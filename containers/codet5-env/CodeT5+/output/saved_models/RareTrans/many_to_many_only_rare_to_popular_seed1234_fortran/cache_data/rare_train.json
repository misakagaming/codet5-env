{"id": 99, "name": "Arithmetic_Integer", "source": "Translate Fortran to C#:  INTEGER A, B\n PRINT *, 'Type in two integer numbers separated by white space',\n+         ' and press ENTER'\n READ *, A, B\n PRINT *, '   A + B = ', (A + B)\n PRINT *, '   A - B = ', (A - B)\n PRINT *, '   A * B = ', (A * B)\n PRINT *, '   A / B = ', (A / B)\n PRINT *, 'MOD(A,B) = ', MOD(A,B)\n PRINT *\n PRINT *, 'Even though you did not ask, ',\n+         'exponentiation is an intrinsic op in Fortran, so...'\n PRINT *, '  A ** B = ', (A ** B)\n END\n", "target": "using System;\n\nclass Program\n{\n    static void Main(string[] args)\n    {\n        int a = Convert.ToInt32(args[0]);\n        int b = Convert.ToInt32(args[1]);\n\n        Console.WriteLine(\"{0} + {1} = {2}\", a, b, a + b);\n        Console.WriteLine(\"{0} - {1} = {2}\", a, b, a - b);\n        Console.WriteLine(\"{0} * {1} = {2}\", a, b, a * b);\n        Console.WriteLine(\"{0} / {1} = {2}\", a, b, a / b); \n        Console.WriteLine(\"{0}\u00a0% {1} = {2}\", a, b, a % b); \n        Console.WriteLine(\"{0} to the power of {1} = {2}\", a, b, Math.Pow(a, b));\n    }\n}\n"}
{"id": 103, "name": "Arithmetic_Integer", "source": "Translate Fortran to Java:  INTEGER A, B\n PRINT *, 'Type in two integer numbers separated by white space',\n+         ' and press ENTER'\n READ *, A, B\n PRINT *, '   A + B = ', (A + B)\n PRINT *, '   A - B = ', (A - B)\n PRINT *, '   A * B = ', (A * B)\n PRINT *, '   A / B = ', (A / B)\n PRINT *, 'MOD(A,B) = ', MOD(A,B)\n PRINT *\n PRINT *, 'Even though you did not ask, ',\n+         'exponentiation is an intrinsic op in Fortran, so...'\n PRINT *, '  A ** B = ', (A ** B)\n END\n", "target": "import java.util.Scanner;\n\npublic class IntegerArithmetic {\n    public static void main(String[] args) {\n        \n        Scanner sc = new Scanner(System.in);\n        int a = sc.nextInt();\n        int b = sc.nextInt();\n\n        int sum = a + b;        \n        int difference = a - b; \n        int product = a * b;    \n        int division = a / b;   \n        int remainder = a % b;  \n\n        System.out.println(\"a + b = \" + sum);\n        System.out.println(\"a - b = \" + difference);\n        System.out.println(\"a * b = \" + product);\n        System.out.println(\"quotient of a / b = \" + division);   \n        System.out.println(\"remainder of a / b = \" + remainder);   \n    }\n}\n"}
{"id": 104, "name": "Arithmetic_Integer", "source": "Translate Fortran to Python:  INTEGER A, B\n PRINT *, 'Type in two integer numbers separated by white space',\n+         ' and press ENTER'\n READ *, A, B\n PRINT *, '   A + B = ', (A + B)\n PRINT *, '   A - B = ', (A - B)\n PRINT *, '   A * B = ', (A * B)\n PRINT *, '   A / B = ', (A / B)\n PRINT *, 'MOD(A,B) = ', MOD(A,B)\n PRINT *\n PRINT *, 'Even though you did not ask, ',\n+         'exponentiation is an intrinsic op in Fortran, so...'\n PRINT *, '  A ** B = ', (A ** B)\n END\n", "target": "x = int(raw_input(\"Number 1: \"))\ny = int(raw_input(\"Number 2: \"))\n\nprint \"Sum: %d\" % (x + y)\nprint \"Difference: %d\" % (x - y)\nprint \"Product: %d\" % (x * y)\nprint \"Quotient: %d\" % (x / y)     \n                                   \nprint \"Remainder: %d\" % (x % y)    \nprint \"Quotient: %d with Remainder: %d\" % divmod(x, y)\nprint \"Power: %d\" % x**y\n\n\nraw_input( )\n"}
{"id": 648, "name": "Percentage difference between images", "source": "Translate Fortran to C#: program ImageDifference\n\n  use RCImageBasic\n  use RCImageIO\n\n  implicit none\n\n  integer, parameter :: input1_u = 20, &\n                        input2_u = 21\n\n  type(rgbimage) :: lenna1, lenna2\n  real           :: totaldiff\n\n\n  open(input1_u, file=\"Lenna100.ppm\", action=\"read\")\n  open(input2_u, file=\"Lenna50.ppm\", action=\"read\")\n  call read_ppm(input1_u, lenna1)\n  call read_ppm(input2_u, lenna2)\n  close(input1_u)\n  close(input2_u)\n\n  totaldiff = sum(  (abs(lenna1%red - lenna2%red) + &\n                     abs(lenna1%green - lenna2%green) + &\n                     abs(lenna1%blue - lenna2%blue)) / 255.0 )\n\n\n  print *, 100.0 * totaldiff / (lenna1%width * lenna1%height * 3.0)\n\n  call free_img(lenna1)\n  call free_img(lenna2)\n\nend program ImageDifference\n", "target": "using System;\nusing System.Drawing;\n\nclass Program\n{\n    static void Main()\n    {\n        Bitmap img1 = new Bitmap(\"Lenna50.jpg\");\n        Bitmap img2 = new Bitmap(\"Lenna100.jpg\");\n\n        if (img1.Size != img2.Size)\n        {\n            Console.Error.WriteLine(\"Images are of different sizes\");\n            return;\n        }\n\n        float diff = 0;\n\n        for (int y = 0; y < img1.Height; y++)\n        {\n            for (int x = 0; x < img1.Width; x++)\n            {\n                Color pixel1 = img1.GetPixel(x, y);\n                Color pixel2 = img2.GetPixel(x, y);\n\n                diff += Math.Abs(pixel1.R - pixel2.R);\n                diff += Math.Abs(pixel1.G - pixel2.G);\n                diff += Math.Abs(pixel1.B - pixel2.B);\n            }\n        }\n\n        Console.WriteLine(\"diff: {0}\u00a0%\", 100 * (diff / 255) / (img1.Width * img1.Height * 3));\n    }\n}\n"}
{"id": 652, "name": "Percentage difference between images", "source": "Translate Fortran to Java: program ImageDifference\n\n  use RCImageBasic\n  use RCImageIO\n\n  implicit none\n\n  integer, parameter :: input1_u = 20, &\n                        input2_u = 21\n\n  type(rgbimage) :: lenna1, lenna2\n  real           :: totaldiff\n\n\n  open(input1_u, file=\"Lenna100.ppm\", action=\"read\")\n  open(input2_u, file=\"Lenna50.ppm\", action=\"read\")\n  call read_ppm(input1_u, lenna1)\n  call read_ppm(input2_u, lenna2)\n  close(input1_u)\n  close(input2_u)\n\n  totaldiff = sum(  (abs(lenna1%red - lenna2%red) + &\n                     abs(lenna1%green - lenna2%green) + &\n                     abs(lenna1%blue - lenna2%blue)) / 255.0 )\n\n\n  print *, 100.0 * totaldiff / (lenna1%width * lenna1%height * 3.0)\n\n  call free_img(lenna1)\n  call free_img(lenna2)\n\nend program ImageDifference\n", "target": "import java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.io.IOException;\nimport javax.imageio.ImageIO;\n\npublic enum ImgDiffPercent {\n    ;\n\n    public static void main(String[] args) throws IOException {\n        \n        \n        BufferedImage img1 = ImageIO.read(new File(\"Lenna50.jpg\"));\n        BufferedImage img2 = ImageIO.read(new File(\"Lenna100.jpg\"));\n\n        double p = getDifferencePercent(img1, img2);\n        System.out.println(\"diff percent: \" + p);\n    }\n\n    private static double getDifferencePercent(BufferedImage img1, BufferedImage img2) {\n        int width = img1.getWidth();\n        int height = img1.getHeight();\n        int width2 = img2.getWidth();\n        int height2 = img2.getHeight();\n        if (width != width2 || height != height2) {\n            throw new IllegalArgumentException(String.format(\"Images must have the same dimensions: (%d,%d) vs. (%d,%d)\", width, height, width2, height2));\n        }\n\n        long diff = 0;\n        for (int y = 0; y < height; y++) {\n            for (int x = 0; x < width; x++) {\n                diff += pixelDiff(img1.getRGB(x, y), img2.getRGB(x, y));\n            }\n        }\n        long maxDiff = 3L * 255 * width * height;\n\n        return 100.0 * diff / maxDiff;\n    }\n\n    private static int pixelDiff(int rgb1, int rgb2) {\n        int r1 = (rgb1 >> 16) & 0xff;\n        int g1 = (rgb1 >>  8) & 0xff;\n        int b1 =  rgb1        & 0xff;\n        int r2 = (rgb2 >> 16) & 0xff;\n        int g2 = (rgb2 >>  8) & 0xff;\n        int b2 =  rgb2        & 0xff;\n        return Math.abs(r1 - r2) + Math.abs(g1 - g2) + Math.abs(b1 - b2);\n    }\n}\n"}
{"id": 653, "name": "Percentage difference between images", "source": "Translate Fortran to Python: program ImageDifference\n\n  use RCImageBasic\n  use RCImageIO\n\n  implicit none\n\n  integer, parameter :: input1_u = 20, &\n                        input2_u = 21\n\n  type(rgbimage) :: lenna1, lenna2\n  real           :: totaldiff\n\n\n  open(input1_u, file=\"Lenna100.ppm\", action=\"read\")\n  open(input2_u, file=\"Lenna50.ppm\", action=\"read\")\n  call read_ppm(input1_u, lenna1)\n  call read_ppm(input2_u, lenna2)\n  close(input1_u)\n  close(input2_u)\n\n  totaldiff = sum(  (abs(lenna1%red - lenna2%red) + &\n                     abs(lenna1%green - lenna2%green) + &\n                     abs(lenna1%blue - lenna2%blue)) / 255.0 )\n\n\n  print *, 100.0 * totaldiff / (lenna1%width * lenna1%height * 3.0)\n\n  call free_img(lenna1)\n  call free_img(lenna2)\n\nend program ImageDifference\n", "target": "from PIL import Image\n\ni1 = Image.open(\"image1.jpg\")\ni2 = Image.open(\"image2.jpg\")\nassert i1.mode == i2.mode, \"Different kinds of images.\"\nassert i1.size == i2.size, \"Different sizes.\"\n\npairs = zip(i1.getdata(), i2.getdata())\nif len(i1.getbands()) == 1:\n    \n    dif = sum(abs(p1-p2) for p1,p2 in pairs)\nelse:\n    dif = sum(abs(c1-c2) for p1,p2 in pairs for c1,c2 in zip(p1,p2))\n\nncomponents = i1.size[0] * i1.size[1] * 3\nprint (\"Difference (percentage):\", (dif / 255.0 * 100) / ncomponents)\n"}
{"id": 833, "name": "Bitwise operations", "source": "Translate Fortran to C#: integer :: i, j = -1, k = 42\nlogical :: a\n    \ni = bit_size(j)       \n    \n\ni = iand(k, j)        \ni = ior(k, j)         \ni = ieor(k, j)        \ni = not(j)            \n    \n\na = btest(i, 4)       \ni = ibclr(k, 8)       \ni = ibset(k, 13)      \n    \n\ni = ishft(k, j)       \n                      \ni = ishftc(k, j)      \n                      \ni = ishftc(k, j, 20)  \n                      \ni = ibits(k, 7, 8)    \n                      \n                      \n                      \n", "target": "static void bitwise(int a, int b)\n        {\n            Console.WriteLine(\"a and b is {0}\", a & b);\n            Console.WriteLine(\"a or b is {0}\", a | b);\n            Console.WriteLine(\"a xor b is {0}\", a ^ b);\n            Console.WriteLine(\"not a is {0}\", ~a);\n            Console.WriteLine(\"a lshift b is {0}\", a << b);\n            Console.WriteLine(\"a arshift b is {0}\", a >> b); \n                                                             \n            uint c = (uint)a;\n            Console.WriteLine(\"c rshift b is {0}\", c >> b); \n                                                            \n            \n        }\n"}
{"id": 836, "name": "Bitwise operations", "source": "Translate Fortran to Java: integer :: i, j = -1, k = 42\nlogical :: a\n    \ni = bit_size(j)       \n    \n\ni = iand(k, j)        \ni = ior(k, j)         \ni = ieor(k, j)        \ni = not(j)            \n    \n\na = btest(i, 4)       \ni = ibclr(k, 8)       \ni = ibset(k, 13)      \n    \n\ni = ishft(k, j)       \n                      \ni = ishftc(k, j)      \n                      \ni = ishftc(k, j, 20)  \n                      \ni = ibits(k, 7, 8)    \n                      \n                      \n                      \n", "target": "module BitwiseOps\n    {\n    @Inject Console console;\n    void run()\n        {\n        for ((Int64 n1, Int64 n2) : [0=7, 1=5, 42=2, 0x123456789ABCDEF=0xFF])  \n            {\n            static String hex(Int64 n)   \n                {\n                \n                return n.toByteArray() [(n.leadingZeroCount / 8).minOf(7) ..< 8].toString();\n                }\n\n            console.print($|For values {n1} ({hex(n1)}) and {n2} ({hex(n2)}):\n                           |  {hex(n1)} AND {hex(n2)} = {hex(n1 & n2)}\n                           |  {hex(n1)} OR {hex(n2)} = {hex(n1 | n2)}\n                           |  {hex(n1)} XOR {hex(n2)} = {hex(n1 ^ n2)}\n                           |  NOT {hex(n1)} = {hex(~n1)}\n                           |  left shift {hex(n1)} by {n2} = {hex(n1 << n2)}\n                           |  right shift {hex(n1)} by {n2} = {hex(n1 >> n2)}\n                           |  right arithmetic shift {hex(n1)} by {n2} = {hex(n1 >>> n2)}\n                           |  left rotate {hex(n1)} by {n2} = {hex(n1.rotateLeft(n2))}\n                           |  right rotate {hex(n1)} by {n2} = {hex(n1.rotateRight(n2))}\n                           |  leftmost bit of {hex(n1)} = {hex(n1.leftmostBit)}\n                           |  rightmost bit of {hex(n1)} = {hex(n1.rightmostBit)}\n                           |  leading zero count of {hex(n1)} = {n1.leadingZeroCount}\n                           |  trailing zero count of {hex(n1)} = {n1.trailingZeroCount}\n                           |  bit count (aka \"population\") of {hex(n1)} = {n1.bitCount}\n                           |  reversed bits of {hex(n1)} = {hex(n1.reverseBits())}\n                           |  reverse bytes of {hex(n1)} = {hex(n1.reverseBytes())}\n                           |\n                         );\n            }\n        }\n    }\n"}
{"id": 837, "name": "Bitwise operations", "source": "Translate Fortran to Python: integer :: i, j = -1, k = 42\nlogical :: a\n    \ni = bit_size(j)       \n    \n\ni = iand(k, j)        \ni = ior(k, j)         \ni = ieor(k, j)        \ni = not(j)            \n    \n\na = btest(i, 4)       \ni = ibclr(k, 8)       \ni = ibset(k, 13)      \n    \n\ni = ishft(k, j)       \n                      \ni = ishftc(k, j)      \n                      \ni = ishftc(k, j, 20)  \n                      \ni = ibits(k, 7, 8)    \n                      \n                      \n                      \n", "target": "def bitwise_built_ins(width, a, b):\n    mask = (1 << width) - 1\n    print(f)\n\ndef rotr(width, a, n):\n    \"Rotate a, n times to the right\"\n    if n < 0:\n        return rotl(width, a, -n)\n    elif n == 0:\n        return a\n    else:\n        mask = (1 << width) - 1\n        a, n = a & mask, n % width\n        return ((a >> n)    \n                | ((a & ((1 << n) - 1))   \n                   << (width - n)))  \n\ndef rotl(width, a, n):\n    \"Rotate a, n times to the left\"\n    if n < 0:\n        return rotr(width, a, -n)\n    elif n == 0:\n        return a\n    else:\n        mask = (1 << width) - 1\n        a, n = a & mask, n % width\n        return (((a << n) & mask)      \n                | (a >> (width - n)))  \n    \ndef asr(width, a, n):\n    \"Arithmetic shift a, n times to the right. (sign preserving).\"\n    mask, top_bit_mask = ((1 << width) - 1), 1 << (width - 1)\n    if n < 0:\n        return  (a << -n) & mask\n    elif n == 0:\n        return a\n    elif n >= width:\n        return mask if a & top_bit_mask else 0\n    else:\n        a = a & mask\n        if a & top_bit_mask:    \n            signs = (1 << n) - 1\n            return a >> n | (signs << width - n)\n        else:\n            return a >> n\n    \n      \ndef helper_funcs(width, a):\n    mask, top_bit_mask = ((1 << width) - 1), 1 << (width - 1)\n    aa = a | top_bit_mask  \n    print(f)\n\nif __name__ == '__main__':\n    bitwise_built_ins(8, 27, 125)\n    helper_funcs(8, 27)\n"}
{"id": 1085, "name": "Stem-and-leaf plot", "source": "Translate Fortran to C#:       SUBROUTINE COMBSORT(A,N)\n       INTEGER A(*)\t\n       INTEGER N\t\n       INTEGER H,T\t\n       LOGICAL CURSE\n        H = N - 1\t\t\n    1   H = MAX(1,H*10/13)\t\n        IF (H.EQ.9 .OR. H.EQ.10) H = 11\t\n        CURSE = .FALSE.\t\t\n        DO I = N - H,1,-1\t\n          IF (A(I) .GT. A(I + H)) THEN\t\n            T=A(I); A(I)=A(I+H); A(I+H)=T\t\n            CURSE = .TRUE.\t\t\t\n          END IF\t\t\t\n        END DO\t\t\t\n        IF (CURSE .OR. H.GT.1) GO TO 1\t\n      END SUBROUTINE COMBSORT\t\n\n      SUBROUTINE TOPIARY(A,N)\t\n       INTEGER A(*)\t\t\n       INTEGER N\t\t\n       INTEGER CLIP\t\t\n       PARAMETER (CLIP = 10)\t\n       INTEGER I1,I2,STEM\t\n        CALL COMBSORT(A,N)\t\n        STEM = A(1)/CLIP\t\n        I1 = 1\t\t\t\n        I2 = I1\t\t\t\n   10   I2 = I2 + 1\t\t\t\n        IF (I2 .GT. N) GO TO 11\t\t\n        IF (A(I2)/CLIP .EQ.STEM) GO TO 10\t\nCast forth a STEM line, corresponding to elements I1:I2 - 1.\n   11   WRITE (6,12) STEM,ABS(MOD(A(I1:I2 - 1),CLIP))\t\n   12   FORMAT (I4,\"|\",(100I1))\t\t\n        IF (I2 .GT. N) RETURN\t\t\n        I1 = I2\t\t\t\t\nChug along to the next STEM value.\n   13   STEM = STEM + 1\t\t\t\n        IF (A(I2)/CLIP.GT.STEM) GO TO 11\n        GO TO 10\t\t\t\n      END SUBROUTINE TOPIARY\t\n\n      PROGRAM TEST\n      INTEGER VALUES(121)\t\n      DATA VALUES/\t\t\n     o  12,127, 28, 42, 39,113, 42, 18, 44,118,\t\n     1  44, 37,113,124, 37, 48,127, 36, 29, 31,\t\n     2 125,139,131,115,105,132,104,123, 35,113,\n     3 122, 42,117,119, 58,109, 23,105, 63, 27,\n     4  44,105, 99, 41,128,121,116,125, 32, 61,\n     5  37,127, 29,113,121, 58,114,126, 53,114,\n     6  96, 25,109,  7, 31,141, 46, 13, 27, 43,\n     7 117,116, 27,  7, 68, 40, 31,115,124, 42,\n     8 128, 52, 71,118,117, 38, 27,106, 33,117,\n     9 116,111, 40,119, 47,105, 57,122,109,124,\n     o 115, 43,120, 43, 27, 27, 18, 28, 48,125,\n     1 107,114, 34,133, 45,120, 30,127, 31,116,\n     2 146/\n        CALL TOPIARY(VALUES,121)\n      END\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Threading.Tasks;\n\nclass Program\n{\n    static void Main()\n    {\n        const string data =\n        \"12 127 28 42 39 113 42 18 44 118 44 37 113 124 37 48 127 36 29 31 \" +\n        \"125 139 131 115 105 132 104 123 35 113 122 42 117 119 58 109 23 \" +\n        \"105 63 27 44 105 99 41 128 121 116 125 32 61 37 127 29 113 121 58 \" +\n        \"114 126 53 114 96 25 109 7 31 141 46 13 27 43 117 116 27 7 68 40 31 \" +\n        \"115 124 42 128 52 71 118 117 38 27 106 33 117 116 111 40 119 47 \" +\n        \"105 57 122 109 124 115 43 120 43 27 27 18 28 48 125 107 114 34 \" +\n        \"133 45 120 30 127 31 116 146\";\n\n        int[] ints = data.Split(' ').Select(int.Parse).ToArray();\n\n        StemAndLeafPlot(ints);\n\n        Console.ReadKey();\n    }\n\n    public static void StemAndLeafPlot(int[] arr)\n    {\n        int stemMax = arr.Max() / 10;\n        int stemMin = arr.Min() / 10;\n        Array.Sort(arr);\n\n        for (int i = stemMin; i <= stemMax; i++)\n        {\n            Console.Write(\"{0,3} | \", i);\n            foreach (var t in arr)\n            {\n                if (t < 10 * i)\n                    continue;\n                if (t >= 10 * (i + 1))\n                    break;\n                Console.Write(\"{0} \", t % 10);\n            }\n            Console.WriteLine(\"\");\n        }\n    }\n}\n"}
{"id": 1088, "name": "Stem-and-leaf plot", "source": "Translate Fortran to Java:       SUBROUTINE COMBSORT(A,N)\n       INTEGER A(*)\t\n       INTEGER N\t\n       INTEGER H,T\t\n       LOGICAL CURSE\n        H = N - 1\t\t\n    1   H = MAX(1,H*10/13)\t\n        IF (H.EQ.9 .OR. H.EQ.10) H = 11\t\n        CURSE = .FALSE.\t\t\n        DO I = N - H,1,-1\t\n          IF (A(I) .GT. A(I + H)) THEN\t\n            T=A(I); A(I)=A(I+H); A(I+H)=T\t\n            CURSE = .TRUE.\t\t\t\n          END IF\t\t\t\n        END DO\t\t\t\n        IF (CURSE .OR. H.GT.1) GO TO 1\t\n      END SUBROUTINE COMBSORT\t\n\n      SUBROUTINE TOPIARY(A,N)\t\n       INTEGER A(*)\t\t\n       INTEGER N\t\t\n       INTEGER CLIP\t\t\n       PARAMETER (CLIP = 10)\t\n       INTEGER I1,I2,STEM\t\n        CALL COMBSORT(A,N)\t\n        STEM = A(1)/CLIP\t\n        I1 = 1\t\t\t\n        I2 = I1\t\t\t\n   10   I2 = I2 + 1\t\t\t\n        IF (I2 .GT. N) GO TO 11\t\t\n        IF (A(I2)/CLIP .EQ.STEM) GO TO 10\t\nCast forth a STEM line, corresponding to elements I1:I2 - 1.\n   11   WRITE (6,12) STEM,ABS(MOD(A(I1:I2 - 1),CLIP))\t\n   12   FORMAT (I4,\"|\",(100I1))\t\t\n        IF (I2 .GT. N) RETURN\t\t\n        I1 = I2\t\t\t\t\nChug along to the next STEM value.\n   13   STEM = STEM + 1\t\t\t\n        IF (A(I2)/CLIP.GT.STEM) GO TO 11\n        GO TO 10\t\t\t\n      END SUBROUTINE TOPIARY\t\n\n      PROGRAM TEST\n      INTEGER VALUES(121)\t\n      DATA VALUES/\t\t\n     o  12,127, 28, 42, 39,113, 42, 18, 44,118,\t\n     1  44, 37,113,124, 37, 48,127, 36, 29, 31,\t\n     2 125,139,131,115,105,132,104,123, 35,113,\n     3 122, 42,117,119, 58,109, 23,105, 63, 27,\n     4  44,105, 99, 41,128,121,116,125, 32, 61,\n     5  37,127, 29,113,121, 58,114,126, 53,114,\n     6  96, 25,109,  7, 31,141, 46, 13, 27, 43,\n     7 117,116, 27,  7, 68, 40, 31,115,124, 42,\n     8 128, 52, 71,118,117, 38, 27,106, 33,117,\n     9 116,111, 40,119, 47,105, 57,122,109,124,\n     o 115, 43,120, 43, 27, 27, 18, 28, 48,125,\n     1 107,114, 34,133, 45,120, 30,127, 31,116,\n     2 146/\n        CALL TOPIARY(VALUES,121)\n      END\n", "target": "import java.util.Collections;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.TreeMap;\n\npublic class StemAndLeaf {\n\tprivate static int[] data = { 12, 127, 28, 42, 39, 113, 42, 18, 44, 118,\n\t\t\t44, 37, 113, 124, 37, 48, 127, 36, 29, 31, 125, 139, 131, 115, 105,\n\t\t\t132, 104, 123, 35, 113, 122, 42, 117, 119, 58, 109, 23, 105, 63,\n\t\t\t27, 44, 105, 99, 41, 128, 121, 116, 125, 32, 61, 37, 127, 29, 113,\n\t\t\t121, 58, 114, 126, 53, 114, 96, 25, 109, 7, 31, 141, 46, 13, 27,\n\t\t\t43, 117, 116, 27, 7, 68, 40, 31, 115, 124, 42, 128, 52, 71, 118,\n\t\t\t117, 38, 27, 106, 33, 117, 116, 111, 40, 119, 47, 105, 57, 122,\n\t\t\t109, 124, 115, 43, 120, 43, 27, 27, 18, 28, 48, 125, 107, 114, 34,\n\t\t\t133, 45, 120, 30, 127, 31, 116, 146 };\n\t\n\tpublic static Map<Integer, List<Integer>> createPlot(int... data){\n\t\tMap<Integer, List<Integer>> plot = new TreeMap<Integer, List<Integer>>();\n\t\tint highestStem = -1; \n\t\tfor(int datum:data){\n\t\t\tint leaf = datum % 10;\n\t\t\tint stem = datum / 10; \n\t\t\tif(stem > highestStem){\n\t\t\t\thighestStem = stem;\n\t\t\t}\n\t\t\tif(plot.containsKey(stem)){\n\t\t\t\tplot.get(stem).add(leaf);\n\t\t\t}else{\n\t\t\t\tLinkedList<Integer> list = new LinkedList<Integer>();\n\t\t\t\tlist.add(leaf);\n\t\t\t\tplot.put(stem, list);\n\t\t\t}\n\t\t}\n\t\tif(plot.keySet().size() < highestStem + 1  ){\n\t\t\tfor(int i = 0; i <= highestStem; i++){\n\t\t\t\tif(!plot.containsKey(i)){\n\t\t\t\t\tLinkedList<Integer> list = new LinkedList<Integer>();\n\t\t\t\t\tplot.put(i, list);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn plot;\n\t}\n\t\n\tpublic static void printPlot(Map<Integer, List<Integer>> plot){\n\t\tfor(Map.Entry<Integer, List<Integer>> line : plot.entrySet()){\n\t\t\tCollections.sort(line.getValue());\n\t\t\tSystem.out.println(line.getKey() + \" | \" + line.getValue());\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args){\n\t\tMap<Integer, List<Integer>> plot = createPlot(data);\n\t\tprintPlot(plot);\n\t}\n}\n"}
{"id": 1089, "name": "Stem-and-leaf plot", "source": "Translate Fortran to Python:       SUBROUTINE COMBSORT(A,N)\n       INTEGER A(*)\t\n       INTEGER N\t\n       INTEGER H,T\t\n       LOGICAL CURSE\n        H = N - 1\t\t\n    1   H = MAX(1,H*10/13)\t\n        IF (H.EQ.9 .OR. H.EQ.10) H = 11\t\n        CURSE = .FALSE.\t\t\n        DO I = N - H,1,-1\t\n          IF (A(I) .GT. A(I + H)) THEN\t\n            T=A(I); A(I)=A(I+H); A(I+H)=T\t\n            CURSE = .TRUE.\t\t\t\n          END IF\t\t\t\n        END DO\t\t\t\n        IF (CURSE .OR. H.GT.1) GO TO 1\t\n      END SUBROUTINE COMBSORT\t\n\n      SUBROUTINE TOPIARY(A,N)\t\n       INTEGER A(*)\t\t\n       INTEGER N\t\t\n       INTEGER CLIP\t\t\n       PARAMETER (CLIP = 10)\t\n       INTEGER I1,I2,STEM\t\n        CALL COMBSORT(A,N)\t\n        STEM = A(1)/CLIP\t\n        I1 = 1\t\t\t\n        I2 = I1\t\t\t\n   10   I2 = I2 + 1\t\t\t\n        IF (I2 .GT. N) GO TO 11\t\t\n        IF (A(I2)/CLIP .EQ.STEM) GO TO 10\t\nCast forth a STEM line, corresponding to elements I1:I2 - 1.\n   11   WRITE (6,12) STEM,ABS(MOD(A(I1:I2 - 1),CLIP))\t\n   12   FORMAT (I4,\"|\",(100I1))\t\t\n        IF (I2 .GT. N) RETURN\t\t\n        I1 = I2\t\t\t\t\nChug along to the next STEM value.\n   13   STEM = STEM + 1\t\t\t\n        IF (A(I2)/CLIP.GT.STEM) GO TO 11\n        GO TO 10\t\t\t\n      END SUBROUTINE TOPIARY\t\n\n      PROGRAM TEST\n      INTEGER VALUES(121)\t\n      DATA VALUES/\t\t\n     o  12,127, 28, 42, 39,113, 42, 18, 44,118,\t\n     1  44, 37,113,124, 37, 48,127, 36, 29, 31,\t\n     2 125,139,131,115,105,132,104,123, 35,113,\n     3 122, 42,117,119, 58,109, 23,105, 63, 27,\n     4  44,105, 99, 41,128,121,116,125, 32, 61,\n     5  37,127, 29,113,121, 58,114,126, 53,114,\n     6  96, 25,109,  7, 31,141, 46, 13, 27, 43,\n     7 117,116, 27,  7, 68, 40, 31,115,124, 42,\n     8 128, 52, 71,118,117, 38, 27,106, 33,117,\n     9 116,111, 40,119, 47,105, 57,122,109,124,\n     o 115, 43,120, 43, 27, 27, 18, 28, 48,125,\n     1 107,114, 34,133, 45,120, 30,127, 31,116,\n     2 146/\n        CALL TOPIARY(VALUES,121)\n      END\n", "target": "from collections import namedtuple\nfrom pprint import pprint as pp\nfrom math import floor\n\nStem = namedtuple('Stem', 'data, leafdigits')\n\ndata0 = Stem((12, 127, 28, 42, 39, 113, 42, 18, 44, 118, 44, 37, 113, 124, 37,\n              48, 127, 36, 29, 31, 125, 139, 131, 115, 105, 132, 104, 123, 35,\n              113, 122, 42, 117, 119, 58, 109, 23, 105, 63, 27, 44, 105, 99,\n              41, 128, 121, 116, 125, 32, 61, 37, 127, 29, 113, 121, 58, 114,\n              126, 53, 114, 96, 25, 109, 7, 31, 141, 46, 13, 27, 43, 117, 116,\n              27, 7, 68, 40, 31, 115, 124, 42, 128, 52, 71, 118, 117, 38, 27,\n              106, 33, 117, 116, 111, 40, 119, 47, 105, 57, 122, 109, 124, 115,\n              43, 120, 43, 27, 27, 18, 28, 48, 125, 107, 114, 34, 133, 45, 120,\n              30, 127, 31, 116, 146),\n             1.0)\n\ndef stemplot(stem):\n    d = []\n    interval = int(10**int(stem.leafdigits))\n    for data in sorted(stem.data):\n        data = int(floor(data))\n        stm, lf = divmod(data,interval)\n        d.append( (int(stm), int(lf)) )\n    stems, leafs = list(zip(*d))\n    stemwidth = max(len(str(x)) for x in stems)\n    leafwidth = max(len(str(x)) for x in leafs)\n    laststem, out = min(stems) - 1, []\n    for s,l in d:\n        while laststem < s:\n            laststem += 1\n            out.append('\\n%*i |' % ( stemwidth, laststem))\n        out.append(' %0*i' % (leafwidth, l))\n    out.append('\\n\\nKey:\\n Stem multiplier: %i\\n X | Y  =>  %i*X+Y\\n'\n               % (interval, interval))\n    return ''.join(out)\n\nif __name__ == '__main__':\n    print( stemplot(data0) )\n"}
{"id": 1325, "name": "Flatten a list", "source": "Translate Fortran to C#: \n\n\nmodule flat\n  implicit none\n\n  type n\n     integer                             :: a\n     type(n), dimension(:), pointer      :: p => null()\n     logical                             :: empty = .false.\n  end type\n\ncontains\n\n  recursive subroutine del(this)\n  type(n), intent(inout) :: this\n  integer                :: i\n  if (associated(this%p)) then\n    do i = 1, size(this%p)\n       call del(this%p(i))\n    end do\n  end if\n  end subroutine\n\n  function join(xs) result (r)\n  type(n), dimension(:), target :: xs\n  type(n)                       :: r\n  integer                       :: i\n  if (size(xs)>0) then\n    allocate(r%p(size(xs)), source=xs)\n    do i = 1, size(xs)\n      r%p(i) = xs(i)\n    end do\n  else\n    r%empty = .true.\n  end if\n  end function\n\n  recursive subroutine flatten1(x,r) \n  integer, dimension (:), allocatable, intent(inout) :: r\n  type(n), intent(in)                                :: x\n  integer, dimension (:), allocatable                :: tmp\n  integer                                            :: i\n  if (associated(x%p)) then\n    do i = 1, size(x%p)\n      call flatten1(x%p(i), r)\n    end do\n  elseif (.not. x%empty) then\n    allocate(tmp(size(r)+1))\n    tmp(1:size(r)) = r\n    tmp(size(r)+1) = x%a\n    call move_alloc(tmp, r)\n  end if\n  end subroutine\n\n  function flatten(x) result (r)\n  type(n), intent(in)                                :: x\n  integer, dimension(:), allocatable                 :: r\n  allocate(r(0))\n  call flatten1(x,r)\n  end function\n\n  recursive subroutine show(x)\n  type(n)   :: x\n  integer   :: i\n  if (x%empty) then \n    write (*, \"(a)\", advance=\"no\") \"[]\"\n  elseif (associated(x%p)) then\n    write (*, \"(a)\", advance=\"no\") \"[\"\n    do i = 1, size(x%p)\n      call show(x%p(i))\n      if (i<size(x%p)) then\n        write (*, \"(a)\", advance=\"no\") \", \"\n      end if\n    end do\n    write (*, \"(a)\", advance=\"no\") \"]\"\n  else\n    write (*, \"(g0)\", advance=\"no\") x%a\n  end if\n  end subroutine\n\n  function fromString(line) result (r)\n  character(len=*)                      :: line\n  type (n)                              :: r\n  type (n), dimension(:), allocatable   :: buffer, buffer1\n  integer, dimension(:), allocatable    :: stack, stack1\n  integer                               :: sp,i0,i,j, a, cur, start\n  character                             :: c\n \n  if (.not. allocated(buffer)) then\n    allocate (buffer(5)) \n  end if\n  if (.not. allocated(stack)) then\n    allocate (stack(5))\n  end if\n\n  sp = 1; cur = 1; i = 1\n  do\n    if ( i > len_trim(line) ) exit\n    c = line(i:i)\n    if (c==\"[\") then\n      if (sp>size(stack)) then \n        allocate(stack1(2*size(stack)))\n        stack1(1:size(stack)) = stack\n        call move_alloc(stack1, stack)\n      end if\n      stack(sp) = cur;  sp = sp + 1; i = i+1\n    elseif (c==\"]\") then\n      sp = sp - 1; start = stack(sp)\n      r = join(buffer(start:cur-1))\n      do j = start, cur-1\n        call del(buffer(j))\n      end do\n      buffer(start) = r; cur = start+1; i = i+1\n    elseif (index(\" ,\",c)>0) then\n      i = i + 1; continue\n    elseif (index(\"-123456789\",c)>0) then\n      i0 = i\n      do \n        if ((i>len_trim(line)).or. &\n            index(\"1234567890\",line(i:i))==0) then\n          read(line(i0:i-1),*) a\n          if (cur>size(buffer)) then\n            allocate(buffer1(2*size(buffer)))\n            buffer1(1:size(buffer)) = buffer\n            call move_alloc(buffer1, buffer)\n          end if\n          buffer(cur) = n(a); cur = cur + 1; exit\n        else\n          i = i+1\n        end if\n      end do\n    else\n       stop \"input corrupted\"\n    end if\n  end do\n  end function\nend module\n\nprogram main\n  use flat\n  type (n)  :: x\n  x = fromString(\"[[1], 2, [[3,4], 5], [[[]]], [[[6]]], 7, 8, []]\")\n  write(*, \"(a)\", advance=\"no\") \"input  \u00a0: \"\n  call show(x)\n  print *\n  write (*,\"(a)\", advance=\"no\") \"flatten\u00a0: [\"\n  write (*, \"(*(i0,:,:', '))\", advance=\"no\") flatten(x)\n  print *, \"]\"\nend program\n", "target": "using System;\nusing System.Collections;\nusing System.Linq;\n\nnamespace RosettaCodeTasks\n{\n\tstatic class FlattenList\n\t{\n\t\tpublic static ArrayList Flatten(this ArrayList List)\n\t\t{\n\t\t\tArrayList NewList = new ArrayList ( );\n\n\t\t\tNewList.AddRange ( List );\n\n\t\t\twhile ( NewList.OfType<ArrayList> ( ).Count ( ) > 0 )\n\t\t\t{\n\t\t\t\tint index = NewList.IndexOf ( NewList.OfType<ArrayList> ( ).ElementAt ( 0 ) );\n\t\t\t\tArrayList Temp = (ArrayList)NewList[index];\n\t\t\t\tNewList.RemoveAt ( index );\n\t\t\t\tNewList.InsertRange ( index, Temp );\n\t\t\t}\n\t\t\t\n\t\t\treturn NewList;\n\t\t}\n\t}\n}\n"}
{"id": 1326, "name": "Flatten a list", "source": "Translate Fortran to C#: \n\n\nmodule flat\n  implicit none\n\n  type n\n     integer                             :: a\n     type(n), dimension(:), pointer      :: p => null()\n     logical                             :: empty = .false.\n  end type\n\ncontains\n\n  recursive subroutine del(this)\n  type(n), intent(inout) :: this\n  integer                :: i\n  if (associated(this%p)) then\n    do i = 1, size(this%p)\n       call del(this%p(i))\n    end do\n  end if\n  end subroutine\n\n  function join(xs) result (r)\n  type(n), dimension(:), target :: xs\n  type(n)                       :: r\n  integer                       :: i\n  if (size(xs)>0) then\n    allocate(r%p(size(xs)), source=xs)\n    do i = 1, size(xs)\n      r%p(i) = xs(i)\n    end do\n  else\n    r%empty = .true.\n  end if\n  end function\n\n  recursive subroutine flatten1(x,r) \n  integer, dimension (:), allocatable, intent(inout) :: r\n  type(n), intent(in)                                :: x\n  integer, dimension (:), allocatable                :: tmp\n  integer                                            :: i\n  if (associated(x%p)) then\n    do i = 1, size(x%p)\n      call flatten1(x%p(i), r)\n    end do\n  elseif (.not. x%empty) then\n    allocate(tmp(size(r)+1))\n    tmp(1:size(r)) = r\n    tmp(size(r)+1) = x%a\n    call move_alloc(tmp, r)\n  end if\n  end subroutine\n\n  function flatten(x) result (r)\n  type(n), intent(in)                                :: x\n  integer, dimension(:), allocatable                 :: r\n  allocate(r(0))\n  call flatten1(x,r)\n  end function\n\n  recursive subroutine show(x)\n  type(n)   :: x\n  integer   :: i\n  if (x%empty) then \n    write (*, \"(a)\", advance=\"no\") \"[]\"\n  elseif (associated(x%p)) then\n    write (*, \"(a)\", advance=\"no\") \"[\"\n    do i = 1, size(x%p)\n      call show(x%p(i))\n      if (i<size(x%p)) then\n        write (*, \"(a)\", advance=\"no\") \", \"\n      end if\n    end do\n    write (*, \"(a)\", advance=\"no\") \"]\"\n  else\n    write (*, \"(g0)\", advance=\"no\") x%a\n  end if\n  end subroutine\n\n  function fromString(line) result (r)\n  character(len=*)                      :: line\n  type (n)                              :: r\n  type (n), dimension(:), allocatable   :: buffer, buffer1\n  integer, dimension(:), allocatable    :: stack, stack1\n  integer                               :: sp,i0,i,j, a, cur, start\n  character                             :: c\n \n  if (.not. allocated(buffer)) then\n    allocate (buffer(5)) \n  end if\n  if (.not. allocated(stack)) then\n    allocate (stack(5))\n  end if\n\n  sp = 1; cur = 1; i = 1\n  do\n    if ( i > len_trim(line) ) exit\n    c = line(i:i)\n    if (c==\"[\") then\n      if (sp>size(stack)) then \n        allocate(stack1(2*size(stack)))\n        stack1(1:size(stack)) = stack\n        call move_alloc(stack1, stack)\n      end if\n      stack(sp) = cur;  sp = sp + 1; i = i+1\n    elseif (c==\"]\") then\n      sp = sp - 1; start = stack(sp)\n      r = join(buffer(start:cur-1))\n      do j = start, cur-1\n        call del(buffer(j))\n      end do\n      buffer(start) = r; cur = start+1; i = i+1\n    elseif (index(\" ,\",c)>0) then\n      i = i + 1; continue\n    elseif (index(\"-123456789\",c)>0) then\n      i0 = i\n      do \n        if ((i>len_trim(line)).or. &\n            index(\"1234567890\",line(i:i))==0) then\n          read(line(i0:i-1),*) a\n          if (cur>size(buffer)) then\n            allocate(buffer1(2*size(buffer)))\n            buffer1(1:size(buffer)) = buffer\n            call move_alloc(buffer1, buffer)\n          end if\n          buffer(cur) = n(a); cur = cur + 1; exit\n        else\n          i = i+1\n        end if\n      end do\n    else\n       stop \"input corrupted\"\n    end if\n  end do\n  end function\nend module\n\nprogram main\n  use flat\n  type (n)  :: x\n  x = fromString(\"[[1], 2, [[3,4], 5], [[[]]], [[[6]]], 7, 8, []]\")\n  write(*, \"(a)\", advance=\"no\") \"input  \u00a0: \"\n  call show(x)\n  print *\n  write (*,\"(a)\", advance=\"no\") \"flatten\u00a0: [\"\n  write (*, \"(*(i0,:,:', '))\", advance=\"no\") flatten(x)\n  print *, \"]\"\nend program\n", "target": "using System;\nusing System.Collections;\nusing System.Linq;\n\nnamespace RosettaCodeTasks\n{\n\tstatic class FlattenList\n\t{\n\t\tpublic static ArrayList Flatten(this ArrayList List)\n\t\t{\n\t\t\tArrayList NewList = new ArrayList ( );\n\n\t\t\tNewList.AddRange ( List );\n\n\t\t\twhile ( NewList.OfType<ArrayList> ( ).Count ( ) > 0 )\n\t\t\t{\n\t\t\t\tint index = NewList.IndexOf ( NewList.OfType<ArrayList> ( ).ElementAt ( 0 ) );\n\t\t\t\tArrayList Temp = (ArrayList)NewList[index];\n\t\t\t\tNewList.RemoveAt ( index );\n\t\t\t\tNewList.InsertRange ( index, Temp );\n\t\t\t}\n\t\t\t\n\t\t\treturn NewList;\n\t\t}\n\t}\n}\n"}
{"id": 1332, "name": "Flatten a list", "source": "Translate Fortran to Java: \n\n\nmodule flat\n  implicit none\n\n  type n\n     integer                             :: a\n     type(n), dimension(:), pointer      :: p => null()\n     logical                             :: empty = .false.\n  end type\n\ncontains\n\n  recursive subroutine del(this)\n  type(n), intent(inout) :: this\n  integer                :: i\n  if (associated(this%p)) then\n    do i = 1, size(this%p)\n       call del(this%p(i))\n    end do\n  end if\n  end subroutine\n\n  function join(xs) result (r)\n  type(n), dimension(:), target :: xs\n  type(n)                       :: r\n  integer                       :: i\n  if (size(xs)>0) then\n    allocate(r%p(size(xs)), source=xs)\n    do i = 1, size(xs)\n      r%p(i) = xs(i)\n    end do\n  else\n    r%empty = .true.\n  end if\n  end function\n\n  recursive subroutine flatten1(x,r) \n  integer, dimension (:), allocatable, intent(inout) :: r\n  type(n), intent(in)                                :: x\n  integer, dimension (:), allocatable                :: tmp\n  integer                                            :: i\n  if (associated(x%p)) then\n    do i = 1, size(x%p)\n      call flatten1(x%p(i), r)\n    end do\n  elseif (.not. x%empty) then\n    allocate(tmp(size(r)+1))\n    tmp(1:size(r)) = r\n    tmp(size(r)+1) = x%a\n    call move_alloc(tmp, r)\n  end if\n  end subroutine\n\n  function flatten(x) result (r)\n  type(n), intent(in)                                :: x\n  integer, dimension(:), allocatable                 :: r\n  allocate(r(0))\n  call flatten1(x,r)\n  end function\n\n  recursive subroutine show(x)\n  type(n)   :: x\n  integer   :: i\n  if (x%empty) then \n    write (*, \"(a)\", advance=\"no\") \"[]\"\n  elseif (associated(x%p)) then\n    write (*, \"(a)\", advance=\"no\") \"[\"\n    do i = 1, size(x%p)\n      call show(x%p(i))\n      if (i<size(x%p)) then\n        write (*, \"(a)\", advance=\"no\") \", \"\n      end if\n    end do\n    write (*, \"(a)\", advance=\"no\") \"]\"\n  else\n    write (*, \"(g0)\", advance=\"no\") x%a\n  end if\n  end subroutine\n\n  function fromString(line) result (r)\n  character(len=*)                      :: line\n  type (n)                              :: r\n  type (n), dimension(:), allocatable   :: buffer, buffer1\n  integer, dimension(:), allocatable    :: stack, stack1\n  integer                               :: sp,i0,i,j, a, cur, start\n  character                             :: c\n \n  if (.not. allocated(buffer)) then\n    allocate (buffer(5)) \n  end if\n  if (.not. allocated(stack)) then\n    allocate (stack(5))\n  end if\n\n  sp = 1; cur = 1; i = 1\n  do\n    if ( i > len_trim(line) ) exit\n    c = line(i:i)\n    if (c==\"[\") then\n      if (sp>size(stack)) then \n        allocate(stack1(2*size(stack)))\n        stack1(1:size(stack)) = stack\n        call move_alloc(stack1, stack)\n      end if\n      stack(sp) = cur;  sp = sp + 1; i = i+1\n    elseif (c==\"]\") then\n      sp = sp - 1; start = stack(sp)\n      r = join(buffer(start:cur-1))\n      do j = start, cur-1\n        call del(buffer(j))\n      end do\n      buffer(start) = r; cur = start+1; i = i+1\n    elseif (index(\" ,\",c)>0) then\n      i = i + 1; continue\n    elseif (index(\"-123456789\",c)>0) then\n      i0 = i\n      do \n        if ((i>len_trim(line)).or. &\n            index(\"1234567890\",line(i:i))==0) then\n          read(line(i0:i-1),*) a\n          if (cur>size(buffer)) then\n            allocate(buffer1(2*size(buffer)))\n            buffer1(1:size(buffer)) = buffer\n            call move_alloc(buffer1, buffer)\n          end if\n          buffer(cur) = n(a); cur = cur + 1; exit\n        else\n          i = i+1\n        end if\n      end do\n    else\n       stop \"input corrupted\"\n    end if\n  end do\n  end function\nend module\n\nprogram main\n  use flat\n  type (n)  :: x\n  x = fromString(\"[[1], 2, [[3,4], 5], [[[]]], [[[6]]], 7, 8, []]\")\n  write(*, \"(a)\", advance=\"no\") \"input  \u00a0: \"\n  call show(x)\n  print *\n  write (*,\"(a)\", advance=\"no\") \"flatten\u00a0: [\"\n  write (*, \"(*(i0,:,:', '))\", advance=\"no\") flatten(x)\n  print *, \"]\"\nend program\n", "target": "import java.util.LinkedList;\nimport java.util.List;\n\n\npublic final class FlattenUtil {\n\n\tpublic static List<Object> flatten(List<?> list) {\n\t\tList<Object> retVal = new LinkedList<Object>();\n\t\tflatten(list, retVal);\n\t\treturn retVal;\n\t}\n\n\tpublic static void flatten(List<?> fromTreeList, List<Object> toFlatList) {\n\t\tfor (Object item : fromTreeList) {\n\t\t\tif (item instanceof List<?>) {\n\t\t\t\tflatten((List<?>) item, toFlatList);\n\t\t\t} else {\n\t\t\t\ttoFlatList.add(item);\n\t\t\t}\n\t\t}\n\t}\n}\n"}
{"id": 1333, "name": "Flatten a list", "source": "Translate Fortran to Java: \n\n\nmodule flat\n  implicit none\n\n  type n\n     integer                             :: a\n     type(n), dimension(:), pointer      :: p => null()\n     logical                             :: empty = .false.\n  end type\n\ncontains\n\n  recursive subroutine del(this)\n  type(n), intent(inout) :: this\n  integer                :: i\n  if (associated(this%p)) then\n    do i = 1, size(this%p)\n       call del(this%p(i))\n    end do\n  end if\n  end subroutine\n\n  function join(xs) result (r)\n  type(n), dimension(:), target :: xs\n  type(n)                       :: r\n  integer                       :: i\n  if (size(xs)>0) then\n    allocate(r%p(size(xs)), source=xs)\n    do i = 1, size(xs)\n      r%p(i) = xs(i)\n    end do\n  else\n    r%empty = .true.\n  end if\n  end function\n\n  recursive subroutine flatten1(x,r) \n  integer, dimension (:), allocatable, intent(inout) :: r\n  type(n), intent(in)                                :: x\n  integer, dimension (:), allocatable                :: tmp\n  integer                                            :: i\n  if (associated(x%p)) then\n    do i = 1, size(x%p)\n      call flatten1(x%p(i), r)\n    end do\n  elseif (.not. x%empty) then\n    allocate(tmp(size(r)+1))\n    tmp(1:size(r)) = r\n    tmp(size(r)+1) = x%a\n    call move_alloc(tmp, r)\n  end if\n  end subroutine\n\n  function flatten(x) result (r)\n  type(n), intent(in)                                :: x\n  integer, dimension(:), allocatable                 :: r\n  allocate(r(0))\n  call flatten1(x,r)\n  end function\n\n  recursive subroutine show(x)\n  type(n)   :: x\n  integer   :: i\n  if (x%empty) then \n    write (*, \"(a)\", advance=\"no\") \"[]\"\n  elseif (associated(x%p)) then\n    write (*, \"(a)\", advance=\"no\") \"[\"\n    do i = 1, size(x%p)\n      call show(x%p(i))\n      if (i<size(x%p)) then\n        write (*, \"(a)\", advance=\"no\") \", \"\n      end if\n    end do\n    write (*, \"(a)\", advance=\"no\") \"]\"\n  else\n    write (*, \"(g0)\", advance=\"no\") x%a\n  end if\n  end subroutine\n\n  function fromString(line) result (r)\n  character(len=*)                      :: line\n  type (n)                              :: r\n  type (n), dimension(:), allocatable   :: buffer, buffer1\n  integer, dimension(:), allocatable    :: stack, stack1\n  integer                               :: sp,i0,i,j, a, cur, start\n  character                             :: c\n \n  if (.not. allocated(buffer)) then\n    allocate (buffer(5)) \n  end if\n  if (.not. allocated(stack)) then\n    allocate (stack(5))\n  end if\n\n  sp = 1; cur = 1; i = 1\n  do\n    if ( i > len_trim(line) ) exit\n    c = line(i:i)\n    if (c==\"[\") then\n      if (sp>size(stack)) then \n        allocate(stack1(2*size(stack)))\n        stack1(1:size(stack)) = stack\n        call move_alloc(stack1, stack)\n      end if\n      stack(sp) = cur;  sp = sp + 1; i = i+1\n    elseif (c==\"]\") then\n      sp = sp - 1; start = stack(sp)\n      r = join(buffer(start:cur-1))\n      do j = start, cur-1\n        call del(buffer(j))\n      end do\n      buffer(start) = r; cur = start+1; i = i+1\n    elseif (index(\" ,\",c)>0) then\n      i = i + 1; continue\n    elseif (index(\"-123456789\",c)>0) then\n      i0 = i\n      do \n        if ((i>len_trim(line)).or. &\n            index(\"1234567890\",line(i:i))==0) then\n          read(line(i0:i-1),*) a\n          if (cur>size(buffer)) then\n            allocate(buffer1(2*size(buffer)))\n            buffer1(1:size(buffer)) = buffer\n            call move_alloc(buffer1, buffer)\n          end if\n          buffer(cur) = n(a); cur = cur + 1; exit\n        else\n          i = i+1\n        end if\n      end do\n    else\n       stop \"input corrupted\"\n    end if\n  end do\n  end function\nend module\n\nprogram main\n  use flat\n  type (n)  :: x\n  x = fromString(\"[[1], 2, [[3,4], 5], [[[]]], [[[6]]], 7, 8, []]\")\n  write(*, \"(a)\", advance=\"no\") \"input  \u00a0: \"\n  call show(x)\n  print *\n  write (*,\"(a)\", advance=\"no\") \"flatten\u00a0: [\"\n  write (*, \"(*(i0,:,:', '))\", advance=\"no\") flatten(x)\n  print *, \"]\"\nend program\n", "target": "import java.util.LinkedList;\nimport java.util.List;\n\n\npublic final class FlattenUtil {\n\n\tpublic static List<Object> flatten(List<?> list) {\n\t\tList<Object> retVal = new LinkedList<Object>();\n\t\tflatten(list, retVal);\n\t\treturn retVal;\n\t}\n\n\tpublic static void flatten(List<?> fromTreeList, List<Object> toFlatList) {\n\t\tfor (Object item : fromTreeList) {\n\t\t\tif (item instanceof List<?>) {\n\t\t\t\tflatten((List<?>) item, toFlatList);\n\t\t\t} else {\n\t\t\t\ttoFlatList.add(item);\n\t\t\t}\n\t\t}\n\t}\n}\n"}
{"id": 1334, "name": "Flatten a list", "source": "Translate Fortran to Python: \n\n\nmodule flat\n  implicit none\n\n  type n\n     integer                             :: a\n     type(n), dimension(:), pointer      :: p => null()\n     logical                             :: empty = .false.\n  end type\n\ncontains\n\n  recursive subroutine del(this)\n  type(n), intent(inout) :: this\n  integer                :: i\n  if (associated(this%p)) then\n    do i = 1, size(this%p)\n       call del(this%p(i))\n    end do\n  end if\n  end subroutine\n\n  function join(xs) result (r)\n  type(n), dimension(:), target :: xs\n  type(n)                       :: r\n  integer                       :: i\n  if (size(xs)>0) then\n    allocate(r%p(size(xs)), source=xs)\n    do i = 1, size(xs)\n      r%p(i) = xs(i)\n    end do\n  else\n    r%empty = .true.\n  end if\n  end function\n\n  recursive subroutine flatten1(x,r) \n  integer, dimension (:), allocatable, intent(inout) :: r\n  type(n), intent(in)                                :: x\n  integer, dimension (:), allocatable                :: tmp\n  integer                                            :: i\n  if (associated(x%p)) then\n    do i = 1, size(x%p)\n      call flatten1(x%p(i), r)\n    end do\n  elseif (.not. x%empty) then\n    allocate(tmp(size(r)+1))\n    tmp(1:size(r)) = r\n    tmp(size(r)+1) = x%a\n    call move_alloc(tmp, r)\n  end if\n  end subroutine\n\n  function flatten(x) result (r)\n  type(n), intent(in)                                :: x\n  integer, dimension(:), allocatable                 :: r\n  allocate(r(0))\n  call flatten1(x,r)\n  end function\n\n  recursive subroutine show(x)\n  type(n)   :: x\n  integer   :: i\n  if (x%empty) then \n    write (*, \"(a)\", advance=\"no\") \"[]\"\n  elseif (associated(x%p)) then\n    write (*, \"(a)\", advance=\"no\") \"[\"\n    do i = 1, size(x%p)\n      call show(x%p(i))\n      if (i<size(x%p)) then\n        write (*, \"(a)\", advance=\"no\") \", \"\n      end if\n    end do\n    write (*, \"(a)\", advance=\"no\") \"]\"\n  else\n    write (*, \"(g0)\", advance=\"no\") x%a\n  end if\n  end subroutine\n\n  function fromString(line) result (r)\n  character(len=*)                      :: line\n  type (n)                              :: r\n  type (n), dimension(:), allocatable   :: buffer, buffer1\n  integer, dimension(:), allocatable    :: stack, stack1\n  integer                               :: sp,i0,i,j, a, cur, start\n  character                             :: c\n \n  if (.not. allocated(buffer)) then\n    allocate (buffer(5)) \n  end if\n  if (.not. allocated(stack)) then\n    allocate (stack(5))\n  end if\n\n  sp = 1; cur = 1; i = 1\n  do\n    if ( i > len_trim(line) ) exit\n    c = line(i:i)\n    if (c==\"[\") then\n      if (sp>size(stack)) then \n        allocate(stack1(2*size(stack)))\n        stack1(1:size(stack)) = stack\n        call move_alloc(stack1, stack)\n      end if\n      stack(sp) = cur;  sp = sp + 1; i = i+1\n    elseif (c==\"]\") then\n      sp = sp - 1; start = stack(sp)\n      r = join(buffer(start:cur-1))\n      do j = start, cur-1\n        call del(buffer(j))\n      end do\n      buffer(start) = r; cur = start+1; i = i+1\n    elseif (index(\" ,\",c)>0) then\n      i = i + 1; continue\n    elseif (index(\"-123456789\",c)>0) then\n      i0 = i\n      do \n        if ((i>len_trim(line)).or. &\n            index(\"1234567890\",line(i:i))==0) then\n          read(line(i0:i-1),*) a\n          if (cur>size(buffer)) then\n            allocate(buffer1(2*size(buffer)))\n            buffer1(1:size(buffer)) = buffer\n            call move_alloc(buffer1, buffer)\n          end if\n          buffer(cur) = n(a); cur = cur + 1; exit\n        else\n          i = i+1\n        end if\n      end do\n    else\n       stop \"input corrupted\"\n    end if\n  end do\n  end function\nend module\n\nprogram main\n  use flat\n  type (n)  :: x\n  x = fromString(\"[[1], 2, [[3,4], 5], [[[]]], [[[6]]], 7, 8, []]\")\n  write(*, \"(a)\", advance=\"no\") \"input  \u00a0: \"\n  call show(x)\n  print *\n  write (*,\"(a)\", advance=\"no\") \"flatten\u00a0: [\"\n  write (*, \"(*(i0,:,:', '))\", advance=\"no\") flatten(x)\n  print *, \"]\"\nend program\n", "target": ">>> def flatten(lst):\n\treturn sum( ([x] if not isinstance(x, list) else flatten(x)\n\t\t     for x in lst), [] )\n\n>>> lst = [[1], 2, [[3,4], 5], [[[]]], [[[6]]], 7, 8, []]\n>>> flatten(lst)\n[1, 2, 3, 4, 5, 6, 7, 8]\n"}
{"id": 1335, "name": "Flatten a list", "source": "Translate Fortran to Python: \n\n\nmodule flat\n  implicit none\n\n  type n\n     integer                             :: a\n     type(n), dimension(:), pointer      :: p => null()\n     logical                             :: empty = .false.\n  end type\n\ncontains\n\n  recursive subroutine del(this)\n  type(n), intent(inout) :: this\n  integer                :: i\n  if (associated(this%p)) then\n    do i = 1, size(this%p)\n       call del(this%p(i))\n    end do\n  end if\n  end subroutine\n\n  function join(xs) result (r)\n  type(n), dimension(:), target :: xs\n  type(n)                       :: r\n  integer                       :: i\n  if (size(xs)>0) then\n    allocate(r%p(size(xs)), source=xs)\n    do i = 1, size(xs)\n      r%p(i) = xs(i)\n    end do\n  else\n    r%empty = .true.\n  end if\n  end function\n\n  recursive subroutine flatten1(x,r) \n  integer, dimension (:), allocatable, intent(inout) :: r\n  type(n), intent(in)                                :: x\n  integer, dimension (:), allocatable                :: tmp\n  integer                                            :: i\n  if (associated(x%p)) then\n    do i = 1, size(x%p)\n      call flatten1(x%p(i), r)\n    end do\n  elseif (.not. x%empty) then\n    allocate(tmp(size(r)+1))\n    tmp(1:size(r)) = r\n    tmp(size(r)+1) = x%a\n    call move_alloc(tmp, r)\n  end if\n  end subroutine\n\n  function flatten(x) result (r)\n  type(n), intent(in)                                :: x\n  integer, dimension(:), allocatable                 :: r\n  allocate(r(0))\n  call flatten1(x,r)\n  end function\n\n  recursive subroutine show(x)\n  type(n)   :: x\n  integer   :: i\n  if (x%empty) then \n    write (*, \"(a)\", advance=\"no\") \"[]\"\n  elseif (associated(x%p)) then\n    write (*, \"(a)\", advance=\"no\") \"[\"\n    do i = 1, size(x%p)\n      call show(x%p(i))\n      if (i<size(x%p)) then\n        write (*, \"(a)\", advance=\"no\") \", \"\n      end if\n    end do\n    write (*, \"(a)\", advance=\"no\") \"]\"\n  else\n    write (*, \"(g0)\", advance=\"no\") x%a\n  end if\n  end subroutine\n\n  function fromString(line) result (r)\n  character(len=*)                      :: line\n  type (n)                              :: r\n  type (n), dimension(:), allocatable   :: buffer, buffer1\n  integer, dimension(:), allocatable    :: stack, stack1\n  integer                               :: sp,i0,i,j, a, cur, start\n  character                             :: c\n \n  if (.not. allocated(buffer)) then\n    allocate (buffer(5)) \n  end if\n  if (.not. allocated(stack)) then\n    allocate (stack(5))\n  end if\n\n  sp = 1; cur = 1; i = 1\n  do\n    if ( i > len_trim(line) ) exit\n    c = line(i:i)\n    if (c==\"[\") then\n      if (sp>size(stack)) then \n        allocate(stack1(2*size(stack)))\n        stack1(1:size(stack)) = stack\n        call move_alloc(stack1, stack)\n      end if\n      stack(sp) = cur;  sp = sp + 1; i = i+1\n    elseif (c==\"]\") then\n      sp = sp - 1; start = stack(sp)\n      r = join(buffer(start:cur-1))\n      do j = start, cur-1\n        call del(buffer(j))\n      end do\n      buffer(start) = r; cur = start+1; i = i+1\n    elseif (index(\" ,\",c)>0) then\n      i = i + 1; continue\n    elseif (index(\"-123456789\",c)>0) then\n      i0 = i\n      do \n        if ((i>len_trim(line)).or. &\n            index(\"1234567890\",line(i:i))==0) then\n          read(line(i0:i-1),*) a\n          if (cur>size(buffer)) then\n            allocate(buffer1(2*size(buffer)))\n            buffer1(1:size(buffer)) = buffer\n            call move_alloc(buffer1, buffer)\n          end if\n          buffer(cur) = n(a); cur = cur + 1; exit\n        else\n          i = i+1\n        end if\n      end do\n    else\n       stop \"input corrupted\"\n    end if\n  end do\n  end function\nend module\n\nprogram main\n  use flat\n  type (n)  :: x\n  x = fromString(\"[[1], 2, [[3,4], 5], [[[]]], [[[6]]], 7, 8, []]\")\n  write(*, \"(a)\", advance=\"no\") \"input  \u00a0: \"\n  call show(x)\n  print *\n  write (*,\"(a)\", advance=\"no\") \"flatten\u00a0: [\"\n  write (*, \"(*(i0,:,:', '))\", advance=\"no\") flatten(x)\n  print *, \"]\"\nend program\n", "target": ">>> def flatten(lst):\n\treturn sum( ([x] if not isinstance(x, list) else flatten(x)\n\t\t     for x in lst), [] )\n\n>>> lst = [[1], 2, [[3,4], 5], [[[]]], [[[6]]], 7, 8, []]\n>>> flatten(lst)\n[1, 2, 3, 4, 5, 6, 7, 8]\n"}
{"id": 2148, "name": "String interpolation (included)", "source": "Translate Fortran to C#: program interpolate\n\n  write (*,*) trim(inter(\"Mary had a X lamb.\",\"X\",\"little\"))\n\ncontains\n\n  elemental function inter(string,place,ins) result(new)\n    character(len=*), intent(in)                          :: string,place,ins\n    character(len=len(string)+max(0,len(ins)-len(place))) :: new\n    integer                                               :: idx\n    idx = index(string,place)\n    if ( idx == 0 ) then\n      new = string\n    else\n      new = string(1:idx-1)//ins//string(idx+len(place):len(string))\n    end if\n  end function inter\n  \nend program interpolate\n", "target": "class Program\n{\n    static void Main()\n    {\n        string extra = \"little\";\n        string formatted = $\"Mary had a {extra} lamb.\";\n        System.Console.WriteLine(formatted);\n    }\n}\n"}
{"id": 2152, "name": "String interpolation (included)", "source": "Translate Fortran to Java: program interpolate\n\n  write (*,*) trim(inter(\"Mary had a X lamb.\",\"X\",\"little\"))\n\ncontains\n\n  elemental function inter(string,place,ins) result(new)\n    character(len=*), intent(in)                          :: string,place,ins\n    character(len=len(string)+max(0,len(ins)-len(place))) :: new\n    integer                                               :: idx\n    idx = index(string,place)\n    if ( idx == 0 ) then\n      new = string\n    else\n      new = string(1:idx-1)//ins//string(idx+len(place):len(string))\n    end if\n  end function inter\n  \nend program interpolate\n", "target": "String original = \"Mary had a X lamb\";\nString little = \"little\";\nString replaced = original.replace(\"X\", little); \nSystem.out.println(replaced);\n\nSystem.out.printf(\"Mary had a %s lamb.\", little);\n\nString formatted = String.format(\"Mary had a %s lamb.\", little);\nSystem.out.println(formatted);\n"}
{"id": 2153, "name": "String interpolation (included)", "source": "Translate Fortran to Python: program interpolate\n\n  write (*,*) trim(inter(\"Mary had a X lamb.\",\"X\",\"little\"))\n\ncontains\n\n  elemental function inter(string,place,ins) result(new)\n    character(len=*), intent(in)                          :: string,place,ins\n    character(len=len(string)+max(0,len(ins)-len(place))) :: new\n    integer                                               :: idx\n    idx = index(string,place)\n    if ( idx == 0 ) then\n      new = string\n    else\n      new = string(1:idx-1)//ins//string(idx+len(place):len(string))\n    end if\n  end function inter\n  \nend program interpolate\n", "target": ">>> original = 'Mary had a %s lamb.'\n>>> extra = 'little'\n>>> original % extra\n'Mary had a little lamb.'\n"}
{"id": 2485, "name": "Babbage problem", "source": "Translate Fortran to C#:       DO 3 N=1,99736\n      IF(MODF(N*N,1000000)-269696)3,4,3\n 3    CONTINUE\n 4    PRINT 5,N\n 5    FORMAT(I6)\n      STOP\n", "target": "namespace Babbage_Problem\n{\n    class iterateNumbers\n    {\n        public iterateNumbers()\n        {\n            long baseNumberSquared = 0; \n            long baseNumber = 0;  \n\n            do  \n            {\n                baseNumber += 1; \n                baseNumberSquared = baseNumber * baseNumber; \n            }\n            while (Right6Digits(baseNumberSquared) != 269696); \n\n            Console.WriteLine(\"The smallest integer whose square ends in 269,696 is \" + baseNumber);\n            Console.WriteLine(\"The square is \" + baseNumberSquared);\n\n        }\n\n        private long Right6Digits(long baseNumberSquared)\n        {\n\n            string numberAsString = baseNumberSquared.ToString(); \n\n            if (numberAsString.Length < 6) { return baseNumberSquared; }; \n\n            numberAsString = numberAsString.Substring(numberAsString.Length - 6);  \n\n            return long.Parse(numberAsString); \n\n        }\n    }\n}}\n"}
{"id": 2486, "name": "Babbage problem", "source": "Translate Fortran to C#:       DO 3 N=1,99736\n      IF(MODF(N*N,1000000)-269696)3,4,3\n 3    CONTINUE\n 4    PRINT 5,N\n 5    FORMAT(I6)\n      STOP\n", "target": "namespace Babbage_Problem\n{\n    class iterateNumbers\n    {\n        public iterateNumbers()\n        {\n            long baseNumberSquared = 0; \n            long baseNumber = 0;  \n\n            do  \n            {\n                baseNumber += 1; \n                baseNumberSquared = baseNumber * baseNumber; \n            }\n            while (Right6Digits(baseNumberSquared) != 269696); \n\n            Console.WriteLine(\"The smallest integer whose square ends in 269,696 is \" + baseNumber);\n            Console.WriteLine(\"The square is \" + baseNumberSquared);\n\n        }\n\n        private long Right6Digits(long baseNumberSquared)\n        {\n\n            string numberAsString = baseNumberSquared.ToString(); \n\n            if (numberAsString.Length < 6) { return baseNumberSquared; }; \n\n            numberAsString = numberAsString.Substring(numberAsString.Length - 6);  \n\n            return long.Parse(numberAsString); \n\n        }\n    }\n}}\n"}
{"id": 2492, "name": "Babbage problem", "source": "Translate Fortran to Java:       DO 3 N=1,99736\n      IF(MODF(N*N,1000000)-269696)3,4,3\n 3    CONTINUE\n 4    PRINT 5,N\n 5    FORMAT(I6)\n      STOP\n", "target": "public class Test {\n\n    public static void main(String[] args) {\n\n        \n        int n = 0;\n\n        \n        do {\n\n            \n            n++;\n\n        \n        } while (n * n % 1000_000 != 269696);\n\n        \n        System.out.println(n);\n    }\n}\n"}
{"id": 2493, "name": "Babbage problem", "source": "Translate Fortran to Java:       DO 3 N=1,99736\n      IF(MODF(N*N,1000000)-269696)3,4,3\n 3    CONTINUE\n 4    PRINT 5,N\n 5    FORMAT(I6)\n      STOP\n", "target": "public class Test {\n\n    public static void main(String[] args) {\n\n        \n        int n = 0;\n\n        \n        do {\n\n            \n            n++;\n\n        \n        } while (n * n % 1000_000 != 269696);\n\n        \n        System.out.println(n);\n    }\n}\n"}
{"id": 2494, "name": "Babbage problem", "source": "Translate Fortran to Python:       DO 3 N=1,99736\n      IF(MODF(N*N,1000000)-269696)3,4,3\n 3    CONTINUE\n 4    PRINT 5,N\n 5    FORMAT(I6)\n      STOP\n", "target": "\n\n\nn=0 \n\n\n\n\nwhile n**2 % 1000000 != 269696:\n\n    \n    \n    \n    \n    n += 1 \n\nprint(n) \n"}
{"id": 2495, "name": "Babbage problem", "source": "Translate Fortran to Python:       DO 3 N=1,99736\n      IF(MODF(N*N,1000000)-269696)3,4,3\n 3    CONTINUE\n 4    PRINT 5,N\n 5    FORMAT(I6)\n      STOP\n", "target": "\n\n\nn=0 \n\n\n\n\nwhile n**2 % 1000000 != 269696:\n\n    \n    \n    \n    \n    n += 1 \n\nprint(n) \n"}
{"id": 2904, "name": "Ternary logic", "source": "Translate Fortran to C#: \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nmodule trit\n\n  real, parameter :: true = 1,  false = 0, maybe = 0.5\n\ncontains\n\n  real function tnot(y)\n    real, intent(in) :: y\n    tnot = 1 - y\n  end function tnot\n\n  real function tand(x, y)\n    real, intent(in) :: x, y\n    tand = min(x, y)\n  end function tand\n\n  real function tor(x, y)\n    real, intent(in) :: x, y\n    tor = max(x, y)\n  end function tor\n\n  real function tif(x, y)\n    real, intent(in) :: x, y\n    tif = tor(y, tnot(x))\n  end function tif\n\n  real function teq(x, y)\n    real, intent(in) :: x, y\n    teq = tor(tand(tnot(x), tnot(y)), tand(x, y))\n  end function teq\n\nend module trit\n\nprogram ternaryLogic\n  use trit\n  integer :: i\n  real, dimension(3) :: a = [false, maybe, true] \n  write(6,'(/a)')'ternary not' ; write(6, '(3f4.1/)') (tnot(a(i)), i = 1 , 3)\n  write(6,'(/a)')'ternary and' ; call table(tand, a, a)\n  write(6,'(/a)')'ternary or' ; call table(tor, a, a)\n  write(6,'(/a)')'ternary if' ; call table(tif, a, a)\n  write(6,'(/a)')'ternary eq' ; call table(teq, a, a)\n\ncontains\n\n  subroutine table(u, x, y) \n    real, external :: u\n    real, dimension(3), intent(in) :: x, y\n    integer :: i, j\n    write(6, '(3(3f4.1/))') ((u(x(i), y(j)), j=1,3), i=1,3)\n  end subroutine table\n\nend program ternaryLogic\n", "target": "using System;\n\n\n\n\n\n\n\npublic static class NullableBoolExtension\n{\n    public static bool? Implies(this bool? left, bool? right)\n    {\n        return !left | right;\n    }\n\n    public static bool? IsEquivalentTo(this bool? left, bool? right)\n    {\n        return left.HasValue && right.HasValue ? left == right : default(bool?);\n    }\n\n    public static string Format(this bool? value)\n    {\n        return value.HasValue ? value.Value.ToString() : \"Maybe\";\n    }\n}\n\npublic class Program\n{\n    private static void Main()\n    {\n        var values = new[] { true, default(bool?), false };\n\n        foreach (var left in values)\n        {\n            Console.WriteLine(\"\u00ac{0} = {1}\", left.Format(), (!left).Format());\n            foreach (var right in values)\n            {\n                Console.WriteLine(\"{0} & {1} = {2}\", left.Format(), right.Format(), (left & right).Format());\n                Console.WriteLine(\"{0} | {1} = {2}\", left.Format(), right.Format(), (left | right).Format());\n                Console.WriteLine(\"{0} \u2192 {1} = {2}\", left.Format(), right.Format(), left.Implies(right).Format());\n                Console.WriteLine(\"{0} \u2261 {1} = {2}\", left.Format(), right.Format(), left.IsEquivalentTo(right).Format());\n            }\n        }\n    }\n}\n"}
{"id": 2907, "name": "Ternary logic", "source": "Translate Fortran to Java: \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nmodule trit\n\n  real, parameter :: true = 1,  false = 0, maybe = 0.5\n\ncontains\n\n  real function tnot(y)\n    real, intent(in) :: y\n    tnot = 1 - y\n  end function tnot\n\n  real function tand(x, y)\n    real, intent(in) :: x, y\n    tand = min(x, y)\n  end function tand\n\n  real function tor(x, y)\n    real, intent(in) :: x, y\n    tor = max(x, y)\n  end function tor\n\n  real function tif(x, y)\n    real, intent(in) :: x, y\n    tif = tor(y, tnot(x))\n  end function tif\n\n  real function teq(x, y)\n    real, intent(in) :: x, y\n    teq = tor(tand(tnot(x), tnot(y)), tand(x, y))\n  end function teq\n\nend module trit\n\nprogram ternaryLogic\n  use trit\n  integer :: i\n  real, dimension(3) :: a = [false, maybe, true] \n  write(6,'(/a)')'ternary not' ; write(6, '(3f4.1/)') (tnot(a(i)), i = 1 , 3)\n  write(6,'(/a)')'ternary and' ; call table(tand, a, a)\n  write(6,'(/a)')'ternary or' ; call table(tor, a, a)\n  write(6,'(/a)')'ternary if' ; call table(tif, a, a)\n  write(6,'(/a)')'ternary eq' ; call table(teq, a, a)\n\ncontains\n\n  subroutine table(u, x, y) \n    real, external :: u\n    real, dimension(3), intent(in) :: x, y\n    integer :: i, j\n    write(6, '(3(3f4.1/))') ((u(x(i), y(j)), j=1,3), i=1,3)\n  end subroutine table\n\nend program ternaryLogic\n", "target": "public class Logic{\n\tpublic static enum Trit{\n\t\tTRUE, MAYBE, FALSE;\n\t\t\n\t\tpublic Trit and(Trit other){\n\t\t\tif(this == TRUE){\n\t\t\t\treturn other;\n\t\t\t}else if(this == MAYBE){\n\t\t\t\treturn (other == FALSE) ? FALSE : MAYBE;\n\t\t\t}else{\n\t\t\t\treturn FALSE;\n\t\t\t}\n\t\t}\n\t\t\n\t\tpublic Trit or(Trit other){\n\t\t\tif(this == TRUE){\n\t\t\t\treturn TRUE;\n\t\t\t}else if(this == MAYBE){\n\t\t\t\treturn (other == TRUE) ? TRUE : MAYBE;\n\t\t\t}else{\n\t\t\t\treturn other;\n\t\t\t}\n\t\t}\n\t\t\n\t\tpublic Trit tIf(Trit other){\n\t\t\tif(this == TRUE){\n\t\t\t\treturn other;\n\t\t\t}else if(this == MAYBE){\n\t\t\t\treturn (other == TRUE) ? TRUE : MAYBE;\n\t\t\t}else{\n\t\t\t\treturn TRUE;\n\t\t\t}\n\t\t}\n\t\t\n\t\tpublic Trit not(){\n\t\t\tif(this == TRUE){\n\t\t\t\treturn FALSE;\n\t\t\t}else if(this == MAYBE){\n\t\t\t\treturn MAYBE;\n\t\t\t}else{\n\t\t\t\treturn TRUE;\n\t\t\t}\n\t\t}\n\t\t\n\t\tpublic Trit equals(Trit other){\n\t\t\tif(this == TRUE){\n\t\t\t\treturn other;\n\t\t\t}else if(this == MAYBE){\n\t\t\t\treturn MAYBE;\n\t\t\t}else{\n\t\t\t\treturn other.not();\n\t\t\t}\n\t\t}\n\t}\n\tpublic static void main(String[] args){\n\t\tfor(Trit a:Trit.values()){\n\t\t\tSystem.out.println(\"not \" + a + \": \" + a.not());\n\t\t}\n\t\tfor(Trit a:Trit.values()){\n\t\t\tfor(Trit b:Trit.values()){\n\t\t\t\tSystem.out.println(a+\" and \"+b+\": \"+a.and(b)+\n\t\t\t\t\t\t\"\\t \"+a+\" or \"+b+\": \"+a.or(b)+\n\t\t\t\t\t\t\"\\t \"+a+\" implies \"+b+\": \"+a.tIf(b)+\n\t\t\t\t\t\t\"\\t \"+a+\" = \"+b+\": \"+a.equals(b));\n\t\t\t}\n\t\t}\n\t}\n}\n"}
{"id": 2908, "name": "Ternary logic", "source": "Translate Fortran to Python: \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nmodule trit\n\n  real, parameter :: true = 1,  false = 0, maybe = 0.5\n\ncontains\n\n  real function tnot(y)\n    real, intent(in) :: y\n    tnot = 1 - y\n  end function tnot\n\n  real function tand(x, y)\n    real, intent(in) :: x, y\n    tand = min(x, y)\n  end function tand\n\n  real function tor(x, y)\n    real, intent(in) :: x, y\n    tor = max(x, y)\n  end function tor\n\n  real function tif(x, y)\n    real, intent(in) :: x, y\n    tif = tor(y, tnot(x))\n  end function tif\n\n  real function teq(x, y)\n    real, intent(in) :: x, y\n    teq = tor(tand(tnot(x), tnot(y)), tand(x, y))\n  end function teq\n\nend module trit\n\nprogram ternaryLogic\n  use trit\n  integer :: i\n  real, dimension(3) :: a = [false, maybe, true] \n  write(6,'(/a)')'ternary not' ; write(6, '(3f4.1/)') (tnot(a(i)), i = 1 , 3)\n  write(6,'(/a)')'ternary and' ; call table(tand, a, a)\n  write(6,'(/a)')'ternary or' ; call table(tor, a, a)\n  write(6,'(/a)')'ternary if' ; call table(tif, a, a)\n  write(6,'(/a)')'ternary eq' ; call table(teq, a, a)\n\ncontains\n\n  subroutine table(u, x, y) \n    real, external :: u\n    real, dimension(3), intent(in) :: x, y\n    integer :: i, j\n    write(6, '(3(3f4.1/))') ((u(x(i), y(j)), j=1,3), i=1,3)\n  end subroutine table\n\nend program ternaryLogic\n", "target": "class Trit(int):\n    def __new__(cls, value):\n        if value == 'TRUE':\n            value = 1\n        elif value == 'FALSE':\n            value = 0\n        elif value == 'MAYBE':\n            value = -1\n        return super(Trit, cls).__new__(cls, value // (abs(value) or 1)) \n\n    def __repr__(self):\n        if self > 0:\n            return 'TRUE'\n        elif self == 0:\n            return 'FALSE'\n        return 'MAYBE'\n\n    def __str__(self):\n        return repr(self)\n\n    def __bool__(self):\n        if self > 0:\n            return True\n        elif self == 0:\n            return False\n        else:\n            raise ValueError(\"invalid literal for bool(): '%s'\" % self)\n\n    def __or__(self, other):\n        if isinstance(other, Trit):\n            return _ttable[(self, other)][1]\n        else:\n            try:\n                return _ttable[(self, Trit(bool(other)))][1]\n            except:\n                return NotImplemented\n\n    def __ror__(self, other):\n        if isinstance(other, Trit):\n            return _ttable[(self, other)][1]\n        else:\n            try:\n                return _ttable[(self, Trit(bool(other)))][1]\n            except:\n                return NotImplemented\n\n    def __and__(self, other):\n        if isinstance(other, Trit):\n            return _ttable[(self, other)][0]\n        else:\n            try:\n                return _ttable[(self, Trit(bool(other)))][0]\n            except:\n                return NotImplemented\n\n    def __rand__(self, other):\n        if isinstance(other, Trit):\n            return _ttable[(self, other)][0]\n        else:\n            try:\n                return _ttable[(self, Trit(bool(other)))][0]\n            except:\n                return NotImplemented\n\n    def __xor__(self, other):\n        if isinstance(other, Trit):\n            return _ttable[(self, other)][2]\n        else:\n            try:\n                return _ttable[(self, Trit(bool(other)))][2]\n            except:\n                return NotImplemented\n\n    def __rxor__(self, other):\n        if isinstance(other, Trit):\n            return _ttable[(self, other)][2]\n        else:\n            try:\n                return _ttable[(self, Trit(bool(other)))][2]\n            except:\n                return NotImplemented\n\n    def __invert__(self):\n        return _ttable[self]\n    \n    def __getattr__(self, name):\n        if name in ('_n', 'flip'):\n            \n            \n            \n            return _ttable[self]\n        else:\n            raise AttributeError \n\n\n        \nTRUE, FALSE, MAYBE = Trit(1), Trit(0), Trit(-1)\n\n_ttable = {\n    \n         TRUE: FALSE,\n        FALSE:  TRUE,\n        MAYBE: MAYBE,\n    \n        (MAYBE, MAYBE): (MAYBE, MAYBE, MAYBE),\n        (MAYBE, FALSE): (FALSE, MAYBE, MAYBE),\n        (MAYBE,  TRUE): (MAYBE,  TRUE, MAYBE),\n        (FALSE, MAYBE): (FALSE, MAYBE, MAYBE),\n        (FALSE, FALSE): (FALSE, FALSE, FALSE),\n        (FALSE,  TRUE): (FALSE,  TRUE,  TRUE),\n        ( TRUE, MAYBE): (MAYBE,  TRUE, MAYBE),\n        ( TRUE, FALSE): (FALSE,  TRUE,  TRUE),\n        ( TRUE,  TRUE): ( TRUE,  TRUE, FALSE),\n    }\n\n\nvalues = ('FALSE', 'TRUE ', 'MAYBE')\n\nprint(\"\\nTrit logical inverse, '~'\")\nfor a in values:\n    expr = '~%s' % a\n    print('  %s = %s' % (expr, eval(expr)))\n\nfor op, ophelp in (('&', 'and'), ('|', 'or'), ('^', 'exclusive-or')):\n    print(\"\\nTrit logical %s, '%s'\" % (ophelp, op))\n    for a in values:\n        for b in values:\n            expr = '%s %s %s' % (a, op, b)\n            print('  %s = %s' % (expr, eval(expr)))\n"}
{"id": 3194, "name": "Find limit of recursion", "source": "Translate Fortran to C#: program recursion_depth\n\n  implicit none\n\n  call recurse (1)\n\ncontains\n\n  recursive subroutine recurse (i)\n\n    implicit none\n    integer, intent (in) :: i\n\n    write (*, '(i0)') i\n    call recurse (i + 1)\n\n  end subroutine recurse\n\nend program recursion_depth\n", "target": "using System;\nclass RecursionLimit\n{\n  static void Main(string[] args)\n  {\n    Recur(0);\n  }\n \n  private static void Recur(int i) \n  {\n    Console.WriteLine(i);\n    Recur(i + 1);\n  }\n}\n"}
{"id": 3195, "name": "Find limit of recursion", "source": "Translate Fortran to C#: program recursion_depth\n\n  implicit none\n\n  call recurse (1)\n\ncontains\n\n  recursive subroutine recurse (i)\n\n    implicit none\n    integer, intent (in) :: i\n\n    write (*, '(i0)') i\n    call recurse (i + 1)\n\n  end subroutine recurse\n\nend program recursion_depth\n", "target": "using System;\nclass RecursionLimit\n{\n  static void Main(string[] args)\n  {\n    Recur(0);\n  }\n \n  private static void Recur(int i) \n  {\n    Console.WriteLine(i);\n    Recur(i + 1);\n  }\n}\n"}
{"id": 3200, "name": "Find limit of recursion", "source": "Translate Fortran to Java: program recursion_depth\n\n  implicit none\n\n  call recurse (1)\n\ncontains\n\n  recursive subroutine recurse (i)\n\n    implicit none\n    integer, intent (in) :: i\n\n    write (*, '(i0)') i\n    call recurse (i + 1)\n\n  end subroutine recurse\n\nend program recursion_depth\n", "target": "public class RecursionTest {\n\t\n    private static void recurse(int i) {\n        try {\n\t    recurse(i+1);\n\t} catch (StackOverflowError e) {\n\t    System.out.print(\"Recursion depth on this system is \" + i + \".\");\n\t}\n    }\n\t\n    public static void main(String[] args) {\n        recurse(0);\n    }\n}\n"}
{"id": 3201, "name": "Find limit of recursion", "source": "Translate Fortran to Java: program recursion_depth\n\n  implicit none\n\n  call recurse (1)\n\ncontains\n\n  recursive subroutine recurse (i)\n\n    implicit none\n    integer, intent (in) :: i\n\n    write (*, '(i0)') i\n    call recurse (i + 1)\n\n  end subroutine recurse\n\nend program recursion_depth\n", "target": "public class RecursionTest {\n\t\n    private static void recurse(int i) {\n        try {\n\t    recurse(i+1);\n\t} catch (StackOverflowError e) {\n\t    System.out.print(\"Recursion depth on this system is \" + i + \".\");\n\t}\n    }\n\t\n    public static void main(String[] args) {\n        recurse(0);\n    }\n}\n"}
{"id": 3202, "name": "Find limit of recursion", "source": "Translate Fortran to Python: program recursion_depth\n\n  implicit none\n\n  call recurse (1)\n\ncontains\n\n  recursive subroutine recurse (i)\n\n    implicit none\n    integer, intent (in) :: i\n\n    write (*, '(i0)') i\n    call recurse (i + 1)\n\n  end subroutine recurse\n\nend program recursion_depth\n", "target": "import sys\nprint(sys.getrecursionlimit())\n"}
{"id": 3203, "name": "Find limit of recursion", "source": "Translate Fortran to Python: program recursion_depth\n\n  implicit none\n\n  call recurse (1)\n\ncontains\n\n  recursive subroutine recurse (i)\n\n    implicit none\n    integer, intent (in) :: i\n\n    write (*, '(i0)') i\n    call recurse (i + 1)\n\n  end subroutine recurse\n\nend program recursion_depth\n", "target": "import sys\nprint(sys.getrecursionlimit())\n"}
{"id": 4111, "name": "CSV data manipulation", "source": "Translate Fortran to C#: program rowsum\n    implicit none\n    character(:), allocatable :: line, name, a(:)\n    character(20) :: fmt\n    double precision, allocatable :: v(:)\n    integer :: n, nrow, ncol, i\n    \n    call get_command_argument(1, length=n)\n    allocate(character(n) :: name)\n    call get_command_argument(1, name)\n    open(unit=10, file=name, action=\"read\", form=\"formatted\", access=\"stream\")\n    deallocate(name)\n    \n    call get_command_argument(2, length=n)\n    allocate(character(n) :: name)\n    call get_command_argument(2, name)\n    open(unit=11, file=name, action=\"write\", form=\"formatted\", access=\"stream\")\n    deallocate(name)\n\n    nrow = 0\n    ncol = 0\n    do while (readline(10, line))\n        nrow = nrow + 1\n        \n        call split(line, a)\n        \n        if (nrow == 1) then\n            ncol = size(a)\n            write(11, \"(A)\", advance=\"no\") line\n            write(11, \"(A)\") \",Sum\"\n            allocate(v(ncol + 1))\n            write(fmt, \"('(',G0,'(G0,:,''',A,'''))')\") ncol + 1, \",\"\n        else\n            if (size(a) /= ncol) then\n                print \"(A,' ',G0)\", \"Invalid number of values on row\", nrow\n                stop\n            end if\n\n            do i = 1, ncol\n                read(a(i), *) v(i)\n            end do\n            v(ncol + 1) = sum(v(1:ncol))\n            write(11, fmt) v\n        end if\n    end do\n    close(10)\n    close(11)\ncontains\n    function readline(unit, line)\n        use iso_fortran_env\n        logical :: readline\n        integer :: unit, ios, n\n        character(:), allocatable :: line\n        character(10) :: buffer\n        \n        line = \"\"\n        readline = .false.\n        do\n            read(unit, \"(A)\", advance=\"no\", size=n, iostat=ios) buffer\n            if (ios == iostat_end) return\n            readline = .true.\n            line = line // buffer(1:n)\n            if (ios == iostat_eor) return\n        end do\n    end function\n\n    subroutine split(line, array, separator)\n        character(*) line\n        character(:), allocatable :: array(:)\n        character, optional :: separator\n        character :: sep\n        integer :: n, m, p, i, k\n        \n        if (present(separator)) then\n            sep = separator\n        else\n            sep = \",\"\n        end if\n        \n        n = len(line)\n        m = 0\n        p = 1\n        k = 1\n        do i = 1, n\n            if (line(i:i) == sep) then\n                p = p + 1\n                m = max(m, i - k)\n                k = i + 1\n            end if\n        end do\n        m = max(m, n - k + 1)\n        \n        if (allocated(array)) deallocate(array)\n        allocate(character(m) :: array(p))\n\n        p = 1\n        k = 1\n        do i = 1, n\n            if (line(i:i) == sep) then\n                array(p) = line(k:i-1)\n                p = p + 1\n                k = i + 1\n            end if\n        end do\n        array(p) = line(k:n)\n    end subroutine\nend program\n", "target": "using System.IO;\nusing System.Linq;\n\nnamespace CSV_data_manipulation\n{\n    class Program\n    {\n        static void Main()\n        {\n            var input = File.ReadAllLines(\"test_in.csv\");\n            var output = input.Select((line, i) =>\n            {\n                if (i == 0)\n                    return line + \",SUM\";\n                var sum = line.Split(',').Select(int.Parse).Sum();\n                return line + \",\" + sum;\n            }).ToArray();\n            File.WriteAllLines(\"test_out.csv\", output);\n        }\n    }\n}\n"}
{"id": 4112, "name": "CSV data manipulation", "source": "Translate Fortran to C#: program rowsum\n    implicit none\n    character(:), allocatable :: line, name, a(:)\n    character(20) :: fmt\n    double precision, allocatable :: v(:)\n    integer :: n, nrow, ncol, i\n    \n    call get_command_argument(1, length=n)\n    allocate(character(n) :: name)\n    call get_command_argument(1, name)\n    open(unit=10, file=name, action=\"read\", form=\"formatted\", access=\"stream\")\n    deallocate(name)\n    \n    call get_command_argument(2, length=n)\n    allocate(character(n) :: name)\n    call get_command_argument(2, name)\n    open(unit=11, file=name, action=\"write\", form=\"formatted\", access=\"stream\")\n    deallocate(name)\n\n    nrow = 0\n    ncol = 0\n    do while (readline(10, line))\n        nrow = nrow + 1\n        \n        call split(line, a)\n        \n        if (nrow == 1) then\n            ncol = size(a)\n            write(11, \"(A)\", advance=\"no\") line\n            write(11, \"(A)\") \",Sum\"\n            allocate(v(ncol + 1))\n            write(fmt, \"('(',G0,'(G0,:,''',A,'''))')\") ncol + 1, \",\"\n        else\n            if (size(a) /= ncol) then\n                print \"(A,' ',G0)\", \"Invalid number of values on row\", nrow\n                stop\n            end if\n\n            do i = 1, ncol\n                read(a(i), *) v(i)\n            end do\n            v(ncol + 1) = sum(v(1:ncol))\n            write(11, fmt) v\n        end if\n    end do\n    close(10)\n    close(11)\ncontains\n    function readline(unit, line)\n        use iso_fortran_env\n        logical :: readline\n        integer :: unit, ios, n\n        character(:), allocatable :: line\n        character(10) :: buffer\n        \n        line = \"\"\n        readline = .false.\n        do\n            read(unit, \"(A)\", advance=\"no\", size=n, iostat=ios) buffer\n            if (ios == iostat_end) return\n            readline = .true.\n            line = line // buffer(1:n)\n            if (ios == iostat_eor) return\n        end do\n    end function\n\n    subroutine split(line, array, separator)\n        character(*) line\n        character(:), allocatable :: array(:)\n        character, optional :: separator\n        character :: sep\n        integer :: n, m, p, i, k\n        \n        if (present(separator)) then\n            sep = separator\n        else\n            sep = \",\"\n        end if\n        \n        n = len(line)\n        m = 0\n        p = 1\n        k = 1\n        do i = 1, n\n            if (line(i:i) == sep) then\n                p = p + 1\n                m = max(m, i - k)\n                k = i + 1\n            end if\n        end do\n        m = max(m, n - k + 1)\n        \n        if (allocated(array)) deallocate(array)\n        allocate(character(m) :: array(p))\n\n        p = 1\n        k = 1\n        do i = 1, n\n            if (line(i:i) == sep) then\n                array(p) = line(k:i-1)\n                p = p + 1\n                k = i + 1\n            end if\n        end do\n        array(p) = line(k:n)\n    end subroutine\nend program\n", "target": "using System.IO;\nusing System.Linq;\n\nnamespace CSV_data_manipulation\n{\n    class Program\n    {\n        static void Main()\n        {\n            var input = File.ReadAllLines(\"test_in.csv\");\n            var output = input.Select((line, i) =>\n            {\n                if (i == 0)\n                    return line + \",SUM\";\n                var sum = line.Split(',').Select(int.Parse).Sum();\n                return line + \",\" + sum;\n            }).ToArray();\n            File.WriteAllLines(\"test_out.csv\", output);\n        }\n    }\n}\n"}
{"id": 4117, "name": "CSV data manipulation", "source": "Translate Fortran to Java: program rowsum\n    implicit none\n    character(:), allocatable :: line, name, a(:)\n    character(20) :: fmt\n    double precision, allocatable :: v(:)\n    integer :: n, nrow, ncol, i\n    \n    call get_command_argument(1, length=n)\n    allocate(character(n) :: name)\n    call get_command_argument(1, name)\n    open(unit=10, file=name, action=\"read\", form=\"formatted\", access=\"stream\")\n    deallocate(name)\n    \n    call get_command_argument(2, length=n)\n    allocate(character(n) :: name)\n    call get_command_argument(2, name)\n    open(unit=11, file=name, action=\"write\", form=\"formatted\", access=\"stream\")\n    deallocate(name)\n\n    nrow = 0\n    ncol = 0\n    do while (readline(10, line))\n        nrow = nrow + 1\n        \n        call split(line, a)\n        \n        if (nrow == 1) then\n            ncol = size(a)\n            write(11, \"(A)\", advance=\"no\") line\n            write(11, \"(A)\") \",Sum\"\n            allocate(v(ncol + 1))\n            write(fmt, \"('(',G0,'(G0,:,''',A,'''))')\") ncol + 1, \",\"\n        else\n            if (size(a) /= ncol) then\n                print \"(A,' ',G0)\", \"Invalid number of values on row\", nrow\n                stop\n            end if\n\n            do i = 1, ncol\n                read(a(i), *) v(i)\n            end do\n            v(ncol + 1) = sum(v(1:ncol))\n            write(11, fmt) v\n        end if\n    end do\n    close(10)\n    close(11)\ncontains\n    function readline(unit, line)\n        use iso_fortran_env\n        logical :: readline\n        integer :: unit, ios, n\n        character(:), allocatable :: line\n        character(10) :: buffer\n        \n        line = \"\"\n        readline = .false.\n        do\n            read(unit, \"(A)\", advance=\"no\", size=n, iostat=ios) buffer\n            if (ios == iostat_end) return\n            readline = .true.\n            line = line // buffer(1:n)\n            if (ios == iostat_eor) return\n        end do\n    end function\n\n    subroutine split(line, array, separator)\n        character(*) line\n        character(:), allocatable :: array(:)\n        character, optional :: separator\n        character :: sep\n        integer :: n, m, p, i, k\n        \n        if (present(separator)) then\n            sep = separator\n        else\n            sep = \",\"\n        end if\n        \n        n = len(line)\n        m = 0\n        p = 1\n        k = 1\n        do i = 1, n\n            if (line(i:i) == sep) then\n                p = p + 1\n                m = max(m, i - k)\n                k = i + 1\n            end if\n        end do\n        m = max(m, n - k + 1)\n        \n        if (allocated(array)) deallocate(array)\n        allocate(character(m) :: array(p))\n\n        p = 1\n        k = 1\n        do i = 1, n\n            if (line(i:i) == sep) then\n                array(p) = line(k:i-1)\n                p = p + 1\n                k = i + 1\n            end if\n        end do\n        array(p) = line(k:n)\n    end subroutine\nend program\n", "target": "import java.io.*;\nimport java.awt.Point;\nimport java.util.HashMap;\nimport java.util.Scanner;\n\npublic class CSV {\n\n    private HashMap<Point, String> _map = new HashMap<Point, String>();\n    private int _cols;\n    private int _rows;\n\n    public void open(File file) throws FileNotFoundException, IOException {\n        open(file, ',');\n    }\n\n    public void open(File file, char delimiter)\n            throws FileNotFoundException, IOException {\n        Scanner scanner = new Scanner(file);\n        scanner.useDelimiter(Character.toString(delimiter));\n\n        clear();\n\n        while(scanner.hasNextLine()) {\n            String[] values = scanner.nextLine().split(Character.toString(delimiter));\n\n            int col = 0;\n            for ( String value: values ) {\n                _map.put(new Point(col, _rows), value);\n                _cols = Math.max(_cols, ++col);\n            }\n            _rows++;\n        }\n        scanner.close();\n    }\n\n    public void save(File file) throws IOException {\n        save(file, ',');\n    }\n\n    public void save(File file, char delimiter) throws IOException {\n        FileWriter fw = new FileWriter(file);\n        BufferedWriter bw = new BufferedWriter(fw);\n\n        for (int row = 0; row < _rows; row++) {\n            for (int col = 0; col < _cols; col++) {\n                Point key = new Point(col, row);\n                if (_map.containsKey(key)) {\n                    bw.write(_map.get(key));\n                }\n\n                if ((col + 1) < _cols) {\n                    bw.write(delimiter);\n                }\n            }\n            bw.newLine();\n        }\n        bw.flush();\n        bw.close();\n    }\n\n    public String get(int col, int row) {\n        String val = \"\";\n        Point key = new Point(col, row);\n        if (_map.containsKey(key)) {\n            val = _map.get(key);\n        }\n        return val;\n    }\n\n    public void put(int col, int row, String value) {\n        _map.put(new Point(col, row), value);\n        _cols = Math.max(_cols, col+1);\n        _rows = Math.max(_rows, row+1);\n    }\n\n    public void clear() {\n        _map.clear();\n        _cols = 0;\n        _rows = 0;\n    }\n\n    public int rows() {\n        return _rows;\n    }\n\n    public int cols() {\n        return _cols;\n    }\n\n    public static void main(String[] args) {\n        try {\n            CSV csv = new CSV();\n\n            csv.open(new File(\"test_in.csv\"));\n            csv.put(0, 0, \"Column0\");\n            csv.put(1, 1, \"100\");\n            csv.put(2, 2, \"200\");\n            csv.put(3, 3, \"300\");\n            csv.put(4, 4, \"400\");\n            csv.save(new File(\"test_out.csv\"));\n        } catch (Exception e) {\n        }\n    }\n}\n"}
{"id": 4118, "name": "CSV data manipulation", "source": "Translate Fortran to Java: program rowsum\n    implicit none\n    character(:), allocatable :: line, name, a(:)\n    character(20) :: fmt\n    double precision, allocatable :: v(:)\n    integer :: n, nrow, ncol, i\n    \n    call get_command_argument(1, length=n)\n    allocate(character(n) :: name)\n    call get_command_argument(1, name)\n    open(unit=10, file=name, action=\"read\", form=\"formatted\", access=\"stream\")\n    deallocate(name)\n    \n    call get_command_argument(2, length=n)\n    allocate(character(n) :: name)\n    call get_command_argument(2, name)\n    open(unit=11, file=name, action=\"write\", form=\"formatted\", access=\"stream\")\n    deallocate(name)\n\n    nrow = 0\n    ncol = 0\n    do while (readline(10, line))\n        nrow = nrow + 1\n        \n        call split(line, a)\n        \n        if (nrow == 1) then\n            ncol = size(a)\n            write(11, \"(A)\", advance=\"no\") line\n            write(11, \"(A)\") \",Sum\"\n            allocate(v(ncol + 1))\n            write(fmt, \"('(',G0,'(G0,:,''',A,'''))')\") ncol + 1, \",\"\n        else\n            if (size(a) /= ncol) then\n                print \"(A,' ',G0)\", \"Invalid number of values on row\", nrow\n                stop\n            end if\n\n            do i = 1, ncol\n                read(a(i), *) v(i)\n            end do\n            v(ncol + 1) = sum(v(1:ncol))\n            write(11, fmt) v\n        end if\n    end do\n    close(10)\n    close(11)\ncontains\n    function readline(unit, line)\n        use iso_fortran_env\n        logical :: readline\n        integer :: unit, ios, n\n        character(:), allocatable :: line\n        character(10) :: buffer\n        \n        line = \"\"\n        readline = .false.\n        do\n            read(unit, \"(A)\", advance=\"no\", size=n, iostat=ios) buffer\n            if (ios == iostat_end) return\n            readline = .true.\n            line = line // buffer(1:n)\n            if (ios == iostat_eor) return\n        end do\n    end function\n\n    subroutine split(line, array, separator)\n        character(*) line\n        character(:), allocatable :: array(:)\n        character, optional :: separator\n        character :: sep\n        integer :: n, m, p, i, k\n        \n        if (present(separator)) then\n            sep = separator\n        else\n            sep = \",\"\n        end if\n        \n        n = len(line)\n        m = 0\n        p = 1\n        k = 1\n        do i = 1, n\n            if (line(i:i) == sep) then\n                p = p + 1\n                m = max(m, i - k)\n                k = i + 1\n            end if\n        end do\n        m = max(m, n - k + 1)\n        \n        if (allocated(array)) deallocate(array)\n        allocate(character(m) :: array(p))\n\n        p = 1\n        k = 1\n        do i = 1, n\n            if (line(i:i) == sep) then\n                array(p) = line(k:i-1)\n                p = p + 1\n                k = i + 1\n            end if\n        end do\n        array(p) = line(k:n)\n    end subroutine\nend program\n", "target": "import java.io.*;\nimport java.awt.Point;\nimport java.util.HashMap;\nimport java.util.Scanner;\n\npublic class CSV {\n\n    private HashMap<Point, String> _map = new HashMap<Point, String>();\n    private int _cols;\n    private int _rows;\n\n    public void open(File file) throws FileNotFoundException, IOException {\n        open(file, ',');\n    }\n\n    public void open(File file, char delimiter)\n            throws FileNotFoundException, IOException {\n        Scanner scanner = new Scanner(file);\n        scanner.useDelimiter(Character.toString(delimiter));\n\n        clear();\n\n        while(scanner.hasNextLine()) {\n            String[] values = scanner.nextLine().split(Character.toString(delimiter));\n\n            int col = 0;\n            for ( String value: values ) {\n                _map.put(new Point(col, _rows), value);\n                _cols = Math.max(_cols, ++col);\n            }\n            _rows++;\n        }\n        scanner.close();\n    }\n\n    public void save(File file) throws IOException {\n        save(file, ',');\n    }\n\n    public void save(File file, char delimiter) throws IOException {\n        FileWriter fw = new FileWriter(file);\n        BufferedWriter bw = new BufferedWriter(fw);\n\n        for (int row = 0; row < _rows; row++) {\n            for (int col = 0; col < _cols; col++) {\n                Point key = new Point(col, row);\n                if (_map.containsKey(key)) {\n                    bw.write(_map.get(key));\n                }\n\n                if ((col + 1) < _cols) {\n                    bw.write(delimiter);\n                }\n            }\n            bw.newLine();\n        }\n        bw.flush();\n        bw.close();\n    }\n\n    public String get(int col, int row) {\n        String val = \"\";\n        Point key = new Point(col, row);\n        if (_map.containsKey(key)) {\n            val = _map.get(key);\n        }\n        return val;\n    }\n\n    public void put(int col, int row, String value) {\n        _map.put(new Point(col, row), value);\n        _cols = Math.max(_cols, col+1);\n        _rows = Math.max(_rows, row+1);\n    }\n\n    public void clear() {\n        _map.clear();\n        _cols = 0;\n        _rows = 0;\n    }\n\n    public int rows() {\n        return _rows;\n    }\n\n    public int cols() {\n        return _cols;\n    }\n\n    public static void main(String[] args) {\n        try {\n            CSV csv = new CSV();\n\n            csv.open(new File(\"test_in.csv\"));\n            csv.put(0, 0, \"Column0\");\n            csv.put(1, 1, \"100\");\n            csv.put(2, 2, \"200\");\n            csv.put(3, 3, \"300\");\n            csv.put(4, 4, \"400\");\n            csv.save(new File(\"test_out.csv\"));\n        } catch (Exception e) {\n        }\n    }\n}\n"}
{"id": 4119, "name": "CSV data manipulation", "source": "Translate Fortran to Python: program rowsum\n    implicit none\n    character(:), allocatable :: line, name, a(:)\n    character(20) :: fmt\n    double precision, allocatable :: v(:)\n    integer :: n, nrow, ncol, i\n    \n    call get_command_argument(1, length=n)\n    allocate(character(n) :: name)\n    call get_command_argument(1, name)\n    open(unit=10, file=name, action=\"read\", form=\"formatted\", access=\"stream\")\n    deallocate(name)\n    \n    call get_command_argument(2, length=n)\n    allocate(character(n) :: name)\n    call get_command_argument(2, name)\n    open(unit=11, file=name, action=\"write\", form=\"formatted\", access=\"stream\")\n    deallocate(name)\n\n    nrow = 0\n    ncol = 0\n    do while (readline(10, line))\n        nrow = nrow + 1\n        \n        call split(line, a)\n        \n        if (nrow == 1) then\n            ncol = size(a)\n            write(11, \"(A)\", advance=\"no\") line\n            write(11, \"(A)\") \",Sum\"\n            allocate(v(ncol + 1))\n            write(fmt, \"('(',G0,'(G0,:,''',A,'''))')\") ncol + 1, \",\"\n        else\n            if (size(a) /= ncol) then\n                print \"(A,' ',G0)\", \"Invalid number of values on row\", nrow\n                stop\n            end if\n\n            do i = 1, ncol\n                read(a(i), *) v(i)\n            end do\n            v(ncol + 1) = sum(v(1:ncol))\n            write(11, fmt) v\n        end if\n    end do\n    close(10)\n    close(11)\ncontains\n    function readline(unit, line)\n        use iso_fortran_env\n        logical :: readline\n        integer :: unit, ios, n\n        character(:), allocatable :: line\n        character(10) :: buffer\n        \n        line = \"\"\n        readline = .false.\n        do\n            read(unit, \"(A)\", advance=\"no\", size=n, iostat=ios) buffer\n            if (ios == iostat_end) return\n            readline = .true.\n            line = line // buffer(1:n)\n            if (ios == iostat_eor) return\n        end do\n    end function\n\n    subroutine split(line, array, separator)\n        character(*) line\n        character(:), allocatable :: array(:)\n        character, optional :: separator\n        character :: sep\n        integer :: n, m, p, i, k\n        \n        if (present(separator)) then\n            sep = separator\n        else\n            sep = \",\"\n        end if\n        \n        n = len(line)\n        m = 0\n        p = 1\n        k = 1\n        do i = 1, n\n            if (line(i:i) == sep) then\n                p = p + 1\n                m = max(m, i - k)\n                k = i + 1\n            end if\n        end do\n        m = max(m, n - k + 1)\n        \n        if (allocated(array)) deallocate(array)\n        allocate(character(m) :: array(p))\n\n        p = 1\n        k = 1\n        do i = 1, n\n            if (line(i:i) == sep) then\n                array(p) = line(k:i-1)\n                p = p + 1\n                k = i + 1\n            end if\n        end do\n        array(p) = line(k:n)\n    end subroutine\nend program\n", "target": "import fileinput\n\nchangerow, changecolumn, changevalue = 2, 4, '\"Spam\"'\n\nwith fileinput.input('csv_data_manipulation.csv', inplace=True) as f:\n    for line in f:\n        if fileinput.filelineno() == changerow:\n            fields = line.rstrip().split(',')\n            fields[changecolumn-1] = changevalue\n            line = ','.join(fields) + '\\n'\n        print(line, end='')\n"}
{"id": 4120, "name": "CSV data manipulation", "source": "Translate Fortran to Python: program rowsum\n    implicit none\n    character(:), allocatable :: line, name, a(:)\n    character(20) :: fmt\n    double precision, allocatable :: v(:)\n    integer :: n, nrow, ncol, i\n    \n    call get_command_argument(1, length=n)\n    allocate(character(n) :: name)\n    call get_command_argument(1, name)\n    open(unit=10, file=name, action=\"read\", form=\"formatted\", access=\"stream\")\n    deallocate(name)\n    \n    call get_command_argument(2, length=n)\n    allocate(character(n) :: name)\n    call get_command_argument(2, name)\n    open(unit=11, file=name, action=\"write\", form=\"formatted\", access=\"stream\")\n    deallocate(name)\n\n    nrow = 0\n    ncol = 0\n    do while (readline(10, line))\n        nrow = nrow + 1\n        \n        call split(line, a)\n        \n        if (nrow == 1) then\n            ncol = size(a)\n            write(11, \"(A)\", advance=\"no\") line\n            write(11, \"(A)\") \",Sum\"\n            allocate(v(ncol + 1))\n            write(fmt, \"('(',G0,'(G0,:,''',A,'''))')\") ncol + 1, \",\"\n        else\n            if (size(a) /= ncol) then\n                print \"(A,' ',G0)\", \"Invalid number of values on row\", nrow\n                stop\n            end if\n\n            do i = 1, ncol\n                read(a(i), *) v(i)\n            end do\n            v(ncol + 1) = sum(v(1:ncol))\n            write(11, fmt) v\n        end if\n    end do\n    close(10)\n    close(11)\ncontains\n    function readline(unit, line)\n        use iso_fortran_env\n        logical :: readline\n        integer :: unit, ios, n\n        character(:), allocatable :: line\n        character(10) :: buffer\n        \n        line = \"\"\n        readline = .false.\n        do\n            read(unit, \"(A)\", advance=\"no\", size=n, iostat=ios) buffer\n            if (ios == iostat_end) return\n            readline = .true.\n            line = line // buffer(1:n)\n            if (ios == iostat_eor) return\n        end do\n    end function\n\n    subroutine split(line, array, separator)\n        character(*) line\n        character(:), allocatable :: array(:)\n        character, optional :: separator\n        character :: sep\n        integer :: n, m, p, i, k\n        \n        if (present(separator)) then\n            sep = separator\n        else\n            sep = \",\"\n        end if\n        \n        n = len(line)\n        m = 0\n        p = 1\n        k = 1\n        do i = 1, n\n            if (line(i:i) == sep) then\n                p = p + 1\n                m = max(m, i - k)\n                k = i + 1\n            end if\n        end do\n        m = max(m, n - k + 1)\n        \n        if (allocated(array)) deallocate(array)\n        allocate(character(m) :: array(p))\n\n        p = 1\n        k = 1\n        do i = 1, n\n            if (line(i:i) == sep) then\n                array(p) = line(k:i-1)\n                p = p + 1\n                k = i + 1\n            end if\n        end do\n        array(p) = line(k:n)\n    end subroutine\nend program\n", "target": "import fileinput\n\nchangerow, changecolumn, changevalue = 2, 4, '\"Spam\"'\n\nwith fileinput.input('csv_data_manipulation.csv', inplace=True) as f:\n    for line in f:\n        if fileinput.filelineno() == changerow:\n            fields = line.rstrip().split(',')\n            fields[changecolumn-1] = changevalue\n            line = ','.join(fields) + '\\n'\n        print(line, end='')\n"}
{"id": 4959, "name": "Read entire file", "source": "Translate Fortran to C#: program read_file\n    implicit none\n    integer :: n\n    character(:), allocatable :: s\n    \n    open(unit=10, file=\"read_file.f90\", action=\"read\", &\n         form=\"unformatted\", access=\"stream\")\n    inquire(unit=10, size=n)\n    allocate(character(n) :: s)\n    read(10) s\n    close(10)\n    \n    print \"(A)\", s\nend program\n", "target": "using System.IO;\n\nclass Program\n{\n    static void Main(string[] args)\n    {\n        var fileContents = File.ReadAllText(\"c:\\\\autoexec.bat\");  \n        \n    }\n}\n"}
{"id": 4962, "name": "Read entire file", "source": "Translate Fortran to Java: program read_file\n    implicit none\n    integer :: n\n    character(:), allocatable :: s\n    \n    open(unit=10, file=\"read_file.f90\", action=\"read\", &\n         form=\"unformatted\", access=\"stream\")\n    inquire(unit=10, size=n)\n    allocate(character(n) :: s)\n    read(10) s\n    close(10)\n    \n    print \"(A)\", s\nend program\n", "target": "static Byte[] contentsOf(File file)\n    {\n    return file.contents;\n    }\n"}
{"id": 4963, "name": "Read entire file", "source": "Translate Fortran to Python: program read_file\n    implicit none\n    integer :: n\n    character(:), allocatable :: s\n    \n    open(unit=10, file=\"read_file.f90\", action=\"read\", &\n         form=\"unformatted\", access=\"stream\")\n    inquire(unit=10, size=n)\n    allocate(character(n) :: s)\n    read(10) s\n    close(10)\n    \n    print \"(A)\", s\nend program\n", "target": "open(filename).read()\n"}
{"id": 5144, "name": "Undefined values", "source": "Translate Fortran to Python: IsNaN(x)\n", "target": "\ntry: name\nexcept NameError: print \"name is undefined at first check\"\n\n\nname = \"Chocolate\"\n\n\ntry: name\nexcept NameError: print \"name is undefined at second check\"\n\n\ndel name\n\n\ntry: name\nexcept NameError: print \"name is undefined at third check\"\n\n\nname = 42\n\n\ntry: name\nexcept NameError: print \"name is undefined at fourth check\"\n\n\n\nprint \"Done\"\n"}
{"id": 5656, "name": "SHA-1", "source": "Translate Fortran to C#: module sha1_mod\n    use kernel32\n    use advapi32\n    implicit none\n    integer, parameter :: SHA1LEN = 20\ncontains\n    subroutine sha1hash(name, hash, dwStatus, filesize)\n        implicit none\n        character(*) :: name\n        integer, parameter :: BUFLEN = 32768\n        integer(HANDLE) :: hFile, hProv, hHash\n        integer(DWORD) :: dwStatus, nRead\n        integer(BOOL) :: status\n        integer(BYTE) :: buffer(BUFLEN)\n        integer(BYTE) :: hash(SHA1LEN)\n        integer(UINT64) :: filesize\n \n        dwStatus = 0\n        filesize = 0\n        hFile = CreateFile(trim(name) // char(0), GENERIC_READ, FILE_SHARE_READ, NULL, &\n                           OPEN_EXISTING, FILE_FLAG_SEQUENTIAL_SCAN, NULL)\n \n        if (hFile == INVALID_HANDLE_VALUE) then\n            dwStatus = GetLastError()\n            print *, \"CreateFile failed.\"\n            return\n        end if\n \n        if (CryptAcquireContext(hProv, NULL, NULL, PROV_RSA_FULL, &\n                                CRYPT_VERIFYCONTEXT) == FALSE) then\n \n            dwStatus = GetLastError()\n            print *, \"CryptAcquireContext failed.\"\n            goto 3\n        end if\n \n        if (CryptCreateHash(hProv, CALG_SHA1, 0_ULONG_PTR, 0_DWORD, hHash) == FALSE) then\n \n            dwStatus = GetLastError()\n            print *, \"CryptCreateHash failed.\"\n            go to 2\n        end if\n \n        do\n            status = ReadFile(hFile, loc(buffer), BUFLEN, nRead, NULL)\n            if (status == FALSE .or. nRead == 0) exit\n            filesize = filesize + nRead\n            if (CryptHashData(hHash, buffer, nRead, 0) == FALSE) then\n                dwStatus = GetLastError()\n                print *, \"CryptHashData failed.\"\n                go to 1\n            end if\n        end do\n \n        if (status == FALSE) then\n            dwStatus = GetLastError()\n            print *, \"ReadFile failed.\"\n            go to 1\n        end if\n \n        nRead = SHA1LEN\n        if (CryptGetHashParam(hHash, HP_HASHVAL, hash, nRead, 0) == FALSE) then\n            dwStatus = GetLastError()\n            print *, \"CryptGetHashParam failed.\", status, nRead, dwStatus\n        end if\n \n      1 status = CryptDestroyHash(hHash)\n      2 status = CryptReleaseContext(hProv, 0)\n      3 status = CloseHandle(hFile)\n    end subroutine\nend module\n \nprogram sha1\n    use sha1_mod\n    implicit none\n    integer :: n, m, i, j\n    character(:), allocatable :: name\n    integer(DWORD) :: dwStatus\n    integer(BYTE) :: hash(SHA1LEN)\n    integer(UINT64) :: filesize\n \n    n = command_argument_count()\n    do i = 1, n\n        call get_command_argument(i, length=m)\n        allocate(character(m) :: name)\n        call get_command_argument(i, name)\n        call sha1hash(name, hash, dwStatus, filesize)\n        if (dwStatus == 0) then\n            do j = 1, SHA1LEN\n                write(*, \"(Z2.2)\", advance=\"NO\") hash(j)\n            end do\n            write(*, \"(' ',A,' (',G0,' bytes)')\") name, filesize\n        end if\n        deallocate(name)\n    end do\nend program\n", "target": "using System;\nusing System.Security.Cryptography;\nusing System.Text;\nusing Microsoft.VisualStudio.TestTools.UnitTesting;\n\nnamespace RosettaCode.SHA1\n{\n    [TestClass]\n    public class SHA1CryptoServiceProviderTest\n    {\n        [TestMethod]\n        public void TestComputeHash()\n        {\n            var input = new UTF8Encoding().GetBytes(\"Rosetta Code\");\n            var output = new SHA1CryptoServiceProvider().ComputeHash(input);\n            Assert.AreEqual(\n                \"48-C9-8F-7E-5A-6E-73-6D-79-0A-B7-40-DF-C3-F5-1A-61-AB-E2-B5\",\n                BitConverter.ToString(output));\n        }\n    }\n}\n"}
{"id": 5657, "name": "SHA-1", "source": "Translate Fortran to C#: module sha1_mod\n    use kernel32\n    use advapi32\n    implicit none\n    integer, parameter :: SHA1LEN = 20\ncontains\n    subroutine sha1hash(name, hash, dwStatus, filesize)\n        implicit none\n        character(*) :: name\n        integer, parameter :: BUFLEN = 32768\n        integer(HANDLE) :: hFile, hProv, hHash\n        integer(DWORD) :: dwStatus, nRead\n        integer(BOOL) :: status\n        integer(BYTE) :: buffer(BUFLEN)\n        integer(BYTE) :: hash(SHA1LEN)\n        integer(UINT64) :: filesize\n \n        dwStatus = 0\n        filesize = 0\n        hFile = CreateFile(trim(name) // char(0), GENERIC_READ, FILE_SHARE_READ, NULL, &\n                           OPEN_EXISTING, FILE_FLAG_SEQUENTIAL_SCAN, NULL)\n \n        if (hFile == INVALID_HANDLE_VALUE) then\n            dwStatus = GetLastError()\n            print *, \"CreateFile failed.\"\n            return\n        end if\n \n        if (CryptAcquireContext(hProv, NULL, NULL, PROV_RSA_FULL, &\n                                CRYPT_VERIFYCONTEXT) == FALSE) then\n \n            dwStatus = GetLastError()\n            print *, \"CryptAcquireContext failed.\"\n            goto 3\n        end if\n \n        if (CryptCreateHash(hProv, CALG_SHA1, 0_ULONG_PTR, 0_DWORD, hHash) == FALSE) then\n \n            dwStatus = GetLastError()\n            print *, \"CryptCreateHash failed.\"\n            go to 2\n        end if\n \n        do\n            status = ReadFile(hFile, loc(buffer), BUFLEN, nRead, NULL)\n            if (status == FALSE .or. nRead == 0) exit\n            filesize = filesize + nRead\n            if (CryptHashData(hHash, buffer, nRead, 0) == FALSE) then\n                dwStatus = GetLastError()\n                print *, \"CryptHashData failed.\"\n                go to 1\n            end if\n        end do\n \n        if (status == FALSE) then\n            dwStatus = GetLastError()\n            print *, \"ReadFile failed.\"\n            go to 1\n        end if\n \n        nRead = SHA1LEN\n        if (CryptGetHashParam(hHash, HP_HASHVAL, hash, nRead, 0) == FALSE) then\n            dwStatus = GetLastError()\n            print *, \"CryptGetHashParam failed.\", status, nRead, dwStatus\n        end if\n \n      1 status = CryptDestroyHash(hHash)\n      2 status = CryptReleaseContext(hProv, 0)\n      3 status = CloseHandle(hFile)\n    end subroutine\nend module\n \nprogram sha1\n    use sha1_mod\n    implicit none\n    integer :: n, m, i, j\n    character(:), allocatable :: name\n    integer(DWORD) :: dwStatus\n    integer(BYTE) :: hash(SHA1LEN)\n    integer(UINT64) :: filesize\n \n    n = command_argument_count()\n    do i = 1, n\n        call get_command_argument(i, length=m)\n        allocate(character(m) :: name)\n        call get_command_argument(i, name)\n        call sha1hash(name, hash, dwStatus, filesize)\n        if (dwStatus == 0) then\n            do j = 1, SHA1LEN\n                write(*, \"(Z2.2)\", advance=\"NO\") hash(j)\n            end do\n            write(*, \"(' ',A,' (',G0,' bytes)')\") name, filesize\n        end if\n        deallocate(name)\n    end do\nend program\n", "target": "using System;\nusing System.Security.Cryptography;\nusing System.Text;\nusing Microsoft.VisualStudio.TestTools.UnitTesting;\n\nnamespace RosettaCode.SHA1\n{\n    [TestClass]\n    public class SHA1CryptoServiceProviderTest\n    {\n        [TestMethod]\n        public void TestComputeHash()\n        {\n            var input = new UTF8Encoding().GetBytes(\"Rosetta Code\");\n            var output = new SHA1CryptoServiceProvider().ComputeHash(input);\n            Assert.AreEqual(\n                \"48-C9-8F-7E-5A-6E-73-6D-79-0A-B7-40-DF-C3-F5-1A-61-AB-E2-B5\",\n                BitConverter.ToString(output));\n        }\n    }\n}\n"}
{"id": 5663, "name": "SHA-1", "source": "Translate Fortran to Python: module sha1_mod\n    use kernel32\n    use advapi32\n    implicit none\n    integer, parameter :: SHA1LEN = 20\ncontains\n    subroutine sha1hash(name, hash, dwStatus, filesize)\n        implicit none\n        character(*) :: name\n        integer, parameter :: BUFLEN = 32768\n        integer(HANDLE) :: hFile, hProv, hHash\n        integer(DWORD) :: dwStatus, nRead\n        integer(BOOL) :: status\n        integer(BYTE) :: buffer(BUFLEN)\n        integer(BYTE) :: hash(SHA1LEN)\n        integer(UINT64) :: filesize\n \n        dwStatus = 0\n        filesize = 0\n        hFile = CreateFile(trim(name) // char(0), GENERIC_READ, FILE_SHARE_READ, NULL, &\n                           OPEN_EXISTING, FILE_FLAG_SEQUENTIAL_SCAN, NULL)\n \n        if (hFile == INVALID_HANDLE_VALUE) then\n            dwStatus = GetLastError()\n            print *, \"CreateFile failed.\"\n            return\n        end if\n \n        if (CryptAcquireContext(hProv, NULL, NULL, PROV_RSA_FULL, &\n                                CRYPT_VERIFYCONTEXT) == FALSE) then\n \n            dwStatus = GetLastError()\n            print *, \"CryptAcquireContext failed.\"\n            goto 3\n        end if\n \n        if (CryptCreateHash(hProv, CALG_SHA1, 0_ULONG_PTR, 0_DWORD, hHash) == FALSE) then\n \n            dwStatus = GetLastError()\n            print *, \"CryptCreateHash failed.\"\n            go to 2\n        end if\n \n        do\n            status = ReadFile(hFile, loc(buffer), BUFLEN, nRead, NULL)\n            if (status == FALSE .or. nRead == 0) exit\n            filesize = filesize + nRead\n            if (CryptHashData(hHash, buffer, nRead, 0) == FALSE) then\n                dwStatus = GetLastError()\n                print *, \"CryptHashData failed.\"\n                go to 1\n            end if\n        end do\n \n        if (status == FALSE) then\n            dwStatus = GetLastError()\n            print *, \"ReadFile failed.\"\n            go to 1\n        end if\n \n        nRead = SHA1LEN\n        if (CryptGetHashParam(hHash, HP_HASHVAL, hash, nRead, 0) == FALSE) then\n            dwStatus = GetLastError()\n            print *, \"CryptGetHashParam failed.\", status, nRead, dwStatus\n        end if\n \n      1 status = CryptDestroyHash(hHash)\n      2 status = CryptReleaseContext(hProv, 0)\n      3 status = CloseHandle(hFile)\n    end subroutine\nend module\n \nprogram sha1\n    use sha1_mod\n    implicit none\n    integer :: n, m, i, j\n    character(:), allocatable :: name\n    integer(DWORD) :: dwStatus\n    integer(BYTE) :: hash(SHA1LEN)\n    integer(UINT64) :: filesize\n \n    n = command_argument_count()\n    do i = 1, n\n        call get_command_argument(i, length=m)\n        allocate(character(m) :: name)\n        call get_command_argument(i, name)\n        call sha1hash(name, hash, dwStatus, filesize)\n        if (dwStatus == 0) then\n            do j = 1, SHA1LEN\n                write(*, \"(Z2.2)\", advance=\"NO\") hash(j)\n            end do\n            write(*, \"(' ',A,' (',G0,' bytes)')\") name, filesize\n        end if\n        deallocate(name)\n    end do\nend program\n", "target": "import crypto { sha1 }\nlet hash = sha1.hexdigest('Ars longa, vita brevis')\nprint hash\n"}
{"id": 5664, "name": "SHA-1", "source": "Translate Fortran to Python: module sha1_mod\n    use kernel32\n    use advapi32\n    implicit none\n    integer, parameter :: SHA1LEN = 20\ncontains\n    subroutine sha1hash(name, hash, dwStatus, filesize)\n        implicit none\n        character(*) :: name\n        integer, parameter :: BUFLEN = 32768\n        integer(HANDLE) :: hFile, hProv, hHash\n        integer(DWORD) :: dwStatus, nRead\n        integer(BOOL) :: status\n        integer(BYTE) :: buffer(BUFLEN)\n        integer(BYTE) :: hash(SHA1LEN)\n        integer(UINT64) :: filesize\n \n        dwStatus = 0\n        filesize = 0\n        hFile = CreateFile(trim(name) // char(0), GENERIC_READ, FILE_SHARE_READ, NULL, &\n                           OPEN_EXISTING, FILE_FLAG_SEQUENTIAL_SCAN, NULL)\n \n        if (hFile == INVALID_HANDLE_VALUE) then\n            dwStatus = GetLastError()\n            print *, \"CreateFile failed.\"\n            return\n        end if\n \n        if (CryptAcquireContext(hProv, NULL, NULL, PROV_RSA_FULL, &\n                                CRYPT_VERIFYCONTEXT) == FALSE) then\n \n            dwStatus = GetLastError()\n            print *, \"CryptAcquireContext failed.\"\n            goto 3\n        end if\n \n        if (CryptCreateHash(hProv, CALG_SHA1, 0_ULONG_PTR, 0_DWORD, hHash) == FALSE) then\n \n            dwStatus = GetLastError()\n            print *, \"CryptCreateHash failed.\"\n            go to 2\n        end if\n \n        do\n            status = ReadFile(hFile, loc(buffer), BUFLEN, nRead, NULL)\n            if (status == FALSE .or. nRead == 0) exit\n            filesize = filesize + nRead\n            if (CryptHashData(hHash, buffer, nRead, 0) == FALSE) then\n                dwStatus = GetLastError()\n                print *, \"CryptHashData failed.\"\n                go to 1\n            end if\n        end do\n \n        if (status == FALSE) then\n            dwStatus = GetLastError()\n            print *, \"ReadFile failed.\"\n            go to 1\n        end if\n \n        nRead = SHA1LEN\n        if (CryptGetHashParam(hHash, HP_HASHVAL, hash, nRead, 0) == FALSE) then\n            dwStatus = GetLastError()\n            print *, \"CryptGetHashParam failed.\", status, nRead, dwStatus\n        end if\n \n      1 status = CryptDestroyHash(hHash)\n      2 status = CryptReleaseContext(hProv, 0)\n      3 status = CloseHandle(hFile)\n    end subroutine\nend module\n \nprogram sha1\n    use sha1_mod\n    implicit none\n    integer :: n, m, i, j\n    character(:), allocatable :: name\n    integer(DWORD) :: dwStatus\n    integer(BYTE) :: hash(SHA1LEN)\n    integer(UINT64) :: filesize\n \n    n = command_argument_count()\n    do i = 1, n\n        call get_command_argument(i, length=m)\n        allocate(character(m) :: name)\n        call get_command_argument(i, name)\n        call sha1hash(name, hash, dwStatus, filesize)\n        if (dwStatus == 0) then\n            do j = 1, SHA1LEN\n                write(*, \"(Z2.2)\", advance=\"NO\") hash(j)\n            end do\n            write(*, \"(' ',A,' (',G0,' bytes)')\") name, filesize\n        end if\n        deallocate(name)\n    end do\nend program\n", "target": "import crypto { sha1 }\nlet hash = sha1.hexdigest('Ars longa, vita brevis')\nprint hash\n"}
{"id": 6083, "name": "Man or boy test", "source": "Translate Fortran to C#: module man_or_boy\n\nimplicit none\n\ncontains\n\n  recursive integer function A(k,x1,x2,x3,x4,x5) result(res)\n    integer, intent(in) :: k\n    interface\n      recursive integer function x1()\n      end function\n      recursive integer function x2()\n      end function\n      recursive integer function x3()\n      end function\n      recursive integer function x4()\n      end function\n      recursive integer function x5()\n      end function\n    end interface\n    integer :: m\n    if ( k <= 0 ) then\n      res = x4()+x5()\n    else\n      m = k\n      res = B()\n    end if\n  \n  contains\n  \n    recursive integer function B() result(res)    \n      m = m-1\n      res = A(m,B,x1,x2,x3,x4)\n    end function B\n  \n  end function A\n\n\n  recursive integer function one() result(res)\n    res = 1\n  end function\n\n  recursive integer function minus_one() result(res)\n    res = -1\n  end function\n\n  recursive integer function zero() result(res)\n    res = 0\n  end function\n\nend module man_or_boy\n\nprogram test\n  use man_or_boy\n  write (*,*) A(10,one,minus_one,minus_one,one,zero)\nend program test\n", "target": "using System;\n \ndelegate T Func<T>();\n \nclass ManOrBoy\n{\n    static void Main()\n    {\n        Console.WriteLine(A(10, C(1), C(-1), C(-1), C(1), C(0)));\n    }\n \n    static Func<int> C(int i)\n    {\n        return delegate { return i; };\n    }\n \n    static int A(int k, Func<int> x1, Func<int> x2, Func<int> x3, Func<int> x4, Func<int> x5)\n    {\n        Func<int> b = null;\n        b = delegate { k--; return A(k, b, x1, x2, x3, x4); };\n        return k <= 0 ? x4() + x5() : b();\n    }\n}\n"}
{"id": 6086, "name": "Man or boy test", "source": "Translate Fortran to Java: module man_or_boy\n\nimplicit none\n\ncontains\n\n  recursive integer function A(k,x1,x2,x3,x4,x5) result(res)\n    integer, intent(in) :: k\n    interface\n      recursive integer function x1()\n      end function\n      recursive integer function x2()\n      end function\n      recursive integer function x3()\n      end function\n      recursive integer function x4()\n      end function\n      recursive integer function x5()\n      end function\n    end interface\n    integer :: m\n    if ( k <= 0 ) then\n      res = x4()+x5()\n    else\n      m = k\n      res = B()\n    end if\n  \n  contains\n  \n    recursive integer function B() result(res)    \n      m = m-1\n      res = A(m,B,x1,x2,x3,x4)\n    end function B\n  \n  end function A\n\n\n  recursive integer function one() result(res)\n    res = 1\n  end function\n\n  recursive integer function minus_one() result(res)\n    res = -1\n  end function\n\n  recursive integer function zero() result(res)\n    res = 0\n  end function\n\nend module man_or_boy\n\nprogram test\n  use man_or_boy\n  write (*,*) A(10,one,minus_one,minus_one,one,zero)\nend program test\n", "target": "import java.util.function.DoubleSupplier;\n\npublic class ManOrBoy {\n    \n    static double A(int k, DoubleSupplier x1, DoubleSupplier x2,\n                 DoubleSupplier x3, DoubleSupplier x4, DoubleSupplier x5) {\n        \n        DoubleSupplier B = new DoubleSupplier() {\n            int m = k;\n            public double getAsDouble() {\n                return A(--m, this, x1, x2, x3, x4);\n            }\n        };\n                \n        return k <= 0 ? x4.getAsDouble() + x5.getAsDouble() : B.getAsDouble();\n    }\n    \n    public static void main(String[] args) {\n        System.out.println(A(10, () -> 1.0, () -> -1.0, () -> -1.0, () -> 1.0, () -> 0.0));\n    }\n}\n"}
{"id": 6087, "name": "Man or boy test", "source": "Translate Fortran to Python: module man_or_boy\n\nimplicit none\n\ncontains\n\n  recursive integer function A(k,x1,x2,x3,x4,x5) result(res)\n    integer, intent(in) :: k\n    interface\n      recursive integer function x1()\n      end function\n      recursive integer function x2()\n      end function\n      recursive integer function x3()\n      end function\n      recursive integer function x4()\n      end function\n      recursive integer function x5()\n      end function\n    end interface\n    integer :: m\n    if ( k <= 0 ) then\n      res = x4()+x5()\n    else\n      m = k\n      res = B()\n    end if\n  \n  contains\n  \n    recursive integer function B() result(res)    \n      m = m-1\n      res = A(m,B,x1,x2,x3,x4)\n    end function B\n  \n  end function A\n\n\n  recursive integer function one() result(res)\n    res = 1\n  end function\n\n  recursive integer function minus_one() result(res)\n    res = -1\n  end function\n\n  recursive integer function zero() result(res)\n    res = 0\n  end function\n\nend module man_or_boy\n\nprogram test\n  use man_or_boy\n  write (*,*) A(10,one,minus_one,minus_one,one,zero)\nend program test\n", "target": "\nimport sys\nsys.setrecursionlimit(1025)\n\ndef a(in_k, x1, x2, x3, x4, x5):\n    k = [in_k]\n    def b():\n        k[0] -= 1\n        return a(k[0], b, x1, x2, x3, x4)\n    return x4() + x5() if k[0] <= 0 else b()\n\nx = lambda i: lambda: i\nprint(a(10, x(1), x(-1), x(-1), x(1), x(0)))\n"}
{"id": 6556, "name": "Collections", "source": "Translate Fortran to C#:  REAL A(36)   \n  A(1) = 1           \n  A(2) = 3*A(1) + 5  \n", "target": "\nint[] intArray = new int[5] { 1, 2, 3, 4, 5 };\n\nint[] intArray = new int[]{ 1, 2, 3, 4, 5 };\n\nint[] intArray = { 1, 2, 3, 4, 5 };\n\n\nstring[] stringArr = new string[5];\nstringArr[0] = \"string\";\n"}
{"id": 6559, "name": "Collections", "source": "Translate Fortran to Java:  REAL A(36)   \n  A(1) = 1           \n  A(2) = 3*A(1) + 5  \n", "target": "List arrayList = new ArrayList();\narrayList.add(new Integer(0));\n\narrayList.add(0); \n\n\n\nList<Integer> myarrlist = new ArrayList<Integer>();\n\n\nint sum;\nfor(int i = 0; i < 10; i++) {\n    myarrlist.add(i);\n}\n"}
{"id": 6560, "name": "Collections", "source": "Translate Fortran to Python:  REAL A(36)   \n  A(1) = 1           \n  A(2) = 3*A(1) + 5  \n", "target": "collection = [0, '1']                 \nx = collection[0]                     \ncollection.append(2)                  \ncollection.insert(0, '-1')            \ny = collection[0]                     \ncollection.extend([2,'3'])            \ncollection += [2,'3']                 \ncollection[2:6]                       \nlen(collection)                       \ncollection = (0, 1)                   \ncollection[:]                         \ncollection[-4:-1]                     \ncollection[::2]                       \ncollection=\"some string\"              \nx = collection[::-1]                  \ncollection[::2] == \"some string\"[::2] \ncollection.__getitem__(slice(0,len(collection),2))  \ncollection = {0: \"zero\", 1: \"one\"}    \ncollection['zero'] = 2                \ncollection = set([0, '1'])            \n"}
{"id": 6777, "name": "Matrix-exponentiation operator", "source": "Translate Fortran to C#: module matmod\n  implicit none\n   \n\n\n\n  interface operator (.matpow.)\n    module procedure matrix_exp\n  end interface\n\ncontains\n\nfunction matrix_exp(m, n) result (res)\n  real, intent(in)  :: m(:,:)\n  integer, intent(in)  :: n\n  real :: res(size(m,1),size(m,2))\n  integer :: i\n   \n  if(n == 0) then\n    res = 0\n    do i = 1, size(m,1)\n      res(i,i) = 1\n    end do\n    return\n  end if\n\n  res = m\n  do i = 2, n\n    res = matmul(res, m)\n  end do\n  \nend function matrix_exp\nend module matmod\n\nprogram Matrix_exponentiation\n  use matmod\n  implicit none\n\n  integer, parameter :: n = 3\n  real, dimension(n,n) :: m1, m2\n  integer :: i, j\n  \n  m1 = reshape((/ (i, i = 1, n*n) /), (/ n, n /), order = (/ 2, 1 /))\n \n  do i = 0, 4\n    m2 = m1 .matpow. i\n    do j = 1, size(m2,1)\n      write(*,*) m2(j,:)\n    end do\n    write(*,*)\n  end do\n\nend program Matrix_exponentiation\n", "target": "using System;\nusing System.Collections;\nusing System.Collections.Generic;\nusing static System.Linq.Enumerable;\n\npublic static class MatrixExponentation\n{\n    public static double[,] Identity(int size) {\n        double[,] matrix = new double[size, size];\n        for (int i = 0; i < size; i++) matrix[i, i] = 1;\n        return matrix;\n    }\n\n    public static double[,] Multiply(this double[,] left, double[,] right) {\n        if (left.ColumnCount() != right.RowCount()) throw new ArgumentException();\n        double[,] m = new double[left.RowCount(), right.ColumnCount()];\n        foreach (var (row, column) in from r in Range(0, m.RowCount()) from c in Range(0, m.ColumnCount()) select (r, c)) {\n            m[row, column] = Range(0, m.RowCount()).Sum(i => left[row, i] * right[i, column]);\n        }\n        return m;\n    }\n\n    public static double[,] Pow(this double[,] matrix, int exp) {\n        if (matrix.RowCount() != matrix.ColumnCount()) throw new ArgumentException(\"Matrix must be square.\");\n        double[,] accumulator = Identity(matrix.RowCount());\n        for (int i = 0; i < exp; i++) {\n            accumulator = accumulator.Multiply(matrix);\n        }\n        return accumulator;\n    }\n\n    private static int RowCount(this double[,] matrix) => matrix.GetLength(0);\n    private static int ColumnCount(this double[,] matrix) => matrix.GetLength(1);\n\n    private static void Print(this double[,] m) {\n        foreach (var row in Rows()) {\n            Console.WriteLine(\"[ \" + string.Join(\"   \", row) + \" ]\");\n        }\n        Console.WriteLine();\n\n        IEnumerable<IEnumerable<double>> Rows() =>\n            Range(0, m.RowCount()).Select(row => Range(0, m.ColumnCount()).Select(column => m[row, column]));\n    }\n\n    public static void Main() {\n        var matrix = new double[,] {\n            { 3, 2 },\n            { 2, 1 }\n        };\n        \n        matrix.Pow(0).Print();\n        matrix.Pow(1).Print();\n        matrix.Pow(2).Print();\n        matrix.Pow(3).Print();\n        matrix.Pow(4).Print();\n        matrix.Pow(50).Print();\n    }\n\n}\n"}
{"id": 6780, "name": "Matrix-exponentiation operator", "source": "Translate Fortran to Python: module matmod\n  implicit none\n   \n\n\n\n  interface operator (.matpow.)\n    module procedure matrix_exp\n  end interface\n\ncontains\n\nfunction matrix_exp(m, n) result (res)\n  real, intent(in)  :: m(:,:)\n  integer, intent(in)  :: n\n  real :: res(size(m,1),size(m,2))\n  integer :: i\n   \n  if(n == 0) then\n    res = 0\n    do i = 1, size(m,1)\n      res(i,i) = 1\n    end do\n    return\n  end if\n\n  res = m\n  do i = 2, n\n    res = matmul(res, m)\n  end do\n  \nend function matrix_exp\nend module matmod\n\nprogram Matrix_exponentiation\n  use matmod\n  implicit none\n\n  integer, parameter :: n = 3\n  real, dimension(n,n) :: m1, m2\n  integer :: i, j\n  \n  m1 = reshape((/ (i, i = 1, n*n) /), (/ n, n /), order = (/ 2, 1 /))\n \n  do i = 0, 4\n    m2 = m1 .matpow. i\n    do j = 1, size(m2,1)\n      write(*,*) m2(j,:)\n    end do\n    write(*,*)\n  end do\n\nend program Matrix_exponentiation\n", "target": ">>> from operator import mul\n>>> def matrixMul(m1, m2):\n  return map(\n    lambda row:\n      map(\n        lambda *column:\n          sum(map(mul, row, column)),\n        *m2),\n    m1)\n\n>>> def identity(size):\n\tsize = range(size)\n\treturn [[(i==j)*1 for i in size] for j in size]\n\n>>> def matrixExp(m, pow):\n\tassert pow>=0 and int(pow)==pow, \"Only non-negative, integer powers allowed\"\n\taccumulator = identity(len(m))\n\tfor i in range(pow):\n\t\taccumulator = matrixMul(accumulator, m)\n\treturn accumulator\n\n>>> def printtable(data):\n\tfor row in data:\n\t\tprint ' '.join('%-5s' % ('%s' % cell) for cell in row)\n\n\t\t\n>>> m = [[3,2], [2,1]]\n>>> for i in range(5):\n\tprint '\\n%i:' % i\n\tprinttable( matrixExp(m, i) )\n\n\t\n\n0:\n1     0    \n0     1    \n\n1:\n3     2    \n2     1    \n\n2:\n13    8    \n8     5    \n\n3:\n55    34   \n34    21   \n\n4:\n233   144  \n144   89   \n>>> printtable( matrixExp(m, 10) )\n1346269 832040\n832040 514229\n>>>\n"}
{"id": 6949, "name": "Tree traversal", "source": "Translate Fortran to C#:       IF (STYLE.EQ.\"PRE\")  CALL OUT(HAS)\n      IF (LINKL(HAS).GT.0) CALL TARZAN(LINKL(HAS),STYLE)\n      IF (STYLE.EQ.\"IN\")   CALL OUT(HAS)\n      IF (LINKR(HAS).GT.0) CALL TARZAN(LINKR(HAS),STYLE)\n      IF (STYLE.EQ.\"POST\") CALL OUT(HAS)\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\nclass Node\n{\n    int Value;\n    Node Left;\n    Node Right;\n\n    Node(int value = default(int), Node left = default(Node), Node right = default(Node))\n    {\n        Value = value;\n        Left = left;\n        Right = right;\n    }\n\n    IEnumerable<int> Preorder()\n    {\n        yield return Value;\n        if (Left != null)\n            foreach (var value in Left.Preorder())\n                yield return value;\n        if (Right != null)\n            foreach (var value in Right.Preorder())\n                yield return value;\n    }\n\n    IEnumerable<int> Inorder()\n    {\n        if (Left != null)\n            foreach (var value in Left.Inorder())\n                yield return value;\n        yield return Value;\n        if (Right != null)\n            foreach (var value in Right.Inorder())\n                yield return value;\n    }\n\n    IEnumerable<int> Postorder()\n    {\n        if (Left != null)\n            foreach (var value in Left.Postorder())\n                yield return value;\n        if (Right != null)\n            foreach (var value in Right.Postorder())\n                yield return value;\n        yield return Value;\n    }\n\n    IEnumerable<int> LevelOrder()\n    {\n        var queue = new Queue<Node>();\n        queue.Enqueue(this);\n        while (queue.Any())\n        {\n            var node = queue.Dequeue();\n            yield return node.Value;\n            if (node.Left != null)\n                queue.Enqueue(node.Left);\n            if (node.Right != null)\n                queue.Enqueue(node.Right);\n        }\n    }\n\n    static void Main()\n    {\n        var tree = new Node(1, new Node(2, new Node(4, new Node(7)), new Node(5)), new Node(3, new Node(6, new Node(8), new Node(9))));\n        foreach (var traversal in new Func<IEnumerable<int>>[] { tree.Preorder, tree.Inorder, tree.Postorder, tree.LevelOrder })\n            Console.WriteLine(\"{0}:\\t{1}\", traversal.Method.Name, string.Join(\" \", traversal()));\n    }\n}\n"}
{"id": 6952, "name": "Tree traversal", "source": "Translate Fortran to Java:       IF (STYLE.EQ.\"PRE\")  CALL OUT(HAS)\n      IF (LINKL(HAS).GT.0) CALL TARZAN(LINKL(HAS),STYLE)\n      IF (STYLE.EQ.\"IN\")   CALL OUT(HAS)\n      IF (LINKR(HAS).GT.0) CALL TARZAN(LINKR(HAS),STYLE)\n      IF (STYLE.EQ.\"POST\") CALL OUT(HAS)\n", "target": "import java.util.*;\n\npublic class TreeTraversal {\n\n        static class Node<T> {\n\t\tT value;\n\t\tNode<T> left;\n\t\tNode<T> right;\n\n\t\tNode(T value) {\n\t\t\tthis.value = value;\n\t\t}\n\n\t\tvoid visit() {\n\t\t\tSystem.out.print(this.value + \" \");\n\t\t}\n\t}\n\n\tstatic enum ORDER {\n\t\tPREORDER, INORDER, POSTORDER, LEVEL\n\t}\n        \n        static <T> void traverse(Node<T> node, ORDER order) {\n\t\tif (node == null) {\n\t\t\treturn;\n\t\t}\n\t\tswitch (order) {\n\t\tcase PREORDER:\n\t\t\tnode.visit();\n\t\t\ttraverse(node.left, order);\n\t\t\ttraverse(node.right, order);\n\t\t\tbreak;\n\t\tcase INORDER:\n\t\t\ttraverse(node.left, order);\n\t\t\tnode.visit();\n\t\t\ttraverse(node.right, order);\n\t\t\tbreak;\n\t\tcase POSTORDER:\n\t\t\ttraverse(node.left, order);\n\t\t\ttraverse(node.right, order);\n\t\t\tnode.visit();\n\t\t\tbreak;\n\t\tcase LEVEL:\n\t\t\tQueue<Node<T>> queue = new LinkedList<>();\n\t\t\tqueue.add(node);\n\t\t\twhile(!queue.isEmpty()){\n\t\t\t\tNode<T> next = queue.remove();\n\t\t\t\tnext.visit();\n\t\t\t\tif(next.left!=null)\n\t\t\t\t\tqueue.add(next.left);\n\t\t\t\tif(next.right!=null)\n\t\t\t\t\tqueue.add(next.right);\n\t\t\t}\n\t\t}\n\t}\t\n\n\tpublic static void main(String[] args) {\n\n\t\tNode<Integer> one = new Node<Integer>(1);\n\t\tNode<Integer> two = new Node<Integer>(2);\n\t\tNode<Integer> three = new Node<Integer>(3);\n\t\tNode<Integer> four = new Node<Integer>(4);\n\t\tNode<Integer> five = new Node<Integer>(5);\n\t\tNode<Integer> six = new Node<Integer>(6);\n\t\tNode<Integer> seven = new Node<Integer>(7);\n\t\tNode<Integer> eight = new Node<Integer>(8);\n\t\tNode<Integer> nine = new Node<Integer>(9);\n\t\t\n\t\tone.left = two;\n\t\tone.right = three;\n\t\ttwo.left = four;\n\t\ttwo.right = five;\n\t\tthree.left = six;\n\t\tfour.left = seven;\n\t\tsix.left = eight;\n\t\tsix.right = nine;\n\n\t\ttraverse(one, ORDER.PREORDER);\n\t\tSystem.out.println(); \n\t\ttraverse(one, ORDER.INORDER);\n\t\tSystem.out.println();\n\t\ttraverse(one, ORDER.POSTORDER);\n\t\tSystem.out.println();\n\t\ttraverse(one, ORDER.LEVEL);\n\t\t\n\t}\n}\n"}
{"id": 6953, "name": "Tree traversal", "source": "Translate Fortran to Python:       IF (STYLE.EQ.\"PRE\")  CALL OUT(HAS)\n      IF (LINKL(HAS).GT.0) CALL TARZAN(LINKL(HAS),STYLE)\n      IF (STYLE.EQ.\"IN\")   CALL OUT(HAS)\n      IF (LINKR(HAS).GT.0) CALL TARZAN(LINKR(HAS),STYLE)\n      IF (STYLE.EQ.\"POST\") CALL OUT(HAS)\n", "target": "from collections import namedtuple\n \nNode = namedtuple('Node', 'data, left, right')\ntree = Node(1,\n            Node(2,\n                 Node(4,\n                      Node(7, None, None),\n                      None),\n                 Node(5, None, None)),\n            Node(3,\n                 Node(6,\n                      Node(8, None, None),\n                      Node(9, None, None)),\n                 None))\n \ndef printwithspace(i):\n    print(i, end=' ')\n\ndef dfs(order, node, visitor):\n    if node is not None:\n        for action in order:\n            if action == 'N':\n                visitor(node.data)\n            elif action == 'L':\n                dfs(order, node.left, visitor)\n            elif action == 'R':\n                dfs(order, node.right, visitor)\n                \ndef preorder(node, visitor = printwithspace):\n    dfs('NLR', node, visitor)\n \ndef inorder(node, visitor = printwithspace):\n    dfs('LNR', node, visitor)\n \ndef postorder(node, visitor = printwithspace):\n    dfs('LRN', node, visitor)\n \ndef ls(node, more, visitor, order='TB'):\n    \"Level-based Top-to-Bottom or Bottom-to-Top tree search\"\n    if node:\n        if more is None:\n            more = []\n        more += [node.left, node.right]\n    for action in order:\n        if action == 'B' and more:\n            ls(more[0], more[1:], visitor, order)\n        elif action == 'T' and node:\n            visitor(node.data)\n\ndef levelorder(node, more=None, visitor = printwithspace):\n    ls(node, more, visitor, 'TB') \n \n\ndef reverse_preorder(node, visitor = printwithspace):\n    dfs('RLN', node, visitor)\n    \ndef bottom_up_order(node, more=None, visitor = printwithspace, order='BT'):\n    ls(node, more, visitor, 'BT')\n\n\nif __name__ == '__main__':\n    w = 10\n    for traversal in [preorder, inorder, postorder, levelorder, \n                      reverse_preorder, bottom_up_order]:\n        if traversal == reverse_preorder:\n            w = 20\n            print('\\nThe generalisation of function dfs allows:')\n        if traversal == bottom_up_order:\n            print('The generalisation of function ls allows:')\n        print(f\"{traversal.__name__:>{w}}:\", end=' ')\n        traversal(tree)\n        print()\n"}
{"id": 7167, "name": "List comprehensions", "source": "Translate Fortran to C#: \n\n\n\n\n\n\n\n\n\n\n\n\n \nprogram list_comprehension\n  integer, parameter :: n = 20\n  integer, parameter :: m = n*(n+1)/2\n  integer :: i, j\n  complex, dimension(m) :: a\n  real, dimension(m) :: b\n  logical, dimension(m) :: c\n  integer, dimension(3, m) :: d\n  a = [ ( ( cmplx(i,j), i=j,n), j=1,n) ] \n  b = abs(a)\n  c = (b .eq. int(b)) .and. (b .le. n)\n  i = sum(merge(1,0,c))\n  d(2,:i) = int(real(pack(a, c))) \n  d(1,:i) = int(imag(pack(a, c))) \n  d(3,:i) = int(pack(b,c))\n  print '(3i4)',d(:,:i)\nend program list_comprehension\n", "target": "using System.Linq;\n\nstatic class Program\n{\n  static void Main()\n  {\n    var ts =\n      from a in Enumerable.Range(1, 20)\n      from b in Enumerable.Range(a, 21 - a)\n      from c in Enumerable.Range(b, 21 - b)\n      where a * a + b * b == c * c\n      select new { a, b, c };\n\n      foreach (var t in ts)\n        System.Console.WriteLine(\"{0}, {1}, {2}\", t.a, t.b, t.c);\n  }\n}\n"}
{"id": 7170, "name": "List comprehensions", "source": "Translate Fortran to Java: \n\n\n\n\n\n\n\n\n\n\n\n\n \nprogram list_comprehension\n  integer, parameter :: n = 20\n  integer, parameter :: m = n*(n+1)/2\n  integer :: i, j\n  complex, dimension(m) :: a\n  real, dimension(m) :: b\n  logical, dimension(m) :: c\n  integer, dimension(3, m) :: d\n  a = [ ( ( cmplx(i,j), i=j,n), j=1,n) ] \n  b = abs(a)\n  c = (b .eq. int(b)) .and. (b .le. n)\n  i = sum(merge(1,0,c))\n  d(2,:i) = int(real(pack(a, c))) \n  d(1,:i) = int(imag(pack(a, c))) \n  d(3,:i) = int(pack(b,c))\n  print '(3i4)',d(:,:i)\nend program list_comprehension\n", "target": "\nimport java.util.Arrays;\nimport java.util.List;\nimport static java.util.function.Function.identity;\nimport static java.util.stream.Collectors.toList;\nimport static java.util.stream.IntStream.range;\npublic interface PythagComp{\n    static void main(String... args){\n        System.out.println(run(20));\n    }\n\n    static List<List<Integer>> run(int n){\n        return\n            \n            \n            range(1, n).mapToObj(\n                x -> range(x, n).mapToObj(\n                    y -> range(y, n).mapToObj(\n                        z -> new Integer[]{x, y, z}\n                    )\n                )\n            )\n                .flatMap(identity())\n                .flatMap(identity())\n                \n                .filter(a -> a[0]*a[0] + a[1]*a[1] == a[2]*a[2])\n                \n                .map(Arrays::asList)\n                \n                .collect(toList())\n        ;\n    }\n}\n"}
{"id": 7171, "name": "List comprehensions", "source": "Translate Fortran to Python: \n\n\n\n\n\n\n\n\n\n\n\n\n \nprogram list_comprehension\n  integer, parameter :: n = 20\n  integer, parameter :: m = n*(n+1)/2\n  integer :: i, j\n  complex, dimension(m) :: a\n  real, dimension(m) :: b\n  logical, dimension(m) :: c\n  integer, dimension(3, m) :: d\n  a = [ ( ( cmplx(i,j), i=j,n), j=1,n) ] \n  b = abs(a)\n  c = (b .eq. int(b)) .and. (b .le. n)\n  i = sum(merge(1,0,c))\n  d(2,:i) = int(real(pack(a, c))) \n  d(1,:i) = int(imag(pack(a, c))) \n  d(3,:i) = int(pack(b,c))\n  print '(3i4)',d(:,:i)\nend program list_comprehension\n", "target": "[(x,y,z) for x in xrange(1,n+1) for y in xrange(x,n+1) for z in xrange(y,n+1) if x**2 + y**2 == z**2]\n"}
{"id": 7549, "name": "Abundant odd numbers", "source": "Translate Fortran to C#: program main\nuse,intrinsic :: iso_fortran_env, only : int8, int16, int32, int64\nimplicit none\ninteger,parameter          :: dp=kind(0.0d0)\ncharacter(len=*),parameter :: g='(*(g0,1x))'\ninteger                    :: j, icount\ninteger,allocatable        :: list(:)\nreal(kind=dp)              :: tally\n\n   write(*,*)'N sum'\n   icount=0                       \n   do j=1,huge(0)-1,2             \n      list=divisors(j)            \n      tally= sum([real(list,kind=dp)]) \n      if(tally>2*j .and. iand(j,1) /= 0) then \n         icount=icount+1\n         select case(icount)  \n         case(1:25,1000);write(*,g)icount,':',j\n         end select\n      endif\n      if(icount.gt.1000)exit \n   enddo\n\n   do j=1000000001,huge(0),2\n      list=divisors(j)\n      tally= sum([real(list,kind=dp)])\n      if(tally>2*j .and. iand(j,1) /= 0) then\n         write(*,g)'First abundant odd number greater than one billion:',j\n\n         exit\n      endif\n   enddo\n\ncontains\n\nfunction divisors(num) result (numbers)\n\ninteger,intent(in) :: num\ninteger :: i\ninteger,allocatable :: numbers(:)\n   numbers=[integer :: ]\n   do i=1 , int(sqrt(real(num)))\n      if (mod(num , i)  .eq. 0) numbers=[numbers, i,num/i]\n   enddo\nend function divisors\n\nend program main\n", "target": "using static System.Console;\nusing System.Collections.Generic;\nusing System.Linq;\n\npublic static class AbundantOddNumbers\n{\n    public static void Main() {\n        WriteLine(\"First 25 abundant odd numbers:\");\n        foreach (var x in AbundantNumbers().Take(25)) WriteLine(x.Format());\n        WriteLine();\n        WriteLine($\"The 1000th abundant odd number: {AbundantNumbers().ElementAt(999).Format()}\");\n        WriteLine();\n        WriteLine($\"First abundant odd number > 1b: {AbundantNumbers(1_000_000_001).First().Format()}\");\n    }\n\n    static IEnumerable<(int n, int sum)> AbundantNumbers(int start = 3) =>\n        start.UpBy(2).Select(n => (n, sum: n.DivisorSum())).Where(x => x.sum > x.n);\n\n    static int DivisorSum(this int n) => 3.UpBy(2).TakeWhile(i => i * i <= n).Where(i => n % i == 0)\n        .Select(i => (a:i, b:n/i)).Sum(p => p.a == p.b ? p.a : p.a + p.b) + 1;\n\n    static IEnumerable<int> UpBy(this int n, int step) {\n        for (int i = n; ; i+=step) yield return i;\n    }\n\n    static string Format(this (int n, int sum) pair) => $\"{pair.n:N0} with sum {pair.sum:N0}\";\n}\n"}
{"id": 7550, "name": "Abundant odd numbers", "source": "Translate Fortran to C#: program main\nuse,intrinsic :: iso_fortran_env, only : int8, int16, int32, int64\nimplicit none\ninteger,parameter          :: dp=kind(0.0d0)\ncharacter(len=*),parameter :: g='(*(g0,1x))'\ninteger                    :: j, icount\ninteger,allocatable        :: list(:)\nreal(kind=dp)              :: tally\n\n   write(*,*)'N sum'\n   icount=0                       \n   do j=1,huge(0)-1,2             \n      list=divisors(j)            \n      tally= sum([real(list,kind=dp)]) \n      if(tally>2*j .and. iand(j,1) /= 0) then \n         icount=icount+1\n         select case(icount)  \n         case(1:25,1000);write(*,g)icount,':',j\n         end select\n      endif\n      if(icount.gt.1000)exit \n   enddo\n\n   do j=1000000001,huge(0),2\n      list=divisors(j)\n      tally= sum([real(list,kind=dp)])\n      if(tally>2*j .and. iand(j,1) /= 0) then\n         write(*,g)'First abundant odd number greater than one billion:',j\n\n         exit\n      endif\n   enddo\n\ncontains\n\nfunction divisors(num) result (numbers)\n\ninteger,intent(in) :: num\ninteger :: i\ninteger,allocatable :: numbers(:)\n   numbers=[integer :: ]\n   do i=1 , int(sqrt(real(num)))\n      if (mod(num , i)  .eq. 0) numbers=[numbers, i,num/i]\n   enddo\nend function divisors\n\nend program main\n", "target": "using static System.Console;\nusing System.Collections.Generic;\nusing System.Linq;\n\npublic static class AbundantOddNumbers\n{\n    public static void Main() {\n        WriteLine(\"First 25 abundant odd numbers:\");\n        foreach (var x in AbundantNumbers().Take(25)) WriteLine(x.Format());\n        WriteLine();\n        WriteLine($\"The 1000th abundant odd number: {AbundantNumbers().ElementAt(999).Format()}\");\n        WriteLine();\n        WriteLine($\"First abundant odd number > 1b: {AbundantNumbers(1_000_000_001).First().Format()}\");\n    }\n\n    static IEnumerable<(int n, int sum)> AbundantNumbers(int start = 3) =>\n        start.UpBy(2).Select(n => (n, sum: n.DivisorSum())).Where(x => x.sum > x.n);\n\n    static int DivisorSum(this int n) => 3.UpBy(2).TakeWhile(i => i * i <= n).Where(i => n % i == 0)\n        .Select(i => (a:i, b:n/i)).Sum(p => p.a == p.b ? p.a : p.a + p.b) + 1;\n\n    static IEnumerable<int> UpBy(this int n, int step) {\n        for (int i = n; ; i+=step) yield return i;\n    }\n\n    static string Format(this (int n, int sum) pair) => $\"{pair.n:N0} with sum {pair.sum:N0}\";\n}\n"}
{"id": 7555, "name": "Abundant odd numbers", "source": "Translate Fortran to Java: program main\nuse,intrinsic :: iso_fortran_env, only : int8, int16, int32, int64\nimplicit none\ninteger,parameter          :: dp=kind(0.0d0)\ncharacter(len=*),parameter :: g='(*(g0,1x))'\ninteger                    :: j, icount\ninteger,allocatable        :: list(:)\nreal(kind=dp)              :: tally\n\n   write(*,*)'N sum'\n   icount=0                       \n   do j=1,huge(0)-1,2             \n      list=divisors(j)            \n      tally= sum([real(list,kind=dp)]) \n      if(tally>2*j .and. iand(j,1) /= 0) then \n         icount=icount+1\n         select case(icount)  \n         case(1:25,1000);write(*,g)icount,':',j\n         end select\n      endif\n      if(icount.gt.1000)exit \n   enddo\n\n   do j=1000000001,huge(0),2\n      list=divisors(j)\n      tally= sum([real(list,kind=dp)])\n      if(tally>2*j .and. iand(j,1) /= 0) then\n         write(*,g)'First abundant odd number greater than one billion:',j\n\n         exit\n      endif\n   enddo\n\ncontains\n\nfunction divisors(num) result (numbers)\n\ninteger,intent(in) :: num\ninteger :: i\ninteger,allocatable :: numbers(:)\n   numbers=[integer :: ]\n   do i=1 , int(sqrt(real(num)))\n      if (mod(num , i)  .eq. 0) numbers=[numbers, i,num/i]\n   enddo\nend function divisors\n\nend program main\n", "target": "import java.util.ArrayList;\nimport java.util.List;\n\npublic class AbundantOddNumbers {\n    private static List<Integer> list = new ArrayList<>();\n    private static List<Integer> result = new ArrayList<>();\n\n    public static void main(String[] args) {\n        System.out.println(\"First 25: \");\n        abundantOdd(1,100000, 25, false);\n\n        System.out.println(\"\\n\\nThousandth: \");\n        abundantOdd(1,2500000, 1000, true);\n\n        System.out.println(\"\\n\\nFirst over 1bn:\"); \n        abundantOdd(1000000001, 2147483647, 1, false);\n    }\n    private static void abundantOdd(int start, int finish, int listSize, boolean printOne) {\n        for (int oddNum = start; oddNum < finish; oddNum += 2) {\n            list.clear();\n            for (int toDivide = 1; toDivide < oddNum; toDivide+=2) {\n                if (oddNum % toDivide == 0)\n                    list.add(toDivide);\n            }\n            if (sumList(list) > oddNum) {\n                if(!printOne)\n                    System.out.printf(\"%5d <= %5d \\n\",oddNum, sumList(list) );\n                result.add(oddNum);\n            }\n            if(printOne && result.size() >= listSize)\n                System.out.printf(\"%5d <= %5d \\n\",oddNum, sumList(list) );\n\n            if(result.size() >= listSize) break;\n        }\n    }\n    private static int sumList(List list) {\n        int sum = 0;\n        for (int i = 0; i < list.size(); i++) {\n            String temp = list.get(i).toString();\n            sum += Integer.parseInt(temp);\n        }\n        return sum;\n    }\n}\n"}
{"id": 7556, "name": "Abundant odd numbers", "source": "Translate Fortran to Java: program main\nuse,intrinsic :: iso_fortran_env, only : int8, int16, int32, int64\nimplicit none\ninteger,parameter          :: dp=kind(0.0d0)\ncharacter(len=*),parameter :: g='(*(g0,1x))'\ninteger                    :: j, icount\ninteger,allocatable        :: list(:)\nreal(kind=dp)              :: tally\n\n   write(*,*)'N sum'\n   icount=0                       \n   do j=1,huge(0)-1,2             \n      list=divisors(j)            \n      tally= sum([real(list,kind=dp)]) \n      if(tally>2*j .and. iand(j,1) /= 0) then \n         icount=icount+1\n         select case(icount)  \n         case(1:25,1000);write(*,g)icount,':',j\n         end select\n      endif\n      if(icount.gt.1000)exit \n   enddo\n\n   do j=1000000001,huge(0),2\n      list=divisors(j)\n      tally= sum([real(list,kind=dp)])\n      if(tally>2*j .and. iand(j,1) /= 0) then\n         write(*,g)'First abundant odd number greater than one billion:',j\n\n         exit\n      endif\n   enddo\n\ncontains\n\nfunction divisors(num) result (numbers)\n\ninteger,intent(in) :: num\ninteger :: i\ninteger,allocatable :: numbers(:)\n   numbers=[integer :: ]\n   do i=1 , int(sqrt(real(num)))\n      if (mod(num , i)  .eq. 0) numbers=[numbers, i,num/i]\n   enddo\nend function divisors\n\nend program main\n", "target": "import java.util.ArrayList;\nimport java.util.List;\n\npublic class AbundantOddNumbers {\n    private static List<Integer> list = new ArrayList<>();\n    private static List<Integer> result = new ArrayList<>();\n\n    public static void main(String[] args) {\n        System.out.println(\"First 25: \");\n        abundantOdd(1,100000, 25, false);\n\n        System.out.println(\"\\n\\nThousandth: \");\n        abundantOdd(1,2500000, 1000, true);\n\n        System.out.println(\"\\n\\nFirst over 1bn:\"); \n        abundantOdd(1000000001, 2147483647, 1, false);\n    }\n    private static void abundantOdd(int start, int finish, int listSize, boolean printOne) {\n        for (int oddNum = start; oddNum < finish; oddNum += 2) {\n            list.clear();\n            for (int toDivide = 1; toDivide < oddNum; toDivide+=2) {\n                if (oddNum % toDivide == 0)\n                    list.add(toDivide);\n            }\n            if (sumList(list) > oddNum) {\n                if(!printOne)\n                    System.out.printf(\"%5d <= %5d \\n\",oddNum, sumList(list) );\n                result.add(oddNum);\n            }\n            if(printOne && result.size() >= listSize)\n                System.out.printf(\"%5d <= %5d \\n\",oddNum, sumList(list) );\n\n            if(result.size() >= listSize) break;\n        }\n    }\n    private static int sumList(List list) {\n        int sum = 0;\n        for (int i = 0; i < list.size(); i++) {\n            String temp = list.get(i).toString();\n            sum += Integer.parseInt(temp);\n        }\n        return sum;\n    }\n}\n"}
{"id": 7557, "name": "Abundant odd numbers", "source": "Translate Fortran to Python: program main\nuse,intrinsic :: iso_fortran_env, only : int8, int16, int32, int64\nimplicit none\ninteger,parameter          :: dp=kind(0.0d0)\ncharacter(len=*),parameter :: g='(*(g0,1x))'\ninteger                    :: j, icount\ninteger,allocatable        :: list(:)\nreal(kind=dp)              :: tally\n\n   write(*,*)'N sum'\n   icount=0                       \n   do j=1,huge(0)-1,2             \n      list=divisors(j)            \n      tally= sum([real(list,kind=dp)]) \n      if(tally>2*j .and. iand(j,1) /= 0) then \n         icount=icount+1\n         select case(icount)  \n         case(1:25,1000);write(*,g)icount,':',j\n         end select\n      endif\n      if(icount.gt.1000)exit \n   enddo\n\n   do j=1000000001,huge(0),2\n      list=divisors(j)\n      tally= sum([real(list,kind=dp)])\n      if(tally>2*j .and. iand(j,1) /= 0) then\n         write(*,g)'First abundant odd number greater than one billion:',j\n\n         exit\n      endif\n   enddo\n\ncontains\n\nfunction divisors(num) result (numbers)\n\ninteger,intent(in) :: num\ninteger :: i\ninteger,allocatable :: numbers(:)\n   numbers=[integer :: ]\n   do i=1 , int(sqrt(real(num)))\n      if (mod(num , i)  .eq. 0) numbers=[numbers, i,num/i]\n   enddo\nend function divisors\n\nend program main\n", "target": "\n\n\noddNumber  = 1\naCount  = 0\ndSum  = 0\n \nfrom math import sqrt\n \ndef divisorSum(n):\n    sum = 1\n    i = int(sqrt(n)+1)\n \n    for d in range (2, i):\n        if n % d == 0:\n            sum += d\n            otherD = n // d\n            if otherD != d:\n                sum += otherD\n    return sum\n \nprint (\"The first 25 abundant odd numbers:\")\nwhile aCount  < 25:\n    dSum  = divisorSum(oddNumber )\n    if dSum  > oddNumber :\n        aCount  += 1\n        print(\"{0:5} proper divisor sum: {1}\". format(oddNumber ,dSum ))\n    oddNumber  += 2\n \nwhile aCount  < 1000:\n    dSum  = divisorSum(oddNumber )\n    if dSum  > oddNumber :\n        aCount  += 1\n    oddNumber  += 2\nprint (\"\\n1000th abundant odd number:\")\nprint (\"    \",(oddNumber - 2),\" proper divisor sum: \",dSum)\n \noddNumber  = 1000000001\nfound  = False\nwhile not found :\n    dSum  = divisorSum(oddNumber )\n    if dSum  > oddNumber :\n        found  = True\n        print (\"\\nFirst abundant odd number > 1 000 000 000:\")\n        print (\"    \",oddNumber,\" proper divisor sum: \",dSum)\n    oddNumber  += 2\n"}
{"id": 7558, "name": "Abundant odd numbers", "source": "Translate Fortran to Python: program main\nuse,intrinsic :: iso_fortran_env, only : int8, int16, int32, int64\nimplicit none\ninteger,parameter          :: dp=kind(0.0d0)\ncharacter(len=*),parameter :: g='(*(g0,1x))'\ninteger                    :: j, icount\ninteger,allocatable        :: list(:)\nreal(kind=dp)              :: tally\n\n   write(*,*)'N sum'\n   icount=0                       \n   do j=1,huge(0)-1,2             \n      list=divisors(j)            \n      tally= sum([real(list,kind=dp)]) \n      if(tally>2*j .and. iand(j,1) /= 0) then \n         icount=icount+1\n         select case(icount)  \n         case(1:25,1000);write(*,g)icount,':',j\n         end select\n      endif\n      if(icount.gt.1000)exit \n   enddo\n\n   do j=1000000001,huge(0),2\n      list=divisors(j)\n      tally= sum([real(list,kind=dp)])\n      if(tally>2*j .and. iand(j,1) /= 0) then\n         write(*,g)'First abundant odd number greater than one billion:',j\n\n         exit\n      endif\n   enddo\n\ncontains\n\nfunction divisors(num) result (numbers)\n\ninteger,intent(in) :: num\ninteger :: i\ninteger,allocatable :: numbers(:)\n   numbers=[integer :: ]\n   do i=1 , int(sqrt(real(num)))\n      if (mod(num , i)  .eq. 0) numbers=[numbers, i,num/i]\n   enddo\nend function divisors\n\nend program main\n", "target": "\n\n\noddNumber  = 1\naCount  = 0\ndSum  = 0\n \nfrom math import sqrt\n \ndef divisorSum(n):\n    sum = 1\n    i = int(sqrt(n)+1)\n \n    for d in range (2, i):\n        if n % d == 0:\n            sum += d\n            otherD = n // d\n            if otherD != d:\n                sum += otherD\n    return sum\n \nprint (\"The first 25 abundant odd numbers:\")\nwhile aCount  < 25:\n    dSum  = divisorSum(oddNumber )\n    if dSum  > oddNumber :\n        aCount  += 1\n        print(\"{0:5} proper divisor sum: {1}\". format(oddNumber ,dSum ))\n    oddNumber  += 2\n \nwhile aCount  < 1000:\n    dSum  = divisorSum(oddNumber )\n    if dSum  > oddNumber :\n        aCount  += 1\n    oddNumber  += 2\nprint (\"\\n1000th abundant odd number:\")\nprint (\"    \",(oddNumber - 2),\" proper divisor sum: \",dSum)\n \noddNumber  = 1000000001\nfound  = False\nwhile not found :\n    dSum  = divisorSum(oddNumber )\n    if dSum  > oddNumber :\n        found  = True\n        print (\"\\nFirst abundant odd number > 1 000 000 000:\")\n        print (\"    \",oddNumber,\" proper divisor sum: \",dSum)\n    oddNumber  += 2\n"}
{"id": 8081, "name": "Combinations", "source": "Translate Fortran to C#: program Combinations\n  use iso_fortran_env\n  implicit none\n\n  type comb_result\n     integer, dimension(:), allocatable :: combs\n  end type comb_result\n\n  type(comb_result), dimension(:), pointer :: r\n  integer :: i, j\n\n  call comb(5, 3, r)\n  do i = 0, choose(5, 3) - 1\n     do j = 2, 0, -1\n        write(*, \"(I4, ' ')\", advance=\"no\") r(i)%combs(j)\n     end do\n     deallocate(r(i)%combs)\n     write(*,*) \"\"\n  end do\n  deallocate(r)\n\ncontains\n\n  function choose(n, k, err)\n    integer :: choose\n    integer, intent(in) :: n, k\n    integer, optional, intent(out) :: err\n\n    integer :: imax, i, imin, ie\n\n    ie = 0\n    if ( (n < 0 ) .or. (k < 0 ) ) then\n       write(ERROR_UNIT, *) \"negative in choose\"\n       choose = 0\n       ie = 1\n    else\n       if ( n < k ) then\n          choose = 0\n       else if ( n == k ) then\n          choose = 1\n       else\n          imax = max(k, n-k)\n          imin = min(k, n-k)\n          choose = 1\n          do i = imax+1, n\n             choose = choose * i\n          end do\n          do i = 2, imin\n             choose = choose / i\n          end do\n       end if\n    end if\n    if ( present(err) ) err = ie\n  end function choose\n\n  subroutine comb(n, k, co)\n    integer, intent(in) :: n, k\n    type(comb_result), dimension(:), pointer, intent(out) :: co\n\n    integer :: i, j, s, ix, kx, hm, t\n    integer :: err\n   \n    hm = choose(n, k, err)\n    if ( err /= 0 ) then\n       nullify(co)\n       return\n    end if\n\n    allocate(co(0:hm-1))\n    do i = 0, hm-1\n       allocate(co(i)%combs(0:k-1))\n    end do\n    do i = 0, hm-1\n       ix = i; kx = k\n       do s = 0, n-1\n          if ( kx == 0 ) exit\n          t = choose(n-(s+1), kx-1)\n          if ( ix < t ) then\n             co(i)%combs(kx-1) = s\n             kx = kx - 1\n          else\n             ix = ix - t\n          end if\n       end do\n    end do\n\n  end subroutine comb\n\nend program Combinations\n", "target": "using System;\nusing System.Collections.Generic;\n\npublic class Program\n{\n    public static IEnumerable<int[]> Combinations(int m, int n)\n    {\n            int[] result = new int[m];\n            Stack<int> stack = new Stack<int>();\n            stack.Push(0);\n\n            while (stack.Count > 0)\n           {\n                int index = stack.Count - 1;\n                int value = stack.Pop();\n\n                while (value < n) \n               {\n                    result[index++] = ++value;\n                    stack.Push(value);\n\n                    if (index == m) \n                    {\n                        yield return result;\n                        break;\n                    }\n                }\n            }\n    }\n\n    static void Main()\n    {\n        foreach (int[] c in Combinations(3, 5))\n        {\n            Console.WriteLine(string.Join(\",\", c));\n            Console.WriteLine();\n        }\n    }\n}\n"}
{"id": 8085, "name": "Combinations", "source": "Translate Fortran to Java: program Combinations\n  use iso_fortran_env\n  implicit none\n\n  type comb_result\n     integer, dimension(:), allocatable :: combs\n  end type comb_result\n\n  type(comb_result), dimension(:), pointer :: r\n  integer :: i, j\n\n  call comb(5, 3, r)\n  do i = 0, choose(5, 3) - 1\n     do j = 2, 0, -1\n        write(*, \"(I4, ' ')\", advance=\"no\") r(i)%combs(j)\n     end do\n     deallocate(r(i)%combs)\n     write(*,*) \"\"\n  end do\n  deallocate(r)\n\ncontains\n\n  function choose(n, k, err)\n    integer :: choose\n    integer, intent(in) :: n, k\n    integer, optional, intent(out) :: err\n\n    integer :: imax, i, imin, ie\n\n    ie = 0\n    if ( (n < 0 ) .or. (k < 0 ) ) then\n       write(ERROR_UNIT, *) \"negative in choose\"\n       choose = 0\n       ie = 1\n    else\n       if ( n < k ) then\n          choose = 0\n       else if ( n == k ) then\n          choose = 1\n       else\n          imax = max(k, n-k)\n          imin = min(k, n-k)\n          choose = 1\n          do i = imax+1, n\n             choose = choose * i\n          end do\n          do i = 2, imin\n             choose = choose / i\n          end do\n       end if\n    end if\n    if ( present(err) ) err = ie\n  end function choose\n\n  subroutine comb(n, k, co)\n    integer, intent(in) :: n, k\n    type(comb_result), dimension(:), pointer, intent(out) :: co\n\n    integer :: i, j, s, ix, kx, hm, t\n    integer :: err\n   \n    hm = choose(n, k, err)\n    if ( err /= 0 ) then\n       nullify(co)\n       return\n    end if\n\n    allocate(co(0:hm-1))\n    do i = 0, hm-1\n       allocate(co(i)%combs(0:k-1))\n    end do\n    do i = 0, hm-1\n       ix = i; kx = k\n       do s = 0, n-1\n          if ( kx == 0 ) exit\n          t = choose(n-(s+1), kx-1)\n          if ( ix < t ) then\n             co(i)%combs(kx-1) = s\n             kx = kx - 1\n          else\n             ix = ix - t\n          end if\n       end do\n    end do\n\n  end subroutine comb\n\nend program Combinations\n", "target": "import java.util.Collections;\nimport java.util.LinkedList;\n\npublic class Comb{\n\n        public static void main(String[] args){\n                System.out.println(comb(3,5));\n        }\n\n        public static String bitprint(int u){\n                String s= \"\";\n                for(int n= 0;u > 0;++n, u>>= 1)\n                        if((u & 1) > 0) s+= n + \" \";\n                return s;\n        }\n\n        public static int bitcount(int u){\n                int n;\n                for(n= 0;u > 0;++n, u&= (u - 1));\n                return n;\n        }\n\n        public static LinkedList<String> comb(int c, int n){\n                LinkedList<String> s= new LinkedList<String>();\n                for(int u= 0;u < 1 << n;u++)\n                        if(bitcount(u) == c) s.push(bitprint(u));\n                Collections.sort(s);\n                return s;\n        }\n}\n"}
{"id": 8086, "name": "Combinations", "source": "Translate Fortran to Python: program Combinations\n  use iso_fortran_env\n  implicit none\n\n  type comb_result\n     integer, dimension(:), allocatable :: combs\n  end type comb_result\n\n  type(comb_result), dimension(:), pointer :: r\n  integer :: i, j\n\n  call comb(5, 3, r)\n  do i = 0, choose(5, 3) - 1\n     do j = 2, 0, -1\n        write(*, \"(I4, ' ')\", advance=\"no\") r(i)%combs(j)\n     end do\n     deallocate(r(i)%combs)\n     write(*,*) \"\"\n  end do\n  deallocate(r)\n\ncontains\n\n  function choose(n, k, err)\n    integer :: choose\n    integer, intent(in) :: n, k\n    integer, optional, intent(out) :: err\n\n    integer :: imax, i, imin, ie\n\n    ie = 0\n    if ( (n < 0 ) .or. (k < 0 ) ) then\n       write(ERROR_UNIT, *) \"negative in choose\"\n       choose = 0\n       ie = 1\n    else\n       if ( n < k ) then\n          choose = 0\n       else if ( n == k ) then\n          choose = 1\n       else\n          imax = max(k, n-k)\n          imin = min(k, n-k)\n          choose = 1\n          do i = imax+1, n\n             choose = choose * i\n          end do\n          do i = 2, imin\n             choose = choose / i\n          end do\n       end if\n    end if\n    if ( present(err) ) err = ie\n  end function choose\n\n  subroutine comb(n, k, co)\n    integer, intent(in) :: n, k\n    type(comb_result), dimension(:), pointer, intent(out) :: co\n\n    integer :: i, j, s, ix, kx, hm, t\n    integer :: err\n   \n    hm = choose(n, k, err)\n    if ( err /= 0 ) then\n       nullify(co)\n       return\n    end if\n\n    allocate(co(0:hm-1))\n    do i = 0, hm-1\n       allocate(co(i)%combs(0:k-1))\n    end do\n    do i = 0, hm-1\n       ix = i; kx = k\n       do s = 0, n-1\n          if ( kx == 0 ) exit\n          t = choose(n-(s+1), kx-1)\n          if ( ix < t ) then\n             co(i)%combs(kx-1) = s\n             kx = kx - 1\n          else\n             ix = ix - t\n          end if\n       end do\n    end do\n\n  end subroutine comb\n\nend program Combinations\n", "target": ">>> from itertools import combinations\n>>> list(combinations(range(5),3))\n[(0, 1, 2), (0, 1, 3), (0, 1, 4), (0, 2, 3), (0, 2, 4), (0, 3, 4), (1, 2, 3), (1, 2, 4), (1, 3, 4), (2, 3, 4)]\n"}
{"id": 8628, "name": "Department numbers", "source": "Translate Fortran to C#:       INTEGER P,S,F\t\n    1  PP:DO P = 2,7,2\t\n    2   SS:DO S = 1,7\t\t\n    3        IF (P.EQ.S) CYCLE SS\t\n    4        F = 12 - (P + S)\t\t\n    5        IF (F.LE.0 .OR. F.GT.7) CYCLE SS\t\n    6        IF ((F - S)*(F - P)) 7,8,7\t\t\n    7        WRITE (6,\"(3I2)\") P,S,F\t\t\n    8      END DO SS\t\t\n    9    END DO PP\t\n      END\t\n", "target": "using System;\npublic class Program\n{\n    public static void Main() {\n        for (int p = 2; p <= 7; p+=2) {\n            for (int s = 1; s <= 7; s++) {\n                int f = 12 - p - s;\n                if (s >= f) break;\n                if (f > 7) continue;\n                if (s == p || f == p) continue; \n                Console.WriteLine($\"Police:{p}, Sanitation:{s}, Fire:{f}\");\n                Console.WriteLine($\"Police:{p}, Sanitation:{f}, Fire:{s}\");\n            }\n        }\n    }\n}\n"}
{"id": 8629, "name": "Department numbers", "source": "Translate Fortran to C#:       INTEGER P,S,F\t\n    1  PP:DO P = 2,7,2\t\n    2   SS:DO S = 1,7\t\t\n    3        IF (P.EQ.S) CYCLE SS\t\n    4        F = 12 - (P + S)\t\t\n    5        IF (F.LE.0 .OR. F.GT.7) CYCLE SS\t\n    6        IF ((F - S)*(F - P)) 7,8,7\t\t\n    7        WRITE (6,\"(3I2)\") P,S,F\t\t\n    8      END DO SS\t\t\n    9    END DO PP\t\n      END\t\n", "target": "using System;\npublic class Program\n{\n    public static void Main() {\n        for (int p = 2; p <= 7; p+=2) {\n            for (int s = 1; s <= 7; s++) {\n                int f = 12 - p - s;\n                if (s >= f) break;\n                if (f > 7) continue;\n                if (s == p || f == p) continue; \n                Console.WriteLine($\"Police:{p}, Sanitation:{s}, Fire:{f}\");\n                Console.WriteLine($\"Police:{p}, Sanitation:{f}, Fire:{s}\");\n            }\n        }\n    }\n}\n"}
{"id": 8634, "name": "Department numbers", "source": "Translate Fortran to Java:       INTEGER P,S,F\t\n    1  PP:DO P = 2,7,2\t\n    2   SS:DO S = 1,7\t\t\n    3        IF (P.EQ.S) CYCLE SS\t\n    4        F = 12 - (P + S)\t\t\n    5        IF (F.LE.0 .OR. F.GT.7) CYCLE SS\t\n    6        IF ((F - S)*(F - P)) 7,8,7\t\t\n    7        WRITE (6,\"(3I2)\") P,S,F\t\t\n    8      END DO SS\t\t\n    9    END DO PP\t\n      END\t\n", "target": "public class DepartmentNumbers {\n    public static void main(String[] args) {\n        System.out.println(\"Police  Sanitation  Fire\");\n        System.out.println(\"------  ----------  ----\");\n        int count = 0;\n        for (int i = 2; i <= 6; i += 2) {\n            for (int j = 1; j <= 7; ++j) {\n                if (j == i) continue;\n                for (int k = 1; k <= 7; ++k) {\n                    if (k == i || k == j) continue;\n                    if (i + j + k != 12) continue;\n                    System.out.printf(\"  %d         %d         %d\\n\", i, j, k);\n                    count++;\n                }\n            }\n        }\n        System.out.printf(\"\\n%d valid combinations\", count);\n    }\n}\n"}
{"id": 8635, "name": "Department numbers", "source": "Translate Fortran to Java:       INTEGER P,S,F\t\n    1  PP:DO P = 2,7,2\t\n    2   SS:DO S = 1,7\t\t\n    3        IF (P.EQ.S) CYCLE SS\t\n    4        F = 12 - (P + S)\t\t\n    5        IF (F.LE.0 .OR. F.GT.7) CYCLE SS\t\n    6        IF ((F - S)*(F - P)) 7,8,7\t\t\n    7        WRITE (6,\"(3I2)\") P,S,F\t\t\n    8      END DO SS\t\t\n    9    END DO PP\t\n      END\t\n", "target": "public class DepartmentNumbers {\n    public static void main(String[] args) {\n        System.out.println(\"Police  Sanitation  Fire\");\n        System.out.println(\"------  ----------  ----\");\n        int count = 0;\n        for (int i = 2; i <= 6; i += 2) {\n            for (int j = 1; j <= 7; ++j) {\n                if (j == i) continue;\n                for (int k = 1; k <= 7; ++k) {\n                    if (k == i || k == j) continue;\n                    if (i + j + k != 12) continue;\n                    System.out.printf(\"  %d         %d         %d\\n\", i, j, k);\n                    count++;\n                }\n            }\n        }\n        System.out.printf(\"\\n%d valid combinations\", count);\n    }\n}\n"}
{"id": 8636, "name": "Department numbers", "source": "Translate Fortran to Python:       INTEGER P,S,F\t\n    1  PP:DO P = 2,7,2\t\n    2   SS:DO S = 1,7\t\t\n    3        IF (P.EQ.S) CYCLE SS\t\n    4        F = 12 - (P + S)\t\t\n    5        IF (F.LE.0 .OR. F.GT.7) CYCLE SS\t\n    6        IF ((F - S)*(F - P)) 7,8,7\t\t\n    7        WRITE (6,\"(3I2)\") P,S,F\t\t\n    8      END DO SS\t\t\n    9    END DO PP\t\n      END\t\n", "target": "from itertools import permutations\n \ndef solve():\n    c, p, f, s = \"\\\\,Police,Fire,Sanitation\".split(',')\n    print(f\"{c:>3}  {p:^6} {f:^4} {s:^10}\")\n    c = 1\n    for p, f, s in permutations(range(1, 8), r=3):\n        if p + s + f == 12 and p % 2 == 0:\n            print(f\"{c:>3}: {p:^6} {f:^4} {s:^10}\")\n            c += 1\n \nif __name__ == '__main__':\n    solve()\n"}
{"id": 8637, "name": "Department numbers", "source": "Translate Fortran to Python:       INTEGER P,S,F\t\n    1  PP:DO P = 2,7,2\t\n    2   SS:DO S = 1,7\t\t\n    3        IF (P.EQ.S) CYCLE SS\t\n    4        F = 12 - (P + S)\t\t\n    5        IF (F.LE.0 .OR. F.GT.7) CYCLE SS\t\n    6        IF ((F - S)*(F - P)) 7,8,7\t\t\n    7        WRITE (6,\"(3I2)\") P,S,F\t\t\n    8      END DO SS\t\t\n    9    END DO PP\t\n      END\t\n", "target": "from itertools import permutations\n \ndef solve():\n    c, p, f, s = \"\\\\,Police,Fire,Sanitation\".split(',')\n    print(f\"{c:>3}  {p:^6} {f:^4} {s:^10}\")\n    c = 1\n    for p, f, s in permutations(range(1, 8), r=3):\n        if p + s + f == 12 and p % 2 == 0:\n            print(f\"{c:>3}: {p:^6} {f:^4} {s:^10}\")\n            c += 1\n \nif __name__ == '__main__':\n    solve()\n"}
{"id": 9345, "name": "Singly-linked list_Traversal", "source": "Translate Fortran to C#: subroutine traversal(list,proc)\n   type(node), target    :: list\n   type(node), pointer   :: current\n   interface\n      subroutine proc(node)\n         real, intent(in) :: node\n      end subroutine proc\n   end interface\n   current => list\n   do while ( associated(current) )\n      call proc(current%data)\n      current => current%next\n   end do\nend subroutine traversal\n", "target": "var current = [head of list to traverse]\nwhile(current != null)\n{\n    \n\n    current = current.Next;\n}\n"}
{"id": 9348, "name": "Singly-linked list_Traversal", "source": "Translate Fortran to Java: subroutine traversal(list,proc)\n   type(node), target    :: list\n   type(node), pointer   :: current\n   interface\n      subroutine proc(node)\n         real, intent(in) :: node\n      end subroutine proc\n   end interface\n   current => list\n   do while ( associated(current) )\n      call proc(current%data)\n      current => current%next\n   end do\nend subroutine traversal\n", "target": "LinkedList<Type> list = new LinkedList<Type>();\n\nfor(Type i: list){\n  \n  System.out.println(i);\n}\n"}
{"id": 9349, "name": "Singly-linked list_Traversal", "source": "Translate Fortran to Python: subroutine traversal(list,proc)\n   type(node), target    :: list\n   type(node), pointer   :: current\n   interface\n      subroutine proc(node)\n         real, intent(in) :: node\n      end subroutine proc\n   end interface\n   current => list\n   do while ( associated(current) )\n      call proc(current%data)\n      current => current%next\n   end do\nend subroutine traversal\n", "target": "for node in lst:\n    print node.value\n"}
{"id": 9648, "name": "Haversine formula", "source": "Translate Fortran to C#: program example\nimplicit none\nreal :: d\n\nd = haversine(36.12,-86.67,33.94,-118.40) \nprint '(A,F9.4,A)', 'distance: ',d,' km' \n\ncontains\n\n      function to_radian(degree) result(rad)\n          \n          real,intent(in) :: degree\n          real, parameter :: deg_to_rad = atan(1.0)/45 \n          real :: rad\n\n          rad = degree*deg_to_rad\n      end function to_radian\n \n      function haversine(deglat1,deglon1,deglat2,deglon2) result (dist)\n          \n          real,intent(in) :: deglat1,deglon1,deglat2,deglon2\n          real :: a,c,dist,dlat,dlon,lat1,lat2\n          real,parameter :: radius = 6372.8 \n\n          dlat = to_radian(deglat2-deglat1)\n          dlon = to_radian(deglon2-deglon1)\n          lat1 = to_radian(deglat1)\n          lat2 = to_radian(deglat2)\n          a = (sin(dlat/2))**2 + cos(lat1)*cos(lat2)*(sin(dlon/2))**2\n          c = 2*asin(sqrt(a))\n          dist = radius*c\n      end function haversine\n\nend program example\n", "target": "public static class Haversine {\n  public static double calculate(double lat1, double lon1, double lat2, double lon2) {\n    var R = 6372.8; \n    var dLat = toRadians(lat2 - lat1);\n    var dLon = toRadians(lon2 - lon1);\n    lat1 = toRadians(lat1);\n    lat2 = toRadians(lat2);\n   \n    var a = Math.Sin(dLat / 2) * Math.Sin(dLat / 2) + Math.Sin(dLon / 2) * Math.Sin(dLon / 2) * Math.Cos(lat1) * Math.Cos(lat2);\n    var c = 2 * Math.Asin(Math.Sqrt(a));\n    return R * 2 * Math.Asin(Math.Sqrt(a));\n  }\n  \n  public static double toRadians(double angle) {\n    return Math.PI * angle / 180.0;\n  }\n}\n\nvoid Main() {\n  Console.WriteLine(String.Format(\"The distance between coordinates {0},{1} and {2},{3} is: {4}\", 36.12, -86.67, 33.94, -118.40, Haversine.calculate(36.12, -86.67, 33.94, -118.40)));\n}\n\n\n"}
{"id": 9649, "name": "Haversine formula", "source": "Translate Fortran to C#: program example\nimplicit none\nreal :: d\n\nd = haversine(36.12,-86.67,33.94,-118.40) \nprint '(A,F9.4,A)', 'distance: ',d,' km' \n\ncontains\n\n      function to_radian(degree) result(rad)\n          \n          real,intent(in) :: degree\n          real, parameter :: deg_to_rad = atan(1.0)/45 \n          real :: rad\n\n          rad = degree*deg_to_rad\n      end function to_radian\n \n      function haversine(deglat1,deglon1,deglat2,deglon2) result (dist)\n          \n          real,intent(in) :: deglat1,deglon1,deglat2,deglon2\n          real :: a,c,dist,dlat,dlon,lat1,lat2\n          real,parameter :: radius = 6372.8 \n\n          dlat = to_radian(deglat2-deglat1)\n          dlon = to_radian(deglon2-deglon1)\n          lat1 = to_radian(deglat1)\n          lat2 = to_radian(deglat2)\n          a = (sin(dlat/2))**2 + cos(lat1)*cos(lat2)*(sin(dlon/2))**2\n          c = 2*asin(sqrt(a))\n          dist = radius*c\n      end function haversine\n\nend program example\n", "target": "public static class Haversine {\n  public static double calculate(double lat1, double lon1, double lat2, double lon2) {\n    var R = 6372.8; \n    var dLat = toRadians(lat2 - lat1);\n    var dLon = toRadians(lon2 - lon1);\n    lat1 = toRadians(lat1);\n    lat2 = toRadians(lat2);\n   \n    var a = Math.Sin(dLat / 2) * Math.Sin(dLat / 2) + Math.Sin(dLon / 2) * Math.Sin(dLon / 2) * Math.Cos(lat1) * Math.Cos(lat2);\n    var c = 2 * Math.Asin(Math.Sqrt(a));\n    return R * 2 * Math.Asin(Math.Sqrt(a));\n  }\n  \n  public static double toRadians(double angle) {\n    return Math.PI * angle / 180.0;\n  }\n}\n\nvoid Main() {\n  Console.WriteLine(String.Format(\"The distance between coordinates {0},{1} and {2},{3} is: {4}\", 36.12, -86.67, 33.94, -118.40, Haversine.calculate(36.12, -86.67, 33.94, -118.40)));\n}\n\n\n"}
{"id": 9654, "name": "Haversine formula", "source": "Translate Fortran to Java: program example\nimplicit none\nreal :: d\n\nd = haversine(36.12,-86.67,33.94,-118.40) \nprint '(A,F9.4,A)', 'distance: ',d,' km' \n\ncontains\n\n      function to_radian(degree) result(rad)\n          \n          real,intent(in) :: degree\n          real, parameter :: deg_to_rad = atan(1.0)/45 \n          real :: rad\n\n          rad = degree*deg_to_rad\n      end function to_radian\n \n      function haversine(deglat1,deglon1,deglat2,deglon2) result (dist)\n          \n          real,intent(in) :: deglat1,deglon1,deglat2,deglon2\n          real :: a,c,dist,dlat,dlon,lat1,lat2\n          real,parameter :: radius = 6372.8 \n\n          dlat = to_radian(deglat2-deglat1)\n          dlon = to_radian(deglon2-deglon1)\n          lat1 = to_radian(deglat1)\n          lat2 = to_radian(deglat2)\n          a = (sin(dlat/2))**2 + cos(lat1)*cos(lat2)*(sin(dlon/2))**2\n          c = 2*asin(sqrt(a))\n          dist = radius*c\n      end function haversine\n\nend program example\n", "target": "public class Haversine {\n    public static final double R = 6372.8; \n\n    public static double haversine(double lat1, double lon1, double lat2, double lon2) {\n        lat1 = Math.toRadians(lat1);\n        lat2 = Math.toRadians(lat2);\n        double dLat = lat2 - lat1;\n        double dLon = Math.toRadians(lon2 - lon1);\n\n        double a = Math.pow(Math.sin(dLat / 2), 2) + Math.pow(Math.sin(dLon / 2), 2) * Math.cos(lat1) * Math.cos(lat2);\n        double c = 2 * Math.asin(Math.sqrt(a));\n        return R * c;\n    }\n\n    public static void main(String[] args) {\n        System.out.println(haversine(36.12, -86.67, 33.94, -118.40));\n    }\n}\n"}
{"id": 9655, "name": "Haversine formula", "source": "Translate Fortran to Java: program example\nimplicit none\nreal :: d\n\nd = haversine(36.12,-86.67,33.94,-118.40) \nprint '(A,F9.4,A)', 'distance: ',d,' km' \n\ncontains\n\n      function to_radian(degree) result(rad)\n          \n          real,intent(in) :: degree\n          real, parameter :: deg_to_rad = atan(1.0)/45 \n          real :: rad\n\n          rad = degree*deg_to_rad\n      end function to_radian\n \n      function haversine(deglat1,deglon1,deglat2,deglon2) result (dist)\n          \n          real,intent(in) :: deglat1,deglon1,deglat2,deglon2\n          real :: a,c,dist,dlat,dlon,lat1,lat2\n          real,parameter :: radius = 6372.8 \n\n          dlat = to_radian(deglat2-deglat1)\n          dlon = to_radian(deglon2-deglon1)\n          lat1 = to_radian(deglat1)\n          lat2 = to_radian(deglat2)\n          a = (sin(dlat/2))**2 + cos(lat1)*cos(lat2)*(sin(dlon/2))**2\n          c = 2*asin(sqrt(a))\n          dist = radius*c\n      end function haversine\n\nend program example\n", "target": "public class Haversine {\n    public static final double R = 6372.8; \n\n    public static double haversine(double lat1, double lon1, double lat2, double lon2) {\n        lat1 = Math.toRadians(lat1);\n        lat2 = Math.toRadians(lat2);\n        double dLat = lat2 - lat1;\n        double dLon = Math.toRadians(lon2 - lon1);\n\n        double a = Math.pow(Math.sin(dLat / 2), 2) + Math.pow(Math.sin(dLon / 2), 2) * Math.cos(lat1) * Math.cos(lat2);\n        double c = 2 * Math.asin(Math.sqrt(a));\n        return R * c;\n    }\n\n    public static void main(String[] args) {\n        System.out.println(haversine(36.12, -86.67, 33.94, -118.40));\n    }\n}\n"}
{"id": 9656, "name": "Haversine formula", "source": "Translate Fortran to Python: program example\nimplicit none\nreal :: d\n\nd = haversine(36.12,-86.67,33.94,-118.40) \nprint '(A,F9.4,A)', 'distance: ',d,' km' \n\ncontains\n\n      function to_radian(degree) result(rad)\n          \n          real,intent(in) :: degree\n          real, parameter :: deg_to_rad = atan(1.0)/45 \n          real :: rad\n\n          rad = degree*deg_to_rad\n      end function to_radian\n \n      function haversine(deglat1,deglon1,deglat2,deglon2) result (dist)\n          \n          real,intent(in) :: deglat1,deglon1,deglat2,deglon2\n          real :: a,c,dist,dlat,dlon,lat1,lat2\n          real,parameter :: radius = 6372.8 \n\n          dlat = to_radian(deglat2-deglat1)\n          dlon = to_radian(deglon2-deglon1)\n          lat1 = to_radian(deglat1)\n          lat2 = to_radian(deglat2)\n          a = (sin(dlat/2))**2 + cos(lat1)*cos(lat2)*(sin(dlon/2))**2\n          c = 2*asin(sqrt(a))\n          dist = radius*c\n      end function haversine\n\nend program example\n", "target": "from math import radians, sin, cos, sqrt, asin\n\n\ndef haversine(lat1, lon1, lat2, lon2):\n    R = 6372.8  \n\n    dLat = radians(lat2 - lat1)\n    dLon = radians(lon2 - lon1)\n    lat1 = radians(lat1)\n    lat2 = radians(lat2)\n\n    a = sin(dLat / 2)**2 + cos(lat1) * cos(lat2) * sin(dLon / 2)**2\n    c = 2 * asin(sqrt(a))\n\n    return R * c\n\n>>> haversine(36.12, -86.67, 33.94, -118.40)\n2887.2599506071106\n>>>\n"}
{"id": 9657, "name": "Haversine formula", "source": "Translate Fortran to Python: program example\nimplicit none\nreal :: d\n\nd = haversine(36.12,-86.67,33.94,-118.40) \nprint '(A,F9.4,A)', 'distance: ',d,' km' \n\ncontains\n\n      function to_radian(degree) result(rad)\n          \n          real,intent(in) :: degree\n          real, parameter :: deg_to_rad = atan(1.0)/45 \n          real :: rad\n\n          rad = degree*deg_to_rad\n      end function to_radian\n \n      function haversine(deglat1,deglon1,deglat2,deglon2) result (dist)\n          \n          real,intent(in) :: deglat1,deglon1,deglat2,deglon2\n          real :: a,c,dist,dlat,dlon,lat1,lat2\n          real,parameter :: radius = 6372.8 \n\n          dlat = to_radian(deglat2-deglat1)\n          dlon = to_radian(deglon2-deglon1)\n          lat1 = to_radian(deglat1)\n          lat2 = to_radian(deglat2)\n          a = (sin(dlat/2))**2 + cos(lat1)*cos(lat2)*(sin(dlon/2))**2\n          c = 2*asin(sqrt(a))\n          dist = radius*c\n      end function haversine\n\nend program example\n", "target": "from math import radians, sin, cos, sqrt, asin\n\n\ndef haversine(lat1, lon1, lat2, lon2):\n    R = 6372.8  \n\n    dLat = radians(lat2 - lat1)\n    dLon = radians(lon2 - lon1)\n    lat1 = radians(lat1)\n    lat2 = radians(lat2)\n\n    a = sin(dLat / 2)**2 + cos(lat1) * cos(lat2) * sin(dLon / 2)**2\n    c = 2 * asin(sqrt(a))\n\n    return R * c\n\n>>> haversine(36.12, -86.67, 33.94, -118.40)\n2887.2599506071106\n>>>\n"}
{"id": 10417, "name": "Nth root", "source": "Translate Fortran to C#: program NthRootTest\n  implicit none\n\n  print *, nthroot(10, 7131.5**10)\n  print *, nthroot(5, 34.0)\n\ncontains\n\n  function nthroot(n, A, p)\n    real :: nthroot\n    integer, intent(in)        :: n\n    real, intent(in)           :: A\n    real, intent(in), optional :: p\n\n    real :: rp, x(2)\n\n    if ( A < 0 ) then\n       stop \"A < 0\"       \n    elseif ( A == 0 ) then\n       nthroot = 0\n       return\n    end if\n\n    if ( present(p) ) then\n       rp = p\n    else\n       rp = 0.001\n    end if\n\n    x(1) = A\n    x(2) = A/n   \n\n    do while ( abs(x(2) - x(1)) > rp )\n       x(1) = x(2)\n       x(2) = ((n-1.0)*x(2) + A/(x(2) ** (n-1.0)))/real(n)\n    end do\n\n    nthroot = x(2)\n\n  end function nthroot\n\nend program NthRootTest\n", "target": "static void Main(string[] args)\n{\n\tConsole.WriteLine(NthRoot(81,2,.001));\n        Console.WriteLine(NthRoot(1000,3,.001));\n        Console.ReadLine();\n}\n\npublic static double NthRoot(double A,int n,  double p)\n{\n\tdouble _n= (double) n;\n\tdouble[] x = new double[2];\t\t\n\tx[0] = A;\n\tx[1] = A/_n;\n\twhile(Math.Abs(x[0] -x[1] ) > p)\n\t{\n\t\tx[1] = x[0];\n\t\tx[0] = (1/_n)*(((_n-1)*x[1]) + (A/Math.Pow(x[1],_n-1)));\n\t\t\t\n\t}\n\treturn x[0];\n}\n"}
{"id": 10421, "name": "Nth root", "source": "Translate Fortran to Java: program NthRootTest\n  implicit none\n\n  print *, nthroot(10, 7131.5**10)\n  print *, nthroot(5, 34.0)\n\ncontains\n\n  function nthroot(n, A, p)\n    real :: nthroot\n    integer, intent(in)        :: n\n    real, intent(in)           :: A\n    real, intent(in), optional :: p\n\n    real :: rp, x(2)\n\n    if ( A < 0 ) then\n       stop \"A < 0\"       \n    elseif ( A == 0 ) then\n       nthroot = 0\n       return\n    end if\n\n    if ( present(p) ) then\n       rp = p\n    else\n       rp = 0.001\n    end if\n\n    x(1) = A\n    x(2) = A/n   \n\n    do while ( abs(x(2) - x(1)) > rp )\n       x(1) = x(2)\n       x(2) = ((n-1.0)*x(2) + A/(x(2) ** (n-1.0)))/real(n)\n    end do\n\n    nthroot = x(2)\n\n  end function nthroot\n\nend program NthRootTest\n", "target": "public static double nthroot(int n, double A) {\n\treturn nthroot(n, A, .001);\n}\npublic static double nthroot(int n, double A, double p) {\n\tif(A < 0) {\n\t\tSystem.err.println(\"A < 0\");\n\t\treturn -1;\n\t} else if(A == 0) {\n\t\treturn 0;\n\t}\n\tdouble x_prev = A;\n\tdouble x = A / n;  \n\twhile(Math.abs(x - x_prev) > p) {\n\t\tx_prev = x;\n\t\tx = ((n - 1.0) * x + A / Math.pow(x, n - 1.0)) / n;\n\t}\n\treturn x;\n}\n"}
{"id": 10422, "name": "Nth root", "source": "Translate Fortran to Python: program NthRootTest\n  implicit none\n\n  print *, nthroot(10, 7131.5**10)\n  print *, nthroot(5, 34.0)\n\ncontains\n\n  function nthroot(n, A, p)\n    real :: nthroot\n    integer, intent(in)        :: n\n    real, intent(in)           :: A\n    real, intent(in), optional :: p\n\n    real :: rp, x(2)\n\n    if ( A < 0 ) then\n       stop \"A < 0\"       \n    elseif ( A == 0 ) then\n       nthroot = 0\n       return\n    end if\n\n    if ( present(p) ) then\n       rp = p\n    else\n       rp = 0.001\n    end if\n\n    x(1) = A\n    x(2) = A/n   \n\n    do while ( abs(x(2) - x(1)) > rp )\n       x(1) = x(2)\n       x(2) = ((n-1.0)*x(2) + A/(x(2) ** (n-1.0)))/real(n)\n    end do\n\n    nthroot = x(2)\n\n  end function nthroot\n\nend program NthRootTest\n", "target": "from decimal import Decimal, getcontext\n\ndef nthroot (n, A, precision):\n    getcontext().prec = precision\n    \n    n = Decimal(n)\n    x_0 = A / n \n    x_1 = 1     \n    while True:\n        \n        x_0, x_1 = x_1, (1 / n)*((n - 1)*x_0 + (A / (x_0 ** (n - 1))))\n        if x_0 == x_1:\n            return x_1\n"}
{"id": 10760, "name": "Priority queue", "source": "Translate Fortran to C#: module priority_queue_mod\nimplicit none\n\ntype node\n  character (len=100)              :: task\n  integer                          :: priority\nend type\n\ntype queue\n  type(node), allocatable :: buf(:)\n  integer                 :: n = 0\ncontains\n  procedure :: top\n  procedure :: enqueue\n  procedure :: siftdown\nend type\n\ncontains\n\nsubroutine siftdown(this, a)\n  class (queue)           :: this\n  integer                 :: a, parent, child\n  associate (x => this%buf)\n  parent = a\n  do while(parent*2 <= this%n)\n    child = parent*2\n    if (child + 1 <= this%n) then \n      if (x(child+1)%priority > x(child)%priority ) then\n        child = child +1 \n      end if\n    end if\n    if (x(parent)%priority < x(child)%priority) then\n      x([child, parent]) = x([parent, child])\n      parent = child\n    else\n      exit\n    end if  \n  end do      \n  end associate\nend subroutine\n\nfunction top(this) result (res)\n  class(queue) :: this\n  type(node)   :: res\n  res = this%buf(1)\n  this%buf(1) = this%buf(this%n)\n  this%n = this%n - 1\n  call this%siftdown(1)\nend function\n\nsubroutine enqueue(this, priority, task)\n  class(queue), intent(inout) :: this\n  integer                     :: priority\n  character(len=*)            :: task\n  type(node)                  :: x\n  type(node), allocatable     :: tmp(:)\n  integer                     :: i\n  x%priority = priority\n  x%task = task\n  this%n = this%n +1  \n  if (.not.allocated(this%buf)) allocate(this%buf(1))\n  if (size(this%buf)<this%n) then\n    allocate(tmp(2*size(this%buf)))\n    tmp(1:this%n-1) = this%buf\n    call move_alloc(tmp, this%buf)\n  end if\n  this%buf(this%n) = x\n  i = this%n\n  do \n    i = i / 2\n    if (i==0) exit\n    call this%siftdown(i)\n  end do\nend subroutine\nend module \n\nprogram main\n  use priority_queue_mod\n\n  type (queue) :: q\n  type (node)  :: x \n\n  call q%enqueue(3, \"Clear drains\")\n  call q%enqueue(4, \"Feed cat\")\n  call q%enqueue(5, \"Make Tea\")\n  call q%enqueue(1, \"Solve RC tasks\")\n  call q%enqueue(2, \"Tax return\")\n\n  do while (q%n >0) \n    x = q%top()\n    print \"(g0,a,a)\", x%priority, \" -> \", trim(x%task)\n  end do\n\nend program\n\n\n\n\n\n\n\n", "target": "using System;\nusing System.Collections.Generic;\n\nnamespace PriorityQueueExample\n{\n\tclass Program\n\t{\n\t\tstatic void Main(string[] args)\n\t\t{\n\t\t\t\n\t\t\tvar p = new PriorityQueue<string, int>();\n\t\t\tp.Enqueue(\"Clear drains\", 3);\n\t\t\tp.Enqueue(\"Feed cat\", 4);\n\t\t\tp.Enqueue(\"Make tea\", 5);\n\t\t\tp.Enqueue(\"Solve RC tasks\", 1);\n\t\t\tp.Enqueue(\"Tax return\", 2);\n\t\t\twhile (p.TryDequeue(out string task, out int priority))\n\t\t\t{\n\t\t\t\tConsole.WriteLine($\"{priority}\\t{task}\");\n\t\t\t}\n\t\t}\n\t}\n}\n\n\n"}
{"id": 10761, "name": "Priority queue", "source": "Translate Fortran to C#: module priority_queue_mod\nimplicit none\n\ntype node\n  character (len=100)              :: task\n  integer                          :: priority\nend type\n\ntype queue\n  type(node), allocatable :: buf(:)\n  integer                 :: n = 0\ncontains\n  procedure :: top\n  procedure :: enqueue\n  procedure :: siftdown\nend type\n\ncontains\n\nsubroutine siftdown(this, a)\n  class (queue)           :: this\n  integer                 :: a, parent, child\n  associate (x => this%buf)\n  parent = a\n  do while(parent*2 <= this%n)\n    child = parent*2\n    if (child + 1 <= this%n) then \n      if (x(child+1)%priority > x(child)%priority ) then\n        child = child +1 \n      end if\n    end if\n    if (x(parent)%priority < x(child)%priority) then\n      x([child, parent]) = x([parent, child])\n      parent = child\n    else\n      exit\n    end if  \n  end do      \n  end associate\nend subroutine\n\nfunction top(this) result (res)\n  class(queue) :: this\n  type(node)   :: res\n  res = this%buf(1)\n  this%buf(1) = this%buf(this%n)\n  this%n = this%n - 1\n  call this%siftdown(1)\nend function\n\nsubroutine enqueue(this, priority, task)\n  class(queue), intent(inout) :: this\n  integer                     :: priority\n  character(len=*)            :: task\n  type(node)                  :: x\n  type(node), allocatable     :: tmp(:)\n  integer                     :: i\n  x%priority = priority\n  x%task = task\n  this%n = this%n +1  \n  if (.not.allocated(this%buf)) allocate(this%buf(1))\n  if (size(this%buf)<this%n) then\n    allocate(tmp(2*size(this%buf)))\n    tmp(1:this%n-1) = this%buf\n    call move_alloc(tmp, this%buf)\n  end if\n  this%buf(this%n) = x\n  i = this%n\n  do \n    i = i / 2\n    if (i==0) exit\n    call this%siftdown(i)\n  end do\nend subroutine\nend module \n\nprogram main\n  use priority_queue_mod\n\n  type (queue) :: q\n  type (node)  :: x \n\n  call q%enqueue(3, \"Clear drains\")\n  call q%enqueue(4, \"Feed cat\")\n  call q%enqueue(5, \"Make Tea\")\n  call q%enqueue(1, \"Solve RC tasks\")\n  call q%enqueue(2, \"Tax return\")\n\n  do while (q%n >0) \n    x = q%top()\n    print \"(g0,a,a)\", x%priority, \" -> \", trim(x%task)\n  end do\n\nend program\n\n\n\n\n\n\n\n", "target": "using System;\nusing System.Collections.Generic;\n\nnamespace PriorityQueueExample\n{\n\tclass Program\n\t{\n\t\tstatic void Main(string[] args)\n\t\t{\n\t\t\t\n\t\t\tvar p = new PriorityQueue<string, int>();\n\t\t\tp.Enqueue(\"Clear drains\", 3);\n\t\t\tp.Enqueue(\"Feed cat\", 4);\n\t\t\tp.Enqueue(\"Make tea\", 5);\n\t\t\tp.Enqueue(\"Solve RC tasks\", 1);\n\t\t\tp.Enqueue(\"Tax return\", 2);\n\t\t\twhile (p.TryDequeue(out string task, out int priority))\n\t\t\t{\n\t\t\t\tConsole.WriteLine($\"{priority}\\t{task}\");\n\t\t\t}\n\t\t}\n\t}\n}\n\n\n"}
{"id": 10766, "name": "Priority queue", "source": "Translate Fortran to Java: module priority_queue_mod\nimplicit none\n\ntype node\n  character (len=100)              :: task\n  integer                          :: priority\nend type\n\ntype queue\n  type(node), allocatable :: buf(:)\n  integer                 :: n = 0\ncontains\n  procedure :: top\n  procedure :: enqueue\n  procedure :: siftdown\nend type\n\ncontains\n\nsubroutine siftdown(this, a)\n  class (queue)           :: this\n  integer                 :: a, parent, child\n  associate (x => this%buf)\n  parent = a\n  do while(parent*2 <= this%n)\n    child = parent*2\n    if (child + 1 <= this%n) then \n      if (x(child+1)%priority > x(child)%priority ) then\n        child = child +1 \n      end if\n    end if\n    if (x(parent)%priority < x(child)%priority) then\n      x([child, parent]) = x([parent, child])\n      parent = child\n    else\n      exit\n    end if  \n  end do      \n  end associate\nend subroutine\n\nfunction top(this) result (res)\n  class(queue) :: this\n  type(node)   :: res\n  res = this%buf(1)\n  this%buf(1) = this%buf(this%n)\n  this%n = this%n - 1\n  call this%siftdown(1)\nend function\n\nsubroutine enqueue(this, priority, task)\n  class(queue), intent(inout) :: this\n  integer                     :: priority\n  character(len=*)            :: task\n  type(node)                  :: x\n  type(node), allocatable     :: tmp(:)\n  integer                     :: i\n  x%priority = priority\n  x%task = task\n  this%n = this%n +1  \n  if (.not.allocated(this%buf)) allocate(this%buf(1))\n  if (size(this%buf)<this%n) then\n    allocate(tmp(2*size(this%buf)))\n    tmp(1:this%n-1) = this%buf\n    call move_alloc(tmp, this%buf)\n  end if\n  this%buf(this%n) = x\n  i = this%n\n  do \n    i = i / 2\n    if (i==0) exit\n    call this%siftdown(i)\n  end do\nend subroutine\nend module \n\nprogram main\n  use priority_queue_mod\n\n  type (queue) :: q\n  type (node)  :: x \n\n  call q%enqueue(3, \"Clear drains\")\n  call q%enqueue(4, \"Feed cat\")\n  call q%enqueue(5, \"Make Tea\")\n  call q%enqueue(1, \"Solve RC tasks\")\n  call q%enqueue(2, \"Tax return\")\n\n  do while (q%n >0) \n    x = q%top()\n    print \"(g0,a,a)\", x%priority, \" -> \", trim(x%task)\n  end do\n\nend program\n\n\n\n\n\n\n\n", "target": "import java.util.PriorityQueue;\n\nclass Task implements Comparable<Task> {\n    final int priority;\n    final String name;\n\n    public Task(int p, String n) {\n        priority = p;\n        name = n;\n    }\n\n    public String toString() {\n        return priority + \", \" + name;\n    }\n\n    public int compareTo(Task other) {\n        return priority < other.priority ? -1 : priority > other.priority ? 1 : 0;\n    }\n\n    public static void main(String[] args) {\n        PriorityQueue<Task> pq = new PriorityQueue<Task>();\n        pq.add(new Task(3, \"Clear drains\"));\n        pq.add(new Task(4, \"Feed cat\"));\n        pq.add(new Task(5, \"Make tea\"));\n        pq.add(new Task(1, \"Solve RC tasks\"));\n        pq.add(new Task(2, \"Tax return\"));\n\n        while (!pq.isEmpty())\n            System.out.println(pq.remove());\n    }\n}\n"}
{"id": 10767, "name": "Priority queue", "source": "Translate Fortran to Java: module priority_queue_mod\nimplicit none\n\ntype node\n  character (len=100)              :: task\n  integer                          :: priority\nend type\n\ntype queue\n  type(node), allocatable :: buf(:)\n  integer                 :: n = 0\ncontains\n  procedure :: top\n  procedure :: enqueue\n  procedure :: siftdown\nend type\n\ncontains\n\nsubroutine siftdown(this, a)\n  class (queue)           :: this\n  integer                 :: a, parent, child\n  associate (x => this%buf)\n  parent = a\n  do while(parent*2 <= this%n)\n    child = parent*2\n    if (child + 1 <= this%n) then \n      if (x(child+1)%priority > x(child)%priority ) then\n        child = child +1 \n      end if\n    end if\n    if (x(parent)%priority < x(child)%priority) then\n      x([child, parent]) = x([parent, child])\n      parent = child\n    else\n      exit\n    end if  \n  end do      \n  end associate\nend subroutine\n\nfunction top(this) result (res)\n  class(queue) :: this\n  type(node)   :: res\n  res = this%buf(1)\n  this%buf(1) = this%buf(this%n)\n  this%n = this%n - 1\n  call this%siftdown(1)\nend function\n\nsubroutine enqueue(this, priority, task)\n  class(queue), intent(inout) :: this\n  integer                     :: priority\n  character(len=*)            :: task\n  type(node)                  :: x\n  type(node), allocatable     :: tmp(:)\n  integer                     :: i\n  x%priority = priority\n  x%task = task\n  this%n = this%n +1  \n  if (.not.allocated(this%buf)) allocate(this%buf(1))\n  if (size(this%buf)<this%n) then\n    allocate(tmp(2*size(this%buf)))\n    tmp(1:this%n-1) = this%buf\n    call move_alloc(tmp, this%buf)\n  end if\n  this%buf(this%n) = x\n  i = this%n\n  do \n    i = i / 2\n    if (i==0) exit\n    call this%siftdown(i)\n  end do\nend subroutine\nend module \n\nprogram main\n  use priority_queue_mod\n\n  type (queue) :: q\n  type (node)  :: x \n\n  call q%enqueue(3, \"Clear drains\")\n  call q%enqueue(4, \"Feed cat\")\n  call q%enqueue(5, \"Make Tea\")\n  call q%enqueue(1, \"Solve RC tasks\")\n  call q%enqueue(2, \"Tax return\")\n\n  do while (q%n >0) \n    x = q%top()\n    print \"(g0,a,a)\", x%priority, \" -> \", trim(x%task)\n  end do\n\nend program\n\n\n\n\n\n\n\n", "target": "import java.util.PriorityQueue;\n\nclass Task implements Comparable<Task> {\n    final int priority;\n    final String name;\n\n    public Task(int p, String n) {\n        priority = p;\n        name = n;\n    }\n\n    public String toString() {\n        return priority + \", \" + name;\n    }\n\n    public int compareTo(Task other) {\n        return priority < other.priority ? -1 : priority > other.priority ? 1 : 0;\n    }\n\n    public static void main(String[] args) {\n        PriorityQueue<Task> pq = new PriorityQueue<Task>();\n        pq.add(new Task(3, \"Clear drains\"));\n        pq.add(new Task(4, \"Feed cat\"));\n        pq.add(new Task(5, \"Make tea\"));\n        pq.add(new Task(1, \"Solve RC tasks\"));\n        pq.add(new Task(2, \"Tax return\"));\n\n        while (!pq.isEmpty())\n            System.out.println(pq.remove());\n    }\n}\n"}
{"id": 10768, "name": "Priority queue", "source": "Translate Fortran to Python: module priority_queue_mod\nimplicit none\n\ntype node\n  character (len=100)              :: task\n  integer                          :: priority\nend type\n\ntype queue\n  type(node), allocatable :: buf(:)\n  integer                 :: n = 0\ncontains\n  procedure :: top\n  procedure :: enqueue\n  procedure :: siftdown\nend type\n\ncontains\n\nsubroutine siftdown(this, a)\n  class (queue)           :: this\n  integer                 :: a, parent, child\n  associate (x => this%buf)\n  parent = a\n  do while(parent*2 <= this%n)\n    child = parent*2\n    if (child + 1 <= this%n) then \n      if (x(child+1)%priority > x(child)%priority ) then\n        child = child +1 \n      end if\n    end if\n    if (x(parent)%priority < x(child)%priority) then\n      x([child, parent]) = x([parent, child])\n      parent = child\n    else\n      exit\n    end if  \n  end do      \n  end associate\nend subroutine\n\nfunction top(this) result (res)\n  class(queue) :: this\n  type(node)   :: res\n  res = this%buf(1)\n  this%buf(1) = this%buf(this%n)\n  this%n = this%n - 1\n  call this%siftdown(1)\nend function\n\nsubroutine enqueue(this, priority, task)\n  class(queue), intent(inout) :: this\n  integer                     :: priority\n  character(len=*)            :: task\n  type(node)                  :: x\n  type(node), allocatable     :: tmp(:)\n  integer                     :: i\n  x%priority = priority\n  x%task = task\n  this%n = this%n +1  \n  if (.not.allocated(this%buf)) allocate(this%buf(1))\n  if (size(this%buf)<this%n) then\n    allocate(tmp(2*size(this%buf)))\n    tmp(1:this%n-1) = this%buf\n    call move_alloc(tmp, this%buf)\n  end if\n  this%buf(this%n) = x\n  i = this%n\n  do \n    i = i / 2\n    if (i==0) exit\n    call this%siftdown(i)\n  end do\nend subroutine\nend module \n\nprogram main\n  use priority_queue_mod\n\n  type (queue) :: q\n  type (node)  :: x \n\n  call q%enqueue(3, \"Clear drains\")\n  call q%enqueue(4, \"Feed cat\")\n  call q%enqueue(5, \"Make Tea\")\n  call q%enqueue(1, \"Solve RC tasks\")\n  call q%enqueue(2, \"Tax return\")\n\n  do while (q%n >0) \n    x = q%top()\n    print \"(g0,a,a)\", x%priority, \" -> \", trim(x%task)\n  end do\n\nend program\n\n\n\n\n\n\n\n", "target": ">>> import queue\n>>> pq = queue.PriorityQueue()\n>>> for item in ((3, \"Clear drains\"), (4, \"Feed cat\"), (5, \"Make tea\"), (1, \"Solve RC tasks\"), (2, \"Tax return\")):\n  pq.put(item)\n\n  \n>>> while not pq.empty():\n  print(pq.get_nowait())\n\n  \n(1, 'Solve RC tasks')\n(2, 'Tax return')\n(3, 'Clear drains')\n(4, 'Feed cat')\n(5, 'Make tea')\n>>>\n"}
{"id": 10769, "name": "Priority queue", "source": "Translate Fortran to Python: module priority_queue_mod\nimplicit none\n\ntype node\n  character (len=100)              :: task\n  integer                          :: priority\nend type\n\ntype queue\n  type(node), allocatable :: buf(:)\n  integer                 :: n = 0\ncontains\n  procedure :: top\n  procedure :: enqueue\n  procedure :: siftdown\nend type\n\ncontains\n\nsubroutine siftdown(this, a)\n  class (queue)           :: this\n  integer                 :: a, parent, child\n  associate (x => this%buf)\n  parent = a\n  do while(parent*2 <= this%n)\n    child = parent*2\n    if (child + 1 <= this%n) then \n      if (x(child+1)%priority > x(child)%priority ) then\n        child = child +1 \n      end if\n    end if\n    if (x(parent)%priority < x(child)%priority) then\n      x([child, parent]) = x([parent, child])\n      parent = child\n    else\n      exit\n    end if  \n  end do      \n  end associate\nend subroutine\n\nfunction top(this) result (res)\n  class(queue) :: this\n  type(node)   :: res\n  res = this%buf(1)\n  this%buf(1) = this%buf(this%n)\n  this%n = this%n - 1\n  call this%siftdown(1)\nend function\n\nsubroutine enqueue(this, priority, task)\n  class(queue), intent(inout) :: this\n  integer                     :: priority\n  character(len=*)            :: task\n  type(node)                  :: x\n  type(node), allocatable     :: tmp(:)\n  integer                     :: i\n  x%priority = priority\n  x%task = task\n  this%n = this%n +1  \n  if (.not.allocated(this%buf)) allocate(this%buf(1))\n  if (size(this%buf)<this%n) then\n    allocate(tmp(2*size(this%buf)))\n    tmp(1:this%n-1) = this%buf\n    call move_alloc(tmp, this%buf)\n  end if\n  this%buf(this%n) = x\n  i = this%n\n  do \n    i = i / 2\n    if (i==0) exit\n    call this%siftdown(i)\n  end do\nend subroutine\nend module \n\nprogram main\n  use priority_queue_mod\n\n  type (queue) :: q\n  type (node)  :: x \n\n  call q%enqueue(3, \"Clear drains\")\n  call q%enqueue(4, \"Feed cat\")\n  call q%enqueue(5, \"Make Tea\")\n  call q%enqueue(1, \"Solve RC tasks\")\n  call q%enqueue(2, \"Tax return\")\n\n  do while (q%n >0) \n    x = q%top()\n    print \"(g0,a,a)\", x%priority, \" -> \", trim(x%task)\n  end do\n\nend program\n\n\n\n\n\n\n\n", "target": ">>> import queue\n>>> pq = queue.PriorityQueue()\n>>> for item in ((3, \"Clear drains\"), (4, \"Feed cat\"), (5, \"Make tea\"), (1, \"Solve RC tasks\"), (2, \"Tax return\")):\n  pq.put(item)\n\n  \n>>> while not pq.empty():\n  print(pq.get_nowait())\n\n  \n(1, 'Solve RC tasks')\n(2, 'Tax return')\n(3, 'Clear drains')\n(4, 'Feed cat')\n(5, 'Make tea')\n>>>\n"}
{"id": 11282, "name": "Hailstone sequence", "source": "Translate Fortran to C#: program Hailstone\n  implicit none\n\n  integer :: i, maxn\n  integer :: maxseqlen = 0, seqlen\n  integer, allocatable :: seq(:)\n\n  call hs(27, seqlen)\n  allocate(seq(seqlen))\n  call hs(27, seqlen, seq)\n  write(*,\"(a,i0,a)\") \"Hailstone sequence for 27 has \", seqlen, \" elements\"\n  write(*,\"(a,4(i0,a),3(i0,a),i0)\") \"Sequence = \", seq(1), \", \", seq(2), \", \", seq(3), \", \", seq(4), \" ...., \",  &\n                                     seq(seqlen-3), \", \", seq(seqlen-2), \", \", seq(seqlen-1), \", \", seq(seqlen) \n  \n  do i = 1, 99999\n    call hs(i, seqlen)\n    if (seqlen > maxseqlen) then\n      maxseqlen = seqlen\n      maxn = i\n    end if\n  end do\n  write(*,*)\n  write(*,\"(a,i0,a,i0,a)\") \"Longest sequence under 100000 is for \", maxn, \" with \", maxseqlen, \" elements\"\n\n  deallocate(seq)\n  \ncontains\n\nsubroutine hs(number, length, seqArray)\n  integer, intent(in)  :: number\n  integer, intent(out) :: length  \n  integer, optional, intent(inout) :: seqArray(:)\n  integer :: n\n\n  n = number\n  length = 1\n  if(present(seqArray)) seqArray(1) = n\n  do while(n /= 1)\n    if(mod(n,2) == 0) then\n      n = n / 2\n    else\n      n = n * 3 + 1\n    end if\n    length = length + 1\n    if(present(seqArray)) seqArray(length) = n\n  end do\nend subroutine\n\nend program\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\nnamespace Hailstone\n{\n    class Program\n    {\n        public static List<int> hs(int n,List<int> seq)\n        {\n            List<int> sequence = seq;\n            sequence.Add(n);\n            if (n == 1)\n            {\n                return sequence;\n            }else{\n                int newn = (n % 2 == 0) ? n / 2 : (3 * n) + 1;\n                return hs(newn, sequence);\n            }                        \n        }\n\n        static void Main(string[] args)\n        {\n            int n = 27;\n            List<int> sequence = hs(n,new List<int>());\n            Console.WriteLine(sequence.Count + \" Elements\");\n            List<int> start = sequence.GetRange(0, 4);\n            List<int> end = sequence.GetRange(sequence.Count - 4, 4);\n            Console.WriteLine(\"Starting with\u00a0: \" + string.Join(\",\", start) + \" and ending with\u00a0: \" + string.Join(\",\", end));            \n            int number = 0, longest = 0;            \n            for (int i = 1; i < 100000; i++)\n            {\n                int count = (hs(i, new List<int>())).Count;\n                if (count > longest)\n                {\n                    longest = count;\n                    number = i;\n                }\n            }\n            Console.WriteLine(\"Number < 100000 with longest Hailstone seq.: \" + number + \" with length of \" + longest);\n       }\n    }\n}\n"}
{"id": 11283, "name": "Hailstone sequence", "source": "Translate Fortran to C#: program Hailstone\n  implicit none\n\n  integer :: i, maxn\n  integer :: maxseqlen = 0, seqlen\n  integer, allocatable :: seq(:)\n\n  call hs(27, seqlen)\n  allocate(seq(seqlen))\n  call hs(27, seqlen, seq)\n  write(*,\"(a,i0,a)\") \"Hailstone sequence for 27 has \", seqlen, \" elements\"\n  write(*,\"(a,4(i0,a),3(i0,a),i0)\") \"Sequence = \", seq(1), \", \", seq(2), \", \", seq(3), \", \", seq(4), \" ...., \",  &\n                                     seq(seqlen-3), \", \", seq(seqlen-2), \", \", seq(seqlen-1), \", \", seq(seqlen) \n  \n  do i = 1, 99999\n    call hs(i, seqlen)\n    if (seqlen > maxseqlen) then\n      maxseqlen = seqlen\n      maxn = i\n    end if\n  end do\n  write(*,*)\n  write(*,\"(a,i0,a,i0,a)\") \"Longest sequence under 100000 is for \", maxn, \" with \", maxseqlen, \" elements\"\n\n  deallocate(seq)\n  \ncontains\n\nsubroutine hs(number, length, seqArray)\n  integer, intent(in)  :: number\n  integer, intent(out) :: length  \n  integer, optional, intent(inout) :: seqArray(:)\n  integer :: n\n\n  n = number\n  length = 1\n  if(present(seqArray)) seqArray(1) = n\n  do while(n /= 1)\n    if(mod(n,2) == 0) then\n      n = n / 2\n    else\n      n = n * 3 + 1\n    end if\n    length = length + 1\n    if(present(seqArray)) seqArray(length) = n\n  end do\nend subroutine\n\nend program\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\nnamespace Hailstone\n{\n    class Program\n    {\n        public static List<int> hs(int n,List<int> seq)\n        {\n            List<int> sequence = seq;\n            sequence.Add(n);\n            if (n == 1)\n            {\n                return sequence;\n            }else{\n                int newn = (n % 2 == 0) ? n / 2 : (3 * n) + 1;\n                return hs(newn, sequence);\n            }                        \n        }\n\n        static void Main(string[] args)\n        {\n            int n = 27;\n            List<int> sequence = hs(n,new List<int>());\n            Console.WriteLine(sequence.Count + \" Elements\");\n            List<int> start = sequence.GetRange(0, 4);\n            List<int> end = sequence.GetRange(sequence.Count - 4, 4);\n            Console.WriteLine(\"Starting with\u00a0: \" + string.Join(\",\", start) + \" and ending with\u00a0: \" + string.Join(\",\", end));            \n            int number = 0, longest = 0;            \n            for (int i = 1; i < 100000; i++)\n            {\n                int count = (hs(i, new List<int>())).Count;\n                if (count > longest)\n                {\n                    longest = count;\n                    number = i;\n                }\n            }\n            Console.WriteLine(\"Number < 100000 with longest Hailstone seq.: \" + number + \" with length of \" + longest);\n       }\n    }\n}\n"}
{"id": 11288, "name": "Hailstone sequence", "source": "Translate Fortran to Java: program Hailstone\n  implicit none\n\n  integer :: i, maxn\n  integer :: maxseqlen = 0, seqlen\n  integer, allocatable :: seq(:)\n\n  call hs(27, seqlen)\n  allocate(seq(seqlen))\n  call hs(27, seqlen, seq)\n  write(*,\"(a,i0,a)\") \"Hailstone sequence for 27 has \", seqlen, \" elements\"\n  write(*,\"(a,4(i0,a),3(i0,a),i0)\") \"Sequence = \", seq(1), \", \", seq(2), \", \", seq(3), \", \", seq(4), \" ...., \",  &\n                                     seq(seqlen-3), \", \", seq(seqlen-2), \", \", seq(seqlen-1), \", \", seq(seqlen) \n  \n  do i = 1, 99999\n    call hs(i, seqlen)\n    if (seqlen > maxseqlen) then\n      maxseqlen = seqlen\n      maxn = i\n    end if\n  end do\n  write(*,*)\n  write(*,\"(a,i0,a,i0,a)\") \"Longest sequence under 100000 is for \", maxn, \" with \", maxseqlen, \" elements\"\n\n  deallocate(seq)\n  \ncontains\n\nsubroutine hs(number, length, seqArray)\n  integer, intent(in)  :: number\n  integer, intent(out) :: length  \n  integer, optional, intent(inout) :: seqArray(:)\n  integer :: n\n\n  n = number\n  length = 1\n  if(present(seqArray)) seqArray(1) = n\n  do while(n /= 1)\n    if(mod(n,2) == 0) then\n      n = n / 2\n    else\n      n = n * 3 + 1\n    end if\n    length = length + 1\n    if(present(seqArray)) seqArray(length) = n\n  end do\nend subroutine\n\nend program\n", "target": "import java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\n\nclass Hailstone {\n\n  public static List<Long> getHailstoneSequence(long n) {\n    if (n <= 0)\n      throw new IllegalArgumentException(\"Invalid starting sequence number\");\n    List<Long> list = new ArrayList<Long>();\n    list.add(Long.valueOf(n));\n    while (n != 1) {\n      if ((n & 1) == 0)\n        n = n / 2;\n      else\n        n = 3 * n + 1;\n      list.add(Long.valueOf(n));\n    }\n    return list;\n  }\n  \n  public static void main(String[] args) {\n    List<Long> sequence27 = getHailstoneSequence(27);\n    System.out.println(\"Sequence for 27 has \" + sequence27.size() + \" elements: \" + sequence27);\n    \n    long MAX = 100000;\n    \n    {\n      long highestNumber = 1;\n      int highestCount = 1;\n      for (long i = 2; i < MAX; i++) {\n        int count = getHailstoneSequence(i).size();\n        if (count > highestCount) {\n          highestCount = count;\n          highestNumber = i;\n        }\n      }\n      System.out.println(\"Method 1, number \" + highestNumber + \" has the longest sequence, with a length of \" + highestCount);\n    }\n    \n    \n    {\n      long highestNumber = 1;\n      int highestCount = 1;\n      for (long i = 2; i < MAX; i++) {\n        int count = 1;\n        long n = i;\n        while (n != 1) {\n          if ((n & 1) == 0)\n            n = n / 2;\n          else\n            n = 3 * n + 1;\n          count++;\n        }\n        if (count > highestCount) {\n          highestCount = count;\n          highestNumber = i;\n        }\n      }\n      System.out.println(\"Method 2, number \" + highestNumber + \" has the longest sequence, with a length of \" + highestCount);\n    }\n    \n    \n    {\n      long highestNumber = 1;\n      long highestCount = 1;\n      Map<Long, Integer> sequenceMap = new HashMap<Long, Integer>();\n      sequenceMap.put(Long.valueOf(1), Integer.valueOf(1));\n      \n      List<Long> currentList = new ArrayList<Long>();\n      for (long i = 2; i < MAX; i++) {\n        currentList.clear();\n        Long n = Long.valueOf(i);\n        Integer count = null;\n        while ((count = sequenceMap.get(n)) == null) {\n          currentList.add(n);\n          long nValue = n.longValue();\n          if ((nValue & 1) == 0)\n            n = Long.valueOf(nValue / 2);\n          else\n            n = Long.valueOf(3 * nValue + 1);\n        }\n        int curCount = count.intValue();\n        for (int j = currentList.size() - 1; j >= 0; j--)\n          sequenceMap.put(currentList.get(j), Integer.valueOf(++curCount));\n        if (curCount > highestCount) {\n          highestCount = curCount;\n          highestNumber = i;\n        }\n      }\n      System.out.println(\"Method 3, number \" + highestNumber + \" has the longest sequence, with a length of \" + highestCount);\n    }\n    return;\n  }\n}\n"}
{"id": 11289, "name": "Hailstone sequence", "source": "Translate Fortran to Java: program Hailstone\n  implicit none\n\n  integer :: i, maxn\n  integer :: maxseqlen = 0, seqlen\n  integer, allocatable :: seq(:)\n\n  call hs(27, seqlen)\n  allocate(seq(seqlen))\n  call hs(27, seqlen, seq)\n  write(*,\"(a,i0,a)\") \"Hailstone sequence for 27 has \", seqlen, \" elements\"\n  write(*,\"(a,4(i0,a),3(i0,a),i0)\") \"Sequence = \", seq(1), \", \", seq(2), \", \", seq(3), \", \", seq(4), \" ...., \",  &\n                                     seq(seqlen-3), \", \", seq(seqlen-2), \", \", seq(seqlen-1), \", \", seq(seqlen) \n  \n  do i = 1, 99999\n    call hs(i, seqlen)\n    if (seqlen > maxseqlen) then\n      maxseqlen = seqlen\n      maxn = i\n    end if\n  end do\n  write(*,*)\n  write(*,\"(a,i0,a,i0,a)\") \"Longest sequence under 100000 is for \", maxn, \" with \", maxseqlen, \" elements\"\n\n  deallocate(seq)\n  \ncontains\n\nsubroutine hs(number, length, seqArray)\n  integer, intent(in)  :: number\n  integer, intent(out) :: length  \n  integer, optional, intent(inout) :: seqArray(:)\n  integer :: n\n\n  n = number\n  length = 1\n  if(present(seqArray)) seqArray(1) = n\n  do while(n /= 1)\n    if(mod(n,2) == 0) then\n      n = n / 2\n    else\n      n = n * 3 + 1\n    end if\n    length = length + 1\n    if(present(seqArray)) seqArray(length) = n\n  end do\nend subroutine\n\nend program\n", "target": "import java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\n\nclass Hailstone {\n\n  public static List<Long> getHailstoneSequence(long n) {\n    if (n <= 0)\n      throw new IllegalArgumentException(\"Invalid starting sequence number\");\n    List<Long> list = new ArrayList<Long>();\n    list.add(Long.valueOf(n));\n    while (n != 1) {\n      if ((n & 1) == 0)\n        n = n / 2;\n      else\n        n = 3 * n + 1;\n      list.add(Long.valueOf(n));\n    }\n    return list;\n  }\n  \n  public static void main(String[] args) {\n    List<Long> sequence27 = getHailstoneSequence(27);\n    System.out.println(\"Sequence for 27 has \" + sequence27.size() + \" elements: \" + sequence27);\n    \n    long MAX = 100000;\n    \n    {\n      long highestNumber = 1;\n      int highestCount = 1;\n      for (long i = 2; i < MAX; i++) {\n        int count = getHailstoneSequence(i).size();\n        if (count > highestCount) {\n          highestCount = count;\n          highestNumber = i;\n        }\n      }\n      System.out.println(\"Method 1, number \" + highestNumber + \" has the longest sequence, with a length of \" + highestCount);\n    }\n    \n    \n    {\n      long highestNumber = 1;\n      int highestCount = 1;\n      for (long i = 2; i < MAX; i++) {\n        int count = 1;\n        long n = i;\n        while (n != 1) {\n          if ((n & 1) == 0)\n            n = n / 2;\n          else\n            n = 3 * n + 1;\n          count++;\n        }\n        if (count > highestCount) {\n          highestCount = count;\n          highestNumber = i;\n        }\n      }\n      System.out.println(\"Method 2, number \" + highestNumber + \" has the longest sequence, with a length of \" + highestCount);\n    }\n    \n    \n    {\n      long highestNumber = 1;\n      long highestCount = 1;\n      Map<Long, Integer> sequenceMap = new HashMap<Long, Integer>();\n      sequenceMap.put(Long.valueOf(1), Integer.valueOf(1));\n      \n      List<Long> currentList = new ArrayList<Long>();\n      for (long i = 2; i < MAX; i++) {\n        currentList.clear();\n        Long n = Long.valueOf(i);\n        Integer count = null;\n        while ((count = sequenceMap.get(n)) == null) {\n          currentList.add(n);\n          long nValue = n.longValue();\n          if ((nValue & 1) == 0)\n            n = Long.valueOf(nValue / 2);\n          else\n            n = Long.valueOf(3 * nValue + 1);\n        }\n        int curCount = count.intValue();\n        for (int j = currentList.size() - 1; j >= 0; j--)\n          sequenceMap.put(currentList.get(j), Integer.valueOf(++curCount));\n        if (curCount > highestCount) {\n          highestCount = curCount;\n          highestNumber = i;\n        }\n      }\n      System.out.println(\"Method 3, number \" + highestNumber + \" has the longest sequence, with a length of \" + highestCount);\n    }\n    return;\n  }\n}\n"}
{"id": 11290, "name": "Hailstone sequence", "source": "Translate Fortran to Python: program Hailstone\n  implicit none\n\n  integer :: i, maxn\n  integer :: maxseqlen = 0, seqlen\n  integer, allocatable :: seq(:)\n\n  call hs(27, seqlen)\n  allocate(seq(seqlen))\n  call hs(27, seqlen, seq)\n  write(*,\"(a,i0,a)\") \"Hailstone sequence for 27 has \", seqlen, \" elements\"\n  write(*,\"(a,4(i0,a),3(i0,a),i0)\") \"Sequence = \", seq(1), \", \", seq(2), \", \", seq(3), \", \", seq(4), \" ...., \",  &\n                                     seq(seqlen-3), \", \", seq(seqlen-2), \", \", seq(seqlen-1), \", \", seq(seqlen) \n  \n  do i = 1, 99999\n    call hs(i, seqlen)\n    if (seqlen > maxseqlen) then\n      maxseqlen = seqlen\n      maxn = i\n    end if\n  end do\n  write(*,*)\n  write(*,\"(a,i0,a,i0,a)\") \"Longest sequence under 100000 is for \", maxn, \" with \", maxseqlen, \" elements\"\n\n  deallocate(seq)\n  \ncontains\n\nsubroutine hs(number, length, seqArray)\n  integer, intent(in)  :: number\n  integer, intent(out) :: length  \n  integer, optional, intent(inout) :: seqArray(:)\n  integer :: n\n\n  n = number\n  length = 1\n  if(present(seqArray)) seqArray(1) = n\n  do while(n /= 1)\n    if(mod(n,2) == 0) then\n      n = n / 2\n    else\n      n = n * 3 + 1\n    end if\n    length = length + 1\n    if(present(seqArray)) seqArray(length) = n\n  end do\nend subroutine\n\nend program\n", "target": "def hailstone(n):\n    seq = [n]\n    while n>1:\n        n = 3*n + 1 if n & 1 else n//2\n        seq.append(n)\n    return seq\n\nif __name__ == '__main__':\n    h = hailstone(27)\n    assert len(h)==112 and h[:4]==[27, 82, 41, 124] and h[-4:]==[8, 4, 2, 1]\n    print(\"Maximum length %i was found for hailstone(%i) for numbers <100,000\" %\n          max((len(hailstone(i)), i) for i in range(1,100000)))\n"}
{"id": 11291, "name": "Hailstone sequence", "source": "Translate Fortran to Python: program Hailstone\n  implicit none\n\n  integer :: i, maxn\n  integer :: maxseqlen = 0, seqlen\n  integer, allocatable :: seq(:)\n\n  call hs(27, seqlen)\n  allocate(seq(seqlen))\n  call hs(27, seqlen, seq)\n  write(*,\"(a,i0,a)\") \"Hailstone sequence for 27 has \", seqlen, \" elements\"\n  write(*,\"(a,4(i0,a),3(i0,a),i0)\") \"Sequence = \", seq(1), \", \", seq(2), \", \", seq(3), \", \", seq(4), \" ...., \",  &\n                                     seq(seqlen-3), \", \", seq(seqlen-2), \", \", seq(seqlen-1), \", \", seq(seqlen) \n  \n  do i = 1, 99999\n    call hs(i, seqlen)\n    if (seqlen > maxseqlen) then\n      maxseqlen = seqlen\n      maxn = i\n    end if\n  end do\n  write(*,*)\n  write(*,\"(a,i0,a,i0,a)\") \"Longest sequence under 100000 is for \", maxn, \" with \", maxseqlen, \" elements\"\n\n  deallocate(seq)\n  \ncontains\n\nsubroutine hs(number, length, seqArray)\n  integer, intent(in)  :: number\n  integer, intent(out) :: length  \n  integer, optional, intent(inout) :: seqArray(:)\n  integer :: n\n\n  n = number\n  length = 1\n  if(present(seqArray)) seqArray(1) = n\n  do while(n /= 1)\n    if(mod(n,2) == 0) then\n      n = n / 2\n    else\n      n = n * 3 + 1\n    end if\n    length = length + 1\n    if(present(seqArray)) seqArray(length) = n\n  end do\nend subroutine\n\nend program\n", "target": "def hailstone(n):\n    seq = [n]\n    while n>1:\n        n = 3*n + 1 if n & 1 else n//2\n        seq.append(n)\n    return seq\n\nif __name__ == '__main__':\n    h = hailstone(27)\n    assert len(h)==112 and h[:4]==[27, 82, 41, 124] and h[-4:]==[8, 4, 2, 1]\n    print(\"Maximum length %i was found for hailstone(%i) for numbers <100,000\" %\n          max((len(hailstone(i)), i) for i in range(1,100000)))\n"}
{"id": 11814, "name": "Multifactorial", "source": "Translate Fortran to C#: program test\n  implicit none\n  integer :: i, j, n\n\n  do i = 1, 5\n    write(*, \"(a, i0, a)\", advance = \"no\") \"Degree \", i, \": \"\n    do j = 1, 10\n      n = multifactorial(j, i)\n      write(*, \"(i0, 1x)\", advance = \"no\") n\n    end do\n    write(*,*)\n  end do\n   \ncontains\n\nfunction multifactorial (range, degree)\n  integer :: multifactorial, range, degree\n  integer :: k\n   \n  multifactorial = product((/(k, k=range, 1, -degree)/))\n\nend function multifactorial\nend program test\n", "target": "namespace RosettaCode.Multifactorial\n{\n    using System;\n    using System.Linq;\n\n    internal static class Program\n    {\n        private static void Main()\n        {\n            Console.WriteLine(string.Join(Environment.NewLine,\n                                          Enumerable.Range(1, 5)\n                                                    .Select(\n                                                        degree =>\n                                                        string.Join(\" \",\n                                                                    Enumerable.Range(1, 10)\n                                                                              .Select(\n                                                                                  number =>\n                                                                                  Multifactorial(number, degree))))));\n        }\n\n        private static int Multifactorial(int number, int degree)\n        {\n            if (degree < 1)\n            {\n                throw new ArgumentOutOfRangeException(\"degree\");\n            }\n\n            var count = 1 + (number - 1) / degree;\n            if (count < 1)\n            {\n                throw new ArgumentOutOfRangeException(\"number\");\n            }\n\n            return Enumerable.Range(0, count)\n                             .Aggregate(1, (accumulator, index) => accumulator * (number - degree * index));\n        }\n    }\n}\n"}
{"id": 11815, "name": "Multifactorial", "source": "Translate Fortran to C#: program test\n  implicit none\n  integer :: i, j, n\n\n  do i = 1, 5\n    write(*, \"(a, i0, a)\", advance = \"no\") \"Degree \", i, \": \"\n    do j = 1, 10\n      n = multifactorial(j, i)\n      write(*, \"(i0, 1x)\", advance = \"no\") n\n    end do\n    write(*,*)\n  end do\n   \ncontains\n\nfunction multifactorial (range, degree)\n  integer :: multifactorial, range, degree\n  integer :: k\n   \n  multifactorial = product((/(k, k=range, 1, -degree)/))\n\nend function multifactorial\nend program test\n", "target": "namespace RosettaCode.Multifactorial\n{\n    using System;\n    using System.Linq;\n\n    internal static class Program\n    {\n        private static void Main()\n        {\n            Console.WriteLine(string.Join(Environment.NewLine,\n                                          Enumerable.Range(1, 5)\n                                                    .Select(\n                                                        degree =>\n                                                        string.Join(\" \",\n                                                                    Enumerable.Range(1, 10)\n                                                                              .Select(\n                                                                                  number =>\n                                                                                  Multifactorial(number, degree))))));\n        }\n\n        private static int Multifactorial(int number, int degree)\n        {\n            if (degree < 1)\n            {\n                throw new ArgumentOutOfRangeException(\"degree\");\n            }\n\n            var count = 1 + (number - 1) / degree;\n            if (count < 1)\n            {\n                throw new ArgumentOutOfRangeException(\"number\");\n            }\n\n            return Enumerable.Range(0, count)\n                             .Aggregate(1, (accumulator, index) => accumulator * (number - degree * index));\n        }\n    }\n}\n"}
{"id": 11820, "name": "Multifactorial", "source": "Translate Fortran to Java: program test\n  implicit none\n  integer :: i, j, n\n\n  do i = 1, 5\n    write(*, \"(a, i0, a)\", advance = \"no\") \"Degree \", i, \": \"\n    do j = 1, 10\n      n = multifactorial(j, i)\n      write(*, \"(i0, 1x)\", advance = \"no\") n\n    end do\n    write(*,*)\n  end do\n   \ncontains\n\nfunction multifactorial (range, degree)\n  integer :: multifactorial, range, degree\n  integer :: k\n   \n  multifactorial = product((/(k, k=range, 1, -degree)/))\n\nend function multifactorial\nend program test\n", "target": "public class MultiFact {\n\tprivate static long multiFact(long n, int deg){\n\t\tlong ans = 1;\n\t\tfor(long i = n; i > 0; i -= deg){\n\t\t\tans *= i;\n\t\t}\n\t\treturn ans;\n\t}\n\t\n\tpublic static void main(String[] args){\n\t\tfor(int deg = 1; deg <= 5; deg++){\n\t\t\tSystem.out.print(\"degree \" + deg + \":\");\n\t\t\tfor(long n = 1; n <= 10; n++){\n\t\t\t\tSystem.out.print(\" \" + multiFact(n, deg));\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t}\n}\n"}
{"id": 11821, "name": "Multifactorial", "source": "Translate Fortran to Java: program test\n  implicit none\n  integer :: i, j, n\n\n  do i = 1, 5\n    write(*, \"(a, i0, a)\", advance = \"no\") \"Degree \", i, \": \"\n    do j = 1, 10\n      n = multifactorial(j, i)\n      write(*, \"(i0, 1x)\", advance = \"no\") n\n    end do\n    write(*,*)\n  end do\n   \ncontains\n\nfunction multifactorial (range, degree)\n  integer :: multifactorial, range, degree\n  integer :: k\n   \n  multifactorial = product((/(k, k=range, 1, -degree)/))\n\nend function multifactorial\nend program test\n", "target": "public class MultiFact {\n\tprivate static long multiFact(long n, int deg){\n\t\tlong ans = 1;\n\t\tfor(long i = n; i > 0; i -= deg){\n\t\t\tans *= i;\n\t\t}\n\t\treturn ans;\n\t}\n\t\n\tpublic static void main(String[] args){\n\t\tfor(int deg = 1; deg <= 5; deg++){\n\t\t\tSystem.out.print(\"degree \" + deg + \":\");\n\t\t\tfor(long n = 1; n <= 10; n++){\n\t\t\t\tSystem.out.print(\" \" + multiFact(n, deg));\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t}\n}\n"}
{"id": 11822, "name": "Multifactorial", "source": "Translate Fortran to Python: program test\n  implicit none\n  integer :: i, j, n\n\n  do i = 1, 5\n    write(*, \"(a, i0, a)\", advance = \"no\") \"Degree \", i, \": \"\n    do j = 1, 10\n      n = multifactorial(j, i)\n      write(*, \"(i0, 1x)\", advance = \"no\") n\n    end do\n    write(*,*)\n  end do\n   \ncontains\n\nfunction multifactorial (range, degree)\n  integer :: multifactorial, range, degree\n  integer :: k\n   \n  multifactorial = product((/(k, k=range, 1, -degree)/))\n\nend function multifactorial\nend program test\n", "target": ">>> from functools import reduce\n>>> from operator import mul\n>>> def mfac(n, m): return reduce(mul, range(n, 0, -m))\n\n>>> for m in range(1, 11): print(\"%2i: %r\" % (m, [mfac(n, m) for n in range(1, 11)]))\n\n 1: [1, 2, 6, 24, 120, 720, 5040, 40320, 362880, 3628800]\n 2: [1, 2, 3, 8, 15, 48, 105, 384, 945, 3840]\n 3: [1, 2, 3, 4, 10, 18, 28, 80, 162, 280]\n 4: [1, 2, 3, 4, 5, 12, 21, 32, 45, 120]\n 5: [1, 2, 3, 4, 5, 6, 14, 24, 36, 50]\n 6: [1, 2, 3, 4, 5, 6, 7, 16, 27, 40]\n 7: [1, 2, 3, 4, 5, 6, 7, 8, 18, 30]\n 8: [1, 2, 3, 4, 5, 6, 7, 8, 9, 20]\n 9: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n10: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n>>>\n"}
{"id": 11823, "name": "Multifactorial", "source": "Translate Fortran to Python: program test\n  implicit none\n  integer :: i, j, n\n\n  do i = 1, 5\n    write(*, \"(a, i0, a)\", advance = \"no\") \"Degree \", i, \": \"\n    do j = 1, 10\n      n = multifactorial(j, i)\n      write(*, \"(i0, 1x)\", advance = \"no\") n\n    end do\n    write(*,*)\n  end do\n   \ncontains\n\nfunction multifactorial (range, degree)\n  integer :: multifactorial, range, degree\n  integer :: k\n   \n  multifactorial = product((/(k, k=range, 1, -degree)/))\n\nend function multifactorial\nend program test\n", "target": ">>> from functools import reduce\n>>> from operator import mul\n>>> def mfac(n, m): return reduce(mul, range(n, 0, -m))\n\n>>> for m in range(1, 11): print(\"%2i: %r\" % (m, [mfac(n, m) for n in range(1, 11)]))\n\n 1: [1, 2, 6, 24, 120, 720, 5040, 40320, 362880, 3628800]\n 2: [1, 2, 3, 8, 15, 48, 105, 384, 945, 3840]\n 3: [1, 2, 3, 4, 10, 18, 28, 80, 162, 280]\n 4: [1, 2, 3, 4, 5, 12, 21, 32, 45, 120]\n 5: [1, 2, 3, 4, 5, 6, 14, 24, 36, 50]\n 6: [1, 2, 3, 4, 5, 6, 7, 16, 27, 40]\n 7: [1, 2, 3, 4, 5, 6, 7, 8, 18, 30]\n 8: [1, 2, 3, 4, 5, 6, 7, 8, 9, 20]\n 9: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n10: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n>>>\n"}
{"id": 12208, "name": "Shoelace formula for polygonal area", "source": "Translate Fortran to C#:       DOUBLE PRECISION FUNCTION AREA(N,P)\t\nC   Uses the mid-point rule for integration. Consider the line joining (x1,y1) to (x2,y2)\nC The area under that line (down to the x-axis) is the y-span midpoint (y1 + y2)/2 times the width (x2 - x1)\nC This is the trapezoidal rule for a single interval, and follows from simple geometry.\nC Now consider a sequence of such points heading in the +x direction: each successive interval's area is positive.\nC Follow with a sequence of points heading in the -x direction, back to the first point: their areas are all negative.\nC The resulting sum is the area below the +x sequence and above the -x sequence: the area of the polygon.\nC   The point sequence can wobble as it wishes and can meet the other side, but it must not cross itself\nc as would be done in a figure 8 drawn with a crossover instead of a meeting.\nC   A clockwise traversal (as for an island) gives a positive area; use anti-clockwise for a lake.\n       INTEGER N\t\t\n       DOUBLE COMPLEX P(N)\t\n       DOUBLE COMPLEX PP,PC\t\n       DOUBLE COMPLEX W\t\t\n       DOUBLE PRECISION A\t\n       INTEGER I\t\t\n        IF (N.LT.3) STOP \"Area: at least three points are needed\n        W = (P(1) + P(N/3) + P(2*N/3))/3\t\n        W = SUM(P(1:N) - W)/N + W\t\n        A = 0\t\t\t\n        PC = P(N) - W\t\t\n        DO I = 1,N\t\t\n          PP = PC\t\t\t\n          PC = P(I) - W\t\t\t\n          A = (DIMAG(PC) + DIMAG(PP))*(DBLE(PC) - DBLE(PP)) + A\t\n        END DO\t\t\t\n        AREA = A/2\t\t\n      END FUNCTION AREA\t\t\n\n      DOUBLE PRECISION FUNCTION AREASL(N,P)\t\n       INTEGER N\t\t\n       DOUBLE COMPLEX P(N)\t\n       DOUBLE PRECISION A\t\n        A = SUM(DBLE(P(1:N - 1)*DIMAG(P(2:N)))) + DBLE(P(N))*DIMAG(P(1))\n     1    - SUM(DBLE(P(2:N)*DIMAG(P(1:N - 1)))) - DBLE(P(1))*DIMAG(P(N))\n        AREASL = A/2\t\t\n      END FUNCTION AREASL\t\n\n      INTEGER ENUFF\n      DOUBLE PRECISION AREA,AREASL\t\n      DOUBLE PRECISION A1,A2\t\t\n      PARAMETER (ENUFF = 5)\t\t\n      DOUBLE COMPLEX POINT(ENUFF)\t\n      DATA POINT/(3D0,4D0),(5D0,11D0),(12D0,8D0),(9D0,5D0),(5D0,6D0)/\t\n\n      WRITE (6,*) POINT\n      A1 = AREA(5,POINT)\n      A2 = AREASL(5,POINT)\n      WRITE (6,*) \"A=\",A1,A2\n      END\n", "target": "using System;\nusing System.Collections.Generic;\n\nnamespace ShoelaceFormula {\n    using Point = Tuple<double, double>;\n\n    class Program {\n        static double ShoelaceArea(List<Point> v) {\n            int n = v.Count;\n            double a = 0.0;\n            for (int i = 0; i < n - 1; i++) {\n                a += v[i].Item1 * v[i + 1].Item2 - v[i + 1].Item1 * v[i].Item2;\n            }\n            return Math.Abs(a + v[n - 1].Item1 * v[0].Item2 - v[0].Item1 * v[n - 1].Item2) / 2.0;\n        }\n\n        static void Main(string[] args) {\n            List<Point> v = new List<Point>() {\n                new Point(3,4),\n                new Point(5,11),\n                new Point(12,8),\n                new Point(9,5),\n                new Point(5,6),\n            };\n            double area = ShoelaceArea(v);\n            Console.WriteLine(\"Given a polygon with vertices [{0}],\", string.Join(\", \", v));\n            Console.WriteLine(\"its area is {0}.\", area);\n        }\n    }\n}\n"}
{"id": 12209, "name": "Shoelace formula for polygonal area", "source": "Translate Fortran to C#:       DOUBLE PRECISION FUNCTION AREA(N,P)\t\nC   Uses the mid-point rule for integration. Consider the line joining (x1,y1) to (x2,y2)\nC The area under that line (down to the x-axis) is the y-span midpoint (y1 + y2)/2 times the width (x2 - x1)\nC This is the trapezoidal rule for a single interval, and follows from simple geometry.\nC Now consider a sequence of such points heading in the +x direction: each successive interval's area is positive.\nC Follow with a sequence of points heading in the -x direction, back to the first point: their areas are all negative.\nC The resulting sum is the area below the +x sequence and above the -x sequence: the area of the polygon.\nC   The point sequence can wobble as it wishes and can meet the other side, but it must not cross itself\nc as would be done in a figure 8 drawn with a crossover instead of a meeting.\nC   A clockwise traversal (as for an island) gives a positive area; use anti-clockwise for a lake.\n       INTEGER N\t\t\n       DOUBLE COMPLEX P(N)\t\n       DOUBLE COMPLEX PP,PC\t\n       DOUBLE COMPLEX W\t\t\n       DOUBLE PRECISION A\t\n       INTEGER I\t\t\n        IF (N.LT.3) STOP \"Area: at least three points are needed\n        W = (P(1) + P(N/3) + P(2*N/3))/3\t\n        W = SUM(P(1:N) - W)/N + W\t\n        A = 0\t\t\t\n        PC = P(N) - W\t\t\n        DO I = 1,N\t\t\n          PP = PC\t\t\t\n          PC = P(I) - W\t\t\t\n          A = (DIMAG(PC) + DIMAG(PP))*(DBLE(PC) - DBLE(PP)) + A\t\n        END DO\t\t\t\n        AREA = A/2\t\t\n      END FUNCTION AREA\t\t\n\n      DOUBLE PRECISION FUNCTION AREASL(N,P)\t\n       INTEGER N\t\t\n       DOUBLE COMPLEX P(N)\t\n       DOUBLE PRECISION A\t\n        A = SUM(DBLE(P(1:N - 1)*DIMAG(P(2:N)))) + DBLE(P(N))*DIMAG(P(1))\n     1    - SUM(DBLE(P(2:N)*DIMAG(P(1:N - 1)))) - DBLE(P(1))*DIMAG(P(N))\n        AREASL = A/2\t\t\n      END FUNCTION AREASL\t\n\n      INTEGER ENUFF\n      DOUBLE PRECISION AREA,AREASL\t\n      DOUBLE PRECISION A1,A2\t\t\n      PARAMETER (ENUFF = 5)\t\t\n      DOUBLE COMPLEX POINT(ENUFF)\t\n      DATA POINT/(3D0,4D0),(5D0,11D0),(12D0,8D0),(9D0,5D0),(5D0,6D0)/\t\n\n      WRITE (6,*) POINT\n      A1 = AREA(5,POINT)\n      A2 = AREASL(5,POINT)\n      WRITE (6,*) \"A=\",A1,A2\n      END\n", "target": "using System;\nusing System.Collections.Generic;\n\nnamespace ShoelaceFormula {\n    using Point = Tuple<double, double>;\n\n    class Program {\n        static double ShoelaceArea(List<Point> v) {\n            int n = v.Count;\n            double a = 0.0;\n            for (int i = 0; i < n - 1; i++) {\n                a += v[i].Item1 * v[i + 1].Item2 - v[i + 1].Item1 * v[i].Item2;\n            }\n            return Math.Abs(a + v[n - 1].Item1 * v[0].Item2 - v[0].Item1 * v[n - 1].Item2) / 2.0;\n        }\n\n        static void Main(string[] args) {\n            List<Point> v = new List<Point>() {\n                new Point(3,4),\n                new Point(5,11),\n                new Point(12,8),\n                new Point(9,5),\n                new Point(5,6),\n            };\n            double area = ShoelaceArea(v);\n            Console.WriteLine(\"Given a polygon with vertices [{0}],\", string.Join(\", \", v));\n            Console.WriteLine(\"its area is {0}.\", area);\n        }\n    }\n}\n"}
{"id": 12214, "name": "Shoelace formula for polygonal area", "source": "Translate Fortran to Java:       DOUBLE PRECISION FUNCTION AREA(N,P)\t\nC   Uses the mid-point rule for integration. Consider the line joining (x1,y1) to (x2,y2)\nC The area under that line (down to the x-axis) is the y-span midpoint (y1 + y2)/2 times the width (x2 - x1)\nC This is the trapezoidal rule for a single interval, and follows from simple geometry.\nC Now consider a sequence of such points heading in the +x direction: each successive interval's area is positive.\nC Follow with a sequence of points heading in the -x direction, back to the first point: their areas are all negative.\nC The resulting sum is the area below the +x sequence and above the -x sequence: the area of the polygon.\nC   The point sequence can wobble as it wishes and can meet the other side, but it must not cross itself\nc as would be done in a figure 8 drawn with a crossover instead of a meeting.\nC   A clockwise traversal (as for an island) gives a positive area; use anti-clockwise for a lake.\n       INTEGER N\t\t\n       DOUBLE COMPLEX P(N)\t\n       DOUBLE COMPLEX PP,PC\t\n       DOUBLE COMPLEX W\t\t\n       DOUBLE PRECISION A\t\n       INTEGER I\t\t\n        IF (N.LT.3) STOP \"Area: at least three points are needed\n        W = (P(1) + P(N/3) + P(2*N/3))/3\t\n        W = SUM(P(1:N) - W)/N + W\t\n        A = 0\t\t\t\n        PC = P(N) - W\t\t\n        DO I = 1,N\t\t\n          PP = PC\t\t\t\n          PC = P(I) - W\t\t\t\n          A = (DIMAG(PC) + DIMAG(PP))*(DBLE(PC) - DBLE(PP)) + A\t\n        END DO\t\t\t\n        AREA = A/2\t\t\n      END FUNCTION AREA\t\t\n\n      DOUBLE PRECISION FUNCTION AREASL(N,P)\t\n       INTEGER N\t\t\n       DOUBLE COMPLEX P(N)\t\n       DOUBLE PRECISION A\t\n        A = SUM(DBLE(P(1:N - 1)*DIMAG(P(2:N)))) + DBLE(P(N))*DIMAG(P(1))\n     1    - SUM(DBLE(P(2:N)*DIMAG(P(1:N - 1)))) - DBLE(P(1))*DIMAG(P(N))\n        AREASL = A/2\t\t\n      END FUNCTION AREASL\t\n\n      INTEGER ENUFF\n      DOUBLE PRECISION AREA,AREASL\t\n      DOUBLE PRECISION A1,A2\t\t\n      PARAMETER (ENUFF = 5)\t\t\n      DOUBLE COMPLEX POINT(ENUFF)\t\n      DATA POINT/(3D0,4D0),(5D0,11D0),(12D0,8D0),(9D0,5D0),(5D0,6D0)/\t\n\n      WRITE (6,*) POINT\n      A1 = AREA(5,POINT)\n      A2 = AREASL(5,POINT)\n      WRITE (6,*) \"A=\",A1,A2\n      END\n", "target": "import java.util.List;\n\npublic class ShoelaceFormula {\n    private static class Point {\n        int x, y;\n\n        Point(int x, int y) {\n            this.x = x;\n            this.y = y;\n        }\n\n        @Override\n        public String toString() {\n            return String.format(\"(%d, %d)\", x, y);\n        }\n    }\n\n    private static double shoelaceArea(List<Point> v) {\n        int n = v.size();\n        double a = 0.0;\n        for (int i = 0; i < n - 1; i++) {\n            a += v.get(i).x * v.get(i + 1).y - v.get(i + 1).x * v.get(i).y;\n        }\n        return Math.abs(a + v.get(n - 1).x * v.get(0).y - v.get(0).x * v.get(n - 1).y) / 2.0;\n    }\n\n    public static void main(String[] args) {\n        List<Point> v = List.of(\n            new Point(3, 4),\n            new Point(5, 11),\n            new Point(12, 8),\n            new Point(9, 5),\n            new Point(5, 6)\n        );\n        double area = shoelaceArea(v);\n        System.out.printf(\"Given a polygon with vertices %s,%n\", v);\n        System.out.printf(\"its area is %f,%n\", area);\n    }\n}\n"}
{"id": 12215, "name": "Shoelace formula for polygonal area", "source": "Translate Fortran to Java:       DOUBLE PRECISION FUNCTION AREA(N,P)\t\nC   Uses the mid-point rule for integration. Consider the line joining (x1,y1) to (x2,y2)\nC The area under that line (down to the x-axis) is the y-span midpoint (y1 + y2)/2 times the width (x2 - x1)\nC This is the trapezoidal rule for a single interval, and follows from simple geometry.\nC Now consider a sequence of such points heading in the +x direction: each successive interval's area is positive.\nC Follow with a sequence of points heading in the -x direction, back to the first point: their areas are all negative.\nC The resulting sum is the area below the +x sequence and above the -x sequence: the area of the polygon.\nC   The point sequence can wobble as it wishes and can meet the other side, but it must not cross itself\nc as would be done in a figure 8 drawn with a crossover instead of a meeting.\nC   A clockwise traversal (as for an island) gives a positive area; use anti-clockwise for a lake.\n       INTEGER N\t\t\n       DOUBLE COMPLEX P(N)\t\n       DOUBLE COMPLEX PP,PC\t\n       DOUBLE COMPLEX W\t\t\n       DOUBLE PRECISION A\t\n       INTEGER I\t\t\n        IF (N.LT.3) STOP \"Area: at least three points are needed\n        W = (P(1) + P(N/3) + P(2*N/3))/3\t\n        W = SUM(P(1:N) - W)/N + W\t\n        A = 0\t\t\t\n        PC = P(N) - W\t\t\n        DO I = 1,N\t\t\n          PP = PC\t\t\t\n          PC = P(I) - W\t\t\t\n          A = (DIMAG(PC) + DIMAG(PP))*(DBLE(PC) - DBLE(PP)) + A\t\n        END DO\t\t\t\n        AREA = A/2\t\t\n      END FUNCTION AREA\t\t\n\n      DOUBLE PRECISION FUNCTION AREASL(N,P)\t\n       INTEGER N\t\t\n       DOUBLE COMPLEX P(N)\t\n       DOUBLE PRECISION A\t\n        A = SUM(DBLE(P(1:N - 1)*DIMAG(P(2:N)))) + DBLE(P(N))*DIMAG(P(1))\n     1    - SUM(DBLE(P(2:N)*DIMAG(P(1:N - 1)))) - DBLE(P(1))*DIMAG(P(N))\n        AREASL = A/2\t\t\n      END FUNCTION AREASL\t\n\n      INTEGER ENUFF\n      DOUBLE PRECISION AREA,AREASL\t\n      DOUBLE PRECISION A1,A2\t\t\n      PARAMETER (ENUFF = 5)\t\t\n      DOUBLE COMPLEX POINT(ENUFF)\t\n      DATA POINT/(3D0,4D0),(5D0,11D0),(12D0,8D0),(9D0,5D0),(5D0,6D0)/\t\n\n      WRITE (6,*) POINT\n      A1 = AREA(5,POINT)\n      A2 = AREASL(5,POINT)\n      WRITE (6,*) \"A=\",A1,A2\n      END\n", "target": "import java.util.List;\n\npublic class ShoelaceFormula {\n    private static class Point {\n        int x, y;\n\n        Point(int x, int y) {\n            this.x = x;\n            this.y = y;\n        }\n\n        @Override\n        public String toString() {\n            return String.format(\"(%d, %d)\", x, y);\n        }\n    }\n\n    private static double shoelaceArea(List<Point> v) {\n        int n = v.size();\n        double a = 0.0;\n        for (int i = 0; i < n - 1; i++) {\n            a += v.get(i).x * v.get(i + 1).y - v.get(i + 1).x * v.get(i).y;\n        }\n        return Math.abs(a + v.get(n - 1).x * v.get(0).y - v.get(0).x * v.get(n - 1).y) / 2.0;\n    }\n\n    public static void main(String[] args) {\n        List<Point> v = List.of(\n            new Point(3, 4),\n            new Point(5, 11),\n            new Point(12, 8),\n            new Point(9, 5),\n            new Point(5, 6)\n        );\n        double area = shoelaceArea(v);\n        System.out.printf(\"Given a polygon with vertices %s,%n\", v);\n        System.out.printf(\"its area is %f,%n\", area);\n    }\n}\n"}
{"id": 12216, "name": "Shoelace formula for polygonal area", "source": "Translate Fortran to Python:       DOUBLE PRECISION FUNCTION AREA(N,P)\t\nC   Uses the mid-point rule for integration. Consider the line joining (x1,y1) to (x2,y2)\nC The area under that line (down to the x-axis) is the y-span midpoint (y1 + y2)/2 times the width (x2 - x1)\nC This is the trapezoidal rule for a single interval, and follows from simple geometry.\nC Now consider a sequence of such points heading in the +x direction: each successive interval's area is positive.\nC Follow with a sequence of points heading in the -x direction, back to the first point: their areas are all negative.\nC The resulting sum is the area below the +x sequence and above the -x sequence: the area of the polygon.\nC   The point sequence can wobble as it wishes and can meet the other side, but it must not cross itself\nc as would be done in a figure 8 drawn with a crossover instead of a meeting.\nC   A clockwise traversal (as for an island) gives a positive area; use anti-clockwise for a lake.\n       INTEGER N\t\t\n       DOUBLE COMPLEX P(N)\t\n       DOUBLE COMPLEX PP,PC\t\n       DOUBLE COMPLEX W\t\t\n       DOUBLE PRECISION A\t\n       INTEGER I\t\t\n        IF (N.LT.3) STOP \"Area: at least three points are needed\n        W = (P(1) + P(N/3) + P(2*N/3))/3\t\n        W = SUM(P(1:N) - W)/N + W\t\n        A = 0\t\t\t\n        PC = P(N) - W\t\t\n        DO I = 1,N\t\t\n          PP = PC\t\t\t\n          PC = P(I) - W\t\t\t\n          A = (DIMAG(PC) + DIMAG(PP))*(DBLE(PC) - DBLE(PP)) + A\t\n        END DO\t\t\t\n        AREA = A/2\t\t\n      END FUNCTION AREA\t\t\n\n      DOUBLE PRECISION FUNCTION AREASL(N,P)\t\n       INTEGER N\t\t\n       DOUBLE COMPLEX P(N)\t\n       DOUBLE PRECISION A\t\n        A = SUM(DBLE(P(1:N - 1)*DIMAG(P(2:N)))) + DBLE(P(N))*DIMAG(P(1))\n     1    - SUM(DBLE(P(2:N)*DIMAG(P(1:N - 1)))) - DBLE(P(1))*DIMAG(P(N))\n        AREASL = A/2\t\t\n      END FUNCTION AREASL\t\n\n      INTEGER ENUFF\n      DOUBLE PRECISION AREA,AREASL\t\n      DOUBLE PRECISION A1,A2\t\t\n      PARAMETER (ENUFF = 5)\t\t\n      DOUBLE COMPLEX POINT(ENUFF)\t\n      DATA POINT/(3D0,4D0),(5D0,11D0),(12D0,8D0),(9D0,5D0),(5D0,6D0)/\t\n\n      WRITE (6,*) POINT\n      A1 = AREA(5,POINT)\n      A2 = AREASL(5,POINT)\n      WRITE (6,*) \"A=\",A1,A2\n      END\n", "target": ">>> def area_by_shoelace(x, y):\n    \"Assumes x,y points go around the polygon in one direction\"\n    return abs( sum(i * j for i, j in zip(x,             y[1:] + y[:1]))\n               -sum(i * j for i, j in zip(x[1:] + x[:1], y            ))) / 2\n\n>>> points = [(3,4), (5,11), (12,8), (9,5), (5,6)]\n>>> x, y = zip(*points)\n>>> area_by_shoelace(x, y)\n30.0\n>>>\n"}
{"id": 12217, "name": "Shoelace formula for polygonal area", "source": "Translate Fortran to Python:       DOUBLE PRECISION FUNCTION AREA(N,P)\t\nC   Uses the mid-point rule for integration. Consider the line joining (x1,y1) to (x2,y2)\nC The area under that line (down to the x-axis) is the y-span midpoint (y1 + y2)/2 times the width (x2 - x1)\nC This is the trapezoidal rule for a single interval, and follows from simple geometry.\nC Now consider a sequence of such points heading in the +x direction: each successive interval's area is positive.\nC Follow with a sequence of points heading in the -x direction, back to the first point: their areas are all negative.\nC The resulting sum is the area below the +x sequence and above the -x sequence: the area of the polygon.\nC   The point sequence can wobble as it wishes and can meet the other side, but it must not cross itself\nc as would be done in a figure 8 drawn with a crossover instead of a meeting.\nC   A clockwise traversal (as for an island) gives a positive area; use anti-clockwise for a lake.\n       INTEGER N\t\t\n       DOUBLE COMPLEX P(N)\t\n       DOUBLE COMPLEX PP,PC\t\n       DOUBLE COMPLEX W\t\t\n       DOUBLE PRECISION A\t\n       INTEGER I\t\t\n        IF (N.LT.3) STOP \"Area: at least three points are needed\n        W = (P(1) + P(N/3) + P(2*N/3))/3\t\n        W = SUM(P(1:N) - W)/N + W\t\n        A = 0\t\t\t\n        PC = P(N) - W\t\t\n        DO I = 1,N\t\t\n          PP = PC\t\t\t\n          PC = P(I) - W\t\t\t\n          A = (DIMAG(PC) + DIMAG(PP))*(DBLE(PC) - DBLE(PP)) + A\t\n        END DO\t\t\t\n        AREA = A/2\t\t\n      END FUNCTION AREA\t\t\n\n      DOUBLE PRECISION FUNCTION AREASL(N,P)\t\n       INTEGER N\t\t\n       DOUBLE COMPLEX P(N)\t\n       DOUBLE PRECISION A\t\n        A = SUM(DBLE(P(1:N - 1)*DIMAG(P(2:N)))) + DBLE(P(N))*DIMAG(P(1))\n     1    - SUM(DBLE(P(2:N)*DIMAG(P(1:N - 1)))) - DBLE(P(1))*DIMAG(P(N))\n        AREASL = A/2\t\t\n      END FUNCTION AREASL\t\n\n      INTEGER ENUFF\n      DOUBLE PRECISION AREA,AREASL\t\n      DOUBLE PRECISION A1,A2\t\t\n      PARAMETER (ENUFF = 5)\t\t\n      DOUBLE COMPLEX POINT(ENUFF)\t\n      DATA POINT/(3D0,4D0),(5D0,11D0),(12D0,8D0),(9D0,5D0),(5D0,6D0)/\t\n\n      WRITE (6,*) POINT\n      A1 = AREA(5,POINT)\n      A2 = AREASL(5,POINT)\n      WRITE (6,*) \"A=\",A1,A2\n      END\n", "target": ">>> def area_by_shoelace(x, y):\n    \"Assumes x,y points go around the polygon in one direction\"\n    return abs( sum(i * j for i, j in zip(x,             y[1:] + y[:1]))\n               -sum(i * j for i, j in zip(x[1:] + x[:1], y            ))) / 2\n\n>>> points = [(3,4), (5,11), (12,8), (9,5), (5,6)]\n>>> x, y = zip(*points)\n>>> area_by_shoelace(x, y)\n30.0\n>>>\n"}
{"id": 12661, "name": "Sudoku", "source": "Translate Fortran to C#: program sudoku\n\n  implicit none\n  integer, dimension (9, 9) :: grid\n  integer, dimension (9, 9) :: grid_solved\n  grid = reshape ((/               &\n    & 0, 0, 3, 0, 2, 0, 6, 0, 0,   &\n    & 9, 0, 0, 3, 0, 5, 0, 0, 1,   &\n    & 0, 0, 1, 8, 0, 6, 4, 0, 0,   &\n    & 0, 0, 8, 1, 0, 2, 9, 0, 0,   &\n    & 7, 0, 0, 0, 0, 0, 0, 0, 8,   &\n    & 0, 0, 6, 7, 0, 8, 2, 0, 0,   &\n    & 0, 0, 2, 6, 0, 9, 5, 0, 0,   &\n    & 8, 0, 0, 2, 0, 3, 0, 0, 9,   &\n    & 0, 0, 5, 0, 1, 0, 3, 0, 0/), &\n    & shape = (/9, 9/),            &\n    & order = (/2, 1/))\n  call pretty_print (grid)\n  call solve (1, 1)\n  write (*, *)\n  call pretty_print (grid_solved)\n\ncontains\n\n  recursive subroutine solve (i, j)\n    implicit none\n    integer, intent (in) :: i\n    integer, intent (in) :: j\n    integer :: n\n    integer :: n_tmp\n    if (i > 9) then\n      grid_solved = grid\n    else\n      do n = 1, 9\n        if (is_safe (i, j, n)) then\n          n_tmp = grid (i, j)\n          grid (i, j) = n\n          if (j == 9) then\n            call solve (i + 1, 1)\n          else\n            call solve (i, j + 1)\n          end if\n          grid (i, j) = n_tmp\n        end if\n      end do\n    end if\n  end subroutine solve\n\n  function is_safe (i, j, n) result (res)\n    implicit none\n    integer, intent (in) :: i\n    integer, intent (in) :: j\n    integer, intent (in) :: n\n    logical :: res\n    integer :: i_min\n    integer :: j_min\n    if (grid (i, j) == n) then\n      res = .true.\n      return\n    end if\n    if (grid (i, j) /= 0) then\n      res = .false.\n      return\n    end if\n    if (any (grid (i, :) == n)) then\n      res = .false.\n      return\n    end if\n    if (any (grid (:, j) == n)) then\n      res = .false.\n      return\n    end if\n    i_min = 1 + 3 * ((i - 1) / 3)\n    j_min = 1 + 3 * ((j - 1) / 3)\n    if (any (grid (i_min : i_min + 2, j_min : j_min + 2) == n)) then\n      res = .false.\n      return\n    end if\n    res = .true.\n  end function is_safe\n\n  subroutine pretty_print (grid)\n    implicit none\n    integer, dimension (9, 9), intent (in) :: grid\n    integer :: i\n    integer :: j\n    character (*), parameter :: bar = '+-----+-----+-----+'\n    character (*), parameter :: fmt = '(3 (\"|\", i0, 1x, i0, 1x, i0), \"|\")'\n    write (*, '(a)') bar\n    do j = 0, 6, 3\n      do i = j + 1, j + 3\n        write (*, fmt) grid (i, :)\n      end do\n      write (*, '(a)') bar\n    end do\n  end subroutine pretty_print\n\nend program sudoku\n", "target": "using System;\n\nclass SudokuSolver\n{\n    private int[] grid;\n\n    public SudokuSolver(String s)\n    {\n        grid = new int[81];\n        for (int i = 0; i < s.Length; i++)\n        {\n            grid[i] = int.Parse(s[i].ToString());\n        }\n    }\n\n    public void solve()\n    {\n        try\n        {\n            placeNumber(0);\n            Console.WriteLine(\"Unsolvable!\");\n        }\n        catch (Exception ex)\n        {\n            Console.WriteLine(ex.Message);\n            Console.WriteLine(this);\n        }\n    }\n\n    public void placeNumber(int pos)\n    {\n        if (pos == 81)\n        {\n            throw new Exception(\"Finished!\");\n        }\n        if (grid[pos] > 0)\n        {\n            placeNumber(pos + 1);\n            return;\n        }\n        for (int n = 1; n <= 9; n++)\n        {\n            if (checkValidity(n, pos % 9, pos / 9))\n            {\n                grid[pos] = n;\n                placeNumber(pos + 1);\n                grid[pos] = 0;\n            }\n        }\n    }\n\n    public bool checkValidity(int val, int x, int y)\n    {\n        for (int i = 0; i < 9; i++)\n        {\n            if (grid[y * 9 + i] == val || grid[i * 9 + x] == val)\n                return false;\n        }\n        int startX = (x / 3) * 3;\n        int startY = (y / 3) * 3;\n        for (int i = startY; i < startY + 3; i++)\n        {\n            for (int j = startX; j < startX + 3; j++)\n            {\n                if (grid[i * 9 + j] == val)\n                    return false;\n            }\n        }\n        return true;\n    }\n\n    public override string ToString()\n    {\n        string sb = \"\";\n        for (int i = 0; i < 9; i++)\n        {\n            for (int j = 0; j < 9; j++)\n            {\n                sb += (grid[i * 9 + j] + \" \");\n                if (j == 2 || j == 5)\n                    sb += (\"| \");\n            }\n            sb += ('\\n');\n            if (i == 2 || i == 5)\n                sb += (\"------+-------+------\\n\");\n        }\n        return sb;\n    }\n\n    public static void Main(String[] args)\n    {\n        new SudokuSolver(\"850002400\" +\n                         \"720000009\" +\n                         \"004000000\" +\n                         \"000107002\" +\n                         \"305000900\" +\n                         \"040000000\" +\n                         \"000080070\" +\n                         \"017000000\" +\n                         \"000036040\").solve();\n        Console.Read();\n    }\n}\n"}
{"id": 12664, "name": "Sudoku", "source": "Translate Fortran to Java: program sudoku\n\n  implicit none\n  integer, dimension (9, 9) :: grid\n  integer, dimension (9, 9) :: grid_solved\n  grid = reshape ((/               &\n    & 0, 0, 3, 0, 2, 0, 6, 0, 0,   &\n    & 9, 0, 0, 3, 0, 5, 0, 0, 1,   &\n    & 0, 0, 1, 8, 0, 6, 4, 0, 0,   &\n    & 0, 0, 8, 1, 0, 2, 9, 0, 0,   &\n    & 7, 0, 0, 0, 0, 0, 0, 0, 8,   &\n    & 0, 0, 6, 7, 0, 8, 2, 0, 0,   &\n    & 0, 0, 2, 6, 0, 9, 5, 0, 0,   &\n    & 8, 0, 0, 2, 0, 3, 0, 0, 9,   &\n    & 0, 0, 5, 0, 1, 0, 3, 0, 0/), &\n    & shape = (/9, 9/),            &\n    & order = (/2, 1/))\n  call pretty_print (grid)\n  call solve (1, 1)\n  write (*, *)\n  call pretty_print (grid_solved)\n\ncontains\n\n  recursive subroutine solve (i, j)\n    implicit none\n    integer, intent (in) :: i\n    integer, intent (in) :: j\n    integer :: n\n    integer :: n_tmp\n    if (i > 9) then\n      grid_solved = grid\n    else\n      do n = 1, 9\n        if (is_safe (i, j, n)) then\n          n_tmp = grid (i, j)\n          grid (i, j) = n\n          if (j == 9) then\n            call solve (i + 1, 1)\n          else\n            call solve (i, j + 1)\n          end if\n          grid (i, j) = n_tmp\n        end if\n      end do\n    end if\n  end subroutine solve\n\n  function is_safe (i, j, n) result (res)\n    implicit none\n    integer, intent (in) :: i\n    integer, intent (in) :: j\n    integer, intent (in) :: n\n    logical :: res\n    integer :: i_min\n    integer :: j_min\n    if (grid (i, j) == n) then\n      res = .true.\n      return\n    end if\n    if (grid (i, j) /= 0) then\n      res = .false.\n      return\n    end if\n    if (any (grid (i, :) == n)) then\n      res = .false.\n      return\n    end if\n    if (any (grid (:, j) == n)) then\n      res = .false.\n      return\n    end if\n    i_min = 1 + 3 * ((i - 1) / 3)\n    j_min = 1 + 3 * ((j - 1) / 3)\n    if (any (grid (i_min : i_min + 2, j_min : j_min + 2) == n)) then\n      res = .false.\n      return\n    end if\n    res = .true.\n  end function is_safe\n\n  subroutine pretty_print (grid)\n    implicit none\n    integer, dimension (9, 9), intent (in) :: grid\n    integer :: i\n    integer :: j\n    character (*), parameter :: bar = '+-----+-----+-----+'\n    character (*), parameter :: fmt = '(3 (\"|\", i0, 1x, i0, 1x, i0), \"|\")'\n    write (*, '(a)') bar\n    do j = 0, 6, 3\n      do i = j + 1, j + 3\n        write (*, fmt) grid (i, :)\n      end do\n      write (*, '(a)') bar\n    end do\n  end subroutine pretty_print\n\nend program sudoku\n", "target": "public class Sudoku\n{\n    private int mBoard[][];\n    private int mBoardSize;\n    private int mBoxSize;\n    private boolean mRowSubset[][];\n    private boolean mColSubset[][];\n    private boolean mBoxSubset[][];\n \n    public Sudoku(int board[][]) {\n        mBoard = board;\n        mBoardSize = mBoard.length;\n        mBoxSize = (int)Math.sqrt(mBoardSize);\n        initSubsets();\n    }\n \n    public void initSubsets() {\n        mRowSubset = new boolean[mBoardSize][mBoardSize];\n        mColSubset = new boolean[mBoardSize][mBoardSize];\n        mBoxSubset = new boolean[mBoardSize][mBoardSize];\n        for(int i = 0; i < mBoard.length; i++) {\n            for(int j = 0; j < mBoard.length; j++) {\n                int value = mBoard[i][j];\n                if(value != 0) {\n                    setSubsetValue(i, j, value, true);\n                }\n            }\n        }\n    }\n \n    private void setSubsetValue(int i, int j, int value, boolean present) {\n        mRowSubset[i][value - 1] = present;\n        mColSubset[j][value - 1] = present;\n        mBoxSubset[computeBoxNo(i, j)][value - 1] = present;\n    }\n \n    public boolean solve() {\n        return solve(0, 0);\n    }\n \n    public boolean solve(int i, int j) {\n        if(i == mBoardSize) {\n            i = 0;\n            if(++j == mBoardSize) {\n                return true;\n            }\n        }\n        if(mBoard[i][j] != 0) {\n            return solve(i + 1, j);\n        }\n        for(int value = 1; value <= mBoardSize; value++) {\n            if(isValid(i, j, value)) {\n                mBoard[i][j] = value;\n                setSubsetValue(i, j, value, true);\n                if(solve(i + 1, j)) {\n                    return true;\n                }\n                setSubsetValue(i, j, value, false);\n            }\n        }\n \n        mBoard[i][j] = 0;\n        return false;\n    }\n \n    private boolean isValid(int i, int j, int val) {\n        val--;\n        boolean isPresent = mRowSubset[i][val] || mColSubset[j][val] || mBoxSubset[computeBoxNo(i, j)][val];\n        return !isPresent;\n    }\n \n    private int computeBoxNo(int i, int j) {\n        int boxRow = i / mBoxSize;\n        int boxCol = j / mBoxSize;\n        return boxRow * mBoxSize + boxCol;\n    }\n \n    public void print() {\n        for(int i = 0; i < mBoardSize; i++) {\n            if(i % mBoxSize == 0) {\n                System.out.println(\" -----------------------\");\n            }\n            for(int j = 0; j < mBoardSize; j++) {\n                if(j % mBoxSize == 0) {\n                    System.out.print(\"| \");\n                }\n                System.out.print(mBoard[i][j] != 0 ? ((Object) (Integer.valueOf(mBoard[i][j]))) : \"-\");\n                System.out.print(' ');\n            }\n \n            System.out.println(\"|\");\n        }\n \n        System.out.println(\" -----------------------\");\n    }\n\n    public static void main(String[] args) {\n        int[][] board = { \n            {8, 5, 0, 0, 0, 2, 4, 0, 0},\n            {7, 2, 0, 0, 0, 0, 0, 0, 9},\n            {0, 0, 4, 0, 0, 0, 0, 0, 0},\n            {0, 0, 0, 1, 0, 7, 0, 0, 2},\n            {3, 0, 5, 0, 0, 0, 9, 0, 0},\n            {0, 4, 0, 0, 0, 0, 0, 0, 0},\n            {0, 0, 0, 0, 8, 0, 0, 7, 0},\n            {0, 1, 7, 0, 0, 0, 0, 0, 0},\n            {0, 0, 0, 0, 3, 6, 0, 4, 0}\n        };\n        Sudoku s = new Sudoku(board);\n        System.out.print(\"Starting grid:\\n\");\n        s.print();        \n        if (s.solve()) {\n            System.out.print(\"\\nSolution:\\n\");\n            s.print();\n        } else {\n            System.out.println(\"\\nUnsolvable!\");\n        }\n    }\n}\n"}
{"id": 12665, "name": "Sudoku", "source": "Translate Fortran to Python: program sudoku\n\n  implicit none\n  integer, dimension (9, 9) :: grid\n  integer, dimension (9, 9) :: grid_solved\n  grid = reshape ((/               &\n    & 0, 0, 3, 0, 2, 0, 6, 0, 0,   &\n    & 9, 0, 0, 3, 0, 5, 0, 0, 1,   &\n    & 0, 0, 1, 8, 0, 6, 4, 0, 0,   &\n    & 0, 0, 8, 1, 0, 2, 9, 0, 0,   &\n    & 7, 0, 0, 0, 0, 0, 0, 0, 8,   &\n    & 0, 0, 6, 7, 0, 8, 2, 0, 0,   &\n    & 0, 0, 2, 6, 0, 9, 5, 0, 0,   &\n    & 8, 0, 0, 2, 0, 3, 0, 0, 9,   &\n    & 0, 0, 5, 0, 1, 0, 3, 0, 0/), &\n    & shape = (/9, 9/),            &\n    & order = (/2, 1/))\n  call pretty_print (grid)\n  call solve (1, 1)\n  write (*, *)\n  call pretty_print (grid_solved)\n\ncontains\n\n  recursive subroutine solve (i, j)\n    implicit none\n    integer, intent (in) :: i\n    integer, intent (in) :: j\n    integer :: n\n    integer :: n_tmp\n    if (i > 9) then\n      grid_solved = grid\n    else\n      do n = 1, 9\n        if (is_safe (i, j, n)) then\n          n_tmp = grid (i, j)\n          grid (i, j) = n\n          if (j == 9) then\n            call solve (i + 1, 1)\n          else\n            call solve (i, j + 1)\n          end if\n          grid (i, j) = n_tmp\n        end if\n      end do\n    end if\n  end subroutine solve\n\n  function is_safe (i, j, n) result (res)\n    implicit none\n    integer, intent (in) :: i\n    integer, intent (in) :: j\n    integer, intent (in) :: n\n    logical :: res\n    integer :: i_min\n    integer :: j_min\n    if (grid (i, j) == n) then\n      res = .true.\n      return\n    end if\n    if (grid (i, j) /= 0) then\n      res = .false.\n      return\n    end if\n    if (any (grid (i, :) == n)) then\n      res = .false.\n      return\n    end if\n    if (any (grid (:, j) == n)) then\n      res = .false.\n      return\n    end if\n    i_min = 1 + 3 * ((i - 1) / 3)\n    j_min = 1 + 3 * ((j - 1) / 3)\n    if (any (grid (i_min : i_min + 2, j_min : j_min + 2) == n)) then\n      res = .false.\n      return\n    end if\n    res = .true.\n  end function is_safe\n\n  subroutine pretty_print (grid)\n    implicit none\n    integer, dimension (9, 9), intent (in) :: grid\n    integer :: i\n    integer :: j\n    character (*), parameter :: bar = '+-----+-----+-----+'\n    character (*), parameter :: fmt = '(3 (\"|\", i0, 1x, i0, 1x, i0), \"|\")'\n    write (*, '(a)') bar\n    do j = 0, 6, 3\n      do i = j + 1, j + 3\n        write (*, fmt) grid (i, :)\n      end do\n      write (*, '(a)') bar\n    end do\n  end subroutine pretty_print\n\nend program sudoku\n", "target": "def initiate():\n    box.append([0, 1, 2, 9, 10, 11, 18, 19, 20])\n    box.append([3, 4, 5, 12, 13, 14, 21, 22, 23])\n    box.append([6, 7, 8, 15, 16, 17, 24, 25, 26])\n    box.append([27, 28, 29, 36, 37, 38, 45, 46, 47])\n    box.append([30, 31, 32, 39, 40, 41, 48, 49, 50])\n    box.append([33, 34, 35, 42, 43, 44, 51, 52, 53])\n    box.append([54, 55, 56, 63, 64, 65, 72, 73, 74])\n    box.append([57, 58, 59, 66, 67, 68, 75, 76, 77])\n    box.append([60, 61, 62, 69, 70, 71, 78, 79, 80])\n    for i in range(0, 81, 9):\n        row.append(range(i, i+9))\n    for i in range(9):\n        column.append(range(i, 80+i, 9))\n\ndef valid(n, pos):\n    current_row = pos/9\n    current_col = pos%9\n    current_box = (current_row/3)*3 + (current_col/3)\n    for i in row[current_row]:\n        if (grid[i] == n):\n            return False\n    for i in column[current_col]:\n        if (grid[i] == n):\n            return False\n    for i in box[current_box]:\n        if (grid[i] == n):\n            return False\n    return True\n\ndef solve():\n    i = 0\n    proceed = 1\n    while(i < 81):\n        if given[i]:\n            if proceed:\n                    i += 1\n            else:\n                i -= 1\n        else:\n            n = grid[i]\n            prev = grid[i]\n            while(n < 9):\n              if (n < 9):\n                  n += 1\n              if valid(n, i):\n                  grid[i] = n\n                  proceed = 1\n                  break\n            if (grid[i] == prev):\n               grid[i] = 0\n               proceed = 0\n            if proceed:\n               i += 1\n            else:\n               i -=1\n\ndef inputs():\n    nextt = 'T'\n    number = 0\n    pos = 0\n    while(not(nextt == 'N' or nextt == 'n')):\n        print \"Enter the position:\",\n        pos = int(raw_input())\n        given[pos - 1] = True\n        print \"Enter the numerical:\",\n        number = int(raw_input())\n        grid[pos - 1] = number\n        print \"Do you want to enter another given?(Y, for yes: N, for no)\"\n        nextt = raw_input()\n\n\ngrid = [0]*81\ngiven = [False]*81\nbox = []\nrow = []\ncolumn = []\ninitiate()\ninputs()\nsolve()\nfor i in range(9):\n    print grid[i*9:i*9+9]\nraw_input()\n"}
{"id": 12871, "name": "Hello world_Newline omission", "source": "Translate Fortran to C#: program bye\n  write (*,'(a)',advance='no') 'Goodbye, World\nend program bye\n", "target": "using System;\n\nclass Program\n{\n    static void Main(string[] args)\n    {\n        \n        Console.WriteLine(\"Goodbye, World!\");\n\n        \n        Console.Write(\"Goodbye, World!\");\n    }\n}\n"}
{"id": 12875, "name": "Hello world_Newline omission", "source": "Translate Fortran to Java: program bye\n  write (*,'(a)',advance='no') 'Goodbye, World\nend program bye\n", "target": "public class HelloWorld\n{\n public static void main(String[] args)\n {\n  System.out.print(\"Goodbye, World!\");\n }\n}\n"}
{"id": 12876, "name": "Hello world_Newline omission", "source": "Translate Fortran to Python: program bye\n  write (*,'(a)',advance='no') 'Goodbye, World\nend program bye\n", "target": "import sys\nsys.stdout.write(\"Goodbye, World!\")\n"}
{"id": 13195, "name": "Vector products", "source": "Translate Fortran to C#: program VectorProducts\n\n  real, dimension(3)  :: a, b, c\n\n  a = (/ 3, 4, 5 /)\n  b = (/ 4, 3, 5 /)\n  c = (/ -5, -12, -13 /)\n\n  print *, dot_product(a, b)\n  print *, cross_product(a, b)\n  print *, s3_product(a, b, c)\n  print *, v3_product(a, b, c)\n\ncontains\n\n  function cross_product(a, b)\n    real, dimension(3) :: cross_product\n    real, dimension(3), intent(in) :: a, b\n\n    cross_product(1) = a(2)*b(3) - a(3)*b(2)\n    cross_product(2) = a(3)*b(1) - a(1)*b(3)\n    cross_product(3) = a(1)*b(2) - b(1)*a(2)\n  end function cross_product\n\n  function s3_product(a, b, c)\n    real :: s3_product\n    real, dimension(3), intent(in) :: a, b, c\n\n    s3_product = dot_product(a, cross_product(b, c))\n  end function s3_product\n\n  function v3_product(a, b, c)\n    real, dimension(3) :: v3_product\n    real, dimension(3), intent(in) :: a, b, c\n\n    v3_product = cross_product(a, cross_product(b, c))\n  end function v3_product\n\nend program VectorProducts\n", "target": "using System;\nusing System.Windows.Media.Media3D;\n\nclass VectorProducts\n{\n    static double ScalarTripleProduct(Vector3D a, Vector3D b, Vector3D c)\n    {\n        return Vector3D.DotProduct(a, Vector3D.CrossProduct(b, c));\n    }\n\n    static Vector3D VectorTripleProduct(Vector3D a, Vector3D b, Vector3D c)\n    {\n        return Vector3D.CrossProduct(a, Vector3D.CrossProduct(b, c));\n    }\n\n    static void Main()\n    {\n        var a = new Vector3D(3, 4, 5);\n        var b = new Vector3D(4, 3, 5);\n        var c = new Vector3D(-5, -12, -13);\n\n        Console.WriteLine(Vector3D.DotProduct(a, b));\n        Console.WriteLine(Vector3D.CrossProduct(a, b));\n        Console.WriteLine(ScalarTripleProduct(a, b, c));\n        Console.WriteLine(VectorTripleProduct(a, b, c));\n    }\n}\n"}
{"id": 13196, "name": "Vector products", "source": "Translate Fortran to C#: program VectorProducts\n\n  real, dimension(3)  :: a, b, c\n\n  a = (/ 3, 4, 5 /)\n  b = (/ 4, 3, 5 /)\n  c = (/ -5, -12, -13 /)\n\n  print *, dot_product(a, b)\n  print *, cross_product(a, b)\n  print *, s3_product(a, b, c)\n  print *, v3_product(a, b, c)\n\ncontains\n\n  function cross_product(a, b)\n    real, dimension(3) :: cross_product\n    real, dimension(3), intent(in) :: a, b\n\n    cross_product(1) = a(2)*b(3) - a(3)*b(2)\n    cross_product(2) = a(3)*b(1) - a(1)*b(3)\n    cross_product(3) = a(1)*b(2) - b(1)*a(2)\n  end function cross_product\n\n  function s3_product(a, b, c)\n    real :: s3_product\n    real, dimension(3), intent(in) :: a, b, c\n\n    s3_product = dot_product(a, cross_product(b, c))\n  end function s3_product\n\n  function v3_product(a, b, c)\n    real, dimension(3) :: v3_product\n    real, dimension(3), intent(in) :: a, b, c\n\n    v3_product = cross_product(a, cross_product(b, c))\n  end function v3_product\n\nend program VectorProducts\n", "target": "using System;\nusing System.Windows.Media.Media3D;\n\nclass VectorProducts\n{\n    static double ScalarTripleProduct(Vector3D a, Vector3D b, Vector3D c)\n    {\n        return Vector3D.DotProduct(a, Vector3D.CrossProduct(b, c));\n    }\n\n    static Vector3D VectorTripleProduct(Vector3D a, Vector3D b, Vector3D c)\n    {\n        return Vector3D.CrossProduct(a, Vector3D.CrossProduct(b, c));\n    }\n\n    static void Main()\n    {\n        var a = new Vector3D(3, 4, 5);\n        var b = new Vector3D(4, 3, 5);\n        var c = new Vector3D(-5, -12, -13);\n\n        Console.WriteLine(Vector3D.DotProduct(a, b));\n        Console.WriteLine(Vector3D.CrossProduct(a, b));\n        Console.WriteLine(ScalarTripleProduct(a, b, c));\n        Console.WriteLine(VectorTripleProduct(a, b, c));\n    }\n}\n"}
{"id": 13201, "name": "Vector products", "source": "Translate Fortran to Java: program VectorProducts\n\n  real, dimension(3)  :: a, b, c\n\n  a = (/ 3, 4, 5 /)\n  b = (/ 4, 3, 5 /)\n  c = (/ -5, -12, -13 /)\n\n  print *, dot_product(a, b)\n  print *, cross_product(a, b)\n  print *, s3_product(a, b, c)\n  print *, v3_product(a, b, c)\n\ncontains\n\n  function cross_product(a, b)\n    real, dimension(3) :: cross_product\n    real, dimension(3), intent(in) :: a, b\n\n    cross_product(1) = a(2)*b(3) - a(3)*b(2)\n    cross_product(2) = a(3)*b(1) - a(1)*b(3)\n    cross_product(3) = a(1)*b(2) - b(1)*a(2)\n  end function cross_product\n\n  function s3_product(a, b, c)\n    real :: s3_product\n    real, dimension(3), intent(in) :: a, b, c\n\n    s3_product = dot_product(a, cross_product(b, c))\n  end function s3_product\n\n  function v3_product(a, b, c)\n    real, dimension(3) :: v3_product\n    real, dimension(3), intent(in) :: a, b, c\n\n    v3_product = cross_product(a, cross_product(b, c))\n  end function v3_product\n\nend program VectorProducts\n", "target": "public class VectorProds{\n    public static class Vector3D<T extends Number>{\n        private T a, b, c;\n\n        public Vector3D(T a, T b, T c){\n            this.a = a;\n            this.b = b;\n            this.c = c;\n        }\n\n        public double dot(Vector3D<?> vec){\n            return (a.doubleValue() * vec.a.doubleValue() +\n                    b.doubleValue() * vec.b.doubleValue() +\n                    c.doubleValue() * vec.c.doubleValue());\n        }\n\n        public Vector3D<Double> cross(Vector3D<?> vec){\n            Double newA = b.doubleValue()*vec.c.doubleValue() - c.doubleValue()*vec.b.doubleValue();\n            Double newB = c.doubleValue()*vec.a.doubleValue() - a.doubleValue()*vec.c.doubleValue();\n            Double newC = a.doubleValue()*vec.b.doubleValue() - b.doubleValue()*vec.a.doubleValue();\n            return new Vector3D<Double>(newA, newB, newC);\n        }\n\n        public double scalTrip(Vector3D<?> vecB, Vector3D<?> vecC){\n            return this.dot(vecB.cross(vecC));\n        }\n\n        public Vector3D<Double> vecTrip(Vector3D<?> vecB, Vector3D<?> vecC){\n            return this.cross(vecB.cross(vecC));\n        }\n\n        @Override\n        public String toString(){\n            return \"<\" + a.toString() + \", \" + b.toString() + \", \" + c.toString() + \">\";\n        }\n    }\n\n    public static void main(String[] args){\n        Vector3D<Integer> a = new Vector3D<Integer>(3, 4, 5);\n        Vector3D<Integer> b = new Vector3D<Integer>(4, 3, 5);\n        Vector3D<Integer> c = new Vector3D<Integer>(-5, -12, -13);\n\n        System.out.println(a.dot(b));\n        System.out.println(a.cross(b));\n        System.out.println(a.scalTrip(b, c));\n        System.out.println(a.vecTrip(b, c));\n    }\n}\n"}
{"id": 13202, "name": "Vector products", "source": "Translate Fortran to Java: program VectorProducts\n\n  real, dimension(3)  :: a, b, c\n\n  a = (/ 3, 4, 5 /)\n  b = (/ 4, 3, 5 /)\n  c = (/ -5, -12, -13 /)\n\n  print *, dot_product(a, b)\n  print *, cross_product(a, b)\n  print *, s3_product(a, b, c)\n  print *, v3_product(a, b, c)\n\ncontains\n\n  function cross_product(a, b)\n    real, dimension(3) :: cross_product\n    real, dimension(3), intent(in) :: a, b\n\n    cross_product(1) = a(2)*b(3) - a(3)*b(2)\n    cross_product(2) = a(3)*b(1) - a(1)*b(3)\n    cross_product(3) = a(1)*b(2) - b(1)*a(2)\n  end function cross_product\n\n  function s3_product(a, b, c)\n    real :: s3_product\n    real, dimension(3), intent(in) :: a, b, c\n\n    s3_product = dot_product(a, cross_product(b, c))\n  end function s3_product\n\n  function v3_product(a, b, c)\n    real, dimension(3) :: v3_product\n    real, dimension(3), intent(in) :: a, b, c\n\n    v3_product = cross_product(a, cross_product(b, c))\n  end function v3_product\n\nend program VectorProducts\n", "target": "public class VectorProds{\n    public static class Vector3D<T extends Number>{\n        private T a, b, c;\n\n        public Vector3D(T a, T b, T c){\n            this.a = a;\n            this.b = b;\n            this.c = c;\n        }\n\n        public double dot(Vector3D<?> vec){\n            return (a.doubleValue() * vec.a.doubleValue() +\n                    b.doubleValue() * vec.b.doubleValue() +\n                    c.doubleValue() * vec.c.doubleValue());\n        }\n\n        public Vector3D<Double> cross(Vector3D<?> vec){\n            Double newA = b.doubleValue()*vec.c.doubleValue() - c.doubleValue()*vec.b.doubleValue();\n            Double newB = c.doubleValue()*vec.a.doubleValue() - a.doubleValue()*vec.c.doubleValue();\n            Double newC = a.doubleValue()*vec.b.doubleValue() - b.doubleValue()*vec.a.doubleValue();\n            return new Vector3D<Double>(newA, newB, newC);\n        }\n\n        public double scalTrip(Vector3D<?> vecB, Vector3D<?> vecC){\n            return this.dot(vecB.cross(vecC));\n        }\n\n        public Vector3D<Double> vecTrip(Vector3D<?> vecB, Vector3D<?> vecC){\n            return this.cross(vecB.cross(vecC));\n        }\n\n        @Override\n        public String toString(){\n            return \"<\" + a.toString() + \", \" + b.toString() + \", \" + c.toString() + \">\";\n        }\n    }\n\n    public static void main(String[] args){\n        Vector3D<Integer> a = new Vector3D<Integer>(3, 4, 5);\n        Vector3D<Integer> b = new Vector3D<Integer>(4, 3, 5);\n        Vector3D<Integer> c = new Vector3D<Integer>(-5, -12, -13);\n\n        System.out.println(a.dot(b));\n        System.out.println(a.cross(b));\n        System.out.println(a.scalTrip(b, c));\n        System.out.println(a.vecTrip(b, c));\n    }\n}\n"}
{"id": 13203, "name": "Vector products", "source": "Translate Fortran to Python: program VectorProducts\n\n  real, dimension(3)  :: a, b, c\n\n  a = (/ 3, 4, 5 /)\n  b = (/ 4, 3, 5 /)\n  c = (/ -5, -12, -13 /)\n\n  print *, dot_product(a, b)\n  print *, cross_product(a, b)\n  print *, s3_product(a, b, c)\n  print *, v3_product(a, b, c)\n\ncontains\n\n  function cross_product(a, b)\n    real, dimension(3) :: cross_product\n    real, dimension(3), intent(in) :: a, b\n\n    cross_product(1) = a(2)*b(3) - a(3)*b(2)\n    cross_product(2) = a(3)*b(1) - a(1)*b(3)\n    cross_product(3) = a(1)*b(2) - b(1)*a(2)\n  end function cross_product\n\n  function s3_product(a, b, c)\n    real :: s3_product\n    real, dimension(3), intent(in) :: a, b, c\n\n    s3_product = dot_product(a, cross_product(b, c))\n  end function s3_product\n\n  function v3_product(a, b, c)\n    real, dimension(3) :: v3_product\n    real, dimension(3), intent(in) :: a, b, c\n\n    v3_product = cross_product(a, cross_product(b, c))\n  end function v3_product\n\nend program VectorProducts\n", "target": "def crossp(a, b):\n    \n    assert len(a) == len(b) == 3, 'For 3D vectors only'\n    a1, a2, a3 = a\n    b1, b2, b3 = b\n    return (a2*b3 - a3*b2, a3*b1 - a1*b3, a1*b2 - a2*b1)\n \ndef dotp(a,b):\n    \n    assert len(a) == len(b), 'Vector sizes must match'\n    return sum(aterm * bterm for aterm,bterm in zip(a, b))\n \ndef scalartriplep(a, b, c):\n    \n    return dotp(a, crossp(b, c))\n \ndef vectortriplep(a, b, c):\n    \n    return crossp(a, crossp(b, c))\n \nif __name__ == '__main__':\n    a, b, c = (3, 4, 5), (4, 3, 5), (-5, -12, -13)\n    print(\"a = %r;  b = %r;  c = %r\" % (a, b, c))\n    print(\"a . b = %r\" % dotp(a,b))\n    print(\"a x b = %r\"  % (crossp(a,b),))\n    print(\"a . (b x c) = %r\" % scalartriplep(a, b, c))\n    print(\"a x (b x c) = %r\" % (vectortriplep(a, b, c),))\n"}
{"id": 13204, "name": "Vector products", "source": "Translate Fortran to Python: program VectorProducts\n\n  real, dimension(3)  :: a, b, c\n\n  a = (/ 3, 4, 5 /)\n  b = (/ 4, 3, 5 /)\n  c = (/ -5, -12, -13 /)\n\n  print *, dot_product(a, b)\n  print *, cross_product(a, b)\n  print *, s3_product(a, b, c)\n  print *, v3_product(a, b, c)\n\ncontains\n\n  function cross_product(a, b)\n    real, dimension(3) :: cross_product\n    real, dimension(3), intent(in) :: a, b\n\n    cross_product(1) = a(2)*b(3) - a(3)*b(2)\n    cross_product(2) = a(3)*b(1) - a(1)*b(3)\n    cross_product(3) = a(1)*b(2) - b(1)*a(2)\n  end function cross_product\n\n  function s3_product(a, b, c)\n    real :: s3_product\n    real, dimension(3), intent(in) :: a, b, c\n\n    s3_product = dot_product(a, cross_product(b, c))\n  end function s3_product\n\n  function v3_product(a, b, c)\n    real, dimension(3) :: v3_product\n    real, dimension(3), intent(in) :: a, b, c\n\n    v3_product = cross_product(a, cross_product(b, c))\n  end function v3_product\n\nend program VectorProducts\n", "target": "def crossp(a, b):\n    \n    assert len(a) == len(b) == 3, 'For 3D vectors only'\n    a1, a2, a3 = a\n    b1, b2, b3 = b\n    return (a2*b3 - a3*b2, a3*b1 - a1*b3, a1*b2 - a2*b1)\n \ndef dotp(a,b):\n    \n    assert len(a) == len(b), 'Vector sizes must match'\n    return sum(aterm * bterm for aterm,bterm in zip(a, b))\n \ndef scalartriplep(a, b, c):\n    \n    return dotp(a, crossp(b, c))\n \ndef vectortriplep(a, b, c):\n    \n    return crossp(a, crossp(b, c))\n \nif __name__ == '__main__':\n    a, b, c = (3, 4, 5), (4, 3, 5), (-5, -12, -13)\n    print(\"a = %r;  b = %r;  c = %r\" % (a, b, c))\n    print(\"a . b = %r\" % dotp(a,b))\n    print(\"a x b = %r\"  % (crossp(a,b),))\n    print(\"a . (b x c) = %r\" % scalartriplep(a, b, c))\n    print(\"a x (b x c) = %r\" % (vectortriplep(a, b, c),))\n"}
{"id": 13623, "name": "Hello world_Standard error", "source": "Translate Fortran to C#: program StdErr\n  \n  use iso_fortran_env\n\n  \n  \n  \n  write (ERROR_UNIT, *) \"Goodbye, World\nend program StdErr\n", "target": "static class StdErr\n{\n    static void Main(string[] args)\n    {\n        Console.Error.WriteLine(\"Goodbye, World!\");\n    }\n}\n"}
{"id": 13626, "name": "Hello world_Standard error", "source": "Translate Fortran to Java: program StdErr\n  \n  use iso_fortran_env\n\n  \n  \n  \n  write (ERROR_UNIT, *) \"Goodbye, World\nend program StdErr\n", "target": "public class Err{\n   public static void main(String[] args){\n      System.err.println(\"Goodbye, World!\");\n   }\n}\n"}
{"id": 13627, "name": "Hello world_Standard error", "source": "Translate Fortran to Python: program StdErr\n  \n  use iso_fortran_env\n\n  \n  \n  \n  write (ERROR_UNIT, *) \"Goodbye, World\nend program StdErr\n", "target": "import sys\n\nprint >> sys.stderr, \"Goodbye, World!\"\n"}
{"id": 13832, "name": "SEDOLs", "source": "Translate Fortran to C#: MODULE SEDOL_CHECK\n  IMPLICIT NONE\n  CONTAINS\n \n  FUNCTION Checkdigit(c)\n    CHARACTER :: Checkdigit\n    CHARACTER(6), INTENT(IN) :: c\n    CHARACTER(36) :: alpha = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n    INTEGER, DIMENSION(6) :: weights = (/ 1, 3, 1, 7, 3, 9 /), temp\n    INTEGER :: i, n\n\n    DO i = 1, 6\n      temp(i) = INDEX(alpha, c(i:i)) - 1\n    END DO\n    temp = temp * weights\n    n = MOD(10 - (MOD(SUM(temp), 10)), 10)  \n    Checkdigit = ACHAR(n + 48)\n  END FUNCTION Checkdigit\n \nEND MODULE SEDOL_CHECK\n\nPROGRAM SEDOLTEST\n  USE SEDOL_CHECK\n  IMPLICIT NONE\n \n  CHARACTER(31) :: valid = \"0123456789BCDFGHJKLMNPQRSTVWXYZ\"\n  CHARACTER(6) :: codes(10) = (/ \"710889\", \"B0YBKJ\", \"406566\", \"B0YBLH\", \"228276\" ,  &\n                                 \"B0YBKL\", \"557910\", \"B0YBKR\", \"585284\", \"B0YBKT\" /)\n  CHARACTER(7) :: sedol\n  INTEGER :: i, invalid\n\n  DO i = 1, 10\n    invalid = VERIFY(codes(i), valid)\n    IF (invalid == 0) THEN\n      sedol = codes(i)\n      sedol(7:7) = Checkdigit(codes(i))\n    ELSE\n      sedol = \"INVALID\"\n    END IF\n    WRITE(*, \"(2A9)\") codes(i), sedol\n  END DO\n   \nEND PROGRAM SEDOLTEST\n", "target": "static int[] sedol_weights = { 1, 3, 1, 7, 3, 9 };\nstatic int sedolChecksum(string sedol)\n{\n    int len = sedol.Length;\n    int sum = 0;\n\n    if (len == 7) \n        return (int)sedol[6];\n\n    if ((len > 7) || (len < 6) || System.Text.RegularExpressions.Regex.IsMatch(sedol, \"[AEIOUaeiou]+\")) \n        return -1;\n\n    for (int i = 0; i < 6; i++)\n    {\n        if (Char.IsDigit(sedol[i]))\n            sum += (((int)sedol[i] - 48) * sedol_weights[i]);\n\n        else if (Char.IsLetter(sedol[i]))\n            sum += (((int)Char.ToUpper(sedol[i]) - 55) * sedol_weights[i]);\n\n        else\n            return -1;\n\n    }\n\n    return (10 - (sum % 10)) % 10;\n}\n"}
{"id": 13835, "name": "SEDOLs", "source": "Translate Fortran to Java: MODULE SEDOL_CHECK\n  IMPLICIT NONE\n  CONTAINS\n \n  FUNCTION Checkdigit(c)\n    CHARACTER :: Checkdigit\n    CHARACTER(6), INTENT(IN) :: c\n    CHARACTER(36) :: alpha = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n    INTEGER, DIMENSION(6) :: weights = (/ 1, 3, 1, 7, 3, 9 /), temp\n    INTEGER :: i, n\n\n    DO i = 1, 6\n      temp(i) = INDEX(alpha, c(i:i)) - 1\n    END DO\n    temp = temp * weights\n    n = MOD(10 - (MOD(SUM(temp), 10)), 10)  \n    Checkdigit = ACHAR(n + 48)\n  END FUNCTION Checkdigit\n \nEND MODULE SEDOL_CHECK\n\nPROGRAM SEDOLTEST\n  USE SEDOL_CHECK\n  IMPLICIT NONE\n \n  CHARACTER(31) :: valid = \"0123456789BCDFGHJKLMNPQRSTVWXYZ\"\n  CHARACTER(6) :: codes(10) = (/ \"710889\", \"B0YBKJ\", \"406566\", \"B0YBLH\", \"228276\" ,  &\n                                 \"B0YBKL\", \"557910\", \"B0YBKR\", \"585284\", \"B0YBKT\" /)\n  CHARACTER(7) :: sedol\n  INTEGER :: i, invalid\n\n  DO i = 1, 10\n    invalid = VERIFY(codes(i), valid)\n    IF (invalid == 0) THEN\n      sedol = codes(i)\n      sedol(7:7) = Checkdigit(codes(i))\n    ELSE\n      sedol = \"INVALID\"\n    END IF\n    WRITE(*, \"(2A9)\") codes(i), sedol\n  END DO\n   \nEND PROGRAM SEDOLTEST\n", "target": "import java.util.Scanner;\n\npublic class SEDOL{\n\tpublic static void main(String[] args){\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(sc.hasNext()){\n\t\t\tString sedol = sc.next();\n\t\t\tSystem.out.println(sedol + getSedolCheckDigit(sedol));\n\t\t}\n\t}\n\t\n\tprivate static final int[] mult = {1, 3, 1, 7, 3, 9};\n\t\n\tpublic static int getSedolCheckDigit(String str){\n\t    if(!validateSedol(str)){\n\t    \tSystem.err.println(\"SEDOL strings must contain six characters with no vowels.\");\n\t    \treturn -1;\n\t    }\n\t    str = str.toUpperCase();\n\t    int total = 0;\n\t    for(int i = 0;i < 6; i++){\n\t        char s = str.charAt(i);\n\t        total += Character.digit(s, 36) * mult[i];\n\t    }\n\t    return (10 - (total % 10)) % 10;\n\t}\n\n\tpublic static boolean validateSedol(String str){\n\t\treturn (str.length() == 6) && !str.toUpperCase().matches(\".*?[AEIOU].*?\");\n\t}\n}\n"}
{"id": 13836, "name": "SEDOLs", "source": "Translate Fortran to Python: MODULE SEDOL_CHECK\n  IMPLICIT NONE\n  CONTAINS\n \n  FUNCTION Checkdigit(c)\n    CHARACTER :: Checkdigit\n    CHARACTER(6), INTENT(IN) :: c\n    CHARACTER(36) :: alpha = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n    INTEGER, DIMENSION(6) :: weights = (/ 1, 3, 1, 7, 3, 9 /), temp\n    INTEGER :: i, n\n\n    DO i = 1, 6\n      temp(i) = INDEX(alpha, c(i:i)) - 1\n    END DO\n    temp = temp * weights\n    n = MOD(10 - (MOD(SUM(temp), 10)), 10)  \n    Checkdigit = ACHAR(n + 48)\n  END FUNCTION Checkdigit\n \nEND MODULE SEDOL_CHECK\n\nPROGRAM SEDOLTEST\n  USE SEDOL_CHECK\n  IMPLICIT NONE\n \n  CHARACTER(31) :: valid = \"0123456789BCDFGHJKLMNPQRSTVWXYZ\"\n  CHARACTER(6) :: codes(10) = (/ \"710889\", \"B0YBKJ\", \"406566\", \"B0YBLH\", \"228276\" ,  &\n                                 \"B0YBKL\", \"557910\", \"B0YBKR\", \"585284\", \"B0YBKT\" /)\n  CHARACTER(7) :: sedol\n  INTEGER :: i, invalid\n\n  DO i = 1, 10\n    invalid = VERIFY(codes(i), valid)\n    IF (invalid == 0) THEN\n      sedol = codes(i)\n      sedol(7:7) = Checkdigit(codes(i))\n    ELSE\n      sedol = \"INVALID\"\n    END IF\n    WRITE(*, \"(2A9)\") codes(i), sedol\n  END DO\n   \nEND PROGRAM SEDOLTEST\n", "target": "def char2value(c):\n  assert c not in 'AEIOU', \"No vowels\"\n  return int(c, 36)\n\nsedolweight = [1,3,1,7,3,9]\n\ndef checksum(sedol):\n    tmp = sum(map(lambda ch, weight: char2value(ch) * weight,\n                  sedol, sedolweight)\n               )\n    return str((10 - (tmp % 10)) % 10)\n\nfor sedol in .split():\n    print sedol + checksum(sedol)\n"}
{"id": 14089, "name": "Determine if a string is squeezable", "source": "Translate Fortran to C#: program main\nimplicit none\ncharacter(len=:),allocatable :: strings(:)\n\nstrings=[ character(len=72) :: &\n'', &\n'\"If I were two-faced, would I be wearing this one?\" --- Abraham Lincoln',  &\n'..1111111111111111111111111111111111111111111111111111111111111117777888', &\n'I never give ''em hell, I just tell the truth, and they think it''s hell.',&\n'                                                    --- Harry S Truman'    &\n]\n\n   call printme( trim(strings(1)), ' ' )\n   call printme( strings(2:4),     ['-','7','.'] )\n   call printme( strings(5),       [' ','-','r'] )\n\ncontains\n\nimpure elemental subroutine printme(str,chr)\ncharacter(len=*),intent(in) :: str\ncharacter(len=1),intent(in) :: chr\ncharacter(len=:),allocatable :: answer\n   write(*,'(a)')repeat('=',9)\n   write(*,'(\"IN:   <<<\",g0,\">>>\")')str\n   answer=compact(str,chr)\n   write(*,'(\"OUT:  <<<\",g0,\">>>\")')answer\n   write(*,'(\"LENS: \",*(g0,1x))')\"from\",len(str),\"to\",len(answer),\"for a change of\",len(str)-len(answer)\n   write(*,'(\"CHAR: \",g0)')chr\nend subroutine printme\n\nelemental function compact(str,charp) result (outstr)\n\ncharacter(len=*),intent(in)  :: str\ncharacter(len=1),intent(in)  :: charp\ncharacter(len=:),allocatable :: outstr\ncharacter(len=1)             :: ch, last_one\ninteger                      :: i, pio \n\n   outstr=repeat(' ',len(str))      \n   if(len(outstr)==0)return         \n   last_one=str(1:1)                \n   outstr(1:1)=last_one\n   pio=1\n\n   do i=2,len(str)\n      ch=str(i:i)\n      pio=pio+merge(0,1, ch.eq.last_one.and.ch.eq.charp) \n      outstr(pio:pio)=ch  \n      last_one=ch\n   enddo\n\n   outstr=outstr(:pio)              \nend function compact\n\nend program main\n}\n", "target": "using System;\nusing static System.Linq.Enumerable;\n\npublic class Program\n{\n    static void Main()\n    {\n        SqueezeAndPrint(\"\", ' ');\n        SqueezeAndPrint(\"\\\"If I were two-faced, would I be wearing this one?\\\" --- Abraham Lincoln \", '-');\n        SqueezeAndPrint(\"..1111111111111111111111111111111111111111111111111111111111111117777888\", '7');\n        SqueezeAndPrint(\"I never give 'em hell, I just tell the truth, and they think it's hell. \", '.');\n        string s = \"                                                    --- Harry S Truman  \";\n        SqueezeAndPrint(s, ' ');\n        SqueezeAndPrint(s, '-');\n        SqueezeAndPrint(s, 'r');\n    }\n\n    static void SqueezeAndPrint(string s, char c) {\n        Console.WriteLine($\"squeeze: '{c}'\");\n        Console.WriteLine($\"old: {s.Length} \u00ab\u00ab\u00ab{s}\u00bb\u00bb\u00bb\");\n        s = Squeeze(s, c);\n        Console.WriteLine($\"new: {s.Length} \u00ab\u00ab\u00ab{s}\u00bb\u00bb\u00bb\");\n    }\n\n    static string Squeeze(string s, char c) => string.IsNullOrEmpty(s) ? \"\" :\n        s[0] + new string(Range(1, s.Length - 1).Where(i => s[i] != c || s[i] != s[i - 1]).Select(i => s[i]).ToArray());\n}\n"}
{"id": 14090, "name": "Determine if a string is squeezable", "source": "Translate Fortran to C#: program main\nimplicit none\ncharacter(len=:),allocatable :: strings(:)\n\nstrings=[ character(len=72) :: &\n'', &\n'\"If I were two-faced, would I be wearing this one?\" --- Abraham Lincoln',  &\n'..1111111111111111111111111111111111111111111111111111111111111117777888', &\n'I never give ''em hell, I just tell the truth, and they think it''s hell.',&\n'                                                    --- Harry S Truman'    &\n]\n\n   call printme( trim(strings(1)), ' ' )\n   call printme( strings(2:4),     ['-','7','.'] )\n   call printme( strings(5),       [' ','-','r'] )\n\ncontains\n\nimpure elemental subroutine printme(str,chr)\ncharacter(len=*),intent(in) :: str\ncharacter(len=1),intent(in) :: chr\ncharacter(len=:),allocatable :: answer\n   write(*,'(a)')repeat('=',9)\n   write(*,'(\"IN:   <<<\",g0,\">>>\")')str\n   answer=compact(str,chr)\n   write(*,'(\"OUT:  <<<\",g0,\">>>\")')answer\n   write(*,'(\"LENS: \",*(g0,1x))')\"from\",len(str),\"to\",len(answer),\"for a change of\",len(str)-len(answer)\n   write(*,'(\"CHAR: \",g0)')chr\nend subroutine printme\n\nelemental function compact(str,charp) result (outstr)\n\ncharacter(len=*),intent(in)  :: str\ncharacter(len=1),intent(in)  :: charp\ncharacter(len=:),allocatable :: outstr\ncharacter(len=1)             :: ch, last_one\ninteger                      :: i, pio \n\n   outstr=repeat(' ',len(str))      \n   if(len(outstr)==0)return         \n   last_one=str(1:1)                \n   outstr(1:1)=last_one\n   pio=1\n\n   do i=2,len(str)\n      ch=str(i:i)\n      pio=pio+merge(0,1, ch.eq.last_one.and.ch.eq.charp) \n      outstr(pio:pio)=ch  \n      last_one=ch\n   enddo\n\n   outstr=outstr(:pio)              \nend function compact\n\nend program main\n}\n", "target": "using System;\nusing static System.Linq.Enumerable;\n\npublic class Program\n{\n    static void Main()\n    {\n        SqueezeAndPrint(\"\", ' ');\n        SqueezeAndPrint(\"\\\"If I were two-faced, would I be wearing this one?\\\" --- Abraham Lincoln \", '-');\n        SqueezeAndPrint(\"..1111111111111111111111111111111111111111111111111111111111111117777888\", '7');\n        SqueezeAndPrint(\"I never give 'em hell, I just tell the truth, and they think it's hell. \", '.');\n        string s = \"                                                    --- Harry S Truman  \";\n        SqueezeAndPrint(s, ' ');\n        SqueezeAndPrint(s, '-');\n        SqueezeAndPrint(s, 'r');\n    }\n\n    static void SqueezeAndPrint(string s, char c) {\n        Console.WriteLine($\"squeeze: '{c}'\");\n        Console.WriteLine($\"old: {s.Length} \u00ab\u00ab\u00ab{s}\u00bb\u00bb\u00bb\");\n        s = Squeeze(s, c);\n        Console.WriteLine($\"new: {s.Length} \u00ab\u00ab\u00ab{s}\u00bb\u00bb\u00bb\");\n    }\n\n    static string Squeeze(string s, char c) => string.IsNullOrEmpty(s) ? \"\" :\n        s[0] + new string(Range(1, s.Length - 1).Where(i => s[i] != c || s[i] != s[i - 1]).Select(i => s[i]).ToArray());\n}\n"}
{"id": 14096, "name": "Determine if a string is squeezable", "source": "Translate Fortran to Java: program main\nimplicit none\ncharacter(len=:),allocatable :: strings(:)\n\nstrings=[ character(len=72) :: &\n'', &\n'\"If I were two-faced, would I be wearing this one?\" --- Abraham Lincoln',  &\n'..1111111111111111111111111111111111111111111111111111111111111117777888', &\n'I never give ''em hell, I just tell the truth, and they think it''s hell.',&\n'                                                    --- Harry S Truman'    &\n]\n\n   call printme( trim(strings(1)), ' ' )\n   call printme( strings(2:4),     ['-','7','.'] )\n   call printme( strings(5),       [' ','-','r'] )\n\ncontains\n\nimpure elemental subroutine printme(str,chr)\ncharacter(len=*),intent(in) :: str\ncharacter(len=1),intent(in) :: chr\ncharacter(len=:),allocatable :: answer\n   write(*,'(a)')repeat('=',9)\n   write(*,'(\"IN:   <<<\",g0,\">>>\")')str\n   answer=compact(str,chr)\n   write(*,'(\"OUT:  <<<\",g0,\">>>\")')answer\n   write(*,'(\"LENS: \",*(g0,1x))')\"from\",len(str),\"to\",len(answer),\"for a change of\",len(str)-len(answer)\n   write(*,'(\"CHAR: \",g0)')chr\nend subroutine printme\n\nelemental function compact(str,charp) result (outstr)\n\ncharacter(len=*),intent(in)  :: str\ncharacter(len=1),intent(in)  :: charp\ncharacter(len=:),allocatable :: outstr\ncharacter(len=1)             :: ch, last_one\ninteger                      :: i, pio \n\n   outstr=repeat(' ',len(str))      \n   if(len(outstr)==0)return         \n   last_one=str(1:1)                \n   outstr(1:1)=last_one\n   pio=1\n\n   do i=2,len(str)\n      ch=str(i:i)\n      pio=pio+merge(0,1, ch.eq.last_one.and.ch.eq.charp) \n      outstr(pio:pio)=ch  \n      last_one=ch\n   enddo\n\n   outstr=outstr(:pio)              \nend function compact\n\nend program main\n}\n", "target": "\n\npublic class StringSqueezable {\n\n    public static void main(String[] args) {\n        String[] testStrings = new String[] {\n                \"\", \n                \"\\\"If I were two-faced, would I be wearing this one?\\\" --- Abraham Lincoln \", \n                \"..1111111111111111111111111111111111111111111111111111111111111117777888\", \n                \"I never give 'em hell, I just tell the truth, and they think it's hell. \", \n                \"                                                    --- Harry S Truman  \",\n                \"122333444455555666666777777788888888999999999\",\n                \"The better the 4-wheel drive, the further you'll be from help when ya get stuck!\",\n                \"headmistressship\"};\n\n        String[] testChar = new String[] {\n                \" \", \n                \"-\", \n                \"7\", \n                \".\", \n                \" -r\",\n                \"5\",\n                \"e\",\n                \"s\"};\n        for ( int testNum = 0 ; testNum < testStrings.length ; testNum++ ) {\n            String s = testStrings[testNum];\n            for ( char c : testChar[testNum].toCharArray() ) {\n                String result = squeeze(s, c);\n                System.out.printf(\"use: '%c'%nold:  %2d <<<%s>>>%nnew:  %2d <<<%s>>>%n%n\", c, s.length(), s, result.length(), result);\n            }\n        }\n    }\n    \n    private static String squeeze(String in, char include) {\n        StringBuilder sb = new StringBuilder();\n        for ( int i = 0 ; i < in.length() ; i++ ) {\n            if ( i == 0 || in.charAt(i-1) != in.charAt(i) || (in.charAt(i-1) == in.charAt(i) && in.charAt(i) != include)) {\n                sb.append(in.charAt(i));\n            }\n        }\n        return sb.toString();\n    }\n\n}\n"}
{"id": 14097, "name": "Determine if a string is squeezable", "source": "Translate Fortran to Java: program main\nimplicit none\ncharacter(len=:),allocatable :: strings(:)\n\nstrings=[ character(len=72) :: &\n'', &\n'\"If I were two-faced, would I be wearing this one?\" --- Abraham Lincoln',  &\n'..1111111111111111111111111111111111111111111111111111111111111117777888', &\n'I never give ''em hell, I just tell the truth, and they think it''s hell.',&\n'                                                    --- Harry S Truman'    &\n]\n\n   call printme( trim(strings(1)), ' ' )\n   call printme( strings(2:4),     ['-','7','.'] )\n   call printme( strings(5),       [' ','-','r'] )\n\ncontains\n\nimpure elemental subroutine printme(str,chr)\ncharacter(len=*),intent(in) :: str\ncharacter(len=1),intent(in) :: chr\ncharacter(len=:),allocatable :: answer\n   write(*,'(a)')repeat('=',9)\n   write(*,'(\"IN:   <<<\",g0,\">>>\")')str\n   answer=compact(str,chr)\n   write(*,'(\"OUT:  <<<\",g0,\">>>\")')answer\n   write(*,'(\"LENS: \",*(g0,1x))')\"from\",len(str),\"to\",len(answer),\"for a change of\",len(str)-len(answer)\n   write(*,'(\"CHAR: \",g0)')chr\nend subroutine printme\n\nelemental function compact(str,charp) result (outstr)\n\ncharacter(len=*),intent(in)  :: str\ncharacter(len=1),intent(in)  :: charp\ncharacter(len=:),allocatable :: outstr\ncharacter(len=1)             :: ch, last_one\ninteger                      :: i, pio \n\n   outstr=repeat(' ',len(str))      \n   if(len(outstr)==0)return         \n   last_one=str(1:1)                \n   outstr(1:1)=last_one\n   pio=1\n\n   do i=2,len(str)\n      ch=str(i:i)\n      pio=pio+merge(0,1, ch.eq.last_one.and.ch.eq.charp) \n      outstr(pio:pio)=ch  \n      last_one=ch\n   enddo\n\n   outstr=outstr(:pio)              \nend function compact\n\nend program main\n}\n", "target": "\n\npublic class StringSqueezable {\n\n    public static void main(String[] args) {\n        String[] testStrings = new String[] {\n                \"\", \n                \"\\\"If I were two-faced, would I be wearing this one?\\\" --- Abraham Lincoln \", \n                \"..1111111111111111111111111111111111111111111111111111111111111117777888\", \n                \"I never give 'em hell, I just tell the truth, and they think it's hell. \", \n                \"                                                    --- Harry S Truman  \",\n                \"122333444455555666666777777788888888999999999\",\n                \"The better the 4-wheel drive, the further you'll be from help when ya get stuck!\",\n                \"headmistressship\"};\n\n        String[] testChar = new String[] {\n                \" \", \n                \"-\", \n                \"7\", \n                \".\", \n                \" -r\",\n                \"5\",\n                \"e\",\n                \"s\"};\n        for ( int testNum = 0 ; testNum < testStrings.length ; testNum++ ) {\n            String s = testStrings[testNum];\n            for ( char c : testChar[testNum].toCharArray() ) {\n                String result = squeeze(s, c);\n                System.out.printf(\"use: '%c'%nold:  %2d <<<%s>>>%nnew:  %2d <<<%s>>>%n%n\", c, s.length(), s, result.length(), result);\n            }\n        }\n    }\n    \n    private static String squeeze(String in, char include) {\n        StringBuilder sb = new StringBuilder();\n        for ( int i = 0 ; i < in.length() ; i++ ) {\n            if ( i == 0 || in.charAt(i-1) != in.charAt(i) || (in.charAt(i-1) == in.charAt(i) && in.charAt(i) != include)) {\n                sb.append(in.charAt(i));\n            }\n        }\n        return sb.toString();\n    }\n\n}\n"}
{"id": 14098, "name": "Determine if a string is squeezable", "source": "Translate Fortran to Python: program main\nimplicit none\ncharacter(len=:),allocatable :: strings(:)\n\nstrings=[ character(len=72) :: &\n'', &\n'\"If I were two-faced, would I be wearing this one?\" --- Abraham Lincoln',  &\n'..1111111111111111111111111111111111111111111111111111111111111117777888', &\n'I never give ''em hell, I just tell the truth, and they think it''s hell.',&\n'                                                    --- Harry S Truman'    &\n]\n\n   call printme( trim(strings(1)), ' ' )\n   call printme( strings(2:4),     ['-','7','.'] )\n   call printme( strings(5),       [' ','-','r'] )\n\ncontains\n\nimpure elemental subroutine printme(str,chr)\ncharacter(len=*),intent(in) :: str\ncharacter(len=1),intent(in) :: chr\ncharacter(len=:),allocatable :: answer\n   write(*,'(a)')repeat('=',9)\n   write(*,'(\"IN:   <<<\",g0,\">>>\")')str\n   answer=compact(str,chr)\n   write(*,'(\"OUT:  <<<\",g0,\">>>\")')answer\n   write(*,'(\"LENS: \",*(g0,1x))')\"from\",len(str),\"to\",len(answer),\"for a change of\",len(str)-len(answer)\n   write(*,'(\"CHAR: \",g0)')chr\nend subroutine printme\n\nelemental function compact(str,charp) result (outstr)\n\ncharacter(len=*),intent(in)  :: str\ncharacter(len=1),intent(in)  :: charp\ncharacter(len=:),allocatable :: outstr\ncharacter(len=1)             :: ch, last_one\ninteger                      :: i, pio \n\n   outstr=repeat(' ',len(str))      \n   if(len(outstr)==0)return         \n   last_one=str(1:1)                \n   outstr(1:1)=last_one\n   pio=1\n\n   do i=2,len(str)\n      ch=str(i:i)\n      pio=pio+merge(0,1, ch.eq.last_one.and.ch.eq.charp) \n      outstr(pio:pio)=ch  \n      last_one=ch\n   enddo\n\n   outstr=outstr(:pio)              \nend function compact\n\nend program main\n}\n", "target": "from itertools import groupby\n\ndef squeezer(s, txt):\n    return ''.join(item if item == s else ''.join(grp)\n                   for item, grp in groupby(txt))\n\nif __name__ == '__main__':\n    strings = [\n            \"\",\n            '\"If I were two-faced, would I be wearing this one?\" --- Abraham Lincoln ',\n            \"..1111111111111111111111111111111111111111111111111111111111111117777888\",\n            \"I never give 'em hell, I just tell the truth, and they think it's hell. \",\n            \"                                                   ---  Harry S Truman  \",\n            \"The better the 4-wheel drive, the further you'll be from help when ya get stuck!\",\n            \"headmistressship\",\n            \"aardvark\",\n            \"\ud83d\ude0d\ud83d\ude00\ud83d\ude4c\ud83d\udc83\ud83d\ude0d\ud83d\ude0d\ud83d\ude0d\ud83d\ude4c\",\n            ]\n    squeezers = ' ,-,7,., -r,e,s,a,\ud83d\ude0d'.split(',')\n    for txt, chars in zip(strings, squeezers):\n        this = \"Original\"\n        print(f\"\\n{this:14} Size: {len(txt)} \u00ab\u00ab\u00ab{txt}\u00bb\u00bb\u00bb\" )\n        for ch in chars:\n            this = f\"Squeezer '{ch}'\"\n            sqz = squeezer(ch, txt)\n            print(f\"{this:>14} Size: {len(sqz)} \u00ab\u00ab\u00ab{sqz}\u00bb\u00bb\u00bb\" )\n"}
{"id": 14099, "name": "Determine if a string is squeezable", "source": "Translate Fortran to Python: program main\nimplicit none\ncharacter(len=:),allocatable :: strings(:)\n\nstrings=[ character(len=72) :: &\n'', &\n'\"If I were two-faced, would I be wearing this one?\" --- Abraham Lincoln',  &\n'..1111111111111111111111111111111111111111111111111111111111111117777888', &\n'I never give ''em hell, I just tell the truth, and they think it''s hell.',&\n'                                                    --- Harry S Truman'    &\n]\n\n   call printme( trim(strings(1)), ' ' )\n   call printme( strings(2:4),     ['-','7','.'] )\n   call printme( strings(5),       [' ','-','r'] )\n\ncontains\n\nimpure elemental subroutine printme(str,chr)\ncharacter(len=*),intent(in) :: str\ncharacter(len=1),intent(in) :: chr\ncharacter(len=:),allocatable :: answer\n   write(*,'(a)')repeat('=',9)\n   write(*,'(\"IN:   <<<\",g0,\">>>\")')str\n   answer=compact(str,chr)\n   write(*,'(\"OUT:  <<<\",g0,\">>>\")')answer\n   write(*,'(\"LENS: \",*(g0,1x))')\"from\",len(str),\"to\",len(answer),\"for a change of\",len(str)-len(answer)\n   write(*,'(\"CHAR: \",g0)')chr\nend subroutine printme\n\nelemental function compact(str,charp) result (outstr)\n\ncharacter(len=*),intent(in)  :: str\ncharacter(len=1),intent(in)  :: charp\ncharacter(len=:),allocatable :: outstr\ncharacter(len=1)             :: ch, last_one\ninteger                      :: i, pio \n\n   outstr=repeat(' ',len(str))      \n   if(len(outstr)==0)return         \n   last_one=str(1:1)                \n   outstr(1:1)=last_one\n   pio=1\n\n   do i=2,len(str)\n      ch=str(i:i)\n      pio=pio+merge(0,1, ch.eq.last_one.and.ch.eq.charp) \n      outstr(pio:pio)=ch  \n      last_one=ch\n   enddo\n\n   outstr=outstr(:pio)              \nend function compact\n\nend program main\n}\n", "target": "from itertools import groupby\n\ndef squeezer(s, txt):\n    return ''.join(item if item == s else ''.join(grp)\n                   for item, grp in groupby(txt))\n\nif __name__ == '__main__':\n    strings = [\n            \"\",\n            '\"If I were two-faced, would I be wearing this one?\" --- Abraham Lincoln ',\n            \"..1111111111111111111111111111111111111111111111111111111111111117777888\",\n            \"I never give 'em hell, I just tell the truth, and they think it's hell. \",\n            \"                                                   ---  Harry S Truman  \",\n            \"The better the 4-wheel drive, the further you'll be from help when ya get stuck!\",\n            \"headmistressship\",\n            \"aardvark\",\n            \"\ud83d\ude0d\ud83d\ude00\ud83d\ude4c\ud83d\udc83\ud83d\ude0d\ud83d\ude0d\ud83d\ude0d\ud83d\ude4c\",\n            ]\n    squeezers = ' ,-,7,., -r,e,s,a,\ud83d\ude0d'.split(',')\n    for txt, chars in zip(strings, squeezers):\n        this = \"Original\"\n        print(f\"\\n{this:14} Size: {len(txt)} \u00ab\u00ab\u00ab{txt}\u00bb\u00bb\u00bb\" )\n        for ch in chars:\n            this = f\"Squeezer '{ch}'\"\n            sqz = squeezer(ch, txt)\n            print(f\"{this:>14} Size: {len(sqz)} \u00ab\u00ab\u00ab{sqz}\u00bb\u00bb\u00bb\" )\n"}
{"id": 14467, "name": "Create a file", "source": "Translate Fortran to C#: PROGRAM CREATION\nOPEN (UNIT=5, FILE=\"output.txt\", STATUS=\"NEW\")   \nCLOSE (UNIT=5)\nOPEN (UNIT=5, FILE=\"/output.txt\", STATUS=\"NEW\")  \nCLOSE (UNIT=5)\n\n\n\ncall system(\"mkdir docs/\")\ncall system(\"mkdir ~/docs/\")\n\nEND PROGRAM\n", "target": "using System;\nusing System.IO;\n\nclass Program {\n    static void Main(string[] args) {\n        File.Create(\"output.txt\");\n        File.Create(@\"\\output.txt\");\n\n        Directory.CreateDirectory(\"docs\");\n        Directory.CreateDirectory(@\"\\docs\");\n    }\n}\n"}
{"id": 14470, "name": "Create a file", "source": "Translate Fortran to Java: PROGRAM CREATION\nOPEN (UNIT=5, FILE=\"output.txt\", STATUS=\"NEW\")   \nCLOSE (UNIT=5)\nOPEN (UNIT=5, FILE=\"/output.txt\", STATUS=\"NEW\")  \nCLOSE (UNIT=5)\n\n\n\ncall system(\"mkdir docs/\")\ncall system(\"mkdir ~/docs/\")\n\nEND PROGRAM\n", "target": "import java.io.*;\npublic class CreateFileTest {\n\tpublic static void main(String args[]) {\n\t\ttry {\n\t\t\tnew File(\"output.txt\").createNewFile();\n\t\t\tnew File(File.separator + \"output.txt\").createNewFile();\n\t\t\tnew File(\"docs\").mkdir();\n\t\t\tnew File(File.separator + \"docs\").mkdir();\n\t\t} catch (IOException e) {\n\t\t\tSystem.err.println(e.getMessage());\n\t\t}\n\t}\n}\n"}
{"id": 14471, "name": "Create a file", "source": "Translate Fortran to Python: PROGRAM CREATION\nOPEN (UNIT=5, FILE=\"output.txt\", STATUS=\"NEW\")   \nCLOSE (UNIT=5)\nOPEN (UNIT=5, FILE=\"/output.txt\", STATUS=\"NEW\")  \nCLOSE (UNIT=5)\n\n\n\ncall system(\"mkdir docs/\")\ncall system(\"mkdir ~/docs/\")\n\nEND PROGRAM\n", "target": "import os\nfor directory in ['/', './']:\n  open(directory + 'output.txt', 'w').close()  \n  os.mkdir(directory + 'docs')                 \n"}
{"id": 14696, "name": "Cholesky decomposition", "source": "Translate Fortran to C#: Program Cholesky_decomp\n\n\n\n\n\n\n\n\n\nimplicit none\n\nINTEGER, PARAMETER :: m=3 \nINTEGER, PARAMETER :: n=3 \nCOMPLEX, DIMENSION(m,n) :: A \nREAL, DIMENSION(m,n) :: L\nREAL :: sum1, sum2\nINTEGER i,j,k\n\n\nA(1,:)=(/ 25,  15,  -5 /)   \nA(2,:)=(/ 15,  18,   0 /)  \nA(3,:)=(/ -5,   0,  11 /)\n\n\n\n\n\n\n\n\n\n\n\nL(1,1)=real(sqrt(A(1,1)))\nL(2,1)=A(2,1)/L(1,1)\nL(2,2)=real(sqrt(A(2,2)-L(2,1)*L(2,1)))\nL(3,1)=A(3,1)/L(1,1)\n\n\n\n\n\n\n\n\ndo i=1,n\n    do k=1,i\n        sum1=0\n        sum2=0\n        do j=1,k-1\n        if (i==k) then\n            sum1=sum1+(L(k,j)*L(k,j))\n            L(k,k)=real(sqrt(A(k,k)-sum1))  \n        elseif (i > k) then\n            sum2=sum2+(L(i,j)*L(k,j))\n            L(i,k)=(1/L(k,k))*(A(i,k)-sum2)\n        else\n            L(i,k)=0\n        end if\n        end do\n    end do\nend do\n\n\ndo i=1,m\n    print \"(3(1X,F6.1))\",L(i,:)\nend do\n\nEnd program Cholesky_decomp\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\nnamespace Cholesky\n{\n    class Program\n    {\n        \n        \n        \n        \n        static void Main(string[] args)\n        {\n            double[,] test1 = new double[,]\n            {\n                {25, 15, -5},\n                {15, 18, 0},\n                {-5, 0, 11},\n            };\n\n            double[,] test2 = new double[,]\n            {\n                {18, 22, 54, 42},\n                {22, 70, 86, 62},\n                {54, 86, 174, 134},\n                {42, 62, 134, 106},\n            };\n\n            double[,] chol1 = Cholesky(test1);\n            double[,] chol2 = Cholesky(test2);\n\n            Console.WriteLine(\"Test 1: \");\n            Print(test1);\n            Console.WriteLine(\"\");\n            Console.WriteLine(\"Lower Cholesky 1: \");\n            Print(chol1);\n            Console.WriteLine(\"\");\n            Console.WriteLine(\"Test 2: \");\n            Print(test2);\n            Console.WriteLine(\"\");\n            Console.WriteLine(\"Lower Cholesky 2: \");\n            Print(chol2);\n\n        }\n\n        public static void Print(double[,] a)\n        {\n            int n = (int)Math.Sqrt(a.Length);\n\n            StringBuilder sb = new StringBuilder();\n            for (int r = 0; r < n; r++)\n            {\n                string s = \"\";\n                for (int c = 0; c < n; c++)\n                {\n                    s += a[r, c].ToString(\"f5\").PadLeft(9) + \",\";\n                }\n                sb.AppendLine(s);\n            }\n\n            Console.WriteLine(sb.ToString());\n        }\n\n        \n        \n        \n        \n        \n        \n        \n        \n        public static double[,] Cholesky(double[,] a)\n        {\n            int n = (int)Math.Sqrt(a.Length);\n\n            double[,] ret = new double[n, n];\n            for (int r = 0; r < n; r++)\n                for (int c = 0; c <= r; c++)\n                {\n                    if (c == r)\n                    {\n                        double sum = 0;\n                        for (int j = 0; j < c; j++)\n                        {\n                            sum += ret[c, j] * ret[c, j];\n                        }\n                        ret[c, c] = Math.Sqrt(a[c, c] - sum);\n                    }\n                    else\n                    {\n                        double sum = 0;\n                        for (int j = 0; j < c; j++)\n                            sum += ret[r, j] * ret[c, j];\n                        ret[r, c] = 1.0 / ret[c, c] * (a[r, c] - sum);\n                    }\n                }\n\n            return ret;\n        }\n    }\n}\n"}
{"id": 14699, "name": "Cholesky decomposition", "source": "Translate Fortran to Java: Program Cholesky_decomp\n\n\n\n\n\n\n\n\n\nimplicit none\n\nINTEGER, PARAMETER :: m=3 \nINTEGER, PARAMETER :: n=3 \nCOMPLEX, DIMENSION(m,n) :: A \nREAL, DIMENSION(m,n) :: L\nREAL :: sum1, sum2\nINTEGER i,j,k\n\n\nA(1,:)=(/ 25,  15,  -5 /)   \nA(2,:)=(/ 15,  18,   0 /)  \nA(3,:)=(/ -5,   0,  11 /)\n\n\n\n\n\n\n\n\n\n\n\nL(1,1)=real(sqrt(A(1,1)))\nL(2,1)=A(2,1)/L(1,1)\nL(2,2)=real(sqrt(A(2,2)-L(2,1)*L(2,1)))\nL(3,1)=A(3,1)/L(1,1)\n\n\n\n\n\n\n\n\ndo i=1,n\n    do k=1,i\n        sum1=0\n        sum2=0\n        do j=1,k-1\n        if (i==k) then\n            sum1=sum1+(L(k,j)*L(k,j))\n            L(k,k)=real(sqrt(A(k,k)-sum1))  \n        elseif (i > k) then\n            sum2=sum2+(L(i,j)*L(k,j))\n            L(i,k)=(1/L(k,k))*(A(i,k)-sum2)\n        else\n            L(i,k)=0\n        end if\n        end do\n    end do\nend do\n\n\ndo i=1,m\n    print \"(3(1X,F6.1))\",L(i,:)\nend do\n\nEnd program Cholesky_decomp\n", "target": "import java.util.Arrays;\n\npublic class Cholesky {\n\tpublic static double[][] chol(double[][] a){\n\t\tint m = a.length;\n\t\tdouble[][] l = new double[m][m]; \n\t\tfor(int i = 0; i< m;i++){\n\t\t\tfor(int k = 0; k < (i+1); k++){\n\t\t\t\tdouble sum = 0;\n\t\t\t\tfor(int j = 0; j < k; j++){\n\t\t\t\t\tsum += l[i][j] * l[k][j];\n\t\t\t\t}\n\t\t\t\tl[i][k] = (i == k) ? Math.sqrt(a[i][i] - sum) :\n\t\t\t\t\t(1.0 / l[k][k] * (a[i][k] - sum));\n\t\t\t}\n\t\t}\n\t\treturn l;\n\t}\n\t\n\tpublic static void main(String[] args){\n\t\tdouble[][] test1 = {{25, 15, -5},\n\t\t\t\t\t\t\t{15, 18, 0},\n\t\t\t\t\t\t\t{-5, 0, 11}};\n\t\tSystem.out.println(Arrays.deepToString(chol(test1)));\n\t\tdouble[][] test2 = {{18, 22, 54, 42},\n\t\t\t\t\t\t\t{22, 70, 86, 62},\n\t\t\t\t\t\t\t{54, 86, 174, 134},\n\t\t\t\t\t\t\t{42, 62, 134, 106}};\n\t\tSystem.out.println(Arrays.deepToString(chol(test2)));\n\t}\n}\n"}
{"id": 14700, "name": "Cholesky decomposition", "source": "Translate Fortran to Python: Program Cholesky_decomp\n\n\n\n\n\n\n\n\n\nimplicit none\n\nINTEGER, PARAMETER :: m=3 \nINTEGER, PARAMETER :: n=3 \nCOMPLEX, DIMENSION(m,n) :: A \nREAL, DIMENSION(m,n) :: L\nREAL :: sum1, sum2\nINTEGER i,j,k\n\n\nA(1,:)=(/ 25,  15,  -5 /)   \nA(2,:)=(/ 15,  18,   0 /)  \nA(3,:)=(/ -5,   0,  11 /)\n\n\n\n\n\n\n\n\n\n\n\nL(1,1)=real(sqrt(A(1,1)))\nL(2,1)=A(2,1)/L(1,1)\nL(2,2)=real(sqrt(A(2,2)-L(2,1)*L(2,1)))\nL(3,1)=A(3,1)/L(1,1)\n\n\n\n\n\n\n\n\ndo i=1,n\n    do k=1,i\n        sum1=0\n        sum2=0\n        do j=1,k-1\n        if (i==k) then\n            sum1=sum1+(L(k,j)*L(k,j))\n            L(k,k)=real(sqrt(A(k,k)-sum1))  \n        elseif (i > k) then\n            sum2=sum2+(L(i,j)*L(k,j))\n            L(i,k)=(1/L(k,k))*(A(i,k)-sum2)\n        else\n            L(i,k)=0\n        end if\n        end do\n    end do\nend do\n\n\ndo i=1,m\n    print \"(3(1X,F6.1))\",L(i,:)\nend do\n\nEnd program Cholesky_decomp\n", "target": "from __future__ import print_function\n\nfrom pprint import pprint\nfrom math import sqrt\n\n\ndef cholesky(A):\n    L = [[0.0] * len(A) for _ in xrange(len(A))]\n    for i in xrange(len(A)):\n        for j in xrange(i+1):\n            s = sum(L[i][k] * L[j][k] for k in xrange(j))\n            L[i][j] = sqrt(A[i][i] - s) if (i == j) else \\\n                      (1.0 / L[j][j] * (A[i][j] - s))\n    return L\n\nif __name__ == \"__main__\":\n    m1 = [[25, 15, -5],\n          [15, 18,  0],\n          [-5,  0, 11]]\n    pprint(cholesky(m1))\n    print()\n    \n    m2 = [[18, 22,  54,  42],\n          [22, 70,  86,  62],\n          [54, 86, 174, 134],\n          [42, 62, 134, 106]]\n    pprint(cholesky(m2), width=120)\n"}
{"id": 14924, "name": "Almost prime", "source": "Translate Fortran to C#: program almost_prime\n    use iso_fortran_env, only: output_unit\n    implicit none\n\n    integer :: i, c, k\n\n    do k = 1, 5\n        write(output_unit,'(A3,x,I0,x,A1,x)', advance=\"no\") \"k =\", k, \":\"\n        i = 2\n        c = 0\n        do\n            if (c >= 10) exit\n\n            if (kprime(i, k)) then\n                write(output_unit,'(I0,x)', advance=\"no\") i\n                c = c + 1\n            end if\n            i = i + 1\n        end do\n        write(output_unit,*)\n    end do\ncontains\n    pure function kprime(n, k)\n        integer, intent(in) :: n, k\n        logical             :: kprime\n        integer             :: p, f, i\n\n        kprime = .false.\n\n        f = 0\n        i = n\n\n        do p = 2, n\n            do\n                if (modulo(i, p) /= 0) exit\n\n                if (f == k) return\n                f = f + 1\n                i = i / p\n            end do\n        end do\n\n        kprime = f==k\n    end function kprime\nend program almost_prime\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\nnamespace AlmostPrime\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            foreach (int k in Enumerable.Range(1, 5))\n            {\n                KPrime kprime = new KPrime() { K = k };\n                Console.WriteLine(\"k = {0}: {1}\",\n                    k, string.Join<int>(\" \", kprime.GetFirstN(10)));\n            }\n        }\n    }\n\n    class KPrime\n    {\n        public int K { get; set; }\n\n        public bool IsKPrime(int number)\n        {\n            int primes = 0;\n            for (int p = 2; p * p <= number && primes < K; ++p)\n            {\n                while (number % p == 0 && primes < K)\n                {\n                    number /= p;\n                    ++primes;\n                }\n            }\n            if (number > 1)\n            {\n                ++primes;\n            }\n            return primes == K;\n        }\n\n        public List<int> GetFirstN(int n)\n        {\n            List<int> result = new List<int>();\n            for (int number = 2; result.Count < n; ++number)\n            {\n                if (IsKPrime(number))\n                {\n                    result.Add(number);\n                }\n            }\n            return result;\n        }\n    }\n}\n"}
{"id": 14928, "name": "Almost prime", "source": "Translate Fortran to Java: program almost_prime\n    use iso_fortran_env, only: output_unit\n    implicit none\n\n    integer :: i, c, k\n\n    do k = 1, 5\n        write(output_unit,'(A3,x,I0,x,A1,x)', advance=\"no\") \"k =\", k, \":\"\n        i = 2\n        c = 0\n        do\n            if (c >= 10) exit\n\n            if (kprime(i, k)) then\n                write(output_unit,'(I0,x)', advance=\"no\") i\n                c = c + 1\n            end if\n            i = i + 1\n        end do\n        write(output_unit,*)\n    end do\ncontains\n    pure function kprime(n, k)\n        integer, intent(in) :: n, k\n        logical             :: kprime\n        integer             :: p, f, i\n\n        kprime = .false.\n\n        f = 0\n        i = n\n\n        do p = 2, n\n            do\n                if (modulo(i, p) /= 0) exit\n\n                if (f == k) return\n                f = f + 1\n                i = i / p\n            end do\n        end do\n\n        kprime = f==k\n    end function kprime\nend program almost_prime\n", "target": "public class AlmostPrime {\n    public static void main(String[] args) {\n        for (int k = 1; k <= 5; k++) {\n            System.out.print(\"k = \" + k + \":\");\n\n            for (int i = 2, c = 0; c < 10; i++) {\n                if (kprime(i, k)) {\n                    System.out.print(\" \" + i);\n                    c++;\n                }\n            }\n\n            System.out.println(\"\");\n        }\n    }\n\n    public static boolean kprime(int n, int k) {\n        int f = 0;\n        for (int p = 2; f < k && p * p <= n; p++) {\n            while (n % p == 0) {\n                n /= p;\n                f++;\n            }\n        }\n        return f + ((n > 1) ? 1 : 0) == k;\n    }\n}\n"}
{"id": 14929, "name": "Almost prime", "source": "Translate Fortran to Python: program almost_prime\n    use iso_fortran_env, only: output_unit\n    implicit none\n\n    integer :: i, c, k\n\n    do k = 1, 5\n        write(output_unit,'(A3,x,I0,x,A1,x)', advance=\"no\") \"k =\", k, \":\"\n        i = 2\n        c = 0\n        do\n            if (c >= 10) exit\n\n            if (kprime(i, k)) then\n                write(output_unit,'(I0,x)', advance=\"no\") i\n                c = c + 1\n            end if\n            i = i + 1\n        end do\n        write(output_unit,*)\n    end do\ncontains\n    pure function kprime(n, k)\n        integer, intent(in) :: n, k\n        logical             :: kprime\n        integer             :: p, f, i\n\n        kprime = .false.\n\n        f = 0\n        i = n\n\n        do p = 2, n\n            do\n                if (modulo(i, p) /= 0) exit\n\n                if (f == k) return\n                f = f + 1\n                i = i / p\n            end do\n        end do\n\n        kprime = f==k\n    end function kprime\nend program almost_prime\n", "target": "from prime_decomposition import decompose\nfrom itertools import islice, count\ntry: \n    from functools import reduce\nexcept: \n    pass\n\n\ndef almostprime(n, k=2):\n    d = decompose(n)\n    try:\n        terms = [next(d) for i in range(k)]\n        return reduce(int.__mul__, terms, 1) == n\n    except:\n        return False\n\nif __name__ == '__main__':\n    for k in range(1,6):\n        print('%i: %r' % (k, list(islice((n for n in count() if almostprime(n, k)), 10))))\n"}
{"id": 15178, "name": "Integer comparison", "source": "Translate Fortran to C#: program arithif\ninteger a, b\n\nc        fortran 77 I/O statements, for simplicity\nread(*,*) a, b\n\nif ( a - b ) 10, 20, 30\n10 write(*,*) a, ' is less than ', b\n   goto 40\n\n20 write(*,*) a, ' is equal to ', b\n   goto 40\n\n30 write(*,*) a, ' is greater than ', b\n40 continue\n\nend\n", "target": "using System;\n\nclass Program\n{\n    static void Main()\n    {\n        int a = int.Parse(Console.ReadLine());\n        int b = int.Parse(Console.ReadLine());\n        if (a < b)\n            Console.WriteLine(\"{0} is less than {1}\", a, b);\n        if (a == b)\n            Console.WriteLine(\"{0} equals {1}\", a, b);\n        if (a > b)\n            Console.WriteLine(\"{0} is greater than {1}\", a, b);\n    }\n}\n"}
{"id": 15181, "name": "Integer comparison", "source": "Translate Fortran to Java: program arithif\ninteger a, b\n\nc        fortran 77 I/O statements, for simplicity\nread(*,*) a, b\n\nif ( a - b ) 10, 20, 30\n10 write(*,*) a, ' is less than ', b\n   goto 40\n\n20 write(*,*) a, ' is equal to ', b\n   goto 40\n\n30 write(*,*) a, ' is greater than ', b\n40 continue\n\nend\n", "target": "import java.io.*;\n\npublic class compInt {\n   public static void main(String[] args) {\n       try {\n           BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n\n           int nbr1 = Integer.parseInt(in.readLine());\n           int nbr2 = Integer.parseInt(in.readLine());\n\n           if(nbr1<nbr2)\n               System.out.println(nbr1 + \" is less than \" + nbr2);\n\n           if(nbr1>nbr2)\n                System.out.println(nbr1 + \" is greater than \" + nbr2);\n\n           if(nbr1==nbr2)\n                System.out.println(nbr1 + \" is equal to \" + nbr2);\n       } catch(IOException e) { }\n   }\n}\n"}
{"id": 15182, "name": "Integer comparison", "source": "Translate Fortran to Python: program arithif\ninteger a, b\n\nc        fortran 77 I/O statements, for simplicity\nread(*,*) a, b\n\nif ( a - b ) 10, 20, 30\n10 write(*,*) a, ' is less than ', b\n   goto 40\n\n20 write(*,*) a, ' is equal to ', b\n   goto 40\n\n30 write(*,*) a, ' is greater than ', b\n40 continue\n\nend\n", "target": "let a = input('Enter value of a: ')\nlet b = input('Enter value of b: ')\n\nif a < b:\n    print 'a is less than b'\nelif a > b:\n    print 'a is greater than b'\nelif a == b:\n    print 'a is equal to b'\n"}
{"id": 15434, "name": "Environment variables", "source": "Translate Fortran to C#: program show_home\nimplicit none\ncharacter(len=32) :: home_val  \ninteger           :: home_len  \ninteger           :: stat      \n                               \n                               \n                               \ncall get_environment_variable('HOME', home_val, home_len, stat)\nif (stat == 0) then\n    write(*,'(a)') 'HOME = '//trim(home_val)\nelse\n    write(*,'(a)') 'No HOME to go to\nend if\nend program show_home\n", "target": "using System;\n\nnamespace RosettaCode {\n    class Program {\n        static void Main() {\n            string temp = Environment.GetEnvironmentVariable(\"TEMP\");\n            Console.WriteLine(\"TEMP is \" + temp);\n        }\n    }\n}\n"}
{"id": 15438, "name": "Environment variables", "source": "Translate Fortran to Java: program show_home\nimplicit none\ncharacter(len=32) :: home_val  \ninteger           :: home_len  \ninteger           :: stat      \n                               \n                               \n                               \ncall get_environment_variable('HOME', home_val, home_len, stat)\nif (stat == 0) then\n    write(*,'(a)') 'HOME = '//trim(home_val)\nelse\n    write(*,'(a)') 'No HOME to go to\nend if\nend program show_home\n", "target": "System.getenv(\"HOME\") \nSystem.getenv()       \n"}
{"id": 15439, "name": "Environment variables", "source": "Translate Fortran to Python: program show_home\nimplicit none\ncharacter(len=32) :: home_val  \ninteger           :: home_len  \ninteger           :: stat      \n                               \n                               \n                               \ncall get_environment_variable('HOME', home_val, home_len, stat)\nif (stat == 0) then\n    write(*,'(a)') 'HOME = '//trim(home_val)\nelse\n    write(*,'(a)') 'No HOME to go to\nend if\nend program show_home\n", "target": "import os\nos.environ['HOME']\n"}
{"id": 15635, "name": "Substring", "source": "Translate Fortran to C#: program test_substring\n\n  character (*), parameter :: string = 'The quick brown fox jumps over the lazy dog.'\n  character (*), parameter :: substring = 'brown'\n  character    , parameter :: c = 'q'\n  integer      , parameter :: n = 5\n  integer      , parameter :: m = 15\n  integer                  :: i\n\n\n  write (*, '(a)') string (n : n + m - 1)\n\n  write (*, '(a)') string (n :)\n\n  i = len (string) - 1\n  write (*, '(a)') string (: i)\n\n  i = index (string, c)\n  write (*, '(a)') string (i : i + m - 1)\n\n  i = index (string, substring)\n  write (*, '(a)') string (i : i + m - 1)\n\nend program test_substring\n", "target": "using System;\nnamespace SubString\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            string s = \"0123456789\";\n            const int n = 3;\n            const int m = 2;\n            const char c = '3';\n            const string z = \"345\";\n\n            \n            Console.WriteLine(s.Substring(n, m));\n            \n            Console.WriteLine(s.Substring(n, s.Length - n));\n            \n            Console.WriteLine(s.Substring(0, s.Length - 1));\n            \n            Console.WriteLine(s.Substring(s.IndexOf(c), m));\n            \n            Console.WriteLine(s.Substring(s.IndexOf(z), m));\n        }\n    }\n}\n"}
{"id": 15639, "name": "Substring", "source": "Translate Fortran to Java: program test_substring\n\n  character (*), parameter :: string = 'The quick brown fox jumps over the lazy dog.'\n  character (*), parameter :: substring = 'brown'\n  character    , parameter :: c = 'q'\n  integer      , parameter :: n = 5\n  integer      , parameter :: m = 15\n  integer                  :: i\n\n\n  write (*, '(a)') string (n : n + m - 1)\n\n  write (*, '(a)') string (n :)\n\n  i = len (string) - 1\n  write (*, '(a)') string (: i)\n\n  i = index (string, c)\n  write (*, '(a)') string (i : i + m - 1)\n\n  i = index (string, substring)\n  write (*, '(a)') string (i : i + m - 1)\n\nend program test_substring\n", "target": "public static String Substring(String str, int n, int m){\n    return str.substring(n, n+m);\n}\npublic static String Substring(String str, int n){\n    return str.substring(n);\n}\npublic static String Substring(String str){\n    return str.substring(0, str.length()-1);\n}\npublic static String Substring(String str, char c, int m){\n    return str.substring(str.indexOf(c), str.indexOf(c)+m+1);\n}\npublic static String Substring(String str, String sub, int m){\n    return str.substring(str.indexOf(sub), str.indexOf(sub)+m+1);\n}\n"}
{"id": 15640, "name": "Substring", "source": "Translate Fortran to Python: program test_substring\n\n  character (*), parameter :: string = 'The quick brown fox jumps over the lazy dog.'\n  character (*), parameter :: substring = 'brown'\n  character    , parameter :: c = 'q'\n  integer      , parameter :: n = 5\n  integer      , parameter :: m = 15\n  integer                  :: i\n\n\n  write (*, '(a)') string (n : n + m - 1)\n\n  write (*, '(a)') string (n :)\n\n  i = len (string) - 1\n  write (*, '(a)') string (: i)\n\n  i = index (string, c)\n  write (*, '(a)') string (i : i + m - 1)\n\n  i = index (string, substring)\n  write (*, '(a)') string (i : i + m - 1)\n\nend program test_substring\n", "target": ">>> s = 'abcdefgh'\n>>> n, m, char, chars = 2, 3, 'd', 'cd'\n>>> \n>>> s[n-1:n+m-1]\n'bcd'\n>>> \n>>> s[n-1:]\n'bcdefgh'\n>>> \n>>> s[:-1]\n'abcdefg'\n>>> \n>>> indx = s.index(char)\n>>> s[indx:indx+m]\n'def'\n>>> \n>>> indx = s.index(chars)\n>>> s[indx:indx+m]\n'cde'\n>>>\n"}
{"id": 15926, "name": "Evaluate binomial coefficients", "source": "Translate Fortran to C#: program test_choose\n\n  implicit none\n\n  write (*, '(i0)') choose (5, 3)\n\ncontains\n\n  function factorial (n) result (res)\n\n    implicit none\n    integer, intent (in) :: n\n    integer :: res\n    integer :: i\n\n    res = product ((/(i, i = 1, n)/))\n\n  end function factorial\n\n  function choose (n, k) result (res)\n\n    implicit none\n    integer, intent (in) :: n\n    integer, intent (in) :: k\n    integer :: res\n\n    res = factorial (n) / (factorial (k) * factorial (n - k))\n\n  end function choose\n\nend program test_choose\n", "target": "using System;\n\nnamespace BinomialCoefficients\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            ulong n = 1000000, k = 3;\n            ulong result = biCoefficient(n, k);\n            Console.WriteLine(\"The Binomial Coefficient of {0}, and {1}, is equal to: {2}\", n, k, result);\n            Console.ReadLine();\n        }\n\n        static int fact(int n)\n        {\n            if (n == 0) return 1;\n            else return n * fact(n - 1);\n        }\n\n        static ulong biCoefficient(ulong n, ulong k)\n        {\n            if (k > n - k)\n            {\n                k = n - k;\n            }\n\n            ulong c = 1;\n            for (uint i = 0; i < k; i++)\n            {\n                c = c * (n - i);\n                c = c / (i + 1);\n            }\n            return c;\n        }\n    }\n}\n"}
{"id": 15930, "name": "Evaluate binomial coefficients", "source": "Translate Fortran to Java: program test_choose\n\n  implicit none\n\n  write (*, '(i0)') choose (5, 3)\n\ncontains\n\n  function factorial (n) result (res)\n\n    implicit none\n    integer, intent (in) :: n\n    integer :: res\n    integer :: i\n\n    res = product ((/(i, i = 1, n)/))\n\n  end function factorial\n\n  function choose (n, k) result (res)\n\n    implicit none\n    integer, intent (in) :: n\n    integer, intent (in) :: k\n    integer :: res\n\n    res = factorial (n) / (factorial (k) * factorial (n - k))\n\n  end function choose\n\nend program test_choose\n", "target": "public class Binomial {\n\n    \n    private static long binomialInt(int n, int k) {\n        if (k > n - k)\n            k = n - k;\n\n        long binom = 1;\n        for (int i = 1; i <= k; i++)\n            binom = binom * (n + 1 - i) / i;\n        return binom;\n    }\n\n    \n    private static Object binomialIntReliable(int n, int k) {\n        if (k > n - k)\n            k = n - k;\n\n        long binom = 1;\n        for (int i = 1; i <= k; i++) {\n            try {\n                binom = Math.multiplyExact(binom, n + 1 - i) / i;\n            } catch (ArithmeticException e) {\n                return \"overflow\";\n            }\n        }\n        return binom;\n    }\n\n    \n    \n    private static double binomialFloat(int n, int k) {\n        if (k > n - k)\n            k = n - k;\n\n        double binom = 1.0;\n        for (int i = 1; i <= k; i++)\n            binom = binom * (n + 1 - i) / i;\n        return binom;\n    }\n\n    \n    private static BigInteger binomialBigInt(int n, int k) {\n        if (k > n - k)\n            k = n - k;\n\n        BigInteger binom = BigInteger.ONE;\n        for (int i = 1; i <= k; i++) {\n            binom = binom.multiply(BigInteger.valueOf(n + 1 - i));\n            binom = binom.divide(BigInteger.valueOf(i));\n        }\n        return binom;\n    }\n\n    private static void demo(int n, int k) {\n        List<Object> data = Arrays.asList(\n                n,\n                k,\n                binomialInt(n, k),\n                binomialIntReliable(n, k),\n                binomialFloat(n, k),\n                binomialBigInt(n, k));\n\n        System.out.println(data.stream().map(Object::toString).collect(Collectors.joining(\"\\t\")));\n    }\n\n    public static void main(String[] args) {\n        demo(5, 3);\n        demo(1000, 300);\n    }\n}\n"}
{"id": 15931, "name": "Evaluate binomial coefficients", "source": "Translate Fortran to Python: program test_choose\n\n  implicit none\n\n  write (*, '(i0)') choose (5, 3)\n\ncontains\n\n  function factorial (n) result (res)\n\n    implicit none\n    integer, intent (in) :: n\n    integer :: res\n    integer :: i\n\n    res = product ((/(i, i = 1, n)/))\n\n  end function factorial\n\n  function choose (n, k) result (res)\n\n    implicit none\n    integer, intent (in) :: n\n    integer, intent (in) :: k\n    integer :: res\n\n    res = factorial (n) / (factorial (k) * factorial (n - k))\n\n  end function choose\n\nend program test_choose\n", "target": "def binomialCoeff(n, k):\n    result = 1\n    for i in range(1, k+1):\n        result = result * (n-i+1) / i\n    return result\n\nif __name__ == \"__main__\":\n    print(binomialCoeff(5, 3))\n"}
{"id": 16151, "name": "Append a record to the end of a text file", "source": "Translate Fortran to C#:       PROGRAM DEMO\t\n      TYPE DETAILS\t\t\n       CHARACTER*28 FULLNAME\n       CHARACTER*12 OFFICE\n       CHARACTER*16 EXTENSION\n       CHARACTER*16 HOMEPHONE\n       CHARACTER*88 EMAIL\n      END TYPE DETAILS\n      TYPE USERSTUFF\t\t\n       CHARACTER*8 ACCOUNT\n       CHARACTER*8 PASSWORD\t\n       INTEGER*2 UID\n       INTEGER*2 GID\n       TYPE(DETAILS) PERSON\n       CHARACTER*18 DIRECTORY\n       CHARACTER*12 SHELL\n      END TYPE USERSTUFF\n      TYPE(USERSTUFF) NOTE\t\n      NAMELIST /STUFF/ NOTE\t\n      INTEGER F,MSG,N\n      MSG = 6\t\n      F = 10\t\n      OPEN(MSG, DELIM = \"QUOTE\")\t\n\nCreate the file and supply its initial content.\n      OPEN (F, FILE=\"Staff.txt\",STATUS=\"REPLACE\",ACTION=\"WRITE\",\n     1 DELIM=\"QUOTE\",RECL=666)\t\n\n      WRITE (F,*) USERSTUFF(\"jsmith\",\"x\",1001,1000,\n     1 DETAILS(\"Joe Smith\",\"Room 1007\",\"(234)555-8917\",\n     2  \"(234)555-0077\",\"jsmith@rosettacode.org\"),\n     2 \"/home/jsmith\",\"/bin/bash\")\n\n      WRITE (F,*) USERSTUFF(\"jdoe\",\"x\",1002,1000,\n     1 DETAILS(\"Jane Doe\",\"Room 1004\",\"(234)555-8914\",\n     2  \"(234)555-0044\",\"jdoe@rosettacode.org\"),\n     3 \"home/jdoe\",\"/bin/bash\")\n      CLOSE (F)\t\t\n\nChoose the existing file, and append a further record to it.\n      OPEN (F, FILE=\"Staff.txt\",STATUS=\"OLD\",ACTION=\"WRITE\",\n     1 DELIM=\"QUOTE\",RECL=666,ACCESS=\"APPEND\")\n\n      NOTE = USERSTUFF(\"xyz\",\"x\",1003,1000,\t\t\n     1 DETAILS(\"X Yz\",\"Room 1003\",\"(234)555-8193\",\n     2  \"(234)555-033\",\"xyz@rosettacode.org\"),\n     3 \"/home/xyz\",\"/bin/bash\")\n      WRITE (F,*) NOTE\t\t\t\t\t\n      CLOSE (F)\n\nChase through the file, revealing what had been written..\n      OPEN (F, FILE=\"Staff.txt\",STATUS=\"OLD\",ACTION=\"READ\",\n     1 DELIM=\"QUOTE\",RECL=666)\n      N = 0\n   10 READ (F,*,END = 20) NOTE\t\n      N = N + 1\t\t\t\n      WRITE (MSG,11) N\t\t\n   11 FORMAT (/,\"Record \",I0)\t\n      WRITE (MSG,STUFF)\t\t\n      GO TO 10\t\t\t\n\nClosedown.\n   20 CLOSE (F)\n      END\n", "target": "using System;\nusing System.IO;\n\nnamespace AppendPwdRosetta\n{\n    class PasswordRecord\n    {\n        public string account, password, fullname, office, extension, homephone, email, directory, shell;\n        public int UID, GID;\n        public PasswordRecord(string account, string password, int UID, int GID, string fullname, string office, string extension, string homephone, \n            string email, string directory, string shell)\n        {\n            this.account = account; this.password = password; this.UID = UID; this.GID = GID; this.fullname = fullname; this.office = office;\n            this.extension = extension; this.homephone = homephone; this.email = email; this.directory = directory; this.shell = shell;\n        }\n        public override string ToString()\n        {\n            var gecos = string.Join(\",\", new string[] { fullname, office, extension, homephone, email });\n            return string.Join(\":\", new string[] { account, password, UID.ToString(), GID.ToString(), gecos, directory, shell });\n        }\n    }\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            var jsmith = new PasswordRecord(\"jsmith\", \"x\", 1001, 1000, \"Joe Smith\", \"Room 1007\", \"(234)555-8917\", \"(234)555-0077\", \"jsmith@rosettacode.org\", \n                \"/home/jsmith\", \"/bin/bash\");\n            var jdoe = new PasswordRecord(\"jdoe\", \"x\", 1002, 1000, \"Jane Doe\", \"Room 1004\", \"(234)555-8914\", \"(234)555-0044\", \"jdoe@rosettacode.org\", \"/home/jdoe\", \n                \"/bin/bash\");\n            var xyz = new PasswordRecord(\"xyz\", \"x\", 1003, 1000, \"X Yz\", \"Room 1003\", \"(234)555-8913\", \"(234)555-0033\", \"xyz@rosettacode.org\", \"/home/xyz\", \"/bin/bash\");\n\n            \n            File.WriteAllLines(\"passwd.txt\", new string[] { jsmith.ToString(), jdoe.ToString() });\n\n            \n            File.AppendAllText(\"passwd.txt\", xyz.ToString());\n\n            \n            string[] lines = File.ReadAllLines(\"passwd.txt\");\n            Console.WriteLine(\"Appended record: \" + lines[2]);\n        }\n    }\n}\n"}
{"id": 16154, "name": "Append a record to the end of a text file", "source": "Translate Fortran to Java:       PROGRAM DEMO\t\n      TYPE DETAILS\t\t\n       CHARACTER*28 FULLNAME\n       CHARACTER*12 OFFICE\n       CHARACTER*16 EXTENSION\n       CHARACTER*16 HOMEPHONE\n       CHARACTER*88 EMAIL\n      END TYPE DETAILS\n      TYPE USERSTUFF\t\t\n       CHARACTER*8 ACCOUNT\n       CHARACTER*8 PASSWORD\t\n       INTEGER*2 UID\n       INTEGER*2 GID\n       TYPE(DETAILS) PERSON\n       CHARACTER*18 DIRECTORY\n       CHARACTER*12 SHELL\n      END TYPE USERSTUFF\n      TYPE(USERSTUFF) NOTE\t\n      NAMELIST /STUFF/ NOTE\t\n      INTEGER F,MSG,N\n      MSG = 6\t\n      F = 10\t\n      OPEN(MSG, DELIM = \"QUOTE\")\t\n\nCreate the file and supply its initial content.\n      OPEN (F, FILE=\"Staff.txt\",STATUS=\"REPLACE\",ACTION=\"WRITE\",\n     1 DELIM=\"QUOTE\",RECL=666)\t\n\n      WRITE (F,*) USERSTUFF(\"jsmith\",\"x\",1001,1000,\n     1 DETAILS(\"Joe Smith\",\"Room 1007\",\"(234)555-8917\",\n     2  \"(234)555-0077\",\"jsmith@rosettacode.org\"),\n     2 \"/home/jsmith\",\"/bin/bash\")\n\n      WRITE (F,*) USERSTUFF(\"jdoe\",\"x\",1002,1000,\n     1 DETAILS(\"Jane Doe\",\"Room 1004\",\"(234)555-8914\",\n     2  \"(234)555-0044\",\"jdoe@rosettacode.org\"),\n     3 \"home/jdoe\",\"/bin/bash\")\n      CLOSE (F)\t\t\n\nChoose the existing file, and append a further record to it.\n      OPEN (F, FILE=\"Staff.txt\",STATUS=\"OLD\",ACTION=\"WRITE\",\n     1 DELIM=\"QUOTE\",RECL=666,ACCESS=\"APPEND\")\n\n      NOTE = USERSTUFF(\"xyz\",\"x\",1003,1000,\t\t\n     1 DETAILS(\"X Yz\",\"Room 1003\",\"(234)555-8193\",\n     2  \"(234)555-033\",\"xyz@rosettacode.org\"),\n     3 \"/home/xyz\",\"/bin/bash\")\n      WRITE (F,*) NOTE\t\t\t\t\t\n      CLOSE (F)\n\nChase through the file, revealing what had been written..\n      OPEN (F, FILE=\"Staff.txt\",STATUS=\"OLD\",ACTION=\"READ\",\n     1 DELIM=\"QUOTE\",RECL=666)\n      N = 0\n   10 READ (F,*,END = 20) NOTE\t\n      N = N + 1\t\t\t\n      WRITE (MSG,11) N\t\t\n   11 FORMAT (/,\"Record \",I0)\t\n      WRITE (MSG,STUFF)\t\t\n      GO TO 10\t\t\t\n\nClosedown.\n   20 CLOSE (F)\n      END\n", "target": "import static java.util.Objects.requireNonNull;\n\nimport java.io.IOException;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.nio.file.Paths;\nimport java.nio.file.StandardOpenOption;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.stream.Collectors;\nimport java.util.stream.Stream;\n\npublic class RecordAppender {\n    static class Record {\n        private final String account;\n        private final String password;\n        private final int uid;\n        private final int gid;\n        private final List<String> gecos;\n        private final String directory;\n        private final String shell;\n\n        public Record(String account, String password, int uid, int gid, List<String> gecos, String directory, String shell) {\n            this.account = requireNonNull(account);\n            this.password = requireNonNull(password);\n            this.uid = uid;\n            this.gid = gid;\n            this.gecos = requireNonNull(gecos);\n            this.directory = requireNonNull(directory);\n            this.shell = requireNonNull(shell);\n        }\n\n        @Override\n        public String toString() {\n            return account + ':' + password + ':' + uid + ':' + gid + ':' + String.join(\",\", gecos) + ':' + directory + ':' + shell;\n        }\n\n        public static Record parse(String text) {\n            String[] tokens = text.split(\":\");\n            return new Record(\n                    tokens[0],\n                    tokens[1],\n                    Integer.parseInt(tokens[2]),\n                    Integer.parseInt(tokens[3]),\n                    Arrays.asList(tokens[4].split(\",\")),\n                    tokens[5],\n                    tokens[6]);\n        }\n    }\n\n    public static void main(String[] args) throws IOException {\n        List<String> rawData = Arrays.asList(\n                \"jsmith:x:1001:1000:Joe Smith,Room 1007,(234)555-8917,(234)555-0077,[email protected]:/home/jsmith:/bin/bash\",\n                \"jdoe:x:1002:1000:Jane Doe,Room 1004,(234)555-8914,(234)555-0044,[email protected]:/home/jdoe:/bin/bash\",\n                \"xyz:x:1003:1000:X Yz,Room 1003,(234)555-8913,(234)555-0033,[email protected]:/home/xyz:/bin/bash\"\n        );\n\n        List<Record> records = rawData.stream().map(Record::parse).collect(Collectors.toList());\n\n        Path tmp = Paths.get(\"_rosetta\", \".passwd\");\n        Files.createDirectories(tmp.getParent());\n        Files.write(tmp, (Iterable<String>) records.stream().limit(2).map(Record::toString)::iterator);\n\n        Files.write(tmp, Collections.singletonList(records.get(2).toString()), StandardOpenOption.APPEND);\n\n        try (Stream<String> lines = Files.lines(tmp)) {\n            lines.map(Record::parse).forEach(System.out::println);\n        }\n    }\n}\n"}
{"id": 16155, "name": "Append a record to the end of a text file", "source": "Translate Fortran to Python:       PROGRAM DEMO\t\n      TYPE DETAILS\t\t\n       CHARACTER*28 FULLNAME\n       CHARACTER*12 OFFICE\n       CHARACTER*16 EXTENSION\n       CHARACTER*16 HOMEPHONE\n       CHARACTER*88 EMAIL\n      END TYPE DETAILS\n      TYPE USERSTUFF\t\t\n       CHARACTER*8 ACCOUNT\n       CHARACTER*8 PASSWORD\t\n       INTEGER*2 UID\n       INTEGER*2 GID\n       TYPE(DETAILS) PERSON\n       CHARACTER*18 DIRECTORY\n       CHARACTER*12 SHELL\n      END TYPE USERSTUFF\n      TYPE(USERSTUFF) NOTE\t\n      NAMELIST /STUFF/ NOTE\t\n      INTEGER F,MSG,N\n      MSG = 6\t\n      F = 10\t\n      OPEN(MSG, DELIM = \"QUOTE\")\t\n\nCreate the file and supply its initial content.\n      OPEN (F, FILE=\"Staff.txt\",STATUS=\"REPLACE\",ACTION=\"WRITE\",\n     1 DELIM=\"QUOTE\",RECL=666)\t\n\n      WRITE (F,*) USERSTUFF(\"jsmith\",\"x\",1001,1000,\n     1 DETAILS(\"Joe Smith\",\"Room 1007\",\"(234)555-8917\",\n     2  \"(234)555-0077\",\"jsmith@rosettacode.org\"),\n     2 \"/home/jsmith\",\"/bin/bash\")\n\n      WRITE (F,*) USERSTUFF(\"jdoe\",\"x\",1002,1000,\n     1 DETAILS(\"Jane Doe\",\"Room 1004\",\"(234)555-8914\",\n     2  \"(234)555-0044\",\"jdoe@rosettacode.org\"),\n     3 \"home/jdoe\",\"/bin/bash\")\n      CLOSE (F)\t\t\n\nChoose the existing file, and append a further record to it.\n      OPEN (F, FILE=\"Staff.txt\",STATUS=\"OLD\",ACTION=\"WRITE\",\n     1 DELIM=\"QUOTE\",RECL=666,ACCESS=\"APPEND\")\n\n      NOTE = USERSTUFF(\"xyz\",\"x\",1003,1000,\t\t\n     1 DETAILS(\"X Yz\",\"Room 1003\",\"(234)555-8193\",\n     2  \"(234)555-033\",\"xyz@rosettacode.org\"),\n     3 \"/home/xyz\",\"/bin/bash\")\n      WRITE (F,*) NOTE\t\t\t\t\t\n      CLOSE (F)\n\nChase through the file, revealing what had been written..\n      OPEN (F, FILE=\"Staff.txt\",STATUS=\"OLD\",ACTION=\"READ\",\n     1 DELIM=\"QUOTE\",RECL=666)\n      N = 0\n   10 READ (F,*,END = 20) NOTE\t\n      N = N + 1\t\t\t\n      WRITE (MSG,11) N\t\t\n   11 FORMAT (/,\"Record \",I0)\t\n      WRITE (MSG,STUFF)\t\t\n      GO TO 10\t\t\t\n\nClosedown.\n   20 CLOSE (F)\n      END\n", "target": "\n\n\n\npasswd_list=[\n  dict(account='jsmith', password='x', UID=1001, GID=1000, \n       GECOS=dict(fullname='Joe Smith', office='Room 1007', extension='(234)555-8917',\n                  homephone='(234)555-0077', email='jsmith@rosettacode.org'),\n                  directory='/home/jsmith', shell='/bin/bash'),\n  dict(account='jdoe', password='x', UID=1002, GID=1000,\n       GECOS=dict(fullname='Jane Doe', office='Room 1004', extension='(234)555-8914',\n                  homephone='(234)555-0044', email='jdoe@rosettacode.org'),\n       directory='/home/jdoe', shell='/bin/bash')\n]\n\npasswd_fields=\"account password UID GID GECOS directory shell\".split()\nGECOS_fields=\"fullname office extension homephone email\".split()\n\ndef passwd_text_repr(passwd_rec):\n\n  passwd_rec[\"GECOS\"]=\",\".join([ passwd_rec[\"GECOS\"][field] for field in GECOS_fields])\n  for field in passwd_rec: \n    if not isinstance(passwd_rec[field], str):\n      passwd_rec[field]=`passwd_rec[field]`\n  return \":\".join([ passwd_rec[field] for field in passwd_fields ])\n\npasswd_text=open(\"passwd.txt\",\"w\")\nfor passwd_rec in passwd_list:\n  print >> passwd_text,passwd_text_repr(passwd_rec)\npasswd_text.close()\n\n\n\n\npasswd_text=open(\"passwd.txt\",\"a+\")\nnew_rec=dict(account='xyz', password='x', UID=1003, GID=1000,\n             GECOS=dict(fullname='X Yz', office='Room 1003', extension='(234)555-8913',\n                        homephone='(234)555-0033', email='xyz@rosettacode.org'),\n             directory='/home/xyz', shell='/bin/bash')\nprint >> passwd_text,  passwd_text_repr(new_rec)\npasswd_text.close()\n\n\n\n\npasswd_list=list(open(\"passwd.txt\",\"r\"))\nif \"xyz\" in passwd_list[-1]:\n  print \"Appended record:\",passwd_list[-1][:-1]\n"}
{"id": 16355, "name": "Digital root_Multiplicative digital root", "source": "Translate Fortran to C#: \nprogram mdr\nimplicit none\ninteger :: i, mdr, mp, n, j\ncharacter(len=*), parameter :: hfmt = '(A18)', nfmt = '(I6)'\ncharacter(len=*), parameter :: cfmt = '(A3)', rfmt = '(I3)', ffmt = '(I9)'\n\nwrite(*,hfmt) 'Number   MDR   MP '\nwrite(*,*) '------------------'\n\ni = 123321\ncall root_pers(i,mdr,mp)\nwrite(*,nfmt,advance='no') i\nwrite(*,cfmt,advance='no') '   '\nwrite(*,rfmt,advance='no') mdr\nwrite(*,cfmt,advance='no') '   '\nwrite(*,rfmt) mp\n\ni = 3939\ncall root_pers(i,mdr,mp)\nwrite(*,nfmt,advance='no') i\nwrite(*,cfmt,advance='no') '   '\nwrite(*,rfmt,advance='no') mdr\nwrite(*,cfmt,advance='no') '   '\nwrite(*,rfmt) mp\n\ni = 8822\ncall root_pers(i,mdr,mp)\nwrite(*,nfmt,advance='no') i\nwrite(*,cfmt,advance='no') '   '\nwrite(*,rfmt,advance='no') mdr\nwrite(*,cfmt,advance='no') '   '\nwrite(*,rfmt) mp\n\ni = 39398\ncall root_pers(i,mdr,mp)\nwrite(*,nfmt,advance='no') i\nwrite(*,cfmt,advance='no') '   '\nwrite(*,rfmt,advance='no') mdr\nwrite(*,cfmt,advance='no') '   '\nwrite(*,rfmt) mp\n\nwrite(*,*)\nwrite(*,*)\nwrite(*,*) 'First five numbers with MDR in first column: '\nwrite(*,*) '---------------------------------------------'\n\ndo i = 0,9\n  n = 0\n  j = 0\n  write(*,rfmt,advance='no') i\n  do\n    call root_pers(j,mdr,mp)\n    if(mdr.eq.i) then\n      n = n+1\n      if(n.eq.5) then\n        write(*,ffmt) j\n        exit\n      else\n        write(*,ffmt,advance='no') j\n      end if\n    end if\n    j = j+1\n  end do\nend do\n\nend program\n\nsubroutine root_pers(i,mdr,mp)\nimplicit none\ninteger :: N, s, a, i, mdr, mp\nn = i\na = 0\nif(n.lt.10) then\n  mdr = n\n  mp = 0\n  return\nend if\ndo while(n.ge.10)\n  a = a + 1\n  s = 1\n  do while(n.gt.0)\n    s = s * mod(n,10)\n    n = int(real(n)/10.0D0)\n  end do\n  n = s\nend do\nmdr = s\nmp = a\nend subroutine\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\nclass Program\n{\n    static Tuple<int, int> DigitalRoot(long num)\n    {\n        int mp = 0;\n        while (num > 9)\n        {\n            num = num.ToString().ToCharArray().Select(x => x - '0').Aggregate((a, b) => a * b);\n            mp++;\n        }\n        return new Tuple<int, int>(mp, (int)num);\n    }\n    static void Main(string[] args)\n    {\n        foreach (long num in new long[] { 123321, 7739, 893, 899998 })\n        {\n            var t = DigitalRoot(num);\n            Console.WriteLine(\"{0} has multiplicative persistence {1} and multiplicative digital root {2}\", num, t.Item1, t.Item2);\n        }\n\n        const int twidth = 5;\n        List<long>[] table = new List<long>[10];\n        for (int i = 0; i < 10; i++)\n            table[i] = new List<long>();\n        long number = -1;\n        while (table.Any(x => x.Count < twidth)) \n        {\n            var t = DigitalRoot(++number);\n            if (table[t.Item2].Count < twidth)\n                table[t.Item2].Add(number);\n        }\n        for (int i = 0; i < 10; i++)\n            Console.WriteLine(\" {0}\u00a0: [{1}]\", i, string.Join(\", \", table[i]));\n    }\n}\n"}
{"id": 16358, "name": "Digital root_Multiplicative digital root", "source": "Translate Fortran to Java: \nprogram mdr\nimplicit none\ninteger :: i, mdr, mp, n, j\ncharacter(len=*), parameter :: hfmt = '(A18)', nfmt = '(I6)'\ncharacter(len=*), parameter :: cfmt = '(A3)', rfmt = '(I3)', ffmt = '(I9)'\n\nwrite(*,hfmt) 'Number   MDR   MP '\nwrite(*,*) '------------------'\n\ni = 123321\ncall root_pers(i,mdr,mp)\nwrite(*,nfmt,advance='no') i\nwrite(*,cfmt,advance='no') '   '\nwrite(*,rfmt,advance='no') mdr\nwrite(*,cfmt,advance='no') '   '\nwrite(*,rfmt) mp\n\ni = 3939\ncall root_pers(i,mdr,mp)\nwrite(*,nfmt,advance='no') i\nwrite(*,cfmt,advance='no') '   '\nwrite(*,rfmt,advance='no') mdr\nwrite(*,cfmt,advance='no') '   '\nwrite(*,rfmt) mp\n\ni = 8822\ncall root_pers(i,mdr,mp)\nwrite(*,nfmt,advance='no') i\nwrite(*,cfmt,advance='no') '   '\nwrite(*,rfmt,advance='no') mdr\nwrite(*,cfmt,advance='no') '   '\nwrite(*,rfmt) mp\n\ni = 39398\ncall root_pers(i,mdr,mp)\nwrite(*,nfmt,advance='no') i\nwrite(*,cfmt,advance='no') '   '\nwrite(*,rfmt,advance='no') mdr\nwrite(*,cfmt,advance='no') '   '\nwrite(*,rfmt) mp\n\nwrite(*,*)\nwrite(*,*)\nwrite(*,*) 'First five numbers with MDR in first column: '\nwrite(*,*) '---------------------------------------------'\n\ndo i = 0,9\n  n = 0\n  j = 0\n  write(*,rfmt,advance='no') i\n  do\n    call root_pers(j,mdr,mp)\n    if(mdr.eq.i) then\n      n = n+1\n      if(n.eq.5) then\n        write(*,ffmt) j\n        exit\n      else\n        write(*,ffmt,advance='no') j\n      end if\n    end if\n    j = j+1\n  end do\nend do\n\nend program\n\nsubroutine root_pers(i,mdr,mp)\nimplicit none\ninteger :: N, s, a, i, mdr, mp\nn = i\na = 0\nif(n.lt.10) then\n  mdr = n\n  mp = 0\n  return\nend if\ndo while(n.ge.10)\n  a = a + 1\n  s = 1\n  do while(n.gt.0)\n    s = s * mod(n,10)\n    n = int(real(n)/10.0D0)\n  end do\n  n = s\nend do\nmdr = s\nmp = a\nend subroutine\n", "target": "import java.util.*;\n\npublic class MultiplicativeDigitalRoot {\n\n    public static void main(String[] args) {\n\n        System.out.println(\"NUMBER  MDR   MP\");\n        for (long n : new long[]{123321, 7739, 893, 899998}) {\n            long[] a = multiplicativeDigitalRoot(n);\n            System.out.printf(\"%6d %4d %4d%n\", a[0], a[1], a[2]);\n        }\n\n        System.out.println();\n\n        Map<Long, List<Long>> table = new HashMap<>();\n        for (long i = 0; i < 10; i++)\n            table.put(i, new ArrayList<>());\n\n        for (long cnt = 0, n = 0; cnt < 10;) {\n            long[] res = multiplicativeDigitalRoot(n++);\n            List<Long> list = table.get(res[1]);\n            if (list.size() < 5) {\n                list.add(res[0]);\n                cnt = list.size() == 5 ? cnt + 1 : cnt;\n            }\n        }\n\n        System.out.println(\"MDR: first five numbers with same MDR\");\n        table.forEach((key, lst) -> {\n            System.out.printf(\"%3d: \", key);\n            lst.forEach(e -> System.out.printf(\"%6s \", e));\n            System.out.println();\n        });\n    }\n\n    public static long[] multiplicativeDigitalRoot(long n) {\n        int mp = 0;\n        long mdr = n;\n        while (mdr > 9) {\n            long m = mdr;\n            long total = 1;\n            while (m > 0) {\n                total *= m % 10;\n                m /= 10;\n            }\n            mdr = total;\n            mp++;\n        }\n        return new long[]{n, mdr, mp};\n    }\n}\n"}
{"id": 16359, "name": "Digital root_Multiplicative digital root", "source": "Translate Fortran to Python: \nprogram mdr\nimplicit none\ninteger :: i, mdr, mp, n, j\ncharacter(len=*), parameter :: hfmt = '(A18)', nfmt = '(I6)'\ncharacter(len=*), parameter :: cfmt = '(A3)', rfmt = '(I3)', ffmt = '(I9)'\n\nwrite(*,hfmt) 'Number   MDR   MP '\nwrite(*,*) '------------------'\n\ni = 123321\ncall root_pers(i,mdr,mp)\nwrite(*,nfmt,advance='no') i\nwrite(*,cfmt,advance='no') '   '\nwrite(*,rfmt,advance='no') mdr\nwrite(*,cfmt,advance='no') '   '\nwrite(*,rfmt) mp\n\ni = 3939\ncall root_pers(i,mdr,mp)\nwrite(*,nfmt,advance='no') i\nwrite(*,cfmt,advance='no') '   '\nwrite(*,rfmt,advance='no') mdr\nwrite(*,cfmt,advance='no') '   '\nwrite(*,rfmt) mp\n\ni = 8822\ncall root_pers(i,mdr,mp)\nwrite(*,nfmt,advance='no') i\nwrite(*,cfmt,advance='no') '   '\nwrite(*,rfmt,advance='no') mdr\nwrite(*,cfmt,advance='no') '   '\nwrite(*,rfmt) mp\n\ni = 39398\ncall root_pers(i,mdr,mp)\nwrite(*,nfmt,advance='no') i\nwrite(*,cfmt,advance='no') '   '\nwrite(*,rfmt,advance='no') mdr\nwrite(*,cfmt,advance='no') '   '\nwrite(*,rfmt) mp\n\nwrite(*,*)\nwrite(*,*)\nwrite(*,*) 'First five numbers with MDR in first column: '\nwrite(*,*) '---------------------------------------------'\n\ndo i = 0,9\n  n = 0\n  j = 0\n  write(*,rfmt,advance='no') i\n  do\n    call root_pers(j,mdr,mp)\n    if(mdr.eq.i) then\n      n = n+1\n      if(n.eq.5) then\n        write(*,ffmt) j\n        exit\n      else\n        write(*,ffmt,advance='no') j\n      end if\n    end if\n    j = j+1\n  end do\nend do\n\nend program\n\nsubroutine root_pers(i,mdr,mp)\nimplicit none\ninteger :: N, s, a, i, mdr, mp\nn = i\na = 0\nif(n.lt.10) then\n  mdr = n\n  mp = 0\n  return\nend if\ndo while(n.ge.10)\n  a = a + 1\n  s = 1\n  do while(n.gt.0)\n    s = s * mod(n,10)\n    n = int(real(n)/10.0D0)\n  end do\n  n = s\nend do\nmdr = s\nmp = a\nend subroutine\n", "target": "try:\n    from functools import reduce\nexcept:\n    pass\n\ndef mdroot(n):\n    'Multiplicative digital root'\n    mdr = [n]\n    while mdr[-1] > 9:\n        mdr.append(reduce(int.__mul__, (int(dig) for dig in str(mdr[-1])), 1))\n    return len(mdr) - 1, mdr[-1]\n\nif __name__ == '__main__':\n    print('Number: (MP, MDR)\\n======  =========')\n    for n in (123321, 7739, 893, 899998):\n        print('%6i: %r' % (n, mdroot(n)))\n        \n    table, n = {i: [] for i in range(10)}, 0\n    while min(len(row) for row in table.values()) < 5:\n        mpersistence, mdr = mdroot(n)\n        table[mdr].append(n)\n        n += 1\n    print('\\nMP: [n0..n4]\\n==  ========')\n    for mp, val in sorted(table.items()):\n        print('%2i: %r' % (mp, val[:5]))\n"}
{"id": 16523, "name": "Perfect numbers", "source": "Translate Fortran to C#: FUNCTION isPerfect(n)\n  LOGICAL :: isPerfect\n  INTEGER, INTENT(IN) :: n\n  INTEGER :: i, factorsum\n\n  isPerfect = .FALSE.\n  factorsum = 1\n  DO i = 2, INT(SQRT(REAL(n)))\n     IF(MOD(n, i) == 0) factorsum = factorsum + i + (n / i)\n  END DO\n  IF (factorsum == n) isPerfect = .TRUE.\nEND FUNCTION isPerfect\n", "target": "static void Main(string[] args)\n{\n\tConsole.WriteLine(\"Perfect numbers from 1 to 33550337:\");\n\n\tfor (int x = 0; x < 33550337; x++)\n\t{\n\t\tif (IsPerfect(x))\n\t\t\tConsole.WriteLine(x + \" is perfect.\");\n\t}\n\n\tConsole.ReadLine();\n}\n\nstatic bool IsPerfect(int num) \n{\n\tint sum = 0;\n\tfor (int i = 1; i < num; i++)\n\t{\n\t\tif (num % i == 0)\n\t\t\tsum += i;\n\t}\n\n\treturn sum == num ;\n}\n"}
{"id": 16526, "name": "Perfect numbers", "source": "Translate Fortran to Java: FUNCTION isPerfect(n)\n  LOGICAL :: isPerfect\n  INTEGER, INTENT(IN) :: n\n  INTEGER :: i, factorsum\n\n  isPerfect = .FALSE.\n  factorsum = 1\n  DO i = 2, INT(SQRT(REAL(n)))\n     IF(MOD(n, i) == 0) factorsum = factorsum + i + (n / i)\n  END DO\n  IF (factorsum == n) isPerfect = .TRUE.\nEND FUNCTION isPerfect\n", "target": "public static boolean perf(int n){\n\tint sum= 0;\n\tfor(int i= 1;i < n;i++){\n\t\tif(n % i == 0){\n\t\t\tsum+= i;\n\t\t}\n\t}\n\treturn sum == n;\n}\n"}
{"id": 16527, "name": "Perfect numbers", "source": "Translate Fortran to Python: FUNCTION isPerfect(n)\n  LOGICAL :: isPerfect\n  INTEGER, INTENT(IN) :: n\n  INTEGER :: i, factorsum\n\n  isPerfect = .FALSE.\n  factorsum = 1\n  DO i = 2, INT(SQRT(REAL(n)))\n     IF(MOD(n, i) == 0) factorsum = factorsum + i + (n / i)\n  END DO\n  IF (factorsum == n) isPerfect = .TRUE.\nEND FUNCTION isPerfect\n", "target": "def perf1(n):\n    sum = 0\n    for i in range(1, n):\n        if n % i == 0:\n            sum += i\n    return sum == n\n"}
{"id": 17417, "name": "Bitmap_Write a PPM file", "source": "Translate Fortran to C#: program main\n\n  use rgbimage_m\n\n  implicit none\n\n  integer :: nx, ny, i, j, k\n\n  type(rgbimage) :: im\n\n  \n  nx = 400\n  ny = 300\n  call im%init(nx, ny)\n\n  \n  do i = 1, nx\n    do j = 1, ny\n      call im%set_pixel(i, j, [(nint(rand()*255), k=1,3)])\n    end do\n  end do\n\n  \n  call im%write('fig.ppm')\n\nend program\n", "target": "using System;\nusing System.IO;\nclass PPMWriter\n{\n    public static void WriteBitmapToPPM(string file, Bitmap bitmap)\n        {\n            \n            var writer = new StreamWriter(file);\n            writer.WriteLine(\"P6\");\n            writer.WriteLine($\"{bitmap.Width}  {bitmap.Height}\");\n            writer.WriteLine(\"255\");\n            writer.Close();\n            \n            var writerB = new BinaryWriter(new FileStream(file, FileMode.Append));\n            for (int x = 0; x < bitmap.Height; x++)\n                for (int y = 0; y < bitmap.Width; y++)\n                {\n                    Color color = bitmap.GetPixel(y, x);\n                    writerB.Write(color.R);\n                    writerB.Write(color.G);\n                    writerB.Write(color.B);\n                }\n            writerB.Close();\n        }\n}\n"}
{"id": 17421, "name": "Bitmap_Write a PPM file", "source": "Translate Fortran to Java: program main\n\n  use rgbimage_m\n\n  implicit none\n\n  integer :: nx, ny, i, j, k\n\n  type(rgbimage) :: im\n\n  \n  nx = 400\n  ny = 300\n  call im%init(nx, ny)\n\n  \n  do i = 1, nx\n    do j = 1, ny\n      call im%set_pixel(i, j, [(nint(rand()*255), k=1,3)])\n    end do\n  end do\n\n  \n  call im%write('fig.ppm')\n\nend program\n", "target": "import java.io.BufferedOutputStream;\nimport java.io.File;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.nio.charset.StandardCharsets;\n\npublic class PPMWriter {\n\n    public void bitmapToPPM(File file, BasicBitmapStorage bitmap) throws IOException {\n        file.delete();\n\n        try (var os = new FileOutputStream(file, true);\n             var bw = new BufferedOutputStream(os)) {\n            var header = String.format(\"P6\\n%d %d\\n255\\n\",\n                    bitmap.getWidth(), bitmap.getHeight());\n\n            bw.write(header.getBytes(StandardCharsets.US_ASCII));\n\n            for (var y = 0; y < bitmap.getHeight(); y++) {\n                for (var x = 0; x < bitmap.getWidth(); x++) {\n                    var pixel = bitmap.getPixel(x, y);\n                    bw.write(pixel.getRed());\n                    bw.write(pixel.getGreen());\n                    bw.write(pixel.getBlue());\n                }\n            }\n        }\n    }\n}\n"}
{"id": 17422, "name": "Bitmap_Write a PPM file", "source": "Translate Fortran to Python: program main\n\n  use rgbimage_m\n\n  implicit none\n\n  integer :: nx, ny, i, j, k\n\n  type(rgbimage) :: im\n\n  \n  nx = 400\n  ny = 300\n  call im%init(nx, ny)\n\n  \n  do i = 1, nx\n    do j = 1, ny\n      call im%set_pixel(i, j, [(nint(rand()*255), k=1,3)])\n    end do\n  end do\n\n  \n  call im%write('fig.ppm')\n\nend program\n", "target": "\nimport io\nppmfileout = io.StringIO('')\n\ndef writeppmp3(self, f):\n    self.writeppm(f, ppmformat='P3')\n        \ndef writeppm(self, f, ppmformat='P6'):\n    assert ppmformat in ['P3', 'P6'], 'Format wrong'\n    magic = ppmformat + '\\n'\n    comment = '\n    maxval = max(max(max(bit) for bit in row) for row in self.map)\n    assert ppmformat == 'P3' or 0 <= maxval < 256, 'R,G,B must fit in a byte'\n    if ppmformat == 'P6':\n        fwrite = lambda s: f.write(bytes(s, 'UTF-8'))\n        maxval = 255\n    else:\n        fwrite = f.write\n        numsize=len(str(maxval))\n    fwrite(magic)\n    fwrite(comment)\n    fwrite('%i %i\\n%i\\n' % (self.width, self.height, maxval))\n    for h in range(self.height-1, -1, -1):\n        for w in range(self.width):\n            r, g, b = self.get(w, h)\n            if ppmformat == 'P3':\n                fwrite('   %*i %*i %*i' % (numsize, r, numsize, g, numsize, b))\n            else:\n                fwrite('%c%c%c' % (r, g, b))\n        if ppmformat == 'P3':\n            fwrite('\\n')\n\nBitmap.writeppmp3 = writeppmp3\nBitmap.writeppm = writeppm\n\n\nbitmap = Bitmap(4, 4, black)\nbitmap.fillrect(1, 0, 1, 2, white)\nbitmap.set(3, 3, Colour(127, 0, 63))\n\nbitmap.writeppmp3(ppmfileout)\n\nprint(ppmfileout.getvalue())\n\n\n\n\nppmfileout = open('tmp.ppm', 'wb')\nbitmap.writeppm(ppmfileout)\nppmfileout.close()\n"}
{"id": 17659, "name": "Create a two-dimensional array at runtime", "source": "Translate Fortran to C#: PROGRAM Example\n\n  IMPLICIT NONE\n  INTEGER :: rows, columns, errcheck\n  INTEGER, ALLOCATABLE :: array(:,:)\n\n  WRITE(*,*) \"Enter number of rows\"\n  READ(*,*) rows\n  WRITE(*,*) \"Enter number of columns\"\n  READ(*,*) columns\n \n  ALLOCATE (array(rows,columns), STAT=errcheck) \n \n  array(1,1) = 42\n \n  WRITE(*,*) array(1,1)\n \n  DEALLOCATE (array, STAT=errcheck)\n\nEND PROGRAM Example\n", "target": "class Program\n    {\n        static void Main(string[] args)\n        {\n            Console.WriteLine(\"Enter two integers. Space delimited please: \");\n            string s = Console.ReadLine();\n            \n            int[,] myArray=new int[(int)s[0],(int)s[2]];\n            myArray[0, 0] = 2;\n            Console.WriteLine(myArray[0, 0]);\n\n            Console.ReadLine();\n        }\n    }\n"}
{"id": 17662, "name": "Create a two-dimensional array at runtime", "source": "Translate Fortran to Java: PROGRAM Example\n\n  IMPLICIT NONE\n  INTEGER :: rows, columns, errcheck\n  INTEGER, ALLOCATABLE :: array(:,:)\n\n  WRITE(*,*) \"Enter number of rows\"\n  READ(*,*) rows\n  WRITE(*,*) \"Enter number of columns\"\n  READ(*,*) columns\n \n  ALLOCATE (array(rows,columns), STAT=errcheck) \n \n  array(1,1) = 42\n \n  WRITE(*,*) array(1,1)\n \n  DEALLOCATE (array, STAT=errcheck)\n\nEND PROGRAM Example\n", "target": "import java.util.Scanner;\n\npublic class twoDimArray {\n  public static void main(String[] args) {\n        Scanner in = new Scanner(System.in);\n        \n        int nbr1 = in.nextInt();\n        int nbr2 = in.nextInt();\n        \n        double[][] array = new double[nbr1][nbr2];\n        array[0][0] = 42.0;\n        System.out.println(\"The number at place [0 0] is \" + array[0][0]);\n  }\n}\n"}
{"id": 17663, "name": "Create a two-dimensional array at runtime", "source": "Translate Fortran to Python: PROGRAM Example\n\n  IMPLICIT NONE\n  INTEGER :: rows, columns, errcheck\n  INTEGER, ALLOCATABLE :: array(:,:)\n\n  WRITE(*,*) \"Enter number of rows\"\n  READ(*,*) rows\n  WRITE(*,*) \"Enter number of columns\"\n  READ(*,*) columns\n \n  ALLOCATE (array(rows,columns), STAT=errcheck) \n \n  array(1,1) = 42\n \n  WRITE(*,*) array(1,1)\n \n  DEALLOCATE (array, STAT=errcheck)\n\nEND PROGRAM Example\n", "target": "width = int(raw_input(\"Width of myarray: \"))\nheight = int(raw_input(\"Height of Array: \"))\nmyarray = [[0] * width for i in range(height)]\nmyarray[0][0] = 3.5\nprint (myarray[0][0])\n"}
{"id": 17957, "name": "Munchausen numbers", "source": "Translate Fortran to C#: C MUNCHAUSEN NUMBERS - FORTRAN IV\n      DO 2 I=1,5000\n        IS=0\n        II=I\n        DO 1 J=1,4\n          ID=10**(4-J)\n          N=II/ID\n          IR=MOD(II,ID)\n          IF(N.NE.0) IS=IS+N**N\n  1       II=IR\n  2     IF(IS.EQ.I) WRITE(*,*) I\n      END\n", "target": "Func<char, int> toInt = c => c-'0';\n\nforeach (var i in Enumerable.Range(1,5000)\n\t.Where(n => n == n.ToString()\n\t\t.Sum(x => Math.Pow(toInt(x), toInt(x)))))\n\tConsole.WriteLine(i);\n"}
{"id": 17958, "name": "Munchausen numbers", "source": "Translate Fortran to C#: C MUNCHAUSEN NUMBERS - FORTRAN IV\n      DO 2 I=1,5000\n        IS=0\n        II=I\n        DO 1 J=1,4\n          ID=10**(4-J)\n          N=II/ID\n          IR=MOD(II,ID)\n          IF(N.NE.0) IS=IS+N**N\n  1       II=IR\n  2     IF(IS.EQ.I) WRITE(*,*) I\n      END\n", "target": "Func<char, int> toInt = c => c-'0';\n\nforeach (var i in Enumerable.Range(1,5000)\n\t.Where(n => n == n.ToString()\n\t\t.Sum(x => Math.Pow(toInt(x), toInt(x)))))\n\tConsole.WriteLine(i);\n"}
{"id": 17964, "name": "Munchausen numbers", "source": "Translate Fortran to Java: C MUNCHAUSEN NUMBERS - FORTRAN IV\n      DO 2 I=1,5000\n        IS=0\n        II=I\n        DO 1 J=1,4\n          ID=10**(4-J)\n          N=II/ID\n          IR=MOD(II,ID)\n          IF(N.NE.0) IS=IS+N**N\n  1       II=IR\n  2     IF(IS.EQ.I) WRITE(*,*) I\n      END\n", "target": "public class Main {\n    public static void main(String[] args) {\n        for(int i = 0 ; i <= 5000 ; i++ ){\n            int val = String.valueOf(i).chars().map(x -> (int) Math.pow( x-48 ,x-48)).sum();\n            if( i == val){\n                System.out.println( i + \" (munchausen)\");\n            }\n        }\n    }\n}\n"}
{"id": 17965, "name": "Munchausen numbers", "source": "Translate Fortran to Java: C MUNCHAUSEN NUMBERS - FORTRAN IV\n      DO 2 I=1,5000\n        IS=0\n        II=I\n        DO 1 J=1,4\n          ID=10**(4-J)\n          N=II/ID\n          IR=MOD(II,ID)\n          IF(N.NE.0) IS=IS+N**N\n  1       II=IR\n  2     IF(IS.EQ.I) WRITE(*,*) I\n      END\n", "target": "public class Main {\n    public static void main(String[] args) {\n        for(int i = 0 ; i <= 5000 ; i++ ){\n            int val = String.valueOf(i).chars().map(x -> (int) Math.pow( x-48 ,x-48)).sum();\n            if( i == val){\n                System.out.println( i + \" (munchausen)\");\n            }\n        }\n    }\n}\n"}
{"id": 17966, "name": "Munchausen numbers", "source": "Translate Fortran to Python: C MUNCHAUSEN NUMBERS - FORTRAN IV\n      DO 2 I=1,5000\n        IS=0\n        II=I\n        DO 1 J=1,4\n          ID=10**(4-J)\n          N=II/ID\n          IR=MOD(II,ID)\n          IF(N.NE.0) IS=IS+N**N\n  1       II=IR\n  2     IF(IS.EQ.I) WRITE(*,*) I\n      END\n", "target": "for i in range(5000):\n    if i == sum(int(x) ** int(x) for x in str(i)):\n        print(i)\n"}
{"id": 17967, "name": "Munchausen numbers", "source": "Translate Fortran to Python: C MUNCHAUSEN NUMBERS - FORTRAN IV\n      DO 2 I=1,5000\n        IS=0\n        II=I\n        DO 1 J=1,4\n          ID=10**(4-J)\n          N=II/ID\n          IR=MOD(II,ID)\n          IF(N.NE.0) IS=IS+N**N\n  1       II=IR\n  2     IF(IS.EQ.I) WRITE(*,*) I\n      END\n", "target": "for i in range(5000):\n    if i == sum(int(x) ** int(x) for x in str(i)):\n        print(i)\n"}
{"id": 18296, "name": "Strip block comments", "source": "Translate Fortran to C#:       SUBROUTINE UNBLOCK(THIS,THAT)\t\nCopies from file INF to file OUT, record by record, except skipping null output records.\n       CHARACTER*(*) THIS,THAT\t\n       INTEGER LOTS\t\t\t\n       PARAMETER (LOTS = 6666)\t\t\n       CHARACTER*(LOTS) ACARD,ALINE\t\n       INTEGER LC,LL,L\t\t\n       INTEGER L1,L2\t\t\n       INTEGER NC,NL\t\t\n       LOGICAL BLAH\t\t\n       INTEGER MSG,KBD,INF,OUT\t\t\n       COMMON /IODEV/MSG,KBD,INF,OUT\t\n        NC = 0\t\t\n        NL = 0\t\t\n        BLAH = .FALSE.\t\nChug through the input.\n   10   READ(INF,11,END = 100) LC,ACARD(1:MIN(LC,LOTS))\t\n   11   FORMAT (Q,A)\t\t\n        NC = NC + 1\t\t\n        IF (LC.GT.LOTS) THEN\t\n          WRITE (MSG,12) NC,LC,LOTS\t\n   12     FORMAT (\"Record \",I0,\" has length \",I0,\"\n          LC = LOTS\t\t\t\n        END IF\t\t\t\nChew through ACARD according to mood.\n        LL = 0\t\t\n        L2 = 0\t\t\n   20   L1 = L2 + 1\t\n        IF (L1.LE.LC) THEN\t\n          L2 = L1\t\t\n          IF (BLAH) THEN\t\n   21       IF (L2 + LEN(THAT) - 1 .LE. LC) THEN\t\n              IF (ACARD(L2:L2 + LEN(THAT) - 1).EQ.THAT) THEN\t\n                BLAH = .FALSE.\t\t\n                L2 = L2 + LEN(THAT) - 1\t\n                GO TO 20\t\t\n              END IF\t\t\n              L2 = L2 + 1\t\n              GO TO 21\t\t\n            END IF\t\n           ELSE\t\t\n   22       IF (L2 + LEN(THIS) - 1 .LE. LC) THEN\t\n              IF (ACARD(L2:L2 + LEN(THIS) - 1).EQ.THIS) THEN\t\n                BLAH = .TRUE.\t\t\n                L = L2 - L1\t\t\n                ALINE(LL + 1:LL + L) = ACARD(L1:L2 - 1)\t\n                LL = LL + L\t\t\n                L2 = L2 + LEN(THIS) - 1\t\n                GO TO 20\t\t\n              END IF\t\t\n              L2 = L2 + 1\t\n              GO TO 22\t\t\n            END IF\t\n            L = LC - L1 + 1\t\n            ALINE(LL + 1:LL + L) = ACARD(L1:LC)\t\n            LL = LL + L\t\t\n          END IF\t\n        END IF\t\nCast forth some output.\n        IF (LL.GT.0) THEN\t\n          WRITE (OUT,23) ALINE(1:LL)\t\n   23     FORMAT (\">\",A,\"<\") \t\t\n          NL = NL + 1\t\t\t\n        END IF        \t\t\n        GO TO 10\t\nCompleted.\n  100   WRITE (MSG,101) NC,NL\t\n  101   FORMAT (I0,\" read, \",I0,\" written.\")\n      END       \n\n      PROGRAM TEST\n      INTEGER MSG,KBD,INF,OUT\n      COMMON /IODEV/MSG,KBD,INF,OUT\n      KBD = 5\n      MSG = 6\n      INF = 10\n      OUT = 11\n      OPEN (INF,FILE=\"Source.txt\",STATUS=\"OLD\",ACTION=\"READ\")\n      OPEN (OUT,FILE=\"Src.txt\",STATUS=\"REPLACE\",ACTION=\"WRITE\")\n\n      CALL UNBLOCK(\"/*\",\"*/\")\n\n      END\t\n", "target": "using System;\n\n    class Program\n    {\n        private static string BlockCommentStrip(string commentStart, string commentEnd, string sampleText)\n        {\n            while (sampleText.IndexOf(commentStart) > -1 && sampleText.IndexOf(commentEnd, sampleText.IndexOf(commentStart) + commentStart.Length) > -1)\n            {\n                int start = sampleText.IndexOf(commentStart);\n                int end = sampleText.IndexOf(commentEnd, start + commentStart.Length);\n                sampleText = sampleText.Remove(\n                    start,\n                    (end + commentEnd.Length) - start\n                    );\n            }\n            return sampleText;\n        }\n    }\n"}
{"id": 18299, "name": "Strip block comments", "source": "Translate Fortran to Java:       SUBROUTINE UNBLOCK(THIS,THAT)\t\nCopies from file INF to file OUT, record by record, except skipping null output records.\n       CHARACTER*(*) THIS,THAT\t\n       INTEGER LOTS\t\t\t\n       PARAMETER (LOTS = 6666)\t\t\n       CHARACTER*(LOTS) ACARD,ALINE\t\n       INTEGER LC,LL,L\t\t\n       INTEGER L1,L2\t\t\n       INTEGER NC,NL\t\t\n       LOGICAL BLAH\t\t\n       INTEGER MSG,KBD,INF,OUT\t\t\n       COMMON /IODEV/MSG,KBD,INF,OUT\t\n        NC = 0\t\t\n        NL = 0\t\t\n        BLAH = .FALSE.\t\nChug through the input.\n   10   READ(INF,11,END = 100) LC,ACARD(1:MIN(LC,LOTS))\t\n   11   FORMAT (Q,A)\t\t\n        NC = NC + 1\t\t\n        IF (LC.GT.LOTS) THEN\t\n          WRITE (MSG,12) NC,LC,LOTS\t\n   12     FORMAT (\"Record \",I0,\" has length \",I0,\"\n          LC = LOTS\t\t\t\n        END IF\t\t\t\nChew through ACARD according to mood.\n        LL = 0\t\t\n        L2 = 0\t\t\n   20   L1 = L2 + 1\t\n        IF (L1.LE.LC) THEN\t\n          L2 = L1\t\t\n          IF (BLAH) THEN\t\n   21       IF (L2 + LEN(THAT) - 1 .LE. LC) THEN\t\n              IF (ACARD(L2:L2 + LEN(THAT) - 1).EQ.THAT) THEN\t\n                BLAH = .FALSE.\t\t\n                L2 = L2 + LEN(THAT) - 1\t\n                GO TO 20\t\t\n              END IF\t\t\n              L2 = L2 + 1\t\n              GO TO 21\t\t\n            END IF\t\n           ELSE\t\t\n   22       IF (L2 + LEN(THIS) - 1 .LE. LC) THEN\t\n              IF (ACARD(L2:L2 + LEN(THIS) - 1).EQ.THIS) THEN\t\n                BLAH = .TRUE.\t\t\n                L = L2 - L1\t\t\n                ALINE(LL + 1:LL + L) = ACARD(L1:L2 - 1)\t\n                LL = LL + L\t\t\n                L2 = L2 + LEN(THIS) - 1\t\n                GO TO 20\t\t\n              END IF\t\t\n              L2 = L2 + 1\t\n              GO TO 22\t\t\n            END IF\t\n            L = LC - L1 + 1\t\n            ALINE(LL + 1:LL + L) = ACARD(L1:LC)\t\n            LL = LL + L\t\t\n          END IF\t\n        END IF\t\nCast forth some output.\n        IF (LL.GT.0) THEN\t\n          WRITE (OUT,23) ALINE(1:LL)\t\n   23     FORMAT (\">\",A,\"<\") \t\t\n          NL = NL + 1\t\t\t\n        END IF        \t\t\n        GO TO 10\t\nCompleted.\n  100   WRITE (MSG,101) NC,NL\t\n  101   FORMAT (I0,\" read, \",I0,\" written.\")\n      END       \n\n      PROGRAM TEST\n      INTEGER MSG,KBD,INF,OUT\n      COMMON /IODEV/MSG,KBD,INF,OUT\n      KBD = 5\n      MSG = 6\n      INF = 10\n      OUT = 11\n      OPEN (INF,FILE=\"Source.txt\",STATUS=\"OLD\",ACTION=\"READ\")\n      OPEN (OUT,FILE=\"Src.txt\",STATUS=\"REPLACE\",ACTION=\"WRITE\")\n\n      CALL UNBLOCK(\"/*\",\"*/\")\n\n      END\t\n", "target": "import java.io.*;\n\npublic class StripBlockComments{\n    public static String readFile(String filename) {\n\tBufferedReader reader = new BufferedReader(new FileReader(filename));\n\ttry {\n\t    StringBuilder fileContents = new StringBuilder();\n\t    char[] buffer = new char[4096];\n\t    while (reader.read(buffer, 0, 4096) > 0) {\n\t\tfileContents.append(buffer);\n\t    }\n\t    return fileContents.toString();\n\t} finally {\n\t    reader.close();\n\t}\n    }\n\n    public static String stripComments(String beginToken, String endToken,\n\t\t\t\t       String input) {\n\tStringBuilder output = new StringBuilder();\n\twhile (true) {\n\t    int begin = input.indexOf(beginToken);\n\t    int end = input.indexOf(endToken, begin+beginToken.length());\n\t    if (begin == -1 || end == -1) {\n\t\toutput.append(input);\n\t\treturn output.toString();\n\t    }\n\t    output.append(input.substring(0, begin));\n\t    input = input.substring(end + endToken.length());\n\t}\n    }\n\n    public static void main(String[] args) {\n\tif (args.length < 3) {\n\t    System.out.println(\"Usage: BeginToken EndToken FileToProcess\");\n\t    System.exit(1);\n\t}\n\n\tString begin = args[0];\n\tString end = args[1];\n\tString input = args[2];\n\n\ttry {\n\t    System.out.println(stripComments(begin, end, readFile(input)));\n\t} catch (Exception e) {\n\t    e.printStackTrace();\n\t    System.exit(1);\n\t}\n    }\n}\n"}
{"id": 18300, "name": "Strip block comments", "source": "Translate Fortran to Python:       SUBROUTINE UNBLOCK(THIS,THAT)\t\nCopies from file INF to file OUT, record by record, except skipping null output records.\n       CHARACTER*(*) THIS,THAT\t\n       INTEGER LOTS\t\t\t\n       PARAMETER (LOTS = 6666)\t\t\n       CHARACTER*(LOTS) ACARD,ALINE\t\n       INTEGER LC,LL,L\t\t\n       INTEGER L1,L2\t\t\n       INTEGER NC,NL\t\t\n       LOGICAL BLAH\t\t\n       INTEGER MSG,KBD,INF,OUT\t\t\n       COMMON /IODEV/MSG,KBD,INF,OUT\t\n        NC = 0\t\t\n        NL = 0\t\t\n        BLAH = .FALSE.\t\nChug through the input.\n   10   READ(INF,11,END = 100) LC,ACARD(1:MIN(LC,LOTS))\t\n   11   FORMAT (Q,A)\t\t\n        NC = NC + 1\t\t\n        IF (LC.GT.LOTS) THEN\t\n          WRITE (MSG,12) NC,LC,LOTS\t\n   12     FORMAT (\"Record \",I0,\" has length \",I0,\"\n          LC = LOTS\t\t\t\n        END IF\t\t\t\nChew through ACARD according to mood.\n        LL = 0\t\t\n        L2 = 0\t\t\n   20   L1 = L2 + 1\t\n        IF (L1.LE.LC) THEN\t\n          L2 = L1\t\t\n          IF (BLAH) THEN\t\n   21       IF (L2 + LEN(THAT) - 1 .LE. LC) THEN\t\n              IF (ACARD(L2:L2 + LEN(THAT) - 1).EQ.THAT) THEN\t\n                BLAH = .FALSE.\t\t\n                L2 = L2 + LEN(THAT) - 1\t\n                GO TO 20\t\t\n              END IF\t\t\n              L2 = L2 + 1\t\n              GO TO 21\t\t\n            END IF\t\n           ELSE\t\t\n   22       IF (L2 + LEN(THIS) - 1 .LE. LC) THEN\t\n              IF (ACARD(L2:L2 + LEN(THIS) - 1).EQ.THIS) THEN\t\n                BLAH = .TRUE.\t\t\n                L = L2 - L1\t\t\n                ALINE(LL + 1:LL + L) = ACARD(L1:L2 - 1)\t\n                LL = LL + L\t\t\n                L2 = L2 + LEN(THIS) - 1\t\n                GO TO 20\t\t\n              END IF\t\t\n              L2 = L2 + 1\t\n              GO TO 22\t\t\n            END IF\t\n            L = LC - L1 + 1\t\n            ALINE(LL + 1:LL + L) = ACARD(L1:LC)\t\n            LL = LL + L\t\t\n          END IF\t\n        END IF\t\nCast forth some output.\n        IF (LL.GT.0) THEN\t\n          WRITE (OUT,23) ALINE(1:LL)\t\n   23     FORMAT (\">\",A,\"<\") \t\t\n          NL = NL + 1\t\t\t\n        END IF        \t\t\n        GO TO 10\t\nCompleted.\n  100   WRITE (MSG,101) NC,NL\t\n  101   FORMAT (I0,\" read, \",I0,\" written.\")\n      END       \n\n      PROGRAM TEST\n      INTEGER MSG,KBD,INF,OUT\n      COMMON /IODEV/MSG,KBD,INF,OUT\n      KBD = 5\n      MSG = 6\n      INF = 10\n      OUT = 11\n      OPEN (INF,FILE=\"Source.txt\",STATUS=\"OLD\",ACTION=\"READ\")\n      OPEN (OUT,FILE=\"Src.txt\",STATUS=\"REPLACE\",ACTION=\"WRITE\")\n\n      CALL UNBLOCK(\"/*\",\"*/\")\n\n      END\t\n", "target": "def _commentstripper(txt, delim):\n    'Strips first nest of block comments'\n    \n    deliml, delimr = delim\n    out = ''\n    if deliml in txt:\n        indx = txt.index(deliml)\n        out += txt[:indx]\n        txt = txt[indx+len(deliml):]\n        txt = _commentstripper(txt, delim)\n        assert delimr in txt, 'Cannot find closing comment delimiter in ' + txt\n        indx = txt.index(delimr)\n        out += txt[(indx+len(delimr)):]\n    else:\n        out = txt\n    return out\n\ndef commentstripper(txt, delim=('/*', '*/')):\n    'Strips nests of block comments'\n    \n    deliml, delimr = delim\n    while deliml in txt:\n        txt = _commentstripper(txt, delim)\n    return txt\n"}
{"id": 18615, "name": "Arithmetic_Complex", "source": "Translate Fortran to C#: program cdemo\n    complex :: a = (5,3), b = (0.5, 6.0)      \n    complex :: absum, abprod, aneg, ainv\n    \n    absum  = a + b\n    abprod = a * b\n    aneg   = -a\n    ainv   = 1.0 / a\nend program cdemo\n", "target": "namespace RosettaCode.Arithmetic.Complex\n{\n    using System;\n    using System.Numerics;\n\n    internal static class Program\n    {\n        private static void Main()\n        {\n            var number = Complex.ImaginaryOne;\n            foreach (var result in new[] { number + number, number * number, -number, 1 / number, Complex.Conjugate(number) })\n            {\n                Console.WriteLine(result);\n            }\n        }\n    }\n}\n"}
{"id": 18618, "name": "Arithmetic_Complex", "source": "Translate Fortran to Java: program cdemo\n    complex :: a = (5,3), b = (0.5, 6.0)      \n    complex :: absum, abprod, aneg, ainv\n    \n    absum  = a + b\n    abprod = a * b\n    aneg   = -a\n    ainv   = 1.0 / a\nend program cdemo\n", "target": "public class Complex {\n    public final double real;\n    public final double imag;\n\n    public Complex() {\n        this(0, 0);\n    }\n\n    public Complex(double r, double i) {\n        real = r;\n        imag = i;\n    }\n\n    public Complex add(Complex b) {\n        return new Complex(this.real + b.real, this.imag + b.imag);\n    }\n\n    public Complex mult(Complex b) {\n        \n        return new Complex(this.real * b.real - this.imag * b.imag,\n                this.real * b.imag + this.imag * b.real);\n    }\n\n    public Complex inv() {\n        \n        double denom = real * real + imag * imag;\n        return new Complex(real / denom, -imag / denom);\n    }\n\n    public Complex neg() {\n        return new Complex(-real, -imag);\n    }\n\n    public Complex conj() {\n        return new Complex(real, -imag);\n    }\n\n    @Override\n    public String toString() {\n        return real + \" + \" + imag + \" * i\";\n    }\n\n    public static void main(String[] args) {\n        Complex a = new Complex(Math.PI, -5); \n        Complex b = new Complex(-1, 2.5);\n        System.out.println(a.neg());\n        System.out.println(a.add(b));\n        System.out.println(a.inv());\n        System.out.println(a.mult(b));\n        System.out.println(a.conj());\n    }\n}\n"}
{"id": 18619, "name": "Arithmetic_Complex", "source": "Translate Fortran to Python: program cdemo\n    complex :: a = (5,3), b = (0.5, 6.0)      \n    complex :: absum, abprod, aneg, ainv\n    \n    absum  = a + b\n    abprod = a * b\n    aneg   = -a\n    ainv   = 1.0 / a\nend program cdemo\n", "target": ">>> z1 = 1.5 + 3j\n>>> z2 = 1.5 + 1.5j\n>>> z1 + z2\n(3+4.5j)\n>>> z1 - z2\n1.5j\n>>> z1 * z2\n(-2.25+6.75j)\n>>> z1 / z2\n(1.5+0.5j)\n>>> - z1\n(-1.5-3j)\n>>> z1.conjugate()\n(1.5-3j)\n>>> abs(z1)\n3.3541019662496847\n>>> z1 ** z2\n(-1.1024829553277784-0.38306415117199333j)\n>>> z1.real\n1.5\n>>> z1.imag\n3.0\n>>>\n"}
{"id": 19176, "name": "Deal cards for FreeCell", "source": "Translate Fortran to C#: module Freecell\n  use lcgs\n  implicit none\n\n  character(4)  :: suit = \"CDHS\"\n  character(13) :: rank = \"A23456789TJQK\"\n  character(2) :: deck(0:51)\n\ncontains\n\nsubroutine Createdeck()\n  integer :: i, j, n\n\n  n = 0\n  do i = 1, 13\n    do j = 1, 4\n      deck(n) = rank(i:i) // suit(j:j)\n      n = n + 1\n    end do\n  end do\n\nend subroutine\n \nsubroutine Freecelldeal(game)\n  integer, intent(in) :: game\n  integer(i64) :: rnum\n  integer :: i, n\n  character(2) :: tmp\n\n  call Createdeck()\n  rnum = msrand(game)\n\n  do i = 51, 1, -1\n    n = mod(rnum, i+1)\n    tmp = deck(n)\n    deck(n) = deck(i)\n    deck(i) = tmp\n    rnum = msrand()\n  end do\n\n  write(*, \"(a, i0)\") \"Game #\", game\n  write(*, \"(8(a, tr1))\") deck(51:0:-1)\n  write(*,*)\n\nend subroutine  \nend module Freecell\n\nprogram Freecell_test\n  use Freecell\n  implicit none\n\n  call Freecelldeal(1)\n  call Freecelldeal(617)\n   \nend program\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Text;\n\nnamespace FreeCellDeals\n{\n    public class RNG\n    {\n        private int _state;\n\n        public RNG()\n        {\n            _state = (int)DateTime.Now.Ticks;\n        }\n\n        public RNG(int n)\n        {\n            _state = n;\n        }\n        public int Next()\n        {\n            return ((_state = 214013 * _state + 2531011) & int.MaxValue) >> 16;\n        }\n    }\n\n    public enum Rank\n    {\n        Ace,\n        One,\n        Two,\n        Three,\n        Four,\n        Five,\n        Six,\n        Seven,\n        Eight,\n        Nine,\n        Ten,\n        Jack,\n        Queen,\n        King\n    }\n\n    public enum Suit\n    {\n        Clubs,\n        Diamonds,\n        Hearts,\n        Spades\n    }\n\n    public class Card\n    {\n        private const string Ranks = \"A23456789TJQK\";\n        private const string Suits = \"CDHS\";\n\n        private Rank _rank;\n        public Rank Rank\n        {\n            get\n            {\n                return _rank;\n            }\n            set\n            {\n                if ((int)value < 0 || (int)value > 12)\n                {\n                    throw new InvalidOperationException(\"Setting card rank out of range\");\n                }\n                _rank = value;\n            }\n        }\n\n        private Suit _suit;\n        public Suit Suit\n        {\n            get\n            {\n                return _suit;\n            }\n            set\n            {\n                if ((int)value < 0 || (int)value > 3)\n                {\n                    throw new InvalidOperationException(\"Setting card rank out of range\");\n                }\n                _suit = value;\n            }\n        }\n\n        public Card(Rank rank, Suit suit)\n        {\n            Rank = rank;\n            Suit = suit;\n        }\n\n        public int NRank()\n        {\n            return (int) Rank;\n        }\n\n        public int NSuit()\n        {\n            return (int) Suit;\n        }\n\n        public override string ToString()\n        {\n            return new string(new[] {Ranks[NRank()], Suits[NSuit()]});\n        }\n    }\n\n    public class FreeCellDeal\n    {\n        public List<Card> Deck { get; private set; }\n\n        public FreeCellDeal(int iDeal)\n        {\n            RNG rng = new RNG(iDeal);\n\n            List<Card> rDeck = new List<Card>();\n            Deck = new List<Card>();\n\n            for (int rank = 0; rank < 13; rank++)\n            {\n                for (int suit = 0; suit < 4; suit++)\n                {\n                    rDeck.Add(new Card((Rank)rank, (Suit)suit));\n                }\n            }\n\n            \n            \n            for (int iCard = 51; iCard >= 0; iCard--)\n            {\n                int iSwap = rng.Next() % (iCard + 1);\n                Deck.Add(rDeck[iSwap]);\n                rDeck[iSwap] = rDeck[iCard];\n            }\n        }\n\n        public override string ToString()\n        {\n            StringBuilder sb = new StringBuilder();\n            for (int iRow = 0; iRow < 6; iRow++ )\n            {\n                for (int iCol = 0; iCol < 8; iCol++)\n                {\n                    sb.AppendFormat(\"{0} \", Deck[iRow * 8 + iCol]);\n                }\n                sb.Append(\"\\n\");\n            }\n            for (int iCard = 48; iCard < 52; iCard++)\n            {\n                sb.AppendFormat(\"{0} \", Deck[iCard]);\n            }\n            return sb.ToString();\n        }\n    }\n\n    class Program\n    {\n        static void Main()\n        {\n            Console.WriteLine(new FreeCellDeal(1));\n            Console.WriteLine();\n            Console.WriteLine(new FreeCellDeal(617));\n        }\n    }\n}\n"}
{"id": 19180, "name": "Deal cards for FreeCell", "source": "Translate Fortran to Java: module Freecell\n  use lcgs\n  implicit none\n\n  character(4)  :: suit = \"CDHS\"\n  character(13) :: rank = \"A23456789TJQK\"\n  character(2) :: deck(0:51)\n\ncontains\n\nsubroutine Createdeck()\n  integer :: i, j, n\n\n  n = 0\n  do i = 1, 13\n    do j = 1, 4\n      deck(n) = rank(i:i) // suit(j:j)\n      n = n + 1\n    end do\n  end do\n\nend subroutine\n \nsubroutine Freecelldeal(game)\n  integer, intent(in) :: game\n  integer(i64) :: rnum\n  integer :: i, n\n  character(2) :: tmp\n\n  call Createdeck()\n  rnum = msrand(game)\n\n  do i = 51, 1, -1\n    n = mod(rnum, i+1)\n    tmp = deck(n)\n    deck(n) = deck(i)\n    deck(i) = tmp\n    rnum = msrand()\n  end do\n\n  write(*, \"(a, i0)\") \"Game #\", game\n  write(*, \"(8(a, tr1))\") deck(51:0:-1)\n  write(*,*)\n\nend subroutine  \nend module Freecell\n\nprogram Freecell_test\n  use Freecell\n  implicit none\n\n  call Freecelldeal(1)\n  call Freecelldeal(617)\n   \nend program\n", "target": "import java.util.Arrays;\n\npublic class Shuffler {\n\t\n\tprivate int seed;\n\t\n\tprivate String[] deck = {\n\t\t\t\"AC\", \"AD\", \"AH\", \"AS\",\n\t\t\t\"2C\", \"2D\", \"2H\", \"2S\",\n\t\t\t\"3C\", \"3D\", \"3H\", \"3S\",\n\t\t\t\"4C\", \"4D\", \"4H\", \"4S\",\n\t\t\t\"5C\", \"5D\", \"5H\", \"5S\",\n\t\t\t\"6C\", \"6D\", \"6H\", \"6S\",\n\t\t\t\"7C\", \"7D\", \"7H\", \"7S\",\n\t\t\t\"8C\", \"8D\", \"8H\", \"8S\",\n\t\t\t\"9C\", \"9D\", \"9H\", \"9S\",\n\t\t\t\"TC\", \"TD\", \"TH\", \"TS\",\n\t\t\t\"JC\", \"JD\", \"JH\", \"JS\",\n\t\t\t\"QC\", \"QD\", \"QH\", \"QS\",\n\t\t\t\"KC\", \"KD\", \"KH\", \"KS\",\n\t};\n\t\n\tprivate int random() {\n\t\tseed = (214013 * seed + 2531011) & Integer.MAX_VALUE;\n\t\treturn seed >> 16;\n\t}\n\t\n\t\n\tprivate String[] getShuffledDeck() {\n\t\tString[] deck = Arrays.copyOf(this.deck, this.deck.length);\n\t\tfor(int i = deck.length - 1; i > 0; i--) {\n\t\t\tint r = random() % (i + 1);\n\t\t\tString card = deck[r];\n\t\t\tdeck[r] = deck[i];\n\t\t\tdeck[i] = card;\n\t\t}\n\t\treturn deck;\n\t}\n\t\n\t\n\tpublic void dealGame(int seed) {\n\t\tthis.seed = seed;\n\t\tString[] shuffledDeck = getShuffledDeck();\n\t\tfor(int count = 1, i = shuffledDeck.length - 1; i >= 0; count++, i--) {\n\t\t\tSystem.out.print(shuffledDeck[i]);\n\t\t\tif(count % 8 == 0) {\n\t\t\t\tSystem.out.println();\n\t\t\t} else {\n\t\t\t\tSystem.out.print(\" \");\n\t\t\t}\n\t\t}\n\t\tSystem.out.println();\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tShuffler s = new Shuffler();\n\t\ts.dealGame(1);\n\t\tSystem.out.println();\n\t\ts.dealGame(617);\n\t}\n\t\n}\n"}
{"id": 19181, "name": "Deal cards for FreeCell", "source": "Translate Fortran to Python: module Freecell\n  use lcgs\n  implicit none\n\n  character(4)  :: suit = \"CDHS\"\n  character(13) :: rank = \"A23456789TJQK\"\n  character(2) :: deck(0:51)\n\ncontains\n\nsubroutine Createdeck()\n  integer :: i, j, n\n\n  n = 0\n  do i = 1, 13\n    do j = 1, 4\n      deck(n) = rank(i:i) // suit(j:j)\n      n = n + 1\n    end do\n  end do\n\nend subroutine\n \nsubroutine Freecelldeal(game)\n  integer, intent(in) :: game\n  integer(i64) :: rnum\n  integer :: i, n\n  character(2) :: tmp\n\n  call Createdeck()\n  rnum = msrand(game)\n\n  do i = 51, 1, -1\n    n = mod(rnum, i+1)\n    tmp = deck(n)\n    deck(n) = deck(i)\n    deck(i) = tmp\n    rnum = msrand()\n  end do\n\n  write(*, \"(a, i0)\") \"Game #\", game\n  write(*, \"(8(a, tr1))\") deck(51:0:-1)\n  write(*,*)\n\nend subroutine  \nend module Freecell\n\nprogram Freecell_test\n  use Freecell\n  implicit none\n\n  call Freecelldeal(1)\n  call Freecelldeal(617)\n   \nend program\n", "target": "def randomGenerator(seed=1):\n    max_int32 = (1 << 31) - 1\n    seed = seed & max_int32\n\n    while True:\n        seed = (seed * 214013 + 2531011) & max_int32\n        yield seed >> 16\n\ndef deal(seed):\n    nc = 52\n    cards = list(range(nc - 1, -1, -1))\n    rnd = randomGenerator(seed)\n    for i, r in zip(range(nc), rnd):\n        j = (nc - 1) - r % (nc - i)\n        cards[i], cards[j] = cards[j], cards[i]\n    return cards\n\ndef show(cards):\n    l = [\"A23456789TJQK\"[int(c/4)] + \"CDHS\"[c%4] for c in cards]\n    for i in range(0, len(cards), 8):\n        print(\" \".join(l[i : i+8]))\n\nif __name__ == '__main__':\n    from sys import argv\n    seed = int(argv[1]) if len(argv) == 2 else 11982\n    print(\"Hand {}\".format(seed))\n    deck = deal(seed)\n    show(deck)\n"}
{"id": 19383, "name": "Handle a signal", "source": "Translate Fortran to C#: program signal_handling\n  use, intrinsic :: iso_fortran_env, only: atomic_logical_kind\n  implicit none\n\n  interface\n    integer(C_INT) function usleep(microseconds) bind(c)\n      use, intrinsic :: iso_c_binding, only: C_INT, C_INT32_T\n      integer(C_INT32_T), value :: microseconds\n    end function usleep\n  end interface\n\n  integer, parameter :: half_second = 500000\n  integer, parameter :: sigint = 2\n  integer, parameter :: sigquit = 3\n\n  logical(atomic_logical_kind) :: interrupt_received[*]\n  integer :: half_seconds\n  logical :: interrupt_received_ref\n\n  interrupt_received = .false.\n  half_seconds = 0\n\n  \n  call signal(sigint, signal_handler)\n  call signal(sigquit, signal_handler)\n\n  \n  do\n    if (usleep(half_second) == -1) &\n      print *, \"Call to usleep interrupted.\"\n\n    call atomic_ref(interrupt_received_ref, interrupt_received)\n    if (interrupt_received_ref) then\n      print \"(A,I0,A)\", \"Program ran for \", half_seconds / 2, \" second(s).\"\n      stop\n    end if\n\n    half_seconds = half_seconds + 1\n    print \"(I0)\", half_seconds\n  end do\n\ncontains\n\n  subroutine signal_handler(sig_num)\n    use, intrinsic :: iso_c_binding, only: C_INT\n    integer(C_INT), value, intent(in) :: sig_num\n    \n    \n\n    select case (sig_num)\n      case (sigint)\n        print *, \"Received SIGINT.\"\n      case (sigquit)\n        print *, \"Received SIGQUIT.\"\n    end select\n\n    call atomic_define(interrupt_received, .true.)\n  end subroutine signal_handler\n\nend program signal_handling\n", "target": "using System; \nclass Program\n{\n    static DateTime start;\n    static void Main(string[] args)\n    {\n        start = DateTime.Now;\n        \n        Console.CancelKeyPress += new ConsoleCancelEventHandler(Console_CancelKeyPress);\n        int counter = 0;\n        while (true)\n        {\n            Console.WriteLine(++counter);\n            System.Threading.Thread.Sleep(500);\n        }\n    }\n    static void Console_CancelKeyPress(object sender, ConsoleCancelEventArgs e)\n    {\n        var end = DateTime.Now;\n        Console.WriteLine(\"This program ran for {0:000.000} seconds.\", (end - start).TotalMilliseconds / 1000);\n        Environment.Exit(0);\n    }\n}\n"}
{"id": 19386, "name": "Handle a signal", "source": "Translate Fortran to Java: program signal_handling\n  use, intrinsic :: iso_fortran_env, only: atomic_logical_kind\n  implicit none\n\n  interface\n    integer(C_INT) function usleep(microseconds) bind(c)\n      use, intrinsic :: iso_c_binding, only: C_INT, C_INT32_T\n      integer(C_INT32_T), value :: microseconds\n    end function usleep\n  end interface\n\n  integer, parameter :: half_second = 500000\n  integer, parameter :: sigint = 2\n  integer, parameter :: sigquit = 3\n\n  logical(atomic_logical_kind) :: interrupt_received[*]\n  integer :: half_seconds\n  logical :: interrupt_received_ref\n\n  interrupt_received = .false.\n  half_seconds = 0\n\n  \n  call signal(sigint, signal_handler)\n  call signal(sigquit, signal_handler)\n\n  \n  do\n    if (usleep(half_second) == -1) &\n      print *, \"Call to usleep interrupted.\"\n\n    call atomic_ref(interrupt_received_ref, interrupt_received)\n    if (interrupt_received_ref) then\n      print \"(A,I0,A)\", \"Program ran for \", half_seconds / 2, \" second(s).\"\n      stop\n    end if\n\n    half_seconds = half_seconds + 1\n    print \"(I0)\", half_seconds\n  end do\n\ncontains\n\n  subroutine signal_handler(sig_num)\n    use, intrinsic :: iso_c_binding, only: C_INT\n    integer(C_INT), value, intent(in) :: sig_num\n    \n    \n\n    select case (sig_num)\n      case (sigint)\n        print *, \"Received SIGINT.\"\n      case (sigquit)\n        print *, \"Received SIGQUIT.\"\n    end select\n\n    call atomic_define(interrupt_received, .true.)\n  end subroutine signal_handler\n\nend program signal_handling\n", "target": "import sun.misc.Signal;\nimport sun.misc.SignalHandler;\n\npublic class ExampleSignalHandler {\n    public static void main(String... args) throws InterruptedException {\n        final long start = System.nanoTime();\n        Signal.handle(new Signal(\"INT\"), new SignalHandler() {\n            public void handle(Signal sig) {\n                System.out.format(\"\\nProgram execution took %f seconds\\n\", (System.nanoTime() - start) / 1e9f);\n                System.exit(0);\n            }\n        });\n        int counter = 0;\n        while(true) {\n            System.out.println(counter++);\n            Thread.sleep(500);\n        }\n    }\n}\n"}
{"id": 19387, "name": "Handle a signal", "source": "Translate Fortran to Python: program signal_handling\n  use, intrinsic :: iso_fortran_env, only: atomic_logical_kind\n  implicit none\n\n  interface\n    integer(C_INT) function usleep(microseconds) bind(c)\n      use, intrinsic :: iso_c_binding, only: C_INT, C_INT32_T\n      integer(C_INT32_T), value :: microseconds\n    end function usleep\n  end interface\n\n  integer, parameter :: half_second = 500000\n  integer, parameter :: sigint = 2\n  integer, parameter :: sigquit = 3\n\n  logical(atomic_logical_kind) :: interrupt_received[*]\n  integer :: half_seconds\n  logical :: interrupt_received_ref\n\n  interrupt_received = .false.\n  half_seconds = 0\n\n  \n  call signal(sigint, signal_handler)\n  call signal(sigquit, signal_handler)\n\n  \n  do\n    if (usleep(half_second) == -1) &\n      print *, \"Call to usleep interrupted.\"\n\n    call atomic_ref(interrupt_received_ref, interrupt_received)\n    if (interrupt_received_ref) then\n      print \"(A,I0,A)\", \"Program ran for \", half_seconds / 2, \" second(s).\"\n      stop\n    end if\n\n    half_seconds = half_seconds + 1\n    print \"(I0)\", half_seconds\n  end do\n\ncontains\n\n  subroutine signal_handler(sig_num)\n    use, intrinsic :: iso_c_binding, only: C_INT\n    integer(C_INT), value, intent(in) :: sig_num\n    \n    \n\n    select case (sig_num)\n      case (sigint)\n        print *, \"Received SIGINT.\"\n      case (sigquit)\n        print *, \"Received SIGQUIT.\"\n    end select\n\n    call atomic_define(interrupt_received, .true.)\n  end subroutine signal_handler\n\nend program signal_handling\n", "target": "import time\n\ndef counter():\n    n = 0\n    t1 = time.time()\n    while True:\n        try:\n            time.sleep(0.5)\n            n += 1\n            print n\n        except KeyboardInterrupt, e:\n            print 'Program has run for %5.3f seconds.' % (time.time() - t1)\n            break\n\ncounter()\n"}
{"id": 19585, "name": "Non-decimal radices_Output", "source": "Translate Fortran to C#: do n = 1, 33\n  write(*, \"(b6, o4, i4, z4)\") n, n, n, n\nend do\n", "target": "using System;\n\nnamespace NonDecimalRadicesOutput\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            for (int i = 0; i < 42; i++)\n            {\n                string binary = Convert.ToString(i, 2);\n                string octal = Convert.ToString(i, 8);\n                string hexadecimal = Convert.ToString(i, 16);\n                Console.WriteLine(string.Format(\"Decimal: {0}, Binary: {1}, Octal: {2}, Hexadecimal: {3}\", i, binary, octal, hexadecimal));\n            }\n\n            Console.ReadKey();\n        }\n    }\n}\n"}
{"id": 19588, "name": "Non-decimal radices_Output", "source": "Translate Fortran to Java: do n = 1, 33\n  write(*, \"(b6, o4, i4, z4)\") n, n, n, n\nend do\n", "target": "public static void main(String args[]){\n   for(int a= 0;a < 33;a++){\n      System.out.println(Integer.toBinaryString(a));\n      System.out.println(Integer.toOctalString(a));\n      System.out.println(Integer.toHexString(a));\n      \n      \n\n      System.out.printf(\"%3o %2d %2x\\n\",a ,a ,a); \n   }\n}\n"}
{"id": 19589, "name": "Non-decimal radices_Output", "source": "Translate Fortran to Python: do n = 1, 33\n  write(*, \"(b6, o4, i4, z4)\") n, n, n, n\nend do\n", "target": ">>> for n in range(34):\n  print \" {0:6b} {1:3o} {2:2d} {3:2X}\".format(n, n, n, n)\n  \n  \n  \n\n  \n      0   0  0  0\n      1   1  1  1\n     10   2  2  2\n     11   3  3  3\n    100   4  4  4\n    101   5  5  5\n    110   6  6  6\n    111   7  7  7\n   1000  10  8  8\n   1001  11  9  9\n   1010  12 10  A\n   1011  13 11  B\n   1100  14 12  C\n   1101  15 13  D\n   1110  16 14  E\n   1111  17 15  F\n  10000  20 16 10\n  10001  21 17 11\n  10010  22 18 12\n  10011  23 19 13\n  10100  24 20 14\n  10101  25 21 15\n  10110  26 22 16\n  10111  27 23 17\n  11000  30 24 18\n  11001  31 25 19\n  11010  32 26 1A\n  11011  33 27 1B\n  11100  34 28 1C\n  11101  35 29 1D\n  11110  36 30 1E\n  11111  37 31 1F\n 100000  40 32 20\n 100001  41 33 21\n>>>\n"}
{"id": 19938, "name": "Huffman coding", "source": "Translate Fortran to C#: \n\n\n\n\n\n\n\n\n\n\n\nmodule huffman\nimplicit none\ntype node\n  character (len=1 ), allocatable :: sym(:)\n  character (len=10), allocatable :: code(:) \n  integer                         :: freq\ncontains\n  procedure                       :: show => show_node\nend type\n\ntype queue\n  type(node), allocatable :: buf(:)\n  integer                 :: n = 0\ncontains\n  procedure :: extractmin\n  procedure :: append\n  procedure :: siftdown\nend type\n\ncontains\n\nsubroutine siftdown(this, a)\n  class (queue)           :: this\n  integer                 :: a, parent, child\n  associate (x => this%buf)\n  parent = a\n  do while(parent*2 <= this%n)\n    child = parent*2\n    if (child + 1 <= this%n) then \n      if (x(child+1)%freq < x(child)%freq ) then\n        child = child +1 \n      end if\n    end if\n    if (x(parent)%freq > x(child)%freq) then\n      x([child, parent]) = x([parent, child])\n      parent = child\n    else\n      exit\n    end if  \n  end do      \n  end associate\nend subroutine\n\nfunction extractmin(this) result (res)\n  class(queue) :: this\n  type(node)   :: res\n  res = this%buf(1)\n  this%buf(1) = this%buf(this%n)\n  this%n = this%n - 1\n  call this%siftdown(1)\nend function\n\nsubroutine append(this, x)\n  class(queue), intent(inout) :: this\n  type(node)                  :: x\n  type(node), allocatable     :: tmp(:)\n  integer                     :: i\n  this%n = this%n +1  \n  if (.not.allocated(this%buf)) allocate(this%buf(1))\n  if (size(this%buf)<this%n) then\n    allocate(tmp(2*size(this%buf)))\n    tmp(1:this%n-1) = this%buf\n    call move_alloc(tmp, this%buf)\n  end if\n  this%buf(this%n) = x\n  i = this%n\n  do \n    i = i / 2\n    if (i==0) exit\n    call this%siftdown(i)\n  end do\nend subroutine\n\nfunction join(a, b) result(c)\n  type(node)             :: a, b, c\n  integer                :: i, n, n1\n  n1 = size(a%sym)\n  n = n1 + size(b%sym)  \n  c%freq = a%freq + b%freq\n  allocate (c%sym(n), c%code(n))\n  do i = 1, n1\n    c%sym(i) = a%sym(i)\n    c%code(i) = \"0\" // trim(a%code(i))\n  end do\n  do i = 1, size(b%sym)\n    c%sym(i+n1) = b%sym(i)\n    c%code(i+n1) = \"1\" // trim(b%code(i))\n  end do\nend function\n\nsubroutine show_node(this)\n  class(node) :: this\n  integer     :: i\n  write(*, \"(*(g0,'-> ',g0,:,', '))\", advance=\"no\") &\n   (this%sym(i), trim(this%code(i)), i=1,size(this%sym))\n  print *\nend subroutine\n\nfunction create(letter, freq) result (this)\n  character :: letter\n  integer   :: freq\n  type(node) :: this\n  allocate(this%sym(1), this%code(1))\n  this%sym(1) = letter ; this%code(1) = \"\"\n  this%freq = freq\nend function\nend module \n\nprogram main\n  use huffman\n  character (len=*), parameter   :: txt = &\n   \"this is an example for huffman encoding\"\n  integer                        :: i, freq(0:255) = 0\n  type(queue)                    :: Q\n  type(node)                     :: x\n  do i = 1, len(txt)\n    freq(ichar(txt(i:i))) = freq(ichar(txt(i:i))) + 1 \n  end do\n  do i = 0, 255\n    if (freq(i)>0) then\n      call Q%append(create(char(i), freq(i)))\n    end if\n  end do\n  do i = 1, Q%n-1\n    call Q%append(join(Q%extractmin(),Q%extractmin()))\n  end do\n  x = Q%extractmin()\n  call x%show()\n  do i = 1, len(txt) \n    do k = 1, size(x%sym)\n      if (x%sym(k)==txt(i:i)) exit\n     end do\n     write (*, \"(a,'|')\", advance=\"no\")  trim(x%code(k))\n  end do\n  print *\nend program\n", "target": "using System;\nusing System.Collections.Generic;\n\nnamespace Huffman_Encoding\n{\n    public class PriorityQueue<T> where T : IComparable\n    {\n        protected List<T> LstHeap = new List<T>();\n\n        public virtual int Count\n        {\n            get { return LstHeap.Count; }\n        }\n\n        public virtual void Add(T val)\n        {\n            LstHeap.Add(val);\n            SetAt(LstHeap.Count - 1, val);\n            UpHeap(LstHeap.Count - 1);\n        }\n\n        public virtual T Peek()\n        {\n            if (LstHeap.Count == 0)\n            {\n                throw new IndexOutOfRangeException(\"Peeking at an empty priority queue\");\n            }\n\n            return LstHeap[0];\n        }\n\n        public virtual T Pop()\n        {\n            if (LstHeap.Count == 0)\n            {\n                throw new IndexOutOfRangeException(\"Popping an empty priority queue\");\n            }\n\n            T valRet = LstHeap[0];\n\n            SetAt(0, LstHeap[LstHeap.Count - 1]);\n            LstHeap.RemoveAt(LstHeap.Count - 1);\n            DownHeap(0);\n            return valRet;\n        }\n\n        protected virtual void SetAt(int i, T val)\n        {\n            LstHeap[i] = val;\n        }\n\n        protected bool RightSonExists(int i)\n        {\n            return RightChildIndex(i) < LstHeap.Count;\n        }\n\n        protected bool LeftSonExists(int i)\n        {\n            return LeftChildIndex(i) < LstHeap.Count;\n        }\n\n        protected int ParentIndex(int i)\n        {\n            return (i - 1) / 2;\n        }\n\n        protected int LeftChildIndex(int i)\n        {\n            return 2 * i + 1;\n        }\n\n        protected int RightChildIndex(int i)\n        {\n            return 2 * (i + 1);\n        }\n\n        protected T ArrayVal(int i)\n        {\n            return LstHeap[i];\n        }\n\n        protected T Parent(int i)\n        {\n            return LstHeap[ParentIndex(i)];\n        }\n\n        protected T Left(int i)\n        {\n            return LstHeap[LeftChildIndex(i)];\n        }\n\n        protected T Right(int i)\n        {\n            return LstHeap[RightChildIndex(i)];\n        }\n\n        protected void Swap(int i, int j)\n        {\n            T valHold = ArrayVal(i);\n            SetAt(i, LstHeap[j]);\n            SetAt(j, valHold);\n        }\n\n        protected void UpHeap(int i)\n        {\n            while (i > 0 && ArrayVal(i).CompareTo(Parent(i)) > 0)\n            {\n                Swap(i, ParentIndex(i));\n                i = ParentIndex(i);\n            }\n        }\n\n        protected void DownHeap(int i)\n        {\n            while (i >= 0)\n            {\n                int iContinue = -1;\n\n                if (RightSonExists(i) && Right(i).CompareTo(ArrayVal(i)) > 0)\n                {\n                    iContinue = Left(i).CompareTo(Right(i)) < 0 ? RightChildIndex(i) : LeftChildIndex(i);\n                }\n                else if (LeftSonExists(i) && Left(i).CompareTo(ArrayVal(i)) > 0)\n                {\n                    iContinue = LeftChildIndex(i);\n                }\n\n                if (iContinue >= 0 && iContinue < LstHeap.Count)\n                {\n                    Swap(i, iContinue);\n                }\n\n                i = iContinue;\n            }\n        }\n    }\n\n    internal class HuffmanNode<T> : IComparable\n    {\n        internal HuffmanNode(double probability, T value)\n        {\n            Probability = probability;\n            LeftSon = RightSon = Parent = null;\n            Value = value;\n            IsLeaf = true;\n        }\n\n        internal HuffmanNode(HuffmanNode<T> leftSon, HuffmanNode<T> rightSon)\n        {\n            LeftSon = leftSon;\n            RightSon = rightSon;\n            Probability = leftSon.Probability + rightSon.Probability;\n            leftSon.IsZero = true;\n            rightSon.IsZero = false;\n            leftSon.Parent = rightSon.Parent = this;\n            IsLeaf = false;\n        }\n\n        internal HuffmanNode<T> LeftSon { get; set; }\n        internal HuffmanNode<T> RightSon { get; set; }\n        internal HuffmanNode<T> Parent { get; set; }\n        internal T Value { get; set; }\n        internal bool IsLeaf { get; set; }\n\n        internal bool IsZero { get; set; }\n\n        internal int Bit\n        {\n            get { return IsZero ? 0 : 1; }\n        }\n\n        internal bool IsRoot\n        {\n            get { return Parent == null; }\n        }\n\n        internal double Probability { get; set; }\n\n        public int CompareTo(object obj)\n        {\n            return -Probability.CompareTo(((HuffmanNode<T>) obj).Probability);\n        }\n    }\n\n    public class Huffman<T> where T : IComparable\n    {\n        private readonly Dictionary<T, HuffmanNode<T>> _leafDictionary = new Dictionary<T, HuffmanNode<T>>();\n        private readonly HuffmanNode<T> _root;\n\n        public Huffman(IEnumerable<T> values)\n        {\n            var counts = new Dictionary<T, int>();\n            var priorityQueue = new PriorityQueue<HuffmanNode<T>>();\n            int valueCount = 0;\n\n            foreach (T value in values)\n            {\n                if (!counts.ContainsKey(value))\n                {\n                    counts[value] = 0;\n                }\n                counts[value]++;\n                valueCount++;\n            }\n\n            foreach (T value in counts.Keys)\n            {\n                var node = new HuffmanNode<T>((double) counts[value] / valueCount, value);\n                priorityQueue.Add(node);\n                _leafDictionary[value] = node;\n            }\n\n            while (priorityQueue.Count > 1)\n            {\n                HuffmanNode<T> leftSon = priorityQueue.Pop();\n                HuffmanNode<T> rightSon = priorityQueue.Pop();\n                var parent = new HuffmanNode<T>(leftSon, rightSon);\n                priorityQueue.Add(parent);\n            }\n\n            _root = priorityQueue.Pop();\n            _root.IsZero = false;\n        }\n\n        public List<int> Encode(T value)\n        {\n            var returnValue = new List<int>();\n            Encode(value, returnValue);\n            return returnValue;\n        }\n\n        public void Encode(T value, List<int> encoding)\n        {\n            if (!_leafDictionary.ContainsKey(value))\n            {\n                throw new ArgumentException(\"Invalid value in Encode\");\n            }\n            HuffmanNode<T> nodeCur = _leafDictionary[value];\n            var reverseEncoding = new List<int>();\n            while (!nodeCur.IsRoot)\n            {\n                reverseEncoding.Add(nodeCur.Bit);\n                nodeCur = nodeCur.Parent;\n            }\n\n            reverseEncoding.Reverse();\n            encoding.AddRange(reverseEncoding);\n        }\n\n        public List<int> Encode(IEnumerable<T> values)\n        {\n            var returnValue = new List<int>();\n\n            foreach (T value in values)\n            {\n                Encode(value, returnValue);\n            }\n            return returnValue;\n        }\n\n        public T Decode(List<int> bitString, ref int position)\n        {\n            HuffmanNode<T> nodeCur = _root;\n            while (!nodeCur.IsLeaf)\n            {\n                if (position > bitString.Count)\n                {\n                    throw new ArgumentException(\"Invalid bitstring in Decode\");\n                }\n                nodeCur = bitString[position++] == 0 ? nodeCur.LeftSon : nodeCur.RightSon;\n            }\n            return nodeCur.Value;\n        }\n\n        public List<T> Decode(List<int> bitString)\n        {\n            int position = 0;\n            var returnValue = new List<T>();\n\n            while (position != bitString.Count)\n            {\n                returnValue.Add(Decode(bitString, ref position));\n            }\n            return returnValue;\n        }\n    }\n\n    internal class Program\n    {\n        private const string Example = \"this is an example for huffman encoding\";\n\n        private static void Main()\n        {\n            var huffman = new Huffman<char>(Example);\n            List<int> encoding = huffman.Encode(Example);\n            List<char> decoding = huffman.Decode(encoding);\n            var outString = new string(decoding.ToArray());\n            Console.WriteLine(outString == Example ? \"Encoding/decoding worked\" : \"Encoding/Decoding failed\");\n\n            var chars = new HashSet<char>(Example);\n            foreach (char c in chars)\n            {\n                encoding = huffman.Encode(c);\n                Console.Write(\"{0}:  \", c);\n                foreach (int bit in encoding)\n                {\n                    Console.Write(\"{0}\", bit);\n                }\n                Console.WriteLine();\n            }\n            Console.ReadKey();\n        }\n    }\n}\n"}
{"id": 19942, "name": "Huffman coding", "source": "Translate Fortran to Java: \n\n\n\n\n\n\n\n\n\n\n\nmodule huffman\nimplicit none\ntype node\n  character (len=1 ), allocatable :: sym(:)\n  character (len=10), allocatable :: code(:) \n  integer                         :: freq\ncontains\n  procedure                       :: show => show_node\nend type\n\ntype queue\n  type(node), allocatable :: buf(:)\n  integer                 :: n = 0\ncontains\n  procedure :: extractmin\n  procedure :: append\n  procedure :: siftdown\nend type\n\ncontains\n\nsubroutine siftdown(this, a)\n  class (queue)           :: this\n  integer                 :: a, parent, child\n  associate (x => this%buf)\n  parent = a\n  do while(parent*2 <= this%n)\n    child = parent*2\n    if (child + 1 <= this%n) then \n      if (x(child+1)%freq < x(child)%freq ) then\n        child = child +1 \n      end if\n    end if\n    if (x(parent)%freq > x(child)%freq) then\n      x([child, parent]) = x([parent, child])\n      parent = child\n    else\n      exit\n    end if  \n  end do      \n  end associate\nend subroutine\n\nfunction extractmin(this) result (res)\n  class(queue) :: this\n  type(node)   :: res\n  res = this%buf(1)\n  this%buf(1) = this%buf(this%n)\n  this%n = this%n - 1\n  call this%siftdown(1)\nend function\n\nsubroutine append(this, x)\n  class(queue), intent(inout) :: this\n  type(node)                  :: x\n  type(node), allocatable     :: tmp(:)\n  integer                     :: i\n  this%n = this%n +1  \n  if (.not.allocated(this%buf)) allocate(this%buf(1))\n  if (size(this%buf)<this%n) then\n    allocate(tmp(2*size(this%buf)))\n    tmp(1:this%n-1) = this%buf\n    call move_alloc(tmp, this%buf)\n  end if\n  this%buf(this%n) = x\n  i = this%n\n  do \n    i = i / 2\n    if (i==0) exit\n    call this%siftdown(i)\n  end do\nend subroutine\n\nfunction join(a, b) result(c)\n  type(node)             :: a, b, c\n  integer                :: i, n, n1\n  n1 = size(a%sym)\n  n = n1 + size(b%sym)  \n  c%freq = a%freq + b%freq\n  allocate (c%sym(n), c%code(n))\n  do i = 1, n1\n    c%sym(i) = a%sym(i)\n    c%code(i) = \"0\" // trim(a%code(i))\n  end do\n  do i = 1, size(b%sym)\n    c%sym(i+n1) = b%sym(i)\n    c%code(i+n1) = \"1\" // trim(b%code(i))\n  end do\nend function\n\nsubroutine show_node(this)\n  class(node) :: this\n  integer     :: i\n  write(*, \"(*(g0,'-> ',g0,:,', '))\", advance=\"no\") &\n   (this%sym(i), trim(this%code(i)), i=1,size(this%sym))\n  print *\nend subroutine\n\nfunction create(letter, freq) result (this)\n  character :: letter\n  integer   :: freq\n  type(node) :: this\n  allocate(this%sym(1), this%code(1))\n  this%sym(1) = letter ; this%code(1) = \"\"\n  this%freq = freq\nend function\nend module \n\nprogram main\n  use huffman\n  character (len=*), parameter   :: txt = &\n   \"this is an example for huffman encoding\"\n  integer                        :: i, freq(0:255) = 0\n  type(queue)                    :: Q\n  type(node)                     :: x\n  do i = 1, len(txt)\n    freq(ichar(txt(i:i))) = freq(ichar(txt(i:i))) + 1 \n  end do\n  do i = 0, 255\n    if (freq(i)>0) then\n      call Q%append(create(char(i), freq(i)))\n    end if\n  end do\n  do i = 1, Q%n-1\n    call Q%append(join(Q%extractmin(),Q%extractmin()))\n  end do\n  x = Q%extractmin()\n  call x%show()\n  do i = 1, len(txt) \n    do k = 1, size(x%sym)\n      if (x%sym(k)==txt(i:i)) exit\n     end do\n     write (*, \"(a,'|')\", advance=\"no\")  trim(x%code(k))\n  end do\n  print *\nend program\n", "target": "import java.util.*;\n\nabstract class HuffmanTree implements Comparable<HuffmanTree> {\n    public final int frequency; \n    public HuffmanTree(int freq) { frequency = freq; }\n\n    \n    public int compareTo(HuffmanTree tree) {\n        return frequency - tree.frequency;\n    }\n}\n\nclass HuffmanLeaf extends HuffmanTree {\n    public final char value; \n   \n    public HuffmanLeaf(int freq, char val) {\n        super(freq);\n        value = val;\n    }\n}\n\nclass HuffmanNode extends HuffmanTree {\n    public final HuffmanTree left, right; \n   \n    public HuffmanNode(HuffmanTree l, HuffmanTree r) {\n        super(l.frequency + r.frequency);\n        left = l;\n        right = r;\n    }\n}\n\npublic class HuffmanCode {\n    \n    public static HuffmanTree buildTree(int[] charFreqs) {\n        PriorityQueue<HuffmanTree> trees = new PriorityQueue<HuffmanTree>();\n        \n        \n        for (int i = 0; i < charFreqs.length; i++)\n            if (charFreqs[i] > 0)\n                trees.offer(new HuffmanLeaf(charFreqs[i], (char)i));\n\n        assert trees.size() > 0;\n        \n        while (trees.size() > 1) {\n            \n            HuffmanTree a = trees.poll();\n            HuffmanTree b = trees.poll();\n\n            \n            trees.offer(new HuffmanNode(a, b));\n        }\n        return trees.poll();\n    }\n\n    public static void printCodes(HuffmanTree tree, StringBuffer prefix) {\n        assert tree != null;\n        if (tree instanceof HuffmanLeaf) {\n            HuffmanLeaf leaf = (HuffmanLeaf)tree;\n\n            \n            System.out.println(leaf.value + \"\\t\" + leaf.frequency + \"\\t\" + prefix);\n\n        } else if (tree instanceof HuffmanNode) {\n            HuffmanNode node = (HuffmanNode)tree;\n\n            \n            prefix.append('0');\n            printCodes(node.left, prefix);\n            prefix.deleteCharAt(prefix.length()-1);\n\n            \n            prefix.append('1');\n            printCodes(node.right, prefix);\n            prefix.deleteCharAt(prefix.length()-1);\n        }\n    }\n\n    public static void main(String[] args) {\n        String test = \"this is an example for huffman encoding\";\n\n        \n        \n        int[] charFreqs = new int[256];\n        \n        for (char c : test.toCharArray())\n            charFreqs[c]++;\n\n        \n        HuffmanTree tree = buildTree(charFreqs);\n\n        \n        System.out.println(\"SYMBOL\\tWEIGHT\\tHUFFMAN CODE\");\n        printCodes(tree, new StringBuffer());\n    }\n}\n"}
{"id": 19943, "name": "Huffman coding", "source": "Translate Fortran to Python: \n\n\n\n\n\n\n\n\n\n\n\nmodule huffman\nimplicit none\ntype node\n  character (len=1 ), allocatable :: sym(:)\n  character (len=10), allocatable :: code(:) \n  integer                         :: freq\ncontains\n  procedure                       :: show => show_node\nend type\n\ntype queue\n  type(node), allocatable :: buf(:)\n  integer                 :: n = 0\ncontains\n  procedure :: extractmin\n  procedure :: append\n  procedure :: siftdown\nend type\n\ncontains\n\nsubroutine siftdown(this, a)\n  class (queue)           :: this\n  integer                 :: a, parent, child\n  associate (x => this%buf)\n  parent = a\n  do while(parent*2 <= this%n)\n    child = parent*2\n    if (child + 1 <= this%n) then \n      if (x(child+1)%freq < x(child)%freq ) then\n        child = child +1 \n      end if\n    end if\n    if (x(parent)%freq > x(child)%freq) then\n      x([child, parent]) = x([parent, child])\n      parent = child\n    else\n      exit\n    end if  \n  end do      \n  end associate\nend subroutine\n\nfunction extractmin(this) result (res)\n  class(queue) :: this\n  type(node)   :: res\n  res = this%buf(1)\n  this%buf(1) = this%buf(this%n)\n  this%n = this%n - 1\n  call this%siftdown(1)\nend function\n\nsubroutine append(this, x)\n  class(queue), intent(inout) :: this\n  type(node)                  :: x\n  type(node), allocatable     :: tmp(:)\n  integer                     :: i\n  this%n = this%n +1  \n  if (.not.allocated(this%buf)) allocate(this%buf(1))\n  if (size(this%buf)<this%n) then\n    allocate(tmp(2*size(this%buf)))\n    tmp(1:this%n-1) = this%buf\n    call move_alloc(tmp, this%buf)\n  end if\n  this%buf(this%n) = x\n  i = this%n\n  do \n    i = i / 2\n    if (i==0) exit\n    call this%siftdown(i)\n  end do\nend subroutine\n\nfunction join(a, b) result(c)\n  type(node)             :: a, b, c\n  integer                :: i, n, n1\n  n1 = size(a%sym)\n  n = n1 + size(b%sym)  \n  c%freq = a%freq + b%freq\n  allocate (c%sym(n), c%code(n))\n  do i = 1, n1\n    c%sym(i) = a%sym(i)\n    c%code(i) = \"0\" // trim(a%code(i))\n  end do\n  do i = 1, size(b%sym)\n    c%sym(i+n1) = b%sym(i)\n    c%code(i+n1) = \"1\" // trim(b%code(i))\n  end do\nend function\n\nsubroutine show_node(this)\n  class(node) :: this\n  integer     :: i\n  write(*, \"(*(g0,'-> ',g0,:,', '))\", advance=\"no\") &\n   (this%sym(i), trim(this%code(i)), i=1,size(this%sym))\n  print *\nend subroutine\n\nfunction create(letter, freq) result (this)\n  character :: letter\n  integer   :: freq\n  type(node) :: this\n  allocate(this%sym(1), this%code(1))\n  this%sym(1) = letter ; this%code(1) = \"\"\n  this%freq = freq\nend function\nend module \n\nprogram main\n  use huffman\n  character (len=*), parameter   :: txt = &\n   \"this is an example for huffman encoding\"\n  integer                        :: i, freq(0:255) = 0\n  type(queue)                    :: Q\n  type(node)                     :: x\n  do i = 1, len(txt)\n    freq(ichar(txt(i:i))) = freq(ichar(txt(i:i))) + 1 \n  end do\n  do i = 0, 255\n    if (freq(i)>0) then\n      call Q%append(create(char(i), freq(i)))\n    end if\n  end do\n  do i = 1, Q%n-1\n    call Q%append(join(Q%extractmin(),Q%extractmin()))\n  end do\n  x = Q%extractmin()\n  call x%show()\n  do i = 1, len(txt) \n    do k = 1, size(x%sym)\n      if (x%sym(k)==txt(i:i)) exit\n     end do\n     write (*, \"(a,'|')\", advance=\"no\")  trim(x%code(k))\n  end do\n  print *\nend program\n", "target": "from heapq import heappush, heappop, heapify\nfrom collections import defaultdict\n\ndef encode(symb2freq):\n    \n    heap = [[wt, [sym, \"\"]] for sym, wt in symb2freq.items()]\n    heapify(heap)\n    while len(heap) > 1:\n        lo = heappop(heap)\n        hi = heappop(heap)\n        for pair in lo[1:]:\n            pair[1] = '0' + pair[1]\n        for pair in hi[1:]:\n            pair[1] = '1' + pair[1]\n        heappush(heap, [lo[0] + hi[0]] + lo[1:] + hi[1:])\n    return sorted(heappop(heap)[1:], key=lambda p: (len(p[-1]), p))\n\ntxt = \"this is an example for huffman encoding\"\nsymb2freq = defaultdict(int)\nfor ch in txt:\n    symb2freq[ch] += 1\n\n\nhuff = encode(symb2freq)\nprint \"Symbol\\tWeight\\tHuffman Code\"\nfor p in huff:\n    print \"%s\\t%s\\t%s\" % (p[0], symb2freq[p[0]], p[1])\n"}
{"id": 20500, "name": "Parallel calculations", "source": "Translate Fortran to C#: program Primes\n\n    use ISO_FORTRAN_ENV\n\n    implicit none\n\n    integer(int64), dimension(7) :: data = (/2099726827, 15780709, 1122725370, 15808973, 576460741, 12878611, 12757923/)\n    integer(int64), dimension(100) :: outprimes\n    integer(int64) :: largest_factor = 0, largest = 0, minim = 0, val = 0\n    integer(int16) :: count = 0, OMP_GET_THREAD_NUM\n\n    call omp_set_num_threads(4);\n    \n    do val = 1, 7\n        outprimes = 0\n        call find_factors(data(val), outprimes, count)\n        minim = minval(outprimes(1:count))\n        if (minim > largest_factor) then\n            largest_factor = minim\n            largest = data(val)\n        end if\n        write(*, fmt = '(A7,i0,A2,i12,100i12)') 'Thread ', OMP_GET_THREAD_NUM(), ': ', data(val), outprimes(1:count)\n    end do\n    \n\n    write(*, fmt = '(i0,A26,i0)') largest, ' have the Largest factor: ', largest_factor\n\n    return\n\ncontains\n\n    subroutine find_factors(n, d, count)\n        integer(int64), intent(in) :: n\n        integer(int64), dimension(:), intent(out) :: d\n        integer(int16), intent(out) :: count\n        integer(int16) :: i\n        integer(int64) :: div, next, rest\n\n        i = 1\n        div = 2; next = 3; rest = n\n\n        do while (rest /= 1)\n            do while (mod(rest, div) == 0)\n                d(i) = div\n                i = i + 1\n                rest = rest / div\n            end do\n            div = next\n            next = next + 2\n        end do\n        count = i - 1\n    end subroutine find_factors\n\nend program Primes\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\nclass Program\n{\n    public static List<int> PrimeFactors(int number)\n    {\n        var primes = new List<int>();\n        for (int div = 2; div <= number; div++)\n        {\n            while (number % div == 0)\n            {\n                primes.Add(div);\n                number = number / div;\n            }\n        }\n        return primes;\n    }\n\n    static void Main(string[] args)\n    {\n        int[] n = { 12757923, 12878611, 12757923, 15808973, 15780709, 197622519 };\n        \n        var factors = n.AsParallel().Select(PrimeFactors).ToList();\n        \n        var smallestFactors = factors.Select(thisNumbersFactors => thisNumbersFactors.Min()).ToList();\n        \n        int biggestFactor = smallestFactors.Max();\n        int whatIndexIsThat = smallestFactors.IndexOf(biggestFactor);\n        Console.WriteLine(\"{0} has the largest minimum prime factor: {1}\", n[whatIndexIsThat], biggestFactor);\n        Console.WriteLine(string.Join(\" \", factors[whatIndexIsThat]));\n    }\n}\n"}
{"id": 20503, "name": "Parallel calculations", "source": "Translate Fortran to Java: program Primes\n\n    use ISO_FORTRAN_ENV\n\n    implicit none\n\n    integer(int64), dimension(7) :: data = (/2099726827, 15780709, 1122725370, 15808973, 576460741, 12878611, 12757923/)\n    integer(int64), dimension(100) :: outprimes\n    integer(int64) :: largest_factor = 0, largest = 0, minim = 0, val = 0\n    integer(int16) :: count = 0, OMP_GET_THREAD_NUM\n\n    call omp_set_num_threads(4);\n    \n    do val = 1, 7\n        outprimes = 0\n        call find_factors(data(val), outprimes, count)\n        minim = minval(outprimes(1:count))\n        if (minim > largest_factor) then\n            largest_factor = minim\n            largest = data(val)\n        end if\n        write(*, fmt = '(A7,i0,A2,i12,100i12)') 'Thread ', OMP_GET_THREAD_NUM(), ': ', data(val), outprimes(1:count)\n    end do\n    \n\n    write(*, fmt = '(i0,A26,i0)') largest, ' have the Largest factor: ', largest_factor\n\n    return\n\ncontains\n\n    subroutine find_factors(n, d, count)\n        integer(int64), intent(in) :: n\n        integer(int64), dimension(:), intent(out) :: d\n        integer(int16), intent(out) :: count\n        integer(int16) :: i\n        integer(int64) :: div, next, rest\n\n        i = 1\n        div = 2; next = 3; rest = n\n\n        do while (rest /= 1)\n            do while (mod(rest, div) == 0)\n                d(i) = div\n                i = i + 1\n                rest = rest / div\n            end do\n            div = next\n            next = next + 2\n        end do\n        count = i - 1\n    end subroutine find_factors\n\nend program Primes\n", "target": "import static java.lang.System.out; \nimport static java.util.Arrays.stream;\nimport static java.util.Comparator.comparing;\n \npublic interface ParallelCalculations {\n    public static final long[] NUMBERS = {\n      12757923,\n      12878611,\n      12878893,\n      12757923,\n      15808973,\n      15780709,\n      197622519\n    };\n \n    public static void main(String... arguments) {\n      stream(NUMBERS)\n        .unordered()\n        .parallel()\n        .mapToObj(ParallelCalculations::minimalPrimeFactor)\n        .max(comparing(a -> a[0]))\n        .ifPresent(res -> out.printf(\n          \"%d has the largest minimum prime factor: %d%n\",\n          res[1],\n          res[0]\n        ));\n    }\n \n    public static long[] minimalPrimeFactor(long n) {\n      for (long i = 2; n >= i * i; i++) {\n        if (n % i == 0) {\n          return new long[]{i, n};\n        }\n      }\n      return new long[]{n, n};\n    }\n}\n"}
{"id": 20504, "name": "Parallel calculations", "source": "Translate Fortran to Python: program Primes\n\n    use ISO_FORTRAN_ENV\n\n    implicit none\n\n    integer(int64), dimension(7) :: data = (/2099726827, 15780709, 1122725370, 15808973, 576460741, 12878611, 12757923/)\n    integer(int64), dimension(100) :: outprimes\n    integer(int64) :: largest_factor = 0, largest = 0, minim = 0, val = 0\n    integer(int16) :: count = 0, OMP_GET_THREAD_NUM\n\n    call omp_set_num_threads(4);\n    \n    do val = 1, 7\n        outprimes = 0\n        call find_factors(data(val), outprimes, count)\n        minim = minval(outprimes(1:count))\n        if (minim > largest_factor) then\n            largest_factor = minim\n            largest = data(val)\n        end if\n        write(*, fmt = '(A7,i0,A2,i12,100i12)') 'Thread ', OMP_GET_THREAD_NUM(), ': ', data(val), outprimes(1:count)\n    end do\n    \n\n    write(*, fmt = '(i0,A26,i0)') largest, ' have the Largest factor: ', largest_factor\n\n    return\n\ncontains\n\n    subroutine find_factors(n, d, count)\n        integer(int64), intent(in) :: n\n        integer(int64), dimension(:), intent(out) :: d\n        integer(int16), intent(out) :: count\n        integer(int16) :: i\n        integer(int64) :: div, next, rest\n\n        i = 1\n        div = 2; next = 3; rest = n\n\n        do while (rest /= 1)\n            do while (mod(rest, div) == 0)\n                d(i) = div\n                i = i + 1\n                rest = rest / div\n            end do\n            div = next\n            next = next + 2\n        end do\n        count = i - 1\n    end subroutine find_factors\n\nend program Primes\n", "target": "from concurrent import futures\nfrom math import floor, sqrt\n \nNUMBERS = [\n    112272537195293,\n    112582718962171,\n    112272537095293,\n    115280098190773,\n    115797840077099,\n    1099726829285419]\n\n \ndef lowest_factor(n, _start=3):\n    if n % 2 == 0:\n        return 2\n    search_max = int(floor(sqrt(n))) + 1\n    for i in range(_start, search_max, 2):\n        if n % i == 0:\n            return i\n    return n\n\ndef prime_factors(n, lowest):\n    pf = []\n    while n > 1:\n        pf.append(lowest)\n        n //= lowest\n        lowest = lowest_factor(n, max(lowest, 3))\n    return pf\n\ndef prime_factors_of_number_with_lowest_prime_factor(NUMBERS):\n    with futures.ProcessPoolExecutor() as executor:\n        low_factor, number = max( (l, f) for l, f in zip(executor.map(lowest_factor, NUMBERS), NUMBERS) )\n        all_factors = prime_factors(number, low_factor)\n        return number, all_factors\n\n \ndef main():\n    print('For these numbers:')\n    print('\\n  '.join(str(p) for p in NUMBERS))\n    number, all_factors = prime_factors_of_number_with_lowest_prime_factor(NUMBERS)\n    print('    The one with the largest minimum prime factor is {}:'.format(number))\n    print('      All its prime factors in order are: {}'.format(all_factors))\n \nif __name__ == '__main__':\n    main()\n"}
{"id": 20630, "name": "Call a function in a shared library", "source": "Translate Fortran to C#: function  add_nf(a,b) bind(c, name='add_nf')\nuse, intrinsic :: iso_c_binding\nimplicit none\nreal(c_double), intent(in) :: a,b\nreal(c_double) :: add_nf\n\nadd_nf = a + b\nend function add_nf\n", "target": "using System.Runtime.InteropServices;\n\nclass Program {\n    [DllImport(\"fakelib.dll\")]\n    public static extern int fakefunction(int args);\n\n    static void Main(string[] args) {\n        int r = fakefunction(10);\n    }\n}\n"}
{"id": 20632, "name": "Call a function in a shared library", "source": "Translate Fortran to Java: function  add_nf(a,b) bind(c, name='add_nf')\nuse, intrinsic :: iso_c_binding\nimplicit none\nreal(c_double), intent(in) :: a,b\nreal(c_double) :: add_nf\n\nadd_nf = a + b\nend function add_nf\n", "target": "\n\nimport java.util.Collections;\nimport java.util.Random;\n\npublic class TrySort {\n    static boolean useC;\n    static {\n\ttry {\n\t    System.loadLibrary(\"TrySort\");\n\t    useC = true;\n\t} catch(UnsatisfiedLinkError e) {\n\t    useC = false;\n\t}\n    }\n    \n    static native void sortInC(int[] ary);\n    \n    static class IntList extends java.util.AbstractList<Integer> {\n\tint[] ary;\n\tIntList(int[] ary) { this.ary = ary; }\n\tpublic Integer get(int i) { return ary[i]; }\n\tpublic Integer set(int i, Integer j) {\n\t    Integer o = ary[i]; ary[i] = j; return o;\n\t}\n\tpublic int size() { return ary.length; }\n    }\n\n    static class ReverseAbsCmp\n\timplements java.util.Comparator<Integer>\n    {\n\tpublic int compare(Integer pa, Integer pb) {\n\t    \n\t    int a = pa > 0 ? -pa : pa;\n\t    int b = pb > 0 ? -pb : pb;\n\t    return a < b ? -1 : a > b ? 1 : 0;\n\t}\n    }\n    \n    static void sortInJava(int[] ary) {\n\tCollections.sort(new IntList(ary), new ReverseAbsCmp());\n    }\n\n    public static void main(String[] args) {\n\t\n\tint[] ary = new int[1000000];\n\tRandom rng = new Random();\n\tfor (int i = 0; i < ary.length; i++)\n\t    ary[i] = rng.nextInt();\n\n\t\n\tif (useC) {\n\t    System.out.print(\"Sorting in C...  \");\n\t    sortInC(ary);\n\t} else {\n\t    System.out.print\n\t\t(\"Missing library for C!  Sorting in Java...  \");\n\t    sortInJava(ary);\n\t}\n\n\tfor (int i = 0; i < ary.length - 1; i++) {\n\t    int a = ary[i];\n\t    int b = ary[i + 1];\n\t    if ((a > 0 ? -a : a) > (b > 0 ? -b : b)) {\n\t\tSystem.out.println(\"*BUG IN SORT*\");\n\t\tSystem.exit(1);\n\t    }\n\t}\n\tSystem.out.println(\"ok\");\n    }\n}\n"}
{"id": 20633, "name": "Call a function in a shared library", "source": "Translate Fortran to Python: function  add_nf(a,b) bind(c, name='add_nf')\nuse, intrinsic :: iso_c_binding\nimplicit none\nreal(c_double), intent(in) :: a,b\nreal(c_double) :: add_nf\n\nadd_nf = a + b\nend function add_nf\n", "target": "import ctypes\n  \nuser32_dll = ctypes.cdll.LoadLibrary('User32.dll')\nprint user32_dll.GetDoubleClickTime()\n"}
{"id": 20766, "name": "Reduced row echelon form", "source": "Translate Fortran to C#: module Rref\n  implicit none\ncontains\n  subroutine to_rref(matrix)\n    real, dimension(:,:), intent(inout) :: matrix\n\n    integer :: pivot, norow, nocolumn\n    integer :: r, i\n    real, dimension(:), allocatable :: trow\n\n    pivot = 1\n    norow = size(matrix, 1)\n    nocolumn = size(matrix, 2)\n\n    allocate(trow(nocolumn))\n    \n    do r = 1, norow\n       if ( nocolumn <= pivot ) exit\n       i = r\n       do while ( matrix(i, pivot) == 0 )\n          i = i + 1\n          if ( norow == i ) then\n             i = r\n             pivot = pivot + 1\n             if ( nocolumn == pivot ) return\n          end if\n       end do\n       trow = matrix(i, :)\n       matrix(i, :) = matrix(r, :)\n       matrix(r, :) = trow\n       matrix(r, :) = matrix(r, :) / matrix(r, pivot)\n       do i = 1, norow\n          if ( i /= r ) matrix(i, :) = matrix(i, :) - matrix(r, :) * matrix(i, pivot) \n       end do\n       pivot = pivot + 1\n    end do\n    deallocate(trow)\n  end subroutine to_rref\nend module Rref\n", "target": "using System;\n\nnamespace rref\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            int[,] matrix = new int[3, 4]{\n                {  1, 2, -1,  -4 },\n                {  2, 3, -1, -11 },\n                { -2, 0, -3,  22 }\n            };\n            matrix = rref(matrix);   \n        }\n\n        private static int[,] rref(int[,] matrix)\n        {            \n            int lead = 0, rowCount = matrix.GetLength(0), columnCount = matrix.GetLength(1);\n            for (int r = 0; r < rowCount; r++)\n            {\n                if (columnCount <= lead) break;\n                int i = r;\n                while (matrix[i, lead] == 0)\n                {\n                    i++;\n                    if (i == rowCount)\n                    {\n                        i = r;\n                        lead++;\n                        if (columnCount == lead)\n                        {\n                        lead--;\n                        break;\n                        }\n                    }\n                }\n                for (int j = 0; j < columnCount; j++)\n                {\n                    int temp = matrix[r, j];\n                    matrix[r, j] = matrix[i, j];\n                    matrix[i, j] = temp;\n                }\n                int div = matrix[r, lead];\n                if(div != 0)\n                    for (int j = 0; j < columnCount; j++) matrix[r, j] /= div;                \n                for (int j = 0; j < rowCount; j++)\n                {\n                    if (j != r)\n                    {\n                        int sub = matrix[j, lead];\n                        for (int k = 0; k < columnCount; k++) matrix[j, k] -= (sub * matrix[r, k]);\n                    }\n                }\n                lead++;\n            }\n            return matrix;\n        }\n    }\n}\n"}
{"id": 20769, "name": "Reduced row echelon form", "source": "Translate Fortran to Java: module Rref\n  implicit none\ncontains\n  subroutine to_rref(matrix)\n    real, dimension(:,:), intent(inout) :: matrix\n\n    integer :: pivot, norow, nocolumn\n    integer :: r, i\n    real, dimension(:), allocatable :: trow\n\n    pivot = 1\n    norow = size(matrix, 1)\n    nocolumn = size(matrix, 2)\n\n    allocate(trow(nocolumn))\n    \n    do r = 1, norow\n       if ( nocolumn <= pivot ) exit\n       i = r\n       do while ( matrix(i, pivot) == 0 )\n          i = i + 1\n          if ( norow == i ) then\n             i = r\n             pivot = pivot + 1\n             if ( nocolumn == pivot ) return\n          end if\n       end do\n       trow = matrix(i, :)\n       matrix(i, :) = matrix(r, :)\n       matrix(r, :) = trow\n       matrix(r, :) = matrix(r, :) / matrix(r, pivot)\n       do i = 1, norow\n          if ( i /= r ) matrix(i, :) = matrix(i, :) - matrix(r, :) * matrix(i, pivot) \n       end do\n       pivot = pivot + 1\n    end do\n    deallocate(trow)\n  end subroutine to_rref\nend module Rref\n", "target": "import java.util.*;\nimport java.lang.Math;\nimport org.apache.commons.math.fraction.Fraction;\nimport org.apache.commons.math.fraction.FractionConversionException;\n\n\nclass Matrix {\n\tLinkedList<LinkedList<Fraction>> matrix;\n\tint numRows;\n\tint numCols;\t\n\t\n\tstatic class Coordinate {\n\t\tint row;\n\t\tint col;\n\n\t\tCoordinate(int r, int c) {\n\t\t\trow = r;\n\t\t\tcol = c;\n\t\t}\n\n\t\tpublic String toString() {\n\t\t\treturn \"(\" + row + \", \" + col + \")\";\n\t\t}\n\t}\n\n\tMatrix(double [][] m) {\n\t\tnumRows = m.length;\t\n\t\tnumCols = m[0].length;\n\n\t\tmatrix = new LinkedList<LinkedList<Fraction>>();\n\n\t\tfor (int i = 0; i < numRows; i++) {\n\t\t\tmatrix.add(new LinkedList<Fraction>());\n\t\t\tfor (int j = 0; j < numCols; j++) {\n\t\t\t\ttry {\n\t\t\t\t\tmatrix.get(i).add(new Fraction(m[i][j]));\n\t\t\t\t} catch (FractionConversionException e) {\n\t\t\t\t\tSystem.err.println(\"Fraction could not be converted from double by apache commons . . .\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic void Interchange(Coordinate a, Coordinate b) {\n\t\tLinkedList<Fraction> temp = matrix.get(a.row);\n\t\tmatrix.set(a.row, matrix.get(b.row));\t\t\n\t\tmatrix.set(b.row, temp);\n\n\t\tint t = a.row;\n\t\ta.row = b.row;\n\t\tb.row = t;\n\t} \n\n\tpublic void Scale(Coordinate x, Fraction d) {\n\t\tLinkedList<Fraction> row = matrix.get(x.row);\n\t\tfor (int i = 0; i < numCols; i++) {\n\t\t\trow.set(i, row.get(i).multiply(d));\n\t\t}\n\t}\n\n\tpublic void MultiplyAndAdd(Coordinate to, Coordinate from, Fraction scalar) {\n\t\tLinkedList<Fraction> row = matrix.get(to.row);\n\t\tLinkedList<Fraction> rowMultiplied = matrix.get(from.row);\n\n\t\tfor (int i = 0; i < numCols; i++) {\n\t\t\trow.set(i, row.get(i).add((rowMultiplied.get(i).multiply(scalar))));\n\t\t}\n\t}\n\n\tpublic void RREF() {\n\t\tCoordinate pivot = new Coordinate(0,0);\n\n\t\tint submatrix = 0;\n\t\tfor (int x = 0; x < numCols; x++) {\n\t\t\tpivot = new Coordinate(pivot.row, x);\n\t\t\t\n\t\t\t\t\n\t\t\t\tfor (int i = x; i < numCols; i++) {\n\t\t\t\t\tif (isColumnZeroes(pivot) == false) {\n\t\t\t\t\t\tbreak;\t\n\t\t\t\t\t} else {\n\t\t\t\t\t\tpivot.col = i;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\n\t\t\t\t\n\t\t\t\tpivot = findPivot(pivot);\n\t\t\t\n\t\t\t\tif (getCoordinate(pivot).doubleValue() == 0.0) {\n\t\t\t\t\tpivot.row++;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\t\n\t\t\t\t\n\t\t\t\tif (pivot.row != submatrix) {\n\t\t\t\t\tInterchange(new Coordinate(submatrix, pivot.col), pivot);\n\t\t\t\t}\n\t\t\n\t\t\t\t\n\t\t\t\tif (getCoordinate(pivot).doubleValue() != 1) {\n\t\t\t\t\t\n\t\t\t\t\tFraction scalar = getCoordinate(pivot).reciprocal();\n\t\t\t\t\tScale(pivot, scalar);\n\t\t\t\t}\n\t\t\t\n\t\t\t\t\n\t\t\t\t\n\t\t\t\tfor (int i = pivot.row; i < numRows; i++) {\n\t\t\t\t\tif (i == pivot.row) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tCoordinate belowPivot = new Coordinate(i, pivot.col);\n\t\t\t\t\tFraction complement = (getCoordinate(belowPivot).negate().divide(getCoordinate(pivot)));\n\t\t\t\t\tMultiplyAndAdd(belowPivot, pivot, complement);\n\t\t\t\t}\n\t\t\t\n\t\t\t\t\n\t\t\t\t\n\t\t\t\t\t\n\t\t\t\tfor (int i = pivot.row; i >= 0; i--) {\n\t\t\t\t\tif (i == pivot.row) {\n\t\t\t\t\t\tif (getCoordinate(pivot).doubleValue() != 1.0) {\n\t\t\t\t\t\t\tScale(pivot, getCoordinate(pivot).reciprocal());\t\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif (i == pivot.row) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\n\t\t\t\t\tCoordinate abovePivot = new Coordinate(i, pivot.col);\n\t\t\t\t\tFraction complement = (getCoordinate(abovePivot).negate().divide(getCoordinate(pivot)));\n\t\t\t\t\tMultiplyAndAdd(abovePivot, pivot, complement);\n\t\t\t\t}\n\t\t\t\n\t\t\t\t\n\t\t\t\t\n\t\t\t\tif ((pivot.row + 1) >= numRows || isRowZeroes(new Coordinate(pivot.row+1, pivot.col))) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tsubmatrix++;\n\t\t\t\tpivot.row++;\n\t\t}\n\t}\n\t\n\tpublic boolean isColumnZeroes(Coordinate a) {\n\t\tfor (int i = 0; i < numRows; i++) {\n\t\t\tif (matrix.get(i).get(a.col).doubleValue() != 0.0) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\treturn true;\n\t}\n\n\tpublic boolean isRowZeroes(Coordinate a) {\n\t\tfor (int i = 0; i < numCols; i++) {\n\t\t\tif (matrix.get(a.row).get(i).doubleValue() != 0.0) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\treturn true;\n\t}\n\n\tpublic Coordinate findPivot(Coordinate a) {\n\t\tint first_row = a.row;\n\t\tCoordinate pivot = new Coordinate(a.row, a.col);\n\t\tCoordinate current = new Coordinate(a.row, a.col);\t\n\n\t\tfor (int i = a.row; i < (numRows - first_row); i++) {\n\t\t\tcurrent.row = i;\n\t\t\tif (getCoordinate(current).doubleValue() == 1.0) {\n\t\t\t\tInterchange(current, a);\n\t\t\t}\n\t\t}\n\n\t\tcurrent.row = a.row;\n\t\tfor (int i = current.row; i < (numRows - first_row); i++) {\n\t\t\tcurrent.row = i;\n\t\t\tif (getCoordinate(current).doubleValue() != 0) {\n\t\t\t\tpivot.row = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\n\t\t\n\t\treturn pivot;\t\n\t}\t\n\n\tpublic Fraction getCoordinate(Coordinate a) {\n\t\treturn matrix.get(a.row).get(a.col);\n\t}\n\n\tpublic String toString() {\n\t\treturn matrix.toString().replace(\"], \", \"]\\n\");\n\t}\n\n\tpublic static void main (String[] args) {\n        \tdouble[][] matrix_1 = {\n\t\t\t{1, 2, -1, -4},\n\t\t\t{2, 3, -1, -11},\n\t\t\t{-2, 0, -3, 22}\n\t\t};\n\n\t\tMatrix x = new Matrix(matrix_1);\n\t\tSystem.out.println(\"before\\n\" + x.toString() + \"\\n\");\n\t\tx.RREF();\n\t\tSystem.out.println(\"after\\n\" + x.toString() + \"\\n\");\n\n\t\tdouble matrix_2 [][] = {\n\t\t\t{2, 0, -1, 0, 0},\n\t\t\t{1, 0, 0, -1, 0},\n\t\t\t{3, 0, 0, -2, -1},\n\t\t\t{0, 1, 0, 0, -2},\n\t\t\t{0, 1, -1, 0, 0}\n\t\t};\n\t\n\t\tMatrix y = new Matrix(matrix_2);\n\t\tSystem.out.println(\"before\\n\" + y.toString() + \"\\n\");\n\t\ty.RREF();\n\t\tSystem.out.println(\"after\\n\" + y.toString() + \"\\n\");\n\n\t\tdouble matrix_3 [][] = {\n\t\t\t{1, 2, 3, 4, 3, 1},\n\t\t\t{2, 4, 6, 2, 6, 2},\n\t\t\t{3, 6, 18, 9, 9, -6},\n\t\t\t{4, 8, 12, 10, 12, 4},\n\t\t\t{5, 10, 24, 11, 15, -4}\n\t\t};\n\n\t\tMatrix z = new Matrix(matrix_3);\n\t\tSystem.out.println(\"before\\n\" + z.toString() + \"\\n\");\n\t\tz.RREF();\n\t\tSystem.out.println(\"after\\n\" + z.toString() + \"\\n\");\n\n\t\tdouble matrix_4 [][] = {\n\t\t\t{0, 1},\n\t\t\t{1, 2},\n\t\t\t{0,5}\n\t\t};\n\n\t\tMatrix a = new Matrix(matrix_4);\n\t\tSystem.out.println(\"before\\n\" + a.toString() + \"\\n\");\n\t\ta.RREF();\n\t\tSystem.out.println(\"after\\n\" + a.toString() + \"\\n\");\n\t}\t\n}\n"}
{"id": 20770, "name": "Reduced row echelon form", "source": "Translate Fortran to Python: module Rref\n  implicit none\ncontains\n  subroutine to_rref(matrix)\n    real, dimension(:,:), intent(inout) :: matrix\n\n    integer :: pivot, norow, nocolumn\n    integer :: r, i\n    real, dimension(:), allocatable :: trow\n\n    pivot = 1\n    norow = size(matrix, 1)\n    nocolumn = size(matrix, 2)\n\n    allocate(trow(nocolumn))\n    \n    do r = 1, norow\n       if ( nocolumn <= pivot ) exit\n       i = r\n       do while ( matrix(i, pivot) == 0 )\n          i = i + 1\n          if ( norow == i ) then\n             i = r\n             pivot = pivot + 1\n             if ( nocolumn == pivot ) return\n          end if\n       end do\n       trow = matrix(i, :)\n       matrix(i, :) = matrix(r, :)\n       matrix(r, :) = trow\n       matrix(r, :) = matrix(r, :) / matrix(r, pivot)\n       do i = 1, norow\n          if ( i /= r ) matrix(i, :) = matrix(i, :) - matrix(r, :) * matrix(i, pivot) \n       end do\n       pivot = pivot + 1\n    end do\n    deallocate(trow)\n  end subroutine to_rref\nend module Rref\n", "target": "def ToReducedRowEchelonForm( M):\n    if not M: return\n    lead = 0\n    rowCount = len(M)\n    columnCount = len(M[0])\n    for r in range(rowCount):\n        if lead >= columnCount:\n            return\n        i = r\n        while M[i][lead] == 0:\n            i += 1\n            if i == rowCount:\n                i = r\n                lead += 1\n                if columnCount == lead:\n                    return\n        M[i],M[r] = M[r],M[i]\n        lv = M[r][lead]\n        M[r] = [ mrx / float(lv) for mrx in M[r]]\n        for i in range(rowCount):\n            if i != r:\n                lv = M[i][lead]\n                M[i] = [ iv - lv*rv for rv,iv in zip(M[r],M[i])]\n        lead += 1\n\n\nmtx = [\n   [ 1, 2, -1, -4],\n   [ 2, 3, -1, -11],\n   [-2, 0, -3, 22],]\n\nToReducedRowEchelonForm( mtx )\n\nfor rw in mtx:\n  print ', '.join( (str(rv) for rv in rw) )\n"}
{"id": 21269, "name": "Hamming numbers", "source": "Translate Fortran to C#: program Hamming_Test\n  use big_integer_module\n  implicit none\n  \n  call Hamming(1,20)\n  write(*,*)\n  call Hamming(1691)\n  write(*,*)\n  call Hamming(1000000)\n   \ncontains\n\nsubroutine Hamming(first, last)\n\n  integer, intent(in) :: first\n  integer, intent(in), optional :: last\n  integer :: i, n, i2, i3, i5, lim\n  type(big_integer), allocatable :: hnums(:)\n\n  if(present(last)) then\n    lim = last\n  else\n    lim = first\n  end if\n\n  if(first < 1 .or. lim > 2500000 ) then\n    write(*,*) \"Invalid input\"\n    return\n  end if\n  \n  allocate(hnums(lim))\n  \n  i2 = 1 ;  i3 = 1 ; i5 = 1  \n  hnums(1) = 1\n  n = 1\n  do while(n < lim)\n    n = n + 1\n    hnums(n) = mini(2*hnums(i2), 3*hnums(i3), 5*hnums(i5))\n    if(2*hnums(i2) == hnums(n)) i2 = i2 + 1\n    if(3*hnums(i3) == hnums(n)) i3 = i3 + 1\n    if(5*hnums(i5) == hnums(n)) i5 = i5 + 1\n  end do\n  \n  if(present(last)) then\n    do i = first, last\n      call print_big(hnums(i))\n      write(*, \"(a)\", advance=\"no\") \" \"\n    end do\n  else\n    call print_big(hnums(first))\n  end if\n  \n  deallocate(hnums)\nend subroutine\n \nfunction mini(a, b, c)\n  type(big_integer) :: mini\n  type(big_integer), intent(in) :: a, b, c\n   \n  if(a < b ) then \n    if(a < c) then\n      mini = a\n    else\n      mini = c\n    end if\n  else if(b < c) then\n    mini = b\n  else\n    mini = c\n  end if \nend function mini \nend program\n", "target": "using System;\nusing System.Numerics;\nusing System.Linq;\n\nnamespace Hamming {\n\n    class MainClass {\n\n        public static BigInteger Hamming(int n) {\n            BigInteger two = 2, three = 3, five = 5;\n            var h = new BigInteger[n];\n            h[0] = 1;\n            BigInteger x2 = 2, x3 = 3, x5 = 5;\n            int i = 0, j = 0, k = 0;\n            \n            for (int index = 1; index < n; index++) {\n                h[index] = BigInteger.Min(x2, BigInteger.Min(x3, x5));\n                if (h[index] == x2) x2 = two * h[++i];\n                if (h[index] == x3) x3 = three * h[++j];\n                if (h[index] == x5) x5 = five * h[++k];\n            }\n            return h[n - 1];\n        }\n\n        public static void Main(string[] args) {\n            Console.WriteLine(string.Join(\" \", Enumerable.Range(1, 20).ToList().Select(x => Hamming(x))));\n            Console.WriteLine(Hamming(1691));\n            Console.WriteLine(Hamming(1000000));\n        }\n    }\n}\n"}
{"id": 21272, "name": "Hamming numbers", "source": "Translate Fortran to Java: program Hamming_Test\n  use big_integer_module\n  implicit none\n  \n  call Hamming(1,20)\n  write(*,*)\n  call Hamming(1691)\n  write(*,*)\n  call Hamming(1000000)\n   \ncontains\n\nsubroutine Hamming(first, last)\n\n  integer, intent(in) :: first\n  integer, intent(in), optional :: last\n  integer :: i, n, i2, i3, i5, lim\n  type(big_integer), allocatable :: hnums(:)\n\n  if(present(last)) then\n    lim = last\n  else\n    lim = first\n  end if\n\n  if(first < 1 .or. lim > 2500000 ) then\n    write(*,*) \"Invalid input\"\n    return\n  end if\n  \n  allocate(hnums(lim))\n  \n  i2 = 1 ;  i3 = 1 ; i5 = 1  \n  hnums(1) = 1\n  n = 1\n  do while(n < lim)\n    n = n + 1\n    hnums(n) = mini(2*hnums(i2), 3*hnums(i3), 5*hnums(i5))\n    if(2*hnums(i2) == hnums(n)) i2 = i2 + 1\n    if(3*hnums(i3) == hnums(n)) i3 = i3 + 1\n    if(5*hnums(i5) == hnums(n)) i5 = i5 + 1\n  end do\n  \n  if(present(last)) then\n    do i = first, last\n      call print_big(hnums(i))\n      write(*, \"(a)\", advance=\"no\") \" \"\n    end do\n  else\n    call print_big(hnums(first))\n  end if\n  \n  deallocate(hnums)\nend subroutine\n \nfunction mini(a, b, c)\n  type(big_integer) :: mini\n  type(big_integer), intent(in) :: a, b, c\n   \n  if(a < b ) then \n    if(a < c) then\n      mini = a\n    else\n      mini = c\n    end if\n  else if(b < c) then\n    mini = b\n  else\n    mini = c\n  end if \nend function mini \nend program\n", "target": "import java.math.BigInteger;\nimport java.util.PriorityQueue;\n\nfinal class Hamming {\n    private static BigInteger THREE = BigInteger.valueOf(3);\n    private static BigInteger FIVE = BigInteger.valueOf(5);\n\n    private static void updateFrontier(BigInteger x,\n                                       PriorityQueue<BigInteger> pq) {\n        pq.offer(x.shiftLeft(1));\n        pq.offer(x.multiply(THREE));\n        pq.offer(x.multiply(FIVE));\n    }\n\n    public static BigInteger hamming(int n) {\n        if (n <= 0)\n            throw new IllegalArgumentException(\"Invalid parameter\");\n        PriorityQueue<BigInteger> frontier = new PriorityQueue<BigInteger>();\n        updateFrontier(BigInteger.ONE, frontier);\n        BigInteger lowest = BigInteger.ONE;\n        for (int i = 1; i < n; i++) {\n            lowest = frontier.poll();\n            while (frontier.peek().equals(lowest))\n                frontier.poll();\n            updateFrontier(lowest, frontier);\n        }\n        return lowest;\n    }\n\n    public static void main(String[] args) {\n        System.out.print(\"Hamming(1 .. 20) =\");\n        for (int i = 1; i < 21; i++)\n             System.out.print(\" \" + hamming(i));\n        System.out.println(\"\\nHamming(1691) = \" + hamming(1691));\n        System.out.println(\"Hamming(1000000) = \" + hamming(1000000));\n    }\n}\n"}
{"id": 21273, "name": "Hamming numbers", "source": "Translate Fortran to Python: program Hamming_Test\n  use big_integer_module\n  implicit none\n  \n  call Hamming(1,20)\n  write(*,*)\n  call Hamming(1691)\n  write(*,*)\n  call Hamming(1000000)\n   \ncontains\n\nsubroutine Hamming(first, last)\n\n  integer, intent(in) :: first\n  integer, intent(in), optional :: last\n  integer :: i, n, i2, i3, i5, lim\n  type(big_integer), allocatable :: hnums(:)\n\n  if(present(last)) then\n    lim = last\n  else\n    lim = first\n  end if\n\n  if(first < 1 .or. lim > 2500000 ) then\n    write(*,*) \"Invalid input\"\n    return\n  end if\n  \n  allocate(hnums(lim))\n  \n  i2 = 1 ;  i3 = 1 ; i5 = 1  \n  hnums(1) = 1\n  n = 1\n  do while(n < lim)\n    n = n + 1\n    hnums(n) = mini(2*hnums(i2), 3*hnums(i3), 5*hnums(i5))\n    if(2*hnums(i2) == hnums(n)) i2 = i2 + 1\n    if(3*hnums(i3) == hnums(n)) i3 = i3 + 1\n    if(5*hnums(i5) == hnums(n)) i5 = i5 + 1\n  end do\n  \n  if(present(last)) then\n    do i = first, last\n      call print_big(hnums(i))\n      write(*, \"(a)\", advance=\"no\") \" \"\n    end do\n  else\n    call print_big(hnums(first))\n  end if\n  \n  deallocate(hnums)\nend subroutine\n \nfunction mini(a, b, c)\n  type(big_integer) :: mini\n  type(big_integer), intent(in) :: a, b, c\n   \n  if(a < b ) then \n    if(a < c) then\n      mini = a\n    else\n      mini = c\n    end if\n  else if(b < c) then\n    mini = b\n  else\n    mini = c\n  end if \nend function mini \nend program\n", "target": "from itertools import islice\n\ndef hamming2():\n    \n    h = 1\n    _h=[h]    \n    multipliers  = (2, 3, 5)\n    multindeces  = [0 for i in multipliers] \n    multvalues   = [x * _h[i] for x,i in zip(multipliers, multindeces)]\n    yield h\n    while True:\n        h = min(multvalues)\n        _h.append(h)\n        for (n,(v,x,i)) in enumerate(zip(multvalues, multipliers, multindeces)):\n            if v == h:\n                i += 1\n                multindeces[n] = i\n                multvalues[n]  = x * _h[i]\n        \n        mini = min(multindeces)\n        if mini >= 1000:\n            del _h[:mini]\n            multindeces = [i - mini for i in multindeces]\n        \n        yield h\n"}
{"id": 21442, "name": "Topological sort", "source": "Translate Fortran to C#:       SUBROUTINE TSORT(NL,ND,IDEP,IORD,IPOS,NO)\n      IMPLICIT NONE\n      INTEGER NL,ND,NO,IDEP(ND,2),IORD(NL),IPOS(NL),I,J,K,IL,IR,IPL,IPR\n      DO 10 I=1,NL\n      IORD(I)=I\n   10 IPOS(I)=I\n      K=1\n   20 J=K\n      K=NL+1\n      DO 30 I=1,ND\n      IL=IDEP(I,1)\n      IR=IDEP(I,2)\n      IPL=IPOS(IL)\n      IPR=IPOS(IR)\n      IF(IL.EQ.IR .OR. IPL.GE.K .OR. IPL.LT.J .OR. IPR.LT.J) GO TO 30\n      K=K-1\n      IPOS(IORD(K))=IPL\n      IPOS(IL)=K\n      IORD(IPL)=IORD(K)\n      IORD(K)=IL\n   30 CONTINUE\n      IF(K.GT.J) GO TO 20\n      NO=J-1\n      END\n", "target": "namespace Algorithms\n{\n    using System;\n    using System.Collections.Generic;\n    using System.Linq;\n\n    public class TopologicalSorter<ValueType>\n    {\n        private class Relations\n        {\n            public int Dependencies = 0;\n            public HashSet<ValueType> Dependents = new HashSet<ValueType>();\n        }\n\n        private Dictionary<ValueType, Relations> _map = new Dictionary<ValueType, Relations>();\n\n        public void Add(ValueType obj)\n        {\n            if (!_map.ContainsKey(obj)) _map.Add(obj, new Relations());\n        }\n\n        public void Add(ValueType obj, ValueType dependency)\n        {\n            if (dependency.Equals(obj)) return;\n\n            if (!_map.ContainsKey(dependency)) _map.Add(dependency, new Relations());\n\n            var dependents = _map[dependency].Dependents;\n\n            if (!dependents.Contains(obj))\n            {\n                dependents.Add(obj);\n\n                if (!_map.ContainsKey(obj)) _map.Add(obj, new Relations());\n\n                ++_map[obj].Dependencies;\n            }\n        }\n\n        public void Add(ValueType obj, IEnumerable<ValueType> dependencies)\n        {\n            foreach (var dependency in dependencies) Add(obj, dependency);\n        }\n\n        public void Add(ValueType obj, params ValueType[] dependencies)\n        {\n            Add(obj, dependencies as IEnumerable<ValueType>);\n        }\n\n        public Tuple<IEnumerable<ValueType>, IEnumerable<ValueType>> Sort()\n        {\n            List<ValueType> sorted = new List<ValueType>(), cycled = new List<ValueType>();\n            var map = _map.ToDictionary(kvp => kvp.Key, kvp => kvp.Value);\n\n            sorted.AddRange(map.Where(kvp => kvp.Value.Dependencies == 0).Select(kvp => kvp.Key));\n\n            for (int idx = 0; idx < sorted.Count; ++idx) sorted.AddRange(map[sorted[idx]].Dependents.Where(k => --map[k].Dependencies == 0));\n\n            cycled.AddRange(map.Where(kvp => kvp.Value.Dependencies != 0).Select(kvp => kvp.Key));\n\n            return new Tuple<IEnumerable<ValueType>, IEnumerable<ValueType>>(sorted, cycled);\n        }\n\n        public void Clear()\n        {\n            _map.Clear();\n        }\n    }\n\n}\n\n\n\nnamespace ExampleApplication\n{\n    using Algorithms;\n    using System;\n    using System.Collections.Generic;\n    using System.Linq;\n\n    public class Task\n    {\n        public string Message;\n    }\n\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            List<Task> tasks = new List<Task>\n            {\n                new Task{ Message = \"A - depends on B and C\" },    \n                new Task{ Message = \"B - depends on none\" },       \n                new Task{ Message = \"C - depends on D and E\" },    \n                new Task{ Message = \"D - depends on none\" },       \n                new Task{ Message = \"E - depends on F, G and H\" }, \n                new Task{ Message = \"F - depends on I\" },          \n                new Task{ Message = \"G - depends on none\" },       \n                new Task{ Message = \"H - depends on none\" },       \n                new Task{ Message = \"I - depends on none\" },       \n            };\n\n            TopologicalSorter<Task> resolver = new TopologicalSorter<Task>();\n\n            \n            resolver.Add(tasks[0], new[] { tasks[1], tasks[2] });\n            \n            resolver.Add(tasks[2], new[] { tasks[3], tasks[4] });\n            \n            resolver.Add(tasks[4], tasks[5], tasks[6], tasks[7]);\n            resolver.Add(tasks[5], tasks[8]);\n            \n            \n\n            \n\n            var result = resolver.Sort();\n            var sorted = result.Item1;\n            var cycled = result.Item2;\n\n            if (!cycled.Any())\n            {\n                foreach (var d in sorted) Console.WriteLine(d.Message);\n            }\n            else\n            {\n                Console.Write(\"Cycled dependencies detected: \");\n\n                foreach (var d in cycled) Console.Write($\"{d.Message[0]} \");\n\n                Console.WriteLine();\n            }\n\n            Console.WriteLine(\"exiting...\");\n        }\n    }\n}\n"}
{"id": 21446, "name": "Topological sort", "source": "Translate Fortran to Java:       SUBROUTINE TSORT(NL,ND,IDEP,IORD,IPOS,NO)\n      IMPLICIT NONE\n      INTEGER NL,ND,NO,IDEP(ND,2),IORD(NL),IPOS(NL),I,J,K,IL,IR,IPL,IPR\n      DO 10 I=1,NL\n      IORD(I)=I\n   10 IPOS(I)=I\n      K=1\n   20 J=K\n      K=NL+1\n      DO 30 I=1,ND\n      IL=IDEP(I,1)\n      IR=IDEP(I,2)\n      IPL=IPOS(IL)\n      IPR=IPOS(IR)\n      IF(IL.EQ.IR .OR. IPL.GE.K .OR. IPL.LT.J .OR. IPR.LT.J) GO TO 30\n      K=K-1\n      IPOS(IORD(K))=IPL\n      IPOS(IL)=K\n      IORD(IPL)=IORD(K)\n      IORD(K)=IL\n   30 CONTINUE\n      IF(K.GT.J) GO TO 20\n      NO=J-1\n      END\n", "target": "import java.util.*;\n\npublic class TopologicalSort {\n\n    public static void main(String[] args) {\n        String s = \"std, ieee, des_system_lib, dw01, dw02, dw03, dw04, dw05,\"\n                + \"dw06, dw07, dware, gtech, ramlib, std_cell_lib, synopsys\";\n\n        Graph g = new Graph(s, new int[][]{\n            {2, 0}, {2, 14}, {2, 13}, {2, 4}, {2, 3}, {2, 12}, {2, 1},\n            {3, 1}, {3, 10}, {3, 11},\n            {4, 1}, {4, 10},\n            {5, 0}, {5, 14}, {5, 10}, {5, 4}, {5, 3}, {5, 1}, {5, 11},\n            {6, 1}, {6, 3}, {6, 10}, {6, 11},\n            {7, 1}, {7, 10},\n            {8, 1}, {8, 10},\n            {9, 1}, {9, 10},\n            {10, 1},\n            {11, 1},\n            {12, 0}, {12, 1},\n            {13, 1}\n        });\n\n        System.out.println(\"Topologically sorted order: \");\n        System.out.println(g.topoSort());\n    }\n}\n\nclass Graph {\n    String[] vertices;\n    boolean[][] adjacency;\n    int numVertices;\n\n    public Graph(String s, int[][] edges) {\n        vertices = s.split(\",\");\n        numVertices = vertices.length;\n        adjacency = new boolean[numVertices][numVertices];\n\n        for (int[] edge : edges)\n            adjacency[edge[0]][edge[1]] = true;\n    }\n\n    List<String> topoSort() {\n        List<String> result = new ArrayList<>();\n        List<Integer> todo = new LinkedList<>();\n\n        for (int i = 0; i < numVertices; i++)\n            todo.add(i);\n\n        try {\n            outer:\n            while (!todo.isEmpty()) {\n                for (Integer r : todo) {\n                    if (!hasDependency(r, todo)) {\n                        todo.remove(r);\n                        result.add(vertices[r]);\n                         \n                        continue outer;\n                    }\n                }\n                throw new Exception(\"Graph has cycles\");\n            }\n        } catch (Exception e) {\n            System.out.println(e);\n            return null;\n        }\n        return result;\n    }\n\n    boolean hasDependency(Integer r, List<Integer> todo) {\n        for (Integer c : todo) {\n            if (adjacency[r][c])\n                return true;\n        }\n        return false;\n    }\n}\n"}
{"id": 21447, "name": "Topological sort", "source": "Translate Fortran to Python:       SUBROUTINE TSORT(NL,ND,IDEP,IORD,IPOS,NO)\n      IMPLICIT NONE\n      INTEGER NL,ND,NO,IDEP(ND,2),IORD(NL),IPOS(NL),I,J,K,IL,IR,IPL,IPR\n      DO 10 I=1,NL\n      IORD(I)=I\n   10 IPOS(I)=I\n      K=1\n   20 J=K\n      K=NL+1\n      DO 30 I=1,ND\n      IL=IDEP(I,1)\n      IR=IDEP(I,2)\n      IPL=IPOS(IL)\n      IPR=IPOS(IR)\n      IF(IL.EQ.IR .OR. IPL.GE.K .OR. IPL.LT.J .OR. IPR.LT.J) GO TO 30\n      K=K-1\n      IPOS(IORD(K))=IPL\n      IPOS(IL)=K\n      IORD(IPL)=IORD(K)\n      IORD(K)=IL\n   30 CONTINUE\n      IF(K.GT.J) GO TO 20\n      NO=J-1\n      END\n", "target": "try:\n    from functools import reduce\nexcept:\n    pass\n\ndata = {\n    'des_system_lib':   set('std synopsys std_cell_lib des_system_lib dw02 dw01 ramlib ieee'.split()),\n    'dw01':             set('ieee dw01 dware gtech'.split()),\n    'dw02':             set('ieee dw02 dware'.split()),\n    'dw03':             set('std synopsys dware dw03 dw02 dw01 ieee gtech'.split()),\n    'dw04':             set('dw04 ieee dw01 dware gtech'.split()),\n    'dw05':             set('dw05 ieee dware'.split()),\n    'dw06':             set('dw06 ieee dware'.split()),\n    'dw07':             set('ieee dware'.split()),\n    'dware':            set('ieee dware'.split()),\n    'gtech':            set('ieee gtech'.split()),\n    'ramlib':           set('std ieee'.split()),\n    'std_cell_lib':     set('ieee std_cell_lib'.split()),\n    'synopsys':         set(),\n    }\n\ndef toposort2(data):\n    for k, v in data.items():\n        v.discard(k) \n    extra_items_in_deps = reduce(set.union, data.values()) - set(data.keys())\n    data.update({item:set() for item in extra_items_in_deps})\n    while True:\n        ordered = set(item for item,dep in data.items() if not dep)\n        if not ordered:\n            break\n        yield ' '.join(sorted(ordered))\n        data = {item: (dep - ordered) for item,dep in data.items()\n                if item not in ordered}\n    assert not data, \"A cyclic dependency exists amongst %r\" % data\n\nprint ('\\n'.join( toposort2(data) ))\n"}
{"id": 21652, "name": "Formatted numeric output", "source": "Translate Fortran to C#: INTEGER :: number = 7125\nWRITE(*,\"(I8.8)\") number   \n", "target": "class Program\n    {\n\n\n        static void Main(string[] args)\n        {\n\n            float myNumbers = 7.125F;\n            \n            string strnumber = Convert.ToString(myNumbers);\n                       \n            Console.WriteLine(strnumber.PadLeft(9, '0'));\n           \n            Console.ReadLine();\n        }\n        \n\n             \n       \n    }\n"}
{"id": 21655, "name": "Formatted numeric output", "source": "Translate Fortran to Java: INTEGER :: number = 7125\nWRITE(*,\"(I8.8)\") number   \n", "target": "public class Printing{\n\tpublic static void main(String[] args){\n\t\tdouble value = 7.125;\n\t\tSystem.out.printf(\"%09.3f\",value); \n\t\tSystem.out.println(String.format(\"%09.3f\",value));\n\t}\n}\n"}
{"id": 21656, "name": "Formatted numeric output", "source": "Translate Fortran to Python: INTEGER :: number = 7125\nWRITE(*,\"(I8.8)\") number   \n", "target": "from math import pi, exp\nr = exp(pi)-pi\nprint r\nprint \"e=%e f=%f g=%g G=%G s=%s r=%r!\"%(r,r,r,r,r,r)\nprint \"e=%9.4e f=%9.4f g=%9.4g!\"%(-r,-r,-r)\nprint \"e=%9.4e f=%9.4f g=%9.4g!\"%(r,r,r)\nprint \"e=%-9.4e f=%-9.4f g=%-9.4g!\"%(r,r,r)\nprint \"e=%09.4e f=%09.4f g=%09.4g!\"%(-r,-r,-r)\nprint \"e=%09.4e f=%09.4f g=%09.4g!\"%(r,r,r)\nprint \"e=%-09.4e f=%-09.4f g=%-09.4g!\"%(r,r,r)\n"}
{"id": 21875, "name": "Doubly-linked list_Element definition", "source": "Translate Fortran to C#: type node\n   real :: data\n   type(node), pointer :: next => null(), previous => null()\nend type node\n\n\n\ntype( node ), target :: head\n", "target": "class Link\n{\n    public int Item { get; set; }\n    public Link Prev { get; set; }\n    public Link Next { get; set; }\n\n    \n    public Link(int item, Link prev = null, Link next = null) {\n        Item = item;\n        Prev = prev;\n        Next = next;\n    }\n}\n"}
{"id": 21878, "name": "Doubly-linked list_Element definition", "source": "Translate Fortran to Java: type node\n   real :: data\n   type(node), pointer :: next => null(), previous => null()\nend type node\n\n\n\ntype( node ), target :: head\n", "target": "public class Node<T> {\n   private T element;\n   private Node<T> next, prev;\n\n   public Node<T>(){\n      next = prev = element = null;\n   }\n\n   public Node<T>(Node<T> n, Node<T> p, T elem){\n      next = n;\n      prev = p;\n      element = elem;\n   }\n\n   public void setNext(Node<T> n){\n      next = n;\n   }\n\n   public Node<T> getNext(){\n      return next;\n   }\n\n   public void setElem(T elem){\n      element = elem;\n   }\n\n   public T getElem(){\n      return element;\n   }\n\n   public void setNext(Node<T> n){\n      next = n;\n   }\n\n   public Node<T> setPrev(Node<T> p){\n      prev = p;\n   }\n\n   public getPrev(){\n      return prev;\n   }\n}\n"}
{"id": 21879, "name": "Doubly-linked list_Element definition", "source": "Translate Fortran to Python: type node\n   real :: data\n   type(node), pointer :: next => null(), previous => null()\nend type node\n\n\n\ntype( node ), target :: head\n", "target": "class Node(object):\n     def __init__(self, data = None, prev = None, next = None):\n         self.prev = prev\n         self.next = next\n         self.data = data\n     def __str__(self):\n         return str(self.data)\n     def __repr__(self):\n         return repr(self.data)\n     def iter_forward(self):\n         c = self\n         while c != None:\n             yield c\n             c = c.next\n     def iter_backward(self):\n         c = self\n         while c != None:\n             yield c\n             c = c.prev\n"}
{"id": 22183, "name": "Dot product", "source": "Translate Fortran to C#: program test_dot_product\n\n  write (*, '(i0)') dot_product ([1, 3, -5], [4, -2, -1])\n\nend program test_dot_product\n", "target": "static void Main(string[] args)\n{\n\tConsole.WriteLine(DotProduct(new decimal[] { 1, 3, -5 }, new decimal[] { 4, -2, -1 }));\n\tConsole.Read();\n}\n\nprivate static decimal DotProduct(decimal[] vec1, decimal[] vec2) \n{\n\tif (vec1 == null)\n\t\treturn 0;\n\n\tif (vec2 == null)\n\t\treturn 0;\n\n\tif (vec1.Length != vec2.Length)\n\t\treturn 0;\n\n\tdecimal tVal = 0;\n\tfor (int x = 0; x < vec1.Length; x++)\n\t{\n\t\ttVal += vec1[x] * vec2[x];\n\t}\n\n\treturn tVal;\n}\n"}
{"id": 22184, "name": "Dot product", "source": "Translate Fortran to C#: program test_dot_product\n\n  write (*, '(i0)') dot_product ([1, 3, -5], [4, -2, -1])\n\nend program test_dot_product\n", "target": "static void Main(string[] args)\n{\n\tConsole.WriteLine(DotProduct(new decimal[] { 1, 3, -5 }, new decimal[] { 4, -2, -1 }));\n\tConsole.Read();\n}\n\nprivate static decimal DotProduct(decimal[] vec1, decimal[] vec2) \n{\n\tif (vec1 == null)\n\t\treturn 0;\n\n\tif (vec2 == null)\n\t\treturn 0;\n\n\tif (vec1.Length != vec2.Length)\n\t\treturn 0;\n\n\tdecimal tVal = 0;\n\tfor (int x = 0; x < vec1.Length; x++)\n\t{\n\t\ttVal += vec1[x] * vec2[x];\n\t}\n\n\treturn tVal;\n}\n"}
{"id": 22190, "name": "Dot product", "source": "Translate Fortran to Java: program test_dot_product\n\n  write (*, '(i0)') dot_product ([1, 3, -5], [4, -2, -1])\n\nend program test_dot_product\n", "target": "public class DotProduct {\n\t\n\tpublic static void main(String[] args) {\n\t\tdouble[] a = {1, 3, -5};\n\t\tdouble[] b = {4, -2, -1};\n\t\t\n\t\tSystem.out.println(dotProd(a,b));\n\t}\n\t\n\tpublic static double dotProd(double[] a, double[] b){\n\t\tif(a.length != b.length){\n\t\t\tthrow new IllegalArgumentException(\"The dimensions have to be equal!\");\n\t\t}\n\t\tdouble sum = 0;\n\t\tfor(int i = 0; i < a.length; i++){\n\t\t\tsum += a[i] * b[i];\n\t\t}\n\t\treturn sum;\n\t}\n}\n"}
{"id": 22191, "name": "Dot product", "source": "Translate Fortran to Java: program test_dot_product\n\n  write (*, '(i0)') dot_product ([1, 3, -5], [4, -2, -1])\n\nend program test_dot_product\n", "target": "public class DotProduct {\n\t\n\tpublic static void main(String[] args) {\n\t\tdouble[] a = {1, 3, -5};\n\t\tdouble[] b = {4, -2, -1};\n\t\t\n\t\tSystem.out.println(dotProd(a,b));\n\t}\n\t\n\tpublic static double dotProd(double[] a, double[] b){\n\t\tif(a.length != b.length){\n\t\t\tthrow new IllegalArgumentException(\"The dimensions have to be equal!\");\n\t\t}\n\t\tdouble sum = 0;\n\t\tfor(int i = 0; i < a.length; i++){\n\t\t\tsum += a[i] * b[i];\n\t\t}\n\t\treturn sum;\n\t}\n}\n"}
{"id": 22192, "name": "Dot product", "source": "Translate Fortran to Python: program test_dot_product\n\n  write (*, '(i0)') dot_product ([1, 3, -5], [4, -2, -1])\n\nend program test_dot_product\n", "target": "def dotp(a,b):\n    assert len(a) == len(b), 'Vector sizes must match'\n    return sum(aterm * bterm for aterm,bterm in zip(a, b))\n\nif __name__ == '__main__':\n    a, b = [1, 3, -5], [4, -2, -1]\n    assert dotp(a,b) == 3\n"}
{"id": 22193, "name": "Dot product", "source": "Translate Fortran to Python: program test_dot_product\n\n  write (*, '(i0)') dot_product ([1, 3, -5], [4, -2, -1])\n\nend program test_dot_product\n", "target": "def dotp(a,b):\n    assert len(a) == len(b), 'Vector sizes must match'\n    return sum(aterm * bterm for aterm,bterm in zip(a, b))\n\nif __name__ == '__main__':\n    a, b = [1, 3, -5], [4, -2, -1]\n    assert dotp(a,b) == 3\n"}
{"id": 22630, "name": "Count in factors", "source": "Translate Fortran to C#: \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nmodule prime_mod\n\n  \n  integer, dimension(:), allocatable :: sieve_table\n  private :: PrimeQ\n\ncontains\n\n  \n  subroutine sieve(n) \n    integer, intent(in) :: n\n    integer :: status, i, j\n    if ((n .lt. 1) .or. allocated(sieve_table)) deallocate(sieve_table)\n    if (n .lt. 1) return\n    allocate(sieve_table(n), stat=status)\n    if (status .ne. 0) stop 'cannot allocate space'\n    sieve_table(1) = 1\n    do i=2,int(sqrt(real(n)))+1\n       if (sieve_table(i) .eq. 0) then\n          do j = i*i, n, i\n             sieve_table(j) = i\n          end do\n       end if\n    end do\n  end subroutine sieve\n\n  subroutine check_sieve(n)\n    integer, intent(in) :: n\n    if (.not. (allocated(sieve_table) .and. ((1 .le. n) .and. (n .le. size(sieve_table))))) stop 'Call sieve first'\n  end subroutine check_sieve\n\n  logical function isPrime(p)\n    integer, intent(in) :: p\n    call check_sieve(p)\n    isPrime = PrimeQ(p)\n  end function isPrime\n\n  logical function isComposite(p)\n    integer, intent(in) :: p\n    isComposite = .not. isPrime(p)\n  end function isComposite\n\n  logical function PrimeQ(p)\n    integer, intent(in) :: p\n    PrimeQ = sieve_table(p) .eq. 0\n  end function PrimeQ\n\n  subroutine prime_factors(p, rv, n)\n    integer, intent(in) :: p \n    integer, dimension(:), intent(out) :: rv \n    integer, intent(out) :: n \n    integer :: i, m\n    call check_sieve(p)\n    m = p\n    i = 1\n    if (p .ne. 1) then\n       do while ((.not. PrimeQ(m)) .and. (i .lt. size(rv)))\n          rv(i) = sieve_table(m)\n          m = m/rv(i)\n          i = i+1\n       end do\n    end if\n    if (i .le. size(rv)) rv(i) = m\n    n = i\n  end subroutine prime_factors\n\nend module prime_mod\n\nprogram count_in_factors\n  use prime_mod\n  integer :: i, n\n  integer, dimension(8) :: factors\n  call sieve(40)                \n  do i=1,40\n     factors = 0\n     call prime_factors(i, factors, n)\n     write(6,*)'assert',i,'= */',factors(:n)\n  end do\n  call sieve(0)                 \nend program count_in_factors\n", "target": "using System;\nusing System.Collections.Generic;\n\nnamespace prog\n{\n\tclass MainClass\n\t{\n\t\tpublic static void Main (string[] args)\n\t\t{\n\t\t\tfor( int i=1; i<=22; i++ )\n\t\t\t{\t\t\t\t\n\t\t\t\tList<int> f = Factorize(i);\n\t\t\t\tConsole.Write( i + \":  \" + f[0] );\n\t\t\t\tfor( int j=1; j<f.Count; j++ )\n\t\t\t\t{\n\t\t\t\t\tConsole.Write( \" * \" + f[j] );\n\t\t\t\t}\n\t\t\t\tConsole.WriteLine();\n\t\t\t}\n\t\t}\n\t\t\n\t\tpublic static List<int> Factorize( int n )\n\t\t{\n\t\t\tList<int> l = new List<int>();\n\t\t    \n\t\t\tif ( n == 1 )\n\t\t\t{\n\t\t\t\tl.Add(1);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tint k = 2;\n\t\t\t\twhile( n > 1 ) \n\t\t\t\t{\n\t\t\t\t\twhile( n % k == 0 )\n\t\t\t\t\t{\n\t\t\t\t\t\tl.Add( k );\n\t\t\t\t\t\tn /= k;\n\t\t\t\t\t}\n\t\t\t\t\tk++;\n\t\t\t\t}\n\t\t\t}\t\t\t\n\t\t\treturn l;\n\t\t}\t\n\t}\n}\n"}
{"id": 22633, "name": "Count in factors", "source": "Translate Fortran to Java: \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nmodule prime_mod\n\n  \n  integer, dimension(:), allocatable :: sieve_table\n  private :: PrimeQ\n\ncontains\n\n  \n  subroutine sieve(n) \n    integer, intent(in) :: n\n    integer :: status, i, j\n    if ((n .lt. 1) .or. allocated(sieve_table)) deallocate(sieve_table)\n    if (n .lt. 1) return\n    allocate(sieve_table(n), stat=status)\n    if (status .ne. 0) stop 'cannot allocate space'\n    sieve_table(1) = 1\n    do i=2,int(sqrt(real(n)))+1\n       if (sieve_table(i) .eq. 0) then\n          do j = i*i, n, i\n             sieve_table(j) = i\n          end do\n       end if\n    end do\n  end subroutine sieve\n\n  subroutine check_sieve(n)\n    integer, intent(in) :: n\n    if (.not. (allocated(sieve_table) .and. ((1 .le. n) .and. (n .le. size(sieve_table))))) stop 'Call sieve first'\n  end subroutine check_sieve\n\n  logical function isPrime(p)\n    integer, intent(in) :: p\n    call check_sieve(p)\n    isPrime = PrimeQ(p)\n  end function isPrime\n\n  logical function isComposite(p)\n    integer, intent(in) :: p\n    isComposite = .not. isPrime(p)\n  end function isComposite\n\n  logical function PrimeQ(p)\n    integer, intent(in) :: p\n    PrimeQ = sieve_table(p) .eq. 0\n  end function PrimeQ\n\n  subroutine prime_factors(p, rv, n)\n    integer, intent(in) :: p \n    integer, dimension(:), intent(out) :: rv \n    integer, intent(out) :: n \n    integer :: i, m\n    call check_sieve(p)\n    m = p\n    i = 1\n    if (p .ne. 1) then\n       do while ((.not. PrimeQ(m)) .and. (i .lt. size(rv)))\n          rv(i) = sieve_table(m)\n          m = m/rv(i)\n          i = i+1\n       end do\n    end if\n    if (i .le. size(rv)) rv(i) = m\n    n = i\n  end subroutine prime_factors\n\nend module prime_mod\n\nprogram count_in_factors\n  use prime_mod\n  integer :: i, n\n  integer, dimension(8) :: factors\n  call sieve(40)                \n  do i=1,40\n     factors = 0\n     call prime_factors(i, factors, n)\n     write(6,*)'assert',i,'= */',factors(:n)\n  end do\n  call sieve(0)                 \nend program count_in_factors\n", "target": "public class CountingInFactors{ \n    public static void main(String[] args){\n        for(int i = 1; i<= 10; i++){\n            System.out.println(i + \" = \"+ countInFactors(i));\n        }\n \n        for(int i = 9991; i <= 10000; i++){\n        \tSystem.out.println(i + \" = \"+ countInFactors(i));\n        }\n    }\n \n    private static String countInFactors(int n){\n        if(n == 1) return \"1\";\n \n        StringBuilder sb = new StringBuilder();\n \n        n = checkFactor(2, n, sb);\n        if(n == 1) return sb.toString();\n \n        n = checkFactor(3, n, sb);\n        if(n == 1) return sb.toString();\n \n        for(int i = 5; i <= n; i+= 2){\n            if(i % 3 == 0)continue;\n \n            n = checkFactor(i, n, sb);\n            if(n == 1)break;\n        }\n \n        return sb.toString();\n    }\n \n    private static int checkFactor(int mult, int n, StringBuilder sb){\n        while(n % mult == 0 ){\n            if(sb.length() > 0) sb.append(\" x \");\n            sb.append(mult);\n            n /= mult;\n        }\n        return n;\n    }\n}\n"}
{"id": 22634, "name": "Count in factors", "source": "Translate Fortran to Python: \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nmodule prime_mod\n\n  \n  integer, dimension(:), allocatable :: sieve_table\n  private :: PrimeQ\n\ncontains\n\n  \n  subroutine sieve(n) \n    integer, intent(in) :: n\n    integer :: status, i, j\n    if ((n .lt. 1) .or. allocated(sieve_table)) deallocate(sieve_table)\n    if (n .lt. 1) return\n    allocate(sieve_table(n), stat=status)\n    if (status .ne. 0) stop 'cannot allocate space'\n    sieve_table(1) = 1\n    do i=2,int(sqrt(real(n)))+1\n       if (sieve_table(i) .eq. 0) then\n          do j = i*i, n, i\n             sieve_table(j) = i\n          end do\n       end if\n    end do\n  end subroutine sieve\n\n  subroutine check_sieve(n)\n    integer, intent(in) :: n\n    if (.not. (allocated(sieve_table) .and. ((1 .le. n) .and. (n .le. size(sieve_table))))) stop 'Call sieve first'\n  end subroutine check_sieve\n\n  logical function isPrime(p)\n    integer, intent(in) :: p\n    call check_sieve(p)\n    isPrime = PrimeQ(p)\n  end function isPrime\n\n  logical function isComposite(p)\n    integer, intent(in) :: p\n    isComposite = .not. isPrime(p)\n  end function isComposite\n\n  logical function PrimeQ(p)\n    integer, intent(in) :: p\n    PrimeQ = sieve_table(p) .eq. 0\n  end function PrimeQ\n\n  subroutine prime_factors(p, rv, n)\n    integer, intent(in) :: p \n    integer, dimension(:), intent(out) :: rv \n    integer, intent(out) :: n \n    integer :: i, m\n    call check_sieve(p)\n    m = p\n    i = 1\n    if (p .ne. 1) then\n       do while ((.not. PrimeQ(m)) .and. (i .lt. size(rv)))\n          rv(i) = sieve_table(m)\n          m = m/rv(i)\n          i = i+1\n       end do\n    end if\n    if (i .le. size(rv)) rv(i) = m\n    n = i\n  end subroutine prime_factors\n\nend module prime_mod\n\nprogram count_in_factors\n  use prime_mod\n  integer :: i, n\n  integer, dimension(8) :: factors\n  call sieve(40)                \n  do i=1,40\n     factors = 0\n     call prime_factors(i, factors, n)\n     write(6,*)'assert',i,'= */',factors(:n)\n  end do\n  call sieve(0)                 \nend program count_in_factors\n", "target": "from functools import lru_cache\n\nprimes = [2, 3, 5, 7, 11, 13, 17]    \n\n@lru_cache(maxsize=2000)\ndef pfactor(n):\n    if n == 1:\n        return [1]\n    n2 = n // 2 + 1\n    for p in primes:\n        if p <= n2:\n            d, m = divmod(n, p)\n            if m == 0:\n                if d > 1:\n                    return [p] + pfactor(d)\n                else:\n                    return [p]\n        else:\n            if n > primes[-1]:\n                primes.append(n)\n            return [n]\n        \nif __name__ == '__main__':\n    mx = 5000\n    for n in range(1, mx + 1):\n        factors = pfactor(n)\n        if n <= 10 or n >= mx - 20:\n            print( '%4i %5s %s' % (n,\n                                   '' if factors != [n] or n == 1 else 'prime',\n                                   'x'.join(str(i) for i in factors)) )\n        if n == 11:\n            print('...')\n            \n    print('\\nNumber of primes gathered up to', n, 'is', len(primes))\n    print(pfactor.cache_info())\n"}
{"id": 22859, "name": "Queue_Definition", "source": "Translate Fortran to C#: module FIFO\n  use fifo_nodes\n\n\n\n\n\n\n\n\n\n\n  type fifo_head\n     type(fifo_node), pointer :: head, tail\n  end type fifo_head\n\ncontains\n\n  subroutine new_fifo(h)\n    type(fifo_head), intent(out) :: h\n    nullify(h%head)\n    nullify(h%tail)\n  end subroutine new_fifo\n\n  subroutine fifo_enqueue(h, n)\n    type(fifo_head), intent(inout) :: h\n    type(fifo_node), intent(inout), target :: n\n\n    if ( associated(h%tail) ) then\n       h%tail%next => n\n       h%tail => n\n    else\n       h%tail => n\n       h%head => n\n    end if\n\n    nullify(n%next)\n  end subroutine fifo_enqueue\n\n  subroutine fifo_dequeue(h, n)\n    type(fifo_head), intent(inout) :: h\n    type(fifo_node), intent(out), target :: n\n\n    if ( associated(h%head) ) then\n       n = h%head\n       if ( associated(n%next) ) then\n          h%head => n%next\n       else\n          nullify(h%head)\n          nullify(h%tail)\n       end if\n       n%valid = .true.\n    else\n       n%valid = .false.\n    end if\n    nullify(n%next)\n  end subroutine fifo_dequeue\n\n  function fifo_isempty(h) result(r)\n    logical :: r\n    type(fifo_head), intent(in) :: h\n    if ( associated(h%head) ) then\n       r = .false.\n    else\n       r = .true.\n    end if\n  end function fifo_isempty\n\nend module FIFO\n", "target": "public class FIFO<T>\n{\n  class Node\n  {\n    public T Item { get; set; }\n    public Node Next { get; set; }\n  }\n  Node first = null;\n  Node last = null;\n  public void push(T item)\n  {\n    if (empty())\n    {\n      \n      first = new Node() { Item = item, Next = null };\n      last = first;\n    }\n    else\n    {\n      last.Next = new Node() { Item = item, Next = null };\n      last = last.Next;\n    }\n  }\n  public T pop()\n  {\n    if (first == null)\n      throw new System.Exception(\"No elements\"); \n    if (last == first)\n      last = null;\n    T temp = first.Item;\n    first = first.Next;\n    return temp;\n  }\n  public bool empty()\n  {\n    return first == null;\n  }\n}\n"}
{"id": 22862, "name": "Queue_Definition", "source": "Translate Fortran to Java: module FIFO\n  use fifo_nodes\n\n\n\n\n\n\n\n\n\n\n  type fifo_head\n     type(fifo_node), pointer :: head, tail\n  end type fifo_head\n\ncontains\n\n  subroutine new_fifo(h)\n    type(fifo_head), intent(out) :: h\n    nullify(h%head)\n    nullify(h%tail)\n  end subroutine new_fifo\n\n  subroutine fifo_enqueue(h, n)\n    type(fifo_head), intent(inout) :: h\n    type(fifo_node), intent(inout), target :: n\n\n    if ( associated(h%tail) ) then\n       h%tail%next => n\n       h%tail => n\n    else\n       h%tail => n\n       h%head => n\n    end if\n\n    nullify(n%next)\n  end subroutine fifo_enqueue\n\n  subroutine fifo_dequeue(h, n)\n    type(fifo_head), intent(inout) :: h\n    type(fifo_node), intent(out), target :: n\n\n    if ( associated(h%head) ) then\n       n = h%head\n       if ( associated(n%next) ) then\n          h%head => n%next\n       else\n          nullify(h%head)\n          nullify(h%tail)\n       end if\n       n%valid = .true.\n    else\n       n%valid = .false.\n    end if\n    nullify(n%next)\n  end subroutine fifo_dequeue\n\n  function fifo_isempty(h) result(r)\n    logical :: r\n    type(fifo_head), intent(in) :: h\n    if ( associated(h%head) ) then\n       r = .false.\n    else\n       r = .true.\n    end if\n  end function fifo_isempty\n\nend module FIFO\n", "target": "public class Queue<E>{\n    Node<E> head = null, tail = null;\n\n    static class Node<E>{\n        E value;\n        Node<E> next;\n\n        Node(E value, Node<E> next){\n            this.value= value;\n            this.next= next;\n        }\n\n    }\n\n    public Queue(){\n    }\n\n    public void enqueue(E value){ \n        Node<E> newNode= new Node<E>(value, null);\n        if(empty()){\n            head= newNode;\n        }else{\n            tail.next = newNode;\n        }\n        tail= newNode;\n    }\n\n    public E dequeue() throws java.util.NoSuchElementException{\n        if(empty()){\n            throw new java.util.NoSuchElementException(\"No more elements.\");\n        }\n        E retVal= head.value;\n        head= head.next;\n        return retVal;\n    } \n\n    public boolean empty(){\n        return head == null;\n    }\n}\n"}
{"id": 22863, "name": "Queue_Definition", "source": "Translate Fortran to Python: module FIFO\n  use fifo_nodes\n\n\n\n\n\n\n\n\n\n\n  type fifo_head\n     type(fifo_node), pointer :: head, tail\n  end type fifo_head\n\ncontains\n\n  subroutine new_fifo(h)\n    type(fifo_head), intent(out) :: h\n    nullify(h%head)\n    nullify(h%tail)\n  end subroutine new_fifo\n\n  subroutine fifo_enqueue(h, n)\n    type(fifo_head), intent(inout) :: h\n    type(fifo_node), intent(inout), target :: n\n\n    if ( associated(h%tail) ) then\n       h%tail%next => n\n       h%tail => n\n    else\n       h%tail => n\n       h%head => n\n    end if\n\n    nullify(n%next)\n  end subroutine fifo_enqueue\n\n  subroutine fifo_dequeue(h, n)\n    type(fifo_head), intent(inout) :: h\n    type(fifo_node), intent(out), target :: n\n\n    if ( associated(h%head) ) then\n       n = h%head\n       if ( associated(n%next) ) then\n          h%head => n%next\n       else\n          nullify(h%head)\n          nullify(h%tail)\n       end if\n       n%valid = .true.\n    else\n       n%valid = .false.\n    end if\n    nullify(n%next)\n  end subroutine fifo_dequeue\n\n  function fifo_isempty(h) result(r)\n    logical :: r\n    type(fifo_head), intent(in) :: h\n    if ( associated(h%head) ) then\n       r = .false.\n    else\n       r = .true.\n    end if\n  end function fifo_isempty\n\nend module FIFO\n", "target": "   class FIFO(object):\n       def __init__(self, *args):\n           self.contents = list(args)\n       def __call__(self):\n           return self.pop()\n       def __len__(self):\n           return len(self.contents)\n       def pop(self):\n           return self.contents.pop(0)\n       def push(self, item):\n           self.contents.append(item)\n       def extend(self,*itemlist):\n           self.contents += itemlist\n       def empty(self):\n           return bool(self.contents)\n       def __iter__(self):\n           return self\n       def next(self):\n           if self.empty():\n               raise StopIteration\n           return self.pop()\n\nif __name__ == \"__main__\":\n    \n    f = FIFO()\n    f.push(3)\n    f.push(2)\n    f.push(1)\n    while not f.empty():\n        print f.pop(),\n    \n    \n    f = FIFO(3,2,1)\n    while not f.empty():\n        print f(),\n    \n    \n    \n    f = FIFO(3,2,1)\n    while f:\n        print f(),\n    \n    f = FIFO(3,2,1)\n    for i in f:\n        print i,\n"}
{"id": 23163, "name": "Remove lines from a file", "source": "Translate Fortran to C#:       SUBROUTINE CROAK(GASP)\t\n       CHARACTER*(*) GASP\t\n        WRITE (6,*) \"Oh dear. \",GASP\t\n        STOP \"++ungood.\"\t\n      END\t\t\t\n\n      SUBROUTINE FILEHACK(FNAME,IST,N)\n       CHARACTER*(*) FNAME\t\n       INTEGER IST\t\t\n       INTEGER N\t\t\n       INTEGER ENUFF,L\t\t\n       PARAMETER (ENUFF = 66666)\n       CHARACTER*(ENUFF) ALINE\t\n       INTEGER NREC\t\t\n       INTEGER F,T\t\t\n       PARAMETER (F=66,T=67)\t\n       LOGICAL EXIST\n        IF (FNAME.EQ.\"\") CALL CROAK(\"Blank file name\n        IF (IST.LE.0)    CALL CROAK(\"First record must be positive\n        IF (N.LE.0)      CALL CROAK(\"Remove count must be positive\n        INQUIRE(FILE = FNAME, EXIST = EXIST)\t\n        IF (.NOT.EXIST) CALL CROAK(\"Can't find a file called \"//FNAME)\t\n        OPEN (F,FILE=FNAME,STATUS=\"OLD\",ACTION=\"READ\",FORM=\"FORMATTED\")\t\n        OPEN (T,STATUS=\"SCRATCH\",FORM=\"FORMATTED\")\t\n        NREC = 0\t\t\nCopy the desired records to a temporary file.\n   10   READ (F,11,END = 20) L,ALINE(1:MIN(L,ENUFF))\t\n   11   FORMAT (Q,A)\t\t\n        IF (L.GT.ENUFF) CALL CROAK(\"Ow\n        NREC = NREC + 1\t\t\n        IF (NREC.LT.IST .OR. NREC.GE.IST + N) WRITE (T,12) ALINE(1:L)\t\n   12   FORMAT (A)\t\t\n        GO TO 10\t\t\nConvert from input to output...\n   20   IF (NREC.LT.IST + N) CALL CROAK(\"Insufficient records\n        REWIND T\t\t\n        CLOSE(F)\t\t\n        OPEN (F,FILE=FNAME,FORM=\"FORMATTED\",\t\n     1   ACTION=\"WRITE\",STATUS=\"REPLACE\")\t\nCopy from the temporary file.\n   21   READ (T,11,END = 30) L,ALINE(1:L)\t\n        WRITE (F,12) ALINE(1:L)\t\t\t\n        GO TO 21\t\t\nCompleted.\n   30   CLOSE(T)\t\t\n        CLOSE(F)\t\t\n      END\t\t\n\n      PROGRAM CHOPPER\n       CALL FILEHACK(\"foobar.txt\",1,2)\n      END\n", "target": "using System;\nusing System.IO;\nusing System.Linq;\n\npublic class Rosetta\n{\n    public static void Main() => RemoveLines(\"foobar.txt\", start: 1, count: 2);\n\n    static void RemoveLines(string filename, int start, int count = 1) =>\n        File.WriteAllLines(filename, File.ReadAllLines(filename)\n            .Where((line, index) => index < start - 1 || index >= start + count - 1));\n}\n"}
{"id": 23164, "name": "Remove lines from a file", "source": "Translate Fortran to C#:       SUBROUTINE CROAK(GASP)\t\n       CHARACTER*(*) GASP\t\n        WRITE (6,*) \"Oh dear. \",GASP\t\n        STOP \"++ungood.\"\t\n      END\t\t\t\n\n      SUBROUTINE FILEHACK(FNAME,IST,N)\n       CHARACTER*(*) FNAME\t\n       INTEGER IST\t\t\n       INTEGER N\t\t\n       INTEGER ENUFF,L\t\t\n       PARAMETER (ENUFF = 66666)\n       CHARACTER*(ENUFF) ALINE\t\n       INTEGER NREC\t\t\n       INTEGER F,T\t\t\n       PARAMETER (F=66,T=67)\t\n       LOGICAL EXIST\n        IF (FNAME.EQ.\"\") CALL CROAK(\"Blank file name\n        IF (IST.LE.0)    CALL CROAK(\"First record must be positive\n        IF (N.LE.0)      CALL CROAK(\"Remove count must be positive\n        INQUIRE(FILE = FNAME, EXIST = EXIST)\t\n        IF (.NOT.EXIST) CALL CROAK(\"Can't find a file called \"//FNAME)\t\n        OPEN (F,FILE=FNAME,STATUS=\"OLD\",ACTION=\"READ\",FORM=\"FORMATTED\")\t\n        OPEN (T,STATUS=\"SCRATCH\",FORM=\"FORMATTED\")\t\n        NREC = 0\t\t\nCopy the desired records to a temporary file.\n   10   READ (F,11,END = 20) L,ALINE(1:MIN(L,ENUFF))\t\n   11   FORMAT (Q,A)\t\t\n        IF (L.GT.ENUFF) CALL CROAK(\"Ow\n        NREC = NREC + 1\t\t\n        IF (NREC.LT.IST .OR. NREC.GE.IST + N) WRITE (T,12) ALINE(1:L)\t\n   12   FORMAT (A)\t\t\n        GO TO 10\t\t\nConvert from input to output...\n   20   IF (NREC.LT.IST + N) CALL CROAK(\"Insufficient records\n        REWIND T\t\t\n        CLOSE(F)\t\t\n        OPEN (F,FILE=FNAME,FORM=\"FORMATTED\",\t\n     1   ACTION=\"WRITE\",STATUS=\"REPLACE\")\t\nCopy from the temporary file.\n   21   READ (T,11,END = 30) L,ALINE(1:L)\t\n        WRITE (F,12) ALINE(1:L)\t\t\t\n        GO TO 21\t\t\nCompleted.\n   30   CLOSE(T)\t\t\n        CLOSE(F)\t\t\n      END\t\t\n\n      PROGRAM CHOPPER\n       CALL FILEHACK(\"foobar.txt\",1,2)\n      END\n", "target": "using System;\nusing System.IO;\nusing System.Linq;\n\npublic class Rosetta\n{\n    public static void Main() => RemoveLines(\"foobar.txt\", start: 1, count: 2);\n\n    static void RemoveLines(string filename, int start, int count = 1) =>\n        File.WriteAllLines(filename, File.ReadAllLines(filename)\n            .Where((line, index) => index < start - 1 || index >= start + count - 1));\n}\n"}
{"id": 23170, "name": "Remove lines from a file", "source": "Translate Fortran to Java:       SUBROUTINE CROAK(GASP)\t\n       CHARACTER*(*) GASP\t\n        WRITE (6,*) \"Oh dear. \",GASP\t\n        STOP \"++ungood.\"\t\n      END\t\t\t\n\n      SUBROUTINE FILEHACK(FNAME,IST,N)\n       CHARACTER*(*) FNAME\t\n       INTEGER IST\t\t\n       INTEGER N\t\t\n       INTEGER ENUFF,L\t\t\n       PARAMETER (ENUFF = 66666)\n       CHARACTER*(ENUFF) ALINE\t\n       INTEGER NREC\t\t\n       INTEGER F,T\t\t\n       PARAMETER (F=66,T=67)\t\n       LOGICAL EXIST\n        IF (FNAME.EQ.\"\") CALL CROAK(\"Blank file name\n        IF (IST.LE.0)    CALL CROAK(\"First record must be positive\n        IF (N.LE.0)      CALL CROAK(\"Remove count must be positive\n        INQUIRE(FILE = FNAME, EXIST = EXIST)\t\n        IF (.NOT.EXIST) CALL CROAK(\"Can't find a file called \"//FNAME)\t\n        OPEN (F,FILE=FNAME,STATUS=\"OLD\",ACTION=\"READ\",FORM=\"FORMATTED\")\t\n        OPEN (T,STATUS=\"SCRATCH\",FORM=\"FORMATTED\")\t\n        NREC = 0\t\t\nCopy the desired records to a temporary file.\n   10   READ (F,11,END = 20) L,ALINE(1:MIN(L,ENUFF))\t\n   11   FORMAT (Q,A)\t\t\n        IF (L.GT.ENUFF) CALL CROAK(\"Ow\n        NREC = NREC + 1\t\t\n        IF (NREC.LT.IST .OR. NREC.GE.IST + N) WRITE (T,12) ALINE(1:L)\t\n   12   FORMAT (A)\t\t\n        GO TO 10\t\t\nConvert from input to output...\n   20   IF (NREC.LT.IST + N) CALL CROAK(\"Insufficient records\n        REWIND T\t\t\n        CLOSE(F)\t\t\n        OPEN (F,FILE=FNAME,FORM=\"FORMATTED\",\t\n     1   ACTION=\"WRITE\",STATUS=\"REPLACE\")\t\nCopy from the temporary file.\n   21   READ (T,11,END = 30) L,ALINE(1:L)\t\n        WRITE (F,12) ALINE(1:L)\t\t\t\n        GO TO 21\t\t\nCompleted.\n   30   CLOSE(T)\t\t\n        CLOSE(F)\t\t\n      END\t\t\n\n      PROGRAM CHOPPER\n       CALL FILEHACK(\"foobar.txt\",1,2)\n      END\n", "target": "import java.io.BufferedReader;\nimport java.io.File;\nimport java.io.FileReader;\nimport java.io.FileWriter;\n\npublic class RemoveLines\n{\n\tpublic static void main(String[] args)\n\t{\n\t\t\n\t\tString filename=\"foobar.txt\";\n\t\t\n\t\tint startline=1;\n\t\t\n\t\tint numlines=2;\n\t\t\n\t\tRemoveLines now=new RemoveLines();\n\t\tnow.delete(filename,startline,numlines);\n\t}\n\tvoid delete(String filename, int startline, int numlines)\n\t{\n\t\ttry\n\t\t{\n\t\t\tBufferedReader br=new BufferedReader(new FileReader(filename));\n\t\t\t\n\t\t\t\n\t\t\tStringBuffer sb=new StringBuffer(\"\");\n\t\t\t\n\t\t\t\n\t\t\tint linenumber=1;\n\t\t\tString line;\n\t\t\t\n\t\t\twhile((line=br.readLine())!=null)\n\t\t\t{\n\t\t\t\t\n\t\t\t\tif(linenumber<startline||linenumber>=startline+numlines)\n\t\t\t\t\tsb.append(line+\"\\n\");\n\t\t\t\tlinenumber++;\n\t\t\t}\n\t\t\tif(startline+numlines>linenumber)\n\t\t\t\tSystem.out.println(\"End of file reached.\");\n\t\t\tbr.close();\n\t\t\t\n\t\t\tFileWriter fw=new FileWriter(new File(filename));\n\t\t\t\n\t\t\tfw.write(sb.toString());\n\t\t\tfw.close();\n\t\t}\n\t\tcatch (Exception e)\n\t\t{\n\t\t\tSystem.out.println(\"Something went horribly wrong: \"+e.getMessage());\n\t\t}\n\t}\n}\n"}
{"id": 23171, "name": "Remove lines from a file", "source": "Translate Fortran to Java:       SUBROUTINE CROAK(GASP)\t\n       CHARACTER*(*) GASP\t\n        WRITE (6,*) \"Oh dear. \",GASP\t\n        STOP \"++ungood.\"\t\n      END\t\t\t\n\n      SUBROUTINE FILEHACK(FNAME,IST,N)\n       CHARACTER*(*) FNAME\t\n       INTEGER IST\t\t\n       INTEGER N\t\t\n       INTEGER ENUFF,L\t\t\n       PARAMETER (ENUFF = 66666)\n       CHARACTER*(ENUFF) ALINE\t\n       INTEGER NREC\t\t\n       INTEGER F,T\t\t\n       PARAMETER (F=66,T=67)\t\n       LOGICAL EXIST\n        IF (FNAME.EQ.\"\") CALL CROAK(\"Blank file name\n        IF (IST.LE.0)    CALL CROAK(\"First record must be positive\n        IF (N.LE.0)      CALL CROAK(\"Remove count must be positive\n        INQUIRE(FILE = FNAME, EXIST = EXIST)\t\n        IF (.NOT.EXIST) CALL CROAK(\"Can't find a file called \"//FNAME)\t\n        OPEN (F,FILE=FNAME,STATUS=\"OLD\",ACTION=\"READ\",FORM=\"FORMATTED\")\t\n        OPEN (T,STATUS=\"SCRATCH\",FORM=\"FORMATTED\")\t\n        NREC = 0\t\t\nCopy the desired records to a temporary file.\n   10   READ (F,11,END = 20) L,ALINE(1:MIN(L,ENUFF))\t\n   11   FORMAT (Q,A)\t\t\n        IF (L.GT.ENUFF) CALL CROAK(\"Ow\n        NREC = NREC + 1\t\t\n        IF (NREC.LT.IST .OR. NREC.GE.IST + N) WRITE (T,12) ALINE(1:L)\t\n   12   FORMAT (A)\t\t\n        GO TO 10\t\t\nConvert from input to output...\n   20   IF (NREC.LT.IST + N) CALL CROAK(\"Insufficient records\n        REWIND T\t\t\n        CLOSE(F)\t\t\n        OPEN (F,FILE=FNAME,FORM=\"FORMATTED\",\t\n     1   ACTION=\"WRITE\",STATUS=\"REPLACE\")\t\nCopy from the temporary file.\n   21   READ (T,11,END = 30) L,ALINE(1:L)\t\n        WRITE (F,12) ALINE(1:L)\t\t\t\n        GO TO 21\t\t\nCompleted.\n   30   CLOSE(T)\t\t\n        CLOSE(F)\t\t\n      END\t\t\n\n      PROGRAM CHOPPER\n       CALL FILEHACK(\"foobar.txt\",1,2)\n      END\n", "target": "import java.io.BufferedReader;\nimport java.io.File;\nimport java.io.FileReader;\nimport java.io.FileWriter;\n\npublic class RemoveLines\n{\n\tpublic static void main(String[] args)\n\t{\n\t\t\n\t\tString filename=\"foobar.txt\";\n\t\t\n\t\tint startline=1;\n\t\t\n\t\tint numlines=2;\n\t\t\n\t\tRemoveLines now=new RemoveLines();\n\t\tnow.delete(filename,startline,numlines);\n\t}\n\tvoid delete(String filename, int startline, int numlines)\n\t{\n\t\ttry\n\t\t{\n\t\t\tBufferedReader br=new BufferedReader(new FileReader(filename));\n\t\t\t\n\t\t\t\n\t\t\tStringBuffer sb=new StringBuffer(\"\");\n\t\t\t\n\t\t\t\n\t\t\tint linenumber=1;\n\t\t\tString line;\n\t\t\t\n\t\t\twhile((line=br.readLine())!=null)\n\t\t\t{\n\t\t\t\t\n\t\t\t\tif(linenumber<startline||linenumber>=startline+numlines)\n\t\t\t\t\tsb.append(line+\"\\n\");\n\t\t\t\tlinenumber++;\n\t\t\t}\n\t\t\tif(startline+numlines>linenumber)\n\t\t\t\tSystem.out.println(\"End of file reached.\");\n\t\t\tbr.close();\n\t\t\t\n\t\t\tFileWriter fw=new FileWriter(new File(filename));\n\t\t\t\n\t\t\tfw.write(sb.toString());\n\t\t\tfw.close();\n\t\t}\n\t\tcatch (Exception e)\n\t\t{\n\t\t\tSystem.out.println(\"Something went horribly wrong: \"+e.getMessage());\n\t\t}\n\t}\n}\n"}
{"id": 23172, "name": "Remove lines from a file", "source": "Translate Fortran to Python:       SUBROUTINE CROAK(GASP)\t\n       CHARACTER*(*) GASP\t\n        WRITE (6,*) \"Oh dear. \",GASP\t\n        STOP \"++ungood.\"\t\n      END\t\t\t\n\n      SUBROUTINE FILEHACK(FNAME,IST,N)\n       CHARACTER*(*) FNAME\t\n       INTEGER IST\t\t\n       INTEGER N\t\t\n       INTEGER ENUFF,L\t\t\n       PARAMETER (ENUFF = 66666)\n       CHARACTER*(ENUFF) ALINE\t\n       INTEGER NREC\t\t\n       INTEGER F,T\t\t\n       PARAMETER (F=66,T=67)\t\n       LOGICAL EXIST\n        IF (FNAME.EQ.\"\") CALL CROAK(\"Blank file name\n        IF (IST.LE.0)    CALL CROAK(\"First record must be positive\n        IF (N.LE.0)      CALL CROAK(\"Remove count must be positive\n        INQUIRE(FILE = FNAME, EXIST = EXIST)\t\n        IF (.NOT.EXIST) CALL CROAK(\"Can't find a file called \"//FNAME)\t\n        OPEN (F,FILE=FNAME,STATUS=\"OLD\",ACTION=\"READ\",FORM=\"FORMATTED\")\t\n        OPEN (T,STATUS=\"SCRATCH\",FORM=\"FORMATTED\")\t\n        NREC = 0\t\t\nCopy the desired records to a temporary file.\n   10   READ (F,11,END = 20) L,ALINE(1:MIN(L,ENUFF))\t\n   11   FORMAT (Q,A)\t\t\n        IF (L.GT.ENUFF) CALL CROAK(\"Ow\n        NREC = NREC + 1\t\t\n        IF (NREC.LT.IST .OR. NREC.GE.IST + N) WRITE (T,12) ALINE(1:L)\t\n   12   FORMAT (A)\t\t\n        GO TO 10\t\t\nConvert from input to output...\n   20   IF (NREC.LT.IST + N) CALL CROAK(\"Insufficient records\n        REWIND T\t\t\n        CLOSE(F)\t\t\n        OPEN (F,FILE=FNAME,FORM=\"FORMATTED\",\t\n     1   ACTION=\"WRITE\",STATUS=\"REPLACE\")\t\nCopy from the temporary file.\n   21   READ (T,11,END = 30) L,ALINE(1:L)\t\n        WRITE (F,12) ALINE(1:L)\t\t\t\n        GO TO 21\t\t\nCompleted.\n   30   CLOSE(T)\t\t\n        CLOSE(F)\t\t\n      END\t\t\n\n      PROGRAM CHOPPER\n       CALL FILEHACK(\"foobar.txt\",1,2)\n      END\n", "target": "\n\nimport fileinput, sys\n\nfname, start, count = sys.argv[1:4]\nstart, count = int(start), int(count)\n\nfor line in fileinput.input(fname, inplace=1, backup='.orig'):\n    if start <= fileinput.lineno() < start + count:\n        pass\n    else:\n        print line.rstrip(\"\\n\")\nfileinput.close()\n"}
{"id": 23173, "name": "Remove lines from a file", "source": "Translate Fortran to Python:       SUBROUTINE CROAK(GASP)\t\n       CHARACTER*(*) GASP\t\n        WRITE (6,*) \"Oh dear. \",GASP\t\n        STOP \"++ungood.\"\t\n      END\t\t\t\n\n      SUBROUTINE FILEHACK(FNAME,IST,N)\n       CHARACTER*(*) FNAME\t\n       INTEGER IST\t\t\n       INTEGER N\t\t\n       INTEGER ENUFF,L\t\t\n       PARAMETER (ENUFF = 66666)\n       CHARACTER*(ENUFF) ALINE\t\n       INTEGER NREC\t\t\n       INTEGER F,T\t\t\n       PARAMETER (F=66,T=67)\t\n       LOGICAL EXIST\n        IF (FNAME.EQ.\"\") CALL CROAK(\"Blank file name\n        IF (IST.LE.0)    CALL CROAK(\"First record must be positive\n        IF (N.LE.0)      CALL CROAK(\"Remove count must be positive\n        INQUIRE(FILE = FNAME, EXIST = EXIST)\t\n        IF (.NOT.EXIST) CALL CROAK(\"Can't find a file called \"//FNAME)\t\n        OPEN (F,FILE=FNAME,STATUS=\"OLD\",ACTION=\"READ\",FORM=\"FORMATTED\")\t\n        OPEN (T,STATUS=\"SCRATCH\",FORM=\"FORMATTED\")\t\n        NREC = 0\t\t\nCopy the desired records to a temporary file.\n   10   READ (F,11,END = 20) L,ALINE(1:MIN(L,ENUFF))\t\n   11   FORMAT (Q,A)\t\t\n        IF (L.GT.ENUFF) CALL CROAK(\"Ow\n        NREC = NREC + 1\t\t\n        IF (NREC.LT.IST .OR. NREC.GE.IST + N) WRITE (T,12) ALINE(1:L)\t\n   12   FORMAT (A)\t\t\n        GO TO 10\t\t\nConvert from input to output...\n   20   IF (NREC.LT.IST + N) CALL CROAK(\"Insufficient records\n        REWIND T\t\t\n        CLOSE(F)\t\t\n        OPEN (F,FILE=FNAME,FORM=\"FORMATTED\",\t\n     1   ACTION=\"WRITE\",STATUS=\"REPLACE\")\t\nCopy from the temporary file.\n   21   READ (T,11,END = 30) L,ALINE(1:L)\t\n        WRITE (F,12) ALINE(1:L)\t\t\t\n        GO TO 21\t\t\nCompleted.\n   30   CLOSE(T)\t\t\n        CLOSE(F)\t\t\n      END\t\t\n\n      PROGRAM CHOPPER\n       CALL FILEHACK(\"foobar.txt\",1,2)\n      END\n", "target": "\n\nimport fileinput, sys\n\nfname, start, count = sys.argv[1:4]\nstart, count = int(start), int(count)\n\nfor line in fileinput.input(fname, inplace=1, backup='.orig'):\n    if start <= fileinput.lineno() < start + count:\n        pass\n    else:\n        print line.rstrip(\"\\n\")\nfileinput.close()\n"}
{"id": 23508, "name": "String case", "source": "Translate Fortran to C#:  program example\n  \n   implicit none\n   \n   character(9) :: teststring = \"alphaBETA\"\n  \n   call To_upper(teststring)\n   write(*,*) teststring\n   call To_lower(teststring)\n   write(*,*) teststring\n  \n contains\n \n   subroutine To_upper(str)\n     character(*), intent(in out) :: str\n     integer :: i\n  \n     do i = 1, len(str)\n       select case(str(i:i))\n         case(\"a\":\"z\")\n           str(i:i) = achar(iachar(str(i:i))-32)\n       end select\n     end do \n   end subroutine To_upper\n \n   subroutine To_lower(str)\n     character(*), intent(in out) :: str\n     integer :: i\n  \n     do i = 1, len(str)\n       select case(str(i:i))\n         case(\"A\":\"Z\")\n           str(i:i) = achar(iachar(str(i:i))+32)\n       end select\n     end do  \n   end subroutine To_Lower\n\n end program example\n", "target": "using System;\n\nnamespace StringCase\n{\n  class Program\n  {\n    public static void Main()\n    {\n      String input = scope .(\"alphaBETA\");\n      input.ToUpper();\n      Console.WriteLine(input);\n      input.ToLower();\n      Console.WriteLine(input);\n    }\n  }\n}\n"}
{"id": 23511, "name": "String case", "source": "Translate Fortran to Java:  program example\n  \n   implicit none\n   \n   character(9) :: teststring = \"alphaBETA\"\n  \n   call To_upper(teststring)\n   write(*,*) teststring\n   call To_lower(teststring)\n   write(*,*) teststring\n  \n contains\n \n   subroutine To_upper(str)\n     character(*), intent(in out) :: str\n     integer :: i\n  \n     do i = 1, len(str)\n       select case(str(i:i))\n         case(\"a\":\"z\")\n           str(i:i) = achar(iachar(str(i:i))-32)\n       end select\n     end do \n   end subroutine To_upper\n \n   subroutine To_lower(str)\n     character(*), intent(in out) :: str\n     integer :: i\n  \n     do i = 1, len(str)\n       select case(str(i:i))\n         case(\"A\":\"Z\")\n           str(i:i) = achar(iachar(str(i:i))+32)\n       end select\n     end do  \n   end subroutine To_Lower\n\n end program example\n", "target": "String str = \"alphaBETA\";\nSystem.out.println(str.toUpperCase());\nSystem.out.println(str.toLowerCase());\n\nSystem.out.println(\"\u00e4\u00e0\u00e2\u00e1\u00e7\u00f1\u00df\u00e6\u03b5\u0431\u1ebf\".toUpperCase());\nSystem.out.println(\"\u00c4\u00c0\u00c2\u00c1\u00c7\u00d1SS\u00c6\u0395\u0411\u1ebe\".toLowerCase()); \n"}
{"id": 23512, "name": "String case", "source": "Translate Fortran to Python:  program example\n  \n   implicit none\n   \n   character(9) :: teststring = \"alphaBETA\"\n  \n   call To_upper(teststring)\n   write(*,*) teststring\n   call To_lower(teststring)\n   write(*,*) teststring\n  \n contains\n \n   subroutine To_upper(str)\n     character(*), intent(in out) :: str\n     integer :: i\n  \n     do i = 1, len(str)\n       select case(str(i:i))\n         case(\"a\":\"z\")\n           str(i:i) = achar(iachar(str(i:i))-32)\n       end select\n     end do \n   end subroutine To_upper\n \n   subroutine To_lower(str)\n     character(*), intent(in out) :: str\n     integer :: i\n  \n     do i = 1, len(str)\n       select case(str(i:i))\n         case(\"A\":\"Z\")\n           str(i:i) = achar(iachar(str(i:i))+32)\n       end select\n     end do  \n   end subroutine To_Lower\n\n end program example\n", "target": "s = \"alphaBETA\"\nprint s.upper() \nprint s.lower() \n\nprint s.swapcase() \n\nprint \"fOo bAR\".capitalize() \nprint \"fOo bAR\".title() \n\nimport string\nprint string.capwords(\"fOo bAR\") \n"}
{"id": 23730, "name": "Cramer's rule", "source": "Translate Fortran to C#:       DATA A/2, -1,  5,  1\n     1       3,  2,  2, -6\n     2       1,  3,  3, -1\n     3       5, -2, -3,  3/\n", "target": "using System;\nusing System.Collections.Generic;\nusing static System.Linq.Enumerable;\n\npublic static class CramersRule\n{\n    public static void Main() {\n        var equations = new [] {\n            new [] { 2, -1,  5,  1,  -3 },\n            new [] { 3,  2,  2, -6, -32 },\n            new [] { 1,  3,  3, -1, -47 },\n            new [] { 5, -2, -3,  3,  49 }\n        };\n        var solution = SolveCramer(equations);\n        Console.WriteLine(solution.DelimitWith(\", \"));\n    }\n\n    public static int[] SolveCramer(int[][] equations) {\n        int size = equations.Length;\n        if (equations.Any(eq => eq.Length != size + 1)) throw new ArgumentException($\"Each equation must have {size+1} terms.\");\n        int[,] matrix = new int[size, size];\n        int[] column = new int[size];\n        for (int r = 0; r < size; r++) {\n            column[r] = equations[r][size];\n            for (int c = 0; c < size; c++) {\n                matrix[r, c] = equations[r][c];\n            }\n        }\n        return Solve(new SubMatrix(matrix, column));\n    }\n\n    private static int[] Solve(SubMatrix matrix) {\n        int det = matrix.Det();\n        if (det == 0) throw new ArgumentException(\"The determinant is zero.\");\n\n        int[] answer = new int[matrix.Size];\n        for (int i = 0; i < matrix.Size; i++) {\n            matrix.ColumnIndex = i;\n            answer[i] = matrix.Det() / det;\n        }\n        return answer;\n    }\n\n    \n    static string DelimitWith<T>(this IEnumerable<T> source, string separator = \" \") =>\n        string.Join(separator ?? \" \", source ?? Empty<T>());\n\n    private class SubMatrix\n    {\n        private int[,] source;\n        private SubMatrix prev;\n        private int[] replaceColumn;\n\n        public SubMatrix(int[,] source, int[] replaceColumn) {\n            this.source = source;\n            this.replaceColumn = replaceColumn;\n            this.prev = null;\n            this.ColumnIndex = -1;\n            Size = replaceColumn.Length;\n        }\n\n        private SubMatrix(SubMatrix prev, int deletedColumnIndex = -1) {\n            this.source = null;\n            this.prev = prev;\n            this.ColumnIndex = deletedColumnIndex;\n            Size = prev.Size - 1;\n        }\n\n        public int ColumnIndex { get; set; }\n        public int Size { get; }\n\n        public int this[int row, int column] {\n            get {\n                if (source != null) return column == ColumnIndex ? replaceColumn[row] : source[row, column];\n                return prev[row + 1, column < ColumnIndex ? column : column + 1];\n            }\n        }\n\n        public int Det() {\n            if (Size == 1) return this[0, 0];\n            if (Size == 2) return this[0, 0] * this[1, 1] - this[0, 1] * this[1, 0];\n            SubMatrix m = new SubMatrix(this);\n            int det = 0;\n            int sign = 1;\n            for (int c = 0; c < Size; c++) {\n                m.ColumnIndex = c;\n                int d = m.Det();\n                det += this[0, c] * d * sign;\n                sign = -sign;\n            }\n            return det;\n        }\n\n        public void Print() {\n            for (int r = 0; r < Size; r++) {\n                Console.WriteLine(Range(0, Size).Select(c => this[r, c]).DelimitWith(\", \"));\n            }\n            Console.WriteLine();\n        }\n    }\n\n}\n"}
{"id": 23733, "name": "Cramer's rule", "source": "Translate Fortran to Java:       DATA A/2, -1,  5,  1\n     1       3,  2,  2, -6\n     2       1,  3,  3, -1\n     3       5, -2, -3,  3/\n", "target": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\n\npublic class CramersRule {\n\n    public static void main(String[] args) {\n        Matrix mat = new Matrix(Arrays.asList(2d, -1d, 5d, 1d), \n                                Arrays.asList(3d, 2d, 2d, -6d), \n                                Arrays.asList(1d, 3d, 3d, -1d),\n                                Arrays.asList(5d, -2d, -3d, 3d));\n        List<Double> b = Arrays.asList(-3d, -32d, -47d, 49d);\n        System.out.println(\"Solution = \" + cramersRule(mat, b));\n    }\n    \n    private static List<Double> cramersRule(Matrix matrix, List<Double> b) {\n        double denominator = matrix.determinant();\n        List<Double> result = new ArrayList<>();\n        for ( int i = 0 ; i < b.size() ; i++ ) {\n            result.add(matrix.replaceColumn(b, i).determinant() / denominator);\n        }\n        return result;\n    }\n        \n    private static class Matrix {\n        \n        private List<List<Double>> matrix;\n        \n        @Override\n        public String toString() {\n            return matrix.toString();\n        }\n        \n        @SafeVarargs\n        public Matrix(List<Double> ... lists) {\n            matrix = new ArrayList<>();\n            for ( List<Double> list : lists) {\n                matrix.add(list);\n            }\n        }\n        \n        public Matrix(List<List<Double>> mat) {\n            matrix = mat;\n        }\n        \n        public double determinant() {\n            if ( matrix.size() == 1 ) {\n                return get(0, 0);\n            }\n            if ( matrix.size() == 2 ) {\n                return get(0, 0) * get(1, 1) - get(0, 1) * get(1, 0);\n            }\n            double sum = 0;\n            double sign = 1;\n            for ( int i = 0 ; i < matrix.size() ; i++ ) {\n                sum += sign * get(0, i) * coFactor(0, i).determinant();\n                sign *= -1;\n            }\n            return sum;\n        }\n        \n        private Matrix coFactor(int row, int col) {\n            List<List<Double>> mat = new ArrayList<>();\n            for ( int i = 0 ; i < matrix.size() ; i++ ) {\n                if ( i == row ) {\n                    continue;\n                }\n                List<Double> list = new ArrayList<>();\n                for ( int j = 0 ; j < matrix.size() ; j++ ) {\n                    if ( j == col ) {\n                        continue;\n                    }\n                    list.add(get(i, j));\n                }\n                mat.add(list);\n            }\n            return new Matrix(mat);\n        }\n\n        private Matrix replaceColumn(List<Double> b, int column) {\n            List<List<Double>> mat = new ArrayList<>();\n            for ( int row = 0 ; row < matrix.size() ; row++ ) {\n                List<Double> list = new ArrayList<>();\n                for ( int col = 0 ; col < matrix.size() ; col++ ) {\n                    double value = get(row, col);\n                    if ( col == column ) {\n                        value = b.get(row);\n                    }\n                    list.add(value);\n                }\n                mat.add(list);\n            }\n            return new Matrix(mat);\n        }\n\n        private double get(int row, int col) {\n            return matrix.get(row).get(col);\n        }\n        \n    }\n\n}\n"}
{"id": 23734, "name": "Cramer's rule", "source": "Translate Fortran to Python:       DATA A/2, -1,  5,  1\n     1       3,  2,  2, -6\n     2       1,  3,  3, -1\n     3       5, -2, -3,  3/\n", "target": "def det(m,n):\n if n==1: return m[0][0]\n z=0\n for r in range(n):\n  k=m[:]\n  del k[r]\n  z+=m[r][0]*(-1)**r*det([p[1:]for p in k],n-1)\n return z\nw=len(t)\nd=det(h,w)\nif d==0:r=[]\nelse:r=[det([r[0:i]+[s]+r[i+1:]for r,s in zip(h,t)],w)/d for i in range(w)]\nprint(r)\n"}
{"id": 23894, "name": "Euler's identity", "source": "Translate Fortran to C#: program euler\n    use iso_fortran_env, only: output_unit, REAL64\n    implicit none\n\n    integer, parameter              :: d=REAL64\n    real(kind=d), parameter         :: e=exp(1._d), pi=4._d*atan(1._d)\n    complex(kind=d), parameter      :: i=(0._d,1._d)\n\n    write(output_unit,*) e**(pi*i) + 1\nend program euler\n", "target": "using System;\nusing System.Numerics;\n\npublic class Program\n{\n    static void Main() {\n        Complex e = Math.E;\n        Complex i = Complex.ImaginaryOne;\n        Complex \u03c0 = Math.PI;\n        Console.WriteLine(Complex.Pow(e, i * \u03c0) + 1);\n    }\n}\n"}
{"id": 23895, "name": "Euler's identity", "source": "Translate Fortran to C#: program euler\n    use iso_fortran_env, only: output_unit, REAL64\n    implicit none\n\n    integer, parameter              :: d=REAL64\n    real(kind=d), parameter         :: e=exp(1._d), pi=4._d*atan(1._d)\n    complex(kind=d), parameter      :: i=(0._d,1._d)\n\n    write(output_unit,*) e**(pi*i) + 1\nend program euler\n", "target": "using System;\nusing System.Numerics;\n\npublic class Program\n{\n    static void Main() {\n        Complex e = Math.E;\n        Complex i = Complex.ImaginaryOne;\n        Complex \u03c0 = Math.PI;\n        Console.WriteLine(Complex.Pow(e, i * \u03c0) + 1);\n    }\n}\n"}
{"id": 23900, "name": "Euler's identity", "source": "Translate Fortran to Java: program euler\n    use iso_fortran_env, only: output_unit, REAL64\n    implicit none\n\n    integer, parameter              :: d=REAL64\n    real(kind=d), parameter         :: e=exp(1._d), pi=4._d*atan(1._d)\n    complex(kind=d), parameter      :: i=(0._d,1._d)\n\n    write(output_unit,*) e**(pi*i) + 1\nend program euler\n", "target": "public class EulerIdentity {\n\n    public static void main(String[] args) {\n        System.out.println(\"e ^ (i*Pi) + 1 = \" + (new Complex(0, Math.PI).exp()).add(new Complex(1, 0)));\n    }\n\n    public static class Complex {\n\n        private double x, y;\n        \n        public Complex(double re, double im) {\n            x = re;\n            y = im;\n        }\n        \n        public Complex exp() {\n            double exp = Math.exp(x);\n            return new Complex(exp * Math.cos(y), exp * Math.sin(y));\n        }\n        \n        public Complex add(Complex a) {\n            return new Complex(x + a.x, y + a.y);\n        }\n        \n        @Override\n        public String toString() {\n            return x + \" + \" + y + \"i\";\n        }\n    }\n}\n"}
{"id": 23901, "name": "Euler's identity", "source": "Translate Fortran to Java: program euler\n    use iso_fortran_env, only: output_unit, REAL64\n    implicit none\n\n    integer, parameter              :: d=REAL64\n    real(kind=d), parameter         :: e=exp(1._d), pi=4._d*atan(1._d)\n    complex(kind=d), parameter      :: i=(0._d,1._d)\n\n    write(output_unit,*) e**(pi*i) + 1\nend program euler\n", "target": "public class EulerIdentity {\n\n    public static void main(String[] args) {\n        System.out.println(\"e ^ (i*Pi) + 1 = \" + (new Complex(0, Math.PI).exp()).add(new Complex(1, 0)));\n    }\n\n    public static class Complex {\n\n        private double x, y;\n        \n        public Complex(double re, double im) {\n            x = re;\n            y = im;\n        }\n        \n        public Complex exp() {\n            double exp = Math.exp(x);\n            return new Complex(exp * Math.cos(y), exp * Math.sin(y));\n        }\n        \n        public Complex add(Complex a) {\n            return new Complex(x + a.x, y + a.y);\n        }\n        \n        @Override\n        public String toString() {\n            return x + \" + \" + y + \"i\";\n        }\n    }\n}\n"}
{"id": 23902, "name": "Euler's identity", "source": "Translate Fortran to Python: program euler\n    use iso_fortran_env, only: output_unit, REAL64\n    implicit none\n\n    integer, parameter              :: d=REAL64\n    real(kind=d), parameter         :: e=exp(1._d), pi=4._d*atan(1._d)\n    complex(kind=d), parameter      :: i=(0._d,1._d)\n\n    write(output_unit,*) e**(pi*i) + 1\nend program euler\n", "target": ">>> import math\n>>> math.e ** (math.pi * 1j) + 1\n1.2246467991473532e-16j\n"}
{"id": 23903, "name": "Euler's identity", "source": "Translate Fortran to Python: program euler\n    use iso_fortran_env, only: output_unit, REAL64\n    implicit none\n\n    integer, parameter              :: d=REAL64\n    real(kind=d), parameter         :: e=exp(1._d), pi=4._d*atan(1._d)\n    complex(kind=d), parameter      :: i=(0._d,1._d)\n\n    write(output_unit,*) e**(pi*i) + 1\nend program euler\n", "target": ">>> import math\n>>> math.e ** (math.pi * 1j) + 1\n1.2246467991473532e-16j\n"}
{"id": 24249, "name": "Arithmetic-geometric mean", "source": "Translate Fortran to C#:       function agm(a,b)\n      implicit none\n      double precision agm,a,b,eps,c\n      parameter(eps=1.0d-15)\n   10 c=0.5d0*(a+b)\n      b=sqrt(a*b)\n      a=c\n      if(a-b.gt.eps*a) go to 10\n      agm=0.5d0*(a+b)\n      end\n      program test\n      implicit none\n      double precision agm\n      print*,agm(1.0d0,1.0d0/sqrt(2.0d0))\n      end\n", "target": "namespace RosettaCode.ArithmeticGeometricMean\n{\n    using System;\n    using System.Collections.Generic;\n    using System.Globalization;\n\n    internal static class Program\n    {\n        private static double ArithmeticGeometricMean(double number,\n                                                      double otherNumber,\n                                                      IEqualityComparer<double>\n                                                          comparer)\n        {\n            return comparer.Equals(number, otherNumber)\n                       ? number\n                       : ArithmeticGeometricMean(\n                           ArithmeticMean(number, otherNumber),\n                           GeometricMean(number, otherNumber), comparer);\n        }\n\n        private static double ArithmeticMean(double number, double otherNumber)\n        {\n            return 0.5 * (number + otherNumber);\n        }\n\n        private static double GeometricMean(double number, double otherNumber)\n        {\n            return Math.Sqrt(number * otherNumber);\n        }\n\n        private static void Main()\n        {\n            Console.WriteLine(\n                ArithmeticGeometricMean(1, 0.5 * Math.Sqrt(2),\n                                        new RelativeDifferenceComparer(1e-5)).\n                    ToString(CultureInfo.InvariantCulture));\n        }\n\n        private class RelativeDifferenceComparer : IEqualityComparer<double>\n        {\n            private readonly double _maximumRelativeDifference;\n\n            internal RelativeDifferenceComparer(double maximumRelativeDifference)\n            {\n                _maximumRelativeDifference = maximumRelativeDifference;\n            }\n\n            public bool Equals(double number, double otherNumber)\n            {\n                return RelativeDifference(number, otherNumber) <=\n                       _maximumRelativeDifference;\n            }\n\n            public int GetHashCode(double number)\n            {\n                return number.GetHashCode();\n            }\n\n            private static double RelativeDifference(double number,\n                                                     double otherNumber)\n            {\n                return AbsoluteDifference(number, otherNumber) /\n                       Norm(number, otherNumber);\n            }\n\n            private static double AbsoluteDifference(double number,\n                                                     double otherNumber)\n            {\n                return Math.Abs(number - otherNumber);\n            }\n\n            private static double Norm(double number, double otherNumber)\n            {\n                return 0.5 * (Math.Abs(number) + Math.Abs(otherNumber));\n            }\n        }\n    }\n}\n"}
{"id": 24250, "name": "Arithmetic-geometric mean", "source": "Translate Fortran to C#:       function agm(a,b)\n      implicit none\n      double precision agm,a,b,eps,c\n      parameter(eps=1.0d-15)\n   10 c=0.5d0*(a+b)\n      b=sqrt(a*b)\n      a=c\n      if(a-b.gt.eps*a) go to 10\n      agm=0.5d0*(a+b)\n      end\n      program test\n      implicit none\n      double precision agm\n      print*,agm(1.0d0,1.0d0/sqrt(2.0d0))\n      end\n", "target": "namespace RosettaCode.ArithmeticGeometricMean\n{\n    using System;\n    using System.Collections.Generic;\n    using System.Globalization;\n\n    internal static class Program\n    {\n        private static double ArithmeticGeometricMean(double number,\n                                                      double otherNumber,\n                                                      IEqualityComparer<double>\n                                                          comparer)\n        {\n            return comparer.Equals(number, otherNumber)\n                       ? number\n                       : ArithmeticGeometricMean(\n                           ArithmeticMean(number, otherNumber),\n                           GeometricMean(number, otherNumber), comparer);\n        }\n\n        private static double ArithmeticMean(double number, double otherNumber)\n        {\n            return 0.5 * (number + otherNumber);\n        }\n\n        private static double GeometricMean(double number, double otherNumber)\n        {\n            return Math.Sqrt(number * otherNumber);\n        }\n\n        private static void Main()\n        {\n            Console.WriteLine(\n                ArithmeticGeometricMean(1, 0.5 * Math.Sqrt(2),\n                                        new RelativeDifferenceComparer(1e-5)).\n                    ToString(CultureInfo.InvariantCulture));\n        }\n\n        private class RelativeDifferenceComparer : IEqualityComparer<double>\n        {\n            private readonly double _maximumRelativeDifference;\n\n            internal RelativeDifferenceComparer(double maximumRelativeDifference)\n            {\n                _maximumRelativeDifference = maximumRelativeDifference;\n            }\n\n            public bool Equals(double number, double otherNumber)\n            {\n                return RelativeDifference(number, otherNumber) <=\n                       _maximumRelativeDifference;\n            }\n\n            public int GetHashCode(double number)\n            {\n                return number.GetHashCode();\n            }\n\n            private static double RelativeDifference(double number,\n                                                     double otherNumber)\n            {\n                return AbsoluteDifference(number, otherNumber) /\n                       Norm(number, otherNumber);\n            }\n\n            private static double AbsoluteDifference(double number,\n                                                     double otherNumber)\n            {\n                return Math.Abs(number - otherNumber);\n            }\n\n            private static double Norm(double number, double otherNumber)\n            {\n                return 0.5 * (Math.Abs(number) + Math.Abs(otherNumber));\n            }\n        }\n    }\n}\n"}
{"id": 24255, "name": "Arithmetic-geometric mean", "source": "Translate Fortran to Java:       function agm(a,b)\n      implicit none\n      double precision agm,a,b,eps,c\n      parameter(eps=1.0d-15)\n   10 c=0.5d0*(a+b)\n      b=sqrt(a*b)\n      a=c\n      if(a-b.gt.eps*a) go to 10\n      agm=0.5d0*(a+b)\n      end\n      program test\n      implicit none\n      double precision agm\n      print*,agm(1.0d0,1.0d0/sqrt(2.0d0))\n      end\n", "target": "\npublic class ArithmeticGeometricMean {\n\n    public static double agm(double a, double g) {\n        double a1 = a;\n        double g1 = g;\n        while (Math.abs(a1 - g1) >= 1.0e-14) {\n            double arith = (a1 + g1) / 2.0;\n            double geom = Math.sqrt(a1 * g1);\n            a1 = arith;\n            g1 = geom;\n        }\n        return a1;\n    }\n\n    public static void main(String[] args) {\n        System.out.println(agm(1.0, 1.0 / Math.sqrt(2.0)));\n    }\n}\n"}
{"id": 24256, "name": "Arithmetic-geometric mean", "source": "Translate Fortran to Java:       function agm(a,b)\n      implicit none\n      double precision agm,a,b,eps,c\n      parameter(eps=1.0d-15)\n   10 c=0.5d0*(a+b)\n      b=sqrt(a*b)\n      a=c\n      if(a-b.gt.eps*a) go to 10\n      agm=0.5d0*(a+b)\n      end\n      program test\n      implicit none\n      double precision agm\n      print*,agm(1.0d0,1.0d0/sqrt(2.0d0))\n      end\n", "target": "\npublic class ArithmeticGeometricMean {\n\n    public static double agm(double a, double g) {\n        double a1 = a;\n        double g1 = g;\n        while (Math.abs(a1 - g1) >= 1.0e-14) {\n            double arith = (a1 + g1) / 2.0;\n            double geom = Math.sqrt(a1 * g1);\n            a1 = arith;\n            g1 = geom;\n        }\n        return a1;\n    }\n\n    public static void main(String[] args) {\n        System.out.println(agm(1.0, 1.0 / Math.sqrt(2.0)));\n    }\n}\n"}
{"id": 24257, "name": "Arithmetic-geometric mean", "source": "Translate Fortran to Python:       function agm(a,b)\n      implicit none\n      double precision agm,a,b,eps,c\n      parameter(eps=1.0d-15)\n   10 c=0.5d0*(a+b)\n      b=sqrt(a*b)\n      a=c\n      if(a-b.gt.eps*a) go to 10\n      agm=0.5d0*(a+b)\n      end\n      program test\n      implicit none\n      double precision agm\n      print*,agm(1.0d0,1.0d0/sqrt(2.0d0))\n      end\n", "target": "from math import sqrt\n\ndef agm(a0, g0, tolerance=1e-10):\n    \n    an, gn = (a0 + g0) / 2.0, sqrt(a0 * g0)\n    while abs(an - gn) > tolerance:\n        an, gn = (an + gn) / 2.0, sqrt(an * gn)\n    return an\n\nprint agm(1, 1 / sqrt(2))\n"}
{"id": 24258, "name": "Arithmetic-geometric mean", "source": "Translate Fortran to Python:       function agm(a,b)\n      implicit none\n      double precision agm,a,b,eps,c\n      parameter(eps=1.0d-15)\n   10 c=0.5d0*(a+b)\n      b=sqrt(a*b)\n      a=c\n      if(a-b.gt.eps*a) go to 10\n      agm=0.5d0*(a+b)\n      end\n      program test\n      implicit none\n      double precision agm\n      print*,agm(1.0d0,1.0d0/sqrt(2.0d0))\n      end\n", "target": "from math import sqrt\n\ndef agm(a0, g0, tolerance=1e-10):\n    \n    an, gn = (a0 + g0) / 2.0, sqrt(a0 * g0)\n    while abs(an - gn) > tolerance:\n        an, gn = (an + gn) / 2.0, sqrt(an * gn)\n    return an\n\nprint agm(1, 1 / sqrt(2))\n"}
{"id": 25511, "name": "Day of the week", "source": "Translate Fortran to C#: PROGRAM YULETIDE\n \nIMPLICIT NONE\n  \nINTEGER :: day, year\n \nWRITE(*, \"(A)\", ADVANCE=\"NO\") \"25th of December is a Sunday in\"\nDO year = 2008, 2121\n   day = Day_of_week(25, 12, year)\n   IF (day == 1) WRITE(*, \"(I5)\", ADVANCE=\"NO\") year\nEND DO\n  \nCONTAINS\n \nFUNCTION Day_of_week(d, m, y)\n   INTEGER :: Day_of_week, j, k, mm, yy\n   INTEGER, INTENT(IN) :: d, m, y\n  \n   mm=m\n   yy=y\n   IF(mm.le.2) THEN\n      mm=mm+12\n      yy=yy-1\n   END IF\n   j = yy / 100\n   k = MOD(yy, 100)\n   Day_of_week = MOD(d + ((mm+1)*26)/10 + k + k/4 + j/4 + 5*j, 7)\nEND FUNCTION Day_of_week\n  \nEND PROGRAM YULETIDE\n", "target": "using System;\n\nclass Program\n{\n    static void Main(string[] args)\n    {\n        for (int i = 2008; i <= 2121; i++)\n        {\n            DateTime date = new DateTime(i, 12, 25);\n            if (date.DayOfWeek == DayOfWeek.Sunday)\n            {\n                Console.WriteLine(date.ToString(\"dd MMM yyyy\"));\n            }\n        }\n    }\n}\n"}
{"id": 25514, "name": "Day of the week", "source": "Translate Fortran to Java: PROGRAM YULETIDE\n \nIMPLICIT NONE\n  \nINTEGER :: day, year\n \nWRITE(*, \"(A)\", ADVANCE=\"NO\") \"25th of December is a Sunday in\"\nDO year = 2008, 2121\n   day = Day_of_week(25, 12, year)\n   IF (day == 1) WRITE(*, \"(I5)\", ADVANCE=\"NO\") year\nEND DO\n  \nCONTAINS\n \nFUNCTION Day_of_week(d, m, y)\n   INTEGER :: Day_of_week, j, k, mm, yy\n   INTEGER, INTENT(IN) :: d, m, y\n  \n   mm=m\n   yy=y\n   IF(mm.le.2) THEN\n      mm=mm+12\n      yy=yy-1\n   END IF\n   j = yy / 100\n   k = MOD(yy, 100)\n   Day_of_week = MOD(d + ((mm+1)*26)/10 + k + k/4 + j/4 + 5*j, 7)\nEND FUNCTION Day_of_week\n  \nEND PROGRAM YULETIDE\n", "target": "import java.util.Calendar;\nimport java.util.Date;\nimport java.util.GregorianCalendar;\n\npublic class Yuletide{\n\tpublic static void main(String[] args) {\n\t\tfor(int i = 2008;i<=2121;i++){\n\t\t\tCalendar cal = new GregorianCalendar(i, Calendar.DECEMBER,\n\t\t\t\t\t25);\n\t\t\tif(cal.get(Calendar.DAY_OF_WEEK)==Calendar.SUNDAY){\n\t\t\t\tSystem.out.println(cal.getTime());\n\t\t\t}\n\t\t}\n\t}\n}\n"}
{"id": 25515, "name": "Day of the week", "source": "Translate Fortran to Python: PROGRAM YULETIDE\n \nIMPLICIT NONE\n  \nINTEGER :: day, year\n \nWRITE(*, \"(A)\", ADVANCE=\"NO\") \"25th of December is a Sunday in\"\nDO year = 2008, 2121\n   day = Day_of_week(25, 12, year)\n   IF (day == 1) WRITE(*, \"(I5)\", ADVANCE=\"NO\") year\nEND DO\n  \nCONTAINS\n \nFUNCTION Day_of_week(d, m, y)\n   INTEGER :: Day_of_week, j, k, mm, yy\n   INTEGER, INTENT(IN) :: d, m, y\n  \n   mm=m\n   yy=y\n   IF(mm.le.2) THEN\n      mm=mm+12\n      yy=yy-1\n   END IF\n   j = yy / 100\n   k = MOD(yy, 100)\n   Day_of_week = MOD(d + ((mm+1)*26)/10 + k + k/4 + j/4 + 5*j, 7)\nEND FUNCTION Day_of_week\n  \nEND PROGRAM YULETIDE\n", "target": "from calendar import weekday, SUNDAY\n\n[year for year in range(2008, 2122) if weekday(year, 12, 25) == SUNDAY]\n"}
{"id": 26231, "name": "Short-circuit evaluation", "source": "Translate Fortran to C#: program Short_Circuit_Eval\n  implicit none\n\n  logical :: x, y\n  logical, dimension(2) :: l = (/ .false., .true. /)\n  integer :: i, j\n\n  do i = 1, 2\n    do j = 1, 2\n      write(*, \"(a,l1,a,l1,a)\") \"Calculating x = a(\", l(i), \") and b(\", l(j), \")\"   \n      \n      x = a(l(i))  \n      if(x) then\n        x = b(l(j))\n        write(*, \"(a,l1)\") \"x = \", x\n      else\n        write(*, \"(a,l1)\") \"x = \", x\n      end if\n  \n      write(*,*)\n      write(*, \"(a,l1,a,l1,a)\") \"Calculating y = a(\", l(i), \") or b(\", l(j), \")\"   \n      \n      y = a(l(i))\n      if(y) then\n        write(*, \"(a,l1)\") \"y = \", y\n      else\n        y = b(l(j))\n        write(*, \"(a,l1)\") \"y = \", y\n      end if\n      write(*,*)\n    end do\n  end do\n\ncontains\n\nfunction a(value)\n  logical :: a\n  logical, intent(in) :: value\n\n  a = value\n  write(*, \"(a,l1,a)\") \"Called function a(\", value, \")\"\nend function\n\nfunction b(value)\n  logical :: b\n  logical, intent(in) :: value\n  \n  b = value\n  write(*, \"(a,l1,a)\") \"Called function b(\", value, \")\"\nend function\nend program\n", "target": "using System;\n\nclass Program\n{\n    static bool a(bool value)\n    {\n        Console.WriteLine(\"a\");\n        return value;\n    }\n\n    static bool b(bool value)\n    {\n        Console.WriteLine(\"b\");\n        return value;\n    }\n\n    static void Main()\n    {\n        foreach (var i in new[] { false, true })\n        {\n            foreach (var j in new[] { false, true })\n            {\n                Console.WriteLine(\"{0} and {1} = {2}\", i, j, a(i) && b(j));\n                Console.WriteLine();\n                Console.WriteLine(\"{0} or {1} = {2}\", i, j, a(i) || b(j));\n                Console.WriteLine();\n            }\n        }\n    }\n}\n"}
{"id": 26234, "name": "Short-circuit evaluation", "source": "Translate Fortran to Java: program Short_Circuit_Eval\n  implicit none\n\n  logical :: x, y\n  logical, dimension(2) :: l = (/ .false., .true. /)\n  integer :: i, j\n\n  do i = 1, 2\n    do j = 1, 2\n      write(*, \"(a,l1,a,l1,a)\") \"Calculating x = a(\", l(i), \") and b(\", l(j), \")\"   \n      \n      x = a(l(i))  \n      if(x) then\n        x = b(l(j))\n        write(*, \"(a,l1)\") \"x = \", x\n      else\n        write(*, \"(a,l1)\") \"x = \", x\n      end if\n  \n      write(*,*)\n      write(*, \"(a,l1,a,l1,a)\") \"Calculating y = a(\", l(i), \") or b(\", l(j), \")\"   \n      \n      y = a(l(i))\n      if(y) then\n        write(*, \"(a,l1)\") \"y = \", y\n      else\n        y = b(l(j))\n        write(*, \"(a,l1)\") \"y = \", y\n      end if\n      write(*,*)\n    end do\n  end do\n\ncontains\n\nfunction a(value)\n  logical :: a\n  logical, intent(in) :: value\n\n  a = value\n  write(*, \"(a,l1,a)\") \"Called function a(\", value, \")\"\nend function\n\nfunction b(value)\n  logical :: b\n  logical, intent(in) :: value\n  \n  b = value\n  write(*, \"(a,l1,a)\") \"Called function b(\", value, \")\"\nend function\nend program\n", "target": "module test\n    {\n    @Inject Console console;\n\n    static Boolean show(String name, Boolean value)\n        {\n        console.print($\"{name}()={value}\");\n        return value;\n        }\n\n    void run()\n        {\n        val a = show(\"a\", _);\n        val b = show(\"b\", _);\n\n        for (Boolean v1 : False..True)\n            {\n            for (Boolean v2 : False..True)\n                {\n                console.print($\"a({v1}) && b({v2}) == {a(v1) && b(v2)}\");\n                console.print();\n                console.print($\"a({v1}) || b({v2}) == {a(v1) || b(v2)}\");\n                console.print();\n                }\n            }\n        }\n    }\n"}
{"id": 26235, "name": "Short-circuit evaluation", "source": "Translate Fortran to Python: program Short_Circuit_Eval\n  implicit none\n\n  logical :: x, y\n  logical, dimension(2) :: l = (/ .false., .true. /)\n  integer :: i, j\n\n  do i = 1, 2\n    do j = 1, 2\n      write(*, \"(a,l1,a,l1,a)\") \"Calculating x = a(\", l(i), \") and b(\", l(j), \")\"   \n      \n      x = a(l(i))  \n      if(x) then\n        x = b(l(j))\n        write(*, \"(a,l1)\") \"x = \", x\n      else\n        write(*, \"(a,l1)\") \"x = \", x\n      end if\n  \n      write(*,*)\n      write(*, \"(a,l1,a,l1,a)\") \"Calculating y = a(\", l(i), \") or b(\", l(j), \")\"   \n      \n      y = a(l(i))\n      if(y) then\n        write(*, \"(a,l1)\") \"y = \", y\n      else\n        y = b(l(j))\n        write(*, \"(a,l1)\") \"y = \", y\n      end if\n      write(*,*)\n    end do\n  end do\n\ncontains\n\nfunction a(value)\n  logical :: a\n  logical, intent(in) :: value\n\n  a = value\n  write(*, \"(a,l1,a)\") \"Called function a(\", value, \")\"\nend function\n\nfunction b(value)\n  logical :: b\n  logical, intent(in) :: value\n  \n  b = value\n  write(*, \"(a,l1,a)\") \"Called function b(\", value, \")\"\nend function\nend program\n", "target": ">>> def a(answer):\n\tprint(\"  \n\treturn answer\n\n>>> def b(answer):\n\tprint(\"  \n\treturn answer\n\n>>> for i in (False, True):\n\tfor j in (False, True):\n\t\tprint (\"\\nCalculating: x = a(i) and b(j)\")\n\t\tx = a(i) and b(j)\n\t\tprint (\"Calculating: y = a(i) or  b(j)\")\n\t\ty = a(i) or  b(j)\n\n\t\t\n\nCalculating: x = a(i) and b(j)\n  \nCalculating: y = a(i) or  b(j)\n  \n  \n\nCalculating: x = a(i) and b(j)\n  \nCalculating: y = a(i) or  b(j)\n  \n  \n\nCalculating: x = a(i) and b(j)\n  \n  \nCalculating: y = a(i) or  b(j)\n  \n\nCalculating: x = a(i) and b(j)\n  \n  \nCalculating: y = a(i) or  b(j)\n  \n"}
{"id": 26548, "name": "ISBN13 check digit", "source": "Translate Fortran to C#: program isbn13\n    implicit none\n\n    character(len=14), dimension(4), parameter  :: isbns=[\"978-1734314502\", \"978-1734314509\", \"978-1788399081\", \"978-1788399083\"]\n    integer                                     :: i\n\n    do i = 1, ubound(isbns, 1)\n        if (check_isbn13(isbns(i))) then\n            print*, isbns(i), \"\u00a0: \", \"good\"\n        else\n            print*, isbns(i), \"\u00a0: \", \"bad\"\n        end if\n    end do\ncontains\n    pure function check_isbn13(isbn)\n        character(len=*), intent(in)    :: isbn\n        logical                         :: check_isbn13\n        integer                         :: summ, counter, i, digit\n\n        check_isbn13 = .false.\n        counter = 0\n        summ = 0\n\n        do i = 1, len(isbn)\n            if (isbn(i:i) == ' ' .or. isbn(i:i) == '-') cycle\n            counter = counter + 1\n            read(isbn(i:i), '(I1)') digit\n            if (modulo(counter, 2) == 0) then\n                summ = summ + 3*digit\n            else\n                summ = summ + digit\n            end if\n        end do\n        if (counter == 13 .and. modulo(summ, 10) == 0) check_isbn13 = .true.\n    end function check_isbn13\nend program isbn13\n", "target": "using System;\nusing System.Linq;\n\npublic class Program\n{\n    public static void Main() {\n        Console.WriteLine(CheckISBN13(\"978-1734314502\"));\n        Console.WriteLine(CheckISBN13(\"978-1734314509\"));\n        Console.WriteLine(CheckISBN13(\"978-1788399081\"));\n        Console.WriteLine(CheckISBN13(\"978-1788399083\"));\n\n        static bool CheckISBN13(string code) {\n            code = code.Replace(\"-\", \"\").Replace(\" \", \"\");\n            if (code.Length != 13) return false;\n            int sum = 0;\n            foreach (var (index, digit) in code.Select((digit, index) => (index, digit))) {\n                if (char.IsDigit(digit)) sum += (digit - '0') * (index % 2 == 0 ? 1 : 3);\n                else return false;\n            }\n            return sum % 10 == 0;\n        }\n    }\n}\n"}
{"id": 26549, "name": "ISBN13 check digit", "source": "Translate Fortran to C#: program isbn13\n    implicit none\n\n    character(len=14), dimension(4), parameter  :: isbns=[\"978-1734314502\", \"978-1734314509\", \"978-1788399081\", \"978-1788399083\"]\n    integer                                     :: i\n\n    do i = 1, ubound(isbns, 1)\n        if (check_isbn13(isbns(i))) then\n            print*, isbns(i), \"\u00a0: \", \"good\"\n        else\n            print*, isbns(i), \"\u00a0: \", \"bad\"\n        end if\n    end do\ncontains\n    pure function check_isbn13(isbn)\n        character(len=*), intent(in)    :: isbn\n        logical                         :: check_isbn13\n        integer                         :: summ, counter, i, digit\n\n        check_isbn13 = .false.\n        counter = 0\n        summ = 0\n\n        do i = 1, len(isbn)\n            if (isbn(i:i) == ' ' .or. isbn(i:i) == '-') cycle\n            counter = counter + 1\n            read(isbn(i:i), '(I1)') digit\n            if (modulo(counter, 2) == 0) then\n                summ = summ + 3*digit\n            else\n                summ = summ + digit\n            end if\n        end do\n        if (counter == 13 .and. modulo(summ, 10) == 0) check_isbn13 = .true.\n    end function check_isbn13\nend program isbn13\n", "target": "using System;\nusing System.Linq;\n\npublic class Program\n{\n    public static void Main() {\n        Console.WriteLine(CheckISBN13(\"978-1734314502\"));\n        Console.WriteLine(CheckISBN13(\"978-1734314509\"));\n        Console.WriteLine(CheckISBN13(\"978-1788399081\"));\n        Console.WriteLine(CheckISBN13(\"978-1788399083\"));\n\n        static bool CheckISBN13(string code) {\n            code = code.Replace(\"-\", \"\").Replace(\" \", \"\");\n            if (code.Length != 13) return false;\n            int sum = 0;\n            foreach (var (index, digit) in code.Select((digit, index) => (index, digit))) {\n                if (char.IsDigit(digit)) sum += (digit - '0') * (index % 2 == 0 ? 1 : 3);\n                else return false;\n            }\n            return sum % 10 == 0;\n        }\n    }\n}\n"}
{"id": 26554, "name": "ISBN13 check digit", "source": "Translate Fortran to Java: program isbn13\n    implicit none\n\n    character(len=14), dimension(4), parameter  :: isbns=[\"978-1734314502\", \"978-1734314509\", \"978-1788399081\", \"978-1788399083\"]\n    integer                                     :: i\n\n    do i = 1, ubound(isbns, 1)\n        if (check_isbn13(isbns(i))) then\n            print*, isbns(i), \"\u00a0: \", \"good\"\n        else\n            print*, isbns(i), \"\u00a0: \", \"bad\"\n        end if\n    end do\ncontains\n    pure function check_isbn13(isbn)\n        character(len=*), intent(in)    :: isbn\n        logical                         :: check_isbn13\n        integer                         :: summ, counter, i, digit\n\n        check_isbn13 = .false.\n        counter = 0\n        summ = 0\n\n        do i = 1, len(isbn)\n            if (isbn(i:i) == ' ' .or. isbn(i:i) == '-') cycle\n            counter = counter + 1\n            read(isbn(i:i), '(I1)') digit\n            if (modulo(counter, 2) == 0) then\n                summ = summ + 3*digit\n            else\n                summ = summ + digit\n            end if\n        end do\n        if (counter == 13 .and. modulo(summ, 10) == 0) check_isbn13 = .true.\n    end function check_isbn13\nend program isbn13\n", "target": "public static void main(){\n        System.out.println(isISBN13(\"978-1734314502\"));\n        System.out.println(isISBN13(\"978-1734314509\"));\n        System.out.println(isISBN13(\"978-1788399081\"));\n        System.out.println(isISBN13(\"978-1788399083\"));\n    }\npublic static boolean isISBN13(String in){\n        int pre = Integer.parseInt(in.substring(0,3));\n        if (pre!=978)return false;\n        String postStr = in.substring(4);\n        if (postStr.length()!=10)return false;\n        int post = Integer.parseInt(postStr);\n        int sum = 38;\n        for(int x = 0; x<10;x+=2)\n        sum += (postStr.charAt(x)-48)*3 + ((postStr.charAt(x+1)-48));\n        if(sum%10==0) return true;\n        return false;\n    }\n"}
{"id": 26555, "name": "ISBN13 check digit", "source": "Translate Fortran to Java: program isbn13\n    implicit none\n\n    character(len=14), dimension(4), parameter  :: isbns=[\"978-1734314502\", \"978-1734314509\", \"978-1788399081\", \"978-1788399083\"]\n    integer                                     :: i\n\n    do i = 1, ubound(isbns, 1)\n        if (check_isbn13(isbns(i))) then\n            print*, isbns(i), \"\u00a0: \", \"good\"\n        else\n            print*, isbns(i), \"\u00a0: \", \"bad\"\n        end if\n    end do\ncontains\n    pure function check_isbn13(isbn)\n        character(len=*), intent(in)    :: isbn\n        logical                         :: check_isbn13\n        integer                         :: summ, counter, i, digit\n\n        check_isbn13 = .false.\n        counter = 0\n        summ = 0\n\n        do i = 1, len(isbn)\n            if (isbn(i:i) == ' ' .or. isbn(i:i) == '-') cycle\n            counter = counter + 1\n            read(isbn(i:i), '(I1)') digit\n            if (modulo(counter, 2) == 0) then\n                summ = summ + 3*digit\n            else\n                summ = summ + digit\n            end if\n        end do\n        if (counter == 13 .and. modulo(summ, 10) == 0) check_isbn13 = .true.\n    end function check_isbn13\nend program isbn13\n", "target": "public static void main(){\n        System.out.println(isISBN13(\"978-1734314502\"));\n        System.out.println(isISBN13(\"978-1734314509\"));\n        System.out.println(isISBN13(\"978-1788399081\"));\n        System.out.println(isISBN13(\"978-1788399083\"));\n    }\npublic static boolean isISBN13(String in){\n        int pre = Integer.parseInt(in.substring(0,3));\n        if (pre!=978)return false;\n        String postStr = in.substring(4);\n        if (postStr.length()!=10)return false;\n        int post = Integer.parseInt(postStr);\n        int sum = 38;\n        for(int x = 0; x<10;x+=2)\n        sum += (postStr.charAt(x)-48)*3 + ((postStr.charAt(x+1)-48));\n        if(sum%10==0) return true;\n        return false;\n    }\n"}
{"id": 26556, "name": "ISBN13 check digit", "source": "Translate Fortran to Python: program isbn13\n    implicit none\n\n    character(len=14), dimension(4), parameter  :: isbns=[\"978-1734314502\", \"978-1734314509\", \"978-1788399081\", \"978-1788399083\"]\n    integer                                     :: i\n\n    do i = 1, ubound(isbns, 1)\n        if (check_isbn13(isbns(i))) then\n            print*, isbns(i), \"\u00a0: \", \"good\"\n        else\n            print*, isbns(i), \"\u00a0: \", \"bad\"\n        end if\n    end do\ncontains\n    pure function check_isbn13(isbn)\n        character(len=*), intent(in)    :: isbn\n        logical                         :: check_isbn13\n        integer                         :: summ, counter, i, digit\n\n        check_isbn13 = .false.\n        counter = 0\n        summ = 0\n\n        do i = 1, len(isbn)\n            if (isbn(i:i) == ' ' .or. isbn(i:i) == '-') cycle\n            counter = counter + 1\n            read(isbn(i:i), '(I1)') digit\n            if (modulo(counter, 2) == 0) then\n                summ = summ + 3*digit\n            else\n                summ = summ + digit\n            end if\n        end do\n        if (counter == 13 .and. modulo(summ, 10) == 0) check_isbn13 = .true.\n    end function check_isbn13\nend program isbn13\n", "target": "def is_isbn13(n):\n    n = n.replace('-','').replace(' ', '')\n    if len(n) != 13:\n        return False\n    product = (sum(int(ch) for ch in n[::2]) \n               + sum(int(ch) * 3 for ch in n[1::2]))\n    return product % 10 == 0\n\nif __name__ == '__main__':\n    tests = .strip().split()\n    for t in tests:\n        print(f\"ISBN13 {t} validates {is_isbn13(t)}\")\n"}
{"id": 26557, "name": "ISBN13 check digit", "source": "Translate Fortran to Python: program isbn13\n    implicit none\n\n    character(len=14), dimension(4), parameter  :: isbns=[\"978-1734314502\", \"978-1734314509\", \"978-1788399081\", \"978-1788399083\"]\n    integer                                     :: i\n\n    do i = 1, ubound(isbns, 1)\n        if (check_isbn13(isbns(i))) then\n            print*, isbns(i), \"\u00a0: \", \"good\"\n        else\n            print*, isbns(i), \"\u00a0: \", \"bad\"\n        end if\n    end do\ncontains\n    pure function check_isbn13(isbn)\n        character(len=*), intent(in)    :: isbn\n        logical                         :: check_isbn13\n        integer                         :: summ, counter, i, digit\n\n        check_isbn13 = .false.\n        counter = 0\n        summ = 0\n\n        do i = 1, len(isbn)\n            if (isbn(i:i) == ' ' .or. isbn(i:i) == '-') cycle\n            counter = counter + 1\n            read(isbn(i:i), '(I1)') digit\n            if (modulo(counter, 2) == 0) then\n                summ = summ + 3*digit\n            else\n                summ = summ + digit\n            end if\n        end do\n        if (counter == 13 .and. modulo(summ, 10) == 0) check_isbn13 = .true.\n    end function check_isbn13\nend program isbn13\n", "target": "def is_isbn13(n):\n    n = n.replace('-','').replace(' ', '')\n    if len(n) != 13:\n        return False\n    product = (sum(int(ch) for ch in n[::2]) \n               + sum(int(ch) * 3 for ch in n[1::2]))\n    return product % 10 == 0\n\nif __name__ == '__main__':\n    tests = .strip().split()\n    for t in tests:\n        print(f\"ISBN13 {t} validates {is_isbn13(t)}\")\n"}
{"id": 27166, "name": "Look-and-say sequence", "source": "Translate Fortran to C#: module LookAndSay\n  implicit none\n\ncontains\n\n  subroutine look_and_say(in, out)\n    character(len=*), intent(in) :: in\n    character(len=*), intent(out) :: out\n\n    integer :: i, c\n    character(len=1) :: x\n    character(len=2) :: d\n\n    out = \"\"\n    c = 1\n    x = in(1:1)\n    do i = 2, len(trim(in))\n       if ( x == in(i:i) ) then\n          c = c + 1\n       else\n          write(d, \"(I2)\") c\n          out = trim(out) // trim(adjustl(d)) // trim(x)\n          c = 1\n          x = in(i:i)\n       end if\n    end do\n    write(d, \"(I2)\") c\n    out = trim(out) // trim(adjustl(d)) // trim(x)\n  end subroutine look_and_say\n\nend module LookAndSay\n", "target": "using System;\nusing System.Text;\nusing System.Linq;\n\nclass Program\n{\n    static string lookandsay(string number)\n    {\n        StringBuilder result = new StringBuilder();\n\n        char repeat = number[0];\n        number = number.Substring(1, number.Length-1)+\" \";\n        int times = 1;\n      \n        foreach (char actual in number)\n        {\n            if (actual != repeat)\n            {\n                result.Append(Convert.ToString(times)+repeat);\n                times = 1;\n                repeat = actual;\n            }\n            else\n            {\n                times += 1;\n            }\n        }\n        return result.ToString();\n    }\n\n    static void Main(string[] args)\n    {\n        string num = \"1\"; \n\n        foreach (int i in Enumerable.Range(1, 10)) {\n             Console.WriteLine(num);\n             num = lookandsay(num);             \n        }\n    }\n}\n"}
{"id": 27169, "name": "Look-and-say sequence", "source": "Translate Fortran to Java: module LookAndSay\n  implicit none\n\ncontains\n\n  subroutine look_and_say(in, out)\n    character(len=*), intent(in) :: in\n    character(len=*), intent(out) :: out\n\n    integer :: i, c\n    character(len=1) :: x\n    character(len=2) :: d\n\n    out = \"\"\n    c = 1\n    x = in(1:1)\n    do i = 2, len(trim(in))\n       if ( x == in(i:i) ) then\n          c = c + 1\n       else\n          write(d, \"(I2)\") c\n          out = trim(out) // trim(adjustl(d)) // trim(x)\n          c = 1\n          x = in(i:i)\n       end if\n    end do\n    write(d, \"(I2)\") c\n    out = trim(out) // trim(adjustl(d)) // trim(x)\n  end subroutine look_and_say\n\nend module LookAndSay\n", "target": "public static String lookandsay(String number){\n\tStringBuilder result= new StringBuilder();\n\n\tchar repeat= number.charAt(0);\n\tnumber= number.substring(1) + \" \";\n\tint times= 1;\n\n\tfor(char actual: number.toCharArray()){\n\t\tif(actual != repeat){\n\t\t\tresult.append(times + \"\" + repeat);\n\t\t\ttimes= 1;\n\t\t\trepeat= actual;\n\t\t}else{\n\t\t\ttimes+= 1;\n\t\t}\n\t}\n\treturn result.toString();\n}\n"}
{"id": 27170, "name": "Look-and-say sequence", "source": "Translate Fortran to Python: module LookAndSay\n  implicit none\n\ncontains\n\n  subroutine look_and_say(in, out)\n    character(len=*), intent(in) :: in\n    character(len=*), intent(out) :: out\n\n    integer :: i, c\n    character(len=1) :: x\n    character(len=2) :: d\n\n    out = \"\"\n    c = 1\n    x = in(1:1)\n    do i = 2, len(trim(in))\n       if ( x == in(i:i) ) then\n          c = c + 1\n       else\n          write(d, \"(I2)\") c\n          out = trim(out) // trim(adjustl(d)) // trim(x)\n          c = 1\n          x = in(i:i)\n       end if\n    end do\n    write(d, \"(I2)\") c\n    out = trim(out) // trim(adjustl(d)) // trim(x)\n  end subroutine look_and_say\n\nend module LookAndSay\n", "target": "def lookandsay(number):\n    result = \"\"\n\n    repeat = number[0]\n    number = number[1:]+\" \"\n    times = 1\n\n    for actual in number:\n        if actual != repeat:\n            result += str(times)+repeat\n            times = 1\n            repeat = actual\n        else:\n            times += 1\n\n    return result\n\nnum = \"1\"\n\nfor i in range(10):\n    print num\n    num = lookandsay(num)\n"}
{"id": 27805, "name": "Send email", "source": "Translate Fortran to C#: program sendmail\n    use ifcom\n    use msoutl\n    implicit none\n    integer(4) :: app, status, msg\n    \n    call cominitialize(status)\n    call comcreateobject(\"Outlook.Application\", app, status)\n    msg = $Application_CreateItem(app, olMailItem, status)\n    call $MailItem_SetTo(msg, \"somebody@somewhere\", status)\n    call $MailItem_SetSubject(msg, \"Title\", status)\n    call $MailItem_SetBody(msg, \"Hello\", status)\n    call $MailItem_Send(msg, status)\n    call $Application_Quit(app, status)\n    call comuninitialize()\nend program\n", "target": "static void Main(string[] args)\n{\n    \n\n    SmtpClient SMTP = new SmtpClient(\"smtp.gmail.com\", 587); \n    SMTP.EnableSsl = true; \n    SMTP.DeliveryMethod = SmtpDeliveryMethod.Network;\n    SMTP.Credentials = new NetworkCredential(\"YourUserName\", \"YourPassword\");\n    MailMessage Mail = new MailMessage(\"yourEmail@address.com\", \"theirEmail@address.com\");\n\n\n    \n\n    Mail.Subject = \"Important Message\";\n    Mail.Body = \"Hello over there\"; \n    \n\n    \n\n    SMTP.Send(Mail);\n\n    Console.WriteLine(\"Message Sent\");\n}\n"}
{"id": 27808, "name": "Send email", "source": "Translate Fortran to Java: program sendmail\n    use ifcom\n    use msoutl\n    implicit none\n    integer(4) :: app, status, msg\n    \n    call cominitialize(status)\n    call comcreateobject(\"Outlook.Application\", app, status)\n    msg = $Application_CreateItem(app, olMailItem, status)\n    call $MailItem_SetTo(msg, \"somebody@somewhere\", status)\n    call $MailItem_SetSubject(msg, \"Title\", status)\n    call $MailItem_SetBody(msg, \"Hello\", status)\n    call $MailItem_Send(msg, status)\n    call $Application_Quit(app, status)\n    call comuninitialize()\nend program\n", "target": "import java.util.Properties;\n\nimport javax.mail.MessagingException;\nimport javax.mail.Session;\nimport javax.mail.Transport;\nimport javax.mail.Message.RecipientType;\nimport javax.mail.internet.InternetAddress;\nimport javax.mail.internet.MimeMessage;\n\n\npublic class Mail\n{\n \n protected Session session;\n\n \n public Mail(String host)\n {\n  Properties properties = new Properties();\n  properties.put(\"mail.smtp.host\", host);\n  session = Session.getDefaultInstance(properties);\n }\n\n \n public void send(String from, String tos[], String ccs[], String subject,\n        String text)\n        throws MessagingException\n {\n  MimeMessage message = new MimeMessage(session);\n  message.setFrom(new InternetAddress(from));\n  for (String to : tos)\n   message.addRecipient(RecipientType.TO, new InternetAddress(to));\n  for (String cc : ccs)\n   message.addRecipient(RecipientType.TO, new InternetAddress(cc));\n  message.setSubject(subject);\n  message.setText(text);\n  Transport.send(message);\n }\n}\n"}
{"id": 27809, "name": "Send email", "source": "Translate Fortran to Python: program sendmail\n    use ifcom\n    use msoutl\n    implicit none\n    integer(4) :: app, status, msg\n    \n    call cominitialize(status)\n    call comcreateobject(\"Outlook.Application\", app, status)\n    msg = $Application_CreateItem(app, olMailItem, status)\n    call $MailItem_SetTo(msg, \"somebody@somewhere\", status)\n    call $MailItem_SetSubject(msg, \"Title\", status)\n    call $MailItem_SetBody(msg, \"Hello\", status)\n    call $MailItem_Send(msg, status)\n    call $Application_Quit(app, status)\n    call comuninitialize()\nend program\n", "target": "import smtplib\n\ndef sendemail(from_addr, to_addr_list, cc_addr_list,\n              subject, message,\n              login, password,\n              smtpserver='smtp.gmail.com:587'):\n    header  = 'From: %s\\n' % from_addr\n    header += 'To: %s\\n' % ','.join(to_addr_list)\n    header += 'Cc: %s\\n' % ','.join(cc_addr_list)\n    header += 'Subject: %s\\n\\n' % subject\n    message = header + message\n    \n    server = smtplib.SMTP(smtpserver)\n    server.starttls()\n    server.login(login,password)\n    problems = server.sendmail(from_addr, to_addr_list, message)\n    server.quit()\n    return problems\n"}
{"id": 28254, "name": "Caesar cipher", "source": "Translate Fortran to C#: program Caesar_Cipher\n  implicit none\n\n  integer, parameter :: key = 3     \n  character(43) :: message = \"The five boxing wizards jump quickly\"\n\n  write(*, \"(2a)\") \"Original message  = \", message\n  call encrypt(message)\n  write(*, \"(2a)\") \"Encrypted message = \", message\n  call decrypt(message)\n  write(*, \"(2a)\") \"Decrypted message = \", message\n  \ncontains\n\nsubroutine encrypt(text)\n  character(*), intent(inout) :: text\n  integer :: i\n  \n  do i = 1, len(text)\n    select case(text(i:i))\n      case ('A':'Z')\n        text(i:i) = achar(modulo(iachar(text(i:i)) - 65 + key, 26) + 65)\n      case ('a':'z')\n        text(i:i) = achar(modulo(iachar(text(i:i)) - 97 + key, 26) + 97)\n    end select\n  end do\nend subroutine\n\nsubroutine decrypt(text)\n  character(*), intent(inout) :: text\n  integer :: i\n  \n  do i = 1, len(text)\n    select case(text(i:i))\n      case ('A':'Z')\n        text(i:i) = achar(modulo(iachar(text(i:i)) - 65 - key, 26) + 65)\n      case ('a':'z')\n        text(i:i) = achar(modulo(iachar(text(i:i)) - 97 - key, 26) + 97)\n    end select\n  end do\nend subroutine\n\nend program Caesar_Cipher\n", "target": "using System;\nusing System.Linq;\n\nnamespace CaesarCypher\n{\n    class Program\n    {\n        static char Encrypt(char ch, int code)\n        {\n            if (!char.IsLetter(ch)) return ch;\n\n            char offset = char.IsUpper(ch) ? 'A' : 'a';\n            return (char)((ch + code - offset) % 26 + offset);\n        }\n\n        static string Encrypt(string input, int code)\n        {\n            return new string(input.Select(ch => Encrypt(ch, code)).ToArray());\n        }\n\n        static string Decrypt(string input, int code)\n        {\n            return Encrypt(input, 26 - code);\n        }\n\n        const string TestCase = \"Pack my box with five dozen liquor jugs.\";\n\n        static void Main()\n        {\n            string str = TestCase;\n\n            Console.WriteLine(str);\n            str = Encrypt(str, 5);\n            Console.WriteLine(\"Encrypted: \" + str);\n            str = Decrypt(str, 5);\n            Console.WriteLine(\"Decrypted: \" + str);\n            Console.ReadKey();\n        }\n    }\n}\n"}
{"id": 28258, "name": "Caesar cipher", "source": "Translate Fortran to Java: program Caesar_Cipher\n  implicit none\n\n  integer, parameter :: key = 3     \n  character(43) :: message = \"The five boxing wizards jump quickly\"\n\n  write(*, \"(2a)\") \"Original message  = \", message\n  call encrypt(message)\n  write(*, \"(2a)\") \"Encrypted message = \", message\n  call decrypt(message)\n  write(*, \"(2a)\") \"Decrypted message = \", message\n  \ncontains\n\nsubroutine encrypt(text)\n  character(*), intent(inout) :: text\n  integer :: i\n  \n  do i = 1, len(text)\n    select case(text(i:i))\n      case ('A':'Z')\n        text(i:i) = achar(modulo(iachar(text(i:i)) - 65 + key, 26) + 65)\n      case ('a':'z')\n        text(i:i) = achar(modulo(iachar(text(i:i)) - 97 + key, 26) + 97)\n    end select\n  end do\nend subroutine\n\nsubroutine decrypt(text)\n  character(*), intent(inout) :: text\n  integer :: i\n  \n  do i = 1, len(text)\n    select case(text(i:i))\n      case ('A':'Z')\n        text(i:i) = achar(modulo(iachar(text(i:i)) - 65 - key, 26) + 65)\n      case ('a':'z')\n        text(i:i) = achar(modulo(iachar(text(i:i)) - 97 - key, 26) + 97)\n    end select\n  end do\nend subroutine\n\nend program Caesar_Cipher\n", "target": "public class Cipher {\n    public static void main(String[] args) {\n\n        String str = \"The quick brown fox Jumped over the lazy Dog\";\n\n        System.out.println( Cipher.encode( str, 12 ));\n        System.out.println( Cipher.decode( Cipher.encode( str, 12), 12 ));\n    }\n\n    public static String decode(String enc, int offset) {\n        return encode(enc, 26-offset);\n    }\n\n    public static String encode(String enc, int offset) {\n        offset = offset % 26 + 26;\n        StringBuilder encoded = new StringBuilder();\n        for (char i : enc.toCharArray()) {\n            if (Character.isLetter(i)) {\n                if (Character.isUpperCase(i)) {\n                    encoded.append((char) ('A' + (i - 'A' + offset) % 26 ));\n                } else {\n                    encoded.append((char) ('a' + (i - 'a' + offset) % 26 ));\n                }\n            } else {\n                encoded.append(i);\n            }\n        }\n        return encoded.toString();\n    }\n}\n"}
{"id": 28259, "name": "Caesar cipher", "source": "Translate Fortran to Python: program Caesar_Cipher\n  implicit none\n\n  integer, parameter :: key = 3     \n  character(43) :: message = \"The five boxing wizards jump quickly\"\n\n  write(*, \"(2a)\") \"Original message  = \", message\n  call encrypt(message)\n  write(*, \"(2a)\") \"Encrypted message = \", message\n  call decrypt(message)\n  write(*, \"(2a)\") \"Decrypted message = \", message\n  \ncontains\n\nsubroutine encrypt(text)\n  character(*), intent(inout) :: text\n  integer :: i\n  \n  do i = 1, len(text)\n    select case(text(i:i))\n      case ('A':'Z')\n        text(i:i) = achar(modulo(iachar(text(i:i)) - 65 + key, 26) + 65)\n      case ('a':'z')\n        text(i:i) = achar(modulo(iachar(text(i:i)) - 97 + key, 26) + 97)\n    end select\n  end do\nend subroutine\n\nsubroutine decrypt(text)\n  character(*), intent(inout) :: text\n  integer :: i\n  \n  do i = 1, len(text)\n    select case(text(i:i))\n      case ('A':'Z')\n        text(i:i) = achar(modulo(iachar(text(i:i)) - 65 - key, 26) + 65)\n      case ('a':'z')\n        text(i:i) = achar(modulo(iachar(text(i:i)) - 97 - key, 26) + 97)\n    end select\n  end do\nend subroutine\n\nend program Caesar_Cipher\n", "target": "fun caesar(s, k, decode: false):\n    if decode:\n        k = 26 - k\n    result = ''\n    for i in s.uppercase() where 65 <= ord(i) <= 90:\n        result.push! char(ord(i) - 65 + k) mod 26 + 65\n    return result\n\nlet message = \"The quick brown fox jumped over the lazy dogs\"\nlet encrypted = caesar(msg, 11)\nlet decrypted = caesar(enc, 11, decode: true)\n\nprint(message, encrypted, decrypted, sep: '\\n')\n"}
{"id": 28627, "name": "Lucas-Lehmer test", "source": "Translate Fortran to C#: PROGRAM LUCAS_LEHMER\n  IMPLICIT NONE\n\n  INTEGER, PARAMETER :: i64 = SELECTED_INT_KIND(18)\n  INTEGER(i64) :: s, n\n  INTEGER :: i, exponent\n  \n  DO exponent = 2, 31\n     IF (exponent == 2) THEN\n        s = 0\n     ELSE\n        s = 4\n     END IF\n     n = 2_i64**exponent - 1\n     DO i = 1, exponent-2\n        s = MOD(s*s - 2, n)\n     END DO\n     IF (s==0) WRITE(*,\"(A,I0,A)\") \"M\", exponent, \" is PRIME\"\n  END DO\n \nEND PROGRAM LUCAS_LEHMER\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Numerics;\nusing System.Threading.Tasks;\n\nnamespace LucasLehmerTestForRosettaCode\n{\n    public class LucasLehmerTest\n    {\n        static BigInteger ZERO = new BigInteger(0);\n        static BigInteger ONE = new BigInteger(1);\n        static BigInteger TWO = new BigInteger(2);\n        static BigInteger FOUR = new BigInteger(4);\n\n        private static bool isMersennePrime(int p) \n        {\n            if (p % 2 == 0) return (p == 2);\n            else {\n                for (int i = 3; i <= (int)Math.Sqrt(p); i += 2)\n                    if (p % i == 0) return false; \n                BigInteger m_p = BigInteger.Pow(TWO, p) - ONE;\n                BigInteger s = FOUR;\n                for (int i = 3; i <= p; i++)\n                    s = (s * s - TWO) % m_p;\n                return s == ZERO;\n            } \n        }\n\n        public static int[] GetMersennePrimeNumbers(int upTo)\n        {\n            List<int> response = new List<int>();\n            Parallel.For(2, upTo + 1, i => {\n                if (isMersennePrime(i)) response.Add(i);\n            });\n            response.Sort();\n            return response.ToArray();\n        }\n\n        static void Main(string[] args)\n        {\n            int[] mersennePrimes = LucasLehmerTest.GetMersennePrimeNumbers(11213);\n            foreach (int mp in mersennePrimes)\n                Console.Write(\"M\" + mp+\" \");\n            Console.ReadLine();\n        }\n    }\n}\n"}
{"id": 28630, "name": "Lucas-Lehmer test", "source": "Translate Fortran to Java: PROGRAM LUCAS_LEHMER\n  IMPLICIT NONE\n\n  INTEGER, PARAMETER :: i64 = SELECTED_INT_KIND(18)\n  INTEGER(i64) :: s, n\n  INTEGER :: i, exponent\n  \n  DO exponent = 2, 31\n     IF (exponent == 2) THEN\n        s = 0\n     ELSE\n        s = 4\n     END IF\n     n = 2_i64**exponent - 1\n     DO i = 1, exponent-2\n        s = MOD(s*s - 2, n)\n     END DO\n     IF (s==0) WRITE(*,\"(A,I0,A)\") \"M\", exponent, \" is PRIME\"\n  END DO\n \nEND PROGRAM LUCAS_LEHMER\n", "target": "import java.math.BigInteger;\npublic class Mersenne\n{\n\n    public static boolean isPrime(int p) {\n        if (p == 2)\n            return true;\n        else if (p <= 1 || p % 2 == 0)\n            return false;\n        else {\n            int to = (int)Math.sqrt(p);\n            for (int i = 3; i <= to; i += 2)\n                if (p % i == 0)\n                    return false;\n            return true;\n        }\n    }\n\n    public static boolean isMersennePrime(int p) {\n        if (p == 2)\n            return true;\n        else {\n            BigInteger m_p = BigInteger.ONE.shiftLeft(p).subtract(BigInteger.ONE);\n            BigInteger s = BigInteger.valueOf(4);\n            for (int i = 3; i <= p; i++)\n                s = s.multiply(s).subtract(BigInteger.valueOf(2)).mod(m_p);\n            return s.equals(BigInteger.ZERO);\n        }\n    }\n\n    \n    public static void main(String[] args) {\n        int upb;\n        if (args.length == 0)\n            upb = 500;\n        else\n            upb = Integer.parseInt(args[0]);\n\n        System.out.print(\" Finding Mersenne primes in M[2..\" + upb + \"]:\\nM2 \");\n        for (int p = 3; p <= upb; p += 2)\n            if (isPrime(p) && isMersennePrime(p))\n                System.out.print(\" M\" + p);\n        System.out.println();\n    }\n}\n"}
{"id": 28631, "name": "Lucas-Lehmer test", "source": "Translate Fortran to Python: PROGRAM LUCAS_LEHMER\n  IMPLICIT NONE\n\n  INTEGER, PARAMETER :: i64 = SELECTED_INT_KIND(18)\n  INTEGER(i64) :: s, n\n  INTEGER :: i, exponent\n  \n  DO exponent = 2, 31\n     IF (exponent == 2) THEN\n        s = 0\n     ELSE\n        s = 4\n     END IF\n     n = 2_i64**exponent - 1\n     DO i = 1, exponent-2\n        s = MOD(s*s - 2, n)\n     END DO\n     IF (s==0) WRITE(*,\"(A,I0,A)\") \"M\", exponent, \" is PRIME\"\n  END DO\n \nEND PROGRAM LUCAS_LEHMER\n", "target": "from sys import stdout\nfrom math import sqrt, log\n\ndef is_prime ( p ):\n  if p == 2: return True \n  elif p <= 1 or p % 2 == 0: return False\n  else:\n    for i in range(3, int(sqrt(p))+1, 2 ): \n      if p % i == 0: return False\n    return True\n\ndef is_mersenne_prime ( p ):\n  if p == 2:\n    return True\n  else:\n    m_p = ( 1 << p ) - 1\n    s = 4\n    for i in range(3, p+1): \n      s = (s ** 2 - 2) % m_p\n    return s == 0\n\nprecision = 20000   \nlong_bits_width = precision * log(10, 2)\nupb_prime = int( long_bits_width - 1 ) / 2    \nupb_count = 45      \n\nprint (\" Finding Mersenne primes in M[2..%d]:\"%upb_prime)\n\ncount=0\nfor p in range(2, int(upb_prime+1)): \n  if is_prime(p) and is_mersenne_prime(p):\n    print(\"M%d\"%p),\n    stdout.flush()\n    count += 1\n  if count >= upb_count: break\nprint\n"}
{"id": 28829, "name": "FizzBuzz", "source": "Translate Fortran to C#: program fizzbuzz_if\n   integer :: i\n   \n   do i = 1, 100\n      if     (mod(i,15) == 0) then; print *, 'FizzBuzz'\n      else if (mod(i,3) == 0) then; print *, 'Fizz'\n      else if (mod(i,5) == 0) then; print *, 'Buzz'\n      else;                         print *, i\n      end if\n   end do\nend program fizzbuzz_if\n", "target": "class Program\n{\n    public void FizzBuzzGo()\n    {\n        Boolean Fizz = false;\n        Boolean Buzz = false;\n        for (int count = 1; count <= 100; count ++)\n        {\n            Fizz = count % 3 == 0;\n            Buzz = count % 5 == 0;\n            if (Fizz && Buzz)\n            {\n                Console.WriteLine(\"Fizz Buzz\");\n                listBox1.Items.Add(\"Fizz Buzz\");\n            }\n            else if (Fizz)\n            {\n                Console.WriteLine(\"Fizz\");\n                listBox1.Items.Add(\"Fizz\");\n            }\n            else if (Buzz)\n            {\n                Console.WriteLine(\"Buzz\");\n                listBox1.Items.Add(\"Buzz\");\n            }\n            else\n            {\n                Console.WriteLine(count);\n                listBox1.Items.Add(count);\n            }\n        }\n    }\n}\n"}
{"id": 28833, "name": "FizzBuzz", "source": "Translate Fortran to Java: program fizzbuzz_if\n   integer :: i\n   \n   do i = 1, 100\n      if     (mod(i,15) == 0) then; print *, 'FizzBuzz'\n      else if (mod(i,3) == 0) then; print *, 'Fizz'\n      else if (mod(i,5) == 0) then; print *, 'Buzz'\n      else;                         print *, i\n      end if\n   end do\nend program fizzbuzz_if\n", "target": "module FizzBuzz\n    {\n    void run()\n        {\n        @Inject Console console;\n        for (Int x : 1..100)\n            {\n            console.print(switch (x % 3, x % 5)\n                {\n                case (0, 0): \"FizzBuzz\";\n                case (0, _): \"Fizz\";\n                case (_, 0): \"Buzz\";\n                case (_, _): x.toString();\n                });\n            }\n        }\n    }\n"}
{"id": 28834, "name": "FizzBuzz", "source": "Translate Fortran to Python: program fizzbuzz_if\n   integer :: i\n   \n   do i = 1, 100\n      if     (mod(i,15) == 0) then; print *, 'FizzBuzz'\n      else if (mod(i,3) == 0) then; print *, 'Fizz'\n      else if (mod(i,5) == 0) then; print *, 'Buzz'\n      else;                         print *, i\n      end if\n   end do\nend program fizzbuzz_if\n", "target": "for i in xrange(1, 101):\n    if i % 15 == 0:\n        print \"FizzBuzz\"\n    elif i % 3 == 0:\n        print \"Fizz\"\n    elif i % 5 == 0:\n        print \"Buzz\"\n    else:\n        print i\n"}
{"id": 29088, "name": "Monty Hall problem", "source": "Translate Fortran to C#: PROGRAM MONTYHALL\n                            \n  IMPLICIT NONE  \n\n  INTEGER, PARAMETER :: trials = 10000\n  INTEGER :: i, choice, prize, remaining, show, staycount = 0, switchcount = 0\n  LOGICAL :: door(3)\n  REAL :: rnum\n\n  CALL RANDOM_SEED\n  DO i = 1, trials\n     door = .FALSE.\n     CALL RANDOM_NUMBER(rnum)\n     prize = INT(3*rnum) + 1\n     door(prize) = .TRUE.              \n    \n     CALL RANDOM_NUMBER(rnum)   \n     choice = INT(3*rnum) + 1          \n\n     DO\n        CALL RANDOM_NUMBER(rnum)   \n        show = INT(3*rnum) + 1 \n        IF (show /= choice .AND. show /= prize) EXIT       \n     END DO\n\n     SELECT CASE(choice+show)          \n       CASE(3)\n          remaining = 3\n       CASE(4)\n          remaining = 2\n       CASE(5)\n          remaining = 1\n     END SELECT\n\n     IF (door(choice)) THEN           \n        staycount = staycount + 1\n     ELSE IF (door(remaining)) THEN   \n        switchcount = switchcount + 1\n     END IF\n    \n  END DO\n\n  WRITE(*, \"(A,F6.2,A)\") \"Chance of winning by not switching is\", real(staycount)/trials*100, \"%\"\n  WRITE(*, \"(A,F6.2,A)\") \"Chance of winning by switching is\", real(switchcount)/trials*100, \"%\" \n\nEND PROGRAM MONTYHALL\n", "target": "using System;\n\nclass Program\n{\n    static void Main(string[] args)\n    {\n        int switchWins = 0;\n        int stayWins = 0;\n\n        Random gen = new Random();\n\t\t    \n        for(int plays = 0; plays < 1000000; plays++ )\n        {\n            int[] doors = {0,0,0};\n\n            var winner = gen.Next(3);\n            doors[winner] = 1; \n                \n\t    int choice = gen.Next(3); \n\t    int shown; \n\t    do\n            {\n\t        shown = gen.Next(3);\n\t    }\n            while (doors[shown] == 1 || shown == choice); \n     \n\t    stayWins += doors[choice]; \n     \n            \n            switchWins += doors[3 - choice - shown];\n        }\n\n        Console.Out.WriteLine(\"Staying wins \" + stayWins + \" times.\");\n        Console.Out.WriteLine(\"Switching wins \" + switchWins + \" times.\");\n    }\n}\n"}
{"id": 29092, "name": "Monty Hall problem", "source": "Translate Fortran to Java: PROGRAM MONTYHALL\n                            \n  IMPLICIT NONE  \n\n  INTEGER, PARAMETER :: trials = 10000\n  INTEGER :: i, choice, prize, remaining, show, staycount = 0, switchcount = 0\n  LOGICAL :: door(3)\n  REAL :: rnum\n\n  CALL RANDOM_SEED\n  DO i = 1, trials\n     door = .FALSE.\n     CALL RANDOM_NUMBER(rnum)\n     prize = INT(3*rnum) + 1\n     door(prize) = .TRUE.              \n    \n     CALL RANDOM_NUMBER(rnum)   \n     choice = INT(3*rnum) + 1          \n\n     DO\n        CALL RANDOM_NUMBER(rnum)   \n        show = INT(3*rnum) + 1 \n        IF (show /= choice .AND. show /= prize) EXIT       \n     END DO\n\n     SELECT CASE(choice+show)          \n       CASE(3)\n          remaining = 3\n       CASE(4)\n          remaining = 2\n       CASE(5)\n          remaining = 1\n     END SELECT\n\n     IF (door(choice)) THEN           \n        staycount = staycount + 1\n     ELSE IF (door(remaining)) THEN   \n        switchcount = switchcount + 1\n     END IF\n    \n  END DO\n\n  WRITE(*, \"(A,F6.2,A)\") \"Chance of winning by not switching is\", real(staycount)/trials*100, \"%\"\n  WRITE(*, \"(A,F6.2,A)\") \"Chance of winning by switching is\", real(switchcount)/trials*100, \"%\" \n\nEND PROGRAM MONTYHALL\n", "target": "import java.util.Random;\npublic class Monty{\n\tpublic static void main(String[] args){\n\t\tint switchWins = 0;\n\t\tint stayWins = 0;\n\t\tRandom gen = new Random();\n\t\tfor(int plays = 0;plays < 32768;plays++ ){\n\t\t\tint[] doors = {0,0,0};\n\t\t\tdoors[gen.nextInt(3)] = 1;\n\t\t\tint choice = gen.nextInt(3); \n\t\t\tint shown; \n\t\t\tdo{\n\t\t\t\tshown = gen.nextInt(3);\n\t\t\t\n\t\t\t}while(doors[shown] == 1 || shown == choice);\n\t\t\t\n\t\t\tstayWins += doors[choice];\n\t\t\t\n\t\t\t\n\t\t\tswitchWins += doors[3 - choice - shown];\n\t\t}\n\t\tSystem.out.println(\"Switching wins \" + switchWins + \" times.\");\n\t\tSystem.out.println(\"Staying wins \" + stayWins + \" times.\");\n\t}\n}\n"}
{"id": 29093, "name": "Monty Hall problem", "source": "Translate Fortran to Python: PROGRAM MONTYHALL\n                            \n  IMPLICIT NONE  \n\n  INTEGER, PARAMETER :: trials = 10000\n  INTEGER :: i, choice, prize, remaining, show, staycount = 0, switchcount = 0\n  LOGICAL :: door(3)\n  REAL :: rnum\n\n  CALL RANDOM_SEED\n  DO i = 1, trials\n     door = .FALSE.\n     CALL RANDOM_NUMBER(rnum)\n     prize = INT(3*rnum) + 1\n     door(prize) = .TRUE.              \n    \n     CALL RANDOM_NUMBER(rnum)   \n     choice = INT(3*rnum) + 1          \n\n     DO\n        CALL RANDOM_NUMBER(rnum)   \n        show = INT(3*rnum) + 1 \n        IF (show /= choice .AND. show /= prize) EXIT       \n     END DO\n\n     SELECT CASE(choice+show)          \n       CASE(3)\n          remaining = 3\n       CASE(4)\n          remaining = 2\n       CASE(5)\n          remaining = 1\n     END SELECT\n\n     IF (door(choice)) THEN           \n        staycount = staycount + 1\n     ELSE IF (door(remaining)) THEN   \n        switchcount = switchcount + 1\n     END IF\n    \n  END DO\n\n  WRITE(*, \"(A,F6.2,A)\") \"Chance of winning by not switching is\", real(staycount)/trials*100, \"%\"\n  WRITE(*, \"(A,F6.2,A)\") \"Chance of winning by switching is\", real(switchcount)/trials*100, \"%\" \n\nEND PROGRAM MONTYHALL\n", "target": "\nfrom random import randrange\n\ndoors, iterations = 3,100000  \n\ndef monty_hall(choice, switch=False, doorCount=doors):\n  \n  door = [False]*doorCount\n  \n  door[randrange(doorCount)] = True\n\n  chosen = door[choice]\n\n  unpicked = door\n  del unpicked[choice]\n\n  \n  \n  \n  alternative = True in unpicked\n\n  if switch:\n    return alternative\n  else:\n    return chosen\n\nprint \"\\nMonty Hall problem simulation:\"\nprint doors, \"doors,\", iterations, \"iterations.\\n\"\n\nprint \"Not switching allows you to win\",\nprint sum(monty_hall(randrange(3), switch=False)\n          for x in range(iterations)),\nprint \"out of\", iterations, \"times.\"\nprint \"Switching allows you to win\",\nprint sum(monty_hall(randrange(3), switch=True)\n          for x in range(iterations)),\nprint \"out of\", iterations, \"times.\\n\"\n"}
{"id": 29295, "name": "Polymorphic copy", "source": "Translate Fortran to C#: \n\n\nmodule polymorphic_copy_example_module\n   implicit none\n   private \n   public :: T,S\n\n   type, abstract :: T\n   contains\n      procedure (T_procedure1), deferred, pass :: identify\n      procedure (T_procedure2), deferred, pass :: duplicate\n   end type T\n\n\n   abstract interface\n      subroutine T_procedure1(this)\n         import  :: T\n         class(T), intent(inout) :: this\n      end subroutine T_procedure1\n      function T_procedure2(this) result(Tobj)\n         import  :: T\n         class(T), intent(inout) :: this\n         class(T), allocatable :: Tobj\n      end function T_procedure2\n   end interface\n\n   type, extends(T) :: S\n   contains\n      procedure, pass :: identify\n      procedure, pass :: duplicate\n   end type S\n\n contains\n\n   subroutine  identify(this)\n      implicit none\n      class(S), intent(inout) :: this\n      write(*,*) \"S\"\n   end subroutine identify\n\n   function duplicate(this) result(obj)\n      class(S), intent(inout) :: this\n      class(T), allocatable :: obj\n      allocate(obj, source = S())\n   end function duplicate\n\nend module polymorphic_copy_example_module\n\n\n\n\nprogram    test\n   use polymorphic_copy_example_module\n   implicit none\n\n   class(T), allocatable :: Sobj\n   class(T), allocatable :: Sclone\n\n   allocate(Sobj, source = S())\n   allocate(Sclone, source = Sobj % duplicate())\n\n   call Sobj % identify()\n   call Sclone % identify()\n\nend program test\n", "target": "using System;\n\nclass T\n{\n    public virtual string Name()\n    {\n        return \"T\";\n    }\n\n    public virtual T Clone()\n    {\n        return new T();\n    }\n}\n\nclass S : T\n{\n    public override string Name()\n    {\n        return \"S\";\n    }\n\n    public override T Clone()\n    {\n        return new S();\n    }\n}\n\nclass Program\n{\n    static void Main()\n    {\n        T original = new S();\n        T clone = original.Clone();\n\n        Console.WriteLine(original.Name());\n        Console.WriteLine(clone.Name());\n    }\n}\n"}
{"id": 29299, "name": "Polymorphic copy", "source": "Translate Fortran to Java: \n\n\nmodule polymorphic_copy_example_module\n   implicit none\n   private \n   public :: T,S\n\n   type, abstract :: T\n   contains\n      procedure (T_procedure1), deferred, pass :: identify\n      procedure (T_procedure2), deferred, pass :: duplicate\n   end type T\n\n\n   abstract interface\n      subroutine T_procedure1(this)\n         import  :: T\n         class(T), intent(inout) :: this\n      end subroutine T_procedure1\n      function T_procedure2(this) result(Tobj)\n         import  :: T\n         class(T), intent(inout) :: this\n         class(T), allocatable :: Tobj\n      end function T_procedure2\n   end interface\n\n   type, extends(T) :: S\n   contains\n      procedure, pass :: identify\n      procedure, pass :: duplicate\n   end type S\n\n contains\n\n   subroutine  identify(this)\n      implicit none\n      class(S), intent(inout) :: this\n      write(*,*) \"S\"\n   end subroutine identify\n\n   function duplicate(this) result(obj)\n      class(S), intent(inout) :: this\n      class(T), allocatable :: obj\n      allocate(obj, source = S())\n   end function duplicate\n\nend module polymorphic_copy_example_module\n\n\n\n\nprogram    test\n   use polymorphic_copy_example_module\n   implicit none\n\n   class(T), allocatable :: Sobj\n   class(T), allocatable :: Sclone\n\n   allocate(Sobj, source = S())\n   allocate(Sclone, source = Sobj % duplicate())\n\n   call Sobj % identify()\n   call Sclone % identify()\n\nend program test\n", "target": "class T implements Cloneable {\n    public String name() { return \"T\"; }\n    public T copy() {\n        try {\n            return (T)super.clone();\n        } catch (CloneNotSupportedException e) {\n            return null;\n        }\n    }\n}\n\nclass S extends T {\n    public String name() { return \"S\"; }\n}\n\npublic class PolymorphicCopy {\n    public static T copier(T x) { return x.copy(); }\n    public static void main(String[] args) {\n        T obj1 = new T();\n        S obj2 = new S();\n        System.out.println(copier(obj1).name()); \n        System.out.println(copier(obj2).name()); \n    }\n}\n"}
{"id": 29300, "name": "Polymorphic copy", "source": "Translate Fortran to Python: \n\n\nmodule polymorphic_copy_example_module\n   implicit none\n   private \n   public :: T,S\n\n   type, abstract :: T\n   contains\n      procedure (T_procedure1), deferred, pass :: identify\n      procedure (T_procedure2), deferred, pass :: duplicate\n   end type T\n\n\n   abstract interface\n      subroutine T_procedure1(this)\n         import  :: T\n         class(T), intent(inout) :: this\n      end subroutine T_procedure1\n      function T_procedure2(this) result(Tobj)\n         import  :: T\n         class(T), intent(inout) :: this\n         class(T), allocatable :: Tobj\n      end function T_procedure2\n   end interface\n\n   type, extends(T) :: S\n   contains\n      procedure, pass :: identify\n      procedure, pass :: duplicate\n   end type S\n\n contains\n\n   subroutine  identify(this)\n      implicit none\n      class(S), intent(inout) :: this\n      write(*,*) \"S\"\n   end subroutine identify\n\n   function duplicate(this) result(obj)\n      class(S), intent(inout) :: this\n      class(T), allocatable :: obj\n      allocate(obj, source = S())\n   end function duplicate\n\nend module polymorphic_copy_example_module\n\n\n\n\nprogram    test\n   use polymorphic_copy_example_module\n   implicit none\n\n   class(T), allocatable :: Sobj\n   class(T), allocatable :: Sclone\n\n   allocate(Sobj, source = S())\n   allocate(Sclone, source = Sobj % duplicate())\n\n   call Sobj % identify()\n   call Sclone % identify()\n\nend program test\n", "target": "import copy\n\nclass T:\n   def classname(self): \n      return self.__class__.__name__\n\n   def __init__(self):\n      self.myValue = \"I'm a T.\"\n\n   def speak(self):\n      print self.classname(), 'Hello', self.myValue\n\n   def clone(self):\n      return copy.copy(self)\n\nclass S1(T):\n   def speak(self):\n      print self.classname(),\"Meow\", self.myValue\n\nclass S2(T):\n   def speak(self):\n      print self.classname(),\"Woof\", self.myValue\n\n\nprint \"creating initial objects of types S1, S2, and T\"\na = S1()\na.myValue = 'Green'\na.speak()\n\nb = S2()\nb.myValue = 'Blue'\nb.speak()\n\nu = T()\nu.myValue = 'Purple'\nu.speak()\n\nprint \"Making copy of a as u, colors and types should match\"\nu = a.clone()\nu.speak()\na.speak()\nprint \"Assigning new color to u, A's color should be unchanged.\"\nu.myValue = \"Orange\"\nu.speak()\na.speak()\n\nprint \"Assigning u to reference same object as b, colors and types should match\"\nu = b\nu.speak()\nb.speak()\nprint \"Assigning new color to u. Since u,b references same object b's color changes as well\"\nu.myValue = \"Yellow\"\nu.speak()\nb.speak()\n"}
{"id": 29479, "name": "User input_Text", "source": "Translate Fortran to C#: character(20) :: s\ninteger :: i\n\nprint*, \"Enter a string (max 20 characters)\"\nread*, s\nprint*, \"Enter the integer 75000\"\nread*, i\n", "target": "using System;\n\nnamespace C_Sharp_Console {\n\n    class example {\n\n        static void Main() {\n            string word;\n            int num;\n            \n            Console.Write(\"Enter an integer: \");\n            num = Console.Read();\n            Console.Write(\"Enter a String: \");\n            word = Console.ReadLine();\n        }\n    }\n}\n"}
{"id": 29482, "name": "User input_Text", "source": "Translate Fortran to Java: character(20) :: s\ninteger :: i\n\nprint*, \"Enter a string (max 20 characters)\"\nread*, s\nprint*, \"Enter the integer 75000\"\nread*, i\n", "target": "import java.util.Scanner;\n\npublic class GetInput {\n    public static void main(String[] args) throws Exception {\n        Scanner s = new Scanner(System.in);\n        System.out.print(\"Enter a string: \");\n        String str = s.nextLine();\n        System.out.print(\"Enter an integer: \");\n        int i = Integer.parseInt(s.next());\n    }\n}\n"}
{"id": 29483, "name": "User input_Text", "source": "Translate Fortran to Python: character(20) :: s\ninteger :: i\n\nprint*, \"Enter a string (max 20 characters)\"\nread*, s\nprint*, \"Enter the integer 75000\"\nread*, i\n", "target": "   string = raw_input(\"Input a string: \")\n"}
{"id": 30218, "name": "File size", "source": "Translate Fortran to C#:     use :: iso_fortran_env, only : FILE_STORAGE_SIZE\n    implicit none\n    character(len=*),parameter :: filename(*)=[character(len=256) :: 'input.txt', '/input.txt']\n    integer                    :: file_size, i\n    do i=1,size(filename)\n       INQUIRE(FILE=filename(i), SIZE=file_size)  \n       write(*,*)'size of file '//trim(filename(i))//' is ',file_size * FILE_STORAGE_SIZE /8,' bytes'\n    enddo\n    end\n", "target": "using System;\nusing System.IO;\n\nclass Program\n{\n    static void Main(string[] args)\n    {\n        Console.WriteLine(new FileInfo(\"/input.txt\").Length);\n        Console.WriteLine(new FileInfo(\"input.txt\").Length);\n    }\n}\n"}
{"id": 30222, "name": "File size", "source": "Translate Fortran to Java:     use :: iso_fortran_env, only : FILE_STORAGE_SIZE\n    implicit none\n    character(len=*),parameter :: filename(*)=[character(len=256) :: 'input.txt', '/input.txt']\n    integer                    :: file_size, i\n    do i=1,size(filename)\n       INQUIRE(FILE=filename(i), SIZE=file_size)  \n       write(*,*)'size of file '//trim(filename(i))//' is ',file_size * FILE_STORAGE_SIZE /8,' bytes'\n    enddo\n    end\n", "target": "import java.io.File;\n\npublic class FileSize\n{\n    public static void main ( String[] args )\n    {\n        System.out.println(\"input.txt \u00a0: \" + new File(\"input.txt\").length() + \" bytes\");\n        System.out.println(\"/input.txt\u00a0: \" + new File(\"/input.txt\").length() + \" bytes\");\n    }\n}\n"}
{"id": 30223, "name": "File size", "source": "Translate Fortran to Python:     use :: iso_fortran_env, only : FILE_STORAGE_SIZE\n    implicit none\n    character(len=*),parameter :: filename(*)=[character(len=256) :: 'input.txt', '/input.txt']\n    integer                    :: file_size, i\n    do i=1,size(filename)\n       INQUIRE(FILE=filename(i), SIZE=file_size)  \n       write(*,*)'size of file '//trim(filename(i))//' is ',file_size * FILE_STORAGE_SIZE /8,' bytes'\n    enddo\n    end\n", "target": "import os\n\nsize = os.path.getsize('input.txt')\nsize = os.path.getsize('/input.txt')\n"}
{"id": 30559, "name": "Sorting algorithms_Sleep sort", "source": "Translate Fortran to C#: program sleepSort\n    use omp_lib\n    implicit none\n    integer::nArgs,myid,i,stat\n    integer,allocatable::intArg(:)\n    character(len=5)::arg\n\n    \n    nArgs=command_argument_count()\n    if(nArgs==0)stop '\u00a0: No argument is given\u00a0\n    allocate(intArg(nArgs))\n    do i=1,nArgs\n        call get_command_argument(i, arg)\n\tread(arg,'(I5)',iostat=stat)intArg(i)\n\tif(intArg(i)<0 .or. stat/=0) stop&\n        &' :Only 0 or positive integer allowed\u00a0\n    end do\n    call omp_set_num_threads(nArgs)\n    \n \n\n    \n    myid =omp_get_thread_num()\n    call sleepNprint(intArg(myid+1))\n    \n\n  contains\n\tsubroutine sleepNprint(nSeconds)\n\t    integer::nSeconds\n            call sleep(nSeconds)\n\t    print*,nSeconds\n\tend subroutine sleepNprint\nend program sleepSort\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Threading;\n\nclass Program\n{\n    static void ThreadStart(object item)\n    {\n        Thread.Sleep(1000 * (int)item);\n        Console.WriteLine(item);\n    }\n\n    static void SleepSort(IEnumerable<int> items)\n    {\n        foreach (var item in items)\n        {\n            new Thread(ThreadStart).Start(item);\n        }\n    }\n\n    static void Main(string[] arguments)\n    {\n        SleepSort(arguments.Select(int.Parse));\n    }\n}\n"}
{"id": 30562, "name": "Sorting algorithms_Sleep sort", "source": "Translate Fortran to Java: program sleepSort\n    use omp_lib\n    implicit none\n    integer::nArgs,myid,i,stat\n    integer,allocatable::intArg(:)\n    character(len=5)::arg\n\n    \n    nArgs=command_argument_count()\n    if(nArgs==0)stop '\u00a0: No argument is given\u00a0\n    allocate(intArg(nArgs))\n    do i=1,nArgs\n        call get_command_argument(i, arg)\n\tread(arg,'(I5)',iostat=stat)intArg(i)\n\tif(intArg(i)<0 .or. stat/=0) stop&\n        &' :Only 0 or positive integer allowed\u00a0\n    end do\n    call omp_set_num_threads(nArgs)\n    \n \n\n    \n    myid =omp_get_thread_num()\n    call sleepNprint(intArg(myid+1))\n    \n\n  contains\n\tsubroutine sleepNprint(nSeconds)\n\t    integer::nSeconds\n            call sleep(nSeconds)\n\t    print*,nSeconds\n\tend subroutine sleepNprint\nend program sleepSort\n", "target": "import java.util.concurrent.CountDownLatch;\n\npublic class SleepSort {\n\tpublic static void sleepSortAndPrint(int[] nums) {\n\t\tfinal CountDownLatch doneSignal = new CountDownLatch(nums.length);\n\t\tfor (final int num : nums) {\n\t\t\tnew Thread(new Runnable() {\n\t\t\t\tpublic void run() {\n\t\t\t\t\tdoneSignal.countDown();\n\t\t\t\t\ttry {\n\t\t\t\t\t\tdoneSignal.await();\n\n\t\t\t\t\t\t\n\t\t\t\t\t\t\n\t\t\t\t\t\t\n\t\t\t\t\t\tThread.sleep(num * 1000);\n\t\t\t\t\t\tSystem.out.println(num);\n\t\t\t\t\t} catch (InterruptedException e) {\n\t\t\t\t\t\te.printStackTrace();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}).start();\n\t\t}\n\t}\n\tpublic static void main(String[] args) {\n\t\tint[] nums = new int[args.length];\n\t\tfor (int i = 0; i < args.length; i++)\n\t\t\tnums[i] = Integer.parseInt(args[i]);\n\t\tsleepSortAndPrint(nums);\n\t}\n}\n"}
{"id": 30563, "name": "Sorting algorithms_Sleep sort", "source": "Translate Fortran to Python: program sleepSort\n    use omp_lib\n    implicit none\n    integer::nArgs,myid,i,stat\n    integer,allocatable::intArg(:)\n    character(len=5)::arg\n\n    \n    nArgs=command_argument_count()\n    if(nArgs==0)stop '\u00a0: No argument is given\u00a0\n    allocate(intArg(nArgs))\n    do i=1,nArgs\n        call get_command_argument(i, arg)\n\tread(arg,'(I5)',iostat=stat)intArg(i)\n\tif(intArg(i)<0 .or. stat/=0) stop&\n        &' :Only 0 or positive integer allowed\u00a0\n    end do\n    call omp_set_num_threads(nArgs)\n    \n \n\n    \n    myid =omp_get_thread_num()\n    call sleepNprint(intArg(myid+1))\n    \n\n  contains\n\tsubroutine sleepNprint(nSeconds)\n\t    integer::nSeconds\n            call sleep(nSeconds)\n\t    print*,nSeconds\n\tend subroutine sleepNprint\nend program sleepSort\n", "target": "from time import sleep\nfrom threading import Timer\n\ndef sleepsort(values):\n    sleepsort.result = []\n    def add1(x):\n        sleepsort.result.append(x)\n    mx = values[0]\n    for v in values:\n        if mx < v: mx = v\n        Timer(v, add1, [v]).start()\n    sleep(mx+1)\n    return sleepsort.result\n\nif __name__ == '__main__':\n    x = [3,2,4,7,3,6,9,1]\n    if sleepsort(x) == sorted(x):\n        print('sleep sort worked for:',x)\n    else:\n        print('sleep sort FAILED for:',x)\n"}
{"id": 30788, "name": "Random number generator (device)", "source": "Translate Fortran to C#: \n\n\nprogram    urandom_test\n  use iso_c_binding, only : c_long\n  implicit none\n\n  character(len=*), parameter :: RANDOM_PATH = \"/dev/urandom\"\n  integer :: funit, ios\n  integer(c_long) :: buf\n\n  open(newunit=funit, file=RANDOM_PATH, access=\"stream\", form=\"UNFORMATTED\", &\n       iostat=ios, status=\"old\", action=\"read\")\n  if ( ios /= 0 ) stop \"Error opening file: \"//RANDOM_PATH\n\n  read(funit) buf\n\n  close(funit)\n\n  write(*,'(A,I64)') \"Integer:     \", buf\n  write(*,'(A,B64)') \"Binary:      \", buf\n  write(*,'(A,Z64)') \"Hexadecimal: \", buf\n\nend program urandom_test\n", "target": "using System;\nusing System.Security.Cryptography;\n\nprivate static int GetRandomInt()\n{\n  int result = 0;\n  var rng = new RNGCryptoServiceProvider();\n  var buffer = new byte[4];\n\n  rng.GetBytes(buffer);\n  result = BitConverter.ToInt32(buffer, 0);\n\n  return result;\n}\n"}
{"id": 30789, "name": "Random number generator (device)", "source": "Translate Fortran to C#: \n\n\nprogram    urandom_test\n  use iso_c_binding, only : c_long\n  implicit none\n\n  character(len=*), parameter :: RANDOM_PATH = \"/dev/urandom\"\n  integer :: funit, ios\n  integer(c_long) :: buf\n\n  open(newunit=funit, file=RANDOM_PATH, access=\"stream\", form=\"UNFORMATTED\", &\n       iostat=ios, status=\"old\", action=\"read\")\n  if ( ios /= 0 ) stop \"Error opening file: \"//RANDOM_PATH\n\n  read(funit) buf\n\n  close(funit)\n\n  write(*,'(A,I64)') \"Integer:     \", buf\n  write(*,'(A,B64)') \"Binary:      \", buf\n  write(*,'(A,Z64)') \"Hexadecimal: \", buf\n\nend program urandom_test\n", "target": "using System;\nusing System.Security.Cryptography;\n\nprivate static int GetRandomInt()\n{\n  int result = 0;\n  var rng = new RNGCryptoServiceProvider();\n  var buffer = new byte[4];\n\n  rng.GetBytes(buffer);\n  result = BitConverter.ToInt32(buffer, 0);\n\n  return result;\n}\n"}
{"id": 30794, "name": "Random number generator (device)", "source": "Translate Fortran to Java: \n\n\nprogram    urandom_test\n  use iso_c_binding, only : c_long\n  implicit none\n\n  character(len=*), parameter :: RANDOM_PATH = \"/dev/urandom\"\n  integer :: funit, ios\n  integer(c_long) :: buf\n\n  open(newunit=funit, file=RANDOM_PATH, access=\"stream\", form=\"UNFORMATTED\", &\n       iostat=ios, status=\"old\", action=\"read\")\n  if ( ios /= 0 ) stop \"Error opening file: \"//RANDOM_PATH\n\n  read(funit) buf\n\n  close(funit)\n\n  write(*,'(A,I64)') \"Integer:     \", buf\n  write(*,'(A,B64)') \"Binary:      \", buf\n  write(*,'(A,Z64)') \"Hexadecimal: \", buf\n\nend program urandom_test\n", "target": "import java.security.SecureRandom;\n\npublic class RandomExample {\n  public static void main(String[] args) {\n    SecureRandom rng = new SecureRandom();\n\n    \n    System.out.println(rng.nextInt());\n  }\n}\n"}
{"id": 30795, "name": "Random number generator (device)", "source": "Translate Fortran to Java: \n\n\nprogram    urandom_test\n  use iso_c_binding, only : c_long\n  implicit none\n\n  character(len=*), parameter :: RANDOM_PATH = \"/dev/urandom\"\n  integer :: funit, ios\n  integer(c_long) :: buf\n\n  open(newunit=funit, file=RANDOM_PATH, access=\"stream\", form=\"UNFORMATTED\", &\n       iostat=ios, status=\"old\", action=\"read\")\n  if ( ios /= 0 ) stop \"Error opening file: \"//RANDOM_PATH\n\n  read(funit) buf\n\n  close(funit)\n\n  write(*,'(A,I64)') \"Integer:     \", buf\n  write(*,'(A,B64)') \"Binary:      \", buf\n  write(*,'(A,Z64)') \"Hexadecimal: \", buf\n\nend program urandom_test\n", "target": "import java.security.SecureRandom;\n\npublic class RandomExample {\n  public static void main(String[] args) {\n    SecureRandom rng = new SecureRandom();\n\n    \n    System.out.println(rng.nextInt());\n  }\n}\n"}
{"id": 30796, "name": "Random number generator (device)", "source": "Translate Fortran to Python: \n\n\nprogram    urandom_test\n  use iso_c_binding, only : c_long\n  implicit none\n\n  character(len=*), parameter :: RANDOM_PATH = \"/dev/urandom\"\n  integer :: funit, ios\n  integer(c_long) :: buf\n\n  open(newunit=funit, file=RANDOM_PATH, access=\"stream\", form=\"UNFORMATTED\", &\n       iostat=ios, status=\"old\", action=\"read\")\n  if ( ios /= 0 ) stop \"Error opening file: \"//RANDOM_PATH\n\n  read(funit) buf\n\n  close(funit)\n\n  write(*,'(A,I64)') \"Integer:     \", buf\n  write(*,'(A,B64)') \"Binary:      \", buf\n  write(*,'(A,Z64)') \"Hexadecimal: \", buf\n\nend program urandom_test\n", "target": "import random\nrand = random.SystemRandom()\nrand.randint(1,10)\n"}
{"id": 30797, "name": "Random number generator (device)", "source": "Translate Fortran to Python: \n\n\nprogram    urandom_test\n  use iso_c_binding, only : c_long\n  implicit none\n\n  character(len=*), parameter :: RANDOM_PATH = \"/dev/urandom\"\n  integer :: funit, ios\n  integer(c_long) :: buf\n\n  open(newunit=funit, file=RANDOM_PATH, access=\"stream\", form=\"UNFORMATTED\", &\n       iostat=ios, status=\"old\", action=\"read\")\n  if ( ios /= 0 ) stop \"Error opening file: \"//RANDOM_PATH\n\n  read(funit) buf\n\n  close(funit)\n\n  write(*,'(A,I64)') \"Integer:     \", buf\n  write(*,'(A,B64)') \"Binary:      \", buf\n  write(*,'(A,Z64)') \"Hexadecimal: \", buf\n\nend program urandom_test\n", "target": "import random\nrand = random.SystemRandom()\nrand.randint(1,10)\n"}
{"id": 31387, "name": "Remove vowels from a string", "source": "Translate Fortran to C#: program remove_vowels\n    implicit none\n\n    character(len=*), parameter :: string1=\"The quick brown fox jumps over the lazy dog.\"\n    character(len=*), parameter :: string2=\"Fortran programming language\"\n\n    call print_no_vowels(string1)\n    call print_no_vowels(string2)\ncontains\n    subroutine print_no_vowels(string)\n        character(len=*), intent(in)    :: string\n        integer                         :: i\n\n        do i = 1, len(string)\n            select case (string(i:i))\n            case('A','E','I','O','U','a','e','i','o','u')\n                cycle\n            case default\n                write(*,'(A1)',advance=\"no\") string(i:i)\n            end select\n        end do\n        write(*,*) new_line('A') \n    end subroutine print_no_vowels\nend program remove_vowels\n", "target": "static string remove_vowels(string value)\n{\n    var stripped = from c in value.ToCharArray()\n                   where !\"aeiouAEIOU\".Contains(c)\n                   select c;\n\n    return new string(stripped.ToArray());\n}\n\nstatic void test(string value)\n{\n    Console.WriteLine(\"Input:  \" + value);\n    Console.WriteLine(\"Output: \" + remove_vowels(value));\n}\n\nstatic void Main(string[] args)\n{\n    test(\"CSharp Programming Language\");\n}\n"}
{"id": 31388, "name": "Remove vowels from a string", "source": "Translate Fortran to C#: program remove_vowels\n    implicit none\n\n    character(len=*), parameter :: string1=\"The quick brown fox jumps over the lazy dog.\"\n    character(len=*), parameter :: string2=\"Fortran programming language\"\n\n    call print_no_vowels(string1)\n    call print_no_vowels(string2)\ncontains\n    subroutine print_no_vowels(string)\n        character(len=*), intent(in)    :: string\n        integer                         :: i\n\n        do i = 1, len(string)\n            select case (string(i:i))\n            case('A','E','I','O','U','a','e','i','o','u')\n                cycle\n            case default\n                write(*,'(A1)',advance=\"no\") string(i:i)\n            end select\n        end do\n        write(*,*) new_line('A') \n    end subroutine print_no_vowels\nend program remove_vowels\n", "target": "static string remove_vowels(string value)\n{\n    var stripped = from c in value.ToCharArray()\n                   where !\"aeiouAEIOU\".Contains(c)\n                   select c;\n\n    return new string(stripped.ToArray());\n}\n\nstatic void test(string value)\n{\n    Console.WriteLine(\"Input:  \" + value);\n    Console.WriteLine(\"Output: \" + remove_vowels(value));\n}\n\nstatic void Main(string[] args)\n{\n    test(\"CSharp Programming Language\");\n}\n"}
{"id": 31394, "name": "Remove vowels from a string", "source": "Translate Fortran to Java: program remove_vowels\n    implicit none\n\n    character(len=*), parameter :: string1=\"The quick brown fox jumps over the lazy dog.\"\n    character(len=*), parameter :: string2=\"Fortran programming language\"\n\n    call print_no_vowels(string1)\n    call print_no_vowels(string2)\ncontains\n    subroutine print_no_vowels(string)\n        character(len=*), intent(in)    :: string\n        integer                         :: i\n\n        do i = 1, len(string)\n            select case (string(i:i))\n            case('A','E','I','O','U','a','e','i','o','u')\n                cycle\n            case default\n                write(*,'(A1)',advance=\"no\") string(i:i)\n            end select\n        end do\n        write(*,*) new_line('A') \n    end subroutine print_no_vowels\nend program remove_vowels\n", "target": "public static String removeVowelse(String str){\n    String re = \"\";\n    char c;\n    for(int x = 0; x<str.length(); x++){\n        c = str.charAt(x);\n        if(!(c=='a'||c=='e'||c=='i'||c=='o'||c=='u'))\n        re+=c;\n    }\n    return re;\n}\n"}
{"id": 31395, "name": "Remove vowels from a string", "source": "Translate Fortran to Java: program remove_vowels\n    implicit none\n\n    character(len=*), parameter :: string1=\"The quick brown fox jumps over the lazy dog.\"\n    character(len=*), parameter :: string2=\"Fortran programming language\"\n\n    call print_no_vowels(string1)\n    call print_no_vowels(string2)\ncontains\n    subroutine print_no_vowels(string)\n        character(len=*), intent(in)    :: string\n        integer                         :: i\n\n        do i = 1, len(string)\n            select case (string(i:i))\n            case('A','E','I','O','U','a','e','i','o','u')\n                cycle\n            case default\n                write(*,'(A1)',advance=\"no\") string(i:i)\n            end select\n        end do\n        write(*,*) new_line('A') \n    end subroutine print_no_vowels\nend program remove_vowels\n", "target": "public static String removeVowelse(String str){\n    String re = \"\";\n    char c;\n    for(int x = 0; x<str.length(); x++){\n        c = str.charAt(x);\n        if(!(c=='a'||c=='e'||c=='i'||c=='o'||c=='u'))\n        re+=c;\n    }\n    return re;\n}\n"}
{"id": 31396, "name": "Remove vowels from a string", "source": "Translate Fortran to Python: program remove_vowels\n    implicit none\n\n    character(len=*), parameter :: string1=\"The quick brown fox jumps over the lazy dog.\"\n    character(len=*), parameter :: string2=\"Fortran programming language\"\n\n    call print_no_vowels(string1)\n    call print_no_vowels(string2)\ncontains\n    subroutine print_no_vowels(string)\n        character(len=*), intent(in)    :: string\n        integer                         :: i\n\n        do i = 1, len(string)\n            select case (string(i:i))\n            case('A','E','I','O','U','a','e','i','o','u')\n                cycle\n            case default\n                write(*,'(A1)',advance=\"no\") string(i:i)\n            end select\n        end do\n        write(*,*) new_line('A') \n    end subroutine print_no_vowels\nend program remove_vowels\n", "target": "\n\n\n\ndef exceptGlyphs(exclusions):\n    \n    def go(s):\n        return ''.join(\n            c for c in s if c not in exclusions\n        )\n    return go\n\n\n\n\ndef main():\n    \n\n    txt = \n\n    print(\n        exceptGlyphs('eau')(txt)\n    )\n\n\n\nif __name__ == '__main__':\n    main()\n"}
{"id": 31397, "name": "Remove vowels from a string", "source": "Translate Fortran to Python: program remove_vowels\n    implicit none\n\n    character(len=*), parameter :: string1=\"The quick brown fox jumps over the lazy dog.\"\n    character(len=*), parameter :: string2=\"Fortran programming language\"\n\n    call print_no_vowels(string1)\n    call print_no_vowels(string2)\ncontains\n    subroutine print_no_vowels(string)\n        character(len=*), intent(in)    :: string\n        integer                         :: i\n\n        do i = 1, len(string)\n            select case (string(i:i))\n            case('A','E','I','O','U','a','e','i','o','u')\n                cycle\n            case default\n                write(*,'(A1)',advance=\"no\") string(i:i)\n            end select\n        end do\n        write(*,*) new_line('A') \n    end subroutine print_no_vowels\nend program remove_vowels\n", "target": "\n\n\n\ndef exceptGlyphs(exclusions):\n    \n    def go(s):\n        return ''.join(\n            c for c in s if c not in exclusions\n        )\n    return go\n\n\n\n\ndef main():\n    \n\n    txt = \n\n    print(\n        exceptGlyphs('eau')(txt)\n    )\n\n\n\nif __name__ == '__main__':\n    main()\n"}
{"id": 31675, "name": "Forward difference", "source": "Translate Fortran to C#: MODULE DIFFERENCE\n  IMPLICIT NONE\n\n  CONTAINS\n \n  SUBROUTINE Fdiff(a, n)\n    INTEGER, INTENT(IN) :: a(:), n\n    INTEGER :: b(SIZE(a))  \n    INTEGER :: i, j, arraysize\n  \n    b = a\n    arraysize = SIZE(b)\n    DO i = arraysize-1, arraysize-n, -1\n      DO j = 1, i\n        b(j) = b(j+1) - b(j)\n      END DO\n    END DO\n    WRITE (*,*) b(1:arraysize-n)\n  END SUBROUTINE Fdiff\nEND MODULE DIFFERENCE\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\nclass Program\n{\n    static IEnumerable<int> ForwardDifference(IEnumerable<int> sequence, uint order = 1u)\n    {\n        switch (order)\n        {\n            case 0u:\n                return sequence;\n            case 1u:\n                return sequence.Skip(1).Zip(sequence, (next, current) => next - current);\n            default:\n                return ForwardDifference(ForwardDifference(sequence), order - 1u);\n        }\n    }\n\n    static void Main()\n    {\n        IEnumerable<int> sequence = new[] { 90, 47, 58, 29, 22, 32, 55, 5, 55, 73 };\n        do\n        {\n            Console.WriteLine(string.Join(\", \", sequence));\n        } while ((sequence = ForwardDifference(sequence)).Any());\n    }\n}\n"}
{"id": 31678, "name": "Forward difference", "source": "Translate Fortran to Java: MODULE DIFFERENCE\n  IMPLICIT NONE\n\n  CONTAINS\n \n  SUBROUTINE Fdiff(a, n)\n    INTEGER, INTENT(IN) :: a(:), n\n    INTEGER :: b(SIZE(a))  \n    INTEGER :: i, j, arraysize\n  \n    b = a\n    arraysize = SIZE(b)\n    DO i = arraysize-1, arraysize-n, -1\n      DO j = 1, i\n        b(j) = b(j+1) - b(j)\n      END DO\n    END DO\n    WRITE (*,*) b(1:arraysize-n)\n  END SUBROUTINE Fdiff\nEND MODULE DIFFERENCE\n", "target": "import java.util.Arrays;\npublic class FD {\n    public static void main(String args[]) {\n        double[] a = {90, 47, 58, 29, 22, 32, 55, 5, 55, 73};\n        System.out.println(Arrays.toString(dif(a, 1)));\n        System.out.println(Arrays.toString(dif(a, 2)));\n        System.out.println(Arrays.toString(dif(a, 9)));\n        System.out.println(Arrays.toString(dif(a, 10)));      \n        System.out.println(Arrays.toString(dif(a, 11)));\n        System.out.println(Arrays.toString(dif(a, -1)));\n        System.out.println(Arrays.toString(dif(a, 0)));\n    }\n\n    public static double[] dif(double[] a, int n) {\n        if (n < 0)\n            return null; \n\n        for (int i = 0; i < n && a.length > 0; i++) {\n            double[] b = new double[a.length - 1];\n            for (int j = 0; j < b.length; j++){\n                b[j] = a[j+1] - a[j];\n            }\n            a = b; \n        }\n        return a;\n    }\n}\n"}
{"id": 31679, "name": "Forward difference", "source": "Translate Fortran to Python: MODULE DIFFERENCE\n  IMPLICIT NONE\n\n  CONTAINS\n \n  SUBROUTINE Fdiff(a, n)\n    INTEGER, INTENT(IN) :: a(:), n\n    INTEGER :: b(SIZE(a))  \n    INTEGER :: i, j, arraysize\n  \n    b = a\n    arraysize = SIZE(b)\n    DO i = arraysize-1, arraysize-n, -1\n      DO j = 1, i\n        b(j) = b(j+1) - b(j)\n      END DO\n    END DO\n    WRITE (*,*) b(1:arraysize-n)\n  END SUBROUTINE Fdiff\nEND MODULE DIFFERENCE\n", "target": ">>> dif = lambda s: [x-s[i] for i,x in enumerate(s[1:])]\n>>> \n>>> difn = lambda s, n: difn(dif(s), n-1) if n else s\n\n>>> s = [90, 47, 58, 29, 22, 32, 55, 5, 55, 73]\n>>> difn(s, 0)\n[90, 47, 58, 29, 22, 32, 55, 5, 55, 73]\n>>> difn(s, 1)\n[-43, 11, -29, -7, 10, 23, -50, 50, 18]\n>>> difn(s, 2)\n[54, -40, 22, 17, 13, -73, 100, -32]\n\n>>> from pprint import pprint\n>>> pprint( [difn(s, i) for i in xrange(10)] )\n[[90, 47, 58, 29, 22, 32, 55, 5, 55, 73],\n [-43, 11, -29, -7, 10, 23, -50, 50, 18],\n [54, -40, 22, 17, 13, -73, 100, -32],\n [-94, 62, -5, -4, -86, 173, -132],\n [156, -67, 1, -82, 259, -305],\n [-223, 68, -83, 341, -564],\n [291, -151, 424, -905],\n [-442, 575, -1329],\n [1017, -1904],\n [-2921]]\n"}
{"id": 31937, "name": "Guess the number_With feedback", "source": "Translate Fortran to C#: program Guess_a_number\n  implicit none\n  \n  integer, parameter :: limit = 100\n  integer :: guess, number\n  real :: rnum\n  \n  write(*, \"(a, i0, a)\") \"I have chosen a number between 1 and \", limit, &\n                         \" and you have to try to guess it.\" \n  write(*, \"(a/)\")  \"I will score your guess by indicating whether it is higher, lower or the same as that number\"\n \n  call random_seed\n  call random_number(rnum)\n  number = rnum * limit + 1\n  do\n    write(*, \"(a)\", advance=\"no\") \"Enter quess: \"\n    read*, guess\n    if(guess < number) then\n      write(*, \"(a/)\") \"That is lower\"\n    else if(guess > number) then\n      write(*, \"(a/)\") \"That is higher\"\n    else\n      write(*, \"(a)\") \"That is correct\"\n      exit\n    end if\n  end do\nend program\n", "target": "using System;\n\nclass Program\n{\n    static void Main(string[] args)\n    {\n        const int from = 1;\n        const int to = 10;\n\n        int randomNumber = new Random().Next(from, to);\n        int guessedNumber;\n\n        Console.Write(\"The number is between {0} and {1}. \", from, to);\n        while (true)\n        {\n            Console.Write(\"Make a guess: \");\n            if (int.TryParse(Console.ReadLine(), out guessedNumber))\n            {\n                if (guessedNumber == randomNumber)\n                {\n                    Console.WriteLine(\"You guessed the right number!\");\n                    break;\n                }\n                else\n                {\n                    Console.WriteLine(\"Your guess was too {0}.\", (guessedNumber > randomNumber) ? \"high\" : \"low\");\n                }\n            }\n            else\n            {\n                Console.WriteLine(\"Input was not an integer.\");\n            }\n        }\n\n        Console.WriteLine();\n        Console.WriteLine(\"Press any key to exit.\");\n        Console.ReadKey();\n    }\n}\n"}
{"id": 31941, "name": "Guess the number_With feedback", "source": "Translate Fortran to Java: program Guess_a_number\n  implicit none\n  \n  integer, parameter :: limit = 100\n  integer :: guess, number\n  real :: rnum\n  \n  write(*, \"(a, i0, a)\") \"I have chosen a number between 1 and \", limit, &\n                         \" and you have to try to guess it.\" \n  write(*, \"(a/)\")  \"I will score your guess by indicating whether it is higher, lower or the same as that number\"\n \n  call random_seed\n  call random_number(rnum)\n  number = rnum * limit + 1\n  do\n    write(*, \"(a)\", advance=\"no\") \"Enter quess: \"\n    read*, guess\n    if(guess < number) then\n      write(*, \"(a/)\") \"That is lower\"\n    else if(guess > number) then\n      write(*, \"(a/)\") \"That is higher\"\n    else\n      write(*, \"(a)\") \"That is correct\"\n      exit\n    end if\n  end do\nend program\n", "target": "import java.util.Random;\nimport java.util.Scanner;\npublic class Main\n{\n    public static void main(String[] args)\n    {\n        Scanner scan = new Scanner(System.in);\n        Random random = new Random();\n        long from = 1;\n        long to = 100;\n        int randomNumber = random.nextInt(to - from + 1) + from;\n        int guessedNumber = 0;\n\n        System.out.printf(\"The number is between %d and %d.\\n\", from, to);\n\n        do\n        {\n            System.out.print(\"Guess what the number is: \");\n            guessedNumber = scan.nextInt();\n            if (guessedNumber > randomNumber)\n                System.out.println(\"Your guess is too high!\");\n            else if (guessedNumber < randomNumber)\n                System.out.println(\"Your guess is too low!\");\n            else\n                System.out.println(\"You got it!\");\n        } while (guessedNumber != randomNumber);\n    }\n}\n"}
{"id": 31942, "name": "Guess the number_With feedback", "source": "Translate Fortran to Python: program Guess_a_number\n  implicit none\n  \n  integer, parameter :: limit = 100\n  integer :: guess, number\n  real :: rnum\n  \n  write(*, \"(a, i0, a)\") \"I have chosen a number between 1 and \", limit, &\n                         \" and you have to try to guess it.\" \n  write(*, \"(a/)\")  \"I will score your guess by indicating whether it is higher, lower or the same as that number\"\n \n  call random_seed\n  call random_number(rnum)\n  number = rnum * limit + 1\n  do\n    write(*, \"(a)\", advance=\"no\") \"Enter quess: \"\n    read*, guess\n    if(guess < number) then\n      write(*, \"(a/)\") \"That is lower\"\n    else if(guess > number) then\n      write(*, \"(a/)\") \"That is higher\"\n    else\n      write(*, \"(a)\") \"That is correct\"\n      exit\n    end if\n  end do\nend program\n", "target": "import random\n\ninclusive_range = (1, 100)\n\nprint(\"Guess my target number that is between %i and %i (inclusive).\\n\"\n      % inclusive_range)\ntarget = random.randint(*inclusive_range)\nanswer, i = None, 0\nwhile answer != target:\n    i += 1\n    txt = input(\"Your guess(%i): \" % i)\n    try:\n        answer = int(txt)\n    except ValueError:\n        print(\"  I don't understand your input of '%s'\u00a0?\" % txt)\n        continue\n    if answer < inclusive_range[0] or answer > inclusive_range[1]:\n        print(\"  Out of range!\")\n        continue\n    if answer == target:\n        print(\"  Ye-Haw!!\")\n        break\n    if answer < target: print(\"  Too low.\")\n    if answer > target: print(\"  Too high.\")\n\nprint(\"\\nThanks for playing.\")\n"}
{"id": 32193, "name": "Compound data type", "source": "Translate Fortran to C#: program typedemo\n    type rational                                           \n        integer :: numerator\n        integer :: denominator\n    end type rational\n    \n    type( rational ), parameter :: zero = rational( 0, 1 )  \n    type( rational ), parameter :: one  = rational( 1, 1 )  \n    type( rational ), parameter :: half = rational( 1, 2 )\n    integer :: n, halfd, halfn\n    type( rational ) :: &\n        one_over_n(20) = (/ (rational( 1, n ), n = 1, 20) /) \n                                                             \n                                                             \n    integer :: oon_denoms(20)                                \n    \n    halfd = half%denominator                       \n    halfn = half%numerator\n    \n    oon_denoms = one_over_n%denominator            \n                                                   \nend program typedemo                               \n", "target": "struct Point\n{\n  public int x, y;\n  public Point(int x, int y) {\n    this.x = x;\n    this.y = y;\n  }\n}\n"}
{"id": 32197, "name": "Compound data type", "source": "Translate Fortran to Java: program typedemo\n    type rational                                           \n        integer :: numerator\n        integer :: denominator\n    end type rational\n    \n    type( rational ), parameter :: zero = rational( 0, 1 )  \n    type( rational ), parameter :: one  = rational( 1, 1 )  \n    type( rational ), parameter :: half = rational( 1, 2 )\n    integer :: n, halfd, halfn\n    type( rational ) :: &\n        one_over_n(20) = (/ (rational( 1, n ), n = 1, 20) /) \n                                                             \n                                                             \n    integer :: oon_denoms(20)                                \n    \n    halfd = half%denominator                       \n    halfn = half%numerator\n    \n    oon_denoms = one_over_n%denominator            \n                                                   \nend program typedemo                               \n", "target": "public class Point\n{\n  public int x, y;\n  public Point() { this(0); }\n  public Point(int x0) { this(x0,0); }\n  public Point(int x0, int y0) { x = x0; y = y0; }\n\n  public static void main(String args[])\n  {\n    Point point = new Point(1,2);\n    System.out.println(\"x = \" + point.x );\n    System.out.println(\"y = \" + point.y );\n  }\n}\n"}
{"id": 32198, "name": "Compound data type", "source": "Translate Fortran to Python: program typedemo\n    type rational                                           \n        integer :: numerator\n        integer :: denominator\n    end type rational\n    \n    type( rational ), parameter :: zero = rational( 0, 1 )  \n    type( rational ), parameter :: one  = rational( 1, 1 )  \n    type( rational ), parameter :: half = rational( 1, 2 )\n    integer :: n, halfd, halfn\n    type( rational ) :: &\n        one_over_n(20) = (/ (rational( 1, n ), n = 1, 20) /) \n                                                             \n                                                             \n    integer :: oon_denoms(20)                                \n    \n    halfd = half%denominator                       \n    halfn = half%numerator\n    \n    oon_denoms = one_over_n%denominator            \n                                                   \nend program typedemo                               \n", "target": "X, Y = 0, 1\np = (3, 4)\np = [3, 4]\n\nprint p[X]\n"}
{"id": 32432, "name": "Sorting algorithms_Bogosort", "source": "Translate Fortran to C#: MODULE BOGO\nIMPLICIT NONE\nCONTAINS\n  FUNCTION Sorted(a)\n    LOGICAL :: Sorted\n    INTEGER, INTENT(IN) :: a(:)\n    INTEGER :: i\n\n    Sorted = .TRUE.  \n    DO i = 1, SIZE(a)-1\n      IF(a(i) > a(i+1)) THEN\n        Sorted = .FALSE.\n        EXIT\n      END IF\n    END DO\n  END FUNCTION Sorted\n\n  SUBROUTINE SHUFFLE(a)\n    INTEGER, INTENT(IN OUT) :: a(:)\n    INTEGER :: i, rand, temp\n    REAL :: x\n\n    DO i = SIZE(a), 1, -1\n       CALL RANDOM_NUMBER(x)\n       rand = INT(x * i) + 1\n       temp = a(rand)\n       a(rand) = a(i)\n       a(i) = temp\n    END DO\n  END SUBROUTINE\nEND MODULE\n\nPROGRAM BOGOSORT\n\n  USE BOGO\n  IMPLICIT NONE\n  INTEGER :: iter = 0\n  INTEGER :: array(8) = (/2, 7, 5, 3, 4, 8, 6, 1/)\n  LOGICAL :: s\n \n  DO\n    s = Sorted(array)\n    IF (s) EXIT\n    CALL SHUFFLE(array)\n    iter = iter + 1\n  END DO\n  WRITE (*,*) \"Array required\", iter, \" shuffles to sort\"\n \nEND PROGRAM BOGOSORT\n", "target": "using System;\nusing System.Collections.Generic;\n\nnamespace RosettaCode.BogoSort\n{\n    public static class BogoSorter\n    {\n        public static void Sort<T>(List<T> list) where T:IComparable\n        {\n            while (!list.isSorted())\n            {\n                list.Shuffle();\n            }\n        }\n\n        private static bool isSorted<T>(this IList<T> list) where T:IComparable\n        {\n            if(list.Count<=1)\n                return true;\n            for (int i = 1 ; i < list.Count; i++)\n                if(list[i].CompareTo(list[i-1])<0) return false;\n            return true;\n        }\n\n        private static void Shuffle<T>(this IList<T> list)\n        {\n            Random rand = new Random();\n            for (int i = 0; i < list.Count; i++)\n            {\n                int swapIndex = rand.Next(list.Count);\n                T temp = list[swapIndex];\n                list[swapIndex] = list[i];\n                list[i] = temp;\n            }\n        }\n    }\n\n    class TestProgram\n    {\n        static void Main()\n        {\n            List<int> testList = new List<int> { 3, 4, 1, 8, 7, 4, -2 };\n            BogoSorter.Sort(testList);\n            foreach (int i in testList) Console.Write(i + \" \");\n        }\n\n    }\n}\n"}
{"id": 32436, "name": "Sorting algorithms_Bogosort", "source": "Translate Fortran to Java: MODULE BOGO\nIMPLICIT NONE\nCONTAINS\n  FUNCTION Sorted(a)\n    LOGICAL :: Sorted\n    INTEGER, INTENT(IN) :: a(:)\n    INTEGER :: i\n\n    Sorted = .TRUE.  \n    DO i = 1, SIZE(a)-1\n      IF(a(i) > a(i+1)) THEN\n        Sorted = .FALSE.\n        EXIT\n      END IF\n    END DO\n  END FUNCTION Sorted\n\n  SUBROUTINE SHUFFLE(a)\n    INTEGER, INTENT(IN OUT) :: a(:)\n    INTEGER :: i, rand, temp\n    REAL :: x\n\n    DO i = SIZE(a), 1, -1\n       CALL RANDOM_NUMBER(x)\n       rand = INT(x * i) + 1\n       temp = a(rand)\n       a(rand) = a(i)\n       a(i) = temp\n    END DO\n  END SUBROUTINE\nEND MODULE\n\nPROGRAM BOGOSORT\n\n  USE BOGO\n  IMPLICIT NONE\n  INTEGER :: iter = 0\n  INTEGER :: array(8) = (/2, 7, 5, 3, 4, 8, 6, 1/)\n  LOGICAL :: s\n \n  DO\n    s = Sorted(array)\n    IF (s) EXIT\n    CALL SHUFFLE(array)\n    iter = iter + 1\n  END DO\n  WRITE (*,*) \"Array required\", iter, \" shuffles to sort\"\n \nEND PROGRAM BOGOSORT\n", "target": "public class BogoSort \n{\n\tpublic static void main(String[] args)\n\t{\n\t\t\n\t\tint[] arr={4,5,6,0,7,8,9,1,2,3};\n\t\t\n\t\tBogoSort now=new BogoSort();\n\t\tSystem.out.print(\"Unsorted: \");\n\t\tnow.display1D(arr);\n\t\t\n\t\tnow.bogo(arr);\n\t\t\n\t\tSystem.out.print(\"Sorted: \");\n\t\tnow.display1D(arr);\n\t}\n\tvoid bogo(int[] arr)\n\t{\n\t\t\n\t\tint shuffle=1;\n\t\tfor(;!isSorted(arr);shuffle++)\n\t\t\tshuffle(arr);\n\t\t\n\t\tSystem.out.println(\"This took \"+shuffle+\" shuffles.\");\n\t}\n\tvoid shuffle(int[] arr)\n\t{\n\t\t\n\t\tint i=arr.length-1;\n\t\twhile(i>0)\n\t\t\tswap(arr,i--,(int)(Math.random()*i));\n\t}\n\tvoid swap(int[] arr,int i,int j)\n\t{\n\t\tint temp=arr[i];\n\t\tarr[i]=arr[j];\n\t\tarr[j]=temp;\n\t}\n\tboolean isSorted(int[] arr)\n\t{\n\n\t\tfor(int i=1;i<arr.length;i++)\n\t\t\tif(arr[i]<arr[i-1])\n\t\t\t\treturn false;\n\t\treturn true;\n\t}\n\tvoid display1D(int[] arr)\n\t{\n\t\tfor(int i=0;i<arr.length;i++)\n\t\t\tSystem.out.print(arr[i]+\" \");\n\t\tSystem.out.println();\n\t}\n\n}\n"}
{"id": 32437, "name": "Sorting algorithms_Bogosort", "source": "Translate Fortran to Python: MODULE BOGO\nIMPLICIT NONE\nCONTAINS\n  FUNCTION Sorted(a)\n    LOGICAL :: Sorted\n    INTEGER, INTENT(IN) :: a(:)\n    INTEGER :: i\n\n    Sorted = .TRUE.  \n    DO i = 1, SIZE(a)-1\n      IF(a(i) > a(i+1)) THEN\n        Sorted = .FALSE.\n        EXIT\n      END IF\n    END DO\n  END FUNCTION Sorted\n\n  SUBROUTINE SHUFFLE(a)\n    INTEGER, INTENT(IN OUT) :: a(:)\n    INTEGER :: i, rand, temp\n    REAL :: x\n\n    DO i = SIZE(a), 1, -1\n       CALL RANDOM_NUMBER(x)\n       rand = INT(x * i) + 1\n       temp = a(rand)\n       a(rand) = a(i)\n       a(i) = temp\n    END DO\n  END SUBROUTINE\nEND MODULE\n\nPROGRAM BOGOSORT\n\n  USE BOGO\n  IMPLICIT NONE\n  INTEGER :: iter = 0\n  INTEGER :: array(8) = (/2, 7, 5, 3, 4, 8, 6, 1/)\n  LOGICAL :: s\n \n  DO\n    s = Sorted(array)\n    IF (s) EXIT\n    CALL SHUFFLE(array)\n    iter = iter + 1\n  END DO\n  WRITE (*,*) \"Array required\", iter, \" shuffles to sort\"\n \nEND PROGRAM BOGOSORT\n", "target": "import random\n\ndef bogosort(l):\n    while not in_order(l):\n        random.shuffle(l)\n    return l\n\ndef in_order(l):\n    if not l:\n        return True\n    last = l[0]\n    for x in l[1:]:\n        if x < last:\n            return False\n        last = x\n    return True\n"}
{"id": 32710, "name": "Cumulative standard deviation", "source": "Translate Fortran to C#: program standard_deviation\n  implicit none\n  integer(kind=4), parameter :: dp = kind(0.0d0)\n\n  real(kind=dp), dimension(:), allocatable :: vals\n  integer(kind=4) :: i\n\n  real(kind=dp), dimension(8) :: sample_data = (/ 2, 4, 4, 4, 5, 5, 7, 9 /)\n\n  do i = lbound(sample_data, 1), ubound(sample_data, 1)\n    call sample_add(vals, sample_data(i))\n    write(*, fmt='(''#'',I1,1X,''value = '',F3.1,1X,''stddev ='',1X,F10.8)') &\n      i, sample_data(i), stddev(vals)\n  end do\n\n  if (allocated(vals)) deallocate(vals)\ncontains\n  \n  subroutine sample_add(population, val)\n    real(kind=dp), dimension(:), allocatable, intent (inout) :: population\n    real(kind=dp), intent (in) :: val\n\n    real(kind=dp), dimension(:), allocatable :: tmp\n    integer(kind=4) :: n\n\n    if (.not. allocated(population)) then\n      allocate(population(1))\n      population(1) = val\n    else\n      n = size(population)\n      call move_alloc(population, tmp)\n\n      allocate(population(n + 1))\n      population(1:n) = tmp\n      population(n + 1) = val\n    endif\n  end subroutine sample_add\n\n  \n  real(kind=dp) function stddev(vals)\n    real(kind=dp), dimension(:), intent(in) :: vals\n    real(kind=dp) :: mean\n    integer(kind=4) :: n\n\n    n = size(vals)\n    mean = sum(vals)/n\n    stddev = sqrt(sum((vals - mean)**2)/n)\n  end function stddev\nend program standard_deviation\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\nnamespace standardDeviation\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            List<double> nums = new List<double> { 2, 4, 4, 4, 5, 5, 7, 9 };\n            for (int i = 1; i <= nums.Count; i++)            \n                Console.WriteLine(sdev(nums.GetRange(0, i)));\n        }\n\n        static double sdev(List<double> nums)\n        {\n            List<double> store = new List<double>();\n            foreach (double n in nums)\n                store.Add((n - nums.Average()) * (n - nums.Average()));           \n\n            return Math.Sqrt(store.Sum() / store.Count);\n        }\n    }\n}\n"}
{"id": 32714, "name": "Cumulative standard deviation", "source": "Translate Fortran to Java: program standard_deviation\n  implicit none\n  integer(kind=4), parameter :: dp = kind(0.0d0)\n\n  real(kind=dp), dimension(:), allocatable :: vals\n  integer(kind=4) :: i\n\n  real(kind=dp), dimension(8) :: sample_data = (/ 2, 4, 4, 4, 5, 5, 7, 9 /)\n\n  do i = lbound(sample_data, 1), ubound(sample_data, 1)\n    call sample_add(vals, sample_data(i))\n    write(*, fmt='(''#'',I1,1X,''value = '',F3.1,1X,''stddev ='',1X,F10.8)') &\n      i, sample_data(i), stddev(vals)\n  end do\n\n  if (allocated(vals)) deallocate(vals)\ncontains\n  \n  subroutine sample_add(population, val)\n    real(kind=dp), dimension(:), allocatable, intent (inout) :: population\n    real(kind=dp), intent (in) :: val\n\n    real(kind=dp), dimension(:), allocatable :: tmp\n    integer(kind=4) :: n\n\n    if (.not. allocated(population)) then\n      allocate(population(1))\n      population(1) = val\n    else\n      n = size(population)\n      call move_alloc(population, tmp)\n\n      allocate(population(n + 1))\n      population(1:n) = tmp\n      population(n + 1) = val\n    endif\n  end subroutine sample_add\n\n  \n  real(kind=dp) function stddev(vals)\n    real(kind=dp), dimension(:), intent(in) :: vals\n    real(kind=dp) :: mean\n    integer(kind=4) :: n\n\n    n = size(vals)\n    mean = sum(vals)/n\n    stddev = sqrt(sum((vals - mean)**2)/n)\n  end function stddev\nend program standard_deviation\n", "target": "public class StdDev {\n    int n = 0;\n    double sum = 0;\n    double sum2 = 0;\n\n    public double sd(double x) {\n\tn++;\n\tsum += x;\n\tsum2 += x*x;\n\n\treturn Math.sqrt(sum2/n - sum*sum/n/n);\n    }\n\n    public static void main(String[] args) {\n        double[] testData = {2,4,4,4,5,5,7,9};\n        StdDev sd = new StdDev();\n\n        for (double x : testData) {\n            System.out.println(sd.sd(x));\n        }\n    }\n}\n"}
{"id": 32715, "name": "Cumulative standard deviation", "source": "Translate Fortran to Python: program standard_deviation\n  implicit none\n  integer(kind=4), parameter :: dp = kind(0.0d0)\n\n  real(kind=dp), dimension(:), allocatable :: vals\n  integer(kind=4) :: i\n\n  real(kind=dp), dimension(8) :: sample_data = (/ 2, 4, 4, 4, 5, 5, 7, 9 /)\n\n  do i = lbound(sample_data, 1), ubound(sample_data, 1)\n    call sample_add(vals, sample_data(i))\n    write(*, fmt='(''#'',I1,1X,''value = '',F3.1,1X,''stddev ='',1X,F10.8)') &\n      i, sample_data(i), stddev(vals)\n  end do\n\n  if (allocated(vals)) deallocate(vals)\ncontains\n  \n  subroutine sample_add(population, val)\n    real(kind=dp), dimension(:), allocatable, intent (inout) :: population\n    real(kind=dp), intent (in) :: val\n\n    real(kind=dp), dimension(:), allocatable :: tmp\n    integer(kind=4) :: n\n\n    if (.not. allocated(population)) then\n      allocate(population(1))\n      population(1) = val\n    else\n      n = size(population)\n      call move_alloc(population, tmp)\n\n      allocate(population(n + 1))\n      population(1:n) = tmp\n      population(n + 1) = val\n    endif\n  end subroutine sample_add\n\n  \n  real(kind=dp) function stddev(vals)\n    real(kind=dp), dimension(:), intent(in) :: vals\n    real(kind=dp) :: mean\n    integer(kind=4) :: n\n\n    n = size(vals)\n    mean = sum(vals)/n\n    stddev = sqrt(sum((vals - mean)**2)/n)\n  end function stddev\nend program standard_deviation\n", "target": ">>> from math import sqrt\n>>> def sd(x):\n    sd.sum  += x\n    sd.sum2 += x*x\n    sd.n    += 1.0\n    sum, sum2, n = sd.sum, sd.sum2, sd.n\n    return sqrt(sum2/n - sum*sum/n/n)\n\n>>> sd.sum = sd.sum2 = sd.n = 0\n>>> for value in (2,4,4,4,5,5,7,9):\n    print (value, sd(value))\n\n    \n(2, 0.0)\n(4, 1.0)\n(4, 0.94280904158206258)\n(4, 0.8660254037844386)\n(5, 0.97979589711327075)\n(5, 1.0)\n(7, 1.3997084244475311)\n(9, 2.0)\n>>>\n"}
{"id": 32995, "name": "Palindrome detection", "source": "Translate Fortran to C#: program palindro\n\n  implicit none\n\n  character(len=*), parameter :: p = \"ingirumimusnocteetconsumimurigni\"\n  \n  print *, is_palindro_r(p)\n  print *, is_palindro_r(\"anothertest\")\n  print *, is_palindro2(p)\n  print *, is_palindro2(\"test\")\n  print *, is_palindro(p)\n  print *, is_palindro(\"last test\")\n\ncontains\n", "target": "using System;\n\nclass Program\n{\n    static string Reverse(string value)\n    {\n        char[] chars = value.ToCharArray();\n        Array.Reverse(chars);\n        return new string(chars);\n    }\n\n    static bool IsPalindrome(string value)\n    {\n        return value == Reverse(value);\n    }\n\n    static void Main(string[] args)\n    {\n        Console.WriteLine(IsPalindrome(\"ingirumimusnocteetconsumimurigni\"));\n    }\n}\n"}
{"id": 32998, "name": "Palindrome detection", "source": "Translate Fortran to Java: program palindro\n\n  implicit none\n\n  character(len=*), parameter :: p = \"ingirumimusnocteetconsumimurigni\"\n  \n  print *, is_palindro_r(p)\n  print *, is_palindro_r(\"anothertest\")\n  print *, is_palindro2(p)\n  print *, is_palindro2(\"test\")\n  print *, is_palindro(p)\n  print *, is_palindro(\"last test\")\n\ncontains\n", "target": "public static boolean pali(String testMe){\n\tStringBuilder sb = new StringBuilder(testMe);\n\treturn testMe.equals(sb.reverse().toString());\n}\n"}
{"id": 32999, "name": "Palindrome detection", "source": "Translate Fortran to Python: program palindro\n\n  implicit none\n\n  character(len=*), parameter :: p = \"ingirumimusnocteetconsumimurigni\"\n  \n  print *, is_palindro_r(p)\n  print *, is_palindro_r(\"anothertest\")\n  print *, is_palindro2(p)\n  print *, is_palindro2(\"test\")\n  print *, is_palindro(p)\n  print *, is_palindro(\"last test\")\n\ncontains\n", "target": "def is_palindrome(s):\n  return s == s[::-1]\n"}
{"id": 33276, "name": "Loop over multiple arrays simultaneously", "source": "Translate Fortran to C#: program main\n implicit none\n\n integer,parameter :: n_vals = 3\n character(len=*),dimension(n_vals),parameter :: ls = ['a','b','c']\n character(len=*),dimension(n_vals),parameter :: us = ['A','B','C']\n integer,dimension(n_vals),parameter          :: ns = [1,2,3]\n\n integer :: i  \n\n do i=1,n_vals\n      write(*,'(A1,A1,I1)') ls(i),us(i),ns(i)\n end do\n\nend program main\n", "target": "class Program\n{\n    static void Main(string[] args)\n    {\n        char[] a = { 'a', 'b', 'c' };\n        char[] b = { 'A', 'B', 'C' };\n        int[] c = { 1, 2, 3 };\n        int min = Math.Min(a.Length, b.Length);\n        min = Math.Min(min, c.Length);\n        for (int i = 0; i < min; i++)\n            Console.WriteLine(\"{0}{1}{2}\", a[i], b[i], c[i]);\n    }             \n}\n"}
{"id": 33279, "name": "Loop over multiple arrays simultaneously", "source": "Translate Fortran to Java: program main\n implicit none\n\n integer,parameter :: n_vals = 3\n character(len=*),dimension(n_vals),parameter :: ls = ['a','b','c']\n character(len=*),dimension(n_vals),parameter :: us = ['A','B','C']\n integer,dimension(n_vals),parameter          :: ns = [1,2,3]\n\n integer :: i  \n\n do i=1,n_vals\n      write(*,'(A1,A1,I1)') ls(i),us(i),ns(i)\n end do\n\nend program main\n", "target": "module LoopOverMultipleArrays\n    {\n    @Inject Console console;\n\n    void run()\n        {\n        Char[]   chars   = ['a', 'b', 'c'];\n        String[] strings = [\"A\", \"B\", \"C\"];\n        Int[]    ints    = [ 1,   2,   3 ];\n\n        console.print(\"Using array indexing:\");\n        for (Int i = 0, Int longest = chars.size.maxOf(strings.size.maxOf(ints.size)); i < longest; ++i)\n            {\n            console.print($|{i < chars.size   ? chars[i].toString() : \"\"}\\\n                           |{i < strings.size ? strings[i]          : \"\"}\\\n                           |{i < ints.size    ? ints[i].toString()  : \"\"}\n                         );\n            }\n\n        console.print(\"\\nUsing array iterators:\");\n        val charIter   = chars.iterator();\n        val stringIter = strings.iterator();\n        val intIter    = ints.iterator();\n        while (True)\n            {\n            StringBuffer buf = new StringBuffer();\n            if (Char ch := charIter.next())\n                {\n                buf.add(ch);\n                }\n            if (String s := stringIter.next())\n                {\n                s.appendTo(buf);\n                }\n            if (Int n := intIter.next())\n                {\n                n.appendTo(buf);\n                }\n            if (buf.size == 0)\n                {\n                break;\n                }\n            console.print(buf);\n            }\n        }\n    }\n"}
{"id": 33280, "name": "Loop over multiple arrays simultaneously", "source": "Translate Fortran to Python: program main\n implicit none\n\n integer,parameter :: n_vals = 3\n character(len=*),dimension(n_vals),parameter :: ls = ['a','b','c']\n character(len=*),dimension(n_vals),parameter :: us = ['A','B','C']\n integer,dimension(n_vals),parameter          :: ns = [1,2,3]\n\n integer :: i  \n\n do i=1,n_vals\n      write(*,'(A1,A1,I1)') ls(i),us(i),ns(i)\n end do\n\nend program main\n", "target": ">>> print ( '\\n'.join(''.join(x) for x in \nzip('abc', 'ABC', '123')) )\naA1\nbB2\ncC3\n>>>\n"}
{"id": 33526, "name": "Sorting algorithms_Cocktail sort", "source": "Translate Fortran to C#: PROGRAM COCKTAIL\n  IMPLICIT NONE\n\n  INTEGER :: intArray(10) = (/ 4, 9, 3, -2, 0, 7, -5, 1, 6, 8 /)\n\n  WRITE(*,\"(A,10I5)\") \"Unsorted array:\", intArray\n  CALL Cocktail_sort(intArray)\n  WRITE(*,\"(A,10I5)\") \"Sorted array \u00a0:\", intArray\n  \nCONTAINS\n\n  SUBROUTINE Cocktail_sort(a)\n    INTEGER, INTENT(IN OUT) :: a(:)\n    INTEGER :: i, bottom, top, temp \n    LOGICAL :: swapped\n \n    bottom = 1\n    top = SIZE(a) - 1\n    DO WHILE (bottom < top )\n       swapped = .FALSE.\n       DO i = bottom, top\n          IF (array(i) > array(i+1)) THEN\n              temp = array(i)\n              array(i) = array(i+1)\n              array(i+1) = temp\n              swapped = .TRUE.\n          END IF\n       END DO\n       IF (.NOT. swapped) EXIT\n       DO i = top, bottom + 1, -1\n          IF (array(i) < array(i-1)) THEN\n              temp = array(i)\n              array(i) = array(i-1)\n              array(i-1) = temp\n              swapped = .TRUE.\n          END IF\n       END DO\n       IF (.NOT. swapped) EXIT\n       bottom = bottom + 1\n       top = top - 1\n    END DO\n  END SUBROUTINE Cocktail_sort\n\nEND PROGRAM COCKTAIL\n", "target": "public static void cocktailSort(int[] A)\n    {\n        bool swapped;\n        do\n        {\n            swapped = false;\n            for (int i = 0; i <= A.Length - 2; i++)\n            {\n                if (A[i] > A[i + 1])\n                {\n                    \n                    int temp = A[i];\n                    A[i] = A[i + 1];\n                    A[i + 1] = temp;\n                    swapped = true;\n                }\n            }\n            if (!swapped)\n            {\n                \n                break;\n            }\n            swapped = false;\n            for (int i = A.Length - 2; i >= 0; i--)\n            {\n                if (A[i] > A[i + 1])\n                {\n                    int temp = A[i];\n                    A[i] = A[i + 1];\n                    A[i + 1] = temp;\n                    swapped = true;\n                }\n            }\n            \n        } while (swapped);\n    }\n"}
{"id": 33530, "name": "Sorting algorithms_Cocktail sort", "source": "Translate Fortran to Java: PROGRAM COCKTAIL\n  IMPLICIT NONE\n\n  INTEGER :: intArray(10) = (/ 4, 9, 3, -2, 0, 7, -5, 1, 6, 8 /)\n\n  WRITE(*,\"(A,10I5)\") \"Unsorted array:\", intArray\n  CALL Cocktail_sort(intArray)\n  WRITE(*,\"(A,10I5)\") \"Sorted array \u00a0:\", intArray\n  \nCONTAINS\n\n  SUBROUTINE Cocktail_sort(a)\n    INTEGER, INTENT(IN OUT) :: a(:)\n    INTEGER :: i, bottom, top, temp \n    LOGICAL :: swapped\n \n    bottom = 1\n    top = SIZE(a) - 1\n    DO WHILE (bottom < top )\n       swapped = .FALSE.\n       DO i = bottom, top\n          IF (array(i) > array(i+1)) THEN\n              temp = array(i)\n              array(i) = array(i+1)\n              array(i+1) = temp\n              swapped = .TRUE.\n          END IF\n       END DO\n       IF (.NOT. swapped) EXIT\n       DO i = top, bottom + 1, -1\n          IF (array(i) < array(i-1)) THEN\n              temp = array(i)\n              array(i) = array(i-1)\n              array(i-1) = temp\n              swapped = .TRUE.\n          END IF\n       END DO\n       IF (.NOT. swapped) EXIT\n       bottom = bottom + 1\n       top = top - 1\n    END DO\n  END SUBROUTINE Cocktail_sort\n\nEND PROGRAM COCKTAIL\n", "target": "public static void cocktailSort( int[] A ){\n\tboolean swapped;\n\tdo {\n\t\tswapped = false;\n\t\tfor (int i =0; i<=  A.length  - 2;i++) {\n\t\t\tif (A[ i ] > A[ i + 1 ]) {\n\t\t\t\t\n\t\t\t\tint temp = A[i];\n\t\t\t\tA[i] = A[i+1];\n\t\t\t\tA[i+1]=temp;\n\t\t\t\tswapped = true;\n\t\t\t}\n\t\t}\n\t\tif (!swapped) {\n\t\t\t\n\t\t\tbreak;\n\t\t}\n\t\tswapped = false;\n\t\tfor (int i= A.length - 2;i>=0;i--) {\n\t\t\tif (A[ i ] > A[ i + 1 ]) {\n\t\t\t\tint temp = A[i];\n\t\t\t\tA[i] = A[i+1];\n\t\t\t\tA[i+1]=temp;\n\t\t\t\tswapped = true;\n\t\t\t}\n\t\t}\n\t\t\n\t} while (swapped);\n}\n"}
{"id": 33531, "name": "Sorting algorithms_Cocktail sort", "source": "Translate Fortran to Python: PROGRAM COCKTAIL\n  IMPLICIT NONE\n\n  INTEGER :: intArray(10) = (/ 4, 9, 3, -2, 0, 7, -5, 1, 6, 8 /)\n\n  WRITE(*,\"(A,10I5)\") \"Unsorted array:\", intArray\n  CALL Cocktail_sort(intArray)\n  WRITE(*,\"(A,10I5)\") \"Sorted array \u00a0:\", intArray\n  \nCONTAINS\n\n  SUBROUTINE Cocktail_sort(a)\n    INTEGER, INTENT(IN OUT) :: a(:)\n    INTEGER :: i, bottom, top, temp \n    LOGICAL :: swapped\n \n    bottom = 1\n    top = SIZE(a) - 1\n    DO WHILE (bottom < top )\n       swapped = .FALSE.\n       DO i = bottom, top\n          IF (array(i) > array(i+1)) THEN\n              temp = array(i)\n              array(i) = array(i+1)\n              array(i+1) = temp\n              swapped = .TRUE.\n          END IF\n       END DO\n       IF (.NOT. swapped) EXIT\n       DO i = top, bottom + 1, -1\n          IF (array(i) < array(i-1)) THEN\n              temp = array(i)\n              array(i) = array(i-1)\n              array(i-1) = temp\n              swapped = .TRUE.\n          END IF\n       END DO\n       IF (.NOT. swapped) EXIT\n       bottom = bottom + 1\n       top = top - 1\n    END DO\n  END SUBROUTINE Cocktail_sort\n\nEND PROGRAM COCKTAIL\n", "target": "def cocktailSort(A):\n    up = range(len(A)-1)\n    while True:\n        for indices in (up, reversed(up)):\n            swapped = False\n            for i in indices:\n                if A[i] > A[i+1]:  \n                    A[i], A[i+1] =  A[i+1], A[i]\n                    swapped = True\n            if not swapped:\n                return\n"}
{"id": 33760, "name": "Animate a pendulum", "source": "Translate Fortran to C#: \nprogram animated_pendulum\nimplicit none\ndouble precision, parameter :: pi = 4.0D0*atan(1.0D0), l = 1.0D-1, dt = 1.0D-2, g = 9.8D0\ninteger :: io\ndouble precision :: s_ang, c_ang, p_ang, n_ang\n\nwrite(*,*) 'Enter starting angle (in degrees):'\ndo\n  read(*,*,iostat=io) s_ang\n  if(io.ne.0 .or. s_ang.lt.-90.0D0 .or. s_ang.gt.90.0D0) then\n    write(*,*) 'Please enter an angle between 90 and -90 degrees:'\n  else\n    exit\n  end if\nend do\ncall execute_command_line('cls')\n\nc_ang = s_ang*pi/180.0D0\np_ang = c_ang\n\ncall display(c_ang)\ndo\n  call next_time_step(c_ang,p_ang,g,l,dt,n_ang)\n  if(abs(c_ang-p_ang).ge.0.05D0) then\n    call execute_command_line('cls')\n    call display(c_ang)\n  end if\nend do\nend program\n\nsubroutine next_time_step(c_ang,p_ang,g,l,dt,n_ang)\ndouble precision :: c_ang, p_ang, g, l, dt, n_ang\nn_ang = (-g*sin(c_ang)/l)*2.0D0*dt**2 + 2.0D0*c_ang - p_ang\np_ang = c_ang\nc_ang = n_ang\nend subroutine\n\nsubroutine display(c_ang)\ndouble precision :: c_ang\ncharacter (len=*), parameter :: cfmt = '(A1)'\ndouble precision :: rx, ry\ninteger :: x, y, i, j\nrx = 45.0D0*sin(c_ang)\nry = 22.5D0*cos(c_ang)\nx = int(rx)+51\ny = int(ry)+2\ndo i = 1,32\n  do j = 1,100\n    if(i.eq.y .and. j.eq.x) then\n      write(*,cfmt,advance='no') 'O'\n    else if(i.eq.y .and. (j.eq.(x-1).or.j.eq.(x+1))) then\n      write(*,cfmt,advance='no') 'G'\n    else if(j.eq.x .and. (i.eq.(y-1).or.i.eq.(y+1))) then\n      write(*,cfmt,advance='no') 'G'\n    else if(i.eq.y .and. (j.eq.(x-2).or.j.eq.(x+2))) then\n      write(*,cfmt,advance='no') '#'\n    else if(j.eq.x .and. (i.eq.(y-2).or.i.eq.(y+2))) then\n      write(*,cfmt,advance='no') 'G'\n    else if((i.eq.(y+1).and.j.eq.(x+1)) .or. (i.eq.(y-1).and.j.eq.(x-1))) then\n      write(*,cfmt,advance='no') '#'\n    else if((i.eq.(y+1).and.j.eq.(x-1)) .or. (i.eq.(y-1).and.j.eq.(x+1))) then\n      write(*,cfmt,advance='no') '#'\n    else if(j.eq.50) then\n      write(*,cfmt,advance='no') '|'\n    else if(i.eq.2) then\n      write(*,cfmt,advance='no') '-'\n    else\n      write(*,cfmt,advance='no') ' '\n    end if\n  end do\n  write(*,*)\nend do\nend subroutine\n", "target": "using System;\nusing System.Drawing;\nusing System.Windows.Forms;\n\nclass CSharpPendulum\n{\n    Form _form;\n    Timer _timer;\n    \n    double _angle = Math.PI / 2, \n           _angleAccel, \n           _angleVelocity = 0, \n           _dt = 0.1;\n    \n    int _length = 50;\n\n    [STAThread]\n    static void Main()\n    {\n        var p = new CSharpPendulum();\n    }\n\n    public CSharpPendulum()\n    {\n        _form = new Form() { Text = \"Pendulum\", Width = 200, Height = 200 };\n        _timer = new Timer() { Interval = 30 };\n\n        _timer.Tick += delegate(object sender, EventArgs e)\n        {\n            int anchorX = (_form.Width / 2) - 12,\n                anchorY = _form.Height / 4,\n                ballX = anchorX + (int)(Math.Sin(_angle) * _length),\n                ballY = anchorY + (int)(Math.Cos(_angle) * _length);\n\n            _angleAccel = -9.81 / _length * Math.Sin(_angle);\n            _angleVelocity += _angleAccel * _dt;\n            _angle += _angleVelocity * _dt;\n          \n            Bitmap dblBuffer = new Bitmap(_form.Width, _form.Height);\n            Graphics g = Graphics.FromImage(dblBuffer);\n            Graphics f = Graphics.FromHwnd(_form.Handle);\n\n            g.DrawLine(Pens.Black, new Point(anchorX, anchorY), new Point(ballX, ballY));\n            g.FillEllipse(Brushes.Black, anchorX - 3, anchorY - 4, 7, 7);\n            g.FillEllipse(Brushes.DarkGoldenrod, ballX - 7, ballY - 7, 14, 14);\n            \n            f.Clear(Color.White);\n            f.DrawImage(dblBuffer, new Point(0, 0));    \n        };\n\n        _timer.Start();\n        Application.Run(_form);\n    }     \n}\n"}
{"id": 33763, "name": "Animate a pendulum", "source": "Translate Fortran to Java: \nprogram animated_pendulum\nimplicit none\ndouble precision, parameter :: pi = 4.0D0*atan(1.0D0), l = 1.0D-1, dt = 1.0D-2, g = 9.8D0\ninteger :: io\ndouble precision :: s_ang, c_ang, p_ang, n_ang\n\nwrite(*,*) 'Enter starting angle (in degrees):'\ndo\n  read(*,*,iostat=io) s_ang\n  if(io.ne.0 .or. s_ang.lt.-90.0D0 .or. s_ang.gt.90.0D0) then\n    write(*,*) 'Please enter an angle between 90 and -90 degrees:'\n  else\n    exit\n  end if\nend do\ncall execute_command_line('cls')\n\nc_ang = s_ang*pi/180.0D0\np_ang = c_ang\n\ncall display(c_ang)\ndo\n  call next_time_step(c_ang,p_ang,g,l,dt,n_ang)\n  if(abs(c_ang-p_ang).ge.0.05D0) then\n    call execute_command_line('cls')\n    call display(c_ang)\n  end if\nend do\nend program\n\nsubroutine next_time_step(c_ang,p_ang,g,l,dt,n_ang)\ndouble precision :: c_ang, p_ang, g, l, dt, n_ang\nn_ang = (-g*sin(c_ang)/l)*2.0D0*dt**2 + 2.0D0*c_ang - p_ang\np_ang = c_ang\nc_ang = n_ang\nend subroutine\n\nsubroutine display(c_ang)\ndouble precision :: c_ang\ncharacter (len=*), parameter :: cfmt = '(A1)'\ndouble precision :: rx, ry\ninteger :: x, y, i, j\nrx = 45.0D0*sin(c_ang)\nry = 22.5D0*cos(c_ang)\nx = int(rx)+51\ny = int(ry)+2\ndo i = 1,32\n  do j = 1,100\n    if(i.eq.y .and. j.eq.x) then\n      write(*,cfmt,advance='no') 'O'\n    else if(i.eq.y .and. (j.eq.(x-1).or.j.eq.(x+1))) then\n      write(*,cfmt,advance='no') 'G'\n    else if(j.eq.x .and. (i.eq.(y-1).or.i.eq.(y+1))) then\n      write(*,cfmt,advance='no') 'G'\n    else if(i.eq.y .and. (j.eq.(x-2).or.j.eq.(x+2))) then\n      write(*,cfmt,advance='no') '#'\n    else if(j.eq.x .and. (i.eq.(y-2).or.i.eq.(y+2))) then\n      write(*,cfmt,advance='no') 'G'\n    else if((i.eq.(y+1).and.j.eq.(x+1)) .or. (i.eq.(y-1).and.j.eq.(x-1))) then\n      write(*,cfmt,advance='no') '#'\n    else if((i.eq.(y+1).and.j.eq.(x-1)) .or. (i.eq.(y-1).and.j.eq.(x+1))) then\n      write(*,cfmt,advance='no') '#'\n    else if(j.eq.50) then\n      write(*,cfmt,advance='no') '|'\n    else if(i.eq.2) then\n      write(*,cfmt,advance='no') '-'\n    else\n      write(*,cfmt,advance='no') ' '\n    end if\n  end do\n  write(*,*)\nend do\nend subroutine\n", "target": "import java.awt.*;\nimport javax.swing.*;\n\npublic class Pendulum extends JPanel implements Runnable {\n\n    private double angle = Math.PI / 2;\n    private int length;\n\n    public Pendulum(int length) {\n        this.length = length;\n        setDoubleBuffered(true);\n    }\n\n    @Override\n    public void paint(Graphics g) {\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, getWidth(), getHeight());\n        g.setColor(Color.BLACK);\n        int anchorX = getWidth() / 2, anchorY = getHeight() / 4;\n        int ballX = anchorX + (int) (Math.sin(angle) * length);\n        int ballY = anchorY + (int) (Math.cos(angle) * length);\n        g.drawLine(anchorX, anchorY, ballX, ballY);\n        g.fillOval(anchorX - 3, anchorY - 4, 7, 7);\n        g.fillOval(ballX - 7, ballY - 7, 14, 14);\n    }\n\n    public void run() {\n        double angleAccel, angleVelocity = 0, dt = 0.1;\n        while (true) {\n            angleAccel = -9.81 / length * Math.sin(angle);\n            angleVelocity += angleAccel * dt;\n            angle += angleVelocity * dt;\n            repaint();\n            try { Thread.sleep(15); } catch (InterruptedException ex) {}\n        }\n    }\n\n    @Override\n    public Dimension getPreferredSize() {\n        return new Dimension(2 * length + 50, length / 2 * 3);\n    }\n\n    public static void main(String[] args) {\n        JFrame f = new JFrame(\"Pendulum\");\n        Pendulum p = new Pendulum(200);\n        f.add(p);\n        f.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n        f.pack();\n        f.setVisible(true);\n        new Thread(p).start();\n    }\n}\n"}
{"id": 33764, "name": "Animate a pendulum", "source": "Translate Fortran to Python: \nprogram animated_pendulum\nimplicit none\ndouble precision, parameter :: pi = 4.0D0*atan(1.0D0), l = 1.0D-1, dt = 1.0D-2, g = 9.8D0\ninteger :: io\ndouble precision :: s_ang, c_ang, p_ang, n_ang\n\nwrite(*,*) 'Enter starting angle (in degrees):'\ndo\n  read(*,*,iostat=io) s_ang\n  if(io.ne.0 .or. s_ang.lt.-90.0D0 .or. s_ang.gt.90.0D0) then\n    write(*,*) 'Please enter an angle between 90 and -90 degrees:'\n  else\n    exit\n  end if\nend do\ncall execute_command_line('cls')\n\nc_ang = s_ang*pi/180.0D0\np_ang = c_ang\n\ncall display(c_ang)\ndo\n  call next_time_step(c_ang,p_ang,g,l,dt,n_ang)\n  if(abs(c_ang-p_ang).ge.0.05D0) then\n    call execute_command_line('cls')\n    call display(c_ang)\n  end if\nend do\nend program\n\nsubroutine next_time_step(c_ang,p_ang,g,l,dt,n_ang)\ndouble precision :: c_ang, p_ang, g, l, dt, n_ang\nn_ang = (-g*sin(c_ang)/l)*2.0D0*dt**2 + 2.0D0*c_ang - p_ang\np_ang = c_ang\nc_ang = n_ang\nend subroutine\n\nsubroutine display(c_ang)\ndouble precision :: c_ang\ncharacter (len=*), parameter :: cfmt = '(A1)'\ndouble precision :: rx, ry\ninteger :: x, y, i, j\nrx = 45.0D0*sin(c_ang)\nry = 22.5D0*cos(c_ang)\nx = int(rx)+51\ny = int(ry)+2\ndo i = 1,32\n  do j = 1,100\n    if(i.eq.y .and. j.eq.x) then\n      write(*,cfmt,advance='no') 'O'\n    else if(i.eq.y .and. (j.eq.(x-1).or.j.eq.(x+1))) then\n      write(*,cfmt,advance='no') 'G'\n    else if(j.eq.x .and. (i.eq.(y-1).or.i.eq.(y+1))) then\n      write(*,cfmt,advance='no') 'G'\n    else if(i.eq.y .and. (j.eq.(x-2).or.j.eq.(x+2))) then\n      write(*,cfmt,advance='no') '#'\n    else if(j.eq.x .and. (i.eq.(y-2).or.i.eq.(y+2))) then\n      write(*,cfmt,advance='no') 'G'\n    else if((i.eq.(y+1).and.j.eq.(x+1)) .or. (i.eq.(y-1).and.j.eq.(x-1))) then\n      write(*,cfmt,advance='no') '#'\n    else if((i.eq.(y+1).and.j.eq.(x-1)) .or. (i.eq.(y-1).and.j.eq.(x+1))) then\n      write(*,cfmt,advance='no') '#'\n    else if(j.eq.50) then\n      write(*,cfmt,advance='no') '|'\n    else if(i.eq.2) then\n      write(*,cfmt,advance='no') '-'\n    else\n      write(*,cfmt,advance='no') ' '\n    end if\n  end do\n  write(*,*)\nend do\nend subroutine\n", "target": "import pygame, sys\nfrom pygame.locals import *\nfrom math import sin, cos, radians\n\npygame.init()\n\nWINDOWSIZE = 250\nTIMETICK = 100\nBOBSIZE = 15\n\nwindow = pygame.display.set_mode((WINDOWSIZE, WINDOWSIZE))\npygame.display.set_caption(\"Pendulum\")\n\nscreen = pygame.display.get_surface()\nscreen.fill((255,255,255))\n\nPIVOT = (WINDOWSIZE/2, WINDOWSIZE/10)\nSWINGLENGTH = PIVOT[1]*4\n\nclass BobMass(pygame.sprite.Sprite):\n    def __init__(self):\n        pygame.sprite.Sprite.__init__(self)\n        self.theta = 45\n        self.dtheta = 0\n        self.rect = pygame.Rect(PIVOT[0]-SWINGLENGTH*cos(radians(self.theta)),\n                                PIVOT[1]+SWINGLENGTH*sin(radians(self.theta)),\n                                1,1)\n        self.draw()\n\n    def recomputeAngle(self):\n        scaling = 3000.0/(SWINGLENGTH**2)\n\n        firstDDtheta = -sin(radians(self.theta))*scaling\n        midDtheta = self.dtheta + firstDDtheta\n        midtheta = self.theta + (self.dtheta + midDtheta)/2.0\n\n        midDDtheta = -sin(radians(midtheta))*scaling\n        midDtheta = self.dtheta + (firstDDtheta + midDDtheta)/2\n        midtheta = self.theta + (self.dtheta + midDtheta)/2\n\n        midDDtheta = -sin(radians(midtheta)) * scaling\n        lastDtheta = midDtheta + midDDtheta\n        lasttheta = midtheta + (midDtheta + lastDtheta)/2.0\n        \n        lastDDtheta = -sin(radians(lasttheta)) * scaling\n        lastDtheta = midDtheta + (midDDtheta + lastDDtheta)/2.0\n        lasttheta = midtheta + (midDtheta + lastDtheta)/2.0\n\n        self.dtheta = lastDtheta\n        self.theta = lasttheta\n        self.rect = pygame.Rect(PIVOT[0]-\n                                SWINGLENGTH*sin(radians(self.theta)), \n                                PIVOT[1]+\n                                SWINGLENGTH*cos(radians(self.theta)),1,1)\n\n\n    def draw(self):\n        pygame.draw.circle(screen, (0,0,0), PIVOT, 5, 0)\n        pygame.draw.circle(screen, (0,0,0), self.rect.center, BOBSIZE, 0)\n        pygame.draw.aaline(screen, (0,0,0), PIVOT, self.rect.center)\n        pygame.draw.line(screen, (0,0,0), (0, PIVOT[1]), (WINDOWSIZE, PIVOT[1]))\n\n    def update(self):\n        self.recomputeAngle()\n        screen.fill((255,255,255))\n        self.draw()\n\nbob = BobMass()\n\nTICK = USEREVENT + 2\npygame.time.set_timer(TICK, TIMETICK)\n\ndef input(events):\n    for event in events:\n        if event.type == QUIT:\n            sys.exit(0)\n        elif event.type == TICK:\n            bob.update()\n\nwhile True:\n    input(pygame.event.get())\n    pygame.display.flip()\n"}
{"id": 33930, "name": "Non-decimal radices_Input", "source": "Translate Fortran to C#: program Example\n  implicit none\n\n  integer :: num\n  character(32) :: str\n\n  str = \"0123459\"\n  read(str, \"(i10)\") num   \n  write(*,*) num           \n\n  str = \"abcf123\"\n  read(str, \"(z8)\") num    \n  write(*,*) num           \n\n  str = \"7651\"\n  read(str, \"(o11)\") num   \n  write(*,*) num           \n\n  str = \"1010011010\"\n  read(str, \"(b32)\") num   \n  write(*,*) num           \n\nend program\n", "target": "using System;\n\nclass Program\n{\n    static void Main()\n    {\n        var value = \"100\";\n        var fromBases = new[] { 2, 8, 10, 16 };\n        var toBase = 10;\n        foreach (var fromBase in fromBases)\n        {\n            Console.WriteLine(\"{0} in base {1} is {2} in base {3}\",\n                value, fromBase, Convert.ToInt32(value, fromBase), toBase);\n        }\n    }\n}\n"}
{"id": 33933, "name": "Non-decimal radices_Input", "source": "Translate Fortran to Java: program Example\n  implicit none\n\n  integer :: num\n  character(32) :: str\n\n  str = \"0123459\"\n  read(str, \"(i10)\") num   \n  write(*,*) num           \n\n  str = \"abcf123\"\n  read(str, \"(z8)\") num    \n  write(*,*) num           \n\n  str = \"7651\"\n  read(str, \"(o11)\") num   \n  write(*,*) num           \n\n  str = \"1010011010\"\n  read(str, \"(b32)\") num   \n  write(*,*) num           \n\nend program\n", "target": "Scanner sc = new Scanner(System.in); \nsc.useRadix(base); \nsc.nextInt(); \n"}
{"id": 33934, "name": "Non-decimal radices_Input", "source": "Translate Fortran to Python: program Example\n  implicit none\n\n  integer :: num\n  character(32) :: str\n\n  str = \"0123459\"\n  read(str, \"(i10)\") num   \n  write(*,*) num           \n\n  str = \"abcf123\"\n  read(str, \"(z8)\") num    \n  write(*,*) num           \n\n  str = \"7651\"\n  read(str, \"(o11)\") num   \n  write(*,*) num           \n\n  str = \"1010011010\"\n  read(str, \"(b32)\") num   \n  write(*,*) num           \n\nend program\n", "target": ">>> text = '100'\n>>> for base in range(2,21):\n    print (\"String '%s' in base %i is  %i in base 10\" \n           % (text, base, int(text, base)))\n\n  \nString '100' in base 2 is  4 in base 10\nString '100' in base 3 is  9 in base 10\nString '100' in base 4 is  16 in base 10\nString '100' in base 5 is  25 in base 10\nString '100' in base 6 is  36 in base 10\nString '100' in base 7 is  49 in base 10\nString '100' in base 8 is  64 in base 10\nString '100' in base 9 is  81 in base 10\nString '100' in base 10 is  100 in base 10\nString '100' in base 11 is  121 in base 10\nString '100' in base 12 is  144 in base 10\nString '100' in base 13 is  169 in base 10\nString '100' in base 14 is  196 in base 10\nString '100' in base 15 is  225 in base 10\nString '100' in base 16 is  256 in base 10\nString '100' in base 17 is  289 in base 10\nString '100' in base 18 is  324 in base 10\nString '100' in base 19 is  361 in base 10\nString '100' in base 20 is  400 in base 10\n"}
{"id": 34146, "name": "Seven-sided dice from five-sided dice", "source": "Translate Fortran to C#: module rand_mod\n  implicit none\n\ncontains\n\nfunction rand5()\n  integer :: rand5\n  real :: r\n\n  call random_number(r)\n  rand5 = 5*r + 1\nend function\n  \nfunction rand7()\n  integer :: rand7\n  \n  do\n    rand7 = 5*rand5() + rand5() - 6\n    if (rand7 < 21) then\n      rand7 = rand7 / 3 + 1\n      return\n    end if\n  end do\nend function\nend module\n\nprogram Randtest\n  use rand_mod\n  implicit none\n  \n  integer, parameter :: samples = 1000000\n \n  call distcheck(rand7, samples, 0.005)\n  write(*,*)\n  call distcheck(rand7, samples, 0.001)\n\nend program\n", "target": "using System;\n\npublic class SevenSidedDice\n{\n    Random random = new Random();\n\t\t\n        static void Main(string[] args)\n\t\t{\n\t\t\tSevenSidedDice sevenDice = new SevenSidedDice();\n\t\t\tConsole.WriteLine(\"Random number from 1 to 7: \"+ sevenDice.seven());\n            Console.Read();\n\t\t}\n\t\t\n\t\tint seven()\n\t\t{\n\t\t\tint v=21;\n\t\t\twhile(v>20)\n\t\t\t\tv=five()+five()*5-6;\n\t\t\treturn 1+v%7;\n\t\t}\n\t\t\n\t\tint five()\n\t\t{\n        return 1 + random.Next(5);\n\t\t}\n}\n"}
{"id": 34150, "name": "Seven-sided dice from five-sided dice", "source": "Translate Fortran to Java: module rand_mod\n  implicit none\n\ncontains\n\nfunction rand5()\n  integer :: rand5\n  real :: r\n\n  call random_number(r)\n  rand5 = 5*r + 1\nend function\n  \nfunction rand7()\n  integer :: rand7\n  \n  do\n    rand7 = 5*rand5() + rand5() - 6\n    if (rand7 < 21) then\n      rand7 = rand7 / 3 + 1\n      return\n    end if\n  end do\nend function\nend module\n\nprogram Randtest\n  use rand_mod\n  implicit none\n  \n  integer, parameter :: samples = 1000000\n \n  call distcheck(rand7, samples, 0.005)\n  write(*,*)\n  call distcheck(rand7, samples, 0.001)\n\nend program\n", "target": "import java.util.Random;\npublic class SevenSidedDice \n{\n\tprivate static final Random rnd = new Random();\n\tpublic static void main(String[] args)\n\t{\n\t\tSevenSidedDice now=new SevenSidedDice();\n\t\tSystem.out.println(\"Random number from 1 to 7: \"+now.seven());\n\t}\n\tint seven()\n\t{\n\t\tint v=21;\n\t\twhile(v>20)\n\t\t\tv=five()+five()*5-6;\n\t\treturn 1+v%7;\n\t}\n\tint five()\n\t{\n\t\treturn 1+rnd.nextInt(5);\n\t}\n}\n"}
{"id": 34151, "name": "Seven-sided dice from five-sided dice", "source": "Translate Fortran to Python: module rand_mod\n  implicit none\n\ncontains\n\nfunction rand5()\n  integer :: rand5\n  real :: r\n\n  call random_number(r)\n  rand5 = 5*r + 1\nend function\n  \nfunction rand7()\n  integer :: rand7\n  \n  do\n    rand7 = 5*rand5() + rand5() - 6\n    if (rand7 < 21) then\n      rand7 = rand7 / 3 + 1\n      return\n    end if\n  end do\nend function\nend module\n\nprogram Randtest\n  use rand_mod\n  implicit none\n  \n  integer, parameter :: samples = 1000000\n \n  call distcheck(rand7, samples, 0.005)\n  write(*,*)\n  call distcheck(rand7, samples, 0.001)\n\nend program\n", "target": "from random import randint\n\ndef dice5():\n    return randint(1, 5)\n\ndef dice7():\n    r = dice5() + dice5() * 5 - 6\n    return (r % 7) + 1 if r < 21 else dice7()\n"}
{"id": 34339, "name": "Heronian triangles", "source": "Translate Fortran to C#:  \n      MODULE GREEK MATHEMATICIANS\t\n       CONTAINS\n        INTEGER FUNCTION GCD(I,J)\t\n         INTEGER I,J\t\n         INTEGER N,M,R\t\n          N = MAX(I,J)\t\n          M = MIN(I,J)\t\n    1     R = MOD(N,M)\t\t\nc          write (6,*) \"M,N,R\",M,N,R\n          IF (R.GT.0) THEN\t\n            N = M\t\t\t\n            M = R\t\t\t\n            IF (R .GT. 1) GO TO 1\t\n          END IF\t\t\t\n          GCD = M\t\t\t\n        END FUNCTION GCD\t\n        FUNCTION GCD3(I,J,K)\t\n         INTEGER I,J,K\t\n         INTEGER R\t\n          R = GCD(I,J)\t\t\n          IF (R .GT. 1) R = GCD(R,K)\t\n          GCD3 = R\t\t\n        END FUNCTION GCD3\n\n        REAL*8 FUNCTION HERO(SIDE)\t\nCalculations could proceed with non-integer sides.\n         INTEGER SIDE(3)\t\n         REAL*8 S\t\t\n          S = SUM(SIDE)\t\t\n          S = S/2\t\t\n          S = S*PRODUCT(S - SIDE)\t\n          HERO = SIGN(SQRT(ABS(S)),S)\t\n        END FUNCTION HERO\t\t\n      END MODULE GREEK MATHEMATICIANS\t\n\n      PROGRAM TEST\t\t\n      USE GREEK MATHEMATICIANS\t\n      INTEGER LIMIT,LOTS\t\n      PARAMETER (LIMIT = 200, LOTS = 666)\t\n      INTEGER I,J,K,SIDE(3)\t\n      EQUIVALENCE (SIDE(1),I),(SIDE(2),J),(SIDE(3),K)\t\n      REAL*8 A\t\t\t\n      TYPE ABLOB\t\t\n       INTEGER SIDE(3)\t\t\n       INTEGER PERIMETER\t\n       INTEGER AREA\t\t\n      END TYPE ABLOB\t\t\n      TYPE(ABLOB) STASH(LOTS)\t\n      INTEGER N,XNDX(LOTS)\t\n      INTEGER H,T\t\t\n      LOGICAL CURSE\t\t\n      INTEGER TASTE,CHOICE\t\n      PARAMETER (TASTE = 10, CHOICE = 210)\t\n\nCollect some triangles.\n      N = 0\t\n      DO K = 1,LIMIT\t\n        DO J = 1,K\t\t\n          DO I = 1,J\t\t\t\n            IF (GCD3(I,J,K).GT.1) CYCLE\t\n            A = HERO(SIDE)\t\t\n            IF (A.LE.0) CYCLE\t\t\n            IF (A .NE. INT(A)) CYCLE\t\n            N = N + 1\t\t\t\n            IF (N.GT.LOTS) STOP \"Too many\n            XNDX(N) = N\t\t\t\n            STASH(N).SIDE = SIDE\t\t\n            STASH(N).PERIMETER = SUM(SIDE)\t\n            STASH(N).AREA = A\t\t\t\nc            WRITE (6,10) N,STASH(N)\n   10       FORMAT (I4,\":\",3I4,I7,I8)\t\n          END DO\n        END DO\n      END DO\n      WRITE (6,11) N,LIMIT\t\n   11 FORMAT (I0,\" triangles of integral area. Sides up to \",I0)\n\nComb sort involves coding only one test, and the comparison is to be compound...\n      H = N - 1\t\n   20 H = MAX(1,H*10/13)\t\n      IF (H.EQ.9 .OR. H.EQ.10) H = 11\t\n      CURSE = .FALSE.\t\t\n      DO 24 I = N - H,1,-1\t\n        IF (STASH(XNDX(I)).AREA - STASH(XNDX(I + H)).AREA) 24,21,23 \t\n   21   IF (STASH(XNDX(I)).PERIMETER-STASH(XNDX(I+H)).PERIMETER)24,22,23 \t\n   22   IF (MAXVAL(STASH(XNDX(I)).SIDE)\t\t\t\n     1    - MAXVAL(STASH(XNDX(I+H)).SIDE)) 24,24,23\t\n   23     T=XNDX(I); XNDX(I)=XNDX(I+H); XNDX(I+H)=T\t\n          CURSE = .TRUE.\t\t\t\n   24 CONTINUE\t\t\t\t\n      IF (CURSE .OR. H.GT.1) GO TO 20\t\n\nCast forth the results, as per the specification.\n      WRITE (6,30) TASTE\n   30 FORMAT (\"First \",I0,\", ordered by area, perimeter, longest side.\",\n     1 /,\"Index ---Sides--- Perimeter Area\")\n      DO I = 1,TASTE\n        WRITE (6,10) XNDX(I),STASH(XNDX(I))\n      END DO\n\n      WRITE (6,31) CHOICE\n   31 FORMAT (\"Those triangles with area\",I7)\n      DO I = 1,N\t\n        IF (STASH(XNDX(I)).AREA.NE.CHOICE) CYCLE\n        WRITE (6,10) XNDX(I),STASH(XNDX(I))\t\n      END DO\t\t\n      END\n", "target": "using System;\nusing System.Collections.Generic;\n\nnamespace heron\n{\n    class Program{\n        static void Main(string[] args){           \n            List<int[]> list = new List<int[]>();\n            for (int c = 1; c <= 200; c++)\n                for (int b = 1; b <= c; b++)\n                    for (int a = 1; a <= b; a++)\n                        if (gcd(a, gcd(b, c)) == 1 && isHeron(heronArea(a, b, c)))\n                            list.Add(new int[] { a, b, c, a + b + c, (int)heronArea(a, b, c)});\n            sort(list);\n            Console.WriteLine(\"Number of primitive Heronian triangles with sides up to 200: \" + list.Count + \"\\n\\nFirst ten when ordered by increasing area, then perimeter,then maximum sides:\\nSides\\t\\t\\tPerimeter\\tArea\");\n            for(int i = 0; i < 10; i++)\n                Console.WriteLine(list[i][0] + \"\\t\" + list[i][1] + \"\\t\" + list[i][2] + \"\\t\" + list[i][3] + \"\\t\\t\" + list[i][4]);\n            Console.WriteLine(\"\\nPerimeter = 210\\nSides\\t\\t\\tPerimeter\\tArea\");\n            foreach (int[] i in list)\n                if (i[4] == 210)\n                    Console.WriteLine(i[0] + \"\\t\" + i[1] + \"\\t\" + i[2] + \"\\t\" + i[3] + \"\\t\\t\" + i[4]);     \n        }\n        static bool isHeron(double heronArea){\n            return heronArea % 1 == 0 && heronArea != 0;\n        }\n        static double heronArea(int a, int b, int c){\n            double s = (a + b + c) / 2d;\n            return Math.Sqrt(s * (s - a) * (s - b) * (s - c));\n        }\n        static int gcd(int a, int b){\n            int remainder = 1, dividend, divisor;\n            dividend = a > b ? a : b;\n            divisor = a > b ? b : a;\n            while (remainder != 0){\n                remainder = dividend % divisor;\n                if (remainder != 0){\n                    dividend = divisor;\n                    divisor = remainder;\n                }\n            }\n            return divisor;\n        }\n        static void sort(List<int[]> list){\n            int[] temp = new int[5];\n            bool changed = true;\n            while(changed){\n                changed = false;\n                for (int i = 1; i < list.Count; i++)\n                    if (list[i][4] < list[i - 1][4] || list[i][4] == list[i - 1][4] && list[i][3] < list[i - 1][3]){\n                        temp = list[i];\n                        list[i] = list[i - 1];\n                        list[i - 1] = temp;\n                        changed = true;\n                    }                \n            }\n        }\n    }\n}\n"}
{"id": 34340, "name": "Heronian triangles", "source": "Translate Fortran to C#:  \n      MODULE GREEK MATHEMATICIANS\t\n       CONTAINS\n        INTEGER FUNCTION GCD(I,J)\t\n         INTEGER I,J\t\n         INTEGER N,M,R\t\n          N = MAX(I,J)\t\n          M = MIN(I,J)\t\n    1     R = MOD(N,M)\t\t\nc          write (6,*) \"M,N,R\",M,N,R\n          IF (R.GT.0) THEN\t\n            N = M\t\t\t\n            M = R\t\t\t\n            IF (R .GT. 1) GO TO 1\t\n          END IF\t\t\t\n          GCD = M\t\t\t\n        END FUNCTION GCD\t\n        FUNCTION GCD3(I,J,K)\t\n         INTEGER I,J,K\t\n         INTEGER R\t\n          R = GCD(I,J)\t\t\n          IF (R .GT. 1) R = GCD(R,K)\t\n          GCD3 = R\t\t\n        END FUNCTION GCD3\n\n        REAL*8 FUNCTION HERO(SIDE)\t\nCalculations could proceed with non-integer sides.\n         INTEGER SIDE(3)\t\n         REAL*8 S\t\t\n          S = SUM(SIDE)\t\t\n          S = S/2\t\t\n          S = S*PRODUCT(S - SIDE)\t\n          HERO = SIGN(SQRT(ABS(S)),S)\t\n        END FUNCTION HERO\t\t\n      END MODULE GREEK MATHEMATICIANS\t\n\n      PROGRAM TEST\t\t\n      USE GREEK MATHEMATICIANS\t\n      INTEGER LIMIT,LOTS\t\n      PARAMETER (LIMIT = 200, LOTS = 666)\t\n      INTEGER I,J,K,SIDE(3)\t\n      EQUIVALENCE (SIDE(1),I),(SIDE(2),J),(SIDE(3),K)\t\n      REAL*8 A\t\t\t\n      TYPE ABLOB\t\t\n       INTEGER SIDE(3)\t\t\n       INTEGER PERIMETER\t\n       INTEGER AREA\t\t\n      END TYPE ABLOB\t\t\n      TYPE(ABLOB) STASH(LOTS)\t\n      INTEGER N,XNDX(LOTS)\t\n      INTEGER H,T\t\t\n      LOGICAL CURSE\t\t\n      INTEGER TASTE,CHOICE\t\n      PARAMETER (TASTE = 10, CHOICE = 210)\t\n\nCollect some triangles.\n      N = 0\t\n      DO K = 1,LIMIT\t\n        DO J = 1,K\t\t\n          DO I = 1,J\t\t\t\n            IF (GCD3(I,J,K).GT.1) CYCLE\t\n            A = HERO(SIDE)\t\t\n            IF (A.LE.0) CYCLE\t\t\n            IF (A .NE. INT(A)) CYCLE\t\n            N = N + 1\t\t\t\n            IF (N.GT.LOTS) STOP \"Too many\n            XNDX(N) = N\t\t\t\n            STASH(N).SIDE = SIDE\t\t\n            STASH(N).PERIMETER = SUM(SIDE)\t\n            STASH(N).AREA = A\t\t\t\nc            WRITE (6,10) N,STASH(N)\n   10       FORMAT (I4,\":\",3I4,I7,I8)\t\n          END DO\n        END DO\n      END DO\n      WRITE (6,11) N,LIMIT\t\n   11 FORMAT (I0,\" triangles of integral area. Sides up to \",I0)\n\nComb sort involves coding only one test, and the comparison is to be compound...\n      H = N - 1\t\n   20 H = MAX(1,H*10/13)\t\n      IF (H.EQ.9 .OR. H.EQ.10) H = 11\t\n      CURSE = .FALSE.\t\t\n      DO 24 I = N - H,1,-1\t\n        IF (STASH(XNDX(I)).AREA - STASH(XNDX(I + H)).AREA) 24,21,23 \t\n   21   IF (STASH(XNDX(I)).PERIMETER-STASH(XNDX(I+H)).PERIMETER)24,22,23 \t\n   22   IF (MAXVAL(STASH(XNDX(I)).SIDE)\t\t\t\n     1    - MAXVAL(STASH(XNDX(I+H)).SIDE)) 24,24,23\t\n   23     T=XNDX(I); XNDX(I)=XNDX(I+H); XNDX(I+H)=T\t\n          CURSE = .TRUE.\t\t\t\n   24 CONTINUE\t\t\t\t\n      IF (CURSE .OR. H.GT.1) GO TO 20\t\n\nCast forth the results, as per the specification.\n      WRITE (6,30) TASTE\n   30 FORMAT (\"First \",I0,\", ordered by area, perimeter, longest side.\",\n     1 /,\"Index ---Sides--- Perimeter Area\")\n      DO I = 1,TASTE\n        WRITE (6,10) XNDX(I),STASH(XNDX(I))\n      END DO\n\n      WRITE (6,31) CHOICE\n   31 FORMAT (\"Those triangles with area\",I7)\n      DO I = 1,N\t\n        IF (STASH(XNDX(I)).AREA.NE.CHOICE) CYCLE\n        WRITE (6,10) XNDX(I),STASH(XNDX(I))\t\n      END DO\t\t\n      END\n", "target": "using System;\nusing System.Collections.Generic;\n\nnamespace heron\n{\n    class Program{\n        static void Main(string[] args){           \n            List<int[]> list = new List<int[]>();\n            for (int c = 1; c <= 200; c++)\n                for (int b = 1; b <= c; b++)\n                    for (int a = 1; a <= b; a++)\n                        if (gcd(a, gcd(b, c)) == 1 && isHeron(heronArea(a, b, c)))\n                            list.Add(new int[] { a, b, c, a + b + c, (int)heronArea(a, b, c)});\n            sort(list);\n            Console.WriteLine(\"Number of primitive Heronian triangles with sides up to 200: \" + list.Count + \"\\n\\nFirst ten when ordered by increasing area, then perimeter,then maximum sides:\\nSides\\t\\t\\tPerimeter\\tArea\");\n            for(int i = 0; i < 10; i++)\n                Console.WriteLine(list[i][0] + \"\\t\" + list[i][1] + \"\\t\" + list[i][2] + \"\\t\" + list[i][3] + \"\\t\\t\" + list[i][4]);\n            Console.WriteLine(\"\\nPerimeter = 210\\nSides\\t\\t\\tPerimeter\\tArea\");\n            foreach (int[] i in list)\n                if (i[4] == 210)\n                    Console.WriteLine(i[0] + \"\\t\" + i[1] + \"\\t\" + i[2] + \"\\t\" + i[3] + \"\\t\\t\" + i[4]);     \n        }\n        static bool isHeron(double heronArea){\n            return heronArea % 1 == 0 && heronArea != 0;\n        }\n        static double heronArea(int a, int b, int c){\n            double s = (a + b + c) / 2d;\n            return Math.Sqrt(s * (s - a) * (s - b) * (s - c));\n        }\n        static int gcd(int a, int b){\n            int remainder = 1, dividend, divisor;\n            dividend = a > b ? a : b;\n            divisor = a > b ? b : a;\n            while (remainder != 0){\n                remainder = dividend % divisor;\n                if (remainder != 0){\n                    dividend = divisor;\n                    divisor = remainder;\n                }\n            }\n            return divisor;\n        }\n        static void sort(List<int[]> list){\n            int[] temp = new int[5];\n            bool changed = true;\n            while(changed){\n                changed = false;\n                for (int i = 1; i < list.Count; i++)\n                    if (list[i][4] < list[i - 1][4] || list[i][4] == list[i - 1][4] && list[i][3] < list[i - 1][3]){\n                        temp = list[i];\n                        list[i] = list[i - 1];\n                        list[i - 1] = temp;\n                        changed = true;\n                    }                \n            }\n        }\n    }\n}\n"}
{"id": 34345, "name": "Heronian triangles", "source": "Translate Fortran to Java:  \n      MODULE GREEK MATHEMATICIANS\t\n       CONTAINS\n        INTEGER FUNCTION GCD(I,J)\t\n         INTEGER I,J\t\n         INTEGER N,M,R\t\n          N = MAX(I,J)\t\n          M = MIN(I,J)\t\n    1     R = MOD(N,M)\t\t\nc          write (6,*) \"M,N,R\",M,N,R\n          IF (R.GT.0) THEN\t\n            N = M\t\t\t\n            M = R\t\t\t\n            IF (R .GT. 1) GO TO 1\t\n          END IF\t\t\t\n          GCD = M\t\t\t\n        END FUNCTION GCD\t\n        FUNCTION GCD3(I,J,K)\t\n         INTEGER I,J,K\t\n         INTEGER R\t\n          R = GCD(I,J)\t\t\n          IF (R .GT. 1) R = GCD(R,K)\t\n          GCD3 = R\t\t\n        END FUNCTION GCD3\n\n        REAL*8 FUNCTION HERO(SIDE)\t\nCalculations could proceed with non-integer sides.\n         INTEGER SIDE(3)\t\n         REAL*8 S\t\t\n          S = SUM(SIDE)\t\t\n          S = S/2\t\t\n          S = S*PRODUCT(S - SIDE)\t\n          HERO = SIGN(SQRT(ABS(S)),S)\t\n        END FUNCTION HERO\t\t\n      END MODULE GREEK MATHEMATICIANS\t\n\n      PROGRAM TEST\t\t\n      USE GREEK MATHEMATICIANS\t\n      INTEGER LIMIT,LOTS\t\n      PARAMETER (LIMIT = 200, LOTS = 666)\t\n      INTEGER I,J,K,SIDE(3)\t\n      EQUIVALENCE (SIDE(1),I),(SIDE(2),J),(SIDE(3),K)\t\n      REAL*8 A\t\t\t\n      TYPE ABLOB\t\t\n       INTEGER SIDE(3)\t\t\n       INTEGER PERIMETER\t\n       INTEGER AREA\t\t\n      END TYPE ABLOB\t\t\n      TYPE(ABLOB) STASH(LOTS)\t\n      INTEGER N,XNDX(LOTS)\t\n      INTEGER H,T\t\t\n      LOGICAL CURSE\t\t\n      INTEGER TASTE,CHOICE\t\n      PARAMETER (TASTE = 10, CHOICE = 210)\t\n\nCollect some triangles.\n      N = 0\t\n      DO K = 1,LIMIT\t\n        DO J = 1,K\t\t\n          DO I = 1,J\t\t\t\n            IF (GCD3(I,J,K).GT.1) CYCLE\t\n            A = HERO(SIDE)\t\t\n            IF (A.LE.0) CYCLE\t\t\n            IF (A .NE. INT(A)) CYCLE\t\n            N = N + 1\t\t\t\n            IF (N.GT.LOTS) STOP \"Too many\n            XNDX(N) = N\t\t\t\n            STASH(N).SIDE = SIDE\t\t\n            STASH(N).PERIMETER = SUM(SIDE)\t\n            STASH(N).AREA = A\t\t\t\nc            WRITE (6,10) N,STASH(N)\n   10       FORMAT (I4,\":\",3I4,I7,I8)\t\n          END DO\n        END DO\n      END DO\n      WRITE (6,11) N,LIMIT\t\n   11 FORMAT (I0,\" triangles of integral area. Sides up to \",I0)\n\nComb sort involves coding only one test, and the comparison is to be compound...\n      H = N - 1\t\n   20 H = MAX(1,H*10/13)\t\n      IF (H.EQ.9 .OR. H.EQ.10) H = 11\t\n      CURSE = .FALSE.\t\t\n      DO 24 I = N - H,1,-1\t\n        IF (STASH(XNDX(I)).AREA - STASH(XNDX(I + H)).AREA) 24,21,23 \t\n   21   IF (STASH(XNDX(I)).PERIMETER-STASH(XNDX(I+H)).PERIMETER)24,22,23 \t\n   22   IF (MAXVAL(STASH(XNDX(I)).SIDE)\t\t\t\n     1    - MAXVAL(STASH(XNDX(I+H)).SIDE)) 24,24,23\t\n   23     T=XNDX(I); XNDX(I)=XNDX(I+H); XNDX(I+H)=T\t\n          CURSE = .TRUE.\t\t\t\n   24 CONTINUE\t\t\t\t\n      IF (CURSE .OR. H.GT.1) GO TO 20\t\n\nCast forth the results, as per the specification.\n      WRITE (6,30) TASTE\n   30 FORMAT (\"First \",I0,\", ordered by area, perimeter, longest side.\",\n     1 /,\"Index ---Sides--- Perimeter Area\")\n      DO I = 1,TASTE\n        WRITE (6,10) XNDX(I),STASH(XNDX(I))\n      END DO\n\n      WRITE (6,31) CHOICE\n   31 FORMAT (\"Those triangles with area\",I7)\n      DO I = 1,N\t\n        IF (STASH(XNDX(I)).AREA.NE.CHOICE) CYCLE\n        WRITE (6,10) XNDX(I),STASH(XNDX(I))\t\n      END DO\t\t\n      END\n", "target": "import java.util.ArrayList;\n\npublic class Heron {\n    public static void main(String[] args) {\n        ArrayList<int[]> list = new ArrayList<>();\n\n        for (int c = 1; c <= 200; c++) {\n            for (int b = 1; b <= c; b++) {\n                for (int a = 1; a <= b; a++) {\n\n                    if (gcd(gcd(a, b), c) == 1 && isHeron(heronArea(a, b, c))){\n                        int area = (int) heronArea(a, b, c);\n                        list.add(new int[]{a, b, c, a + b + c, area});\n                    }\n                }\n            }\n        }\n        sort(list);\n\n        System.out.printf(\"Number of primitive Heronian triangles with sides up \"\n                + \"to 200: %d\\n\\nFirst ten when ordered by increasing area, then\"\n                + \" perimeter:\\nSides       Perimeter   Area\", list.size());\n\n        for (int i = 0; i < 10; i++) {\n            System.out.printf(\"\\n%d x %d x %d   %d      %d\",\n                    list.get(i)[0], list.get(i)[1], list.get(i)[2],\n                    list.get(i)[3], list.get(i)[4]);\n        }\n\n        System.out.printf(\"\\n\\nArea = 210\\nSides        Perimeter   Area\");\n        for (int i = 0; i < list.size(); i++) {\n            if (list.get(i)[4] == 210)\n                System.out.printf(\"\\n%d x %d x %d   %d      %d\",\n                        list.get(i)[0], list.get(i)[1], list.get(i)[2],\n                        list.get(i)[3], list.get(i)[4]);\n        }\n    }\n\n    public static double heronArea(int a, int b, int c) {\n        double s = (a + b + c) / 2f;\n        return Math.sqrt(s * (s - a) * (s - b) * (s - c));\n    }\n\n    public static boolean isHeron(double h) {\n        return h % 1 == 0 && h > 0;\n    }\n\n    public static int gcd(int a, int b) {\n        int leftover = 1, dividend = a > b ? a : b, divisor = a > b ? b : a;\n        while (leftover != 0) {\n            leftover = dividend % divisor;\n            if (leftover > 0) {\n                dividend = divisor;\n                divisor = leftover;\n            }\n        }\n        return divisor;\n    }\n\n    public static void sort(ArrayList<int[]> list) {\n        boolean swapped = true;\n        int[] temp;\n        while (swapped) {\n            swapped = false;\n            for (int i = 1; i < list.size(); i++) {\n                if (list.get(i)[4] < list.get(i - 1)[4] ||\n                        list.get(i)[4] == list.get(i - 1)[4] &&\n                        list.get(i)[3] < list.get(i - 1)[3]) {\n                    temp = list.get(i);\n                    list.set(i, list.get(i - 1));\n                    list.set(i - 1, temp);\n                    swapped = true;\n                }\n            }\n        }\n    }\n}\n"}
{"id": 34346, "name": "Heronian triangles", "source": "Translate Fortran to Java:  \n      MODULE GREEK MATHEMATICIANS\t\n       CONTAINS\n        INTEGER FUNCTION GCD(I,J)\t\n         INTEGER I,J\t\n         INTEGER N,M,R\t\n          N = MAX(I,J)\t\n          M = MIN(I,J)\t\n    1     R = MOD(N,M)\t\t\nc          write (6,*) \"M,N,R\",M,N,R\n          IF (R.GT.0) THEN\t\n            N = M\t\t\t\n            M = R\t\t\t\n            IF (R .GT. 1) GO TO 1\t\n          END IF\t\t\t\n          GCD = M\t\t\t\n        END FUNCTION GCD\t\n        FUNCTION GCD3(I,J,K)\t\n         INTEGER I,J,K\t\n         INTEGER R\t\n          R = GCD(I,J)\t\t\n          IF (R .GT. 1) R = GCD(R,K)\t\n          GCD3 = R\t\t\n        END FUNCTION GCD3\n\n        REAL*8 FUNCTION HERO(SIDE)\t\nCalculations could proceed with non-integer sides.\n         INTEGER SIDE(3)\t\n         REAL*8 S\t\t\n          S = SUM(SIDE)\t\t\n          S = S/2\t\t\n          S = S*PRODUCT(S - SIDE)\t\n          HERO = SIGN(SQRT(ABS(S)),S)\t\n        END FUNCTION HERO\t\t\n      END MODULE GREEK MATHEMATICIANS\t\n\n      PROGRAM TEST\t\t\n      USE GREEK MATHEMATICIANS\t\n      INTEGER LIMIT,LOTS\t\n      PARAMETER (LIMIT = 200, LOTS = 666)\t\n      INTEGER I,J,K,SIDE(3)\t\n      EQUIVALENCE (SIDE(1),I),(SIDE(2),J),(SIDE(3),K)\t\n      REAL*8 A\t\t\t\n      TYPE ABLOB\t\t\n       INTEGER SIDE(3)\t\t\n       INTEGER PERIMETER\t\n       INTEGER AREA\t\t\n      END TYPE ABLOB\t\t\n      TYPE(ABLOB) STASH(LOTS)\t\n      INTEGER N,XNDX(LOTS)\t\n      INTEGER H,T\t\t\n      LOGICAL CURSE\t\t\n      INTEGER TASTE,CHOICE\t\n      PARAMETER (TASTE = 10, CHOICE = 210)\t\n\nCollect some triangles.\n      N = 0\t\n      DO K = 1,LIMIT\t\n        DO J = 1,K\t\t\n          DO I = 1,J\t\t\t\n            IF (GCD3(I,J,K).GT.1) CYCLE\t\n            A = HERO(SIDE)\t\t\n            IF (A.LE.0) CYCLE\t\t\n            IF (A .NE. INT(A)) CYCLE\t\n            N = N + 1\t\t\t\n            IF (N.GT.LOTS) STOP \"Too many\n            XNDX(N) = N\t\t\t\n            STASH(N).SIDE = SIDE\t\t\n            STASH(N).PERIMETER = SUM(SIDE)\t\n            STASH(N).AREA = A\t\t\t\nc            WRITE (6,10) N,STASH(N)\n   10       FORMAT (I4,\":\",3I4,I7,I8)\t\n          END DO\n        END DO\n      END DO\n      WRITE (6,11) N,LIMIT\t\n   11 FORMAT (I0,\" triangles of integral area. Sides up to \",I0)\n\nComb sort involves coding only one test, and the comparison is to be compound...\n      H = N - 1\t\n   20 H = MAX(1,H*10/13)\t\n      IF (H.EQ.9 .OR. H.EQ.10) H = 11\t\n      CURSE = .FALSE.\t\t\n      DO 24 I = N - H,1,-1\t\n        IF (STASH(XNDX(I)).AREA - STASH(XNDX(I + H)).AREA) 24,21,23 \t\n   21   IF (STASH(XNDX(I)).PERIMETER-STASH(XNDX(I+H)).PERIMETER)24,22,23 \t\n   22   IF (MAXVAL(STASH(XNDX(I)).SIDE)\t\t\t\n     1    - MAXVAL(STASH(XNDX(I+H)).SIDE)) 24,24,23\t\n   23     T=XNDX(I); XNDX(I)=XNDX(I+H); XNDX(I+H)=T\t\n          CURSE = .TRUE.\t\t\t\n   24 CONTINUE\t\t\t\t\n      IF (CURSE .OR. H.GT.1) GO TO 20\t\n\nCast forth the results, as per the specification.\n      WRITE (6,30) TASTE\n   30 FORMAT (\"First \",I0,\", ordered by area, perimeter, longest side.\",\n     1 /,\"Index ---Sides--- Perimeter Area\")\n      DO I = 1,TASTE\n        WRITE (6,10) XNDX(I),STASH(XNDX(I))\n      END DO\n\n      WRITE (6,31) CHOICE\n   31 FORMAT (\"Those triangles with area\",I7)\n      DO I = 1,N\t\n        IF (STASH(XNDX(I)).AREA.NE.CHOICE) CYCLE\n        WRITE (6,10) XNDX(I),STASH(XNDX(I))\t\n      END DO\t\t\n      END\n", "target": "import java.util.ArrayList;\n\npublic class Heron {\n    public static void main(String[] args) {\n        ArrayList<int[]> list = new ArrayList<>();\n\n        for (int c = 1; c <= 200; c++) {\n            for (int b = 1; b <= c; b++) {\n                for (int a = 1; a <= b; a++) {\n\n                    if (gcd(gcd(a, b), c) == 1 && isHeron(heronArea(a, b, c))){\n                        int area = (int) heronArea(a, b, c);\n                        list.add(new int[]{a, b, c, a + b + c, area});\n                    }\n                }\n            }\n        }\n        sort(list);\n\n        System.out.printf(\"Number of primitive Heronian triangles with sides up \"\n                + \"to 200: %d\\n\\nFirst ten when ordered by increasing area, then\"\n                + \" perimeter:\\nSides       Perimeter   Area\", list.size());\n\n        for (int i = 0; i < 10; i++) {\n            System.out.printf(\"\\n%d x %d x %d   %d      %d\",\n                    list.get(i)[0], list.get(i)[1], list.get(i)[2],\n                    list.get(i)[3], list.get(i)[4]);\n        }\n\n        System.out.printf(\"\\n\\nArea = 210\\nSides        Perimeter   Area\");\n        for (int i = 0; i < list.size(); i++) {\n            if (list.get(i)[4] == 210)\n                System.out.printf(\"\\n%d x %d x %d   %d      %d\",\n                        list.get(i)[0], list.get(i)[1], list.get(i)[2],\n                        list.get(i)[3], list.get(i)[4]);\n        }\n    }\n\n    public static double heronArea(int a, int b, int c) {\n        double s = (a + b + c) / 2f;\n        return Math.sqrt(s * (s - a) * (s - b) * (s - c));\n    }\n\n    public static boolean isHeron(double h) {\n        return h % 1 == 0 && h > 0;\n    }\n\n    public static int gcd(int a, int b) {\n        int leftover = 1, dividend = a > b ? a : b, divisor = a > b ? b : a;\n        while (leftover != 0) {\n            leftover = dividend % divisor;\n            if (leftover > 0) {\n                dividend = divisor;\n                divisor = leftover;\n            }\n        }\n        return divisor;\n    }\n\n    public static void sort(ArrayList<int[]> list) {\n        boolean swapped = true;\n        int[] temp;\n        while (swapped) {\n            swapped = false;\n            for (int i = 1; i < list.size(); i++) {\n                if (list.get(i)[4] < list.get(i - 1)[4] ||\n                        list.get(i)[4] == list.get(i - 1)[4] &&\n                        list.get(i)[3] < list.get(i - 1)[3]) {\n                    temp = list.get(i);\n                    list.set(i, list.get(i - 1));\n                    list.set(i - 1, temp);\n                    swapped = true;\n                }\n            }\n        }\n    }\n}\n"}
{"id": 34347, "name": "Heronian triangles", "source": "Translate Fortran to Python:  \n      MODULE GREEK MATHEMATICIANS\t\n       CONTAINS\n        INTEGER FUNCTION GCD(I,J)\t\n         INTEGER I,J\t\n         INTEGER N,M,R\t\n          N = MAX(I,J)\t\n          M = MIN(I,J)\t\n    1     R = MOD(N,M)\t\t\nc          write (6,*) \"M,N,R\",M,N,R\n          IF (R.GT.0) THEN\t\n            N = M\t\t\t\n            M = R\t\t\t\n            IF (R .GT. 1) GO TO 1\t\n          END IF\t\t\t\n          GCD = M\t\t\t\n        END FUNCTION GCD\t\n        FUNCTION GCD3(I,J,K)\t\n         INTEGER I,J,K\t\n         INTEGER R\t\n          R = GCD(I,J)\t\t\n          IF (R .GT. 1) R = GCD(R,K)\t\n          GCD3 = R\t\t\n        END FUNCTION GCD3\n\n        REAL*8 FUNCTION HERO(SIDE)\t\nCalculations could proceed with non-integer sides.\n         INTEGER SIDE(3)\t\n         REAL*8 S\t\t\n          S = SUM(SIDE)\t\t\n          S = S/2\t\t\n          S = S*PRODUCT(S - SIDE)\t\n          HERO = SIGN(SQRT(ABS(S)),S)\t\n        END FUNCTION HERO\t\t\n      END MODULE GREEK MATHEMATICIANS\t\n\n      PROGRAM TEST\t\t\n      USE GREEK MATHEMATICIANS\t\n      INTEGER LIMIT,LOTS\t\n      PARAMETER (LIMIT = 200, LOTS = 666)\t\n      INTEGER I,J,K,SIDE(3)\t\n      EQUIVALENCE (SIDE(1),I),(SIDE(2),J),(SIDE(3),K)\t\n      REAL*8 A\t\t\t\n      TYPE ABLOB\t\t\n       INTEGER SIDE(3)\t\t\n       INTEGER PERIMETER\t\n       INTEGER AREA\t\t\n      END TYPE ABLOB\t\t\n      TYPE(ABLOB) STASH(LOTS)\t\n      INTEGER N,XNDX(LOTS)\t\n      INTEGER H,T\t\t\n      LOGICAL CURSE\t\t\n      INTEGER TASTE,CHOICE\t\n      PARAMETER (TASTE = 10, CHOICE = 210)\t\n\nCollect some triangles.\n      N = 0\t\n      DO K = 1,LIMIT\t\n        DO J = 1,K\t\t\n          DO I = 1,J\t\t\t\n            IF (GCD3(I,J,K).GT.1) CYCLE\t\n            A = HERO(SIDE)\t\t\n            IF (A.LE.0) CYCLE\t\t\n            IF (A .NE. INT(A)) CYCLE\t\n            N = N + 1\t\t\t\n            IF (N.GT.LOTS) STOP \"Too many\n            XNDX(N) = N\t\t\t\n            STASH(N).SIDE = SIDE\t\t\n            STASH(N).PERIMETER = SUM(SIDE)\t\n            STASH(N).AREA = A\t\t\t\nc            WRITE (6,10) N,STASH(N)\n   10       FORMAT (I4,\":\",3I4,I7,I8)\t\n          END DO\n        END DO\n      END DO\n      WRITE (6,11) N,LIMIT\t\n   11 FORMAT (I0,\" triangles of integral area. Sides up to \",I0)\n\nComb sort involves coding only one test, and the comparison is to be compound...\n      H = N - 1\t\n   20 H = MAX(1,H*10/13)\t\n      IF (H.EQ.9 .OR. H.EQ.10) H = 11\t\n      CURSE = .FALSE.\t\t\n      DO 24 I = N - H,1,-1\t\n        IF (STASH(XNDX(I)).AREA - STASH(XNDX(I + H)).AREA) 24,21,23 \t\n   21   IF (STASH(XNDX(I)).PERIMETER-STASH(XNDX(I+H)).PERIMETER)24,22,23 \t\n   22   IF (MAXVAL(STASH(XNDX(I)).SIDE)\t\t\t\n     1    - MAXVAL(STASH(XNDX(I+H)).SIDE)) 24,24,23\t\n   23     T=XNDX(I); XNDX(I)=XNDX(I+H); XNDX(I+H)=T\t\n          CURSE = .TRUE.\t\t\t\n   24 CONTINUE\t\t\t\t\n      IF (CURSE .OR. H.GT.1) GO TO 20\t\n\nCast forth the results, as per the specification.\n      WRITE (6,30) TASTE\n   30 FORMAT (\"First \",I0,\", ordered by area, perimeter, longest side.\",\n     1 /,\"Index ---Sides--- Perimeter Area\")\n      DO I = 1,TASTE\n        WRITE (6,10) XNDX(I),STASH(XNDX(I))\n      END DO\n\n      WRITE (6,31) CHOICE\n   31 FORMAT (\"Those triangles with area\",I7)\n      DO I = 1,N\t\n        IF (STASH(XNDX(I)).AREA.NE.CHOICE) CYCLE\n        WRITE (6,10) XNDX(I),STASH(XNDX(I))\t\n      END DO\t\t\n      END\n", "target": "from __future__ import division, print_function\nfrom math import gcd, sqrt\n\n\ndef hero(a, b, c):\n    s = (a + b + c) / 2\n    a2 = s * (s - a) * (s - b) * (s - c)\n    return sqrt(a2) if a2 > 0 else 0\n\n\ndef is_heronian(a, b, c):\n    a = hero(a, b, c)\n    return a > 0 and a.is_integer()\n\n\ndef gcd3(x, y, z):\n    return gcd(gcd(x, y), z)\n\n\nif __name__ == '__main__':\n    MAXSIDE = 200\n\n    N = 1 + MAXSIDE\n    h = [(x, y, z)\n         for x in range(1, N)\n         for y in range(x, N)\n         for z in range(y, N) if (x + y > z) and\n         1 == gcd3(x, y, z) and\n         is_heronian(x, y, z)]\n\n    \n    h.sort(key=lambda x: (hero(*x), sum(x), x[::-1]))\n\n    print(\n        'Primitive Heronian triangles with sides up to %i:' % MAXSIDE, len(h)\n    )\n    print('\\nFirst ten when ordered by increasing area, then perimeter,',\n          'then maximum sides:')\n    print('\\n'.join('  %14r perim: %3i area: %i'\n                    % (sides, sum(sides), hero(*sides)) for sides in h[:10]))\n    print('\\nAll with area 210 subject to the previous ordering:')\n    print('\\n'.join('  %14r perim: %3i area: %i'\n                    % (sides, sum(sides), hero(*sides)) for sides in h\n                    if hero(*sides) == 210))\n"}
{"id": 34348, "name": "Heronian triangles", "source": "Translate Fortran to Python:  \n      MODULE GREEK MATHEMATICIANS\t\n       CONTAINS\n        INTEGER FUNCTION GCD(I,J)\t\n         INTEGER I,J\t\n         INTEGER N,M,R\t\n          N = MAX(I,J)\t\n          M = MIN(I,J)\t\n    1     R = MOD(N,M)\t\t\nc          write (6,*) \"M,N,R\",M,N,R\n          IF (R.GT.0) THEN\t\n            N = M\t\t\t\n            M = R\t\t\t\n            IF (R .GT. 1) GO TO 1\t\n          END IF\t\t\t\n          GCD = M\t\t\t\n        END FUNCTION GCD\t\n        FUNCTION GCD3(I,J,K)\t\n         INTEGER I,J,K\t\n         INTEGER R\t\n          R = GCD(I,J)\t\t\n          IF (R .GT. 1) R = GCD(R,K)\t\n          GCD3 = R\t\t\n        END FUNCTION GCD3\n\n        REAL*8 FUNCTION HERO(SIDE)\t\nCalculations could proceed with non-integer sides.\n         INTEGER SIDE(3)\t\n         REAL*8 S\t\t\n          S = SUM(SIDE)\t\t\n          S = S/2\t\t\n          S = S*PRODUCT(S - SIDE)\t\n          HERO = SIGN(SQRT(ABS(S)),S)\t\n        END FUNCTION HERO\t\t\n      END MODULE GREEK MATHEMATICIANS\t\n\n      PROGRAM TEST\t\t\n      USE GREEK MATHEMATICIANS\t\n      INTEGER LIMIT,LOTS\t\n      PARAMETER (LIMIT = 200, LOTS = 666)\t\n      INTEGER I,J,K,SIDE(3)\t\n      EQUIVALENCE (SIDE(1),I),(SIDE(2),J),(SIDE(3),K)\t\n      REAL*8 A\t\t\t\n      TYPE ABLOB\t\t\n       INTEGER SIDE(3)\t\t\n       INTEGER PERIMETER\t\n       INTEGER AREA\t\t\n      END TYPE ABLOB\t\t\n      TYPE(ABLOB) STASH(LOTS)\t\n      INTEGER N,XNDX(LOTS)\t\n      INTEGER H,T\t\t\n      LOGICAL CURSE\t\t\n      INTEGER TASTE,CHOICE\t\n      PARAMETER (TASTE = 10, CHOICE = 210)\t\n\nCollect some triangles.\n      N = 0\t\n      DO K = 1,LIMIT\t\n        DO J = 1,K\t\t\n          DO I = 1,J\t\t\t\n            IF (GCD3(I,J,K).GT.1) CYCLE\t\n            A = HERO(SIDE)\t\t\n            IF (A.LE.0) CYCLE\t\t\n            IF (A .NE. INT(A)) CYCLE\t\n            N = N + 1\t\t\t\n            IF (N.GT.LOTS) STOP \"Too many\n            XNDX(N) = N\t\t\t\n            STASH(N).SIDE = SIDE\t\t\n            STASH(N).PERIMETER = SUM(SIDE)\t\n            STASH(N).AREA = A\t\t\t\nc            WRITE (6,10) N,STASH(N)\n   10       FORMAT (I4,\":\",3I4,I7,I8)\t\n          END DO\n        END DO\n      END DO\n      WRITE (6,11) N,LIMIT\t\n   11 FORMAT (I0,\" triangles of integral area. Sides up to \",I0)\n\nComb sort involves coding only one test, and the comparison is to be compound...\n      H = N - 1\t\n   20 H = MAX(1,H*10/13)\t\n      IF (H.EQ.9 .OR. H.EQ.10) H = 11\t\n      CURSE = .FALSE.\t\t\n      DO 24 I = N - H,1,-1\t\n        IF (STASH(XNDX(I)).AREA - STASH(XNDX(I + H)).AREA) 24,21,23 \t\n   21   IF (STASH(XNDX(I)).PERIMETER-STASH(XNDX(I+H)).PERIMETER)24,22,23 \t\n   22   IF (MAXVAL(STASH(XNDX(I)).SIDE)\t\t\t\n     1    - MAXVAL(STASH(XNDX(I+H)).SIDE)) 24,24,23\t\n   23     T=XNDX(I); XNDX(I)=XNDX(I+H); XNDX(I+H)=T\t\n          CURSE = .TRUE.\t\t\t\n   24 CONTINUE\t\t\t\t\n      IF (CURSE .OR. H.GT.1) GO TO 20\t\n\nCast forth the results, as per the specification.\n      WRITE (6,30) TASTE\n   30 FORMAT (\"First \",I0,\", ordered by area, perimeter, longest side.\",\n     1 /,\"Index ---Sides--- Perimeter Area\")\n      DO I = 1,TASTE\n        WRITE (6,10) XNDX(I),STASH(XNDX(I))\n      END DO\n\n      WRITE (6,31) CHOICE\n   31 FORMAT (\"Those triangles with area\",I7)\n      DO I = 1,N\t\n        IF (STASH(XNDX(I)).AREA.NE.CHOICE) CYCLE\n        WRITE (6,10) XNDX(I),STASH(XNDX(I))\t\n      END DO\t\t\n      END\n", "target": "from __future__ import division, print_function\nfrom math import gcd, sqrt\n\n\ndef hero(a, b, c):\n    s = (a + b + c) / 2\n    a2 = s * (s - a) * (s - b) * (s - c)\n    return sqrt(a2) if a2 > 0 else 0\n\n\ndef is_heronian(a, b, c):\n    a = hero(a, b, c)\n    return a > 0 and a.is_integer()\n\n\ndef gcd3(x, y, z):\n    return gcd(gcd(x, y), z)\n\n\nif __name__ == '__main__':\n    MAXSIDE = 200\n\n    N = 1 + MAXSIDE\n    h = [(x, y, z)\n         for x in range(1, N)\n         for y in range(x, N)\n         for z in range(y, N) if (x + y > z) and\n         1 == gcd3(x, y, z) and\n         is_heronian(x, y, z)]\n\n    \n    h.sort(key=lambda x: (hero(*x), sum(x), x[::-1]))\n\n    print(\n        'Primitive Heronian triangles with sides up to %i:' % MAXSIDE, len(h)\n    )\n    print('\\nFirst ten when ordered by increasing area, then perimeter,',\n          'then maximum sides:')\n    print('\\n'.join('  %14r perim: %3i area: %i'\n                    % (sides, sum(sides), hero(*sides)) for sides in h[:10]))\n    print('\\nAll with area 210 subject to the previous ordering:')\n    print('\\n'.join('  %14r perim: %3i area: %i'\n                    % (sides, sum(sides), hero(*sides)) for sides in h\n                    if hero(*sides) == 210))\n"}
{"id": 34901, "name": "Averages_Median", "source": "Translate Fortran to C#: program Median_Test\n\n  real            :: a(7) = (/ 4.1, 5.6, 7.2, 1.7, 9.3, 4.4, 3.2 /), &\n                     b(6) = (/ 4.1, 7.2, 1.7, 9.3, 4.4, 3.2 /)\n\n  print *, median(a)\n  print *, median(b)\n\ncontains\n\n  function median(a, found)\n    real, dimension(:), intent(in) :: a\n      \n      \n      \n    logical, optional, intent(out) :: found\n    real :: median\n\n    integer :: l\n    real, dimension(size(a,1)) :: ac\n\n    if ( size(a,1) < 1 ) then\n       if ( present(found) ) found = .false.\n    else\n       ac = a\n       \n       \n       \n       call sort(ac)\n\n       l = size(a,1)\n       if ( mod(l, 2) == 0 ) then\n          median = (ac(l/2+1) + ac(l/2))/2.0\n       else\n          median = ac(l/2+1)\n       end if\n\n       if ( present(found) ) found = .true.\n    end if\n\n  end function median\n\nend program Median_Test\n", "target": "using System;\nusing System.Linq;\n\nnamespace Test\n{\n    class Program\n    {\n        static void Main()\n        {\n            double[] myArr = new double[] { 1, 5, 3, 6, 4, 2 };\n\n            myArr = myArr.OrderBy(i => i).ToArray();\n            \n\n            int mid = myArr.Length / 2;\n            double median;\n\n            if (myArr.Length % 2 == 0)\n            {\n                \n                median = (myArr[mid] + myArr[mid - 1]) / 2.0;\n            }\n            else\n            {\n                \n                median = myArr[mid];\n            }\n\n            Console.WriteLine(median);\n            Console.ReadLine();\n        }\n    }\n}\n"}
{"id": 34905, "name": "Averages_Median", "source": "Translate Fortran to Java: program Median_Test\n\n  real            :: a(7) = (/ 4.1, 5.6, 7.2, 1.7, 9.3, 4.4, 3.2 /), &\n                     b(6) = (/ 4.1, 7.2, 1.7, 9.3, 4.4, 3.2 /)\n\n  print *, median(a)\n  print *, median(b)\n\ncontains\n\n  function median(a, found)\n    real, dimension(:), intent(in) :: a\n      \n      \n      \n    logical, optional, intent(out) :: found\n    real :: median\n\n    integer :: l\n    real, dimension(size(a,1)) :: ac\n\n    if ( size(a,1) < 1 ) then\n       if ( present(found) ) found = .false.\n    else\n       ac = a\n       \n       \n       \n       call sort(ac)\n\n       l = size(a,1)\n       if ( mod(l, 2) == 0 ) then\n          median = (ac(l/2+1) + ac(l/2))/2.0\n       else\n          median = ac(l/2+1)\n       end if\n\n       if ( present(found) ) found = .true.\n    end if\n\n  end function median\n\nend program Median_Test\n", "target": "\npublic static double median(List<Double> list) {\n    Collections.sort(list);\n    return (list.get(list.size() / 2) + list.get((list.size() - 1) / 2)) / 2;\n}\n"}
{"id": 34906, "name": "Averages_Median", "source": "Translate Fortran to Python: program Median_Test\n\n  real            :: a(7) = (/ 4.1, 5.6, 7.2, 1.7, 9.3, 4.4, 3.2 /), &\n                     b(6) = (/ 4.1, 7.2, 1.7, 9.3, 4.4, 3.2 /)\n\n  print *, median(a)\n  print *, median(b)\n\ncontains\n\n  function median(a, found)\n    real, dimension(:), intent(in) :: a\n      \n      \n      \n    logical, optional, intent(out) :: found\n    real :: median\n\n    integer :: l\n    real, dimension(size(a,1)) :: ac\n\n    if ( size(a,1) < 1 ) then\n       if ( present(found) ) found = .false.\n    else\n       ac = a\n       \n       \n       \n       call sort(ac)\n\n       l = size(a,1)\n       if ( mod(l, 2) == 0 ) then\n          median = (ac(l/2+1) + ac(l/2))/2.0\n       else\n          median = ac(l/2+1)\n       end if\n\n       if ( present(found) ) found = .true.\n    end if\n\n  end function median\n\nend program Median_Test\n", "target": "def median(aray):\n    srtd = sorted(aray)\n    alen = len(srtd)\n    return 0.5*( srtd[(alen-1)//2] + srtd[alen//2])\n\na = (4.1, 5.6, 7.2, 1.7, 9.3, 4.4, 3.2)\nprint a, median(a)\na = (4.1, 7.2, 1.7, 9.3, 4.4, 3.2)\nprint a, median(a)\n"}
{"id": 35104, "name": "Pointers and references", "source": "Translate Fortran to C#: real, pointer :: pointertoreal\n", "target": "static void Main(string[] args)\n{\n\tint p;\n\n\tp = 1;\n\tConsole.WriteLine(\"Ref Before: \" + p);\n\tValue(ref p);\n\tConsole.WriteLine(\"Ref After\u00a0: \" + p);\n\n\tp = 1;\n\tConsole.WriteLine(\"Val Before: \" + p);\n\tValue(p);\n\tConsole.WriteLine(\"Val After\u00a0: \" + p);\n\n\tConsole.ReadLine();\n}\n\nprivate static void Value(ref int Value)\n{\n\tValue += 1;\n}\nprivate static void Value(int Value)\n{\n\tValue += 1;\n}\n"}
{"id": 35105, "name": "Pointers and references", "source": "Translate Fortran to Java: real, pointer :: pointertoreal\n", "target": " public class Foo { public int x = 0; }\n\n void somefunction() {\n     Foo a; \n     a = new Foo(); \n     Foo b = a; \n     a.x = 5; \n     System.out.println(b.x); \n }\n"}
{"id": 35106, "name": "Pointers and references", "source": "Translate Fortran to Python: real, pointer :: pointertoreal\n", "target": " \n a = \"foo\"\n \n b = []\n \n class Foo(object):\n     pass\n c = Foo()\n \n class Bar(object):\n     def __init__(self, initializer = None)\n         \n         if initializer is not None:\n            self.value = initializer\n d = Bar(10)\n print d.value\n \n if a is b: pass\n \n if id(a) == id(b): pass\n \n def a(fmt, *args):\n     if fmt is None:\n         fmt = \"%s\"\n      print fmt % (args)\n \n b.append(a)\n \n del(a)\n \n b[0](\"foo\")  \n              \n"}
{"id": 35310, "name": "Sierpinski triangle", "source": "Translate Fortran to C#: program Sierpinski_triangle\n  implicit none\n  \n  call Triangle(4)\n\ncontains\n\nsubroutine Triangle(n)\n  implicit none\n  integer, parameter :: i64 = selected_int_kind(18)\n  integer, intent(in) :: n\n  integer :: i, k\n  integer(i64) :: c\n  \n  do i = 0, n*4-1\n    c = 1\n    write(*, \"(a)\", advance=\"no\") repeat(\" \", 2 * (n*4 - 1 - i))\n    do k = 0, i\n      if(mod(c, 2) == 0) then\n        write(*, \"(a)\", advance=\"no\") \"    \"\n      else\n        write(*, \"(a)\", advance=\"no\") \"  * \"\n      end if\n      c = c * (i - k) / (k + 1)\n    end do\n    write(*,*)\n  end do\nend subroutine Triangle\nend program Sierpinski_triangle\n", "target": "using System;\nusing System.Collections;\n\nnamespace RosettaCode {\n    class SierpinskiTriangle {\n        int len;\n        BitArray b;\n\n        public SierpinskiTriangle(int n) {\n            if (n < 1) {\n                throw new ArgumentOutOfRangeException(\"Order must be greater than zero\");\n            }\n            len = 1 << (n+1);\n            b = new BitArray(len+1, false);\n            b[len>>1] = true;\n        }\n\n        public void Display() {\n            for (int j = 0; j < len / 2; j++) {\n                for (int i = 0; i < b.Count; i++) {\n                    Console.Write(\"{0}\", b[i] ? \"*\" : \" \");\n                }\n                Console.WriteLine();\n                NextGen();\n            }\n        }\n\n        private void NextGen() {\n            BitArray next = new BitArray(b.Count, false);\n            for (int i = 0; i < b.Count; i++) {\n                if (b[i]) {\n                    next[i - 1] = next[i - 1] ^ true;\n                    next[i + 1] = next[i + 1] ^ true;\n                }\n            }\n            b = next;\n        }\n    }\n}\n"}
{"id": 35313, "name": "Sierpinski triangle", "source": "Translate Fortran to Java: program Sierpinski_triangle\n  implicit none\n  \n  call Triangle(4)\n\ncontains\n\nsubroutine Triangle(n)\n  implicit none\n  integer, parameter :: i64 = selected_int_kind(18)\n  integer, intent(in) :: n\n  integer :: i, k\n  integer(i64) :: c\n  \n  do i = 0, n*4-1\n    c = 1\n    write(*, \"(a)\", advance=\"no\") repeat(\" \", 2 * (n*4 - 1 - i))\n    do k = 0, i\n      if(mod(c, 2) == 0) then\n        write(*, \"(a)\", advance=\"no\") \"    \"\n      else\n        write(*, \"(a)\", advance=\"no\") \"  * \"\n      end if\n      c = c * (i - k) / (k + 1)\n    end do\n    write(*,*)\n  end do\nend subroutine Triangle\nend program Sierpinski_triangle\n", "target": "public class SierpinskiTriangle {\n\n    public static void main(String[] args) {\n        System.out.println(getSierpinskiTriangle(4));\n    }\n    \n    private static final String getSierpinskiTriangle(int n) {\n        if ( n == 0 ) {\n            return \"*\";\n        }\n\n        String s = getSierpinskiTriangle(n-1);\n        String [] split = s.split(\"\\n\");\n        int length = split.length;\n\n        \n        StringBuilder sb = new StringBuilder();\n        String top = buildSpace((int)Math.pow(2, n-1));\n        for ( int i = 0 ; i < length ;i++ ) {\n            sb.append(top);\n            sb.append(split[i]);\n            sb.append(\"\\n\");\n        }\n        \n        \n        for ( int i = 0 ; i < length ;i++ ) {\n            sb.append(split[i]);\n            sb.append(buildSpace(length-i));\n            sb.append(split[i]);\n            sb.append(\"\\n\");\n        }\n        return sb.toString();\n    }\n    \n    private static String buildSpace(int n) {\n        StringBuilder sb = new StringBuilder();\n        while ( n > 0 ) {\n            sb.append(\" \");\n            n--;\n        }\n        return sb.toString();\n    }\n    \n}\n"}
{"id": 35314, "name": "Sierpinski triangle", "source": "Translate Fortran to Python: program Sierpinski_triangle\n  implicit none\n  \n  call Triangle(4)\n\ncontains\n\nsubroutine Triangle(n)\n  implicit none\n  integer, parameter :: i64 = selected_int_kind(18)\n  integer, intent(in) :: n\n  integer :: i, k\n  integer(i64) :: c\n  \n  do i = 0, n*4-1\n    c = 1\n    write(*, \"(a)\", advance=\"no\") repeat(\" \", 2 * (n*4 - 1 - i))\n    do k = 0, i\n      if(mod(c, 2) == 0) then\n        write(*, \"(a)\", advance=\"no\") \"    \"\n      else\n        write(*, \"(a)\", advance=\"no\") \"  * \"\n      end if\n      c = c * (i - k) / (k + 1)\n    end do\n    write(*,*)\n  end do\nend subroutine Triangle\nend program Sierpinski_triangle\n", "target": "def sierpinski(n):\n    d = [\"*\"]\n    for i in xrange(n):\n        sp = \" \" * (2 ** i)\n        d = [sp+x+sp for x in d] + [x+\" \"+x for x in d]\n    return d\n\nprint \"\\n\".join(sierpinski(4))\n"}
{"id": 35631, "name": "Globally replace text in several files", "source": "Translate Fortran to C#:       SUBROUTINE FILEHACK(FNAME,THIS,THAT)\t\n       CHARACTER*(*) FNAME\t\n       CHARACTER*(*) THIS\t\n       CHARACTER*(*) THAT\t\n       INTEGER F,T\t\t\n       PARAMETER (F=66,T=67)\t\n       INTEGER L\t\t\n       CHARACTER*6666 ALINE\t\n       LOGICAL AHIT\t\t\n        INQUIRE(FILE = FNAME, EXIST = AHIT)\t\n        IF (.NOT.AHIT) RETURN\t\t\t\n        OPEN (F,FILE=FNAME,STATUS=\"OLD\",ACTION=\"READWRITE\")\t\n        OPEN (T,STATUS=\"SCRATCH\")\t\n        AHIT = .FALSE.\t\t\nChew through the input, replacing THIS by THAT while writing to the temporary file..\n   10   READ (F,11,END = 20) L,ALINE(1:MIN(L,LEN(ALINE)))\t\n        IF (L.GT.LEN(ALINE)) STOP \"Monster record\n   11   FORMAT (Q,A)\t\t\n        L1 = 1\t\t\t\n   12   L2 = INDEX(ALINE(L1:L),THIS)\t\n        IF (L2.LE.0) THEN\t\t\n          WRITE (T,13) ALINE(L1:L)\t\n   13     FORMAT (A)\t\t\t\n          GO TO 10\t\t\t\n        END IF\t\t\t\t\n   14   L2 = L1 + L2 - 2\t\n        WRITE (T,15) ALINE(L1:L2)\t\n   15   FORMAT (A,$)\t\t\t\n        WRITE (T,15) THAT\t\t\n        AHIT = .TRUE.\t\t\t\n        L1 = L2 + LEN(THIS) + 1\t\t\n        IF (L - L1 + 1 .GE. LEN(THIS)) GO TO 12\t\n        WRITE (T,13) ALINE(L1:L)\t\n        GO TO 10\t\t\nCopy the temporary file back over the source file. Hope for no mishap and data loss\n   20   IF (AHIT) THEN\t\n          CLOSE (F)\t\t\n          REWIND T\t\t\n          OPEN (F,FILE=\"new\"//FNAME,STATUS = \"REPLACE\",ACTION = \"WRITE\")\t\n   21     READ (T,11,END = 22) L,ALINE(1:MIN(L,LEN(ALINE)))\t\n          IF (L.GT.LEN(ALINE)) STOP \"Monster changed record\n          WRITE (F,13) ALINE(1:L) \t\t\n          GO TO 21\t\t\t\n        END IF\t\t\n   22   CLOSE(T)\t\n        CLOSE(F)\t\n      END\t\n\n      PROGRAM ATTACK\n      INTEGER N\n      PARAMETER (N = 6)\t\t\n      CHARACTER*48 VICTIM(N)\t\n      DATA VICTIM/\t\t\n     1 \"StaffStory.txt\",\n     2 \"Accounts.dat\",\n     3 \"TravelAgent.txt\",\n     4 \"RemovalFirm.dat\",\n     5 \"Addresses.txt\",\n     6 \"SongLyrics.txt\"/\t\n\n      DO I = 1,N\t\n        CALL FILEHACK(VICTIM(I),\"Goodbye London\n      END DO\t\t\n\n      END\n", "target": "using System.Collections.Generic;\nusing System.IO;\n\nclass Program {\n    static void Main() {\n        var files = new List<string> {\n            \"test1.txt\",\n            \"test2.txt\"\n        };\n        foreach (string file in files) {\n            File.WriteAllText(file, File.ReadAllText(file).Replace(\"Goodbye London!\", \"Hello New York!\"));\n        }\n    }\n}\n"}
{"id": 35632, "name": "Globally replace text in several files", "source": "Translate Fortran to C#:       SUBROUTINE FILEHACK(FNAME,THIS,THAT)\t\n       CHARACTER*(*) FNAME\t\n       CHARACTER*(*) THIS\t\n       CHARACTER*(*) THAT\t\n       INTEGER F,T\t\t\n       PARAMETER (F=66,T=67)\t\n       INTEGER L\t\t\n       CHARACTER*6666 ALINE\t\n       LOGICAL AHIT\t\t\n        INQUIRE(FILE = FNAME, EXIST = AHIT)\t\n        IF (.NOT.AHIT) RETURN\t\t\t\n        OPEN (F,FILE=FNAME,STATUS=\"OLD\",ACTION=\"READWRITE\")\t\n        OPEN (T,STATUS=\"SCRATCH\")\t\n        AHIT = .FALSE.\t\t\nChew through the input, replacing THIS by THAT while writing to the temporary file..\n   10   READ (F,11,END = 20) L,ALINE(1:MIN(L,LEN(ALINE)))\t\n        IF (L.GT.LEN(ALINE)) STOP \"Monster record\n   11   FORMAT (Q,A)\t\t\n        L1 = 1\t\t\t\n   12   L2 = INDEX(ALINE(L1:L),THIS)\t\n        IF (L2.LE.0) THEN\t\t\n          WRITE (T,13) ALINE(L1:L)\t\n   13     FORMAT (A)\t\t\t\n          GO TO 10\t\t\t\n        END IF\t\t\t\t\n   14   L2 = L1 + L2 - 2\t\n        WRITE (T,15) ALINE(L1:L2)\t\n   15   FORMAT (A,$)\t\t\t\n        WRITE (T,15) THAT\t\t\n        AHIT = .TRUE.\t\t\t\n        L1 = L2 + LEN(THIS) + 1\t\t\n        IF (L - L1 + 1 .GE. LEN(THIS)) GO TO 12\t\n        WRITE (T,13) ALINE(L1:L)\t\n        GO TO 10\t\t\nCopy the temporary file back over the source file. Hope for no mishap and data loss\n   20   IF (AHIT) THEN\t\n          CLOSE (F)\t\t\n          REWIND T\t\t\n          OPEN (F,FILE=\"new\"//FNAME,STATUS = \"REPLACE\",ACTION = \"WRITE\")\t\n   21     READ (T,11,END = 22) L,ALINE(1:MIN(L,LEN(ALINE)))\t\n          IF (L.GT.LEN(ALINE)) STOP \"Monster changed record\n          WRITE (F,13) ALINE(1:L) \t\t\n          GO TO 21\t\t\t\n        END IF\t\t\n   22   CLOSE(T)\t\n        CLOSE(F)\t\n      END\t\n\n      PROGRAM ATTACK\n      INTEGER N\n      PARAMETER (N = 6)\t\t\n      CHARACTER*48 VICTIM(N)\t\n      DATA VICTIM/\t\t\n     1 \"StaffStory.txt\",\n     2 \"Accounts.dat\",\n     3 \"TravelAgent.txt\",\n     4 \"RemovalFirm.dat\",\n     5 \"Addresses.txt\",\n     6 \"SongLyrics.txt\"/\t\n\n      DO I = 1,N\t\n        CALL FILEHACK(VICTIM(I),\"Goodbye London\n      END DO\t\t\n\n      END\n", "target": "using System.Collections.Generic;\nusing System.IO;\n\nclass Program {\n    static void Main() {\n        var files = new List<string> {\n            \"test1.txt\",\n            \"test2.txt\"\n        };\n        foreach (string file in files) {\n            File.WriteAllText(file, File.ReadAllText(file).Replace(\"Goodbye London!\", \"Hello New York!\"));\n        }\n    }\n}\n"}
{"id": 35637, "name": "Globally replace text in several files", "source": "Translate Fortran to Java:       SUBROUTINE FILEHACK(FNAME,THIS,THAT)\t\n       CHARACTER*(*) FNAME\t\n       CHARACTER*(*) THIS\t\n       CHARACTER*(*) THAT\t\n       INTEGER F,T\t\t\n       PARAMETER (F=66,T=67)\t\n       INTEGER L\t\t\n       CHARACTER*6666 ALINE\t\n       LOGICAL AHIT\t\t\n        INQUIRE(FILE = FNAME, EXIST = AHIT)\t\n        IF (.NOT.AHIT) RETURN\t\t\t\n        OPEN (F,FILE=FNAME,STATUS=\"OLD\",ACTION=\"READWRITE\")\t\n        OPEN (T,STATUS=\"SCRATCH\")\t\n        AHIT = .FALSE.\t\t\nChew through the input, replacing THIS by THAT while writing to the temporary file..\n   10   READ (F,11,END = 20) L,ALINE(1:MIN(L,LEN(ALINE)))\t\n        IF (L.GT.LEN(ALINE)) STOP \"Monster record\n   11   FORMAT (Q,A)\t\t\n        L1 = 1\t\t\t\n   12   L2 = INDEX(ALINE(L1:L),THIS)\t\n        IF (L2.LE.0) THEN\t\t\n          WRITE (T,13) ALINE(L1:L)\t\n   13     FORMAT (A)\t\t\t\n          GO TO 10\t\t\t\n        END IF\t\t\t\t\n   14   L2 = L1 + L2 - 2\t\n        WRITE (T,15) ALINE(L1:L2)\t\n   15   FORMAT (A,$)\t\t\t\n        WRITE (T,15) THAT\t\t\n        AHIT = .TRUE.\t\t\t\n        L1 = L2 + LEN(THIS) + 1\t\t\n        IF (L - L1 + 1 .GE. LEN(THIS)) GO TO 12\t\n        WRITE (T,13) ALINE(L1:L)\t\n        GO TO 10\t\t\nCopy the temporary file back over the source file. Hope for no mishap and data loss\n   20   IF (AHIT) THEN\t\n          CLOSE (F)\t\t\n          REWIND T\t\t\n          OPEN (F,FILE=\"new\"//FNAME,STATUS = \"REPLACE\",ACTION = \"WRITE\")\t\n   21     READ (T,11,END = 22) L,ALINE(1:MIN(L,LEN(ALINE)))\t\n          IF (L.GT.LEN(ALINE)) STOP \"Monster changed record\n          WRITE (F,13) ALINE(1:L) \t\t\n          GO TO 21\t\t\t\n        END IF\t\t\n   22   CLOSE(T)\t\n        CLOSE(F)\t\n      END\t\n\n      PROGRAM ATTACK\n      INTEGER N\n      PARAMETER (N = 6)\t\t\n      CHARACTER*48 VICTIM(N)\t\n      DATA VICTIM/\t\t\n     1 \"StaffStory.txt\",\n     2 \"Accounts.dat\",\n     3 \"TravelAgent.txt\",\n     4 \"RemovalFirm.dat\",\n     5 \"Addresses.txt\",\n     6 \"SongLyrics.txt\"/\t\n\n      DO I = 1,N\t\n        CALL FILEHACK(VICTIM(I),\"Goodbye London\n      END DO\t\t\n\n      END\n", "target": "import java.io.*;\nimport java.nio.file.*;\n\npublic class GloballyReplaceText {\n\n    public static void main(String[] args) throws IOException {\n\n        for (String fn : new String[]{\"test1.txt\", \"test2.txt\"}) {\n            String s = new String(Files.readAllBytes(Paths.get(fn)));\n            s = s.replace(\"Goodbye London!\", \"Hello New York!\");\n            try (FileWriter fw = new FileWriter(fn)) {\n                fw.write(s);\n            }\n        }\n    }\n}\n"}
{"id": 35638, "name": "Globally replace text in several files", "source": "Translate Fortran to Java:       SUBROUTINE FILEHACK(FNAME,THIS,THAT)\t\n       CHARACTER*(*) FNAME\t\n       CHARACTER*(*) THIS\t\n       CHARACTER*(*) THAT\t\n       INTEGER F,T\t\t\n       PARAMETER (F=66,T=67)\t\n       INTEGER L\t\t\n       CHARACTER*6666 ALINE\t\n       LOGICAL AHIT\t\t\n        INQUIRE(FILE = FNAME, EXIST = AHIT)\t\n        IF (.NOT.AHIT) RETURN\t\t\t\n        OPEN (F,FILE=FNAME,STATUS=\"OLD\",ACTION=\"READWRITE\")\t\n        OPEN (T,STATUS=\"SCRATCH\")\t\n        AHIT = .FALSE.\t\t\nChew through the input, replacing THIS by THAT while writing to the temporary file..\n   10   READ (F,11,END = 20) L,ALINE(1:MIN(L,LEN(ALINE)))\t\n        IF (L.GT.LEN(ALINE)) STOP \"Monster record\n   11   FORMAT (Q,A)\t\t\n        L1 = 1\t\t\t\n   12   L2 = INDEX(ALINE(L1:L),THIS)\t\n        IF (L2.LE.0) THEN\t\t\n          WRITE (T,13) ALINE(L1:L)\t\n   13     FORMAT (A)\t\t\t\n          GO TO 10\t\t\t\n        END IF\t\t\t\t\n   14   L2 = L1 + L2 - 2\t\n        WRITE (T,15) ALINE(L1:L2)\t\n   15   FORMAT (A,$)\t\t\t\n        WRITE (T,15) THAT\t\t\n        AHIT = .TRUE.\t\t\t\n        L1 = L2 + LEN(THIS) + 1\t\t\n        IF (L - L1 + 1 .GE. LEN(THIS)) GO TO 12\t\n        WRITE (T,13) ALINE(L1:L)\t\n        GO TO 10\t\t\nCopy the temporary file back over the source file. Hope for no mishap and data loss\n   20   IF (AHIT) THEN\t\n          CLOSE (F)\t\t\n          REWIND T\t\t\n          OPEN (F,FILE=\"new\"//FNAME,STATUS = \"REPLACE\",ACTION = \"WRITE\")\t\n   21     READ (T,11,END = 22) L,ALINE(1:MIN(L,LEN(ALINE)))\t\n          IF (L.GT.LEN(ALINE)) STOP \"Monster changed record\n          WRITE (F,13) ALINE(1:L) \t\t\n          GO TO 21\t\t\t\n        END IF\t\t\n   22   CLOSE(T)\t\n        CLOSE(F)\t\n      END\t\n\n      PROGRAM ATTACK\n      INTEGER N\n      PARAMETER (N = 6)\t\t\n      CHARACTER*48 VICTIM(N)\t\n      DATA VICTIM/\t\t\n     1 \"StaffStory.txt\",\n     2 \"Accounts.dat\",\n     3 \"TravelAgent.txt\",\n     4 \"RemovalFirm.dat\",\n     5 \"Addresses.txt\",\n     6 \"SongLyrics.txt\"/\t\n\n      DO I = 1,N\t\n        CALL FILEHACK(VICTIM(I),\"Goodbye London\n      END DO\t\t\n\n      END\n", "target": "import java.io.*;\nimport java.nio.file.*;\n\npublic class GloballyReplaceText {\n\n    public static void main(String[] args) throws IOException {\n\n        for (String fn : new String[]{\"test1.txt\", \"test2.txt\"}) {\n            String s = new String(Files.readAllBytes(Paths.get(fn)));\n            s = s.replace(\"Goodbye London!\", \"Hello New York!\");\n            try (FileWriter fw = new FileWriter(fn)) {\n                fw.write(s);\n            }\n        }\n    }\n}\n"}
{"id": 35639, "name": "Globally replace text in several files", "source": "Translate Fortran to Python:       SUBROUTINE FILEHACK(FNAME,THIS,THAT)\t\n       CHARACTER*(*) FNAME\t\n       CHARACTER*(*) THIS\t\n       CHARACTER*(*) THAT\t\n       INTEGER F,T\t\t\n       PARAMETER (F=66,T=67)\t\n       INTEGER L\t\t\n       CHARACTER*6666 ALINE\t\n       LOGICAL AHIT\t\t\n        INQUIRE(FILE = FNAME, EXIST = AHIT)\t\n        IF (.NOT.AHIT) RETURN\t\t\t\n        OPEN (F,FILE=FNAME,STATUS=\"OLD\",ACTION=\"READWRITE\")\t\n        OPEN (T,STATUS=\"SCRATCH\")\t\n        AHIT = .FALSE.\t\t\nChew through the input, replacing THIS by THAT while writing to the temporary file..\n   10   READ (F,11,END = 20) L,ALINE(1:MIN(L,LEN(ALINE)))\t\n        IF (L.GT.LEN(ALINE)) STOP \"Monster record\n   11   FORMAT (Q,A)\t\t\n        L1 = 1\t\t\t\n   12   L2 = INDEX(ALINE(L1:L),THIS)\t\n        IF (L2.LE.0) THEN\t\t\n          WRITE (T,13) ALINE(L1:L)\t\n   13     FORMAT (A)\t\t\t\n          GO TO 10\t\t\t\n        END IF\t\t\t\t\n   14   L2 = L1 + L2 - 2\t\n        WRITE (T,15) ALINE(L1:L2)\t\n   15   FORMAT (A,$)\t\t\t\n        WRITE (T,15) THAT\t\t\n        AHIT = .TRUE.\t\t\t\n        L1 = L2 + LEN(THIS) + 1\t\t\n        IF (L - L1 + 1 .GE. LEN(THIS)) GO TO 12\t\n        WRITE (T,13) ALINE(L1:L)\t\n        GO TO 10\t\t\nCopy the temporary file back over the source file. Hope for no mishap and data loss\n   20   IF (AHIT) THEN\t\n          CLOSE (F)\t\t\n          REWIND T\t\t\n          OPEN (F,FILE=\"new\"//FNAME,STATUS = \"REPLACE\",ACTION = \"WRITE\")\t\n   21     READ (T,11,END = 22) L,ALINE(1:MIN(L,LEN(ALINE)))\t\n          IF (L.GT.LEN(ALINE)) STOP \"Monster changed record\n          WRITE (F,13) ALINE(1:L) \t\t\n          GO TO 21\t\t\t\n        END IF\t\t\n   22   CLOSE(T)\t\n        CLOSE(F)\t\n      END\t\n\n      PROGRAM ATTACK\n      INTEGER N\n      PARAMETER (N = 6)\t\t\n      CHARACTER*48 VICTIM(N)\t\n      DATA VICTIM/\t\t\n     1 \"StaffStory.txt\",\n     2 \"Accounts.dat\",\n     3 \"TravelAgent.txt\",\n     4 \"RemovalFirm.dat\",\n     5 \"Addresses.txt\",\n     6 \"SongLyrics.txt\"/\t\n\n      DO I = 1,N\t\n        CALL FILEHACK(VICTIM(I),\"Goodbye London\n      END DO\t\t\n\n      END\n", "target": "import fileinput\n\nfor line in fileinput.input(inplace=True):\n    print(line.replace('Goodbye London!', 'Hello New York!'), end='')\n"}
{"id": 35640, "name": "Globally replace text in several files", "source": "Translate Fortran to Python:       SUBROUTINE FILEHACK(FNAME,THIS,THAT)\t\n       CHARACTER*(*) FNAME\t\n       CHARACTER*(*) THIS\t\n       CHARACTER*(*) THAT\t\n       INTEGER F,T\t\t\n       PARAMETER (F=66,T=67)\t\n       INTEGER L\t\t\n       CHARACTER*6666 ALINE\t\n       LOGICAL AHIT\t\t\n        INQUIRE(FILE = FNAME, EXIST = AHIT)\t\n        IF (.NOT.AHIT) RETURN\t\t\t\n        OPEN (F,FILE=FNAME,STATUS=\"OLD\",ACTION=\"READWRITE\")\t\n        OPEN (T,STATUS=\"SCRATCH\")\t\n        AHIT = .FALSE.\t\t\nChew through the input, replacing THIS by THAT while writing to the temporary file..\n   10   READ (F,11,END = 20) L,ALINE(1:MIN(L,LEN(ALINE)))\t\n        IF (L.GT.LEN(ALINE)) STOP \"Monster record\n   11   FORMAT (Q,A)\t\t\n        L1 = 1\t\t\t\n   12   L2 = INDEX(ALINE(L1:L),THIS)\t\n        IF (L2.LE.0) THEN\t\t\n          WRITE (T,13) ALINE(L1:L)\t\n   13     FORMAT (A)\t\t\t\n          GO TO 10\t\t\t\n        END IF\t\t\t\t\n   14   L2 = L1 + L2 - 2\t\n        WRITE (T,15) ALINE(L1:L2)\t\n   15   FORMAT (A,$)\t\t\t\n        WRITE (T,15) THAT\t\t\n        AHIT = .TRUE.\t\t\t\n        L1 = L2 + LEN(THIS) + 1\t\t\n        IF (L - L1 + 1 .GE. LEN(THIS)) GO TO 12\t\n        WRITE (T,13) ALINE(L1:L)\t\n        GO TO 10\t\t\nCopy the temporary file back over the source file. Hope for no mishap and data loss\n   20   IF (AHIT) THEN\t\n          CLOSE (F)\t\t\n          REWIND T\t\t\n          OPEN (F,FILE=\"new\"//FNAME,STATUS = \"REPLACE\",ACTION = \"WRITE\")\t\n   21     READ (T,11,END = 22) L,ALINE(1:MIN(L,LEN(ALINE)))\t\n          IF (L.GT.LEN(ALINE)) STOP \"Monster changed record\n          WRITE (F,13) ALINE(1:L) \t\t\n          GO TO 21\t\t\t\n        END IF\t\t\n   22   CLOSE(T)\t\n        CLOSE(F)\t\n      END\t\n\n      PROGRAM ATTACK\n      INTEGER N\n      PARAMETER (N = 6)\t\t\n      CHARACTER*48 VICTIM(N)\t\n      DATA VICTIM/\t\t\n     1 \"StaffStory.txt\",\n     2 \"Accounts.dat\",\n     3 \"TravelAgent.txt\",\n     4 \"RemovalFirm.dat\",\n     5 \"Addresses.txt\",\n     6 \"SongLyrics.txt\"/\t\n\n      DO I = 1,N\t\n        CALL FILEHACK(VICTIM(I),\"Goodbye London\n      END DO\t\t\n\n      END\n", "target": "import fileinput\n\nfor line in fileinput.input(inplace=True):\n    print(line.replace('Goodbye London!', 'Hello New York!'), end='')\n"}
{"id": 35974, "name": "Continued fraction", "source": "Translate Fortran to C#: module continued_fractions\n  implicit none\n  \n  integer, parameter :: long = selected_real_kind(7,99)\n\n  type continued_fraction\n    integer                            :: a0, b1\n    procedure(series), pointer, nopass :: a, b\n  end type\n\n  interface\n    pure function series (n)\n      integer, intent(in) :: n\n      integer             :: series\n    end function\n  end interface\n\ncontains\n\n  pure function define_cf (a0,a,b1,b) result(x)\n    integer, intent(in)           :: a0\n    procedure(series)             :: a\n    integer, intent(in), optional :: b1\n    procedure(series),   optional :: b\n    type(continued_fraction)      :: x\n    x%a0 = a0\n    x%a => a\n    if ( present(b1) ) then\n       x%b1 = b1\n    else\n       x%b1 = 1\n    end if\n    if ( present(b) ) then\n       x%b => b\n    else\n       x%b => const_1\n    end if\n  end function define_cf\n\n  pure integer function const_1(n)\n    integer,intent(in) :: n\n    const_1 = 1  \n  end function\n\n  pure real(kind=long) function output(x,iterations)\n    type(continued_fraction), intent(in) :: x\n    integer,                  intent(in) :: iterations\n    integer                              :: i\n    output = x%a(iterations)\n    do i = iterations-1,1,-1\n      output = x%a(i) + (x%b(i+1) / output)\n    end do\n    output = x%a0 + (x%b1 / output)\n  end function output\n  \nend module continued_fractions\n\n\nprogram examples\n  use continued_fractions\n\n  type(continued_fraction) :: sqr2,napier,pi\n\n  sqr2   = define_cf(1,a_sqr2)\n  napier = define_cf(2,a_napier,1,b_napier)\n  pi     = define_cf(3,a=a_pi,b=b_pi)\n\n  write (*,*) output(sqr2,10000)\n  write (*,*) output(napier,10000)\n  write (*,*) output(pi,10000)\n\ncontains\n\n  pure integer function a_sqr2(n)\n    integer,intent(in) :: n\n    a_sqr2 = 2\n  end function\n\n  pure integer function a_napier(n)\n    integer,intent(in) :: n\n    a_napier = n\n  end function\n\n  pure integer function b_napier(n)\n    integer,intent(in) :: n\n    b_napier = n-1\n  end function\n\n  pure integer function a_pi(n)\n    integer,intent(in) :: n\n    a_pi = 6\n  end function\n\n  pure integer function b_pi(n)\n    integer,intent(in) :: n\n    b_pi = (2*n-1)*(2*n-1)\n  end function\n\nend program examples\n", "target": "using System;\nusing System.Collections.Generic;\n\nnamespace ContinuedFraction {\n    class Program {\n        static double Calc(Func<int, int[]> f, int n) {\n            double temp = 0.0;\n            for (int ni = n; ni >= 1; ni--) {\n                int[] p = f(ni);\n                temp = p[1] / (p[0] + temp);\n            }\n            return f(0)[0] + temp;\n        }\n\n        static void Main(string[] args) {\n            List<Func<int, int[]>> fList = new List<Func<int, int[]>>();\n            fList.Add(n => new int[] { n > 0 ? 2 : 1, 1 });\n            fList.Add(n => new int[] { n > 0 ? n : 2, n > 1 ? (n - 1) : 1 });\n            fList.Add(n => new int[] { n > 0 ? 6 : 3, (int) Math.Pow(2 * n - 1, 2) });\n\n            foreach (var f in fList) {\n                Console.WriteLine(Calc(f, 200));\n            }\n        }\n    }\n}\n"}
{"id": 35975, "name": "Continued fraction", "source": "Translate Fortran to C#: module continued_fractions\n  implicit none\n  \n  integer, parameter :: long = selected_real_kind(7,99)\n\n  type continued_fraction\n    integer                            :: a0, b1\n    procedure(series), pointer, nopass :: a, b\n  end type\n\n  interface\n    pure function series (n)\n      integer, intent(in) :: n\n      integer             :: series\n    end function\n  end interface\n\ncontains\n\n  pure function define_cf (a0,a,b1,b) result(x)\n    integer, intent(in)           :: a0\n    procedure(series)             :: a\n    integer, intent(in), optional :: b1\n    procedure(series),   optional :: b\n    type(continued_fraction)      :: x\n    x%a0 = a0\n    x%a => a\n    if ( present(b1) ) then\n       x%b1 = b1\n    else\n       x%b1 = 1\n    end if\n    if ( present(b) ) then\n       x%b => b\n    else\n       x%b => const_1\n    end if\n  end function define_cf\n\n  pure integer function const_1(n)\n    integer,intent(in) :: n\n    const_1 = 1  \n  end function\n\n  pure real(kind=long) function output(x,iterations)\n    type(continued_fraction), intent(in) :: x\n    integer,                  intent(in) :: iterations\n    integer                              :: i\n    output = x%a(iterations)\n    do i = iterations-1,1,-1\n      output = x%a(i) + (x%b(i+1) / output)\n    end do\n    output = x%a0 + (x%b1 / output)\n  end function output\n  \nend module continued_fractions\n\n\nprogram examples\n  use continued_fractions\n\n  type(continued_fraction) :: sqr2,napier,pi\n\n  sqr2   = define_cf(1,a_sqr2)\n  napier = define_cf(2,a_napier,1,b_napier)\n  pi     = define_cf(3,a=a_pi,b=b_pi)\n\n  write (*,*) output(sqr2,10000)\n  write (*,*) output(napier,10000)\n  write (*,*) output(pi,10000)\n\ncontains\n\n  pure integer function a_sqr2(n)\n    integer,intent(in) :: n\n    a_sqr2 = 2\n  end function\n\n  pure integer function a_napier(n)\n    integer,intent(in) :: n\n    a_napier = n\n  end function\n\n  pure integer function b_napier(n)\n    integer,intent(in) :: n\n    b_napier = n-1\n  end function\n\n  pure integer function a_pi(n)\n    integer,intent(in) :: n\n    a_pi = 6\n  end function\n\n  pure integer function b_pi(n)\n    integer,intent(in) :: n\n    b_pi = (2*n-1)*(2*n-1)\n  end function\n\nend program examples\n", "target": "using System;\nusing System.Collections.Generic;\n\nnamespace ContinuedFraction {\n    class Program {\n        static double Calc(Func<int, int[]> f, int n) {\n            double temp = 0.0;\n            for (int ni = n; ni >= 1; ni--) {\n                int[] p = f(ni);\n                temp = p[1] / (p[0] + temp);\n            }\n            return f(0)[0] + temp;\n        }\n\n        static void Main(string[] args) {\n            List<Func<int, int[]>> fList = new List<Func<int, int[]>>();\n            fList.Add(n => new int[] { n > 0 ? 2 : 1, 1 });\n            fList.Add(n => new int[] { n > 0 ? n : 2, n > 1 ? (n - 1) : 1 });\n            fList.Add(n => new int[] { n > 0 ? 6 : 3, (int) Math.Pow(2 * n - 1, 2) });\n\n            foreach (var f in fList) {\n                Console.WriteLine(Calc(f, 200));\n            }\n        }\n    }\n}\n"}
{"id": 35981, "name": "Continued fraction", "source": "Translate Fortran to Java: module continued_fractions\n  implicit none\n  \n  integer, parameter :: long = selected_real_kind(7,99)\n\n  type continued_fraction\n    integer                            :: a0, b1\n    procedure(series), pointer, nopass :: a, b\n  end type\n\n  interface\n    pure function series (n)\n      integer, intent(in) :: n\n      integer             :: series\n    end function\n  end interface\n\ncontains\n\n  pure function define_cf (a0,a,b1,b) result(x)\n    integer, intent(in)           :: a0\n    procedure(series)             :: a\n    integer, intent(in), optional :: b1\n    procedure(series),   optional :: b\n    type(continued_fraction)      :: x\n    x%a0 = a0\n    x%a => a\n    if ( present(b1) ) then\n       x%b1 = b1\n    else\n       x%b1 = 1\n    end if\n    if ( present(b) ) then\n       x%b => b\n    else\n       x%b => const_1\n    end if\n  end function define_cf\n\n  pure integer function const_1(n)\n    integer,intent(in) :: n\n    const_1 = 1  \n  end function\n\n  pure real(kind=long) function output(x,iterations)\n    type(continued_fraction), intent(in) :: x\n    integer,                  intent(in) :: iterations\n    integer                              :: i\n    output = x%a(iterations)\n    do i = iterations-1,1,-1\n      output = x%a(i) + (x%b(i+1) / output)\n    end do\n    output = x%a0 + (x%b1 / output)\n  end function output\n  \nend module continued_fractions\n\n\nprogram examples\n  use continued_fractions\n\n  type(continued_fraction) :: sqr2,napier,pi\n\n  sqr2   = define_cf(1,a_sqr2)\n  napier = define_cf(2,a_napier,1,b_napier)\n  pi     = define_cf(3,a=a_pi,b=b_pi)\n\n  write (*,*) output(sqr2,10000)\n  write (*,*) output(napier,10000)\n  write (*,*) output(pi,10000)\n\ncontains\n\n  pure integer function a_sqr2(n)\n    integer,intent(in) :: n\n    a_sqr2 = 2\n  end function\n\n  pure integer function a_napier(n)\n    integer,intent(in) :: n\n    a_napier = n\n  end function\n\n  pure integer function b_napier(n)\n    integer,intent(in) :: n\n    b_napier = n-1\n  end function\n\n  pure integer function a_pi(n)\n    integer,intent(in) :: n\n    a_pi = 6\n  end function\n\n  pure integer function b_pi(n)\n    integer,intent(in) :: n\n    b_pi = (2*n-1)*(2*n-1)\n  end function\n\nend program examples\n", "target": "import static java.lang.Math.pow;\nimport java.util.*;\nimport java.util.function.Function;\n\npublic class Test {\n    static double calc(Function<Integer, Integer[]> f, int n) {\n        double temp = 0;\n\n        for (int ni = n; ni >= 1; ni--) {\n            Integer[] p = f.apply(ni);\n            temp = p[1] / (double) (p[0] + temp);\n        }\n        return f.apply(0)[0] + temp;\n    }\n\n    public static void main(String[] args) {\n        List<Function<Integer, Integer[]>> fList = new ArrayList<>();\n        fList.add(n -> new Integer[]{n > 0 ? 2 : 1, 1});\n        fList.add(n -> new Integer[]{n > 0 ? n : 2, n > 1 ? (n - 1) : 1});\n        fList.add(n -> new Integer[]{n > 0 ? 6 : 3, (int) pow(2 * n - 1, 2)});\n\n        for (Function<Integer, Integer[]> f : fList)\n            System.out.println(calc(f, 200));\n    }\n}\n"}
{"id": 35982, "name": "Continued fraction", "source": "Translate Fortran to Java: module continued_fractions\n  implicit none\n  \n  integer, parameter :: long = selected_real_kind(7,99)\n\n  type continued_fraction\n    integer                            :: a0, b1\n    procedure(series), pointer, nopass :: a, b\n  end type\n\n  interface\n    pure function series (n)\n      integer, intent(in) :: n\n      integer             :: series\n    end function\n  end interface\n\ncontains\n\n  pure function define_cf (a0,a,b1,b) result(x)\n    integer, intent(in)           :: a0\n    procedure(series)             :: a\n    integer, intent(in), optional :: b1\n    procedure(series),   optional :: b\n    type(continued_fraction)      :: x\n    x%a0 = a0\n    x%a => a\n    if ( present(b1) ) then\n       x%b1 = b1\n    else\n       x%b1 = 1\n    end if\n    if ( present(b) ) then\n       x%b => b\n    else\n       x%b => const_1\n    end if\n  end function define_cf\n\n  pure integer function const_1(n)\n    integer,intent(in) :: n\n    const_1 = 1  \n  end function\n\n  pure real(kind=long) function output(x,iterations)\n    type(continued_fraction), intent(in) :: x\n    integer,                  intent(in) :: iterations\n    integer                              :: i\n    output = x%a(iterations)\n    do i = iterations-1,1,-1\n      output = x%a(i) + (x%b(i+1) / output)\n    end do\n    output = x%a0 + (x%b1 / output)\n  end function output\n  \nend module continued_fractions\n\n\nprogram examples\n  use continued_fractions\n\n  type(continued_fraction) :: sqr2,napier,pi\n\n  sqr2   = define_cf(1,a_sqr2)\n  napier = define_cf(2,a_napier,1,b_napier)\n  pi     = define_cf(3,a=a_pi,b=b_pi)\n\n  write (*,*) output(sqr2,10000)\n  write (*,*) output(napier,10000)\n  write (*,*) output(pi,10000)\n\ncontains\n\n  pure integer function a_sqr2(n)\n    integer,intent(in) :: n\n    a_sqr2 = 2\n  end function\n\n  pure integer function a_napier(n)\n    integer,intent(in) :: n\n    a_napier = n\n  end function\n\n  pure integer function b_napier(n)\n    integer,intent(in) :: n\n    b_napier = n-1\n  end function\n\n  pure integer function a_pi(n)\n    integer,intent(in) :: n\n    a_pi = 6\n  end function\n\n  pure integer function b_pi(n)\n    integer,intent(in) :: n\n    b_pi = (2*n-1)*(2*n-1)\n  end function\n\nend program examples\n", "target": "import static java.lang.Math.pow;\nimport java.util.*;\nimport java.util.function.Function;\n\npublic class Test {\n    static double calc(Function<Integer, Integer[]> f, int n) {\n        double temp = 0;\n\n        for (int ni = n; ni >= 1; ni--) {\n            Integer[] p = f.apply(ni);\n            temp = p[1] / (double) (p[0] + temp);\n        }\n        return f.apply(0)[0] + temp;\n    }\n\n    public static void main(String[] args) {\n        List<Function<Integer, Integer[]>> fList = new ArrayList<>();\n        fList.add(n -> new Integer[]{n > 0 ? 2 : 1, 1});\n        fList.add(n -> new Integer[]{n > 0 ? n : 2, n > 1 ? (n - 1) : 1});\n        fList.add(n -> new Integer[]{n > 0 ? 6 : 3, (int) pow(2 * n - 1, 2)});\n\n        for (Function<Integer, Integer[]> f : fList)\n            System.out.println(calc(f, 200));\n    }\n}\n"}
{"id": 35983, "name": "Continued fraction", "source": "Translate Fortran to Python: module continued_fractions\n  implicit none\n  \n  integer, parameter :: long = selected_real_kind(7,99)\n\n  type continued_fraction\n    integer                            :: a0, b1\n    procedure(series), pointer, nopass :: a, b\n  end type\n\n  interface\n    pure function series (n)\n      integer, intent(in) :: n\n      integer             :: series\n    end function\n  end interface\n\ncontains\n\n  pure function define_cf (a0,a,b1,b) result(x)\n    integer, intent(in)           :: a0\n    procedure(series)             :: a\n    integer, intent(in), optional :: b1\n    procedure(series),   optional :: b\n    type(continued_fraction)      :: x\n    x%a0 = a0\n    x%a => a\n    if ( present(b1) ) then\n       x%b1 = b1\n    else\n       x%b1 = 1\n    end if\n    if ( present(b) ) then\n       x%b => b\n    else\n       x%b => const_1\n    end if\n  end function define_cf\n\n  pure integer function const_1(n)\n    integer,intent(in) :: n\n    const_1 = 1  \n  end function\n\n  pure real(kind=long) function output(x,iterations)\n    type(continued_fraction), intent(in) :: x\n    integer,                  intent(in) :: iterations\n    integer                              :: i\n    output = x%a(iterations)\n    do i = iterations-1,1,-1\n      output = x%a(i) + (x%b(i+1) / output)\n    end do\n    output = x%a0 + (x%b1 / output)\n  end function output\n  \nend module continued_fractions\n\n\nprogram examples\n  use continued_fractions\n\n  type(continued_fraction) :: sqr2,napier,pi\n\n  sqr2   = define_cf(1,a_sqr2)\n  napier = define_cf(2,a_napier,1,b_napier)\n  pi     = define_cf(3,a=a_pi,b=b_pi)\n\n  write (*,*) output(sqr2,10000)\n  write (*,*) output(napier,10000)\n  write (*,*) output(pi,10000)\n\ncontains\n\n  pure integer function a_sqr2(n)\n    integer,intent(in) :: n\n    a_sqr2 = 2\n  end function\n\n  pure integer function a_napier(n)\n    integer,intent(in) :: n\n    a_napier = n\n  end function\n\n  pure integer function b_napier(n)\n    integer,intent(in) :: n\n    b_napier = n-1\n  end function\n\n  pure integer function a_pi(n)\n    integer,intent(in) :: n\n    a_pi = 6\n  end function\n\n  pure integer function b_pi(n)\n    integer,intent(in) :: n\n    b_pi = (2*n-1)*(2*n-1)\n  end function\n\nend program examples\n", "target": "from fractions import Fraction\nimport itertools\ntry: zip = itertools.izip\nexcept: pass\n \n\ndef CF(a, b, t):\n  terms = list(itertools.islice(zip(a, b), t))\n  z = Fraction(1,1)\n  for a, b in reversed(terms):\n    z = a + b / z\n  return z\n \n\ndef pRes(x, d):\n  q, x = divmod(x, 1)\n  res = str(q)\n  res += \".\"\n  for i in range(d):\n    x *= 10\n    q, x = divmod(x, 1)\n    res += str(q)\n  return res\n \n\ndef sqrt2_a():\n  yield 1\n  for x in itertools.repeat(2):\n    yield x\n \ndef sqrt2_b():\n  for x in itertools.repeat(1):\n    yield x\n \ncf = CF(sqrt2_a(), sqrt2_b(), 950)\nprint(pRes(cf, 200))\n\n \n \n\ndef Napier_a():\n  yield 2\n  for x in itertools.count(1):\n    yield x\n \ndef Napier_b():\n  yield 1\n  for x in itertools.count(1):\n    yield x\n \ncf = CF(Napier_a(), Napier_b(), 950)\nprint(pRes(cf, 200))\n\n \n\ndef Pi_a():\n  yield 3\n  for x in itertools.repeat(6):\n    yield x\n \ndef Pi_b():\n  for x in itertools.count(1,2):\n    yield x*x\n \ncf = CF(Pi_a(), Pi_b(), 950)\nprint(pRes(cf, 10))\n\n"}
{"id": 35984, "name": "Continued fraction", "source": "Translate Fortran to Python: module continued_fractions\n  implicit none\n  \n  integer, parameter :: long = selected_real_kind(7,99)\n\n  type continued_fraction\n    integer                            :: a0, b1\n    procedure(series), pointer, nopass :: a, b\n  end type\n\n  interface\n    pure function series (n)\n      integer, intent(in) :: n\n      integer             :: series\n    end function\n  end interface\n\ncontains\n\n  pure function define_cf (a0,a,b1,b) result(x)\n    integer, intent(in)           :: a0\n    procedure(series)             :: a\n    integer, intent(in), optional :: b1\n    procedure(series),   optional :: b\n    type(continued_fraction)      :: x\n    x%a0 = a0\n    x%a => a\n    if ( present(b1) ) then\n       x%b1 = b1\n    else\n       x%b1 = 1\n    end if\n    if ( present(b) ) then\n       x%b => b\n    else\n       x%b => const_1\n    end if\n  end function define_cf\n\n  pure integer function const_1(n)\n    integer,intent(in) :: n\n    const_1 = 1  \n  end function\n\n  pure real(kind=long) function output(x,iterations)\n    type(continued_fraction), intent(in) :: x\n    integer,                  intent(in) :: iterations\n    integer                              :: i\n    output = x%a(iterations)\n    do i = iterations-1,1,-1\n      output = x%a(i) + (x%b(i+1) / output)\n    end do\n    output = x%a0 + (x%b1 / output)\n  end function output\n  \nend module continued_fractions\n\n\nprogram examples\n  use continued_fractions\n\n  type(continued_fraction) :: sqr2,napier,pi\n\n  sqr2   = define_cf(1,a_sqr2)\n  napier = define_cf(2,a_napier,1,b_napier)\n  pi     = define_cf(3,a=a_pi,b=b_pi)\n\n  write (*,*) output(sqr2,10000)\n  write (*,*) output(napier,10000)\n  write (*,*) output(pi,10000)\n\ncontains\n\n  pure integer function a_sqr2(n)\n    integer,intent(in) :: n\n    a_sqr2 = 2\n  end function\n\n  pure integer function a_napier(n)\n    integer,intent(in) :: n\n    a_napier = n\n  end function\n\n  pure integer function b_napier(n)\n    integer,intent(in) :: n\n    b_napier = n-1\n  end function\n\n  pure integer function a_pi(n)\n    integer,intent(in) :: n\n    a_pi = 6\n  end function\n\n  pure integer function b_pi(n)\n    integer,intent(in) :: n\n    b_pi = (2*n-1)*(2*n-1)\n  end function\n\nend program examples\n", "target": "from fractions import Fraction\nimport itertools\ntry: zip = itertools.izip\nexcept: pass\n \n\ndef CF(a, b, t):\n  terms = list(itertools.islice(zip(a, b), t))\n  z = Fraction(1,1)\n  for a, b in reversed(terms):\n    z = a + b / z\n  return z\n \n\ndef pRes(x, d):\n  q, x = divmod(x, 1)\n  res = str(q)\n  res += \".\"\n  for i in range(d):\n    x *= 10\n    q, x = divmod(x, 1)\n    res += str(q)\n  return res\n \n\ndef sqrt2_a():\n  yield 1\n  for x in itertools.repeat(2):\n    yield x\n \ndef sqrt2_b():\n  for x in itertools.repeat(1):\n    yield x\n \ncf = CF(sqrt2_a(), sqrt2_b(), 950)\nprint(pRes(cf, 200))\n\n \n \n\ndef Napier_a():\n  yield 2\n  for x in itertools.count(1):\n    yield x\n \ndef Napier_b():\n  yield 1\n  for x in itertools.count(1):\n    yield x\n \ncf = CF(Napier_a(), Napier_b(), 950)\nprint(pRes(cf, 200))\n\n \n\ndef Pi_a():\n  yield 3\n  for x in itertools.repeat(6):\n    yield x\n \ndef Pi_b():\n  for x in itertools.count(1,2):\n    yield x*x\n \ncf = CF(Pi_a(), Pi_b(), 950)\nprint(pRes(cf, 10))\n\n"}
{"id": 36431, "name": "Quine", "source": "Translate Fortran to C#: character*46::s='(\"character*46::s=\",3a,\";print s,39,s,39;end\")';print s,39,s,39;end\n", "target": "class Program { static void Main() { var s = \"class Program {{ static void Main() {{ var s = {0}{1}{0}; System.Console.WriteLine(s, (char)34, s); }} }}\"; System.Console.WriteLine(s, (char)34, s); } }\n"}
{"id": 36432, "name": "Quine", "source": "Translate Fortran to C#: character*46::s='(\"character*46::s=\",3a,\";print s,39,s,39;end\")';print s,39,s,39;end\n", "target": "class Program { static void Main() { var s = \"class Program {{ static void Main() {{ var s = {0}{1}{0}; System.Console.WriteLine(s, (char)34, s); }} }}\"; System.Console.WriteLine(s, (char)34, s); } }\n"}
{"id": 36438, "name": "Quine", "source": "Translate Fortran to Java: character*46::s='(\"character*46::s=\",3a,\";print s,39,s,39;end\")';print s,39,s,39;end\n", "target": "module test\n    {\n    @Inject Console console;\n    void run()\n        {\n        console.print($./test.x);\n        }\n    }\n"}
{"id": 36439, "name": "Quine", "source": "Translate Fortran to Java: character*46::s='(\"character*46::s=\",3a,\";print s,39,s,39;end\")';print s,39,s,39;end\n", "target": "module test\n    {\n    @Inject Console console;\n    void run()\n        {\n        console.print($./test.x);\n        }\n    }\n"}
{"id": 36440, "name": "Quine", "source": "Translate Fortran to Python: character*46::s='(\"character*46::s=\",3a,\";print s,39,s,39;end\")';print s,39,s,39;end\n", "target": "w = \"print('w = ' + chr(34) + w + chr(34) + chr(10) + w)\"\nprint('w = ' + chr(34) + w + chr(34) + chr(10) + w)\n"}
{"id": 36441, "name": "Quine", "source": "Translate Fortran to Python: character*46::s='(\"character*46::s=\",3a,\";print s,39,s,39;end\")';print s,39,s,39;end\n", "target": "w = \"print('w = ' + chr(34) + w + chr(34) + chr(10) + w)\"\nprint('w = ' + chr(34) + w + chr(34) + chr(10) + w)\n"}
{"id": 37022, "name": "Problem of Apollonius", "source": "Translate Fortran to C#: program Apollonius\n  implicit none\n\n  integer, parameter :: dp = selected_real_kind(15)\n\n  type circle\n    real(dp) :: x\n    real(dp) :: y\n    real(dp) :: radius\n  end type\n       \n  type(circle) :: c1 , c2, c3, r\n\n  c1 = circle(0.0, 0.0, 1.0)\n  c2 = circle(4.0, 0.0, 1.0)\n  c3 = circle(2.0, 4.0, 2.0)\n\n  write(*, \"(a,3f12.8))\") \"External tangent:\", SolveApollonius(c1, c2, c3, 1, 1, 1)\n  write(*, \"(a,3f12.8))\") \"Internal tangent:\", SolveApollonius(c1, c2, c3, -1, -1, -1)\n \ncontains\n\nfunction SolveApollonius(c1, c2, c3, s1, s2, s3) result(res)\n  type(circle) :: res\n  type(circle), intent(in) :: c1, c2, c3\n  integer, intent(in) :: s1, s2, s3\n \n  real(dp) :: x1, x2, x3, y1, y2, y3, r1, r2, r3\n  real(dp) :: v11, v12, v13, v14\n  real(dp) :: v21, v22, v23, v24\n  real(dp) :: w12, w13, w14\n  real(dp) :: w22, w23, w24\n  real(dp) :: p, q, m, n, a, b, c, det\n  \n  x1 = c1%x; x2 = c2%x; x3 = c3%x\n  y1 = c1%y; y2 = c2%y; y3 = c3%y\n  r1 = c1%radius; r2 = c2%radius; r3 = c3%radius\n\n  v11 = 2*x2 - 2*x1\n  v12 = 2*y2 - 2*y1\n  v13 = x1*x1 - x2*x2 + y1*y1 - y2*y2 - r1*r1 + r2*r2\n  v14 = 2*s2*r2 - 2*s1*r1\n \n  v21 = 2*x3 - 2*x2\n  v22 = 2*y3 - 2*y2\n  v23 = x2*x2 - x3*x3 + y2*y2 - y3*y3 - r2*r2 + r3*r3\n  v24 = 2*s3*r3 - 2*s2*r2\n \n  w12 = v12/v11\n  w13 = v13/v11\n  w14 = v14/v11\n \n  w22 = v22/v21-w12\n  w23 = v23/v21-w13\n  w24 = v24/v21-w14\n \n  p = -w23/w22\n  q = w24/w22\n  m = -w12*P - w13\n  n = w14 - w12*q\n \n  a = n*n + q*q - 1\n  b = 2*m*n - 2*n*x1 + 2*p*q - 2*q*y1 + 2*s1*r1\n  c = x1*x1 + m*m - 2*m*x1 + p*p + y1*y1 - 2*p*y1 - r1*r1\n \n  det = b*b - 4*a*c\n  res%radius = (-b-sqrt(det)) / (2*a)\n  res%x = m + n*res%radius\n  res%y = p + q*res%radius\n\nend function\nend program\n", "target": "using System;\n\nnamespace ApolloniusProblemCalc\n{\n    class Program\n    {\n        static float rs = 0;\n        static float xs = 0;\n        static float ys = 0;\n\n        public static void Main(string[] args)\n        {\n            float gx1;\n            float gy1;\n            float gr1;\n            float gx2;\n            float gy2;\n            float gr2;\n            float gx3;\n            float gy3;\n            float gr3;\n\n            \n            gx1 = 0;\n            gy1 = 0;\n            gr1 = 1;\n            gx2 = 4;\n            gy2 = 0;\n            gr2 = 1;\n            gx3 = 2;\n            gy3 = 4;\n            gr3 = 2;\n            \n\n            for (int i = 1; i <= 8; i++)\n            {\n                SolveTheApollonius(i, gx1, gy1, gr1, gx2, gy2, gr2, gx3, gy3, gr3);\n\n\n                if (i == 1)\n                {\n                    Console.WriteLine(\"X of point of the \" + i + \"st solution: \" + xs.ToString());\n                    Console.WriteLine(\"Y of point of the \" + i + \"st solution: \" + ys.ToString());\n                    Console.WriteLine(i + \"st Solution circle's radius: \" + rs.ToString());\n                }\n                else if (i == 2)\n                {\n                    Console.WriteLine(\"X of point of the \" + i + \"ed solution: \" + xs.ToString());\n                    Console.WriteLine(\"Y of point of the \" + i + \"ed solution: \" + ys.ToString());\n                    Console.WriteLine(i + \"ed Solution circle's radius: \" + rs.ToString());\n                }\n                else if(i == 3)\n                {\n                    Console.WriteLine(\"X of point of the \" + i + \"rd solution: \" + xs.ToString());\n                    Console.WriteLine(\"Y of point of the \" + i + \"rd solution: \" + ys.ToString());\n                    Console.WriteLine(i + \"rd Solution circle's radius: \" + rs.ToString());\n                }\n                else\n                {\n                    Console.WriteLine(\"X of point of the \" + i + \"th solution: \" + xs.ToString());\n                    Console.WriteLine(\"Y of point of the \" + i + \"th solution: \" + ys.ToString());\n                    Console.WriteLine(i + \"th Solution circle's radius: \" + rs.ToString());\n                }\n\n                Console.WriteLine();\n            }\n\n\n            Console.ReadKey(true);\n        }\n\n        private static void SolveTheApollonius(int calcCounter, float x1, float y1, float r1, float x2, float y2, float r2, float x3, float y3, float r3)\n        {\n            float s1 = 1;\n            float s2 = 1;\n            float s3 = 1;\n\n            if (calcCounter == 2)\n            {\n                s1 = -1;\n                s2 = -1;\n                s3 = -1;\n            }\n            else if (calcCounter == 3)\n            {\n                s1 = 1;\n                s2 = -1;\n                s3 = -1;\n            }\n            else if (calcCounter == 4)\n            {\n                s1 = -1;\n                s2 = 1;\n                s3 = -1;\n            }\n            else if (calcCounter == 5)\n            {\n                s1 = -1;\n                s2 = -1;\n                s3 = 1;\n            }\n            else if (calcCounter == 6)\n            {\n                s1 = 1;\n                s2 = 1;\n                s3 = -1;\n            }\n            else if (calcCounter == 7)\n            {\n                s1 = -1;\n                s2 = 1;\n                s3 = 1;\n            }\n            else if (calcCounter == 8)\n            {\n                s1 = 1;\n                s2 = -1;\n                s3 = 1;\n            }\n\n            \n            float v11 = 2 * x2 - 2 * x1;\n            float v12 = 2 * y2 - 2 * y1;\n            float v13 = x1 * x1 - x2 * x2 + y1 * y1 - y2 * y2 - r1 * r1 + r2 * r2;\n            float v14 = 2 * s2 * r2 - 2 * s1 * r1;\n\n            float v21 = 2 * x3 - 2 * x2;\n            float v22 = 2 * y3 - 2 * y2;\n            float v23 = x2 * x2 - x3 * x3 + y2 * y2 - y3 * y3 - r2 * r2 + r3 * r3;\n            float v24 = 2 * s3 * r3 - 2 * s2 * r2;\n\n            float w12 = v12 / v11;\n            float w13 = v13 / v11;\n            float w14 = v14 / v11;\n\n            float w22 = v22 / v21 - w12;\n            float w23 = v23 / v21 - w13;\n            float w24 = v24 / v21 - w14;\n\n            float P = -w23 / w22;\n            float Q = w24 / w22;\n            float M = -w12 * P - w13;\n            float N = w14 - w12 * Q;\n\n            float a = N * N + Q * Q - 1;\n            float b = 2 * M * N - 2 * N * x1 + 2 * P * Q - 2 * Q * y1 + 2 * s1 * r1;\n            float c = x1 * x1 + M * M - 2 * M * x1 + P * P + y1 * y1 - 2 * P * y1 - r1 * r1;\n\n            float D = b * b - 4 * a * c;\n\n            rs = (-b - float.Parse(Math.Sqrt(D).ToString())) / (2 * float.Parse(a.ToString()));\n            xs = M + N * rs;\n            ys = P + Q * rs;\n        }\n    }\n}\n"}
{"id": 37025, "name": "Problem of Apollonius", "source": "Translate Fortran to Java: program Apollonius\n  implicit none\n\n  integer, parameter :: dp = selected_real_kind(15)\n\n  type circle\n    real(dp) :: x\n    real(dp) :: y\n    real(dp) :: radius\n  end type\n       \n  type(circle) :: c1 , c2, c3, r\n\n  c1 = circle(0.0, 0.0, 1.0)\n  c2 = circle(4.0, 0.0, 1.0)\n  c3 = circle(2.0, 4.0, 2.0)\n\n  write(*, \"(a,3f12.8))\") \"External tangent:\", SolveApollonius(c1, c2, c3, 1, 1, 1)\n  write(*, \"(a,3f12.8))\") \"Internal tangent:\", SolveApollonius(c1, c2, c3, -1, -1, -1)\n \ncontains\n\nfunction SolveApollonius(c1, c2, c3, s1, s2, s3) result(res)\n  type(circle) :: res\n  type(circle), intent(in) :: c1, c2, c3\n  integer, intent(in) :: s1, s2, s3\n \n  real(dp) :: x1, x2, x3, y1, y2, y3, r1, r2, r3\n  real(dp) :: v11, v12, v13, v14\n  real(dp) :: v21, v22, v23, v24\n  real(dp) :: w12, w13, w14\n  real(dp) :: w22, w23, w24\n  real(dp) :: p, q, m, n, a, b, c, det\n  \n  x1 = c1%x; x2 = c2%x; x3 = c3%x\n  y1 = c1%y; y2 = c2%y; y3 = c3%y\n  r1 = c1%radius; r2 = c2%radius; r3 = c3%radius\n\n  v11 = 2*x2 - 2*x1\n  v12 = 2*y2 - 2*y1\n  v13 = x1*x1 - x2*x2 + y1*y1 - y2*y2 - r1*r1 + r2*r2\n  v14 = 2*s2*r2 - 2*s1*r1\n \n  v21 = 2*x3 - 2*x2\n  v22 = 2*y3 - 2*y2\n  v23 = x2*x2 - x3*x3 + y2*y2 - y3*y3 - r2*r2 + r3*r3\n  v24 = 2*s3*r3 - 2*s2*r2\n \n  w12 = v12/v11\n  w13 = v13/v11\n  w14 = v14/v11\n \n  w22 = v22/v21-w12\n  w23 = v23/v21-w13\n  w24 = v24/v21-w14\n \n  p = -w23/w22\n  q = w24/w22\n  m = -w12*P - w13\n  n = w14 - w12*q\n \n  a = n*n + q*q - 1\n  b = 2*m*n - 2*n*x1 + 2*p*q - 2*q*y1 + 2*s1*r1\n  c = x1*x1 + m*m - 2*m*x1 + p*p + y1*y1 - 2*p*y1 - r1*r1\n \n  det = b*b - 4*a*c\n  res%radius = (-b-sqrt(det)) / (2*a)\n  res%x = m + n*res%radius\n  res%y = p + q*res%radius\n\nend function\nend program\n", "target": "public class Circle\n{\n public double[] center;\n public double radius;\n public Circle(double[] center, double radius)\n {\n  this.center = center;\n  this.radius = radius;\n }\n public String toString()\n {\n  return String.format(\"Circle[x=%.2f,y=%.2f,r=%.2f]\",center[0],center[1],\n\t\t       radius);\n }\n}\n\npublic class ApolloniusSolver\n{\n\n public static Circle solveApollonius(Circle c1, Circle c2, Circle c3, int s1,\n\t\t\t\t      int s2, int s3)\n {\n  float x1 = c1.center[0];\n  float y1 = c1.center[1];\n  float r1 = c1.radius;\n  float x2 = c2.center[0];\n  float y2 = c2.center[1];\n  float r2 = c2.radius;\n  float x3 = c3.center[0];\n  float y3 = c3.center[1];\n  float r3 = c3.radius;\n\n  \n  \n  float v11 = 2*x2 - 2*x1;\n  float v12 = 2*y2 - 2*y1;\n  float v13 = x1*x1 - x2*x2 + y1*y1 - y2*y2 - r1*r1 + r2*r2;\n  float v14 = 2*s2*r2 - 2*s1*r1;\n\n  float v21 = 2*x3 - 2*x2;\n  float v22 = 2*y3 - 2*y2;\n  float v23 = x2*x2 - x3*x3 + y2*y2 - y3*y3 - r2*r2 + r3*r3;\n  float v24 = 2*s3*r3 - 2*s2*r2;\n\n  float w12 = v12/v11;\n  float w13 = v13/v11;\n  float w14 = v14/v11;\n\n  float w22 = v22/v21-w12;\n  float w23 = v23/v21-w13;\n  float w24 = v24/v21-w14;\n\n  float P = -w23/w22;\n  float Q = w24/w22;\n  float M = -w12*P-w13;\n  float N = w14 - w12*Q;\n\n  float a = N*N + Q*Q - 1;\n  float b = 2*M*N - 2*N*x1 + 2*P*Q - 2*Q*y1 + 2*s1*r1;\n  float c = x1*x1 + M*M - 2*M*x1 + P*P + y1*y1 - 2*P*y1 - r1*r1;\n\n  \n  \n  float D = b*b-4*a*c;\n  float rs = (-b-Math.sqrt(D))/(2*a);\n  float xs = M + N * rs;\n  float ys = P + Q * rs;\n  return new Circle(new double[]{xs,ys}, rs);\n }\n public static void main(final String[] args)\n {\n  Circle c1 = new Circle(new double[]{0,0}, 1);\n  Circle c2 = new Circle(new double[]{4,0}, 1);\n  Circle c3 = new Circle(new double[]{2,4}, 2);\n  \n  System.out.println(solveApollonius(c1,c2,c3,1,1,1));\n  \n  System.out.println(solveApollonius(c1,c2,c3,-1,-1,-1));\n }\n}\n"}
{"id": 37026, "name": "Problem of Apollonius", "source": "Translate Fortran to Python: program Apollonius\n  implicit none\n\n  integer, parameter :: dp = selected_real_kind(15)\n\n  type circle\n    real(dp) :: x\n    real(dp) :: y\n    real(dp) :: radius\n  end type\n       \n  type(circle) :: c1 , c2, c3, r\n\n  c1 = circle(0.0, 0.0, 1.0)\n  c2 = circle(4.0, 0.0, 1.0)\n  c3 = circle(2.0, 4.0, 2.0)\n\n  write(*, \"(a,3f12.8))\") \"External tangent:\", SolveApollonius(c1, c2, c3, 1, 1, 1)\n  write(*, \"(a,3f12.8))\") \"Internal tangent:\", SolveApollonius(c1, c2, c3, -1, -1, -1)\n \ncontains\n\nfunction SolveApollonius(c1, c2, c3, s1, s2, s3) result(res)\n  type(circle) :: res\n  type(circle), intent(in) :: c1, c2, c3\n  integer, intent(in) :: s1, s2, s3\n \n  real(dp) :: x1, x2, x3, y1, y2, y3, r1, r2, r3\n  real(dp) :: v11, v12, v13, v14\n  real(dp) :: v21, v22, v23, v24\n  real(dp) :: w12, w13, w14\n  real(dp) :: w22, w23, w24\n  real(dp) :: p, q, m, n, a, b, c, det\n  \n  x1 = c1%x; x2 = c2%x; x3 = c3%x\n  y1 = c1%y; y2 = c2%y; y3 = c3%y\n  r1 = c1%radius; r2 = c2%radius; r3 = c3%radius\n\n  v11 = 2*x2 - 2*x1\n  v12 = 2*y2 - 2*y1\n  v13 = x1*x1 - x2*x2 + y1*y1 - y2*y2 - r1*r1 + r2*r2\n  v14 = 2*s2*r2 - 2*s1*r1\n \n  v21 = 2*x3 - 2*x2\n  v22 = 2*y3 - 2*y2\n  v23 = x2*x2 - x3*x3 + y2*y2 - y3*y3 - r2*r2 + r3*r3\n  v24 = 2*s3*r3 - 2*s2*r2\n \n  w12 = v12/v11\n  w13 = v13/v11\n  w14 = v14/v11\n \n  w22 = v22/v21-w12\n  w23 = v23/v21-w13\n  w24 = v24/v21-w14\n \n  p = -w23/w22\n  q = w24/w22\n  m = -w12*P - w13\n  n = w14 - w12*q\n \n  a = n*n + q*q - 1\n  b = 2*m*n - 2*n*x1 + 2*p*q - 2*q*y1 + 2*s1*r1\n  c = x1*x1 + m*m - 2*m*x1 + p*p + y1*y1 - 2*p*y1 - r1*r1\n \n  det = b*b - 4*a*c\n  res%radius = (-b-sqrt(det)) / (2*a)\n  res%x = m + n*res%radius\n  res%y = p + q*res%radius\n\nend function\nend program\n", "target": "from collections import namedtuple\nimport math\n\nCircle = namedtuple('Circle', 'x, y, r')\n \ndef solveApollonius(c1, c2, c3, s1, s2, s3):\n    \n    x1, y1, r1 = c1\n    x2, y2, r2 = c2\n    x3, y3, r3 = c3\n\n    v11 = 2*x2 - 2*x1\n    v12 = 2*y2 - 2*y1\n    v13 = x1*x1 - x2*x2 + y1*y1 - y2*y2 - r1*r1 + r2*r2\n    v14 = 2*s2*r2 - 2*s1*r1\n \n    v21 = 2*x3 - 2*x2\n    v22 = 2*y3 - 2*y2\n    v23 = x2*x2 - x3*x3 + y2*y2 - y3*y3 - r2*r2 + r3*r3\n    v24 = 2*s3*r3 - 2*s2*r2\n \n    w12 = v12/v11\n    w13 = v13/v11\n    w14 = v14/v11\n \n    w22 = v22/v21-w12\n    w23 = v23/v21-w13\n    w24 = v24/v21-w14\n \n    P = -w23/w22\n    Q = w24/w22\n    M = -w12*P-w13\n    N = w14 - w12*Q\n \n    a = N*N + Q*Q - 1\n    b = 2*M*N - 2*N*x1 + 2*P*Q - 2*Q*y1 + 2*s1*r1\n    c = x1*x1 + M*M - 2*M*x1 + P*P + y1*y1 - 2*P*y1 - r1*r1\n \n    \n    D = b*b-4*a*c\n    rs = (-b-math.sqrt(D))/(2*a)\n \n    xs = M+N*rs\n    ys = P+Q*rs\n \n    return Circle(xs, ys, rs)\n\nif __name__ == '__main__':\n    c1, c2, c3 = Circle(0, 0, 1), Circle(4, 0, 1), Circle(2, 4, 2)\n    print(solveApollonius(c1, c2, c3, 1, 1, 1))    \n    print(solveApollonius(c1, c2, c3, -1, -1, -1)) \n"}
{"id": 37198, "name": "Sequence of non-squares", "source": "Translate Fortran to C#: PROGRAM NONSQUARES\n\n  IMPLICIT NONE\n\n  INTEGER :: m, n, nonsqr\n      \n  DO n = 1, 22\n    nonsqr =  n + FLOOR(0.5 + SQRT(REAL(n)))  \n    WRITE(*,*) nonsqr\n  END DO\n\n  DO n = 1, 1000000\n    nonsqr =  n + FLOOR(0.5 + SQRT(REAL(n)))\n    m = INT(SQRT(REAL(nonsqr)))\n    IF (m*m == nonsqr) THEN\n      WRITE(*,*) \"Square found, n=\", n\n    END IF\n  END DO\n\nEND PROGRAM NONSQUARES\n", "target": "using System;\nusing System.Diagnostics;\n\nnamespace sons\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            for (int i = 1; i < 23; i++)            \n                Console.WriteLine(nonsqr(i));            \n\n            for (int i = 1; i < 1000000; i++)\n            {\n                double j = Math.Sqrt(nonsqr(i));\n                Debug.Assert(j != Math.Floor(j),\"Square\");\n            }            \n        }\n\n        static int nonsqr(int i)\n        {\n            return (int)(i + Math.Floor(0.5 + Math.Sqrt(i)));\n        }\n    }\n}\n"}
{"id": 37201, "name": "Sequence of non-squares", "source": "Translate Fortran to Java: PROGRAM NONSQUARES\n\n  IMPLICIT NONE\n\n  INTEGER :: m, n, nonsqr\n      \n  DO n = 1, 22\n    nonsqr =  n + FLOOR(0.5 + SQRT(REAL(n)))  \n    WRITE(*,*) nonsqr\n  END DO\n\n  DO n = 1, 1000000\n    nonsqr =  n + FLOOR(0.5 + SQRT(REAL(n)))\n    m = INT(SQRT(REAL(nonsqr)))\n    IF (m*m == nonsqr) THEN\n      WRITE(*,*) \"Square found, n=\", n\n    END IF\n  END DO\n\nEND PROGRAM NONSQUARES\n", "target": "public class SeqNonSquares {\n    public static int nonsqr(int n) {\n        return n + (int)Math.round(Math.sqrt(n));\n    }\n    \n    public static void main(String[] args) {\n        \n        for (int i = 1; i < 23; i++)\n            System.out.print(nonsqr(i) + \" \");\n        System.out.println();\n        \n        \n        for (int i = 1; i < 1000000; i++) {\n            double j = Math.sqrt(nonsqr(i));\n            assert j != Math.floor(j);\n        }\n    }\n}\n"}
{"id": 37202, "name": "Sequence of non-squares", "source": "Translate Fortran to Python: PROGRAM NONSQUARES\n\n  IMPLICIT NONE\n\n  INTEGER :: m, n, nonsqr\n      \n  DO n = 1, 22\n    nonsqr =  n + FLOOR(0.5 + SQRT(REAL(n)))  \n    WRITE(*,*) nonsqr\n  END DO\n\n  DO n = 1, 1000000\n    nonsqr =  n + FLOOR(0.5 + SQRT(REAL(n)))\n    m = INT(SQRT(REAL(nonsqr)))\n    IF (m*m == nonsqr) THEN\n      WRITE(*,*) \"Square found, n=\", n\n    END IF\n  END DO\n\nEND PROGRAM NONSQUARES\n", "target": ">>> from math import floor, sqrt\n>>> def non_square(n):\n        return n + floor(1/2 + sqrt(n))\n\n>>> \n>>> print(*map(non_square, range(1, 23)))\n2 3 5 6 7 8 10 11 12 13 14 15 17 18 19 20 21 22 23 24 26 27\n\n>>> \n>>> def is_square(n):\n        return sqrt(n).is_integer()\n\n>>> non_squares = map(non_square, range(1, 10 ** 6))\n>>> next(filter(is_square, non_squares))\nStopIteration                             Traceback (most recent call last)\n<ipython-input-45-f32645fc1c0a> in <module>()\n      1 non_squares = map(non_square, range(1, 10 ** 6))\n----> 2 next(filter(is_square, non_squares))\n\nStopIteration:\n"}
{"id": 37508, "name": "Quaternion type", "source": "Translate Fortran to C#: module Q_mod\n  implicit none\n\n  type quaternion\n    real :: a, b, c, d\n  end type\n\n  public :: norm, neg, conj\n  public :: operator (+)\n  public :: operator (*)\n  \n  private ::  q_plus_q, q_plus_r, r_plus_q, &\n              q_mult_q, q_mult_r, r_mult_q, &\n              norm_q, neg_q, conj_q\n\n  interface norm\n    module procedure norm_q\n  end interface\n\n  interface neg\n    module procedure neg_q\n  end interface\n\n  interface conj\n    module procedure conj_q\n  end interface\n\n  interface operator (+)\n    module procedure q_plus_q, q_plus_r, r_plus_q\n  end interface\n\n  interface operator (*)\n    module procedure q_mult_q, q_mult_r, r_mult_q\n  end interface\n\ncontains\n\nfunction norm_q(x) result(res)\n  real :: res\n  type (quaternion), intent (in) :: x\n\n  res = sqrt(x%a*x%a + x%b*x%b + x%c*x%c + x%d*x%d)\n  \nend function norm_q\n\nfunction neg_q(x) result(res)\n  type (quaternion) :: res\n  type (quaternion), intent (in) :: x\n\n  res%a = -x%a\n  res%b = -x%b\n  res%c = -x%c\n  res%d = -x%d\n  \nend function neg_q\n\nfunction conj_q(x) result(res)\n  type (quaternion) :: res\n  type (quaternion), intent (in) :: x\n\n  res%a = x%a\n  res%b = -x%b\n  res%c = -x%c\n  res%d = -x%d\n  \nend function conj_q\n\nfunction q_plus_q(x, y) result (res)\n  type (quaternion) :: res\n  type (quaternion), intent (in) :: x, y\n   \n  res%a = x%a + y%a\n  res%b = x%b + y%b\n  res%c = x%c + y%c\n  res%d = x%d + y%d\n   \nend function q_plus_q\n\nfunction q_plus_r(x, r) result (res)\n  type (quaternion) :: res \n  type (quaternion), intent (in) :: x\n  real, intent(in) :: r\n   \n   res = x\n   res%a = x%a + r\n   \nend function q_plus_r\n\nfunction r_plus_q(r, x) result (res)\n  type (quaternion) :: res \n  type (quaternion), intent (in) :: x\n  real, intent(in) :: r\n   \n   res = x\n   res%a = x%a + r\n   \nend function r_plus_q\n\nfunction q_mult_q(x, y) result (res)\n  type (quaternion) :: res \n  type (quaternion), intent (in) :: x, y\n   \n   res%a = x%a*y%a - x%b*y%b - x%c*y%c - x%d*y%d\n   res%b = x%a*y%b + x%b*y%a + x%c*y%d - x%d*y%c\n   res%c = x%a*y%c - x%b*y%d + x%c*y%a + x%d*y%b\n   res%d = x%a*y%d + x%b*y%c - x%c*y%b + x%d*y%a\n   \nend function q_mult_q\n\nfunction q_mult_r(x, r) result (res)\n  type (quaternion) :: res \n  type (quaternion), intent (in) :: x\n  real, intent(in) ::  r\n   \n   res%a = x%a*r\n   res%b = x%b*r\n   res%c = x%c*r  \n   res%d = x%d*r \n   \nend function q_mult_r\n\nfunction r_mult_q(r, x) result (res)\n  type (quaternion) :: res \n  type (quaternion), intent (in) :: x\n  real, intent(in) ::  r\n   \n   res%a = x%a*r\n   res%b = x%b*r\n   res%c = x%c*r  \n   res%d = x%d*r \n   \nend function r_mult_q\nend module Q_mod\n\nprogram Quaternions\n  use Q_mod\n  implicit none\n\n  real :: r = 7.0\n  type(quaternion) :: q, q1, q2\n\n  q  = quaternion(1, 2, 3, 4)\n  q1 = quaternion(2, 3, 4, 5)\n  q2 = quaternion(3, 4, 5, 6)\n\n  write(*, \"(a, 4f8.3)\") \"             q = \", q\n  write(*, \"(a, 4f8.3)\") \"            q1 = \", q1\n  write(*, \"(a, 4f8.3)\") \"            q2 = \", q2\n  write(*, \"(a, f8.3)\")  \"             r = \", r\n  write(*, \"(a, f8.3)\")  \"     Norm of q = \", norm(q) \n  write(*, \"(a, 4f8.3)\") \" Negative of q = \", neg(q)\n  write(*, \"(a, 4f8.3)\") \"Conjugate of q = \", conj(q) \n  write(*, \"(a, 4f8.3)\") \"         q + r = \", q + r\n  write(*, \"(a, 4f8.3)\") \"         r + q = \", r + q\n  write(*, \"(a, 4f8.3)\") \"       q1 + q2 = \", q1 + q2\n  write(*, \"(a, 4f8.3)\") \"         q * r = \", q * r  \n  write(*, \"(a, 4f8.3)\") \"         r * q = \", r * q \n  write(*, \"(a, 4f8.3)\") \"       q1 * q2 = \", q1 * q2 \n  write(*, \"(a, 4f8.3)\") \"       q2 * q1 = \", q2 * q1 \n\nend program\n", "target": "using System;\n\nstruct Quaternion : IEquatable<Quaternion>\n{\n    public readonly double A, B, C, D;\n\n    public Quaternion(double a, double b, double c, double d)\n    {\n        this.A = a;\n        this.B = b;\n        this.C = c;\n        this.D = d;\n    }\n\n    public double Norm()\n    {\n        return Math.Sqrt(A * A + B * B + C * C + D * D);\n    }\n\n    public static Quaternion operator -(Quaternion q)\n    {\n        return new Quaternion(-q.A, -q.B, -q.C, -q.D);\n    }\n\n    public Quaternion Conjugate()\n    {\n        return new Quaternion(A, -B, -C, -D);\n    }\n\n    \n    public static implicit operator Quaternion(double d)\n    {\n        return new Quaternion(d, 0, 0, 0);\n    }\n\n    public static Quaternion operator +(Quaternion q1, Quaternion q2)\n    {\n        return new Quaternion(q1.A + q2.A, q1.B + q2.B, q1.C + q2.C, q1.D + q2.D);\n    }\n\n    public static Quaternion operator *(Quaternion q1, Quaternion q2)\n    {\n        return new Quaternion(\n            q1.A * q2.A - q1.B * q2.B - q1.C * q2.C - q1.D * q2.D,\n            q1.A * q2.B + q1.B * q2.A + q1.C * q2.D - q1.D * q2.C,\n            q1.A * q2.C - q1.B * q2.D + q1.C * q2.A + q1.D * q2.B,\n            q1.A * q2.D + q1.B * q2.C - q1.C * q2.B + q1.D * q2.A);\n    }\n\n    public static bool operator ==(Quaternion q1, Quaternion q2)\n    {\n        return q1.A == q2.A && q1.B == q2.B && q1.C == q2.C && q1.D == q2.D;\n    }\n\n    public static bool operator !=(Quaternion q1, Quaternion q2)\n    {\n        return !(q1 == q2);\n    }\n\n    #region Object Members\n\n    public override bool Equals(object obj)\n    {\n        if (obj is Quaternion)\n            return Equals((Quaternion)obj);\n\n        return false;\n    }\n\n    public override int GetHashCode()\n    {\n        return A.GetHashCode() ^ B.GetHashCode() ^ C.GetHashCode() ^ D.GetHashCode();\n    }\n\n    public override string ToString()\n    {\n        return string.Format(\"Q({0}, {1}, {2}, {3})\", A, B, C, D);\n    }\n\n    #endregion\n\n    #region IEquatable<Quaternion> Members\n\n    public bool Equals(Quaternion other)\n    {\n        return other == this;\n    }\n\n    #endregion\n}\n"}
{"id": 37509, "name": "Quaternion type", "source": "Translate Fortran to C#: module Q_mod\n  implicit none\n\n  type quaternion\n    real :: a, b, c, d\n  end type\n\n  public :: norm, neg, conj\n  public :: operator (+)\n  public :: operator (*)\n  \n  private ::  q_plus_q, q_plus_r, r_plus_q, &\n              q_mult_q, q_mult_r, r_mult_q, &\n              norm_q, neg_q, conj_q\n\n  interface norm\n    module procedure norm_q\n  end interface\n\n  interface neg\n    module procedure neg_q\n  end interface\n\n  interface conj\n    module procedure conj_q\n  end interface\n\n  interface operator (+)\n    module procedure q_plus_q, q_plus_r, r_plus_q\n  end interface\n\n  interface operator (*)\n    module procedure q_mult_q, q_mult_r, r_mult_q\n  end interface\n\ncontains\n\nfunction norm_q(x) result(res)\n  real :: res\n  type (quaternion), intent (in) :: x\n\n  res = sqrt(x%a*x%a + x%b*x%b + x%c*x%c + x%d*x%d)\n  \nend function norm_q\n\nfunction neg_q(x) result(res)\n  type (quaternion) :: res\n  type (quaternion), intent (in) :: x\n\n  res%a = -x%a\n  res%b = -x%b\n  res%c = -x%c\n  res%d = -x%d\n  \nend function neg_q\n\nfunction conj_q(x) result(res)\n  type (quaternion) :: res\n  type (quaternion), intent (in) :: x\n\n  res%a = x%a\n  res%b = -x%b\n  res%c = -x%c\n  res%d = -x%d\n  \nend function conj_q\n\nfunction q_plus_q(x, y) result (res)\n  type (quaternion) :: res\n  type (quaternion), intent (in) :: x, y\n   \n  res%a = x%a + y%a\n  res%b = x%b + y%b\n  res%c = x%c + y%c\n  res%d = x%d + y%d\n   \nend function q_plus_q\n\nfunction q_plus_r(x, r) result (res)\n  type (quaternion) :: res \n  type (quaternion), intent (in) :: x\n  real, intent(in) :: r\n   \n   res = x\n   res%a = x%a + r\n   \nend function q_plus_r\n\nfunction r_plus_q(r, x) result (res)\n  type (quaternion) :: res \n  type (quaternion), intent (in) :: x\n  real, intent(in) :: r\n   \n   res = x\n   res%a = x%a + r\n   \nend function r_plus_q\n\nfunction q_mult_q(x, y) result (res)\n  type (quaternion) :: res \n  type (quaternion), intent (in) :: x, y\n   \n   res%a = x%a*y%a - x%b*y%b - x%c*y%c - x%d*y%d\n   res%b = x%a*y%b + x%b*y%a + x%c*y%d - x%d*y%c\n   res%c = x%a*y%c - x%b*y%d + x%c*y%a + x%d*y%b\n   res%d = x%a*y%d + x%b*y%c - x%c*y%b + x%d*y%a\n   \nend function q_mult_q\n\nfunction q_mult_r(x, r) result (res)\n  type (quaternion) :: res \n  type (quaternion), intent (in) :: x\n  real, intent(in) ::  r\n   \n   res%a = x%a*r\n   res%b = x%b*r\n   res%c = x%c*r  \n   res%d = x%d*r \n   \nend function q_mult_r\n\nfunction r_mult_q(r, x) result (res)\n  type (quaternion) :: res \n  type (quaternion), intent (in) :: x\n  real, intent(in) ::  r\n   \n   res%a = x%a*r\n   res%b = x%b*r\n   res%c = x%c*r  \n   res%d = x%d*r \n   \nend function r_mult_q\nend module Q_mod\n\nprogram Quaternions\n  use Q_mod\n  implicit none\n\n  real :: r = 7.0\n  type(quaternion) :: q, q1, q2\n\n  q  = quaternion(1, 2, 3, 4)\n  q1 = quaternion(2, 3, 4, 5)\n  q2 = quaternion(3, 4, 5, 6)\n\n  write(*, \"(a, 4f8.3)\") \"             q = \", q\n  write(*, \"(a, 4f8.3)\") \"            q1 = \", q1\n  write(*, \"(a, 4f8.3)\") \"            q2 = \", q2\n  write(*, \"(a, f8.3)\")  \"             r = \", r\n  write(*, \"(a, f8.3)\")  \"     Norm of q = \", norm(q) \n  write(*, \"(a, 4f8.3)\") \" Negative of q = \", neg(q)\n  write(*, \"(a, 4f8.3)\") \"Conjugate of q = \", conj(q) \n  write(*, \"(a, 4f8.3)\") \"         q + r = \", q + r\n  write(*, \"(a, 4f8.3)\") \"         r + q = \", r + q\n  write(*, \"(a, 4f8.3)\") \"       q1 + q2 = \", q1 + q2\n  write(*, \"(a, 4f8.3)\") \"         q * r = \", q * r  \n  write(*, \"(a, 4f8.3)\") \"         r * q = \", r * q \n  write(*, \"(a, 4f8.3)\") \"       q1 * q2 = \", q1 * q2 \n  write(*, \"(a, 4f8.3)\") \"       q2 * q1 = \", q2 * q1 \n\nend program\n", "target": "using System;\n\nstruct Quaternion : IEquatable<Quaternion>\n{\n    public readonly double A, B, C, D;\n\n    public Quaternion(double a, double b, double c, double d)\n    {\n        this.A = a;\n        this.B = b;\n        this.C = c;\n        this.D = d;\n    }\n\n    public double Norm()\n    {\n        return Math.Sqrt(A * A + B * B + C * C + D * D);\n    }\n\n    public static Quaternion operator -(Quaternion q)\n    {\n        return new Quaternion(-q.A, -q.B, -q.C, -q.D);\n    }\n\n    public Quaternion Conjugate()\n    {\n        return new Quaternion(A, -B, -C, -D);\n    }\n\n    \n    public static implicit operator Quaternion(double d)\n    {\n        return new Quaternion(d, 0, 0, 0);\n    }\n\n    public static Quaternion operator +(Quaternion q1, Quaternion q2)\n    {\n        return new Quaternion(q1.A + q2.A, q1.B + q2.B, q1.C + q2.C, q1.D + q2.D);\n    }\n\n    public static Quaternion operator *(Quaternion q1, Quaternion q2)\n    {\n        return new Quaternion(\n            q1.A * q2.A - q1.B * q2.B - q1.C * q2.C - q1.D * q2.D,\n            q1.A * q2.B + q1.B * q2.A + q1.C * q2.D - q1.D * q2.C,\n            q1.A * q2.C - q1.B * q2.D + q1.C * q2.A + q1.D * q2.B,\n            q1.A * q2.D + q1.B * q2.C - q1.C * q2.B + q1.D * q2.A);\n    }\n\n    public static bool operator ==(Quaternion q1, Quaternion q2)\n    {\n        return q1.A == q2.A && q1.B == q2.B && q1.C == q2.C && q1.D == q2.D;\n    }\n\n    public static bool operator !=(Quaternion q1, Quaternion q2)\n    {\n        return !(q1 == q2);\n    }\n\n    #region Object Members\n\n    public override bool Equals(object obj)\n    {\n        if (obj is Quaternion)\n            return Equals((Quaternion)obj);\n\n        return false;\n    }\n\n    public override int GetHashCode()\n    {\n        return A.GetHashCode() ^ B.GetHashCode() ^ C.GetHashCode() ^ D.GetHashCode();\n    }\n\n    public override string ToString()\n    {\n        return string.Format(\"Q({0}, {1}, {2}, {3})\", A, B, C, D);\n    }\n\n    #endregion\n\n    #region IEquatable<Quaternion> Members\n\n    public bool Equals(Quaternion other)\n    {\n        return other == this;\n    }\n\n    #endregion\n}\n"}
{"id": 37516, "name": "Quaternion type", "source": "Translate Fortran to Java: module Q_mod\n  implicit none\n\n  type quaternion\n    real :: a, b, c, d\n  end type\n\n  public :: norm, neg, conj\n  public :: operator (+)\n  public :: operator (*)\n  \n  private ::  q_plus_q, q_plus_r, r_plus_q, &\n              q_mult_q, q_mult_r, r_mult_q, &\n              norm_q, neg_q, conj_q\n\n  interface norm\n    module procedure norm_q\n  end interface\n\n  interface neg\n    module procedure neg_q\n  end interface\n\n  interface conj\n    module procedure conj_q\n  end interface\n\n  interface operator (+)\n    module procedure q_plus_q, q_plus_r, r_plus_q\n  end interface\n\n  interface operator (*)\n    module procedure q_mult_q, q_mult_r, r_mult_q\n  end interface\n\ncontains\n\nfunction norm_q(x) result(res)\n  real :: res\n  type (quaternion), intent (in) :: x\n\n  res = sqrt(x%a*x%a + x%b*x%b + x%c*x%c + x%d*x%d)\n  \nend function norm_q\n\nfunction neg_q(x) result(res)\n  type (quaternion) :: res\n  type (quaternion), intent (in) :: x\n\n  res%a = -x%a\n  res%b = -x%b\n  res%c = -x%c\n  res%d = -x%d\n  \nend function neg_q\n\nfunction conj_q(x) result(res)\n  type (quaternion) :: res\n  type (quaternion), intent (in) :: x\n\n  res%a = x%a\n  res%b = -x%b\n  res%c = -x%c\n  res%d = -x%d\n  \nend function conj_q\n\nfunction q_plus_q(x, y) result (res)\n  type (quaternion) :: res\n  type (quaternion), intent (in) :: x, y\n   \n  res%a = x%a + y%a\n  res%b = x%b + y%b\n  res%c = x%c + y%c\n  res%d = x%d + y%d\n   \nend function q_plus_q\n\nfunction q_plus_r(x, r) result (res)\n  type (quaternion) :: res \n  type (quaternion), intent (in) :: x\n  real, intent(in) :: r\n   \n   res = x\n   res%a = x%a + r\n   \nend function q_plus_r\n\nfunction r_plus_q(r, x) result (res)\n  type (quaternion) :: res \n  type (quaternion), intent (in) :: x\n  real, intent(in) :: r\n   \n   res = x\n   res%a = x%a + r\n   \nend function r_plus_q\n\nfunction q_mult_q(x, y) result (res)\n  type (quaternion) :: res \n  type (quaternion), intent (in) :: x, y\n   \n   res%a = x%a*y%a - x%b*y%b - x%c*y%c - x%d*y%d\n   res%b = x%a*y%b + x%b*y%a + x%c*y%d - x%d*y%c\n   res%c = x%a*y%c - x%b*y%d + x%c*y%a + x%d*y%b\n   res%d = x%a*y%d + x%b*y%c - x%c*y%b + x%d*y%a\n   \nend function q_mult_q\n\nfunction q_mult_r(x, r) result (res)\n  type (quaternion) :: res \n  type (quaternion), intent (in) :: x\n  real, intent(in) ::  r\n   \n   res%a = x%a*r\n   res%b = x%b*r\n   res%c = x%c*r  \n   res%d = x%d*r \n   \nend function q_mult_r\n\nfunction r_mult_q(r, x) result (res)\n  type (quaternion) :: res \n  type (quaternion), intent (in) :: x\n  real, intent(in) ::  r\n   \n   res%a = x%a*r\n   res%b = x%b*r\n   res%c = x%c*r  \n   res%d = x%d*r \n   \nend function r_mult_q\nend module Q_mod\n\nprogram Quaternions\n  use Q_mod\n  implicit none\n\n  real :: r = 7.0\n  type(quaternion) :: q, q1, q2\n\n  q  = quaternion(1, 2, 3, 4)\n  q1 = quaternion(2, 3, 4, 5)\n  q2 = quaternion(3, 4, 5, 6)\n\n  write(*, \"(a, 4f8.3)\") \"             q = \", q\n  write(*, \"(a, 4f8.3)\") \"            q1 = \", q1\n  write(*, \"(a, 4f8.3)\") \"            q2 = \", q2\n  write(*, \"(a, f8.3)\")  \"             r = \", r\n  write(*, \"(a, f8.3)\")  \"     Norm of q = \", norm(q) \n  write(*, \"(a, 4f8.3)\") \" Negative of q = \", neg(q)\n  write(*, \"(a, 4f8.3)\") \"Conjugate of q = \", conj(q) \n  write(*, \"(a, 4f8.3)\") \"         q + r = \", q + r\n  write(*, \"(a, 4f8.3)\") \"         r + q = \", r + q\n  write(*, \"(a, 4f8.3)\") \"       q1 + q2 = \", q1 + q2\n  write(*, \"(a, 4f8.3)\") \"         q * r = \", q * r  \n  write(*, \"(a, 4f8.3)\") \"         r * q = \", r * q \n  write(*, \"(a, 4f8.3)\") \"       q1 * q2 = \", q1 * q2 \n  write(*, \"(a, 4f8.3)\") \"       q2 * q1 = \", q2 * q1 \n\nend program\n", "target": "public class Quaternion {\n    private final double a, b, c, d;\n\n    public Quaternion(double a, double b, double c, double d) {\n        this.a = a;\n        this.b = b;\n        this.c = c;\n        this.d = d;\n    }\n    public Quaternion(double r) {\n        this(r, 0.0, 0.0, 0.0);\n    }\n\n    public double norm() {\n        return Math.sqrt(a * a + b * b + c * c + d * d);\n    }\n\n    public Quaternion negative() {\n        return new Quaternion(-a, -b, -c, -d);\n    }\n\n    public Quaternion conjugate() {\n        return new Quaternion(a, -b, -c, -d);\n    }\n\n    public Quaternion add(double r) {\n        return new Quaternion(a + r, b, c, d);\n    }\n    public static Quaternion add(Quaternion q, double r) {\n        return q.add(r);\n    }\n    public static Quaternion add(double r, Quaternion q) {\n        return q.add(r);\n    }\n    public Quaternion add(Quaternion q) {\n        return new Quaternion(a + q.a, b + q.b, c + q.c, d + q.d);\n    }\n    public static Quaternion add(Quaternion q1, Quaternion q2) {\n        return q1.add(q2);\n    }\n\n    public Quaternion times(double r) {\n        return new Quaternion(a * r, b * r, c * r, d * r);\n    }\n    public static Quaternion times(Quaternion q, double r) {\n        return q.times(r);\n    }\n    public static Quaternion times(double r, Quaternion q) {\n        return q.times(r);\n    }\n    public Quaternion times(Quaternion q) {\n        return new Quaternion(\n            a * q.a - b * q.b - c * q.c - d * q.d,\n            a * q.b + b * q.a + c * q.d - d * q.c,\n            a * q.c - b * q.d + c * q.a + d * q.b,\n            a * q.d + b * q.c - c * q.b + d * q.a\n        );\n    }\n    public static Quaternion times(Quaternion q1, Quaternion q2) {\n        return q1.times(q2);\n    }\n\n    @Override\n    public boolean equals(Object obj) {\n        if (!(obj instanceof Quaternion)) return false;\n        final Quaternion other = (Quaternion) obj;\n        if (Double.doubleToLongBits(this.a) != Double.doubleToLongBits(other.a)) return false;\n        if (Double.doubleToLongBits(this.b) != Double.doubleToLongBits(other.b)) return false;\n        if (Double.doubleToLongBits(this.c) != Double.doubleToLongBits(other.c)) return false;\n        if (Double.doubleToLongBits(this.d) != Double.doubleToLongBits(other.d)) return false;\n        return true;\n    }\n    @Override\n    public String toString() {\n        return String.format(\"%.2f +\u00a0%.2fi +\u00a0%.2fj +\u00a0%.2fk\", a, b, c, d).replaceAll(\"\\\\+ -\", \"- \");\n    }\n\n    public String toQuadruple() {\n        return String.format(\"(%.2f,\u00a0%.2f,\u00a0%.2f,\u00a0%.2f)\", a, b, c, d);\n    }\n\n    public static void main(String[] args) {\n        Quaternion q = new Quaternion(1.0, 2.0, 3.0, 4.0);\n        Quaternion q1 = new Quaternion(2.0, 3.0, 4.0, 5.0);\n        Quaternion q2 = new Quaternion(3.0, 4.0, 5.0, 6.0);\n        double r = 7.0;\n        System.out.format(\"q       = %s%n\", q);\n        System.out.format(\"q1      = %s%n\", q1);\n        System.out.format(\"q2      = %s%n\", q2);\n        System.out.format(\"r       =\u00a0%.2f%n%n\", r);\n        System.out.format(\"\\u2016q\\u2016     =\u00a0%.2f%n\", q.norm());\n        System.out.format(\"-q      = %s%n\", q.negative());\n        System.out.format(\"q*      = %s%n\", q.conjugate());\n        System.out.format(\"q + r   = %s%n\", q.add(r));\n        System.out.format(\"q1 + q2 = %s%n\", q1.add(q2));\n        System.out.format(\"q \\u00d7 r   = %s%n\", q.times(r));\n        Quaternion q1q2 = q1.times(q2);\n        Quaternion q2q1 = q2.times(q1);\n        System.out.format(\"q1 \\u00d7 q2 = %s%n\", q1q2);\n        System.out.format(\"q2 \\u00d7 q1 = %s%n\", q2q1);\n        System.out.format(\"q1 \\u00d7 q2 %s q2 \\u00d7 q1%n\", (q1q2.equals(q2q1) ? \"=\" : \"\\u2260\"));\n    }\n}\n"}
{"id": 37517, "name": "Quaternion type", "source": "Translate Fortran to Java: module Q_mod\n  implicit none\n\n  type quaternion\n    real :: a, b, c, d\n  end type\n\n  public :: norm, neg, conj\n  public :: operator (+)\n  public :: operator (*)\n  \n  private ::  q_plus_q, q_plus_r, r_plus_q, &\n              q_mult_q, q_mult_r, r_mult_q, &\n              norm_q, neg_q, conj_q\n\n  interface norm\n    module procedure norm_q\n  end interface\n\n  interface neg\n    module procedure neg_q\n  end interface\n\n  interface conj\n    module procedure conj_q\n  end interface\n\n  interface operator (+)\n    module procedure q_plus_q, q_plus_r, r_plus_q\n  end interface\n\n  interface operator (*)\n    module procedure q_mult_q, q_mult_r, r_mult_q\n  end interface\n\ncontains\n\nfunction norm_q(x) result(res)\n  real :: res\n  type (quaternion), intent (in) :: x\n\n  res = sqrt(x%a*x%a + x%b*x%b + x%c*x%c + x%d*x%d)\n  \nend function norm_q\n\nfunction neg_q(x) result(res)\n  type (quaternion) :: res\n  type (quaternion), intent (in) :: x\n\n  res%a = -x%a\n  res%b = -x%b\n  res%c = -x%c\n  res%d = -x%d\n  \nend function neg_q\n\nfunction conj_q(x) result(res)\n  type (quaternion) :: res\n  type (quaternion), intent (in) :: x\n\n  res%a = x%a\n  res%b = -x%b\n  res%c = -x%c\n  res%d = -x%d\n  \nend function conj_q\n\nfunction q_plus_q(x, y) result (res)\n  type (quaternion) :: res\n  type (quaternion), intent (in) :: x, y\n   \n  res%a = x%a + y%a\n  res%b = x%b + y%b\n  res%c = x%c + y%c\n  res%d = x%d + y%d\n   \nend function q_plus_q\n\nfunction q_plus_r(x, r) result (res)\n  type (quaternion) :: res \n  type (quaternion), intent (in) :: x\n  real, intent(in) :: r\n   \n   res = x\n   res%a = x%a + r\n   \nend function q_plus_r\n\nfunction r_plus_q(r, x) result (res)\n  type (quaternion) :: res \n  type (quaternion), intent (in) :: x\n  real, intent(in) :: r\n   \n   res = x\n   res%a = x%a + r\n   \nend function r_plus_q\n\nfunction q_mult_q(x, y) result (res)\n  type (quaternion) :: res \n  type (quaternion), intent (in) :: x, y\n   \n   res%a = x%a*y%a - x%b*y%b - x%c*y%c - x%d*y%d\n   res%b = x%a*y%b + x%b*y%a + x%c*y%d - x%d*y%c\n   res%c = x%a*y%c - x%b*y%d + x%c*y%a + x%d*y%b\n   res%d = x%a*y%d + x%b*y%c - x%c*y%b + x%d*y%a\n   \nend function q_mult_q\n\nfunction q_mult_r(x, r) result (res)\n  type (quaternion) :: res \n  type (quaternion), intent (in) :: x\n  real, intent(in) ::  r\n   \n   res%a = x%a*r\n   res%b = x%b*r\n   res%c = x%c*r  \n   res%d = x%d*r \n   \nend function q_mult_r\n\nfunction r_mult_q(r, x) result (res)\n  type (quaternion) :: res \n  type (quaternion), intent (in) :: x\n  real, intent(in) ::  r\n   \n   res%a = x%a*r\n   res%b = x%b*r\n   res%c = x%c*r  \n   res%d = x%d*r \n   \nend function r_mult_q\nend module Q_mod\n\nprogram Quaternions\n  use Q_mod\n  implicit none\n\n  real :: r = 7.0\n  type(quaternion) :: q, q1, q2\n\n  q  = quaternion(1, 2, 3, 4)\n  q1 = quaternion(2, 3, 4, 5)\n  q2 = quaternion(3, 4, 5, 6)\n\n  write(*, \"(a, 4f8.3)\") \"             q = \", q\n  write(*, \"(a, 4f8.3)\") \"            q1 = \", q1\n  write(*, \"(a, 4f8.3)\") \"            q2 = \", q2\n  write(*, \"(a, f8.3)\")  \"             r = \", r\n  write(*, \"(a, f8.3)\")  \"     Norm of q = \", norm(q) \n  write(*, \"(a, 4f8.3)\") \" Negative of q = \", neg(q)\n  write(*, \"(a, 4f8.3)\") \"Conjugate of q = \", conj(q) \n  write(*, \"(a, 4f8.3)\") \"         q + r = \", q + r\n  write(*, \"(a, 4f8.3)\") \"         r + q = \", r + q\n  write(*, \"(a, 4f8.3)\") \"       q1 + q2 = \", q1 + q2\n  write(*, \"(a, 4f8.3)\") \"         q * r = \", q * r  \n  write(*, \"(a, 4f8.3)\") \"         r * q = \", r * q \n  write(*, \"(a, 4f8.3)\") \"       q1 * q2 = \", q1 * q2 \n  write(*, \"(a, 4f8.3)\") \"       q2 * q1 = \", q2 * q1 \n\nend program\n", "target": "public class Quaternion {\n    private final double a, b, c, d;\n\n    public Quaternion(double a, double b, double c, double d) {\n        this.a = a;\n        this.b = b;\n        this.c = c;\n        this.d = d;\n    }\n    public Quaternion(double r) {\n        this(r, 0.0, 0.0, 0.0);\n    }\n\n    public double norm() {\n        return Math.sqrt(a * a + b * b + c * c + d * d);\n    }\n\n    public Quaternion negative() {\n        return new Quaternion(-a, -b, -c, -d);\n    }\n\n    public Quaternion conjugate() {\n        return new Quaternion(a, -b, -c, -d);\n    }\n\n    public Quaternion add(double r) {\n        return new Quaternion(a + r, b, c, d);\n    }\n    public static Quaternion add(Quaternion q, double r) {\n        return q.add(r);\n    }\n    public static Quaternion add(double r, Quaternion q) {\n        return q.add(r);\n    }\n    public Quaternion add(Quaternion q) {\n        return new Quaternion(a + q.a, b + q.b, c + q.c, d + q.d);\n    }\n    public static Quaternion add(Quaternion q1, Quaternion q2) {\n        return q1.add(q2);\n    }\n\n    public Quaternion times(double r) {\n        return new Quaternion(a * r, b * r, c * r, d * r);\n    }\n    public static Quaternion times(Quaternion q, double r) {\n        return q.times(r);\n    }\n    public static Quaternion times(double r, Quaternion q) {\n        return q.times(r);\n    }\n    public Quaternion times(Quaternion q) {\n        return new Quaternion(\n            a * q.a - b * q.b - c * q.c - d * q.d,\n            a * q.b + b * q.a + c * q.d - d * q.c,\n            a * q.c - b * q.d + c * q.a + d * q.b,\n            a * q.d + b * q.c - c * q.b + d * q.a\n        );\n    }\n    public static Quaternion times(Quaternion q1, Quaternion q2) {\n        return q1.times(q2);\n    }\n\n    @Override\n    public boolean equals(Object obj) {\n        if (!(obj instanceof Quaternion)) return false;\n        final Quaternion other = (Quaternion) obj;\n        if (Double.doubleToLongBits(this.a) != Double.doubleToLongBits(other.a)) return false;\n        if (Double.doubleToLongBits(this.b) != Double.doubleToLongBits(other.b)) return false;\n        if (Double.doubleToLongBits(this.c) != Double.doubleToLongBits(other.c)) return false;\n        if (Double.doubleToLongBits(this.d) != Double.doubleToLongBits(other.d)) return false;\n        return true;\n    }\n    @Override\n    public String toString() {\n        return String.format(\"%.2f +\u00a0%.2fi +\u00a0%.2fj +\u00a0%.2fk\", a, b, c, d).replaceAll(\"\\\\+ -\", \"- \");\n    }\n\n    public String toQuadruple() {\n        return String.format(\"(%.2f,\u00a0%.2f,\u00a0%.2f,\u00a0%.2f)\", a, b, c, d);\n    }\n\n    public static void main(String[] args) {\n        Quaternion q = new Quaternion(1.0, 2.0, 3.0, 4.0);\n        Quaternion q1 = new Quaternion(2.0, 3.0, 4.0, 5.0);\n        Quaternion q2 = new Quaternion(3.0, 4.0, 5.0, 6.0);\n        double r = 7.0;\n        System.out.format(\"q       = %s%n\", q);\n        System.out.format(\"q1      = %s%n\", q1);\n        System.out.format(\"q2      = %s%n\", q2);\n        System.out.format(\"r       =\u00a0%.2f%n%n\", r);\n        System.out.format(\"\\u2016q\\u2016     =\u00a0%.2f%n\", q.norm());\n        System.out.format(\"-q      = %s%n\", q.negative());\n        System.out.format(\"q*      = %s%n\", q.conjugate());\n        System.out.format(\"q + r   = %s%n\", q.add(r));\n        System.out.format(\"q1 + q2 = %s%n\", q1.add(q2));\n        System.out.format(\"q \\u00d7 r   = %s%n\", q.times(r));\n        Quaternion q1q2 = q1.times(q2);\n        Quaternion q2q1 = q2.times(q1);\n        System.out.format(\"q1 \\u00d7 q2 = %s%n\", q1q2);\n        System.out.format(\"q2 \\u00d7 q1 = %s%n\", q2q1);\n        System.out.format(\"q1 \\u00d7 q2 %s q2 \\u00d7 q1%n\", (q1q2.equals(q2q1) ? \"=\" : \"\\u2260\"));\n    }\n}\n"}
{"id": 37518, "name": "Quaternion type", "source": "Translate Fortran to Python: module Q_mod\n  implicit none\n\n  type quaternion\n    real :: a, b, c, d\n  end type\n\n  public :: norm, neg, conj\n  public :: operator (+)\n  public :: operator (*)\n  \n  private ::  q_plus_q, q_plus_r, r_plus_q, &\n              q_mult_q, q_mult_r, r_mult_q, &\n              norm_q, neg_q, conj_q\n\n  interface norm\n    module procedure norm_q\n  end interface\n\n  interface neg\n    module procedure neg_q\n  end interface\n\n  interface conj\n    module procedure conj_q\n  end interface\n\n  interface operator (+)\n    module procedure q_plus_q, q_plus_r, r_plus_q\n  end interface\n\n  interface operator (*)\n    module procedure q_mult_q, q_mult_r, r_mult_q\n  end interface\n\ncontains\n\nfunction norm_q(x) result(res)\n  real :: res\n  type (quaternion), intent (in) :: x\n\n  res = sqrt(x%a*x%a + x%b*x%b + x%c*x%c + x%d*x%d)\n  \nend function norm_q\n\nfunction neg_q(x) result(res)\n  type (quaternion) :: res\n  type (quaternion), intent (in) :: x\n\n  res%a = -x%a\n  res%b = -x%b\n  res%c = -x%c\n  res%d = -x%d\n  \nend function neg_q\n\nfunction conj_q(x) result(res)\n  type (quaternion) :: res\n  type (quaternion), intent (in) :: x\n\n  res%a = x%a\n  res%b = -x%b\n  res%c = -x%c\n  res%d = -x%d\n  \nend function conj_q\n\nfunction q_plus_q(x, y) result (res)\n  type (quaternion) :: res\n  type (quaternion), intent (in) :: x, y\n   \n  res%a = x%a + y%a\n  res%b = x%b + y%b\n  res%c = x%c + y%c\n  res%d = x%d + y%d\n   \nend function q_plus_q\n\nfunction q_plus_r(x, r) result (res)\n  type (quaternion) :: res \n  type (quaternion), intent (in) :: x\n  real, intent(in) :: r\n   \n   res = x\n   res%a = x%a + r\n   \nend function q_plus_r\n\nfunction r_plus_q(r, x) result (res)\n  type (quaternion) :: res \n  type (quaternion), intent (in) :: x\n  real, intent(in) :: r\n   \n   res = x\n   res%a = x%a + r\n   \nend function r_plus_q\n\nfunction q_mult_q(x, y) result (res)\n  type (quaternion) :: res \n  type (quaternion), intent (in) :: x, y\n   \n   res%a = x%a*y%a - x%b*y%b - x%c*y%c - x%d*y%d\n   res%b = x%a*y%b + x%b*y%a + x%c*y%d - x%d*y%c\n   res%c = x%a*y%c - x%b*y%d + x%c*y%a + x%d*y%b\n   res%d = x%a*y%d + x%b*y%c - x%c*y%b + x%d*y%a\n   \nend function q_mult_q\n\nfunction q_mult_r(x, r) result (res)\n  type (quaternion) :: res \n  type (quaternion), intent (in) :: x\n  real, intent(in) ::  r\n   \n   res%a = x%a*r\n   res%b = x%b*r\n   res%c = x%c*r  \n   res%d = x%d*r \n   \nend function q_mult_r\n\nfunction r_mult_q(r, x) result (res)\n  type (quaternion) :: res \n  type (quaternion), intent (in) :: x\n  real, intent(in) ::  r\n   \n   res%a = x%a*r\n   res%b = x%b*r\n   res%c = x%c*r  \n   res%d = x%d*r \n   \nend function r_mult_q\nend module Q_mod\n\nprogram Quaternions\n  use Q_mod\n  implicit none\n\n  real :: r = 7.0\n  type(quaternion) :: q, q1, q2\n\n  q  = quaternion(1, 2, 3, 4)\n  q1 = quaternion(2, 3, 4, 5)\n  q2 = quaternion(3, 4, 5, 6)\n\n  write(*, \"(a, 4f8.3)\") \"             q = \", q\n  write(*, \"(a, 4f8.3)\") \"            q1 = \", q1\n  write(*, \"(a, 4f8.3)\") \"            q2 = \", q2\n  write(*, \"(a, f8.3)\")  \"             r = \", r\n  write(*, \"(a, f8.3)\")  \"     Norm of q = \", norm(q) \n  write(*, \"(a, 4f8.3)\") \" Negative of q = \", neg(q)\n  write(*, \"(a, 4f8.3)\") \"Conjugate of q = \", conj(q) \n  write(*, \"(a, 4f8.3)\") \"         q + r = \", q + r\n  write(*, \"(a, 4f8.3)\") \"         r + q = \", r + q\n  write(*, \"(a, 4f8.3)\") \"       q1 + q2 = \", q1 + q2\n  write(*, \"(a, 4f8.3)\") \"         q * r = \", q * r  \n  write(*, \"(a, 4f8.3)\") \"         r * q = \", r * q \n  write(*, \"(a, 4f8.3)\") \"       q1 * q2 = \", q1 * q2 \n  write(*, \"(a, 4f8.3)\") \"       q2 * q1 = \", q2 * q1 \n\nend program\n", "target": "from collections import namedtuple\nimport math\n\nclass Q(namedtuple('Quaternion', 'real, i, j, k')):\n    'Quaternion type: Q(real=0.0, i=0.0, j=0.0, k=0.0)' \n\n    __slots__ = () \n\n    def __new__(_cls, real=0.0, i=0.0, j=0.0, k=0.0):\n        'Defaults all parts of quaternion to zero'\n        return super().__new__(_cls, float(real), float(i), float(j), float(k))\n\n    def conjugate(self):\n        return Q(self.real, -self.i, -self.j, -self.k)\n\n    def _norm2(self):\n        return sum( x*x for x in self)\n\n    def norm(self):\n        return math.sqrt(self._norm2())\n\n    def reciprocal(self):\n        n2 = self._norm2()\n        return Q(*(x / n2 for x in self.conjugate())) \n\n    def __str__(self):\n        'Shorter form of Quaternion as string'\n        return 'Q(%g, %g, %g, %g)' % self\n\n    def __neg__(self):\n        return Q(-self.real, -self.i, -self.j, -self.k)\n\n    def __add__(self, other):\n        if type(other) == Q:\n            return Q( *(s+o for s,o in zip(self, other)) )\n        try:\n            f = float(other)\n        except:\n            return NotImplemented\n        return Q(self.real + f, self.i, self.j, self.k)\n\n    def __radd__(self, other):\n        return Q.__add__(self, other)\n\n    def __mul__(self, other):\n        if type(other) == Q:\n            a1,b1,c1,d1 = self\n            a2,b2,c2,d2 = other\n            return Q(\n                 a1*a2 - b1*b2 - c1*c2 - d1*d2,\n                 a1*b2 + b1*a2 + c1*d2 - d1*c2,\n                 a1*c2 - b1*d2 + c1*a2 + d1*b2,\n                 a1*d2 + b1*c2 - c1*b2 + d1*a2 )\n        try:\n            f = float(other)\n        except:\n            return NotImplemented\n        return Q(self.real * f, self.i * f, self.j * f, self.k * f)\n\n    def __rmul__(self, other):\n        return Q.__mul__(self, other)\n\n    def __truediv__(self, other):\n        if type(other) == Q:\n            return self.__mul__(other.reciprocal())\n        try:\n            f = float(other)\n        except:\n            return NotImplemented\n        return Q(self.real / f, self.i / f, self.j / f, self.k / f)\n\n    def __rtruediv__(self, other):\n        return other * self.reciprocal()\n\n    __div__, __rdiv__ = __truediv__, __rtruediv__\n\nQuaternion = Q       \n\nq  = Q(1, 2, 3, 4)\nq1 = Q(2, 3, 4, 5)\nq2 = Q(3, 4, 5, 6)\nr  = 7\n"}
{"id": 37519, "name": "Quaternion type", "source": "Translate Fortran to Python: module Q_mod\n  implicit none\n\n  type quaternion\n    real :: a, b, c, d\n  end type\n\n  public :: norm, neg, conj\n  public :: operator (+)\n  public :: operator (*)\n  \n  private ::  q_plus_q, q_plus_r, r_plus_q, &\n              q_mult_q, q_mult_r, r_mult_q, &\n              norm_q, neg_q, conj_q\n\n  interface norm\n    module procedure norm_q\n  end interface\n\n  interface neg\n    module procedure neg_q\n  end interface\n\n  interface conj\n    module procedure conj_q\n  end interface\n\n  interface operator (+)\n    module procedure q_plus_q, q_plus_r, r_plus_q\n  end interface\n\n  interface operator (*)\n    module procedure q_mult_q, q_mult_r, r_mult_q\n  end interface\n\ncontains\n\nfunction norm_q(x) result(res)\n  real :: res\n  type (quaternion), intent (in) :: x\n\n  res = sqrt(x%a*x%a + x%b*x%b + x%c*x%c + x%d*x%d)\n  \nend function norm_q\n\nfunction neg_q(x) result(res)\n  type (quaternion) :: res\n  type (quaternion), intent (in) :: x\n\n  res%a = -x%a\n  res%b = -x%b\n  res%c = -x%c\n  res%d = -x%d\n  \nend function neg_q\n\nfunction conj_q(x) result(res)\n  type (quaternion) :: res\n  type (quaternion), intent (in) :: x\n\n  res%a = x%a\n  res%b = -x%b\n  res%c = -x%c\n  res%d = -x%d\n  \nend function conj_q\n\nfunction q_plus_q(x, y) result (res)\n  type (quaternion) :: res\n  type (quaternion), intent (in) :: x, y\n   \n  res%a = x%a + y%a\n  res%b = x%b + y%b\n  res%c = x%c + y%c\n  res%d = x%d + y%d\n   \nend function q_plus_q\n\nfunction q_plus_r(x, r) result (res)\n  type (quaternion) :: res \n  type (quaternion), intent (in) :: x\n  real, intent(in) :: r\n   \n   res = x\n   res%a = x%a + r\n   \nend function q_plus_r\n\nfunction r_plus_q(r, x) result (res)\n  type (quaternion) :: res \n  type (quaternion), intent (in) :: x\n  real, intent(in) :: r\n   \n   res = x\n   res%a = x%a + r\n   \nend function r_plus_q\n\nfunction q_mult_q(x, y) result (res)\n  type (quaternion) :: res \n  type (quaternion), intent (in) :: x, y\n   \n   res%a = x%a*y%a - x%b*y%b - x%c*y%c - x%d*y%d\n   res%b = x%a*y%b + x%b*y%a + x%c*y%d - x%d*y%c\n   res%c = x%a*y%c - x%b*y%d + x%c*y%a + x%d*y%b\n   res%d = x%a*y%d + x%b*y%c - x%c*y%b + x%d*y%a\n   \nend function q_mult_q\n\nfunction q_mult_r(x, r) result (res)\n  type (quaternion) :: res \n  type (quaternion), intent (in) :: x\n  real, intent(in) ::  r\n   \n   res%a = x%a*r\n   res%b = x%b*r\n   res%c = x%c*r  \n   res%d = x%d*r \n   \nend function q_mult_r\n\nfunction r_mult_q(r, x) result (res)\n  type (quaternion) :: res \n  type (quaternion), intent (in) :: x\n  real, intent(in) ::  r\n   \n   res%a = x%a*r\n   res%b = x%b*r\n   res%c = x%c*r  \n   res%d = x%d*r \n   \nend function r_mult_q\nend module Q_mod\n\nprogram Quaternions\n  use Q_mod\n  implicit none\n\n  real :: r = 7.0\n  type(quaternion) :: q, q1, q2\n\n  q  = quaternion(1, 2, 3, 4)\n  q1 = quaternion(2, 3, 4, 5)\n  q2 = quaternion(3, 4, 5, 6)\n\n  write(*, \"(a, 4f8.3)\") \"             q = \", q\n  write(*, \"(a, 4f8.3)\") \"            q1 = \", q1\n  write(*, \"(a, 4f8.3)\") \"            q2 = \", q2\n  write(*, \"(a, f8.3)\")  \"             r = \", r\n  write(*, \"(a, f8.3)\")  \"     Norm of q = \", norm(q) \n  write(*, \"(a, 4f8.3)\") \" Negative of q = \", neg(q)\n  write(*, \"(a, 4f8.3)\") \"Conjugate of q = \", conj(q) \n  write(*, \"(a, 4f8.3)\") \"         q + r = \", q + r\n  write(*, \"(a, 4f8.3)\") \"         r + q = \", r + q\n  write(*, \"(a, 4f8.3)\") \"       q1 + q2 = \", q1 + q2\n  write(*, \"(a, 4f8.3)\") \"         q * r = \", q * r  \n  write(*, \"(a, 4f8.3)\") \"         r * q = \", r * q \n  write(*, \"(a, 4f8.3)\") \"       q1 * q2 = \", q1 * q2 \n  write(*, \"(a, 4f8.3)\") \"       q2 * q1 = \", q2 * q1 \n\nend program\n", "target": "from collections import namedtuple\nimport math\n\nclass Q(namedtuple('Quaternion', 'real, i, j, k')):\n    'Quaternion type: Q(real=0.0, i=0.0, j=0.0, k=0.0)' \n\n    __slots__ = () \n\n    def __new__(_cls, real=0.0, i=0.0, j=0.0, k=0.0):\n        'Defaults all parts of quaternion to zero'\n        return super().__new__(_cls, float(real), float(i), float(j), float(k))\n\n    def conjugate(self):\n        return Q(self.real, -self.i, -self.j, -self.k)\n\n    def _norm2(self):\n        return sum( x*x for x in self)\n\n    def norm(self):\n        return math.sqrt(self._norm2())\n\n    def reciprocal(self):\n        n2 = self._norm2()\n        return Q(*(x / n2 for x in self.conjugate())) \n\n    def __str__(self):\n        'Shorter form of Quaternion as string'\n        return 'Q(%g, %g, %g, %g)' % self\n\n    def __neg__(self):\n        return Q(-self.real, -self.i, -self.j, -self.k)\n\n    def __add__(self, other):\n        if type(other) == Q:\n            return Q( *(s+o for s,o in zip(self, other)) )\n        try:\n            f = float(other)\n        except:\n            return NotImplemented\n        return Q(self.real + f, self.i, self.j, self.k)\n\n    def __radd__(self, other):\n        return Q.__add__(self, other)\n\n    def __mul__(self, other):\n        if type(other) == Q:\n            a1,b1,c1,d1 = self\n            a2,b2,c2,d2 = other\n            return Q(\n                 a1*a2 - b1*b2 - c1*c2 - d1*d2,\n                 a1*b2 + b1*a2 + c1*d2 - d1*c2,\n                 a1*c2 - b1*d2 + c1*a2 + d1*b2,\n                 a1*d2 + b1*c2 - c1*b2 + d1*a2 )\n        try:\n            f = float(other)\n        except:\n            return NotImplemented\n        return Q(self.real * f, self.i * f, self.j * f, self.k * f)\n\n    def __rmul__(self, other):\n        return Q.__mul__(self, other)\n\n    def __truediv__(self, other):\n        if type(other) == Q:\n            return self.__mul__(other.reciprocal())\n        try:\n            f = float(other)\n        except:\n            return NotImplemented\n        return Q(self.real / f, self.i / f, self.j / f, self.k / f)\n\n    def __rtruediv__(self, other):\n        return other * self.reciprocal()\n\n    __div__, __rdiv__ = __truediv__, __rtruediv__\n\nQuaternion = Q       \n\nq  = Q(1, 2, 3, 4)\nq1 = Q(2, 3, 4, 5)\nq2 = Q(3, 4, 5, 6)\nr  = 7\n"}
{"id": 37792, "name": "QR decomposition", "source": "Translate Fortran to C#: program qrtask\n    implicit none\n    integer, parameter :: n = 4\n    real(8) :: durer(n, n) = reshape(dble([ &\n        16,  5,  9,  4, &\n         3, 10,  6, 15, &\n         2, 11,  7, 14, &\n        13,  8, 12,  1  &\n    ]), [n, n])\n    real(8) :: q(n, n), r(n, n), qr(n, n), id(n, n), tau(n)\n    integer, parameter :: lwork = 1024\n    real(8) :: work(lwork)\n    integer :: info, i, j\n \n    q = durer\n    call dgeqrf(n, n, q, n, tau, work, lwork, info)\n \n    r = 0d0\n    forall (i = 1:n, j = 1:n, j >= i) r(i, j) = q(i, j)\n \n    call dorgqr(n, n, n, q, n, tau, work, lwork, info)\n \n    qr = matmul(q, r)\n    id = matmul(q, transpose(q))\n \n    call show(4, durer, \"A\")\n    call show(4, q, \"Q\")\n    call show(4, r, \"R\")\n    call show(4, qr, \"Q*R\")\n    call show(4, id, \"Q*Q'\")\ncontains\n    subroutine show(n, a, s)\n        character(*) :: s\n        integer :: n, i\n        real(8) :: a(n, n)\n \n        print *, s\n        do i = 1, n\n            print 1, a(i, :)\n          1 format (*(f12.6,:,' '))\n        end do\n    end subroutine\nend program\n", "target": "using System;\nusing MathNet.Numerics.LinearAlgebra;\nusing MathNet.Numerics.LinearAlgebra.Double;\n\n\nclass Program\n{\n\n    static void Main(string[] args)\n    {\n        Matrix<double> A = DenseMatrix.OfArray(new double[,]\n        {\n                {  12,  -51,    4 },\n                {   6,  167,  -68 },\n                {  -4,   24,  -41 }\n        });\n        Console.WriteLine(\"A:\");\n        Console.WriteLine(A);\n        var qr = A.QR();\n        Console.WriteLine();\n        Console.WriteLine(\"Q:\");\n        Console.WriteLine(qr.Q);\n        Console.WriteLine();\n        Console.WriteLine(\"R:\");\n        Console.WriteLine(qr.R);\n    }\n}\n"}
{"id": 37795, "name": "QR decomposition", "source": "Translate Fortran to Java: program qrtask\n    implicit none\n    integer, parameter :: n = 4\n    real(8) :: durer(n, n) = reshape(dble([ &\n        16,  5,  9,  4, &\n         3, 10,  6, 15, &\n         2, 11,  7, 14, &\n        13,  8, 12,  1  &\n    ]), [n, n])\n    real(8) :: q(n, n), r(n, n), qr(n, n), id(n, n), tau(n)\n    integer, parameter :: lwork = 1024\n    real(8) :: work(lwork)\n    integer :: info, i, j\n \n    q = durer\n    call dgeqrf(n, n, q, n, tau, work, lwork, info)\n \n    r = 0d0\n    forall (i = 1:n, j = 1:n, j >= i) r(i, j) = q(i, j)\n \n    call dorgqr(n, n, n, q, n, tau, work, lwork, info)\n \n    qr = matmul(q, r)\n    id = matmul(q, transpose(q))\n \n    call show(4, durer, \"A\")\n    call show(4, q, \"Q\")\n    call show(4, r, \"R\")\n    call show(4, qr, \"Q*R\")\n    call show(4, id, \"Q*Q'\")\ncontains\n    subroutine show(n, a, s)\n        character(*) :: s\n        integer :: n, i\n        real(8) :: a(n, n)\n \n        print *, s\n        do i = 1, n\n            print 1, a(i, :)\n          1 format (*(f12.6,:,' '))\n        end do\n    end subroutine\nend program\n", "target": "import Jama.Matrix;\nimport Jama.QRDecomposition;\n\npublic class Decompose {\n    public static void main(String[] args) {\n        var matrix = new Matrix(new double[][] {\n            {12, -51,   4},\n            { 6, 167, -68},\n            {-4,  24, -41},\n        });\n\n        var qr = new QRDecomposition(matrix);\n        qr.getQ().print(10, 4);\n        qr.getR().print(10, 4);\n    }\n}\n"}
{"id": 37796, "name": "QR decomposition", "source": "Translate Fortran to Python: program qrtask\n    implicit none\n    integer, parameter :: n = 4\n    real(8) :: durer(n, n) = reshape(dble([ &\n        16,  5,  9,  4, &\n         3, 10,  6, 15, &\n         2, 11,  7, 14, &\n        13,  8, 12,  1  &\n    ]), [n, n])\n    real(8) :: q(n, n), r(n, n), qr(n, n), id(n, n), tau(n)\n    integer, parameter :: lwork = 1024\n    real(8) :: work(lwork)\n    integer :: info, i, j\n \n    q = durer\n    call dgeqrf(n, n, q, n, tau, work, lwork, info)\n \n    r = 0d0\n    forall (i = 1:n, j = 1:n, j >= i) r(i, j) = q(i, j)\n \n    call dorgqr(n, n, n, q, n, tau, work, lwork, info)\n \n    qr = matmul(q, r)\n    id = matmul(q, transpose(q))\n \n    call show(4, durer, \"A\")\n    call show(4, q, \"Q\")\n    call show(4, r, \"R\")\n    call show(4, qr, \"Q*R\")\n    call show(4, id, \"Q*Q'\")\ncontains\n    subroutine show(n, a, s)\n        character(*) :: s\n        integer :: n, i\n        real(8) :: a(n, n)\n \n        print *, s\n        do i = 1, n\n            print 1, a(i, :)\n          1 format (*(f12.6,:,' '))\n        end do\n    end subroutine\nend program\n", "target": "\n\nimport numpy as np\n\ndef qr(A):\n    m, n = A.shape\n    Q = np.eye(m)\n    for i in range(n - (m == n)):\n        H = np.eye(m)\n        H[i:, i:] = make_householder(A[i:, i])\n        Q = np.dot(Q, H)\n        A = np.dot(H, A)\n    return Q, A\n\ndef make_householder(a):\n    v = a / (a[0] + np.copysign(np.linalg.norm(a), a[0]))\n    v[0] = 1\n    H = np.eye(a.shape[0])\n    H -= (2 / np.dot(v, v)) * np.dot(v[:, None], v[None, :])\n    return H\n\n\na = np.array(((\n    (12, -51,   4),\n    ( 6, 167, -68),\n    (-4,  24, -41),\n)))\n\nq, r = qr(a)\nprint('q:\\n', q.round(6))\nprint('r:\\n', r.round(6))\n\n\ndef polyfit(x, y, n):\n    return lsqr(x[:, None]**np.arange(n + 1), y.T)\n\ndef lsqr(a, b):\n    q, r = qr(a)\n    _, n = r.shape\n    return np.linalg.solve(r[:n, :], np.dot(q.T, b)[:n])\n\nx = np.array((0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10))\ny = np.array((1, 6, 17, 34, 57, 86, 121, 162, 209, 262, 321))\n\nprint('\\npolyfit:\\n', polyfit(x, y, 2))\n"}
{"id": 37972, "name": "Character codes", "source": "Translate Fortran to C#: WRITE(*,*) ACHAR(97), IACHAR(\"a\")   \nWRITE(*,*) CHAR(97), ICHAR(\"a\")\n", "target": "using System;\n\nnamespace RosettaCode.CharacterCode\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            Console.WriteLine((int) 'a');   \n            Console.WriteLine((char) 97);   \n        }\n    }\n}\n"}
{"id": 37976, "name": "Character codes", "source": "Translate Fortran to Java: WRITE(*,*) ACHAR(97), IACHAR(\"a\")   \nWRITE(*,*) CHAR(97), ICHAR(\"a\")\n", "target": "module CharacterCodes\n    {\n    @Inject Console console;\n    void run()\n        {\n        for (Char char : ['\\0', '\\d', 'A', '$', '\u00a2', '~', '\u02dc'])\n            {\n            \n            UInt32 codepoint = char.codepoint;\n\n            \n            Char fromCodePoint = codepoint.toChar();   \n\n            console.print($|Character {char.quoted()}:\\\n                           | Unicode codepoint={char.codepoint},\\\n                           | ASCII={char.ascii},\\\n                           | UTF8 bytes={char.utf8()},\\\n                           | char from codepoint={fromCodePoint.quoted()}\n                         );\n            }\n        }\n    }\n"}
{"id": 37977, "name": "Character codes", "source": "Translate Fortran to Python: WRITE(*,*) ACHAR(97), IACHAR(\"a\")   \nWRITE(*,*) CHAR(97), ICHAR(\"a\")\n", "target": "print ord('a') \nprint chr(97)  \n"}
{"id": 38420, "name": "Fibonacci n-step number sequences", "source": "Translate Fortran to C#: \n\n\n\n\n\n\n\n\n\n\n\n\n\nprogram f\n  implicit none\n  integer :: n, terms\n  integer, allocatable, dimension(:) :: sequence\n  integer :: i\n  character :: answer\n  write(6,'(a)',advance='no')'Enter the number of terms to sum: '\n  read(5,*) n\n  if ((n < 2) .or. (29 < n)) stop'Unreasonable\n  write(6,'(a)',advance='no')'Show the the first how many terms of the sequence?  '\n  read(5,*) terms\n  if (terms < 1) stop'Lazy programmer has not implemented backward sequences.'\n  n = min(n, terms)\n  allocate(sequence(1:terms))\n  sequence(1) = 1\n  do i = 0, n - 2\n     sequence(i+2) = 2**i\n  end do\n  write(6,*)'Accept this initial sequence (y/n)?'\n  write(6,*) sequence(:n)\n  read(5,*) answer\n  if (answer .eq. 'n') then\n     write(6,*) 'Fine.  Enter the initial terms.'\n     do i=1, n\n        write(6, '(i2,a2)', advance = 'no') i, ': '\n        read(5, *) sequence(i)\n     end do\n  end if\n  call nacci(n, sequence)\n  write(6,*) sequence(:terms)\n  deallocate(sequence)\n\ncontains\n\n    subroutine nacci(n, s)\n      \n      integer, intent(in) :: n\n      integer, intent(inout), dimension(:) :: s\n      integer :: i, terms\n      terms = size(s)\n\n \n  \n      i = n+1\n      if (n+1 .le. terms) s(i) = sum(s(i-n:i-1))\n      do i = n + 2, terms\n         s(i) = 2*s(i-1) - s(i-(n+1))\n      end do\n    end subroutine nacci\nend program f\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\nnamespace Fibonacci\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            PrintNumberSequence(\"Fibonacci\", GetNnacciNumbers(2, 10));\n            PrintNumberSequence(\"Lucas\", GetLucasNumbers(10));\n            PrintNumberSequence(\"Tribonacci\", GetNnacciNumbers(3, 10));\n            PrintNumberSequence(\"Tetranacci\", GetNnacciNumbers(4, 10));\n            Console.ReadKey();\n        }\n\n        private static IList<ulong> GetLucasNumbers(int length)\n        {\n            IList<ulong> seedSequence = new List<ulong>() { 2, 1 };\n            return GetFibLikeSequence(seedSequence, length);\n        }\n\n        private static IList<ulong> GetNnacciNumbers(int seedLength, int length)\n        {\n            return GetFibLikeSequence(GetNacciSeed(seedLength), length);\n        }\n\n        private static IList<ulong> GetNacciSeed(int seedLength)\n        {\n            IList<ulong> seedSquence = new List<ulong>() { 1 };\n\n            for (uint i = 0; i < seedLength - 1; i++)\n            {\n                seedSquence.Add((ulong)Math.Pow(2, i));\n            }\n\n            return seedSquence;\n        }\n\n        private static IList<ulong> GetFibLikeSequence(IList<ulong> seedSequence, int length)\n        {\n            IList<ulong> sequence = new List<ulong>();\n\n            int count = seedSequence.Count();\n\n            if (length <= count)\n            {\n                sequence = seedSequence.Take((int)length).ToList();\n            }\n            else\n            {\n                sequence = seedSequence;\n\n                for (int i = count; i < length; i++)\n                {\n                    ulong num = 0;\n\n                    for (int j = 0; j < count; j++)\n                    {\n                        num += sequence[sequence.Count - 1 - j];\n                    }\n\n                    sequence.Add(num);\n                }\n            }\n\n            return sequence;\n        }\n\n        private static void PrintNumberSequence(string Title, IList<ulong> numbersequence)\n        {\n            StringBuilder output = new StringBuilder(Title).Append(\"   \");\n\n            foreach (long item in numbersequence)\n            {\n                output.AppendFormat(\"{0}, \", item);\n            }\n\n            Console.WriteLine(output.ToString());\n        }\n    }\n}\n"}
{"id": 38421, "name": "Fibonacci n-step number sequences", "source": "Translate Fortran to C#: \n\n\n\n\n\n\n\n\n\n\n\n\n\nprogram f\n  implicit none\n  integer :: n, terms\n  integer, allocatable, dimension(:) :: sequence\n  integer :: i\n  character :: answer\n  write(6,'(a)',advance='no')'Enter the number of terms to sum: '\n  read(5,*) n\n  if ((n < 2) .or. (29 < n)) stop'Unreasonable\n  write(6,'(a)',advance='no')'Show the the first how many terms of the sequence?  '\n  read(5,*) terms\n  if (terms < 1) stop'Lazy programmer has not implemented backward sequences.'\n  n = min(n, terms)\n  allocate(sequence(1:terms))\n  sequence(1) = 1\n  do i = 0, n - 2\n     sequence(i+2) = 2**i\n  end do\n  write(6,*)'Accept this initial sequence (y/n)?'\n  write(6,*) sequence(:n)\n  read(5,*) answer\n  if (answer .eq. 'n') then\n     write(6,*) 'Fine.  Enter the initial terms.'\n     do i=1, n\n        write(6, '(i2,a2)', advance = 'no') i, ': '\n        read(5, *) sequence(i)\n     end do\n  end if\n  call nacci(n, sequence)\n  write(6,*) sequence(:terms)\n  deallocate(sequence)\n\ncontains\n\n    subroutine nacci(n, s)\n      \n      integer, intent(in) :: n\n      integer, intent(inout), dimension(:) :: s\n      integer :: i, terms\n      terms = size(s)\n\n \n  \n      i = n+1\n      if (n+1 .le. terms) s(i) = sum(s(i-n:i-1))\n      do i = n + 2, terms\n         s(i) = 2*s(i-1) - s(i-(n+1))\n      end do\n    end subroutine nacci\nend program f\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\nnamespace Fibonacci\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            PrintNumberSequence(\"Fibonacci\", GetNnacciNumbers(2, 10));\n            PrintNumberSequence(\"Lucas\", GetLucasNumbers(10));\n            PrintNumberSequence(\"Tribonacci\", GetNnacciNumbers(3, 10));\n            PrintNumberSequence(\"Tetranacci\", GetNnacciNumbers(4, 10));\n            Console.ReadKey();\n        }\n\n        private static IList<ulong> GetLucasNumbers(int length)\n        {\n            IList<ulong> seedSequence = new List<ulong>() { 2, 1 };\n            return GetFibLikeSequence(seedSequence, length);\n        }\n\n        private static IList<ulong> GetNnacciNumbers(int seedLength, int length)\n        {\n            return GetFibLikeSequence(GetNacciSeed(seedLength), length);\n        }\n\n        private static IList<ulong> GetNacciSeed(int seedLength)\n        {\n            IList<ulong> seedSquence = new List<ulong>() { 1 };\n\n            for (uint i = 0; i < seedLength - 1; i++)\n            {\n                seedSquence.Add((ulong)Math.Pow(2, i));\n            }\n\n            return seedSquence;\n        }\n\n        private static IList<ulong> GetFibLikeSequence(IList<ulong> seedSequence, int length)\n        {\n            IList<ulong> sequence = new List<ulong>();\n\n            int count = seedSequence.Count();\n\n            if (length <= count)\n            {\n                sequence = seedSequence.Take((int)length).ToList();\n            }\n            else\n            {\n                sequence = seedSequence;\n\n                for (int i = count; i < length; i++)\n                {\n                    ulong num = 0;\n\n                    for (int j = 0; j < count; j++)\n                    {\n                        num += sequence[sequence.Count - 1 - j];\n                    }\n\n                    sequence.Add(num);\n                }\n            }\n\n            return sequence;\n        }\n\n        private static void PrintNumberSequence(string Title, IList<ulong> numbersequence)\n        {\n            StringBuilder output = new StringBuilder(Title).Append(\"   \");\n\n            foreach (long item in numbersequence)\n            {\n                output.AppendFormat(\"{0}, \", item);\n            }\n\n            Console.WriteLine(output.ToString());\n        }\n    }\n}\n"}
{"id": 38427, "name": "Fibonacci n-step number sequences", "source": "Translate Fortran to Java: \n\n\n\n\n\n\n\n\n\n\n\n\n\nprogram f\n  implicit none\n  integer :: n, terms\n  integer, allocatable, dimension(:) :: sequence\n  integer :: i\n  character :: answer\n  write(6,'(a)',advance='no')'Enter the number of terms to sum: '\n  read(5,*) n\n  if ((n < 2) .or. (29 < n)) stop'Unreasonable\n  write(6,'(a)',advance='no')'Show the the first how many terms of the sequence?  '\n  read(5,*) terms\n  if (terms < 1) stop'Lazy programmer has not implemented backward sequences.'\n  n = min(n, terms)\n  allocate(sequence(1:terms))\n  sequence(1) = 1\n  do i = 0, n - 2\n     sequence(i+2) = 2**i\n  end do\n  write(6,*)'Accept this initial sequence (y/n)?'\n  write(6,*) sequence(:n)\n  read(5,*) answer\n  if (answer .eq. 'n') then\n     write(6,*) 'Fine.  Enter the initial terms.'\n     do i=1, n\n        write(6, '(i2,a2)', advance = 'no') i, ': '\n        read(5, *) sequence(i)\n     end do\n  end if\n  call nacci(n, sequence)\n  write(6,*) sequence(:terms)\n  deallocate(sequence)\n\ncontains\n\n    subroutine nacci(n, s)\n      \n      integer, intent(in) :: n\n      integer, intent(inout), dimension(:) :: s\n      integer :: i, terms\n      terms = size(s)\n\n \n  \n      i = n+1\n      if (n+1 .le. terms) s(i) = sum(s(i-n:i-1))\n      do i = n + 2, terms\n         s(i) = 2*s(i-1) - s(i-(n+1))\n      end do\n    end subroutine nacci\nend program f\n", "target": "class Fibonacci\n{\n  public static int[] lucas(int n, int numRequested)\n  {\n    if (n < 2)\n      throw new IllegalArgumentException(\"Fibonacci value must be at least 2\");\n    return fibonacci((n == 2) ? new int[] { 2, 1 } : lucas(n - 1, n), numRequested);\n  }\n  \n  public static int[] fibonacci(int n, int numRequested)\n  {\n    if (n < 2)\n      throw new IllegalArgumentException(\"Fibonacci value must be at least 2\");\n    return fibonacci((n == 2) ? new int[] { 1, 1 } : fibonacci(n - 1, n), numRequested);\n  }\n  \n  public static int[] fibonacci(int[] startingValues, int numRequested)\n  {\n    int[] output = new int[numRequested];\n    int n = startingValues.length;\n    System.arraycopy(startingValues, 0, output, 0, n);\n    for (int i = n; i < numRequested; i++)\n      for (int j = 1; j <= n; j++)\n        output[i] += output[i - j];\n    return output;\n  }\n  \n  public static void main(String[] args)\n  {\n    for (int n = 2; n <= 10; n++)\n    {\n      System.out.print(\"nacci(\" + n + \"):\");\n      for (int value : fibonacci(n, 15))\n        System.out.print(\" \" + value);\n      System.out.println();\n    }\n    for (int n = 2; n <= 10; n++)\n    {\n      System.out.print(\"lucas(\" + n + \"):\");\n      for (int value : lucas(n, 15))\n        System.out.print(\" \" + value);\n      System.out.println();\n    }\n  }\n}\n"}
{"id": 38428, "name": "Fibonacci n-step number sequences", "source": "Translate Fortran to Java: \n\n\n\n\n\n\n\n\n\n\n\n\n\nprogram f\n  implicit none\n  integer :: n, terms\n  integer, allocatable, dimension(:) :: sequence\n  integer :: i\n  character :: answer\n  write(6,'(a)',advance='no')'Enter the number of terms to sum: '\n  read(5,*) n\n  if ((n < 2) .or. (29 < n)) stop'Unreasonable\n  write(6,'(a)',advance='no')'Show the the first how many terms of the sequence?  '\n  read(5,*) terms\n  if (terms < 1) stop'Lazy programmer has not implemented backward sequences.'\n  n = min(n, terms)\n  allocate(sequence(1:terms))\n  sequence(1) = 1\n  do i = 0, n - 2\n     sequence(i+2) = 2**i\n  end do\n  write(6,*)'Accept this initial sequence (y/n)?'\n  write(6,*) sequence(:n)\n  read(5,*) answer\n  if (answer .eq. 'n') then\n     write(6,*) 'Fine.  Enter the initial terms.'\n     do i=1, n\n        write(6, '(i2,a2)', advance = 'no') i, ': '\n        read(5, *) sequence(i)\n     end do\n  end if\n  call nacci(n, sequence)\n  write(6,*) sequence(:terms)\n  deallocate(sequence)\n\ncontains\n\n    subroutine nacci(n, s)\n      \n      integer, intent(in) :: n\n      integer, intent(inout), dimension(:) :: s\n      integer :: i, terms\n      terms = size(s)\n\n \n  \n      i = n+1\n      if (n+1 .le. terms) s(i) = sum(s(i-n:i-1))\n      do i = n + 2, terms\n         s(i) = 2*s(i-1) - s(i-(n+1))\n      end do\n    end subroutine nacci\nend program f\n", "target": "class Fibonacci\n{\n  public static int[] lucas(int n, int numRequested)\n  {\n    if (n < 2)\n      throw new IllegalArgumentException(\"Fibonacci value must be at least 2\");\n    return fibonacci((n == 2) ? new int[] { 2, 1 } : lucas(n - 1, n), numRequested);\n  }\n  \n  public static int[] fibonacci(int n, int numRequested)\n  {\n    if (n < 2)\n      throw new IllegalArgumentException(\"Fibonacci value must be at least 2\");\n    return fibonacci((n == 2) ? new int[] { 1, 1 } : fibonacci(n - 1, n), numRequested);\n  }\n  \n  public static int[] fibonacci(int[] startingValues, int numRequested)\n  {\n    int[] output = new int[numRequested];\n    int n = startingValues.length;\n    System.arraycopy(startingValues, 0, output, 0, n);\n    for (int i = n; i < numRequested; i++)\n      for (int j = 1; j <= n; j++)\n        output[i] += output[i - j];\n    return output;\n  }\n  \n  public static void main(String[] args)\n  {\n    for (int n = 2; n <= 10; n++)\n    {\n      System.out.print(\"nacci(\" + n + \"):\");\n      for (int value : fibonacci(n, 15))\n        System.out.print(\" \" + value);\n      System.out.println();\n    }\n    for (int n = 2; n <= 10; n++)\n    {\n      System.out.print(\"lucas(\" + n + \"):\");\n      for (int value : lucas(n, 15))\n        System.out.print(\" \" + value);\n      System.out.println();\n    }\n  }\n}\n"}
{"id": 38429, "name": "Fibonacci n-step number sequences", "source": "Translate Fortran to Python: \n\n\n\n\n\n\n\n\n\n\n\n\n\nprogram f\n  implicit none\n  integer :: n, terms\n  integer, allocatable, dimension(:) :: sequence\n  integer :: i\n  character :: answer\n  write(6,'(a)',advance='no')'Enter the number of terms to sum: '\n  read(5,*) n\n  if ((n < 2) .or. (29 < n)) stop'Unreasonable\n  write(6,'(a)',advance='no')'Show the the first how many terms of the sequence?  '\n  read(5,*) terms\n  if (terms < 1) stop'Lazy programmer has not implemented backward sequences.'\n  n = min(n, terms)\n  allocate(sequence(1:terms))\n  sequence(1) = 1\n  do i = 0, n - 2\n     sequence(i+2) = 2**i\n  end do\n  write(6,*)'Accept this initial sequence (y/n)?'\n  write(6,*) sequence(:n)\n  read(5,*) answer\n  if (answer .eq. 'n') then\n     write(6,*) 'Fine.  Enter the initial terms.'\n     do i=1, n\n        write(6, '(i2,a2)', advance = 'no') i, ': '\n        read(5, *) sequence(i)\n     end do\n  end if\n  call nacci(n, sequence)\n  write(6,*) sequence(:terms)\n  deallocate(sequence)\n\ncontains\n\n    subroutine nacci(n, s)\n      \n      integer, intent(in) :: n\n      integer, intent(inout), dimension(:) :: s\n      integer :: i, terms\n      terms = size(s)\n\n \n  \n      i = n+1\n      if (n+1 .le. terms) s(i) = sum(s(i-n:i-1))\n      do i = n + 2, terms\n         s(i) = 2*s(i-1) - s(i-(n+1))\n      end do\n    end subroutine nacci\nend program f\n", "target": ">>> def fiblike(start):\n\taddnum = len(start)\n\tmemo = start[:]\n\tdef fibber(n):\n\t\ttry:\n\t\t\treturn memo[n]\n\t\texcept IndexError:\n\t\t\tans = sum(fibber(i) for i in range(n-addnum, n))\n\t\t\tmemo.append(ans)\n\t\t\treturn ans\n\treturn fibber\n\n>>> fibo = fiblike([1,1])\n>>> [fibo(i) for i in range(10)]\n[1, 1, 2, 3, 5, 8, 13, 21, 34, 55]\n>>> lucas = fiblike([2,1])\n>>> [lucas(i) for i in range(10)]\n[2, 1, 3, 4, 7, 11, 18, 29, 47, 76]\n>>> for n, name in zip(range(2,11), 'fibo tribo tetra penta hexa hepta octo nona deca'.split()) :\n\tfibber = fiblike([1] + [2**i for i in range(n-1)])\n\tprint('n=%2i, %5snacci -> %s ...' % (n, name, ' '.join(str(fibber(i)) for i in range(15))))\n\n\t\nn= 2,  fibonacci -> 1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 ...\nn= 3, tribonacci -> 1 1 2 4 7 13 24 44 81 149 274 504 927 1705 3136 ...\nn= 4, tetranacci -> 1 1 2 4 8 15 29 56 108 208 401 773 1490 2872 5536 ...\nn= 5, pentanacci -> 1 1 2 4 8 16 31 61 120 236 464 912 1793 3525 6930 ...\nn= 6,  hexanacci -> 1 1 2 4 8 16 32 63 125 248 492 976 1936 3840 7617 ...\nn= 7, heptanacci -> 1 1 2 4 8 16 32 64 127 253 504 1004 2000 3984 7936 ...\nn= 8,  octonacci -> 1 1 2 4 8 16 32 64 128 255 509 1016 2028 4048 8080 ...\nn= 9,  nonanacci -> 1 1 2 4 8 16 32 64 128 256 511 1021 2040 4076 8144 ...\nn=10,  decanacci -> 1 1 2 4 8 16 32 64 128 256 512 1023 2045 4088 8172 ...\n>>>\n"}
{"id": 38430, "name": "Fibonacci n-step number sequences", "source": "Translate Fortran to Python: \n\n\n\n\n\n\n\n\n\n\n\n\n\nprogram f\n  implicit none\n  integer :: n, terms\n  integer, allocatable, dimension(:) :: sequence\n  integer :: i\n  character :: answer\n  write(6,'(a)',advance='no')'Enter the number of terms to sum: '\n  read(5,*) n\n  if ((n < 2) .or. (29 < n)) stop'Unreasonable\n  write(6,'(a)',advance='no')'Show the the first how many terms of the sequence?  '\n  read(5,*) terms\n  if (terms < 1) stop'Lazy programmer has not implemented backward sequences.'\n  n = min(n, terms)\n  allocate(sequence(1:terms))\n  sequence(1) = 1\n  do i = 0, n - 2\n     sequence(i+2) = 2**i\n  end do\n  write(6,*)'Accept this initial sequence (y/n)?'\n  write(6,*) sequence(:n)\n  read(5,*) answer\n  if (answer .eq. 'n') then\n     write(6,*) 'Fine.  Enter the initial terms.'\n     do i=1, n\n        write(6, '(i2,a2)', advance = 'no') i, ': '\n        read(5, *) sequence(i)\n     end do\n  end if\n  call nacci(n, sequence)\n  write(6,*) sequence(:terms)\n  deallocate(sequence)\n\ncontains\n\n    subroutine nacci(n, s)\n      \n      integer, intent(in) :: n\n      integer, intent(inout), dimension(:) :: s\n      integer :: i, terms\n      terms = size(s)\n\n \n  \n      i = n+1\n      if (n+1 .le. terms) s(i) = sum(s(i-n:i-1))\n      do i = n + 2, terms\n         s(i) = 2*s(i-1) - s(i-(n+1))\n      end do\n    end subroutine nacci\nend program f\n", "target": ">>> def fiblike(start):\n\taddnum = len(start)\n\tmemo = start[:]\n\tdef fibber(n):\n\t\ttry:\n\t\t\treturn memo[n]\n\t\texcept IndexError:\n\t\t\tans = sum(fibber(i) for i in range(n-addnum, n))\n\t\t\tmemo.append(ans)\n\t\t\treturn ans\n\treturn fibber\n\n>>> fibo = fiblike([1,1])\n>>> [fibo(i) for i in range(10)]\n[1, 1, 2, 3, 5, 8, 13, 21, 34, 55]\n>>> lucas = fiblike([2,1])\n>>> [lucas(i) for i in range(10)]\n[2, 1, 3, 4, 7, 11, 18, 29, 47, 76]\n>>> for n, name in zip(range(2,11), 'fibo tribo tetra penta hexa hepta octo nona deca'.split()) :\n\tfibber = fiblike([1] + [2**i for i in range(n-1)])\n\tprint('n=%2i, %5snacci -> %s ...' % (n, name, ' '.join(str(fibber(i)) for i in range(15))))\n\n\t\nn= 2,  fibonacci -> 1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 ...\nn= 3, tribonacci -> 1 1 2 4 7 13 24 44 81 149 274 504 927 1705 3136 ...\nn= 4, tetranacci -> 1 1 2 4 8 15 29 56 108 208 401 773 1490 2872 5536 ...\nn= 5, pentanacci -> 1 1 2 4 8 16 31 61 120 236 464 912 1793 3525 6930 ...\nn= 6,  hexanacci -> 1 1 2 4 8 16 32 63 125 248 492 976 1936 3840 7617 ...\nn= 7, heptanacci -> 1 1 2 4 8 16 32 64 127 253 504 1004 2000 3984 7936 ...\nn= 8,  octonacci -> 1 1 2 4 8 16 32 64 128 255 509 1016 2028 4048 8080 ...\nn= 9,  nonanacci -> 1 1 2 4 8 16 32 64 128 256 511 1021 2040 4076 8144 ...\nn=10,  decanacci -> 1 1 2 4 8 16 32 64 128 256 512 1023 2045 4088 8172 ...\n>>>\n"}
{"id": 38796, "name": "Generic swap", "source": "Translate Fortran to C#: MODULE Genericswap\n  IMPLICIT NONE\n\n  INTERFACE Swap\n    MODULE PROCEDURE Swapint, Swapreal, Swapstring\n  END INTERFACE\n\nCONTAINS\n\n  SUBROUTINE Swapint(a, b)\n    INTEGER, INTENT(IN OUT) :: a, b\n    INTEGER :: temp\n    temp = a ; a = b ; b = temp\n  END SUBROUTINE Swapint\n\n  SUBROUTINE Swapreal(a, b)\n    REAL, INTENT(IN OUT) :: a, b\n    REAL :: temp\n    temp = a ; a = b ; b = temp\n  END SUBROUTINE Swapreal\n\n  SUBROUTINE Swapstring(a, b)\n    CHARACTER(*), INTENT(IN OUT) :: a, b\n    CHARACTER(len(a)) :: temp\n    temp = a ; a = b ; b = temp\n  END SUBROUTINE Swapstring\nEND MODULE Genericswap\n\nPROGRAM EXAMPLE\n  USE Genericswap\n  IMPLICIT NONE\n  INTEGER :: i1 = 1, i2 = 2\n  REAL :: r1 = 1.0, r2 = 2.0\n  CHARACTER(3) :: s1=\"abc\", s2=\"xyz\"\n\n  CALL Swap(i1, i2)\n  CALL Swap(r1, r2)\n  CALL Swap(s1, s2)\n\n  WRITE(*,*) i1, i2   \n  WRITE(*,*) r1, r2   \n  WRITE(*,*) s1, s2   \nEND PROGRAM EXAMPLE\n", "target": "static void Swap<T>(ref T a, ref T b)\n{\n    T temp = a;\n    a = b;\n    b = temp;\n}\n"}
{"id": 38799, "name": "Generic swap", "source": "Translate Fortran to Java: MODULE Genericswap\n  IMPLICIT NONE\n\n  INTERFACE Swap\n    MODULE PROCEDURE Swapint, Swapreal, Swapstring\n  END INTERFACE\n\nCONTAINS\n\n  SUBROUTINE Swapint(a, b)\n    INTEGER, INTENT(IN OUT) :: a, b\n    INTEGER :: temp\n    temp = a ; a = b ; b = temp\n  END SUBROUTINE Swapint\n\n  SUBROUTINE Swapreal(a, b)\n    REAL, INTENT(IN OUT) :: a, b\n    REAL :: temp\n    temp = a ; a = b ; b = temp\n  END SUBROUTINE Swapreal\n\n  SUBROUTINE Swapstring(a, b)\n    CHARACTER(*), INTENT(IN OUT) :: a, b\n    CHARACTER(len(a)) :: temp\n    temp = a ; a = b ; b = temp\n  END SUBROUTINE Swapstring\nEND MODULE Genericswap\n\nPROGRAM EXAMPLE\n  USE Genericswap\n  IMPLICIT NONE\n  INTEGER :: i1 = 1, i2 = 2\n  REAL :: r1 = 1.0, r2 = 2.0\n  CHARACTER(3) :: s1=\"abc\", s2=\"xyz\"\n\n  CALL Swap(i1, i2)\n  CALL Swap(r1, r2)\n  CALL Swap(s1, s2)\n\n  WRITE(*,*) i1, i2   \n  WRITE(*,*) r1, r2   \n  WRITE(*,*) s1, s2   \nEND PROGRAM EXAMPLE\n", "target": "class Pair<T> {\n    T first;\n    T second;\n}\npublic static <T> void swap(Pair<T> p) {\n   T temp = p.first;\n   p.first = p.second;\n   p.second = temp;\n}\n"}
{"id": 38800, "name": "Generic swap", "source": "Translate Fortran to Python: MODULE Genericswap\n  IMPLICIT NONE\n\n  INTERFACE Swap\n    MODULE PROCEDURE Swapint, Swapreal, Swapstring\n  END INTERFACE\n\nCONTAINS\n\n  SUBROUTINE Swapint(a, b)\n    INTEGER, INTENT(IN OUT) :: a, b\n    INTEGER :: temp\n    temp = a ; a = b ; b = temp\n  END SUBROUTINE Swapint\n\n  SUBROUTINE Swapreal(a, b)\n    REAL, INTENT(IN OUT) :: a, b\n    REAL :: temp\n    temp = a ; a = b ; b = temp\n  END SUBROUTINE Swapreal\n\n  SUBROUTINE Swapstring(a, b)\n    CHARACTER(*), INTENT(IN OUT) :: a, b\n    CHARACTER(len(a)) :: temp\n    temp = a ; a = b ; b = temp\n  END SUBROUTINE Swapstring\nEND MODULE Genericswap\n\nPROGRAM EXAMPLE\n  USE Genericswap\n  IMPLICIT NONE\n  INTEGER :: i1 = 1, i2 = 2\n  REAL :: r1 = 1.0, r2 = 2.0\n  CHARACTER(3) :: s1=\"abc\", s2=\"xyz\"\n\n  CALL Swap(i1, i2)\n  CALL Swap(r1, r2)\n  CALL Swap(s1, s2)\n\n  WRITE(*,*) i1, i2   \n  WRITE(*,*) r1, r2   \n  WRITE(*,*) s1, s2   \nEND PROGRAM EXAMPLE\n", "target": "a, b = b, a\n"}
{"id": 39273, "name": "Modular arithmetic", "source": "Translate Fortran to C#: module modular_arithmetic\n  implicit none\n\n  type :: modular\n     integer :: val\n     integer :: modulus\n  end type modular\n\n  interface operator(+)\n     module procedure modular_modular_add\n     module procedure modular_integer_add\n  end interface operator(+)\n\n  interface operator(**)\n     module procedure modular_integer_pow\n  end interface operator(**)\n\ncontains\n\n  function modular_modular_add (a, b) result (c)\n    type(modular), intent(in) :: a\n    type(modular), intent(in) :: b\n    type(modular) :: c\n\n    if (a%modulus /= b%modulus) error stop\n    c%val = modulo (a%val + b%val, a%modulus)\n    c%modulus = a%modulus\n  end function modular_modular_add\n\n  function modular_integer_add (a, i) result (c)\n    type(modular), intent(in) :: a\n    integer, intent(in) :: i\n    type(modular) :: c\n\n    c%val = modulo (a%val + i, a%modulus)\n    c%modulus = a%modulus\n  end function modular_integer_add\n\n  function modular_integer_pow (a, i) result (c)\n    type(modular), intent(in) :: a\n    integer, intent(in) :: i\n    type(modular) :: c\n\n    \n    \n    \n    \n\n    integer :: modulus\n    integer :: base\n    integer :: exponent\n\n    modulus = a%modulus\n    exponent = i\n\n    if (modulus < 1) error stop\n    if (exponent < 0) error stop\n\n    c%modulus = modulus\n    if (modulus == 1) then\n       c%val = 0\n    else\n       c%val = 1\n       base = modulo (a%val, modulus)\n       do while (exponent > 0)\n          if (modulo (exponent, 2) /= 0) then\n             c%val = modulo (c%val * base, modulus)\n          end if\n          exponent = exponent / 2\n          base = modulo (base * base, modulus)\n       end do\n    end if\n  end function modular_integer_pow\n\nend module modular_arithmetic\n\n\n\n\n#define f(x) ((x)**100 + (x) + 1)\n\nprogram modular_arithmetic_task\n  use, intrinsic :: iso_fortran_env\n  use, non_intrinsic :: modular_arithmetic\n  implicit none\n\n  type(modular) :: x, y\n\n  x = modular(10, 13)\n  y = f(x)\n\n  write (*, '(\"    modulus 13:  \", I0)') y%val\n  write (*, '(\"floating point:  \", E55.50)') f(10.0_real64)\n\nend program modular_arithmetic_task\n", "target": "using System;\n\nnamespace ModularArithmetic {\n    interface IAddition<T> {\n        T Add(T rhs);\n    }\n    interface IMultiplication<T> {\n        T Multiply(T rhs);\n    }\n    interface IPower<T> {\n        T Power(int pow);\n    }\n    interface IOne<T> {\n        T One();\n    }\n\n    class ModInt : IAddition<ModInt>, IMultiplication<ModInt>, IPower<ModInt>, IOne<ModInt> {\n        private int modulo;\n\n        public ModInt(int value, int modulo) {\n            Value = value;\n            this.modulo = modulo;\n        }\n\n        public int Value { get; }\n\n        public ModInt One() {\n            return new ModInt(1, modulo);\n        }\n\n        public ModInt Add(ModInt rhs) {\n            return this + rhs;\n        }\n\n        public ModInt Multiply(ModInt rhs) {\n            return this * rhs;\n        }\n\n        public ModInt Power(int pow) {\n            return Pow(this, pow);\n        }\n\n        public override string ToString() {\n            return string.Format(\"ModInt({0}, {1})\", Value, modulo);\n        }\n\n        public static ModInt operator +(ModInt lhs, ModInt rhs) {\n            if (lhs.modulo != rhs.modulo) {\n                throw new ArgumentException(\"Cannot add rings with different modulus\");\n            }\n            return new ModInt((lhs.Value + rhs.Value) % lhs.modulo, lhs.modulo);\n        }\n\n        public static ModInt operator *(ModInt lhs, ModInt rhs) {\n            if (lhs.modulo != rhs.modulo) {\n                throw new ArgumentException(\"Cannot add rings with different modulus\");\n            }\n            return new ModInt((lhs.Value * rhs.Value) % lhs.modulo, lhs.modulo);\n        }\n\n        public static ModInt Pow(ModInt self, int p) {\n            if (p < 0) {\n                throw new ArgumentException(\"p must be zero or greater\");\n            }\n\n            int pp = p;\n            ModInt pwr = self.One();\n            while (pp-- > 0) {\n                pwr *= self;\n            }\n            return pwr;\n        }\n    }\n\n    class Program {\n        static T F<T>(T x) where T : IAddition<T>, IMultiplication<T>, IPower<T>, IOne<T> {\n            return x.Power(100).Add(x).Add(x.One());\n        }\n\n        static void Main(string[] args) {\n            ModInt x = new ModInt(10, 13);\n            ModInt y = F(x);\n            Console.WriteLine(\"x ^ 100 + x + 1 for x = {0} is {1}\", x, y);\n        }\n    }\n}\n"}
{"id": 39274, "name": "Modular arithmetic", "source": "Translate Fortran to C#: module modular_arithmetic\n  implicit none\n\n  type :: modular\n     integer :: val\n     integer :: modulus\n  end type modular\n\n  interface operator(+)\n     module procedure modular_modular_add\n     module procedure modular_integer_add\n  end interface operator(+)\n\n  interface operator(**)\n     module procedure modular_integer_pow\n  end interface operator(**)\n\ncontains\n\n  function modular_modular_add (a, b) result (c)\n    type(modular), intent(in) :: a\n    type(modular), intent(in) :: b\n    type(modular) :: c\n\n    if (a%modulus /= b%modulus) error stop\n    c%val = modulo (a%val + b%val, a%modulus)\n    c%modulus = a%modulus\n  end function modular_modular_add\n\n  function modular_integer_add (a, i) result (c)\n    type(modular), intent(in) :: a\n    integer, intent(in) :: i\n    type(modular) :: c\n\n    c%val = modulo (a%val + i, a%modulus)\n    c%modulus = a%modulus\n  end function modular_integer_add\n\n  function modular_integer_pow (a, i) result (c)\n    type(modular), intent(in) :: a\n    integer, intent(in) :: i\n    type(modular) :: c\n\n    \n    \n    \n    \n\n    integer :: modulus\n    integer :: base\n    integer :: exponent\n\n    modulus = a%modulus\n    exponent = i\n\n    if (modulus < 1) error stop\n    if (exponent < 0) error stop\n\n    c%modulus = modulus\n    if (modulus == 1) then\n       c%val = 0\n    else\n       c%val = 1\n       base = modulo (a%val, modulus)\n       do while (exponent > 0)\n          if (modulo (exponent, 2) /= 0) then\n             c%val = modulo (c%val * base, modulus)\n          end if\n          exponent = exponent / 2\n          base = modulo (base * base, modulus)\n       end do\n    end if\n  end function modular_integer_pow\n\nend module modular_arithmetic\n\n\n\n\n#define f(x) ((x)**100 + (x) + 1)\n\nprogram modular_arithmetic_task\n  use, intrinsic :: iso_fortran_env\n  use, non_intrinsic :: modular_arithmetic\n  implicit none\n\n  type(modular) :: x, y\n\n  x = modular(10, 13)\n  y = f(x)\n\n  write (*, '(\"    modulus 13:  \", I0)') y%val\n  write (*, '(\"floating point:  \", E55.50)') f(10.0_real64)\n\nend program modular_arithmetic_task\n", "target": "using System;\n\nnamespace ModularArithmetic {\n    interface IAddition<T> {\n        T Add(T rhs);\n    }\n    interface IMultiplication<T> {\n        T Multiply(T rhs);\n    }\n    interface IPower<T> {\n        T Power(int pow);\n    }\n    interface IOne<T> {\n        T One();\n    }\n\n    class ModInt : IAddition<ModInt>, IMultiplication<ModInt>, IPower<ModInt>, IOne<ModInt> {\n        private int modulo;\n\n        public ModInt(int value, int modulo) {\n            Value = value;\n            this.modulo = modulo;\n        }\n\n        public int Value { get; }\n\n        public ModInt One() {\n            return new ModInt(1, modulo);\n        }\n\n        public ModInt Add(ModInt rhs) {\n            return this + rhs;\n        }\n\n        public ModInt Multiply(ModInt rhs) {\n            return this * rhs;\n        }\n\n        public ModInt Power(int pow) {\n            return Pow(this, pow);\n        }\n\n        public override string ToString() {\n            return string.Format(\"ModInt({0}, {1})\", Value, modulo);\n        }\n\n        public static ModInt operator +(ModInt lhs, ModInt rhs) {\n            if (lhs.modulo != rhs.modulo) {\n                throw new ArgumentException(\"Cannot add rings with different modulus\");\n            }\n            return new ModInt((lhs.Value + rhs.Value) % lhs.modulo, lhs.modulo);\n        }\n\n        public static ModInt operator *(ModInt lhs, ModInt rhs) {\n            if (lhs.modulo != rhs.modulo) {\n                throw new ArgumentException(\"Cannot add rings with different modulus\");\n            }\n            return new ModInt((lhs.Value * rhs.Value) % lhs.modulo, lhs.modulo);\n        }\n\n        public static ModInt Pow(ModInt self, int p) {\n            if (p < 0) {\n                throw new ArgumentException(\"p must be zero or greater\");\n            }\n\n            int pp = p;\n            ModInt pwr = self.One();\n            while (pp-- > 0) {\n                pwr *= self;\n            }\n            return pwr;\n        }\n    }\n\n    class Program {\n        static T F<T>(T x) where T : IAddition<T>, IMultiplication<T>, IPower<T>, IOne<T> {\n            return x.Power(100).Add(x).Add(x.One());\n        }\n\n        static void Main(string[] args) {\n            ModInt x = new ModInt(10, 13);\n            ModInt y = F(x);\n            Console.WriteLine(\"x ^ 100 + x + 1 for x = {0} is {1}\", x, y);\n        }\n    }\n}\n"}
{"id": 39280, "name": "Modular arithmetic", "source": "Translate Fortran to Java: module modular_arithmetic\n  implicit none\n\n  type :: modular\n     integer :: val\n     integer :: modulus\n  end type modular\n\n  interface operator(+)\n     module procedure modular_modular_add\n     module procedure modular_integer_add\n  end interface operator(+)\n\n  interface operator(**)\n     module procedure modular_integer_pow\n  end interface operator(**)\n\ncontains\n\n  function modular_modular_add (a, b) result (c)\n    type(modular), intent(in) :: a\n    type(modular), intent(in) :: b\n    type(modular) :: c\n\n    if (a%modulus /= b%modulus) error stop\n    c%val = modulo (a%val + b%val, a%modulus)\n    c%modulus = a%modulus\n  end function modular_modular_add\n\n  function modular_integer_add (a, i) result (c)\n    type(modular), intent(in) :: a\n    integer, intent(in) :: i\n    type(modular) :: c\n\n    c%val = modulo (a%val + i, a%modulus)\n    c%modulus = a%modulus\n  end function modular_integer_add\n\n  function modular_integer_pow (a, i) result (c)\n    type(modular), intent(in) :: a\n    integer, intent(in) :: i\n    type(modular) :: c\n\n    \n    \n    \n    \n\n    integer :: modulus\n    integer :: base\n    integer :: exponent\n\n    modulus = a%modulus\n    exponent = i\n\n    if (modulus < 1) error stop\n    if (exponent < 0) error stop\n\n    c%modulus = modulus\n    if (modulus == 1) then\n       c%val = 0\n    else\n       c%val = 1\n       base = modulo (a%val, modulus)\n       do while (exponent > 0)\n          if (modulo (exponent, 2) /= 0) then\n             c%val = modulo (c%val * base, modulus)\n          end if\n          exponent = exponent / 2\n          base = modulo (base * base, modulus)\n       end do\n    end if\n  end function modular_integer_pow\n\nend module modular_arithmetic\n\n\n\n\n#define f(x) ((x)**100 + (x) + 1)\n\nprogram modular_arithmetic_task\n  use, intrinsic :: iso_fortran_env\n  use, non_intrinsic :: modular_arithmetic\n  implicit none\n\n  type(modular) :: x, y\n\n  x = modular(10, 13)\n  y = f(x)\n\n  write (*, '(\"    modulus 13:  \", I0)') y%val\n  write (*, '(\"floating point:  \", E55.50)') f(10.0_real64)\n\nend program modular_arithmetic_task\n", "target": "public class ModularArithmetic {\n    private interface Ring<T> {\n        Ring<T> plus(Ring<T> rhs);\n\n        Ring<T> times(Ring<T> rhs);\n\n        int value();\n\n        Ring<T> one();\n\n        default Ring<T> pow(int p) {\n            if (p < 0) {\n                throw new IllegalArgumentException(\"p must be zero or greater\");\n            }\n\n            int pp = p;\n            Ring<T> pwr = this.one();\n            while (pp-- > 0) {\n                pwr = pwr.times(this);\n            }\n            return pwr;\n        }\n    }\n\n    private static class ModInt implements Ring<ModInt> {\n        private int value;\n        private int modulo;\n\n        private ModInt(int value, int modulo) {\n            this.value = value;\n            this.modulo = modulo;\n        }\n\n        @Override\n        public Ring<ModInt> plus(Ring<ModInt> other) {\n            if (!(other instanceof ModInt)) {\n                throw new IllegalArgumentException(\"Cannot add an unknown ring.\");\n            }\n            ModInt rhs = (ModInt) other;\n            if (modulo != rhs.modulo) {\n                throw new IllegalArgumentException(\"Cannot add rings with different modulus\");\n            }\n            return new ModInt((value + rhs.value) % modulo, modulo);\n        }\n\n        @Override\n        public Ring<ModInt> times(Ring<ModInt> other) {\n            if (!(other instanceof ModInt)) {\n                throw new IllegalArgumentException(\"Cannot multiple an unknown ring.\");\n            }\n            ModInt rhs = (ModInt) other;\n            if (modulo != rhs.modulo) {\n                throw new IllegalArgumentException(\"Cannot multiply rings with different modulus\");\n            }\n            return new ModInt((value * rhs.value) % modulo, modulo);\n        }\n\n        @Override\n        public int value() {\n            return value;\n        }\n\n        @Override\n        public Ring<ModInt> one() {\n            return new ModInt(1, modulo);\n        }\n\n        @Override\n        public String toString() {\n            return String.format(\"ModInt(%d, %d)\", value, modulo);\n        }\n    }\n\n    private static <T> Ring<T> f(Ring<T> x) {\n        return x.pow(100).plus(x).plus(x.one());\n    }\n\n    public static void main(String[] args) {\n        ModInt x = new ModInt(10, 13);\n        Ring<ModInt> y = f(x);\n        System.out.print(\"x ^ 100 + x + 1 for x = ModInt(10, 13) is \");\n        System.out.println(y);\n        System.out.flush();\n    }\n}\n"}
{"id": 39281, "name": "Modular arithmetic", "source": "Translate Fortran to Java: module modular_arithmetic\n  implicit none\n\n  type :: modular\n     integer :: val\n     integer :: modulus\n  end type modular\n\n  interface operator(+)\n     module procedure modular_modular_add\n     module procedure modular_integer_add\n  end interface operator(+)\n\n  interface operator(**)\n     module procedure modular_integer_pow\n  end interface operator(**)\n\ncontains\n\n  function modular_modular_add (a, b) result (c)\n    type(modular), intent(in) :: a\n    type(modular), intent(in) :: b\n    type(modular) :: c\n\n    if (a%modulus /= b%modulus) error stop\n    c%val = modulo (a%val + b%val, a%modulus)\n    c%modulus = a%modulus\n  end function modular_modular_add\n\n  function modular_integer_add (a, i) result (c)\n    type(modular), intent(in) :: a\n    integer, intent(in) :: i\n    type(modular) :: c\n\n    c%val = modulo (a%val + i, a%modulus)\n    c%modulus = a%modulus\n  end function modular_integer_add\n\n  function modular_integer_pow (a, i) result (c)\n    type(modular), intent(in) :: a\n    integer, intent(in) :: i\n    type(modular) :: c\n\n    \n    \n    \n    \n\n    integer :: modulus\n    integer :: base\n    integer :: exponent\n\n    modulus = a%modulus\n    exponent = i\n\n    if (modulus < 1) error stop\n    if (exponent < 0) error stop\n\n    c%modulus = modulus\n    if (modulus == 1) then\n       c%val = 0\n    else\n       c%val = 1\n       base = modulo (a%val, modulus)\n       do while (exponent > 0)\n          if (modulo (exponent, 2) /= 0) then\n             c%val = modulo (c%val * base, modulus)\n          end if\n          exponent = exponent / 2\n          base = modulo (base * base, modulus)\n       end do\n    end if\n  end function modular_integer_pow\n\nend module modular_arithmetic\n\n\n\n\n#define f(x) ((x)**100 + (x) + 1)\n\nprogram modular_arithmetic_task\n  use, intrinsic :: iso_fortran_env\n  use, non_intrinsic :: modular_arithmetic\n  implicit none\n\n  type(modular) :: x, y\n\n  x = modular(10, 13)\n  y = f(x)\n\n  write (*, '(\"    modulus 13:  \", I0)') y%val\n  write (*, '(\"floating point:  \", E55.50)') f(10.0_real64)\n\nend program modular_arithmetic_task\n", "target": "public class ModularArithmetic {\n    private interface Ring<T> {\n        Ring<T> plus(Ring<T> rhs);\n\n        Ring<T> times(Ring<T> rhs);\n\n        int value();\n\n        Ring<T> one();\n\n        default Ring<T> pow(int p) {\n            if (p < 0) {\n                throw new IllegalArgumentException(\"p must be zero or greater\");\n            }\n\n            int pp = p;\n            Ring<T> pwr = this.one();\n            while (pp-- > 0) {\n                pwr = pwr.times(this);\n            }\n            return pwr;\n        }\n    }\n\n    private static class ModInt implements Ring<ModInt> {\n        private int value;\n        private int modulo;\n\n        private ModInt(int value, int modulo) {\n            this.value = value;\n            this.modulo = modulo;\n        }\n\n        @Override\n        public Ring<ModInt> plus(Ring<ModInt> other) {\n            if (!(other instanceof ModInt)) {\n                throw new IllegalArgumentException(\"Cannot add an unknown ring.\");\n            }\n            ModInt rhs = (ModInt) other;\n            if (modulo != rhs.modulo) {\n                throw new IllegalArgumentException(\"Cannot add rings with different modulus\");\n            }\n            return new ModInt((value + rhs.value) % modulo, modulo);\n        }\n\n        @Override\n        public Ring<ModInt> times(Ring<ModInt> other) {\n            if (!(other instanceof ModInt)) {\n                throw new IllegalArgumentException(\"Cannot multiple an unknown ring.\");\n            }\n            ModInt rhs = (ModInt) other;\n            if (modulo != rhs.modulo) {\n                throw new IllegalArgumentException(\"Cannot multiply rings with different modulus\");\n            }\n            return new ModInt((value * rhs.value) % modulo, modulo);\n        }\n\n        @Override\n        public int value() {\n            return value;\n        }\n\n        @Override\n        public Ring<ModInt> one() {\n            return new ModInt(1, modulo);\n        }\n\n        @Override\n        public String toString() {\n            return String.format(\"ModInt(%d, %d)\", value, modulo);\n        }\n    }\n\n    private static <T> Ring<T> f(Ring<T> x) {\n        return x.pow(100).plus(x).plus(x.one());\n    }\n\n    public static void main(String[] args) {\n        ModInt x = new ModInt(10, 13);\n        Ring<ModInt> y = f(x);\n        System.out.print(\"x ^ 100 + x + 1 for x = ModInt(10, 13) is \");\n        System.out.println(y);\n        System.out.flush();\n    }\n}\n"}
{"id": 39282, "name": "Modular arithmetic", "source": "Translate Fortran to Python: module modular_arithmetic\n  implicit none\n\n  type :: modular\n     integer :: val\n     integer :: modulus\n  end type modular\n\n  interface operator(+)\n     module procedure modular_modular_add\n     module procedure modular_integer_add\n  end interface operator(+)\n\n  interface operator(**)\n     module procedure modular_integer_pow\n  end interface operator(**)\n\ncontains\n\n  function modular_modular_add (a, b) result (c)\n    type(modular), intent(in) :: a\n    type(modular), intent(in) :: b\n    type(modular) :: c\n\n    if (a%modulus /= b%modulus) error stop\n    c%val = modulo (a%val + b%val, a%modulus)\n    c%modulus = a%modulus\n  end function modular_modular_add\n\n  function modular_integer_add (a, i) result (c)\n    type(modular), intent(in) :: a\n    integer, intent(in) :: i\n    type(modular) :: c\n\n    c%val = modulo (a%val + i, a%modulus)\n    c%modulus = a%modulus\n  end function modular_integer_add\n\n  function modular_integer_pow (a, i) result (c)\n    type(modular), intent(in) :: a\n    integer, intent(in) :: i\n    type(modular) :: c\n\n    \n    \n    \n    \n\n    integer :: modulus\n    integer :: base\n    integer :: exponent\n\n    modulus = a%modulus\n    exponent = i\n\n    if (modulus < 1) error stop\n    if (exponent < 0) error stop\n\n    c%modulus = modulus\n    if (modulus == 1) then\n       c%val = 0\n    else\n       c%val = 1\n       base = modulo (a%val, modulus)\n       do while (exponent > 0)\n          if (modulo (exponent, 2) /= 0) then\n             c%val = modulo (c%val * base, modulus)\n          end if\n          exponent = exponent / 2\n          base = modulo (base * base, modulus)\n       end do\n    end if\n  end function modular_integer_pow\n\nend module modular_arithmetic\n\n\n\n\n#define f(x) ((x)**100 + (x) + 1)\n\nprogram modular_arithmetic_task\n  use, intrinsic :: iso_fortran_env\n  use, non_intrinsic :: modular_arithmetic\n  implicit none\n\n  type(modular) :: x, y\n\n  x = modular(10, 13)\n  y = f(x)\n\n  write (*, '(\"    modulus 13:  \", I0)') y%val\n  write (*, '(\"floating point:  \", E55.50)') f(10.0_real64)\n\nend program modular_arithmetic_task\n", "target": "import operator\nimport functools\n\n@functools.total_ordering\nclass Mod:\n    __slots__ = ['val','mod']\n\n    def __init__(self, val, mod):\n        if not isinstance(val, int):\n            raise ValueError('Value must be integer')\n        if not isinstance(mod, int) or mod<=0:\n            raise ValueError('Modulo must be positive integer')\n        self.val = val % mod\n        self.mod = mod\n\n    def __repr__(self):\n        return 'Mod({}, {})'.format(self.val, self.mod)\n\n    def __int__(self):\n        return self.val\n\n    def __eq__(self, other):\n        if isinstance(other, Mod):\n            if self.mod == other.mod:\n                return self.val==other.val\n            else:\n                return NotImplemented\n        elif isinstance(other, int):\n            return self.val == other\n        else:\n            return NotImplemented\n\n    def __lt__(self, other):\n        if isinstance(other, Mod):\n            if self.mod == other.mod:\n                return self.val<other.val\n            else:\n                return NotImplemented\n        elif isinstance(other, int):\n            return self.val < other\n        else:\n            return NotImplemented\n\n    def _check_operand(self, other):\n        if not isinstance(other, (int, Mod)):\n            raise TypeError('Only integer and Mod operands are supported')\n        if isinstance(other, Mod) and self.mod != other.mod:\n            raise ValueError('Inconsistent modulus: {} vs. {}'.format(self.mod, other.mod))\n\n    def __pow__(self, other):\n        self._check_operand(other)\n        \n        return Mod(pow(self.val, int(other), self.mod), self.mod)\n\n    def __neg__(self):\n        return Mod(self.mod - self.val, self.mod)\n\n    def __pos__(self):\n        return self \n\n    def __abs__(self):\n        return self \n\n\n\ndef _make_op(opname):\n    op_fun = getattr(operator, opname)  \n    def op(self, other):\n        self._check_operand(other)\n        return Mod(op_fun(self.val, int(other)) % self.mod, self.mod)\n    return op\n\ndef _make_reflected_op(opname):\n    op_fun = getattr(operator, opname)\n    def op(self, other):\n        self._check_operand(other)\n        return Mod(op_fun(int(other), self.val) % self.mod, self.mod)\n    return op\n\n\nfor opname, reflected_opname in [('__add__', '__radd__'), ('__sub__', '__rsub__'), ('__mul__', '__rmul__')]:\n    setattr(Mod, opname, _make_op(opname))\n    setattr(Mod, reflected_opname, _make_reflected_op(opname))\n\ndef f(x):\n    return x**100+x+1\n\nprint(f(Mod(10,13)))\n\n"}
{"id": 39283, "name": "Modular arithmetic", "source": "Translate Fortran to Python: module modular_arithmetic\n  implicit none\n\n  type :: modular\n     integer :: val\n     integer :: modulus\n  end type modular\n\n  interface operator(+)\n     module procedure modular_modular_add\n     module procedure modular_integer_add\n  end interface operator(+)\n\n  interface operator(**)\n     module procedure modular_integer_pow\n  end interface operator(**)\n\ncontains\n\n  function modular_modular_add (a, b) result (c)\n    type(modular), intent(in) :: a\n    type(modular), intent(in) :: b\n    type(modular) :: c\n\n    if (a%modulus /= b%modulus) error stop\n    c%val = modulo (a%val + b%val, a%modulus)\n    c%modulus = a%modulus\n  end function modular_modular_add\n\n  function modular_integer_add (a, i) result (c)\n    type(modular), intent(in) :: a\n    integer, intent(in) :: i\n    type(modular) :: c\n\n    c%val = modulo (a%val + i, a%modulus)\n    c%modulus = a%modulus\n  end function modular_integer_add\n\n  function modular_integer_pow (a, i) result (c)\n    type(modular), intent(in) :: a\n    integer, intent(in) :: i\n    type(modular) :: c\n\n    \n    \n    \n    \n\n    integer :: modulus\n    integer :: base\n    integer :: exponent\n\n    modulus = a%modulus\n    exponent = i\n\n    if (modulus < 1) error stop\n    if (exponent < 0) error stop\n\n    c%modulus = modulus\n    if (modulus == 1) then\n       c%val = 0\n    else\n       c%val = 1\n       base = modulo (a%val, modulus)\n       do while (exponent > 0)\n          if (modulo (exponent, 2) /= 0) then\n             c%val = modulo (c%val * base, modulus)\n          end if\n          exponent = exponent / 2\n          base = modulo (base * base, modulus)\n       end do\n    end if\n  end function modular_integer_pow\n\nend module modular_arithmetic\n\n\n\n\n#define f(x) ((x)**100 + (x) + 1)\n\nprogram modular_arithmetic_task\n  use, intrinsic :: iso_fortran_env\n  use, non_intrinsic :: modular_arithmetic\n  implicit none\n\n  type(modular) :: x, y\n\n  x = modular(10, 13)\n  y = f(x)\n\n  write (*, '(\"    modulus 13:  \", I0)') y%val\n  write (*, '(\"floating point:  \", E55.50)') f(10.0_real64)\n\nend program modular_arithmetic_task\n", "target": "import operator\nimport functools\n\n@functools.total_ordering\nclass Mod:\n    __slots__ = ['val','mod']\n\n    def __init__(self, val, mod):\n        if not isinstance(val, int):\n            raise ValueError('Value must be integer')\n        if not isinstance(mod, int) or mod<=0:\n            raise ValueError('Modulo must be positive integer')\n        self.val = val % mod\n        self.mod = mod\n\n    def __repr__(self):\n        return 'Mod({}, {})'.format(self.val, self.mod)\n\n    def __int__(self):\n        return self.val\n\n    def __eq__(self, other):\n        if isinstance(other, Mod):\n            if self.mod == other.mod:\n                return self.val==other.val\n            else:\n                return NotImplemented\n        elif isinstance(other, int):\n            return self.val == other\n        else:\n            return NotImplemented\n\n    def __lt__(self, other):\n        if isinstance(other, Mod):\n            if self.mod == other.mod:\n                return self.val<other.val\n            else:\n                return NotImplemented\n        elif isinstance(other, int):\n            return self.val < other\n        else:\n            return NotImplemented\n\n    def _check_operand(self, other):\n        if not isinstance(other, (int, Mod)):\n            raise TypeError('Only integer and Mod operands are supported')\n        if isinstance(other, Mod) and self.mod != other.mod:\n            raise ValueError('Inconsistent modulus: {} vs. {}'.format(self.mod, other.mod))\n\n    def __pow__(self, other):\n        self._check_operand(other)\n        \n        return Mod(pow(self.val, int(other), self.mod), self.mod)\n\n    def __neg__(self):\n        return Mod(self.mod - self.val, self.mod)\n\n    def __pos__(self):\n        return self \n\n    def __abs__(self):\n        return self \n\n\n\ndef _make_op(opname):\n    op_fun = getattr(operator, opname)  \n    def op(self, other):\n        self._check_operand(other)\n        return Mod(op_fun(self.val, int(other)) % self.mod, self.mod)\n    return op\n\ndef _make_reflected_op(opname):\n    op_fun = getattr(operator, opname)\n    def op(self, other):\n        self._check_operand(other)\n        return Mod(op_fun(int(other), self.val) % self.mod, self.mod)\n    return op\n\n\nfor opname, reflected_opname in [('__add__', '__radd__'), ('__sub__', '__rsub__'), ('__mul__', '__rmul__')]:\n    setattr(Mod, opname, _make_op(opname))\n    setattr(Mod, reflected_opname, _make_reflected_op(opname))\n\ndef f(x):\n    return x**100+x+1\n\nprint(f(Mod(10,13)))\n\n"}
{"id": 39534, "name": "String append", "source": "Translate Fortran to C#: program main\n\n character(len=:),allocatable :: str\n\n str = 'hello'\n str = str//' world'\n\n write(*,*) str\n\nend program main\n", "target": "class Program\n{\n    static void Main(string[] args)\n    {\n        string x = \"foo\";\n        x += \"bar\";\n        System.Console.WriteLine(x);\n    }\n}\n"}
{"id": 39537, "name": "String append", "source": "Translate Fortran to Java: program main\n\n character(len=:),allocatable :: str\n\n str = 'hello'\n str = str//' world'\n\n write(*,*) str\n\nend program main\n", "target": "String sa = \"Hello\";\nsa += \", World!\";\nSystem.out.println(sa);\n\nStringBuilder ba = new StringBuilder();\nba.append(\"Hello\");\nba.append(\", World!\");\nSystem.out.println(ba.toString());\n"}
{"id": 39538, "name": "String append", "source": "Translate Fortran to Python: program main\n\n character(len=:),allocatable :: str\n\n str = 'hello'\n str = str//' world'\n\n write(*,*) str\n\nend program main\n", "target": "\n\n\nstr = \"12345678\";\nstr += \"9!\";\nprint(str)\n"}
{"id": 39748, "name": "Count in octal", "source": "Translate Fortran to C#: program Octal\n  implicit none\n  \n  integer, parameter :: i64 = selected_int_kind(18)\n  integer(i64) :: n = 0\n  \n\n\n  do while(n >= 0)\n    write(*, \"(o0)\") n\n    n = n + 1\n  end do\nend program\n", "target": "using System;\n\nclass Program\n{\n    static void Main()\n    {\n        var number = 0;\n        do\n        {\n            Console.WriteLine(Convert.ToString(number, 8));\n        } while (++number > 0);\n    }\n}\n"}
{"id": 39751, "name": "Count in octal", "source": "Translate Fortran to Java: program Octal\n  implicit none\n  \n  integer, parameter :: i64 = selected_int_kind(18)\n  integer(i64) :: n = 0\n  \n\n\n  do while(n >= 0)\n    write(*, \"(o0)\") n\n    n = n + 1\n  end do\nend program\n", "target": "public class Count{\n    public static void main(String[] args){\n        for(int i = 0;i >= 0;i++){\n            System.out.println(Integer.toOctalString(i)); \n        }\n    }\n}\n"}
{"id": 39752, "name": "Count in octal", "source": "Translate Fortran to Python: program Octal\n  implicit none\n  \n  integer, parameter :: i64 = selected_int_kind(18)\n  integer(i64) :: n = 0\n  \n\n\n  do while(n >= 0)\n    write(*, \"(o0)\") n\n    n = n + 1\n  end do\nend program\n", "target": "import sys\nfor n in xrange(sys.maxint):\n    print oct(n)\n"}
{"id": 40013, "name": "Delete a file", "source": "Translate Fortran to C#:  OPEN  (UNIT=5, FILE=\"input.txt\", STATUS=\"OLD\")   \n CLOSE (UNIT=5, STATUS=\"DELETE\")\n OPEN  (UNIT=5, FILE=\"/input.txt\", STATUS=\"OLD\")  \n CLOSE (UNIT=5, STATUS=\"DELETE\")\n", "target": "using System;\nusing System.IO;\n\nnamespace DeleteFile {\n  class Program {\n    static void Main() {\n      File.Delete(\"input.txt\");\n      Directory.Delete(\"docs\");\n      File.Delete(\"/input.txt\");\n      Directory.Delete(\"/docs\");\n    }\n  }\n}\n"}
{"id": 40016, "name": "Delete a file", "source": "Translate Fortran to Java:  OPEN  (UNIT=5, FILE=\"input.txt\", STATUS=\"OLD\")   \n CLOSE (UNIT=5, STATUS=\"DELETE\")\n OPEN  (UNIT=5, FILE=\"/input.txt\", STATUS=\"OLD\")  \n CLOSE (UNIT=5, STATUS=\"DELETE\")\n", "target": "import java.io.File;\n\npublic class FileDeleteTest {\n    public static boolean deleteFile(String filename) {\n        boolean exists = new File(filename).delete();\n        return exists;\n    }\n    \n    public static void test(String type, String filename) {\n        System.out.println(\"The following \" + type + \" called \" + filename + \n            (deleteFile(filename) ? \" was deleted.\" : \" could not be deleted.\")\n        );\n    }\n\n    public static void main(String args[]) {\n        test(\"file\", \"input.txt\");\n        test(\"file\", File.seperator + \"input.txt\");\n        test(\"directory\", \"docs\");\n        test(\"directory\", File.seperator + \"docs\" + File.seperator);\n    }\n}\n"}
{"id": 40017, "name": "Delete a file", "source": "Translate Fortran to Python:  OPEN  (UNIT=5, FILE=\"input.txt\", STATUS=\"OLD\")   \n CLOSE (UNIT=5, STATUS=\"DELETE\")\n OPEN  (UNIT=5, FILE=\"/input.txt\", STATUS=\"OLD\")  \n CLOSE (UNIT=5, STATUS=\"DELETE\")\n", "target": "import os\n\nos.remove(\"output.txt\")\nos.rmdir(\"docs\")\n\nos.remove(\"/output.txt\")\nos.rmdir(\"/docs\")\n"}
{"id": 40290, "name": "Sum of a series", "source": "Translate Fortran to C#: real, dimension(1000) :: a = (/ (1.0/(i*i), i=1, 1000) /)\nreal :: result\n\nresult = sum(a);\n", "target": "class Program\n{\n    static void Main(string[] args)\n    {\n        \n\n        List<double> myList = new List<double>();\n        for (double i = 1; i < 1001; i++)\n        {\n            myList.Add(i);\n        }\n        \n\n        var sum = myList.Sum(x => 1/(x*x));\n\n        Console.WriteLine(sum);\n        Console.ReadLine();\n    }\n}\n"}
{"id": 40293, "name": "Sum of a series", "source": "Translate Fortran to Java: real, dimension(1000) :: a = (/ (1.0/(i*i), i=1, 1000) /)\nreal :: result\n\nresult = sum(a);\n", "target": "public class Sum{\n    public static double f(double x){\n       return 1/(x*x);\n    }\n \n    public static void main(String[] args){\n       double start = 1;\n       double end = 1000;\n       double sum = 0;\n \n       for(double x = start;x <= end;x++) sum += f(x);\n \n       System.out.println(\"Sum of f(x) from \" + start + \" to \" + end +\" is \" + sum);\n    }\n}\n"}
{"id": 40294, "name": "Sum of a series", "source": "Translate Fortran to Python: real, dimension(1000) :: a = (/ (1.0/(i*i), i=1, 1000) /)\nreal :: result\n\nresult = sum(a);\n", "target": "print ( sum(1.0 / (x * x) for x in range(1, 1001)) )\n"}
{"id": 40583, "name": "Sierpinski carpet", "source": "Translate Fortran to C#: program Sierpinski_carpet\n  implicit none\n  \n  call carpet(4)\n\ncontains\n\nfunction In_carpet(a, b)\n  logical :: in_carpet\n  integer, intent(in) :: a, b\n  integer :: x, y\n\n  x = a ; y = b\n  do \n    if(x == 0 .or. y == 0) then\n      In_carpet = .true.\n      return\n    else if(mod(x, 3) == 1 .and. mod(y, 3) == 1) then\n      In_carpet = .false.\n      return\n    end if\n    x = x / 3\n    y = y / 3\n  end do\nend function\n\nsubroutine Carpet(n)\n  integer, intent(in) :: n\n  integer :: i, j\n \n  do i = 0, 3**n - 1 \n    do j = 0, 3**n - 1\n      if(In_carpet(i, j)) then\n        write(*, \"(a)\", advance=\"no\") \"#\"\n      else\n        write(*, \"(a)\", advance=\"no\") \" \"\n      end if\n    end do\n    write(*,*)\n  end do\nend subroutine Carpet\nend program Sierpinski_carpet\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\nclass Program\n{\n    static List<string> NextCarpet(List<string> carpet)\n    {\n        return carpet.Select(x => x + x + x)\n                     .Concat(carpet.Select(x => x + x.Replace('#', ' ') + x))\n                     .Concat(carpet.Select(x => x + x + x)).ToList();\n    }\n\n    static List<string> SierpinskiCarpet(int n)\n    {\n        return Enumerable.Range(1, n).Aggregate(new List<string> { \"#\" }, (carpet, _) => NextCarpet(carpet));\n    }\n\n    static void Main(string[] args)\n    {\n        foreach (string s in SierpinskiCarpet(3))\n            Console.WriteLine(s);\n    }\n}\n"}
{"id": 40587, "name": "Sierpinski carpet", "source": "Translate Fortran to Java: program Sierpinski_carpet\n  implicit none\n  \n  call carpet(4)\n\ncontains\n\nfunction In_carpet(a, b)\n  logical :: in_carpet\n  integer, intent(in) :: a, b\n  integer :: x, y\n\n  x = a ; y = b\n  do \n    if(x == 0 .or. y == 0) then\n      In_carpet = .true.\n      return\n    else if(mod(x, 3) == 1 .and. mod(y, 3) == 1) then\n      In_carpet = .false.\n      return\n    end if\n    x = x / 3\n    y = y / 3\n  end do\nend function\n\nsubroutine Carpet(n)\n  integer, intent(in) :: n\n  integer :: i, j\n \n  do i = 0, 3**n - 1 \n    do j = 0, 3**n - 1\n      if(In_carpet(i, j)) then\n        write(*, \"(a)\", advance=\"no\") \"#\"\n      else\n        write(*, \"(a)\", advance=\"no\") \" \"\n      end if\n    end do\n    write(*,*)\n  end do\nend subroutine Carpet\nend program Sierpinski_carpet\n", "target": "public static boolean inCarpet(long x, long y) {\n    while (x!=0 && y!=0) {\n        if (x % 3 == 1 && y % 3 == 1)\n            return false;\n        x /= 3;\n        y /= 3;\n    }\n    return true;\n}\n \npublic static void carpet(final int n) {\n    final double power = Math.pow(3,n);\n    for(long i = 0; i < power; i++) {\n        for(long j = 0; j < power; j++) {\n            System.out.print(inCarpet(i, j) ? \"*\" : \" \");\n        }\n        System.out.println();\n    }\n}\n"}
{"id": 40588, "name": "Sierpinski carpet", "source": "Translate Fortran to Python: program Sierpinski_carpet\n  implicit none\n  \n  call carpet(4)\n\ncontains\n\nfunction In_carpet(a, b)\n  logical :: in_carpet\n  integer, intent(in) :: a, b\n  integer :: x, y\n\n  x = a ; y = b\n  do \n    if(x == 0 .or. y == 0) then\n      In_carpet = .true.\n      return\n    else if(mod(x, 3) == 1 .and. mod(y, 3) == 1) then\n      In_carpet = .false.\n      return\n    end if\n    x = x / 3\n    y = y / 3\n  end do\nend function\n\nsubroutine Carpet(n)\n  integer, intent(in) :: n\n  integer :: i, j\n \n  do i = 0, 3**n - 1 \n    do j = 0, 3**n - 1\n      if(In_carpet(i, j)) then\n        write(*, \"(a)\", advance=\"no\") \"#\"\n      else\n        write(*, \"(a)\", advance=\"no\") \" \"\n      end if\n    end do\n    write(*,*)\n  end do\nend subroutine Carpet\nend program Sierpinski_carpet\n", "target": "def setup():\n    size(729, 729)\n    fill(0)\n    background(255)\n    noStroke()\n    rect(width / 3, height / 3, width / 3, width / 3)\n    rectangles(width / 3, height / 3, width / 3)\n\ndef rectangles(x, y, s):\n    if s < 1: return\n    xc, yc = x - s, y - s\n    for row in range(3):\n        for col in range(3):\n            if not (row == 1 and col == 1):\n                xx, yy = xc + row * s, yc + col * s\n                delta = s / 3\n                rect(xx + delta, yy + delta, delta, delta)\n                rectangles(xx + s / 3, yy + s / 3, s / 3)\n"}
{"id": 41192, "name": "Read a file line by line", "source": "Translate Fortran to C#:       INTEGER ENUFF\t\t\n      PARAMETER (ENUFF = 2468)\t\n      CHARACTER*(ENUFF) ALINE\t\n      CHARACTER*66 FNAME\t\n      INTEGER LINPR,IN\t\t\n      INTEGER L,N\t\t\n      LOGICAL EXIST\t\t\n      LINPR = 6\t\t\t\n      IN = 10\t\t\t\n      FNAME = \"Read.for\"\t\n      INQUIRE (FILE = FNAME, EXIST = EXIST)\t\n      IF (.NOT.EXIST) THEN\t\t\n        WRITE (LINPR,1) FNAME\t\t\n    1   FORMAT (\"No sign of file \",A)\t\n        STOP \"No file, no go.\"\t\t\n      END IF\t\t\t\t\n      OPEN (IN,FILE = FNAME, STATUS = \"OLD\", ACTION = \"READ\")\t\n\n      N = 0\t\t\n   10 READ (IN,11,END = 20) L,ALINE(1:MIN(L,ENUFF))\t\n   11 FORMAT (Q,A)\t\t\n      N = N + 1\t\t\t\n      IF (L.GT.ENUFF) WRITE (LINPR,12) N,L,ENUFF\t\n   12 FORMAT (\"Record \",I0,\" has length \",I0,\": my limit is \",I0)\t\n      WRITE (LINPR,13) N,ALINE(1:MIN(L,ENUFF))\t\n   13 FORMAT (I9,\":\",A)\t\t\n      GO TO 10\t\t\t\n\n   20 CLOSE (IN)\t\n      END\t\n", "target": "foreach (string readLine in File.ReadLines(\"FileName\"))\n  DoSomething(readLine);\n"}
{"id": 41195, "name": "Read a file line by line", "source": "Translate Fortran to Java:       INTEGER ENUFF\t\t\n      PARAMETER (ENUFF = 2468)\t\n      CHARACTER*(ENUFF) ALINE\t\n      CHARACTER*66 FNAME\t\n      INTEGER LINPR,IN\t\t\n      INTEGER L,N\t\t\n      LOGICAL EXIST\t\t\n      LINPR = 6\t\t\t\n      IN = 10\t\t\t\n      FNAME = \"Read.for\"\t\n      INQUIRE (FILE = FNAME, EXIST = EXIST)\t\n      IF (.NOT.EXIST) THEN\t\t\n        WRITE (LINPR,1) FNAME\t\t\n    1   FORMAT (\"No sign of file \",A)\t\n        STOP \"No file, no go.\"\t\t\n      END IF\t\t\t\t\n      OPEN (IN,FILE = FNAME, STATUS = \"OLD\", ACTION = \"READ\")\t\n\n      N = 0\t\t\n   10 READ (IN,11,END = 20) L,ALINE(1:MIN(L,ENUFF))\t\n   11 FORMAT (Q,A)\t\t\n      N = N + 1\t\t\t\n      IF (L.GT.ENUFF) WRITE (LINPR,12) N,L,ENUFF\t\n   12 FORMAT (\"Record \",I0,\" has length \",I0,\": my limit is \",I0)\t\n      WRITE (LINPR,13) N,ALINE(1:MIN(L,ENUFF))\t\n   13 FORMAT (I9,\":\",A)\t\t\n      GO TO 10\t\t\t\n\n   20 CLOSE (IN)\t\n      END\t\n", "target": "import java.io.BufferedReader;\nimport java.io.FileReader;\n\n\npublic class ReadFileByLines {\n    private static void processLine(int lineNo, String line) {\n        \n    }\n\n    public static void main(String[] args) {\n        for (String filename : args) {\n            BufferedReader br = null;\n            FileReader fr = null;\n            try {\n                fr = new FileReader(filename);\n                br = new BufferedReader(fr);\n                String line;\n                int lineNo = 0;\n                while ((line = br.readLine()) != null) {\n                    processLine(++lineNo, line);\n                }\n            }\n            catch (Exception x) {\n                x.printStackTrace();\n            }\n            finally {\n                if (fr != null) {\n                    try {br.close();} catch (Exception ignoreMe) {}\n                    try {fr.close();} catch (Exception ignoreMe) {}\n                }\n            }\n        }\n    }\n}\n"}
{"id": 41196, "name": "Read a file line by line", "source": "Translate Fortran to Python:       INTEGER ENUFF\t\t\n      PARAMETER (ENUFF = 2468)\t\n      CHARACTER*(ENUFF) ALINE\t\n      CHARACTER*66 FNAME\t\n      INTEGER LINPR,IN\t\t\n      INTEGER L,N\t\t\n      LOGICAL EXIST\t\t\n      LINPR = 6\t\t\t\n      IN = 10\t\t\t\n      FNAME = \"Read.for\"\t\n      INQUIRE (FILE = FNAME, EXIST = EXIST)\t\n      IF (.NOT.EXIST) THEN\t\t\n        WRITE (LINPR,1) FNAME\t\t\n    1   FORMAT (\"No sign of file \",A)\t\n        STOP \"No file, no go.\"\t\t\n      END IF\t\t\t\t\n      OPEN (IN,FILE = FNAME, STATUS = \"OLD\", ACTION = \"READ\")\t\n\n      N = 0\t\t\n   10 READ (IN,11,END = 20) L,ALINE(1:MIN(L,ENUFF))\t\n   11 FORMAT (Q,A)\t\t\n      N = N + 1\t\t\t\n      IF (L.GT.ENUFF) WRITE (LINPR,12) N,L,ENUFF\t\n   12 FORMAT (\"Record \",I0,\" has length \",I0,\": my limit is \",I0)\t\n      WRITE (LINPR,13) N,ALINE(1:MIN(L,ENUFF))\t\n   13 FORMAT (I9,\":\",A)\t\t\n      GO TO 10\t\t\t\n\n   20 CLOSE (IN)\t\n      END\t\n", "target": "for line in lines open('input.txt'):\n    print line\n"}
{"id": 41456, "name": "Write entire file", "source": "Translate Fortran to C#:       OPEN (F,FILE=\"SomeFileName.txt\",STATUS=\"REPLACE\")\n      WRITE (F,*) \"Whatever you like.\"\n      WRITE (F) BIGARRAY\n", "target": "System.IO.File.WriteAllText(\"filename.txt\", \"This file contains a string.\");\n"}
{"id": 41459, "name": "Write entire file", "source": "Translate Fortran to Java:       OPEN (F,FILE=\"SomeFileName.txt\",STATUS=\"REPLACE\")\n      WRITE (F,*) \"Whatever you like.\"\n      WRITE (F) BIGARRAY\n", "target": "import java.io.*;\n\npublic class Test {\n\n    public static void main(String[] args) throws IOException {\n        try (BufferedWriter bw = new BufferedWriter(new FileWriter(\"test.txt\"))) {\n            bw.write(\"abc\");\n        }\n    }\n}\n"}
{"id": 41460, "name": "Write entire file", "source": "Translate Fortran to Python:       OPEN (F,FILE=\"SomeFileName.txt\",STATUS=\"REPLACE\")\n      WRITE (F,*) \"Whatever you like.\"\n      WRITE (F) BIGARRAY\n", "target": "with open(filename, 'w') as f:\n    f.write(data)\n"}
{"id": 41713, "name": "4-rings or 4-squares puzzle", "source": "Translate Fortran to C#: WRITE(...) FIRST,LAST,IF (UNIQUE) THEN \"Distinct values only\" ELSE \"Repeated values allowed\" FI // \".\"\n", "target": "using System;\nusing System.Linq;\n\nnamespace Four_Squares_Puzzle {\n    class Program {\n        static void Main(string[] args) {\n            fourSquare(1, 7, true, true);\n            fourSquare(3, 9, true, true);\n            fourSquare(0, 9, false, false);\n        }\n\n        private static void fourSquare(int low, int high, bool unique, bool print) {\n            int count = 0;\n\n            if (print) {\n                Console.WriteLine(\"a b c d e f g\");\n            }\n            for (int a = low; a <= high; ++a) {\n                for (int b = low; b <= high; ++b) {\n                    if (notValid(unique, b, a)) continue;\n\n                    int fp = a + b;\n                    for (int c = low; c <= high; ++c) {\n                        if (notValid(unique, c, b, a)) continue;\n                        for (int d = low; d <= high; ++d) {\n                            if (notValid(unique, d, c, b, a)) continue;\n                            if (fp != b + c + d) continue;\n\n                            for (int e = low; e <= high; ++e) {\n                                if (notValid(unique, e, d, c, b, a)) continue;\n                                for (int f = low; f <= high; ++f) {\n                                    if (notValid(unique, f, e, d, c, b, a)) continue;\n                                    if (fp != d + e + f) continue;\n\n                                    for (int g = low; g <= high; ++g) {\n                                        if (notValid(unique, g, f, e, d, c, b, a)) continue;\n                                        if (fp != f + g) continue;\n\n                                        ++count;\n                                        if (print) {\n                                            Console.WriteLine(\"{0} {1} {2} {3} {4} {5} {6}\", a, b, c, d, e, f, g);\n                                        }\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n            if (unique) {\n                Console.WriteLine(\"There are {0} unique solutions in [{1}, {2}]\", count, low, high);\n            }\n            else {\n                Console.WriteLine(\"There are {0} non-unique solutions in [{1}, {2}]\", count, low, high);\n            }\n        }\n\n        private static bool notValid(bool unique, int needle, params int[] haystack) {\n            return unique && haystack.Any(p => p == needle);\n        }\n    }\n}\n"}
{"id": 41714, "name": "4-rings or 4-squares puzzle", "source": "Translate Fortran to C#: WRITE(...) FIRST,LAST,IF (UNIQUE) THEN \"Distinct values only\" ELSE \"Repeated values allowed\" FI // \".\"\n", "target": "using System;\nusing System.Linq;\n\nnamespace Four_Squares_Puzzle {\n    class Program {\n        static void Main(string[] args) {\n            fourSquare(1, 7, true, true);\n            fourSquare(3, 9, true, true);\n            fourSquare(0, 9, false, false);\n        }\n\n        private static void fourSquare(int low, int high, bool unique, bool print) {\n            int count = 0;\n\n            if (print) {\n                Console.WriteLine(\"a b c d e f g\");\n            }\n            for (int a = low; a <= high; ++a) {\n                for (int b = low; b <= high; ++b) {\n                    if (notValid(unique, b, a)) continue;\n\n                    int fp = a + b;\n                    for (int c = low; c <= high; ++c) {\n                        if (notValid(unique, c, b, a)) continue;\n                        for (int d = low; d <= high; ++d) {\n                            if (notValid(unique, d, c, b, a)) continue;\n                            if (fp != b + c + d) continue;\n\n                            for (int e = low; e <= high; ++e) {\n                                if (notValid(unique, e, d, c, b, a)) continue;\n                                for (int f = low; f <= high; ++f) {\n                                    if (notValid(unique, f, e, d, c, b, a)) continue;\n                                    if (fp != d + e + f) continue;\n\n                                    for (int g = low; g <= high; ++g) {\n                                        if (notValid(unique, g, f, e, d, c, b, a)) continue;\n                                        if (fp != f + g) continue;\n\n                                        ++count;\n                                        if (print) {\n                                            Console.WriteLine(\"{0} {1} {2} {3} {4} {5} {6}\", a, b, c, d, e, f, g);\n                                        }\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n            if (unique) {\n                Console.WriteLine(\"There are {0} unique solutions in [{1}, {2}]\", count, low, high);\n            }\n            else {\n                Console.WriteLine(\"There are {0} non-unique solutions in [{1}, {2}]\", count, low, high);\n            }\n        }\n\n        private static bool notValid(bool unique, int needle, params int[] haystack) {\n            return unique && haystack.Any(p => p == needle);\n        }\n    }\n}\n"}
{"id": 41719, "name": "4-rings or 4-squares puzzle", "source": "Translate Fortran to Java: WRITE(...) FIRST,LAST,IF (UNIQUE) THEN \"Distinct values only\" ELSE \"Repeated values allowed\" FI // \".\"\n", "target": "import java.util.Arrays;\n\npublic class FourSquares {\n    public static void main(String[] args) {\n        fourSquare(1, 7, true, true);\n        fourSquare(3, 9, true, true);\n        fourSquare(0, 9, false, false);\n    }\n\n    private static void fourSquare(int low, int high, boolean unique, boolean print) {\n        int count = 0;\n\n        if (print) {\n            System.out.println(\"a b c d e f g\");\n        }\n        for (int a = low; a <= high; ++a) {\n            for (int b = low; b <= high; ++b) {\n                if (notValid(unique, a, b)) continue;\n\n                int fp = a + b;\n                for (int c = low; c <= high; ++c) {\n                    if (notValid(unique, c, a, b)) continue;\n                    for (int d = low; d <= high; ++d) {\n                        if (notValid(unique, d, a, b, c)) continue;\n                        if (fp != b + c + d) continue;\n\n                        for (int e = low; e <= high; ++e) {\n                            if (notValid(unique, e, a, b, c, d)) continue;\n                            for (int f = low; f <= high; ++f) {\n                                if (notValid(unique, f, a, b, c, d, e)) continue;\n                                if (fp != d + e + f) continue;\n\n                                for (int g = low; g <= high; ++g) {\n                                    if (notValid(unique, g, a, b, c, d, e, f)) continue;\n                                    if (fp != f + g) continue;\n\n                                    ++count;\n                                    if (print) {\n                                        System.out.printf(\"%d %d %d %d %d %d %d%n\", a, b, c, d, e, f, g);\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        if (unique) {\n            System.out.printf(\"There are %d unique solutions in [%d, %d]%n\", count, low, high);\n        } else {\n            System.out.printf(\"There are %d non-unique solutions in [%d, %d]%n\", count, low, high);\n        }\n    }\n\n    private static boolean notValid(boolean unique, int needle, int... haystack) {\n        return unique && Arrays.stream(haystack).anyMatch(p -> p == needle);\n    }\n}\n"}
{"id": 41720, "name": "4-rings or 4-squares puzzle", "source": "Translate Fortran to Java: WRITE(...) FIRST,LAST,IF (UNIQUE) THEN \"Distinct values only\" ELSE \"Repeated values allowed\" FI // \".\"\n", "target": "import java.util.Arrays;\n\npublic class FourSquares {\n    public static void main(String[] args) {\n        fourSquare(1, 7, true, true);\n        fourSquare(3, 9, true, true);\n        fourSquare(0, 9, false, false);\n    }\n\n    private static void fourSquare(int low, int high, boolean unique, boolean print) {\n        int count = 0;\n\n        if (print) {\n            System.out.println(\"a b c d e f g\");\n        }\n        for (int a = low; a <= high; ++a) {\n            for (int b = low; b <= high; ++b) {\n                if (notValid(unique, a, b)) continue;\n\n                int fp = a + b;\n                for (int c = low; c <= high; ++c) {\n                    if (notValid(unique, c, a, b)) continue;\n                    for (int d = low; d <= high; ++d) {\n                        if (notValid(unique, d, a, b, c)) continue;\n                        if (fp != b + c + d) continue;\n\n                        for (int e = low; e <= high; ++e) {\n                            if (notValid(unique, e, a, b, c, d)) continue;\n                            for (int f = low; f <= high; ++f) {\n                                if (notValid(unique, f, a, b, c, d, e)) continue;\n                                if (fp != d + e + f) continue;\n\n                                for (int g = low; g <= high; ++g) {\n                                    if (notValid(unique, g, a, b, c, d, e, f)) continue;\n                                    if (fp != f + g) continue;\n\n                                    ++count;\n                                    if (print) {\n                                        System.out.printf(\"%d %d %d %d %d %d %d%n\", a, b, c, d, e, f, g);\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        if (unique) {\n            System.out.printf(\"There are %d unique solutions in [%d, %d]%n\", count, low, high);\n        } else {\n            System.out.printf(\"There are %d non-unique solutions in [%d, %d]%n\", count, low, high);\n        }\n    }\n\n    private static boolean notValid(boolean unique, int needle, int... haystack) {\n        return unique && Arrays.stream(haystack).anyMatch(p -> p == needle);\n    }\n}\n"}
{"id": 41721, "name": "4-rings or 4-squares puzzle", "source": "Translate Fortran to Python: WRITE(...) FIRST,LAST,IF (UNIQUE) THEN \"Distinct values only\" ELSE \"Repeated values allowed\" FI // \".\"\n", "target": "import itertools\n\ndef all_equal(a,b,c,d,e,f,g):\n    return a+b == b+c+d == d+e+f == f+g\n\ndef foursquares(lo,hi,unique,show):\n    solutions = 0\n    if unique:\n        uorn = \"unique\"\n        citer = itertools.combinations(range(lo,hi+1),7)\n    else:\n        uorn = \"non-unique\"\n        citer =  itertools.combinations_with_replacement(range(lo,hi+1),7)\n                    \n    for c in citer:\n            for p in set(itertools.permutations(c)):\n                if all_equal(*p):\n                    solutions += 1\n                    if show:\n                        print str(p)[1:-1]\n\n    print str(solutions)+\" \"+uorn+\" solutions in \"+str(lo)+\" to \"+str(hi)\n    print\n"}
{"id": 41722, "name": "4-rings or 4-squares puzzle", "source": "Translate Fortran to Python: WRITE(...) FIRST,LAST,IF (UNIQUE) THEN \"Distinct values only\" ELSE \"Repeated values allowed\" FI // \".\"\n", "target": "import itertools\n\ndef all_equal(a,b,c,d,e,f,g):\n    return a+b == b+c+d == d+e+f == f+g\n\ndef foursquares(lo,hi,unique,show):\n    solutions = 0\n    if unique:\n        uorn = \"unique\"\n        citer = itertools.combinations(range(lo,hi+1),7)\n    else:\n        uorn = \"non-unique\"\n        citer =  itertools.combinations_with_replacement(range(lo,hi+1),7)\n                    \n    for c in citer:\n            for p in set(itertools.permutations(c)):\n                if all_equal(*p):\n                    solutions += 1\n                    if show:\n                        print str(p)[1:-1]\n\n    print str(solutions)+\" \"+uorn+\" solutions in \"+str(lo)+\" to \"+str(hi)\n    print\n"}
{"id": 42045, "name": "Mutual recursion", "source": "Translate Fortran to C#: module MutualRec\n  implicit none\ncontains\n  pure recursive function m(n) result(r)\n    integer :: r\n    integer, intent(in) :: n\n    if ( n == 0 ) then\n       r = 0\n       return\n    end if\n    r = n - f(m(n-1))\n  end function m\n  \n  pure recursive function f(n) result(r)\n    integer :: r\n    integer, intent(in) :: n\n    if ( n == 0 ) then\n       r = 1\n       return\n    end if\n    r = n - m(f(n-1))\n  end function f\n\nend module\n", "target": "namespace RosettaCode {\n    class Hofstadter {\n        static public int F(int n) {\n            int result = 1;\n            if (n > 0) {\n                result = n - M(F(n-1));\n            }\n\n            return result;\n        }\n\n        static public int M(int n) {\n            int result = 0;\n            if (n > 0) {\n                result = n - F(M(n - 1));\n            }\n\n            return result;\n        }\n    }\n}\n"}
{"id": 42049, "name": "Mutual recursion", "source": "Translate Fortran to Java: module MutualRec\n  implicit none\ncontains\n  pure recursive function m(n) result(r)\n    integer :: r\n    integer, intent(in) :: n\n    if ( n == 0 ) then\n       r = 0\n       return\n    end if\n    r = n - f(m(n-1))\n  end function m\n  \n  pure recursive function f(n) result(r)\n    integer :: r\n    integer, intent(in) :: n\n    if ( n == 0 ) then\n       r = 1\n       return\n    end if\n    r = n - m(f(n-1))\n  end function f\n\nend module\n", "target": "import java.util.HashMap;\nimport java.util.Map;\n\npublic class MutualRecursion {\n\n    public static void main(final String args[]) {\n        int max = 20;\n        System.out.printf(\"First %d values of the Female sequence:  %n\", max);\n        for (int i = 0; i < max; i++) {\n            System.out.printf(\"  f(%d) = %d%n\", i, f(i));\n        }\n        System.out.printf(\"First %d values of the Male sequence:  %n\", max);\n        for (int i = 0; i < 20; i++) {\n            System.out.printf(\"  m(%d) = %d%n\", i, m(i));\n        }\n    }\n\n    private static Map<Integer,Integer> F_MAP = new HashMap<>();\n\n    private static int f(final int n) {\n        if ( F_MAP.containsKey(n) ) {\n            return F_MAP.get(n);\n        }\n        int fn = n == 0 ? 1 : n - m(f(n - 1));\n        F_MAP.put(n, fn);\n        return fn;\n    }\n\n    private static Map<Integer,Integer> M_MAP = new HashMap<>();\n\n    private static int m(final int n) {\n        if ( M_MAP.containsKey(n) ) {\n            return M_MAP.get(n);\n        }\n        int mn = n == 0 ? 0 : n - f(m(n - 1));\n        M_MAP.put(n, mn);\n        return mn;\n    }\n     \n\n}\n"}
{"id": 42050, "name": "Mutual recursion", "source": "Translate Fortran to Python: module MutualRec\n  implicit none\ncontains\n  pure recursive function m(n) result(r)\n    integer :: r\n    integer, intent(in) :: n\n    if ( n == 0 ) then\n       r = 0\n       return\n    end if\n    r = n - f(m(n-1))\n  end function m\n  \n  pure recursive function f(n) result(r)\n    integer :: r\n    integer, intent(in) :: n\n    if ( n == 0 ) then\n       r = 1\n       return\n    end if\n    r = n - m(f(n-1))\n  end function f\n\nend module\n", "target": "def F(n): return 1 if n == 0 else n - M(F(n-1))\ndef M(n): return 0 if n == 0 else n - F(M(n-1))\n\nprint ([ F(n) for n in range(20) ])\nprint ([ M(n) for n in range(20) ])\n"}
{"id": 42980, "name": "Strip comments from a string", "source": "Translate Fortran to C#: \n module string_routines\n\n implicit none\n private\n public :: strip_comments\n contains\n\n \n\t function strip_comments(str,c) result(str2)\n\t implicit none\n\t character(len=*),intent(in) :: str\n\t character(len=1),intent(in) :: c \n\t character(len=len(str)) :: str2\n\t \n\t integer :: i\n\t \n\t i = index(str,c)\n\t if (i>0) then\n\t\tstr2 = str(1:i-1)\n\t else\n\t\tstr2 = str\n\t end if\n\t \n\t end function strip_comments\n \n\n end module string_routines\n\n\n\n program main\n\n\n\n use string_routines, only: strip_comments\n implicit none\n \n write(*,*) strip_comments('apples, pears # and bananas', '#')\n write(*,*) strip_comments('apples, pears\u00a0; and bananas', ';')\n \n\n end program main\n\n", "target": "using System.Text.RegularExpressions;\n\nstring RemoveComments(string str, string delimiter)\n        {\n            \n            \n            \n            return Regex.Replace(str, delimiter + \".+\", string.Empty).Trim();\n        }\n"}
{"id": 42983, "name": "Strip comments from a string", "source": "Translate Fortran to Java: \n module string_routines\n\n implicit none\n private\n public :: strip_comments\n contains\n\n \n\t function strip_comments(str,c) result(str2)\n\t implicit none\n\t character(len=*),intent(in) :: str\n\t character(len=1),intent(in) :: c \n\t character(len=len(str)) :: str2\n\t \n\t integer :: i\n\t \n\t i = index(str,c)\n\t if (i>0) then\n\t\tstr2 = str(1:i-1)\n\t else\n\t\tstr2 = str\n\t end if\n\t \n\t end function strip_comments\n \n\n end module string_routines\n\n\n\n program main\n\n\n\n use string_routines, only: strip_comments\n implicit none\n \n write(*,*) strip_comments('apples, pears # and bananas', '#')\n write(*,*) strip_comments('apples, pears\u00a0; and bananas', ';')\n \n\n end program main\n\n", "target": "import java.io.*;\n\npublic class StripLineComments{\n    public static void main( String[] args ){\n\tif( args.length < 1 ){\n\t    System.out.println(\"Usage: java StripLineComments StringToProcess\");\n\t}\n\telse{\n\t    String inputFile = args[0];\n\t    String input = \"\";\n\t    try{\n\t\tBufferedReader reader = new BufferedReader( new FileReader( inputFile ) );\n\t\tString line = \"\";\n\t\twhile((line = reader.readLine()) != null){\n\t\t    System.out.println( line.split(\"[#;]\")[0] );\n\t\t}\n\t    }\n\t    catch( Exception e ){\n\t\te.printStackTrace();\n\t    }\n\t}\n    }\n}\n"}
{"id": 42984, "name": "Strip comments from a string", "source": "Translate Fortran to Python: \n module string_routines\n\n implicit none\n private\n public :: strip_comments\n contains\n\n \n\t function strip_comments(str,c) result(str2)\n\t implicit none\n\t character(len=*),intent(in) :: str\n\t character(len=1),intent(in) :: c \n\t character(len=len(str)) :: str2\n\t \n\t integer :: i\n\t \n\t i = index(str,c)\n\t if (i>0) then\n\t\tstr2 = str(1:i-1)\n\t else\n\t\tstr2 = str\n\t end if\n\t \n\t end function strip_comments\n \n\n end module string_routines\n\n\n\n program main\n\n\n\n use string_routines, only: strip_comments\n implicit none\n \n write(*,*) strip_comments('apples, pears # and bananas', '#')\n write(*,*) strip_comments('apples, pears\u00a0; and bananas', ';')\n \n\n end program main\n\n", "target": "def remove_comments(line, sep):\n    for s in sep:\n        i = line.find(s)\n        if i >= 0:\n            line = line[:i]\n    return line.strip()\n\n\nprint remove_comments('apples\u00a0; pears \nprint remove_comments('apples\u00a0; pears \n"}
{"id": 43855, "name": "Determine if a string is numeric", "source": "Translate Fortran to C#: FUNCTION is_numeric(string)\n  IMPLICIT NONE\n  CHARACTER(len=*), INTENT(IN) :: string\n  LOGICAL :: is_numeric\n  REAL :: x\n  INTEGER :: e\n  READ(string,*,IOSTAT=e) x\n  is_numeric = e == 0\nEND FUNCTION is_numeric\n", "target": "public static bool IsNumeric(string s)\n{\n    double Result;\n    return double.TryParse(s, out Result);  \n}        \n\nstring value = \"123\";\nif (IsNumeric(value)) \n{\n  \n}\n"}
{"id": 43858, "name": "Determine if a string is numeric", "source": "Translate Fortran to Java: FUNCTION is_numeric(string)\n  IMPLICIT NONE\n  CHARACTER(len=*), INTENT(IN) :: string\n  LOGICAL :: is_numeric\n  REAL :: x\n  INTEGER :: e\n  READ(string,*,IOSTAT=e) x\n  is_numeric = e == 0\nEND FUNCTION is_numeric\n", "target": "public boolean isNumeric(String input) {\n  try {\n    Integer.parseInt(input);\n    return true;\n  }\n  catch (NumberFormatException e) {\n    \n    return false;\n  }\n}\n"}
{"id": 43859, "name": "Determine if a string is numeric", "source": "Translate Fortran to Python: FUNCTION is_numeric(string)\n  IMPLICIT NONE\n  CHARACTER(len=*), INTENT(IN) :: string\n  LOGICAL :: is_numeric\n  REAL :: x\n  INTEGER :: e\n  READ(string,*,IOSTAT=e) x\n  is_numeric = e == 0\nEND FUNCTION is_numeric\n", "target": "def is_numeric(s):\n    try:\n        float(s)\n        return True\n    except (ValueError, TypeError):\n        return False\n\nis_numeric('123.0')\n"}
{"id": 44128, "name": "One-dimensional cellular automata", "source": "Translate Fortran to C#: PROGRAM LIFE_1D\n   \n  IMPLICIT NONE\n\n  LOGICAL :: cells(20) = (/ .FALSE., .TRUE., .TRUE., .TRUE., .FALSE., .TRUE., .TRUE., .FALSE., .TRUE., .FALSE., &\n                            .TRUE., .FALSE., .TRUE., .FALSE., .TRUE., .FALSE., .FALSE., .TRUE., .FALSE., .FALSE. /)\n  INTEGER :: i\n  \n  DO i = 0, 9\n     WRITE(*, \"(A,I0,A)\", ADVANCE = \"NO\") \"Generation \", i, \": \"\n     CALL Drawgen(cells)\n     CALL Nextgen(cells)\n  END DO\n\nCONTAINS\n\n  SUBROUTINE Nextgen(cells)\n    LOGICAL, INTENT (IN OUT) :: cells(:)\n    LOGICAL :: left, centre, right\n    INTEGER :: i\n   \n    left = .FALSE.\n    DO i = 1, SIZE(cells)-1\n       centre = cells(i)\n       right = cells(i+1)\n       IF (left .AND. right) THEN\n          cells(i) = .NOT. cells(i)\n       ELSE IF (.NOT. left .AND. .NOT. right) THEN\n          cells(i) = .FALSE.\n       END IF\n       left = centre\n    END DO\n    cells(SIZE(cells)) = left .AND. right\n  END SUBROUTINE Nextgen\n\n  SUBROUTINE Drawgen(cells)\n    LOGICAL, INTENT (IN OUT) :: cells(:)\n    INTEGER :: i\n   \n    DO i = 1, SIZE(cells)\n       IF (cells(i)) THEN\n          WRITE(*, \"(A)\", ADVANCE = \"NO\") \"#\"\n       ELSE\n          WRITE(*, \"(A)\", ADVANCE = \"NO\") \"_\"\n       END IF\n    END DO\n    WRITE(*,*)\n  END SUBROUTINE Drawgen\n  \nEND PROGRAM LIFE_1D\n", "target": "using System;\nusing System.Collections.Generic;\n\nnamespace prog\n{\n\tclass MainClass\n\t{\t\n\t\tconst int n_iter = 10;\n\t\tstatic int[] f = { 0, 1, 1, 1, 0, 1, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0, 1, 0, 0 };\n\t\t\n\t\tpublic static void Main (string[] args)\n\t\t{\n\t\t\tfor( int i=0; i<f.Length; i++ )\n\t\t\t\tConsole.Write( f[i]==0 ? \"-\" : \"#\" );\n\t\t\tConsole.WriteLine(\"\");\t\t\t\n\t\t\t\n\t\t\tint[] g = new int[f.Length];\n\t\t\tfor( int n=n_iter; n!=0; n-- )\n\t\t\t{\n\t\t\t\tfor( int i=1; i<f.Length-1; i++ )\n\t\t\t\t{\n\t\t\t\t\tif ( (f[i-1] ^ f[i+1]) == 1 ) g[i] = f[i];\n\t\t\t\t\telse if ( f[i] == 0 && (f[i-1] & f[i+1]) == 1 ) g[i] = 1;\n\t\t\t\t\telse g[i] = 0;\n\t\t\t\t}\n\t\t\t\tg[0] = ( (f[0] & f[1]) == 1 ) ? 1 : 0;\n\t\t\t\tg[g.Length-1] = ( (f[f.Length-1] & f[f.Length-2]) == 1 ) ? 1 : 0;\n\t\t\t\t\n\t\t\t\tint[] tmp = f;\n\t\t\t\tf = g;\n\t\t\t\tg = tmp;\n\t\t\t\t\n\t\t\t\tfor( int i=0; i<f.Length; i++ )\n\t\t\t\t\tConsole.Write( f[i]==0 ? \"-\" : \"#\" );\n\t\t\t\tConsole.WriteLine(\"\");\n\t\t\t}\t\t\t\n\t\t}\n\t}\n}\n"}
{"id": 44132, "name": "One-dimensional cellular automata", "source": "Translate Fortran to Java: PROGRAM LIFE_1D\n   \n  IMPLICIT NONE\n\n  LOGICAL :: cells(20) = (/ .FALSE., .TRUE., .TRUE., .TRUE., .FALSE., .TRUE., .TRUE., .FALSE., .TRUE., .FALSE., &\n                            .TRUE., .FALSE., .TRUE., .FALSE., .TRUE., .FALSE., .FALSE., .TRUE., .FALSE., .FALSE. /)\n  INTEGER :: i\n  \n  DO i = 0, 9\n     WRITE(*, \"(A,I0,A)\", ADVANCE = \"NO\") \"Generation \", i, \": \"\n     CALL Drawgen(cells)\n     CALL Nextgen(cells)\n  END DO\n\nCONTAINS\n\n  SUBROUTINE Nextgen(cells)\n    LOGICAL, INTENT (IN OUT) :: cells(:)\n    LOGICAL :: left, centre, right\n    INTEGER :: i\n   \n    left = .FALSE.\n    DO i = 1, SIZE(cells)-1\n       centre = cells(i)\n       right = cells(i+1)\n       IF (left .AND. right) THEN\n          cells(i) = .NOT. cells(i)\n       ELSE IF (.NOT. left .AND. .NOT. right) THEN\n          cells(i) = .FALSE.\n       END IF\n       left = centre\n    END DO\n    cells(SIZE(cells)) = left .AND. right\n  END SUBROUTINE Nextgen\n\n  SUBROUTINE Drawgen(cells)\n    LOGICAL, INTENT (IN OUT) :: cells(:)\n    INTEGER :: i\n   \n    DO i = 1, SIZE(cells)\n       IF (cells(i)) THEN\n          WRITE(*, \"(A)\", ADVANCE = \"NO\") \"#\"\n       ELSE\n          WRITE(*, \"(A)\", ADVANCE = \"NO\") \"_\"\n       END IF\n    END DO\n    WRITE(*,*)\n  END SUBROUTINE Drawgen\n  \nEND PROGRAM LIFE_1D\n", "target": "public class Life{\n\tpublic static void main(String[] args) throws Exception{\n\t\tString start= \"_###_##_#_#_#_#__#__\";\n\t\tint numGens = 10;\n\t\tfor(int i= 0; i < numGens; i++){\n\t\t\tSystem.out.println(\"Generation \" + i + \": \" + start);\n\t\t\tstart= life(start);\n\t\t}\n\t}\n\n\tpublic static String life(String lastGen){\n\t\tString newGen= \"\";\n\t\tfor(int i= 0; i < lastGen.length(); i++){\n\t\t\tint neighbors= 0;\n\t\t\tif (i == 0){\n\t\t\t\tneighbors= lastGen.charAt(1) == '#' ? 1 : 0;\n\t\t\t} else if (i == lastGen.length() - 1){\n\t\t\t\tneighbors= lastGen.charAt(i - 1) == '#' ? 1 : 0;\n\t\t\t} else{\n\t\t\t\tneighbors= getNeighbors(lastGen.substring(i - 1, i + 2));\n\t\t\t}\n\n\t\t\tif (neighbors == 0){\n\t\t\t\tnewGen+= \"_\";\n\t\t\t}\n\t\t\tif (neighbors == 1){\n\t\t\t\tnewGen+= lastGen.charAt(i);\n\t\t\t}\n\t\t\tif (neighbors == 2){\n\t\t\t\tnewGen+= lastGen.charAt(i) == '#' ? \"_\" : \"#\";\n\t\t\t}\n\t\t}\n\t\treturn newGen;\n\t}\n\n\tpublic static int getNeighbors(String group){\n\t\tint ans= 0;\n\t\tif (group.charAt(0) == '#') ans++;\n\t\tif (group.charAt(2) == '#') ans++;\n\t\treturn ans;\n\t}\n}\n"}
{"id": 44133, "name": "One-dimensional cellular automata", "source": "Translate Fortran to Python: PROGRAM LIFE_1D\n   \n  IMPLICIT NONE\n\n  LOGICAL :: cells(20) = (/ .FALSE., .TRUE., .TRUE., .TRUE., .FALSE., .TRUE., .TRUE., .FALSE., .TRUE., .FALSE., &\n                            .TRUE., .FALSE., .TRUE., .FALSE., .TRUE., .FALSE., .FALSE., .TRUE., .FALSE., .FALSE. /)\n  INTEGER :: i\n  \n  DO i = 0, 9\n     WRITE(*, \"(A,I0,A)\", ADVANCE = \"NO\") \"Generation \", i, \": \"\n     CALL Drawgen(cells)\n     CALL Nextgen(cells)\n  END DO\n\nCONTAINS\n\n  SUBROUTINE Nextgen(cells)\n    LOGICAL, INTENT (IN OUT) :: cells(:)\n    LOGICAL :: left, centre, right\n    INTEGER :: i\n   \n    left = .FALSE.\n    DO i = 1, SIZE(cells)-1\n       centre = cells(i)\n       right = cells(i+1)\n       IF (left .AND. right) THEN\n          cells(i) = .NOT. cells(i)\n       ELSE IF (.NOT. left .AND. .NOT. right) THEN\n          cells(i) = .FALSE.\n       END IF\n       left = centre\n    END DO\n    cells(SIZE(cells)) = left .AND. right\n  END SUBROUTINE Nextgen\n\n  SUBROUTINE Drawgen(cells)\n    LOGICAL, INTENT (IN OUT) :: cells(:)\n    INTEGER :: i\n   \n    DO i = 1, SIZE(cells)\n       IF (cells(i)) THEN\n          WRITE(*, \"(A)\", ADVANCE = \"NO\") \"#\"\n       ELSE\n          WRITE(*, \"(A)\", ADVANCE = \"NO\") \"_\"\n       END IF\n    END DO\n    WRITE(*,*)\n  END SUBROUTINE Drawgen\n  \nEND PROGRAM LIFE_1D\n", "target": "import random\n\nprintdead, printlive = '_\nmaxgenerations = 10\ncellcount = 20\noffendvalue = '0'\n\nuniverse = ''.join(random.choice('01') for i in range(cellcount))\n\nneighbours2newstate = {\n '000': '0',\n '001': '0',\n '010': '0',\n '011': '1',\n '100': '0',\n '101': '1',\n '110': '1',\n '111': '0',\n }\n\nfor i in range(maxgenerations):\n    print \"Generation %3i:  %s\" % ( i,\n          universe.replace('0', printdead).replace('1', printlive) )\n    universe = offendvalue + universe + offendvalue\n    universe = ''.join(neighbours2newstate[universe[i:i+3]] for i in range(cellcount))\n"}
{"id": 44913, "name": "Zero to the zero power", "source": "Translate Fortran to C#: program zero\ndouble precision :: i, j\ndouble complex :: z1, z2\ni = 0.0D0\nj = 0.0D0\nz1 = (0.0D0,0.0D0)\nz2 = (0.0D0,0.0D0)\nwrite(*,*) 'When integers are used, we have 0^0 = ', 0**0\nwrite(*,*) 'When double precision numbers are used, we have 0.0^0.0 = ', i**j\nwrite(*,*) 'When complex numbers are used, we have (0.0+0.0i)^(0.0+0.0i) = ', z1**z2\nend program\n", "target": "using System;\n\nnamespace ZeroToTheZeroeth\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            double k = Math.Pow(0, 0);\n            Console.Write(\"0^0 is {0}\", k);           \n        }\n    }\n}\n"}
{"id": 44914, "name": "Zero to the zero power", "source": "Translate Fortran to C#: program zero\ndouble precision :: i, j\ndouble complex :: z1, z2\ni = 0.0D0\nj = 0.0D0\nz1 = (0.0D0,0.0D0)\nz2 = (0.0D0,0.0D0)\nwrite(*,*) 'When integers are used, we have 0^0 = ', 0**0\nwrite(*,*) 'When double precision numbers are used, we have 0.0^0.0 = ', i**j\nwrite(*,*) 'When complex numbers are used, we have (0.0+0.0i)^(0.0+0.0i) = ', z1**z2\nend program\n", "target": "using System;\n\nnamespace ZeroToTheZeroeth\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            double k = Math.Pow(0, 0);\n            Console.Write(\"0^0 is {0}\", k);           \n        }\n    }\n}\n"}
{"id": 44920, "name": "Zero to the zero power", "source": "Translate Fortran to Java: program zero\ndouble precision :: i, j\ndouble complex :: z1, z2\ni = 0.0D0\nj = 0.0D0\nz1 = (0.0D0,0.0D0)\nz2 = (0.0D0,0.0D0)\nwrite(*,*) 'When integers are used, we have 0^0 = ', 0**0\nwrite(*,*) 'When double precision numbers are used, we have 0.0^0.0 = ', i**j\nwrite(*,*) 'When complex numbers are used, we have (0.0+0.0i)^(0.0+0.0i) = ', z1**z2\nend program\n", "target": "System.out.println(Math.pow(0, 0));\n"}
{"id": 44921, "name": "Zero to the zero power", "source": "Translate Fortran to Java: program zero\ndouble precision :: i, j\ndouble complex :: z1, z2\ni = 0.0D0\nj = 0.0D0\nz1 = (0.0D0,0.0D0)\nz2 = (0.0D0,0.0D0)\nwrite(*,*) 'When integers are used, we have 0^0 = ', 0**0\nwrite(*,*) 'When double precision numbers are used, we have 0.0^0.0 = ', i**j\nwrite(*,*) 'When complex numbers are used, we have (0.0+0.0i)^(0.0+0.0i) = ', z1**z2\nend program\n", "target": "System.out.println(Math.pow(0, 0));\n"}
{"id": 44922, "name": "Zero to the zero power", "source": "Translate Fortran to Python: program zero\ndouble precision :: i, j\ndouble complex :: z1, z2\ni = 0.0D0\nj = 0.0D0\nz1 = (0.0D0,0.0D0)\nz2 = (0.0D0,0.0D0)\nwrite(*,*) 'When integers are used, we have 0^0 = ', 0**0\nwrite(*,*) 'When double precision numbers are used, we have 0.0^0.0 = ', i**j\nwrite(*,*) 'When complex numbers are used, we have (0.0+0.0i)^(0.0+0.0i) = ', z1**z2\nend program\n", "target": "from decimal import Decimal\nfrom fractions import Fraction\nfrom itertools import product\n\nzeroes = [0, 0.0, 0j, Decimal(0), Fraction(0, 1), -0.0, -0.0j, Decimal(-0.0)]\nfor i, j in product(zeroes, repeat=2):\n    try:\n        ans = i**j\n    except:\n        ans = '<Exception raised>'\n    print(f'{i!r:>15} ** {j!r:<15} = {ans!r}')\n"}
{"id": 44923, "name": "Zero to the zero power", "source": "Translate Fortran to Python: program zero\ndouble precision :: i, j\ndouble complex :: z1, z2\ni = 0.0D0\nj = 0.0D0\nz1 = (0.0D0,0.0D0)\nz2 = (0.0D0,0.0D0)\nwrite(*,*) 'When integers are used, we have 0^0 = ', 0**0\nwrite(*,*) 'When double precision numbers are used, we have 0.0^0.0 = ', i**j\nwrite(*,*) 'When complex numbers are used, we have (0.0+0.0i)^(0.0+0.0i) = ', z1**z2\nend program\n", "target": "from decimal import Decimal\nfrom fractions import Fraction\nfrom itertools import product\n\nzeroes = [0, 0.0, 0j, Decimal(0), Fraction(0, 1), -0.0, -0.0j, Decimal(-0.0)]\nfor i, j in product(zeroes, repeat=2):\n    try:\n        ans = i**j\n    except:\n        ans = '<Exception raised>'\n    print(f'{i!r:>15} ** {j!r:<15} = {ans!r}')\n"}
{"id": 45281, "name": "Runge-Kutta method", "source": "Translate Fortran to C#: program rungekutta\n    implicit none\n    integer, parameter :: dp = kind(1d0)\n    real(dp) :: t, dt, tstart, tstop\n    real(dp) :: y, k1, k2, k3, k4\n    \n    tstart = 0.0d0\n    tstop = 10.0d0\n    dt = 0.1d0\n    y = 1.0d0\n    t = tstart\n    write (6, '(a,f4.1,a,f12.8,a,es13.6)') 'y(', t, ') = ', y, ' error = ', &\n        abs(y-(t**2+4)**2/16)\n    do while (t < tstop)\n        k1 = dt*f(t, y)\n        k2 = dt*f(t+dt/2, y+k1/2)\n        k3 = dt*f(t+dt/2, y+k2/2)\n        k4 = dt*f(t+dt, y+k3)\n        y = y+(k1+2*(k2+k3)+k4)/6\n        t = t+dt\n        if (abs(nint(t)-t) <= 1d-12) then\n            write (6, '(a,f4.1,a,f12.8,a,es13.6)') 'y(', t, ') = ', y, ' error = ', &\n                abs(y-(t**2+4)**2/16)\n        end if\n    end do\ncontains\n    function f(t,y)\n        real(dp), intent(in) :: t, y\n        real(dp) :: f\n\n        f = t*sqrt(y)\n    end function f\nend program rungekutta\n", "target": "using System;\n\nnamespace RungeKutta\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            \n            double t = 0.0;\n            double T = 10.0;\n            double dt = 0.1;\n\n            \n            int n = (int)(((T - t) / dt)) + 1;\n\n            \n            double[] y = new double[n];\n            double[] s = new double[n];\n\n            \n            double dy1;\n            double dy2;\n            double dy3;\n            double dy4;\n\n            \n            int i = 0;\n            s[i] = 0.0;\n            y[i] = 1.0;\n\n            Console.WriteLine(\" ===================================== \");\n            Console.WriteLine(\" Beging 4th Order Runge Kutta Method \");\n            Console.WriteLine(\" ===================================== \");\n\n            Console.WriteLine();\n            Console.WriteLine(\" Given the example Differential equation: \\n\");\n            Console.WriteLine(\"     y' = t*sqrt(y) \\n\");\n            Console.WriteLine(\" With the initial conditions: \\n\");\n            Console.WriteLine(\"     t0 = 0\" + \", y(0) = 1.0 \\n\");\n            Console.WriteLine(\" Whose exact solution is known to be: \\n\");\n            Console.WriteLine(\"     y(t) = 1/16*(t^2 + 4)^2 \\n\");\n            Console.WriteLine(\" Solve the given equations over the range t = 0...10 with a step value dt = 0.1 \\n\");\n            Console.WriteLine(\" Print the calculated values of y at whole numbered t's (0.0,1.0,...10.0) along with the error \\n\");\n            Console.WriteLine();\n\n            Console.WriteLine(\" y(t) \" +\"RK4\" + \" \".PadRight(18) + \"Absolute Error\");\n            Console.WriteLine(\" -------------------------------------------------\");\n            Console.WriteLine(\" y(0) \" + y[i] + \" \".PadRight(20) + (y[i] - solution(s[i])));\n\n            \n            while (i < y.Length - 1)\n            {\n\n                dy1 = dt * equation(s[i], y[i]);\n                dy2 = dt * equation(s[i] + dt / 2, y[i] + dy1 / 2);\n                dy3 = dt * equation(s[i] + dt / 2, y[i] + dy2 / 2);\n                dy4 = dt * equation(s[i] + dt, y[i] + dy3);\n\n                s[i + 1] = s[i] + dt;\n                y[i + 1] = y[i] + (dy1 + 2 * dy2 + 2 * dy3 + dy4) / 6;\n\n                double error = Math.Abs(y[i + 1] - solution(s[i + 1]));\n                double t_rounded = Math.Round(t + dt, 2);\n\n                if (t_rounded % 1 == 0)\n                {\n                    Console.WriteLine(\" y(\" + t_rounded + \")\" + \" \" + y[i + 1] + \" \".PadRight(5) + (error));\n                }\n\n                i++;\n                t += dt;\n\n            };\n\n            Console.ReadLine();\n        }\n\n        \n        public static double equation(double t, double y)\n        {\n            double y_prime;\n            return y_prime = t*Math.Sqrt(y);\n        }\n\n        \n        public static double solution(double t)\n        {\n            double actual;\n            actual = Math.Pow((Math.Pow(t, 2) + 4), 2)/16;\n            return actual;\n        }\n    }\n}\n"}
{"id": 45282, "name": "Runge-Kutta method", "source": "Translate Fortran to C#: program rungekutta\n    implicit none\n    integer, parameter :: dp = kind(1d0)\n    real(dp) :: t, dt, tstart, tstop\n    real(dp) :: y, k1, k2, k3, k4\n    \n    tstart = 0.0d0\n    tstop = 10.0d0\n    dt = 0.1d0\n    y = 1.0d0\n    t = tstart\n    write (6, '(a,f4.1,a,f12.8,a,es13.6)') 'y(', t, ') = ', y, ' error = ', &\n        abs(y-(t**2+4)**2/16)\n    do while (t < tstop)\n        k1 = dt*f(t, y)\n        k2 = dt*f(t+dt/2, y+k1/2)\n        k3 = dt*f(t+dt/2, y+k2/2)\n        k4 = dt*f(t+dt, y+k3)\n        y = y+(k1+2*(k2+k3)+k4)/6\n        t = t+dt\n        if (abs(nint(t)-t) <= 1d-12) then\n            write (6, '(a,f4.1,a,f12.8,a,es13.6)') 'y(', t, ') = ', y, ' error = ', &\n                abs(y-(t**2+4)**2/16)\n        end if\n    end do\ncontains\n    function f(t,y)\n        real(dp), intent(in) :: t, y\n        real(dp) :: f\n\n        f = t*sqrt(y)\n    end function f\nend program rungekutta\n", "target": "using System;\n\nnamespace RungeKutta\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            \n            double t = 0.0;\n            double T = 10.0;\n            double dt = 0.1;\n\n            \n            int n = (int)(((T - t) / dt)) + 1;\n\n            \n            double[] y = new double[n];\n            double[] s = new double[n];\n\n            \n            double dy1;\n            double dy2;\n            double dy3;\n            double dy4;\n\n            \n            int i = 0;\n            s[i] = 0.0;\n            y[i] = 1.0;\n\n            Console.WriteLine(\" ===================================== \");\n            Console.WriteLine(\" Beging 4th Order Runge Kutta Method \");\n            Console.WriteLine(\" ===================================== \");\n\n            Console.WriteLine();\n            Console.WriteLine(\" Given the example Differential equation: \\n\");\n            Console.WriteLine(\"     y' = t*sqrt(y) \\n\");\n            Console.WriteLine(\" With the initial conditions: \\n\");\n            Console.WriteLine(\"     t0 = 0\" + \", y(0) = 1.0 \\n\");\n            Console.WriteLine(\" Whose exact solution is known to be: \\n\");\n            Console.WriteLine(\"     y(t) = 1/16*(t^2 + 4)^2 \\n\");\n            Console.WriteLine(\" Solve the given equations over the range t = 0...10 with a step value dt = 0.1 \\n\");\n            Console.WriteLine(\" Print the calculated values of y at whole numbered t's (0.0,1.0,...10.0) along with the error \\n\");\n            Console.WriteLine();\n\n            Console.WriteLine(\" y(t) \" +\"RK4\" + \" \".PadRight(18) + \"Absolute Error\");\n            Console.WriteLine(\" -------------------------------------------------\");\n            Console.WriteLine(\" y(0) \" + y[i] + \" \".PadRight(20) + (y[i] - solution(s[i])));\n\n            \n            while (i < y.Length - 1)\n            {\n\n                dy1 = dt * equation(s[i], y[i]);\n                dy2 = dt * equation(s[i] + dt / 2, y[i] + dy1 / 2);\n                dy3 = dt * equation(s[i] + dt / 2, y[i] + dy2 / 2);\n                dy4 = dt * equation(s[i] + dt, y[i] + dy3);\n\n                s[i + 1] = s[i] + dt;\n                y[i + 1] = y[i] + (dy1 + 2 * dy2 + 2 * dy3 + dy4) / 6;\n\n                double error = Math.Abs(y[i + 1] - solution(s[i + 1]));\n                double t_rounded = Math.Round(t + dt, 2);\n\n                if (t_rounded % 1 == 0)\n                {\n                    Console.WriteLine(\" y(\" + t_rounded + \")\" + \" \" + y[i + 1] + \" \".PadRight(5) + (error));\n                }\n\n                i++;\n                t += dt;\n\n            };\n\n            Console.ReadLine();\n        }\n\n        \n        public static double equation(double t, double y)\n        {\n            double y_prime;\n            return y_prime = t*Math.Sqrt(y);\n        }\n\n        \n        public static double solution(double t)\n        {\n            double actual;\n            actual = Math.Pow((Math.Pow(t, 2) + 4), 2)/16;\n            return actual;\n        }\n    }\n}\n"}
{"id": 45288, "name": "Runge-Kutta method", "source": "Translate Fortran to Java: program rungekutta\n    implicit none\n    integer, parameter :: dp = kind(1d0)\n    real(dp) :: t, dt, tstart, tstop\n    real(dp) :: y, k1, k2, k3, k4\n    \n    tstart = 0.0d0\n    tstop = 10.0d0\n    dt = 0.1d0\n    y = 1.0d0\n    t = tstart\n    write (6, '(a,f4.1,a,f12.8,a,es13.6)') 'y(', t, ') = ', y, ' error = ', &\n        abs(y-(t**2+4)**2/16)\n    do while (t < tstop)\n        k1 = dt*f(t, y)\n        k2 = dt*f(t+dt/2, y+k1/2)\n        k3 = dt*f(t+dt/2, y+k2/2)\n        k4 = dt*f(t+dt, y+k3)\n        y = y+(k1+2*(k2+k3)+k4)/6\n        t = t+dt\n        if (abs(nint(t)-t) <= 1d-12) then\n            write (6, '(a,f4.1,a,f12.8,a,es13.6)') 'y(', t, ') = ', y, ' error = ', &\n                abs(y-(t**2+4)**2/16)\n        end if\n    end do\ncontains\n    function f(t,y)\n        real(dp), intent(in) :: t, y\n        real(dp) :: f\n\n        f = t*sqrt(y)\n    end function f\nend program rungekutta\n", "target": "import static java.lang.Math.*;\nimport java.util.function.BiFunction;\n\npublic class RungeKutta {\n\n    static void runge(BiFunction<Double, Double, Double> yp_func, double[] t,\n            double[] y, double dt) {\n\n        for (int n = 0; n < t.length - 1; n++) {\n            double dy1 = dt * yp_func.apply(t[n], y[n]);\n            double dy2 = dt * yp_func.apply(t[n] + dt / 2.0, y[n] + dy1 / 2.0);\n            double dy3 = dt * yp_func.apply(t[n] + dt / 2.0, y[n] + dy2 / 2.0);\n            double dy4 = dt * yp_func.apply(t[n] + dt, y[n] + dy3);\n            t[n + 1] = t[n] + dt;\n            y[n + 1] = y[n] + (dy1 + 2.0 * (dy2 + dy3) + dy4) / 6.0;\n        }\n    }\n\n    static double calc_err(double t, double calc) {\n        double actual = pow(pow(t, 2.0) + 4.0, 2) / 16.0;\n        return abs(actual - calc);\n    }\n\n    public static void main(String[] args) {\n        double dt = 0.10;\n        double[] t_arr = new double[101];\n        double[] y_arr = new double[101];\n        y_arr[0] = 1.0;\n\n        runge((t, y) -> t * sqrt(y), t_arr, y_arr, dt);\n\n        for (int i = 0; i < t_arr.length; i++)\n            if (i % 10 == 0)\n                System.out.printf(\"y(%.1f) =\u00a0%.8f Error:\u00a0%.6f%n\",\n                        t_arr[i], y_arr[i],\n                        calc_err(t_arr[i], y_arr[i]));\n    }\n}\n"}
{"id": 45289, "name": "Runge-Kutta method", "source": "Translate Fortran to Java: program rungekutta\n    implicit none\n    integer, parameter :: dp = kind(1d0)\n    real(dp) :: t, dt, tstart, tstop\n    real(dp) :: y, k1, k2, k3, k4\n    \n    tstart = 0.0d0\n    tstop = 10.0d0\n    dt = 0.1d0\n    y = 1.0d0\n    t = tstart\n    write (6, '(a,f4.1,a,f12.8,a,es13.6)') 'y(', t, ') = ', y, ' error = ', &\n        abs(y-(t**2+4)**2/16)\n    do while (t < tstop)\n        k1 = dt*f(t, y)\n        k2 = dt*f(t+dt/2, y+k1/2)\n        k3 = dt*f(t+dt/2, y+k2/2)\n        k4 = dt*f(t+dt, y+k3)\n        y = y+(k1+2*(k2+k3)+k4)/6\n        t = t+dt\n        if (abs(nint(t)-t) <= 1d-12) then\n            write (6, '(a,f4.1,a,f12.8,a,es13.6)') 'y(', t, ') = ', y, ' error = ', &\n                abs(y-(t**2+4)**2/16)\n        end if\n    end do\ncontains\n    function f(t,y)\n        real(dp), intent(in) :: t, y\n        real(dp) :: f\n\n        f = t*sqrt(y)\n    end function f\nend program rungekutta\n", "target": "import static java.lang.Math.*;\nimport java.util.function.BiFunction;\n\npublic class RungeKutta {\n\n    static void runge(BiFunction<Double, Double, Double> yp_func, double[] t,\n            double[] y, double dt) {\n\n        for (int n = 0; n < t.length - 1; n++) {\n            double dy1 = dt * yp_func.apply(t[n], y[n]);\n            double dy2 = dt * yp_func.apply(t[n] + dt / 2.0, y[n] + dy1 / 2.0);\n            double dy3 = dt * yp_func.apply(t[n] + dt / 2.0, y[n] + dy2 / 2.0);\n            double dy4 = dt * yp_func.apply(t[n] + dt, y[n] + dy3);\n            t[n + 1] = t[n] + dt;\n            y[n + 1] = y[n] + (dy1 + 2.0 * (dy2 + dy3) + dy4) / 6.0;\n        }\n    }\n\n    static double calc_err(double t, double calc) {\n        double actual = pow(pow(t, 2.0) + 4.0, 2) / 16.0;\n        return abs(actual - calc);\n    }\n\n    public static void main(String[] args) {\n        double dt = 0.10;\n        double[] t_arr = new double[101];\n        double[] y_arr = new double[101];\n        y_arr[0] = 1.0;\n\n        runge((t, y) -> t * sqrt(y), t_arr, y_arr, dt);\n\n        for (int i = 0; i < t_arr.length; i++)\n            if (i % 10 == 0)\n                System.out.printf(\"y(%.1f) =\u00a0%.8f Error:\u00a0%.6f%n\",\n                        t_arr[i], y_arr[i],\n                        calc_err(t_arr[i], y_arr[i]));\n    }\n}\n"}
{"id": 45290, "name": "Runge-Kutta method", "source": "Translate Fortran to Python: program rungekutta\n    implicit none\n    integer, parameter :: dp = kind(1d0)\n    real(dp) :: t, dt, tstart, tstop\n    real(dp) :: y, k1, k2, k3, k4\n    \n    tstart = 0.0d0\n    tstop = 10.0d0\n    dt = 0.1d0\n    y = 1.0d0\n    t = tstart\n    write (6, '(a,f4.1,a,f12.8,a,es13.6)') 'y(', t, ') = ', y, ' error = ', &\n        abs(y-(t**2+4)**2/16)\n    do while (t < tstop)\n        k1 = dt*f(t, y)\n        k2 = dt*f(t+dt/2, y+k1/2)\n        k3 = dt*f(t+dt/2, y+k2/2)\n        k4 = dt*f(t+dt, y+k3)\n        y = y+(k1+2*(k2+k3)+k4)/6\n        t = t+dt\n        if (abs(nint(t)-t) <= 1d-12) then\n            write (6, '(a,f4.1,a,f12.8,a,es13.6)') 'y(', t, ') = ', y, ' error = ', &\n                abs(y-(t**2+4)**2/16)\n        end if\n    end do\ncontains\n    function f(t,y)\n        real(dp), intent(in) :: t, y\n        real(dp) :: f\n\n        f = t*sqrt(y)\n    end function f\nend program rungekutta\n", "target": "from math import sqrt\n \ndef rk4(f, x0, y0, x1, n):\n    vx = [0] * (n + 1)\n    vy = [0] * (n + 1)\n    h = (x1 - x0) / float(n)\n    vx[0] = x = x0\n    vy[0] = y = y0\n    for i in range(1, n + 1):\n        k1 = h * f(x, y)\n        k2 = h * f(x + 0.5 * h, y + 0.5 * k1)\n        k3 = h * f(x + 0.5 * h, y + 0.5 * k2)\n        k4 = h * f(x + h, y + k3)\n        vx[i] = x = x0 + i * h\n        vy[i] = y = y + (k1 + k2 + k2 + k3 + k3 + k4) / 6\n    return vx, vy\n \ndef f(x, y):\n    return x * sqrt(y)\n \nvx, vy = rk4(f, 0, 1, 10, 100)\nfor x, y in list(zip(vx, vy))[::10]:\n    print(\"%4.1f %10.5f %+12.4e\" % (x, y, y - (4 + x * x)**2 / 16))\n\n 0.0    1.00000  +0.0000e+00\n 1.0    1.56250  -1.4572e-07\n 2.0    4.00000  -9.1948e-07\n 3.0   10.56250  -2.9096e-06\n 4.0   24.99999  -6.2349e-06\n 5.0   52.56249  -1.0820e-05\n 6.0   99.99998  -1.6595e-05\n 7.0  175.56248  -2.3518e-05\n 8.0  288.99997  -3.1565e-05\n 9.0  451.56246  -4.0723e-05\n10.0  675.99995  -5.0983e-05\n"}
{"id": 45291, "name": "Runge-Kutta method", "source": "Translate Fortran to Python: program rungekutta\n    implicit none\n    integer, parameter :: dp = kind(1d0)\n    real(dp) :: t, dt, tstart, tstop\n    real(dp) :: y, k1, k2, k3, k4\n    \n    tstart = 0.0d0\n    tstop = 10.0d0\n    dt = 0.1d0\n    y = 1.0d0\n    t = tstart\n    write (6, '(a,f4.1,a,f12.8,a,es13.6)') 'y(', t, ') = ', y, ' error = ', &\n        abs(y-(t**2+4)**2/16)\n    do while (t < tstop)\n        k1 = dt*f(t, y)\n        k2 = dt*f(t+dt/2, y+k1/2)\n        k3 = dt*f(t+dt/2, y+k2/2)\n        k4 = dt*f(t+dt, y+k3)\n        y = y+(k1+2*(k2+k3)+k4)/6\n        t = t+dt\n        if (abs(nint(t)-t) <= 1d-12) then\n            write (6, '(a,f4.1,a,f12.8,a,es13.6)') 'y(', t, ') = ', y, ' error = ', &\n                abs(y-(t**2+4)**2/16)\n        end if\n    end do\ncontains\n    function f(t,y)\n        real(dp), intent(in) :: t, y\n        real(dp) :: f\n\n        f = t*sqrt(y)\n    end function f\nend program rungekutta\n", "target": "from math import sqrt\n \ndef rk4(f, x0, y0, x1, n):\n    vx = [0] * (n + 1)\n    vy = [0] * (n + 1)\n    h = (x1 - x0) / float(n)\n    vx[0] = x = x0\n    vy[0] = y = y0\n    for i in range(1, n + 1):\n        k1 = h * f(x, y)\n        k2 = h * f(x + 0.5 * h, y + 0.5 * k1)\n        k3 = h * f(x + 0.5 * h, y + 0.5 * k2)\n        k4 = h * f(x + h, y + k3)\n        vx[i] = x = x0 + i * h\n        vy[i] = y = y + (k1 + k2 + k2 + k3 + k3 + k4) / 6\n    return vx, vy\n \ndef f(x, y):\n    return x * sqrt(y)\n \nvx, vy = rk4(f, 0, 1, 10, 100)\nfor x, y in list(zip(vx, vy))[::10]:\n    print(\"%4.1f %10.5f %+12.4e\" % (x, y, y - (4 + x * x)**2 / 16))\n\n 0.0    1.00000  +0.0000e+00\n 1.0    1.56250  -1.4572e-07\n 2.0    4.00000  -9.1948e-07\n 3.0   10.56250  -2.9096e-06\n 4.0   24.99999  -6.2349e-06\n 5.0   52.56249  -1.0820e-05\n 6.0   99.99998  -1.6595e-05\n 7.0  175.56248  -2.3518e-05\n 8.0  288.99997  -3.1565e-05\n 9.0  451.56246  -4.0723e-05\n10.0  675.99995  -5.0983e-05\n"}
{"id": 45622, "name": "Multiplication tables", "source": "Translate Fortran to C#: program multtable\nimplicit none\n\n  integer :: i, j, k\n\n    write(*, \"(a)\") \" x|   1   2   3   4   5   6   7   8   9  10  11  12\"\n    write(*, \"(a)\") \"--+------------------------------------------------\"\n    do i = 1, 12\n      write(*, \"(i2, a)\", advance=\"no\") i, \"|\"\n\tdo k = 2, i\n    \t  write(*, \"(a4)\", advance=\"no\") \"\"\n        end do\n    \tdo j = i, 12\n          write(*, \"(i4)\", advance=\"no\") i*j\n        end do\n        write(*, *)\n    end do\n\nend program multtable\n", "target": "using System;\n\nnamespace multtbl\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            Console.Write(\" X\".PadRight(4));\n            for (int i = 1; i <= 12; i++)\n                Console.Write(i.ToString(\"####\").PadLeft(4));\n\n            Console.WriteLine();\n            Console.Write(\" ___\");\n\n            for (int i = 1; i <= 12; i++)\n                Console.Write(\" ___\");\n\n            Console.WriteLine();\n            for (int row = 1; row <= 12; row++)\n            {\n                Console.Write(row.ToString(\"###\").PadLeft(3).PadRight(4));\n                for (int col = 1; col <= 12; col++)\n                {\n                    if (row <= col)\n                        Console.Write((row * col).ToString(\"###\").PadLeft(4));\n                    else\n                        Console.Write(\"\".PadLeft(4));\n                }\n\n                Console.WriteLine();\n            }\n\n            Console.WriteLine();\n            Console.ReadLine();\n        }\n    }\n}\n"}
{"id": 45625, "name": "Multiplication tables", "source": "Translate Fortran to Java: program multtable\nimplicit none\n\n  integer :: i, j, k\n\n    write(*, \"(a)\") \" x|   1   2   3   4   5   6   7   8   9  10  11  12\"\n    write(*, \"(a)\") \"--+------------------------------------------------\"\n    do i = 1, 12\n      write(*, \"(i2, a)\", advance=\"no\") i, \"|\"\n\tdo k = 2, i\n    \t  write(*, \"(a4)\", advance=\"no\") \"\"\n        end do\n    \tdo j = i, 12\n          write(*, \"(i4)\", advance=\"no\") i*j\n        end do\n        write(*, *)\n    end do\n\nend program multtable\n", "target": "public class MultiplicationTable {\n    public static void main(String[] args) {\n        for (int i = 1; i <= 12; i++)\n            System.out.print(\"\\t\" + i);\n        \n        System.out.println();\n        for (int i = 0; i < 100; i++)\n            System.out.print(\"-\");\n        System.out.println();\n        for (int i = 1; i <= 12; i++) {\n            System.out.print(i + \"|\");\n            for(int j = 1; j <= 12; j++) {\n                System.out.print(\"\\t\");\n                if (j >= i)\n                    System.out.print(\"\\t\" + i * j);\n            }\n            System.out.println();\n        }\n    }\n}\n"}
{"id": 45626, "name": "Multiplication tables", "source": "Translate Fortran to Python: program multtable\nimplicit none\n\n  integer :: i, j, k\n\n    write(*, \"(a)\") \" x|   1   2   3   4   5   6   7   8   9  10  11  12\"\n    write(*, \"(a)\") \"--+------------------------------------------------\"\n    do i = 1, 12\n      write(*, \"(i2, a)\", advance=\"no\") i, \"|\"\n\tdo k = 2, i\n    \t  write(*, \"(a4)\", advance=\"no\") \"\"\n        end do\n    \tdo j = i, 12\n          write(*, \"(i4)\", advance=\"no\") i*j\n        end do\n        write(*, *)\n    end do\n\nend program multtable\n", "target": ">>> size = 12\n>>> width = len(str(size**2))\n>>> for row in range(-1,size+1):\n\tif row==0:\n\t\tprint(\"\u2500\"*width + \"\u253c\"+\"\u2500\"*((width+1)*size-1))\n\telse:\n\t\tprint(\"\".join(\"%*s%1s\" % ((width,) + ((\"x\",\"\u2502\")      if row==-1 and col==0\n\t\t\t\t\t              else (row,\"\u2502\") if row>0   and col==0\n\t\t\t\t\t              else (col,\"\")  if row==-1\n\t\t\t\t\t              else (\"\",\"\")   if row>col\n\t\t\t\t\t              else (row*col,\"\")))\n\t\t\t       for col in range(size+1)))\n\n\t\t\n  x\u2502  1   2   3   4   5   6   7   8   9  10  11  12 \n\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n  1\u2502  1   2   3   4   5   6   7   8   9  10  11  12 \n  2\u2502      4   6   8  10  12  14  16  18  20  22  24 \n  3\u2502          9  12  15  18  21  24  27  30  33  36 \n  4\u2502             16  20  24  28  32  36  40  44  48 \n  5\u2502                 25  30  35  40  45  50  55  60 \n  6\u2502                     36  42  48  54  60  66  72 \n  7\u2502                         49  56  63  70  77  84 \n  8\u2502                             64  72  80  88  96 \n  9\u2502                                 81  90  99 108 \n 10\u2502                                    100 110 120 \n 11\u2502                                        121 132 \n 12\u2502                                            144 \n>>>\n"}
{"id": 45914, "name": "Comma quibbling", "source": "Translate Fortran to C#:       SUBROUTINE QUIBBLE(TEXT,OXFORDIAN)\t\n       CHARACTER*(*) TEXT\t\n       LOGICAL OXFORDIAN\t\n       INTEGER IST(6),LST(6)\t\n       INTEGER N,L,I\t\t\n       INTEGER L1,L2\t\t\n       INTEGER MSG\t\t\n       COMMON /IODEV/MSG\t\nChop the text into words.\n        N = 0\t\t\n        L = LEN(TEXT)\t\n        L2 = 0\t\t\n   10   L1 = L2\t\t\n   11   L1 = L1 + 1\t\t\n        IF (L1.GT.L) GO TO 20\t\t\n        IF (TEXT(L1:L1).LE.\" \") GO TO 11\t\n        L2 = L1\t\t\t\n   12   L2 = L2 + 1\t\t\n        IF (L2.GT.L) GO TO 13\t\n        IF (TEXT(L2:L2).GT.\" \") GO TO 12\t\n   13   N = N + 1\t\t\t\n        IST(N) = L1\t\t\n        LST(N) = L2 - 1\t\t\n        IF (L2.LT.L) GO TO 10\t\nComma time...\n   20   WRITE (MSG,21) \"{\"\t\n   21   FORMAT (A,$)\t\t\n        DO I = 1,N\t\t\n          IF (I.GT.1) THEN\t\t\n            IF (I.LT.N) THEN\t\t\t\n              WRITE (MSG,21) \", \"\t\t\t\n            ELSE IF (OXFORDIAN) THEN\t\t\n              WRITE (MSG,21) \", and \"\t\t\t\n            ELSE\t\t\t\t\n              WRITE (MSG,21) \" and \"\t\t\t\n            END IF\t\t\t\t\n          END IF\t\t\t\n          WRITE (MSG,21) TEXT(IST(I):LST(I))\t\n        END DO\t\t\t\n        WRITE (MSG,\"('}')\")\t\n      END\t\t\n\n      PROGRAM ENCOMMA\t\n      CHARACTER*(666) TEXT\t\n      INTEGER KBD,MSG,INF\t\n      COMMON /IODEV/MSG,KBD\t\n      KBD = 5\t\n      MSG = 6\t\n      INF = 10\t\n      OPEN (INF,FILE=\"List.txt\",ACTION = \"READ\")\t\n\n   10 WRITE (MSG,11) \"To insert commas into lists...\"\t\n   11 FORMAT (A)\t\t\t\n   12 READ (INF,11,END = 20) TEXT\t\n      CALL QUIBBLE(TEXT,.FALSE.)\t\n      GO TO 12\t\t\t\t\n\n   20 REWIND (INF)\t\t\t\n      WRITE (MSG,11)\t\t\t\n      WRITE (MSG,11) \"Oxford style...\"\t\n   21 READ (INF,11,END = 30) TEXT\t\n      CALL QUIBBLE(TEXT,.TRUE.)\t\t\n      GO TO 21\t\t\t\t\n\nClosedown\n   30 END\t\n", "target": "using System;\nusing System.Linq;\n\nnamespace CommaQuibbling\n{\n    internal static class Program\n    {\n        #region Static Members\n\tprivate static string Quibble(string[] input)\n\t{\n            return\n                String.Format(\"{{{0}}}\",\n                    String.Join(\"\",\n                        input.Reverse().Zip(\n                            new [] { \"\", \" and \" }.Concat(Enumerable.Repeat(\", \", int.MaxValue)),\n                            (x, y) => x + y).Reverse()));\n\t}\n\n\n        private static void Main()\n        {\n            Console.WriteLine( Quibble( new string[] {} ) );\n            Console.WriteLine( Quibble( new[] {\"ABC\"} ) );\n            Console.WriteLine( Quibble( new[] {\"ABC\", \"DEF\"} ) );\n            Console.WriteLine( Quibble( new[] {\"ABC\", \"DEF\", \"G\", \"H\"} ) );\n\n            Console.WriteLine( \"< Press Any Key >\" );\n            Console.ReadKey();\n        }\n\n        #endregion\n    }\n}\n"}
{"id": 45915, "name": "Comma quibbling", "source": "Translate Fortran to C#:       SUBROUTINE QUIBBLE(TEXT,OXFORDIAN)\t\n       CHARACTER*(*) TEXT\t\n       LOGICAL OXFORDIAN\t\n       INTEGER IST(6),LST(6)\t\n       INTEGER N,L,I\t\t\n       INTEGER L1,L2\t\t\n       INTEGER MSG\t\t\n       COMMON /IODEV/MSG\t\nChop the text into words.\n        N = 0\t\t\n        L = LEN(TEXT)\t\n        L2 = 0\t\t\n   10   L1 = L2\t\t\n   11   L1 = L1 + 1\t\t\n        IF (L1.GT.L) GO TO 20\t\t\n        IF (TEXT(L1:L1).LE.\" \") GO TO 11\t\n        L2 = L1\t\t\t\n   12   L2 = L2 + 1\t\t\n        IF (L2.GT.L) GO TO 13\t\n        IF (TEXT(L2:L2).GT.\" \") GO TO 12\t\n   13   N = N + 1\t\t\t\n        IST(N) = L1\t\t\n        LST(N) = L2 - 1\t\t\n        IF (L2.LT.L) GO TO 10\t\nComma time...\n   20   WRITE (MSG,21) \"{\"\t\n   21   FORMAT (A,$)\t\t\n        DO I = 1,N\t\t\n          IF (I.GT.1) THEN\t\t\n            IF (I.LT.N) THEN\t\t\t\n              WRITE (MSG,21) \", \"\t\t\t\n            ELSE IF (OXFORDIAN) THEN\t\t\n              WRITE (MSG,21) \", and \"\t\t\t\n            ELSE\t\t\t\t\n              WRITE (MSG,21) \" and \"\t\t\t\n            END IF\t\t\t\t\n          END IF\t\t\t\n          WRITE (MSG,21) TEXT(IST(I):LST(I))\t\n        END DO\t\t\t\n        WRITE (MSG,\"('}')\")\t\n      END\t\t\n\n      PROGRAM ENCOMMA\t\n      CHARACTER*(666) TEXT\t\n      INTEGER KBD,MSG,INF\t\n      COMMON /IODEV/MSG,KBD\t\n      KBD = 5\t\n      MSG = 6\t\n      INF = 10\t\n      OPEN (INF,FILE=\"List.txt\",ACTION = \"READ\")\t\n\n   10 WRITE (MSG,11) \"To insert commas into lists...\"\t\n   11 FORMAT (A)\t\t\t\n   12 READ (INF,11,END = 20) TEXT\t\n      CALL QUIBBLE(TEXT,.FALSE.)\t\n      GO TO 12\t\t\t\t\n\n   20 REWIND (INF)\t\t\t\n      WRITE (MSG,11)\t\t\t\n      WRITE (MSG,11) \"Oxford style...\"\t\n   21 READ (INF,11,END = 30) TEXT\t\n      CALL QUIBBLE(TEXT,.TRUE.)\t\t\n      GO TO 21\t\t\t\t\n\nClosedown\n   30 END\t\n", "target": "using System;\nusing System.Linq;\n\nnamespace CommaQuibbling\n{\n    internal static class Program\n    {\n        #region Static Members\n\tprivate static string Quibble(string[] input)\n\t{\n            return\n                String.Format(\"{{{0}}}\",\n                    String.Join(\"\",\n                        input.Reverse().Zip(\n                            new [] { \"\", \" and \" }.Concat(Enumerable.Repeat(\", \", int.MaxValue)),\n                            (x, y) => x + y).Reverse()));\n\t}\n\n\n        private static void Main()\n        {\n            Console.WriteLine( Quibble( new string[] {} ) );\n            Console.WriteLine( Quibble( new[] {\"ABC\"} ) );\n            Console.WriteLine( Quibble( new[] {\"ABC\", \"DEF\"} ) );\n            Console.WriteLine( Quibble( new[] {\"ABC\", \"DEF\", \"G\", \"H\"} ) );\n\n            Console.WriteLine( \"< Press Any Key >\" );\n            Console.ReadKey();\n        }\n\n        #endregion\n    }\n}\n"}
{"id": 45920, "name": "Comma quibbling", "source": "Translate Fortran to Java:       SUBROUTINE QUIBBLE(TEXT,OXFORDIAN)\t\n       CHARACTER*(*) TEXT\t\n       LOGICAL OXFORDIAN\t\n       INTEGER IST(6),LST(6)\t\n       INTEGER N,L,I\t\t\n       INTEGER L1,L2\t\t\n       INTEGER MSG\t\t\n       COMMON /IODEV/MSG\t\nChop the text into words.\n        N = 0\t\t\n        L = LEN(TEXT)\t\n        L2 = 0\t\t\n   10   L1 = L2\t\t\n   11   L1 = L1 + 1\t\t\n        IF (L1.GT.L) GO TO 20\t\t\n        IF (TEXT(L1:L1).LE.\" \") GO TO 11\t\n        L2 = L1\t\t\t\n   12   L2 = L2 + 1\t\t\n        IF (L2.GT.L) GO TO 13\t\n        IF (TEXT(L2:L2).GT.\" \") GO TO 12\t\n   13   N = N + 1\t\t\t\n        IST(N) = L1\t\t\n        LST(N) = L2 - 1\t\t\n        IF (L2.LT.L) GO TO 10\t\nComma time...\n   20   WRITE (MSG,21) \"{\"\t\n   21   FORMAT (A,$)\t\t\n        DO I = 1,N\t\t\n          IF (I.GT.1) THEN\t\t\n            IF (I.LT.N) THEN\t\t\t\n              WRITE (MSG,21) \", \"\t\t\t\n            ELSE IF (OXFORDIAN) THEN\t\t\n              WRITE (MSG,21) \", and \"\t\t\t\n            ELSE\t\t\t\t\n              WRITE (MSG,21) \" and \"\t\t\t\n            END IF\t\t\t\t\n          END IF\t\t\t\n          WRITE (MSG,21) TEXT(IST(I):LST(I))\t\n        END DO\t\t\t\n        WRITE (MSG,\"('}')\")\t\n      END\t\t\n\n      PROGRAM ENCOMMA\t\n      CHARACTER*(666) TEXT\t\n      INTEGER KBD,MSG,INF\t\n      COMMON /IODEV/MSG,KBD\t\n      KBD = 5\t\n      MSG = 6\t\n      INF = 10\t\n      OPEN (INF,FILE=\"List.txt\",ACTION = \"READ\")\t\n\n   10 WRITE (MSG,11) \"To insert commas into lists...\"\t\n   11 FORMAT (A)\t\t\t\n   12 READ (INF,11,END = 20) TEXT\t\n      CALL QUIBBLE(TEXT,.FALSE.)\t\n      GO TO 12\t\t\t\t\n\n   20 REWIND (INF)\t\t\t\n      WRITE (MSG,11)\t\t\t\n      WRITE (MSG,11) \"Oxford style...\"\t\n   21 READ (INF,11,END = 30) TEXT\t\n      CALL QUIBBLE(TEXT,.TRUE.)\t\t\n      GO TO 21\t\t\t\t\n\nClosedown\n   30 END\t\n", "target": "public class Quibbler {\n\n\tpublic static String quibble(String[] words) {\n\t\tString qText = \"{\";\n\t\tfor(int wIndex = 0; wIndex < words.length; wIndex++) {\n\t\t\tqText += words[wIndex] + (wIndex == words.length-1 ? \"\" : \n\t\t\t\t\t\t  wIndex == words.length-2 ? \" and \" :\n\t\t\t\t\t\t  \", \";\n\t\t}\n\t\tqText += \"}\";\n\t\treturn qText;\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tSystem.out.println(quibble(new String[]{}));\n\t\tSystem.out.println(quibble(new String[]{\"ABC\"}));\n\t\tSystem.out.println(quibble(new String[]{\"ABC\", \"DEF\"}));\n\t\tSystem.out.println(quibble(new String[]{\"ABC\", \"DEF\", \"G\"}));\n\t\tSystem.out.println(quibble(new String[]{\"ABC\", \"DEF\", \"G\", \"H\"}));\n\t}\n}\n"}
{"id": 45921, "name": "Comma quibbling", "source": "Translate Fortran to Java:       SUBROUTINE QUIBBLE(TEXT,OXFORDIAN)\t\n       CHARACTER*(*) TEXT\t\n       LOGICAL OXFORDIAN\t\n       INTEGER IST(6),LST(6)\t\n       INTEGER N,L,I\t\t\n       INTEGER L1,L2\t\t\n       INTEGER MSG\t\t\n       COMMON /IODEV/MSG\t\nChop the text into words.\n        N = 0\t\t\n        L = LEN(TEXT)\t\n        L2 = 0\t\t\n   10   L1 = L2\t\t\n   11   L1 = L1 + 1\t\t\n        IF (L1.GT.L) GO TO 20\t\t\n        IF (TEXT(L1:L1).LE.\" \") GO TO 11\t\n        L2 = L1\t\t\t\n   12   L2 = L2 + 1\t\t\n        IF (L2.GT.L) GO TO 13\t\n        IF (TEXT(L2:L2).GT.\" \") GO TO 12\t\n   13   N = N + 1\t\t\t\n        IST(N) = L1\t\t\n        LST(N) = L2 - 1\t\t\n        IF (L2.LT.L) GO TO 10\t\nComma time...\n   20   WRITE (MSG,21) \"{\"\t\n   21   FORMAT (A,$)\t\t\n        DO I = 1,N\t\t\n          IF (I.GT.1) THEN\t\t\n            IF (I.LT.N) THEN\t\t\t\n              WRITE (MSG,21) \", \"\t\t\t\n            ELSE IF (OXFORDIAN) THEN\t\t\n              WRITE (MSG,21) \", and \"\t\t\t\n            ELSE\t\t\t\t\n              WRITE (MSG,21) \" and \"\t\t\t\n            END IF\t\t\t\t\n          END IF\t\t\t\n          WRITE (MSG,21) TEXT(IST(I):LST(I))\t\n        END DO\t\t\t\n        WRITE (MSG,\"('}')\")\t\n      END\t\t\n\n      PROGRAM ENCOMMA\t\n      CHARACTER*(666) TEXT\t\n      INTEGER KBD,MSG,INF\t\n      COMMON /IODEV/MSG,KBD\t\n      KBD = 5\t\n      MSG = 6\t\n      INF = 10\t\n      OPEN (INF,FILE=\"List.txt\",ACTION = \"READ\")\t\n\n   10 WRITE (MSG,11) \"To insert commas into lists...\"\t\n   11 FORMAT (A)\t\t\t\n   12 READ (INF,11,END = 20) TEXT\t\n      CALL QUIBBLE(TEXT,.FALSE.)\t\n      GO TO 12\t\t\t\t\n\n   20 REWIND (INF)\t\t\t\n      WRITE (MSG,11)\t\t\t\n      WRITE (MSG,11) \"Oxford style...\"\t\n   21 READ (INF,11,END = 30) TEXT\t\n      CALL QUIBBLE(TEXT,.TRUE.)\t\t\n      GO TO 21\t\t\t\t\n\nClosedown\n   30 END\t\n", "target": "public class Quibbler {\n\n\tpublic static String quibble(String[] words) {\n\t\tString qText = \"{\";\n\t\tfor(int wIndex = 0; wIndex < words.length; wIndex++) {\n\t\t\tqText += words[wIndex] + (wIndex == words.length-1 ? \"\" : \n\t\t\t\t\t\t  wIndex == words.length-2 ? \" and \" :\n\t\t\t\t\t\t  \", \";\n\t\t}\n\t\tqText += \"}\";\n\t\treturn qText;\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tSystem.out.println(quibble(new String[]{}));\n\t\tSystem.out.println(quibble(new String[]{\"ABC\"}));\n\t\tSystem.out.println(quibble(new String[]{\"ABC\", \"DEF\"}));\n\t\tSystem.out.println(quibble(new String[]{\"ABC\", \"DEF\", \"G\"}));\n\t\tSystem.out.println(quibble(new String[]{\"ABC\", \"DEF\", \"G\", \"H\"}));\n\t}\n}\n"}
{"id": 45922, "name": "Comma quibbling", "source": "Translate Fortran to Python:       SUBROUTINE QUIBBLE(TEXT,OXFORDIAN)\t\n       CHARACTER*(*) TEXT\t\n       LOGICAL OXFORDIAN\t\n       INTEGER IST(6),LST(6)\t\n       INTEGER N,L,I\t\t\n       INTEGER L1,L2\t\t\n       INTEGER MSG\t\t\n       COMMON /IODEV/MSG\t\nChop the text into words.\n        N = 0\t\t\n        L = LEN(TEXT)\t\n        L2 = 0\t\t\n   10   L1 = L2\t\t\n   11   L1 = L1 + 1\t\t\n        IF (L1.GT.L) GO TO 20\t\t\n        IF (TEXT(L1:L1).LE.\" \") GO TO 11\t\n        L2 = L1\t\t\t\n   12   L2 = L2 + 1\t\t\n        IF (L2.GT.L) GO TO 13\t\n        IF (TEXT(L2:L2).GT.\" \") GO TO 12\t\n   13   N = N + 1\t\t\t\n        IST(N) = L1\t\t\n        LST(N) = L2 - 1\t\t\n        IF (L2.LT.L) GO TO 10\t\nComma time...\n   20   WRITE (MSG,21) \"{\"\t\n   21   FORMAT (A,$)\t\t\n        DO I = 1,N\t\t\n          IF (I.GT.1) THEN\t\t\n            IF (I.LT.N) THEN\t\t\t\n              WRITE (MSG,21) \", \"\t\t\t\n            ELSE IF (OXFORDIAN) THEN\t\t\n              WRITE (MSG,21) \", and \"\t\t\t\n            ELSE\t\t\t\t\n              WRITE (MSG,21) \" and \"\t\t\t\n            END IF\t\t\t\t\n          END IF\t\t\t\n          WRITE (MSG,21) TEXT(IST(I):LST(I))\t\n        END DO\t\t\t\n        WRITE (MSG,\"('}')\")\t\n      END\t\t\n\n      PROGRAM ENCOMMA\t\n      CHARACTER*(666) TEXT\t\n      INTEGER KBD,MSG,INF\t\n      COMMON /IODEV/MSG,KBD\t\n      KBD = 5\t\n      MSG = 6\t\n      INF = 10\t\n      OPEN (INF,FILE=\"List.txt\",ACTION = \"READ\")\t\n\n   10 WRITE (MSG,11) \"To insert commas into lists...\"\t\n   11 FORMAT (A)\t\t\t\n   12 READ (INF,11,END = 20) TEXT\t\n      CALL QUIBBLE(TEXT,.FALSE.)\t\n      GO TO 12\t\t\t\t\n\n   20 REWIND (INF)\t\t\t\n      WRITE (MSG,11)\t\t\t\n      WRITE (MSG,11) \"Oxford style...\"\t\n   21 READ (INF,11,END = 30) TEXT\t\n      CALL QUIBBLE(TEXT,.TRUE.)\t\t\n      GO TO 21\t\t\t\t\n\nClosedown\n   30 END\t\n", "target": "fun quibble(s):\n    let result = s.join(' and ').replace(|| and ||, \", \", length(s) - 1)\n    return \"{ $result }\"\n\nlet s = [\n    []\n    [\"ABC\"]\n    [\"ABC\", \"DEF\"]\n    [\"ABC\", \"DEF\", \"G\", \"H\"]\n]\n\nfor i in s:\n    print(quibble i)\n"}
{"id": 45923, "name": "Comma quibbling", "source": "Translate Fortran to Python:       SUBROUTINE QUIBBLE(TEXT,OXFORDIAN)\t\n       CHARACTER*(*) TEXT\t\n       LOGICAL OXFORDIAN\t\n       INTEGER IST(6),LST(6)\t\n       INTEGER N,L,I\t\t\n       INTEGER L1,L2\t\t\n       INTEGER MSG\t\t\n       COMMON /IODEV/MSG\t\nChop the text into words.\n        N = 0\t\t\n        L = LEN(TEXT)\t\n        L2 = 0\t\t\n   10   L1 = L2\t\t\n   11   L1 = L1 + 1\t\t\n        IF (L1.GT.L) GO TO 20\t\t\n        IF (TEXT(L1:L1).LE.\" \") GO TO 11\t\n        L2 = L1\t\t\t\n   12   L2 = L2 + 1\t\t\n        IF (L2.GT.L) GO TO 13\t\n        IF (TEXT(L2:L2).GT.\" \") GO TO 12\t\n   13   N = N + 1\t\t\t\n        IST(N) = L1\t\t\n        LST(N) = L2 - 1\t\t\n        IF (L2.LT.L) GO TO 10\t\nComma time...\n   20   WRITE (MSG,21) \"{\"\t\n   21   FORMAT (A,$)\t\t\n        DO I = 1,N\t\t\n          IF (I.GT.1) THEN\t\t\n            IF (I.LT.N) THEN\t\t\t\n              WRITE (MSG,21) \", \"\t\t\t\n            ELSE IF (OXFORDIAN) THEN\t\t\n              WRITE (MSG,21) \", and \"\t\t\t\n            ELSE\t\t\t\t\n              WRITE (MSG,21) \" and \"\t\t\t\n            END IF\t\t\t\t\n          END IF\t\t\t\n          WRITE (MSG,21) TEXT(IST(I):LST(I))\t\n        END DO\t\t\t\n        WRITE (MSG,\"('}')\")\t\n      END\t\t\n\n      PROGRAM ENCOMMA\t\n      CHARACTER*(666) TEXT\t\n      INTEGER KBD,MSG,INF\t\n      COMMON /IODEV/MSG,KBD\t\n      KBD = 5\t\n      MSG = 6\t\n      INF = 10\t\n      OPEN (INF,FILE=\"List.txt\",ACTION = \"READ\")\t\n\n   10 WRITE (MSG,11) \"To insert commas into lists...\"\t\n   11 FORMAT (A)\t\t\t\n   12 READ (INF,11,END = 20) TEXT\t\n      CALL QUIBBLE(TEXT,.FALSE.)\t\n      GO TO 12\t\t\t\t\n\n   20 REWIND (INF)\t\t\t\n      WRITE (MSG,11)\t\t\t\n      WRITE (MSG,11) \"Oxford style...\"\t\n   21 READ (INF,11,END = 30) TEXT\t\n      CALL QUIBBLE(TEXT,.TRUE.)\t\t\n      GO TO 21\t\t\t\t\n\nClosedown\n   30 END\t\n", "target": "fun quibble(s):\n    let result = s.join(' and ').replace(|| and ||, \", \", length(s) - 1)\n    return \"{ $result }\"\n\nlet s = [\n    []\n    [\"ABC\"]\n    [\"ABC\", \"DEF\"]\n    [\"ABC\", \"DEF\", \"G\", \"H\"]\n]\n\nfor i in s:\n    print(quibble i)\n"}
{"id": 46995, "name": "Ackermann function", "source": "Translate Fortran to C#: PROGRAM EXAMPLE  \n  IMPLICIT NONE\n \n  INTEGER :: i, j\n \n  DO i = 0, 3\n    DO j = 0, 6\n       WRITE(*, \"(I10)\", ADVANCE=\"NO\") Ackermann(i, j)\n    END DO\n    WRITE(*,*)\n  END DO\n \nCONTAINS\n \n  RECURSIVE FUNCTION Ackermann(m, n) RESULT(ack)\n    INTEGER :: ack, m, n\n\n    IF (m == 0) THEN\n      ack = n + 1\n    ELSE IF (n == 0) THEN\n      ack = Ackermann(m - 1, 1)\n    ELSE\n      ack = Ackermann(m - 1, Ackermann(m, n - 1))\n    END IF\n  END FUNCTION Ackermann\n\nEND PROGRAM EXAMPLE\n", "target": "using System;\nclass Program\n{\n    public static long Ackermann(long m, long n)\n    {\n        if(m > 0)\n        {\n            if (n > 0)\n                return Ackermann(m - 1, Ackermann(m, n - 1));\n            else if (n == 0)\n                return Ackermann(m - 1, 1);\n        }\n        else if(m == 0)\n        {\n            if(n >= 0) \n                return n + 1;\n        }\n\n        throw new System.ArgumentOutOfRangeException();\n    }\n    \n    static void Main()\n    {\n        for (long m = 0; m <= 3; ++m)\n        {\n            for (long n = 0; n <= 4; ++n)\n            {\n                Console.WriteLine(\"Ackermann({0}, {1}) = {2}\", m, n, Ackermann(m, n));\n            }\n        }\n    }\n}\n"}
{"id": 46998, "name": "Ackermann function", "source": "Translate Fortran to Java: PROGRAM EXAMPLE  \n  IMPLICIT NONE\n \n  INTEGER :: i, j\n \n  DO i = 0, 3\n    DO j = 0, 6\n       WRITE(*, \"(I10)\", ADVANCE=\"NO\") Ackermann(i, j)\n    END DO\n    WRITE(*,*)\n  END DO\n \nCONTAINS\n \n  RECURSIVE FUNCTION Ackermann(m, n) RESULT(ack)\n    INTEGER :: ack, m, n\n\n    IF (m == 0) THEN\n      ack = n + 1\n    ELSE IF (n == 0) THEN\n      ack = Ackermann(m - 1, 1)\n    ELSE\n      ack = Ackermann(m - 1, Ackermann(m, n - 1))\n    END IF\n  END FUNCTION Ackermann\n\nEND PROGRAM EXAMPLE\n", "target": "import java.math.BigInteger;\n\npublic static BigInteger ack(BigInteger m, BigInteger n) {\n    return m.equals(BigInteger.ZERO)\n            ? n.add(BigInteger.ONE)\n            : ack(m.subtract(BigInteger.ONE),\n                        n.equals(BigInteger.ZERO) ? BigInteger.ONE : ack(m, n.subtract(BigInteger.ONE)));\n}\n"}
{"id": 46999, "name": "Ackermann function", "source": "Translate Fortran to Python: PROGRAM EXAMPLE  \n  IMPLICIT NONE\n \n  INTEGER :: i, j\n \n  DO i = 0, 3\n    DO j = 0, 6\n       WRITE(*, \"(I10)\", ADVANCE=\"NO\") Ackermann(i, j)\n    END DO\n    WRITE(*,*)\n  END DO\n \nCONTAINS\n \n  RECURSIVE FUNCTION Ackermann(m, n) RESULT(ack)\n    INTEGER :: ack, m, n\n\n    IF (m == 0) THEN\n      ack = n + 1\n    ELSE IF (n == 0) THEN\n      ack = Ackermann(m - 1, 1)\n    ELSE\n      ack = Ackermann(m - 1, Ackermann(m, n - 1))\n    END IF\n  END FUNCTION Ackermann\n\nEND PROGRAM EXAMPLE\n", "target": "from __future__ import print_function\n\ndef setup():\n    for m in range(4):\n        for n in range(7):\n            print(\"{} \".format(ackermann(m, n)), end = \"\")\n        print()\n    \n\ndef ackermann(m, n):\n    if m == 0:\n        return n + 1\n    elif m > 0 and n == 0:\n        return ackermann(m - 1, 1)\n    else:\n        return ackermann(m - 1, ackermann(m, n - 1))\n"}
{"id": 47275, "name": "Enumerations", "source": "Translate Fortran to C#: enum, bind(c)\n  enumerator :: one=1, two, three, four, five\n  enumerator :: six, seven, nine=9\nend enum\n", "target": "enum fruits { apple, banana, cherry }\n\nenum fruits { apple = 0, banana = 1, cherry = 2 }\n\nenum fruits : int { apple = 0, banana = 1, cherry = 2 }\n\n[FlagsAttribute]\nenum Colors { Red = 1, Green = 2, Blue = 4, Yellow = 8 }\n"}
{"id": 47278, "name": "Enumerations", "source": "Translate Fortran to Java: enum, bind(c)\n  enumerator :: one=1, two, three, four, five\n  enumerator :: six, seven, nine=9\nend enum\n", "target": "enum Fruits{\n   APPLE, BANANA, CHERRY\n}\n"}
{"id": 47279, "name": "Enumerations", "source": "Translate Fortran to Python: enum, bind(c)\n  enumerator :: one=1, two, three, four, five\n  enumerator :: six, seven, nine=9\nend enum\n", "target": ">>> from enum import Enum\n>>> Contact = Enum('Contact', 'FIRST_NAME, LAST_NAME, PHONE')\n>>> Contact.__members__\nmappingproxy(OrderedDict([('FIRST_NAME', <Contact.FIRST_NAME: 1>), ('LAST_NAME', <Contact.LAST_NAME: 2>), ('PHONE', <Contact.PHONE: 3>)]))\n>>> \n>>> \n>>> class Contact2(Enum):\n\tFIRST_NAME = 1\n\tLAST_NAME = 2\n\tPHONE = 3\n\n\t\n>>> Contact2.__members__\nmappingproxy(OrderedDict([('FIRST_NAME', <Contact2.FIRST_NAME: 1>), ('LAST_NAME', <Contact2.LAST_NAME: 2>), ('PHONE', <Contact2.PHONE: 3>)]))\n>>>\n"}
{"id": 47873, "name": "Hello world_Text", "source": "Translate Fortran to C#: print *,\"Hello world\n", "target": "Using System;\nnamespace HelloWorld {\n  class Program\n  {\n    static void Main()\n    {\n      Console.Writeln(\"Hello World!\");\n    }\n  }\n}\n"}
{"id": 47875, "name": "Hello world_Text", "source": "Translate Fortran to Java: print *,\"Hello world\n", "target": "module HelloWorld\n    {\n    void run()\n        {\n        @Inject Console console;\n        console.print(\"Hello World!\");\n        }\n    }\n"}
{"id": 48340, "name": "Unbias a random generator", "source": "Translate Fortran to C#: program Bias_Unbias\n  implicit none\n\n  integer, parameter :: samples = 1000000\n  integer :: i, j\n  integer :: c1, c2, rand\n \n  do i = 3, 6\n    c1 = 0\n    c2 = 0\n    do j = 1, samples\n      rand = bias(i)\n      if (rand == 1) c1 = c1 + 1\n      rand = unbias(i)\n      if (rand == 1) c2 = c2 + 1\n    end do\n    write(*, \"(i2,a,f8.3,a,f8.3,a)\") i, \":\", real(c1) * 100.0 / real(samples), &\n                                     \"%\", real(c2) * 100.0 / real(samples), \"%\"\n  end do\n \ncontains\n\nfunction bias(n)\n  integer :: bias\n  integer, intent(in) :: n\n  real :: r\n\n  call random_number(r)\n  if (r > 1 / real(n)) then\n    bias = 0\n  else\n    bias = 1\n  end if\nend function\n\nfunction unbias(n)\n  integer :: unbias\n  integer, intent(in) :: n\n  integer :: a, b\n\n  do\n    a = bias(n)\n    b = bias(n)\n    if (a /= b) exit\n  end do\n  unbias = a     \nend function\n\nend program\n", "target": "using System;\n\nnamespace Unbias\n{\n    internal class Program\n    {\n        private static void Main(string[] args)\n        {\n            \n            for (int n = 3; n <= 6; n++)\n            {\n                int biasedZero = 0, biasedOne = 0, unbiasedZero = 0, unbiasedOne = 0;\n                for (int i = 0; i < 100000; i++)\n                {\n                    if (randN(n))\n                        biasedOne++;\n                    else\n                        biasedZero++;\n                    if (Unbiased(n))\n                        unbiasedOne++;\n                    else\n                        unbiasedZero++;\n                }\n\n                Console.WriteLine(\"(N = {0}):\".PadRight(17) + \"# of 0\\t# of 1\\t% of 0\\t% of 1\", n);\n                Console.WriteLine(\"Biased:\".PadRight(15) + \"{0}\\t{1}\\t{2}\\t{3}\",\n                                  biasedZero, biasedOne,\n                                  biasedZero/1000, biasedOne/1000);\n                Console.WriteLine(\"Unbiased:\".PadRight(15) + \"{0}\\t{1}\\t{2}\\t{3}\",\n                                  unbiasedZero, unbiasedOne,\n                                  unbiasedZero/1000, unbiasedOne/1000);\n            }\n        }\n\n        private static bool Unbiased(int n)\n        {\n            bool flip1, flip2;\n\n            \n\n            do\n            {\n                flip1 = randN(n);\n                flip2 = randN(n);\n            } while (flip1 == flip2);\n\n            return flip1;\n        }\n\n        private static readonly Random random = new Random();\n\n        private static bool randN(int n)\n        {\n            \n            return random.Next(0, n) == 0;\n        }\n    }\n}\n"}
{"id": 48341, "name": "Unbias a random generator", "source": "Translate Fortran to C#: program Bias_Unbias\n  implicit none\n\n  integer, parameter :: samples = 1000000\n  integer :: i, j\n  integer :: c1, c2, rand\n \n  do i = 3, 6\n    c1 = 0\n    c2 = 0\n    do j = 1, samples\n      rand = bias(i)\n      if (rand == 1) c1 = c1 + 1\n      rand = unbias(i)\n      if (rand == 1) c2 = c2 + 1\n    end do\n    write(*, \"(i2,a,f8.3,a,f8.3,a)\") i, \":\", real(c1) * 100.0 / real(samples), &\n                                     \"%\", real(c2) * 100.0 / real(samples), \"%\"\n  end do\n \ncontains\n\nfunction bias(n)\n  integer :: bias\n  integer, intent(in) :: n\n  real :: r\n\n  call random_number(r)\n  if (r > 1 / real(n)) then\n    bias = 0\n  else\n    bias = 1\n  end if\nend function\n\nfunction unbias(n)\n  integer :: unbias\n  integer, intent(in) :: n\n  integer :: a, b\n\n  do\n    a = bias(n)\n    b = bias(n)\n    if (a /= b) exit\n  end do\n  unbias = a     \nend function\n\nend program\n", "target": "using System;\n\nnamespace Unbias\n{\n    internal class Program\n    {\n        private static void Main(string[] args)\n        {\n            \n            for (int n = 3; n <= 6; n++)\n            {\n                int biasedZero = 0, biasedOne = 0, unbiasedZero = 0, unbiasedOne = 0;\n                for (int i = 0; i < 100000; i++)\n                {\n                    if (randN(n))\n                        biasedOne++;\n                    else\n                        biasedZero++;\n                    if (Unbiased(n))\n                        unbiasedOne++;\n                    else\n                        unbiasedZero++;\n                }\n\n                Console.WriteLine(\"(N = {0}):\".PadRight(17) + \"# of 0\\t# of 1\\t% of 0\\t% of 1\", n);\n                Console.WriteLine(\"Biased:\".PadRight(15) + \"{0}\\t{1}\\t{2}\\t{3}\",\n                                  biasedZero, biasedOne,\n                                  biasedZero/1000, biasedOne/1000);\n                Console.WriteLine(\"Unbiased:\".PadRight(15) + \"{0}\\t{1}\\t{2}\\t{3}\",\n                                  unbiasedZero, unbiasedOne,\n                                  unbiasedZero/1000, unbiasedOne/1000);\n            }\n        }\n\n        private static bool Unbiased(int n)\n        {\n            bool flip1, flip2;\n\n            \n\n            do\n            {\n                flip1 = randN(n);\n                flip2 = randN(n);\n            } while (flip1 == flip2);\n\n            return flip1;\n        }\n\n        private static readonly Random random = new Random();\n\n        private static bool randN(int n)\n        {\n            \n            return random.Next(0, n) == 0;\n        }\n    }\n}\n"}
{"id": 48347, "name": "Unbias a random generator", "source": "Translate Fortran to Java: program Bias_Unbias\n  implicit none\n\n  integer, parameter :: samples = 1000000\n  integer :: i, j\n  integer :: c1, c2, rand\n \n  do i = 3, 6\n    c1 = 0\n    c2 = 0\n    do j = 1, samples\n      rand = bias(i)\n      if (rand == 1) c1 = c1 + 1\n      rand = unbias(i)\n      if (rand == 1) c2 = c2 + 1\n    end do\n    write(*, \"(i2,a,f8.3,a,f8.3,a)\") i, \":\", real(c1) * 100.0 / real(samples), &\n                                     \"%\", real(c2) * 100.0 / real(samples), \"%\"\n  end do\n \ncontains\n\nfunction bias(n)\n  integer :: bias\n  integer, intent(in) :: n\n  real :: r\n\n  call random_number(r)\n  if (r > 1 / real(n)) then\n    bias = 0\n  else\n    bias = 1\n  end if\nend function\n\nfunction unbias(n)\n  integer :: unbias\n  integer, intent(in) :: n\n  integer :: a, b\n\n  do\n    a = bias(n)\n    b = bias(n)\n    if (a /= b) exit\n  end do\n  unbias = a     \nend function\n\nend program\n", "target": "public class Bias {\n    public static boolean biased(int n) {\n        return Math.random() < 1.0 / n;\n    }\n\n    public static boolean unbiased(int n) {\n        boolean a, b;\n        do {\n            a = biased(n);\n            b = biased(n);\n        } while (a == b);\n        return a;\n    }\n\n    public static void main(String[] args) {\n        final int M = 50000;\n        for (int n = 3; n < 7; n++) {\n            int c1 = 0, c2 = 0;\n            for (int i = 0; i < M; i++) {\n                c1 += biased(n) ? 1 : 0;\n                c2 += unbiased(n) ? 1 : 0;\n            }\n            System.out.format(\"%d: %2.2f%%  %2.2f%%\\n\",\n                              n, 100.0*c1/M, 100.0*c2/M);\n        }\n    }\n}\n"}
{"id": 48348, "name": "Unbias a random generator", "source": "Translate Fortran to Java: program Bias_Unbias\n  implicit none\n\n  integer, parameter :: samples = 1000000\n  integer :: i, j\n  integer :: c1, c2, rand\n \n  do i = 3, 6\n    c1 = 0\n    c2 = 0\n    do j = 1, samples\n      rand = bias(i)\n      if (rand == 1) c1 = c1 + 1\n      rand = unbias(i)\n      if (rand == 1) c2 = c2 + 1\n    end do\n    write(*, \"(i2,a,f8.3,a,f8.3,a)\") i, \":\", real(c1) * 100.0 / real(samples), &\n                                     \"%\", real(c2) * 100.0 / real(samples), \"%\"\n  end do\n \ncontains\n\nfunction bias(n)\n  integer :: bias\n  integer, intent(in) :: n\n  real :: r\n\n  call random_number(r)\n  if (r > 1 / real(n)) then\n    bias = 0\n  else\n    bias = 1\n  end if\nend function\n\nfunction unbias(n)\n  integer :: unbias\n  integer, intent(in) :: n\n  integer :: a, b\n\n  do\n    a = bias(n)\n    b = bias(n)\n    if (a /= b) exit\n  end do\n  unbias = a     \nend function\n\nend program\n", "target": "public class Bias {\n    public static boolean biased(int n) {\n        return Math.random() < 1.0 / n;\n    }\n\n    public static boolean unbiased(int n) {\n        boolean a, b;\n        do {\n            a = biased(n);\n            b = biased(n);\n        } while (a == b);\n        return a;\n    }\n\n    public static void main(String[] args) {\n        final int M = 50000;\n        for (int n = 3; n < 7; n++) {\n            int c1 = 0, c2 = 0;\n            for (int i = 0; i < M; i++) {\n                c1 += biased(n) ? 1 : 0;\n                c2 += unbiased(n) ? 1 : 0;\n            }\n            System.out.format(\"%d: %2.2f%%  %2.2f%%\\n\",\n                              n, 100.0*c1/M, 100.0*c2/M);\n        }\n    }\n}\n"}
{"id": 48349, "name": "Unbias a random generator", "source": "Translate Fortran to Python: program Bias_Unbias\n  implicit none\n\n  integer, parameter :: samples = 1000000\n  integer :: i, j\n  integer :: c1, c2, rand\n \n  do i = 3, 6\n    c1 = 0\n    c2 = 0\n    do j = 1, samples\n      rand = bias(i)\n      if (rand == 1) c1 = c1 + 1\n      rand = unbias(i)\n      if (rand == 1) c2 = c2 + 1\n    end do\n    write(*, \"(i2,a,f8.3,a,f8.3,a)\") i, \":\", real(c1) * 100.0 / real(samples), &\n                                     \"%\", real(c2) * 100.0 / real(samples), \"%\"\n  end do\n \ncontains\n\nfunction bias(n)\n  integer :: bias\n  integer, intent(in) :: n\n  real :: r\n\n  call random_number(r)\n  if (r > 1 / real(n)) then\n    bias = 0\n  else\n    bias = 1\n  end if\nend function\n\nfunction unbias(n)\n  integer :: unbias\n  integer, intent(in) :: n\n  integer :: a, b\n\n  do\n    a = bias(n)\n    b = bias(n)\n    if (a /= b) exit\n  end do\n  unbias = a     \nend function\n\nend program\n", "target": "from __future__ import print_function\nimport random\n\ndef randN(N):\n    \" 1,0 random generator factory with 1 appearing 1/N'th of the time\"\n    return lambda: random.randrange(N) == 0\n\ndef unbiased(biased):\n    'uses a biased() generator of 1 or 0, to create an unbiased one'\n    this, that = biased(), biased()\n    while this == that: \n        this, that = biased(), biased()\n    return this         \n\nif __name__ == '__main__':\n    from collections import namedtuple\n\n    Stats = namedtuple('Stats', 'count1 count0 percent')\n\n    for N in range(3, 7):\n        biased = randN(N)\n        v = [biased() for x in range(1000000)]\n        v1, v0 = v.count(1), v.count(0)\n        print ( \"Biased(%i)  = %r\" % (N, Stats(v1, v0, 100. * v1/(v1 + v0))) )\n\n        v = [unbiased(biased) for x in range(1000000)]\n        v1, v0 = v.count(1), v.count(0)\n        print ( \"  Unbiased = %r\" % (Stats(v1, v0, 100. * v1/(v1 + v0)), ) )\n"}
{"id": 48350, "name": "Unbias a random generator", "source": "Translate Fortran to Python: program Bias_Unbias\n  implicit none\n\n  integer, parameter :: samples = 1000000\n  integer :: i, j\n  integer :: c1, c2, rand\n \n  do i = 3, 6\n    c1 = 0\n    c2 = 0\n    do j = 1, samples\n      rand = bias(i)\n      if (rand == 1) c1 = c1 + 1\n      rand = unbias(i)\n      if (rand == 1) c2 = c2 + 1\n    end do\n    write(*, \"(i2,a,f8.3,a,f8.3,a)\") i, \":\", real(c1) * 100.0 / real(samples), &\n                                     \"%\", real(c2) * 100.0 / real(samples), \"%\"\n  end do\n \ncontains\n\nfunction bias(n)\n  integer :: bias\n  integer, intent(in) :: n\n  real :: r\n\n  call random_number(r)\n  if (r > 1 / real(n)) then\n    bias = 0\n  else\n    bias = 1\n  end if\nend function\n\nfunction unbias(n)\n  integer :: unbias\n  integer, intent(in) :: n\n  integer :: a, b\n\n  do\n    a = bias(n)\n    b = bias(n)\n    if (a /= b) exit\n  end do\n  unbias = a     \nend function\n\nend program\n", "target": "from __future__ import print_function\nimport random\n\ndef randN(N):\n    \" 1,0 random generator factory with 1 appearing 1/N'th of the time\"\n    return lambda: random.randrange(N) == 0\n\ndef unbiased(biased):\n    'uses a biased() generator of 1 or 0, to create an unbiased one'\n    this, that = biased(), biased()\n    while this == that: \n        this, that = biased(), biased()\n    return this         \n\nif __name__ == '__main__':\n    from collections import namedtuple\n\n    Stats = namedtuple('Stats', 'count1 count0 percent')\n\n    for N in range(3, 7):\n        biased = randN(N)\n        v = [biased() for x in range(1000000)]\n        v1, v0 = v.count(1), v.count(0)\n        print ( \"Biased(%i)  = %r\" % (N, Stats(v1, v0, 100. * v1/(v1 + v0))) )\n\n        v = [unbiased(biased) for x in range(1000000)]\n        v1, v0 = v.count(1), v.count(0)\n        print ( \"  Unbiased = %r\" % (Stats(v1, v0, 100. * v1/(v1 + v0)), ) )\n"}
{"id": 48842, "name": "Digital root", "source": "Translate Fortran to C#: program prec\nimplicit none\ninteger(kind=16) :: i\ni = 627615\ncall root_pers(i)\ni = 39390\ncall root_pers(i)\ni = 588225\ncall root_pers(i)\ni = 393900588225\ncall root_pers(i)\nend program\n\nsubroutine root_pers(i)\nimplicit none\ninteger(kind=16) :: N, s, a, i\nwrite(*,*) 'Number: ', i\nn = i\na = 0\ndo while(n.ge.10)\n  a = a + 1\n  s = 0\n  do while(n.gt.0)\n    s = s + n-int(real(n,kind=8)/10.0D0,kind=8) * 10_8\n    n = int(real(n,kind=16)/real(10,kind=8),kind=8)\n  end do\n  n = s\nend do\nwrite(*,*) 'digital root = ', s\nwrite(*,*) 'additive persistance = ', a\nend subroutine\n", "target": "using System;\nusing System.Linq;\n\nclass Program\n{\n    static Tuple<int, int> DigitalRoot(long num)\n    {\n        int additivepersistence = 0;\n        while (num > 9)\n        {\n            num = num.ToString().ToCharArray().Sum(x => x - '0');\n            additivepersistence++;\n        }\n        return new Tuple<int, int>(additivepersistence, (int)num);\n    }\n    static void Main(string[] args)\n    {\n        foreach (long num in new long[] { 627615, 39390, 588225, 393900588225 })\n        {\n            var t = DigitalRoot(num);\n            Console.WriteLine(\"{0} has additive persistence {1} and digital root {2}\", num, t.Item1, t.Item2);\n        }\n    }\n}\n"}
{"id": 48843, "name": "Digital root", "source": "Translate Fortran to C#: program prec\nimplicit none\ninteger(kind=16) :: i\ni = 627615\ncall root_pers(i)\ni = 39390\ncall root_pers(i)\ni = 588225\ncall root_pers(i)\ni = 393900588225\ncall root_pers(i)\nend program\n\nsubroutine root_pers(i)\nimplicit none\ninteger(kind=16) :: N, s, a, i\nwrite(*,*) 'Number: ', i\nn = i\na = 0\ndo while(n.ge.10)\n  a = a + 1\n  s = 0\n  do while(n.gt.0)\n    s = s + n-int(real(n,kind=8)/10.0D0,kind=8) * 10_8\n    n = int(real(n,kind=16)/real(10,kind=8),kind=8)\n  end do\n  n = s\nend do\nwrite(*,*) 'digital root = ', s\nwrite(*,*) 'additive persistance = ', a\nend subroutine\n", "target": "using System;\nusing System.Linq;\n\nclass Program\n{\n    static Tuple<int, int> DigitalRoot(long num)\n    {\n        int additivepersistence = 0;\n        while (num > 9)\n        {\n            num = num.ToString().ToCharArray().Sum(x => x - '0');\n            additivepersistence++;\n        }\n        return new Tuple<int, int>(additivepersistence, (int)num);\n    }\n    static void Main(string[] args)\n    {\n        foreach (long num in new long[] { 627615, 39390, 588225, 393900588225 })\n        {\n            var t = DigitalRoot(num);\n            Console.WriteLine(\"{0} has additive persistence {1} and digital root {2}\", num, t.Item1, t.Item2);\n        }\n    }\n}\n"}
{"id": 48849, "name": "Digital root", "source": "Translate Fortran to Java: program prec\nimplicit none\ninteger(kind=16) :: i\ni = 627615\ncall root_pers(i)\ni = 39390\ncall root_pers(i)\ni = 588225\ncall root_pers(i)\ni = 393900588225\ncall root_pers(i)\nend program\n\nsubroutine root_pers(i)\nimplicit none\ninteger(kind=16) :: N, s, a, i\nwrite(*,*) 'Number: ', i\nn = i\na = 0\ndo while(n.ge.10)\n  a = a + 1\n  s = 0\n  do while(n.gt.0)\n    s = s + n-int(real(n,kind=8)/10.0D0,kind=8) * 10_8\n    n = int(real(n,kind=16)/real(10,kind=8),kind=8)\n  end do\n  n = s\nend do\nwrite(*,*) 'digital root = ', s\nwrite(*,*) 'additive persistance = ', a\nend subroutine\n", "target": "import java.math.BigInteger;\n\nclass DigitalRoot\n{\n  public static int[] calcDigitalRoot(String number, int base)\n  {\n    BigInteger bi = new BigInteger(number, base);\n    int additivePersistence = 0;\n    if (bi.signum() < 0)\n      bi = bi.negate();\n    BigInteger biBase = BigInteger.valueOf(base);\n    while (bi.compareTo(biBase) >= 0)\n    {\n      number = bi.toString(base);\n      bi = BigInteger.ZERO;\n      for (int i = 0; i < number.length(); i++)\n        bi = bi.add(new BigInteger(number.substring(i, i + 1), base));\n      additivePersistence++;\n    }\n    return new int[] { additivePersistence, bi.intValue() };\n  }\n\n  public static void main(String[] args)\n  {\n    for (String arg : args)\n    {\n      int[] results = calcDigitalRoot(arg, 10);\n      System.out.println(arg + \" has additive persistence \" + results[0] + \" and digital root of \" + results[1]);\n    }\n  }\n}\n"}
{"id": 48850, "name": "Digital root", "source": "Translate Fortran to Java: program prec\nimplicit none\ninteger(kind=16) :: i\ni = 627615\ncall root_pers(i)\ni = 39390\ncall root_pers(i)\ni = 588225\ncall root_pers(i)\ni = 393900588225\ncall root_pers(i)\nend program\n\nsubroutine root_pers(i)\nimplicit none\ninteger(kind=16) :: N, s, a, i\nwrite(*,*) 'Number: ', i\nn = i\na = 0\ndo while(n.ge.10)\n  a = a + 1\n  s = 0\n  do while(n.gt.0)\n    s = s + n-int(real(n,kind=8)/10.0D0,kind=8) * 10_8\n    n = int(real(n,kind=16)/real(10,kind=8),kind=8)\n  end do\n  n = s\nend do\nwrite(*,*) 'digital root = ', s\nwrite(*,*) 'additive persistance = ', a\nend subroutine\n", "target": "import java.math.BigInteger;\n\nclass DigitalRoot\n{\n  public static int[] calcDigitalRoot(String number, int base)\n  {\n    BigInteger bi = new BigInteger(number, base);\n    int additivePersistence = 0;\n    if (bi.signum() < 0)\n      bi = bi.negate();\n    BigInteger biBase = BigInteger.valueOf(base);\n    while (bi.compareTo(biBase) >= 0)\n    {\n      number = bi.toString(base);\n      bi = BigInteger.ZERO;\n      for (int i = 0; i < number.length(); i++)\n        bi = bi.add(new BigInteger(number.substring(i, i + 1), base));\n      additivePersistence++;\n    }\n    return new int[] { additivePersistence, bi.intValue() };\n  }\n\n  public static void main(String[] args)\n  {\n    for (String arg : args)\n    {\n      int[] results = calcDigitalRoot(arg, 10);\n      System.out.println(arg + \" has additive persistence \" + results[0] + \" and digital root of \" + results[1]);\n    }\n  }\n}\n"}
{"id": 48851, "name": "Digital root", "source": "Translate Fortran to Python: program prec\nimplicit none\ninteger(kind=16) :: i\ni = 627615\ncall root_pers(i)\ni = 39390\ncall root_pers(i)\ni = 588225\ncall root_pers(i)\ni = 393900588225\ncall root_pers(i)\nend program\n\nsubroutine root_pers(i)\nimplicit none\ninteger(kind=16) :: N, s, a, i\nwrite(*,*) 'Number: ', i\nn = i\na = 0\ndo while(n.ge.10)\n  a = a + 1\n  s = 0\n  do while(n.gt.0)\n    s = s + n-int(real(n,kind=8)/10.0D0,kind=8) * 10_8\n    n = int(real(n,kind=16)/real(10,kind=8),kind=8)\n  end do\n  n = s\nend do\nwrite(*,*) 'digital root = ', s\nwrite(*,*) 'additive persistance = ', a\nend subroutine\n", "target": "def digital_root (n):\n    ap = 0\n    n = abs(int(n))\n    while n >= 10:\n        n = sum(int(digit) for digit in str(n))\n        ap += 1\n    return ap, n\n\nif __name__ == '__main__':\n    for n in [627615, 39390, 588225, 393900588225, 55]:\n        persistance, root = digital_root(n)\n        print(\"%12i has additive persistance %2i and digital root %i.\" \n              % (n, persistance, root))\n"}
{"id": 48852, "name": "Digital root", "source": "Translate Fortran to Python: program prec\nimplicit none\ninteger(kind=16) :: i\ni = 627615\ncall root_pers(i)\ni = 39390\ncall root_pers(i)\ni = 588225\ncall root_pers(i)\ni = 393900588225\ncall root_pers(i)\nend program\n\nsubroutine root_pers(i)\nimplicit none\ninteger(kind=16) :: N, s, a, i\nwrite(*,*) 'Number: ', i\nn = i\na = 0\ndo while(n.ge.10)\n  a = a + 1\n  s = 0\n  do while(n.gt.0)\n    s = s + n-int(real(n,kind=8)/10.0D0,kind=8) * 10_8\n    n = int(real(n,kind=16)/real(10,kind=8),kind=8)\n  end do\n  n = s\nend do\nwrite(*,*) 'digital root = ', s\nwrite(*,*) 'additive persistance = ', a\nend subroutine\n", "target": "def digital_root (n):\n    ap = 0\n    n = abs(int(n))\n    while n >= 10:\n        n = sum(int(digit) for digit in str(n))\n        ap += 1\n    return ap, n\n\nif __name__ == '__main__':\n    for n in [627615, 39390, 588225, 393900588225, 55]:\n        persistance, root = digital_root(n)\n        print(\"%12i has additive persistance %2i and digital root %i.\" \n              % (n, persistance, root))\n"}
{"id": 49286, "name": "Loops_Continue", "source": "Translate Fortran to C#: do i = 1, 10\n   write(*, '(I0)', advance='no') i\n   if ( mod(i, 5) == 0 ) then\n      write(*,*)\n      cycle\n   end if\n   write(*, '(A)', advance='no') ', '\nend do\n", "target": "using System;\n\nclass Program {\n    static void Main(string[] args) {\n        for (int i = 1; i <= 10; i++) {\n            Console.Write(i);\n\n            if (i % 5 == 0) {\n                Console.WriteLine();\n                continue;\n            }\n\n            Console.Write(\", \");\n        }\n    }\n}\n"}
{"id": 49289, "name": "Loops_Continue", "source": "Translate Fortran to Java: do i = 1, 10\n   write(*, '(I0)', advance='no') i\n   if ( mod(i, 5) == 0 ) then\n      write(*,*)\n      cycle\n   end if\n   write(*, '(A)', advance='no') ', '\nend do\n", "target": "for(int i = 1;i <= 10; i++){\n   System.out.print(i);\n   if(i % 5 == 0){\n      System.out.println();\n      continue;\n   }\n   System.out.print(\", \");\n}\n"}
{"id": 49290, "name": "Loops_Continue", "source": "Translate Fortran to Python: do i = 1, 10\n   write(*, '(I0)', advance='no') i\n   if ( mod(i, 5) == 0 ) then\n      write(*,*)\n      cycle\n   end if\n   write(*, '(A)', advance='no') ', '\nend do\n", "target": "for i in range(1, 11):\n    if i % 5 == 0:\n        print(i)\n        continue\n    print(i, end=', ')\n"}
{"id": 49571, "name": "Filter", "source": "Translate Fortran to C#: module funcs\n  implicit none\ncontains\n  pure function iseven(x)\n    logical :: iseven\n    integer, intent(in) :: x\n    iseven = mod(x, 2) == 0\n  end function iseven\nend module funcs\n", "target": "ArrayList array = new ArrayList( new int[] { 1, 2, 3, 4, 5 } );\nArrayList evens = new ArrayList();\nforeach( int i in array )\n{\n        if( (i%2) == 0 )\n                evens.Add( i );\n}\nforeach( int i in evens )\n       System.Console.WriteLine( i.ToString() );\n"}
{"id": 49574, "name": "Filter", "source": "Translate Fortran to Java: module funcs\n  implicit none\ncontains\n  pure function iseven(x)\n    logical :: iseven\n    integer, intent(in) :: x\n    iseven = mod(x, 2) == 0\n  end function iseven\nend module funcs\n", "target": "int[] array = {1, 2, 3, 4, 5 };\nList<Integer> evensList = new ArrayList<Integer>();\nfor (int  i: array) {\n    if (i % 2 == 0) evensList.add(i);\n}\nint[] evens = evensList.toArray(new int[0]);\n"}
{"id": 49575, "name": "Filter", "source": "Translate Fortran to Python: module funcs\n  implicit none\ncontains\n  pure function iseven(x)\n    logical :: iseven\n    integer, intent(in) :: x\n    iseven = mod(x, 2) == 0\n  end function iseven\nend module funcs\n", "target": "values = range(10)\nevens = [x for x in values if not x & 1]\nievens = (x for x in values if not x & 1) \n\nevens = filter(lambda x: not x & 1, values)\n"}
{"id": 49816, "name": "Ludic numbers", "source": "Translate Fortran to C#: program ludic_numbers\n  implicit none\n  \n  integer, parameter :: nmax = 25000\n  logical :: ludic(nmax) = .true.\n  integer :: i, j, n\n\n  do i = 2, nmax / 2\n    if (ludic(i)) then\n      n = 0\n      do j = i+1, nmax\n        if(ludic(j)) n = n + 1\n        if(n == i) then\n          ludic(j) = .false.\n          n = 0\n        end if\n      end do\n    end if\n  end do\n\n  write(*, \"(a)\", advance = \"no\") \"First 25 Ludic numbers: \"\n  n = 0\n  do i = 1, nmax\n    if(ludic(i)) then\n      write(*, \"(i0, 1x)\", advance = \"no\") i\n      n = n + 1\n    end if\n    if(n == 25) exit\n  end do  \n   \n  write(*, \"(/, a)\", advance = \"no\") \"Ludic numbers below 1000: \"\n  write(*, \"(i0)\") count(ludic(:999))\n \n  write(*, \"(a)\", advance = \"no\") \"Ludic numbers 2000 to 2005: \" \n  n = 0\n  do i = 1, nmax\n    if(ludic(i)) then\n       n = n + 1\n       if(n >= 2000) then\n         write(*, \"(i0, 1x)\", advance = \"no\") i\n         if(n == 2005) exit\n       end if\n     end if\n  end do  \n\n  write(*, \"(/, a)\", advance = \"no\") \"Ludic Triplets below 250: \"\n  do i = 1, 243\n    if(ludic(i) .and. ludic(i+2) .and. ludic(i+6)) then\n       write(*, \"(a, 2(i0, 1x), i0, a, 1x)\", advance = \"no\") \"[\", i, i+2, i+6, \"]\"\n    end if  \n  end do\n\nend program\n", "target": "using System;\nusing System.Linq;\nusing System.Collections.Generic;\n\npublic class Program\n{\n    public static void Main()\n    {\n        Console.WriteLine(\"First 25 ludic numbers:\");\n        Console.WriteLine(string.Join(\", \", LudicNumbers(150).Take(25)));\n        Console.WriteLine();\n        \n        Console.WriteLine($\"There are {LudicNumbers(1001).Count()} ludic numbers below 1000\");\n        Console.WriteLine();\n        \n        foreach (var ludic in LudicNumbers(22000).Skip(1999).Take(6)\n                .Select((n, i) => $\"#{i+2000} = {n}\")) {\n            Console.WriteLine(ludic);\n        }\n        Console.WriteLine();\n        \n        Console.WriteLine(\"Triplets below 250:\");\n        var queue = new Queue<int>(5);\n        foreach (int x in LudicNumbers(255)) {\n            if (queue.Count == 5) queue.Dequeue();\n            queue.Enqueue(x);\n            if (x - 6 < 250 && queue.Contains(x - 6) && queue.Contains(x - 4)) {\n                Console.WriteLine($\"{x-6}, {x-4}, {x}\");\n            }\n        }\n    }\n    \n    public static IEnumerable<int> LudicNumbers(int limit) {\n        yield return 1;\n        \n        \n        \n        Entry[] values = Enumerable.Range(0, limit + 1).Select(n => new Entry(n)).ToArray();\n        for (int i = 2; i < limit; i = values[i].Next) {\n            yield return values[i].N;\n            int start = i;\n            while (start < limit) {\n                Unlink(values, start);\n                for (int step = 0; step < i && start < limit; step++)\n                    start = values[start].Next;\n            }\n        }\n    }\n    \n    static void Unlink(Entry[] values, int index) {\n        values[values[index].Prev].Next = values[index].Next;\n        values[values[index].Next].Prev = values[index].Prev;\n    }\n    \n}\n\nstruct Entry\n{\n    public Entry(int n) : this() {\n        N = n;\n        Prev = n - 1;\n        Next = n + 1;\n    }\n    \n    public int N { get; }\n    public int Prev { get; set; }\n    public int Next { get; set; }\n}\n"}
{"id": 49819, "name": "Ludic numbers", "source": "Translate Fortran to Java: program ludic_numbers\n  implicit none\n  \n  integer, parameter :: nmax = 25000\n  logical :: ludic(nmax) = .true.\n  integer :: i, j, n\n\n  do i = 2, nmax / 2\n    if (ludic(i)) then\n      n = 0\n      do j = i+1, nmax\n        if(ludic(j)) n = n + 1\n        if(n == i) then\n          ludic(j) = .false.\n          n = 0\n        end if\n      end do\n    end if\n  end do\n\n  write(*, \"(a)\", advance = \"no\") \"First 25 Ludic numbers: \"\n  n = 0\n  do i = 1, nmax\n    if(ludic(i)) then\n      write(*, \"(i0, 1x)\", advance = \"no\") i\n      n = n + 1\n    end if\n    if(n == 25) exit\n  end do  \n   \n  write(*, \"(/, a)\", advance = \"no\") \"Ludic numbers below 1000: \"\n  write(*, \"(i0)\") count(ludic(:999))\n \n  write(*, \"(a)\", advance = \"no\") \"Ludic numbers 2000 to 2005: \" \n  n = 0\n  do i = 1, nmax\n    if(ludic(i)) then\n       n = n + 1\n       if(n >= 2000) then\n         write(*, \"(i0, 1x)\", advance = \"no\") i\n         if(n == 2005) exit\n       end if\n     end if\n  end do  \n\n  write(*, \"(/, a)\", advance = \"no\") \"Ludic Triplets below 250: \"\n  do i = 1, 243\n    if(ludic(i) .and. ludic(i+2) .and. ludic(i+6)) then\n       write(*, \"(a, 2(i0, 1x), i0, a, 1x)\", advance = \"no\") \"[\", i, i+2, i+6, \"]\"\n    end if  \n  end do\n\nend program\n", "target": "import java.util.ArrayList;\nimport java.util.List;\n\npublic class Ludic{\n\tpublic static List<Integer> ludicUpTo(int n){\n\t\tList<Integer> ludics = new ArrayList<Integer>(n);\n\t\tfor(int i = 1; i <= n; i++){   \n\t\t\tludics.add(i);\n\t\t}\n\t\t\n\t\t\n\t\tfor(int cursor = 1; cursor < ludics.size(); cursor++){\n\t\t\tint thisLudic = ludics.get(cursor); \n\t\t\tint removeCursor = cursor + thisLudic; \n\t\t\twhile(removeCursor < ludics.size()){\n\t\t\t\tludics.remove(removeCursor);\t\t     \n\t\t\t\tremoveCursor = removeCursor + thisLudic - 1; \n\t\t\t\t\t\t\t\t\t     \n\t\t\t}\n\t\t}\n\t\treturn ludics;\n\t}\n\t\n\tpublic static List<List<Integer>> getTriplets(List<Integer> ludics){\n\t\tList<List<Integer>> triplets = new ArrayList<List<Integer>>();\n\t\tfor(int i = 0; i < ludics.size() - 2; i++){ \n\t\t\tint thisLudic = ludics.get(i);\n\t\t\tif(ludics.contains(thisLudic + 2) && ludics.contains(thisLudic + 6)){\n\t\t\t\tList<Integer> triplet = new ArrayList<Integer>(3);\n\t\t\t\ttriplet.add(thisLudic);\n\t\t\t\ttriplet.add(thisLudic + 2);\n\t\t\t\ttriplet.add(thisLudic + 6);\n\t\t\t\ttriplets.add(triplet);\n\t\t\t}\n\t\t}\n\t\treturn triplets;\n\t}\n\t\n\tpublic static void main(String[] srgs){\n\t\tSystem.out.println(\"First 25 Ludics: \" + ludicUpTo(110));\t\t\t\t\n\t\tSystem.out.println(\"Ludics up to 1000: \" + ludicUpTo(1000).size());\n\t\tSystem.out.println(\"2000th - 2005th Ludics: \" + ludicUpTo(22000).subList(1999, 2005));  \n\t\tSystem.out.println(\"Triplets up to 250: \" + getTriplets(ludicUpTo(250)));\n\t}\n}\n"}
{"id": 49820, "name": "Ludic numbers", "source": "Translate Fortran to Python: program ludic_numbers\n  implicit none\n  \n  integer, parameter :: nmax = 25000\n  logical :: ludic(nmax) = .true.\n  integer :: i, j, n\n\n  do i = 2, nmax / 2\n    if (ludic(i)) then\n      n = 0\n      do j = i+1, nmax\n        if(ludic(j)) n = n + 1\n        if(n == i) then\n          ludic(j) = .false.\n          n = 0\n        end if\n      end do\n    end if\n  end do\n\n  write(*, \"(a)\", advance = \"no\") \"First 25 Ludic numbers: \"\n  n = 0\n  do i = 1, nmax\n    if(ludic(i)) then\n      write(*, \"(i0, 1x)\", advance = \"no\") i\n      n = n + 1\n    end if\n    if(n == 25) exit\n  end do  \n   \n  write(*, \"(/, a)\", advance = \"no\") \"Ludic numbers below 1000: \"\n  write(*, \"(i0)\") count(ludic(:999))\n \n  write(*, \"(a)\", advance = \"no\") \"Ludic numbers 2000 to 2005: \" \n  n = 0\n  do i = 1, nmax\n    if(ludic(i)) then\n       n = n + 1\n       if(n >= 2000) then\n         write(*, \"(i0, 1x)\", advance = \"no\") i\n         if(n == 2005) exit\n       end if\n     end if\n  end do  \n\n  write(*, \"(/, a)\", advance = \"no\") \"Ludic Triplets below 250: \"\n  do i = 1, 243\n    if(ludic(i) .and. ludic(i+2) .and. ludic(i+6)) then\n       write(*, \"(a, 2(i0, 1x), i0, a, 1x)\", advance = \"no\") \"[\", i, i+2, i+6, \"]\"\n    end if  \n  end do\n\nend program\n", "target": "def ludic(nmax=100000):\n    yield 1\n    lst = list(range(2, nmax + 1))\n    while lst:\n        yield lst[0]\n        del lst[::lst[0]]\n\nludics = [l for l in ludic()]\n\nprint('First 25 ludic primes:')\nprint(ludics[:25])\nprint(\"\\nThere are %i ludic numbers <= 1000\"\n      % sum(1 for l in ludics if l <= 1000)) \nprint(\"\\n2000'th..2005'th ludic primes:\")\nprint(ludics[2000-1: 2005])\n\nn = 250\ntriplets = [(x, x+2, x+6)\n            for x in ludics\n            if x+6 < n and x+2 in ludics and x+6 in ludics]\nprint('\\nThere are %i triplets less than %i:\\n  %r'\n      % (len(triplets), n, triplets))\n"}
{"id": 50030, "name": "Sieve of Eratosthenes", "source": "Translate Fortran to C#:       PROGRAM MAIN\n      INTEGER LI\n      WRITE (6,100)\n      READ  (5,110) LI\n      call SOE(LI)\n 100  FORMAT( 'Limit:' )\n 110  FORMAT( I4 )\n      STOP\n      END\n      \nC --- SIEVE OF ERATOSTHENES ----------\n      SUBROUTINE SOE( LI )\n      INTEGER LI\n      LOGICAL A(LI)\n      INTEGER SL,P,I\n      \n      DO 10 I=1,LI\n         A(I) = .TRUE.\n 10   CONTINUE\n      \n      SL = INT(SQRT(REAL(LI)))\n      A(1) = .FALSE.\n      DO 30 P=2,SL\n         IF ( .NOT. A(P) ) GOTO 30\n         DO 20 I=P*P,LI,P\n            A(I)=.FALSE.\n 20      CONTINUE\n 30   CONTINUE\n\n      DO 40 I=2,LI\n         IF ( A(I) ) WRITE(6,100) I\n 40   CONTINUE\n\n 100  FORMAT(I3)\n      RETURN\n      END\n", "target": "using System;\nusing System.Collections;\nusing System.Collections.Generic;\n\nnamespace SieveOfEratosthenes\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            int maxprime = int.Parse(args[0]);\n            var primelist = GetAllPrimesLessThan(maxprime);\n            foreach (int prime in primelist)\n            {\n                Console.WriteLine(prime);\n            }\n            Console.WriteLine(\"Count = \" + primelist.Count);\n            Console.ReadLine();\n        }\n\n        private static List<int> GetAllPrimesLessThan(int maxPrime)\n        {\n            var primes = new List<int>();\n            var maxSquareRoot = (int)Math.Sqrt(maxPrime);\n            var eliminated = new BitArray(maxPrime + 1);\n\n            for (int i = 2; i <= maxPrime; ++i)\n            {\n                if (!eliminated[i])\n                {\n                    primes.Add(i);\n                    if (i <= maxSquareRoot)\n                    {\n                        for (int j = i * i; j <= maxPrime; j += i)\n                        {\n                            eliminated[j] = true;\n                        }\n                    }\n                }\n            }\n            return primes;\n        }\n    }\n}\n"}
{"id": 50033, "name": "Sieve of Eratosthenes", "source": "Translate Fortran to Java:       PROGRAM MAIN\n      INTEGER LI\n      WRITE (6,100)\n      READ  (5,110) LI\n      call SOE(LI)\n 100  FORMAT( 'Limit:' )\n 110  FORMAT( I4 )\n      STOP\n      END\n      \nC --- SIEVE OF ERATOSTHENES ----------\n      SUBROUTINE SOE( LI )\n      INTEGER LI\n      LOGICAL A(LI)\n      INTEGER SL,P,I\n      \n      DO 10 I=1,LI\n         A(I) = .TRUE.\n 10   CONTINUE\n      \n      SL = INT(SQRT(REAL(LI)))\n      A(1) = .FALSE.\n      DO 30 P=2,SL\n         IF ( .NOT. A(P) ) GOTO 30\n         DO 20 I=P*P,LI,P\n            A(I)=.FALSE.\n 20      CONTINUE\n 30   CONTINUE\n\n      DO 40 I=2,LI\n         IF ( A(I) ) WRITE(6,100) I\n 40   CONTINUE\n\n 100  FORMAT(I3)\n      RETURN\n      END\n", "target": "import java.util.LinkedList;\n\npublic class Sieve{\n       public static LinkedList<Integer> sieve(int n){\n               if(n < 2) return new LinkedList<Integer>();\n               LinkedList<Integer> primes = new LinkedList<Integer>();\n               LinkedList<Integer> nums = new LinkedList<Integer>();\n\n               for(int i = 2;i <= n;i++){ \n                       nums.add(i);\n               }\n\n               while(nums.size() > 0){\n                       int nextPrime = nums.remove();\n                       for(int i = nextPrime * nextPrime;i <= n;i += nextPrime){\n                               nums.removeFirstOccurrence(i);\n                       }\n                       primes.add(nextPrime);\n               }\n               return primes;\n       }\n}\n"}
{"id": 50034, "name": "Sieve of Eratosthenes", "source": "Translate Fortran to Python:       PROGRAM MAIN\n      INTEGER LI\n      WRITE (6,100)\n      READ  (5,110) LI\n      call SOE(LI)\n 100  FORMAT( 'Limit:' )\n 110  FORMAT( I4 )\n      STOP\n      END\n      \nC --- SIEVE OF ERATOSTHENES ----------\n      SUBROUTINE SOE( LI )\n      INTEGER LI\n      LOGICAL A(LI)\n      INTEGER SL,P,I\n      \n      DO 10 I=1,LI\n         A(I) = .TRUE.\n 10   CONTINUE\n      \n      SL = INT(SQRT(REAL(LI)))\n      A(1) = .FALSE.\n      DO 30 P=2,SL\n         IF ( .NOT. A(P) ) GOTO 30\n         DO 20 I=P*P,LI,P\n            A(I)=.FALSE.\n 20      CONTINUE\n 30   CONTINUE\n\n      DO 40 I=2,LI\n         IF ( A(I) ) WRITE(6,100) I\n 40   CONTINUE\n\n 100  FORMAT(I3)\n      RETURN\n      END\n", "target": "from __future__ import print_function\n\ni = 2\n\ndef setup():\n    size(1000, 1000)\n    \n    global maxx, maxy, max_num, sieve\n    maxx = width\n    maxy = height\n    max_num = width * height\n    sieve = [False] * (max_num + 1)\n\n    sieve[1] = False\n    plot(0, False)\n    plot(1, False)\n    for i in range(2, max_num + 1):\n        sieve[i] = True\n        plot(i, True)\n\n\ndef draw():\n    global i\n    if not sieve[i]:\n        while (i * i < max_num and not sieve[i]):\n            i += 1\n\n    if sieve[i]:\n        print(\"{} \".format(i), end = '')\n        for j in range(i * i, max_num + 1, i):\n            if sieve[j]:\n                sieve[j] = False\n                plot(j, False)\n\n    if i * i < max_num:\n        i += 1\n    else:\n        noLoop()\n        println(\"finished\")\n\n\ndef plot(pos, active):\n    set(pos % maxx, pos / maxx, color(0) if active else color(255))\n"}
{"id": 50436, "name": "Sort disjoint sublist", "source": "Translate Fortran to C#: program Example\n  implicit none\n\n  integer :: array(8) = (/ 7, 6, 5, 4, 3, 2, 1, 0 /)\n  integer :: indices(3) = (/ 7, 2, 8 /)\n\n\n\n  call Isort(indices)\n\n\n\n\n  call Isort(array(indices))\n\n  write(*,*) array\n\ncontains\n\nsubroutine Isort(a)\n  integer, intent(in out) :: a(:)\n  integer :: temp\n  integer :: i, j\n   \n  do i = 2, size(a)\n     j = i - 1\n     temp = a(i)\n     do while (j>=1 .and. a(j)>temp)\n        a(j+1) = a(j)\n        j = j - 1\n     end do\n     a(j+1) = temp\n  end do\n  \nend subroutine Isort\nend program Example\n", "target": "using System;\nusing System.Linq;\nusing System.Collections.Generic;\n     \npublic class Test\n{\n    public static void Main()\n    {\n        var list = new List<int>{ 7, 6, 5, 4, 3, 2, 1, 0 };\n        list.SortSublist(6, 1, 7);\n        Console.WriteLine(string.Join(\", \", list));\n    }\n}\n     \npublic static class Extensions\n{\n    public static void SortSublist<T>(this List<T> list, params int[] indices)\n        where T : IComparable<T>\n    {\n        var sublist = indices.OrderBy(i => i)\n            .Zip(indices.Select(i => list[i]).OrderBy(v => v),\n                (Index, Value) => new { Index, Value });\n     \n        foreach (var entry in sublist) {\n            list[entry.Index] = entry.Value;\n        }\n    }\n     \n}\n"}
{"id": 50439, "name": "Sort disjoint sublist", "source": "Translate Fortran to Java: program Example\n  implicit none\n\n  integer :: array(8) = (/ 7, 6, 5, 4, 3, 2, 1, 0 /)\n  integer :: indices(3) = (/ 7, 2, 8 /)\n\n\n\n  call Isort(indices)\n\n\n\n\n  call Isort(array(indices))\n\n  write(*,*) array\n\ncontains\n\nsubroutine Isort(a)\n  integer, intent(in out) :: a(:)\n  integer :: temp\n  integer :: i, j\n   \n  do i = 2, size(a)\n     j = i - 1\n     temp = a(i)\n     do while (j>=1 .and. a(j)>temp)\n        a(j+1) = a(j)\n        j = j - 1\n     end do\n     a(j+1) = temp\n  end do\n  \nend subroutine Isort\nend program Example\n", "target": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.List;\n\npublic class Disjoint {\n    public static <T extends Comparable<? super T>> void sortDisjoint(\n            List<T> array, int[] idxs) {\n        Arrays.sort(idxs);\n        List<T> disjoint = new ArrayList<T>();\n        for (int idx : idxs) {\n            disjoint.add(array.get(idx));\n        }\n        Collections.sort(disjoint);\n        int i = 0;\n        for (int idx : idxs) {\n            array.set(idx, disjoint.get(i++));\n        }\n    }\n\n    public static void main(String[] args) {\n        List<Integer> list = Arrays.asList(7, 6, 5, 4, 3, 2, 1, 0);\n        int[] indices = {6, 1, 7};\n        System.out.println(list);\n        sortDisjoint(list, indices);\n        System.out.println(list);\n    }\n}\n"}
{"id": 50440, "name": "Sort disjoint sublist", "source": "Translate Fortran to Python: program Example\n  implicit none\n\n  integer :: array(8) = (/ 7, 6, 5, 4, 3, 2, 1, 0 /)\n  integer :: indices(3) = (/ 7, 2, 8 /)\n\n\n\n  call Isort(indices)\n\n\n\n\n  call Isort(array(indices))\n\n  write(*,*) array\n\ncontains\n\nsubroutine Isort(a)\n  integer, intent(in out) :: a(:)\n  integer :: temp\n  integer :: i, j\n   \n  do i = 2, size(a)\n     j = i - 1\n     temp = a(i)\n     do while (j>=1 .and. a(j)>temp)\n        a(j+1) = a(j)\n        j = j - 1\n     end do\n     a(j+1) = temp\n  end do\n  \nend subroutine Isort\nend program Example\n", "target": ">>> def sort_disjoint_sublist(data, indices):\n\tindices = sorted(indices)\n\tvalues  = sorted(data[i] for i in indices)\n\tfor index, value in zip(indices, values):\n\t\tdata[index] = value\n\n\t\t\n>>> d = [7, 6, 5, 4, 3, 2, 1, 0]\n>>> i = set([6, 1, 7])\n>>> sort_disjoint_sublist(d, i)\n>>> d\n[7, 0, 5, 4, 3, 2, 1, 6]\n>>> \n>>> def sort_disjoint_sublist(data, indices):\n\tfor index, value in zip(sorted(indices), sorted(data[i] for i in indices)): data[index] = value\n\n\t\n>>>\n"}
{"id": 50601, "name": "Kronecker product", "source": "Translate Fortran to C#:       MODULE ARRAYMUSH\t\n       CONTAINS\t\t\n        SUBROUTINE KPRODUCT(A,B,AB)\t\nConsiders the arrays to be addressed as A(row,column), despite any storage order arrangements.        .\nCreating array AB to fit here, adjusting the caller's array AB, may not work on some compilers.\n         INTEGER A(:,:),B(:,:)\t\t\n         INTEGER, ALLOCATABLE:: AB(:,:)\t\n         INTEGER R,RA,RB,C,CA,CB,I\t\n          RA = UBOUND(A,DIM = 1)\t\n          CA = UBOUND(A,DIM = 2)\t\n          RB = UBOUND(B,DIM = 1)\t\n          CB = UBOUND(B,DIM = 2)\t\n          WRITE (6,1) \"A\",RA,CA,\"B\",RB,CB,\"A.k.B\",RA*RB,CA*CB\t\n    1     FORMAT (3(A,\" is \",I0,\"x\",I0,1X))\t\n          IF (ALLOCATED(AB)) DEALLOCATE(AB)\t\n          ALLOCATE (AB(RA*RB,CA*CB))\t\t\n          R = 0\t\t\n          DO I = 1,RA\t\n            C = 0\t\t\n            DO J = 1,CA\t\t\n              AB(R + 1:R + RB,C + 1:C + CB) = A(I,J)*B\t\n              C = C + CB\t\t\n            END DO\t\t\n            R = R + RB\t\t\n          END DO\t\n        END SUBROUTINE KPRODUCT\t\n\n        SUBROUTINE SHOW(F,A)\t\n         INTEGER F\t\n         INTEGER A(:,:)\t\n         INTEGER R\t\n          DO R = 1,UBOUND(A,DIM = 1)\t\n            WRITE (F,1) A(R,:)\t\t\n    1       FORMAT (666I3)\t\t\n          END DO\t\t\t\n        END SUBROUTINE SHOW\t\n      END MODULE ARRAYMUSH\t\n\n      PROGRAM POKE\n      USE ARRAYMUSH\n      INTEGER A(2,2),B(2,2)\t\t\n      INTEGER, ALLOCATABLE:: AB(:,:)\t\n      INTEGER C(3,3),D(3,4)\t\t\n      DATA A/1,3, 2,4/,B/0,6, 5,7/\t\n      DATA C/0,1,0, 1,1,1, 0,1,0/\t\n      DATA D/1,1,1, 1,0,1, 1,0,1, 1,1,1/\n\n      WRITE (6,*) \"First test...\"\n      CALL KPRODUCT(A,B,AB)\n      CALL SHOW (6,AB)\n\n      WRITE (6,*)\n      WRITE (6,*) \"Second test...\"\n      CALL KPRODUCT(C,D,AB)\n      CALL SHOW (6,AB)\n\n      END\n", "target": "using System;\nusing System.Collections;\nusing System.Collections.Generic;\nusing static System.Linq.Enumerable;\n\npublic static class KroneckerProduct\n{\n    public static void Main() {\n        int[,] left = { {1, 2}, {3, 4} };\n        int[,] right = { {0, 5}, {6, 7} };\n        Print(Multiply(left, right));\n\n        left = new [,] { {0, 1, 0}, {1, 1, 1}, {0, 1, 0} };\n        right = new [,] { {1, 1, 1, 1}, {1, 0, 0, 1}, {1, 1, 1, 1} };\n        Print(Multiply(left, right));\n    }\n\n    static int[,] Multiply(int[,] left, int[,] right) {\n        (int lRows, int lColumns) = (left.GetLength(0), left.GetLength(1));\n        (int rRows, int rColumns) = (right.GetLength(0), right.GetLength(1));\n        int[,] result = new int[lRows * rRows, lColumns * rColumns];\n\n        foreach (var (r, c) in from r in Range(0, lRows) from c in Range(0, lColumns) select (r, c)) {\n            Copy(r * rRows, c * rColumns, left[r, c]);\n        }\n        return result;\n        \n        void Copy(int startRow, int startColumn, int multiplier) {\n            foreach (var (r, c) in from r in Range(0, rRows) from c in Range(0, rColumns) select (r, c)) {\n                result[startRow + r, startColumn + c] = right[r, c] * multiplier;\n            }\n        }\n    }\n\n    static void Print(int[,] matrix) {\n        (int rows, int columns) = (matrix.GetLength(0), matrix.GetLength(1));\n        int width = matrix.Cast<int>().Select(LengthOf).Max();\n        for (int row = 0; row < rows; row++) {\n            Console.WriteLine(\"| \" + string.Join(\" \", Range(0, columns).Select(column => (matrix[row, column] + \"\").PadLeft(width, ' '))) + \" |\");\n        }\n        Console.WriteLine();\n    }\n\n    private static int LengthOf(int i) {\n        if (i < 0) return LengthOf(-i) + 1;\n        int length = 0;\n        while (i > 0) {\n            length++;\n            i /= 10;\n        }\n        return length;\n    }\n\n}\n"}
{"id": 50604, "name": "Kronecker product", "source": "Translate Fortran to Java:       MODULE ARRAYMUSH\t\n       CONTAINS\t\t\n        SUBROUTINE KPRODUCT(A,B,AB)\t\nConsiders the arrays to be addressed as A(row,column), despite any storage order arrangements.        .\nCreating array AB to fit here, adjusting the caller's array AB, may not work on some compilers.\n         INTEGER A(:,:),B(:,:)\t\t\n         INTEGER, ALLOCATABLE:: AB(:,:)\t\n         INTEGER R,RA,RB,C,CA,CB,I\t\n          RA = UBOUND(A,DIM = 1)\t\n          CA = UBOUND(A,DIM = 2)\t\n          RB = UBOUND(B,DIM = 1)\t\n          CB = UBOUND(B,DIM = 2)\t\n          WRITE (6,1) \"A\",RA,CA,\"B\",RB,CB,\"A.k.B\",RA*RB,CA*CB\t\n    1     FORMAT (3(A,\" is \",I0,\"x\",I0,1X))\t\n          IF (ALLOCATED(AB)) DEALLOCATE(AB)\t\n          ALLOCATE (AB(RA*RB,CA*CB))\t\t\n          R = 0\t\t\n          DO I = 1,RA\t\n            C = 0\t\t\n            DO J = 1,CA\t\t\n              AB(R + 1:R + RB,C + 1:C + CB) = A(I,J)*B\t\n              C = C + CB\t\t\n            END DO\t\t\n            R = R + RB\t\t\n          END DO\t\n        END SUBROUTINE KPRODUCT\t\n\n        SUBROUTINE SHOW(F,A)\t\n         INTEGER F\t\n         INTEGER A(:,:)\t\n         INTEGER R\t\n          DO R = 1,UBOUND(A,DIM = 1)\t\n            WRITE (F,1) A(R,:)\t\t\n    1       FORMAT (666I3)\t\t\n          END DO\t\t\t\n        END SUBROUTINE SHOW\t\n      END MODULE ARRAYMUSH\t\n\n      PROGRAM POKE\n      USE ARRAYMUSH\n      INTEGER A(2,2),B(2,2)\t\t\n      INTEGER, ALLOCATABLE:: AB(:,:)\t\n      INTEGER C(3,3),D(3,4)\t\t\n      DATA A/1,3, 2,4/,B/0,6, 5,7/\t\n      DATA C/0,1,0, 1,1,1, 0,1,0/\t\n      DATA D/1,1,1, 1,0,1, 1,0,1, 1,1,1/\n\n      WRITE (6,*) \"First test...\"\n      CALL KPRODUCT(A,B,AB)\n      CALL SHOW (6,AB)\n\n      WRITE (6,*)\n      WRITE (6,*) \"Second test...\"\n      CALL KPRODUCT(C,D,AB)\n      CALL SHOW (6,AB)\n\n      END\n", "target": "package kronecker;\n\n\npublic class Product {\n  \n  public static int[][] product(final int[][] a, final int[][] b) {\n    \n    \n    final int[][] c = new int[a.length*b.length][];\n    \n    \n    for (int ix = 0; ix < c.length; ix++) {\n      final int num_cols = a[0].length*b[0].length;\n      c[ix] = new int[num_cols];\n    }\n    \n    \n    for (int ia = 0; ia < a.length; ia++) {\n      for (int ja = 0; ja < a[ia].length; ja++) {\n        \n        for (int ib = 0; ib < b.length; ib++) {\n          for (int jb = 0; jb < b[ib].length; jb++) {\n             c[b.length*ia+ib][b[ib].length*ja+jb] = a[ia][ja] * b[ib][jb];\n          }\n        }\n      }\n    }\n\n    \n    return c;\n  }\n\n  \n  public static void print_matrix(final int[][] m) {\n    \n    \n    \n    \n    final String[][] sts = new String[m.length][];\n    int max_length = 0;  \n    for (int im = 0; im < m.length; im++) {\n      sts[im] = new String[m[im].length];\n      for (int jm = 0; jm < m[im].length; jm++) {\n        final String st = String.valueOf(m[im][jm]);\n        if (st.length() > max_length) {\n          max_length = st.length();\n        }\n        sts[im][jm] = st;\n      }\n    }\n\n    \n    \n    \n    final String format = String.format(\"%%%ds\", max_length);\n    for (int im = 0; im < m.length; im++) {\n      System.out.print(\"|\");\n      \n      for (int jm = 0; jm < m[im].length - 1; jm++) {\n        System.out.format(format, m[im][jm]);\n        System.out.print(\" \");\n      }\n      System.out.format(format, m[im][m[im].length - 1]);\n      System.out.println(\"|\");\n    }\n  }\n\n  \n  private static void test(final int[][] a, final int[][] b) {\n    \n    System.out.println(\"Testing Kronecker product\");\n    System.out.println(\"Size of matrix a: \" + a.length + \" by \" + a[0].length);\n    System.out.println(\"Matrix a:\");\n    print_matrix(a);\n    System.out.println(\"Size of matrix b: \" + b.length + \" by \" + b[0].length);\n    System.out.println(\"Matrix b:\");\n    print_matrix(b);\n    System.out.println(\"Calculating matrix c as Kronecker product\");\n    final int[][] c = product(a, b);\n    System.out.println(\"Size of matrix c: \" + c.length + \" by \" + c[0].length);\n    System.out.println(\"Matrix c:\");\n    print_matrix(c);\n  }\n\n  \n  private static void test1() {\n    \n    final int[][] a = new int[2][];  \n    a[0] = new int[]{1, 2};\n    a[1] = new int[]{3, 4};\n    final int[][] b = new int[2][];  \n    b[0] = new int[]{0, 5};\n    b[1] = new int[]{6, 7};\n    \n    test(a, b);\n  }\n\n  \n  private static void test2() {\n    \n    final int[][] a = new int[3][];  \n    a[0] = new int[]{0, 1, 0};\n    a[1] = new int[]{1, 1, 1};\n    a[2] = new int[]{0, 1, 0};\n    final int[][] b = new int[3][];  \n    b[0] = new int[]{1, 1, 1, 1};\n    b[1] = new int[]{1, 0, 0, 1};\n    b[2] = new int[]{1, 1, 1, 1};\n    \n    test(a, b);\n  }\n\n  \n  public static void main(final String[] args) {\n    \n    test1();\n    test2();\n  }\n\n}\n"}
{"id": 50605, "name": "Kronecker product", "source": "Translate Fortran to Python:       MODULE ARRAYMUSH\t\n       CONTAINS\t\t\n        SUBROUTINE KPRODUCT(A,B,AB)\t\nConsiders the arrays to be addressed as A(row,column), despite any storage order arrangements.        .\nCreating array AB to fit here, adjusting the caller's array AB, may not work on some compilers.\n         INTEGER A(:,:),B(:,:)\t\t\n         INTEGER, ALLOCATABLE:: AB(:,:)\t\n         INTEGER R,RA,RB,C,CA,CB,I\t\n          RA = UBOUND(A,DIM = 1)\t\n          CA = UBOUND(A,DIM = 2)\t\n          RB = UBOUND(B,DIM = 1)\t\n          CB = UBOUND(B,DIM = 2)\t\n          WRITE (6,1) \"A\",RA,CA,\"B\",RB,CB,\"A.k.B\",RA*RB,CA*CB\t\n    1     FORMAT (3(A,\" is \",I0,\"x\",I0,1X))\t\n          IF (ALLOCATED(AB)) DEALLOCATE(AB)\t\n          ALLOCATE (AB(RA*RB,CA*CB))\t\t\n          R = 0\t\t\n          DO I = 1,RA\t\n            C = 0\t\t\n            DO J = 1,CA\t\t\n              AB(R + 1:R + RB,C + 1:C + CB) = A(I,J)*B\t\n              C = C + CB\t\t\n            END DO\t\t\n            R = R + RB\t\t\n          END DO\t\n        END SUBROUTINE KPRODUCT\t\n\n        SUBROUTINE SHOW(F,A)\t\n         INTEGER F\t\n         INTEGER A(:,:)\t\n         INTEGER R\t\n          DO R = 1,UBOUND(A,DIM = 1)\t\n            WRITE (F,1) A(R,:)\t\t\n    1       FORMAT (666I3)\t\t\n          END DO\t\t\t\n        END SUBROUTINE SHOW\t\n      END MODULE ARRAYMUSH\t\n\n      PROGRAM POKE\n      USE ARRAYMUSH\n      INTEGER A(2,2),B(2,2)\t\t\n      INTEGER, ALLOCATABLE:: AB(:,:)\t\n      INTEGER C(3,3),D(3,4)\t\t\n      DATA A/1,3, 2,4/,B/0,6, 5,7/\t\n      DATA C/0,1,0, 1,1,1, 0,1,0/\t\n      DATA D/1,1,1, 1,0,1, 1,0,1, 1,1,1/\n\n      WRITE (6,*) \"First test...\"\n      CALL KPRODUCT(A,B,AB)\n      CALL SHOW (6,AB)\n\n      WRITE (6,*)\n      WRITE (6,*) \"Second test...\"\n      CALL KPRODUCT(C,D,AB)\n      CALL SHOW (6,AB)\n\n      END\n", "target": "\n\n\na1 = [[1, 2], [3, 4]]\nb1 = [[0, 5], [6, 7]]\n\n\na2 = [[0, 1, 0], [1, 1, 1], [0, 1, 0]]\nb2 = [[1, 1, 1, 1], [1, 0, 0, 1], [1, 1, 1, 1]]\n\ndef kronecker(matrix1, matrix2):\n    final_list = []\n    sub_list = []\n\n    count = len(matrix2)\n\n    for elem1 in matrix1:\n        counter = 0\n        check = 0\n        while check < count:\n            for num1 in elem1:\n                for num2 in matrix2[counter]:\n                    sub_list.append(num1 * num2)\n            counter += 1\n            final_list.append(sub_list)\n            sub_list = []\n            check +=1\n            \n    return final_list\n\n\nresult1 = kronecker(a1, b1)\nfor elem in result1:\n    print(elem)\n\nprint(\"\")\n\n\nresult2 = kronecker(a2, b2)\nfor elem in result2:\n    print(elem)\n"}
{"id": 50879, "name": "Split a character string based on change of character", "source": "Translate Fortran to C#:       SUBROUTINE SPLATTER(TEXT)\t\nCan't display the inserted commas in a different colour so as not to look like any commas in TEXT.\n       CHARACTER*(*) TEXT\t\n       INTEGER L\t\n       CHARACTER*1 C\t\n        IF (LEN(TEXT).LE.0) RETURN\t\n        C = TEXT(1:1)\t\t\t\n        DO L = 1,LEN(TEXT)\t\n          IF (C.NE.TEXT(L:L)) THEN\t\n            C = TEXT(L:L)\t\t\t\n            WRITE (6,1) \", \"\t\t\t\n          END IF\t\t\t\n          WRITE (6,1) C\t\t\t\n    1     FORMAT (A,$)\t\t\t\n        END DO\t\t\t\n        WRITE (6,1)\t\n      END SUBROUTINE SPLATTER\t\n\n      PROGRAM POKE\n      CALL SPLATTER(\"gHHH5YY++///\\\")\t\n      END\n", "target": "using System;\nusing System.Linq;\nusing System.Collections.Generic;\n\npublic class Program\n{\n    string s = @\"gHHH5YY++\n    Console.WriteLine(s.RunLengthSplit().Delimit(\", \"));\n}\n\npublic static class Extensions\n{\n    public static IEnumerable<string> RunLengthSplit(this string source) {\n        using (var enumerator = source.GetEnumerator()) {\n            if (!enumerator.MoveNext()) yield break;\n            char previous = enumerator.Current;\n            int count = 1;\n            while (enumerator.MoveNext()) {\n                if (previous == enumerator.Current) {\n                    count++;\n                } else {\n                    yield return new string(Enumerable.Repeat(previous, count).ToArray());\n                    previous = enumerator.Current;\n                    count = 1;\n                }\n            }\n            yield return new string(Enumerable.Repeat(previous, count).ToArray());\n        }\n    }\n\n    public static string Delimit<T>(this IEnumerable<T> source, string separator = \"\") => string.Join(separator ?? \"\", source);\n}\n"}
{"id": 50880, "name": "Split a character string based on change of character", "source": "Translate Fortran to C#:       SUBROUTINE SPLATTER(TEXT)\t\nCan't display the inserted commas in a different colour so as not to look like any commas in TEXT.\n       CHARACTER*(*) TEXT\t\n       INTEGER L\t\n       CHARACTER*1 C\t\n        IF (LEN(TEXT).LE.0) RETURN\t\n        C = TEXT(1:1)\t\t\t\n        DO L = 1,LEN(TEXT)\t\n          IF (C.NE.TEXT(L:L)) THEN\t\n            C = TEXT(L:L)\t\t\t\n            WRITE (6,1) \", \"\t\t\t\n          END IF\t\t\t\n          WRITE (6,1) C\t\t\t\n    1     FORMAT (A,$)\t\t\t\n        END DO\t\t\t\n        WRITE (6,1)\t\n      END SUBROUTINE SPLATTER\t\n\n      PROGRAM POKE\n      CALL SPLATTER(\"gHHH5YY++///\\\")\t\n      END\n", "target": "using System;\nusing System.Linq;\nusing System.Collections.Generic;\n\npublic class Program\n{\n    string s = @\"gHHH5YY++\n    Console.WriteLine(s.RunLengthSplit().Delimit(\", \"));\n}\n\npublic static class Extensions\n{\n    public static IEnumerable<string> RunLengthSplit(this string source) {\n        using (var enumerator = source.GetEnumerator()) {\n            if (!enumerator.MoveNext()) yield break;\n            char previous = enumerator.Current;\n            int count = 1;\n            while (enumerator.MoveNext()) {\n                if (previous == enumerator.Current) {\n                    count++;\n                } else {\n                    yield return new string(Enumerable.Repeat(previous, count).ToArray());\n                    previous = enumerator.Current;\n                    count = 1;\n                }\n            }\n            yield return new string(Enumerable.Repeat(previous, count).ToArray());\n        }\n    }\n\n    public static string Delimit<T>(this IEnumerable<T> source, string separator = \"\") => string.Join(separator ?? \"\", source);\n}\n"}
{"id": 50885, "name": "Split a character string based on change of character", "source": "Translate Fortran to Java:       SUBROUTINE SPLATTER(TEXT)\t\nCan't display the inserted commas in a different colour so as not to look like any commas in TEXT.\n       CHARACTER*(*) TEXT\t\n       INTEGER L\t\n       CHARACTER*1 C\t\n        IF (LEN(TEXT).LE.0) RETURN\t\n        C = TEXT(1:1)\t\t\t\n        DO L = 1,LEN(TEXT)\t\n          IF (C.NE.TEXT(L:L)) THEN\t\n            C = TEXT(L:L)\t\t\t\n            WRITE (6,1) \", \"\t\t\t\n          END IF\t\t\t\n          WRITE (6,1) C\t\t\t\n    1     FORMAT (A,$)\t\t\t\n        END DO\t\t\t\n        WRITE (6,1)\t\n      END SUBROUTINE SPLATTER\t\n\n      PROGRAM POKE\n      CALL SPLATTER(\"gHHH5YY++///\\\")\t\n      END\n", "target": "package org.rosettacode;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\n\n\npublic class SplitStringByCharacterChange {\n    \n    public static void main(String... args){\n        for (String string : args){\n            \n            List<String> resultStrings = splitStringByCharacter(string);\n            String output = formatList(resultStrings);\n            System.out.println(output);\n        }\n    }\n    \n    \n    public static List<String> splitStringByCharacter(String string){\n        \n        List<String> resultStrings = new ArrayList<>();\n        StringBuilder currentString = new StringBuilder();\n        \n        for (int pointer = 0; pointer < string.length(); pointer++){\n            \n            currentString.append(string.charAt(pointer));\n            \n            if (pointer == string.length() - 1 \n                    || currentString.charAt(0) != string.charAt(pointer + 1)) {\n                resultStrings.add(currentString.toString());\n                currentString = new StringBuilder();\n            }\n        }\n        \n        return resultStrings;\n    }\n    \n    \n    public static String formatList(List<String> list){\n        \n        StringBuilder output = new StringBuilder();\n        \n        for (int pointer = 0; pointer < list.size(); pointer++){\n            output.append(list.get(pointer));\n            \n            if (pointer != list.size() - 1){\n                output.append(\", \");\n            }\n        }\n        \n        return output.toString();\n    }\n}\n"}
{"id": 50886, "name": "Split a character string based on change of character", "source": "Translate Fortran to Java:       SUBROUTINE SPLATTER(TEXT)\t\nCan't display the inserted commas in a different colour so as not to look like any commas in TEXT.\n       CHARACTER*(*) TEXT\t\n       INTEGER L\t\n       CHARACTER*1 C\t\n        IF (LEN(TEXT).LE.0) RETURN\t\n        C = TEXT(1:1)\t\t\t\n        DO L = 1,LEN(TEXT)\t\n          IF (C.NE.TEXT(L:L)) THEN\t\n            C = TEXT(L:L)\t\t\t\n            WRITE (6,1) \", \"\t\t\t\n          END IF\t\t\t\n          WRITE (6,1) C\t\t\t\n    1     FORMAT (A,$)\t\t\t\n        END DO\t\t\t\n        WRITE (6,1)\t\n      END SUBROUTINE SPLATTER\t\n\n      PROGRAM POKE\n      CALL SPLATTER(\"gHHH5YY++///\\\")\t\n      END\n", "target": "package org.rosettacode;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\n\n\npublic class SplitStringByCharacterChange {\n    \n    public static void main(String... args){\n        for (String string : args){\n            \n            List<String> resultStrings = splitStringByCharacter(string);\n            String output = formatList(resultStrings);\n            System.out.println(output);\n        }\n    }\n    \n    \n    public static List<String> splitStringByCharacter(String string){\n        \n        List<String> resultStrings = new ArrayList<>();\n        StringBuilder currentString = new StringBuilder();\n        \n        for (int pointer = 0; pointer < string.length(); pointer++){\n            \n            currentString.append(string.charAt(pointer));\n            \n            if (pointer == string.length() - 1 \n                    || currentString.charAt(0) != string.charAt(pointer + 1)) {\n                resultStrings.add(currentString.toString());\n                currentString = new StringBuilder();\n            }\n        }\n        \n        return resultStrings;\n    }\n    \n    \n    public static String formatList(List<String> list){\n        \n        StringBuilder output = new StringBuilder();\n        \n        for (int pointer = 0; pointer < list.size(); pointer++){\n            output.append(list.get(pointer));\n            \n            if (pointer != list.size() - 1){\n                output.append(\", \");\n            }\n        }\n        \n        return output.toString();\n    }\n}\n"}
{"id": 50887, "name": "Split a character string based on change of character", "source": "Translate Fortran to Python:       SUBROUTINE SPLATTER(TEXT)\t\nCan't display the inserted commas in a different colour so as not to look like any commas in TEXT.\n       CHARACTER*(*) TEXT\t\n       INTEGER L\t\n       CHARACTER*1 C\t\n        IF (LEN(TEXT).LE.0) RETURN\t\n        C = TEXT(1:1)\t\t\t\n        DO L = 1,LEN(TEXT)\t\n          IF (C.NE.TEXT(L:L)) THEN\t\n            C = TEXT(L:L)\t\t\t\n            WRITE (6,1) \", \"\t\t\t\n          END IF\t\t\t\n          WRITE (6,1) C\t\t\t\n    1     FORMAT (A,$)\t\t\t\n        END DO\t\t\t\n        WRITE (6,1)\t\n      END SUBROUTINE SPLATTER\t\n\n      PROGRAM POKE\n      CALL SPLATTER(\"gHHH5YY++///\\\")\t\n      END\n", "target": "from itertools import groupby\n\ndef splitter(text):\n    return ', '.join(''.join(group) for key, group in groupby(text))\n\nif __name__ == '__main__':\n    txt = 'gHHH5YY++///\\\\'      \n    print(f'Input: {txt}\\nSplit: {splitter(txt)}')\n"}
{"id": 50888, "name": "Split a character string based on change of character", "source": "Translate Fortran to Python:       SUBROUTINE SPLATTER(TEXT)\t\nCan't display the inserted commas in a different colour so as not to look like any commas in TEXT.\n       CHARACTER*(*) TEXT\t\n       INTEGER L\t\n       CHARACTER*1 C\t\n        IF (LEN(TEXT).LE.0) RETURN\t\n        C = TEXT(1:1)\t\t\t\n        DO L = 1,LEN(TEXT)\t\n          IF (C.NE.TEXT(L:L)) THEN\t\n            C = TEXT(L:L)\t\t\t\n            WRITE (6,1) \", \"\t\t\t\n          END IF\t\t\t\n          WRITE (6,1) C\t\t\t\n    1     FORMAT (A,$)\t\t\t\n        END DO\t\t\t\n        WRITE (6,1)\t\n      END SUBROUTINE SPLATTER\t\n\n      PROGRAM POKE\n      CALL SPLATTER(\"gHHH5YY++///\\\")\t\n      END\n", "target": "from itertools import groupby\n\ndef splitter(text):\n    return ', '.join(''.join(group) for key, group in groupby(text))\n\nif __name__ == '__main__':\n    txt = 'gHHH5YY++///\\\\'      \n    print(f'Input: {txt}\\nSplit: {splitter(txt)}')\n"}
{"id": 51191, "name": "Truncatable primes", "source": "Translate Fortran to C#: module primes_mod\n  implicit none\n  \n  logical, allocatable :: primes(:)\n  \ncontains\n\nsubroutine Genprimes(parr)\n  logical, intent(in out) :: parr(:)\n  integer :: i\n\n  parr = .true.\n  parr (1) = .false.\n  parr (4 : size(parr) : 2) = .false.\n  do i = 3, int (sqrt (real (size(parr)))), 2\n    if (parr(i)) parr(i * i : size(parr) : i) = .false.\n  end do\n\nend subroutine\n\nfunction is_rtp(candidate)\n  logical :: is_rtp\n  integer, intent(in) :: candidate\n  integer :: n\n\n  is_rtp = .true.\n  n = candidate / 10\n  do while(n > 0)\n    if(.not. primes(n)) then\n      is_rtp = .false.\n      return\n    end if\n    n = n / 10\n  end do\n  \nend function\n\nfunction is_ltp(candidate)\n  logical :: is_ltp\n  integer, intent(in) :: candidate\n  integer :: i, n\n  character(10) :: nstr\n\n  write(nstr, \"(i10)\") candidate\n  is_ltp = .true.\n  do i = len_trim(nstr)-1, 1, -1\n    n = mod(candidate, 10**i)\n    if(.not. primes(n)) then\n      is_ltp = .false.\n      return\n    end if\n  end do\nend function\n\nend module primes_mod\n\nprogram Truncatable_Primes\n  use primes_mod\n  implicit none\n  \n  integer, parameter :: limit = 999999\n  integer :: i\n  character(10) :: nstr\n \n\n  allocate(primes(limit))\n  call Genprimes(primes)\n   \n\n  do i = limit, 1, -1\n    write(nstr, \"(i10)\") i\n    if(index(trim(nstr), \"0\") /= 0) cycle      \n    if(is_ltp(i)) then\n      write(*, \"(a, i0)\") \"Largest left truncatable prime below 1000000 is \", i\n      exit\n    end if\n  end do\n\n\n  do i = limit, 1, -1\n    write(nstr, \"(i10)\") i\n    if(index(trim(nstr), \"0\") /= 0) cycle      \n    if(is_rtp(i)) then\n      write(*, \"(a, i0)\") \"Largest right truncatable prime below 1000000 is \", i\n      exit\n    end if\n  end do\nend program\n", "target": "using System;  \nusing System.Collections.Generic;\nclass truncatable_primes\n{\n    static void Main()\n    {\n        uint m = 1000000;\n        Console.Write(\"L \" + L(m) + \" R \" + R(m) + \"  \");\n        var sw = System.Diagnostics.Stopwatch.StartNew();\n        for (int i = 1000; i > 0; i--) { L(m); R(m); }\n        Console.Write(sw.Elapsed); Console.Read();\n    }\n\n    static uint L(uint n)\n    {\n        n -= n & 1; n--;\n        for (uint d, d1 = 100; ; n -= 2)\n        {\n            while (n % 3 == 0 || n % 5 == 0 || n % 7 == 0) n -= 2;\n            if ((d = n % 10) == 3 || d == 7)\n            {\n                while (d1 < n && d < (d = n % d1) && isP(d)) d1 *= 10;\n                if (d1 > n && isP(n)) return n; d1 = 100;\n            }\n        }\n    }\n\n    static uint R(uint m)\n    {\n        var p = new List<uint>() { 2, 3, 5, 7 }; uint n = 20, np;\n        for (int i = 1; i < p.Count; n = 10 * p[i++])\n        {\n            if ((np = n + 1) >= m) break; if (isP(np)) p.Add(np);\n            if ((np = n + 3) >= m) break; if (isP(np)) p.Add(np);\n            if ((np = n + 7) >= m) break; if (isP(np)) p.Add(np);\n            if ((np = n + 9) >= m) break; if (isP(np)) p.Add(np);\n        }\n        return p[p.Count - 1];\n    }\n\n    static bool isP(uint n)\n    {\n        if (n < 7) return n == 2 || n == 3 || n == 5;\n        if ((n & 1) == 0 || n % 3 == 0 || n % 5 == 0) return false;\n        for (uint r = (uint)Math.Sqrt(n), d = 7; d <= r; d += 30)\n            if (n % (d + 00) == 0 || n % (d + 04) == 0 ||\n                n % (d + 06) == 0 || n % (d + 10) == 0 ||\n                n % (d + 12) == 0 || n % (d + 16) == 0 ||\n                n % (d + 22) == 0 || n % (d + 24) == 0) return false;\n        return true;\n    }\n}\n"}
{"id": 51195, "name": "Truncatable primes", "source": "Translate Fortran to Java: module primes_mod\n  implicit none\n  \n  logical, allocatable :: primes(:)\n  \ncontains\n\nsubroutine Genprimes(parr)\n  logical, intent(in out) :: parr(:)\n  integer :: i\n\n  parr = .true.\n  parr (1) = .false.\n  parr (4 : size(parr) : 2) = .false.\n  do i = 3, int (sqrt (real (size(parr)))), 2\n    if (parr(i)) parr(i * i : size(parr) : i) = .false.\n  end do\n\nend subroutine\n\nfunction is_rtp(candidate)\n  logical :: is_rtp\n  integer, intent(in) :: candidate\n  integer :: n\n\n  is_rtp = .true.\n  n = candidate / 10\n  do while(n > 0)\n    if(.not. primes(n)) then\n      is_rtp = .false.\n      return\n    end if\n    n = n / 10\n  end do\n  \nend function\n\nfunction is_ltp(candidate)\n  logical :: is_ltp\n  integer, intent(in) :: candidate\n  integer :: i, n\n  character(10) :: nstr\n\n  write(nstr, \"(i10)\") candidate\n  is_ltp = .true.\n  do i = len_trim(nstr)-1, 1, -1\n    n = mod(candidate, 10**i)\n    if(.not. primes(n)) then\n      is_ltp = .false.\n      return\n    end if\n  end do\nend function\n\nend module primes_mod\n\nprogram Truncatable_Primes\n  use primes_mod\n  implicit none\n  \n  integer, parameter :: limit = 999999\n  integer :: i\n  character(10) :: nstr\n \n\n  allocate(primes(limit))\n  call Genprimes(primes)\n   \n\n  do i = limit, 1, -1\n    write(nstr, \"(i10)\") i\n    if(index(trim(nstr), \"0\") /= 0) cycle      \n    if(is_ltp(i)) then\n      write(*, \"(a, i0)\") \"Largest left truncatable prime below 1000000 is \", i\n      exit\n    end if\n  end do\n\n\n  do i = limit, 1, -1\n    write(nstr, \"(i10)\") i\n    if(index(trim(nstr), \"0\") /= 0) cycle      \n    if(is_rtp(i)) then\n      write(*, \"(a, i0)\") \"Largest right truncatable prime below 1000000 is \", i\n      exit\n    end if\n  end do\nend program\n", "target": "import java.util.BitSet;\n\npublic class Main {\n\n\tpublic static void main(String[] args){\n\n\t\tfinal int MAX = 1000000;\n\n\t\t\n\t\tBitSet primeList = new BitSet(MAX>>1); \n\t\tprimeList.set(0,primeList.size(),true); \n\n\t\tint sqroot = (int) Math.sqrt(MAX); \n\t\tprimeList.clear(0); \n\t\tfor(int num = 3; num <= sqroot; num+=2) \n\t\t{ \n\t\t\tif( primeList.get(num >> 1) ) \n\t\t\t{ \n\t\t\t\tint inc = num << 1;\n\t\t\t\tfor(int factor = num * num; factor < MAX; factor += inc) \n\t\t\t\t{ \n\t\t\t\t\t\n\t\t\t\t\t\n\t\t\t\t\tprimeList.clear(factor >> 1); \n\t\t\t\t\t\n\t\t\t\t} \n\t\t\t} \n\t\t}\n\t\t\n\n\t\t\n\t\tint rightTrunc = -1, leftTrunc = -1;\n\t\tfor(int prime = (MAX - 1) | 1; prime >= 3; prime -= 2)\n\t\t{\n\t\t\tif(primeList.get(prime>>1))\n\t\t\t{\n\t\t\t\t\n\t\t\t\tif(rightTrunc == -1)\n\t\t\t\t{\n\t\t\t\t\tint right = prime;\n\t\t\t\t\twhile(right > 0 && right % 2 != 0 && primeList.get(right >> 1)) right /= 10;\n\t\t\t\t\tif(right == 0) rightTrunc = prime;\n\t\t\t\t}\n\n\t\t\t\t\n\t\t\t\tif(leftTrunc == -1 )\n\t\t\t\t{\n\t\t\t\t\t\n\t\t\t\t\tString left = Integer.toString(prime);\n\t\t\t\t\tif(!left.contains(\"0\"))\n\t\t\t\t\t{\n\t\t\t\t\t\twhile( left.length() > 0 ){\n\t\t\t\t\t\t\tint iLeft = Integer.parseInt(left);\n\t\t\t\t\t\t\tif(!primeList.get( iLeft >> 1)) break;\n\t\t\t\t\t\t\tleft = left.substring(1);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(left.length() == 0) leftTrunc = prime;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(leftTrunc != -1 && rightTrunc != -1) \n\t\t\t\t{\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(\"Left  Truncatable\u00a0: \" + leftTrunc);\n\t\tSystem.out.println(\"Right Truncatable\u00a0: \" + rightTrunc);\n\t}\n}\n"}
{"id": 51196, "name": "Truncatable primes", "source": "Translate Fortran to Python: module primes_mod\n  implicit none\n  \n  logical, allocatable :: primes(:)\n  \ncontains\n\nsubroutine Genprimes(parr)\n  logical, intent(in out) :: parr(:)\n  integer :: i\n\n  parr = .true.\n  parr (1) = .false.\n  parr (4 : size(parr) : 2) = .false.\n  do i = 3, int (sqrt (real (size(parr)))), 2\n    if (parr(i)) parr(i * i : size(parr) : i) = .false.\n  end do\n\nend subroutine\n\nfunction is_rtp(candidate)\n  logical :: is_rtp\n  integer, intent(in) :: candidate\n  integer :: n\n\n  is_rtp = .true.\n  n = candidate / 10\n  do while(n > 0)\n    if(.not. primes(n)) then\n      is_rtp = .false.\n      return\n    end if\n    n = n / 10\n  end do\n  \nend function\n\nfunction is_ltp(candidate)\n  logical :: is_ltp\n  integer, intent(in) :: candidate\n  integer :: i, n\n  character(10) :: nstr\n\n  write(nstr, \"(i10)\") candidate\n  is_ltp = .true.\n  do i = len_trim(nstr)-1, 1, -1\n    n = mod(candidate, 10**i)\n    if(.not. primes(n)) then\n      is_ltp = .false.\n      return\n    end if\n  end do\nend function\n\nend module primes_mod\n\nprogram Truncatable_Primes\n  use primes_mod\n  implicit none\n  \n  integer, parameter :: limit = 999999\n  integer :: i\n  character(10) :: nstr\n \n\n  allocate(primes(limit))\n  call Genprimes(primes)\n   \n\n  do i = limit, 1, -1\n    write(nstr, \"(i10)\") i\n    if(index(trim(nstr), \"0\") /= 0) cycle      \n    if(is_ltp(i)) then\n      write(*, \"(a, i0)\") \"Largest left truncatable prime below 1000000 is \", i\n      exit\n    end if\n  end do\n\n\n  do i = limit, 1, -1\n    write(nstr, \"(i10)\") i\n    if(index(trim(nstr), \"0\") /= 0) cycle      \n    if(is_rtp(i)) then\n      write(*, \"(a, i0)\") \"Largest right truncatable prime below 1000000 is \", i\n      exit\n    end if\n  end do\nend program\n", "target": "maxprime = 1000000\n\ndef primes(n):\n    multiples = set()\n    prime = []\n    for i in range(2, n+1):\n        if i not in multiples:\n            prime.append(i)\n            multiples.update(set(range(i*i, n+1, i)))\n    return prime\n\ndef truncatableprime(n):\n    'Return a longest left and right truncatable primes below n'\n    primelist = [str(x) for x in primes(n)[::-1]]\n    primeset = set(primelist)\n    for n in primelist:\n        \n        alltruncs = set(n[i:] for i in range(len(n)))\n        if alltruncs.issubset(primeset):\n            truncateleft = int(n)\n            break\n    for n in primelist:\n        \n        alltruncs = set([n[:i+1] for i in range(len(n))])\n        if alltruncs.issubset(primeset):\n            truncateright = int(n)\n            break\n    return truncateleft, truncateright\n\nprint(truncatableprime(maxprime))\n"}
{"id": 51541, "name": "Nested function", "source": "Translate Fortran to C#:       FUNCTION F(X)\n       REAL X\n       DIST(U,V,W) = X*SQRT(U**2 + V**2 + W**2)    \n        T = EXP(X)\n        F = T + DIST(T,SIN(X),ATAN(X) + 7)         \n      END\n", "target": "string MakeList(string separator)\n{\n    int counter = 1;\n\n    Func<string, string> makeItem = item => counter++ + separator + item + \"\\n\";\n\n    return makeItem(\"first\") + makeItem(\"second\") + makeItem(\"third\");\n}\n\nConsole.WriteLine(MakeList(\". \"));\n"}
{"id": 51542, "name": "Nested function", "source": "Translate Fortran to C#:       FUNCTION F(X)\n       REAL X\n       DIST(U,V,W) = X*SQRT(U**2 + V**2 + W**2)    \n        T = EXP(X)\n        F = T + DIST(T,SIN(X),ATAN(X) + 7)         \n      END\n", "target": "string MakeList(string separator)\n{\n    int counter = 1;\n\n    Func<string, string> makeItem = item => counter++ + separator + item + \"\\n\";\n\n    return makeItem(\"first\") + makeItem(\"second\") + makeItem(\"third\");\n}\n\nConsole.WriteLine(MakeList(\". \"));\n"}
{"id": 51548, "name": "Nested function", "source": "Translate Fortran to Java:       FUNCTION F(X)\n       REAL X\n       DIST(U,V,W) = X*SQRT(U**2 + V**2 + W**2)    \n        T = EXP(X)\n        F = T + DIST(T,SIN(X),ATAN(X) + 7)         \n      END\n", "target": "module NestedFunction\n    {\n    static String makeList(String separator)\n        {\n        Int counter = 1;\n\n        function String(String) makeItem = item -> $\"{counter++}{separator}{item}\\n\";\n\n        return makeItem(\"first\")\n             + makeItem(\"second\")\n             + makeItem(\"third\");\n        }\n\n    void run()\n        {\n        @Inject Console console;\n        console.print(makeList(\". \"));\n        }\n    }\n"}
{"id": 51549, "name": "Nested function", "source": "Translate Fortran to Java:       FUNCTION F(X)\n       REAL X\n       DIST(U,V,W) = X*SQRT(U**2 + V**2 + W**2)    \n        T = EXP(X)\n        F = T + DIST(T,SIN(X),ATAN(X) + 7)         \n      END\n", "target": "module NestedFunction\n    {\n    static String makeList(String separator)\n        {\n        Int counter = 1;\n\n        function String(String) makeItem = item -> $\"{counter++}{separator}{item}\\n\";\n\n        return makeItem(\"first\")\n             + makeItem(\"second\")\n             + makeItem(\"third\");\n        }\n\n    void run()\n        {\n        @Inject Console console;\n        console.print(makeList(\". \"));\n        }\n    }\n"}
{"id": 51550, "name": "Nested function", "source": "Translate Fortran to Python:       FUNCTION F(X)\n       REAL X\n       DIST(U,V,W) = X*SQRT(U**2 + V**2 + W**2)    \n        T = EXP(X)\n        F = T + DIST(T,SIN(X),ATAN(X) + 7)         \n      END\n", "target": "def makeList(separator):\n    counter = 1\n\n    def makeItem(item):\n        nonlocal counter\n        result = str(counter) + separator + item + \"\\n\"\n        counter += 1\n        return result\n\n    return makeItem(\"first\") + makeItem(\"second\") + makeItem(\"third\")\n\nprint(makeList(\". \"))\n"}
{"id": 51551, "name": "Nested function", "source": "Translate Fortran to Python:       FUNCTION F(X)\n       REAL X\n       DIST(U,V,W) = X*SQRT(U**2 + V**2 + W**2)    \n        T = EXP(X)\n        F = T + DIST(T,SIN(X),ATAN(X) + 7)         \n      END\n", "target": "def makeList(separator):\n    counter = 1\n\n    def makeItem(item):\n        nonlocal counter\n        result = str(counter) + separator + item + \"\\n\"\n        counter += 1\n        return result\n\n    return makeItem(\"first\") + makeItem(\"second\") + makeItem(\"third\")\n\nprint(makeList(\". \"))\n"}
{"id": 51887, "name": "Sorting algorithms_Merge sort", "source": "Translate Fortran to C#:       program TestMergeSort\n        implicit none\n        integer, parameter :: N = 8\n        integer :: A(N) = (/ 1, 5, 2, 7, 3, 9, 4, 6 /)\n        integer :: work((size(A) + 1) / 2)\n        write(*,'(A,/,10I3)')'Unsorted array\u00a0:',A\n        call MergeSort(A, work)\n        write(*,'(A,/,10I3)')'Sorted array\u00a0:',A\n      contains\n\n      subroutine merge(A, B, C)\n        implicit none\n\n        integer, target, intent(in) :: A(:), B(:)\n        integer, target, intent(inout) :: C(:)\n        integer :: i, j, k\n\n        if (size(A) + size(B) > size(C)) stop(1)\n\n        i = 1; j = 1\n        do k = 1, size(C)\n          if (i <= size(A) .and. j <= size(B)) then\n            if (A(i) <= B(j)) then\n              C(k) = A(i)\n              i = i + 1\n            else\n              C(k) = B(j)\n              j = j + 1\n            end if\n          else if (i <= size(A)) then\n            C(k) = A(i)\n            i = i + 1\n          else if (j <= size(B)) then\n            C(k) = B(j)\n            j = j + 1\n          end if\n        end do\n      end subroutine merge\n\n      subroutine swap(x, y)\n        implicit none\n        integer, intent(inout) :: x, y\n        integer :: tmp\n        tmp = x; x = y; y = tmp\n      end subroutine\n\n      recursive subroutine MergeSort(A, work)\n        implicit none\n        integer, intent(inout) :: A(:)\n        integer, intent(inout) :: work(:)\n        integer :: half\n        half = (size(A) + 1) / 2\n        if (size(A) < 2) then\n          continue\n        else if (size(A) == 2) then\n          if (A(1) > A(2)) then\n            call swap(A(1), A(2))\n          end if\n        else\n          call MergeSort(A( : half), work)\n          call MergeSort(A(half + 1 :), work)\n          if (A(half) > A(half + 1)) then\n            work(1 : half) = A(1 : half)\n            call merge(work(1 : half), A(half + 1:), A)\n          endif\n        end if\n      end subroutine MergeSort\n      end program TestMergeSort\n", "target": "namespace RosettaCode {\n  using System;\n\n  public class MergeSort<T> where T : IComparable {\n    #region Constants\n    public const UInt32 INSERTION_LIMIT_DEFAULT = 12;\n    public const Int32 MERGES_DEFAULT = 6;\n    #endregion\n\n    #region Properties\n    public UInt32 InsertionLimit { get; }\n    protected UInt32[] Positions { get; set; }\n\n    private Int32 merges;\n    public Int32 Merges {\n      get { return merges; }\n      set {\n        \n        if (value > 1)\n          merges = value;\n        else\n          throw new ArgumentOutOfRangeException($\"value = {value} must be greater than one\", nameof(Merges));\n\n        if (Positions == null || Positions.Length != merges)\n          Positions = new UInt32[merges];\n      }\n    }\n    #endregion\n\n    #region Constructors\n    public MergeSort(UInt32 insertionLimit, Int32 merges) {\n      InsertionLimit = insertionLimit;\n      Merges = merges;\n    }\n\n    public MergeSort()\n      : this(INSERTION_LIMIT_DEFAULT, MERGES_DEFAULT) {\n    }\n    #endregion\n\n    #region Sort Methods\n    public void Sort(T[] entries) {\n      \n      var entries2 = new T[entries.Length];\n      Sort(entries, entries2, 0, entries.Length - 1);\n    }\n\n    \n    public void Sort(T[] entries1, T[] entries2, Int32 first, Int32 last) {\n      var length = last + 1 - first;\n      if (length < 2) return;      \n      if (length < Merges || length < InsertionLimit) {\n        InsertionSort<T>.Sort(entries1, first, last);\n        return;\n      }\n\n      var left = first;\n      var size = ceiling(length, Merges);\n      for (var remaining = length; remaining > 0; remaining -= size, left += size) {\n        var right = left + Math.Min(remaining, size) - 1;\n        Sort(entries1, entries2, left, right);\n      }\n\n      Merge(entries1, entries2, first, last);\n      Array.Copy(entries2, first, entries1, first, length);\n    }\n    #endregion\n\n    #region Merge Methods\n    public void Merge(T[] entries1, T[] entries2, Int32 first, Int32 last) {\n      Array.Clear(Positions, 0, Merges);\n      \n      for (var index = first; index <= last; index++)\n        entries2[index] = remove(entries1, first, last);\n    }\n\n    private T remove(T[] entries, Int32 first, Int32 last) {\n      T entry = default;\n      Int32? found = default;\n      var length = last + 1 - first;\n\n      var index = 0;\n      var left = first;\n      var size = ceiling(length, Merges);\n      for (var remaining = length; remaining > 0; remaining -= size, left += size, index++) {\n        var position = Positions[index];\n        if (position < Math.Min(remaining, size)) {\n          var next = entries[left + position];\n          if (!found.HasValue || entry.CompareTo(next) > 0) {\n            found = index;\n            entry = next;\n          }\n        }\n      }\n\n      \n      Positions[found.Value]++;\n      return entry;\n    }\n    #endregion\n\n    #region Math Methods\n    private static Int32 ceiling(Int32 numerator, Int32 denominator) {\n      return (numerator + denominator - 1) / denominator;\n    }\n    #endregion\n  }\n\n  #region Insertion Sort\n  static class InsertionSort<T> where T : IComparable {\n    public static void Sort(T[] entries, Int32 first, Int32 last) {\n      for (var next = first + 1; next <= last; next++)\n        insert(entries, first, next);\n    }\n\n    \n    private static void insert(T[] entries, Int32 first, Int32 next) {\n      var entry = entries[next];\n      while (next > first && entries[next - 1].CompareTo(entry) > 0)\n        entries[next] = entries[--next];\n      entries[next] = entry;\n    }\n  }\n  #endregion\n}\n"}
{"id": 51890, "name": "Sorting algorithms_Merge sort", "source": "Translate Fortran to Java:       program TestMergeSort\n        implicit none\n        integer, parameter :: N = 8\n        integer :: A(N) = (/ 1, 5, 2, 7, 3, 9, 4, 6 /)\n        integer :: work((size(A) + 1) / 2)\n        write(*,'(A,/,10I3)')'Unsorted array\u00a0:',A\n        call MergeSort(A, work)\n        write(*,'(A,/,10I3)')'Sorted array\u00a0:',A\n      contains\n\n      subroutine merge(A, B, C)\n        implicit none\n\n        integer, target, intent(in) :: A(:), B(:)\n        integer, target, intent(inout) :: C(:)\n        integer :: i, j, k\n\n        if (size(A) + size(B) > size(C)) stop(1)\n\n        i = 1; j = 1\n        do k = 1, size(C)\n          if (i <= size(A) .and. j <= size(B)) then\n            if (A(i) <= B(j)) then\n              C(k) = A(i)\n              i = i + 1\n            else\n              C(k) = B(j)\n              j = j + 1\n            end if\n          else if (i <= size(A)) then\n            C(k) = A(i)\n            i = i + 1\n          else if (j <= size(B)) then\n            C(k) = B(j)\n            j = j + 1\n          end if\n        end do\n      end subroutine merge\n\n      subroutine swap(x, y)\n        implicit none\n        integer, intent(inout) :: x, y\n        integer :: tmp\n        tmp = x; x = y; y = tmp\n      end subroutine\n\n      recursive subroutine MergeSort(A, work)\n        implicit none\n        integer, intent(inout) :: A(:)\n        integer, intent(inout) :: work(:)\n        integer :: half\n        half = (size(A) + 1) / 2\n        if (size(A) < 2) then\n          continue\n        else if (size(A) == 2) then\n          if (A(1) > A(2)) then\n            call swap(A(1), A(2))\n          end if\n        else\n          call MergeSort(A( : half), work)\n          call MergeSort(A(half + 1 :), work)\n          if (A(half) > A(half + 1)) then\n            work(1 : half) = A(1 : half)\n            call merge(work(1 : half), A(half + 1:), A)\n          endif\n        end if\n      end subroutine MergeSort\n      end program TestMergeSort\n", "target": "import java.util.List;\nimport java.util.ArrayList;\nimport java.util.Iterator;\n\npublic class Merge{\n    public static <E extends Comparable<? super E>> List<E> mergeSort(List<E> m){\n        if(m.size() <= 1) return m;\n\n        int middle = m.size() / 2;\n        List<E> left = m.subList(0, middle);\n        List<E> right = m.subList(middle, m.size());\n\n        right = mergeSort(right);\n        left = mergeSort(left);\n        List<E> result = merge(left, right);\n\n        return result;\n    }\n\n    public static <E extends Comparable<? super E>> List<E> merge(List<E> left, List<E> right){\n        List<E> result = new ArrayList<E>();\n        Iterator<E> it1 = left.iterator();\n        Iterator<E> it2 = right.iterator();\n\n\tE x = it1.next();\n\tE y = it2.next();\n        while (true){\n            \n            if(x.compareTo(y) <= 0){\n\t\tresult.add(x);\n\t\tif(it1.hasNext()){\n\t\t    x = it1.next();\n\t\t}else{\n\t\t    result.add(y);\n\t\t    while(it2.hasNext()){\n\t\t\tresult.add(it2.next());\n\t\t    }\n\t\t    break;\n\t\t}\n\t    }else{\n\t\tresult.add(y);\n\t\tif(it2.hasNext()){\n\t\t    y = it2.next();\n\t\t}else{\n\t\t    result.add(x);\n\t\t    while (it1.hasNext()){\n\t\t\tresult.add(it1.next());\n\t\t    }\n\t\t    break;\n\t\t}\n\t    }\n        }\n        return result;\n    }\n}\n"}
{"id": 51891, "name": "Sorting algorithms_Merge sort", "source": "Translate Fortran to Python:       program TestMergeSort\n        implicit none\n        integer, parameter :: N = 8\n        integer :: A(N) = (/ 1, 5, 2, 7, 3, 9, 4, 6 /)\n        integer :: work((size(A) + 1) / 2)\n        write(*,'(A,/,10I3)')'Unsorted array\u00a0:',A\n        call MergeSort(A, work)\n        write(*,'(A,/,10I3)')'Sorted array\u00a0:',A\n      contains\n\n      subroutine merge(A, B, C)\n        implicit none\n\n        integer, target, intent(in) :: A(:), B(:)\n        integer, target, intent(inout) :: C(:)\n        integer :: i, j, k\n\n        if (size(A) + size(B) > size(C)) stop(1)\n\n        i = 1; j = 1\n        do k = 1, size(C)\n          if (i <= size(A) .and. j <= size(B)) then\n            if (A(i) <= B(j)) then\n              C(k) = A(i)\n              i = i + 1\n            else\n              C(k) = B(j)\n              j = j + 1\n            end if\n          else if (i <= size(A)) then\n            C(k) = A(i)\n            i = i + 1\n          else if (j <= size(B)) then\n            C(k) = B(j)\n            j = j + 1\n          end if\n        end do\n      end subroutine merge\n\n      subroutine swap(x, y)\n        implicit none\n        integer, intent(inout) :: x, y\n        integer :: tmp\n        tmp = x; x = y; y = tmp\n      end subroutine\n\n      recursive subroutine MergeSort(A, work)\n        implicit none\n        integer, intent(inout) :: A(:)\n        integer, intent(inout) :: work(:)\n        integer :: half\n        half = (size(A) + 1) / 2\n        if (size(A) < 2) then\n          continue\n        else if (size(A) == 2) then\n          if (A(1) > A(2)) then\n            call swap(A(1), A(2))\n          end if\n        else\n          call MergeSort(A( : half), work)\n          call MergeSort(A(half + 1 :), work)\n          if (A(half) > A(half + 1)) then\n            work(1 : half) = A(1 : half)\n            call merge(work(1 : half), A(half + 1:), A)\n          endif\n        end if\n      end subroutine MergeSort\n      end program TestMergeSort\n", "target": "fun mergesort(m):\n    if m.lenght <= 1: return m\n    let middle = floor m.lenght / 2\n    let left = merge(m[:middle])\n    let right = merge(m[middle-1:]);\n\nfun merge(left, right):\n    let result = []\n    while not (left.isempty or right.isempty):\n        if left[1] <= right[1]:\n            result.push! left.shift!()\n        else:\n            result.push! right.shift!()\n    result.push! left.push! right\n\nlet arr = [7, 6, 5, 9, 8, 4, 3, 1, 2, 0]\nprint mergesort arr\n"}
{"id": 52921, "name": "Ascending primes", "source": "Translate Fortran to C#: \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    \nprogram prog\n\n    parameter (MAXSIZE = 1000)\n    \n    logical isprime\n    dimension iqueue(MAXSIZE)\n    dimension iprimes(MAXSIZE)\n    \n    ibegin = 1\n    iend = 1\n    n = 0\n\n    do k = 1, 9\n        iqueue(iend) = k\n        iend = iend + 1\n    end do\n    \n    do while (ibegin .lt. iend)\n        iv = iqueue(ibegin)\n        ibegin = ibegin + 1\n        if (isprime(iv)) then\n            n = n + 1\n            iprimes(n) = iv\n        end if\n        lsd1 = mod(iv, 10) + 1\n        if (lsd1 .le. 9) then\n            do k = lsd1, 9\n                iqueue(iend) = iv * 10 + k\n                iend = iend + 1\n            end do\n        end if\n    end do\n\n    print *, (iprimes(i), i = 1, n)\n\nend program\n\n\nlogical function isprime(n)\n    \n\n\n\n\n\n\n\n\n\n    isprime = .FALSE.\n    if (n .eq. 0 .or. n .eq. 1) then\n        return\n    end if\n    if (n .ne. 2) then\n        if (mod(n, 2) .eq. 0) then\n            return\n        end if\n        m = n**0.5\n        do k = 3, m, 2\n            if (mod(n, k) .eq. 0) then\n                return\n            end if\n        end do\n    end if\n    isprime = .TRUE.\nend function\n", "target": "using System;\nusing System.Collections.Generic;\n\nnamespace ascendingprimes\n{\n    class Program\n    {\n        static bool isPrime(uint n)\n        {\n            if (n == 2)\n                return true;\n            if (n == 1 || n % 2 = 0)\n                return false;\n            uint root = (uint)Math.Sqrt(n);\n            for (uint k = 3; k <= root; k += 2)\n                if (n % k == 0)\n                    return false;\n            return true;\n        }\n        static void Main(string[] args)\n        {\n            var queue = new Queue<uint>();\n            var primes = new List<uint>();\n\n            for (uint k = 1; k <= 9; k++)\n                queue.Enqueue(k);\n            while(queue.Count > 0)\n            {\n                uint n = queue.Dequeue();\n                if (isPrime(n))\n                    primes.Add(n);\n                for (uint k = n % 10 + 1; k <= 9; k++)\n                    queue.Enqueue(n * 10 + k);\n            }\n\n            foreach (uint p in primes)\n            {\n                Console.Write(p);\n                Console.Write(\" \");\n            }\n            Console.WriteLine();\n        }\n    }\n}\n"}
{"id": 52922, "name": "Ascending primes", "source": "Translate Fortran to C#: \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    \nprogram prog\n\n    parameter (MAXSIZE = 1000)\n    \n    logical isprime\n    dimension iqueue(MAXSIZE)\n    dimension iprimes(MAXSIZE)\n    \n    ibegin = 1\n    iend = 1\n    n = 0\n\n    do k = 1, 9\n        iqueue(iend) = k\n        iend = iend + 1\n    end do\n    \n    do while (ibegin .lt. iend)\n        iv = iqueue(ibegin)\n        ibegin = ibegin + 1\n        if (isprime(iv)) then\n            n = n + 1\n            iprimes(n) = iv\n        end if\n        lsd1 = mod(iv, 10) + 1\n        if (lsd1 .le. 9) then\n            do k = lsd1, 9\n                iqueue(iend) = iv * 10 + k\n                iend = iend + 1\n            end do\n        end if\n    end do\n\n    print *, (iprimes(i), i = 1, n)\n\nend program\n\n\nlogical function isprime(n)\n    \n\n\n\n\n\n\n\n\n\n    isprime = .FALSE.\n    if (n .eq. 0 .or. n .eq. 1) then\n        return\n    end if\n    if (n .ne. 2) then\n        if (mod(n, 2) .eq. 0) then\n            return\n        end if\n        m = n**0.5\n        do k = 3, m, 2\n            if (mod(n, k) .eq. 0) then\n                return\n            end if\n        end do\n    end if\n    isprime = .TRUE.\nend function\n", "target": "using System;\nusing System.Collections.Generic;\n\nnamespace ascendingprimes\n{\n    class Program\n    {\n        static bool isPrime(uint n)\n        {\n            if (n == 2)\n                return true;\n            if (n == 1 || n % 2 = 0)\n                return false;\n            uint root = (uint)Math.Sqrt(n);\n            for (uint k = 3; k <= root; k += 2)\n                if (n % k == 0)\n                    return false;\n            return true;\n        }\n        static void Main(string[] args)\n        {\n            var queue = new Queue<uint>();\n            var primes = new List<uint>();\n\n            for (uint k = 1; k <= 9; k++)\n                queue.Enqueue(k);\n            while(queue.Count > 0)\n            {\n                uint n = queue.Dequeue();\n                if (isPrime(n))\n                    primes.Add(n);\n                for (uint k = n % 10 + 1; k <= 9; k++)\n                    queue.Enqueue(n * 10 + k);\n            }\n\n            foreach (uint p in primes)\n            {\n                Console.Write(p);\n                Console.Write(\" \");\n            }\n            Console.WriteLine();\n        }\n    }\n}\n"}
{"id": 52929, "name": "Ascending primes", "source": "Translate Fortran to Java: \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    \nprogram prog\n\n    parameter (MAXSIZE = 1000)\n    \n    logical isprime\n    dimension iqueue(MAXSIZE)\n    dimension iprimes(MAXSIZE)\n    \n    ibegin = 1\n    iend = 1\n    n = 0\n\n    do k = 1, 9\n        iqueue(iend) = k\n        iend = iend + 1\n    end do\n    \n    do while (ibegin .lt. iend)\n        iv = iqueue(ibegin)\n        ibegin = ibegin + 1\n        if (isprime(iv)) then\n            n = n + 1\n            iprimes(n) = iv\n        end if\n        lsd1 = mod(iv, 10) + 1\n        if (lsd1 .le. 9) then\n            do k = lsd1, 9\n                iqueue(iend) = iv * 10 + k\n                iend = iend + 1\n            end do\n        end if\n    end do\n\n    print *, (iprimes(i), i = 1, n)\n\nend program\n\n\nlogical function isprime(n)\n    \n\n\n\n\n\n\n\n\n\n    isprime = .FALSE.\n    if (n .eq. 0 .or. n .eq. 1) then\n        return\n    end if\n    if (n .ne. 2) then\n        if (mod(n, 2) .eq. 0) then\n            return\n        end if\n        m = n**0.5\n        do k = 3, m, 2\n            if (mod(n, k) .eq. 0) then\n                return\n            end if\n        end do\n    end if\n    isprime = .TRUE.\nend function\n", "target": "\n\npackage example.rossetacode.ascendingprimes;\n\nimport java.util.Arrays;\n\npublic class Program implements Runnable {\n\n    public static void main(String[] args) {\n        long t1 = System.nanoTime();\n        new Program().run();\n        long t2 = System.nanoTime();\n        System.out.println(\n                \"total time consumed = \" + (t2 - t1) * 1E-6 + \" milliseconds\");\n    }\n\n    public void run() {\n\n        final int MAX_SIZE = 1000;\n        final int[] queue = new int[MAX_SIZE];\n        int begin = 0;\n        int end = 0;\n\n        for (int k = 1; k <= 9; k++) {\n            queue[end++] = k;\n        }\n\n        while (begin < end) {\n            int n = queue[begin++];\n            for (int k = n % 10 + 1; k <= 9; k++) {\n                queue[end++] = n * 10 + k;\n            }\n        }\n\n        \n        \n        \n        System.out.println(Arrays.stream(queue).filter(this::isPrime).boxed().toList());\n    }\n\n    private boolean isPrime(int n) {\n        if (n == 2) {\n            return true;\n        }\n        if (n == 1 || n % 2 == 0) {\n            return false;\n        }\n        int root = (int) Math.sqrt(n);\n        for (int k = 3; k <= root; k += 2) {\n            if (n % k == 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\n"}
{"id": 52930, "name": "Ascending primes", "source": "Translate Fortran to Java: \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    \nprogram prog\n\n    parameter (MAXSIZE = 1000)\n    \n    logical isprime\n    dimension iqueue(MAXSIZE)\n    dimension iprimes(MAXSIZE)\n    \n    ibegin = 1\n    iend = 1\n    n = 0\n\n    do k = 1, 9\n        iqueue(iend) = k\n        iend = iend + 1\n    end do\n    \n    do while (ibegin .lt. iend)\n        iv = iqueue(ibegin)\n        ibegin = ibegin + 1\n        if (isprime(iv)) then\n            n = n + 1\n            iprimes(n) = iv\n        end if\n        lsd1 = mod(iv, 10) + 1\n        if (lsd1 .le. 9) then\n            do k = lsd1, 9\n                iqueue(iend) = iv * 10 + k\n                iend = iend + 1\n            end do\n        end if\n    end do\n\n    print *, (iprimes(i), i = 1, n)\n\nend program\n\n\nlogical function isprime(n)\n    \n\n\n\n\n\n\n\n\n\n    isprime = .FALSE.\n    if (n .eq. 0 .or. n .eq. 1) then\n        return\n    end if\n    if (n .ne. 2) then\n        if (mod(n, 2) .eq. 0) then\n            return\n        end if\n        m = n**0.5\n        do k = 3, m, 2\n            if (mod(n, k) .eq. 0) then\n                return\n            end if\n        end do\n    end if\n    isprime = .TRUE.\nend function\n", "target": "\n\npackage example.rossetacode.ascendingprimes;\n\nimport java.util.Arrays;\n\npublic class Program implements Runnable {\n\n    public static void main(String[] args) {\n        long t1 = System.nanoTime();\n        new Program().run();\n        long t2 = System.nanoTime();\n        System.out.println(\n                \"total time consumed = \" + (t2 - t1) * 1E-6 + \" milliseconds\");\n    }\n\n    public void run() {\n\n        final int MAX_SIZE = 1000;\n        final int[] queue = new int[MAX_SIZE];\n        int begin = 0;\n        int end = 0;\n\n        for (int k = 1; k <= 9; k++) {\n            queue[end++] = k;\n        }\n\n        while (begin < end) {\n            int n = queue[begin++];\n            for (int k = n % 10 + 1; k <= 9; k++) {\n                queue[end++] = n * 10 + k;\n            }\n        }\n\n        \n        \n        \n        System.out.println(Arrays.stream(queue).filter(this::isPrime).boxed().toList());\n    }\n\n    private boolean isPrime(int n) {\n        if (n == 2) {\n            return true;\n        }\n        if (n == 1 || n % 2 == 0) {\n            return false;\n        }\n        int root = (int) Math.sqrt(n);\n        for (int k = 3; k <= root; k += 2) {\n            if (n % k == 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\n"}
{"id": 52931, "name": "Ascending primes", "source": "Translate Fortran to Python: \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    \nprogram prog\n\n    parameter (MAXSIZE = 1000)\n    \n    logical isprime\n    dimension iqueue(MAXSIZE)\n    dimension iprimes(MAXSIZE)\n    \n    ibegin = 1\n    iend = 1\n    n = 0\n\n    do k = 1, 9\n        iqueue(iend) = k\n        iend = iend + 1\n    end do\n    \n    do while (ibegin .lt. iend)\n        iv = iqueue(ibegin)\n        ibegin = ibegin + 1\n        if (isprime(iv)) then\n            n = n + 1\n            iprimes(n) = iv\n        end if\n        lsd1 = mod(iv, 10) + 1\n        if (lsd1 .le. 9) then\n            do k = lsd1, 9\n                iqueue(iend) = iv * 10 + k\n                iend = iend + 1\n            end do\n        end if\n    end do\n\n    print *, (iprimes(i), i = 1, n)\n\nend program\n\n\nlogical function isprime(n)\n    \n\n\n\n\n\n\n\n\n\n    isprime = .FALSE.\n    if (n .eq. 0 .or. n .eq. 1) then\n        return\n    end if\n    if (n .ne. 2) then\n        if (mod(n, 2) .eq. 0) then\n            return\n        end if\n        m = n**0.5\n        do k = 3, m, 2\n            if (mod(n, k) .eq. 0) then\n                return\n            end if\n        end do\n    end if\n    isprime = .TRUE.\nend function\n", "target": "from sympy import isprime\n\ndef ascending(x=0):\n    for y in range(x*10 + (x%10) + 1, x*10 + 10):\n        yield from ascending(y)\n        yield(y)\n\nprint(sorted(x for x in ascending() if isprime(x)))\n"}
{"id": 52932, "name": "Ascending primes", "source": "Translate Fortran to Python: \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    \nprogram prog\n\n    parameter (MAXSIZE = 1000)\n    \n    logical isprime\n    dimension iqueue(MAXSIZE)\n    dimension iprimes(MAXSIZE)\n    \n    ibegin = 1\n    iend = 1\n    n = 0\n\n    do k = 1, 9\n        iqueue(iend) = k\n        iend = iend + 1\n    end do\n    \n    do while (ibegin .lt. iend)\n        iv = iqueue(ibegin)\n        ibegin = ibegin + 1\n        if (isprime(iv)) then\n            n = n + 1\n            iprimes(n) = iv\n        end if\n        lsd1 = mod(iv, 10) + 1\n        if (lsd1 .le. 9) then\n            do k = lsd1, 9\n                iqueue(iend) = iv * 10 + k\n                iend = iend + 1\n            end do\n        end if\n    end do\n\n    print *, (iprimes(i), i = 1, n)\n\nend program\n\n\nlogical function isprime(n)\n    \n\n\n\n\n\n\n\n\n\n    isprime = .FALSE.\n    if (n .eq. 0 .or. n .eq. 1) then\n        return\n    end if\n    if (n .ne. 2) then\n        if (mod(n, 2) .eq. 0) then\n            return\n        end if\n        m = n**0.5\n        do k = 3, m, 2\n            if (mod(n, k) .eq. 0) then\n                return\n            end if\n        end do\n    end if\n    isprime = .TRUE.\nend function\n", "target": "from sympy import isprime\n\ndef ascending(x=0):\n    for y in range(x*10 + (x%10) + 1, x*10 + 10):\n        yield from ascending(y)\n        yield(y)\n\nprint(sorted(x for x in ascending() if isprime(x)))\n"}
{"id": 53148, "name": "Tic-tac-toe", "source": "Translate Fortran to C#: \n\n\n\n\n\n\n\nmodule tic\n   implicit none\n   integer :: b(9)\ncontains\n   logical function iswin(p)\n      integer,intent(in) :: p\n      iswin = &\n         all(b([1,2,3])==p).or.all(b([4,5,6])==p).or.all(b([7,8,9])==p).or.&\n         all(b([1,4,7])==p).or.all(b([2,5,8])==p).or.all(b([3,6,9])==p).or.&\n         all(b([1,5,9])==p).or.all(b([3,5,7])==p)\n   end function iswin\n   subroutine printb(mes)\n      character(len=*) :: mes\n      integer          :: i,j\n      character        :: s(0:2) = ['.','X','O']\n      print \"(3a3,'   ',3i3)\",(s(b(3*i+1:3*i+3)),(j,j=3*i+1,3*i+3),i=0,2)\n      if(mes /= ' ') print \"(/,a)\",mes\n   end subroutine printb\n   integer recursive function minmax(player,bestm) result(bestv)\n      integer :: player,bestm,move,v,bm,win=1000,inf=100000\n      real    :: x\n      if (all(b .ne. 0)) then\n         bestv = 0\n      else\n         bestv = -inf\n         do move=1,9\n            if (b(move) == 0) then\n               b(move) = player\n               if (iswin(player)) then\n                  v = win\n               else\n                  call random_number(x)\n                  v = -minmax(3-player,bm) - int(10*x)\n               endif\n               if (v > bestv) then\n                  bestv = v\n                  bestm = move\n               endif\n               b(move) = 0\n               if (v == win) exit\n            endif\n         enddo\n      endif\n   end function minmax\nend module tic\nprogram tictactoe\n   \n   use tic\n   implicit none \n   integer :: move,ios,v,bestmove,ply,player=2,k,values(8)\n   integer,allocatable :: seed(:)\n   call date_and_time(values=values)\n   call random_seed(size=k)\n   allocate(seed(k))\n   seed = values(8)+1000*values(7)+60*1000*values(6)+60*60*1000*values(5)\n   call random_seed(put=seed)\n   mainloop: do\n      b = 0\n      call printb('You have O, I have X. You enter 0: game ends.')\n      plyloop: do ply=0,4\n         if (player == 2 .or. ply >0 ) then  \n            write(*,\"(/,a)\",advance='no'),'Your move? (0..9) '\n            getloop: do\n               readloop: do\n                  read (*,*,iostat=ios),move\n                  if (ios == 0 .and. move  >= 0 .and. move <= 9) exit readloop\n                  write(*,\"(a)\",advance='no'),'huh? Try again (0..9): '\n               enddo readloop\n               if (  move  == 0) exit mainloop\n               if (b(move) == 0) exit getloop\n               write(*,\"(a)\",advance='no'),'Already occupied, again (0..9): '\n            enddo getloop\n            b(move) = 2\n            if(iswin(2)) then   \n               call printb('***** You win *****')\n               exit plyloop\n            endif\n         endif\n         v = minmax(1,bestmove)   \n         b(bestmove) = 1\n         if(iswin(1)) then\n            call printb('***** I win *****')\n            exit plyloop\n         endif\n         write(*,\"(/,a,i3)\"), 'My move: ',bestmove\n         call printb(' ')\n      enddo plyloop\n      if(ply == 5) write(*,\"('***** Draw *****',/)\")\n      player = 3-player\n   enddo mainloop\nend program\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\nnamespace RosettaTicTacToe\n{\n  class Program\n  {\n\n    \n    static string[][] Players = new string[][] { \n      new string[] { \"COMPUTER\", \"X\" }, \n      new string[] { \"HUMAN\", \"O\" }     \n    };\n\n    const int Unplayed = -1;\n    const int Computer = 0;\n    const int Human = 1;\n\n    \n    static int[] GameBoard = new int[9];\n\n    static int[] corners = new int[] { 0, 2, 6, 8 };\n\n    static int[][] wins = new int[][] { \n      new int[] { 0, 1, 2 }, new int[] { 3, 4, 5 }, new int[] { 6, 7, 8 }, \n      new int[] { 0, 3, 6 }, new int[] { 1, 4, 7 }, new int[] { 2, 5, 8 }, \n      new int[] { 0, 4, 8 }, new int[] { 2, 4, 6 } };\n\n\n    \n    static void Main(string[] args)\n    {\n      while (true)\n      {\n        Console.Clear();\n        Console.WriteLine(\"Welcome to Rosetta Code Tic-Tac-Toe for C#.\");\n        initializeGameBoard();\n        displayGameBoard();\n        int currentPlayer = rnd.Next(0, 2);  \n        Console.WriteLine(\"The first move goes to {0} who is playing {1}s.\\n\", playerName(currentPlayer), playerToken(currentPlayer));\n        while (true)\n        {\n          int thisMove = getMoveFor(currentPlayer);\n          if (thisMove == Unplayed)\n          {\n            Console.WriteLine(\"{0}, you've quit the game ... am I that good?\", playerName(currentPlayer));\n            break;\n          }\n          playMove(thisMove, currentPlayer);\n          displayGameBoard();\n          if (isGameWon())\n          {\n            Console.WriteLine(\"{0} has won the game!\", playerName(currentPlayer));\n            break;\n          }\n          else if (isGameTied())\n          {\n            Console.WriteLine(\"Cat game ... we have a tie.\");\n            break;\n          }\n          currentPlayer = getNextPlayer(currentPlayer);\n        }\n        if (!playAgain())\n          return;\n      }\n    }\n\n    \n    static int getMoveFor(int player)\n    {\n      if (player == Human)\n        return getManualMove(player);\n      else\n      {\n        \n        \n        int selectedMove = getSemiRandomMove(player);\n        \n        Console.WriteLine(\"{0} selects position {1}.\", playerName(player), selectedMove + 1);\n        return selectedMove;\n      }\n    }\n\n    static int getManualMove(int player)\n    {\n      while (true)\n      {\n        Console.Write(\"{0}, enter you move (number): \", playerName(player));\n        ConsoleKeyInfo keyInfo = Console.ReadKey();\n        Console.WriteLine();  \n        if (keyInfo.Key == ConsoleKey.Escape)\n          return Unplayed;\n        if (keyInfo.Key >= ConsoleKey.D1 && keyInfo.Key <= ConsoleKey.D9)\n        {\n          int move = keyInfo.KeyChar - '1';  \n          if (GameBoard[move] == Unplayed)\n            return move;\n          else\n            Console.WriteLine(\"Spot {0} is already taken, please select again.\", move + 1);\n        }\n        else\n          Console.WriteLine(\"Illegal move, please select again.\\n\");\n      }\n    }\n\n    static int getRandomMove(int player)\n    {\n      int movesLeft = GameBoard.Count(position => position == Unplayed);\n      int x = rnd.Next(0, movesLeft);\n      for (int i = 0; i < GameBoard.Length; i++)  \n      {\n        if (GameBoard[i] == Unplayed && x < 0)    \n          return i;\n        x--;\n      }\n      return Unplayed;\n    }\n\n    \n    static int getSemiRandomMove(int player)\n    {\n      int posToPlay;\n      if (checkForWinningMove(player, out posToPlay))\n        return posToPlay;\n      if (checkForBlockingMove(player, out posToPlay))\n        return posToPlay;\n      return getRandomMove(player);\n    }\n\n    \n    static int getBestMove(int player)\n    {\n      return -1;\n    }\n\n    static bool checkForWinningMove(int player, out int posToPlay)\n    {\n      posToPlay = Unplayed;\n      foreach (var line in wins)\n        if (twoOfThreeMatchPlayer(player, line, out posToPlay))\n          return true;\n      return false;\n    }\n\n    static bool checkForBlockingMove(int player, out int posToPlay)\n    {\n      posToPlay = Unplayed;\n      foreach (var line in wins)\n        if (twoOfThreeMatchPlayer(getNextPlayer(player), line, out posToPlay))\n          return true;\n      return false;\n    }\n\n    static bool twoOfThreeMatchPlayer(int player, int[] line, out int posToPlay)\n    {\n      int cnt = 0;\n      posToPlay = int.MinValue;\n      foreach (int pos in line)\n      {\n        if (GameBoard[pos] == player)\n          cnt++;\n        else if (GameBoard[pos] == Unplayed)\n          posToPlay = pos;\n      }\n      return cnt == 2 && posToPlay >= 0;\n    }\n\n    static void playMove(int boardPosition, int player)\n    {\n      GameBoard[boardPosition] = player;\n    }\n\n    static bool isGameWon()\n    {\n      return wins.Any(line => takenBySamePlayer(line[0], line[1], line[2]));\n    }\n\n    static bool takenBySamePlayer(int a, int b, int c)\n    {\n      return GameBoard[a] != Unplayed && GameBoard[a] == GameBoard[b] && GameBoard[a] == GameBoard[c];\n    }\n\n    static bool isGameTied()\n    {\n      return !GameBoard.Any(spot => spot == Unplayed);\n    }\n\n    \n    static Random rnd = new Random();\n\n    static void initializeGameBoard()\n    {\n      for (int i = 0; i < GameBoard.Length; i++)\n        GameBoard[i] = Unplayed;\n    }\n\n    static string playerName(int player)\n    {\n      return Players[player][0];\n    }\n\n    static string playerToken(int player)\n    {\n      return Players[player][1];\n    }\n\n    static int getNextPlayer(int player)\n    {\n      return (player + 1) % 2;\n    }\n\n    static void displayGameBoard()\n    {\n      Console.WriteLine(\" {0} | {1} | {2}\", pieceAt(0), pieceAt(1), pieceAt(2));\n      Console.WriteLine(\"---|---|---\");\n      Console.WriteLine(\" {0} | {1} | {2}\", pieceAt(3), pieceAt(4), pieceAt(5));\n      Console.WriteLine(\"---|---|---\");\n      Console.WriteLine(\" {0} | {1} | {2}\", pieceAt(6), pieceAt(7), pieceAt(8));\n      Console.WriteLine();\n    }\n\n    static string pieceAt(int boardPosition)\n    {\n      if (GameBoard[boardPosition] == Unplayed)\n        return (boardPosition + 1).ToString();  \n      return playerToken(GameBoard[boardPosition]);\n    }\n\n    private static bool playAgain()\n    {\n      Console.WriteLine(\"\\nDo you want to play again?\");\n      return Console.ReadKey(false).Key == ConsoleKey.Y;\n    }\n  }\n\n}\n"}
{"id": 53152, "name": "Tic-tac-toe", "source": "Translate Fortran to Python: \n\n\n\n\n\n\n\nmodule tic\n   implicit none\n   integer :: b(9)\ncontains\n   logical function iswin(p)\n      integer,intent(in) :: p\n      iswin = &\n         all(b([1,2,3])==p).or.all(b([4,5,6])==p).or.all(b([7,8,9])==p).or.&\n         all(b([1,4,7])==p).or.all(b([2,5,8])==p).or.all(b([3,6,9])==p).or.&\n         all(b([1,5,9])==p).or.all(b([3,5,7])==p)\n   end function iswin\n   subroutine printb(mes)\n      character(len=*) :: mes\n      integer          :: i,j\n      character        :: s(0:2) = ['.','X','O']\n      print \"(3a3,'   ',3i3)\",(s(b(3*i+1:3*i+3)),(j,j=3*i+1,3*i+3),i=0,2)\n      if(mes /= ' ') print \"(/,a)\",mes\n   end subroutine printb\n   integer recursive function minmax(player,bestm) result(bestv)\n      integer :: player,bestm,move,v,bm,win=1000,inf=100000\n      real    :: x\n      if (all(b .ne. 0)) then\n         bestv = 0\n      else\n         bestv = -inf\n         do move=1,9\n            if (b(move) == 0) then\n               b(move) = player\n               if (iswin(player)) then\n                  v = win\n               else\n                  call random_number(x)\n                  v = -minmax(3-player,bm) - int(10*x)\n               endif\n               if (v > bestv) then\n                  bestv = v\n                  bestm = move\n               endif\n               b(move) = 0\n               if (v == win) exit\n            endif\n         enddo\n      endif\n   end function minmax\nend module tic\nprogram tictactoe\n   \n   use tic\n   implicit none \n   integer :: move,ios,v,bestmove,ply,player=2,k,values(8)\n   integer,allocatable :: seed(:)\n   call date_and_time(values=values)\n   call random_seed(size=k)\n   allocate(seed(k))\n   seed = values(8)+1000*values(7)+60*1000*values(6)+60*60*1000*values(5)\n   call random_seed(put=seed)\n   mainloop: do\n      b = 0\n      call printb('You have O, I have X. You enter 0: game ends.')\n      plyloop: do ply=0,4\n         if (player == 2 .or. ply >0 ) then  \n            write(*,\"(/,a)\",advance='no'),'Your move? (0..9) '\n            getloop: do\n               readloop: do\n                  read (*,*,iostat=ios),move\n                  if (ios == 0 .and. move  >= 0 .and. move <= 9) exit readloop\n                  write(*,\"(a)\",advance='no'),'huh? Try again (0..9): '\n               enddo readloop\n               if (  move  == 0) exit mainloop\n               if (b(move) == 0) exit getloop\n               write(*,\"(a)\",advance='no'),'Already occupied, again (0..9): '\n            enddo getloop\n            b(move) = 2\n            if(iswin(2)) then   \n               call printb('***** You win *****')\n               exit plyloop\n            endif\n         endif\n         v = minmax(1,bestmove)   \n         b(bestmove) = 1\n         if(iswin(1)) then\n            call printb('***** I win *****')\n            exit plyloop\n         endif\n         write(*,\"(/,a,i3)\"), 'My move: ',bestmove\n         call printb(' ')\n      enddo plyloop\n      if(ply == 5) write(*,\"('***** Draw *****',/)\")\n      player = 3-player\n   enddo mainloop\nend program\n", "target": "\n\nimport random\n\nboard = list('123456789')\nwins = ((0,1,2), (3,4,5), (6,7,8),\n        (0,3,6), (1,4,7), (2,5,8),\n        (0,4,8), (2,4,6))\n\ndef printboard():\n    print('\\n'.join(' '.join(board[x:x+3]) for x in(0,3,6)))\n\ndef score():\n    for w in wins:\n        b = board[w[0]]\n        if b in 'XO' and all (board[i] == b for i in w):\n            return b, [i+1 for i in w]\n    return None, None\n\ndef finished():\n    return all (b in 'XO' for b in board)\n\ndef space():\n    return [ b for b in board if b not in 'XO']\n\ndef my_turn(xo):\n    options = space()\n    choice = random.choice(options)\n    board[int(choice)-1] = xo\n    return choice\n\ndef your_turn(xo):\n    options = space()\n    while True:\n        choice = input(\" Put your %s in any of these positions: %s \"\n                       % (xo, ''.join(options))).strip()\n        if choice in options:\n            break\n        print( \"Whoops I don't understand the input\" )\n    board[int(choice)-1] = xo\n    return choice\n\ndef me(xo='X'):\n    printboard()\n    print('I go at', my_turn(xo))\n    return score()\n    assert not s[0], \"\\n%s wins across %s\" % s\n\ndef you(xo='O'):\n    printboard()\n    \n    print('You went at', your_turn(xo))\n    return score()\n    assert not s[0], \"\\n%s wins across %s\" % s\n\n\nprint(__doc__)\nwhile not finished():\n    s = me('X')\n    if s[0]:\n        printboard()\n        print(\"\\n%s wins across %s\" % s)\n        break\n    if not finished():\n        s = you('O')\n        if s[0]:\n            printboard()\n            print(\"\\n%s wins across %s\" % s)\n            break\nelse:\n    print('\\nA draw')\n"}
{"id": 53368, "name": "Pick random element", "source": "Translate Fortran to C#: program pick_random\n  implicit none\n\n  integer :: i\n  integer :: a(10) = (/ (i, i = 1, 10) /)\n  real :: r\n\n  call random_seed\n  call random_number(r)\n  write(*,*) a(int(r*size(a)) + 1)\nend program\n", "target": "using System;\nusing System.Collections.Generic;\n\nclass RandomElementPicker {\n  static void Main() {\n    var list = new List<int>(new[]{0, 1, 2, 3, 4, 5, 6, 7, 8, 9});\n    var rng = new Random();\n    var randomElement = list[rng.Next(list.Count)];\n    Console.WriteLine(\"I picked element {0}\", randomElement);\n  }\n}\n"}
{"id": 53372, "name": "Pick random element", "source": "Translate Fortran to Java: program pick_random\n  implicit none\n\n  integer :: i\n  integer :: a(10) = (/ (i, i = 1, 10) /)\n  real :: r\n\n  call random_seed\n  call random_number(r)\n  write(*,*) a(int(r*size(a)) + 1)\nend program\n", "target": "import java.util.Random;\n...\nint[] array = {1,2,3};\nreturn array[new Random().nextInt(array.length)]; \n"}
{"id": 53373, "name": "Pick random element", "source": "Translate Fortran to Python: program pick_random\n  implicit none\n\n  integer :: i\n  integer :: a(10) = (/ (i, i = 1, 10) /)\n  real :: r\n\n  call random_seed\n  call random_number(r)\n  write(*,*) a(int(r*size(a)) + 1)\nend program\n", "target": ">>> import random\n>>> random.choice(['foo', 'bar', 'baz'])\n'baz'\n"}
{"id": 53637, "name": "Jensen's Device", "source": "Translate Fortran to C#:       FUNCTION SUM(I,LO,HI,TERM)\n        SUM = 0\n        DO I = LO,HI\n          SUM = SUM + TERM\n        END DO\n      END FUNCTION SUM\n      WRITE (6,*) SUM(I,1,100,1.0/I)\n      END\n", "target": "using System;\n\nclass JensensDevice\n{    \n    public static double Sum(ref int i, int lo, int hi, Func<double> term)\n    {\n        double temp = 0.0;\n        for (i = lo; i <= hi; i++)\n        {\n            temp += term();\n        }\n        return temp;\n    }\n\n    static void Main()\n    {\n        int i = 0;\n        Console.WriteLine(Sum(ref i, 1, 100, () => 1.0 / i));\n    }\n}\n"}
{"id": 53640, "name": "Jensen's Device", "source": "Translate Fortran to Java:       FUNCTION SUM(I,LO,HI,TERM)\n        SUM = 0\n        DO I = LO,HI\n          SUM = SUM + TERM\n        END DO\n      END FUNCTION SUM\n      WRITE (6,*) SUM(I,1,100,1.0/I)\n      END\n", "target": "import java.util.function.*;\nimport java.util.stream.*;\n\npublic class Jensen {\n    static double sum(int lo, int hi, IntToDoubleFunction f) {\n        return IntStream.rangeClosed(lo, hi).mapToDouble(f).sum();\n    }\n        \n    public static void main(String args[]) {\n        System.out.println(sum(1, 100, (i -> 1.0/i)));\n    }\n}\n"}
{"id": 53641, "name": "Jensen's Device", "source": "Translate Fortran to Python:       FUNCTION SUM(I,LO,HI,TERM)\n        SUM = 0\n        DO I = LO,HI\n          SUM = SUM + TERM\n        END DO\n      END FUNCTION SUM\n      WRITE (6,*) SUM(I,1,100,1.0/I)\n      END\n", "target": "class Ref(object):\n    def __init__(self, value=None):\n        self.value = value\n\ndef harmonic_sum(i, lo, hi, term):\n    \n    temp = 0\n    i.value = lo\n    while i.value <= hi:  \n        temp += term() \n        i.value += 1   \n    return temp\n\ni = Ref()\n\n\n\nprint harmonic_sum(i, 1, 100, lambda: 1.0/i.value)\n"}
{"id": 53901, "name": "Greatest element of a list", "source": "Translate Fortran to C#: program test_maxval\n \ninteger,dimension(5),parameter :: x = [10,100,7,1,2]\nreal,dimension(5),parameter :: y = [5.0,60.0,1.0,678.0,0.0]\n \nwrite(*,'(I5)') maxval(x)\nwrite(*,'(F5.1)') maxval(y)\n\nend program test_maxval\n", "target": "int[] values = new int[] {1,2,3,4,5,6,7,8,9,10};\n\nint max = values.Max();\n"}
{"id": 53905, "name": "Greatest element of a list", "source": "Translate Fortran to Java: program test_maxval\n \ninteger,dimension(5),parameter :: x = [10,100,7,1,2]\nreal,dimension(5),parameter :: y = [5.0,60.0,1.0,678.0,0.0]\n \nwrite(*,'(I5)') maxval(x)\nwrite(*,'(F5.1)') maxval(y)\n\nend program test_maxval\n", "target": "public static float max(float[] values) throws NoSuchElementException {\n    if (values.length == 0)\n        throw new NoSuchElementException();\n    float themax = values[0];\n    for (int idx = 1; idx < values.length; ++idx) {\n        if (values[idx] > themax)\n            themax = values[idx];\n    }\n    return themax;\n}\n"}
{"id": 53906, "name": "Greatest element of a list", "source": "Translate Fortran to Python: program test_maxval\n \ninteger,dimension(5),parameter :: x = [10,100,7,1,2]\nreal,dimension(5),parameter :: y = [5.0,60.0,1.0,678.0,0.0]\n \nwrite(*,'(I5)') maxval(x)\nwrite(*,'(F5.1)') maxval(y)\n\nend program test_maxval\n", "target": "max(values)\n"}
{"id": 54190, "name": "Discordian date", "source": "Translate Fortran to C#: program discordianDate\n    implicit none\n    \n    character(32) :: arg\n    character(15) :: season,day,holyday\n    character(80) :: Output,fmt1,fmt2,fmt3\n    character(2) :: dayfix,f1,f2,f3,f4\n    integer :: i,j,k,daysofyear,dayofweek,seasonnum,yold,dayofseason,t1,t2,t3\n    integer,dimension(8) :: values\n    integer, dimension(12) :: daysinmonth\n    logical  :: isleapyear, isholyday, Pleapyear\n     \n    \n    call date_and_time(VALUES=values)\n    \n    daysinmonth = (/ 31,28,31,30,31,30,31,31,30,31,30,31 /)\n    isleapyear = .false.\n    isholyday = .false.\n    \n    \n    j = iargc()\n    do i = 1, iargc()\n      call getarg(i, arg)  \n      if (j==3) then\n        if (i==1) then\n          read(arg,'(i2)') values(3)  \n        endif\n        if (i==2) then\n          read(arg,'(i2)') values(2)  \n        endif\n        if (i==3) then\n          read(arg,'(i4)') values(1)  \n \n        endif\n      endif\n      if (j==2) then  \n        if (i==1) then\n          read(arg,'(i2)') values(3)  \n        endif\n        if (i==2) then\n          read(arg,'(i2)') values(2)  \n        endif\n      endif\n      if (j==1) then \n        read(arg,'(i2)') values(3)  \n      endif\n    end do\n \n    \n\n    yold = values(1) + 1166\n    daysofyear = 0\n    if (values(2)>1) then \n    do i=1 , values(2)-1 , 1\n        daysofyear = daysofyear + daysinmonth(i)\n     end do\n   end if\n    daysofyear = daysofyear + values(3)\n    isholyday = .false.\n    isleapyear = Pleapyear(yold)\n    dayofweek = mod (daysofyear, 5)\n    seasonnum = ((daysofyear - 1) / 73) + 1 \n    dayofseason = daysofyear - ((seasonnum - 1)  * 73)\n    k = mod(dayofseason,10)  \n    select case (k)\n      case (1)\n         dayfix='st'\n      case (2)\n         dayfix='nd'\n      case (3)\n         dayfix='rd'\n      case default\n         dayfix='th'\n    end select\n    \n    if (((dayofseason > 10) .and. (dayofseason < 20)) .eqv. .true.) then\n      dayfix = 'th'\n    end if\n    select case (Seasonnum)\n      case (1) \n        season ='Choas'\n        f4 = '5'\n      case (2) \n        season ='Discord'\n        f4 = '7'\n      case (3) \n        season ='Confusion'\n        f4 = '9'\n      case (4) \n        season ='Bureaucracy'\n        f4 = '10'\n      case (5) \n        season ='The Aftermath'\n        f4 = '13'\n    end select\n    select case (dayofweek)\n       case (0) \n         day='Setting Orange'\n         f2 = '14'\n       case (1) \n         day ='Sweetmorn'\n         f2 = '9'\n       case (2) \n         day = 'Boomtime'\n         f2 = '8'\n       case (3) \n         day = 'Pungenday'\n         f2 = '9'\n       case (4) \n         day = 'Prickle-Prickle'\n         f2 = '15'\n    end select\n    \n    select case (dayofseason)\n      case (5)\n        isholyday = .true.\n        select case (seasonnum)\n          case (1)\n             holyday ='Mungday'\n             f1 = '7'\n          case (2)\n             holyday = 'Mojoday'\n             f1 = '7'\n          case (3)\n            holyday = 'Syaday'\n            f1 = '6'\n          case (4)\n             holyday = 'Zaraday'\n             f1 = '7'\n          case (5)\n            holyday = 'Maladay'\n            f1 = '7'\n         end select\n      Case (50)\n        isholyday = .true.\n        select case (seasonnum)\n          case (1)\n            holyday = 'Chaoflux'\n            f1 = '8'\n          case (2)\n            holyday = 'Discoflux'\n            f1 = '9'\n          case (3)\n            holyday = 'Confuflux'\n            f1 = '9'\n          case (4)\n            holyday = 'Bureflux'\n            f1 = '8'\n          case (5)\n            holyday = 'Afflux'\n            f1 = '6'\n         end select\n    end select\n    \n\n    \n    if (isleapyear .eqv. .true.) then \n      if ((values(2) == 2) .and. (values(3) == 29)) then\n         isholyday = .true.\n      end if\n    end if\n    \n    f3 = \"2\"\n    if (dayofseason < 10) then\n      f3 = \"1\"\n    end if\n    fmt1 = \"(a,i4)\"\n    fmt2 = \"(A,a\" // f1 // \",A,A\" // f2 // \",A,I\" // f3 // \",A2,A,A\" // f4 // \",A,I4)\"\n    fmt3 = \"(A,A\" // f2 // \",A,I\" // f3 //\",A2,A,A\" // f4 // \",A,I4)\"\n    \n    if (isholyday .eqv. .true.) then\n      if (values(3) == 29) then\n         print fmt1,'Celebrate for today is St. Tibbs Day in the YOLD ',yold\n       else\n         print fmt2, 'Today is ',holyday, ' on ',day,' the ',dayofseason,dayfix,' day of ',season,' in the YOLD ',yold \n       end if\n     else   \n         print fmt3, 'Today is ',day,' the ',dayofseason,dayfix, ' day of ',season,' in the YOLD ',yold\n     end if\n    end program discordianDate\n\n    \n\n    function Pleapyear(dloy) result(leaper)\n    implicit none\n    integer, intent(in) :: dloy\n    logical :: leaper\n    leaper = .false.\n    if (mod((dloy-1166),4) == 0)  then\n      leaper = .true.\n    end if\n    if (mod((dloy-1166),100) == 0) then\n        leaper = .false.\n        if (mod((dloy-1166),400)==0) then\n           leaper = .true.\n        end if\n    end if \n    end function Pleapyear\n", "target": "using System;\n\npublic static class DiscordianDate\n{\n    static readonly string[] seasons = { \"Chaos\", \"Discord\", \"Confusion\", \"Bureaucracy\", \"The Aftermath\" };\n    static readonly string[] weekdays = { \"Sweetmorn\", \"Boomtime\", \"Pungenday\", \"Prickle-Prickle\", \"Setting Orange\" };\n    static readonly string[] apostles = { \"Mungday\", \"Mojoday\", \"Syaday\", \"Zaraday\", \"Maladay\" };\n    static readonly string[] holidays = { \"Chaoflux\", \"Discoflux\", \"Confuflux\", \"Bureflux\", \"Afflux\" };\n    \n    public static string Discordian(this DateTime date) {\n        string yold = $\" in the YOLD {date.Year + 1166}.\";\n        int dayOfYear = date.DayOfYear;\n\n        if (DateTime.IsLeapYear(date.Year)) {\n            if (dayOfYear == 60) return \"St. Tib's day\" + yold;\n            else if (dayOfYear > 60) dayOfYear--;\n        }\n        dayOfYear--;\n\n        int seasonDay = dayOfYear % 73 + 1;\n        int seasonNr = dayOfYear / 73;\n        int weekdayNr = dayOfYear % 5;\n        string holyday = \"\";\n\n        if (seasonDay == 5)       holyday = $\" Celebrate {apostles[seasonNr]}!\";\n        else if (seasonDay == 50) holyday = $\" Celebrate {holidays[seasonNr]}!\";\n        return $\"{weekdays[weekdayNr]}, day {seasonDay} of {seasons[seasonNr]}{yold}{holyday}\";\n    }\n\n    public static void Main() {\n        foreach (var (day, month, year) in new [] {\n            (1, 1, 2010),\n            (5, 1, 2010),\n            (19, 2, 2011),\n            (28, 2, 2012),\n            (29, 2, 2012),\n            (1, 3, 2012),\n            (19, 3, 2013),\n            (3, 5, 2014),\n            (31, 5, 2015),\n            (22, 6, 2016),\n            (15, 7, 2016),\n            (12, 8, 2017),\n            (19, 9, 2018),\n            (26, 9, 2018),\n            (24, 10, 2019),\n            (8, 12, 2020),\n            (31, 12, 2020)\n        })\n        {\n            Console.WriteLine($\"{day:00}-{month:00}-{year:00} = {new DateTime(year, month, day).Discordian()}\");\n        }\n    }\n\n}\n"}
{"id": 54193, "name": "Discordian date", "source": "Translate Fortran to Java: program discordianDate\n    implicit none\n    \n    character(32) :: arg\n    character(15) :: season,day,holyday\n    character(80) :: Output,fmt1,fmt2,fmt3\n    character(2) :: dayfix,f1,f2,f3,f4\n    integer :: i,j,k,daysofyear,dayofweek,seasonnum,yold,dayofseason,t1,t2,t3\n    integer,dimension(8) :: values\n    integer, dimension(12) :: daysinmonth\n    logical  :: isleapyear, isholyday, Pleapyear\n     \n    \n    call date_and_time(VALUES=values)\n    \n    daysinmonth = (/ 31,28,31,30,31,30,31,31,30,31,30,31 /)\n    isleapyear = .false.\n    isholyday = .false.\n    \n    \n    j = iargc()\n    do i = 1, iargc()\n      call getarg(i, arg)  \n      if (j==3) then\n        if (i==1) then\n          read(arg,'(i2)') values(3)  \n        endif\n        if (i==2) then\n          read(arg,'(i2)') values(2)  \n        endif\n        if (i==3) then\n          read(arg,'(i4)') values(1)  \n \n        endif\n      endif\n      if (j==2) then  \n        if (i==1) then\n          read(arg,'(i2)') values(3)  \n        endif\n        if (i==2) then\n          read(arg,'(i2)') values(2)  \n        endif\n      endif\n      if (j==1) then \n        read(arg,'(i2)') values(3)  \n      endif\n    end do\n \n    \n\n    yold = values(1) + 1166\n    daysofyear = 0\n    if (values(2)>1) then \n    do i=1 , values(2)-1 , 1\n        daysofyear = daysofyear + daysinmonth(i)\n     end do\n   end if\n    daysofyear = daysofyear + values(3)\n    isholyday = .false.\n    isleapyear = Pleapyear(yold)\n    dayofweek = mod (daysofyear, 5)\n    seasonnum = ((daysofyear - 1) / 73) + 1 \n    dayofseason = daysofyear - ((seasonnum - 1)  * 73)\n    k = mod(dayofseason,10)  \n    select case (k)\n      case (1)\n         dayfix='st'\n      case (2)\n         dayfix='nd'\n      case (3)\n         dayfix='rd'\n      case default\n         dayfix='th'\n    end select\n    \n    if (((dayofseason > 10) .and. (dayofseason < 20)) .eqv. .true.) then\n      dayfix = 'th'\n    end if\n    select case (Seasonnum)\n      case (1) \n        season ='Choas'\n        f4 = '5'\n      case (2) \n        season ='Discord'\n        f4 = '7'\n      case (3) \n        season ='Confusion'\n        f4 = '9'\n      case (4) \n        season ='Bureaucracy'\n        f4 = '10'\n      case (5) \n        season ='The Aftermath'\n        f4 = '13'\n    end select\n    select case (dayofweek)\n       case (0) \n         day='Setting Orange'\n         f2 = '14'\n       case (1) \n         day ='Sweetmorn'\n         f2 = '9'\n       case (2) \n         day = 'Boomtime'\n         f2 = '8'\n       case (3) \n         day = 'Pungenday'\n         f2 = '9'\n       case (4) \n         day = 'Prickle-Prickle'\n         f2 = '15'\n    end select\n    \n    select case (dayofseason)\n      case (5)\n        isholyday = .true.\n        select case (seasonnum)\n          case (1)\n             holyday ='Mungday'\n             f1 = '7'\n          case (2)\n             holyday = 'Mojoday'\n             f1 = '7'\n          case (3)\n            holyday = 'Syaday'\n            f1 = '6'\n          case (4)\n             holyday = 'Zaraday'\n             f1 = '7'\n          case (5)\n            holyday = 'Maladay'\n            f1 = '7'\n         end select\n      Case (50)\n        isholyday = .true.\n        select case (seasonnum)\n          case (1)\n            holyday = 'Chaoflux'\n            f1 = '8'\n          case (2)\n            holyday = 'Discoflux'\n            f1 = '9'\n          case (3)\n            holyday = 'Confuflux'\n            f1 = '9'\n          case (4)\n            holyday = 'Bureflux'\n            f1 = '8'\n          case (5)\n            holyday = 'Afflux'\n            f1 = '6'\n         end select\n    end select\n    \n\n    \n    if (isleapyear .eqv. .true.) then \n      if ((values(2) == 2) .and. (values(3) == 29)) then\n         isholyday = .true.\n      end if\n    end if\n    \n    f3 = \"2\"\n    if (dayofseason < 10) then\n      f3 = \"1\"\n    end if\n    fmt1 = \"(a,i4)\"\n    fmt2 = \"(A,a\" // f1 // \",A,A\" // f2 // \",A,I\" // f3 // \",A2,A,A\" // f4 // \",A,I4)\"\n    fmt3 = \"(A,A\" // f2 // \",A,I\" // f3 //\",A2,A,A\" // f4 // \",A,I4)\"\n    \n    if (isholyday .eqv. .true.) then\n      if (values(3) == 29) then\n         print fmt1,'Celebrate for today is St. Tibbs Day in the YOLD ',yold\n       else\n         print fmt2, 'Today is ',holyday, ' on ',day,' the ',dayofseason,dayfix,' day of ',season,' in the YOLD ',yold \n       end if\n     else   \n         print fmt3, 'Today is ',day,' the ',dayofseason,dayfix, ' day of ',season,' in the YOLD ',yold\n     end if\n    end program discordianDate\n\n    \n\n    function Pleapyear(dloy) result(leaper)\n    implicit none\n    integer, intent(in) :: dloy\n    logical :: leaper\n    leaper = .false.\n    if (mod((dloy-1166),4) == 0)  then\n      leaper = .true.\n    end if\n    if (mod((dloy-1166),100) == 0) then\n        leaper = .false.\n        if (mod((dloy-1166),400)==0) then\n           leaper = .true.\n        end if\n    end if \n    end function Pleapyear\n", "target": "import java.util.Calendar;\nimport java.util.GregorianCalendar;\n\npublic class DiscordianDate {\n    final static String[] seasons = {\"Chaos\", \"Discord\", \"Confusion\",\n        \"Bureaucracy\", \"The Aftermath\"};\n\n    final static String[] weekday = {\"Sweetmorn\", \"Boomtime\", \"Pungenday\",\n        \"Prickle-Prickle\", \"Setting Orange\"};\n\n    final static String[] apostle = {\"Mungday\", \"Mojoday\", \"Syaday\",\n        \"Zaraday\", \"Maladay\"};\n\n    final static String[] holiday = {\"Chaoflux\", \"Discoflux\", \"Confuflux\",\n        \"Bureflux\", \"Afflux\"};\n\n    public static String discordianDate(final GregorianCalendar date) {\n        int y = date.get(Calendar.YEAR);\n        int yold = y + 1166;\n        int dayOfYear = date.get(Calendar.DAY_OF_YEAR);\n\n        if (date.isLeapYear(y)) {\n            if (dayOfYear == 60)\n                return \"St. Tib's Day, in the YOLD \" + yold;\n            else if (dayOfYear > 60)\n                dayOfYear--;\n        }\n\n        dayOfYear--;\n\n        int seasonDay = dayOfYear % 73 + 1;\n        if (seasonDay == 5)\n            return apostle[dayOfYear / 73] + \", in the YOLD \" + yold;\n        if (seasonDay == 50)\n            return holiday[dayOfYear / 73] + \", in the YOLD \" + yold;\n\n        String season = seasons[dayOfYear / 73];\n        String dayOfWeek = weekday[dayOfYear % 5];\n\n        return String.format(\"%s, day %s of %s in the YOLD %s\",\n                dayOfWeek, seasonDay, season, yold);\n    }\n\n    public static void main(String[] args) {\n\n        System.out.println(discordianDate(new GregorianCalendar()));\n\n        test(2010, 6, 22, \"Pungenday, day 57 of Confusion in the YOLD 3176\");\n        test(2012, 1, 28, \"Prickle-Prickle, day 59 of Chaos in the YOLD 3178\");\n        test(2012, 1, 29, \"St. Tib's Day, in the YOLD 3178\");\n        test(2012, 2, 1, \"Setting Orange, day 60 of Chaos in the YOLD 3178\");\n        test(2010, 0, 5, \"Mungday, in the YOLD 3176\");\n        test(2011, 4, 3, \"Discoflux, in the YOLD 3177\");\n        test(2015, 9, 19, \"Boomtime, day 73 of Bureaucracy in the YOLD 3181\");\n    }\n\n    private static void test(int y, int m, int d, final String result) {\n        assert (discordianDate(new GregorianCalendar(y, m, d)).equals(result));\n    }\n}\n"}
{"id": 54194, "name": "Discordian date", "source": "Translate Fortran to Python: program discordianDate\n    implicit none\n    \n    character(32) :: arg\n    character(15) :: season,day,holyday\n    character(80) :: Output,fmt1,fmt2,fmt3\n    character(2) :: dayfix,f1,f2,f3,f4\n    integer :: i,j,k,daysofyear,dayofweek,seasonnum,yold,dayofseason,t1,t2,t3\n    integer,dimension(8) :: values\n    integer, dimension(12) :: daysinmonth\n    logical  :: isleapyear, isholyday, Pleapyear\n     \n    \n    call date_and_time(VALUES=values)\n    \n    daysinmonth = (/ 31,28,31,30,31,30,31,31,30,31,30,31 /)\n    isleapyear = .false.\n    isholyday = .false.\n    \n    \n    j = iargc()\n    do i = 1, iargc()\n      call getarg(i, arg)  \n      if (j==3) then\n        if (i==1) then\n          read(arg,'(i2)') values(3)  \n        endif\n        if (i==2) then\n          read(arg,'(i2)') values(2)  \n        endif\n        if (i==3) then\n          read(arg,'(i4)') values(1)  \n \n        endif\n      endif\n      if (j==2) then  \n        if (i==1) then\n          read(arg,'(i2)') values(3)  \n        endif\n        if (i==2) then\n          read(arg,'(i2)') values(2)  \n        endif\n      endif\n      if (j==1) then \n        read(arg,'(i2)') values(3)  \n      endif\n    end do\n \n    \n\n    yold = values(1) + 1166\n    daysofyear = 0\n    if (values(2)>1) then \n    do i=1 , values(2)-1 , 1\n        daysofyear = daysofyear + daysinmonth(i)\n     end do\n   end if\n    daysofyear = daysofyear + values(3)\n    isholyday = .false.\n    isleapyear = Pleapyear(yold)\n    dayofweek = mod (daysofyear, 5)\n    seasonnum = ((daysofyear - 1) / 73) + 1 \n    dayofseason = daysofyear - ((seasonnum - 1)  * 73)\n    k = mod(dayofseason,10)  \n    select case (k)\n      case (1)\n         dayfix='st'\n      case (2)\n         dayfix='nd'\n      case (3)\n         dayfix='rd'\n      case default\n         dayfix='th'\n    end select\n    \n    if (((dayofseason > 10) .and. (dayofseason < 20)) .eqv. .true.) then\n      dayfix = 'th'\n    end if\n    select case (Seasonnum)\n      case (1) \n        season ='Choas'\n        f4 = '5'\n      case (2) \n        season ='Discord'\n        f4 = '7'\n      case (3) \n        season ='Confusion'\n        f4 = '9'\n      case (4) \n        season ='Bureaucracy'\n        f4 = '10'\n      case (5) \n        season ='The Aftermath'\n        f4 = '13'\n    end select\n    select case (dayofweek)\n       case (0) \n         day='Setting Orange'\n         f2 = '14'\n       case (1) \n         day ='Sweetmorn'\n         f2 = '9'\n       case (2) \n         day = 'Boomtime'\n         f2 = '8'\n       case (3) \n         day = 'Pungenday'\n         f2 = '9'\n       case (4) \n         day = 'Prickle-Prickle'\n         f2 = '15'\n    end select\n    \n    select case (dayofseason)\n      case (5)\n        isholyday = .true.\n        select case (seasonnum)\n          case (1)\n             holyday ='Mungday'\n             f1 = '7'\n          case (2)\n             holyday = 'Mojoday'\n             f1 = '7'\n          case (3)\n            holyday = 'Syaday'\n            f1 = '6'\n          case (4)\n             holyday = 'Zaraday'\n             f1 = '7'\n          case (5)\n            holyday = 'Maladay'\n            f1 = '7'\n         end select\n      Case (50)\n        isholyday = .true.\n        select case (seasonnum)\n          case (1)\n            holyday = 'Chaoflux'\n            f1 = '8'\n          case (2)\n            holyday = 'Discoflux'\n            f1 = '9'\n          case (3)\n            holyday = 'Confuflux'\n            f1 = '9'\n          case (4)\n            holyday = 'Bureflux'\n            f1 = '8'\n          case (5)\n            holyday = 'Afflux'\n            f1 = '6'\n         end select\n    end select\n    \n\n    \n    if (isleapyear .eqv. .true.) then \n      if ((values(2) == 2) .and. (values(3) == 29)) then\n         isholyday = .true.\n      end if\n    end if\n    \n    f3 = \"2\"\n    if (dayofseason < 10) then\n      f3 = \"1\"\n    end if\n    fmt1 = \"(a,i4)\"\n    fmt2 = \"(A,a\" // f1 // \",A,A\" // f2 // \",A,I\" // f3 // \",A2,A,A\" // f4 // \",A,I4)\"\n    fmt3 = \"(A,A\" // f2 // \",A,I\" // f3 //\",A2,A,A\" // f4 // \",A,I4)\"\n    \n    if (isholyday .eqv. .true.) then\n      if (values(3) == 29) then\n         print fmt1,'Celebrate for today is St. Tibbs Day in the YOLD ',yold\n       else\n         print fmt2, 'Today is ',holyday, ' on ',day,' the ',dayofseason,dayfix,' day of ',season,' in the YOLD ',yold \n       end if\n     else   \n         print fmt3, 'Today is ',day,' the ',dayofseason,dayfix, ' day of ',season,' in the YOLD ',yold\n     end if\n    end program discordianDate\n\n    \n\n    function Pleapyear(dloy) result(leaper)\n    implicit none\n    integer, intent(in) :: dloy\n    logical :: leaper\n    leaper = .false.\n    if (mod((dloy-1166),4) == 0)  then\n      leaper = .true.\n    end if\n    if (mod((dloy-1166),100) == 0) then\n        leaper = .false.\n        if (mod((dloy-1166),400)==0) then\n           leaper = .true.\n        end if\n    end if \n    end function Pleapyear\n", "target": "import datetime, calendar\n\nDISCORDIAN_SEASONS = [\"Chaos\", \"Discord\", \"Confusion\", \"Bureaucracy\", \"The Aftermath\"]\n\ndef ddate(year, month, day):\n    today = datetime.date(year, month, day)\n    is_leap_year = calendar.isleap(year)\n    if is_leap_year and month == 2 and day == 29:\n        return \"St. Tib's Day, YOLD \" + (year + 1166)\n    \n    day_of_year = today.timetuple().tm_yday - 1\n    \n    if is_leap_year and day_of_year >= 60:\n        day_of_year -= 1 \n    \n    season, dday = divmod(day_of_year, 73)\n    return \"%s %d, YOLD %d\" % (DISCORDIAN_SEASONS[season], dday + 1, year + 1166)\n"}
{"id": 54566, "name": "Binary digits", "source": "Translate Fortran to C#: \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nprogram bits\n  implicit none\n  integer, dimension(3) :: a\n  integer :: i\n  data a/5,50,9000/\n  do i = 1, 3\n    call s(a(i))\n  enddo\n\ncontains\n\n  subroutine s(a)\n    integer, intent(in) :: a\n    integer :: i\n    if (a .eq. 0) then\n      write(6,'(a)')'0'\n      return\n    endif\n    do i = 31, 0, -1\n      if (btest(a, i)) exit\n    enddo\n    do while (0 .lt. i)\n      if (btest(a, i)) then\n        write(6,'(a)',advance='no')'1'\n      else\n        write(6,'(a)',advance='no')'0'\n      endif\n      i = i-1\n    enddo\n    if (btest(a, i)) then\n      write(6,'(a)')'1'\n    else\n      write(6,'(a)')'0'\n    endif\n  end subroutine s\n\nend program bits\n", "target": "using System;\n\nclass Program\n{\n    static void Main()\n    {\n        foreach (var number in new[] { 5, 50, 9000 })\n        {\n            Console.WriteLine(Convert.ToString(number, 2));\n        }\n    }\n}\n"}
{"id": 54569, "name": "Binary digits", "source": "Translate Fortran to Java: \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nprogram bits\n  implicit none\n  integer, dimension(3) :: a\n  integer :: i\n  data a/5,50,9000/\n  do i = 1, 3\n    call s(a(i))\n  enddo\n\ncontains\n\n  subroutine s(a)\n    integer, intent(in) :: a\n    integer :: i\n    if (a .eq. 0) then\n      write(6,'(a)')'0'\n      return\n    endif\n    do i = 31, 0, -1\n      if (btest(a, i)) exit\n    enddo\n    do while (0 .lt. i)\n      if (btest(a, i)) then\n        write(6,'(a)',advance='no')'1'\n      else\n        write(6,'(a)',advance='no')'0'\n      endif\n      i = i-1\n    enddo\n    if (btest(a, i)) then\n      write(6,'(a)')'1'\n    else\n      write(6,'(a)')'0'\n    endif\n  end subroutine s\n\nend program bits\n", "target": "module BinaryDigits\n    {\n    @Inject Console console;\n    void run()\n        {\n        Int[] tests = [0, 1, 5, 50, 9000];\n\n        Int longestInt = tests.map(n -> n.estimateStringLength()).reduce(0, (max, len) -> max.maxOf(len));\n        Int longestBin = tests.map(n -> (64-n.leadingZeroCount).maxOf(1)).reduce(0, (max, len) -> max.maxOf(len));\n\n        function String(Int) num = n ->\n            {\n            Int indent = longestInt - n.estimateStringLength();\n            return $\"{' ' * indent}{n}\";\n            };\n\n        function String(Int) bin = n ->\n            {\n            Int index  = n.leadingZeroCount.minOf(63);\n            Int indent = index - (64 - longestBin);\n            val bits   = n.toBitArray()[index ..< 64];\n            return $\"{' ' * indent}{bits.toString().substring(2)}\";\n            };\n\n        for (Int test : tests)\n            {\n            console.print($\"The decimal value {num(test)} should produce an output of {bin(test)}\");\n            }\n        }\n    }\n"}
{"id": 54570, "name": "Binary digits", "source": "Translate Fortran to Python: \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nprogram bits\n  implicit none\n  integer, dimension(3) :: a\n  integer :: i\n  data a/5,50,9000/\n  do i = 1, 3\n    call s(a(i))\n  enddo\n\ncontains\n\n  subroutine s(a)\n    integer, intent(in) :: a\n    integer :: i\n    if (a .eq. 0) then\n      write(6,'(a)')'0'\n      return\n    endif\n    do i = 31, 0, -1\n      if (btest(a, i)) exit\n    enddo\n    do while (0 .lt. i)\n      if (btest(a, i)) then\n        write(6,'(a)',advance='no')'1'\n      else\n        write(6,'(a)',advance='no')'0'\n      endif\n      i = i-1\n    enddo\n    if (btest(a, i)) then\n      write(6,'(a)')'1'\n    else\n      write(6,'(a)')'0'\n    endif\n  end subroutine s\n\nend program bits\n", "target": ">>> for i in range(16): print('{0:b}'.format(i))\n\n0\n1\n10\n11\n100\n101\n110\n111\n1000\n1001\n1010\n1011\n1100\n1101\n1110\n1111\n"}
{"id": 55564, "name": "Find the intersection of two lines", "source": "Translate Fortran to C#: program intersect_two_lines\n  implicit none\n  \n  type point\n    real::x,y\n  end type point\n  \n  integer, parameter :: n = 4\n  type(point)        :: p(n)\n  \n  p(1)%x = 4; p(1)%y = 0; p(2)%x = 6;  p(2)%y = 10 \n  p(3)%x = 0; p(3)%y = 3; p(4)%x = 10; p(4)%y = 7  \n  \n  call intersect(p, n)\n  \n  contains\n  \n  subroutine intersect(p,m)\n  integer, intent(in)       :: m\n  type(point), intent(in)   :: p(m)\n  integer   :: i\n  real      :: a(2), b(2) \n  real      :: x, y       \n  real      :: dx,dy      \n  \n  do i = 1, 2\n    dx = p(2*i-1)%x - p(2*i)%x\n    dy = p(2*i-1)%y - p(2*i)%y\n    if( dx == 0.) then    \n        a(i) = 0.\n        b(i) = p(2*i-1)%y\n    else\n        a(i)= dy / dx\n        b(i) = p(2*i-1)%y - a(i)*p(2*i-1)%x\n    endif\n  enddo\n  \n  if( a(1) - a(2) == 0. ) then\n    write(*,*)\"lines are not intersecting\"\n    return\n  endif\n  \n  x = ( b(2) - b(1) ) / ( a(1) - a(2) )\n  y = a(1) * x + b(1)\n  write(*,*)x,y\n  end subroutine intersect\nend program intersect_two_lines\n", "target": "using System;\nusing System.Drawing;\npublic class Program\n{\n    static PointF FindIntersection(PointF s1, PointF e1, PointF s2, PointF e2) {\n        float a1 = e1.Y - s1.Y;\n        float b1 = s1.X - e1.X;\n        float c1 = a1 * s1.X + b1 * s1.Y;\n\n        float a2 = e2.Y - s2.Y;\n        float b2 = s2.X - e2.X;\n        float c2 = a2 * s2.X + b2 * s2.Y;\n\n        float delta = a1 * b2 - a2 * b1;\n        \n        return delta == 0 ? new PointF(float.NaN, float.NaN)\n            : new PointF((b2 * c1 - b1 * c2) / delta, (a1 * c2 - a2 * c1) / delta);\n    }\n\n    static void Main() {\n        Func<float, float, PointF> p = (x, y) => new PointF(x, y);\n        Console.WriteLine(FindIntersection(p(4f, 0f), p(6f, 10f), p(0f, 3f), p(10f, 7f)));\n        Console.WriteLine(FindIntersection(p(0f, 0f), p(1f, 1f), p(1f, 2f), p(4f, 5f)));\n    }\n}\n"}
{"id": 55565, "name": "Find the intersection of two lines", "source": "Translate Fortran to C#: program intersect_two_lines\n  implicit none\n  \n  type point\n    real::x,y\n  end type point\n  \n  integer, parameter :: n = 4\n  type(point)        :: p(n)\n  \n  p(1)%x = 4; p(1)%y = 0; p(2)%x = 6;  p(2)%y = 10 \n  p(3)%x = 0; p(3)%y = 3; p(4)%x = 10; p(4)%y = 7  \n  \n  call intersect(p, n)\n  \n  contains\n  \n  subroutine intersect(p,m)\n  integer, intent(in)       :: m\n  type(point), intent(in)   :: p(m)\n  integer   :: i\n  real      :: a(2), b(2) \n  real      :: x, y       \n  real      :: dx,dy      \n  \n  do i = 1, 2\n    dx = p(2*i-1)%x - p(2*i)%x\n    dy = p(2*i-1)%y - p(2*i)%y\n    if( dx == 0.) then    \n        a(i) = 0.\n        b(i) = p(2*i-1)%y\n    else\n        a(i)= dy / dx\n        b(i) = p(2*i-1)%y - a(i)*p(2*i-1)%x\n    endif\n  enddo\n  \n  if( a(1) - a(2) == 0. ) then\n    write(*,*)\"lines are not intersecting\"\n    return\n  endif\n  \n  x = ( b(2) - b(1) ) / ( a(1) - a(2) )\n  y = a(1) * x + b(1)\n  write(*,*)x,y\n  end subroutine intersect\nend program intersect_two_lines\n", "target": "using System;\nusing System.Drawing;\npublic class Program\n{\n    static PointF FindIntersection(PointF s1, PointF e1, PointF s2, PointF e2) {\n        float a1 = e1.Y - s1.Y;\n        float b1 = s1.X - e1.X;\n        float c1 = a1 * s1.X + b1 * s1.Y;\n\n        float a2 = e2.Y - s2.Y;\n        float b2 = s2.X - e2.X;\n        float c2 = a2 * s2.X + b2 * s2.Y;\n\n        float delta = a1 * b2 - a2 * b1;\n        \n        return delta == 0 ? new PointF(float.NaN, float.NaN)\n            : new PointF((b2 * c1 - b1 * c2) / delta, (a1 * c2 - a2 * c1) / delta);\n    }\n\n    static void Main() {\n        Func<float, float, PointF> p = (x, y) => new PointF(x, y);\n        Console.WriteLine(FindIntersection(p(4f, 0f), p(6f, 10f), p(0f, 3f), p(10f, 7f)));\n        Console.WriteLine(FindIntersection(p(0f, 0f), p(1f, 1f), p(1f, 2f), p(4f, 5f)));\n    }\n}\n"}
{"id": 55571, "name": "Find the intersection of two lines", "source": "Translate Fortran to Java: program intersect_two_lines\n  implicit none\n  \n  type point\n    real::x,y\n  end type point\n  \n  integer, parameter :: n = 4\n  type(point)        :: p(n)\n  \n  p(1)%x = 4; p(1)%y = 0; p(2)%x = 6;  p(2)%y = 10 \n  p(3)%x = 0; p(3)%y = 3; p(4)%x = 10; p(4)%y = 7  \n  \n  call intersect(p, n)\n  \n  contains\n  \n  subroutine intersect(p,m)\n  integer, intent(in)       :: m\n  type(point), intent(in)   :: p(m)\n  integer   :: i\n  real      :: a(2), b(2) \n  real      :: x, y       \n  real      :: dx,dy      \n  \n  do i = 1, 2\n    dx = p(2*i-1)%x - p(2*i)%x\n    dy = p(2*i-1)%y - p(2*i)%y\n    if( dx == 0.) then    \n        a(i) = 0.\n        b(i) = p(2*i-1)%y\n    else\n        a(i)= dy / dx\n        b(i) = p(2*i-1)%y - a(i)*p(2*i-1)%x\n    endif\n  enddo\n  \n  if( a(1) - a(2) == 0. ) then\n    write(*,*)\"lines are not intersecting\"\n    return\n  endif\n  \n  x = ( b(2) - b(1) ) / ( a(1) - a(2) )\n  y = a(1) * x + b(1)\n  write(*,*)x,y\n  end subroutine intersect\nend program intersect_two_lines\n", "target": "public class Intersection {\n    private static class Point {\n        double x, y;\n\n        Point(double x, double y) {\n            this.x = x;\n            this.y = y;\n        }\n\n        @Override\n        public String toString() {\n            return String.format(\"{%f, %f}\", x, y);\n        }\n    }\n\n    private static class Line {\n        Point s, e;\n\n        Line(Point s, Point e) {\n            this.s = s;\n            this.e = e;\n        }\n    }\n\n    private static Point findIntersection(Line l1, Line l2) {\n        double a1 = l1.e.y - l1.s.y;\n        double b1 = l1.s.x - l1.e.x;\n        double c1 = a1 * l1.s.x + b1 * l1.s.y;\n\n        double a2 = l2.e.y - l2.s.y;\n        double b2 = l2.s.x - l2.e.x;\n        double c2 = a2 * l2.s.x + b2 * l2.s.y;\n\n        double delta = a1 * b2 - a2 * b1;\n        return new Point((b2 * c1 - b1 * c2) / delta, (a1 * c2 - a2 * c1) / delta);\n    }\n\n    public static void main(String[] args) {\n        Line l1 = new Line(new Point(4, 0), new Point(6, 10));\n        Line l2 = new Line(new Point(0, 3), new Point(10, 7));\n        System.out.println(findIntersection(l1, l2));\n\n        l1 = new Line(new Point(0, 0), new Point(1, 1));\n        l2 = new Line(new Point(1, 2), new Point(4, 5));\n        System.out.println(findIntersection(l1, l2));\n    }\n}\n"}
{"id": 55572, "name": "Find the intersection of two lines", "source": "Translate Fortran to Java: program intersect_two_lines\n  implicit none\n  \n  type point\n    real::x,y\n  end type point\n  \n  integer, parameter :: n = 4\n  type(point)        :: p(n)\n  \n  p(1)%x = 4; p(1)%y = 0; p(2)%x = 6;  p(2)%y = 10 \n  p(3)%x = 0; p(3)%y = 3; p(4)%x = 10; p(4)%y = 7  \n  \n  call intersect(p, n)\n  \n  contains\n  \n  subroutine intersect(p,m)\n  integer, intent(in)       :: m\n  type(point), intent(in)   :: p(m)\n  integer   :: i\n  real      :: a(2), b(2) \n  real      :: x, y       \n  real      :: dx,dy      \n  \n  do i = 1, 2\n    dx = p(2*i-1)%x - p(2*i)%x\n    dy = p(2*i-1)%y - p(2*i)%y\n    if( dx == 0.) then    \n        a(i) = 0.\n        b(i) = p(2*i-1)%y\n    else\n        a(i)= dy / dx\n        b(i) = p(2*i-1)%y - a(i)*p(2*i-1)%x\n    endif\n  enddo\n  \n  if( a(1) - a(2) == 0. ) then\n    write(*,*)\"lines are not intersecting\"\n    return\n  endif\n  \n  x = ( b(2) - b(1) ) / ( a(1) - a(2) )\n  y = a(1) * x + b(1)\n  write(*,*)x,y\n  end subroutine intersect\nend program intersect_two_lines\n", "target": "public class Intersection {\n    private static class Point {\n        double x, y;\n\n        Point(double x, double y) {\n            this.x = x;\n            this.y = y;\n        }\n\n        @Override\n        public String toString() {\n            return String.format(\"{%f, %f}\", x, y);\n        }\n    }\n\n    private static class Line {\n        Point s, e;\n\n        Line(Point s, Point e) {\n            this.s = s;\n            this.e = e;\n        }\n    }\n\n    private static Point findIntersection(Line l1, Line l2) {\n        double a1 = l1.e.y - l1.s.y;\n        double b1 = l1.s.x - l1.e.x;\n        double c1 = a1 * l1.s.x + b1 * l1.s.y;\n\n        double a2 = l2.e.y - l2.s.y;\n        double b2 = l2.s.x - l2.e.x;\n        double c2 = a2 * l2.s.x + b2 * l2.s.y;\n\n        double delta = a1 * b2 - a2 * b1;\n        return new Point((b2 * c1 - b1 * c2) / delta, (a1 * c2 - a2 * c1) / delta);\n    }\n\n    public static void main(String[] args) {\n        Line l1 = new Line(new Point(4, 0), new Point(6, 10));\n        Line l2 = new Line(new Point(0, 3), new Point(10, 7));\n        System.out.println(findIntersection(l1, l2));\n\n        l1 = new Line(new Point(0, 0), new Point(1, 1));\n        l2 = new Line(new Point(1, 2), new Point(4, 5));\n        System.out.println(findIntersection(l1, l2));\n    }\n}\n"}
{"id": 55573, "name": "Find the intersection of two lines", "source": "Translate Fortran to Python: program intersect_two_lines\n  implicit none\n  \n  type point\n    real::x,y\n  end type point\n  \n  integer, parameter :: n = 4\n  type(point)        :: p(n)\n  \n  p(1)%x = 4; p(1)%y = 0; p(2)%x = 6;  p(2)%y = 10 \n  p(3)%x = 0; p(3)%y = 3; p(4)%x = 10; p(4)%y = 7  \n  \n  call intersect(p, n)\n  \n  contains\n  \n  subroutine intersect(p,m)\n  integer, intent(in)       :: m\n  type(point), intent(in)   :: p(m)\n  integer   :: i\n  real      :: a(2), b(2) \n  real      :: x, y       \n  real      :: dx,dy      \n  \n  do i = 1, 2\n    dx = p(2*i-1)%x - p(2*i)%x\n    dy = p(2*i-1)%y - p(2*i)%y\n    if( dx == 0.) then    \n        a(i) = 0.\n        b(i) = p(2*i-1)%y\n    else\n        a(i)= dy / dx\n        b(i) = p(2*i-1)%y - a(i)*p(2*i-1)%x\n    endif\n  enddo\n  \n  if( a(1) - a(2) == 0. ) then\n    write(*,*)\"lines are not intersecting\"\n    return\n  endif\n  \n  x = ( b(2) - b(1) ) / ( a(1) - a(2) )\n  y = a(1) * x + b(1)\n  write(*,*)x,y\n  end subroutine intersect\nend program intersect_two_lines\n", "target": "from __future__ import division\n\ndef setup():\n    \n    (a, b), (c, d) = (4, 0), (6, 10)  \n    (e, f), (g, h) = (0, 3), (10, 7)  \n    pt = line_instersect(a, b, c, d, e, f, g, h)\n    scale(9)\n    line(a, b, c, d)\n    line(e, f, g, h)\n    if pt:\n        x, y = pt\n        stroke(255)\n        point(x, y)\n    println(pt)  \n\ndef line_instersect(Ax1, Ay1, Ax2, Ay2, Bx1, By1, Bx2, By2):\n    \n    d = (By2 - By1) * (Ax2 - Ax1) - (Bx2 - Bx1) * (Ay2 - Ay1)\n    if d:\n        uA = ((Bx2 - Bx1) * (Ay1 - By1) - (By2 - By1) * (Ax1 - Bx1)) / d\n        uB = ((Ax2 - Ax1) * (Ay1 - By1) - (Ay2 - Ay1) * (Ax1 - Bx1)) / d\n    else:\n        return\n    if not(0 <= uA <= 1 and 0 <= uB <= 1):\n        return\n    x = Ax1 + uA * (Ax2 - Ax1)\n    y = Ay1 + uA * (Ay2 - Ay1)\n    return x, y\n"}
{"id": 55574, "name": "Find the intersection of two lines", "source": "Translate Fortran to Python: program intersect_two_lines\n  implicit none\n  \n  type point\n    real::x,y\n  end type point\n  \n  integer, parameter :: n = 4\n  type(point)        :: p(n)\n  \n  p(1)%x = 4; p(1)%y = 0; p(2)%x = 6;  p(2)%y = 10 \n  p(3)%x = 0; p(3)%y = 3; p(4)%x = 10; p(4)%y = 7  \n  \n  call intersect(p, n)\n  \n  contains\n  \n  subroutine intersect(p,m)\n  integer, intent(in)       :: m\n  type(point), intent(in)   :: p(m)\n  integer   :: i\n  real      :: a(2), b(2) \n  real      :: x, y       \n  real      :: dx,dy      \n  \n  do i = 1, 2\n    dx = p(2*i-1)%x - p(2*i)%x\n    dy = p(2*i-1)%y - p(2*i)%y\n    if( dx == 0.) then    \n        a(i) = 0.\n        b(i) = p(2*i-1)%y\n    else\n        a(i)= dy / dx\n        b(i) = p(2*i-1)%y - a(i)*p(2*i-1)%x\n    endif\n  enddo\n  \n  if( a(1) - a(2) == 0. ) then\n    write(*,*)\"lines are not intersecting\"\n    return\n  endif\n  \n  x = ( b(2) - b(1) ) / ( a(1) - a(2) )\n  y = a(1) * x + b(1)\n  write(*,*)x,y\n  end subroutine intersect\nend program intersect_two_lines\n", "target": "from __future__ import division\n\ndef setup():\n    \n    (a, b), (c, d) = (4, 0), (6, 10)  \n    (e, f), (g, h) = (0, 3), (10, 7)  \n    pt = line_instersect(a, b, c, d, e, f, g, h)\n    scale(9)\n    line(a, b, c, d)\n    line(e, f, g, h)\n    if pt:\n        x, y = pt\n        stroke(255)\n        point(x, y)\n    println(pt)  \n\ndef line_instersect(Ax1, Ay1, Ax2, Ay2, Bx1, By1, Bx2, By2):\n    \n    d = (By2 - By1) * (Ax2 - Ax1) - (Bx2 - Bx1) * (Ay2 - Ay1)\n    if d:\n        uA = ((Bx2 - Bx1) * (Ay1 - By1) - (By2 - By1) * (Ax1 - Bx1)) / d\n        uB = ((Ax2 - Ax1) * (Ay1 - By1) - (Ay2 - Ay1) * (Ax1 - Bx1)) / d\n    else:\n        return\n    if not(0 <= uA <= 1 and 0 <= uB <= 1):\n        return\n    x = Ax1 + uA * (Ax2 - Ax1)\n    y = Ay1 + uA * (Ay2 - Ay1)\n    return x, y\n"}
{"id": 55865, "name": "Conditional structures", "source": "Translate Fortran to C#: if ( a .gt. 20.0 ) then\n   q = q + a**2\nelse if ( a .ge. 0.0 ) then\n   q = q + 2*a**3\nelse\n   q = q - a\nend if\n", "target": "if (condition)\n{\n   \n}\n\nif (condition)\n{\n  \n}\nelse if (condition2)\n{\n  \n}\nelse\n{\n  \n}\n"}
{"id": 55869, "name": "Conditional structures", "source": "Translate Fortran to Java: if ( a .gt. 20.0 ) then\n   q = q + a**2\nelse if ( a .ge. 0.0 ) then\n   q = q + 2*a**3\nelse\n   q = q - a\nend if\n", "target": "if (s == 'Hello World') {\n    foo();\n} else if (s == 'Bye World') {\n    bar();\n} else {\n    deusEx();\n}\n"}
{"id": 55870, "name": "Conditional structures", "source": "Translate Fortran to Python: if ( a .gt. 20.0 ) then\n   q = q + a**2\nelse if ( a .ge. 0.0 ) then\n   q = q + 2*a**3\nelse\n   q = q - a\nend if\n", "target": "if x == 0:\n    foo()\nelif x == 1:\n    bar()\nelif x == 2:\n    baz()\nelse:\n    qux()\n\nmatch x:\n    0 => foo()\n    1 => bar()\n    2 => baz()\n    _ => qux()\n\n(a) ? b : c\n"}
{"id": 56076, "name": "Align columns", "source": "Translate Fortran to C#:       SUBROUTINE RAKE(IN,M,X,WAY)\t\nCollates column widths so that each column is wide enough for its widest member.\n       INTEGER IN\t\t\n       INTEGER M\t\t\n       CHARACTER*1 X\t\t\n       INTEGER WAY\t\t\n       INTEGER W(M + 1)\t\t\n       INTEGER C(0:M + 1)\t\n       CHARACTER*(M) ACARD\t\n       CHARACTER*(28 + 4*M) FORMAT\t\n       INTEGER I\t\t\n       INTEGER L,LF\t\t\n       INTEGER NF,MF\t\t\n       CHARACTER*6 WAYNESS(-1:+1)\t\n       PARAMETER (WAYNESS = (/\"Left\",\"Centre\",\"Right\"/))\t\n       INTEGER LINPR\t\n       COMMON LINPR\t\n        W = 0\t\t\n        MF = 0\t\t\n        C(0) = 0\t\n        WRITE (LINPR,*)\t\n        WRITE (LINPR,*) \"Align \",WAYNESS(MIN(MAX(WAY,-1),+1))\t\n\nChase through the file assessing the lengths of each field.\n   10   READ (IN,11,END = 20) L,ACARD(1:L)\t\n   11   FORMAT (Q,A)\t\t\t\t\n        CALL LIZZIEBORDEN\t\n        W(1:NF) = MAX(W(1:NF),C(1:NF) - C(0:NF - 1) - 1)\t\n        MF = MAX(MF,NF)\t\t\n        GO TO 10\t\t\n\nConcoct a FORMAT based on the maximum size of each field. Plus one.\n   20   REWIND(IN)\t\t\n        WRITE (FORMAT,21) W(1:MF) + 1\t\n   21   FORMAT (\"(\",<MF>(\"A\",I0,\",\"))\t\n        LF = INDEX(FORMAT,\", \")\t\t\n        IF (LF.LE.0) STOP \"Format trouble\n        FORMAT(LF:LF) = \")\"\t\t\t\n        WRITE (LINPR,*) \"Format\",FORMAT(1:LF)\t\n\nChug afresh, this time knowing the maximum length of each field.\n   30   READ (IN,11,END = 40) L,ACARD(1:L)\t\n        CALL LIZZIEBORDEN\t\t\n        SELECT CASE(WAY)\t\n         CASE(-1)\t\t\n          WRITE (LINPR,FORMAT) (ACARD(C(I - 1) + 1:C(I) - 1)//\t\n     1     REPEAT(\" \",W(I) - C(I) + C(I - 1) + 1),I = 1,NF)\t\n         CASE( 0)\t\t\n          WRITE (LINPR,FORMAT) (ACARD(C(I - 1) + 1:C(I) - 1)//\t\n     1     REPEAT(\" \",(W(I) - C(I) + C(I - 1) + 1)/2),I = 1,NF)\t\n         CASE(+1)\t\t\n          WRITE (LINPR,FORMAT) (ACARD(C(I - 1) + 1:C(I) - 1),I = 1,NF)\t\n         CASE DEFAULT\t\t\n         WRITE (LINPR,*) \"Huh? WAY=\",WAY\t\n         STOP \"Unanticipated value for WAY\n        END SELECT\t\t\n        GO TO 30\t\t\nClosedown\n   40   REWIND(IN)\t\t\n       CONTAINS\t\n        SUBROUTINE LIZZIEBORDEN\t\n          NF = 0\t\t\n          DO I = 1,L\t\t\n            IF (ICHAR(ACARD(I:I)).EQ.ICHAR(X)) THEN\t\n              NF = NF + 1\t\t\n              C(NF) = I\t\t\n            END IF\t\t\n          END DO\t\t\n          NF = NF + 1\t\t\n          C(NF) = L + 1\t\t\n        END SUBROUTINE LIZZIEBORDEN\t\n      END SUBROUTINE RAKE\t\n\n      INTEGER L,M,N\t\n      INTEGER LINPR,IN\t\n      COMMON LINPR\t\n      LINPR = 6\t\t\n      IN = 10\t\t\n      OPEN (IN,FILE=\"Rake.txt\",STATUS=\"OLD\",ACTION=\"READ\")\t\n      N = 0\t\t\n      M = 0\t\t\n\n    1 READ (IN,2,END = 10) L\t\n    2 FORMAT (Q)\t\n      N = N + 1\t\t\n      M = MAX(M,L)\t\n      GO TO 1\t\t\n\n   10 REWIND (IN)\t\n      WRITE (LINPR,*) N,\"Recs, longest rec. length is \",M\n      CALL RAKE(IN,M,\"$\",-1)\t\n      CALL RAKE(IN,M,\"$\", 0)\t\n      CALL RAKE(IN,M,\"$\",+1)\t\n      END\t\n", "target": "using System;\nclass ColumnAlignerProgram\n{\n    delegate string Justification(string s, int width);\n\n    static string[] AlignColumns(string[] lines, Justification justification)\n    {\n        const char Separator = '$';\n        \n        string[][] table = new string[lines.Length][];\n        int columns = 0;\n        for (int i = 0; i < lines.Length; i++)\n        {\n            string[] row = lines[i].TrimEnd(Separator).Split(Separator);\n            if (columns < row.Length) columns = row.Length;\n            table[i] = row;\n        }\n        \n        string[][] formattedTable = new string[table.Length][];\n        for (int i = 0; i < formattedTable.Length; i++)\n        {\n            formattedTable[i] = new string[columns];\n        }\n        for (int j = 0; j < columns; j++)\n        {\n            \n            int columnWidth = 0;\n            for (int i = 0; i < table.Length; i++)\n            {\n                if (j < table[i].Length && columnWidth < table[i][j].Length)\n                    columnWidth = table[i][j].Length;\n            }\n            \n            for (int i = 0; i < formattedTable.Length; i++)\n            {\n                if (j < table[i].Length)\n                    formattedTable[i][j] = justification(table[i][j], columnWidth);\n                else \n                    formattedTable[i][j] = new String(' ', columnWidth);\n            }\n        }\n        \n        string[] result = new string[formattedTable.Length];\n        for (int i = 0; i < result.Length; i++)\n        {\n            result[i] = String.Join(\" \", formattedTable[i]);\n        }\n        return result;\n    }\n\n    static string JustifyLeft(string s, int width) { return s.PadRight(width); }\n    static string JustifyRight(string s, int width) { return s.PadLeft(width); }\n    static string JustifyCenter(string s, int width) \n    { \n        return s.PadLeft((width + s.Length) / 2).PadRight(width); \n    }\n\n    static void Main()\n    {\n        string[] input = {    \n            \"Given$a$text$file$of$many$lines,$where$fields$within$a$line$\",\n            \"are$delineated$by$a$single$'dollar'$character,$write$a$program\",\n            \"that$aligns$each$column$of$fields$by$ensuring$that$words$in$each$\",\n            \"column$are$separated$by$at$least$one$space.\",\n            \"Further,$allow$for$each$word$in$a$column$to$be$either$left$\",\n            \"justified,$right$justified,$or$center$justified$within$its$column.\",\n        };\n\n        foreach (string line in AlignColumns(input, JustifyCenter))\n        {\n            Console.WriteLine(line);\n        }\n    }\n}\n"}
{"id": 56078, "name": "Align columns", "source": "Translate Fortran to Java:       SUBROUTINE RAKE(IN,M,X,WAY)\t\nCollates column widths so that each column is wide enough for its widest member.\n       INTEGER IN\t\t\n       INTEGER M\t\t\n       CHARACTER*1 X\t\t\n       INTEGER WAY\t\t\n       INTEGER W(M + 1)\t\t\n       INTEGER C(0:M + 1)\t\n       CHARACTER*(M) ACARD\t\n       CHARACTER*(28 + 4*M) FORMAT\t\n       INTEGER I\t\t\n       INTEGER L,LF\t\t\n       INTEGER NF,MF\t\t\n       CHARACTER*6 WAYNESS(-1:+1)\t\n       PARAMETER (WAYNESS = (/\"Left\",\"Centre\",\"Right\"/))\t\n       INTEGER LINPR\t\n       COMMON LINPR\t\n        W = 0\t\t\n        MF = 0\t\t\n        C(0) = 0\t\n        WRITE (LINPR,*)\t\n        WRITE (LINPR,*) \"Align \",WAYNESS(MIN(MAX(WAY,-1),+1))\t\n\nChase through the file assessing the lengths of each field.\n   10   READ (IN,11,END = 20) L,ACARD(1:L)\t\n   11   FORMAT (Q,A)\t\t\t\t\n        CALL LIZZIEBORDEN\t\n        W(1:NF) = MAX(W(1:NF),C(1:NF) - C(0:NF - 1) - 1)\t\n        MF = MAX(MF,NF)\t\t\n        GO TO 10\t\t\n\nConcoct a FORMAT based on the maximum size of each field. Plus one.\n   20   REWIND(IN)\t\t\n        WRITE (FORMAT,21) W(1:MF) + 1\t\n   21   FORMAT (\"(\",<MF>(\"A\",I0,\",\"))\t\n        LF = INDEX(FORMAT,\", \")\t\t\n        IF (LF.LE.0) STOP \"Format trouble\n        FORMAT(LF:LF) = \")\"\t\t\t\n        WRITE (LINPR,*) \"Format\",FORMAT(1:LF)\t\n\nChug afresh, this time knowing the maximum length of each field.\n   30   READ (IN,11,END = 40) L,ACARD(1:L)\t\n        CALL LIZZIEBORDEN\t\t\n        SELECT CASE(WAY)\t\n         CASE(-1)\t\t\n          WRITE (LINPR,FORMAT) (ACARD(C(I - 1) + 1:C(I) - 1)//\t\n     1     REPEAT(\" \",W(I) - C(I) + C(I - 1) + 1),I = 1,NF)\t\n         CASE( 0)\t\t\n          WRITE (LINPR,FORMAT) (ACARD(C(I - 1) + 1:C(I) - 1)//\t\n     1     REPEAT(\" \",(W(I) - C(I) + C(I - 1) + 1)/2),I = 1,NF)\t\n         CASE(+1)\t\t\n          WRITE (LINPR,FORMAT) (ACARD(C(I - 1) + 1:C(I) - 1),I = 1,NF)\t\n         CASE DEFAULT\t\t\n         WRITE (LINPR,*) \"Huh? WAY=\",WAY\t\n         STOP \"Unanticipated value for WAY\n        END SELECT\t\t\n        GO TO 30\t\t\nClosedown\n   40   REWIND(IN)\t\t\n       CONTAINS\t\n        SUBROUTINE LIZZIEBORDEN\t\n          NF = 0\t\t\n          DO I = 1,L\t\t\n            IF (ICHAR(ACARD(I:I)).EQ.ICHAR(X)) THEN\t\n              NF = NF + 1\t\t\n              C(NF) = I\t\t\n            END IF\t\t\n          END DO\t\t\n          NF = NF + 1\t\t\n          C(NF) = L + 1\t\t\n        END SUBROUTINE LIZZIEBORDEN\t\n      END SUBROUTINE RAKE\t\n\n      INTEGER L,M,N\t\n      INTEGER LINPR,IN\t\n      COMMON LINPR\t\n      LINPR = 6\t\t\n      IN = 10\t\t\n      OPEN (IN,FILE=\"Rake.txt\",STATUS=\"OLD\",ACTION=\"READ\")\t\n      N = 0\t\t\n      M = 0\t\t\n\n    1 READ (IN,2,END = 10) L\t\n    2 FORMAT (Q)\t\n      N = N + 1\t\t\n      M = MAX(M,L)\t\n      GO TO 1\t\t\n\n   10 REWIND (IN)\t\n      WRITE (LINPR,*) N,\"Recs, longest rec. length is \",M\n      CALL RAKE(IN,M,\"$\",-1)\t\n      CALL RAKE(IN,M,\"$\", 0)\t\n      CALL RAKE(IN,M,\"$\",+1)\t\n      END\t\n", "target": "import java.io.IOException;\nimport java.nio.charset.StandardCharsets;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.StringUtils;\n\n\npublic class ColumnAligner {\n    private List<String[]> words = new ArrayList<>();\n    private int columns = 0;\n    private List<Integer> columnWidths = new ArrayList<>();\n\n    \n    public ColumnAligner(String s) {\n        String[] lines = s.split(\"\\\\n\");\n        for (String line : lines) {\n            processInputLine(line);\n        }\n    }\n\n    \n    public ColumnAligner(List<String> lines) {\n        for (String line : lines) {\n            processInputLine(line);\n        }\n    }\n\n    private void processInputLine(String line) {\n        String[] lineWords = line.split(\"\\\\$\");\n        words.add(lineWords);\n        columns = Math.max(columns, lineWords.length);\n        for (int i = 0; i < lineWords.length; i++) {\n            String word = lineWords[i];\n            if (i >= columnWidths.size()) {\n                columnWidths.add(word.length());\n            } else {\n                columnWidths.set(i, Math.max(columnWidths.get(i), word.length()));\n            }\n        }\n    }\n\n    interface AlignFunction {\n        String align(String s, int length);\n    }\n\n    \n    public String alignLeft() {\n        return align(new AlignFunction() {\n            @Override\n            public String align(String s, int length) {\n                return StringUtils.rightPad(s, length);\n            }\n        });\n    }\n\n    \n    public String alignRight() {\n        return align(new AlignFunction() {\n            @Override\n            public String align(String s, int length) {\n                return StringUtils.leftPad(s, length);\n            }\n        });\n    }\n\n    \n    public String alignCenter() {\n        return align(new AlignFunction() {\n            @Override\n            public String align(String s, int length) {\n                return StringUtils.center(s, length);\n            }\n        });\n    }\n\n    private String align(AlignFunction a) {\n        StringBuilder result = new StringBuilder();\n        for (String[] lineWords : words) {\n            for (int i = 0; i < lineWords.length; i++) {\n                String word = lineWords[i];\n                if (i == 0) {\n                    result.append(\"|\");\n                }\n                result.append(a.align(word, columnWidths.get(i)) + \"|\");\n            }\n            result.append(\"\\n\");\n        }\n        return result.toString();\n    }\n\n    public static void main(String args[]) throws IOException {\n        if (args.length < 1) {\n            System.out.println(\"Usage: ColumnAligner file [left|right|center]\");\n            return;\n        }\n        String filePath = args[0];\n        String alignment = \"left\";\n        if (args.length >= 2) {\n            alignment = args[1];\n        }\n        ColumnAligner ca = new ColumnAligner(Files.readAllLines(Paths.get(filePath), StandardCharsets.UTF_8));\n        switch (alignment) {\n        case \"left\":\n            System.out.print(ca.alignLeft());\n            break;\n        case \"right\":\n            System.out.print(ca.alignRight());\n            break;\n        case \"center\":\n            System.out.print(ca.alignCenter());\n            break;\n        default:\n            System.err.println(String.format(\"Error! Unknown alignment: '%s'\", alignment));\n            break;\n        }\n    }\n}\n"}
{"id": 56079, "name": "Align columns", "source": "Translate Fortran to Python:       SUBROUTINE RAKE(IN,M,X,WAY)\t\nCollates column widths so that each column is wide enough for its widest member.\n       INTEGER IN\t\t\n       INTEGER M\t\t\n       CHARACTER*1 X\t\t\n       INTEGER WAY\t\t\n       INTEGER W(M + 1)\t\t\n       INTEGER C(0:M + 1)\t\n       CHARACTER*(M) ACARD\t\n       CHARACTER*(28 + 4*M) FORMAT\t\n       INTEGER I\t\t\n       INTEGER L,LF\t\t\n       INTEGER NF,MF\t\t\n       CHARACTER*6 WAYNESS(-1:+1)\t\n       PARAMETER (WAYNESS = (/\"Left\",\"Centre\",\"Right\"/))\t\n       INTEGER LINPR\t\n       COMMON LINPR\t\n        W = 0\t\t\n        MF = 0\t\t\n        C(0) = 0\t\n        WRITE (LINPR,*)\t\n        WRITE (LINPR,*) \"Align \",WAYNESS(MIN(MAX(WAY,-1),+1))\t\n\nChase through the file assessing the lengths of each field.\n   10   READ (IN,11,END = 20) L,ACARD(1:L)\t\n   11   FORMAT (Q,A)\t\t\t\t\n        CALL LIZZIEBORDEN\t\n        W(1:NF) = MAX(W(1:NF),C(1:NF) - C(0:NF - 1) - 1)\t\n        MF = MAX(MF,NF)\t\t\n        GO TO 10\t\t\n\nConcoct a FORMAT based on the maximum size of each field. Plus one.\n   20   REWIND(IN)\t\t\n        WRITE (FORMAT,21) W(1:MF) + 1\t\n   21   FORMAT (\"(\",<MF>(\"A\",I0,\",\"))\t\n        LF = INDEX(FORMAT,\", \")\t\t\n        IF (LF.LE.0) STOP \"Format trouble\n        FORMAT(LF:LF) = \")\"\t\t\t\n        WRITE (LINPR,*) \"Format\",FORMAT(1:LF)\t\n\nChug afresh, this time knowing the maximum length of each field.\n   30   READ (IN,11,END = 40) L,ACARD(1:L)\t\n        CALL LIZZIEBORDEN\t\t\n        SELECT CASE(WAY)\t\n         CASE(-1)\t\t\n          WRITE (LINPR,FORMAT) (ACARD(C(I - 1) + 1:C(I) - 1)//\t\n     1     REPEAT(\" \",W(I) - C(I) + C(I - 1) + 1),I = 1,NF)\t\n         CASE( 0)\t\t\n          WRITE (LINPR,FORMAT) (ACARD(C(I - 1) + 1:C(I) - 1)//\t\n     1     REPEAT(\" \",(W(I) - C(I) + C(I - 1) + 1)/2),I = 1,NF)\t\n         CASE(+1)\t\t\n          WRITE (LINPR,FORMAT) (ACARD(C(I - 1) + 1:C(I) - 1),I = 1,NF)\t\n         CASE DEFAULT\t\t\n         WRITE (LINPR,*) \"Huh? WAY=\",WAY\t\n         STOP \"Unanticipated value for WAY\n        END SELECT\t\t\n        GO TO 30\t\t\nClosedown\n   40   REWIND(IN)\t\t\n       CONTAINS\t\n        SUBROUTINE LIZZIEBORDEN\t\n          NF = 0\t\t\n          DO I = 1,L\t\t\n            IF (ICHAR(ACARD(I:I)).EQ.ICHAR(X)) THEN\t\n              NF = NF + 1\t\t\n              C(NF) = I\t\t\n            END IF\t\t\n          END DO\t\t\n          NF = NF + 1\t\t\n          C(NF) = L + 1\t\t\n        END SUBROUTINE LIZZIEBORDEN\t\n      END SUBROUTINE RAKE\t\n\n      INTEGER L,M,N\t\n      INTEGER LINPR,IN\t\n      COMMON LINPR\t\n      LINPR = 6\t\t\n      IN = 10\t\t\n      OPEN (IN,FILE=\"Rake.txt\",STATUS=\"OLD\",ACTION=\"READ\")\t\n      N = 0\t\t\n      M = 0\t\t\n\n    1 READ (IN,2,END = 10) L\t\n    2 FORMAT (Q)\t\n      N = N + 1\t\t\n      M = MAX(M,L)\t\n      GO TO 1\t\t\n\n   10 REWIND (IN)\t\n      WRITE (LINPR,*) N,\"Recs, longest rec. length is \",M\n      CALL RAKE(IN,M,\"$\",-1)\t\n      CALL RAKE(IN,M,\"$\", 0)\t\n      CALL RAKE(IN,M,\"$\",+1)\t\n      END\t\n", "target": "from itertools import zip_longest\n\ntxt = \n \nparts = [line.rstrip(\"$\").split(\"$\") for line in txt.splitlines()]\nwidths = [max(len(word) for word in col) \n          for col in zip_longest(*parts, fillvalue='')]\n \nfor justify in \"<_Left ^_Center >_Right\".split():\n    j, jtext = justify.split('_')\n    print(f\"{jtext} column-aligned output:\\n\")\n    for line in parts:\n        print(' '.join(f\"{wrd:{j}{wdth}}\" for wdth, wrd in zip(widths, line)))\n    print(\"- \" * 52)\n"}
{"id": 56655, "name": "String matching", "source": "Translate Fortran to C#:       SUBROUTINE STARTS(A,B)\t\n       CHARACTER*(*) A,B\n        IF (INDEX(A,B).EQ.1) THEN\t\n          WRITE (6,*) \">\",A,\"< starts with >\",B,\"<\"\n         ELSE\n          WRITE (6,*) \">\",A,\"< does not start with >\",B,\"<\"\n        END IF\n      END SUBROUTINE STARTS\n\n      SUBROUTINE HAS(A,B)\t\n       CHARACTER*(*) A,B\n       INTEGER L\n        L = INDEX(A,B)\t\t\n        IF (L.LE.0) THEN\n          WRITE (6,*) \">\",A,\"< does not contain >\",B,\"<\"\n         ELSE\n          WRITE (6,*) \">\",A,\"< contains a >\",B,\"<, offset\",L\n        END IF\n      END SUBROUTINE HAS\n\n      SUBROUTINE ENDS(A,B)\t\n       CHARACTER*(*) A,B\n       INTEGER L\n        L = LEN(A) - LEN(B)\t\n        IF (L.LT.0) THEN\t\n          WRITE (6,*) \">\",A,\"< is too short to end with >\",B,\"<\"\t\n        ELSE IF (A(L + 1:L + LEN(B)).NE.B) THEN\t\n          WRITE (6,*) \">\",A,\"< does not end with >\",B,\"<\"\n        ELSE\n          WRITE (6,*) \">\",A,\"< ends with >\",B,\"<\"\n        END IF\n      END SUBROUTINE ENDS\n\n      CALL STARTS(\"This\",\"is\")\n      CALL STARTS(\"Theory\",\"The\")\n      CALL HAS(\"Bananas\",\"an\")\n      CALL ENDS(\"Banana\",\"an\")\n      CALL ENDS(\"Banana\",\"na\")\n      CALL ENDS(\"Brief\",\"Much longer\")\n      END\n", "target": "class Program\n{\n\tpublic static void Main (string[] args)\n\t{\n\t\tvar value = \"abcd\".StartsWith(\"ab\");\n\t\tvalue = \"abcd\".EndsWith(\"zn\"); \n\t\tvalue = \"abab\".Contains(\"bb\"); \n\t\tvalue = \"abab\".Contains(\"ab\"); \n\t\tint loc = \"abab\".IndexOf(\"bb\"); \n\t\tloc = \"abab\".IndexOf(\"ab\"); \n\t\tloc = \"abab\".IndexOf(\"ab\",loc+1); \n\t}\n}\n"}
{"id": 56658, "name": "String matching", "source": "Translate Fortran to Java:       SUBROUTINE STARTS(A,B)\t\n       CHARACTER*(*) A,B\n        IF (INDEX(A,B).EQ.1) THEN\t\n          WRITE (6,*) \">\",A,\"< starts with >\",B,\"<\"\n         ELSE\n          WRITE (6,*) \">\",A,\"< does not start with >\",B,\"<\"\n        END IF\n      END SUBROUTINE STARTS\n\n      SUBROUTINE HAS(A,B)\t\n       CHARACTER*(*) A,B\n       INTEGER L\n        L = INDEX(A,B)\t\t\n        IF (L.LE.0) THEN\n          WRITE (6,*) \">\",A,\"< does not contain >\",B,\"<\"\n         ELSE\n          WRITE (6,*) \">\",A,\"< contains a >\",B,\"<, offset\",L\n        END IF\n      END SUBROUTINE HAS\n\n      SUBROUTINE ENDS(A,B)\t\n       CHARACTER*(*) A,B\n       INTEGER L\n        L = LEN(A) - LEN(B)\t\n        IF (L.LT.0) THEN\t\n          WRITE (6,*) \">\",A,\"< is too short to end with >\",B,\"<\"\t\n        ELSE IF (A(L + 1:L + LEN(B)).NE.B) THEN\t\n          WRITE (6,*) \">\",A,\"< does not end with >\",B,\"<\"\n        ELSE\n          WRITE (6,*) \">\",A,\"< ends with >\",B,\"<\"\n        END IF\n      END SUBROUTINE ENDS\n\n      CALL STARTS(\"This\",\"is\")\n      CALL STARTS(\"Theory\",\"The\")\n      CALL HAS(\"Bananas\",\"an\")\n      CALL ENDS(\"Banana\",\"an\")\n      CALL ENDS(\"Banana\",\"na\")\n      CALL ENDS(\"Brief\",\"Much longer\")\n      END\n", "target": "\"abcd\".startsWith(\"ab\") \n\"abcd\".endsWith(\"zn\") \n\"abab\".contains(\"bb\") \n\"abab\".contains(\"ab\") \nint loc = \"abab\".indexOf(\"bb\") \nloc = \"abab\".indexOf(\"ab\") \nloc = \"abab\".indexOf(\"ab\",loc+1) \n"}
{"id": 56659, "name": "String matching", "source": "Translate Fortran to Python:       SUBROUTINE STARTS(A,B)\t\n       CHARACTER*(*) A,B\n        IF (INDEX(A,B).EQ.1) THEN\t\n          WRITE (6,*) \">\",A,\"< starts with >\",B,\"<\"\n         ELSE\n          WRITE (6,*) \">\",A,\"< does not start with >\",B,\"<\"\n        END IF\n      END SUBROUTINE STARTS\n\n      SUBROUTINE HAS(A,B)\t\n       CHARACTER*(*) A,B\n       INTEGER L\n        L = INDEX(A,B)\t\t\n        IF (L.LE.0) THEN\n          WRITE (6,*) \">\",A,\"< does not contain >\",B,\"<\"\n         ELSE\n          WRITE (6,*) \">\",A,\"< contains a >\",B,\"<, offset\",L\n        END IF\n      END SUBROUTINE HAS\n\n      SUBROUTINE ENDS(A,B)\t\n       CHARACTER*(*) A,B\n       INTEGER L\n        L = LEN(A) - LEN(B)\t\n        IF (L.LT.0) THEN\t\n          WRITE (6,*) \">\",A,\"< is too short to end with >\",B,\"<\"\t\n        ELSE IF (A(L + 1:L + LEN(B)).NE.B) THEN\t\n          WRITE (6,*) \">\",A,\"< does not end with >\",B,\"<\"\n        ELSE\n          WRITE (6,*) \">\",A,\"< ends with >\",B,\"<\"\n        END IF\n      END SUBROUTINE ENDS\n\n      CALL STARTS(\"This\",\"is\")\n      CALL STARTS(\"Theory\",\"The\")\n      CALL HAS(\"Bananas\",\"an\")\n      CALL ENDS(\"Banana\",\"an\")\n      CALL ENDS(\"Banana\",\"na\")\n      CALL ENDS(\"Brief\",\"Much longer\")\n      END\n", "target": "\"abcd\".startswith(\"ab\") \n\"abcd\".endswith(\"zn\") \n\"bb\" in \"abab\" \n\"ab\" in \"abab\" \nloc = \"abab\".find(\"bb\") \nloc = \"abab\".find(\"ab\") \nloc = \"abab\".find(\"ab\",loc+1) \n"}
{"id": 56917, "name": "Real constants and functions", "source": "Translate Fortran to C#:  e          \n pi         \n SQRT(x)    \n LOG(x)     \n LOG10(x)   \n EXP(x)     \n ABS(x)     \n FLOOR(x)   \n CEILING(x) \n x**y       \n", "target": "using System;\n\nclass Program {\n    static void Main(string[] args) {        \n        Console.WriteLine(Math.E); \n        Console.WriteLine(Math.PI); \n        Console.WriteLine(Math.Sqrt(10)); \n        Console.WriteLine(Math.Log(10)); \n        Console.WriteLine(Math.Log10(10)); \n        Console.WriteLine(Math.Exp(10)); \n        Console.WriteLine(Math.Abs(10)); \n        Console.WriteLine(Math.Floor(10.0)); \n        Console.WriteLine(Math.Ceiling(10.0)); \n        Console.WriteLine(Math.Pow(2, 5)); \n    }\n}\n"}
{"id": 56921, "name": "Real constants and functions", "source": "Translate Fortran to Java:  e          \n pi         \n SQRT(x)    \n LOG(x)     \n LOG10(x)   \n EXP(x)     \n ABS(x)     \n FLOOR(x)   \n CEILING(x) \n x**y       \n", "target": "Math.E; \nMath.PI; \nMath.sqrt(x); \nMath.log(x); \nMath.exp(x); \nMath.abs(x); \nMath.floor(x); \nMath.ceil(x); \nMath.pow(x,y); \n"}
{"id": 56922, "name": "Real constants and functions", "source": "Translate Fortran to Python:  e          \n pi         \n SQRT(x)    \n LOG(x)     \n LOG10(x)   \n EXP(x)     \n ABS(x)     \n FLOOR(x)   \n CEILING(x) \n x**y       \n", "target": "import math\n\nmath.e          \nmath.pi         \nmath.sqrt(x)    \nmath.log(x)     \nmath.log10(x)   \nmath.exp(x)     \nabs(x)          \nmath.floor(x)   \nmath.ceil(x)    \nx ** y          \npow(x, y[, n])  \n\n\n\n"}
{"id": 57159, "name": "Singly-linked list_Element definition", "source": "Translate Fortran to C#: type node\n   real :: data\n   type( node ), pointer :: next => null() \nend type node\n\n\n\ntype( node ) :: head\n", "target": "class LinkedListNode\n{\n    public int Value { get; set; }\n    public LinkedListNode Next { get; set; }\n\n    \n    public Link(int value, LinkedListNode next = null)\n    {\n        Item = value;\n        Next = next;\n    }\n}\n"}
{"id": 57163, "name": "Singly-linked list_Element definition", "source": "Translate Fortran to Java: type node\n   real :: data\n   type( node ), pointer :: next => null() \nend type node\n\n\n\ntype( node ) :: head\n", "target": "class Link\n{\n    Link next;\n    int data;\n}\n"}
{"id": 57164, "name": "Singly-linked list_Element definition", "source": "Translate Fortran to Python: type node\n   real :: data\n   type( node ), pointer :: next => null() \nend type node\n\n\n\ntype( node ) :: head\n", "target": "class LinkedList(object):\n     \n\tclass Node(object):\n\t\tdef __init__(self, item):\n\t\t\tself.value  = item\n\t\t\tself.next = None\n\tdef __init__(self, item=None):\n\t\tif item is not None:\n\t\t\tself.head = Node(item); self.tail = self.head\n\t\telse:\n\t\t\tself.head = None; self.tail = None\n\tdef append(self, item):\n\t\tif not self.head:\n\t\t\tself.head = Node(item)\n\t\t\tself.tail = self.head\n\t\telif self.tail:\n\t\t\tself.tail.next = Node(item)\n\t\t\tself.tail = self.tail.next\n\t\telse:\n\t\t\tself.tail = Node(item)\n\tdef __iter__(self):\n\t\tcursor = self.head\n\t\twhile cursor:\n\t\t\tyield cursor.value\n\t\t\tcursor = cursor.next\n"}
{"id": 57434, "name": "System time", "source": "Translate Fortran to C#: integer :: start, stop, rate\nreal :: result\n      \n\n\n\ncall system_clock( start, rate )\n      \nresult = do_timed_work()\n      \ncall system_clock( stop )\n      \nprint *, \"elapsed time: \", real(stop - start) / real(rate)\n", "target": "Console.WriteLine(DateTime.Now);\n"}
{"id": 57437, "name": "System time", "source": "Translate Fortran to Java: integer :: start, stop, rate\nreal :: result\n      \n\n\n\ncall system_clock( start, rate )\n      \nresult = do_timed_work()\n      \ncall system_clock( stop )\n      \nprint *, \"elapsed time: \", real(stop - start) / real(rate)\n", "target": "public class SystemTime{\n    public static void main(String[] args){\n        System.out.format(\"%tc%n\", System.currentTimeMillis());\n    }\n}\n"}
{"id": 57438, "name": "System time", "source": "Translate Fortran to Python: integer :: start, stop, rate\nreal :: result\n      \n\n\n\ncall system_clock( start, rate )\n      \nresult = do_timed_work()\n      \ncall system_clock( stop )\n      \nprint *, \"elapsed time: \", real(stop - start) / real(rate)\n", "target": "import time\nprint time.ctime()\n"}
{"id": 57615, "name": "Roots of a quadratic function", "source": "Translate Fortran to C#: PROGRAM QUADRATIC\n\n IMPLICIT NONE\n INTEGER, PARAMETER :: dp = SELECTED_REAL_KIND(15)\n REAL(dp) :: a, b, c, e, discriminant, rroot1, rroot2\n COMPLEX(dp) :: croot1, croot2\n\n WRITE(*,*) \"Enter the coefficients of the equation ax^2 + bx + c\"\n WRITE(*, \"(A)\", ADVANCE=\"NO\") \"a = \"\n READ *, a\n WRITE(*,\"(A)\", ADVANCE=\"NO\") \"b = \"\n READ *, b\n WRITE(*,\"(A)\", ADVANCE=\"NO\") \"c = \"\n READ *, c\n \n WRITE(*,\"(3(A,E23.15))\") \"Coefficients are: a = \", a, \"   b = \", b, \"   c = \", c\n e = 1.0e-9_dp\n discriminant = b*b - 4.0_dp*a*c\n \n IF (ABS(discriminant) < e) THEN\n    rroot1 = -b / (2.0_dp * a)\n    WRITE(*,*) \"The roots are real and equal:\"\n    WRITE(*,\"(A,E23.15)\") \"Root = \", rroot1\n ELSE IF (discriminant > 0) THEN\n    rroot1 = -(b + SIGN(SQRT(discriminant), b)) / (2.0_dp * a)\n    rroot2 = c / (a * rroot1)\n    WRITE(*,*) \"The roots are real:\"\n    WRITE(*,\"(2(A,E23.15))\") \"Root1 = \", rroot1, \"  Root2 = \", rroot2\n ELSE\n    croot1 = (-b + SQRT(CMPLX(discriminant))) / (2.0_dp*a) \n    croot2 = CONJG(croot1)\n    WRITE(*,*) \"The roots are complex:\" \n    WRITE(*,\"(2(A,2E23.15,A))\") \"Root1 = \", croot1, \"j \", \"  Root2 = \", croot2, \"j\"\n END IF\n", "target": "using System;\nusing System.Numerics;\n\nclass QuadraticRoots\n{\n    static Tuple<Complex, Complex> Solve(double a, double b, double c)\n    {\n        var q = -(b + Math.Sign(b) * Complex.Sqrt(b * b - 4 * a * c)) / 2;\n        return Tuple.Create(q / a, c / q);\n    }\n\n    static void Main()\n    {\n        Console.WriteLine(Solve(1, -1E20, 1));\n    }\n}\n"}
{"id": 57618, "name": "Roots of a quadratic function", "source": "Translate Fortran to Java: PROGRAM QUADRATIC\n\n IMPLICIT NONE\n INTEGER, PARAMETER :: dp = SELECTED_REAL_KIND(15)\n REAL(dp) :: a, b, c, e, discriminant, rroot1, rroot2\n COMPLEX(dp) :: croot1, croot2\n\n WRITE(*,*) \"Enter the coefficients of the equation ax^2 + bx + c\"\n WRITE(*, \"(A)\", ADVANCE=\"NO\") \"a = \"\n READ *, a\n WRITE(*,\"(A)\", ADVANCE=\"NO\") \"b = \"\n READ *, b\n WRITE(*,\"(A)\", ADVANCE=\"NO\") \"c = \"\n READ *, c\n \n WRITE(*,\"(3(A,E23.15))\") \"Coefficients are: a = \", a, \"   b = \", b, \"   c = \", c\n e = 1.0e-9_dp\n discriminant = b*b - 4.0_dp*a*c\n \n IF (ABS(discriminant) < e) THEN\n    rroot1 = -b / (2.0_dp * a)\n    WRITE(*,*) \"The roots are real and equal:\"\n    WRITE(*,\"(A,E23.15)\") \"Root = \", rroot1\n ELSE IF (discriminant > 0) THEN\n    rroot1 = -(b + SIGN(SQRT(discriminant), b)) / (2.0_dp * a)\n    rroot2 = c / (a * rroot1)\n    WRITE(*,*) \"The roots are real:\"\n    WRITE(*,\"(2(A,E23.15))\") \"Root1 = \", rroot1, \"  Root2 = \", rroot2\n ELSE\n    croot1 = (-b + SQRT(CMPLX(discriminant))) / (2.0_dp*a) \n    croot2 = CONJG(croot1)\n    WRITE(*,*) \"The roots are complex:\" \n    WRITE(*,\"(2(A,2E23.15,A))\") \"Root1 = \", croot1, \"j \", \"  Root2 = \", croot2, \"j\"\n END IF\n", "target": "public class QuadraticRoots {\n    private static class Complex {\n        double re, im;\n\n        public Complex(double re, double im) {\n            this.re = re;\n            this.im = im;\n        }\n\n        @Override\n        public boolean equals(Object obj) {\n            if (obj == this) {return true;}\n            if (!(obj instanceof Complex)) {return false;}\n            Complex other = (Complex) obj;\n            return (re == other.re) && (im == other.im);\n        }\n\n        @Override\n        public String toString() {\n            if (im == 0.0) {return String.format(\"%g\", re);}\n            if (re == 0.0) {return String.format(\"%gi\", im);}\n            return String.format(\"%g %c %gi\", re,\n                (im < 0.0 ? '-' : '+'), Math.abs(im));\n        }\n    }\n\n    private static Complex[] quadraticRoots(double a, double b, double c) {\n        Complex[] roots = new Complex[2];\n        double d = b * b - 4.0 * a * c;  \n        double aa = a + a;\n\n        if (d < 0.0) {\n            double re = -b / aa;\n            double im = Math.sqrt(-d) / aa;\n            roots[0] = new Complex(re, im);\n            roots[1] = new Complex(re, -im);\n        } else if (b < 0.0) {\n            \n            \n            double re = (-b + Math.sqrt(d)) / aa;\n            roots[0] = new Complex(re, 0.0);\n            roots[1] = new Complex(c / (a * re), 0.0);\n        } else {\n            \n            double re = (-b - Math.sqrt(d)) / aa;\n            roots[1] = new Complex(re, 0.0);\n            roots[0] = new Complex(c / (a * re), 0.0);\n        }\n        return roots;\n    }\n\n    public static void main(String[] args) {\n        double[][] equations = {\n            {1.0, 22.0, -1323.0},   \n            {6.0, -23.0, 20.0},     \n            {1.0, -1.0e9, 1.0},     \n            {1.0, 2.0, 1.0},        \n            {1.0, 0.0, 1.0},        \n            {1.0, 1.0, 1.0}         \n        };\n        for (int i = 0; i < equations.length; i++) {\n            Complex[] roots = quadraticRoots(\n                equations[i][0], equations[i][1], equations[i][2]);\n            System.out.format(\"%na = %g   b = %g   c = %g%n\",\n                equations[i][0], equations[i][1], equations[i][2]);\n            if (roots[0].equals(roots[1])) {\n                System.out.format(\"X1,2 = %s%n\", roots[0]);\n            } else {\n                System.out.format(\"X1 = %s%n\", roots[0]);\n                System.out.format(\"X2 = %s%n\", roots[1]);\n            }\n        }\n    }\n}\n"}
{"id": 57619, "name": "Roots of a quadratic function", "source": "Translate Fortran to Python: PROGRAM QUADRATIC\n\n IMPLICIT NONE\n INTEGER, PARAMETER :: dp = SELECTED_REAL_KIND(15)\n REAL(dp) :: a, b, c, e, discriminant, rroot1, rroot2\n COMPLEX(dp) :: croot1, croot2\n\n WRITE(*,*) \"Enter the coefficients of the equation ax^2 + bx + c\"\n WRITE(*, \"(A)\", ADVANCE=\"NO\") \"a = \"\n READ *, a\n WRITE(*,\"(A)\", ADVANCE=\"NO\") \"b = \"\n READ *, b\n WRITE(*,\"(A)\", ADVANCE=\"NO\") \"c = \"\n READ *, c\n \n WRITE(*,\"(3(A,E23.15))\") \"Coefficients are: a = \", a, \"   b = \", b, \"   c = \", c\n e = 1.0e-9_dp\n discriminant = b*b - 4.0_dp*a*c\n \n IF (ABS(discriminant) < e) THEN\n    rroot1 = -b / (2.0_dp * a)\n    WRITE(*,*) \"The roots are real and equal:\"\n    WRITE(*,\"(A,E23.15)\") \"Root = \", rroot1\n ELSE IF (discriminant > 0) THEN\n    rroot1 = -(b + SIGN(SQRT(discriminant), b)) / (2.0_dp * a)\n    rroot2 = c / (a * rroot1)\n    WRITE(*,*) \"The roots are real:\"\n    WRITE(*,\"(2(A,E23.15))\") \"Root1 = \", rroot1, \"  Root2 = \", rroot2\n ELSE\n    croot1 = (-b + SQRT(CMPLX(discriminant))) / (2.0_dp*a) \n    croot2 = CONJG(croot1)\n    WRITE(*,*) \"The roots are complex:\" \n    WRITE(*,\"(2(A,2E23.15,A))\") \"Root1 = \", croot1, \"j \", \"  Root2 = \", croot2, \"j\"\n END IF\n", "target": "\n\nimport math\nimport cmath\nimport numpy\n\ndef quad_discriminating_roots(a,b,c, entier = 1e-5):\n    \n    discriminant = b*b - 4*a*c\n    a,b,c,d =complex(a), complex(b), complex(c), complex(discriminant)\n    root1 = (-b + cmath.sqrt(d))/2./a\n    root2 = (-b - cmath.sqrt(d))/2./a\n    if abs(discriminant) < entier:\n        return \"real and equal\", abs(root1), abs(root1)\n    if discriminant > 0:\n        return \"real\", root1.real, root2.real\n    return \"complex\", root1, root2\n\ndef middlebrook(a, b, c):\n    try:\n        q = math.sqrt(a*c)/b\n        f = .5+ math.sqrt(1-4*q*q)/2\n    except ValueError:\n        q = cmath.sqrt(a*c)/b\n        f = .5+ cmath.sqrt(1-4*q*q)/2\n    return (-b/a)*f, -c/(b*f)\n\ndef whatevery(a, b, c):\n    try:\n        d = math.sqrt(b*b-4*a*c)\n    except ValueError:\n        d = cmath.sqrt(b*b-4*a*c)\n    if b > 0:\n        return div(2*c, (-b-d)), div((-b-d), 2*a)\n    else:\n        return div((-b+d), 2*a), div(2*c, (-b+d))\n\ndef div(n, d):\n    \n    try:\n        return n/d\n    except ZeroDivisionError:\n        if n:\n            return n*float('inf')\n        return float('nan')\n\ntestcases = [\n    (3, 4, 4/3),    \n    (3, 2, -1),     \n    (3, 2, 1),      \n    (1, -1e9, 1),   \n    (1, -1e100, 1),\n    (1, -1e200, 1),\n    (1, -1e300, 1),\n]\n\nprint('Naive:')\nfor c in testcases:\n    print(\"{} {:.5} {:.5}\".format(*quad_discriminating_roots(*c)))\n\nprint('\\nMiddlebrook:')\nfor c in testcases:\n    print((\"{:.5} \"*2).format(*middlebrook(*c)))\n\nprint('\\nWhat Every...')\nfor c in testcases:\n    print((\"{:.5} \"*2).format(*whatevery(*c)))\n\nprint('\\nNumpy:')\nfor c in testcases:\n    print((\"{:.5} \"*2).format(*numpy.roots(c)))\n"}
{"id": 57972, "name": "Secure temporary file", "source": "Translate Fortran to Java:         OPEN (F,STATUS = 'SCRATCH')   \n", "target": "import java.io.File;\nimport java.io.IOException;\n\npublic class CreateTempFile {\n    public static void main(String[] args)  {\n        try {\n            \n            File temp = File.createTempFile(\"temp-file-name\", \".tmp\");\n            System.out.println(\"Temp file\u00a0: \" + temp.getAbsolutePath());\n        }\n        catch(IOException e) {\n            e.printStackTrace();\n    \t}\n    }\n}\n"}
{"id": 57973, "name": "Secure temporary file", "source": "Translate Fortran to Python:         OPEN (F,STATUS = 'SCRATCH')   \n", "target": ">>> import tempfile\n>>> invisible = tempfile.TemporaryFile()\n>>> invisible.name\n'<fdopen>'\n>>> visible = tempfile.NamedTemporaryFile()\n>>> visible.name\n'/tmp/tmpZNfc_s'\n>>> visible.close()\n>>> invisible.close()\n"}
{"id": 58638, "name": "Box the compass", "source": "Translate Fortran to C#: Program Compass\n  implicit none\n\n  integer :: i, ind\n  real :: heading\n\n  do i = 0, 32\n    heading = i * 11.25\n    if (mod(i, 3) == 1) then\n      heading = heading + 5.62\n    else if (mod(i, 3) == 2) then\n            heading = heading - 5.62\n    end if\n    ind = mod(i, 32) + 1\n    write(*, \"(i2, a20, f8.2)\") ind, compasspoint(heading), heading\n  end do\n\ncontains\n\nfunction compasspoint(h)\n  character(18) :: compasspoint\n  character(18) :: points(32) = (/ \"North             \", \"North by east     \", \"North-northeast   \", & \n             \"Northeast by north\", \"Northeast         \", \"Northeast by east \", \"East-northeast    \", &\n             \"East by north     \", \"East              \", \"East by south     \", \"East-southeast    \", &\n             \"Southeast by east \", \"Southeast         \", \"Southeast by south\", \"South-southeast   \", &\n             \"South by east     \", \"South             \", \"South by west     \", \"South-southwest   \", &\n             \"Southwest by south\", \"Southwest         \", \"Southwest by west \", \"West-southwest    \", &\n             \"West by south     \", \"West              \", \"West by north     \", \"West-northwest    \", &\n             \"Northwest by west \", \"Northwest         \", \"Northwest by north\", \"North-northwest   \", &\n             \"North by west     \"  /)  \n  real, intent(in) :: h\n  real :: x\n\n  x = h / 11.25 + 1.5\n  if (x >= 33.0) x = x - 32.0\n  compasspoint = points(int(x))\nend function compasspoint\nend program Compass\n", "target": "using System;\nusing System.Collections.Generic;\n\nnamespace BoxTheCompass\n{\n    class Compass\n    {\n        string[] cp = new string[] {\"North\", \"North by east\", \"North-northeast\", \"Northeast by north\", \"Northeast\",\"Northeast by east\", \n\t    \"East-northeast\", \"East by north\", \"East\", \"East by south\", \"East-southeast\", \"Southeast by east\", \"Southeast\", \n            \"Southeast by south\", \"South-southeast\", \"South by east\", \"South\", \"South by west\", \"South-southwest\", \"Southwest by south\", \n            \"Southwest\", \"Southwest by west\", \"West-southwest\", \"West by south\", \"West\", \"West by north\", \"West-northwest\", \n            \"Northwest by west\", \"Northwest\", \"Northwest by north\", \"North-northwest\", \"North by west\", \"North\"};\n\n        public void compassHeading(float a)\n        {\n            int h = Convert.ToInt32(Math.Floor(a / 11.25f + .5f)) % 32;\n            Console.WriteLine( \"{0,2}: {1,-22}\u00a0: {2,6:N}\",h + 1, cp[h], a );\n        }\n    };\n    class Program\n    {\n        static void Main(string[] args)\n       {\n            Compass c = new Compass();\n            float[] degs = new float[] {0.0f, 16.87f, 16.88f, 33.75f, 50.62f, 50.63f, 67.5f, 84.37f, 84.38f, 101.25f, \n                118.12f, 118.13f, 135.0f, 151.87f, 151.88f, 168.75f, 185.62f, 185.63f, 202.5f, 219.37f, 219.38f, 236.25f, \n                253.12f, 253.13f, 270.0f, 286.87f, 286.88f, 303.75f, 320.62f, 320.63f, 337.5f, 354.37f, 354.38f};\n\n            foreach (float d in degs)\n                c.compassHeading(d);\n\n            Console.WriteLine(\"\\nPress any key to continue...\");\n            Console.ReadKey();\n        }\n    }\n}\n"}
{"id": 58639, "name": "Box the compass", "source": "Translate Fortran to C#: Program Compass\n  implicit none\n\n  integer :: i, ind\n  real :: heading\n\n  do i = 0, 32\n    heading = i * 11.25\n    if (mod(i, 3) == 1) then\n      heading = heading + 5.62\n    else if (mod(i, 3) == 2) then\n            heading = heading - 5.62\n    end if\n    ind = mod(i, 32) + 1\n    write(*, \"(i2, a20, f8.2)\") ind, compasspoint(heading), heading\n  end do\n\ncontains\n\nfunction compasspoint(h)\n  character(18) :: compasspoint\n  character(18) :: points(32) = (/ \"North             \", \"North by east     \", \"North-northeast   \", & \n             \"Northeast by north\", \"Northeast         \", \"Northeast by east \", \"East-northeast    \", &\n             \"East by north     \", \"East              \", \"East by south     \", \"East-southeast    \", &\n             \"Southeast by east \", \"Southeast         \", \"Southeast by south\", \"South-southeast   \", &\n             \"South by east     \", \"South             \", \"South by west     \", \"South-southwest   \", &\n             \"Southwest by south\", \"Southwest         \", \"Southwest by west \", \"West-southwest    \", &\n             \"West by south     \", \"West              \", \"West by north     \", \"West-northwest    \", &\n             \"Northwest by west \", \"Northwest         \", \"Northwest by north\", \"North-northwest   \", &\n             \"North by west     \"  /)  \n  real, intent(in) :: h\n  real :: x\n\n  x = h / 11.25 + 1.5\n  if (x >= 33.0) x = x - 32.0\n  compasspoint = points(int(x))\nend function compasspoint\nend program Compass\n", "target": "using System;\nusing System.Collections.Generic;\n\nnamespace BoxTheCompass\n{\n    class Compass\n    {\n        string[] cp = new string[] {\"North\", \"North by east\", \"North-northeast\", \"Northeast by north\", \"Northeast\",\"Northeast by east\", \n\t    \"East-northeast\", \"East by north\", \"East\", \"East by south\", \"East-southeast\", \"Southeast by east\", \"Southeast\", \n            \"Southeast by south\", \"South-southeast\", \"South by east\", \"South\", \"South by west\", \"South-southwest\", \"Southwest by south\", \n            \"Southwest\", \"Southwest by west\", \"West-southwest\", \"West by south\", \"West\", \"West by north\", \"West-northwest\", \n            \"Northwest by west\", \"Northwest\", \"Northwest by north\", \"North-northwest\", \"North by west\", \"North\"};\n\n        public void compassHeading(float a)\n        {\n            int h = Convert.ToInt32(Math.Floor(a / 11.25f + .5f)) % 32;\n            Console.WriteLine( \"{0,2}: {1,-22}\u00a0: {2,6:N}\",h + 1, cp[h], a );\n        }\n    };\n    class Program\n    {\n        static void Main(string[] args)\n       {\n            Compass c = new Compass();\n            float[] degs = new float[] {0.0f, 16.87f, 16.88f, 33.75f, 50.62f, 50.63f, 67.5f, 84.37f, 84.38f, 101.25f, \n                118.12f, 118.13f, 135.0f, 151.87f, 151.88f, 168.75f, 185.62f, 185.63f, 202.5f, 219.37f, 219.38f, 236.25f, \n                253.12f, 253.13f, 270.0f, 286.87f, 286.88f, 303.75f, 320.62f, 320.63f, 337.5f, 354.37f, 354.38f};\n\n            foreach (float d in degs)\n                c.compassHeading(d);\n\n            Console.WriteLine(\"\\nPress any key to continue...\");\n            Console.ReadKey();\n        }\n    }\n}\n"}
{"id": 58645, "name": "Box the compass", "source": "Translate Fortran to Java: Program Compass\n  implicit none\n\n  integer :: i, ind\n  real :: heading\n\n  do i = 0, 32\n    heading = i * 11.25\n    if (mod(i, 3) == 1) then\n      heading = heading + 5.62\n    else if (mod(i, 3) == 2) then\n            heading = heading - 5.62\n    end if\n    ind = mod(i, 32) + 1\n    write(*, \"(i2, a20, f8.2)\") ind, compasspoint(heading), heading\n  end do\n\ncontains\n\nfunction compasspoint(h)\n  character(18) :: compasspoint\n  character(18) :: points(32) = (/ \"North             \", \"North by east     \", \"North-northeast   \", & \n             \"Northeast by north\", \"Northeast         \", \"Northeast by east \", \"East-northeast    \", &\n             \"East by north     \", \"East              \", \"East by south     \", \"East-southeast    \", &\n             \"Southeast by east \", \"Southeast         \", \"Southeast by south\", \"South-southeast   \", &\n             \"South by east     \", \"South             \", \"South by west     \", \"South-southwest   \", &\n             \"Southwest by south\", \"Southwest         \", \"Southwest by west \", \"West-southwest    \", &\n             \"West by south     \", \"West              \", \"West by north     \", \"West-northwest    \", &\n             \"Northwest by west \", \"Northwest         \", \"Northwest by north\", \"North-northwest   \", &\n             \"North by west     \"  /)  \n  real, intent(in) :: h\n  real :: x\n\n  x = h / 11.25 + 1.5\n  if (x >= 33.0) x = x - 32.0\n  compasspoint = points(int(x))\nend function compasspoint\nend program Compass\n", "target": "public class BoxingTheCompass{\n    private static String[] points = new String[32];\n \n    public static void main(String[] args){\n        buildPoints();\n \n        double heading = 0;\n \n        for(int i = 0; i<= 32;i++){\n            heading = i * 11.25;\n            switch(i % 3){\n                case 1:\n                    heading += 5.62;\n                    break;\n                case 2:\n                    heading -= 5.62;\n                    break;\n                default:\n            }\n \n            System.out.printf(\"%s\\t%18s\\t%s\u00b0\\n\",(i % 32) + 1, initialUpper(getPoint(heading)), heading);\n        }\n    }\n \n    private static void buildPoints(){\n        String[] cardinal = {\"north\", \"east\", \"south\", \"west\"};\n        String[] pointDesc = {\"1\", \"1 by 2\", \"1-C\", \"C by 1\", \"C\", \"C by 2\", \"2-C\", \"2 by 1\"};\n \n        String str1, str2, strC;\n \n        for(int i = 0;i <= 3;i++){\n            str1 = cardinal[i];\n            str2 = cardinal[(i + 1) % 4];\n            strC = (str1.equals(\"north\") || str1.equals(\"south\")) ? (str1 + str2): (str2 + str1);\n            for(int j = 0;j <= 7;j++){\n                points[i * 8 + j] = pointDesc[j].replace(\"1\", str1).replace(\"2\", str2).replace(\"C\", strC);\n            }\n        }\n    }\n \n    private static String initialUpper(String s){\n        return s.substring(0, 1).toUpperCase() + s.substring(1);\n    }\n \n    private static String getPoint(double degrees){\n        double testD = (degrees / 11.25) + 0.5;\n        return points[(int)Math.floor(testD % 32)];\n    }\n}\n"}
{"id": 58646, "name": "Box the compass", "source": "Translate Fortran to Java: Program Compass\n  implicit none\n\n  integer :: i, ind\n  real :: heading\n\n  do i = 0, 32\n    heading = i * 11.25\n    if (mod(i, 3) == 1) then\n      heading = heading + 5.62\n    else if (mod(i, 3) == 2) then\n            heading = heading - 5.62\n    end if\n    ind = mod(i, 32) + 1\n    write(*, \"(i2, a20, f8.2)\") ind, compasspoint(heading), heading\n  end do\n\ncontains\n\nfunction compasspoint(h)\n  character(18) :: compasspoint\n  character(18) :: points(32) = (/ \"North             \", \"North by east     \", \"North-northeast   \", & \n             \"Northeast by north\", \"Northeast         \", \"Northeast by east \", \"East-northeast    \", &\n             \"East by north     \", \"East              \", \"East by south     \", \"East-southeast    \", &\n             \"Southeast by east \", \"Southeast         \", \"Southeast by south\", \"South-southeast   \", &\n             \"South by east     \", \"South             \", \"South by west     \", \"South-southwest   \", &\n             \"Southwest by south\", \"Southwest         \", \"Southwest by west \", \"West-southwest    \", &\n             \"West by south     \", \"West              \", \"West by north     \", \"West-northwest    \", &\n             \"Northwest by west \", \"Northwest         \", \"Northwest by north\", \"North-northwest   \", &\n             \"North by west     \"  /)  \n  real, intent(in) :: h\n  real :: x\n\n  x = h / 11.25 + 1.5\n  if (x >= 33.0) x = x - 32.0\n  compasspoint = points(int(x))\nend function compasspoint\nend program Compass\n", "target": "public class BoxingTheCompass{\n    private static String[] points = new String[32];\n \n    public static void main(String[] args){\n        buildPoints();\n \n        double heading = 0;\n \n        for(int i = 0; i<= 32;i++){\n            heading = i * 11.25;\n            switch(i % 3){\n                case 1:\n                    heading += 5.62;\n                    break;\n                case 2:\n                    heading -= 5.62;\n                    break;\n                default:\n            }\n \n            System.out.printf(\"%s\\t%18s\\t%s\u00b0\\n\",(i % 32) + 1, initialUpper(getPoint(heading)), heading);\n        }\n    }\n \n    private static void buildPoints(){\n        String[] cardinal = {\"north\", \"east\", \"south\", \"west\"};\n        String[] pointDesc = {\"1\", \"1 by 2\", \"1-C\", \"C by 1\", \"C\", \"C by 2\", \"2-C\", \"2 by 1\"};\n \n        String str1, str2, strC;\n \n        for(int i = 0;i <= 3;i++){\n            str1 = cardinal[i];\n            str2 = cardinal[(i + 1) % 4];\n            strC = (str1.equals(\"north\") || str1.equals(\"south\")) ? (str1 + str2): (str2 + str1);\n            for(int j = 0;j <= 7;j++){\n                points[i * 8 + j] = pointDesc[j].replace(\"1\", str1).replace(\"2\", str2).replace(\"C\", strC);\n            }\n        }\n    }\n \n    private static String initialUpper(String s){\n        return s.substring(0, 1).toUpperCase() + s.substring(1);\n    }\n \n    private static String getPoint(double degrees){\n        double testD = (degrees / 11.25) + 0.5;\n        return points[(int)Math.floor(testD % 32)];\n    }\n}\n"}
{"id": 58647, "name": "Box the compass", "source": "Translate Fortran to Python: Program Compass\n  implicit none\n\n  integer :: i, ind\n  real :: heading\n\n  do i = 0, 32\n    heading = i * 11.25\n    if (mod(i, 3) == 1) then\n      heading = heading + 5.62\n    else if (mod(i, 3) == 2) then\n            heading = heading - 5.62\n    end if\n    ind = mod(i, 32) + 1\n    write(*, \"(i2, a20, f8.2)\") ind, compasspoint(heading), heading\n  end do\n\ncontains\n\nfunction compasspoint(h)\n  character(18) :: compasspoint\n  character(18) :: points(32) = (/ \"North             \", \"North by east     \", \"North-northeast   \", & \n             \"Northeast by north\", \"Northeast         \", \"Northeast by east \", \"East-northeast    \", &\n             \"East by north     \", \"East              \", \"East by south     \", \"East-southeast    \", &\n             \"Southeast by east \", \"Southeast         \", \"Southeast by south\", \"South-southeast   \", &\n             \"South by east     \", \"South             \", \"South by west     \", \"South-southwest   \", &\n             \"Southwest by south\", \"Southwest         \", \"Southwest by west \", \"West-southwest    \", &\n             \"West by south     \", \"West              \", \"West by north     \", \"West-northwest    \", &\n             \"Northwest by west \", \"Northwest         \", \"Northwest by north\", \"North-northwest   \", &\n             \"North by west     \"  /)  \n  real, intent(in) :: h\n  real :: x\n\n  x = h / 11.25 + 1.5\n  if (x >= 33.0) x = x - 32.0\n  compasspoint = points(int(x))\nend function compasspoint\nend program Compass\n", "target": "majors   = 'north east south west'.split()\nmajors   *= 2 \nquarter1 = 'N,N by E,N-NE,NE by N,NE,NE by E,E-NE,E by N'.split(',')\nquarter2 = [p.replace('NE','EN') for p in quarter1]\n\ndef degrees2compasspoint(d):\n    d = (d % 360) + 360/64\n    majorindex, minor = divmod(d, 90.)\n    majorindex = int(majorindex)\n    minorindex  = int( (minor*4) // 45 )\n    p1, p2 = majors[majorindex: majorindex+2]\n    if p1 in {'north', 'south'}:\n        q = quarter1\n    else:\n        q = quarter2\n    return q[minorindex].replace('N', p1).replace('E', p2).capitalize()\n\nif __name__ == '__main__':\n    for i in range(33):\n        d = i * 11.25\n        m = i % 3\n        if   m == 1: d += 5.62\n        elif m == 2: d -= 5.62\n        n = i % 32 + 1\n        print( '%2i %-18s %7.2f\u00b0' % (n, degrees2compasspoint(d), d) )\n"}
{"id": 58648, "name": "Box the compass", "source": "Translate Fortran to Python: Program Compass\n  implicit none\n\n  integer :: i, ind\n  real :: heading\n\n  do i = 0, 32\n    heading = i * 11.25\n    if (mod(i, 3) == 1) then\n      heading = heading + 5.62\n    else if (mod(i, 3) == 2) then\n            heading = heading - 5.62\n    end if\n    ind = mod(i, 32) + 1\n    write(*, \"(i2, a20, f8.2)\") ind, compasspoint(heading), heading\n  end do\n\ncontains\n\nfunction compasspoint(h)\n  character(18) :: compasspoint\n  character(18) :: points(32) = (/ \"North             \", \"North by east     \", \"North-northeast   \", & \n             \"Northeast by north\", \"Northeast         \", \"Northeast by east \", \"East-northeast    \", &\n             \"East by north     \", \"East              \", \"East by south     \", \"East-southeast    \", &\n             \"Southeast by east \", \"Southeast         \", \"Southeast by south\", \"South-southeast   \", &\n             \"South by east     \", \"South             \", \"South by west     \", \"South-southwest   \", &\n             \"Southwest by south\", \"Southwest         \", \"Southwest by west \", \"West-southwest    \", &\n             \"West by south     \", \"West              \", \"West by north     \", \"West-northwest    \", &\n             \"Northwest by west \", \"Northwest         \", \"Northwest by north\", \"North-northwest   \", &\n             \"North by west     \"  /)  \n  real, intent(in) :: h\n  real :: x\n\n  x = h / 11.25 + 1.5\n  if (x >= 33.0) x = x - 32.0\n  compasspoint = points(int(x))\nend function compasspoint\nend program Compass\n", "target": "majors   = 'north east south west'.split()\nmajors   *= 2 \nquarter1 = 'N,N by E,N-NE,NE by N,NE,NE by E,E-NE,E by N'.split(',')\nquarter2 = [p.replace('NE','EN') for p in quarter1]\n\ndef degrees2compasspoint(d):\n    d = (d % 360) + 360/64\n    majorindex, minor = divmod(d, 90.)\n    majorindex = int(majorindex)\n    minorindex  = int( (minor*4) // 45 )\n    p1, p2 = majors[majorindex: majorindex+2]\n    if p1 in {'north', 'south'}:\n        q = quarter1\n    else:\n        q = quarter2\n    return q[minorindex].replace('N', p1).replace('E', p2).capitalize()\n\nif __name__ == '__main__':\n    for i in range(33):\n        d = i * 11.25\n        m = i % 3\n        if   m == 1: d += 5.62\n        elif m == 2: d -= 5.62\n        n = i % 32 + 1\n        print( '%2i %-18s %7.2f\u00b0' % (n, degrees2compasspoint(d), d) )\n"}
{"id": 59719, "name": "99 bottles of beer", "source": "Translate Fortran to C#: program bottlestest\n\n  implicit none\n\n  integer :: i\n  \n  character(len=*), parameter   :: bwall = \" on the wall\", &\n                                   bottles = \"bottles of beer\", &\n                                   bottle  = \"bottle of beer\", &\n                                   take = \"Take one down, pass it around\", &\n                                   form = \"(I0, ' ', A)\"\n\n  do i = 99,0,-1\n     if ( i /= 1 ) then\n        write (*,form)  i, bottles // bwall\n        if ( i > 0 ) write (*,form)  i, bottles\n     else\n        write (*,form)  i, bottle // bwall\n        write (*,form)  i, bottle\n     end if\n     if ( i > 0 ) write (*,*) take\n  end do\n\nend program bottlestest\n", "target": "using System;\n\nclass Program\n{\n    static void Main(string[] args)\n    {\n        for (int i = 99; i > -1; i--)\n        {\n            if (i == 0)\n            {\n                Console.WriteLine(\"No more bottles of beer on the wall, no more bottles of beer.\");\n                Console.WriteLine(\"Go to the store and buy some more, 99 bottles of beer on the wall.\");\n                break;\n            }\n            if (i == 1)\n            {\n                Console.WriteLine(\"1 bottle of beer on the wall, 1 bottle of beer.\");\n                Console.WriteLine(\"Take one down and pass it around, no more bottles of beer on the wall.\");\n                Console.WriteLine();\n            }\n            else\n            {\n                Console.WriteLine(\"{0} bottles of beer on the wall, {0} bottles of beer.\", i);\n                Console.WriteLine(\"Take one down and pass it around, {0} bottles of beer on the wall.\", i - 1);\n                Console.WriteLine();\n            }\n        }\n    }\n}\n"}
{"id": 59720, "name": "99 bottles of beer", "source": "Translate Fortran to C#: program bottlestest\n\n  implicit none\n\n  integer :: i\n  \n  character(len=*), parameter   :: bwall = \" on the wall\", &\n                                   bottles = \"bottles of beer\", &\n                                   bottle  = \"bottle of beer\", &\n                                   take = \"Take one down, pass it around\", &\n                                   form = \"(I0, ' ', A)\"\n\n  do i = 99,0,-1\n     if ( i /= 1 ) then\n        write (*,form)  i, bottles // bwall\n        if ( i > 0 ) write (*,form)  i, bottles\n     else\n        write (*,form)  i, bottle // bwall\n        write (*,form)  i, bottle\n     end if\n     if ( i > 0 ) write (*,*) take\n  end do\n\nend program bottlestest\n", "target": "using System;\n\nclass Program\n{\n    static void Main(string[] args)\n    {\n        for (int i = 99; i > -1; i--)\n        {\n            if (i == 0)\n            {\n                Console.WriteLine(\"No more bottles of beer on the wall, no more bottles of beer.\");\n                Console.WriteLine(\"Go to the store and buy some more, 99 bottles of beer on the wall.\");\n                break;\n            }\n            if (i == 1)\n            {\n                Console.WriteLine(\"1 bottle of beer on the wall, 1 bottle of beer.\");\n                Console.WriteLine(\"Take one down and pass it around, no more bottles of beer on the wall.\");\n                Console.WriteLine();\n            }\n            else\n            {\n                Console.WriteLine(\"{0} bottles of beer on the wall, {0} bottles of beer.\", i);\n                Console.WriteLine(\"Take one down and pass it around, {0} bottles of beer on the wall.\", i - 1);\n                Console.WriteLine();\n            }\n        }\n    }\n}\n"}
{"id": 59726, "name": "99 bottles of beer", "source": "Translate Fortran to Java: program bottlestest\n\n  implicit none\n\n  integer :: i\n  \n  character(len=*), parameter   :: bwall = \" on the wall\", &\n                                   bottles = \"bottles of beer\", &\n                                   bottle  = \"bottle of beer\", &\n                                   take = \"Take one down, pass it around\", &\n                                   form = \"(I0, ' ', A)\"\n\n  do i = 99,0,-1\n     if ( i /= 1 ) then\n        write (*,form)  i, bottles // bwall\n        if ( i > 0 ) write (*,form)  i, bottles\n     else\n        write (*,form)  i, bottle // bwall\n        write (*,form)  i, bottle\n     end if\n     if ( i > 0 ) write (*,*) take\n  end do\n\nend program bottlestest\n", "target": "module Bottles\n    {\n    @Inject Console console;\n    void run()\n        {\n        function String(Int) num     = i -> i==0 ? \"No\" : i.toString();\n        function String(Int) bottles = i -> i==1 ? \"bottle\" : \"bottles\";\n\n        for (Int remain : 99..1)\n            {\n            console.print($|{num(remain)} {bottles(remain)} of beer on the wall\n                           |{num(remain)} {bottles(remain)} of beer\n                           |Take one down, pass it around\n                           |{num(remain-1)} {bottles(remain-1)} of beer on the wall\n                           |\n                         );\n            }\n        }\n    }\n"}
{"id": 59727, "name": "99 bottles of beer", "source": "Translate Fortran to Java: program bottlestest\n\n  implicit none\n\n  integer :: i\n  \n  character(len=*), parameter   :: bwall = \" on the wall\", &\n                                   bottles = \"bottles of beer\", &\n                                   bottle  = \"bottle of beer\", &\n                                   take = \"Take one down, pass it around\", &\n                                   form = \"(I0, ' ', A)\"\n\n  do i = 99,0,-1\n     if ( i /= 1 ) then\n        write (*,form)  i, bottles // bwall\n        if ( i > 0 ) write (*,form)  i, bottles\n     else\n        write (*,form)  i, bottle // bwall\n        write (*,form)  i, bottle\n     end if\n     if ( i > 0 ) write (*,*) take\n  end do\n\nend program bottlestest\n", "target": "module Bottles\n    {\n    @Inject Console console;\n    void run()\n        {\n        function String(Int) num     = i -> i==0 ? \"No\" : i.toString();\n        function String(Int) bottles = i -> i==1 ? \"bottle\" : \"bottles\";\n\n        for (Int remain : 99..1)\n            {\n            console.print($|{num(remain)} {bottles(remain)} of beer on the wall\n                           |{num(remain)} {bottles(remain)} of beer\n                           |Take one down, pass it around\n                           |{num(remain-1)} {bottles(remain-1)} of beer on the wall\n                           |\n                         );\n            }\n        }\n    }\n"}
{"id": 59728, "name": "99 bottles of beer", "source": "Translate Fortran to Python: program bottlestest\n\n  implicit none\n\n  integer :: i\n  \n  character(len=*), parameter   :: bwall = \" on the wall\", &\n                                   bottles = \"bottles of beer\", &\n                                   bottle  = \"bottle of beer\", &\n                                   take = \"Take one down, pass it around\", &\n                                   form = \"(I0, ' ', A)\"\n\n  do i = 99,0,-1\n     if ( i /= 1 ) then\n        write (*,form)  i, bottles // bwall\n        if ( i > 0 ) write (*,form)  i, bottles\n     else\n        write (*,form)  i, bottle // bwall\n        write (*,form)  i, bottle\n     end if\n     if ( i > 0 ) write (*,*) take\n  end do\n\nend program bottlestest\n", "target": "fun bottles(n): match __args__:\n    (0) => \"No more bottles\"\n    (1) => \"1 bottle\"\n    (_) => \"$n bottles\"\n\nfor n in 99..-1..1:\n    print @format\n"}
{"id": 59729, "name": "99 bottles of beer", "source": "Translate Fortran to Python: program bottlestest\n\n  implicit none\n\n  integer :: i\n  \n  character(len=*), parameter   :: bwall = \" on the wall\", &\n                                   bottles = \"bottles of beer\", &\n                                   bottle  = \"bottle of beer\", &\n                                   take = \"Take one down, pass it around\", &\n                                   form = \"(I0, ' ', A)\"\n\n  do i = 99,0,-1\n     if ( i /= 1 ) then\n        write (*,form)  i, bottles // bwall\n        if ( i > 0 ) write (*,form)  i, bottles\n     else\n        write (*,form)  i, bottle // bwall\n        write (*,form)  i, bottle\n     end if\n     if ( i > 0 ) write (*,*) take\n  end do\n\nend program bottlestest\n", "target": "fun bottles(n): match __args__:\n    (0) => \"No more bottles\"\n    (1) => \"1 bottle\"\n    (_) => \"$n bottles\"\n\nfor n in 99..-1..1:\n    print @format\n"}
{"id": 60139, "name": "Concurrent computing", "source": "Translate Fortran to C#: program concurrency\n  implicit none\n  character(len=*), parameter :: str1 = 'Enjoy'\n  character(len=*), parameter :: str2 = 'Rosetta'\n  character(len=*), parameter :: str3 = 'Code'\n  integer                     :: i\n  real                        :: h\n  real, parameter             :: one_third = 1.0e0/3\n  real, parameter             :: two_thirds = 2.0e0/3\n\n  interface\n     integer function omp_get_thread_num\n     end function omp_get_thread_num\n  end interface\n  interface\n     integer function omp_get_num_threads\n     end function omp_get_num_threads\n  end interface\n\n  \n  \n  do i=1,20\n     \n     \n     if (omp_get_thread_num() == 0 .and. i == 1) then\n        write(*,'(a,i0,a)') 'Using ',omp_get_num_threads(),' threads'\n     end if\n\n     \n     call random_number(h)\n\n     \n     if (h < one_third) then\n        write(*,'(a)') str1\n     else if (h < two_thirds) then\n        write(*,'(a)') str2\n     else\n        write(*,'(a)') str3\n     end if\n     \n  end do\n  \n\nend program concurrency\n", "target": "static Random tRand = new Random();\n\nstatic void Main(string[] args)\n{\n\tThread t = new Thread(new ParameterizedThreadStart(WriteText));\n\tt.Start(\"Enjoy\");\n\n\tt = new Thread(new ParameterizedThreadStart(WriteText));\n\tt.Start(\"Rosetta\");\n\n\tt = new Thread(new ParameterizedThreadStart(WriteText));\n\tt.Start(\"Code\");\n\n\tConsole.ReadLine();\n}\n\nprivate static void WriteText(object p)\n{\n\tThread.Sleep(tRand.Next(1000, 4000));\n\tConsole.WriteLine(p);\n}\n"}
{"id": 60142, "name": "Concurrent computing", "source": "Translate Fortran to Java: program concurrency\n  implicit none\n  character(len=*), parameter :: str1 = 'Enjoy'\n  character(len=*), parameter :: str2 = 'Rosetta'\n  character(len=*), parameter :: str3 = 'Code'\n  integer                     :: i\n  real                        :: h\n  real, parameter             :: one_third = 1.0e0/3\n  real, parameter             :: two_thirds = 2.0e0/3\n\n  interface\n     integer function omp_get_thread_num\n     end function omp_get_thread_num\n  end interface\n  interface\n     integer function omp_get_num_threads\n     end function omp_get_num_threads\n  end interface\n\n  \n  \n  do i=1,20\n     \n     \n     if (omp_get_thread_num() == 0 .and. i == 1) then\n        write(*,'(a,i0,a)') 'Using ',omp_get_num_threads(),' threads'\n     end if\n\n     \n     call random_number(h)\n\n     \n     if (h < one_third) then\n        write(*,'(a)') str1\n     else if (h < two_thirds) then\n        write(*,'(a)') str2\n     else\n        write(*,'(a)') str3\n     end if\n     \n  end do\n  \n\nend program concurrency\n", "target": "import java.util.concurrent.CyclicBarrier;\n\npublic class Threads\n{\n  public static class DelayedMessagePrinter implements Runnable\n  {\n    private CyclicBarrier barrier;\n    private String msg;\n    \n    public DelayedMessagePrinter(CyclicBarrier barrier, String msg)\n    {\n      this.barrier = barrier;\n      this.msg = msg;\n    }\n    \n    public void run()\n    {\n      try\n      {  barrier.await();  }\n      catch (Exception e)\n      {  }\n      System.out.println(msg);\n    }\n  }\n  \n  public static void main(String[] args)\n  {\n    CyclicBarrier barrier = new CyclicBarrier(3);\n    new Thread(new DelayedMessagePrinter(barrier, \"Enjoy\")).start();\n    new Thread(new DelayedMessagePrinter(barrier, \"Rosetta\")).start();\n    new Thread(new DelayedMessagePrinter(barrier, \"Code\")).start();\n  }\n}\n"}
{"id": 60143, "name": "Concurrent computing", "source": "Translate Fortran to Python: program concurrency\n  implicit none\n  character(len=*), parameter :: str1 = 'Enjoy'\n  character(len=*), parameter :: str2 = 'Rosetta'\n  character(len=*), parameter :: str3 = 'Code'\n  integer                     :: i\n  real                        :: h\n  real, parameter             :: one_third = 1.0e0/3\n  real, parameter             :: two_thirds = 2.0e0/3\n\n  interface\n     integer function omp_get_thread_num\n     end function omp_get_thread_num\n  end interface\n  interface\n     integer function omp_get_num_threads\n     end function omp_get_num_threads\n  end interface\n\n  \n  \n  do i=1,20\n     \n     \n     if (omp_get_thread_num() == 0 .and. i == 1) then\n        write(*,'(a,i0,a)') 'Using ',omp_get_num_threads(),' threads'\n     end if\n\n     \n     call random_number(h)\n\n     \n     if (h < one_third) then\n        write(*,'(a)') str1\n     else if (h < two_thirds) then\n        write(*,'(a)') str2\n     else\n        write(*,'(a)') str3\n     end if\n     \n  end do\n  \n\nend program concurrency\n", "target": "let words = [\"Enjoy\", \"Rosetta\", \"Code\"]\n\nfor word in words:\n    (word) |> async (w) =>\n        sleep(random())\n        print(w)\n"}
{"id": 60360, "name": "Strip a set of characters from a string", "source": "Translate Fortran to C#: elemental subroutine strip(string,set)\n  character(len=*), intent(inout) :: string\n  character(len=*), intent(in)    :: set\n  integer                         :: old, new, stride\n  old = 1; new = 1\n  do\n    stride = scan( string( old : ), set )\n    if ( stride > 0 ) then\n      string( new : new+stride-2 ) = string( old : old+stride-2 )\n      old = old+stride\n      new = new+stride-1\n    else\n      string( new : ) = string( old : )\n      return\n    end if\n  end do\nend subroutine strip\n", "target": "using System;\n\npublic static string RemoveCharactersFromString(string testString, string removeChars)\n{\n    char[] charAry = removeChars.ToCharArray();\n    string returnString = testString;\n    foreach (char c in charAry)\n    {\n        while (returnString.IndexOf(c) > -1)\n        {\n            returnString = returnString.Remove(returnString.IndexOf(c), 1);\n        }\n    }\n    return returnString;\n}\n"}
{"id": 60363, "name": "Strip a set of characters from a string", "source": "Translate Fortran to Java: elemental subroutine strip(string,set)\n  character(len=*), intent(inout) :: string\n  character(len=*), intent(in)    :: set\n  integer                         :: old, new, stride\n  old = 1; new = 1\n  do\n    stride = scan( string( old : ), set )\n    if ( stride > 0 ) then\n      string( new : new+stride-2 ) = string( old : old+stride-2 )\n      old = old+stride\n      new = new+stride-1\n    else\n      string( new : ) = string( old : )\n      return\n    end if\n  end do\nend subroutine strip\n", "target": "class StripChars {\n    public static String stripChars(String inString, String toStrip) {\n        return inString.replaceAll(\"[\" + toStrip + \"]\", \"\");\n    }\n\n    public static void main(String[] args) {\n        String sentence = \"She was a soul stripper. She took my heart!\";\n        String chars = \"aei\";\n        System.out.println(\"sentence: \" + sentence);\n        System.out.println(\"to strip: \" + chars);\n        System.out.println(\"stripped: \" + stripChars(sentence, chars));\n    }\n}\n"}
{"id": 60364, "name": "Strip a set of characters from a string", "source": "Translate Fortran to Python: elemental subroutine strip(string,set)\n  character(len=*), intent(inout) :: string\n  character(len=*), intent(in)    :: set\n  integer                         :: old, new, stride\n  old = 1; new = 1\n  do\n    stride = scan( string( old : ), set )\n    if ( stride > 0 ) then\n      string( new : new+stride-2 ) = string( old : old+stride-2 )\n      old = old+stride\n      new = new+stride-1\n    else\n      string( new : ) = string( old : )\n      return\n    end if\n  end do\nend subroutine strip\n", "target": ">>> def stripchars(s, chars):\n...     return s.translate(None, chars)\n... \n>>> stripchars(\"She was a soul stripper. She took my heart!\", \"aei\")\n'Sh ws  soul strppr. Sh took my hrt!'\n"}
{"id": 60631, "name": "Isqrt (integer square root) of X", "source": "Translate Fortran to C#: MODULE INTEGER_SQUARE_ROOT\n    IMPLICIT NONE\n\n    CONTAINS\n        \n    \n    FUNCTION COMMATIZE(NUM) RESULT(OUT_STR)\n         INTEGER(16), INTENT(IN) :: NUM\n         INTEGER(16) I \n         CHARACTER(83) :: TEMP, OUT_STR\n         \n         WRITE(TEMP, '(I0)') NUM\n\n         OUT_STR = \"\"\n\n         DO I=0, LEN_TRIM(TEMP)-1\n             IF (MOD(I, 3) .EQ. 0 .AND. I .GT. 0 .AND. I .LT. LEN_TRIM(TEMP)) THEN\n                  OUT_STR = \",\" // TRIM(OUT_STR)\n             END IF\n             OUT_STR = TEMP(LEN_TRIM(TEMP)-I:LEN_TRIM(TEMP)-I) // TRIM(OUT_STR)\n         END DO\n    END FUNCTION COMMATIZE\n\n\n    \n    FUNCTION ISQRT(NUM)\n        INTEGER(16), INTENT(IN) :: NUM\n        INTEGER(16) :: ISQRT\n        INTEGER(16) :: Q, Z, R, T\n    \n        Q = 1\n        Z = NUM\n        R = 0\n        T = 0\n    \n        DO WHILE (Q .LT. NUM)\n            Q = Q * 4\n        END DO\n    \n        DO WHILE (Q .GT. 1)\n            Q = Q / 4\n            T = Z - R - Q\n            R = R / 2\n            \n            IF (T .GE. 0) THEN\n                Z = T\n                R = R + Q\n            END IF\n        END DO\n    \n        ISQRT = R\n    END FUNCTION ISQRT\n\nEND MODULE INTEGER_SQUARE_ROOT\n\n\n\n\nPROGRAM ISQRT_DEMO\n    USE INTEGER_SQUARE_ROOT\n    IMPLICIT NONE\n\n\n    INTEGER(16), PARAMETER :: MIN_NUM_HZ = 0\n    INTEGER(16), PARAMETER :: MAX_NUM_HZ = 65\n    INTEGER(16), PARAMETER :: POWER_BASE = 7\n    INTEGER(16), PARAMETER :: POWER_MIN = 1\n    INTEGER(16), PARAMETER :: POWER_MAX = 73\n    INTEGER(16), DIMENSION(MAX_NUM_HZ-MIN_NUM_HZ+1) :: VALUES\n    CHARACTER(2) :: HEADER_1\n    CHARACTER(83) :: HEADER_2\n    CHARACTER(83) :: HEADER_3\n\n    INTEGER(16) :: I\n\n    HEADER_1 = \" n\"\n    HEADER_2 = \"7^n\"\n    HEADER_3 = \"isqrt(7^n)\"\n\n    WRITE(*,'(A, I0, A, I0)') \"Integer square root for numbers \", MIN_NUM_HZ, \" to \", MAX_NUM_HZ\n\n    DO I=1, SIZE(VALUES)\n        VALUES(I) = ISQRT(MIN_NUM_HZ+I)\n    END DO\n\n    WRITE(*,'(100I2)') VALUES\n    WRITE(*,*) NEW_LINE('A')\n    \n    WRITE(*,'(A,A,A,A,A)') HEADER_1, \" | \", HEADER_2, \" | \", HEADER_3\n    WRITE(*,*) REPEAT(\"-\", 8+83*2)\n\n    DO I=POWER_MIN,POWER_MAX, 2\n        WRITE(*,'(I2, A, A, A, A)') I, \" | \" // COMMATIZE(7**I), \" | \", COMMATIZE(ISQRT(7**I))\n    END DO\n        \n\n END PROGRAM ISQRT_DEMO\n", "target": "using System;\nusing static System.Console;\nusing BI = System.Numerics.BigInteger;\n\u00a0\nclass Program {\n\u00a0\n    static BI isqrt(BI x) { BI q = 1, r = 0, t; while (q <= x) q <<= 2; while (q > 1) {\n        q >>= 2; t = x - r - q; r >>= 1; if (t >= 0) { x = t; r += q; } } return r; }\n\u00a0\n    static void Main() { const int max = 73, smax = 65;\n        int power_width = ((BI.Pow(7, max).ToString().Length / 3) << 2) + 3,\n            isqrt_width = (power_width + 1) >> 1;\n        WriteLine(\"Integer square root for numbers 0 to {0}:\", smax);\n        for (int n = 0; n <= smax; ++n) Write(\"{0} \", \n            (n / 10).ToString().Replace(\"0\", \" \")); WriteLine();\n        for (int n = 0; n <= smax; ++n) Write(\"{0} \", n % 10); WriteLine();\n        WriteLine(new String('-', (smax << 1) + 1));\n        for (int n = 0; n <= smax; ++n) Write(\"{0} \", isqrt(n));\n        WriteLine(\"\\n\\nInteger square roots of odd powers of 7 from 1 to {0}:\", max);\n        string s = string.Format(\"[0,2] |[1,{0}:n0] |[2,{1}:n0]\",\n            power_width, isqrt_width).Replace(\"[\", \"{\").Replace(\"]\", \"}\");\n        WriteLine(s, \"n\", \"7 ^ n\", \"isqrt(7 ^ n)\");\n        WriteLine(new String('-', power_width + isqrt_width + 6));\n        BI p = 7; for (int n = 1; n <= max; n += 2, p *= 49)\n            WriteLine (s, n, p, isqrt(p)); }\n}\n"}
{"id": 60632, "name": "Isqrt (integer square root) of X", "source": "Translate Fortran to C#: MODULE INTEGER_SQUARE_ROOT\n    IMPLICIT NONE\n\n    CONTAINS\n        \n    \n    FUNCTION COMMATIZE(NUM) RESULT(OUT_STR)\n         INTEGER(16), INTENT(IN) :: NUM\n         INTEGER(16) I \n         CHARACTER(83) :: TEMP, OUT_STR\n         \n         WRITE(TEMP, '(I0)') NUM\n\n         OUT_STR = \"\"\n\n         DO I=0, LEN_TRIM(TEMP)-1\n             IF (MOD(I, 3) .EQ. 0 .AND. I .GT. 0 .AND. I .LT. LEN_TRIM(TEMP)) THEN\n                  OUT_STR = \",\" // TRIM(OUT_STR)\n             END IF\n             OUT_STR = TEMP(LEN_TRIM(TEMP)-I:LEN_TRIM(TEMP)-I) // TRIM(OUT_STR)\n         END DO\n    END FUNCTION COMMATIZE\n\n\n    \n    FUNCTION ISQRT(NUM)\n        INTEGER(16), INTENT(IN) :: NUM\n        INTEGER(16) :: ISQRT\n        INTEGER(16) :: Q, Z, R, T\n    \n        Q = 1\n        Z = NUM\n        R = 0\n        T = 0\n    \n        DO WHILE (Q .LT. NUM)\n            Q = Q * 4\n        END DO\n    \n        DO WHILE (Q .GT. 1)\n            Q = Q / 4\n            T = Z - R - Q\n            R = R / 2\n            \n            IF (T .GE. 0) THEN\n                Z = T\n                R = R + Q\n            END IF\n        END DO\n    \n        ISQRT = R\n    END FUNCTION ISQRT\n\nEND MODULE INTEGER_SQUARE_ROOT\n\n\n\n\nPROGRAM ISQRT_DEMO\n    USE INTEGER_SQUARE_ROOT\n    IMPLICIT NONE\n\n\n    INTEGER(16), PARAMETER :: MIN_NUM_HZ = 0\n    INTEGER(16), PARAMETER :: MAX_NUM_HZ = 65\n    INTEGER(16), PARAMETER :: POWER_BASE = 7\n    INTEGER(16), PARAMETER :: POWER_MIN = 1\n    INTEGER(16), PARAMETER :: POWER_MAX = 73\n    INTEGER(16), DIMENSION(MAX_NUM_HZ-MIN_NUM_HZ+1) :: VALUES\n    CHARACTER(2) :: HEADER_1\n    CHARACTER(83) :: HEADER_2\n    CHARACTER(83) :: HEADER_3\n\n    INTEGER(16) :: I\n\n    HEADER_1 = \" n\"\n    HEADER_2 = \"7^n\"\n    HEADER_3 = \"isqrt(7^n)\"\n\n    WRITE(*,'(A, I0, A, I0)') \"Integer square root for numbers \", MIN_NUM_HZ, \" to \", MAX_NUM_HZ\n\n    DO I=1, SIZE(VALUES)\n        VALUES(I) = ISQRT(MIN_NUM_HZ+I)\n    END DO\n\n    WRITE(*,'(100I2)') VALUES\n    WRITE(*,*) NEW_LINE('A')\n    \n    WRITE(*,'(A,A,A,A,A)') HEADER_1, \" | \", HEADER_2, \" | \", HEADER_3\n    WRITE(*,*) REPEAT(\"-\", 8+83*2)\n\n    DO I=POWER_MIN,POWER_MAX, 2\n        WRITE(*,'(I2, A, A, A, A)') I, \" | \" // COMMATIZE(7**I), \" | \", COMMATIZE(ISQRT(7**I))\n    END DO\n        \n\n END PROGRAM ISQRT_DEMO\n", "target": "using System;\nusing static System.Console;\nusing BI = System.Numerics.BigInteger;\n\u00a0\nclass Program {\n\u00a0\n    static BI isqrt(BI x) { BI q = 1, r = 0, t; while (q <= x) q <<= 2; while (q > 1) {\n        q >>= 2; t = x - r - q; r >>= 1; if (t >= 0) { x = t; r += q; } } return r; }\n\u00a0\n    static void Main() { const int max = 73, smax = 65;\n        int power_width = ((BI.Pow(7, max).ToString().Length / 3) << 2) + 3,\n            isqrt_width = (power_width + 1) >> 1;\n        WriteLine(\"Integer square root for numbers 0 to {0}:\", smax);\n        for (int n = 0; n <= smax; ++n) Write(\"{0} \", \n            (n / 10).ToString().Replace(\"0\", \" \")); WriteLine();\n        for (int n = 0; n <= smax; ++n) Write(\"{0} \", n % 10); WriteLine();\n        WriteLine(new String('-', (smax << 1) + 1));\n        for (int n = 0; n <= smax; ++n) Write(\"{0} \", isqrt(n));\n        WriteLine(\"\\n\\nInteger square roots of odd powers of 7 from 1 to {0}:\", max);\n        string s = string.Format(\"[0,2] |[1,{0}:n0] |[2,{1}:n0]\",\n            power_width, isqrt_width).Replace(\"[\", \"{\").Replace(\"]\", \"}\");\n        WriteLine(s, \"n\", \"7 ^ n\", \"isqrt(7 ^ n)\");\n        WriteLine(new String('-', power_width + isqrt_width + 6));\n        BI p = 7; for (int n = 1; n <= max; n += 2, p *= 49)\n            WriteLine (s, n, p, isqrt(p)); }\n}\n"}
{"id": 60637, "name": "Isqrt (integer square root) of X", "source": "Translate Fortran to Java: MODULE INTEGER_SQUARE_ROOT\n    IMPLICIT NONE\n\n    CONTAINS\n        \n    \n    FUNCTION COMMATIZE(NUM) RESULT(OUT_STR)\n         INTEGER(16), INTENT(IN) :: NUM\n         INTEGER(16) I \n         CHARACTER(83) :: TEMP, OUT_STR\n         \n         WRITE(TEMP, '(I0)') NUM\n\n         OUT_STR = \"\"\n\n         DO I=0, LEN_TRIM(TEMP)-1\n             IF (MOD(I, 3) .EQ. 0 .AND. I .GT. 0 .AND. I .LT. LEN_TRIM(TEMP)) THEN\n                  OUT_STR = \",\" // TRIM(OUT_STR)\n             END IF\n             OUT_STR = TEMP(LEN_TRIM(TEMP)-I:LEN_TRIM(TEMP)-I) // TRIM(OUT_STR)\n         END DO\n    END FUNCTION COMMATIZE\n\n\n    \n    FUNCTION ISQRT(NUM)\n        INTEGER(16), INTENT(IN) :: NUM\n        INTEGER(16) :: ISQRT\n        INTEGER(16) :: Q, Z, R, T\n    \n        Q = 1\n        Z = NUM\n        R = 0\n        T = 0\n    \n        DO WHILE (Q .LT. NUM)\n            Q = Q * 4\n        END DO\n    \n        DO WHILE (Q .GT. 1)\n            Q = Q / 4\n            T = Z - R - Q\n            R = R / 2\n            \n            IF (T .GE. 0) THEN\n                Z = T\n                R = R + Q\n            END IF\n        END DO\n    \n        ISQRT = R\n    END FUNCTION ISQRT\n\nEND MODULE INTEGER_SQUARE_ROOT\n\n\n\n\nPROGRAM ISQRT_DEMO\n    USE INTEGER_SQUARE_ROOT\n    IMPLICIT NONE\n\n\n    INTEGER(16), PARAMETER :: MIN_NUM_HZ = 0\n    INTEGER(16), PARAMETER :: MAX_NUM_HZ = 65\n    INTEGER(16), PARAMETER :: POWER_BASE = 7\n    INTEGER(16), PARAMETER :: POWER_MIN = 1\n    INTEGER(16), PARAMETER :: POWER_MAX = 73\n    INTEGER(16), DIMENSION(MAX_NUM_HZ-MIN_NUM_HZ+1) :: VALUES\n    CHARACTER(2) :: HEADER_1\n    CHARACTER(83) :: HEADER_2\n    CHARACTER(83) :: HEADER_3\n\n    INTEGER(16) :: I\n\n    HEADER_1 = \" n\"\n    HEADER_2 = \"7^n\"\n    HEADER_3 = \"isqrt(7^n)\"\n\n    WRITE(*,'(A, I0, A, I0)') \"Integer square root for numbers \", MIN_NUM_HZ, \" to \", MAX_NUM_HZ\n\n    DO I=1, SIZE(VALUES)\n        VALUES(I) = ISQRT(MIN_NUM_HZ+I)\n    END DO\n\n    WRITE(*,'(100I2)') VALUES\n    WRITE(*,*) NEW_LINE('A')\n    \n    WRITE(*,'(A,A,A,A,A)') HEADER_1, \" | \", HEADER_2, \" | \", HEADER_3\n    WRITE(*,*) REPEAT(\"-\", 8+83*2)\n\n    DO I=POWER_MIN,POWER_MAX, 2\n        WRITE(*,'(I2, A, A, A, A)') I, \" | \" // COMMATIZE(7**I), \" | \", COMMATIZE(ISQRT(7**I))\n    END DO\n        \n\n END PROGRAM ISQRT_DEMO\n", "target": "import java.math.BigInteger;\n\npublic class Isqrt {\n    private static BigInteger isqrt(BigInteger x) {\n        if (x.compareTo(BigInteger.ZERO) < 0) {\n            throw new IllegalArgumentException(\"Argument cannot be negative\");\n        }\n        var q = BigInteger.ONE;\n        while (q.compareTo(x) <= 0) {\n            q = q.shiftLeft(2);\n        }\n        var z = x;\n        var r = BigInteger.ZERO;\n        while (q.compareTo(BigInteger.ONE) > 0) {\n            q = q.shiftRight(2);\n            var t = z;\n            t = t.subtract(r);\n            t = t.subtract(q);\n            r = r.shiftRight(1);\n            if (t.compareTo(BigInteger.ZERO) >= 0) {\n                z = t;\n                r = r.add(q);\n            }\n        }\n        return r;\n    }\n\n    public static void main(String[] args) {\n        System.out.println(\"The integer square root of integers from 0 to 65 are:\");\n        for (int i = 0; i <= 65; i++) {\n            System.out.printf(\"%s \", isqrt(BigInteger.valueOf(i)));\n        }\n        System.out.println();\n\n        System.out.println(\"The integer square roots of powers of 7 from 7^1 up to 7^73 are:\");\n        System.out.println(\"power                                    7 ^ power                                                 integer square root\");\n        System.out.println(\"----- --------------------------------------------------------------------------------- -----------------------------------------\");\n        var pow7 = BigInteger.valueOf(7);\n        var bi49 = BigInteger.valueOf(49);\n        for (int i = 1; i < 74; i += 2) {\n            System.out.printf(\"%2d\u00a0%,84d\u00a0%,41d\\n\", i, pow7, isqrt(pow7));\n            pow7 = pow7.multiply(bi49);\n        }\n    }\n}\n"}
{"id": 60638, "name": "Isqrt (integer square root) of X", "source": "Translate Fortran to Java: MODULE INTEGER_SQUARE_ROOT\n    IMPLICIT NONE\n\n    CONTAINS\n        \n    \n    FUNCTION COMMATIZE(NUM) RESULT(OUT_STR)\n         INTEGER(16), INTENT(IN) :: NUM\n         INTEGER(16) I \n         CHARACTER(83) :: TEMP, OUT_STR\n         \n         WRITE(TEMP, '(I0)') NUM\n\n         OUT_STR = \"\"\n\n         DO I=0, LEN_TRIM(TEMP)-1\n             IF (MOD(I, 3) .EQ. 0 .AND. I .GT. 0 .AND. I .LT. LEN_TRIM(TEMP)) THEN\n                  OUT_STR = \",\" // TRIM(OUT_STR)\n             END IF\n             OUT_STR = TEMP(LEN_TRIM(TEMP)-I:LEN_TRIM(TEMP)-I) // TRIM(OUT_STR)\n         END DO\n    END FUNCTION COMMATIZE\n\n\n    \n    FUNCTION ISQRT(NUM)\n        INTEGER(16), INTENT(IN) :: NUM\n        INTEGER(16) :: ISQRT\n        INTEGER(16) :: Q, Z, R, T\n    \n        Q = 1\n        Z = NUM\n        R = 0\n        T = 0\n    \n        DO WHILE (Q .LT. NUM)\n            Q = Q * 4\n        END DO\n    \n        DO WHILE (Q .GT. 1)\n            Q = Q / 4\n            T = Z - R - Q\n            R = R / 2\n            \n            IF (T .GE. 0) THEN\n                Z = T\n                R = R + Q\n            END IF\n        END DO\n    \n        ISQRT = R\n    END FUNCTION ISQRT\n\nEND MODULE INTEGER_SQUARE_ROOT\n\n\n\n\nPROGRAM ISQRT_DEMO\n    USE INTEGER_SQUARE_ROOT\n    IMPLICIT NONE\n\n\n    INTEGER(16), PARAMETER :: MIN_NUM_HZ = 0\n    INTEGER(16), PARAMETER :: MAX_NUM_HZ = 65\n    INTEGER(16), PARAMETER :: POWER_BASE = 7\n    INTEGER(16), PARAMETER :: POWER_MIN = 1\n    INTEGER(16), PARAMETER :: POWER_MAX = 73\n    INTEGER(16), DIMENSION(MAX_NUM_HZ-MIN_NUM_HZ+1) :: VALUES\n    CHARACTER(2) :: HEADER_1\n    CHARACTER(83) :: HEADER_2\n    CHARACTER(83) :: HEADER_3\n\n    INTEGER(16) :: I\n\n    HEADER_1 = \" n\"\n    HEADER_2 = \"7^n\"\n    HEADER_3 = \"isqrt(7^n)\"\n\n    WRITE(*,'(A, I0, A, I0)') \"Integer square root for numbers \", MIN_NUM_HZ, \" to \", MAX_NUM_HZ\n\n    DO I=1, SIZE(VALUES)\n        VALUES(I) = ISQRT(MIN_NUM_HZ+I)\n    END DO\n\n    WRITE(*,'(100I2)') VALUES\n    WRITE(*,*) NEW_LINE('A')\n    \n    WRITE(*,'(A,A,A,A,A)') HEADER_1, \" | \", HEADER_2, \" | \", HEADER_3\n    WRITE(*,*) REPEAT(\"-\", 8+83*2)\n\n    DO I=POWER_MIN,POWER_MAX, 2\n        WRITE(*,'(I2, A, A, A, A)') I, \" | \" // COMMATIZE(7**I), \" | \", COMMATIZE(ISQRT(7**I))\n    END DO\n        \n\n END PROGRAM ISQRT_DEMO\n", "target": "import java.math.BigInteger;\n\npublic class Isqrt {\n    private static BigInteger isqrt(BigInteger x) {\n        if (x.compareTo(BigInteger.ZERO) < 0) {\n            throw new IllegalArgumentException(\"Argument cannot be negative\");\n        }\n        var q = BigInteger.ONE;\n        while (q.compareTo(x) <= 0) {\n            q = q.shiftLeft(2);\n        }\n        var z = x;\n        var r = BigInteger.ZERO;\n        while (q.compareTo(BigInteger.ONE) > 0) {\n            q = q.shiftRight(2);\n            var t = z;\n            t = t.subtract(r);\n            t = t.subtract(q);\n            r = r.shiftRight(1);\n            if (t.compareTo(BigInteger.ZERO) >= 0) {\n                z = t;\n                r = r.add(q);\n            }\n        }\n        return r;\n    }\n\n    public static void main(String[] args) {\n        System.out.println(\"The integer square root of integers from 0 to 65 are:\");\n        for (int i = 0; i <= 65; i++) {\n            System.out.printf(\"%s \", isqrt(BigInteger.valueOf(i)));\n        }\n        System.out.println();\n\n        System.out.println(\"The integer square roots of powers of 7 from 7^1 up to 7^73 are:\");\n        System.out.println(\"power                                    7 ^ power                                                 integer square root\");\n        System.out.println(\"----- --------------------------------------------------------------------------------- -----------------------------------------\");\n        var pow7 = BigInteger.valueOf(7);\n        var bi49 = BigInteger.valueOf(49);\n        for (int i = 1; i < 74; i += 2) {\n            System.out.printf(\"%2d\u00a0%,84d\u00a0%,41d\\n\", i, pow7, isqrt(pow7));\n            pow7 = pow7.multiply(bi49);\n        }\n    }\n}\n"}
{"id": 60639, "name": "Isqrt (integer square root) of X", "source": "Translate Fortran to Python: MODULE INTEGER_SQUARE_ROOT\n    IMPLICIT NONE\n\n    CONTAINS\n        \n    \n    FUNCTION COMMATIZE(NUM) RESULT(OUT_STR)\n         INTEGER(16), INTENT(IN) :: NUM\n         INTEGER(16) I \n         CHARACTER(83) :: TEMP, OUT_STR\n         \n         WRITE(TEMP, '(I0)') NUM\n\n         OUT_STR = \"\"\n\n         DO I=0, LEN_TRIM(TEMP)-1\n             IF (MOD(I, 3) .EQ. 0 .AND. I .GT. 0 .AND. I .LT. LEN_TRIM(TEMP)) THEN\n                  OUT_STR = \",\" // TRIM(OUT_STR)\n             END IF\n             OUT_STR = TEMP(LEN_TRIM(TEMP)-I:LEN_TRIM(TEMP)-I) // TRIM(OUT_STR)\n         END DO\n    END FUNCTION COMMATIZE\n\n\n    \n    FUNCTION ISQRT(NUM)\n        INTEGER(16), INTENT(IN) :: NUM\n        INTEGER(16) :: ISQRT\n        INTEGER(16) :: Q, Z, R, T\n    \n        Q = 1\n        Z = NUM\n        R = 0\n        T = 0\n    \n        DO WHILE (Q .LT. NUM)\n            Q = Q * 4\n        END DO\n    \n        DO WHILE (Q .GT. 1)\n            Q = Q / 4\n            T = Z - R - Q\n            R = R / 2\n            \n            IF (T .GE. 0) THEN\n                Z = T\n                R = R + Q\n            END IF\n        END DO\n    \n        ISQRT = R\n    END FUNCTION ISQRT\n\nEND MODULE INTEGER_SQUARE_ROOT\n\n\n\n\nPROGRAM ISQRT_DEMO\n    USE INTEGER_SQUARE_ROOT\n    IMPLICIT NONE\n\n\n    INTEGER(16), PARAMETER :: MIN_NUM_HZ = 0\n    INTEGER(16), PARAMETER :: MAX_NUM_HZ = 65\n    INTEGER(16), PARAMETER :: POWER_BASE = 7\n    INTEGER(16), PARAMETER :: POWER_MIN = 1\n    INTEGER(16), PARAMETER :: POWER_MAX = 73\n    INTEGER(16), DIMENSION(MAX_NUM_HZ-MIN_NUM_HZ+1) :: VALUES\n    CHARACTER(2) :: HEADER_1\n    CHARACTER(83) :: HEADER_2\n    CHARACTER(83) :: HEADER_3\n\n    INTEGER(16) :: I\n\n    HEADER_1 = \" n\"\n    HEADER_2 = \"7^n\"\n    HEADER_3 = \"isqrt(7^n)\"\n\n    WRITE(*,'(A, I0, A, I0)') \"Integer square root for numbers \", MIN_NUM_HZ, \" to \", MAX_NUM_HZ\n\n    DO I=1, SIZE(VALUES)\n        VALUES(I) = ISQRT(MIN_NUM_HZ+I)\n    END DO\n\n    WRITE(*,'(100I2)') VALUES\n    WRITE(*,*) NEW_LINE('A')\n    \n    WRITE(*,'(A,A,A,A,A)') HEADER_1, \" | \", HEADER_2, \" | \", HEADER_3\n    WRITE(*,*) REPEAT(\"-\", 8+83*2)\n\n    DO I=POWER_MIN,POWER_MAX, 2\n        WRITE(*,'(I2, A, A, A, A)') I, \" | \" // COMMATIZE(7**I), \" | \", COMMATIZE(ISQRT(7**I))\n    END DO\n        \n\n END PROGRAM ISQRT_DEMO\n", "target": "def isqrt ( x ):\n    q = 1\n    while q <= x : \n        q *= 4\n    z,r = x,0\n    while q > 1 :\n        q  /= 4\n        t,r = z-r-q,r/2\n        if t >= 0 :\n            z,r = t,r+q\n    return r \n\nprint ' '.join( '%d'%isqrt( n ) for n in xrange( 66 ))\nprint '\\n'.join( '{0:114,} = isqrt( 7^{1:3} )'.format( isqrt( 7**n ),n ) for n in range( 1,204,2 ))\n"}
{"id": 60640, "name": "Isqrt (integer square root) of X", "source": "Translate Fortran to Python: MODULE INTEGER_SQUARE_ROOT\n    IMPLICIT NONE\n\n    CONTAINS\n        \n    \n    FUNCTION COMMATIZE(NUM) RESULT(OUT_STR)\n         INTEGER(16), INTENT(IN) :: NUM\n         INTEGER(16) I \n         CHARACTER(83) :: TEMP, OUT_STR\n         \n         WRITE(TEMP, '(I0)') NUM\n\n         OUT_STR = \"\"\n\n         DO I=0, LEN_TRIM(TEMP)-1\n             IF (MOD(I, 3) .EQ. 0 .AND. I .GT. 0 .AND. I .LT. LEN_TRIM(TEMP)) THEN\n                  OUT_STR = \",\" // TRIM(OUT_STR)\n             END IF\n             OUT_STR = TEMP(LEN_TRIM(TEMP)-I:LEN_TRIM(TEMP)-I) // TRIM(OUT_STR)\n         END DO\n    END FUNCTION COMMATIZE\n\n\n    \n    FUNCTION ISQRT(NUM)\n        INTEGER(16), INTENT(IN) :: NUM\n        INTEGER(16) :: ISQRT\n        INTEGER(16) :: Q, Z, R, T\n    \n        Q = 1\n        Z = NUM\n        R = 0\n        T = 0\n    \n        DO WHILE (Q .LT. NUM)\n            Q = Q * 4\n        END DO\n    \n        DO WHILE (Q .GT. 1)\n            Q = Q / 4\n            T = Z - R - Q\n            R = R / 2\n            \n            IF (T .GE. 0) THEN\n                Z = T\n                R = R + Q\n            END IF\n        END DO\n    \n        ISQRT = R\n    END FUNCTION ISQRT\n\nEND MODULE INTEGER_SQUARE_ROOT\n\n\n\n\nPROGRAM ISQRT_DEMO\n    USE INTEGER_SQUARE_ROOT\n    IMPLICIT NONE\n\n\n    INTEGER(16), PARAMETER :: MIN_NUM_HZ = 0\n    INTEGER(16), PARAMETER :: MAX_NUM_HZ = 65\n    INTEGER(16), PARAMETER :: POWER_BASE = 7\n    INTEGER(16), PARAMETER :: POWER_MIN = 1\n    INTEGER(16), PARAMETER :: POWER_MAX = 73\n    INTEGER(16), DIMENSION(MAX_NUM_HZ-MIN_NUM_HZ+1) :: VALUES\n    CHARACTER(2) :: HEADER_1\n    CHARACTER(83) :: HEADER_2\n    CHARACTER(83) :: HEADER_3\n\n    INTEGER(16) :: I\n\n    HEADER_1 = \" n\"\n    HEADER_2 = \"7^n\"\n    HEADER_3 = \"isqrt(7^n)\"\n\n    WRITE(*,'(A, I0, A, I0)') \"Integer square root for numbers \", MIN_NUM_HZ, \" to \", MAX_NUM_HZ\n\n    DO I=1, SIZE(VALUES)\n        VALUES(I) = ISQRT(MIN_NUM_HZ+I)\n    END DO\n\n    WRITE(*,'(100I2)') VALUES\n    WRITE(*,*) NEW_LINE('A')\n    \n    WRITE(*,'(A,A,A,A,A)') HEADER_1, \" | \", HEADER_2, \" | \", HEADER_3\n    WRITE(*,*) REPEAT(\"-\", 8+83*2)\n\n    DO I=POWER_MIN,POWER_MAX, 2\n        WRITE(*,'(I2, A, A, A, A)') I, \" | \" // COMMATIZE(7**I), \" | \", COMMATIZE(ISQRT(7**I))\n    END DO\n        \n\n END PROGRAM ISQRT_DEMO\n", "target": "def isqrt ( x ):\n    q = 1\n    while q <= x : \n        q *= 4\n    z,r = x,0\n    while q > 1 :\n        q  /= 4\n        t,r = z-r-q,r/2\n        if t >= 0 :\n            z,r = t,r+q\n    return r \n\nprint ' '.join( '%d'%isqrt( n ) for n in xrange( 66 ))\nprint '\\n'.join( '{0:114,} = isqrt( 7^{1:3} )'.format( isqrt( 7**n ),n ) for n in range( 1,204,2 ))\n"}
{"id": 61310, "name": "Factorial", "source": "Translate Fortran to C#: nfactorial = PRODUCT((/(i, i=1,n)/))\n", "target": "using System;\n\nclass Program\n{\n    static int Factorial(int number)\n    {\n        if(number < 0) \n            throw new ArgumentOutOfRangeException(nameof(number), number, \"Must be zero or a positive number.\");\n\n        var accumulator = 1;\n        for (var factor = 1; factor <= number; factor++)\n        {\n            accumulator *= factor;\n        }\n        return accumulator;\n    }\n\n    static void Main()\n    {\n        Console.WriteLine(Factorial(10));\n    }\n}\n"}
{"id": 61313, "name": "Factorial", "source": "Translate Fortran to Java: nfactorial = PRODUCT((/(i, i=1,n)/))\n", "target": "module ShowFactorials\n    {\n    static <Value extends IntNumber> Value factorial(Value n)\n        {\n        assert:arg n >= Value.zero();\n        return n <= Value.one() ? n : n * factorial(n-Value.one());\n        }\n\n    @Inject Console console;\n    void run()\n        {\n        \n        UInt128 bigNum = 34;\n        console.print($\"factorial({bigNum})={factorial(bigNum)}\");\n\n        \n        for (Int i : 10..-1)\n            {\n            console.print($\"factorial({i})={factorial(i)}\");\n            }\n        }\n    }\n"}
{"id": 61539, "name": "Polynomial regression", "source": "Translate Fortran to C#: module fitting\ncontains\n\n  function polyfit(vx, vy, d)\n    implicit none\n    integer, intent(in)                   :: d\n    integer, parameter                    :: dp = selected_real_kind(15, 307)\n    real(dp), dimension(d+1)              :: polyfit\n    real(dp), dimension(:), intent(in)    :: vx, vy\n   \n    real(dp), dimension(:,:), allocatable :: X\n    real(dp), dimension(:,:), allocatable :: XT\n    real(dp), dimension(:,:), allocatable :: XTX\n   \n    integer :: i, j\n   \n    integer     :: n, lda, lwork\n    integer :: info\n    integer, dimension(:), allocatable :: ipiv\n    real(dp), dimension(:), allocatable :: work\n   \n    n = d+1\n    lda = n\n    lwork = n\n   \n    allocate(ipiv(n))\n    allocate(work(lwork))\n    allocate(XT(n, size(vx)))\n    allocate(X(size(vx), n))\n    allocate(XTX(n, n))\n   \n    \n    do i = 0, d\n       do j = 1, size(vx)\n          X(j, i+1) = vx(j)**i\n       end do\n    end do\n   \n    XT  = transpose(X)\n    XTX = matmul(XT, X)\n   \n    \n    call DGETRF(n, n, XTX, lda, ipiv, info)\n    if ( info /= 0 ) then\n       print *, \"problem\"\n       return\n    end if\n    call DGETRI(n, XTX, lda, ipiv, work, lwork, info)\n    if ( info /= 0 ) then\n       print *, \"problem\"\n       return\n    end if\n    \n    polyfit = matmul( matmul(XTX, XT), vy)\n    \n    deallocate(ipiv)\n    deallocate(work)\n    deallocate(X)\n    deallocate(XT)\n    deallocate(XTX)\n  \n  end function\n \nend module\n", "target": "        public static double[] Polyfit(double[] x, double[] y, int degree)\n        {\n            \n            var v = new DenseMatrix(x.Length, degree + 1);\n            for (int i = 0; i < v.RowCount; i++)\n                for (int j = 0; j <= degree; j++) v[i, j] = Math.Pow(x[i], j);\n            var yv = new DenseVector(y).ToColumnMatrix();\n            QR<double> qr = v.QR();\n            \n            \n            var r = qr.R.SubMatrix(0, degree + 1, 0, degree + 1);\n            var q = v.Multiply(r.Inverse());\n            var p = r.Inverse().Multiply(q.TransposeThisAndMultiply(yv));\n            return p.Column(0).ToArray();\n        }\n"}
{"id": 61542, "name": "Polynomial regression", "source": "Translate Fortran to Java: module fitting\ncontains\n\n  function polyfit(vx, vy, d)\n    implicit none\n    integer, intent(in)                   :: d\n    integer, parameter                    :: dp = selected_real_kind(15, 307)\n    real(dp), dimension(d+1)              :: polyfit\n    real(dp), dimension(:), intent(in)    :: vx, vy\n   \n    real(dp), dimension(:,:), allocatable :: X\n    real(dp), dimension(:,:), allocatable :: XT\n    real(dp), dimension(:,:), allocatable :: XTX\n   \n    integer :: i, j\n   \n    integer     :: n, lda, lwork\n    integer :: info\n    integer, dimension(:), allocatable :: ipiv\n    real(dp), dimension(:), allocatable :: work\n   \n    n = d+1\n    lda = n\n    lwork = n\n   \n    allocate(ipiv(n))\n    allocate(work(lwork))\n    allocate(XT(n, size(vx)))\n    allocate(X(size(vx), n))\n    allocate(XTX(n, n))\n   \n    \n    do i = 0, d\n       do j = 1, size(vx)\n          X(j, i+1) = vx(j)**i\n       end do\n    end do\n   \n    XT  = transpose(X)\n    XTX = matmul(XT, X)\n   \n    \n    call DGETRF(n, n, XTX, lda, ipiv, info)\n    if ( info /= 0 ) then\n       print *, \"problem\"\n       return\n    end if\n    call DGETRI(n, XTX, lda, ipiv, work, lwork, info)\n    if ( info /= 0 ) then\n       print *, \"problem\"\n       return\n    end if\n    \n    polyfit = matmul( matmul(XTX, XT), vy)\n    \n    deallocate(ipiv)\n    deallocate(work)\n    deallocate(X)\n    deallocate(XT)\n    deallocate(XTX)\n  \n  end function\n \nend module\n", "target": "import java.util.Arrays;\nimport java.util.function.IntToDoubleFunction;\nimport java.util.stream.IntStream;\n\npublic class PolynomialRegression {\n    private static void polyRegression(int[] x, int[] y) {\n        int n = x.length;\n        double xm = Arrays.stream(x).average().orElse(Double.NaN);\n        double ym = Arrays.stream(y).average().orElse(Double.NaN);\n        double x2m = Arrays.stream(x).map(a -> a * a).average().orElse(Double.NaN);\n        double x3m = Arrays.stream(x).map(a -> a * a * a).average().orElse(Double.NaN);\n        double x4m = Arrays.stream(x).map(a -> a * a * a * a).average().orElse(Double.NaN);\n        double xym = 0.0;\n        for (int i = 0; i < x.length && i < y.length; ++i) {\n            xym += x[i] * y[i];\n        }\n        xym /= Math.min(x.length, y.length);\n        double x2ym = 0.0;\n        for (int i = 0; i < x.length && i < y.length; ++i) {\n            x2ym += x[i] * x[i] * y[i];\n        }\n        x2ym /= Math.min(x.length, y.length);\n\n        double sxx = x2m - xm * xm;\n        double sxy = xym - xm * ym;\n        double sxx2 = x3m - xm * x2m;\n        double sx2x2 = x4m - x2m * x2m;\n        double sx2y = x2ym - x2m * ym;\n\n        double b = (sxy * sx2x2 - sx2y * sxx2) / (sxx * sx2x2 - sxx2 * sxx2);\n        double c = (sx2y * sxx - sxy * sxx2) / (sxx * sx2x2 - sxx2 * sxx2);\n        double a = ym - b * xm - c * x2m;\n\n        IntToDoubleFunction abc = (int xx) -> a + b * xx + c * xx * xx;\n\n        System.out.println(\"y = \" + a + \" + \" + b + \"x + \" + c + \"x^2\");\n        System.out.println(\" Input  Approximation\");\n        System.out.println(\" x   y     y1\");\n        for (int i = 0; i < n; ++i) {\n            System.out.printf(\"%2d %3d  %5.1f\\n\", x[i], y[i], abc.applyAsDouble(x[i]));\n        }\n    }\n\n    public static void main(String[] args) {\n        int[] x = IntStream.range(0, 11).toArray();\n        int[] y = new int[]{1, 6, 17, 34, 57, 86, 121, 162, 209, 262, 321};\n        polyRegression(x, y);\n    }\n}\n"}
{"id": 61543, "name": "Polynomial regression", "source": "Translate Fortran to Python: module fitting\ncontains\n\n  function polyfit(vx, vy, d)\n    implicit none\n    integer, intent(in)                   :: d\n    integer, parameter                    :: dp = selected_real_kind(15, 307)\n    real(dp), dimension(d+1)              :: polyfit\n    real(dp), dimension(:), intent(in)    :: vx, vy\n   \n    real(dp), dimension(:,:), allocatable :: X\n    real(dp), dimension(:,:), allocatable :: XT\n    real(dp), dimension(:,:), allocatable :: XTX\n   \n    integer :: i, j\n   \n    integer     :: n, lda, lwork\n    integer :: info\n    integer, dimension(:), allocatable :: ipiv\n    real(dp), dimension(:), allocatable :: work\n   \n    n = d+1\n    lda = n\n    lwork = n\n   \n    allocate(ipiv(n))\n    allocate(work(lwork))\n    allocate(XT(n, size(vx)))\n    allocate(X(size(vx), n))\n    allocate(XTX(n, n))\n   \n    \n    do i = 0, d\n       do j = 1, size(vx)\n          X(j, i+1) = vx(j)**i\n       end do\n    end do\n   \n    XT  = transpose(X)\n    XTX = matmul(XT, X)\n   \n    \n    call DGETRF(n, n, XTX, lda, ipiv, info)\n    if ( info /= 0 ) then\n       print *, \"problem\"\n       return\n    end if\n    call DGETRI(n, XTX, lda, ipiv, work, lwork, info)\n    if ( info /= 0 ) then\n       print *, \"problem\"\n       return\n    end if\n    \n    polyfit = matmul( matmul(XTX, XT), vy)\n    \n    deallocate(ipiv)\n    deallocate(work)\n    deallocate(X)\n    deallocate(XT)\n    deallocate(XTX)\n  \n  end function\n \nend module\n", "target": ">>> x = [0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10]\n>>> y = [1,   6,  17,  34,  57,  86, 121, 162, 209, 262, 321]\n>>> coeffs = numpy.polyfit(x,y,deg=2)\n>>> coeffs\narray([ 3.,  2.,  1.])\n"}
{"id": 61750, "name": "Menu", "source": "Translate Fortran to C#: \n\n\n      module menu\n      public :: selector\n      contains\n\n      function selector(title,options) result(choice)\n      character(len=*),intent(in) :: title\n      character(len=*),dimension(:),intent(in) :: options\n      character(len=len(options)) :: choice\n      integer :: i,ichoose,ios,n\n\n      choice = \"\"\n\n      n = size(options)\n      if (n > 0) then\n        do\n          print \"(a)\",title\n          print \"(i8,\"\", \"\",a)\",(i,options(i),i=1,n)\n          read (*,fmt=\"(i8)\",iostat=ios) ichoose\n\n          if (ios == -1) exit \n          if (ios /= 0) cycle \n          if (ichoose < 1) cycle\n          if (ichoose > n) cycle \n\n          choice = options(ichoose)\n          exit\n        end do\n      end if\n      end function selector\n      end module menu\n\n      program menu_demo\n      use menu\n      character(len=14),dimension(:),allocatable :: zero_items,fairytale\n      character(len=len(zero_items)) :: s\n\n      \n      allocate(zero_items(0))\n      print \"(a)\",\"input items:\",zero_items\n      s = selector('Choose from the empty list',zero_items)\n      print \"(a)\",\"returned:\",s\n      if (s == \"\") print \"(a)\",\"(an empty string)\"\n\n      \n      allocate(fairytale(4))\n      fairytale = (/'fee fie       ','huff and puff ', &\n        'mirror mirror ','tick tock     '/)\n      print \"(a)\",\"input items:\",fairytale\n      s = selector('Choose a fairy tale',fairytale)\n      print \"(a)\",\"returned: \",s\n      if (s == \"\") print \"(a)\",\"(an empty string)\"\n\n      end program menu_demo\n", "target": "using System;\nusing System.Collections.Generic;\n\npublic class Menu\n{\n        static void Main(string[] args)\n        {\n            List<string> menu_items = new List<string>() { \"fee fie\", \"huff and puff\", \"mirror mirror\", \"tick tock\" };\n            \n            Console.WriteLine(PrintMenu(menu_items));\n            Console.ReadLine();\n        }\n        private static string PrintMenu(List<string> items)\n        {\n            if (items.Count == 0)\n                return \"\";\n\n            string input = \"\";\n            int i = -1;\n            do\n            {\n                for (int j = 0; j < items.Count; j++)\n                    Console.WriteLine(\"{0}) {1}\", j, items[j]);\n\n                Console.WriteLine(\"What number?\");\n                input = Console.ReadLine();\n\n            } while (!int.TryParse(input, out i) || i >= items.Count || i < 0);\n            return items[i];\n        }\n}\n"}
{"id": 61753, "name": "Menu", "source": "Translate Fortran to Java: \n\n\n      module menu\n      public :: selector\n      contains\n\n      function selector(title,options) result(choice)\n      character(len=*),intent(in) :: title\n      character(len=*),dimension(:),intent(in) :: options\n      character(len=len(options)) :: choice\n      integer :: i,ichoose,ios,n\n\n      choice = \"\"\n\n      n = size(options)\n      if (n > 0) then\n        do\n          print \"(a)\",title\n          print \"(i8,\"\", \"\",a)\",(i,options(i),i=1,n)\n          read (*,fmt=\"(i8)\",iostat=ios) ichoose\n\n          if (ios == -1) exit \n          if (ios /= 0) cycle \n          if (ichoose < 1) cycle\n          if (ichoose > n) cycle \n\n          choice = options(ichoose)\n          exit\n        end do\n      end if\n      end function selector\n      end module menu\n\n      program menu_demo\n      use menu\n      character(len=14),dimension(:),allocatable :: zero_items,fairytale\n      character(len=len(zero_items)) :: s\n\n      \n      allocate(zero_items(0))\n      print \"(a)\",\"input items:\",zero_items\n      s = selector('Choose from the empty list',zero_items)\n      print \"(a)\",\"returned:\",s\n      if (s == \"\") print \"(a)\",\"(an empty string)\"\n\n      \n      allocate(fairytale(4))\n      fairytale = (/'fee fie       ','huff and puff ', &\n        'mirror mirror ','tick tock     '/)\n      print \"(a)\",\"input items:\",fairytale\n      s = selector('Choose a fairy tale',fairytale)\n      print \"(a)\",\"returned: \",s\n      if (s == \"\") print \"(a)\",\"(an empty string)\"\n\n      end program menu_demo\n", "target": "public static String select(List<String> list, String prompt){\n    if(list.size() == 0) return \"\";\n    Scanner sc = new Scanner(System.in);\n    String ret = null;\n    do{\n        for(int i=0;i<list.size();i++){\n            System.out.println(i + \": \"+list.get(i));\n        }\n        System.out.print(prompt);\n        int index = sc.nextInt();\n        if(index >= 0 && index < list.size()){\n            ret = list.get(index);\n        }\n    }while(ret == null);\n    return ret;\n}\n"}
{"id": 61754, "name": "Menu", "source": "Translate Fortran to Python: \n\n\n      module menu\n      public :: selector\n      contains\n\n      function selector(title,options) result(choice)\n      character(len=*),intent(in) :: title\n      character(len=*),dimension(:),intent(in) :: options\n      character(len=len(options)) :: choice\n      integer :: i,ichoose,ios,n\n\n      choice = \"\"\n\n      n = size(options)\n      if (n > 0) then\n        do\n          print \"(a)\",title\n          print \"(i8,\"\", \"\",a)\",(i,options(i),i=1,n)\n          read (*,fmt=\"(i8)\",iostat=ios) ichoose\n\n          if (ios == -1) exit \n          if (ios /= 0) cycle \n          if (ichoose < 1) cycle\n          if (ichoose > n) cycle \n\n          choice = options(ichoose)\n          exit\n        end do\n      end if\n      end function selector\n      end module menu\n\n      program menu_demo\n      use menu\n      character(len=14),dimension(:),allocatable :: zero_items,fairytale\n      character(len=len(zero_items)) :: s\n\n      \n      allocate(zero_items(0))\n      print \"(a)\",\"input items:\",zero_items\n      s = selector('Choose from the empty list',zero_items)\n      print \"(a)\",\"returned:\",s\n      if (s == \"\") print \"(a)\",\"(an empty string)\"\n\n      \n      allocate(fairytale(4))\n      fairytale = (/'fee fie       ','huff and puff ', &\n        'mirror mirror ','tick tock     '/)\n      print \"(a)\",\"input items:\",fairytale\n      s = selector('Choose a fairy tale',fairytale)\n      print \"(a)\",\"returned: \",s\n      if (s == \"\") print \"(a)\",\"(an empty string)\"\n\n      end program menu_demo\n", "target": "def _menu(items):\n    for indexitem in enumerate(items):\n        print (\"  %2i) %s\" % indexitem)\n\ndef _ok(reply, itemcount):\n    try:\n        n = int(reply)\n        return 0 <= n < itemcount\n    except:\n        return False\n    \ndef selector(items, prompt):\n    'Prompt to select an item from the items'\n    if not items: return ''\n    reply = -1\n    itemcount = len(items)\n    while not _ok(reply, itemcount):\n        _menu(items)\n        \n        reply = raw_input(prompt).strip()\n    return items[int(reply)]\n\nif __name__ == '__main__':\n    items = ['fee fie', 'huff and puff', 'mirror mirror', 'tick tock']\n    item = selector(items, 'Which is from the three pigs: ')\n    print (\"You chose: \" + item)\n"}
{"id": 62082, "name": "Greatest subsequential sum", "source": "Translate Fortran to C#: program MaxSubSeq\n  implicit none\n\n  integer, parameter :: an = 11\n  integer, dimension(an) :: a = (/ -1, -2, 3, 5, 6, -2, -1, 4, -4, 2, -1 /)\n\n  integer, dimension(an,an) :: mix\n  integer :: i, j\n  integer, dimension(2) :: m\n\n  forall(i=1:an,j=1:an) mix(i,j) = sum(a(i:j))\n  m = maxloc(mix)\n  \n  print *, a(m(1):m(2))\n\nend program MaxSubSeq\n", "target": "using System;\n\nnamespace Tests_With_Framework_4\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            int[] integers = { -1, -2, 3, 5, 6, -2, -1, 4, -4, 2, -1 }; int length = integers.Length;\n            int maxsum, beginmax, endmax, sum; maxsum = beginmax = sum = 0; endmax = -1;\n\n            for (int i = 0; i < length; i++)\n            {\n                sum = 0;\n                for (int k = i; k < length; k++)\n                {\n                    sum += integers[k];\n                    if (sum > maxsum)\n                    {\n                        maxsum = sum;\n                        beginmax = i;\n                        endmax = k;\n                    }\n                }\n            }\n\n            for (int i = beginmax; i <= endmax; i++)\n                Console.WriteLine(integers[i]);\n\n            Console.ReadKey();\n        }\n    }\n}\n"}
{"id": 62083, "name": "Greatest subsequential sum", "source": "Translate Fortran to C#: program MaxSubSeq\n  implicit none\n\n  integer, parameter :: an = 11\n  integer, dimension(an) :: a = (/ -1, -2, 3, 5, 6, -2, -1, 4, -4, 2, -1 /)\n\n  integer, dimension(an,an) :: mix\n  integer :: i, j\n  integer, dimension(2) :: m\n\n  forall(i=1:an,j=1:an) mix(i,j) = sum(a(i:j))\n  m = maxloc(mix)\n  \n  print *, a(m(1):m(2))\n\nend program MaxSubSeq\n", "target": "using System;\n\nnamespace Tests_With_Framework_4\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            int[] integers = { -1, -2, 3, 5, 6, -2, -1, 4, -4, 2, -1 }; int length = integers.Length;\n            int maxsum, beginmax, endmax, sum; maxsum = beginmax = sum = 0; endmax = -1;\n\n            for (int i = 0; i < length; i++)\n            {\n                sum = 0;\n                for (int k = i; k < length; k++)\n                {\n                    sum += integers[k];\n                    if (sum > maxsum)\n                    {\n                        maxsum = sum;\n                        beginmax = i;\n                        endmax = k;\n                    }\n                }\n            }\n\n            for (int i = beginmax; i <= endmax; i++)\n                Console.WriteLine(integers[i]);\n\n            Console.ReadKey();\n        }\n    }\n}\n"}
{"id": 62088, "name": "Greatest subsequential sum", "source": "Translate Fortran to Java: program MaxSubSeq\n  implicit none\n\n  integer, parameter :: an = 11\n  integer, dimension(an) :: a = (/ -1, -2, 3, 5, 6, -2, -1, 4, -4, 2, -1 /)\n\n  integer, dimension(an,an) :: mix\n  integer :: i, j\n  integer, dimension(2) :: m\n\n  forall(i=1:an,j=1:an) mix(i,j) = sum(a(i:j))\n  m = maxloc(mix)\n  \n  print *, a(m(1):m(2))\n\nend program MaxSubSeq\n", "target": "import java.util.Scanner;\nimport java.util.ArrayList;\n\npublic class Sub{\n    private static int[] indices;\n\n    public static void main(String[] args){\n        ArrayList<Long> array= new ArrayList<Long>(); \n        Scanner in = new Scanner(System.in);\n        while(in.hasNextLong()) array.add(in.nextLong());\n        long highSum= Long.MIN_VALUE;\n        ArrayList<Long> highSet= new ArrayList<Long>();\n        \n        for(int subSize= 0;subSize<= array.size();subSize++){\n            indices= new int[subSize];\n            for(int i= 0;i< subSize;i++) indices[i]= i;\n            do{\n                long sum= 0;\n                ArrayList<Long> temp= new ArrayList<Long>();\n                \n                for(long index:indices) {sum+= array.get(index); temp.add(array.get(index));}\n                if(sum > highSum){\n                    highSet= temp;    \n                    highSum= sum;\n                }\n            }while(nextIndices(array));\n        }\n        System.out.println(\"Sum: \" + highSum + \"\\nSet: \" + \n        \t\thighSet);\n    }\n    \n\n    private static boolean nextIndices(ArrayList<Long> a) {\n        for(int i= indices.length-1;i >= 0;--i){\n            indices[i]++;\n            for(int j=i+1;j < indices.length;++j){\n                indices[j]= indices[j - 1] + 1;\n            }\n            if(indices[indices.length - 1] < a.size()){\n                return true;\n            }\n        }\n        return false;\n    }\n}\n"}
{"id": 62089, "name": "Greatest subsequential sum", "source": "Translate Fortran to Java: program MaxSubSeq\n  implicit none\n\n  integer, parameter :: an = 11\n  integer, dimension(an) :: a = (/ -1, -2, 3, 5, 6, -2, -1, 4, -4, 2, -1 /)\n\n  integer, dimension(an,an) :: mix\n  integer :: i, j\n  integer, dimension(2) :: m\n\n  forall(i=1:an,j=1:an) mix(i,j) = sum(a(i:j))\n  m = maxloc(mix)\n  \n  print *, a(m(1):m(2))\n\nend program MaxSubSeq\n", "target": "import java.util.Scanner;\nimport java.util.ArrayList;\n\npublic class Sub{\n    private static int[] indices;\n\n    public static void main(String[] args){\n        ArrayList<Long> array= new ArrayList<Long>(); \n        Scanner in = new Scanner(System.in);\n        while(in.hasNextLong()) array.add(in.nextLong());\n        long highSum= Long.MIN_VALUE;\n        ArrayList<Long> highSet= new ArrayList<Long>();\n        \n        for(int subSize= 0;subSize<= array.size();subSize++){\n            indices= new int[subSize];\n            for(int i= 0;i< subSize;i++) indices[i]= i;\n            do{\n                long sum= 0;\n                ArrayList<Long> temp= new ArrayList<Long>();\n                \n                for(long index:indices) {sum+= array.get(index); temp.add(array.get(index));}\n                if(sum > highSum){\n                    highSet= temp;    \n                    highSum= sum;\n                }\n            }while(nextIndices(array));\n        }\n        System.out.println(\"Sum: \" + highSum + \"\\nSet: \" + \n        \t\thighSet);\n    }\n    \n\n    private static boolean nextIndices(ArrayList<Long> a) {\n        for(int i= indices.length-1;i >= 0;--i){\n            indices[i]++;\n            for(int j=i+1;j < indices.length;++j){\n                indices[j]= indices[j - 1] + 1;\n            }\n            if(indices[indices.length - 1] < a.size()){\n                return true;\n            }\n        }\n        return false;\n    }\n}\n"}
{"id": 62090, "name": "Greatest subsequential sum", "source": "Translate Fortran to Python: program MaxSubSeq\n  implicit none\n\n  integer, parameter :: an = 11\n  integer, dimension(an) :: a = (/ -1, -2, 3, 5, 6, -2, -1, 4, -4, 2, -1 /)\n\n  integer, dimension(an,an) :: mix\n  integer :: i, j\n  integer, dimension(2) :: m\n\n  forall(i=1:an,j=1:an) mix(i,j) = sum(a(i:j))\n  m = maxloc(mix)\n  \n  print *, a(m(1):m(2))\n\nend program MaxSubSeq\n", "target": "def maxsubseq(seq):\n  return max((seq[begin:end] for begin in xrange(len(seq)+1)\n                             for end in xrange(begin, len(seq)+1)),\n             key=sum)\n"}
{"id": 62091, "name": "Greatest subsequential sum", "source": "Translate Fortran to Python: program MaxSubSeq\n  implicit none\n\n  integer, parameter :: an = 11\n  integer, dimension(an) :: a = (/ -1, -2, 3, 5, 6, -2, -1, 4, -4, 2, -1 /)\n\n  integer, dimension(an,an) :: mix\n  integer :: i, j\n  integer, dimension(2) :: m\n\n  forall(i=1:an,j=1:an) mix(i,j) = sum(a(i:j))\n  m = maxloc(mix)\n  \n  print *, a(m(1):m(2))\n\nend program MaxSubSeq\n", "target": "def maxsubseq(seq):\n  return max((seq[begin:end] for begin in xrange(len(seq)+1)\n                             for end in xrange(begin, len(seq)+1)),\n             key=sum)\n"}
{"id": 62566, "name": "Integer sequence", "source": "Translate Fortran to C#: program Intseq\n  implicit none\n  \n  integer, parameter :: i64 = selected_int_kind(18)\n  integer(i64) :: n = 1\n  \n\n\n  do\n    print*, n\n    n = n + 1\n  end do\nend program\n", "target": "using System;\nusing System.Numerics;\n\nclass Program\n{\n    static void Main()\n    {\n        BigInteger i = 1;\n        while (true)\n        {\n            Console.WriteLine(i++);\n        }\n    }\n}\n"}
{"id": 62567, "name": "Integer sequence", "source": "Translate Fortran to C#: program Intseq\n  implicit none\n  \n  integer, parameter :: i64 = selected_int_kind(18)\n  integer(i64) :: n = 1\n  \n\n\n  do\n    print*, n\n    n = n + 1\n  end do\nend program\n", "target": "using System;\nusing System.Numerics;\n\nclass Program\n{\n    static void Main()\n    {\n        BigInteger i = 1;\n        while (true)\n        {\n            Console.WriteLine(i++);\n        }\n    }\n}\n"}
{"id": 62572, "name": "Integer sequence", "source": "Translate Fortran to Java: program Intseq\n  implicit none\n  \n  integer, parameter :: i64 = selected_int_kind(18)\n  integer(i64) :: n = 1\n  \n\n\n  do\n    print*, n\n    n = n + 1\n  end do\nend program\n", "target": "public class Count{\n    public static void main(String[] args){\n        for(long i = 1; ;i++) System.out.println(i);\n    }\n}\n"}
{"id": 62573, "name": "Integer sequence", "source": "Translate Fortran to Java: program Intseq\n  implicit none\n  \n  integer, parameter :: i64 = selected_int_kind(18)\n  integer(i64) :: n = 1\n  \n\n\n  do\n    print*, n\n    n = n + 1\n  end do\nend program\n", "target": "public class Count{\n    public static void main(String[] args){\n        for(long i = 1; ;i++) System.out.println(i);\n    }\n}\n"}
{"id": 62574, "name": "Integer sequence", "source": "Translate Fortran to Python: program Intseq\n  implicit none\n  \n  integer, parameter :: i64 = selected_int_kind(18)\n  integer(i64) :: n = 1\n  \n\n\n  do\n    print*, n\n    n = n + 1\n  end do\nend program\n", "target": "i=1\nwhile i:\n    print(i)\n    i += 1\n"}
{"id": 62575, "name": "Integer sequence", "source": "Translate Fortran to Python: program Intseq\n  implicit none\n  \n  integer, parameter :: i64 = selected_int_kind(18)\n  integer(i64) :: n = 1\n  \n\n\n  do\n    print*, n\n    n = n + 1\n  end do\nend program\n", "target": "i=1\nwhile i:\n    print(i)\n    i += 1\n"}
{"id": 62951, "name": "Fibonacci sequence", "source": "Translate Fortran to C#: C     FIBONACCI SEQUENCE - FORTRAN IV\n      NN=46\n      DO 1 I=0,NN\n    1 WRITE(*,300) I,IFIBO(I)\n  300 FORMAT(1X,I2,1X,I10)\n      END\nC\n      FUNCTION IFIBO(N)\n      IF(N) 9,1,2\n    1 IFN=0\n      GOTO 9\n    2 IF(N-1) 9,3,4\n    3 IFN=1\n      GOTO 9\n    4 IFNM1=0\n      IFN=1\n      DO 5 I=2,N\n      IFNM2=IFNM1\n      IFNM1=IFN\n    5 IFN=IFNM1+IFNM2\n    9 IFIBO=IFN\n      END\n", "target": "public static ulong Fib(uint n) {\n    return (n < 2)? n : Fib(n - 1) + Fib(n - 2);\n}\n"}
{"id": 62954, "name": "Fibonacci sequence", "source": "Translate Fortran to Java: C     FIBONACCI SEQUENCE - FORTRAN IV\n      NN=46\n      DO 1 I=0,NN\n    1 WRITE(*,300) I,IFIBO(I)\n  300 FORMAT(1X,I2,1X,I10)\n      END\nC\n      FUNCTION IFIBO(N)\n      IF(N) 9,1,2\n    1 IFN=0\n      GOTO 9\n    2 IF(N-1) 9,3,4\n    3 IFN=1\n      GOTO 9\n    4 IFNM1=0\n      IFN=1\n      DO 5 I=2,N\n      IFNM2=IFNM1\n      IFNM1=IFN\n    5 IFN=IFNM1+IFNM2\n    9 IFIBO=IFN\n      END\n", "target": "public static long itFibN(int n)\n{\n if (n < 2)\n  return n;\n long ans = 0;\n long n1 = 0;\n long n2 = 1;\n for(n--; n > 0; n--)\n {\n  ans = n1 + n2;\n  n1 = n2;\n  n2 = ans;\n }\n return ans;\n}\n"}
{"id": 62955, "name": "Fibonacci sequence", "source": "Translate Fortran to Python: C     FIBONACCI SEQUENCE - FORTRAN IV\n      NN=46\n      DO 1 I=0,NN\n    1 WRITE(*,300) I,IFIBO(I)\n  300 FORMAT(1X,I2,1X,I10)\n      END\nC\n      FUNCTION IFIBO(N)\n      IF(N) 9,1,2\n    1 IFN=0\n      GOTO 9\n    2 IF(N-1) 9,3,4\n    3 IFN=1\n      GOTO 9\n    4 IFNM1=0\n      IFN=1\n      DO 5 I=2,N\n      IFNM2=IFNM1\n      IFNM1=IFN\n    5 IFN=IFNM1+IFNM2\n    9 IFIBO=IFN\n      END\n", "target": "from math import *\n\ndef analytic_fibonacci(n):\n  sqrt_5 = sqrt(5);\n  p = (1 + sqrt_5) / 2;\n  q = 1/p;\n  return int( (p**n + q**n) / sqrt_5 + 0.5 )\n\nfor i in range(1,31):\n  print analytic_fibonacci(i),\n"}
{"id": 63235, "name": "Averages_Arithmetic mean", "source": "Translate Fortran to C#: real, target, dimension(100) :: a = (/ (i, i=1, 100) /)\nreal, dimension(5,20) :: b = reshape( a, (/ 5,20 /) )\nreal, pointer, dimension(:) :: p => a(2:1)       \nreal :: mean, zmean, bmean\nreal, dimension(20) :: colmeans\nreal, dimension(5) :: rowmeans\n\nmean = sum(a)/size(a)                \nmean = sum(a)/max(size(a),1)         \n                                     \n\nzmean = sum(p)/max(size(p),1)        \n                                     \n\nbmean = sum(b)/max(size(b),1)        \n\nrowmeans = sum(b,1)/max(size(b,2),1) \n                                     \ncolmeans = sum(b,2)/max(size(b,1),1) \n                                     \n", "target": "using System;\nusing System.Linq;\n\nclass Program\n{\n    static void Main()\n    {\n        Console.WriteLine(new[] { 1, 2, 3 }.Average());\n    }\n}\n"}
{"id": 63239, "name": "Averages_Arithmetic mean", "source": "Translate Fortran to Java: real, target, dimension(100) :: a = (/ (i, i=1, 100) /)\nreal, dimension(5,20) :: b = reshape( a, (/ 5,20 /) )\nreal, pointer, dimension(:) :: p => a(2:1)       \nreal :: mean, zmean, bmean\nreal, dimension(20) :: colmeans\nreal, dimension(5) :: rowmeans\n\nmean = sum(a)/size(a)                \nmean = sum(a)/max(size(a),1)         \n                                     \n\nzmean = sum(p)/max(size(p),1)        \n                                     \n\nbmean = sum(b)/max(size(b),1)        \n\nrowmeans = sum(b,1)/max(size(b,2),1) \n                                     \ncolmeans = sum(b,2)/max(size(b,1),1) \n                                     \n", "target": "public static double avg(double... arr) {\n    double sum = 0.0;\n    for (double x : arr) {\n        sum += x;\n    }\n    return sum / arr.length;\n}\n"}
{"id": 63240, "name": "Averages_Arithmetic mean", "source": "Translate Fortran to Python: real, target, dimension(100) :: a = (/ (i, i=1, 100) /)\nreal, dimension(5,20) :: b = reshape( a, (/ 5,20 /) )\nreal, pointer, dimension(:) :: p => a(2:1)       \nreal :: mean, zmean, bmean\nreal, dimension(20) :: colmeans\nreal, dimension(5) :: rowmeans\n\nmean = sum(a)/size(a)                \nmean = sum(a)/max(size(a),1)         \n                                     \n\nzmean = sum(p)/max(size(p),1)        \n                                     \n\nbmean = sum(b)/max(size(b),1)        \n\nrowmeans = sum(b,1)/max(size(b,2),1) \n                                     \ncolmeans = sum(b,2)/max(size(b,1),1) \n                                     \n", "target": "from math import fsum\ndef average(x):\n    return fsum(x)/float(len(x)) if x else 0\nprint (average([0,0,3,1,4,1,5,9,0,0]))\nprint (average([1e20,-1e-20,3,1,4,1,5,9,-1e20,1e-20]))\n"}
{"id": 63500, "name": "Spiral matrix", "source": "Translate Fortran to C#: PROGRAM SPIRAL\n\n  IMPLICIT NONE\n \n  INTEGER, PARAMETER :: size = 5\n  INTEGER :: i, x = 0, y = 1, count = size, n = 0\n  INTEGER :: array(size,size)\n\n  DO i = 1, count\n    x = x + 1 \n      array(x,y) = n\n    n = n + 1\n  END DO\n\n  DO\n    count = count  - 1\n      DO i = 1, count\n        y = y + 1\n        array(x,y) = n\n        n = n + 1\n      END DO\n      DO i = 1, count\n        x = x - 1\n        array(x,y) = n\n        n = n + 1\n      END DO\n      IF (n > size*size-1) EXIT\n      count = count - 1\n      DO i = 1, count\n        y = y - 1\n        array(x,y) = n\n        n = n + 1\n      END DO\n      DO i = 1, count\n        x = x + 1\n        array(x,y) = n\n        n = n + 1\n      END DO\t\n      IF (n > size*size-1) EXIT\n  END DO\n   \n  DO y = 1, size\n    DO x = 1, size\n      WRITE (*, \"(I4)\", ADVANCE=\"NO\") array (x, y)\n    END DO\n    WRITE (*,*)\n  END DO\n\nEND PROGRAM SPIRAL\n", "target": "public int[,] Spiral(int n) {\n    int[,] result = new int[n, n];\n\n    int pos = 0;\n    int count = n;\n    int value = -n;\n    int sum = -1;\n\n    do {\n        value = -1 * value / n;\n        for (int i = 0; i < count; i++) {\n            sum += value;\n            result[sum / n, sum % n] = pos++;\n        }\n        value *= n;\n        count--;\n        for (int i = 0; i < count; i++) {\n            sum += value;\n            result[sum / n, sum % n] = pos++;\n        }\n    } while (count > 0);\n\n    return result;\n}\n\n\n\npublic void PrintArray(int[,] array) {\n    int n = (array.GetLength(0) * array.GetLength(1) - 1).ToString().Length + 1;\n\n    for (int i = 0; i < array.GetLength(0); i++) {\n        for (int j = 0; j < array.GetLength(1); j++) {\n            Console.Write(array[i, j].ToString().PadLeft(n, ' '));\n        }\n        Console.WriteLine();\n    }\n}\n"}
{"id": 63503, "name": "Spiral matrix", "source": "Translate Fortran to Java: PROGRAM SPIRAL\n\n  IMPLICIT NONE\n \n  INTEGER, PARAMETER :: size = 5\n  INTEGER :: i, x = 0, y = 1, count = size, n = 0\n  INTEGER :: array(size,size)\n\n  DO i = 1, count\n    x = x + 1 \n      array(x,y) = n\n    n = n + 1\n  END DO\n\n  DO\n    count = count  - 1\n      DO i = 1, count\n        y = y + 1\n        array(x,y) = n\n        n = n + 1\n      END DO\n      DO i = 1, count\n        x = x - 1\n        array(x,y) = n\n        n = n + 1\n      END DO\n      IF (n > size*size-1) EXIT\n      count = count - 1\n      DO i = 1, count\n        y = y - 1\n        array(x,y) = n\n        n = n + 1\n      END DO\n      DO i = 1, count\n        x = x + 1\n        array(x,y) = n\n        n = n + 1\n      END DO\t\n      IF (n > size*size-1) EXIT\n  END DO\n   \n  DO y = 1, size\n    DO x = 1, size\n      WRITE (*, \"(I4)\", ADVANCE=\"NO\") array (x, y)\n    END DO\n    WRITE (*,*)\n  END DO\n\nEND PROGRAM SPIRAL\n", "target": "public class Blah {\n\n  public static void main(String[] args) {\n    print2dArray(getSpiralArray(5));\n  }\n\n  public static int[][] getSpiralArray(int dimension) {\n    int[][] spiralArray = new int[dimension][dimension];\n\n    int numConcentricSquares = (int) Math.ceil((dimension) / 2.0);\n\n    int j;\n    int sideLen = dimension;\n    int currNum = 0;\n\n    for (int i = 0; i < numConcentricSquares; i++) {\n      \n      for (j = 0; j < sideLen; j++) {\n        spiralArray[i][i + j] = currNum++;\n      }\n\n      \n      for (j = 1; j < sideLen; j++) {\n        spiralArray[i + j][dimension - 1 - i] = currNum++;\n      }\n\n      \n      for (j = sideLen - 2; j > -1; j--) {\n        spiralArray[dimension - 1 - i][i + j] = currNum++;\n      }\n\n      \n      for (j = sideLen - 2; j > 0; j--) {\n        spiralArray[i + j][i] = currNum++;\n      }\n\n      sideLen -= 2;\n    }\n\n    return spiralArray;\n  }\n\n  public static void print2dArray(int[][] array) {\n    for (int[] row : array) {\n      for (int elem : row) {\n        System.out.printf(\"%3d\", elem);\n      }\n      System.out.println();\n    }\n  }\n}\n"}
{"id": 63504, "name": "Spiral matrix", "source": "Translate Fortran to Python: PROGRAM SPIRAL\n\n  IMPLICIT NONE\n \n  INTEGER, PARAMETER :: size = 5\n  INTEGER :: i, x = 0, y = 1, count = size, n = 0\n  INTEGER :: array(size,size)\n\n  DO i = 1, count\n    x = x + 1 \n      array(x,y) = n\n    n = n + 1\n  END DO\n\n  DO\n    count = count  - 1\n      DO i = 1, count\n        y = y + 1\n        array(x,y) = n\n        n = n + 1\n      END DO\n      DO i = 1, count\n        x = x - 1\n        array(x,y) = n\n        n = n + 1\n      END DO\n      IF (n > size*size-1) EXIT\n      count = count - 1\n      DO i = 1, count\n        y = y - 1\n        array(x,y) = n\n        n = n + 1\n      END DO\n      DO i = 1, count\n        x = x + 1\n        array(x,y) = n\n        n = n + 1\n      END DO\t\n      IF (n > size*size-1) EXIT\n  END DO\n   \n  DO y = 1, size\n    DO x = 1, size\n      WRITE (*, \"(I4)\", ADVANCE=\"NO\") array (x, y)\n    END DO\n    WRITE (*,*)\n  END DO\n\nEND PROGRAM SPIRAL\n", "target": "def spiral(n):\n    dx,dy = 1,0            \n    x,y = 0,0              \n    myarray = [[None]* n for j in range(n)]\n    for i in xrange(n**2):\n        myarray[x][y] = i\n        nx,ny = x+dx, y+dy\n        if 0<=nx<n and 0<=ny<n and myarray[nx][ny] == None:\n            x,y = nx,ny\n        else:\n            dx,dy = -dy,dx\n            x,y = x+dx, y+dy\n    return myarray\n\ndef printspiral(myarray):\n    n = range(len(myarray))\n    for y in n:\n        for x in n:\n            print \"%2i\" % myarray[x][y],\n        print\n\nprintspiral(spiral(5))\n"}
{"id": 63709, "name": "Sort an array of composite structures", "source": "Translate Fortran to C#: PROGRAM EXAMPLE\n  IMPLICIT NONE  \n\n  TYPE Pair\n    CHARACTER(6) :: name\n    CHARACTER(1) :: value\n  END TYPE Pair\n\n  TYPE(Pair) :: rcc(10), temp\n  INTEGER :: i, j\n\n  rcc(1) = Pair(\"Black\", \"0\")\n  rcc(2) = Pair(\"Brown\", \"1\")\n  rcc(3) = Pair(\"Red\", \"2\")\n  rcc(4) = Pair(\"Orange\", \"3\")\n  rcc(5) = Pair(\"Yellow\", \"4\") \n  rcc(6) = Pair(\"Green\", \"5\")\n  rcc(7) = Pair(\"Blue\", \"6\")\n  rcc(8) = Pair(\"Violet\", \"7\")\n  rcc(9) = Pair(\"Grey\", \"8\")\n  rcc(10) = Pair(\"White\", \"9\")\n\n  DO i = 2, SIZE(rcc)\n     j = i - 1\n     temp = rcc(i)\n        DO WHILE (j>=1 .AND. LGT(rcc(j)%name, temp%name))\n           rcc(j+1) = rcc(j)\n           j = j - 1\n        END DO\n     rcc(j+1) = temp\n  END DO\n\n  WRITE (*,\"(2A6)\") rcc\n\nEND PROGRAM EXAMPLE\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\nclass Program\n{        \n    struct Entry\n    {\n        public Entry(string name, double value) { Name = name; Value = value; }\n        public string Name;\n        public double Value;\n    }\n\n    static void Main(string[] args)\n    {\n        var Elements = new List<Entry>\n        {\n            new Entry(\"Krypton\", 83.798), new Entry(\"Beryllium\", 9.012182), new Entry(\"Silicon\", 28.0855),\n            new Entry(\"Cobalt\", 58.933195), new Entry(\"Selenium\", 78.96), new Entry(\"Germanium\", 72.64)\n        };\n\n        var sortedElements = Elements.OrderBy(e => e.Name);\n\n        foreach (Entry e in sortedElements)\n            Console.WriteLine(\"{0,-11}{1}\", e.Name, e.Value);\n    }\n}\n"}
{"id": 63712, "name": "Sort an array of composite structures", "source": "Translate Fortran to Java: PROGRAM EXAMPLE\n  IMPLICIT NONE  \n\n  TYPE Pair\n    CHARACTER(6) :: name\n    CHARACTER(1) :: value\n  END TYPE Pair\n\n  TYPE(Pair) :: rcc(10), temp\n  INTEGER :: i, j\n\n  rcc(1) = Pair(\"Black\", \"0\")\n  rcc(2) = Pair(\"Brown\", \"1\")\n  rcc(3) = Pair(\"Red\", \"2\")\n  rcc(4) = Pair(\"Orange\", \"3\")\n  rcc(5) = Pair(\"Yellow\", \"4\") \n  rcc(6) = Pair(\"Green\", \"5\")\n  rcc(7) = Pair(\"Blue\", \"6\")\n  rcc(8) = Pair(\"Violet\", \"7\")\n  rcc(9) = Pair(\"Grey\", \"8\")\n  rcc(10) = Pair(\"White\", \"9\")\n\n  DO i = 2, SIZE(rcc)\n     j = i - 1\n     temp = rcc(i)\n        DO WHILE (j>=1 .AND. LGT(rcc(j)%name, temp%name))\n           rcc(j+1) = rcc(j)\n           j = j - 1\n        END DO\n     rcc(j+1) = temp\n  END DO\n\n  WRITE (*,\"(2A6)\") rcc\n\nEND PROGRAM EXAMPLE\n", "target": "import java.util.Arrays;\nimport java.util.Comparator;\n\npublic class SortComp {\n    public static class Pair {\n        public String name;\n        public String value;\n        public Pair(String n, String v) {\n            name = n;\n            value = v;\n        }\n    }\n\n    public static void main(String[] args) {\n        Pair[] pairs = {new Pair(\"06-07\", \"Ducks\"), new Pair(\"00-01\", \"Avalanche\"),\n            new Pair(\"02-03\", \"Devils\"), new Pair(\"01-02\", \"Red Wings\"),\n            new Pair(\"03-04\", \"Lightning\"), new Pair(\"04-05\", \"lockout\"),\n            new Pair(\"05-06\", \"Hurricanes\"), new Pair(\"99-00\", \"Devils\"),\n            new Pair(\"07-08\", \"Red Wings\"), new Pair(\"08-09\", \"Penguins\")};\n\n        sortByName(pairs);\n        for (Pair p : pairs) {\n            System.out.println(p.name + \" \" + p.value);\n        }\n    }\n\n    public static void sortByName(Pair[] pairs) {\n        Arrays.sort(pairs, new Comparator<Pair>() {\n            public int compare(Pair p1, Pair p2) {\n                return p1.name.compareTo(p2.name);\n            }\n        });\n    }\n}\n"}
{"id": 63713, "name": "Sort an array of composite structures", "source": "Translate Fortran to Python: PROGRAM EXAMPLE\n  IMPLICIT NONE  \n\n  TYPE Pair\n    CHARACTER(6) :: name\n    CHARACTER(1) :: value\n  END TYPE Pair\n\n  TYPE(Pair) :: rcc(10), temp\n  INTEGER :: i, j\n\n  rcc(1) = Pair(\"Black\", \"0\")\n  rcc(2) = Pair(\"Brown\", \"1\")\n  rcc(3) = Pair(\"Red\", \"2\")\n  rcc(4) = Pair(\"Orange\", \"3\")\n  rcc(5) = Pair(\"Yellow\", \"4\") \n  rcc(6) = Pair(\"Green\", \"5\")\n  rcc(7) = Pair(\"Blue\", \"6\")\n  rcc(8) = Pair(\"Violet\", \"7\")\n  rcc(9) = Pair(\"Grey\", \"8\")\n  rcc(10) = Pair(\"White\", \"9\")\n\n  DO i = 2, SIZE(rcc)\n     j = i - 1\n     temp = rcc(i)\n        DO WHILE (j>=1 .AND. LGT(rcc(j)%name, temp%name))\n           rcc(j+1) = rcc(j)\n           j = j - 1\n        END DO\n     rcc(j+1) = temp\n  END DO\n\n  WRITE (*,\"(2A6)\") rcc\n\nEND PROGRAM EXAMPLE\n", "target": "people = [('joe', 120), ('foo', 31), ('bar', 51)]\nsorted(people)\n"}
{"id": 64026, "name": "Julia set", "source": "Translate Fortran to C#: C     ==================================================================\n      PROGRAM JULIA\nC     ------------------------------------------------------------------\n      INTEGER    NMAP,NROW,NCOL\n      COMPLEX*16 C\n      PARAMETER(NMAP=11,NROW=40,NCOL=100,C=(-0.798D0,0.1618D0))\n      CHARACTER*1 MAP(NMAP)\n      DATA MAP /' ','.',':','-','=','+','*','#','%','$','@'/\n      REAL*8      X(NCOL), Y(NROW)\n      INTEGER     IR, IC, I, J, MX\n      CHARACTER*1 CLR, LINE(NCOL)\n      COMPLEX*16  Z\n\n      MX = (NMAP-1)*5\n      CALL LINSPACE( NCOL, X, -1.5D0,  1.5D0 )\n      CALL LINSPACE( NROW, Y,  1.0D0, -1.0D0 )\n\n      WRITE (*,*) C\n\n      DO 110 IR=1,NROW\n         DO 100 IC=1,NCOL\n            Z = DCMPLX( X(IC), Y(IR) )\n            I  = 1\n            CLR = ' '\n 10         CONTINUE\n            Z = Z*Z + C\n            IF ( 2.0D0 .LT. CDABS(Z) ) THEN\n               CLR = MAP(MOD(I,NMAP-1)+1)\n               GOTO 20\n            END IF\n            I = I + 1\n            IF ( MX .GT. I ) GOTO 10\n 20         CONTINUE\n            LINE(IC) = CLR\n 100     CONTINUE\n         WRITE(*,*) (LINE(J),J=1,NCOL)\n 110  CONTINUE\n      \n      STOP\n      END\n\nC     ==================================================================\n      SUBROUTINE LINSPACE( N, A, S, F )\nC     ------------------------------------------------------------------\n      INTEGER N\n      REAL*8  N A(N), S, F\n      INTEGER I\n      REAL*8  D\n      D = (F-S)/DBLE(N-1)\n      A(1) = S\n      DO 10 I=2,N\n         A(I) = A(I-1) + D\n 10   CONTINUE\n      RETURN\n      END\n", "target": "using System.Drawing;\n\n\n\nusing System.Linq;\n\nnamespace RosettaJuliaSet\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            const int w = 800;\n            const int h = 600;\n            const int zoom = 1;\n            const int maxiter = 255;\n            const int moveX = 0;\n            const int moveY = 0;\n            const double cX = -0.7;\n            const double cY = 0.27015;\n            double zx, zy, tmp;\n            int i;\n\n            var colors = (from c in Enumerable.Range(0, 256)\n                          select Color.FromArgb((c >> 5) * 36, (c >> 3 & 7) * 36, (c & 3) * 85)).ToArray();\n\n            var bitmap = new Bitmap(w, h);\n            for (int x = 0; x < w; x++)\n            {\n                for (int y = 0; y < h; y++)\n                {\n                    zx = 1.5 * (x - w / 2) / (0.5 * zoom * w) + moveX;\n                    zy = 1.0 * (y - h / 2) / (0.5 * zoom * h) + moveY;\n                    i = maxiter;\n                    while (zx * zx + zy * zy < 4 && i > 1)\n                    {\n                        tmp = zx * zx - zy * zy + cX;\n                        zy = 2.0 * zx * zy + cY;\n                        zx = tmp;\n                        i -= 1;\n                    }\n                    bitmap.SetPixel(x, y, colors[i]);\n                }\n            }\n            bitmap.Save(\"julia-set.png\");\n        }\n    }\n}\n"}
{"id": 64027, "name": "Julia set", "source": "Translate Fortran to C#: C     ==================================================================\n      PROGRAM JULIA\nC     ------------------------------------------------------------------\n      INTEGER    NMAP,NROW,NCOL\n      COMPLEX*16 C\n      PARAMETER(NMAP=11,NROW=40,NCOL=100,C=(-0.798D0,0.1618D0))\n      CHARACTER*1 MAP(NMAP)\n      DATA MAP /' ','.',':','-','=','+','*','#','%','$','@'/\n      REAL*8      X(NCOL), Y(NROW)\n      INTEGER     IR, IC, I, J, MX\n      CHARACTER*1 CLR, LINE(NCOL)\n      COMPLEX*16  Z\n\n      MX = (NMAP-1)*5\n      CALL LINSPACE( NCOL, X, -1.5D0,  1.5D0 )\n      CALL LINSPACE( NROW, Y,  1.0D0, -1.0D0 )\n\n      WRITE (*,*) C\n\n      DO 110 IR=1,NROW\n         DO 100 IC=1,NCOL\n            Z = DCMPLX( X(IC), Y(IR) )\n            I  = 1\n            CLR = ' '\n 10         CONTINUE\n            Z = Z*Z + C\n            IF ( 2.0D0 .LT. CDABS(Z) ) THEN\n               CLR = MAP(MOD(I,NMAP-1)+1)\n               GOTO 20\n            END IF\n            I = I + 1\n            IF ( MX .GT. I ) GOTO 10\n 20         CONTINUE\n            LINE(IC) = CLR\n 100     CONTINUE\n         WRITE(*,*) (LINE(J),J=1,NCOL)\n 110  CONTINUE\n      \n      STOP\n      END\n\nC     ==================================================================\n      SUBROUTINE LINSPACE( N, A, S, F )\nC     ------------------------------------------------------------------\n      INTEGER N\n      REAL*8  N A(N), S, F\n      INTEGER I\n      REAL*8  D\n      D = (F-S)/DBLE(N-1)\n      A(1) = S\n      DO 10 I=2,N\n         A(I) = A(I-1) + D\n 10   CONTINUE\n      RETURN\n      END\n", "target": "using System.Drawing;\n\n\n\nusing System.Linq;\n\nnamespace RosettaJuliaSet\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            const int w = 800;\n            const int h = 600;\n            const int zoom = 1;\n            const int maxiter = 255;\n            const int moveX = 0;\n            const int moveY = 0;\n            const double cX = -0.7;\n            const double cY = 0.27015;\n            double zx, zy, tmp;\n            int i;\n\n            var colors = (from c in Enumerable.Range(0, 256)\n                          select Color.FromArgb((c >> 5) * 36, (c >> 3 & 7) * 36, (c & 3) * 85)).ToArray();\n\n            var bitmap = new Bitmap(w, h);\n            for (int x = 0; x < w; x++)\n            {\n                for (int y = 0; y < h; y++)\n                {\n                    zx = 1.5 * (x - w / 2) / (0.5 * zoom * w) + moveX;\n                    zy = 1.0 * (y - h / 2) / (0.5 * zoom * h) + moveY;\n                    i = maxiter;\n                    while (zx * zx + zy * zy < 4 && i > 1)\n                    {\n                        tmp = zx * zx - zy * zy + cX;\n                        zy = 2.0 * zx * zy + cY;\n                        zx = tmp;\n                        i -= 1;\n                    }\n                    bitmap.SetPixel(x, y, colors[i]);\n                }\n            }\n            bitmap.Save(\"julia-set.png\");\n        }\n    }\n}\n"}
{"id": 64033, "name": "Julia set", "source": "Translate Fortran to Java: C     ==================================================================\n      PROGRAM JULIA\nC     ------------------------------------------------------------------\n      INTEGER    NMAP,NROW,NCOL\n      COMPLEX*16 C\n      PARAMETER(NMAP=11,NROW=40,NCOL=100,C=(-0.798D0,0.1618D0))\n      CHARACTER*1 MAP(NMAP)\n      DATA MAP /' ','.',':','-','=','+','*','#','%','$','@'/\n      REAL*8      X(NCOL), Y(NROW)\n      INTEGER     IR, IC, I, J, MX\n      CHARACTER*1 CLR, LINE(NCOL)\n      COMPLEX*16  Z\n\n      MX = (NMAP-1)*5\n      CALL LINSPACE( NCOL, X, -1.5D0,  1.5D0 )\n      CALL LINSPACE( NROW, Y,  1.0D0, -1.0D0 )\n\n      WRITE (*,*) C\n\n      DO 110 IR=1,NROW\n         DO 100 IC=1,NCOL\n            Z = DCMPLX( X(IC), Y(IR) )\n            I  = 1\n            CLR = ' '\n 10         CONTINUE\n            Z = Z*Z + C\n            IF ( 2.0D0 .LT. CDABS(Z) ) THEN\n               CLR = MAP(MOD(I,NMAP-1)+1)\n               GOTO 20\n            END IF\n            I = I + 1\n            IF ( MX .GT. I ) GOTO 10\n 20         CONTINUE\n            LINE(IC) = CLR\n 100     CONTINUE\n         WRITE(*,*) (LINE(J),J=1,NCOL)\n 110  CONTINUE\n      \n      STOP\n      END\n\nC     ==================================================================\n      SUBROUTINE LINSPACE( N, A, S, F )\nC     ------------------------------------------------------------------\n      INTEGER N\n      REAL*8  N A(N), S, F\n      INTEGER I\n      REAL*8  D\n      D = (F-S)/DBLE(N-1)\n      A(1) = S\n      DO 10 I=2,N\n         A(I) = A(I-1) + D\n 10   CONTINUE\n      RETURN\n      END\n", "target": "import javax.swing.*;\nimport java.awt.*;\nimport java.awt.image.BufferedImage;\n\npublic class JuliaSet extends JPanel {\n    private static final int MAX_ITERATIONS = 300;\n    private static final double ZOOM = 1;\n    private static final double CX = -0.7;\n    private static final double CY = 0.27015;\n    private static final double MOVE_X = 0;\n    private static final double MOVE_Y = 0;\n\n    public JuliaSet() {\n        setPreferredSize(new Dimension(800, 600));\n        setBackground(Color.white);\n    }\n\n    void drawJuliaSet(Graphics2D g) {\n        int w = getWidth();\n        int h = getHeight();\n        BufferedImage image = new BufferedImage(w, h, BufferedImage.TYPE_INT_RGB);\n\n        for (int x = 0; x < w; x++) {\n            for (int y = 0; y < h; y++) {\n                double zx = 1.5 * (x - w / 2) / (0.5 * ZOOM * w) + MOVE_X;\n                double zy = (y - h / 2) / (0.5 * ZOOM * h) + MOVE_Y;\n                float i = MAX_ITERATIONS;\n                while (zx * zx + zy * zy < 4 && i > 0) {\n                    double tmp = zx * zx - zy * zy + CX;\n                    zy = 2.0 * zx * zy + CY;\n                    zx = tmp;\n                    i--;\n                }\n                int c = Color.HSBtoRGB((MAX_ITERATIONS / i) % 1, 1, i > 0 ? 1 : 0);\n                image.setRGB(x, y, c);\n            }\n        }\n        g.drawImage(image, 0, 0, null);\n    }\n\n    @Override\n    public void paintComponent(Graphics gg) {\n        super.paintComponent(gg);\n        Graphics2D g = (Graphics2D) gg;\n        g.setRenderingHint(RenderingHints.KEY_ANTIALIASING,\n                RenderingHints.VALUE_ANTIALIAS_ON);\n        drawJuliaSet(g);\n    }\n\n    public static void main(String[] args) {\n        SwingUtilities.invokeLater(() -> {\n            JFrame f = new JFrame();\n            f.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n            f.setTitle(\"Julia Set\");\n            f.setResizable(false);\n            f.add(new JuliaSet(), BorderLayout.CENTER);\n            f.pack();\n            f.setLocationRelativeTo(null);\n            f.setVisible(true);\n        });\n    }\n}\n"}
{"id": 64034, "name": "Julia set", "source": "Translate Fortran to Java: C     ==================================================================\n      PROGRAM JULIA\nC     ------------------------------------------------------------------\n      INTEGER    NMAP,NROW,NCOL\n      COMPLEX*16 C\n      PARAMETER(NMAP=11,NROW=40,NCOL=100,C=(-0.798D0,0.1618D0))\n      CHARACTER*1 MAP(NMAP)\n      DATA MAP /' ','.',':','-','=','+','*','#','%','$','@'/\n      REAL*8      X(NCOL), Y(NROW)\n      INTEGER     IR, IC, I, J, MX\n      CHARACTER*1 CLR, LINE(NCOL)\n      COMPLEX*16  Z\n\n      MX = (NMAP-1)*5\n      CALL LINSPACE( NCOL, X, -1.5D0,  1.5D0 )\n      CALL LINSPACE( NROW, Y,  1.0D0, -1.0D0 )\n\n      WRITE (*,*) C\n\n      DO 110 IR=1,NROW\n         DO 100 IC=1,NCOL\n            Z = DCMPLX( X(IC), Y(IR) )\n            I  = 1\n            CLR = ' '\n 10         CONTINUE\n            Z = Z*Z + C\n            IF ( 2.0D0 .LT. CDABS(Z) ) THEN\n               CLR = MAP(MOD(I,NMAP-1)+1)\n               GOTO 20\n            END IF\n            I = I + 1\n            IF ( MX .GT. I ) GOTO 10\n 20         CONTINUE\n            LINE(IC) = CLR\n 100     CONTINUE\n         WRITE(*,*) (LINE(J),J=1,NCOL)\n 110  CONTINUE\n      \n      STOP\n      END\n\nC     ==================================================================\n      SUBROUTINE LINSPACE( N, A, S, F )\nC     ------------------------------------------------------------------\n      INTEGER N\n      REAL*8  N A(N), S, F\n      INTEGER I\n      REAL*8  D\n      D = (F-S)/DBLE(N-1)\n      A(1) = S\n      DO 10 I=2,N\n         A(I) = A(I-1) + D\n 10   CONTINUE\n      RETURN\n      END\n", "target": "import javax.swing.*;\nimport java.awt.*;\nimport java.awt.image.BufferedImage;\n\npublic class JuliaSet extends JPanel {\n    private static final int MAX_ITERATIONS = 300;\n    private static final double ZOOM = 1;\n    private static final double CX = -0.7;\n    private static final double CY = 0.27015;\n    private static final double MOVE_X = 0;\n    private static final double MOVE_Y = 0;\n\n    public JuliaSet() {\n        setPreferredSize(new Dimension(800, 600));\n        setBackground(Color.white);\n    }\n\n    void drawJuliaSet(Graphics2D g) {\n        int w = getWidth();\n        int h = getHeight();\n        BufferedImage image = new BufferedImage(w, h, BufferedImage.TYPE_INT_RGB);\n\n        for (int x = 0; x < w; x++) {\n            for (int y = 0; y < h; y++) {\n                double zx = 1.5 * (x - w / 2) / (0.5 * ZOOM * w) + MOVE_X;\n                double zy = (y - h / 2) / (0.5 * ZOOM * h) + MOVE_Y;\n                float i = MAX_ITERATIONS;\n                while (zx * zx + zy * zy < 4 && i > 0) {\n                    double tmp = zx * zx - zy * zy + CX;\n                    zy = 2.0 * zx * zy + CY;\n                    zx = tmp;\n                    i--;\n                }\n                int c = Color.HSBtoRGB((MAX_ITERATIONS / i) % 1, 1, i > 0 ? 1 : 0);\n                image.setRGB(x, y, c);\n            }\n        }\n        g.drawImage(image, 0, 0, null);\n    }\n\n    @Override\n    public void paintComponent(Graphics gg) {\n        super.paintComponent(gg);\n        Graphics2D g = (Graphics2D) gg;\n        g.setRenderingHint(RenderingHints.KEY_ANTIALIASING,\n                RenderingHints.VALUE_ANTIALIAS_ON);\n        drawJuliaSet(g);\n    }\n\n    public static void main(String[] args) {\n        SwingUtilities.invokeLater(() -> {\n            JFrame f = new JFrame();\n            f.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n            f.setTitle(\"Julia Set\");\n            f.setResizable(false);\n            f.add(new JuliaSet(), BorderLayout.CENTER);\n            f.pack();\n            f.setLocationRelativeTo(null);\n            f.setVisible(true);\n        });\n    }\n}\n"}
{"id": 64035, "name": "Julia set", "source": "Translate Fortran to Python: C     ==================================================================\n      PROGRAM JULIA\nC     ------------------------------------------------------------------\n      INTEGER    NMAP,NROW,NCOL\n      COMPLEX*16 C\n      PARAMETER(NMAP=11,NROW=40,NCOL=100,C=(-0.798D0,0.1618D0))\n      CHARACTER*1 MAP(NMAP)\n      DATA MAP /' ','.',':','-','=','+','*','#','%','$','@'/\n      REAL*8      X(NCOL), Y(NROW)\n      INTEGER     IR, IC, I, J, MX\n      CHARACTER*1 CLR, LINE(NCOL)\n      COMPLEX*16  Z\n\n      MX = (NMAP-1)*5\n      CALL LINSPACE( NCOL, X, -1.5D0,  1.5D0 )\n      CALL LINSPACE( NROW, Y,  1.0D0, -1.0D0 )\n\n      WRITE (*,*) C\n\n      DO 110 IR=1,NROW\n         DO 100 IC=1,NCOL\n            Z = DCMPLX( X(IC), Y(IR) )\n            I  = 1\n            CLR = ' '\n 10         CONTINUE\n            Z = Z*Z + C\n            IF ( 2.0D0 .LT. CDABS(Z) ) THEN\n               CLR = MAP(MOD(I,NMAP-1)+1)\n               GOTO 20\n            END IF\n            I = I + 1\n            IF ( MX .GT. I ) GOTO 10\n 20         CONTINUE\n            LINE(IC) = CLR\n 100     CONTINUE\n         WRITE(*,*) (LINE(J),J=1,NCOL)\n 110  CONTINUE\n      \n      STOP\n      END\n\nC     ==================================================================\n      SUBROUTINE LINSPACE( N, A, S, F )\nC     ------------------------------------------------------------------\n      INTEGER N\n      REAL*8  N A(N), S, F\n      INTEGER I\n      REAL*8  D\n      D = (F-S)/DBLE(N-1)\n      A(1) = S\n      DO 10 I=2,N\n         A(I) = A(I-1) + D\n 10   CONTINUE\n      RETURN\n      END\n", "target": "from __future__ import division\n\ncX = -0.7\ncY = 0.27015\nmaxIter = 300\n\ndef setup():\n    size(640, 480)\n\ndef draw():\n    for x in range(width):\n        for y in range(height):\n            zx = 1.5 * (x - width / 2) / (0.5 * width)\n            zy = (y - height / 2) / (0.5 * height)\n            i = maxIter\n            while zx * zx + zy * zy < 4 and i > 0:\n                tmp = zx * zx - zy * zy + cX\n                zy = 2.0 * zx * zy + cY\n                zx = tmp\n                i -= 1\n            colorMode(HSB)\n            c = color(i / maxIter * 255, 255, 255 if i > 1 else 0)\n            set(x, y, c)\n"}
{"id": 64036, "name": "Julia set", "source": "Translate Fortran to Python: C     ==================================================================\n      PROGRAM JULIA\nC     ------------------------------------------------------------------\n      INTEGER    NMAP,NROW,NCOL\n      COMPLEX*16 C\n      PARAMETER(NMAP=11,NROW=40,NCOL=100,C=(-0.798D0,0.1618D0))\n      CHARACTER*1 MAP(NMAP)\n      DATA MAP /' ','.',':','-','=','+','*','#','%','$','@'/\n      REAL*8      X(NCOL), Y(NROW)\n      INTEGER     IR, IC, I, J, MX\n      CHARACTER*1 CLR, LINE(NCOL)\n      COMPLEX*16  Z\n\n      MX = (NMAP-1)*5\n      CALL LINSPACE( NCOL, X, -1.5D0,  1.5D0 )\n      CALL LINSPACE( NROW, Y,  1.0D0, -1.0D0 )\n\n      WRITE (*,*) C\n\n      DO 110 IR=1,NROW\n         DO 100 IC=1,NCOL\n            Z = DCMPLX( X(IC), Y(IR) )\n            I  = 1\n            CLR = ' '\n 10         CONTINUE\n            Z = Z*Z + C\n            IF ( 2.0D0 .LT. CDABS(Z) ) THEN\n               CLR = MAP(MOD(I,NMAP-1)+1)\n               GOTO 20\n            END IF\n            I = I + 1\n            IF ( MX .GT. I ) GOTO 10\n 20         CONTINUE\n            LINE(IC) = CLR\n 100     CONTINUE\n         WRITE(*,*) (LINE(J),J=1,NCOL)\n 110  CONTINUE\n      \n      STOP\n      END\n\nC     ==================================================================\n      SUBROUTINE LINSPACE( N, A, S, F )\nC     ------------------------------------------------------------------\n      INTEGER N\n      REAL*8  N A(N), S, F\n      INTEGER I\n      REAL*8  D\n      D = (F-S)/DBLE(N-1)\n      A(1) = S\n      DO 10 I=2,N\n         A(I) = A(I-1) + D\n 10   CONTINUE\n      RETURN\n      END\n", "target": "from __future__ import division\n\ncX = -0.7\ncY = 0.27015\nmaxIter = 300\n\ndef setup():\n    size(640, 480)\n\ndef draw():\n    for x in range(width):\n        for y in range(height):\n            zx = 1.5 * (x - width / 2) / (0.5 * width)\n            zy = (y - height / 2) / (0.5 * height)\n            i = maxIter\n            while zx * zx + zy * zy < 4 and i > 0:\n                tmp = zx * zx - zy * zy + cX\n                zy = 2.0 * zx * zy + cY\n                zx = tmp\n                i -= 1\n            colorMode(HSB)\n            c = color(i / maxIter * 255, 255, 255 if i > 1 else 0)\n            set(x, y, c)\n"}
{"id": 64402, "name": "Calculating the value of e", "source": "Translate Fortran to C#: Program eee\nimplicit none\ninteger, parameter  :: QP = selected_real_kind(16)\nreal(QP), parameter :: one = 1.0\nreal(QP)            :: ee\n\nwrite(*,*) '    exp(1.) ', exp(1._QP)\n\nee = 1. +(one +(one +(one +(one +(one+ (one +(one +(one +(one +(one +(one & \n        +(one +(one +(one +(one +(one +(one +(one +(one +(one +(one)      & \n        /21.)/20.)/19.)/18.)/17.)/16.)/15.)/14.)/13.)/12.)/11.)/10.)/9.)  &\n        /8.)/7.)/6.)/5.)/4.)/3.)/2.)\n\nwrite(*,*) ' polynomial ', ee\n\t\t\t   \nend Program eee\n", "target": "using System;\n\nnamespace CalculateE {\n    class Program {\n        public const double EPSILON = 1.0e-15;\n\n        static void Main(string[] args) {\n            ulong fact = 1;\n            double e = 2.0;\n            double e0;\n            uint n = 2;\n            do {\n                e0 = e;\n                fact *= n++;\n                e += 1.0 / fact;\n            } while (Math.Abs(e - e0) >= EPSILON);\n            Console.WriteLine(\"e = {0:F15}\", e);\n        }\n    }\n}\n"}
{"id": 64403, "name": "Calculating the value of e", "source": "Translate Fortran to C#: Program eee\nimplicit none\ninteger, parameter  :: QP = selected_real_kind(16)\nreal(QP), parameter :: one = 1.0\nreal(QP)            :: ee\n\nwrite(*,*) '    exp(1.) ', exp(1._QP)\n\nee = 1. +(one +(one +(one +(one +(one+ (one +(one +(one +(one +(one +(one & \n        +(one +(one +(one +(one +(one +(one +(one +(one +(one +(one)      & \n        /21.)/20.)/19.)/18.)/17.)/16.)/15.)/14.)/13.)/12.)/11.)/10.)/9.)  &\n        /8.)/7.)/6.)/5.)/4.)/3.)/2.)\n\nwrite(*,*) ' polynomial ', ee\n\t\t\t   \nend Program eee\n", "target": "using System;\n\nnamespace CalculateE {\n    class Program {\n        public const double EPSILON = 1.0e-15;\n\n        static void Main(string[] args) {\n            ulong fact = 1;\n            double e = 2.0;\n            double e0;\n            uint n = 2;\n            do {\n                e0 = e;\n                fact *= n++;\n                e += 1.0 / fact;\n            } while (Math.Abs(e - e0) >= EPSILON);\n            Console.WriteLine(\"e = {0:F15}\", e);\n        }\n    }\n}\n"}
{"id": 64408, "name": "Calculating the value of e", "source": "Translate Fortran to Java: Program eee\nimplicit none\ninteger, parameter  :: QP = selected_real_kind(16)\nreal(QP), parameter :: one = 1.0\nreal(QP)            :: ee\n\nwrite(*,*) '    exp(1.) ', exp(1._QP)\n\nee = 1. +(one +(one +(one +(one +(one+ (one +(one +(one +(one +(one +(one & \n        +(one +(one +(one +(one +(one +(one +(one +(one +(one +(one)      & \n        /21.)/20.)/19.)/18.)/17.)/16.)/15.)/14.)/13.)/12.)/11.)/10.)/9.)  &\n        /8.)/7.)/6.)/5.)/4.)/3.)/2.)\n\nwrite(*,*) ' polynomial ', ee\n\t\t\t   \nend Program eee\n", "target": "public class CalculateE {\n    public static final double EPSILON = 1.0e-15;\n\n    public static void main(String[] args) {\n        long fact = 1;\n        double e = 2.0;\n        int n = 2;\n        double e0;\n        do {\n            e0 = e;\n            fact *= n++;\n            e += 1.0 / fact;\n        } while (Math.abs(e - e0) >= EPSILON);\n        System.out.printf(\"e =\u00a0%.15f\\n\", e);\n    }\n}\n"}
{"id": 64409, "name": "Calculating the value of e", "source": "Translate Fortran to Java: Program eee\nimplicit none\ninteger, parameter  :: QP = selected_real_kind(16)\nreal(QP), parameter :: one = 1.0\nreal(QP)            :: ee\n\nwrite(*,*) '    exp(1.) ', exp(1._QP)\n\nee = 1. +(one +(one +(one +(one +(one+ (one +(one +(one +(one +(one +(one & \n        +(one +(one +(one +(one +(one +(one +(one +(one +(one +(one)      & \n        /21.)/20.)/19.)/18.)/17.)/16.)/15.)/14.)/13.)/12.)/11.)/10.)/9.)  &\n        /8.)/7.)/6.)/5.)/4.)/3.)/2.)\n\nwrite(*,*) ' polynomial ', ee\n\t\t\t   \nend Program eee\n", "target": "public class CalculateE {\n    public static final double EPSILON = 1.0e-15;\n\n    public static void main(String[] args) {\n        long fact = 1;\n        double e = 2.0;\n        int n = 2;\n        double e0;\n        do {\n            e0 = e;\n            fact *= n++;\n            e += 1.0 / fact;\n        } while (Math.abs(e - e0) >= EPSILON);\n        System.out.printf(\"e =\u00a0%.15f\\n\", e);\n    }\n}\n"}
{"id": 64410, "name": "Calculating the value of e", "source": "Translate Fortran to Python: Program eee\nimplicit none\ninteger, parameter  :: QP = selected_real_kind(16)\nreal(QP), parameter :: one = 1.0\nreal(QP)            :: ee\n\nwrite(*,*) '    exp(1.) ', exp(1._QP)\n\nee = 1. +(one +(one +(one +(one +(one+ (one +(one +(one +(one +(one +(one & \n        +(one +(one +(one +(one +(one +(one +(one +(one +(one +(one)      & \n        /21.)/20.)/19.)/18.)/17.)/16.)/15.)/14.)/13.)/12.)/11.)/10.)/9.)  &\n        /8.)/7.)/6.)/5.)/4.)/3.)/2.)\n\nwrite(*,*) ' polynomial ', ee\n\t\t\t   \nend Program eee\n", "target": "import math\n\ne0 = 0\ne = 2\nn = 0\nfact = 1\nwhile(e-e0 > 1e-15):\n\te0 = e\n\tn += 1\n\tfact *= 2*n*(2*n+1)\n\te += (2.*n+2)/fact\n\nprint \"Computed e = \"+str(e)\nprint \"Real e = \"+str(math.e)\nprint \"Error = \"+str(math.e-e)\nprint \"Number of iterations = \"+str(n)\n"}
{"id": 64411, "name": "Calculating the value of e", "source": "Translate Fortran to Python: Program eee\nimplicit none\ninteger, parameter  :: QP = selected_real_kind(16)\nreal(QP), parameter :: one = 1.0\nreal(QP)            :: ee\n\nwrite(*,*) '    exp(1.) ', exp(1._QP)\n\nee = 1. +(one +(one +(one +(one +(one+ (one +(one +(one +(one +(one +(one & \n        +(one +(one +(one +(one +(one +(one +(one +(one +(one +(one)      & \n        /21.)/20.)/19.)/18.)/17.)/16.)/15.)/14.)/13.)/12.)/11.)/10.)/9.)  &\n        /8.)/7.)/6.)/5.)/4.)/3.)/2.)\n\nwrite(*,*) ' polynomial ', ee\n\t\t\t   \nend Program eee\n", "target": "import math\n\ne0 = 0\ne = 2\nn = 0\nfact = 1\nwhile(e-e0 > 1e-15):\n\te0 = e\n\tn += 1\n\tfact *= 2*n*(2*n+1)\n\te += (2.*n+2)/fact\n\nprint \"Computed e = \"+str(e)\nprint \"Real e = \"+str(math.e)\nprint \"Error = \"+str(math.e-e)\nprint \"Number of iterations = \"+str(n)\n"}
{"id": 64962, "name": "Symmetric difference", "source": "Translate Fortran to C#: program Symmetric_difference\nimplicit none\n\n  character(6) :: a(4) = (/ \"John  \", \"Bob   \", \"Mary  \", \"Serena\" /)\n  character(6) :: b(4) = (/ \"Jim   \", \"Mary  \", \"John  \", \"Bob   \" /)\n  integer :: i, j\n\nouter1: do i = 1, size(a)\n          do j = 1, i-1\n            if(a(i) == a(j)) cycle outer1   \n          end do\n          if(.not. any(b == a(i))) write(*,*) a(i)\n        end do outer1\n  \nouter2: do i = 1, size(b)\n          do j = 1, i-1\n            if(b(i) == b(j)) cycle outer2   \n          end do\n          if(.not. any(a == b(i))) write(*,*) b(i)\n        end do outer2\n      \nend program\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\nnamespace RosettaCode.SymmetricDifference\n{\n    public static class IEnumerableExtension\n    {\n        public static IEnumerable<T> SymmetricDifference<T>(this IEnumerable<T> @this, IEnumerable<T> that)\n        {\n            return @this.Except(that).Concat(that.Except(@this));\n        }\n    }\n\n    class Program\n    {\n        static void Main()\n        {\n            var a = new[] { \"John\", \"Bob\", \"Mary\", \"Serena\" };\n            var b = new[] { \"Jim\", \"Mary\", \"John\", \"Bob\" };\n\n            foreach (var element in a.SymmetricDifference(b))\n            {\n                Console.WriteLine(element);\n            }\n        }\n    }\n}\n"}
{"id": 64965, "name": "Symmetric difference", "source": "Translate Fortran to Java: program Symmetric_difference\nimplicit none\n\n  character(6) :: a(4) = (/ \"John  \", \"Bob   \", \"Mary  \", \"Serena\" /)\n  character(6) :: b(4) = (/ \"Jim   \", \"Mary  \", \"John  \", \"Bob   \" /)\n  integer :: i, j\n\nouter1: do i = 1, size(a)\n          do j = 1, i-1\n            if(a(i) == a(j)) cycle outer1   \n          end do\n          if(.not. any(b == a(i))) write(*,*) a(i)\n        end do outer1\n  \nouter2: do i = 1, size(b)\n          do j = 1, i-1\n            if(b(i) == b(j)) cycle outer2   \n          end do\n          if(.not. any(a == b(i))) write(*,*) b(i)\n        end do outer2\n      \nend program\n", "target": "Set<String> setA = new Set<String>{'John', 'Bob', 'Mary', 'Serena'};\nSet<String> setB = new Set<String>{'Jim', 'Mary', 'John', 'Bob'};\n\n\nSet<String> notInSetA = setB.clone();\nnotInSetA.removeAll(setA);\n\nSet<String> notInSetB = setA.clone();\nnotInSetB.removeAll(setB);\n\nSet<String> symmetricDifference = new Set<String>();\nsymmetricDifference.addAll(notInSetA);\nsymmetricDifference.addAll(notInSetB);\n\n\nSet<String> union = setA.clone();\nunion.addAll(setB);\n\nSet<String> intersection = setA.clone();\nintersection.retainAll(setB);\n\nSet<String> symmetricDifference2 = union.clone();\nsymmetricDifference2.removeAll(intersection);\n\nSystem.debug('Not in set A: ' + notInSetA);\nSystem.debug('Not in set B: ' + notInSetB);\nSystem.debug('Symmetric Difference: ' + symmetricDifference);\nSystem.debug('Symmetric Difference 2: ' + symmetricDifference2);\n"}
{"id": 64966, "name": "Symmetric difference", "source": "Translate Fortran to Python: program Symmetric_difference\nimplicit none\n\n  character(6) :: a(4) = (/ \"John  \", \"Bob   \", \"Mary  \", \"Serena\" /)\n  character(6) :: b(4) = (/ \"Jim   \", \"Mary  \", \"John  \", \"Bob   \" /)\n  integer :: i, j\n\nouter1: do i = 1, size(a)\n          do j = 1, i-1\n            if(a(i) == a(j)) cycle outer1   \n          end do\n          if(.not. any(b == a(i))) write(*,*) a(i)\n        end do outer1\n  \nouter2: do i = 1, size(b)\n          do j = 1, i-1\n            if(b(i) == b(j)) cycle outer2   \n          end do\n          if(.not. any(a == b(i))) write(*,*) b(i)\n        end do outer2\n      \nend program\n", "target": ">>> setA = {\"John\", \"Bob\", \"Mary\", \"Serena\"}\n>>> setB = {\"Jim\", \"Mary\", \"John\", \"Bob\"}\n>>> setA ^ setB \n{'Jim', 'Serena'}\n>>> setA - setB \n{'Serena'}\n>>> setB - setA \n{'Jim'}\n>>> setA | setB \n{'John', 'Bob', 'Jim', 'Serena', 'Mary'}\n>>> setA & setB \n{'Bob', 'John', 'Mary'}\n"}
{"id": 65195, "name": "Inheritance_Single", "source": "Translate Fortran to C#: module anim\n\n  type animal\n  end type animal\n\n  type, extends(animal) :: dog\n  end type dog\n\n  type, extends(animal) :: cat\n  end type cat\n\n  type, extends(dog) :: lab\n  end type lab\n\n  type, extends(dog) :: collie\n  end type collie\n\nend module anim\n", "target": "class Animal\n{ \n   \n  \n}\n\nclass Dog : Animal\n{ \n   \n  \n}\n\nclass Lab : Dog\n{ \n   \n  \n}\n\nclass Collie : Dog\n{ \n  \n  \n}\n\nclass Cat : Animal\n{ \n  \n  \n}\n"}
{"id": 65197, "name": "Inheritance_Single", "source": "Translate Fortran to Java: module anim\n\n  type animal\n  end type animal\n\n  type, extends(animal) :: dog\n  end type dog\n\n  type, extends(animal) :: cat\n  end type cat\n\n  type, extends(dog) :: lab\n  end type lab\n\n  type, extends(dog) :: collie\n  end type collie\n\nend module anim\n", "target": "public class Animal{\n   \n}\n"}
{"id": 65198, "name": "Inheritance_Single", "source": "Translate Fortran to Python: module anim\n\n  type animal\n  end type animal\n\n  type, extends(animal) :: dog\n  end type dog\n\n  type, extends(animal) :: cat\n  end type cat\n\n  type, extends(dog) :: lab\n  end type lab\n\n  type, extends(dog) :: collie\n  end type collie\n\nend module anim\n", "target": "class Animal:\n  pass \n\nclass Dog(Animal):\n  pass \n\nclass Cat(Animal):\n  pass \n\nclass Lab(Dog):\n  pass \n\nclass Collie(Dog):\n  pass \n"}
{"id": 65426, "name": "Averages_Mode", "source": "Translate Fortran to C#: program mode_test\n  use Qsort_Module only Qsort => sort\n  implicit none\n\n  integer, parameter    :: S = 10\n  integer, dimension(S) :: a1 = (/ -1, 7, 7, 2, 2, 2, -1, 7, -3, -3 /)\n  integer, dimension(S) :: a2 = (/  1, 1, 1, 1, 1, 0, 2, 2, 2, 2 /)\n  integer, dimension(S) :: a3 = (/  0, 0, -1, -1, 9, 9, 3, 3, 7, 7 /)\n\n  integer, dimension(S) :: o\n  integer               :: l, trash\n\n  print *, stat_mode(a1)\n\n  trash = stat_mode(a1, o, l)\n  print *, o(1:l)\n  trash = stat_mode(a2, o, l)\n  print *, o(1:l)\n  trash = stat_mode(a3, o, l)\n  print *, o(1:l)\n\ncontains\n\n  \n  \n  \n  \n  \n  \n  integer function stat_mode(a, others, otherslen, ok)\n    integer, dimension(:), intent(in) :: a\n    logical, optional, intent(out)    :: ok\n    integer, dimension(size(a,1)), optional, intent(out) :: others\n    integer, optional, intent(out)    :: otherslen\n\n    \n    \n    \n    integer, dimension(size(a, 1)) :: ta, freq, idx\n    integer                        :: rs, i, tm, ml, tf\n\n    if ( present(ok) ) ok = .false.\n\n    select case ( size(a, 1) )\n    case (0)  \n       return\n    case (1)\n       if ( present(ok) ) ok = .true.\n       stat_mode = a(1)\n       return\n    case default\n       if ( present(ok) ) ok = .true.\n       ta = a         \n       call sort(ta)  \n       freq = 1\n       idx = 0\n       rs = 1         \n       \n       do i = 2, size(ta, 1)\n          if ( ta(i-1) == ta(i) ) then\n             freq(rs) = freq(rs) + 1\n          else\n             idx(rs) = i-1\n             rs = rs + 1\n          end if\n       end do\n       idx(rs) = i-1\n         \n       ml = maxloc(freq(1:rs), 1)  \n       tf = freq(ml)               \n       tm = ta(idx(ml))            \n\n       \n       if ( present(others) ) then\n          i = 1\n          others(1) = tm\n          do\n             freq(ml) = 0\n             ml = maxloc(freq(1:rs), 1)\n             if ( tf == freq(ml) ) then \n                i = i + 1               \n                others(i) = ta(idx(ml))\n             else\n                exit\n             end if\n          end do\n                \n          if ( present(otherslen) ) then\n             otherslen = i\n          end if\n\n       end if\n       stat_mode = tm\n    end select\n\n  end function stat_mode\n\nend program mode_test\n", "target": "using System;\nusing System.Collections;\nusing System.Collections.Generic;\nusing System.Linq;\n\nnamespace Test\n{\n    class Program\n    {\n     \n        static void Main(string[] args)\n        {\n            \n            List<int> myList = new List<int>() { 1, 1, 2, 4, 4 }; \n\n            var query =     from numbers in myList \n                            group numbers by numbers \n                            into groupedNumbers\n                            select new { Number = groupedNumbers.Key, Count = groupedNumbers.Count() }; \n            \n            int max = query.Max(g => g.Count);\n            IEnumerable<int> modes = query.Where(x => x.Count == max).Select(x => x.Number);\n            foreach (var item in modes)\n            {\n                Console.WriteLine(item);\n            }\n            \n            Console.ReadLine();\n        }\n\n             \n       \n    }\n     \n    \n}\n"}
{"id": 65429, "name": "Averages_Mode", "source": "Translate Fortran to Java: program mode_test\n  use Qsort_Module only Qsort => sort\n  implicit none\n\n  integer, parameter    :: S = 10\n  integer, dimension(S) :: a1 = (/ -1, 7, 7, 2, 2, 2, -1, 7, -3, -3 /)\n  integer, dimension(S) :: a2 = (/  1, 1, 1, 1, 1, 0, 2, 2, 2, 2 /)\n  integer, dimension(S) :: a3 = (/  0, 0, -1, -1, 9, 9, 3, 3, 7, 7 /)\n\n  integer, dimension(S) :: o\n  integer               :: l, trash\n\n  print *, stat_mode(a1)\n\n  trash = stat_mode(a1, o, l)\n  print *, o(1:l)\n  trash = stat_mode(a2, o, l)\n  print *, o(1:l)\n  trash = stat_mode(a3, o, l)\n  print *, o(1:l)\n\ncontains\n\n  \n  \n  \n  \n  \n  \n  integer function stat_mode(a, others, otherslen, ok)\n    integer, dimension(:), intent(in) :: a\n    logical, optional, intent(out)    :: ok\n    integer, dimension(size(a,1)), optional, intent(out) :: others\n    integer, optional, intent(out)    :: otherslen\n\n    \n    \n    \n    integer, dimension(size(a, 1)) :: ta, freq, idx\n    integer                        :: rs, i, tm, ml, tf\n\n    if ( present(ok) ) ok = .false.\n\n    select case ( size(a, 1) )\n    case (0)  \n       return\n    case (1)\n       if ( present(ok) ) ok = .true.\n       stat_mode = a(1)\n       return\n    case default\n       if ( present(ok) ) ok = .true.\n       ta = a         \n       call sort(ta)  \n       freq = 1\n       idx = 0\n       rs = 1         \n       \n       do i = 2, size(ta, 1)\n          if ( ta(i-1) == ta(i) ) then\n             freq(rs) = freq(rs) + 1\n          else\n             idx(rs) = i-1\n             rs = rs + 1\n          end if\n       end do\n       idx(rs) = i-1\n         \n       ml = maxloc(freq(1:rs), 1)  \n       tf = freq(ml)               \n       tm = ta(idx(ml))            \n\n       \n       if ( present(others) ) then\n          i = 1\n          others(1) = tm\n          do\n             freq(ml) = 0\n             ml = maxloc(freq(1:rs), 1)\n             if ( tf == freq(ml) ) then \n                i = i + 1               \n                others(i) = ta(idx(ml))\n             else\n                exit\n             end if\n          end do\n                \n          if ( present(otherslen) ) then\n             otherslen = i\n          end if\n\n       end if\n       stat_mode = tm\n    end select\n\n  end function stat_mode\n\nend program mode_test\n", "target": "import java.util.*;\n\npublic class Mode {\n    public static <T> List<T> mode(List<? extends T> coll) {\n        Map<T, Integer> seen = new HashMap<T, Integer>();\n        int max = 0;\n        List<T> maxElems = new ArrayList<T>();\n        for (T value : coll) {\n            if (seen.containsKey(value))\n                seen.put(value, seen.get(value) + 1);\n            else\n                seen.put(value, 1);\n            if (seen.get(value) > max) {\n                max = seen.get(value);\n                maxElems.clear();\n                maxElems.add(value);\n            } else if (seen.get(value) == max) {\n                maxElems.add(value);\n            }\n        }\n        return maxElems;\n    }\n\n    public static void main(String[] args) {\n        System.out.println(mode(Arrays.asList(1, 3, 6, 6, 6, 6, 7, 7, 12, 12, 17))); \n        System.out.println(mode(Arrays.asList(1, 1, 2, 4, 4))); \n    }\n}\n"}
{"id": 65430, "name": "Averages_Mode", "source": "Translate Fortran to Python: program mode_test\n  use Qsort_Module only Qsort => sort\n  implicit none\n\n  integer, parameter    :: S = 10\n  integer, dimension(S) :: a1 = (/ -1, 7, 7, 2, 2, 2, -1, 7, -3, -3 /)\n  integer, dimension(S) :: a2 = (/  1, 1, 1, 1, 1, 0, 2, 2, 2, 2 /)\n  integer, dimension(S) :: a3 = (/  0, 0, -1, -1, 9, 9, 3, 3, 7, 7 /)\n\n  integer, dimension(S) :: o\n  integer               :: l, trash\n\n  print *, stat_mode(a1)\n\n  trash = stat_mode(a1, o, l)\n  print *, o(1:l)\n  trash = stat_mode(a2, o, l)\n  print *, o(1:l)\n  trash = stat_mode(a3, o, l)\n  print *, o(1:l)\n\ncontains\n\n  \n  \n  \n  \n  \n  \n  integer function stat_mode(a, others, otherslen, ok)\n    integer, dimension(:), intent(in) :: a\n    logical, optional, intent(out)    :: ok\n    integer, dimension(size(a,1)), optional, intent(out) :: others\n    integer, optional, intent(out)    :: otherslen\n\n    \n    \n    \n    integer, dimension(size(a, 1)) :: ta, freq, idx\n    integer                        :: rs, i, tm, ml, tf\n\n    if ( present(ok) ) ok = .false.\n\n    select case ( size(a, 1) )\n    case (0)  \n       return\n    case (1)\n       if ( present(ok) ) ok = .true.\n       stat_mode = a(1)\n       return\n    case default\n       if ( present(ok) ) ok = .true.\n       ta = a         \n       call sort(ta)  \n       freq = 1\n       idx = 0\n       rs = 1         \n       \n       do i = 2, size(ta, 1)\n          if ( ta(i-1) == ta(i) ) then\n             freq(rs) = freq(rs) + 1\n          else\n             idx(rs) = i-1\n             rs = rs + 1\n          end if\n       end do\n       idx(rs) = i-1\n         \n       ml = maxloc(freq(1:rs), 1)  \n       tf = freq(ml)               \n       tm = ta(idx(ml))            \n\n       \n       if ( present(others) ) then\n          i = 1\n          others(1) = tm\n          do\n             freq(ml) = 0\n             ml = maxloc(freq(1:rs), 1)\n             if ( tf == freq(ml) ) then \n                i = i + 1               \n                others(i) = ta(idx(ml))\n             else\n                exit\n             end if\n          end do\n                \n          if ( present(otherslen) ) then\n             otherslen = i\n          end if\n\n       end if\n       stat_mode = tm\n    end select\n\n  end function stat_mode\n\nend program mode_test\n", "target": ">>> from collections import defaultdict\n>>> def modes(values):\n\tcount = defaultdict(int)\n\tfor v in values:\n\t\tcount[v] +=1\n\tbest = max(count.values())\n\treturn [k for k,v in count.items() if v == best]\n\n>>> modes([1,3,6,6,6,6,7,7,12,12,17])\n[6]\n>>> modes((1,1,2,4,4))\n[1, 4]\n"}
{"id": 65671, "name": "Monte Carlo methods", "source": "Translate Fortran to C#: MODULE Simulation\n \n   IMPLICIT NONE\n \n   CONTAINS\n \n   FUNCTION Pi(samples)\n     REAL :: Pi\n     REAL :: coords(2), length\n     INTEGER :: i, in_circle, samples\n  \n     in_circle = 0\n     DO i=1, samples\n       CALL RANDOM_NUMBER(coords)\n       coords = coords * 2 - 1\n       length = SQRT(coords(1)*coords(1) + coords(2)*coords(2))\n       IF (length <= 1) in_circle = in_circle + 1\n     END DO\n     Pi = 4.0 * REAL(in_circle) / REAL(samples)\n   END FUNCTION Pi\n \n END MODULE Simulation\n  \n PROGRAM MONTE_CARLO\n \n   USE Simulation \n   \n   INTEGER :: n = 10000\n \n   DO WHILE (n <= 100000000)\n     WRITE (*,*) n, Pi(n)\n     n = n * 10\n   END DO\n     \n END PROGRAM MONTE_CARLO\n", "target": "using System;\n\nclass Program {\n    static double MonteCarloPi(int n) {\n        int inside = 0;\n        Random r = new Random();\n\n        for (int i = 0; i < n; i++) {\n            if (Math.Pow(r.NextDouble(), 2)+ Math.Pow(r.NextDouble(), 2) <= 1) {\n                inside++;\n            }\n        }\n\n        return 4.0 * inside / n;\n    }\n\n    static void Main(string[] args) {\n        int value = 1000;\n        for (int n = 0; n < 5; n++) {\n            value *= 10;\n            Console.WriteLine(\"{0}:{1}\", value.ToString(\"#,###\").PadLeft(11, ' '), MonteCarloPi(value));\n        }\n    }\n}\n"}
{"id": 65674, "name": "Monte Carlo methods", "source": "Translate Fortran to Java: MODULE Simulation\n \n   IMPLICIT NONE\n \n   CONTAINS\n \n   FUNCTION Pi(samples)\n     REAL :: Pi\n     REAL :: coords(2), length\n     INTEGER :: i, in_circle, samples\n  \n     in_circle = 0\n     DO i=1, samples\n       CALL RANDOM_NUMBER(coords)\n       coords = coords * 2 - 1\n       length = SQRT(coords(1)*coords(1) + coords(2)*coords(2))\n       IF (length <= 1) in_circle = in_circle + 1\n     END DO\n     Pi = 4.0 * REAL(in_circle) / REAL(samples)\n   END FUNCTION Pi\n \n END MODULE Simulation\n  \n PROGRAM MONTE_CARLO\n \n   USE Simulation \n   \n   INTEGER :: n = 10000\n \n   DO WHILE (n <= 100000000)\n     WRITE (*,*) n, Pi(n)\n     n = n * 10\n   END DO\n     \n END PROGRAM MONTE_CARLO\n", "target": "public class MC {\n\tpublic static void main(String[] args) {\n\t\tSystem.out.println(getPi(10000));\n\t\tSystem.out.println(getPi(100000));\n\t\tSystem.out.println(getPi(1000000));\n\t\tSystem.out.println(getPi(10000000));\n\t\tSystem.out.println(getPi(100000000));\n\t\t\n\t}\n\tpublic static double getPi(int numThrows){\n\t\tint inCircle= 0;\n\t\tfor(int i= 0;i < numThrows;i++){\n\t\t\t\n\t\t\t\n\t\t\tdouble randX= (Math.random() * 2) - 1;\n\t\t\tdouble randY= (Math.random() * 2) - 1;\n\t\t\t\n\t\t\tdouble dist= Math.sqrt(randX * randX + randY * randY);\n\t\t\t\n\t\t\tif(dist < 1){\n\t\t\t\tinCircle++;\n\t\t\t}\n\t\t}\n\t\treturn 4.0 * inCircle / numThrows;\n\t}\n}\n"}
{"id": 65675, "name": "Monte Carlo methods", "source": "Translate Fortran to Python: MODULE Simulation\n \n   IMPLICIT NONE\n \n   CONTAINS\n \n   FUNCTION Pi(samples)\n     REAL :: Pi\n     REAL :: coords(2), length\n     INTEGER :: i, in_circle, samples\n  \n     in_circle = 0\n     DO i=1, samples\n       CALL RANDOM_NUMBER(coords)\n       coords = coords * 2 - 1\n       length = SQRT(coords(1)*coords(1) + coords(2)*coords(2))\n       IF (length <= 1) in_circle = in_circle + 1\n     END DO\n     Pi = 4.0 * REAL(in_circle) / REAL(samples)\n   END FUNCTION Pi\n \n END MODULE Simulation\n  \n PROGRAM MONTE_CARLO\n \n   USE Simulation \n   \n   INTEGER :: n = 10000\n \n   DO WHILE (n <= 100000000)\n     WRITE (*,*) n, Pi(n)\n     n = n * 10\n   END DO\n     \n END PROGRAM MONTE_CARLO\n", "target": ">>> import random, math\n>>> throws = 1000\n>>> 4.0 * sum(math.hypot(*[random.random()*2-1\n\t                 for q in [0,1]]) < 1\n              for p in xrange(throws)) / float(throws)\n3.1520000000000001\n>>> throws = 1000000\n>>> 4.0 * sum(math.hypot(*[random.random()*2-1\n\t                 for q in [0,1]]) < 1\n              for p in xrange(throws)) / float(throws)\n3.1396359999999999\n>>> throws = 100000000\n>>> 4.0 * sum(math.hypot(*[random.random()*2-1\n\t                 for q in [0,1]]) < 1\n              for p in xrange(throws)) / float(throws)\n3.1415666400000002\n"}
{"id": 66019, "name": "N'th", "source": "Translate Fortran to C#: \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nprogram nth\n  implicit none\n  logical :: need\n  integer :: here, there, n, i, iostat\n  read(5,*,iostat=iostat) here, there\n  if (iostat .ne. 0) then\n     write(6,*)'such bad input never before seen.'\n     write(6,*)'I AYE EYE QUIT\n     call exit(1)\n  end if\n  need = .false.\n  n = abs(there - here) + 1\n  i = 0\n  do while (0 /= mod(3+mod(here-i, 3), 3))\n     write(6,'(a22)',advance='no') ''\n     i = i+1\n  end do\n  do i = here, there, sign(1, there-here)\n     write(6,'(a22)',advance='no') ordinate(i)\n     if (2 /= mod(i,3)) then\n        need = .true.\n     else\n        write(6,'(a)')''\n        need = .false.\n     end if\n  end do\n  if (need) write(6,'(a)')''\n\ncontains\n\n  character(len=22) function ordinate(n)\n    character(len=19) :: a\n    character(len=20), parameter :: &\n         &a09 =   \"thstndrdthththththth\",&\n         &ateen = \"thththththththththth\"\n    integer :: ones, tens, ones_index\n    integer, intent(in) :: n\n    write(a,'(i19)') n\n    ones = mod(n,10)\n    tens = mod(n,100)\n    ones_index = ones*2+1\n    if (n < 1000) then\n       if ((10 .le. tens) .and. (tens .lt. 20)) then\n          ordinate = a // \"'\" // ateen(ones_index:ones_index+1)\n          \n       else\n          ordinate = a // \"'\" // a09(ones_index:ones_index+1)\n          \n       end if\n    else\n       if ((10 .le. tens) .and. (tens .lt. 20)) then\n          ordinate = a // ateen(ones_index:ones_index+1)\n       else\n          ordinate = a // a09(ones_index:ones_index+1)\n       end if\n    end if\n  end function ordinate\n\nend program nth\n", "target": "using System;\nusing System.Linq;\n\nclass Program\n{\n    private static string Ordinalize(int i)\n    {\n        i = Math.Abs(i);\n\n        if (new[] {11, 12, 13}.Contains(i%100))\n            return i + \"th\";\n\n        switch (i%10)\n        {\n            case 1:\n                return i + \"st\";\n            case 2:\n                return i + \"nd\";\n            case 3:\n                return i + \"rd\";\n            default:\n                return i + \"th\";\n        }\n    }\n\n    static void Main()\n    {\n        Console.WriteLine(string.Join(\" \", Enumerable.Range(0, 26).Select(Ordinalize)));\n        Console.WriteLine(string.Join(\" \", Enumerable.Range(250, 16).Select(Ordinalize)));\n        Console.WriteLine(string.Join(\" \", Enumerable.Range(1000, 26).Select(Ordinalize)));\n    }\n}\n"}
{"id": 66022, "name": "N'th", "source": "Translate Fortran to Java: \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nprogram nth\n  implicit none\n  logical :: need\n  integer :: here, there, n, i, iostat\n  read(5,*,iostat=iostat) here, there\n  if (iostat .ne. 0) then\n     write(6,*)'such bad input never before seen.'\n     write(6,*)'I AYE EYE QUIT\n     call exit(1)\n  end if\n  need = .false.\n  n = abs(there - here) + 1\n  i = 0\n  do while (0 /= mod(3+mod(here-i, 3), 3))\n     write(6,'(a22)',advance='no') ''\n     i = i+1\n  end do\n  do i = here, there, sign(1, there-here)\n     write(6,'(a22)',advance='no') ordinate(i)\n     if (2 /= mod(i,3)) then\n        need = .true.\n     else\n        write(6,'(a)')''\n        need = .false.\n     end if\n  end do\n  if (need) write(6,'(a)')''\n\ncontains\n\n  character(len=22) function ordinate(n)\n    character(len=19) :: a\n    character(len=20), parameter :: &\n         &a09 =   \"thstndrdthththththth\",&\n         &ateen = \"thththththththththth\"\n    integer :: ones, tens, ones_index\n    integer, intent(in) :: n\n    write(a,'(i19)') n\n    ones = mod(n,10)\n    tens = mod(n,100)\n    ones_index = ones*2+1\n    if (n < 1000) then\n       if ((10 .le. tens) .and. (tens .lt. 20)) then\n          ordinate = a // \"'\" // ateen(ones_index:ones_index+1)\n          \n       else\n          ordinate = a // \"'\" // a09(ones_index:ones_index+1)\n          \n       end if\n    else\n       if ((10 .le. tens) .and. (tens .lt. 20)) then\n          ordinate = a // ateen(ones_index:ones_index+1)\n       else\n          ordinate = a // a09(ones_index:ones_index+1)\n       end if\n    end if\n  end function ordinate\n\nend program nth\n", "target": "public class Nth {\n\tpublic static String ordinalAbbrev(int n){\n\t\tString ans = \"th\"; \n\t\tif(n % 100 / 10 == 1) return ans; \n\t\tswitch(n % 10){\n\t\t\tcase 1: ans = \"st\"; break;\n\t\t\tcase 2: ans = \"nd\"; break;\n\t\t\tcase 3: ans = \"rd\"; break;\n\t\t}\n\t\treturn ans;\n\t}\n\t\n\tpublic static void main(String[] args){\n\t\tfor(int i = 0; i <= 25;i++){\n\t\t\tSystem.out.print(i + ordinalAbbrev(i) + \" \");\n\t\t}\n\t\tSystem.out.println();\n\t\tfor(int i = 250; i <= 265;i++){\n\t\t\tSystem.out.print(i + ordinalAbbrev(i) + \" \");\n\t\t}\n\t\tSystem.out.println();\n\t\tfor(int i = 1000; i <= 1025;i++){\n\t\t\tSystem.out.print(i + ordinalAbbrev(i) + \" \");\n\t\t}\n\t}\n}\n"}
{"id": 66023, "name": "N'th", "source": "Translate Fortran to Python: \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nprogram nth\n  implicit none\n  logical :: need\n  integer :: here, there, n, i, iostat\n  read(5,*,iostat=iostat) here, there\n  if (iostat .ne. 0) then\n     write(6,*)'such bad input never before seen.'\n     write(6,*)'I AYE EYE QUIT\n     call exit(1)\n  end if\n  need = .false.\n  n = abs(there - here) + 1\n  i = 0\n  do while (0 /= mod(3+mod(here-i, 3), 3))\n     write(6,'(a22)',advance='no') ''\n     i = i+1\n  end do\n  do i = here, there, sign(1, there-here)\n     write(6,'(a22)',advance='no') ordinate(i)\n     if (2 /= mod(i,3)) then\n        need = .true.\n     else\n        write(6,'(a)')''\n        need = .false.\n     end if\n  end do\n  if (need) write(6,'(a)')''\n\ncontains\n\n  character(len=22) function ordinate(n)\n    character(len=19) :: a\n    character(len=20), parameter :: &\n         &a09 =   \"thstndrdthththththth\",&\n         &ateen = \"thththththththththth\"\n    integer :: ones, tens, ones_index\n    integer, intent(in) :: n\n    write(a,'(i19)') n\n    ones = mod(n,10)\n    tens = mod(n,100)\n    ones_index = ones*2+1\n    if (n < 1000) then\n       if ((10 .le. tens) .and. (tens .lt. 20)) then\n          ordinate = a // \"'\" // ateen(ones_index:ones_index+1)\n          \n       else\n          ordinate = a // \"'\" // a09(ones_index:ones_index+1)\n          \n       end if\n    else\n       if ((10 .le. tens) .and. (tens .lt. 20)) then\n          ordinate = a // ateen(ones_index:ones_index+1)\n       else\n          ordinate = a // a09(ones_index:ones_index+1)\n       end if\n    end if\n  end function ordinate\n\nend program nth\n", "target": "_suffix = ['th', 'st', 'nd', 'rd', 'th', 'th', 'th', 'th', 'th', 'th']\n\ndef nth(n):\n    return \"%i'%s\" % (n, _suffix[n%10] if n % 100 <= 10 or n % 100 > 20 else 'th')\n\nif __name__ == '__main__':\n    for j in range(0,1001, 250):\n        print(' '.join(nth(i) for i in list(range(j, j+25))))\n"}
{"id": 66371, "name": "Levenshtein distance", "source": "Translate Fortran to C#: program demo_edit_distance\ncharacter(len=:),allocatable :: sources(:),targets(:)\ninteger,allocatable          :: answers(:),expected(:)\n\nsources=[character(len=20)   :: \"kitten\",  \"rosettacode\",   \"Saturday\", \"sleep\",    \"qwerty\", \"Fortran\" ]\ntargets=[character(len=20)   :: \"sitting\", \"raisethysword\", \"Sunday\",   \"fleeting\", \"qweryt\", \"Fortran\" ]\nexpected=[                       3,         8,               3,          5,          2,        0        ]\n\nanswers=edit_distance(sources,targets)\n\ndo i=1, size(sources)\n   write(*,'(*(g0,1x))') sources(i), targets(i), answers(i), answers(i) == expected(i)\nenddo\n\nwrite(*,*)edit_distance(\"here's a bunch of words\", \"to wring out this code\")==18\n\ncontains\n\npure elemental integer function edit_distance (source,target)\n\n\ncharacter(len=*), intent(in) :: source, target\ninteger                      :: len_source, len_target, i, j, cost\ninteger                      :: matrix(0:len_trim(source), 0:len_trim(target))\n   len_source = len_trim(source)\n   len_target = len_trim(target)\n   matrix(:,0) = [(i,i=0,len_source)]\n   matrix(0,:) = [(j,j=0,len_target)]\n   do i = 1, len_source\n      do j = 1, len_target\n         cost=merge(0,1,source(i:i)==target(j:j))\n         matrix(i,j) = min(matrix(i-1,j)+1, matrix(i,j-1)+1, matrix(i-1,j-1)+cost)\n      enddo\n   enddo\n   edit_distance = matrix(len_source,len_target)\nend function edit_distance\n\nend program demo_edit_distance\n", "target": "using System;\n\nnamespace LevenshteinDistance\n{\n    class Program\n    {\n        static int LevenshteinDistance(string s, string t)\n        {\n            int n = s.Length;\n            int m = t.Length;\n            int[,] d = new int[n + 1, m + 1];\n\t\t\n\t    if (n == 0)\n\t    {\n\t\treturn m;\n\t    }\n\t\n\t    if (m == 0)\n\t    {\n\t\treturn n;\n\t    }\n\n            for (int i = 0; i <= n; i++)\n                d[i, 0] = i;\n            for (int j = 0; j <= m; j++)\n                d[0, j] = j;\n\t\t\t\n            for (int j = 1; j <= m; j++)\n                for (int i = 1; i <= n; i++)\n                    if (s[i - 1] == t[j - 1])\n                        d[i, j] = d[i - 1, j - 1];  \n                    else\n                        d[i, j] = Math.Min(Math.Min(\n                            d[i - 1, j] + 1,    \n                            d[i, j - 1] + 1),   \n                            d[i - 1, j - 1] + 1 \n                            );\n            return d[n, m];\n        }\n\n        static void Main(string[] args)\n        {\n            if (args.Length == 2)\n                Console.WriteLine(\"{0} -> {1} = {2}\",\n                    args[0], args[1], LevenshteinDistance(args[0], args[1]));\n            else\n                Console.WriteLine(\"Usage:-\\n\\nLevenshteinDistance <string1> <string2>\");\n        }\n    }\n}\n"}
{"id": 66372, "name": "Levenshtein distance", "source": "Translate Fortran to C#: program demo_edit_distance\ncharacter(len=:),allocatable :: sources(:),targets(:)\ninteger,allocatable          :: answers(:),expected(:)\n\nsources=[character(len=20)   :: \"kitten\",  \"rosettacode\",   \"Saturday\", \"sleep\",    \"qwerty\", \"Fortran\" ]\ntargets=[character(len=20)   :: \"sitting\", \"raisethysword\", \"Sunday\",   \"fleeting\", \"qweryt\", \"Fortran\" ]\nexpected=[                       3,         8,               3,          5,          2,        0        ]\n\nanswers=edit_distance(sources,targets)\n\ndo i=1, size(sources)\n   write(*,'(*(g0,1x))') sources(i), targets(i), answers(i), answers(i) == expected(i)\nenddo\n\nwrite(*,*)edit_distance(\"here's a bunch of words\", \"to wring out this code\")==18\n\ncontains\n\npure elemental integer function edit_distance (source,target)\n\n\ncharacter(len=*), intent(in) :: source, target\ninteger                      :: len_source, len_target, i, j, cost\ninteger                      :: matrix(0:len_trim(source), 0:len_trim(target))\n   len_source = len_trim(source)\n   len_target = len_trim(target)\n   matrix(:,0) = [(i,i=0,len_source)]\n   matrix(0,:) = [(j,j=0,len_target)]\n   do i = 1, len_source\n      do j = 1, len_target\n         cost=merge(0,1,source(i:i)==target(j:j))\n         matrix(i,j) = min(matrix(i-1,j)+1, matrix(i,j-1)+1, matrix(i-1,j-1)+cost)\n      enddo\n   enddo\n   edit_distance = matrix(len_source,len_target)\nend function edit_distance\n\nend program demo_edit_distance\n", "target": "using System;\n\nnamespace LevenshteinDistance\n{\n    class Program\n    {\n        static int LevenshteinDistance(string s, string t)\n        {\n            int n = s.Length;\n            int m = t.Length;\n            int[,] d = new int[n + 1, m + 1];\n\t\t\n\t    if (n == 0)\n\t    {\n\t\treturn m;\n\t    }\n\t\n\t    if (m == 0)\n\t    {\n\t\treturn n;\n\t    }\n\n            for (int i = 0; i <= n; i++)\n                d[i, 0] = i;\n            for (int j = 0; j <= m; j++)\n                d[0, j] = j;\n\t\t\t\n            for (int j = 1; j <= m; j++)\n                for (int i = 1; i <= n; i++)\n                    if (s[i - 1] == t[j - 1])\n                        d[i, j] = d[i - 1, j - 1];  \n                    else\n                        d[i, j] = Math.Min(Math.Min(\n                            d[i - 1, j] + 1,    \n                            d[i, j - 1] + 1),   \n                            d[i - 1, j - 1] + 1 \n                            );\n            return d[n, m];\n        }\n\n        static void Main(string[] args)\n        {\n            if (args.Length == 2)\n                Console.WriteLine(\"{0} -> {1} = {2}\",\n                    args[0], args[1], LevenshteinDistance(args[0], args[1]));\n            else\n                Console.WriteLine(\"Usage:-\\n\\nLevenshteinDistance <string1> <string2>\");\n        }\n    }\n}\n"}
{"id": 66378, "name": "Levenshtein distance", "source": "Translate Fortran to Java: program demo_edit_distance\ncharacter(len=:),allocatable :: sources(:),targets(:)\ninteger,allocatable          :: answers(:),expected(:)\n\nsources=[character(len=20)   :: \"kitten\",  \"rosettacode\",   \"Saturday\", \"sleep\",    \"qwerty\", \"Fortran\" ]\ntargets=[character(len=20)   :: \"sitting\", \"raisethysword\", \"Sunday\",   \"fleeting\", \"qweryt\", \"Fortran\" ]\nexpected=[                       3,         8,               3,          5,          2,        0        ]\n\nanswers=edit_distance(sources,targets)\n\ndo i=1, size(sources)\n   write(*,'(*(g0,1x))') sources(i), targets(i), answers(i), answers(i) == expected(i)\nenddo\n\nwrite(*,*)edit_distance(\"here's a bunch of words\", \"to wring out this code\")==18\n\ncontains\n\npure elemental integer function edit_distance (source,target)\n\n\ncharacter(len=*), intent(in) :: source, target\ninteger                      :: len_source, len_target, i, j, cost\ninteger                      :: matrix(0:len_trim(source), 0:len_trim(target))\n   len_source = len_trim(source)\n   len_target = len_trim(target)\n   matrix(:,0) = [(i,i=0,len_source)]\n   matrix(0,:) = [(j,j=0,len_target)]\n   do i = 1, len_source\n      do j = 1, len_target\n         cost=merge(0,1,source(i:i)==target(j:j))\n         matrix(i,j) = min(matrix(i-1,j)+1, matrix(i,j-1)+1, matrix(i-1,j-1)+cost)\n      enddo\n   enddo\n   edit_distance = matrix(len_source,len_target)\nend function edit_distance\n\nend program demo_edit_distance\n", "target": "public class Levenshtein {\n\n    public static int distance(String a, String b) {\n        a = a.toLowerCase();\n        b = b.toLowerCase();\n        \n        int [] costs = new int [b.length() + 1];\n        for (int j = 0; j < costs.length; j++)\n            costs[j] = j;\n        for (int i = 1; i <= a.length(); i++) {\n            \n            costs[0] = i;\n            int nw = i - 1;\n            for (int j = 1; j <= b.length(); j++) {\n                int cj = Math.min(1 + Math.min(costs[j], costs[j - 1]), a.charAt(i - 1) == b.charAt(j - 1) ? nw : nw + 1);\n                nw = costs[j];\n                costs[j] = cj;\n            }\n        }\n        return costs[b.length()];\n    }\n\n    public static void main(String [] args) {\n        String [] data = { \"kitten\", \"sitting\", \"saturday\", \"sunday\", \"rosettacode\", \"raisethysword\" };\n        for (int i = 0; i < data.length; i += 2)\n            System.out.println(\"distance(\" + data[i] + \", \" + data[i+1] + \") = \" + distance(data[i], data[i+1]));\n    }\n}\n"}
{"id": 66379, "name": "Levenshtein distance", "source": "Translate Fortran to Java: program demo_edit_distance\ncharacter(len=:),allocatable :: sources(:),targets(:)\ninteger,allocatable          :: answers(:),expected(:)\n\nsources=[character(len=20)   :: \"kitten\",  \"rosettacode\",   \"Saturday\", \"sleep\",    \"qwerty\", \"Fortran\" ]\ntargets=[character(len=20)   :: \"sitting\", \"raisethysword\", \"Sunday\",   \"fleeting\", \"qweryt\", \"Fortran\" ]\nexpected=[                       3,         8,               3,          5,          2,        0        ]\n\nanswers=edit_distance(sources,targets)\n\ndo i=1, size(sources)\n   write(*,'(*(g0,1x))') sources(i), targets(i), answers(i), answers(i) == expected(i)\nenddo\n\nwrite(*,*)edit_distance(\"here's a bunch of words\", \"to wring out this code\")==18\n\ncontains\n\npure elemental integer function edit_distance (source,target)\n\n\ncharacter(len=*), intent(in) :: source, target\ninteger                      :: len_source, len_target, i, j, cost\ninteger                      :: matrix(0:len_trim(source), 0:len_trim(target))\n   len_source = len_trim(source)\n   len_target = len_trim(target)\n   matrix(:,0) = [(i,i=0,len_source)]\n   matrix(0,:) = [(j,j=0,len_target)]\n   do i = 1, len_source\n      do j = 1, len_target\n         cost=merge(0,1,source(i:i)==target(j:j))\n         matrix(i,j) = min(matrix(i-1,j)+1, matrix(i,j-1)+1, matrix(i-1,j-1)+cost)\n      enddo\n   enddo\n   edit_distance = matrix(len_source,len_target)\nend function edit_distance\n\nend program demo_edit_distance\n", "target": "public class Levenshtein {\n\n    public static int distance(String a, String b) {\n        a = a.toLowerCase();\n        b = b.toLowerCase();\n        \n        int [] costs = new int [b.length() + 1];\n        for (int j = 0; j < costs.length; j++)\n            costs[j] = j;\n        for (int i = 1; i <= a.length(); i++) {\n            \n            costs[0] = i;\n            int nw = i - 1;\n            for (int j = 1; j <= b.length(); j++) {\n                int cj = Math.min(1 + Math.min(costs[j], costs[j - 1]), a.charAt(i - 1) == b.charAt(j - 1) ? nw : nw + 1);\n                nw = costs[j];\n                costs[j] = cj;\n            }\n        }\n        return costs[b.length()];\n    }\n\n    public static void main(String [] args) {\n        String [] data = { \"kitten\", \"sitting\", \"saturday\", \"sunday\", \"rosettacode\", \"raisethysword\" };\n        for (int i = 0; i < data.length; i += 2)\n            System.out.println(\"distance(\" + data[i] + \", \" + data[i+1] + \") = \" + distance(data[i], data[i+1]));\n    }\n}\n"}
{"id": 66380, "name": "Levenshtein distance", "source": "Translate Fortran to Python: program demo_edit_distance\ncharacter(len=:),allocatable :: sources(:),targets(:)\ninteger,allocatable          :: answers(:),expected(:)\n\nsources=[character(len=20)   :: \"kitten\",  \"rosettacode\",   \"Saturday\", \"sleep\",    \"qwerty\", \"Fortran\" ]\ntargets=[character(len=20)   :: \"sitting\", \"raisethysword\", \"Sunday\",   \"fleeting\", \"qweryt\", \"Fortran\" ]\nexpected=[                       3,         8,               3,          5,          2,        0        ]\n\nanswers=edit_distance(sources,targets)\n\ndo i=1, size(sources)\n   write(*,'(*(g0,1x))') sources(i), targets(i), answers(i), answers(i) == expected(i)\nenddo\n\nwrite(*,*)edit_distance(\"here's a bunch of words\", \"to wring out this code\")==18\n\ncontains\n\npure elemental integer function edit_distance (source,target)\n\n\ncharacter(len=*), intent(in) :: source, target\ninteger                      :: len_source, len_target, i, j, cost\ninteger                      :: matrix(0:len_trim(source), 0:len_trim(target))\n   len_source = len_trim(source)\n   len_target = len_trim(target)\n   matrix(:,0) = [(i,i=0,len_source)]\n   matrix(0,:) = [(j,j=0,len_target)]\n   do i = 1, len_source\n      do j = 1, len_target\n         cost=merge(0,1,source(i:i)==target(j:j))\n         matrix(i,j) = min(matrix(i-1,j)+1, matrix(i,j-1)+1, matrix(i-1,j-1)+cost)\n      enddo\n   enddo\n   edit_distance = matrix(len_source,len_target)\nend function edit_distance\n\nend program demo_edit_distance\n", "target": "def setup():\n    println(distance(\"kitten\", \"sitting\"))\n\ndef distance(a, b):\n    costs = []\n    for j in range(len(b) + 1):\n        costs.append(j)\n    for i in range(1, len(a) + 1):\n        costs[0] = i\n        nw = i - 1\n        for j in range(1, len(b) + 1):\n            cj = min(1 + min(costs[j], costs[j - 1]),\n                     nw if a[i - 1] == b[j - 1] else nw + 1)\n            nw = costs[j]\n            costs[j] = cj\n\n    return costs[len(b)]\n"}
{"id": 66381, "name": "Levenshtein distance", "source": "Translate Fortran to Python: program demo_edit_distance\ncharacter(len=:),allocatable :: sources(:),targets(:)\ninteger,allocatable          :: answers(:),expected(:)\n\nsources=[character(len=20)   :: \"kitten\",  \"rosettacode\",   \"Saturday\", \"sleep\",    \"qwerty\", \"Fortran\" ]\ntargets=[character(len=20)   :: \"sitting\", \"raisethysword\", \"Sunday\",   \"fleeting\", \"qweryt\", \"Fortran\" ]\nexpected=[                       3,         8,               3,          5,          2,        0        ]\n\nanswers=edit_distance(sources,targets)\n\ndo i=1, size(sources)\n   write(*,'(*(g0,1x))') sources(i), targets(i), answers(i), answers(i) == expected(i)\nenddo\n\nwrite(*,*)edit_distance(\"here's a bunch of words\", \"to wring out this code\")==18\n\ncontains\n\npure elemental integer function edit_distance (source,target)\n\n\ncharacter(len=*), intent(in) :: source, target\ninteger                      :: len_source, len_target, i, j, cost\ninteger                      :: matrix(0:len_trim(source), 0:len_trim(target))\n   len_source = len_trim(source)\n   len_target = len_trim(target)\n   matrix(:,0) = [(i,i=0,len_source)]\n   matrix(0,:) = [(j,j=0,len_target)]\n   do i = 1, len_source\n      do j = 1, len_target\n         cost=merge(0,1,source(i:i)==target(j:j))\n         matrix(i,j) = min(matrix(i-1,j)+1, matrix(i,j-1)+1, matrix(i-1,j-1)+cost)\n      enddo\n   enddo\n   edit_distance = matrix(len_source,len_target)\nend function edit_distance\n\nend program demo_edit_distance\n", "target": "def setup():\n    println(distance(\"kitten\", \"sitting\"))\n\ndef distance(a, b):\n    costs = []\n    for j in range(len(b) + 1):\n        costs.append(j)\n    for i in range(1, len(a) + 1):\n        costs[0] = i\n        nw = i - 1\n        for j in range(1, len(b) + 1):\n            cj = min(1 + min(costs[j], costs[j - 1]),\n                     nw if a[i - 1] == b[j - 1] else nw + 1)\n            nw = costs[j]\n            costs[j] = cj\n\n    return costs[len(b)]\n"}
{"id": 66857, "name": "15 puzzle game", "source": "Translate Fortran to C#: LOCZ = MINLOC(BOARD)\t\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Drawing;\nusing System.Windows.Forms;\n\npublic class FifteenPuzzle\n{\n    const int GridSize = 4; \n    const int BlockCount = 16;\n\n    static readonly Random R = new Random();\n\n    private List<Button> Puzzles = new List<Button>();\n    private int Moves = 0;\n    private DateTime Start;\n\n    public class Puzzle\n    {\n        private int mOrderedNumer;\n\n        public int CurrentNumber;\n\n        public int X;\n        public int Y;\n\n        public int InvX\n        {\n            get { return (GridSize - 1) - X; }\n        }\n        public int InvY\n        {\n            get { return (GridSize - 1) - Y; }\n        }\n\n        public Puzzle(int OrderedNumer)\n        {\n            mOrderedNumer = OrderedNumer;\n\n            CurrentNumber = OrderedNumer;\n\n            X = OrderedNumer % GridSize;\n            Y = OrderedNumer / GridSize;\n        }\n        public Puzzle(int OrderedNumer, int CurrentNumber)\n            : this(OrderedNumer)\n        {\n            this.CurrentNumber = CurrentNumber;\n        }\n\n        public bool IsEmptyPuzzle\n        {\n            get { return CurrentNumber >= (BlockCount - 1); }\n        }\n        public bool IsTruePlace\n        {\n            get { return (CurrentNumber == mOrderedNumer); }\n        }\n        public bool NearestWith(Puzzle OtherPz)\n        {\n            int dx = (X - OtherPz.X);\n            int dy = (Y - OtherPz.Y);\n\n            if ((dx == 0) && (dy <= 1) && (dy >= -1)) return true;\n            if ((dy == 0) && (dx <= 1) && (dx >= -1)) return true;\n\n            return false;\n        }\n\n        public override string ToString()\n        {\n            return (CurrentNumber + 1).ToString();\n        }\n    }\n\n    public static void Main(string[] args)\n    {\n        FifteenPuzzle Game = new FifteenPuzzle();\n        Application.Run(Game.CreateForm());\n    }\n\n    private Form CreateForm()\n    {\n        int ButtonSize = 50;\n        int ButtonMargin = 3;\n        int FormEdge = 9;\n\n        Font ButtonFont = new Font(\"Arial\", 15.75F, FontStyle.Regular);\n\n        Button StartButton = new Button();\n        StartButton.Location = new Point(FormEdge, (GridSize * (ButtonMargin + ButtonSize)) + FormEdge);\n        StartButton.Size = new Size(86, 23);\n        StartButton.Font = new Font(\"Arial\", 9.75F, FontStyle.Regular);\n        StartButton.Text = \"New Game\";\n        StartButton.UseVisualStyleBackColor = true;\n        StartButton.TabStop = false;\n\n        StartButton.Click += new EventHandler(NewGame);\n\n        int FormWidth = (GridSize * ButtonSize) + ((GridSize - 1) * ButtonMargin) + (FormEdge * 2);\n        int FormHeigth = FormWidth + StartButton.Height;\n\n        Form Form = new Form();\n        Form.Text = \"Fifteen\";\n        Form.ClientSize = new Size(FormWidth, FormHeigth);\n        Form.FormBorderStyle = FormBorderStyle.FixedSingle;\n        Form.MaximizeBox = false;\n        Form.SuspendLayout();\n\n        for (int i = 0; i < BlockCount; i++)\n        {\n            Button Bt = new Button();\n            Puzzle Pz = new Puzzle(i);\n\n            int PosX = FormEdge + (Pz.X) * (ButtonSize + ButtonMargin);\n            int PosY = FormEdge + (Pz.Y) * (ButtonSize + ButtonMargin);\n            Bt.Location = new Point(PosX, PosY);\n\n            Bt.Size = new Size(ButtonSize, ButtonSize);\n            Bt.Font = ButtonFont;\n\n            Bt.Text = Pz.ToString();\n            Bt.Tag = Pz;\n            Bt.UseVisualStyleBackColor = true;\n            Bt.TabStop = false;\n\n            Bt.Enabled = false;\n            if (Pz.IsEmptyPuzzle) Bt.Visible = false;\n\n            Bt.Click += new EventHandler(MovePuzzle);\n\n            Puzzles.Add(Bt);\n            Form.Controls.Add(Bt);\n        }\n\n        Form.Controls.Add(StartButton);\n        Form.ResumeLayout();\n\n        return Form;\n    }\n\n    private void NewGame(object Sender, EventArgs E)\n    {\n        do\n        {\n            for (int i = 0; i < Puzzles.Count; i++)\n            {\n                Button Bt1 = Puzzles[R.Next(i, Puzzles.Count)];\n                Button Bt2 = Puzzles[i];\n                Swap(Bt1, Bt2);\n            }\n        }\n        while (!IsSolvable());\n\n        for (int i = 0; i < Puzzles.Count; i++)\n        {\n            Puzzles[i].Enabled = true;\n        }\n\n        Moves = 0;\n        Start = DateTime.Now;\n    }\n\n    private void MovePuzzle(object Sender, EventArgs E)\n    {\n        Button Bt1 = (Button)Sender;\n        Puzzle Pz1 = (Puzzle)Bt1.Tag;\n\n        Button Bt2 = Puzzles.Find(Bt => ((Puzzle)Bt.Tag).IsEmptyPuzzle);\n        Puzzle Pz2 = (Puzzle)Bt2.Tag;\n\n        if (Pz1.NearestWith(Pz2))\n        {\n            Swap(Bt1, Bt2);\n            Moves++;\n        }\n\n        CheckWin();\n    }\n\n    private void CheckWin()\n    {\n        Button WrongPuzzle = Puzzles.Find(Bt => !((Puzzle)Bt.Tag).IsTruePlace);\n        bool UWin = (WrongPuzzle == null);\n\n        if (UWin)\n        {\n            for (int i = 0; i < Puzzles.Count; i++)\n            {\n                Puzzles[i].Enabled = false;\n            }\n\n            TimeSpan Elapsed = DateTime.Now - Start;\n            Elapsed = TimeSpan.FromSeconds(Math.Round(Elapsed.TotalSeconds, 0));\n            MessageBox.Show(String.Format(\"Solved in {0} moves. Time: {1}\", Moves, Elapsed));\n        }\n    }\n\n    private void Swap(Button Bt1, Button Bt2)\n    {\n        if (Bt1 == Bt2) return;\n\n        Puzzle Pz1 = (Puzzle)Bt1.Tag;\n        Puzzle Pz2 = (Puzzle)Bt2.Tag;\n\n        int g = Pz1.CurrentNumber;\n        Pz1.CurrentNumber = Pz2.CurrentNumber;\n        Pz2.CurrentNumber = g;\n\n        Bt1.Visible = true;\n        Bt1.Text = Pz1.ToString();\n        if (Pz1.IsEmptyPuzzle) Bt1.Visible = false;\n\n        Bt2.Visible = true;\n        Bt2.Text = Pz2.ToString();\n        if (Pz2.IsEmptyPuzzle) Bt2.Visible = false;\n    }\n\n    private bool IsSolvable()\n    {\n        \n        \n\n        int InvCount = 0;\n        for (int i = 0; i < Puzzles.Count - 1; i++)\n        {\n            for (int j = i + 1; j < Puzzles.Count; j++)\n            {\n                Puzzle Pz1 = (Puzzle)Puzzles[i].Tag;\n                if (Pz1.IsEmptyPuzzle) continue;\n\n                Puzzle Pz2 = (Puzzle)Puzzles[j].Tag;\n                if (Pz2.IsEmptyPuzzle) continue;\n\n                if (Pz1.CurrentNumber > Pz2.CurrentNumber) InvCount++;\n            }\n        }\n\n        Button EmptyBt = Puzzles.Find(Bt => ((Puzzle)Bt.Tag).IsEmptyPuzzle);\n        Puzzle EmptyPz = (Puzzle)EmptyBt.Tag;\n\n        bool Result = false;\n        if ((EmptyPz.InvY + 1) % 2 == 0) \n        {\n            \n            if (InvCount % 2 != 0) Result = true;\n        }\n        else \n        {\n            \n            if (InvCount % 2 == 0) Result = true;\n        }\n        return Result;\n    }\n}\n"}
{"id": 66858, "name": "15 puzzle game", "source": "Translate Fortran to C#: LOCZ = MINLOC(BOARD)\t\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Drawing;\nusing System.Windows.Forms;\n\npublic class FifteenPuzzle\n{\n    const int GridSize = 4; \n    const int BlockCount = 16;\n\n    static readonly Random R = new Random();\n\n    private List<Button> Puzzles = new List<Button>();\n    private int Moves = 0;\n    private DateTime Start;\n\n    public class Puzzle\n    {\n        private int mOrderedNumer;\n\n        public int CurrentNumber;\n\n        public int X;\n        public int Y;\n\n        public int InvX\n        {\n            get { return (GridSize - 1) - X; }\n        }\n        public int InvY\n        {\n            get { return (GridSize - 1) - Y; }\n        }\n\n        public Puzzle(int OrderedNumer)\n        {\n            mOrderedNumer = OrderedNumer;\n\n            CurrentNumber = OrderedNumer;\n\n            X = OrderedNumer % GridSize;\n            Y = OrderedNumer / GridSize;\n        }\n        public Puzzle(int OrderedNumer, int CurrentNumber)\n            : this(OrderedNumer)\n        {\n            this.CurrentNumber = CurrentNumber;\n        }\n\n        public bool IsEmptyPuzzle\n        {\n            get { return CurrentNumber >= (BlockCount - 1); }\n        }\n        public bool IsTruePlace\n        {\n            get { return (CurrentNumber == mOrderedNumer); }\n        }\n        public bool NearestWith(Puzzle OtherPz)\n        {\n            int dx = (X - OtherPz.X);\n            int dy = (Y - OtherPz.Y);\n\n            if ((dx == 0) && (dy <= 1) && (dy >= -1)) return true;\n            if ((dy == 0) && (dx <= 1) && (dx >= -1)) return true;\n\n            return false;\n        }\n\n        public override string ToString()\n        {\n            return (CurrentNumber + 1).ToString();\n        }\n    }\n\n    public static void Main(string[] args)\n    {\n        FifteenPuzzle Game = new FifteenPuzzle();\n        Application.Run(Game.CreateForm());\n    }\n\n    private Form CreateForm()\n    {\n        int ButtonSize = 50;\n        int ButtonMargin = 3;\n        int FormEdge = 9;\n\n        Font ButtonFont = new Font(\"Arial\", 15.75F, FontStyle.Regular);\n\n        Button StartButton = new Button();\n        StartButton.Location = new Point(FormEdge, (GridSize * (ButtonMargin + ButtonSize)) + FormEdge);\n        StartButton.Size = new Size(86, 23);\n        StartButton.Font = new Font(\"Arial\", 9.75F, FontStyle.Regular);\n        StartButton.Text = \"New Game\";\n        StartButton.UseVisualStyleBackColor = true;\n        StartButton.TabStop = false;\n\n        StartButton.Click += new EventHandler(NewGame);\n\n        int FormWidth = (GridSize * ButtonSize) + ((GridSize - 1) * ButtonMargin) + (FormEdge * 2);\n        int FormHeigth = FormWidth + StartButton.Height;\n\n        Form Form = new Form();\n        Form.Text = \"Fifteen\";\n        Form.ClientSize = new Size(FormWidth, FormHeigth);\n        Form.FormBorderStyle = FormBorderStyle.FixedSingle;\n        Form.MaximizeBox = false;\n        Form.SuspendLayout();\n\n        for (int i = 0; i < BlockCount; i++)\n        {\n            Button Bt = new Button();\n            Puzzle Pz = new Puzzle(i);\n\n            int PosX = FormEdge + (Pz.X) * (ButtonSize + ButtonMargin);\n            int PosY = FormEdge + (Pz.Y) * (ButtonSize + ButtonMargin);\n            Bt.Location = new Point(PosX, PosY);\n\n            Bt.Size = new Size(ButtonSize, ButtonSize);\n            Bt.Font = ButtonFont;\n\n            Bt.Text = Pz.ToString();\n            Bt.Tag = Pz;\n            Bt.UseVisualStyleBackColor = true;\n            Bt.TabStop = false;\n\n            Bt.Enabled = false;\n            if (Pz.IsEmptyPuzzle) Bt.Visible = false;\n\n            Bt.Click += new EventHandler(MovePuzzle);\n\n            Puzzles.Add(Bt);\n            Form.Controls.Add(Bt);\n        }\n\n        Form.Controls.Add(StartButton);\n        Form.ResumeLayout();\n\n        return Form;\n    }\n\n    private void NewGame(object Sender, EventArgs E)\n    {\n        do\n        {\n            for (int i = 0; i < Puzzles.Count; i++)\n            {\n                Button Bt1 = Puzzles[R.Next(i, Puzzles.Count)];\n                Button Bt2 = Puzzles[i];\n                Swap(Bt1, Bt2);\n            }\n        }\n        while (!IsSolvable());\n\n        for (int i = 0; i < Puzzles.Count; i++)\n        {\n            Puzzles[i].Enabled = true;\n        }\n\n        Moves = 0;\n        Start = DateTime.Now;\n    }\n\n    private void MovePuzzle(object Sender, EventArgs E)\n    {\n        Button Bt1 = (Button)Sender;\n        Puzzle Pz1 = (Puzzle)Bt1.Tag;\n\n        Button Bt2 = Puzzles.Find(Bt => ((Puzzle)Bt.Tag).IsEmptyPuzzle);\n        Puzzle Pz2 = (Puzzle)Bt2.Tag;\n\n        if (Pz1.NearestWith(Pz2))\n        {\n            Swap(Bt1, Bt2);\n            Moves++;\n        }\n\n        CheckWin();\n    }\n\n    private void CheckWin()\n    {\n        Button WrongPuzzle = Puzzles.Find(Bt => !((Puzzle)Bt.Tag).IsTruePlace);\n        bool UWin = (WrongPuzzle == null);\n\n        if (UWin)\n        {\n            for (int i = 0; i < Puzzles.Count; i++)\n            {\n                Puzzles[i].Enabled = false;\n            }\n\n            TimeSpan Elapsed = DateTime.Now - Start;\n            Elapsed = TimeSpan.FromSeconds(Math.Round(Elapsed.TotalSeconds, 0));\n            MessageBox.Show(String.Format(\"Solved in {0} moves. Time: {1}\", Moves, Elapsed));\n        }\n    }\n\n    private void Swap(Button Bt1, Button Bt2)\n    {\n        if (Bt1 == Bt2) return;\n\n        Puzzle Pz1 = (Puzzle)Bt1.Tag;\n        Puzzle Pz2 = (Puzzle)Bt2.Tag;\n\n        int g = Pz1.CurrentNumber;\n        Pz1.CurrentNumber = Pz2.CurrentNumber;\n        Pz2.CurrentNumber = g;\n\n        Bt1.Visible = true;\n        Bt1.Text = Pz1.ToString();\n        if (Pz1.IsEmptyPuzzle) Bt1.Visible = false;\n\n        Bt2.Visible = true;\n        Bt2.Text = Pz2.ToString();\n        if (Pz2.IsEmptyPuzzle) Bt2.Visible = false;\n    }\n\n    private bool IsSolvable()\n    {\n        \n        \n\n        int InvCount = 0;\n        for (int i = 0; i < Puzzles.Count - 1; i++)\n        {\n            for (int j = i + 1; j < Puzzles.Count; j++)\n            {\n                Puzzle Pz1 = (Puzzle)Puzzles[i].Tag;\n                if (Pz1.IsEmptyPuzzle) continue;\n\n                Puzzle Pz2 = (Puzzle)Puzzles[j].Tag;\n                if (Pz2.IsEmptyPuzzle) continue;\n\n                if (Pz1.CurrentNumber > Pz2.CurrentNumber) InvCount++;\n            }\n        }\n\n        Button EmptyBt = Puzzles.Find(Bt => ((Puzzle)Bt.Tag).IsEmptyPuzzle);\n        Puzzle EmptyPz = (Puzzle)EmptyBt.Tag;\n\n        bool Result = false;\n        if ((EmptyPz.InvY + 1) % 2 == 0) \n        {\n            \n            if (InvCount % 2 != 0) Result = true;\n        }\n        else \n        {\n            \n            if (InvCount % 2 == 0) Result = true;\n        }\n        return Result;\n    }\n}\n"}
{"id": 66864, "name": "15 puzzle game", "source": "Translate Fortran to Java: LOCZ = MINLOC(BOARD)\t\n", "target": "package fifteenpuzzle;\n\nimport java.awt.*;\nimport java.awt.event.*;\nimport java.util.Random;\nimport javax.swing.*;\n\nclass FifteenPuzzle extends JPanel {\n\n    private final int side = 4;\n    private final int numTiles = side * side - 1;\n\n    private final Random rand = new Random();\n    private final int[] tiles = new int[numTiles + 1];\n    private final int tileSize;\n    private int blankPos;\n    private final int margin;\n    private final int gridSize;\n    private boolean gameOver;\n\n    private FifteenPuzzle() {\n        final int dim = 640;\n\n        margin = 80;\n        tileSize = (dim - 2 * margin) / side;\n        gridSize = tileSize * side;\n\n        setPreferredSize(new Dimension(dim, dim + margin));\n        setBackground(Color.WHITE);\n        setForeground(new Color(0x6495ED)); \n        setFont(new Font(\"SansSerif\", Font.BOLD, 60));\n\n        gameOver = true;\n\n        addMouseListener(new MouseAdapter() {\n            @Override\n            public void mousePressed(MouseEvent e) {\n                if (gameOver) {\n                    newGame();\n\n                } else {\n\n                    int ex = e.getX() - margin;\n                    int ey = e.getY() - margin;\n\n                    if (ex < 0 || ex > gridSize || ey < 0 || ey > gridSize) {\n                        return;\n                    }\n\n                    int c1 = ex / tileSize;\n                    int r1 = ey / tileSize;\n                    int c2 = blankPos % side;\n                    int r2 = blankPos / side;\n\n                    int clickPos = r1 * side + c1;\n\n                    int dir = 0;\n                    if (c1 == c2 && Math.abs(r1 - r2) > 0) {\n                        dir = (r1 - r2) > 0 ? 4 : -4;\n                        \n                    } else if (r1 == r2 && Math.abs(c1 - c2) > 0) {\n                        dir = (c1 - c2) > 0 ? 1 : -1;\n                    }\n\n                    if (dir != 0) {\n                        do {\n                            int newBlankPos = blankPos + dir;\n                            tiles[blankPos] = tiles[newBlankPos];\n                            blankPos = newBlankPos;\n                        } while (blankPos != clickPos);\n                        tiles[blankPos] = 0;\n                    }\n                    \n                    gameOver = isSolved();\n                }\n                repaint();\n            }\n        });\n\n        newGame();\n    }\n\n    private void newGame() {\n        do {\n            reset();\n            shuffle();\n        } while (!isSolvable());\n        gameOver = false;\n    }\n\n    private void reset() {\n        for (int i = 0; i < tiles.length; i++) {\n            tiles[i] = (i + 1) % tiles.length;\n        }\n        blankPos = tiles.length - 1;\n    }\n\n    private void shuffle() {\n        \n        \n        int n = numTiles;\n        while (n > 1) {\n            int r = rand.nextInt(n--);\n            int tmp = tiles[r];\n            tiles[r] = tiles[n];\n            tiles[n] = tmp;\n        }\n    }\n\n    \n    private boolean isSolvable() {\n        int countInversions = 0;\n        for (int i = 0; i < numTiles; i++) {\n            for (int j = 0; j < i; j++) {\n                if (tiles[j] > tiles[i]) {\n                    countInversions++;\n                }\n            }\n        }\n        return countInversions % 2 == 0;\n    }\n\n    private boolean isSolved() {\n        if (tiles[tiles.length - 1] != 0) {\n            return false;\n        }\n        for (int i = numTiles - 1; i >= 0; i--) {\n            if (tiles[i] != i + 1) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    private void drawGrid(Graphics2D g) {\n        for (int i = 0; i < tiles.length; i++) {\n            int r = i / side;\n            int c = i % side;\n            int x = margin + c * tileSize;\n            int y = margin + r * tileSize;\n\n            if (tiles[i] == 0) {\n                if (gameOver) {\n                    g.setColor(Color.GREEN);\n                    drawCenteredString(g, \"\\u2713\", x, y);\n                }\n                continue;\n            }\n\n            g.setColor(getForeground());\n            g.fillRoundRect(x, y, tileSize, tileSize, 25, 25);\n            g.setColor(Color.blue.darker());\n            g.drawRoundRect(x, y, tileSize, tileSize, 25, 25);\n            g.setColor(Color.WHITE);\n\n            drawCenteredString(g, String.valueOf(tiles[i]), x, y);\n        }\n    }\n\n    private void drawStartMessage(Graphics2D g) {\n        if (gameOver) {\n            g.setFont(getFont().deriveFont(Font.BOLD, 18));\n            g.setColor(getForeground());\n            String s = \"click to start a new game\";\n            int x = (getWidth() - g.getFontMetrics().stringWidth(s)) / 2;\n            int y = getHeight() - margin;\n            g.drawString(s, x, y);\n        }\n    }\n\n    private void drawCenteredString(Graphics2D g, String s, int x, int y) {\n        FontMetrics fm = g.getFontMetrics();\n        int asc = fm.getAscent();\n        int des = fm.getDescent();\n\n        x = x + (tileSize - fm.stringWidth(s)) / 2;\n        y = y + (asc + (tileSize - (asc + des)) / 2);\n\n        g.drawString(s, x, y);\n    }\n\n    @Override\n    public void paintComponent(Graphics gg) {\n        super.paintComponent(gg);\n        Graphics2D g = (Graphics2D) gg;\n        g.setRenderingHint(RenderingHints.KEY_ANTIALIASING,\n                RenderingHints.VALUE_ANTIALIAS_ON);\n\n        drawGrid(g);\n        drawStartMessage(g);\n    }\n\n    public static void main(String[] args) {\n        SwingUtilities.invokeLater(() -> {\n            JFrame f = new JFrame();\n            f.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n            f.setTitle(\"Fifteen Puzzle\");\n            f.setResizable(false);\n            f.add(new FifteenPuzzle(), BorderLayout.CENTER);\n            f.pack();\n            f.setLocationRelativeTo(null);\n            f.setVisible(true);\n        });\n    }\n}\n"}
{"id": 66865, "name": "15 puzzle game", "source": "Translate Fortran to Java: LOCZ = MINLOC(BOARD)\t\n", "target": "package fifteenpuzzle;\n\nimport java.awt.*;\nimport java.awt.event.*;\nimport java.util.Random;\nimport javax.swing.*;\n\nclass FifteenPuzzle extends JPanel {\n\n    private final int side = 4;\n    private final int numTiles = side * side - 1;\n\n    private final Random rand = new Random();\n    private final int[] tiles = new int[numTiles + 1];\n    private final int tileSize;\n    private int blankPos;\n    private final int margin;\n    private final int gridSize;\n    private boolean gameOver;\n\n    private FifteenPuzzle() {\n        final int dim = 640;\n\n        margin = 80;\n        tileSize = (dim - 2 * margin) / side;\n        gridSize = tileSize * side;\n\n        setPreferredSize(new Dimension(dim, dim + margin));\n        setBackground(Color.WHITE);\n        setForeground(new Color(0x6495ED)); \n        setFont(new Font(\"SansSerif\", Font.BOLD, 60));\n\n        gameOver = true;\n\n        addMouseListener(new MouseAdapter() {\n            @Override\n            public void mousePressed(MouseEvent e) {\n                if (gameOver) {\n                    newGame();\n\n                } else {\n\n                    int ex = e.getX() - margin;\n                    int ey = e.getY() - margin;\n\n                    if (ex < 0 || ex > gridSize || ey < 0 || ey > gridSize) {\n                        return;\n                    }\n\n                    int c1 = ex / tileSize;\n                    int r1 = ey / tileSize;\n                    int c2 = blankPos % side;\n                    int r2 = blankPos / side;\n\n                    int clickPos = r1 * side + c1;\n\n                    int dir = 0;\n                    if (c1 == c2 && Math.abs(r1 - r2) > 0) {\n                        dir = (r1 - r2) > 0 ? 4 : -4;\n                        \n                    } else if (r1 == r2 && Math.abs(c1 - c2) > 0) {\n                        dir = (c1 - c2) > 0 ? 1 : -1;\n                    }\n\n                    if (dir != 0) {\n                        do {\n                            int newBlankPos = blankPos + dir;\n                            tiles[blankPos] = tiles[newBlankPos];\n                            blankPos = newBlankPos;\n                        } while (blankPos != clickPos);\n                        tiles[blankPos] = 0;\n                    }\n                    \n                    gameOver = isSolved();\n                }\n                repaint();\n            }\n        });\n\n        newGame();\n    }\n\n    private void newGame() {\n        do {\n            reset();\n            shuffle();\n        } while (!isSolvable());\n        gameOver = false;\n    }\n\n    private void reset() {\n        for (int i = 0; i < tiles.length; i++) {\n            tiles[i] = (i + 1) % tiles.length;\n        }\n        blankPos = tiles.length - 1;\n    }\n\n    private void shuffle() {\n        \n        \n        int n = numTiles;\n        while (n > 1) {\n            int r = rand.nextInt(n--);\n            int tmp = tiles[r];\n            tiles[r] = tiles[n];\n            tiles[n] = tmp;\n        }\n    }\n\n    \n    private boolean isSolvable() {\n        int countInversions = 0;\n        for (int i = 0; i < numTiles; i++) {\n            for (int j = 0; j < i; j++) {\n                if (tiles[j] > tiles[i]) {\n                    countInversions++;\n                }\n            }\n        }\n        return countInversions % 2 == 0;\n    }\n\n    private boolean isSolved() {\n        if (tiles[tiles.length - 1] != 0) {\n            return false;\n        }\n        for (int i = numTiles - 1; i >= 0; i--) {\n            if (tiles[i] != i + 1) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    private void drawGrid(Graphics2D g) {\n        for (int i = 0; i < tiles.length; i++) {\n            int r = i / side;\n            int c = i % side;\n            int x = margin + c * tileSize;\n            int y = margin + r * tileSize;\n\n            if (tiles[i] == 0) {\n                if (gameOver) {\n                    g.setColor(Color.GREEN);\n                    drawCenteredString(g, \"\\u2713\", x, y);\n                }\n                continue;\n            }\n\n            g.setColor(getForeground());\n            g.fillRoundRect(x, y, tileSize, tileSize, 25, 25);\n            g.setColor(Color.blue.darker());\n            g.drawRoundRect(x, y, tileSize, tileSize, 25, 25);\n            g.setColor(Color.WHITE);\n\n            drawCenteredString(g, String.valueOf(tiles[i]), x, y);\n        }\n    }\n\n    private void drawStartMessage(Graphics2D g) {\n        if (gameOver) {\n            g.setFont(getFont().deriveFont(Font.BOLD, 18));\n            g.setColor(getForeground());\n            String s = \"click to start a new game\";\n            int x = (getWidth() - g.getFontMetrics().stringWidth(s)) / 2;\n            int y = getHeight() - margin;\n            g.drawString(s, x, y);\n        }\n    }\n\n    private void drawCenteredString(Graphics2D g, String s, int x, int y) {\n        FontMetrics fm = g.getFontMetrics();\n        int asc = fm.getAscent();\n        int des = fm.getDescent();\n\n        x = x + (tileSize - fm.stringWidth(s)) / 2;\n        y = y + (asc + (tileSize - (asc + des)) / 2);\n\n        g.drawString(s, x, y);\n    }\n\n    @Override\n    public void paintComponent(Graphics gg) {\n        super.paintComponent(gg);\n        Graphics2D g = (Graphics2D) gg;\n        g.setRenderingHint(RenderingHints.KEY_ANTIALIASING,\n                RenderingHints.VALUE_ANTIALIAS_ON);\n\n        drawGrid(g);\n        drawStartMessage(g);\n    }\n\n    public static void main(String[] args) {\n        SwingUtilities.invokeLater(() -> {\n            JFrame f = new JFrame();\n            f.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n            f.setTitle(\"Fifteen Puzzle\");\n            f.setResizable(false);\n            f.add(new FifteenPuzzle(), BorderLayout.CENTER);\n            f.pack();\n            f.setLocationRelativeTo(null);\n            f.setVisible(true);\n        });\n    }\n}\n"}
{"id": 66866, "name": "15 puzzle game", "source": "Translate Fortran to Python: LOCZ = MINLOC(BOARD)\t\n", "target": "type Puzzle(var items: {}, var position: -1)\n\nfun mainframe(puz):\n    let d = puz.items\n    print('+-----+-----+-----+-----+')\n    print(d[1], d[2], d[3], d[4], first: '|', sep: '|', last: '|')\n    print('+-----+-----+-----+-----+')\n    print(d[5], d[6], d[7], d[8], first: '|', sep: '|', last: '|')\n    print('+-----+-----+-----+-----+')\n    print(d[9], d[10], d[11], d[12], first: '|', sep: '|', last: '|')\n    print('+-----+-----+-----+-----+')\n    print(d[13], d[14], d[15], d[16], first: '|', sep: '|', last: '|')\n    print('+-----+-----+-----+-----+')\n\nfun format(puz, ch):\n    match ch.trim().length:\n        1 => '  $ch  '\n        2 => '  $ch '\n        0 => '     '\n\nfun change(puz, to):\n    let fro = puz.position\n    for a, b in puz.items where b == puz.format(str i):\n        to = a\n        break\n\n    swap(puz.items[fro], :[to])\n    puz.position = to;\n\nfun buildboard(puz, difficulty):\n    for i in 1..16:\n        puz.items[i] = puz.format(str i)\n\n    var tmp = a\n    for a, b in puz.items where b == '  16 ':\n        puz.items[a] = '     '\n            tmp = a\n            break\n\n    puz.position = tmp\n    let diff = match difficulty:\n        0 => 10\n        1 => 50\n        _ => 100\n\n    for i in 1..diff:\n        let lst = puz.validmoves()\n        let lst1 = []\n        for j in lst:\n            lst1.push! j.trim().int()\n        puz.change(lst1[random(1, lst1.length - 1)])\n\nfun validmoves(puz):\n    match puz.position:\n        6 | 7 | 10 | 11 =>\n            puz.items[pos - 4], :[pos - 1], :[pos + 1], :[pos + 4]\n        5 | 9 =>\n            puz.items[pos - 4], :[pos + 4], :[pos + 1]\n        8 | 12 =>\n            puz.items[pos - 4], :[pos + 4], :[pos - 1]\n        2 | 3 =>\n            puz.items[pos - 1], :[pos + 1], :[pos + 4]\n        14 | 15 =>\n            puz.items[pos - 1], :[pos + 1], :[pos - 4]\n        1 =>\n            puz.items[pos + 1], :[pos + 4]\n        4 =>\n            puz.items[pos - 1], :[pos + 4]\n        13 =>\n            puz.items[pos + 1], :[pos - 4]\n        16 =>\n            puz.items[pos - 1], :[pos - 4]\n\nfun mainframe(puz):\n    var flag = false\n    for a, b in puz.items:\n        if b == '     ':\n            pass\n        else:\n            flag = (a == b.trim().int())\n    ..\n    return flag\n\nlet game = Puzzle()\ngame.buildboard(\n    int(input('Enter the difficulty\u00a0: 0 1 2\\n2 => highest 0=> lowest\\n'))\n)\ngame.mainframe()\n\nprint 'Enter 0 to exit'\n\nloop:\n    print 'Hello user:\\nTo change the position just enter the no. near it'\n\n    var lst = game.validmoves()\n    var lst1 = []\n    for i in lst:\n        lst1.push! i.trim().int()\n        print(i.strip(), '\\t', last: '')\n\n    print()\n\n    let value = int(input())\n    if value == 0:\n        break\n    elif x not in lst1:\n        print('Wrong move')\n    else:\n        game.change(x)\n\n    game.mainframe()\n    if g.gameover():\n        print 'You WON'\n        break\n"}
{"id": 66867, "name": "15 puzzle game", "source": "Translate Fortran to Python: LOCZ = MINLOC(BOARD)\t\n", "target": "type Puzzle(var items: {}, var position: -1)\n\nfun mainframe(puz):\n    let d = puz.items\n    print('+-----+-----+-----+-----+')\n    print(d[1], d[2], d[3], d[4], first: '|', sep: '|', last: '|')\n    print('+-----+-----+-----+-----+')\n    print(d[5], d[6], d[7], d[8], first: '|', sep: '|', last: '|')\n    print('+-----+-----+-----+-----+')\n    print(d[9], d[10], d[11], d[12], first: '|', sep: '|', last: '|')\n    print('+-----+-----+-----+-----+')\n    print(d[13], d[14], d[15], d[16], first: '|', sep: '|', last: '|')\n    print('+-----+-----+-----+-----+')\n\nfun format(puz, ch):\n    match ch.trim().length:\n        1 => '  $ch  '\n        2 => '  $ch '\n        0 => '     '\n\nfun change(puz, to):\n    let fro = puz.position\n    for a, b in puz.items where b == puz.format(str i):\n        to = a\n        break\n\n    swap(puz.items[fro], :[to])\n    puz.position = to;\n\nfun buildboard(puz, difficulty):\n    for i in 1..16:\n        puz.items[i] = puz.format(str i)\n\n    var tmp = a\n    for a, b in puz.items where b == '  16 ':\n        puz.items[a] = '     '\n            tmp = a\n            break\n\n    puz.position = tmp\n    let diff = match difficulty:\n        0 => 10\n        1 => 50\n        _ => 100\n\n    for i in 1..diff:\n        let lst = puz.validmoves()\n        let lst1 = []\n        for j in lst:\n            lst1.push! j.trim().int()\n        puz.change(lst1[random(1, lst1.length - 1)])\n\nfun validmoves(puz):\n    match puz.position:\n        6 | 7 | 10 | 11 =>\n            puz.items[pos - 4], :[pos - 1], :[pos + 1], :[pos + 4]\n        5 | 9 =>\n            puz.items[pos - 4], :[pos + 4], :[pos + 1]\n        8 | 12 =>\n            puz.items[pos - 4], :[pos + 4], :[pos - 1]\n        2 | 3 =>\n            puz.items[pos - 1], :[pos + 1], :[pos + 4]\n        14 | 15 =>\n            puz.items[pos - 1], :[pos + 1], :[pos - 4]\n        1 =>\n            puz.items[pos + 1], :[pos + 4]\n        4 =>\n            puz.items[pos - 1], :[pos + 4]\n        13 =>\n            puz.items[pos + 1], :[pos - 4]\n        16 =>\n            puz.items[pos - 1], :[pos - 4]\n\nfun mainframe(puz):\n    var flag = false\n    for a, b in puz.items:\n        if b == '     ':\n            pass\n        else:\n            flag = (a == b.trim().int())\n    ..\n    return flag\n\nlet game = Puzzle()\ngame.buildboard(\n    int(input('Enter the difficulty\u00a0: 0 1 2\\n2 => highest 0=> lowest\\n'))\n)\ngame.mainframe()\n\nprint 'Enter 0 to exit'\n\nloop:\n    print 'Hello user:\\nTo change the position just enter the no. near it'\n\n    var lst = game.validmoves()\n    var lst1 = []\n    for i in lst:\n        lst1.push! i.trim().int()\n        print(i.strip(), '\\t', last: '')\n\n    print()\n\n    let value = int(input())\n    if value == 0:\n        break\n    elif x not in lst1:\n        print('Wrong move')\n    else:\n        game.change(x)\n\n    game.mainframe()\n    if g.gameover():\n        print 'You WON'\n        break\n"}
{"id": 67202, "name": "Sorting algorithms_Counting sort", "source": "Translate Fortran to C#: module CountingSort\n  implicit none\n\n  interface counting_sort\n     module procedure counting_sort_mm, counting_sort_a\n  end interface\n\ncontains\n\n  subroutine counting_sort_a(array)\n    integer, dimension(:), intent(inout) :: array\n\n    call counting_sort_mm(array, minval(array), maxval(array))\n\n  end subroutine counting_sort_a\n\n  subroutine counting_sort_mm(array, tmin, tmax)\n    integer, dimension(:), intent(inout) :: array\n    integer, intent(in) :: tmin, tmax\n\n    integer, dimension(tmin:tmax) :: cnt\n    integer :: i, z\n\n    cnt = 0                   \n    FORALL (I=1:size(array))  \n        cnt(array(i)) = cnt(array(i))+1\n    END FORALL\n\n\n\n\n    z = 1\n    do i = tmin, tmax\n       do while ( cnt(i) > 0 )\n          array(z) = i\n          z = z + 1\n          cnt(i) = cnt(i) - 1\n       end do\n    end do\n\n  end subroutine counting_sort_mm\n\nend module CountingSort\n", "target": "using System;\nusing System.Linq;\n\nnamespace CountingSort\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            Random rand = new Random();                                   \n            int[] arr = new int[100];                                     \n            for (int i = 0; i < 100; i++) { arr[i] = rand.Next(0, 100); } \n\n            int[] newarr = countingSort(arr, arr.Min(), arr.Max());\n        }\n\n        private static int[] countingSort(int[] arr, int min, int max)\n        {\n            int[] count = new int[max - min + 1];\n            int z = 0;\n\n            for (int i = 0; i < count.Length; i++) { count[i] = 0; }\n            for (int i = 0; i < arr.Length; i++) { count[arr[i] - min]++; }           \n\n            for (int i = min; i <= max; i++)\n            {\n                while (count[i - min]-- > 0)\n                {\n                    arr[z] = i;\n                    z++;                    \n                }\n            }\n            return arr;\n        }\n    }\n}\n"}
{"id": 67206, "name": "Sorting algorithms_Counting sort", "source": "Translate Fortran to Java: module CountingSort\n  implicit none\n\n  interface counting_sort\n     module procedure counting_sort_mm, counting_sort_a\n  end interface\n\ncontains\n\n  subroutine counting_sort_a(array)\n    integer, dimension(:), intent(inout) :: array\n\n    call counting_sort_mm(array, minval(array), maxval(array))\n\n  end subroutine counting_sort_a\n\n  subroutine counting_sort_mm(array, tmin, tmax)\n    integer, dimension(:), intent(inout) :: array\n    integer, intent(in) :: tmin, tmax\n\n    integer, dimension(tmin:tmax) :: cnt\n    integer :: i, z\n\n    cnt = 0                   \n    FORALL (I=1:size(array))  \n        cnt(array(i)) = cnt(array(i))+1\n    END FORALL\n\n\n\n\n    z = 1\n    do i = tmin, tmax\n       do while ( cnt(i) > 0 )\n          array(z) = i\n          z = z + 1\n          cnt(i) = cnt(i) - 1\n       end do\n    end do\n\n  end subroutine counting_sort_mm\n\nend module CountingSort\n", "target": "public static void countingSort(int[] array, int min, int max){\n\tint[] count= new int[max - min + 1];\n\tfor(int number : array){\n\t\tcount[number - min]++;\n\t}\n\tint z= 0;\n\tfor(int i= min;i <= max;i++){\n\t\twhile(count[i - min] > 0){\n\t\t\tarray[z]= i;\n\t\t\tz++;\n\t\t\tcount[i - min]--;\n\t\t}\n\t}\n}\n"}
{"id": 67207, "name": "Sorting algorithms_Counting sort", "source": "Translate Fortran to Python: module CountingSort\n  implicit none\n\n  interface counting_sort\n     module procedure counting_sort_mm, counting_sort_a\n  end interface\n\ncontains\n\n  subroutine counting_sort_a(array)\n    integer, dimension(:), intent(inout) :: array\n\n    call counting_sort_mm(array, minval(array), maxval(array))\n\n  end subroutine counting_sort_a\n\n  subroutine counting_sort_mm(array, tmin, tmax)\n    integer, dimension(:), intent(inout) :: array\n    integer, intent(in) :: tmin, tmax\n\n    integer, dimension(tmin:tmax) :: cnt\n    integer :: i, z\n\n    cnt = 0                   \n    FORALL (I=1:size(array))  \n        cnt(array(i)) = cnt(array(i))+1\n    END FORALL\n\n\n\n\n    z = 1\n    do i = tmin, tmax\n       do while ( cnt(i) > 0 )\n          array(z) = i\n          z = z + 1\n          cnt(i) = cnt(i) - 1\n       end do\n    end do\n\n  end subroutine counting_sort_mm\n\nend module CountingSort\n", "target": ">>> from collections import defaultdict\n>>> def countingSort(array, mn, mx):\n\tcount = defaultdict(int)\n\tfor i in array:\n\t\tcount[i] += 1\n\tresult = []\n\tfor j in range(mn,mx+1):\n\t\tresult += [j]* count[j]\n\treturn result\n\n>>> data = [9, 7, 10, 2, 9, 7, 4, 3, 10, 2, 7, 10, 2, 1, 3, 8, 7, 3, 9, 5, 8, 5, 1, 6, 3, 7, 5, 4, 6, 9, 9, 6, 6, 10, 2, 4, 5, 2, 8, 2, 2, 5, 2, 9, 3, 3, 5, 7, 8, 4]\n>>> mini,maxi = 1,10\n>>> countingSort(data, mini, maxi) == sorted(data)\nTrue\n"}
{"id": 67562, "name": "Array length", "source": "Translate Fortran to C#:       MODULE EXAMPLE\n       CONTAINS\n        SUBROUTINE ABOUND(A)\n         CHARACTER*(*) A(:)\t\n          WRITE (6,*) \"Lower bound\",LBOUND(A),\", Upper bound\",UBOUND(A)\n          WRITE (6,*) \"Element size\",LEN(A(LBOUND(A)))\n          WRITE (6,*) A\n        END SUBROUTINE ABOUND\n      END MODULE EXAMPLE\n\n      PROGRAM SHOWBOUNDS\n       USE EXAMPLE\n       CHARACTER*6 ARRAY(-1:1)\n        ARRAY(-1) = \"Apple\"\n        ARRAY(0) = \"Orange\"\n        ARRAY(1) = \"\"\n        CALL ABOUND(ARRAY)\n        WRITE (6,*) \"But, when it is at home...\"\n        WRITE (6,*) \"L. bound\",LBOUND(ARRAY),\", U. bound\",UBOUND(ARRAY)\n      END\n", "target": "using System;\n\nnamespace ArrayLength\n{\n  class Program\n  {\n    public static void Main()\n    {\n      var array = new String[](\"apple\", \"orange\");\n      Console.WriteLine(array.Count);\n      delete(array);\n    }\n  }\n}\n"}
{"id": 67563, "name": "Array length", "source": "Translate Fortran to C#:       MODULE EXAMPLE\n       CONTAINS\n        SUBROUTINE ABOUND(A)\n         CHARACTER*(*) A(:)\t\n          WRITE (6,*) \"Lower bound\",LBOUND(A),\", Upper bound\",UBOUND(A)\n          WRITE (6,*) \"Element size\",LEN(A(LBOUND(A)))\n          WRITE (6,*) A\n        END SUBROUTINE ABOUND\n      END MODULE EXAMPLE\n\n      PROGRAM SHOWBOUNDS\n       USE EXAMPLE\n       CHARACTER*6 ARRAY(-1:1)\n        ARRAY(-1) = \"Apple\"\n        ARRAY(0) = \"Orange\"\n        ARRAY(1) = \"\"\n        CALL ABOUND(ARRAY)\n        WRITE (6,*) \"But, when it is at home...\"\n        WRITE (6,*) \"L. bound\",LBOUND(ARRAY),\", U. bound\",UBOUND(ARRAY)\n      END\n", "target": "using System;\n\nnamespace ArrayLength\n{\n  class Program\n  {\n    public static void Main()\n    {\n      var array = new String[](\"apple\", \"orange\");\n      Console.WriteLine(array.Count);\n      delete(array);\n    }\n  }\n}\n"}
{"id": 67569, "name": "Array length", "source": "Translate Fortran to Java:       MODULE EXAMPLE\n       CONTAINS\n        SUBROUTINE ABOUND(A)\n         CHARACTER*(*) A(:)\t\n          WRITE (6,*) \"Lower bound\",LBOUND(A),\", Upper bound\",UBOUND(A)\n          WRITE (6,*) \"Element size\",LEN(A(LBOUND(A)))\n          WRITE (6,*) A\n        END SUBROUTINE ABOUND\n      END MODULE EXAMPLE\n\n      PROGRAM SHOWBOUNDS\n       USE EXAMPLE\n       CHARACTER*6 ARRAY(-1:1)\n        ARRAY(-1) = \"Apple\"\n        ARRAY(0) = \"Orange\"\n        ARRAY(1) = \"\"\n        CALL ABOUND(ARRAY)\n        WRITE (6,*) \"But, when it is at home...\"\n        WRITE (6,*) \"L. bound\",LBOUND(ARRAY),\", U. bound\",UBOUND(ARRAY)\n      END\n", "target": "String[] array  = [\"apple\", \"orange\"];\nInt      length = array.size;\n"}
{"id": 67570, "name": "Array length", "source": "Translate Fortran to Java:       MODULE EXAMPLE\n       CONTAINS\n        SUBROUTINE ABOUND(A)\n         CHARACTER*(*) A(:)\t\n          WRITE (6,*) \"Lower bound\",LBOUND(A),\", Upper bound\",UBOUND(A)\n          WRITE (6,*) \"Element size\",LEN(A(LBOUND(A)))\n          WRITE (6,*) A\n        END SUBROUTINE ABOUND\n      END MODULE EXAMPLE\n\n      PROGRAM SHOWBOUNDS\n       USE EXAMPLE\n       CHARACTER*6 ARRAY(-1:1)\n        ARRAY(-1) = \"Apple\"\n        ARRAY(0) = \"Orange\"\n        ARRAY(1) = \"\"\n        CALL ABOUND(ARRAY)\n        WRITE (6,*) \"But, when it is at home...\"\n        WRITE (6,*) \"L. bound\",LBOUND(ARRAY),\", U. bound\",UBOUND(ARRAY)\n      END\n", "target": "String[] array  = [\"apple\", \"orange\"];\nInt      length = array.size;\n"}
{"id": 67571, "name": "Array length", "source": "Translate Fortran to Python:       MODULE EXAMPLE\n       CONTAINS\n        SUBROUTINE ABOUND(A)\n         CHARACTER*(*) A(:)\t\n          WRITE (6,*) \"Lower bound\",LBOUND(A),\", Upper bound\",UBOUND(A)\n          WRITE (6,*) \"Element size\",LEN(A(LBOUND(A)))\n          WRITE (6,*) A\n        END SUBROUTINE ABOUND\n      END MODULE EXAMPLE\n\n      PROGRAM SHOWBOUNDS\n       USE EXAMPLE\n       CHARACTER*6 ARRAY(-1:1)\n        ARRAY(-1) = \"Apple\"\n        ARRAY(0) = \"Orange\"\n        ARRAY(1) = \"\"\n        CALL ABOUND(ARRAY)\n        WRITE (6,*) \"But, when it is at home...\"\n        WRITE (6,*) \"L. bound\",LBOUND(ARRAY),\", U. bound\",UBOUND(ARRAY)\n      END\n", "target": "arr = ['apple', 'orange']  \n\ndef setup():\n    println(len(arr))\n"}
{"id": 67572, "name": "Array length", "source": "Translate Fortran to Python:       MODULE EXAMPLE\n       CONTAINS\n        SUBROUTINE ABOUND(A)\n         CHARACTER*(*) A(:)\t\n          WRITE (6,*) \"Lower bound\",LBOUND(A),\", Upper bound\",UBOUND(A)\n          WRITE (6,*) \"Element size\",LEN(A(LBOUND(A)))\n          WRITE (6,*) A\n        END SUBROUTINE ABOUND\n      END MODULE EXAMPLE\n\n      PROGRAM SHOWBOUNDS\n       USE EXAMPLE\n       CHARACTER*6 ARRAY(-1:1)\n        ARRAY(-1) = \"Apple\"\n        ARRAY(0) = \"Orange\"\n        ARRAY(1) = \"\"\n        CALL ABOUND(ARRAY)\n        WRITE (6,*) \"But, when it is at home...\"\n        WRITE (6,*) \"L. bound\",LBOUND(ARRAY),\", U. bound\",UBOUND(ARRAY)\n      END\n", "target": "arr = ['apple', 'orange']  \n\ndef setup():\n    println(len(arr))\n"}
{"id": 67981, "name": "Bulls and cows", "source": "Translate Fortran to C#: module bac\n  implicit none\n\ncontains\n\n  subroutine Gennum(n)\n    integer, intent(out) :: n(4)\n    integer :: i, j\n    real :: r\n      \n    call random_number(r)\n    n(1) = int(r * 9.0) + 1\n    i = 2\n    \nouter: do while (i <= 4)\n         call random_number(r)\n         n(i) = int(r * 9.0) + 1\ninner:   do j = i-1 , 1, -1\n           if (n(j) == n(i)) cycle outer\n         end do inner\n         i = i + 1\n       end do outer\n \n  end subroutine Gennum\n\n  subroutine Score(n, guess, b, c) \n    character(*), intent(in) :: guess\n    integer, intent(in) :: n(0:3)\n    integer, intent(out) :: b, c\n    integer :: digit, i, j, ind\n   \n    b = 0; c = 0\n    do i = 1, 4\n      read(guess(i:i), \"(i1)\") digit\n      if (digit == n(i-1)) then\n        b = b + 1\n      else\n        do j = i, i+2\n          ind = mod(j, 4)\n          if (digit == n(ind)) then\n            c = c + 1\n            exit\n          end if\n        end do    \n      end if\n    end do  \n\n end subroutine Score  \n\nend module bac\n\nprogram Bulls_and_Cows\n   use bac\n   implicit none\n   \n   integer :: n(4)\n   integer :: bulls=0, cows=0, tries=0\n   character(4) :: guess\n\n   call random_seed\n   call Gennum(n)\n   \n   write(*,*) \"I have selected a number made up of 4 digits (1-9) without repetitions.\"\n   write(*,*) \"You attempt to guess this number.\"\n   write(*,*) \"Every digit in your guess that is in the correct position scores 1 Bull\"\n   write(*,*) \"Every digit in your guess that is in an incorrect position scores 1 Cow\"\n   write(*,*)\n\n   do while (bulls /= 4)\n     write(*,*) \"Enter a 4 digit number\"\n     read*, guess\n     if (verify(guess, \"123456789\") /= 0) then\n       write(*,*) \"That is an invalid entry. Please try again.\"\n       cycle\n     end if\n     tries = tries + 1\n     call Score (n, guess, bulls, cows)\n     write(*, \"(a, i1, a, i1, a)\") \"You scored \", bulls, \" bulls and \", cows, \" cows\"\n     write(*,*)\n   end do\n\n   write(*,\"(a,i0,a)\") \"Congratulations\n\nend program Bulls_and_Cows\n", "target": "using System;\n\nnamespace BullsnCows\n{\n    class Program\n    {\n        \n        static void Main(string[] args)\n        {\n            int[] nums = new int[] { 1, 2, 3, 4, 5, 6, 7, 8, 9 };\n            KnuthShuffle<int>(ref nums);\n            int[] chosenNum = new int[4];\n            Array.Copy(nums, chosenNum, 4);\n\n            Console.WriteLine(\"Your Guess\u00a0?\");\n            while (!game(Console.ReadLine(), chosenNum))\n            {\n                Console.WriteLine(\"Your next Guess\u00a0?\");\n            }\n            \n            Console.ReadKey();\n        }\n\n        public static void KnuthShuffle<T>(ref T[] array)\n        {\n            System.Random random = new System.Random();\n            for (int i = 0; i < array.Length; i++)\n            {\n                int j = random.Next(array.Length);\n                T temp = array[i]; array[i] = array[j]; array[j] = temp;\n            }\n        }\n\n        public static bool game(string guess, int[] num)\n        {\n            char[] guessed = guess.ToCharArray();\n            int bullsCount = 0, cowsCount = 0;\n\n            if (guessed.Length != 4)\n            {\n                Console.WriteLine(\"Not a valid guess.\");\n                return false;\n            }\n\n            for (int i = 0; i < 4; i++)\n            {\n                int curguess = (int) char.GetNumericValue(guessed[i]);\n                if (curguess < 1 || curguess > 9)\n                {\n                    Console.WriteLine(\"Digit must be ge greater 0 and lower 10.\");\n                    return false;\n                }\n                if (curguess == num[i])\n                {\n                    bullsCount++;\n                }\n                else\n                {\n                    for (int j = 0; j < 4; j++)\n                    {\n                        if (curguess == num[j])\n                            cowsCount++;\n                    }\n                }\n            }\n\n            if (bullsCount == 4)\n            {\n                Console.WriteLine(\"Congratulations! You have won!\");\n                return true;\n            }\n            else\n            {\n                Console.WriteLine(\"Your Score is {0} bulls and {1} cows\", bullsCount, cowsCount);\n                return false;\n            }\n        }\n    }\n}\n"}
{"id": 67985, "name": "Bulls and cows", "source": "Translate Fortran to Java: module bac\n  implicit none\n\ncontains\n\n  subroutine Gennum(n)\n    integer, intent(out) :: n(4)\n    integer :: i, j\n    real :: r\n      \n    call random_number(r)\n    n(1) = int(r * 9.0) + 1\n    i = 2\n    \nouter: do while (i <= 4)\n         call random_number(r)\n         n(i) = int(r * 9.0) + 1\ninner:   do j = i-1 , 1, -1\n           if (n(j) == n(i)) cycle outer\n         end do inner\n         i = i + 1\n       end do outer\n \n  end subroutine Gennum\n\n  subroutine Score(n, guess, b, c) \n    character(*), intent(in) :: guess\n    integer, intent(in) :: n(0:3)\n    integer, intent(out) :: b, c\n    integer :: digit, i, j, ind\n   \n    b = 0; c = 0\n    do i = 1, 4\n      read(guess(i:i), \"(i1)\") digit\n      if (digit == n(i-1)) then\n        b = b + 1\n      else\n        do j = i, i+2\n          ind = mod(j, 4)\n          if (digit == n(ind)) then\n            c = c + 1\n            exit\n          end if\n        end do    \n      end if\n    end do  \n\n end subroutine Score  \n\nend module bac\n\nprogram Bulls_and_Cows\n   use bac\n   implicit none\n   \n   integer :: n(4)\n   integer :: bulls=0, cows=0, tries=0\n   character(4) :: guess\n\n   call random_seed\n   call Gennum(n)\n   \n   write(*,*) \"I have selected a number made up of 4 digits (1-9) without repetitions.\"\n   write(*,*) \"You attempt to guess this number.\"\n   write(*,*) \"Every digit in your guess that is in the correct position scores 1 Bull\"\n   write(*,*) \"Every digit in your guess that is in an incorrect position scores 1 Cow\"\n   write(*,*)\n\n   do while (bulls /= 4)\n     write(*,*) \"Enter a 4 digit number\"\n     read*, guess\n     if (verify(guess, \"123456789\") /= 0) then\n       write(*,*) \"That is an invalid entry. Please try again.\"\n       cycle\n     end if\n     tries = tries + 1\n     call Score (n, guess, bulls, cows)\n     write(*, \"(a, i1, a, i1, a)\") \"You scored \", bulls, \" bulls and \", cows, \" cows\"\n     write(*,*)\n   end do\n\n   write(*,\"(a,i0,a)\") \"Congratulations\n\nend program Bulls_and_Cows\n", "target": "import java.util.InputMismatchException;\nimport java.util.Random;\nimport java.util.Scanner;\n\npublic class BullsAndCows{\n\tpublic static void main(String[] args){\n\t\tRandom gen= new Random();\n\t\tint target;\n\t\twhile(hasDupes(target= (gen.nextInt(9000) + 1000)));\n\t\tString targetStr = target +\"\";\n\t\tboolean guessed = false;\n\t\tScanner input = new Scanner(System.in);\n\t\tint guesses = 0;\n\t\tdo{\n\t\t\tint bulls = 0;\n\t\t\tint cows = 0;\n\t\t\tSystem.out.print(\"Guess a 4-digit number with no duplicate digits: \");\n\t\t\tint guess;\n\t\t\ttry{\n\t\t\t\tguess = input.nextInt();\n\t\t\t\tif(hasDupes(guess) || guess < 1000) continue;\n\t\t\t}catch(InputMismatchException e){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tguesses++;\n\t\t\tString guessStr = guess + \"\";\n\t\t\tfor(int i= 0;i < 4;i++){\n\t\t\t\tif(guessStr.charAt(i) == targetStr.charAt(i)){\n\t\t\t\t\tbulls++;\n\t\t\t\t}else if(targetStr.contains(guessStr.charAt(i)+\"\")){\n\t\t\t\t\tcows++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(bulls == 4){\n\t\t\t\tguessed = true;\n\t\t\t}else{\n\t\t\t\tSystem.out.println(cows+\" Cows and \"+bulls+\" Bulls.\");\n\t\t\t}\n\t\t}while(!guessed);\n\t\tSystem.out.println(\"You won after \"+guesses+\" guesses!\");\n\t}\n\n\tpublic static boolean hasDupes(int num){\n\t\tboolean[] digs = new boolean[10];\n\t\twhile(num > 0){\n\t\t\tif(digs[num%10]) return true;\n\t\t\tdigs[num%10] = true;\n\t\t\tnum/= 10;\n\t\t}\n\t\treturn false;\n\t}\n}\n"}
{"id": 67986, "name": "Bulls and cows", "source": "Translate Fortran to Python: module bac\n  implicit none\n\ncontains\n\n  subroutine Gennum(n)\n    integer, intent(out) :: n(4)\n    integer :: i, j\n    real :: r\n      \n    call random_number(r)\n    n(1) = int(r * 9.0) + 1\n    i = 2\n    \nouter: do while (i <= 4)\n         call random_number(r)\n         n(i) = int(r * 9.0) + 1\ninner:   do j = i-1 , 1, -1\n           if (n(j) == n(i)) cycle outer\n         end do inner\n         i = i + 1\n       end do outer\n \n  end subroutine Gennum\n\n  subroutine Score(n, guess, b, c) \n    character(*), intent(in) :: guess\n    integer, intent(in) :: n(0:3)\n    integer, intent(out) :: b, c\n    integer :: digit, i, j, ind\n   \n    b = 0; c = 0\n    do i = 1, 4\n      read(guess(i:i), \"(i1)\") digit\n      if (digit == n(i-1)) then\n        b = b + 1\n      else\n        do j = i, i+2\n          ind = mod(j, 4)\n          if (digit == n(ind)) then\n            c = c + 1\n            exit\n          end if\n        end do    \n      end if\n    end do  \n\n end subroutine Score  \n\nend module bac\n\nprogram Bulls_and_Cows\n   use bac\n   implicit none\n   \n   integer :: n(4)\n   integer :: bulls=0, cows=0, tries=0\n   character(4) :: guess\n\n   call random_seed\n   call Gennum(n)\n   \n   write(*,*) \"I have selected a number made up of 4 digits (1-9) without repetitions.\"\n   write(*,*) \"You attempt to guess this number.\"\n   write(*,*) \"Every digit in your guess that is in the correct position scores 1 Bull\"\n   write(*,*) \"Every digit in your guess that is in an incorrect position scores 1 Cow\"\n   write(*,*)\n\n   do while (bulls /= 4)\n     write(*,*) \"Enter a 4 digit number\"\n     read*, guess\n     if (verify(guess, \"123456789\") /= 0) then\n       write(*,*) \"That is an invalid entry. Please try again.\"\n       cycle\n     end if\n     tries = tries + 1\n     call Score (n, guess, bulls, cows)\n     write(*, \"(a, i1, a, i1, a)\") \"You scored \", bulls, \" bulls and \", cows, \" cows\"\n     write(*,*)\n   end do\n\n   write(*,\"(a,i0,a)\") \"Congratulations\n\nend program Bulls_and_Cows\n", "target": "\n\nimport random\n\ndigits = '123456789'\nsize = 4\nchosen = ''.join(random.sample(digits,size))\n\nprint  % (size, size)\nguesses = 0\nwhile True:\n    guesses += 1\n    while True:\n        \n        guess = raw_input('\\nNext guess [%i]: ' % guesses).strip()\n        if len(guess) == size and \\\n           all(char in digits for char in guess) \\\n           and len(set(guess)) == size:\n            break\n        print \"Problem, try again. You need to enter %i unique digits from 1 to 9\" % size\n    if guess == chosen:\n        print '\\nCongratulations you guessed correctly in',guesses,'attempts'\n        break\n    bulls = cows = 0\n    for i in range(size):\n        if guess[i] == chosen[i]:\n            bulls += 1\n        elif guess[i] in chosen:\n            cows += 1\n    print '  %i Bulls\\n  %i Cows' % (bulls, cows)\n"}
{"id": 68460, "name": "Accumulator factory", "source": "Translate Fortran to C#: #define foo(type,g,nn) \\\ntypex function g(i);\\\ntypex i,s,n;\\\ndata s,n/0,nn/;\\\ns=s+i;\\\ng=s+n;\\\nend\n\n      foo(real,x,1)\n      foo(integer,y,3)\n\n      program acc\n      real x, temp\n      integer y, itemp\n      temp = x(5.0)\n      print *, x(2.3)\n      itemp = y(5)\n      print *, y(2)\n      stop\n      end\n", "target": "using System;\n\nclass Program\n{\n    static Func<dynamic, dynamic> Foo(dynamic n)\n    {\n        return i => n += i;\n    }\n\n    static void Main(string[] args)\n    {\n        var x = Foo(1);\n        x(5);\n        Foo(3);\n        Console.WriteLine(x(2.3));\n    }\n}\n"}
{"id": 68461, "name": "Accumulator factory", "source": "Translate Fortran to C#: #define foo(type,g,nn) \\\ntypex function g(i);\\\ntypex i,s,n;\\\ndata s,n/0,nn/;\\\ns=s+i;\\\ng=s+n;\\\nend\n\n      foo(real,x,1)\n      foo(integer,y,3)\n\n      program acc\n      real x, temp\n      integer y, itemp\n      temp = x(5.0)\n      print *, x(2.3)\n      itemp = y(5)\n      print *, y(2)\n      stop\n      end\n", "target": "using System;\n\nclass Program\n{\n    static Func<dynamic, dynamic> Foo(dynamic n)\n    {\n        return i => n += i;\n    }\n\n    static void Main(string[] args)\n    {\n        var x = Foo(1);\n        x(5);\n        Foo(3);\n        Console.WriteLine(x(2.3));\n    }\n}\n"}
{"id": 68466, "name": "Accumulator factory", "source": "Translate Fortran to Java: #define foo(type,g,nn) \\\ntypex function g(i);\\\ntypex i,s,n;\\\ndata s,n/0,nn/;\\\ns=s+i;\\\ng=s+n;\\\nend\n\n      foo(real,x,1)\n      foo(integer,y,3)\n\n      program acc\n      real x, temp\n      integer y, itemp\n      temp = x(5.0)\n      print *, x(2.3)\n      itemp = y(5)\n      print *, y(2)\n      stop\n      end\n", "target": "public class Accumulator\n    \n{\n    private Number sum;\n\n    public Accumulator(Number sum0) {\n\tsum = sum0;\n    }\n\n    public Number apply(Number n) {\n\t\n\t\n\treturn (longable(sum) && longable(n)) ?\n\t    (sum = sum.longValue() + n.longValue()) :\n\t    (sum = sum.doubleValue() + n.doubleValue());\n    }\n\n    private static boolean longable(Number n) {\n\treturn n instanceof Byte || n instanceof Short ||\n\t    n instanceof Integer || n instanceof Long;\n    }\n\n    public static void main(String[] args) {\n\tAccumulator x = new Accumulator(1);\n\tx.apply(5);\n\tnew Accumulator(3);\n\tSystem.out.println(x.apply(2.3));\n    }\n}\n"}
{"id": 68467, "name": "Accumulator factory", "source": "Translate Fortran to Java: #define foo(type,g,nn) \\\ntypex function g(i);\\\ntypex i,s,n;\\\ndata s,n/0,nn/;\\\ns=s+i;\\\ng=s+n;\\\nend\n\n      foo(real,x,1)\n      foo(integer,y,3)\n\n      program acc\n      real x, temp\n      integer y, itemp\n      temp = x(5.0)\n      print *, x(2.3)\n      itemp = y(5)\n      print *, y(2)\n      stop\n      end\n", "target": "public class Accumulator\n    \n{\n    private Number sum;\n\n    public Accumulator(Number sum0) {\n\tsum = sum0;\n    }\n\n    public Number apply(Number n) {\n\t\n\t\n\treturn (longable(sum) && longable(n)) ?\n\t    (sum = sum.longValue() + n.longValue()) :\n\t    (sum = sum.doubleValue() + n.doubleValue());\n    }\n\n    private static boolean longable(Number n) {\n\treturn n instanceof Byte || n instanceof Short ||\n\t    n instanceof Integer || n instanceof Long;\n    }\n\n    public static void main(String[] args) {\n\tAccumulator x = new Accumulator(1);\n\tx.apply(5);\n\tnew Accumulator(3);\n\tSystem.out.println(x.apply(2.3));\n    }\n}\n"}
{"id": 68468, "name": "Accumulator factory", "source": "Translate Fortran to Python: #define foo(type,g,nn) \\\ntypex function g(i);\\\ntypex i,s,n;\\\ndata s,n/0,nn/;\\\ns=s+i;\\\ng=s+n;\\\nend\n\n      foo(real,x,1)\n      foo(integer,y,3)\n\n      program acc\n      real x, temp\n      integer y, itemp\n      temp = x(5.0)\n      print *, x(2.3)\n      itemp = y(5)\n      print *, y(2)\n      stop\n      end\n", "target": "fun accumulator(var sum): :: Real -> _\n    n => sum += n\n\nlet f = accumulator!(5)\nprint f(5)   \nprint f(10)  \nprint f(2.4) \n"}
{"id": 68469, "name": "Accumulator factory", "source": "Translate Fortran to Python: #define foo(type,g,nn) \\\ntypex function g(i);\\\ntypex i,s,n;\\\ndata s,n/0,nn/;\\\ns=s+i;\\\ng=s+n;\\\nend\n\n      foo(real,x,1)\n      foo(integer,y,3)\n\n      program acc\n      real x, temp\n      integer y, itemp\n      temp = x(5.0)\n      print *, x(2.3)\n      itemp = y(5)\n      print *, y(2)\n      stop\n      end\n", "target": "fun accumulator(var sum): :: Real -> _\n    n => sum += n\n\nlet f = accumulator!(5)\nprint f(5)   \nprint f(10)  \nprint f(2.4) \n"}
{"id": 69142, "name": "Averages_Root mean square", "source": "Translate Fortran to C#: print *,sqrt( sum(x**2)/size(x) )\n", "target": "using System;\n\nnamespace rms\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            int[] x = new int[] { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };\n            Console.WriteLine(rootMeanSquare(x));\n        }\n\n        private static double rootMeanSquare(int[] x)\n        {            \n            double sum = 0;\n            for (int i = 0; i < x.Length; i++)\n            {\n                sum += (x[i]*x[i]);\n            }\n            return Math.Sqrt(sum / x.Length);\n        }\n    }\n}\n"}
{"id": 69143, "name": "Averages_Root mean square", "source": "Translate Fortran to C#: print *,sqrt( sum(x**2)/size(x) )\n", "target": "using System;\n\nnamespace rms\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            int[] x = new int[] { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };\n            Console.WriteLine(rootMeanSquare(x));\n        }\n\n        private static double rootMeanSquare(int[] x)\n        {            \n            double sum = 0;\n            for (int i = 0; i < x.Length; i++)\n            {\n                sum += (x[i]*x[i]);\n            }\n            return Math.Sqrt(sum / x.Length);\n        }\n    }\n}\n"}
{"id": 69149, "name": "Averages_Root mean square", "source": "Translate Fortran to Java: print *,sqrt( sum(x**2)/size(x) )\n", "target": "public class RootMeanSquare {\n\n    public static double rootMeanSquare(double... nums) {\n        double sum = 0.0;\n        for (double num : nums)\n            sum += num * num;\n        return Math.sqrt(sum / nums.length);\n    }\n\n    public static void main(String[] args) {\n        double[] nums = {1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0};\n        System.out.println(\"The RMS of the numbers from 1 to 10 is \" + rootMeanSquare(nums));\n    }\n}\n"}
{"id": 69150, "name": "Averages_Root mean square", "source": "Translate Fortran to Java: print *,sqrt( sum(x**2)/size(x) )\n", "target": "public class RootMeanSquare {\n\n    public static double rootMeanSquare(double... nums) {\n        double sum = 0.0;\n        for (double num : nums)\n            sum += num * num;\n        return Math.sqrt(sum / nums.length);\n    }\n\n    public static void main(String[] args) {\n        double[] nums = {1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0};\n        System.out.println(\"The RMS of the numbers from 1 to 10 is \" + rootMeanSquare(nums));\n    }\n}\n"}
{"id": 69649, "name": "Pi", "source": "Translate Fortran to C#: program pi\n  implicit none\n  integer,dimension(3350) :: vect\n  integer,dimension(201) :: buffer\n  integer :: more,karray,num,k,l,n\n  more = 0\n  vect = 2\n  do n = 1,201\n    karray = 0\n    do l = 3350,1,-1\n      num = 100000*vect(l) + karray*l\n      karray = num/(2*l - 1)\n      vect(l) = num - karray*(2*l - 1)\n    end do\n    k = karray/100000\n    buffer(n) = more + k\n    more = karray - k*100000\n  end do\n  write (*,'(i2,\".\"/(1x,10i5.5))') buffer\nend program pi\n", "target": "using System;\nusing System.Numerics;\n\nnamespace PiCalc {\n    internal class Program {\n        private readonly BigInteger FOUR = new BigInteger(4);\n        private readonly BigInteger SEVEN = new BigInteger(7);\n        private readonly BigInteger TEN = new BigInteger(10);\n        private readonly BigInteger THREE = new BigInteger(3);\n        private readonly BigInteger TWO = new BigInteger(2);\n\n        private BigInteger k = BigInteger.One;\n        private BigInteger l = new BigInteger(3);\n        private BigInteger n = new BigInteger(3);\n        private BigInteger q = BigInteger.One;\n        private BigInteger r = BigInteger.Zero;\n        private BigInteger t = BigInteger.One;\n\n        public void CalcPiDigits() {\n            BigInteger nn, nr;\n            bool first = true;\n            while (true) {\n                if ((FOUR*q + r - t).CompareTo(n*t) == -1) {\n                    Console.Write(n);\n                    if (first) {\n                        Console.Write(\".\");\n                        first = false;\n                    }\n                    nr = TEN*(r - (n*t));\n                    n = TEN*(THREE*q + r)/t - (TEN*n);\n                    q *= TEN;\n                    r = nr;\n                } else {\n                    nr = (TWO*q + r)*l;\n                    nn = (q*(SEVEN*k) + TWO + r*l)/(t*l);\n                    q *= k;\n                    t *= l;\n                    l += TWO;\n                    k += BigInteger.One;\n                    n = nn;\n                    r = nr;\n                }\n            }\n        }\n\n        private static void Main(string[] args) {\n            new Program().CalcPiDigits();\n        }\n    }\n}\n"}
{"id": 69652, "name": "Pi", "source": "Translate Fortran to Java: program pi\n  implicit none\n  integer,dimension(3350) :: vect\n  integer,dimension(201) :: buffer\n  integer :: more,karray,num,k,l,n\n  more = 0\n  vect = 2\n  do n = 1,201\n    karray = 0\n    do l = 3350,1,-1\n      num = 100000*vect(l) + karray*l\n      karray = num/(2*l - 1)\n      vect(l) = num - karray*(2*l - 1)\n    end do\n    k = karray/100000\n    buffer(n) = more + k\n    more = karray - k*100000\n  end do\n  write (*,'(i2,\".\"/(1x,10i5.5))') buffer\nend program pi\n", "target": "import java.math.BigInteger ;\n\npublic class Pi {\n  final BigInteger TWO = BigInteger.valueOf(2) ;\n  final BigInteger THREE = BigInteger.valueOf(3) ;\n  final BigInteger FOUR = BigInteger.valueOf(4) ;\n  final BigInteger SEVEN = BigInteger.valueOf(7) ;\n\n  BigInteger q = BigInteger.ONE ;\n  BigInteger r = BigInteger.ZERO ;\n  BigInteger t = BigInteger.ONE ;\n  BigInteger k = BigInteger.ONE ;\n  BigInteger n = BigInteger.valueOf(3) ;\n  BigInteger l = BigInteger.valueOf(3) ;\n\n  public void calcPiDigits(){\n    BigInteger nn, nr ;\n    boolean first = true ;\n    while(true){\n        if(FOUR.multiply(q).add(r).subtract(t).compareTo(n.multiply(t)) == -1){\n          System.out.print(n) ;\n          if(first){System.out.print(\".\") ; first = false ;}\n          nr = BigInteger.TEN.multiply(r.subtract(n.multiply(t))) ;\n          n = BigInteger.TEN.multiply(THREE.multiply(q).add(r)).divide(t).subtract(BigInteger.TEN.multiply(n)) ;\n          q = q.multiply(BigInteger.TEN) ;\n          r = nr ;\n          System.out.flush() ;\n        }else{\n          nr = TWO.multiply(q).add(r).multiply(l) ;\n          nn = q.multiply((SEVEN.multiply(k))).add(TWO).add(r.multiply(l)).divide(t.multiply(l)) ;\n          q = q.multiply(k) ;\n          t = t.multiply(l) ;\n          l = l.add(TWO) ;\n          k = k.add(BigInteger.ONE) ;\n          n = nn ;\n          r = nr ;\n        }\n    }\n  }\n\n  public static void main(String[] args) {\n    Pi p = new Pi() ;\n    p.calcPiDigits() ;\n  }\n}\n"}
{"id": 69653, "name": "Pi", "source": "Translate Fortran to Python: program pi\n  implicit none\n  integer,dimension(3350) :: vect\n  integer,dimension(201) :: buffer\n  integer :: more,karray,num,k,l,n\n  more = 0\n  vect = 2\n  do n = 1,201\n    karray = 0\n    do l = 3350,1,-1\n      num = 100000*vect(l) + karray*l\n      karray = num/(2*l - 1)\n      vect(l) = num - karray*(2*l - 1)\n    end do\n    k = karray/100000\n    buffer(n) = more + k\n    more = karray - k*100000\n  end do\n  write (*,'(i2,\".\"/(1x,10i5.5))') buffer\nend program pi\n", "target": "def calcPi():\n    q, r, t, k, n, l = 1, 0, 1, 1, 3, 3\n    while True:\n        if 4*q+r-t < n*t:\n            yield n\n            nr = 10*(r-n*t)\n            n  = ((10*(3*q+r))//t)-10*n\n            q  *= 10\n            r  = nr\n        else:\n            nr = (2*q+r)*l\n            nn = (q*(7*k)+2+(r*l))//(t*l)\n            q  *= k\n            t  *= l\n            l  += 2\n            k += 1\n            n  = nn\n            r  = nr\n\nimport sys\npi_digits = calcPi()\ni = 0\nfor d in pi_digits:\n    sys.stdout.write(str(d))\n    i += 1\n    if i == 40: print(\"\"); i = 0\n"}
{"id": 69980, "name": "Terminal control_Coloured text", "source": "Translate Fortran to C#: \n\nprogram coloured_terminal_text\n  use, intrinsic :: iso_fortran_env, only: ERROR_UNIT\n  implicit none\n\n  \n  character(*), parameter :: esc = achar(27) \n  character(*), parameter :: reset = esc // '[0m' \n  \n  character(*), parameter :: red     = esc // '[31m'\n  character(*), parameter :: green   = esc // '[32m'\n  character(*), parameter :: yellow  = esc // '[33m'\n  character(*), parameter :: blue    = esc // '[34m'\n  character(*), parameter :: magenta = esc // '[35m'\n  character(*), parameter :: cyan    = esc // '[36m'\n  character(*), parameter :: grey    = esc // '[90m' \n  \n  character(*), parameter :: background_green = esc // '[42m'\n  \n  character(*), parameter :: bold = esc // '[1m'\n  character(*), parameter :: bold_blink = esc // '[1;5m'\n\n  \n  write(ERROR_UNIT, '(a)') bold // 'Coloured words:' // reset\n  write(ERROR_UNIT, '(4x, a)')       & \n      red     // 'Red'     // reset, &\n      green   // 'Green'   // reset, &\n      yellow  // 'Yellow'  // reset, &\n      blue    // 'Blue'    // reset, &\n      magenta // 'Magenta' // reset, &\n      cyan    // 'Cyan'    // reset, &\n      grey    // 'Grey'    // reset\n  write(ERROR_UNIT, '(a)') bold_blink // 'THE END\u00a0;-)' // reset\n\n  write(ERROR_UNIT, '(a)') background_green // 'Bonus Round' // reset\nend program coloured_terminal_text\n", "target": "static void Main(string[] args)\n{\n    Console.ForegroundColor = ConsoleColor.Red;\n    Console.BackgroundColor = ConsoleColor.Yellow;\n    Console.WriteLine(\"Red on Yellow\");\n    Console.ForegroundColor = ConsoleColor.White;\n    Console.BackgroundColor = ConsoleColor.Black;\n    Console.WriteLine(\"White on black\");\n    Console.ResetColor();\n    Console.WriteLine(\"Back to normal\");\n    Console.ReadKey();\n}\n"}
{"id": 69981, "name": "Terminal control_Coloured text", "source": "Translate Fortran to C#: \n\nprogram coloured_terminal_text\n  use, intrinsic :: iso_fortran_env, only: ERROR_UNIT\n  implicit none\n\n  \n  character(*), parameter :: esc = achar(27) \n  character(*), parameter :: reset = esc // '[0m' \n  \n  character(*), parameter :: red     = esc // '[31m'\n  character(*), parameter :: green   = esc // '[32m'\n  character(*), parameter :: yellow  = esc // '[33m'\n  character(*), parameter :: blue    = esc // '[34m'\n  character(*), parameter :: magenta = esc // '[35m'\n  character(*), parameter :: cyan    = esc // '[36m'\n  character(*), parameter :: grey    = esc // '[90m' \n  \n  character(*), parameter :: background_green = esc // '[42m'\n  \n  character(*), parameter :: bold = esc // '[1m'\n  character(*), parameter :: bold_blink = esc // '[1;5m'\n\n  \n  write(ERROR_UNIT, '(a)') bold // 'Coloured words:' // reset\n  write(ERROR_UNIT, '(4x, a)')       & \n      red     // 'Red'     // reset, &\n      green   // 'Green'   // reset, &\n      yellow  // 'Yellow'  // reset, &\n      blue    // 'Blue'    // reset, &\n      magenta // 'Magenta' // reset, &\n      cyan    // 'Cyan'    // reset, &\n      grey    // 'Grey'    // reset\n  write(ERROR_UNIT, '(a)') bold_blink // 'THE END\u00a0;-)' // reset\n\n  write(ERROR_UNIT, '(a)') background_green // 'Bonus Round' // reset\nend program coloured_terminal_text\n", "target": "static void Main(string[] args)\n{\n    Console.ForegroundColor = ConsoleColor.Red;\n    Console.BackgroundColor = ConsoleColor.Yellow;\n    Console.WriteLine(\"Red on Yellow\");\n    Console.ForegroundColor = ConsoleColor.White;\n    Console.BackgroundColor = ConsoleColor.Black;\n    Console.WriteLine(\"White on black\");\n    Console.ResetColor();\n    Console.WriteLine(\"Back to normal\");\n    Console.ReadKey();\n}\n"}
{"id": 69984, "name": "Terminal control_Coloured text", "source": "Translate Fortran to Python: \n\nprogram coloured_terminal_text\n  use, intrinsic :: iso_fortran_env, only: ERROR_UNIT\n  implicit none\n\n  \n  character(*), parameter :: esc = achar(27) \n  character(*), parameter :: reset = esc // '[0m' \n  \n  character(*), parameter :: red     = esc // '[31m'\n  character(*), parameter :: green   = esc // '[32m'\n  character(*), parameter :: yellow  = esc // '[33m'\n  character(*), parameter :: blue    = esc // '[34m'\n  character(*), parameter :: magenta = esc // '[35m'\n  character(*), parameter :: cyan    = esc // '[36m'\n  character(*), parameter :: grey    = esc // '[90m' \n  \n  character(*), parameter :: background_green = esc // '[42m'\n  \n  character(*), parameter :: bold = esc // '[1m'\n  character(*), parameter :: bold_blink = esc // '[1;5m'\n\n  \n  write(ERROR_UNIT, '(a)') bold // 'Coloured words:' // reset\n  write(ERROR_UNIT, '(4x, a)')       & \n      red     // 'Red'     // reset, &\n      green   // 'Green'   // reset, &\n      yellow  // 'Yellow'  // reset, &\n      blue    // 'Blue'    // reset, &\n      magenta // 'Magenta' // reset, &\n      cyan    // 'Cyan'    // reset, &\n      grey    // 'Grey'    // reset\n  write(ERROR_UNIT, '(a)') bold_blink // 'THE END\u00a0;-)' // reset\n\n  write(ERROR_UNIT, '(a)') background_green // 'Bonus Round' // reset\nend program coloured_terminal_text\n", "target": "from colorama import init, Fore, Back, Style\ninit(autoreset=True)\n\nprint Fore.RED + \"FATAL ERROR! Cannot write to /boot/vmlinuz-3.2.0-33-generic\"\nprint Back.BLUE + Fore.YELLOW + \"What a cute console!\"\nprint \"This is an %simportant%s word\" % (Style.BRIGHT, Style.NORMAL)\nprint Fore.YELLOW  + \"Rosetta Code!\"\nprint Fore.CYAN    + \"Rosetta Code!\"\nprint Fore.GREEN   + \"Rosetta Code!\"\nprint Fore.MAGENTA + \"Rosetta Code!\"\nprint Back.YELLOW + Fore.BLUE + Style.BRIGHT + \" \" * 40 + \" == Good Bye!\"\n"}
{"id": 69985, "name": "Terminal control_Coloured text", "source": "Translate Fortran to Python: \n\nprogram coloured_terminal_text\n  use, intrinsic :: iso_fortran_env, only: ERROR_UNIT\n  implicit none\n\n  \n  character(*), parameter :: esc = achar(27) \n  character(*), parameter :: reset = esc // '[0m' \n  \n  character(*), parameter :: red     = esc // '[31m'\n  character(*), parameter :: green   = esc // '[32m'\n  character(*), parameter :: yellow  = esc // '[33m'\n  character(*), parameter :: blue    = esc // '[34m'\n  character(*), parameter :: magenta = esc // '[35m'\n  character(*), parameter :: cyan    = esc // '[36m'\n  character(*), parameter :: grey    = esc // '[90m' \n  \n  character(*), parameter :: background_green = esc // '[42m'\n  \n  character(*), parameter :: bold = esc // '[1m'\n  character(*), parameter :: bold_blink = esc // '[1;5m'\n\n  \n  write(ERROR_UNIT, '(a)') bold // 'Coloured words:' // reset\n  write(ERROR_UNIT, '(4x, a)')       & \n      red     // 'Red'     // reset, &\n      green   // 'Green'   // reset, &\n      yellow  // 'Yellow'  // reset, &\n      blue    // 'Blue'    // reset, &\n      magenta // 'Magenta' // reset, &\n      cyan    // 'Cyan'    // reset, &\n      grey    // 'Grey'    // reset\n  write(ERROR_UNIT, '(a)') bold_blink // 'THE END\u00a0;-)' // reset\n\n  write(ERROR_UNIT, '(a)') background_green // 'Bonus Round' // reset\nend program coloured_terminal_text\n", "target": "from colorama import init, Fore, Back, Style\ninit(autoreset=True)\n\nprint Fore.RED + \"FATAL ERROR! Cannot write to /boot/vmlinuz-3.2.0-33-generic\"\nprint Back.BLUE + Fore.YELLOW + \"What a cute console!\"\nprint \"This is an %simportant%s word\" % (Style.BRIGHT, Style.NORMAL)\nprint Fore.YELLOW  + \"Rosetta Code!\"\nprint Fore.CYAN    + \"Rosetta Code!\"\nprint Fore.GREEN   + \"Rosetta Code!\"\nprint Fore.MAGENTA + \"Rosetta Code!\"\nprint Back.YELLOW + Fore.BLUE + Style.BRIGHT + \" \" * 40 + \" == Good Bye!\"\n"}
{"id": 70214, "name": "Loops_Foreach", "source": "Translate Fortran to C#: program main\n\n implicit none\n\n integer :: i\n character(len=5),dimension(5),parameter :: colors = ['Red  ','Green','Blue ','Black','White']\n\n \n do i=1,size(colors)\n   write(*,'(A)') colors(i) \n end do\n\n \n write(*,'(A)') colors\n\nend program main\n", "target": "string[] things = {\"Apple\", \"Banana\", \"Coconut\"};\n\nforeach (string thing in things)\n{\n    Console.WriteLine(thing);\n}\n"}
{"id": 70217, "name": "Loops_Foreach", "source": "Translate Fortran to Java: program main\n\n implicit none\n\n integer :: i\n character(len=5),dimension(5),parameter :: colors = ['Red  ','Green','Blue ','Black','White']\n\n \n do i=1,size(colors)\n   write(*,'(A)') colors(i) \n end do\n\n \n write(*,'(A)') colors\n\nend program main\n", "target": "module LoopForEach\n    {\n    @Inject Console console;\n    void run()\n        {\n        val vals = [10, 20, 30, 40];\n        console.print(\"Array of values:\");\n        Loop: for (val val : vals)\n            {\n            console.print($\"  value #{Loop.count + 1}: {val}\");\n            }\n\n        Map<String, Int> pairs = [\"x\"=42, \"y\"=69];\n        console.print(\"\\nKeys and values:\");\n        for ((String key, Int val) : pairs)\n            {\n            console.print($\"  {key}={val}\");\n            }\n        console.print(\"\\nJust the keys:\");\n        Loop: for (String key : pairs)\n            {\n            console.print($\"  key #{Loop.count + 1}: {key}\");\n            }\n\n        console.print(\"\\nValues from a range:\");\n        for (Int n : 1..5)\n            {\n            console.print($\"  {n}\");\n            }\n        }\n    }\n"}
{"id": 70218, "name": "Loops_Foreach", "source": "Translate Fortran to Python: program main\n\n implicit none\n\n integer :: i\n character(len=5),dimension(5),parameter :: colors = ['Red  ','Green','Blue ','Black','White']\n\n \n do i=1,size(colors)\n   write(*,'(A)') colors(i) \n end do\n\n \n write(*,'(A)') colors\n\nend program main\n", "target": "for i in collection:\n   print i\n"}
{"id": 70435, "name": "Brownian tree", "source": "Translate Fortran to C#: program BrownianTree\n  use RCImageBasic\n  use RCImageIO\n\n  implicit none\n\n  integer, parameter :: num_particles = 1000\n  integer, parameter :: wsize         = 800\n\n  integer, dimension(wsize, wsize) :: world\n  type(rgbimage) :: gworld\n  integer :: x, y\n\n  \n  call init_random_seed\n  \n  world = 0\n  call draw_brownian_tree(world)\n\n  call alloc_img(gworld, wsize, wsize)\n  call fill_img(gworld, rgb(0,0,0))\n  \n  do y = 1, wsize\n     do x = 1, wsize\n        if ( world(x, y) /= 0 ) then\n           call put_pixel(gworld, x, y, rgb(255, 255, 255))\n        end if\n     end do\n  end do\n\n  open(unit=10, file='browniantree.ppm', action='write')\n  call output_ppm(10, gworld)\n  close(10)\n\n  call free_img(gworld)\n\ncontains\n\n  \n  subroutine init_random_seed\n    integer :: i, n, clock\n    integer, dimension(:), allocatable :: seed\n\n    call random_seed(size = n)\n    allocate(seed(n))\n    call system_clock(count = clock)\n    seed = clock + 37 * (/ ( i - 1, i = 1, n) /)\n    call random_seed(put = seed)\n    deallocate(seed)\n  end subroutine init_random_seed\n\n\n  function randbetween(a, b) result(res) \n    integer, intent(in) :: a, b\n    integer :: res\n\n    real :: r\n\n    call random_number(r)\n\n    res = a + int((b-a)*r + 0.5)\n\n  end function randbetween\n\n  function bounded(v, ll, ul) result(res)\n    integer, intent(in) :: v, ll, ul\n    logical res\n\n    res = ( v >= ll ) .and. ( v <= ul )\n  end function bounded\n\n\n  subroutine draw_brownian_tree(w)\n    integer, dimension(:,:), intent(inout) :: w\n\n    integer :: px, py, dx, dy, i\n    integer :: xsize, ysize\n\n    xsize = size(w, 1)\n    ysize = size(w, 2)\n\n    w(randbetween(1, xsize), randbetween(1, ysize)) = 1\n    \n    do i = 1, num_particles\n       px = randbetween(1, xsize)\n       py = randbetween(1, ysize)\n       \n       do\n          dx = randbetween(-1, 1)\n          dy = randbetween(-1, 1)\n          if ( .not. bounded(dx+px, 1, xsize) .or. .not. bounded(dy+py, 1, ysize) ) then\n             px = randbetween(1, xsize)\n             py = randbetween(1, ysize)\n          else if ( w(px+dx, py+dy) /= 0 ) then\n             w(px, py) = 1\n             exit\n          else\n             py = py + dy\n             px = px + dx\n          end if\n       end do\n    end do\n    \n  end subroutine draw_brownian_tree\n\nend program\n", "target": "using System;\nusing System.Drawing;\n\nnamespace BrownianTree\n{\n    class Program\n    {\n        static Bitmap BrownianTree(int size, int numparticles)\n        {\n            Bitmap bmp = new Bitmap(size, size);\n            Rectangle bounds = new Rectangle { X = 0, Y = 0, Size = bmp.Size };\n            using (Graphics g = Graphics.FromImage(bmp))\n            {\n                g.Clear(Color.Black);\n            }\n            Random rnd = new Random();\n            bmp.SetPixel(rnd.Next(size), rnd.Next(size), Color.White);\n            Point pt = new Point(), newpt = new Point();\n            for (int i = 0; i < numparticles; i++)\n            {\n                pt.X = rnd.Next(size);\n                pt.Y = rnd.Next(size);\n                do\n                {\n                    newpt.X = pt.X + rnd.Next(-1, 2);\n                    newpt.Y = pt.Y + rnd.Next(-1, 2);\n                    if (!bounds.Contains(newpt))\n                    {\n                        pt.X = rnd.Next(size);\n                        pt.Y = rnd.Next(size);\n                    }\n                    else if (bmp.GetPixel(newpt.X, newpt.Y).R > 0)\n                    {\n                        bmp.SetPixel(pt.X, pt.Y, Color.White);\n                        break;\n                    }\n                    else\n                    {\n                        pt = newpt;\n                    }\n                } while (true);\n            }\n            return bmp;\n        }\n\n        static void Main(string[] args)\n        {\n            BrownianTree(300, 3000).Save(\"browniantree.png\");\n        }\n    }\n}\n"}
{"id": 70438, "name": "Brownian tree", "source": "Translate Fortran to Java: program BrownianTree\n  use RCImageBasic\n  use RCImageIO\n\n  implicit none\n\n  integer, parameter :: num_particles = 1000\n  integer, parameter :: wsize         = 800\n\n  integer, dimension(wsize, wsize) :: world\n  type(rgbimage) :: gworld\n  integer :: x, y\n\n  \n  call init_random_seed\n  \n  world = 0\n  call draw_brownian_tree(world)\n\n  call alloc_img(gworld, wsize, wsize)\n  call fill_img(gworld, rgb(0,0,0))\n  \n  do y = 1, wsize\n     do x = 1, wsize\n        if ( world(x, y) /= 0 ) then\n           call put_pixel(gworld, x, y, rgb(255, 255, 255))\n        end if\n     end do\n  end do\n\n  open(unit=10, file='browniantree.ppm', action='write')\n  call output_ppm(10, gworld)\n  close(10)\n\n  call free_img(gworld)\n\ncontains\n\n  \n  subroutine init_random_seed\n    integer :: i, n, clock\n    integer, dimension(:), allocatable :: seed\n\n    call random_seed(size = n)\n    allocate(seed(n))\n    call system_clock(count = clock)\n    seed = clock + 37 * (/ ( i - 1, i = 1, n) /)\n    call random_seed(put = seed)\n    deallocate(seed)\n  end subroutine init_random_seed\n\n\n  function randbetween(a, b) result(res) \n    integer, intent(in) :: a, b\n    integer :: res\n\n    real :: r\n\n    call random_number(r)\n\n    res = a + int((b-a)*r + 0.5)\n\n  end function randbetween\n\n  function bounded(v, ll, ul) result(res)\n    integer, intent(in) :: v, ll, ul\n    logical res\n\n    res = ( v >= ll ) .and. ( v <= ul )\n  end function bounded\n\n\n  subroutine draw_brownian_tree(w)\n    integer, dimension(:,:), intent(inout) :: w\n\n    integer :: px, py, dx, dy, i\n    integer :: xsize, ysize\n\n    xsize = size(w, 1)\n    ysize = size(w, 2)\n\n    w(randbetween(1, xsize), randbetween(1, ysize)) = 1\n    \n    do i = 1, num_particles\n       px = randbetween(1, xsize)\n       py = randbetween(1, ysize)\n       \n       do\n          dx = randbetween(-1, 1)\n          dy = randbetween(-1, 1)\n          if ( .not. bounded(dx+px, 1, xsize) .or. .not. bounded(dy+py, 1, ysize) ) then\n             px = randbetween(1, xsize)\n             py = randbetween(1, ysize)\n          else if ( w(px+dx, py+dy) /= 0 ) then\n             w(px, py) = 1\n             exit\n          else\n             py = py + dy\n             px = px + dx\n          end if\n       end do\n    end do\n    \n  end subroutine draw_brownian_tree\n\nend program\n", "target": "import java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.util.*;\nimport javax.swing.JFrame;\n\npublic class BrownianTree extends JFrame implements Runnable {\n\n    BufferedImage I;\n    private List<Particle> particles;\n    static Random rand = new Random();\n\n    public BrownianTree() {\n        super(\"Brownian Tree\");\n        setBounds(100, 100, 400, 300);\n        setDefaultCloseOperation(EXIT_ON_CLOSE);\n        I = new BufferedImage(getWidth(), getHeight(), BufferedImage.TYPE_INT_RGB);\n        I.setRGB(I.getWidth() / 2, I.getHeight() / 2, 0xff00);\n        particles = new LinkedList<Particle>();\n    }\n\n    @Override\n    public void paint(Graphics g) {\n        g.drawImage(I, 0, 0, this);\n    }\n\n    public void run() {\n        for (int i = 0; i < 20000; i++) {\n            particles.add(new Particle());\n        }\n        while (!particles.isEmpty()) {\n            for (Iterator<Particle> it = particles.iterator(); it.hasNext();) {\n                if (it.next().move()) {\n                    it.remove();\n                }\n            }\n            repaint();\n        }\n    }\n\n    public static void main(String[] args) {\n        BrownianTree b = new BrownianTree();\n        b.setVisible(true);\n        new Thread(b).start();\n    }\n\n    private class Particle {\n\n        private int x, y;\n\n        private Particle() {\n            x = rand.nextInt(I.getWidth());\n            y = rand.nextInt(I.getHeight());\n        }\n\n        \n        private boolean move() {\n            int dx = rand.nextInt(3) - 1;\n            int dy = rand.nextInt(3) - 1;\n            if ((x + dx < 0) || (y + dy < 0)\n                    || (y + dy >= I.getHeight()) || (x + dx >= I.getWidth())) {\n                return true;\n            }\n            x += dx;\n            y += dy;\n            if ((I.getRGB(x, y) & 0xff00) == 0xff00) {\n                I.setRGB(x - dx, y - dy, 0xff00);\n                return true;\n            }\n            return false;\n        }\n    }\n}\n"}
{"id": 70439, "name": "Brownian tree", "source": "Translate Fortran to Python: program BrownianTree\n  use RCImageBasic\n  use RCImageIO\n\n  implicit none\n\n  integer, parameter :: num_particles = 1000\n  integer, parameter :: wsize         = 800\n\n  integer, dimension(wsize, wsize) :: world\n  type(rgbimage) :: gworld\n  integer :: x, y\n\n  \n  call init_random_seed\n  \n  world = 0\n  call draw_brownian_tree(world)\n\n  call alloc_img(gworld, wsize, wsize)\n  call fill_img(gworld, rgb(0,0,0))\n  \n  do y = 1, wsize\n     do x = 1, wsize\n        if ( world(x, y) /= 0 ) then\n           call put_pixel(gworld, x, y, rgb(255, 255, 255))\n        end if\n     end do\n  end do\n\n  open(unit=10, file='browniantree.ppm', action='write')\n  call output_ppm(10, gworld)\n  close(10)\n\n  call free_img(gworld)\n\ncontains\n\n  \n  subroutine init_random_seed\n    integer :: i, n, clock\n    integer, dimension(:), allocatable :: seed\n\n    call random_seed(size = n)\n    allocate(seed(n))\n    call system_clock(count = clock)\n    seed = clock + 37 * (/ ( i - 1, i = 1, n) /)\n    call random_seed(put = seed)\n    deallocate(seed)\n  end subroutine init_random_seed\n\n\n  function randbetween(a, b) result(res) \n    integer, intent(in) :: a, b\n    integer :: res\n\n    real :: r\n\n    call random_number(r)\n\n    res = a + int((b-a)*r + 0.5)\n\n  end function randbetween\n\n  function bounded(v, ll, ul) result(res)\n    integer, intent(in) :: v, ll, ul\n    logical res\n\n    res = ( v >= ll ) .and. ( v <= ul )\n  end function bounded\n\n\n  subroutine draw_brownian_tree(w)\n    integer, dimension(:,:), intent(inout) :: w\n\n    integer :: px, py, dx, dy, i\n    integer :: xsize, ysize\n\n    xsize = size(w, 1)\n    ysize = size(w, 2)\n\n    w(randbetween(1, xsize), randbetween(1, ysize)) = 1\n    \n    do i = 1, num_particles\n       px = randbetween(1, xsize)\n       py = randbetween(1, ysize)\n       \n       do\n          dx = randbetween(-1, 1)\n          dy = randbetween(-1, 1)\n          if ( .not. bounded(dx+px, 1, xsize) .or. .not. bounded(dy+py, 1, ysize) ) then\n             px = randbetween(1, xsize)\n             py = randbetween(1, ysize)\n          else if ( w(px+dx, py+dy) /= 0 ) then\n             w(px, py) = 1\n             exit\n          else\n             py = py + dy\n             px = px + dx\n          end if\n       end do\n    end do\n    \n  end subroutine draw_brownian_tree\n\nend program\n", "target": "SIDESTICK = False\n\ndef setup() :\n    global is_taken\n    size(512, 512)\n    background(0)\n    is_taken = [[False] * height for _ in range(width)]\n    is_taken[width/2][height/2] = True\n\n\ndef draw() :\n    x = floor(random(width))\n    y = floor(random(height))\n    if is_taken[x][y]: \n        return\n    while True:\n        xp = x + floor(random(-1, 2))\n        yp = y + floor(random(-1, 2))\n        is_contained = 0 <= xp < width and 0 <= yp < height\n        if is_contained and not is_taken[xp][yp]:\n            x = xp\n            y = yp\n            continue\n        else:\n            if SIDESTICK or (is_contained and is_taken[xp][yp]):\n                is_taken[x][y] = True\n                set(x, y, color(255))            \n            break\n        \n    if frameCount > width * height:\n        noLoop()\n"}
{"id": 70618, "name": "Guess the number_With feedback (player)", "source": "Translate Fortran to C#: program Guess_a_number_Player\n  implicit none\n  \n  integer, parameter :: limit = 100\n  integer :: guess, mx = limit, mn = 1\n  real :: rnum\n  character(1) :: score\n  \n  write(*, \"(a, i0, a)\") \"Think of a number between 1 and \", limit, &\n                         \" and I will try to guess it.\" \n  write(*, \"(a)\")  \"You score my guess by entering: h if my guess is higher than that number\"\n  write(*, \"(a)\")  \"                                l if my guess is lower than that number\"\n  write(*, \"(a/)\") \"                                c if my guess is the same as that number\"\n\n  call random_seed\n  call random_number(rnum)\n  guess = rnum * limit + 1\n  do\n    write(*, \"(a, i0, a,)\", advance='no') \"My quess is: \", guess, \"   Score(h, l or c)?: \"\n    read*, score\n    select case(score)\n      case(\"l\", \"L\")\n        mn = guess\n        guess = (mx-guess+1) / 2 + mn \n        \n      case(\"h\", \"H\")\n        mx = guess\n        guess = mx - (guess-mn+1) / 2 \n\n      case(\"c\", \"C\")\n        write(*, \"(a)\") \"I solved it\n        exit\n\n      case default\n        write(*, \"(a)\") \"I did not understand that\"\n    end select\n  end do\nend program\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Threading; \n\nnamespace ConsoleApplication1\n{\n    class RealisticGuess \n    {\n        private int max;\n        private int min;\n        private int guess;\n\n        public void Start()\n        {\n            Console.Clear();\n            string input;\n\n            try\n            {\n                Console.WriteLine(\"Please enter the lower boundary\");\n                input = Console.ReadLine();\n                min = Convert.ToInt32(input);\n                Console.WriteLine(\"Please enter the upper boundary\");\n                input = Console.ReadLine();\n                max = Convert.ToInt32(input);\n            }\n            catch (FormatException)\n            {\n                Console.WriteLine(\"The entry you have made is invalid. Please make sure your entry is an integer and try again.\");\n                Console.ReadKey(true);\n                Start();\n            }\n            Console.WriteLine(\"Think of a number between {0} and {1}.\", min, max);\n            Thread.Sleep(2500);\n            Console.WriteLine(\"Ready?\");\n            Console.WriteLine(\"Press any key to begin.\");\n            Console.ReadKey(true);\n            Guess(min, max);\n        }\n        public void Guess(int min, int max)\n        {\n            int counter = 1;\n            string userAnswer;\n            bool correct = false;\n            Random rand = new Random();\n\n            while (correct == false)\n            {\n                guess = rand.Next(min, max);\n                Console.Clear();\n                Console.WriteLine(\"{0}\", guess);\n                Console.WriteLine(\"Is this number correct? {Y/N}\");\n                userAnswer = Console.ReadLine();\n                if (userAnswer != \"y\" && userAnswer != \"Y\" && userAnswer != \"n\" && userAnswer != \"N\")\n                {\n                    Console.WriteLine(\"Your entry is invalid. Please enter either 'Y' or 'N'\");\n                    Console.WriteLine(\"Is the number correct? {Y/N}\");\n                    userAnswer = Console.ReadLine();\n                }\n                if (userAnswer == \"y\" || userAnswer == \"Y\")\n                {\n                    correct = true;\n                }\n                if (userAnswer == \"n\" || userAnswer == \"N\")\n                {\n                    counter++;\n                    if (max == min)\n                    {\n                        Console.WriteLine(\"Error: Range Intersect. Press enter to restart the game.\");  \n                        Console.ReadKey(true);                                                          \n                        Guess(1, 101);                                                                  \n                    }\n                    Console.WriteLine(\"Is the number you're thinking of lower or higher? {L/H}\");\n                    userAnswer = Console.ReadLine();\n                    if (userAnswer != \"l\" && userAnswer != \"L\" && userAnswer != \"h\" && userAnswer != \"H\")\n                    {\n                        Console.WriteLine(\"Your entry is invalid. Please enter either 'L' or 'H'\");\n                        Console.WriteLine(\"Is the number you're thinking of lower or higher? {L/H}\");\n                        userAnswer = Console.ReadLine();\n                    }\n                    if (userAnswer == \"l\" || userAnswer == \"L\")\n                    {\n                        max = guess;\n                    }\n                    if (userAnswer == \"h\" || userAnswer == \"H\")\n                    {\n                        min = guess;\n                    }\n                }\n            }\n            if (correct == true)\n            {\n                EndAndLoop(counter);\n            }\n        }\n\n        public void EndAndLoop(int iterations)\n        {\n            string userChoice;\n            bool loop = false;\n            Console.WriteLine(\"Game over. It took {0} guesses to find the number.\", iterations);\n            while (loop == false)\n            {\n                Console.WriteLine(\"Would you like to play again? {Y/N}\");\n                userChoice = Console.ReadLine();\n                if (userChoice != \"Y\" && userChoice != \"y\" && userChoice != \"N\" && userChoice != \"n\")\n                {\n                    Console.WriteLine(\"Sorry, your input is invalid. Please answer 'Y' to play again, or 'N' to quit.\");\n                }\n                if (userChoice == \"Y\" || userChoice == \"y\")\n                {\n                    Start();\n                }\n                if (userChoice == \"N\" || userChoice == \"n\")\n                {\n                    Environment.Exit(1);\n                }\n            }\n        }\n    }\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            Console.Title = \"Random Number\";\n            RealisticGuess game = new RealisticGuess();\n            game.Start();\n        }\n    }\n}\n"}
{"id": 70621, "name": "Guess the number_With feedback (player)", "source": "Translate Fortran to Java: program Guess_a_number_Player\n  implicit none\n  \n  integer, parameter :: limit = 100\n  integer :: guess, mx = limit, mn = 1\n  real :: rnum\n  character(1) :: score\n  \n  write(*, \"(a, i0, a)\") \"Think of a number between 1 and \", limit, &\n                         \" and I will try to guess it.\" \n  write(*, \"(a)\")  \"You score my guess by entering: h if my guess is higher than that number\"\n  write(*, \"(a)\")  \"                                l if my guess is lower than that number\"\n  write(*, \"(a/)\") \"                                c if my guess is the same as that number\"\n\n  call random_seed\n  call random_number(rnum)\n  guess = rnum * limit + 1\n  do\n    write(*, \"(a, i0, a,)\", advance='no') \"My quess is: \", guess, \"   Score(h, l or c)?: \"\n    read*, score\n    select case(score)\n      case(\"l\", \"L\")\n        mn = guess\n        guess = (mx-guess+1) / 2 + mn \n        \n      case(\"h\", \"H\")\n        mx = guess\n        guess = mx - (guess-mn+1) / 2 \n\n      case(\"c\", \"C\")\n        write(*, \"(a)\") \"I solved it\n        exit\n\n      case default\n        write(*, \"(a)\") \"I did not understand that\"\n    end select\n  end do\nend program\n", "target": "import java.util.AbstractList;\nimport java.util.Collections;\nimport java.util.Scanner;\n\npublic class GuessNumber {\n    public static final int LOWER = 0, UPPER = 100;\n    public static void main(String[] args) {\n\tSystem.out.printf(\"Instructions:\\n\" +\n\t\t\t  \"Think of integer number from %d (inclusive) to %d (exclusive) and\\n\" +\n\t\t\t  \"I will guess it. After each guess, you respond with L, H, or C depending\\n\" +\n\t\t\t  \"on if my guess was too low, too high, or correct.\\n\",\n\t\t\t  LOWER, UPPER);\n\tint result = Collections.binarySearch(new AbstractList<Integer>() {\n\t\tprivate final Scanner in = new Scanner(System.in);\n\t\tpublic int size() { return UPPER - LOWER; }\n\t\tpublic Integer get(int i) {\n\t\t    System.out.printf(\"My guess is: %d. Is it too high, too low, or correct? (H/L/C) \", LOWER+i);\n\t\t    String s = in.nextLine();\n\t\t    assert s.length() > 0;\n\t\t    switch (Character.toLowerCase(s.charAt(0))) {\n\t\t    case 'l':\n\t\t\treturn -1;\n\t\t    case 'h':\n\t\t\treturn 1;\n\t\t    case 'c':\n\t\t\treturn 0;\n\t\t    }\n\t\t    return -1;\n\t\t}\n\t    }, 0);\n\tif (result < 0)\n\t    System.out.println(\"That is impossible.\");\n\telse\n\t    System.out.printf(\"Your number is %d.\\n\", result);\n    }\n}\n"}
{"id": 70622, "name": "Guess the number_With feedback (player)", "source": "Translate Fortran to Python: program Guess_a_number_Player\n  implicit none\n  \n  integer, parameter :: limit = 100\n  integer :: guess, mx = limit, mn = 1\n  real :: rnum\n  character(1) :: score\n  \n  write(*, \"(a, i0, a)\") \"Think of a number between 1 and \", limit, &\n                         \" and I will try to guess it.\" \n  write(*, \"(a)\")  \"You score my guess by entering: h if my guess is higher than that number\"\n  write(*, \"(a)\")  \"                                l if my guess is lower than that number\"\n  write(*, \"(a/)\") \"                                c if my guess is the same as that number\"\n\n  call random_seed\n  call random_number(rnum)\n  guess = rnum * limit + 1\n  do\n    write(*, \"(a, i0, a,)\", advance='no') \"My quess is: \", guess, \"   Score(h, l or c)?: \"\n    read*, score\n    select case(score)\n      case(\"l\", \"L\")\n        mn = guess\n        guess = (mx-guess+1) / 2 + mn \n        \n      case(\"h\", \"H\")\n        mx = guess\n        guess = mx - (guess-mn+1) / 2 \n\n      case(\"c\", \"C\")\n        write(*, \"(a)\") \"I solved it\n        exit\n\n      case default\n        write(*, \"(a)\") \"I did not understand that\"\n    end select\n  end do\nend program\n", "target": "inclusive_range = mn, mx = (1, 10)\n\nprint( % inclusive_range)\n\ni = 0\nwhile True:\n    i += 1\n    guess = (mn+mx)//2\n    txt = input(\"Guess %2i is: %2i. The score for which is (h,l,=): \"\n                % (i, guess)).strip().lower()[0]\n    if txt not in 'hl=':\n        print(\"  I don't understand your input of '%s'\u00a0?\" % txt)\n        continue\n    if txt == 'h':\n        mx = guess-1\n    if txt == 'l':\n        mn = guess+1\n    if txt == '=':\n        print(\"  Ye-Haw!!\")\n        break\n    if (mn > mx) or (mn < inclusive_range[0]) or (mx > inclusive_range[1]):\n        print(\"Please check your scoring as I cannot find the value\")\n        break\n        \nprint(\"\\nThanks for keeping score.\")\n"}
{"id": 71556, "name": "Determine if a string has all unique characters", "source": "Translate Fortran to C#: program demo_verify\nimplicit none\n    call nodup('')\n    call nodup('.')\n    call nodup('abcABC')\n    call nodup('XYZ ZYX')\n    call nodup('1234567890ABCDEFGHIJKLMN0PQRSTUVWXYZ')\ncontains\n\nsubroutine nodup(str)\ncharacter(len=*),intent(in)  :: str\ncharacter(len=*),parameter   :: g='(*(g0))'\ncharacter(len=:),allocatable :: ch\ninteger                      :: where\ninteger                      :: i\n   where=0\n   ch=''\n\n   do i=1,len(str)-1\n      ch=str(i:i)\n      where=index(str(i+1:),ch)\n      if(where.ne.0)then\n         where=where+i\n         exit\n      endif\n   enddo\n\n   if(where.eq.0)then\n     write(*,g)'STR: \"',str,'\"',new_line('a'),'LEN: ',len(str),'. No duplicate characters found'\n   else\n     write(*,g)'STR: \"',str,'\"'\n     write(*,'(a,a,t1,a,a)')repeat(' ',where+5),'^',repeat(' ',i+5),'^'\n     write(*,g)'LEN: ',len(str), &\n     & '. Duplicate chars. First duplicate at positions ',i,' and ',where, &\n     & ' where a ','\"'//str(where:where)//'\"(hex:',hex(str(where:where)),') was found.'\n   endif\n   write(*,*)\n\nend subroutine nodup\n\nfunction hex(ch) result(hexstr)\ncharacter(len=1),intent(in) :: ch\ncharacter(len=:),allocatable :: hexstr\n   hexstr=repeat(' ',100)\n   write(hexstr,'(Z0)')ch\n   hexstr=trim(hexstr)\nend function hex\n\nend program demo_verify\n", "target": "using System;\nusing System.Linq;\n\npublic class Program\n{\n    static void Main\n    {\n        string[] input = {\"\", \".\", \"abcABC\", \"XYZ ZYX\", \"1234567890ABCDEFGHIJKLMN0PQRSTUVWXYZ\"};\n        foreach (string s in input) {\n            Console.WriteLine($\"\\\"{s}\\\" (Length {s.Length}) \" +\n                string.Join(\", \",\n                    s.Select((c, i) => (c, i))\n                    .GroupBy(t => t.c).Where(g => g.Count() > 1)\n                    .Select(g => $\"'{g.Key}' (0X{(int)g.Key:X})[{string.Join(\", \", g.Select(t => t.i))}]\")\n                    .DefaultIfEmpty(\"All characters are unique.\")\n                )\n            );\n        }\n    }\n}\n"}
{"id": 71557, "name": "Determine if a string has all unique characters", "source": "Translate Fortran to C#: program demo_verify\nimplicit none\n    call nodup('')\n    call nodup('.')\n    call nodup('abcABC')\n    call nodup('XYZ ZYX')\n    call nodup('1234567890ABCDEFGHIJKLMN0PQRSTUVWXYZ')\ncontains\n\nsubroutine nodup(str)\ncharacter(len=*),intent(in)  :: str\ncharacter(len=*),parameter   :: g='(*(g0))'\ncharacter(len=:),allocatable :: ch\ninteger                      :: where\ninteger                      :: i\n   where=0\n   ch=''\n\n   do i=1,len(str)-1\n      ch=str(i:i)\n      where=index(str(i+1:),ch)\n      if(where.ne.0)then\n         where=where+i\n         exit\n      endif\n   enddo\n\n   if(where.eq.0)then\n     write(*,g)'STR: \"',str,'\"',new_line('a'),'LEN: ',len(str),'. No duplicate characters found'\n   else\n     write(*,g)'STR: \"',str,'\"'\n     write(*,'(a,a,t1,a,a)')repeat(' ',where+5),'^',repeat(' ',i+5),'^'\n     write(*,g)'LEN: ',len(str), &\n     & '. Duplicate chars. First duplicate at positions ',i,' and ',where, &\n     & ' where a ','\"'//str(where:where)//'\"(hex:',hex(str(where:where)),') was found.'\n   endif\n   write(*,*)\n\nend subroutine nodup\n\nfunction hex(ch) result(hexstr)\ncharacter(len=1),intent(in) :: ch\ncharacter(len=:),allocatable :: hexstr\n   hexstr=repeat(' ',100)\n   write(hexstr,'(Z0)')ch\n   hexstr=trim(hexstr)\nend function hex\n\nend program demo_verify\n", "target": "using System;\nusing System.Linq;\n\npublic class Program\n{\n    static void Main\n    {\n        string[] input = {\"\", \".\", \"abcABC\", \"XYZ ZYX\", \"1234567890ABCDEFGHIJKLMN0PQRSTUVWXYZ\"};\n        foreach (string s in input) {\n            Console.WriteLine($\"\\\"{s}\\\" (Length {s.Length}) \" +\n                string.Join(\", \",\n                    s.Select((c, i) => (c, i))\n                    .GroupBy(t => t.c).Where(g => g.Count() > 1)\n                    .Select(g => $\"'{g.Key}' (0X{(int)g.Key:X})[{string.Join(\", \", g.Select(t => t.i))}]\")\n                    .DefaultIfEmpty(\"All characters are unique.\")\n                )\n            );\n        }\n    }\n}\n"}
{"id": 71562, "name": "Determine if a string has all unique characters", "source": "Translate Fortran to Java: program demo_verify\nimplicit none\n    call nodup('')\n    call nodup('.')\n    call nodup('abcABC')\n    call nodup('XYZ ZYX')\n    call nodup('1234567890ABCDEFGHIJKLMN0PQRSTUVWXYZ')\ncontains\n\nsubroutine nodup(str)\ncharacter(len=*),intent(in)  :: str\ncharacter(len=*),parameter   :: g='(*(g0))'\ncharacter(len=:),allocatable :: ch\ninteger                      :: where\ninteger                      :: i\n   where=0\n   ch=''\n\n   do i=1,len(str)-1\n      ch=str(i:i)\n      where=index(str(i+1:),ch)\n      if(where.ne.0)then\n         where=where+i\n         exit\n      endif\n   enddo\n\n   if(where.eq.0)then\n     write(*,g)'STR: \"',str,'\"',new_line('a'),'LEN: ',len(str),'. No duplicate characters found'\n   else\n     write(*,g)'STR: \"',str,'\"'\n     write(*,'(a,a,t1,a,a)')repeat(' ',where+5),'^',repeat(' ',i+5),'^'\n     write(*,g)'LEN: ',len(str), &\n     & '. Duplicate chars. First duplicate at positions ',i,' and ',where, &\n     & ' where a ','\"'//str(where:where)//'\"(hex:',hex(str(where:where)),') was found.'\n   endif\n   write(*,*)\n\nend subroutine nodup\n\nfunction hex(ch) result(hexstr)\ncharacter(len=1),intent(in) :: ch\ncharacter(len=:),allocatable :: hexstr\n   hexstr=repeat(' ',100)\n   write(hexstr,'(Z0)')ch\n   hexstr=trim(hexstr)\nend function hex\n\nend program demo_verify\n", "target": "import java.util.HashMap;\nimport java.util.Map;\n\n\n\npublic class StringUniqueCharacters {\n\n    public static void main(String[] args) {\n        System.out.printf(\"%-40s  %2s  %10s  %8s  %s  %s%n\", \"String\", \"Length\", \"All Unique\", \"1st Diff\", \"Hex\", \"Positions\");\n        System.out.printf(\"%-40s  %2s  %10s  %8s  %s  %s%n\", \"------------------------\", \"------\", \"----------\", \"--------\", \"---\", \"---------\");\n        for ( String s : new String[] {\"\", \".\", \"abcABC\", \"XYZ ZYX\", \"1234567890ABCDEFGHIJKLMN0PQRSTUVWXYZ\"} ) {\n            processString(s);\n        }\n    }\n    \n    \n    \n    private static void processString(String input) {\n        Map<Character,Integer> charMap = new HashMap<>(); \n        char dup = 0;\n        int index = 0;\n        int pos1 = -1;\n        int pos2 = -1;\n        for ( char key : input.toCharArray() ) {\n            index++;\n            if ( charMap.containsKey(key) ) {\n                dup = key;\n                pos1 = charMap.get(key);\n                pos2 = index;\n                break;\n            }\n            charMap.put(key, index);\n        }\n        String unique = dup == 0 ? \"yes\" : \"no\";\n        String diff = dup == 0 ? \"\" : \"'\" + dup + \"'\";\n        String hex = dup == 0 ? \"\" : Integer.toHexString(dup).toUpperCase();\n        String position = dup == 0 ? \"\" : pos1 + \" \" + pos2;\n        System.out.printf(\"%-40s \u00a0%-6d \u00a0%-10s \u00a0%-8s \u00a0%-3s \u00a0%-5s%n\", input, input.length(), unique, diff, hex, position);\n    }\n\n}\n"}
{"id": 71563, "name": "Determine if a string has all unique characters", "source": "Translate Fortran to Java: program demo_verify\nimplicit none\n    call nodup('')\n    call nodup('.')\n    call nodup('abcABC')\n    call nodup('XYZ ZYX')\n    call nodup('1234567890ABCDEFGHIJKLMN0PQRSTUVWXYZ')\ncontains\n\nsubroutine nodup(str)\ncharacter(len=*),intent(in)  :: str\ncharacter(len=*),parameter   :: g='(*(g0))'\ncharacter(len=:),allocatable :: ch\ninteger                      :: where\ninteger                      :: i\n   where=0\n   ch=''\n\n   do i=1,len(str)-1\n      ch=str(i:i)\n      where=index(str(i+1:),ch)\n      if(where.ne.0)then\n         where=where+i\n         exit\n      endif\n   enddo\n\n   if(where.eq.0)then\n     write(*,g)'STR: \"',str,'\"',new_line('a'),'LEN: ',len(str),'. No duplicate characters found'\n   else\n     write(*,g)'STR: \"',str,'\"'\n     write(*,'(a,a,t1,a,a)')repeat(' ',where+5),'^',repeat(' ',i+5),'^'\n     write(*,g)'LEN: ',len(str), &\n     & '. Duplicate chars. First duplicate at positions ',i,' and ',where, &\n     & ' where a ','\"'//str(where:where)//'\"(hex:',hex(str(where:where)),') was found.'\n   endif\n   write(*,*)\n\nend subroutine nodup\n\nfunction hex(ch) result(hexstr)\ncharacter(len=1),intent(in) :: ch\ncharacter(len=:),allocatable :: hexstr\n   hexstr=repeat(' ',100)\n   write(hexstr,'(Z0)')ch\n   hexstr=trim(hexstr)\nend function hex\n\nend program demo_verify\n", "target": "import java.util.HashMap;\nimport java.util.Map;\n\n\n\npublic class StringUniqueCharacters {\n\n    public static void main(String[] args) {\n        System.out.printf(\"%-40s  %2s  %10s  %8s  %s  %s%n\", \"String\", \"Length\", \"All Unique\", \"1st Diff\", \"Hex\", \"Positions\");\n        System.out.printf(\"%-40s  %2s  %10s  %8s  %s  %s%n\", \"------------------------\", \"------\", \"----------\", \"--------\", \"---\", \"---------\");\n        for ( String s : new String[] {\"\", \".\", \"abcABC\", \"XYZ ZYX\", \"1234567890ABCDEFGHIJKLMN0PQRSTUVWXYZ\"} ) {\n            processString(s);\n        }\n    }\n    \n    \n    \n    private static void processString(String input) {\n        Map<Character,Integer> charMap = new HashMap<>(); \n        char dup = 0;\n        int index = 0;\n        int pos1 = -1;\n        int pos2 = -1;\n        for ( char key : input.toCharArray() ) {\n            index++;\n            if ( charMap.containsKey(key) ) {\n                dup = key;\n                pos1 = charMap.get(key);\n                pos2 = index;\n                break;\n            }\n            charMap.put(key, index);\n        }\n        String unique = dup == 0 ? \"yes\" : \"no\";\n        String diff = dup == 0 ? \"\" : \"'\" + dup + \"'\";\n        String hex = dup == 0 ? \"\" : Integer.toHexString(dup).toUpperCase();\n        String position = dup == 0 ? \"\" : pos1 + \" \" + pos2;\n        System.out.printf(\"%-40s \u00a0%-6d \u00a0%-10s \u00a0%-8s \u00a0%-3s \u00a0%-5s%n\", input, input.length(), unique, diff, hex, position);\n    }\n\n}\n"}
{"id": 71564, "name": "Determine if a string has all unique characters", "source": "Translate Fortran to Python: program demo_verify\nimplicit none\n    call nodup('')\n    call nodup('.')\n    call nodup('abcABC')\n    call nodup('XYZ ZYX')\n    call nodup('1234567890ABCDEFGHIJKLMN0PQRSTUVWXYZ')\ncontains\n\nsubroutine nodup(str)\ncharacter(len=*),intent(in)  :: str\ncharacter(len=*),parameter   :: g='(*(g0))'\ncharacter(len=:),allocatable :: ch\ninteger                      :: where\ninteger                      :: i\n   where=0\n   ch=''\n\n   do i=1,len(str)-1\n      ch=str(i:i)\n      where=index(str(i+1:),ch)\n      if(where.ne.0)then\n         where=where+i\n         exit\n      endif\n   enddo\n\n   if(where.eq.0)then\n     write(*,g)'STR: \"',str,'\"',new_line('a'),'LEN: ',len(str),'. No duplicate characters found'\n   else\n     write(*,g)'STR: \"',str,'\"'\n     write(*,'(a,a,t1,a,a)')repeat(' ',where+5),'^',repeat(' ',i+5),'^'\n     write(*,g)'LEN: ',len(str), &\n     & '. Duplicate chars. First duplicate at positions ',i,' and ',where, &\n     & ' where a ','\"'//str(where:where)//'\"(hex:',hex(str(where:where)),') was found.'\n   endif\n   write(*,*)\n\nend subroutine nodup\n\nfunction hex(ch) result(hexstr)\ncharacter(len=1),intent(in) :: ch\ncharacter(len=:),allocatable :: hexstr\n   hexstr=repeat(' ',100)\n   write(hexstr,'(Z0)')ch\n   hexstr=trim(hexstr)\nend function hex\n\nend program demo_verify\n", "target": "\n\nfrom itertools import groupby\n\n\n\ndef duplicatedCharIndices(s):\n    \n    def go(xs):\n        if 1 < len(xs):\n            duplicates = list(filter(lambda kv: 1 < len(kv[1]), [\n                (k, list(v)) for k, v in groupby(\n                    sorted(xs, key=swap),\n                    key=snd\n                )\n            ]))\n            return Just(second(fmap(fst))(\n                sorted(\n                    duplicates,\n                    key=lambda kv: kv[1][0]\n                )[0]\n            )) if duplicates else Nothing()\n        else:\n            return Nothing()\n    return go(list(enumerate(s)))\n\n\n\n\ndef main():\n    \n\n    def showSample(s):\n        return repr(s) + ' (' + str(len(s)) + ')'\n\n    def showDuplicate(cix):\n        c, ix = cix\n        return repr(c) + (\n            ' (' + hex(ord(c)) + ') at ' + repr(ix)\n        )\n\n    print(\n        fTable('First duplicated character, if any:')(\n            showSample\n        )(maybe('None')(showDuplicate))(duplicatedCharIndices)([\n            '', '.', 'abcABC', 'XYZ ZYX',\n            '1234567890ABCDEFGHIJKLMN0PQRSTUVWXYZ'\n        ])\n    )\n\n\n\n\n\n\ndef fTable(s):\n    \n    def go(xShow, fxShow, f, xs):\n        ys = [xShow(x) for x in xs]\n        w = max(map(len, ys))\n        return s + '\\n' + '\\n'.join(map(\n            lambda x, y: y.rjust(w, ' ') + ' -> ' + fxShow(f(x)),\n            xs, ys\n        ))\n    return lambda xShow: lambda fxShow: lambda f: lambda xs: go(\n        xShow, fxShow, f, xs\n    )\n\n\n\n\n\ndef Just(x):\n    \n    return {'type': 'Maybe', 'Nothing': False, 'Just': x}\n\n\n\ndef Nothing():\n    \n    return {'type': 'Maybe', 'Nothing': True}\n\n\n\ndef fmap(f):\n    \n    return lambda xs: [f(x) for x in xs]\n\n\n\ndef fst(tpl):\n    \n    return tpl[0]\n\n\n\ndef head(xs):\n    \n    return xs[0] if isinstance(xs, list) else next(xs)\n\n\n\ndef maybe(v):\n    \n    return lambda f: lambda m: v if (\n        None is m or m.get('Nothing')\n    ) else f(m.get('Just'))\n\n\n\ndef second(f):\n    \n    return lambda xy: (xy[0], f(xy[1]))\n\n\n\ndef snd(tpl):\n    \n    return tpl[1]\n\n\n\ndef swap(tpl):\n    \n    return (tpl[1], tpl[0])\n\n\n\nif __name__ == '__main__':\n    main()\n"}
{"id": 71565, "name": "Determine if a string has all unique characters", "source": "Translate Fortran to Python: program demo_verify\nimplicit none\n    call nodup('')\n    call nodup('.')\n    call nodup('abcABC')\n    call nodup('XYZ ZYX')\n    call nodup('1234567890ABCDEFGHIJKLMN0PQRSTUVWXYZ')\ncontains\n\nsubroutine nodup(str)\ncharacter(len=*),intent(in)  :: str\ncharacter(len=*),parameter   :: g='(*(g0))'\ncharacter(len=:),allocatable :: ch\ninteger                      :: where\ninteger                      :: i\n   where=0\n   ch=''\n\n   do i=1,len(str)-1\n      ch=str(i:i)\n      where=index(str(i+1:),ch)\n      if(where.ne.0)then\n         where=where+i\n         exit\n      endif\n   enddo\n\n   if(where.eq.0)then\n     write(*,g)'STR: \"',str,'\"',new_line('a'),'LEN: ',len(str),'. No duplicate characters found'\n   else\n     write(*,g)'STR: \"',str,'\"'\n     write(*,'(a,a,t1,a,a)')repeat(' ',where+5),'^',repeat(' ',i+5),'^'\n     write(*,g)'LEN: ',len(str), &\n     & '. Duplicate chars. First duplicate at positions ',i,' and ',where, &\n     & ' where a ','\"'//str(where:where)//'\"(hex:',hex(str(where:where)),') was found.'\n   endif\n   write(*,*)\n\nend subroutine nodup\n\nfunction hex(ch) result(hexstr)\ncharacter(len=1),intent(in) :: ch\ncharacter(len=:),allocatable :: hexstr\n   hexstr=repeat(' ',100)\n   write(hexstr,'(Z0)')ch\n   hexstr=trim(hexstr)\nend function hex\n\nend program demo_verify\n", "target": "\n\nfrom itertools import groupby\n\n\n\ndef duplicatedCharIndices(s):\n    \n    def go(xs):\n        if 1 < len(xs):\n            duplicates = list(filter(lambda kv: 1 < len(kv[1]), [\n                (k, list(v)) for k, v in groupby(\n                    sorted(xs, key=swap),\n                    key=snd\n                )\n            ]))\n            return Just(second(fmap(fst))(\n                sorted(\n                    duplicates,\n                    key=lambda kv: kv[1][0]\n                )[0]\n            )) if duplicates else Nothing()\n        else:\n            return Nothing()\n    return go(list(enumerate(s)))\n\n\n\n\ndef main():\n    \n\n    def showSample(s):\n        return repr(s) + ' (' + str(len(s)) + ')'\n\n    def showDuplicate(cix):\n        c, ix = cix\n        return repr(c) + (\n            ' (' + hex(ord(c)) + ') at ' + repr(ix)\n        )\n\n    print(\n        fTable('First duplicated character, if any:')(\n            showSample\n        )(maybe('None')(showDuplicate))(duplicatedCharIndices)([\n            '', '.', 'abcABC', 'XYZ ZYX',\n            '1234567890ABCDEFGHIJKLMN0PQRSTUVWXYZ'\n        ])\n    )\n\n\n\n\n\n\ndef fTable(s):\n    \n    def go(xShow, fxShow, f, xs):\n        ys = [xShow(x) for x in xs]\n        w = max(map(len, ys))\n        return s + '\\n' + '\\n'.join(map(\n            lambda x, y: y.rjust(w, ' ') + ' -> ' + fxShow(f(x)),\n            xs, ys\n        ))\n    return lambda xShow: lambda fxShow: lambda f: lambda xs: go(\n        xShow, fxShow, f, xs\n    )\n\n\n\n\n\ndef Just(x):\n    \n    return {'type': 'Maybe', 'Nothing': False, 'Just': x}\n\n\n\ndef Nothing():\n    \n    return {'type': 'Maybe', 'Nothing': True}\n\n\n\ndef fmap(f):\n    \n    return lambda xs: [f(x) for x in xs]\n\n\n\ndef fst(tpl):\n    \n    return tpl[0]\n\n\n\ndef head(xs):\n    \n    return xs[0] if isinstance(xs, list) else next(xs)\n\n\n\ndef maybe(v):\n    \n    return lambda f: lambda m: v if (\n        None is m or m.get('Nothing')\n    ) else f(m.get('Just'))\n\n\n\ndef second(f):\n    \n    return lambda xy: (xy[0], f(xy[1]))\n\n\n\ndef snd(tpl):\n    \n    return tpl[1]\n\n\n\ndef swap(tpl):\n    \n    return (tpl[1], tpl[0])\n\n\n\nif __name__ == '__main__':\n    main()\n"}
{"id": 71845, "name": "Combinations with repetitions", "source": "Translate Fortran to C#: program main\n\tinteger :: chosen(4)\n\tinteger :: ssize\n\t\n\tcharacter(len=50) :: donuts(4) = [ \"iced\", \"jam\", \"plain\", \"something completely different\" ]\n\t\n\tssize = choose( chosen, 2, 3 )\n\twrite(*,*) \"Total = \", ssize\n\t\n\tcontains\n\t\n\trecursive function choose( got, len, maxTypes, nChosen, at ) result ( output )\n\t\tinteger :: got(:)\n\t\tinteger :: len\n\t\tinteger :: maxTypes\n\t\tinteger :: output\n\t\tinteger, optional :: nChosen\n\t\tinteger, optional :: at\n\t\t\n\t\tinteger :: effNChosen\n\t\tinteger :: effAt\n\t\t\n\t\tinteger :: i\n\t\tinteger :: counter\n\t\t\n\t\teffNChosen = 1\n\t\tif( present(nChosen) ) effNChosen = nChosen\n\t\t\n\t\teffAt = 1\n\t\tif( present(at) ) effAt = at\n\t\t\n\t\tif ( effNChosen == len+1 ) then\n\t\t\tdo i=1,len\n\t\t\t\twrite(*,\"(A10,5X)\", advance='no') donuts( got(i)+1 )\n\t\t\tend do\n\t\t\t\n\t\t\twrite(*,*) \"\"\n\t\t\t\n\t\t\toutput = 1\n\t\t\treturn\n\t\tend if\n\t\t\n\t\tcounter = 0\n\t\tdo i=effAt,maxTypes\n\t\t\tgot(effNChosen) = i-1\n\t\t\tcounter = counter + choose( got, len, maxTypes, effNChosen + 1, i )\n\t\tend do\n\t\t\n\t\toutput = counter\n\t\treturn\n\tend function choose\n\nend program main\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\npublic static class MultiCombinations\n{\n    private static void Main()\n    {\n        var set = new List<string> { \"iced\", \"jam\", \"plain\" };\n        var combinations = GenerateCombinations(set, 2);\n\n        foreach (var combination in combinations)\n        {\n            string combinationStr = string.Join(\" \", combination);\n            Console.WriteLine(combinationStr);\n        }\n\n        var donuts = Enumerable.Range(1, 10).ToList();\n\n        int donutsCombinationsNumber = GenerateCombinations(donuts, 3).Count;\n\n        Console.WriteLine(\"{0} ways to order 3 donuts given 10 types\", donutsCombinationsNumber);\n    }\n    \n    private static List<List<T>> GenerateCombinations<T>(List<T> combinationList, int k)\n    {\n        var combinations = new List<List<T>>();\n\n        if (k == 0)\n        {\n            var emptyCombination = new List<T>();\n            combinations.Add(emptyCombination);\n\n            return combinations;\n        }\n\n        if (combinationList.Count == 0)\n        {\n            return combinations;\n        }\n\n        T head = combinationList[0];\n        var copiedCombinationList = new List<T>(combinationList);\n        \n        List<List<T>> subcombinations = GenerateCombinations(copiedCombinationList, k - 1);\n\n        foreach (var subcombination in subcombinations)\n        {\n            subcombination.Insert(0, head);\n            combinations.Add(subcombination);\n        }\n\n        combinationList.RemoveAt(0);\n        combinations.AddRange(GenerateCombinations(combinationList, k));\n\n        return combinations;\n    }\n}\n"}
{"id": 71848, "name": "Combinations with repetitions", "source": "Translate Fortran to Java: program main\n\tinteger :: chosen(4)\n\tinteger :: ssize\n\t\n\tcharacter(len=50) :: donuts(4) = [ \"iced\", \"jam\", \"plain\", \"something completely different\" ]\n\t\n\tssize = choose( chosen, 2, 3 )\n\twrite(*,*) \"Total = \", ssize\n\t\n\tcontains\n\t\n\trecursive function choose( got, len, maxTypes, nChosen, at ) result ( output )\n\t\tinteger :: got(:)\n\t\tinteger :: len\n\t\tinteger :: maxTypes\n\t\tinteger :: output\n\t\tinteger, optional :: nChosen\n\t\tinteger, optional :: at\n\t\t\n\t\tinteger :: effNChosen\n\t\tinteger :: effAt\n\t\t\n\t\tinteger :: i\n\t\tinteger :: counter\n\t\t\n\t\teffNChosen = 1\n\t\tif( present(nChosen) ) effNChosen = nChosen\n\t\t\n\t\teffAt = 1\n\t\tif( present(at) ) effAt = at\n\t\t\n\t\tif ( effNChosen == len+1 ) then\n\t\t\tdo i=1,len\n\t\t\t\twrite(*,\"(A10,5X)\", advance='no') donuts( got(i)+1 )\n\t\t\tend do\n\t\t\t\n\t\t\twrite(*,*) \"\"\n\t\t\t\n\t\t\toutput = 1\n\t\t\treturn\n\t\tend if\n\t\t\n\t\tcounter = 0\n\t\tdo i=effAt,maxTypes\n\t\t\tgot(effNChosen) = i-1\n\t\t\tcounter = counter + choose( got, len, maxTypes, effNChosen + 1, i )\n\t\tend do\n\t\t\n\t\toutput = counter\n\t\treturn\n\tend function choose\n\nend program main\n", "target": "import com.objectwave.utility.*;\n\npublic class MultiCombinationsTester {\n\n    public MultiCombinationsTester() throws CombinatoricException {\n        Object[] objects = {\"iced\", \"jam\", \"plain\"};\n        \n        \n        \n        MultiCombinations mc = new MultiCombinations(objects, 2);\n        while (mc.hasMoreElements()) {\n            for (int i = 0; i < mc.nextElement().length; i++) {\n                System.out.print(mc.nextElement()[i].toString() + \" \");\n            }\n            System.out.println();\n        }\n\n        \n        System.out.println(\"----------\");\n        System.out.println(\"The ways to choose 3 items from 10 with replacement = \" + MultiCombinations.c(10, 3));\n    } \n\n    public static void main(String[] args) throws CombinatoricException {\n        new MultiCombinationsTester();\n    }\n} \n"}
{"id": 71849, "name": "Combinations with repetitions", "source": "Translate Fortran to Python: program main\n\tinteger :: chosen(4)\n\tinteger :: ssize\n\t\n\tcharacter(len=50) :: donuts(4) = [ \"iced\", \"jam\", \"plain\", \"something completely different\" ]\n\t\n\tssize = choose( chosen, 2, 3 )\n\twrite(*,*) \"Total = \", ssize\n\t\n\tcontains\n\t\n\trecursive function choose( got, len, maxTypes, nChosen, at ) result ( output )\n\t\tinteger :: got(:)\n\t\tinteger :: len\n\t\tinteger :: maxTypes\n\t\tinteger :: output\n\t\tinteger, optional :: nChosen\n\t\tinteger, optional :: at\n\t\t\n\t\tinteger :: effNChosen\n\t\tinteger :: effAt\n\t\t\n\t\tinteger :: i\n\t\tinteger :: counter\n\t\t\n\t\teffNChosen = 1\n\t\tif( present(nChosen) ) effNChosen = nChosen\n\t\t\n\t\teffAt = 1\n\t\tif( present(at) ) effAt = at\n\t\t\n\t\tif ( effNChosen == len+1 ) then\n\t\t\tdo i=1,len\n\t\t\t\twrite(*,\"(A10,5X)\", advance='no') donuts( got(i)+1 )\n\t\t\tend do\n\t\t\t\n\t\t\twrite(*,*) \"\"\n\t\t\t\n\t\t\toutput = 1\n\t\t\treturn\n\t\tend if\n\t\t\n\t\tcounter = 0\n\t\tdo i=effAt,maxTypes\n\t\t\tgot(effNChosen) = i-1\n\t\t\tcounter = counter + choose( got, len, maxTypes, effNChosen + 1, i )\n\t\tend do\n\t\t\n\t\toutput = counter\n\t\treturn\n\tend function choose\n\nend program main\n", "target": ">>> from itertools import combinations_with_replacement\n>>> n, k = 'iced jam plain'.split(), 2\n>>> list(combinations_with_replacement(n,k))\n[('iced', 'iced'), ('iced', 'jam'), ('iced', 'plain'), ('jam', 'jam'), ('jam', 'plain'), ('plain', 'plain')]\n>>> \n>>> len(list(combinations_with_replacement(range(10), 3)))\n220\n>>>\n"}
{"id": 72120, "name": "Multiple distinct objects", "source": "Translate Fortran to C#: program multiple\n  \n  type T\n     integer :: a = 3\n  end type T\n\n  \n  type S\n     integer, pointer :: a\n  end type S\n\n  type(T), allocatable :: T_array(:)\n  type(S), allocatable :: S_same(:)\n  integer              :: i\n  integer, target      :: v\n  integer, parameter   :: N = 10\n\n  \n  allocate(T_array(N))\n\n  \n  T_array(5)%a = 1\n\n  \n  write(*,'(10i2)') (T_array(i),i=1,N)\n\n  \n  allocate(S_same(N))\n  v = 5\n  do i=1, N\n     allocate(S_same(i)%a)\n     S_same(i)%a => v\n  end do\n\n  \n  write(*,'(10i2)') (S_same(i)%a,i=1,N)\n\n  \n  v = 3\n  write(*,'(10i2)') (S_same(i)%a,i=1,N)  \n\nend program multiple\n", "target": "using System;\nusing System.Linq;\nusing System.Collections.Generic;\n\nList<Foo> foos = Enumerable.Range(1, n).Select(x => new Foo()).ToList();\n"}
{"id": 72121, "name": "Multiple distinct objects", "source": "Translate Fortran to C#: program multiple\n  \n  type T\n     integer :: a = 3\n  end type T\n\n  \n  type S\n     integer, pointer :: a\n  end type S\n\n  type(T), allocatable :: T_array(:)\n  type(S), allocatable :: S_same(:)\n  integer              :: i\n  integer, target      :: v\n  integer, parameter   :: N = 10\n\n  \n  allocate(T_array(N))\n\n  \n  T_array(5)%a = 1\n\n  \n  write(*,'(10i2)') (T_array(i),i=1,N)\n\n  \n  allocate(S_same(N))\n  v = 5\n  do i=1, N\n     allocate(S_same(i)%a)\n     S_same(i)%a => v\n  end do\n\n  \n  write(*,'(10i2)') (S_same(i)%a,i=1,N)\n\n  \n  v = 3\n  write(*,'(10i2)') (S_same(i)%a,i=1,N)  \n\nend program multiple\n", "target": "using System;\nusing System.Linq;\nusing System.Collections.Generic;\n\nList<Foo> foos = Enumerable.Range(1, n).Select(x => new Foo()).ToList();\n"}
{"id": 72127, "name": "Multiple distinct objects", "source": "Translate Fortran to Java: program multiple\n  \n  type T\n     integer :: a = 3\n  end type T\n\n  \n  type S\n     integer, pointer :: a\n  end type S\n\n  type(T), allocatable :: T_array(:)\n  type(S), allocatable :: S_same(:)\n  integer              :: i\n  integer, target      :: v\n  integer, parameter   :: N = 10\n\n  \n  allocate(T_array(N))\n\n  \n  T_array(5)%a = 1\n\n  \n  write(*,'(10i2)') (T_array(i),i=1,N)\n\n  \n  allocate(S_same(N))\n  v = 5\n  do i=1, N\n     allocate(S_same(i)%a)\n     S_same(i)%a => v\n  end do\n\n  \n  write(*,'(10i2)') (S_same(i)%a,i=1,N)\n\n  \n  v = 3\n  write(*,'(10i2)') (S_same(i)%a,i=1,N)  \n\nend program multiple\n", "target": "Foo[] foos = new Foo[n]; \nfor (int i = 0; i < foos.length; i++)\n    foos[i] = new Foo();\n\n\nFoo[] foos_WRONG = new Foo[n];\nArrays.fill(foos, new Foo());  \n"}
{"id": 72128, "name": "Multiple distinct objects", "source": "Translate Fortran to Java: program multiple\n  \n  type T\n     integer :: a = 3\n  end type T\n\n  \n  type S\n     integer, pointer :: a\n  end type S\n\n  type(T), allocatable :: T_array(:)\n  type(S), allocatable :: S_same(:)\n  integer              :: i\n  integer, target      :: v\n  integer, parameter   :: N = 10\n\n  \n  allocate(T_array(N))\n\n  \n  T_array(5)%a = 1\n\n  \n  write(*,'(10i2)') (T_array(i),i=1,N)\n\n  \n  allocate(S_same(N))\n  v = 5\n  do i=1, N\n     allocate(S_same(i)%a)\n     S_same(i)%a => v\n  end do\n\n  \n  write(*,'(10i2)') (S_same(i)%a,i=1,N)\n\n  \n  v = 3\n  write(*,'(10i2)') (S_same(i)%a,i=1,N)  \n\nend program multiple\n", "target": "Foo[] foos = new Foo[n]; \nfor (int i = 0; i < foos.length; i++)\n    foos[i] = new Foo();\n\n\nFoo[] foos_WRONG = new Foo[n];\nArrays.fill(foos, new Foo());  \n"}
{"id": 72129, "name": "Multiple distinct objects", "source": "Translate Fortran to Python: program multiple\n  \n  type T\n     integer :: a = 3\n  end type T\n\n  \n  type S\n     integer, pointer :: a\n  end type S\n\n  type(T), allocatable :: T_array(:)\n  type(S), allocatable :: S_same(:)\n  integer              :: i\n  integer, target      :: v\n  integer, parameter   :: N = 10\n\n  \n  allocate(T_array(N))\n\n  \n  T_array(5)%a = 1\n\n  \n  write(*,'(10i2)') (T_array(i),i=1,N)\n\n  \n  allocate(S_same(N))\n  v = 5\n  do i=1, N\n     allocate(S_same(i)%a)\n     S_same(i)%a => v\n  end do\n\n  \n  write(*,'(10i2)') (S_same(i)%a,i=1,N)\n\n  \n  v = 3\n  write(*,'(10i2)') (S_same(i)%a,i=1,N)  \n\nend program multiple\n", "target": "[Foo()] * n \n"}
{"id": 72130, "name": "Multiple distinct objects", "source": "Translate Fortran to Python: program multiple\n  \n  type T\n     integer :: a = 3\n  end type T\n\n  \n  type S\n     integer, pointer :: a\n  end type S\n\n  type(T), allocatable :: T_array(:)\n  type(S), allocatable :: S_same(:)\n  integer              :: i\n  integer, target      :: v\n  integer, parameter   :: N = 10\n\n  \n  allocate(T_array(N))\n\n  \n  T_array(5)%a = 1\n\n  \n  write(*,'(10i2)') (T_array(i),i=1,N)\n\n  \n  allocate(S_same(N))\n  v = 5\n  do i=1, N\n     allocate(S_same(i)%a)\n     S_same(i)%a => v\n  end do\n\n  \n  write(*,'(10i2)') (S_same(i)%a,i=1,N)\n\n  \n  v = 3\n  write(*,'(10i2)') (S_same(i)%a,i=1,N)  \n\nend program multiple\n", "target": "[Foo()] * n \n"}
{"id": 72424, "name": "Five weekends", "source": "Translate Fortran to C#: program Five_weekends\n  implicit none\n\n  integer :: m, year, nfives = 0, not5 = 0\n  logical :: no5weekend\n\n  type month\n    integer :: n\n    character(3) :: name\n  end type month\n\n  type(month) :: month31(7)\n  \n  month31(1) = month(13, \"Jan\")\n  month31(2) = month(3,  \"Mar\")\n  month31(3) = month(5,  \"May\")\n  month31(4) = month(7,  \"Jul\")\n  month31(5) = month(8,  \"Aug\")\n  month31(6) = month(10, \"Oct\")\n  month31(7) = month(12, \"Dec\")\n\n  do year = 1900, 2100\n    no5weekend = .true.\n    do m = 1, size(month31)\n      if(month31(m)%n == 13) then\n        if(Day_of_week(1, month31(m)%n, year-1) == 6) then\n          write(*, \"(a3, i5)\") month31(m)%name, year\n          nfives = nfives + 1\n          no5weekend = .false.\n        end if\n      else \n        if(Day_of_week(1, month31(m)%n, year) == 6) then\n          write(*,\"(a3, i5)\") month31(m)%name, year\n          nfives = nfives + 1\n          no5weekend = .false.\n        end if\n      end if\n    end do\n    if(no5weekend) not5 = not5 + 1\n  end do\n  \n  write(*, \"(a, i0)\") \"Number of months with five weekends between 1900 and 2100 = \", nfives\n  write(*, \"(a, i0)\") \"Number of years between 1900 and 2100 with no five weekend months = \", not5\n  \ncontains\n \nfunction Day_of_week(d, m, y)\n  integer :: Day_of_week\n  integer, intent(in) :: d, m, y\n  integer :: j, k\n    \n  j = y / 100\n  k = mod(y, 100)\n  Day_of_week = mod(d + (m+1)*26/10 + k + k/4 + j/4 + 5*j, 7)\n  \nend function Day_of_week\nend program Five_weekends\n", "target": "using System;\n\nnamespace _5_Weekends\n{\n    class Program\n    {\n        const int FIRST_YEAR = 1900;\n        const int LAST_YEAR = 2100;\n        static int[] _31_MONTHS = { 1, 3, 5, 7, 8, 10, 12 }; \n\n        static void Main(string[] args)\n        {\n            int totalNum = 0;\n            int totalNo5Weekends = 0;\n\n            for (int year = FIRST_YEAR; year <= LAST_YEAR; year++)\n            {\n                bool has5Weekends = false;\n\n                foreach (int month in _31_MONTHS)\n                {\n                    DateTime firstDay = new DateTime(year, month, 1);\n                    if (firstDay.DayOfWeek == DayOfWeek.Friday)\n                    {\n                        totalNum++;\n                        has5Weekends = true;\n                        Console.WriteLine(firstDay.ToString(\"yyyy - MMMM\"));\n                    }\n                }\n\n                if (!has5Weekends) totalNo5Weekends++;\n            }\n            Console.WriteLine(\"Total 5-weekend months between {0} and {1}: {2}\", FIRST_YEAR, LAST_YEAR, totalNum);\n            Console.WriteLine(\"Total number of years with no 5-weekend months {0}\", totalNo5Weekends);\n        }\n    }\n}\n"}
{"id": 72427, "name": "Five weekends", "source": "Translate Fortran to Java: program Five_weekends\n  implicit none\n\n  integer :: m, year, nfives = 0, not5 = 0\n  logical :: no5weekend\n\n  type month\n    integer :: n\n    character(3) :: name\n  end type month\n\n  type(month) :: month31(7)\n  \n  month31(1) = month(13, \"Jan\")\n  month31(2) = month(3,  \"Mar\")\n  month31(3) = month(5,  \"May\")\n  month31(4) = month(7,  \"Jul\")\n  month31(5) = month(8,  \"Aug\")\n  month31(6) = month(10, \"Oct\")\n  month31(7) = month(12, \"Dec\")\n\n  do year = 1900, 2100\n    no5weekend = .true.\n    do m = 1, size(month31)\n      if(month31(m)%n == 13) then\n        if(Day_of_week(1, month31(m)%n, year-1) == 6) then\n          write(*, \"(a3, i5)\") month31(m)%name, year\n          nfives = nfives + 1\n          no5weekend = .false.\n        end if\n      else \n        if(Day_of_week(1, month31(m)%n, year) == 6) then\n          write(*,\"(a3, i5)\") month31(m)%name, year\n          nfives = nfives + 1\n          no5weekend = .false.\n        end if\n      end if\n    end do\n    if(no5weekend) not5 = not5 + 1\n  end do\n  \n  write(*, \"(a, i0)\") \"Number of months with five weekends between 1900 and 2100 = \", nfives\n  write(*, \"(a, i0)\") \"Number of years between 1900 and 2100 with no five weekend months = \", not5\n  \ncontains\n \nfunction Day_of_week(d, m, y)\n  integer :: Day_of_week\n  integer, intent(in) :: d, m, y\n  integer :: j, k\n    \n  j = y / 100\n  k = mod(y, 100)\n  Day_of_week = mod(d + (m+1)*26/10 + k + k/4 + j/4 + 5*j, 7)\n  \nend function Day_of_week\nend program Five_weekends\n", "target": "import java.util.Calendar;\nimport java.util.GregorianCalendar;\n\npublic class FiveFSS {\n    private static boolean[] years = new boolean[201];\n    private static int[] month31 = {Calendar.JANUARY, Calendar.MARCH, Calendar.MAY,\n        Calendar.JULY, Calendar.AUGUST, Calendar.OCTOBER, Calendar.DECEMBER};\n\n    public static void main(String[] args) {\n        StringBuilder months = new StringBuilder();\n        int numMonths = 0;\n        for (int year = 1900; year <= 2100; year++) {\n            for (int month : month31) {\n                Calendar date = new GregorianCalendar(year, month, 1);\n                if (date.get(Calendar.DAY_OF_WEEK) == Calendar.FRIDAY) {\n                    years[year - 1900] = true;\n                    numMonths++;\n                    \n                    months.append((date.get(Calendar.MONTH) + 1) + \"-\" + year +\"\\n\");\n                }\n            }\n        }\n        System.out.println(\"There are \"+numMonths+\" months with five weekends from 1900 through 2100:\");\n        System.out.println(months);\n        System.out.println(\"Years with no five-weekend months:\");\n        for (int year = 1900; year <= 2100; year++) {\n            if(!years[year - 1900]){\n                System.out.println(year);\n            }\n        }\n    }\n}\n"}
{"id": 72428, "name": "Five weekends", "source": "Translate Fortran to Python: program Five_weekends\n  implicit none\n\n  integer :: m, year, nfives = 0, not5 = 0\n  logical :: no5weekend\n\n  type month\n    integer :: n\n    character(3) :: name\n  end type month\n\n  type(month) :: month31(7)\n  \n  month31(1) = month(13, \"Jan\")\n  month31(2) = month(3,  \"Mar\")\n  month31(3) = month(5,  \"May\")\n  month31(4) = month(7,  \"Jul\")\n  month31(5) = month(8,  \"Aug\")\n  month31(6) = month(10, \"Oct\")\n  month31(7) = month(12, \"Dec\")\n\n  do year = 1900, 2100\n    no5weekend = .true.\n    do m = 1, size(month31)\n      if(month31(m)%n == 13) then\n        if(Day_of_week(1, month31(m)%n, year-1) == 6) then\n          write(*, \"(a3, i5)\") month31(m)%name, year\n          nfives = nfives + 1\n          no5weekend = .false.\n        end if\n      else \n        if(Day_of_week(1, month31(m)%n, year) == 6) then\n          write(*,\"(a3, i5)\") month31(m)%name, year\n          nfives = nfives + 1\n          no5weekend = .false.\n        end if\n      end if\n    end do\n    if(no5weekend) not5 = not5 + 1\n  end do\n  \n  write(*, \"(a, i0)\") \"Number of months with five weekends between 1900 and 2100 = \", nfives\n  write(*, \"(a, i0)\") \"Number of years between 1900 and 2100 with no five weekend months = \", not5\n  \ncontains\n \nfunction Day_of_week(d, m, y)\n  integer :: Day_of_week\n  integer, intent(in) :: d, m, y\n  integer :: j, k\n    \n  j = y / 100\n  k = mod(y, 100)\n  Day_of_week = mod(d + (m+1)*26/10 + k + k/4 + j/4 + 5*j, 7)\n  \nend function Day_of_week\nend program Five_weekends\n", "target": "from datetime import (date,\n                      timedelta)\n\nDAY = timedelta(days=1)\nSTART, STOP = date(1900, 1, 1), date(2101, 1, 1)\nWEEKEND = {6, 5, 4}  \nFMT = '%Y %m(%B)'\n\n\ndef five_weekends_per_month(start: date = START,\n                            stop: date = STOP) -> list[date]:\n    \n    current_date = start\n    last_month = weekend_days = 0\n    five_weekends = []\n    while current_date < stop:\n        if current_date.month != last_month:\n            if weekend_days >= 15:\n                five_weekends.append(current_date - DAY)\n            weekend_days = 0\n            last_month = current_date.month\n        if current_date.weekday() in WEEKEND:\n            weekend_days += 1\n        current_date += DAY\n    return five_weekends\n\n\ndates = five_weekends_per_month()\nindent = '  '\nprint(f\"There are {len(dates)} months of which the first and last five are:\")\nprint(indent + ('\\n' + indent).join(d.strftime(FMT) for d in dates[:5]))\nprint(indent + '...')\nprint(indent + ('\\n' + indent).join(d.strftime(FMT) for d in dates[-5:]))\n\nyears_without_five_weekends_months = (STOP.year - START.year\n                                      - len({d.year for d in dates}))\nprint(f\"\\nThere are {years_without_five_weekends_months} years in the \"\n      f\"range that do not have months with five weekends\")\n"}
{"id": 73425, "name": "Josephus problem", "source": "Translate Fortran to C#: program josephus\n   implicit none\n   integer :: n, i, k, p\n   integer, allocatable :: next(:)\n   read *, n, k\n   allocate(next(0:n - 1))\n   do i = 0, n - 2\n      next(i) = i + 1\n   end do\n   next(n - 1) = 0\n   p = 0\n   do while(next(p) /= p)\n      do i = 1, k - 2\n         p = next(p)\n      end do\n      print *, \"Kill\", next(p)\n      next(p) = next(next(p))\n      p = next(p)\n   end do\n   print *, \"Alive\", p\n   deallocate(next)\nend program\n", "target": "namespace Josephus\n{\n    using System;\n    using System.Collections;\n    using System.Collections.Generic;\n\n    public class Program\n    {\n        public static int[] JosephusProblem(int n, int m)\n        {\n            var circle = new List<int>();\n            var order = new int[n];\n\n            for (var i = 0; i < n; ++i)\n            {\n                circle.Add(i);\n            }\n\n            var l = 0;\n            var j = 0;\n            var k = 0;\n\n            while (circle.Count != 0)\n            {\n                j++;\n                if (j == m)\n                {\n                    order[k] = circle[l];\n                    circle.RemoveAt(l);\n\n                    k++;\n                    l--;\n                    j = 0;\n                }\n\n                if (k == n - 1)\n                {\n                    order[k] = circle[0];\n                    circle.RemoveAt(0);\n                }\n\n                if (l == circle.Count - 1)\n                {\n                    l = 0;\n                }\n                else\n                {\n                    l++;\n                }\n            }\n\n            return order;\n        }\n\n        static void Main(string[] args)\n        {\n            try\n            {\n                var n = 7;\n                var m = 2;\n\n                var result = JosephusProblem(n, m);\n\n               for (var i = 0; i < result.Length; i++)\n               {\n                   Console.WriteLine(result[i]);\n               }\n            }\n            catch (Exception e)\n            {\n                Console.WriteLine(e);\n            }\n            finally\n            {\n                Console.ReadLine();\n            }\n        }\n\n    }\n}\n"}
{"id": 73428, "name": "Josephus problem", "source": "Translate Fortran to Java: program josephus\n   implicit none\n   integer :: n, i, k, p\n   integer, allocatable :: next(:)\n   read *, n, k\n   allocate(next(0:n - 1))\n   do i = 0, n - 2\n      next(i) = i + 1\n   end do\n   next(n - 1) = 0\n   p = 0\n   do while(next(p) /= p)\n      do i = 1, k - 2\n         p = next(p)\n      end do\n      print *, \"Kill\", next(p)\n      next(p) = next(next(p))\n      p = next(p)\n   end do\n   print *, \"Alive\", p\n   deallocate(next)\nend program\n", "target": "import java.util.ArrayList;\n\npublic class Josephus {\n    public static int execute(int n, int k){\n        int killIdx = 0;\n        ArrayList<Integer> prisoners = new ArrayList<Integer>(n);\n        for(int i = 0;i < n;i++){\n            prisoners.add(i);\n        }\n        System.out.println(\"Prisoners executed in order:\");\n        while(prisoners.size() > 1){\n            killIdx = (killIdx + k - 1) % prisoners.size();\n            System.out.print(prisoners.get(killIdx) + \" \");\n            prisoners.remove(killIdx);\n        }\n        System.out.println();\n        return prisoners.get(0);\n    }\n    \n    public static ArrayList<Integer> executeAllButM(int n, int k, int m){\n        int killIdx = 0;\n        ArrayList<Integer> prisoners = new ArrayList<Integer>(n);\n        for(int i = 0;i < n;i++){\n            prisoners.add(i);\n        }\n        System.out.println(\"Prisoners executed in order:\");\n        while(prisoners.size() > m){\n            killIdx = (killIdx + k - 1) % prisoners.size();\n            System.out.print(prisoners.get(killIdx) + \" \");\n            prisoners.remove(killIdx);\n        }\n        System.out.println();\n        return prisoners;\n    }\n    \n    public static void main(String[] args){\n        System.out.println(\"Survivor: \" + execute(41, 3));\n        System.out.println(\"Survivors: \" + executeAllButM(41, 3, 3));\n    }\n}\n"}
{"id": 73429, "name": "Josephus problem", "source": "Translate Fortran to Python: program josephus\n   implicit none\n   integer :: n, i, k, p\n   integer, allocatable :: next(:)\n   read *, n, k\n   allocate(next(0:n - 1))\n   do i = 0, n - 2\n      next(i) = i + 1\n   end do\n   next(n - 1) = 0\n   p = 0\n   do while(next(p) /= p)\n      do i = 1, k - 2\n         p = next(p)\n      end do\n      print *, \"Kill\", next(p)\n      next(p) = next(next(p))\n      p = next(p)\n   end do\n   print *, \"Alive\", p\n   deallocate(next)\nend program\n", "target": ">>> def j(n, k):\n\tp, i, seq = list(range(n)), 0, []\n\twhile p:\n\t\ti = (i+k-1) % len(p)\n\t\tseq.append(p.pop(i))\n\treturn 'Prisoner killing order: %s.\\nSurvivor: %i' % (', '.join(str(i) for i in seq[:-1]), seq[-1])\n\n>>> print(j(5, 2))\nPrisoner killing order: 1, 3, 0, 4.\nSurvivor: 2\n>>> print(j(41, 3))\nPrisoner killing order: 2, 5, 8, 11, 14, 17, 20, 23, 26, 29, 32, 35, 38, 0, 4, 9, 13, 18, 22, 27, 31, 36, 40, 6, 12, 19, 25, 33, 39, 7, 16, 28, 37, 10, 24, 1, 21, 3, 34, 15.\nSurvivor: 30\n>>>\n"}
{"id": 73640, "name": "Pathological floating point problems", "source": "Translate Fortran to C#:       SUBROUTINE MULLER\n       REAL*4 VN,VNL1,VNL2\t\n       REAL*8 WN,WNL1,WNL2\t\n       INTEGER I\t\t\n        WRITE (6,1)\t\t\n    1   FORMAT (\"Muller's sequence should converge to six...\",/\n     1   \"  N     Single      Double\")\n        VNL1 = 2; VN = -4\t\n        WNL1 = 2; WN = -4\t\n        DO I = 3,36\t\t\t\n          VNL2 = VNL1; VNL1 = VN\t\t\n          WNL2 = WNL1; WNL1 = WN\t\t\n          VN = 111 - 1130/VNL1 + 3000/(VNL1*VNL2)\t\n          WN = 111 - 1130/WNL1 + 3000/(WNL1*WNL2)\t\n          WRITE (6,2) I,VN,WN\t\t\t\n    2     FORMAT (I3,F12.7,F21.16)\t\t\n        END DO\t\t\t\t\n      END SUBROUTINE MULLER\t\n\n      SUBROUTINE CBS\t\t\n       INTEGER YEAR\t\n       REAL*4 V\t\t\n       REAL*8 W\t\t\n        V = 1; W = 1\t\t\n        V = EXP(V) - 1\t\t\n        W = EXP(W) - 1\t\t\n        WRITE (6,1)\t\t\n    1   FORMAT (///\"The Chaotic Bank Society in action...\"/\"Year\")\n        WRITE (6,2) 0,V,W\t\n    2   FORMAT (I3,F16.7,F28.16)\n        DO YEAR = 1,25\t\t\n          V = V*YEAR - 1\t\n          W = W*YEAR - 1\t\n          WRITE (6,2) YEAR,V,W\t\n        END DO\t\t\t\n      END SUBROUTINE CBS\t\n\n      REAL*4 FUNCTION SR4(A,B)\t\n       REAL*4 A,B\n        SR4 = 333.75*B**6\n     1      + A**2*(11*A**2*B**2 - B**6 - 121*B**4 - 2)\n     2      + 5.5*B**8 + A/(2*B)\n      END FUNCTION SR4\n      REAL*8 FUNCTION SR8(A,B)\t\n       REAL*8 A,B\n        SR8 = 333.75*B**6\t\n     1      + A**2*(11*A**2*B**2 - B**6 - 121*B**4 - 2)\n     2      + 5.5*B**8 + A/(2*B)\n      END FUNCTION SR8\n\n      PROGRAM POKE\n      REAL*4 V\t\n      REAL*8 W\t\n      WRITE (6,1) RADIX(V),DIGITS(V),\"single\",DIGITS(W),\"double\"\n    1   FORMAT (\"Floating-point arithmetic is conducted in base \",I0,/\n     1   2(I3,\" digits for \",A,\" precision\",/))\n      WRITE (6,*) \"Single precision limit\",HUGE(V)\n      WRITE (6,*) \"Double precision limit\",HUGE(W)\n      WRITE (6,*)\n\n      CALL MULLER\n\n      CALL CBS\n\n      WRITE (6,10)\n   10 FORMAT (///\"Evaluation of Siegfried Rump's function of 1988\",\n     1 \" where F(77617,33096) = -0.827396059946821\")\n      WRITE (6,*) \"Single precision:\",SR4(77617.0,33096.0)\n      WRITE (6,*) \"Double precision:\",SR8(77617.0D0,33096.0D0)\t\n      END\n", "target": "#define USE_BIGRATIONAL\n#define BANDED_ROWS\n#define INCREASED_LIMITS\n\nusing System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\nusing System.Globalization;\nusing System.Linq;\nusing System.Numerics;\nusing Numerics;\n\nusing static Common;\nusing static Task1;\nusing static Task2;\nusing static Task3;\n\n#if !USE_BIGRATIONAL\n\nstruct BigRational\n{\n    public override string ToString() => \"NOT USING BIGRATIONAL\";\n    public static explicit operator decimal(BigRational value) => -1;\n}\n#endif\n\nstatic class Common\n{\n    public const string FMT_STR = \"{0,4}   {1,-15:G9}   {2,-24:G17}   {3,-32}   {4,-32}\";\n    public static string Headings { get; } =\n        string.Format(\n            CultureInfo.InvariantCulture,\n            FMT_STR,\n            new[] { \"N\", \"Single\", \"Double\", \"Decimal\", \"BigRational (rounded as Decimal)\" });\n\n    [Conditional(\"BANDED_ROWS\")]\n    static void SetConsoleFormat(int n)\n    {\n        if (n % 2 == 0)\n        {\n            Console.BackgroundColor = ConsoleColor.Black;\n            Console.ForegroundColor = ConsoleColor.White;\n        }\n        else\n        {\n            Console.BackgroundColor = ConsoleColor.White;\n            Console.ForegroundColor = ConsoleColor.Black;\n        }\n    }\n\n    public static string FormatOutput(int n, (float sn, double db, decimal dm, BigRational br) x)\n    {\n        SetConsoleFormat(n);\n        return string.Format(CultureInfo.CurrentCulture, FMT_STR, n, x.sn, x.db, x.dm, (decimal)x.br);\n    }\n\n    static void Main()\n    {\n        WrongConvergence();\n\n        Console.WriteLine();\n        ChaoticBankSociety();\n\n        Console.WriteLine();\n        SiegfriedRump();\n\n        SetConsoleFormat(0);\n    }\n}\n"}
{"id": 73641, "name": "Pathological floating point problems", "source": "Translate Fortran to C#:       SUBROUTINE MULLER\n       REAL*4 VN,VNL1,VNL2\t\n       REAL*8 WN,WNL1,WNL2\t\n       INTEGER I\t\t\n        WRITE (6,1)\t\t\n    1   FORMAT (\"Muller's sequence should converge to six...\",/\n     1   \"  N     Single      Double\")\n        VNL1 = 2; VN = -4\t\n        WNL1 = 2; WN = -4\t\n        DO I = 3,36\t\t\t\n          VNL2 = VNL1; VNL1 = VN\t\t\n          WNL2 = WNL1; WNL1 = WN\t\t\n          VN = 111 - 1130/VNL1 + 3000/(VNL1*VNL2)\t\n          WN = 111 - 1130/WNL1 + 3000/(WNL1*WNL2)\t\n          WRITE (6,2) I,VN,WN\t\t\t\n    2     FORMAT (I3,F12.7,F21.16)\t\t\n        END DO\t\t\t\t\n      END SUBROUTINE MULLER\t\n\n      SUBROUTINE CBS\t\t\n       INTEGER YEAR\t\n       REAL*4 V\t\t\n       REAL*8 W\t\t\n        V = 1; W = 1\t\t\n        V = EXP(V) - 1\t\t\n        W = EXP(W) - 1\t\t\n        WRITE (6,1)\t\t\n    1   FORMAT (///\"The Chaotic Bank Society in action...\"/\"Year\")\n        WRITE (6,2) 0,V,W\t\n    2   FORMAT (I3,F16.7,F28.16)\n        DO YEAR = 1,25\t\t\n          V = V*YEAR - 1\t\n          W = W*YEAR - 1\t\n          WRITE (6,2) YEAR,V,W\t\n        END DO\t\t\t\n      END SUBROUTINE CBS\t\n\n      REAL*4 FUNCTION SR4(A,B)\t\n       REAL*4 A,B\n        SR4 = 333.75*B**6\n     1      + A**2*(11*A**2*B**2 - B**6 - 121*B**4 - 2)\n     2      + 5.5*B**8 + A/(2*B)\n      END FUNCTION SR4\n      REAL*8 FUNCTION SR8(A,B)\t\n       REAL*8 A,B\n        SR8 = 333.75*B**6\t\n     1      + A**2*(11*A**2*B**2 - B**6 - 121*B**4 - 2)\n     2      + 5.5*B**8 + A/(2*B)\n      END FUNCTION SR8\n\n      PROGRAM POKE\n      REAL*4 V\t\n      REAL*8 W\t\n      WRITE (6,1) RADIX(V),DIGITS(V),\"single\",DIGITS(W),\"double\"\n    1   FORMAT (\"Floating-point arithmetic is conducted in base \",I0,/\n     1   2(I3,\" digits for \",A,\" precision\",/))\n      WRITE (6,*) \"Single precision limit\",HUGE(V)\n      WRITE (6,*) \"Double precision limit\",HUGE(W)\n      WRITE (6,*)\n\n      CALL MULLER\n\n      CALL CBS\n\n      WRITE (6,10)\n   10 FORMAT (///\"Evaluation of Siegfried Rump's function of 1988\",\n     1 \" where F(77617,33096) = -0.827396059946821\")\n      WRITE (6,*) \"Single precision:\",SR4(77617.0,33096.0)\n      WRITE (6,*) \"Double precision:\",SR8(77617.0D0,33096.0D0)\t\n      END\n", "target": "#define USE_BIGRATIONAL\n#define BANDED_ROWS\n#define INCREASED_LIMITS\n\nusing System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\nusing System.Globalization;\nusing System.Linq;\nusing System.Numerics;\nusing Numerics;\n\nusing static Common;\nusing static Task1;\nusing static Task2;\nusing static Task3;\n\n#if !USE_BIGRATIONAL\n\nstruct BigRational\n{\n    public override string ToString() => \"NOT USING BIGRATIONAL\";\n    public static explicit operator decimal(BigRational value) => -1;\n}\n#endif\n\nstatic class Common\n{\n    public const string FMT_STR = \"{0,4}   {1,-15:G9}   {2,-24:G17}   {3,-32}   {4,-32}\";\n    public static string Headings { get; } =\n        string.Format(\n            CultureInfo.InvariantCulture,\n            FMT_STR,\n            new[] { \"N\", \"Single\", \"Double\", \"Decimal\", \"BigRational (rounded as Decimal)\" });\n\n    [Conditional(\"BANDED_ROWS\")]\n    static void SetConsoleFormat(int n)\n    {\n        if (n % 2 == 0)\n        {\n            Console.BackgroundColor = ConsoleColor.Black;\n            Console.ForegroundColor = ConsoleColor.White;\n        }\n        else\n        {\n            Console.BackgroundColor = ConsoleColor.White;\n            Console.ForegroundColor = ConsoleColor.Black;\n        }\n    }\n\n    public static string FormatOutput(int n, (float sn, double db, decimal dm, BigRational br) x)\n    {\n        SetConsoleFormat(n);\n        return string.Format(CultureInfo.CurrentCulture, FMT_STR, n, x.sn, x.db, x.dm, (decimal)x.br);\n    }\n\n    static void Main()\n    {\n        WrongConvergence();\n\n        Console.WriteLine();\n        ChaoticBankSociety();\n\n        Console.WriteLine();\n        SiegfriedRump();\n\n        SetConsoleFormat(0);\n    }\n}\n"}
{"id": 73644, "name": "Pathological floating point problems", "source": "Translate Fortran to Java:       SUBROUTINE MULLER\n       REAL*4 VN,VNL1,VNL2\t\n       REAL*8 WN,WNL1,WNL2\t\n       INTEGER I\t\t\n        WRITE (6,1)\t\t\n    1   FORMAT (\"Muller's sequence should converge to six...\",/\n     1   \"  N     Single      Double\")\n        VNL1 = 2; VN = -4\t\n        WNL1 = 2; WN = -4\t\n        DO I = 3,36\t\t\t\n          VNL2 = VNL1; VNL1 = VN\t\t\n          WNL2 = WNL1; WNL1 = WN\t\t\n          VN = 111 - 1130/VNL1 + 3000/(VNL1*VNL2)\t\n          WN = 111 - 1130/WNL1 + 3000/(WNL1*WNL2)\t\n          WRITE (6,2) I,VN,WN\t\t\t\n    2     FORMAT (I3,F12.7,F21.16)\t\t\n        END DO\t\t\t\t\n      END SUBROUTINE MULLER\t\n\n      SUBROUTINE CBS\t\t\n       INTEGER YEAR\t\n       REAL*4 V\t\t\n       REAL*8 W\t\t\n        V = 1; W = 1\t\t\n        V = EXP(V) - 1\t\t\n        W = EXP(W) - 1\t\t\n        WRITE (6,1)\t\t\n    1   FORMAT (///\"The Chaotic Bank Society in action...\"/\"Year\")\n        WRITE (6,2) 0,V,W\t\n    2   FORMAT (I3,F16.7,F28.16)\n        DO YEAR = 1,25\t\t\n          V = V*YEAR - 1\t\n          W = W*YEAR - 1\t\n          WRITE (6,2) YEAR,V,W\t\n        END DO\t\t\t\n      END SUBROUTINE CBS\t\n\n      REAL*4 FUNCTION SR4(A,B)\t\n       REAL*4 A,B\n        SR4 = 333.75*B**6\n     1      + A**2*(11*A**2*B**2 - B**6 - 121*B**4 - 2)\n     2      + 5.5*B**8 + A/(2*B)\n      END FUNCTION SR4\n      REAL*8 FUNCTION SR8(A,B)\t\n       REAL*8 A,B\n        SR8 = 333.75*B**6\t\n     1      + A**2*(11*A**2*B**2 - B**6 - 121*B**4 - 2)\n     2      + 5.5*B**8 + A/(2*B)\n      END FUNCTION SR8\n\n      PROGRAM POKE\n      REAL*4 V\t\n      REAL*8 W\t\n      WRITE (6,1) RADIX(V),DIGITS(V),\"single\",DIGITS(W),\"double\"\n    1   FORMAT (\"Floating-point arithmetic is conducted in base \",I0,/\n     1   2(I3,\" digits for \",A,\" precision\",/))\n      WRITE (6,*) \"Single precision limit\",HUGE(V)\n      WRITE (6,*) \"Double precision limit\",HUGE(W)\n      WRITE (6,*)\n\n      CALL MULLER\n\n      CALL CBS\n\n      WRITE (6,10)\n   10 FORMAT (///\"Evaluation of Siegfried Rump's function of 1988\",\n     1 \" where F(77617,33096) = -0.827396059946821\")\n      WRITE (6,*) \"Single precision:\",SR4(77617.0,33096.0)\n      WRITE (6,*) \"Double precision:\",SR8(77617.0D0,33096.0D0)\t\n      END\n", "target": "import java.math.BigDecimal;\nimport java.math.RoundingMode;\n\npublic class FPProblems {\n    public static void wrongConvergence() {\n        int[] INDEXES = new int[] { 3, 4, 5, 6, 7, 8, 20, 30, 50, 100 };\n        \n        \n        double[] fpValues = new double[100];\n        fpValues[0] = 2.0;\n        fpValues[1] = -4.0;\n        for (int i = 2; i < fpValues.length; i++) {\n            fpValues[i] = 111.0 - 1130.0 / fpValues[i - 1] + 3000.0 / (fpValues[i - 1] * fpValues[i - 2]);\n        }\n        \n        \n        BigRational[] brValues = new BigRational[100];\n        brValues[0] = BigRational.valueOf(2);\n        brValues[1] = BigRational.valueOf(-4);\n        for (int i = 2; i < brValues.length; i++) {\n            \n            BigRational clause2 = BigRational.valueOf(1130).divide(brValues[i - 1]);\n            BigRational clause3 = BigRational.valueOf(3000).divide(brValues[i - 1].multiply(brValues[i - 2]));\n            brValues[i] = BigRational.valueOf(111).subtract(clause2).add(clause3);\n        }\n        \n        System.out.println(\"Wrong Convergence Sequence\");\n        for (int n : INDEXES) {\n            BigDecimal value = brValues[n - 1].toBigDecimal(16, RoundingMode.HALF_UP);\n            System.out.println(\"  For index \" + n + \", FP value is \" + fpValues[n - 1] + \", and rounded BigRational value is \" + value.toPlainString());\n        }\n        \n        return;\n    }\n    \n    public static void chaoticBankSociety() {\n        System.out.println(\"Chaotic Bank Society\");\n        double balance = Math.E - 1.0;\n        \n        \n        BigRational e = BigRational.ONE;\n        BigRational d = BigRational.ONE;\n        for (int i = 1; i < 1000; i++) {\n            d = d.multiply(BigRational.valueOf(i));\n            e = e.add(d.reciprocal());\n        }\n        System.out.println(\"DEBUG: e=\" + e.toBigDecimal(100, RoundingMode.HALF_UP).toPlainString());\n        \n        \n        \n        \n        BigRational brBalance = e.subtract(BigRational.ONE);\n        for (int year = 1; year <= 25; year++) {\n            balance = (balance * year) - 1.0;\n            brBalance = brBalance.multiply(BigRational.valueOf(year)).subtract(BigRational.ONE);\n            BigDecimal bdValue = brBalance.toBigDecimal(16, RoundingMode.HALF_UP);\n            System.out.println(\"  Year=\" + year + \", FP balance=\" + balance + \", BigRational balance=\" + bdValue.toPlainString());\n        }\n    }\n    \n    public static void siegfriedRump() {\n        System.out.println(\"Siegfried Rump formula\");\n        double fpValue;\n        {\n            double a = 77617.0;\n            double b = 33096.0;\n            fpValue = 333.75 * Math.pow(b, 6) + a * a * (11.0 * a * a * b * b - Math.pow(b, 6) - 121.0 * Math.pow(b, 4) - 2.0) + 5.5 * Math.pow(b, 8) + a / (2.0 * b);\n        }\n        \n        BigRational brValue;\n        {\n            BigRational a = BigRational.valueOf(77617);\n            BigRational b = BigRational.valueOf(33096);\n            BigRational clause1 = BigRational.valueOf(333.75).multiply(b.pow(6));\n            BigRational clause2a = BigRational.valueOf(11).multiply(a).multiply(a).multiply(b).multiply(b);\n            BigRational clause2b = b.pow(6).add(BigRational.valueOf(121).multiply(b.pow(4))).add(BigRational.valueOf(2));\n            BigRational clause2 = a.multiply(a).multiply(clause2a.subtract(clause2b));\n            BigRational clause3 = BigRational.valueOf(5.5).multiply(b.pow(8));\n            BigRational clause4 = a.divide(b.multiply(BigRational.valueOf(2)));\n            brValue = clause1.add(clause2).add(clause3).add(clause4);\n        }\n        \n        System.out.println(\"  FP value is \" + fpValue);\n        System.out.println(\"  BigRational rounded value is \" + brValue.toBigDecimal(64, RoundingMode.HALF_UP).toPlainString());\n        System.out.println(\"  BigRational full value is \" + brValue.toString());\n    }\n    \n    public static void main(String... args) {\n        wrongConvergence();\n        \n        System.out.println();\n        chaoticBankSociety();\n\n        System.out.println();\n        siegfriedRump();\n    }\n}\n"}
{"id": 73645, "name": "Pathological floating point problems", "source": "Translate Fortran to Java:       SUBROUTINE MULLER\n       REAL*4 VN,VNL1,VNL2\t\n       REAL*8 WN,WNL1,WNL2\t\n       INTEGER I\t\t\n        WRITE (6,1)\t\t\n    1   FORMAT (\"Muller's sequence should converge to six...\",/\n     1   \"  N     Single      Double\")\n        VNL1 = 2; VN = -4\t\n        WNL1 = 2; WN = -4\t\n        DO I = 3,36\t\t\t\n          VNL2 = VNL1; VNL1 = VN\t\t\n          WNL2 = WNL1; WNL1 = WN\t\t\n          VN = 111 - 1130/VNL1 + 3000/(VNL1*VNL2)\t\n          WN = 111 - 1130/WNL1 + 3000/(WNL1*WNL2)\t\n          WRITE (6,2) I,VN,WN\t\t\t\n    2     FORMAT (I3,F12.7,F21.16)\t\t\n        END DO\t\t\t\t\n      END SUBROUTINE MULLER\t\n\n      SUBROUTINE CBS\t\t\n       INTEGER YEAR\t\n       REAL*4 V\t\t\n       REAL*8 W\t\t\n        V = 1; W = 1\t\t\n        V = EXP(V) - 1\t\t\n        W = EXP(W) - 1\t\t\n        WRITE (6,1)\t\t\n    1   FORMAT (///\"The Chaotic Bank Society in action...\"/\"Year\")\n        WRITE (6,2) 0,V,W\t\n    2   FORMAT (I3,F16.7,F28.16)\n        DO YEAR = 1,25\t\t\n          V = V*YEAR - 1\t\n          W = W*YEAR - 1\t\n          WRITE (6,2) YEAR,V,W\t\n        END DO\t\t\t\n      END SUBROUTINE CBS\t\n\n      REAL*4 FUNCTION SR4(A,B)\t\n       REAL*4 A,B\n        SR4 = 333.75*B**6\n     1      + A**2*(11*A**2*B**2 - B**6 - 121*B**4 - 2)\n     2      + 5.5*B**8 + A/(2*B)\n      END FUNCTION SR4\n      REAL*8 FUNCTION SR8(A,B)\t\n       REAL*8 A,B\n        SR8 = 333.75*B**6\t\n     1      + A**2*(11*A**2*B**2 - B**6 - 121*B**4 - 2)\n     2      + 5.5*B**8 + A/(2*B)\n      END FUNCTION SR8\n\n      PROGRAM POKE\n      REAL*4 V\t\n      REAL*8 W\t\n      WRITE (6,1) RADIX(V),DIGITS(V),\"single\",DIGITS(W),\"double\"\n    1   FORMAT (\"Floating-point arithmetic is conducted in base \",I0,/\n     1   2(I3,\" digits for \",A,\" precision\",/))\n      WRITE (6,*) \"Single precision limit\",HUGE(V)\n      WRITE (6,*) \"Double precision limit\",HUGE(W)\n      WRITE (6,*)\n\n      CALL MULLER\n\n      CALL CBS\n\n      WRITE (6,10)\n   10 FORMAT (///\"Evaluation of Siegfried Rump's function of 1988\",\n     1 \" where F(77617,33096) = -0.827396059946821\")\n      WRITE (6,*) \"Single precision:\",SR4(77617.0,33096.0)\n      WRITE (6,*) \"Double precision:\",SR8(77617.0D0,33096.0D0)\t\n      END\n", "target": "import java.math.BigDecimal;\nimport java.math.RoundingMode;\n\npublic class FPProblems {\n    public static void wrongConvergence() {\n        int[] INDEXES = new int[] { 3, 4, 5, 6, 7, 8, 20, 30, 50, 100 };\n        \n        \n        double[] fpValues = new double[100];\n        fpValues[0] = 2.0;\n        fpValues[1] = -4.0;\n        for (int i = 2; i < fpValues.length; i++) {\n            fpValues[i] = 111.0 - 1130.0 / fpValues[i - 1] + 3000.0 / (fpValues[i - 1] * fpValues[i - 2]);\n        }\n        \n        \n        BigRational[] brValues = new BigRational[100];\n        brValues[0] = BigRational.valueOf(2);\n        brValues[1] = BigRational.valueOf(-4);\n        for (int i = 2; i < brValues.length; i++) {\n            \n            BigRational clause2 = BigRational.valueOf(1130).divide(brValues[i - 1]);\n            BigRational clause3 = BigRational.valueOf(3000).divide(brValues[i - 1].multiply(brValues[i - 2]));\n            brValues[i] = BigRational.valueOf(111).subtract(clause2).add(clause3);\n        }\n        \n        System.out.println(\"Wrong Convergence Sequence\");\n        for (int n : INDEXES) {\n            BigDecimal value = brValues[n - 1].toBigDecimal(16, RoundingMode.HALF_UP);\n            System.out.println(\"  For index \" + n + \", FP value is \" + fpValues[n - 1] + \", and rounded BigRational value is \" + value.toPlainString());\n        }\n        \n        return;\n    }\n    \n    public static void chaoticBankSociety() {\n        System.out.println(\"Chaotic Bank Society\");\n        double balance = Math.E - 1.0;\n        \n        \n        BigRational e = BigRational.ONE;\n        BigRational d = BigRational.ONE;\n        for (int i = 1; i < 1000; i++) {\n            d = d.multiply(BigRational.valueOf(i));\n            e = e.add(d.reciprocal());\n        }\n        System.out.println(\"DEBUG: e=\" + e.toBigDecimal(100, RoundingMode.HALF_UP).toPlainString());\n        \n        \n        \n        \n        BigRational brBalance = e.subtract(BigRational.ONE);\n        for (int year = 1; year <= 25; year++) {\n            balance = (balance * year) - 1.0;\n            brBalance = brBalance.multiply(BigRational.valueOf(year)).subtract(BigRational.ONE);\n            BigDecimal bdValue = brBalance.toBigDecimal(16, RoundingMode.HALF_UP);\n            System.out.println(\"  Year=\" + year + \", FP balance=\" + balance + \", BigRational balance=\" + bdValue.toPlainString());\n        }\n    }\n    \n    public static void siegfriedRump() {\n        System.out.println(\"Siegfried Rump formula\");\n        double fpValue;\n        {\n            double a = 77617.0;\n            double b = 33096.0;\n            fpValue = 333.75 * Math.pow(b, 6) + a * a * (11.0 * a * a * b * b - Math.pow(b, 6) - 121.0 * Math.pow(b, 4) - 2.0) + 5.5 * Math.pow(b, 8) + a / (2.0 * b);\n        }\n        \n        BigRational brValue;\n        {\n            BigRational a = BigRational.valueOf(77617);\n            BigRational b = BigRational.valueOf(33096);\n            BigRational clause1 = BigRational.valueOf(333.75).multiply(b.pow(6));\n            BigRational clause2a = BigRational.valueOf(11).multiply(a).multiply(a).multiply(b).multiply(b);\n            BigRational clause2b = b.pow(6).add(BigRational.valueOf(121).multiply(b.pow(4))).add(BigRational.valueOf(2));\n            BigRational clause2 = a.multiply(a).multiply(clause2a.subtract(clause2b));\n            BigRational clause3 = BigRational.valueOf(5.5).multiply(b.pow(8));\n            BigRational clause4 = a.divide(b.multiply(BigRational.valueOf(2)));\n            brValue = clause1.add(clause2).add(clause3).add(clause4);\n        }\n        \n        System.out.println(\"  FP value is \" + fpValue);\n        System.out.println(\"  BigRational rounded value is \" + brValue.toBigDecimal(64, RoundingMode.HALF_UP).toPlainString());\n        System.out.println(\"  BigRational full value is \" + brValue.toString());\n    }\n    \n    public static void main(String... args) {\n        wrongConvergence();\n        \n        System.out.println();\n        chaoticBankSociety();\n\n        System.out.println();\n        siegfriedRump();\n    }\n}\n"}
{"id": 73646, "name": "Pathological floating point problems", "source": "Translate Fortran to Python:       SUBROUTINE MULLER\n       REAL*4 VN,VNL1,VNL2\t\n       REAL*8 WN,WNL1,WNL2\t\n       INTEGER I\t\t\n        WRITE (6,1)\t\t\n    1   FORMAT (\"Muller's sequence should converge to six...\",/\n     1   \"  N     Single      Double\")\n        VNL1 = 2; VN = -4\t\n        WNL1 = 2; WN = -4\t\n        DO I = 3,36\t\t\t\n          VNL2 = VNL1; VNL1 = VN\t\t\n          WNL2 = WNL1; WNL1 = WN\t\t\n          VN = 111 - 1130/VNL1 + 3000/(VNL1*VNL2)\t\n          WN = 111 - 1130/WNL1 + 3000/(WNL1*WNL2)\t\n          WRITE (6,2) I,VN,WN\t\t\t\n    2     FORMAT (I3,F12.7,F21.16)\t\t\n        END DO\t\t\t\t\n      END SUBROUTINE MULLER\t\n\n      SUBROUTINE CBS\t\t\n       INTEGER YEAR\t\n       REAL*4 V\t\t\n       REAL*8 W\t\t\n        V = 1; W = 1\t\t\n        V = EXP(V) - 1\t\t\n        W = EXP(W) - 1\t\t\n        WRITE (6,1)\t\t\n    1   FORMAT (///\"The Chaotic Bank Society in action...\"/\"Year\")\n        WRITE (6,2) 0,V,W\t\n    2   FORMAT (I3,F16.7,F28.16)\n        DO YEAR = 1,25\t\t\n          V = V*YEAR - 1\t\n          W = W*YEAR - 1\t\n          WRITE (6,2) YEAR,V,W\t\n        END DO\t\t\t\n      END SUBROUTINE CBS\t\n\n      REAL*4 FUNCTION SR4(A,B)\t\n       REAL*4 A,B\n        SR4 = 333.75*B**6\n     1      + A**2*(11*A**2*B**2 - B**6 - 121*B**4 - 2)\n     2      + 5.5*B**8 + A/(2*B)\n      END FUNCTION SR4\n      REAL*8 FUNCTION SR8(A,B)\t\n       REAL*8 A,B\n        SR8 = 333.75*B**6\t\n     1      + A**2*(11*A**2*B**2 - B**6 - 121*B**4 - 2)\n     2      + 5.5*B**8 + A/(2*B)\n      END FUNCTION SR8\n\n      PROGRAM POKE\n      REAL*4 V\t\n      REAL*8 W\t\n      WRITE (6,1) RADIX(V),DIGITS(V),\"single\",DIGITS(W),\"double\"\n    1   FORMAT (\"Floating-point arithmetic is conducted in base \",I0,/\n     1   2(I3,\" digits for \",A,\" precision\",/))\n      WRITE (6,*) \"Single precision limit\",HUGE(V)\n      WRITE (6,*) \"Double precision limit\",HUGE(W)\n      WRITE (6,*)\n\n      CALL MULLER\n\n      CALL CBS\n\n      WRITE (6,10)\n   10 FORMAT (///\"Evaluation of Siegfried Rump's function of 1988\",\n     1 \" where F(77617,33096) = -0.827396059946821\")\n      WRITE (6,*) \"Single precision:\",SR4(77617.0,33096.0)\n      WRITE (6,*) \"Double precision:\",SR8(77617.0D0,33096.0D0)\t\n      END\n", "target": "from fractions import Fraction\n\ndef muller_seq(n:int) -> float:\n    seq = [Fraction(0), Fraction(2), Fraction(-4)]\n    for i in range(3, n+1):\n        next_value = (111 - 1130/seq[i-1]\n            + 3000/(seq[i-1]*seq[i-2]))\n        seq.append(next_value)\n    return float(seq[n])\n\nfor n in [3, 4, 5, 6, 7, 8, 20, 30, 50, 100]:\n    print(\"{:4d} -> {}\".format(n, muller_seq(n)))\n"}
{"id": 73647, "name": "Pathological floating point problems", "source": "Translate Fortran to Python:       SUBROUTINE MULLER\n       REAL*4 VN,VNL1,VNL2\t\n       REAL*8 WN,WNL1,WNL2\t\n       INTEGER I\t\t\n        WRITE (6,1)\t\t\n    1   FORMAT (\"Muller's sequence should converge to six...\",/\n     1   \"  N     Single      Double\")\n        VNL1 = 2; VN = -4\t\n        WNL1 = 2; WN = -4\t\n        DO I = 3,36\t\t\t\n          VNL2 = VNL1; VNL1 = VN\t\t\n          WNL2 = WNL1; WNL1 = WN\t\t\n          VN = 111 - 1130/VNL1 + 3000/(VNL1*VNL2)\t\n          WN = 111 - 1130/WNL1 + 3000/(WNL1*WNL2)\t\n          WRITE (6,2) I,VN,WN\t\t\t\n    2     FORMAT (I3,F12.7,F21.16)\t\t\n        END DO\t\t\t\t\n      END SUBROUTINE MULLER\t\n\n      SUBROUTINE CBS\t\t\n       INTEGER YEAR\t\n       REAL*4 V\t\t\n       REAL*8 W\t\t\n        V = 1; W = 1\t\t\n        V = EXP(V) - 1\t\t\n        W = EXP(W) - 1\t\t\n        WRITE (6,1)\t\t\n    1   FORMAT (///\"The Chaotic Bank Society in action...\"/\"Year\")\n        WRITE (6,2) 0,V,W\t\n    2   FORMAT (I3,F16.7,F28.16)\n        DO YEAR = 1,25\t\t\n          V = V*YEAR - 1\t\n          W = W*YEAR - 1\t\n          WRITE (6,2) YEAR,V,W\t\n        END DO\t\t\t\n      END SUBROUTINE CBS\t\n\n      REAL*4 FUNCTION SR4(A,B)\t\n       REAL*4 A,B\n        SR4 = 333.75*B**6\n     1      + A**2*(11*A**2*B**2 - B**6 - 121*B**4 - 2)\n     2      + 5.5*B**8 + A/(2*B)\n      END FUNCTION SR4\n      REAL*8 FUNCTION SR8(A,B)\t\n       REAL*8 A,B\n        SR8 = 333.75*B**6\t\n     1      + A**2*(11*A**2*B**2 - B**6 - 121*B**4 - 2)\n     2      + 5.5*B**8 + A/(2*B)\n      END FUNCTION SR8\n\n      PROGRAM POKE\n      REAL*4 V\t\n      REAL*8 W\t\n      WRITE (6,1) RADIX(V),DIGITS(V),\"single\",DIGITS(W),\"double\"\n    1   FORMAT (\"Floating-point arithmetic is conducted in base \",I0,/\n     1   2(I3,\" digits for \",A,\" precision\",/))\n      WRITE (6,*) \"Single precision limit\",HUGE(V)\n      WRITE (6,*) \"Double precision limit\",HUGE(W)\n      WRITE (6,*)\n\n      CALL MULLER\n\n      CALL CBS\n\n      WRITE (6,10)\n   10 FORMAT (///\"Evaluation of Siegfried Rump's function of 1988\",\n     1 \" where F(77617,33096) = -0.827396059946821\")\n      WRITE (6,*) \"Single precision:\",SR4(77617.0,33096.0)\n      WRITE (6,*) \"Double precision:\",SR8(77617.0D0,33096.0D0)\t\n      END\n", "target": "from fractions import Fraction\n\ndef muller_seq(n:int) -> float:\n    seq = [Fraction(0), Fraction(2), Fraction(-4)]\n    for i in range(3, n+1):\n        next_value = (111 - 1130/seq[i-1]\n            + 3000/(seq[i-1]*seq[i-2]))\n        seq.append(next_value)\n    return float(seq[n])\n\nfor n in [3, 4, 5, 6, 7, 8, 20, 30, 50, 100]:\n    print(\"{:4d} -> {}\".format(n, muller_seq(n)))\n"}
{"id": 74034, "name": "Sum to 100", "source": "Translate Fortran to C#: \n\n\n\n\n\n\n\n\n\nprogram sumto100\n    \n    parameter (nexpr = 13122)\n\n    print *\n    print *, 'Show all solutions that sum to 100'\n    print *\n    do i = 0, nexpr-1\n        if ( ievaluate(i) .eq. 100 ) then\n            call printexpr(i)\n        endif    \n    enddo\n    \n    print *\n    print *, 'Show the sum that has the maximum number of solutions'\n    print *    \n    ibest = -1\n    nbest = -1\n    do i = 0, nexpr-1\n        itest = ievaluate(i)\n        if ( itest .ge. 0 ) then\n            ntest = 0\n            do j = 0, nexpr-1\n                if ( ievaluate(j) .eq. itest ) then\n                    ntest = ntest + 1\n                endif\n            enddo\n            if ( (ntest .gt. nbest) ) then\n                ibest = itest\n                nbest = ntest\n            endif\n        endif\n    enddo\n    print *, ibest, ' has ', nbest, ' solutions'\n    print *\n\n\n\n\n\n\n    print *\n    print *, 'Show the lowest positive number that can''t be expressed'\n    print *\n    loop: do i = 0,123456789\n        do j = 0,nexpr-1\n            if ( i .eq. ievaluate(j) ) then\n                cycle loop\n            endif\n        enddo\n        exit\n    enddo loop\n    print *, i\n \n    print *\n    print *, 'Show the ten highest numbers that can be expressed'\n    print *\n    ilimit = 123456789\n    do i = 1,10\n        ibest = 0\n        do j = 0, nexpr-1\n            itest = ievaluate(j)\n            if ( (itest .le. ilimit) .and. (itest .gt. ibest ) ) then\n                ibest = itest\n            endif\n        enddo\n        do j = 0, nexpr-1    \n            if ( ievaluate(j) .eq. ibest ) then\n                call printexpr(j)\n            endif    \n        enddo\n        ilimit = ibest - 1;\n    enddo\n       \nend \n\nfunction ievaluate(icode)\n    ic = icode\n    ievaluate = 0\n    n = 0\n    ip = 1\n    do k = 9,1,-1\n        n = ip*k + n\n        select case(mod(ic,3))\n            case ( 0 )\n                ievaluate = ievaluate + n\n                n = 0\n                ip = 1\n            case ( 1 )\n                ievaluate = ievaluate - n\n                n = 0\n                ip = 1\n            case ( 2 )\n                ip = ip * 10\n        end select\n        ic = ic / 3                \n    enddo\nend \n\nsubroutine printexpr(icode)\n    character(len=32) s\n    ia = 19683\n    ib =  6561\n    s = \"\"\n    do k = 1,9\n        ic = mod(icode,ia) / ib\n        ia = ib\n        ib = ib / 3\n        select case(mod(ic,3))\n            case ( 0 )\n                if ( k .gt. 1 ) then\n                    s = trim(s) // '+'\n                endif\n            case ( 1 )\n                s = trim(s) // '-'\n        end select\n        s = trim(s) // char(ichar('0')+k)\n    end do\n    ivalue = ievaluate(icode)\n    print *, ivalue, ' = ', s\nend\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\nclass Program\n{\n    static void Main(string[] args)\n    {\n        \n        var expressionsPlus = Enumerable.Range(0, (int)Math.Pow(3, 8)).AsParallel().Select(i => new Expression(i, 1));\n        \n        var expressionsMinus = Enumerable.Range(0, (int)Math.Pow(3, 8)).AsParallel().Select(i => new Expression(i, -1));\n        var expressions = expressionsPlus.Concat(expressionsMinus);\n        var results = new Dictionary<int, List<Expression>>();\n        foreach (var e in expressions)\n        {\n            if (results.Keys.Contains(e.Value))\n                results[e.Value].Add(e);\n            else\n                results[e.Value] = new List<Expression>() { e };\n        }\n        Console.WriteLine(\"Show all solutions that sum to 100\");\n        foreach (Expression e in results[100])\n            Console.WriteLine(\"  \" + e);\n        Console.WriteLine(\"Show the sum that has the maximum number of solutions (from zero to infinity)\");\n        var summary = results.Keys.Select(k => new Tuple<int, int>(k, results[k].Count));\n        var maxSols = summary.Aggregate((a, b) => a.Item2 > b.Item2 ? a : b);\n        Console.WriteLine(\"  The sum \" + maxSols.Item1 + \" has \" + maxSols.Item2 + \" solutions.\");\n        Console.WriteLine(\"Show the lowest positive sum that can't be expressed (has no solutions), using the rules for this task\");\n        var lowestPositive = Enumerable.Range(1, int.MaxValue).First(x => !results.Keys.Contains(x));\n        Console.WriteLine(\"  \" + lowestPositive);\n        Console.WriteLine(\"Show the ten highest numbers that can be expressed using the rules for this task (extra credit)\");\n        var highest = from k in results.Keys\n                      orderby k descending\n                      select k;\n        foreach (var x in highest.Take(10))\n            Console.WriteLine(\"  \" + x);\n    }\n}\npublic enum Operations { Plus, Minus, Join };\npublic class Expression\n{\n    protected Operations[] Gaps;\n    \n    \n    public int Value; \n    protected int _one;\n    \n    public Expression(int serial, int one)\n    {\n        _one = one;\n        Gaps = new Operations[8];\n        \n        int divisor = 2187; \n        int times;\n        for (int i = 0; i < 8; i++)\n        {\n            times = Math.DivRem(serial, divisor, out serial);\n            divisor /= 3;\n            if (times == 0)\n                Gaps[i] = Operations.Join;\n            else if (times == 1)\n                Gaps[i] = Operations.Minus;\n            else\n                Gaps[i] = Operations.Plus;\n        }\n        \n        \n        Value = Evaluate();\n    }\n    public override string ToString()\n    {\n        string ret = _one.ToString();\n        for (int i = 0; i < 8; i++)\n        {\n            switch (Gaps[i])\n            {\n                case Operations.Plus:\n                    ret += \"+\";\n                    break;\n                case Operations.Minus:\n                    ret += \"-\";\n                    break;\n            }\n            ret += (i + 2);\n        }\n        return ret;\n    }\n    private int Evaluate()\n        \n    {\n        var numbers = new int[9];\n        int nc = 0;\n        var operations = new List<Operations>();\n        int a = 1;\n        for (int i = 0; i < 8; i++)\n        {\n            if (Gaps[i] == Operations.Join)\n                a = a * 10 + (i + 2);\n            else\n            {\n                if (a > 0)\n                {\n                    if (nc == 0)\n                        a *= _one;\n                    numbers[nc++] = a;\n                    a = i + 2;\n                }\n                operations.Add(Gaps[i]);\n            }\n        }\n        if (nc == 0)\n            a *= _one;\n        numbers[nc++] = a;\n        int ni = 0;\n        int left = numbers[ni++];\n        foreach (var operation in operations)\n        {\n            int right = numbers[ni++];\n            if (operation == Operations.Plus)\n                left = left + right;\n            else\n                left = left - right;\n        }\n        return left;\n    }\n}\n"}
{"id": 74035, "name": "Sum to 100", "source": "Translate Fortran to C#: \n\n\n\n\n\n\n\n\n\nprogram sumto100\n    \n    parameter (nexpr = 13122)\n\n    print *\n    print *, 'Show all solutions that sum to 100'\n    print *\n    do i = 0, nexpr-1\n        if ( ievaluate(i) .eq. 100 ) then\n            call printexpr(i)\n        endif    \n    enddo\n    \n    print *\n    print *, 'Show the sum that has the maximum number of solutions'\n    print *    \n    ibest = -1\n    nbest = -1\n    do i = 0, nexpr-1\n        itest = ievaluate(i)\n        if ( itest .ge. 0 ) then\n            ntest = 0\n            do j = 0, nexpr-1\n                if ( ievaluate(j) .eq. itest ) then\n                    ntest = ntest + 1\n                endif\n            enddo\n            if ( (ntest .gt. nbest) ) then\n                ibest = itest\n                nbest = ntest\n            endif\n        endif\n    enddo\n    print *, ibest, ' has ', nbest, ' solutions'\n    print *\n\n\n\n\n\n\n    print *\n    print *, 'Show the lowest positive number that can''t be expressed'\n    print *\n    loop: do i = 0,123456789\n        do j = 0,nexpr-1\n            if ( i .eq. ievaluate(j) ) then\n                cycle loop\n            endif\n        enddo\n        exit\n    enddo loop\n    print *, i\n \n    print *\n    print *, 'Show the ten highest numbers that can be expressed'\n    print *\n    ilimit = 123456789\n    do i = 1,10\n        ibest = 0\n        do j = 0, nexpr-1\n            itest = ievaluate(j)\n            if ( (itest .le. ilimit) .and. (itest .gt. ibest ) ) then\n                ibest = itest\n            endif\n        enddo\n        do j = 0, nexpr-1    \n            if ( ievaluate(j) .eq. ibest ) then\n                call printexpr(j)\n            endif    \n        enddo\n        ilimit = ibest - 1;\n    enddo\n       \nend \n\nfunction ievaluate(icode)\n    ic = icode\n    ievaluate = 0\n    n = 0\n    ip = 1\n    do k = 9,1,-1\n        n = ip*k + n\n        select case(mod(ic,3))\n            case ( 0 )\n                ievaluate = ievaluate + n\n                n = 0\n                ip = 1\n            case ( 1 )\n                ievaluate = ievaluate - n\n                n = 0\n                ip = 1\n            case ( 2 )\n                ip = ip * 10\n        end select\n        ic = ic / 3                \n    enddo\nend \n\nsubroutine printexpr(icode)\n    character(len=32) s\n    ia = 19683\n    ib =  6561\n    s = \"\"\n    do k = 1,9\n        ic = mod(icode,ia) / ib\n        ia = ib\n        ib = ib / 3\n        select case(mod(ic,3))\n            case ( 0 )\n                if ( k .gt. 1 ) then\n                    s = trim(s) // '+'\n                endif\n            case ( 1 )\n                s = trim(s) // '-'\n        end select\n        s = trim(s) // char(ichar('0')+k)\n    end do\n    ivalue = ievaluate(icode)\n    print *, ivalue, ' = ', s\nend\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\nclass Program\n{\n    static void Main(string[] args)\n    {\n        \n        var expressionsPlus = Enumerable.Range(0, (int)Math.Pow(3, 8)).AsParallel().Select(i => new Expression(i, 1));\n        \n        var expressionsMinus = Enumerable.Range(0, (int)Math.Pow(3, 8)).AsParallel().Select(i => new Expression(i, -1));\n        var expressions = expressionsPlus.Concat(expressionsMinus);\n        var results = new Dictionary<int, List<Expression>>();\n        foreach (var e in expressions)\n        {\n            if (results.Keys.Contains(e.Value))\n                results[e.Value].Add(e);\n            else\n                results[e.Value] = new List<Expression>() { e };\n        }\n        Console.WriteLine(\"Show all solutions that sum to 100\");\n        foreach (Expression e in results[100])\n            Console.WriteLine(\"  \" + e);\n        Console.WriteLine(\"Show the sum that has the maximum number of solutions (from zero to infinity)\");\n        var summary = results.Keys.Select(k => new Tuple<int, int>(k, results[k].Count));\n        var maxSols = summary.Aggregate((a, b) => a.Item2 > b.Item2 ? a : b);\n        Console.WriteLine(\"  The sum \" + maxSols.Item1 + \" has \" + maxSols.Item2 + \" solutions.\");\n        Console.WriteLine(\"Show the lowest positive sum that can't be expressed (has no solutions), using the rules for this task\");\n        var lowestPositive = Enumerable.Range(1, int.MaxValue).First(x => !results.Keys.Contains(x));\n        Console.WriteLine(\"  \" + lowestPositive);\n        Console.WriteLine(\"Show the ten highest numbers that can be expressed using the rules for this task (extra credit)\");\n        var highest = from k in results.Keys\n                      orderby k descending\n                      select k;\n        foreach (var x in highest.Take(10))\n            Console.WriteLine(\"  \" + x);\n    }\n}\npublic enum Operations { Plus, Minus, Join };\npublic class Expression\n{\n    protected Operations[] Gaps;\n    \n    \n    public int Value; \n    protected int _one;\n    \n    public Expression(int serial, int one)\n    {\n        _one = one;\n        Gaps = new Operations[8];\n        \n        int divisor = 2187; \n        int times;\n        for (int i = 0; i < 8; i++)\n        {\n            times = Math.DivRem(serial, divisor, out serial);\n            divisor /= 3;\n            if (times == 0)\n                Gaps[i] = Operations.Join;\n            else if (times == 1)\n                Gaps[i] = Operations.Minus;\n            else\n                Gaps[i] = Operations.Plus;\n        }\n        \n        \n        Value = Evaluate();\n    }\n    public override string ToString()\n    {\n        string ret = _one.ToString();\n        for (int i = 0; i < 8; i++)\n        {\n            switch (Gaps[i])\n            {\n                case Operations.Plus:\n                    ret += \"+\";\n                    break;\n                case Operations.Minus:\n                    ret += \"-\";\n                    break;\n            }\n            ret += (i + 2);\n        }\n        return ret;\n    }\n    private int Evaluate()\n        \n    {\n        var numbers = new int[9];\n        int nc = 0;\n        var operations = new List<Operations>();\n        int a = 1;\n        for (int i = 0; i < 8; i++)\n        {\n            if (Gaps[i] == Operations.Join)\n                a = a * 10 + (i + 2);\n            else\n            {\n                if (a > 0)\n                {\n                    if (nc == 0)\n                        a *= _one;\n                    numbers[nc++] = a;\n                    a = i + 2;\n                }\n                operations.Add(Gaps[i]);\n            }\n        }\n        if (nc == 0)\n            a *= _one;\n        numbers[nc++] = a;\n        int ni = 0;\n        int left = numbers[ni++];\n        foreach (var operation in operations)\n        {\n            int right = numbers[ni++];\n            if (operation == Operations.Plus)\n                left = left + right;\n            else\n                left = left - right;\n        }\n        return left;\n    }\n}\n"}
{"id": 74041, "name": "Sum to 100", "source": "Translate Fortran to Java: \n\n\n\n\n\n\n\n\n\nprogram sumto100\n    \n    parameter (nexpr = 13122)\n\n    print *\n    print *, 'Show all solutions that sum to 100'\n    print *\n    do i = 0, nexpr-1\n        if ( ievaluate(i) .eq. 100 ) then\n            call printexpr(i)\n        endif    \n    enddo\n    \n    print *\n    print *, 'Show the sum that has the maximum number of solutions'\n    print *    \n    ibest = -1\n    nbest = -1\n    do i = 0, nexpr-1\n        itest = ievaluate(i)\n        if ( itest .ge. 0 ) then\n            ntest = 0\n            do j = 0, nexpr-1\n                if ( ievaluate(j) .eq. itest ) then\n                    ntest = ntest + 1\n                endif\n            enddo\n            if ( (ntest .gt. nbest) ) then\n                ibest = itest\n                nbest = ntest\n            endif\n        endif\n    enddo\n    print *, ibest, ' has ', nbest, ' solutions'\n    print *\n\n\n\n\n\n\n    print *\n    print *, 'Show the lowest positive number that can''t be expressed'\n    print *\n    loop: do i = 0,123456789\n        do j = 0,nexpr-1\n            if ( i .eq. ievaluate(j) ) then\n                cycle loop\n            endif\n        enddo\n        exit\n    enddo loop\n    print *, i\n \n    print *\n    print *, 'Show the ten highest numbers that can be expressed'\n    print *\n    ilimit = 123456789\n    do i = 1,10\n        ibest = 0\n        do j = 0, nexpr-1\n            itest = ievaluate(j)\n            if ( (itest .le. ilimit) .and. (itest .gt. ibest ) ) then\n                ibest = itest\n            endif\n        enddo\n        do j = 0, nexpr-1    \n            if ( ievaluate(j) .eq. ibest ) then\n                call printexpr(j)\n            endif    \n        enddo\n        ilimit = ibest - 1;\n    enddo\n       \nend \n\nfunction ievaluate(icode)\n    ic = icode\n    ievaluate = 0\n    n = 0\n    ip = 1\n    do k = 9,1,-1\n        n = ip*k + n\n        select case(mod(ic,3))\n            case ( 0 )\n                ievaluate = ievaluate + n\n                n = 0\n                ip = 1\n            case ( 1 )\n                ievaluate = ievaluate - n\n                n = 0\n                ip = 1\n            case ( 2 )\n                ip = ip * 10\n        end select\n        ic = ic / 3                \n    enddo\nend \n\nsubroutine printexpr(icode)\n    character(len=32) s\n    ia = 19683\n    ib =  6561\n    s = \"\"\n    do k = 1,9\n        ic = mod(icode,ia) / ib\n        ia = ib\n        ib = ib / 3\n        select case(mod(ic,3))\n            case ( 0 )\n                if ( k .gt. 1 ) then\n                    s = trim(s) // '+'\n                endif\n            case ( 1 )\n                s = trim(s) // '-'\n        end select\n        s = trim(s) // char(ichar('0')+k)\n    end do\n    ivalue = ievaluate(icode)\n    print *, ivalue, ' = ', s\nend\n", "target": "\npackage rosettacode;\n\nimport java.io.PrintStream;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.Map;\nimport java.util.Set;\n\npublic class SumTo100 implements Runnable {\n\n    public static void main(String[] args) {\n        new SumTo100().run();\n    }\n\n    void print(int givenSum) {\n        Expression expression = new Expression();\n        for (int i = 0; i < Expression.NUMBER_OF_EXPRESSIONS; i++, expression.next()) {\n            if (expression.toInt() == givenSum) {\n                expression.print();\n            }\n        }\n    }\n\n    void comment(String commentString) {\n        System.out.println();\n        System.out.println(commentString);\n        System.out.println();\n    }\n\n    @Override\n    public void run() {\n        final Stat stat = new Stat();\n\n        comment(\"Show all solutions that sum to 100\");\n        final int givenSum = 100;\n        print(givenSum);\n\n        comment(\"Show the sum that has the maximum number of solutions\");\n        final int maxCount = Collections.max(stat.sumCount.keySet());\n        int maxSum;\n        Iterator<Integer> it = stat.sumCount.get(maxCount).iterator();\n        do {\n            maxSum = it.next();\n        } while (maxSum < 0);\n        System.out.println(maxSum + \" has \" + maxCount + \" solutions\");\n\n        comment(\"Show the lowest positive number that can't be expressed\");\n        int value = 0;\n        while (stat.countSum.containsKey(value)) {\n            value++;\n        }\n        System.out.println(value);\n\n        comment(\"Show the ten highest numbers that can be expressed\");\n        final int n = stat.countSum.keySet().size();\n        final Integer[] sums = stat.countSum.keySet().toArray(new Integer[n]);\n        Arrays.sort(sums);\n        for (int i = n - 1; i >= n - 10; i--) {\n            print(sums[i]);\n        }\n    }\n\n    private static class Expression {\n\n        private final static int NUMBER_OF_DIGITS = 9;\n        private final static byte ADD = 0;\n        private final static byte SUB = 1;\n        private final static byte JOIN = 2;\n\n        final byte[] code = new byte[NUMBER_OF_DIGITS];\n        final static int NUMBER_OF_EXPRESSIONS = 2 * 3 * 3 * 3 * 3 * 3 * 3 * 3 * 3;\n\n        Expression next() {\n            for (int i = 0; i < NUMBER_OF_DIGITS; i++) {\n                if (++code[i] > JOIN) {\n                    code[i] = ADD;\n                } else {\n                    break;\n                }\n            }\n            return this;\n        }\n\n        int toInt() {\n            int value = 0;\n            int number = 0;\n            int sign = (+1);\n            for (int digit = 1; digit <= 9; digit++) {\n                switch (code[NUMBER_OF_DIGITS - digit]) {\n                    case ADD:\n                        value += sign * number;\n                        number = digit;\n                        sign = (+1);\n                        break;\n                    case SUB:\n                        value += sign * number;\n                        number = digit;\n                        sign = (-1);\n                        break;\n                    case JOIN:\n                        number = 10 * number + digit;\n                        break;\n                }\n            }\n            return value + sign * number;\n        }\n\n        @Override\n        public String toString() {\n            StringBuilder s = new StringBuilder(2 * NUMBER_OF_DIGITS + 1);\n            for (int digit = 1; digit <= NUMBER_OF_DIGITS; digit++) {\n                switch (code[NUMBER_OF_DIGITS - digit]) {\n                    case ADD:\n                        if (digit > 1) {\n                            s.append('+');\n                        }\n                        break;\n                    case SUB:\n                        s.append('-');\n                        break;\n                }\n                s.append(digit);\n            }\n            return s.toString();\n        }\n\n        void print() {\n            print(System.out);\n        }\n\n        void print(PrintStream printStream) {\n            printStream.format(\"%9d\", this.toInt());\n            printStream.println(\" = \" + this);\n        }\n    }\n\n    private static class Stat {\n\n        final Map<Integer, Integer> countSum = new HashMap<>();\n        final Map<Integer, Set<Integer>> sumCount = new HashMap<>();\n\n        Stat() {\n            Expression expression = new Expression();\n            for (int i = 0; i < Expression.NUMBER_OF_EXPRESSIONS; i++, expression.next()) {\n                int sum = expression.toInt();\n                countSum.put(sum, countSum.getOrDefault(sum, 0) + 1);\n            }\n            for (Map.Entry<Integer, Integer> entry : countSum.entrySet()) {\n                Set<Integer> set;\n                if (sumCount.containsKey(entry.getValue())) {\n                    set = sumCount.get(entry.getValue());\n                } else {\n                    set = new HashSet<>();\n                }\n                set.add(entry.getKey());\n                sumCount.put(entry.getValue(), set);\n            }\n        }\n    }\n}\n"}
{"id": 74042, "name": "Sum to 100", "source": "Translate Fortran to Java: \n\n\n\n\n\n\n\n\n\nprogram sumto100\n    \n    parameter (nexpr = 13122)\n\n    print *\n    print *, 'Show all solutions that sum to 100'\n    print *\n    do i = 0, nexpr-1\n        if ( ievaluate(i) .eq. 100 ) then\n            call printexpr(i)\n        endif    \n    enddo\n    \n    print *\n    print *, 'Show the sum that has the maximum number of solutions'\n    print *    \n    ibest = -1\n    nbest = -1\n    do i = 0, nexpr-1\n        itest = ievaluate(i)\n        if ( itest .ge. 0 ) then\n            ntest = 0\n            do j = 0, nexpr-1\n                if ( ievaluate(j) .eq. itest ) then\n                    ntest = ntest + 1\n                endif\n            enddo\n            if ( (ntest .gt. nbest) ) then\n                ibest = itest\n                nbest = ntest\n            endif\n        endif\n    enddo\n    print *, ibest, ' has ', nbest, ' solutions'\n    print *\n\n\n\n\n\n\n    print *\n    print *, 'Show the lowest positive number that can''t be expressed'\n    print *\n    loop: do i = 0,123456789\n        do j = 0,nexpr-1\n            if ( i .eq. ievaluate(j) ) then\n                cycle loop\n            endif\n        enddo\n        exit\n    enddo loop\n    print *, i\n \n    print *\n    print *, 'Show the ten highest numbers that can be expressed'\n    print *\n    ilimit = 123456789\n    do i = 1,10\n        ibest = 0\n        do j = 0, nexpr-1\n            itest = ievaluate(j)\n            if ( (itest .le. ilimit) .and. (itest .gt. ibest ) ) then\n                ibest = itest\n            endif\n        enddo\n        do j = 0, nexpr-1    \n            if ( ievaluate(j) .eq. ibest ) then\n                call printexpr(j)\n            endif    \n        enddo\n        ilimit = ibest - 1;\n    enddo\n       \nend \n\nfunction ievaluate(icode)\n    ic = icode\n    ievaluate = 0\n    n = 0\n    ip = 1\n    do k = 9,1,-1\n        n = ip*k + n\n        select case(mod(ic,3))\n            case ( 0 )\n                ievaluate = ievaluate + n\n                n = 0\n                ip = 1\n            case ( 1 )\n                ievaluate = ievaluate - n\n                n = 0\n                ip = 1\n            case ( 2 )\n                ip = ip * 10\n        end select\n        ic = ic / 3                \n    enddo\nend \n\nsubroutine printexpr(icode)\n    character(len=32) s\n    ia = 19683\n    ib =  6561\n    s = \"\"\n    do k = 1,9\n        ic = mod(icode,ia) / ib\n        ia = ib\n        ib = ib / 3\n        select case(mod(ic,3))\n            case ( 0 )\n                if ( k .gt. 1 ) then\n                    s = trim(s) // '+'\n                endif\n            case ( 1 )\n                s = trim(s) // '-'\n        end select\n        s = trim(s) // char(ichar('0')+k)\n    end do\n    ivalue = ievaluate(icode)\n    print *, ivalue, ' = ', s\nend\n", "target": "\npackage rosettacode;\n\nimport java.io.PrintStream;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.Map;\nimport java.util.Set;\n\npublic class SumTo100 implements Runnable {\n\n    public static void main(String[] args) {\n        new SumTo100().run();\n    }\n\n    void print(int givenSum) {\n        Expression expression = new Expression();\n        for (int i = 0; i < Expression.NUMBER_OF_EXPRESSIONS; i++, expression.next()) {\n            if (expression.toInt() == givenSum) {\n                expression.print();\n            }\n        }\n    }\n\n    void comment(String commentString) {\n        System.out.println();\n        System.out.println(commentString);\n        System.out.println();\n    }\n\n    @Override\n    public void run() {\n        final Stat stat = new Stat();\n\n        comment(\"Show all solutions that sum to 100\");\n        final int givenSum = 100;\n        print(givenSum);\n\n        comment(\"Show the sum that has the maximum number of solutions\");\n        final int maxCount = Collections.max(stat.sumCount.keySet());\n        int maxSum;\n        Iterator<Integer> it = stat.sumCount.get(maxCount).iterator();\n        do {\n            maxSum = it.next();\n        } while (maxSum < 0);\n        System.out.println(maxSum + \" has \" + maxCount + \" solutions\");\n\n        comment(\"Show the lowest positive number that can't be expressed\");\n        int value = 0;\n        while (stat.countSum.containsKey(value)) {\n            value++;\n        }\n        System.out.println(value);\n\n        comment(\"Show the ten highest numbers that can be expressed\");\n        final int n = stat.countSum.keySet().size();\n        final Integer[] sums = stat.countSum.keySet().toArray(new Integer[n]);\n        Arrays.sort(sums);\n        for (int i = n - 1; i >= n - 10; i--) {\n            print(sums[i]);\n        }\n    }\n\n    private static class Expression {\n\n        private final static int NUMBER_OF_DIGITS = 9;\n        private final static byte ADD = 0;\n        private final static byte SUB = 1;\n        private final static byte JOIN = 2;\n\n        final byte[] code = new byte[NUMBER_OF_DIGITS];\n        final static int NUMBER_OF_EXPRESSIONS = 2 * 3 * 3 * 3 * 3 * 3 * 3 * 3 * 3;\n\n        Expression next() {\n            for (int i = 0; i < NUMBER_OF_DIGITS; i++) {\n                if (++code[i] > JOIN) {\n                    code[i] = ADD;\n                } else {\n                    break;\n                }\n            }\n            return this;\n        }\n\n        int toInt() {\n            int value = 0;\n            int number = 0;\n            int sign = (+1);\n            for (int digit = 1; digit <= 9; digit++) {\n                switch (code[NUMBER_OF_DIGITS - digit]) {\n                    case ADD:\n                        value += sign * number;\n                        number = digit;\n                        sign = (+1);\n                        break;\n                    case SUB:\n                        value += sign * number;\n                        number = digit;\n                        sign = (-1);\n                        break;\n                    case JOIN:\n                        number = 10 * number + digit;\n                        break;\n                }\n            }\n            return value + sign * number;\n        }\n\n        @Override\n        public String toString() {\n            StringBuilder s = new StringBuilder(2 * NUMBER_OF_DIGITS + 1);\n            for (int digit = 1; digit <= NUMBER_OF_DIGITS; digit++) {\n                switch (code[NUMBER_OF_DIGITS - digit]) {\n                    case ADD:\n                        if (digit > 1) {\n                            s.append('+');\n                        }\n                        break;\n                    case SUB:\n                        s.append('-');\n                        break;\n                }\n                s.append(digit);\n            }\n            return s.toString();\n        }\n\n        void print() {\n            print(System.out);\n        }\n\n        void print(PrintStream printStream) {\n            printStream.format(\"%9d\", this.toInt());\n            printStream.println(\" = \" + this);\n        }\n    }\n\n    private static class Stat {\n\n        final Map<Integer, Integer> countSum = new HashMap<>();\n        final Map<Integer, Set<Integer>> sumCount = new HashMap<>();\n\n        Stat() {\n            Expression expression = new Expression();\n            for (int i = 0; i < Expression.NUMBER_OF_EXPRESSIONS; i++, expression.next()) {\n                int sum = expression.toInt();\n                countSum.put(sum, countSum.getOrDefault(sum, 0) + 1);\n            }\n            for (Map.Entry<Integer, Integer> entry : countSum.entrySet()) {\n                Set<Integer> set;\n                if (sumCount.containsKey(entry.getValue())) {\n                    set = sumCount.get(entry.getValue());\n                } else {\n                    set = new HashSet<>();\n                }\n                set.add(entry.getKey());\n                sumCount.put(entry.getValue(), set);\n            }\n        }\n    }\n}\n"}
{"id": 74043, "name": "Sum to 100", "source": "Translate Fortran to Python: \n\n\n\n\n\n\n\n\n\nprogram sumto100\n    \n    parameter (nexpr = 13122)\n\n    print *\n    print *, 'Show all solutions that sum to 100'\n    print *\n    do i = 0, nexpr-1\n        if ( ievaluate(i) .eq. 100 ) then\n            call printexpr(i)\n        endif    \n    enddo\n    \n    print *\n    print *, 'Show the sum that has the maximum number of solutions'\n    print *    \n    ibest = -1\n    nbest = -1\n    do i = 0, nexpr-1\n        itest = ievaluate(i)\n        if ( itest .ge. 0 ) then\n            ntest = 0\n            do j = 0, nexpr-1\n                if ( ievaluate(j) .eq. itest ) then\n                    ntest = ntest + 1\n                endif\n            enddo\n            if ( (ntest .gt. nbest) ) then\n                ibest = itest\n                nbest = ntest\n            endif\n        endif\n    enddo\n    print *, ibest, ' has ', nbest, ' solutions'\n    print *\n\n\n\n\n\n\n    print *\n    print *, 'Show the lowest positive number that can''t be expressed'\n    print *\n    loop: do i = 0,123456789\n        do j = 0,nexpr-1\n            if ( i .eq. ievaluate(j) ) then\n                cycle loop\n            endif\n        enddo\n        exit\n    enddo loop\n    print *, i\n \n    print *\n    print *, 'Show the ten highest numbers that can be expressed'\n    print *\n    ilimit = 123456789\n    do i = 1,10\n        ibest = 0\n        do j = 0, nexpr-1\n            itest = ievaluate(j)\n            if ( (itest .le. ilimit) .and. (itest .gt. ibest ) ) then\n                ibest = itest\n            endif\n        enddo\n        do j = 0, nexpr-1    \n            if ( ievaluate(j) .eq. ibest ) then\n                call printexpr(j)\n            endif    \n        enddo\n        ilimit = ibest - 1;\n    enddo\n       \nend \n\nfunction ievaluate(icode)\n    ic = icode\n    ievaluate = 0\n    n = 0\n    ip = 1\n    do k = 9,1,-1\n        n = ip*k + n\n        select case(mod(ic,3))\n            case ( 0 )\n                ievaluate = ievaluate + n\n                n = 0\n                ip = 1\n            case ( 1 )\n                ievaluate = ievaluate - n\n                n = 0\n                ip = 1\n            case ( 2 )\n                ip = ip * 10\n        end select\n        ic = ic / 3                \n    enddo\nend \n\nsubroutine printexpr(icode)\n    character(len=32) s\n    ia = 19683\n    ib =  6561\n    s = \"\"\n    do k = 1,9\n        ic = mod(icode,ia) / ib\n        ia = ib\n        ib = ib / 3\n        select case(mod(ic,3))\n            case ( 0 )\n                if ( k .gt. 1 ) then\n                    s = trim(s) // '+'\n                endif\n            case ( 1 )\n                s = trim(s) // '-'\n        end select\n        s = trim(s) // char(ichar('0')+k)\n    end do\n    ivalue = ievaluate(icode)\n    print *, ivalue, ' = ', s\nend\n", "target": "from itertools import product, islice\n\n\ndef expr(p):\n    return \"{}1{}2{}3{}4{}5{}6{}7{}8{}9\".format(*p)\n\n\ndef gen_expr():\n    op = ['+', '-', '']\n    return [expr(p) for p in product(op, repeat=9) if p[0] != '+']\n\n\ndef all_exprs():\n    values = {}\n    for expr in gen_expr():\n        val = eval(expr)\n        if val not in values:\n            values[val] = 1\n        else:\n            values[val] += 1\n    return values\n\n\ndef sum_to(val):\n    for s in filter(lambda x: x[0] == val, map(lambda x: (eval(x), x), gen_expr())):\n        print(s)\n\n\ndef max_solve():\n    print(\"Sum {} has the maximum number of solutions: {}\".\n          format(*max(all_exprs().items(), key=lambda x: x[1])))\n\n\ndef min_solve():\n    values = all_exprs()\n    for i in range(123456789):\n        if i not in values:\n            print(\"Lowest positive sum that can't be expressed: {}\".format(i))\n            return\n\n\ndef highest_sums(n=10):\n    sums = map(lambda x: x[0],\n               islice(sorted(all_exprs().items(), key=lambda x: x[0], reverse=True), n))\n    print(\"Highest Sums: {}\".format(list(sums)))\n\n\nsum_to(100)\nmax_solve()\nmin_solve()\nhighest_sums()\n"}
{"id": 74044, "name": "Sum to 100", "source": "Translate Fortran to Python: \n\n\n\n\n\n\n\n\n\nprogram sumto100\n    \n    parameter (nexpr = 13122)\n\n    print *\n    print *, 'Show all solutions that sum to 100'\n    print *\n    do i = 0, nexpr-1\n        if ( ievaluate(i) .eq. 100 ) then\n            call printexpr(i)\n        endif    \n    enddo\n    \n    print *\n    print *, 'Show the sum that has the maximum number of solutions'\n    print *    \n    ibest = -1\n    nbest = -1\n    do i = 0, nexpr-1\n        itest = ievaluate(i)\n        if ( itest .ge. 0 ) then\n            ntest = 0\n            do j = 0, nexpr-1\n                if ( ievaluate(j) .eq. itest ) then\n                    ntest = ntest + 1\n                endif\n            enddo\n            if ( (ntest .gt. nbest) ) then\n                ibest = itest\n                nbest = ntest\n            endif\n        endif\n    enddo\n    print *, ibest, ' has ', nbest, ' solutions'\n    print *\n\n\n\n\n\n\n    print *\n    print *, 'Show the lowest positive number that can''t be expressed'\n    print *\n    loop: do i = 0,123456789\n        do j = 0,nexpr-1\n            if ( i .eq. ievaluate(j) ) then\n                cycle loop\n            endif\n        enddo\n        exit\n    enddo loop\n    print *, i\n \n    print *\n    print *, 'Show the ten highest numbers that can be expressed'\n    print *\n    ilimit = 123456789\n    do i = 1,10\n        ibest = 0\n        do j = 0, nexpr-1\n            itest = ievaluate(j)\n            if ( (itest .le. ilimit) .and. (itest .gt. ibest ) ) then\n                ibest = itest\n            endif\n        enddo\n        do j = 0, nexpr-1    \n            if ( ievaluate(j) .eq. ibest ) then\n                call printexpr(j)\n            endif    \n        enddo\n        ilimit = ibest - 1;\n    enddo\n       \nend \n\nfunction ievaluate(icode)\n    ic = icode\n    ievaluate = 0\n    n = 0\n    ip = 1\n    do k = 9,1,-1\n        n = ip*k + n\n        select case(mod(ic,3))\n            case ( 0 )\n                ievaluate = ievaluate + n\n                n = 0\n                ip = 1\n            case ( 1 )\n                ievaluate = ievaluate - n\n                n = 0\n                ip = 1\n            case ( 2 )\n                ip = ip * 10\n        end select\n        ic = ic / 3                \n    enddo\nend \n\nsubroutine printexpr(icode)\n    character(len=32) s\n    ia = 19683\n    ib =  6561\n    s = \"\"\n    do k = 1,9\n        ic = mod(icode,ia) / ib\n        ia = ib\n        ib = ib / 3\n        select case(mod(ic,3))\n            case ( 0 )\n                if ( k .gt. 1 ) then\n                    s = trim(s) // '+'\n                endif\n            case ( 1 )\n                s = trim(s) // '-'\n        end select\n        s = trim(s) // char(ichar('0')+k)\n    end do\n    ivalue = ievaluate(icode)\n    print *, ivalue, ' = ', s\nend\n", "target": "from itertools import product, islice\n\n\ndef expr(p):\n    return \"{}1{}2{}3{}4{}5{}6{}7{}8{}9\".format(*p)\n\n\ndef gen_expr():\n    op = ['+', '-', '']\n    return [expr(p) for p in product(op, repeat=9) if p[0] != '+']\n\n\ndef all_exprs():\n    values = {}\n    for expr in gen_expr():\n        val = eval(expr)\n        if val not in values:\n            values[val] = 1\n        else:\n            values[val] += 1\n    return values\n\n\ndef sum_to(val):\n    for s in filter(lambda x: x[0] == val, map(lambda x: (eval(x), x), gen_expr())):\n        print(s)\n\n\ndef max_solve():\n    print(\"Sum {} has the maximum number of solutions: {}\".\n          format(*max(all_exprs().items(), key=lambda x: x[1])))\n\n\ndef min_solve():\n    values = all_exprs()\n    for i in range(123456789):\n        if i not in values:\n            print(\"Lowest positive sum that can't be expressed: {}\".format(i))\n            return\n\n\ndef highest_sums(n=10):\n    sums = map(lambda x: x[0],\n               islice(sorted(all_exprs().items(), key=lambda x: x[0], reverse=True), n))\n    print(\"Highest Sums: {}\".format(list(sums)))\n\n\nsum_to(100)\nmax_solve()\nmin_solve()\nhighest_sums()\n"}
{"id": 74323, "name": "Array concatenation", "source": "Translate Fortran to C#: program Concat_Arrays\n  implicit none\n\n  \n  integer, dimension(3) :: a = [1, 2, 3] \n  integer, dimension(3) :: b = [4, 5, 6] \n  integer, dimension(:), allocatable :: c, d\n  \n  allocate(c(size(a)+size(b)))\n  c(1 : size(a)) = a\n  c(size(a)+1 : size(a)+size(b)) = b\n  print*, c\n\n  \n  d = [a, b] \n  print*, d\nend program Concat_Arrays\n", "target": "using System;\n\nnamespace RosettaCode\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            int[] a = { 1, 2, 3 };\n            int[] b = { 4, 5, 6 };\n\n            int[] c = new int[a.Length + b.Length];\n            a.CopyTo(c, 0);\n            b.CopyTo(c, a.Length);\n\n            foreach(int n in c)\n            {\n                Console.WriteLine(n.ToString());\n            }\n        }\n    }\n}\n"}
{"id": 74327, "name": "Array concatenation", "source": "Translate Fortran to Java: program Concat_Arrays\n  implicit none\n\n  \n  integer, dimension(3) :: a = [1, 2, 3] \n  integer, dimension(3) :: b = [4, 5, 6] \n  integer, dimension(:), allocatable :: c, d\n  \n  allocate(c(size(a)+size(b)))\n  c(1 : size(a)) = a\n  c(size(a)+1 : size(a)+size(b)) = b\n  print*, c\n\n  \n  d = [a, b] \n  print*, d\nend program Concat_Arrays\n", "target": "String[] fruits = [\"apples\", \"oranges\"];\nString[] grains = [\"wheat\", \"corn\"];\nString[] all    = fruits + grains;\n"}
{"id": 74328, "name": "Array concatenation", "source": "Translate Fortran to Python: program Concat_Arrays\n  implicit none\n\n  \n  integer, dimension(3) :: a = [1, 2, 3] \n  integer, dimension(3) :: b = [4, 5, 6] \n  integer, dimension(:), allocatable :: c, d\n  \n  allocate(c(size(a)+size(b)))\n  c(1 : size(a)) = a\n  c(size(a)+1 : size(a)+size(b)) = b\n  print*, c\n\n  \n  d = [a, b] \n  print*, d\nend program Concat_Arrays\n", "target": "arr1 = [1, 2, 3]\narr2 = [4, 5, 6]\narr3 = [7, 8, 9]\narr4 = arr1 + arr2\nassert arr4 == [1, 2, 3, 4, 5, 6]\narr4.extend(arr3)\nassert arr4 == [1, 2, 3, 4, 5, 6, 7, 8, 9]\n"}
{"id": 74606, "name": "Abundant, deficient and perfect number classifications", "source": "Translate Fortran to C#:       MODULE FACTORSTUFF\t\nConcocted by R.N.McLean, MMXV.\n       INTEGER LOTS\t\t\n       PARAMETER (LOTS = 20000)\n       INTEGER KNOWNSUM(LOTS)\t\n       CONTAINS\t\t\n        SUBROUTINE PREPARESUMF\t\nConvert the Sieve of Eratoshenes to have each slot contain the sum of the proper divisors of its slot number.\nChanges to instead count the number of factors, or prime factors, etc. would be simple enough.\n         INTEGER F\t\t\n          KNOWNSUM(1) = 0\t\t\n          KNOWNSUM(2:LOTS) = 1\t\t\n          DO F = 2,LOTS/2\t\t\n            FORALL(I = F + F:LOTS:F) KNOWNSUM(I) = KNOWNSUM(I) + F\t\n          END DO\t\t\t\n        END SUBROUTINE PREPARESUMF\t\n         PURE INTEGER FUNCTION SIGN3(N)\t\nConfounded by the intrinsic function SIGN distinguishing only two states: < 0 from >= 0. NOT three-way.\n         INTEGER, INTENT(IN):: N\t\n          IF (N) 1,2,3\t\n    1     SIGN3 = -1\t\n          RETURN\n    2     SIGN3 = 0\t\n          RETURN\n    3     SIGN3 = +1\t\n        END FUNCTION SIGN3\t\n      END MODULE FACTORSTUFF\t\n       PROGRAM THREEWAYS\t\n       USE FACTORSTUFF\t\t\n       INTEGER I\t\t\n       INTEGER TEST(LOTS)\t\n        WRITE (6,*) \"Inspecting sums of proper divisors for 1 to\",LOTS\n        CALL PREPARESUMF\t\t\n        FORALL(I = 1:LOTS) TEST(I) = SIGN3(KNOWNSUM(I) - I)\t\n        WRITE (6,*) \"Deficient\",COUNT(TEST .LT. 0)\t\n        WRITE (6,*) \"Perfect\n        WRITE (6,*) \"Abundant \",COUNT(TEST .GT. 0)\t\n      END\t\t\t\n", "target": "using System;\nusing System.Linq;\n\npublic class Program\n{\n    public static void Main()\n    {\n        int abundant, deficient, perfect;\n        var sw = System.Diagnostics.Stopwatch.StartNew();\n        ClassifyNumbers.UsingSieve(20000, out abundant, out deficient, out perfect); sw.Stop();\n        Console.WriteLine($\"Abundant: {abundant}, Deficient: {deficient}, Perfect: {perfect}  {sw.Elapsed.TotalMilliseconds} ms\");\n        sw.Restart();\n        ClassifyNumbers.UsingOptiDivision(20000, out abundant, out deficient, out perfect);\n        Console.WriteLine($\"Abundant: {abundant}, Deficient: {deficient}, Perfect: {perfect}  {sw.Elapsed.TotalMilliseconds} ms\");\n        sw.Restart();\n        ClassifyNumbers.UsingDivision(20000, out abundant, out deficient, out perfect);\n        Console.WriteLine($\"Abundant: {abundant}, Deficient: {deficient}, Perfect: {perfect}  {sw.Elapsed.TotalMilliseconds} ms\");\n    }\n}\n\npublic static class ClassifyNumbers\n{\n    \n    public static void UsingSieve(int bound, out int abundant, out int deficient, out int perfect) {\n        abundant = perfect = 0;\n        \n        int[] sum = new int[bound + 1];\n        for (int divisor = 1; divisor <= bound >> 1; divisor++)\n            for (int i = divisor << 1; i <= bound; i += divisor)\n                sum[i] += divisor;\n        for (int i = 1; i <= bound; i++) {\n            if (sum[i] > i) abundant++;\n            else if (sum[i] == i) perfect++;\n        }\n        deficient = bound - abundant - perfect;\n    }\n\n    \n    public static void UsingOptiDivision(int bound, out int abundant, out int deficient, out int perfect) {\n        abundant = perfect = 0; int sum = 0;\n        for (int i = 2, d, r = 1; i <= bound; i++) {\n            if ((d = r * r - i) < 0) r++;\n            for (int x = 2; x < r; x++) if (i % x == 0) sum += x + i / x;\n            if (d == 0) sum += r;\n            switch (sum.CompareTo(i)) { case 0: perfect++; break; case 1: abundant++; break; }\n            sum = 1;\n        }\n        deficient = bound - abundant - perfect;\n    }\n\n    \n    public static void UsingDivision(int bound, out int abundant, out int deficient, out int perfect) {\n        abundant = perfect = 0;\n        for (int i = 2; i <= bound; i++) {\n            int sum = Enumerable.Range(1, (i + 1) / 2)\n                .Where(div => i % div == 0).Sum();\n            switch (sum.CompareTo(i)) {\n                case 0: perfect++; break;\n                case 1: abundant++; break;\n            }\n        }\n        deficient = bound - abundant - perfect;\n    }\n}\n"}
{"id": 74609, "name": "Abundant, deficient and perfect number classifications", "source": "Translate Fortran to Java:       MODULE FACTORSTUFF\t\nConcocted by R.N.McLean, MMXV.\n       INTEGER LOTS\t\t\n       PARAMETER (LOTS = 20000)\n       INTEGER KNOWNSUM(LOTS)\t\n       CONTAINS\t\t\n        SUBROUTINE PREPARESUMF\t\nConvert the Sieve of Eratoshenes to have each slot contain the sum of the proper divisors of its slot number.\nChanges to instead count the number of factors, or prime factors, etc. would be simple enough.\n         INTEGER F\t\t\n          KNOWNSUM(1) = 0\t\t\n          KNOWNSUM(2:LOTS) = 1\t\t\n          DO F = 2,LOTS/2\t\t\n            FORALL(I = F + F:LOTS:F) KNOWNSUM(I) = KNOWNSUM(I) + F\t\n          END DO\t\t\t\n        END SUBROUTINE PREPARESUMF\t\n         PURE INTEGER FUNCTION SIGN3(N)\t\nConfounded by the intrinsic function SIGN distinguishing only two states: < 0 from >= 0. NOT three-way.\n         INTEGER, INTENT(IN):: N\t\n          IF (N) 1,2,3\t\n    1     SIGN3 = -1\t\n          RETURN\n    2     SIGN3 = 0\t\n          RETURN\n    3     SIGN3 = +1\t\n        END FUNCTION SIGN3\t\n      END MODULE FACTORSTUFF\t\n       PROGRAM THREEWAYS\t\n       USE FACTORSTUFF\t\t\n       INTEGER I\t\t\n       INTEGER TEST(LOTS)\t\n        WRITE (6,*) \"Inspecting sums of proper divisors for 1 to\",LOTS\n        CALL PREPARESUMF\t\t\n        FORALL(I = 1:LOTS) TEST(I) = SIGN3(KNOWNSUM(I) - I)\t\n        WRITE (6,*) \"Deficient\",COUNT(TEST .LT. 0)\t\n        WRITE (6,*) \"Perfect\n        WRITE (6,*) \"Abundant \",COUNT(TEST .GT. 0)\t\n      END\t\t\t\n", "target": "import java.util.stream.LongStream;\n\npublic class NumberClassifications {\n \n    public static void main(String[] args) {\n        int deficient = 0;\n        int perfect = 0;\n        int abundant = 0;\n \n        for (long i = 1; i <= 20_000; i++) {\n            long sum = properDivsSum(i);\n            if (sum < i)\n                deficient++;\n            else if (sum == i)\n                perfect++;\n            else\n                abundant++;\n        }\n        System.out.println(\"Deficient: \" + deficient);\n        System.out.println(\"Perfect: \" + perfect);\n        System.out.println(\"Abundant: \" + abundant);\n    }\n \n    public static long properDivsSum(long n) {\n        return LongStream.rangeClosed(1, (n + 1) / 2).filter(i -> n != i && n % i == 0).sum();\n    }\n}\n"}
{"id": 74610, "name": "Abundant, deficient and perfect number classifications", "source": "Translate Fortran to Python:       MODULE FACTORSTUFF\t\nConcocted by R.N.McLean, MMXV.\n       INTEGER LOTS\t\t\n       PARAMETER (LOTS = 20000)\n       INTEGER KNOWNSUM(LOTS)\t\n       CONTAINS\t\t\n        SUBROUTINE PREPARESUMF\t\nConvert the Sieve of Eratoshenes to have each slot contain the sum of the proper divisors of its slot number.\nChanges to instead count the number of factors, or prime factors, etc. would be simple enough.\n         INTEGER F\t\t\n          KNOWNSUM(1) = 0\t\t\n          KNOWNSUM(2:LOTS) = 1\t\t\n          DO F = 2,LOTS/2\t\t\n            FORALL(I = F + F:LOTS:F) KNOWNSUM(I) = KNOWNSUM(I) + F\t\n          END DO\t\t\t\n        END SUBROUTINE PREPARESUMF\t\n         PURE INTEGER FUNCTION SIGN3(N)\t\nConfounded by the intrinsic function SIGN distinguishing only two states: < 0 from >= 0. NOT three-way.\n         INTEGER, INTENT(IN):: N\t\n          IF (N) 1,2,3\t\n    1     SIGN3 = -1\t\n          RETURN\n    2     SIGN3 = 0\t\n          RETURN\n    3     SIGN3 = +1\t\n        END FUNCTION SIGN3\t\n      END MODULE FACTORSTUFF\t\n       PROGRAM THREEWAYS\t\n       USE FACTORSTUFF\t\t\n       INTEGER I\t\t\n       INTEGER TEST(LOTS)\t\n        WRITE (6,*) \"Inspecting sums of proper divisors for 1 to\",LOTS\n        CALL PREPARESUMF\t\t\n        FORALL(I = 1:LOTS) TEST(I) = SIGN3(KNOWNSUM(I) - I)\t\n        WRITE (6,*) \"Deficient\",COUNT(TEST .LT. 0)\t\n        WRITE (6,*) \"Perfect\n        WRITE (6,*) \"Abundant \",COUNT(TEST .GT. 0)\t\n      END\t\t\t\n", "target": ">>> from proper_divisors import proper_divs\n>>> from collections import Counter\n>>> \n>>> rangemax = 20000\n>>> \n>>> def pdsum(n):\n...     return sum(proper_divs(n))\n... \n>>> def classify(n, p):\n...     return 'perfect' if n == p else 'abundant' if p > n else 'deficient'\n... \n>>> classes = Counter(classify(n, pdsum(n)) for n in range(1, 1 + rangemax))\n>>> classes.most_common()\n[('deficient', 15043), ('abundant', 4953), ('perfect', 4)]\n>>>\n"}
{"id": 74806, "name": "Leonardo numbers", "source": "Translate Fortran to C#:       SUBROUTINE LEONARDO(LAST,L0,L1,AF)\t\n       INTEGER LAST\t\n       INTEGER L0,L1\t\n       INTEGER AF\t\n       OPTIONAL AF\t\n       INTEGER EMBOLISM\t\n       INTEGER N,LN,LNL1,LNL2\t\n        IF (PRESENT(AF)) THEN\t\n          EMBOLISM = AF\t\t\t\n         ELSE\t\t\t\n          EMBOLISM = 1\t\t\t\n        END IF\t\t\t\n        WRITE (6,1) LAST,L0,L1,EMBOLISM\t\n    1   FORMAT (\"The first \",I0,\t\n     1   \" numbers in the Leonardo sequence defined by L(0) = \",I0,\n     2   \" and L(1) = \",I0,\" with L(n) = L(n - 1) + L(n - 2) + \",I0)\n        IF (LAST .GE. 1) WRITE (6,2) L0\t\n        IF (LAST .GE. 2) WRITE (6,2) L1\t\n    2   FORMAT (I0,\", \",$)\t\n        LNL1 = L0\t\n        LN = L1\t\t\n        DO N = 3,LAST\t\n          LNL2 = LNL1\t\t\n          LNL1 = LN\t\t\n          LN = LNL1 + LNL2 + EMBOLISM\t\n          WRITE (6,2) LN\t\n        END DO\t\t\n        WRITE (6,*)\t\n      END SUBROUTINE LEONARDO\t\n\n      PROGRAM POKE\n\n      CALL LEONARDO(25,1,1,1)\t\n      CALL LEONARDO(25,0,1,0)\t\n      END\n", "target": "using System;\nusing System.Linq;\n\npublic class Program\n{\n    public static void Main() {\n        Console.WriteLine(string.Join(\" \", Leonardo().Take(25)));\n        Console.WriteLine(string.Join(\" \", Leonardo(L0: 0, L1: 1, add: 0).Take(25)));\n    }\n\n    public static IEnumerable<int> Leonardo(int L0 = 1, int L1 = 1, int add = 1) {\n        while (true) {\n            yield return L0;\n            (L0, L1) = (L1, L0 + L1 + add);\n        }\n    }\n}\n"}
{"id": 74809, "name": "Leonardo numbers", "source": "Translate Fortran to Java:       SUBROUTINE LEONARDO(LAST,L0,L1,AF)\t\n       INTEGER LAST\t\n       INTEGER L0,L1\t\n       INTEGER AF\t\n       OPTIONAL AF\t\n       INTEGER EMBOLISM\t\n       INTEGER N,LN,LNL1,LNL2\t\n        IF (PRESENT(AF)) THEN\t\n          EMBOLISM = AF\t\t\t\n         ELSE\t\t\t\n          EMBOLISM = 1\t\t\t\n        END IF\t\t\t\n        WRITE (6,1) LAST,L0,L1,EMBOLISM\t\n    1   FORMAT (\"The first \",I0,\t\n     1   \" numbers in the Leonardo sequence defined by L(0) = \",I0,\n     2   \" and L(1) = \",I0,\" with L(n) = L(n - 1) + L(n - 2) + \",I0)\n        IF (LAST .GE. 1) WRITE (6,2) L0\t\n        IF (LAST .GE. 2) WRITE (6,2) L1\t\n    2   FORMAT (I0,\", \",$)\t\n        LNL1 = L0\t\n        LN = L1\t\t\n        DO N = 3,LAST\t\n          LNL2 = LNL1\t\t\n          LNL1 = LN\t\t\n          LN = LNL1 + LNL2 + EMBOLISM\t\n          WRITE (6,2) LN\t\n        END DO\t\t\n        WRITE (6,*)\t\n      END SUBROUTINE LEONARDO\t\n\n      PROGRAM POKE\n\n      CALL LEONARDO(25,1,1,1)\t\n      CALL LEONARDO(25,0,1,0)\t\n      END\n", "target": "import java.util.Arrays;\nimport java.util.List;\n\n@SuppressWarnings(\"SameParameterValue\")\npublic class LeonardoNumbers {\n    private static List<Integer> leonardo(int n) {\n        return leonardo(n, 1, 1, 1);\n    }\n\n    private static List<Integer> leonardo(int n, int l0, int l1, int add) {\n        Integer[] leo = new Integer[n];\n        leo[0] = l0;\n        leo[1] = l1;\n        for (int i = 2; i < n; i++) {\n            leo[i] = leo[i - 1] + leo[i - 2] + add;\n        }\n        return Arrays.asList(leo);\n    }\n\n    public static void main(String[] args) {\n        System.out.println(\"The first 25 Leonardo numbers with L[0] = 1, L[1] = 1 and add number = 1 are:\");\n        System.out.println(leonardo(25));\n        System.out.println(\"\\nThe first 25 Leonardo numbers with L[0] = 0, L[1] = 1 and add number = 0 are:\");\n        System.out.println(leonardo(25, 0, 1, 0));\n    }\n}\n"}
{"id": 74810, "name": "Leonardo numbers", "source": "Translate Fortran to Python:       SUBROUTINE LEONARDO(LAST,L0,L1,AF)\t\n       INTEGER LAST\t\n       INTEGER L0,L1\t\n       INTEGER AF\t\n       OPTIONAL AF\t\n       INTEGER EMBOLISM\t\n       INTEGER N,LN,LNL1,LNL2\t\n        IF (PRESENT(AF)) THEN\t\n          EMBOLISM = AF\t\t\t\n         ELSE\t\t\t\n          EMBOLISM = 1\t\t\t\n        END IF\t\t\t\n        WRITE (6,1) LAST,L0,L1,EMBOLISM\t\n    1   FORMAT (\"The first \",I0,\t\n     1   \" numbers in the Leonardo sequence defined by L(0) = \",I0,\n     2   \" and L(1) = \",I0,\" with L(n) = L(n - 1) + L(n - 2) + \",I0)\n        IF (LAST .GE. 1) WRITE (6,2) L0\t\n        IF (LAST .GE. 2) WRITE (6,2) L1\t\n    2   FORMAT (I0,\", \",$)\t\n        LNL1 = L0\t\n        LN = L1\t\t\n        DO N = 3,LAST\t\n          LNL2 = LNL1\t\t\n          LNL1 = LN\t\t\n          LN = LNL1 + LNL2 + EMBOLISM\t\n          WRITE (6,2) LN\t\n        END DO\t\t\n        WRITE (6,*)\t\n      END SUBROUTINE LEONARDO\t\n\n      PROGRAM POKE\n\n      CALL LEONARDO(25,1,1,1)\t\n      CALL LEONARDO(25,0,1,0)\t\n      END\n", "target": "def Leonardo(L_Zero, L_One, Add, Amount):\n    terms = [L_Zero,L_One]\n    while len(terms) < Amount:\n        new = terms[-1] + terms[-2]\n        new += Add\n        terms.append(new)\n    return terms\n\nout = \"\"\nprint \"First 25 Leonardo numbers:\"\nfor term in Leonardo(1,1,1,25):\n    out += str(term) + \" \"\nprint out\n\nout = \"\"\nprint \"Leonardo numbers with fibonacci parameters:\"\nfor term in Leonardo(0,1,0,25):\n    out += str(term) + \" \"\nprint out\n"}
{"id": 74979, "name": "Variadic function", "source": "Translate Fortran to C#: program varargs\n\n  integer, dimension(:), allocatable :: va\n  integer :: i\n\n  \n  call v_func()\n  call v_func( (/ 100 /) )\n  call v_func( (/ 90, 20, 30 /) )\n\n  \n  allocate(va(5))\n  va = (/ (i,i=1,5) /)\n  call v_func(va)\n  deallocate(va)\n\ncontains\n\n  subroutine v_func(arglist)\n    integer, dimension(:), intent(in), optional :: arglist\n\n    integer :: i\n\n    if ( present(arglist) ) then\n       do i = lbound(arglist, 1), ubound(arglist, 1)\n          print *, arglist(i)\n       end do\n    else\n       print *, \"no argument at all\"\n    end if\n  end subroutine v_func\n\nend program varargs\n", "target": "using System;\n\nclass Program {\n    static void Main(string[] args) {\n        PrintAll(\"test\", \"rosetta code\", 123, 5.6);\n    }\n\n    static void PrintAll(params object[] varargs) {\n        foreach (var i in varargs) {\n            Console.WriteLine(i);\n        }\n    }\n}\n"}
{"id": 74982, "name": "Variadic function", "source": "Translate Fortran to Java: program varargs\n\n  integer, dimension(:), allocatable :: va\n  integer :: i\n\n  \n  call v_func()\n  call v_func( (/ 100 /) )\n  call v_func( (/ 90, 20, 30 /) )\n\n  \n  allocate(va(5))\n  va = (/ (i,i=1,5) /)\n  call v_func(va)\n  deallocate(va)\n\ncontains\n\n  subroutine v_func(arglist)\n    integer, dimension(:), intent(in), optional :: arglist\n\n    integer :: i\n\n    if ( present(arglist) ) then\n       do i = lbound(arglist, 1), ubound(arglist, 1)\n          print *, arglist(i)\n       end do\n    else\n       print *, \"no argument at all\"\n    end if\n  end subroutine v_func\n\nend program varargs\n", "target": "module VariadicFunction\n    {\n    void show(String[] strings)\n        {\n        @Inject Console console;\n        strings.forEach(s -> console.print(s));\n        }\n\n    void run()\n        {\n        show([\"hello\", \"world\"]);\n\n        String s1 = \"not\";\n        String s2 = \"a\";\n        String s3 = \"constant\";\n        String s4 = \"literal\";\n        show([s1, s2, s3, s4]);\n        }\n    }\n"}
{"id": 74983, "name": "Variadic function", "source": "Translate Fortran to Python: program varargs\n\n  integer, dimension(:), allocatable :: va\n  integer :: i\n\n  \n  call v_func()\n  call v_func( (/ 100 /) )\n  call v_func( (/ 90, 20, 30 /) )\n\n  \n  allocate(va(5))\n  va = (/ (i,i=1,5) /)\n  call v_func(va)\n  deallocate(va)\n\ncontains\n\n  subroutine v_func(arglist)\n    integer, dimension(:), intent(in), optional :: arglist\n\n    integer :: i\n\n    if ( present(arglist) ) then\n       do i = lbound(arglist, 1), ubound(arglist, 1)\n          print *, arglist(i)\n       end do\n    else\n       print *, \"no argument at all\"\n    end if\n  end subroutine v_func\n\nend program varargs\n", "target": "def print_all(*things):\n    for x in things:\n        print x\n"}
{"id": 75662, "name": "Exponentiation operator", "source": "Translate Fortran to C#: MODULE Exp_Mod\nIMPLICIT NONE\n\nINTERFACE OPERATOR (.pow.)    \n  MODULE PROCEDURE Intexp, Realexp\nEND INTERFACE\n\nCONTAINS\n\n  FUNCTION Intexp (base, exponent)\n    INTEGER :: Intexp\n    INTEGER, INTENT(IN) :: base, exponent\n    INTEGER :: i\n\n    IF (exponent < 0) THEN\n       IF (base == 1) THEN\n          Intexp = 1\n       ELSE\n          Intexp = 0\n       END IF\n       RETURN\n    END IF\n    Intexp = 1\n    DO i = 1, exponent\n      Intexp = Intexp * base\n    END DO\n  END FUNCTION IntExp\n\n  FUNCTION Realexp (base, exponent)\n    REAL :: Realexp\n    REAL, INTENT(IN) :: base\n    INTEGER, INTENT(IN) :: exponent\n    INTEGER :: i\n  \n    Realexp = 1.0\n    IF (exponent < 0) THEN\n       DO i = exponent, -1\n          Realexp = Realexp / base\n       END DO\n    ELSE  \n       DO i = 1, exponent\n          Realexp = Realexp * base\n       END DO\n    END IF\n  END FUNCTION RealExp\nEND MODULE Exp_Mod\n\nPROGRAM EXAMPLE\nUSE Exp_Mod\n  WRITE(*,*) 2.pow.30, 2.0.pow.30\nEND PROGRAM EXAMPLE\n", "target": "static void Main(string[] args)\n{\n\tConsole.WriteLine(\"5^5 = \" + Expon(5, 5));\n\tConsole.WriteLine(\"5.5^5 = \" + Expon(5.5, 5));\n\tConsole.ReadLine();\n}\n\nstatic double Expon(int Val, int Pow) \n{\n\treturn Math.Pow(Val, Pow);\n}\nstatic double Expon(double Val, int Pow)\n{\n\treturn Math.Pow(Val, Pow);\n}\n"}
{"id": 75665, "name": "Exponentiation operator", "source": "Translate Fortran to Java: MODULE Exp_Mod\nIMPLICIT NONE\n\nINTERFACE OPERATOR (.pow.)    \n  MODULE PROCEDURE Intexp, Realexp\nEND INTERFACE\n\nCONTAINS\n\n  FUNCTION Intexp (base, exponent)\n    INTEGER :: Intexp\n    INTEGER, INTENT(IN) :: base, exponent\n    INTEGER :: i\n\n    IF (exponent < 0) THEN\n       IF (base == 1) THEN\n          Intexp = 1\n       ELSE\n          Intexp = 0\n       END IF\n       RETURN\n    END IF\n    Intexp = 1\n    DO i = 1, exponent\n      Intexp = Intexp * base\n    END DO\n  END FUNCTION IntExp\n\n  FUNCTION Realexp (base, exponent)\n    REAL :: Realexp\n    REAL, INTENT(IN) :: base\n    INTEGER, INTENT(IN) :: exponent\n    INTEGER :: i\n  \n    Realexp = 1.0\n    IF (exponent < 0) THEN\n       DO i = exponent, -1\n          Realexp = Realexp / base\n       END DO\n    ELSE  \n       DO i = 1, exponent\n          Realexp = Realexp * base\n       END DO\n    END IF\n  END FUNCTION RealExp\nEND MODULE Exp_Mod\n\nPROGRAM EXAMPLE\nUSE Exp_Mod\n  WRITE(*,*) 2.pow.30, 2.0.pow.30\nEND PROGRAM EXAMPLE\n", "target": "public class Exp{\n   public static void main(String[] args){\n      System.out.println(pow(2,30));\n      System.out.println(pow(2.0,30)); \n      System.out.println(pow(2.0,-2));\n   }\n\n   public static double pow(double base, int exp){\n      if(exp < 0) return 1 / pow(base, -exp);\n      double ans = 1.0;\n      for(;exp > 0;--exp) ans *= base;\n      return ans;\n   }\n}\n"}
{"id": 75666, "name": "Exponentiation operator", "source": "Translate Fortran to Python: MODULE Exp_Mod\nIMPLICIT NONE\n\nINTERFACE OPERATOR (.pow.)    \n  MODULE PROCEDURE Intexp, Realexp\nEND INTERFACE\n\nCONTAINS\n\n  FUNCTION Intexp (base, exponent)\n    INTEGER :: Intexp\n    INTEGER, INTENT(IN) :: base, exponent\n    INTEGER :: i\n\n    IF (exponent < 0) THEN\n       IF (base == 1) THEN\n          Intexp = 1\n       ELSE\n          Intexp = 0\n       END IF\n       RETURN\n    END IF\n    Intexp = 1\n    DO i = 1, exponent\n      Intexp = Intexp * base\n    END DO\n  END FUNCTION IntExp\n\n  FUNCTION Realexp (base, exponent)\n    REAL :: Realexp\n    REAL, INTENT(IN) :: base\n    INTEGER, INTENT(IN) :: exponent\n    INTEGER :: i\n  \n    Realexp = 1.0\n    IF (exponent < 0) THEN\n       DO i = exponent, -1\n          Realexp = Realexp / base\n       END DO\n    ELSE  \n       DO i = 1, exponent\n          Realexp = Realexp * base\n       END DO\n    END IF\n  END FUNCTION RealExp\nEND MODULE Exp_Mod\n\nPROGRAM EXAMPLE\nUSE Exp_Mod\n  WRITE(*,*) 2.pow.30, 2.0.pow.30\nEND PROGRAM EXAMPLE\n", "target": "MULTIPLY = lambda x, y: x*y\n\nclass num(float):\n    \n    \n    def __pow__(self, b):\n        return reduce(MULTIPLY, [self]*b, 1)\n\n\nprint num(2).__pow__(3)\nprint num(2) ** 3\n\n\nprint num(2.3).__pow__(8)\nprint num(2.3) ** 8\n"}
{"id": 75899, "name": "Sorting algorithms_Bubble sort", "source": "Translate Fortran to C#: SUBROUTINE Bubble_Sort(a)\n  REAL, INTENT(in out), DIMENSION(:) :: a\n  REAL :: temp\n  INTEGER :: i, j\n  LOGICAL :: swapped\n \n  DO j = SIZE(a)-1, 1, -1\n    swapped = .FALSE.\n    DO i = 1, j\n      IF (a(i) > a(i+1)) THEN\n        temp = a(i)\n        a(i) = a(i+1)\n        a(i+1) = temp\n        swapped = .TRUE.\n      END IF\n    END DO\n    IF (.NOT. swapped) EXIT\n  END DO\nEND SUBROUTINE Bubble_Sort\n", "target": "using System;\nusing System.Collections.Generic;\n\nnamespace RosettaCode.BubbleSort\n{\n    public static class BubbleSortMethods\n    {\n        \n        \n        \n        public static void BubbleSort<T>(this List<T> list) where T : IComparable\n        {\n            bool madeChanges;\n            int itemCount = list.Count;\n            do\n            {\n                madeChanges = false;\n                itemCount--;\n                for (int i = 0; i < itemCount; i++)\n                {\n                    if (list[i].CompareTo(list[i + 1]) > 0)\n                    {\n                        T temp = list[i + 1];\n                        list[i + 1] = list[i];\n                        list[i] = temp;\n                        madeChanges = true;\n                    }\n                }\n            } while (madeChanges);\n        }\n    }\n\n    \n    \n    class Program\n    {\n        static void Main()\n        {\n            List<int> testList = new List<int> { 3, 7, 3, 2, 1, -4, 10, 12, 4 };\n            testList.BubbleSort();\n            foreach (var t in testList) Console.Write(t + \" \");\n        }\n    }\n}\n"}
{"id": 75902, "name": "Sorting algorithms_Bubble sort", "source": "Translate Fortran to Java: SUBROUTINE Bubble_Sort(a)\n  REAL, INTENT(in out), DIMENSION(:) :: a\n  REAL :: temp\n  INTEGER :: i, j\n  LOGICAL :: swapped\n \n  DO j = SIZE(a)-1, 1, -1\n    swapped = .FALSE.\n    DO i = 1, j\n      IF (a(i) > a(i+1)) THEN\n        temp = a(i)\n        a(i) = a(i+1)\n        a(i+1) = temp\n        swapped = .TRUE.\n      END IF\n    END DO\n    IF (.NOT. swapped) EXIT\n  END DO\nEND SUBROUTINE Bubble_Sort\n", "target": "public static <E extends Comparable<? super E>> void bubbleSort(E[] comparable) {\n    boolean changed = false;\n    do {\n        changed = false;\n        for (int a = 0; a < comparable.length - 1; a++) {\n            if (comparable[a].compareTo(comparable[a + 1]) > 0) {\n                E tmp = comparable[a];\n                comparable[a] = comparable[a + 1];\n                comparable[a + 1] = tmp;\n                changed = true;\n            }\n        }\n    } while (changed);\n}\n"}
{"id": 75903, "name": "Sorting algorithms_Bubble sort", "source": "Translate Fortran to Python: SUBROUTINE Bubble_Sort(a)\n  REAL, INTENT(in out), DIMENSION(:) :: a\n  REAL :: temp\n  INTEGER :: i, j\n  LOGICAL :: swapped\n \n  DO j = SIZE(a)-1, 1, -1\n    swapped = .FALSE.\n    DO i = 1, j\n      IF (a(i) > a(i+1)) THEN\n        temp = a(i)\n        a(i) = a(i+1)\n        a(i+1) = temp\n        swapped = .TRUE.\n      END IF\n    END DO\n    IF (.NOT. swapped) EXIT\n  END DO\nEND SUBROUTINE Bubble_Sort\n", "target": "def bubble_sort(seq):\n    \n    changed = True\n    while changed:\n        changed = False\n        for i in range(len(seq) - 1):\n            if seq[i] > seq[i+1]:\n                seq[i], seq[i+1] = seq[i+1], seq[i]\n                changed = True\n    return seq\n\nif __name__ == \"__main__\":\n   \n\n   from random import shuffle\n\n   testset = [_ for _ in range(100)]\n   testcase = testset.copy() \n   shuffle(testcase)\n   assert testcase != testset  \n   bubble_sort(testcase)\n   assert testcase == testset  \n"}
{"id": 76254, "name": "Find the missing permutation", "source": "Translate Fortran to C#: program missing_permutation\n\n  implicit none\n  character (4), dimension (23), parameter :: list =                    &\n    & (/'ABCD', 'CABD', 'ACDB', 'DACB', 'BCDA', 'ACBD', 'ADCB', 'CDAB', &\n    &   'DABC', 'BCAD', 'CADB', 'CDBA', 'CBAD', 'ABDC', 'ADBC', 'BDCA', &\n    &   'DCBA', 'BACD', 'BADC', 'BDAC', 'CBDA', 'DBCA', 'DCAB'/)\n  integer :: i, j, k\n\n  do i = 1, 4\n    j = minloc ((/(count (list (:) (i : i) == list (1) (k : k)), k = 1, 4)/), 1)\n    write (*, '(a)', advance = 'no') list (1) (j : j)\n  end do\n  write (*, *)\n\nend program missing_permutation\n", "target": "using System;\nusing System.Collections.Generic;\n\nnamespace MissingPermutation\n{\n    class Program\n    {\n        static void Main()\n        {\n            string[] given = new string[] { \"ABCD\", \"CABD\", \"ACDB\", \"DACB\", \n                                            \"BCDA\", \"ACBD\", \"ADCB\", \"CDAB\", \n                                            \"DABC\", \"BCAD\", \"CADB\", \"CDBA\", \n                                            \"CBAD\", \"ABDC\", \"ADBC\", \"BDCA\", \n                                            \"DCBA\", \"BACD\", \"BADC\", \"BDAC\", \n                                            \"CBDA\", \"DBCA\", \"DCAB\" };\n            \n            List<string> result = new List<string>();\n            permuteString(ref result, \"\", \"ABCD\");\n            \n            foreach (string a in result)            \n                if (Array.IndexOf(given, a) == -1)\n                    Console.WriteLine(a + \" is a missing Permutation\");\n        }\n\n        public static void permuteString(ref List<string> result, string beginningString, string endingString)\n        {\n            if (endingString.Length <= 1)\n            {                 \n                result.Add(beginningString + endingString);\n            }\n            else\n            {\n                for (int i = 0; i < endingString.Length; i++)\n                {                     \n                    string newString = endingString.Substring(0, i) + endingString.Substring(i + 1);\n                    permuteString(ref result, beginningString + (endingString.ToCharArray())[i], newString);                    \n                }\n            }\n        }\n    }\n}\n"}
{"id": 76255, "name": "Find the missing permutation", "source": "Translate Fortran to C#: program missing_permutation\n\n  implicit none\n  character (4), dimension (23), parameter :: list =                    &\n    & (/'ABCD', 'CABD', 'ACDB', 'DACB', 'BCDA', 'ACBD', 'ADCB', 'CDAB', &\n    &   'DABC', 'BCAD', 'CADB', 'CDBA', 'CBAD', 'ABDC', 'ADBC', 'BDCA', &\n    &   'DCBA', 'BACD', 'BADC', 'BDAC', 'CBDA', 'DBCA', 'DCAB'/)\n  integer :: i, j, k\n\n  do i = 1, 4\n    j = minloc ((/(count (list (:) (i : i) == list (1) (k : k)), k = 1, 4)/), 1)\n    write (*, '(a)', advance = 'no') list (1) (j : j)\n  end do\n  write (*, *)\n\nend program missing_permutation\n", "target": "using System;\nusing System.Collections.Generic;\n\nnamespace MissingPermutation\n{\n    class Program\n    {\n        static void Main()\n        {\n            string[] given = new string[] { \"ABCD\", \"CABD\", \"ACDB\", \"DACB\", \n                                            \"BCDA\", \"ACBD\", \"ADCB\", \"CDAB\", \n                                            \"DABC\", \"BCAD\", \"CADB\", \"CDBA\", \n                                            \"CBAD\", \"ABDC\", \"ADBC\", \"BDCA\", \n                                            \"DCBA\", \"BACD\", \"BADC\", \"BDAC\", \n                                            \"CBDA\", \"DBCA\", \"DCAB\" };\n            \n            List<string> result = new List<string>();\n            permuteString(ref result, \"\", \"ABCD\");\n            \n            foreach (string a in result)            \n                if (Array.IndexOf(given, a) == -1)\n                    Console.WriteLine(a + \" is a missing Permutation\");\n        }\n\n        public static void permuteString(ref List<string> result, string beginningString, string endingString)\n        {\n            if (endingString.Length <= 1)\n            {                 \n                result.Add(beginningString + endingString);\n            }\n            else\n            {\n                for (int i = 0; i < endingString.Length; i++)\n                {                     \n                    string newString = endingString.Substring(0, i) + endingString.Substring(i + 1);\n                    permuteString(ref result, beginningString + (endingString.ToCharArray())[i], newString);                    \n                }\n            }\n        }\n    }\n}\n"}
{"id": 76260, "name": "Find the missing permutation", "source": "Translate Fortran to Java: program missing_permutation\n\n  implicit none\n  character (4), dimension (23), parameter :: list =                    &\n    & (/'ABCD', 'CABD', 'ACDB', 'DACB', 'BCDA', 'ACBD', 'ADCB', 'CDAB', &\n    &   'DABC', 'BCAD', 'CADB', 'CDBA', 'CBAD', 'ABDC', 'ADBC', 'BDCA', &\n    &   'DCBA', 'BACD', 'BADC', 'BDAC', 'CBDA', 'DBCA', 'DCAB'/)\n  integer :: i, j, k\n\n  do i = 1, 4\n    j = minloc ((/(count (list (:) (i : i) == list (1) (k : k)), k = 1, 4)/), 1)\n    write (*, '(a)', advance = 'no') list (1) (j : j)\n  end do\n  write (*, *)\n\nend program missing_permutation\n", "target": "import java.util.ArrayList;\n\nimport com.google.common.base.Joiner;\nimport com.google.common.collect.ImmutableSet;\nimport com.google.common.collect.Lists;\n\npublic class FindMissingPermutation {\n\tpublic static void main(String[] args) {\n\t\tJoiner joiner = Joiner.on(\"\").skipNulls();\n\t\tImmutableSet<String> s = ImmutableSet.of(\"ABCD\", \"CABD\", \"ACDB\",\n\t\t\t\t\"DACB\", \"BCDA\", \"ACBD\", \"ADCB\", \"CDAB\", \"DABC\", \"BCAD\", \"CADB\",\n\t\t\t\t\"CDBA\", \"CBAD\", \"ABDC\", \"ADBC\", \"BDCA\", \"DCBA\", \"BACD\", \"BADC\",\n\t\t\t\t\"BDAC\", \"CBDA\", \"DBCA\", \"DCAB\");\n\n\t\tfor (ArrayList<Character> cs : Utils.Permutations(Lists.newArrayList(\n\t\t\t\t'A', 'B', 'C', 'D')))\n\t\t\tif (!s.contains(joiner.join(cs)))\n\t\t\t\tSystem.out.println(joiner.join(cs));\n\t}\n}\n"}
{"id": 76261, "name": "Find the missing permutation", "source": "Translate Fortran to Java: program missing_permutation\n\n  implicit none\n  character (4), dimension (23), parameter :: list =                    &\n    & (/'ABCD', 'CABD', 'ACDB', 'DACB', 'BCDA', 'ACBD', 'ADCB', 'CDAB', &\n    &   'DABC', 'BCAD', 'CADB', 'CDBA', 'CBAD', 'ABDC', 'ADBC', 'BDCA', &\n    &   'DCBA', 'BACD', 'BADC', 'BDAC', 'CBDA', 'DBCA', 'DCAB'/)\n  integer :: i, j, k\n\n  do i = 1, 4\n    j = minloc ((/(count (list (:) (i : i) == list (1) (k : k)), k = 1, 4)/), 1)\n    write (*, '(a)', advance = 'no') list (1) (j : j)\n  end do\n  write (*, *)\n\nend program missing_permutation\n", "target": "import java.util.ArrayList;\n\nimport com.google.common.base.Joiner;\nimport com.google.common.collect.ImmutableSet;\nimport com.google.common.collect.Lists;\n\npublic class FindMissingPermutation {\n\tpublic static void main(String[] args) {\n\t\tJoiner joiner = Joiner.on(\"\").skipNulls();\n\t\tImmutableSet<String> s = ImmutableSet.of(\"ABCD\", \"CABD\", \"ACDB\",\n\t\t\t\t\"DACB\", \"BCDA\", \"ACBD\", \"ADCB\", \"CDAB\", \"DABC\", \"BCAD\", \"CADB\",\n\t\t\t\t\"CDBA\", \"CBAD\", \"ABDC\", \"ADBC\", \"BDCA\", \"DCBA\", \"BACD\", \"BADC\",\n\t\t\t\t\"BDAC\", \"CBDA\", \"DBCA\", \"DCAB\");\n\n\t\tfor (ArrayList<Character> cs : Utils.Permutations(Lists.newArrayList(\n\t\t\t\t'A', 'B', 'C', 'D')))\n\t\t\tif (!s.contains(joiner.join(cs)))\n\t\t\t\tSystem.out.println(joiner.join(cs));\n\t}\n}\n"}
{"id": 76262, "name": "Find the missing permutation", "source": "Translate Fortran to Python: program missing_permutation\n\n  implicit none\n  character (4), dimension (23), parameter :: list =                    &\n    & (/'ABCD', 'CABD', 'ACDB', 'DACB', 'BCDA', 'ACBD', 'ADCB', 'CDAB', &\n    &   'DABC', 'BCAD', 'CADB', 'CDBA', 'CBAD', 'ABDC', 'ADBC', 'BDCA', &\n    &   'DCBA', 'BACD', 'BADC', 'BDAC', 'CBDA', 'DBCA', 'DCAB'/)\n  integer :: i, j, k\n\n  do i = 1, 4\n    j = minloc ((/(count (list (:) (i : i) == list (1) (k : k)), k = 1, 4)/), 1)\n    write (*, '(a)', advance = 'no') list (1) (j : j)\n  end do\n  write (*, *)\n\nend program missing_permutation\n", "target": "from itertools import permutations\n\ngiven = .split()\n\nallPerms = [''.join(x) for x in permutations(given[0])]\n\nmissing = list(set(allPerms) - set(given)) \n"}
{"id": 76263, "name": "Find the missing permutation", "source": "Translate Fortran to Python: program missing_permutation\n\n  implicit none\n  character (4), dimension (23), parameter :: list =                    &\n    & (/'ABCD', 'CABD', 'ACDB', 'DACB', 'BCDA', 'ACBD', 'ADCB', 'CDAB', &\n    &   'DABC', 'BCAD', 'CADB', 'CDBA', 'CBAD', 'ABDC', 'ADBC', 'BDCA', &\n    &   'DCBA', 'BACD', 'BADC', 'BDAC', 'CBDA', 'DBCA', 'DCAB'/)\n  integer :: i, j, k\n\n  do i = 1, 4\n    j = minloc ((/(count (list (:) (i : i) == list (1) (k : k)), k = 1, 4)/), 1)\n    write (*, '(a)', advance = 'no') list (1) (j : j)\n  end do\n  write (*, *)\n\nend program missing_permutation\n", "target": "from itertools import permutations\n\ngiven = .split()\n\nallPerms = [''.join(x) for x in permutations(given[0])]\n\nmissing = list(set(allPerms) - set(given)) \n"}
{"id": 76696, "name": "Approximate equality", "source": "Translate Fortran to C#: program main\n  implicit none\n\n  integer                       :: i\n  double precision, allocatable :: vals(:)\n\n  vals = [ 100000000000000.01d0,          100000000000000.011d0,   &\n    &      100.01d0,                      100.011d0,               &\n    &      10000000000000.001d0/10000d0,  1000000000.0000001000d0, &\n    &      0.001d0,                       0.0010000001d0,          &\n    &      0.000000000000000000000101d0,  0d0,                     &\n    &      sqrt(2d0)*sqrt(2d0),           2d0,                     &\n    &     -sqrt(2d0)*sqrt(2d0),          -2d0,                     &\n    &      3.14159265358979323846d0,      3.14159265358979324d0    ]\n\n  do i = 1, size(vals)/2\n    print '(ES30.18, A, ES30.18, A, L)', vals(2*i-1), ' == ', vals(2*i), '\u00a0? ', eq_approx(vals(2*i-1), vals(2*i))\n  end do\n\ncontains\n\n  logical function eq_approx(a, b, reltol, abstol)\n    \n\n    double precision, intent(in)           :: a, b\n      \n    double precision, intent(in), optional :: reltol, abstol\n      \n      \n\n    double precision :: rt, at\n\n    rt = epsilon(1d0)\n    at = tiny(1d0)\n    if (present(reltol)) rt = reltol\n    if (present(abstol)) at = abstol\n\n    eq_approx = abs(a - b) .le. max(rt * max(abs(a), abs(b)), at)\n    return\n  end function\n\nend program\n", "target": "using System;\n\npublic static class Program\n{\n    public static void Main() {\n        Test(100000000000000.01, 100000000000000.011);\n        Test(100.01, 100.011);\n        Test(10000000000000.001 / 10000.0, 1000000000.0000001000);\n        Test(0.001, 0.0010000001);\n        Test(0.000000000000000000000101, 0.0);\n        Test(Math.Sqrt(2) * Math.Sqrt(2), 2.0);\n        Test(-Math.Sqrt(2) * Math.Sqrt(2), -2.0);\n        Test(3.14159265358979323846, 3.14159265358979324);\n\n        void Test(double a, double b) {\n            const double epsilon = 1e-18;\n            WriteLine($\"{a}, {b} => {a.ApproxEquals(b, epsilon)}\");\n        }\n    }\n\n    public static bool ApproxEquals(this double value, double other, double epsilon) => Math.Abs(value - other) < epsilon;\n}\n"}
{"id": 76697, "name": "Approximate equality", "source": "Translate Fortran to C#: program main\n  implicit none\n\n  integer                       :: i\n  double precision, allocatable :: vals(:)\n\n  vals = [ 100000000000000.01d0,          100000000000000.011d0,   &\n    &      100.01d0,                      100.011d0,               &\n    &      10000000000000.001d0/10000d0,  1000000000.0000001000d0, &\n    &      0.001d0,                       0.0010000001d0,          &\n    &      0.000000000000000000000101d0,  0d0,                     &\n    &      sqrt(2d0)*sqrt(2d0),           2d0,                     &\n    &     -sqrt(2d0)*sqrt(2d0),          -2d0,                     &\n    &      3.14159265358979323846d0,      3.14159265358979324d0    ]\n\n  do i = 1, size(vals)/2\n    print '(ES30.18, A, ES30.18, A, L)', vals(2*i-1), ' == ', vals(2*i), '\u00a0? ', eq_approx(vals(2*i-1), vals(2*i))\n  end do\n\ncontains\n\n  logical function eq_approx(a, b, reltol, abstol)\n    \n\n    double precision, intent(in)           :: a, b\n      \n    double precision, intent(in), optional :: reltol, abstol\n      \n      \n\n    double precision :: rt, at\n\n    rt = epsilon(1d0)\n    at = tiny(1d0)\n    if (present(reltol)) rt = reltol\n    if (present(abstol)) at = abstol\n\n    eq_approx = abs(a - b) .le. max(rt * max(abs(a), abs(b)), at)\n    return\n  end function\n\nend program\n", "target": "using System;\n\npublic static class Program\n{\n    public static void Main() {\n        Test(100000000000000.01, 100000000000000.011);\n        Test(100.01, 100.011);\n        Test(10000000000000.001 / 10000.0, 1000000000.0000001000);\n        Test(0.001, 0.0010000001);\n        Test(0.000000000000000000000101, 0.0);\n        Test(Math.Sqrt(2) * Math.Sqrt(2), 2.0);\n        Test(-Math.Sqrt(2) * Math.Sqrt(2), -2.0);\n        Test(3.14159265358979323846, 3.14159265358979324);\n\n        void Test(double a, double b) {\n            const double epsilon = 1e-18;\n            WriteLine($\"{a}, {b} => {a.ApproxEquals(b, epsilon)}\");\n        }\n    }\n\n    public static bool ApproxEquals(this double value, double other, double epsilon) => Math.Abs(value - other) < epsilon;\n}\n"}
{"id": 76702, "name": "Approximate equality", "source": "Translate Fortran to Java: program main\n  implicit none\n\n  integer                       :: i\n  double precision, allocatable :: vals(:)\n\n  vals = [ 100000000000000.01d0,          100000000000000.011d0,   &\n    &      100.01d0,                      100.011d0,               &\n    &      10000000000000.001d0/10000d0,  1000000000.0000001000d0, &\n    &      0.001d0,                       0.0010000001d0,          &\n    &      0.000000000000000000000101d0,  0d0,                     &\n    &      sqrt(2d0)*sqrt(2d0),           2d0,                     &\n    &     -sqrt(2d0)*sqrt(2d0),          -2d0,                     &\n    &      3.14159265358979323846d0,      3.14159265358979324d0    ]\n\n  do i = 1, size(vals)/2\n    print '(ES30.18, A, ES30.18, A, L)', vals(2*i-1), ' == ', vals(2*i), '\u00a0? ', eq_approx(vals(2*i-1), vals(2*i))\n  end do\n\ncontains\n\n  logical function eq_approx(a, b, reltol, abstol)\n    \n\n    double precision, intent(in)           :: a, b\n      \n    double precision, intent(in), optional :: reltol, abstol\n      \n      \n\n    double precision :: rt, at\n\n    rt = epsilon(1d0)\n    at = tiny(1d0)\n    if (present(reltol)) rt = reltol\n    if (present(abstol)) at = abstol\n\n    eq_approx = abs(a - b) .le. max(rt * max(abs(a), abs(b)), at)\n    return\n  end function\n\nend program\n", "target": "public class Approximate {\n    private static boolean approxEquals(double value, double other, double epsilon) {\n        return Math.abs(value - other) < epsilon;\n    }\n\n    private static void test(double a, double b) {\n        double epsilon = 1e-18;\n        System.out.printf(\"%f, %f => %s\\n\", a, b, approxEquals(a, b, epsilon));\n    }\n\n    public static void main(String[] args) {\n        test(100000000000000.01, 100000000000000.011);\n        test(100.01, 100.011);\n        test(10000000000000.001 / 10000.0, 1000000000.0000001000);\n        test(0.001, 0.0010000001);\n        test(0.000000000000000000000101, 0.0);\n        test(Math.sqrt(2.0) * Math.sqrt(2.0), 2.0);\n        test(-Math.sqrt(2.0) * Math.sqrt(2.0), -2.0);\n        test(3.14159265358979323846, 3.14159265358979324);\n    }\n}\n"}
{"id": 76703, "name": "Approximate equality", "source": "Translate Fortran to Java: program main\n  implicit none\n\n  integer                       :: i\n  double precision, allocatable :: vals(:)\n\n  vals = [ 100000000000000.01d0,          100000000000000.011d0,   &\n    &      100.01d0,                      100.011d0,               &\n    &      10000000000000.001d0/10000d0,  1000000000.0000001000d0, &\n    &      0.001d0,                       0.0010000001d0,          &\n    &      0.000000000000000000000101d0,  0d0,                     &\n    &      sqrt(2d0)*sqrt(2d0),           2d0,                     &\n    &     -sqrt(2d0)*sqrt(2d0),          -2d0,                     &\n    &      3.14159265358979323846d0,      3.14159265358979324d0    ]\n\n  do i = 1, size(vals)/2\n    print '(ES30.18, A, ES30.18, A, L)', vals(2*i-1), ' == ', vals(2*i), '\u00a0? ', eq_approx(vals(2*i-1), vals(2*i))\n  end do\n\ncontains\n\n  logical function eq_approx(a, b, reltol, abstol)\n    \n\n    double precision, intent(in)           :: a, b\n      \n    double precision, intent(in), optional :: reltol, abstol\n      \n      \n\n    double precision :: rt, at\n\n    rt = epsilon(1d0)\n    at = tiny(1d0)\n    if (present(reltol)) rt = reltol\n    if (present(abstol)) at = abstol\n\n    eq_approx = abs(a - b) .le. max(rt * max(abs(a), abs(b)), at)\n    return\n  end function\n\nend program\n", "target": "public class Approximate {\n    private static boolean approxEquals(double value, double other, double epsilon) {\n        return Math.abs(value - other) < epsilon;\n    }\n\n    private static void test(double a, double b) {\n        double epsilon = 1e-18;\n        System.out.printf(\"%f, %f => %s\\n\", a, b, approxEquals(a, b, epsilon));\n    }\n\n    public static void main(String[] args) {\n        test(100000000000000.01, 100000000000000.011);\n        test(100.01, 100.011);\n        test(10000000000000.001 / 10000.0, 1000000000.0000001000);\n        test(0.001, 0.0010000001);\n        test(0.000000000000000000000101, 0.0);\n        test(Math.sqrt(2.0) * Math.sqrt(2.0), 2.0);\n        test(-Math.sqrt(2.0) * Math.sqrt(2.0), -2.0);\n        test(3.14159265358979323846, 3.14159265358979324);\n    }\n}\n"}
{"id": 76704, "name": "Approximate equality", "source": "Translate Fortran to Python: program main\n  implicit none\n\n  integer                       :: i\n  double precision, allocatable :: vals(:)\n\n  vals = [ 100000000000000.01d0,          100000000000000.011d0,   &\n    &      100.01d0,                      100.011d0,               &\n    &      10000000000000.001d0/10000d0,  1000000000.0000001000d0, &\n    &      0.001d0,                       0.0010000001d0,          &\n    &      0.000000000000000000000101d0,  0d0,                     &\n    &      sqrt(2d0)*sqrt(2d0),           2d0,                     &\n    &     -sqrt(2d0)*sqrt(2d0),          -2d0,                     &\n    &      3.14159265358979323846d0,      3.14159265358979324d0    ]\n\n  do i = 1, size(vals)/2\n    print '(ES30.18, A, ES30.18, A, L)', vals(2*i-1), ' == ', vals(2*i), '\u00a0? ', eq_approx(vals(2*i-1), vals(2*i))\n  end do\n\ncontains\n\n  logical function eq_approx(a, b, reltol, abstol)\n    \n\n    double precision, intent(in)           :: a, b\n      \n    double precision, intent(in), optional :: reltol, abstol\n      \n      \n\n    double precision :: rt, at\n\n    rt = epsilon(1d0)\n    at = tiny(1d0)\n    if (present(reltol)) rt = reltol\n    if (present(abstol)) at = abstol\n\n    eq_approx = abs(a - b) .le. max(rt * max(abs(a), abs(b)), at)\n    return\n  end function\n\nend program\n", "target": "from numpy import sqrt\nfrom math import isclose\n\ntestvalues = [[100000000000000.01,           100000000000000.011],\n              [100.01,                       100.011],\n              [10000000000000.001 / 10000.0, 1000000000.0000001000],\n              [0.001,                        0.0010000001],\n              [0.000000000000000000000101,   0.0],\n              [sqrt(2) * sqrt(2),            2.0],\n              [-sqrt(2) * sqrt(2),          -2.0],\n              [3.14159265358979323846,       3.14159265358979324]]\n\nfor (x, y) in testvalues:\n    maybenot = \"is\" if isclose(x, y) else \"is NOT\"\n    print(x, maybenot, \"approximately equal to \", y)\n"}
{"id": 76705, "name": "Approximate equality", "source": "Translate Fortran to Python: program main\n  implicit none\n\n  integer                       :: i\n  double precision, allocatable :: vals(:)\n\n  vals = [ 100000000000000.01d0,          100000000000000.011d0,   &\n    &      100.01d0,                      100.011d0,               &\n    &      10000000000000.001d0/10000d0,  1000000000.0000001000d0, &\n    &      0.001d0,                       0.0010000001d0,          &\n    &      0.000000000000000000000101d0,  0d0,                     &\n    &      sqrt(2d0)*sqrt(2d0),           2d0,                     &\n    &     -sqrt(2d0)*sqrt(2d0),          -2d0,                     &\n    &      3.14159265358979323846d0,      3.14159265358979324d0    ]\n\n  do i = 1, size(vals)/2\n    print '(ES30.18, A, ES30.18, A, L)', vals(2*i-1), ' == ', vals(2*i), '\u00a0? ', eq_approx(vals(2*i-1), vals(2*i))\n  end do\n\ncontains\n\n  logical function eq_approx(a, b, reltol, abstol)\n    \n\n    double precision, intent(in)           :: a, b\n      \n    double precision, intent(in), optional :: reltol, abstol\n      \n      \n\n    double precision :: rt, at\n\n    rt = epsilon(1d0)\n    at = tiny(1d0)\n    if (present(reltol)) rt = reltol\n    if (present(abstol)) at = abstol\n\n    eq_approx = abs(a - b) .le. max(rt * max(abs(a), abs(b)), at)\n    return\n  end function\n\nend program\n", "target": "from numpy import sqrt\nfrom math import isclose\n\ntestvalues = [[100000000000000.01,           100000000000000.011],\n              [100.01,                       100.011],\n              [10000000000000.001 / 10000.0, 1000000000.0000001000],\n              [0.001,                        0.0010000001],\n              [0.000000000000000000000101,   0.0],\n              [sqrt(2) * sqrt(2),            2.0],\n              [-sqrt(2) * sqrt(2),          -2.0],\n              [3.14159265358979323846,       3.14159265358979324]]\n\nfor (x, y) in testvalues:\n    maybenot = \"is\" if isclose(x, y) else \"is NOT\"\n    print(x, maybenot, \"approximately equal to \", y)\n"}
{"id": 77017, "name": "Greatest common divisor", "source": "Translate Fortran to C#: recursive function gcd_rec(u, v) result(gcd)\n    integer             :: gcd\n    integer, intent(in) :: u, v\n    \n    if (mod(u, v) /= 0) then\n        gcd = gcd_rec(v, mod(u, v))\n    else\n        gcd = v\n    end if\nend function gcd_rec\n", "target": "static void Main()\n{\n\tConsole.WriteLine(\"GCD of {0} and {1} is {2}\", 1, 1, gcd(1, 1));\n\tConsole.WriteLine(\"GCD of {0} and {1} is {2}\", 1, 10, gcd(1, 10));\n\tConsole.WriteLine(\"GCD of {0} and {1} is {2}\", 10, 100, gcd(10, 100));\n\tConsole.WriteLine(\"GCD of {0} and {1} is {2}\", 5, 50, gcd(5, 50));\n\tConsole.WriteLine(\"GCD of {0} and {1} is {2}\", 8, 24, gcd(8, 24));\n\tConsole.WriteLine(\"GCD of {0} and {1} is {2}\", 36, 17, gcd(36, 17));\n\tConsole.WriteLine(\"GCD of {0} and {1} is {2}\", 36, 18, gcd(36, 18));\n\tConsole.WriteLine(\"GCD of {0} and {1} is {2}\", 36, 19, gcd(36, 19));\n\tfor (int x = 1; x < 36; x++)\n\t{\n\t\tConsole.WriteLine(\"GCD of {0} and {1} is {2}\", 36, x, gcd(36, x));\n\t}\n\tConsole.Read();\n}\n \n\n\n\nstatic int gcd(int a, int b)\n{\n    while (b != 0) b = a % (a = b);\n    return a;\n}\n"}
{"id": 77020, "name": "Greatest common divisor", "source": "Translate Fortran to Java: recursive function gcd_rec(u, v) result(gcd)\n    integer             :: gcd\n    integer, intent(in) :: u, v\n    \n    if (mod(u, v) /= 0) then\n        gcd = gcd_rec(v, mod(u, v))\n    else\n        gcd = v\n    end if\nend function gcd_rec\n", "target": "public static long gcd(long a, long b){\n   long factor= Math.min(a, b);\n   for(long loop= factor;loop > 1;loop--){\n      if(a % loop == 0 && b % loop == 0){\n         return loop;\n      }\n   }\n   return 1;\n}\n"}
{"id": 77021, "name": "Greatest common divisor", "source": "Translate Fortran to Python: recursive function gcd_rec(u, v) result(gcd)\n    integer             :: gcd\n    integer, intent(in) :: u, v\n    \n    if (mod(u, v) /= 0) then\n        gcd = gcd_rec(v, mod(u, v))\n    else\n        gcd = v\n    end if\nend function gcd_rec\n", "target": "from fractions import gcd\n"}
{"id": 77297, "name": "Luhn test of credit card numbers", "source": "Translate Fortran to C#: program luhn\n  implicit none\n  integer              :: nargs\n  character(len=20)    :: arg\n  integer              :: alen, i, dr\n  integer, allocatable :: number(:)\n  integer, parameter   :: drmap(0:9) = [0, 2, 4, 6, 8, 1, 3, 5, 7, 9]\n\n  \n  nargs = command_argument_count()\n  if (nargs /= 1) then\n     stop\n  end if\n  call get_command_argument(1, arg, alen)\n  allocate(number(alen))\n  do i=1, alen\n     number(alen-i+1) = iachar(arg(i:i)) - iachar('0')\n  end do\n\n  \n  dr = 0\n  do i=1, alen\n     dr = dr + merge(drmap(number(i)), number(i), mod(i,2) == 0)\n  end do\n\n  if (mod(dr,10) == 0) then\n     write(*,'(a,i0)') arg(1:alen)//' is valid'\n  else\n     write(*,'(a,i0)') arg(1:alen)//' is not valid'\n  end if\nend program luhn\n\n\n\n\n\n\n", "target": "    public static class Luhn\n    {\n        public static bool LuhnCheck(this string cardNumber)\n        {\n            return LuhnCheck(cardNumber.Select(c => c - '0').ToArray());\n        }\n\n        private static bool LuhnCheck(this int[] digits)\n        {\n            return GetCheckValue(digits) == 0;\n        }\n\n        private static int GetCheckValue(int[] digits)\n        {\n            return digits.Select((d, i) => i % 2 == digits.Length % 2 ? ((2 * d) % 10) + d / 5 : d).Sum() % 10;\n        }\n    }\n\n    public static class TestProgram\n    {\n        public static void Main()\n        {\n            long[] testNumbers = {49927398716, 49927398717, 1234567812345678, 1234567812345670};\n            foreach (var testNumber in testNumbers)\n                Console.WriteLine(\"{0} is {1}valid\", testNumber, testNumber.ToString().LuhnCheck() ? \"\" : \"not \");\n        }\n    }\n"}
{"id": 77300, "name": "Luhn test of credit card numbers", "source": "Translate Fortran to Java: program luhn\n  implicit none\n  integer              :: nargs\n  character(len=20)    :: arg\n  integer              :: alen, i, dr\n  integer, allocatable :: number(:)\n  integer, parameter   :: drmap(0:9) = [0, 2, 4, 6, 8, 1, 3, 5, 7, 9]\n\n  \n  nargs = command_argument_count()\n  if (nargs /= 1) then\n     stop\n  end if\n  call get_command_argument(1, arg, alen)\n  allocate(number(alen))\n  do i=1, alen\n     number(alen-i+1) = iachar(arg(i:i)) - iachar('0')\n  end do\n\n  \n  dr = 0\n  do i=1, alen\n     dr = dr + merge(drmap(number(i)), number(i), mod(i,2) == 0)\n  end do\n\n  if (mod(dr,10) == 0) then\n     write(*,'(a,i0)') arg(1:alen)//' is valid'\n  else\n     write(*,'(a,i0)') arg(1:alen)//' is not valid'\n  end if\nend program luhn\n\n\n\n\n\n\n", "target": "public class Luhn {\n    public static void main(String[] args) {\n        System.out.println(luhnTest(\"49927398716\"));\n        System.out.println(luhnTest(\"49927398717\"));\n        System.out.println(luhnTest(\"1234567812345678\"));\n        System.out.println(luhnTest(\"1234567812345670\"));\n    }\n    \n    public static boolean luhnTest(String number){\n        int s1 = 0, s2 = 0;\n        String reverse = new StringBuffer(number).reverse().toString();\n        for(int i = 0 ;i < reverse.length();i++){\n            int digit = Character.digit(reverse.charAt(i), 10);\n            if(i % 2 == 0){\n                s1 += digit;\n            }else{\n                s2 += 2 * digit;\n                if(digit >= 5){\n                    s2 -= 9;\n                }\n            }\n        }\n        return (s1 + s2) % 10 == 0;\n    }\n}\n"}
{"id": 77301, "name": "Luhn test of credit card numbers", "source": "Translate Fortran to Python: program luhn\n  implicit none\n  integer              :: nargs\n  character(len=20)    :: arg\n  integer              :: alen, i, dr\n  integer, allocatable :: number(:)\n  integer, parameter   :: drmap(0:9) = [0, 2, 4, 6, 8, 1, 3, 5, 7, 9]\n\n  \n  nargs = command_argument_count()\n  if (nargs /= 1) then\n     stop\n  end if\n  call get_command_argument(1, arg, alen)\n  allocate(number(alen))\n  do i=1, alen\n     number(alen-i+1) = iachar(arg(i:i)) - iachar('0')\n  end do\n\n  \n  dr = 0\n  do i=1, alen\n     dr = dr + merge(drmap(number(i)), number(i), mod(i,2) == 0)\n  end do\n\n  if (mod(dr,10) == 0) then\n     write(*,'(a,i0)') arg(1:alen)//' is valid'\n  else\n     write(*,'(a,i0)') arg(1:alen)//' is not valid'\n  end if\nend program luhn\n\n\n\n\n\n\n", "target": ">>> def luhn(n):\n\tr = [int(ch) for ch in str(n)][::-1]\n\treturn (sum(r[0::2]) + sum(sum(divmod(d*2,10)) for d in r[1::2])) % 10 == 0\n\n>>> for n in (49927398716, 49927398717, 1234567812345678, 1234567812345670):\n\tprint(n, luhn(n))\n"}
{"id": 77578, "name": "Sorting algorithms_Quicksort", "source": "Translate Fortran to C#: MODULE qsort_mod\n\n  IMPLICIT NONE\n\n  TYPE group\n     INTEGER :: order    \n     REAL    :: VALUE    \n  END TYPE group\n\nCONTAINS\n\n  RECURSIVE SUBROUTINE QSort(a,na)\n\n    \n    INTEGER, INTENT(in) :: nA\n    TYPE (group), DIMENSION(nA), INTENT(in out) :: A\n\n    \n    INTEGER :: left, right\n    REAL :: random\n    REAL :: pivot\n    TYPE (group) :: temp\n    INTEGER :: marker\n\n    IF (nA > 1) THEN\n\n       CALL random_NUMBER(random)\n       pivot = A(INT(random*REAL(nA-1))+1)%VALUE   \n       left = 1\n       right = nA\n       \n       DO\n          IF (left >= right) EXIT\n          DO\n             IF (A(right)%VALUE <= pivot) EXIT\n             right = right - 1\n          END DO\n          DO\n             IF (A(left)%VALUE >= pivot) EXIT\n             left = left + 1\n          END DO\n          IF (left < right) THEN\n             temp = A(left)\n             A(left) = A(right)\n             A(right) = temp\n          END IF\n       END DO\n\n       IF (left == right) THEN\n          marker = left + 1\n       ELSE\n          marker = left\n       END IF\n\n       CALL QSort(A(:marker-1),marker-1)\n       CALL QSort(A(marker:),nA-marker+1)\n\n    END IF\n\n  END SUBROUTINE QSort\n\nEND MODULE qsort_mod\n     \n\nPROGRAM qsort_test\n  USE qsort_mod\n  IMPLICIT NONE\n\n  INTEGER, PARAMETER :: nl = 10, nc = 5, l = nc*nl, ns=33\n  TYPE (group), DIMENSION(l) :: A\n  INTEGER, DIMENSION(ns) :: seed\n  INTEGER :: i\n  REAL :: random\n  CHARACTER(LEN=80) :: fmt1, fmt2\n  \n  seed(1) = 1 ; seed(2) = 1\n  DO i = 3,ns\n     seed(i) = seed(i-1)+seed(i-2)\n  END DO\n  \n  WRITE(fmt1,'(A,I2,A)') '(', nc, '(I5,2X,F6.2))'\n  WRITE(fmt2,'(A,I2,A)') '(3x', nc, '(\"Ord.  Num.\",3x))' \n  PRINT *, \"Unsorted Values:\"\n  PRINT fmt2,\n  CALL random_SEED(put = seed)\n  DO i = 1, l\n     CALL random_NUMBER(random)\n     A(i)%VALUE = NINT(1000*random)/10.0\n     A(i)%order = i\n     IF (MOD(i,nc) == 0) WRITE (*,fmt1) A(i-nc+1:i)\n  END DO\n  PRINT *\n  CALL QSort(A,l)\n  PRINT *, \"Sorted Values:\"\n  PRINT fmt2,\n  DO i = nc, l, nc\n     IF (MOD(i,nc) == 0) WRITE (*,fmt1) A(i-nc+1:i)\n  END DO\n  STOP\nEND PROGRAM qsort_test\n", "target": "\n\n\n\n\n#define Tripartite\n\nnamespace RosettaCode {\n  using System;\n  using System.Diagnostics;\n\n  public class QuickSort<T> where T : IComparable {\n    #region Constants\n    public const UInt32 INSERTION_LIMIT_DEFAULT = 12;\n    private const Int32 SAMPLES_MAX = 19;\n    #endregion\n\n    #region Properties\n    public UInt32 InsertionLimit { get; }\n    private T[] Samples { get; }\n    private Int32 Left { get; set; }\n    private Int32 Right { get; set; }\n    private Int32 LeftMedian { get; set; }\n    private Int32 RightMedian { get; set; }\n    #endregion\n\n    #region Constructors\n    public QuickSort(UInt32 insertionLimit = INSERTION_LIMIT_DEFAULT) {\n      this.InsertionLimit = insertionLimit;\n      this.Samples = new T[SAMPLES_MAX];\n    }\n    #endregion\n\n    #region Sort Methods\n    public void Sort(T[] entries) {\n      Sort(entries, 0, entries.Length - 1);\n    }\n\n    public void Sort(T[] entries, Int32 first, Int32 last) {\n      var length = last + 1 - first;\n      while (length > 1) {\n        if (length < InsertionLimit) {\n          InsertionSort<T>.Sort(entries, first, last);\n          return;\n        }\n\n        Left = first;\n        Right = last;\n        var median = pivot(entries);\n        partition(median, entries);\n        \n\n        var leftLength = Right + 1 - first;\n        var rightLength = last + 1 - Left;\n\n        \n        \n        \n        \n        if (leftLength < rightLength) {\n          Sort(entries, first, Right);\n          first = Left;\n          length = rightLength;\n        }\n        else {\n          Sort(entries, Left, last);\n          last = Right;\n          length = leftLength;\n        }\n      }\n    }\n\n    \n    private static Int32 sampleSize(Int32 length, Int32 max = SAMPLES_MAX) {\n      var logLen = (Int32)Math.Log10(length);\n      var samples = Math.Min(2 * logLen + 1, max);\n      return Math.Min(samples, length);\n    }\n\n    \n    \n    private T pivot(T[] entries) {\n      var length = Right + 1 - Left;\n      var samples = sampleSize(length);\n      \n      for (var sample = 0; sample < samples; sample++) {\n        \n        var index = (Int64)length * sample / samples + Left;\n        Samples[sample] = entries[index];\n      }\n\n      InsertionSort<T>.Sort(Samples, 0, samples - 1);\n      return Samples[samples / 2];\n    }\n\n    private void partition(T median, T[] entries) {\n      var first = Left;\n      var last = Right;\n#if Tripartite\n      LeftMedian = first;\n      RightMedian = last;\n#endif\n      while (true) {\n        \n        \n        \n        while (median.CompareTo(entries[Left]) > 0) Left++;\n        while (median.CompareTo(entries[Right]) < 0) Right--;\n\n        \n        if (Right <= Left) break;\n\n        Swap(entries, Left, Right);\n        swapOut(median, entries);\n        Left++;\n        Right--;\n        \n      }\n\n      if (Left == Right) {\n        Left++;\n        Right--;\n      }\n      \n      swapIn(entries, first, last);\n\n      \n      \n    }\n    #endregion\n\n    #region Swap Methods\n    [Conditional(\"Tripartite\")]\n    private void swapOut(T median, T[] entries) {\n      if (median.CompareTo(entries[Left]) == 0) Swap(entries, LeftMedian++, Left);\n      if (median.CompareTo(entries[Right]) == 0) Swap(entries, Right, RightMedian--);\n    }\n\n    [Conditional(\"Tripartite\")]\n    private void swapIn(T[] entries, Int32 first, Int32 last) {\n      \n      while (first < LeftMedian) Swap(entries, first++, Right--);\n      while (RightMedian < last) Swap(entries, Left++, last--);\n    }\n\n    \n    public void Swap(T[] entries, Int32 left, Int32 right) {\n      Swap(ref entries[left], ref entries[right]);\n    }\n\n    \n    public static void Swap(ref T e1, ref T e2) {\n      var e = e1;\n      e1 = e2;\n      e2 = e;\n    }\n    #endregion\n  }\n\n  #region Insertion Sort\n  static class InsertionSort<T> where T : IComparable {\n    public static void Sort(T[] entries, Int32 first, Int32 last) {\n      for (var next = first + 1; next <= last; next++)\n        insert(entries, first, next);\n    }\n\n    \n    private static void insert(T[] entries, Int32 first, Int32 next) {\n      var entry = entries[next];\n      while (next > first && entries[next - 1].CompareTo(entry) > 0)\n        entries[next] = entries[--next];\n      entries[next] = entry;\n    }\n  }\n  #endregion\n}\n"}
{"id": 77581, "name": "Sorting algorithms_Quicksort", "source": "Translate Fortran to Java: MODULE qsort_mod\n\n  IMPLICIT NONE\n\n  TYPE group\n     INTEGER :: order    \n     REAL    :: VALUE    \n  END TYPE group\n\nCONTAINS\n\n  RECURSIVE SUBROUTINE QSort(a,na)\n\n    \n    INTEGER, INTENT(in) :: nA\n    TYPE (group), DIMENSION(nA), INTENT(in out) :: A\n\n    \n    INTEGER :: left, right\n    REAL :: random\n    REAL :: pivot\n    TYPE (group) :: temp\n    INTEGER :: marker\n\n    IF (nA > 1) THEN\n\n       CALL random_NUMBER(random)\n       pivot = A(INT(random*REAL(nA-1))+1)%VALUE   \n       left = 1\n       right = nA\n       \n       DO\n          IF (left >= right) EXIT\n          DO\n             IF (A(right)%VALUE <= pivot) EXIT\n             right = right - 1\n          END DO\n          DO\n             IF (A(left)%VALUE >= pivot) EXIT\n             left = left + 1\n          END DO\n          IF (left < right) THEN\n             temp = A(left)\n             A(left) = A(right)\n             A(right) = temp\n          END IF\n       END DO\n\n       IF (left == right) THEN\n          marker = left + 1\n       ELSE\n          marker = left\n       END IF\n\n       CALL QSort(A(:marker-1),marker-1)\n       CALL QSort(A(marker:),nA-marker+1)\n\n    END IF\n\n  END SUBROUTINE QSort\n\nEND MODULE qsort_mod\n     \n\nPROGRAM qsort_test\n  USE qsort_mod\n  IMPLICIT NONE\n\n  INTEGER, PARAMETER :: nl = 10, nc = 5, l = nc*nl, ns=33\n  TYPE (group), DIMENSION(l) :: A\n  INTEGER, DIMENSION(ns) :: seed\n  INTEGER :: i\n  REAL :: random\n  CHARACTER(LEN=80) :: fmt1, fmt2\n  \n  seed(1) = 1 ; seed(2) = 1\n  DO i = 3,ns\n     seed(i) = seed(i-1)+seed(i-2)\n  END DO\n  \n  WRITE(fmt1,'(A,I2,A)') '(', nc, '(I5,2X,F6.2))'\n  WRITE(fmt2,'(A,I2,A)') '(3x', nc, '(\"Ord.  Num.\",3x))' \n  PRINT *, \"Unsorted Values:\"\n  PRINT fmt2,\n  CALL random_SEED(put = seed)\n  DO i = 1, l\n     CALL random_NUMBER(random)\n     A(i)%VALUE = NINT(1000*random)/10.0\n     A(i)%order = i\n     IF (MOD(i,nc) == 0) WRITE (*,fmt1) A(i-nc+1:i)\n  END DO\n  PRINT *\n  CALL QSort(A,l)\n  PRINT *, \"Sorted Values:\"\n  PRINT fmt2,\n  DO i = nc, l, nc\n     IF (MOD(i,nc) == 0) WRITE (*,fmt1) A(i-nc+1:i)\n  END DO\n  STOP\nEND PROGRAM qsort_test\n", "target": "public static <E extends Comparable<? super E>> List<E> quickSort(List<E> arr) {\n    if (arr.isEmpty())\n        return arr;\n    else {\n        E pivot = arr.get(0);\n\n        List<E> less = new LinkedList<E>();\n        List<E> pivotList = new LinkedList<E>();\n        List<E> more = new LinkedList<E>();\n\n        \n        for (E i: arr) {\n            if (i.compareTo(pivot) < 0)\n                less.add(i);\n            else if (i.compareTo(pivot) > 0)\n                more.add(i);\n            else\n                pivotList.add(i);\n        }\n\n        \n        less = quickSort(less);\n        more = quickSort(more);\n\n        \n        less.addAll(pivotList);\n        less.addAll(more);\n        return less;\n    }\n}\n"}
{"id": 77582, "name": "Sorting algorithms_Quicksort", "source": "Translate Fortran to Python: MODULE qsort_mod\n\n  IMPLICIT NONE\n\n  TYPE group\n     INTEGER :: order    \n     REAL    :: VALUE    \n  END TYPE group\n\nCONTAINS\n\n  RECURSIVE SUBROUTINE QSort(a,na)\n\n    \n    INTEGER, INTENT(in) :: nA\n    TYPE (group), DIMENSION(nA), INTENT(in out) :: A\n\n    \n    INTEGER :: left, right\n    REAL :: random\n    REAL :: pivot\n    TYPE (group) :: temp\n    INTEGER :: marker\n\n    IF (nA > 1) THEN\n\n       CALL random_NUMBER(random)\n       pivot = A(INT(random*REAL(nA-1))+1)%VALUE   \n       left = 1\n       right = nA\n       \n       DO\n          IF (left >= right) EXIT\n          DO\n             IF (A(right)%VALUE <= pivot) EXIT\n             right = right - 1\n          END DO\n          DO\n             IF (A(left)%VALUE >= pivot) EXIT\n             left = left + 1\n          END DO\n          IF (left < right) THEN\n             temp = A(left)\n             A(left) = A(right)\n             A(right) = temp\n          END IF\n       END DO\n\n       IF (left == right) THEN\n          marker = left + 1\n       ELSE\n          marker = left\n       END IF\n\n       CALL QSort(A(:marker-1),marker-1)\n       CALL QSort(A(marker:),nA-marker+1)\n\n    END IF\n\n  END SUBROUTINE QSort\n\nEND MODULE qsort_mod\n     \n\nPROGRAM qsort_test\n  USE qsort_mod\n  IMPLICIT NONE\n\n  INTEGER, PARAMETER :: nl = 10, nc = 5, l = nc*nl, ns=33\n  TYPE (group), DIMENSION(l) :: A\n  INTEGER, DIMENSION(ns) :: seed\n  INTEGER :: i\n  REAL :: random\n  CHARACTER(LEN=80) :: fmt1, fmt2\n  \n  seed(1) = 1 ; seed(2) = 1\n  DO i = 3,ns\n     seed(i) = seed(i-1)+seed(i-2)\n  END DO\n  \n  WRITE(fmt1,'(A,I2,A)') '(', nc, '(I5,2X,F6.2))'\n  WRITE(fmt2,'(A,I2,A)') '(3x', nc, '(\"Ord.  Num.\",3x))' \n  PRINT *, \"Unsorted Values:\"\n  PRINT fmt2,\n  CALL random_SEED(put = seed)\n  DO i = 1, l\n     CALL random_NUMBER(random)\n     A(i)%VALUE = NINT(1000*random)/10.0\n     A(i)%order = i\n     IF (MOD(i,nc) == 0) WRITE (*,fmt1) A(i-nc+1:i)\n  END DO\n  PRINT *\n  CALL QSort(A,l)\n  PRINT *, \"Sorted Values:\"\n  PRINT fmt2,\n  DO i = nc, l, nc\n     IF (MOD(i,nc) == 0) WRITE (*,fmt1) A(i-nc+1:i)\n  END DO\n  STOP\nEND PROGRAM qsort_test\n", "target": "def quickSort(arr):\n    less = []\n    pivotList = []\n    more = []\n    if len(arr) <= 1:\n        return arr\n    else:\n        pivot = arr[0]\n        for i in arr:\n            if i < pivot:\n                less.append(i)\n            elif i > pivot:\n                more.append(i)\n            else:\n                pivotList.append(i)\n        less = quickSort(less)\n        more = quickSort(more)\n        return less + pivotList + more\n\na = [4, 65, 2, -31, 0, 99, 83, 782, 1]\na = quickSort(a)\n"}
{"id": 78074, "name": "Rot-13", "source": "Translate Fortran to C#: program test_rot_13\n\n  implicit none\n  integer, parameter :: len_max = 256\n  integer, parameter :: unit = 10\n  character (len_max) :: file\n  character (len_max) :: fmt\n  character (len_max) :: line\n  integer :: arg\n  integer :: arg_max\n  integer :: iostat\n\n  write (fmt, '(a, i0, a)') '(a', len_max, ')'\n  arg_max = iargc ()\n  if (arg_max > 0) then\n\n    do arg = 1, arg_max\n      call getarg (arg, file)\n      open (unit, file = file, iostat = iostat)\n      if (iostat /= 0) cycle\n      do\n        read (unit, fmt = fmt, iostat = iostat) line\n        if (iostat /= 0) exit\n        write (*, '(a)') trim (rot_13 (line))\n      end do\n      close (unit)\n    end do\n  else\n\n    do\n      read (*, fmt = fmt, iostat = iostat) line\n      if (iostat /= 0) exit\n      write (*, '(a)') trim (rot_13 (line))\n    end do\n  end if\n\ncontains\n\n  function rot_13 (input) result (output)\n\n    implicit none\n    character (len_max), intent (in) :: input\n    character (len_max) :: output\n    integer :: i\n\n    output = input\n    do i = 1, len_trim (output)\n      select case (output (i : i))\n      case ('A' : 'M', 'a' : 'm')\n        output (i : i) = char (ichar (output (i : i)) + 13)\n      case ('N' : 'Z', 'n' : 'z')\n        output (i : i) = char (ichar (output (i : i)) - 13)\n      end select\n    end do\n\n  end function rot_13\n\nend program test_rot_13\n", "target": "using System;\nusing System.IO;\nusing System.Linq;\nusing System.Text;\n\nclass Program\n{\n    static char Rot13(char c)\n    {\n        if ('a' <= c && c <= 'm' || 'A' <= c && c <= 'M')\n        {\n            return (char)(c + 13);\n        }\n        if ('n' <= c && c <= 'z' || 'N' <= c && c <= 'Z')\n        {\n            return (char)(c - 13);\n        }\n        return c;\n    }\n\n    static string Rot13(string s)\n    {\n        return new string(s.Select(Rot13).ToArray());\n    }\n\n\n    static void Main(string[] args)\n    {\n        foreach (var file in args.Where(file => File.Exists(file)))\n        {\n            Console.WriteLine(Rot13(File.ReadAllText(file)));\n        }\n        if (!args.Any())\n        {\n            Console.WriteLine(Rot13(Console.In.ReadToEnd()));\n        }\n    }\n}\n"}
{"id": 78078, "name": "Rot-13", "source": "Translate Fortran to Java: program test_rot_13\n\n  implicit none\n  integer, parameter :: len_max = 256\n  integer, parameter :: unit = 10\n  character (len_max) :: file\n  character (len_max) :: fmt\n  character (len_max) :: line\n  integer :: arg\n  integer :: arg_max\n  integer :: iostat\n\n  write (fmt, '(a, i0, a)') '(a', len_max, ')'\n  arg_max = iargc ()\n  if (arg_max > 0) then\n\n    do arg = 1, arg_max\n      call getarg (arg, file)\n      open (unit, file = file, iostat = iostat)\n      if (iostat /= 0) cycle\n      do\n        read (unit, fmt = fmt, iostat = iostat) line\n        if (iostat /= 0) exit\n        write (*, '(a)') trim (rot_13 (line))\n      end do\n      close (unit)\n    end do\n  else\n\n    do\n      read (*, fmt = fmt, iostat = iostat) line\n      if (iostat /= 0) exit\n      write (*, '(a)') trim (rot_13 (line))\n    end do\n  end if\n\ncontains\n\n  function rot_13 (input) result (output)\n\n    implicit none\n    character (len_max), intent (in) :: input\n    character (len_max) :: output\n    integer :: i\n\n    output = input\n    do i = 1, len_trim (output)\n      select case (output (i : i))\n      case ('A' : 'M', 'a' : 'm')\n        output (i : i) = char (ichar (output (i : i)) + 13)\n      case ('N' : 'Z', 'n' : 'z')\n        output (i : i) = char (ichar (output (i : i)) - 13)\n      end select\n    end do\n\n  end function rot_13\n\nend program test_rot_13\n", "target": "import java.io.*;\n\npublic class Rot13 {\n\n    public static void main(String[] args) throws IOException {\n        if (args.length >= 1) {\n            for (String file : args) {\n                try (InputStream in = new BufferedInputStream(new FileInputStream(file))) {\n                    rot13(in, System.out);\n                }\n            }\n        } else {\n            rot13(System.in, System.out);\n        }\n    }\n\n    private static void rot13(InputStream in, OutputStream out) throws IOException {\n        int ch;\n        while ((ch = in.read()) != -1) {\n            out.write(rot13((char) ch));\n        }\n    }\n\n    private static char rot13(char ch) {\n        if (ch >= 'A' && ch <= 'Z') {\n            return (char) (((ch - 'A') + 13) % 26 + 'A');\n        }\n        if (ch >= 'a' && ch <= 'z') {\n            return (char) (((ch - 'a') + 13) % 26 + 'a');\n        }\n        return ch;\n    }\n}\n"}
{"id": 78079, "name": "Rot-13", "source": "Translate Fortran to Python: program test_rot_13\n\n  implicit none\n  integer, parameter :: len_max = 256\n  integer, parameter :: unit = 10\n  character (len_max) :: file\n  character (len_max) :: fmt\n  character (len_max) :: line\n  integer :: arg\n  integer :: arg_max\n  integer :: iostat\n\n  write (fmt, '(a, i0, a)') '(a', len_max, ')'\n  arg_max = iargc ()\n  if (arg_max > 0) then\n\n    do arg = 1, arg_max\n      call getarg (arg, file)\n      open (unit, file = file, iostat = iostat)\n      if (iostat /= 0) cycle\n      do\n        read (unit, fmt = fmt, iostat = iostat) line\n        if (iostat /= 0) exit\n        write (*, '(a)') trim (rot_13 (line))\n      end do\n      close (unit)\n    end do\n  else\n\n    do\n      read (*, fmt = fmt, iostat = iostat) line\n      if (iostat /= 0) exit\n      write (*, '(a)') trim (rot_13 (line))\n    end do\n  end if\n\ncontains\n\n  function rot_13 (input) result (output)\n\n    implicit none\n    character (len_max), intent (in) :: input\n    character (len_max) :: output\n    integer :: i\n\n    output = input\n    do i = 1, len_trim (output)\n      select case (output (i : i))\n      case ('A' : 'M', 'a' : 'm')\n        output (i : i) = char (ichar (output (i : i)) + 13)\n      case ('N' : 'Z', 'n' : 'z')\n        output (i : i) = char (ichar (output (i : i)) - 13)\n      end select\n    end do\n\n  end function rot_13\n\nend program test_rot_13\n", "target": ">>> u'foo'.encode('rot13')\n'sbb'\n>>> 'sbb'.decode('rot13')\nu'foo'\n"}
{"id": 78296, "name": "Parametric polymorphism", "source": "Translate Fortran to C#:       MODULE SORTSEARCH\t\t\n\n       INTERFACE FIND\t\t\t\n        MODULE PROCEDURE\n     1   FINDI4,\t\t\t\t\n     2   FINDF4,FINDF8,\t\t\t\t\n     3          FINDTTI2,FINDTTI4\t\t\n       END INTERFACE FIND\n\n      CONTAINS\n      INTEGER FUNCTION FINDI4(THIS,NUMB,N)\t\n       USE ASSISTANCE\t\t\n       INTENT(IN) THIS,NUMB,N\t\n       INTEGER*4 THIS,NUMB(1:*)\t\n       INTEGER N\t\t\n       INTEGER L,R,P\t\t\nChop away.\n        L = 0\t\t\t\n        R = N + 1\t\t\n    1   P = (R - L)/2\t\t\n        IF (P.LE.0) THEN\t\n          FINDI4 = -L\t\t\n          RETURN\t\t\n        END IF\t\t\t\n        P = P + L\t\t\n        IF (THIS - NUMB(P)) 3,4,2\t\n    2   L = P\t\t\t\n        GO TO 1\t\t\t\n    3   R = P\t\t\t\n        GO TO 1\t\t\t\nCaught it\n    4   FINDI4 = P\t\t\n      END FUNCTION FINDI4\t\n\n      END MODULE SORTSEARCH\n", "target": "using System;\n\nclass BinaryTree<T>\n{\n    public T value;\n    public BinaryTree<T> left;\n    public BinaryTree<T> right;\n\n    public BinaryTree(T value)\n    {\n        this.value = value;\n    }\n\n    public BinaryTree<U> Map<U>(Func<T, U> f)\n    {\n        BinaryTree<U> tree = new BinaryTree<U>(f(this.value));\n        if (this.left != null)\n        {\n            tree.left = this.left.Map(f);\n        }\n        if (this.right != null)\n        {\n            tree.right = this.right.Map(f);\n        }\n        return tree;\n    }\n}\n"}
{"id": 78299, "name": "Parametric polymorphism", "source": "Translate Fortran to Java:       MODULE SORTSEARCH\t\t\n\n       INTERFACE FIND\t\t\t\n        MODULE PROCEDURE\n     1   FINDI4,\t\t\t\t\n     2   FINDF4,FINDF8,\t\t\t\t\n     3          FINDTTI2,FINDTTI4\t\t\n       END INTERFACE FIND\n\n      CONTAINS\n      INTEGER FUNCTION FINDI4(THIS,NUMB,N)\t\n       USE ASSISTANCE\t\t\n       INTENT(IN) THIS,NUMB,N\t\n       INTEGER*4 THIS,NUMB(1:*)\t\n       INTEGER N\t\t\n       INTEGER L,R,P\t\t\nChop away.\n        L = 0\t\t\t\n        R = N + 1\t\t\n    1   P = (R - L)/2\t\t\n        IF (P.LE.0) THEN\t\n          FINDI4 = -L\t\t\n          RETURN\t\t\n        END IF\t\t\t\n        P = P + L\t\t\n        IF (THIS - NUMB(P)) 3,4,2\t\n    2   L = P\t\t\t\n        GO TO 1\t\t\t\n    3   R = P\t\t\t\n        GO TO 1\t\t\t\nCaught it\n    4   FINDI4 = P\t\t\n      END FUNCTION FINDI4\t\n\n      END MODULE SORTSEARCH\n", "target": "public class Tree<T>{\n\tprivate T value;\n\tprivate Tree<T> left;\n\tprivate Tree<T> right;\n\n\tpublic void replaceAll(T value){\n\t\tthis.value = value;\n\t\tif (left != null)\n\t\t\tleft.replaceAll(value);\n\t\tif (right != null)\n\t\t\tright.replaceAll(value);\n\t}\n}\n"}
{"id": 78505, "name": "Write float arrays to a text file", "source": "Translate Fortran to C#: program writefloats\n  implicit none\n\n  real, dimension(10) :: a, sqrta\n  integer :: i\n  integer, parameter :: unit = 40 \n\n  a = (/ (i, i=1,10) /)\n  sqrta = sqrt(a)\n\n  open(unit, file=\"xydata.txt\", status=\"new\", action=\"write\")\n  call writexy(unit, a, sqrta)\n  close(unit)\n\ncontains\n\n  subroutine writexy(u, x, y)\n    real, dimension(:), intent(in) :: x, y\n    integer, intent(in) :: u\n\n    integer :: i\n\n    write(u, \"(2F10.4)\") (x(i), y(i), i=lbound(x,1), ubound(x,1))\n  end subroutine writexy\n\nend program writefloats\n", "target": "using System.IO;\n\nclass Program\n{\n    static void Main(string[] args)\n    {\n        var x = new double[] { 1, 2, 3, 1e11 };\n        var y = new double[] { 1, 1.4142135623730951, 1.7320508075688772, 316227.76601683791 };\n\n        int xprecision = 3;\n        int yprecision = 5;\n\n        string formatString = \"{0:G\" + xprecision + \"}\\t{1:G\" + yprecision + \"}\";\n\n        using (var outf = new StreamWriter(\"FloatArrayColumns.txt\"))\n            for (int i = 0; i < x.Length; i++)\n                outf.WriteLine(formatString, x[i], y[i]);\n    }\n}\n"}
{"id": 78506, "name": "Write float arrays to a text file", "source": "Translate Fortran to C#: program writefloats\n  implicit none\n\n  real, dimension(10) :: a, sqrta\n  integer :: i\n  integer, parameter :: unit = 40 \n\n  a = (/ (i, i=1,10) /)\n  sqrta = sqrt(a)\n\n  open(unit, file=\"xydata.txt\", status=\"new\", action=\"write\")\n  call writexy(unit, a, sqrta)\n  close(unit)\n\ncontains\n\n  subroutine writexy(u, x, y)\n    real, dimension(:), intent(in) :: x, y\n    integer, intent(in) :: u\n\n    integer :: i\n\n    write(u, \"(2F10.4)\") (x(i), y(i), i=lbound(x,1), ubound(x,1))\n  end subroutine writexy\n\nend program writefloats\n", "target": "using System.IO;\n\nclass Program\n{\n    static void Main(string[] args)\n    {\n        var x = new double[] { 1, 2, 3, 1e11 };\n        var y = new double[] { 1, 1.4142135623730951, 1.7320508075688772, 316227.76601683791 };\n\n        int xprecision = 3;\n        int yprecision = 5;\n\n        string formatString = \"{0:G\" + xprecision + \"}\\t{1:G\" + yprecision + \"}\";\n\n        using (var outf = new StreamWriter(\"FloatArrayColumns.txt\"))\n            for (int i = 0; i < x.Length; i++)\n                outf.WriteLine(formatString, x[i], y[i]);\n    }\n}\n"}
{"id": 78511, "name": "Write float arrays to a text file", "source": "Translate Fortran to Java: program writefloats\n  implicit none\n\n  real, dimension(10) :: a, sqrta\n  integer :: i\n  integer, parameter :: unit = 40 \n\n  a = (/ (i, i=1,10) /)\n  sqrta = sqrt(a)\n\n  open(unit, file=\"xydata.txt\", status=\"new\", action=\"write\")\n  call writexy(unit, a, sqrta)\n  close(unit)\n\ncontains\n\n  subroutine writexy(u, x, y)\n    real, dimension(:), intent(in) :: x, y\n    integer, intent(in) :: u\n\n    integer :: i\n\n    write(u, \"(2F10.4)\") (x(i), y(i), i=lbound(x,1), ubound(x,1))\n  end subroutine writexy\n\nend program writefloats\n", "target": "import java.io.*;\n\npublic class FloatArray {\n    public static void writeDat(String filename, double[] x, double[] y,\n                                int xprecision, int yprecision)\n        throws IOException {\n        assert x.length == y.length;\n        PrintWriter out = new PrintWriter(filename);\n        for (int i = 0; i < x.length; i++)\n            out.printf(\"%.\"+xprecision+\"g\\t%.\"+yprecision+\"g\\n\", x[i], y[i]);\n        out.close();\n    }\n\n    public static void main(String[] args) {\n        double[] x = {1, 2, 3, 1e11};\n        double[] y = new double[x.length];\n        for (int i = 0; i < x.length; i++)\n            y[i] = Math.sqrt(x[i]);\n        \n        try {\n            writeDat(\"sqrt.dat\", x, y, 3, 5);\n        } catch (IOException e) {\n            System.err.println(\"writeDat: exception: \"+e);\n        }\n\n        try {\n            BufferedReader br = new BufferedReader(new FileReader(\"sqrt.dat\"));\n            String line;\n            while ((line = br.readLine()) != null)\n                System.out.println(line);\n        } catch (IOException e) { }\n    }\n}\n"}
{"id": 78512, "name": "Write float arrays to a text file", "source": "Translate Fortran to Java: program writefloats\n  implicit none\n\n  real, dimension(10) :: a, sqrta\n  integer :: i\n  integer, parameter :: unit = 40 \n\n  a = (/ (i, i=1,10) /)\n  sqrta = sqrt(a)\n\n  open(unit, file=\"xydata.txt\", status=\"new\", action=\"write\")\n  call writexy(unit, a, sqrta)\n  close(unit)\n\ncontains\n\n  subroutine writexy(u, x, y)\n    real, dimension(:), intent(in) :: x, y\n    integer, intent(in) :: u\n\n    integer :: i\n\n    write(u, \"(2F10.4)\") (x(i), y(i), i=lbound(x,1), ubound(x,1))\n  end subroutine writexy\n\nend program writefloats\n", "target": "import java.io.*;\n\npublic class FloatArray {\n    public static void writeDat(String filename, double[] x, double[] y,\n                                int xprecision, int yprecision)\n        throws IOException {\n        assert x.length == y.length;\n        PrintWriter out = new PrintWriter(filename);\n        for (int i = 0; i < x.length; i++)\n            out.printf(\"%.\"+xprecision+\"g\\t%.\"+yprecision+\"g\\n\", x[i], y[i]);\n        out.close();\n    }\n\n    public static void main(String[] args) {\n        double[] x = {1, 2, 3, 1e11};\n        double[] y = new double[x.length];\n        for (int i = 0; i < x.length; i++)\n            y[i] = Math.sqrt(x[i]);\n        \n        try {\n            writeDat(\"sqrt.dat\", x, y, 3, 5);\n        } catch (IOException e) {\n            System.err.println(\"writeDat: exception: \"+e);\n        }\n\n        try {\n            BufferedReader br = new BufferedReader(new FileReader(\"sqrt.dat\"));\n            String line;\n            while ((line = br.readLine()) != null)\n                System.out.println(line);\n        } catch (IOException e) { }\n    }\n}\n"}
{"id": 78513, "name": "Write float arrays to a text file", "source": "Translate Fortran to Python: program writefloats\n  implicit none\n\n  real, dimension(10) :: a, sqrta\n  integer :: i\n  integer, parameter :: unit = 40 \n\n  a = (/ (i, i=1,10) /)\n  sqrta = sqrt(a)\n\n  open(unit, file=\"xydata.txt\", status=\"new\", action=\"write\")\n  call writexy(unit, a, sqrta)\n  close(unit)\n\ncontains\n\n  subroutine writexy(u, x, y)\n    real, dimension(:), intent(in) :: x, y\n    integer, intent(in) :: u\n\n    integer :: i\n\n    write(u, \"(2F10.4)\") (x(i), y(i), i=lbound(x,1), ubound(x,1))\n  end subroutine writexy\n\nend program writefloats\n", "target": "import itertools\ndef writedat(filename, x, y, xprecision=3, yprecision=5):\n    with open(filename,'w') as f:\n        for a, b in itertools.izip(x, y):\n            print >> f, \"%.*g\\t%.*g\" % (xprecision, a, yprecision, b)\n"}
{"id": 78514, "name": "Write float arrays to a text file", "source": "Translate Fortran to Python: program writefloats\n  implicit none\n\n  real, dimension(10) :: a, sqrta\n  integer :: i\n  integer, parameter :: unit = 40 \n\n  a = (/ (i, i=1,10) /)\n  sqrta = sqrt(a)\n\n  open(unit, file=\"xydata.txt\", status=\"new\", action=\"write\")\n  call writexy(unit, a, sqrta)\n  close(unit)\n\ncontains\n\n  subroutine writexy(u, x, y)\n    real, dimension(:), intent(in) :: x, y\n    integer, intent(in) :: u\n\n    integer :: i\n\n    write(u, \"(2F10.4)\") (x(i), y(i), i=lbound(x,1), ubound(x,1))\n  end subroutine writexy\n\nend program writefloats\n", "target": "import itertools\ndef writedat(filename, x, y, xprecision=3, yprecision=5):\n    with open(filename,'w') as f:\n        for a, b in itertools.izip(x, y):\n            print >> f, \"%.*g\\t%.*g\" % (xprecision, a, yprecision, b)\n"}
{"id": 78849, "name": "21 game", "source": "Translate Fortran to C#: \n\nsubroutine ai\n  common itotal, igoal\n  if (itotal .lt. igoal) then\n    move = 1\n    do i = 1, 3\n      if (mod(itotal + i - 1 , 4) .eq. 0) then\n        move = i\n      end if\n    end do\n    do i = 1, 3\n      if (itotal + i .eq. igoal) then\n        move = i\n      end if\n    end do\n    print *, \"      ai  \", itotal + move, \" = \", itotal, \" + \", move\n    itotal = itotal + move\n    if (itotal .eq. igoal) then\n      print *, \"\"\n      print *, \"the winner is ai\"\n      print *, \"\"\n    end if\n  end if\nend subroutine ai\n\nsubroutine human\n  common itotal, igoal\n  print *, \"\"\n  do while (.true.)\n    if (itotal + 1 .eq. igoal) then\n      print *, \"enter 1 (or 0 to exit): \"\n    else if (itotal + 2 .eq. igoal) then\n      print *, \"enter 1 or 2 (or 0 to exit): \"\n    else\n      print *, \"enter 1 or 2 or 3 (or 0 to exit)\"\n    end if\n    read(*,*) move\n    if (move .eq. 0) then\n      stop\n    else if (move .ge. 1 .and. move .le. 3 .and. move + itotal .le. igoal) then\n      print *, \"   human  \", itotal + move, \" = \", itotal, \" + \", move\n      itotal = itotal + move\n      if (itotal .eq. igoal) then\n        print *, \"\"\n        print *, \"the winner is human\"\n        print *, \"\"\n      end if\n      return\n    else\n      print *, \"a bad choice\"\n    end if\n  end do\nend subroutine human\n\nprogram main\n  common itotal, igoal\n  print *,\"game 21 - an example in fortran iv language for rosseta code.\"\n  print *,\"\"\n  print *,\"21 is a two player game, the game is played by choosing a number\"\n  print *,\"(1, 2, or 3) to be added to the running total. the game is won\"\n  print *,\"by the player whose chosen number causes the running total to reach\"\n  print *,\"exactly 21. the running total starts at zero.\"\n  print *,\"\"\n  i = irand(1)\n  igoal = 21\n  do while(.true.)\n    print *, \"---- new game ----\"\n    print *, \"\"\n    print *, \"the running total is currently zero.\"\n    print *, \"\"\n    itotal = 0\n    if (mod(irand(0), 2) .eq. 0) then\n      print *, \"the first move is ai move.\"\n      call ai\n    else\n      print *, \"the first move is human move.\"\n    end if\n    print *, \"\"\n    do while(itotal .lt. igoal)\n      call human\n      call ai\n    end do\nend do\nend program main\n", "target": "\n\nusing System;\n\nnamespace _21Game\n{\n    public class Program\n    {\n        private const string computerPlayer = \"Computer\";\n        private const string humanPlayer = \"Player 1\";\n\n        public static string SwapPlayer(string currentPlayer)\n        {\n            if (currentPlayer == computerPlayer)\n            {\n                currentPlayer = humanPlayer;\n            }\n            else\n            {\n                currentPlayer = computerPlayer;\n            }\n\n            return currentPlayer;\n        }\n\n        public static void PlayGame()\n        {\n            bool playAnother = true;\n            int total = 0;\n            int final = 21;\n            int roundChoice = 0;\n            string currentPlayer = RandomPLayerSelect();\n            int compWins = 0;\n            int humanWins = 0;\n\n            while (playAnother)\n            {\n                Console.WriteLine($\"Now playing: {currentPlayer}\");\n                try\n                {\n                    if (currentPlayer == computerPlayer)\n                    {\n                       roundChoice =  CompMove(total);\n                    }\n                    else\n                    {\n                        roundChoice = int.Parse(Console.ReadLine());\n                    }\n                    \n\n                    if (roundChoice != 1 && roundChoice != 2 && roundChoice != 3)\n                    {\n                        throw new Exception();\n                    }\n\n                    total += roundChoice;\n                }\n                catch (Exception)\n                {\n                    Console.WriteLine(\"Invalid choice! Choose from numbers: 1, 2, 3.\");\n                    continue;\n                }\n\n                Console.WriteLine(total);\n\n                if (total == final)\n                {\n                    if (currentPlayer == computerPlayer)\n                    {\n                        compWins++;\n                    }\n                    if (currentPlayer == humanPlayer)\n                    {\n                        humanWins++;\n                    }\n                    Console.WriteLine($\"Winner: {currentPlayer}\");\n                    Console.WriteLine($\"Comp wins: {compWins}. Human wins: {humanWins}\");\n                    Console.WriteLine($\"do you wan to play another round? y/n\");\n                    var choice = Console.ReadLine();\n                    if (choice == \"y\")\n                    {\n                        total = 0;\n                    }\n                    else if (choice == \"n\")\n                    {\n                        break;\n                    }\n                    else\n                    {\n                        Console.WriteLine(\"Invalid choice! Choose from y or n\");\n                        continue;\n                    }\n                }\n\n                else if (total > 21)\n                {\n                    Console.WriteLine(\"Not the right time to play this game\u00a0:)\");\n                    break;\n                }\n\n                currentPlayer = SwapPlayer(currentPlayer);\n            }\n        }\n\n        public static bool CheckIfCanWin(int total)\n        {\n            bool result = false;\n            if (total == 18)\n            {\n                result = true;\n            }\n            return result;\n        }\n\n        public static int CompMove(int total)\n        {\n            int choice = 0;\n\n            if (CheckIfCanWin(total))\n            {\n                choice = 21 - total;\n            }\n            else\n            {\n                choice = new Random().Next(1,4);\n            }\n\n            return choice;\n        }\n\n        public static string RandomPLayerSelect()\n        {\n            string[] players = new string[] { computerPlayer, humanPlayer };\n            var random = new Random().Next(0,2);\n            return players[random];\n        }\n\n        public static void Main(string[] args)\n        {\n            \n            Console.WriteLine(\"Welcome to 21 game \\n\");\n            Console.WriteLine(@\"21 is a two player game. \nThe game is played by choosing a number.\n1, 2, or 3 to be added a total sum. \\n\nThe game is won by the player reaches exactly 21. \\n\" );            \n            Console.WriteLine(\"Choose your number: (1, 2 or 3)\");\n\n            PlayGame();\n        }\n    }\n}\n"}
{"id": 78850, "name": "21 game", "source": "Translate Fortran to C#: \n\nsubroutine ai\n  common itotal, igoal\n  if (itotal .lt. igoal) then\n    move = 1\n    do i = 1, 3\n      if (mod(itotal + i - 1 , 4) .eq. 0) then\n        move = i\n      end if\n    end do\n    do i = 1, 3\n      if (itotal + i .eq. igoal) then\n        move = i\n      end if\n    end do\n    print *, \"      ai  \", itotal + move, \" = \", itotal, \" + \", move\n    itotal = itotal + move\n    if (itotal .eq. igoal) then\n      print *, \"\"\n      print *, \"the winner is ai\"\n      print *, \"\"\n    end if\n  end if\nend subroutine ai\n\nsubroutine human\n  common itotal, igoal\n  print *, \"\"\n  do while (.true.)\n    if (itotal + 1 .eq. igoal) then\n      print *, \"enter 1 (or 0 to exit): \"\n    else if (itotal + 2 .eq. igoal) then\n      print *, \"enter 1 or 2 (or 0 to exit): \"\n    else\n      print *, \"enter 1 or 2 or 3 (or 0 to exit)\"\n    end if\n    read(*,*) move\n    if (move .eq. 0) then\n      stop\n    else if (move .ge. 1 .and. move .le. 3 .and. move + itotal .le. igoal) then\n      print *, \"   human  \", itotal + move, \" = \", itotal, \" + \", move\n      itotal = itotal + move\n      if (itotal .eq. igoal) then\n        print *, \"\"\n        print *, \"the winner is human\"\n        print *, \"\"\n      end if\n      return\n    else\n      print *, \"a bad choice\"\n    end if\n  end do\nend subroutine human\n\nprogram main\n  common itotal, igoal\n  print *,\"game 21 - an example in fortran iv language for rosseta code.\"\n  print *,\"\"\n  print *,\"21 is a two player game, the game is played by choosing a number\"\n  print *,\"(1, 2, or 3) to be added to the running total. the game is won\"\n  print *,\"by the player whose chosen number causes the running total to reach\"\n  print *,\"exactly 21. the running total starts at zero.\"\n  print *,\"\"\n  i = irand(1)\n  igoal = 21\n  do while(.true.)\n    print *, \"---- new game ----\"\n    print *, \"\"\n    print *, \"the running total is currently zero.\"\n    print *, \"\"\n    itotal = 0\n    if (mod(irand(0), 2) .eq. 0) then\n      print *, \"the first move is ai move.\"\n      call ai\n    else\n      print *, \"the first move is human move.\"\n    end if\n    print *, \"\"\n    do while(itotal .lt. igoal)\n      call human\n      call ai\n    end do\nend do\nend program main\n", "target": "\n\nusing System;\n\nnamespace _21Game\n{\n    public class Program\n    {\n        private const string computerPlayer = \"Computer\";\n        private const string humanPlayer = \"Player 1\";\n\n        public static string SwapPlayer(string currentPlayer)\n        {\n            if (currentPlayer == computerPlayer)\n            {\n                currentPlayer = humanPlayer;\n            }\n            else\n            {\n                currentPlayer = computerPlayer;\n            }\n\n            return currentPlayer;\n        }\n\n        public static void PlayGame()\n        {\n            bool playAnother = true;\n            int total = 0;\n            int final = 21;\n            int roundChoice = 0;\n            string currentPlayer = RandomPLayerSelect();\n            int compWins = 0;\n            int humanWins = 0;\n\n            while (playAnother)\n            {\n                Console.WriteLine($\"Now playing: {currentPlayer}\");\n                try\n                {\n                    if (currentPlayer == computerPlayer)\n                    {\n                       roundChoice =  CompMove(total);\n                    }\n                    else\n                    {\n                        roundChoice = int.Parse(Console.ReadLine());\n                    }\n                    \n\n                    if (roundChoice != 1 && roundChoice != 2 && roundChoice != 3)\n                    {\n                        throw new Exception();\n                    }\n\n                    total += roundChoice;\n                }\n                catch (Exception)\n                {\n                    Console.WriteLine(\"Invalid choice! Choose from numbers: 1, 2, 3.\");\n                    continue;\n                }\n\n                Console.WriteLine(total);\n\n                if (total == final)\n                {\n                    if (currentPlayer == computerPlayer)\n                    {\n                        compWins++;\n                    }\n                    if (currentPlayer == humanPlayer)\n                    {\n                        humanWins++;\n                    }\n                    Console.WriteLine($\"Winner: {currentPlayer}\");\n                    Console.WriteLine($\"Comp wins: {compWins}. Human wins: {humanWins}\");\n                    Console.WriteLine($\"do you wan to play another round? y/n\");\n                    var choice = Console.ReadLine();\n                    if (choice == \"y\")\n                    {\n                        total = 0;\n                    }\n                    else if (choice == \"n\")\n                    {\n                        break;\n                    }\n                    else\n                    {\n                        Console.WriteLine(\"Invalid choice! Choose from y or n\");\n                        continue;\n                    }\n                }\n\n                else if (total > 21)\n                {\n                    Console.WriteLine(\"Not the right time to play this game\u00a0:)\");\n                    break;\n                }\n\n                currentPlayer = SwapPlayer(currentPlayer);\n            }\n        }\n\n        public static bool CheckIfCanWin(int total)\n        {\n            bool result = false;\n            if (total == 18)\n            {\n                result = true;\n            }\n            return result;\n        }\n\n        public static int CompMove(int total)\n        {\n            int choice = 0;\n\n            if (CheckIfCanWin(total))\n            {\n                choice = 21 - total;\n            }\n            else\n            {\n                choice = new Random().Next(1,4);\n            }\n\n            return choice;\n        }\n\n        public static string RandomPLayerSelect()\n        {\n            string[] players = new string[] { computerPlayer, humanPlayer };\n            var random = new Random().Next(0,2);\n            return players[random];\n        }\n\n        public static void Main(string[] args)\n        {\n            \n            Console.WriteLine(\"Welcome to 21 game \\n\");\n            Console.WriteLine(@\"21 is a two player game. \nThe game is played by choosing a number.\n1, 2, or 3 to be added a total sum. \\n\nThe game is won by the player reaches exactly 21. \\n\" );            \n            Console.WriteLine(\"Choose your number: (1, 2 or 3)\");\n\n            PlayGame();\n        }\n    }\n}\n"}
{"id": 78855, "name": "21 game", "source": "Translate Fortran to Java: \n\nsubroutine ai\n  common itotal, igoal\n  if (itotal .lt. igoal) then\n    move = 1\n    do i = 1, 3\n      if (mod(itotal + i - 1 , 4) .eq. 0) then\n        move = i\n      end if\n    end do\n    do i = 1, 3\n      if (itotal + i .eq. igoal) then\n        move = i\n      end if\n    end do\n    print *, \"      ai  \", itotal + move, \" = \", itotal, \" + \", move\n    itotal = itotal + move\n    if (itotal .eq. igoal) then\n      print *, \"\"\n      print *, \"the winner is ai\"\n      print *, \"\"\n    end if\n  end if\nend subroutine ai\n\nsubroutine human\n  common itotal, igoal\n  print *, \"\"\n  do while (.true.)\n    if (itotal + 1 .eq. igoal) then\n      print *, \"enter 1 (or 0 to exit): \"\n    else if (itotal + 2 .eq. igoal) then\n      print *, \"enter 1 or 2 (or 0 to exit): \"\n    else\n      print *, \"enter 1 or 2 or 3 (or 0 to exit)\"\n    end if\n    read(*,*) move\n    if (move .eq. 0) then\n      stop\n    else if (move .ge. 1 .and. move .le. 3 .and. move + itotal .le. igoal) then\n      print *, \"   human  \", itotal + move, \" = \", itotal, \" + \", move\n      itotal = itotal + move\n      if (itotal .eq. igoal) then\n        print *, \"\"\n        print *, \"the winner is human\"\n        print *, \"\"\n      end if\n      return\n    else\n      print *, \"a bad choice\"\n    end if\n  end do\nend subroutine human\n\nprogram main\n  common itotal, igoal\n  print *,\"game 21 - an example in fortran iv language for rosseta code.\"\n  print *,\"\"\n  print *,\"21 is a two player game, the game is played by choosing a number\"\n  print *,\"(1, 2, or 3) to be added to the running total. the game is won\"\n  print *,\"by the player whose chosen number causes the running total to reach\"\n  print *,\"exactly 21. the running total starts at zero.\"\n  print *,\"\"\n  i = irand(1)\n  igoal = 21\n  do while(.true.)\n    print *, \"---- new game ----\"\n    print *, \"\"\n    print *, \"the running total is currently zero.\"\n    print *, \"\"\n    itotal = 0\n    if (mod(irand(0), 2) .eq. 0) then\n      print *, \"the first move is ai move.\"\n      call ai\n    else\n      print *, \"the first move is human move.\"\n    end if\n    print *, \"\"\n    do while(itotal .lt. igoal)\n      call human\n      call ai\n    end do\nend do\nend program main\n", "target": "import java.util.Random;\nimport java.util.Scanner;\n\npublic class TwentyOneGame {\n\n    public static void main(String[] args) {\n        new TwentyOneGame().run(true, 21, new int[] {1, 2, 3});\n    }\n    \n    public void run(boolean computerPlay, int max, int[] valid) {\n        String comma = \"\";\n        for ( int i = 0 ; i < valid.length ; i++ ) {\n            comma += valid[i];\n            if ( i < valid.length - 2 && valid.length >= 3 ) {\n                comma += \", \";\n            }\n            if ( i == valid.length - 2 ) {\n                comma += \" or \";\n            }\n        }\n        System.out.printf(\"The %d game.%nEach player chooses to add %s to a running total.%n\" + \n                \"The player whose turn it is when the total reaches %d will win the game.%n\" + \n                \"Winner of the game starts the next game.  Enter q to quit.%n%n\", max, comma, max);\n        int cGames = 0;\n        int hGames = 0;\n        boolean anotherGame = true;\n        try (Scanner scanner = new Scanner(System.in);) {\n            while ( anotherGame ) {\n                Random r = new Random();\n                int round = 0;\n                int total = 0;\n                System.out.printf(\"Start game %d%n\", hGames + cGames + 1);\n                DONE:\n                    while ( true ) {\n                        round++;\n                        System.out.printf(\"ROUND %d:%n%n\", round);\n                        for ( int play = 0 ; play < 2 ; play++ ) {\n                            if ( computerPlay ) {\n                                int guess = 0;\n                                \n                                for ( int test : valid ) {\n                                    if ( total + test == max ) {\n                                        guess = test;\n                                        break;\n                                    }\n                                }\n                                \n                                if ( guess == 0 ) {\n                                    for ( int test : valid ) {\n                                        if ( total + test >= max ) {\n                                            guess = test;\n                                            break;\n                                        }\n                                    }\n                                }\n                                if ( guess == 0 ) {\n                                    guess = valid[r.nextInt(valid.length)];\n                                }\n                                total += guess;\n                                System.out.printf(\"The computer chooses %d%n\", guess);\n                                System.out.printf(\"Running total is now %d%n%n\", total);\n                                if ( total >= max ) {\n                                    break DONE;\n                                }\n                            }\n                            else {\n                                while ( true ) {\n                                    System.out.printf(\"Your choice among %s: \", comma);\n                                    String line = scanner.nextLine();\n                                    if ( line.matches(\"^[qQ].*\") ) {\n                                        System.out.printf(\"Computer wins %d game%s, human wins %d game%s.  One game incomplete.%nQuitting.%n\", cGames, cGames == 1 ? \"\" : \"s\", hGames, hGames == 1 ? \"\" : \"s\");\n                                        return;\n                                    }\n                                    try {\n                                        int input = Integer.parseInt(line);\n                                        boolean inputOk = false;\n                                        for ( int test : valid ) {\n                                            if ( input == test ) {\n                                                inputOk = true;\n                                                break;\n                                            }\n                                        }\n                                        if ( inputOk ) {\n                                            total += input;\n                                            System.out.printf(\"Running total is now %d%n%n\", total);\n                                            if ( total >= max ) {\n                                                break DONE;\n                                            }\n                                            break;\n                                        }\n                                        else {\n                                            System.out.printf(\"Invalid input - must be a number among %s.  Try again.%n\", comma);\n                                        }\n                                    }\n                                    catch (NumberFormatException e) {\n                                        System.out.printf(\"Invalid input - must be a number among %s.  Try again.%n\", comma);\n                                    }\n                                }\n                            }\n                            computerPlay = !computerPlay;\n                        }\n                    }\n                String win;\n                if ( computerPlay ) {\n                    win = \"Computer wins!!\";\n                    cGames++;\n                }\n                else {\n                    win = \"You win and probably had help from another computer!!\";\n                    hGames++;\n                }\n                System.out.printf(\"%s%n\", win);\n                System.out.printf(\"Computer wins %d game%s, human wins %d game%s%n%n\", cGames, cGames == 1 ? \"\" : \"s\", hGames, hGames == 1 ? \"\" : \"s\");\n                while ( true ) {\n                    System.out.printf(\"Another game (y/n)? \");\n                    String line = scanner.nextLine();\n                    if ( line.matches(\"^[yY]$\") ) {\n                        \n                        System.out.printf(\"%n\");\n                        break;\n                    }\n                    else if ( line.matches(\"^[nN]$\") ) {\n                        anotherGame = false;\n                        System.out.printf(\"Quitting.%n\");\n                        break;\n                    }\n                    else {\n                        System.out.printf(\"Invalid input - must be a y or n.  Try again.%n\");\n                    }\n                }\n            }\n        }\n    }\n\n}\n"}
{"id": 78856, "name": "21 game", "source": "Translate Fortran to Java: \n\nsubroutine ai\n  common itotal, igoal\n  if (itotal .lt. igoal) then\n    move = 1\n    do i = 1, 3\n      if (mod(itotal + i - 1 , 4) .eq. 0) then\n        move = i\n      end if\n    end do\n    do i = 1, 3\n      if (itotal + i .eq. igoal) then\n        move = i\n      end if\n    end do\n    print *, \"      ai  \", itotal + move, \" = \", itotal, \" + \", move\n    itotal = itotal + move\n    if (itotal .eq. igoal) then\n      print *, \"\"\n      print *, \"the winner is ai\"\n      print *, \"\"\n    end if\n  end if\nend subroutine ai\n\nsubroutine human\n  common itotal, igoal\n  print *, \"\"\n  do while (.true.)\n    if (itotal + 1 .eq. igoal) then\n      print *, \"enter 1 (or 0 to exit): \"\n    else if (itotal + 2 .eq. igoal) then\n      print *, \"enter 1 or 2 (or 0 to exit): \"\n    else\n      print *, \"enter 1 or 2 or 3 (or 0 to exit)\"\n    end if\n    read(*,*) move\n    if (move .eq. 0) then\n      stop\n    else if (move .ge. 1 .and. move .le. 3 .and. move + itotal .le. igoal) then\n      print *, \"   human  \", itotal + move, \" = \", itotal, \" + \", move\n      itotal = itotal + move\n      if (itotal .eq. igoal) then\n        print *, \"\"\n        print *, \"the winner is human\"\n        print *, \"\"\n      end if\n      return\n    else\n      print *, \"a bad choice\"\n    end if\n  end do\nend subroutine human\n\nprogram main\n  common itotal, igoal\n  print *,\"game 21 - an example in fortran iv language for rosseta code.\"\n  print *,\"\"\n  print *,\"21 is a two player game, the game is played by choosing a number\"\n  print *,\"(1, 2, or 3) to be added to the running total. the game is won\"\n  print *,\"by the player whose chosen number causes the running total to reach\"\n  print *,\"exactly 21. the running total starts at zero.\"\n  print *,\"\"\n  i = irand(1)\n  igoal = 21\n  do while(.true.)\n    print *, \"---- new game ----\"\n    print *, \"\"\n    print *, \"the running total is currently zero.\"\n    print *, \"\"\n    itotal = 0\n    if (mod(irand(0), 2) .eq. 0) then\n      print *, \"the first move is ai move.\"\n      call ai\n    else\n      print *, \"the first move is human move.\"\n    end if\n    print *, \"\"\n    do while(itotal .lt. igoal)\n      call human\n      call ai\n    end do\nend do\nend program main\n", "target": "import java.util.Random;\nimport java.util.Scanner;\n\npublic class TwentyOneGame {\n\n    public static void main(String[] args) {\n        new TwentyOneGame().run(true, 21, new int[] {1, 2, 3});\n    }\n    \n    public void run(boolean computerPlay, int max, int[] valid) {\n        String comma = \"\";\n        for ( int i = 0 ; i < valid.length ; i++ ) {\n            comma += valid[i];\n            if ( i < valid.length - 2 && valid.length >= 3 ) {\n                comma += \", \";\n            }\n            if ( i == valid.length - 2 ) {\n                comma += \" or \";\n            }\n        }\n        System.out.printf(\"The %d game.%nEach player chooses to add %s to a running total.%n\" + \n                \"The player whose turn it is when the total reaches %d will win the game.%n\" + \n                \"Winner of the game starts the next game.  Enter q to quit.%n%n\", max, comma, max);\n        int cGames = 0;\n        int hGames = 0;\n        boolean anotherGame = true;\n        try (Scanner scanner = new Scanner(System.in);) {\n            while ( anotherGame ) {\n                Random r = new Random();\n                int round = 0;\n                int total = 0;\n                System.out.printf(\"Start game %d%n\", hGames + cGames + 1);\n                DONE:\n                    while ( true ) {\n                        round++;\n                        System.out.printf(\"ROUND %d:%n%n\", round);\n                        for ( int play = 0 ; play < 2 ; play++ ) {\n                            if ( computerPlay ) {\n                                int guess = 0;\n                                \n                                for ( int test : valid ) {\n                                    if ( total + test == max ) {\n                                        guess = test;\n                                        break;\n                                    }\n                                }\n                                \n                                if ( guess == 0 ) {\n                                    for ( int test : valid ) {\n                                        if ( total + test >= max ) {\n                                            guess = test;\n                                            break;\n                                        }\n                                    }\n                                }\n                                if ( guess == 0 ) {\n                                    guess = valid[r.nextInt(valid.length)];\n                                }\n                                total += guess;\n                                System.out.printf(\"The computer chooses %d%n\", guess);\n                                System.out.printf(\"Running total is now %d%n%n\", total);\n                                if ( total >= max ) {\n                                    break DONE;\n                                }\n                            }\n                            else {\n                                while ( true ) {\n                                    System.out.printf(\"Your choice among %s: \", comma);\n                                    String line = scanner.nextLine();\n                                    if ( line.matches(\"^[qQ].*\") ) {\n                                        System.out.printf(\"Computer wins %d game%s, human wins %d game%s.  One game incomplete.%nQuitting.%n\", cGames, cGames == 1 ? \"\" : \"s\", hGames, hGames == 1 ? \"\" : \"s\");\n                                        return;\n                                    }\n                                    try {\n                                        int input = Integer.parseInt(line);\n                                        boolean inputOk = false;\n                                        for ( int test : valid ) {\n                                            if ( input == test ) {\n                                                inputOk = true;\n                                                break;\n                                            }\n                                        }\n                                        if ( inputOk ) {\n                                            total += input;\n                                            System.out.printf(\"Running total is now %d%n%n\", total);\n                                            if ( total >= max ) {\n                                                break DONE;\n                                            }\n                                            break;\n                                        }\n                                        else {\n                                            System.out.printf(\"Invalid input - must be a number among %s.  Try again.%n\", comma);\n                                        }\n                                    }\n                                    catch (NumberFormatException e) {\n                                        System.out.printf(\"Invalid input - must be a number among %s.  Try again.%n\", comma);\n                                    }\n                                }\n                            }\n                            computerPlay = !computerPlay;\n                        }\n                    }\n                String win;\n                if ( computerPlay ) {\n                    win = \"Computer wins!!\";\n                    cGames++;\n                }\n                else {\n                    win = \"You win and probably had help from another computer!!\";\n                    hGames++;\n                }\n                System.out.printf(\"%s%n\", win);\n                System.out.printf(\"Computer wins %d game%s, human wins %d game%s%n%n\", cGames, cGames == 1 ? \"\" : \"s\", hGames, hGames == 1 ? \"\" : \"s\");\n                while ( true ) {\n                    System.out.printf(\"Another game (y/n)? \");\n                    String line = scanner.nextLine();\n                    if ( line.matches(\"^[yY]$\") ) {\n                        \n                        System.out.printf(\"%n\");\n                        break;\n                    }\n                    else if ( line.matches(\"^[nN]$\") ) {\n                        anotherGame = false;\n                        System.out.printf(\"Quitting.%n\");\n                        break;\n                    }\n                    else {\n                        System.out.printf(\"Invalid input - must be a y or n.  Try again.%n\");\n                    }\n                }\n            }\n        }\n    }\n\n}\n"}
{"id": 78857, "name": "21 game", "source": "Translate Fortran to Python: \n\nsubroutine ai\n  common itotal, igoal\n  if (itotal .lt. igoal) then\n    move = 1\n    do i = 1, 3\n      if (mod(itotal + i - 1 , 4) .eq. 0) then\n        move = i\n      end if\n    end do\n    do i = 1, 3\n      if (itotal + i .eq. igoal) then\n        move = i\n      end if\n    end do\n    print *, \"      ai  \", itotal + move, \" = \", itotal, \" + \", move\n    itotal = itotal + move\n    if (itotal .eq. igoal) then\n      print *, \"\"\n      print *, \"the winner is ai\"\n      print *, \"\"\n    end if\n  end if\nend subroutine ai\n\nsubroutine human\n  common itotal, igoal\n  print *, \"\"\n  do while (.true.)\n    if (itotal + 1 .eq. igoal) then\n      print *, \"enter 1 (or 0 to exit): \"\n    else if (itotal + 2 .eq. igoal) then\n      print *, \"enter 1 or 2 (or 0 to exit): \"\n    else\n      print *, \"enter 1 or 2 or 3 (or 0 to exit)\"\n    end if\n    read(*,*) move\n    if (move .eq. 0) then\n      stop\n    else if (move .ge. 1 .and. move .le. 3 .and. move + itotal .le. igoal) then\n      print *, \"   human  \", itotal + move, \" = \", itotal, \" + \", move\n      itotal = itotal + move\n      if (itotal .eq. igoal) then\n        print *, \"\"\n        print *, \"the winner is human\"\n        print *, \"\"\n      end if\n      return\n    else\n      print *, \"a bad choice\"\n    end if\n  end do\nend subroutine human\n\nprogram main\n  common itotal, igoal\n  print *,\"game 21 - an example in fortran iv language for rosseta code.\"\n  print *,\"\"\n  print *,\"21 is a two player game, the game is played by choosing a number\"\n  print *,\"(1, 2, or 3) to be added to the running total. the game is won\"\n  print *,\"by the player whose chosen number causes the running total to reach\"\n  print *,\"exactly 21. the running total starts at zero.\"\n  print *,\"\"\n  i = irand(1)\n  igoal = 21\n  do while(.true.)\n    print *, \"---- new game ----\"\n    print *, \"\"\n    print *, \"the running total is currently zero.\"\n    print *, \"\"\n    itotal = 0\n    if (mod(irand(0), 2) .eq. 0) then\n      print *, \"the first move is ai move.\"\n      call ai\n    else\n      print *, \"the first move is human move.\"\n    end if\n    print *, \"\"\n    do while(itotal .lt. igoal)\n      call human\n      call ai\n    end do\nend do\nend program main\n", "target": "from random import randint\ndef start():\n\tgame_count=0\n\tprint(\"Enter q to quit at any time.\\nThe computer will choose first.\\nRunning total is now {}\".format(game_count))\n\troundno=1\n\twhile game_count<21:\n\t\tprint(\"\\nROUND {}: \\n\".format(roundno))\n\t\tt = select_count(game_count)\n\t\tgame_count = game_count+t\n\t\tprint(\"Running total is now {}\\n\".format(game_count))\n\t\tif game_count>=21:\n\t\t\tprint(\"So, commiserations, the computer has won!\")\n\t\t\treturn 0\n\t\tt = request_count()\n\t\tif not t:\n\t\t\tprint('OK,quitting the game')\n\t\t\treturn -1\n\t\tgame_count = game_count+t\n\t\tprint(\"Running total is now {}\\n\".format(game_count))\n\t\tif game_count>=21:\n\t\t\tprint(\"So, congratulations, you've won!\")\n\t\t\treturn 1\n\t\troundno+=1\n\ndef select_count(game_count):\n\t\n\tif game_count<18:\n\t\tt= randint(1,3)\n\telse:\n\t\tt = 21-game_count\n\tprint(\"The computer chooses {}\".format(t))\n\treturn t\n\ndef request_count():\n\t\n\tt=\"\"\n\twhile True:\n\t\ttry:\n\t\t\tt = raw_input('Your choice 1 to 3\u00a0:')\n\t\t\tif int(t) in [1,2,3]:\n\t\t\t\treturn int(t)\n\t\t\telse:\n\t\t\t\tprint(\"Out of range, try again\")\n\t\texcept:\n\t\t\tif t==\"q\":\n\t\t\t\treturn None\n\t\t\telse:\n\t\t\t\tprint(\"Invalid Entry, try again\")\n\nc=0\nm=0\nr=True\nwhile r:\n\to = start()\n\tif o==-1:\n\t\tbreak\n\telse:\n\t\tc+=1 if o==0 else 0\n\t\tm+=1 if o==1 else 0\n\tprint(\"Computer wins {0} game, human wins {1} games\".format(c,m))\n\tt = raw_input(\"Another game?(press y to continue):\")\n\tr = (t==\"y\")\n"}
{"id": 79279, "name": "Sum multiples of 3 and 5", "source": "Translate Fortran to C#:       INTEGER*8 FUNCTION SUMI(N)\t\nCalculates as per the young Gauss: N*(N + 1)/2 = 1 + 2 + 3 + ... + N.\n       INTEGER*8 N\t\n        IF (MOD(N,2).EQ.0) THEN\t\n          SUMI = N/2*(N + 1)\t\t\n         ELSE\t\t\t\n          SUMI = (N + 1)/2*N\t\t\n        END IF\t\t\t\n      END FUNCTION SUMI\t\t\n\n      INTEGER*8 FUNCTION SUMF(N,F)\t\n       INTEGER*8 N,F\t\t\n       INTEGER*8 L\t\t\n       INTEGER*8 SUMI\t\t\n        L = (N - 1)/F\t\t\n        SUMF = F*SUMI(L)\t\n      END FUNCTION SUMF\t\t\n\n      INTEGER*8 FUNCTION SUMBFI(N)\t\n       INTEGER*8 N\t\n       INTEGER*8 I,S\t\n        S = 0\t\t\n        DO I = 3,N - 1\t\n          IF (MOD(I,3).EQ.0 .OR. MOD(I,5).EQ.0) S = S + I\t\n        END DO\t\t\n        SUMBFI = S\t\t\n      END FUNCTION SUMBFI\t\n\n      INTEGER*8 SUMF,SUMBFI\t\n      INTEGER*8 N\t\n      WRITE (6,*) \"Sum multiples of 3 and 5 up to N\"\n   10 WRITE (6,11)\t\t\n   11 FORMAT (\"Specify N: \",$)\t\n      READ (5,*) N\t\t\n      IF (N.LE.0) STOP\t\t\n      WRITE (6,*) \"By Gauss:\",SUMF(N,3) + SUMF(N,5) - SUMF(N,15)\n      WRITE (6,*) \"BFI sum\u00a0:\",SUMBFI(N)\t\t\n      GO TO 10\t\t\t\n      END\t\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Numerics;\n\nnamespace RosettaCode\n{\n    class Program\n    {\n        static void Main()\n        {\n            List<BigInteger> candidates = new List<BigInteger>(new BigInteger[] { 1000, 100000, 10000000, 10000000000, 1000000000000000 });\n            candidates.Add(BigInteger.Parse(\"100000000000000000000\"));\n\n            foreach (BigInteger candidate in candidates)\n            {\n                BigInteger c = candidate - 1;\n                BigInteger answer3 = GetSumOfNumbersDivisibleByN(c, 3);\n                BigInteger answer5 = GetSumOfNumbersDivisibleByN(c, 5);\n                BigInteger answer15 = GetSumOfNumbersDivisibleByN(c, 15);\n\n                Console.WriteLine(\"The sum of numbers divisible by 3 or 5 between 1 and {0} is {1}\", c, answer3 + answer5 - answer15);\n            }\n\n            Console.ReadKey(true);\n        }\n\n        private static BigInteger GetSumOfNumbersDivisibleByN(BigInteger candidate, uint n)\n        {\n            BigInteger largest = candidate;\n            while (largest % n > 0)\n                largest--;\n            BigInteger totalCount = (largest / n);\n            BigInteger pairCount = totalCount / 2;\n            bool unpairedNumberOnFoldLine = (totalCount % 2 == 1);\n            BigInteger pairSum = largest + n;\n            return pairCount * pairSum + (unpairedNumberOnFoldLine ? pairSum / 2 : 0);\n        }\n\n    }\n}\n"}
{"id": 79280, "name": "Sum multiples of 3 and 5", "source": "Translate Fortran to C#:       INTEGER*8 FUNCTION SUMI(N)\t\nCalculates as per the young Gauss: N*(N + 1)/2 = 1 + 2 + 3 + ... + N.\n       INTEGER*8 N\t\n        IF (MOD(N,2).EQ.0) THEN\t\n          SUMI = N/2*(N + 1)\t\t\n         ELSE\t\t\t\n          SUMI = (N + 1)/2*N\t\t\n        END IF\t\t\t\n      END FUNCTION SUMI\t\t\n\n      INTEGER*8 FUNCTION SUMF(N,F)\t\n       INTEGER*8 N,F\t\t\n       INTEGER*8 L\t\t\n       INTEGER*8 SUMI\t\t\n        L = (N - 1)/F\t\t\n        SUMF = F*SUMI(L)\t\n      END FUNCTION SUMF\t\t\n\n      INTEGER*8 FUNCTION SUMBFI(N)\t\n       INTEGER*8 N\t\n       INTEGER*8 I,S\t\n        S = 0\t\t\n        DO I = 3,N - 1\t\n          IF (MOD(I,3).EQ.0 .OR. MOD(I,5).EQ.0) S = S + I\t\n        END DO\t\t\n        SUMBFI = S\t\t\n      END FUNCTION SUMBFI\t\n\n      INTEGER*8 SUMF,SUMBFI\t\n      INTEGER*8 N\t\n      WRITE (6,*) \"Sum multiples of 3 and 5 up to N\"\n   10 WRITE (6,11)\t\t\n   11 FORMAT (\"Specify N: \",$)\t\n      READ (5,*) N\t\t\n      IF (N.LE.0) STOP\t\t\n      WRITE (6,*) \"By Gauss:\",SUMF(N,3) + SUMF(N,5) - SUMF(N,15)\n      WRITE (6,*) \"BFI sum\u00a0:\",SUMBFI(N)\t\t\n      GO TO 10\t\t\t\n      END\t\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Numerics;\n\nnamespace RosettaCode\n{\n    class Program\n    {\n        static void Main()\n        {\n            List<BigInteger> candidates = new List<BigInteger>(new BigInteger[] { 1000, 100000, 10000000, 10000000000, 1000000000000000 });\n            candidates.Add(BigInteger.Parse(\"100000000000000000000\"));\n\n            foreach (BigInteger candidate in candidates)\n            {\n                BigInteger c = candidate - 1;\n                BigInteger answer3 = GetSumOfNumbersDivisibleByN(c, 3);\n                BigInteger answer5 = GetSumOfNumbersDivisibleByN(c, 5);\n                BigInteger answer15 = GetSumOfNumbersDivisibleByN(c, 15);\n\n                Console.WriteLine(\"The sum of numbers divisible by 3 or 5 between 1 and {0} is {1}\", c, answer3 + answer5 - answer15);\n            }\n\n            Console.ReadKey(true);\n        }\n\n        private static BigInteger GetSumOfNumbersDivisibleByN(BigInteger candidate, uint n)\n        {\n            BigInteger largest = candidate;\n            while (largest % n > 0)\n                largest--;\n            BigInteger totalCount = (largest / n);\n            BigInteger pairCount = totalCount / 2;\n            bool unpairedNumberOnFoldLine = (totalCount % 2 == 1);\n            BigInteger pairSum = largest + n;\n            return pairCount * pairSum + (unpairedNumberOnFoldLine ? pairSum / 2 : 0);\n        }\n\n    }\n}\n"}
{"id": 79286, "name": "Sum multiples of 3 and 5", "source": "Translate Fortran to Java:       INTEGER*8 FUNCTION SUMI(N)\t\nCalculates as per the young Gauss: N*(N + 1)/2 = 1 + 2 + 3 + ... + N.\n       INTEGER*8 N\t\n        IF (MOD(N,2).EQ.0) THEN\t\n          SUMI = N/2*(N + 1)\t\t\n         ELSE\t\t\t\n          SUMI = (N + 1)/2*N\t\t\n        END IF\t\t\t\n      END FUNCTION SUMI\t\t\n\n      INTEGER*8 FUNCTION SUMF(N,F)\t\n       INTEGER*8 N,F\t\t\n       INTEGER*8 L\t\t\n       INTEGER*8 SUMI\t\t\n        L = (N - 1)/F\t\t\n        SUMF = F*SUMI(L)\t\n      END FUNCTION SUMF\t\t\n\n      INTEGER*8 FUNCTION SUMBFI(N)\t\n       INTEGER*8 N\t\n       INTEGER*8 I,S\t\n        S = 0\t\t\n        DO I = 3,N - 1\t\n          IF (MOD(I,3).EQ.0 .OR. MOD(I,5).EQ.0) S = S + I\t\n        END DO\t\t\n        SUMBFI = S\t\t\n      END FUNCTION SUMBFI\t\n\n      INTEGER*8 SUMF,SUMBFI\t\n      INTEGER*8 N\t\n      WRITE (6,*) \"Sum multiples of 3 and 5 up to N\"\n   10 WRITE (6,11)\t\t\n   11 FORMAT (\"Specify N: \",$)\t\n      READ (5,*) N\t\t\n      IF (N.LE.0) STOP\t\t\n      WRITE (6,*) \"By Gauss:\",SUMF(N,3) + SUMF(N,5) - SUMF(N,15)\n      WRITE (6,*) \"BFI sum\u00a0:\",SUMBFI(N)\t\t\n      GO TO 10\t\t\t\n      END\t\n", "target": "class SumMultiples {\n\tpublic static long getSum(long n) {\n\t\tlong sum = 0;\n\t\tfor (int i = 3; i < n; i++) {\n\t\t\tif (i % 3 == 0 || i % 5 == 0) sum += i;\n\t\t}\n\t\treturn sum;\n\t}\n\tpublic static void main(String[] args) {\n\t\tSystem.out.println(getSum(1000));\n\t}\n}\n"}
{"id": 79287, "name": "Sum multiples of 3 and 5", "source": "Translate Fortran to Java:       INTEGER*8 FUNCTION SUMI(N)\t\nCalculates as per the young Gauss: N*(N + 1)/2 = 1 + 2 + 3 + ... + N.\n       INTEGER*8 N\t\n        IF (MOD(N,2).EQ.0) THEN\t\n          SUMI = N/2*(N + 1)\t\t\n         ELSE\t\t\t\n          SUMI = (N + 1)/2*N\t\t\n        END IF\t\t\t\n      END FUNCTION SUMI\t\t\n\n      INTEGER*8 FUNCTION SUMF(N,F)\t\n       INTEGER*8 N,F\t\t\n       INTEGER*8 L\t\t\n       INTEGER*8 SUMI\t\t\n        L = (N - 1)/F\t\t\n        SUMF = F*SUMI(L)\t\n      END FUNCTION SUMF\t\t\n\n      INTEGER*8 FUNCTION SUMBFI(N)\t\n       INTEGER*8 N\t\n       INTEGER*8 I,S\t\n        S = 0\t\t\n        DO I = 3,N - 1\t\n          IF (MOD(I,3).EQ.0 .OR. MOD(I,5).EQ.0) S = S + I\t\n        END DO\t\t\n        SUMBFI = S\t\t\n      END FUNCTION SUMBFI\t\n\n      INTEGER*8 SUMF,SUMBFI\t\n      INTEGER*8 N\t\n      WRITE (6,*) \"Sum multiples of 3 and 5 up to N\"\n   10 WRITE (6,11)\t\t\n   11 FORMAT (\"Specify N: \",$)\t\n      READ (5,*) N\t\t\n      IF (N.LE.0) STOP\t\t\n      WRITE (6,*) \"By Gauss:\",SUMF(N,3) + SUMF(N,5) - SUMF(N,15)\n      WRITE (6,*) \"BFI sum\u00a0:\",SUMBFI(N)\t\t\n      GO TO 10\t\t\t\n      END\t\n", "target": "class SumMultiples {\n\tpublic static long getSum(long n) {\n\t\tlong sum = 0;\n\t\tfor (int i = 3; i < n; i++) {\n\t\t\tif (i % 3 == 0 || i % 5 == 0) sum += i;\n\t\t}\n\t\treturn sum;\n\t}\n\tpublic static void main(String[] args) {\n\t\tSystem.out.println(getSum(1000));\n\t}\n}\n"}
{"id": 79288, "name": "Sum multiples of 3 and 5", "source": "Translate Fortran to Python:       INTEGER*8 FUNCTION SUMI(N)\t\nCalculates as per the young Gauss: N*(N + 1)/2 = 1 + 2 + 3 + ... + N.\n       INTEGER*8 N\t\n        IF (MOD(N,2).EQ.0) THEN\t\n          SUMI = N/2*(N + 1)\t\t\n         ELSE\t\t\t\n          SUMI = (N + 1)/2*N\t\t\n        END IF\t\t\t\n      END FUNCTION SUMI\t\t\n\n      INTEGER*8 FUNCTION SUMF(N,F)\t\n       INTEGER*8 N,F\t\t\n       INTEGER*8 L\t\t\n       INTEGER*8 SUMI\t\t\n        L = (N - 1)/F\t\t\n        SUMF = F*SUMI(L)\t\n      END FUNCTION SUMF\t\t\n\n      INTEGER*8 FUNCTION SUMBFI(N)\t\n       INTEGER*8 N\t\n       INTEGER*8 I,S\t\n        S = 0\t\t\n        DO I = 3,N - 1\t\n          IF (MOD(I,3).EQ.0 .OR. MOD(I,5).EQ.0) S = S + I\t\n        END DO\t\t\n        SUMBFI = S\t\t\n      END FUNCTION SUMBFI\t\n\n      INTEGER*8 SUMF,SUMBFI\t\n      INTEGER*8 N\t\n      WRITE (6,*) \"Sum multiples of 3 and 5 up to N\"\n   10 WRITE (6,11)\t\t\n   11 FORMAT (\"Specify N: \",$)\t\n      READ (5,*) N\t\t\n      IF (N.LE.0) STOP\t\t\n      WRITE (6,*) \"By Gauss:\",SUMF(N,3) + SUMF(N,5) - SUMF(N,15)\n      WRITE (6,*) \"BFI sum\u00a0:\",SUMBFI(N)\t\t\n      GO TO 10\t\t\t\n      END\t\n", "target": "def sum35a(n):\n    'Direct count'\n    \n    return sum(x for x in range(n) if x%3==0 or x%5==0)\n\ndef sum35b(n): \n    \"Count all the 3's; all the 5's; minus double-counted 3*5's\"\n    \n    return sum(range(3, n, 3)) + sum(range(5, n, 5)) - sum(range(15, n, 15))\n    \ndef sum35c(n):\n    'Sum the arithmetic progressions: sum3 + sum5 - sum15'\n    consts = (3, 5, 15)\n    \n    divs = [(n-1) // c for c in consts]\n    sums = [d*c*(1+d)/2 for d,c in zip(divs, consts)]\n    return sums[0] + sums[1] - sums[2]\n\n\nfor n in range(1001):\n    sa, sb, sc = sum35a(n), sum35b(n), sum35c(n)\n    assert sa == sb == sc  \n\nprint('For n = %7i -> %i\\n' % (n, sc))\n\n\nfor p in range(7):\n    print('For n = %7i -> %i' % (10**p, sum35c(10**p)))\n\n\np = 20\nprint('\\nFor n = %20i -> %i' % (10**p, sum35c(10**p)))\n"}
{"id": 79289, "name": "Sum multiples of 3 and 5", "source": "Translate Fortran to Python:       INTEGER*8 FUNCTION SUMI(N)\t\nCalculates as per the young Gauss: N*(N + 1)/2 = 1 + 2 + 3 + ... + N.\n       INTEGER*8 N\t\n        IF (MOD(N,2).EQ.0) THEN\t\n          SUMI = N/2*(N + 1)\t\t\n         ELSE\t\t\t\n          SUMI = (N + 1)/2*N\t\t\n        END IF\t\t\t\n      END FUNCTION SUMI\t\t\n\n      INTEGER*8 FUNCTION SUMF(N,F)\t\n       INTEGER*8 N,F\t\t\n       INTEGER*8 L\t\t\n       INTEGER*8 SUMI\t\t\n        L = (N - 1)/F\t\t\n        SUMF = F*SUMI(L)\t\n      END FUNCTION SUMF\t\t\n\n      INTEGER*8 FUNCTION SUMBFI(N)\t\n       INTEGER*8 N\t\n       INTEGER*8 I,S\t\n        S = 0\t\t\n        DO I = 3,N - 1\t\n          IF (MOD(I,3).EQ.0 .OR. MOD(I,5).EQ.0) S = S + I\t\n        END DO\t\t\n        SUMBFI = S\t\t\n      END FUNCTION SUMBFI\t\n\n      INTEGER*8 SUMF,SUMBFI\t\n      INTEGER*8 N\t\n      WRITE (6,*) \"Sum multiples of 3 and 5 up to N\"\n   10 WRITE (6,11)\t\t\n   11 FORMAT (\"Specify N: \",$)\t\n      READ (5,*) N\t\t\n      IF (N.LE.0) STOP\t\t\n      WRITE (6,*) \"By Gauss:\",SUMF(N,3) + SUMF(N,5) - SUMF(N,15)\n      WRITE (6,*) \"BFI sum\u00a0:\",SUMBFI(N)\t\t\n      GO TO 10\t\t\t\n      END\t\n", "target": "def sum35a(n):\n    'Direct count'\n    \n    return sum(x for x in range(n) if x%3==0 or x%5==0)\n\ndef sum35b(n): \n    \"Count all the 3's; all the 5's; minus double-counted 3*5's\"\n    \n    return sum(range(3, n, 3)) + sum(range(5, n, 5)) - sum(range(15, n, 15))\n    \ndef sum35c(n):\n    'Sum the arithmetic progressions: sum3 + sum5 - sum15'\n    consts = (3, 5, 15)\n    \n    divs = [(n-1) // c for c in consts]\n    sums = [d*c*(1+d)/2 for d,c in zip(divs, consts)]\n    return sums[0] + sums[1] - sums[2]\n\n\nfor n in range(1001):\n    sa, sb, sc = sum35a(n), sum35b(n), sum35c(n)\n    assert sa == sb == sc  \n\nprint('For n = %7i -> %i\\n' % (n, sc))\n\n\nfor p in range(7):\n    print('For n = %7i -> %i' % (10**p, sum35c(10**p)))\n\n\np = 20\nprint('\\nFor n = %20i -> %i' % (10**p, sum35c(10**p)))\n"}
{"id": 79732, "name": "Pascal's triangle", "source": "Translate Fortran to C#: PROGRAM Pascals_Triangle\n\n  CALL Print_Triangle(8)\n\nEND PROGRAM Pascals_Triangle\n\nSUBROUTINE Print_Triangle(n)\n\n  IMPLICIT NONE\n  INTEGER, INTENT(IN) :: n\n  INTEGER :: c, i, j, k, spaces\n\n  DO i = 0, n-1\n     c = 1\n     spaces = 3 * (n - 1 - i)\n     DO j = 1, spaces\n        WRITE(*,\"(A)\", ADVANCE=\"NO\") \" \"\n     END DO\n     DO k = 0, i\n        WRITE(*,\"(I6)\", ADVANCE=\"NO\") c\n        c = c * (i - k) / (k + 1)\n     END DO\n     WRITE(*,*)\n  END DO\n\nEND SUBROUTINE Print_Triangle\n", "target": "using System;\n\nnamespace RosettaCode {\n\n    class PascalsTriangle {\n\n        public static void CreateTriangle(int n) {\n            if (n > 0) {\n                for (int i = 0; i < n; i++) {\n                    int c = 1;\n                    Console.Write(\" \".PadLeft(2 * (n - 1 - i)));\n                    for (int k = 0; k <= i; k++) {\n                        Console.Write(\"{0}\", c.ToString().PadLeft(3));\n                        c = c * (i - k) / (k + 1);\n                    }\n                    Console.WriteLine();\n                }\n            }\n        }\n\n        public static void Main() {\n            CreateTriangle(8);\n        }\n    }\n}\n"}
{"id": 79735, "name": "Pascal's triangle", "source": "Translate Fortran to Java: PROGRAM Pascals_Triangle\n\n  CALL Print_Triangle(8)\n\nEND PROGRAM Pascals_Triangle\n\nSUBROUTINE Print_Triangle(n)\n\n  IMPLICIT NONE\n  INTEGER, INTENT(IN) :: n\n  INTEGER :: c, i, j, k, spaces\n\n  DO i = 0, n-1\n     c = 1\n     spaces = 3 * (n - 1 - i)\n     DO j = 1, spaces\n        WRITE(*,\"(A)\", ADVANCE=\"NO\") \" \"\n     END DO\n     DO k = 0, i\n        WRITE(*,\"(I6)\", ADVANCE=\"NO\") c\n        c = c * (i - k) / (k + 1)\n     END DO\n     WRITE(*,*)\n  END DO\n\nEND SUBROUTINE Print_Triangle\n", "target": "import java.util.ArrayList;\n...\npublic static void genPyrN(int rows){\n\tif(rows < 0) return;\n\t\n\tArrayList<Integer> last = new ArrayList<Integer>();\n\tlast.add(1);\n\tSystem.out.println(last);\n\tfor(int i= 1;i <= rows;++i){\n\t\t\n\t\tArrayList<Integer> thisRow= new ArrayList<Integer>();\n\t\tthisRow.add(last.get(0)); \n\t\tfor(int j= 1;j < i;++j){\n\t\t\t\n\t\t\tthisRow.add(last.get(j - 1) + last.get(j));\n\t\t}\n\t\tthisRow.add(last.get(0)); \n\t\tlast= thisRow;\n\t\tSystem.out.println(thisRow);\n\t}\n}\n"}
{"id": 79736, "name": "Pascal's triangle", "source": "Translate Fortran to Python: PROGRAM Pascals_Triangle\n\n  CALL Print_Triangle(8)\n\nEND PROGRAM Pascals_Triangle\n\nSUBROUTINE Print_Triangle(n)\n\n  IMPLICIT NONE\n  INTEGER, INTENT(IN) :: n\n  INTEGER :: c, i, j, k, spaces\n\n  DO i = 0, n-1\n     c = 1\n     spaces = 3 * (n - 1 - i)\n     DO j = 1, spaces\n        WRITE(*,\"(A)\", ADVANCE=\"NO\") \" \"\n     END DO\n     DO k = 0, i\n        WRITE(*,\"(I6)\", ADVANCE=\"NO\") c\n        c = c * (i - k) / (k + 1)\n     END DO\n     WRITE(*,*)\n  END DO\n\nEND SUBROUTINE Print_Triangle\n", "target": "def pascal(n):\n   \n   row = [1]\n   k = [0]\n   for x in range(max(n,0)):\n      print row\n      row=[l+r for l,r in zip(row+k,k+row)]\n   return n>=1\n"}
{"id": 80017, "name": "Logical operations", "source": "Translate Fortran to C#:        SUBROUTINE PRNLOG(A, B)\n       LOGICAL A, B\n       PRINT *, 'a and b is ', A .AND. B\n       PRINT *, 'a or b is ', A .OR. B\n       PRINT *, 'not a is ', .NOT. A\n       \nC       You did not ask, but the following logical operators are also standard\nC       since ANSI FORTRAN 66 \nC       =======================================================================\n       \nC       This yields the same results as .EQ., but has lower operator precedence\nC       and only works with LOGICAL operands:\n       PRINT *, 'a equivalent to b is ', A .EQV. B\n       \nC       This yields the same results as .NE., but has lower operator precedence\nC       and only works with LOGICAL operands (this operation is also commonly\nC       called \"exclusive or\"):\n       PRINT *, 'a not equivalent to b is ', A .NEQV. B\n       END\n", "target": "using System;\n\nnamespace LogicalOperations\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            bool a = true, b = false;\n            Console.WriteLine(\"a and b is {0}\", a && b);\n            Console.WriteLine(\"a or b is {0}\", a || b);\n            Console.WriteLine(\"Not a is {0}\", !a);\n            Console.WriteLine(\"a exclusive-or b is {0}\", a ^ b);\n        }\n    }\n}\n"}
{"id": 80020, "name": "Logical operations", "source": "Translate Fortran to Java:        SUBROUTINE PRNLOG(A, B)\n       LOGICAL A, B\n       PRINT *, 'a and b is ', A .AND. B\n       PRINT *, 'a or b is ', A .OR. B\n       PRINT *, 'not a is ', .NOT. A\n       \nC       You did not ask, but the following logical operators are also standard\nC       since ANSI FORTRAN 66 \nC       =======================================================================\n       \nC       This yields the same results as .EQ., but has lower operator precedence\nC       and only works with LOGICAL operands:\n       PRINT *, 'a equivalent to b is ', A .EQV. B\n       \nC       This yields the same results as .NE., but has lower operator precedence\nC       and only works with LOGICAL operands (this operation is also commonly\nC       called \"exclusive or\"):\n       PRINT *, 'a not equivalent to b is ', A .NEQV. B\n       END\n", "target": "boolean a = true;\nboolean b = false;\nSystem.Debug('a AND b: ' + (a && b));\nSystem.Debug('a OR b: ' + (a || b));\nSystem.Debug('NOT a: ' + (!a));\nSystem.Debug('a XOR b: ' + (a ^ b));\n"}
{"id": 80021, "name": "Logical operations", "source": "Translate Fortran to Python:        SUBROUTINE PRNLOG(A, B)\n       LOGICAL A, B\n       PRINT *, 'a and b is ', A .AND. B\n       PRINT *, 'a or b is ', A .OR. B\n       PRINT *, 'not a is ', .NOT. A\n       \nC       You did not ask, but the following logical operators are also standard\nC       since ANSI FORTRAN 66 \nC       =======================================================================\n       \nC       This yields the same results as .EQ., but has lower operator precedence\nC       and only works with LOGICAL operands:\n       PRINT *, 'a equivalent to b is ', A .EQV. B\n       \nC       This yields the same results as .NE., but has lower operator precedence\nC       and only works with LOGICAL operands (this operation is also commonly\nC       called \"exclusive or\"):\n       PRINT *, 'a not equivalent to b is ', A .NEQV. B\n       END\n", "target": "def logic(a, b):\n    print('a and b:', a and b)\n    print('a or b:', a or b)\n    print('not a:', not a)\n"}
{"id": 80345, "name": "Perfect shuffle", "source": "Translate Fortran to C#: MODULE PERFECT_SHUFFLE\n     IMPLICIT NONE\n\n     CONTAINS\n\n     \n     FUNCTION SHUFFLE(NUM_ARR)\n          INTEGER, DIMENSION(:), INTENT(IN) :: NUM_ARR\n          INTEGER, DIMENSION(SIZE(NUM_ARR)) :: SHUFFLE\n          INTEGER :: I, IDX\n\n          IF (MOD(SIZE(NUM_ARR), 2) .NE. 0) THEN\n              WRITE(*,*) \"ERROR: SIZE OF DECK MUST BE EVEN NUMBER\"\n              CALL EXIT(1)\n          END IF\n\n          IDX = 1\n\n          DO I=1, SIZE(NUM_ARR)/2\n              SHUFFLE(IDX) = NUM_ARR(I)\n              SHUFFLE(IDX+1) = NUM_ARR(SIZE(NUM_ARR)/2+I)\n              IDX = IDX + 2\n          END DO\n\n    END FUNCTION SHUFFLE\n\n    \n    FUNCTION COMPARE_ARRAYS(ARRAY_1, ARRAY_2)\n        INTEGER, DIMENSION(:) :: ARRAY_1, ARRAY_2\n        LOGICAL :: COMPARE_ARRAYS\n        INTEGER :: I\n\n        DO I=1,SIZE(ARRAY_1)\n            IF (ARRAY_1(I) .NE. ARRAY_2(I)) THEN\n                COMPARE_ARRAYS = .FALSE.\n                RETURN\n            END IF\n        END DO\n\n        COMPARE_ARRAYS = .TRUE.\n    END FUNCTION COMPARE_ARRAYS\n\n    \n    FUNCTION GEN_DECK(DECK_SIZE)\n        INTEGER, INTENT(IN) :: DECK_SIZE\n        INTEGER, DIMENSION(DECK_SIZE) :: GEN_DECK\n        INTEGER :: I\n\n        GEN_DECK = (/(I, I=1,DECK_SIZE)/)\n    END FUNCTION GEN_DECK\nEND MODULE PERFECT_SHUFFLE\n\n\n\nPROGRAM DEMO_PERFECT_SHUFFLE\n    USE PERFECT_SHUFFLE\n    IMPLICIT NONE\n\n    INTEGER, PARAMETER, DIMENSION(7) :: DECK_SIZES = (/8, 24, 52, 100, 1020, 1024, 10000/)\n    INTEGER, DIMENSION(:), ALLOCATABLE :: DECK, SHUFFLED\n    INTEGER :: I, COUNTER\n\n    WRITE(*,'(A, A, A)') \"input (deck size)\", \" | \", \"output (number of shuffles required)\"\n    WRITE(*,*) REPEAT(\"-\", 55)\n\n    DO I=1, SIZE(DECK_SIZES)\n        IF (I .GT. 1) THEN\n            DEALLOCATE(DECK)\n            DEALLOCATE(SHUFFLED)\n        END IF\n        ALLOCATE(DECK(DECK_SIZES(I)))\n        ALLOCATE(SHUFFLED(DECK_SIZES(I)))\n        DECK = GEN_DECK(DECK_SIZES(I))\n        SHUFFLED = SHUFFLE(DECK)\n        COUNTER = 1\n        DO WHILE (.NOT. COMPARE_ARRAYS(DECK, SHUFFLED))\n            SHUFFLED = SHUFFLE(SHUFFLED)\n            COUNTER = COUNTER + 1\n        END DO\n\n        WRITE(*,'(I17, A, I35)') DECK_SIZES(I), \" | \", COUNTER\n   END DO\nEND PROGRAM DEMO_PERFECT_SHUFFLE\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\npublic static class PerfectShuffle\n{\n    static void Main()\n    {\n        foreach (int input in new [] {8, 24, 52, 100, 1020, 1024, 10000}) {\n            int[] numbers = Enumerable.Range(1, input).ToArray();\n            Console.WriteLine($\"{input} cards: {ShuffleThrough(numbers).Count()}\");\n        }\n\n        IEnumerable<T[]> ShuffleThrough<T>(T[] original) {\n            T[] copy = (T[])original.Clone();\n            do {\n                yield return copy = Shuffle(copy);\n            } while (!Enumerable.SequenceEqual(original, copy));\n        }\n    }\n\n    public static T[] Shuffle<T>(T[] array) {\n        if (array.Length % 2 != 0) throw new ArgumentException(\"Length must be even.\");\n        int half = array.Length / 2;\n        T[] result = new T[array.Length];\n        for (int t = 0, l = 0, r = half; l < half; t+=2, l++, r++) {\n            result[t] = array[l];\n            result[t+1] = array[r];\n        }\n        return result;\n    }\n    \n}\n"}
{"id": 80346, "name": "Perfect shuffle", "source": "Translate Fortran to C#: MODULE PERFECT_SHUFFLE\n     IMPLICIT NONE\n\n     CONTAINS\n\n     \n     FUNCTION SHUFFLE(NUM_ARR)\n          INTEGER, DIMENSION(:), INTENT(IN) :: NUM_ARR\n          INTEGER, DIMENSION(SIZE(NUM_ARR)) :: SHUFFLE\n          INTEGER :: I, IDX\n\n          IF (MOD(SIZE(NUM_ARR), 2) .NE. 0) THEN\n              WRITE(*,*) \"ERROR: SIZE OF DECK MUST BE EVEN NUMBER\"\n              CALL EXIT(1)\n          END IF\n\n          IDX = 1\n\n          DO I=1, SIZE(NUM_ARR)/2\n              SHUFFLE(IDX) = NUM_ARR(I)\n              SHUFFLE(IDX+1) = NUM_ARR(SIZE(NUM_ARR)/2+I)\n              IDX = IDX + 2\n          END DO\n\n    END FUNCTION SHUFFLE\n\n    \n    FUNCTION COMPARE_ARRAYS(ARRAY_1, ARRAY_2)\n        INTEGER, DIMENSION(:) :: ARRAY_1, ARRAY_2\n        LOGICAL :: COMPARE_ARRAYS\n        INTEGER :: I\n\n        DO I=1,SIZE(ARRAY_1)\n            IF (ARRAY_1(I) .NE. ARRAY_2(I)) THEN\n                COMPARE_ARRAYS = .FALSE.\n                RETURN\n            END IF\n        END DO\n\n        COMPARE_ARRAYS = .TRUE.\n    END FUNCTION COMPARE_ARRAYS\n\n    \n    FUNCTION GEN_DECK(DECK_SIZE)\n        INTEGER, INTENT(IN) :: DECK_SIZE\n        INTEGER, DIMENSION(DECK_SIZE) :: GEN_DECK\n        INTEGER :: I\n\n        GEN_DECK = (/(I, I=1,DECK_SIZE)/)\n    END FUNCTION GEN_DECK\nEND MODULE PERFECT_SHUFFLE\n\n\n\nPROGRAM DEMO_PERFECT_SHUFFLE\n    USE PERFECT_SHUFFLE\n    IMPLICIT NONE\n\n    INTEGER, PARAMETER, DIMENSION(7) :: DECK_SIZES = (/8, 24, 52, 100, 1020, 1024, 10000/)\n    INTEGER, DIMENSION(:), ALLOCATABLE :: DECK, SHUFFLED\n    INTEGER :: I, COUNTER\n\n    WRITE(*,'(A, A, A)') \"input (deck size)\", \" | \", \"output (number of shuffles required)\"\n    WRITE(*,*) REPEAT(\"-\", 55)\n\n    DO I=1, SIZE(DECK_SIZES)\n        IF (I .GT. 1) THEN\n            DEALLOCATE(DECK)\n            DEALLOCATE(SHUFFLED)\n        END IF\n        ALLOCATE(DECK(DECK_SIZES(I)))\n        ALLOCATE(SHUFFLED(DECK_SIZES(I)))\n        DECK = GEN_DECK(DECK_SIZES(I))\n        SHUFFLED = SHUFFLE(DECK)\n        COUNTER = 1\n        DO WHILE (.NOT. COMPARE_ARRAYS(DECK, SHUFFLED))\n            SHUFFLED = SHUFFLE(SHUFFLED)\n            COUNTER = COUNTER + 1\n        END DO\n\n        WRITE(*,'(I17, A, I35)') DECK_SIZES(I), \" | \", COUNTER\n   END DO\nEND PROGRAM DEMO_PERFECT_SHUFFLE\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\npublic static class PerfectShuffle\n{\n    static void Main()\n    {\n        foreach (int input in new [] {8, 24, 52, 100, 1020, 1024, 10000}) {\n            int[] numbers = Enumerable.Range(1, input).ToArray();\n            Console.WriteLine($\"{input} cards: {ShuffleThrough(numbers).Count()}\");\n        }\n\n        IEnumerable<T[]> ShuffleThrough<T>(T[] original) {\n            T[] copy = (T[])original.Clone();\n            do {\n                yield return copy = Shuffle(copy);\n            } while (!Enumerable.SequenceEqual(original, copy));\n        }\n    }\n\n    public static T[] Shuffle<T>(T[] array) {\n        if (array.Length % 2 != 0) throw new ArgumentException(\"Length must be even.\");\n        int half = array.Length / 2;\n        T[] result = new T[array.Length];\n        for (int t = 0, l = 0, r = half; l < half; t+=2, l++, r++) {\n            result[t] = array[l];\n            result[t+1] = array[r];\n        }\n        return result;\n    }\n    \n}\n"}
{"id": 80352, "name": "Perfect shuffle", "source": "Translate Fortran to Java: MODULE PERFECT_SHUFFLE\n     IMPLICIT NONE\n\n     CONTAINS\n\n     \n     FUNCTION SHUFFLE(NUM_ARR)\n          INTEGER, DIMENSION(:), INTENT(IN) :: NUM_ARR\n          INTEGER, DIMENSION(SIZE(NUM_ARR)) :: SHUFFLE\n          INTEGER :: I, IDX\n\n          IF (MOD(SIZE(NUM_ARR), 2) .NE. 0) THEN\n              WRITE(*,*) \"ERROR: SIZE OF DECK MUST BE EVEN NUMBER\"\n              CALL EXIT(1)\n          END IF\n\n          IDX = 1\n\n          DO I=1, SIZE(NUM_ARR)/2\n              SHUFFLE(IDX) = NUM_ARR(I)\n              SHUFFLE(IDX+1) = NUM_ARR(SIZE(NUM_ARR)/2+I)\n              IDX = IDX + 2\n          END DO\n\n    END FUNCTION SHUFFLE\n\n    \n    FUNCTION COMPARE_ARRAYS(ARRAY_1, ARRAY_2)\n        INTEGER, DIMENSION(:) :: ARRAY_1, ARRAY_2\n        LOGICAL :: COMPARE_ARRAYS\n        INTEGER :: I\n\n        DO I=1,SIZE(ARRAY_1)\n            IF (ARRAY_1(I) .NE. ARRAY_2(I)) THEN\n                COMPARE_ARRAYS = .FALSE.\n                RETURN\n            END IF\n        END DO\n\n        COMPARE_ARRAYS = .TRUE.\n    END FUNCTION COMPARE_ARRAYS\n\n    \n    FUNCTION GEN_DECK(DECK_SIZE)\n        INTEGER, INTENT(IN) :: DECK_SIZE\n        INTEGER, DIMENSION(DECK_SIZE) :: GEN_DECK\n        INTEGER :: I\n\n        GEN_DECK = (/(I, I=1,DECK_SIZE)/)\n    END FUNCTION GEN_DECK\nEND MODULE PERFECT_SHUFFLE\n\n\n\nPROGRAM DEMO_PERFECT_SHUFFLE\n    USE PERFECT_SHUFFLE\n    IMPLICIT NONE\n\n    INTEGER, PARAMETER, DIMENSION(7) :: DECK_SIZES = (/8, 24, 52, 100, 1020, 1024, 10000/)\n    INTEGER, DIMENSION(:), ALLOCATABLE :: DECK, SHUFFLED\n    INTEGER :: I, COUNTER\n\n    WRITE(*,'(A, A, A)') \"input (deck size)\", \" | \", \"output (number of shuffles required)\"\n    WRITE(*,*) REPEAT(\"-\", 55)\n\n    DO I=1, SIZE(DECK_SIZES)\n        IF (I .GT. 1) THEN\n            DEALLOCATE(DECK)\n            DEALLOCATE(SHUFFLED)\n        END IF\n        ALLOCATE(DECK(DECK_SIZES(I)))\n        ALLOCATE(SHUFFLED(DECK_SIZES(I)))\n        DECK = GEN_DECK(DECK_SIZES(I))\n        SHUFFLED = SHUFFLE(DECK)\n        COUNTER = 1\n        DO WHILE (.NOT. COMPARE_ARRAYS(DECK, SHUFFLED))\n            SHUFFLED = SHUFFLE(SHUFFLED)\n            COUNTER = COUNTER + 1\n        END DO\n\n        WRITE(*,'(I17, A, I35)') DECK_SIZES(I), \" | \", COUNTER\n   END DO\nEND PROGRAM DEMO_PERFECT_SHUFFLE\n", "target": "import java.util.Arrays;\nimport java.util.stream.IntStream;\n\npublic class PerfectShuffle {\n\n    public static void main(String[] args) {\n        int[] sizes = {8, 24, 52, 100, 1020, 1024, 10_000};\n        for (int size : sizes)\n            System.out.printf(\"%5d\u00a0: %5d%n\", size, perfectShuffle(size));\n    }\n\n    static int perfectShuffle(int size) {\n        if (size % 2 != 0)\n            throw new IllegalArgumentException(\"size must be even\");\n\n        int half = size / 2;\n        int[] a = IntStream.range(0, size).toArray();\n        int[] original = a.clone();\n        int[] aa = new int[size];\n\n        for (int count = 1; true; count++) {\n            System.arraycopy(a, 0, aa, 0, size);\n\n            for (int i = 0; i < half; i++) {\n                a[2 * i] = aa[i];\n                a[2 * i + 1] = aa[i + half];\n            }\n\n            if (Arrays.equals(a, original))\n                return count;\n        }\n    }\n}\n"}
{"id": 80353, "name": "Perfect shuffle", "source": "Translate Fortran to Java: MODULE PERFECT_SHUFFLE\n     IMPLICIT NONE\n\n     CONTAINS\n\n     \n     FUNCTION SHUFFLE(NUM_ARR)\n          INTEGER, DIMENSION(:), INTENT(IN) :: NUM_ARR\n          INTEGER, DIMENSION(SIZE(NUM_ARR)) :: SHUFFLE\n          INTEGER :: I, IDX\n\n          IF (MOD(SIZE(NUM_ARR), 2) .NE. 0) THEN\n              WRITE(*,*) \"ERROR: SIZE OF DECK MUST BE EVEN NUMBER\"\n              CALL EXIT(1)\n          END IF\n\n          IDX = 1\n\n          DO I=1, SIZE(NUM_ARR)/2\n              SHUFFLE(IDX) = NUM_ARR(I)\n              SHUFFLE(IDX+1) = NUM_ARR(SIZE(NUM_ARR)/2+I)\n              IDX = IDX + 2\n          END DO\n\n    END FUNCTION SHUFFLE\n\n    \n    FUNCTION COMPARE_ARRAYS(ARRAY_1, ARRAY_2)\n        INTEGER, DIMENSION(:) :: ARRAY_1, ARRAY_2\n        LOGICAL :: COMPARE_ARRAYS\n        INTEGER :: I\n\n        DO I=1,SIZE(ARRAY_1)\n            IF (ARRAY_1(I) .NE. ARRAY_2(I)) THEN\n                COMPARE_ARRAYS = .FALSE.\n                RETURN\n            END IF\n        END DO\n\n        COMPARE_ARRAYS = .TRUE.\n    END FUNCTION COMPARE_ARRAYS\n\n    \n    FUNCTION GEN_DECK(DECK_SIZE)\n        INTEGER, INTENT(IN) :: DECK_SIZE\n        INTEGER, DIMENSION(DECK_SIZE) :: GEN_DECK\n        INTEGER :: I\n\n        GEN_DECK = (/(I, I=1,DECK_SIZE)/)\n    END FUNCTION GEN_DECK\nEND MODULE PERFECT_SHUFFLE\n\n\n\nPROGRAM DEMO_PERFECT_SHUFFLE\n    USE PERFECT_SHUFFLE\n    IMPLICIT NONE\n\n    INTEGER, PARAMETER, DIMENSION(7) :: DECK_SIZES = (/8, 24, 52, 100, 1020, 1024, 10000/)\n    INTEGER, DIMENSION(:), ALLOCATABLE :: DECK, SHUFFLED\n    INTEGER :: I, COUNTER\n\n    WRITE(*,'(A, A, A)') \"input (deck size)\", \" | \", \"output (number of shuffles required)\"\n    WRITE(*,*) REPEAT(\"-\", 55)\n\n    DO I=1, SIZE(DECK_SIZES)\n        IF (I .GT. 1) THEN\n            DEALLOCATE(DECK)\n            DEALLOCATE(SHUFFLED)\n        END IF\n        ALLOCATE(DECK(DECK_SIZES(I)))\n        ALLOCATE(SHUFFLED(DECK_SIZES(I)))\n        DECK = GEN_DECK(DECK_SIZES(I))\n        SHUFFLED = SHUFFLE(DECK)\n        COUNTER = 1\n        DO WHILE (.NOT. COMPARE_ARRAYS(DECK, SHUFFLED))\n            SHUFFLED = SHUFFLE(SHUFFLED)\n            COUNTER = COUNTER + 1\n        END DO\n\n        WRITE(*,'(I17, A, I35)') DECK_SIZES(I), \" | \", COUNTER\n   END DO\nEND PROGRAM DEMO_PERFECT_SHUFFLE\n", "target": "import java.util.Arrays;\nimport java.util.stream.IntStream;\n\npublic class PerfectShuffle {\n\n    public static void main(String[] args) {\n        int[] sizes = {8, 24, 52, 100, 1020, 1024, 10_000};\n        for (int size : sizes)\n            System.out.printf(\"%5d\u00a0: %5d%n\", size, perfectShuffle(size));\n    }\n\n    static int perfectShuffle(int size) {\n        if (size % 2 != 0)\n            throw new IllegalArgumentException(\"size must be even\");\n\n        int half = size / 2;\n        int[] a = IntStream.range(0, size).toArray();\n        int[] original = a.clone();\n        int[] aa = new int[size];\n\n        for (int count = 1; true; count++) {\n            System.arraycopy(a, 0, aa, 0, size);\n\n            for (int i = 0; i < half; i++) {\n                a[2 * i] = aa[i];\n                a[2 * i + 1] = aa[i + half];\n            }\n\n            if (Arrays.equals(a, original))\n                return count;\n        }\n    }\n}\n"}
{"id": 80354, "name": "Perfect shuffle", "source": "Translate Fortran to Python: MODULE PERFECT_SHUFFLE\n     IMPLICIT NONE\n\n     CONTAINS\n\n     \n     FUNCTION SHUFFLE(NUM_ARR)\n          INTEGER, DIMENSION(:), INTENT(IN) :: NUM_ARR\n          INTEGER, DIMENSION(SIZE(NUM_ARR)) :: SHUFFLE\n          INTEGER :: I, IDX\n\n          IF (MOD(SIZE(NUM_ARR), 2) .NE. 0) THEN\n              WRITE(*,*) \"ERROR: SIZE OF DECK MUST BE EVEN NUMBER\"\n              CALL EXIT(1)\n          END IF\n\n          IDX = 1\n\n          DO I=1, SIZE(NUM_ARR)/2\n              SHUFFLE(IDX) = NUM_ARR(I)\n              SHUFFLE(IDX+1) = NUM_ARR(SIZE(NUM_ARR)/2+I)\n              IDX = IDX + 2\n          END DO\n\n    END FUNCTION SHUFFLE\n\n    \n    FUNCTION COMPARE_ARRAYS(ARRAY_1, ARRAY_2)\n        INTEGER, DIMENSION(:) :: ARRAY_1, ARRAY_2\n        LOGICAL :: COMPARE_ARRAYS\n        INTEGER :: I\n\n        DO I=1,SIZE(ARRAY_1)\n            IF (ARRAY_1(I) .NE. ARRAY_2(I)) THEN\n                COMPARE_ARRAYS = .FALSE.\n                RETURN\n            END IF\n        END DO\n\n        COMPARE_ARRAYS = .TRUE.\n    END FUNCTION COMPARE_ARRAYS\n\n    \n    FUNCTION GEN_DECK(DECK_SIZE)\n        INTEGER, INTENT(IN) :: DECK_SIZE\n        INTEGER, DIMENSION(DECK_SIZE) :: GEN_DECK\n        INTEGER :: I\n\n        GEN_DECK = (/(I, I=1,DECK_SIZE)/)\n    END FUNCTION GEN_DECK\nEND MODULE PERFECT_SHUFFLE\n\n\n\nPROGRAM DEMO_PERFECT_SHUFFLE\n    USE PERFECT_SHUFFLE\n    IMPLICIT NONE\n\n    INTEGER, PARAMETER, DIMENSION(7) :: DECK_SIZES = (/8, 24, 52, 100, 1020, 1024, 10000/)\n    INTEGER, DIMENSION(:), ALLOCATABLE :: DECK, SHUFFLED\n    INTEGER :: I, COUNTER\n\n    WRITE(*,'(A, A, A)') \"input (deck size)\", \" | \", \"output (number of shuffles required)\"\n    WRITE(*,*) REPEAT(\"-\", 55)\n\n    DO I=1, SIZE(DECK_SIZES)\n        IF (I .GT. 1) THEN\n            DEALLOCATE(DECK)\n            DEALLOCATE(SHUFFLED)\n        END IF\n        ALLOCATE(DECK(DECK_SIZES(I)))\n        ALLOCATE(SHUFFLED(DECK_SIZES(I)))\n        DECK = GEN_DECK(DECK_SIZES(I))\n        SHUFFLED = SHUFFLE(DECK)\n        COUNTER = 1\n        DO WHILE (.NOT. COMPARE_ARRAYS(DECK, SHUFFLED))\n            SHUFFLED = SHUFFLE(SHUFFLED)\n            COUNTER = COUNTER + 1\n        END DO\n\n        WRITE(*,'(I17, A, I35)') DECK_SIZES(I), \" | \", COUNTER\n   END DO\nEND PROGRAM DEMO_PERFECT_SHUFFLE\n", "target": "import doctest\nimport random\n\n\ndef flatten(lst):\n    \n    return [i for sublst in lst for i in sublst]\n\ndef magic_shuffle(deck):\n    \n    half = len(deck) // 2 \n    return flatten(zip(deck[:half], deck[half:]))\n\ndef after_how_many_is_equal(shuffle_type,start,end):\n    \n\n    start = shuffle_type(start)\n    counter = 1\n    while start != end:\n        start = shuffle_type(start)\n        counter += 1\n    return counter\n\ndef main():\n    doctest.testmod()\n\n    print(\"Length of the deck of cards | Perfect shuffles needed to obtain the same deck back\")\n    for length in (8, 24, 52, 100, 1020, 1024, 10000):\n        deck = list(range(length))\n        shuffles_needed = after_how_many_is_equal(magic_shuffle,deck,deck)\n        print(\"{} | {}\".format(length,shuffles_needed))\n\n\nif __name__ == \"__main__\":\n    main()\n"}
{"id": 80355, "name": "Perfect shuffle", "source": "Translate Fortran to Python: MODULE PERFECT_SHUFFLE\n     IMPLICIT NONE\n\n     CONTAINS\n\n     \n     FUNCTION SHUFFLE(NUM_ARR)\n          INTEGER, DIMENSION(:), INTENT(IN) :: NUM_ARR\n          INTEGER, DIMENSION(SIZE(NUM_ARR)) :: SHUFFLE\n          INTEGER :: I, IDX\n\n          IF (MOD(SIZE(NUM_ARR), 2) .NE. 0) THEN\n              WRITE(*,*) \"ERROR: SIZE OF DECK MUST BE EVEN NUMBER\"\n              CALL EXIT(1)\n          END IF\n\n          IDX = 1\n\n          DO I=1, SIZE(NUM_ARR)/2\n              SHUFFLE(IDX) = NUM_ARR(I)\n              SHUFFLE(IDX+1) = NUM_ARR(SIZE(NUM_ARR)/2+I)\n              IDX = IDX + 2\n          END DO\n\n    END FUNCTION SHUFFLE\n\n    \n    FUNCTION COMPARE_ARRAYS(ARRAY_1, ARRAY_2)\n        INTEGER, DIMENSION(:) :: ARRAY_1, ARRAY_2\n        LOGICAL :: COMPARE_ARRAYS\n        INTEGER :: I\n\n        DO I=1,SIZE(ARRAY_1)\n            IF (ARRAY_1(I) .NE. ARRAY_2(I)) THEN\n                COMPARE_ARRAYS = .FALSE.\n                RETURN\n            END IF\n        END DO\n\n        COMPARE_ARRAYS = .TRUE.\n    END FUNCTION COMPARE_ARRAYS\n\n    \n    FUNCTION GEN_DECK(DECK_SIZE)\n        INTEGER, INTENT(IN) :: DECK_SIZE\n        INTEGER, DIMENSION(DECK_SIZE) :: GEN_DECK\n        INTEGER :: I\n\n        GEN_DECK = (/(I, I=1,DECK_SIZE)/)\n    END FUNCTION GEN_DECK\nEND MODULE PERFECT_SHUFFLE\n\n\n\nPROGRAM DEMO_PERFECT_SHUFFLE\n    USE PERFECT_SHUFFLE\n    IMPLICIT NONE\n\n    INTEGER, PARAMETER, DIMENSION(7) :: DECK_SIZES = (/8, 24, 52, 100, 1020, 1024, 10000/)\n    INTEGER, DIMENSION(:), ALLOCATABLE :: DECK, SHUFFLED\n    INTEGER :: I, COUNTER\n\n    WRITE(*,'(A, A, A)') \"input (deck size)\", \" | \", \"output (number of shuffles required)\"\n    WRITE(*,*) REPEAT(\"-\", 55)\n\n    DO I=1, SIZE(DECK_SIZES)\n        IF (I .GT. 1) THEN\n            DEALLOCATE(DECK)\n            DEALLOCATE(SHUFFLED)\n        END IF\n        ALLOCATE(DECK(DECK_SIZES(I)))\n        ALLOCATE(SHUFFLED(DECK_SIZES(I)))\n        DECK = GEN_DECK(DECK_SIZES(I))\n        SHUFFLED = SHUFFLE(DECK)\n        COUNTER = 1\n        DO WHILE (.NOT. COMPARE_ARRAYS(DECK, SHUFFLED))\n            SHUFFLED = SHUFFLE(SHUFFLED)\n            COUNTER = COUNTER + 1\n        END DO\n\n        WRITE(*,'(I17, A, I35)') DECK_SIZES(I), \" | \", COUNTER\n   END DO\nEND PROGRAM DEMO_PERFECT_SHUFFLE\n", "target": "import doctest\nimport random\n\n\ndef flatten(lst):\n    \n    return [i for sublst in lst for i in sublst]\n\ndef magic_shuffle(deck):\n    \n    half = len(deck) // 2 \n    return flatten(zip(deck[:half], deck[half:]))\n\ndef after_how_many_is_equal(shuffle_type,start,end):\n    \n\n    start = shuffle_type(start)\n    counter = 1\n    while start != end:\n        start = shuffle_type(start)\n        counter += 1\n    return counter\n\ndef main():\n    doctest.testmod()\n\n    print(\"Length of the deck of cards | Perfect shuffles needed to obtain the same deck back\")\n    for length in (8, 24, 52, 100, 1020, 1024, 10000):\n        deck = list(range(length))\n        shuffles_needed = after_how_many_is_equal(magic_shuffle,deck,deck)\n        print(\"{} | {}\".format(length,shuffles_needed))\n\n\nif __name__ == \"__main__\":\n    main()\n"}
{"id": 80628, "name": "Abstract type", "source": "Translate Fortran to C#:  \n   \n   type, abstract :: TFigure\n      real(rdp) :: area\n   contains\n      \n      procedure(calculate_area), deferred, pass :: calculate_area\n   end type TFigure\n   \n   abstract interface\n      function  calculate_area(this)\n         import TFigure \n         implicit none\n         class(TFigure) :: this\n         real(rdp) :: calculate_area\n      end function calculate_area\n   end interface\n", "target": "abstract class Class1\n{\n   public abstract void method1();\n\n   public int method2()\n   {\n      return 0;\n   }\n}\n"}
{"id": 80632, "name": "Abstract type", "source": "Translate Fortran to Java:  \n   \n   type, abstract :: TFigure\n      real(rdp) :: area\n   contains\n      \n      procedure(calculate_area), deferred, pass :: calculate_area\n   end type TFigure\n   \n   abstract interface\n      function  calculate_area(this)\n         import TFigure \n         implicit none\n         class(TFigure) :: this\n         real(rdp) :: calculate_area\n      end function calculate_area\n   end interface\n", "target": "public abstract class Abs {\n    public abstract int method1(double value);\n    protected abstract int method2(String name);\n    int add(int a, int b) {\n        return a + b;\n    }\n}\n"}
{"id": 80633, "name": "Abstract type", "source": "Translate Fortran to Python:  \n   \n   type, abstract :: TFigure\n      real(rdp) :: area\n   contains\n      \n      procedure(calculate_area), deferred, pass :: calculate_area\n   end type TFigure\n   \n   abstract interface\n      function  calculate_area(this)\n         import TFigure \n         implicit none\n         class(TFigure) :: this\n         real(rdp) :: calculate_area\n      end function calculate_area\n   end interface\n", "target": "class BaseQueue(object):\n    \n    def __init__(self):\n        self.contents = list()\n        raise NotImplementedError\n    def Enqueue(self, item):\n        raise NotImplementedError\n    def Dequeue(self):\n        raise NotImplementedError\n    def Print_Contents(self):\n        for i in self.contents:\n            print i,\n"}
{"id": 80858, "name": "Conway's Game of Life", "source": "Translate Fortran to C#:  PROGRAM LIFE_2D\n   IMPLICIT NONE\n \n   INTEGER, PARAMETER :: gridsize = 10\n   LOGICAL :: cells(0:gridsize+1,0:gridsize+1) = .FALSE.\n   INTEGER :: i, j, generation=0\n   REAL :: rnums(gridsize,gridsize)\n \n \n \n \n \n \n    cells(3:5,3:5) = .TRUE. ; cells(6:8,6:8) = .TRUE.                      \n \n \n \n   \n   CALL Drawgen(cells(1:gridsize, 1:gridsize), generation)\n   DO generation = 1, 8\n      CALL NextgenV2(cells)\n      CALL Drawgen(cells(1:gridsize, 1:gridsize), generation)\n   END DO\n \n CONTAINS\n \n   SUBROUTINE Drawgen(cells, gen)\n     LOGICAL, INTENT(IN OUT) :: cells(:,:)\n     INTEGER, INTENT(IN) :: gen\n \n     WRITE(*, \"(A,I0)\") \"Generation \", gen \n     DO i = 1, SIZE(cells,1)\n        DO j = 1, SIZE(cells,2)\n           IF (cells(i,j)) THEN\n              WRITE(*, \"(A)\", ADVANCE = \"NO\") \"#\"\n           ELSE\n              WRITE(*, \"(A)\", ADVANCE = \"NO\") \" \"\n           END IF\n        END DO\n        WRITE(*,*)\n     END DO\n     WRITE(*,*)\n   END SUBROUTINE Drawgen\n \n  SUBROUTINE Nextgen(cells)\n     LOGICAL, INTENT(IN OUT) :: cells(0:,0:)\n     LOGICAL :: buffer(0:SIZE(cells, 1)-1, 0:SIZE(cells, 2)-1)\n     INTEGER :: neighbours, i, j\n   \n     buffer = cells   \n     DO j = 1, SIZE(cells, 2)-2\n        DO i = 1, SIZE(cells, 1)-2\n          if(buffer(i, j)) then\n            neighbours = sum(count(buffer(i-1:i+1, j-1:j+1), 1)) - 1\n          else\n            neighbours = sum(count(buffer(i-1:i+1, j-1:j+1), 1))\n          end if\n  \n          SELECT CASE(neighbours)\n            CASE (0:1, 4:8)\n               cells(i,j) = .FALSE.\n  \n            CASE (2)\n               \n  \n            CASE (3)\n               cells(i,j) = .TRUE.\n          END SELECT\n          \n        END DO\n     END DO\n  END SUBROUTINE Nextgen\n\n\n\n\n\n\n\n\n  PURE SUBROUTINE NextgenV2(cells)\n     LOGICAL, INTENT(IN OUT) :: cells(:,:)\n     INTEGER(KIND=1) :: buffer(1:SIZE(cells, 1)-2,1:SIZE(cells, 2)-2)\n     INTEGER :: gridsize, i, j\n     \n     gridsize=SIZE(cells, 1)\n     buffer=0\n     \n     DO j=-1, 1\n        DO i=-1,1\n           IF(i==0 .AND. j==0) CYCLE\n           WHERE(cells(i+2:gridsize-i-1,j+2:gridsize-j-1)) buffer=buffer+1\n        END DO\n     END DO\n\n     WHERE(buffer<2 .or. buffer>3) cells(2:gridsize-1,2:gridsize-1) = .FALSE.\n     WHERE(buffer==3) cells(2:gridsize-1,2:gridsize-1) = .TRUE.\n  END SUBROUTINE NextgenV2\n\n END PROGRAM LIFE_2D\n", "target": "using System;\nusing System.Text;\nusing System.Threading;\n \nnamespace ConwaysGameOfLife\n{\n    \n    class Program\n    {\n        \n        private const int DELAY = 50;\n \n        \n        private const ConsoleColor DEAD_COLOR = ConsoleColor.White;\n        private const ConsoleColor LIVE_COLOR = ConsoleColor.Black;\n \n        \n        private const ConsoleColor EXTRA_COLOR = ConsoleColor.Gray;\n \n        private const char EMPTY_BLOCK_CHAR = ' ';\n        private const char FULL_BLOCK_CHAR = '\\u2588';\n \n        \n        private static bool[,] board;\n \n        \n        private static int width = 32;\n        private static int height = 32;\n \n        \n        private static bool loopEdges = true;\n \n \n        static void Main(string[] args)\n        {\n            \n            initializeDemoBoard();\n \n            initializeConsole();\n \n            \n            while (!Console.KeyAvailable || Console.ReadKey(true).Key != ConsoleKey.Escape) {\n                Program.drawBoard();\n                Program.updateBoard();\n \n                \n                Thread.Sleep(DELAY);\n            }\n        }\n \n        \n        private static void initializeConsole()\n        {\n            Console.BackgroundColor = EXTRA_COLOR;\n            Console.Clear();\n \n            Console.CursorVisible = false;\n \n            \n            \n            int width = Math.Max(Program.width, 8) * 2 + 1;\n            int height = Math.Max(Program.height, 8) + 1;\n            Console.SetWindowSize(width, height);\n            Console.SetBufferSize(width, height);\n \n            Console.BackgroundColor = DEAD_COLOR;\n            Console.ForegroundColor = LIVE_COLOR;\n        }\n \n        \n        private static void initializeRandomBoard()\n        {\n            var random = new Random();\n \n            Program.board = new bool[Program.width, Program.height];\n            for (var y = 0; y < Program.height; y++) {\n                for (var x = 0; x < Program.width; x++) {\n                    \n                    Program.board[x, y] = random.Next(2) == 0;\n                }\n            }\n        }\n \n        \n        private static void initializeDemoBoard()\n        {\n            Program.width = 3;\n            Program.height = 3;\n \n            Program.loopEdges = false;\n \n            Program.board = new bool[3, 3];\n            Program.board[1, 0] = true;\n            Program.board[1, 1] = true;\n            Program.board[1, 2] = true;\n        }\n \n        \n        private static void drawBoard()\n        {\n            \n            var builder = new StringBuilder();\n \n            for (var y = 0; y < Program.height; y++) {\n                for (var x = 0; x < Program.width; x++) {\n                    char c = Program.board[x, y] ? FULL_BLOCK_CHAR : EMPTY_BLOCK_CHAR;\n \n                    \n                    builder.Append(c);\n                    builder.Append(c);\n                }\n                builder.Append('\\n');\n            }\n \n            \n            Console.SetCursorPosition(0, 0);\n            Console.Write (builder.ToString());\n        }\n \n        \n        private static void updateBoard()\n        {\n            \n            bool[,] newBoard = new bool[Program.width, Program.height];\n \n            for (var y = 0; y < Program.height; y++) {\n                for (var x = 0; x < Program.width; x++) {\n                    var n = countLiveNeighbors(x, y);\n                    var c = Program.board[x, y];\n \n                    \n                    \n                    newBoard[x, y] = c && (n == 2 || n == 3) || !c && n == 3;\n                }\n            }\n \n            \n            Program.board = newBoard;\n        }\n \n        \n        private static int countLiveNeighbors(int x, int y)\n        {\n            \n            int value = 0;\n \n            \n            for (var j = -1; j <= 1; j++) {\n                \n                if (!Program.loopEdges && y + j < 0 || y + j >= Program.height) {\n                    continue;\n                }\n \n                \n                int k = (y + j + Program.height) % Program.height;\n \n                for (var i = -1; i <= 1; i++) {\n                    \n                    if (!Program.loopEdges && x + i < 0 || x + i >= Program.width) {\n                        continue;\n                    }\n \n                    \n                    int h = (x + i + Program.width) % Program.width;\n \n                    \n                    value += Program.board[h, k] ? 1 : 0;\n                }\n            }\n \n            \n            return value - (Program.board[x, y] ? 1 : 0);\n        }\n    }\n}\n"}
{"id": 80862, "name": "Conway's Game of Life", "source": "Translate Fortran to Java:  PROGRAM LIFE_2D\n   IMPLICIT NONE\n \n   INTEGER, PARAMETER :: gridsize = 10\n   LOGICAL :: cells(0:gridsize+1,0:gridsize+1) = .FALSE.\n   INTEGER :: i, j, generation=0\n   REAL :: rnums(gridsize,gridsize)\n \n \n \n \n \n \n    cells(3:5,3:5) = .TRUE. ; cells(6:8,6:8) = .TRUE.                      \n \n \n \n   \n   CALL Drawgen(cells(1:gridsize, 1:gridsize), generation)\n   DO generation = 1, 8\n      CALL NextgenV2(cells)\n      CALL Drawgen(cells(1:gridsize, 1:gridsize), generation)\n   END DO\n \n CONTAINS\n \n   SUBROUTINE Drawgen(cells, gen)\n     LOGICAL, INTENT(IN OUT) :: cells(:,:)\n     INTEGER, INTENT(IN) :: gen\n \n     WRITE(*, \"(A,I0)\") \"Generation \", gen \n     DO i = 1, SIZE(cells,1)\n        DO j = 1, SIZE(cells,2)\n           IF (cells(i,j)) THEN\n              WRITE(*, \"(A)\", ADVANCE = \"NO\") \"#\"\n           ELSE\n              WRITE(*, \"(A)\", ADVANCE = \"NO\") \" \"\n           END IF\n        END DO\n        WRITE(*,*)\n     END DO\n     WRITE(*,*)\n   END SUBROUTINE Drawgen\n \n  SUBROUTINE Nextgen(cells)\n     LOGICAL, INTENT(IN OUT) :: cells(0:,0:)\n     LOGICAL :: buffer(0:SIZE(cells, 1)-1, 0:SIZE(cells, 2)-1)\n     INTEGER :: neighbours, i, j\n   \n     buffer = cells   \n     DO j = 1, SIZE(cells, 2)-2\n        DO i = 1, SIZE(cells, 1)-2\n          if(buffer(i, j)) then\n            neighbours = sum(count(buffer(i-1:i+1, j-1:j+1), 1)) - 1\n          else\n            neighbours = sum(count(buffer(i-1:i+1, j-1:j+1), 1))\n          end if\n  \n          SELECT CASE(neighbours)\n            CASE (0:1, 4:8)\n               cells(i,j) = .FALSE.\n  \n            CASE (2)\n               \n  \n            CASE (3)\n               cells(i,j) = .TRUE.\n          END SELECT\n          \n        END DO\n     END DO\n  END SUBROUTINE Nextgen\n\n\n\n\n\n\n\n\n  PURE SUBROUTINE NextgenV2(cells)\n     LOGICAL, INTENT(IN OUT) :: cells(:,:)\n     INTEGER(KIND=1) :: buffer(1:SIZE(cells, 1)-2,1:SIZE(cells, 2)-2)\n     INTEGER :: gridsize, i, j\n     \n     gridsize=SIZE(cells, 1)\n     buffer=0\n     \n     DO j=-1, 1\n        DO i=-1,1\n           IF(i==0 .AND. j==0) CYCLE\n           WHERE(cells(i+2:gridsize-i-1,j+2:gridsize-j-1)) buffer=buffer+1\n        END DO\n     END DO\n\n     WHERE(buffer<2 .or. buffer>3) cells(2:gridsize-1,2:gridsize-1) = .FALSE.\n     WHERE(buffer==3) cells(2:gridsize-1,2:gridsize-1) = .TRUE.\n  END SUBROUTINE NextgenV2\n\n END PROGRAM LIFE_2D\n", "target": "public class GameOfLife{\n\tpublic static void main(String[] args){\n\t\tString[] dish= {\n\t\t\t\t\"_#_\",\n\t\t\t\t\"_#_\",\n\t\t\t\t\"_#_\",};\n\t\tint gens= 3;\n\t\tfor(int i= 0;i < gens;i++){\n\t\t\tSystem.out.println(\"Generation \" + i + \":\");\n\t\t\tprint(dish);\n\t\t\tdish= life(dish);\n\t\t}\n\t}\n\n\tpublic static String[] life(String[] dish){\n\t\tString[] newGen= new String[dish.length];\n\t\tfor(int row= 0;row < dish.length;row++){\n\t\t\tnewGen[row]= \"\";\n\t\t\tfor(int i= 0;i < dish[row].length();i++){\n\t\t\t\tString above= \"\";\n\t\t\t\tString same= \"\";\n\t\t\t\tString below= \"\";\n\t\t\t\tif(i == 0){\n\t\t\t\t\t\n\t\t\t\t\t\n\t\t\t\t\tabove= (row == 0) ? null : dish[row - 1].substring(i,\n\t\t\t\t\t\t\t\t\ti + 2);\n\t\t\t\t\tsame= dish[row].substring(i + 1, i + 2);\n\t\t\t\t\t\n\t\t\t\t\t\n\t\t\t\t\tbelow= (row == dish.length - 1) ? null : dish[row + 1]\n\t\t\t\t\t\t\t\t\t.substring(i, i + 2);\n\t\t\t\t}else if(i == dish[row].length() - 1){\n\t\t\t\t\t\n\t\t\t\t\t\n\t\t\t\t\tabove= (row == 0) ? null : dish[row - 1].substring(i - 1,\n\t\t\t\t\t\t\t\t\ti + 1);\n\t\t\t\t\tsame= dish[row].substring(i - 1, i);\n\t\t\t\t\t\n\t\t\t\t\t\n\t\t\t\t\tbelow= (row == dish.length - 1) ? null : dish[row + 1]\n\t\t\t\t\t\t\t\t\t.substring(i - 1, i + 1);\n\t\t\t\t}else{\n\t\t\t\t\t\n\t\t\t\t\t\n\t\t\t\t\tabove= (row == 0) ? null : dish[row - 1].substring(i - 1,\n\t\t\t\t\t\t\t\t\ti + 2);\n\t\t\t\t\tsame= dish[row].substring(i - 1, i)\n\t\t\t\t\t\t\t\t\t+ dish[row].substring(i + 1, i + 2);\n\t\t\t\t\t\n\t\t\t\t\t\n\t\t\t\t\tbelow= (row == dish.length - 1) ? null : dish[row + 1]\n\t\t\t\t\t\t\t\t\t.substring(i - 1, i + 2);\n\t\t\t\t}\n\t\t\t\tint neighbors= getNeighbors(above, same, below);\n\t\t\t\tif(neighbors < 2 || neighbors > 3){\n\t\t\t\t\tnewGen[row]+= \"_\";\n\t\t\t\t}else if(neighbors == 3){\n\t\t\t\t\tnewGen[row]+= \"#\";\n\t\t\t\t}else{\n\t\t\t\t\tnewGen[row]+= dish[row].charAt(i);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn newGen;\n\t}\n\n\tpublic static int getNeighbors(String above, String same, String below){\n\t\tint ans= 0;\n\t\tif(above != null){\n\t\t\tfor(char x: above.toCharArray()){\n\t\t\t\tif(x == '#') ans++;\n\t\t\t}\n\t\t}\n\t\tfor(char x: same.toCharArray()){\n\t\t\tif(x == '#') ans++;\n\t\t}\n\t\tif(below != null){\n\t\t\tfor(char x: below.toCharArray()){\n\t\t\t\tif(x == '#') ans++;\n\t\t\t}\n\t\t}\n\t\treturn ans;\n\t}\n\n\tpublic static void print(String[] dish){\n\t\tfor(String s: dish){\n\t\t\tSystem.out.println(s);\n\t\t}\n\t}\n}\n"}
{"id": 80863, "name": "Conway's Game of Life", "source": "Translate Fortran to Python:  PROGRAM LIFE_2D\n   IMPLICIT NONE\n \n   INTEGER, PARAMETER :: gridsize = 10\n   LOGICAL :: cells(0:gridsize+1,0:gridsize+1) = .FALSE.\n   INTEGER :: i, j, generation=0\n   REAL :: rnums(gridsize,gridsize)\n \n \n \n \n \n \n    cells(3:5,3:5) = .TRUE. ; cells(6:8,6:8) = .TRUE.                      \n \n \n \n   \n   CALL Drawgen(cells(1:gridsize, 1:gridsize), generation)\n   DO generation = 1, 8\n      CALL NextgenV2(cells)\n      CALL Drawgen(cells(1:gridsize, 1:gridsize), generation)\n   END DO\n \n CONTAINS\n \n   SUBROUTINE Drawgen(cells, gen)\n     LOGICAL, INTENT(IN OUT) :: cells(:,:)\n     INTEGER, INTENT(IN) :: gen\n \n     WRITE(*, \"(A,I0)\") \"Generation \", gen \n     DO i = 1, SIZE(cells,1)\n        DO j = 1, SIZE(cells,2)\n           IF (cells(i,j)) THEN\n              WRITE(*, \"(A)\", ADVANCE = \"NO\") \"#\"\n           ELSE\n              WRITE(*, \"(A)\", ADVANCE = \"NO\") \" \"\n           END IF\n        END DO\n        WRITE(*,*)\n     END DO\n     WRITE(*,*)\n   END SUBROUTINE Drawgen\n \n  SUBROUTINE Nextgen(cells)\n     LOGICAL, INTENT(IN OUT) :: cells(0:,0:)\n     LOGICAL :: buffer(0:SIZE(cells, 1)-1, 0:SIZE(cells, 2)-1)\n     INTEGER :: neighbours, i, j\n   \n     buffer = cells   \n     DO j = 1, SIZE(cells, 2)-2\n        DO i = 1, SIZE(cells, 1)-2\n          if(buffer(i, j)) then\n            neighbours = sum(count(buffer(i-1:i+1, j-1:j+1), 1)) - 1\n          else\n            neighbours = sum(count(buffer(i-1:i+1, j-1:j+1), 1))\n          end if\n  \n          SELECT CASE(neighbours)\n            CASE (0:1, 4:8)\n               cells(i,j) = .FALSE.\n  \n            CASE (2)\n               \n  \n            CASE (3)\n               cells(i,j) = .TRUE.\n          END SELECT\n          \n        END DO\n     END DO\n  END SUBROUTINE Nextgen\n\n\n\n\n\n\n\n\n  PURE SUBROUTINE NextgenV2(cells)\n     LOGICAL, INTENT(IN OUT) :: cells(:,:)\n     INTEGER(KIND=1) :: buffer(1:SIZE(cells, 1)-2,1:SIZE(cells, 2)-2)\n     INTEGER :: gridsize, i, j\n     \n     gridsize=SIZE(cells, 1)\n     buffer=0\n     \n     DO j=-1, 1\n        DO i=-1,1\n           IF(i==0 .AND. j==0) CYCLE\n           WHERE(cells(i+2:gridsize-i-1,j+2:gridsize-j-1)) buffer=buffer+1\n        END DO\n     END DO\n\n     WHERE(buffer<2 .or. buffer>3) cells(2:gridsize-1,2:gridsize-1) = .FALSE.\n     WHERE(buffer==3) cells(2:gridsize-1,2:gridsize-1) = .TRUE.\n  END SUBROUTINE NextgenV2\n\n END PROGRAM LIFE_2D\n", "target": "cell_size = 10\nsample = 10 \nplay = False   \nlast_cell = 0\n\ndef setup():\n    global grid, next_grid, rows, cols\n    size(800, 500)\n\n    rows = height / cell_size\n    cols = width / cell_size\n    grid = empty_grid()\n    next_grid = empty_grid()\n    randomize_grid()\n\n    println(\"Press 'space' to start/stop\")\n    println(\"'e' to clear all cells\")\n    println(\"'b' demonstrate 'blinker'\")\n    println(\"'g' demonstrate glider\")\n    println(\"'r' to randomize grid\")\n    println(\"'+' and '-' to change speed\")\n\ndef draw():\n    background(0)\n    for i in range(cols):\n        x = i * cell_size\n        for j in range(rows):\n            y = j * cell_size\n            current_state = grid[i][j]\n            fill(255)\n            noStroke()\n            if current_state:\n                rect(x, y, cell_size, cell_size)\n            if play:\n                ngbs_alive = calc_ngbs_alive(i, j)\n                result = rule(current_state, ngbs_alive)\n                next_grid[i][j] = result\n                \n    if play and frameCount % sample == 0 and not mousePressed:\n        step()\n\ndef rule(current, ngbs):\n    \n    if ngbs < 2 or ngbs > 3:\n        return 0  \n    elif ngbs == 3:\n        return 1  \n    else:\n        return current  \n\ndef calc_ngbs_alive(i, j):\n    NEIGHBOURS = ((-1, 00), (01, 00),  \n                  (-1, -1), (00, -1),\n                  (01, -1), (-1, 01),\n                  (00, 01), (01, 01))\n    alive = 0\n    for iv, jv in NEIGHBOURS:\n        alive += grid[(i + iv) % cols][(j + jv) % rows]\n    return alive\n\ndef empty_grid():\n    grid = []\n    for _ in range(cols):\n        grid.append([0] * rows)\n    return grid\n\ndef randomize_grid():\n    from random import choice\n    for i in range(cols):\n        for j in range(rows):\n            grid[i][j] = choice((0, 1))\n\ndef step():\n    global grid, next_grid\n    grid = next_grid\n    next_grid = empty_grid()\n\ndef keyReleased():\n    global grid, play, sample\n    if key == \"e\":\n        grid = empty_grid()\n    if key == \"r\":\n        randomize_grid()\n    if key == \"g\":\n         grid[10][10:13] = [0, 1, 0]       \n         grid[11][10:13] = [0, 0, 1]       \n         grid[12][10:13] = [1, 1, 1]       \n    if key == \"b\":\n         grid[10][10:13] = [0, 1, 0]       \n         grid[11][10:13] = [0, 1, 0]       \n         grid[12][10:13] = [0, 1, 0]               \n    if key == \" \":\n        play = not play \n    if  str(key) in '+=':\n        sample = max(sample - 1, 1);\n    if key == '-':\n        sample += 1\n\ndef mousePressed():\n    paint()\n    \ndef mouseDragged():\n    paint()\n\ndef paint():\n    global last_cell\n    i, j = mouseX // cell_size, mouseY // cell_size\n    p = j * cols + i\n    if p != last_cell:\n        last_cell = p\n        grid[i][j] = (1, 0)[grid[i][j]]\n"}
{"id": 81529, "name": "Compile-time calculation", "source": "Translate Fortran to C#:  program test\n\n   implicit none\n   integer,parameter :: t = 10*9*8*7*6*5*4*3*2  \n\n   write(*,*) t  \n\n end program test\n", "target": "using System;\n\npublic static class Program\n{\n    public const int FACTORIAL_10 = 10 * 9 * 8 * 7 * 6 * 5 * 4 * 3 * 2 * 1;\n    static void Main()\n    {\n        Console.WriteLine(FACTORIAL_10);\n    }\n}\n"}
{"id": 81530, "name": "Compile-time calculation", "source": "Translate Fortran to C#:  program test\n\n   implicit none\n   integer,parameter :: t = 10*9*8*7*6*5*4*3*2  \n\n   write(*,*) t  \n\n end program test\n", "target": "using System;\n\npublic static class Program\n{\n    public const int FACTORIAL_10 = 10 * 9 * 8 * 7 * 6 * 5 * 4 * 3 * 2 * 1;\n    static void Main()\n    {\n        Console.WriteLine(FACTORIAL_10);\n    }\n}\n"}
{"id": 81910, "name": "Gaussian elimination", "source": "Translate Fortran to C#:         program ge\n\n          real, allocatable :: a(:,:),b(:)\n          a = reshape(                             &\n          [1.0, 1.00, 1.00,  1.00,   1.00,   1.00, &\n           0.0, 0.63, 1.26,  1.88,   2.51,   3.14, &\n           0.0, 0.39, 1.58,  3.55,   6.32,   9.87, &\n           0.0, 0.25, 1.98,  6.70,  15.88,  31.01, &\n           0.0, 0.16, 2.49, 12.62,  39.90,  97.41, &\n           0.0, 0.10, 3.13, 23.80, 100.28, 306.02], [6,6] )\n          b = [-0.01, 0.61, 0.91, 0.99, 0.60, 0.02]\n          print'(f15.7)',solve_wbs(ge_wpp(a,b))\n\n        contains\n  \n          function solve_wbs(u) result(x) \n            real                 :: u(:,:)\n            integer              :: i,n\n            real   , allocatable :: x(:)\n            n = size(u,1)\n            allocate(x(n))\n            forall (i=n:1:-1) x(i) = ( u(i,n+1) - sum(u(i,i+1:n)*x(i+1:n)) ) / u(i,i)\n          end function\n\n          function  ge_wpp(a,b) result(u) \n            real                 :: a(:,:),b(:),upi\n            integer              :: i,j,n,p\n            real   , allocatable :: u(:,:)\n            n = size(a,1)\n            u = reshape( [a,b], [n,n+1] )\n            do j=1,n\n              p = maxloc(abs(u(j:n,j)),1) + j-1 \n              if (p /= j) u([p,j],j) = u([j,p],j)\n              u(j+1:,j) = u(j+1:,j)/u(j,j)\n              do i=j+1,n+1\n                upi = u(p,i)\n                if (p /= j) u([p,j],i) = u([j,p],i)\n                u(j+1:n,i) = u(j+1:n,i) - upi*u(j+1:n,j)\n              end do\n            end do\n          end function\n\n        end program\n", "target": "using System;\n\nnamespace Rosetta\n{\n    internal class Vector\n    {\n        private double[] b;\n        internal readonly int rows;\n\n        internal Vector(int rows)\n        {\n            this.rows = rows;\n            b = new double[rows];\n        }\n\n        internal Vector(double[] initArray)\n        {\n            b = (double[])initArray.Clone();\n            rows = b.Length;\n        }\n\n        internal Vector Clone()\n        {\n            Vector v = new Vector(b);\n            return v;\n        }\n\n        internal double this[int row]\n        {\n            get { return b[row]; }\n            set { b[row] = value; }\n        }\n\n        internal void SwapRows(int r1, int r2)\n        {\n            if (r1 == r2) return;\n            double tmp = b[r1];\n            b[r1] = b[r2];\n            b[r2] = tmp;\n        }\n\n        internal double norm(double[] weights)\n        {\n            double sum = 0;\n            for (int i = 0; i < rows; i++)\n            {\n                double d = b[i] * weights[i];\n                sum +=  d*d;\n            }\n            return Math.Sqrt(sum);\n        }\n\n        internal void print()\n        {\n            for (int i = 0; i < rows; i++)\n                Console.WriteLine(b[i]);\n            Console.WriteLine();\n        }\n\n        public static Vector operator-(Vector lhs, Vector rhs)\n        {\n            Vector v = new Vector(lhs.rows);\n            for (int i = 0; i < lhs.rows; i++)\n                v[i] = lhs[i] - rhs[i];\n            return v;\n        }\n    }\n\n    class Matrix\n    {\n        private double[] b;\n        internal readonly int rows, cols;\n\n        internal Matrix(int rows, int cols)\n        {\n            this.rows = rows;\n            this.cols = cols;\n            b = new double[rows * cols];            \n        }\n\n        internal Matrix(int size)\n        {\n            this.rows = size;\n            this.cols = size;\n            b = new double[rows * cols];\n            for (int i = 0; i < size; i++)\n                this[i, i] = 1;\n        }\n\n        internal Matrix(int rows, int cols, double[] initArray)\n        {\n            this.rows = rows;\n            this.cols = cols;\n            b = (double[])initArray.Clone();\n            if (b.Length != rows * cols) throw new Exception(\"bad init array\");\n        }\n\n        internal double this[int row, int col]\n        {\n            get { return b[row * cols + col]; }\n            set { b[row * cols + col] = value; }\n        }        \n        \n        public static Vector operator*(Matrix lhs, Vector rhs)\n        {\n            if (lhs.cols != rhs.rows) throw new Exception(\"I can't multiply matrix by vector\");\n            Vector v = new Vector(lhs.rows);\n            for (int i = 0; i < lhs.rows; i++)\n            {\n                double sum = 0;\n                for (int j = 0; j < rhs.rows; j++)\n                    sum += lhs[i,j]*rhs[j];\n                v[i] = sum;\n            }\n            return v;\n        }\n\n        internal void SwapRows(int r1, int r2)\n        {\n            if (r1 == r2) return;\n            int firstR1 = r1 * cols;\n            int firstR2 = r2 * cols;\n            for (int i = 0; i < cols; i++)\n            {\n                double tmp = b[firstR1 + i];\n                b[firstR1 + i] = b[firstR2 + i];\n                b[firstR2 + i] = tmp;\n            }\n        }\n\n        \n        internal void ElimPartial(Vector B)\n        {\n            for (int diag = 0; diag < rows; diag++)\n            {\n                int max_row = diag;\n                double max_val = Math.Abs(this[diag, diag]);\n                double d;\n                for (int row = diag + 1; row < rows; row++)\n                    if ((d = Math.Abs(this[row, diag])) > max_val)\n                    {\n                        max_row = row;\n                        max_val = d;\n                    }\n                SwapRows(diag, max_row);\n                B.SwapRows(diag, max_row);\n                double invd = 1 / this[diag, diag];\n                for (int col = diag; col < cols; col++)\n                    this[diag, col] *= invd;\n                B[diag] *= invd;\n                for (int row = 0; row < rows; row++)\n                {\n                    d = this[row, diag];\n                    if (row != diag)\n                    {\n                        for (int col = diag; col < cols; col++)\n                            this[row, col] -= d * this[diag, col];\n                        B[row] -= d * B[diag];\n                    }\n                }\n            }\n        }\n        \n        internal void print()\n        {\n            for (int i = 0; i < rows; i++)\n            {\n                for (int j = 0; j < cols; j++)\n                    Console.Write(this[i,j].ToString()+\"  \");\n                Console.WriteLine();\n            }\n        }\n    }\n}\n"}
{"id": 81911, "name": "Gaussian elimination", "source": "Translate Fortran to C#:         program ge\n\n          real, allocatable :: a(:,:),b(:)\n          a = reshape(                             &\n          [1.0, 1.00, 1.00,  1.00,   1.00,   1.00, &\n           0.0, 0.63, 1.26,  1.88,   2.51,   3.14, &\n           0.0, 0.39, 1.58,  3.55,   6.32,   9.87, &\n           0.0, 0.25, 1.98,  6.70,  15.88,  31.01, &\n           0.0, 0.16, 2.49, 12.62,  39.90,  97.41, &\n           0.0, 0.10, 3.13, 23.80, 100.28, 306.02], [6,6] )\n          b = [-0.01, 0.61, 0.91, 0.99, 0.60, 0.02]\n          print'(f15.7)',solve_wbs(ge_wpp(a,b))\n\n        contains\n  \n          function solve_wbs(u) result(x) \n            real                 :: u(:,:)\n            integer              :: i,n\n            real   , allocatable :: x(:)\n            n = size(u,1)\n            allocate(x(n))\n            forall (i=n:1:-1) x(i) = ( u(i,n+1) - sum(u(i,i+1:n)*x(i+1:n)) ) / u(i,i)\n          end function\n\n          function  ge_wpp(a,b) result(u) \n            real                 :: a(:,:),b(:),upi\n            integer              :: i,j,n,p\n            real   , allocatable :: u(:,:)\n            n = size(a,1)\n            u = reshape( [a,b], [n,n+1] )\n            do j=1,n\n              p = maxloc(abs(u(j:n,j)),1) + j-1 \n              if (p /= j) u([p,j],j) = u([j,p],j)\n              u(j+1:,j) = u(j+1:,j)/u(j,j)\n              do i=j+1,n+1\n                upi = u(p,i)\n                if (p /= j) u([p,j],i) = u([j,p],i)\n                u(j+1:n,i) = u(j+1:n,i) - upi*u(j+1:n,j)\n              end do\n            end do\n          end function\n\n        end program\n", "target": "using System;\n\nnamespace Rosetta\n{\n    internal class Vector\n    {\n        private double[] b;\n        internal readonly int rows;\n\n        internal Vector(int rows)\n        {\n            this.rows = rows;\n            b = new double[rows];\n        }\n\n        internal Vector(double[] initArray)\n        {\n            b = (double[])initArray.Clone();\n            rows = b.Length;\n        }\n\n        internal Vector Clone()\n        {\n            Vector v = new Vector(b);\n            return v;\n        }\n\n        internal double this[int row]\n        {\n            get { return b[row]; }\n            set { b[row] = value; }\n        }\n\n        internal void SwapRows(int r1, int r2)\n        {\n            if (r1 == r2) return;\n            double tmp = b[r1];\n            b[r1] = b[r2];\n            b[r2] = tmp;\n        }\n\n        internal double norm(double[] weights)\n        {\n            double sum = 0;\n            for (int i = 0; i < rows; i++)\n            {\n                double d = b[i] * weights[i];\n                sum +=  d*d;\n            }\n            return Math.Sqrt(sum);\n        }\n\n        internal void print()\n        {\n            for (int i = 0; i < rows; i++)\n                Console.WriteLine(b[i]);\n            Console.WriteLine();\n        }\n\n        public static Vector operator-(Vector lhs, Vector rhs)\n        {\n            Vector v = new Vector(lhs.rows);\n            for (int i = 0; i < lhs.rows; i++)\n                v[i] = lhs[i] - rhs[i];\n            return v;\n        }\n    }\n\n    class Matrix\n    {\n        private double[] b;\n        internal readonly int rows, cols;\n\n        internal Matrix(int rows, int cols)\n        {\n            this.rows = rows;\n            this.cols = cols;\n            b = new double[rows * cols];            \n        }\n\n        internal Matrix(int size)\n        {\n            this.rows = size;\n            this.cols = size;\n            b = new double[rows * cols];\n            for (int i = 0; i < size; i++)\n                this[i, i] = 1;\n        }\n\n        internal Matrix(int rows, int cols, double[] initArray)\n        {\n            this.rows = rows;\n            this.cols = cols;\n            b = (double[])initArray.Clone();\n            if (b.Length != rows * cols) throw new Exception(\"bad init array\");\n        }\n\n        internal double this[int row, int col]\n        {\n            get { return b[row * cols + col]; }\n            set { b[row * cols + col] = value; }\n        }        \n        \n        public static Vector operator*(Matrix lhs, Vector rhs)\n        {\n            if (lhs.cols != rhs.rows) throw new Exception(\"I can't multiply matrix by vector\");\n            Vector v = new Vector(lhs.rows);\n            for (int i = 0; i < lhs.rows; i++)\n            {\n                double sum = 0;\n                for (int j = 0; j < rhs.rows; j++)\n                    sum += lhs[i,j]*rhs[j];\n                v[i] = sum;\n            }\n            return v;\n        }\n\n        internal void SwapRows(int r1, int r2)\n        {\n            if (r1 == r2) return;\n            int firstR1 = r1 * cols;\n            int firstR2 = r2 * cols;\n            for (int i = 0; i < cols; i++)\n            {\n                double tmp = b[firstR1 + i];\n                b[firstR1 + i] = b[firstR2 + i];\n                b[firstR2 + i] = tmp;\n            }\n        }\n\n        \n        internal void ElimPartial(Vector B)\n        {\n            for (int diag = 0; diag < rows; diag++)\n            {\n                int max_row = diag;\n                double max_val = Math.Abs(this[diag, diag]);\n                double d;\n                for (int row = diag + 1; row < rows; row++)\n                    if ((d = Math.Abs(this[row, diag])) > max_val)\n                    {\n                        max_row = row;\n                        max_val = d;\n                    }\n                SwapRows(diag, max_row);\n                B.SwapRows(diag, max_row);\n                double invd = 1 / this[diag, diag];\n                for (int col = diag; col < cols; col++)\n                    this[diag, col] *= invd;\n                B[diag] *= invd;\n                for (int row = 0; row < rows; row++)\n                {\n                    d = this[row, diag];\n                    if (row != diag)\n                    {\n                        for (int col = diag; col < cols; col++)\n                            this[row, col] -= d * this[diag, col];\n                        B[row] -= d * B[diag];\n                    }\n                }\n            }\n        }\n        \n        internal void print()\n        {\n            for (int i = 0; i < rows; i++)\n            {\n                for (int j = 0; j < cols; j++)\n                    Console.Write(this[i,j].ToString()+\"  \");\n                Console.WriteLine();\n            }\n        }\n    }\n}\n"}
{"id": 81916, "name": "Gaussian elimination", "source": "Translate Fortran to Java:         program ge\n\n          real, allocatable :: a(:,:),b(:)\n          a = reshape(                             &\n          [1.0, 1.00, 1.00,  1.00,   1.00,   1.00, &\n           0.0, 0.63, 1.26,  1.88,   2.51,   3.14, &\n           0.0, 0.39, 1.58,  3.55,   6.32,   9.87, &\n           0.0, 0.25, 1.98,  6.70,  15.88,  31.01, &\n           0.0, 0.16, 2.49, 12.62,  39.90,  97.41, &\n           0.0, 0.10, 3.13, 23.80, 100.28, 306.02], [6,6] )\n          b = [-0.01, 0.61, 0.91, 0.99, 0.60, 0.02]\n          print'(f15.7)',solve_wbs(ge_wpp(a,b))\n\n        contains\n  \n          function solve_wbs(u) result(x) \n            real                 :: u(:,:)\n            integer              :: i,n\n            real   , allocatable :: x(:)\n            n = size(u,1)\n            allocate(x(n))\n            forall (i=n:1:-1) x(i) = ( u(i,n+1) - sum(u(i,i+1:n)*x(i+1:n)) ) / u(i,i)\n          end function\n\n          function  ge_wpp(a,b) result(u) \n            real                 :: a(:,:),b(:),upi\n            integer              :: i,j,n,p\n            real   , allocatable :: u(:,:)\n            n = size(a,1)\n            u = reshape( [a,b], [n,n+1] )\n            do j=1,n\n              p = maxloc(abs(u(j:n,j)),1) + j-1 \n              if (p /= j) u([p,j],j) = u([j,p],j)\n              u(j+1:,j) = u(j+1:,j)/u(j,j)\n              do i=j+1,n+1\n                upi = u(p,i)\n                if (p /= j) u([p,j],i) = u([j,p],i)\n                u(j+1:n,i) = u(j+1:n,i) - upi*u(j+1:n,j)\n              end do\n            end do\n          end function\n\n        end program\n", "target": "import java.util.Locale;\n\npublic class GaussianElimination {\n    public static double solve(double[][] a, double[][] b) {\n        if (a == null || b == null || a.length == 0 || b.length == 0) {\n            throw new IllegalArgumentException(\"Invalid dimensions\");\n        }\n        \n        int n = b.length, p = b[0].length;\n        if (a.length != n || a[0].length != n) {\n            throw new IllegalArgumentException(\"Invalid dimensions\");\n        }\n\n        double det = 1.0;\n        \n        for (int i = 0; i < n - 1; i++) {\n            int k = i;\n            for (int j = i + 1; j < n; j++) {\n                if (Math.abs(a[j][i]) > Math.abs(a[k][i])) {\n                    k = j;\n                }\n            }\n            \n            if (k != i) {\n                det = -det;\n                \n                for (int j = i; j < n; j++) {\n                    double s = a[i][j];\n                    a[i][j] = a[k][j];\n                    a[k][j] = s;\n                }\n\n                for (int j = 0; j < p; j++) {\n                    double s = b[i][j];\n                    b[i][j] = b[k][j];\n                    b[k][j] = s;\n                }\n            }\n            \n            for (int j = i + 1; j < n; j++) {\n                double s = a[j][i] / a[i][i];\n                for (k = i + 1; k < n; k++) {\n                    a[j][k] -= s * a[i][k];\n                }\n                \n                for (k = 0; k < p; k++) {\n                    b[j][k] -= s * b[i][k];\n                }\n            }\n        }\n        \n        for (int i = n - 1; i >= 0; i--) {\n            for (int j = i + 1; j < n; j++) {\n                double s = a[i][j];\n                for (int k = 0; k < p; k++) {\n                    b[i][k] -= s * b[j][k];\n                }\n            }\n            double s = a[i][i];\n            det *= s;\n            for (int k = 0; k < p; k++) {\n                b[i][k] /= s;\n            }\n        }\n        \n        return det;\n    }\n    \n    public static void main(String[] args) {\n        double[][] a = new double[][] {{4.0, 1.0, 0.0, 0.0, 0.0},\n                                       {1.0, 4.0, 1.0, 0.0, 0.0},\n                                       {0.0, 1.0, 4.0, 1.0, 0.0},\n                                       {0.0, 0.0, 1.0, 4.0, 1.0},\n                                       {0.0, 0.0, 0.0, 1.0, 4.0}};\n\n        double[][] b = new double[][] {{1.0 / 2.0},\n                                       {2.0 / 3.0},\n                                       {3.0 / 4.0},\n                                       {4.0 / 5.0},\n                                       {5.0 / 6.0}};\n                                       \n        double[] x = {39.0 / 400.0,\n                      11.0 / 100.0,\n                      31.0 / 240.0,\n                      37.0 / 300.0,\n                      71.0 / 400.0};\n                                       \n        System.out.println(\"det: \" + solve(a, b));\n        \n\n        for (int i = 0; i < 5; i++) {\n            System.out.printf(Locale.US, \"%12.8f %12.4e\\n\", b[i][0], b[i][0] - x[i]);\n        }\n    }\n}\n"}
{"id": 81917, "name": "Gaussian elimination", "source": "Translate Fortran to Java:         program ge\n\n          real, allocatable :: a(:,:),b(:)\n          a = reshape(                             &\n          [1.0, 1.00, 1.00,  1.00,   1.00,   1.00, &\n           0.0, 0.63, 1.26,  1.88,   2.51,   3.14, &\n           0.0, 0.39, 1.58,  3.55,   6.32,   9.87, &\n           0.0, 0.25, 1.98,  6.70,  15.88,  31.01, &\n           0.0, 0.16, 2.49, 12.62,  39.90,  97.41, &\n           0.0, 0.10, 3.13, 23.80, 100.28, 306.02], [6,6] )\n          b = [-0.01, 0.61, 0.91, 0.99, 0.60, 0.02]\n          print'(f15.7)',solve_wbs(ge_wpp(a,b))\n\n        contains\n  \n          function solve_wbs(u) result(x) \n            real                 :: u(:,:)\n            integer              :: i,n\n            real   , allocatable :: x(:)\n            n = size(u,1)\n            allocate(x(n))\n            forall (i=n:1:-1) x(i) = ( u(i,n+1) - sum(u(i,i+1:n)*x(i+1:n)) ) / u(i,i)\n          end function\n\n          function  ge_wpp(a,b) result(u) \n            real                 :: a(:,:),b(:),upi\n            integer              :: i,j,n,p\n            real   , allocatable :: u(:,:)\n            n = size(a,1)\n            u = reshape( [a,b], [n,n+1] )\n            do j=1,n\n              p = maxloc(abs(u(j:n,j)),1) + j-1 \n              if (p /= j) u([p,j],j) = u([j,p],j)\n              u(j+1:,j) = u(j+1:,j)/u(j,j)\n              do i=j+1,n+1\n                upi = u(p,i)\n                if (p /= j) u([p,j],i) = u([j,p],i)\n                u(j+1:n,i) = u(j+1:n,i) - upi*u(j+1:n,j)\n              end do\n            end do\n          end function\n\n        end program\n", "target": "import java.util.Locale;\n\npublic class GaussianElimination {\n    public static double solve(double[][] a, double[][] b) {\n        if (a == null || b == null || a.length == 0 || b.length == 0) {\n            throw new IllegalArgumentException(\"Invalid dimensions\");\n        }\n        \n        int n = b.length, p = b[0].length;\n        if (a.length != n || a[0].length != n) {\n            throw new IllegalArgumentException(\"Invalid dimensions\");\n        }\n\n        double det = 1.0;\n        \n        for (int i = 0; i < n - 1; i++) {\n            int k = i;\n            for (int j = i + 1; j < n; j++) {\n                if (Math.abs(a[j][i]) > Math.abs(a[k][i])) {\n                    k = j;\n                }\n            }\n            \n            if (k != i) {\n                det = -det;\n                \n                for (int j = i; j < n; j++) {\n                    double s = a[i][j];\n                    a[i][j] = a[k][j];\n                    a[k][j] = s;\n                }\n\n                for (int j = 0; j < p; j++) {\n                    double s = b[i][j];\n                    b[i][j] = b[k][j];\n                    b[k][j] = s;\n                }\n            }\n            \n            for (int j = i + 1; j < n; j++) {\n                double s = a[j][i] / a[i][i];\n                for (k = i + 1; k < n; k++) {\n                    a[j][k] -= s * a[i][k];\n                }\n                \n                for (k = 0; k < p; k++) {\n                    b[j][k] -= s * b[i][k];\n                }\n            }\n        }\n        \n        for (int i = n - 1; i >= 0; i--) {\n            for (int j = i + 1; j < n; j++) {\n                double s = a[i][j];\n                for (int k = 0; k < p; k++) {\n                    b[i][k] -= s * b[j][k];\n                }\n            }\n            double s = a[i][i];\n            det *= s;\n            for (int k = 0; k < p; k++) {\n                b[i][k] /= s;\n            }\n        }\n        \n        return det;\n    }\n    \n    public static void main(String[] args) {\n        double[][] a = new double[][] {{4.0, 1.0, 0.0, 0.0, 0.0},\n                                       {1.0, 4.0, 1.0, 0.0, 0.0},\n                                       {0.0, 1.0, 4.0, 1.0, 0.0},\n                                       {0.0, 0.0, 1.0, 4.0, 1.0},\n                                       {0.0, 0.0, 0.0, 1.0, 4.0}};\n\n        double[][] b = new double[][] {{1.0 / 2.0},\n                                       {2.0 / 3.0},\n                                       {3.0 / 4.0},\n                                       {4.0 / 5.0},\n                                       {5.0 / 6.0}};\n                                       \n        double[] x = {39.0 / 400.0,\n                      11.0 / 100.0,\n                      31.0 / 240.0,\n                      37.0 / 300.0,\n                      71.0 / 400.0};\n                                       \n        System.out.println(\"det: \" + solve(a, b));\n        \n\n        for (int i = 0; i < 5; i++) {\n            System.out.printf(Locale.US, \"%12.8f %12.4e\\n\", b[i][0], b[i][0] - x[i]);\n        }\n    }\n}\n"}
{"id": 81918, "name": "Gaussian elimination", "source": "Translate Fortran to Python:         program ge\n\n          real, allocatable :: a(:,:),b(:)\n          a = reshape(                             &\n          [1.0, 1.00, 1.00,  1.00,   1.00,   1.00, &\n           0.0, 0.63, 1.26,  1.88,   2.51,   3.14, &\n           0.0, 0.39, 1.58,  3.55,   6.32,   9.87, &\n           0.0, 0.25, 1.98,  6.70,  15.88,  31.01, &\n           0.0, 0.16, 2.49, 12.62,  39.90,  97.41, &\n           0.0, 0.10, 3.13, 23.80, 100.28, 306.02], [6,6] )\n          b = [-0.01, 0.61, 0.91, 0.99, 0.60, 0.02]\n          print'(f15.7)',solve_wbs(ge_wpp(a,b))\n\n        contains\n  \n          function solve_wbs(u) result(x) \n            real                 :: u(:,:)\n            integer              :: i,n\n            real   , allocatable :: x(:)\n            n = size(u,1)\n            allocate(x(n))\n            forall (i=n:1:-1) x(i) = ( u(i,n+1) - sum(u(i,i+1:n)*x(i+1:n)) ) / u(i,i)\n          end function\n\n          function  ge_wpp(a,b) result(u) \n            real                 :: a(:,:),b(:),upi\n            integer              :: i,j,n,p\n            real   , allocatable :: u(:,:)\n            n = size(a,1)\n            u = reshape( [a,b], [n,n+1] )\n            do j=1,n\n              p = maxloc(abs(u(j:n,j)),1) + j-1 \n              if (p /= j) u([p,j],j) = u([j,p],j)\n              u(j+1:,j) = u(j+1:,j)/u(j,j)\n              do i=j+1,n+1\n                upi = u(p,i)\n                if (p /= j) u([p,j],i) = u([j,p],i)\n                u(j+1:n,i) = u(j+1:n,i) - upi*u(j+1:n,j)\n              end do\n            end do\n          end function\n\n        end program\n", "target": "\n\n\nimport copy\nfrom fractions import Fraction\n\ndef gauss(a, b):\n    a = copy.deepcopy(a)\n    b = copy.deepcopy(b)\n    n = len(a)\n    p = len(b[0])\n    det = 1\n    for i in range(n - 1):\n        k = i\n        for j in range(i + 1, n):\n            if abs(a[j][i]) > abs(a[k][i]):\n                k = j\n        if k != i:\n            a[i], a[k] = a[k], a[i]\n            b[i], b[k] = b[k], b[i]\n            det = -det\n            \n        for j in range(i + 1, n):\n            t = a[j][i]/a[i][i]\n            for k in range(i + 1, n):\n                a[j][k] -= t*a[i][k]\n            for k in range(p):\n                b[j][k] -= t*b[i][k]\n                \n    for i in range(n - 1, -1, -1):\n        for j in range(i + 1, n):\n            t = a[i][j]\n            for k in range(p):\n                b[i][k] -= t*b[j][k]\n        t = 1/a[i][i]\n        det *= a[i][i]\n        for j in range(p):\n            b[i][j] *= t\n    return det, b\n\ndef zeromat(p, q):\n    return [[0]*q for i in range(p)]\n\ndef matmul(a, b):\n    n, p = len(a), len(a[0])\n    p1, q = len(b), len(b[0])\n    if p != p1:\n        raise ValueError(\"Incompatible dimensions\")\n    c = zeromat(n, q)\n    for i in range(n):\n        for j in range(q):\n                c[i][j] = sum(a[i][k]*b[k][j] for k in range(p))\n    return c\n\n\ndef mapmat(f, a):\n    return [list(map(f, v)) for v in a]\n\ndef ratmat(a):\n    return mapmat(Fraction, a)\n\n\n\na = [[2, 9, 4], [7, 5, 3], [6, 1, 8]]\nb = [[1, 0, 0], [0, 1, 0], [0, 0, 1]]\ndet, c = gauss(a, b)\n\ndet\n-360.0\n\nc\n[[-0.10277777777777776, 0.18888888888888888, -0.019444444444444438],\n[0.10555555555555554, 0.02222222222222223, -0.061111111111111116],\n[0.0638888888888889, -0.14444444444444446, 0.14722222222222223]]\n\n\nmatmul(a, c)\n[[1.0, 0.0, 0.0], [5.551115123125783e-17, 1.0, 0.0],\n[1.1102230246251565e-16, -2.220446049250313e-16, 1.0]]\n\n\n\ndet, c = gauss(ratmat(a), ratmat(b))\n\ndet\nFraction(-360, 1)\n\nc\n[[Fraction(-37, 360), Fraction(17, 90), Fraction(-7, 360)],\n[Fraction(19, 180), Fraction(1, 45), Fraction(-11, 180)],\n[Fraction(23, 360), Fraction(-13, 90), Fraction(53, 360)]]\n\nmatmul(a, c)\n[[Fraction(1, 1), Fraction(0, 1), Fraction(0, 1)],\n[Fraction(0, 1), Fraction(1, 1), Fraction(0, 1)],\n[Fraction(0, 1), Fraction(0, 1), Fraction(1, 1)]]\n"}
{"id": 81919, "name": "Gaussian elimination", "source": "Translate Fortran to Python:         program ge\n\n          real, allocatable :: a(:,:),b(:)\n          a = reshape(                             &\n          [1.0, 1.00, 1.00,  1.00,   1.00,   1.00, &\n           0.0, 0.63, 1.26,  1.88,   2.51,   3.14, &\n           0.0, 0.39, 1.58,  3.55,   6.32,   9.87, &\n           0.0, 0.25, 1.98,  6.70,  15.88,  31.01, &\n           0.0, 0.16, 2.49, 12.62,  39.90,  97.41, &\n           0.0, 0.10, 3.13, 23.80, 100.28, 306.02], [6,6] )\n          b = [-0.01, 0.61, 0.91, 0.99, 0.60, 0.02]\n          print'(f15.7)',solve_wbs(ge_wpp(a,b))\n\n        contains\n  \n          function solve_wbs(u) result(x) \n            real                 :: u(:,:)\n            integer              :: i,n\n            real   , allocatable :: x(:)\n            n = size(u,1)\n            allocate(x(n))\n            forall (i=n:1:-1) x(i) = ( u(i,n+1) - sum(u(i,i+1:n)*x(i+1:n)) ) / u(i,i)\n          end function\n\n          function  ge_wpp(a,b) result(u) \n            real                 :: a(:,:),b(:),upi\n            integer              :: i,j,n,p\n            real   , allocatable :: u(:,:)\n            n = size(a,1)\n            u = reshape( [a,b], [n,n+1] )\n            do j=1,n\n              p = maxloc(abs(u(j:n,j)),1) + j-1 \n              if (p /= j) u([p,j],j) = u([j,p],j)\n              u(j+1:,j) = u(j+1:,j)/u(j,j)\n              do i=j+1,n+1\n                upi = u(p,i)\n                if (p /= j) u([p,j],i) = u([j,p],i)\n                u(j+1:n,i) = u(j+1:n,i) - upi*u(j+1:n,j)\n              end do\n            end do\n          end function\n\n        end program\n", "target": "\n\n\nimport copy\nfrom fractions import Fraction\n\ndef gauss(a, b):\n    a = copy.deepcopy(a)\n    b = copy.deepcopy(b)\n    n = len(a)\n    p = len(b[0])\n    det = 1\n    for i in range(n - 1):\n        k = i\n        for j in range(i + 1, n):\n            if abs(a[j][i]) > abs(a[k][i]):\n                k = j\n        if k != i:\n            a[i], a[k] = a[k], a[i]\n            b[i], b[k] = b[k], b[i]\n            det = -det\n            \n        for j in range(i + 1, n):\n            t = a[j][i]/a[i][i]\n            for k in range(i + 1, n):\n                a[j][k] -= t*a[i][k]\n            for k in range(p):\n                b[j][k] -= t*b[i][k]\n                \n    for i in range(n - 1, -1, -1):\n        for j in range(i + 1, n):\n            t = a[i][j]\n            for k in range(p):\n                b[i][k] -= t*b[j][k]\n        t = 1/a[i][i]\n        det *= a[i][i]\n        for j in range(p):\n            b[i][j] *= t\n    return det, b\n\ndef zeromat(p, q):\n    return [[0]*q for i in range(p)]\n\ndef matmul(a, b):\n    n, p = len(a), len(a[0])\n    p1, q = len(b), len(b[0])\n    if p != p1:\n        raise ValueError(\"Incompatible dimensions\")\n    c = zeromat(n, q)\n    for i in range(n):\n        for j in range(q):\n                c[i][j] = sum(a[i][k]*b[k][j] for k in range(p))\n    return c\n\n\ndef mapmat(f, a):\n    return [list(map(f, v)) for v in a]\n\ndef ratmat(a):\n    return mapmat(Fraction, a)\n\n\n\na = [[2, 9, 4], [7, 5, 3], [6, 1, 8]]\nb = [[1, 0, 0], [0, 1, 0], [0, 0, 1]]\ndet, c = gauss(a, b)\n\ndet\n-360.0\n\nc\n[[-0.10277777777777776, 0.18888888888888888, -0.019444444444444438],\n[0.10555555555555554, 0.02222222222222223, -0.061111111111111116],\n[0.0638888888888889, -0.14444444444444446, 0.14722222222222223]]\n\n\nmatmul(a, c)\n[[1.0, 0.0, 0.0], [5.551115123125783e-17, 1.0, 0.0],\n[1.1102230246251565e-16, -2.220446049250313e-16, 1.0]]\n\n\n\ndet, c = gauss(ratmat(a), ratmat(b))\n\ndet\nFraction(-360, 1)\n\nc\n[[Fraction(-37, 360), Fraction(17, 90), Fraction(-7, 360)],\n[Fraction(19, 180), Fraction(1, 45), Fraction(-11, 180)],\n[Fraction(23, 360), Fraction(-13, 90), Fraction(53, 360)]]\n\nmatmul(a, c)\n[[Fraction(1, 1), Fraction(0, 1), Fraction(0, 1)],\n[Fraction(0, 1), Fraction(1, 1), Fraction(0, 1)],\n[Fraction(0, 1), Fraction(0, 1), Fraction(1, 1)]]\n"}
{"id": 82617, "name": "Averages_Pythagorean means", "source": "Translate Fortran to C#: program Mean\n\n  real :: a(10) = (/ (i, i=1,10) /)\n  real :: amean, gmean, hmean\n\n  amean = sum(a) / size(a)\n  gmean = product(a)**(1.0/size(a))\n  hmean = size(a) / sum(1.0/a)\n\n  if ((amean < gmean) .or. (gmean < hmean)) then\n    print*, \"Error\n  else\n    print*, amean, gmean, hmean\n  end if\n\nend program Mean\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\nusing System.Linq;\n\nnamespace PythMean\n{\n    static class Program\n    {\n        static void Main(string[] args) {\n            var nums = from n in Enumerable.Range(1, 10) select (double)n;\n\n            var a = nums.Average();\n            var g = nums.Gmean();\n            var h = nums.Hmean();\n\n            Console.WriteLine(\"Arithmetic mean {0}\", a);\n            Console.WriteLine(\"Geometric mean  {0}\", g);\n            Console.WriteLine(\"Harmonic mean   {0}\", h);\n\n            Debug.Assert(a >= g && g >= h);\n        }\n\n        \n        static double Gmean(this IEnumerable<double> n) {\n            return Math.Pow(n.Aggregate((s, i) => s * i), 1.0 / n.Count());\n        }\n\n        \n        static double Hmean(this IEnumerable<double> n) {\n            return n.Count() / n.Sum(i => 1.0 / i);\n        }\n    }\n}\n"}
{"id": 82618, "name": "Averages_Pythagorean means", "source": "Translate Fortran to C#: program Mean\n\n  real :: a(10) = (/ (i, i=1,10) /)\n  real :: amean, gmean, hmean\n\n  amean = sum(a) / size(a)\n  gmean = product(a)**(1.0/size(a))\n  hmean = size(a) / sum(1.0/a)\n\n  if ((amean < gmean) .or. (gmean < hmean)) then\n    print*, \"Error\n  else\n    print*, amean, gmean, hmean\n  end if\n\nend program Mean\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\nusing System.Linq;\n\nnamespace PythMean\n{\n    static class Program\n    {\n        static void Main(string[] args) {\n            var nums = from n in Enumerable.Range(1, 10) select (double)n;\n\n            var a = nums.Average();\n            var g = nums.Gmean();\n            var h = nums.Hmean();\n\n            Console.WriteLine(\"Arithmetic mean {0}\", a);\n            Console.WriteLine(\"Geometric mean  {0}\", g);\n            Console.WriteLine(\"Harmonic mean   {0}\", h);\n\n            Debug.Assert(a >= g && g >= h);\n        }\n\n        \n        static double Gmean(this IEnumerable<double> n) {\n            return Math.Pow(n.Aggregate((s, i) => s * i), 1.0 / n.Count());\n        }\n\n        \n        static double Hmean(this IEnumerable<double> n) {\n            return n.Count() / n.Sum(i => 1.0 / i);\n        }\n    }\n}\n"}
{"id": 82623, "name": "Averages_Pythagorean means", "source": "Translate Fortran to Java: program Mean\n\n  real :: a(10) = (/ (i, i=1,10) /)\n  real :: amean, gmean, hmean\n\n  amean = sum(a) / size(a)\n  gmean = product(a)**(1.0/size(a))\n  hmean = size(a) / sum(1.0/a)\n\n  if ((amean < gmean) .or. (gmean < hmean)) then\n    print*, \"Error\n  else\n    print*, amean, gmean, hmean\n  end if\n\nend program Mean\n", "target": "import java.util.Arrays;\nimport java.util.List;\n\npublic class PythagoreanMeans {\n    public static double arithmeticMean(List<Double> numbers) {\n        if (numbers.isEmpty()) return Double.NaN;\n        double mean = 0.0;\n        for (Double number : numbers) {\n            mean += number;\n        }\n        return mean / numbers.size();\n    }\n\n    public static double geometricMean(List<Double> numbers) {\n        if (numbers.isEmpty()) return Double.NaN;\n        double mean = 1.0;\n        for (Double number : numbers) {\n            mean *= number;\n        }\n        return Math.pow(mean, 1.0 / numbers.size());\n    }\n\n    public static double harmonicMean(List<Double> numbers) {\n        if (numbers.isEmpty() || numbers.contains(0.0)) return Double.NaN;\n        double mean = 0.0;\n        for (Double number : numbers) {\n            mean += (1.0 / number);\n        }\n        return numbers.size() / mean;\n    }\n\n    public static void main(String[] args) {\n        Double[] array = {1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0};\n        List<Double> list = Arrays.asList(array);\n        double arithmetic = arithmeticMean(list);\n        double geometric = geometricMean(list);\n        double harmonic = harmonicMean(list);\n        System.out.format(\"A = %f  G = %f  H = %f%n\", arithmetic, geometric, harmonic);\n        System.out.format(\"A >= G is %b, G >= H is %b%n\", (arithmetic >= geometric), (geometric >= harmonic));\n    }\n}\n"}
{"id": 82624, "name": "Averages_Pythagorean means", "source": "Translate Fortran to Java: program Mean\n\n  real :: a(10) = (/ (i, i=1,10) /)\n  real :: amean, gmean, hmean\n\n  amean = sum(a) / size(a)\n  gmean = product(a)**(1.0/size(a))\n  hmean = size(a) / sum(1.0/a)\n\n  if ((amean < gmean) .or. (gmean < hmean)) then\n    print*, \"Error\n  else\n    print*, amean, gmean, hmean\n  end if\n\nend program Mean\n", "target": "import java.util.Arrays;\nimport java.util.List;\n\npublic class PythagoreanMeans {\n    public static double arithmeticMean(List<Double> numbers) {\n        if (numbers.isEmpty()) return Double.NaN;\n        double mean = 0.0;\n        for (Double number : numbers) {\n            mean += number;\n        }\n        return mean / numbers.size();\n    }\n\n    public static double geometricMean(List<Double> numbers) {\n        if (numbers.isEmpty()) return Double.NaN;\n        double mean = 1.0;\n        for (Double number : numbers) {\n            mean *= number;\n        }\n        return Math.pow(mean, 1.0 / numbers.size());\n    }\n\n    public static double harmonicMean(List<Double> numbers) {\n        if (numbers.isEmpty() || numbers.contains(0.0)) return Double.NaN;\n        double mean = 0.0;\n        for (Double number : numbers) {\n            mean += (1.0 / number);\n        }\n        return numbers.size() / mean;\n    }\n\n    public static void main(String[] args) {\n        Double[] array = {1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0};\n        List<Double> list = Arrays.asList(array);\n        double arithmetic = arithmeticMean(list);\n        double geometric = geometricMean(list);\n        double harmonic = harmonicMean(list);\n        System.out.format(\"A = %f  G = %f  H = %f%n\", arithmetic, geometric, harmonic);\n        System.out.format(\"A >= G is %b, G >= H is %b%n\", (arithmetic >= geometric), (geometric >= harmonic));\n    }\n}\n"}
{"id": 82625, "name": "Averages_Pythagorean means", "source": "Translate Fortran to Python: program Mean\n\n  real :: a(10) = (/ (i, i=1,10) /)\n  real :: amean, gmean, hmean\n\n  amean = sum(a) / size(a)\n  gmean = product(a)**(1.0/size(a))\n  hmean = size(a) / sum(1.0/a)\n\n  if ((amean < gmean) .or. (gmean < hmean)) then\n    print*, \"Error\n  else\n    print*, amean, gmean, hmean\n  end if\n\nend program Mean\n", "target": "from operator import mul\nfrom functools import reduce\n\n\ndef amean(num):\n    return sum(num) / len(num)\n\n\ndef gmean(num):\n    return reduce(mul, num, 1)**(1 / len(num))\n\n\ndef hmean(num):\n    return len(num) / sum(1 / n for n in num)\n\n\nnumbers = range(1, 11)  \na, g, h = amean(numbers), gmean(numbers), hmean(numbers)\nprint(a, g, h)\nassert a >= g >= h\n"}
{"id": 82626, "name": "Averages_Pythagorean means", "source": "Translate Fortran to Python: program Mean\n\n  real :: a(10) = (/ (i, i=1,10) /)\n  real :: amean, gmean, hmean\n\n  amean = sum(a) / size(a)\n  gmean = product(a)**(1.0/size(a))\n  hmean = size(a) / sum(1.0/a)\n\n  if ((amean < gmean) .or. (gmean < hmean)) then\n    print*, \"Error\n  else\n    print*, amean, gmean, hmean\n  end if\n\nend program Mean\n", "target": "from operator import mul\nfrom functools import reduce\n\n\ndef amean(num):\n    return sum(num) / len(num)\n\n\ndef gmean(num):\n    return reduce(mul, num, 1)**(1 / len(num))\n\n\ndef hmean(num):\n    return len(num) / sum(1 / n for n in num)\n\n\nnumbers = range(1, 11)  \na, g, h = amean(numbers), gmean(numbers), hmean(numbers)\nprint(a, g, h)\nassert a >= g >= h\n"}
{"id": 83129, "name": "AKS test for primes", "source": "Translate Fortran to C#: program aks\n  implicit none\n\n  \n  integer(kind=16), dimension(:), allocatable :: coeffs\n  integer(kind=16) :: n\n  \n  character(len=40) :: tmp\n\n  \n  do n = 0, 7\n    write(tmp, *) n\n    call polynomial_expansion(n, coeffs)\n    write(*, fmt='(A)', advance='no') '(x - 1)^'//trim(adjustl(tmp))//' ='\n    call print_polynom(coeffs)\n  end do\n\n  \n  do n = 2, 35\n    if (is_prime(n)) write(*, '(I4)', advance='no') n\n  end do\n  write(*, *)\n\n  \n  do n = 2, 124\n    if (is_prime(n)) write(*, '(I4)', advance='no') n\n  end do\n  write(*, *)\n\n  if (allocated(coeffs)) deallocate(coeffs)\ncontains\n  \n  subroutine polynomial_expansion(n, coeffs)\n    integer(kind=16), intent(in) :: n\n    integer(kind=16), dimension(:), allocatable, intent(out) :: coeffs\n    integer(kind=16) :: i, j\n\n    if (allocated(coeffs)) deallocate(coeffs)\n\n    allocate(coeffs(n + 1))\n\n    do i = 1, n + 1\n      coeffs(i) = binomial(n, i - 1)*(-1)**(n - i - 1)\n    end do\n  end subroutine\n\n  \n  \n  function binomial(n, k) result (res)\n    integer(kind=16), intent(in) :: n, k\n    integer(kind=16) :: res\n    integer(kind=16) :: i\n\n    if (k == 0) then\n      res = 1\n      return\n    end if\n\n    res = 1\n    do i = 0, k - 1\n      res = res*(n - i)/(i + 1)\n    end do\n  end function\n\n  \n  subroutine print_polynom(coeffs)\n    integer(kind=16), dimension(:), allocatable, intent(in) :: coeffs\n    integer(kind=4) :: i, p\n    character(len=40) :: cbuf, pbuf\n    logical(kind=1) :: non_zero\n\n    if (.not. allocated(coeffs)) return\n\n    non_zero = .false.\n\n    do i = 1, size(coeffs)\n      if (coeffs(i) .eq. 0) cycle\n\n      p = i - 1\n      write(cbuf, '(I40)') abs(coeffs(i))\n      write(pbuf, '(I40)') p \n\n      if (non_zero) then\n        if (coeffs(i) .gt. 0) then\n          write(*, fmt='(A)', advance='no') ' + '\n        else\n          write(*, fmt='(A)', advance='no') ' - '\n        endif\n      else\n        if (coeffs(i) .gt. 0) then\n          write(*, fmt='(A)', advance='no') '   '\n        else\n          write(*, fmt='(A)', advance='no') ' - '\n        endif\n      endif\n\n      if (p .eq. 0) then\n        write(*, fmt='(A)', advance='no') trim(adjustl(cbuf))\n      elseif (p .eq. 1) then\n        if (coeffs(i) .eq. 1) then\n          write(*, fmt='(A)', advance='no') 'x'\n        else\n          write(*, fmt='(A)', advance='no') trim(adjustl(cbuf))//'x'\n        end if\n      else\n        if (coeffs(i) .eq. 1) then\n          write(*, fmt='(A)', advance='no') 'x^'//trim(adjustl(pbuf))\n        else\n          write(*, fmt='(A)', advance='no') &\n            trim(adjustl(cbuf))//'x^'//trim(adjustl(pbuf))\n        end if\n      end if\n      non_zero = .true.\n    end do\n    \n    write(*, *)\n  end subroutine\n\n  \n  function is_prime(n) result (res)\n    integer(kind=16), intent (in) :: n\n    logical(kind=1) :: res\n    integer(kind=16), dimension(:), allocatable :: coeffs\n    integer(kind=16) :: i\n\n    call polynomial_expansion(n, coeffs)\n    coeffs(1) = coeffs(1) + 1\n    coeffs(n + 1) = coeffs(n + 1) - 1\n\n    res = .true.\n\n    do i = 1, n + 1\n      res = res .and. (mod(coeffs(i), n) == 0)\n    end do\n\n    if (allocated(coeffs)) deallocate(coeffs)\n  end function\nend program aks\n", "target": "using System;\n    public class AksTest\n    {\n        static long[] c = new long[100];\n\n        static void Main(string[] args)\n        {\n        for (int n = 0; n < 10; n++) {\n\t\tcoef(n);\n\t\tConsole.Write(\"(x-1)^\" + n + \" = \");\n\t\tshow(n);\n\t\tConsole.WriteLine(\"\");\n\t}\t \n\t   Console.Write(\"Primes:\");\n\t  for (int n = 1; n <= 63; n++)\n\t     if (is_prime(n))\n\t       Console.Write(n + \" \");\n\t \n\t    Console.WriteLine('\\n');\n            Console.ReadLine();\n        }\n\n        static void coef(int n)\n        {\n            int i, j;\n\n            if (n < 0 || n > 63) System.Environment.Exit(0);\n\n            for (c[i = 0] = 1L; i < n; c[0] = -c[0], i++)\n                for (c[1 + (j = i)] = 1L; j > 0; j--)\n                    c[j] = c[j - 1] - c[j];\n        }\n\n        static bool is_prime(int n)\n        {\n            int i;\n\n            coef(n);\n            c[0] += 1;\n            c[i = n] -= 1;\n\n            while (i-- != 0 && (c[i] % n) == 0) ;\n\n            return i < 0;\n        }\n\n        static void show(int n)\n\t    {\n\t\t    do {\n                Console.Write(\"+\" + c[n] + \"x^\" + n);\n\t\t    }while (n-- != 0);\n\t    }\n    }\n"}
{"id": 83133, "name": "AKS test for primes", "source": "Translate Fortran to Java: program aks\n  implicit none\n\n  \n  integer(kind=16), dimension(:), allocatable :: coeffs\n  integer(kind=16) :: n\n  \n  character(len=40) :: tmp\n\n  \n  do n = 0, 7\n    write(tmp, *) n\n    call polynomial_expansion(n, coeffs)\n    write(*, fmt='(A)', advance='no') '(x - 1)^'//trim(adjustl(tmp))//' ='\n    call print_polynom(coeffs)\n  end do\n\n  \n  do n = 2, 35\n    if (is_prime(n)) write(*, '(I4)', advance='no') n\n  end do\n  write(*, *)\n\n  \n  do n = 2, 124\n    if (is_prime(n)) write(*, '(I4)', advance='no') n\n  end do\n  write(*, *)\n\n  if (allocated(coeffs)) deallocate(coeffs)\ncontains\n  \n  subroutine polynomial_expansion(n, coeffs)\n    integer(kind=16), intent(in) :: n\n    integer(kind=16), dimension(:), allocatable, intent(out) :: coeffs\n    integer(kind=16) :: i, j\n\n    if (allocated(coeffs)) deallocate(coeffs)\n\n    allocate(coeffs(n + 1))\n\n    do i = 1, n + 1\n      coeffs(i) = binomial(n, i - 1)*(-1)**(n - i - 1)\n    end do\n  end subroutine\n\n  \n  \n  function binomial(n, k) result (res)\n    integer(kind=16), intent(in) :: n, k\n    integer(kind=16) :: res\n    integer(kind=16) :: i\n\n    if (k == 0) then\n      res = 1\n      return\n    end if\n\n    res = 1\n    do i = 0, k - 1\n      res = res*(n - i)/(i + 1)\n    end do\n  end function\n\n  \n  subroutine print_polynom(coeffs)\n    integer(kind=16), dimension(:), allocatable, intent(in) :: coeffs\n    integer(kind=4) :: i, p\n    character(len=40) :: cbuf, pbuf\n    logical(kind=1) :: non_zero\n\n    if (.not. allocated(coeffs)) return\n\n    non_zero = .false.\n\n    do i = 1, size(coeffs)\n      if (coeffs(i) .eq. 0) cycle\n\n      p = i - 1\n      write(cbuf, '(I40)') abs(coeffs(i))\n      write(pbuf, '(I40)') p \n\n      if (non_zero) then\n        if (coeffs(i) .gt. 0) then\n          write(*, fmt='(A)', advance='no') ' + '\n        else\n          write(*, fmt='(A)', advance='no') ' - '\n        endif\n      else\n        if (coeffs(i) .gt. 0) then\n          write(*, fmt='(A)', advance='no') '   '\n        else\n          write(*, fmt='(A)', advance='no') ' - '\n        endif\n      endif\n\n      if (p .eq. 0) then\n        write(*, fmt='(A)', advance='no') trim(adjustl(cbuf))\n      elseif (p .eq. 1) then\n        if (coeffs(i) .eq. 1) then\n          write(*, fmt='(A)', advance='no') 'x'\n        else\n          write(*, fmt='(A)', advance='no') trim(adjustl(cbuf))//'x'\n        end if\n      else\n        if (coeffs(i) .eq. 1) then\n          write(*, fmt='(A)', advance='no') 'x^'//trim(adjustl(pbuf))\n        else\n          write(*, fmt='(A)', advance='no') &\n            trim(adjustl(cbuf))//'x^'//trim(adjustl(pbuf))\n        end if\n      end if\n      non_zero = .true.\n    end do\n    \n    write(*, *)\n  end subroutine\n\n  \n  function is_prime(n) result (res)\n    integer(kind=16), intent (in) :: n\n    logical(kind=1) :: res\n    integer(kind=16), dimension(:), allocatable :: coeffs\n    integer(kind=16) :: i\n\n    call polynomial_expansion(n, coeffs)\n    coeffs(1) = coeffs(1) + 1\n    coeffs(n + 1) = coeffs(n + 1) - 1\n\n    res = .true.\n\n    do i = 1, n + 1\n      res = res .and. (mod(coeffs(i), n) == 0)\n    end do\n\n    if (allocated(coeffs)) deallocate(coeffs)\n  end function\nend program aks\n", "target": "public class AksTest {\n    private static final long[] c = new long[64];\n\n    public static void main(String[] args) {\n        for (int n = 0; n < 10; n++) {\n            coeff(n);\n            show(n);\n        }\n\n        System.out.print(\"Primes:\");\n        for (int n = 1; n < c.length; n++)\n            if (isPrime(n))\n                System.out.printf(\" %d\", n);\n\n        System.out.println();\n    }\n\n    static void coeff(int n) {\n        c[0] = 1;\n        for (int i = 0; i < n; c[0] = -c[0], i++) {\n            c[1 + i] = 1;\n            for (int j = i; j > 0; j--)\n                c[j] = c[j - 1] - c[j];\n        }\n    }\n\n    static boolean isPrime(int n) {\n        coeff(n);\n        c[0]++;\n        c[n]--;\n\n        int i = n;\n        while (i-- != 0 && c[i] % n == 0)\n            continue;\n        return i < 0;\n    }\n\n    static void show(int n) {\n        System.out.print(\"(x-1)^\" + n + \" =\");\n        for (int i = n; i >= 0; i--) {\n            System.out.print(\" + \" + c[i] + \"x^\" + i);\n        }\n        System.out.println();\n    }\n}\n"}
{"id": 83134, "name": "AKS test for primes", "source": "Translate Fortran to Python: program aks\n  implicit none\n\n  \n  integer(kind=16), dimension(:), allocatable :: coeffs\n  integer(kind=16) :: n\n  \n  character(len=40) :: tmp\n\n  \n  do n = 0, 7\n    write(tmp, *) n\n    call polynomial_expansion(n, coeffs)\n    write(*, fmt='(A)', advance='no') '(x - 1)^'//trim(adjustl(tmp))//' ='\n    call print_polynom(coeffs)\n  end do\n\n  \n  do n = 2, 35\n    if (is_prime(n)) write(*, '(I4)', advance='no') n\n  end do\n  write(*, *)\n\n  \n  do n = 2, 124\n    if (is_prime(n)) write(*, '(I4)', advance='no') n\n  end do\n  write(*, *)\n\n  if (allocated(coeffs)) deallocate(coeffs)\ncontains\n  \n  subroutine polynomial_expansion(n, coeffs)\n    integer(kind=16), intent(in) :: n\n    integer(kind=16), dimension(:), allocatable, intent(out) :: coeffs\n    integer(kind=16) :: i, j\n\n    if (allocated(coeffs)) deallocate(coeffs)\n\n    allocate(coeffs(n + 1))\n\n    do i = 1, n + 1\n      coeffs(i) = binomial(n, i - 1)*(-1)**(n - i - 1)\n    end do\n  end subroutine\n\n  \n  \n  function binomial(n, k) result (res)\n    integer(kind=16), intent(in) :: n, k\n    integer(kind=16) :: res\n    integer(kind=16) :: i\n\n    if (k == 0) then\n      res = 1\n      return\n    end if\n\n    res = 1\n    do i = 0, k - 1\n      res = res*(n - i)/(i + 1)\n    end do\n  end function\n\n  \n  subroutine print_polynom(coeffs)\n    integer(kind=16), dimension(:), allocatable, intent(in) :: coeffs\n    integer(kind=4) :: i, p\n    character(len=40) :: cbuf, pbuf\n    logical(kind=1) :: non_zero\n\n    if (.not. allocated(coeffs)) return\n\n    non_zero = .false.\n\n    do i = 1, size(coeffs)\n      if (coeffs(i) .eq. 0) cycle\n\n      p = i - 1\n      write(cbuf, '(I40)') abs(coeffs(i))\n      write(pbuf, '(I40)') p \n\n      if (non_zero) then\n        if (coeffs(i) .gt. 0) then\n          write(*, fmt='(A)', advance='no') ' + '\n        else\n          write(*, fmt='(A)', advance='no') ' - '\n        endif\n      else\n        if (coeffs(i) .gt. 0) then\n          write(*, fmt='(A)', advance='no') '   '\n        else\n          write(*, fmt='(A)', advance='no') ' - '\n        endif\n      endif\n\n      if (p .eq. 0) then\n        write(*, fmt='(A)', advance='no') trim(adjustl(cbuf))\n      elseif (p .eq. 1) then\n        if (coeffs(i) .eq. 1) then\n          write(*, fmt='(A)', advance='no') 'x'\n        else\n          write(*, fmt='(A)', advance='no') trim(adjustl(cbuf))//'x'\n        end if\n      else\n        if (coeffs(i) .eq. 1) then\n          write(*, fmt='(A)', advance='no') 'x^'//trim(adjustl(pbuf))\n        else\n          write(*, fmt='(A)', advance='no') &\n            trim(adjustl(cbuf))//'x^'//trim(adjustl(pbuf))\n        end if\n      end if\n      non_zero = .true.\n    end do\n    \n    write(*, *)\n  end subroutine\n\n  \n  function is_prime(n) result (res)\n    integer(kind=16), intent (in) :: n\n    logical(kind=1) :: res\n    integer(kind=16), dimension(:), allocatable :: coeffs\n    integer(kind=16) :: i\n\n    call polynomial_expansion(n, coeffs)\n    coeffs(1) = coeffs(1) + 1\n    coeffs(n + 1) = coeffs(n + 1) - 1\n\n    res = .true.\n\n    do i = 1, n + 1\n      res = res .and. (mod(coeffs(i), n) == 0)\n    end do\n\n    if (allocated(coeffs)) deallocate(coeffs)\n  end function\nend program aks\n", "target": "def expand_x_1(n): \n\n    c =1\n    for i in range(n//2+1):\n        c = c*(n-i)//(i+1)\n        yield c\n        \ndef aks(p):\n    if p==2:\n        return True\n\n    for i in expand_x_1(p):\n        if i % p:\n\n            return False\n    return True\n"}
{"id": 83767, "name": "Loops_N plus one half", "source": "Translate Fortran to C#: C     Loops N plus one half - Fortran IV (1964)\n      INTEGER I\n      WRITE(6,301) (I,I=1,10)\n  301 FORMAT((I3,','))\n      END\n", "target": "using System;\n\nclass Program\n{\n    static void Main(string[] args)\n    {\n        for (int i = 1; ; i++)\n        {\n            Console.Write(i);\n            if (i == 10) break;\n            Console.Write(\", \");\n        }\n        Console.WriteLine();\n    }\n}\n"}
{"id": 83770, "name": "Loops_N plus one half", "source": "Translate Fortran to Java: C     Loops N plus one half - Fortran IV (1964)\n      INTEGER I\n      WRITE(6,301) (I,I=1,10)\n  301 FORMAT((I3,','))\n      END\n", "target": "var out = System.out\nfor(i in 1..10) {\n  if(i > 1) out.print(\", \")\n  out.print(i)\n}\n"}
{"id": 83771, "name": "Loops_N plus one half", "source": "Translate Fortran to Python: C     Loops N plus one half - Fortran IV (1964)\n      INTEGER I\n      WRITE(6,301) (I,I=1,10)\n  301 FORMAT((I3,','))\n      END\n", "target": "print ( ', '.join(str(i+1) for i in range(10)) )\n"}
{"id": 84103, "name": "Euler's sum of powers conjecture", "source": "Translate Fortran to C#: C EULER SUM OF POWERS CONJECTURE - FORTRAN IV\nC FIND I1,I2,I3,I4,I5 : I1**5+I2**5+I3**5+I4**5=I5**5\n      INTEGER I,P5(250),SUMX\n      MAXN=250\n      DO 1 I=1,MAXN\n   1  P5(I)=I**5\n      DO 6 I1=1,MAXN\n      DO 6 I2=1,MAXN\n      DO 6 I3=1,MAXN\n      DO 6 I4=1,MAXN\t  \n      SUMX=P5(I1)+P5(I2)+P5(I3)+P5(I4)\n      I5=1\n   2  IF(I5-MAXN) 3,3,6\n   3  IF(P5(I5)-SUMX) 5,4,6\n   4  WRITE(*,300) I1,I2,I3,I4,I5\n      STOP\n   5  I5=I5+1\n      GOTO 2\n   6  CONTINUE\n 300  FORMAT(5(1X,I3))\n      END\n", "target": "using System;\n\nnamespace EulerSumOfPowers {\n    class Program {\n        const int MAX_NUMBER = 250;\n\n        static void Main(string[] args) {\n            bool found = false;\n            long[] fifth = new long[MAX_NUMBER];\n\n            for (int i = 1; i <= MAX_NUMBER; i++) {\n                long i2 = i * i;\n                fifth[i - 1] = i2 * i2 * i;\n            }\n\n            for (int a = 0; a < MAX_NUMBER && !found; a++) {\n                for (int b = a; b < MAX_NUMBER && !found; b++) {\n                    for (int c = b; c < MAX_NUMBER && !found; c++) {\n                        for (int d = c; d < MAX_NUMBER && !found; d++) {\n                            long sum = fifth[a] + fifth[b] + fifth[c] + fifth[d];\n                            int e = Array.BinarySearch(fifth, sum);\n                            found = e >= 0;\n                            if (found) {\n                                Console.WriteLine(\"{0}^5 + {1}^5 + {2}^5 + {3}^5 = {4}^5\", a + 1, b + 1, c + 1, d + 1, e + 1);\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n}\n"}
{"id": 84104, "name": "Euler's sum of powers conjecture", "source": "Translate Fortran to C#: C EULER SUM OF POWERS CONJECTURE - FORTRAN IV\nC FIND I1,I2,I3,I4,I5 : I1**5+I2**5+I3**5+I4**5=I5**5\n      INTEGER I,P5(250),SUMX\n      MAXN=250\n      DO 1 I=1,MAXN\n   1  P5(I)=I**5\n      DO 6 I1=1,MAXN\n      DO 6 I2=1,MAXN\n      DO 6 I3=1,MAXN\n      DO 6 I4=1,MAXN\t  \n      SUMX=P5(I1)+P5(I2)+P5(I3)+P5(I4)\n      I5=1\n   2  IF(I5-MAXN) 3,3,6\n   3  IF(P5(I5)-SUMX) 5,4,6\n   4  WRITE(*,300) I1,I2,I3,I4,I5\n      STOP\n   5  I5=I5+1\n      GOTO 2\n   6  CONTINUE\n 300  FORMAT(5(1X,I3))\n      END\n", "target": "using System;\n\nnamespace EulerSumOfPowers {\n    class Program {\n        const int MAX_NUMBER = 250;\n\n        static void Main(string[] args) {\n            bool found = false;\n            long[] fifth = new long[MAX_NUMBER];\n\n            for (int i = 1; i <= MAX_NUMBER; i++) {\n                long i2 = i * i;\n                fifth[i - 1] = i2 * i2 * i;\n            }\n\n            for (int a = 0; a < MAX_NUMBER && !found; a++) {\n                for (int b = a; b < MAX_NUMBER && !found; b++) {\n                    for (int c = b; c < MAX_NUMBER && !found; c++) {\n                        for (int d = c; d < MAX_NUMBER && !found; d++) {\n                            long sum = fifth[a] + fifth[b] + fifth[c] + fifth[d];\n                            int e = Array.BinarySearch(fifth, sum);\n                            found = e >= 0;\n                            if (found) {\n                                Console.WriteLine(\"{0}^5 + {1}^5 + {2}^5 + {3}^5 = {4}^5\", a + 1, b + 1, c + 1, d + 1, e + 1);\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n}\n"}
{"id": 84110, "name": "Euler's sum of powers conjecture", "source": "Translate Fortran to Java: C EULER SUM OF POWERS CONJECTURE - FORTRAN IV\nC FIND I1,I2,I3,I4,I5 : I1**5+I2**5+I3**5+I4**5=I5**5\n      INTEGER I,P5(250),SUMX\n      MAXN=250\n      DO 1 I=1,MAXN\n   1  P5(I)=I**5\n      DO 6 I1=1,MAXN\n      DO 6 I2=1,MAXN\n      DO 6 I3=1,MAXN\n      DO 6 I4=1,MAXN\t  \n      SUMX=P5(I1)+P5(I2)+P5(I3)+P5(I4)\n      I5=1\n   2  IF(I5-MAXN) 3,3,6\n   3  IF(P5(I5)-SUMX) 5,4,6\n   4  WRITE(*,300) I1,I2,I3,I4,I5\n      STOP\n   5  I5=I5+1\n      GOTO 2\n   6  CONTINUE\n 300  FORMAT(5(1X,I3))\n      END\n", "target": "public class eulerSopConjecture\n{\n\n    static final int    MAX_NUMBER = 250;\n\n    public static void main( String[] args )\n    {\n        boolean found = false;\n        long[]  fifth = new long[ MAX_NUMBER ];\n\n        for( int i = 1; i <= MAX_NUMBER; i ++ )\n        {\n            long i2 =  i * i;\n            fifth[ i - 1 ] = i2 * i2 * i;\n        } \n\n        for( int a = 0; a < MAX_NUMBER && ! found ; a ++ )\n        {\n            for( int b = a; b < MAX_NUMBER && ! found ; b ++ )\n            {\n                for( int c = b; c < MAX_NUMBER && ! found ; c ++ )\n                {\n                    for( int d = c; d < MAX_NUMBER && ! found ; d ++ )\n                    {\n                        long sum  = fifth[a] + fifth[b] + fifth[c] + fifth[d];\n                        int  e = java.util.Arrays.binarySearch( fifth, sum );\n                        found  = ( e >= 0 );\n                        if( found )\n                        {\n                            \n                            System.out.print( (a+1) + \"^5 + \"\n                                            + (b+1) + \"^5 + \"\n                                            + (c+1) + \"^5 + \"\n                                            + (d+1) + \"^5 = \"\n                                            + (e+1) + \"^5\"\n                                            );\n                        } \n                    } \n                } \n            } \n        } \n    } \n\n} \n"}
{"id": 84111, "name": "Euler's sum of powers conjecture", "source": "Translate Fortran to Java: C EULER SUM OF POWERS CONJECTURE - FORTRAN IV\nC FIND I1,I2,I3,I4,I5 : I1**5+I2**5+I3**5+I4**5=I5**5\n      INTEGER I,P5(250),SUMX\n      MAXN=250\n      DO 1 I=1,MAXN\n   1  P5(I)=I**5\n      DO 6 I1=1,MAXN\n      DO 6 I2=1,MAXN\n      DO 6 I3=1,MAXN\n      DO 6 I4=1,MAXN\t  \n      SUMX=P5(I1)+P5(I2)+P5(I3)+P5(I4)\n      I5=1\n   2  IF(I5-MAXN) 3,3,6\n   3  IF(P5(I5)-SUMX) 5,4,6\n   4  WRITE(*,300) I1,I2,I3,I4,I5\n      STOP\n   5  I5=I5+1\n      GOTO 2\n   6  CONTINUE\n 300  FORMAT(5(1X,I3))\n      END\n", "target": "public class eulerSopConjecture\n{\n\n    static final int    MAX_NUMBER = 250;\n\n    public static void main( String[] args )\n    {\n        boolean found = false;\n        long[]  fifth = new long[ MAX_NUMBER ];\n\n        for( int i = 1; i <= MAX_NUMBER; i ++ )\n        {\n            long i2 =  i * i;\n            fifth[ i - 1 ] = i2 * i2 * i;\n        } \n\n        for( int a = 0; a < MAX_NUMBER && ! found ; a ++ )\n        {\n            for( int b = a; b < MAX_NUMBER && ! found ; b ++ )\n            {\n                for( int c = b; c < MAX_NUMBER && ! found ; c ++ )\n                {\n                    for( int d = c; d < MAX_NUMBER && ! found ; d ++ )\n                    {\n                        long sum  = fifth[a] + fifth[b] + fifth[c] + fifth[d];\n                        int  e = java.util.Arrays.binarySearch( fifth, sum );\n                        found  = ( e >= 0 );\n                        if( found )\n                        {\n                            \n                            System.out.print( (a+1) + \"^5 + \"\n                                            + (b+1) + \"^5 + \"\n                                            + (c+1) + \"^5 + \"\n                                            + (d+1) + \"^5 = \"\n                                            + (e+1) + \"^5\"\n                                            );\n                        } \n                    } \n                } \n            } \n        } \n    } \n\n} \n"}
{"id": 84112, "name": "Euler's sum of powers conjecture", "source": "Translate Fortran to Python: C EULER SUM OF POWERS CONJECTURE - FORTRAN IV\nC FIND I1,I2,I3,I4,I5 : I1**5+I2**5+I3**5+I4**5=I5**5\n      INTEGER I,P5(250),SUMX\n      MAXN=250\n      DO 1 I=1,MAXN\n   1  P5(I)=I**5\n      DO 6 I1=1,MAXN\n      DO 6 I2=1,MAXN\n      DO 6 I3=1,MAXN\n      DO 6 I4=1,MAXN\t  \n      SUMX=P5(I1)+P5(I2)+P5(I3)+P5(I4)\n      I5=1\n   2  IF(I5-MAXN) 3,3,6\n   3  IF(P5(I5)-SUMX) 5,4,6\n   4  WRITE(*,300) I1,I2,I3,I4,I5\n      STOP\n   5  I5=I5+1\n      GOTO 2\n   6  CONTINUE\n 300  FORMAT(5(1X,I3))\n      END\n", "target": "def eulers_sum_of_powers():\n    max_n = 250\n    pow_5 = [n**5 for n in range(max_n)]\n    pow5_to_n = {n**5: n for n in range(max_n)}\n    for x0 in range(1, max_n):\n        for x1 in range(1, x0):\n            for x2 in range(1, x1):\n                for x3 in range(1, x2):\n                    pow_5_sum = sum(pow_5[i] for i in (x0, x1, x2, x3))\n                    if pow_5_sum in pow5_to_n:\n                        y = pow5_to_n[pow_5_sum]\n                        return (x0, x1, x2, x3, y)\n\nprint(\"%i**5 + %i**5 + %i**5 + %i**5 == %i**5\" % eulers_sum_of_powers())\n"}
{"id": 84113, "name": "Euler's sum of powers conjecture", "source": "Translate Fortran to Python: C EULER SUM OF POWERS CONJECTURE - FORTRAN IV\nC FIND I1,I2,I3,I4,I5 : I1**5+I2**5+I3**5+I4**5=I5**5\n      INTEGER I,P5(250),SUMX\n      MAXN=250\n      DO 1 I=1,MAXN\n   1  P5(I)=I**5\n      DO 6 I1=1,MAXN\n      DO 6 I2=1,MAXN\n      DO 6 I3=1,MAXN\n      DO 6 I4=1,MAXN\t  \n      SUMX=P5(I1)+P5(I2)+P5(I3)+P5(I4)\n      I5=1\n   2  IF(I5-MAXN) 3,3,6\n   3  IF(P5(I5)-SUMX) 5,4,6\n   4  WRITE(*,300) I1,I2,I3,I4,I5\n      STOP\n   5  I5=I5+1\n      GOTO 2\n   6  CONTINUE\n 300  FORMAT(5(1X,I3))\n      END\n", "target": "def eulers_sum_of_powers():\n    max_n = 250\n    pow_5 = [n**5 for n in range(max_n)]\n    pow5_to_n = {n**5: n for n in range(max_n)}\n    for x0 in range(1, max_n):\n        for x1 in range(1, x0):\n            for x2 in range(1, x1):\n                for x3 in range(1, x2):\n                    pow_5_sum = sum(pow_5[i] for i in (x0, x1, x2, x3))\n                    if pow_5_sum in pow5_to_n:\n                        y = pow5_to_n[pow_5_sum]\n                        return (x0, x1, x2, x3, y)\n\nprint(\"%i**5 + %i**5 + %i**5 + %i**5 == %i**5\" % eulers_sum_of_powers())\n"}
{"id": 84536, "name": "Strip control codes and extended characters from a string", "source": "Translate Fortran to C#: module stripcharacters\nimplicit none\n\ncontains\n\n  pure logical function not_control(ch)\n    character, intent(in) :: ch\n    not_control = iachar(ch) >= 32 .and. iachar(ch) /= 127\n  end function not_control\n\n  pure logical function not_extended(ch)\n    character, intent(in) :: ch\n    not_extended = iachar(ch) >= 32 .and. iachar(ch) < 127\n  end function not_extended\n\n  pure function strip(string,accept) result(str)\n    character(len=*), intent(in) :: string\n    character(len=len(string))   :: str\n    interface\n      pure logical function accept(ch)\n        character, intent(in) :: ch\n      end function except\n    end interface\n    integer :: i,n\n    str = repeat(' ',len(string))\n    n = 0\n    do i=1,len(string)\n      if ( accept(string(i:i)) ) then\n        n = n+1\n        str(n:n) = string(i:i)\n      end if\n    end do\n  end function strip\n\nend module stripcharacters\n\n\nprogram test\n  use stripcharacters\n  \n  character(len=256) :: string, str\n  integer            :: ascii(256), i\n  forall (i=0:255) ascii(i) = i\n  forall (i=1:len(string)) string(i:i) = achar(ascii(i))\n  write (*,*) string\n  \n  write (*,*) 'Control characters deleted:'\n  str = strip(string,not_control)\n  write (*,*) str\n\n  forall (i=1:len(string)) string(i:i) = achar(ascii(i))\n  write (*,*) 'Extended characters deleted:'\n  write (*,*) strip(string,not_extended)\nend program test\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Threading.Tasks;\n\nnamespace RosettaCode\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            string test = \"string of \u263a\u263b\u2665\u2666\u2302, may include control characters and other ilk.\u266b\u263c\u00a7\u25ba\u2194\u25c4\";\n            Console.WriteLine(\"Original: {0}\", test);\n            Console.WriteLine(\"Stripped of control codes: {0}\", StripControlChars(test));\n            Console.WriteLine(\"Stripped of extended: {0}\", StripExtended(test));\n        }\n\n        static string StripControlChars(string arg)\n        {\n            char[] arrForm = arg.ToCharArray();\n            StringBuilder buffer = new StringBuilder(arg.Length);\n            \n            foreach(char ch in arrForm)\n                if (!Char.IsControl(ch)) buffer.Append(ch);\n\n            return buffer.ToString();\n        }\n\n        static string StripExtended(string arg)\n        {\n            StringBuilder buffer = new StringBuilder(arg.Length); \n            foreach(char ch in arg)\n            {\n                UInt16 num = Convert.ToUInt16(ch);\n                \n                if((num >= 32u) && (num <= 126u)) buffer.Append(ch);\n            }\n            return buffer.ToString();\n        }\n    }\n}\n"}
{"id": 84537, "name": "Strip control codes and extended characters from a string", "source": "Translate Fortran to C#: module stripcharacters\nimplicit none\n\ncontains\n\n  pure logical function not_control(ch)\n    character, intent(in) :: ch\n    not_control = iachar(ch) >= 32 .and. iachar(ch) /= 127\n  end function not_control\n\n  pure logical function not_extended(ch)\n    character, intent(in) :: ch\n    not_extended = iachar(ch) >= 32 .and. iachar(ch) < 127\n  end function not_extended\n\n  pure function strip(string,accept) result(str)\n    character(len=*), intent(in) :: string\n    character(len=len(string))   :: str\n    interface\n      pure logical function accept(ch)\n        character, intent(in) :: ch\n      end function except\n    end interface\n    integer :: i,n\n    str = repeat(' ',len(string))\n    n = 0\n    do i=1,len(string)\n      if ( accept(string(i:i)) ) then\n        n = n+1\n        str(n:n) = string(i:i)\n      end if\n    end do\n  end function strip\n\nend module stripcharacters\n\n\nprogram test\n  use stripcharacters\n  \n  character(len=256) :: string, str\n  integer            :: ascii(256), i\n  forall (i=0:255) ascii(i) = i\n  forall (i=1:len(string)) string(i:i) = achar(ascii(i))\n  write (*,*) string\n  \n  write (*,*) 'Control characters deleted:'\n  str = strip(string,not_control)\n  write (*,*) str\n\n  forall (i=1:len(string)) string(i:i) = achar(ascii(i))\n  write (*,*) 'Extended characters deleted:'\n  write (*,*) strip(string,not_extended)\nend program test\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Threading.Tasks;\n\nnamespace RosettaCode\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            string test = \"string of \u263a\u263b\u2665\u2666\u2302, may include control characters and other ilk.\u266b\u263c\u00a7\u25ba\u2194\u25c4\";\n            Console.WriteLine(\"Original: {0}\", test);\n            Console.WriteLine(\"Stripped of control codes: {0}\", StripControlChars(test));\n            Console.WriteLine(\"Stripped of extended: {0}\", StripExtended(test));\n        }\n\n        static string StripControlChars(string arg)\n        {\n            char[] arrForm = arg.ToCharArray();\n            StringBuilder buffer = new StringBuilder(arg.Length);\n            \n            foreach(char ch in arrForm)\n                if (!Char.IsControl(ch)) buffer.Append(ch);\n\n            return buffer.ToString();\n        }\n\n        static string StripExtended(string arg)\n        {\n            StringBuilder buffer = new StringBuilder(arg.Length); \n            foreach(char ch in arg)\n            {\n                UInt16 num = Convert.ToUInt16(ch);\n                \n                if((num >= 32u) && (num <= 126u)) buffer.Append(ch);\n            }\n            return buffer.ToString();\n        }\n    }\n}\n"}
{"id": 84543, "name": "Strip control codes and extended characters from a string", "source": "Translate Fortran to Java: module stripcharacters\nimplicit none\n\ncontains\n\n  pure logical function not_control(ch)\n    character, intent(in) :: ch\n    not_control = iachar(ch) >= 32 .and. iachar(ch) /= 127\n  end function not_control\n\n  pure logical function not_extended(ch)\n    character, intent(in) :: ch\n    not_extended = iachar(ch) >= 32 .and. iachar(ch) < 127\n  end function not_extended\n\n  pure function strip(string,accept) result(str)\n    character(len=*), intent(in) :: string\n    character(len=len(string))   :: str\n    interface\n      pure logical function accept(ch)\n        character, intent(in) :: ch\n      end function except\n    end interface\n    integer :: i,n\n    str = repeat(' ',len(string))\n    n = 0\n    do i=1,len(string)\n      if ( accept(string(i:i)) ) then\n        n = n+1\n        str(n:n) = string(i:i)\n      end if\n    end do\n  end function strip\n\nend module stripcharacters\n\n\nprogram test\n  use stripcharacters\n  \n  character(len=256) :: string, str\n  integer            :: ascii(256), i\n  forall (i=0:255) ascii(i) = i\n  forall (i=1:len(string)) string(i:i) = achar(ascii(i))\n  write (*,*) string\n  \n  write (*,*) 'Control characters deleted:'\n  str = strip(string,not_control)\n  write (*,*) str\n\n  forall (i=1:len(string)) string(i:i) = achar(ascii(i))\n  write (*,*) 'Extended characters deleted:'\n  write (*,*) strip(string,not_extended)\nend program test\n", "target": "import java.util.function.IntPredicate;\n\npublic class StripControlCodes {\n\n    public static void main(String[] args) {\n        String s = \"\\u0000\\n abc\\u00E9def\\u007F\";\n        System.out.println(stripChars(s, c -> c > '\\u001F' && c != '\\u007F'));\n        System.out.println(stripChars(s, c -> c > '\\u001F' && c < '\\u007F'));\n    }\n\n    static String stripChars(String s, IntPredicate include) {\n        return s.codePoints().filter(include::test).collect(StringBuilder::new,\n                StringBuilder::appendCodePoint, StringBuilder::append).toString();\n    }\n}\n"}
{"id": 84544, "name": "Strip control codes and extended characters from a string", "source": "Translate Fortran to Java: module stripcharacters\nimplicit none\n\ncontains\n\n  pure logical function not_control(ch)\n    character, intent(in) :: ch\n    not_control = iachar(ch) >= 32 .and. iachar(ch) /= 127\n  end function not_control\n\n  pure logical function not_extended(ch)\n    character, intent(in) :: ch\n    not_extended = iachar(ch) >= 32 .and. iachar(ch) < 127\n  end function not_extended\n\n  pure function strip(string,accept) result(str)\n    character(len=*), intent(in) :: string\n    character(len=len(string))   :: str\n    interface\n      pure logical function accept(ch)\n        character, intent(in) :: ch\n      end function except\n    end interface\n    integer :: i,n\n    str = repeat(' ',len(string))\n    n = 0\n    do i=1,len(string)\n      if ( accept(string(i:i)) ) then\n        n = n+1\n        str(n:n) = string(i:i)\n      end if\n    end do\n  end function strip\n\nend module stripcharacters\n\n\nprogram test\n  use stripcharacters\n  \n  character(len=256) :: string, str\n  integer            :: ascii(256), i\n  forall (i=0:255) ascii(i) = i\n  forall (i=1:len(string)) string(i:i) = achar(ascii(i))\n  write (*,*) string\n  \n  write (*,*) 'Control characters deleted:'\n  str = strip(string,not_control)\n  write (*,*) str\n\n  forall (i=1:len(string)) string(i:i) = achar(ascii(i))\n  write (*,*) 'Extended characters deleted:'\n  write (*,*) strip(string,not_extended)\nend program test\n", "target": "import java.util.function.IntPredicate;\n\npublic class StripControlCodes {\n\n    public static void main(String[] args) {\n        String s = \"\\u0000\\n abc\\u00E9def\\u007F\";\n        System.out.println(stripChars(s, c -> c > '\\u001F' && c != '\\u007F'));\n        System.out.println(stripChars(s, c -> c > '\\u001F' && c < '\\u007F'));\n    }\n\n    static String stripChars(String s, IntPredicate include) {\n        return s.codePoints().filter(include::test).collect(StringBuilder::new,\n                StringBuilder::appendCodePoint, StringBuilder::append).toString();\n    }\n}\n"}
{"id": 84545, "name": "Strip control codes and extended characters from a string", "source": "Translate Fortran to Python: module stripcharacters\nimplicit none\n\ncontains\n\n  pure logical function not_control(ch)\n    character, intent(in) :: ch\n    not_control = iachar(ch) >= 32 .and. iachar(ch) /= 127\n  end function not_control\n\n  pure logical function not_extended(ch)\n    character, intent(in) :: ch\n    not_extended = iachar(ch) >= 32 .and. iachar(ch) < 127\n  end function not_extended\n\n  pure function strip(string,accept) result(str)\n    character(len=*), intent(in) :: string\n    character(len=len(string))   :: str\n    interface\n      pure logical function accept(ch)\n        character, intent(in) :: ch\n      end function except\n    end interface\n    integer :: i,n\n    str = repeat(' ',len(string))\n    n = 0\n    do i=1,len(string)\n      if ( accept(string(i:i)) ) then\n        n = n+1\n        str(n:n) = string(i:i)\n      end if\n    end do\n  end function strip\n\nend module stripcharacters\n\n\nprogram test\n  use stripcharacters\n  \n  character(len=256) :: string, str\n  integer            :: ascii(256), i\n  forall (i=0:255) ascii(i) = i\n  forall (i=1:len(string)) string(i:i) = achar(ascii(i))\n  write (*,*) string\n  \n  write (*,*) 'Control characters deleted:'\n  str = strip(string,not_control)\n  write (*,*) str\n\n  forall (i=1:len(string)) string(i:i) = achar(ascii(i))\n  write (*,*) 'Extended characters deleted:'\n  write (*,*) strip(string,not_extended)\nend program test\n", "target": "stripped = lambda s: \"\".join(i for i in s if 31 < ord(i) < 127)\n\nprint(stripped(\"\\ba\\x00b\\n\\rc\\fd\\xc3\"))\n"}
{"id": 84546, "name": "Strip control codes and extended characters from a string", "source": "Translate Fortran to Python: module stripcharacters\nimplicit none\n\ncontains\n\n  pure logical function not_control(ch)\n    character, intent(in) :: ch\n    not_control = iachar(ch) >= 32 .and. iachar(ch) /= 127\n  end function not_control\n\n  pure logical function not_extended(ch)\n    character, intent(in) :: ch\n    not_extended = iachar(ch) >= 32 .and. iachar(ch) < 127\n  end function not_extended\n\n  pure function strip(string,accept) result(str)\n    character(len=*), intent(in) :: string\n    character(len=len(string))   :: str\n    interface\n      pure logical function accept(ch)\n        character, intent(in) :: ch\n      end function except\n    end interface\n    integer :: i,n\n    str = repeat(' ',len(string))\n    n = 0\n    do i=1,len(string)\n      if ( accept(string(i:i)) ) then\n        n = n+1\n        str(n:n) = string(i:i)\n      end if\n    end do\n  end function strip\n\nend module stripcharacters\n\n\nprogram test\n  use stripcharacters\n  \n  character(len=256) :: string, str\n  integer            :: ascii(256), i\n  forall (i=0:255) ascii(i) = i\n  forall (i=1:len(string)) string(i:i) = achar(ascii(i))\n  write (*,*) string\n  \n  write (*,*) 'Control characters deleted:'\n  str = strip(string,not_control)\n  write (*,*) str\n\n  forall (i=1:len(string)) string(i:i) = achar(ascii(i))\n  write (*,*) 'Extended characters deleted:'\n  write (*,*) strip(string,not_extended)\nend program test\n", "target": "stripped = lambda s: \"\".join(i for i in s if 31 < ord(i) < 127)\n\nprint(stripped(\"\\ba\\x00b\\n\\rc\\fd\\xc3\"))\n"}
{"id": 84899, "name": "Primality by trial division", "source": "Translate Fortran to C#:  FUNCTION isPrime(number)\n   LOGICAL :: isPrime\n   INTEGER, INTENT(IN) :: number\n   INTEGER :: i\n \n   IF(number==2) THEN\n      isPrime = .TRUE.\n   ELSE IF(number < 2 .OR. MOD(number,2) == 0) THEN\n      isPRIME = .FALSE.\n   ELSE\n      isPrime = .TRUE.\n      DO i = 3, INT(SQRT(REAL(number))), 2\n         IF(MOD(number,i) == 0) THEN\n            isPrime = .FALSE.\n            EXIT\n         END IF\n      END DO\n   END IF\n END FUNCTION\n", "target": "static bool isPrime(int n)\n        {\n            if (n <= 1) return false;\n            for (int i = 2; i * i <= n; i++)            \n                if (n % i == 0) return false;            \n            return true;\n        }\n"}
{"id": 84902, "name": "Primality by trial division", "source": "Translate Fortran to Java:  FUNCTION isPrime(number)\n   LOGICAL :: isPrime\n   INTEGER, INTENT(IN) :: number\n   INTEGER :: i\n \n   IF(number==2) THEN\n      isPrime = .TRUE.\n   ELSE IF(number < 2 .OR. MOD(number,2) == 0) THEN\n      isPRIME = .FALSE.\n   ELSE\n      isPrime = .TRUE.\n      DO i = 3, INT(SQRT(REAL(number))), 2\n         IF(MOD(number,i) == 0) THEN\n            isPrime = .FALSE.\n            EXIT\n         END IF\n      END DO\n   END IF\n END FUNCTION\n", "target": "public static boolean prime(long a){\n   if(a == 2){\n      return true;\n   }else if(a <= 1 || a % 2 == 0){\n      return false;\n   }\n   long max = (long)Math.sqrt(a);\n   for(long n= 3; n <= max; n+= 2){\n      if(a % n == 0){ return false; }\n   }\n   return true;\n}\n"}
{"id": 84903, "name": "Primality by trial division", "source": "Translate Fortran to Python:  FUNCTION isPrime(number)\n   LOGICAL :: isPrime\n   INTEGER, INTENT(IN) :: number\n   INTEGER :: i\n \n   IF(number==2) THEN\n      isPrime = .TRUE.\n   ELSE IF(number < 2 .OR. MOD(number,2) == 0) THEN\n      isPRIME = .FALSE.\n   ELSE\n      isPrime = .TRUE.\n      DO i = 3, INT(SQRT(REAL(number))), 2\n         IF(MOD(number,i) == 0) THEN\n            isPrime = .FALSE.\n            EXIT\n         END IF\n      END DO\n   END IF\n END FUNCTION\n", "target": "def prime(a):\n    return not (a < 2 or any(a % x == 0 for x in xrange(2, int(a**0.5) + 1)))\n"}
{"id": 85151, "name": "MD5", "source": "Translate Fortran to C#: module md5_mod\n    use kernel32\n    use advapi32\n    implicit none\n    integer, parameter :: MD5LEN = 16\ncontains\n    subroutine md5hash(name, hash, dwStatus, filesize)\n        implicit none\n        character(*) :: name\n        integer, parameter :: BUFLEN = 32768\n        integer(HANDLE) :: hFile, hProv, hHash\n        integer(DWORD) :: dwStatus, nRead\n        integer(BOOL) :: status\n        integer(BYTE) :: buffer(BUFLEN)\n        integer(BYTE) :: hash(MD5LEN)\n        integer(UINT64) :: filesize\n \n        dwStatus = 0\n        filesize = 0\n        hFile = CreateFile(trim(name) // char(0), GENERIC_READ, FILE_SHARE_READ, NULL, &\n                           OPEN_EXISTING, FILE_FLAG_SEQUENTIAL_SCAN, NULL)\n \n        if (hFile == INVALID_HANDLE_VALUE) then\n            dwStatus = GetLastError()\n            print *, \"CreateFile failed.\"\n            return\n        end if\n \n        if (CryptAcquireContext(hProv, NULL, NULL, PROV_RSA_FULL, &\n                                CRYPT_VERIFYCONTEXT) == FALSE) then\n            dwStatus = GetLastError()\n            print *, \"CryptAcquireContext failed.\"\n            goto 3\n        end if\n \n        if (CryptCreateHash(hProv, CALG_MD5, 0_ULONG_PTR, 0_DWORD, hHash) == FALSE) then\n            dwStatus = GetLastError()\n            print *, \"CryptCreateHash failed.\"\n            go to 2\n        end if\n \n        do\n            status = ReadFile(hFile, loc(buffer), BUFLEN, nRead, NULL)\n            if (status == FALSE .or. nRead == 0) exit\n            filesize = filesize + nRead\n            if (CryptHashData(hHash, buffer, nRead, 0) == FALSE) then\n                dwStatus = GetLastError()\n                print *, \"CryptHashData failed.\"\n                go to 1\n            end if\n        end do\n \n        if (status == FALSE) then\n            dwStatus = GetLastError()\n            print *, \"ReadFile failed.\"\n            go to 1\n        end if\n \n        nRead = MD5LEN\n        if (CryptGetHashParam(hHash, HP_HASHVAL, hash, nRead, 0) == FALSE) then\n            dwStatus = GetLastError()\n            print *, \"CryptGetHashParam failed.\", status, nRead, dwStatus\n        end if\n \n      1 status = CryptDestroyHash(hHash)\n      2 status = CryptReleaseContext(hProv, 0)\n      3 status = CloseHandle(hFile)\n    end subroutine\nend module\n \nprogram md5\n    use md5_mod\n    implicit none\n    integer :: n, m, i, j\n    character(:), allocatable :: name\n    integer(DWORD) :: dwStatus\n    integer(BYTE) :: hash(MD5LEN)\n    integer(UINT64) :: filesize\n \n    n = command_argument_count()\n    do i = 1, n\n        call get_command_argument(i, length=m)\n        allocate(character(m) :: name)\n        call get_command_argument(i, name)\n        call md5hash(name, hash, dwStatus, filesize)\n        if (dwStatus == 0) then\n            do j = 1, MD5LEN\n                write(*, \"(Z2.2)\", advance=\"NO\") hash(j)\n            end do\n            write(*, \"(' ',A,' (',G0,' bytes)')\") name, filesize\n        end if\n        deallocate(name)\n    end do\nend program\n", "target": "using System.Text;\nusing System.Security.Cryptography;\n\nbyte[] data = Encoding.ASCII.GetBytes(\"The quick brown fox jumped over the lazy dog's back\");\nbyte[] hash = MD5.Create().ComputeHash(data);\nConsole.WriteLine(BitConverter.ToString(hash).Replace(\"-\", \"\").ToLower());\n"}
{"id": 85154, "name": "MD5", "source": "Translate Fortran to Java: module md5_mod\n    use kernel32\n    use advapi32\n    implicit none\n    integer, parameter :: MD5LEN = 16\ncontains\n    subroutine md5hash(name, hash, dwStatus, filesize)\n        implicit none\n        character(*) :: name\n        integer, parameter :: BUFLEN = 32768\n        integer(HANDLE) :: hFile, hProv, hHash\n        integer(DWORD) :: dwStatus, nRead\n        integer(BOOL) :: status\n        integer(BYTE) :: buffer(BUFLEN)\n        integer(BYTE) :: hash(MD5LEN)\n        integer(UINT64) :: filesize\n \n        dwStatus = 0\n        filesize = 0\n        hFile = CreateFile(trim(name) // char(0), GENERIC_READ, FILE_SHARE_READ, NULL, &\n                           OPEN_EXISTING, FILE_FLAG_SEQUENTIAL_SCAN, NULL)\n \n        if (hFile == INVALID_HANDLE_VALUE) then\n            dwStatus = GetLastError()\n            print *, \"CreateFile failed.\"\n            return\n        end if\n \n        if (CryptAcquireContext(hProv, NULL, NULL, PROV_RSA_FULL, &\n                                CRYPT_VERIFYCONTEXT) == FALSE) then\n            dwStatus = GetLastError()\n            print *, \"CryptAcquireContext failed.\"\n            goto 3\n        end if\n \n        if (CryptCreateHash(hProv, CALG_MD5, 0_ULONG_PTR, 0_DWORD, hHash) == FALSE) then\n            dwStatus = GetLastError()\n            print *, \"CryptCreateHash failed.\"\n            go to 2\n        end if\n \n        do\n            status = ReadFile(hFile, loc(buffer), BUFLEN, nRead, NULL)\n            if (status == FALSE .or. nRead == 0) exit\n            filesize = filesize + nRead\n            if (CryptHashData(hHash, buffer, nRead, 0) == FALSE) then\n                dwStatus = GetLastError()\n                print *, \"CryptHashData failed.\"\n                go to 1\n            end if\n        end do\n \n        if (status == FALSE) then\n            dwStatus = GetLastError()\n            print *, \"ReadFile failed.\"\n            go to 1\n        end if\n \n        nRead = MD5LEN\n        if (CryptGetHashParam(hHash, HP_HASHVAL, hash, nRead, 0) == FALSE) then\n            dwStatus = GetLastError()\n            print *, \"CryptGetHashParam failed.\", status, nRead, dwStatus\n        end if\n \n      1 status = CryptDestroyHash(hHash)\n      2 status = CryptReleaseContext(hProv, 0)\n      3 status = CloseHandle(hFile)\n    end subroutine\nend module\n \nprogram md5\n    use md5_mod\n    implicit none\n    integer :: n, m, i, j\n    character(:), allocatable :: name\n    integer(DWORD) :: dwStatus\n    integer(BYTE) :: hash(MD5LEN)\n    integer(UINT64) :: filesize\n \n    n = command_argument_count()\n    do i = 1, n\n        call get_command_argument(i, length=m)\n        allocate(character(m) :: name)\n        call get_command_argument(i, name)\n        call md5hash(name, hash, dwStatus, filesize)\n        if (dwStatus == 0) then\n            do j = 1, MD5LEN\n                write(*, \"(Z2.2)\", advance=\"NO\") hash(j)\n            end do\n            write(*, \"(' ',A,' (',G0,' bytes)')\") name, filesize\n        end if\n        deallocate(name)\n    end do\nend program\n", "target": "import java.nio.charset.StandardCharsets;\nimport java.security.MessageDigest;\nimport java.security.NoSuchAlgorithmException;\n\npublic class Digester {\n\n    public static void main(String[] args) {\n        System.out.println(hexDigest(\"Rosetta code\", \"MD5\"));\n    }\n\n    static String hexDigest(String str, String digestName) {\n        try {\n            MessageDigest md = MessageDigest.getInstance(digestName);\n            byte[] digest = md.digest(str.getBytes(StandardCharsets.UTF_8));\n            char[] hex = new char[digest.length * 2];\n            for (int i = 0; i < digest.length; i++) {\n                hex[2 * i] = \"0123456789abcdef\".charAt((digest[i] & 0xf0) >> 4);\n                hex[2 * i + 1] = \"0123456789abcdef\".charAt(digest[i] & 0x0f);\n            }\n            return new String(hex);\n        } catch (NoSuchAlgorithmException e) {\n            throw new IllegalStateException(e);\n        }\n    }\n}\n"}
{"id": 85155, "name": "MD5", "source": "Translate Fortran to Python: module md5_mod\n    use kernel32\n    use advapi32\n    implicit none\n    integer, parameter :: MD5LEN = 16\ncontains\n    subroutine md5hash(name, hash, dwStatus, filesize)\n        implicit none\n        character(*) :: name\n        integer, parameter :: BUFLEN = 32768\n        integer(HANDLE) :: hFile, hProv, hHash\n        integer(DWORD) :: dwStatus, nRead\n        integer(BOOL) :: status\n        integer(BYTE) :: buffer(BUFLEN)\n        integer(BYTE) :: hash(MD5LEN)\n        integer(UINT64) :: filesize\n \n        dwStatus = 0\n        filesize = 0\n        hFile = CreateFile(trim(name) // char(0), GENERIC_READ, FILE_SHARE_READ, NULL, &\n                           OPEN_EXISTING, FILE_FLAG_SEQUENTIAL_SCAN, NULL)\n \n        if (hFile == INVALID_HANDLE_VALUE) then\n            dwStatus = GetLastError()\n            print *, \"CreateFile failed.\"\n            return\n        end if\n \n        if (CryptAcquireContext(hProv, NULL, NULL, PROV_RSA_FULL, &\n                                CRYPT_VERIFYCONTEXT) == FALSE) then\n            dwStatus = GetLastError()\n            print *, \"CryptAcquireContext failed.\"\n            goto 3\n        end if\n \n        if (CryptCreateHash(hProv, CALG_MD5, 0_ULONG_PTR, 0_DWORD, hHash) == FALSE) then\n            dwStatus = GetLastError()\n            print *, \"CryptCreateHash failed.\"\n            go to 2\n        end if\n \n        do\n            status = ReadFile(hFile, loc(buffer), BUFLEN, nRead, NULL)\n            if (status == FALSE .or. nRead == 0) exit\n            filesize = filesize + nRead\n            if (CryptHashData(hHash, buffer, nRead, 0) == FALSE) then\n                dwStatus = GetLastError()\n                print *, \"CryptHashData failed.\"\n                go to 1\n            end if\n        end do\n \n        if (status == FALSE) then\n            dwStatus = GetLastError()\n            print *, \"ReadFile failed.\"\n            go to 1\n        end if\n \n        nRead = MD5LEN\n        if (CryptGetHashParam(hHash, HP_HASHVAL, hash, nRead, 0) == FALSE) then\n            dwStatus = GetLastError()\n            print *, \"CryptGetHashParam failed.\", status, nRead, dwStatus\n        end if\n \n      1 status = CryptDestroyHash(hHash)\n      2 status = CryptReleaseContext(hProv, 0)\n      3 status = CloseHandle(hFile)\n    end subroutine\nend module\n \nprogram md5\n    use md5_mod\n    implicit none\n    integer :: n, m, i, j\n    character(:), allocatable :: name\n    integer(DWORD) :: dwStatus\n    integer(BYTE) :: hash(MD5LEN)\n    integer(UINT64) :: filesize\n \n    n = command_argument_count()\n    do i = 1, n\n        call get_command_argument(i, length=m)\n        allocate(character(m) :: name)\n        call get_command_argument(i, name)\n        call md5hash(name, hash, dwStatus, filesize)\n        if (dwStatus == 0) then\n            do j = 1, MD5LEN\n                write(*, \"(Z2.2)\", advance=\"NO\") hash(j)\n            end do\n            write(*, \"(' ',A,' (',G0,' bytes)')\") name, filesize\n        end if\n        deallocate(name)\n    end do\nend program\n", "target": ">>> import hashlib\n>>> \n>>> tests = (\n  (b\"\", 'd41d8cd98f00b204e9800998ecf8427e'),\n  (b\"a\", '0cc175b9c0f1b6a831c399e269772661'),\n  (b\"abc\", '900150983cd24fb0d6963f7d28e17f72'),\n  (b\"message digest\", 'f96b697d7cb7938d525a2f31aaf161d0'),\n  (b\"abcdefghijklmnopqrstuvwxyz\", 'c3fcd3d76192e4007dfb496cca67e13b'),\n  (b\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789\", 'd174ab98d277d9f5a5611c2c9f419d9f'),\n  (b\"12345678901234567890123456789012345678901234567890123456789012345678901234567890\", '57edf4a22be3c955ac49da2e2107b67a') )\n>>> for text, golden in tests: assert hashlib.md5(text).hexdigest() == golden\n\n>>>\n"}
{"id": 85580, "name": "Time a function", "source": "Translate Fortran to C#: c The subroutine to analyze\n      subroutine do_something()\nc For testing we just do nothing for 3 seconds\n      call sleep(3)\n      return\n      end\n\nc Main Program\n      program timing\n      integer(kind=8) start,finish,rate\n      call system_clock(count_rate=rate)\n      call system_clock(start)         \nc Here comes the function we want to time\n      call do_something()\n      call system_clock(finish)         \n      write(6,*) 'Elapsed Time in seconds:',float(finish-start)/rate\n      return\n      end\n", "target": "using System;\nusing System.Linq;\nusing System.Threading;\nusing System.Diagnostics;\n\nclass Program {\n    static void Main(string[] args) {\n        Stopwatch sw = new Stopwatch();\n\n        sw.Start();\n        DoSomething();\n        sw.Stop();\n\n        Console.WriteLine(\"DoSomething() took {0}ms.\", sw.Elapsed.TotalMilliseconds);\n    }\n\n    static void DoSomething() {\n        Thread.Sleep(1000);\n\n        Enumerable.Range(1, 10000).Where(x => x % 2 == 0).Sum();  \n    }\n}\n"}
{"id": 85584, "name": "Time a function", "source": "Translate Fortran to Java: c The subroutine to analyze\n      subroutine do_something()\nc For testing we just do nothing for 3 seconds\n      call sleep(3)\n      return\n      end\n\nc Main Program\n      program timing\n      integer(kind=8) start,finish,rate\n      call system_clock(count_rate=rate)\n      call system_clock(start)         \nc Here comes the function we want to time\n      call do_something()\n      call system_clock(finish)         \n      write(6,*) 'Elapsed Time in seconds:',float(finish-start)/rate\n      return\n      end\n", "target": "import java.lang.management.ManagementFactory;\nimport java.lang.management.ThreadMXBean;\n\npublic class TimeIt {\n\tpublic static void main(String[] args) {\n\t\tfinal ThreadMXBean threadMX = ManagementFactory.getThreadMXBean();\n\t\tassert threadMX.isCurrentThreadCpuTimeSupported();\n\t\tthreadMX.setThreadCpuTimeEnabled(true);\n\t\t\n\t\tlong start, end;\n\t\tstart = threadMX.getCurrentThreadCpuTime();\n\t\tcountTo(100000000);\n\t\tend = threadMX.getCurrentThreadCpuTime();\n\t\tSystem.out.println(\"Counting to 100000000 takes \"+(end-start)/1000000+\"ms\");\n\t\tstart = threadMX.getCurrentThreadCpuTime();\n\t\tcountTo(1000000000L);\n\t\tend = threadMX.getCurrentThreadCpuTime();\n\t\tSystem.out.println(\"Counting to 1000000000 takes \"+(end-start)/1000000+\"ms\");\n \n\t}\n \n\tpublic static void countTo(long x){\n\t\tSystem.out.println(\"Counting...\");\n\t\tfor(long i=0;i<x;i++);\n\t\tSystem.out.println(\"Done!\");\n\t}\n}\n"}
{"id": 85585, "name": "Time a function", "source": "Translate Fortran to Python: c The subroutine to analyze\n      subroutine do_something()\nc For testing we just do nothing for 3 seconds\n      call sleep(3)\n      return\n      end\n\nc Main Program\n      program timing\n      integer(kind=8) start,finish,rate\n      call system_clock(count_rate=rate)\n      call system_clock(start)         \nc Here comes the function we want to time\n      call do_something()\n      call system_clock(finish)         \n      write(6,*) 'Elapsed Time in seconds:',float(finish-start)/rate\n      return\n      end\n", "target": "import sys, timeit\ndef usec(function, arguments):\n    modname, funcname = __name__, function.__name__\n    timer = timeit.Timer(stmt='%(funcname)s(*args)' % vars(),\n                         setup='from %(modname)s import %(funcname)s; args=%(arguments)r' % vars())\n    try:\n        t, N = 0, 1\n        while t < 0.2:            \n            t = min(timer.repeat(repeat=3, number=N))            \n            N *= 10\n        microseconds = round(10000000 * t / N, 1) \n        return microseconds \n    except:\n        timer.print_exc(file=sys.stderr)\n        raise\n\nfrom math import pow\ndef nothing(): pass\ndef identity(x): return x\n"}
{"id": 85810, "name": "Binary search", "source": "Translate Fortran to C#: recursive function binarySearch_R (a, value) result (bsresult)\n    real, intent(in) :: a(:), value\n    integer          :: bsresult, mid\n    \n    mid = size(a)/2 + 1\n    if (size(a) == 0) then\n        bsresult = 0        \n    else if (a(mid) > value) then\n        bsresult= binarySearch_R(a(:mid-1), value)\n    else if (a(mid) < value) then\n        bsresult = binarySearch_R(a(mid+1:), value)\n        if (bsresult /= 0) then\n            bsresult = mid + bsresult\n        end if\n    else\n        bsresult = mid      \n    end if\nend function binarySearch_R\n", "target": "namespace Search {\n  using System;\n\n  public static partial class Extensions {\n    \n    \n    \n    \n    \n    \n    public static int RecursiveBinarySearchForGLB<T>(this T[] entries, T value)\n      where T : IComparable {\n      return entries.RecursiveBinarySearchForGLB(value, 0, entries.Length - 1);\n    }\n\n    \n    \n    \n    \n    \n    \n    \n    \n    public static int RecursiveBinarySearchForGLB<T>(this T[] entries, T value, int left, int right)\n      where T : IComparable {\n      if (left <= right) {\n        var middle = left + (right - left) / 2;\n        return entries[middle].CompareTo(value) < 0 ?\n          entries.RecursiveBinarySearchForGLB(value, middle + 1, right) :\n          entries.RecursiveBinarySearchForGLB(value, left, middle - 1);\n      }\n\n      \n      \n      return right;\n    }\n\n    \n    \n    \n    \n    \n    \n    public static int RecursiveBinarySearchForLUB<T>(this T[] entries, T value)\n      where T : IComparable {\n      return entries.RecursiveBinarySearchForLUB(value, 0, entries.Length - 1);\n    }\n\n    \n    \n    \n    \n    \n    \n    \n    \n    public static int RecursiveBinarySearchForLUB<T>(this T[] entries, T value, int left, int right)\n      where T : IComparable {\n      if (left <= right) {\n        var middle = left + (right - left) / 2;\n        return entries[middle].CompareTo(value) <= 0 ?\n          entries.RecursiveBinarySearchForLUB(value, middle + 1, right) :\n          entries.RecursiveBinarySearchForLUB(value, left, middle - 1);\n      }\n\n      \n      \n      return left;\n    }\n  }\n}\n"}
{"id": 85813, "name": "Binary search", "source": "Translate Fortran to Java: recursive function binarySearch_R (a, value) result (bsresult)\n    real, intent(in) :: a(:), value\n    integer          :: bsresult, mid\n    \n    mid = size(a)/2 + 1\n    if (size(a) == 0) then\n        bsresult = 0        \n    else if (a(mid) > value) then\n        bsresult= binarySearch_R(a(:mid-1), value)\n    else if (a(mid) < value) then\n        bsresult = binarySearch_R(a(mid+1:), value)\n        if (bsresult /= 0) then\n            bsresult = mid + bsresult\n        end if\n    else\n        bsresult = mid      \n    end if\nend function binarySearch_R\n", "target": "public class BinarySearchIterative {\n\n    public static int binarySearch(int[] nums, int check) {\n        int hi = nums.length - 1;\n        int lo = 0;\n        while (hi >= lo) {\n            int guess = (lo + hi) >>> 1;  \n            if (nums[guess] > check) {\n                hi = guess - 1;\n            } else if (nums[guess] < check) {\n                lo = guess + 1;\n            } else {\n                return guess;\n            }\n        }\n        return -1;\n    }\n\n    public static void main(String[] args) {\n        int[] haystack = {1, 5, 6, 7, 8, 11};\n        int needle = 5;\n        int index = binarySearch(haystack, needle);\n        if (index == -1) {\n            System.out.println(needle + \" is not in the array\");\n        } else {\n            System.out.println(needle + \" is at index \" + index);\n        }\n    }\n}\n"}
{"id": 85814, "name": "Binary search", "source": "Translate Fortran to Python: recursive function binarySearch_R (a, value) result (bsresult)\n    real, intent(in) :: a(:), value\n    integer          :: bsresult, mid\n    \n    mid = size(a)/2 + 1\n    if (size(a) == 0) then\n        bsresult = 0        \n    else if (a(mid) > value) then\n        bsresult= binarySearch_R(a(:mid-1), value)\n    else if (a(mid) < value) then\n        bsresult = binarySearch_R(a(mid+1:), value)\n        if (bsresult /= 0) then\n            bsresult = mid + bsresult\n        end if\n    else\n        bsresult = mid      \n    end if\nend function binarySearch_R\n", "target": "def binary_search(l, value):\n    low = 0\n    high = len(l)-1\n    while low <= high: \n        mid = (low+high)//2\n        if l[mid] > value: high = mid-1\n        elif l[mid] < value: low = mid+1\n        else: return mid\n    return -1\n"}
{"id": 86041, "name": "Documentation", "source": "Translate Fortran to C#:       SUBROUTINE SHOW(A,N)   \n        REAL*8 A    \n        INTEGER N   \n", "target": "\n\n\npublic static class XMLSystem\n{\n    static XMLSystem()\n    {\n        \n    }\n\n    \n    \n    \n    \n    \n    public static XmlDocument GetXML(string name) \n    {\n        return null;\n    }\n}\n"}
{"id": 86043, "name": "Documentation", "source": "Translate Fortran to Java:       SUBROUTINE SHOW(A,N)   \n        REAL*8 A    \n        INTEGER N   \n", "target": "\npublic class Doc{\n   \n   private String field;\n\n   \n   public int method(long num) throws BadException{\n      \n   }\n}\n"}
{"id": 86044, "name": "Documentation", "source": "Translate Fortran to Python:       SUBROUTINE SHOW(A,N)   \n        REAL*8 A    \n        INTEGER N   \n", "target": "class Doc(object):\n   \n   def method(self, num):\n      \n      pass\n"}
{"id": 86226, "name": "Rename a file", "source": "Translate Fortran to C#:       PROGRAM EX_RENAME\n      CALL RENAME('input.txt','output.txt')\n      CALL RENAME('docs','mydocs')\n      CALL RENAME('/input.txt','/output.txt')\n      CALL RENAME('/docs','/mydocs')\n      END\n", "target": "using System;\nusing System.IO;\n\nclass Program {\n    static void Main(string[] args) {\n        File.Move(\"input.txt\",\"output.txt\");\n        File.Move(@\"\\input.txt\",@\"\\output.txt\");\n\n        Directory.Move(\"docs\",\"mydocs\");\n        Directory.Move(@\"\\docs\",@\"\\mydocs\");\n    }\n}\n"}
{"id": 86229, "name": "Rename a file", "source": "Translate Fortran to Java:       PROGRAM EX_RENAME\n      CALL RENAME('input.txt','output.txt')\n      CALL RENAME('docs','mydocs')\n      CALL RENAME('/input.txt','/output.txt')\n      CALL RENAME('/docs','/mydocs')\n      END\n", "target": "import java.io.File;\npublic class FileRenameTest {\n   public static boolean renameFile(String oldname, String newname) {\n       \n       File file = new File(oldname);\n   \n       \n       File file2 = new File(newname);\n   \n       \n       boolean success = file.renameTo(file2);\n       return success;\n   }\n   public static void test(String type, String oldname, String newname) {\n       System.out.println(\"The following \" + type + \" called \" + oldname +\n           ( renameFile(oldname, newname) ? \" was renamed as \" : \" could not be renamed into \")\n           + newname + \".\"\n       );\n   }\n   public static void main(String args[]) {\n        test(\"file\", \"input.txt\", \"output.txt\");\n        test(\"file\", File.separator + \"input.txt\", File.separator + \"output.txt\");\n        test(\"directory\", \"docs\", \"mydocs\");\n        test(\"directory\", File.separator + \"docs\" + File.separator, File.separator + \"mydocs\" + File.separator);\n   }\n}\n"}
{"id": 86230, "name": "Rename a file", "source": "Translate Fortran to Python:       PROGRAM EX_RENAME\n      CALL RENAME('input.txt','output.txt')\n      CALL RENAME('docs','mydocs')\n      CALL RENAME('/input.txt','/output.txt')\n      CALL RENAME('/docs','/mydocs')\n      END\n", "target": "from java.io import File\n\ndef setup():\n    \n    sketchfile = rename(sketchPath(\"input.txt\"), sketchPath(\"output.txt\"))\n    \n    sketchfold = rename(sketchPath(\"docs\"), sketchPath(\"mydocs\"))\n    \n    rootfile = rename(\"input.txt\", \"output.txt\")\n    \n    rootfold = rename(\"docs\", \"mydocs\")\n\n    \n    println(str(sketchfile) + ' ' +\n            str(sketchfold) + ' ' +\n            str(rootfile) +  ' ' +\n            str(rootfold)) \n    \n    \n\n\ndef rename(oldname, newname):\n    \n    file = File(oldname)\n    \n    file2 = File(newname)\n    \n    success = file.renameTo(file2)\n    return success\n"}
{"id": 86460, "name": "Vigen\u00e8re cipher", "source": "Translate Fortran to C#: program vigenere_cipher\n  implicit none\n  \n  character(80) :: plaintext = \"Beware the Jabberwock, my son\n                   ciphertext = \"\"\n  character(14) :: key = \"VIGENERECIPHER\"\n\n\n  call encrypt(plaintext, ciphertext, key)\n  write(*,*) plaintext\n  write(*,*) ciphertext\n  call decrypt(ciphertext, plaintext, key)\n  write(*,*) plaintext\n\ncontains\n\nsubroutine encrypt(intxt, outtxt, k)\n  character(*), intent(in)  :: intxt, k\n  character(*), intent(out) :: outtxt\n  integer :: chrn\n  integer :: cp = 1, kp = 1\n  integer :: i\n  \n  outtxt = \"\"\n  do i = 1, len(trim(intxt))\n    select case(intxt(i:i))\n      case (\"A\":\"Z\", \"a\":\"z\")\n        select case(intxt(i:i))\n          case(\"a\":\"z\")\n            chrn = iachar(intxt(i:i)) - 32\n   \n          case default\n            chrn = iachar(intxt(i:i))\n                         \n        end select\n     \n        outtxt(cp:cp) = achar(modulo(chrn + iachar(k(kp:kp)), 26) + 65)\n        cp = cp + 1\n        kp = kp + 1\n        if(kp > len(k)) kp = kp - len(k)\n \n    end select\n  end do\nend subroutine\n\nsubroutine decrypt(intxt, outtxt, k)\n  character(*), intent(in)  :: intxt, k\n  character(*), intent(out) :: outtxt\n  integer :: chrn\n  integer :: cp = 1, kp = 1\n  integer :: i\n  \n  outtxt = \"\"\n  do i = 1, len(trim(intxt))\n    chrn = iachar(intxt(i:i))\n    outtxt(cp:cp) = achar(modulo(chrn - iachar(k(kp:kp)), 26) + 65)\n    cp = cp + 1\n    kp = kp + 1\n    if(kp > len(k)) kp = kp - len(k)\n   end do\nend subroutine\nend program\n", "target": "using System;\n\nnamespace VigenereCipher\n{\n    class VCipher\n    {\n        public string encrypt(string txt, string pw, int d)\n        {\n            int pwi = 0, tmp;\n            string ns = \"\";\n            txt = txt.ToUpper();\n            pw = pw.ToUpper();\n            foreach (char t in txt)\n            {\n                if (t < 65) continue;\n                tmp = t - 65 + d * (pw[pwi] - 65);\n                if (tmp < 0) tmp += 26;\n                ns += Convert.ToChar(65 + ( tmp % 26) );\n                if (++pwi == pw.Length) pwi = 0;\n            }\n\n            return ns;\n        }\n    };\n\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            VCipher v = new VCipher();\n\n            string s0 = \"Beware the Jabberwock, my son! The jaws that bite, the claws that catch!\",\n                   pw = \"VIGENERECIPHER\";\n\n            Console.WriteLine(s0 + \"\\n\" + pw + \"\\n\");\n            string s1 = v.encrypt(s0, pw, 1);\n            Console.WriteLine(\"Encrypted: \" + s1);\n            s1 = v.encrypt(s1, \"VIGENERECIPHER\", -1);\n            Console.WriteLine(\"Decrypted: \" + s1);\n            Console.WriteLine(\"\\nPress any key to continue...\");\n            Console.ReadKey();\n        }\n    }\n}\n"}
{"id": 86463, "name": "Vigen\u00e8re cipher", "source": "Translate Fortran to Java: program vigenere_cipher\n  implicit none\n  \n  character(80) :: plaintext = \"Beware the Jabberwock, my son\n                   ciphertext = \"\"\n  character(14) :: key = \"VIGENERECIPHER\"\n\n\n  call encrypt(plaintext, ciphertext, key)\n  write(*,*) plaintext\n  write(*,*) ciphertext\n  call decrypt(ciphertext, plaintext, key)\n  write(*,*) plaintext\n\ncontains\n\nsubroutine encrypt(intxt, outtxt, k)\n  character(*), intent(in)  :: intxt, k\n  character(*), intent(out) :: outtxt\n  integer :: chrn\n  integer :: cp = 1, kp = 1\n  integer :: i\n  \n  outtxt = \"\"\n  do i = 1, len(trim(intxt))\n    select case(intxt(i:i))\n      case (\"A\":\"Z\", \"a\":\"z\")\n        select case(intxt(i:i))\n          case(\"a\":\"z\")\n            chrn = iachar(intxt(i:i)) - 32\n   \n          case default\n            chrn = iachar(intxt(i:i))\n                         \n        end select\n     \n        outtxt(cp:cp) = achar(modulo(chrn + iachar(k(kp:kp)), 26) + 65)\n        cp = cp + 1\n        kp = kp + 1\n        if(kp > len(k)) kp = kp - len(k)\n \n    end select\n  end do\nend subroutine\n\nsubroutine decrypt(intxt, outtxt, k)\n  character(*), intent(in)  :: intxt, k\n  character(*), intent(out) :: outtxt\n  integer :: chrn\n  integer :: cp = 1, kp = 1\n  integer :: i\n  \n  outtxt = \"\"\n  do i = 1, len(trim(intxt))\n    chrn = iachar(intxt(i:i))\n    outtxt(cp:cp) = achar(modulo(chrn - iachar(k(kp:kp)), 26) + 65)\n    cp = cp + 1\n    kp = kp + 1\n    if(kp > len(k)) kp = kp - len(k)\n   end do\nend subroutine\nend program\n", "target": "public class VigenereCipher {\n    public static void main(String[] args) {\n        String key = \"VIGENERECIPHER\";\n        String ori = \"Beware the Jabberwock, my son! The jaws that bite, the claws that catch!\";\n        String enc = encrypt(ori, key);\n        System.out.println(enc);\n        System.out.println(decrypt(enc, key));\n    }\n\n    static String encrypt(String text, final String key) {\n        String res = \"\";\n        text = text.toUpperCase();\n        for (int i = 0, j = 0; i < text.length(); i++) {\n            char c = text.charAt(i);\n            if (c < 'A' || c > 'Z') continue;\n            res += (char)((c + key.charAt(j) - 2 * 'A') % 26 + 'A');\n            j = ++j % key.length();\n        }\n        return res;\n    }\n\n    static String decrypt(String text, final String key) {\n        String res = \"\";\n        text = text.toUpperCase();\n        for (int i = 0, j = 0; i < text.length(); i++) {\n            char c = text.charAt(i);\n            if (c < 'A' || c > 'Z') continue;\n            res += (char)((c - key.charAt(j) + 26) % 26 + 'A');\n            j = ++j % key.length();\n        }\n        return res;\n    }\n}\n"}
{"id": 86464, "name": "Vigen\u00e8re cipher", "source": "Translate Fortran to Python: program vigenere_cipher\n  implicit none\n  \n  character(80) :: plaintext = \"Beware the Jabberwock, my son\n                   ciphertext = \"\"\n  character(14) :: key = \"VIGENERECIPHER\"\n\n\n  call encrypt(plaintext, ciphertext, key)\n  write(*,*) plaintext\n  write(*,*) ciphertext\n  call decrypt(ciphertext, plaintext, key)\n  write(*,*) plaintext\n\ncontains\n\nsubroutine encrypt(intxt, outtxt, k)\n  character(*), intent(in)  :: intxt, k\n  character(*), intent(out) :: outtxt\n  integer :: chrn\n  integer :: cp = 1, kp = 1\n  integer :: i\n  \n  outtxt = \"\"\n  do i = 1, len(trim(intxt))\n    select case(intxt(i:i))\n      case (\"A\":\"Z\", \"a\":\"z\")\n        select case(intxt(i:i))\n          case(\"a\":\"z\")\n            chrn = iachar(intxt(i:i)) - 32\n   \n          case default\n            chrn = iachar(intxt(i:i))\n                         \n        end select\n     \n        outtxt(cp:cp) = achar(modulo(chrn + iachar(k(kp:kp)), 26) + 65)\n        cp = cp + 1\n        kp = kp + 1\n        if(kp > len(k)) kp = kp - len(k)\n \n    end select\n  end do\nend subroutine\n\nsubroutine decrypt(intxt, outtxt, k)\n  character(*), intent(in)  :: intxt, k\n  character(*), intent(out) :: outtxt\n  integer :: chrn\n  integer :: cp = 1, kp = 1\n  integer :: i\n  \n  outtxt = \"\"\n  do i = 1, len(trim(intxt))\n    chrn = iachar(intxt(i:i))\n    outtxt(cp:cp) = achar(modulo(chrn - iachar(k(kp:kp)), 26) + 65)\n    cp = cp + 1\n    kp = kp + 1\n    if(kp > len(k)) kp = kp - len(k)\n   end do\nend subroutine\nend program\n", "target": "\n\nfrom itertools import starmap, cycle\n\n\ndef encrypt(message, key):\n    \n\n    \n    \n    message = filter(str.isalpha, message.upper())\n\n    def enc(c, k):\n        \n\n        return chr(((ord(k) + ord(c) - 2 * ord('A')) % 26) + ord('A'))\n\n    return ''.join(starmap(enc, zip(message, cycle(key))))\n\n\ndef decrypt(message, key):\n    \n\n    def dec(c, k):\n        \n\n        return chr(((ord(c) - ord(k) - 2 * ord('A')) % 26) + ord('A'))\n\n    return ''.join(starmap(dec, zip(message, cycle(key))))\n\n\ndef main():\n    \n\n    text = 'Beware the Jabberwock, my son! The jaws that bite, ' + (\n           'the claws that catch!'\n    )\n    key = 'VIGENERECIPHER'\n\n    encr = encrypt(text, key)\n    decr = decrypt(encr, key)\n\n    print(text)\n    print(encr)\n    print(decr)\n\n\nif __name__ == '__main__':\n    main()\n"}
{"id": 87062, "name": "Higher-order functions", "source": "Translate Fortran to C#: FUNCTION FUNC3(FUNC1, FUNC2, x, y)\n  REAL, EXTERNAL :: FUNC1, FUNC2 \n  REAL :: FUNC3\n  REAL :: x, y\n\n  FUNC3 = FUNC1(x) * FUNC2(y)\nEND FUNCTION FUNC3\n", "target": "using System;\n\n\ndelegate int Func2(int a, int b);\n\nclass Program\n{\n    static int Add(int a, int b)\n    {\n        return a + b;\n    }\n    \n    static int Mul(int a, int b)\n    {\n        return a * b;\n    }\n    \n    static int Div(int a, int b)\n    {\n        return a / b;\n    }\n    \n    static int Call(Func2 f, int a, int b)\n    {\n        \n        return f(a, b);\n    }\n\n    static void Main()\n    {\n        int a = 6;\n        int b = 2;\n\n        \n        Func2 add = new Func2(Add);\n        Func2 mul = new Func2(Mul);\n        Func2 div = new Func2(Div);\n        \n        Console.WriteLine(\"f=Add, f({0}, {1}) = {2}\", a, b, Call(add, a, b));\n        Console.WriteLine(\"f=Mul, f({0}, {1}) = {2}\", a, b, Call(mul, a, b));\n        Console.WriteLine(\"f=Div, f({0}, {1}) = {2}\", a, b, Call(div, a, b));\n    }\n}\n"}
{"id": 87065, "name": "Higher-order functions", "source": "Translate Fortran to Java: FUNCTION FUNC3(FUNC1, FUNC2, x, y)\n  REAL, EXTERNAL :: FUNC1, FUNC2 \n  REAL :: FUNC3\n  REAL :: x, y\n\n  FUNC3 = FUNC1(x) * FUNC2(y)\nEND FUNCTION FUNC3\n", "target": "public class NewClass {\n   \n   public NewClass() {\n       first(new AnEventOrCallback() {\n           public void call() {\n               second();\n           }\n       });\n   }\n   \n   public void first(AnEventOrCallback obj) {\n       obj.call();\n   }\n   \n   public void second() {\n       System.out.println(\"Second\");\n   }\n   \n   public static void main(String[] args) {\n       new NewClass();\n   }\n}\n\ninterface AnEventOrCallback {\n   public void call();\n}\n"}
{"id": 87066, "name": "Higher-order functions", "source": "Translate Fortran to Python: FUNCTION FUNC3(FUNC1, FUNC2, x, y)\n  REAL, EXTERNAL :: FUNC1, FUNC2 \n  REAL :: FUNC3\n  REAL :: x, y\n\n  FUNC3 = FUNC1(x) * FUNC2(y)\nEND FUNCTION FUNC3\n", "target": "def first(function):\n    return function()\n\ndef second():\n    return \"second\"\n\nresult = first(second)\n"}
{"id": 87315, "name": "CUSIP", "source": "Translate Fortran to C#:       CHARACTER*1 FUNCTION CUSIPCHECK(TEXT)\t\nCommittee on Uniform Security Identification Purposes, of the American (i.e. USA) Bankers' Association.\n       CHARACTER*8 TEXT\t\t\n       CHARACTER*(*) VALID\t\n       PARAMETER (VALID = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ*@#\")\n       INTEGER I,V,S\t\t\n        S = 0\t\t\n        DO I = 1,LEN(TEXT)\t\n          V = INDEX(VALID,TEXT(I:I)) - 1\t\n          IF (MOD(I,2).EQ.0) V = V*2\t\t\n          S = S + V/10 + MOD(V,10)\t\t\n        END DO\t\t\t\n        I = MOD(10 - MOD(S,10),10) + 1\t\n        CUSIPCHECK = VALID(I:I)\t\n      END FUNCTION CUSIPCHECK\t\n\n      PROGRAM POKE\t\n      INTEGER I,N\t\n      PARAMETER (N = 6)\t\t\n      CHARACTER*9 CUSIP(N)\t\n      DATA CUSIP/\t\t\n     1  \"037833100\",\n     2  \"17275R102\",\n     3  \"38259P508\",\n     4  \"594918104\",\n     5  \"68389X106\",\n     6  \"68389X105\"/\n      CHARACTER*1 CUSIPCHECK\t\n\n      DO I = 1,N\t\n        WRITE (6,*) CUSIP(I),CUSIPCHECK(CUSIP(I)(1:8)).EQ.CUSIP(I)(9:9)\n      END DO\n\n      END\n", "target": "using System;\nusing System.Collections.Generic;\n\nnamespace CUSIP {\n    class Program {\n        static bool IsCusip(string s) {\n            if (s.Length != 9) return false;\n            int sum = 0;\n            for (int i = 0; i <= 7; i++) {\n                char c = s[i];\n\n                int v;\n                if (c >= '0' && c <= '9') {\n                    v = c - 48;\n                }\n                else if (c >= 'A' && c <= 'Z') {\n                    v = c - 55;  \n                }\n                else if (c == '*') {\n                    v = 36;\n                }\n                else if (c == '#') {\n                    v = 38;\n                }\n                else {\n                    return false;\n                }\n                if (i % 2 == 1) v *= 2;  \n                sum += v / 10 + v % 10;\n            }\n            return s[8] - 48 == (10 - (sum % 10)) % 10;\n        }\n\n        static void Main(string[] args) {\n            List<string> candidates = new List<string>() {\n                \"037833100\",\n                \"17275R102\",\n                \"38259P508\",\n                \"594918104\",\n                \"68389X106\",\n                \"68389X105\"\n            };\n            foreach (var candidate in candidates) {\n                Console.WriteLine(\"{0} -> {1}\", candidate, IsCusip(candidate) ? \"correct\" : \"incorrect\");\n            }\n        }\n    }\n}\n"}
{"id": 87318, "name": "CUSIP", "source": "Translate Fortran to Java:       CHARACTER*1 FUNCTION CUSIPCHECK(TEXT)\t\nCommittee on Uniform Security Identification Purposes, of the American (i.e. USA) Bankers' Association.\n       CHARACTER*8 TEXT\t\t\n       CHARACTER*(*) VALID\t\n       PARAMETER (VALID = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ*@#\")\n       INTEGER I,V,S\t\t\n        S = 0\t\t\n        DO I = 1,LEN(TEXT)\t\n          V = INDEX(VALID,TEXT(I:I)) - 1\t\n          IF (MOD(I,2).EQ.0) V = V*2\t\t\n          S = S + V/10 + MOD(V,10)\t\t\n        END DO\t\t\t\n        I = MOD(10 - MOD(S,10),10) + 1\t\n        CUSIPCHECK = VALID(I:I)\t\n      END FUNCTION CUSIPCHECK\t\n\n      PROGRAM POKE\t\n      INTEGER I,N\t\n      PARAMETER (N = 6)\t\t\n      CHARACTER*9 CUSIP(N)\t\n      DATA CUSIP/\t\t\n     1  \"037833100\",\n     2  \"17275R102\",\n     3  \"38259P508\",\n     4  \"594918104\",\n     5  \"68389X106\",\n     6  \"68389X105\"/\n      CHARACTER*1 CUSIPCHECK\t\n\n      DO I = 1,N\t\n        WRITE (6,*) CUSIP(I),CUSIPCHECK(CUSIP(I)(1:8)).EQ.CUSIP(I)(9:9)\n      END DO\n\n      END\n", "target": "import java.util.List;\n\npublic class Cusip {\n    private static Boolean isCusip(String s) {\n        if (s.length() != 9) return false;\n        int sum = 0;\n        for (int i = 0; i <= 7; i++) {\n            char c = s.charAt(i);\n\n            int v;\n            if (c >= '0' && c <= '9') {\n                v = c - 48;\n            } else if (c >= 'A' && c <= 'Z') {\n                v = c - 55;  \n            } else if (c == '*') {\n                v = 36;\n            } else if (c == '@') {\n                v = 37;\n            } else if (c == '#') {\n                v = 38;\n            } else {\n                return false;\n            }\n            if (i % 2 == 1) v *= 2;  \n            sum += v / 10 + v % 10;\n        }\n        return s.charAt(8) - 48 == (10 - (sum % 10)) % 10;\n    }\n\n    public static void main(String[] args) {\n        List<String> candidates = List.of(\n                \"037833100\", \"17275R102\", \"38259P508\", \"594918104\", \"68389X106\", \"68389X105\", \"EXTRACRD8\",\n                \"EXTRACRD9\", \"BADCUSIP!\", \"683&9X106\", \"68389x105\", \"683$9X106\", \"68389}105\", \"87264ABE4\"\n        );\n        for (String candidate : candidates) {\n            System.out.printf(\"%s -> %s%n\", candidate, isCusip(candidate) ? \"correct\" : \"incorrect\");\n        }\n    }\n}\n"}
{"id": 87319, "name": "CUSIP", "source": "Translate Fortran to Python:       CHARACTER*1 FUNCTION CUSIPCHECK(TEXT)\t\nCommittee on Uniform Security Identification Purposes, of the American (i.e. USA) Bankers' Association.\n       CHARACTER*8 TEXT\t\t\n       CHARACTER*(*) VALID\t\n       PARAMETER (VALID = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ*@#\")\n       INTEGER I,V,S\t\t\n        S = 0\t\t\n        DO I = 1,LEN(TEXT)\t\n          V = INDEX(VALID,TEXT(I:I)) - 1\t\n          IF (MOD(I,2).EQ.0) V = V*2\t\t\n          S = S + V/10 + MOD(V,10)\t\t\n        END DO\t\t\t\n        I = MOD(10 - MOD(S,10),10) + 1\t\n        CUSIPCHECK = VALID(I:I)\t\n      END FUNCTION CUSIPCHECK\t\n\n      PROGRAM POKE\t\n      INTEGER I,N\t\n      PARAMETER (N = 6)\t\t\n      CHARACTER*9 CUSIP(N)\t\n      DATA CUSIP/\t\t\n     1  \"037833100\",\n     2  \"17275R102\",\n     3  \"38259P508\",\n     4  \"594918104\",\n     5  \"68389X106\",\n     6  \"68389X105\"/\n      CHARACTER*1 CUSIPCHECK\t\n\n      DO I = 1,N\t\n        WRITE (6,*) CUSIP(I),CUSIPCHECK(CUSIP(I)(1:8)).EQ.CUSIP(I)(9:9)\n      END DO\n\n      END\n", "target": "\n\nimport math\n\ndef cusip_check(cusip):\n    if len(cusip) != 9:\n        raise ValueError('CUSIP must be 9 characters')\n\n    cusip = cusip.upper()\n    total = 0\n    for i in range(8):\n        c = cusip[i]\n        if c.isdigit():\n            v = int(c)\n        elif c.isalpha():\n            p = ord(c) - ord('A') + 1\n            v = p + 9\n        elif c == '*':\n            v = 36\n        elif c == '@':\n            v = 37\n        elif c == '\n            v = 38\n\n        if i % 2 != 0:\n            v *= 2\n\n        total += int(v / 10) + v % 10\n    check = (10 - (total % 10)) % 10\n    return str(check) == cusip[-1]\n\nif __name__ == '__main__':\n    codes = [\n            '037833100',\n            '17275R102',\n            '38259P508',\n            '594918104',\n            '68389X106',\n            '68389X105'\n            ]\n    for code in codes:\n        print(f'{code} -> {cusip_check(code)}')\n"}
{"id": 87836, "name": "Floyd-Warshall algorithm", "source": "Translate Fortran to C#: module floyd_warshall_algorithm\n\n  use, intrinsic :: ieee_arithmetic\n\n  implicit none\n\n  integer, parameter :: floating_point_kind = &\n       & ieee_selected_real_kind (6, 37)\n  integer, parameter :: fpk = floating_point_kind\n\n  integer, parameter :: nil_vertex = 0\n\n  type :: edge\n     integer :: u\n     real(kind = fpk) :: weight\n     integer :: v\n  end type edge\n\n  type :: edge_list\n     type(edge), allocatable :: element(:)\n  end type edge_list\n\ncontains\n\n  subroutine make_example_graph (edges)\n    type(edge_list), intent(out) :: edges\n\n    allocate (edges%element(1:5))\n    edges%element(1) = edge (1, -2.0, 3)\n    edges%element(2) = edge (3, +2.0, 4)\n    edges%element(3) = edge (4, -1.0, 2)\n    edges%element(4) = edge (2, +4.0, 1)\n    edges%element(5) = edge (2, +3.0, 3)\n  end subroutine make_example_graph\n\n  function find_max_vertex (edges) result (n)\n    type(edge_list), intent(in) :: edges\n    integer n\n\n    integer i\n\n    n = 1\n    do i = lbound (edges%element, 1), ubound (edges%element, 1)\n       n = max (n, edges%element(i)%u)\n       n = max (n, edges%element(i)%v)\n    end do\n  end function find_max_vertex\n\n  subroutine floyd_warshall (edges, max_vertex, distance, next_vertex)\n\n    type(edge_list), intent(in) :: edges\n    integer, intent(out) :: max_vertex\n    real(kind = fpk), allocatable, intent(out) :: distance(:,:)\n    integer, allocatable, intent(out) :: next_vertex(:,:)\n\n    integer :: n\n    integer :: i, j, k\n    integer :: u, v\n    real(kind = fpk) :: dist_ikj\n    real(kind = fpk) :: infinity\n\n    n = find_max_vertex (edges)\n    max_vertex = n\n\n    allocate (distance(1:n, 1:n))\n    allocate (next_vertex(1:n, 1:n))\n\n    infinity = ieee_value (1.0_fpk,  ieee_positive_inf)\n\n    \n\n    do i = 1, n\n       do j = 1, n\n          distance(i, j) = infinity\n          next_vertex (i, j) = nil_vertex\n       end do\n    end do\n    do i = lbound (edges%element, 1), ubound (edges%element, 1)\n       u = edges%element(i)%u\n       v = edges%element(i)%v\n       distance(u, v) = edges%element(i)%weight\n       next_vertex(u, v) = v\n    end do\n    do i = 1, n\n       distance(i, i) = 0.0_fpk \n       next_vertex(i, i) = i\n    end do\n\n    \n\n    do k = 1, n\n       do i = 1, n\n          do j = 1, n\n             dist_ikj = distance(i, k) + distance(k, j)\n             if (dist_ikj < distance(i, j)) then\n                distance(i, j) = dist_ikj\n                next_vertex(i, j) = next_vertex(i, k)\n             end if\n          end do\n       end do\n    end do\n\n  end subroutine floyd_warshall\n\n  subroutine print_path (next_vertex, u, v)\n    integer, intent(in) :: next_vertex(:,:)\n    integer, intent(in) :: u, v\n\n    integer i\n\n    if (next_vertex(u, v) /= nil_vertex) then\n       i = u\n       write (*, '(I0)', advance = 'no') i\n       do while (i /= v)\n          i = next_vertex(i, v)\n          write (*, '('' -> '', I0)', advance = 'no') i\n       end do\n    end if\n  end subroutine print_path\n\nend module floyd_warshall_algorithm\n\nprogram floyd_warshall_task\n\n  use, non_intrinsic :: floyd_warshall_algorithm\n\n  implicit none\n\n  type(edge_list) :: example_graph\n  integer :: max_vertex\n  real(kind = fpk), allocatable :: distance(:,:)\n  integer, allocatable :: next_vertex(:,:)\n  integer :: u, v\n\n  call make_example_graph (example_graph)\n  call floyd_warshall (example_graph, max_vertex, distance, &\n       &               next_vertex)\n\n1000 format (1X, I0, ' -> ', I0, 5X, F4.1, 6X)\n\n  write (*, '(''  pair     distance    path'')')\n  write (*, '(''---------------------------------------'')')\n  do u = 1, max_vertex\n     do v = 1, max_vertex\n        if (u /= v) then\n           write (*, 1000, advance = 'no') u, v, distance(u, v)\n           call print_path (next_vertex, u, v)\n           write (*, '()', advance = 'yes')\n        end if\n     end do\n  end do\n\nend program floyd_warshall_task\n", "target": "using System;\n\nnamespace FloydWarshallAlgorithm {\n    class Program {\n        static void FloydWarshall(int[,] weights, int numVerticies) {\n            double[,] dist = new double[numVerticies, numVerticies];\n            for (int i = 0; i < numVerticies; i++) {\n                for (int j = 0; j < numVerticies; j++) {\n                    dist[i, j] = double.PositiveInfinity;\n                }\n            }\n\n            for (int i = 0; i < weights.GetLength(0); i++) {\n                dist[weights[i, 0] - 1, weights[i, 1] - 1] = weights[i, 2];\n            }\n\n            int[,] next = new int[numVerticies, numVerticies];\n            for (int i = 0; i < numVerticies; i++) {\n                for (int j = 0; j < numVerticies; j++) {\n                    if (i != j) {\n                        next[i, j] = j + 1;\n                    }\n                }\n            }\n\n            for (int k = 0; k < numVerticies; k++) {\n                for (int i = 0; i < numVerticies; i++) {\n                    for (int j = 0; j < numVerticies; j++) {\n                        if (dist[i, k] + dist[k, j] < dist[i, j]) {\n                            dist[i, j] = dist[i, k] + dist[k, j];\n                            next[i, j] = next[i, k];\n                        }\n                    }\n                }\n            }\n\n            PrintResult(dist, next);\n        }\n\n        static void PrintResult(double[,] dist, int[,] next) {\n            Console.WriteLine(\"pair     dist    path\");\n            for (int i = 0; i < next.GetLength(0); i++) {\n                for (int j = 0; j < next.GetLength(1); j++) {\n                    if (i != j) {\n                        int u = i + 1;\n                        int v = j + 1;\n                        string path = string.Format(\"{0} -> {1}    {2,2:G}     {3}\", u, v, dist[i, j], u);\n                        do {\n                            u = next[u - 1, v - 1];\n                            path += \" -> \" + u;\n                        } while (u != v);\n                        Console.WriteLine(path);\n                    }\n                }\n            }\n        }\n\n        static void Main(string[] args) {\n            int[,] weights = { { 1, 3, -2 }, { 2, 1, 4 }, { 2, 3, 3 }, { 3, 4, 2 }, { 4, 2, -1 } };\n            int numVerticies = 4;\n\n            FloydWarshall(weights, numVerticies);\n        }\n    }\n}\n"}
{"id": 87839, "name": "Floyd-Warshall algorithm", "source": "Translate Fortran to Java: module floyd_warshall_algorithm\n\n  use, intrinsic :: ieee_arithmetic\n\n  implicit none\n\n  integer, parameter :: floating_point_kind = &\n       & ieee_selected_real_kind (6, 37)\n  integer, parameter :: fpk = floating_point_kind\n\n  integer, parameter :: nil_vertex = 0\n\n  type :: edge\n     integer :: u\n     real(kind = fpk) :: weight\n     integer :: v\n  end type edge\n\n  type :: edge_list\n     type(edge), allocatable :: element(:)\n  end type edge_list\n\ncontains\n\n  subroutine make_example_graph (edges)\n    type(edge_list), intent(out) :: edges\n\n    allocate (edges%element(1:5))\n    edges%element(1) = edge (1, -2.0, 3)\n    edges%element(2) = edge (3, +2.0, 4)\n    edges%element(3) = edge (4, -1.0, 2)\n    edges%element(4) = edge (2, +4.0, 1)\n    edges%element(5) = edge (2, +3.0, 3)\n  end subroutine make_example_graph\n\n  function find_max_vertex (edges) result (n)\n    type(edge_list), intent(in) :: edges\n    integer n\n\n    integer i\n\n    n = 1\n    do i = lbound (edges%element, 1), ubound (edges%element, 1)\n       n = max (n, edges%element(i)%u)\n       n = max (n, edges%element(i)%v)\n    end do\n  end function find_max_vertex\n\n  subroutine floyd_warshall (edges, max_vertex, distance, next_vertex)\n\n    type(edge_list), intent(in) :: edges\n    integer, intent(out) :: max_vertex\n    real(kind = fpk), allocatable, intent(out) :: distance(:,:)\n    integer, allocatable, intent(out) :: next_vertex(:,:)\n\n    integer :: n\n    integer :: i, j, k\n    integer :: u, v\n    real(kind = fpk) :: dist_ikj\n    real(kind = fpk) :: infinity\n\n    n = find_max_vertex (edges)\n    max_vertex = n\n\n    allocate (distance(1:n, 1:n))\n    allocate (next_vertex(1:n, 1:n))\n\n    infinity = ieee_value (1.0_fpk,  ieee_positive_inf)\n\n    \n\n    do i = 1, n\n       do j = 1, n\n          distance(i, j) = infinity\n          next_vertex (i, j) = nil_vertex\n       end do\n    end do\n    do i = lbound (edges%element, 1), ubound (edges%element, 1)\n       u = edges%element(i)%u\n       v = edges%element(i)%v\n       distance(u, v) = edges%element(i)%weight\n       next_vertex(u, v) = v\n    end do\n    do i = 1, n\n       distance(i, i) = 0.0_fpk \n       next_vertex(i, i) = i\n    end do\n\n    \n\n    do k = 1, n\n       do i = 1, n\n          do j = 1, n\n             dist_ikj = distance(i, k) + distance(k, j)\n             if (dist_ikj < distance(i, j)) then\n                distance(i, j) = dist_ikj\n                next_vertex(i, j) = next_vertex(i, k)\n             end if\n          end do\n       end do\n    end do\n\n  end subroutine floyd_warshall\n\n  subroutine print_path (next_vertex, u, v)\n    integer, intent(in) :: next_vertex(:,:)\n    integer, intent(in) :: u, v\n\n    integer i\n\n    if (next_vertex(u, v) /= nil_vertex) then\n       i = u\n       write (*, '(I0)', advance = 'no') i\n       do while (i /= v)\n          i = next_vertex(i, v)\n          write (*, '('' -> '', I0)', advance = 'no') i\n       end do\n    end if\n  end subroutine print_path\n\nend module floyd_warshall_algorithm\n\nprogram floyd_warshall_task\n\n  use, non_intrinsic :: floyd_warshall_algorithm\n\n  implicit none\n\n  type(edge_list) :: example_graph\n  integer :: max_vertex\n  real(kind = fpk), allocatable :: distance(:,:)\n  integer, allocatable :: next_vertex(:,:)\n  integer :: u, v\n\n  call make_example_graph (example_graph)\n  call floyd_warshall (example_graph, max_vertex, distance, &\n       &               next_vertex)\n\n1000 format (1X, I0, ' -> ', I0, 5X, F4.1, 6X)\n\n  write (*, '(''  pair     distance    path'')')\n  write (*, '(''---------------------------------------'')')\n  do u = 1, max_vertex\n     do v = 1, max_vertex\n        if (u /= v) then\n           write (*, 1000, advance = 'no') u, v, distance(u, v)\n           call print_path (next_vertex, u, v)\n           write (*, '()', advance = 'yes')\n        end if\n     end do\n  end do\n\nend program floyd_warshall_task\n", "target": "import static java.lang.String.format;\nimport java.util.Arrays;\n\npublic class FloydWarshall {\n\n    public static void main(String[] args) {\n        int[][] weights = {{1, 3, -2}, {2, 1, 4}, {2, 3, 3}, {3, 4, 2}, {4, 2, -1}};\n        int numVertices = 4;\n\n        floydWarshall(weights, numVertices);\n    }\n\n    static void floydWarshall(int[][] weights, int numVertices) {\n\n        double[][] dist = new double[numVertices][numVertices];\n        for (double[] row : dist)\n            Arrays.fill(row, Double.POSITIVE_INFINITY);\n\n        for (int[] w : weights)\n            dist[w[0] - 1][w[1] - 1] = w[2];\n\n        int[][] next = new int[numVertices][numVertices];\n        for (int i = 0; i < next.length; i++) {\n            for (int j = 0; j < next.length; j++)\n                if (i != j)\n                    next[i][j] = j + 1;\n        }\n\n        for (int k = 0; k < numVertices; k++)\n            for (int i = 0; i < numVertices; i++)\n                for (int j = 0; j < numVertices; j++)\n                    if (dist[i][k] + dist[k][j] < dist[i][j]) {\n                        dist[i][j] = dist[i][k] + dist[k][j];\n                        next[i][j] = next[i][k];\n                    }\n\n        printResult(dist, next);\n    }\n\n    static void printResult(double[][] dist, int[][] next) {\n        System.out.println(\"pair     dist    path\");\n        for (int i = 0; i < next.length; i++) {\n            for (int j = 0; j < next.length; j++) {\n                if (i != j) {\n                    int u = i + 1;\n                    int v = j + 1;\n                    String path = format(\"%d -> %d    %2d     %s\", u, v,\n                            (int) dist[i][j], u);\n                    do {\n                        u = next[u - 1][v - 1];\n                        path += \" -> \" + u;\n                    } while (u != v);\n                    System.out.println(path);\n                }\n            }\n        }\n    }\n}\n"}
{"id": 87840, "name": "Floyd-Warshall algorithm", "source": "Translate Fortran to Python: module floyd_warshall_algorithm\n\n  use, intrinsic :: ieee_arithmetic\n\n  implicit none\n\n  integer, parameter :: floating_point_kind = &\n       & ieee_selected_real_kind (6, 37)\n  integer, parameter :: fpk = floating_point_kind\n\n  integer, parameter :: nil_vertex = 0\n\n  type :: edge\n     integer :: u\n     real(kind = fpk) :: weight\n     integer :: v\n  end type edge\n\n  type :: edge_list\n     type(edge), allocatable :: element(:)\n  end type edge_list\n\ncontains\n\n  subroutine make_example_graph (edges)\n    type(edge_list), intent(out) :: edges\n\n    allocate (edges%element(1:5))\n    edges%element(1) = edge (1, -2.0, 3)\n    edges%element(2) = edge (3, +2.0, 4)\n    edges%element(3) = edge (4, -1.0, 2)\n    edges%element(4) = edge (2, +4.0, 1)\n    edges%element(5) = edge (2, +3.0, 3)\n  end subroutine make_example_graph\n\n  function find_max_vertex (edges) result (n)\n    type(edge_list), intent(in) :: edges\n    integer n\n\n    integer i\n\n    n = 1\n    do i = lbound (edges%element, 1), ubound (edges%element, 1)\n       n = max (n, edges%element(i)%u)\n       n = max (n, edges%element(i)%v)\n    end do\n  end function find_max_vertex\n\n  subroutine floyd_warshall (edges, max_vertex, distance, next_vertex)\n\n    type(edge_list), intent(in) :: edges\n    integer, intent(out) :: max_vertex\n    real(kind = fpk), allocatable, intent(out) :: distance(:,:)\n    integer, allocatable, intent(out) :: next_vertex(:,:)\n\n    integer :: n\n    integer :: i, j, k\n    integer :: u, v\n    real(kind = fpk) :: dist_ikj\n    real(kind = fpk) :: infinity\n\n    n = find_max_vertex (edges)\n    max_vertex = n\n\n    allocate (distance(1:n, 1:n))\n    allocate (next_vertex(1:n, 1:n))\n\n    infinity = ieee_value (1.0_fpk,  ieee_positive_inf)\n\n    \n\n    do i = 1, n\n       do j = 1, n\n          distance(i, j) = infinity\n          next_vertex (i, j) = nil_vertex\n       end do\n    end do\n    do i = lbound (edges%element, 1), ubound (edges%element, 1)\n       u = edges%element(i)%u\n       v = edges%element(i)%v\n       distance(u, v) = edges%element(i)%weight\n       next_vertex(u, v) = v\n    end do\n    do i = 1, n\n       distance(i, i) = 0.0_fpk \n       next_vertex(i, i) = i\n    end do\n\n    \n\n    do k = 1, n\n       do i = 1, n\n          do j = 1, n\n             dist_ikj = distance(i, k) + distance(k, j)\n             if (dist_ikj < distance(i, j)) then\n                distance(i, j) = dist_ikj\n                next_vertex(i, j) = next_vertex(i, k)\n             end if\n          end do\n       end do\n    end do\n\n  end subroutine floyd_warshall\n\n  subroutine print_path (next_vertex, u, v)\n    integer, intent(in) :: next_vertex(:,:)\n    integer, intent(in) :: u, v\n\n    integer i\n\n    if (next_vertex(u, v) /= nil_vertex) then\n       i = u\n       write (*, '(I0)', advance = 'no') i\n       do while (i /= v)\n          i = next_vertex(i, v)\n          write (*, '('' -> '', I0)', advance = 'no') i\n       end do\n    end if\n  end subroutine print_path\n\nend module floyd_warshall_algorithm\n\nprogram floyd_warshall_task\n\n  use, non_intrinsic :: floyd_warshall_algorithm\n\n  implicit none\n\n  type(edge_list) :: example_graph\n  integer :: max_vertex\n  real(kind = fpk), allocatable :: distance(:,:)\n  integer, allocatable :: next_vertex(:,:)\n  integer :: u, v\n\n  call make_example_graph (example_graph)\n  call floyd_warshall (example_graph, max_vertex, distance, &\n       &               next_vertex)\n\n1000 format (1X, I0, ' -> ', I0, 5X, F4.1, 6X)\n\n  write (*, '(''  pair     distance    path'')')\n  write (*, '(''---------------------------------------'')')\n  do u = 1, max_vertex\n     do v = 1, max_vertex\n        if (u /= v) then\n           write (*, 1000, advance = 'no') u, v, distance(u, v)\n           call print_path (next_vertex, u, v)\n           write (*, '()', advance = 'yes')\n        end if\n     end do\n  end do\n\nend program floyd_warshall_task\n", "target": "from math import inf\nfrom itertools import product\n\ndef floyd_warshall(n, edge):\n    rn = range(n)\n    dist = [[inf] * n for i in rn]\n    nxt  = [[0]   * n for i in rn]\n    for i in rn:\n        dist[i][i] = 0\n    for u, v, w in edge:\n        dist[u-1][v-1] = w\n        nxt[u-1][v-1] = v-1\n    for k, i, j in product(rn, repeat=3):\n        sum_ik_kj = dist[i][k] + dist[k][j]\n        if dist[i][j] > sum_ik_kj:\n            dist[i][j] = sum_ik_kj\n            nxt[i][j]  = nxt[i][k]\n    print(\"pair     dist    path\")\n    for i, j in product(rn, repeat=2):\n        if i != j:\n            path = [i]\n            while path[-1] != j:\n                path.append(nxt[path[-1]][j])\n            print(\"%d \u2192 %d  %4d       %s\" \n                  % (i + 1, j + 1, dist[i][j], \n                     ' \u2192 '.join(str(p + 1) for p in path)))\n\nif __name__ == '__main__':\n    floyd_warshall(4, [[1, 3, -2], [2, 1, 4], [2, 3, 3], [3, 4, 2], [4, 2, -1]])\n"}
{"id": 88046, "name": "Roots of unity", "source": "Translate Fortran to C#: PROGRAM Roots\n\n  COMPLEX :: root \n  INTEGER :: i, n\n  REAL :: angle, pi\n\n  pi = 4.0 * ATAN(1.0)\n  DO n = 2, 7\n    angle = 0.0\n    WRITE(*,\"(I1,A)\", ADVANCE=\"NO\") n,\": \"\n    DO i = 1, n\n      root = CMPLX(COS(angle), SIN(angle))\n      WRITE(*,\"(SP,2F7.4,A)\", ADVANCE=\"NO\") root, \"j  \"\n      angle = angle + (2.0*pi / REAL(n))\n    END DO\n    WRITE(*,*)\n  END DO\n\nEND PROGRAM Roots\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Numerics;\n\nclass Program\n{\n    static IEnumerable<Complex> RootsOfUnity(int degree)\n    {\n        return Enumerable\n            .Range(0, degree)\n            .Select(element => Complex.FromPolarCoordinates(1, 2 * Math.PI * element / degree));\n    }\n\n    static void Main()\n    {\n        var degree = 3;\n        foreach (var root in RootsOfUnity(degree))\n        {\n            Console.WriteLine(root);\n        }\n    }\n}\n"}
{"id": 88049, "name": "Roots of unity", "source": "Translate Fortran to Java: PROGRAM Roots\n\n  COMPLEX :: root \n  INTEGER :: i, n\n  REAL :: angle, pi\n\n  pi = 4.0 * ATAN(1.0)\n  DO n = 2, 7\n    angle = 0.0\n    WRITE(*,\"(I1,A)\", ADVANCE=\"NO\") n,\": \"\n    DO i = 1, n\n      root = CMPLX(COS(angle), SIN(angle))\n      WRITE(*,\"(SP,2F7.4,A)\", ADVANCE=\"NO\") root, \"j  \"\n      angle = angle + (2.0*pi / REAL(n))\n    END DO\n    WRITE(*,*)\n  END DO\n\nEND PROGRAM Roots\n", "target": "import java.util.Locale;\n\npublic class Test {\n\n    public static void main(String[] a) {\n        for (int n = 2; n < 6; n++)\n            unity(n);\n    }\n\n    public static void unity(int n) {\n        System.out.printf(\"%n%d: \", n);\n\n        \n        for (double angle = 0; angle < 2 * Math.PI; angle += (2 * Math.PI) / n) {\n\n            double real = Math.cos(angle); \n\n            if (Math.abs(real) < 1.0E-3)\n                real = 0.0; \n\n            double imag = Math.sin(angle); \n\n            if (Math.abs(imag) < 1.0E-3)\n                imag = 0.0;\n\n            System.out.printf(Locale.US, \"(%9f,%9f) \", real, imag);\n        }\n    }\n}\n"}
{"id": 88050, "name": "Roots of unity", "source": "Translate Fortran to Python: PROGRAM Roots\n\n  COMPLEX :: root \n  INTEGER :: i, n\n  REAL :: angle, pi\n\n  pi = 4.0 * ATAN(1.0)\n  DO n = 2, 7\n    angle = 0.0\n    WRITE(*,\"(I1,A)\", ADVANCE=\"NO\") n,\": \"\n    DO i = 1, n\n      root = CMPLX(COS(angle), SIN(angle))\n      WRITE(*,\"(SP,2F7.4,A)\", ADVANCE=\"NO\") root, \"j  \"\n      angle = angle + (2.0*pi / REAL(n))\n    END DO\n    WRITE(*,*)\n  END DO\n\nEND PROGRAM Roots\n", "target": "import cmath\n\n\nclass Complex(complex):\n    def __repr__(self):\n        rp = '%7.5f' % self.real if not self.pureImag() else ''\n        ip = '%7.5fj' % self.imag if not self.pureReal() else ''\n        conj = '' if (\n            self.pureImag() or self.pureReal() or self.imag < 0.0\n        ) else '+'\n        return '0.0' if (\n            self.pureImag() and self.pureReal()\n        ) else rp + conj + ip\n\n    def pureImag(self):\n        return abs(self.real) < 0.000005\n\n    def pureReal(self):\n        return abs(self.imag) < 0.000005\n\n\ndef croots(n):\n    if n <= 0:\n        return None\n    return (Complex(cmath.rect(1, 2 * k * cmath.pi / n)) for k in range(n))\n    \n    \n\n\nfor nr in range(2, 11):\n    print(nr, list(croots(nr)))\n"}
{"id": 88461, "name": "Sorting algorithms_Insertion sort", "source": "Translate Fortran to C#: subroutine sort(n, a)\n    implicit none\n    integer :: n, i, j\n    real :: a(n), x\n    \n    do i = 2, n\n        x = a(i)\n        j = i - 1\n        do while (j >= 1)\n            if (a(j) <= x) exit\n            a(j + 1) = a(j)\n            j = j - 1\n        end do\n        a(j + 1) = x\n    end do\nend subroutine\n", "target": "namespace Sort {\n  using System;\n\n  static class InsertionSort<T> where T : IComparable {\n    public static void Sort(T[] entries) {\n      Sort(entries, 0, entries.Length - 1);\n    }\n\n    public static void Sort(T[] entries, Int32 first, Int32 last) {\n      for (var i = first + 1; i <= last; i++) {\n        var entry = entries[i];\n        var j = i;\n\n        while (j > first && entries[j - 1].CompareTo(entry) > 0)\n          entries[j] = entries[--j];\n\n        entries[j] = entry;\n      }\n    }\n  }\n}\n"}
{"id": 88465, "name": "Sorting algorithms_Insertion sort", "source": "Translate Fortran to Java: subroutine sort(n, a)\n    implicit none\n    integer :: n, i, j\n    real :: a(n), x\n    \n    do i = 2, n\n        x = a(i)\n        j = i - 1\n        do while (j >= 1)\n            if (a(j) <= x) exit\n            a(j + 1) = a(j)\n            j = j - 1\n        end do\n        a(j + 1) = x\n    end do\nend subroutine\n", "target": "public static void insertSort(int[] A){\n  for(int i = 1; i < A.length; i++){\n    int value = A[i];\n    int j = i - 1;\n    while(j >= 0 && A[j] > value){\n      A[j + 1] = A[j];\n      j = j - 1;\n    }\n    A[j + 1] = value;\n  }\n}\n"}
{"id": 88466, "name": "Sorting algorithms_Insertion sort", "source": "Translate Fortran to Python: subroutine sort(n, a)\n    implicit none\n    integer :: n, i, j\n    real :: a(n), x\n    \n    do i = 2, n\n        x = a(i)\n        j = i - 1\n        do while (j >= 1)\n            if (a(j) <= x) exit\n            a(j + 1) = a(j)\n            j = j - 1\n        end do\n        a(j + 1) = x\n    end do\nend subroutine\n", "target": "def insertion_sort(L):\n    for i in xrange(1, len(L)):\n        j = i-1 \n        key = L[i]\n        while j >= 0 and L[j] > key:\n           L[j+1] = L[j]\n           j -= 1\n        L[j+1] = key\n"}
{"id": 88812, "name": "Angle difference between two bearings", "source": "Translate Fortran to C#:       SUBROUTINE BDIFF (B1,B2)\t\n       REAL*8 B1,B2\t\n       COMPLEX*16 CIS,Z1,Z2,Z\t\n       CIS(T) = CMPLX(COSD(T),SIND(T))\t\n        Z1 = CIS(90 - B1)\t\n        Z2 = CIS(90 - B2)\t\n        Z = Z1*CONJG(Z2)\t\n        T = ATAN2D(AIMAG(Z),REAL(Z))\t\n        WRITE (6,10) B1,Z1,B2,Z2,T\t\n   10   FORMAT (2(F14.4,\"(\",F9.6,\",\",F9.6,\")\"),F9.3)\t\n      END SUBROUTINE BDIFF\t\n\n      PROGRAM ORIENTED\n      REAL*8 B(24)\t\n      DATA B/20D0,45D0, -45D0,45D0, -85D0,90D0, -95D0,90D0,\t\n     1      -45D0,125D0, -45D0,145D0, 29.4803D0,-88.6381D0,\n     2      -78.3251D0,              -159.036D0,\n     3   -70099.74233810938D0,      29840.67437876723D0,\n     4  -165313.6666297357D0,       33693.9894517456D0,\n     5     1174.8380510598456D0,  -154146.66490124757D0,\n     6    60175.77306795546D0,      42213.07192354373D0/\n\n      WRITE (6,1) (\"B\",I,\"x\",\"y\", I = 1,2)\t\n    1 FORMAT (28X,\"Bearing calculations, in degrees\"//\n     * 2(A13,I1,\"(\",A9,\",\",A9,\")\"),A9)\t\n\n      DO I = 1,23,2\t\n        CALL BDIFF(B(I),B(I + 1))\n      END DO\n\n      END\n", "target": "using System;\n\nnamespace Angle_difference_between_two_bearings\n{\n\tclass Program\n\t{\n\t\tpublic static void Main(string[] args)\n\t\t{\n\t\t\tConsole.WriteLine();\n\t\t\tConsole.WriteLine(\"Hello World!\");\n\t\t\tConsole.WriteLine();\n\t\t\t\n\t\t\t\n\t\t\tConsole.WriteLine(Delta_Bearing( 20M,45));\n\t\t\tConsole.WriteLine(Delta_Bearing(-45M,45M));\n\t\t\tConsole.WriteLine(Delta_Bearing(-85M,90M));\n\t\t\tConsole.WriteLine(Delta_Bearing(-95M,90M));\n\t\t\tConsole.WriteLine(Delta_Bearing(-45M,125M));\n\t\t\tConsole.WriteLine(Delta_Bearing(-45M,145M));\n\t\t\tConsole.WriteLine(Delta_Bearing( 29.4803M,-88.6381M));\n\t\t\tConsole.WriteLine(Delta_Bearing(-78.3251M, -159.036M));\n\t\t\t\n\t\t\t\n\t\t\tConsole.WriteLine(Delta_Bearing(-70099.74233810938M,   29840.67437876723M));\n\t\t\tConsole.WriteLine(Delta_Bearing(-165313.6666297357M,   33693.9894517456M));\n\t\t\tConsole.WriteLine(Delta_Bearing( 1174.8380510598456M, -154146.66490124757M));\n\t\t\tConsole.WriteLine(Delta_Bearing( 60175.77306795546M,   42213.07192354373M));\n\t\t\t\n\t\t\tConsole.WriteLine();\n\t\t\tConsole.Write(\"Press any key to continue . . . \");\n\t\t\tConsole.ReadKey(true);\n\t\t}\n\t\t\n\t\tstatic decimal Delta_Bearing(decimal b1, decimal b2)\n\t\t{\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t\tdecimal d = 0;\n\t\t\t\n\t\t\t\n\t\t\tif(b1<0)\n\t\t\t\tb1 += 360;\n\t\t\tif(b2<0)\n\t\t\t\tb2 += 360;\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t\td = (b2 - b1)%360;\n\t\t\t\n\t\t\tif(d>180)\n\t\t\t\td -= 360;\n\t\t\telse if(d<-180)\n\t\t\t\td += 360;\n\t\t\t\n\t\t\treturn d;\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t}\n\t}\n}\n"}
{"id": 88813, "name": "Angle difference between two bearings", "source": "Translate Fortran to C#:       SUBROUTINE BDIFF (B1,B2)\t\n       REAL*8 B1,B2\t\n       COMPLEX*16 CIS,Z1,Z2,Z\t\n       CIS(T) = CMPLX(COSD(T),SIND(T))\t\n        Z1 = CIS(90 - B1)\t\n        Z2 = CIS(90 - B2)\t\n        Z = Z1*CONJG(Z2)\t\n        T = ATAN2D(AIMAG(Z),REAL(Z))\t\n        WRITE (6,10) B1,Z1,B2,Z2,T\t\n   10   FORMAT (2(F14.4,\"(\",F9.6,\",\",F9.6,\")\"),F9.3)\t\n      END SUBROUTINE BDIFF\t\n\n      PROGRAM ORIENTED\n      REAL*8 B(24)\t\n      DATA B/20D0,45D0, -45D0,45D0, -85D0,90D0, -95D0,90D0,\t\n     1      -45D0,125D0, -45D0,145D0, 29.4803D0,-88.6381D0,\n     2      -78.3251D0,              -159.036D0,\n     3   -70099.74233810938D0,      29840.67437876723D0,\n     4  -165313.6666297357D0,       33693.9894517456D0,\n     5     1174.8380510598456D0,  -154146.66490124757D0,\n     6    60175.77306795546D0,      42213.07192354373D0/\n\n      WRITE (6,1) (\"B\",I,\"x\",\"y\", I = 1,2)\t\n    1 FORMAT (28X,\"Bearing calculations, in degrees\"//\n     * 2(A13,I1,\"(\",A9,\",\",A9,\")\"),A9)\t\n\n      DO I = 1,23,2\t\n        CALL BDIFF(B(I),B(I + 1))\n      END DO\n\n      END\n", "target": "using System;\n\nnamespace Angle_difference_between_two_bearings\n{\n\tclass Program\n\t{\n\t\tpublic static void Main(string[] args)\n\t\t{\n\t\t\tConsole.WriteLine();\n\t\t\tConsole.WriteLine(\"Hello World!\");\n\t\t\tConsole.WriteLine();\n\t\t\t\n\t\t\t\n\t\t\tConsole.WriteLine(Delta_Bearing( 20M,45));\n\t\t\tConsole.WriteLine(Delta_Bearing(-45M,45M));\n\t\t\tConsole.WriteLine(Delta_Bearing(-85M,90M));\n\t\t\tConsole.WriteLine(Delta_Bearing(-95M,90M));\n\t\t\tConsole.WriteLine(Delta_Bearing(-45M,125M));\n\t\t\tConsole.WriteLine(Delta_Bearing(-45M,145M));\n\t\t\tConsole.WriteLine(Delta_Bearing( 29.4803M,-88.6381M));\n\t\t\tConsole.WriteLine(Delta_Bearing(-78.3251M, -159.036M));\n\t\t\t\n\t\t\t\n\t\t\tConsole.WriteLine(Delta_Bearing(-70099.74233810938M,   29840.67437876723M));\n\t\t\tConsole.WriteLine(Delta_Bearing(-165313.6666297357M,   33693.9894517456M));\n\t\t\tConsole.WriteLine(Delta_Bearing( 1174.8380510598456M, -154146.66490124757M));\n\t\t\tConsole.WriteLine(Delta_Bearing( 60175.77306795546M,   42213.07192354373M));\n\t\t\t\n\t\t\tConsole.WriteLine();\n\t\t\tConsole.Write(\"Press any key to continue . . . \");\n\t\t\tConsole.ReadKey(true);\n\t\t}\n\t\t\n\t\tstatic decimal Delta_Bearing(decimal b1, decimal b2)\n\t\t{\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t\tdecimal d = 0;\n\t\t\t\n\t\t\t\n\t\t\tif(b1<0)\n\t\t\t\tb1 += 360;\n\t\t\tif(b2<0)\n\t\t\t\tb2 += 360;\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t\td = (b2 - b1)%360;\n\t\t\t\n\t\t\tif(d>180)\n\t\t\t\td -= 360;\n\t\t\telse if(d<-180)\n\t\t\t\td += 360;\n\t\t\t\n\t\t\treturn d;\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t}\n\t}\n}\n"}
{"id": 88819, "name": "Angle difference between two bearings", "source": "Translate Fortran to Java:       SUBROUTINE BDIFF (B1,B2)\t\n       REAL*8 B1,B2\t\n       COMPLEX*16 CIS,Z1,Z2,Z\t\n       CIS(T) = CMPLX(COSD(T),SIND(T))\t\n        Z1 = CIS(90 - B1)\t\n        Z2 = CIS(90 - B2)\t\n        Z = Z1*CONJG(Z2)\t\n        T = ATAN2D(AIMAG(Z),REAL(Z))\t\n        WRITE (6,10) B1,Z1,B2,Z2,T\t\n   10   FORMAT (2(F14.4,\"(\",F9.6,\",\",F9.6,\")\"),F9.3)\t\n      END SUBROUTINE BDIFF\t\n\n      PROGRAM ORIENTED\n      REAL*8 B(24)\t\n      DATA B/20D0,45D0, -45D0,45D0, -85D0,90D0, -95D0,90D0,\t\n     1      -45D0,125D0, -45D0,145D0, 29.4803D0,-88.6381D0,\n     2      -78.3251D0,              -159.036D0,\n     3   -70099.74233810938D0,      29840.67437876723D0,\n     4  -165313.6666297357D0,       33693.9894517456D0,\n     5     1174.8380510598456D0,  -154146.66490124757D0,\n     6    60175.77306795546D0,      42213.07192354373D0/\n\n      WRITE (6,1) (\"B\",I,\"x\",\"y\", I = 1,2)\t\n    1 FORMAT (28X,\"Bearing calculations, in degrees\"//\n     * 2(A13,I1,\"(\",A9,\",\",A9,\")\"),A9)\t\n\n      DO I = 1,23,2\t\n        CALL BDIFF(B(I),B(I + 1))\n      END DO\n\n      END\n", "target": "public class AngleDifference {\n\n    public static double getDifference(double b1, double b2) {\n        double r = (b2 - b1) % 360.0;\n        if (r < -180.0)\n            r += 360.0;\n        if (r >= 180.0)\n            r -= 360.0;\n        return r;\n    }\n\n    public static void main(String[] args) {\n        System.out.println(\"Input in -180 to +180 range\");\n        System.out.println(getDifference(20.0, 45.0));\n        System.out.println(getDifference(-45.0, 45.0));\n        System.out.println(getDifference(-85.0, 90.0));\n        System.out.println(getDifference(-95.0, 90.0));\n        System.out.println(getDifference(-45.0, 125.0));\n        System.out.println(getDifference(-45.0, 145.0));\n        System.out.println(getDifference(-45.0, 125.0));\n        System.out.println(getDifference(-45.0, 145.0));\n        System.out.println(getDifference(29.4803, -88.6381));\n        System.out.println(getDifference(-78.3251, -159.036));\n\n        System.out.println(\"Input in wider range\");\n        System.out.println(getDifference(-70099.74233810938, 29840.67437876723));\n        System.out.println(getDifference(-165313.6666297357, 33693.9894517456));\n        System.out.println(getDifference(1174.8380510598456, -154146.66490124757));\n        System.out.println(getDifference(60175.77306795546, 42213.07192354373));\n    }\n}\n"}
{"id": 88820, "name": "Angle difference between two bearings", "source": "Translate Fortran to Java:       SUBROUTINE BDIFF (B1,B2)\t\n       REAL*8 B1,B2\t\n       COMPLEX*16 CIS,Z1,Z2,Z\t\n       CIS(T) = CMPLX(COSD(T),SIND(T))\t\n        Z1 = CIS(90 - B1)\t\n        Z2 = CIS(90 - B2)\t\n        Z = Z1*CONJG(Z2)\t\n        T = ATAN2D(AIMAG(Z),REAL(Z))\t\n        WRITE (6,10) B1,Z1,B2,Z2,T\t\n   10   FORMAT (2(F14.4,\"(\",F9.6,\",\",F9.6,\")\"),F9.3)\t\n      END SUBROUTINE BDIFF\t\n\n      PROGRAM ORIENTED\n      REAL*8 B(24)\t\n      DATA B/20D0,45D0, -45D0,45D0, -85D0,90D0, -95D0,90D0,\t\n     1      -45D0,125D0, -45D0,145D0, 29.4803D0,-88.6381D0,\n     2      -78.3251D0,              -159.036D0,\n     3   -70099.74233810938D0,      29840.67437876723D0,\n     4  -165313.6666297357D0,       33693.9894517456D0,\n     5     1174.8380510598456D0,  -154146.66490124757D0,\n     6    60175.77306795546D0,      42213.07192354373D0/\n\n      WRITE (6,1) (\"B\",I,\"x\",\"y\", I = 1,2)\t\n    1 FORMAT (28X,\"Bearing calculations, in degrees\"//\n     * 2(A13,I1,\"(\",A9,\",\",A9,\")\"),A9)\t\n\n      DO I = 1,23,2\t\n        CALL BDIFF(B(I),B(I + 1))\n      END DO\n\n      END\n", "target": "public class AngleDifference {\n\n    public static double getDifference(double b1, double b2) {\n        double r = (b2 - b1) % 360.0;\n        if (r < -180.0)\n            r += 360.0;\n        if (r >= 180.0)\n            r -= 360.0;\n        return r;\n    }\n\n    public static void main(String[] args) {\n        System.out.println(\"Input in -180 to +180 range\");\n        System.out.println(getDifference(20.0, 45.0));\n        System.out.println(getDifference(-45.0, 45.0));\n        System.out.println(getDifference(-85.0, 90.0));\n        System.out.println(getDifference(-95.0, 90.0));\n        System.out.println(getDifference(-45.0, 125.0));\n        System.out.println(getDifference(-45.0, 145.0));\n        System.out.println(getDifference(-45.0, 125.0));\n        System.out.println(getDifference(-45.0, 145.0));\n        System.out.println(getDifference(29.4803, -88.6381));\n        System.out.println(getDifference(-78.3251, -159.036));\n\n        System.out.println(\"Input in wider range\");\n        System.out.println(getDifference(-70099.74233810938, 29840.67437876723));\n        System.out.println(getDifference(-165313.6666297357, 33693.9894517456));\n        System.out.println(getDifference(1174.8380510598456, -154146.66490124757));\n        System.out.println(getDifference(60175.77306795546, 42213.07192354373));\n    }\n}\n"}
{"id": 88821, "name": "Angle difference between two bearings", "source": "Translate Fortran to Python:       SUBROUTINE BDIFF (B1,B2)\t\n       REAL*8 B1,B2\t\n       COMPLEX*16 CIS,Z1,Z2,Z\t\n       CIS(T) = CMPLX(COSD(T),SIND(T))\t\n        Z1 = CIS(90 - B1)\t\n        Z2 = CIS(90 - B2)\t\n        Z = Z1*CONJG(Z2)\t\n        T = ATAN2D(AIMAG(Z),REAL(Z))\t\n        WRITE (6,10) B1,Z1,B2,Z2,T\t\n   10   FORMAT (2(F14.4,\"(\",F9.6,\",\",F9.6,\")\"),F9.3)\t\n      END SUBROUTINE BDIFF\t\n\n      PROGRAM ORIENTED\n      REAL*8 B(24)\t\n      DATA B/20D0,45D0, -45D0,45D0, -85D0,90D0, -95D0,90D0,\t\n     1      -45D0,125D0, -45D0,145D0, 29.4803D0,-88.6381D0,\n     2      -78.3251D0,              -159.036D0,\n     3   -70099.74233810938D0,      29840.67437876723D0,\n     4  -165313.6666297357D0,       33693.9894517456D0,\n     5     1174.8380510598456D0,  -154146.66490124757D0,\n     6    60175.77306795546D0,      42213.07192354373D0/\n\n      WRITE (6,1) (\"B\",I,\"x\",\"y\", I = 1,2)\t\n    1 FORMAT (28X,\"Bearing calculations, in degrees\"//\n     * 2(A13,I1,\"(\",A9,\",\",A9,\")\"),A9)\t\n\n      DO I = 1,23,2\t\n        CALL BDIFF(B(I),B(I + 1))\n      END DO\n\n      END\n", "target": "from __future__ import print_function\n \ndef getDifference(b1, b2):\n\tr = (b2 - b1) % 360.0\n\t\n\t\n\tif r >= 180.0:\n\t\tr -= 360.0\n\treturn r\n \nif __name__ == \"__main__\":\n\tprint (\"Input in -180 to +180 range\")\n\tprint (getDifference(20.0, 45.0))\n\tprint (getDifference(-45.0, 45.0))\n\tprint (getDifference(-85.0, 90.0))\n\tprint (getDifference(-95.0, 90.0))\n\tprint (getDifference(-45.0, 125.0))\n\tprint (getDifference(-45.0, 145.0))\n\tprint (getDifference(-45.0, 125.0))\n\tprint (getDifference(-45.0, 145.0))\n\tprint (getDifference(29.4803, -88.6381))\n\tprint (getDifference(-78.3251, -159.036))\n \n\tprint (\"Input in wider range\")\n\tprint (getDifference(-70099.74233810938, 29840.67437876723))\n\tprint (getDifference(-165313.6666297357, 33693.9894517456))\n\tprint (getDifference(1174.8380510598456, -154146.66490124757))\n\tprint (getDifference(60175.77306795546, 42213.07192354373))\n"}
{"id": 88822, "name": "Angle difference between two bearings", "source": "Translate Fortran to Python:       SUBROUTINE BDIFF (B1,B2)\t\n       REAL*8 B1,B2\t\n       COMPLEX*16 CIS,Z1,Z2,Z\t\n       CIS(T) = CMPLX(COSD(T),SIND(T))\t\n        Z1 = CIS(90 - B1)\t\n        Z2 = CIS(90 - B2)\t\n        Z = Z1*CONJG(Z2)\t\n        T = ATAN2D(AIMAG(Z),REAL(Z))\t\n        WRITE (6,10) B1,Z1,B2,Z2,T\t\n   10   FORMAT (2(F14.4,\"(\",F9.6,\",\",F9.6,\")\"),F9.3)\t\n      END SUBROUTINE BDIFF\t\n\n      PROGRAM ORIENTED\n      REAL*8 B(24)\t\n      DATA B/20D0,45D0, -45D0,45D0, -85D0,90D0, -95D0,90D0,\t\n     1      -45D0,125D0, -45D0,145D0, 29.4803D0,-88.6381D0,\n     2      -78.3251D0,              -159.036D0,\n     3   -70099.74233810938D0,      29840.67437876723D0,\n     4  -165313.6666297357D0,       33693.9894517456D0,\n     5     1174.8380510598456D0,  -154146.66490124757D0,\n     6    60175.77306795546D0,      42213.07192354373D0/\n\n      WRITE (6,1) (\"B\",I,\"x\",\"y\", I = 1,2)\t\n    1 FORMAT (28X,\"Bearing calculations, in degrees\"//\n     * 2(A13,I1,\"(\",A9,\",\",A9,\")\"),A9)\t\n\n      DO I = 1,23,2\t\n        CALL BDIFF(B(I),B(I + 1))\n      END DO\n\n      END\n", "target": "from __future__ import print_function\n \ndef getDifference(b1, b2):\n\tr = (b2 - b1) % 360.0\n\t\n\t\n\tif r >= 180.0:\n\t\tr -= 360.0\n\treturn r\n \nif __name__ == \"__main__\":\n\tprint (\"Input in -180 to +180 range\")\n\tprint (getDifference(20.0, 45.0))\n\tprint (getDifference(-45.0, 45.0))\n\tprint (getDifference(-85.0, 90.0))\n\tprint (getDifference(-95.0, 90.0))\n\tprint (getDifference(-45.0, 125.0))\n\tprint (getDifference(-45.0, 145.0))\n\tprint (getDifference(-45.0, 125.0))\n\tprint (getDifference(-45.0, 145.0))\n\tprint (getDifference(29.4803, -88.6381))\n\tprint (getDifference(-78.3251, -159.036))\n \n\tprint (\"Input in wider range\")\n\tprint (getDifference(-70099.74233810938, 29840.67437876723))\n\tprint (getDifference(-165313.6666297357, 33693.9894517456))\n\tprint (getDifference(1174.8380510598456, -154146.66490124757))\n\tprint (getDifference(60175.77306795546, 42213.07192354373))\n"}
{"id": 89459, "name": "Named parameters", "source": "Translate Fortran to C#: subroutine a_sub(arg1, arg2, arg3)\n  integer, intent(in) :: arg1, arg2\n  integer, intent(out), optional :: arg3\n  \nend subroutine a_sub\n", "target": "using System;\n\nnamespace NamedParams\n{\n    class Program\n    {\n        static void AddWidget(string parent, float x = 0, float y = 0, string text = \"Default\")\n        {\n            Console.WriteLine(\"parent = {0}, x = {1}, y = {2}, text = {3}\", parent, x, y, text);\n        }\n\n        static void Main(string[] args)\n        {\n            AddWidget(\"root\", 320, 240, \"First\");\n            AddWidget(\"root\", text: \"Origin\");\n            AddWidget(\"root\", 500);\n            AddWidget(\"root\", text: \"Footer\", y: 400);\n        }\n    }\n}\n"}
{"id": 89463, "name": "Named parameters", "source": "Translate Fortran to Java: subroutine a_sub(arg1, arg2, arg3)\n  integer, intent(in) :: arg1, arg2\n  integer, intent(out), optional :: arg3\n  \nend subroutine a_sub\n", "target": "module NamedParams\n    {\n    const Point(Int x, Int y)\n        {\n        Point with(Int? x=Null, Int? y=Null)\n            {\n            return new Point(x ?: this.x, y ?: this.y);\n            }\n        }\n\n    @Inject Console console;\n\n    void run()\n        {\n        Point origin = new Point(0, 0);\n        console.print($\"origin={origin}\");\n        Point moveRight = origin.with(x=5);\n        console.print($\"moveRight(x=5)={moveRight}\");\n        Point moveUp    = moveRight.with(y=3);\n        console.print($\"moveUp(y=3)={moveUp}\");\n        }\n    }\n"}
{"id": 89464, "name": "Named parameters", "source": "Translate Fortran to Python: subroutine a_sub(arg1, arg2, arg3)\n  integer, intent(in) :: arg1, arg2\n  integer, intent(out), optional :: arg3\n  \nend subroutine a_sub\n", "target": "def subtract(x, y):\n    return x - y\n\nsubtract(5, 3)         \nsubtract(y = 3, x = 5) \n"}
{"id": 89696, "name": "Catalan numbers", "source": "Translate Fortran to C#: program main\n  \n  implicit none\n\n  \n  integer                      :: n\n\n  \n  double precision, external   :: catalan_numbers         \n  \n  \n\n  write(*,'(1x,a)')'==============='\n  write(*,'(5x,a,6x,a)')'n','c(n)'\n  write(*,'(1x,a)')'---------------'\n\n  do n = 0, 14\n    write(*,'(1x,i5,i10)') n, int(catalan_numbers(n))\n  enddo\n\n  write(*,'(1x,a)')'==============='\n\n  \nend program main\n\n\n\ndouble precision recursive function catalan_numbers(n) result(value)\n  \n  implicit none\n\n  \n  integer, intent(in)          :: n\n\n  \n\n  if ( n .eq. 0 ) then\n    value = 1\n  else \n    value = ( 2.0d0 * dfloat(2 * n - 1) / dfloat( n + 1 ) ) * catalan_numbers(n-1)\n  endif\n\n  \nend function catalan_numbers\n", "target": "namespace CatalanNumbers\n{\n    \n    \n    \n    public class CatalanNumberGenerator\n    {\n        private static double Factorial(double n)\n        {\n            if (n == 0)\n                return 1;\n\n            return n * Factorial(n - 1);\n        }\n\n        public double FirstOption(double n)\n        {\n            const double topMultiplier = 2;\n            return Factorial(topMultiplier * n) / (Factorial(n + 1) * Factorial(n));\n        }\n\n        public double SecondOption(double n)\n        {\n            if (n == 0)\n            {\n                return 1;\n            }\n            double sum = 0;\n            double i = 0;\n            for (; i <= (n - 1); i++)\n            {\n                sum += SecondOption(i) * SecondOption((n - 1) - i);\n            }\n            return sum;\n        }\n\n        public double ThirdOption(double n)\n        {\n            if (n == 0)\n            {\n                return 1;\n            }\n            return ((2 * (2 * n - 1)) / (n + 1)) * ThirdOption(n - 1);\n        }\n    }\n}\n\n\n\nusing System;\nusing System.Configuration;\n\n\n\n\n\n\n\n\n\n\nnamespace CatalanNumbers\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            CatalanNumberGenerator generator = new CatalanNumberGenerator();\n            int i = 0;\n            DateTime initial;\n            DateTime final;\n            TimeSpan ts;\n\n            try\n            {\n                initial = DateTime.Now;\n                for (; i <= Convert.ToInt32(ConfigurationManager.AppSettings[\"MaxCatalanNumber\"]); i++)\n                {\n                    Console.WriteLine(\"CatalanNumber({0}):{1}\", i, generator.FirstOption(i));\n                }\n                final = DateTime.Now;\n                ts = final - initial;\n                Console.WriteLine(\"It took {0}.{1} to execute\\n\", ts.Seconds, ts.Milliseconds);\n\n                i = 0;\n                initial = DateTime.Now;\n                for (; i <= Convert.ToInt32(ConfigurationManager.AppSettings[\"MaxCatalanNumber\"]); i++)\n                {\n                    Console.WriteLine(\"CatalanNumber({0}):{1}\", i, generator.SecondOption(i));\n                }\n                final = DateTime.Now;\n                ts = final - initial;\n                Console.WriteLine(\"It took {0}.{1} to execute\\n\", ts.Seconds, ts.Milliseconds);   \n\n                i = 0;\n                initial = DateTime.Now;\n                for (; i <= Convert.ToInt32(ConfigurationManager.AppSettings[\"MaxCatalanNumber\"]); i++)\n                {\n                    Console.WriteLine(\"CatalanNumber({0}):{1}\", i, generator.ThirdOption(i));\n                }\n                final = DateTime.Now;\n                ts = final - initial;\n                Console.WriteLine(\"It took {0}.{1} to execute\", ts.Seconds, ts.Milliseconds, ts.TotalMilliseconds);\n                Console.ReadLine();\n            }\n            catch (Exception ex)\n            {\n                Console.WriteLine(\"Stopped at index {0}:\", i);\n                Console.WriteLine(ex.Message);\n                Console.ReadLine();\n            }\n        }\n    }\n}\n"}
{"id": 89699, "name": "Catalan numbers", "source": "Translate Fortran to Java: program main\n  \n  implicit none\n\n  \n  integer                      :: n\n\n  \n  double precision, external   :: catalan_numbers         \n  \n  \n\n  write(*,'(1x,a)')'==============='\n  write(*,'(5x,a,6x,a)')'n','c(n)'\n  write(*,'(1x,a)')'---------------'\n\n  do n = 0, 14\n    write(*,'(1x,i5,i10)') n, int(catalan_numbers(n))\n  enddo\n\n  write(*,'(1x,a)')'==============='\n\n  \nend program main\n\n\n\ndouble precision recursive function catalan_numbers(n) result(value)\n  \n  implicit none\n\n  \n  integer, intent(in)          :: n\n\n  \n\n  if ( n .eq. 0 ) then\n    value = 1\n  else \n    value = ( 2.0d0 * dfloat(2 * n - 1) / dfloat( n + 1 ) ) * catalan_numbers(n-1)\n  endif\n\n  \nend function catalan_numbers\n", "target": "import java.math.BigInteger;\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\n\npublic class CatlanNumbers {\n\n    public static void main(String[] args) {\n        Catlan f1 = new Catlan1();\n        Catlan f2 = new Catlan2();\n        Catlan f3 = new Catlan3();\n        System.out.printf(\"           Formula 1     Formula 2     Formula 3%n\");\n        for ( int n = 0 ; n <= 15 ; n++ ) {\n             System.out.printf(\"C(%2d) =\u00a0%,12d \u00a0%,12d \u00a0%,12d%n\", n, f1.catlin(n), f2.catlin(n), f3.catlin(n));\n        }\n    }\n    \n    private static interface Catlan {\n        public BigInteger catlin(long n);\n    }\n    \n    private static class Catlan1 implements Catlan {\n\n        \n        @Override\n        public BigInteger catlin(long n) {\n            List<Long> numerator = new ArrayList<>();\n            for ( long k = n+2 ; k <= 2*n ; k++ ) {\n                numerator.add(k);\n            }\n            \n            List<Long> denominator = new ArrayList<>();\n            for ( long k = 2 ; k <= n ; k++ ) {\n                denominator.add(k);\n            }\n            \n            for ( int i = numerator.size()-1 ; i >= 0  ; i-- ) {\n                for ( int j = denominator.size()-1 ; j >= 0  ; j-- ) {\n                    if ( denominator.get(j) == 1 ) {\n                        continue;\n                    }\n                    if ( numerator.get(i) % denominator.get(j) == 0 ) {\n                        long val = numerator.get(i) / denominator.get(j);\n                        numerator.set(i, val);\n                        denominator.remove(denominator.get(j));\n                        if ( val == 1 ) {\n                            break;\n                        }\n                    }\n                }\n            }\n\n            BigInteger catlin = BigInteger.ONE;\n            for ( int i = 0 ; i < numerator.size() ; i++ ) {\n                catlin = catlin.multiply(BigInteger.valueOf(numerator.get(i)));\n            }\n            for ( int i = 0 ; i < denominator.size() ; i++ ) {\n                catlin = catlin.divide(BigInteger.valueOf(denominator.get(i)));\n            }\n            return catlin;\n        }        \n    }\n    \n    private static class Catlan2 implements Catlan {\n\n        private static Map<Long,BigInteger> CACHE = new HashMap<>();\n        static {\n            CACHE.put(0L, BigInteger.ONE);\n        }\n        \n        \n        @Override\n        public BigInteger catlin(long n) {\n            if ( CACHE.containsKey(n) ) {\n                return CACHE.get(n);\n            }\n            BigInteger catlin = BigInteger.ZERO;\n            n--;\n            for ( int i = 0 ; i <= n ; i++ ) {\n                \n                catlin = catlin.add(catlin(i).multiply(catlin(n-i)));\n            }\n            CACHE.put(n+1, catlin);\n            return catlin;\n        }\n    }\n    \n    private static class Catlan3 implements Catlan {\n\n        private static Map<Long,BigInteger> CACHE = new HashMap<>();\n        static {\n            CACHE.put(0L, BigInteger.ONE);\n        }\n        \n        \n        @Override\n        public BigInteger catlin(long n) {\n            if ( CACHE.containsKey(n) ) {\n                return CACHE.get(n);\n            }\n            BigInteger catlin = BigInteger.valueOf(2).multiply(BigInteger.valueOf(2*n-1)).multiply(catlin(n-1)).divide(BigInteger.valueOf(n+1));\n            CACHE.put(n, catlin);\n            return catlin;\n        }\n    }\n\n}\n"}
{"id": 89700, "name": "Catalan numbers", "source": "Translate Fortran to Python: program main\n  \n  implicit none\n\n  \n  integer                      :: n\n\n  \n  double precision, external   :: catalan_numbers         \n  \n  \n\n  write(*,'(1x,a)')'==============='\n  write(*,'(5x,a,6x,a)')'n','c(n)'\n  write(*,'(1x,a)')'---------------'\n\n  do n = 0, 14\n    write(*,'(1x,i5,i10)') n, int(catalan_numbers(n))\n  enddo\n\n  write(*,'(1x,a)')'==============='\n\n  \nend program main\n\n\n\ndouble precision recursive function catalan_numbers(n) result(value)\n  \n  implicit none\n\n  \n  integer, intent(in)          :: n\n\n  \n\n  if ( n .eq. 0 ) then\n    value = 1\n  else \n    value = ( 2.0d0 * dfloat(2 * n - 1) / dfloat( n + 1 ) ) * catalan_numbers(n-1)\n  endif\n\n  \nend function catalan_numbers\n", "target": "from math import factorial\nimport functools\n\n\ndef memoize(func):\n    cache = {}\n\n    def memoized(key):\n        \n        if key not in cache:\n            cache[key] = func(key)\n        return cache[key]\n    return functools.update_wrapper(memoized, func)\n\n\n@memoize\ndef fact(n):\n    return factorial(n)\n\n\ndef cat_direct(n):\n    return fact(2 * n) // fact(n + 1) // fact(n)\n\n\n@memoize\ndef catR1(n):\n    return 1 if n == 0 else (\n        sum(catR1(i) * catR1(n - 1 - i) for i in range(n))\n    )\n\n\n@memoize\ndef catR2(n):\n    return 1 if n == 0 else (\n        ((4 * n - 2) * catR2(n - 1)) // (n + 1)\n    )\n\n\nif __name__ == '__main__':\n    def pr(results):\n        fmt = '%-10s %-10s %-10s'\n        print((fmt % tuple(c.__name__ for c in defs)).upper())\n        print(fmt % (('=' * 10,) * 3))\n        for r in zip(*results):\n            print(fmt % r)\n\n    defs = (cat_direct, catR1, catR2)\n    results = [tuple(c(i) for i in range(15)) for c in defs]\n    pr(results)\n"}
{"id": 89972, "name": "Reverse a string", "source": "Translate Fortran to C#: PROGRAM Example\n\n  CHARACTER(80) :: str = \"This is a string\"\n  CHARACTER :: temp\n  INTEGER :: i, length\n\n  WRITE (*,*) str\n  length = LEN_TRIM(str) \n  DO i = 1, length/2\n     temp = str(i:i)\n     str(i:i) = str(length+1-i:length+1-i)\n     str(length+1-i:length+1-i) = temp\n  END DO\n  WRITE(*,*) str\n\nEND PROGRAM Example\n", "target": "using System;\n\nnamespace System\n{\n\textension String\n\t{\n\t\tpublic void Reverse()\n\t\t{\n\t\t\tint i = 0;\n\t\t\tint j = mLength - 1;\n\t\t\twhile (i < j)\n\t\t\t{\n\t\t\t\tSwap!(Ptr[i++], Ptr[j--]);\n\t\t\t}\n\t\t}\n\t}\n}\n\nnamespace StringReverse\n{\n\tclass Program\n\t{\n\t\tstatic void Main()\n\t\t{\n\t\t\tString s = scope .(\"abcdef\");\n\t\t\ts.Reverse();\n\t\t\tConsole.WriteLine(s);\n\t\t}\n\t}\n}\n"}
{"id": 89975, "name": "Reverse a string", "source": "Translate Fortran to Java: PROGRAM Example\n\n  CHARACTER(80) :: str = \"This is a string\"\n  CHARACTER :: temp\n  INTEGER :: i, length\n\n  WRITE (*,*) str\n  length = LEN_TRIM(str) \n  DO i = 1, length/2\n     temp = str(i:i)\n     str(i:i) = str(length+1-i:length+1-i)\n     str(length+1-i:length+1-i) = temp\n  END DO\n  WRITE(*,*) str\n\nEND PROGRAM Example\n", "target": "String str = 'Hello World!';\nstr = str.reverse();\nsystem.debug(str);\n"}
{"id": 89976, "name": "Reverse a string", "source": "Translate Fortran to Python: PROGRAM Example\n\n  CHARACTER(80) :: str = \"This is a string\"\n  CHARACTER :: temp\n  INTEGER :: i, length\n\n  WRITE (*,*) str\n  length = LEN_TRIM(str) \n  DO i = 1, length/2\n     temp = str(i:i)\n     str(i:i) = str(length+1-i:length+1-i)\n     str(length+1-i:length+1-i) = temp\n  END DO\n  WRITE(*,*) str\n\nEND PROGRAM Example\n", "target": "input()[::-1]\n"}
{"id": 90246, "name": "Barnsley fern", "source": "Translate Fortran to C#: \n\nprogram BarnsleyFern\nimplicit none\n\ndouble precision :: p(4), a(4), b(4), c(4), d(4), e(4), f(4), trx, try, prob\ninteger :: itermax, i\n\n\n\n\np(1) = 0.01; p(2) = 0.85; p(3) = 0.07; p(4) = 0.07\n\n\na(1) =  0.00; a(2) =  0.85; a(3) =  0.20; a(4) = -0.15\nb(1) =  0.00; b(2) =  0.04; b(3) = -0.26; b(4) =  0.28\nc(1) =  0.00; c(2) = -0.04; c(3) =  0.23; c(4) =  0.26\nd(1) =  0.16; d(2) =  0.85; d(3) =  0.22; d(4) =  0.24\ne(1) =  0.00; e(2) =  0.00; e(3) =  0.00; e(4) =  0.00\nf(1) =  0.00; f(2) =  1.60; f(3) =  1.60; f(4) =  0.44\n\nitermax = 100000\n\ntrx = 0.0D0\ntry = 0.0D0\n\nopen(1, file=\"plot.dat\")\nwrite(1,*) \"#X            #Y\"\nwrite(1,'(2F10.5)') trx, try\n\ndo i = 1, itermax\n  call random_number(prob)\n  if (prob < p(1)) then\n    trx = a(1) * trx + b(1) * try + e(1)\n    try = c(1) * trx + d(1) * try + f(1)\n  else if(prob < (p(1) + p(2))) then\n    trx = a(2) * trx + b(2) * try + e(2)\n    try = c(2) * trx + d(2) * try + f(2)\n  else if ( prob < (p(1) + p(2) + p(3))) then\n    trx = a(3) * trx + b(3) * try + e(3)\n    try = c(3) * trx + d(3) * try + f(3)\n  else\n    trx = a(4) * trx + b(4) * try + e(4)\n    try = c(4) * trx + d(4) * try + f(4)\n  end if\n  write(1,'(2F10.5)') trx, try\nend do\nclose(1)\nend program BarnsleyFern\n", "target": "using System;\nusing System.Diagnostics;\nusing System.Drawing;\n\nnamespace RosettaBarnsleyFern\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            const int w = 600;\n            const int h = 600;\n            var bm = new Bitmap(w, h);\n            var r = new Random();\n            double x = 0;\n            double y = 0;\n            for (int count = 0; count < 100000; count++)\n            {\n                bm.SetPixel((int)(300 + 58 * x), (int)(58 * y), Color.ForestGreen);\n                int roll = r.Next(100);\n                double xp = x;\n                if (roll < 1)\n                {\n                    x = 0;\n                    y = 0.16 * y;\n                } else if (roll < 86)\n                {\n                    x = 0.85 * x + 0.04 * y;\n                    y = -0.04 * xp + 0.85 * y + 1.6;\n                } else if (roll < 93)\n                {\n                    x = 0.2 * x - 0.26 * y;\n                    y = 0.23 * xp + 0.22 * y + 1.6;\n                } else\n                {\n                    x = -0.15 * x + 0.28 * y;\n                    y = 0.26 * xp + 0.24 * y + 0.44;\n                }\n            }\n            const string filename = \"Fern.png\";\n            bm.Save(filename);\n            Process.Start(filename);\n        }\n    }\n}\n"}
{"id": 90247, "name": "Barnsley fern", "source": "Translate Fortran to C#: \n\nprogram BarnsleyFern\nimplicit none\n\ndouble precision :: p(4), a(4), b(4), c(4), d(4), e(4), f(4), trx, try, prob\ninteger :: itermax, i\n\n\n\n\np(1) = 0.01; p(2) = 0.85; p(3) = 0.07; p(4) = 0.07\n\n\na(1) =  0.00; a(2) =  0.85; a(3) =  0.20; a(4) = -0.15\nb(1) =  0.00; b(2) =  0.04; b(3) = -0.26; b(4) =  0.28\nc(1) =  0.00; c(2) = -0.04; c(3) =  0.23; c(4) =  0.26\nd(1) =  0.16; d(2) =  0.85; d(3) =  0.22; d(4) =  0.24\ne(1) =  0.00; e(2) =  0.00; e(3) =  0.00; e(4) =  0.00\nf(1) =  0.00; f(2) =  1.60; f(3) =  1.60; f(4) =  0.44\n\nitermax = 100000\n\ntrx = 0.0D0\ntry = 0.0D0\n\nopen(1, file=\"plot.dat\")\nwrite(1,*) \"#X            #Y\"\nwrite(1,'(2F10.5)') trx, try\n\ndo i = 1, itermax\n  call random_number(prob)\n  if (prob < p(1)) then\n    trx = a(1) * trx + b(1) * try + e(1)\n    try = c(1) * trx + d(1) * try + f(1)\n  else if(prob < (p(1) + p(2))) then\n    trx = a(2) * trx + b(2) * try + e(2)\n    try = c(2) * trx + d(2) * try + f(2)\n  else if ( prob < (p(1) + p(2) + p(3))) then\n    trx = a(3) * trx + b(3) * try + e(3)\n    try = c(3) * trx + d(3) * try + f(3)\n  else\n    trx = a(4) * trx + b(4) * try + e(4)\n    try = c(4) * trx + d(4) * try + f(4)\n  end if\n  write(1,'(2F10.5)') trx, try\nend do\nclose(1)\nend program BarnsleyFern\n", "target": "using System;\nusing System.Diagnostics;\nusing System.Drawing;\n\nnamespace RosettaBarnsleyFern\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            const int w = 600;\n            const int h = 600;\n            var bm = new Bitmap(w, h);\n            var r = new Random();\n            double x = 0;\n            double y = 0;\n            for (int count = 0; count < 100000; count++)\n            {\n                bm.SetPixel((int)(300 + 58 * x), (int)(58 * y), Color.ForestGreen);\n                int roll = r.Next(100);\n                double xp = x;\n                if (roll < 1)\n                {\n                    x = 0;\n                    y = 0.16 * y;\n                } else if (roll < 86)\n                {\n                    x = 0.85 * x + 0.04 * y;\n                    y = -0.04 * xp + 0.85 * y + 1.6;\n                } else if (roll < 93)\n                {\n                    x = 0.2 * x - 0.26 * y;\n                    y = 0.23 * xp + 0.22 * y + 1.6;\n                } else\n                {\n                    x = -0.15 * x + 0.28 * y;\n                    y = 0.26 * xp + 0.24 * y + 0.44;\n                }\n            }\n            const string filename = \"Fern.png\";\n            bm.Save(filename);\n            Process.Start(filename);\n        }\n    }\n}\n"}
{"id": 90253, "name": "Barnsley fern", "source": "Translate Fortran to Java: \n\nprogram BarnsleyFern\nimplicit none\n\ndouble precision :: p(4), a(4), b(4), c(4), d(4), e(4), f(4), trx, try, prob\ninteger :: itermax, i\n\n\n\n\np(1) = 0.01; p(2) = 0.85; p(3) = 0.07; p(4) = 0.07\n\n\na(1) =  0.00; a(2) =  0.85; a(3) =  0.20; a(4) = -0.15\nb(1) =  0.00; b(2) =  0.04; b(3) = -0.26; b(4) =  0.28\nc(1) =  0.00; c(2) = -0.04; c(3) =  0.23; c(4) =  0.26\nd(1) =  0.16; d(2) =  0.85; d(3) =  0.22; d(4) =  0.24\ne(1) =  0.00; e(2) =  0.00; e(3) =  0.00; e(4) =  0.00\nf(1) =  0.00; f(2) =  1.60; f(3) =  1.60; f(4) =  0.44\n\nitermax = 100000\n\ntrx = 0.0D0\ntry = 0.0D0\n\nopen(1, file=\"plot.dat\")\nwrite(1,*) \"#X            #Y\"\nwrite(1,'(2F10.5)') trx, try\n\ndo i = 1, itermax\n  call random_number(prob)\n  if (prob < p(1)) then\n    trx = a(1) * trx + b(1) * try + e(1)\n    try = c(1) * trx + d(1) * try + f(1)\n  else if(prob < (p(1) + p(2))) then\n    trx = a(2) * trx + b(2) * try + e(2)\n    try = c(2) * trx + d(2) * try + f(2)\n  else if ( prob < (p(1) + p(2) + p(3))) then\n    trx = a(3) * trx + b(3) * try + e(3)\n    try = c(3) * trx + d(3) * try + f(3)\n  else\n    trx = a(4) * trx + b(4) * try + e(4)\n    try = c(4) * trx + d(4) * try + f(4)\n  end if\n  write(1,'(2F10.5)') trx, try\nend do\nclose(1)\nend program BarnsleyFern\n", "target": "import java.awt.*;\nimport java.awt.image.BufferedImage;\nimport javax.swing.*;\n\npublic class BarnsleyFern extends JPanel {\n\n    BufferedImage img;\n\n    public BarnsleyFern() {\n        final int dim = 640;\n        setPreferredSize(new Dimension(dim, dim));\n        setBackground(Color.white);\n        img = new BufferedImage(dim, dim, BufferedImage.TYPE_INT_ARGB);\n        createFern(dim, dim);\n    }\n\n    void createFern(int w, int h) {\n        double x = 0;\n        double y = 0;\n\n        for (int i = 0; i < 200_000; i++) {\n            double tmpx, tmpy;\n            double r = Math.random();\n\n            if (r <= 0.01) {\n                tmpx = 0;\n                tmpy = 0.16 * y;\n            } else if (r <= 0.08) {\n                tmpx = 0.2 * x - 0.26 * y;\n                tmpy = 0.23 * x + 0.22 * y + 1.6;\n            } else if (r <= 0.15) {\n                tmpx = -0.15 * x + 0.28 * y;\n                tmpy = 0.26 * x + 0.24 * y + 0.44;\n            } else {\n                tmpx = 0.85 * x + 0.04 * y;\n                tmpy = -0.04 * x + 0.85 * y + 1.6;\n            }\n            x = tmpx;\n            y = tmpy;\n\n            img.setRGB((int) Math.round(w / 2 + x * w / 11),\n                    (int) Math.round(h - y * h / 11), 0xFF32CD32);\n        }\n    }\n\n    @Override\n    public void paintComponent(Graphics gg) {\n        super.paintComponent(gg);\n        Graphics2D g = (Graphics2D) gg;\n        g.setRenderingHint(RenderingHints.KEY_ANTIALIASING,\n                RenderingHints.VALUE_ANTIALIAS_ON);\n\n        g.drawImage(img, 0, 0, null);\n    }\n\n    public static void main(String[] args) {\n        SwingUtilities.invokeLater(() -> {\n            JFrame f = new JFrame();\n            f.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n            f.setTitle(\"Barnsley Fern\");\n            f.setResizable(false);\n            f.add(new BarnsleyFern(), BorderLayout.CENTER);\n            f.pack();\n            f.setLocationRelativeTo(null);\n            f.setVisible(true);\n        });\n    }\n}\n"}
{"id": 90254, "name": "Barnsley fern", "source": "Translate Fortran to Java: \n\nprogram BarnsleyFern\nimplicit none\n\ndouble precision :: p(4), a(4), b(4), c(4), d(4), e(4), f(4), trx, try, prob\ninteger :: itermax, i\n\n\n\n\np(1) = 0.01; p(2) = 0.85; p(3) = 0.07; p(4) = 0.07\n\n\na(1) =  0.00; a(2) =  0.85; a(3) =  0.20; a(4) = -0.15\nb(1) =  0.00; b(2) =  0.04; b(3) = -0.26; b(4) =  0.28\nc(1) =  0.00; c(2) = -0.04; c(3) =  0.23; c(4) =  0.26\nd(1) =  0.16; d(2) =  0.85; d(3) =  0.22; d(4) =  0.24\ne(1) =  0.00; e(2) =  0.00; e(3) =  0.00; e(4) =  0.00\nf(1) =  0.00; f(2) =  1.60; f(3) =  1.60; f(4) =  0.44\n\nitermax = 100000\n\ntrx = 0.0D0\ntry = 0.0D0\n\nopen(1, file=\"plot.dat\")\nwrite(1,*) \"#X            #Y\"\nwrite(1,'(2F10.5)') trx, try\n\ndo i = 1, itermax\n  call random_number(prob)\n  if (prob < p(1)) then\n    trx = a(1) * trx + b(1) * try + e(1)\n    try = c(1) * trx + d(1) * try + f(1)\n  else if(prob < (p(1) + p(2))) then\n    trx = a(2) * trx + b(2) * try + e(2)\n    try = c(2) * trx + d(2) * try + f(2)\n  else if ( prob < (p(1) + p(2) + p(3))) then\n    trx = a(3) * trx + b(3) * try + e(3)\n    try = c(3) * trx + d(3) * try + f(3)\n  else\n    trx = a(4) * trx + b(4) * try + e(4)\n    try = c(4) * trx + d(4) * try + f(4)\n  end if\n  write(1,'(2F10.5)') trx, try\nend do\nclose(1)\nend program BarnsleyFern\n", "target": "import java.awt.*;\nimport java.awt.image.BufferedImage;\nimport javax.swing.*;\n\npublic class BarnsleyFern extends JPanel {\n\n    BufferedImage img;\n\n    public BarnsleyFern() {\n        final int dim = 640;\n        setPreferredSize(new Dimension(dim, dim));\n        setBackground(Color.white);\n        img = new BufferedImage(dim, dim, BufferedImage.TYPE_INT_ARGB);\n        createFern(dim, dim);\n    }\n\n    void createFern(int w, int h) {\n        double x = 0;\n        double y = 0;\n\n        for (int i = 0; i < 200_000; i++) {\n            double tmpx, tmpy;\n            double r = Math.random();\n\n            if (r <= 0.01) {\n                tmpx = 0;\n                tmpy = 0.16 * y;\n            } else if (r <= 0.08) {\n                tmpx = 0.2 * x - 0.26 * y;\n                tmpy = 0.23 * x + 0.22 * y + 1.6;\n            } else if (r <= 0.15) {\n                tmpx = -0.15 * x + 0.28 * y;\n                tmpy = 0.26 * x + 0.24 * y + 0.44;\n            } else {\n                tmpx = 0.85 * x + 0.04 * y;\n                tmpy = -0.04 * x + 0.85 * y + 1.6;\n            }\n            x = tmpx;\n            y = tmpy;\n\n            img.setRGB((int) Math.round(w / 2 + x * w / 11),\n                    (int) Math.round(h - y * h / 11), 0xFF32CD32);\n        }\n    }\n\n    @Override\n    public void paintComponent(Graphics gg) {\n        super.paintComponent(gg);\n        Graphics2D g = (Graphics2D) gg;\n        g.setRenderingHint(RenderingHints.KEY_ANTIALIASING,\n                RenderingHints.VALUE_ANTIALIAS_ON);\n\n        g.drawImage(img, 0, 0, null);\n    }\n\n    public static void main(String[] args) {\n        SwingUtilities.invokeLater(() -> {\n            JFrame f = new JFrame();\n            f.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n            f.setTitle(\"Barnsley Fern\");\n            f.setResizable(false);\n            f.add(new BarnsleyFern(), BorderLayout.CENTER);\n            f.pack();\n            f.setLocationRelativeTo(null);\n            f.setVisible(true);\n        });\n    }\n}\n"}
{"id": 90255, "name": "Barnsley fern", "source": "Translate Fortran to Python: \n\nprogram BarnsleyFern\nimplicit none\n\ndouble precision :: p(4), a(4), b(4), c(4), d(4), e(4), f(4), trx, try, prob\ninteger :: itermax, i\n\n\n\n\np(1) = 0.01; p(2) = 0.85; p(3) = 0.07; p(4) = 0.07\n\n\na(1) =  0.00; a(2) =  0.85; a(3) =  0.20; a(4) = -0.15\nb(1) =  0.00; b(2) =  0.04; b(3) = -0.26; b(4) =  0.28\nc(1) =  0.00; c(2) = -0.04; c(3) =  0.23; c(4) =  0.26\nd(1) =  0.16; d(2) =  0.85; d(3) =  0.22; d(4) =  0.24\ne(1) =  0.00; e(2) =  0.00; e(3) =  0.00; e(4) =  0.00\nf(1) =  0.00; f(2) =  1.60; f(3) =  1.60; f(4) =  0.44\n\nitermax = 100000\n\ntrx = 0.0D0\ntry = 0.0D0\n\nopen(1, file=\"plot.dat\")\nwrite(1,*) \"#X            #Y\"\nwrite(1,'(2F10.5)') trx, try\n\ndo i = 1, itermax\n  call random_number(prob)\n  if (prob < p(1)) then\n    trx = a(1) * trx + b(1) * try + e(1)\n    try = c(1) * trx + d(1) * try + f(1)\n  else if(prob < (p(1) + p(2))) then\n    trx = a(2) * trx + b(2) * try + e(2)\n    try = c(2) * trx + d(2) * try + f(2)\n  else if ( prob < (p(1) + p(2) + p(3))) then\n    trx = a(3) * trx + b(3) * try + e(3)\n    try = c(3) * trx + d(3) * try + f(3)\n  else\n    trx = a(4) * trx + b(4) * try + e(4)\n    try = c(4) * trx + d(4) * try + f(4)\n  end if\n  write(1,'(2F10.5)') trx, try\nend do\nclose(1)\nend program BarnsleyFern\n", "target": "size(640, 640)\nbackground(0)\n\nx = 0\ny = 0\n\nfor _ in range(100000):\n    xt = 0\n    yt = 0\n    r = random(100)\n\n    if r <= 1:\n        xt = 0\n        yt = 0.16 * y\n    elif r <= 8:\n        xt = 0.20 * x - 0.26 * y\n        yt = 0.23 * x + 0.22 * y + 1.60\n    elif r <= 15:\n        xt = -0.15 * x + 0.28 * y\n        yt = +0.26 * x + 0.24 * y + 0.44\n    else:\n        xt = +0.85 * x + 0.04 * y\n        yt = -0.04 * x + 0.85 * y + 1.60\nsize(640, 640)\nbackground(0)\n\nx = 0\ny = 0\n\nfor _ in range(100000):\n    xt = 0\n    yt = 0\n    r = random(100)\n    \n    if r <= 1:\n        xt = 0\n        yt = 0.16*y\n    elif r <= 8:\n        xt = 0.20*x - 0.26*y\n        yt = 0.23*x + 0.22*y + 1.60\n    elif r <= 15:\n        xt = -0.15*x + 0.28*y\n        yt =    0.26*x + 0.24*y + 0.44\n    else:\n        xt =    0.85*x + 0.04*y\n        yt = -0.04*x + 0.85*y + 1.60\n    \n    x = xt\n    y = yt\n\n    m = round(width/2 + 60*x)\n    n = height-round(60*y)\n\n    set(m, n, \"\n    x = xt\n    y = yt\n\n    m = round(width / 2 + 60 * x)\n    n = height - round(60 * y)\n\n    set(m, n, \"\n"}
{"id": 90256, "name": "Barnsley fern", "source": "Translate Fortran to Python: \n\nprogram BarnsleyFern\nimplicit none\n\ndouble precision :: p(4), a(4), b(4), c(4), d(4), e(4), f(4), trx, try, prob\ninteger :: itermax, i\n\n\n\n\np(1) = 0.01; p(2) = 0.85; p(3) = 0.07; p(4) = 0.07\n\n\na(1) =  0.00; a(2) =  0.85; a(3) =  0.20; a(4) = -0.15\nb(1) =  0.00; b(2) =  0.04; b(3) = -0.26; b(4) =  0.28\nc(1) =  0.00; c(2) = -0.04; c(3) =  0.23; c(4) =  0.26\nd(1) =  0.16; d(2) =  0.85; d(3) =  0.22; d(4) =  0.24\ne(1) =  0.00; e(2) =  0.00; e(3) =  0.00; e(4) =  0.00\nf(1) =  0.00; f(2) =  1.60; f(3) =  1.60; f(4) =  0.44\n\nitermax = 100000\n\ntrx = 0.0D0\ntry = 0.0D0\n\nopen(1, file=\"plot.dat\")\nwrite(1,*) \"#X            #Y\"\nwrite(1,'(2F10.5)') trx, try\n\ndo i = 1, itermax\n  call random_number(prob)\n  if (prob < p(1)) then\n    trx = a(1) * trx + b(1) * try + e(1)\n    try = c(1) * trx + d(1) * try + f(1)\n  else if(prob < (p(1) + p(2))) then\n    trx = a(2) * trx + b(2) * try + e(2)\n    try = c(2) * trx + d(2) * try + f(2)\n  else if ( prob < (p(1) + p(2) + p(3))) then\n    trx = a(3) * trx + b(3) * try + e(3)\n    try = c(3) * trx + d(3) * try + f(3)\n  else\n    trx = a(4) * trx + b(4) * try + e(4)\n    try = c(4) * trx + d(4) * try + f(4)\n  end if\n  write(1,'(2F10.5)') trx, try\nend do\nclose(1)\nend program BarnsleyFern\n", "target": "size(640, 640)\nbackground(0)\n\nx = 0\ny = 0\n\nfor _ in range(100000):\n    xt = 0\n    yt = 0\n    r = random(100)\n\n    if r <= 1:\n        xt = 0\n        yt = 0.16 * y\n    elif r <= 8:\n        xt = 0.20 * x - 0.26 * y\n        yt = 0.23 * x + 0.22 * y + 1.60\n    elif r <= 15:\n        xt = -0.15 * x + 0.28 * y\n        yt = +0.26 * x + 0.24 * y + 0.44\n    else:\n        xt = +0.85 * x + 0.04 * y\n        yt = -0.04 * x + 0.85 * y + 1.60\nsize(640, 640)\nbackground(0)\n\nx = 0\ny = 0\n\nfor _ in range(100000):\n    xt = 0\n    yt = 0\n    r = random(100)\n    \n    if r <= 1:\n        xt = 0\n        yt = 0.16*y\n    elif r <= 8:\n        xt = 0.20*x - 0.26*y\n        yt = 0.23*x + 0.22*y + 1.60\n    elif r <= 15:\n        xt = -0.15*x + 0.28*y\n        yt =    0.26*x + 0.24*y + 0.44\n    else:\n        xt =    0.85*x + 0.04*y\n        yt = -0.04*x + 0.85*y + 1.60\n    \n    x = xt\n    y = yt\n\n    m = round(width/2 + 60*x)\n    n = height-round(60*y)\n\n    set(m, n, \"\n    x = xt\n    y = yt\n\n    m = round(width / 2 + 60 * x)\n    n = height - round(60 * y)\n\n    set(m, n, \"\n"}
{"id": 90634, "name": "Command-line arguments", "source": "Translate Fortran to C#: program command_line_arguments\n\n  implicit none\n  integer, parameter :: len_max = 256\n  integer :: i , nargs\n  character (len_max) :: arg\n  \n  nargs = command_argument_count()\n  \n  do i = 0, nargs\n    call get_command_argument (i, arg)\n    \n    write (*, '(a)') trim (arg)\n  end do\n\nend program command_line_arguments\n", "target": "using System;\n\nnamespace RosettaCode {\n    class Program {\n        static void Main(string[] args) {\n            for (int i = 0; i < args.Length; i++)\n                Console.WriteLine(String.Format(\"Argument {0} is '{1}'\", i, args[i]));\n        }\n    }\n}\n"}
{"id": 90635, "name": "Command-line arguments", "source": "Translate Fortran to C#: program command_line_arguments\n\n  implicit none\n  integer, parameter :: len_max = 256\n  integer :: i , nargs\n  character (len_max) :: arg\n  \n  nargs = command_argument_count()\n  \n  do i = 0, nargs\n    call get_command_argument (i, arg)\n    \n    write (*, '(a)') trim (arg)\n  end do\n\nend program command_line_arguments\n", "target": "using System;\n\nnamespace RosettaCode {\n    class Program {\n        static void Main(string[] args) {\n            for (int i = 0; i < args.Length; i++)\n                Console.WriteLine(String.Format(\"Argument {0} is '{1}'\", i, args[i]));\n        }\n    }\n}\n"}
{"id": 90640, "name": "Command-line arguments", "source": "Translate Fortran to Java: program command_line_arguments\n\n  implicit none\n  integer, parameter :: len_max = 256\n  integer :: i , nargs\n  character (len_max) :: arg\n  \n  nargs = command_argument_count()\n  \n  do i = 0, nargs\n    call get_command_argument (i, arg)\n    \n    write (*, '(a)') trim (arg)\n  end do\n\nend program command_line_arguments\n", "target": "public class Arguments {\n  public static void main(String[] args) {\n     System.out.println(\"There are \" + args.length + \" arguments given.\");\n     for(int i = 0; i < args.length; i++) \n        System.out.println(\"The argument #\" + (i+1) + \" is \" + args[i] + \" and is at index \" + i);\n  }\n}\n"}
{"id": 90641, "name": "Command-line arguments", "source": "Translate Fortran to Java: program command_line_arguments\n\n  implicit none\n  integer, parameter :: len_max = 256\n  integer :: i , nargs\n  character (len_max) :: arg\n  \n  nargs = command_argument_count()\n  \n  do i = 0, nargs\n    call get_command_argument (i, arg)\n    \n    write (*, '(a)') trim (arg)\n  end do\n\nend program command_line_arguments\n", "target": "public class Arguments {\n  public static void main(String[] args) {\n     System.out.println(\"There are \" + args.length + \" arguments given.\");\n     for(int i = 0; i < args.length; i++) \n        System.out.println(\"The argument #\" + (i+1) + \" is \" + args[i] + \" and is at index \" + i);\n  }\n}\n"}
{"id": 90642, "name": "Command-line arguments", "source": "Translate Fortran to Python: program command_line_arguments\n\n  implicit none\n  integer, parameter :: len_max = 256\n  integer :: i , nargs\n  character (len_max) :: arg\n  \n  nargs = command_argument_count()\n  \n  do i = 0, nargs\n    call get_command_argument (i, arg)\n    \n    write (*, '(a)') trim (arg)\n  end do\n\nend program command_line_arguments\n", "target": "import sys\nprogram_name = sys.argv[0]\narguments = sys.argv[1:]\ncount = len(arguments)\n"}
{"id": 90643, "name": "Command-line arguments", "source": "Translate Fortran to Python: program command_line_arguments\n\n  implicit none\n  integer, parameter :: len_max = 256\n  integer :: i , nargs\n  character (len_max) :: arg\n  \n  nargs = command_argument_count()\n  \n  do i = 0, nargs\n    call get_command_argument (i, arg)\n    \n    write (*, '(a)') trim (arg)\n  end do\n\nend program command_line_arguments\n", "target": "import sys\nprogram_name = sys.argv[0]\narguments = sys.argv[1:]\ncount = len(arguments)\n"}
{"id": 91246, "name": "Tokenize a string", "source": "Translate Fortran to C#: PROGRAM Example\n\n  CHARACTER(23) :: str = \"Hello,How,Are,You,Today\"\n  CHARACTER(5) :: word(5)\n  INTEGER :: pos1 = 1, pos2, n = 0, i\n\n  DO\n    pos2 = INDEX(str(pos1:), \",\")\n    IF (pos2 == 0) THEN\n       n = n + 1\n       word(n) = str(pos1:)\n       EXIT\n    END IF\n    n = n + 1\n    word(n) = str(pos1:pos1+pos2-2)\n    pos1 = pos2+pos1\n END DO\n\n DO i = 1, n\n   WRITE(*,\"(2A)\", ADVANCE=\"NO\") TRIM(word(i)), \".\"\n END DO\n \nEND PROGRAM Example\n", "target": "string str = \"Hello,How,Are,You,Today\"; \n\n\nstring[] strings = str.Split(',');\nConsole.WriteLine(String.Join(\".\", strings));\n"}
{"id": 91249, "name": "Tokenize a string", "source": "Translate Fortran to Java: PROGRAM Example\n\n  CHARACTER(23) :: str = \"Hello,How,Are,You,Today\"\n  CHARACTER(5) :: word(5)\n  INTEGER :: pos1 = 1, pos2, n = 0, i\n\n  DO\n    pos2 = INDEX(str(pos1:), \",\")\n    IF (pos2 == 0) THEN\n       n = n + 1\n       word(n) = str(pos1:)\n       EXIT\n    END IF\n    n = n + 1\n    word(n) = str(pos1:pos1+pos2-2)\n    pos1 = pos2+pos1\n END DO\n\n DO i = 1, n\n   WRITE(*,\"(2A)\", ADVANCE=\"NO\") TRIM(word(i)), \".\"\n END DO\n \nEND PROGRAM Example\n", "target": "String toTokenize = \"Hello,How,Are,You,Today\";\nSystem.out.println(String.join(\".\", toTokenize.split(\",\")));\n"}
{"id": 91250, "name": "Tokenize a string", "source": "Translate Fortran to Python: PROGRAM Example\n\n  CHARACTER(23) :: str = \"Hello,How,Are,You,Today\"\n  CHARACTER(5) :: word(5)\n  INTEGER :: pos1 = 1, pos2, n = 0, i\n\n  DO\n    pos2 = INDEX(str(pos1:), \",\")\n    IF (pos2 == 0) THEN\n       n = n + 1\n       word(n) = str(pos1:)\n       EXIT\n    END IF\n    n = n + 1\n    word(n) = str(pos1:pos1+pos2-2)\n    pos1 = pos2+pos1\n END DO\n\n DO i = 1, n\n   WRITE(*,\"(2A)\", ADVANCE=\"NO\") TRIM(word(i)), \".\"\n END DO\n \nEND PROGRAM Example\n", "target": "let text = 'Hello,How,Are,You,Today'\nlet tokens = text.split(||,||)\nprint tokens.join(with: '.')\n"}
{"id": 91495, "name": "Holidays related to Easter", "source": "Translate Fortran to C#:       subroutine easter(year,month,day)\nc Easter sunday\nc\nc Input\nc   year\nc Output\nc   month\nc   day\nc\nc See:\nc Jean Meeus, \"Astronomical Formulae for Calculators\",\nc 4th edition, Willmann-Bell, 1988, p.31\n      implicit integer(a-z)\n      a=mod(year,19)\n      b=year/100\n      c=mod(year,100)\n      d=b/4\n      e=mod(b,4)\n      f=(b+8)/25\n      g=(b-f+1)/3\n      h=mod(19*a+b-d-g+15,30)\n      i=c/4\n      k=mod(c,4)\n      l=mod(32+2*e+2*i-h-k,7)\n      m=(a+11*h+22*l)/451\n      n=h+l-7*m+114\n      month=n/31\n      day=mod(n,31)+1\n      end\n", "target": "using System;\nusing System.Collections;\nusing System.Collections.Specialized;\nusing System.Linq;\n\ninternal class Program\n{\n    private static readonly OrderedDictionary _holidayOffsets = new OrderedDictionary\n                                                                    {\n                                                                        {\"Easter\", 0},\n                                                                        {\"Ascension\", 39},\n                                                                        {\"Pentecost\", 49},\n                                                                        {\"Trinity\", 56},\n                                                                        {\"Corpus\", 60},\n                                                                    };\n\n    static void Main(string[] args)\n    {\n        Console.WriteLine(\"Christian holidays, related to Easter, for each centennial from 400 to 2100 CE:\");\n        for (int year = 400; year <= 2100; year += 100)\n            OutputHolidays(year);\n\n        Console.WriteLine();\n        Console.WriteLine(\"Christian holidays, related to Easter, for years from 2010 to 2020 CE:\");\n        for (int year = 2010; year <= 2020; year += 1)\n            OutputHolidays(year);\n    }\n\n    static void OutputHolidays(int year)\n    {\n        var easter = CalculateEaster(year);\n        var holidays = from kp in _holidayOffsets.OfType<DictionaryEntry>()\n                       let holiday = easter.AddDays(Convert.ToInt32(kp.Value))\n                       select kp.Key + \": \" + string.Format(\"{0,2:ddd} {0,2:%d} {0:MMM}\", holiday);\n        Console.WriteLine(\"{0,4} {1}\", year, string.Join(\", \", holidays.ToArray()));\n    }\n\n    static DateTime CalculateEaster(int year)\n    {\n        var a = year % 19;\n        var b = year / 100;\n        var c = year %100;\n        var d = b / 4;\n        var e = b % 4;\n        var f = (b + 8) / 25;\n        var g = (b - f + 1) / 3;\n        var h = (19 * a + b - d - g + 15) % 30;\n        var i = c / 4;\n        var k = c % 4;\n        var l = (32 + 2 * e + 2 * i - h - k) % 7;\n        var m = (a + 11 * h + 22 * l) / 451;\n        var numerator = h + l - 7 * m + 114;\n        var month = numerator / 31;\n        var day = (numerator % 31) + 1;\n        return new DateTime(year, month, day);\n    }\n}\n"}
{"id": 91497, "name": "Holidays related to Easter", "source": "Translate Fortran to Java:       subroutine easter(year,month,day)\nc Easter sunday\nc\nc Input\nc   year\nc Output\nc   month\nc   day\nc\nc See:\nc Jean Meeus, \"Astronomical Formulae for Calculators\",\nc 4th edition, Willmann-Bell, 1988, p.31\n      implicit integer(a-z)\n      a=mod(year,19)\n      b=year/100\n      c=mod(year,100)\n      d=b/4\n      e=mod(b,4)\n      f=(b+8)/25\n      g=(b-f+1)/3\n      h=mod(19*a+b-d-g+15,30)\n      i=c/4\n      k=mod(c,4)\n      l=mod(32+2*e+2*i-h-k,7)\n      m=(a+11*h+22*l)/451\n      n=h+l-7*m+114\n      month=n/31\n      day=mod(n,31)+1\n      end\n", "target": "import java.text.DateFormatSymbols;\nimport java.util.*;\n\npublic class EasterRelatedHolidays {\n\n    final static Map<String, Integer> holidayOffsets;\n\n    static {\n        holidayOffsets = new LinkedHashMap<>();\n        holidayOffsets.put(\"Easter\", 0);\n        holidayOffsets.put(\"Ascension\", 39);\n        holidayOffsets.put(\"Pentecost\", 10);\n        holidayOffsets.put(\"Trinity\", 7);\n        holidayOffsets.put(\"Corpus\", 4);\n    }\n\n    public static void main(String[] args) {\n        System.out.println(\"Christian holidays, related to Easter,\"\n                + \" for each centennial from 400 to 2100 CE:\");\n\n        for (int y = 400; y <= 2100; y += 100)\n            printEasterRelatedHolidays(y);\n\n        System.out.println(\"\\nChristian holidays, related to Easter,\"\n                + \" for years from 2010 to 2020 CE:\");\n        for (int y = 2010; y < 2021; y++)\n            printEasterRelatedHolidays(y);\n    }\n\n    static void printEasterRelatedHolidays(int year) {\n        final int a = year % 19;\n        final int b = year / 100;\n        final int c = year % 100;\n        final int d = b / 4;\n        final int e = b % 4;\n        final int f = (b + 8) / 25;\n        final int g = (b - f + 1) / 3;\n        final int h = (19 * a + b - d - g + 15) % 30;\n        final int i = c / 4;\n        final int k = c % 4;\n        final int l = (32 + 2 * e + 2 * i - h - k) % 7;\n        final int m = (a + 11 * h + 22 * l) / 451;\n        final int n = h + l - 7 * m + 114;\n        final int month = n / 31 - 1;\n        final int day = (n % 31) + 1;\n\n        Calendar date = new GregorianCalendar(year, month, day);\n        String[] months = new DateFormatSymbols(Locale.US).getShortMonths();\n\n        System.out.printf(\"%4d \", year);\n        for (String hd : holidayOffsets.keySet()) {\n            date.add(Calendar.DATE, holidayOffsets.get(hd));\n            System.out.printf(\"%s: %2d %s  \", hd,\n                    date.get(Calendar.DAY_OF_MONTH),\n                    months[date.get(Calendar.MONTH)]);\n        }\n        System.out.println();\n    }\n}\n"}
{"id": 91498, "name": "Holidays related to Easter", "source": "Translate Fortran to Python:       subroutine easter(year,month,day)\nc Easter sunday\nc\nc Input\nc   year\nc Output\nc   month\nc   day\nc\nc See:\nc Jean Meeus, \"Astronomical Formulae for Calculators\",\nc 4th edition, Willmann-Bell, 1988, p.31\n      implicit integer(a-z)\n      a=mod(year,19)\n      b=year/100\n      c=mod(year,100)\n      d=b/4\n      e=mod(b,4)\n      f=(b+8)/25\n      g=(b-f+1)/3\n      h=mod(19*a+b-d-g+15,30)\n      i=c/4\n      k=mod(c,4)\n      l=mod(32+2*e+2*i-h-k,7)\n      m=(a+11*h+22*l)/451\n      n=h+l-7*m+114\n      month=n/31\n      day=mod(n,31)+1\n      end\n", "target": "from dateutil.easter import *\nimport datetime, calendar\n\nclass Holiday(object):\n    def __init__(self, date, offset=0):\n        self.holiday = date + datetime.timedelta(days=offset)\n\n    def __str__(self):\n        dayofweek = calendar.day_name[self.holiday.weekday()][0:3]\n        month = calendar.month_name[self.holiday.month][0:3]\n        return '{0} {1:2d} {2}'.format(dayofweek, self.holiday.day, month)\n\ndef get_holiday_values(year):\n    holidays = {'year': year}\n    easterDate = easter(year)\n    holidays['easter'] = Holiday(easterDate) \n    holidays['ascension'] = Holiday(easterDate, 39)\n    holidays['pentecost'] = Holiday(easterDate, 49)\n    holidays['trinity'] = Holiday(easterDate, 56)\n    holidays['corpus'] = Holiday(easterDate, 60)\n    return holidays\n    \ndef print_holidays(holidays):\n    print '{year:4d} Easter: {easter}, Ascension: {ascension}, Pentecost: {pentecost}, Trinity: {trinity}, Corpus: {corpus}'.format(**holidays)\n    \nif __name__ == \"__main__\":\n    print \"Christian holidays, related to Easter, for each centennial from 400 to 2100 CE:\"\n    for year in range(400, 2200, 100):\n        print_holidays(get_holiday_values(year))\n\n    print ''\n    print \"Christian holidays, related to Easter, for years from 2010 to 2020 CE:\"\n    for year in range(2010, 2021):\n        print_holidays(get_holiday_values(year))\n"}
{"id": 91681, "name": "Stack", "source": "Translate Fortran to C#: module mod_stack\n\n  implicit none\n  type node\n    \n    real*8, private :: data\n    \n    type(node), pointer, private :: next\n  end type node\n  private node\n\n  type stack\n    \n    type(node), pointer, private :: first\n    \n    integer, private :: len=0\n  contains\n    procedure :: pop\n    procedure :: push\n    procedure :: peek\n    procedure :: getSize\n    procedure :: clearStack\n    procedure :: isEmpty\n  end type stack\n\ncontains\n\n  function pop(this) result(x)\n    class(stack) :: this\n    real*8 :: x\n    type(node), pointer :: tmp\n    if ( this%len == 0 ) then\n      print*, \"popping from empty stack\"\n      \n    end if\n    tmp => this%first\n    x = this%first%data\n    this%first => this%first%next\n    deallocate(tmp)\n    this%len = this%len -1\n  end function pop\n\n  subroutine push(this, x)\n    real*8 :: x\n    class(stack), target :: this\n    type(node), pointer :: new, tmp\n    allocate(new)\n    new%data = x\n    if (.not. associated(this%first)) then\n      this%first => new\n    else\n      tmp => this%first\n      this%first => new\n      this%first%next => tmp\n    end if\n    this%len = this%len + 1\n  end subroutine push\n\n  function peek(this) result(x)\n    class(stack) :: this\n    real*8 :: x\n    x = this%first%data\n  end function peek\n\n  function getSize(this) result(n)\n    class(stack) :: this\n    integer :: n\n    n = this%len\n  end function getSize\n\n  function isEmpty(this) result(empty)\n    class(stack) :: this\n    logical :: empty\n    if ( this%len > 0 ) then\n      empty = .FALSE.\n    else\n      empty = .TRUE.\n    end if\n  end function isEmpty\n\n  subroutine clearStack(this)\n    class(stack) :: this\n    type(node), pointer :: tmp\n    integer :: i\n    if ( this%len == 0 ) then\n      return\n    end if\n    do i = 1, this%len\n      tmp => this%first\n      if ( .not. associated(tmp)) exit\n      this%first => this%first%next\n      deallocate(tmp)\n    end do\n    this%len = 0\n  end subroutine clearStack\nend module mod_stack\n\nprogram main\n  use mod_stack\n  type(stack) :: my_stack\n  integer :: i\n  real*8 :: dat\n  do i = 1, 5, 1\n    dat = 1.0 * i\n    call my_stack%push(dat)\n  end do\n  do while ( .not. my_stack%isEmpty() )\n    print*, my_stack%pop()\n  end do\n  call my_stack%clearStack()\nend program main\n", "target": "\nSystem.Collections.Stack stack = new System.Collections.Stack();\nstack.Push( obj );\nbool isEmpty = stack.Count == 0;\nobject top = stack.Peek(); \ntop = stack.Pop();\n\n\nSystem.Collections.Generic.Stack<Foo> stack = new System.Collections.Generic.Stack<Foo>();\nstack.Push(new Foo());\nbool isEmpty = stack.Count == 0;\nFoo top = stack.Peek(); \ntop = stack.Pop();\n"}
{"id": 91684, "name": "Stack", "source": "Translate Fortran to Java: module mod_stack\n\n  implicit none\n  type node\n    \n    real*8, private :: data\n    \n    type(node), pointer, private :: next\n  end type node\n  private node\n\n  type stack\n    \n    type(node), pointer, private :: first\n    \n    integer, private :: len=0\n  contains\n    procedure :: pop\n    procedure :: push\n    procedure :: peek\n    procedure :: getSize\n    procedure :: clearStack\n    procedure :: isEmpty\n  end type stack\n\ncontains\n\n  function pop(this) result(x)\n    class(stack) :: this\n    real*8 :: x\n    type(node), pointer :: tmp\n    if ( this%len == 0 ) then\n      print*, \"popping from empty stack\"\n      \n    end if\n    tmp => this%first\n    x = this%first%data\n    this%first => this%first%next\n    deallocate(tmp)\n    this%len = this%len -1\n  end function pop\n\n  subroutine push(this, x)\n    real*8 :: x\n    class(stack), target :: this\n    type(node), pointer :: new, tmp\n    allocate(new)\n    new%data = x\n    if (.not. associated(this%first)) then\n      this%first => new\n    else\n      tmp => this%first\n      this%first => new\n      this%first%next => tmp\n    end if\n    this%len = this%len + 1\n  end subroutine push\n\n  function peek(this) result(x)\n    class(stack) :: this\n    real*8 :: x\n    x = this%first%data\n  end function peek\n\n  function getSize(this) result(n)\n    class(stack) :: this\n    integer :: n\n    n = this%len\n  end function getSize\n\n  function isEmpty(this) result(empty)\n    class(stack) :: this\n    logical :: empty\n    if ( this%len > 0 ) then\n      empty = .FALSE.\n    else\n      empty = .TRUE.\n    end if\n  end function isEmpty\n\n  subroutine clearStack(this)\n    class(stack) :: this\n    type(node), pointer :: tmp\n    integer :: i\n    if ( this%len == 0 ) then\n      return\n    end if\n    do i = 1, this%len\n      tmp => this%first\n      if ( .not. associated(tmp)) exit\n      this%first => this%first%next\n      deallocate(tmp)\n    end do\n    this%len = 0\n  end subroutine clearStack\nend module mod_stack\n\nprogram main\n  use mod_stack\n  type(stack) :: my_stack\n  integer :: i\n  real*8 :: dat\n  do i = 1, 5, 1\n    dat = 1.0 * i\n    call my_stack%push(dat)\n  end do\n  do while ( .not. my_stack%isEmpty() )\n    print*, my_stack%pop()\n  end do\n  call my_stack%clearStack()\nend program main\n", "target": "import java.util.Stack;\n\npublic class StackTest {\n    public static void main( final String[] args ) {\n        final Stack<String> stack = new Stack<String>();\n\n        System.out.println( \"New stack empty? \" + stack.empty() );\n\n        stack.push( \"There can be only one\" );\n        System.out.println( \"Pushed stack empty? \" + stack.empty() );\n        System.out.println( \"Popped single entry: \" + stack.pop() );\n\n        stack.push( \"First\" );\n        stack.push( \"Second\" );\n        System.out.println( \"Popped entry should be second: \" + stack.pop() );\n\n        \n        stack.pop();\n        stack.pop();\n    }\n}\n"}
{"id": 91685, "name": "Stack", "source": "Translate Fortran to Python: module mod_stack\n\n  implicit none\n  type node\n    \n    real*8, private :: data\n    \n    type(node), pointer, private :: next\n  end type node\n  private node\n\n  type stack\n    \n    type(node), pointer, private :: first\n    \n    integer, private :: len=0\n  contains\n    procedure :: pop\n    procedure :: push\n    procedure :: peek\n    procedure :: getSize\n    procedure :: clearStack\n    procedure :: isEmpty\n  end type stack\n\ncontains\n\n  function pop(this) result(x)\n    class(stack) :: this\n    real*8 :: x\n    type(node), pointer :: tmp\n    if ( this%len == 0 ) then\n      print*, \"popping from empty stack\"\n      \n    end if\n    tmp => this%first\n    x = this%first%data\n    this%first => this%first%next\n    deallocate(tmp)\n    this%len = this%len -1\n  end function pop\n\n  subroutine push(this, x)\n    real*8 :: x\n    class(stack), target :: this\n    type(node), pointer :: new, tmp\n    allocate(new)\n    new%data = x\n    if (.not. associated(this%first)) then\n      this%first => new\n    else\n      tmp => this%first\n      this%first => new\n      this%first%next => tmp\n    end if\n    this%len = this%len + 1\n  end subroutine push\n\n  function peek(this) result(x)\n    class(stack) :: this\n    real*8 :: x\n    x = this%first%data\n  end function peek\n\n  function getSize(this) result(n)\n    class(stack) :: this\n    integer :: n\n    n = this%len\n  end function getSize\n\n  function isEmpty(this) result(empty)\n    class(stack) :: this\n    logical :: empty\n    if ( this%len > 0 ) then\n      empty = .FALSE.\n    else\n      empty = .TRUE.\n    end if\n  end function isEmpty\n\n  subroutine clearStack(this)\n    class(stack) :: this\n    type(node), pointer :: tmp\n    integer :: i\n    if ( this%len == 0 ) then\n      return\n    end if\n    do i = 1, this%len\n      tmp => this%first\n      if ( .not. associated(tmp)) exit\n      this%first => this%first%next\n      deallocate(tmp)\n    end do\n    this%len = 0\n  end subroutine clearStack\nend module mod_stack\n\nprogram main\n  use mod_stack\n  type(stack) :: my_stack\n  integer :: i\n  real*8 :: dat\n  do i = 1, 5, 1\n    dat = 1.0 * i\n    call my_stack%push(dat)\n  end do\n  do while ( .not. my_stack%isEmpty() )\n    print*, my_stack%pop()\n  end do\n  call my_stack%clearStack()\nend program main\n", "target": "from collections import deque\nstack = deque()\nstack.append(value) \nvalue = stack.pop()\nnot stack \n"}
{"id": 91945, "name": "CRC-32", "source": "Translate Fortran to C#: module crc32_m\n    use iso_fortran_env\n    implicit none\n    integer(int32) :: crc_table(0:255)\ncontains\n    subroutine update_crc(a, crc)\n        integer :: n, i\n        character(*) :: a\n        integer(int32) :: crc\n        \n        crc = not(crc)\n        n = len(a)\n        do i = 1, n\n            crc = ieor(shiftr(crc, 8), crc_table(iand(ieor(crc, iachar(a(i:i))), 255)))\n        end do\n        crc = not(crc)\n    end subroutine\n    \n    subroutine init_table\n        integer :: i, j\n        integer(int32) :: k\n        \n        do i = 0, 255\n            k = i\n            do j = 1, 8\n                if (btest(k, 0)) then\n                    k = ieor(shiftr(k, 1), -306674912)\n                else\n                    k = shiftr(k, 1)\n                end if\n            end do\n            crc_table(i) = k\n        end do\n    end subroutine\nend module\n\nprogram crc32\n    use crc32_m\n    implicit none\n    integer(int32) :: crc = 0\n    character(*), parameter :: s = \"The quick brown fox jumps over the lazy dog\"\n    call init_table\n    call update_crc(s, crc)\n    print \"(Z8)\", crc\nend program\n", "target": "    \n    \n    \n    public class Crc32\n    {\n        #region Constants\n        \n        \n        \n        private const UInt32 s_generator = 0xEDB88320;\n        #endregion\n\n        #region Constructors\n        \n        \n        \n        public Crc32()\n        {\n            \n            m_checksumTable = Enumerable.Range(0, 256).Select(i =>\n            {\n                var tableEntry = (uint)i;\n                for (var j = 0; j < 8; ++j)\n                {\n                    tableEntry = ((tableEntry & 1) != 0)\n                        ? (s_generator ^ (tableEntry >> 1)) \n                        : (tableEntry >> 1);\n                }\n                return tableEntry;\n            }).ToArray();\n        }\n        #endregion\n\n        #region Methods\n        \n        \n        \n        \n        \n        public UInt32 Get<T>(IEnumerable<T> byteStream)\n        {\n            try\n            {\n                \n                return ~byteStream.Aggregate(0xFFFFFFFF, (checksumRegister, currentByte) => \n                          (m_checksumTable[(checksumRegister & 0xFF) ^ Convert.ToByte(currentByte)] ^ (checksumRegister >> 8)));\n            }\n            catch (FormatException e)\n            {\n                throw new CrcException(\"Could not read the stream out as bytes.\", e);\n            }\n            catch (InvalidCastException e)\n            {\n                throw new CrcException(\"Could not read the stream out as bytes.\", e);\n            }\n            catch (OverflowException e)\n            {\n                throw new CrcException(\"Could not read the stream out as bytes.\", e);\n            }\n        }\n        #endregion\n\n        #region Fields\n        \n        \n        \n        private readonly UInt32[] m_checksumTable;\n\n        #endregion\n    }\n"}
{"id": 91948, "name": "CRC-32", "source": "Translate Fortran to Java: module crc32_m\n    use iso_fortran_env\n    implicit none\n    integer(int32) :: crc_table(0:255)\ncontains\n    subroutine update_crc(a, crc)\n        integer :: n, i\n        character(*) :: a\n        integer(int32) :: crc\n        \n        crc = not(crc)\n        n = len(a)\n        do i = 1, n\n            crc = ieor(shiftr(crc, 8), crc_table(iand(ieor(crc, iachar(a(i:i))), 255)))\n        end do\n        crc = not(crc)\n    end subroutine\n    \n    subroutine init_table\n        integer :: i, j\n        integer(int32) :: k\n        \n        do i = 0, 255\n            k = i\n            do j = 1, 8\n                if (btest(k, 0)) then\n                    k = ieor(shiftr(k, 1), -306674912)\n                else\n                    k = shiftr(k, 1)\n                end if\n            end do\n            crc_table(i) = k\n        end do\n    end subroutine\nend module\n\nprogram crc32\n    use crc32_m\n    implicit none\n    integer(int32) :: crc = 0\n    character(*), parameter :: s = \"The quick brown fox jumps over the lazy dog\"\n    call init_table\n    call update_crc(s, crc)\n    print \"(Z8)\", crc\nend program\n", "target": "import java.util.zip.* ;\n\npublic class CRCMaker {\n   public static void main( String[ ] args ) {\n      String toBeEncoded = new String( \"The quick brown fox jumps over the lazy dog\" ) ;\n      CRC32 myCRC = new CRC32( ) ;\n      myCRC.update( toBeEncoded.getBytes( ) ) ;\n      System.out.println( \"The CRC-32 value is\u00a0: \" + Long.toHexString( myCRC.getValue( ) ) + \"\u00a0!\" ) ;\n   }\n}\n"}
{"id": 91949, "name": "CRC-32", "source": "Translate Fortran to Python: module crc32_m\n    use iso_fortran_env\n    implicit none\n    integer(int32) :: crc_table(0:255)\ncontains\n    subroutine update_crc(a, crc)\n        integer :: n, i\n        character(*) :: a\n        integer(int32) :: crc\n        \n        crc = not(crc)\n        n = len(a)\n        do i = 1, n\n            crc = ieor(shiftr(crc, 8), crc_table(iand(ieor(crc, iachar(a(i:i))), 255)))\n        end do\n        crc = not(crc)\n    end subroutine\n    \n    subroutine init_table\n        integer :: i, j\n        integer(int32) :: k\n        \n        do i = 0, 255\n            k = i\n            do j = 1, 8\n                if (btest(k, 0)) then\n                    k = ieor(shiftr(k, 1), -306674912)\n                else\n                    k = shiftr(k, 1)\n                end if\n            end do\n            crc_table(i) = k\n        end do\n    end subroutine\nend module\n\nprogram crc32\n    use crc32_m\n    implicit none\n    integer(int32) :: crc = 0\n    character(*), parameter :: s = \"The quick brown fox jumps over the lazy dog\"\n    call init_table\n    call update_crc(s, crc)\n    print \"(Z8)\", crc\nend program\n", "target": ">>> s = 'The quick brown fox jumps over the lazy dog'\n>>> import zlib\n>>> hex(zlib.crc32(s))\n'0x414fa339'\n\n>>> import binascii\n>>> hex(binascii.crc32(s))\n'0x414fa339'\n"}
{"id": 92404, "name": "Van der Corput sequence", "source": "Translate Fortran to C#:       FUNCTION VDC(N,BASE)\t\nConverts 1234 in decimal to 4321 in V, and P = 10000.\n       INTEGER N\t\n       INTEGER BASE\t\n       INTEGER I\t\n       INTEGER P\t\n       INTEGER V\t\n        P = 1\t\t\n        V = 0\t\t\n        I = N\t\t\n        DO WHILE (I .NE. 0)\t\n          V = V*BASE + MOD(I,BASE)\t\n          I = I/BASE\t\t\t\n          P = P*BASE\t\t\t\n        END DO\t\t\t\n        VDC = V/FLOAT(P)\t\n      END FUNCTION VDC\t\n\n      PROGRAM POKE\n      INTEGER FIRST,LAST\t\n      PARAMETER (FIRST = 0,LAST = 9)\t\n      INTEGER I,BASE\t\t\n      REAL VDC\t\t\t\n\n      WRITE (6,1) FIRST,LAST,(I, I = FIRST,LAST)\t\n    1 FORMAT (\"Calculates values \",I0,\" to \",I0,\" of the \",\n     1 \"Van der Corput sequence, in various bases.\"/\n     2 \"Base\",666I9)\n\n      DO BASE = 2,13\t\n        WRITE (6,2) BASE,(VDC(I,BASE), I = FIRST,LAST)\t\n    2   FORMAT (I4,666F9.6)\t\n      END DO\t\t\n\n      END\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\nnamespace VanDerCorput\n{\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    public class VanDerCorputSequence: IEnumerable<Tuple<long,long>>\n    {\n        \n        \n        \n        public int Base { get; private set; }\n\n        \n        \n        \n        public long Count { get; private set; }\n\n        \n        \n        \n        \n        \n        public VanDerCorputSequence(int iBase, long count = long.MaxValue) {\n            if (iBase < 2)\n                throw new ArgumentOutOfRangeException(\"iBase\", \"must be two or greater, not the given value of \" + iBase);\n            Base = iBase;\n            Count = count;\n        }\n\n        \n        \n        \n        \n        \n        \n        public Tuple<long,long> Compute(long n)\n        {\n            long p = 0, q = 1;\n            long numerator, denominator;\n            while (n != 0)\n            {\n                p = p * Base + (n % Base);\n                q *= Base;\n                n /= Base;\n            }\n            numerator = p;\n            denominator = q;\n            while (p != 0) \n            { \n                n = p; \n                p = q % p; \n                q = n; \n            }\n            numerator /= q;\n            denominator /= q;\n            return new Tuple<long,long>(numerator, denominator);\n        }\n\n        \n        \n        \n        \n        \n        \n        public static Tuple<long, long> Compute(int iBase, long n)\n        {\n            var seq = new VanDerCorputSequence(iBase);\n            return seq.Compute(n);\n        }\n\n        \n        \n        \n        \n        \n        public IEnumerator<Tuple<long, long>> GetEnumerator()\n        {\n            long iSequenceIndex = 0L;\n            while (iSequenceIndex < Count)\n            {\n                yield return Compute(iSequenceIndex);\n                iSequenceIndex++;\n            }\n        }\n\n        System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()\n        {\n            return GetEnumerator();\n        }\n    }\n\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            TestBasesTwoThroughFive();\n\n            Console.WriteLine(\"Type return to continue...\");\n            Console.ReadLine();\n        }\n\n        static void TestBasesTwoThroughFive()\n        {\n            foreach (var seq in Enumerable.Range(2, 5).Select(x => new VanDerCorputSequence(x, 10))) \n            {\n                Console.Write(\"base \" + seq.Base + \":\");\n                foreach(var vc in seq) \n                    Console.Write(\" \" + vc.Item1 + \"/\" + vc.Item2);\n                Console.WriteLine();\n            }\n        }\n    }\n}\n"}
{"id": 92405, "name": "Van der Corput sequence", "source": "Translate Fortran to C#:       FUNCTION VDC(N,BASE)\t\nConverts 1234 in decimal to 4321 in V, and P = 10000.\n       INTEGER N\t\n       INTEGER BASE\t\n       INTEGER I\t\n       INTEGER P\t\n       INTEGER V\t\n        P = 1\t\t\n        V = 0\t\t\n        I = N\t\t\n        DO WHILE (I .NE. 0)\t\n          V = V*BASE + MOD(I,BASE)\t\n          I = I/BASE\t\t\t\n          P = P*BASE\t\t\t\n        END DO\t\t\t\n        VDC = V/FLOAT(P)\t\n      END FUNCTION VDC\t\n\n      PROGRAM POKE\n      INTEGER FIRST,LAST\t\n      PARAMETER (FIRST = 0,LAST = 9)\t\n      INTEGER I,BASE\t\t\n      REAL VDC\t\t\t\n\n      WRITE (6,1) FIRST,LAST,(I, I = FIRST,LAST)\t\n    1 FORMAT (\"Calculates values \",I0,\" to \",I0,\" of the \",\n     1 \"Van der Corput sequence, in various bases.\"/\n     2 \"Base\",666I9)\n\n      DO BASE = 2,13\t\n        WRITE (6,2) BASE,(VDC(I,BASE), I = FIRST,LAST)\t\n    2   FORMAT (I4,666F9.6)\t\n      END DO\t\t\n\n      END\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\nnamespace VanDerCorput\n{\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    public class VanDerCorputSequence: IEnumerable<Tuple<long,long>>\n    {\n        \n        \n        \n        public int Base { get; private set; }\n\n        \n        \n        \n        public long Count { get; private set; }\n\n        \n        \n        \n        \n        \n        public VanDerCorputSequence(int iBase, long count = long.MaxValue) {\n            if (iBase < 2)\n                throw new ArgumentOutOfRangeException(\"iBase\", \"must be two or greater, not the given value of \" + iBase);\n            Base = iBase;\n            Count = count;\n        }\n\n        \n        \n        \n        \n        \n        \n        public Tuple<long,long> Compute(long n)\n        {\n            long p = 0, q = 1;\n            long numerator, denominator;\n            while (n != 0)\n            {\n                p = p * Base + (n % Base);\n                q *= Base;\n                n /= Base;\n            }\n            numerator = p;\n            denominator = q;\n            while (p != 0) \n            { \n                n = p; \n                p = q % p; \n                q = n; \n            }\n            numerator /= q;\n            denominator /= q;\n            return new Tuple<long,long>(numerator, denominator);\n        }\n\n        \n        \n        \n        \n        \n        \n        public static Tuple<long, long> Compute(int iBase, long n)\n        {\n            var seq = new VanDerCorputSequence(iBase);\n            return seq.Compute(n);\n        }\n\n        \n        \n        \n        \n        \n        public IEnumerator<Tuple<long, long>> GetEnumerator()\n        {\n            long iSequenceIndex = 0L;\n            while (iSequenceIndex < Count)\n            {\n                yield return Compute(iSequenceIndex);\n                iSequenceIndex++;\n            }\n        }\n\n        System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()\n        {\n            return GetEnumerator();\n        }\n    }\n\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            TestBasesTwoThroughFive();\n\n            Console.WriteLine(\"Type return to continue...\");\n            Console.ReadLine();\n        }\n\n        static void TestBasesTwoThroughFive()\n        {\n            foreach (var seq in Enumerable.Range(2, 5).Select(x => new VanDerCorputSequence(x, 10))) \n            {\n                Console.Write(\"base \" + seq.Base + \":\");\n                foreach(var vc in seq) \n                    Console.Write(\" \" + vc.Item1 + \"/\" + vc.Item2);\n                Console.WriteLine();\n            }\n        }\n    }\n}\n"}
{"id": 92411, "name": "Van der Corput sequence", "source": "Translate Fortran to Java:       FUNCTION VDC(N,BASE)\t\nConverts 1234 in decimal to 4321 in V, and P = 10000.\n       INTEGER N\t\n       INTEGER BASE\t\n       INTEGER I\t\n       INTEGER P\t\n       INTEGER V\t\n        P = 1\t\t\n        V = 0\t\t\n        I = N\t\t\n        DO WHILE (I .NE. 0)\t\n          V = V*BASE + MOD(I,BASE)\t\n          I = I/BASE\t\t\t\n          P = P*BASE\t\t\t\n        END DO\t\t\t\n        VDC = V/FLOAT(P)\t\n      END FUNCTION VDC\t\n\n      PROGRAM POKE\n      INTEGER FIRST,LAST\t\n      PARAMETER (FIRST = 0,LAST = 9)\t\n      INTEGER I,BASE\t\t\n      REAL VDC\t\t\t\n\n      WRITE (6,1) FIRST,LAST,(I, I = FIRST,LAST)\t\n    1 FORMAT (\"Calculates values \",I0,\" to \",I0,\" of the \",\n     1 \"Van der Corput sequence, in various bases.\"/\n     2 \"Base\",666I9)\n\n      DO BASE = 2,13\t\n        WRITE (6,2) BASE,(VDC(I,BASE), I = FIRST,LAST)\t\n    2   FORMAT (I4,666F9.6)\t\n      END DO\t\t\n\n      END\n", "target": "public class VanDerCorput{\n\tpublic static double vdc(int n){\n\t\tdouble vdc = 0;\n\t\tint denom = 1;\n\t\twhile(n != 0){\n\t\t\tvdc += n % 2.0 / (denom *= 2);\n\t\t\tn /= 2;\n\t\t}\n\t\treturn vdc;\n\t}\n\t\n\tpublic static void main(String[] args){\n\t\tfor(int i = 0; i <= 10; i++){\n\t\t\tSystem.out.println(vdc(i));\n\t\t}\n\t}\n}\n"}
{"id": 92412, "name": "Van der Corput sequence", "source": "Translate Fortran to Java:       FUNCTION VDC(N,BASE)\t\nConverts 1234 in decimal to 4321 in V, and P = 10000.\n       INTEGER N\t\n       INTEGER BASE\t\n       INTEGER I\t\n       INTEGER P\t\n       INTEGER V\t\n        P = 1\t\t\n        V = 0\t\t\n        I = N\t\t\n        DO WHILE (I .NE. 0)\t\n          V = V*BASE + MOD(I,BASE)\t\n          I = I/BASE\t\t\t\n          P = P*BASE\t\t\t\n        END DO\t\t\t\n        VDC = V/FLOAT(P)\t\n      END FUNCTION VDC\t\n\n      PROGRAM POKE\n      INTEGER FIRST,LAST\t\n      PARAMETER (FIRST = 0,LAST = 9)\t\n      INTEGER I,BASE\t\t\n      REAL VDC\t\t\t\n\n      WRITE (6,1) FIRST,LAST,(I, I = FIRST,LAST)\t\n    1 FORMAT (\"Calculates values \",I0,\" to \",I0,\" of the \",\n     1 \"Van der Corput sequence, in various bases.\"/\n     2 \"Base\",666I9)\n\n      DO BASE = 2,13\t\n        WRITE (6,2) BASE,(VDC(I,BASE), I = FIRST,LAST)\t\n    2   FORMAT (I4,666F9.6)\t\n      END DO\t\t\n\n      END\n", "target": "public class VanDerCorput{\n\tpublic static double vdc(int n){\n\t\tdouble vdc = 0;\n\t\tint denom = 1;\n\t\twhile(n != 0){\n\t\t\tvdc += n % 2.0 / (denom *= 2);\n\t\t\tn /= 2;\n\t\t}\n\t\treturn vdc;\n\t}\n\t\n\tpublic static void main(String[] args){\n\t\tfor(int i = 0; i <= 10; i++){\n\t\t\tSystem.out.println(vdc(i));\n\t\t}\n\t}\n}\n"}
{"id": 92413, "name": "Van der Corput sequence", "source": "Translate Fortran to Python:       FUNCTION VDC(N,BASE)\t\nConverts 1234 in decimal to 4321 in V, and P = 10000.\n       INTEGER N\t\n       INTEGER BASE\t\n       INTEGER I\t\n       INTEGER P\t\n       INTEGER V\t\n        P = 1\t\t\n        V = 0\t\t\n        I = N\t\t\n        DO WHILE (I .NE. 0)\t\n          V = V*BASE + MOD(I,BASE)\t\n          I = I/BASE\t\t\t\n          P = P*BASE\t\t\t\n        END DO\t\t\t\n        VDC = V/FLOAT(P)\t\n      END FUNCTION VDC\t\n\n      PROGRAM POKE\n      INTEGER FIRST,LAST\t\n      PARAMETER (FIRST = 0,LAST = 9)\t\n      INTEGER I,BASE\t\t\n      REAL VDC\t\t\t\n\n      WRITE (6,1) FIRST,LAST,(I, I = FIRST,LAST)\t\n    1 FORMAT (\"Calculates values \",I0,\" to \",I0,\" of the \",\n     1 \"Van der Corput sequence, in various bases.\"/\n     2 \"Base\",666I9)\n\n      DO BASE = 2,13\t\n        WRITE (6,2) BASE,(VDC(I,BASE), I = FIRST,LAST)\t\n    2   FORMAT (I4,666F9.6)\t\n      END DO\t\t\n\n      END\n", "target": ">>> def base10change(n, base):\n\tdigits = []\n\twhile n:\n\t\tn,remainder = divmod(n, base)\n\t\tdigits.insert(0, remainder)\n\treturn digits\n\n>>> base10change(11, 2)\n[1, 0, 1, 1]\n"}
{"id": 92414, "name": "Van der Corput sequence", "source": "Translate Fortran to Python:       FUNCTION VDC(N,BASE)\t\nConverts 1234 in decimal to 4321 in V, and P = 10000.\n       INTEGER N\t\n       INTEGER BASE\t\n       INTEGER I\t\n       INTEGER P\t\n       INTEGER V\t\n        P = 1\t\t\n        V = 0\t\t\n        I = N\t\t\n        DO WHILE (I .NE. 0)\t\n          V = V*BASE + MOD(I,BASE)\t\n          I = I/BASE\t\t\t\n          P = P*BASE\t\t\t\n        END DO\t\t\t\n        VDC = V/FLOAT(P)\t\n      END FUNCTION VDC\t\n\n      PROGRAM POKE\n      INTEGER FIRST,LAST\t\n      PARAMETER (FIRST = 0,LAST = 9)\t\n      INTEGER I,BASE\t\t\n      REAL VDC\t\t\t\n\n      WRITE (6,1) FIRST,LAST,(I, I = FIRST,LAST)\t\n    1 FORMAT (\"Calculates values \",I0,\" to \",I0,\" of the \",\n     1 \"Van der Corput sequence, in various bases.\"/\n     2 \"Base\",666I9)\n\n      DO BASE = 2,13\t\n        WRITE (6,2) BASE,(VDC(I,BASE), I = FIRST,LAST)\t\n    2   FORMAT (I4,666F9.6)\t\n      END DO\t\t\n\n      END\n", "target": ">>> def base10change(n, base):\n\tdigits = []\n\twhile n:\n\t\tn,remainder = divmod(n, base)\n\t\tdigits.insert(0, remainder)\n\treturn digits\n\n>>> base10change(11, 2)\n[1, 0, 1, 1]\n"}
{"id": 92738, "name": "Loops_Nested", "source": "Translate Fortran to C#:       PROGRAM LOOPNESTED\n        INTEGER A, I, J, RNDINT\n\nC       Build a two-dimensional twenty-by-twenty array.\n        DIMENSION A(20,20)\n\nC       It doesn't matter what number you put here.\n        CALL SDRAND(123)\n\nC       Fill the array with random numbers.\n        DO 20 I = 1, 20\n          DO 10 J = 1, 20\n            A(I, J) = RNDINT(1, 20)\n   10     CONTINUE\n   20   CONTINUE\n\nC       Print the numbers.\n        DO 40 I = 1, 20\n          DO 30 J = 1, 20\n            WRITE (*,5000) I, J, A(I, J)\n\nC           If this number is twenty, break out of both loops.\n            IF (A(I, J) .EQ. 20) GOTO 50\n   30     CONTINUE\n   40   CONTINUE\n\nC       If we had gone to 40, the DO loop would have continued. You can\nC       label STOP instead of adding another CONTINUE, but it is good\nC       form to only label CONTINUE statements as much as possible.\n   50   CONTINUE\n        STOP\n\nC       Print the value so that it looks like one of those C arrays that\nC       makes everybody so comfortable.\n 5000   FORMAT('A[', I2, '][', I2, '] is ', I2)\n      END\n\nC FORTRAN 77 does not come with a random number generator, but it is\nC easy enough to type \"fortran 77 random number generator\" into your\nC preferred search engine and to copy and paste what you find. \nC The following code is a slightly-modified version of:\nC\nC     http://www.tat.physik.uni-tuebingen.de/\nC         ~kley/lehre/ftn77/tutorial/subprograms.html\n      SUBROUTINE SDRAND (IRSEED)\n        COMMON  /SEED/ UTSEED, IRFRST\n        UTSEED = IRSEED\n        IRFRST = 0\n        RETURN\n      END\n      INTEGER FUNCTION RNDINT (IFROM, ITO)\n        INTEGER IFROM, ITO\n        PARAMETER (MPLIER=16807, MODLUS=2147483647,                     &\n     &              MOBYMP=127773, MOMDMP=2836)\n        COMMON  /SEED/ UTSEED, IRFRST\n        INTEGER HVLUE, LVLUE, TESTV, NEXTN\n        SAVE    NEXTN\n        IF (IRFRST .EQ. 0) THEN\n          NEXTN = UTSEED\n          IRFRST = 1\n        ENDIF\n        HVLUE = NEXTN / MOBYMP\n        LVLUE = MOD(NEXTN, MOBYMP)\n        TESTV = MPLIER*LVLUE - MOMDMP*HVLUE\n        IF (TESTV .GT. 0) THEN\n          NEXTN = TESTV\n        ELSE\n          NEXTN = TESTV + MODLUS\n        ENDIF\n        IF (NEXTN .GE. 0) THEN\n          RNDINT = MOD(MOD(NEXTN, MODLUS), ITO - IFROM + 1) + IFROM\n        ELSE\n          RNDINT = MOD(MOD(NEXTN, MODLUS), ITO - IFROM + 1) + ITO + 1\n        ENDIF\n        RETURN\n      END\n", "target": "using System;\n\nclass Program {\n    static void Main(string[] args) {\n        int[,] a = new int[10, 10];\n        Random r = new Random();\n\n        for (int i = 0; i < 10; i++) {\n            for (int j = 0; j < 10; j++) {\n                a[i, j] = r.Next(0, 21) + 1;\n            }\n        }\n        \n        for (int i = 0; i < 10; i++) {\n            for (int j = 0; j < 10; j++) {\n                Console.Write(\" {0}\", a[i, j]);\n                if (a[i, j] == 20) {\n                    goto Done;\n                }\n            }\n            Console.WriteLine();\n        }\n    Done:\n        Console.WriteLine();\n    }\n}\n"}
{"id": 92741, "name": "Loops_Nested", "source": "Translate Fortran to Java:       PROGRAM LOOPNESTED\n        INTEGER A, I, J, RNDINT\n\nC       Build a two-dimensional twenty-by-twenty array.\n        DIMENSION A(20,20)\n\nC       It doesn't matter what number you put here.\n        CALL SDRAND(123)\n\nC       Fill the array with random numbers.\n        DO 20 I = 1, 20\n          DO 10 J = 1, 20\n            A(I, J) = RNDINT(1, 20)\n   10     CONTINUE\n   20   CONTINUE\n\nC       Print the numbers.\n        DO 40 I = 1, 20\n          DO 30 J = 1, 20\n            WRITE (*,5000) I, J, A(I, J)\n\nC           If this number is twenty, break out of both loops.\n            IF (A(I, J) .EQ. 20) GOTO 50\n   30     CONTINUE\n   40   CONTINUE\n\nC       If we had gone to 40, the DO loop would have continued. You can\nC       label STOP instead of adding another CONTINUE, but it is good\nC       form to only label CONTINUE statements as much as possible.\n   50   CONTINUE\n        STOP\n\nC       Print the value so that it looks like one of those C arrays that\nC       makes everybody so comfortable.\n 5000   FORMAT('A[', I2, '][', I2, '] is ', I2)\n      END\n\nC FORTRAN 77 does not come with a random number generator, but it is\nC easy enough to type \"fortran 77 random number generator\" into your\nC preferred search engine and to copy and paste what you find. \nC The following code is a slightly-modified version of:\nC\nC     http://www.tat.physik.uni-tuebingen.de/\nC         ~kley/lehre/ftn77/tutorial/subprograms.html\n      SUBROUTINE SDRAND (IRSEED)\n        COMMON  /SEED/ UTSEED, IRFRST\n        UTSEED = IRSEED\n        IRFRST = 0\n        RETURN\n      END\n      INTEGER FUNCTION RNDINT (IFROM, ITO)\n        INTEGER IFROM, ITO\n        PARAMETER (MPLIER=16807, MODLUS=2147483647,                     &\n     &              MOBYMP=127773, MOMDMP=2836)\n        COMMON  /SEED/ UTSEED, IRFRST\n        INTEGER HVLUE, LVLUE, TESTV, NEXTN\n        SAVE    NEXTN\n        IF (IRFRST .EQ. 0) THEN\n          NEXTN = UTSEED\n          IRFRST = 1\n        ENDIF\n        HVLUE = NEXTN / MOBYMP\n        LVLUE = MOD(NEXTN, MOBYMP)\n        TESTV = MPLIER*LVLUE - MOMDMP*HVLUE\n        IF (TESTV .GT. 0) THEN\n          NEXTN = TESTV\n        ELSE\n          NEXTN = TESTV + MODLUS\n        ENDIF\n        IF (NEXTN .GE. 0) THEN\n          RNDINT = MOD(MOD(NEXTN, MODLUS), ITO - IFROM + 1) + IFROM\n        ELSE\n          RNDINT = MOD(MOD(NEXTN, MODLUS), ITO - IFROM + 1) + ITO + 1\n        ENDIF\n        RETURN\n      END\n", "target": "import java.util.Random;\n\npublic class NestedLoopTest {\n    public static final Random gen = new Random();\n    public static void main(String[] args) {\n        int[][] a = new int[10][10];\n        for (int i = 0; i < a.length; i++)\n            for (int j = 0; j < a[i].length; j++)\n                a[i][j] = gen.nextInt(20) + 1;\n\n        Outer:for (int i = 0; i < a.length; i++) {\n            for (int j = 0; j < a[i].length; j++) {\n                System.out.print(\" \" + a[i][j]);\n                if (a[i][j] == 20)\n                    break Outer; \n            }\n            System.out.println();\n        }\n        System.out.println();\n    }\n}\n"}
{"id": 92742, "name": "Loops_Nested", "source": "Translate Fortran to Python:       PROGRAM LOOPNESTED\n        INTEGER A, I, J, RNDINT\n\nC       Build a two-dimensional twenty-by-twenty array.\n        DIMENSION A(20,20)\n\nC       It doesn't matter what number you put here.\n        CALL SDRAND(123)\n\nC       Fill the array with random numbers.\n        DO 20 I = 1, 20\n          DO 10 J = 1, 20\n            A(I, J) = RNDINT(1, 20)\n   10     CONTINUE\n   20   CONTINUE\n\nC       Print the numbers.\n        DO 40 I = 1, 20\n          DO 30 J = 1, 20\n            WRITE (*,5000) I, J, A(I, J)\n\nC           If this number is twenty, break out of both loops.\n            IF (A(I, J) .EQ. 20) GOTO 50\n   30     CONTINUE\n   40   CONTINUE\n\nC       If we had gone to 40, the DO loop would have continued. You can\nC       label STOP instead of adding another CONTINUE, but it is good\nC       form to only label CONTINUE statements as much as possible.\n   50   CONTINUE\n        STOP\n\nC       Print the value so that it looks like one of those C arrays that\nC       makes everybody so comfortable.\n 5000   FORMAT('A[', I2, '][', I2, '] is ', I2)\n      END\n\nC FORTRAN 77 does not come with a random number generator, but it is\nC easy enough to type \"fortran 77 random number generator\" into your\nC preferred search engine and to copy and paste what you find. \nC The following code is a slightly-modified version of:\nC\nC     http://www.tat.physik.uni-tuebingen.de/\nC         ~kley/lehre/ftn77/tutorial/subprograms.html\n      SUBROUTINE SDRAND (IRSEED)\n        COMMON  /SEED/ UTSEED, IRFRST\n        UTSEED = IRSEED\n        IRFRST = 0\n        RETURN\n      END\n      INTEGER FUNCTION RNDINT (IFROM, ITO)\n        INTEGER IFROM, ITO\n        PARAMETER (MPLIER=16807, MODLUS=2147483647,                     &\n     &              MOBYMP=127773, MOMDMP=2836)\n        COMMON  /SEED/ UTSEED, IRFRST\n        INTEGER HVLUE, LVLUE, TESTV, NEXTN\n        SAVE    NEXTN\n        IF (IRFRST .EQ. 0) THEN\n          NEXTN = UTSEED\n          IRFRST = 1\n        ENDIF\n        HVLUE = NEXTN / MOBYMP\n        LVLUE = MOD(NEXTN, MOBYMP)\n        TESTV = MPLIER*LVLUE - MOMDMP*HVLUE\n        IF (TESTV .GT. 0) THEN\n          NEXTN = TESTV\n        ELSE\n          NEXTN = TESTV + MODLUS\n        ENDIF\n        IF (NEXTN .GE. 0) THEN\n          RNDINT = MOD(MOD(NEXTN, MODLUS), ITO - IFROM + 1) + IFROM\n        ELSE\n          RNDINT = MOD(MOD(NEXTN, MODLUS), ITO - IFROM + 1) + ITO + 1\n        ENDIF\n        RETURN\n      END\n", "target": "from random import randint\n\ndef do_scan(mat):\n    for row in mat:\n        for item in row:\n            print item,\n            if item == 20:\n                print\n                return\n        print\n    print\n\nmat = [[randint(1, 20) for x in xrange(10)] for y in xrange(10)]\ndo_scan(mat)\n"}
{"id": 93016, "name": "File input_output", "source": "Translate Fortran to C#: program FileIO\n\n  integer, parameter :: out = 123, in = 124\n  integer :: err\n  character :: c\n\n  open(out, file=\"output.txt\", status=\"new\", action=\"write\", access=\"stream\", iostat=err)\n  if (err == 0) then\n     open(in, file=\"input.txt\", status=\"old\", action=\"read\", access=\"stream\", iostat=err)\n     if (err == 0) then\n        err = 0\n        do while (err == 0)\n           read(unit=in, iostat=err) c\n           if (err == 0) write(out) c\n        end do\n        close(in)\n     end if\n     close(out)\n  end if\n\nend program FileIO\n", "target": "using System;\nusing System.IO;\n\nnamespace FileIO\n{\n  class Program\n  {\n    static void Main()\n    {\n      String s = scope .();\n      File.ReadAllText(\"input.txt\", s);\n      File.WriteAllText(\"output.txt\", s);\n    }\n  }\n}\n"}
{"id": 93019, "name": "File input_output", "source": "Translate Fortran to Java: program FileIO\n\n  integer, parameter :: out = 123, in = 124\n  integer :: err\n  character :: c\n\n  open(out, file=\"output.txt\", status=\"new\", action=\"write\", access=\"stream\", iostat=err)\n  if (err == 0) then\n     open(in, file=\"input.txt\", status=\"old\", action=\"read\", access=\"stream\", iostat=err)\n     if (err == 0) then\n        err = 0\n        do while (err == 0)\n           read(unit=in, iostat=err) c\n           if (err == 0) write(out) c\n        end do\n        close(in)\n     end if\n     close(out)\n  end if\n\nend program FileIO\n", "target": "import java.io.*;\n\npublic class FileIODemo {\n  public static void main(String[] args) {\n    try {\n      FileInputStream in = new FileInputStream(\"input.txt\");\n      FileOutputStream out = new FileOutputStream(\"ouput.txt\");\n      int c;\n      while ((c = in.read()) != -1) {\n        out.write(c);\n      }\n    } catch (FileNotFoundException e) {\n      e.printStackTrace();\n    } catch (IOException e){\n      e.printStackTrace();\n    }\n  }\n}\n"}
{"id": 93020, "name": "File input_output", "source": "Translate Fortran to Python: program FileIO\n\n  integer, parameter :: out = 123, in = 124\n  integer :: err\n  character :: c\n\n  open(out, file=\"output.txt\", status=\"new\", action=\"write\", access=\"stream\", iostat=err)\n  if (err == 0) then\n     open(in, file=\"input.txt\", status=\"old\", action=\"read\", access=\"stream\", iostat=err)\n     if (err == 0) then\n        err = 0\n        do while (err == 0)\n           read(unit=in, iostat=err) c\n           if (err == 0) write(out) c\n        end do\n        close(in)\n     end if\n     close(out)\n  end if\n\nend program FileIO\n", "target": "import shutil\nshutil.copyfile('input.txt', 'output.txt')\n"}
{"id": 93241, "name": "Sorting algorithms_Heapsort", "source": "Translate Fortran to C#: program Heapsort_Demo\n  implicit none\n  \n  integer, parameter :: num = 20\n  real :: array(num)\n    \n  call random_seed\n  call random_number(array)\n  write(*,*) \"Unsorted array:-\"\n  write(*,*) array\n  write(*,*)\n  call heapsort(array)\n  write(*,*) \"Sorted array:-\"\n  write(*,*) array\n  \ncontains\n\nsubroutine heapsort(a)\n\n   real, intent(in out) :: a(0:)\n   integer :: start, n, bottom\n   real :: temp\n\n   n = size(a)\n   do start = (n - 2) / 2, 0, -1\n     call siftdown(a, start, n);\n   end do\n   \n   do bottom = n - 1, 1, -1\n     temp = a(0)\n     a(0) = a(bottom)\n     a(bottom) = temp;\n     call siftdown(a, 0, bottom)\n   end do\n\nend subroutine heapsort\n\nsubroutine siftdown(a, start, bottom)\n  \n  real, intent(in out) :: a(0:)\n  integer, intent(in) :: start, bottom\n  integer :: child, root\n  real :: temp\n\n  root = start\n  do while(root*2 + 1 < bottom)\n    child = root * 2 + 1\n    \n    if (child + 1 < bottom) then\n      if (a(child) < a(child+1)) child = child + 1\n    end if\n    \n    if (a(root) < a(child)) then\n      temp = a(child)\n      a(child) = a (root)\n      a(root) = temp\n      root = child\n    else\n      return\n    end if  \n  end do      \n    \nend subroutine siftdown\n\nend program Heapsort_Demo\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Text;\n\npublic class HeapSortClass\n{\n    public static void HeapSort<T>(T[] array)\n    {\n        HeapSort<T>(array, 0, array.Length, Comparer<T>.Default);\n    }\n\n    public static void HeapSort<T>(T[] array, int offset, int length, IComparer<T> comparer)\n    {\n        HeapSort<T>(array, offset, length, comparer.Compare);\n    }\n\n    public static void HeapSort<T>(T[] array, int offset, int length, Comparison<T> comparison)\n    {\n        \n        for (int i = 0; i < length; i++)\n        {\n            int index = i;\n            T item = array[offset + i]; \n\n            \n            while (index > 0 &&\n                comparison(array[offset + (index - 1) / 2], item) < 0)\n            {\n                int top = (index - 1) / 2;\n                array[offset + index] = array[offset + top];\n                index = top;\n            }\n            array[offset + index] = item;\n        }\n\n        for (int i = length - 1; i > 0; i--)\n        {\n            \n            T last = array[offset + i];\n            array[offset + i] = array[offset];\n\n            int index = 0;\n            \n            while (index * 2 + 1 < i)\n            {\n                int left = index * 2 + 1, right = left + 1;\n\n                if (right < i && comparison(array[offset + left], array[offset + right]) < 0)\n                {\n                    if (comparison(last, array[offset + right]) > 0) break;\n\n                    array[offset + index] = array[offset + right];\n                    index = right;\n                }\n                else\n                {\n                    if (comparison(last, array[offset + left]) > 0) break;\n\n                    array[offset + index] = array[offset + left];\n                    index = left;\n                }\n            }\n            array[offset + index] = last;\n        }\n    }\n\n    static void Main()\n    {\n        \n        byte[] r = {5, 4, 1, 2};\n        HeapSort(r);\n\n        string[] s = { \"-\", \"D\", \"a\", \"33\" };\n        HeapSort(s, 0, s.Length, StringComparer.CurrentCultureIgnoreCase);\n    }\n}\n"}
{"id": 93245, "name": "Sorting algorithms_Heapsort", "source": "Translate Fortran to Java: program Heapsort_Demo\n  implicit none\n  \n  integer, parameter :: num = 20\n  real :: array(num)\n    \n  call random_seed\n  call random_number(array)\n  write(*,*) \"Unsorted array:-\"\n  write(*,*) array\n  write(*,*)\n  call heapsort(array)\n  write(*,*) \"Sorted array:-\"\n  write(*,*) array\n  \ncontains\n\nsubroutine heapsort(a)\n\n   real, intent(in out) :: a(0:)\n   integer :: start, n, bottom\n   real :: temp\n\n   n = size(a)\n   do start = (n - 2) / 2, 0, -1\n     call siftdown(a, start, n);\n   end do\n   \n   do bottom = n - 1, 1, -1\n     temp = a(0)\n     a(0) = a(bottom)\n     a(bottom) = temp;\n     call siftdown(a, 0, bottom)\n   end do\n\nend subroutine heapsort\n\nsubroutine siftdown(a, start, bottom)\n  \n  real, intent(in out) :: a(0:)\n  integer, intent(in) :: start, bottom\n  integer :: child, root\n  real :: temp\n\n  root = start\n  do while(root*2 + 1 < bottom)\n    child = root * 2 + 1\n    \n    if (child + 1 < bottom) then\n      if (a(child) < a(child+1)) child = child + 1\n    end if\n    \n    if (a(root) < a(child)) then\n      temp = a(child)\n      a(child) = a (root)\n      a(root) = temp\n      root = child\n    else\n      return\n    end if  \n  end do      \n    \nend subroutine siftdown\n\nend program Heapsort_Demo\n", "target": "public static void heapSort(int[] a){\n\tint count = a.length;\n\n\t\n\theapify(a, count);\n\n\tint end = count - 1;\n\twhile(end > 0){\n\t\t\n\t\t\n\t\tint tmp = a[end];\n\t\ta[end] = a[0];\n\t\ta[0] = tmp;\n\t\t\n\t\tsiftDown(a, 0, end - 1);\n\t\t\n\t\t\n\t\tend--;\n\t}\n}\n\npublic static void heapify(int[] a, int count){\n\t\n\tint start = (count - 2) / 2; \n\n\twhile(start >= 0){\n\t\t\n\t\t\n\t\t\n\t\tsiftDown(a, start, count - 1);\n\t\tstart--;\n\t}\n\t\n}\n\npublic static void siftDown(int[] a, int start, int end){\n\t\n\tint root = start;\n\n\twhile((root * 2 + 1) <= end){      \n\t\tint child = root * 2 + 1;           \n\t\t\n\t\tif(child + 1 <= end && a[child] < a[child + 1])\n\t\t\tchild = child + 1;           \n\t\tif(a[root] < a[child]){     \n\t\t\tint tmp = a[root];\n\t\t\ta[root] = a[child];\n\t\t\ta[child] = tmp;\n\t\t\troot = child;                \n\t\t}else\n\t\t\treturn;\n\t}\n}\n"}
{"id": 93246, "name": "Sorting algorithms_Heapsort", "source": "Translate Fortran to Python: program Heapsort_Demo\n  implicit none\n  \n  integer, parameter :: num = 20\n  real :: array(num)\n    \n  call random_seed\n  call random_number(array)\n  write(*,*) \"Unsorted array:-\"\n  write(*,*) array\n  write(*,*)\n  call heapsort(array)\n  write(*,*) \"Sorted array:-\"\n  write(*,*) array\n  \ncontains\n\nsubroutine heapsort(a)\n\n   real, intent(in out) :: a(0:)\n   integer :: start, n, bottom\n   real :: temp\n\n   n = size(a)\n   do start = (n - 2) / 2, 0, -1\n     call siftdown(a, start, n);\n   end do\n   \n   do bottom = n - 1, 1, -1\n     temp = a(0)\n     a(0) = a(bottom)\n     a(bottom) = temp;\n     call siftdown(a, 0, bottom)\n   end do\n\nend subroutine heapsort\n\nsubroutine siftdown(a, start, bottom)\n  \n  real, intent(in out) :: a(0:)\n  integer, intent(in) :: start, bottom\n  integer :: child, root\n  real :: temp\n\n  root = start\n  do while(root*2 + 1 < bottom)\n    child = root * 2 + 1\n    \n    if (child + 1 < bottom) then\n      if (a(child) < a(child+1)) child = child + 1\n    end if\n    \n    if (a(root) < a(child)) then\n      temp = a(child)\n      a(child) = a (root)\n      a(root) = temp\n      root = child\n    else\n      return\n    end if  \n  end do      \n    \nend subroutine siftdown\n\nend program Heapsort_Demo\n", "target": "def heapsort(lst):\n  \n\n  \n  for start in range((len(lst)-2)/2, -1, -1):\n    siftdown(lst, start, len(lst)-1)\n\n  for end in range(len(lst)-1, 0, -1):\n    lst[end], lst[0] = lst[0], lst[end]\n    siftdown(lst, 0, end - 1)\n  return lst\n\ndef siftdown(lst, start, end):\n  root = start\n  while True:\n    child = root * 2 + 1\n    if child > end: break\n    if child + 1 <= end and lst[child] < lst[child + 1]:\n      child += 1\n    if lst[root] < lst[child]:\n      lst[root], lst[child] = lst[child], lst[root]\n      root = child\n    else:\n      break\n"}
{"id": 93956, "name": "Sum and product of an array", "source": "Translate Fortran to C#: integer, dimension(10) :: a = (/ (i, i=1, 10) /)\ninteger :: sresult, presult\n\nsresult = sum(a)\npresult = product(a)\n", "target": "int sum = 0, prod = 1;\nint[] arg = { 1, 2, 3, 4, 5 };\nforeach (int value in arg) {\n  sum += value;\n  prod *= value;\n}\n"}
{"id": 93959, "name": "Sum and product of an array", "source": "Translate Fortran to Java: integer, dimension(10) :: a = (/ (i, i=1, 10) /)\ninteger :: sresult, presult\n\nsresult = sum(a)\npresult = product(a)\n", "target": "public class SumProd\n{\n public static void main(final String[] args)\n {\n  int sum = 0;\n  int prod = 1;\n  int[] arg = {1,2,3,4,5};\n  for (int i : arg)\n  {\n   sum += i;\n   prod *= i;\n  }\n }\n}\n"}
{"id": 93960, "name": "Sum and product of an array", "source": "Translate Fortran to Python: integer, dimension(10) :: a = (/ (i, i=1, 10) /)\ninteger :: sresult, presult\n\nsresult = sum(a)\npresult = product(a)\n", "target": "numbers = [1, 2, 3]\ntotal = sum(numbers)\n\nproduct = 1\nfor i in numbers:\n    product *= i\n"}
{"id": 94347, "name": "100 doors", "source": "Translate Fortran to C#: program doors\n    implicit none\n    integer, allocatable :: door(:)\n    character(6), parameter :: s(0:1) = [character(6) :: \"closed\", \"open\"]\n    integer :: i, n\n  \n    print \"(A)\", \"Number of doors?\"\n    read *, n\n    allocate (door(n))\n    door = 1\n    do i = 1, n\n        door(i:n:i) = 1 - door(i:n:i)\n        print \"(A,G0,2A)\", \"door \", i, \" is \", s(door(i))\n    end do\nend program\n", "target": "namespace ConsoleApplication1\n{\n    using System;\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            bool[] doors = new bool[100];\n\n            \n            for (int d = 0; d < 100; d++) doors[d] = false;\n\n            \n            for (int p = 0; p < 100; p++)\n            {\n                \n                for (int d = 0; d < 100; d++)\n                {\n                    if ((d + 1) % (p + 1) == 0)\n                    {\n                        doors[d] = !doors[d];\n                    }\n                }\n            }\n\n            \n            Console.WriteLine(\"Passes Completed!!!  Here are the results: \\r\\n\");\n            for (int d = 0; d < 100; d++)\n            {\n                if (doors[d])\n                {\n                    Console.WriteLine(String.Format(\"Door #{0}: Open\", d + 1));\n                }\n                else\n                {\n                    Console.WriteLine(String.Format(\"Door #{0}: Closed\", d + 1));\n                }\n            }\n            Console.ReadKey(true);\n        }\n    }\n}\n"}
{"id": 94348, "name": "100 doors", "source": "Translate Fortran to C#: program doors\n    implicit none\n    integer, allocatable :: door(:)\n    character(6), parameter :: s(0:1) = [character(6) :: \"closed\", \"open\"]\n    integer :: i, n\n  \n    print \"(A)\", \"Number of doors?\"\n    read *, n\n    allocate (door(n))\n    door = 1\n    do i = 1, n\n        door(i:n:i) = 1 - door(i:n:i)\n        print \"(A,G0,2A)\", \"door \", i, \" is \", s(door(i))\n    end do\nend program\n", "target": "namespace ConsoleApplication1\n{\n    using System;\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            bool[] doors = new bool[100];\n\n            \n            for (int d = 0; d < 100; d++) doors[d] = false;\n\n            \n            for (int p = 0; p < 100; p++)\n            {\n                \n                for (int d = 0; d < 100; d++)\n                {\n                    if ((d + 1) % (p + 1) == 0)\n                    {\n                        doors[d] = !doors[d];\n                    }\n                }\n            }\n\n            \n            Console.WriteLine(\"Passes Completed!!!  Here are the results: \\r\\n\");\n            for (int d = 0; d < 100; d++)\n            {\n                if (doors[d])\n                {\n                    Console.WriteLine(String.Format(\"Door #{0}: Open\", d + 1));\n                }\n                else\n                {\n                    Console.WriteLine(String.Format(\"Door #{0}: Closed\", d + 1));\n                }\n            }\n            Console.ReadKey(true);\n        }\n    }\n}\n"}
{"id": 94354, "name": "100 doors", "source": "Translate Fortran to Java: program doors\n    implicit none\n    integer, allocatable :: door(:)\n    character(6), parameter :: s(0:1) = [character(6) :: \"closed\", \"open\"]\n    integer :: i, n\n  \n    print \"(A)\", \"Number of doors?\"\n    read *, n\n    allocate (door(n))\n    door = 1\n    do i = 1, n\n        door(i:n:i) = 1 - door(i:n:i)\n        print \"(A,G0,2A)\", \"door \", i, \" is \", s(door(i))\n    end do\nend program\n", "target": "module OneHundredDoors\n    {\n    @Inject Console console;\n\n    void run()\n        {\n        Boolean[] doors = new Boolean[100];\n        for (Int pass : 0 ..< 100)\n            {\n            for (Int door = pass; door < 100; door += 1+pass)\n                {\n                doors[door] = !doors[door];\n                }\n            }\n\n        console.print($\"open doors: {doors.mapIndexed((d, i) -> d\u00a0? i+1\u00a0: 0).filter(i -> i > 0)}\");\n        }\n    }\n"}
{"id": 94355, "name": "100 doors", "source": "Translate Fortran to Java: program doors\n    implicit none\n    integer, allocatable :: door(:)\n    character(6), parameter :: s(0:1) = [character(6) :: \"closed\", \"open\"]\n    integer :: i, n\n  \n    print \"(A)\", \"Number of doors?\"\n    read *, n\n    allocate (door(n))\n    door = 1\n    do i = 1, n\n        door(i:n:i) = 1 - door(i:n:i)\n        print \"(A,G0,2A)\", \"door \", i, \" is \", s(door(i))\n    end do\nend program\n", "target": "module OneHundredDoors\n    {\n    @Inject Console console;\n\n    void run()\n        {\n        Boolean[] doors = new Boolean[100];\n        for (Int pass : 0 ..< 100)\n            {\n            for (Int door = pass; door < 100; door += 1+pass)\n                {\n                doors[door] = !doors[door];\n                }\n            }\n\n        console.print($\"open doors: {doors.mapIndexed((d, i) -> d\u00a0? i+1\u00a0: 0).filter(i -> i > 0)}\");\n        }\n    }\n"}
{"id": 94356, "name": "100 doors", "source": "Translate Fortran to Python: program doors\n    implicit none\n    integer, allocatable :: door(:)\n    character(6), parameter :: s(0:1) = [character(6) :: \"closed\", \"open\"]\n    integer :: i, n\n  \n    print \"(A)\", \"Number of doors?\"\n    read *, n\n    allocate (door(n))\n    door = 1\n    do i = 1, n\n        door(i:n:i) = 1 - door(i:n:i)\n        print \"(A,G0,2A)\", \"door \", i, \" is \", s(door(i))\n    end do\nend program\n", "target": "var doors = falses(100)\n\nfor a in 1..100: for b in a..a..100:\n    doors[b] = not doors[b]\n\nfor a in 1..100:\n    print \"Door $a is ${(doors[a])\u00a0? 'open.': 'closed.'}\"\n"}
{"id": 94357, "name": "100 doors", "source": "Translate Fortran to Python: program doors\n    implicit none\n    integer, allocatable :: door(:)\n    character(6), parameter :: s(0:1) = [character(6) :: \"closed\", \"open\"]\n    integer :: i, n\n  \n    print \"(A)\", \"Number of doors?\"\n    read *, n\n    allocate (door(n))\n    door = 1\n    do i = 1, n\n        door(i:n:i) = 1 - door(i:n:i)\n        print \"(A,G0,2A)\", \"door \", i, \" is \", s(door(i))\n    end do\nend program\n", "target": "var doors = falses(100)\n\nfor a in 1..100: for b in a..a..100:\n    doors[b] = not doors[b]\n\nfor a in 1..100:\n    print \"Door $a is ${(doors[a])\u00a0? 'open.': 'closed.'}\"\n"}
{"id": 94879, "name": "Anti-primes", "source": "Translate Fortran to C#: program anti_primes\n    use iso_fortran_env, only: output_unit\n    implicit none\n\n    integer :: n, d, maxDiv, pCount\n\n    write(output_unit,*) \"The first 20 anti-primes are:\"\n    n = 1\n    maxDiv = 0\n    pCount = 0\n    do\n        if (pCount >= 20) exit\n\n        d = countDivisors(n)\n        if (d > maxDiv) then\n            write(output_unit,'(I0,x)', advance=\"no\") n\n            maxDiv = d\n            pCount = pCount + 1\n        end if\n        n = n + 1\n    end do\n    write(output_unit,*)\ncontains\n    pure function countDivisors(n)\n        integer, intent(in) :: n\n        integer             :: countDivisors\n        integer             :: i\n\n        countDivisors = 1\n        if (n < 2) return\n        countDivisors = 2\n        do i = 2, n/2\n            if (modulo(n, i) == 0) countDivisors = countDivisors + 1\n        end do\n    end function countDivisors\nend program anti_primes\n", "target": "using System;\nusing System.Linq;\nusing System.Collections.Generic;\n\t\t\t\t\t\npublic static class Program\n{\n    public static void Main() =>\n        Console.WriteLine(string.Join(\" \", FindAntiPrimes().Take(20)));\n\t\n    static IEnumerable<int> FindAntiPrimes() {\n        int max = 0;\n        for (int i = 1; ; i++) {\n            int divisors = CountDivisors(i);\n            if (divisors > max) {\n                max = divisors;\n                yield return i;\n            }\n        }\n\t\n        int CountDivisors(int n) => Enumerable.Range(1, n / 2).Count(i => n % i == 0) + 1;\n    }\n}\n"}
{"id": 94880, "name": "Anti-primes", "source": "Translate Fortran to C#: program anti_primes\n    use iso_fortran_env, only: output_unit\n    implicit none\n\n    integer :: n, d, maxDiv, pCount\n\n    write(output_unit,*) \"The first 20 anti-primes are:\"\n    n = 1\n    maxDiv = 0\n    pCount = 0\n    do\n        if (pCount >= 20) exit\n\n        d = countDivisors(n)\n        if (d > maxDiv) then\n            write(output_unit,'(I0,x)', advance=\"no\") n\n            maxDiv = d\n            pCount = pCount + 1\n        end if\n        n = n + 1\n    end do\n    write(output_unit,*)\ncontains\n    pure function countDivisors(n)\n        integer, intent(in) :: n\n        integer             :: countDivisors\n        integer             :: i\n\n        countDivisors = 1\n        if (n < 2) return\n        countDivisors = 2\n        do i = 2, n/2\n            if (modulo(n, i) == 0) countDivisors = countDivisors + 1\n        end do\n    end function countDivisors\nend program anti_primes\n", "target": "using System;\nusing System.Linq;\nusing System.Collections.Generic;\n\t\t\t\t\t\npublic static class Program\n{\n    public static void Main() =>\n        Console.WriteLine(string.Join(\" \", FindAntiPrimes().Take(20)));\n\t\n    static IEnumerable<int> FindAntiPrimes() {\n        int max = 0;\n        for (int i = 1; ; i++) {\n            int divisors = CountDivisors(i);\n            if (divisors > max) {\n                max = divisors;\n                yield return i;\n            }\n        }\n\t\n        int CountDivisors(int n) => Enumerable.Range(1, n / 2).Count(i => n % i == 0) + 1;\n    }\n}\n"}
{"id": 94886, "name": "Anti-primes", "source": "Translate Fortran to Java: program anti_primes\n    use iso_fortran_env, only: output_unit\n    implicit none\n\n    integer :: n, d, maxDiv, pCount\n\n    write(output_unit,*) \"The first 20 anti-primes are:\"\n    n = 1\n    maxDiv = 0\n    pCount = 0\n    do\n        if (pCount >= 20) exit\n\n        d = countDivisors(n)\n        if (d > maxDiv) then\n            write(output_unit,'(I0,x)', advance=\"no\") n\n            maxDiv = d\n            pCount = pCount + 1\n        end if\n        n = n + 1\n    end do\n    write(output_unit,*)\ncontains\n    pure function countDivisors(n)\n        integer, intent(in) :: n\n        integer             :: countDivisors\n        integer             :: i\n\n        countDivisors = 1\n        if (n < 2) return\n        countDivisors = 2\n        do i = 2, n/2\n            if (modulo(n, i) == 0) countDivisors = countDivisors + 1\n        end do\n    end function countDivisors\nend program anti_primes\n", "target": "public class Antiprime {\n\n    static int countDivisors(int n) {\n        if (n < 2) return 1;\n        int count = 2; \n        for (int i = 2; i <= n/2; ++i) {\n            if (n%i == 0) ++count;\n        }\n        return count;\n    }\n\n    public static void main(String[] args) {\n        int maxDiv = 0, count = 0;\n        System.out.println(\"The first 20 anti-primes are:\");\n        for (int n = 1; count < 20; ++n) {\n            int d = countDivisors(n);\n            if (d > maxDiv) {\n                System.out.printf(\"%d \", n);\n                maxDiv = d;\n                count++;\n            }\n        }\n        System.out.println();\n    }\n}\n"}
{"id": 94887, "name": "Anti-primes", "source": "Translate Fortran to Java: program anti_primes\n    use iso_fortran_env, only: output_unit\n    implicit none\n\n    integer :: n, d, maxDiv, pCount\n\n    write(output_unit,*) \"The first 20 anti-primes are:\"\n    n = 1\n    maxDiv = 0\n    pCount = 0\n    do\n        if (pCount >= 20) exit\n\n        d = countDivisors(n)\n        if (d > maxDiv) then\n            write(output_unit,'(I0,x)', advance=\"no\") n\n            maxDiv = d\n            pCount = pCount + 1\n        end if\n        n = n + 1\n    end do\n    write(output_unit,*)\ncontains\n    pure function countDivisors(n)\n        integer, intent(in) :: n\n        integer             :: countDivisors\n        integer             :: i\n\n        countDivisors = 1\n        if (n < 2) return\n        countDivisors = 2\n        do i = 2, n/2\n            if (modulo(n, i) == 0) countDivisors = countDivisors + 1\n        end do\n    end function countDivisors\nend program anti_primes\n", "target": "public class Antiprime {\n\n    static int countDivisors(int n) {\n        if (n < 2) return 1;\n        int count = 2; \n        for (int i = 2; i <= n/2; ++i) {\n            if (n%i == 0) ++count;\n        }\n        return count;\n    }\n\n    public static void main(String[] args) {\n        int maxDiv = 0, count = 0;\n        System.out.println(\"The first 20 anti-primes are:\");\n        for (int n = 1; count < 20; ++n) {\n            int d = countDivisors(n);\n            if (d > maxDiv) {\n                System.out.printf(\"%d \", n);\n                maxDiv = d;\n                count++;\n            }\n        }\n        System.out.println();\n    }\n}\n"}
{"id": 94888, "name": "Anti-primes", "source": "Translate Fortran to Python: program anti_primes\n    use iso_fortran_env, only: output_unit\n    implicit none\n\n    integer :: n, d, maxDiv, pCount\n\n    write(output_unit,*) \"The first 20 anti-primes are:\"\n    n = 1\n    maxDiv = 0\n    pCount = 0\n    do\n        if (pCount >= 20) exit\n\n        d = countDivisors(n)\n        if (d > maxDiv) then\n            write(output_unit,'(I0,x)', advance=\"no\") n\n            maxDiv = d\n            pCount = pCount + 1\n        end if\n        n = n + 1\n    end do\n    write(output_unit,*)\ncontains\n    pure function countDivisors(n)\n        integer, intent(in) :: n\n        integer             :: countDivisors\n        integer             :: i\n\n        countDivisors = 1\n        if (n < 2) return\n        countDivisors = 2\n        do i = 2, n/2\n            if (modulo(n, i) == 0) countDivisors = countDivisors + 1\n        end do\n    end function countDivisors\nend program anti_primes\n", "target": "from itertools import chain, count, cycle, islice, accumulate\n \ndef factors(n):\n    def prime_powers(n):\n        for c in accumulate(chain([2, 1, 2], cycle([2,4]))):\n            if c*c > n: break\n            if n%c: continue\n            d,p = (), c\n            while not n%c:\n                n,p,d = n//c, p*c, d+(p,)\n            yield d\n        if n > 1: yield n,\n \n    r = [1]\n    for e in prime_powers(n):\n        r += [a*b for a in r for b in e]\n    return r\n    \ndef antiprimes():\n    mx = 0\n    yield 1\n    for c in count(2,2):\n        if c >= 58: break\n        ln = len(factors(c))\n        if ln > mx:\n            yield c\n            mx = ln\n    for c in count(60,30):\n        ln = len(factors(c))\n        if ln > mx:\n            yield c\n            mx = ln  \n\nif __name__ == '__main__':\n    print(*islice(antiprimes(), 40)))\n"}
{"id": 94889, "name": "Anti-primes", "source": "Translate Fortran to Python: program anti_primes\n    use iso_fortran_env, only: output_unit\n    implicit none\n\n    integer :: n, d, maxDiv, pCount\n\n    write(output_unit,*) \"The first 20 anti-primes are:\"\n    n = 1\n    maxDiv = 0\n    pCount = 0\n    do\n        if (pCount >= 20) exit\n\n        d = countDivisors(n)\n        if (d > maxDiv) then\n            write(output_unit,'(I0,x)', advance=\"no\") n\n            maxDiv = d\n            pCount = pCount + 1\n        end if\n        n = n + 1\n    end do\n    write(output_unit,*)\ncontains\n    pure function countDivisors(n)\n        integer, intent(in) :: n\n        integer             :: countDivisors\n        integer             :: i\n\n        countDivisors = 1\n        if (n < 2) return\n        countDivisors = 2\n        do i = 2, n/2\n            if (modulo(n, i) == 0) countDivisors = countDivisors + 1\n        end do\n    end function countDivisors\nend program anti_primes\n", "target": "from itertools import chain, count, cycle, islice, accumulate\n \ndef factors(n):\n    def prime_powers(n):\n        for c in accumulate(chain([2, 1, 2], cycle([2,4]))):\n            if c*c > n: break\n            if n%c: continue\n            d,p = (), c\n            while not n%c:\n                n,p,d = n//c, p*c, d+(p,)\n            yield d\n        if n > 1: yield n,\n \n    r = [1]\n    for e in prime_powers(n):\n        r += [a*b for a in r for b in e]\n    return r\n    \ndef antiprimes():\n    mx = 0\n    yield 1\n    for c in count(2,2):\n        if c >= 58: break\n        ln = len(factors(c))\n        if ln > mx:\n            yield c\n            mx = ln\n    for c in count(60,30):\n        ln = len(factors(c))\n        if ln > mx:\n            yield c\n            mx = ln  \n\nif __name__ == '__main__':\n    print(*islice(antiprimes(), 40)))\n"}
{"id": 95219, "name": "Bitmap_Bresenham's line algorithm", "source": "Translate Fortran to C#: module RCImagePrimitive\n  use RCImageBasic\n\n  implicit none\n\n  type point\n     integer :: x, y\n  end type point\n\n  private :: swapcoord\n\ncontains\n\n  subroutine swapcoord(p1, p2)\n    integer, intent(inout) :: p1, p2\n    integer :: t\n\n    t = p2\n    p2 = p1\n    p1 = t\n  end subroutine swapcoord\n\n  subroutine draw_line(img, from, to, color)\n    type(rgbimage), intent(inout) :: img\n    type(point), intent(in) :: from, to\n    type(rgb), intent(in) :: color\n\n    type(point) :: rfrom, rto\n    integer :: dx, dy, error, ystep, x, y\n    logical :: steep\n\n    rfrom = from\n    rto = to\n    steep = (abs(rto%y - rfrom%y) > abs(rto%x - rfrom%x))\n    if ( steep ) then\n       call swapcoord(rfrom%x, rfrom%y)\n       call swapcoord(rto%x, rto%y)\n    end if\n    if ( rfrom%x > rto%x ) then\n       call swapcoord(rfrom%x, rto%x)\n       call swapcoord(rfrom%y, rto%y)\n    end if\n\n    dx = rto%x - rfrom%x\n    dy = abs(rto%y - rfrom%y)\n    error = dx / 2\n    y = rfrom%y\n\n    if ( rfrom%y < rto%y ) then\n       ystep = 1\n    else\n       ystep = -1\n    end if\n\n    do x = rfrom%x, rto%x\n       if ( steep ) then\n          call put_pixel(img, y, x, color)\n       else \n          call put_pixel(img, x, y, color)\n       end if\n       error = error - dy\n       if ( error < 0 ) then\n          y = y + ystep\n          error = error + dx\n       end if\n    end do\n\n  end subroutine draw_line\n\nend module RCImagePrimitive\n", "target": "using System;\nusing System.Drawing;\nusing System.Drawing.Imaging;\nstatic class Program\n{\n    static void Main()\n    {\n        new Bitmap(200, 200)\n            .DrawLine(0, 0, 199, 199, Color.Black).DrawLine(199,0,0,199,Color.Black)\n            .DrawLine(50, 75, 150, 125, Color.Blue).DrawLine(150, 75, 50, 125, Color.Blue)\n            .Save(\"line.png\", ImageFormat.Png);\n    }\n    static Bitmap DrawLine(this Bitmap bitmap, int x0, int y0, int x1, int y1, Color color)\n    {\n        int dx = Math.Abs(x1 - x0), sx = x0 < x1 ? 1 : -1;\n        int dy = Math.Abs(y1 - y0), sy = y0 < y1 ? 1 : -1;\n        int err = (dx > dy ? dx : -dy) / 2, e2;\n        for(;;) {\n            bitmap.SetPixel(x0, y0, color);\n            if (x0 == x1 && y0 == y1) break;\n            e2 = err;\n            if (e2 > -dx) { err -= dy; x0 += sx; }\n            if (e2 < dy) { err += dx; y0 += sy; }\n        }\n        return bitmap;\n    }\n}\n"}
{"id": 95222, "name": "Bitmap_Bresenham's line algorithm", "source": "Translate Fortran to Java: module RCImagePrimitive\n  use RCImageBasic\n\n  implicit none\n\n  type point\n     integer :: x, y\n  end type point\n\n  private :: swapcoord\n\ncontains\n\n  subroutine swapcoord(p1, p2)\n    integer, intent(inout) :: p1, p2\n    integer :: t\n\n    t = p2\n    p2 = p1\n    p1 = t\n  end subroutine swapcoord\n\n  subroutine draw_line(img, from, to, color)\n    type(rgbimage), intent(inout) :: img\n    type(point), intent(in) :: from, to\n    type(rgb), intent(in) :: color\n\n    type(point) :: rfrom, rto\n    integer :: dx, dy, error, ystep, x, y\n    logical :: steep\n\n    rfrom = from\n    rto = to\n    steep = (abs(rto%y - rfrom%y) > abs(rto%x - rfrom%x))\n    if ( steep ) then\n       call swapcoord(rfrom%x, rfrom%y)\n       call swapcoord(rto%x, rto%y)\n    end if\n    if ( rfrom%x > rto%x ) then\n       call swapcoord(rfrom%x, rto%x)\n       call swapcoord(rfrom%y, rto%y)\n    end if\n\n    dx = rto%x - rfrom%x\n    dy = abs(rto%y - rfrom%y)\n    error = dx / 2\n    y = rfrom%y\n\n    if ( rfrom%y < rto%y ) then\n       ystep = 1\n    else\n       ystep = -1\n    end if\n\n    do x = rfrom%x, rto%x\n       if ( steep ) then\n          call put_pixel(img, y, x, color)\n       else \n          call put_pixel(img, x, y, color)\n       end if\n       error = error - dy\n       if ( error < 0 ) then\n          y = y + ystep\n          error = error + dx\n       end if\n    end do\n\n  end subroutine draw_line\n\nend module RCImagePrimitive\n", "target": "import java.awt.Color;\nimport java.awt.Dimension;\nimport java.awt.Graphics;\nimport javax.swing.JFrame;\nimport javax.swing.JPanel;\nimport javax.swing.SwingUtilities;\nimport javax.swing.WindowConstants;\n\npublic class Bresenham {\n\n    public static void main(String[] args) {\n        SwingUtilities.invokeLater(Bresenham::run);\n    }\n\n    private static void run() {\n        JFrame f = new JFrame();\n        f.setDefaultCloseOperation(WindowConstants.DISPOSE_ON_CLOSE);\n        f.setTitle(\"Bresenham\");\n\n        f.getContentPane().add(new BresenhamPanel());\n        f.pack();\n\n        f.setLocationRelativeTo(null);\n        f.setVisible(true);\n    }\n}\n\nclass BresenhamPanel extends JPanel {\n\n    private final int pixelSize = 10;\n\n    BresenhamPanel() {\n        setPreferredSize(new Dimension(600, 500));\n        setBackground(Color.WHITE);\n    }\n\n    @Override\n    public void paintComponent(Graphics g) {\n        super.paintComponent(g);\n\n        int w = (getWidth() - 1) / pixelSize;\n        int h = (getHeight() - 1) / pixelSize;\n        int maxX = (w - 1) / 2;\n        int maxY = (h - 1) / 2;\n        int x1 = -maxX, x2 = maxX * -2 / 3, x3 = maxX * 2 / 3, x4 = maxX;\n        int y1 = -maxY, y2 = maxY * -2 / 3, y3 = maxY * 2 / 3, y4 = maxY;\n\n        drawLine(g, 0, 0, x3, y1); \n        drawLine(g, 0, 0, x4, y2); \n        drawLine(g, 0, 0, x4, y3); \n        drawLine(g, 0, 0, x3, y4); \n        drawLine(g, 0, 0, x2, y4); \n        drawLine(g, 0, 0, x1, y3); \n        drawLine(g, 0, 0, x1, y2); \n        drawLine(g, 0, 0, x2, y1); \n    }\n\n    private void plot(Graphics g, int x, int y) {\n        int w = (getWidth() - 1) / pixelSize;\n        int h = (getHeight() - 1) / pixelSize;\n        int maxX = (w - 1) / 2;\n        int maxY = (h - 1) / 2;\n\n        int borderX = getWidth() - ((2 * maxX + 1) * pixelSize + 1);\n        int borderY = getHeight() - ((2 * maxY + 1) * pixelSize + 1);\n        int left = (x + maxX) * pixelSize + borderX / 2;\n        int top = (y + maxY) * pixelSize + borderY / 2;\n\n        g.setColor(Color.black);\n        g.drawOval(left, top, pixelSize, pixelSize);\n    }\n\n    private void drawLine(Graphics g, int x1, int y1, int x2, int y2) {\n        \n        int d = 0;\n\n        int dx = Math.abs(x2 - x1);\n        int dy = Math.abs(y2 - y1);\n\n        int dx2 = 2 * dx; \n        int dy2 = 2 * dy; \n\n        int ix = x1 < x2 ? 1 : -1; \n        int iy = y1 < y2 ? 1 : -1;\n\n        int x = x1;\n        int y = y1;\n\n        if (dx >= dy) {\n            while (true) {\n                plot(g, x, y);\n                if (x == x2)\n                    break;\n                x += ix;\n                d += dy2;\n                if (d > dx) {\n                    y += iy;\n                    d -= dx2;\n                }\n            }\n        } else {\n            while (true) {\n                plot(g, x, y);\n                if (y == y2)\n                    break;\n                y += iy;\n                d += dx2;\n                if (d > dy) {\n                    x += ix;\n                    d -= dy2;\n                }\n            }\n        }\n    }\n}\n"}
{"id": 95223, "name": "Bitmap_Bresenham's line algorithm", "source": "Translate Fortran to Python: module RCImagePrimitive\n  use RCImageBasic\n\n  implicit none\n\n  type point\n     integer :: x, y\n  end type point\n\n  private :: swapcoord\n\ncontains\n\n  subroutine swapcoord(p1, p2)\n    integer, intent(inout) :: p1, p2\n    integer :: t\n\n    t = p2\n    p2 = p1\n    p1 = t\n  end subroutine swapcoord\n\n  subroutine draw_line(img, from, to, color)\n    type(rgbimage), intent(inout) :: img\n    type(point), intent(in) :: from, to\n    type(rgb), intent(in) :: color\n\n    type(point) :: rfrom, rto\n    integer :: dx, dy, error, ystep, x, y\n    logical :: steep\n\n    rfrom = from\n    rto = to\n    steep = (abs(rto%y - rfrom%y) > abs(rto%x - rfrom%x))\n    if ( steep ) then\n       call swapcoord(rfrom%x, rfrom%y)\n       call swapcoord(rto%x, rto%y)\n    end if\n    if ( rfrom%x > rto%x ) then\n       call swapcoord(rfrom%x, rto%x)\n       call swapcoord(rfrom%y, rto%y)\n    end if\n\n    dx = rto%x - rfrom%x\n    dy = abs(rto%y - rfrom%y)\n    error = dx / 2\n    y = rfrom%y\n\n    if ( rfrom%y < rto%y ) then\n       ystep = 1\n    else\n       ystep = -1\n    end if\n\n    do x = rfrom%x, rto%x\n       if ( steep ) then\n          call put_pixel(img, y, x, color)\n       else \n          call put_pixel(img, x, y, color)\n       end if\n       error = error - dy\n       if ( error < 0 ) then\n          y = y + ystep\n          error = error + dx\n       end if\n    end do\n\n  end subroutine draw_line\n\nend module RCImagePrimitive\n", "target": "def line(self, x0, y0, x1, y1):\n    \"Bresenham's line algorithm\"\n    dx = abs(x1 - x0)\n    dy = abs(y1 - y0)\n    x, y = x0, y0\n    sx = -1 if x0 > x1 else 1\n    sy = -1 if y0 > y1 else 1\n    if dx > dy:\n        err = dx / 2.0\n        while x != x1:\n            self.set(x, y)\n            err -= dy\n            if err < 0:\n                y += sy\n                err += dx\n            x += sx\n    else:\n        err = dy / 2.0\n        while y != y1:\n            self.set(x, y)\n            err -= dx\n            if err < 0:\n                x += sx\n                err += dy\n            y += sy        \n    self.set(x, y)\nBitmap.line = line\n\nbitmap = Bitmap(17,17)\nfor points in ((1,8,8,16),(8,16,16,8),(16,8,8,1),(8,1,1,8)):\n    bitmap.line(*points)\nbitmap.chardisplay()\n\n\n"}
{"id": 95384, "name": "Hello world_Web server", "source": "Translate Fortran to C#: program http_example\n   implicit none\n   character (len=:), allocatable :: code\n   character (len=:), allocatable :: command\n   logical :: waitForProcess\n\n   \n   code = \"const http = require('http'); http.createServer((req, res) => &\n   {res.end('Hello World from a Node.js server started from Fortran\n\n   command = 'node -e \"' // code // '\"'\n   call execute_command_line (command, wait=waitForProcess)\n\nend program http_example\n", "target": "using System.Text;\nusing System.Net.Sockets;\nusing System.Net;\n\nnamespace WebServer\n{\n    class GoodByeWorld\n    {        \n        static void Main(string[] args)\n        {\n            const string msg = \"<html>\\n<body>\\nGoodbye, world!\\n</body>\\n</html>\\n\";        \n            const int port = 8080;\n            bool serverRunning = true;\n\n            TcpListener tcpListener = new TcpListener(IPAddress.Any, port);\n            tcpListener.Start();\n\n            while (serverRunning)\n            {\n                Socket socketConnection = tcpListener.AcceptSocket();\n                byte[] bMsg = Encoding.ASCII.GetBytes(msg.ToCharArray(), 0, (int)msg.Length);\n                socketConnection.Send(bMsg);\n                socketConnection.Disconnect(true);\n            }\n        }\n    }\n}\n"}
{"id": 95387, "name": "Hello world_Web server", "source": "Translate Fortran to Java: program http_example\n   implicit none\n   character (len=:), allocatable :: code\n   character (len=:), allocatable :: command\n   logical :: waitForProcess\n\n   \n   code = \"const http = require('http'); http.createServer((req, res) => &\n   {res.end('Hello World from a Node.js server started from Fortran\n\n   command = 'node -e \"' // code // '\"'\n   call execute_command_line (command, wait=waitForProcess)\n\nend program http_example\n", "target": "import java.io.IOException;\nimport java.io.PrintWriter;\nimport java.net.ServerSocket;\nimport java.net.Socket;\n\npublic class HelloWorld{\n  public static void main(String[] args) throws IOException{\n    ServerSocket listener = new ServerSocket(8080);\n    while(true){\n      Socket sock = listener.accept();\n      new PrintWriter(sock.getOutputStream(), true).\n                println(\"Goodbye, World!\");\n      sock.close();\n    }\n  }\n}\n"}
{"id": 95388, "name": "Hello world_Web server", "source": "Translate Fortran to Python: program http_example\n   implicit none\n   character (len=:), allocatable :: code\n   character (len=:), allocatable :: command\n   logical :: waitForProcess\n\n   \n   code = \"const http = require('http'); http.createServer((req, res) => &\n   {res.end('Hello World from a Node.js server started from Fortran\n\n   command = 'node -e \"' // code // '\"'\n   call execute_command_line (command, wait=waitForProcess)\n\nend program http_example\n", "target": "from wsgiref.simple_server import make_server\n\ndef app(environ, start_response):\n    start_response('200 OK', [('Content-Type','text/html')])\n    yield b\"<h1>Goodbye, World!</h1>\"\n\nserver = make_server('127.0.0.1', 8080, app)\nserver.serve_forever()\n"}
{"id": 95596, "name": "Knuth shuffle", "source": "Translate Fortran to C#: program Knuth_Shuffle\n  implicit none\n\n  integer, parameter :: reps = 1000000\n  integer :: i, n\n  integer, dimension(10) :: a, bins = 0, initial = (/ (n, n=1,10) /) \n\n  do i = 1, reps\n    a = initial\n \tcall Shuffle(a)\n    where (a == initial) bins = bins + 1  \n  end do\n  write(*, \"(10(i8))\") bins\n\n\ncontains\n\nsubroutine Shuffle(a)\n  integer, intent(inout) :: a(:)\n  integer :: i, randpos, temp\n  real :: r\n\n  do i = size(a), 2, -1\n    call random_number(r)\n    randpos = int(r * i) + 1\n    temp = a(randpos)\n    a(randpos) = a(i)\n    a(i) = temp\n  end do\n     \nend subroutine Shuffle\n   \nend program Knuth_Shuffle\n", "target": "public static void KnuthShuffle<T>(T[] array)\n{\n    System.Random random = new System.Random();\n    for (int i = 0; i < array.Length; i++)\n    {\n        int j = random.Next(i, array.Length); \n        T temp = array[i]; array[i] = array[j]; array[j] = temp;\n    }\n}\n"}
{"id": 95599, "name": "Knuth shuffle", "source": "Translate Fortran to Java: program Knuth_Shuffle\n  implicit none\n\n  integer, parameter :: reps = 1000000\n  integer :: i, n\n  integer, dimension(10) :: a, bins = 0, initial = (/ (n, n=1,10) /) \n\n  do i = 1, reps\n    a = initial\n \tcall Shuffle(a)\n    where (a == initial) bins = bins + 1  \n  end do\n  write(*, \"(10(i8))\") bins\n\n\ncontains\n\nsubroutine Shuffle(a)\n  integer, intent(inout) :: a(:)\n  integer :: i, randpos, temp\n  real :: r\n\n  do i = size(a), 2, -1\n    call random_number(r)\n    randpos = int(r * i) + 1\n    temp = a(randpos)\n    a(randpos) = a(i)\n    a(i) = temp\n  end do\n     \nend subroutine Shuffle\n   \nend program Knuth_Shuffle\n", "target": "import java.util.Random;\n\npublic static final Random gen = new Random();\n\n\npublic static void shuffle (int[] array) {\n    int n = array.length;\n    while (n > 1) {\n        int k = gen.nextInt(n--); \n        int temp = array[n];\n        array[n] = array[k];\n        array[k] = temp;\n    }\n}\n\npublic static void shuffle (Object[] array) {\n    int n = array.length;\n    while (n > 1) {\n        int k = gen.nextInt(n--); \n        Object temp = array[n];\n        array[n] = array[k];\n        array[k] = temp;\n    }\n}\n"}
{"id": 95600, "name": "Knuth shuffle", "source": "Translate Fortran to Python: program Knuth_Shuffle\n  implicit none\n\n  integer, parameter :: reps = 1000000\n  integer :: i, n\n  integer, dimension(10) :: a, bins = 0, initial = (/ (n, n=1,10) /) \n\n  do i = 1, reps\n    a = initial\n \tcall Shuffle(a)\n    where (a == initial) bins = bins + 1  \n  end do\n  write(*, \"(10(i8))\") bins\n\n\ncontains\n\nsubroutine Shuffle(a)\n  integer, intent(inout) :: a(:)\n  integer :: i, randpos, temp\n  real :: r\n\n  do i = size(a), 2, -1\n    call random_number(r)\n    randpos = int(r * i) + 1\n    temp = a(randpos)\n    a(randpos) = a(i)\n    a(i) = temp\n  end do\n     \nend subroutine Shuffle\n   \nend program Knuth_Shuffle\n", "target": "from random import randrange\n\ndef knuth_shuffle(x):\n    for i in range(len(x)-1, 0, -1):\n        j = randrange(i + 1)\n        x[i], x[j] = x[j], x[i]\n\nx = list(range(10))\nknuth_shuffle(x)\nprint(\"shuffled:\", x)\n"}
{"id": 95992, "name": "Knapsack problem_Continuous", "source": "Translate Fortran to C#: program KNAPSACK_CONTINUOUS\n  implicit none\n \n  real, parameter :: maxweight = 15.0\n  real :: total_weight = 0, total_value = 0, frac\n  integer :: i, j\n  \n  type Item\n    character(7) :: name\n    real :: weight\n    real :: value\n  end type Item\n\n  type(Item) :: items(9), temp\n  \n  items(1) = Item(\"beef\",    3.8, 36.0)\n  items(2) = Item(\"pork\",    5.4, 43.0)\n  items(3) = Item(\"ham\",     3.6, 90.0)\n  items(4) = Item(\"greaves\", 2.4, 45.0)\n  items(5) = Item(\"flitch\",  4.0, 30.0)\n  items(6) = Item(\"brawn\",   2.5, 56.0)\n  items(7) = Item(\"welt\",    3.7, 67.0)\n  items(8) = Item(\"salami\",  3.0, 95.0)\n  items(9) = Item(\"sausage\", 5.9, 98.0)\n\n  \n  do i = 2, size(items)\n     j = i - 1\n     temp = items(i)\n     do while (j>=1 .and. items(j)%value / items(j)%weight < temp%value / temp%weight)\n       items(j+1) = items(j)\n       j = j - 1\n     end do\n    items(j+1) = temp\n  end do\n \n  i = 0\n  write(*, \"(a4, a13, a6)\") \"Item\", \"Weight\", \"Value\"\n  do while(i < size(items) .and. total_weight < maxweight)\n    i = i + 1\n    if(total_weight+items(i)%weight < maxweight) then\n      total_weight = total_weight + items(i)%weight\n      total_value = total_value + items(i)%value\n      write(*, \"(a7, 2f8.2)\") items(i)\n    else\n      frac = (maxweight-total_weight) / items(i)%weight\n      total_weight = total_weight + items(i)%weight * frac\n      total_value = total_value + items(i)%value * frac\n      write(*, \"(a7, 2f8.2)\") items(i)%name, items(i)%weight * frac, items(i)%value * frac\n    end if \n  end do\n\n  write(*, \"(f15.2, f8.2)\") total_weight, total_value\n \nend program KNAPSACK_CONTINUOUS\n", "target": "using System;  \nclass Program\n{\n    static void Main()\n    {\n        Console.WriteLine(knapSack(15) + \"\\n\");\n        var sw = System.Diagnostics.Stopwatch.StartNew();\n        for (int i = 1000; i > 0; i--) knapSack(15);\n        Console.Write(sw.Elapsed); Console.Read();    \n    }\n\n    static string knapSack(double w1)\n    {\n        int k = w.Length; var q = new double[k];\n        for (int i = 0; i < k; ) q[i] = v[i] / w[i++];\n        var c = new double[k];\n        Array.Copy(q, c, k); Array.Sort(c, w);\n        Array.Copy(q, c, k); Array.Sort(c, v);\n        Array.Sort(q, items);\n        string str = \"\";\n        for (k--; k >= 0; k--)\n            if (w1 - w[k] > 0) { w1 -= w[k]; str += items[k] + \"\\n\"; }\n            else break;\n        return w1 > 0 && k >= 0 ? str + items[k] : str;\n    }\n\n    static double[] w = { 3.8, 5.4, 3.6, 2.4, 4.0, 2.5, 3.7, 3.0, 5.9 },\n\n                    v = { 36, 43, 90, 45, 30, 56, 67, 95, 98 };\n\n    static string[] items = {\"beef\",\"pork\",\"ham\",\"greaves\",\"flitch\",\n                             \"brawn\",\"welt\",\"salami\",\"sausage\"};\n}\n"}
{"id": 95995, "name": "Knapsack problem_Continuous", "source": "Translate Fortran to Java: program KNAPSACK_CONTINUOUS\n  implicit none\n \n  real, parameter :: maxweight = 15.0\n  real :: total_weight = 0, total_value = 0, frac\n  integer :: i, j\n  \n  type Item\n    character(7) :: name\n    real :: weight\n    real :: value\n  end type Item\n\n  type(Item) :: items(9), temp\n  \n  items(1) = Item(\"beef\",    3.8, 36.0)\n  items(2) = Item(\"pork\",    5.4, 43.0)\n  items(3) = Item(\"ham\",     3.6, 90.0)\n  items(4) = Item(\"greaves\", 2.4, 45.0)\n  items(5) = Item(\"flitch\",  4.0, 30.0)\n  items(6) = Item(\"brawn\",   2.5, 56.0)\n  items(7) = Item(\"welt\",    3.7, 67.0)\n  items(8) = Item(\"salami\",  3.0, 95.0)\n  items(9) = Item(\"sausage\", 5.9, 98.0)\n\n  \n  do i = 2, size(items)\n     j = i - 1\n     temp = items(i)\n     do while (j>=1 .and. items(j)%value / items(j)%weight < temp%value / temp%weight)\n       items(j+1) = items(j)\n       j = j - 1\n     end do\n    items(j+1) = temp\n  end do\n \n  i = 0\n  write(*, \"(a4, a13, a6)\") \"Item\", \"Weight\", \"Value\"\n  do while(i < size(items) .and. total_weight < maxweight)\n    i = i + 1\n    if(total_weight+items(i)%weight < maxweight) then\n      total_weight = total_weight + items(i)%weight\n      total_value = total_value + items(i)%value\n      write(*, \"(a7, 2f8.2)\") items(i)\n    else\n      frac = (maxweight-total_weight) / items(i)%weight\n      total_weight = total_weight + items(i)%weight * frac\n      total_value = total_value + items(i)%value * frac\n      write(*, \"(a7, 2f8.2)\") items(i)%name, items(i)%weight * frac, items(i)%value * frac\n    end if \n  end do\n\n  write(*, \"(f15.2, f8.2)\") total_weight, total_value\n \nend program KNAPSACK_CONTINUOUS\n", "target": "package hu.pj.alg.test;\n\nimport hu.pj.alg.ContinuousKnapsack;\nimport hu.pj.obj.Item;\nimport java.util.*;\nimport java.text.*;\n\npublic class ContinousKnapsackForRobber {\n    final private double tolerance = 0.0005;\n\n    public ContinousKnapsackForRobber() {\n        ContinuousKnapsack cok = new ContinuousKnapsack(15); \n\n        \n        cok.add(\"beef\",     3.8, 36); \n        cok.add(\"pork\",     5.4, 43); \n        cok.add(\"ham\",      3.6, 90); \n        cok.add(\"greaves\",  2.4, 45); \n        cok.add(\"flitch\",   4.0, 30); \n        cok.add(\"brawn\",    2.5, 56); \n        cok.add(\"welt\",     3.7, 67); \n        cok.add(\"salami\",   3.0, 95); \n        cok.add(\"sausage\",  5.9, 98); \n\n        \n        List<Item> itemList = cok.calcSolution();\n\n        \n        if (cok.isCalculated()) {\n            NumberFormat nf  = NumberFormat.getInstance();\n\n            System.out.println(\n                \"Maximal weight           = \" +\n                nf.format(cok.getMaxWeight()) + \" kg\"\n            );\n            System.out.println(\n                \"Total weight of solution = \" +\n                nf.format(cok.getSolutionWeight()) + \" kg\"\n            );\n            System.out.println(\n                \"Total value (profit)     = \" +\n                nf.format(cok.getProfit())\n            );\n            System.out.println();\n            System.out.println(\n                \"You can carry the following materials \" +\n                \"in the knapsack:\"\n            );\n            for (Item item : itemList) {\n                if (item.getInKnapsack() > tolerance) {\n                    System.out.format(\n                        \"%1$-10s %2$-15s %3$-15s \\n\",\n                        nf.format(item.getInKnapsack()) + \" kg \",\n                        item.getName(),\n                        \"(value = \" + nf.format(item.getInKnapsack() *\n                                                (item.getValue() / item.getWeight())) + \")\"\n                    );\n                }\n            }\n        } else {\n            System.out.println(\n                \"The problem is not solved. \" +\n                \"Maybe you gave wrong data.\"\n            );\n        }\n\n    }\n\n    public static void main(String[] args) {\n        new ContinousKnapsackForRobber();\n    }\n\n} \n"}
{"id": 95996, "name": "Knapsack problem_Continuous", "source": "Translate Fortran to Python: program KNAPSACK_CONTINUOUS\n  implicit none\n \n  real, parameter :: maxweight = 15.0\n  real :: total_weight = 0, total_value = 0, frac\n  integer :: i, j\n  \n  type Item\n    character(7) :: name\n    real :: weight\n    real :: value\n  end type Item\n\n  type(Item) :: items(9), temp\n  \n  items(1) = Item(\"beef\",    3.8, 36.0)\n  items(2) = Item(\"pork\",    5.4, 43.0)\n  items(3) = Item(\"ham\",     3.6, 90.0)\n  items(4) = Item(\"greaves\", 2.4, 45.0)\n  items(5) = Item(\"flitch\",  4.0, 30.0)\n  items(6) = Item(\"brawn\",   2.5, 56.0)\n  items(7) = Item(\"welt\",    3.7, 67.0)\n  items(8) = Item(\"salami\",  3.0, 95.0)\n  items(9) = Item(\"sausage\", 5.9, 98.0)\n\n  \n  do i = 2, size(items)\n     j = i - 1\n     temp = items(i)\n     do while (j>=1 .and. items(j)%value / items(j)%weight < temp%value / temp%weight)\n       items(j+1) = items(j)\n       j = j - 1\n     end do\n    items(j+1) = temp\n  end do\n \n  i = 0\n  write(*, \"(a4, a13, a6)\") \"Item\", \"Weight\", \"Value\"\n  do while(i < size(items) .and. total_weight < maxweight)\n    i = i + 1\n    if(total_weight+items(i)%weight < maxweight) then\n      total_weight = total_weight + items(i)%weight\n      total_value = total_value + items(i)%value\n      write(*, \"(a7, 2f8.2)\") items(i)\n    else\n      frac = (maxweight-total_weight) / items(i)%weight\n      total_weight = total_weight + items(i)%weight * frac\n      total_value = total_value + items(i)%value * frac\n      write(*, \"(a7, 2f8.2)\") items(i)%name, items(i)%weight * frac, items(i)%value * frac\n    end if \n  end do\n\n  write(*, \"(f15.2, f8.2)\") total_weight, total_value\n \nend program KNAPSACK_CONTINUOUS\n", "target": "\nitems = [(\"beef\",    3.8, 36.0),\n         (\"pork\",    5.4, 43.0),\n         (\"ham\",     3.6, 90.0),\n         (\"greaves\", 2.4, 45.0),\n         (\"flitch\",  4.0, 30.0),\n         (\"brawn\",   2.5, 56.0),\n         (\"welt\",    3.7, 67.0),\n         (\"salami\",  3.0, 95.0),\n         (\"sausage\", 5.9, 98.0)]\n\nMAXWT = 15.0\n\nsorted_items = sorted(((value/amount, amount, name)\n                       for name, amount, value in items),\n                      reverse = True)\nwt = val = 0\nbagged = []\nfor unit_value, amount, name in sorted_items:\n    portion = min(MAXWT - wt, amount)\n    wt     += portion\n    addval  = portion * unit_value\n    val    += addval\n    bagged += [(name, portion, addval)]\n    if wt >= MAXWT:\n        break\n\nprint(\"    ITEM   PORTION VALUE\")\nprint(\"\\n\".join(\"%10s %6.2f %6.2f\" % item for item in bagged))\nprint(\"\\nTOTAL WEIGHT: %5.2f\\nTOTAL VALUE: %5.2f\" % (wt, val))\n"}
{"id": 96281, "name": "Map range", "source": "Translate Fortran to C#: program Map\n  implicit none\n  \n  real :: t\n  integer :: i\n\n  do i = 0, 10\n    t = Maprange((/0.0, 10.0/), (/-1.0, 0.0/), real(i)) \n    write(*,*) i, \" maps to \", t\n  end do \n\ncontains\n\nfunction Maprange(a, b, s)\n  real :: Maprange\n  real, intent(in) :: a(2), b(2), s\n \n  Maprange = (s-a(1)) * (b(2)-b(1)) / (a(2)-a(1)) + b(1) \n\nend function Maprange\nend program Map\n", "target": "using System;\nusing System.Linq;\n\npublic class MapRange\n{\n    public static void Main() {\n        foreach (int i in Enumerable.Range(0, 11))\n            Console.WriteLine($\"{i} maps to {Map(0, 10, -1, 0, i)}\");\n    }\n    \n    static double Map(double a1, double a2, double b1, double b2, double s) => b1 + (s - a1) * (b2 - b1) / (a2 - a1);\n}\n"}
{"id": 96282, "name": "Map range", "source": "Translate Fortran to C#: program Map\n  implicit none\n  \n  real :: t\n  integer :: i\n\n  do i = 0, 10\n    t = Maprange((/0.0, 10.0/), (/-1.0, 0.0/), real(i)) \n    write(*,*) i, \" maps to \", t\n  end do \n\ncontains\n\nfunction Maprange(a, b, s)\n  real :: Maprange\n  real, intent(in) :: a(2), b(2), s\n \n  Maprange = (s-a(1)) * (b(2)-b(1)) / (a(2)-a(1)) + b(1) \n\nend function Maprange\nend program Map\n", "target": "using System;\nusing System.Linq;\n\npublic class MapRange\n{\n    public static void Main() {\n        foreach (int i in Enumerable.Range(0, 11))\n            Console.WriteLine($\"{i} maps to {Map(0, 10, -1, 0, i)}\");\n    }\n    \n    static double Map(double a1, double a2, double b1, double b2, double s) => b1 + (s - a1) * (b2 - b1) / (a2 - a1);\n}\n"}
{"id": 96288, "name": "Map range", "source": "Translate Fortran to Java: program Map\n  implicit none\n  \n  real :: t\n  integer :: i\n\n  do i = 0, 10\n    t = Maprange((/0.0, 10.0/), (/-1.0, 0.0/), real(i)) \n    write(*,*) i, \" maps to \", t\n  end do \n\ncontains\n\nfunction Maprange(a, b, s)\n  real :: Maprange\n  real, intent(in) :: a(2), b(2), s\n \n  Maprange = (s-a(1)) * (b(2)-b(1)) / (a(2)-a(1)) + b(1) \n\nend function Maprange\nend program Map\n", "target": "public class Range {\n\tpublic static void main(String[] args){\n\t\tfor(float s = 0;s <= 10; s++){\n\t\t\tSystem.out.println(s + \" in [0, 10] maps to \"+ \n\t\t\t\t\tmapRange(0, 10, -1, 0, s)+\" in [-1, 0].\");\n\t\t}\n\t}\n\t\n\tpublic static double mapRange(double a1, double a2, double b1, double b2, double s){\n\t\treturn b1 + ((s - a1)*(b2 - b1))/(a2 - a1);\n\t}\n}\n"}
{"id": 96289, "name": "Map range", "source": "Translate Fortran to Java: program Map\n  implicit none\n  \n  real :: t\n  integer :: i\n\n  do i = 0, 10\n    t = Maprange((/0.0, 10.0/), (/-1.0, 0.0/), real(i)) \n    write(*,*) i, \" maps to \", t\n  end do \n\ncontains\n\nfunction Maprange(a, b, s)\n  real :: Maprange\n  real, intent(in) :: a(2), b(2), s\n \n  Maprange = (s-a(1)) * (b(2)-b(1)) / (a(2)-a(1)) + b(1) \n\nend function Maprange\nend program Map\n", "target": "public class Range {\n\tpublic static void main(String[] args){\n\t\tfor(float s = 0;s <= 10; s++){\n\t\t\tSystem.out.println(s + \" in [0, 10] maps to \"+ \n\t\t\t\t\tmapRange(0, 10, -1, 0, s)+\" in [-1, 0].\");\n\t\t}\n\t}\n\t\n\tpublic static double mapRange(double a1, double a2, double b1, double b2, double s){\n\t\treturn b1 + ((s - a1)*(b2 - b1))/(a2 - a1);\n\t}\n}\n"}
{"id": 96290, "name": "Map range", "source": "Translate Fortran to Python: program Map\n  implicit none\n  \n  real :: t\n  integer :: i\n\n  do i = 0, 10\n    t = Maprange((/0.0, 10.0/), (/-1.0, 0.0/), real(i)) \n    write(*,*) i, \" maps to \", t\n  end do \n\ncontains\n\nfunction Maprange(a, b, s)\n  real :: Maprange\n  real, intent(in) :: a(2), b(2), s\n \n  Maprange = (s-a(1)) * (b(2)-b(1)) / (a(2)-a(1)) + b(1) \n\nend function Maprange\nend program Map\n", "target": ">>> def maprange( a, b, s):\n\t(a1, a2), (b1, b2) = a, b\n\treturn  b1 + ((s - a1) * (b2 - b1) / (a2 - a1))\n\n>>> for s in range(11):\n\tprint(\"%2g maps to %g\" % (s, maprange( (0, 10), (-1, 0), s)))\n\n\t\n 0 maps to -1\n 1 maps to -0.9\n 2 maps to -0.8\n 3 maps to -0.7\n 4 maps to -0.6\n 5 maps to -0.5\n 6 maps to -0.4\n 7 maps to -0.3\n 8 maps to -0.2\n 9 maps to -0.1\n10 maps to 0\n"}
{"id": 96291, "name": "Map range", "source": "Translate Fortran to Python: program Map\n  implicit none\n  \n  real :: t\n  integer :: i\n\n  do i = 0, 10\n    t = Maprange((/0.0, 10.0/), (/-1.0, 0.0/), real(i)) \n    write(*,*) i, \" maps to \", t\n  end do \n\ncontains\n\nfunction Maprange(a, b, s)\n  real :: Maprange\n  real, intent(in) :: a(2), b(2), s\n \n  Maprange = (s-a(1)) * (b(2)-b(1)) / (a(2)-a(1)) + b(1) \n\nend function Maprange\nend program Map\n", "target": ">>> def maprange( a, b, s):\n\t(a1, a2), (b1, b2) = a, b\n\treturn  b1 + ((s - a1) * (b2 - b1) / (a2 - a1))\n\n>>> for s in range(11):\n\tprint(\"%2g maps to %g\" % (s, maprange( (0, 10), (-1, 0), s)))\n\n\t\n 0 maps to -1\n 1 maps to -0.9\n 2 maps to -0.8\n 3 maps to -0.7\n 4 maps to -0.6\n 5 maps to -0.5\n 6 maps to -0.4\n 7 maps to -0.3\n 8 maps to -0.2\n 9 maps to -0.1\n10 maps to 0\n"}
{"id": 96622, "name": "Function composition", "source": "Translate Fortran to C#: module functions_module\n   implicit none\n   private \n   public :: f,g\n\ncontains\n\n   pure function  f(x)\n      implicit none\n      real, intent(in) :: x\n      real :: f\n      f = sin(x)\n   end function f\n\n   pure function  g(x)\n      implicit none\n      real, intent(in) :: x\n      real :: g\n      g = cos(x)\n   end function g\n\nend module functions_module\n\nmodule compose_module\n   implicit none\n   private \n   public :: compose\n\n   interface\n      pure function  f(x)\n         implicit none\n         real, intent(in) :: x\n         real :: f\n      end function f\n\n      pure function  g(x)\n         implicit none\n         real, intent(in) :: x\n         real :: g\n      end function g\n   end interface\n\ncontains\n\n   impure function  compose(x, fi, gi)\n      implicit none\n      real, intent(in) :: x\n      procedure(f), optional :: fi\n      procedure(g), optional :: gi\n      real :: compose\n\n      procedure (f), pointer, save :: fpi => null()\n      procedure (g), pointer, save :: gpi => null()\n\n      if(present(fi) .and. present(gi))then\n         fpi => fi\n         gpi => gi\n         compose = 0\n         return\n      endif\n\n      if(.not. associated(fpi)) error stop \"fpi\"\n      if(.not. associated(gpi)) error stop \"gpi\"\n\n      compose = fpi(gpi(x))\n\n   contains\n\n   end function compose\n\nend module compose_module\n\nprogram test_compose\n   use functions_module\n   use compose_module\n   implicit none\n   write(*,*) \"prepare compose:\", compose(0.0, f,g)\n   write(*,*) \"run compose:\", compose(0.5)\nend program test_compose\n", "target": "using System;\nclass Program\n{\n    static void Main(string[] args)\n    {\n        Func<int, int> outfunc = Composer<int, int, int>.Compose(functA, functB);\n        Console.WriteLine(outfunc(5)); \n    }\n    static int functA(int i) { return i * 10; }\n    static int functB(int i) { return i + 5; }\n    class Composer<A, B, C>\n    {\n        public static Func<C, A> Compose(Func<B, A> a, Func<C, B> b)\n        {\n            return delegate(C i) { return a(b(i)); };\n        }\n    }\n}\n"}
{"id": 96625, "name": "Function composition", "source": "Translate Fortran to Java: module functions_module\n   implicit none\n   private \n   public :: f,g\n\ncontains\n\n   pure function  f(x)\n      implicit none\n      real, intent(in) :: x\n      real :: f\n      f = sin(x)\n   end function f\n\n   pure function  g(x)\n      implicit none\n      real, intent(in) :: x\n      real :: g\n      g = cos(x)\n   end function g\n\nend module functions_module\n\nmodule compose_module\n   implicit none\n   private \n   public :: compose\n\n   interface\n      pure function  f(x)\n         implicit none\n         real, intent(in) :: x\n         real :: f\n      end function f\n\n      pure function  g(x)\n         implicit none\n         real, intent(in) :: x\n         real :: g\n      end function g\n   end interface\n\ncontains\n\n   impure function  compose(x, fi, gi)\n      implicit none\n      real, intent(in) :: x\n      procedure(f), optional :: fi\n      procedure(g), optional :: gi\n      real :: compose\n\n      procedure (f), pointer, save :: fpi => null()\n      procedure (g), pointer, save :: gpi => null()\n\n      if(present(fi) .and. present(gi))then\n         fpi => fi\n         gpi => gi\n         compose = 0\n         return\n      endif\n\n      if(.not. associated(fpi)) error stop \"fpi\"\n      if(.not. associated(gpi)) error stop \"gpi\"\n\n      compose = fpi(gpi(x))\n\n   contains\n\n   end function compose\n\nend module compose_module\n\nprogram test_compose\n   use functions_module\n   use compose_module\n   implicit none\n   write(*,*) \"prepare compose:\", compose(0.0, f,g)\n   write(*,*) \"run compose:\", compose(0.5)\nend program test_compose\n", "target": "public class Compose {\n\n    \n    \n    public interface Fun<A,B> {\n        B call(A x);\n    }\n\n    public static <A,B,C> Fun<A,C> compose(final Fun<B,C> f, final Fun<A,B> g) {\n        return new Fun<A,C>() {\n            public C call(A x) {\n                return f.call(g.call(x));\n            }\n        };\n    }\n\n    public static void main(String[] args) {\n        Fun<Double,Double> sin = new Fun<Double,Double>() {\n            public Double call(Double x) {\n                return Math.sin(x);\n            }\n        };\n        Fun<Double,Double> asin = new Fun<Double,Double>() {\n            public Double call(Double x) {\n                return Math.asin(x);\n            }\n        };\n\n        Fun<Double,Double> sin_asin = compose(sin, asin);\n\n        System.out.println(sin_asin.call(0.5)); \n    }\n}\n"}
{"id": 96626, "name": "Function composition", "source": "Translate Fortran to Python: module functions_module\n   implicit none\n   private \n   public :: f,g\n\ncontains\n\n   pure function  f(x)\n      implicit none\n      real, intent(in) :: x\n      real :: f\n      f = sin(x)\n   end function f\n\n   pure function  g(x)\n      implicit none\n      real, intent(in) :: x\n      real :: g\n      g = cos(x)\n   end function g\n\nend module functions_module\n\nmodule compose_module\n   implicit none\n   private \n   public :: compose\n\n   interface\n      pure function  f(x)\n         implicit none\n         real, intent(in) :: x\n         real :: f\n      end function f\n\n      pure function  g(x)\n         implicit none\n         real, intent(in) :: x\n         real :: g\n      end function g\n   end interface\n\ncontains\n\n   impure function  compose(x, fi, gi)\n      implicit none\n      real, intent(in) :: x\n      procedure(f), optional :: fi\n      procedure(g), optional :: gi\n      real :: compose\n\n      procedure (f), pointer, save :: fpi => null()\n      procedure (g), pointer, save :: gpi => null()\n\n      if(present(fi) .and. present(gi))then\n         fpi => fi\n         gpi => gi\n         compose = 0\n         return\n      endif\n\n      if(.not. associated(fpi)) error stop \"fpi\"\n      if(.not. associated(gpi)) error stop \"gpi\"\n\n      compose = fpi(gpi(x))\n\n   contains\n\n   end function compose\n\nend module compose_module\n\nprogram test_compose\n   use functions_module\n   use compose_module\n   implicit none\n   write(*,*) \"prepare compose:\", compose(0.0, f,g)\n   write(*,*) \"run compose:\", compose(0.5)\nend program test_compose\n", "target": "compose = lambda f, g: lambda x: f( g(x) )\n"}
{"id": 97148, "name": "Smith numbers", "source": "Translate Fortran to C#:       MODULE FACTORISE\t\n       USE PRIMEBAG\t\t\n       INTEGER LASTP\t\t\n       PARAMETER (LASTP = 9)\t\n       TYPE FACTORED\t\t\n        INTEGER PVAL(0:LASTP)\t\n        INTEGER PPOW(LASTP)\t\n       END TYPE FACTORED\t\n\n       CONTAINS\t\t\n        SUBROUTINE SHOWFACTORS(N)\t\n         TYPE(FACTORED) N\t\n         INTEGER I\t\t\n          DO I = 1,N.PVAL(0)\t\n            IF (I.GT.1) WRITE (MSG,\"('x',$)\")\t\n            WRITE (MSG,\"(I0,$)\") N.PVAL(I)\t\n            IF (N.PPOW(I).GT.1) WRITE (MSG,\"('^',I0,$)\") N.PPOW(I)\t\n          END DO\t\t\n          WRITE (MSG,1) N.PVAL(0)\t\n    1     FORMAT (\": Factor count \",I0)\t\n        END SUBROUTINE SHOWFACTORS\t\n\n        TYPE(FACTORED) FUNCTION FACTOR(IT)\t\nCareful\n         INTEGER IT,N\t\n         INTEGER F,FP\t\n          IF (IT.LE.0) STOP \"Factor only positive numbers\n          FACTOR.PVAL(0) = 0\t\n          F = 0\t\t\t\n          N = IT\t\t\nCollapse N into its prime factors.\n   10     DO WHILE(N.GT.1)\t\n            IF (ISPRIME(N)) THEN\n              F = N\t\t\t\n              FP = 1\t\t\t\n              N = 1\t\t\t\n             ELSE\t\t\n              FP = 0\t\t\t\n   11         F = NEXTPRIME(F)\t\t\n              DO WHILE(MOD(N,F).EQ.0)\t\n                FP = FP + 1\t\t\t\n                N = N/F\t\t\t\t\n              END DO\t\t\t\n              IF (FP.LE.0) GO TO 11\t\n            END IF\t\t\n            IF (FACTOR.PVAL(0).GE.LASTP) THEN\t\n              WRITE (MSG,1) IT,LASTP\t\t\n    1         FORMAT (\"Factoring \",I0,\" but with provision for only \",\t\n     1         I0,\" distinct prime factors\n              CALL SHOWFACTORS(FACTOR)\t\t\n              STOP \"Not enough storage\n            END IF\t\t\t\n            FACTOR.PVAL(0) = FACTOR.PVAL(0) + 1\t\n            FACTOR.PVAL(FACTOR.PVAL(0)) = F\t\n            FACTOR.PPOW(FACTOR.PVAL(0)) = FP\t\n          END DO\t\t\n        END FUNCTION FACTOR\t\n      END MODULE FACTORISE\t\n\n      MODULE SMITHSTUFF\t\n       CONTAINS\t\t\n        INTEGER FUNCTION DIGITSUM(N,BASE)\t\n         INTEGER N,IT\t\n         INTEGER BASE\t\n         IF (N.LT.0) STOP \"DigitSum: negative numbers need not apply\n          DIGITSUM = 0\t\n          IT = N\t\n          DO WHILE(IT.GT.0)\t\n            DIGITSUM = MOD(IT,BASE) + DIGITSUM\t\n            IT = IT/BASE\t\t\t\n          END DO\t\t\n        END FUNCTION DIGITSUM\t\n\n        LOGICAL FUNCTION SMITHNUM(N,BASE)\t\n         USE FACTORISE\t\t\n         INTEGER N\t\t\n         INTEGER BASE\t\t\n         TYPE(FACTORED) F\t\n         INTEGER I,FD\t\t\n          F = FACTOR(N)\t\t\nc          write (6,\"(a,I0,1x)\",advance=\"no\") \"N=\",N\nc          call ShowFactors(F)\n          FD = 0\t\t\n          DO I = 1,F.PVAL(0)\t\n            FD = DIGITSUM(F.PVAL(I),BASE)*F.PPOW(I) + FD\t\n          END DO\t\t\n          SMITHNUM = FD.EQ.DIGITSUM(N,BASE)\t\n        END FUNCTION SMITHNUM\t\n      END MODULE SMITHSTUFF\t\n\n      USE PRIMEBAG\t\n      USE SMITHSTUFF\t\n      INTEGER LAST\t\t\n      PARAMETER (LAST = 9999)\t\n      INTEGER I,N,BASE\t\t\n      INTEGER NB,BAG(20)\t\n      MSG = 6\t\n\n      WRITE (MSG,1) LAST\t\n    1 FORMAT ('To find the \"Smith\" numbers up to ',I0)\n      IF (.NOT.GRASPPRIMEBAG(66)) STOP \"Gan't grab my file\n\n   10 DO BASE = 2,12\t\n        WRITE (MSG,11) BASE\t\n   11   FORMAT (/,\"Working in base \",I0)\n        N = 0\t\t\t\n        NB = 0\t\t\t\n        DO I = 1,LAST\t\t\n          IF (ISPRIME(I)) CYCLE\t\t\n          IF (SMITHNUM(I,BASE)) THEN\t\n            N = N + 1\t\t\t\t\n            IF (NB.GE.20) THEN\t\t\t\n              WRITE (MSG,12) BAG\t\t\t\n   12         FORMAT (20I6)\t\t\t\t\n              NB = 0\t\t\t\t\t\n            END IF\t\t\t\t\n            NB = NB + 1\t\t\t\t\n            BAG(NB) = I\t\t\t\t\n          END IF\t\t\t\n        END DO\t\t\t\n        WRITE (MSG,12) BAG(1:NB)\n        WRITE (MSG,13) N\t\n   13   FORMAT (I9,\" found.\")\t\n      END DO\t\t\n      END\t\n", "target": "using System;\nusing System.Collections.Generic;\n\nnamespace SmithNumbers {\n    class Program {\n        static int SumDigits(int n) {\n            int sum = 0;\n            while (n > 0) {\n                n = Math.DivRem(n, 10, out int rem);\n                sum += rem;\n            }\n            return sum;\n        }\n\n        static List<int> PrimeFactors(int n) {\n            List<int> result = new List<int>();\n\n            for (int i = 2; n % i == 0; n /= i) {\n                result.Add(i);\n            }\n\n            for (int i = 3; i * i < n; i += 2) {\n                while (n % i == 0) {\n                    result.Add(i);\n                    n /= i;\n                }\n            }\n\n            if (n != 1) {\n                result.Add(n);\n            }\n\n            return result;\n        }\n\n        static void Main(string[] args) {\n            const int SIZE = 8;\n            int count = 0;\n            for (int n = 1; n < 10_000; n++) {\n                var factors = PrimeFactors(n);\n                if (factors.Count > 1) {\n                    int sum = SumDigits(n);\n                    foreach (var f in factors) {\n                        sum -= SumDigits(f);\n                    }\n                    if (sum == 0) {\n                        Console.Write(\"{0,5}\", n);\n                        if (count == SIZE - 1) {\n                            Console.WriteLine();\n                        }\n                        count = (count + 1) % SIZE;\n                    }\n                }\n            }\n        }\n    }\n}\n"}
{"id": 97149, "name": "Smith numbers", "source": "Translate Fortran to C#:       MODULE FACTORISE\t\n       USE PRIMEBAG\t\t\n       INTEGER LASTP\t\t\n       PARAMETER (LASTP = 9)\t\n       TYPE FACTORED\t\t\n        INTEGER PVAL(0:LASTP)\t\n        INTEGER PPOW(LASTP)\t\n       END TYPE FACTORED\t\n\n       CONTAINS\t\t\n        SUBROUTINE SHOWFACTORS(N)\t\n         TYPE(FACTORED) N\t\n         INTEGER I\t\t\n          DO I = 1,N.PVAL(0)\t\n            IF (I.GT.1) WRITE (MSG,\"('x',$)\")\t\n            WRITE (MSG,\"(I0,$)\") N.PVAL(I)\t\n            IF (N.PPOW(I).GT.1) WRITE (MSG,\"('^',I0,$)\") N.PPOW(I)\t\n          END DO\t\t\n          WRITE (MSG,1) N.PVAL(0)\t\n    1     FORMAT (\": Factor count \",I0)\t\n        END SUBROUTINE SHOWFACTORS\t\n\n        TYPE(FACTORED) FUNCTION FACTOR(IT)\t\nCareful\n         INTEGER IT,N\t\n         INTEGER F,FP\t\n          IF (IT.LE.0) STOP \"Factor only positive numbers\n          FACTOR.PVAL(0) = 0\t\n          F = 0\t\t\t\n          N = IT\t\t\nCollapse N into its prime factors.\n   10     DO WHILE(N.GT.1)\t\n            IF (ISPRIME(N)) THEN\n              F = N\t\t\t\n              FP = 1\t\t\t\n              N = 1\t\t\t\n             ELSE\t\t\n              FP = 0\t\t\t\n   11         F = NEXTPRIME(F)\t\t\n              DO WHILE(MOD(N,F).EQ.0)\t\n                FP = FP + 1\t\t\t\n                N = N/F\t\t\t\t\n              END DO\t\t\t\n              IF (FP.LE.0) GO TO 11\t\n            END IF\t\t\n            IF (FACTOR.PVAL(0).GE.LASTP) THEN\t\n              WRITE (MSG,1) IT,LASTP\t\t\n    1         FORMAT (\"Factoring \",I0,\" but with provision for only \",\t\n     1         I0,\" distinct prime factors\n              CALL SHOWFACTORS(FACTOR)\t\t\n              STOP \"Not enough storage\n            END IF\t\t\t\n            FACTOR.PVAL(0) = FACTOR.PVAL(0) + 1\t\n            FACTOR.PVAL(FACTOR.PVAL(0)) = F\t\n            FACTOR.PPOW(FACTOR.PVAL(0)) = FP\t\n          END DO\t\t\n        END FUNCTION FACTOR\t\n      END MODULE FACTORISE\t\n\n      MODULE SMITHSTUFF\t\n       CONTAINS\t\t\n        INTEGER FUNCTION DIGITSUM(N,BASE)\t\n         INTEGER N,IT\t\n         INTEGER BASE\t\n         IF (N.LT.0) STOP \"DigitSum: negative numbers need not apply\n          DIGITSUM = 0\t\n          IT = N\t\n          DO WHILE(IT.GT.0)\t\n            DIGITSUM = MOD(IT,BASE) + DIGITSUM\t\n            IT = IT/BASE\t\t\t\n          END DO\t\t\n        END FUNCTION DIGITSUM\t\n\n        LOGICAL FUNCTION SMITHNUM(N,BASE)\t\n         USE FACTORISE\t\t\n         INTEGER N\t\t\n         INTEGER BASE\t\t\n         TYPE(FACTORED) F\t\n         INTEGER I,FD\t\t\n          F = FACTOR(N)\t\t\nc          write (6,\"(a,I0,1x)\",advance=\"no\") \"N=\",N\nc          call ShowFactors(F)\n          FD = 0\t\t\n          DO I = 1,F.PVAL(0)\t\n            FD = DIGITSUM(F.PVAL(I),BASE)*F.PPOW(I) + FD\t\n          END DO\t\t\n          SMITHNUM = FD.EQ.DIGITSUM(N,BASE)\t\n        END FUNCTION SMITHNUM\t\n      END MODULE SMITHSTUFF\t\n\n      USE PRIMEBAG\t\n      USE SMITHSTUFF\t\n      INTEGER LAST\t\t\n      PARAMETER (LAST = 9999)\t\n      INTEGER I,N,BASE\t\t\n      INTEGER NB,BAG(20)\t\n      MSG = 6\t\n\n      WRITE (MSG,1) LAST\t\n    1 FORMAT ('To find the \"Smith\" numbers up to ',I0)\n      IF (.NOT.GRASPPRIMEBAG(66)) STOP \"Gan't grab my file\n\n   10 DO BASE = 2,12\t\n        WRITE (MSG,11) BASE\t\n   11   FORMAT (/,\"Working in base \",I0)\n        N = 0\t\t\t\n        NB = 0\t\t\t\n        DO I = 1,LAST\t\t\n          IF (ISPRIME(I)) CYCLE\t\t\n          IF (SMITHNUM(I,BASE)) THEN\t\n            N = N + 1\t\t\t\t\n            IF (NB.GE.20) THEN\t\t\t\n              WRITE (MSG,12) BAG\t\t\t\n   12         FORMAT (20I6)\t\t\t\t\n              NB = 0\t\t\t\t\t\n            END IF\t\t\t\t\n            NB = NB + 1\t\t\t\t\n            BAG(NB) = I\t\t\t\t\n          END IF\t\t\t\n        END DO\t\t\t\n        WRITE (MSG,12) BAG(1:NB)\n        WRITE (MSG,13) N\t\n   13   FORMAT (I9,\" found.\")\t\n      END DO\t\t\n      END\t\n", "target": "using System;\nusing System.Collections.Generic;\n\nnamespace SmithNumbers {\n    class Program {\n        static int SumDigits(int n) {\n            int sum = 0;\n            while (n > 0) {\n                n = Math.DivRem(n, 10, out int rem);\n                sum += rem;\n            }\n            return sum;\n        }\n\n        static List<int> PrimeFactors(int n) {\n            List<int> result = new List<int>();\n\n            for (int i = 2; n % i == 0; n /= i) {\n                result.Add(i);\n            }\n\n            for (int i = 3; i * i < n; i += 2) {\n                while (n % i == 0) {\n                    result.Add(i);\n                    n /= i;\n                }\n            }\n\n            if (n != 1) {\n                result.Add(n);\n            }\n\n            return result;\n        }\n\n        static void Main(string[] args) {\n            const int SIZE = 8;\n            int count = 0;\n            for (int n = 1; n < 10_000; n++) {\n                var factors = PrimeFactors(n);\n                if (factors.Count > 1) {\n                    int sum = SumDigits(n);\n                    foreach (var f in factors) {\n                        sum -= SumDigits(f);\n                    }\n                    if (sum == 0) {\n                        Console.Write(\"{0,5}\", n);\n                        if (count == SIZE - 1) {\n                            Console.WriteLine();\n                        }\n                        count = (count + 1) % SIZE;\n                    }\n                }\n            }\n        }\n    }\n}\n"}
{"id": 97154, "name": "Smith numbers", "source": "Translate Fortran to Java:       MODULE FACTORISE\t\n       USE PRIMEBAG\t\t\n       INTEGER LASTP\t\t\n       PARAMETER (LASTP = 9)\t\n       TYPE FACTORED\t\t\n        INTEGER PVAL(0:LASTP)\t\n        INTEGER PPOW(LASTP)\t\n       END TYPE FACTORED\t\n\n       CONTAINS\t\t\n        SUBROUTINE SHOWFACTORS(N)\t\n         TYPE(FACTORED) N\t\n         INTEGER I\t\t\n          DO I = 1,N.PVAL(0)\t\n            IF (I.GT.1) WRITE (MSG,\"('x',$)\")\t\n            WRITE (MSG,\"(I0,$)\") N.PVAL(I)\t\n            IF (N.PPOW(I).GT.1) WRITE (MSG,\"('^',I0,$)\") N.PPOW(I)\t\n          END DO\t\t\n          WRITE (MSG,1) N.PVAL(0)\t\n    1     FORMAT (\": Factor count \",I0)\t\n        END SUBROUTINE SHOWFACTORS\t\n\n        TYPE(FACTORED) FUNCTION FACTOR(IT)\t\nCareful\n         INTEGER IT,N\t\n         INTEGER F,FP\t\n          IF (IT.LE.0) STOP \"Factor only positive numbers\n          FACTOR.PVAL(0) = 0\t\n          F = 0\t\t\t\n          N = IT\t\t\nCollapse N into its prime factors.\n   10     DO WHILE(N.GT.1)\t\n            IF (ISPRIME(N)) THEN\n              F = N\t\t\t\n              FP = 1\t\t\t\n              N = 1\t\t\t\n             ELSE\t\t\n              FP = 0\t\t\t\n   11         F = NEXTPRIME(F)\t\t\n              DO WHILE(MOD(N,F).EQ.0)\t\n                FP = FP + 1\t\t\t\n                N = N/F\t\t\t\t\n              END DO\t\t\t\n              IF (FP.LE.0) GO TO 11\t\n            END IF\t\t\n            IF (FACTOR.PVAL(0).GE.LASTP) THEN\t\n              WRITE (MSG,1) IT,LASTP\t\t\n    1         FORMAT (\"Factoring \",I0,\" but with provision for only \",\t\n     1         I0,\" distinct prime factors\n              CALL SHOWFACTORS(FACTOR)\t\t\n              STOP \"Not enough storage\n            END IF\t\t\t\n            FACTOR.PVAL(0) = FACTOR.PVAL(0) + 1\t\n            FACTOR.PVAL(FACTOR.PVAL(0)) = F\t\n            FACTOR.PPOW(FACTOR.PVAL(0)) = FP\t\n          END DO\t\t\n        END FUNCTION FACTOR\t\n      END MODULE FACTORISE\t\n\n      MODULE SMITHSTUFF\t\n       CONTAINS\t\t\n        INTEGER FUNCTION DIGITSUM(N,BASE)\t\n         INTEGER N,IT\t\n         INTEGER BASE\t\n         IF (N.LT.0) STOP \"DigitSum: negative numbers need not apply\n          DIGITSUM = 0\t\n          IT = N\t\n          DO WHILE(IT.GT.0)\t\n            DIGITSUM = MOD(IT,BASE) + DIGITSUM\t\n            IT = IT/BASE\t\t\t\n          END DO\t\t\n        END FUNCTION DIGITSUM\t\n\n        LOGICAL FUNCTION SMITHNUM(N,BASE)\t\n         USE FACTORISE\t\t\n         INTEGER N\t\t\n         INTEGER BASE\t\t\n         TYPE(FACTORED) F\t\n         INTEGER I,FD\t\t\n          F = FACTOR(N)\t\t\nc          write (6,\"(a,I0,1x)\",advance=\"no\") \"N=\",N\nc          call ShowFactors(F)\n          FD = 0\t\t\n          DO I = 1,F.PVAL(0)\t\n            FD = DIGITSUM(F.PVAL(I),BASE)*F.PPOW(I) + FD\t\n          END DO\t\t\n          SMITHNUM = FD.EQ.DIGITSUM(N,BASE)\t\n        END FUNCTION SMITHNUM\t\n      END MODULE SMITHSTUFF\t\n\n      USE PRIMEBAG\t\n      USE SMITHSTUFF\t\n      INTEGER LAST\t\t\n      PARAMETER (LAST = 9999)\t\n      INTEGER I,N,BASE\t\t\n      INTEGER NB,BAG(20)\t\n      MSG = 6\t\n\n      WRITE (MSG,1) LAST\t\n    1 FORMAT ('To find the \"Smith\" numbers up to ',I0)\n      IF (.NOT.GRASPPRIMEBAG(66)) STOP \"Gan't grab my file\n\n   10 DO BASE = 2,12\t\n        WRITE (MSG,11) BASE\t\n   11   FORMAT (/,\"Working in base \",I0)\n        N = 0\t\t\t\n        NB = 0\t\t\t\n        DO I = 1,LAST\t\t\n          IF (ISPRIME(I)) CYCLE\t\t\n          IF (SMITHNUM(I,BASE)) THEN\t\n            N = N + 1\t\t\t\t\n            IF (NB.GE.20) THEN\t\t\t\n              WRITE (MSG,12) BAG\t\t\t\n   12         FORMAT (20I6)\t\t\t\t\n              NB = 0\t\t\t\t\t\n            END IF\t\t\t\t\n            NB = NB + 1\t\t\t\t\n            BAG(NB) = I\t\t\t\t\n          END IF\t\t\t\n        END DO\t\t\t\n        WRITE (MSG,12) BAG(1:NB)\n        WRITE (MSG,13) N\t\n   13   FORMAT (I9,\" found.\")\t\n      END DO\t\t\n      END\t\n", "target": "import java.util.*;\n\npublic class SmithNumbers {\n\n    public static void main(String[] args) {\n        for (int n = 1; n < 10_000; n++) {\n            List<Integer> factors = primeFactors(n);\n            if (factors.size() > 1) {\n                int sum = sumDigits(n);\n                for (int f : factors)\n                    sum -= sumDigits(f);\n                if (sum == 0)\n                    System.out.println(n);\n            }\n        }\n    }\n\n    static List<Integer> primeFactors(int n) {\n        List<Integer> result = new ArrayList<>();\n\n        for (int i = 2; n % i == 0; n /= i)\n            result.add(i);\n\n        for (int i = 3; i * i <= n; i += 2) {\n            while (n % i == 0) {\n                result.add(i);\n                n /= i;\n            }\n        }\n\n        if (n != 1)\n            result.add(n);\n\n        return result;\n    }\n\n    static int sumDigits(int n) {\n        int sum = 0;\n        while (n > 0) {\n            sum += (n % 10);\n            n /= 10;\n        }\n        return sum;\n    }\n}\n"}
{"id": 97155, "name": "Smith numbers", "source": "Translate Fortran to Java:       MODULE FACTORISE\t\n       USE PRIMEBAG\t\t\n       INTEGER LASTP\t\t\n       PARAMETER (LASTP = 9)\t\n       TYPE FACTORED\t\t\n        INTEGER PVAL(0:LASTP)\t\n        INTEGER PPOW(LASTP)\t\n       END TYPE FACTORED\t\n\n       CONTAINS\t\t\n        SUBROUTINE SHOWFACTORS(N)\t\n         TYPE(FACTORED) N\t\n         INTEGER I\t\t\n          DO I = 1,N.PVAL(0)\t\n            IF (I.GT.1) WRITE (MSG,\"('x',$)\")\t\n            WRITE (MSG,\"(I0,$)\") N.PVAL(I)\t\n            IF (N.PPOW(I).GT.1) WRITE (MSG,\"('^',I0,$)\") N.PPOW(I)\t\n          END DO\t\t\n          WRITE (MSG,1) N.PVAL(0)\t\n    1     FORMAT (\": Factor count \",I0)\t\n        END SUBROUTINE SHOWFACTORS\t\n\n        TYPE(FACTORED) FUNCTION FACTOR(IT)\t\nCareful\n         INTEGER IT,N\t\n         INTEGER F,FP\t\n          IF (IT.LE.0) STOP \"Factor only positive numbers\n          FACTOR.PVAL(0) = 0\t\n          F = 0\t\t\t\n          N = IT\t\t\nCollapse N into its prime factors.\n   10     DO WHILE(N.GT.1)\t\n            IF (ISPRIME(N)) THEN\n              F = N\t\t\t\n              FP = 1\t\t\t\n              N = 1\t\t\t\n             ELSE\t\t\n              FP = 0\t\t\t\n   11         F = NEXTPRIME(F)\t\t\n              DO WHILE(MOD(N,F).EQ.0)\t\n                FP = FP + 1\t\t\t\n                N = N/F\t\t\t\t\n              END DO\t\t\t\n              IF (FP.LE.0) GO TO 11\t\n            END IF\t\t\n            IF (FACTOR.PVAL(0).GE.LASTP) THEN\t\n              WRITE (MSG,1) IT,LASTP\t\t\n    1         FORMAT (\"Factoring \",I0,\" but with provision for only \",\t\n     1         I0,\" distinct prime factors\n              CALL SHOWFACTORS(FACTOR)\t\t\n              STOP \"Not enough storage\n            END IF\t\t\t\n            FACTOR.PVAL(0) = FACTOR.PVAL(0) + 1\t\n            FACTOR.PVAL(FACTOR.PVAL(0)) = F\t\n            FACTOR.PPOW(FACTOR.PVAL(0)) = FP\t\n          END DO\t\t\n        END FUNCTION FACTOR\t\n      END MODULE FACTORISE\t\n\n      MODULE SMITHSTUFF\t\n       CONTAINS\t\t\n        INTEGER FUNCTION DIGITSUM(N,BASE)\t\n         INTEGER N,IT\t\n         INTEGER BASE\t\n         IF (N.LT.0) STOP \"DigitSum: negative numbers need not apply\n          DIGITSUM = 0\t\n          IT = N\t\n          DO WHILE(IT.GT.0)\t\n            DIGITSUM = MOD(IT,BASE) + DIGITSUM\t\n            IT = IT/BASE\t\t\t\n          END DO\t\t\n        END FUNCTION DIGITSUM\t\n\n        LOGICAL FUNCTION SMITHNUM(N,BASE)\t\n         USE FACTORISE\t\t\n         INTEGER N\t\t\n         INTEGER BASE\t\t\n         TYPE(FACTORED) F\t\n         INTEGER I,FD\t\t\n          F = FACTOR(N)\t\t\nc          write (6,\"(a,I0,1x)\",advance=\"no\") \"N=\",N\nc          call ShowFactors(F)\n          FD = 0\t\t\n          DO I = 1,F.PVAL(0)\t\n            FD = DIGITSUM(F.PVAL(I),BASE)*F.PPOW(I) + FD\t\n          END DO\t\t\n          SMITHNUM = FD.EQ.DIGITSUM(N,BASE)\t\n        END FUNCTION SMITHNUM\t\n      END MODULE SMITHSTUFF\t\n\n      USE PRIMEBAG\t\n      USE SMITHSTUFF\t\n      INTEGER LAST\t\t\n      PARAMETER (LAST = 9999)\t\n      INTEGER I,N,BASE\t\t\n      INTEGER NB,BAG(20)\t\n      MSG = 6\t\n\n      WRITE (MSG,1) LAST\t\n    1 FORMAT ('To find the \"Smith\" numbers up to ',I0)\n      IF (.NOT.GRASPPRIMEBAG(66)) STOP \"Gan't grab my file\n\n   10 DO BASE = 2,12\t\n        WRITE (MSG,11) BASE\t\n   11   FORMAT (/,\"Working in base \",I0)\n        N = 0\t\t\t\n        NB = 0\t\t\t\n        DO I = 1,LAST\t\t\n          IF (ISPRIME(I)) CYCLE\t\t\n          IF (SMITHNUM(I,BASE)) THEN\t\n            N = N + 1\t\t\t\t\n            IF (NB.GE.20) THEN\t\t\t\n              WRITE (MSG,12) BAG\t\t\t\n   12         FORMAT (20I6)\t\t\t\t\n              NB = 0\t\t\t\t\t\n            END IF\t\t\t\t\n            NB = NB + 1\t\t\t\t\n            BAG(NB) = I\t\t\t\t\n          END IF\t\t\t\n        END DO\t\t\t\n        WRITE (MSG,12) BAG(1:NB)\n        WRITE (MSG,13) N\t\n   13   FORMAT (I9,\" found.\")\t\n      END DO\t\t\n      END\t\n", "target": "import java.util.*;\n\npublic class SmithNumbers {\n\n    public static void main(String[] args) {\n        for (int n = 1; n < 10_000; n++) {\n            List<Integer> factors = primeFactors(n);\n            if (factors.size() > 1) {\n                int sum = sumDigits(n);\n                for (int f : factors)\n                    sum -= sumDigits(f);\n                if (sum == 0)\n                    System.out.println(n);\n            }\n        }\n    }\n\n    static List<Integer> primeFactors(int n) {\n        List<Integer> result = new ArrayList<>();\n\n        for (int i = 2; n % i == 0; n /= i)\n            result.add(i);\n\n        for (int i = 3; i * i <= n; i += 2) {\n            while (n % i == 0) {\n                result.add(i);\n                n /= i;\n            }\n        }\n\n        if (n != 1)\n            result.add(n);\n\n        return result;\n    }\n\n    static int sumDigits(int n) {\n        int sum = 0;\n        while (n > 0) {\n            sum += (n % 10);\n            n /= 10;\n        }\n        return sum;\n    }\n}\n"}
{"id": 97156, "name": "Smith numbers", "source": "Translate Fortran to Python:       MODULE FACTORISE\t\n       USE PRIMEBAG\t\t\n       INTEGER LASTP\t\t\n       PARAMETER (LASTP = 9)\t\n       TYPE FACTORED\t\t\n        INTEGER PVAL(0:LASTP)\t\n        INTEGER PPOW(LASTP)\t\n       END TYPE FACTORED\t\n\n       CONTAINS\t\t\n        SUBROUTINE SHOWFACTORS(N)\t\n         TYPE(FACTORED) N\t\n         INTEGER I\t\t\n          DO I = 1,N.PVAL(0)\t\n            IF (I.GT.1) WRITE (MSG,\"('x',$)\")\t\n            WRITE (MSG,\"(I0,$)\") N.PVAL(I)\t\n            IF (N.PPOW(I).GT.1) WRITE (MSG,\"('^',I0,$)\") N.PPOW(I)\t\n          END DO\t\t\n          WRITE (MSG,1) N.PVAL(0)\t\n    1     FORMAT (\": Factor count \",I0)\t\n        END SUBROUTINE SHOWFACTORS\t\n\n        TYPE(FACTORED) FUNCTION FACTOR(IT)\t\nCareful\n         INTEGER IT,N\t\n         INTEGER F,FP\t\n          IF (IT.LE.0) STOP \"Factor only positive numbers\n          FACTOR.PVAL(0) = 0\t\n          F = 0\t\t\t\n          N = IT\t\t\nCollapse N into its prime factors.\n   10     DO WHILE(N.GT.1)\t\n            IF (ISPRIME(N)) THEN\n              F = N\t\t\t\n              FP = 1\t\t\t\n              N = 1\t\t\t\n             ELSE\t\t\n              FP = 0\t\t\t\n   11         F = NEXTPRIME(F)\t\t\n              DO WHILE(MOD(N,F).EQ.0)\t\n                FP = FP + 1\t\t\t\n                N = N/F\t\t\t\t\n              END DO\t\t\t\n              IF (FP.LE.0) GO TO 11\t\n            END IF\t\t\n            IF (FACTOR.PVAL(0).GE.LASTP) THEN\t\n              WRITE (MSG,1) IT,LASTP\t\t\n    1         FORMAT (\"Factoring \",I0,\" but with provision for only \",\t\n     1         I0,\" distinct prime factors\n              CALL SHOWFACTORS(FACTOR)\t\t\n              STOP \"Not enough storage\n            END IF\t\t\t\n            FACTOR.PVAL(0) = FACTOR.PVAL(0) + 1\t\n            FACTOR.PVAL(FACTOR.PVAL(0)) = F\t\n            FACTOR.PPOW(FACTOR.PVAL(0)) = FP\t\n          END DO\t\t\n        END FUNCTION FACTOR\t\n      END MODULE FACTORISE\t\n\n      MODULE SMITHSTUFF\t\n       CONTAINS\t\t\n        INTEGER FUNCTION DIGITSUM(N,BASE)\t\n         INTEGER N,IT\t\n         INTEGER BASE\t\n         IF (N.LT.0) STOP \"DigitSum: negative numbers need not apply\n          DIGITSUM = 0\t\n          IT = N\t\n          DO WHILE(IT.GT.0)\t\n            DIGITSUM = MOD(IT,BASE) + DIGITSUM\t\n            IT = IT/BASE\t\t\t\n          END DO\t\t\n        END FUNCTION DIGITSUM\t\n\n        LOGICAL FUNCTION SMITHNUM(N,BASE)\t\n         USE FACTORISE\t\t\n         INTEGER N\t\t\n         INTEGER BASE\t\t\n         TYPE(FACTORED) F\t\n         INTEGER I,FD\t\t\n          F = FACTOR(N)\t\t\nc          write (6,\"(a,I0,1x)\",advance=\"no\") \"N=\",N\nc          call ShowFactors(F)\n          FD = 0\t\t\n          DO I = 1,F.PVAL(0)\t\n            FD = DIGITSUM(F.PVAL(I),BASE)*F.PPOW(I) + FD\t\n          END DO\t\t\n          SMITHNUM = FD.EQ.DIGITSUM(N,BASE)\t\n        END FUNCTION SMITHNUM\t\n      END MODULE SMITHSTUFF\t\n\n      USE PRIMEBAG\t\n      USE SMITHSTUFF\t\n      INTEGER LAST\t\t\n      PARAMETER (LAST = 9999)\t\n      INTEGER I,N,BASE\t\t\n      INTEGER NB,BAG(20)\t\n      MSG = 6\t\n\n      WRITE (MSG,1) LAST\t\n    1 FORMAT ('To find the \"Smith\" numbers up to ',I0)\n      IF (.NOT.GRASPPRIMEBAG(66)) STOP \"Gan't grab my file\n\n   10 DO BASE = 2,12\t\n        WRITE (MSG,11) BASE\t\n   11   FORMAT (/,\"Working in base \",I0)\n        N = 0\t\t\t\n        NB = 0\t\t\t\n        DO I = 1,LAST\t\t\n          IF (ISPRIME(I)) CYCLE\t\t\n          IF (SMITHNUM(I,BASE)) THEN\t\n            N = N + 1\t\t\t\t\n            IF (NB.GE.20) THEN\t\t\t\n              WRITE (MSG,12) BAG\t\t\t\n   12         FORMAT (20I6)\t\t\t\t\n              NB = 0\t\t\t\t\t\n            END IF\t\t\t\t\n            NB = NB + 1\t\t\t\t\n            BAG(NB) = I\t\t\t\t\n          END IF\t\t\t\n        END DO\t\t\t\n        WRITE (MSG,12) BAG(1:NB)\n        WRITE (MSG,13) N\t\n   13   FORMAT (I9,\" found.\")\t\n      END DO\t\t\n      END\t\n", "target": "from sys import stdout\n\n\ndef factors(n):\n    rt = []\n    f = 2\n    if n == 1:\n        rt.append(1);\n    else:\n        while 1:\n            if 0 == ( n % f ):\n                rt.append(f);\n                n //= f\n                if n == 1:\n                    return rt\n            else:\n                f += 1\n    return rt\n\n\ndef sum_digits(n):\n    sum = 0\n    while n > 0:\n        m = n % 10\n        sum += m\n        n -= m\n        n //= 10\n\n    return sum\n\n\ndef add_all_digits(lst):\n    sum = 0\n    for i in range (len(lst)):\n        sum += sum_digits(lst[i])\n\n    return sum\n\n\ndef list_smith_numbers(cnt):\n    for i in range(4, cnt):\n        fac = factors(i)\n        if len(fac) > 1:\n            if sum_digits(i) == add_all_digits(fac):\n                stdout.write(\"{0} \".format(i) )\n\n\nlist_smith_numbers(10_000)\n"}
{"id": 97157, "name": "Smith numbers", "source": "Translate Fortran to Python:       MODULE FACTORISE\t\n       USE PRIMEBAG\t\t\n       INTEGER LASTP\t\t\n       PARAMETER (LASTP = 9)\t\n       TYPE FACTORED\t\t\n        INTEGER PVAL(0:LASTP)\t\n        INTEGER PPOW(LASTP)\t\n       END TYPE FACTORED\t\n\n       CONTAINS\t\t\n        SUBROUTINE SHOWFACTORS(N)\t\n         TYPE(FACTORED) N\t\n         INTEGER I\t\t\n          DO I = 1,N.PVAL(0)\t\n            IF (I.GT.1) WRITE (MSG,\"('x',$)\")\t\n            WRITE (MSG,\"(I0,$)\") N.PVAL(I)\t\n            IF (N.PPOW(I).GT.1) WRITE (MSG,\"('^',I0,$)\") N.PPOW(I)\t\n          END DO\t\t\n          WRITE (MSG,1) N.PVAL(0)\t\n    1     FORMAT (\": Factor count \",I0)\t\n        END SUBROUTINE SHOWFACTORS\t\n\n        TYPE(FACTORED) FUNCTION FACTOR(IT)\t\nCareful\n         INTEGER IT,N\t\n         INTEGER F,FP\t\n          IF (IT.LE.0) STOP \"Factor only positive numbers\n          FACTOR.PVAL(0) = 0\t\n          F = 0\t\t\t\n          N = IT\t\t\nCollapse N into its prime factors.\n   10     DO WHILE(N.GT.1)\t\n            IF (ISPRIME(N)) THEN\n              F = N\t\t\t\n              FP = 1\t\t\t\n              N = 1\t\t\t\n             ELSE\t\t\n              FP = 0\t\t\t\n   11         F = NEXTPRIME(F)\t\t\n              DO WHILE(MOD(N,F).EQ.0)\t\n                FP = FP + 1\t\t\t\n                N = N/F\t\t\t\t\n              END DO\t\t\t\n              IF (FP.LE.0) GO TO 11\t\n            END IF\t\t\n            IF (FACTOR.PVAL(0).GE.LASTP) THEN\t\n              WRITE (MSG,1) IT,LASTP\t\t\n    1         FORMAT (\"Factoring \",I0,\" but with provision for only \",\t\n     1         I0,\" distinct prime factors\n              CALL SHOWFACTORS(FACTOR)\t\t\n              STOP \"Not enough storage\n            END IF\t\t\t\n            FACTOR.PVAL(0) = FACTOR.PVAL(0) + 1\t\n            FACTOR.PVAL(FACTOR.PVAL(0)) = F\t\n            FACTOR.PPOW(FACTOR.PVAL(0)) = FP\t\n          END DO\t\t\n        END FUNCTION FACTOR\t\n      END MODULE FACTORISE\t\n\n      MODULE SMITHSTUFF\t\n       CONTAINS\t\t\n        INTEGER FUNCTION DIGITSUM(N,BASE)\t\n         INTEGER N,IT\t\n         INTEGER BASE\t\n         IF (N.LT.0) STOP \"DigitSum: negative numbers need not apply\n          DIGITSUM = 0\t\n          IT = N\t\n          DO WHILE(IT.GT.0)\t\n            DIGITSUM = MOD(IT,BASE) + DIGITSUM\t\n            IT = IT/BASE\t\t\t\n          END DO\t\t\n        END FUNCTION DIGITSUM\t\n\n        LOGICAL FUNCTION SMITHNUM(N,BASE)\t\n         USE FACTORISE\t\t\n         INTEGER N\t\t\n         INTEGER BASE\t\t\n         TYPE(FACTORED) F\t\n         INTEGER I,FD\t\t\n          F = FACTOR(N)\t\t\nc          write (6,\"(a,I0,1x)\",advance=\"no\") \"N=\",N\nc          call ShowFactors(F)\n          FD = 0\t\t\n          DO I = 1,F.PVAL(0)\t\n            FD = DIGITSUM(F.PVAL(I),BASE)*F.PPOW(I) + FD\t\n          END DO\t\t\n          SMITHNUM = FD.EQ.DIGITSUM(N,BASE)\t\n        END FUNCTION SMITHNUM\t\n      END MODULE SMITHSTUFF\t\n\n      USE PRIMEBAG\t\n      USE SMITHSTUFF\t\n      INTEGER LAST\t\t\n      PARAMETER (LAST = 9999)\t\n      INTEGER I,N,BASE\t\t\n      INTEGER NB,BAG(20)\t\n      MSG = 6\t\n\n      WRITE (MSG,1) LAST\t\n    1 FORMAT ('To find the \"Smith\" numbers up to ',I0)\n      IF (.NOT.GRASPPRIMEBAG(66)) STOP \"Gan't grab my file\n\n   10 DO BASE = 2,12\t\n        WRITE (MSG,11) BASE\t\n   11   FORMAT (/,\"Working in base \",I0)\n        N = 0\t\t\t\n        NB = 0\t\t\t\n        DO I = 1,LAST\t\t\n          IF (ISPRIME(I)) CYCLE\t\t\n          IF (SMITHNUM(I,BASE)) THEN\t\n            N = N + 1\t\t\t\t\n            IF (NB.GE.20) THEN\t\t\t\n              WRITE (MSG,12) BAG\t\t\t\n   12         FORMAT (20I6)\t\t\t\t\n              NB = 0\t\t\t\t\t\n            END IF\t\t\t\t\n            NB = NB + 1\t\t\t\t\n            BAG(NB) = I\t\t\t\t\n          END IF\t\t\t\n        END DO\t\t\t\n        WRITE (MSG,12) BAG(1:NB)\n        WRITE (MSG,13) N\t\n   13   FORMAT (I9,\" found.\")\t\n      END DO\t\t\n      END\t\n", "target": "from sys import stdout\n\n\ndef factors(n):\n    rt = []\n    f = 2\n    if n == 1:\n        rt.append(1);\n    else:\n        while 1:\n            if 0 == ( n % f ):\n                rt.append(f);\n                n //= f\n                if n == 1:\n                    return rt\n            else:\n                f += 1\n    return rt\n\n\ndef sum_digits(n):\n    sum = 0\n    while n > 0:\n        m = n % 10\n        sum += m\n        n -= m\n        n //= 10\n\n    return sum\n\n\ndef add_all_digits(lst):\n    sum = 0\n    for i in range (len(lst)):\n        sum += sum_digits(lst[i])\n\n    return sum\n\n\ndef list_smith_numbers(cnt):\n    for i in range(4, cnt):\n        fac = factors(i)\n        if len(fac) > 1:\n            if sum_digits(i) == add_all_digits(fac):\n                stdout.write(\"{0} \".format(i) )\n\n\nlist_smith_numbers(10_000)\n"}
{"id": 97609, "name": "Multiple regression", "source": "Translate Fortran to C#: *-----------------------------------------------------------------------\n* MR - multiple regression using the SLATEC library routine DHFTI\n*\n* Finds the nearest approximation to BETA in the system of linear equations:\n*                     \n*              X(j,i) . BETA(i) = Y(j)\n* where   \n*                  1 ... j ... N  \n*                  1 ... i ... K\n* and               \n*                  K .LE. N\n*\n* INPUT ARRAYS ARE DESTROYED\n*\n*___Name___________Type_______________In/Out____Description_____________\n*   X(N,K)         Double precision   In        Predictors\n*   Y(N)           Double precision   Both      On input:   N Observations\n*                                               On output:  K beta weights\n*   N              Integer            In        Number of observations\n*   K              Integer            In        Number of predictor variables\n*   DWORK(N+2*K)   Double precision   Neither   Workspace\n*   IWORK(K)       Integer            Neither   Workspace\n*-----------------------------------------------------------------------\n      SUBROUTINE MR (X, Y, N, K, DWORK, IWORK)\n       IMPLICIT NONE\n       INTEGER K, N, IWORK\n       DOUBLE PRECISION X, Y, DWORK\n       DIMENSION X(N,K), Y(N), DWORK(N+2*K), IWORK(K)\n       \n*         local variables\n       INTEGER I, J\n       DOUBLE PRECISION TAU, TOT\n       \n*        maximum of all column sums of magnitudes\n       TAU = 0.\n       DO J = 1, K\n         TOT = 0.\n         DO I = 1, N\n           TOT = TOT + ABS(X(I,J))\n         END DO\n         IF (TOT > TAU) TAU = TOT\n       END DO\n       TAU = TAU * EPSILON(TAU)        \n       \n*            call function\n       CALL DHFTI (X, N, N, K, Y, N, 1, TAU, \n     $  J, DWORK(1), DWORK(N+1), DWORK(N+K+1), IWORK)\n       IF (J < K) PRINT *, 'mr: solution is rank deficient\n       RETURN\n      END  \n      \n*-----------------------------------------------------------------------\n      PROGRAM t_mr        \n       IMPLICIT NONE\n       INTEGER N, K\n       PARAMETER (N=15, K=3)\n       INTEGER IWORK(K), I, J\n       DOUBLE PRECISION XIN(N), X(N,K), Y(N), DWORK(N+2*K)\n\n       DATA XIN / 1.47, 1.50, 1.52, 1.55, 1.57, 1.60, 1.63, 1.65, 1.68, \n     $            1.70, 1.73, 1.75, 1.78, 1.80, 1.83 /\n       DATA Y / 52.21, 53.12, 54.48, 55.84, 57.20, 58.57, 59.93, 61.29,\n     $          63.11, 64.47, 66.28, 68.10, 69.92, 72.19, 74.46 /\n\n*              make coefficient matrix\n       DO J = 1, K\n         DO I = 1, N\n           X(I,J) = XIN(I) **(J-1)\n         END DO\n       END DO\n\n*               solve\n       CALL MR (X, Y, N, K, DWORK, IWORK)\n       \n*               print result\n  10   FORMAT ('beta: ', $)\n  20   FORMAT (F12.4, $)\n  30   FORMAT ()\n       PRINT 10\n       DO J = 1, K\n         PRINT 20, Y(J)\n       END DO       \n       PRINT 30\n       STOP 'program complete'\n      END\n", "target": "using System;\nusing MathNet.Numerics.LinearRegression;\nusing MathNet.Numerics.LinearAlgebra;\nusing MathNet.Numerics.LinearAlgebra.Double;\n\nclass Program\n{\n    static void Main(string[] args)\n    {\n        var col = DenseVector.OfArray(new double[] { 1.47, 1.50, 1.52, 1.55, 1.57, 1.60, 1.63, 1.65,\n            1.68, 1.70, 1.73, 1.75, 1.78, 1.80, 1.83 });\n        var X = DenseMatrix.OfColumns(new Vector<double>[] { col.PointwisePower(0), col, col.PointwisePower(2) });\n        var y = DenseVector.OfArray(new double[] { 52.21, 53.12, 54.48, 55.84, 57.20, 58.57, 59.93,\n            61.29, 63.11, 64.47, 66.28, 68.10, 69.92, 72.19, 74.46 });\n        var \u03b2 = MultipleRegression.QR(X, y);\n        Console.WriteLine(\u03b2);\n    }\n}\n"}
{"id": 97613, "name": "Multiple regression", "source": "Translate Fortran to Java: *-----------------------------------------------------------------------\n* MR - multiple regression using the SLATEC library routine DHFTI\n*\n* Finds the nearest approximation to BETA in the system of linear equations:\n*                     \n*              X(j,i) . BETA(i) = Y(j)\n* where   \n*                  1 ... j ... N  \n*                  1 ... i ... K\n* and               \n*                  K .LE. N\n*\n* INPUT ARRAYS ARE DESTROYED\n*\n*___Name___________Type_______________In/Out____Description_____________\n*   X(N,K)         Double precision   In        Predictors\n*   Y(N)           Double precision   Both      On input:   N Observations\n*                                               On output:  K beta weights\n*   N              Integer            In        Number of observations\n*   K              Integer            In        Number of predictor variables\n*   DWORK(N+2*K)   Double precision   Neither   Workspace\n*   IWORK(K)       Integer            Neither   Workspace\n*-----------------------------------------------------------------------\n      SUBROUTINE MR (X, Y, N, K, DWORK, IWORK)\n       IMPLICIT NONE\n       INTEGER K, N, IWORK\n       DOUBLE PRECISION X, Y, DWORK\n       DIMENSION X(N,K), Y(N), DWORK(N+2*K), IWORK(K)\n       \n*         local variables\n       INTEGER I, J\n       DOUBLE PRECISION TAU, TOT\n       \n*        maximum of all column sums of magnitudes\n       TAU = 0.\n       DO J = 1, K\n         TOT = 0.\n         DO I = 1, N\n           TOT = TOT + ABS(X(I,J))\n         END DO\n         IF (TOT > TAU) TAU = TOT\n       END DO\n       TAU = TAU * EPSILON(TAU)        \n       \n*            call function\n       CALL DHFTI (X, N, N, K, Y, N, 1, TAU, \n     $  J, DWORK(1), DWORK(N+1), DWORK(N+K+1), IWORK)\n       IF (J < K) PRINT *, 'mr: solution is rank deficient\n       RETURN\n      END  \n      \n*-----------------------------------------------------------------------\n      PROGRAM t_mr        \n       IMPLICIT NONE\n       INTEGER N, K\n       PARAMETER (N=15, K=3)\n       INTEGER IWORK(K), I, J\n       DOUBLE PRECISION XIN(N), X(N,K), Y(N), DWORK(N+2*K)\n\n       DATA XIN / 1.47, 1.50, 1.52, 1.55, 1.57, 1.60, 1.63, 1.65, 1.68, \n     $            1.70, 1.73, 1.75, 1.78, 1.80, 1.83 /\n       DATA Y / 52.21, 53.12, 54.48, 55.84, 57.20, 58.57, 59.93, 61.29,\n     $          63.11, 64.47, 66.28, 68.10, 69.92, 72.19, 74.46 /\n\n*              make coefficient matrix\n       DO J = 1, K\n         DO I = 1, N\n           X(I,J) = XIN(I) **(J-1)\n         END DO\n       END DO\n\n*               solve\n       CALL MR (X, Y, N, K, DWORK, IWORK)\n       \n*               print result\n  10   FORMAT ('beta: ', $)\n  20   FORMAT (F12.4, $)\n  30   FORMAT ()\n       PRINT 10\n       DO J = 1, K\n         PRINT 20, Y(J)\n       END DO       \n       PRINT 30\n       STOP 'program complete'\n      END\n", "target": "import java.util.Arrays;\nimport java.util.Objects;\n\npublic class MultipleRegression {\n    public static void require(boolean condition, String message) {\n        if (condition) {\n            return;\n        }\n        throw new IllegalArgumentException(message);\n    }\n\n    public static class Matrix {\n        private final double[][] data;\n        private final int rowCount;\n        private final int colCount;\n\n        public Matrix(int rows, int cols) {\n            require(rows > 0, \"Need at least one row\");\n            this.rowCount = rows;\n\n            require(cols > 0, \"Need at least one column\");\n            this.colCount = cols;\n\n            this.data = new double[rows][cols];\n            for (double[] row : this.data) {\n                Arrays.fill(row, 0.0);\n            }\n        }\n\n        public Matrix(double[][] source) {\n            require(source.length > 0, \"Need at least one row\");\n            this.rowCount = source.length;\n\n            require(source[0].length > 0, \"Need at least one column\");\n            this.colCount = source[0].length;\n\n            this.data = new double[this.rowCount][this.colCount];\n            for (int i = 0; i < this.rowCount; i++) {\n                set(i, source[i]);\n            }\n        }\n\n        public double[] get(int row) {\n            Objects.checkIndex(row, this.rowCount);\n            return this.data[row];\n        }\n\n        public void set(int row, double[] data) {\n            Objects.checkIndex(row, this.rowCount);\n            require(data.length == this.colCount, \"The column in the row must match the number of columns in the matrix\");\n            System.arraycopy(data, 0, this.data[row], 0, this.colCount);\n        }\n\n        public double get(int row, int col) {\n            Objects.checkIndex(row, this.rowCount);\n            Objects.checkIndex(col, this.colCount);\n            return this.data[row][col];\n        }\n\n        public void set(int row, int col, double value) {\n            Objects.checkIndex(row, this.rowCount);\n            Objects.checkIndex(col, this.colCount);\n            this.data[row][col] = value;\n        }\n\n        @SuppressWarnings(\"UnnecessaryLocalVariable\")\n        public Matrix times(Matrix that) {\n            var rc1 = this.rowCount;\n            var cc1 = this.colCount;\n            var rc2 = that.rowCount;\n            var cc2 = that.colCount;\n            require(cc1 == rc2, \"Cannot multiply if the first columns does not equal the second rows\");\n            var result = new Matrix(rc1, cc2);\n            for (int i = 0; i < rc1; i++) {\n                for (int j = 0; j < cc2; j++) {\n                    for (int k = 0; k < rc2; k++) {\n                        var prod = get(i, k) * that.get(k, j);\n                        result.set(i, j, result.get(i, j) + prod);\n                    }\n                }\n            }\n            return result;\n        }\n\n        public Matrix transpose() {\n            var rc = this.rowCount;\n            var cc = this.colCount;\n            var trans = new Matrix(cc, rc);\n            for (int i = 0; i < cc; i++) {\n                for (int j = 0; j < rc; j++) {\n                    trans.set(i, j, get(j, i));\n                }\n            }\n            return trans;\n        }\n\n        public void toReducedRowEchelonForm() {\n            int lead = 0;\n            var rc = this.rowCount;\n            var cc = this.colCount;\n            for (int r = 0; r < rc; r++) {\n                if (cc <= lead) {\n                    return;\n                }\n                var i = r;\n\n                while (get(i, lead) == 0.0) {\n                    i++;\n                    if (rc == i) {\n                        i = r;\n                        lead++;\n                        if (cc == lead) {\n                            return;\n                        }\n                    }\n                }\n\n                var temp = get(i);\n                set(i, get(r));\n                set(r, temp);\n\n                if (get(r, lead) != 0.0) {\n                    var div = get(r, lead);\n                    for (int j = 0; j < cc; j++) {\n                        set(r, j, get(r, j) / div);\n                    }\n                }\n\n                for (int k = 0; k < rc; k++) {\n                    if (k != r) {\n                        var mult = get(k, lead);\n                        for (int j = 0; j < cc; j++) {\n                            var prod = get(r, j) * mult;\n                            set(k, j, get(k, j) - prod);\n                        }\n                    }\n                }\n\n                lead++;\n            }\n        }\n\n        public Matrix inverse() {\n            require(this.rowCount == this.colCount, \"Not a square matrix\");\n            var len = this.rowCount;\n            var aug = new Matrix(len, 2 * len);\n            for (int i = 0; i < len; i++) {\n                for (int j = 0; j < len; j++) {\n                    aug.set(i, j, get(i, j));\n                }\n                \n                aug.set(i, i + len, 1.0);\n            }\n            aug.toReducedRowEchelonForm();\n            var inv = new Matrix(len, len);\n            \n            for (int i = 0; i < len; i++) {\n                for (int j = len; j < 2 * len; j++) {\n                    inv.set(i, j - len, aug.get(i, j));\n                }\n            }\n            return inv;\n        }\n    }\n\n    public static double[] multipleRegression(double[] y, Matrix x) {\n        var tm = new Matrix(new double[][]{y});\n        var cy = tm.transpose();\n        var cx = x.transpose();\n        return x.times(cx).inverse().times(x).times(cy).transpose().get(0);\n    }\n\n    public static void printVector(double[] v) {\n        System.out.println(Arrays.toString(v));\n        System.out.println();\n    }\n\n    public static double[] repeat(int size, double value) {\n        var a = new double[size];\n        Arrays.fill(a, value);\n        return a;\n    }\n\n    public static void main(String[] args) {\n        double[] y = new double[]{1.0, 2.0, 3.0, 4.0, 5.0};\n        var x = new Matrix(new double[][]{{2.0, 1.0, 3.0, 4.0, 5.0}});\n        var v = multipleRegression(y, x);\n        printVector(v);\n\n        y = new double[]{3.0, 4.0, 5.0};\n        x = new Matrix(new double[][]{\n            {1.0, 2.0, 1.0},\n            {1.0, 1.0, 2.0}\n        });\n        v = multipleRegression(y, x);\n        printVector(v);\n\n        y = new double[]{52.21, 53.12, 54.48, 55.84, 57.20, 58.57, 59.93, 61.29, 63.11, 64.47, 66.28, 68.10, 69.92, 72.19, 74.46};\n        var a = new double[]{1.47, 1.50, 1.52, 1.55, 1.57, 1.60, 1.63, 1.65, 1.68, 1.70, 1.73, 1.75, 1.78, 1.80, 1.83};\n        x = new Matrix(new double[][]{\n            repeat(a.length, 1.0),\n            a,\n            Arrays.stream(a).map(it -> it * it).toArray()\n        });\n\n        v = multipleRegression(y, x);\n        printVector(v);\n    }\n}\n"}
{"id": 97614, "name": "Multiple regression", "source": "Translate Fortran to Python: *-----------------------------------------------------------------------\n* MR - multiple regression using the SLATEC library routine DHFTI\n*\n* Finds the nearest approximation to BETA in the system of linear equations:\n*                     \n*              X(j,i) . BETA(i) = Y(j)\n* where   \n*                  1 ... j ... N  \n*                  1 ... i ... K\n* and               \n*                  K .LE. N\n*\n* INPUT ARRAYS ARE DESTROYED\n*\n*___Name___________Type_______________In/Out____Description_____________\n*   X(N,K)         Double precision   In        Predictors\n*   Y(N)           Double precision   Both      On input:   N Observations\n*                                               On output:  K beta weights\n*   N              Integer            In        Number of observations\n*   K              Integer            In        Number of predictor variables\n*   DWORK(N+2*K)   Double precision   Neither   Workspace\n*   IWORK(K)       Integer            Neither   Workspace\n*-----------------------------------------------------------------------\n      SUBROUTINE MR (X, Y, N, K, DWORK, IWORK)\n       IMPLICIT NONE\n       INTEGER K, N, IWORK\n       DOUBLE PRECISION X, Y, DWORK\n       DIMENSION X(N,K), Y(N), DWORK(N+2*K), IWORK(K)\n       \n*         local variables\n       INTEGER I, J\n       DOUBLE PRECISION TAU, TOT\n       \n*        maximum of all column sums of magnitudes\n       TAU = 0.\n       DO J = 1, K\n         TOT = 0.\n         DO I = 1, N\n           TOT = TOT + ABS(X(I,J))\n         END DO\n         IF (TOT > TAU) TAU = TOT\n       END DO\n       TAU = TAU * EPSILON(TAU)        \n       \n*            call function\n       CALL DHFTI (X, N, N, K, Y, N, 1, TAU, \n     $  J, DWORK(1), DWORK(N+1), DWORK(N+K+1), IWORK)\n       IF (J < K) PRINT *, 'mr: solution is rank deficient\n       RETURN\n      END  \n      \n*-----------------------------------------------------------------------\n      PROGRAM t_mr        \n       IMPLICIT NONE\n       INTEGER N, K\n       PARAMETER (N=15, K=3)\n       INTEGER IWORK(K), I, J\n       DOUBLE PRECISION XIN(N), X(N,K), Y(N), DWORK(N+2*K)\n\n       DATA XIN / 1.47, 1.50, 1.52, 1.55, 1.57, 1.60, 1.63, 1.65, 1.68, \n     $            1.70, 1.73, 1.75, 1.78, 1.80, 1.83 /\n       DATA Y / 52.21, 53.12, 54.48, 55.84, 57.20, 58.57, 59.93, 61.29,\n     $          63.11, 64.47, 66.28, 68.10, 69.92, 72.19, 74.46 /\n\n*              make coefficient matrix\n       DO J = 1, K\n         DO I = 1, N\n           X(I,J) = XIN(I) **(J-1)\n         END DO\n       END DO\n\n*               solve\n       CALL MR (X, Y, N, K, DWORK, IWORK)\n       \n*               print result\n  10   FORMAT ('beta: ', $)\n  20   FORMAT (F12.4, $)\n  30   FORMAT ()\n       PRINT 10\n       DO J = 1, K\n         PRINT 20, Y(J)\n       END DO       \n       PRINT 30\n       STOP 'program complete'\n      END\n", "target": "import numpy as np\n\nheight = [1.47, 1.50, 1.52, 1.55, 1.57, 1.60, 1.63,\n    1.65, 1.68, 1.70, 1.73, 1.75, 1.78, 1.80, 1.83]\nweight = [52.21, 53.12, 54.48, 55.84, 57.20, 58.57, 59.93,\n    61.29, 63.11, 64.47, 66.28, 68.10, 69.92, 72.19, 74.46]\n\nX = np.mat(height**np.arange(3)[:, None])\ny = np.mat(weight)\n\nprint(y * X.T * (X*X.T).I)\n"}
{"id": 97730, "name": "Bitmap_Flood fill", "source": "Translate Fortran to C#: module RCImageArea\n  use RCImageBasic\n  use RCImagePrimitive\n  implicit none\n\n  real, parameter, private :: matchdistance = 0.2\n\n  private :: northsouth, eastwest\n\ncontains\n\n  subroutine northsouth(img, p0, tcolor, fcolor)\n    type(rgbimage), intent(inout) :: img\n    type(point), intent(in) :: p0\n    type(rgb), intent(in) :: tcolor, fcolor\n\n    integer :: npy, spy, y\n    type(rgb) :: pc\n\n    npy = p0%y - 1\n    do\n       if ( inside_image(img, p0%x, npy) ) then\n          call get_pixel(img, p0%x, npy, pc)\n          if ( ((pc .dist. tcolor) > matchdistance ) .or. ( pc == fcolor ) ) exit\n       else\n          exit\n       end if\n       npy = npy - 1\n    end do\n    npy = npy + 1\n    spy = p0%y + 1\n    do\n       if ( inside_image(img, p0%x, spy) ) then\n          call get_pixel(img, p0%x, spy, pc)\n          if ( ((pc .dist. tcolor) > matchdistance ) .or. ( pc == fcolor ) ) exit\n       else\n          exit\n       end if\n       spy = spy + 1       \n    end do\n    spy = spy - 1\n    call draw_line(img, point(p0%x, spy), point(p0%x, npy), fcolor)\n    \n    do y = min(spy, npy), max(spy, npy)\n       if ( y == p0%y ) cycle\n       call eastwest(img, point(p0%x, y), tcolor, fcolor)\n    end do\n    \n  end subroutine northsouth\n\n\n  subroutine eastwest(img, p0, tcolor, fcolor)\n    type(rgbimage), intent(inout) :: img\n    type(point), intent(in) :: p0\n    type(rgb), intent(in) :: tcolor, fcolor\n\n    integer :: npx, spx, x\n    type(rgb) :: pc\n\n    npx = p0%x - 1\n    do\n       if ( inside_image(img, npx, p0%y) ) then\n          call get_pixel(img, npx, p0%y, pc)\n          if ( ((pc .dist. tcolor) > matchdistance ) .or. ( pc == fcolor ) ) exit\n       else\n          exit\n       end if\n       npx = npx - 1\n    end do\n    npx = npx + 1\n    spx = p0%x + 1\n    do\n       if ( inside_image(img, spx, p0%y) ) then\n          call get_pixel(img, spx, p0%y, pc)\n          if ( ((pc .dist. tcolor) > matchdistance ) .or. ( pc == fcolor ) ) exit\n       else\n          exit\n       end if\n       spx = spx + 1       \n    end do\n    spx = spx - 1\n    call draw_line(img, point(spx, p0%y), point(npx, p0%y), fcolor)\n    \n    do x = min(spx, npx), max(spx, npx)\n       if ( x == p0%x ) cycle\n       call northsouth(img, point(x, p0%y), tcolor, fcolor)\n    end do\n    \n  end subroutine eastwest\n\n  subroutine floodfill(img, p0, tcolor, fcolor)\n    type(rgbimage), intent(inout) :: img\n    type(point), intent(in) :: p0\n    type(rgb), intent(in) :: tcolor, fcolor\n    \n    type(rgb) :: pcolor\n\n    if ( .not. inside_image(img, p0%x, p0%y) ) return\n    call get_pixel(img, p0%x, p0%y, pcolor)\n    if ( (pcolor .dist. tcolor) > matchdistance ) return\n\n    call northsouth(img, p0, tcolor, fcolor)\n    call eastwest(img, p0, tcolor, fcolor)\n  end subroutine floodfill\n\nend module RCImageArea\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Drawing;\n\nnamespace FloodFill\n{\n    class Program\n    {\n        private static bool ColorMatch(Color a, Color b)\n        {\n            return (a.ToArgb() & 0xffffff) == (b.ToArgb() & 0xffffff);\n        }\n\n        static void FloodFill(Bitmap bmp, Point pt, Color targetColor, Color replacementColor)\n        {\n            Queue<Point> q = new Queue<Point>();\n            q.Enqueue(pt);\n            while (q.Count > 0)\n            {\n                Point n = q.Dequeue();\n                if (!ColorMatch(bmp.GetPixel(n.X, n.Y),targetColor))\n                    continue;\n                Point w = n, e = new Point(n.X + 1, n.Y);\n                while ((w.X >= 0) && ColorMatch(bmp.GetPixel(w.X, w.Y),targetColor))\n                {\n                    bmp.SetPixel(w.X, w.Y, replacementColor);\n                    if ((w.Y > 0) && ColorMatch(bmp.GetPixel(w.X, w.Y - 1),targetColor))\n                        q.Enqueue(new Point(w.X, w.Y - 1));\n                    if ((w.Y < bmp.Height - 1) && ColorMatch(bmp.GetPixel(w.X, w.Y + 1),targetColor))\n                        q.Enqueue(new Point(w.X, w.Y + 1));\n                    w.X--;\n                }\n                while ((e.X <= bmp.Width - 1) && ColorMatch(bmp.GetPixel(e.X, e.Y),targetColor))\n                {\n                    bmp.SetPixel(e.X, e.Y, replacementColor);\n                    if ((e.Y > 0) && ColorMatch(bmp.GetPixel(e.X, e.Y - 1), targetColor))\n                        q.Enqueue(new Point(e.X, e.Y - 1));\n                    if ((e.Y < bmp.Height - 1) && ColorMatch(bmp.GetPixel(e.X, e.Y + 1), targetColor))\n                        q.Enqueue(new Point(e.X, e.Y + 1));\n                    e.X++;\n                }\n            }\n        }\n\n        static void Main(string[] args)\n        {\n            Bitmap bmp = new Bitmap(\"Unfilledcirc.bmp\");\n            FloodFill(bmp, new Point(200, 200), Color.White, Color.Red);\n            FloodFill(bmp, new Point(100, 100), Color.Black, Color.Blue);\n            bmp.Save(\"Filledcirc.bmp\");\n        }\n    }\n}\n"}
{"id": 97734, "name": "Bitmap_Flood fill", "source": "Translate Fortran to Java: module RCImageArea\n  use RCImageBasic\n  use RCImagePrimitive\n  implicit none\n\n  real, parameter, private :: matchdistance = 0.2\n\n  private :: northsouth, eastwest\n\ncontains\n\n  subroutine northsouth(img, p0, tcolor, fcolor)\n    type(rgbimage), intent(inout) :: img\n    type(point), intent(in) :: p0\n    type(rgb), intent(in) :: tcolor, fcolor\n\n    integer :: npy, spy, y\n    type(rgb) :: pc\n\n    npy = p0%y - 1\n    do\n       if ( inside_image(img, p0%x, npy) ) then\n          call get_pixel(img, p0%x, npy, pc)\n          if ( ((pc .dist. tcolor) > matchdistance ) .or. ( pc == fcolor ) ) exit\n       else\n          exit\n       end if\n       npy = npy - 1\n    end do\n    npy = npy + 1\n    spy = p0%y + 1\n    do\n       if ( inside_image(img, p0%x, spy) ) then\n          call get_pixel(img, p0%x, spy, pc)\n          if ( ((pc .dist. tcolor) > matchdistance ) .or. ( pc == fcolor ) ) exit\n       else\n          exit\n       end if\n       spy = spy + 1       \n    end do\n    spy = spy - 1\n    call draw_line(img, point(p0%x, spy), point(p0%x, npy), fcolor)\n    \n    do y = min(spy, npy), max(spy, npy)\n       if ( y == p0%y ) cycle\n       call eastwest(img, point(p0%x, y), tcolor, fcolor)\n    end do\n    \n  end subroutine northsouth\n\n\n  subroutine eastwest(img, p0, tcolor, fcolor)\n    type(rgbimage), intent(inout) :: img\n    type(point), intent(in) :: p0\n    type(rgb), intent(in) :: tcolor, fcolor\n\n    integer :: npx, spx, x\n    type(rgb) :: pc\n\n    npx = p0%x - 1\n    do\n       if ( inside_image(img, npx, p0%y) ) then\n          call get_pixel(img, npx, p0%y, pc)\n          if ( ((pc .dist. tcolor) > matchdistance ) .or. ( pc == fcolor ) ) exit\n       else\n          exit\n       end if\n       npx = npx - 1\n    end do\n    npx = npx + 1\n    spx = p0%x + 1\n    do\n       if ( inside_image(img, spx, p0%y) ) then\n          call get_pixel(img, spx, p0%y, pc)\n          if ( ((pc .dist. tcolor) > matchdistance ) .or. ( pc == fcolor ) ) exit\n       else\n          exit\n       end if\n       spx = spx + 1       \n    end do\n    spx = spx - 1\n    call draw_line(img, point(spx, p0%y), point(npx, p0%y), fcolor)\n    \n    do x = min(spx, npx), max(spx, npx)\n       if ( x == p0%x ) cycle\n       call northsouth(img, point(x, p0%y), tcolor, fcolor)\n    end do\n    \n  end subroutine eastwest\n\n  subroutine floodfill(img, p0, tcolor, fcolor)\n    type(rgbimage), intent(inout) :: img\n    type(point), intent(in) :: p0\n    type(rgb), intent(in) :: tcolor, fcolor\n    \n    type(rgb) :: pcolor\n\n    if ( .not. inside_image(img, p0%x, p0%y) ) return\n    call get_pixel(img, p0%x, p0%y, pcolor)\n    if ( (pcolor .dist. tcolor) > matchdistance ) return\n\n    call northsouth(img, p0, tcolor, fcolor)\n    call eastwest(img, p0, tcolor, fcolor)\n  end subroutine floodfill\n\nend module RCImageArea\n", "target": "import java.awt.Color;\nimport java.awt.Point;\nimport java.awt.image.BufferedImage;\nimport java.util.Deque;\nimport java.util.LinkedList;\n\npublic class FloodFill {\n  public void floodFill(BufferedImage image, Point node, Color targetColor, Color replacementColor) {\n    int width = image.getWidth();\n    int height = image.getHeight();\n    int target = targetColor.getRGB();\n    int replacement = replacementColor.getRGB();\n    if (target != replacement) {\n      Deque<Point> queue = new LinkedList<Point>();\n      do {\n        int x = node.x;\n        int y = node.y;\n        while (x > 0 && image.getRGB(x - 1, y) == target) {\n          x--;\n        }\n        boolean spanUp = false;\n        boolean spanDown = false;\n        while (x < width && image.getRGB(x, y) == target) {\n          image.setRGB(x, y, replacement);\n          if (!spanUp && y > 0 && image.getRGB(x, y - 1) == target) {\n            queue.add(new Point(x, y - 1));\n            spanUp = true;\n          } else if (spanUp && y > 0 && image.getRGB(x, y - 1) != target) {\n            spanUp = false;\n          }\n          if (!spanDown && y < height - 1 && image.getRGB(x, y + 1) == target) {\n            queue.add(new Point(x, y + 1));\n            spanDown = true;\n          } else if (spanDown && y < height - 1 && image.getRGB(x, y + 1) != target) {\n            spanDown = false;\n          }\n          x++;\n        }\n      } while ((node = queue.pollFirst()) != null);\n    }\n  }\n}\n"}
{"id": 97735, "name": "Bitmap_Flood fill", "source": "Translate Fortran to Python: module RCImageArea\n  use RCImageBasic\n  use RCImagePrimitive\n  implicit none\n\n  real, parameter, private :: matchdistance = 0.2\n\n  private :: northsouth, eastwest\n\ncontains\n\n  subroutine northsouth(img, p0, tcolor, fcolor)\n    type(rgbimage), intent(inout) :: img\n    type(point), intent(in) :: p0\n    type(rgb), intent(in) :: tcolor, fcolor\n\n    integer :: npy, spy, y\n    type(rgb) :: pc\n\n    npy = p0%y - 1\n    do\n       if ( inside_image(img, p0%x, npy) ) then\n          call get_pixel(img, p0%x, npy, pc)\n          if ( ((pc .dist. tcolor) > matchdistance ) .or. ( pc == fcolor ) ) exit\n       else\n          exit\n       end if\n       npy = npy - 1\n    end do\n    npy = npy + 1\n    spy = p0%y + 1\n    do\n       if ( inside_image(img, p0%x, spy) ) then\n          call get_pixel(img, p0%x, spy, pc)\n          if ( ((pc .dist. tcolor) > matchdistance ) .or. ( pc == fcolor ) ) exit\n       else\n          exit\n       end if\n       spy = spy + 1       \n    end do\n    spy = spy - 1\n    call draw_line(img, point(p0%x, spy), point(p0%x, npy), fcolor)\n    \n    do y = min(spy, npy), max(spy, npy)\n       if ( y == p0%y ) cycle\n       call eastwest(img, point(p0%x, y), tcolor, fcolor)\n    end do\n    \n  end subroutine northsouth\n\n\n  subroutine eastwest(img, p0, tcolor, fcolor)\n    type(rgbimage), intent(inout) :: img\n    type(point), intent(in) :: p0\n    type(rgb), intent(in) :: tcolor, fcolor\n\n    integer :: npx, spx, x\n    type(rgb) :: pc\n\n    npx = p0%x - 1\n    do\n       if ( inside_image(img, npx, p0%y) ) then\n          call get_pixel(img, npx, p0%y, pc)\n          if ( ((pc .dist. tcolor) > matchdistance ) .or. ( pc == fcolor ) ) exit\n       else\n          exit\n       end if\n       npx = npx - 1\n    end do\n    npx = npx + 1\n    spx = p0%x + 1\n    do\n       if ( inside_image(img, spx, p0%y) ) then\n          call get_pixel(img, spx, p0%y, pc)\n          if ( ((pc .dist. tcolor) > matchdistance ) .or. ( pc == fcolor ) ) exit\n       else\n          exit\n       end if\n       spx = spx + 1       \n    end do\n    spx = spx - 1\n    call draw_line(img, point(spx, p0%y), point(npx, p0%y), fcolor)\n    \n    do x = min(spx, npx), max(spx, npx)\n       if ( x == p0%x ) cycle\n       call northsouth(img, point(x, p0%y), tcolor, fcolor)\n    end do\n    \n  end subroutine eastwest\n\n  subroutine floodfill(img, p0, tcolor, fcolor)\n    type(rgbimage), intent(inout) :: img\n    type(point), intent(in) :: p0\n    type(rgb), intent(in) :: tcolor, fcolor\n    \n    type(rgb) :: pcolor\n\n    if ( .not. inside_image(img, p0%x, p0%y) ) return\n    call get_pixel(img, p0%x, p0%y, pcolor)\n    if ( (pcolor .dist. tcolor) > matchdistance ) return\n\n    call northsouth(img, p0, tcolor, fcolor)\n    call eastwest(img, p0, tcolor, fcolor)\n  end subroutine floodfill\n\nend module RCImageArea\n", "target": "from collections import deque\n\nimage_file = \"image.png\"\nfill_color = color(250, 0, 0)\ntolerance = 15\nallowed = False\n\ndef setup():\n    global img\n    size(600, 400)\n    img = loadImage(image_file)\n    fill(0, 0, 100)\n    textSize(18)\n    show()\n    \ndef show():\n    image(img, 0, 0, width, height)\n    text(\"Tolerance = {}    (Use mouse wheel to change)\".format(tolerance),\n         100, height - 30)\n    text(\"Right click to reset\", 100, height - 10)\n \ndef draw():\n    global allowed\n    if allowed:\n        show()\n        allowed = False\n\ndef mousePressed():\n    global allowed, img\n    if mouseButton == RIGHT:\n        img = loadImage(image_file)\n    else:\n        img.loadPixels()\n        flood(mouseX, mouseY)\n        img.updatePixels()\n    allowed = True    \n\ndef mouseWheel(event):\n    global allowed, tolerance\n    e = event.getCount()\n    tolerance += 2 * e\n    if tolerance > 128:\n        tolerance = 128\n    if tolerance < 0:\n        tolerance = 0\n    allowed = True\n\ndef flood(x, y):\n    target_color = img.pixels[pixel_position(mouseX, mouseY)]\n    if target_color != fill_color:\n        queue = deque()\n        queue.append((x, y))\n        while len(queue) > 0:\n            p_x, p_y = queue.popleft()\n            if (check(p_x, p_y, target_color)):\n                queue.append((p_x, p_y - 1))\n                queue.append((p_x, p_y + 1))\n                queue.append((p_x - 1, p_y))\n                queue.append((p_x + 1, p_y))\n\ndef pixel_position(x, y):\n    return x + (y * img.width)\n\ndef check(x, y, target_color):\n    if x < 0 or y < 0 or y >= img.height or x >= img.width:\n        return False\n    pp = img.pixels[pixel_position(x, y)]\n    test_tolerance = (abs(green(target_color) - green(pp)) < tolerance\n                      and abs(red(target_color) - red(pp)) < tolerance\n                      and abs(blue(target_color) - blue(pp)) < tolerance)\n    if not test_tolerance:\n        return False\n    img.pixels[pixel_position(x, y)] = fill_color\n    return True\n"}
{"id": 98362, "name": "Determine if a string has all the same characters", "source": "Translate Fortran to C#: program demo_verify\nimplicit none\n    call homogeneous('')\n    call homogeneous('2')\n    call homogeneous('333')\n    call homogeneous('.55')\n    call homogeneous('tttTTT')\n    call homogeneous('4444  444k')\ncontains\n\nsubroutine homogeneous(str)\ncharacter(len=*),intent(in)  :: str\ncharacter(len=:),allocatable :: ch\ncharacter(len=*),parameter   :: g='(*(g0))'\ninteger :: where\n   if(len(str)>0)then;ch=str(1:1);else;ch='';endif\n   where=verify(str,ch)\n   if(where.eq.0)then\n     write(*,g)'STR: \"',str,'\" LEN: ',len(str),'. All chars are a ','\"'//ch//'\"'\n   else\n     write(*,g)'STR: \"',str,'\" LEN: ',len(str), &\n     & '. Multiple chars found. First difference at position ',where, &\n     & ' where a ','\"'//str(where:where)//'\"(hex:',hex(str(where:where)),') was found.'\n     write(*,g)repeat(' ',where+5),'^'\n   endif\nend subroutine homogeneous\n\nfunction hex(ch) result(hexstr)\ncharacter(len=1),intent(in) :: ch\ncharacter(len=:),allocatable :: hexstr\n   hexstr=repeat(' ',100)\n   write(hexstr,'(Z0)')ch\n   hexstr=trim(hexstr)\nend function hex \n\nend program demo_verify\n", "target": "using System;\n\nnamespace AllSame {\n    class Program {\n        static void Analyze(string s) {\n            Console.WriteLine(\"Examining [{0}] which has a length of {1}:\", s, s.Length);\n            if (s.Length > 1) {\n                var b = s[0];\n                for (int i = 1; i < s.Length; i++) {\n                    var c = s[i];\n                    if (c != b) {\n                        Console.WriteLine(\"    Not all characters in the string are the same.\");\n                        Console.WriteLine(\"    '{0}' (0x{1:X02}) is different at position {2}\", c, (int)c, i);\n                        return;\n                    }\n                }\n\n            }\n            Console.WriteLine(\"    All characters in the string are the same.\");\n        }\n\n        static void Main() {\n            var strs = new string[] { \"\", \"   \", \"2\", \"333\", \".55\", \"tttTTT\", \"4444 444k\" };\n            foreach (var str in strs) {\n                Analyze(str);\n            }\n        }\n    }\n}\n"}
{"id": 98363, "name": "Determine if a string has all the same characters", "source": "Translate Fortran to C#: program demo_verify\nimplicit none\n    call homogeneous('')\n    call homogeneous('2')\n    call homogeneous('333')\n    call homogeneous('.55')\n    call homogeneous('tttTTT')\n    call homogeneous('4444  444k')\ncontains\n\nsubroutine homogeneous(str)\ncharacter(len=*),intent(in)  :: str\ncharacter(len=:),allocatable :: ch\ncharacter(len=*),parameter   :: g='(*(g0))'\ninteger :: where\n   if(len(str)>0)then;ch=str(1:1);else;ch='';endif\n   where=verify(str,ch)\n   if(where.eq.0)then\n     write(*,g)'STR: \"',str,'\" LEN: ',len(str),'. All chars are a ','\"'//ch//'\"'\n   else\n     write(*,g)'STR: \"',str,'\" LEN: ',len(str), &\n     & '. Multiple chars found. First difference at position ',where, &\n     & ' where a ','\"'//str(where:where)//'\"(hex:',hex(str(where:where)),') was found.'\n     write(*,g)repeat(' ',where+5),'^'\n   endif\nend subroutine homogeneous\n\nfunction hex(ch) result(hexstr)\ncharacter(len=1),intent(in) :: ch\ncharacter(len=:),allocatable :: hexstr\n   hexstr=repeat(' ',100)\n   write(hexstr,'(Z0)')ch\n   hexstr=trim(hexstr)\nend function hex \n\nend program demo_verify\n", "target": "using System;\n\nnamespace AllSame {\n    class Program {\n        static void Analyze(string s) {\n            Console.WriteLine(\"Examining [{0}] which has a length of {1}:\", s, s.Length);\n            if (s.Length > 1) {\n                var b = s[0];\n                for (int i = 1; i < s.Length; i++) {\n                    var c = s[i];\n                    if (c != b) {\n                        Console.WriteLine(\"    Not all characters in the string are the same.\");\n                        Console.WriteLine(\"    '{0}' (0x{1:X02}) is different at position {2}\", c, (int)c, i);\n                        return;\n                    }\n                }\n\n            }\n            Console.WriteLine(\"    All characters in the string are the same.\");\n        }\n\n        static void Main() {\n            var strs = new string[] { \"\", \"   \", \"2\", \"333\", \".55\", \"tttTTT\", \"4444 444k\" };\n            foreach (var str in strs) {\n                Analyze(str);\n            }\n        }\n    }\n}\n"}
{"id": 98369, "name": "Determine if a string has all the same characters", "source": "Translate Fortran to Java: program demo_verify\nimplicit none\n    call homogeneous('')\n    call homogeneous('2')\n    call homogeneous('333')\n    call homogeneous('.55')\n    call homogeneous('tttTTT')\n    call homogeneous('4444  444k')\ncontains\n\nsubroutine homogeneous(str)\ncharacter(len=*),intent(in)  :: str\ncharacter(len=:),allocatable :: ch\ncharacter(len=*),parameter   :: g='(*(g0))'\ninteger :: where\n   if(len(str)>0)then;ch=str(1:1);else;ch='';endif\n   where=verify(str,ch)\n   if(where.eq.0)then\n     write(*,g)'STR: \"',str,'\" LEN: ',len(str),'. All chars are a ','\"'//ch//'\"'\n   else\n     write(*,g)'STR: \"',str,'\" LEN: ',len(str), &\n     & '. Multiple chars found. First difference at position ',where, &\n     & ' where a ','\"'//str(where:where)//'\"(hex:',hex(str(where:where)),') was found.'\n     write(*,g)repeat(' ',where+5),'^'\n   endif\nend subroutine homogeneous\n\nfunction hex(ch) result(hexstr)\ncharacter(len=1),intent(in) :: ch\ncharacter(len=:),allocatable :: hexstr\n   hexstr=repeat(' ',100)\n   write(hexstr,'(Z0)')ch\n   hexstr=trim(hexstr)\nend function hex \n\nend program demo_verify\n", "target": "public class Main{\n\tpublic static void main(String[] args){\n\t\tString[] tests = {\"\", \"   \", \"2\", \"333\", \".55\", \"tttTTT\", \"4444 444k\"};\n\t\tfor(String s:tests)\n\t\t\tanalyze(s);\n\t}\n\n\tpublic static void analyze(String s){\n\t\tSystem.out.printf(\"Examining [%s] which has a length of %d:\\n\", s, s.length());\n\t\tif(s.length() > 1){\n\t\t\tchar firstChar = s.charAt(0);\n\t\t\tint lastIndex = s.lastIndexOf(firstChar);\n\t\t\tif(lastIndex != 0){\n\t\t\t\tSystem.out.println(\"\\tNot all characters in the string are the same.\");\n\t\t\t\tSystem.out.printf(\"\\t'%c' (0x%x) is different at position %d\\n\", firstChar, (int) firstChar, lastIndex);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(\"\\tAll characters in the string are the same.\");\n\t}\n}\n"}
{"id": 98370, "name": "Determine if a string has all the same characters", "source": "Translate Fortran to Java: program demo_verify\nimplicit none\n    call homogeneous('')\n    call homogeneous('2')\n    call homogeneous('333')\n    call homogeneous('.55')\n    call homogeneous('tttTTT')\n    call homogeneous('4444  444k')\ncontains\n\nsubroutine homogeneous(str)\ncharacter(len=*),intent(in)  :: str\ncharacter(len=:),allocatable :: ch\ncharacter(len=*),parameter   :: g='(*(g0))'\ninteger :: where\n   if(len(str)>0)then;ch=str(1:1);else;ch='';endif\n   where=verify(str,ch)\n   if(where.eq.0)then\n     write(*,g)'STR: \"',str,'\" LEN: ',len(str),'. All chars are a ','\"'//ch//'\"'\n   else\n     write(*,g)'STR: \"',str,'\" LEN: ',len(str), &\n     & '. Multiple chars found. First difference at position ',where, &\n     & ' where a ','\"'//str(where:where)//'\"(hex:',hex(str(where:where)),') was found.'\n     write(*,g)repeat(' ',where+5),'^'\n   endif\nend subroutine homogeneous\n\nfunction hex(ch) result(hexstr)\ncharacter(len=1),intent(in) :: ch\ncharacter(len=:),allocatable :: hexstr\n   hexstr=repeat(' ',100)\n   write(hexstr,'(Z0)')ch\n   hexstr=trim(hexstr)\nend function hex \n\nend program demo_verify\n", "target": "public class Main{\n\tpublic static void main(String[] args){\n\t\tString[] tests = {\"\", \"   \", \"2\", \"333\", \".55\", \"tttTTT\", \"4444 444k\"};\n\t\tfor(String s:tests)\n\t\t\tanalyze(s);\n\t}\n\n\tpublic static void analyze(String s){\n\t\tSystem.out.printf(\"Examining [%s] which has a length of %d:\\n\", s, s.length());\n\t\tif(s.length() > 1){\n\t\t\tchar firstChar = s.charAt(0);\n\t\t\tint lastIndex = s.lastIndexOf(firstChar);\n\t\t\tif(lastIndex != 0){\n\t\t\t\tSystem.out.println(\"\\tNot all characters in the string are the same.\");\n\t\t\t\tSystem.out.printf(\"\\t'%c' (0x%x) is different at position %d\\n\", firstChar, (int) firstChar, lastIndex);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(\"\\tAll characters in the string are the same.\");\n\t}\n}\n"}
{"id": 98371, "name": "Determine if a string has all the same characters", "source": "Translate Fortran to Python: program demo_verify\nimplicit none\n    call homogeneous('')\n    call homogeneous('2')\n    call homogeneous('333')\n    call homogeneous('.55')\n    call homogeneous('tttTTT')\n    call homogeneous('4444  444k')\ncontains\n\nsubroutine homogeneous(str)\ncharacter(len=*),intent(in)  :: str\ncharacter(len=:),allocatable :: ch\ncharacter(len=*),parameter   :: g='(*(g0))'\ninteger :: where\n   if(len(str)>0)then;ch=str(1:1);else;ch='';endif\n   where=verify(str,ch)\n   if(where.eq.0)then\n     write(*,g)'STR: \"',str,'\" LEN: ',len(str),'. All chars are a ','\"'//ch//'\"'\n   else\n     write(*,g)'STR: \"',str,'\" LEN: ',len(str), &\n     & '. Multiple chars found. First difference at position ',where, &\n     & ' where a ','\"'//str(where:where)//'\"(hex:',hex(str(where:where)),') was found.'\n     write(*,g)repeat(' ',where+5),'^'\n   endif\nend subroutine homogeneous\n\nfunction hex(ch) result(hexstr)\ncharacter(len=1),intent(in) :: ch\ncharacter(len=:),allocatable :: hexstr\n   hexstr=repeat(' ',100)\n   write(hexstr,'(Z0)')ch\n   hexstr=trim(hexstr)\nend function hex \n\nend program demo_verify\n", "target": "\n\nfrom itertools import groupby\n\n\n\ndef firstDifferingCharLR(s):\n    \n    def details(xs):\n        c = xs[1][0]\n        return {\n            'char': repr(c),\n            'hex': hex(ord(c)),\n            'index': s.index(c),\n            'total': len(s)\n        }\n    xs = list(groupby(s))\n    return Right(details(xs)) if 1 < len(xs) else (\n        Left('Total length ' + str(len(s)) + ' - No character changes.')\n    )\n\n\n\n\ndef main():\n    \n\n    print(fTable('First, if any, points of difference:\\n')(repr)(\n        either(identity)(\n            lambda dct: dct['char'] + ' (' + dct['hex'] +\n            ') at character ' + str(1 + dct['index']) +\n            ' of ' + str(dct['total']) + '.'\n        )\n    )(firstDifferingCharLR)([\n        '',\n        '   ',\n        '2',\n        '333',\n        '.55',\n        'tttTTT',\n        '4444 444'\n    ]))\n\n\n\n\n\ndef either(fl):\n    \n    return lambda fr: lambda e: fl(e['Left']) if (\n        None is e['Right']\n    ) else fr(e['Right'])\n\n\n\ndef identity(x):\n    \n    return x\n\n\n\n\ndef fTable(s):\n    \n    def go(xShow, fxShow, f, xs):\n        ys = [xShow(x) for x in xs]\n        w = max(map(len, ys))\n        return s + '\\n' + '\\n'.join(map(\n            lambda x, y: y.rjust(w, ' ') + ' -> ' + fxShow(f(x)),\n            xs, ys\n        ))\n    return lambda xShow: lambda fxShow: lambda f: lambda xs: go(\n        xShow, fxShow, f, xs\n    )\n\n\n\ndef Left(x):\n    \n    return {'type': 'Either', 'Right': None, 'Left': x}\n\n\n\ndef Right(x):\n    \n    return {'type': 'Either', 'Left': None, 'Right': x}\n\n\n\nif __name__ == '__main__':\n    main()\n"}
{"id": 98372, "name": "Determine if a string has all the same characters", "source": "Translate Fortran to Python: program demo_verify\nimplicit none\n    call homogeneous('')\n    call homogeneous('2')\n    call homogeneous('333')\n    call homogeneous('.55')\n    call homogeneous('tttTTT')\n    call homogeneous('4444  444k')\ncontains\n\nsubroutine homogeneous(str)\ncharacter(len=*),intent(in)  :: str\ncharacter(len=:),allocatable :: ch\ncharacter(len=*),parameter   :: g='(*(g0))'\ninteger :: where\n   if(len(str)>0)then;ch=str(1:1);else;ch='';endif\n   where=verify(str,ch)\n   if(where.eq.0)then\n     write(*,g)'STR: \"',str,'\" LEN: ',len(str),'. All chars are a ','\"'//ch//'\"'\n   else\n     write(*,g)'STR: \"',str,'\" LEN: ',len(str), &\n     & '. Multiple chars found. First difference at position ',where, &\n     & ' where a ','\"'//str(where:where)//'\"(hex:',hex(str(where:where)),') was found.'\n     write(*,g)repeat(' ',where+5),'^'\n   endif\nend subroutine homogeneous\n\nfunction hex(ch) result(hexstr)\ncharacter(len=1),intent(in) :: ch\ncharacter(len=:),allocatable :: hexstr\n   hexstr=repeat(' ',100)\n   write(hexstr,'(Z0)')ch\n   hexstr=trim(hexstr)\nend function hex \n\nend program demo_verify\n", "target": "\n\nfrom itertools import groupby\n\n\n\ndef firstDifferingCharLR(s):\n    \n    def details(xs):\n        c = xs[1][0]\n        return {\n            'char': repr(c),\n            'hex': hex(ord(c)),\n            'index': s.index(c),\n            'total': len(s)\n        }\n    xs = list(groupby(s))\n    return Right(details(xs)) if 1 < len(xs) else (\n        Left('Total length ' + str(len(s)) + ' - No character changes.')\n    )\n\n\n\n\ndef main():\n    \n\n    print(fTable('First, if any, points of difference:\\n')(repr)(\n        either(identity)(\n            lambda dct: dct['char'] + ' (' + dct['hex'] +\n            ') at character ' + str(1 + dct['index']) +\n            ' of ' + str(dct['total']) + '.'\n        )\n    )(firstDifferingCharLR)([\n        '',\n        '   ',\n        '2',\n        '333',\n        '.55',\n        'tttTTT',\n        '4444 444'\n    ]))\n\n\n\n\n\ndef either(fl):\n    \n    return lambda fr: lambda e: fl(e['Left']) if (\n        None is e['Right']\n    ) else fr(e['Right'])\n\n\n\ndef identity(x):\n    \n    return x\n\n\n\n\ndef fTable(s):\n    \n    def go(xShow, fxShow, f, xs):\n        ys = [xShow(x) for x in xs]\n        w = max(map(len, ys))\n        return s + '\\n' + '\\n'.join(map(\n            lambda x, y: y.rjust(w, ' ') + ' -> ' + fxShow(f(x)),\n            xs, ys\n        ))\n    return lambda xShow: lambda fxShow: lambda f: lambda xs: go(\n        xShow, fxShow, f, xs\n    )\n\n\n\ndef Left(x):\n    \n    return {'type': 'Either', 'Right': None, 'Left': x}\n\n\n\ndef Right(x):\n    \n    return {'type': 'Either', 'Left': None, 'Right': x}\n\n\n\nif __name__ == '__main__':\n    main()\n"}
{"id": 98735, "name": "Catamorphism", "source": "Translate Fortran to C#:       SUBROUTINE FOLD(t,F,i,ist,lst)\n       INTEGER t\n       BYNAME F\n        DO i = ist,lst\n          t = F\n        END DO\n      END SUBROUTINE FOLD      \n\n      temp = a(1); CALL FOLD(temp,temp*a(i),i,2,N)\n", "target": "var nums = Enumerable.Range(1, 10);\n\nint summation = nums.Aggregate((a, b) => a + b);\n\nint product = nums.Aggregate((a, b) => a * b);\n\nstring concatenation = nums.Aggregate(String.Empty, (a, b) => a.ToString() + b.ToString());\n\nConsole.WriteLine(\"{0} {1} {2}\", summation, product, concatenation);\n"}
{"id": 98736, "name": "Catamorphism", "source": "Translate Fortran to C#:       SUBROUTINE FOLD(t,F,i,ist,lst)\n       INTEGER t\n       BYNAME F\n        DO i = ist,lst\n          t = F\n        END DO\n      END SUBROUTINE FOLD      \n\n      temp = a(1); CALL FOLD(temp,temp*a(i),i,2,N)\n", "target": "var nums = Enumerable.Range(1, 10);\n\nint summation = nums.Aggregate((a, b) => a + b);\n\nint product = nums.Aggregate((a, b) => a * b);\n\nstring concatenation = nums.Aggregate(String.Empty, (a, b) => a.ToString() + b.ToString());\n\nConsole.WriteLine(\"{0} {1} {2}\", summation, product, concatenation);\n"}
{"id": 98742, "name": "Catamorphism", "source": "Translate Fortran to Java:       SUBROUTINE FOLD(t,F,i,ist,lst)\n       INTEGER t\n       BYNAME F\n        DO i = ist,lst\n          t = F\n        END DO\n      END SUBROUTINE FOLD      \n\n      temp = a(1); CALL FOLD(temp,temp*a(i),i,2,N)\n", "target": "import java.util.stream.Stream;\n\npublic class ReduceTask {\n\n    public static void main(String[] args) {\n        System.out.println(Stream.of(1, 2, 3, 4, 5).mapToInt(i -> i).sum());\n        System.out.println(Stream.of(1, 2, 3, 4, 5).reduce(1, (a, b) -> a * b));\n    }\n}\n"}
{"id": 98743, "name": "Catamorphism", "source": "Translate Fortran to Java:       SUBROUTINE FOLD(t,F,i,ist,lst)\n       INTEGER t\n       BYNAME F\n        DO i = ist,lst\n          t = F\n        END DO\n      END SUBROUTINE FOLD      \n\n      temp = a(1); CALL FOLD(temp,temp*a(i),i,2,N)\n", "target": "import java.util.stream.Stream;\n\npublic class ReduceTask {\n\n    public static void main(String[] args) {\n        System.out.println(Stream.of(1, 2, 3, 4, 5).mapToInt(i -> i).sum());\n        System.out.println(Stream.of(1, 2, 3, 4, 5).reduce(1, (a, b) -> a * b));\n    }\n}\n"}
{"id": 98744, "name": "Catamorphism", "source": "Translate Fortran to Python:       SUBROUTINE FOLD(t,F,i,ist,lst)\n       INTEGER t\n       BYNAME F\n        DO i = ist,lst\n          t = F\n        END DO\n      END SUBROUTINE FOLD      \n\n      temp = a(1); CALL FOLD(temp,temp*a(i),i,2,N)\n", "target": ">>> \n>>> from operator import add\n>>> listoflists = [['the', 'cat'], ['sat', 'on'], ['the', 'mat']]\n>>> help(reduce)\nHelp on built-in function reduce in module __builtin__:\n\nreduce(...)\n    reduce(function, sequence[, initial]) -> value\n    \n    Apply a function of two arguments cumulatively to the items of a sequence,\n    from left to right, so as to reduce the sequence to a single value.\n    For example, reduce(lambda x, y: x+y, [1, 2, 3, 4, 5]) calculates\n    ((((1+2)+3)+4)+5).  If initial is present, it is placed before the items\n    of the sequence in the calculation, and serves as a default when the\n    sequence is empty.\n\n>>> reduce(add, listoflists, [])\n['the', 'cat', 'sat', 'on', 'the', 'mat']\n>>>\n"}
{"id": 98745, "name": "Catamorphism", "source": "Translate Fortran to Python:       SUBROUTINE FOLD(t,F,i,ist,lst)\n       INTEGER t\n       BYNAME F\n        DO i = ist,lst\n          t = F\n        END DO\n      END SUBROUTINE FOLD      \n\n      temp = a(1); CALL FOLD(temp,temp*a(i),i,2,N)\n", "target": ">>> \n>>> from operator import add\n>>> listoflists = [['the', 'cat'], ['sat', 'on'], ['the', 'mat']]\n>>> help(reduce)\nHelp on built-in function reduce in module __builtin__:\n\nreduce(...)\n    reduce(function, sequence[, initial]) -> value\n    \n    Apply a function of two arguments cumulatively to the items of a sequence,\n    from left to right, so as to reduce the sequence to a single value.\n    For example, reduce(lambda x, y: x+y, [1, 2, 3, 4, 5]) calculates\n    ((((1+2)+3)+4)+5).  If initial is present, it is placed before the items\n    of the sequence in the calculation, and serves as a default when the\n    sequence is empty.\n\n>>> reduce(add, listoflists, [])\n['the', 'cat', 'sat', 'on', 'the', 'mat']\n>>>\n"}
{"id": 99110, "name": "Sleep", "source": "Translate Fortran to C#: program test_sleep\n\n  implicit none\n  integer :: iostat\n  integer :: seconds\n  character (32) :: argument\n\n  if (iargc () == 1) then\n    call getarg (1, argument)\n    read (argument, *, iostat = iostat) seconds\n    if (iostat == 0) then\n      write (*, '(a)') 'Sleeping...'\n      call sleep (seconds)\n      write (*, '(a)') 'Awake\n    end if\n  end if\n\nend program test_sleep\n", "target": "using System;\nusing System.Threading;\n\nclass Program\n{\n    static void Main(string[] args)\n    {\n        int sleep = Convert.ToInt32(Console.ReadLine());\n        Console.WriteLine(\"Sleeping...\");\n        Thread.Sleep(sleep); \n        Console.WriteLine(\"Awake!\");\n    }\n}\n"}
{"id": 99113, "name": "Sleep", "source": "Translate Fortran to Java: program test_sleep\n\n  implicit none\n  integer :: iostat\n  integer :: seconds\n  character (32) :: argument\n\n  if (iargc () == 1) then\n    call getarg (1, argument)\n    read (argument, *, iostat = iostat) seconds\n    if (iostat == 0) then\n      write (*, '(a)') 'Sleeping...'\n      call sleep (seconds)\n      write (*, '(a)') 'Awake\n    end if\n  end if\n\nend program test_sleep\n", "target": "import java.util.InputMismatchException;\nimport java.util.Scanner;\n\npublic class Sleep {\n    public static void main(final String[] args) throws InterruptedException {\n        try {\n            int ms = new Scanner(System.in).nextInt(); \n            System.out.println(\"Sleeping...\");\n            Thread.sleep(ms);\n            System.out.println(\"Awake!\");\n        } catch (InputMismatchException inputMismatchException) {\n            System.err.println(\"Exception: \" + inputMismatchException);\n        }\n    }\n}\n"}
{"id": 99114, "name": "Sleep", "source": "Translate Fortran to Python: program test_sleep\n\n  implicit none\n  integer :: iostat\n  integer :: seconds\n  character (32) :: argument\n\n  if (iargc () == 1) then\n    call getarg (1, argument)\n    read (argument, *, iostat = iostat) seconds\n    if (iostat == 0) then\n      write (*, '(a)') 'Sleeping...'\n      call sleep (seconds)\n      write (*, '(a)') 'Awake\n    end if\n  end if\n\nend program test_sleep\n", "target": "import time\n\nseconds = float(raw_input())\nprint \"Sleeping...\"\ntime.sleep(seconds) \nprint \"Awake!\"\n"}
{"id": 99349, "name": "Polymorphism", "source": "Translate Fortran to C#: module geom\n\n  type point\n     real(8), private  :: x = 0\n     real(8), private  :: y = 0\n   contains\n     procedure, public :: get_x\n     procedure, public :: get_y\n     procedure, public :: set_x\n     procedure, public :: set_y\n     procedure, public :: print => print_point\n     procedure, pass :: copy_point\n     \n     generic, public :: assignment(=) => copy_point\n  end type point\n\n  type, extends(point) :: circle\n     real(8), private  :: r = 0\n   contains\n     procedure, public :: get_r\n     procedure, public :: set_r\n     procedure, public :: print => print_circle\n     procedure, pass :: copy_circle\n     \n     generic, public :: assignment(=) => copy_circle\n  end type circle\n\n  \n  interface circle\n  module procedure circle_constructor\n  end interface circle\n  \n  interface point\n  module procedure point_constructor\n  end interface point\n\ncontains\n\n  real(8) function get_x(this)\n    class(point), intent(in) :: this\n    get_x = this%x\n  end function get_x\n\n  real(8) function get_y(this)\n    class(point), intent(in) :: this\n    get_y = this%y\n  end function get_y\n\n  subroutine set_x(this, val)\n    class(point), intent(inout) :: this\n    real(8), intent(in)         :: val\n    this%x = val\n  end subroutine set_x\n\n  subroutine set_y(this, val)\n    class(point), intent(inout) :: this\n    real(8), intent(in)         :: val\n    this%y = val\n  end subroutine set_y\n\n  subroutine print_point(this)\n    class(point), intent(in) :: this\n    write(*,'(2(a,f0.4),a)') 'Point(',this%x,', ',this%y,')'\n  end subroutine print_point\n\n  real(8) function get_r(this)\n    class(circle), intent(in) :: this\n    get_r = this%r\n  end function get_r\n\n  subroutine set_r(this, val)\n    class(circle), intent(inout) :: this\n    real(8), intent(in)          :: val\n    this%r = val\n  end subroutine set_r\n\n  subroutine print_circle(this)\n    class(circle), intent(in) :: this\n    write(*,'(3(a,f0.4),a)') 'Circle(',this%x,', ',this%y,'; ',this%r,')'\n  end subroutine print_circle\n\n  subroutine copy_point(this, rhs)\n      class(point), intent(inout) :: this\n      type(point), intent(in) :: rhs\n      this%x = rhs%x\n      this%y = rhs%y\n  end subroutine copy_point\n\n  subroutine copy_circle(this, rhs)\n      class(circle), intent(inout) :: this\n      type(circle), intent(in) :: rhs\n      this%x = rhs%x\n      this%y = rhs%y\n      this%r = rhs%r\n  end subroutine copy_circle\n\n\n  type(point) function point_constructor(x,y)\n  real(8), intent(in) :: x,y\n  point_constructor%x = x\n  point_constructor%y = y\n  end function point_constructor\n\n  type(circle) function circle_constructor(x,y,r)\n  real(8), intent(in) :: x,y,r\n  circle_constructor%x = x\n  circle_constructor%y = y\n  circle_constructor%r = r\n  end function circle_constructor\n\nend module geom\n\nprogram inh\n  use geom\n\n  type(point)  :: p, p_copy\n  type(circle) :: c, c_copy\n\n  p = point(2.0d0, 3.0d0)\n  call p%print\n  p_copy = p\n  call p_copy%print\n\n  c = circle(3.0d0, 4.0d0, 5.0d0)\n  call c%print\n  c_copy = c\n  call c_copy%print\n\nend program inh\n", "target": "using System;\nclass Point\n{\n  protected int x, y;\n  public Point() : this(0) {}\n  public Point(int x) : this(x,0) {}\n  public Point(int x, int y) { this.x = x; this.y = y; }\n  public int X { get { return x; } set { x = value; } }\n  public int Y { get { return y; } set { y = value; } }\n  public virtual void print() { System.Console.WriteLine(\"Point\"); }\n}\n\npublic class Circle : Point\n{\n  private int r;\n  public Circle(Point p) : this(p,0) { }\n  public Circle(Point p, int r) : base(p) { this.r = r; }\n  public Circle() : this(0) { }\n  public Circle(int x) : this(x,0) { }\n  public Circle(int x, int y) : this(x,y,0) { }\n  public Circle(int x, int y, int r) : base(x,y) { this.r = r; }\n  public int R { get { return r; } set { r = value; } }\n  public override void print() { System.Console.WriteLine(\"Circle\"); }\n \n  public static void main(String args[])\n  {\n    Point p = new Point();\n    Point c = new Circle();\n    p.print();\n    c.print();\n  }\n}\n"}
{"id": 99351, "name": "Polymorphism", "source": "Translate Fortran to Java: module geom\n\n  type point\n     real(8), private  :: x = 0\n     real(8), private  :: y = 0\n   contains\n     procedure, public :: get_x\n     procedure, public :: get_y\n     procedure, public :: set_x\n     procedure, public :: set_y\n     procedure, public :: print => print_point\n     procedure, pass :: copy_point\n     \n     generic, public :: assignment(=) => copy_point\n  end type point\n\n  type, extends(point) :: circle\n     real(8), private  :: r = 0\n   contains\n     procedure, public :: get_r\n     procedure, public :: set_r\n     procedure, public :: print => print_circle\n     procedure, pass :: copy_circle\n     \n     generic, public :: assignment(=) => copy_circle\n  end type circle\n\n  \n  interface circle\n  module procedure circle_constructor\n  end interface circle\n  \n  interface point\n  module procedure point_constructor\n  end interface point\n\ncontains\n\n  real(8) function get_x(this)\n    class(point), intent(in) :: this\n    get_x = this%x\n  end function get_x\n\n  real(8) function get_y(this)\n    class(point), intent(in) :: this\n    get_y = this%y\n  end function get_y\n\n  subroutine set_x(this, val)\n    class(point), intent(inout) :: this\n    real(8), intent(in)         :: val\n    this%x = val\n  end subroutine set_x\n\n  subroutine set_y(this, val)\n    class(point), intent(inout) :: this\n    real(8), intent(in)         :: val\n    this%y = val\n  end subroutine set_y\n\n  subroutine print_point(this)\n    class(point), intent(in) :: this\n    write(*,'(2(a,f0.4),a)') 'Point(',this%x,', ',this%y,')'\n  end subroutine print_point\n\n  real(8) function get_r(this)\n    class(circle), intent(in) :: this\n    get_r = this%r\n  end function get_r\n\n  subroutine set_r(this, val)\n    class(circle), intent(inout) :: this\n    real(8), intent(in)          :: val\n    this%r = val\n  end subroutine set_r\n\n  subroutine print_circle(this)\n    class(circle), intent(in) :: this\n    write(*,'(3(a,f0.4),a)') 'Circle(',this%x,', ',this%y,'; ',this%r,')'\n  end subroutine print_circle\n\n  subroutine copy_point(this, rhs)\n      class(point), intent(inout) :: this\n      type(point), intent(in) :: rhs\n      this%x = rhs%x\n      this%y = rhs%y\n  end subroutine copy_point\n\n  subroutine copy_circle(this, rhs)\n      class(circle), intent(inout) :: this\n      type(circle), intent(in) :: rhs\n      this%x = rhs%x\n      this%y = rhs%y\n      this%r = rhs%r\n  end subroutine copy_circle\n\n\n  type(point) function point_constructor(x,y)\n  real(8), intent(in) :: x,y\n  point_constructor%x = x\n  point_constructor%y = y\n  end function point_constructor\n\n  type(circle) function circle_constructor(x,y,r)\n  real(8), intent(in) :: x,y,r\n  circle_constructor%x = x\n  circle_constructor%y = y\n  circle_constructor%r = r\n  end function circle_constructor\n\nend module geom\n\nprogram inh\n  use geom\n\n  type(point)  :: p, p_copy\n  type(circle) :: c, c_copy\n\n  p = point(2.0d0, 3.0d0)\n  call p%print\n  p_copy = p\n  call p_copy%print\n\n  c = circle(3.0d0, 4.0d0, 5.0d0)\n  call c%print\n  c_copy = c\n  call c_copy%print\n\nend program inh\n", "target": "class Point {\n   protected int x, y;\n   public Point() { this(0); }\n   public Point(int x) { this(x, 0); }\n   public Point(int x, int y) { this.x = x; this.y = y; }\n   public Point(Point p) { this(p.x, p.y); }\n   public int getX() { return this.x; }\n   public int getY() { return this.y; }\n   public void setX(int x) { this.x = x; }\n   public void setY(int y) { this.y = y; }\n   public void print() { System.out.println(\"Point x: \" + this.x + \" y: \" + this.y); }\n}\n\nclass Circle extends Point {\n   private int r;\n   public Circle(Point p) { this(p, 0); }\n   public Circle(Point p, int r) { super(p); this.r = r; }\n   public Circle() { this(0); }\n   public Circle(int x) { this(x, 0); }\n   public Circle(int x, int y) { this(x, y, 0); }\n   public Circle(int x, int y, int r) { super(x, y); this.r = r; }\n   public Circle(Circle c) { this(c.x, c.y, c.r); }\n   public int getR() { return this.r; }\n   public void setR(int r) { this.r = r; }\n   public void print() { System.out.println(\"Circle x: \" + this.x + \" y: \" + this.y + \" r: \" + this.r); }\n}\n\npublic class test {\n  public static void main(String args[]) {\n    Point p = new Point();\n    Point c = new Circle();\n    p.print();\n    c.print();     \n  }\n}\n"}
{"id": 99352, "name": "Polymorphism", "source": "Translate Fortran to Python: module geom\n\n  type point\n     real(8), private  :: x = 0\n     real(8), private  :: y = 0\n   contains\n     procedure, public :: get_x\n     procedure, public :: get_y\n     procedure, public :: set_x\n     procedure, public :: set_y\n     procedure, public :: print => print_point\n     procedure, pass :: copy_point\n     \n     generic, public :: assignment(=) => copy_point\n  end type point\n\n  type, extends(point) :: circle\n     real(8), private  :: r = 0\n   contains\n     procedure, public :: get_r\n     procedure, public :: set_r\n     procedure, public :: print => print_circle\n     procedure, pass :: copy_circle\n     \n     generic, public :: assignment(=) => copy_circle\n  end type circle\n\n  \n  interface circle\n  module procedure circle_constructor\n  end interface circle\n  \n  interface point\n  module procedure point_constructor\n  end interface point\n\ncontains\n\n  real(8) function get_x(this)\n    class(point), intent(in) :: this\n    get_x = this%x\n  end function get_x\n\n  real(8) function get_y(this)\n    class(point), intent(in) :: this\n    get_y = this%y\n  end function get_y\n\n  subroutine set_x(this, val)\n    class(point), intent(inout) :: this\n    real(8), intent(in)         :: val\n    this%x = val\n  end subroutine set_x\n\n  subroutine set_y(this, val)\n    class(point), intent(inout) :: this\n    real(8), intent(in)         :: val\n    this%y = val\n  end subroutine set_y\n\n  subroutine print_point(this)\n    class(point), intent(in) :: this\n    write(*,'(2(a,f0.4),a)') 'Point(',this%x,', ',this%y,')'\n  end subroutine print_point\n\n  real(8) function get_r(this)\n    class(circle), intent(in) :: this\n    get_r = this%r\n  end function get_r\n\n  subroutine set_r(this, val)\n    class(circle), intent(inout) :: this\n    real(8), intent(in)          :: val\n    this%r = val\n  end subroutine set_r\n\n  subroutine print_circle(this)\n    class(circle), intent(in) :: this\n    write(*,'(3(a,f0.4),a)') 'Circle(',this%x,', ',this%y,'; ',this%r,')'\n  end subroutine print_circle\n\n  subroutine copy_point(this, rhs)\n      class(point), intent(inout) :: this\n      type(point), intent(in) :: rhs\n      this%x = rhs%x\n      this%y = rhs%y\n  end subroutine copy_point\n\n  subroutine copy_circle(this, rhs)\n      class(circle), intent(inout) :: this\n      type(circle), intent(in) :: rhs\n      this%x = rhs%x\n      this%y = rhs%y\n      this%r = rhs%r\n  end subroutine copy_circle\n\n\n  type(point) function point_constructor(x,y)\n  real(8), intent(in) :: x,y\n  point_constructor%x = x\n  point_constructor%y = y\n  end function point_constructor\n\n  type(circle) function circle_constructor(x,y,r)\n  real(8), intent(in) :: x,y,r\n  circle_constructor%x = x\n  circle_constructor%y = y\n  circle_constructor%r = r\n  end function circle_constructor\n\nend module geom\n\nprogram inh\n  use geom\n\n  type(point)  :: p, p_copy\n  type(circle) :: c, c_copy\n\n  p = point(2.0d0, 3.0d0)\n  call p%print\n  p_copy = p\n  call p_copy%print\n\n  c = circle(3.0d0, 4.0d0, 5.0d0)\n  call c%print\n  c_copy = c\n  call c_copy%print\n\nend program inh\n", "target": "class Point(object):\n    def __init__(self, x=0.0, y=0.0):\n        self.x = x\n        self.y = y\n    def __repr__(self):\n        return '<Point 0x%x x: %f y: %f>' % (id(self), self.x, self.y)\n\nclass Circle(object):\n    def __init__(self, center=None, radius=1.0):\n        self.center = center or Point()\n        self.radius = radius\n    def __repr__(self):\n        return '<Circle 0x%x x: %f y: %f radius: %f>' % (\n            id(self), self.center.x, self.center.y, self.radius)\n"}
{"id": 99761, "name": "Generate lower case ASCII alphabet", "source": "Translate Fortran to Java:   character(26) :: alpha\n  integer :: i\n\n  do i = 1, 26\n    alpha(i:i) = achar(iachar('a') + i - 1)\n  end do\n", "target": "public class LowerAscii {\n\n    public static void main(String[] args) {\n        StringBuilder sb = new StringBuilder(26);\n        for (char ch = 'a'; ch <= 'z'; ch++)\n            sb.append(ch);\n        System.out.printf(\"lower ascii: %s, length: %s\", sb, sb.length());\n    }\n}\n"}
{"id": 99762, "name": "Generate lower case ASCII alphabet", "source": "Translate Fortran to Python:   character(26) :: alpha\n  integer :: i\n\n  do i = 1, 26\n    alpha(i:i) = achar(iachar('a') + i - 1)\n  end do\n", "target": "\nfrom string import ascii_lowercase\n\n\nlower = [chr(i) for i in range(ord('a'), ord('z') + 1)]\n"}
{"id": 99968, "name": "Constrained genericity", "source": "Translate Fortran to C#: module cg\n    implicit none\n    \n    type, abstract :: eatable\n    end type eatable\n    \n    type, extends(eatable) :: carrot_t\n    end type carrot_t\n    \n    type :: brick_t; end type brick_t\n    \n    type :: foodbox\n\tclass(eatable), allocatable :: food\n    contains\n        procedure, public :: add_item => add_item_fb\n    end type foodbox\n    \ncontains\n\n    subroutine add_item_fb(this, f)\n        class(foodbox), intent(inout) :: this\n        class(eatable), intent(in)    :: f\n        allocate(this%food, source=f)\n    end subroutine add_item_fb\nend module cg\n\n\nprogram con_gen\n    use cg\n    implicit none\n    \n    type(carrot_t) :: carrot\n    type(brick_t)  :: brick\n    type(foodbox)  :: fbox\n    \n    \n    call fbox%add_item(carrot)\n    \n    \n    call fbox%add_item(brick)\n    \nend program con_gen\n", "target": "interface IEatable\n{\n    void Eat();\n}\n"}
{"id": 99970, "name": "Constrained genericity", "source": "Translate Fortran to Java: module cg\n    implicit none\n    \n    type, abstract :: eatable\n    end type eatable\n    \n    type, extends(eatable) :: carrot_t\n    end type carrot_t\n    \n    type :: brick_t; end type brick_t\n    \n    type :: foodbox\n\tclass(eatable), allocatable :: food\n    contains\n        procedure, public :: add_item => add_item_fb\n    end type foodbox\n    \ncontains\n\n    subroutine add_item_fb(this, f)\n        class(foodbox), intent(inout) :: this\n        class(eatable), intent(in)    :: f\n        allocate(this%food, source=f)\n    end subroutine add_item_fb\nend module cg\n\n\nprogram con_gen\n    use cg\n    implicit none\n    \n    type(carrot_t) :: carrot\n    type(brick_t)  :: brick\n    type(foodbox)  :: fbox\n    \n    \n    call fbox%add_item(carrot)\n    \n    \n    call fbox%add_item(brick)\n    \nend program con_gen\n", "target": "interface Eatable\n{\n    void eat();\n}\n"}
{"id": 100172, "name": "Compare a list of strings", "source": "Translate Fortran to C#:       INTEGER MANY,LONG\n      PARAMETER (LONG = 6,MANY = 4)\t\n      CHARACTER*(LONG) STRINGS(MANY)\t\n      STRINGS(1) = \"Fee\"\n      STRINGS(2) = \"Fie\"\n      STRINGS(3) = \"Foe\"\n      STRINGS(4) = \"Fum\"\n      IF (ALL(STRINGS(1:MANY - 1) .LT. STRINGS(2:MANY))) THEN\n        WRITE (6,*) MANY,\" strings: strictly increasing in order.\"\n       ELSE\n        WRITE (6,*) MANY,\" strings: not strictly increasing in order.\"\n      END IF\n      IF (ALL(STRINGS(1:MANY - 1) .EQ. STRINGS(2:MANY))) THEN\n        WRITE (6,*) MANY,\" strings: all equal.\"\n       ELSE\n        WRITE (6,*) MANY,\" strings: not all equal.\"\n      END IF\n      END\n", "target": "public static (bool lexicallyEqual, bool strictlyAscending) CompareAListOfStrings(List<string> strings) =>\n    strings.Count < 2 ? (true, true) :\n    (\n        strings.Distinct().Count() < 2,\n        Enumerable.Range(1, strings.Count - 1).All(i => string.Compare(strings[i-1], strings[i]) < 0)\n    );\n"}
{"id": 100173, "name": "Compare a list of strings", "source": "Translate Fortran to C#:       INTEGER MANY,LONG\n      PARAMETER (LONG = 6,MANY = 4)\t\n      CHARACTER*(LONG) STRINGS(MANY)\t\n      STRINGS(1) = \"Fee\"\n      STRINGS(2) = \"Fie\"\n      STRINGS(3) = \"Foe\"\n      STRINGS(4) = \"Fum\"\n      IF (ALL(STRINGS(1:MANY - 1) .LT. STRINGS(2:MANY))) THEN\n        WRITE (6,*) MANY,\" strings: strictly increasing in order.\"\n       ELSE\n        WRITE (6,*) MANY,\" strings: not strictly increasing in order.\"\n      END IF\n      IF (ALL(STRINGS(1:MANY - 1) .EQ. STRINGS(2:MANY))) THEN\n        WRITE (6,*) MANY,\" strings: all equal.\"\n       ELSE\n        WRITE (6,*) MANY,\" strings: not all equal.\"\n      END IF\n      END\n", "target": "public static (bool lexicallyEqual, bool strictlyAscending) CompareAListOfStrings(List<string> strings) =>\n    strings.Count < 2 ? (true, true) :\n    (\n        strings.Distinct().Count() < 2,\n        Enumerable.Range(1, strings.Count - 1).All(i => string.Compare(strings[i-1], strings[i]) < 0)\n    );\n"}
{"id": 100179, "name": "Compare a list of strings", "source": "Translate Fortran to Java:       INTEGER MANY,LONG\n      PARAMETER (LONG = 6,MANY = 4)\t\n      CHARACTER*(LONG) STRINGS(MANY)\t\n      STRINGS(1) = \"Fee\"\n      STRINGS(2) = \"Fie\"\n      STRINGS(3) = \"Foe\"\n      STRINGS(4) = \"Fum\"\n      IF (ALL(STRINGS(1:MANY - 1) .LT. STRINGS(2:MANY))) THEN\n        WRITE (6,*) MANY,\" strings: strictly increasing in order.\"\n       ELSE\n        WRITE (6,*) MANY,\" strings: not strictly increasing in order.\"\n      END IF\n      IF (ALL(STRINGS(1:MANY - 1) .EQ. STRINGS(2:MANY))) THEN\n        WRITE (6,*) MANY,\" strings: all equal.\"\n       ELSE\n        WRITE (6,*) MANY,\" strings: not all equal.\"\n      END IF\n      END\n", "target": "import java.util.Arrays;\n\npublic class CompareListOfStrings {\n\n    public static void main(String[] args) {\n        String[][] arr = {{\"AA\", \"AA\", \"AA\", \"AA\"}, {\"AA\", \"ACB\", \"BB\", \"CC\"}};\n        for (String[] a : arr) {\n            System.out.println(Arrays.toString(a));\n            System.out.println(Arrays.stream(a).distinct().count() < 2);\n            System.out.println(Arrays.equals(Arrays.stream(a).distinct().sorted().toArray(), a));\n        }\n    }\n}\n"}
{"id": 100180, "name": "Compare a list of strings", "source": "Translate Fortran to Java:       INTEGER MANY,LONG\n      PARAMETER (LONG = 6,MANY = 4)\t\n      CHARACTER*(LONG) STRINGS(MANY)\t\n      STRINGS(1) = \"Fee\"\n      STRINGS(2) = \"Fie\"\n      STRINGS(3) = \"Foe\"\n      STRINGS(4) = \"Fum\"\n      IF (ALL(STRINGS(1:MANY - 1) .LT. STRINGS(2:MANY))) THEN\n        WRITE (6,*) MANY,\" strings: strictly increasing in order.\"\n       ELSE\n        WRITE (6,*) MANY,\" strings: not strictly increasing in order.\"\n      END IF\n      IF (ALL(STRINGS(1:MANY - 1) .EQ. STRINGS(2:MANY))) THEN\n        WRITE (6,*) MANY,\" strings: all equal.\"\n       ELSE\n        WRITE (6,*) MANY,\" strings: not all equal.\"\n      END IF\n      END\n", "target": "import java.util.Arrays;\n\npublic class CompareListOfStrings {\n\n    public static void main(String[] args) {\n        String[][] arr = {{\"AA\", \"AA\", \"AA\", \"AA\"}, {\"AA\", \"ACB\", \"BB\", \"CC\"}};\n        for (String[] a : arr) {\n            System.out.println(Arrays.toString(a));\n            System.out.println(Arrays.stream(a).distinct().count() < 2);\n            System.out.println(Arrays.equals(Arrays.stream(a).distinct().sorted().toArray(), a));\n        }\n    }\n}\n"}
{"id": 100181, "name": "Compare a list of strings", "source": "Translate Fortran to Python:       INTEGER MANY,LONG\n      PARAMETER (LONG = 6,MANY = 4)\t\n      CHARACTER*(LONG) STRINGS(MANY)\t\n      STRINGS(1) = \"Fee\"\n      STRINGS(2) = \"Fie\"\n      STRINGS(3) = \"Foe\"\n      STRINGS(4) = \"Fum\"\n      IF (ALL(STRINGS(1:MANY - 1) .LT. STRINGS(2:MANY))) THEN\n        WRITE (6,*) MANY,\" strings: strictly increasing in order.\"\n       ELSE\n        WRITE (6,*) MANY,\" strings: not strictly increasing in order.\"\n      END IF\n      IF (ALL(STRINGS(1:MANY - 1) .EQ. STRINGS(2:MANY))) THEN\n        WRITE (6,*) MANY,\" strings: all equal.\"\n       ELSE\n        WRITE (6,*) MANY,\" strings: not all equal.\"\n      END IF\n      END\n", "target": "all(a == nexta for a, nexta in zip(strings, strings[1:])) \nall(a < nexta for a, nexta in zip(strings, strings[1:])) \n\nlen(set(strings)) == 1  \nsorted(strings, reverse=True) == strings  \n"}
{"id": 100182, "name": "Compare a list of strings", "source": "Translate Fortran to Python:       INTEGER MANY,LONG\n      PARAMETER (LONG = 6,MANY = 4)\t\n      CHARACTER*(LONG) STRINGS(MANY)\t\n      STRINGS(1) = \"Fee\"\n      STRINGS(2) = \"Fie\"\n      STRINGS(3) = \"Foe\"\n      STRINGS(4) = \"Fum\"\n      IF (ALL(STRINGS(1:MANY - 1) .LT. STRINGS(2:MANY))) THEN\n        WRITE (6,*) MANY,\" strings: strictly increasing in order.\"\n       ELSE\n        WRITE (6,*) MANY,\" strings: not strictly increasing in order.\"\n      END IF\n      IF (ALL(STRINGS(1:MANY - 1) .EQ. STRINGS(2:MANY))) THEN\n        WRITE (6,*) MANY,\" strings: all equal.\"\n       ELSE\n        WRITE (6,*) MANY,\" strings: not all equal.\"\n      END IF\n      END\n", "target": "all(a == nexta for a, nexta in zip(strings, strings[1:])) \nall(a < nexta for a, nexta in zip(strings, strings[1:])) \n\nlen(set(strings)) == 1  \nsorted(strings, reverse=True) == strings  \n"}
{"id": 100618, "name": "Roman numerals_Decode", "source": "Translate Fortran to C#: program Roman_decode\n  implicit none\n \n  write(*,*) decode(\"MCMXC\"), decode(\"MMVIII\"), decode(\"MDCLXVI\")\n\ncontains\n\nfunction decode(roman) result(arabic)\n  character(*), intent(in) :: roman\n  integer :: i, n, lastval, arabic\n\n  arabic = 0\n  lastval = 0\n  do i = len(roman), 1, -1\n    select case(roman(i:i))\n      case ('M','m')\n        n = 1000\n      case ('D','d')\n        n = 500\n      case ('C','c')\n        n = 100\n      case ('L','l')\n        n = 50\n      case ('X','x')\n        n = 10\n      case ('V','v')\n        n = 5\n      case ('I','i')\n        n = 1\n      case default\n        n = 0\n    end select\n    if (n < lastval) then\n      arabic = arabic - n\n    else\n      arabic = arabic + n\n    end if\n    lastval = n\n  end do\nend function decode\nend program Roman_decode\n", "target": "using System;\nusing System.Collections.Generic;\n\nnamespace Roman\n{\n    internal class Program\n    {\n        private static void Main(string[] args)\n        {\n            \n            Console.WriteLine(\"{0}: {1}\", \"MCMXC\", Decode(\"MCMXC\"));\n            Console.WriteLine(\"{0}: {1}\", \"MMVIII\", Decode(\"MMVIII\"));\n            Console.WriteLine(\"{0}: {1}\", \"MDCLXVI\", Decode(\"MDCLXVI\"));\n        }\n\n        \n        private static readonly Dictionary<char, int> RomanDictionary = new Dictionary<char, int>\n                                                                            {\n                                                                                {'I', 1},\n                                                                                {'V', 5},\n                                                                                {'X', 10},\n                                                                                {'L', 50},\n                                                                                {'C', 100},\n                                                                                {'D', 500},\n                                                                                {'M', 1000}\n                                                                            };\n\n        private static int Decode(string roman)\n        {\n            \n            roman = roman.ToUpper();\n\n            \n            int total = 0, minus = 0;\n\n            for (int i = 0; i < roman.Length; i++) \n            {\n                \n                int thisNumeral = RomanDictionary[roman[i]] - minus;\n\n                \n                if (i >= roman.Length - 1 ||\n                    thisNumeral + minus >= RomanDictionary[roman[i + 1]])\n                {\n                    total += thisNumeral;\n                    minus = 0;\n                }\n                else\n                {\n                    minus = thisNumeral;\n                }\n            }\n\n            return total; \n        }\n    }\n}\n"}
{"id": 100619, "name": "Roman numerals_Decode", "source": "Translate Fortran to C#: program Roman_decode\n  implicit none\n \n  write(*,*) decode(\"MCMXC\"), decode(\"MMVIII\"), decode(\"MDCLXVI\")\n\ncontains\n\nfunction decode(roman) result(arabic)\n  character(*), intent(in) :: roman\n  integer :: i, n, lastval, arabic\n\n  arabic = 0\n  lastval = 0\n  do i = len(roman), 1, -1\n    select case(roman(i:i))\n      case ('M','m')\n        n = 1000\n      case ('D','d')\n        n = 500\n      case ('C','c')\n        n = 100\n      case ('L','l')\n        n = 50\n      case ('X','x')\n        n = 10\n      case ('V','v')\n        n = 5\n      case ('I','i')\n        n = 1\n      case default\n        n = 0\n    end select\n    if (n < lastval) then\n      arabic = arabic - n\n    else\n      arabic = arabic + n\n    end if\n    lastval = n\n  end do\nend function decode\nend program Roman_decode\n", "target": "using System;\nusing System.Collections.Generic;\n\nnamespace Roman\n{\n    internal class Program\n    {\n        private static void Main(string[] args)\n        {\n            \n            Console.WriteLine(\"{0}: {1}\", \"MCMXC\", Decode(\"MCMXC\"));\n            Console.WriteLine(\"{0}: {1}\", \"MMVIII\", Decode(\"MMVIII\"));\n            Console.WriteLine(\"{0}: {1}\", \"MDCLXVI\", Decode(\"MDCLXVI\"));\n        }\n\n        \n        private static readonly Dictionary<char, int> RomanDictionary = new Dictionary<char, int>\n                                                                            {\n                                                                                {'I', 1},\n                                                                                {'V', 5},\n                                                                                {'X', 10},\n                                                                                {'L', 50},\n                                                                                {'C', 100},\n                                                                                {'D', 500},\n                                                                                {'M', 1000}\n                                                                            };\n\n        private static int Decode(string roman)\n        {\n            \n            roman = roman.ToUpper();\n\n            \n            int total = 0, minus = 0;\n\n            for (int i = 0; i < roman.Length; i++) \n            {\n                \n                int thisNumeral = RomanDictionary[roman[i]] - minus;\n\n                \n                if (i >= roman.Length - 1 ||\n                    thisNumeral + minus >= RomanDictionary[roman[i + 1]])\n                {\n                    total += thisNumeral;\n                    minus = 0;\n                }\n                else\n                {\n                    minus = thisNumeral;\n                }\n            }\n\n            return total; \n        }\n    }\n}\n"}
{"id": 100625, "name": "Roman numerals_Decode", "source": "Translate Fortran to Java: program Roman_decode\n  implicit none\n \n  write(*,*) decode(\"MCMXC\"), decode(\"MMVIII\"), decode(\"MDCLXVI\")\n\ncontains\n\nfunction decode(roman) result(arabic)\n  character(*), intent(in) :: roman\n  integer :: i, n, lastval, arabic\n\n  arabic = 0\n  lastval = 0\n  do i = len(roman), 1, -1\n    select case(roman(i:i))\n      case ('M','m')\n        n = 1000\n      case ('D','d')\n        n = 500\n      case ('C','c')\n        n = 100\n      case ('L','l')\n        n = 50\n      case ('X','x')\n        n = 10\n      case ('V','v')\n        n = 5\n      case ('I','i')\n        n = 1\n      case default\n        n = 0\n    end select\n    if (n < lastval) then\n      arabic = arabic - n\n    else\n      arabic = arabic + n\n    end if\n    lastval = n\n  end do\nend function decode\nend program Roman_decode\n", "target": "\ngrammar ParseRN ;\n\noptions {\n\tlanguage = Java;\n}\n@members {\nint rnValue;\nint ONE;\n}\n\nparseRN:\t({rnValue = 0;} rn NEWLINE {System.out.println($rn.text + \" = \" + rnValue);})*\n\t;\n\t\nrn\t:\t(Thousand {rnValue += 1000;})* hundreds? tens? units?;\n\nhundreds:\t{ONE = 0;} (h9 | h5) {if (ONE > 3) System.out.println (\"Too many hundreds\");};\nh9\t:\tHundred {ONE += 1;} (FiveHund {rnValue += 400;}| Thousand {rnValue += 900;}|{rnValue += 100;} (Hundred {rnValue += 100; ONE += 1;})*);\nh5\t:\tFiveHund {rnValue += 500;} (Hundred {rnValue += 100; ONE += 1;})*;\n\ntens\t:\t{ONE = 0;} (t9 | t5) {if (ONE > 3) System.out.println (\"Too many tens\");};\nt9\t:\tTen {ONE += 1;} (Fifty {rnValue += 40;}| Hundred {rnValue += 90;}|{rnValue += 10;} (Ten {rnValue += 10; ONE += 1;})*);\nt5\t:\tFifty {rnValue += 50;} (Ten {rnValue += 10; ONE += 1;})*;\n\t\nunits\t:\t{ONE = 0;} (u9 | u5) {if (ONE > 3) System.out.println (\"Too many ones\");};\nu9\t:\tOne {ONE += 1;} (Five {rnValue += 4;}| Ten {rnValue += 9;}|{rnValue += 1;} (One {rnValue += 1; ONE += 1;})*);\nu5\t:\tFive {rnValue += 5;} (One {rnValue += 1; ONE += 1;})*;\n\t\nOne\t:\t'I';\nFive\t:\t'V';\nTen\t:\t'X';\nFifty\t:\t'L';\nHundred:\t'C';\nFiveHund:\t'D';\nThousand:\t'M' ;\nNEWLINE:\t'\\r'? '\\n' ;\n"}
{"id": 100626, "name": "Roman numerals_Decode", "source": "Translate Fortran to Java: program Roman_decode\n  implicit none\n \n  write(*,*) decode(\"MCMXC\"), decode(\"MMVIII\"), decode(\"MDCLXVI\")\n\ncontains\n\nfunction decode(roman) result(arabic)\n  character(*), intent(in) :: roman\n  integer :: i, n, lastval, arabic\n\n  arabic = 0\n  lastval = 0\n  do i = len(roman), 1, -1\n    select case(roman(i:i))\n      case ('M','m')\n        n = 1000\n      case ('D','d')\n        n = 500\n      case ('C','c')\n        n = 100\n      case ('L','l')\n        n = 50\n      case ('X','x')\n        n = 10\n      case ('V','v')\n        n = 5\n      case ('I','i')\n        n = 1\n      case default\n        n = 0\n    end select\n    if (n < lastval) then\n      arabic = arabic - n\n    else\n      arabic = arabic + n\n    end if\n    lastval = n\n  end do\nend function decode\nend program Roman_decode\n", "target": "\ngrammar ParseRN ;\n\noptions {\n\tlanguage = Java;\n}\n@members {\nint rnValue;\nint ONE;\n}\n\nparseRN:\t({rnValue = 0;} rn NEWLINE {System.out.println($rn.text + \" = \" + rnValue);})*\n\t;\n\t\nrn\t:\t(Thousand {rnValue += 1000;})* hundreds? tens? units?;\n\nhundreds:\t{ONE = 0;} (h9 | h5) {if (ONE > 3) System.out.println (\"Too many hundreds\");};\nh9\t:\tHundred {ONE += 1;} (FiveHund {rnValue += 400;}| Thousand {rnValue += 900;}|{rnValue += 100;} (Hundred {rnValue += 100; ONE += 1;})*);\nh5\t:\tFiveHund {rnValue += 500;} (Hundred {rnValue += 100; ONE += 1;})*;\n\ntens\t:\t{ONE = 0;} (t9 | t5) {if (ONE > 3) System.out.println (\"Too many tens\");};\nt9\t:\tTen {ONE += 1;} (Fifty {rnValue += 40;}| Hundred {rnValue += 90;}|{rnValue += 10;} (Ten {rnValue += 10; ONE += 1;})*);\nt5\t:\tFifty {rnValue += 50;} (Ten {rnValue += 10; ONE += 1;})*;\n\t\nunits\t:\t{ONE = 0;} (u9 | u5) {if (ONE > 3) System.out.println (\"Too many ones\");};\nu9\t:\tOne {ONE += 1;} (Five {rnValue += 4;}| Ten {rnValue += 9;}|{rnValue += 1;} (One {rnValue += 1; ONE += 1;})*);\nu5\t:\tFive {rnValue += 5;} (One {rnValue += 1; ONE += 1;})*;\n\t\nOne\t:\t'I';\nFive\t:\t'V';\nTen\t:\t'X';\nFifty\t:\t'L';\nHundred:\t'C';\nFiveHund:\t'D';\nThousand:\t'M' ;\nNEWLINE:\t'\\r'? '\\n' ;\n"}
{"id": 100627, "name": "Roman numerals_Decode", "source": "Translate Fortran to Python: program Roman_decode\n  implicit none\n \n  write(*,*) decode(\"MCMXC\"), decode(\"MMVIII\"), decode(\"MDCLXVI\")\n\ncontains\n\nfunction decode(roman) result(arabic)\n  character(*), intent(in) :: roman\n  integer :: i, n, lastval, arabic\n\n  arabic = 0\n  lastval = 0\n  do i = len(roman), 1, -1\n    select case(roman(i:i))\n      case ('M','m')\n        n = 1000\n      case ('D','d')\n        n = 500\n      case ('C','c')\n        n = 100\n      case ('L','l')\n        n = 50\n      case ('X','x')\n        n = 10\n      case ('V','v')\n        n = 5\n      case ('I','i')\n        n = 1\n      case default\n        n = 0\n    end select\n    if (n < lastval) then\n      arabic = arabic - n\n    else\n      arabic = arabic + n\n    end if\n    lastval = n\n  end do\nend function decode\nend program Roman_decode\n", "target": "_rdecode = dict(zip('MDCLXVI', (1000, 500, 100, 50, 10, 5, 1)))\n\ndef decode( roman ):\n    result = 0\n    for r, r1 in zip(roman, roman[1:]):\n        rd, rd1 = _rdecode[r], _rdecode[r1]\n        result += -rd if rd < rd1 else rd\n    return result + _rdecode[roman[-1]]\n\nif __name__ == '__main__':\n    for r in 'MCMXC MMVIII MDCLXVI'.split():\n        print( r, decode(r) )\n"}
{"id": 100628, "name": "Roman numerals_Decode", "source": "Translate Fortran to Python: program Roman_decode\n  implicit none\n \n  write(*,*) decode(\"MCMXC\"), decode(\"MMVIII\"), decode(\"MDCLXVI\")\n\ncontains\n\nfunction decode(roman) result(arabic)\n  character(*), intent(in) :: roman\n  integer :: i, n, lastval, arabic\n\n  arabic = 0\n  lastval = 0\n  do i = len(roman), 1, -1\n    select case(roman(i:i))\n      case ('M','m')\n        n = 1000\n      case ('D','d')\n        n = 500\n      case ('C','c')\n        n = 100\n      case ('L','l')\n        n = 50\n      case ('X','x')\n        n = 10\n      case ('V','v')\n        n = 5\n      case ('I','i')\n        n = 1\n      case default\n        n = 0\n    end select\n    if (n < lastval) then\n      arabic = arabic - n\n    else\n      arabic = arabic + n\n    end if\n    lastval = n\n  end do\nend function decode\nend program Roman_decode\n", "target": "_rdecode = dict(zip('MDCLXVI', (1000, 500, 100, 50, 10, 5, 1)))\n\ndef decode( roman ):\n    result = 0\n    for r, r1 in zip(roman, roman[1:]):\n        rd, rd1 = _rdecode[r], _rdecode[r1]\n        result += -rd if rd < rd1 else rd\n    return result + _rdecode[roman[-1]]\n\nif __name__ == '__main__':\n    for r in 'MCMXC MMVIII MDCLXVI'.split():\n        print( r, decode(r) )\n"}
{"id": 101059, "name": "Euler method", "source": "Translate Fortran to C#: program euler_method\nuse iso_fortran_env, only: real64\nimplicit none\n\nabstract interface\n  \n  function derivative(y, t)\n    use iso_fortran_env, only: real64\n    real(real64) :: derivative\n    real(real64), intent(in) :: t, y\n  end function\nend interface\n\nreal(real64), parameter :: T_0 = 100, T_room = 20, k = 0.07, a = 0, b = 100, &\n    h(3) = [2.0, 5.0, 10.0]\n\ninteger :: i\n\n\ndo i = 1, 3\n  call euler(newton_cooling, T_0, a, b, h(i))\nend do\n\ncontains\n\n\n\nsubroutine euler(f, y0, a, b, h)\n  procedure(derivative) :: f\n  real(real64), intent(in) :: y0, a, b, h\n  real(real64) :: t, y\n\n  if (a > b) return\n  if (h <= 0) stop \"negative step size\"\n  \n  print '(\"# h = \", F0.3)', h\n\n  y = y0\n  t = a\n\n  do\n    print *, t, y\n    t = t + h\n    if (t > b) return\n    y = y + h * f(y, t)\n  end do\nend subroutine\n\n\n\nfunction newton_cooling(T, unused) result(dTdt)\n  real(real64) :: dTdt\n  real(real64), intent(in) :: T, unused\n  dTdt = -k * (T - T_room)\nend function\n\nend program\n", "target": "using System;\n\nnamespace prog\n{\n\tclass MainClass\n\t{\n\t\tconst float T0 = 100f;\n\t\tconst float TR = 20f;\n\t\tconst float k = 0.07f;\n\t\treadonly static float[] delta_t = {2.0f,5.0f,10.0f};\n\t\tconst int n = 100;\n\t\t\n\t\tpublic delegate float func(float t);\n\t\tstatic float NewtonCooling(float t)\n\t\t{\n\t\t\treturn -k * (t-TR);\t\t\t\n\t\t}\n\t\t\n\t\tpublic static void Main (string[] args)\n\t\t{\n\t\t\tfunc f = new func(NewtonCooling); \n\t\t\tfor(int i=0; i<delta_t.Length; i++)\n\t\t\t{\n\t\t\t\tConsole.WriteLine(\"delta_t = \" + delta_t[i]);\n\t\t\t\tEuler(f,T0,n,delta_t[i]);\n\t\t\t}\n\t\t}\n\t\t\t\t\n\t\tpublic static void Euler(func f, float y, int n, float h)\n\t\t{\n\t\t\tfor(float x=0; x<=n; x+=h)\n\t\t\t{\n\t\t\t\tConsole.WriteLine(\"\\t\" + x + \"\\t\" + y);\n\t\t\t\ty += h * f(y);\t\n\t\t\t}\n\t\t}\n\t}\n}\n"}
{"id": 101062, "name": "Euler method", "source": "Translate Fortran to Java: program euler_method\nuse iso_fortran_env, only: real64\nimplicit none\n\nabstract interface\n  \n  function derivative(y, t)\n    use iso_fortran_env, only: real64\n    real(real64) :: derivative\n    real(real64), intent(in) :: t, y\n  end function\nend interface\n\nreal(real64), parameter :: T_0 = 100, T_room = 20, k = 0.07, a = 0, b = 100, &\n    h(3) = [2.0, 5.0, 10.0]\n\ninteger :: i\n\n\ndo i = 1, 3\n  call euler(newton_cooling, T_0, a, b, h(i))\nend do\n\ncontains\n\n\n\nsubroutine euler(f, y0, a, b, h)\n  procedure(derivative) :: f\n  real(real64), intent(in) :: y0, a, b, h\n  real(real64) :: t, y\n\n  if (a > b) return\n  if (h <= 0) stop \"negative step size\"\n  \n  print '(\"# h = \", F0.3)', h\n\n  y = y0\n  t = a\n\n  do\n    print *, t, y\n    t = t + h\n    if (t > b) return\n    y = y + h * f(y, t)\n  end do\nend subroutine\n\n\n\nfunction newton_cooling(T, unused) result(dTdt)\n  real(real64) :: dTdt\n  real(real64), intent(in) :: T, unused\n  dTdt = -k * (T - T_room)\nend function\n\nend program\n", "target": "public class Euler {\n  private static void euler (Callable f, double y0, int a, int b, int h) {\n    int t = a;\n    double y = y0;\n    while (t < b) {\n      System.out.println (\"\" + t + \" \" + y);\n      t += h;\n      y += h * f.compute (t, y);\n    }\n    System.out.println (\"DONE\");\n  }\n\n  public static void main (String[] args) {\n    Callable cooling = new Cooling ();\n    int[] steps = {2, 5, 10};\n    for (int stepSize : steps) {\n      System.out.println (\"Step size: \" + stepSize);\n      euler (cooling, 100.0, 0, 100, stepSize);\n    }\n  }\n}\n\n\ninterface Callable {\n  public double compute (int time, double t);\n}\n\n\nclass Cooling implements Callable {\n  public double compute (int time, double t) {\n    return -0.07 * (t - 20);\n  }\n}\n"}
{"id": 101063, "name": "Euler method", "source": "Translate Fortran to Python: program euler_method\nuse iso_fortran_env, only: real64\nimplicit none\n\nabstract interface\n  \n  function derivative(y, t)\n    use iso_fortran_env, only: real64\n    real(real64) :: derivative\n    real(real64), intent(in) :: t, y\n  end function\nend interface\n\nreal(real64), parameter :: T_0 = 100, T_room = 20, k = 0.07, a = 0, b = 100, &\n    h(3) = [2.0, 5.0, 10.0]\n\ninteger :: i\n\n\ndo i = 1, 3\n  call euler(newton_cooling, T_0, a, b, h(i))\nend do\n\ncontains\n\n\n\nsubroutine euler(f, y0, a, b, h)\n  procedure(derivative) :: f\n  real(real64), intent(in) :: y0, a, b, h\n  real(real64) :: t, y\n\n  if (a > b) return\n  if (h <= 0) stop \"negative step size\"\n  \n  print '(\"# h = \", F0.3)', h\n\n  y = y0\n  t = a\n\n  do\n    print *, t, y\n    t = t + h\n    if (t > b) return\n    y = y + h * f(y, t)\n  end do\nend subroutine\n\n\n\nfunction newton_cooling(T, unused) result(dTdt)\n  real(real64) :: dTdt\n  real(real64), intent(in) :: T, unused\n  dTdt = -k * (T - T_room)\nend function\n\nend program\n", "target": "def euler(f,y0,a,b,h):\n\tt,y = a,y0\n\twhile t <= b:\n\t\tprint \"%6.3f %6.3f\" % (t,y)\n\t\tt += h\n\t\ty += h * f(t,y)\n\ndef newtoncooling(time, temp):\n\treturn -0.07 * (temp - 20)\n\neuler(newtoncooling,100,0,100,10)\n"}
{"id": 101386, "name": "Horner's rule for polynomial evaluation", "source": "Translate Fortran to C#: program test_horner\n\n  implicit none\n\n  write (*, '(f5.1)') horner ([-19.0, 7.0, -4.0, 6.0], 3.0)\n\ncontains\n\n  function horner (coeffs, x) result (res)\n\n    implicit none\n    real, dimension (0:), intent (in) :: coeffs\n    real, intent (in) :: x\n    real :: res\n    integer :: i\n\n    res = coeffs(ubound(coeffs,1))\n    do i = ubound(coeffs,1)-1, 0, -1\n      res = res * x + coeffs (i)\n    end do\n\n  end function horner\n\nend program test_horner\n", "target": "using System;\nusing System.Linq;\n\nclass Program\n{\n    static double Horner(double[] coefficients, double variable)\n    {\n        return coefficients.Reverse().Aggregate(\n                (accumulator, coefficient) => accumulator * variable + coefficient);\n    }\n\n    static void Main()\n    {\n        Console.WriteLine(Horner(new[] { -19.0, 7.0, -4.0, 6.0 }, 3.0));\n    }\n}\n"}
{"id": 101387, "name": "Horner's rule for polynomial evaluation", "source": "Translate Fortran to C#: program test_horner\n\n  implicit none\n\n  write (*, '(f5.1)') horner ([-19.0, 7.0, -4.0, 6.0], 3.0)\n\ncontains\n\n  function horner (coeffs, x) result (res)\n\n    implicit none\n    real, dimension (0:), intent (in) :: coeffs\n    real, intent (in) :: x\n    real :: res\n    integer :: i\n\n    res = coeffs(ubound(coeffs,1))\n    do i = ubound(coeffs,1)-1, 0, -1\n      res = res * x + coeffs (i)\n    end do\n\n  end function horner\n\nend program test_horner\n", "target": "using System;\nusing System.Linq;\n\nclass Program\n{\n    static double Horner(double[] coefficients, double variable)\n    {\n        return coefficients.Reverse().Aggregate(\n                (accumulator, coefficient) => accumulator * variable + coefficient);\n    }\n\n    static void Main()\n    {\n        Console.WriteLine(Horner(new[] { -19.0, 7.0, -4.0, 6.0 }, 3.0));\n    }\n}\n"}
{"id": 101392, "name": "Horner's rule for polynomial evaluation", "source": "Translate Fortran to Java: program test_horner\n\n  implicit none\n\n  write (*, '(f5.1)') horner ([-19.0, 7.0, -4.0, 6.0], 3.0)\n\ncontains\n\n  function horner (coeffs, x) result (res)\n\n    implicit none\n    real, dimension (0:), intent (in) :: coeffs\n    real, intent (in) :: x\n    real :: res\n    integer :: i\n\n    res = coeffs(ubound(coeffs,1))\n    do i = ubound(coeffs,1)-1, 0, -1\n      res = res * x + coeffs (i)\n    end do\n\n  end function horner\n\nend program test_horner\n", "target": "import java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\n\npublic class Horner {\n    public static void main(String[] args){\n        List<Double> coeffs = new ArrayList<Double>();\n        coeffs.add(-19.0);\n        coeffs.add(7.0);\n        coeffs.add(-4.0);\n        coeffs.add(6.0);\n        System.out.println(polyEval(coeffs, 3));\n    }\n\n    public static double polyEval(List<Double> coefficients, double x) {\n        Collections.reverse(coefficients);\n        Double accumulator = coefficients.get(0);\n        for (int i = 1; i < coefficients.size(); i++) {\n            accumulator = (accumulator * x) + (Double) coefficients.get(i);\n        }\n        return accumulator;\n    }\n}\n"}
{"id": 101393, "name": "Horner's rule for polynomial evaluation", "source": "Translate Fortran to Java: program test_horner\n\n  implicit none\n\n  write (*, '(f5.1)') horner ([-19.0, 7.0, -4.0, 6.0], 3.0)\n\ncontains\n\n  function horner (coeffs, x) result (res)\n\n    implicit none\n    real, dimension (0:), intent (in) :: coeffs\n    real, intent (in) :: x\n    real :: res\n    integer :: i\n\n    res = coeffs(ubound(coeffs,1))\n    do i = ubound(coeffs,1)-1, 0, -1\n      res = res * x + coeffs (i)\n    end do\n\n  end function horner\n\nend program test_horner\n", "target": "import java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\n\npublic class Horner {\n    public static void main(String[] args){\n        List<Double> coeffs = new ArrayList<Double>();\n        coeffs.add(-19.0);\n        coeffs.add(7.0);\n        coeffs.add(-4.0);\n        coeffs.add(6.0);\n        System.out.println(polyEval(coeffs, 3));\n    }\n\n    public static double polyEval(List<Double> coefficients, double x) {\n        Collections.reverse(coefficients);\n        Double accumulator = coefficients.get(0);\n        for (int i = 1; i < coefficients.size(); i++) {\n            accumulator = (accumulator * x) + (Double) coefficients.get(i);\n        }\n        return accumulator;\n    }\n}\n"}
{"id": 101394, "name": "Horner's rule for polynomial evaluation", "source": "Translate Fortran to Python: program test_horner\n\n  implicit none\n\n  write (*, '(f5.1)') horner ([-19.0, 7.0, -4.0, 6.0], 3.0)\n\ncontains\n\n  function horner (coeffs, x) result (res)\n\n    implicit none\n    real, dimension (0:), intent (in) :: coeffs\n    real, intent (in) :: x\n    real :: res\n    integer :: i\n\n    res = coeffs(ubound(coeffs,1))\n    do i = ubound(coeffs,1)-1, 0, -1\n      res = res * x + coeffs (i)\n    end do\n\n  end function horner\n\nend program test_horner\n", "target": ">>> def horner(coeffs, x):\n\tacc = 0\n\tfor c in reversed(coeffs):\n\t\tacc = acc * x + c\n\treturn acc\n\n>>> horner( (-19, 7, -4, 6), 3)\n128\n"}
{"id": 101395, "name": "Horner's rule for polynomial evaluation", "source": "Translate Fortran to Python: program test_horner\n\n  implicit none\n\n  write (*, '(f5.1)') horner ([-19.0, 7.0, -4.0, 6.0], 3.0)\n\ncontains\n\n  function horner (coeffs, x) result (res)\n\n    implicit none\n    real, dimension (0:), intent (in) :: coeffs\n    real, intent (in) :: x\n    real :: res\n    integer :: i\n\n    res = coeffs(ubound(coeffs,1))\n    do i = ubound(coeffs,1)-1, 0, -1\n      res = res * x + coeffs (i)\n    end do\n\n  end function horner\n\nend program test_horner\n", "target": ">>> def horner(coeffs, x):\n\tacc = 0\n\tfor c in reversed(coeffs):\n\t\tacc = acc * x + c\n\treturn acc\n\n>>> horner( (-19, 7, -4, 6), 3)\n128\n"}
{"id": 101848, "name": "Matrix multiplication", "source": "Translate Fortran to C#: real, dimension(n,m) :: a = reshape( [ (i, i=1, n*m) ], [ n, m ] )\nreal, dimension(m,k) :: b = reshape( [ (i, i=1, m*k) ], [ m, k ] )\nreal, dimension(size(a,1), size(b,2)) :: c    \n                                              \n                                              \n                                              \n\nc = matmul( a, b )\n\nprint *, 'A'\ndo i = 1, n\n    print *, a(i,:)\nend do\n\nprint *,\nprint *, 'B'\ndo i = 1, m\n    print *, b(i,:)\nend do\n\nprint *,\nprint *, 'C = AB'\ndo i = 1, n\n    print *, c(i,:)\nend do\n", "target": "public class Matrix\n{\n\tint n;\n\tint m;\n\tdouble[,] a;\n\n\tpublic Matrix(int n, int m)\n\t{\n\t\tif (n <= 0 || m <= 0)\n\t\t\tthrow new ArgumentException(\"Matrix dimensions must be positive\");\n\t\tthis.n = n;\n\t\tthis.m = m;\n\t\ta = new double[n, m];\n\t}\n\n\t\n\tpublic double this[int i, int j]\n\t{\n\t\tget { return a[i - 1, j - 1]; }\n\t\tset { a[i - 1, j - 1] = value; }\n\t}\n\n\tpublic int N { get { return n; } }\n\tpublic int M { get { return m; } }\n\n\tpublic static Matrix operator*(Matrix _a, Matrix b)\n\t{\n\t\tint n = _a.N;\n\t\tint m = b.M;\n\t\tint l = _a.M;\n\t\tif (l != b.N)\n\t\t\tthrow new ArgumentException(\"Illegal matrix dimensions for multiplication. _a.M must be equal b.N\");\n\t\tMatrix result = new Matrix(_a.N, b.M);\n\t\tfor(int i = 0; i < n; i++)\n\t\t\tfor (int j = 0; j < m; j++)\n\t\t\t{\n\t\t\t\tdouble sum = 0.0;\n\t\t\t\tfor (int k = 0; k < l; k++)\n\t\t\t\t\tsum += _a.a[i, k]*b.a[k, j];\n\t\t\t\tresult.a[i, j] = sum;\n\t\t\t}\n\t\treturn result;\n\t}\n}\n"}
{"id": 101851, "name": "Matrix multiplication", "source": "Translate Fortran to Java: real, dimension(n,m) :: a = reshape( [ (i, i=1, n*m) ], [ n, m ] )\nreal, dimension(m,k) :: b = reshape( [ (i, i=1, m*k) ], [ m, k ] )\nreal, dimension(size(a,1), size(b,2)) :: c    \n                                              \n                                              \n                                              \n\nc = matmul( a, b )\n\nprint *, 'A'\ndo i = 1, n\n    print *, a(i,:)\nend do\n\nprint *,\nprint *, 'B'\ndo i = 1, m\n    print *, b(i,:)\nend do\n\nprint *,\nprint *, 'C = AB'\ndo i = 1, n\n    print *, c(i,:)\nend do\n", "target": "public static double[][] mult(double a[][], double b[][]){\n   if(a.length == 0) return new double[0][0];\n   if(a[0].length != b.length) return null; \n\n   int n = a[0].length;\n   int m = a.length;\n   int p = b[0].length;\n\n   double ans[][] = new double[m][p];\n\n   for(int i = 0;i < m;i++){\n      for(int j = 0;j < p;j++){\n         for(int k = 0;k < n;k++){\n            ans[i][j] += a[i][k] * b[k][j];\n         }\n      }\n   }\n   return ans;\n}\n"}
{"id": 101852, "name": "Matrix multiplication", "source": "Translate Fortran to Python: real, dimension(n,m) :: a = reshape( [ (i, i=1, n*m) ], [ n, m ] )\nreal, dimension(m,k) :: b = reshape( [ (i, i=1, m*k) ], [ m, k ] )\nreal, dimension(size(a,1), size(b,2)) :: c    \n                                              \n                                              \n                                              \n\nc = matmul( a, b )\n\nprint *, 'A'\ndo i = 1, n\n    print *, a(i,:)\nend do\n\nprint *,\nprint *, 'B'\ndo i = 1, m\n    print *, b(i,:)\nend do\n\nprint *,\nprint *, 'C = AB'\ndo i = 1, n\n    print *, c(i,:)\nend do\n", "target": "a=((1,  1,  1,   1), \n     (2,  4,  8,  16),\n     (3,  9, 27,  81),\n     (4, 16, 64, 256))\n\nb=((  4  , -3  ,  4/3.,  -1/4. ), \n     (-13/3., 19/4., -7/3.,  11/24.),\n     (  3/2., -2.  ,  7/6.,  -1/4. ),\n     ( -1/6.,  1/4., -1/6.,   1/24.))\n\n\n\ndef MatrixMul( mtx_a, mtx_b):\n    tpos_b = zip( *mtx_b)\n    rtn = [[ sum( ea*eb for ea,eb in zip(a,b)) for b in tpos_b] for a in mtx_a]\n    return rtn\n\n\nv = MatrixMul( a, b )\n\nprint 'v = ('\nfor r in v:\n    print '[', \n    for val in r:\n        print '%8.2f '%val, \n    print ']'\nprint ')'\n\n\nu = MatrixMul(b,a)\n\nprint 'u = '\nfor r in u:\n    print '[', \n    for val in r:\n        print '%8.2f '%val, \n    print ']'\nprint ')'\n"}
{"id": 102493, "name": "Input loop", "source": "Translate Fortran to C#: program BasicInputLoop\n\n  implicit none\n\n  integer, parameter        :: in = 50, &\n                               linelen = 1000\n  integer                   :: ecode\n  character(len=linelen)    :: l\n\n  open(in, file=\"afile.txt\", action=\"read\", status=\"old\", iostat=ecode)\n  if ( ecode == 0 ) then\n     do\n        read(in, fmt=\"(A)\", iostat=ecode) l\n        if ( ecode /= 0 ) exit\n        write(*,*) trim(l)\n     end do\n     close(in)\n  end if\n\nend program BasicInputLoop\n", "target": "using System;\nusing System.IO;\n\nclass Program\n{\n    static void Main(string[] args)\n    {\n        \n        \n\n        using (var b = new StreamReader(\"file.txt\"))\n        {\n            string line;\n            while ((line = b.ReadLine()) != null)\n                Console.WriteLine(line);\n        }\n    }\n}\n"}
{"id": 102496, "name": "Input loop", "source": "Translate Fortran to Java: program BasicInputLoop\n\n  implicit none\n\n  integer, parameter        :: in = 50, &\n                               linelen = 1000\n  integer                   :: ecode\n  character(len=linelen)    :: l\n\n  open(in, file=\"afile.txt\", action=\"read\", status=\"old\", iostat=ecode)\n  if ( ecode == 0 ) then\n     do\n        read(in, fmt=\"(A)\", iostat=ecode) l\n        if ( ecode /= 0 ) exit\n        write(*,*) trim(l)\n     end do\n     close(in)\n  end if\n\nend program BasicInputLoop\n", "target": "import java.io.InputStream;\nimport java.util.Scanner;\n\npublic class InputLoop {\n    public static void main(String args[]) {\n        \n        InputStream source = System.in;\n\n        \n\n        Scanner in = new Scanner(source);\n        while(in.hasNext()){\n            String input = in.next(); \n\n            \n            System.out.println(input);\n        }\n    }\n}\n"}
{"id": 102497, "name": "Input loop", "source": "Translate Fortran to Python: program BasicInputLoop\n\n  implicit none\n\n  integer, parameter        :: in = 50, &\n                               linelen = 1000\n  integer                   :: ecode\n  character(len=linelen)    :: l\n\n  open(in, file=\"afile.txt\", action=\"read\", status=\"old\", iostat=ecode)\n  if ( ecode == 0 ) then\n     do\n        read(in, fmt=\"(A)\", iostat=ecode) l\n        if ( ecode /= 0 ) exit\n        write(*,*) trim(l)\n     end do\n     close(in)\n  end if\n\nend program BasicInputLoop\n", "target": "while(True):\n      x = input(\"What is your age? \")\n      print(x)\n"}
{"id": 102755, "name": "Mandelbrot set", "source": "Translate Fortran to C#: program mandelbrot\n\n  implicit none\n  integer  , parameter :: rk       = selected_real_kind (9, 99)\n  integer  , parameter :: i_max    =  800\n  integer  , parameter :: j_max    =  600\n  integer  , parameter :: n_max    =  100\n  real (rk), parameter :: x_centre = -0.5_rk\n  real (rk), parameter :: y_centre =  0.0_rk\n  real (rk), parameter :: width    =  4.0_rk\n  real (rk), parameter :: height   =  3.0_rk\n  real (rk), parameter :: dx_di    =   width / i_max\n  real (rk), parameter :: dy_dj    = -height / j_max\n  real (rk), parameter :: x_offset = x_centre - 0.5_rk * (i_max + 1) * dx_di\n  real (rk), parameter :: y_offset = y_centre - 0.5_rk * (j_max + 1) * dy_dj\n  integer, dimension (i_max, j_max) :: image\n  integer   :: i\n  integer   :: j\n  integer   :: n\n  real (rk) :: x\n  real (rk) :: y\n  real (rk) :: x_0\n  real (rk) :: y_0\n  real (rk) :: x_sqr\n  real (rk) :: y_sqr\n\n  do j = 1, j_max\n    y_0 = y_offset + dy_dj * j\n    do i = 1, i_max\n      x_0 = x_offset + dx_di * i\n      x = 0.0_rk\n      y = 0.0_rk\n      n = 0\n      do\n        x_sqr = x ** 2\n        y_sqr = y ** 2\n        if (x_sqr + y_sqr > 4.0_rk) then\n          image (i, j) = 255\n          exit\n        end if\n        if (n == n_max) then\n          image (i, j) = 0\n          exit\n        end if\n        y = y_0 + 2.0_rk * x * y\n        x = x_0 + x_sqr - y_sqr\n        n = n + 1\n      end do\n    end do\n  end do\n  open  (10, file = 'out.pgm')\n  write (10, '(a/ i0, 1x, i0/ i0)') 'P2', i_max, j_max, 255\n  write (10, '(i0)') image\n  close (10)\n\nend program mandelbrot\n", "target": "using System;\nusing System.Drawing;\nusing System.Drawing.Imaging;\nusing System.Threading;\nusing System.Windows.Forms;\n\n\n\n\npublic class MandelbrotSetForm : Form\n{\n    const double MaxValueExtent = 2.0;\n    Thread thread;\n\n    static double CalcMandelbrotSetColor(ComplexNumber c)\n    {\n        \n        const int MaxIterations = 1000;\n        const double MaxNorm = MaxValueExtent * MaxValueExtent;\n\n        int iteration = 0;\n        ComplexNumber z = new ComplexNumber();\n        do\n        {\n            z = z * z + c;\n            iteration++;\n        } while (z.Norm() < MaxNorm && iteration < MaxIterations);\n        if (iteration < MaxIterations)\n            return (double)iteration / MaxIterations;\n        else\n            return 0; \n    }\n\n    static void GenerateBitmap(Bitmap bitmap)\n    {\n        double scale = 2 * MaxValueExtent / Math.Min(bitmap.Width, bitmap.Height);\n        for (int i = 0; i < bitmap.Height; i++)\n        {\n            double y = (bitmap.Height / 2 - i) * scale;\n            for (int j = 0; j < bitmap.Width; j++)\n            {\n                double x = (j - bitmap.Width / 2) * scale;\n                double color = CalcMandelbrotSetColor(new ComplexNumber(x, y));\n                bitmap.SetPixel(j, i, GetColor(color));\n            }\n        }\n    }\n\n    static Color GetColor(double value)\n    {\n        const double MaxColor = 256;\n        const double ContrastValue = 0.2;\n        return Color.FromArgb(0, 0,\n            (int)(MaxColor * Math.Pow(value, ContrastValue)));\n    }\n    \n    public MandelbrotSetForm()\n    {\n        \n        this.Text = \"Mandelbrot Set Drawing\";\n        this.BackColor = System.Drawing.Color.Black;\n        this.BackgroundImageLayout = System.Windows.Forms.ImageLayout.Stretch;\n        this.MaximizeBox = false;\n        this.StartPosition = FormStartPosition.CenterScreen;\n        this.FormBorderStyle = FormBorderStyle.FixedDialog;\n        this.ClientSize = new Size(640, 640);\n        this.Load += new System.EventHandler(this.MainForm_Load);\n    }\n\n    void MainForm_Load(object sender, EventArgs e)\n    {\n        thread = new Thread(thread_Proc);\n        thread.IsBackground = true;\n        thread.Start(this.ClientSize);\n    }\n\n    void thread_Proc(object args)\n    {\n        \n        Size size = (Size)args;\n        int width = 16;\n        while (width * 2 < size.Width)\n        {\n            int height = width * size.Height / size.Width;\n            Bitmap bitmap = new Bitmap(width, height, PixelFormat.Format24bppRgb);\n            GenerateBitmap(bitmap);\n            this.BeginInvoke(new SetNewBitmapDelegate(SetNewBitmap), bitmap);\n            width *= 2;\n            Thread.Sleep(200);\n        }\n        \n        Bitmap finalBitmap = new Bitmap(size.Width, size.Height, PixelFormat.Format24bppRgb);\n        GenerateBitmap(finalBitmap);\n        this.BeginInvoke(new SetNewBitmapDelegate(SetNewBitmap), finalBitmap);\n    }\n\n    void SetNewBitmap(Bitmap image)\n    {\n        if (this.BackgroundImage != null)\n            this.BackgroundImage.Dispose();\n        this.BackgroundImage = image;\n    }\n\n    delegate void SetNewBitmapDelegate(Bitmap image);\n\n    static void Main()\n    {\n        Application.Run(new MandelbrotSetForm());\n    }\n}\n\nstruct ComplexNumber\n{\n    public double Re;\n    public double Im;\n\n    public ComplexNumber(double re, double im)\n    {\n        this.Re = re;\n        this.Im = im;\n    }\n\n    public static ComplexNumber operator +(ComplexNumber x, ComplexNumber y)\n    {\n        return new ComplexNumber(x.Re + y.Re, x.Im + y.Im);\n    }\n\n    public static ComplexNumber operator *(ComplexNumber x, ComplexNumber y)\n    {\n        return new ComplexNumber(x.Re * y.Re - x.Im * y.Im,\n            x.Re * y.Im + x.Im * y.Re);\n    }\n\n    public double Norm()\n    {\n        return Re * Re + Im * Im;\n    }\n}\n"}
{"id": 102758, "name": "Mandelbrot set", "source": "Translate Fortran to Java: program mandelbrot\n\n  implicit none\n  integer  , parameter :: rk       = selected_real_kind (9, 99)\n  integer  , parameter :: i_max    =  800\n  integer  , parameter :: j_max    =  600\n  integer  , parameter :: n_max    =  100\n  real (rk), parameter :: x_centre = -0.5_rk\n  real (rk), parameter :: y_centre =  0.0_rk\n  real (rk), parameter :: width    =  4.0_rk\n  real (rk), parameter :: height   =  3.0_rk\n  real (rk), parameter :: dx_di    =   width / i_max\n  real (rk), parameter :: dy_dj    = -height / j_max\n  real (rk), parameter :: x_offset = x_centre - 0.5_rk * (i_max + 1) * dx_di\n  real (rk), parameter :: y_offset = y_centre - 0.5_rk * (j_max + 1) * dy_dj\n  integer, dimension (i_max, j_max) :: image\n  integer   :: i\n  integer   :: j\n  integer   :: n\n  real (rk) :: x\n  real (rk) :: y\n  real (rk) :: x_0\n  real (rk) :: y_0\n  real (rk) :: x_sqr\n  real (rk) :: y_sqr\n\n  do j = 1, j_max\n    y_0 = y_offset + dy_dj * j\n    do i = 1, i_max\n      x_0 = x_offset + dx_di * i\n      x = 0.0_rk\n      y = 0.0_rk\n      n = 0\n      do\n        x_sqr = x ** 2\n        y_sqr = y ** 2\n        if (x_sqr + y_sqr > 4.0_rk) then\n          image (i, j) = 255\n          exit\n        end if\n        if (n == n_max) then\n          image (i, j) = 0\n          exit\n        end if\n        y = y_0 + 2.0_rk * x * y\n        x = x_0 + x_sqr - y_sqr\n        n = n + 1\n      end do\n    end do\n  end do\n  open  (10, file = 'out.pgm')\n  write (10, '(a/ i0, 1x, i0/ i0)') 'P2', i_max, j_max, 255\n  write (10, '(i0)') image\n  close (10)\n\nend program mandelbrot\n", "target": "import java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport javax.swing.JFrame;\n\npublic class Mandelbrot extends JFrame {\n\n    private final int MAX_ITER = 570;\n    private final double ZOOM = 150;\n    private BufferedImage I;\n    private double zx, zy, cX, cY, tmp;\n\n    public Mandelbrot() {\n        super(\"Mandelbrot Set\");\n        setBounds(100, 100, 800, 600);\n        setResizable(false);\n        setDefaultCloseOperation(EXIT_ON_CLOSE);\n        I = new BufferedImage(getWidth(), getHeight(), BufferedImage.TYPE_INT_RGB);\n        for (int y = 0; y < getHeight(); y++) {\n            for (int x = 0; x < getWidth(); x++) {\n                zx = zy = 0;\n                cX = (x - 400) / ZOOM;\n                cY = (y - 300) / ZOOM;\n                int iter = MAX_ITER;\n                while (zx * zx + zy * zy < 4 && iter > 0) {\n                    tmp = zx * zx - zy * zy + cX;\n                    zy = 2.0 * zx * zy + cY;\n                    zx = tmp;\n                    iter--;\n                }\n                I.setRGB(x, y, iter | (iter << 8));\n            }\n        }\n    }\n\n    @Override\n    public void paint(Graphics g) {\n        g.drawImage(I, 0, 0, this);\n    }\n\n    public static void main(String[] args) {\n        new Mandelbrot().setVisible(true);\n    }\n}\n"}
{"id": 102759, "name": "Mandelbrot set", "source": "Translate Fortran to Python: program mandelbrot\n\n  implicit none\n  integer  , parameter :: rk       = selected_real_kind (9, 99)\n  integer  , parameter :: i_max    =  800\n  integer  , parameter :: j_max    =  600\n  integer  , parameter :: n_max    =  100\n  real (rk), parameter :: x_centre = -0.5_rk\n  real (rk), parameter :: y_centre =  0.0_rk\n  real (rk), parameter :: width    =  4.0_rk\n  real (rk), parameter :: height   =  3.0_rk\n  real (rk), parameter :: dx_di    =   width / i_max\n  real (rk), parameter :: dy_dj    = -height / j_max\n  real (rk), parameter :: x_offset = x_centre - 0.5_rk * (i_max + 1) * dx_di\n  real (rk), parameter :: y_offset = y_centre - 0.5_rk * (j_max + 1) * dy_dj\n  integer, dimension (i_max, j_max) :: image\n  integer   :: i\n  integer   :: j\n  integer   :: n\n  real (rk) :: x\n  real (rk) :: y\n  real (rk) :: x_0\n  real (rk) :: y_0\n  real (rk) :: x_sqr\n  real (rk) :: y_sqr\n\n  do j = 1, j_max\n    y_0 = y_offset + dy_dj * j\n    do i = 1, i_max\n      x_0 = x_offset + dx_di * i\n      x = 0.0_rk\n      y = 0.0_rk\n      n = 0\n      do\n        x_sqr = x ** 2\n        y_sqr = y ** 2\n        if (x_sqr + y_sqr > 4.0_rk) then\n          image (i, j) = 255\n          exit\n        end if\n        if (n == n_max) then\n          image (i, j) = 0\n          exit\n        end if\n        y = y_0 + 2.0_rk * x * y\n        x = x_0 + x_sqr - y_sqr\n        n = n + 1\n      end do\n    end do\n  end do\n  open  (10, file = 'out.pgm')\n  write (10, '(a/ i0, 1x, i0/ i0)') 'P2', i_max, j_max, 255\n  write (10, '(i0)') image\n  close (10)\n\nend program mandelbrot\n", "target": "i = di = dj = 0\nfn1, fn2, fn3 = random(20), random(20), random(20)\nf = 10\n    \ndef setup():\n    global zmx1, zmx2, zmy1, zmy2\n    size(500, 500)\n    zmx1 = int(width / 4)\n    zmx2 = 2\n    zmy1 = int(height / 4)\n    zmy2 = 2\n\n\ndef draw():\n    global i\n\n    if i <= width:\n        i += 1\n    x = float(i + di) / zmx1 - zmx2\n    for j in range(height + 1):\n        y = zmy2 - float(j + dj) / zmy1\n        zr = zi = zr2 = zi2 = 0\n        cr, ci = x, y\n        n = 1\n        while n < 200 and (zr2 + zi2) < 4:\n            zi2 = zi * zi\n            zr2 = zr * zr\n            zi = 2 * zi * zr + ci\n            zr = zr2 - zi2 + cr\n            n += 1\n\n        re = (n * fn1) % 255\n        gr = (n * fn2) % 255\n        bl = (n * fn3) % 255\n        stroke(re, gr, bl)\n        point(i, j)\n\n\ndef mousePressed():\n    global zmx1, zmx2, zmy1, zmy2, di, dj\n    global i, j\n    background(200)\n    xt, yt = mouseX, mouseY\n    di = di + xt - width / 2.\n    dj = dj + yt - height / 2.\n    zmx1 = zmx1 * f\n    zmx2 = zmx2 * (1. / f)\n    zmy1 = zmy1 * f\n    zmy2 = zmy2 * (1. / f)\n    di, dj = di * f, dj * f\n    i = j = 0\n"}
{"id": 103032, "name": "Anagrams", "source": "Translate Fortran to C#: \n\tmodule anagram_routines\n\n\timplicit none\n\t\n\t\n\tinteger,parameter :: file_unit = 1000\n\tcharacter(len=*),parameter :: filename = 'unixdict.txt'\n\t\n\t\n\tinteger,parameter :: max_chars = 50\n\t\n\t\n\tinteger,parameter :: str_len = 256\n\t\n\ttype word \n\t  character(len=max_chars) :: str = repeat(' ',max_chars)    \n\t  integer                  :: n = 0                          \n\t  integer                  :: n_anagrams = 0\t             \n\t  logical                  :: checked = .false.              \n\t  character(len=str_len)   :: anagrams = repeat(' ',str_len) \n\tend type word\n\t\n\t\n\ttype(word),dimension(:),allocatable,target :: dict\n\t\n\tcontains\n\n\n\t\n\t\tfunction count_lines_in_file(fid) result(n_lines)\n\t\n\t\timplicit none\n\t\n\t\tinteger             :: n_lines\n\t\tinteger,intent(in)  :: fid\t\t\n\t\tcharacter(len=1)    :: tmp\n\t\tinteger             :: i\n\t\tinteger             :: ios\n\t\t\n\t\t\n\t\t\n\t\trewind(fid)\t  \n\t\t\n\t\tn_lines = 0\n\t\tdo \n\t\t\tread(fid,'(A1)',iostat=ios) tmp\n\t\t\tif (ios < 0) exit      \n\t\t\tn_lines = n_lines + 1  \n\t\tend do\n\n\t\trewind(fid)   \n\t\t\t\t\n\t\n\t\tend function count_lines_in_file\n\t\n\t\n\t\n\t\tpure elemental function is_anagram(x,y)\n\t\n\t\timplicit none\n\t\tcharacter(len=*),intent(in) :: x\n\t\tcharacter(len=*),intent(in) :: y\n\t\tlogical :: is_anagram\n\t\n\t\tcharacter(len=len(x)) :: x_tmp\t\n\t\tinteger :: i,j\n\t\t\n\t\t\n\t\tcharacter(len=1),parameter :: null = achar(0)\n\t\t\t\n\t\t\n\t\t\n\t\tx_tmp = x\n\t\tdo i=1,len_trim(x)\n\t\t\tj = index(x_tmp, y(i:i)) \n\t\t\tif (j/=0) then\n\t\t\t\tx_tmp(j:j) = null  \n\t\t\telse\n\t\t\t\tis_anagram = .false. \n\t\t\t\treturn\n\t\t\tend if\n\t\tend do\n\t\n\t\t\n\t\t\n\t\tis_anagram = .true.\n\t\t\t\t\t\n\t\n\t\tend function is_anagram\n\t\n\n\n\tend module anagram_routines\n\n\n\n\tprogram main\n\n\tuse anagram_routines\n\timplicit none\n\t\n\tinteger :: n,i,j,n_max\n\ttype(word),pointer :: x,y\n\tlogical :: first_word\n\treal :: start, finish\n\t\n\tcall cpu_time(start)\t\n\t\n\t\n\topen(unit=file_unit,file=filename)      \n\tn = count_lines_in_file(file_unit)      \n\tallocate(dict(n))                       \n\tdo i=1,n                                \n\t\tread(file_unit,'(A)') dict(i)%str   \n\t\tdict(i)%n = len_trim(dict(i)%str)   \n\tend do\t\t\n\tclose(file_unit)                        \n\t\n\t\n\tdo i=1,n\n\t\t\n\t\tx => dict(i)\t\n\t\tfirst_word = .true.\t\n\t\t\n\t\tdo j=i,n\n\t\t\n\t\t\ty => dict(j)\t\n\t\t\t\n\t\t\t\n\t\t\tif (x%checked .or. y%checked) cycle     \n\t\t\tif (x%n/=y%n) cycle                     \n\t\t\tif (x%str(1:x%n)==y%str(1:y%n)) cycle   \n\t\t\t\n\t\t\t\n\t\t\tif (is_anagram(x%str(1:x%n), y%str(1:y%n))) then\n\t\t\t\t\n\t\t\t\ty%checked = .true. \t\n\t\t\t\tx%n_anagrams = x%n_anagrams + 1\n\t\t\t\tif (first_word) then\n\t\t\t\t\t\n\t\t\t\t\tfirst_word = .false.\n\t\t\t\t\tx%n_anagrams = x%n_anagrams + 1\n\t\t\t\t\tx%anagrams = trim(x%anagrams)//x%str(1:x%n)  \n\t\t\t\tend if\n\t\t\t\tx%anagrams = trim(x%anagrams)//','//y%str(1:y%n) \n\t\t\tend if\n\t\n\t\tend do\n\t\tx%checked = .true.  \n\t\t \n\tend do\n\t\n\t\n\twrite(*,*) ''\n\tn_max = maxval(dict%n_anagrams)\n\tdo i=1,n\n\t\tif (dict(i)%n_anagrams==n_max) write(*,'(A)') trim(dict(i)%anagrams)\n\tend do\n\t\n\t\n\twrite(*,*) ''\n\tn_max = maxval(dict%n, mask=dict%n_anagrams>0)\n\tdo i=1,n\n\t\tif (dict(i)%n_anagrams>0 .and. dict(i)%n==n_max) write(*,'(A)') trim(dict(i)%anagrams)\n\tend do\n\twrite(*,*) ''\n\n\tcall cpu_time(finish)\t\n\twrite(*,'(A,F6.3,A)') '[Runtime = ',finish-start,' sec]'\n\twrite(*,*) ''\n\n\n\tend program main\n\n", "target": "using System;\nusing System.IO;\nusing System.Linq;\nusing System.Net;\nusing System.Text.RegularExpressions;\n\nnamespace Anagram\n{\n    class Program\n    {\n        const string DICO_URL = \"http:\n\n        static void Main( string[] args )\n        {\n            WebRequest request = WebRequest.Create(DICO_URL);\n            string[] words;\n            using (StreamReader sr = new StreamReader(request.GetResponse().GetResponseStream(), true)) {\n                words = Regex.Split(sr.ReadToEnd(), @\"\\r?\\n\");\n            }\n            var groups = from string w in words\n                         group w by string.Concat(w.OrderBy(x => x)) into c\n                         group c by c.Count() into d\n                         orderby d.Key descending\n                         select d;\n            foreach (var c in groups.First()) {\n                Console.WriteLine(string.Join(\" \", c));\n            }\n        }\n    }\n}\n"}
{"id": 103035, "name": "Anagrams", "source": "Translate Fortran to Java: \n\tmodule anagram_routines\n\n\timplicit none\n\t\n\t\n\tinteger,parameter :: file_unit = 1000\n\tcharacter(len=*),parameter :: filename = 'unixdict.txt'\n\t\n\t\n\tinteger,parameter :: max_chars = 50\n\t\n\t\n\tinteger,parameter :: str_len = 256\n\t\n\ttype word \n\t  character(len=max_chars) :: str = repeat(' ',max_chars)    \n\t  integer                  :: n = 0                          \n\t  integer                  :: n_anagrams = 0\t             \n\t  logical                  :: checked = .false.              \n\t  character(len=str_len)   :: anagrams = repeat(' ',str_len) \n\tend type word\n\t\n\t\n\ttype(word),dimension(:),allocatable,target :: dict\n\t\n\tcontains\n\n\n\t\n\t\tfunction count_lines_in_file(fid) result(n_lines)\n\t\n\t\timplicit none\n\t\n\t\tinteger             :: n_lines\n\t\tinteger,intent(in)  :: fid\t\t\n\t\tcharacter(len=1)    :: tmp\n\t\tinteger             :: i\n\t\tinteger             :: ios\n\t\t\n\t\t\n\t\t\n\t\trewind(fid)\t  \n\t\t\n\t\tn_lines = 0\n\t\tdo \n\t\t\tread(fid,'(A1)',iostat=ios) tmp\n\t\t\tif (ios < 0) exit      \n\t\t\tn_lines = n_lines + 1  \n\t\tend do\n\n\t\trewind(fid)   \n\t\t\t\t\n\t\n\t\tend function count_lines_in_file\n\t\n\t\n\t\n\t\tpure elemental function is_anagram(x,y)\n\t\n\t\timplicit none\n\t\tcharacter(len=*),intent(in) :: x\n\t\tcharacter(len=*),intent(in) :: y\n\t\tlogical :: is_anagram\n\t\n\t\tcharacter(len=len(x)) :: x_tmp\t\n\t\tinteger :: i,j\n\t\t\n\t\t\n\t\tcharacter(len=1),parameter :: null = achar(0)\n\t\t\t\n\t\t\n\t\t\n\t\tx_tmp = x\n\t\tdo i=1,len_trim(x)\n\t\t\tj = index(x_tmp, y(i:i)) \n\t\t\tif (j/=0) then\n\t\t\t\tx_tmp(j:j) = null  \n\t\t\telse\n\t\t\t\tis_anagram = .false. \n\t\t\t\treturn\n\t\t\tend if\n\t\tend do\n\t\n\t\t\n\t\t\n\t\tis_anagram = .true.\n\t\t\t\t\t\n\t\n\t\tend function is_anagram\n\t\n\n\n\tend module anagram_routines\n\n\n\n\tprogram main\n\n\tuse anagram_routines\n\timplicit none\n\t\n\tinteger :: n,i,j,n_max\n\ttype(word),pointer :: x,y\n\tlogical :: first_word\n\treal :: start, finish\n\t\n\tcall cpu_time(start)\t\n\t\n\t\n\topen(unit=file_unit,file=filename)      \n\tn = count_lines_in_file(file_unit)      \n\tallocate(dict(n))                       \n\tdo i=1,n                                \n\t\tread(file_unit,'(A)') dict(i)%str   \n\t\tdict(i)%n = len_trim(dict(i)%str)   \n\tend do\t\t\n\tclose(file_unit)                        \n\t\n\t\n\tdo i=1,n\n\t\t\n\t\tx => dict(i)\t\n\t\tfirst_word = .true.\t\n\t\t\n\t\tdo j=i,n\n\t\t\n\t\t\ty => dict(j)\t\n\t\t\t\n\t\t\t\n\t\t\tif (x%checked .or. y%checked) cycle     \n\t\t\tif (x%n/=y%n) cycle                     \n\t\t\tif (x%str(1:x%n)==y%str(1:y%n)) cycle   \n\t\t\t\n\t\t\t\n\t\t\tif (is_anagram(x%str(1:x%n), y%str(1:y%n))) then\n\t\t\t\t\n\t\t\t\ty%checked = .true. \t\n\t\t\t\tx%n_anagrams = x%n_anagrams + 1\n\t\t\t\tif (first_word) then\n\t\t\t\t\t\n\t\t\t\t\tfirst_word = .false.\n\t\t\t\t\tx%n_anagrams = x%n_anagrams + 1\n\t\t\t\t\tx%anagrams = trim(x%anagrams)//x%str(1:x%n)  \n\t\t\t\tend if\n\t\t\t\tx%anagrams = trim(x%anagrams)//','//y%str(1:y%n) \n\t\t\tend if\n\t\n\t\tend do\n\t\tx%checked = .true.  \n\t\t \n\tend do\n\t\n\t\n\twrite(*,*) ''\n\tn_max = maxval(dict%n_anagrams)\n\tdo i=1,n\n\t\tif (dict(i)%n_anagrams==n_max) write(*,'(A)') trim(dict(i)%anagrams)\n\tend do\n\t\n\t\n\twrite(*,*) ''\n\tn_max = maxval(dict%n, mask=dict%n_anagrams>0)\n\tdo i=1,n\n\t\tif (dict(i)%n_anagrams>0 .and. dict(i)%n==n_max) write(*,'(A)') trim(dict(i)%anagrams)\n\tend do\n\twrite(*,*) ''\n\n\tcall cpu_time(finish)\t\n\twrite(*,'(A,F6.3,A)') '[Runtime = ',finish-start,' sec]'\n\twrite(*,*) ''\n\n\n\tend program main\n\n", "target": "import java.net.*;\nimport java.io.*;\nimport java.util.*;\n \npublic class WordsOfEqChars {\n    public static void main(String[] args) throws IOException {\n        URL url = new URL(\"http:\n        InputStreamReader isr = new InputStreamReader(url.openStream());\n        BufferedReader reader = new BufferedReader(isr);\n\n        Map<String, Collection<String>> anagrams = new HashMap<String, Collection<String>>();\n        String word;\n        int count = 0;\n        while ((word = reader.readLine()) != null) {\n            char[] chars = word.toCharArray();\n            Arrays.sort(chars);\n            String key = new String(chars);\n            if (!anagrams.containsKey(key))\n                anagrams.put(key, new ArrayList<String>());\n            anagrams.get(key).add(word);\n            count = Math.max(count, anagrams.get(key).size());\n        }\n\n        reader.close();\n\n        for (Collection<String> ana : anagrams.values())\n            if (ana.size() >= count)\n                System.out.println(ana);\n    }   \n}\n"}
{"id": 103036, "name": "Anagrams", "source": "Translate Fortran to Python: \n\tmodule anagram_routines\n\n\timplicit none\n\t\n\t\n\tinteger,parameter :: file_unit = 1000\n\tcharacter(len=*),parameter :: filename = 'unixdict.txt'\n\t\n\t\n\tinteger,parameter :: max_chars = 50\n\t\n\t\n\tinteger,parameter :: str_len = 256\n\t\n\ttype word \n\t  character(len=max_chars) :: str = repeat(' ',max_chars)    \n\t  integer                  :: n = 0                          \n\t  integer                  :: n_anagrams = 0\t             \n\t  logical                  :: checked = .false.              \n\t  character(len=str_len)   :: anagrams = repeat(' ',str_len) \n\tend type word\n\t\n\t\n\ttype(word),dimension(:),allocatable,target :: dict\n\t\n\tcontains\n\n\n\t\n\t\tfunction count_lines_in_file(fid) result(n_lines)\n\t\n\t\timplicit none\n\t\n\t\tinteger             :: n_lines\n\t\tinteger,intent(in)  :: fid\t\t\n\t\tcharacter(len=1)    :: tmp\n\t\tinteger             :: i\n\t\tinteger             :: ios\n\t\t\n\t\t\n\t\t\n\t\trewind(fid)\t  \n\t\t\n\t\tn_lines = 0\n\t\tdo \n\t\t\tread(fid,'(A1)',iostat=ios) tmp\n\t\t\tif (ios < 0) exit      \n\t\t\tn_lines = n_lines + 1  \n\t\tend do\n\n\t\trewind(fid)   \n\t\t\t\t\n\t\n\t\tend function count_lines_in_file\n\t\n\t\n\t\n\t\tpure elemental function is_anagram(x,y)\n\t\n\t\timplicit none\n\t\tcharacter(len=*),intent(in) :: x\n\t\tcharacter(len=*),intent(in) :: y\n\t\tlogical :: is_anagram\n\t\n\t\tcharacter(len=len(x)) :: x_tmp\t\n\t\tinteger :: i,j\n\t\t\n\t\t\n\t\tcharacter(len=1),parameter :: null = achar(0)\n\t\t\t\n\t\t\n\t\t\n\t\tx_tmp = x\n\t\tdo i=1,len_trim(x)\n\t\t\tj = index(x_tmp, y(i:i)) \n\t\t\tif (j/=0) then\n\t\t\t\tx_tmp(j:j) = null  \n\t\t\telse\n\t\t\t\tis_anagram = .false. \n\t\t\t\treturn\n\t\t\tend if\n\t\tend do\n\t\n\t\t\n\t\t\n\t\tis_anagram = .true.\n\t\t\t\t\t\n\t\n\t\tend function is_anagram\n\t\n\n\n\tend module anagram_routines\n\n\n\n\tprogram main\n\n\tuse anagram_routines\n\timplicit none\n\t\n\tinteger :: n,i,j,n_max\n\ttype(word),pointer :: x,y\n\tlogical :: first_word\n\treal :: start, finish\n\t\n\tcall cpu_time(start)\t\n\t\n\t\n\topen(unit=file_unit,file=filename)      \n\tn = count_lines_in_file(file_unit)      \n\tallocate(dict(n))                       \n\tdo i=1,n                                \n\t\tread(file_unit,'(A)') dict(i)%str   \n\t\tdict(i)%n = len_trim(dict(i)%str)   \n\tend do\t\t\n\tclose(file_unit)                        \n\t\n\t\n\tdo i=1,n\n\t\t\n\t\tx => dict(i)\t\n\t\tfirst_word = .true.\t\n\t\t\n\t\tdo j=i,n\n\t\t\n\t\t\ty => dict(j)\t\n\t\t\t\n\t\t\t\n\t\t\tif (x%checked .or. y%checked) cycle     \n\t\t\tif (x%n/=y%n) cycle                     \n\t\t\tif (x%str(1:x%n)==y%str(1:y%n)) cycle   \n\t\t\t\n\t\t\t\n\t\t\tif (is_anagram(x%str(1:x%n), y%str(1:y%n))) then\n\t\t\t\t\n\t\t\t\ty%checked = .true. \t\n\t\t\t\tx%n_anagrams = x%n_anagrams + 1\n\t\t\t\tif (first_word) then\n\t\t\t\t\t\n\t\t\t\t\tfirst_word = .false.\n\t\t\t\t\tx%n_anagrams = x%n_anagrams + 1\n\t\t\t\t\tx%anagrams = trim(x%anagrams)//x%str(1:x%n)  \n\t\t\t\tend if\n\t\t\t\tx%anagrams = trim(x%anagrams)//','//y%str(1:y%n) \n\t\t\tend if\n\t\n\t\tend do\n\t\tx%checked = .true.  \n\t\t \n\tend do\n\t\n\t\n\twrite(*,*) ''\n\tn_max = maxval(dict%n_anagrams)\n\tdo i=1,n\n\t\tif (dict(i)%n_anagrams==n_max) write(*,'(A)') trim(dict(i)%anagrams)\n\tend do\n\t\n\t\n\twrite(*,*) ''\n\tn_max = maxval(dict%n, mask=dict%n_anagrams>0)\n\tdo i=1,n\n\t\tif (dict(i)%n_anagrams>0 .and. dict(i)%n==n_max) write(*,'(A)') trim(dict(i)%anagrams)\n\tend do\n\twrite(*,*) ''\n\n\tcall cpu_time(finish)\t\n\twrite(*,'(A,F6.3,A)') '[Runtime = ',finish-start,' sec]'\n\twrite(*,*) ''\n\n\n\tend program main\n\n", "target": ">>> import urllib.request\n>>> from collections import defaultdict\n>>> words = urllib.request.urlopen('http://wiki.puzzlers.org/pub/wordlists/unixdict.txt').read().split()\n>>> anagram = defaultdict(list) \n>>> for word in words:\n\tanagram[tuple(sorted(word))].append( word )\n\n\t\n>>> count = max(len(ana) for ana in anagram.values())\n>>> for ana in anagram.values():\n\tif len(ana) >= count:\n\t\tprint ([x.decode() for x in ana])\n"}
{"id": 103293, "name": "Draw a clock", "source": "Translate Fortran to C#: \nprogram clock\nimplicit none\ninteger :: t(8)\ndo\n  call date_and_time(values=t)\n  call sleep(1)\n  call system('clear')\n  call digital_display(t(5),t(6),t(7))\nend do\nend program\n\nsubroutine digital_display(H,M,S)\n\ninteger :: H, M, S\n\ncharacter(len=*), parameter :: nfmt='(A8)', cfmt='(A6)'\ncharacter(len=88), parameter :: d1 = ' 00000     1     22222   33333      4   5555555  66666  7777777  88888   99999        '\ncharacter(len=88), parameter :: d2 = '0     0   11    2     2 3     3    44   5       6     6 7     7 8     8 9     9 \u00a0::   '\ncharacter(len=88), parameter :: d3 = '0    00  1 1          2       3   4 4   5       6             7 8     8 9     9 \u00a0::   '\ncharacter(len=88), parameter :: d4 = '0   0 0    1         2        3  4  4   5       6            7  8     8 9     9 \u00a0::   '\ncharacter(len=88), parameter :: d5 = '0  0  0    1        2      333  4444444 555555  666666      7    88888   999999       '\ncharacter(len=88), parameter :: d6 = '0 0   0    1       2          3     4         5 6     6    7    8     8       9 \u00a0::   '\ncharacter(len=88), parameter :: d7 = '00    0    1      2           3     4         5 6     6   7     8     8       9 \u00a0::   '\ncharacter(len=88), parameter :: d8 = '0     0    1     2      3     3     4   5     5 6     6  7      8     8 9     9 \u00a0::   '\ncharacter(len=88), parameter :: d9 = ' 00000  1111111 2222222  33333      4    55555   66666  7        88888   99999        '\ninteger :: h1, h2, m1, m2, s1, s2\nh1 = 1+8*floor(dble(H)/10.D0)\nh2 = 1+8*modulo(H,10)\nm1 = 1+8*floor(dble(M)/10.D0)\nm2 = 1+8*modulo(M,10)\ns1 = 1+8*floor(dble(S)/10.D0)\ns2 = 1+8*modulo(S,10)\n\nwrite(*,nfmt,advance='no') d1(h1:h1+8)\nwrite(*,nfmt,advance='no') d1(h2:h2+8)\nwrite(*,cfmt,advance='no') d1(81:88)\nwrite(*,nfmt,advance='no') d1(m1:m1+8)\nwrite(*,nfmt,advance='no') d1(m2:m2+8)\nwrite(*,cfmt,advance='no') d1(81:88)\nwrite(*,nfmt,advance='no') d1(s1:s1+8)\nwrite(*,nfmt) d1(s2:s2+8)\n\nwrite(*,nfmt,advance='no') d2(h1:h1+8)\nwrite(*,nfmt,advance='no') d2(h2:h2+8)\nwrite(*,cfmt,advance='no') d2(81:88)\nwrite(*,nfmt,advance='no') d2(m1:m1+8)\nwrite(*,nfmt,advance='no') d2(m2:m2+8)\nwrite(*,cfmt,advance='no') d2(81:88)\nwrite(*,nfmt,advance='no') d2(s1:s1+8)\nwrite(*,nfmt) d2(s2:s2+8)\n\nwrite(*,nfmt,advance='no') d3(h1:h1+8)\nwrite(*,nfmt,advance='no') d3(h2:h2+8)\nwrite(*,cfmt,advance='no') d3(81:88)\nwrite(*,nfmt,advance='no') d3(m1:m1+8)\nwrite(*,nfmt,advance='no') d3(m2:m2+8)\nwrite(*,cfmt,advance='no') d3(81:88)\nwrite(*,nfmt,advance='no') d3(s1:s1+8)\nwrite(*,nfmt) d3(s2:s2+8)\n\nwrite(*,nfmt,advance='no') d4(h1:h1+8)\nwrite(*,nfmt,advance='no') d4(h2:h2+8)\nwrite(*,cfmt,advance='no') d4(81:88)\nwrite(*,nfmt,advance='no') d4(m1:m1+8)\nwrite(*,nfmt,advance='no') d4(m2:m2+8)\nwrite(*,cfmt,advance='no') d4(81:88)\nwrite(*,nfmt,advance='no') d4(s1:s1+8)\nwrite(*,nfmt) d4(s2:s2+8)\n\nwrite(*,nfmt,advance='no') d5(h1:h1+8)\nwrite(*,nfmt,advance='no') d5(h2:h2+8)\nwrite(*,cfmt,advance='no') d5(81:88)\nwrite(*,nfmt,advance='no') d5(m1:m1+8)\nwrite(*,nfmt,advance='no') d5(m2:m2+8)\nwrite(*,cfmt,advance='no') d5(81:88)\nwrite(*,nfmt,advance='no') d5(s1:s1+8)\nwrite(*,nfmt) d5(s2:s2+8)\n\nwrite(*,nfmt,advance='no') d6(h1:h1+8)\nwrite(*,nfmt,advance='no') d6(h2:h2+8)\nwrite(*,cfmt,advance='no') d6(81:88)\nwrite(*,nfmt,advance='no') d6(m1:m1+8)\nwrite(*,nfmt,advance='no') d6(m2:m2+8)\nwrite(*,cfmt,advance='no') d6(81:88)\nwrite(*,nfmt,advance='no') d6(s1:s1+8)\nwrite(*,nfmt) d6(s2:s2+8)\n\nwrite(*,nfmt,advance='no') d7(h1:h1+8)\nwrite(*,nfmt,advance='no') d7(h2:h2+8)\nwrite(*,cfmt,advance='no') d7(81:88)\nwrite(*,nfmt,advance='no') d7(m1:m1+8)\nwrite(*,nfmt,advance='no') d7(m2:m2+8)\nwrite(*,cfmt,advance='no') d7(81:88)\nwrite(*,nfmt,advance='no') d7(s1:s1+8)\nwrite(*,nfmt) d7(s2:s2+8)\n\nwrite(*,nfmt,advance='no') d8(h1:h1+8)\nwrite(*,nfmt,advance='no') d8(h2:h2+8)\nwrite(*,cfmt,advance='no') d8(81:88)\nwrite(*,nfmt,advance='no') d8(m1:m1+8)\nwrite(*,nfmt,advance='no') d8(m2:m2+8)\nwrite(*,cfmt,advance='no') d8(81:88)\nwrite(*,nfmt,advance='no') d8(s1:s1+8)\nwrite(*,nfmt) d8(s2:s2+8)\n\nwrite(*,nfmt,advance='no') d9(h1:h1+8)\nwrite(*,nfmt,advance='no') d9(h2:h2+8)\nwrite(*,cfmt,advance='no') d9(81:88)\nwrite(*,nfmt,advance='no') d9(m1:m1+8)\nwrite(*,nfmt,advance='no') d9(m2:m2+8)\nwrite(*,cfmt,advance='no') d9(81:88)\nwrite(*,nfmt,advance='no') d9(s1:s1+8)\nwrite(*,nfmt) d9(s2:s2+8)\n\nend subroutine\n", "target": "using System;\nusing System.Drawing;\nusing System.Drawing.Drawing2D;\nusing System.Windows.Forms;\n\npublic class Clock : Form\n{\n    static readonly float degrees06 = (float)Math.PI / 30;\n    static readonly float degrees30 = degrees06 * 5;\n    static readonly float degrees90 = degrees30 * 3;\n\n    readonly int margin = 20;\n\n    private Point p0;\n\n    public Clock()\n    {\n        Size = new Size(500, 500);\n        StartPosition = FormStartPosition.CenterScreen;\n        Resize += (sender, args) => ResetSize();\n        ResetSize();\n        var timer = new Timer() { Interval = 1000, Enabled = true };\n        timer.Tick += (sender, e) => Refresh();\n        DoubleBuffered = true;\n    }\n\n    private void ResetSize()\n    {\n        p0 = new Point(ClientRectangle.Width / 2, ClientRectangle.Height / 2);\n        Refresh();\n    }\n\n    protected override void OnPaint(PaintEventArgs e)\n    {\n        base.OnPaint(e);\n        e.Graphics.SmoothingMode = SmoothingMode.AntiAlias;\n\n        drawFace(e.Graphics);\n\n        var time = DateTime.Now;\n        int second = time.Second;\n        int minute = time.Minute;\n        int hour = time.Hour;\n\n        float angle = degrees90 - (degrees06 * second);\n        DrawHand(e.Graphics, Pens.Red, angle, 0.95);\n\n        float minsecs = (minute + second / 60.0F);\n        angle = degrees90 - (degrees06 * minsecs);\n        DrawHand(e.Graphics, Pens.Black, angle, 0.9);\n\n        float hourmins = (hour + minsecs / 60.0F);\n        angle = degrees90 - (degrees30 * hourmins);\n        DrawHand(e.Graphics, Pens.Black, angle, 0.6);\n    }\n\n    private void drawFace(Graphics g)\n    {\n        int radius = Math.Min(p0.X, p0.Y) - margin;\n        g.FillEllipse(Brushes.White, p0.X - radius, p0.Y - radius, radius * 2, radius * 2);\n\n        for (int h = 0; h < 12; h++)\n            DrawHand(g, Pens.LightGray, h * degrees30, -0.05);\n\n        for (int m = 0; m < 60; m++)\n            DrawHand(g, Pens.LightGray, m * degrees06, -0.025);\n    }\n\n    private void DrawHand(Graphics g, Pen pen, float angle, double size)\n    {\n        int radius = Math.Min(p0.X, p0.Y) - margin;\n\n        int x0 = p0.X + (size > 0 ? 0 : Convert.ToInt32(radius * (1 + size) * Math.Cos(angle)));\n        int y0 = p0.Y + (size > 0 ? 0 : Convert.ToInt32(radius * (1 + size) * Math.Sin(-angle)));\n\n        int x1 = p0.X + Convert.ToInt32(radius * (size > 0 ? size : 1) * Math.Cos(angle));\n        int y1 = p0.Y + Convert.ToInt32(radius * (size > 0 ? size : 1) * Math.Sin(-angle));\n\n        g.DrawLine(pen, x0, y0, x1, y1);\n    }\n\n    [STAThread]\n    static void Main()\n    {\n        Application.Run(new Clock());\n    }\n}\n"}
{"id": 103294, "name": "Draw a clock", "source": "Translate Fortran to C#: \nprogram clock\nimplicit none\ninteger :: t(8)\ndo\n  call date_and_time(values=t)\n  call sleep(1)\n  call system('clear')\n  call digital_display(t(5),t(6),t(7))\nend do\nend program\n\nsubroutine digital_display(H,M,S)\n\ninteger :: H, M, S\n\ncharacter(len=*), parameter :: nfmt='(A8)', cfmt='(A6)'\ncharacter(len=88), parameter :: d1 = ' 00000     1     22222   33333      4   5555555  66666  7777777  88888   99999        '\ncharacter(len=88), parameter :: d2 = '0     0   11    2     2 3     3    44   5       6     6 7     7 8     8 9     9 \u00a0::   '\ncharacter(len=88), parameter :: d3 = '0    00  1 1          2       3   4 4   5       6             7 8     8 9     9 \u00a0::   '\ncharacter(len=88), parameter :: d4 = '0   0 0    1         2        3  4  4   5       6            7  8     8 9     9 \u00a0::   '\ncharacter(len=88), parameter :: d5 = '0  0  0    1        2      333  4444444 555555  666666      7    88888   999999       '\ncharacter(len=88), parameter :: d6 = '0 0   0    1       2          3     4         5 6     6    7    8     8       9 \u00a0::   '\ncharacter(len=88), parameter :: d7 = '00    0    1      2           3     4         5 6     6   7     8     8       9 \u00a0::   '\ncharacter(len=88), parameter :: d8 = '0     0    1     2      3     3     4   5     5 6     6  7      8     8 9     9 \u00a0::   '\ncharacter(len=88), parameter :: d9 = ' 00000  1111111 2222222  33333      4    55555   66666  7        88888   99999        '\ninteger :: h1, h2, m1, m2, s1, s2\nh1 = 1+8*floor(dble(H)/10.D0)\nh2 = 1+8*modulo(H,10)\nm1 = 1+8*floor(dble(M)/10.D0)\nm2 = 1+8*modulo(M,10)\ns1 = 1+8*floor(dble(S)/10.D0)\ns2 = 1+8*modulo(S,10)\n\nwrite(*,nfmt,advance='no') d1(h1:h1+8)\nwrite(*,nfmt,advance='no') d1(h2:h2+8)\nwrite(*,cfmt,advance='no') d1(81:88)\nwrite(*,nfmt,advance='no') d1(m1:m1+8)\nwrite(*,nfmt,advance='no') d1(m2:m2+8)\nwrite(*,cfmt,advance='no') d1(81:88)\nwrite(*,nfmt,advance='no') d1(s1:s1+8)\nwrite(*,nfmt) d1(s2:s2+8)\n\nwrite(*,nfmt,advance='no') d2(h1:h1+8)\nwrite(*,nfmt,advance='no') d2(h2:h2+8)\nwrite(*,cfmt,advance='no') d2(81:88)\nwrite(*,nfmt,advance='no') d2(m1:m1+8)\nwrite(*,nfmt,advance='no') d2(m2:m2+8)\nwrite(*,cfmt,advance='no') d2(81:88)\nwrite(*,nfmt,advance='no') d2(s1:s1+8)\nwrite(*,nfmt) d2(s2:s2+8)\n\nwrite(*,nfmt,advance='no') d3(h1:h1+8)\nwrite(*,nfmt,advance='no') d3(h2:h2+8)\nwrite(*,cfmt,advance='no') d3(81:88)\nwrite(*,nfmt,advance='no') d3(m1:m1+8)\nwrite(*,nfmt,advance='no') d3(m2:m2+8)\nwrite(*,cfmt,advance='no') d3(81:88)\nwrite(*,nfmt,advance='no') d3(s1:s1+8)\nwrite(*,nfmt) d3(s2:s2+8)\n\nwrite(*,nfmt,advance='no') d4(h1:h1+8)\nwrite(*,nfmt,advance='no') d4(h2:h2+8)\nwrite(*,cfmt,advance='no') d4(81:88)\nwrite(*,nfmt,advance='no') d4(m1:m1+8)\nwrite(*,nfmt,advance='no') d4(m2:m2+8)\nwrite(*,cfmt,advance='no') d4(81:88)\nwrite(*,nfmt,advance='no') d4(s1:s1+8)\nwrite(*,nfmt) d4(s2:s2+8)\n\nwrite(*,nfmt,advance='no') d5(h1:h1+8)\nwrite(*,nfmt,advance='no') d5(h2:h2+8)\nwrite(*,cfmt,advance='no') d5(81:88)\nwrite(*,nfmt,advance='no') d5(m1:m1+8)\nwrite(*,nfmt,advance='no') d5(m2:m2+8)\nwrite(*,cfmt,advance='no') d5(81:88)\nwrite(*,nfmt,advance='no') d5(s1:s1+8)\nwrite(*,nfmt) d5(s2:s2+8)\n\nwrite(*,nfmt,advance='no') d6(h1:h1+8)\nwrite(*,nfmt,advance='no') d6(h2:h2+8)\nwrite(*,cfmt,advance='no') d6(81:88)\nwrite(*,nfmt,advance='no') d6(m1:m1+8)\nwrite(*,nfmt,advance='no') d6(m2:m2+8)\nwrite(*,cfmt,advance='no') d6(81:88)\nwrite(*,nfmt,advance='no') d6(s1:s1+8)\nwrite(*,nfmt) d6(s2:s2+8)\n\nwrite(*,nfmt,advance='no') d7(h1:h1+8)\nwrite(*,nfmt,advance='no') d7(h2:h2+8)\nwrite(*,cfmt,advance='no') d7(81:88)\nwrite(*,nfmt,advance='no') d7(m1:m1+8)\nwrite(*,nfmt,advance='no') d7(m2:m2+8)\nwrite(*,cfmt,advance='no') d7(81:88)\nwrite(*,nfmt,advance='no') d7(s1:s1+8)\nwrite(*,nfmt) d7(s2:s2+8)\n\nwrite(*,nfmt,advance='no') d8(h1:h1+8)\nwrite(*,nfmt,advance='no') d8(h2:h2+8)\nwrite(*,cfmt,advance='no') d8(81:88)\nwrite(*,nfmt,advance='no') d8(m1:m1+8)\nwrite(*,nfmt,advance='no') d8(m2:m2+8)\nwrite(*,cfmt,advance='no') d8(81:88)\nwrite(*,nfmt,advance='no') d8(s1:s1+8)\nwrite(*,nfmt) d8(s2:s2+8)\n\nwrite(*,nfmt,advance='no') d9(h1:h1+8)\nwrite(*,nfmt,advance='no') d9(h2:h2+8)\nwrite(*,cfmt,advance='no') d9(81:88)\nwrite(*,nfmt,advance='no') d9(m1:m1+8)\nwrite(*,nfmt,advance='no') d9(m2:m2+8)\nwrite(*,cfmt,advance='no') d9(81:88)\nwrite(*,nfmt,advance='no') d9(s1:s1+8)\nwrite(*,nfmt) d9(s2:s2+8)\n\nend subroutine\n", "target": "using System;\nusing System.Drawing;\nusing System.Drawing.Drawing2D;\nusing System.Windows.Forms;\n\npublic class Clock : Form\n{\n    static readonly float degrees06 = (float)Math.PI / 30;\n    static readonly float degrees30 = degrees06 * 5;\n    static readonly float degrees90 = degrees30 * 3;\n\n    readonly int margin = 20;\n\n    private Point p0;\n\n    public Clock()\n    {\n        Size = new Size(500, 500);\n        StartPosition = FormStartPosition.CenterScreen;\n        Resize += (sender, args) => ResetSize();\n        ResetSize();\n        var timer = new Timer() { Interval = 1000, Enabled = true };\n        timer.Tick += (sender, e) => Refresh();\n        DoubleBuffered = true;\n    }\n\n    private void ResetSize()\n    {\n        p0 = new Point(ClientRectangle.Width / 2, ClientRectangle.Height / 2);\n        Refresh();\n    }\n\n    protected override void OnPaint(PaintEventArgs e)\n    {\n        base.OnPaint(e);\n        e.Graphics.SmoothingMode = SmoothingMode.AntiAlias;\n\n        drawFace(e.Graphics);\n\n        var time = DateTime.Now;\n        int second = time.Second;\n        int minute = time.Minute;\n        int hour = time.Hour;\n\n        float angle = degrees90 - (degrees06 * second);\n        DrawHand(e.Graphics, Pens.Red, angle, 0.95);\n\n        float minsecs = (minute + second / 60.0F);\n        angle = degrees90 - (degrees06 * minsecs);\n        DrawHand(e.Graphics, Pens.Black, angle, 0.9);\n\n        float hourmins = (hour + minsecs / 60.0F);\n        angle = degrees90 - (degrees30 * hourmins);\n        DrawHand(e.Graphics, Pens.Black, angle, 0.6);\n    }\n\n    private void drawFace(Graphics g)\n    {\n        int radius = Math.Min(p0.X, p0.Y) - margin;\n        g.FillEllipse(Brushes.White, p0.X - radius, p0.Y - radius, radius * 2, radius * 2);\n\n        for (int h = 0; h < 12; h++)\n            DrawHand(g, Pens.LightGray, h * degrees30, -0.05);\n\n        for (int m = 0; m < 60; m++)\n            DrawHand(g, Pens.LightGray, m * degrees06, -0.025);\n    }\n\n    private void DrawHand(Graphics g, Pen pen, float angle, double size)\n    {\n        int radius = Math.Min(p0.X, p0.Y) - margin;\n\n        int x0 = p0.X + (size > 0 ? 0 : Convert.ToInt32(radius * (1 + size) * Math.Cos(angle)));\n        int y0 = p0.Y + (size > 0 ? 0 : Convert.ToInt32(radius * (1 + size) * Math.Sin(-angle)));\n\n        int x1 = p0.X + Convert.ToInt32(radius * (size > 0 ? size : 1) * Math.Cos(angle));\n        int y1 = p0.Y + Convert.ToInt32(radius * (size > 0 ? size : 1) * Math.Sin(-angle));\n\n        g.DrawLine(pen, x0, y0, x1, y1);\n    }\n\n    [STAThread]\n    static void Main()\n    {\n        Application.Run(new Clock());\n    }\n}\n"}
{"id": 103298, "name": "Draw a clock", "source": "Translate Fortran to Java: \nprogram clock\nimplicit none\ninteger :: t(8)\ndo\n  call date_and_time(values=t)\n  call sleep(1)\n  call system('clear')\n  call digital_display(t(5),t(6),t(7))\nend do\nend program\n\nsubroutine digital_display(H,M,S)\n\ninteger :: H, M, S\n\ncharacter(len=*), parameter :: nfmt='(A8)', cfmt='(A6)'\ncharacter(len=88), parameter :: d1 = ' 00000     1     22222   33333      4   5555555  66666  7777777  88888   99999        '\ncharacter(len=88), parameter :: d2 = '0     0   11    2     2 3     3    44   5       6     6 7     7 8     8 9     9 \u00a0::   '\ncharacter(len=88), parameter :: d3 = '0    00  1 1          2       3   4 4   5       6             7 8     8 9     9 \u00a0::   '\ncharacter(len=88), parameter :: d4 = '0   0 0    1         2        3  4  4   5       6            7  8     8 9     9 \u00a0::   '\ncharacter(len=88), parameter :: d5 = '0  0  0    1        2      333  4444444 555555  666666      7    88888   999999       '\ncharacter(len=88), parameter :: d6 = '0 0   0    1       2          3     4         5 6     6    7    8     8       9 \u00a0::   '\ncharacter(len=88), parameter :: d7 = '00    0    1      2           3     4         5 6     6   7     8     8       9 \u00a0::   '\ncharacter(len=88), parameter :: d8 = '0     0    1     2      3     3     4   5     5 6     6  7      8     8 9     9 \u00a0::   '\ncharacter(len=88), parameter :: d9 = ' 00000  1111111 2222222  33333      4    55555   66666  7        88888   99999        '\ninteger :: h1, h2, m1, m2, s1, s2\nh1 = 1+8*floor(dble(H)/10.D0)\nh2 = 1+8*modulo(H,10)\nm1 = 1+8*floor(dble(M)/10.D0)\nm2 = 1+8*modulo(M,10)\ns1 = 1+8*floor(dble(S)/10.D0)\ns2 = 1+8*modulo(S,10)\n\nwrite(*,nfmt,advance='no') d1(h1:h1+8)\nwrite(*,nfmt,advance='no') d1(h2:h2+8)\nwrite(*,cfmt,advance='no') d1(81:88)\nwrite(*,nfmt,advance='no') d1(m1:m1+8)\nwrite(*,nfmt,advance='no') d1(m2:m2+8)\nwrite(*,cfmt,advance='no') d1(81:88)\nwrite(*,nfmt,advance='no') d1(s1:s1+8)\nwrite(*,nfmt) d1(s2:s2+8)\n\nwrite(*,nfmt,advance='no') d2(h1:h1+8)\nwrite(*,nfmt,advance='no') d2(h2:h2+8)\nwrite(*,cfmt,advance='no') d2(81:88)\nwrite(*,nfmt,advance='no') d2(m1:m1+8)\nwrite(*,nfmt,advance='no') d2(m2:m2+8)\nwrite(*,cfmt,advance='no') d2(81:88)\nwrite(*,nfmt,advance='no') d2(s1:s1+8)\nwrite(*,nfmt) d2(s2:s2+8)\n\nwrite(*,nfmt,advance='no') d3(h1:h1+8)\nwrite(*,nfmt,advance='no') d3(h2:h2+8)\nwrite(*,cfmt,advance='no') d3(81:88)\nwrite(*,nfmt,advance='no') d3(m1:m1+8)\nwrite(*,nfmt,advance='no') d3(m2:m2+8)\nwrite(*,cfmt,advance='no') d3(81:88)\nwrite(*,nfmt,advance='no') d3(s1:s1+8)\nwrite(*,nfmt) d3(s2:s2+8)\n\nwrite(*,nfmt,advance='no') d4(h1:h1+8)\nwrite(*,nfmt,advance='no') d4(h2:h2+8)\nwrite(*,cfmt,advance='no') d4(81:88)\nwrite(*,nfmt,advance='no') d4(m1:m1+8)\nwrite(*,nfmt,advance='no') d4(m2:m2+8)\nwrite(*,cfmt,advance='no') d4(81:88)\nwrite(*,nfmt,advance='no') d4(s1:s1+8)\nwrite(*,nfmt) d4(s2:s2+8)\n\nwrite(*,nfmt,advance='no') d5(h1:h1+8)\nwrite(*,nfmt,advance='no') d5(h2:h2+8)\nwrite(*,cfmt,advance='no') d5(81:88)\nwrite(*,nfmt,advance='no') d5(m1:m1+8)\nwrite(*,nfmt,advance='no') d5(m2:m2+8)\nwrite(*,cfmt,advance='no') d5(81:88)\nwrite(*,nfmt,advance='no') d5(s1:s1+8)\nwrite(*,nfmt) d5(s2:s2+8)\n\nwrite(*,nfmt,advance='no') d6(h1:h1+8)\nwrite(*,nfmt,advance='no') d6(h2:h2+8)\nwrite(*,cfmt,advance='no') d6(81:88)\nwrite(*,nfmt,advance='no') d6(m1:m1+8)\nwrite(*,nfmt,advance='no') d6(m2:m2+8)\nwrite(*,cfmt,advance='no') d6(81:88)\nwrite(*,nfmt,advance='no') d6(s1:s1+8)\nwrite(*,nfmt) d6(s2:s2+8)\n\nwrite(*,nfmt,advance='no') d7(h1:h1+8)\nwrite(*,nfmt,advance='no') d7(h2:h2+8)\nwrite(*,cfmt,advance='no') d7(81:88)\nwrite(*,nfmt,advance='no') d7(m1:m1+8)\nwrite(*,nfmt,advance='no') d7(m2:m2+8)\nwrite(*,cfmt,advance='no') d7(81:88)\nwrite(*,nfmt,advance='no') d7(s1:s1+8)\nwrite(*,nfmt) d7(s2:s2+8)\n\nwrite(*,nfmt,advance='no') d8(h1:h1+8)\nwrite(*,nfmt,advance='no') d8(h2:h2+8)\nwrite(*,cfmt,advance='no') d8(81:88)\nwrite(*,nfmt,advance='no') d8(m1:m1+8)\nwrite(*,nfmt,advance='no') d8(m2:m2+8)\nwrite(*,cfmt,advance='no') d8(81:88)\nwrite(*,nfmt,advance='no') d8(s1:s1+8)\nwrite(*,nfmt) d8(s2:s2+8)\n\nwrite(*,nfmt,advance='no') d9(h1:h1+8)\nwrite(*,nfmt,advance='no') d9(h2:h2+8)\nwrite(*,cfmt,advance='no') d9(81:88)\nwrite(*,nfmt,advance='no') d9(m1:m1+8)\nwrite(*,nfmt,advance='no') d9(m2:m2+8)\nwrite(*,cfmt,advance='no') d9(81:88)\nwrite(*,nfmt,advance='no') d9(s1:s1+8)\nwrite(*,nfmt) d9(s2:s2+8)\n\nend subroutine\n", "target": "import java.awt.*;\nimport java.awt.event.*;\nimport static java.lang.Math.*;\nimport java.time.LocalTime;\nimport javax.swing.*;\n\nclass Clock extends JPanel {\n\n    final float degrees06 = (float) (PI / 30);\n    final float degrees30 = degrees06 * 5;\n    final float degrees90 = degrees30 * 3;\n\n    final int size = 590;\n    final int spacing = 40;\n    final int diameter = size - 2 * spacing;\n    final int cx = diameter / 2 + spacing;\n    final int cy = diameter / 2 + spacing;\n\n    public Clock() {\n        setPreferredSize(new Dimension(size, size));\n        setBackground(Color.white);\n\n        new Timer(1000, (ActionEvent e) -> {\n            repaint();\n        }).start();\n    }\n\n    @Override\n    public void paintComponent(Graphics gg) {\n        super.paintComponent(gg);\n        Graphics2D g = (Graphics2D) gg;\n        g.setRenderingHint(RenderingHints.KEY_ANTIALIASING,\n                RenderingHints.VALUE_ANTIALIAS_ON);\n\n        drawFace(g);\n\n        final LocalTime time  = LocalTime.now();\n        int hour = time.getHour();\n        int minute = time.getMinute();\n        int second = time.getSecond();\n\n        float angle = degrees90 - (degrees06 * second);\n        drawHand(g, angle, diameter / 2 - 30, Color.red);\n\n        float minsecs = (minute + second / 60.0F);\n        angle = degrees90 - (degrees06 * minsecs);\n        drawHand(g, angle, diameter / 3 + 10, Color.black);\n\n        float hourmins = (hour + minsecs / 60.0F);\n        angle = degrees90 - (degrees30 * hourmins);\n        drawHand(g, angle, diameter / 4 + 10, Color.black);\n    }\n\n    private void drawFace(Graphics2D g) {\n        g.setStroke(new BasicStroke(2));\n        g.setColor(Color.white);\n        g.fillOval(spacing, spacing, diameter, diameter);\n        g.setColor(Color.black);\n        g.drawOval(spacing, spacing, diameter, diameter);\n    }\n\n    private void drawHand(Graphics2D g, float angle, int radius, Color color) {\n        int x = cx + (int) (radius * cos(angle));\n        int y = cy - (int) (radius * sin(angle));\n        g.setColor(color);\n        g.drawLine(cx, cy, x, y);\n    }\n\n    public static void main(String[] args) {\n        SwingUtilities.invokeLater(() -> {\n            JFrame f = new JFrame();\n            f.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n            f.setTitle(\"Clock\");\n            f.setResizable(false);\n            f.add(new Clock(), BorderLayout.CENTER);\n            f.pack();\n            f.setLocationRelativeTo(null);\n            f.setVisible(true);\n        });\n    }\n}\n"}
{"id": 103299, "name": "Draw a clock", "source": "Translate Fortran to Java: \nprogram clock\nimplicit none\ninteger :: t(8)\ndo\n  call date_and_time(values=t)\n  call sleep(1)\n  call system('clear')\n  call digital_display(t(5),t(6),t(7))\nend do\nend program\n\nsubroutine digital_display(H,M,S)\n\ninteger :: H, M, S\n\ncharacter(len=*), parameter :: nfmt='(A8)', cfmt='(A6)'\ncharacter(len=88), parameter :: d1 = ' 00000     1     22222   33333      4   5555555  66666  7777777  88888   99999        '\ncharacter(len=88), parameter :: d2 = '0     0   11    2     2 3     3    44   5       6     6 7     7 8     8 9     9 \u00a0::   '\ncharacter(len=88), parameter :: d3 = '0    00  1 1          2       3   4 4   5       6             7 8     8 9     9 \u00a0::   '\ncharacter(len=88), parameter :: d4 = '0   0 0    1         2        3  4  4   5       6            7  8     8 9     9 \u00a0::   '\ncharacter(len=88), parameter :: d5 = '0  0  0    1        2      333  4444444 555555  666666      7    88888   999999       '\ncharacter(len=88), parameter :: d6 = '0 0   0    1       2          3     4         5 6     6    7    8     8       9 \u00a0::   '\ncharacter(len=88), parameter :: d7 = '00    0    1      2           3     4         5 6     6   7     8     8       9 \u00a0::   '\ncharacter(len=88), parameter :: d8 = '0     0    1     2      3     3     4   5     5 6     6  7      8     8 9     9 \u00a0::   '\ncharacter(len=88), parameter :: d9 = ' 00000  1111111 2222222  33333      4    55555   66666  7        88888   99999        '\ninteger :: h1, h2, m1, m2, s1, s2\nh1 = 1+8*floor(dble(H)/10.D0)\nh2 = 1+8*modulo(H,10)\nm1 = 1+8*floor(dble(M)/10.D0)\nm2 = 1+8*modulo(M,10)\ns1 = 1+8*floor(dble(S)/10.D0)\ns2 = 1+8*modulo(S,10)\n\nwrite(*,nfmt,advance='no') d1(h1:h1+8)\nwrite(*,nfmt,advance='no') d1(h2:h2+8)\nwrite(*,cfmt,advance='no') d1(81:88)\nwrite(*,nfmt,advance='no') d1(m1:m1+8)\nwrite(*,nfmt,advance='no') d1(m2:m2+8)\nwrite(*,cfmt,advance='no') d1(81:88)\nwrite(*,nfmt,advance='no') d1(s1:s1+8)\nwrite(*,nfmt) d1(s2:s2+8)\n\nwrite(*,nfmt,advance='no') d2(h1:h1+8)\nwrite(*,nfmt,advance='no') d2(h2:h2+8)\nwrite(*,cfmt,advance='no') d2(81:88)\nwrite(*,nfmt,advance='no') d2(m1:m1+8)\nwrite(*,nfmt,advance='no') d2(m2:m2+8)\nwrite(*,cfmt,advance='no') d2(81:88)\nwrite(*,nfmt,advance='no') d2(s1:s1+8)\nwrite(*,nfmt) d2(s2:s2+8)\n\nwrite(*,nfmt,advance='no') d3(h1:h1+8)\nwrite(*,nfmt,advance='no') d3(h2:h2+8)\nwrite(*,cfmt,advance='no') d3(81:88)\nwrite(*,nfmt,advance='no') d3(m1:m1+8)\nwrite(*,nfmt,advance='no') d3(m2:m2+8)\nwrite(*,cfmt,advance='no') d3(81:88)\nwrite(*,nfmt,advance='no') d3(s1:s1+8)\nwrite(*,nfmt) d3(s2:s2+8)\n\nwrite(*,nfmt,advance='no') d4(h1:h1+8)\nwrite(*,nfmt,advance='no') d4(h2:h2+8)\nwrite(*,cfmt,advance='no') d4(81:88)\nwrite(*,nfmt,advance='no') d4(m1:m1+8)\nwrite(*,nfmt,advance='no') d4(m2:m2+8)\nwrite(*,cfmt,advance='no') d4(81:88)\nwrite(*,nfmt,advance='no') d4(s1:s1+8)\nwrite(*,nfmt) d4(s2:s2+8)\n\nwrite(*,nfmt,advance='no') d5(h1:h1+8)\nwrite(*,nfmt,advance='no') d5(h2:h2+8)\nwrite(*,cfmt,advance='no') d5(81:88)\nwrite(*,nfmt,advance='no') d5(m1:m1+8)\nwrite(*,nfmt,advance='no') d5(m2:m2+8)\nwrite(*,cfmt,advance='no') d5(81:88)\nwrite(*,nfmt,advance='no') d5(s1:s1+8)\nwrite(*,nfmt) d5(s2:s2+8)\n\nwrite(*,nfmt,advance='no') d6(h1:h1+8)\nwrite(*,nfmt,advance='no') d6(h2:h2+8)\nwrite(*,cfmt,advance='no') d6(81:88)\nwrite(*,nfmt,advance='no') d6(m1:m1+8)\nwrite(*,nfmt,advance='no') d6(m2:m2+8)\nwrite(*,cfmt,advance='no') d6(81:88)\nwrite(*,nfmt,advance='no') d6(s1:s1+8)\nwrite(*,nfmt) d6(s2:s2+8)\n\nwrite(*,nfmt,advance='no') d7(h1:h1+8)\nwrite(*,nfmt,advance='no') d7(h2:h2+8)\nwrite(*,cfmt,advance='no') d7(81:88)\nwrite(*,nfmt,advance='no') d7(m1:m1+8)\nwrite(*,nfmt,advance='no') d7(m2:m2+8)\nwrite(*,cfmt,advance='no') d7(81:88)\nwrite(*,nfmt,advance='no') d7(s1:s1+8)\nwrite(*,nfmt) d7(s2:s2+8)\n\nwrite(*,nfmt,advance='no') d8(h1:h1+8)\nwrite(*,nfmt,advance='no') d8(h2:h2+8)\nwrite(*,cfmt,advance='no') d8(81:88)\nwrite(*,nfmt,advance='no') d8(m1:m1+8)\nwrite(*,nfmt,advance='no') d8(m2:m2+8)\nwrite(*,cfmt,advance='no') d8(81:88)\nwrite(*,nfmt,advance='no') d8(s1:s1+8)\nwrite(*,nfmt) d8(s2:s2+8)\n\nwrite(*,nfmt,advance='no') d9(h1:h1+8)\nwrite(*,nfmt,advance='no') d9(h2:h2+8)\nwrite(*,cfmt,advance='no') d9(81:88)\nwrite(*,nfmt,advance='no') d9(m1:m1+8)\nwrite(*,nfmt,advance='no') d9(m2:m2+8)\nwrite(*,cfmt,advance='no') d9(81:88)\nwrite(*,nfmt,advance='no') d9(s1:s1+8)\nwrite(*,nfmt) d9(s2:s2+8)\n\nend subroutine\n", "target": "import java.awt.*;\nimport java.awt.event.*;\nimport static java.lang.Math.*;\nimport java.time.LocalTime;\nimport javax.swing.*;\n\nclass Clock extends JPanel {\n\n    final float degrees06 = (float) (PI / 30);\n    final float degrees30 = degrees06 * 5;\n    final float degrees90 = degrees30 * 3;\n\n    final int size = 590;\n    final int spacing = 40;\n    final int diameter = size - 2 * spacing;\n    final int cx = diameter / 2 + spacing;\n    final int cy = diameter / 2 + spacing;\n\n    public Clock() {\n        setPreferredSize(new Dimension(size, size));\n        setBackground(Color.white);\n\n        new Timer(1000, (ActionEvent e) -> {\n            repaint();\n        }).start();\n    }\n\n    @Override\n    public void paintComponent(Graphics gg) {\n        super.paintComponent(gg);\n        Graphics2D g = (Graphics2D) gg;\n        g.setRenderingHint(RenderingHints.KEY_ANTIALIASING,\n                RenderingHints.VALUE_ANTIALIAS_ON);\n\n        drawFace(g);\n\n        final LocalTime time  = LocalTime.now();\n        int hour = time.getHour();\n        int minute = time.getMinute();\n        int second = time.getSecond();\n\n        float angle = degrees90 - (degrees06 * second);\n        drawHand(g, angle, diameter / 2 - 30, Color.red);\n\n        float minsecs = (minute + second / 60.0F);\n        angle = degrees90 - (degrees06 * minsecs);\n        drawHand(g, angle, diameter / 3 + 10, Color.black);\n\n        float hourmins = (hour + minsecs / 60.0F);\n        angle = degrees90 - (degrees30 * hourmins);\n        drawHand(g, angle, diameter / 4 + 10, Color.black);\n    }\n\n    private void drawFace(Graphics2D g) {\n        g.setStroke(new BasicStroke(2));\n        g.setColor(Color.white);\n        g.fillOval(spacing, spacing, diameter, diameter);\n        g.setColor(Color.black);\n        g.drawOval(spacing, spacing, diameter, diameter);\n    }\n\n    private void drawHand(Graphics2D g, float angle, int radius, Color color) {\n        int x = cx + (int) (radius * cos(angle));\n        int y = cy - (int) (radius * sin(angle));\n        g.setColor(color);\n        g.drawLine(cx, cy, x, y);\n    }\n\n    public static void main(String[] args) {\n        SwingUtilities.invokeLater(() -> {\n            JFrame f = new JFrame();\n            f.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n            f.setTitle(\"Clock\");\n            f.setResizable(false);\n            f.add(new Clock(), BorderLayout.CENTER);\n            f.pack();\n            f.setLocationRelativeTo(null);\n            f.setVisible(true);\n        });\n    }\n}\n"}
{"id": 103300, "name": "Draw a clock", "source": "Translate Fortran to Python: \nprogram clock\nimplicit none\ninteger :: t(8)\ndo\n  call date_and_time(values=t)\n  call sleep(1)\n  call system('clear')\n  call digital_display(t(5),t(6),t(7))\nend do\nend program\n\nsubroutine digital_display(H,M,S)\n\ninteger :: H, M, S\n\ncharacter(len=*), parameter :: nfmt='(A8)', cfmt='(A6)'\ncharacter(len=88), parameter :: d1 = ' 00000     1     22222   33333      4   5555555  66666  7777777  88888   99999        '\ncharacter(len=88), parameter :: d2 = '0     0   11    2     2 3     3    44   5       6     6 7     7 8     8 9     9 \u00a0::   '\ncharacter(len=88), parameter :: d3 = '0    00  1 1          2       3   4 4   5       6             7 8     8 9     9 \u00a0::   '\ncharacter(len=88), parameter :: d4 = '0   0 0    1         2        3  4  4   5       6            7  8     8 9     9 \u00a0::   '\ncharacter(len=88), parameter :: d5 = '0  0  0    1        2      333  4444444 555555  666666      7    88888   999999       '\ncharacter(len=88), parameter :: d6 = '0 0   0    1       2          3     4         5 6     6    7    8     8       9 \u00a0::   '\ncharacter(len=88), parameter :: d7 = '00    0    1      2           3     4         5 6     6   7     8     8       9 \u00a0::   '\ncharacter(len=88), parameter :: d8 = '0     0    1     2      3     3     4   5     5 6     6  7      8     8 9     9 \u00a0::   '\ncharacter(len=88), parameter :: d9 = ' 00000  1111111 2222222  33333      4    55555   66666  7        88888   99999        '\ninteger :: h1, h2, m1, m2, s1, s2\nh1 = 1+8*floor(dble(H)/10.D0)\nh2 = 1+8*modulo(H,10)\nm1 = 1+8*floor(dble(M)/10.D0)\nm2 = 1+8*modulo(M,10)\ns1 = 1+8*floor(dble(S)/10.D0)\ns2 = 1+8*modulo(S,10)\n\nwrite(*,nfmt,advance='no') d1(h1:h1+8)\nwrite(*,nfmt,advance='no') d1(h2:h2+8)\nwrite(*,cfmt,advance='no') d1(81:88)\nwrite(*,nfmt,advance='no') d1(m1:m1+8)\nwrite(*,nfmt,advance='no') d1(m2:m2+8)\nwrite(*,cfmt,advance='no') d1(81:88)\nwrite(*,nfmt,advance='no') d1(s1:s1+8)\nwrite(*,nfmt) d1(s2:s2+8)\n\nwrite(*,nfmt,advance='no') d2(h1:h1+8)\nwrite(*,nfmt,advance='no') d2(h2:h2+8)\nwrite(*,cfmt,advance='no') d2(81:88)\nwrite(*,nfmt,advance='no') d2(m1:m1+8)\nwrite(*,nfmt,advance='no') d2(m2:m2+8)\nwrite(*,cfmt,advance='no') d2(81:88)\nwrite(*,nfmt,advance='no') d2(s1:s1+8)\nwrite(*,nfmt) d2(s2:s2+8)\n\nwrite(*,nfmt,advance='no') d3(h1:h1+8)\nwrite(*,nfmt,advance='no') d3(h2:h2+8)\nwrite(*,cfmt,advance='no') d3(81:88)\nwrite(*,nfmt,advance='no') d3(m1:m1+8)\nwrite(*,nfmt,advance='no') d3(m2:m2+8)\nwrite(*,cfmt,advance='no') d3(81:88)\nwrite(*,nfmt,advance='no') d3(s1:s1+8)\nwrite(*,nfmt) d3(s2:s2+8)\n\nwrite(*,nfmt,advance='no') d4(h1:h1+8)\nwrite(*,nfmt,advance='no') d4(h2:h2+8)\nwrite(*,cfmt,advance='no') d4(81:88)\nwrite(*,nfmt,advance='no') d4(m1:m1+8)\nwrite(*,nfmt,advance='no') d4(m2:m2+8)\nwrite(*,cfmt,advance='no') d4(81:88)\nwrite(*,nfmt,advance='no') d4(s1:s1+8)\nwrite(*,nfmt) d4(s2:s2+8)\n\nwrite(*,nfmt,advance='no') d5(h1:h1+8)\nwrite(*,nfmt,advance='no') d5(h2:h2+8)\nwrite(*,cfmt,advance='no') d5(81:88)\nwrite(*,nfmt,advance='no') d5(m1:m1+8)\nwrite(*,nfmt,advance='no') d5(m2:m2+8)\nwrite(*,cfmt,advance='no') d5(81:88)\nwrite(*,nfmt,advance='no') d5(s1:s1+8)\nwrite(*,nfmt) d5(s2:s2+8)\n\nwrite(*,nfmt,advance='no') d6(h1:h1+8)\nwrite(*,nfmt,advance='no') d6(h2:h2+8)\nwrite(*,cfmt,advance='no') d6(81:88)\nwrite(*,nfmt,advance='no') d6(m1:m1+8)\nwrite(*,nfmt,advance='no') d6(m2:m2+8)\nwrite(*,cfmt,advance='no') d6(81:88)\nwrite(*,nfmt,advance='no') d6(s1:s1+8)\nwrite(*,nfmt) d6(s2:s2+8)\n\nwrite(*,nfmt,advance='no') d7(h1:h1+8)\nwrite(*,nfmt,advance='no') d7(h2:h2+8)\nwrite(*,cfmt,advance='no') d7(81:88)\nwrite(*,nfmt,advance='no') d7(m1:m1+8)\nwrite(*,nfmt,advance='no') d7(m2:m2+8)\nwrite(*,cfmt,advance='no') d7(81:88)\nwrite(*,nfmt,advance='no') d7(s1:s1+8)\nwrite(*,nfmt) d7(s2:s2+8)\n\nwrite(*,nfmt,advance='no') d8(h1:h1+8)\nwrite(*,nfmt,advance='no') d8(h2:h2+8)\nwrite(*,cfmt,advance='no') d8(81:88)\nwrite(*,nfmt,advance='no') d8(m1:m1+8)\nwrite(*,nfmt,advance='no') d8(m2:m2+8)\nwrite(*,cfmt,advance='no') d8(81:88)\nwrite(*,nfmt,advance='no') d8(s1:s1+8)\nwrite(*,nfmt) d8(s2:s2+8)\n\nwrite(*,nfmt,advance='no') d9(h1:h1+8)\nwrite(*,nfmt,advance='no') d9(h2:h2+8)\nwrite(*,cfmt,advance='no') d9(81:88)\nwrite(*,nfmt,advance='no') d9(m1:m1+8)\nwrite(*,nfmt,advance='no') d9(m2:m2+8)\nwrite(*,cfmt,advance='no') d9(81:88)\nwrite(*,nfmt,advance='no') d9(s1:s1+8)\nwrite(*,nfmt) d9(s2:s2+8)\n\nend subroutine\n", "target": "last_sec = second()\n\ndef draw():\n    global last_sec\n    if last_sec != second():\n        draw_clock()\n        last_sec = second()\n\ndef draw_clock():\n    background(192)\n    translate(width / 2, height / 2)\n    s = second() * TWO_PI / 60.0\n    m = minute() * TWO_PI / 60.0\n    h = hour() * TWO_PI / 12.0\n    rotate(s)\n    strokeWeight(1)\n    line(0, 0, 0, -width * 0.5)\n    rotate(-s + m)\n    strokeWeight(2)\n    line(0, 0, 0, -width * 0.4)\n    rotate(-m + h)\n    strokeWeight(4)\n    line(0, 0, 0, -width * 0.2)\n"}
{"id": 103301, "name": "Draw a clock", "source": "Translate Fortran to Python: \nprogram clock\nimplicit none\ninteger :: t(8)\ndo\n  call date_and_time(values=t)\n  call sleep(1)\n  call system('clear')\n  call digital_display(t(5),t(6),t(7))\nend do\nend program\n\nsubroutine digital_display(H,M,S)\n\ninteger :: H, M, S\n\ncharacter(len=*), parameter :: nfmt='(A8)', cfmt='(A6)'\ncharacter(len=88), parameter :: d1 = ' 00000     1     22222   33333      4   5555555  66666  7777777  88888   99999        '\ncharacter(len=88), parameter :: d2 = '0     0   11    2     2 3     3    44   5       6     6 7     7 8     8 9     9 \u00a0::   '\ncharacter(len=88), parameter :: d3 = '0    00  1 1          2       3   4 4   5       6             7 8     8 9     9 \u00a0::   '\ncharacter(len=88), parameter :: d4 = '0   0 0    1         2        3  4  4   5       6            7  8     8 9     9 \u00a0::   '\ncharacter(len=88), parameter :: d5 = '0  0  0    1        2      333  4444444 555555  666666      7    88888   999999       '\ncharacter(len=88), parameter :: d6 = '0 0   0    1       2          3     4         5 6     6    7    8     8       9 \u00a0::   '\ncharacter(len=88), parameter :: d7 = '00    0    1      2           3     4         5 6     6   7     8     8       9 \u00a0::   '\ncharacter(len=88), parameter :: d8 = '0     0    1     2      3     3     4   5     5 6     6  7      8     8 9     9 \u00a0::   '\ncharacter(len=88), parameter :: d9 = ' 00000  1111111 2222222  33333      4    55555   66666  7        88888   99999        '\ninteger :: h1, h2, m1, m2, s1, s2\nh1 = 1+8*floor(dble(H)/10.D0)\nh2 = 1+8*modulo(H,10)\nm1 = 1+8*floor(dble(M)/10.D0)\nm2 = 1+8*modulo(M,10)\ns1 = 1+8*floor(dble(S)/10.D0)\ns2 = 1+8*modulo(S,10)\n\nwrite(*,nfmt,advance='no') d1(h1:h1+8)\nwrite(*,nfmt,advance='no') d1(h2:h2+8)\nwrite(*,cfmt,advance='no') d1(81:88)\nwrite(*,nfmt,advance='no') d1(m1:m1+8)\nwrite(*,nfmt,advance='no') d1(m2:m2+8)\nwrite(*,cfmt,advance='no') d1(81:88)\nwrite(*,nfmt,advance='no') d1(s1:s1+8)\nwrite(*,nfmt) d1(s2:s2+8)\n\nwrite(*,nfmt,advance='no') d2(h1:h1+8)\nwrite(*,nfmt,advance='no') d2(h2:h2+8)\nwrite(*,cfmt,advance='no') d2(81:88)\nwrite(*,nfmt,advance='no') d2(m1:m1+8)\nwrite(*,nfmt,advance='no') d2(m2:m2+8)\nwrite(*,cfmt,advance='no') d2(81:88)\nwrite(*,nfmt,advance='no') d2(s1:s1+8)\nwrite(*,nfmt) d2(s2:s2+8)\n\nwrite(*,nfmt,advance='no') d3(h1:h1+8)\nwrite(*,nfmt,advance='no') d3(h2:h2+8)\nwrite(*,cfmt,advance='no') d3(81:88)\nwrite(*,nfmt,advance='no') d3(m1:m1+8)\nwrite(*,nfmt,advance='no') d3(m2:m2+8)\nwrite(*,cfmt,advance='no') d3(81:88)\nwrite(*,nfmt,advance='no') d3(s1:s1+8)\nwrite(*,nfmt) d3(s2:s2+8)\n\nwrite(*,nfmt,advance='no') d4(h1:h1+8)\nwrite(*,nfmt,advance='no') d4(h2:h2+8)\nwrite(*,cfmt,advance='no') d4(81:88)\nwrite(*,nfmt,advance='no') d4(m1:m1+8)\nwrite(*,nfmt,advance='no') d4(m2:m2+8)\nwrite(*,cfmt,advance='no') d4(81:88)\nwrite(*,nfmt,advance='no') d4(s1:s1+8)\nwrite(*,nfmt) d4(s2:s2+8)\n\nwrite(*,nfmt,advance='no') d5(h1:h1+8)\nwrite(*,nfmt,advance='no') d5(h2:h2+8)\nwrite(*,cfmt,advance='no') d5(81:88)\nwrite(*,nfmt,advance='no') d5(m1:m1+8)\nwrite(*,nfmt,advance='no') d5(m2:m2+8)\nwrite(*,cfmt,advance='no') d5(81:88)\nwrite(*,nfmt,advance='no') d5(s1:s1+8)\nwrite(*,nfmt) d5(s2:s2+8)\n\nwrite(*,nfmt,advance='no') d6(h1:h1+8)\nwrite(*,nfmt,advance='no') d6(h2:h2+8)\nwrite(*,cfmt,advance='no') d6(81:88)\nwrite(*,nfmt,advance='no') d6(m1:m1+8)\nwrite(*,nfmt,advance='no') d6(m2:m2+8)\nwrite(*,cfmt,advance='no') d6(81:88)\nwrite(*,nfmt,advance='no') d6(s1:s1+8)\nwrite(*,nfmt) d6(s2:s2+8)\n\nwrite(*,nfmt,advance='no') d7(h1:h1+8)\nwrite(*,nfmt,advance='no') d7(h2:h2+8)\nwrite(*,cfmt,advance='no') d7(81:88)\nwrite(*,nfmt,advance='no') d7(m1:m1+8)\nwrite(*,nfmt,advance='no') d7(m2:m2+8)\nwrite(*,cfmt,advance='no') d7(81:88)\nwrite(*,nfmt,advance='no') d7(s1:s1+8)\nwrite(*,nfmt) d7(s2:s2+8)\n\nwrite(*,nfmt,advance='no') d8(h1:h1+8)\nwrite(*,nfmt,advance='no') d8(h2:h2+8)\nwrite(*,cfmt,advance='no') d8(81:88)\nwrite(*,nfmt,advance='no') d8(m1:m1+8)\nwrite(*,nfmt,advance='no') d8(m2:m2+8)\nwrite(*,cfmt,advance='no') d8(81:88)\nwrite(*,nfmt,advance='no') d8(s1:s1+8)\nwrite(*,nfmt) d8(s2:s2+8)\n\nwrite(*,nfmt,advance='no') d9(h1:h1+8)\nwrite(*,nfmt,advance='no') d9(h2:h2+8)\nwrite(*,cfmt,advance='no') d9(81:88)\nwrite(*,nfmt,advance='no') d9(m1:m1+8)\nwrite(*,nfmt,advance='no') d9(m2:m2+8)\nwrite(*,cfmt,advance='no') d9(81:88)\nwrite(*,nfmt,advance='no') d9(s1:s1+8)\nwrite(*,nfmt) d9(s2:s2+8)\n\nend subroutine\n", "target": "last_sec = second()\n\ndef draw():\n    global last_sec\n    if last_sec != second():\n        draw_clock()\n        last_sec = second()\n\ndef draw_clock():\n    background(192)\n    translate(width / 2, height / 2)\n    s = second() * TWO_PI / 60.0\n    m = minute() * TWO_PI / 60.0\n    h = hour() * TWO_PI / 12.0\n    rotate(s)\n    strokeWeight(1)\n    line(0, 0, 0, -width * 0.5)\n    rotate(-s + m)\n    strokeWeight(2)\n    line(0, 0, 0, -width * 0.4)\n    rotate(-m + h)\n    strokeWeight(4)\n    line(0, 0, 0, -width * 0.2)\n"}
{"id": 103584, "name": "Letter frequency", "source": "Translate Fortran to C#: -*- mode: compilation; default-directory: \"/tmp/\" -*-\nCompilation started at Sat May 18 18:09:46\n\na=./F && make $a && $a < configuration.file\nf95 -Wall -ffree-form F.F -o F\n          92          21          17          24          82          19          19          22          67           0           2          27          27          57          55          31           1          61          43          60          20           6           2           0          10           0\n\nCompilation finished at Sat May 18 18:09:46\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.IO;\nusing System.Linq;\n\nclass Program\n{\n    static SortedDictionary<TItem, int> GetFrequencies<TItem>(IEnumerable<TItem> items)\n    {\n        var dictionary = new SortedDictionary<TItem, int>();\n        foreach (var item in items)\n        {\n            if (dictionary.ContainsKey(item))\n            {\n                dictionary[item]++;\n            }\n            else\n            {\n                dictionary[item] = 1;\n            }\n        }\n        return dictionary;\n    }\n\n    static void Main(string[] arguments)\n    {\n        var file = arguments.FirstOrDefault();\n        if (File.Exists(file))\n        {\n            var text = File.ReadAllText(file);\n            foreach (var entry in GetFrequencies(text))\n            {\n                Console.WriteLine(\"{0}: {1}\", entry.Key, entry.Value);\n            }\n        }\n    }\n}\n"}
{"id": 103587, "name": "Letter frequency", "source": "Translate Fortran to Java: -*- mode: compilation; default-directory: \"/tmp/\" -*-\nCompilation started at Sat May 18 18:09:46\n\na=./F && make $a && $a < configuration.file\nf95 -Wall -ffree-form F.F -o F\n          92          21          17          24          82          19          19          22          67           0           2          27          27          57          55          31           1          61          43          60          20           6           2           0          10           0\n\nCompilation finished at Sat May 18 18:09:46\n", "target": "import java.io.BufferedReader;\nimport java.io.FileReader;\nimport java.io.IOException;\nimport java.util.Arrays;\n\npublic class LetterFreq {\n\tpublic static int[] countLetters(String filename) throws IOException{\n\t\tint[] freqs = new int[26];\n\t\tBufferedReader in = new BufferedReader(new FileReader(filename));\n\t\tString line;\n\t\twhile((line = in.readLine()) != null){\n\t\t\tline = line.toUpperCase();\n\t\t\tfor(char ch:line.toCharArray()){\n\t\t\t\tif(Character.isLetter(ch)){\n\t\t\t\t\tfreqs[ch - 'A']++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tin.close();\n\t\treturn freqs;\n\t}\n\t\n\tpublic static void main(String[] args) throws IOException{\n\t\tSystem.out.println(Arrays.toString(countLetters(\"filename.txt\")));\n\t}\n}\n"}
{"id": 103588, "name": "Letter frequency", "source": "Translate Fortran to Python: -*- mode: compilation; default-directory: \"/tmp/\" -*-\nCompilation started at Sat May 18 18:09:46\n\na=./F && make $a && $a < configuration.file\nf95 -Wall -ffree-form F.F -o F\n          92          21          17          24          82          19          19          22          67           0           2          27          27          57          55          31           1          61          43          60          20           6           2           0          10           0\n\nCompilation finished at Sat May 18 18:09:46\n", "target": "import collections, sys\n\ndef filecharcount(openfile):\n    return sorted(collections.Counter(c for l in openfile for c in l).items())\n\nf = open(sys.argv[1])\nprint(filecharcount(f))\n"}
{"id": 103982, "name": "Hello world_Graphical", "source": "Translate Fortran to C#: program hello\n    use windows\n    integer :: res\n    res = MessageBoxA(0, LOC(\"Hello, World\"), LOC(\"Window Title\"), MB_OK)\nend program\n", "target": "using System;\nusing System.Windows.Forms;\n\nclass Program {\n    static void Main(string[] args) {\n        Application.EnableVisualStyles(); \n        MessageBox.Show(\"Goodbye, World!\");\n    }\n}\n"}
{"id": 103985, "name": "Hello world_Graphical", "source": "Translate Fortran to Java: program hello\n    use windows\n    integer :: res\n    res = MessageBoxA(0, LOC(\"Hello, World\"), LOC(\"Window Title\"), MB_OK)\nend program\n", "target": "import javax.swing.*;\nimport java.awt.*;\n\npublic class OutputSwing {\n\n    public static void main(String[] args) {\n\n        SwingUtilities.invokeLater(new Runnable(){\n            public void run() {\n                JOptionPane.showMessageDialog (null, \"Goodbye, World!\"); \n                JFrame frame = new JFrame(\"Goodbye, World!\");            \n                JTextArea text = new JTextArea(\"Goodbye, World!\");       \n                JButton button = new JButton(\"Goodbye, World!\");         \n\n                frame.setLayout(new FlowLayout());\n                frame.add(button);\n                frame.add(text);\n                frame.pack();\n                frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n                frame.setVisible(true);\n            }\n        });\n    }\n}\n"}
{"id": 103986, "name": "Hello world_Graphical", "source": "Translate Fortran to Python: program hello\n    use windows\n    integer :: res\n    res = MessageBoxA(0, LOC(\"Hello, World\"), LOC(\"Window Title\"), MB_OK)\nend program\n", "target": "import bpy\n\n\nbpy.data.objects['Cube'].select_set(True)\n\n\nbpy.ops.object.delete(True)\n  \n\nbpy.data.curves.new(type=\"FONT\", name=\"Font Curve\").body = \"Hello World\"\nfont_obj = bpy.data.objects.new(name=\"Font Object\", object_data=bpy.data.curves[\"Font Curve\"])\nbpy.context.scene.collection.objects.link(font_obj)\n        \n\nbpy.context.scene.camera.location = (2.5,0.3,10)\n\n\nbpy.context.scene.camera.rotation_euler = (0,0,0)\n\n\narea = next(area for area in bpy.context.screen.areas if area.type == 'VIEW_3D')\narea.spaces[0].region_3d.view_perspective = 'CAMERA'\n"}
{"id": 104266, "name": "Search a list", "source": "Translate Fortran to C#: program main\n\n implicit none\n\n character(len=7),dimension(10) :: haystack = [  &\n  'Zig    ',&\n  'Zag    ',&\n  'Wally  ',&\n  'Ronald ',&\n  'Bush   ',&\n  'Krusty ',&\n  'Charlie',&\n  'Bush   ',&\n  'Boz    ',&\n  'Zag    ']\n\n call find_needle('Charlie')\n call find_needle('Bush')\n\n contains\n\n\tsubroutine find_needle(needle)\n\timplicit none\n\tcharacter(len=*),intent(in) :: needle\n\tinteger :: i\n\tdo i=1,size(haystack)\n\t\tif (needle==haystack(i)) then\n\t\t\twrite(*,'(A,I4)') trim(needle)//' found at index:',i\n\t\t\treturn\n\t\tend if\n\tend do\n\twrite(*,'(A)') 'Error: '//trim(needle)//' not found.'\n\tend subroutine find_needle\n\n end program main\n", "target": "using System;\nusing System.Collections.Generic;\n\nclass Program {\n    static void Main(string[] args) {\n        List<string> haystack = new List<string>() { \"Zig\", \"Zag\", \"Wally\", \"Ronald\", \"Bush\", \"Krusty\", \"Charlie\", \"Bush\", \"Bozo\" };\n\n        foreach (string needle in new string[] { \"Washington\", \"Bush\" }) {\n            int index = haystack.IndexOf(needle);\n            \n            if (index < 0) Console.WriteLine(\"{0} is not in haystack\",needle);                \n            else Console.WriteLine(\"{0} {1}\",index,needle);\n        }\n    }\n}\n"}
{"id": 104270, "name": "Search a list", "source": "Translate Fortran to Java: program main\n\n implicit none\n\n character(len=7),dimension(10) :: haystack = [  &\n  'Zig    ',&\n  'Zag    ',&\n  'Wally  ',&\n  'Ronald ',&\n  'Bush   ',&\n  'Krusty ',&\n  'Charlie',&\n  'Bush   ',&\n  'Boz    ',&\n  'Zag    ']\n\n call find_needle('Charlie')\n call find_needle('Bush')\n\n contains\n\n\tsubroutine find_needle(needle)\n\timplicit none\n\tcharacter(len=*),intent(in) :: needle\n\tinteger :: i\n\tdo i=1,size(haystack)\n\t\tif (needle==haystack(i)) then\n\t\t\twrite(*,'(A,I4)') trim(needle)//' found at index:',i\n\t\t\treturn\n\t\tend if\n\tend do\n\twrite(*,'(A)') 'Error: '//trim(needle)//' not found.'\n\tend subroutine find_needle\n\n end program main\n", "target": "import java.util.List;\nimport java.util.Arrays;\n\nList<String> haystack = Arrays.asList(\"Zig\",\"Zag\",\"Wally\",\"Ronald\",\"Bush\",\"Krusty\",\"Charlie\",\"Bush\",\"Bozo\");\n\nfor (String needle : new String[]{\"Washington\",\"Bush\"}) {\n    int index = haystack.indexOf(needle);\n    if (index < 0)\n        System.out.println(needle + \" is not in haystack\");\n    else\n        System.out.println(index + \" \" + needle);\n}\n"}
{"id": 104271, "name": "Search a list", "source": "Translate Fortran to Python: program main\n\n implicit none\n\n character(len=7),dimension(10) :: haystack = [  &\n  'Zig    ',&\n  'Zag    ',&\n  'Wally  ',&\n  'Ronald ',&\n  'Bush   ',&\n  'Krusty ',&\n  'Charlie',&\n  'Bush   ',&\n  'Boz    ',&\n  'Zag    ']\n\n call find_needle('Charlie')\n call find_needle('Bush')\n\n contains\n\n\tsubroutine find_needle(needle)\n\timplicit none\n\tcharacter(len=*),intent(in) :: needle\n\tinteger :: i\n\tdo i=1,size(haystack)\n\t\tif (needle==haystack(i)) then\n\t\t\twrite(*,'(A,I4)') trim(needle)//' found at index:',i\n\t\t\treturn\n\t\tend if\n\tend do\n\twrite(*,'(A)') 'Error: '//trim(needle)//' not found.'\n\tend subroutine find_needle\n\n end program main\n", "target": "haystack=[\"Zig\",\"Zag\",\"Wally\",\"Ronald\",\"Bush\",\"Krusty\",\"Charlie\",\"Bush\",\"Bozo\"]\n\nfor needle in (\"Washington\",\"Bush\"):\n  try:\n    print haystack.index(needle), needle\n  except ValueError, value_error:\n    print needle,\"is not in haystack\"\n"}
{"id": 104498, "name": "Element-wise operations", "source": "Translate Fortran to C#: program element_operations\n  implicit none\n\n  real(kind=4), dimension(3,3) :: a,b\n  integer :: i\n\n  a=reshape([(i,i=1,9)],shape(a))\n\n  print*,'addition'\n  b=a+a\n  call print_arr(b)\n\n  print*,'multiplication'\n  b=a*a\n  call print_arr(b)\n\n  print*,'division'\n  b=a/b\n  call print_arr(b)\n\n  print*,'exponentiation'\n  b=a**a\n  call print_arr(b)\n\n  print*,'trignometric'\n  b=cos(a)\n  call print_arr(b)\n\n  print*,'mod'\n  b=mod(int(a),3)\n  call print_arr(b)\n\n  print*,'element selection'\n  b=0\n  where(a>3) b=1\n  call print_arr(b)  \n\n  print*,'elemental functions can be applied to single values:'\n  print*,square(3.0)\n  print*,'or element wise to arrays:'\n  b=square(a)\n  call print_arr(b)\n\n\ncontains\n\n  elemental real function square(a)\n    real, intent(in) :: a\n    square=a*a\n  end function square\n\n  subroutine print_arr(arr)\n    real, intent(in) :: arr(:,:)\n    integer :: i\n    do i=1,size(arr,dim=2)\n       print*,arr(:,i)\n    end do\n  end subroutine print_arr\n  \n  \nend program element_operations\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\npublic static class ElementWiseOperations\n{\n    private static readonly Dictionary<string, Func<double, double, double>> operations =\n        new Dictionary<string, Func<double, double, double>> {\n            { \"add\", (a, b) => a + b },\n            { \"sub\", (a, b) => a - b },\n            { \"mul\", (a, b) => a * b },\n            { \"div\", (a, b) => a / b },\n            { \"pow\", (a, b) => Math.Pow(a, b) }\n        };\n\n    private static readonly Func<double, double, double> nothing = (a, b) => a;\n\n    public static double[,] DoOperation(this double[,] m, string name, double[,] other) =>\n        DoOperation(m, operations.TryGetValue(name, out var operation) ? operation : nothing, other);\n\n    public static double[,] DoOperation(this double[,] m, Func<double, double, double> operation, double[,] other) {\n        if (m == null || other == null) throw new ArgumentNullException();\n        int rows = m.GetLength(0), columns = m.GetLength(1);\n        if (rows != other.GetLength(0) || columns != other.GetLength(1)) {\n            throw new ArgumentException(\"Matrices have different dimensions.\");\n        }\n\n        double[,] result = new double[rows, columns];\n        for (int r = 0; r < rows; r++) {\n            for (int c = 0; c < columns; c++) {\n                result[r, c] = operation(m[r, c], other[r, c]);\n            }\n        }\n        return result;\n    }\n\n    public static double[,] DoOperation(this double[,] m, string name, double number) =>\n        DoOperation(m, operations.TryGetValue(name, out var operation) ? operation : nothing, number);\n\n    public static double[,] DoOperation(this double[,] m, Func<double, double, double> operation, double number) {\n        if (m == null) throw new ArgumentNullException();\n        int rows = m.GetLength(0), columns = m.GetLength(1);\n        double[,] result = new double[rows, columns];\n        for (int r = 0; r < rows; r++) {\n            for (int c = 0; c < columns; c++) {\n                result[r, c] = operation(m[r, c], number);\n            }\n        }\n        return result;\n    }\n\n    public static void Print(this double[,] m) {\n        if (m == null) throw new ArgumentNullException();\n        int rows = m.GetLength(0), columns = m.GetLength(1);\n        for (int r = 0; r < rows; r++) {\n            Console.WriteLine(\"[ \" + string.Join(\", \", Enumerable.Range(0, columns).Select(c => m[r, c])) + \" ]\");\n        }\n    }\n\n}\n\npublic class Program\n{\n    public static void Main() {\n        double[,] matrix = {\n            { 1, 2, 3, 4 },\n            { 5, 6, 7, 8 },\n            { 9, 10, 11, 12 }\n        };\n\n        double[,] tens = {\n            { 10, 10, 10, 10 },\n            { 20, 20, 20, 20 },\n            { 30, 30, 30, 30 }\n        };\n\n        matrix.Print();\n        WriteLine();\n\n        (matrix = matrix.DoOperation(\"add\", tens)).Print();\n        WriteLine();\n\n        matrix.DoOperation((a, b) => b - a, 100).Print();\n    }\n}\n"}
{"id": 104501, "name": "Element-wise operations", "source": "Translate Fortran to Java: program element_operations\n  implicit none\n\n  real(kind=4), dimension(3,3) :: a,b\n  integer :: i\n\n  a=reshape([(i,i=1,9)],shape(a))\n\n  print*,'addition'\n  b=a+a\n  call print_arr(b)\n\n  print*,'multiplication'\n  b=a*a\n  call print_arr(b)\n\n  print*,'division'\n  b=a/b\n  call print_arr(b)\n\n  print*,'exponentiation'\n  b=a**a\n  call print_arr(b)\n\n  print*,'trignometric'\n  b=cos(a)\n  call print_arr(b)\n\n  print*,'mod'\n  b=mod(int(a),3)\n  call print_arr(b)\n\n  print*,'element selection'\n  b=0\n  where(a>3) b=1\n  call print_arr(b)  \n\n  print*,'elemental functions can be applied to single values:'\n  print*,square(3.0)\n  print*,'or element wise to arrays:'\n  b=square(a)\n  call print_arr(b)\n\n\ncontains\n\n  elemental real function square(a)\n    real, intent(in) :: a\n    square=a*a\n  end function square\n\n  subroutine print_arr(arr)\n    real, intent(in) :: arr(:,:)\n    integer :: i\n    do i=1,size(arr,dim=2)\n       print*,arr(:,i)\n    end do\n  end subroutine print_arr\n  \n  \nend program element_operations\n", "target": "import java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.function.BiFunction;\nimport java.util.stream.Stream;\n\n@SuppressWarnings(\"serial\")\npublic class ElementWiseOp {\n\tstatic final Map<String, BiFunction<Double, Double, Double>> OPERATIONS = new HashMap<String, BiFunction<Double, Double, Double>>() {\n\t\t{\n\t\t\tput(\"add\", (a, b) -> a + b);\n\t\t\tput(\"sub\", (a, b) -> a - b);\n\t\t\tput(\"mul\", (a, b) -> a * b);\n\t\t\tput(\"div\", (a, b) -> a / b);\n\t\t\tput(\"pow\", (a, b) -> Math.pow(a, b));\n\t\t\tput(\"mod\", (a, b) -> a % b);\n\t\t}\n\t};\n\tpublic static Double[][] scalarOp(String op, Double[][] matr, Double scalar) {\n\t\tBiFunction<Double, Double, Double> operation = OPERATIONS.getOrDefault(op, (a, b) -> a);\n\t\tDouble[][] result = new Double[matr.length][matr[0].length];\n\t\tfor (int i = 0; i < matr.length; i++) {\n\t\t\tfor (int j = 0; j < matr[i].length; j++) {\n\t\t\t\tresult[i][j] = operation.apply(matr[i][j], scalar);\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n\tpublic static Double[][] matrOp(String op, Double[][] matr, Double[][] scalar) {\n\t\tBiFunction<Double, Double, Double> operation = OPERATIONS.getOrDefault(op, (a, b) -> a);\n\t\tDouble[][] result = new Double[matr.length][Stream.of(matr).mapToInt(a -> a.length).max().getAsInt()];\n\t\tfor (int i = 0; i < matr.length; i++) {\n\t\t\tfor (int j = 0; j < matr[i].length; j++) {\n\t\t\t\tresult[i][j] = operation.apply(matr[i][j], scalar[i % scalar.length][j\n\t\t\t\t\t\t% scalar[i % scalar.length].length]);\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n\tpublic static void printMatrix(Double[][] matr) {\n\t\tStream.of(matr).map(Arrays::toString).forEach(System.out::println);\n\t}\n\tpublic static void main(String[] args) {\n\t\tprintMatrix(scalarOp(\"mul\", new Double[][] {\n\t\t\t\t{ 1.0, 2.0, 3.0 }, \n\t\t\t\t{ 4.0, 5.0, 6.0 }, \n\t\t\t\t{ 7.0, 8.0, 9.0 }\n\t\t}, 3.0));\n\n\t\tprintMatrix(matrOp(\"div\", new Double[][] {\n\t\t\t\t{ 1.0, 2.0, 3.0 }, \n\t\t\t\t{ 4.0, 5.0, 6.0 }, \n\t\t\t\t{ 7.0, 8.0, 9.0 }\n\t\t}, new Double[][] {\n\t\t\t\t{ 1.0, 2.0}, \n\t\t\t\t{ 3.0, 4.0} \n\t\t}));\n\t}\n}\n"}
{"id": 104502, "name": "Element-wise operations", "source": "Translate Fortran to Python: program element_operations\n  implicit none\n\n  real(kind=4), dimension(3,3) :: a,b\n  integer :: i\n\n  a=reshape([(i,i=1,9)],shape(a))\n\n  print*,'addition'\n  b=a+a\n  call print_arr(b)\n\n  print*,'multiplication'\n  b=a*a\n  call print_arr(b)\n\n  print*,'division'\n  b=a/b\n  call print_arr(b)\n\n  print*,'exponentiation'\n  b=a**a\n  call print_arr(b)\n\n  print*,'trignometric'\n  b=cos(a)\n  call print_arr(b)\n\n  print*,'mod'\n  b=mod(int(a),3)\n  call print_arr(b)\n\n  print*,'element selection'\n  b=0\n  where(a>3) b=1\n  call print_arr(b)  \n\n  print*,'elemental functions can be applied to single values:'\n  print*,square(3.0)\n  print*,'or element wise to arrays:'\n  b=square(a)\n  call print_arr(b)\n\n\ncontains\n\n  elemental real function square(a)\n    real, intent(in) :: a\n    square=a*a\n  end function square\n\n  subroutine print_arr(arr)\n    real, intent(in) :: arr(:,:)\n    integer :: i\n    do i=1,size(arr,dim=2)\n       print*,arr(:,i)\n    end do\n  end subroutine print_arr\n  \n  \nend program element_operations\n", "target": ">>> import random\n>>> from operator import add, sub, mul, floordiv\n>>> from pprint import pprint as pp\n>>> \n>>> def ewise(matrix1, matrix2, op):\n\treturn [[op(e1,e2) for e1,e2 in zip(row1, row2)] for row1,row2 in zip(matrix1, matrix2)]\n\n>>> m,n = 3,4 \t\n>>> a0 = [[random.randint(1,9) for y in range(n)] for x in range(m)]\n>>> a1 = [[random.randint(1,9) for y in range(n)] for x in range(m)]\n>>> pp(a0); pp(a1)\n[[7, 8, 7, 4], [4, 9, 4, 1], [2, 3, 6, 4]]\n[[4, 5, 1, 6], [6, 8, 3, 4], [2, 2, 6, 3]]\n>>> pp(ewise(a0, a1, add))\n[[11, 13, 8, 10], [10, 17, 7, 5], [4, 5, 12, 7]]\n>>> pp(ewise(a0, a1, sub))\n[[3, 3, 6, -2], [-2, 1, 1, -3], [0, 1, 0, 1]]\n>>> pp(ewise(a0, a1, mul))\n[[28, 40, 7, 24], [24, 72, 12, 4], [4, 6, 36, 12]]\n>>> pp(ewise(a0, a1, floordiv))\n[[1, 1, 7, 0], [0, 1, 1, 0], [1, 1, 1, 1]]\n>>> pp(ewise(a0, a1, pow))\n[[2401, 32768, 7, 4096], [4096, 43046721, 64, 1], [4, 9, 46656, 64]]\n>>> pp(ewise(a0, a1, lambda x, y:2*x - y))\n[[10, 11, 13, 2], [2, 10, 5, -2], [2, 4, 6, 5]]\n>>> \n>>> def s_ewise(scalar1, matrix1, op):\n\treturn [[op(scalar1, e1) for e1 in row1] for row1 in matrix1]\n\n>>> scalar = 10\n>>> a0\n[[7, 8, 7, 4], [4, 9, 4, 1], [2, 3, 6, 4]]\n>>> for op in ( add, sub, mul, floordiv, pow, lambda x, y:2*x - y ):\n\tprint(\"%10s\u00a0:\" % op.__name__, s_ewise(scalar, a0, op))\n\n\t\n       add : [[17, 18, 17, 14], [14, 19, 14, 11], [12, 13, 16, 14]]\n       sub : [[3, 2, 3, 6], [6, 1, 6, 9], [8, 7, 4, 6]]\n       mul : [[70, 80, 70, 40], [40, 90, 40, 10], [20, 30, 60, 40]]\n  floordiv : [[1, 1, 1, 2], [2, 1, 2, 10], [5, 3, 1, 2]]\n       pow : [[10000000, 100000000, 10000000, 10000], [10000, 1000000000, 10000, 10], [100, 1000, 1000000, 10000]]\n  <lambda> : [[13, 12, 13, 16], [16, 11, 16, 19], [18, 17, 14, 16]]\n>>>\n"}
{"id": 104614, "name": "Terminal control_Cursor positioning", "source": "Translate Fortran to C#: program textposition\n    use kernel32\n    implicit none\n    integer(HANDLE) :: hConsole\n    integer(BOOL) :: q\n    \n    hConsole = GetStdHandle(STD_OUTPUT_HANDLE)\n    q = SetConsoleCursorPosition(hConsole, T_COORD(3, 6))\n    q = WriteConsole(hConsole, loc(\"Hello\"), 5, NULL, NULL)\nend program\n", "target": "static void Main(string[] args)\n{\n    Console.SetCursorPosition(3, 6);\n    Console.Write(\"Hello\");\n}\n"}
{"id": 104616, "name": "Terminal control_Cursor positioning", "source": "Translate Fortran to Python: program textposition\n    use kernel32\n    implicit none\n    integer(HANDLE) :: hConsole\n    integer(BOOL) :: q\n    \n    hConsole = GetStdHandle(STD_OUTPUT_HANDLE)\n    q = SetConsoleCursorPosition(hConsole, T_COORD(3, 6))\n    q = WriteConsole(hConsole, loc(\"Hello\"), 5, NULL, NULL)\nend program\n", "target": "print(\"\\033[6;3HHello\")\n"}
{"id": 104970, "name": "Amicable pairs", "source": "Translate Fortran to C#:       MODULE FACTORSTUFF\t\nConcocted by R.N.McLean, MMXV.\n       INTEGER LOTS,ILIMIT\t\t\n       PARAMETER (ILIMIT = 2147483647)\t\n       PARAMETER (LOTS = 22000)\t\n       INTEGER KNOWNSUM(LOTS)\t\t\n       CONTAINS\t\t\t\n        INTEGER FUNCTION SUMF(N)\t\n         INTEGER N\t\t\t\n         INTEGER S,F,F2,INC,BOOST\t\n          IF (N.LE.LOTS) THEN\t\t\n            SUMF = KNOWNSUM(N)\t\t\t\n           ELSE\t\t\t\nCould use SUMF in place of S, but some compilers have been confused by such usage.\n            S = 1\t\t\t\n            F = 1\t\t\t\n            INC = 1\t\t\t\n            IF (MOD(N,2) .EQ. 1) INC = 2\n    1       F = F + INC\t\t\t\n            F2 = F*F\t\t\t\t\n            IF (F2 .LT. N) THEN\t\t\t\n              IF (MOD(N,F) .EQ. 0) THEN\t\t\n                BOOST = F + N/F\t\t\t\n                IF (S .GT. ILIMIT - BOOST) GO TO 666\t\n                S = S + BOOST\t\t\t\n              END IF\t\t\t\t\n              GO TO 1\t\t\t\t\n            END IF\t\t\t\n            IF (F2 .EQ. N) THEN\t\n              IF (S .GT. ILIMIT - F) GO TO 666\t\n              S = S + F\t\t\t\n            END IF\t\t\t\n            SUMF = S\t\t\t\n          END IF\t\t\t\n         RETURN\t\t\t\nCannot calculate the sum, because it exceeds the integer limit.\n  666     SUMF = -666\t\t\n        END FUNCTION SUMF\t\n         SUBROUTINE PREPARESUMF\t\nConvert the Sieve of Eratoshenes to have each slot contain the sum of the proper divisors of its slot number.\nChanges to instead count the number of factors, or prime factors, etc. would be simple enough.\n         INTEGER F\t\t\n          KNOWNSUM(1) = 0\t\t\n          KNOWNSUM(2:LOTS) = 1\t\t\n          DO F = 2,LOTS/2\t\t\n            FOR ALL(I = F + F:LOTS:F) KNOWNSUM(I) = KNOWNSUM(I) + F\t\n          END DO\t\t\t\n        END SUBROUTINE PREPARESUMF\t\n      END MODULE FACTORSTUFF\t\n       PROGRAM AMICABLE\t\t\n       USE FACTORSTUFF\t\t\n       INTEGER I,N\t\t\n       INTEGER S1,S2\t\t\n        CALL PREPARESUMF\t\t\nc        WRITE (6,66) (I,KNOWNSUM(I), I = 1,48)\nc   66   FORMAT (10(I3,\":\",I5,\"|\"))\n        DO N = 2,20000\t\t\n          S1 = SUMF(N)\t\t\t\n          IF (S1 .EQ. N) THEN\t\t\n            WRITE (6,*) \"Perfect\n          ELSE IF (S1 .GT. N) THEN\t\n            S2 = SUMF(S1)\t\t\n            IF (S2.EQ.N) WRITE (6,*) \"Amicable\n          END IF\t\t\t\n        END DO\t\t\t\n      END\t\t\t\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\nnamespace RosettaCode.AmicablePairs\n{\n    internal static class Program {\n        private const int Limit = 20000;        \n\n        private static void Main()\n        {\n            foreach (var pair in GetPairs(Limit))\n            {\n                Console.WriteLine(\"{0} {1}\", pair.Item1, pair.Item2);\n            }\n        }\n\n        private static IEnumerable<Tuple<int, int>> GetPairs(int max)\n        {\n            List<int> divsums =\n                Enumerable.Range(0, max + 1).Select(i => ProperDivisors(i).Sum()).ToList();\n            for(int i=1; i<divsums.Count; i++) {\n                int sum = divsums[i];\n                if(i < sum && sum <= divsums.Count && divsums[sum] == i) {\n                    yield return new Tuple<int, int>(i, sum);\n                }\n            }\n        }\n\n        private static IEnumerable<int> ProperDivisors(int number)\n        {\n            return\n                Enumerable.Range(1, number / 2)\n                    .Where(divisor => number % divisor == 0);\n        }\n    }\n}\n"}
{"id": 104973, "name": "Amicable pairs", "source": "Translate Fortran to Java:       MODULE FACTORSTUFF\t\nConcocted by R.N.McLean, MMXV.\n       INTEGER LOTS,ILIMIT\t\t\n       PARAMETER (ILIMIT = 2147483647)\t\n       PARAMETER (LOTS = 22000)\t\n       INTEGER KNOWNSUM(LOTS)\t\t\n       CONTAINS\t\t\t\n        INTEGER FUNCTION SUMF(N)\t\n         INTEGER N\t\t\t\n         INTEGER S,F,F2,INC,BOOST\t\n          IF (N.LE.LOTS) THEN\t\t\n            SUMF = KNOWNSUM(N)\t\t\t\n           ELSE\t\t\t\nCould use SUMF in place of S, but some compilers have been confused by such usage.\n            S = 1\t\t\t\n            F = 1\t\t\t\n            INC = 1\t\t\t\n            IF (MOD(N,2) .EQ. 1) INC = 2\n    1       F = F + INC\t\t\t\n            F2 = F*F\t\t\t\t\n            IF (F2 .LT. N) THEN\t\t\t\n              IF (MOD(N,F) .EQ. 0) THEN\t\t\n                BOOST = F + N/F\t\t\t\n                IF (S .GT. ILIMIT - BOOST) GO TO 666\t\n                S = S + BOOST\t\t\t\n              END IF\t\t\t\t\n              GO TO 1\t\t\t\t\n            END IF\t\t\t\n            IF (F2 .EQ. N) THEN\t\n              IF (S .GT. ILIMIT - F) GO TO 666\t\n              S = S + F\t\t\t\n            END IF\t\t\t\n            SUMF = S\t\t\t\n          END IF\t\t\t\n         RETURN\t\t\t\nCannot calculate the sum, because it exceeds the integer limit.\n  666     SUMF = -666\t\t\n        END FUNCTION SUMF\t\n         SUBROUTINE PREPARESUMF\t\nConvert the Sieve of Eratoshenes to have each slot contain the sum of the proper divisors of its slot number.\nChanges to instead count the number of factors, or prime factors, etc. would be simple enough.\n         INTEGER F\t\t\n          KNOWNSUM(1) = 0\t\t\n          KNOWNSUM(2:LOTS) = 1\t\t\n          DO F = 2,LOTS/2\t\t\n            FOR ALL(I = F + F:LOTS:F) KNOWNSUM(I) = KNOWNSUM(I) + F\t\n          END DO\t\t\t\n        END SUBROUTINE PREPARESUMF\t\n      END MODULE FACTORSTUFF\t\n       PROGRAM AMICABLE\t\t\n       USE FACTORSTUFF\t\t\n       INTEGER I,N\t\t\n       INTEGER S1,S2\t\t\n        CALL PREPARESUMF\t\t\nc        WRITE (6,66) (I,KNOWNSUM(I), I = 1,48)\nc   66   FORMAT (10(I3,\":\",I5,\"|\"))\n        DO N = 2,20000\t\t\n          S1 = SUMF(N)\t\t\t\n          IF (S1 .EQ. N) THEN\t\t\n            WRITE (6,*) \"Perfect\n          ELSE IF (S1 .GT. N) THEN\t\n            S2 = SUMF(S1)\t\t\n            IF (S2.EQ.N) WRITE (6,*) \"Amicable\n          END IF\t\t\t\n        END DO\t\t\t\n      END\t\t\t\n", "target": "import java.util.Map;\nimport java.util.function.Function;\nimport java.util.stream.Collectors;\nimport java.util.stream.LongStream;\n\npublic class AmicablePairs {\n\n    public static void main(String[] args) {\n        int limit = 20_000;\n\n        Map<Long, Long> map = LongStream.rangeClosed(1, limit)\n                .parallel()\n                .boxed()\n                .collect(Collectors.toMap(Function.identity(), AmicablePairs::properDivsSum));\n\n        LongStream.rangeClosed(1, limit)\n                .forEach(n -> {\n                    long m = map.get(n);\n                    if (m > n && m <= limit && map.get(m) == n)\n                        System.out.printf(\"%s %s %n\", n, m);\n                });\n    }\n\n    public static Long properDivsSum(long n) {\n        return LongStream.rangeClosed(1, (n + 1) / 2).filter(i -> n % i == 0).sum();\n    }\n}\n"}
{"id": 104974, "name": "Amicable pairs", "source": "Translate Fortran to Python:       MODULE FACTORSTUFF\t\nConcocted by R.N.McLean, MMXV.\n       INTEGER LOTS,ILIMIT\t\t\n       PARAMETER (ILIMIT = 2147483647)\t\n       PARAMETER (LOTS = 22000)\t\n       INTEGER KNOWNSUM(LOTS)\t\t\n       CONTAINS\t\t\t\n        INTEGER FUNCTION SUMF(N)\t\n         INTEGER N\t\t\t\n         INTEGER S,F,F2,INC,BOOST\t\n          IF (N.LE.LOTS) THEN\t\t\n            SUMF = KNOWNSUM(N)\t\t\t\n           ELSE\t\t\t\nCould use SUMF in place of S, but some compilers have been confused by such usage.\n            S = 1\t\t\t\n            F = 1\t\t\t\n            INC = 1\t\t\t\n            IF (MOD(N,2) .EQ. 1) INC = 2\n    1       F = F + INC\t\t\t\n            F2 = F*F\t\t\t\t\n            IF (F2 .LT. N) THEN\t\t\t\n              IF (MOD(N,F) .EQ. 0) THEN\t\t\n                BOOST = F + N/F\t\t\t\n                IF (S .GT. ILIMIT - BOOST) GO TO 666\t\n                S = S + BOOST\t\t\t\n              END IF\t\t\t\t\n              GO TO 1\t\t\t\t\n            END IF\t\t\t\n            IF (F2 .EQ. N) THEN\t\n              IF (S .GT. ILIMIT - F) GO TO 666\t\n              S = S + F\t\t\t\n            END IF\t\t\t\n            SUMF = S\t\t\t\n          END IF\t\t\t\n         RETURN\t\t\t\nCannot calculate the sum, because it exceeds the integer limit.\n  666     SUMF = -666\t\t\n        END FUNCTION SUMF\t\n         SUBROUTINE PREPARESUMF\t\nConvert the Sieve of Eratoshenes to have each slot contain the sum of the proper divisors of its slot number.\nChanges to instead count the number of factors, or prime factors, etc. would be simple enough.\n         INTEGER F\t\t\n          KNOWNSUM(1) = 0\t\t\n          KNOWNSUM(2:LOTS) = 1\t\t\n          DO F = 2,LOTS/2\t\t\n            FOR ALL(I = F + F:LOTS:F) KNOWNSUM(I) = KNOWNSUM(I) + F\t\n          END DO\t\t\t\n        END SUBROUTINE PREPARESUMF\t\n      END MODULE FACTORSTUFF\t\n       PROGRAM AMICABLE\t\t\n       USE FACTORSTUFF\t\t\n       INTEGER I,N\t\t\n       INTEGER S1,S2\t\t\n        CALL PREPARESUMF\t\t\nc        WRITE (6,66) (I,KNOWNSUM(I), I = 1,48)\nc   66   FORMAT (10(I3,\":\",I5,\"|\"))\n        DO N = 2,20000\t\t\n          S1 = SUMF(N)\t\t\t\n          IF (S1 .EQ. N) THEN\t\t\n            WRITE (6,*) \"Perfect\n          ELSE IF (S1 .GT. N) THEN\t\n            S2 = SUMF(S1)\t\t\n            IF (S2.EQ.N) WRITE (6,*) \"Amicable\n          END IF\t\t\t\n        END DO\t\t\t\n      END\t\t\t\n", "target": "from proper_divisors import proper_divs\n\ndef amicable(rangemax=20000):\n    n2divsum = {n: sum(proper_divs(n)) for n in range(1, rangemax + 1)}\n    for num, divsum in n2divsum.items():\n        if num < divsum and divsum <= rangemax and n2divsum[divsum] == num:\n            yield num, divsum\n\nif __name__ == '__main__':\n    for num, divsum in amicable():\n        print('Amicable pair: %i and %i With proper divisors:\\n    %r\\n    %r'\n              % (num, divsum, sorted(proper_divs(num)), sorted(proper_divs(divsum))))\n"}
{"id": 105355, "name": "Knapsack problem_Unbounded", "source": "Translate Fortran to C#: PROGRAM KNAPSACK\n\n  IMPLICIT NONE\n \n  REAL :: totalWeight, totalVolume\n  INTEGER :: maxPanacea, maxIchor, maxGold, maxValue = 0\n  INTEGER :: i, j, k\n  INTEGER :: n(3)  \n\n  TYPE Bounty\n    INTEGER :: value\n    REAL :: weight\n    REAL :: volume\n  END TYPE Bounty\n\n  TYPE(Bounty) :: panacea, ichor, gold, sack, current\n\n  panacea = Bounty(3000, 0.3, 0.025)\n  ichor   = Bounty(1800, 0.2, 0.015)\n  gold    = Bounty(2500, 2.0, 0.002)\n  sack    = Bounty(0, 25.0, 0.25)\n\n  maxPanacea = MIN(sack%weight / panacea%weight, sack%volume / panacea%volume)\n  maxIchor = MIN(sack%weight / ichor%weight, sack%volume / ichor%volume)\n  maxGold = MIN(sack%weight / gold%weight, sack%volume / gold%volume)\n  \n  DO i = 0, maxPanacea\n     DO j = 0, maxIchor\n        Do k = 0, maxGold\n           current%value = k * gold%value + j * ichor%value + i * panacea%value\n           current%weight = k * gold%weight + j * ichor%weight + i * panacea%weight\n           current%volume = k * gold%volume + j * ichor%volume + i * panacea%volume       \n           IF (current%weight > sack%weight .OR. current%volume > sack%volume) CYCLE\n           IF (current%value > maxValue) THEN\n              maxValue = current%value\n              totalWeight = current%weight\n              totalVolume = current%volume\n              n(1) = i ; n(2) = j ; n(3) = k\n           END IF\n        END DO  \n     END DO\n  END DO\n\n  WRITE(*, \"(A,I0)\") \"Maximum value achievable is \", maxValue\n  WRITE(*, \"(3(A,I0),A)\") \"This is achieved by carrying \", n(1), \" panacea, \", n(2), \" ichor and \", n(3), \" gold items\"\n  WRITE(*, \"(A,F4.1,A,F5.3)\") \"The weight to carry is \", totalWeight, \" and the volume used is \", totalVolume\n \nEND PROGRAM KNAPSACK\n", "target": "\nusing System;\nclass Program\n{\n    static void Main()\n    {\n        uint[] r = items1();\n        Console.WriteLine(r[0] + \" v  \" + r[1] + \" a  \" + r[2] + \" b\");  \n        var sw = System.Diagnostics.Stopwatch.StartNew();\n        for (int i = 1000; i > 0; i--) items1();\n        Console.Write(sw.Elapsed); Console.Read();\n    }\n\n    static uint[] items0()  \n    {\n        uint v, v0 = 0, a, b, c, a0 = 0, b0 = 0, c0 = 0;\n        for (a = 0; a <= 10; a++)\n            for (b = 0; a * 5 + b * 3 <= 50; b++)\n                for (c = 0; a * 25 + b * 15 + c * 2 <= 250 && a * 3 + b * 2 + c * 20 <= 250; c++)\n                    if (v0 < (v = a * 30 + b * 18 + c * 25))\n                    {\n                        v0 = v; a0 = a; b0 = b; c0 = c;\n                        \n                    }\n        return new uint[] { a0, b0, c0 };\n    }\n\n    static uint[] items1()  \n    {\n        uint v, v0 = 0, a, b, c, a0 = 0, b0 = 0, c0 = 0, c1 = 0;\n        for (a = 0; a <= 10; a++)\n            for (b = 0; a * 5 + b * 3 <= 50; b++)\n            {\n                c = (250 - a * 25 - b * 15) / 2;\n                if ((c1 = (250 - a * 3 - b * 2) / 20) < c) c = c1;\n                if (v0 < (v = a * 30 + b * 18 + c * 25))\n                { v0 = v; a0 = a; b0 = b; c0 = c; }\n            }\n        return new uint[] { a0, b0, c0 };\n    }\n}\n"}
{"id": 105357, "name": "Knapsack problem_Unbounded", "source": "Translate Fortran to Java: PROGRAM KNAPSACK\n\n  IMPLICIT NONE\n \n  REAL :: totalWeight, totalVolume\n  INTEGER :: maxPanacea, maxIchor, maxGold, maxValue = 0\n  INTEGER :: i, j, k\n  INTEGER :: n(3)  \n\n  TYPE Bounty\n    INTEGER :: value\n    REAL :: weight\n    REAL :: volume\n  END TYPE Bounty\n\n  TYPE(Bounty) :: panacea, ichor, gold, sack, current\n\n  panacea = Bounty(3000, 0.3, 0.025)\n  ichor   = Bounty(1800, 0.2, 0.015)\n  gold    = Bounty(2500, 2.0, 0.002)\n  sack    = Bounty(0, 25.0, 0.25)\n\n  maxPanacea = MIN(sack%weight / panacea%weight, sack%volume / panacea%volume)\n  maxIchor = MIN(sack%weight / ichor%weight, sack%volume / ichor%volume)\n  maxGold = MIN(sack%weight / gold%weight, sack%volume / gold%volume)\n  \n  DO i = 0, maxPanacea\n     DO j = 0, maxIchor\n        Do k = 0, maxGold\n           current%value = k * gold%value + j * ichor%value + i * panacea%value\n           current%weight = k * gold%weight + j * ichor%weight + i * panacea%weight\n           current%volume = k * gold%volume + j * ichor%volume + i * panacea%volume       \n           IF (current%weight > sack%weight .OR. current%volume > sack%volume) CYCLE\n           IF (current%value > maxValue) THEN\n              maxValue = current%value\n              totalWeight = current%weight\n              totalVolume = current%volume\n              n(1) = i ; n(2) = j ; n(3) = k\n           END IF\n        END DO  \n     END DO\n  END DO\n\n  WRITE(*, \"(A,I0)\") \"Maximum value achievable is \", maxValue\n  WRITE(*, \"(3(A,I0),A)\") \"This is achieved by carrying \", n(1), \" panacea, \", n(2), \" ichor and \", n(3), \" gold items\"\n  WRITE(*, \"(A,F4.1,A,F5.3)\") \"The weight to carry is \", totalWeight, \" and the volume used is \", totalVolume\n \nEND PROGRAM KNAPSACK\n", "target": "package hu.pj.alg;\n\nimport hu.pj.obj.Item;\nimport java.text.*;\n\npublic class UnboundedKnapsack {\n\n    protected Item []  items = {\n                               new Item(\"panacea\", 3000,  0.3, 0.025),\n                               new Item(\"ichor\"  , 1800,  0.2, 0.015),\n                               new Item(\"gold\"   , 2500,  2.0, 0.002)\n                               };\n    protected final int    n = items.length; \n    protected Item      sack = new Item(\"sack\"   ,    0, 25.0, 0.250);\n    protected Item      best = new Item(\"best\"   ,    0,  0.0, 0.000);\n    protected int  []  maxIt = new int [n];  \n    protected int  []    iIt = new int [n];  \n    protected int  [] bestAm = new int [n];  \n\n    public UnboundedKnapsack() {\n        \n        for (int i = 0; i < n; i++) {\n            maxIt [i] = Math.min(\n                           (int)(sack.getWeight() / items[i].getWeight()),\n                           (int)(sack.getVolume() / items[i].getVolume())\n                        );\n        } \n\n        \n        calcWithRecursion(0);\n\n        \n        NumberFormat nf = NumberFormat.getInstance();\n        System.out.println(\"Maximum value achievable is: \" + best.getValue());\n        System.out.print(\"This is achieved by carrying (one solution): \");\n        for (int i = 0; i < n; i++) {\n            System.out.print(bestAm[i] + \" \" + items[i].getName() + \", \");\n        }\n        System.out.println();\n        System.out.println(\"The weight to carry is: \" + nf.format(best.getWeight()) +\n                           \"   and the volume used is: \" + nf.format(best.getVolume())\n                          );\n\n    }\n\n    \n    \n    public void calcWithRecursion(int item) {\n        for (int i = 0; i <= maxIt[item]; i++) {\n            iIt[item] = i;\n            if (item < n-1) {\n                calcWithRecursion(item+1);\n            } else {\n                int    currVal = 0;   \n                double currWei = 0.0; \n                double currVol = 0.0; \n                for (int j = 0; j < n; j++) {\n                    currVal += iIt[j] * items[j].getValue();\n                    currWei += iIt[j] * items[j].getWeight();\n                    currVol += iIt[j] * items[j].getVolume();\n                }\n\n                if (currVal > best.getValue()\n                    &&\n                    currWei <= sack.getWeight()\n                    &&\n                    currVol <= sack.getVolume()\n                )\n                {\n                    best.setValue (currVal);\n                    best.setWeight(currWei);\n                    best.setVolume(currVol);\n                    for (int j = 0; j < n; j++) bestAm[j] = iIt[j];\n                } \n            } \n        } \n    } \n\n    \n    public static void main(String[] args) {\n        new UnboundedKnapsack();\n    } \n\n} \n"}
{"id": 105507, "name": "Variables", "source": "Translate Fortran to C#:  program test\n implicit none\n\n integer :: i  \n integer,dimension(10) :: ivec \n real :: r \n real,dimension(10) :: rvec \n character(len=:),allocatable :: char1, char2  \n\n\n\n\n i = 1\n r = 3.14\n\n\n ivec = 1 \n ivec(1:5) = 2\n\n rvec(1:9) = 0.0\n rvec(10) = 1.0\n\n\n char1 = 'hello world\n char2 = char1   \n char2(1:1) = 'H'  \n\nend program test\n", "target": "int j;\n"}
{"id": 105511, "name": "Variables", "source": "Translate Fortran to Java:  program test\n implicit none\n\n integer :: i  \n integer,dimension(10) :: ivec \n real :: r \n real,dimension(10) :: rvec \n character(len=:),allocatable :: char1, char2  \n\n\n\n\n i = 1\n r = 3.14\n\n\n ivec = 1 \n ivec(1:5) = 2\n\n rvec(1:9) = 0.0\n rvec(10) = 1.0\n\n\n char1 = 'hello world\n char2 = char1   \n char2(1:1) = 'H'  \n\nend program test\n", "target": "int a;\ndouble b;\nAClassNameHere c;\n"}
{"id": 105512, "name": "Variables", "source": "Translate Fortran to Python:  program test\n implicit none\n\n integer :: i  \n integer,dimension(10) :: ivec \n real :: r \n real,dimension(10) :: rvec \n character(len=:),allocatable :: char1, char2  \n\n\n\n\n i = 1\n r = 3.14\n\n\n ivec = 1 \n ivec(1:5) = 2\n\n rvec(1:9) = 0.0\n rvec(10) = 1.0\n\n\n char1 = 'hello world\n char2 = char1   \n char2(1:1) = 'H'  \n\nend program test\n", "target": "\nexample1 = 3\nexample2 = 3.0\nexample3 = True\nexample4 = \"hello\"\n\n\nexample1 = \"goodbye\"\n"}
{"id": 105714, "name": "Sort three variables", "source": "Translate Fortran to C#:       TYPE(MONGREL)\n       INTEGER TYPEIS\n       INTEGER VI\n       REAL VF\n       CHARACTER*(enuff) VC\n       ...etc...\n      END TYPE MONGREL\n      TYPE (MONGREL) DOG\n", "target": "using System;\npublic class Program\n{\n    public static void Main()\n    {\n        (int x, int y, int z) = (77444, -12, 0);\n\n        \n        if (x > y) (x, y) = (y, x);\n        if (x > z) (x, z) = (z, x);\n        if (y > z) (y, z) = (z, y);\n        Console.WriteLine((x, y, z));\n\n        var (a, b, c) = (\n            \"lions, tigers, and\",\n            \"bears, oh my!\",\n            \"(from the 'Wizard of OZ')\");\n        \n        \n        Sort(ref a, ref b, ref c);\n        Console.WriteLine((a, b, c));\n    }\n    \n    public static void Sort<T>(ref T a, ref T b, ref T c)\n        where T : IComparable<T>\n    {\n        if (a.CompareTo(b) > 0) (a, b) = (b, a);\n        if (a.CompareTo(c) > 0) (a, c) = (c, a);\n        if (b.CompareTo(c) > 0) (b, c) = (c, b);\n    }\n}\n"}
{"id": 105717, "name": "Sort three variables", "source": "Translate Fortran to Java:       TYPE(MONGREL)\n       INTEGER TYPEIS\n       INTEGER VI\n       REAL VF\n       CHARACTER*(enuff) VC\n       ...etc...\n      END TYPE MONGREL\n      TYPE (MONGREL) DOG\n", "target": "import java.util.Comparator;\nimport java.util.stream.Stream;\n\nclass Box {\n    public int weightKg;\n\n    Box(final int weightKg) {\n        this.weightKg = weightKg;\n    }\n}\n\npublic class Sort3Vars {\n    public static void main(String... args) {\n        int iA = 21;\n        int iB = 11;\n        int iC = 82;\n        int[] sortedInt = Stream.of(iA, iB, iC).sorted().mapToInt(Integer::intValue).toArray();\n        iA = sortedInt[0];\n        iB = sortedInt[1];\n        iC = sortedInt[2];\n        System.out.printf(\"Sorted values: %d %d %d%n\", iA, iB, iC);\n\n        String sA = \"s21\";\n        String sB = \"s11\";\n        String sC = \"s82\";\n        Object[] sortedStr = Stream.of(sA, sB, sC).sorted().toArray();\n        sA = (String) sortedStr[0];\n        sB = (String) sortedStr[1];\n        sC = (String) sortedStr[2];\n        System.out.printf(\"Sorted values: %s %s %s%n\", sA, sB, sC);\n\n        Box bA = new Box(200);\n        Box bB = new Box(12);\n        Box bC = new Box(143);\n        \n        Object[] sortedBox = Stream.of(bA, bB, bC).sorted(Comparator.comparingInt(a -> a.weightKg)).toArray();\n        bA = (Box) sortedBox[0];\n        bB = (Box) sortedBox[1];\n        bC = (Box) sortedBox[2];\n        System.out.printf(\"Sorted Boxes: %dKg %dKg %dKg%n\", bA.weightKg, bB.weightKg, bC.weightKg);\n    }\n}\n"}
{"id": 105718, "name": "Sort three variables", "source": "Translate Fortran to Python:       TYPE(MONGREL)\n       INTEGER TYPEIS\n       INTEGER VI\n       REAL VF\n       CHARACTER*(enuff) VC\n       ...etc...\n      END TYPE MONGREL\n      TYPE (MONGREL) DOG\n", "target": "\na= raw_input(\"Enter values one by one ..\\n1.\").strip()\nb=raw_input(\"2.\").strip()\nc=raw_input(\"3.\").strip()\nif a>b :\n   a,b = b,a \nif a>c:\n   a,c = c,a \nif b>c:\n   b,c = c,b \nprint(str(a)+\" \"+str(b)+\" \"+str(c))\n"}
{"id": 105894, "name": "Sorting algorithms_Radix sort", "source": "Translate Fortran to C#:       SUBROUTINE VARRADIX(A , Siz)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n      IMPLICIT NONE\n\n\n\n      INTEGER , PARAMETER  ::  BASE = 256 \n\n\n\n      INTEGER  ::  Siz\n      INTEGER , DIMENSION(Siz)  ::  A\n\n\n\n      INTEGER , ALLOCATABLE , DIMENSION(:)  ::  b\n      INTEGER , ALLOCATABLE , DIMENSION(:)  ::  c\n      INTEGER  ::  exps\n      INTEGER  ::  maxs\n\n      ALLOCATE(b(Siz))\n      ALLOCATE(c(BASE))\n \n      exps = 1\n      maxs = MAXVAL(A)\n      DO WHILE ( (maxs/exps)>0 )\n         CALL XXCOUNTING_SORT(A , Siz , exps , BASE , b , c)\n         exps = exps*BASE\n      END DO\n      deallocate(C)\n      deallocate(B)\n      RETURN\n      CONTAINS\n\n\n\n      SUBROUTINE XXCOUNTING_SORT(A , Siz , Exps , Base , B , C)\n      IMPLICIT NONE\n\n\n\n\n      INTEGER  ::  Base\n      INTEGER  ::  Exps\n      INTEGER  ::  Siz    \n      INTEGER , DIMENSION(0:)  ::  A\n      INTEGER , DIMENSION(0:)  ::  B\n      INTEGER , DIMENSION(0:)  ::  C\n      INTENT (IN) Base , Exps , Siz\n      INTENT (INOUT) A , B , C\n\n\n\n      INTEGER  ::  i\n      INTEGER  ::  k\n\n      C = 0                             \n      B = 0\n\n      DO i = 0 , Siz - 1 , 1\n         k = MOD((A(i)/Exps) , Base)    \n         C(k) = C(k) + 1\n      END DO\n\n      DO i = 1 , Base - 1 , 1\n         C(i) = C(i) + C(i - 1)         \n      END DO\n\n      DO i = Siz - 1 , 0 , -1\n         k = MOD(A(i)/Exps , Base)      \n         B(C(k) - 1) = A(i)\n         C(k) = C(k) - 1\n      END DO\n\n      DO i = 0 , Siz - 1 , 1              \n         A(i) = B(i)\n      END DO\n      RETURN\n      END SUBROUTINE XXCOUNTING_SORT\n    END SUBROUTINE Varradix\n\n\n\n      MODULE LEASTSIG\n      IMPLICIT NONE\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n      CONTAINS\n \n\n      SUBROUTINE LSDRADIXSORT(A , N)\n      IMPLICIT NONE\n\n\n\n      INTEGER  ::  N\n      INTEGER , target, DIMENSION(0:N - 1)  ::  A           \n      INTENT (IN) N\n      INTENT (INOUT) A\n\n\n\n      INTEGER , DIMENSION(0:9)  ::  counts\n      INTEGER  ::  digitplace\n      INTEGER  ::  i\n      INTEGER  ::  j\n      INTEGER  ::  largestnum\n      INTEGER, DIMENSION(0:N - 1)  ::  results \n\n      digitplace = 1                                        \n      largestnum = MAXVAL(A)\n \n      DO WHILE ( (largestnum/digitplace)>0 )\n         counts = 0                                         \n        DO i = 0 , N - 1 , 1\n            J = (A(i)/digitplace)\n            J = MODULO(j , 10) \n            counts(j) = counts(j) + 1\n        END DO\n\n\n\n         DO i = 1 , 9 , 1\n            counts(i) = counts(i) + counts(i - 1)       \n         END DO\n\n         DO i = N - 1 , 0 , -1                          \n            j = (A(i)/digitplace)\n            j = MODULO(j, 10)\n            results(counts(j) - 1) = A(i)               \n            counts(j) = counts(j) - 1\n         END DO\n\n         DO i = 0 , N - 1 , 1                           \n           A(i) = results(i)\n         END DO\n\n         digitplace = digitplace*10\n      END DO                                             \n      RETURN\n      END SUBROUTINE LSDRADIXSORT\n      END MODULE LEASTSIG\n\n\n\n\n\n\n      SUBROUTINE FASTLSDRAD(Dataset , Scratch , Dsize)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n      IMPLICIT NONE\n\n\n\n      INTEGER  ::  Dsize\n      INTEGER , TARGET , DIMENSION(0:Dsize - 1)  ::  Scratch    \n      INTEGER , TARGET , DIMENSION(0:Dsize - 1)  ::  Dataset\n      INTENT (IN) Dsize\n      INTENT (INOUT) Scratch , Dataset\n\n\n\n      INTEGER , POINTER , DIMENSION(:)  ::  a                   \n      INTEGER , POINTER , DIMENSION(:)  ::  b                   \n      INTEGER  ::  i\n      INTEGER  ::  j\n      INTEGER  ::  m\n      INTEGER , DIMENSION(0:255,0:3)  ::  stats_table\n      INTEGER  ::  n\n      LOGICAL  ::  swap\n      INTEGER  ::  u\n      \n\n      stats_table = 0                                           \n      swap = .TRUE.                                             \n\n      a => Dataset\n      b => Scratch\n\n      DO i = 0 , Dsize - 1 , 1                                  \n         u = a(i)\n         DO j = 0 , 3 , 1\n            n = IAND(u , z'FF')\n            u = SHIFTR(u , 8)\n            stats_table(n,j) = stats_table(n,j) + 1\n         END DO\n      END DO\n\n      DO i = 0 , 3 , 1                                          \n         m = 0\n         DO j = 0 , 255 , 1\n            n = stats_table(j , i)\n            stats_table(j , i) = m\n            m = m + n\n         END DO\n      END DO\n\n      DO j = 0 , 3 , 1                                          \n         DO i = 0 , Dsize - 1 , 1\n            u = a(i)\n            m = IAND(SHIFTR(u,SHIFTL(j,3)) , z'FF')             \n            b(stats_table(m,j)) = u                             \n            stats_table(m,j) = stats_table(m,j) + 1\n         END DO\n\n\n\n         IF( swap )THEN\n            a => Scratch                                        \n            b => Dataset                                        \n         ELSE\n            a => Dataset\n            b => Scratch\n         END IF\n         swap = .NOT.swap                                       \n      END DO\n \n      RETURN\n      END SUBROUTINE FASTLSDRAD\n\n\n\n*=======================================================================\n* RSORT - sort a list of integers by the Radix Sort algorithm\n* Public domain.  This program may be used by any person for any purpose.\n* Origin:  Herman Hollerith, 1887\n*\n*___Name____Type______In/Out____Description_____________________________\n*   IX(N)   Integer   Both      Array to be sorted in increasing order\n*   IW(N)   Integer   Neither   Workspace\n*   N       Integer   In        Length of array\n*\n* ASSUMPTIONS:  Bits in an INTEGER is an even number.\n*               Integers are represented by twos complement.\n*\n* NOTE THAT:  Radix sorting has an advantage when the input is known \n*             to be less than some value, so that only a few bits need \n*             to be compared.  This routine looks at all the bits, \n*             and is thus slower than Quicksort.\n*=======================================================================\n      SUBROUTINE RSORT (IX, IW, N)      \n       IMPLICIT NONE\n       INTEGER IX, IW, N\n       DIMENSION IX(N), IW(N)\n\n       INTEGER I,                        \n     $         ILIM,                     \n     $         J,                        \n     $         P1OLD, P0OLD, P1, P0,     \n     $         SWAP\n       LOGICAL ODD                       \n\n*      IF (N < 2) RETURN      \n*\n        ILIM = Bit_size(i)    \n*=======================================================================\n* Alternate between putting data into IW and into IX\n*=======================================================================\n       P1 = N+1\n       P0 = N                \n       ODD = .FALSE.\n       DO I = 0, ILIM-2\n         P1OLD = P1\n         P0OLD = P0         \n         P1 = N+1\n         P0 = 0                 \n\n         IF (ODD) THEN\n           DO J = 1, P0OLD, +1             \n             IF ( BTEST(IW(J), I) ) THEN\n               P1 = P1 - 1\n               IX(P1) = IW(J)\n             ELSE\n               P0 = P0 + 1\n               IX(P0) = IW(J)\n             END IF\n           END DO\n           DO J = N, P1OLD, -1             \n             IF ( BTEST(IW(J), I) ) THEN\n               P1 = P1 - 1\n               IX(P1) = IW(J)\n             ELSE\n               P0 = P0 + 1\n              IX(P0) = IW(J)\n             END IF\n           END DO\n          \n         ELSE \n           DO J = 1, P0OLD, +1             \n             IF ( BTEST(IX(J), I) ) THEN\n               P1 = P1 - 1\n               IW(P1) = IX(J)\n              ELSE\n               P0 = P0 + 1\n               IW(P0) = IX(J)\n             END IF\n           END DO\n           DO J = N, P1OLD, -1            \n             IF ( BTEST(IX(J), I) ) THEN\n               P1 = P1 - 1\n               IW(P1) = IX(J)\n             ELSE\n               P0 = P0 + 1\n               IW(P0) = IX(J)\n             END IF\n          END DO\n         END IF  \n        \n         ODD = .NOT. ODD\n       END DO  \n\n*=======================================================================\n*        the sign bit\n*=======================================================================\n       P1OLD = P1\n       P0OLD = P0\n       P1 = N+1\n       P0 = 0 \n\n*          if sign bit is set, send to the zero end\n       DO J = 1, P0OLD, +1\n         IF ( BTEST(IW(J), ILIM-1) ) THEN \n           P0 = P0 + 1\n           IX(P0) = IW(J)\n         ELSE\n           P1 = P1 - 1\n           IX(P1) = IW(J)\n         END IF\n       END DO          \n       DO J = N, P1OLD, -1\n         IF ( BTEST(IW(J), ILIM-1) ) THEN\n           P0 = P0 + 1\n           IX(P0) = IW(J)\n         ELSE\n           P1 = P1 - 1\n           IX(P1) = IW(J)\n         END IF\n       END DO\n          \n*=======================================================================\n*       Reverse the order of the greater value partition\n*=======================================================================\n       P1OLD = P1\n       DO J = N, (P1OLD+N)/2+1, -1\n         SWAP = IX(J)\n         IX(J) = IX(P1)\n         IX(P1) = SWAP\n         P1 = P1 + 1\n       END DO\n       RETURN\n      END \n\n\n***********************************************************************\n*         test program\n***********************************************************************\n      PROGRAM t_sort\n       IMPLICIT NONE\n       INTEGER I, N\n       PARAMETER (N = 11)\n       INTEGER IX(N), IW(N)\n       LOGICAL OK\n       \n       DATA IX / 2, 24, 45, 0, 66, 75, 170, -802, -90, 1066, 666 /\n       \n       PRINT *, 'before: ', IX\n       CALL RSORT (IX, IW, N)\n       PRINT *, 'after: ', IX\n       \n*              compare\n       OK = .TRUE.\n       DO I = 1, N-1\n         IF (IX(I) > IX(I+1)) OK = .FALSE.\n       END DO\n       IF (OK) THEN\n         PRINT *, 't_sort: successful test'\n       ELSE\n         PRINT *, 't_sort: failure\n       END IF\n      END \n", "target": "using System;\n\nnamespace RadixSort\n{\n    class Program\n    {\n        static void Sort(int[] old)\n        {\n            int i, j;\n            int[] tmp = new int[old.Length];\n            for (int shift = 31; shift > -1; --shift)\n            {\n                j = 0;\n                for (i = 0; i < old.Length; ++i)\n                {\n                    bool move = (old[i] << shift) >= 0;\n                    if (shift == 0 ? !move : move)  \n                        old[i-j] = old[i];\n                    else                            \n                        tmp[j++] = old[i];\n                }\n                Array.Copy(tmp, 0, old, old.Length-j, j);\n            }\n        }\n        static void Main(string[] args)\n        {\n            int[] old = new int[] { 2, 5, 1, -3, 4 };\n            Console.WriteLine(string.Join(\", \", old));\n            Sort(old);\n            Console.WriteLine(string.Join(\", \", old));\n            Console.Read();\n        }\n    }\n}\n"}
{"id": 105898, "name": "Sorting algorithms_Radix sort", "source": "Translate Fortran to Java:       SUBROUTINE VARRADIX(A , Siz)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n      IMPLICIT NONE\n\n\n\n      INTEGER , PARAMETER  ::  BASE = 256 \n\n\n\n      INTEGER  ::  Siz\n      INTEGER , DIMENSION(Siz)  ::  A\n\n\n\n      INTEGER , ALLOCATABLE , DIMENSION(:)  ::  b\n      INTEGER , ALLOCATABLE , DIMENSION(:)  ::  c\n      INTEGER  ::  exps\n      INTEGER  ::  maxs\n\n      ALLOCATE(b(Siz))\n      ALLOCATE(c(BASE))\n \n      exps = 1\n      maxs = MAXVAL(A)\n      DO WHILE ( (maxs/exps)>0 )\n         CALL XXCOUNTING_SORT(A , Siz , exps , BASE , b , c)\n         exps = exps*BASE\n      END DO\n      deallocate(C)\n      deallocate(B)\n      RETURN\n      CONTAINS\n\n\n\n      SUBROUTINE XXCOUNTING_SORT(A , Siz , Exps , Base , B , C)\n      IMPLICIT NONE\n\n\n\n\n      INTEGER  ::  Base\n      INTEGER  ::  Exps\n      INTEGER  ::  Siz    \n      INTEGER , DIMENSION(0:)  ::  A\n      INTEGER , DIMENSION(0:)  ::  B\n      INTEGER , DIMENSION(0:)  ::  C\n      INTENT (IN) Base , Exps , Siz\n      INTENT (INOUT) A , B , C\n\n\n\n      INTEGER  ::  i\n      INTEGER  ::  k\n\n      C = 0                             \n      B = 0\n\n      DO i = 0 , Siz - 1 , 1\n         k = MOD((A(i)/Exps) , Base)    \n         C(k) = C(k) + 1\n      END DO\n\n      DO i = 1 , Base - 1 , 1\n         C(i) = C(i) + C(i - 1)         \n      END DO\n\n      DO i = Siz - 1 , 0 , -1\n         k = MOD(A(i)/Exps , Base)      \n         B(C(k) - 1) = A(i)\n         C(k) = C(k) - 1\n      END DO\n\n      DO i = 0 , Siz - 1 , 1              \n         A(i) = B(i)\n      END DO\n      RETURN\n      END SUBROUTINE XXCOUNTING_SORT\n    END SUBROUTINE Varradix\n\n\n\n      MODULE LEASTSIG\n      IMPLICIT NONE\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n      CONTAINS\n \n\n      SUBROUTINE LSDRADIXSORT(A , N)\n      IMPLICIT NONE\n\n\n\n      INTEGER  ::  N\n      INTEGER , target, DIMENSION(0:N - 1)  ::  A           \n      INTENT (IN) N\n      INTENT (INOUT) A\n\n\n\n      INTEGER , DIMENSION(0:9)  ::  counts\n      INTEGER  ::  digitplace\n      INTEGER  ::  i\n      INTEGER  ::  j\n      INTEGER  ::  largestnum\n      INTEGER, DIMENSION(0:N - 1)  ::  results \n\n      digitplace = 1                                        \n      largestnum = MAXVAL(A)\n \n      DO WHILE ( (largestnum/digitplace)>0 )\n         counts = 0                                         \n        DO i = 0 , N - 1 , 1\n            J = (A(i)/digitplace)\n            J = MODULO(j , 10) \n            counts(j) = counts(j) + 1\n        END DO\n\n\n\n         DO i = 1 , 9 , 1\n            counts(i) = counts(i) + counts(i - 1)       \n         END DO\n\n         DO i = N - 1 , 0 , -1                          \n            j = (A(i)/digitplace)\n            j = MODULO(j, 10)\n            results(counts(j) - 1) = A(i)               \n            counts(j) = counts(j) - 1\n         END DO\n\n         DO i = 0 , N - 1 , 1                           \n           A(i) = results(i)\n         END DO\n\n         digitplace = digitplace*10\n      END DO                                             \n      RETURN\n      END SUBROUTINE LSDRADIXSORT\n      END MODULE LEASTSIG\n\n\n\n\n\n\n      SUBROUTINE FASTLSDRAD(Dataset , Scratch , Dsize)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n      IMPLICIT NONE\n\n\n\n      INTEGER  ::  Dsize\n      INTEGER , TARGET , DIMENSION(0:Dsize - 1)  ::  Scratch    \n      INTEGER , TARGET , DIMENSION(0:Dsize - 1)  ::  Dataset\n      INTENT (IN) Dsize\n      INTENT (INOUT) Scratch , Dataset\n\n\n\n      INTEGER , POINTER , DIMENSION(:)  ::  a                   \n      INTEGER , POINTER , DIMENSION(:)  ::  b                   \n      INTEGER  ::  i\n      INTEGER  ::  j\n      INTEGER  ::  m\n      INTEGER , DIMENSION(0:255,0:3)  ::  stats_table\n      INTEGER  ::  n\n      LOGICAL  ::  swap\n      INTEGER  ::  u\n      \n\n      stats_table = 0                                           \n      swap = .TRUE.                                             \n\n      a => Dataset\n      b => Scratch\n\n      DO i = 0 , Dsize - 1 , 1                                  \n         u = a(i)\n         DO j = 0 , 3 , 1\n            n = IAND(u , z'FF')\n            u = SHIFTR(u , 8)\n            stats_table(n,j) = stats_table(n,j) + 1\n         END DO\n      END DO\n\n      DO i = 0 , 3 , 1                                          \n         m = 0\n         DO j = 0 , 255 , 1\n            n = stats_table(j , i)\n            stats_table(j , i) = m\n            m = m + n\n         END DO\n      END DO\n\n      DO j = 0 , 3 , 1                                          \n         DO i = 0 , Dsize - 1 , 1\n            u = a(i)\n            m = IAND(SHIFTR(u,SHIFTL(j,3)) , z'FF')             \n            b(stats_table(m,j)) = u                             \n            stats_table(m,j) = stats_table(m,j) + 1\n         END DO\n\n\n\n         IF( swap )THEN\n            a => Scratch                                        \n            b => Dataset                                        \n         ELSE\n            a => Dataset\n            b => Scratch\n         END IF\n         swap = .NOT.swap                                       \n      END DO\n \n      RETURN\n      END SUBROUTINE FASTLSDRAD\n\n\n\n*=======================================================================\n* RSORT - sort a list of integers by the Radix Sort algorithm\n* Public domain.  This program may be used by any person for any purpose.\n* Origin:  Herman Hollerith, 1887\n*\n*___Name____Type______In/Out____Description_____________________________\n*   IX(N)   Integer   Both      Array to be sorted in increasing order\n*   IW(N)   Integer   Neither   Workspace\n*   N       Integer   In        Length of array\n*\n* ASSUMPTIONS:  Bits in an INTEGER is an even number.\n*               Integers are represented by twos complement.\n*\n* NOTE THAT:  Radix sorting has an advantage when the input is known \n*             to be less than some value, so that only a few bits need \n*             to be compared.  This routine looks at all the bits, \n*             and is thus slower than Quicksort.\n*=======================================================================\n      SUBROUTINE RSORT (IX, IW, N)      \n       IMPLICIT NONE\n       INTEGER IX, IW, N\n       DIMENSION IX(N), IW(N)\n\n       INTEGER I,                        \n     $         ILIM,                     \n     $         J,                        \n     $         P1OLD, P0OLD, P1, P0,     \n     $         SWAP\n       LOGICAL ODD                       \n\n*      IF (N < 2) RETURN      \n*\n        ILIM = Bit_size(i)    \n*=======================================================================\n* Alternate between putting data into IW and into IX\n*=======================================================================\n       P1 = N+1\n       P0 = N                \n       ODD = .FALSE.\n       DO I = 0, ILIM-2\n         P1OLD = P1\n         P0OLD = P0         \n         P1 = N+1\n         P0 = 0                 \n\n         IF (ODD) THEN\n           DO J = 1, P0OLD, +1             \n             IF ( BTEST(IW(J), I) ) THEN\n               P1 = P1 - 1\n               IX(P1) = IW(J)\n             ELSE\n               P0 = P0 + 1\n               IX(P0) = IW(J)\n             END IF\n           END DO\n           DO J = N, P1OLD, -1             \n             IF ( BTEST(IW(J), I) ) THEN\n               P1 = P1 - 1\n               IX(P1) = IW(J)\n             ELSE\n               P0 = P0 + 1\n              IX(P0) = IW(J)\n             END IF\n           END DO\n          \n         ELSE \n           DO J = 1, P0OLD, +1             \n             IF ( BTEST(IX(J), I) ) THEN\n               P1 = P1 - 1\n               IW(P1) = IX(J)\n              ELSE\n               P0 = P0 + 1\n               IW(P0) = IX(J)\n             END IF\n           END DO\n           DO J = N, P1OLD, -1            \n             IF ( BTEST(IX(J), I) ) THEN\n               P1 = P1 - 1\n               IW(P1) = IX(J)\n             ELSE\n               P0 = P0 + 1\n               IW(P0) = IX(J)\n             END IF\n          END DO\n         END IF  \n        \n         ODD = .NOT. ODD\n       END DO  \n\n*=======================================================================\n*        the sign bit\n*=======================================================================\n       P1OLD = P1\n       P0OLD = P0\n       P1 = N+1\n       P0 = 0 \n\n*          if sign bit is set, send to the zero end\n       DO J = 1, P0OLD, +1\n         IF ( BTEST(IW(J), ILIM-1) ) THEN \n           P0 = P0 + 1\n           IX(P0) = IW(J)\n         ELSE\n           P1 = P1 - 1\n           IX(P1) = IW(J)\n         END IF\n       END DO          \n       DO J = N, P1OLD, -1\n         IF ( BTEST(IW(J), ILIM-1) ) THEN\n           P0 = P0 + 1\n           IX(P0) = IW(J)\n         ELSE\n           P1 = P1 - 1\n           IX(P1) = IW(J)\n         END IF\n       END DO\n          \n*=======================================================================\n*       Reverse the order of the greater value partition\n*=======================================================================\n       P1OLD = P1\n       DO J = N, (P1OLD+N)/2+1, -1\n         SWAP = IX(J)\n         IX(J) = IX(P1)\n         IX(P1) = SWAP\n         P1 = P1 + 1\n       END DO\n       RETURN\n      END \n\n\n***********************************************************************\n*         test program\n***********************************************************************\n      PROGRAM t_sort\n       IMPLICIT NONE\n       INTEGER I, N\n       PARAMETER (N = 11)\n       INTEGER IX(N), IW(N)\n       LOGICAL OK\n       \n       DATA IX / 2, 24, 45, 0, 66, 75, 170, -802, -90, 1066, 666 /\n       \n       PRINT *, 'before: ', IX\n       CALL RSORT (IX, IW, N)\n       PRINT *, 'after: ', IX\n       \n*              compare\n       OK = .TRUE.\n       DO I = 1, N-1\n         IF (IX(I) > IX(I+1)) OK = .FALSE.\n       END DO\n       IF (OK) THEN\n         PRINT *, 't_sort: successful test'\n       ELSE\n         PRINT *, 't_sort: failure\n       END IF\n      END \n", "target": "public static int[] sort(int[] old) {\n    \n    for (int shift = Integer.SIZE - 1; shift > -1; shift--) {\n        \n        int[] tmp = new int[old.length];\n        \n        int j = 0;\n\n        \n        for (int i = 0; i < old.length; i++) {\n            \n            boolean move = old[i] << shift >= 0;\n\n            \n            if (shift == 0 ? !move : move) {\n                tmp[j] = old[i];\n                j++;\n            } else {\n                \n                old[i - j] = old[i];\n            }\n        }\n\n        \n        for (int i = j; i < tmp.length; i++) {\n            tmp[i] = old[i - j];\n        }\n\n        \n        old = tmp;\n    }\n\n    return old;\n}\n"}
{"id": 105899, "name": "Sorting algorithms_Radix sort", "source": "Translate Fortran to Python:       SUBROUTINE VARRADIX(A , Siz)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n      IMPLICIT NONE\n\n\n\n      INTEGER , PARAMETER  ::  BASE = 256 \n\n\n\n      INTEGER  ::  Siz\n      INTEGER , DIMENSION(Siz)  ::  A\n\n\n\n      INTEGER , ALLOCATABLE , DIMENSION(:)  ::  b\n      INTEGER , ALLOCATABLE , DIMENSION(:)  ::  c\n      INTEGER  ::  exps\n      INTEGER  ::  maxs\n\n      ALLOCATE(b(Siz))\n      ALLOCATE(c(BASE))\n \n      exps = 1\n      maxs = MAXVAL(A)\n      DO WHILE ( (maxs/exps)>0 )\n         CALL XXCOUNTING_SORT(A , Siz , exps , BASE , b , c)\n         exps = exps*BASE\n      END DO\n      deallocate(C)\n      deallocate(B)\n      RETURN\n      CONTAINS\n\n\n\n      SUBROUTINE XXCOUNTING_SORT(A , Siz , Exps , Base , B , C)\n      IMPLICIT NONE\n\n\n\n\n      INTEGER  ::  Base\n      INTEGER  ::  Exps\n      INTEGER  ::  Siz    \n      INTEGER , DIMENSION(0:)  ::  A\n      INTEGER , DIMENSION(0:)  ::  B\n      INTEGER , DIMENSION(0:)  ::  C\n      INTENT (IN) Base , Exps , Siz\n      INTENT (INOUT) A , B , C\n\n\n\n      INTEGER  ::  i\n      INTEGER  ::  k\n\n      C = 0                             \n      B = 0\n\n      DO i = 0 , Siz - 1 , 1\n         k = MOD((A(i)/Exps) , Base)    \n         C(k) = C(k) + 1\n      END DO\n\n      DO i = 1 , Base - 1 , 1\n         C(i) = C(i) + C(i - 1)         \n      END DO\n\n      DO i = Siz - 1 , 0 , -1\n         k = MOD(A(i)/Exps , Base)      \n         B(C(k) - 1) = A(i)\n         C(k) = C(k) - 1\n      END DO\n\n      DO i = 0 , Siz - 1 , 1              \n         A(i) = B(i)\n      END DO\n      RETURN\n      END SUBROUTINE XXCOUNTING_SORT\n    END SUBROUTINE Varradix\n\n\n\n      MODULE LEASTSIG\n      IMPLICIT NONE\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n      CONTAINS\n \n\n      SUBROUTINE LSDRADIXSORT(A , N)\n      IMPLICIT NONE\n\n\n\n      INTEGER  ::  N\n      INTEGER , target, DIMENSION(0:N - 1)  ::  A           \n      INTENT (IN) N\n      INTENT (INOUT) A\n\n\n\n      INTEGER , DIMENSION(0:9)  ::  counts\n      INTEGER  ::  digitplace\n      INTEGER  ::  i\n      INTEGER  ::  j\n      INTEGER  ::  largestnum\n      INTEGER, DIMENSION(0:N - 1)  ::  results \n\n      digitplace = 1                                        \n      largestnum = MAXVAL(A)\n \n      DO WHILE ( (largestnum/digitplace)>0 )\n         counts = 0                                         \n        DO i = 0 , N - 1 , 1\n            J = (A(i)/digitplace)\n            J = MODULO(j , 10) \n            counts(j) = counts(j) + 1\n        END DO\n\n\n\n         DO i = 1 , 9 , 1\n            counts(i) = counts(i) + counts(i - 1)       \n         END DO\n\n         DO i = N - 1 , 0 , -1                          \n            j = (A(i)/digitplace)\n            j = MODULO(j, 10)\n            results(counts(j) - 1) = A(i)               \n            counts(j) = counts(j) - 1\n         END DO\n\n         DO i = 0 , N - 1 , 1                           \n           A(i) = results(i)\n         END DO\n\n         digitplace = digitplace*10\n      END DO                                             \n      RETURN\n      END SUBROUTINE LSDRADIXSORT\n      END MODULE LEASTSIG\n\n\n\n\n\n\n      SUBROUTINE FASTLSDRAD(Dataset , Scratch , Dsize)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n      IMPLICIT NONE\n\n\n\n      INTEGER  ::  Dsize\n      INTEGER , TARGET , DIMENSION(0:Dsize - 1)  ::  Scratch    \n      INTEGER , TARGET , DIMENSION(0:Dsize - 1)  ::  Dataset\n      INTENT (IN) Dsize\n      INTENT (INOUT) Scratch , Dataset\n\n\n\n      INTEGER , POINTER , DIMENSION(:)  ::  a                   \n      INTEGER , POINTER , DIMENSION(:)  ::  b                   \n      INTEGER  ::  i\n      INTEGER  ::  j\n      INTEGER  ::  m\n      INTEGER , DIMENSION(0:255,0:3)  ::  stats_table\n      INTEGER  ::  n\n      LOGICAL  ::  swap\n      INTEGER  ::  u\n      \n\n      stats_table = 0                                           \n      swap = .TRUE.                                             \n\n      a => Dataset\n      b => Scratch\n\n      DO i = 0 , Dsize - 1 , 1                                  \n         u = a(i)\n         DO j = 0 , 3 , 1\n            n = IAND(u , z'FF')\n            u = SHIFTR(u , 8)\n            stats_table(n,j) = stats_table(n,j) + 1\n         END DO\n      END DO\n\n      DO i = 0 , 3 , 1                                          \n         m = 0\n         DO j = 0 , 255 , 1\n            n = stats_table(j , i)\n            stats_table(j , i) = m\n            m = m + n\n         END DO\n      END DO\n\n      DO j = 0 , 3 , 1                                          \n         DO i = 0 , Dsize - 1 , 1\n            u = a(i)\n            m = IAND(SHIFTR(u,SHIFTL(j,3)) , z'FF')             \n            b(stats_table(m,j)) = u                             \n            stats_table(m,j) = stats_table(m,j) + 1\n         END DO\n\n\n\n         IF( swap )THEN\n            a => Scratch                                        \n            b => Dataset                                        \n         ELSE\n            a => Dataset\n            b => Scratch\n         END IF\n         swap = .NOT.swap                                       \n      END DO\n \n      RETURN\n      END SUBROUTINE FASTLSDRAD\n\n\n\n*=======================================================================\n* RSORT - sort a list of integers by the Radix Sort algorithm\n* Public domain.  This program may be used by any person for any purpose.\n* Origin:  Herman Hollerith, 1887\n*\n*___Name____Type______In/Out____Description_____________________________\n*   IX(N)   Integer   Both      Array to be sorted in increasing order\n*   IW(N)   Integer   Neither   Workspace\n*   N       Integer   In        Length of array\n*\n* ASSUMPTIONS:  Bits in an INTEGER is an even number.\n*               Integers are represented by twos complement.\n*\n* NOTE THAT:  Radix sorting has an advantage when the input is known \n*             to be less than some value, so that only a few bits need \n*             to be compared.  This routine looks at all the bits, \n*             and is thus slower than Quicksort.\n*=======================================================================\n      SUBROUTINE RSORT (IX, IW, N)      \n       IMPLICIT NONE\n       INTEGER IX, IW, N\n       DIMENSION IX(N), IW(N)\n\n       INTEGER I,                        \n     $         ILIM,                     \n     $         J,                        \n     $         P1OLD, P0OLD, P1, P0,     \n     $         SWAP\n       LOGICAL ODD                       \n\n*      IF (N < 2) RETURN      \n*\n        ILIM = Bit_size(i)    \n*=======================================================================\n* Alternate between putting data into IW and into IX\n*=======================================================================\n       P1 = N+1\n       P0 = N                \n       ODD = .FALSE.\n       DO I = 0, ILIM-2\n         P1OLD = P1\n         P0OLD = P0         \n         P1 = N+1\n         P0 = 0                 \n\n         IF (ODD) THEN\n           DO J = 1, P0OLD, +1             \n             IF ( BTEST(IW(J), I) ) THEN\n               P1 = P1 - 1\n               IX(P1) = IW(J)\n             ELSE\n               P0 = P0 + 1\n               IX(P0) = IW(J)\n             END IF\n           END DO\n           DO J = N, P1OLD, -1             \n             IF ( BTEST(IW(J), I) ) THEN\n               P1 = P1 - 1\n               IX(P1) = IW(J)\n             ELSE\n               P0 = P0 + 1\n              IX(P0) = IW(J)\n             END IF\n           END DO\n          \n         ELSE \n           DO J = 1, P0OLD, +1             \n             IF ( BTEST(IX(J), I) ) THEN\n               P1 = P1 - 1\n               IW(P1) = IX(J)\n              ELSE\n               P0 = P0 + 1\n               IW(P0) = IX(J)\n             END IF\n           END DO\n           DO J = N, P1OLD, -1            \n             IF ( BTEST(IX(J), I) ) THEN\n               P1 = P1 - 1\n               IW(P1) = IX(J)\n             ELSE\n               P0 = P0 + 1\n               IW(P0) = IX(J)\n             END IF\n          END DO\n         END IF  \n        \n         ODD = .NOT. ODD\n       END DO  \n\n*=======================================================================\n*        the sign bit\n*=======================================================================\n       P1OLD = P1\n       P0OLD = P0\n       P1 = N+1\n       P0 = 0 \n\n*          if sign bit is set, send to the zero end\n       DO J = 1, P0OLD, +1\n         IF ( BTEST(IW(J), ILIM-1) ) THEN \n           P0 = P0 + 1\n           IX(P0) = IW(J)\n         ELSE\n           P1 = P1 - 1\n           IX(P1) = IW(J)\n         END IF\n       END DO          \n       DO J = N, P1OLD, -1\n         IF ( BTEST(IW(J), ILIM-1) ) THEN\n           P0 = P0 + 1\n           IX(P0) = IW(J)\n         ELSE\n           P1 = P1 - 1\n           IX(P1) = IW(J)\n         END IF\n       END DO\n          \n*=======================================================================\n*       Reverse the order of the greater value partition\n*=======================================================================\n       P1OLD = P1\n       DO J = N, (P1OLD+N)/2+1, -1\n         SWAP = IX(J)\n         IX(J) = IX(P1)\n         IX(P1) = SWAP\n         P1 = P1 + 1\n       END DO\n       RETURN\n      END \n\n\n***********************************************************************\n*         test program\n***********************************************************************\n      PROGRAM t_sort\n       IMPLICIT NONE\n       INTEGER I, N\n       PARAMETER (N = 11)\n       INTEGER IX(N), IW(N)\n       LOGICAL OK\n       \n       DATA IX / 2, 24, 45, 0, 66, 75, 170, -802, -90, 1066, 666 /\n       \n       PRINT *, 'before: ', IX\n       CALL RSORT (IX, IW, N)\n       PRINT *, 'after: ', IX\n       \n*              compare\n       OK = .TRUE.\n       DO I = 1, N-1\n         IF (IX(I) > IX(I+1)) OK = .FALSE.\n       END DO\n       IF (OK) THEN\n         PRINT *, 't_sort: successful test'\n       ELSE\n         PRINT *, 't_sort: failure\n       END IF\n      END \n", "target": "\nfrom math import log\n \ndef getDigit(num, base, digit_num):\n    \n    return (num // base ** digit_num) % base  \n \ndef makeBlanks(size):\n    \n    return [ [] for i in range(size) ]  \n \ndef split(a_list, base, digit_num):\n    buckets = makeBlanks(base)\n    for num in a_list:\n        \n        buckets[getDigit(num, base, digit_num)].append(num)  \n    return buckets\n \n\ndef merge(a_list):\n    new_list = []\n    for sublist in a_list:\n       new_list.extend(sublist)\n    return new_list\n \ndef maxAbs(a_list):\n    \n    return max(abs(num) for num in a_list)\n\ndef split_by_sign(a_list):\n    \n    \n    buckets = [[], []]\n    for num in a_list:\n        if num < 0:\n            buckets[0].append(num)\n        else:\n            buckets[1].append(num)\n    return buckets\n \ndef radixSort(a_list, base):\n    \n    passes = int(round(log(maxAbs(a_list), base)) + 1) \n    new_list = list(a_list)\n    for digit_num in range(passes):\n        new_list = merge(split(new_list, base, digit_num))\n    return merge(split_by_sign(new_list))\n"}
{"id": 106262, "name": "Miller\u2013Rabin primality test", "source": "Translate Fortran to C#:   module Miller_Rabin\n  use PrimeDecompose\n  implicit none\n\n  integer, parameter :: max_decompose = 100\n\n  private :: int_rrand, max_decompose\n\ncontains\n\n  function int_rrand(from, to)\n    integer(huge) :: int_rrand\n    integer(huge), intent(in) :: from, to\n\n    real :: o\n    call random_number(o)\n    int_rrand = floor(from + o * real(max(from,to) - min(from, to)))\n  end function int_rrand\n\n  function miller_rabin_test(n, k) result(res)\n    logical :: res\n    integer(huge), intent(in) :: n\n    integer, intent(in) :: k\n    \n    integer(huge), dimension(max_decompose) :: f\n    integer(huge)                     :: s, d, i, a, x, r\n\n    res = .true.\n    f = 0\n\n    if ( (n <= 2) .and. (n > 0) ) return\n    if ( mod(n, 2) == 0 ) then\n       res = .false.\n       return\n    end if\n\n    call find_factors(n-1, f)\n    s = count(f == 2)\n    d = (n-1) / (2 ** s)\n    loop:  do i = 1, k\n       a = int_rrand(2_huge, n-2)\n       x = mod(a ** d, n)\n       \n       if ( x == 1 ) cycle\n       do r = 0, s-1\n          if ( x == ( n - 1 ) ) cycle loop\n          x = mod(x*x, n)\n       end do\n       if ( x == (n-1) ) cycle\n       res = .false.\n       return\n    end do loop\n    res = .true.\n  end function miller_rabin_test\n\nend module Miller_Rabin\n", "target": "public static class RabinMiller\n{\n    public static bool IsPrime(int n, int k)\n    {\n        if ((n < 2) || (n % 2 == 0)) return (n == 2);\n\n        int s = n - 1;\n        while (s % 2 == 0)  s >>= 1;\n\n        Random r = new Random();\n        for (int i = 0; i < k; i++)\n        {\n            int a = r.Next(n - 1) + 1;\n            int temp = s;\n            long mod = 1;\n            for (int j = 0; j < temp; ++j)  mod = (mod * a) % n;\n            while (temp != n - 1 && mod != 1 && mod != n - 1)\n            {\n                mod = (mod * mod) % n;\n                temp *= 2;\n            }\n\n            if (mod != n - 1 && temp % 2 == 0) return false;\n        }\n        return true;\n    }\n}\n"}
{"id": 106264, "name": "Miller\u2013Rabin primality test", "source": "Translate Fortran to Java:   module Miller_Rabin\n  use PrimeDecompose\n  implicit none\n\n  integer, parameter :: max_decompose = 100\n\n  private :: int_rrand, max_decompose\n\ncontains\n\n  function int_rrand(from, to)\n    integer(huge) :: int_rrand\n    integer(huge), intent(in) :: from, to\n\n    real :: o\n    call random_number(o)\n    int_rrand = floor(from + o * real(max(from,to) - min(from, to)))\n  end function int_rrand\n\n  function miller_rabin_test(n, k) result(res)\n    logical :: res\n    integer(huge), intent(in) :: n\n    integer, intent(in) :: k\n    \n    integer(huge), dimension(max_decompose) :: f\n    integer(huge)                     :: s, d, i, a, x, r\n\n    res = .true.\n    f = 0\n\n    if ( (n <= 2) .and. (n > 0) ) return\n    if ( mod(n, 2) == 0 ) then\n       res = .false.\n       return\n    end if\n\n    call find_factors(n-1, f)\n    s = count(f == 2)\n    d = (n-1) / (2 ** s)\n    loop:  do i = 1, k\n       a = int_rrand(2_huge, n-2)\n       x = mod(a ** d, n)\n       \n       if ( x == 1 ) cycle\n       do r = 0, s-1\n          if ( x == ( n - 1 ) ) cycle loop\n          x = mod(x*x, n)\n       end do\n       if ( x == (n-1) ) cycle\n       res = .false.\n       return\n    end do loop\n    res = .true.\n  end function miller_rabin_test\n\nend module Miller_Rabin\n", "target": "import java.math.BigInteger;\n\npublic class MillerRabinPrimalityTest {\n  public static void main(String[] args) {\n    BigInteger n = new BigInteger(args[0]);\n    int certainty = Integer.parseInt(args[1]);\n    System.out.println(n.toString() + \" is \" + (n.isProbablePrime(certainty) ? \"probably prime\" : \"composite\"));\n  }\n}\n"}
{"id": 106265, "name": "Miller\u2013Rabin primality test", "source": "Translate Fortran to Python:   module Miller_Rabin\n  use PrimeDecompose\n  implicit none\n\n  integer, parameter :: max_decompose = 100\n\n  private :: int_rrand, max_decompose\n\ncontains\n\n  function int_rrand(from, to)\n    integer(huge) :: int_rrand\n    integer(huge), intent(in) :: from, to\n\n    real :: o\n    call random_number(o)\n    int_rrand = floor(from + o * real(max(from,to) - min(from, to)))\n  end function int_rrand\n\n  function miller_rabin_test(n, k) result(res)\n    logical :: res\n    integer(huge), intent(in) :: n\n    integer, intent(in) :: k\n    \n    integer(huge), dimension(max_decompose) :: f\n    integer(huge)                     :: s, d, i, a, x, r\n\n    res = .true.\n    f = 0\n\n    if ( (n <= 2) .and. (n > 0) ) return\n    if ( mod(n, 2) == 0 ) then\n       res = .false.\n       return\n    end if\n\n    call find_factors(n-1, f)\n    s = count(f == 2)\n    d = (n-1) / (2 ** s)\n    loop:  do i = 1, k\n       a = int_rrand(2_huge, n-2)\n       x = mod(a ** d, n)\n       \n       if ( x == 1 ) cycle\n       do r = 0, s-1\n          if ( x == ( n - 1 ) ) cycle loop\n          x = mod(x*x, n)\n       end do\n       if ( x == (n-1) ) cycle\n       res = .false.\n       return\n    end do loop\n    res = .true.\n  end function miller_rabin_test\n\nend module Miller_Rabin\n", "target": "import random\n\ndef is_Prime(n):\n    \n    if n!=int(n):\n        return False\n    n=int(n)\n    \n    if n==0 or n==1 or n==4 or n==6 or n==8 or n==9:\n        return False\n        \n    if n==2 or n==3 or n==5 or n==7:\n        return True\n    s = 0\n    d = n-1\n    while d%2==0:\n        d>>=1\n        s+=1\n    assert(2**s * d == n-1)\n  \n    def trial_composite(a):\n        if pow(a, d, n) == 1:\n            return False\n        for i in range(s):\n            if pow(a, 2**i * d, n) == n-1:\n                return False\n        return True  \n \n    for i in range(8):\n        a = random.randrange(2, n)\n        if trial_composite(a):\n            return False\n \n    return True\n"}
{"id": 106400, "name": "Bulls and cows_Player", "source": "Translate Fortran to C#: module Player\n  implicit none\n\ncontains\n\nsubroutine Init(candidates)\n  integer, intent(in out) :: candidates(:)\n  integer :: a, b, c, d, n\n    \n           n = 0\nthousands: do a = 1, 9\nhundreds:    do b = 1, 9\ntens:          do c = 1, 9\nunits:           do d = 1, 9\n                   if (b == a) cycle hundreds\n                   if (c == b .or. c == a) cycle tens\n                   if (d == c .or. d == b .or. d == a) cycle units\n                   n = n + 1\n                   candidates(n) = a*1000 + b*100 + c*10 + d\n                 end do units\n               end do tens\n             end do hundreds\n           end do thousands\n\nend subroutine init\n\nsubroutine Evaluate(bulls, cows, guess, candidates) \n  integer, intent(in) :: bulls, cows, guess\n  integer, intent(in out) :: candidates(:)\n  integer :: b, c, s, i, j\n  character(4) :: n1, n2\n   \n  write(n1, \"(i4)\") guess\n  do i = 1, size(candidates)\n    if (candidates(i) == 0) cycle\n    b = 0\n    c = 0\n    write(n2, \"(i4)\") candidates(i)\n    do j = 1, 4\n      s = index(n1, n2(j:j)) \n      if(s /= 0) then\n        if(s == j) then\n          b = b + 1\n        else\n          c = c + 1\n        end if\n      end if\n    end do\n    if(.not.(b == bulls .and. c == cows)) candidates(i) = 0\n  end do\nend subroutine Evaluate\n\nfunction Nextguess(candidates)\n  integer :: Nextguess\n  integer, intent(in out) :: candidates(:)\n  integer :: i\n\n  nextguess = 0\n  do i = 1, size(candidates)\n    if(candidates(i) /= 0) then\n      nextguess = candidates(i)\n      candidates(i) = 0\n      return\n     end if\n  end do\nend function\nend module Player\n\nprogram Bulls_Cows\n  use Player\n  implicit none\n\n  integer :: bulls, cows, initial, guess\n  integer :: candidates(3024) = 0\n  real :: rnum\n\n\n  call Init(candidates)\n\n\n  call random_seed\n  call random_number(rnum)\n  initial = 3024 * rnum + 1\n  guess = candidates(initial)\n  candidates(initial) = 0\n  \n  do \n    write(*, \"(a, i4)\") \"My guess is \", guess\n    write(*, \"(a)\", advance = \"no\") \"Please score number of Bulls and Cows: \"\n    read*, bulls, cows\n    write(*,*)\n    if (bulls == 4) then\n      write(*, \"(a)\") \"Solved\n      exit\n    end if\n\n\n\n    call Evaluate(bulls, cows, guess, candidates)\n\n\n    guess = Nextguess(candidates)\n    if(guess == 0) then\n\n      write(*, \"(a)\") \"Sorry\n      exit\n    end if\n  end do\nend program\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\nnamespace BullsAndCows\n{\n    class Program\n    {\n        const int ANSWER_SIZE = 4;\n\n        static IEnumerable<string> Permutations(int size)\n        {\n            if (size > 0)\n            {\n                foreach (string s in Permutations(size - 1))\n                    foreach (char n in \"123456789\")\n                        if (!s.Contains(n))\n                            yield return s + n;\n            }\n            else\n                yield return \"\";\n        }\n\n        static IEnumerable<T> Shuffle<T>(IEnumerable<T> source)\n        {\n            Random random = new Random();\n            List<T> list = source.ToList();\n            while (list.Count > 0)\n            {\n                int ix = random.Next(list.Count);\n                yield return list[ix];\n                list.RemoveAt(ix);\n            }\n        }\n\n        static bool ReadBullsCows(out int bulls, out int cows)\n        {\n            string[] input = Console.ReadLine().Split(',').ToArray();\n            bulls = cows = 0;\n            if (input.Length < 2)\n                return false;\n            else\n                return int.TryParse(input[0], out bulls)\n                    && int.TryParse(input[1], out cows);\n        }\n\n        static void Main(string[] args)\n        {\n            Console.WriteLine(\"Bulls and Cows\");\n            Console.WriteLine(\"==============\");\n            Console.WriteLine();\n            List<string> answers = Shuffle(Permutations(ANSWER_SIZE)).ToList();\n            while (answers.Count > 1)\n            {\n                string guess = answers[0];\n                Console.Write(\"My guess is {0}. How many bulls, cows? \", guess);\n                int bulls, cows;\n                if (!ReadBullsCows(out bulls, out cows))\n                    Console.WriteLine(\"Sorry, I didn't understand that. Please try again.\");\n                else\n                    for (int ans = answers.Count - 1; ans >= 0; ans--)\n                    {\n                        int tb = 0, tc = 0;\n                        for (int ix = 0; ix < ANSWER_SIZE; ix++)\n                            if (answers[ans][ix] == guess[ix])\n                                tb++;\n                            else if (answers[ans].Contains(guess[ix]))\n                                tc++;\n                        if ((tb != bulls) || (tc != cows))\n                            answers.RemoveAt(ans);\n                    }\n            }\n            if (answers.Count == 1)\n                Console.WriteLine(\"Hooray! The answer is {0}!\", answers[0]);\n            else\n                Console.WriteLine(\"No possible answer fits the scores you gave.\");\n        }\n    }\n}\n"}
{"id": 106403, "name": "Bulls and cows_Player", "source": "Translate Fortran to Java: module Player\n  implicit none\n\ncontains\n\nsubroutine Init(candidates)\n  integer, intent(in out) :: candidates(:)\n  integer :: a, b, c, d, n\n    \n           n = 0\nthousands: do a = 1, 9\nhundreds:    do b = 1, 9\ntens:          do c = 1, 9\nunits:           do d = 1, 9\n                   if (b == a) cycle hundreds\n                   if (c == b .or. c == a) cycle tens\n                   if (d == c .or. d == b .or. d == a) cycle units\n                   n = n + 1\n                   candidates(n) = a*1000 + b*100 + c*10 + d\n                 end do units\n               end do tens\n             end do hundreds\n           end do thousands\n\nend subroutine init\n\nsubroutine Evaluate(bulls, cows, guess, candidates) \n  integer, intent(in) :: bulls, cows, guess\n  integer, intent(in out) :: candidates(:)\n  integer :: b, c, s, i, j\n  character(4) :: n1, n2\n   \n  write(n1, \"(i4)\") guess\n  do i = 1, size(candidates)\n    if (candidates(i) == 0) cycle\n    b = 0\n    c = 0\n    write(n2, \"(i4)\") candidates(i)\n    do j = 1, 4\n      s = index(n1, n2(j:j)) \n      if(s /= 0) then\n        if(s == j) then\n          b = b + 1\n        else\n          c = c + 1\n        end if\n      end if\n    end do\n    if(.not.(b == bulls .and. c == cows)) candidates(i) = 0\n  end do\nend subroutine Evaluate\n\nfunction Nextguess(candidates)\n  integer :: Nextguess\n  integer, intent(in out) :: candidates(:)\n  integer :: i\n\n  nextguess = 0\n  do i = 1, size(candidates)\n    if(candidates(i) /= 0) then\n      nextguess = candidates(i)\n      candidates(i) = 0\n      return\n     end if\n  end do\nend function\nend module Player\n\nprogram Bulls_Cows\n  use Player\n  implicit none\n\n  integer :: bulls, cows, initial, guess\n  integer :: candidates(3024) = 0\n  real :: rnum\n\n\n  call Init(candidates)\n\n\n  call random_seed\n  call random_number(rnum)\n  initial = 3024 * rnum + 1\n  guess = candidates(initial)\n  candidates(initial) = 0\n  \n  do \n    write(*, \"(a, i4)\") \"My guess is \", guess\n    write(*, \"(a)\", advance = \"no\") \"Please score number of Bulls and Cows: \"\n    read*, bulls, cows\n    write(*,*)\n    if (bulls == 4) then\n      write(*, \"(a)\") \"Solved\n      exit\n    end if\n\n\n\n    call Evaluate(bulls, cows, guess, candidates)\n\n\n    guess = Nextguess(candidates)\n    if(guess == 0) then\n\n      write(*, \"(a)\") \"Sorry\n      exit\n    end if\n  end do\nend program\n", "target": "public class BullsAndCowsPlayerGame {\n\n    private static int count;\n    private static Console io = System.console();\n\n    private final GameNumber secret;\n    private List<AutoGuessNumber> pool = new ArrayList<>();\n\n    public BullsAndCowsPlayerGame(GameNumber secret) {\n        this.secret = secret;\n        fillPool();\n    }\n\n    private void fillPool() {\n        for (int i = 123; i < 9877; i++) {\n            int[] arr = AutoGuessNumber.parseDigits(i, 4);\n\n            if (GameNumber.isGuess(arr)) {\n                pool.add(new AutoGuessNumber(i, 4));\n            }\n        }\n    }\n\n    public void play() {\n        io.printf(\"Bulls and Cows%n\");\n        io.printf(\"==============%n\");\n        io.printf(\"Secret number is %s%n\", secret);\n\n        do {\n            AutoGuessNumber guess = guessNumber();\n            io.printf(\"Guess #%d is %s from %d%n\", count, guess, pool.size());\n\n            GuessResult result = secret.match(guess);\n            if (result != null) {\n                printScore(io, result);\n\n                if (result.isWin()) {\n                    io.printf(\"The answer is %s%n\", guess);\n                    break;\n                }\n\n                clearPool(guess, result);\n            } else {\n                io.printf(\"No more variants%n\");\n                System.exit(0);\n            }\n        } while (true);\n    }\n\n    private AutoGuessNumber guessNumber() {\n        Random random = new Random();\n        if (pool.size() > 0) {\n            int number = random.nextInt(pool.size());\n            count++;\n            return pool.get(number);\n        }\n        return null;\n    }\n\n    private static void printScore(Console io, GuessResult result) {\n        io.printf(\"%1$d  %2$d%n\", result.getBulls(), result.getCows());\n    }\n\n    private void clearPool(AutoGuessNumber guess, GuessResult guessResult) {\n        pool.remove(guess);\n\n        for (int i = 0; i < pool.size(); i++) {\n            AutoGuessNumber g = pool.get(i);\n            GuessResult gr = guess.match(g);\n\n            if (!guessResult.equals(gr)) {\n                pool.remove(g);\n            }\n        }\n    }\n\n    public static void main(String[] args) {\n        new BullsAndCowsPlayerGame(new GameNumber()).play();\n    }\n}\n"}
{"id": 106404, "name": "Bulls and cows_Player", "source": "Translate Fortran to Python: module Player\n  implicit none\n\ncontains\n\nsubroutine Init(candidates)\n  integer, intent(in out) :: candidates(:)\n  integer :: a, b, c, d, n\n    \n           n = 0\nthousands: do a = 1, 9\nhundreds:    do b = 1, 9\ntens:          do c = 1, 9\nunits:           do d = 1, 9\n                   if (b == a) cycle hundreds\n                   if (c == b .or. c == a) cycle tens\n                   if (d == c .or. d == b .or. d == a) cycle units\n                   n = n + 1\n                   candidates(n) = a*1000 + b*100 + c*10 + d\n                 end do units\n               end do tens\n             end do hundreds\n           end do thousands\n\nend subroutine init\n\nsubroutine Evaluate(bulls, cows, guess, candidates) \n  integer, intent(in) :: bulls, cows, guess\n  integer, intent(in out) :: candidates(:)\n  integer :: b, c, s, i, j\n  character(4) :: n1, n2\n   \n  write(n1, \"(i4)\") guess\n  do i = 1, size(candidates)\n    if (candidates(i) == 0) cycle\n    b = 0\n    c = 0\n    write(n2, \"(i4)\") candidates(i)\n    do j = 1, 4\n      s = index(n1, n2(j:j)) \n      if(s /= 0) then\n        if(s == j) then\n          b = b + 1\n        else\n          c = c + 1\n        end if\n      end if\n    end do\n    if(.not.(b == bulls .and. c == cows)) candidates(i) = 0\n  end do\nend subroutine Evaluate\n\nfunction Nextguess(candidates)\n  integer :: Nextguess\n  integer, intent(in out) :: candidates(:)\n  integer :: i\n\n  nextguess = 0\n  do i = 1, size(candidates)\n    if(candidates(i) /= 0) then\n      nextguess = candidates(i)\n      candidates(i) = 0\n      return\n     end if\n  end do\nend function\nend module Player\n\nprogram Bulls_Cows\n  use Player\n  implicit none\n\n  integer :: bulls, cows, initial, guess\n  integer :: candidates(3024) = 0\n  real :: rnum\n\n\n  call Init(candidates)\n\n\n  call random_seed\n  call random_number(rnum)\n  initial = 3024 * rnum + 1\n  guess = candidates(initial)\n  candidates(initial) = 0\n  \n  do \n    write(*, \"(a, i4)\") \"My guess is \", guess\n    write(*, \"(a)\", advance = \"no\") \"Please score number of Bulls and Cows: \"\n    read*, bulls, cows\n    write(*,*)\n    if (bulls == 4) then\n      write(*, \"(a)\") \"Solved\n      exit\n    end if\n\n\n\n    call Evaluate(bulls, cows, guess, candidates)\n\n\n    guess = Nextguess(candidates)\n    if(guess == 0) then\n\n      write(*, \"(a)\") \"Sorry\n      exit\n    end if\n  end do\nend program\n", "target": "from itertools import permutations\nfrom random import shuffle\n\ntry:\n    raw_input\nexcept:\n    raw_input = input\ntry:\n    from itertools import izip\nexcept:\n    izip = zip\n    \ndigits = '123456789'\nsize = 4\n\ndef parse_score(score):\n    score = score.strip().split(',')\n    return tuple(int(s.strip()) for s in score)\n\ndef scorecalc(guess, chosen):\n    bulls = cows = 0\n    for g,c in izip(guess, chosen):\n        if g == c:\n            bulls += 1\n        elif g in chosen:\n            cows += 1\n    return bulls, cows\n\nchoices = list(permutations(digits, size))\nshuffle(choices)\nanswers = []\nscores  = []\n\nprint (\"Playing Bulls & Cows with %i unique digits\\n\" % size)\n       \nwhile True:\n    ans = choices[0]\n    answers.append(ans)\n    \n    score = raw_input(\"Guess %2i is %*s. Answer (Bulls, cows)? \"\n                      % (len(answers), size, ''.join(ans)))\n    score = parse_score(score)\n    scores.append(score)\n    \n    found =  score == (size, 0)\n    if found:\n        print (\"Ye-haw!\")\n        break\n    choices = [c for c in choices if scorecalc(c, ans) == score]\n    if not choices:\n        print (\"Bad scoring? nothing fits those scores you gave:\")\n        print ('  ' +\n               '\\n  '.join(\"%s -> %s\" % (''.join(an),sc)\n                           for an,sc in izip(answers, scores)))\n        break\n"}
{"id": 106615, "name": "Last Friday of each month", "source": "Translate Fortran to C#: program fridays\n   implicit none\n   integer :: days(1:12) = (/31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31/)\n   integer :: year, k, y, m\n   read *, year\n   if (mod(year, 400) == 0 .or. (mod(year, 4) == 0 .and. mod(year, 100) /= 0)) days(2) = 29\n   y = year - 1\n   k = 44 + y + y/4 + 6*(y/100) + y/400\n   do m = 1, 12\n      k = k + days(m)\n      print \"(I4,A1,I2.2,A1,I2)\", year, '-', m, '-', days(m) - mod(k, 7)\n   end do\nend program\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Globalization;\nusing System.Linq;\n\nnamespace RosettaCode.LastFridaysOfYear\n{\n    internal static class Program\n    {\n        private static IEnumerable<DateTime> LastFridaysOfYear(int year)\n        {\n            for (var month = 1; month <= 12; month++)\n            {\n                var date = new DateTime(year, month, 1).AddMonths(1).AddDays(-1);\n                while (date.DayOfWeek != DayOfWeek.Friday)\n                {\n                    date = date.AddDays(-1);\n                }\n                yield return date;\n            }\n        }\n\n        private static void Main(string[] arguments)\n        {\n            int year;\n            var argument = arguments.FirstOrDefault();\n            if (string.IsNullOrEmpty(argument) || !int.TryParse(argument, out year))\n            {\n                year = DateTime.Today.Year;\n            }\n\n            foreach (var date in LastFridaysOfYear(year))\n            {\n                Console.WriteLine(date.ToString(\"d\", CultureInfo.InvariantCulture));\n            }\n        }\n    }\n}\n"}
{"id": 106616, "name": "Last Friday of each month", "source": "Translate Fortran to C#: program fridays\n   implicit none\n   integer :: days(1:12) = (/31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31/)\n   integer :: year, k, y, m\n   read *, year\n   if (mod(year, 400) == 0 .or. (mod(year, 4) == 0 .and. mod(year, 100) /= 0)) days(2) = 29\n   y = year - 1\n   k = 44 + y + y/4 + 6*(y/100) + y/400\n   do m = 1, 12\n      k = k + days(m)\n      print \"(I4,A1,I2.2,A1,I2)\", year, '-', m, '-', days(m) - mod(k, 7)\n   end do\nend program\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Globalization;\nusing System.Linq;\n\nnamespace RosettaCode.LastFridaysOfYear\n{\n    internal static class Program\n    {\n        private static IEnumerable<DateTime> LastFridaysOfYear(int year)\n        {\n            for (var month = 1; month <= 12; month++)\n            {\n                var date = new DateTime(year, month, 1).AddMonths(1).AddDays(-1);\n                while (date.DayOfWeek != DayOfWeek.Friday)\n                {\n                    date = date.AddDays(-1);\n                }\n                yield return date;\n            }\n        }\n\n        private static void Main(string[] arguments)\n        {\n            int year;\n            var argument = arguments.FirstOrDefault();\n            if (string.IsNullOrEmpty(argument) || !int.TryParse(argument, out year))\n            {\n                year = DateTime.Today.Year;\n            }\n\n            foreach (var date in LastFridaysOfYear(year))\n            {\n                Console.WriteLine(date.ToString(\"d\", CultureInfo.InvariantCulture));\n            }\n        }\n    }\n}\n"}
{"id": 106622, "name": "Last Friday of each month", "source": "Translate Fortran to Java: program fridays\n   implicit none\n   integer :: days(1:12) = (/31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31/)\n   integer :: year, k, y, m\n   read *, year\n   if (mod(year, 400) == 0 .or. (mod(year, 4) == 0 .and. mod(year, 100) /= 0)) days(2) = 29\n   y = year - 1\n   k = 44 + y + y/4 + 6*(y/100) + y/400\n   do m = 1, 12\n      k = k + days(m)\n      print \"(I4,A1,I2.2,A1,I2)\", year, '-', m, '-', days(m) - mod(k, 7)\n   end do\nend program\n", "target": "import java.text.*;\nimport java.util.*;\n\npublic class LastFridays {\n\n    public static void main(String[] args) throws Exception {\n        int year = Integer.parseInt(args[0]);\n        GregorianCalendar c = new GregorianCalendar(year, 0, 1);\n\n        for (String mon : new DateFormatSymbols(Locale.US).getShortMonths()) {\n            if (!mon.isEmpty()) {\n                int totalDaysOfMonth = c.getActualMaximum(Calendar.DAY_OF_MONTH);\n                c.set(Calendar.DAY_OF_MONTH, totalDaysOfMonth);\n\n                int daysToRollBack = (c.get(Calendar.DAY_OF_WEEK) + 1) % 7;\n\n                int day = totalDaysOfMonth - daysToRollBack;\n                c.set(Calendar.DAY_OF_MONTH, day);\n\n                System.out.printf(\"%d %s %d\\n\", year, mon, day);\n\n                c.set(year, c.get(Calendar.MONTH) + 1, 1);\n            }\n        }\n    }\n}\n"}
{"id": 106623, "name": "Last Friday of each month", "source": "Translate Fortran to Java: program fridays\n   implicit none\n   integer :: days(1:12) = (/31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31/)\n   integer :: year, k, y, m\n   read *, year\n   if (mod(year, 400) == 0 .or. (mod(year, 4) == 0 .and. mod(year, 100) /= 0)) days(2) = 29\n   y = year - 1\n   k = 44 + y + y/4 + 6*(y/100) + y/400\n   do m = 1, 12\n      k = k + days(m)\n      print \"(I4,A1,I2.2,A1,I2)\", year, '-', m, '-', days(m) - mod(k, 7)\n   end do\nend program\n", "target": "import java.text.*;\nimport java.util.*;\n\npublic class LastFridays {\n\n    public static void main(String[] args) throws Exception {\n        int year = Integer.parseInt(args[0]);\n        GregorianCalendar c = new GregorianCalendar(year, 0, 1);\n\n        for (String mon : new DateFormatSymbols(Locale.US).getShortMonths()) {\n            if (!mon.isEmpty()) {\n                int totalDaysOfMonth = c.getActualMaximum(Calendar.DAY_OF_MONTH);\n                c.set(Calendar.DAY_OF_MONTH, totalDaysOfMonth);\n\n                int daysToRollBack = (c.get(Calendar.DAY_OF_WEEK) + 1) % 7;\n\n                int day = totalDaysOfMonth - daysToRollBack;\n                c.set(Calendar.DAY_OF_MONTH, day);\n\n                System.out.printf(\"%d %s %d\\n\", year, mon, day);\n\n                c.set(year, c.get(Calendar.MONTH) + 1, 1);\n            }\n        }\n    }\n}\n"}
{"id": 106624, "name": "Last Friday of each month", "source": "Translate Fortran to Python: program fridays\n   implicit none\n   integer :: days(1:12) = (/31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31/)\n   integer :: year, k, y, m\n   read *, year\n   if (mod(year, 400) == 0 .or. (mod(year, 4) == 0 .and. mod(year, 100) /= 0)) days(2) = 29\n   y = year - 1\n   k = 44 + y + y/4 + 6*(y/100) + y/400\n   do m = 1, 12\n      k = k + days(m)\n      print \"(I4,A1,I2.2,A1,I2)\", year, '-', m, '-', days(m) - mod(k, 7)\n   end do\nend program\n", "target": "import calendar\n\ndef last_fridays(year):\n    for month in range(1, 13):\n        last_friday = max(week[calendar.FRIDAY]\n            for week in calendar.monthcalendar(year, month))\n        print('{:4d}-{:02d}-{:02d}'.format(year, month, last_friday))\n"}
{"id": 106625, "name": "Last Friday of each month", "source": "Translate Fortran to Python: program fridays\n   implicit none\n   integer :: days(1:12) = (/31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31/)\n   integer :: year, k, y, m\n   read *, year\n   if (mod(year, 400) == 0 .or. (mod(year, 4) == 0 .and. mod(year, 100) /= 0)) days(2) = 29\n   y = year - 1\n   k = 44 + y + y/4 + 6*(y/100) + y/400\n   do m = 1, 12\n      k = k + days(m)\n      print \"(I4,A1,I2.2,A1,I2)\", year, '-', m, '-', days(m) - mod(k, 7)\n   end do\nend program\n", "target": "import calendar\n\ndef last_fridays(year):\n    for month in range(1, 13):\n        last_friday = max(week[calendar.FRIDAY]\n            for week in calendar.monthcalendar(year, month))\n        print('{:4d}-{:02d}-{:02d}'.format(year, month, last_friday))\n"}
{"id": 107033, "name": "Date format", "source": "Translate Fortran to C#: PROGRAM DATE\n\n  IMPLICIT NONE\n  \n  INTEGER :: dateinfo(8), day\n  CHARACTER(9) :: month, dayname\n     \n  CALL DATE_AND_TIME(VALUES=dateinfo)\n  SELECT CASE(dateinfo(2))\n    CASE(1)\n      month = \"January\"\n    CASE(2)\n      month = \"February\"\n    CASE(3)\n      month = \"March\"\n    CASE(4)\n      month = \"April\"\n    CASE(5)\n      month = \"May\"\n    CASE(6)\n      month = \"June\"\n    CASE(7)\n      month = \"July\"\n    CASE(8)\n      month = \"August\"\n    CASE(9)\n      month = \"September\"\n    CASE(10)\n      month = \"October\"\n    CASE(11)\n      month = \"November\"\n    CASE(12)\n     month = \"December\"\n  END SELECT\n\n  day = Day_of_week(dateinfo(3), dateinfo(2), dateinfo(1))\n\n  SELECT CASE(day)\n    CASE(0)\n      dayname = \"Saturday\"\n    CASE(1)\n      dayname = \"Sunday\"\n    CASE(2)\n      dayname = \"Monday\"\n    CASE(3)\n      dayname = \"Tuesday\"\n    CASE(4)\n      dayname = \"Wednesday\"\n    CASE(5)\n      dayname = \"Thursday\"\n    CASE(6)\n      dayname = \"Friday\"\n  END SELECT\n  \n  WRITE(*,\"(I0,A,I0,A,I0)\") dateinfo(1),\"-\", dateinfo(2),\"-\", dateinfo(3)\n  WRITE(*,\"(4(A),I0,A,I0)\") trim(dayname), \", \", trim(month), \" \", dateinfo(3), \", \", dateinfo(1)\n\nCONTAINS\n\n  FUNCTION Day_of_week(d, m, y)\n    INTEGER :: Day_of_week, j, k\n    INTEGER, INTENT(IN) :: d, m, y\n    \n    j = y / 100\n    k = MOD(y, 100)\n    Day_of_week = MOD(d + (m+1)*26/10 + k + k/4 + j/4 + 5*j, 7)\n  END FUNCTION Day_of_week\n\nEND PROGRAM DATE\n", "target": "using System;\n\nnamespace RosettaCode.DateFormat\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            DateTime today = DateTime.Now.Date;\n            Console.WriteLine(today.ToString(\"yyyy-MM-dd\"));\n            Console.WriteLine(today.ToString(\"dddd, MMMMM d, yyyy\"));\n        }\n    }\n}\n"}
{"id": 107036, "name": "Date format", "source": "Translate Fortran to Java: PROGRAM DATE\n\n  IMPLICIT NONE\n  \n  INTEGER :: dateinfo(8), day\n  CHARACTER(9) :: month, dayname\n     \n  CALL DATE_AND_TIME(VALUES=dateinfo)\n  SELECT CASE(dateinfo(2))\n    CASE(1)\n      month = \"January\"\n    CASE(2)\n      month = \"February\"\n    CASE(3)\n      month = \"March\"\n    CASE(4)\n      month = \"April\"\n    CASE(5)\n      month = \"May\"\n    CASE(6)\n      month = \"June\"\n    CASE(7)\n      month = \"July\"\n    CASE(8)\n      month = \"August\"\n    CASE(9)\n      month = \"September\"\n    CASE(10)\n      month = \"October\"\n    CASE(11)\n      month = \"November\"\n    CASE(12)\n     month = \"December\"\n  END SELECT\n\n  day = Day_of_week(dateinfo(3), dateinfo(2), dateinfo(1))\n\n  SELECT CASE(day)\n    CASE(0)\n      dayname = \"Saturday\"\n    CASE(1)\n      dayname = \"Sunday\"\n    CASE(2)\n      dayname = \"Monday\"\n    CASE(3)\n      dayname = \"Tuesday\"\n    CASE(4)\n      dayname = \"Wednesday\"\n    CASE(5)\n      dayname = \"Thursday\"\n    CASE(6)\n      dayname = \"Friday\"\n  END SELECT\n  \n  WRITE(*,\"(I0,A,I0,A,I0)\") dateinfo(1),\"-\", dateinfo(2),\"-\", dateinfo(3)\n  WRITE(*,\"(4(A),I0,A,I0)\") trim(dayname), \", \", trim(month), \" \", dateinfo(3), \", \", dateinfo(1)\n\nCONTAINS\n\n  FUNCTION Day_of_week(d, m, y)\n    INTEGER :: Day_of_week, j, k\n    INTEGER, INTENT(IN) :: d, m, y\n    \n    j = y / 100\n    k = MOD(y, 100)\n    Day_of_week = MOD(d + (m+1)*26/10 + k + k/4 + j/4 + 5*j, 7)\n  END FUNCTION Day_of_week\n\nEND PROGRAM DATE\n", "target": "Datetime dtNow = datetime.now();\nString strDt1 = dtNow.format('yyyy-MM-dd');\nString strDt2 = dtNow.format('EEEE, MMMM dd, yyyy');\nsystem.debug(strDt1); \nsystem.debug(strDt2); \n"}
{"id": 107037, "name": "Date format", "source": "Translate Fortran to Python: PROGRAM DATE\n\n  IMPLICIT NONE\n  \n  INTEGER :: dateinfo(8), day\n  CHARACTER(9) :: month, dayname\n     \n  CALL DATE_AND_TIME(VALUES=dateinfo)\n  SELECT CASE(dateinfo(2))\n    CASE(1)\n      month = \"January\"\n    CASE(2)\n      month = \"February\"\n    CASE(3)\n      month = \"March\"\n    CASE(4)\n      month = \"April\"\n    CASE(5)\n      month = \"May\"\n    CASE(6)\n      month = \"June\"\n    CASE(7)\n      month = \"July\"\n    CASE(8)\n      month = \"August\"\n    CASE(9)\n      month = \"September\"\n    CASE(10)\n      month = \"October\"\n    CASE(11)\n      month = \"November\"\n    CASE(12)\n     month = \"December\"\n  END SELECT\n\n  day = Day_of_week(dateinfo(3), dateinfo(2), dateinfo(1))\n\n  SELECT CASE(day)\n    CASE(0)\n      dayname = \"Saturday\"\n    CASE(1)\n      dayname = \"Sunday\"\n    CASE(2)\n      dayname = \"Monday\"\n    CASE(3)\n      dayname = \"Tuesday\"\n    CASE(4)\n      dayname = \"Wednesday\"\n    CASE(5)\n      dayname = \"Thursday\"\n    CASE(6)\n      dayname = \"Friday\"\n  END SELECT\n  \n  WRITE(*,\"(I0,A,I0,A,I0)\") dateinfo(1),\"-\", dateinfo(2),\"-\", dateinfo(3)\n  WRITE(*,\"(4(A),I0,A,I0)\") trim(dayname), \", \", trim(month), \" \", dateinfo(3), \", \", dateinfo(1)\n\nCONTAINS\n\n  FUNCTION Day_of_week(d, m, y)\n    INTEGER :: Day_of_week, j, k\n    INTEGER, INTENT(IN) :: d, m, y\n    \n    j = y / 100\n    k = MOD(y, 100)\n    Day_of_week = MOD(d + (m+1)*26/10 + k + k/4 + j/4 + 5*j, 7)\n  END FUNCTION Day_of_week\n\nEND PROGRAM DATE\n", "target": "import datetime\ntoday = datetime.date.today()\n\ntoday.isoformat()\n\ntoday.strftime(\"%A, %B %d, %Y\")\n\n\n\"The date is {0:%A, %B %d, %Y}\".format(d)\n\n\"The date is {date:%A, %B %d, %Y}\".format(date=d)\n\nf\"The date is {d:%A, %B %d, %Y}\"\n"}
{"id": 107305, "name": "XML_Input", "source": "Translate Fortran to C#: program tixi_rosetta\n  use tixi\n  implicit none\n  integer :: i\n  character (len=100) :: xml_file_name \n  integer :: handle\n  integer :: error\t\n  character(len=100) :: name, xml_attr\n  xml_file_name = 'rosetta.xml'\n\n  call tixi_open_document( xml_file_name, handle, error )\n  i = 1\n  do \n      xml_attr = '/Students/Student['//int2char(i)//']'\n      call tixi_get_text_attribute( handle, xml_attr,'Name', name, error )      \n      if(error /= 0) exit\n      write(*,*) name\n      i = i + 1\n  enddo\n\n  call tixi_close_document( handle, error )\n\n  contains\n\n  function int2char(i) result(res)\n    character(:),allocatable :: res\n    integer,intent(in) :: i\n    character(range(i)+2) :: tmp\n    write(tmp,'(i0)') i\n    res = trim(tmp)\n  end function int2char\n\nend program tixi_rosetta\n", "target": "class Program\n{\n    static void Main(string[] args)\n    {   \n        XDocument xmlDoc = XDocument.Load(\"XMLFile1.xml\");\n        var query = from p in xmlDoc.Descendants(\"Student\")\n                    select p.Attribute(\"Name\");\n\n        foreach (var item in query)\n        {\n            Console.WriteLine(item.Value);\n        }\n        Console.ReadLine();\n    }  \n}\n"}
{"id": 107308, "name": "XML_Input", "source": "Translate Fortran to Java: program tixi_rosetta\n  use tixi\n  implicit none\n  integer :: i\n  character (len=100) :: xml_file_name \n  integer :: handle\n  integer :: error\t\n  character(len=100) :: name, xml_attr\n  xml_file_name = 'rosetta.xml'\n\n  call tixi_open_document( xml_file_name, handle, error )\n  i = 1\n  do \n      xml_attr = '/Students/Student['//int2char(i)//']'\n      call tixi_get_text_attribute( handle, xml_attr,'Name', name, error )      \n      if(error /= 0) exit\n      write(*,*) name\n      i = i + 1\n  enddo\n\n  call tixi_close_document( handle, error )\n\n  contains\n\n  function int2char(i) result(res)\n    character(:),allocatable :: res\n    integer,intent(in) :: i\n    character(range(i)+2) :: tmp\n    write(tmp,'(i0)') i\n    res = trim(tmp)\n  end function int2char\n\nend program tixi_rosetta\n", "target": "import java.io.IOException;\nimport java.io.StringReader;\nimport org.xml.sax.Attributes;\nimport org.xml.sax.InputSource;\nimport org.xml.sax.SAXException;\nimport org.xml.sax.XMLReader;\nimport org.xml.sax.helpers.DefaultHandler;\nimport org.xml.sax.helpers.XMLReaderFactory;\n\npublic class StudentHandler extends DefaultHandler {\n  public static void main(String[] args)throws Exception{\n    String xml = \"<Students>\\n\"+\n    \"<Student Name=\\\"April\\\" Gender=\\\"F\\\" DateOfBirth=\\\"1989-01-02\\\" />\\n\"+\n    \"<Student Name=\\\"Bob\\\" Gender=\\\"M\\\"  DateOfBirth=\\\"1990-03-04\\\" />\\n\"+\n    \"<Student Name=\\\"Chad\\\" Gender=\\\"M\\\"  DateOfBirth=\\\"1991-05-06\\\" />\\n\"+\n    \"<Student Name=\\\"Dave\\\" Gender=\\\"M\\\"  DateOfBirth=\\\"1992-07-08\\\">\\n\"+\n    \"  <Pet Type=\\\"dog\\\" Name=\\\"Rover\\\" />\\n\"+\n    \"</Student>\\n\"+\n    \"<Student DateOfBirth=\\\"1993-09-10\\\" Gender=\\\"F\\\" Name=\\\"&#x00C9;mily\\\" />\\n\"+\n    \"</Students>\";\n    StudentHandler handler = new StudentHandler();\n    handler.parse(new InputSource(new StringReader(xml)));\n  }\n\n  public void parse(InputSource src) throws SAXException, IOException {\n\t\tXMLReader parser = XMLReaderFactory.createXMLReader();\n    parser.setContentHandler(this);\n    parser.parse(src);\n  }\n\n  @Override\n  public void characters(char[] ch, int start, int length) throws SAXException {\n    \n    \n    super.characters(ch, start, length);\n  }\n\n  @Override\n  public void endElement(String uri, String localName, String qName) throws SAXException {\n    \n    \n    super.endElement(uri, localName, qName);\n  }\n\n  @Override\n  public void startElement(String uri, String localName, String qName, Attributes attributes) throws SAXException {\n    if(qName.equals(\"Student\")){\n      System.out.println(attributes.getValue(\"Name\"));\n    }\n  }\n}\n"}
{"id": 107309, "name": "XML_Input", "source": "Translate Fortran to Python: program tixi_rosetta\n  use tixi\n  implicit none\n  integer :: i\n  character (len=100) :: xml_file_name \n  integer :: handle\n  integer :: error\t\n  character(len=100) :: name, xml_attr\n  xml_file_name = 'rosetta.xml'\n\n  call tixi_open_document( xml_file_name, handle, error )\n  i = 1\n  do \n      xml_attr = '/Students/Student['//int2char(i)//']'\n      call tixi_get_text_attribute( handle, xml_attr,'Name', name, error )      \n      if(error /= 0) exit\n      write(*,*) name\n      i = i + 1\n  enddo\n\n  call tixi_close_document( handle, error )\n\n  contains\n\n  function int2char(i) result(res)\n    character(:),allocatable :: res\n    integer,intent(in) :: i\n    character(range(i)+2) :: tmp\n    write(tmp,'(i0)') i\n    res = trim(tmp)\n  end function int2char\n\nend program tixi_rosetta\n", "target": "import xml.dom.minidom\n\ndoc = \n\ndoc = xml.dom.minidom.parseString(doc)\n\nfor i in doc.getElementsByTagName(\"Student\"):\n    print i.getAttribute(\"Name\")\n"}
{"id": 107575, "name": "Exponentiation order", "source": "Translate Fortran to C#: write(*, \"(a, i0)\") \"5**3**2   = \", 5**3**2\nwrite(*, \"(a, i0)\") \"(5**3)**2 = \", (5**3)**2\nwrite(*, \"(a, i0)\") \"5**(3**2) = \", 5**(3**2)\n", "target": "using System;\n\nnamespace exponents\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            \n            Console.WriteLine(Math.Pow(Math.Pow(5, 3), 2));\n            Console.WriteLine(Math.Pow(5, Math.Pow(3, 2)));\n            Console.Read();\n        }\n\n    }\n}\n"}
{"id": 107576, "name": "Exponentiation order", "source": "Translate Fortran to C#: write(*, \"(a, i0)\") \"5**3**2   = \", 5**3**2\nwrite(*, \"(a, i0)\") \"(5**3)**2 = \", (5**3)**2\nwrite(*, \"(a, i0)\") \"5**(3**2) = \", 5**(3**2)\n", "target": "using System;\n\nnamespace exponents\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            \n            Console.WriteLine(Math.Pow(Math.Pow(5, 3), 2));\n            Console.WriteLine(Math.Pow(5, Math.Pow(3, 2)));\n            Console.Read();\n        }\n\n    }\n}\n"}
{"id": 107582, "name": "Exponentiation order", "source": "Translate Fortran to Python: write(*, \"(a, i0)\") \"5**3**2   = \", 5**3**2\nwrite(*, \"(a, i0)\") \"(5**3)**2 = \", (5**3)**2\nwrite(*, \"(a, i0)\") \"5**(3**2) = \", 5**(3**2)\n", "target": ">>> 5**3**2\n1953125\n>>> (5**3)**2\n15625\n>>> 5**(3**2)\n1953125\n>>> \n>>> try: from functools import reduce \nexcept: pass\n\n>>> reduce(pow, (5, 3, 2))\n15625\n>>>\n"}
{"id": 107583, "name": "Exponentiation order", "source": "Translate Fortran to Python: write(*, \"(a, i0)\") \"5**3**2   = \", 5**3**2\nwrite(*, \"(a, i0)\") \"(5**3)**2 = \", (5**3)**2\nwrite(*, \"(a, i0)\") \"5**(3**2) = \", 5**(3**2)\n", "target": ">>> 5**3**2\n1953125\n>>> (5**3)**2\n15625\n>>> 5**(3**2)\n1953125\n>>> \n>>> try: from functools import reduce \nexcept: pass\n\n>>> reduce(pow, (5, 3, 2))\n15625\n>>>\n"}
{"id": 107863, "name": "Loops_For with a specified step", "source": "Translate Fortran to C#: do i = 1,10,2\n   print *, i\nend do\n", "target": "using System;\n \nclass Program {\n    static void Main(string[] args) {    \n        for (int i = 2; i <= 8; i+= 2) {        \n            Console.Write(\"{0}, \", i);\n        }\n\n        Console.WriteLine(\"who do we appreciate?\");\n    }\n}\n"}
{"id": 107866, "name": "Loops_For with a specified step", "source": "Translate Fortran to Java: do i = 1,10,2\n   print *, i\nend do\n", "target": "for(int i = 2; i <= 8;i += 2){\n   System.out.print(i + \", \");\n}\nSystem.out.println(\"who do we appreciate?\");\n"}
{"id": 107867, "name": "Loops_For with a specified step", "source": "Translate Fortran to Python: do i = 1,10,2\n   print *, i\nend do\n", "target": "for i in xrange(2, 9, 2):\n    print \"%d,\" % i,\nprint \"who do we appreciate?\"\n"}
{"id": 108137, "name": "Queue_Usage", "source": "Translate Fortran to C#: module fifo_nodes\n  type fifo_node\n     integer :: datum\n     \n     type(fifo_node), pointer :: next\n     logical :: valid\n  end type fifo_node\nend module fifo_nodes\n\nprogram FIFOTest\n  use fifo\n  implicit none\n\n  type(fifo_head) :: thehead\n  type(fifo_node), dimension(5) :: ex, xe\n  integer :: i\n  \n  call new_fifo(thehead)\n\n  do i = 1, 5\n     ex(i)%datum = i\n     call fifo_enqueue(thehead, ex(i))\n  end do\n\n  i = 1\n  do\n     call fifo_dequeue(thehead, xe(i))\n     print *, xe(i)%datum\n     i = i + 1\n     if ( fifo_isempty(thehead) ) exit\n  end do\n\nend program FIFOTest\n", "target": "using System;\nusing System.Collections.Generic;\n\nnamespace RosettaCode\n{\n    class Program\n    {\n        static void Main()\n        {\n            \n            Queue<int> queue  = new Queue<int>();\n            queue.Enqueue(1);\n            queue.Enqueue(3);\n            queue.Enqueue(5);\n\n            \n            Console.WriteLine(queue.Dequeue()); \n            Console.WriteLine(queue.Dequeue()); \n            Console.WriteLine(queue.Dequeue()); \n\n            \n            bool empty = queue.Count == 0;\n            Console.WriteLine(empty); \n\n            \n            \n            try\n            {\n                queue.Dequeue();\n            }\n            catch (InvalidOperationException exception)\n            {\n                Console.WriteLine(exception.Message); \n            }\n        }\n    }\n}\n"}
{"id": 108140, "name": "Queue_Usage", "source": "Translate Fortran to Java: module fifo_nodes\n  type fifo_node\n     integer :: datum\n     \n     type(fifo_node), pointer :: next\n     logical :: valid\n  end type fifo_node\nend module fifo_nodes\n\nprogram FIFOTest\n  use fifo\n  implicit none\n\n  type(fifo_head) :: thehead\n  type(fifo_node), dimension(5) :: ex, xe\n  integer :: i\n  \n  call new_fifo(thehead)\n\n  do i = 1, 5\n     ex(i)%datum = i\n     call fifo_enqueue(thehead, ex(i))\n  end do\n\n  i = 1\n  do\n     call fifo_dequeue(thehead, xe(i))\n     print *, xe(i)%datum\n     i = i + 1\n     if ( fifo_isempty(thehead) ) exit\n  end do\n\nend program FIFOTest\n", "target": "import java.util.LinkedList;\nimport java.util.Queue;\n...\nQueue<Integer> queue = new LinkedList<Integer>();\nSystem.out.println(queue.isEmpty());      \n\nqueue.add(1);\nqueue.add(2);\nqueue.add(3);\nSystem.out.println(queue);                \nSystem.out.println(queue.remove());       \nSystem.out.println(queue);                \nSystem.out.println(queue.isEmpty());      \n"}
{"id": 108141, "name": "Queue_Usage", "source": "Translate Fortran to Python: module fifo_nodes\n  type fifo_node\n     integer :: datum\n     \n     type(fifo_node), pointer :: next\n     logical :: valid\n  end type fifo_node\nend module fifo_nodes\n\nprogram FIFOTest\n  use fifo\n  implicit none\n\n  type(fifo_head) :: thehead\n  type(fifo_node), dimension(5) :: ex, xe\n  integer :: i\n  \n  call new_fifo(thehead)\n\n  do i = 1, 5\n     ex(i)%datum = i\n     call fifo_enqueue(thehead, ex(i))\n  end do\n\n  i = 1\n  do\n     call fifo_dequeue(thehead, xe(i))\n     print *, xe(i)%datum\n     i = i + 1\n     if ( fifo_isempty(thehead) ) exit\n  end do\n\nend program FIFOTest\n", "target": "let my_queue = Queue()\n\nmy_queue.push!('foo')\nmy_queue.push!('bar')\nmy_queue.push!('baz')\n\nprint my_queue.pop!() \nprint my_queue.pop!() \nprint my_queue.pop!() \n"}
{"id": 108780, "name": "Loops_Break", "source": "Translate Fortran to C#: program Example\n  implicit none\n\n  real :: r\n  integer :: a, b\n\n  do\n     call random_number(r)\n     a = int(r * 20)\n     write(*,*) a\n     if (a == 10) exit\n     call random_number(r)\n     b = int(r * 20)\n     write(*,*) b\n  end do\n\nend program Example\n", "target": "class Program\n{\n    static void Main(string[] args)\n    {\n        Random random = new Random();\n        while (true)\n        {\n            int a = random.Next(20);\n            Console.WriteLine(a);\n            if (a == 10)\n                break;\n            int b = random.Next(20)\n            Console.WriteLine(b);\n        }\n           \n        Console.ReadLine();\n    }       \n}\n"}
{"id": 108783, "name": "Loops_Break", "source": "Translate Fortran to Java: program Example\n  implicit none\n\n  real :: r\n  integer :: a, b\n\n  do\n     call random_number(r)\n     a = int(r * 20)\n     write(*,*) a\n     if (a == 10) exit\n     call random_number(r)\n     b = int(r * 20)\n     write(*,*) b\n  end do\n\nend program Example\n", "target": "import java.util.Random;\n\nRandom rand = new Random();\nwhile(true){\n    int a = rand.nextInt(20);\n    System.out.println(a);\n    if(a == 10) break;\n    int b = rand.nextInt(20);\n    System.out.println(b);\n}\n"}
{"id": 108784, "name": "Loops_Break", "source": "Translate Fortran to Python: program Example\n  implicit none\n\n  real :: r\n  integer :: a, b\n\n  do\n     call random_number(r)\n     a = int(r * 20)\n     write(*,*) a\n     if (a == 10) exit\n     call random_number(r)\n     b = int(r * 20)\n     write(*,*) b\n  end do\n\nend program Example\n", "target": "from random import randrange\n\nwhile True:\n    a = randrange(20)\n    print(a)\n    if a == 10:\n        break\n    b = randrange(20)\n    print(b)\n"}
{"id": 109029, "name": "Non-decimal radices_Convert", "source": "Translate Fortran to C#: MODULE Conversion\n  IMPLICIT NONE\n  CHARACTER(36) :: alphanum = \"0123456789abcdefghijklmnopqrstuvwxyz\"\n \n  CONTAINS\n\n  FUNCTION ToDecimal(base, instr)\n    INTEGER :: ToDecimal\n    INTEGER :: length, i, n, base\n    CHARACTER(*) :: instr\n\n    ToDecimal = 0\n    length = LEN(instr)\n    DO i = 1, length\n      n = INDEX(alphanum, instr(i:i)) - 1\n      n = n * base**(length-i)\n      Todecimal = ToDecimal + n\n    END DO\n  END FUNCTION ToDecimal\n\n  FUNCTION ToBase(base, number)\n    CHARACTER(31) :: ToBase\n    INTEGER :: base, number, i, rem\n\n    ToBase = \"                               \"\n    DO i = 31, 1, -1\n      IF(number < base) THEN\n        ToBase(i:i) = alphanum(number+1:number+1)\n        EXIT\n      END IF\n      rem = MOD(number, base)\n      ToBase(i:i) = alphanum(rem+1:rem+1)\n      number = number / base\n    END DO\n    ToBase = ADJUSTL(ToBase)\n  END FUNCTION ToBase\n\nEND MODULE Conversion\n\nPROGRAM Base_Convert\n  USE Conversion\n\n  WRITE (*,*) ToDecimal(16, \"1a\")\n  WRITE (*,*) ToBase(16, 26)     \n\nEND PROGRAM\n", "target": "public static class BaseConverter {\n\n    \n    \n    \n    \n    \n    \n    public static long stringToLong(string s, int b) {\n\n        if ( b < 2 || b > 36 )\n            throw new ArgumentException(\"Base must be between 2 and 36\", \"b\");\n\n        checked {\n\n            int slen = s.Length;\n            long result = 0;\n            bool isNegative = false;\n\n            for ( int i = 0; i < slen; i++ ) {\n\n                char c = s[i];\n                int num;\n\n                if ( c == '-' ) {\n                    \n                    if ( i != 0 )\n                        throw new ArgumentException(\"A negative sign is allowed only as the first character of the string.\", \"s\");\n\n                    isNegative = true;\n                    continue;\n                }\n\n                if ( c > 0x2F && c < 0x3A )\n                    \n                    num = c - 0x30;\n                else if ( c > 0x40 && c < 0x5B )\n                    \n                    \n                    num = c - 0x37;  \n                else if ( c > 0x60 && c < 0x7B )\n                    \n                    \n                    num = c - 0x57;  \n                else\n                    throw new ArgumentException(\"The string contains an invalid character '\" + c + \"'\", \"s\");\n\n                \n\n                if ( num >= b )\n                    throw new ArgumentException(\"The string contains a character '\" + c + \"' which is not allowed in base \" + b, \"s\");\n\n                \n\n                result *= b;\n                result += num;\n\n            }\n\n            if ( isNegative )\n                result = -result;\n\n            return result;\n\n        }\n\n    }\n\n    \n    \n    \n    \n    \n    \n    public static string longToString(long n, int b) {\n        \n        \n        \n        \n        if ( b < 2 || b > 36 )\n            throw new ArgumentException(\"Base must be between 2 and 36\", \"b\");\n\n        \n\n        if ( b == 10 )\n            return n.ToString();\n\n        checked {\n            long longBase = b;\n            \n            StringBuilder sb = new StringBuilder();\n            \n            if ( n < 0 ) {\n                \n                n = -n;\n                sb.Append('-');\n            }\n            \n            long div = 1;\n            while ( n / div >= b )\n                \n                \n                div *= b;\n            \n            while ( true ) {\n                byte digit = (byte) (n / div);\n            \n                if ( digit < 10 )\n                    \n                    sb.Append((char) (digit + 0x30));\n                else\n                    \n                    sb.Append((char) (digit + 0x57));  \n            \n                if ( div == 1 )\n                    \n                    break;\n            \n                n %= div;\n                div /= b;\n            }\n            \n            return sb.ToString();\n        }\n\n    }\n\n}\n"}
{"id": 109033, "name": "Non-decimal radices_Convert", "source": "Translate Fortran to Java: MODULE Conversion\n  IMPLICIT NONE\n  CHARACTER(36) :: alphanum = \"0123456789abcdefghijklmnopqrstuvwxyz\"\n \n  CONTAINS\n\n  FUNCTION ToDecimal(base, instr)\n    INTEGER :: ToDecimal\n    INTEGER :: length, i, n, base\n    CHARACTER(*) :: instr\n\n    ToDecimal = 0\n    length = LEN(instr)\n    DO i = 1, length\n      n = INDEX(alphanum, instr(i:i)) - 1\n      n = n * base**(length-i)\n      Todecimal = ToDecimal + n\n    END DO\n  END FUNCTION ToDecimal\n\n  FUNCTION ToBase(base, number)\n    CHARACTER(31) :: ToBase\n    INTEGER :: base, number, i, rem\n\n    ToBase = \"                               \"\n    DO i = 31, 1, -1\n      IF(number < base) THEN\n        ToBase(i:i) = alphanum(number+1:number+1)\n        EXIT\n      END IF\n      rem = MOD(number, base)\n      ToBase(i:i) = alphanum(rem+1:rem+1)\n      number = number / base\n    END DO\n    ToBase = ADJUSTL(ToBase)\n  END FUNCTION ToBase\n\nEND MODULE Conversion\n\nPROGRAM Base_Convert\n  USE Conversion\n\n  WRITE (*,*) ToDecimal(16, \"1a\")\n  WRITE (*,*) ToBase(16, 26)     \n\nEND PROGRAM\n", "target": "public static long backToTen(String num, int oldBase){\n   return Long.parseLong(num, oldBase); \n}\n\npublic static String tenToBase(long num, int newBase){\n   return Long.toString(num, newBase);\n}\n"}
{"id": 109034, "name": "Non-decimal radices_Convert", "source": "Translate Fortran to Python: MODULE Conversion\n  IMPLICIT NONE\n  CHARACTER(36) :: alphanum = \"0123456789abcdefghijklmnopqrstuvwxyz\"\n \n  CONTAINS\n\n  FUNCTION ToDecimal(base, instr)\n    INTEGER :: ToDecimal\n    INTEGER :: length, i, n, base\n    CHARACTER(*) :: instr\n\n    ToDecimal = 0\n    length = LEN(instr)\n    DO i = 1, length\n      n = INDEX(alphanum, instr(i:i)) - 1\n      n = n * base**(length-i)\n      Todecimal = ToDecimal + n\n    END DO\n  END FUNCTION ToDecimal\n\n  FUNCTION ToBase(base, number)\n    CHARACTER(31) :: ToBase\n    INTEGER :: base, number, i, rem\n\n    ToBase = \"                               \"\n    DO i = 31, 1, -1\n      IF(number < base) THEN\n        ToBase(i:i) = alphanum(number+1:number+1)\n        EXIT\n      END IF\n      rem = MOD(number, base)\n      ToBase(i:i) = alphanum(rem+1:rem+1)\n      number = number / base\n    END DO\n    ToBase = ADJUSTL(ToBase)\n  END FUNCTION ToBase\n\nEND MODULE Conversion\n\nPROGRAM Base_Convert\n  USE Conversion\n\n  WRITE (*,*) ToDecimal(16, \"1a\")\n  WRITE (*,*) ToBase(16, 26)     \n\nEND PROGRAM\n", "target": "i = int('1a',16)  \n"}
{"id": 109453, "name": "Factors of an integer", "source": "Translate Fortran to C#: program Factors\n  implicit none\n  integer :: i, number\n  \n  write(*,*) \"Enter a number between 1 and 2147483647\"\n  read*, number\n\n  do i = 1, int(sqrt(real(number))) - 1\n    if (mod(number, i) == 0) write (*,*) i, number/i\n  end do\n  \n  \n  i = int(sqrt(real(number))) \n  if (i*i == number) then\n     write (*,*) i\n  else if (mod(number, i) == 0) then\n     write (*,*) i, number/i\n  end if\n    \nend program\n", "target": "static void Main (string[] args) {\n    do {\n        Console.WriteLine (\"Number:\");\n        Int64 p = 0;\n        do {\n            try {\n                p = Convert.ToInt64 (Console.ReadLine ());\n                break;\n            } catch (Exception) { }\n\n        } while (true);\n\n        Console.WriteLine (\"For 1 through \" + ((int) Math.Sqrt (p)).ToString () + \"\");\n        for (int x = 1; x <= (int) Math.Sqrt (p); x++) {\n            if (p % x == 0)\n                Console.WriteLine (\"Found: \" + x.ToString () + \". \" + p.ToString () + \" / \" + x.ToString () + \" = \" + (p / x).ToString ());\n        }\n\n        Console.WriteLine (\"Done.\");\n    } while (true);\n}\n"}
{"id": 109456, "name": "Factors of an integer", "source": "Translate Fortran to Java: program Factors\n  implicit none\n  integer :: i, number\n  \n  write(*,*) \"Enter a number between 1 and 2147483647\"\n  read*, number\n\n  do i = 1, int(sqrt(real(number))) - 1\n    if (mod(number, i) == 0) write (*,*) i, number/i\n  end do\n  \n  \n  i = int(sqrt(real(number))) \n  if (i*i == number) then\n     write (*,*) i\n  else if (mod(number, i) == 0) then\n     write (*,*) i, number/i\n  end if\n    \nend program\n", "target": "public static TreeSet<Long> factors(long n)\n{\n TreeSet<Long> factors = new TreeSet<Long>();\n factors.add(n);\n factors.add(1L);\n for(long test = n - 1; test >= Math.sqrt(n); test--)\n  if(n % test == 0)\n  {\n   factors.add(test);\n   factors.add(n / test);\n  }\n return factors;\n}\n"}
{"id": 109457, "name": "Factors of an integer", "source": "Translate Fortran to Python: program Factors\n  implicit none\n  integer :: i, number\n  \n  write(*,*) \"Enter a number between 1 and 2147483647\"\n  read*, number\n\n  do i = 1, int(sqrt(real(number))) - 1\n    if (mod(number, i) == 0) write (*,*) i, number/i\n  end do\n  \n  \n  i = int(sqrt(real(number))) \n  if (i*i == number) then\n     write (*,*) i\n  else if (mod(number, i) == 0) then\n     write (*,*) i, number/i\n  end if\n    \nend program\n", "target": ">>> def factors(n):\n      return [i for i in range(1, n + 1) if not n%i]\n"}
{"id": 111030, "name": "Take notes on the command line", "source": "Translate Fortran to C#: program notes\nimplicit none\ninteger                      :: i, length, iargs, lun, ios\ninteger,dimension(8)         :: values\ncharacter(len=:),allocatable :: arg\ncharacter(len=256)           :: line\ncharacter(len=1),parameter   :: tab=char(9)\n   iargs = command_argument_count()\n   open(file='notes.txt',newunit=lun,action='readwrite',position='append',status='unknown')\n   if(iargs.eq.0)then\n      rewind(lun)\n      do\n         read(lun,'(a)',iostat=ios)line\n         if(ios.ne.0)exit\n         write(*,'(a)')trim(line)\n      enddo\n   else\n      call date_and_time(VALUES=values)\n      write(lun,'(*(g0))')values(1),\"-\",values(2),\"-\",values(3),\"T\",values(5),\":\",values(6),\":\",values(7)\n      write(lun,'(a)',advance='no')tab\n      do i=1,iargs\n         call get_command_argument(number=i,length=length)\n         arg=repeat(' ',length)\n         call get_command_argument(i, arg)\n         write(lun,'(a,1x)',advance='no')arg\n      enddo\n      write(lun,*)\n   endif\nend program notes\n", "target": "using System;\nusing System.IO;\nusing System.Text;\n\nnamespace RosettaCode\n{\n  internal class Program\n  {\n    private const string FileName = \"NOTES.TXT\";\n\n    private static void Main(string[] args)\n    {\n      if (args.Length==0)\n      {\n        string txt = File.ReadAllText(FileName);\n        Console.WriteLine(txt);\n      }\n      else\n      {\n        var sb = new StringBuilder();\n        sb.Append(DateTime.Now).Append(\"\\n\\t\");\n        foreach (string s in args)\n          sb.Append(s).Append(\" \");\n        sb.Append(\"\\n\");\n\n        if (File.Exists(FileName))\n          File.AppendAllText(FileName, sb.ToString());\n        else\n          File.WriteAllText(FileName, sb.ToString());\n      }\n    }\n  }\n}\n"}
{"id": 111033, "name": "Take notes on the command line", "source": "Translate Fortran to Java: program notes\nimplicit none\ninteger                      :: i, length, iargs, lun, ios\ninteger,dimension(8)         :: values\ncharacter(len=:),allocatable :: arg\ncharacter(len=256)           :: line\ncharacter(len=1),parameter   :: tab=char(9)\n   iargs = command_argument_count()\n   open(file='notes.txt',newunit=lun,action='readwrite',position='append',status='unknown')\n   if(iargs.eq.0)then\n      rewind(lun)\n      do\n         read(lun,'(a)',iostat=ios)line\n         if(ios.ne.0)exit\n         write(*,'(a)')trim(line)\n      enddo\n   else\n      call date_and_time(VALUES=values)\n      write(lun,'(*(g0))')values(1),\"-\",values(2),\"-\",values(3),\"T\",values(5),\":\",values(6),\":\",values(7)\n      write(lun,'(a)',advance='no')tab\n      do i=1,iargs\n         call get_command_argument(number=i,length=length)\n         arg=repeat(' ',length)\n         call get_command_argument(i, arg)\n         write(lun,'(a,1x)',advance='no')arg\n      enddo\n      write(lun,*)\n   endif\nend program notes\n", "target": "import java.io.*;\nimport java.nio.channels.*;\nimport java.util.Date;\n\npublic class TakeNotes {\n    public static void main(String[] args) throws IOException {\n        if (args.length > 0) {\n            PrintStream ps = new PrintStream(new FileOutputStream(\"notes.txt\", true));\n            ps.println(new Date());\n            ps.print(\"\\t\" + args[0]);\n            for (int i = 1; i < args.length; i++)\n                ps.print(\" \" + args[i]);\n            ps.println();\n            ps.close();\n        } else {\n            FileChannel fc = new FileInputStream(\"notes.txt\").getChannel();\n            fc.transferTo(0, fc.size(), Channels.newChannel(System.out));\n            fc.close();\n        }\n    }\n}\n"}
{"id": 111034, "name": "Take notes on the command line", "source": "Translate Fortran to Python: program notes\nimplicit none\ninteger                      :: i, length, iargs, lun, ios\ninteger,dimension(8)         :: values\ncharacter(len=:),allocatable :: arg\ncharacter(len=256)           :: line\ncharacter(len=1),parameter   :: tab=char(9)\n   iargs = command_argument_count()\n   open(file='notes.txt',newunit=lun,action='readwrite',position='append',status='unknown')\n   if(iargs.eq.0)then\n      rewind(lun)\n      do\n         read(lun,'(a)',iostat=ios)line\n         if(ios.ne.0)exit\n         write(*,'(a)')trim(line)\n      enddo\n   else\n      call date_and_time(VALUES=values)\n      write(lun,'(*(g0))')values(1),\"-\",values(2),\"-\",values(3),\"T\",values(5),\":\",values(6),\":\",values(7)\n      write(lun,'(a)',advance='no')tab\n      do i=1,iargs\n         call get_command_argument(number=i,length=length)\n         arg=repeat(' ',length)\n         call get_command_argument(i, arg)\n         write(lun,'(a,1x)',advance='no')arg\n      enddo\n      write(lun,*)\n   endif\nend program notes\n", "target": "import sys, datetime, shutil\n\nif len(sys.argv) == 1:\n    try:\n        with open('notes.txt', 'r') as f:\n            shutil.copyfileobj(f, sys.stdout)\n    except IOError:\n        pass\nelse:\n    with open('notes.txt', 'a') as f:\n        f.write(datetime.datetime.now().isoformat() + '\\n')\n        f.write(\"\\t%s\\n\" % ' '.join(sys.argv[1:]))\n"}
{"id": 111620, "name": "Sort using a custom comparator", "source": "Translate Fortran to C#: module sorts_with_custom_comparator\n  implicit none\ncontains\n  subroutine a_sort(a, cc)\n    character(len=*), dimension(:), intent(inout) :: a\n    interface\n       integer function cc(a, b)\n         character(len=*), intent(in) :: a, b\n       end function cc\n    end interface\n    \n    integer :: i, j, increment\n    character(len=max(len(a), 10)) :: temp\n    \n    increment = size(a) / 2\n    do while ( increment > 0 )\n       do i = increment+1, size(a)\n          j = i\n          temp = a(i)\n          do while ( j >= increment+1 .and. cc(a(j-increment), temp) > 0)\n             a(j) = a(j-increment)\n             j = j - increment\n          end do\n          a(j) = temp\n       end do\n       if ( increment == 2 ) then\n          increment = 1\n       else\n          increment = increment * 5 / 11\n       end if\n    end do\n  end subroutine a_sort\nend module sorts_with_custom_comparator\n", "target": "using System;\nusing System.Collections.Generic;\n\nnamespace RosettaCode {\n    class SortCustomComparator {\n        \n        public void CustomSort() {\n            String[] items = { \"Here\", \"are\", \"some\", \"sample\", \"strings\", \"to\", \"be\", \"sorted\" };\n            List<String> list = new List<string>(items);\n\n            DisplayList(\"Unsorted\", list);\n            \n            list.Sort(CustomCompare);\n            DisplayList(\"Descending Length\", list);\n\n            list.Sort();\n            DisplayList(\"Ascending order\", list);\n        }\n\n        \n        public int CustomCompare(String x, String y) {\n            int result = -x.Length.CompareTo(y.Length);\n            if (result == 0) {\n                result = x.ToLower().CompareTo(y.ToLower());\n            }\n\n            return result;\n        }\n\n        \n        public void DisplayList(String header, List<String> theList) {\n            Console.WriteLine(header);\n            Console.WriteLine(\"\".PadLeft(header.Length, '*'));\n            foreach (String str in theList) {\n                Console.WriteLine(str);\n            }\n            Console.WriteLine();\n        }\n    }\n}\n"}
{"id": 111623, "name": "Sort using a custom comparator", "source": "Translate Fortran to Java: module sorts_with_custom_comparator\n  implicit none\ncontains\n  subroutine a_sort(a, cc)\n    character(len=*), dimension(:), intent(inout) :: a\n    interface\n       integer function cc(a, b)\n         character(len=*), intent(in) :: a, b\n       end function cc\n    end interface\n    \n    integer :: i, j, increment\n    character(len=max(len(a), 10)) :: temp\n    \n    increment = size(a) / 2\n    do while ( increment > 0 )\n       do i = increment+1, size(a)\n          j = i\n          temp = a(i)\n          do while ( j >= increment+1 .and. cc(a(j-increment), temp) > 0)\n             a(j) = a(j-increment)\n             j = j - increment\n          end do\n          a(j) = temp\n       end do\n       if ( increment == 2 ) then\n          increment = 1\n       else\n          increment = increment * 5 / 11\n       end if\n    end do\n  end subroutine a_sort\nend module sorts_with_custom_comparator\n", "target": "import java.util.Comparator;\nimport java.util.Arrays;\n\npublic class Test {\n  public static void main(String[] args) {\n    String[] strings = {\"Here\", \"are\", \"some\", \"sample\", \"strings\", \"to\", \"be\", \"sorted\"};\n\n    Arrays.sort(strings, new Comparator<String>() {\n      public int compare(String s1, String s2) {\n        int c = s2.length() - s1.length();\n        if (c == 0)\n          c = s1.compareToIgnoreCase(s2);\n        return c;\n      }\n    });\n\n    for (String s: strings)\n      System.out.print(s + \" \");\n  }\n}\n"}
{"id": 111624, "name": "Sort using a custom comparator", "source": "Translate Fortran to Python: module sorts_with_custom_comparator\n  implicit none\ncontains\n  subroutine a_sort(a, cc)\n    character(len=*), dimension(:), intent(inout) :: a\n    interface\n       integer function cc(a, b)\n         character(len=*), intent(in) :: a, b\n       end function cc\n    end interface\n    \n    integer :: i, j, increment\n    character(len=max(len(a), 10)) :: temp\n    \n    increment = size(a) / 2\n    do while ( increment > 0 )\n       do i = increment+1, size(a)\n          j = i\n          temp = a(i)\n          do while ( j >= increment+1 .and. cc(a(j-increment), temp) > 0)\n             a(j) = a(j-increment)\n             j = j - increment\n          end do\n          a(j) = temp\n       end do\n       if ( increment == 2 ) then\n          increment = 1\n       else\n          increment = increment * 5 / 11\n       end if\n    end do\n  end subroutine a_sort\nend module sorts_with_custom_comparator\n", "target": "strings = \"here are Some sample strings to be sorted\".split()\n\ndef mykey(x):\n    return -len(x), x.upper()\n\nprint sorted(strings, key=mykey)\n"}
{"id": 111868, "name": "Feigenbaum constant calculation", "source": "Translate Fortran to C#:       program feigenbaum\n      implicit none\n\n      integer i, j, k\n      real ( KIND = 16 ) x, y, a, b, a1, a2, d1\n\n      print '(a4,a13)', 'i', 'd'\n\n      a1 = 1.0;\n      a2 = 0.0;\n      d1 = 3.2;\n\n      do i=2,20\n         a = a1 + (a1 - a2) / d1;\n         do j=1,10\n            x = 0\n            y = 0\n            do k=1,2**i\n                y = 1 - 2 * y * x;\n                x = a - x**2;\n            end do\n            a = a - x / y;\n         end do\n\n         d1 = (a1 - a2) / (a - a1);\n         a2 = a1;\n         a1 = a;\n         print '(i4,f13.10)', i, d1\n     end do\n     end\n", "target": "using System;\n\nnamespace FeigenbaumConstant {\n    class Program {\n        static void Main(string[] args) {\n            var maxIt = 13;\n            var maxItJ = 10;\n            var a1 = 1.0;\n            var a2 = 0.0;\n            var d1 = 3.2;\n            Console.WriteLine(\" i       d\");\n            for (int i = 2; i <= maxIt; i++) {\n                var a = a1 + (a1 - a2) / d1;\n                for (int j = 1; j <= maxItJ; j++) {\n                    var x = 0.0;\n                    var y = 0.0;\n                    for (int k = 1; k <= 1<<i; k++) {\n                        y = 1.0 - 2.0 * y * x;\n                        x = a - x * x;\n                    }\n                    a -= x / y;\n                }\n                var d = (a1 - a2) / (a - a1);\n                Console.WriteLine(\"{0,2:d}    {1:f8}\", i, d);\n                d1 = d;\n                a2 = a1;\n                a1 = a;\n            }\n        }\n    }\n}\n"}
{"id": 111869, "name": "Feigenbaum constant calculation", "source": "Translate Fortran to C#:       program feigenbaum\n      implicit none\n\n      integer i, j, k\n      real ( KIND = 16 ) x, y, a, b, a1, a2, d1\n\n      print '(a4,a13)', 'i', 'd'\n\n      a1 = 1.0;\n      a2 = 0.0;\n      d1 = 3.2;\n\n      do i=2,20\n         a = a1 + (a1 - a2) / d1;\n         do j=1,10\n            x = 0\n            y = 0\n            do k=1,2**i\n                y = 1 - 2 * y * x;\n                x = a - x**2;\n            end do\n            a = a - x / y;\n         end do\n\n         d1 = (a1 - a2) / (a - a1);\n         a2 = a1;\n         a1 = a;\n         print '(i4,f13.10)', i, d1\n     end do\n     end\n", "target": "using System;\n\nnamespace FeigenbaumConstant {\n    class Program {\n        static void Main(string[] args) {\n            var maxIt = 13;\n            var maxItJ = 10;\n            var a1 = 1.0;\n            var a2 = 0.0;\n            var d1 = 3.2;\n            Console.WriteLine(\" i       d\");\n            for (int i = 2; i <= maxIt; i++) {\n                var a = a1 + (a1 - a2) / d1;\n                for (int j = 1; j <= maxItJ; j++) {\n                    var x = 0.0;\n                    var y = 0.0;\n                    for (int k = 1; k <= 1<<i; k++) {\n                        y = 1.0 - 2.0 * y * x;\n                        x = a - x * x;\n                    }\n                    a -= x / y;\n                }\n                var d = (a1 - a2) / (a - a1);\n                Console.WriteLine(\"{0,2:d}    {1:f8}\", i, d);\n                d1 = d;\n                a2 = a1;\n                a1 = a;\n            }\n        }\n    }\n}\n"}
{"id": 111874, "name": "Feigenbaum constant calculation", "source": "Translate Fortran to Java:       program feigenbaum\n      implicit none\n\n      integer i, j, k\n      real ( KIND = 16 ) x, y, a, b, a1, a2, d1\n\n      print '(a4,a13)', 'i', 'd'\n\n      a1 = 1.0;\n      a2 = 0.0;\n      d1 = 3.2;\n\n      do i=2,20\n         a = a1 + (a1 - a2) / d1;\n         do j=1,10\n            x = 0\n            y = 0\n            do k=1,2**i\n                y = 1 - 2 * y * x;\n                x = a - x**2;\n            end do\n            a = a - x / y;\n         end do\n\n         d1 = (a1 - a2) / (a - a1);\n         a2 = a1;\n         a1 = a;\n         print '(i4,f13.10)', i, d1\n     end do\n     end\n", "target": "public class Feigenbaum {\n    public static void main(String[] args) {\n        int max_it = 13;\n        int max_it_j = 10;\n        double a1 = 1.0;\n        double a2 = 0.0;\n        double d1 = 3.2;\n        double a;\n\n        System.out.println(\" i       d\");\n        for (int i = 2; i <= max_it; i++) {\n            a = a1 + (a1 - a2) / d1;\n            for (int j = 0; j < max_it_j; j++) {\n                double x = 0.0;\n                double y = 0.0;\n                for (int k = 0; k < 1 << i; k++) {\n                    y = 1.0 - 2.0 * y * x;\n                    x = a - x * x;\n                }\n                a -= x / y;\n            }\n            double d = (a1 - a2) / (a - a1);\n            System.out.printf(\"%2d   \u00a0%.8f\\n\", i, d);\n            d1 = d;\n            a2 = a1;\n            a1 = a;\n        }\n    }\n}\n"}
{"id": 111875, "name": "Feigenbaum constant calculation", "source": "Translate Fortran to Java:       program feigenbaum\n      implicit none\n\n      integer i, j, k\n      real ( KIND = 16 ) x, y, a, b, a1, a2, d1\n\n      print '(a4,a13)', 'i', 'd'\n\n      a1 = 1.0;\n      a2 = 0.0;\n      d1 = 3.2;\n\n      do i=2,20\n         a = a1 + (a1 - a2) / d1;\n         do j=1,10\n            x = 0\n            y = 0\n            do k=1,2**i\n                y = 1 - 2 * y * x;\n                x = a - x**2;\n            end do\n            a = a - x / y;\n         end do\n\n         d1 = (a1 - a2) / (a - a1);\n         a2 = a1;\n         a1 = a;\n         print '(i4,f13.10)', i, d1\n     end do\n     end\n", "target": "public class Feigenbaum {\n    public static void main(String[] args) {\n        int max_it = 13;\n        int max_it_j = 10;\n        double a1 = 1.0;\n        double a2 = 0.0;\n        double d1 = 3.2;\n        double a;\n\n        System.out.println(\" i       d\");\n        for (int i = 2; i <= max_it; i++) {\n            a = a1 + (a1 - a2) / d1;\n            for (int j = 0; j < max_it_j; j++) {\n                double x = 0.0;\n                double y = 0.0;\n                for (int k = 0; k < 1 << i; k++) {\n                    y = 1.0 - 2.0 * y * x;\n                    x = a - x * x;\n                }\n                a -= x / y;\n            }\n            double d = (a1 - a2) / (a - a1);\n            System.out.printf(\"%2d   \u00a0%.8f\\n\", i, d);\n            d1 = d;\n            a2 = a1;\n            a1 = a;\n        }\n    }\n}\n"}
{"id": 111876, "name": "Feigenbaum constant calculation", "source": "Translate Fortran to Python:       program feigenbaum\n      implicit none\n\n      integer i, j, k\n      real ( KIND = 16 ) x, y, a, b, a1, a2, d1\n\n      print '(a4,a13)', 'i', 'd'\n\n      a1 = 1.0;\n      a2 = 0.0;\n      d1 = 3.2;\n\n      do i=2,20\n         a = a1 + (a1 - a2) / d1;\n         do j=1,10\n            x = 0\n            y = 0\n            do k=1,2**i\n                y = 1 - 2 * y * x;\n                x = a - x**2;\n            end do\n            a = a - x / y;\n         end do\n\n         d1 = (a1 - a2) / (a - a1);\n         a2 = a1;\n         a1 = a;\n         print '(i4,f13.10)', i, d1\n     end do\n     end\n", "target": "max_it = 13\nmax_it_j = 10\na1 = 1.0\na2 = 0.0\nd1 = 3.2\na = 0.0\n\nprint \" i       d\"\nfor i in range(2, max_it + 1):\n    a = a1 + (a1 - a2) / d1\n    for j in range(1, max_it_j + 1):\n        x = 0.0\n        y = 0.0\n        for k in range(1, (1 << i) + 1):\n            y = 1.0 - 2.0 * y * x\n            x = a - x * x\n        a = a - x / y\n    d = (a1 - a2) / (a - a1)\n    print(\"{0:2d}    {1:.8f}\".format(i, d))\n    d1 = d\n    a2 = a1\n    a1 = a\n"}
{"id": 111877, "name": "Feigenbaum constant calculation", "source": "Translate Fortran to Python:       program feigenbaum\n      implicit none\n\n      integer i, j, k\n      real ( KIND = 16 ) x, y, a, b, a1, a2, d1\n\n      print '(a4,a13)', 'i', 'd'\n\n      a1 = 1.0;\n      a2 = 0.0;\n      d1 = 3.2;\n\n      do i=2,20\n         a = a1 + (a1 - a2) / d1;\n         do j=1,10\n            x = 0\n            y = 0\n            do k=1,2**i\n                y = 1 - 2 * y * x;\n                x = a - x**2;\n            end do\n            a = a - x / y;\n         end do\n\n         d1 = (a1 - a2) / (a - a1);\n         a2 = a1;\n         a1 = a;\n         print '(i4,f13.10)', i, d1\n     end do\n     end\n", "target": "max_it = 13\nmax_it_j = 10\na1 = 1.0\na2 = 0.0\nd1 = 3.2\na = 0.0\n\nprint \" i       d\"\nfor i in range(2, max_it + 1):\n    a = a1 + (a1 - a2) / d1\n    for j in range(1, max_it_j + 1):\n        x = 0.0\n        y = 0.0\n        for k in range(1, (1 << i) + 1):\n            y = 1.0 - 2.0 * y * x\n            x = a - x * x\n        a = a - x / y\n    d = (a1 - a2) / (a - a1)\n    print(\"{0:2d}    {1:.8f}\".format(i, d))\n    d1 = d\n    a2 = a1\n    a1 = a\n"}
{"id": 112087, "name": "Memory allocation", "source": "Translate Fortran to C#: program allocation_test\n    implicit none\n    real, dimension(:), allocatable :: vector\n    real, dimension(:, :), allocatable :: matrix\n    real, pointer :: ptr\n    integer, parameter :: n = 100 \n\n    allocate(vector(n))      \n    allocate(matrix(n, n))   \n    allocate(ptr)            \n\n    deallocate(vector)       \n    deallocate(matrix)       \n    deallocate(ptr)          \nend program allocation_test\n", "target": "using System;\nusing System.Runtime.InteropServices;\n\npublic unsafe class Program\n{\n    public static unsafe void HeapMemory()\n    {\n        const int HEAP_ZERO_MEMORY = 0x00000008;\n        const int size = 1000;\n        int ph = GetProcessHeap();\n        void* pointer = HeapAlloc(ph, HEAP_ZERO_MEMORY, size);\n        if (pointer == null)\n            throw new OutOfMemoryException();\n        Console.WriteLine(HeapSize(ph, 0, pointer));\n        HeapFree(ph, 0, pointer);\n    }\n\n    public static unsafe void StackMemory()\n    {\n        byte* buffer = stackalloc byte[1000];\n        \n    }\n    public static void Main(string[] args)\n    {\n        HeapMemory();\n        StackMemory();\n    }\n    [DllImport(\"kernel32\")]\n    static extern void* HeapAlloc(int hHeap, int flags, int size);\n    [DllImport(\"kernel32\")]\n    static extern bool HeapFree(int hHeap, int flags, void* block);\n    [DllImport(\"kernel32\")]\n    static extern int GetProcessHeap();\n    [DllImport(\"kernel32\")]\n    static extern int HeapSize(int hHeap, int flags, void* block);\n\n}\n"}
{"id": 112090, "name": "Memory allocation", "source": "Translate Fortran to Java: program allocation_test\n    implicit none\n    real, dimension(:), allocatable :: vector\n    real, dimension(:, :), allocatable :: matrix\n    real, pointer :: ptr\n    integer, parameter :: n = 100 \n\n    allocate(vector(n))      \n    allocate(matrix(n, n))   \n    allocate(ptr)            \n\n    deallocate(vector)       \n    deallocate(matrix)       \n    deallocate(ptr)          \nend program allocation_test\n", "target": "\n\nObject foo = new Object(); \nint[] fooArray = new int[size]; \nint x = 0; \n"}
{"id": 112091, "name": "Memory allocation", "source": "Translate Fortran to Python: program allocation_test\n    implicit none\n    real, dimension(:), allocatable :: vector\n    real, dimension(:, :), allocatable :: matrix\n    real, pointer :: ptr\n    integer, parameter :: n = 100 \n\n    allocate(vector(n))      \n    allocate(matrix(n, n))   \n    allocate(ptr)            \n\n    deallocate(vector)       \n    deallocate(matrix)       \n    deallocate(ptr)          \nend program allocation_test\n", "target": ">>> from array import array\n>>> argslist = [('l', []), ('c', 'hello world'), ('u', u'hello \\u2641'),\n\t('l', [1, 2, 3, 4, 5]), ('d', [1.0, 2.0, 3.14])]\n>>> for typecode, initializer in argslist:\n\ta = array(typecode, initializer)\n\tprint a\n\tdel a\n\n\t\narray('l')\narray('c', 'hello world')\narray('u', u'hello \\u2641')\narray('l', [1, 2, 3, 4, 5])\narray('d', [1.0, 2.0, 3.1400000000000001])\n>>>\n"}
{"id": 112283, "name": "Stair-climbing puzzle", "source": "Translate Fortran to C#: module StairRobot\n  implicit none\n\ncontains\n\n  logical function step()\n    \n    step = .true.     \n  end function step\n\n  recursive subroutine step_up_rec\n    do while ( .not. step() )\n       call step_up_rec\n    end do\n  end subroutine step_up_rec\n\n  subroutine step_up_iter\n    integer :: i = 0\n    do while ( i < 1 )\n       if ( step() ) then\n          i = i + 1\n       else\n          i = i - 1\n       end if\n    end do\n  end subroutine step_up_iter\n\nend module StairRobot\n", "target": "void step_up() {\n    while (!step()) step_up();\n}\n"}
{"id": 112284, "name": "Stair-climbing puzzle", "source": "Translate Fortran to C#: module StairRobot\n  implicit none\n\ncontains\n\n  logical function step()\n    \n    step = .true.     \n  end function step\n\n  recursive subroutine step_up_rec\n    do while ( .not. step() )\n       call step_up_rec\n    end do\n  end subroutine step_up_rec\n\n  subroutine step_up_iter\n    integer :: i = 0\n    do while ( i < 1 )\n       if ( step() ) then\n          i = i + 1\n       else\n          i = i - 1\n       end if\n    end do\n  end subroutine step_up_iter\n\nend module StairRobot\n", "target": "void step_up() {\n    while (!step()) step_up();\n}\n"}
{"id": 112290, "name": "Stair-climbing puzzle", "source": "Translate Fortran to Java: module StairRobot\n  implicit none\n\ncontains\n\n  logical function step()\n    \n    step = .true.     \n  end function step\n\n  recursive subroutine step_up_rec\n    do while ( .not. step() )\n       call step_up_rec\n    end do\n  end subroutine step_up_rec\n\n  subroutine step_up_iter\n    integer :: i = 0\n    do while ( i < 1 )\n       if ( step() ) then\n          i = i + 1\n       else\n          i = i - 1\n       end if\n    end do\n  end subroutine step_up_iter\n\nend module StairRobot\n", "target": "public void stepUp() {\n  while (!step()) stepUp();\n}\n"}
{"id": 112291, "name": "Stair-climbing puzzle", "source": "Translate Fortran to Java: module StairRobot\n  implicit none\n\ncontains\n\n  logical function step()\n    \n    step = .true.     \n  end function step\n\n  recursive subroutine step_up_rec\n    do while ( .not. step() )\n       call step_up_rec\n    end do\n  end subroutine step_up_rec\n\n  subroutine step_up_iter\n    integer :: i = 0\n    do while ( i < 1 )\n       if ( step() ) then\n          i = i + 1\n       else\n          i = i - 1\n       end if\n    end do\n  end subroutine step_up_iter\n\nend module StairRobot\n", "target": "public void stepUp() {\n  while (!step()) stepUp();\n}\n"}
{"id": 112292, "name": "Stair-climbing puzzle", "source": "Translate Fortran to Python: module StairRobot\n  implicit none\n\ncontains\n\n  logical function step()\n    \n    step = .true.     \n  end function step\n\n  recursive subroutine step_up_rec\n    do while ( .not. step() )\n       call step_up_rec\n    end do\n  end subroutine step_up_rec\n\n  subroutine step_up_iter\n    integer :: i = 0\n    do while ( i < 1 )\n       if ( step() ) then\n          i = i + 1\n       else\n          i = i - 1\n       end if\n    end do\n  end subroutine step_up_iter\n\nend module StairRobot\n", "target": "def step_up1():\n  \n  deficit = 1\n  while deficit > 0:\n    if step():\n      deficit -= 1\n    else:\n      deficit += 1\n"}
{"id": 112293, "name": "Stair-climbing puzzle", "source": "Translate Fortran to Python: module StairRobot\n  implicit none\n\ncontains\n\n  logical function step()\n    \n    step = .true.     \n  end function step\n\n  recursive subroutine step_up_rec\n    do while ( .not. step() )\n       call step_up_rec\n    end do\n  end subroutine step_up_rec\n\n  subroutine step_up_iter\n    integer :: i = 0\n    do while ( i < 1 )\n       if ( step() ) then\n          i = i + 1\n       else\n          i = i - 1\n       end if\n    end do\n  end subroutine step_up_iter\n\nend module StairRobot\n", "target": "def step_up1():\n  \n  deficit = 1\n  while deficit > 0:\n    if step():\n      deficit -= 1\n    else:\n      deficit += 1\n"}
{"id": 112539, "name": "Hostname", "source": "Translate Fortran to C#: program HostTest\n  character(len=128) :: name \n  call hostnm(name)\n  print *, name\nend program HostTest\n", "target": "System.Net.Dns.GetHostName();\n"}
{"id": 112541, "name": "Hostname", "source": "Translate Fortran to Java: program HostTest\n  character(len=128) :: name \n  call hostnm(name)\n  print *, name\nend program HostTest\n", "target": "import java.net.*;\nclass DiscoverHostName {\n public static void main(final String[] args) {\n  try {\n   System.out.println(InetAddress.getLocalHost().getHostName());\n  } catch (UnknownHostException e) { \n  }\n }\n}\n"}
{"id": 112542, "name": "Hostname", "source": "Translate Fortran to Python: program HostTest\n  character(len=128) :: name \n  call hostnm(name)\n  print *, name\nend program HostTest\n", "target": "import socket\nhost = socket.gethostname()\n"}
{"id": 112730, "name": "Guess the number", "source": "Translate Fortran to C#: program guess_the_number\n implicit none\n\n integer                          :: guess\n real                             :: r\n integer                          :: i, clock, count, n\n integer,dimension(:),allocatable :: seed\n\n real,parameter :: rmax = 10\t\n\n\n call random_seed(size=n)\n allocate(seed(n))\n call system_clock(count)\n seed = count\n call random_seed(put=seed)\n deallocate(seed)\n\n\n call random_number(r)          \n i = int((rmax-1.0)*r + 1.0)    \n\n\n write(*,'(A)') 'I''m thinking of a number between 1 and 10.'\n do   \n\twrite(*,'(A)',advance='NO') 'Enter Guess: '\n\tread(*,'(I5)') guess\n\tif (guess==i) exit\n\twrite(*,*) 'Sorry, try again.'\n end do\n\n write(*,*) 'You''ve guessed my number\n\nend program guess_the_number\n", "target": "using System;\n\nclass GuessTheNumberGame\n{\n    static void Main()\n    {\n        int randomNumber = new Random().Next(1, 11);\n        \n        Console.WriteLine(\"I'm thinking of a number between 1 and 10. Can you guess it?\");\n        while(true)\n        {\n            Console.Write(\"Guess: \");\n            if (int.Parse(Console.ReadLine()) == randomNumber)\n                break;\n            Console.WriteLine(\"That's not it. Guess again.\");\n        }\n        Console.WriteLine(\"Congrats!! You guessed right!\");\n    }\n};\n"}
{"id": 112733, "name": "Guess the number", "source": "Translate Fortran to Java: program guess_the_number\n implicit none\n\n integer                          :: guess\n real                             :: r\n integer                          :: i, clock, count, n\n integer,dimension(:),allocatable :: seed\n\n real,parameter :: rmax = 10\t\n\n\n call random_seed(size=n)\n allocate(seed(n))\n call system_clock(count)\n seed = count\n call random_seed(put=seed)\n deallocate(seed)\n\n\n call random_number(r)          \n i = int((rmax-1.0)*r + 1.0)    \n\n\n write(*,'(A)') 'I''m thinking of a number between 1 and 10.'\n do   \n\twrite(*,'(A)',advance='NO') 'Enter Guess: '\n\tread(*,'(I5)') guess\n\tif (guess==i) exit\n\twrite(*,*) 'Sorry, try again.'\n end do\n\n write(*,*) 'You''ve guessed my number\n\nend program guess_the_number\n", "target": "public class Guessing {\n    public static void main(String[] args) throws NumberFormatException{\n        int n = (int)(Math.random() * 10 + 1);\n        System.out.print(\"Guess the number between 1 and 10: \");\n        while(Integer.parseInt(System.console().readLine()) != n){\n            System.out.print(\"Wrong! Guess again: \");\n        }\n        System.out.println(\"Well guessed!\");\n    }\n}\n"}
{"id": 112734, "name": "Guess the number", "source": "Translate Fortran to Python: program guess_the_number\n implicit none\n\n integer                          :: guess\n real                             :: r\n integer                          :: i, clock, count, n\n integer,dimension(:),allocatable :: seed\n\n real,parameter :: rmax = 10\t\n\n\n call random_seed(size=n)\n allocate(seed(n))\n call system_clock(count)\n seed = count\n call random_seed(put=seed)\n deallocate(seed)\n\n\n call random_number(r)          \n i = int((rmax-1.0)*r + 1.0)    \n\n\n write(*,'(A)') 'I''m thinking of a number between 1 and 10.'\n do   \n\twrite(*,'(A)',advance='NO') 'Enter Guess: '\n\tread(*,'(I5)') guess\n\tif (guess==i) exit\n\twrite(*,*) 'Sorry, try again.'\n end do\n\n write(*,*) 'You''ve guessed my number\n\nend program guess_the_number\n", "target": "import random\nt,g=random.randint(1,10),0\ng=int(input(\"Guess a number that's between 1 and 10: \"))\nwhile t!=g:g=int(input(\"Guess again! \"))\nprint(\"That's right!\")\n"}
{"id": 112946, "name": "Bitmap_Read a PPM file", "source": "Translate Fortran to C#: subroutine read_ppm(u, img) \n  integer, intent(in) :: u\n  type(rgbimage), intent(out) :: img\n  integer :: i, j, ncol, cc\n  character(2) :: sign\n  character :: ccode\n  \n  img%width = 0\n  img%height = 0\n  nullify(img%red)\n  nullify(img%green)\n  nullify(img%blue)\n\n  read(u, '(A2)') sign\n  read(u, *) img%width, img%height\n  read(u, *) ncol\n\n  write(0,*) sign\n  write(0,*) img%width, img%height\n  write(0,*) ncol\n\n  if ( ncol /= 255 ) return\n\n  call alloc_img(img, img%width, img%height)\n\n  if ( valid_image(img) ) then\n     do j=1, img%height\n        do i=1, img%width\n           read(u, '(A1)', advance='no', iostat=status) ccode\n           cc = iachar(ccode)\n           img%red(i,j) = cc\n           read(u, '(A1)', advance='no', iostat=status) ccode\n           cc = iachar(ccode)\n           img%green(i,j) = cc\n           read(u, '(A1)', advance='no', iostat=status) ccode\n           cc = iachar(ccode)\n           img%blue(i,j) = cc\n        end do\n     end do\n  end if\n\nend subroutine read_ppm\n", "target": "using System.IO;\nclass PPMReader\n{\n    public static Bitmap ReadBitmapFromPPM(string file)\n    {\n        var reader = new BinaryReader(new FileStream(file, FileMode.Open));\n        if (reader.ReadChar() != 'P' || reader.ReadChar() != '6')\n            return null;\n        reader.ReadChar(); \n        string widths = \"\", heights = \"\";\n        char temp;\n        while ((temp = reader.ReadChar()) != ' ')\n            widths += temp;\n        while ((temp = reader.ReadChar()) >= '0' && temp <= '9')\n            heights += temp;\n        if (reader.ReadChar() != '2' || reader.ReadChar() != '5' || reader.ReadChar() != '5')\n            return null;\n        reader.ReadChar(); \n        int width = int.Parse(widths),\n            height = int.Parse(heights);\n        Bitmap bitmap = new Bitmap(width, height);\n        \n        for (int y = 0; y < height; y++)\n            for (int x = 0; x < width; x++)\n                bitmap.SetPixel(x, y, new Bitmap.Color()\n                {\n                    Red = reader.ReadByte(),\n                    Green = reader.ReadByte(),\n                    Blue = reader.ReadByte()\n                });\n        return bitmap;\n    }\n}\n"}
{"id": 112948, "name": "Bitmap_Read a PPM file", "source": "Translate Fortran to Python: subroutine read_ppm(u, img) \n  integer, intent(in) :: u\n  type(rgbimage), intent(out) :: img\n  integer :: i, j, ncol, cc\n  character(2) :: sign\n  character :: ccode\n  \n  img%width = 0\n  img%height = 0\n  nullify(img%red)\n  nullify(img%green)\n  nullify(img%blue)\n\n  read(u, '(A2)') sign\n  read(u, *) img%width, img%height\n  read(u, *) ncol\n\n  write(0,*) sign\n  write(0,*) img%width, img%height\n  write(0,*) ncol\n\n  if ( ncol /= 255 ) return\n\n  call alloc_img(img, img%width, img%height)\n\n  if ( valid_image(img) ) then\n     do j=1, img%height\n        do i=1, img%width\n           read(u, '(A1)', advance='no', iostat=status) ccode\n           cc = iachar(ccode)\n           img%red(i,j) = cc\n           read(u, '(A1)', advance='no', iostat=status) ccode\n           cc = iachar(ccode)\n           img%green(i,j) = cc\n           read(u, '(A1)', advance='no', iostat=status) ccode\n           cc = iachar(ccode)\n           img%blue(i,j) = cc\n        end do\n     end do\n  end if\n\nend subroutine read_ppm\n", "target": "\n\n\nimport io\n\nppmtxt = \n\n\ndef tokenize(f):\n    for line in f:\n        if line[0] != '\n            for t in line.split():\n                yield t\n\ndef ppmp3tobitmap(f):\n    t = tokenize(f)\n    nexttoken = lambda : next(t)\n    assert 'P3' == nexttoken(), 'Wrong filetype'\n    width, height, maxval = (int(nexttoken()) for i in range(3))\n    bitmap = Bitmap(width, height, Colour(0, 0, 0))\n    for h in range(height-1, -1, -1):\n        for w in range(0, width):\n            bitmap.set(w, h, Colour( *(int(nexttoken()) for i in range(3))))\n\n    return bitmap\n    \nprint('Original Colour PPM file')\nprint(ppmtxt)\nppmfile = io.StringIO(ppmtxt)\nbitmap = ppmp3tobitmap(ppmfile)\nprint('Grey PPM:')\nbitmap.togreyscale()\nppmfileout = io.StringIO('')\nbitmap.writeppmp3(ppmfileout)\nprint(ppmfileout.getvalue())\n\n\n\n"}
{"id": 113320, "name": "Parsing_RPN calculator algorithm", "source": "Translate Fortran to C#:       REAL FUNCTION EVALRP(TEXT)\t\nCaution: deals with single digits only.\n       CHARACTER*(*) TEXT\t\n       INTEGER SP,STACKLIMIT\t\t\n       PARAMETER (STACKLIMIT = 6)\t\n       REAL*8 STACK(STACKLIMIT)\t\t\n       INTEGER L,D\t\t\n       CHARACTER*4 DEED\t\t\n       CHARACTER*1 C\t\t\n        WRITE (6,1) TEXT\t\n    1   FORMAT (\"Evaluation of the Reverse Polish string \",A,//\t\n     1   \"Char Token Action  SP:Stack...\")\t\n        SP = 0\t\t\t\n        STACK = -666\t\t\n        DO L = 1,LEN(TEXT)\t\n          C = TEXT(L:L)\t\t\t\n          IF (C.LE.\" \") CYCLE\t\t\n          D = ICHAR(C) - ICHAR(\"0\")\t\n          IF (D.GE.0 .AND. D.LE.9) THEN\t\n            DEED = \"Load\"\t\t\t\n            SP = SP + 1\t\t\t\t\n            IF (SP.GT.STACKLIMIT) STOP \"Stack overflow\n            STACK(SP) = D\t\t\t\n           ELSE\t\t\t\t\n            IF (SP.LT.2) STOP \"Stack underflow\n            DEED = \"XEQ\"\t\t\n            SELECT CASE(C)\t\t\n             CASE(\"+\"); STACK(SP - 1) = STACK(SP - 1) + STACK(SP)\t\n             CASE(\"-\"); STACK(SP - 1) = STACK(SP - 1) - STACK(SP)\t\n             CASE(\"*\"); STACK(SP - 1) = STACK(SP - 1)*STACK(SP)\t\t\n             CASE(\"/\"); STACK(SP - 1) = STACK(SP - 1)/STACK(SP)\t\t\n             CASE(\"^\"); STACK(SP - 1) = STACK(SP - 1)**STACK(SP)\t\n             CASE DEFAULT\t\t\n              STOP \"Unknown operator\n            END SELECT\t\t\t\n            SP = SP - 1\t\t\n          END IF\t\t\n          WRITE (6,2) L,C,DEED,SP,STACK(1:SP)\t\n    2     FORMAT (I4,A6,A7,I4,\":\",66F14.6)\t\n        END DO\t\t\t\n        EVALRP = STACK(1)\t\n      END\t\n\n      PROGRAM HSILOP\n      REAL V\n      V = EVALRP(\"3 4 2 * 1 5 - 2 3 ^ ^ / +\")\t\n      WRITE (6,*) \"Result is...\",V\n      END\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Globalization;\nusing System.Threading;\n\nnamespace RPNEvaluator\n{\n    class RPNEvaluator\n    {\n        static void Main(string[] args)\n        {\n            Thread.CurrentThread.CurrentCulture = CultureInfo.InvariantCulture;\n\n            string rpn = \"3 4 2 * 1 5 - 2 3 ^ ^ / +\";\n            Console.WriteLine(\"{0}\\n\", rpn);\n\n            decimal result = CalculateRPN(rpn);\n            Console.WriteLine(\"\\nResult is {0}\", result);\n        }\n\n        static decimal CalculateRPN(string rpn)\n        {\n            string[] rpnTokens = rpn.Split(' ');\n            Stack<decimal> stack = new Stack<decimal>();\n            decimal number = decimal.Zero;\n\n            foreach (string token in rpnTokens)\n            {\n                if (decimal.TryParse(token, out number))\n                {\n                    stack.Push(number);\n                }\n                else\n                {\n                    switch (token)\n                    {\n                        case \"^\":\n                        case \"pow\":\n                            {\n                                number = stack.Pop();\n                                stack.Push((decimal)Math.Pow((double)stack.Pop(), (double)number));\n                                break;\n                            }\n                        case \"ln\":\n                            {\n                                stack.Push((decimal)Math.Log((double)stack.Pop(), Math.E));\n                                break;\n                            }\n                        case \"sqrt\":\n                            {\n                                stack.Push((decimal)Math.Sqrt((double)stack.Pop()));\n                                break;\n                            }\n                        case \"*\":\n                            {\n                                stack.Push(stack.Pop() * stack.Pop());\n                                break;\n                            }\n                        case \"/\":\n                            {\n                                number = stack.Pop();\n                                stack.Push(stack.Pop() / number);\n                                break;\n                            }\n                        case \"+\":\n                            {\n                                stack.Push(stack.Pop() + stack.Pop());\n                                break;\n                            }\n                        case \"-\":\n                            {\n                                number = stack.Pop();\n                                stack.Push(stack.Pop() - number);\n                                break;\n                            }\n                        default:\n                            Console.WriteLine(\"Error in CalculateRPN(string) Method!\");\n                            break;\n                    }\n                }\n                PrintState(stack);\n            }\n\n            return stack.Pop();\n        }\n\n        static void PrintState(Stack<decimal> stack)\n        {\n            decimal[] arr = stack.ToArray();\n\n            for (int i = arr.Length - 1; i >= 0; i--)\n            {\n                Console.Write(\"{0,-8:F3}\", arr[i]);\n            }\n            \n            Console.WriteLine();\n        }\n    }\n}\n"}
{"id": 113321, "name": "Parsing_RPN calculator algorithm", "source": "Translate Fortran to C#:       REAL FUNCTION EVALRP(TEXT)\t\nCaution: deals with single digits only.\n       CHARACTER*(*) TEXT\t\n       INTEGER SP,STACKLIMIT\t\t\n       PARAMETER (STACKLIMIT = 6)\t\n       REAL*8 STACK(STACKLIMIT)\t\t\n       INTEGER L,D\t\t\n       CHARACTER*4 DEED\t\t\n       CHARACTER*1 C\t\t\n        WRITE (6,1) TEXT\t\n    1   FORMAT (\"Evaluation of the Reverse Polish string \",A,//\t\n     1   \"Char Token Action  SP:Stack...\")\t\n        SP = 0\t\t\t\n        STACK = -666\t\t\n        DO L = 1,LEN(TEXT)\t\n          C = TEXT(L:L)\t\t\t\n          IF (C.LE.\" \") CYCLE\t\t\n          D = ICHAR(C) - ICHAR(\"0\")\t\n          IF (D.GE.0 .AND. D.LE.9) THEN\t\n            DEED = \"Load\"\t\t\t\n            SP = SP + 1\t\t\t\t\n            IF (SP.GT.STACKLIMIT) STOP \"Stack overflow\n            STACK(SP) = D\t\t\t\n           ELSE\t\t\t\t\n            IF (SP.LT.2) STOP \"Stack underflow\n            DEED = \"XEQ\"\t\t\n            SELECT CASE(C)\t\t\n             CASE(\"+\"); STACK(SP - 1) = STACK(SP - 1) + STACK(SP)\t\n             CASE(\"-\"); STACK(SP - 1) = STACK(SP - 1) - STACK(SP)\t\n             CASE(\"*\"); STACK(SP - 1) = STACK(SP - 1)*STACK(SP)\t\t\n             CASE(\"/\"); STACK(SP - 1) = STACK(SP - 1)/STACK(SP)\t\t\n             CASE(\"^\"); STACK(SP - 1) = STACK(SP - 1)**STACK(SP)\t\n             CASE DEFAULT\t\t\n              STOP \"Unknown operator\n            END SELECT\t\t\t\n            SP = SP - 1\t\t\n          END IF\t\t\n          WRITE (6,2) L,C,DEED,SP,STACK(1:SP)\t\n    2     FORMAT (I4,A6,A7,I4,\":\",66F14.6)\t\n        END DO\t\t\t\n        EVALRP = STACK(1)\t\n      END\t\n\n      PROGRAM HSILOP\n      REAL V\n      V = EVALRP(\"3 4 2 * 1 5 - 2 3 ^ ^ / +\")\t\n      WRITE (6,*) \"Result is...\",V\n      END\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Globalization;\nusing System.Threading;\n\nnamespace RPNEvaluator\n{\n    class RPNEvaluator\n    {\n        static void Main(string[] args)\n        {\n            Thread.CurrentThread.CurrentCulture = CultureInfo.InvariantCulture;\n\n            string rpn = \"3 4 2 * 1 5 - 2 3 ^ ^ / +\";\n            Console.WriteLine(\"{0}\\n\", rpn);\n\n            decimal result = CalculateRPN(rpn);\n            Console.WriteLine(\"\\nResult is {0}\", result);\n        }\n\n        static decimal CalculateRPN(string rpn)\n        {\n            string[] rpnTokens = rpn.Split(' ');\n            Stack<decimal> stack = new Stack<decimal>();\n            decimal number = decimal.Zero;\n\n            foreach (string token in rpnTokens)\n            {\n                if (decimal.TryParse(token, out number))\n                {\n                    stack.Push(number);\n                }\n                else\n                {\n                    switch (token)\n                    {\n                        case \"^\":\n                        case \"pow\":\n                            {\n                                number = stack.Pop();\n                                stack.Push((decimal)Math.Pow((double)stack.Pop(), (double)number));\n                                break;\n                            }\n                        case \"ln\":\n                            {\n                                stack.Push((decimal)Math.Log((double)stack.Pop(), Math.E));\n                                break;\n                            }\n                        case \"sqrt\":\n                            {\n                                stack.Push((decimal)Math.Sqrt((double)stack.Pop()));\n                                break;\n                            }\n                        case \"*\":\n                            {\n                                stack.Push(stack.Pop() * stack.Pop());\n                                break;\n                            }\n                        case \"/\":\n                            {\n                                number = stack.Pop();\n                                stack.Push(stack.Pop() / number);\n                                break;\n                            }\n                        case \"+\":\n                            {\n                                stack.Push(stack.Pop() + stack.Pop());\n                                break;\n                            }\n                        case \"-\":\n                            {\n                                number = stack.Pop();\n                                stack.Push(stack.Pop() - number);\n                                break;\n                            }\n                        default:\n                            Console.WriteLine(\"Error in CalculateRPN(string) Method!\");\n                            break;\n                    }\n                }\n                PrintState(stack);\n            }\n\n            return stack.Pop();\n        }\n\n        static void PrintState(Stack<decimal> stack)\n        {\n            decimal[] arr = stack.ToArray();\n\n            for (int i = arr.Length - 1; i >= 0; i--)\n            {\n                Console.Write(\"{0,-8:F3}\", arr[i]);\n            }\n            \n            Console.WriteLine();\n        }\n    }\n}\n"}
{"id": 113327, "name": "Parsing_RPN calculator algorithm", "source": "Translate Fortran to Java:       REAL FUNCTION EVALRP(TEXT)\t\nCaution: deals with single digits only.\n       CHARACTER*(*) TEXT\t\n       INTEGER SP,STACKLIMIT\t\t\n       PARAMETER (STACKLIMIT = 6)\t\n       REAL*8 STACK(STACKLIMIT)\t\t\n       INTEGER L,D\t\t\n       CHARACTER*4 DEED\t\t\n       CHARACTER*1 C\t\t\n        WRITE (6,1) TEXT\t\n    1   FORMAT (\"Evaluation of the Reverse Polish string \",A,//\t\n     1   \"Char Token Action  SP:Stack...\")\t\n        SP = 0\t\t\t\n        STACK = -666\t\t\n        DO L = 1,LEN(TEXT)\t\n          C = TEXT(L:L)\t\t\t\n          IF (C.LE.\" \") CYCLE\t\t\n          D = ICHAR(C) - ICHAR(\"0\")\t\n          IF (D.GE.0 .AND. D.LE.9) THEN\t\n            DEED = \"Load\"\t\t\t\n            SP = SP + 1\t\t\t\t\n            IF (SP.GT.STACKLIMIT) STOP \"Stack overflow\n            STACK(SP) = D\t\t\t\n           ELSE\t\t\t\t\n            IF (SP.LT.2) STOP \"Stack underflow\n            DEED = \"XEQ\"\t\t\n            SELECT CASE(C)\t\t\n             CASE(\"+\"); STACK(SP - 1) = STACK(SP - 1) + STACK(SP)\t\n             CASE(\"-\"); STACK(SP - 1) = STACK(SP - 1) - STACK(SP)\t\n             CASE(\"*\"); STACK(SP - 1) = STACK(SP - 1)*STACK(SP)\t\t\n             CASE(\"/\"); STACK(SP - 1) = STACK(SP - 1)/STACK(SP)\t\t\n             CASE(\"^\"); STACK(SP - 1) = STACK(SP - 1)**STACK(SP)\t\n             CASE DEFAULT\t\t\n              STOP \"Unknown operator\n            END SELECT\t\t\t\n            SP = SP - 1\t\t\n          END IF\t\t\n          WRITE (6,2) L,C,DEED,SP,STACK(1:SP)\t\n    2     FORMAT (I4,A6,A7,I4,\":\",66F14.6)\t\n        END DO\t\t\t\n        EVALRP = STACK(1)\t\n      END\t\n\n      PROGRAM HSILOP\n      REAL V\n      V = EVALRP(\"3 4 2 * 1 5 - 2 3 ^ ^ / +\")\t\n      WRITE (6,*) \"Result is...\",V\n      END\n", "target": "grammar rpnC ;\n\n\n\n\n\n@members {\nStack<Double> s = new Stack<Double>();\n}\nrpn\t:\t(WS* (num|op) (WS | WS* NEWLINE {System.out.println(s.pop());}))*;\nnum\t:\t'-'? Digit+ ('.' Digit+)? {s.push(Double.parseDouble($num.text));};\nDigit\t:\t'0'..'9';\nop\t:\t'-' {double x = s.pop(); s.push(s.pop() - x);}\n\t|\t'/' {double x = s.pop(); s.push(s.pop() / x);}\n\t|\t'*' {s.push(s.pop() * s.pop());}\n\t|\t'^' {double x = s.pop(); s.push(Math.pow(s.pop(), x));}\n\t|\t'+' {s.push(s.pop() + s.pop());};\nWS\t:\t(' ' | '\\t'){skip()};\nNEWLINE\t:\t'\\r'? '\\n';\n"}
{"id": 113328, "name": "Parsing_RPN calculator algorithm", "source": "Translate Fortran to Java:       REAL FUNCTION EVALRP(TEXT)\t\nCaution: deals with single digits only.\n       CHARACTER*(*) TEXT\t\n       INTEGER SP,STACKLIMIT\t\t\n       PARAMETER (STACKLIMIT = 6)\t\n       REAL*8 STACK(STACKLIMIT)\t\t\n       INTEGER L,D\t\t\n       CHARACTER*4 DEED\t\t\n       CHARACTER*1 C\t\t\n        WRITE (6,1) TEXT\t\n    1   FORMAT (\"Evaluation of the Reverse Polish string \",A,//\t\n     1   \"Char Token Action  SP:Stack...\")\t\n        SP = 0\t\t\t\n        STACK = -666\t\t\n        DO L = 1,LEN(TEXT)\t\n          C = TEXT(L:L)\t\t\t\n          IF (C.LE.\" \") CYCLE\t\t\n          D = ICHAR(C) - ICHAR(\"0\")\t\n          IF (D.GE.0 .AND. D.LE.9) THEN\t\n            DEED = \"Load\"\t\t\t\n            SP = SP + 1\t\t\t\t\n            IF (SP.GT.STACKLIMIT) STOP \"Stack overflow\n            STACK(SP) = D\t\t\t\n           ELSE\t\t\t\t\n            IF (SP.LT.2) STOP \"Stack underflow\n            DEED = \"XEQ\"\t\t\n            SELECT CASE(C)\t\t\n             CASE(\"+\"); STACK(SP - 1) = STACK(SP - 1) + STACK(SP)\t\n             CASE(\"-\"); STACK(SP - 1) = STACK(SP - 1) - STACK(SP)\t\n             CASE(\"*\"); STACK(SP - 1) = STACK(SP - 1)*STACK(SP)\t\t\n             CASE(\"/\"); STACK(SP - 1) = STACK(SP - 1)/STACK(SP)\t\t\n             CASE(\"^\"); STACK(SP - 1) = STACK(SP - 1)**STACK(SP)\t\n             CASE DEFAULT\t\t\n              STOP \"Unknown operator\n            END SELECT\t\t\t\n            SP = SP - 1\t\t\n          END IF\t\t\n          WRITE (6,2) L,C,DEED,SP,STACK(1:SP)\t\n    2     FORMAT (I4,A6,A7,I4,\":\",66F14.6)\t\n        END DO\t\t\t\n        EVALRP = STACK(1)\t\n      END\t\n\n      PROGRAM HSILOP\n      REAL V\n      V = EVALRP(\"3 4 2 * 1 5 - 2 3 ^ ^ / +\")\t\n      WRITE (6,*) \"Result is...\",V\n      END\n", "target": "grammar rpnC ;\n\n\n\n\n\n@members {\nStack<Double> s = new Stack<Double>();\n}\nrpn\t:\t(WS* (num|op) (WS | WS* NEWLINE {System.out.println(s.pop());}))*;\nnum\t:\t'-'? Digit+ ('.' Digit+)? {s.push(Double.parseDouble($num.text));};\nDigit\t:\t'0'..'9';\nop\t:\t'-' {double x = s.pop(); s.push(s.pop() - x);}\n\t|\t'/' {double x = s.pop(); s.push(s.pop() / x);}\n\t|\t'*' {s.push(s.pop() * s.pop());}\n\t|\t'^' {double x = s.pop(); s.push(Math.pow(s.pop(), x));}\n\t|\t'+' {s.push(s.pop() + s.pop());};\nWS\t:\t(' ' | '\\t'){skip()};\nNEWLINE\t:\t'\\r'? '\\n';\n"}
{"id": 113329, "name": "Parsing_RPN calculator algorithm", "source": "Translate Fortran to Python:       REAL FUNCTION EVALRP(TEXT)\t\nCaution: deals with single digits only.\n       CHARACTER*(*) TEXT\t\n       INTEGER SP,STACKLIMIT\t\t\n       PARAMETER (STACKLIMIT = 6)\t\n       REAL*8 STACK(STACKLIMIT)\t\t\n       INTEGER L,D\t\t\n       CHARACTER*4 DEED\t\t\n       CHARACTER*1 C\t\t\n        WRITE (6,1) TEXT\t\n    1   FORMAT (\"Evaluation of the Reverse Polish string \",A,//\t\n     1   \"Char Token Action  SP:Stack...\")\t\n        SP = 0\t\t\t\n        STACK = -666\t\t\n        DO L = 1,LEN(TEXT)\t\n          C = TEXT(L:L)\t\t\t\n          IF (C.LE.\" \") CYCLE\t\t\n          D = ICHAR(C) - ICHAR(\"0\")\t\n          IF (D.GE.0 .AND. D.LE.9) THEN\t\n            DEED = \"Load\"\t\t\t\n            SP = SP + 1\t\t\t\t\n            IF (SP.GT.STACKLIMIT) STOP \"Stack overflow\n            STACK(SP) = D\t\t\t\n           ELSE\t\t\t\t\n            IF (SP.LT.2) STOP \"Stack underflow\n            DEED = \"XEQ\"\t\t\n            SELECT CASE(C)\t\t\n             CASE(\"+\"); STACK(SP - 1) = STACK(SP - 1) + STACK(SP)\t\n             CASE(\"-\"); STACK(SP - 1) = STACK(SP - 1) - STACK(SP)\t\n             CASE(\"*\"); STACK(SP - 1) = STACK(SP - 1)*STACK(SP)\t\t\n             CASE(\"/\"); STACK(SP - 1) = STACK(SP - 1)/STACK(SP)\t\t\n             CASE(\"^\"); STACK(SP - 1) = STACK(SP - 1)**STACK(SP)\t\n             CASE DEFAULT\t\t\n              STOP \"Unknown operator\n            END SELECT\t\t\t\n            SP = SP - 1\t\t\n          END IF\t\t\n          WRITE (6,2) L,C,DEED,SP,STACK(1:SP)\t\n    2     FORMAT (I4,A6,A7,I4,\":\",66F14.6)\t\n        END DO\t\t\t\n        EVALRP = STACK(1)\t\n      END\t\n\n      PROGRAM HSILOP\n      REAL V\n      V = EVALRP(\"3 4 2 * 1 5 - 2 3 ^ ^ / +\")\t\n      WRITE (6,*) \"Result is...\",V\n      END\n", "target": "def op_pow(stack):\n    b = stack.pop(); a = stack.pop()\n    stack.append( a ** b )\ndef op_mul(stack):\n    b = stack.pop(); a = stack.pop()\n    stack.append( a * b )\ndef op_div(stack):\n    b = stack.pop(); a = stack.pop()\n    stack.append( a / b )\ndef op_add(stack):\n    b = stack.pop(); a = stack.pop()\n    stack.append( a + b )\ndef op_sub(stack):\n    b = stack.pop(); a = stack.pop()\n    stack.append( a - b )\ndef op_num(stack, num):\n    stack.append( num )\n    \nops = {\n '^': op_pow,\n '*': op_mul,\n '/': op_div,\n '+': op_add,\n '-': op_sub,\n }\n\ndef get_input(inp = None):\n    'Inputs an expression and returns list of tokens'\n    \n    if inp is None:\n        inp = input('expression: ')\n    tokens = inp.strip().split()\n    return tokens\n\ndef rpn_calc(tokens):\n    stack = []\n    table = ['TOKEN,ACTION,STACK'.split(',')]\n    for token in tokens:\n        if token in ops:\n            action = 'Apply op to top of stack'\n            ops[token](stack)\n            table.append( (token, action, ' '.join(str(s) for s in stack)) )\n        else:\n            action = 'Push num onto top of stack'\n            op_num(stack, eval(token))\n            table.append( (token, action, ' '.join(str(s) for s in stack)) )\n    return table\n\nif __name__ == '__main__':\n    rpn = '3 4 2 * 1 5 - 2 3 ^ ^ / +'\n    print( 'For RPN expression: %r\\n' % rpn )\n    rp = rpn_calc(get_input(rpn))\n    maxcolwidths = [max(len(y) for y in x) for x in zip(*rp)]\n    row = rp[0]\n    print( ' '.join('{cell:^{width}}'.format(width=width, cell=cell) for (width, cell) in zip(maxcolwidths, row)))\n    for row in rp[1:]:\n        print( ' '.join('{cell:<{width}}'.format(width=width, cell=cell) for (width, cell) in zip(maxcolwidths, row)))\n\n    print('\\n The final output value is: %r' % rp[-1][2])\n"}
{"id": 113330, "name": "Parsing_RPN calculator algorithm", "source": "Translate Fortran to Python:       REAL FUNCTION EVALRP(TEXT)\t\nCaution: deals with single digits only.\n       CHARACTER*(*) TEXT\t\n       INTEGER SP,STACKLIMIT\t\t\n       PARAMETER (STACKLIMIT = 6)\t\n       REAL*8 STACK(STACKLIMIT)\t\t\n       INTEGER L,D\t\t\n       CHARACTER*4 DEED\t\t\n       CHARACTER*1 C\t\t\n        WRITE (6,1) TEXT\t\n    1   FORMAT (\"Evaluation of the Reverse Polish string \",A,//\t\n     1   \"Char Token Action  SP:Stack...\")\t\n        SP = 0\t\t\t\n        STACK = -666\t\t\n        DO L = 1,LEN(TEXT)\t\n          C = TEXT(L:L)\t\t\t\n          IF (C.LE.\" \") CYCLE\t\t\n          D = ICHAR(C) - ICHAR(\"0\")\t\n          IF (D.GE.0 .AND. D.LE.9) THEN\t\n            DEED = \"Load\"\t\t\t\n            SP = SP + 1\t\t\t\t\n            IF (SP.GT.STACKLIMIT) STOP \"Stack overflow\n            STACK(SP) = D\t\t\t\n           ELSE\t\t\t\t\n            IF (SP.LT.2) STOP \"Stack underflow\n            DEED = \"XEQ\"\t\t\n            SELECT CASE(C)\t\t\n             CASE(\"+\"); STACK(SP - 1) = STACK(SP - 1) + STACK(SP)\t\n             CASE(\"-\"); STACK(SP - 1) = STACK(SP - 1) - STACK(SP)\t\n             CASE(\"*\"); STACK(SP - 1) = STACK(SP - 1)*STACK(SP)\t\t\n             CASE(\"/\"); STACK(SP - 1) = STACK(SP - 1)/STACK(SP)\t\t\n             CASE(\"^\"); STACK(SP - 1) = STACK(SP - 1)**STACK(SP)\t\n             CASE DEFAULT\t\t\n              STOP \"Unknown operator\n            END SELECT\t\t\t\n            SP = SP - 1\t\t\n          END IF\t\t\n          WRITE (6,2) L,C,DEED,SP,STACK(1:SP)\t\n    2     FORMAT (I4,A6,A7,I4,\":\",66F14.6)\t\n        END DO\t\t\t\n        EVALRP = STACK(1)\t\n      END\t\n\n      PROGRAM HSILOP\n      REAL V\n      V = EVALRP(\"3 4 2 * 1 5 - 2 3 ^ ^ / +\")\t\n      WRITE (6,*) \"Result is...\",V\n      END\n", "target": "def op_pow(stack):\n    b = stack.pop(); a = stack.pop()\n    stack.append( a ** b )\ndef op_mul(stack):\n    b = stack.pop(); a = stack.pop()\n    stack.append( a * b )\ndef op_div(stack):\n    b = stack.pop(); a = stack.pop()\n    stack.append( a / b )\ndef op_add(stack):\n    b = stack.pop(); a = stack.pop()\n    stack.append( a + b )\ndef op_sub(stack):\n    b = stack.pop(); a = stack.pop()\n    stack.append( a - b )\ndef op_num(stack, num):\n    stack.append( num )\n    \nops = {\n '^': op_pow,\n '*': op_mul,\n '/': op_div,\n '+': op_add,\n '-': op_sub,\n }\n\ndef get_input(inp = None):\n    'Inputs an expression and returns list of tokens'\n    \n    if inp is None:\n        inp = input('expression: ')\n    tokens = inp.strip().split()\n    return tokens\n\ndef rpn_calc(tokens):\n    stack = []\n    table = ['TOKEN,ACTION,STACK'.split(',')]\n    for token in tokens:\n        if token in ops:\n            action = 'Apply op to top of stack'\n            ops[token](stack)\n            table.append( (token, action, ' '.join(str(s) for s in stack)) )\n        else:\n            action = 'Push num onto top of stack'\n            op_num(stack, eval(token))\n            table.append( (token, action, ' '.join(str(s) for s in stack)) )\n    return table\n\nif __name__ == '__main__':\n    rpn = '3 4 2 * 1 5 - 2 3 ^ ^ / +'\n    print( 'For RPN expression: %r\\n' % rpn )\n    rp = rpn_calc(get_input(rpn))\n    maxcolwidths = [max(len(y) for y in x) for x in zip(*rp)]\n    row = rp[0]\n    print( ' '.join('{cell:^{width}}'.format(width=width, cell=cell) for (width, cell) in zip(maxcolwidths, row)))\n    for row in rp[1:]:\n        print( ' '.join('{cell:<{width}}'.format(width=width, cell=cell) for (width, cell) in zip(maxcolwidths, row)))\n\n    print('\\n The final output value is: %r' % rp[-1][2])\n"}
{"id": 113716, "name": "Run-length encoding", "source": "Translate Fortran to C#: program RLE\n  implicit none\n\n  integer, parameter :: bufsize = 100   \n  character(bufsize) :: teststr = \"WWWWWWWWWWWWBWWWWWWWWWWWWBBBWWWWWWWWWWWWWWWWWWWWWWWWBWWWWWWWWWWWWWW\"\n  character(bufsize) :: codedstr = \"\", decodedstr = \"\"\n    \n  call Encode(teststr, codedstr)\n  write(*,\"(a)\") trim(codedstr)\n  call Decode(codedstr, decodedstr)\n  write(*,\"(a)\") trim(decodedstr)\n\ncontains\n\nsubroutine Encode(instr, outstr)\n  character(*), intent(in)  :: instr\n  character(*), intent(out) :: outstr\n  character(8) :: tempstr = \"\"\n  character(26) :: validchars = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n  integer :: a, b, c, i\n\n  if(verify(trim(instr), validchars) /= 0) then\n    outstr = \"Invalid input\"\n    return\n  end if\n  outstr = \"\"\n  c = 1\n  a = iachar(instr(1:1))\n  do i = 2, len(trim(instr))\n    b = iachar(instr(i:i))\n    if(a == b) then\n      c = c + 1\n    else\n      write(tempstr, \"(i0)\") c\n      outstr = trim(outstr) // trim(tempstr) // achar(a)\n      a = b\n      c = 1\n    end if\n  end do\n  write(tempstr, \"(i0)\") c\n  outstr = trim(outstr) // trim(tempstr) // achar(b)\nend subroutine\n\nsubroutine Decode(instr, outstr)\n  character(*), intent(in)  :: instr\n  character(*), intent(out) :: outstr\n  character(26) :: validchars = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n  integer :: startn, endn, n\n\n  outstr = \"\"\n  startn = 1\n  do while(startn < len(trim(instr)))\n    endn = scan(instr(startn:), validchars) + startn - 1\n    read(instr(startn:endn-1), \"(i8)\") n\n    outstr = trim(outstr) // repeat(instr(endn:endn), n)\n    startn = endn + 1\n  end do\nend subroutine\nend program\n", "target": "using System.Collections.Generic;\nusing System.Linq;\nusing static System.Console;\nusing static System.Linq.Enumerable;\n\nnamespace RunLengthEncoding\n{\n    static class Program\n    {\n          public static string Encode(string input) => input.Length ==0 ? \"\" : input.Skip(1)\n            .Aggregate((t:input[0].ToString(),o:Empty<string>()),\n               (a,c)=>a.t[0]==c ? (a.t+c,a.o) : (c.ToString(),a.o.Append(a.t)),\n               a=>a.o.Append(a.t).Select(p => (key: p.Length, chr: p[0])))\n            .Select(p=> $\"{p.key}{p.chr}\")\n            .StringConcat();\n\n        public static string Decode(string input) => input\n            .Aggregate((t: \"\", o: Empty<string>()), (a, c) => !char.IsDigit(c) ? (\"\", a.o.Append(a.t+c)) : (a.t + c,a.o)).o \n            .Select(p => new string(p.Last(), int.Parse(string.Concat(p.Where(char.IsDigit)))))\n            .StringConcat();\n\n        private static string StringConcat(this IEnumerable<string> seq) => string.Concat(seq);\n        \n        public static void Main(string[] args)\n        {\n            const string  raw = \"WWWWWWWWWWWWBWWWWWWWWWWWWBBBWWWWWWWWWWWWWWWWWWWWWWWWBWWWWWWWWWWWWWW\";\n            const string encoded = \"12W1B12W3B24W1B14W\";\n\n            WriteLine($\"raw = {raw}\");\n            WriteLine($\"encoded = {encoded}\");\n            WriteLine($\"Encode(raw) = encoded = {Encode(raw)}\");\n            WriteLine($\"Decode(encode) = {Decode(encoded)}\");\n            WriteLine($\"Decode(Encode(raw)) = {Decode(Encode(raw)) == raw}\");\n            ReadLine();\n        }\n    }\n}\n"}
{"id": 113719, "name": "Run-length encoding", "source": "Translate Fortran to Java: program RLE\n  implicit none\n\n  integer, parameter :: bufsize = 100   \n  character(bufsize) :: teststr = \"WWWWWWWWWWWWBWWWWWWWWWWWWBBBWWWWWWWWWWWWWWWWWWWWWWWWBWWWWWWWWWWWWWW\"\n  character(bufsize) :: codedstr = \"\", decodedstr = \"\"\n    \n  call Encode(teststr, codedstr)\n  write(*,\"(a)\") trim(codedstr)\n  call Decode(codedstr, decodedstr)\n  write(*,\"(a)\") trim(decodedstr)\n\ncontains\n\nsubroutine Encode(instr, outstr)\n  character(*), intent(in)  :: instr\n  character(*), intent(out) :: outstr\n  character(8) :: tempstr = \"\"\n  character(26) :: validchars = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n  integer :: a, b, c, i\n\n  if(verify(trim(instr), validchars) /= 0) then\n    outstr = \"Invalid input\"\n    return\n  end if\n  outstr = \"\"\n  c = 1\n  a = iachar(instr(1:1))\n  do i = 2, len(trim(instr))\n    b = iachar(instr(i:i))\n    if(a == b) then\n      c = c + 1\n    else\n      write(tempstr, \"(i0)\") c\n      outstr = trim(outstr) // trim(tempstr) // achar(a)\n      a = b\n      c = 1\n    end if\n  end do\n  write(tempstr, \"(i0)\") c\n  outstr = trim(outstr) // trim(tempstr) // achar(b)\nend subroutine\n\nsubroutine Decode(instr, outstr)\n  character(*), intent(in)  :: instr\n  character(*), intent(out) :: outstr\n  character(26) :: validchars = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n  integer :: startn, endn, n\n\n  outstr = \"\"\n  startn = 1\n  do while(startn < len(trim(instr)))\n    endn = scan(instr(startn:), validchars) + startn - 1\n    read(instr(startn:endn-1), \"(i8)\") n\n    outstr = trim(outstr) // repeat(instr(endn:endn), n)\n    startn = endn + 1\n  end do\nend subroutine\nend program\n", "target": "import java.util.regex.Matcher;\nimport java.util.regex.Pattern;\npublic class RunLengthEncoding {\n\n    public static String encode(String source) {\n        StringBuffer dest = new StringBuffer();\n        for (int i = 0; i < source.length(); i++) {\n            int runLength = 1;\n            while (i+1 < source.length() && source.charAt(i) == source.charAt(i+1)) {\n                runLength++;\n                i++;\n            }\n            dest.append(runLength);\n            dest.append(source.charAt(i));\n        }\n        return dest.toString();\n    }\n\n    public static String decode(String source) {\n        StringBuffer dest = new StringBuffer();\n        Pattern pattern = Pattern.compile(\"[0-9]+|[a-zA-Z]\");\n        Matcher matcher = pattern.matcher(source);\n        while (matcher.find()) {\n            int number = Integer.parseInt(matcher.group());\n            matcher.find();\n            while (number-- != 0) {\n                dest.append(matcher.group());\n            }\n        }\n        return dest.toString();\n    }\n\n    public static void main(String[] args) {\n        String example = \"WWWWWWWWWWWWBWWWWWWWWWWWWBBBWWWWWWWWWWWWWWWWWWWWWWWWBWWWWWWWWWWWWWW\";\n        System.out.println(encode(example));\n        System.out.println(decode(\"1W1B1W1B1W1B1W1B1W1B1W1B1W1B\"));\n    }\n}\n"}
{"id": 113720, "name": "Run-length encoding", "source": "Translate Fortran to Python: program RLE\n  implicit none\n\n  integer, parameter :: bufsize = 100   \n  character(bufsize) :: teststr = \"WWWWWWWWWWWWBWWWWWWWWWWWWBBBWWWWWWWWWWWWWWWWWWWWWWWWBWWWWWWWWWWWWWW\"\n  character(bufsize) :: codedstr = \"\", decodedstr = \"\"\n    \n  call Encode(teststr, codedstr)\n  write(*,\"(a)\") trim(codedstr)\n  call Decode(codedstr, decodedstr)\n  write(*,\"(a)\") trim(decodedstr)\n\ncontains\n\nsubroutine Encode(instr, outstr)\n  character(*), intent(in)  :: instr\n  character(*), intent(out) :: outstr\n  character(8) :: tempstr = \"\"\n  character(26) :: validchars = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n  integer :: a, b, c, i\n\n  if(verify(trim(instr), validchars) /= 0) then\n    outstr = \"Invalid input\"\n    return\n  end if\n  outstr = \"\"\n  c = 1\n  a = iachar(instr(1:1))\n  do i = 2, len(trim(instr))\n    b = iachar(instr(i:i))\n    if(a == b) then\n      c = c + 1\n    else\n      write(tempstr, \"(i0)\") c\n      outstr = trim(outstr) // trim(tempstr) // achar(a)\n      a = b\n      c = 1\n    end if\n  end do\n  write(tempstr, \"(i0)\") c\n  outstr = trim(outstr) // trim(tempstr) // achar(b)\nend subroutine\n\nsubroutine Decode(instr, outstr)\n  character(*), intent(in)  :: instr\n  character(*), intent(out) :: outstr\n  character(26) :: validchars = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n  integer :: startn, endn, n\n\n  outstr = \"\"\n  startn = 1\n  do while(startn < len(trim(instr)))\n    endn = scan(instr(startn:), validchars) + startn - 1\n    read(instr(startn:endn-1), \"(i8)\") n\n    outstr = trim(outstr) // repeat(instr(endn:endn), n)\n    startn = endn + 1\n  end do\nend subroutine\nend program\n", "target": "def encode(input_string):\n    count = 1\n    prev = None\n    lst = []\n    for character in input_string:\n        if character != prev:\n            if prev:\n                entry = (prev, count)\n                lst.append(entry)\n            count = 1\n            prev = character\n        else:\n            count += 1\n    else:\n        try:\n            entry = (character, count)\n            lst.append(entry)\n            return (lst, 0)\n        except Exception as e:\n            print(\"Exception encountered {e}\".format(e=e)) \n            return (e, 1)\n \ndef decode(lst):\n    q = []\n    for character, count in lst:\n        q.append(character * count)\n    return ''.join(q)\n \n\nvalue = encode(\"aaaaahhhhhhmmmmmmmuiiiiiiiaaaaaa\")\nif value[1] == 0:\n    print(\"Encoded value is {}\".format(value[0]))\n    decode(value[0])\n"}
{"id": 113988, "name": "Anonymous recursion", "source": "Translate Fortran to C#: integer function fib(n)\n  integer, intent(in) :: n\n  if (n < 0 ) then\n    write (*,*) 'Bad argument: fib(',n,')'\n    stop\n  else\n    fib = purefib(n)\n  end if\ncontains\n  recursive pure integer function purefib(n) result(f)\n    integer, intent(in) :: n\n    if (n < 2 ) then\n      f = n\n    else\n      f = purefib(n-1) + purefib(n-2)\n    end if\n  end function purefib\nend function fib\n", "target": "static int Fib(int n)\n{\n    if (n < 0) throw new ArgumentException(\"Must be non negativ\", \"n\");\n \n    Func<int, int> fib = null; \n    fib = p => p > 1 ? fib(p - 2) + fib(p - 1) : p;\n    return fib(n);\n}\n"}
{"id": 113992, "name": "Anonymous recursion", "source": "Translate Fortran to Java: integer function fib(n)\n  integer, intent(in) :: n\n  if (n < 0 ) then\n    write (*,*) 'Bad argument: fib(',n,')'\n    stop\n  else\n    fib = purefib(n)\n  end if\ncontains\n  recursive pure integer function purefib(n) result(f)\n    integer, intent(in) :: n\n    if (n < 2 ) then\n      f = n\n    else\n      f = purefib(n-1) + purefib(n-2)\n    end if\n  end function purefib\nend function fib\n", "target": "public static long fib(int n) {\n    if (n < 0)\n        throw new IllegalArgumentException(\"n can not be a negative number\");\n\n    return new Object() {\n        private long fibInner(int n) {\n            return (n < 2) ? n : (fibInner(n - 1) + fibInner(n - 2));\n        }\n    }.fibInner(n);\n}\n"}
{"id": 113993, "name": "Anonymous recursion", "source": "Translate Fortran to Python: integer function fib(n)\n  integer, intent(in) :: n\n  if (n < 0 ) then\n    write (*,*) 'Bad argument: fib(',n,')'\n    stop\n  else\n    fib = purefib(n)\n  end if\ncontains\n  recursive pure integer function purefib(n) result(f)\n    integer, intent(in) :: n\n    if (n < 2 ) then\n      f = n\n    else\n      f = purefib(n-1) + purefib(n-2)\n    end if\n  end function purefib\nend function fib\n", "target": ">>> Y = lambda f: (lambda x: x(x))(lambda y: f(lambda *args: y(y)(*args)))\n>>> fib = lambda f: lambda n: None if n < 0 else (0 if n == 0 else (1 if n == 1 else f(n-1) + f(n-2)))\n>>> [ Y(fib)(i) for i in range(-2, 10) ]\n[None, None, 0, 1, 1, 2, 3, 5, 8, 13, 21, 34]\n"}
{"id": 114351, "name": "A+B", "source": "Translate Fortran to C#: program a_plus_b\n  implicit none\n  integer :: a,b\n  read (*, *) a, b\n  write (*, '(i0)') a + b\nend program a_plus_b\n", "target": "using System;\nusing System.Linq;\n\nclass Program\n{\n    static void Main()\n    {\n        Console.WriteLine(Console.ReadLine().Split().Select(int.Parse).Sum());\n    }\n}\n"}
{"id": 114352, "name": "A+B", "source": "Translate Fortran to C#: program a_plus_b\n  implicit none\n  integer :: a,b\n  read (*, *) a, b\n  write (*, '(i0)') a + b\nend program a_plus_b\n", "target": "using System;\nusing System.Linq;\n\nclass Program\n{\n    static void Main()\n    {\n        Console.WriteLine(Console.ReadLine().Split().Select(int.Parse).Sum());\n    }\n}\n"}
{"id": 114357, "name": "A+B", "source": "Translate Fortran to Java: program a_plus_b\n  implicit none\n  integer :: a,b\n  read (*, *) a, b\n  write (*, '(i0)') a + b\nend program a_plus_b\n", "target": "import java.util.Scanner;\n\npublic class Sum2 {\n    public static void main(String[] args) {\n        Scanner in = new Scanner(System.in); \n        System.out.println(in.nextInt() + in.nextInt()); \n    }\n}\n"}
{"id": 114358, "name": "A+B", "source": "Translate Fortran to Java: program a_plus_b\n  implicit none\n  integer :: a,b\n  read (*, *) a, b\n  write (*, '(i0)') a + b\nend program a_plus_b\n", "target": "import java.util.Scanner;\n\npublic class Sum2 {\n    public static void main(String[] args) {\n        Scanner in = new Scanner(System.in); \n        System.out.println(in.nextInt() + in.nextInt()); \n    }\n}\n"}
{"id": 114359, "name": "A+B", "source": "Translate Fortran to Python: program a_plus_b\n  implicit none\n  integer :: a,b\n  read (*, *) a, b\n  write (*, '(i0)') a + b\nend program a_plus_b\n", "target": "try: raw_input\nexcept: raw_input = input\n\nprint(sum(map(int, raw_input().split())))\n"}
{"id": 114360, "name": "A+B", "source": "Translate Fortran to Python: program a_plus_b\n  implicit none\n  integer :: a,b\n  read (*, *) a, b\n  write (*, '(i0)') a + b\nend program a_plus_b\n", "target": "try: raw_input\nexcept: raw_input = input\n\nprint(sum(map(int, raw_input().split())))\n"}
{"id": 114836, "name": "Leap year", "source": "Translate Fortran to C#: program leap\n implicit none\n\n write(*,*) leap_year([1900, 1996, 1997, 2000])\n\n contains\n\n\tpure elemental function leap_year(y) result(is_leap)\n\timplicit none\n\tlogical :: is_leap\n\tinteger,intent(in) :: y\t\n\t\n\tis_leap = (mod(y,4)==0 .and. .not. mod(y,100)==0) .or. (mod(y,400)==0)\t\n\t\n\tend function leap_year\n\t\nend program leap\n", "target": "using System;\n\nclass Program\n{\n    static void Main()\n    {\n        foreach (var year in new[] { 1900, 1994, 1996, DateTime.Now.Year })\n        {\n            Console.WriteLine(\"{0} is {1}a leap year.\",\n                              year,\n                              DateTime.IsLeapYear(year) ? string.Empty : \"not \");\n        }\n    }\n}\n"}
{"id": 114839, "name": "Leap year", "source": "Translate Fortran to Java: program leap\n implicit none\n\n write(*,*) leap_year([1900, 1996, 1997, 2000])\n\n contains\n\n\tpure elemental function leap_year(y) result(is_leap)\n\timplicit none\n\tlogical :: is_leap\n\tinteger,intent(in) :: y\t\n\t\n\tis_leap = (mod(y,4)==0 .and. .not. mod(y,100)==0) .or. (mod(y,400)==0)\t\n\t\n\tend function leap_year\n\t\nend program leap\n", "target": "import java.util.GregorianCalendar;\nimport java.text.MessageFormat;\n\npublic class Leapyear{\n        public static void main(String[] argv){\n                int[] yrs = {1800,1900,1994,1998,1999,2000,2001,2004,2100};\n                GregorianCalendar cal = new GregorianCalendar();\n                for(int year : yrs){\n                        System.err.println(MessageFormat.format(\"The year {0,number,#} is leaper: {1} / {2}.\",\n                                                                 year, cal.isLeapYear(year), isLeapYear(year)));\n                }\n\n        }\n        public static boolean isLeapYear(int year){\n                return (year % 100 == 0) ? (year % 400 == 0) : (year % 4 == 0);\n        }\n}\n"}
{"id": 114840, "name": "Leap year", "source": "Translate Fortran to Python: program leap\n implicit none\n\n write(*,*) leap_year([1900, 1996, 1997, 2000])\n\n contains\n\n\tpure elemental function leap_year(y) result(is_leap)\n\timplicit none\n\tlogical :: is_leap\n\tinteger,intent(in) :: y\t\n\t\n\tis_leap = (mod(y,4)==0 .and. .not. mod(y,100)==0) .or. (mod(y,400)==0)\t\n\t\n\tend function leap_year\n\t\nend program leap\n", "target": "import calendar\ncalendar.isleap(year)\n"}
{"id": 115110, "name": "Program name", "source": "Translate Fortran to C#: \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nmodule sundry\n\ncontains\n\n  subroutine verify_name(required)\n    \n    character(len=*), intent(in) :: required\n    character(len=1024) :: name\n    integer :: length, status\n    \n    call get_command_argument(0, name, length, status)\n    if (0 /= status) stop\n    if ((len_trim(name)+1) .ne. (index(name, required, back=.true.) + len(required))) stop\n    write(6,*) trim(name)//' approved.'\n  end subroutine verify_name\n\nend module sundry\n\nprogram name\n  use sundry\n  call verify_name('rcname')\n  write(6,*)'program continues...'\nend program name\n", "target": "using System;\nnamespace ProgramName\n{\n\tclass Program\n\t{\n\t\tstatic void Main(string[] args)\n\t\t{\n\t\t\tConsole.Write(Environment.CommandLine);\n\t\t}\n\t}\n}\n"}
{"id": 115113, "name": "Program name", "source": "Translate Fortran to Java: \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nmodule sundry\n\ncontains\n\n  subroutine verify_name(required)\n    \n    character(len=*), intent(in) :: required\n    character(len=1024) :: name\n    integer :: length, status\n    \n    call get_command_argument(0, name, length, status)\n    if (0 /= status) stop\n    if ((len_trim(name)+1) .ne. (index(name, required, back=.true.) + len(required))) stop\n    write(6,*) trim(name)//' approved.'\n  end subroutine verify_name\n\nend module sundry\n\nprogram name\n  use sundry\n  call verify_name('rcname')\n  write(6,*)'program continues...'\nend program name\n", "target": "public class ScriptName {\n\tpublic static void main(String[] args) {\n\t\tString program = System.getProperty(\"sun.java.command\").split(\" \")[0];\n\t\tSystem.out.println(\"Program: \" + program);\n\t}\n}\n"}
{"id": 115114, "name": "Program name", "source": "Translate Fortran to Python: \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nmodule sundry\n\ncontains\n\n  subroutine verify_name(required)\n    \n    character(len=*), intent(in) :: required\n    character(len=1024) :: name\n    integer :: length, status\n    \n    call get_command_argument(0, name, length, status)\n    if (0 /= status) stop\n    if ((len_trim(name)+1) .ne. (index(name, required, back=.true.) + len(required))) stop\n    write(6,*) trim(name)//' approved.'\n  end subroutine verify_name\n\nend module sundry\n\nprogram name\n  use sundry\n  call verify_name('rcname')\n  write(6,*)'program continues...'\nend program name\n", "target": "\n\nimport sys\n\ndef main():\n    program = sys.argv[0]\n    print(\"Program: %s\" % program)\n\nif __name__ == \"__main__\":\n    main()\n"}
{"id": 115415, "name": "Doubly-linked list_Element insertion", "source": "Translate Fortran to C#: module dlList\n    public :: node, insertAfter, getNext\n    \n    type node\n        real :: data\n        type( node ), pointer :: next => null()\n        type( node ), pointer :: previous => null()\n    end type node\n    \ncontains\n    subroutine insertAfter(nodeBefore, value)\n        type( node ), intent(inout), target :: nodeBefore\n        type( node ), pointer :: newNode\n        real, intent(in) :: value\n        \n        allocate( newNode )\n        newNode%data = value\n        newNode%next => nodeBefore%next\n        newNode%previous => nodeBefore\n        \n        if (associated( newNode%next )) then\n            newNode%next%previous => newNode\n        end if\n        newNode%previous%next => newNode\n    end subroutine insertAfter\n   \n    subroutine delete(current)\n        type( node ), intent(inout), pointer :: current\n        \n        if (associated( current%next )) current%next%previous => current%previous\n        if (associated( current%previous )) current%previous%next => current%next\n        deallocate(current)\n    end subroutine delete\nend module dlList\n\nprogram dlListTest\n    use dlList\n    type( node ), target :: head\n    type( node ), pointer :: current, next\n    \n    head%data = 1.0\n    current => head\n    do i = 1, 20\n       call insertAfter(current, 2.0**i)\n       current => current%next\n    end do\n    \n    current => head\n    do while (associated(current))\n        print *, current%data\n        next => current%next\n        if (.not. associated(current, head)) call delete(current)\n        current => next\n    end do\nend program dlListTest\n", "target": "static void InsertAfter(Link prev, int i)\n{\n    if (prev.next != null)\n    {\n        prev.next.prev = new Link() { item = i, prev = prev, next = prev.next };\n        prev.next = prev.next.prev;\n    }\n    else\n        prev.next = new Link() { item = i, prev = prev };\n}\n"}
{"id": 115419, "name": "Doubly-linked list_Element insertion", "source": "Translate Fortran to Java: module dlList\n    public :: node, insertAfter, getNext\n    \n    type node\n        real :: data\n        type( node ), pointer :: next => null()\n        type( node ), pointer :: previous => null()\n    end type node\n    \ncontains\n    subroutine insertAfter(nodeBefore, value)\n        type( node ), intent(inout), target :: nodeBefore\n        type( node ), pointer :: newNode\n        real, intent(in) :: value\n        \n        allocate( newNode )\n        newNode%data = value\n        newNode%next => nodeBefore%next\n        newNode%previous => nodeBefore\n        \n        if (associated( newNode%next )) then\n            newNode%next%previous => newNode\n        end if\n        newNode%previous%next => newNode\n    end subroutine insertAfter\n   \n    subroutine delete(current)\n        type( node ), intent(inout), pointer :: current\n        \n        if (associated( current%next )) current%next%previous => current%previous\n        if (associated( current%previous )) current%previous%next => current%next\n        deallocate(current)\n    end subroutine delete\nend module dlList\n\nprogram dlListTest\n    use dlList\n    type( node ), target :: head\n    type( node ), pointer :: current, next\n    \n    head%data = 1.0\n    current => head\n    do i = 1, 20\n       call insertAfter(current, 2.0**i)\n       current => current%next\n    end do\n    \n    current => head\n    do while (associated(current))\n        print *, current%data\n        next => current%next\n        if (.not. associated(current, head)) call delete(current)\n        current => next\n    end do\nend program dlListTest\n", "target": "import java.util.LinkedList;\n\n@SuppressWarnings(\"serial\")\npublic class DoublyLinkedListInsertion<T> extends LinkedList<T> {\n   \n    public static void main(String[] args) {\n        DoublyLinkedListInsertion<String> list = new DoublyLinkedListInsertion<String>();\n        list.addFirst(\"Add First 1\");\n        list.addFirst(\"Add First 2\");\n        list.addFirst(\"Add First 3\");\n        list.addFirst(\"Add First 4\");\n        list.addFirst(\"Add First 5\");\n        traverseList(list);\n        \n        list.addAfter(\"Add First 3\", \"Add New\");\n        traverseList(list);\n    }\n    \n    \n    public void addAfter(T after, T element) {\n        int index = indexOf(after);\n        if ( index >= 0 ) {\n            add(index + 1, element);\n        }\n        else {\n            addLast(element);\n        }\n    }\n    \n    private static void traverseList(LinkedList<String> list) {\n        System.out.println(\"Traverse List:\");\n        for ( int i = 0 ; i < list.size() ; i++ ) {\n            System.out.printf(\"Element number %d - Element value = '%s'%n\", i, list.get(i));\n        }\n        System.out.println();\n    }\n    \n}\n"}
{"id": 115420, "name": "Doubly-linked list_Element insertion", "source": "Translate Fortran to Python: module dlList\n    public :: node, insertAfter, getNext\n    \n    type node\n        real :: data\n        type( node ), pointer :: next => null()\n        type( node ), pointer :: previous => null()\n    end type node\n    \ncontains\n    subroutine insertAfter(nodeBefore, value)\n        type( node ), intent(inout), target :: nodeBefore\n        type( node ), pointer :: newNode\n        real, intent(in) :: value\n        \n        allocate( newNode )\n        newNode%data = value\n        newNode%next => nodeBefore%next\n        newNode%previous => nodeBefore\n        \n        if (associated( newNode%next )) then\n            newNode%next%previous => newNode\n        end if\n        newNode%previous%next => newNode\n    end subroutine insertAfter\n   \n    subroutine delete(current)\n        type( node ), intent(inout), pointer :: current\n        \n        if (associated( current%next )) current%next%previous => current%previous\n        if (associated( current%previous )) current%previous%next => current%next\n        deallocate(current)\n    end subroutine delete\nend module dlList\n\nprogram dlListTest\n    use dlList\n    type( node ), target :: head\n    type( node ), pointer :: current, next\n    \n    head%data = 1.0\n    current => head\n    do i = 1, 20\n       call insertAfter(current, 2.0**i)\n       current => current%next\n    end do\n    \n    current => head\n    do while (associated(current))\n        print *, current%data\n        next => current%next\n        if (.not. associated(current, head)) call delete(current)\n        current => next\n    end do\nend program dlListTest\n", "target": "def insert(anchor, new):\n    new.next = anchor.next\n    new.prev = anchor\n    anchor.next.prev = new\n    anchor.next = new\n"}
{"id": 115694, "name": "N-queens problem", "source": "Translate Fortran to C#: program Nqueens\n  implicit none\n\n  integer, parameter :: n = 8  \n  integer :: file = 1, rank = 1, queens = 0\n  integer :: i\n  logical :: board(n,n) = .false.\n\n  do while (queens < n)\n    board(file, rank) = .true.\n    if(is_safe(board, file, rank)) then\n      queens = queens + 1\n      file = 1\n      rank = rank + 1\n    else\n      board(file, rank) = .false.\n      file = file + 1\n      do while(file > n)\n         rank = rank - 1\n         if (rank < 1) then\n           write(*, \"(a,i0)\") \"No solution for n = \", n\n           stop\n         end if  \n         do i = 1, n\n           if (board(i, rank)) then\n             file = i\n             board(file, rank) = .false.\n             queens = queens - 1\n             file = i + 1\n             exit\n           end if\n         end do\n       end do\n    end if\n  end do\n\n  call Printboard(board)\n  \ncontains\n\nfunction is_safe(board, file, rank)\n  logical :: is_safe\n  logical, intent(in) :: board(:,:)\n  integer, intent(in) :: file, rank\n  integer :: i, f, r\n  \n  is_safe = .true.\n  do i = rank-1, 1, -1\n    if(board(file, i)) then\n      is_safe = .false.\n      return\n    end if\n  end do\n  \n  f = file - 1\n  r = rank - 1\n  do while(f > 0 .and. r > 0)\n    if(board(f, r)) then\n      is_safe = .false.\n      return\n    end if\n    f = f - 1\n    r = r - 1\n  end do\n\n  f = file + 1\n  r = rank - 1\n  do while(f <= n .and. r > 0)\n    if(board(f, r)) then\n      is_safe = .false.\n      return\n    end if\n    f = f + 1\n    r = r - 1\n  end do\nend function    \n\nsubroutine Printboard(board)\n  logical, intent(in) :: board(:,:)\n  character(n*4+1) :: line\n  integer :: f, r\n  \n  write(*, \"(a, i0)\") \"n = \", n\n  line = repeat(\"+---\", n) // \"+\"\n  do r = 1, n\n    write(*, \"(a)\") line\n    do f = 1, n\n      write(*, \"(a)\", advance=\"no\") \"|\"\n      if(board(f, r)) then\n        write(*, \"(a)\", advance=\"no\") \" Q \"\n      else if(mod(f+r, 2) == 0) then\n        write(*, \"(a)\", advance=\"no\") \"   \"\n      else\n        write(*, \"(a)\", advance=\"no\") \"###\"\n      end if\n    end do\n    write(*, \"(a)\") \"|\"\n  end do\n  write(*, \"(a)\") line\nend subroutine\nend program\n", "target": "using System.Collections.Generic;\nusing static System.Linq.Enumerable;\nusing static System.Console;\nusing static System.Math;\n\nnamespace N_Queens\n{\n    static class Program\n    {\n        static void Main(string[] args)\n        {\n            var n = 8;\n            var cols = Range(0, n);\n            var combs = cols.Combinations(2).Select(pairs=> pairs.ToArray());\n            var solved = from v in cols.Permutations().Select(p => p.ToArray())\n                         where combs.All(c => Abs(v[c[0]] - v[c[1]]) != Abs(c[0] - c[1]))\n                         select v;\n            \n            WriteLine($\"{n}-queens has {solved.Count()} solutions\");\n            WriteLine(\"Position is row, value is column:-\");\n            var first = string.Join(\" \", solved.First());\n            WriteLine($\"First Solution: {first}\");\n            Read();\n        }\n\n        \n        public static IEnumerable<IEnumerable<T>> Permutations<T>(this IEnumerable<T> values)\n        {\n            if (values.Count() == 1)\n                return values.ToSingleton();\n\n            return values.SelectMany(v => Permutations(values.Except(v.ToSingleton())), (v, p) => p.Prepend(v));\n        }\n\n        public static IEnumerable<IEnumerable<T>> Combinations<T>(this IEnumerable<T> seq) =>\n            seq.Aggregate(Empty<T>().ToSingleton(), (a, b) => a.Concat(a.Select(x => x.Append(b))));\n\n        public static IEnumerable<IEnumerable<T>> Combinations<T>(this IEnumerable<T> seq, int numItems) =>\n            seq.Combinations().Where(s => s.Count() == numItems);\n\n        public static IEnumerable<T> ToSingleton<T>(this T item) { yield return item; }\n    }\n}\n"}
{"id": 115695, "name": "N-queens problem", "source": "Translate Fortran to C#: program Nqueens\n  implicit none\n\n  integer, parameter :: n = 8  \n  integer :: file = 1, rank = 1, queens = 0\n  integer :: i\n  logical :: board(n,n) = .false.\n\n  do while (queens < n)\n    board(file, rank) = .true.\n    if(is_safe(board, file, rank)) then\n      queens = queens + 1\n      file = 1\n      rank = rank + 1\n    else\n      board(file, rank) = .false.\n      file = file + 1\n      do while(file > n)\n         rank = rank - 1\n         if (rank < 1) then\n           write(*, \"(a,i0)\") \"No solution for n = \", n\n           stop\n         end if  \n         do i = 1, n\n           if (board(i, rank)) then\n             file = i\n             board(file, rank) = .false.\n             queens = queens - 1\n             file = i + 1\n             exit\n           end if\n         end do\n       end do\n    end if\n  end do\n\n  call Printboard(board)\n  \ncontains\n\nfunction is_safe(board, file, rank)\n  logical :: is_safe\n  logical, intent(in) :: board(:,:)\n  integer, intent(in) :: file, rank\n  integer :: i, f, r\n  \n  is_safe = .true.\n  do i = rank-1, 1, -1\n    if(board(file, i)) then\n      is_safe = .false.\n      return\n    end if\n  end do\n  \n  f = file - 1\n  r = rank - 1\n  do while(f > 0 .and. r > 0)\n    if(board(f, r)) then\n      is_safe = .false.\n      return\n    end if\n    f = f - 1\n    r = r - 1\n  end do\n\n  f = file + 1\n  r = rank - 1\n  do while(f <= n .and. r > 0)\n    if(board(f, r)) then\n      is_safe = .false.\n      return\n    end if\n    f = f + 1\n    r = r - 1\n  end do\nend function    \n\nsubroutine Printboard(board)\n  logical, intent(in) :: board(:,:)\n  character(n*4+1) :: line\n  integer :: f, r\n  \n  write(*, \"(a, i0)\") \"n = \", n\n  line = repeat(\"+---\", n) // \"+\"\n  do r = 1, n\n    write(*, \"(a)\") line\n    do f = 1, n\n      write(*, \"(a)\", advance=\"no\") \"|\"\n      if(board(f, r)) then\n        write(*, \"(a)\", advance=\"no\") \" Q \"\n      else if(mod(f+r, 2) == 0) then\n        write(*, \"(a)\", advance=\"no\") \"   \"\n      else\n        write(*, \"(a)\", advance=\"no\") \"###\"\n      end if\n    end do\n    write(*, \"(a)\") \"|\"\n  end do\n  write(*, \"(a)\") line\nend subroutine\nend program\n", "target": "using System.Collections.Generic;\nusing static System.Linq.Enumerable;\nusing static System.Console;\nusing static System.Math;\n\nnamespace N_Queens\n{\n    static class Program\n    {\n        static void Main(string[] args)\n        {\n            var n = 8;\n            var cols = Range(0, n);\n            var combs = cols.Combinations(2).Select(pairs=> pairs.ToArray());\n            var solved = from v in cols.Permutations().Select(p => p.ToArray())\n                         where combs.All(c => Abs(v[c[0]] - v[c[1]]) != Abs(c[0] - c[1]))\n                         select v;\n            \n            WriteLine($\"{n}-queens has {solved.Count()} solutions\");\n            WriteLine(\"Position is row, value is column:-\");\n            var first = string.Join(\" \", solved.First());\n            WriteLine($\"First Solution: {first}\");\n            Read();\n        }\n\n        \n        public static IEnumerable<IEnumerable<T>> Permutations<T>(this IEnumerable<T> values)\n        {\n            if (values.Count() == 1)\n                return values.ToSingleton();\n\n            return values.SelectMany(v => Permutations(values.Except(v.ToSingleton())), (v, p) => p.Prepend(v));\n        }\n\n        public static IEnumerable<IEnumerable<T>> Combinations<T>(this IEnumerable<T> seq) =>\n            seq.Aggregate(Empty<T>().ToSingleton(), (a, b) => a.Concat(a.Select(x => x.Append(b))));\n\n        public static IEnumerable<IEnumerable<T>> Combinations<T>(this IEnumerable<T> seq, int numItems) =>\n            seq.Combinations().Where(s => s.Count() == numItems);\n\n        public static IEnumerable<T> ToSingleton<T>(this T item) { yield return item; }\n    }\n}\n"}
{"id": 115700, "name": "N-queens problem", "source": "Translate Fortran to Java: program Nqueens\n  implicit none\n\n  integer, parameter :: n = 8  \n  integer :: file = 1, rank = 1, queens = 0\n  integer :: i\n  logical :: board(n,n) = .false.\n\n  do while (queens < n)\n    board(file, rank) = .true.\n    if(is_safe(board, file, rank)) then\n      queens = queens + 1\n      file = 1\n      rank = rank + 1\n    else\n      board(file, rank) = .false.\n      file = file + 1\n      do while(file > n)\n         rank = rank - 1\n         if (rank < 1) then\n           write(*, \"(a,i0)\") \"No solution for n = \", n\n           stop\n         end if  \n         do i = 1, n\n           if (board(i, rank)) then\n             file = i\n             board(file, rank) = .false.\n             queens = queens - 1\n             file = i + 1\n             exit\n           end if\n         end do\n       end do\n    end if\n  end do\n\n  call Printboard(board)\n  \ncontains\n\nfunction is_safe(board, file, rank)\n  logical :: is_safe\n  logical, intent(in) :: board(:,:)\n  integer, intent(in) :: file, rank\n  integer :: i, f, r\n  \n  is_safe = .true.\n  do i = rank-1, 1, -1\n    if(board(file, i)) then\n      is_safe = .false.\n      return\n    end if\n  end do\n  \n  f = file - 1\n  r = rank - 1\n  do while(f > 0 .and. r > 0)\n    if(board(f, r)) then\n      is_safe = .false.\n      return\n    end if\n    f = f - 1\n    r = r - 1\n  end do\n\n  f = file + 1\n  r = rank - 1\n  do while(f <= n .and. r > 0)\n    if(board(f, r)) then\n      is_safe = .false.\n      return\n    end if\n    f = f + 1\n    r = r - 1\n  end do\nend function    \n\nsubroutine Printboard(board)\n  logical, intent(in) :: board(:,:)\n  character(n*4+1) :: line\n  integer :: f, r\n  \n  write(*, \"(a, i0)\") \"n = \", n\n  line = repeat(\"+---\", n) // \"+\"\n  do r = 1, n\n    write(*, \"(a)\") line\n    do f = 1, n\n      write(*, \"(a)\", advance=\"no\") \"|\"\n      if(board(f, r)) then\n        write(*, \"(a)\", advance=\"no\") \" Q \"\n      else if(mod(f+r, 2) == 0) then\n        write(*, \"(a)\", advance=\"no\") \"   \"\n      else\n        write(*, \"(a)\", advance=\"no\") \"###\"\n      end if\n    end do\n    write(*, \"(a)\") \"|\"\n  end do\n  write(*, \"(a)\") line\nend subroutine\nend program\n", "target": "public class NQueens {\n\n  private static int[] b = new int[8];\n  private static int s = 0;\n\n  static boolean unsafe(int y) {\n    int x = b[y];\n    for (int i = 1; i <= y; i++) {\n      int t = b[y - i];\n      if (t == x ||\n          t == x - i ||\n          t == x + i) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  public static void putboard() {\n    System.out.println(\"\\n\\nSolution \" + (++s));\n    for (int y = 0; y < 8; y++) {\n      for (int x = 0; x < 8; x++) {\n        System.out.print((b[y] == x) ? \"|Q\" : \"|_\");\n      }\n      System.out.println(\"|\");\n    }\n  }\n\n  public static void main(String[] args) {\n    int y = 0;\n    b[0] = -1;\n    while (y >= 0) {\n      do {\n        b[y]++;\n      } while ((b[y] < 8) && unsafe(y));\n      if (b[y] < 8) {\n        if (y < 7) {\n          b[++y] = -1;\n        } else {\n          putboard();\n        }\n      } else {\n        y--;\n      }\n    }\n  }\n}\n"}
{"id": 115701, "name": "N-queens problem", "source": "Translate Fortran to Java: program Nqueens\n  implicit none\n\n  integer, parameter :: n = 8  \n  integer :: file = 1, rank = 1, queens = 0\n  integer :: i\n  logical :: board(n,n) = .false.\n\n  do while (queens < n)\n    board(file, rank) = .true.\n    if(is_safe(board, file, rank)) then\n      queens = queens + 1\n      file = 1\n      rank = rank + 1\n    else\n      board(file, rank) = .false.\n      file = file + 1\n      do while(file > n)\n         rank = rank - 1\n         if (rank < 1) then\n           write(*, \"(a,i0)\") \"No solution for n = \", n\n           stop\n         end if  \n         do i = 1, n\n           if (board(i, rank)) then\n             file = i\n             board(file, rank) = .false.\n             queens = queens - 1\n             file = i + 1\n             exit\n           end if\n         end do\n       end do\n    end if\n  end do\n\n  call Printboard(board)\n  \ncontains\n\nfunction is_safe(board, file, rank)\n  logical :: is_safe\n  logical, intent(in) :: board(:,:)\n  integer, intent(in) :: file, rank\n  integer :: i, f, r\n  \n  is_safe = .true.\n  do i = rank-1, 1, -1\n    if(board(file, i)) then\n      is_safe = .false.\n      return\n    end if\n  end do\n  \n  f = file - 1\n  r = rank - 1\n  do while(f > 0 .and. r > 0)\n    if(board(f, r)) then\n      is_safe = .false.\n      return\n    end if\n    f = f - 1\n    r = r - 1\n  end do\n\n  f = file + 1\n  r = rank - 1\n  do while(f <= n .and. r > 0)\n    if(board(f, r)) then\n      is_safe = .false.\n      return\n    end if\n    f = f + 1\n    r = r - 1\n  end do\nend function    \n\nsubroutine Printboard(board)\n  logical, intent(in) :: board(:,:)\n  character(n*4+1) :: line\n  integer :: f, r\n  \n  write(*, \"(a, i0)\") \"n = \", n\n  line = repeat(\"+---\", n) // \"+\"\n  do r = 1, n\n    write(*, \"(a)\") line\n    do f = 1, n\n      write(*, \"(a)\", advance=\"no\") \"|\"\n      if(board(f, r)) then\n        write(*, \"(a)\", advance=\"no\") \" Q \"\n      else if(mod(f+r, 2) == 0) then\n        write(*, \"(a)\", advance=\"no\") \"   \"\n      else\n        write(*, \"(a)\", advance=\"no\") \"###\"\n      end if\n    end do\n    write(*, \"(a)\") \"|\"\n  end do\n  write(*, \"(a)\") line\nend subroutine\nend program\n", "target": "public class NQueens {\n\n  private static int[] b = new int[8];\n  private static int s = 0;\n\n  static boolean unsafe(int y) {\n    int x = b[y];\n    for (int i = 1; i <= y; i++) {\n      int t = b[y - i];\n      if (t == x ||\n          t == x - i ||\n          t == x + i) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  public static void putboard() {\n    System.out.println(\"\\n\\nSolution \" + (++s));\n    for (int y = 0; y < 8; y++) {\n      for (int x = 0; x < 8; x++) {\n        System.out.print((b[y] == x) ? \"|Q\" : \"|_\");\n      }\n      System.out.println(\"|\");\n    }\n  }\n\n  public static void main(String[] args) {\n    int y = 0;\n    b[0] = -1;\n    while (y >= 0) {\n      do {\n        b[y]++;\n      } while ((b[y] < 8) && unsafe(y));\n      if (b[y] < 8) {\n        if (y < 7) {\n          b[++y] = -1;\n        } else {\n          putboard();\n        }\n      } else {\n        y--;\n      }\n    }\n  }\n}\n"}
{"id": 115702, "name": "N-queens problem", "source": "Translate Fortran to Python: program Nqueens\n  implicit none\n\n  integer, parameter :: n = 8  \n  integer :: file = 1, rank = 1, queens = 0\n  integer :: i\n  logical :: board(n,n) = .false.\n\n  do while (queens < n)\n    board(file, rank) = .true.\n    if(is_safe(board, file, rank)) then\n      queens = queens + 1\n      file = 1\n      rank = rank + 1\n    else\n      board(file, rank) = .false.\n      file = file + 1\n      do while(file > n)\n         rank = rank - 1\n         if (rank < 1) then\n           write(*, \"(a,i0)\") \"No solution for n = \", n\n           stop\n         end if  \n         do i = 1, n\n           if (board(i, rank)) then\n             file = i\n             board(file, rank) = .false.\n             queens = queens - 1\n             file = i + 1\n             exit\n           end if\n         end do\n       end do\n    end if\n  end do\n\n  call Printboard(board)\n  \ncontains\n\nfunction is_safe(board, file, rank)\n  logical :: is_safe\n  logical, intent(in) :: board(:,:)\n  integer, intent(in) :: file, rank\n  integer :: i, f, r\n  \n  is_safe = .true.\n  do i = rank-1, 1, -1\n    if(board(file, i)) then\n      is_safe = .false.\n      return\n    end if\n  end do\n  \n  f = file - 1\n  r = rank - 1\n  do while(f > 0 .and. r > 0)\n    if(board(f, r)) then\n      is_safe = .false.\n      return\n    end if\n    f = f - 1\n    r = r - 1\n  end do\n\n  f = file + 1\n  r = rank - 1\n  do while(f <= n .and. r > 0)\n    if(board(f, r)) then\n      is_safe = .false.\n      return\n    end if\n    f = f + 1\n    r = r - 1\n  end do\nend function    \n\nsubroutine Printboard(board)\n  logical, intent(in) :: board(:,:)\n  character(n*4+1) :: line\n  integer :: f, r\n  \n  write(*, \"(a, i0)\") \"n = \", n\n  line = repeat(\"+---\", n) // \"+\"\n  do r = 1, n\n    write(*, \"(a)\") line\n    do f = 1, n\n      write(*, \"(a)\", advance=\"no\") \"|\"\n      if(board(f, r)) then\n        write(*, \"(a)\", advance=\"no\") \" Q \"\n      else if(mod(f+r, 2) == 0) then\n        write(*, \"(a)\", advance=\"no\") \"   \"\n      else\n        write(*, \"(a)\", advance=\"no\") \"###\"\n      end if\n    end do\n    write(*, \"(a)\") \"|\"\n  end do\n  write(*, \"(a)\") line\nend subroutine\nend program\n", "target": "from itertools import permutations, product\n\nn = 8\ncols = range(n)\ni = 0  \n\nsolutions = [vec for vec in permutations(cols)\n             if n == len(set(vec[i] + i for i in cols))\n                  == len(set(vec[i] - i for i in cols))]\n\ndef setup():\n    size(400, 400)\n    textAlign(CENTER, CENTER)\n    textFont(createFont(\"DejaVu Sans\", 44))\n\ndef draw():\n    background(0)\n    w = width / n\n    for x, y in product(range(n), range(n)):\n        fill(255 * ((x + y) % 2))\n        square(x * w, y * w, w)\n        if solutions[i][y] == x:\n            fill(255 - 255 * ((x + y) % 2))\n            text(u'\u2655', w / 2 + x * w, w / 3 + y * w)\n\ndef keyPressed():  \n    global i\n    i = (i + 1) % len(solutions)\n"}
{"id": 115703, "name": "N-queens problem", "source": "Translate Fortran to Python: program Nqueens\n  implicit none\n\n  integer, parameter :: n = 8  \n  integer :: file = 1, rank = 1, queens = 0\n  integer :: i\n  logical :: board(n,n) = .false.\n\n  do while (queens < n)\n    board(file, rank) = .true.\n    if(is_safe(board, file, rank)) then\n      queens = queens + 1\n      file = 1\n      rank = rank + 1\n    else\n      board(file, rank) = .false.\n      file = file + 1\n      do while(file > n)\n         rank = rank - 1\n         if (rank < 1) then\n           write(*, \"(a,i0)\") \"No solution for n = \", n\n           stop\n         end if  \n         do i = 1, n\n           if (board(i, rank)) then\n             file = i\n             board(file, rank) = .false.\n             queens = queens - 1\n             file = i + 1\n             exit\n           end if\n         end do\n       end do\n    end if\n  end do\n\n  call Printboard(board)\n  \ncontains\n\nfunction is_safe(board, file, rank)\n  logical :: is_safe\n  logical, intent(in) :: board(:,:)\n  integer, intent(in) :: file, rank\n  integer :: i, f, r\n  \n  is_safe = .true.\n  do i = rank-1, 1, -1\n    if(board(file, i)) then\n      is_safe = .false.\n      return\n    end if\n  end do\n  \n  f = file - 1\n  r = rank - 1\n  do while(f > 0 .and. r > 0)\n    if(board(f, r)) then\n      is_safe = .false.\n      return\n    end if\n    f = f - 1\n    r = r - 1\n  end do\n\n  f = file + 1\n  r = rank - 1\n  do while(f <= n .and. r > 0)\n    if(board(f, r)) then\n      is_safe = .false.\n      return\n    end if\n    f = f + 1\n    r = r - 1\n  end do\nend function    \n\nsubroutine Printboard(board)\n  logical, intent(in) :: board(:,:)\n  character(n*4+1) :: line\n  integer :: f, r\n  \n  write(*, \"(a, i0)\") \"n = \", n\n  line = repeat(\"+---\", n) // \"+\"\n  do r = 1, n\n    write(*, \"(a)\") line\n    do f = 1, n\n      write(*, \"(a)\", advance=\"no\") \"|\"\n      if(board(f, r)) then\n        write(*, \"(a)\", advance=\"no\") \" Q \"\n      else if(mod(f+r, 2) == 0) then\n        write(*, \"(a)\", advance=\"no\") \"   \"\n      else\n        write(*, \"(a)\", advance=\"no\") \"###\"\n      end if\n    end do\n    write(*, \"(a)\") \"|\"\n  end do\n  write(*, \"(a)\") line\nend subroutine\nend program\n", "target": "from itertools import permutations, product\n\nn = 8\ncols = range(n)\ni = 0  \n\nsolutions = [vec for vec in permutations(cols)\n             if n == len(set(vec[i] + i for i in cols))\n                  == len(set(vec[i] - i for i in cols))]\n\ndef setup():\n    size(400, 400)\n    textAlign(CENTER, CENTER)\n    textFont(createFont(\"DejaVu Sans\", 44))\n\ndef draw():\n    background(0)\n    w = width / n\n    for x, y in product(range(n), range(n)):\n        fill(255 * ((x + y) % 2))\n        square(x * w, y * w, w)\n        if solutions[i][y] == x:\n            fill(255 - 255 * ((x + y) % 2))\n            text(u'\u2655', w / 2 + x * w, w / 3 + y * w)\n\ndef keyPressed():  \n    global i\n    i = (i + 1) % len(solutions)\n"}
{"id": 116155, "name": "Four bit adder", "source": "Translate Fortran to C#: module logic\n  implicit none\n\ncontains\n\nfunction xor(a, b)\n  logical :: xor\n  logical, intent(in) :: a, b\n\n  xor = (a .and. .not. b) .or. (b .and. .not. a)\nend function xor\n\nfunction halfadder(a, b, c)\n  logical :: halfadder\n  logical, intent(in)  :: a, b\n  logical, intent(out) :: c\n\n  halfadder = xor(a, b)\n  c = a .and. b\nend function halfadder\n\nfunction fulladder(a, b, c0, c1)\n  logical :: fulladder\n  logical, intent(in)  :: a, b, c0\n  logical, intent(out) :: c1\n  logical :: c2, c3\n\n  fulladder = halfadder(halfadder(c0, a, c2), b, c3)\n  c1 = c2 .or. c3\nend function fulladder\n\nsubroutine fourbitadder(a, b, s)\n  logical, intent(in)  :: a(0:3), b(0:3)\n  logical, intent(out) :: s(0:4)\n  logical :: c0, c1, c2\n\n  s(0) = fulladder(a(0), b(0), .false., c0)  \n  s(1) = fulladder(a(1), b(1), c0, c1)\n  s(2) = fulladder(a(2), b(2), c1, c2)\n  s(3) = fulladder(a(3), b(3), c2, s(4))\nend subroutine fourbitadder\nend module\n\nprogram Four_bit_adder\n  use logic\n  implicit none\n  \n  logical, dimension(0:3) :: a, b\n  logical, dimension(0:4) :: s\n  integer, dimension(0:3) :: ai, bi\n  integer, dimension(0:4) :: si\n  integer :: i, j\n\n  do i = 0, 15\n    a(0) = btest(i, 0); a(1) = btest(i, 1); a(2) = btest(i, 2); a(3) = btest(i, 3)\n    where(a)\n      ai = 1\n    else where\n      ai = 0\n    end where\n    do j = 0, 15\n      b(0) = btest(j, 0); b(1) = btest(j, 1); b(2) = btest(j, 2); b(3) = btest(j, 3)\n      where(b)\n        bi = 1\n      else where\n        bi = 0\n      end where\n      call fourbitadder(a, b, s)\n      where (s)\n        si = 1\n      elsewhere\n        si = 0\n      end where\n      write(*, \"(4i1,a,4i1,a,5i1)\") ai(3:0:-1), \" + \", bi(3:0:-1), \" = \", si(4:0:-1)\n    end do\n  end do  \nend program\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\nnamespace RosettaCodeTasks.FourBitAdder\n{\n\tpublic struct BitAdderOutput\n\t{\n\t\tpublic bool S { get; set; }\n\t\tpublic bool C { get; set; }\n\t\tpublic override string ToString ( )\n\t\t{\n\t\t\treturn \"S\" + ( S ? \"1\" : \"0\" ) + \"C\" + ( C ? \"1\" : \"0\" );\n\t\t}\n\t}\n\tpublic struct Nibble\n\t{\n\t\tpublic bool _1 { get; set; }\n\t\tpublic bool _2 { get; set; }\n\t\tpublic bool _3 { get; set; }\n\t\tpublic bool _4 { get; set; }\n\t\tpublic override string ToString ( )\n\t\t{\n\t\t\treturn ( _4 ? \"1\" : \"0\" )\n\t\t\t\t+ ( _3 ? \"1\" : \"0\" )\n\t\t\t\t+ ( _2 ? \"1\" : \"0\" )\n\t\t\t\t+ ( _1 ? \"1\" : \"0\" );\n\t\t}\n\t}\n\tpublic struct FourBitAdderOutput\n\t{\n\t\tpublic Nibble N { get; set; }\n\t\tpublic bool C { get; set; }\n\t\tpublic override string ToString ( )\n\t\t{\n\t\t\treturn N.ToString ( ) + \"c\" + ( C ? \"1\" : \"0\" );\n\t\t}\n\t}\n\n\tpublic static class LogicGates\n\t{\n\t\t\n\t\tpublic static bool Not ( bool A ) { return !A; }\n\t\tpublic static bool And ( bool A, bool B ) { return A && B; }\n\t\tpublic static bool Or ( bool A, bool B ) { return A || B; }\n\n\t\t\n\t\tpublic static bool Xor ( bool A, bool B ) {\treturn Or ( And ( A, Not ( B ) ), ( And ( Not ( A ), B ) ) ); }\n\t}\n\n\tpublic static class ConstructiveBlocks\n\t{\n\t\tpublic static BitAdderOutput HalfAdder ( bool A, bool B )\n\t\t{\n\t\t\treturn new BitAdderOutput ( ) { S = LogicGates.Xor ( A, B ), C = LogicGates.And ( A, B ) };\n\t\t}\n\n\t\tpublic static BitAdderOutput FullAdder ( bool A, bool B, bool CI )\n\t\t{\n\t\t\tBitAdderOutput HA1 = HalfAdder ( CI, A );\n\t\t\tBitAdderOutput HA2 = HalfAdder ( HA1.S, B );\n\n\t\t\treturn new BitAdderOutput ( ) { S = HA2.S, C = LogicGates.Or ( HA1.C, HA2.C ) };\n\t\t}\n\n\t\tpublic static FourBitAdderOutput FourBitAdder ( Nibble A, Nibble B, bool CI )\n\t\t{\n\n\t\t\tBitAdderOutput FA1 = FullAdder ( A._1, B._1, CI );\n\t\t\tBitAdderOutput FA2 = FullAdder ( A._2, B._2, FA1.C );\n\t\t\tBitAdderOutput FA3 = FullAdder ( A._3, B._3, FA2.C );\n\t\t\tBitAdderOutput FA4 = FullAdder ( A._4, B._4, FA3.C );\n\n\t\t\treturn new FourBitAdderOutput ( ) { N = new Nibble ( ) { _1 = FA1.S, _2 = FA2.S, _3 = FA3.S, _4 = FA4.S }, C = FA4.C };\n\t\t}\n\n\t\tpublic static void Test ( )\n\t\t{\n\t\t\tConsole.WriteLine ( \"Four Bit Adder\" );\n\n\t\t\tfor ( int i = 0; i < 256; i++ )\n\t\t\t{\n\t\t\t\tNibble A = new Nibble ( ) { _1 = false, _2 = false, _3 = false, _4 = false };\n\t\t\t\tNibble B = new Nibble ( ) { _1 = false, _2 = false, _3 = false, _4 = false };\n\t\t\t\tif ( (i & 1) == 1)\n\t\t\t\t{\n\t\t\t\t\tA._1 = true;\n\t\t\t\t}\n\t\t\t\tif ( ( i & 2 ) == 2 )\n\t\t\t\t{\n\t\t\t\t\tA._2 = true;\n\t\t\t\t}\n\t\t\t\tif ( ( i & 4 ) == 4 )\n\t\t\t\t{\n\t\t\t\t\tA._3 = true;\n\t\t\t\t}\n\t\t\t\tif ( ( i & 8 ) == 8 )\n\t\t\t\t{\n\t\t\t\t\tA._4 = true;\n\t\t\t\t}\n\t\t\t\tif ( ( i & 16 ) == 16 )\n\t\t\t\t{\n\t\t\t\t\tB._1 = true;\n\t\t\t\t}\n\t\t\t\tif ( ( i & 32 ) == 32)\n\t\t\t\t{\n\t\t\t\t\tB._2 = true;\n\t\t\t\t}\n\t\t\t\tif ( ( i & 64 ) == 64 )\n\t\t\t\t{\n\t\t\t\t\tB._3 = true;\n\t\t\t\t}\n\t\t\t\tif ( ( i & 128 ) == 128 )\n\t\t\t\t{\n\t\t\t\t\tB._4 = true;\n\t\t\t\t}\n\n\t\t\t\tConsole.WriteLine ( \"{0} + {1} = {2}\", A.ToString ( ), B.ToString ( ), FourBitAdder( A, B, false ).ToString ( ) );\n\n\t\t\t}\n\n\t\t\tConsole.WriteLine ( );\n\t\t}\n\n\t}\n}\n"}
{"id": 116156, "name": "Four bit adder", "source": "Translate Fortran to C#: module logic\n  implicit none\n\ncontains\n\nfunction xor(a, b)\n  logical :: xor\n  logical, intent(in) :: a, b\n\n  xor = (a .and. .not. b) .or. (b .and. .not. a)\nend function xor\n\nfunction halfadder(a, b, c)\n  logical :: halfadder\n  logical, intent(in)  :: a, b\n  logical, intent(out) :: c\n\n  halfadder = xor(a, b)\n  c = a .and. b\nend function halfadder\n\nfunction fulladder(a, b, c0, c1)\n  logical :: fulladder\n  logical, intent(in)  :: a, b, c0\n  logical, intent(out) :: c1\n  logical :: c2, c3\n\n  fulladder = halfadder(halfadder(c0, a, c2), b, c3)\n  c1 = c2 .or. c3\nend function fulladder\n\nsubroutine fourbitadder(a, b, s)\n  logical, intent(in)  :: a(0:3), b(0:3)\n  logical, intent(out) :: s(0:4)\n  logical :: c0, c1, c2\n\n  s(0) = fulladder(a(0), b(0), .false., c0)  \n  s(1) = fulladder(a(1), b(1), c0, c1)\n  s(2) = fulladder(a(2), b(2), c1, c2)\n  s(3) = fulladder(a(3), b(3), c2, s(4))\nend subroutine fourbitadder\nend module\n\nprogram Four_bit_adder\n  use logic\n  implicit none\n  \n  logical, dimension(0:3) :: a, b\n  logical, dimension(0:4) :: s\n  integer, dimension(0:3) :: ai, bi\n  integer, dimension(0:4) :: si\n  integer :: i, j\n\n  do i = 0, 15\n    a(0) = btest(i, 0); a(1) = btest(i, 1); a(2) = btest(i, 2); a(3) = btest(i, 3)\n    where(a)\n      ai = 1\n    else where\n      ai = 0\n    end where\n    do j = 0, 15\n      b(0) = btest(j, 0); b(1) = btest(j, 1); b(2) = btest(j, 2); b(3) = btest(j, 3)\n      where(b)\n        bi = 1\n      else where\n        bi = 0\n      end where\n      call fourbitadder(a, b, s)\n      where (s)\n        si = 1\n      elsewhere\n        si = 0\n      end where\n      write(*, \"(4i1,a,4i1,a,5i1)\") ai(3:0:-1), \" + \", bi(3:0:-1), \" = \", si(4:0:-1)\n    end do\n  end do  \nend program\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\nnamespace RosettaCodeTasks.FourBitAdder\n{\n\tpublic struct BitAdderOutput\n\t{\n\t\tpublic bool S { get; set; }\n\t\tpublic bool C { get; set; }\n\t\tpublic override string ToString ( )\n\t\t{\n\t\t\treturn \"S\" + ( S ? \"1\" : \"0\" ) + \"C\" + ( C ? \"1\" : \"0\" );\n\t\t}\n\t}\n\tpublic struct Nibble\n\t{\n\t\tpublic bool _1 { get; set; }\n\t\tpublic bool _2 { get; set; }\n\t\tpublic bool _3 { get; set; }\n\t\tpublic bool _4 { get; set; }\n\t\tpublic override string ToString ( )\n\t\t{\n\t\t\treturn ( _4 ? \"1\" : \"0\" )\n\t\t\t\t+ ( _3 ? \"1\" : \"0\" )\n\t\t\t\t+ ( _2 ? \"1\" : \"0\" )\n\t\t\t\t+ ( _1 ? \"1\" : \"0\" );\n\t\t}\n\t}\n\tpublic struct FourBitAdderOutput\n\t{\n\t\tpublic Nibble N { get; set; }\n\t\tpublic bool C { get; set; }\n\t\tpublic override string ToString ( )\n\t\t{\n\t\t\treturn N.ToString ( ) + \"c\" + ( C ? \"1\" : \"0\" );\n\t\t}\n\t}\n\n\tpublic static class LogicGates\n\t{\n\t\t\n\t\tpublic static bool Not ( bool A ) { return !A; }\n\t\tpublic static bool And ( bool A, bool B ) { return A && B; }\n\t\tpublic static bool Or ( bool A, bool B ) { return A || B; }\n\n\t\t\n\t\tpublic static bool Xor ( bool A, bool B ) {\treturn Or ( And ( A, Not ( B ) ), ( And ( Not ( A ), B ) ) ); }\n\t}\n\n\tpublic static class ConstructiveBlocks\n\t{\n\t\tpublic static BitAdderOutput HalfAdder ( bool A, bool B )\n\t\t{\n\t\t\treturn new BitAdderOutput ( ) { S = LogicGates.Xor ( A, B ), C = LogicGates.And ( A, B ) };\n\t\t}\n\n\t\tpublic static BitAdderOutput FullAdder ( bool A, bool B, bool CI )\n\t\t{\n\t\t\tBitAdderOutput HA1 = HalfAdder ( CI, A );\n\t\t\tBitAdderOutput HA2 = HalfAdder ( HA1.S, B );\n\n\t\t\treturn new BitAdderOutput ( ) { S = HA2.S, C = LogicGates.Or ( HA1.C, HA2.C ) };\n\t\t}\n\n\t\tpublic static FourBitAdderOutput FourBitAdder ( Nibble A, Nibble B, bool CI )\n\t\t{\n\n\t\t\tBitAdderOutput FA1 = FullAdder ( A._1, B._1, CI );\n\t\t\tBitAdderOutput FA2 = FullAdder ( A._2, B._2, FA1.C );\n\t\t\tBitAdderOutput FA3 = FullAdder ( A._3, B._3, FA2.C );\n\t\t\tBitAdderOutput FA4 = FullAdder ( A._4, B._4, FA3.C );\n\n\t\t\treturn new FourBitAdderOutput ( ) { N = new Nibble ( ) { _1 = FA1.S, _2 = FA2.S, _3 = FA3.S, _4 = FA4.S }, C = FA4.C };\n\t\t}\n\n\t\tpublic static void Test ( )\n\t\t{\n\t\t\tConsole.WriteLine ( \"Four Bit Adder\" );\n\n\t\t\tfor ( int i = 0; i < 256; i++ )\n\t\t\t{\n\t\t\t\tNibble A = new Nibble ( ) { _1 = false, _2 = false, _3 = false, _4 = false };\n\t\t\t\tNibble B = new Nibble ( ) { _1 = false, _2 = false, _3 = false, _4 = false };\n\t\t\t\tif ( (i & 1) == 1)\n\t\t\t\t{\n\t\t\t\t\tA._1 = true;\n\t\t\t\t}\n\t\t\t\tif ( ( i & 2 ) == 2 )\n\t\t\t\t{\n\t\t\t\t\tA._2 = true;\n\t\t\t\t}\n\t\t\t\tif ( ( i & 4 ) == 4 )\n\t\t\t\t{\n\t\t\t\t\tA._3 = true;\n\t\t\t\t}\n\t\t\t\tif ( ( i & 8 ) == 8 )\n\t\t\t\t{\n\t\t\t\t\tA._4 = true;\n\t\t\t\t}\n\t\t\t\tif ( ( i & 16 ) == 16 )\n\t\t\t\t{\n\t\t\t\t\tB._1 = true;\n\t\t\t\t}\n\t\t\t\tif ( ( i & 32 ) == 32)\n\t\t\t\t{\n\t\t\t\t\tB._2 = true;\n\t\t\t\t}\n\t\t\t\tif ( ( i & 64 ) == 64 )\n\t\t\t\t{\n\t\t\t\t\tB._3 = true;\n\t\t\t\t}\n\t\t\t\tif ( ( i & 128 ) == 128 )\n\t\t\t\t{\n\t\t\t\t\tB._4 = true;\n\t\t\t\t}\n\n\t\t\t\tConsole.WriteLine ( \"{0} + {1} = {2}\", A.ToString ( ), B.ToString ( ), FourBitAdder( A, B, false ).ToString ( ) );\n\n\t\t\t}\n\n\t\t\tConsole.WriteLine ( );\n\t\t}\n\n\t}\n}\n"}
{"id": 116159, "name": "Four bit adder", "source": "Translate Fortran to Java: module logic\n  implicit none\n\ncontains\n\nfunction xor(a, b)\n  logical :: xor\n  logical, intent(in) :: a, b\n\n  xor = (a .and. .not. b) .or. (b .and. .not. a)\nend function xor\n\nfunction halfadder(a, b, c)\n  logical :: halfadder\n  logical, intent(in)  :: a, b\n  logical, intent(out) :: c\n\n  halfadder = xor(a, b)\n  c = a .and. b\nend function halfadder\n\nfunction fulladder(a, b, c0, c1)\n  logical :: fulladder\n  logical, intent(in)  :: a, b, c0\n  logical, intent(out) :: c1\n  logical :: c2, c3\n\n  fulladder = halfadder(halfadder(c0, a, c2), b, c3)\n  c1 = c2 .or. c3\nend function fulladder\n\nsubroutine fourbitadder(a, b, s)\n  logical, intent(in)  :: a(0:3), b(0:3)\n  logical, intent(out) :: s(0:4)\n  logical :: c0, c1, c2\n\n  s(0) = fulladder(a(0), b(0), .false., c0)  \n  s(1) = fulladder(a(1), b(1), c0, c1)\n  s(2) = fulladder(a(2), b(2), c1, c2)\n  s(3) = fulladder(a(3), b(3), c2, s(4))\nend subroutine fourbitadder\nend module\n\nprogram Four_bit_adder\n  use logic\n  implicit none\n  \n  logical, dimension(0:3) :: a, b\n  logical, dimension(0:4) :: s\n  integer, dimension(0:3) :: ai, bi\n  integer, dimension(0:4) :: si\n  integer :: i, j\n\n  do i = 0, 15\n    a(0) = btest(i, 0); a(1) = btest(i, 1); a(2) = btest(i, 2); a(3) = btest(i, 3)\n    where(a)\n      ai = 1\n    else where\n      ai = 0\n    end where\n    do j = 0, 15\n      b(0) = btest(j, 0); b(1) = btest(j, 1); b(2) = btest(j, 2); b(3) = btest(j, 3)\n      where(b)\n        bi = 1\n      else where\n        bi = 0\n      end where\n      call fourbitadder(a, b, s)\n      where (s)\n        si = 1\n      elsewhere\n        si = 0\n      end where\n      write(*, \"(4i1,a,4i1,a,5i1)\") ai(3:0:-1), \" + \", bi(3:0:-1), \" = \", si(4:0:-1)\n    end do\n  end do  \nend program\n", "target": "public class GateLogic\n{\n  \n  public interface OneInputGate\n  {  boolean eval(boolean input);  }\n  \n  public interface TwoInputGate\n  {  boolean eval(boolean input1, boolean input2);  }\n  \n  public interface MultiGate\n  {  boolean[] eval(boolean... inputs);  }\n  \n  \n  public static OneInputGate NOT = new OneInputGate() {\n    public boolean eval(boolean input)\n    {  return !input;  }\n  };\n  \n  \n  public static TwoInputGate AND = new TwoInputGate() {\n    public boolean eval(boolean input1, boolean input2)\n    {  return input1 && input2;  }\n  };\n  \n  \n  public static TwoInputGate OR = new TwoInputGate() {\n    public boolean eval(boolean input1, boolean input2)\n    {  return input1 || input2;  }\n  };\n  \n  \n  public static TwoInputGate XOR = new TwoInputGate() {\n    public boolean eval(boolean input1, boolean input2)\n    {\n      return OR.eval(\n               AND.eval(input1, NOT.eval(input2)),\n               AND.eval(NOT.eval(input1), input2)\n             );\n    }\n  };\n  \n  \n  public static MultiGate HALF_ADDER = new MultiGate() {\n    public boolean[] eval(boolean... inputs)\n    {\n      if (inputs.length != 2)\n        throw new IllegalArgumentException();\n      return new boolean[] {\n        XOR.eval(inputs[0], inputs[1]),  \n        AND.eval(inputs[0], inputs[1])   \n      };\n    }\n  };\n  \n  \n  public static MultiGate FULL_ADDER = new MultiGate() {\n    public boolean[] eval(boolean... inputs)\n    {\n      if (inputs.length != 3)\n        throw new IllegalArgumentException();\n      \n      \n      boolean[] haOutputs1 = HALF_ADDER.eval(inputs[0], inputs[1]);\n      boolean[] haOutputs2 = HALF_ADDER.eval(haOutputs1[0], inputs[2]);\n      return new boolean[] {\n        haOutputs2[0],                         \n        OR.eval(haOutputs1[1], haOutputs2[1])  \n      };\n    }\n  };\n  \n  public static MultiGate buildAdder(final int numBits)\n  {\n    return new MultiGate() {\n      public boolean[] eval(boolean... inputs)\n      {\n        \n        if (inputs.length != (numBits << 1))\n          throw new IllegalArgumentException();\n        boolean[] outputs = new boolean[numBits + 1];\n        boolean[] faInputs = new boolean[3];\n        boolean[] faOutputs = null;\n        for (int i = 0; i < numBits; i++)\n        {\n          faInputs[0] = (faOutputs == null) ? false : faOutputs[1];  \n          faInputs[1] = inputs[i];                                   \n          faInputs[2] = inputs[numBits + i];                         \n          faOutputs = FULL_ADDER.eval(faInputs);\n          outputs[i] = faOutputs[0];                                 \n        }\n        if (faOutputs != null)\n          outputs[numBits] = faOutputs[1];                           \n        return outputs;\n      }\n    };\n  }\n  \n  public static void main(String[] args)\n  {\n    int numBits = Integer.parseInt(args[0]);\n    int firstNum = Integer.parseInt(args[1]);\n    int secondNum = Integer.parseInt(args[2]);\n    int maxNum = 1 << numBits;\n    if ((firstNum < 0) || (firstNum >= maxNum))\n    {\n      System.out.println(\"First number is out of range\");\n      return;\n    }\n    if ((secondNum < 0) || (secondNum >= maxNum))\n    {\n      System.out.println(\"Second number is out of range\");\n      return;\n    }\n    \n    MultiGate multiBitAdder = buildAdder(numBits);\n    \n    boolean[] inputs = new boolean[numBits << 1];\n    String firstNumDisplay = \"\";\n    String secondNumDisplay = \"\";\n    for (int i = 0; i < numBits; i++)\n    {\n      boolean firstBit = ((firstNum >>> i) & 1) == 1;\n      boolean secondBit = ((secondNum >>> i) & 1) == 1;\n      inputs[i] = firstBit;\n      inputs[numBits + i] = secondBit;\n      firstNumDisplay = (firstBit ? \"1\" : \"0\") + firstNumDisplay;\n      secondNumDisplay = (secondBit ? \"1\" : \"0\") + secondNumDisplay;\n    }\n    \n    boolean[] outputs = multiBitAdder.eval(inputs);\n    int outputNum = 0;\n    String outputNumDisplay = \"\";\n    String outputCarryDisplay = null;\n    for (int i = numBits; i >= 0; i--)\n    {\n      outputNum = (outputNum << 1) | (outputs[i] ? 1 : 0);\n      if (i == numBits)\n        outputCarryDisplay = outputs[i] ? \"1\" : \"0\";\n      else\n        outputNumDisplay += (outputs[i] ? \"1\" : \"0\");\n    }\n    System.out.println(\"numBits=\" + numBits);\n    System.out.println(\"A=\" + firstNumDisplay + \" (\" + firstNum + \"), B=\" + secondNumDisplay + \" (\" + secondNum + \"), S=\" + outputCarryDisplay + \" \" + outputNumDisplay + \" (\" + outputNum + \")\");\n    return;\n  }\n  \n}\n"}
{"id": 116160, "name": "Four bit adder", "source": "Translate Fortran to Java: module logic\n  implicit none\n\ncontains\n\nfunction xor(a, b)\n  logical :: xor\n  logical, intent(in) :: a, b\n\n  xor = (a .and. .not. b) .or. (b .and. .not. a)\nend function xor\n\nfunction halfadder(a, b, c)\n  logical :: halfadder\n  logical, intent(in)  :: a, b\n  logical, intent(out) :: c\n\n  halfadder = xor(a, b)\n  c = a .and. b\nend function halfadder\n\nfunction fulladder(a, b, c0, c1)\n  logical :: fulladder\n  logical, intent(in)  :: a, b, c0\n  logical, intent(out) :: c1\n  logical :: c2, c3\n\n  fulladder = halfadder(halfadder(c0, a, c2), b, c3)\n  c1 = c2 .or. c3\nend function fulladder\n\nsubroutine fourbitadder(a, b, s)\n  logical, intent(in)  :: a(0:3), b(0:3)\n  logical, intent(out) :: s(0:4)\n  logical :: c0, c1, c2\n\n  s(0) = fulladder(a(0), b(0), .false., c0)  \n  s(1) = fulladder(a(1), b(1), c0, c1)\n  s(2) = fulladder(a(2), b(2), c1, c2)\n  s(3) = fulladder(a(3), b(3), c2, s(4))\nend subroutine fourbitadder\nend module\n\nprogram Four_bit_adder\n  use logic\n  implicit none\n  \n  logical, dimension(0:3) :: a, b\n  logical, dimension(0:4) :: s\n  integer, dimension(0:3) :: ai, bi\n  integer, dimension(0:4) :: si\n  integer :: i, j\n\n  do i = 0, 15\n    a(0) = btest(i, 0); a(1) = btest(i, 1); a(2) = btest(i, 2); a(3) = btest(i, 3)\n    where(a)\n      ai = 1\n    else where\n      ai = 0\n    end where\n    do j = 0, 15\n      b(0) = btest(j, 0); b(1) = btest(j, 1); b(2) = btest(j, 2); b(3) = btest(j, 3)\n      where(b)\n        bi = 1\n      else where\n        bi = 0\n      end where\n      call fourbitadder(a, b, s)\n      where (s)\n        si = 1\n      elsewhere\n        si = 0\n      end where\n      write(*, \"(4i1,a,4i1,a,5i1)\") ai(3:0:-1), \" + \", bi(3:0:-1), \" = \", si(4:0:-1)\n    end do\n  end do  \nend program\n", "target": "public class GateLogic\n{\n  \n  public interface OneInputGate\n  {  boolean eval(boolean input);  }\n  \n  public interface TwoInputGate\n  {  boolean eval(boolean input1, boolean input2);  }\n  \n  public interface MultiGate\n  {  boolean[] eval(boolean... inputs);  }\n  \n  \n  public static OneInputGate NOT = new OneInputGate() {\n    public boolean eval(boolean input)\n    {  return !input;  }\n  };\n  \n  \n  public static TwoInputGate AND = new TwoInputGate() {\n    public boolean eval(boolean input1, boolean input2)\n    {  return input1 && input2;  }\n  };\n  \n  \n  public static TwoInputGate OR = new TwoInputGate() {\n    public boolean eval(boolean input1, boolean input2)\n    {  return input1 || input2;  }\n  };\n  \n  \n  public static TwoInputGate XOR = new TwoInputGate() {\n    public boolean eval(boolean input1, boolean input2)\n    {\n      return OR.eval(\n               AND.eval(input1, NOT.eval(input2)),\n               AND.eval(NOT.eval(input1), input2)\n             );\n    }\n  };\n  \n  \n  public static MultiGate HALF_ADDER = new MultiGate() {\n    public boolean[] eval(boolean... inputs)\n    {\n      if (inputs.length != 2)\n        throw new IllegalArgumentException();\n      return new boolean[] {\n        XOR.eval(inputs[0], inputs[1]),  \n        AND.eval(inputs[0], inputs[1])   \n      };\n    }\n  };\n  \n  \n  public static MultiGate FULL_ADDER = new MultiGate() {\n    public boolean[] eval(boolean... inputs)\n    {\n      if (inputs.length != 3)\n        throw new IllegalArgumentException();\n      \n      \n      boolean[] haOutputs1 = HALF_ADDER.eval(inputs[0], inputs[1]);\n      boolean[] haOutputs2 = HALF_ADDER.eval(haOutputs1[0], inputs[2]);\n      return new boolean[] {\n        haOutputs2[0],                         \n        OR.eval(haOutputs1[1], haOutputs2[1])  \n      };\n    }\n  };\n  \n  public static MultiGate buildAdder(final int numBits)\n  {\n    return new MultiGate() {\n      public boolean[] eval(boolean... inputs)\n      {\n        \n        if (inputs.length != (numBits << 1))\n          throw new IllegalArgumentException();\n        boolean[] outputs = new boolean[numBits + 1];\n        boolean[] faInputs = new boolean[3];\n        boolean[] faOutputs = null;\n        for (int i = 0; i < numBits; i++)\n        {\n          faInputs[0] = (faOutputs == null) ? false : faOutputs[1];  \n          faInputs[1] = inputs[i];                                   \n          faInputs[2] = inputs[numBits + i];                         \n          faOutputs = FULL_ADDER.eval(faInputs);\n          outputs[i] = faOutputs[0];                                 \n        }\n        if (faOutputs != null)\n          outputs[numBits] = faOutputs[1];                           \n        return outputs;\n      }\n    };\n  }\n  \n  public static void main(String[] args)\n  {\n    int numBits = Integer.parseInt(args[0]);\n    int firstNum = Integer.parseInt(args[1]);\n    int secondNum = Integer.parseInt(args[2]);\n    int maxNum = 1 << numBits;\n    if ((firstNum < 0) || (firstNum >= maxNum))\n    {\n      System.out.println(\"First number is out of range\");\n      return;\n    }\n    if ((secondNum < 0) || (secondNum >= maxNum))\n    {\n      System.out.println(\"Second number is out of range\");\n      return;\n    }\n    \n    MultiGate multiBitAdder = buildAdder(numBits);\n    \n    boolean[] inputs = new boolean[numBits << 1];\n    String firstNumDisplay = \"\";\n    String secondNumDisplay = \"\";\n    for (int i = 0; i < numBits; i++)\n    {\n      boolean firstBit = ((firstNum >>> i) & 1) == 1;\n      boolean secondBit = ((secondNum >>> i) & 1) == 1;\n      inputs[i] = firstBit;\n      inputs[numBits + i] = secondBit;\n      firstNumDisplay = (firstBit ? \"1\" : \"0\") + firstNumDisplay;\n      secondNumDisplay = (secondBit ? \"1\" : \"0\") + secondNumDisplay;\n    }\n    \n    boolean[] outputs = multiBitAdder.eval(inputs);\n    int outputNum = 0;\n    String outputNumDisplay = \"\";\n    String outputCarryDisplay = null;\n    for (int i = numBits; i >= 0; i--)\n    {\n      outputNum = (outputNum << 1) | (outputs[i] ? 1 : 0);\n      if (i == numBits)\n        outputCarryDisplay = outputs[i] ? \"1\" : \"0\";\n      else\n        outputNumDisplay += (outputs[i] ? \"1\" : \"0\");\n    }\n    System.out.println(\"numBits=\" + numBits);\n    System.out.println(\"A=\" + firstNumDisplay + \" (\" + firstNum + \"), B=\" + secondNumDisplay + \" (\" + secondNum + \"), S=\" + outputCarryDisplay + \" \" + outputNumDisplay + \" (\" + outputNum + \")\");\n    return;\n  }\n  \n}\n"}
{"id": 116161, "name": "Four bit adder", "source": "Translate Fortran to Python: module logic\n  implicit none\n\ncontains\n\nfunction xor(a, b)\n  logical :: xor\n  logical, intent(in) :: a, b\n\n  xor = (a .and. .not. b) .or. (b .and. .not. a)\nend function xor\n\nfunction halfadder(a, b, c)\n  logical :: halfadder\n  logical, intent(in)  :: a, b\n  logical, intent(out) :: c\n\n  halfadder = xor(a, b)\n  c = a .and. b\nend function halfadder\n\nfunction fulladder(a, b, c0, c1)\n  logical :: fulladder\n  logical, intent(in)  :: a, b, c0\n  logical, intent(out) :: c1\n  logical :: c2, c3\n\n  fulladder = halfadder(halfadder(c0, a, c2), b, c3)\n  c1 = c2 .or. c3\nend function fulladder\n\nsubroutine fourbitadder(a, b, s)\n  logical, intent(in)  :: a(0:3), b(0:3)\n  logical, intent(out) :: s(0:4)\n  logical :: c0, c1, c2\n\n  s(0) = fulladder(a(0), b(0), .false., c0)  \n  s(1) = fulladder(a(1), b(1), c0, c1)\n  s(2) = fulladder(a(2), b(2), c1, c2)\n  s(3) = fulladder(a(3), b(3), c2, s(4))\nend subroutine fourbitadder\nend module\n\nprogram Four_bit_adder\n  use logic\n  implicit none\n  \n  logical, dimension(0:3) :: a, b\n  logical, dimension(0:4) :: s\n  integer, dimension(0:3) :: ai, bi\n  integer, dimension(0:4) :: si\n  integer :: i, j\n\n  do i = 0, 15\n    a(0) = btest(i, 0); a(1) = btest(i, 1); a(2) = btest(i, 2); a(3) = btest(i, 3)\n    where(a)\n      ai = 1\n    else where\n      ai = 0\n    end where\n    do j = 0, 15\n      b(0) = btest(j, 0); b(1) = btest(j, 1); b(2) = btest(j, 2); b(3) = btest(j, 3)\n      where(b)\n        bi = 1\n      else where\n        bi = 0\n      end where\n      call fourbitadder(a, b, s)\n      where (s)\n        si = 1\n      elsewhere\n        si = 0\n      end where\n      write(*, \"(4i1,a,4i1,a,5i1)\") ai(3:0:-1), \" + \", bi(3:0:-1), \" = \", si(4:0:-1)\n    end do\n  end do  \nend program\n", "target": "\n\nfrom myhdl import *\n\n\n\n@block\ndef NOTgate( a,  q ):   \n   \n   @always_comb   \n   def NOTgateLogic():\n      q.next = not a\n\n   return NOTgateLogic   \n\n\n@block\ndef ANDgate( a, b,  q ):\n   \n   @always_comb \n   def ANDgateLogic():\n      q.next = a and b\n\n   return ANDgateLogic\n\n\n@block\ndef ORgate( a, b,  q ):\n      \n   @always_comb  \n   def ORgateLogic():\n      q.next = a or b\n\n   return ORgateLogic\n\n\n\n\n@block\ndef XORgate( a, b,  q ):\n      \n   \n   nota, notb, annotb, bnnota = [Signal(bool(0)) for i in range(4)]\n   \n   inv0 = NOTgate( a,  nota )\n   inv1 = NOTgate( b,  notb )\n   and2a = ANDgate( a, notb,  annotb )\n   and2b = ANDgate( b, nota,  bnnota )\n   or2a = ORgate( annotb, bnnota,  q )\n\n   return inv0, inv1, and2a, and2b, or2a\n\n\n@block\ndef HalfAdder( in_a, in_b,  summ, carry ):\n    \n   and2a =  ANDgate(in_a, in_b,  carry)\n   xor2a =  XORgate(in_a, in_b,  summ)\n\n   return and2a, xor2a\n\n\n@block\ndef FullAdder( fa_c0, fa_a, fa_b,  fa_s, fa_c1 ):\n   \n\n   ha1_s, ha1_c1, ha2_c1 = [Signal(bool(0)) for i in range(3)]\n\n   HalfAdder01 = HalfAdder( fa_c0, fa_a,  ha1_s, ha1_c1 )\n   HalfAdder02 = HalfAdder( ha1_s, fa_b,  fa_s,  ha2_c1 )\n   or2a = ORgate(ha1_c1, ha2_c1,  fa_c1)\n\n   return HalfAdder01, HalfAdder02, or2a\n\n\n@block\ndef Adder4b( ina, inb,  cOut, sum4):\n    \n\n   cl = [Signal(bool()) for i in range(0,4)]  \n   sl = [Signal(bool()) for i in range(4)]  \n\n   HalfAdder0 = HalfAdder(        ina(0), inb(0),  sl[0], cl[1] )\n   FullAdder1 = FullAdder( cl[1], ina(1), inb(1),  sl[1], cl[2] ) \n   FullAdder2 = FullAdder( cl[2], ina(2), inb(2),  sl[2], cl[3] ) \n   FullAdder3 = FullAdder( cl[3], ina(3), inb(3),  sl[3], cOut ) \n\n   sc = ConcatSignal(*reversed(sl))  \n\n   @always_comb\n   def list2intbv():\n      sum4.next = sc  \n\n   return HalfAdder0, FullAdder1, FullAdder2, FullAdder3, list2intbv\n\n\n\nt_co, t_s, t_a, t_b, dbug =  [Signal(bool(0)) for i in range(5)]\nina4, inb4, sum4 =  [Signal(intbv(0)[4:])  for i in range(3)]\n\nfrom random import randrange \n\n@block\ndef Test_Adder4b():\n   \n   dut = Adder4b( ina4, inb4,  t_co, sum4 )\n\n   @instance\n   def check():\n      print( \"\\n      b   a   |  c1    s   \\n     -------------------\" )\n      for i in range(15):\n         ina4.next, inb4.next = randrange(2**4), randrange(2**4)\n         yield delay(5)\n         print( \"     %2d  %2d   |  %2d   %2d     \" \\\n                % (ina4,inb4, t_co,sum4) )\n         assert t_co * 16 + sum4 == ina4 + inb4  \n      print()\n\n   return dut, check\n\n\n\n\ndef main():\n   simInst = Test_Adder4b()\n   simInst.name = \"mySimInst\"\n   simInst.config_sim(trace=True)  \n   simInst.run_sim(duration=None)\n\n   inst = Adder4b( ina4, inb4,  t_co, sum4 )  \n   inst.convert(hdl='VHDL')  \n   inst.convert(hdl='Verilog')  \n\n    \nif __name__ == '__main__':\n   main()\n"}
{"id": 116162, "name": "Four bit adder", "source": "Translate Fortran to Python: module logic\n  implicit none\n\ncontains\n\nfunction xor(a, b)\n  logical :: xor\n  logical, intent(in) :: a, b\n\n  xor = (a .and. .not. b) .or. (b .and. .not. a)\nend function xor\n\nfunction halfadder(a, b, c)\n  logical :: halfadder\n  logical, intent(in)  :: a, b\n  logical, intent(out) :: c\n\n  halfadder = xor(a, b)\n  c = a .and. b\nend function halfadder\n\nfunction fulladder(a, b, c0, c1)\n  logical :: fulladder\n  logical, intent(in)  :: a, b, c0\n  logical, intent(out) :: c1\n  logical :: c2, c3\n\n  fulladder = halfadder(halfadder(c0, a, c2), b, c3)\n  c1 = c2 .or. c3\nend function fulladder\n\nsubroutine fourbitadder(a, b, s)\n  logical, intent(in)  :: a(0:3), b(0:3)\n  logical, intent(out) :: s(0:4)\n  logical :: c0, c1, c2\n\n  s(0) = fulladder(a(0), b(0), .false., c0)  \n  s(1) = fulladder(a(1), b(1), c0, c1)\n  s(2) = fulladder(a(2), b(2), c1, c2)\n  s(3) = fulladder(a(3), b(3), c2, s(4))\nend subroutine fourbitadder\nend module\n\nprogram Four_bit_adder\n  use logic\n  implicit none\n  \n  logical, dimension(0:3) :: a, b\n  logical, dimension(0:4) :: s\n  integer, dimension(0:3) :: ai, bi\n  integer, dimension(0:4) :: si\n  integer :: i, j\n\n  do i = 0, 15\n    a(0) = btest(i, 0); a(1) = btest(i, 1); a(2) = btest(i, 2); a(3) = btest(i, 3)\n    where(a)\n      ai = 1\n    else where\n      ai = 0\n    end where\n    do j = 0, 15\n      b(0) = btest(j, 0); b(1) = btest(j, 1); b(2) = btest(j, 2); b(3) = btest(j, 3)\n      where(b)\n        bi = 1\n      else where\n        bi = 0\n      end where\n      call fourbitadder(a, b, s)\n      where (s)\n        si = 1\n      elsewhere\n        si = 0\n      end where\n      write(*, \"(4i1,a,4i1,a,5i1)\") ai(3:0:-1), \" + \", bi(3:0:-1), \" = \", si(4:0:-1)\n    end do\n  end do  \nend program\n", "target": "\n\nfrom myhdl import *\n\n\n\n@block\ndef NOTgate( a,  q ):   \n   \n   @always_comb   \n   def NOTgateLogic():\n      q.next = not a\n\n   return NOTgateLogic   \n\n\n@block\ndef ANDgate( a, b,  q ):\n   \n   @always_comb \n   def ANDgateLogic():\n      q.next = a and b\n\n   return ANDgateLogic\n\n\n@block\ndef ORgate( a, b,  q ):\n      \n   @always_comb  \n   def ORgateLogic():\n      q.next = a or b\n\n   return ORgateLogic\n\n\n\n\n@block\ndef XORgate( a, b,  q ):\n      \n   \n   nota, notb, annotb, bnnota = [Signal(bool(0)) for i in range(4)]\n   \n   inv0 = NOTgate( a,  nota )\n   inv1 = NOTgate( b,  notb )\n   and2a = ANDgate( a, notb,  annotb )\n   and2b = ANDgate( b, nota,  bnnota )\n   or2a = ORgate( annotb, bnnota,  q )\n\n   return inv0, inv1, and2a, and2b, or2a\n\n\n@block\ndef HalfAdder( in_a, in_b,  summ, carry ):\n    \n   and2a =  ANDgate(in_a, in_b,  carry)\n   xor2a =  XORgate(in_a, in_b,  summ)\n\n   return and2a, xor2a\n\n\n@block\ndef FullAdder( fa_c0, fa_a, fa_b,  fa_s, fa_c1 ):\n   \n\n   ha1_s, ha1_c1, ha2_c1 = [Signal(bool(0)) for i in range(3)]\n\n   HalfAdder01 = HalfAdder( fa_c0, fa_a,  ha1_s, ha1_c1 )\n   HalfAdder02 = HalfAdder( ha1_s, fa_b,  fa_s,  ha2_c1 )\n   or2a = ORgate(ha1_c1, ha2_c1,  fa_c1)\n\n   return HalfAdder01, HalfAdder02, or2a\n\n\n@block\ndef Adder4b( ina, inb,  cOut, sum4):\n    \n\n   cl = [Signal(bool()) for i in range(0,4)]  \n   sl = [Signal(bool()) for i in range(4)]  \n\n   HalfAdder0 = HalfAdder(        ina(0), inb(0),  sl[0], cl[1] )\n   FullAdder1 = FullAdder( cl[1], ina(1), inb(1),  sl[1], cl[2] ) \n   FullAdder2 = FullAdder( cl[2], ina(2), inb(2),  sl[2], cl[3] ) \n   FullAdder3 = FullAdder( cl[3], ina(3), inb(3),  sl[3], cOut ) \n\n   sc = ConcatSignal(*reversed(sl))  \n\n   @always_comb\n   def list2intbv():\n      sum4.next = sc  \n\n   return HalfAdder0, FullAdder1, FullAdder2, FullAdder3, list2intbv\n\n\n\nt_co, t_s, t_a, t_b, dbug =  [Signal(bool(0)) for i in range(5)]\nina4, inb4, sum4 =  [Signal(intbv(0)[4:])  for i in range(3)]\n\nfrom random import randrange \n\n@block\ndef Test_Adder4b():\n   \n   dut = Adder4b( ina4, inb4,  t_co, sum4 )\n\n   @instance\n   def check():\n      print( \"\\n      b   a   |  c1    s   \\n     -------------------\" )\n      for i in range(15):\n         ina4.next, inb4.next = randrange(2**4), randrange(2**4)\n         yield delay(5)\n         print( \"     %2d  %2d   |  %2d   %2d     \" \\\n                % (ina4,inb4, t_co,sum4) )\n         assert t_co * 16 + sum4 == ina4 + inb4  \n      print()\n\n   return dut, check\n\n\n\n\ndef main():\n   simInst = Test_Adder4b()\n   simInst.name = \"mySimInst\"\n   simInst.config_sim(trace=True)  \n   simInst.run_sim(duration=None)\n\n   inst = Adder4b( ina4, inb4,  t_co, sum4 )  \n   inst.convert(hdl='VHDL')  \n   inst.convert(hdl='Verilog')  \n\n    \nif __name__ == '__main__':\n   main()\n"}
{"id": 116471, "name": "Longest common subsequence", "source": "Translate Fortran to C#: program lcstest\n  use iso_varying_string\n  implicit none\n\n  type(varying_string) :: s1, s2\n\n  s1 = \"thisisatest\"\n  s2 = \"testing123testing\"\n  print *, char(lcs(s1, s2))\n\n  s1 = \"1234\"\n  s2 = \"1224533324\"\n  print *, char(lcs(s1, s2))\n\ncontains\n\n  recursive function lcs(a, b) result(l)\n    type(varying_string) :: l\n    type(varying_string), intent(in) :: a, b\n\n    type(varying_string) :: x, y\n\n    l = \"\"\n    if ( (len(a) == 0) .or. (len(b) == 0) ) return\n    if ( extract(a, len(a), len(a)) == extract(b, len(b), len(b)) ) then\n       l = lcs(extract(a, 1, len(a)-1), extract(b, 1, len(b)-1)) // extract(a, len(a), len(a))\n    else\n       x = lcs(a, extract(b, 1, len(b)-1))\n       y = lcs(extract(a, 1, len(a)-1), b)\n       if ( len(x) > len(y) ) then\n          l = x\n       else\n          l = y\n       end if\n    end if\n  end function lcs\n\nend program lcstest\n", "target": "using System;\n\nnamespace LCS\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            string word1 = \"thisisatest\";\n            string word2 = \"testing123testing\";\n            \n            Console.WriteLine(lcsBack(word1, word2));\n            Console.ReadKey();\n        }\n\n        public static string lcsBack(string a, string b)\n        {\n            string aSub = a.Substring(0, (a.Length - 1 < 0) ? 0 : a.Length - 1);\n            string bSub = b.Substring(0, (b.Length - 1 < 0) ? 0 : b.Length - 1);\n            \n            if (a.Length == 0 || b.Length == 0)            \n                return \"\";\n            else if (a[a.Length - 1] == b[b.Length - 1])\n                return lcsBack(aSub, bSub) + a[a.Length - 1];\n            else\n            {\n                string x = lcsBack(a, bSub);\n                string y = lcsBack(aSub, b);\n                return (x.Length > y.Length) ? x : y;\n            }\n        }\n    }\n}\n"}
{"id": 116472, "name": "Longest common subsequence", "source": "Translate Fortran to C#: program lcstest\n  use iso_varying_string\n  implicit none\n\n  type(varying_string) :: s1, s2\n\n  s1 = \"thisisatest\"\n  s2 = \"testing123testing\"\n  print *, char(lcs(s1, s2))\n\n  s1 = \"1234\"\n  s2 = \"1224533324\"\n  print *, char(lcs(s1, s2))\n\ncontains\n\n  recursive function lcs(a, b) result(l)\n    type(varying_string) :: l\n    type(varying_string), intent(in) :: a, b\n\n    type(varying_string) :: x, y\n\n    l = \"\"\n    if ( (len(a) == 0) .or. (len(b) == 0) ) return\n    if ( extract(a, len(a), len(a)) == extract(b, len(b), len(b)) ) then\n       l = lcs(extract(a, 1, len(a)-1), extract(b, 1, len(b)-1)) // extract(a, len(a), len(a))\n    else\n       x = lcs(a, extract(b, 1, len(b)-1))\n       y = lcs(extract(a, 1, len(a)-1), b)\n       if ( len(x) > len(y) ) then\n          l = x\n       else\n          l = y\n       end if\n    end if\n  end function lcs\n\nend program lcstest\n", "target": "using System;\n\nnamespace LCS\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            string word1 = \"thisisatest\";\n            string word2 = \"testing123testing\";\n            \n            Console.WriteLine(lcsBack(word1, word2));\n            Console.ReadKey();\n        }\n\n        public static string lcsBack(string a, string b)\n        {\n            string aSub = a.Substring(0, (a.Length - 1 < 0) ? 0 : a.Length - 1);\n            string bSub = b.Substring(0, (b.Length - 1 < 0) ? 0 : b.Length - 1);\n            \n            if (a.Length == 0 || b.Length == 0)            \n                return \"\";\n            else if (a[a.Length - 1] == b[b.Length - 1])\n                return lcsBack(aSub, bSub) + a[a.Length - 1];\n            else\n            {\n                string x = lcsBack(a, bSub);\n                string y = lcsBack(aSub, b);\n                return (x.Length > y.Length) ? x : y;\n            }\n        }\n    }\n}\n"}
{"id": 116478, "name": "Longest common subsequence", "source": "Translate Fortran to Java: program lcstest\n  use iso_varying_string\n  implicit none\n\n  type(varying_string) :: s1, s2\n\n  s1 = \"thisisatest\"\n  s2 = \"testing123testing\"\n  print *, char(lcs(s1, s2))\n\n  s1 = \"1234\"\n  s2 = \"1224533324\"\n  print *, char(lcs(s1, s2))\n\ncontains\n\n  recursive function lcs(a, b) result(l)\n    type(varying_string) :: l\n    type(varying_string), intent(in) :: a, b\n\n    type(varying_string) :: x, y\n\n    l = \"\"\n    if ( (len(a) == 0) .or. (len(b) == 0) ) return\n    if ( extract(a, len(a), len(a)) == extract(b, len(b), len(b)) ) then\n       l = lcs(extract(a, 1, len(a)-1), extract(b, 1, len(b)-1)) // extract(a, len(a), len(a))\n    else\n       x = lcs(a, extract(b, 1, len(b)-1))\n       y = lcs(extract(a, 1, len(a)-1), b)\n       if ( len(x) > len(y) ) then\n          l = x\n       else\n          l = y\n       end if\n    end if\n  end function lcs\n\nend program lcstest\n", "target": "public static String lcs(String a, String b){\n    int aLen = a.length();\n    int bLen = b.length();\n    if(aLen == 0 || bLen == 0){\n        return \"\";\n    }else if(a.charAt(aLen-1) == b.charAt(bLen-1)){\n        return lcs(a.substring(0,aLen-1),b.substring(0,bLen-1))\n            + a.charAt(aLen-1);\n    }else{\n        String x = lcs(a, b.substring(0,bLen-1));\n        String y = lcs(a.substring(0,aLen-1), b);\n        return (x.length() > y.length()) ? x : y;\n    }\n}\n"}
{"id": 116479, "name": "Longest common subsequence", "source": "Translate Fortran to Java: program lcstest\n  use iso_varying_string\n  implicit none\n\n  type(varying_string) :: s1, s2\n\n  s1 = \"thisisatest\"\n  s2 = \"testing123testing\"\n  print *, char(lcs(s1, s2))\n\n  s1 = \"1234\"\n  s2 = \"1224533324\"\n  print *, char(lcs(s1, s2))\n\ncontains\n\n  recursive function lcs(a, b) result(l)\n    type(varying_string) :: l\n    type(varying_string), intent(in) :: a, b\n\n    type(varying_string) :: x, y\n\n    l = \"\"\n    if ( (len(a) == 0) .or. (len(b) == 0) ) return\n    if ( extract(a, len(a), len(a)) == extract(b, len(b), len(b)) ) then\n       l = lcs(extract(a, 1, len(a)-1), extract(b, 1, len(b)-1)) // extract(a, len(a), len(a))\n    else\n       x = lcs(a, extract(b, 1, len(b)-1))\n       y = lcs(extract(a, 1, len(a)-1), b)\n       if ( len(x) > len(y) ) then\n          l = x\n       else\n          l = y\n       end if\n    end if\n  end function lcs\n\nend program lcstest\n", "target": "public static String lcs(String a, String b){\n    int aLen = a.length();\n    int bLen = b.length();\n    if(aLen == 0 || bLen == 0){\n        return \"\";\n    }else if(a.charAt(aLen-1) == b.charAt(bLen-1)){\n        return lcs(a.substring(0,aLen-1),b.substring(0,bLen-1))\n            + a.charAt(aLen-1);\n    }else{\n        String x = lcs(a, b.substring(0,bLen-1));\n        String y = lcs(a.substring(0,aLen-1), b);\n        return (x.length() > y.length()) ? x : y;\n    }\n}\n"}
{"id": 116480, "name": "Longest common subsequence", "source": "Translate Fortran to Python: program lcstest\n  use iso_varying_string\n  implicit none\n\n  type(varying_string) :: s1, s2\n\n  s1 = \"thisisatest\"\n  s2 = \"testing123testing\"\n  print *, char(lcs(s1, s2))\n\n  s1 = \"1234\"\n  s2 = \"1224533324\"\n  print *, char(lcs(s1, s2))\n\ncontains\n\n  recursive function lcs(a, b) result(l)\n    type(varying_string) :: l\n    type(varying_string), intent(in) :: a, b\n\n    type(varying_string) :: x, y\n\n    l = \"\"\n    if ( (len(a) == 0) .or. (len(b) == 0) ) return\n    if ( extract(a, len(a), len(a)) == extract(b, len(b), len(b)) ) then\n       l = lcs(extract(a, 1, len(a)-1), extract(b, 1, len(b)-1)) // extract(a, len(a), len(a))\n    else\n       x = lcs(a, extract(b, 1, len(b)-1))\n       y = lcs(extract(a, 1, len(a)-1), b)\n       if ( len(x) > len(y) ) then\n          l = x\n       else\n          l = y\n       end if\n    end if\n  end function lcs\n\nend program lcstest\n", "target": "def lcs(xstr, ystr):\n    \n    if not xstr or not ystr:\n        return \"\"\n    x, xs, y, ys = xstr[0], xstr[1:], ystr[0], ystr[1:]\n    if x == y:\n        return str(lcs(xs, ys)) + x\n    else:\n        return max(lcs(xstr, ys), lcs(xs, ystr), key=len)\n"}
{"id": 116481, "name": "Longest common subsequence", "source": "Translate Fortran to Python: program lcstest\n  use iso_varying_string\n  implicit none\n\n  type(varying_string) :: s1, s2\n\n  s1 = \"thisisatest\"\n  s2 = \"testing123testing\"\n  print *, char(lcs(s1, s2))\n\n  s1 = \"1234\"\n  s2 = \"1224533324\"\n  print *, char(lcs(s1, s2))\n\ncontains\n\n  recursive function lcs(a, b) result(l)\n    type(varying_string) :: l\n    type(varying_string), intent(in) :: a, b\n\n    type(varying_string) :: x, y\n\n    l = \"\"\n    if ( (len(a) == 0) .or. (len(b) == 0) ) return\n    if ( extract(a, len(a), len(a)) == extract(b, len(b), len(b)) ) then\n       l = lcs(extract(a, 1, len(a)-1), extract(b, 1, len(b)-1)) // extract(a, len(a), len(a))\n    else\n       x = lcs(a, extract(b, 1, len(b)-1))\n       y = lcs(extract(a, 1, len(a)-1), b)\n       if ( len(x) > len(y) ) then\n          l = x\n       else\n          l = y\n       end if\n    end if\n  end function lcs\n\nend program lcstest\n", "target": "def lcs(xstr, ystr):\n    \n    if not xstr or not ystr:\n        return \"\"\n    x, xs, y, ys = xstr[0], xstr[1:], ystr[0], ystr[1:]\n    if x == y:\n        return str(lcs(xs, ys)) + x\n    else:\n        return max(lcs(xstr, ys), lcs(xs, ystr), key=len)\n"}
{"id": 116889, "name": "ABC problem", "source": "Translate Fortran to C#: \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nprogram abc\n  implicit none\n  integer, parameter :: nblocks = 20\n  character(len=nblocks) :: goal\n  integer, dimension(nblocks) :: solution\n  character(len=2), dimension(0:nblocks) :: blocks_copy, blocks = &\n       &(/'--','BO','XK','DQ','CP','NA','GT','RE','TG','QD','FS','JW','HU','VI','AN','OB','ER','FS','LY','PC','ZM'/)\n  logical :: valid\n  integer :: i, iostat\n  read(5,*,iostat=iostat) goal\n  if (iostat .ne. 0) goal = ''\n  call ucase(goal)\n  solution = 0\n  blocks_copy = blocks\n  valid = assign_block(goal(1:len_trim(goal)), blocks, solution, 1)\n  write(6,*) valid, ' '//goal, (' '//blocks_copy(solution(i)), i=1,len_trim(goal))\n\ncontains\n\n  recursive function assign_block(goal, blocks, solution, n) result(valid)\n    implicit none\n    logical :: valid\n    character(len=*), intent(in) :: goal\n    character(len=2), dimension(0:), intent(inout) :: blocks\n    integer, dimension(:), intent(out) :: solution\n    integer, intent(in) :: n\n    integer :: i\n    character(len=2) :: backing_store\n    valid = .true.\n    if (len(goal)+1 .eq. n) return\n    do i=1, size(blocks)\n       if (index(blocks(i),goal(n:n)) .ne. 0) then\n          backing_store = blocks(i)\n          blocks(i) = ''\n          solution(n) = i\n          if (assign_block(goal, blocks, solution, n+1)) return\n          blocks(i) = backing_store\n       end if\n    end do\n    valid = .false.\n    return\n  end function assign_block\n\n  subroutine ucase(a)\n    implicit none\n    character(len=*), intent(inout) :: a\n    integer :: i, j\n    do i = 1, len_trim(a)\n       j = index('abcdefghijklmnopqrstuvwxyz',a(i:i))\n       if (j .ne. 0) a(i:i) = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'(j:j)\n    end do\n  end subroutine ucase\n\nend program abc\n", "target": "using System;\nusing System.IO;\n\nusing System.Text.RegularExpressions;\nusing System.Collections.Generic;\n\nvoid Main()\n{\n   string blocks = \"BO XK DQ CP NA GT RE TG QD FS JW HU VI AN OB ER FS LY PC ZM\";\n   List<string> words = new List<string>() {\n      \"A\", \"BARK\", \"BOOK\", \"TREAT\", \"COMMON\", \"SQUAD\", \"CONFUSE\"\n   };\n\n   foreach(var word in words)\n   {\n      Console.WriteLine(\"{0}: {1}\", word, CheckWord(blocks, word));\n   }\n}\n\nbool CheckWord(string blocks, string word)\n{\n   for(int i = 0; i < word.Length; ++i)\n   {\n      int length = blocks.Length;\n      Regex rgx = new Regex(\"([a-z]\"+word[i]+\"|\"+word[i]+\"[a-z])\", RegexOptions.IgnoreCase);\n      blocks = rgx.Replace(blocks, \"\", 1);\n      if(blocks.Length == length) return false;\n   }\n   return true;\n}\n"}
{"id": 116890, "name": "ABC problem", "source": "Translate Fortran to C#: \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nprogram abc\n  implicit none\n  integer, parameter :: nblocks = 20\n  character(len=nblocks) :: goal\n  integer, dimension(nblocks) :: solution\n  character(len=2), dimension(0:nblocks) :: blocks_copy, blocks = &\n       &(/'--','BO','XK','DQ','CP','NA','GT','RE','TG','QD','FS','JW','HU','VI','AN','OB','ER','FS','LY','PC','ZM'/)\n  logical :: valid\n  integer :: i, iostat\n  read(5,*,iostat=iostat) goal\n  if (iostat .ne. 0) goal = ''\n  call ucase(goal)\n  solution = 0\n  blocks_copy = blocks\n  valid = assign_block(goal(1:len_trim(goal)), blocks, solution, 1)\n  write(6,*) valid, ' '//goal, (' '//blocks_copy(solution(i)), i=1,len_trim(goal))\n\ncontains\n\n  recursive function assign_block(goal, blocks, solution, n) result(valid)\n    implicit none\n    logical :: valid\n    character(len=*), intent(in) :: goal\n    character(len=2), dimension(0:), intent(inout) :: blocks\n    integer, dimension(:), intent(out) :: solution\n    integer, intent(in) :: n\n    integer :: i\n    character(len=2) :: backing_store\n    valid = .true.\n    if (len(goal)+1 .eq. n) return\n    do i=1, size(blocks)\n       if (index(blocks(i),goal(n:n)) .ne. 0) then\n          backing_store = blocks(i)\n          blocks(i) = ''\n          solution(n) = i\n          if (assign_block(goal, blocks, solution, n+1)) return\n          blocks(i) = backing_store\n       end if\n    end do\n    valid = .false.\n    return\n  end function assign_block\n\n  subroutine ucase(a)\n    implicit none\n    character(len=*), intent(inout) :: a\n    integer :: i, j\n    do i = 1, len_trim(a)\n       j = index('abcdefghijklmnopqrstuvwxyz',a(i:i))\n       if (j .ne. 0) a(i:i) = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'(j:j)\n    end do\n  end subroutine ucase\n\nend program abc\n", "target": "using System;\nusing System.IO;\n\nusing System.Text.RegularExpressions;\nusing System.Collections.Generic;\n\nvoid Main()\n{\n   string blocks = \"BO XK DQ CP NA GT RE TG QD FS JW HU VI AN OB ER FS LY PC ZM\";\n   List<string> words = new List<string>() {\n      \"A\", \"BARK\", \"BOOK\", \"TREAT\", \"COMMON\", \"SQUAD\", \"CONFUSE\"\n   };\n\n   foreach(var word in words)\n   {\n      Console.WriteLine(\"{0}: {1}\", word, CheckWord(blocks, word));\n   }\n}\n\nbool CheckWord(string blocks, string word)\n{\n   for(int i = 0; i < word.Length; ++i)\n   {\n      int length = blocks.Length;\n      Regex rgx = new Regex(\"([a-z]\"+word[i]+\"|\"+word[i]+\"[a-z])\", RegexOptions.IgnoreCase);\n      blocks = rgx.Replace(blocks, \"\", 1);\n      if(blocks.Length == length) return false;\n   }\n   return true;\n}\n"}
{"id": 116895, "name": "ABC problem", "source": "Translate Fortran to Java: \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nprogram abc\n  implicit none\n  integer, parameter :: nblocks = 20\n  character(len=nblocks) :: goal\n  integer, dimension(nblocks) :: solution\n  character(len=2), dimension(0:nblocks) :: blocks_copy, blocks = &\n       &(/'--','BO','XK','DQ','CP','NA','GT','RE','TG','QD','FS','JW','HU','VI','AN','OB','ER','FS','LY','PC','ZM'/)\n  logical :: valid\n  integer :: i, iostat\n  read(5,*,iostat=iostat) goal\n  if (iostat .ne. 0) goal = ''\n  call ucase(goal)\n  solution = 0\n  blocks_copy = blocks\n  valid = assign_block(goal(1:len_trim(goal)), blocks, solution, 1)\n  write(6,*) valid, ' '//goal, (' '//blocks_copy(solution(i)), i=1,len_trim(goal))\n\ncontains\n\n  recursive function assign_block(goal, blocks, solution, n) result(valid)\n    implicit none\n    logical :: valid\n    character(len=*), intent(in) :: goal\n    character(len=2), dimension(0:), intent(inout) :: blocks\n    integer, dimension(:), intent(out) :: solution\n    integer, intent(in) :: n\n    integer :: i\n    character(len=2) :: backing_store\n    valid = .true.\n    if (len(goal)+1 .eq. n) return\n    do i=1, size(blocks)\n       if (index(blocks(i),goal(n:n)) .ne. 0) then\n          backing_store = blocks(i)\n          blocks(i) = ''\n          solution(n) = i\n          if (assign_block(goal, blocks, solution, n+1)) return\n          blocks(i) = backing_store\n       end if\n    end do\n    valid = .false.\n    return\n  end function assign_block\n\n  subroutine ucase(a)\n    implicit none\n    character(len=*), intent(inout) :: a\n    integer :: i, j\n    do i = 1, len_trim(a)\n       j = index('abcdefghijklmnopqrstuvwxyz',a(i:i))\n       if (j .ne. 0) a(i:i) = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'(j:j)\n    end do\n  end subroutine ucase\n\nend program abc\n", "target": "static Boolean canMakeWord(List<String> src_blocks, String word) {\n    if (String.isEmpty(word)) {\n        return true;\n    }\n\n    List<String> blocks = new List<String>();\n    for (String block : src_blocks) {\n        blocks.add(block.toUpperCase());\n    }\n    \n    for (Integer i = 0; i < word.length(); i++) {\n        Integer blockIndex = -1;\n        String c = word.mid(i, 1).toUpperCase();\n        \n        for (Integer j = 0; j < blocks.size(); j++) {\n            if (blocks.get(j).contains(c)) {\n                blockIndex = j;\n                break;\n            }\n        }\n        \n        if (blockIndex == -1) {\n            return false;\n        } else {\n            blocks.remove(blockIndex);\n        }\n    }\n        \n    return true;\n}\n\nList<String> blocks = new List<String>{\n    'BO', 'XK', 'DQ', 'CP', 'NA',\n    'GT', 'RE', 'TG', 'QD', 'FS', \n    'JW', 'HU', 'VI', 'AN', 'OB', \n    'ER', 'FS', 'LY', 'PC', 'ZM'\n};\nSystem.debug('\"\": ' + canMakeWord(blocks, ''));\nSystem.debug('\"A\": ' + canMakeWord(blocks, 'A'));\nSystem.debug('\"BARK\": ' + canMakeWord(blocks, 'BARK'));\nSystem.debug('\"book\": ' + canMakeWord(blocks, 'book'));\nSystem.debug('\"treat\": ' + canMakeWord(blocks, 'treat'));\nSystem.debug('\"COMMON\": ' + canMakeWord(blocks, 'COMMON'));\nSystem.debug('\"SQuAd\": ' + canMakeWord(blocks, 'SQuAd'));\nSystem.debug('\"CONFUSE\": ' + canMakeWord(blocks, 'CONFUSE'));\n"}
{"id": 116896, "name": "ABC problem", "source": "Translate Fortran to Java: \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nprogram abc\n  implicit none\n  integer, parameter :: nblocks = 20\n  character(len=nblocks) :: goal\n  integer, dimension(nblocks) :: solution\n  character(len=2), dimension(0:nblocks) :: blocks_copy, blocks = &\n       &(/'--','BO','XK','DQ','CP','NA','GT','RE','TG','QD','FS','JW','HU','VI','AN','OB','ER','FS','LY','PC','ZM'/)\n  logical :: valid\n  integer :: i, iostat\n  read(5,*,iostat=iostat) goal\n  if (iostat .ne. 0) goal = ''\n  call ucase(goal)\n  solution = 0\n  blocks_copy = blocks\n  valid = assign_block(goal(1:len_trim(goal)), blocks, solution, 1)\n  write(6,*) valid, ' '//goal, (' '//blocks_copy(solution(i)), i=1,len_trim(goal))\n\ncontains\n\n  recursive function assign_block(goal, blocks, solution, n) result(valid)\n    implicit none\n    logical :: valid\n    character(len=*), intent(in) :: goal\n    character(len=2), dimension(0:), intent(inout) :: blocks\n    integer, dimension(:), intent(out) :: solution\n    integer, intent(in) :: n\n    integer :: i\n    character(len=2) :: backing_store\n    valid = .true.\n    if (len(goal)+1 .eq. n) return\n    do i=1, size(blocks)\n       if (index(blocks(i),goal(n:n)) .ne. 0) then\n          backing_store = blocks(i)\n          blocks(i) = ''\n          solution(n) = i\n          if (assign_block(goal, blocks, solution, n+1)) return\n          blocks(i) = backing_store\n       end if\n    end do\n    valid = .false.\n    return\n  end function assign_block\n\n  subroutine ucase(a)\n    implicit none\n    character(len=*), intent(inout) :: a\n    integer :: i, j\n    do i = 1, len_trim(a)\n       j = index('abcdefghijklmnopqrstuvwxyz',a(i:i))\n       if (j .ne. 0) a(i:i) = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'(j:j)\n    end do\n  end subroutine ucase\n\nend program abc\n", "target": "static Boolean canMakeWord(List<String> src_blocks, String word) {\n    if (String.isEmpty(word)) {\n        return true;\n    }\n\n    List<String> blocks = new List<String>();\n    for (String block : src_blocks) {\n        blocks.add(block.toUpperCase());\n    }\n    \n    for (Integer i = 0; i < word.length(); i++) {\n        Integer blockIndex = -1;\n        String c = word.mid(i, 1).toUpperCase();\n        \n        for (Integer j = 0; j < blocks.size(); j++) {\n            if (blocks.get(j).contains(c)) {\n                blockIndex = j;\n                break;\n            }\n        }\n        \n        if (blockIndex == -1) {\n            return false;\n        } else {\n            blocks.remove(blockIndex);\n        }\n    }\n        \n    return true;\n}\n\nList<String> blocks = new List<String>{\n    'BO', 'XK', 'DQ', 'CP', 'NA',\n    'GT', 'RE', 'TG', 'QD', 'FS', \n    'JW', 'HU', 'VI', 'AN', 'OB', \n    'ER', 'FS', 'LY', 'PC', 'ZM'\n};\nSystem.debug('\"\": ' + canMakeWord(blocks, ''));\nSystem.debug('\"A\": ' + canMakeWord(blocks, 'A'));\nSystem.debug('\"BARK\": ' + canMakeWord(blocks, 'BARK'));\nSystem.debug('\"book\": ' + canMakeWord(blocks, 'book'));\nSystem.debug('\"treat\": ' + canMakeWord(blocks, 'treat'));\nSystem.debug('\"COMMON\": ' + canMakeWord(blocks, 'COMMON'));\nSystem.debug('\"SQuAd\": ' + canMakeWord(blocks, 'SQuAd'));\nSystem.debug('\"CONFUSE\": ' + canMakeWord(blocks, 'CONFUSE'));\n"}
{"id": 116897, "name": "ABC problem", "source": "Translate Fortran to Python: \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nprogram abc\n  implicit none\n  integer, parameter :: nblocks = 20\n  character(len=nblocks) :: goal\n  integer, dimension(nblocks) :: solution\n  character(len=2), dimension(0:nblocks) :: blocks_copy, blocks = &\n       &(/'--','BO','XK','DQ','CP','NA','GT','RE','TG','QD','FS','JW','HU','VI','AN','OB','ER','FS','LY','PC','ZM'/)\n  logical :: valid\n  integer :: i, iostat\n  read(5,*,iostat=iostat) goal\n  if (iostat .ne. 0) goal = ''\n  call ucase(goal)\n  solution = 0\n  blocks_copy = blocks\n  valid = assign_block(goal(1:len_trim(goal)), blocks, solution, 1)\n  write(6,*) valid, ' '//goal, (' '//blocks_copy(solution(i)), i=1,len_trim(goal))\n\ncontains\n\n  recursive function assign_block(goal, blocks, solution, n) result(valid)\n    implicit none\n    logical :: valid\n    character(len=*), intent(in) :: goal\n    character(len=2), dimension(0:), intent(inout) :: blocks\n    integer, dimension(:), intent(out) :: solution\n    integer, intent(in) :: n\n    integer :: i\n    character(len=2) :: backing_store\n    valid = .true.\n    if (len(goal)+1 .eq. n) return\n    do i=1, size(blocks)\n       if (index(blocks(i),goal(n:n)) .ne. 0) then\n          backing_store = blocks(i)\n          blocks(i) = ''\n          solution(n) = i\n          if (assign_block(goal, blocks, solution, n+1)) return\n          blocks(i) = backing_store\n       end if\n    end do\n    valid = .false.\n    return\n  end function assign_block\n\n  subroutine ucase(a)\n    implicit none\n    character(len=*), intent(inout) :: a\n    integer :: i, j\n    do i = 1, len_trim(a)\n       j = index('abcdefghijklmnopqrstuvwxyz',a(i:i))\n       if (j .ne. 0) a(i:i) = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'(j:j)\n    end do\n  end subroutine ucase\n\nend program abc\n", "target": "    >>> can_make_word(\"A\")\n    True\n    >>> can_make_word(\"BARK\")\n    True\n    >>> can_make_word(\"BOOK\")\n    False\n    >>> can_make_word(\"TREAT\")\n    True\n    >>> can_make_word(\"COMMON\")\n    False\n    >>> can_make_word(\"SQUAD\")\n    True\n    >>> can_make_word(\"CONFUSE\")\n    True\n"}
{"id": 116898, "name": "ABC problem", "source": "Translate Fortran to Python: \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nprogram abc\n  implicit none\n  integer, parameter :: nblocks = 20\n  character(len=nblocks) :: goal\n  integer, dimension(nblocks) :: solution\n  character(len=2), dimension(0:nblocks) :: blocks_copy, blocks = &\n       &(/'--','BO','XK','DQ','CP','NA','GT','RE','TG','QD','FS','JW','HU','VI','AN','OB','ER','FS','LY','PC','ZM'/)\n  logical :: valid\n  integer :: i, iostat\n  read(5,*,iostat=iostat) goal\n  if (iostat .ne. 0) goal = ''\n  call ucase(goal)\n  solution = 0\n  blocks_copy = blocks\n  valid = assign_block(goal(1:len_trim(goal)), blocks, solution, 1)\n  write(6,*) valid, ' '//goal, (' '//blocks_copy(solution(i)), i=1,len_trim(goal))\n\ncontains\n\n  recursive function assign_block(goal, blocks, solution, n) result(valid)\n    implicit none\n    logical :: valid\n    character(len=*), intent(in) :: goal\n    character(len=2), dimension(0:), intent(inout) :: blocks\n    integer, dimension(:), intent(out) :: solution\n    integer, intent(in) :: n\n    integer :: i\n    character(len=2) :: backing_store\n    valid = .true.\n    if (len(goal)+1 .eq. n) return\n    do i=1, size(blocks)\n       if (index(blocks(i),goal(n:n)) .ne. 0) then\n          backing_store = blocks(i)\n          blocks(i) = ''\n          solution(n) = i\n          if (assign_block(goal, blocks, solution, n+1)) return\n          blocks(i) = backing_store\n       end if\n    end do\n    valid = .false.\n    return\n  end function assign_block\n\n  subroutine ucase(a)\n    implicit none\n    character(len=*), intent(inout) :: a\n    integer :: i, j\n    do i = 1, len_trim(a)\n       j = index('abcdefghijklmnopqrstuvwxyz',a(i:i))\n       if (j .ne. 0) a(i:i) = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'(j:j)\n    end do\n  end subroutine ucase\n\nend program abc\n", "target": "    >>> can_make_word(\"A\")\n    True\n    >>> can_make_word(\"BARK\")\n    True\n    >>> can_make_word(\"BOOK\")\n    False\n    >>> can_make_word(\"TREAT\")\n    True\n    >>> can_make_word(\"COMMON\")\n    False\n    >>> can_make_word(\"SQUAD\")\n    True\n    >>> can_make_word(\"CONFUSE\")\n    True\n"}
{"id": 117655, "name": "Sum digits of an integer", "source": "Translate Fortran to C#: \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nmodule base_mod\n  private :: reverse\ncontains\n  subroutine reverse(a)\n    integer, dimension(:), intent(inout) :: a\n    integer :: i, j, t\n    do i=1,size(a)/2\n       j = size(a) - i + 1\n       t = a(i)\n       a(i) = a(j)\n       a(j) = t\n    end do\n  end subroutine reverse  \n\n  function antibase(b, n) result(a)\n    integer, intent(in) :: b,n\n    integer, dimension(32) :: a\n    integer :: m, i\n    a = 0\n    m = n\n    i = 1\n    do while (m .ne. 0)\n       a(i) = mod(m, b)\n       m = m/b\n       i = i+1\n    end do\n    call reverse(a)\n  end function antibase\nend module base_mod\n\nprogram digit_sum\n  use base_mod\n  call still\n  call confused\ncontains\n  subroutine still\n    character(len=6),parameter :: fmt = '(i9,a)'\n    print'(a9,a8)','digit sum','n'\n    call process1(fmt,'1',10)\n    call process1(fmt,'1234',10)\n    call process1(fmt,'fe',16)\n    call process1(fmt,'f0e',16)\n  end subroutine still\n\n  subroutine process1(fmt,s,b)\n    character(len=*), intent(in) :: fmt, s\n    integer, intent(in), optional :: b\n    integer :: i\n    print fmt,sum((/(index('123456789abcdef',s(i:i)),i=1,len(s))/)),' '//s\n  end subroutine process1\n\n  subroutine confused\n    character(len=5),parameter :: fmt = '(3i7)'\n    print*,'sum of digits of n expressed in base is...'\n    print'(3a7)','n','base','sum'\n    call process0(10,1,fmt)\n    call process0(10,1234,fmt)\n    call process0(16,254,fmt)\n    call process0(16,3854,fmt)\n  end subroutine confused\n\n  subroutine process0(b,n,fmt)\n    integer, intent(in) :: b, n\n    character(len=*), intent(in) :: fmt\n    print fmt,n,b,sum(antibase(b, n))\n  end subroutine process0\nend program digit_sum\n", "target": "namespace RosettaCode.SumDigitsOfAnInteger\n{\n    using System;\n    using System.Collections.Generic;\n    using System.Linq;\n\n    internal static class Program\n    {\n        \n        \n        \n        \n        \n        \n        \n        \n        \n        private static IEnumerable<int> Digits(this int number, int @base = 10)\n        {\n            while (number != 0)\n            {\n                int digit;\n                number = Math.DivRem(number, @base, out digit);\n                yield return digit;\n            }\n        }\n\n        \n        \n        \n        \n        \n        \n        private static int SumOfDigits(this int number, int @base = 10)\n        {\n            return number.Digits(@base).Sum();\n        }\n\n        \n        \n        \n        private static void Main()\n        {\n            foreach (var example in\n                new[]\n                {\n                    new {Number = 1, Base = 10},\n                    new {Number = 12345, Base = 10},\n                    new {Number = 123045, Base = 10},\n                    new {Number = 0xfe, Base = 0x10},\n                    new {Number = 0xf0e, Base = 0x10}\n                })\n            {\n                Console.WriteLine(example.Number.SumOfDigits(example.Base));\n            }\n        }\n    }\n}\n"}
{"id": 117656, "name": "Sum digits of an integer", "source": "Translate Fortran to C#: \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nmodule base_mod\n  private :: reverse\ncontains\n  subroutine reverse(a)\n    integer, dimension(:), intent(inout) :: a\n    integer :: i, j, t\n    do i=1,size(a)/2\n       j = size(a) - i + 1\n       t = a(i)\n       a(i) = a(j)\n       a(j) = t\n    end do\n  end subroutine reverse  \n\n  function antibase(b, n) result(a)\n    integer, intent(in) :: b,n\n    integer, dimension(32) :: a\n    integer :: m, i\n    a = 0\n    m = n\n    i = 1\n    do while (m .ne. 0)\n       a(i) = mod(m, b)\n       m = m/b\n       i = i+1\n    end do\n    call reverse(a)\n  end function antibase\nend module base_mod\n\nprogram digit_sum\n  use base_mod\n  call still\n  call confused\ncontains\n  subroutine still\n    character(len=6),parameter :: fmt = '(i9,a)'\n    print'(a9,a8)','digit sum','n'\n    call process1(fmt,'1',10)\n    call process1(fmt,'1234',10)\n    call process1(fmt,'fe',16)\n    call process1(fmt,'f0e',16)\n  end subroutine still\n\n  subroutine process1(fmt,s,b)\n    character(len=*), intent(in) :: fmt, s\n    integer, intent(in), optional :: b\n    integer :: i\n    print fmt,sum((/(index('123456789abcdef',s(i:i)),i=1,len(s))/)),' '//s\n  end subroutine process1\n\n  subroutine confused\n    character(len=5),parameter :: fmt = '(3i7)'\n    print*,'sum of digits of n expressed in base is...'\n    print'(3a7)','n','base','sum'\n    call process0(10,1,fmt)\n    call process0(10,1234,fmt)\n    call process0(16,254,fmt)\n    call process0(16,3854,fmt)\n  end subroutine confused\n\n  subroutine process0(b,n,fmt)\n    integer, intent(in) :: b, n\n    character(len=*), intent(in) :: fmt\n    print fmt,n,b,sum(antibase(b, n))\n  end subroutine process0\nend program digit_sum\n", "target": "namespace RosettaCode.SumDigitsOfAnInteger\n{\n    using System;\n    using System.Collections.Generic;\n    using System.Linq;\n\n    internal static class Program\n    {\n        \n        \n        \n        \n        \n        \n        \n        \n        \n        private static IEnumerable<int> Digits(this int number, int @base = 10)\n        {\n            while (number != 0)\n            {\n                int digit;\n                number = Math.DivRem(number, @base, out digit);\n                yield return digit;\n            }\n        }\n\n        \n        \n        \n        \n        \n        \n        private static int SumOfDigits(this int number, int @base = 10)\n        {\n            return number.Digits(@base).Sum();\n        }\n\n        \n        \n        \n        private static void Main()\n        {\n            foreach (var example in\n                new[]\n                {\n                    new {Number = 1, Base = 10},\n                    new {Number = 12345, Base = 10},\n                    new {Number = 123045, Base = 10},\n                    new {Number = 0xfe, Base = 0x10},\n                    new {Number = 0xf0e, Base = 0x10}\n                })\n            {\n                Console.WriteLine(example.Number.SumOfDigits(example.Base));\n            }\n        }\n    }\n}\n"}
{"id": 117661, "name": "Sum digits of an integer", "source": "Translate Fortran to Java: \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nmodule base_mod\n  private :: reverse\ncontains\n  subroutine reverse(a)\n    integer, dimension(:), intent(inout) :: a\n    integer :: i, j, t\n    do i=1,size(a)/2\n       j = size(a) - i + 1\n       t = a(i)\n       a(i) = a(j)\n       a(j) = t\n    end do\n  end subroutine reverse  \n\n  function antibase(b, n) result(a)\n    integer, intent(in) :: b,n\n    integer, dimension(32) :: a\n    integer :: m, i\n    a = 0\n    m = n\n    i = 1\n    do while (m .ne. 0)\n       a(i) = mod(m, b)\n       m = m/b\n       i = i+1\n    end do\n    call reverse(a)\n  end function antibase\nend module base_mod\n\nprogram digit_sum\n  use base_mod\n  call still\n  call confused\ncontains\n  subroutine still\n    character(len=6),parameter :: fmt = '(i9,a)'\n    print'(a9,a8)','digit sum','n'\n    call process1(fmt,'1',10)\n    call process1(fmt,'1234',10)\n    call process1(fmt,'fe',16)\n    call process1(fmt,'f0e',16)\n  end subroutine still\n\n  subroutine process1(fmt,s,b)\n    character(len=*), intent(in) :: fmt, s\n    integer, intent(in), optional :: b\n    integer :: i\n    print fmt,sum((/(index('123456789abcdef',s(i:i)),i=1,len(s))/)),' '//s\n  end subroutine process1\n\n  subroutine confused\n    character(len=5),parameter :: fmt = '(3i7)'\n    print*,'sum of digits of n expressed in base is...'\n    print'(3a7)','n','base','sum'\n    call process0(10,1,fmt)\n    call process0(10,1234,fmt)\n    call process0(16,254,fmt)\n    call process0(16,3854,fmt)\n  end subroutine confused\n\n  subroutine process0(b,n,fmt)\n    integer, intent(in) :: b, n\n    character(len=*), intent(in) :: fmt\n    print fmt,n,b,sum(antibase(b, n))\n  end subroutine process0\nend program digit_sum\n", "target": "import java.math.BigInteger;\npublic class SumDigits {\n    public static int sumDigits(long num) {\n\treturn sumDigits(num, 10);\n    }\n    public static int sumDigits(long num, int base) {\n\tString s = Long.toString(num, base);\n\tint result = 0;\n\tfor (int i = 0; i < s.length(); i++)\n\t    result += Character.digit(s.charAt(i), base);\n\treturn result;\n    }\n    public static int sumDigits(BigInteger num) {\n\treturn sumDigits(num, 10);\n    }\n    public static int sumDigits(BigInteger num, int base) {\n\tString s = num.toString(base);\n\tint result = 0;\n\tfor (int i = 0; i < s.length(); i++)\n\t    result += Character.digit(s.charAt(i), base);\n\treturn result;\n    }\n\n    public static void main(String[] args) {\n\tSystem.out.println(sumDigits(1));\n\tSystem.out.println(sumDigits(12345));\n\tSystem.out.println(sumDigits(123045));\n\tSystem.out.println(sumDigits(0xfe, 16));\n\tSystem.out.println(sumDigits(0xf0e, 16));\n\tSystem.out.println(sumDigits(new BigInteger(\"12345678901234567890\")));\n    }\n}\n"}
{"id": 117662, "name": "Sum digits of an integer", "source": "Translate Fortran to Java: \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nmodule base_mod\n  private :: reverse\ncontains\n  subroutine reverse(a)\n    integer, dimension(:), intent(inout) :: a\n    integer :: i, j, t\n    do i=1,size(a)/2\n       j = size(a) - i + 1\n       t = a(i)\n       a(i) = a(j)\n       a(j) = t\n    end do\n  end subroutine reverse  \n\n  function antibase(b, n) result(a)\n    integer, intent(in) :: b,n\n    integer, dimension(32) :: a\n    integer :: m, i\n    a = 0\n    m = n\n    i = 1\n    do while (m .ne. 0)\n       a(i) = mod(m, b)\n       m = m/b\n       i = i+1\n    end do\n    call reverse(a)\n  end function antibase\nend module base_mod\n\nprogram digit_sum\n  use base_mod\n  call still\n  call confused\ncontains\n  subroutine still\n    character(len=6),parameter :: fmt = '(i9,a)'\n    print'(a9,a8)','digit sum','n'\n    call process1(fmt,'1',10)\n    call process1(fmt,'1234',10)\n    call process1(fmt,'fe',16)\n    call process1(fmt,'f0e',16)\n  end subroutine still\n\n  subroutine process1(fmt,s,b)\n    character(len=*), intent(in) :: fmt, s\n    integer, intent(in), optional :: b\n    integer :: i\n    print fmt,sum((/(index('123456789abcdef',s(i:i)),i=1,len(s))/)),' '//s\n  end subroutine process1\n\n  subroutine confused\n    character(len=5),parameter :: fmt = '(3i7)'\n    print*,'sum of digits of n expressed in base is...'\n    print'(3a7)','n','base','sum'\n    call process0(10,1,fmt)\n    call process0(10,1234,fmt)\n    call process0(16,254,fmt)\n    call process0(16,3854,fmt)\n  end subroutine confused\n\n  subroutine process0(b,n,fmt)\n    integer, intent(in) :: b, n\n    character(len=*), intent(in) :: fmt\n    print fmt,n,b,sum(antibase(b, n))\n  end subroutine process0\nend program digit_sum\n", "target": "import java.math.BigInteger;\npublic class SumDigits {\n    public static int sumDigits(long num) {\n\treturn sumDigits(num, 10);\n    }\n    public static int sumDigits(long num, int base) {\n\tString s = Long.toString(num, base);\n\tint result = 0;\n\tfor (int i = 0; i < s.length(); i++)\n\t    result += Character.digit(s.charAt(i), base);\n\treturn result;\n    }\n    public static int sumDigits(BigInteger num) {\n\treturn sumDigits(num, 10);\n    }\n    public static int sumDigits(BigInteger num, int base) {\n\tString s = num.toString(base);\n\tint result = 0;\n\tfor (int i = 0; i < s.length(); i++)\n\t    result += Character.digit(s.charAt(i), base);\n\treturn result;\n    }\n\n    public static void main(String[] args) {\n\tSystem.out.println(sumDigits(1));\n\tSystem.out.println(sumDigits(12345));\n\tSystem.out.println(sumDigits(123045));\n\tSystem.out.println(sumDigits(0xfe, 16));\n\tSystem.out.println(sumDigits(0xf0e, 16));\n\tSystem.out.println(sumDigits(new BigInteger(\"12345678901234567890\")));\n    }\n}\n"}
{"id": 117663, "name": "Sum digits of an integer", "source": "Translate Fortran to Python: \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nmodule base_mod\n  private :: reverse\ncontains\n  subroutine reverse(a)\n    integer, dimension(:), intent(inout) :: a\n    integer :: i, j, t\n    do i=1,size(a)/2\n       j = size(a) - i + 1\n       t = a(i)\n       a(i) = a(j)\n       a(j) = t\n    end do\n  end subroutine reverse  \n\n  function antibase(b, n) result(a)\n    integer, intent(in) :: b,n\n    integer, dimension(32) :: a\n    integer :: m, i\n    a = 0\n    m = n\n    i = 1\n    do while (m .ne. 0)\n       a(i) = mod(m, b)\n       m = m/b\n       i = i+1\n    end do\n    call reverse(a)\n  end function antibase\nend module base_mod\n\nprogram digit_sum\n  use base_mod\n  call still\n  call confused\ncontains\n  subroutine still\n    character(len=6),parameter :: fmt = '(i9,a)'\n    print'(a9,a8)','digit sum','n'\n    call process1(fmt,'1',10)\n    call process1(fmt,'1234',10)\n    call process1(fmt,'fe',16)\n    call process1(fmt,'f0e',16)\n  end subroutine still\n\n  subroutine process1(fmt,s,b)\n    character(len=*), intent(in) :: fmt, s\n    integer, intent(in), optional :: b\n    integer :: i\n    print fmt,sum((/(index('123456789abcdef',s(i:i)),i=1,len(s))/)),' '//s\n  end subroutine process1\n\n  subroutine confused\n    character(len=5),parameter :: fmt = '(3i7)'\n    print*,'sum of digits of n expressed in base is...'\n    print'(3a7)','n','base','sum'\n    call process0(10,1,fmt)\n    call process0(10,1234,fmt)\n    call process0(16,254,fmt)\n    call process0(16,3854,fmt)\n  end subroutine confused\n\n  subroutine process0(b,n,fmt)\n    integer, intent(in) :: b, n\n    character(len=*), intent(in) :: fmt\n    print fmt,n,b,sum(antibase(b, n))\n  end subroutine process0\nend program digit_sum\n", "target": "\n\n\n\n\n\u0ba8\u0bbf\u0bb0\u0bb2\u0bcd\u0baa\u0bbe\u0b95\u0bae\u0bcd \u0b8e\u0ba3\u0bcd_\u0b95\u0bc2\u0b9f\u0bcd\u0b9f\u0bb2\u0bcd( \u0b8e\u0ba3\u0bcd )\n  \u0ba4\u0bca\u0b95\u0bc8 = 0\n  @( \u0b8e\u0ba3\u0bcd > 0 ) \u0bb5\u0bb0\u0bc8\n     d = \u0b8e\u0ba3\u0bcd%10;\n     \u0baa\u0ba4\u0bbf\u0baa\u0bcd\u0baa\u0bbf \"digit = \",d\n     \u0b8e\u0ba3\u0bcd = (\u0b8e\u0ba3\u0bcd-d)/10;\n     \u0ba4\u0bca\u0b95\u0bc8  = \u0ba4\u0bca\u0b95\u0bc8  + d\n  \u0bae\u0bc1\u0b9f\u0bbf\n  \u0baa\u0bbf\u0ba9\u0bcd\u0b95\u0bca\u0b9f\u0bc1 \u0ba4\u0bca\u0b95\u0bc8 \n\u0bae\u0bc1\u0b9f\u0bbf\n\n\n\u0baa\u0ba4\u0bbf\u0baa\u0bcd\u0baa\u0bbf \u0b8e\u0ba3\u0bcd_\u0b95\u0bc2\u0b9f\u0bcd\u0b9f\u0bb2\u0bcd( 1289)\n\u0baa\u0ba4\u0bbf\u0baa\u0bcd\u0baa\u0bbf \u0b8e\u0ba3\u0bcd_\u0b95\u0bc2\u0b9f\u0bcd\u0b9f\u0bb2\u0bcd( 123456789)\n"}
{"id": 117664, "name": "Sum digits of an integer", "source": "Translate Fortran to Python: \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nmodule base_mod\n  private :: reverse\ncontains\n  subroutine reverse(a)\n    integer, dimension(:), intent(inout) :: a\n    integer :: i, j, t\n    do i=1,size(a)/2\n       j = size(a) - i + 1\n       t = a(i)\n       a(i) = a(j)\n       a(j) = t\n    end do\n  end subroutine reverse  \n\n  function antibase(b, n) result(a)\n    integer, intent(in) :: b,n\n    integer, dimension(32) :: a\n    integer :: m, i\n    a = 0\n    m = n\n    i = 1\n    do while (m .ne. 0)\n       a(i) = mod(m, b)\n       m = m/b\n       i = i+1\n    end do\n    call reverse(a)\n  end function antibase\nend module base_mod\n\nprogram digit_sum\n  use base_mod\n  call still\n  call confused\ncontains\n  subroutine still\n    character(len=6),parameter :: fmt = '(i9,a)'\n    print'(a9,a8)','digit sum','n'\n    call process1(fmt,'1',10)\n    call process1(fmt,'1234',10)\n    call process1(fmt,'fe',16)\n    call process1(fmt,'f0e',16)\n  end subroutine still\n\n  subroutine process1(fmt,s,b)\n    character(len=*), intent(in) :: fmt, s\n    integer, intent(in), optional :: b\n    integer :: i\n    print fmt,sum((/(index('123456789abcdef',s(i:i)),i=1,len(s))/)),' '//s\n  end subroutine process1\n\n  subroutine confused\n    character(len=5),parameter :: fmt = '(3i7)'\n    print*,'sum of digits of n expressed in base is...'\n    print'(3a7)','n','base','sum'\n    call process0(10,1,fmt)\n    call process0(10,1234,fmt)\n    call process0(16,254,fmt)\n    call process0(16,3854,fmt)\n  end subroutine confused\n\n  subroutine process0(b,n,fmt)\n    integer, intent(in) :: b, n\n    character(len=*), intent(in) :: fmt\n    print fmt,n,b,sum(antibase(b, n))\n  end subroutine process0\nend program digit_sum\n", "target": "\n\n\n\n\n\u0ba8\u0bbf\u0bb0\u0bb2\u0bcd\u0baa\u0bbe\u0b95\u0bae\u0bcd \u0b8e\u0ba3\u0bcd_\u0b95\u0bc2\u0b9f\u0bcd\u0b9f\u0bb2\u0bcd( \u0b8e\u0ba3\u0bcd )\n  \u0ba4\u0bca\u0b95\u0bc8 = 0\n  @( \u0b8e\u0ba3\u0bcd > 0 ) \u0bb5\u0bb0\u0bc8\n     d = \u0b8e\u0ba3\u0bcd%10;\n     \u0baa\u0ba4\u0bbf\u0baa\u0bcd\u0baa\u0bbf \"digit = \",d\n     \u0b8e\u0ba3\u0bcd = (\u0b8e\u0ba3\u0bcd-d)/10;\n     \u0ba4\u0bca\u0b95\u0bc8  = \u0ba4\u0bca\u0b95\u0bc8  + d\n  \u0bae\u0bc1\u0b9f\u0bbf\n  \u0baa\u0bbf\u0ba9\u0bcd\u0b95\u0bca\u0b9f\u0bc1 \u0ba4\u0bca\u0b95\u0bc8 \n\u0bae\u0bc1\u0b9f\u0bbf\n\n\n\u0baa\u0ba4\u0bbf\u0baa\u0bcd\u0baa\u0bbf \u0b8e\u0ba3\u0bcd_\u0b95\u0bc2\u0b9f\u0bcd\u0b9f\u0bb2\u0bcd( 1289)\n\u0baa\u0ba4\u0bbf\u0baa\u0bcd\u0baa\u0bbf \u0b8e\u0ba3\u0bcd_\u0b95\u0bc2\u0b9f\u0bcd\u0b9f\u0bb2\u0bcd( 123456789)\n"}
{"id": 118079, "name": "Apply a callback to an array", "source": "Translate Fortran to C#: module arrCallback\ncontains\n    elemental function cube( x )\n        implicit none\n        real :: cube\n        real, intent(in) :: x\n        cube = x * x * x\n    end function cube\nend module arrCallback\n", "target": "int[] intArray = { 1, 2, 3, 4, 5 };\n\nint[] squares1 = intArray.Select(x => x * x).ToArray();\n\n\nint[] squares2 = (from x in intArray\n                  select x * x).ToArray();\n\n\nforeach (var i in intArray)\n    Console.WriteLine(i * i);\n"}
{"id": 118083, "name": "Apply a callback to an array", "source": "Translate Fortran to Java: module arrCallback\ncontains\n    elemental function cube( x )\n        implicit none\n        real :: cube\n        real, intent(in) :: x\n        cube = x * x * x\n    end function cube\nend module arrCallback\n", "target": "public class ArrayCallback7 {\n\n    interface IntConsumer {\n        void run(int x);\n    }\n\n    interface IntToInt {\n        int run(int x);\n    }\n\n    static void forEach(int[] arr, IntConsumer consumer) {\n        for (int i : arr) {\n            consumer.run(i);\n        }\n    }\n\n    static void update(int[] arr, IntToInt mapper) {\n        for (int i = 0; i < arr.length; i++) {\n            arr[i] = mapper.run(arr[i]);\n        }\n    }\n\n    public static void main(String[] args) {\n        int[] numbers = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};\n\n        forEach(numbers, new IntConsumer() {\n            public void run(int x) {\n                System.out.println(x);\n            }\n        });\n\n        update(numbers, new IntToInt() {\n            @Override\n            public int run(int x) {\n                return x * x;\n            }\n        });\n\n        forEach(numbers, new IntConsumer() {\n            public void run(int x) {\n                System.out.println(x);\n            }\n        });\n    }\n}\n"}
{"id": 118084, "name": "Apply a callback to an array", "source": "Translate Fortran to Python: module arrCallback\ncontains\n    elemental function cube( x )\n        implicit none\n        real :: cube\n        real, intent(in) :: x\n        cube = x * x * x\n    end function cube\nend module arrCallback\n", "target": "def square(n):\n    return n * n\n  \nnumbers = [1, 3, 5, 7]\n\nsquares1 = [square(n) for n in numbers]     \n\nsquares2a = map(square, numbers)            \n\nsquares2b = map(lambda x: x*x, numbers)     \n\nsquares3 = [n * n for n in numbers]         \n                                            \n\nisquares1 = (n * n for n in numbers)        \n\nimport itertools\nisquares2 = itertools.imap(square, numbers) \n"}
{"id": 118367, "name": "Sum of squares", "source": "Translate Fortran to C#: real, dimension(1000) :: a = (/ (i, i=1, 1000) /)\nreal, pointer, dimension(:) :: p => a(2:1)       \nreal :: result, zresult\n\nresult = sum(a*a)    \n\nresult = sum(a**2)   \n\nzresult = sum(p*p)   \n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\nclass Program\n{\n    static int SumOfSquares(IEnumerable<int> list)\n    {\n        return list.Sum(x => x * x);\n    }\n    static void Main(string[] args)\n    {\n        Console.WriteLine(SumOfSquares(new int[] { 4, 8, 15, 16, 23, 42 })); \n        Console.WriteLine(SumOfSquares(new int[] { 1, 2, 3, 4, 5 })); \n        Console.WriteLine(SumOfSquares(new int[] { })); \n    }\n}\n"}
{"id": 118370, "name": "Sum of squares", "source": "Translate Fortran to Java: real, dimension(1000) :: a = (/ (i, i=1, 1000) /)\nreal, pointer, dimension(:) :: p => a(2:1)       \nreal :: result, zresult\n\nresult = sum(a*a)    \n\nresult = sum(a**2)   \n\nzresult = sum(p*p)   \n", "target": "public class SumSquares\n{\n public static void main(final String[] args)\n {\n  double sum = 0;\n  int[] nums = {1,2,3,4,5};\n  for (int i : nums)\n   sum += i * i;\n  System.out.println(\"The sum of the squares is: \" + sum);\n }\n}\n"}
{"id": 118371, "name": "Sum of squares", "source": "Translate Fortran to Python: real, dimension(1000) :: a = (/ (i, i=1, 1000) /)\nreal, pointer, dimension(:) :: p => a(2:1)       \nreal :: result, zresult\n\nresult = sum(a*a)    \n\nresult = sum(a**2)   \n\nzresult = sum(p*p)   \n", "target": "sum([1, 2, 3, 4]\u00b2)\n"}
{"id": 118734, "name": "Convert seconds to compound duration", "source": "Translate Fortran to C#:       SUBROUTINE PROUST(T)\t\n       INTEGER T\t\t\n       INTEGER NTYPES\t\t\n       PARAMETER (NTYPES = 5)\t\n       INTEGER USIZE(NTYPES)\t\n       CHARACTER*3 UNAME(NTYPES)\n       PARAMETER (USIZE = (/7*24*60*60, 24*60*60, 60*60,   60,    1/))\t\n       PARAMETER (UNAME = (/      \"wk\",      \"d\",  \"hr\",\"min\",\"sec\"/))\t\n       CHARACTER*28 TEXT\t\n       INTEGER I,L,N,S\t\t\n        S = T\t\t\t\n        L = 0\t\t\t\n        DO I = 1,NTYPES\t\t\n          N = S/USIZE(I)\t\n          IF (N.GT.0) THEN\t\n            S = S - N*USIZE(I)\t\t\n            IF (L.GT.0) THEN\t\t\n              L = L + 2\t\t\t\t\n              TEXT(L - 1:L) = \", \"\t\t\n            END IF\t\t\t\n            WRITE (TEXT(L + 1:),1) N,UNAME(I)\t\n    1       FORMAT (I0,1X,A)\t\t\n            L = LEN_TRIM(TEXT)\t\t\n          END IF\t\t\t\n        END DO\t\t\t\nCast forth the result.\n        WRITE (6,*) T,\">\",TEXT(1:L),\"<\"\t\n       END\t\t\t\n\n       PROGRAM MARCEL\t\t\n       CALL PROUST(7259)\n       CALL PROUST(7260)\n       CALL PROUST(86400)\n       CALL PROUST(6000000)\n       CALL PROUST(0)\n       CALL PROUST(-666)\n       END\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\nnamespace ConvertSecondsToCompoundDuration\n{\n  class Program\n  {\n    static void Main( string[] args )\n    {\n      foreach ( string arg in args )\n      {\n        int duration ;\n        bool isValid = int.TryParse( arg , out duration ) ;\n\n        if ( !isValid     ) { Console.Error.WriteLine( \"ERROR: Not an integer: {0}\"           , arg ) ; }\n        if ( duration < 0 ) { Console.Error.WriteLine( \"ERROR: duration must be non-negative\" , arg ) ; }\n        \n        Console.WriteLine();\n        Console.WriteLine( \"{0:#,##0} seconds ==> {1}\" , duration , FormatAsDuration(duration) ) ;\n        \n      }\n    }\n    \n    private static string FormatAsDuration( int duration )\n    {\n      if ( duration < 0 ) throw new ArgumentOutOfRangeException(\"duration\") ;\n      return string.Join( \", \" , GetDurationParts(duration)  ) ;\n    }\n    \n    private static IEnumerable<string> GetDurationParts( int duration )\n    {\n      var parts = new[]\n      {\n        new { Name=\"wk\" , Length = 7*24*60*60*1 , } ,\n        new { Name=\"d\"  , Length =   24*60*60*1 , } ,\n        new { Name=\"h\"  , Length =      60*60*1 , } ,\n        new { Name=\"m\"  , Length =         60*1 , } ,\n        new { Name=\"s\"  , Length =            1 , } ,\n      } ;\n      \n      foreach ( var part in parts )\n      {\n        int n = Math.DivRem( duration , part.Length , out duration ) ;\n        if ( n > 0 ) yield return string.Format( \"{0} {1}\" , n , part.Name ) ;\n      }\n      \n    }\n    \n  }\n  \n}\n"}
{"id": 118735, "name": "Convert seconds to compound duration", "source": "Translate Fortran to C#:       SUBROUTINE PROUST(T)\t\n       INTEGER T\t\t\n       INTEGER NTYPES\t\t\n       PARAMETER (NTYPES = 5)\t\n       INTEGER USIZE(NTYPES)\t\n       CHARACTER*3 UNAME(NTYPES)\n       PARAMETER (USIZE = (/7*24*60*60, 24*60*60, 60*60,   60,    1/))\t\n       PARAMETER (UNAME = (/      \"wk\",      \"d\",  \"hr\",\"min\",\"sec\"/))\t\n       CHARACTER*28 TEXT\t\n       INTEGER I,L,N,S\t\t\n        S = T\t\t\t\n        L = 0\t\t\t\n        DO I = 1,NTYPES\t\t\n          N = S/USIZE(I)\t\n          IF (N.GT.0) THEN\t\n            S = S - N*USIZE(I)\t\t\n            IF (L.GT.0) THEN\t\t\n              L = L + 2\t\t\t\t\n              TEXT(L - 1:L) = \", \"\t\t\n            END IF\t\t\t\n            WRITE (TEXT(L + 1:),1) N,UNAME(I)\t\n    1       FORMAT (I0,1X,A)\t\t\n            L = LEN_TRIM(TEXT)\t\t\n          END IF\t\t\t\n        END DO\t\t\t\nCast forth the result.\n        WRITE (6,*) T,\">\",TEXT(1:L),\"<\"\t\n       END\t\t\t\n\n       PROGRAM MARCEL\t\t\n       CALL PROUST(7259)\n       CALL PROUST(7260)\n       CALL PROUST(86400)\n       CALL PROUST(6000000)\n       CALL PROUST(0)\n       CALL PROUST(-666)\n       END\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\nnamespace ConvertSecondsToCompoundDuration\n{\n  class Program\n  {\n    static void Main( string[] args )\n    {\n      foreach ( string arg in args )\n      {\n        int duration ;\n        bool isValid = int.TryParse( arg , out duration ) ;\n\n        if ( !isValid     ) { Console.Error.WriteLine( \"ERROR: Not an integer: {0}\"           , arg ) ; }\n        if ( duration < 0 ) { Console.Error.WriteLine( \"ERROR: duration must be non-negative\" , arg ) ; }\n        \n        Console.WriteLine();\n        Console.WriteLine( \"{0:#,##0} seconds ==> {1}\" , duration , FormatAsDuration(duration) ) ;\n        \n      }\n    }\n    \n    private static string FormatAsDuration( int duration )\n    {\n      if ( duration < 0 ) throw new ArgumentOutOfRangeException(\"duration\") ;\n      return string.Join( \", \" , GetDurationParts(duration)  ) ;\n    }\n    \n    private static IEnumerable<string> GetDurationParts( int duration )\n    {\n      var parts = new[]\n      {\n        new { Name=\"wk\" , Length = 7*24*60*60*1 , } ,\n        new { Name=\"d\"  , Length =   24*60*60*1 , } ,\n        new { Name=\"h\"  , Length =      60*60*1 , } ,\n        new { Name=\"m\"  , Length =         60*1 , } ,\n        new { Name=\"s\"  , Length =            1 , } ,\n      } ;\n      \n      foreach ( var part in parts )\n      {\n        int n = Math.DivRem( duration , part.Length , out duration ) ;\n        if ( n > 0 ) yield return string.Format( \"{0} {1}\" , n , part.Name ) ;\n      }\n      \n    }\n    \n  }\n  \n}\n"}
{"id": 118740, "name": "Convert seconds to compound duration", "source": "Translate Fortran to Java:       SUBROUTINE PROUST(T)\t\n       INTEGER T\t\t\n       INTEGER NTYPES\t\t\n       PARAMETER (NTYPES = 5)\t\n       INTEGER USIZE(NTYPES)\t\n       CHARACTER*3 UNAME(NTYPES)\n       PARAMETER (USIZE = (/7*24*60*60, 24*60*60, 60*60,   60,    1/))\t\n       PARAMETER (UNAME = (/      \"wk\",      \"d\",  \"hr\",\"min\",\"sec\"/))\t\n       CHARACTER*28 TEXT\t\n       INTEGER I,L,N,S\t\t\n        S = T\t\t\t\n        L = 0\t\t\t\n        DO I = 1,NTYPES\t\t\n          N = S/USIZE(I)\t\n          IF (N.GT.0) THEN\t\n            S = S - N*USIZE(I)\t\t\n            IF (L.GT.0) THEN\t\t\n              L = L + 2\t\t\t\t\n              TEXT(L - 1:L) = \", \"\t\t\n            END IF\t\t\t\n            WRITE (TEXT(L + 1:),1) N,UNAME(I)\t\n    1       FORMAT (I0,1X,A)\t\t\n            L = LEN_TRIM(TEXT)\t\t\n          END IF\t\t\t\n        END DO\t\t\t\nCast forth the result.\n        WRITE (6,*) T,\">\",TEXT(1:L),\"<\"\t\n       END\t\t\t\n\n       PROGRAM MARCEL\t\t\n       CALL PROUST(7259)\n       CALL PROUST(7260)\n       CALL PROUST(86400)\n       CALL PROUST(6000000)\n       CALL PROUST(0)\n       CALL PROUST(-666)\n       END\n", "target": "public class CompoundDuration {\n\n    public static void main(String[] args) {\n        compound(7259);\n        compound(86400);\n        compound(6000_000);\n    }\n\n    private static void compound(long seconds) {\n        StringBuilder sb = new StringBuilder();\n\n        seconds = addUnit(sb, seconds, 604800, \" wk, \");\n        seconds = addUnit(sb, seconds, 86400, \" d, \");\n        seconds = addUnit(sb, seconds, 3600, \" hr, \");\n        seconds = addUnit(sb, seconds, 60, \" min, \");\n        addUnit(sb, seconds, 1, \" sec, \");\n\n        sb.setLength(sb.length() > 2 ? sb.length() - 2 : 0);\n\n        System.out.println(sb);\n    }\n\n    private static long addUnit(StringBuilder sb, long sec, long unit, String s) {\n        long n;\n        if ((n = sec / unit) > 0) {\n            sb.append(n).append(s);\n            sec %= (n * unit);\n        }\n        return sec;\n    }\n}\n"}
{"id": 118741, "name": "Convert seconds to compound duration", "source": "Translate Fortran to Java:       SUBROUTINE PROUST(T)\t\n       INTEGER T\t\t\n       INTEGER NTYPES\t\t\n       PARAMETER (NTYPES = 5)\t\n       INTEGER USIZE(NTYPES)\t\n       CHARACTER*3 UNAME(NTYPES)\n       PARAMETER (USIZE = (/7*24*60*60, 24*60*60, 60*60,   60,    1/))\t\n       PARAMETER (UNAME = (/      \"wk\",      \"d\",  \"hr\",\"min\",\"sec\"/))\t\n       CHARACTER*28 TEXT\t\n       INTEGER I,L,N,S\t\t\n        S = T\t\t\t\n        L = 0\t\t\t\n        DO I = 1,NTYPES\t\t\n          N = S/USIZE(I)\t\n          IF (N.GT.0) THEN\t\n            S = S - N*USIZE(I)\t\t\n            IF (L.GT.0) THEN\t\t\n              L = L + 2\t\t\t\t\n              TEXT(L - 1:L) = \", \"\t\t\n            END IF\t\t\t\n            WRITE (TEXT(L + 1:),1) N,UNAME(I)\t\n    1       FORMAT (I0,1X,A)\t\t\n            L = LEN_TRIM(TEXT)\t\t\n          END IF\t\t\t\n        END DO\t\t\t\nCast forth the result.\n        WRITE (6,*) T,\">\",TEXT(1:L),\"<\"\t\n       END\t\t\t\n\n       PROGRAM MARCEL\t\t\n       CALL PROUST(7259)\n       CALL PROUST(7260)\n       CALL PROUST(86400)\n       CALL PROUST(6000000)\n       CALL PROUST(0)\n       CALL PROUST(-666)\n       END\n", "target": "public class CompoundDuration {\n\n    public static void main(String[] args) {\n        compound(7259);\n        compound(86400);\n        compound(6000_000);\n    }\n\n    private static void compound(long seconds) {\n        StringBuilder sb = new StringBuilder();\n\n        seconds = addUnit(sb, seconds, 604800, \" wk, \");\n        seconds = addUnit(sb, seconds, 86400, \" d, \");\n        seconds = addUnit(sb, seconds, 3600, \" hr, \");\n        seconds = addUnit(sb, seconds, 60, \" min, \");\n        addUnit(sb, seconds, 1, \" sec, \");\n\n        sb.setLength(sb.length() > 2 ? sb.length() - 2 : 0);\n\n        System.out.println(sb);\n    }\n\n    private static long addUnit(StringBuilder sb, long sec, long unit, String s) {\n        long n;\n        if ((n = sec / unit) > 0) {\n            sb.append(n).append(s);\n            sec %= (n * unit);\n        }\n        return sec;\n    }\n}\n"}
{"id": 118742, "name": "Convert seconds to compound duration", "source": "Translate Fortran to Python:       SUBROUTINE PROUST(T)\t\n       INTEGER T\t\t\n       INTEGER NTYPES\t\t\n       PARAMETER (NTYPES = 5)\t\n       INTEGER USIZE(NTYPES)\t\n       CHARACTER*3 UNAME(NTYPES)\n       PARAMETER (USIZE = (/7*24*60*60, 24*60*60, 60*60,   60,    1/))\t\n       PARAMETER (UNAME = (/      \"wk\",      \"d\",  \"hr\",\"min\",\"sec\"/))\t\n       CHARACTER*28 TEXT\t\n       INTEGER I,L,N,S\t\t\n        S = T\t\t\t\n        L = 0\t\t\t\n        DO I = 1,NTYPES\t\t\n          N = S/USIZE(I)\t\n          IF (N.GT.0) THEN\t\n            S = S - N*USIZE(I)\t\t\n            IF (L.GT.0) THEN\t\t\n              L = L + 2\t\t\t\t\n              TEXT(L - 1:L) = \", \"\t\t\n            END IF\t\t\t\n            WRITE (TEXT(L + 1:),1) N,UNAME(I)\t\n    1       FORMAT (I0,1X,A)\t\t\n            L = LEN_TRIM(TEXT)\t\t\n          END IF\t\t\t\n        END DO\t\t\t\nCast forth the result.\n        WRITE (6,*) T,\">\",TEXT(1:L),\"<\"\t\n       END\t\t\t\n\n       PROGRAM MARCEL\t\t\n       CALL PROUST(7259)\n       CALL PROUST(7260)\n       CALL PROUST(86400)\n       CALL PROUST(6000000)\n       CALL PROUST(0)\n       CALL PROUST(-666)\n       END\n", "target": ">>> def duration(seconds):\n\tt= []\n\tfor dm in (60, 60, 24, 7):\n\t\tseconds, m = divmod(seconds, dm)\n\t\tt.append(m)\n\tt.append(seconds)\n\treturn ', '.join('%d %s' % (num, unit)\n\t\t\t for num, unit in zip(t[::-1], 'wk d hr min sec'.split())\n\t\t\t if num)\n\n>>> for seconds in [7259, 86400, 6000000]:\n\tprint(\"%7d sec = %s\" % (seconds, duration(seconds)))\n\n\t\n   7259 sec = 2 hr, 59 sec\n  86400 sec = 1 d\n6000000 sec = 9 wk, 6 d, 10 hr, 40 min\n>>>\n"}
{"id": 118743, "name": "Convert seconds to compound duration", "source": "Translate Fortran to Python:       SUBROUTINE PROUST(T)\t\n       INTEGER T\t\t\n       INTEGER NTYPES\t\t\n       PARAMETER (NTYPES = 5)\t\n       INTEGER USIZE(NTYPES)\t\n       CHARACTER*3 UNAME(NTYPES)\n       PARAMETER (USIZE = (/7*24*60*60, 24*60*60, 60*60,   60,    1/))\t\n       PARAMETER (UNAME = (/      \"wk\",      \"d\",  \"hr\",\"min\",\"sec\"/))\t\n       CHARACTER*28 TEXT\t\n       INTEGER I,L,N,S\t\t\n        S = T\t\t\t\n        L = 0\t\t\t\n        DO I = 1,NTYPES\t\t\n          N = S/USIZE(I)\t\n          IF (N.GT.0) THEN\t\n            S = S - N*USIZE(I)\t\t\n            IF (L.GT.0) THEN\t\t\n              L = L + 2\t\t\t\t\n              TEXT(L - 1:L) = \", \"\t\t\n            END IF\t\t\t\n            WRITE (TEXT(L + 1:),1) N,UNAME(I)\t\n    1       FORMAT (I0,1X,A)\t\t\n            L = LEN_TRIM(TEXT)\t\t\n          END IF\t\t\t\n        END DO\t\t\t\nCast forth the result.\n        WRITE (6,*) T,\">\",TEXT(1:L),\"<\"\t\n       END\t\t\t\n\n       PROGRAM MARCEL\t\t\n       CALL PROUST(7259)\n       CALL PROUST(7260)\n       CALL PROUST(86400)\n       CALL PROUST(6000000)\n       CALL PROUST(0)\n       CALL PROUST(-666)\n       END\n", "target": ">>> def duration(seconds):\n\tt= []\n\tfor dm in (60, 60, 24, 7):\n\t\tseconds, m = divmod(seconds, dm)\n\t\tt.append(m)\n\tt.append(seconds)\n\treturn ', '.join('%d %s' % (num, unit)\n\t\t\t for num, unit in zip(t[::-1], 'wk d hr min sec'.split())\n\t\t\t if num)\n\n>>> for seconds in [7259, 86400, 6000000]:\n\tprint(\"%7d sec = %s\" % (seconds, duration(seconds)))\n\n\t\n   7259 sec = 2 hr, 59 sec\n  86400 sec = 1 d\n6000000 sec = 9 wk, 6 d, 10 hr, 40 min\n>>>\n"}
{"id": 119059, "name": "Execute a system command", "source": "Translate Fortran to C#: program SystemTest\ninteger :: i\n call execute_command_line (\"ls\", exitstat=i)\nend program SystemTest\n", "target": "using System.Diagnostics;\n\nnamespace Execute\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            Process.Start(\"cmd.exe\", \"/c dir\");\n        }\n    }\n}\n"}
{"id": 119061, "name": "Execute a system command", "source": "Translate Fortran to Java: program SystemTest\ninteger :: i\n call execute_command_line (\"ls\", exitstat=i)\nend program SystemTest\n", "target": "import java.util.Scanner;\nimport java.io.*;\n\npublic class Program {\n    public static void main(String[] args) {    \t\n    \ttry {\n    \t\tProcess p = Runtime.getRuntime().exec(\"cmd /C dir\");\n    \t\tScanner sc = new Scanner(p.getInputStream());    \t\t\n    \t\twhile (sc.hasNext()) System.out.println(sc.nextLine());\n    \t}\n    \tcatch (IOException e) {\n    \t\tSystem.out.println(e.getMessage());\n    \t}\n    }\n}\n"}
{"id": 119062, "name": "Execute a system command", "source": "Translate Fortran to Python: program SystemTest\ninteger :: i\n call execute_command_line (\"ls\", exitstat=i)\nend program SystemTest\n", "target": "import os\nexit_code = os.system('ls')       \noutput    = os.popen('ls').read() \n"}
{"id": 119298, "name": "Loops_Do-while", "source": "Translate Fortran to C#: INTEGER :: i = 0\nDO \n  i = i + 1\n  WRITE(*, *) i\n  IF (MOD(i, 6) == 0) EXIT\nEND DO\n", "target": "int a = 0;\n\ndo\n{\n    a += 1;\n    Console.WriteLine(a);\n} while (a % 6 != 0);\n"}
{"id": 119301, "name": "Loops_Do-while", "source": "Translate Fortran to Java: INTEGER :: i = 0\nDO \n  i = i + 1\n  WRITE(*, *) i\n  IF (MOD(i, 6) == 0) EXIT\nEND DO\n", "target": "int val = 0;\ndo{\n   val++;\n   System.out.println(val);\n}while(val % 6 != 0);\n"}
{"id": 119302, "name": "Loops_Do-while", "source": "Translate Fortran to Python: INTEGER :: i = 0\nDO \n  i = i + 1\n  WRITE(*, *) i\n  IF (MOD(i, 6) == 0) EXIT\nEND DO\n", "target": "val = 0\nwhile True:\n   val +=1\n   print val\n   if val % 6 == 0: break\n"}
{"id": 119872, "name": "Text processing_2", "source": "Translate Fortran to C#: Crunches a set of hourly data. Starts with a date, then 24 pairs of value,indicator for that day, on one line.\n      INTEGER Y,M,D\t\t\n      INTEGER GOOD(24,2)\t\n      REAL*8     V(24,2)\t\n      CHARACTER*10 DATE(2)\t\n      INTEGER IT,TI\t\t\n      INTEGER NV\t\t\n      INTEGER I,NREC,HIC\t\n      LOGICAL INGOOD\t\t\n      INTEGER IN,MSG\t\t\n      CHARACTER*666 ACARD\t\n      IN = 10\t\t\n      MSG = 6\t\t\n      OPEN (IN,FILE=\"Readings1.txt\", FORM=\"FORMATTED\",\t\n     1 STATUS =\"OLD\",ACTION=\"READ\")\t\t\t\n      NV = 0\t\t\n      NREC = 0\t\t\n      HIC = 0\t\t\n      DATE = \"snargle\"\t\n      IT = 2\t\t\nChew into the file.\n   10 READ (IN,11,END=100,ERR=666) L,ACARD(1:MIN(L,LEN(ACARD)))\t\n      NREC = NREC + 1\t\t\n   11 FORMAT (Q,A)\t\t\n      READ (ACARD,12,END=600,ERR=601) Y,M,D\t\n   12 FORMAT (I4,2(1X,I2))\t\t\t\t\n      TI = IT\t\t\t\n      IT = 3 - IT\t\t\n      DATE(IT) = ACARD(1:10)\t\n      READ (ACARD(11:L),*,END=600,ERR=601) (V(I,IT),GOOD(I,IT),I = 1,24)\t\nComparisons. Should really convert the date to a daynumber, check it by reversion, and then check for + 1 day only.\n   20 IF (DATE(IT).EQ.DATE(TI)) THEN\t\n        IF (ALL(V(:,IT)   .EQ.V(:,TI)) .AND.\t\n     1      ALL(GOOD(:,IT).EQ.GOOD(:,TI))) THEN\t\n          WRITE (MSG,21) NREC,DATE(IT),\"same.\"\t\n   21     FORMAT (\"Record\",I8,\" Duplicate date field (\",A,\"), data \",A)\t\n         ELSE\t\t\t\t\n          WRITE (MSG,21) NREC,DATE(IT),\"different\n        END IF\t\t\t\t\t\n      END IF\t\t\t\t\n      IF (ALL(GOOD(:,IT).GT.0)) NV = NV + 1\t\n      GO TO 10\t\t\n\nComplaints. Should really distinguish between trouble in the date part and in the data part.\n  600 WRITE (MSG,*) '\"END\" declared - insufficient data?'\t\n      GO TO 602\t\t\t\t\n  601 WRITE (MSG,*) '\"ERR\" declared - improper number format?'\t\n  602 WRITE (MSG,603) NREC,L,ACARD(1:L)\t\n  603 FORMAT(\"Record\",I8,\", length \",I0,\" reads \",A)\t\n      HIC = HIC + 1\t\t\t\n      IF (HIC.LE.12) GO TO 10\t\t\n      STOP \"Enough distaste.\"\t\t\n  666 WRITE (MSG,101) NREC,\"format error\n      GO TO 900\t\t\t\t\n\nClosedown.\n  100 WRITE (MSG,101) NREC,\"then end-of-file\"\t\n  101 FORMAT (\"Record\",I8,\": \",A)\t\t\n      WRITE (MSG,102) NV\t\n  102 FORMAT (\"  with\",I8,\" having all values good.\")\t\n  900 CLOSE(IN)\t\t\n      END\t\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Text.RegularExpressions;\nusing System.IO;\n\nnamespace TextProc2\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            Regex multiWhite = new Regex(@\"\\s+\");\n            Regex dateEx = new Regex(@\"^\\d{4}-\\d{2}-\\d{2}$\");\n            Regex valEx = new Regex(@\"^\\d+\\.{1}\\d{3}$\");\n            Regex flagEx = new Regex(@\"^[1-9]{1}$\");\n            \n            int missformcount = 0, totalcount = 0;\n            Dictionary<int, string> dates = new Dictionary<int, string>();\n\n            using (StreamReader sr = new StreamReader(\"readings.txt\"))\n            {\n                string line = sr.ReadLine();\n                while (line != null)\n                {\n                    line = multiWhite.Replace(line, @\" \");                    \n                    string[] splitLine = line.Split(' ');\n                    if (splitLine.Length != 49)\n                        missformcount++;\n                    if (!dateEx.IsMatch(splitLine[0]))                        \n                        missformcount++;                    \n                    else\n                        dates.Add(totalcount + 1, dateEx.Match(splitLine[0]).ToString());\n                    int err = 0;                    \n                    for (int i = 1; i < splitLine.Length; i++)\n                    {\n                        if (i%2 != 0)\n                        {\n                            if (!valEx.IsMatch(splitLine[i]))                          \n                                err++;\n                        }\n                        else\n                        {\n                            if (!flagEx.IsMatch(splitLine[i]))\n                                err++;                                                        \n                        }                        \n                    }\n                    if (err != 0) missformcount++;\n                    line = sr.ReadLine();\n                    totalcount++;                    \n                }\n            }\n\n            int goodEntries = totalcount - missformcount;\n            Dictionary<string,List<int>> dateReverse = new Dictionary<string,List<int>>();\n\n            foreach (KeyValuePair<int, string> kvp in dates)\n            {\n                if (!dateReverse.ContainsKey(kvp.Value))\n                    dateReverse[kvp.Value] = new List<int>();\n                dateReverse[kvp.Value].Add(kvp.Key);\n            }\n\n            Console.WriteLine(goodEntries + \" valid Records out of \" + totalcount);\n\n            foreach (KeyValuePair<string, List<int>> kvp in dateReverse)\n            {\n                if (kvp.Value.Count > 1)\n                    Console.WriteLine(\"{0} is duplicated at Lines\u00a0: {1}\", kvp.Key, string.Join(\",\", kvp.Value));                    \n            }\n        }\n    }\n}\n"}
{"id": 119875, "name": "Text processing_2", "source": "Translate Fortran to Java: Crunches a set of hourly data. Starts with a date, then 24 pairs of value,indicator for that day, on one line.\n      INTEGER Y,M,D\t\t\n      INTEGER GOOD(24,2)\t\n      REAL*8     V(24,2)\t\n      CHARACTER*10 DATE(2)\t\n      INTEGER IT,TI\t\t\n      INTEGER NV\t\t\n      INTEGER I,NREC,HIC\t\n      LOGICAL INGOOD\t\t\n      INTEGER IN,MSG\t\t\n      CHARACTER*666 ACARD\t\n      IN = 10\t\t\n      MSG = 6\t\t\n      OPEN (IN,FILE=\"Readings1.txt\", FORM=\"FORMATTED\",\t\n     1 STATUS =\"OLD\",ACTION=\"READ\")\t\t\t\n      NV = 0\t\t\n      NREC = 0\t\t\n      HIC = 0\t\t\n      DATE = \"snargle\"\t\n      IT = 2\t\t\nChew into the file.\n   10 READ (IN,11,END=100,ERR=666) L,ACARD(1:MIN(L,LEN(ACARD)))\t\n      NREC = NREC + 1\t\t\n   11 FORMAT (Q,A)\t\t\n      READ (ACARD,12,END=600,ERR=601) Y,M,D\t\n   12 FORMAT (I4,2(1X,I2))\t\t\t\t\n      TI = IT\t\t\t\n      IT = 3 - IT\t\t\n      DATE(IT) = ACARD(1:10)\t\n      READ (ACARD(11:L),*,END=600,ERR=601) (V(I,IT),GOOD(I,IT),I = 1,24)\t\nComparisons. Should really convert the date to a daynumber, check it by reversion, and then check for + 1 day only.\n   20 IF (DATE(IT).EQ.DATE(TI)) THEN\t\n        IF (ALL(V(:,IT)   .EQ.V(:,TI)) .AND.\t\n     1      ALL(GOOD(:,IT).EQ.GOOD(:,TI))) THEN\t\n          WRITE (MSG,21) NREC,DATE(IT),\"same.\"\t\n   21     FORMAT (\"Record\",I8,\" Duplicate date field (\",A,\"), data \",A)\t\n         ELSE\t\t\t\t\n          WRITE (MSG,21) NREC,DATE(IT),\"different\n        END IF\t\t\t\t\t\n      END IF\t\t\t\t\n      IF (ALL(GOOD(:,IT).GT.0)) NV = NV + 1\t\n      GO TO 10\t\t\n\nComplaints. Should really distinguish between trouble in the date part and in the data part.\n  600 WRITE (MSG,*) '\"END\" declared - insufficient data?'\t\n      GO TO 602\t\t\t\t\n  601 WRITE (MSG,*) '\"ERR\" declared - improper number format?'\t\n  602 WRITE (MSG,603) NREC,L,ACARD(1:L)\t\n  603 FORMAT(\"Record\",I8,\", length \",I0,\" reads \",A)\t\n      HIC = HIC + 1\t\t\t\n      IF (HIC.LE.12) GO TO 10\t\t\n      STOP \"Enough distaste.\"\t\t\n  666 WRITE (MSG,101) NREC,\"format error\n      GO TO 900\t\t\t\t\n\nClosedown.\n  100 WRITE (MSG,101) NREC,\"then end-of-file\"\t\n  101 FORMAT (\"Record\",I8,\": \",A)\t\t\n      WRITE (MSG,102) NV\t\n  102 FORMAT (\"  with\",I8,\" having all values good.\")\t\n  900 CLOSE(IN)\t\t\n      END\t\n", "target": "import java.util.*;\nimport java.util.regex.*;\nimport java.io.*;\n\npublic class DataMunging2 {\n\n    public static final Pattern e = Pattern.compile(\"\\\\s+\");\n\n    public static void main(String[] args) {\n        try {\n            BufferedReader infile = new BufferedReader(new FileReader(args[0]));\n            List<String> duplicates = new ArrayList<String>();\n            Set<String> datestamps = new HashSet<String>(); \n\n            String eingabe;\n            int all_ok = 0;\n            while ((eingabe = infile.readLine()) != null) { \n                String[] fields = e.split(eingabe); \n                if (fields.length != 49) \n                    System.out.println(\"Format not ok!\");\n                if (datestamps.add(fields[0])) { \n                    int howoften = (fields.length - 1) / 2 ; \n                                                             \n                    for (int n = 1; Integer.parseInt(fields[2*n]) >= 1; n++) {\n                        if (n == howoften) {\n                            all_ok++ ;\n                            break ;\n                        }\n                    }\n                } else {\n                    duplicates.add(fields[0]); \n                }\n            }\n            infile.close();\n            System.out.println(\"The following \" + duplicates.size() + \" datestamps were duplicated:\");\n            for (String x : duplicates)\n                System.out.println(x);\n            System.out.println(all_ok + \" records were complete and ok!\");\n        } catch (IOException e) {\n            System.err.println(\"Can't open file \" + args[0]);\n            System.exit(1);\n        }\n    }\n}\n"}
{"id": 119876, "name": "Text processing_2", "source": "Translate Fortran to Python: Crunches a set of hourly data. Starts with a date, then 24 pairs of value,indicator for that day, on one line.\n      INTEGER Y,M,D\t\t\n      INTEGER GOOD(24,2)\t\n      REAL*8     V(24,2)\t\n      CHARACTER*10 DATE(2)\t\n      INTEGER IT,TI\t\t\n      INTEGER NV\t\t\n      INTEGER I,NREC,HIC\t\n      LOGICAL INGOOD\t\t\n      INTEGER IN,MSG\t\t\n      CHARACTER*666 ACARD\t\n      IN = 10\t\t\n      MSG = 6\t\t\n      OPEN (IN,FILE=\"Readings1.txt\", FORM=\"FORMATTED\",\t\n     1 STATUS =\"OLD\",ACTION=\"READ\")\t\t\t\n      NV = 0\t\t\n      NREC = 0\t\t\n      HIC = 0\t\t\n      DATE = \"snargle\"\t\n      IT = 2\t\t\nChew into the file.\n   10 READ (IN,11,END=100,ERR=666) L,ACARD(1:MIN(L,LEN(ACARD)))\t\n      NREC = NREC + 1\t\t\n   11 FORMAT (Q,A)\t\t\n      READ (ACARD,12,END=600,ERR=601) Y,M,D\t\n   12 FORMAT (I4,2(1X,I2))\t\t\t\t\n      TI = IT\t\t\t\n      IT = 3 - IT\t\t\n      DATE(IT) = ACARD(1:10)\t\n      READ (ACARD(11:L),*,END=600,ERR=601) (V(I,IT),GOOD(I,IT),I = 1,24)\t\nComparisons. Should really convert the date to a daynumber, check it by reversion, and then check for + 1 day only.\n   20 IF (DATE(IT).EQ.DATE(TI)) THEN\t\n        IF (ALL(V(:,IT)   .EQ.V(:,TI)) .AND.\t\n     1      ALL(GOOD(:,IT).EQ.GOOD(:,TI))) THEN\t\n          WRITE (MSG,21) NREC,DATE(IT),\"same.\"\t\n   21     FORMAT (\"Record\",I8,\" Duplicate date field (\",A,\"), data \",A)\t\n         ELSE\t\t\t\t\n          WRITE (MSG,21) NREC,DATE(IT),\"different\n        END IF\t\t\t\t\t\n      END IF\t\t\t\t\n      IF (ALL(GOOD(:,IT).GT.0)) NV = NV + 1\t\n      GO TO 10\t\t\n\nComplaints. Should really distinguish between trouble in the date part and in the data part.\n  600 WRITE (MSG,*) '\"END\" declared - insufficient data?'\t\n      GO TO 602\t\t\t\t\n  601 WRITE (MSG,*) '\"ERR\" declared - improper number format?'\t\n  602 WRITE (MSG,603) NREC,L,ACARD(1:L)\t\n  603 FORMAT(\"Record\",I8,\", length \",I0,\" reads \",A)\t\n      HIC = HIC + 1\t\t\t\n      IF (HIC.LE.12) GO TO 10\t\t\n      STOP \"Enough distaste.\"\t\t\n  666 WRITE (MSG,101) NREC,\"format error\n      GO TO 900\t\t\t\t\n\nClosedown.\n  100 WRITE (MSG,101) NREC,\"then end-of-file\"\t\n  101 FORMAT (\"Record\",I8,\": \",A)\t\t\n      WRITE (MSG,102) NV\t\n  102 FORMAT (\"  with\",I8,\" having all values good.\")\t\n  900 CLOSE(IN)\t\t\n      END\t\n", "target": "import re\nimport zipfile\nimport StringIO\n\ndef munge2(readings):\n\n   datePat = re.compile(r'\\d{4}-\\d{2}-\\d{2}')\n   valuPat = re.compile(r'[-+]?\\d+\\.\\d+')\n   statPat = re.compile(r'-?\\d+')\n   allOk, totalLines = 0, 0\n   datestamps = set([])\n   for line in readings:\n      totalLines += 1\n      fields = line.split('\\t')\n      date = fields[0]\n      pairs = [(fields[i],fields[i+1]) for i in range(1,len(fields),2)]\n\n      lineFormatOk = datePat.match(date) and \\\n         all( valuPat.match(p[0]) for p in pairs ) and \\\n         all( statPat.match(p[1]) for p in pairs )\n      if not lineFormatOk:\n         print 'Bad formatting', line\n         continue\n\t\t\n      if len(pairs)!=24 or any( int(p[1]) < 1 for p in pairs ):\n         print 'Missing values', line\n         continue\n\n      if date in datestamps:\n         print 'Duplicate datestamp', line\n         continue\n      datestamps.add(date)\n      allOk += 1\n\n   print 'Lines with all readings: ', allOk\n   print 'Total records: ', totalLines\n\n\n\nreadings = open('readings.txt','r')\nmunge2(readings)\n"}
{"id": 120204, "name": "Floyd's triangle", "source": "Translate Fortran to C#: \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nprogram p\n  integer, dimension(2) :: examples = [5, 14]\n  integer :: i\n  do i=1, size(examples)\n    call floyd(examples(i))\n    write(6, '(/)')\n  end do\n\ncontains\n\n  subroutine floyd(rows)\n    integer, intent(in) :: rows\n    integer :: n, i, j, k\n    integer, dimension(60) :: L\n    character(len=504) :: fmt\n    n = (rows*(rows+1))/2 \n    do i=1,rows \n      L(i) = 2+int(log10(real(n-rows+i)))\n    end do\n    k = 0\n    do i=1,rows\n      do j=1,i\n        k = k+1\n        write(fmt,'(a2,i1,a1)')'(i',L(j),')'\n        write(6,fmt,advance='no') k\n      enddo\n      write(6,*) ''\n    end do\n  end subroutine floyd\n  \nend program p\n", "target": "using System;\nusing System.Text;\n\npublic class FloydsTriangle\n{\n    internal static void Main(string[] args)\n    {\n        int count;\n        if (args.Length >= 1 && int.TryParse(args[0], out count) && count > 0)\n        {\n            Console.WriteLine(MakeTriangle(count));\n        }\n        else\n        {\n            Console.WriteLine(MakeTriangle(5));\n            Console.WriteLine();\n            Console.WriteLine(MakeTriangle(14));\n        }\n    }\n\n    public static string MakeTriangle(int rows)\n    {\n        int maxValue = (rows * (rows + 1)) / 2;\n        int digit = 0;\n        StringBuilder output = new StringBuilder();\n\n        for (int row = 1; row <= rows; row++)\n        {\n            for (int column = 0; column < row; column++)\n            {\n                int colMaxDigit = (maxValue - rows) + column + 1;\n                if (column > 0)\n                {\n                    output.Append(' ');\n                }\n\n                digit++;\n                output.Append(digit.ToString().PadLeft(colMaxDigit.ToString().Length));\n            }\n\n            output.AppendLine();\n        }\n\n        return output.ToString();\n    }\n}\n"}
{"id": 120205, "name": "Floyd's triangle", "source": "Translate Fortran to C#: \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nprogram p\n  integer, dimension(2) :: examples = [5, 14]\n  integer :: i\n  do i=1, size(examples)\n    call floyd(examples(i))\n    write(6, '(/)')\n  end do\n\ncontains\n\n  subroutine floyd(rows)\n    integer, intent(in) :: rows\n    integer :: n, i, j, k\n    integer, dimension(60) :: L\n    character(len=504) :: fmt\n    n = (rows*(rows+1))/2 \n    do i=1,rows \n      L(i) = 2+int(log10(real(n-rows+i)))\n    end do\n    k = 0\n    do i=1,rows\n      do j=1,i\n        k = k+1\n        write(fmt,'(a2,i1,a1)')'(i',L(j),')'\n        write(6,fmt,advance='no') k\n      enddo\n      write(6,*) ''\n    end do\n  end subroutine floyd\n  \nend program p\n", "target": "using System;\nusing System.Text;\n\npublic class FloydsTriangle\n{\n    internal static void Main(string[] args)\n    {\n        int count;\n        if (args.Length >= 1 && int.TryParse(args[0], out count) && count > 0)\n        {\n            Console.WriteLine(MakeTriangle(count));\n        }\n        else\n        {\n            Console.WriteLine(MakeTriangle(5));\n            Console.WriteLine();\n            Console.WriteLine(MakeTriangle(14));\n        }\n    }\n\n    public static string MakeTriangle(int rows)\n    {\n        int maxValue = (rows * (rows + 1)) / 2;\n        int digit = 0;\n        StringBuilder output = new StringBuilder();\n\n        for (int row = 1; row <= rows; row++)\n        {\n            for (int column = 0; column < row; column++)\n            {\n                int colMaxDigit = (maxValue - rows) + column + 1;\n                if (column > 0)\n                {\n                    output.Append(' ');\n                }\n\n                digit++;\n                output.Append(digit.ToString().PadLeft(colMaxDigit.ToString().Length));\n            }\n\n            output.AppendLine();\n        }\n\n        return output.ToString();\n    }\n}\n"}
{"id": 120211, "name": "Floyd's triangle", "source": "Translate Fortran to Java: \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nprogram p\n  integer, dimension(2) :: examples = [5, 14]\n  integer :: i\n  do i=1, size(examples)\n    call floyd(examples(i))\n    write(6, '(/)')\n  end do\n\ncontains\n\n  subroutine floyd(rows)\n    integer, intent(in) :: rows\n    integer :: n, i, j, k\n    integer, dimension(60) :: L\n    character(len=504) :: fmt\n    n = (rows*(rows+1))/2 \n    do i=1,rows \n      L(i) = 2+int(log10(real(n-rows+i)))\n    end do\n    k = 0\n    do i=1,rows\n      do j=1,i\n        k = k+1\n        write(fmt,'(a2,i1,a1)')'(i',L(j),')'\n        write(6,fmt,advance='no') k\n      enddo\n      write(6,*) ''\n    end do\n  end subroutine floyd\n  \nend program p\n", "target": "public class Floyd {\n\tpublic static void main(String[] args){\n\t\tprintTriangle(5);\n\t\tprintTriangle(14);\n\t}\n\t\n\tprivate static void printTriangle(int n){\n\t\tSystem.out.println(n + \" rows:\");\n\t\tfor(int rowNum = 1, printMe = 1, numsPrinted = 0;\n\t\t\t\trowNum <= n; printMe++){\n\t\t\tint cols = (int)Math.ceil(Math.log10(n*(n-1)/2 + numsPrinted + 2));\n\t\t\tSystem.out.printf(\"%\"+cols+\"d \", printMe);\n\t\t\tif(++numsPrinted == rowNum){\n\t\t\t\tSystem.out.println();\n\t\t\t\trowNum++;\n\t\t\t\tnumsPrinted = 0;\n\t\t\t}\n\t\t}\n\t}\n}\n"}
{"id": 120212, "name": "Floyd's triangle", "source": "Translate Fortran to Java: \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nprogram p\n  integer, dimension(2) :: examples = [5, 14]\n  integer :: i\n  do i=1, size(examples)\n    call floyd(examples(i))\n    write(6, '(/)')\n  end do\n\ncontains\n\n  subroutine floyd(rows)\n    integer, intent(in) :: rows\n    integer :: n, i, j, k\n    integer, dimension(60) :: L\n    character(len=504) :: fmt\n    n = (rows*(rows+1))/2 \n    do i=1,rows \n      L(i) = 2+int(log10(real(n-rows+i)))\n    end do\n    k = 0\n    do i=1,rows\n      do j=1,i\n        k = k+1\n        write(fmt,'(a2,i1,a1)')'(i',L(j),')'\n        write(6,fmt,advance='no') k\n      enddo\n      write(6,*) ''\n    end do\n  end subroutine floyd\n  \nend program p\n", "target": "public class Floyd {\n\tpublic static void main(String[] args){\n\t\tprintTriangle(5);\n\t\tprintTriangle(14);\n\t}\n\t\n\tprivate static void printTriangle(int n){\n\t\tSystem.out.println(n + \" rows:\");\n\t\tfor(int rowNum = 1, printMe = 1, numsPrinted = 0;\n\t\t\t\trowNum <= n; printMe++){\n\t\t\tint cols = (int)Math.ceil(Math.log10(n*(n-1)/2 + numsPrinted + 2));\n\t\t\tSystem.out.printf(\"%\"+cols+\"d \", printMe);\n\t\t\tif(++numsPrinted == rowNum){\n\t\t\t\tSystem.out.println();\n\t\t\t\trowNum++;\n\t\t\t\tnumsPrinted = 0;\n\t\t\t}\n\t\t}\n\t}\n}\n"}
{"id": 120213, "name": "Floyd's triangle", "source": "Translate Fortran to Python: \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nprogram p\n  integer, dimension(2) :: examples = [5, 14]\n  integer :: i\n  do i=1, size(examples)\n    call floyd(examples(i))\n    write(6, '(/)')\n  end do\n\ncontains\n\n  subroutine floyd(rows)\n    integer, intent(in) :: rows\n    integer :: n, i, j, k\n    integer, dimension(60) :: L\n    character(len=504) :: fmt\n    n = (rows*(rows+1))/2 \n    do i=1,rows \n      L(i) = 2+int(log10(real(n-rows+i)))\n    end do\n    k = 0\n    do i=1,rows\n      do j=1,i\n        k = k+1\n        write(fmt,'(a2,i1,a1)')'(i',L(j),')'\n        write(6,fmt,advance='no') k\n      enddo\n      write(6,*) ''\n    end do\n  end subroutine floyd\n  \nend program p\n", "target": ">>> def floyd(rowcount=5):\n\trows = [[1]]\n\twhile len(rows) < rowcount:\n\t\tn = rows[-1][-1] + 1\n\t\trows.append(list(range(n, n + len(rows[-1]) + 1)))\n\treturn rows\n\n>>> floyd()\n[[1], [2, 3], [4, 5, 6], [7, 8, 9, 10], [11, 12, 13, 14, 15]]\n>>> def pfloyd(rows=[[1], [2, 3], [4, 5, 6], [7, 8, 9, 10]]):\n\tcolspace = [len(str(n)) for n in rows[-1]]\n\tfor row in rows:\n\t\tprint( ' '.join('%*i' % space_n for space_n in zip(colspace, row)))\n\n\t\t\n>>> pfloyd()\n1\n2 3\n4 5 6\n7 8 9 10\n>>> pfloyd(floyd(5))\n 1\n 2  3\n 4  5  6\n 7  8  9 10\n11 12 13 14 15\n>>> pfloyd(floyd(14))\n 1\n 2  3\n 4  5  6\n 7  8  9 10\n11 12 13 14 15\n16 17 18 19 20 21\n22 23 24 25 26 27 28\n29 30 31 32 33 34 35 36\n37 38 39 40 41 42 43 44  45\n46 47 48 49 50 51 52 53  54  55\n56 57 58 59 60 61 62 63  64  65  66\n67 68 69 70 71 72 73 74  75  76  77  78\n79 80 81 82 83 84 85 86  87  88  89  90  91\n92 93 94 95 96 97 98 99 100 101 102 103 104 105\n>>>\n"}
{"id": 120214, "name": "Floyd's triangle", "source": "Translate Fortran to Python: \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nprogram p\n  integer, dimension(2) :: examples = [5, 14]\n  integer :: i\n  do i=1, size(examples)\n    call floyd(examples(i))\n    write(6, '(/)')\n  end do\n\ncontains\n\n  subroutine floyd(rows)\n    integer, intent(in) :: rows\n    integer :: n, i, j, k\n    integer, dimension(60) :: L\n    character(len=504) :: fmt\n    n = (rows*(rows+1))/2 \n    do i=1,rows \n      L(i) = 2+int(log10(real(n-rows+i)))\n    end do\n    k = 0\n    do i=1,rows\n      do j=1,i\n        k = k+1\n        write(fmt,'(a2,i1,a1)')'(i',L(j),')'\n        write(6,fmt,advance='no') k\n      enddo\n      write(6,*) ''\n    end do\n  end subroutine floyd\n  \nend program p\n", "target": ">>> def floyd(rowcount=5):\n\trows = [[1]]\n\twhile len(rows) < rowcount:\n\t\tn = rows[-1][-1] + 1\n\t\trows.append(list(range(n, n + len(rows[-1]) + 1)))\n\treturn rows\n\n>>> floyd()\n[[1], [2, 3], [4, 5, 6], [7, 8, 9, 10], [11, 12, 13, 14, 15]]\n>>> def pfloyd(rows=[[1], [2, 3], [4, 5, 6], [7, 8, 9, 10]]):\n\tcolspace = [len(str(n)) for n in rows[-1]]\n\tfor row in rows:\n\t\tprint( ' '.join('%*i' % space_n for space_n in zip(colspace, row)))\n\n\t\t\n>>> pfloyd()\n1\n2 3\n4 5 6\n7 8 9 10\n>>> pfloyd(floyd(5))\n 1\n 2  3\n 4  5  6\n 7  8  9 10\n11 12 13 14 15\n>>> pfloyd(floyd(14))\n 1\n 2  3\n 4  5  6\n 7  8  9 10\n11 12 13 14 15\n16 17 18 19 20 21\n22 23 24 25 26 27 28\n29 30 31 32 33 34 35 36\n37 38 39 40 41 42 43 44  45\n46 47 48 49 50 51 52 53  54  55\n56 57 58 59 60 61 62 63  64  65  66\n67 68 69 70 71 72 73 74  75  76  77  78\n79 80 81 82 83 84 85 86  87  88  89  90  91\n92 93 94 95 96 97 98 99 100 101 102 103 104 105\n>>>\n"}
{"id": 120675, "name": "100 prisoners", "source": "Translate Fortran to C#: SUBROUTINE SHUFFLE_ARRAY(INT_ARRAY)\n    \n    \n    IMPLICIT NONE\n\n    INTEGER, DIMENSION(100), INTENT(INOUT) :: INT_ARRAY\n    INTEGER, PARAMETER :: N_PASSES = 10\n    \n\n    INTEGER :: TEMP_1, TEMP_2   \n    INTEGER :: I, J, PASS       \n    REAL :: R                   \n\n    CALL RANDOM_SEED()  \n\n    DO PASS=1, N_PASSES\n        DO I=1, SIZE(INT_ARRAY)\n\n            \n            CALL RANDOM_NUMBER(R)\n            J = CEILING(R*SIZE(INT_ARRAY))\n\n            \n            \n            DO WHILE (J > SIZE(INT_ARRAY))\n                J = CEILING(R*SIZE(INT_ARRAY))\n            END DO\n\n            \n            TEMP_1 = INT_ARRAY(I)\n            TEMP_2 = INT_ARRAY(J)\n            INT_ARRAY(I) = TEMP_2\n            INT_ARRAY(J) = TEMP_1\n        ENDDO\n    ENDDO\nEND SUBROUTINE SHUFFLE_ARRAY\n\nSUBROUTINE RUN_RANDOM(N_ROUNDS)\n    \n    \n    IMPLICIT NONE\n\n    INTEGER, INTENT(IN) :: N_ROUNDS \n\n    INTEGER :: ROUND, PRISONER, CHOICE, I       \n    INTEGER :: N_SUCCESSES                      \n    REAL(8) :: TOTAL                            \n    LOGICAL :: NUM_FOUND = .FALSE.              \n\n    INTEGER, DIMENSION(100) :: CARDS, CHOICES   \n                                                \n\n    \n    \n    \n    \n    CARDS = (/(I, I=1, 100, 1)/)\n    CHOICES = (/(I, I=1, 100, 1)/)\n\n    N_SUCCESSES = 0\n    TOTAL = REAL(N_ROUNDS)\n\n    \n    \n    \n    \n    ROUNDS_LOOP: DO ROUND=1, N_ROUNDS\n        CALL SHUFFLE_ARRAY(CARDS)\n        PRISONERS_LOOP: DO PRISONER=1, 100\n            NUM_FOUND = .FALSE.\n            CALL SHUFFLE_ARRAY(CHOICES)\n            CHOICE_LOOP: DO CHOICE=1, 50\n                IF(CARDS(CHOICE) == PRISONER) THEN\n                    NUM_FOUND = .TRUE.\n                    EXIT CHOICE_LOOP\n                ENDIF\n            ENDDO CHOICE_LOOP\n            IF(.NOT. NUM_FOUND) THEN\n                EXIT PRISONERS_LOOP\n            ENDIF\n        ENDDO PRISONERS_LOOP\n        IF(NUM_FOUND) THEN\n            N_SUCCESSES = N_SUCCESSES + 1\n        ENDIF\n    ENDDO ROUNDS_LOOP\n\n    WRITE(*, '(A, F0.3, A)') \"Random drawer selection method success rate: \", &\n        100*N_SUCCESSES/TOTAL, \"%\"\n\nEND SUBROUTINE RUN_RANDOM\n\nSUBROUTINE RUN_OPTIMAL(N_ROUNDS)\n    \n    \n    \n    \n    IMPLICIT NONE\n\n    INTEGER, INTENT(IN) :: N_ROUNDS\n\n    INTEGER :: ROUND, PRISONER, CHOICE, I   \n    INTEGER :: CURRENT_DRAW                 \n    INTEGER :: N_SUCCESSES                  \n    REAL(8) :: TOTAL                        \n    LOGICAL :: NUM_FOUND = .FALSE.          \n    INTEGER, DIMENSION(100) :: CARDS        \n\n    \n    \n    CARDS = (/(I, I=1, 100, 1)/)\n\n    N_SUCCESSES = 0\n    TOTAL = REAL(N_ROUNDS)\n\n    \n    \n    \n    \n    ROUNDS_LOOP: DO ROUND=1, N_ROUNDS\n        CARDS = (/(I, I=1, 100, 1)/)\n        CALL SHUFFLE_ARRAY(CARDS)\n        PRISONERS_LOOP: DO PRISONER=1, 100\n            CURRENT_DRAW = PRISONER\n            NUM_FOUND = .FALSE.\n            CHOICE_LOOP: DO CHOICE=1, 50\n                IF(CARDS(CURRENT_DRAW) == PRISONER) THEN\n                    NUM_FOUND = .TRUE.\n                    EXIT CHOICE_LOOP\n                ELSE\n                    CURRENT_DRAW = CARDS(CURRENT_DRAW)\n                ENDIF\n            ENDDO CHOICE_LOOP\n            IF(.NOT. NUM_FOUND) THEN\n                EXIT PRISONERS_LOOP\n            ENDIF\n        ENDDO PRISONERS_LOOP\n        IF(NUM_FOUND) THEN\n            N_SUCCESSES = N_SUCCESSES + 1\n        ENDIF\n    ENDDO ROUNDS_LOOP\n    WRITE(*, '(A, F0.3, A)') \"Optimal drawer selection method success rate: \", &\n        100*N_SUCCESSES/TOTAL, \"%\"\n\nEND SUBROUTINE RUN_OPTIMAL\n\nPROGRAM HUNDRED_PRISONERS\n    \n    \n    IMPLICIT NONE\n    INTEGER, PARAMETER :: N_ROUNDS = 50000\n    WRITE(*,'(A, I0, A)') \"Running simulation for \", N_ROUNDS, \" trials...\"\n    CALL RUN_RANDOM(N_ROUNDS)\n    CALL RUN_OPTIMAL(N_ROUNDS)\nEND PROGRAM HUNDRED_PRISONERS\n", "target": "using System;\nusing System.Linq;\n\nnamespace Prisoners {\n    class Program {\n        static bool PlayOptimal() {\n            var secrets = Enumerable.Range(0, 100).OrderBy(a => Guid.NewGuid()).ToList();\n\n            for (int p = 0; p < 100; p++) {\n                bool success = false;\n\n                var choice = p;\n                for (int i = 0; i < 50; i++) {\n                    if (secrets[choice] == p) {\n                        success = true;\n                        break;\n                    }\n                    choice = secrets[choice];\n                }\n\n                if (!success) {\n                    return false;\n                }\n            }\n\n            return true;\n        }\n\n        static bool PlayRandom() {\n            var secrets = Enumerable.Range(0, 100).OrderBy(a => Guid.NewGuid()).ToList();\n\n            for (int p = 0; p < 100; p++) {\n                var choices = Enumerable.Range(0, 100).OrderBy(a => Guid.NewGuid()).ToList();\n\n                bool success = false;\n                for (int i = 0; i < 50; i++) {\n                    if (choices[i] == p) {\n                        success = true;\n                        break;\n                    }\n                }\n\n                if (!success) {\n                    return false;\n                }\n            }\n\n            return true;\n        }\n\n        static double Exec(uint n, Func<bool> play) {\n            uint success = 0;\n            for (uint i = 0; i < n; i++) {\n                if (play()) {\n                    success++;\n                }\n            }\n            return 100.0 * success / n;\n        }\n\n        static void Main() {\n            const uint N = 1_000_000;\n            Console.WriteLine(\"# of executions: {0}\", N);\n            Console.WriteLine(\"Optimal play success rate: {0:0.00000000000}%\", Exec(N, PlayOptimal));\n            Console.WriteLine(\" Random play success rate: {0:0.00000000000}%\", Exec(N, PlayRandom));\n        }\n    }\n}\n"}
{"id": 120676, "name": "100 prisoners", "source": "Translate Fortran to C#: SUBROUTINE SHUFFLE_ARRAY(INT_ARRAY)\n    \n    \n    IMPLICIT NONE\n\n    INTEGER, DIMENSION(100), INTENT(INOUT) :: INT_ARRAY\n    INTEGER, PARAMETER :: N_PASSES = 10\n    \n\n    INTEGER :: TEMP_1, TEMP_2   \n    INTEGER :: I, J, PASS       \n    REAL :: R                   \n\n    CALL RANDOM_SEED()  \n\n    DO PASS=1, N_PASSES\n        DO I=1, SIZE(INT_ARRAY)\n\n            \n            CALL RANDOM_NUMBER(R)\n            J = CEILING(R*SIZE(INT_ARRAY))\n\n            \n            \n            DO WHILE (J > SIZE(INT_ARRAY))\n                J = CEILING(R*SIZE(INT_ARRAY))\n            END DO\n\n            \n            TEMP_1 = INT_ARRAY(I)\n            TEMP_2 = INT_ARRAY(J)\n            INT_ARRAY(I) = TEMP_2\n            INT_ARRAY(J) = TEMP_1\n        ENDDO\n    ENDDO\nEND SUBROUTINE SHUFFLE_ARRAY\n\nSUBROUTINE RUN_RANDOM(N_ROUNDS)\n    \n    \n    IMPLICIT NONE\n\n    INTEGER, INTENT(IN) :: N_ROUNDS \n\n    INTEGER :: ROUND, PRISONER, CHOICE, I       \n    INTEGER :: N_SUCCESSES                      \n    REAL(8) :: TOTAL                            \n    LOGICAL :: NUM_FOUND = .FALSE.              \n\n    INTEGER, DIMENSION(100) :: CARDS, CHOICES   \n                                                \n\n    \n    \n    \n    \n    CARDS = (/(I, I=1, 100, 1)/)\n    CHOICES = (/(I, I=1, 100, 1)/)\n\n    N_SUCCESSES = 0\n    TOTAL = REAL(N_ROUNDS)\n\n    \n    \n    \n    \n    ROUNDS_LOOP: DO ROUND=1, N_ROUNDS\n        CALL SHUFFLE_ARRAY(CARDS)\n        PRISONERS_LOOP: DO PRISONER=1, 100\n            NUM_FOUND = .FALSE.\n            CALL SHUFFLE_ARRAY(CHOICES)\n            CHOICE_LOOP: DO CHOICE=1, 50\n                IF(CARDS(CHOICE) == PRISONER) THEN\n                    NUM_FOUND = .TRUE.\n                    EXIT CHOICE_LOOP\n                ENDIF\n            ENDDO CHOICE_LOOP\n            IF(.NOT. NUM_FOUND) THEN\n                EXIT PRISONERS_LOOP\n            ENDIF\n        ENDDO PRISONERS_LOOP\n        IF(NUM_FOUND) THEN\n            N_SUCCESSES = N_SUCCESSES + 1\n        ENDIF\n    ENDDO ROUNDS_LOOP\n\n    WRITE(*, '(A, F0.3, A)') \"Random drawer selection method success rate: \", &\n        100*N_SUCCESSES/TOTAL, \"%\"\n\nEND SUBROUTINE RUN_RANDOM\n\nSUBROUTINE RUN_OPTIMAL(N_ROUNDS)\n    \n    \n    \n    \n    IMPLICIT NONE\n\n    INTEGER, INTENT(IN) :: N_ROUNDS\n\n    INTEGER :: ROUND, PRISONER, CHOICE, I   \n    INTEGER :: CURRENT_DRAW                 \n    INTEGER :: N_SUCCESSES                  \n    REAL(8) :: TOTAL                        \n    LOGICAL :: NUM_FOUND = .FALSE.          \n    INTEGER, DIMENSION(100) :: CARDS        \n\n    \n    \n    CARDS = (/(I, I=1, 100, 1)/)\n\n    N_SUCCESSES = 0\n    TOTAL = REAL(N_ROUNDS)\n\n    \n    \n    \n    \n    ROUNDS_LOOP: DO ROUND=1, N_ROUNDS\n        CARDS = (/(I, I=1, 100, 1)/)\n        CALL SHUFFLE_ARRAY(CARDS)\n        PRISONERS_LOOP: DO PRISONER=1, 100\n            CURRENT_DRAW = PRISONER\n            NUM_FOUND = .FALSE.\n            CHOICE_LOOP: DO CHOICE=1, 50\n                IF(CARDS(CURRENT_DRAW) == PRISONER) THEN\n                    NUM_FOUND = .TRUE.\n                    EXIT CHOICE_LOOP\n                ELSE\n                    CURRENT_DRAW = CARDS(CURRENT_DRAW)\n                ENDIF\n            ENDDO CHOICE_LOOP\n            IF(.NOT. NUM_FOUND) THEN\n                EXIT PRISONERS_LOOP\n            ENDIF\n        ENDDO PRISONERS_LOOP\n        IF(NUM_FOUND) THEN\n            N_SUCCESSES = N_SUCCESSES + 1\n        ENDIF\n    ENDDO ROUNDS_LOOP\n    WRITE(*, '(A, F0.3, A)') \"Optimal drawer selection method success rate: \", &\n        100*N_SUCCESSES/TOTAL, \"%\"\n\nEND SUBROUTINE RUN_OPTIMAL\n\nPROGRAM HUNDRED_PRISONERS\n    \n    \n    IMPLICIT NONE\n    INTEGER, PARAMETER :: N_ROUNDS = 50000\n    WRITE(*,'(A, I0, A)') \"Running simulation for \", N_ROUNDS, \" trials...\"\n    CALL RUN_RANDOM(N_ROUNDS)\n    CALL RUN_OPTIMAL(N_ROUNDS)\nEND PROGRAM HUNDRED_PRISONERS\n", "target": "using System;\nusing System.Linq;\n\nnamespace Prisoners {\n    class Program {\n        static bool PlayOptimal() {\n            var secrets = Enumerable.Range(0, 100).OrderBy(a => Guid.NewGuid()).ToList();\n\n            for (int p = 0; p < 100; p++) {\n                bool success = false;\n\n                var choice = p;\n                for (int i = 0; i < 50; i++) {\n                    if (secrets[choice] == p) {\n                        success = true;\n                        break;\n                    }\n                    choice = secrets[choice];\n                }\n\n                if (!success) {\n                    return false;\n                }\n            }\n\n            return true;\n        }\n\n        static bool PlayRandom() {\n            var secrets = Enumerable.Range(0, 100).OrderBy(a => Guid.NewGuid()).ToList();\n\n            for (int p = 0; p < 100; p++) {\n                var choices = Enumerable.Range(0, 100).OrderBy(a => Guid.NewGuid()).ToList();\n\n                bool success = false;\n                for (int i = 0; i < 50; i++) {\n                    if (choices[i] == p) {\n                        success = true;\n                        break;\n                    }\n                }\n\n                if (!success) {\n                    return false;\n                }\n            }\n\n            return true;\n        }\n\n        static double Exec(uint n, Func<bool> play) {\n            uint success = 0;\n            for (uint i = 0; i < n; i++) {\n                if (play()) {\n                    success++;\n                }\n            }\n            return 100.0 * success / n;\n        }\n\n        static void Main() {\n            const uint N = 1_000_000;\n            Console.WriteLine(\"# of executions: {0}\", N);\n            Console.WriteLine(\"Optimal play success rate: {0:0.00000000000}%\", Exec(N, PlayOptimal));\n            Console.WriteLine(\" Random play success rate: {0:0.00000000000}%\", Exec(N, PlayRandom));\n        }\n    }\n}\n"}
{"id": 120683, "name": "100 prisoners", "source": "Translate Fortran to Java: SUBROUTINE SHUFFLE_ARRAY(INT_ARRAY)\n    \n    \n    IMPLICIT NONE\n\n    INTEGER, DIMENSION(100), INTENT(INOUT) :: INT_ARRAY\n    INTEGER, PARAMETER :: N_PASSES = 10\n    \n\n    INTEGER :: TEMP_1, TEMP_2   \n    INTEGER :: I, J, PASS       \n    REAL :: R                   \n\n    CALL RANDOM_SEED()  \n\n    DO PASS=1, N_PASSES\n        DO I=1, SIZE(INT_ARRAY)\n\n            \n            CALL RANDOM_NUMBER(R)\n            J = CEILING(R*SIZE(INT_ARRAY))\n\n            \n            \n            DO WHILE (J > SIZE(INT_ARRAY))\n                J = CEILING(R*SIZE(INT_ARRAY))\n            END DO\n\n            \n            TEMP_1 = INT_ARRAY(I)\n            TEMP_2 = INT_ARRAY(J)\n            INT_ARRAY(I) = TEMP_2\n            INT_ARRAY(J) = TEMP_1\n        ENDDO\n    ENDDO\nEND SUBROUTINE SHUFFLE_ARRAY\n\nSUBROUTINE RUN_RANDOM(N_ROUNDS)\n    \n    \n    IMPLICIT NONE\n\n    INTEGER, INTENT(IN) :: N_ROUNDS \n\n    INTEGER :: ROUND, PRISONER, CHOICE, I       \n    INTEGER :: N_SUCCESSES                      \n    REAL(8) :: TOTAL                            \n    LOGICAL :: NUM_FOUND = .FALSE.              \n\n    INTEGER, DIMENSION(100) :: CARDS, CHOICES   \n                                                \n\n    \n    \n    \n    \n    CARDS = (/(I, I=1, 100, 1)/)\n    CHOICES = (/(I, I=1, 100, 1)/)\n\n    N_SUCCESSES = 0\n    TOTAL = REAL(N_ROUNDS)\n\n    \n    \n    \n    \n    ROUNDS_LOOP: DO ROUND=1, N_ROUNDS\n        CALL SHUFFLE_ARRAY(CARDS)\n        PRISONERS_LOOP: DO PRISONER=1, 100\n            NUM_FOUND = .FALSE.\n            CALL SHUFFLE_ARRAY(CHOICES)\n            CHOICE_LOOP: DO CHOICE=1, 50\n                IF(CARDS(CHOICE) == PRISONER) THEN\n                    NUM_FOUND = .TRUE.\n                    EXIT CHOICE_LOOP\n                ENDIF\n            ENDDO CHOICE_LOOP\n            IF(.NOT. NUM_FOUND) THEN\n                EXIT PRISONERS_LOOP\n            ENDIF\n        ENDDO PRISONERS_LOOP\n        IF(NUM_FOUND) THEN\n            N_SUCCESSES = N_SUCCESSES + 1\n        ENDIF\n    ENDDO ROUNDS_LOOP\n\n    WRITE(*, '(A, F0.3, A)') \"Random drawer selection method success rate: \", &\n        100*N_SUCCESSES/TOTAL, \"%\"\n\nEND SUBROUTINE RUN_RANDOM\n\nSUBROUTINE RUN_OPTIMAL(N_ROUNDS)\n    \n    \n    \n    \n    IMPLICIT NONE\n\n    INTEGER, INTENT(IN) :: N_ROUNDS\n\n    INTEGER :: ROUND, PRISONER, CHOICE, I   \n    INTEGER :: CURRENT_DRAW                 \n    INTEGER :: N_SUCCESSES                  \n    REAL(8) :: TOTAL                        \n    LOGICAL :: NUM_FOUND = .FALSE.          \n    INTEGER, DIMENSION(100) :: CARDS        \n\n    \n    \n    CARDS = (/(I, I=1, 100, 1)/)\n\n    N_SUCCESSES = 0\n    TOTAL = REAL(N_ROUNDS)\n\n    \n    \n    \n    \n    ROUNDS_LOOP: DO ROUND=1, N_ROUNDS\n        CARDS = (/(I, I=1, 100, 1)/)\n        CALL SHUFFLE_ARRAY(CARDS)\n        PRISONERS_LOOP: DO PRISONER=1, 100\n            CURRENT_DRAW = PRISONER\n            NUM_FOUND = .FALSE.\n            CHOICE_LOOP: DO CHOICE=1, 50\n                IF(CARDS(CURRENT_DRAW) == PRISONER) THEN\n                    NUM_FOUND = .TRUE.\n                    EXIT CHOICE_LOOP\n                ELSE\n                    CURRENT_DRAW = CARDS(CURRENT_DRAW)\n                ENDIF\n            ENDDO CHOICE_LOOP\n            IF(.NOT. NUM_FOUND) THEN\n                EXIT PRISONERS_LOOP\n            ENDIF\n        ENDDO PRISONERS_LOOP\n        IF(NUM_FOUND) THEN\n            N_SUCCESSES = N_SUCCESSES + 1\n        ENDIF\n    ENDDO ROUNDS_LOOP\n    WRITE(*, '(A, F0.3, A)') \"Optimal drawer selection method success rate: \", &\n        100*N_SUCCESSES/TOTAL, \"%\"\n\nEND SUBROUTINE RUN_OPTIMAL\n\nPROGRAM HUNDRED_PRISONERS\n    \n    \n    IMPLICIT NONE\n    INTEGER, PARAMETER :: N_ROUNDS = 50000\n    WRITE(*,'(A, I0, A)') \"Running simulation for \", N_ROUNDS, \" trials...\"\n    CALL RUN_RANDOM(N_ROUNDS)\n    CALL RUN_OPTIMAL(N_ROUNDS)\nEND PROGRAM HUNDRED_PRISONERS\n", "target": "import java.util.Collections;\nimport java.util.List;\nimport java.util.Objects;\nimport java.util.function.Function;\nimport java.util.function.Supplier;\nimport java.util.stream.Collectors;\nimport java.util.stream.IntStream;\n\npublic class Main {\n    private static boolean playOptimal(int n) {\n        List<Integer> secretList = IntStream.range(0, n).boxed().collect(Collectors.toList());\n        Collections.shuffle(secretList);\n\n        prisoner:\n        for (int i = 0; i < secretList.size(); ++i) {\n            int prev = i;\n            for (int j = 0; j < secretList.size() / 2; ++j) {\n                if (secretList.get(prev) == i) {\n                    continue prisoner;\n                }\n                prev = secretList.get(prev);\n            }\n            return false;\n        }\n        return true;\n    }\n\n    private static boolean playRandom(int n) {\n        List<Integer> secretList = IntStream.range(0, n).boxed().collect(Collectors.toList());\n        Collections.shuffle(secretList);\n\n        prisoner:\n        for (Integer i : secretList) {\n            List<Integer> trialList = IntStream.range(0, n).boxed().collect(Collectors.toList());\n            Collections.shuffle(trialList);\n\n            for (int j = 0; j < trialList.size() / 2; ++j) {\n                if (Objects.equals(trialList.get(j), i)) {\n                    continue prisoner;\n                }\n            }\n\n            return false;\n        }\n        return true;\n    }\n\n    private static double exec(int n, int p, Function<Integer, Boolean> play) {\n        int succ = 0;\n        for (int i = 0; i < n; ++i) {\n            if (play.apply(p)) {\n                succ++;\n            }\n        }\n        return (succ * 100.0) / n;\n    }\n\n    public static void main(String[] args) {\n        final int n = 100_000;\n        final int p = 100;\n        System.out.printf(\"# of executions: %d\\n\", n);\n        System.out.printf(\"Optimal play success rate: %f%%\\n\", exec(n, p, Main::playOptimal));\n        System.out.printf(\"Random play success rate: %f%%\\n\", exec(n, p, Main::playRandom));\n    }\n}\n"}
{"id": 120684, "name": "100 prisoners", "source": "Translate Fortran to Java: SUBROUTINE SHUFFLE_ARRAY(INT_ARRAY)\n    \n    \n    IMPLICIT NONE\n\n    INTEGER, DIMENSION(100), INTENT(INOUT) :: INT_ARRAY\n    INTEGER, PARAMETER :: N_PASSES = 10\n    \n\n    INTEGER :: TEMP_1, TEMP_2   \n    INTEGER :: I, J, PASS       \n    REAL :: R                   \n\n    CALL RANDOM_SEED()  \n\n    DO PASS=1, N_PASSES\n        DO I=1, SIZE(INT_ARRAY)\n\n            \n            CALL RANDOM_NUMBER(R)\n            J = CEILING(R*SIZE(INT_ARRAY))\n\n            \n            \n            DO WHILE (J > SIZE(INT_ARRAY))\n                J = CEILING(R*SIZE(INT_ARRAY))\n            END DO\n\n            \n            TEMP_1 = INT_ARRAY(I)\n            TEMP_2 = INT_ARRAY(J)\n            INT_ARRAY(I) = TEMP_2\n            INT_ARRAY(J) = TEMP_1\n        ENDDO\n    ENDDO\nEND SUBROUTINE SHUFFLE_ARRAY\n\nSUBROUTINE RUN_RANDOM(N_ROUNDS)\n    \n    \n    IMPLICIT NONE\n\n    INTEGER, INTENT(IN) :: N_ROUNDS \n\n    INTEGER :: ROUND, PRISONER, CHOICE, I       \n    INTEGER :: N_SUCCESSES                      \n    REAL(8) :: TOTAL                            \n    LOGICAL :: NUM_FOUND = .FALSE.              \n\n    INTEGER, DIMENSION(100) :: CARDS, CHOICES   \n                                                \n\n    \n    \n    \n    \n    CARDS = (/(I, I=1, 100, 1)/)\n    CHOICES = (/(I, I=1, 100, 1)/)\n\n    N_SUCCESSES = 0\n    TOTAL = REAL(N_ROUNDS)\n\n    \n    \n    \n    \n    ROUNDS_LOOP: DO ROUND=1, N_ROUNDS\n        CALL SHUFFLE_ARRAY(CARDS)\n        PRISONERS_LOOP: DO PRISONER=1, 100\n            NUM_FOUND = .FALSE.\n            CALL SHUFFLE_ARRAY(CHOICES)\n            CHOICE_LOOP: DO CHOICE=1, 50\n                IF(CARDS(CHOICE) == PRISONER) THEN\n                    NUM_FOUND = .TRUE.\n                    EXIT CHOICE_LOOP\n                ENDIF\n            ENDDO CHOICE_LOOP\n            IF(.NOT. NUM_FOUND) THEN\n                EXIT PRISONERS_LOOP\n            ENDIF\n        ENDDO PRISONERS_LOOP\n        IF(NUM_FOUND) THEN\n            N_SUCCESSES = N_SUCCESSES + 1\n        ENDIF\n    ENDDO ROUNDS_LOOP\n\n    WRITE(*, '(A, F0.3, A)') \"Random drawer selection method success rate: \", &\n        100*N_SUCCESSES/TOTAL, \"%\"\n\nEND SUBROUTINE RUN_RANDOM\n\nSUBROUTINE RUN_OPTIMAL(N_ROUNDS)\n    \n    \n    \n    \n    IMPLICIT NONE\n\n    INTEGER, INTENT(IN) :: N_ROUNDS\n\n    INTEGER :: ROUND, PRISONER, CHOICE, I   \n    INTEGER :: CURRENT_DRAW                 \n    INTEGER :: N_SUCCESSES                  \n    REAL(8) :: TOTAL                        \n    LOGICAL :: NUM_FOUND = .FALSE.          \n    INTEGER, DIMENSION(100) :: CARDS        \n\n    \n    \n    CARDS = (/(I, I=1, 100, 1)/)\n\n    N_SUCCESSES = 0\n    TOTAL = REAL(N_ROUNDS)\n\n    \n    \n    \n    \n    ROUNDS_LOOP: DO ROUND=1, N_ROUNDS\n        CARDS = (/(I, I=1, 100, 1)/)\n        CALL SHUFFLE_ARRAY(CARDS)\n        PRISONERS_LOOP: DO PRISONER=1, 100\n            CURRENT_DRAW = PRISONER\n            NUM_FOUND = .FALSE.\n            CHOICE_LOOP: DO CHOICE=1, 50\n                IF(CARDS(CURRENT_DRAW) == PRISONER) THEN\n                    NUM_FOUND = .TRUE.\n                    EXIT CHOICE_LOOP\n                ELSE\n                    CURRENT_DRAW = CARDS(CURRENT_DRAW)\n                ENDIF\n            ENDDO CHOICE_LOOP\n            IF(.NOT. NUM_FOUND) THEN\n                EXIT PRISONERS_LOOP\n            ENDIF\n        ENDDO PRISONERS_LOOP\n        IF(NUM_FOUND) THEN\n            N_SUCCESSES = N_SUCCESSES + 1\n        ENDIF\n    ENDDO ROUNDS_LOOP\n    WRITE(*, '(A, F0.3, A)') \"Optimal drawer selection method success rate: \", &\n        100*N_SUCCESSES/TOTAL, \"%\"\n\nEND SUBROUTINE RUN_OPTIMAL\n\nPROGRAM HUNDRED_PRISONERS\n    \n    \n    IMPLICIT NONE\n    INTEGER, PARAMETER :: N_ROUNDS = 50000\n    WRITE(*,'(A, I0, A)') \"Running simulation for \", N_ROUNDS, \" trials...\"\n    CALL RUN_RANDOM(N_ROUNDS)\n    CALL RUN_OPTIMAL(N_ROUNDS)\nEND PROGRAM HUNDRED_PRISONERS\n", "target": "import java.util.Collections;\nimport java.util.List;\nimport java.util.Objects;\nimport java.util.function.Function;\nimport java.util.function.Supplier;\nimport java.util.stream.Collectors;\nimport java.util.stream.IntStream;\n\npublic class Main {\n    private static boolean playOptimal(int n) {\n        List<Integer> secretList = IntStream.range(0, n).boxed().collect(Collectors.toList());\n        Collections.shuffle(secretList);\n\n        prisoner:\n        for (int i = 0; i < secretList.size(); ++i) {\n            int prev = i;\n            for (int j = 0; j < secretList.size() / 2; ++j) {\n                if (secretList.get(prev) == i) {\n                    continue prisoner;\n                }\n                prev = secretList.get(prev);\n            }\n            return false;\n        }\n        return true;\n    }\n\n    private static boolean playRandom(int n) {\n        List<Integer> secretList = IntStream.range(0, n).boxed().collect(Collectors.toList());\n        Collections.shuffle(secretList);\n\n        prisoner:\n        for (Integer i : secretList) {\n            List<Integer> trialList = IntStream.range(0, n).boxed().collect(Collectors.toList());\n            Collections.shuffle(trialList);\n\n            for (int j = 0; j < trialList.size() / 2; ++j) {\n                if (Objects.equals(trialList.get(j), i)) {\n                    continue prisoner;\n                }\n            }\n\n            return false;\n        }\n        return true;\n    }\n\n    private static double exec(int n, int p, Function<Integer, Boolean> play) {\n        int succ = 0;\n        for (int i = 0; i < n; ++i) {\n            if (play.apply(p)) {\n                succ++;\n            }\n        }\n        return (succ * 100.0) / n;\n    }\n\n    public static void main(String[] args) {\n        final int n = 100_000;\n        final int p = 100;\n        System.out.printf(\"# of executions: %d\\n\", n);\n        System.out.printf(\"Optimal play success rate: %f%%\\n\", exec(n, p, Main::playOptimal));\n        System.out.printf(\"Random play success rate: %f%%\\n\", exec(n, p, Main::playRandom));\n    }\n}\n"}
{"id": 120685, "name": "100 prisoners", "source": "Translate Fortran to Python: SUBROUTINE SHUFFLE_ARRAY(INT_ARRAY)\n    \n    \n    IMPLICIT NONE\n\n    INTEGER, DIMENSION(100), INTENT(INOUT) :: INT_ARRAY\n    INTEGER, PARAMETER :: N_PASSES = 10\n    \n\n    INTEGER :: TEMP_1, TEMP_2   \n    INTEGER :: I, J, PASS       \n    REAL :: R                   \n\n    CALL RANDOM_SEED()  \n\n    DO PASS=1, N_PASSES\n        DO I=1, SIZE(INT_ARRAY)\n\n            \n            CALL RANDOM_NUMBER(R)\n            J = CEILING(R*SIZE(INT_ARRAY))\n\n            \n            \n            DO WHILE (J > SIZE(INT_ARRAY))\n                J = CEILING(R*SIZE(INT_ARRAY))\n            END DO\n\n            \n            TEMP_1 = INT_ARRAY(I)\n            TEMP_2 = INT_ARRAY(J)\n            INT_ARRAY(I) = TEMP_2\n            INT_ARRAY(J) = TEMP_1\n        ENDDO\n    ENDDO\nEND SUBROUTINE SHUFFLE_ARRAY\n\nSUBROUTINE RUN_RANDOM(N_ROUNDS)\n    \n    \n    IMPLICIT NONE\n\n    INTEGER, INTENT(IN) :: N_ROUNDS \n\n    INTEGER :: ROUND, PRISONER, CHOICE, I       \n    INTEGER :: N_SUCCESSES                      \n    REAL(8) :: TOTAL                            \n    LOGICAL :: NUM_FOUND = .FALSE.              \n\n    INTEGER, DIMENSION(100) :: CARDS, CHOICES   \n                                                \n\n    \n    \n    \n    \n    CARDS = (/(I, I=1, 100, 1)/)\n    CHOICES = (/(I, I=1, 100, 1)/)\n\n    N_SUCCESSES = 0\n    TOTAL = REAL(N_ROUNDS)\n\n    \n    \n    \n    \n    ROUNDS_LOOP: DO ROUND=1, N_ROUNDS\n        CALL SHUFFLE_ARRAY(CARDS)\n        PRISONERS_LOOP: DO PRISONER=1, 100\n            NUM_FOUND = .FALSE.\n            CALL SHUFFLE_ARRAY(CHOICES)\n            CHOICE_LOOP: DO CHOICE=1, 50\n                IF(CARDS(CHOICE) == PRISONER) THEN\n                    NUM_FOUND = .TRUE.\n                    EXIT CHOICE_LOOP\n                ENDIF\n            ENDDO CHOICE_LOOP\n            IF(.NOT. NUM_FOUND) THEN\n                EXIT PRISONERS_LOOP\n            ENDIF\n        ENDDO PRISONERS_LOOP\n        IF(NUM_FOUND) THEN\n            N_SUCCESSES = N_SUCCESSES + 1\n        ENDIF\n    ENDDO ROUNDS_LOOP\n\n    WRITE(*, '(A, F0.3, A)') \"Random drawer selection method success rate: \", &\n        100*N_SUCCESSES/TOTAL, \"%\"\n\nEND SUBROUTINE RUN_RANDOM\n\nSUBROUTINE RUN_OPTIMAL(N_ROUNDS)\n    \n    \n    \n    \n    IMPLICIT NONE\n\n    INTEGER, INTENT(IN) :: N_ROUNDS\n\n    INTEGER :: ROUND, PRISONER, CHOICE, I   \n    INTEGER :: CURRENT_DRAW                 \n    INTEGER :: N_SUCCESSES                  \n    REAL(8) :: TOTAL                        \n    LOGICAL :: NUM_FOUND = .FALSE.          \n    INTEGER, DIMENSION(100) :: CARDS        \n\n    \n    \n    CARDS = (/(I, I=1, 100, 1)/)\n\n    N_SUCCESSES = 0\n    TOTAL = REAL(N_ROUNDS)\n\n    \n    \n    \n    \n    ROUNDS_LOOP: DO ROUND=1, N_ROUNDS\n        CARDS = (/(I, I=1, 100, 1)/)\n        CALL SHUFFLE_ARRAY(CARDS)\n        PRISONERS_LOOP: DO PRISONER=1, 100\n            CURRENT_DRAW = PRISONER\n            NUM_FOUND = .FALSE.\n            CHOICE_LOOP: DO CHOICE=1, 50\n                IF(CARDS(CURRENT_DRAW) == PRISONER) THEN\n                    NUM_FOUND = .TRUE.\n                    EXIT CHOICE_LOOP\n                ELSE\n                    CURRENT_DRAW = CARDS(CURRENT_DRAW)\n                ENDIF\n            ENDDO CHOICE_LOOP\n            IF(.NOT. NUM_FOUND) THEN\n                EXIT PRISONERS_LOOP\n            ENDIF\n        ENDDO PRISONERS_LOOP\n        IF(NUM_FOUND) THEN\n            N_SUCCESSES = N_SUCCESSES + 1\n        ENDIF\n    ENDDO ROUNDS_LOOP\n    WRITE(*, '(A, F0.3, A)') \"Optimal drawer selection method success rate: \", &\n        100*N_SUCCESSES/TOTAL, \"%\"\n\nEND SUBROUTINE RUN_OPTIMAL\n\nPROGRAM HUNDRED_PRISONERS\n    \n    \n    IMPLICIT NONE\n    INTEGER, PARAMETER :: N_ROUNDS = 50000\n    WRITE(*,'(A, I0, A)') \"Running simulation for \", N_ROUNDS, \" trials...\"\n    CALL RUN_RANDOM(N_ROUNDS)\n    CALL RUN_OPTIMAL(N_ROUNDS)\nEND PROGRAM HUNDRED_PRISONERS\n", "target": "import random\n\ndef play_random(n):\n    \n    pardoned = 0\n    in_drawer = list(range(100))\n    sampler = list(range(100))\n    for _round in range(n):\n        random.shuffle(in_drawer)\n        found = False\n        for prisoner in range(100):\n            found = False\n            for reveal in random.sample(sampler, 50):\n                card = in_drawer[reveal]\n                if card == prisoner:\n                    found = True\n                    break\n            if not found:\n                break\n        if found:\n            pardoned += 1\n    return pardoned / n * 100   \n\ndef play_optimal(n):\n    \n    pardoned = 0\n    in_drawer = list(range(100))\n    for _round in range(n):\n        random.shuffle(in_drawer)\n        for prisoner in range(100):\n            reveal = prisoner\n            found = False\n            for go in range(50):\n                card = in_drawer[reveal]\n                if card == prisoner:\n                    found = True\n                    break\n                reveal = card\n            if not found:\n                break\n        if found:\n            pardoned += 1\n    return pardoned / n * 100   \n\nif __name__ == '__main__':\n    n = 100_000\n    print(\" Simulation count:\", n)\n    print(f\" Random play wins: {play_random(n):4.1f}% of simulations\")\n    print(f\"Optimal play wins: {play_optimal(n):4.1f}% of simulations\")\n"}
{"id": 120686, "name": "100 prisoners", "source": "Translate Fortran to Python: SUBROUTINE SHUFFLE_ARRAY(INT_ARRAY)\n    \n    \n    IMPLICIT NONE\n\n    INTEGER, DIMENSION(100), INTENT(INOUT) :: INT_ARRAY\n    INTEGER, PARAMETER :: N_PASSES = 10\n    \n\n    INTEGER :: TEMP_1, TEMP_2   \n    INTEGER :: I, J, PASS       \n    REAL :: R                   \n\n    CALL RANDOM_SEED()  \n\n    DO PASS=1, N_PASSES\n        DO I=1, SIZE(INT_ARRAY)\n\n            \n            CALL RANDOM_NUMBER(R)\n            J = CEILING(R*SIZE(INT_ARRAY))\n\n            \n            \n            DO WHILE (J > SIZE(INT_ARRAY))\n                J = CEILING(R*SIZE(INT_ARRAY))\n            END DO\n\n            \n            TEMP_1 = INT_ARRAY(I)\n            TEMP_2 = INT_ARRAY(J)\n            INT_ARRAY(I) = TEMP_2\n            INT_ARRAY(J) = TEMP_1\n        ENDDO\n    ENDDO\nEND SUBROUTINE SHUFFLE_ARRAY\n\nSUBROUTINE RUN_RANDOM(N_ROUNDS)\n    \n    \n    IMPLICIT NONE\n\n    INTEGER, INTENT(IN) :: N_ROUNDS \n\n    INTEGER :: ROUND, PRISONER, CHOICE, I       \n    INTEGER :: N_SUCCESSES                      \n    REAL(8) :: TOTAL                            \n    LOGICAL :: NUM_FOUND = .FALSE.              \n\n    INTEGER, DIMENSION(100) :: CARDS, CHOICES   \n                                                \n\n    \n    \n    \n    \n    CARDS = (/(I, I=1, 100, 1)/)\n    CHOICES = (/(I, I=1, 100, 1)/)\n\n    N_SUCCESSES = 0\n    TOTAL = REAL(N_ROUNDS)\n\n    \n    \n    \n    \n    ROUNDS_LOOP: DO ROUND=1, N_ROUNDS\n        CALL SHUFFLE_ARRAY(CARDS)\n        PRISONERS_LOOP: DO PRISONER=1, 100\n            NUM_FOUND = .FALSE.\n            CALL SHUFFLE_ARRAY(CHOICES)\n            CHOICE_LOOP: DO CHOICE=1, 50\n                IF(CARDS(CHOICE) == PRISONER) THEN\n                    NUM_FOUND = .TRUE.\n                    EXIT CHOICE_LOOP\n                ENDIF\n            ENDDO CHOICE_LOOP\n            IF(.NOT. NUM_FOUND) THEN\n                EXIT PRISONERS_LOOP\n            ENDIF\n        ENDDO PRISONERS_LOOP\n        IF(NUM_FOUND) THEN\n            N_SUCCESSES = N_SUCCESSES + 1\n        ENDIF\n    ENDDO ROUNDS_LOOP\n\n    WRITE(*, '(A, F0.3, A)') \"Random drawer selection method success rate: \", &\n        100*N_SUCCESSES/TOTAL, \"%\"\n\nEND SUBROUTINE RUN_RANDOM\n\nSUBROUTINE RUN_OPTIMAL(N_ROUNDS)\n    \n    \n    \n    \n    IMPLICIT NONE\n\n    INTEGER, INTENT(IN) :: N_ROUNDS\n\n    INTEGER :: ROUND, PRISONER, CHOICE, I   \n    INTEGER :: CURRENT_DRAW                 \n    INTEGER :: N_SUCCESSES                  \n    REAL(8) :: TOTAL                        \n    LOGICAL :: NUM_FOUND = .FALSE.          \n    INTEGER, DIMENSION(100) :: CARDS        \n\n    \n    \n    CARDS = (/(I, I=1, 100, 1)/)\n\n    N_SUCCESSES = 0\n    TOTAL = REAL(N_ROUNDS)\n\n    \n    \n    \n    \n    ROUNDS_LOOP: DO ROUND=1, N_ROUNDS\n        CARDS = (/(I, I=1, 100, 1)/)\n        CALL SHUFFLE_ARRAY(CARDS)\n        PRISONERS_LOOP: DO PRISONER=1, 100\n            CURRENT_DRAW = PRISONER\n            NUM_FOUND = .FALSE.\n            CHOICE_LOOP: DO CHOICE=1, 50\n                IF(CARDS(CURRENT_DRAW) == PRISONER) THEN\n                    NUM_FOUND = .TRUE.\n                    EXIT CHOICE_LOOP\n                ELSE\n                    CURRENT_DRAW = CARDS(CURRENT_DRAW)\n                ENDIF\n            ENDDO CHOICE_LOOP\n            IF(.NOT. NUM_FOUND) THEN\n                EXIT PRISONERS_LOOP\n            ENDIF\n        ENDDO PRISONERS_LOOP\n        IF(NUM_FOUND) THEN\n            N_SUCCESSES = N_SUCCESSES + 1\n        ENDIF\n    ENDDO ROUNDS_LOOP\n    WRITE(*, '(A, F0.3, A)') \"Optimal drawer selection method success rate: \", &\n        100*N_SUCCESSES/TOTAL, \"%\"\n\nEND SUBROUTINE RUN_OPTIMAL\n\nPROGRAM HUNDRED_PRISONERS\n    \n    \n    IMPLICIT NONE\n    INTEGER, PARAMETER :: N_ROUNDS = 50000\n    WRITE(*,'(A, I0, A)') \"Running simulation for \", N_ROUNDS, \" trials...\"\n    CALL RUN_RANDOM(N_ROUNDS)\n    CALL RUN_OPTIMAL(N_ROUNDS)\nEND PROGRAM HUNDRED_PRISONERS\n", "target": "import random\n\ndef play_random(n):\n    \n    pardoned = 0\n    in_drawer = list(range(100))\n    sampler = list(range(100))\n    for _round in range(n):\n        random.shuffle(in_drawer)\n        found = False\n        for prisoner in range(100):\n            found = False\n            for reveal in random.sample(sampler, 50):\n                card = in_drawer[reveal]\n                if card == prisoner:\n                    found = True\n                    break\n            if not found:\n                break\n        if found:\n            pardoned += 1\n    return pardoned / n * 100   \n\ndef play_optimal(n):\n    \n    pardoned = 0\n    in_drawer = list(range(100))\n    for _round in range(n):\n        random.shuffle(in_drawer)\n        for prisoner in range(100):\n            reveal = prisoner\n            found = False\n            for go in range(50):\n                card = in_drawer[reveal]\n                if card == prisoner:\n                    found = True\n                    break\n                reveal = card\n            if not found:\n                break\n        if found:\n            pardoned += 1\n    return pardoned / n * 100   \n\nif __name__ == '__main__':\n    n = 100_000\n    print(\" Simulation count:\", n)\n    print(f\" Random play wins: {play_random(n):4.1f}% of simulations\")\n    print(f\"Optimal play wins: {play_optimal(n):4.1f}% of simulations\")\n"}
{"id": 121118, "name": "Word wrap", "source": "Translate Fortran to C#:       CHARACTER*12345 TEXT\n       ...\n      DO I = 0,120\n        WRITE (6,*) TEXT(I*80 + 1:(I + 1)*80)\n      END DO\n", "target": "namespace RosettaCode.WordWrap\n{\n    using System;\n    using System.Collections.Generic;\n\n    internal static class Program\n    {\n        private const string LoremIpsum = @\"\nLorem ipsum dolor sit amet, consectetur adipiscing elit. Maecenas varius sapien\nvel purus hendrerit vehicula. Integer hendrerit viverra turpis, ac sagittis arcu\npharetra id. Sed dapibus enim non dui posuere sit amet rhoncus tellus\nconsectetur. Proin blandit lacus vitae nibh tincidunt cursus. Cum sociis natoque\npenatibus et magnis dis parturient montes, nascetur ridiculus mus. Nam tincidunt\npurus at tortor tincidunt et aliquam dui gravida. Nulla consectetur sem vel\nfelis vulputate et imperdiet orci pharetra. Nam vel tortor nisi. Sed eget porta\ntortor. Aliquam suscipit lacus vel odio faucibus tempor. Sed ipsum est,\ncondimentum eget eleifend ac, ultricies non dui. Integer tempus, nunc sed\nvenenatis feugiat, augue orci pellentesque risus, nec pretium lacus enim eu\nnibh.\";\n\n        private static void Main()\n        {\n            foreach (var lineWidth in new[] { 72, 80 })\n            {\n                Console.WriteLine(new string('-', lineWidth));\n                Console.WriteLine(Wrap(LoremIpsum, lineWidth));\n            }\n        }\n\n        private static string Wrap(string text, int lineWidth)\n        {\n            return string.Join(string.Empty,\n                               Wrap(\n                                   text.Split(new char[0],\n                                              StringSplitOptions\n                                                  .RemoveEmptyEntries),\n                                   lineWidth));\n        }\n\n        private static IEnumerable<string> Wrap(IEnumerable<string> words,\n                                                int lineWidth)\n        {\n            var currentWidth = 0;\n            foreach (var word in words)\n            {\n                if (currentWidth != 0)\n                {\n                    if (currentWidth + word.Length < lineWidth)\n                    {\n                        currentWidth++;\n                        yield return \" \";\n                    }\n                    else\n                    {\n                        currentWidth = 0;\n                        yield return Environment.NewLine;\n                    }\n                }\n                currentWidth += word.Length;\n                yield return word;\n            }\n        }\n    }\n}\n"}
{"id": 121119, "name": "Word wrap", "source": "Translate Fortran to C#:       CHARACTER*12345 TEXT\n       ...\n      DO I = 0,120\n        WRITE (6,*) TEXT(I*80 + 1:(I + 1)*80)\n      END DO\n", "target": "namespace RosettaCode.WordWrap\n{\n    using System;\n    using System.Collections.Generic;\n\n    internal static class Program\n    {\n        private const string LoremIpsum = @\"\nLorem ipsum dolor sit amet, consectetur adipiscing elit. Maecenas varius sapien\nvel purus hendrerit vehicula. Integer hendrerit viverra turpis, ac sagittis arcu\npharetra id. Sed dapibus enim non dui posuere sit amet rhoncus tellus\nconsectetur. Proin blandit lacus vitae nibh tincidunt cursus. Cum sociis natoque\npenatibus et magnis dis parturient montes, nascetur ridiculus mus. Nam tincidunt\npurus at tortor tincidunt et aliquam dui gravida. Nulla consectetur sem vel\nfelis vulputate et imperdiet orci pharetra. Nam vel tortor nisi. Sed eget porta\ntortor. Aliquam suscipit lacus vel odio faucibus tempor. Sed ipsum est,\ncondimentum eget eleifend ac, ultricies non dui. Integer tempus, nunc sed\nvenenatis feugiat, augue orci pellentesque risus, nec pretium lacus enim eu\nnibh.\";\n\n        private static void Main()\n        {\n            foreach (var lineWidth in new[] { 72, 80 })\n            {\n                Console.WriteLine(new string('-', lineWidth));\n                Console.WriteLine(Wrap(LoremIpsum, lineWidth));\n            }\n        }\n\n        private static string Wrap(string text, int lineWidth)\n        {\n            return string.Join(string.Empty,\n                               Wrap(\n                                   text.Split(new char[0],\n                                              StringSplitOptions\n                                                  .RemoveEmptyEntries),\n                                   lineWidth));\n        }\n\n        private static IEnumerable<string> Wrap(IEnumerable<string> words,\n                                                int lineWidth)\n        {\n            var currentWidth = 0;\n            foreach (var word in words)\n            {\n                if (currentWidth != 0)\n                {\n                    if (currentWidth + word.Length < lineWidth)\n                    {\n                        currentWidth++;\n                        yield return \" \";\n                    }\n                    else\n                    {\n                        currentWidth = 0;\n                        yield return Environment.NewLine;\n                    }\n                }\n                currentWidth += word.Length;\n                yield return word;\n            }\n        }\n    }\n}\n"}
{"id": 121125, "name": "Word wrap", "source": "Translate Fortran to Java:       CHARACTER*12345 TEXT\n       ...\n      DO I = 0,120\n        WRITE (6,*) TEXT(I*80 + 1:(I + 1)*80)\n      END DO\n", "target": "package rosettacode;\n\nimport java.util.StringTokenizer;\n\npublic class WordWrap \n{\n    int defaultLineWidth=80;\n    int defaultSpaceWidth=1;\n    void minNumLinesWrap(String text)\n    {\n        minNumLinesWrap(text,defaultLineWidth);\n    }\n    void minNumLinesWrap(String text,int LineWidth)\n    {\n        StringTokenizer st=new StringTokenizer(text);\n        int SpaceLeft=LineWidth;\n        int SpaceWidth=defaultSpaceWidth;\n        while(st.hasMoreTokens())\n        {\n            String word=st.nextToken();\n            if((word.length()+SpaceWidth)>SpaceLeft)\n            {\n                System.out.print(\"\\n\"+word+\" \");\n                SpaceLeft=LineWidth-word.length();\n            }\n            else\n            {\n                System.out.print(word+\" \");\n                SpaceLeft-=(word.length()+SpaceWidth);\n            }\n        }\n    }\n    public static void main(String[] args)\n    {\n        WordWrap now=new WordWrap();\n        String wodehouse=\"Old Mr MacFarland (_said Henry_) started the place fifteen years ago. He was a widower with one son and what you might call half a daughter. That's to say, he had adopted her. Katie was her name, and she was the child of a dead friend of his. The son's name was Andy. A little freckled nipper he was when I first knew him--one of those silent kids that don't say much and have as much obstinacy in them as if they were mules. Many's the time, in them days, I've clumped him on the head and told him to do something; and he didn't run yelling to his pa, same as most kids would have done, but just said nothing and went on not doing whatever it was I had told him to do. That was the sort of disposition Andy had, and it grew on him. Why, when he came back from Oxford College the time the old man sent for him--what I'm going to tell you about soon--he had a jaw on him like the ram of a battleship. Katie was the kid for my money. I liked Katie. We all liked Katie.\";\n        System.out.println(\"DEFAULT:\");\n        now.minNumLinesWrap(wodehouse);\n        System.out.println(\"\\n\\nLINEWIDTH=120\");\n        now.minNumLinesWrap(wodehouse,120);\n    }\n\n}\n"}
{"id": 121126, "name": "Word wrap", "source": "Translate Fortran to Java:       CHARACTER*12345 TEXT\n       ...\n      DO I = 0,120\n        WRITE (6,*) TEXT(I*80 + 1:(I + 1)*80)\n      END DO\n", "target": "package rosettacode;\n\nimport java.util.StringTokenizer;\n\npublic class WordWrap \n{\n    int defaultLineWidth=80;\n    int defaultSpaceWidth=1;\n    void minNumLinesWrap(String text)\n    {\n        minNumLinesWrap(text,defaultLineWidth);\n    }\n    void minNumLinesWrap(String text,int LineWidth)\n    {\n        StringTokenizer st=new StringTokenizer(text);\n        int SpaceLeft=LineWidth;\n        int SpaceWidth=defaultSpaceWidth;\n        while(st.hasMoreTokens())\n        {\n            String word=st.nextToken();\n            if((word.length()+SpaceWidth)>SpaceLeft)\n            {\n                System.out.print(\"\\n\"+word+\" \");\n                SpaceLeft=LineWidth-word.length();\n            }\n            else\n            {\n                System.out.print(word+\" \");\n                SpaceLeft-=(word.length()+SpaceWidth);\n            }\n        }\n    }\n    public static void main(String[] args)\n    {\n        WordWrap now=new WordWrap();\n        String wodehouse=\"Old Mr MacFarland (_said Henry_) started the place fifteen years ago. He was a widower with one son and what you might call half a daughter. That's to say, he had adopted her. Katie was her name, and she was the child of a dead friend of his. The son's name was Andy. A little freckled nipper he was when I first knew him--one of those silent kids that don't say much and have as much obstinacy in them as if they were mules. Many's the time, in them days, I've clumped him on the head and told him to do something; and he didn't run yelling to his pa, same as most kids would have done, but just said nothing and went on not doing whatever it was I had told him to do. That was the sort of disposition Andy had, and it grew on him. Why, when he came back from Oxford College the time the old man sent for him--what I'm going to tell you about soon--he had a jaw on him like the ram of a battleship. Katie was the kid for my money. I liked Katie. We all liked Katie.\";\n        System.out.println(\"DEFAULT:\");\n        now.minNumLinesWrap(wodehouse);\n        System.out.println(\"\\n\\nLINEWIDTH=120\");\n        now.minNumLinesWrap(wodehouse,120);\n    }\n\n}\n"}
{"id": 121127, "name": "Word wrap", "source": "Translate Fortran to Python:       CHARACTER*12345 TEXT\n       ...\n      DO I = 0,120\n        WRITE (6,*) TEXT(I*80 + 1:(I + 1)*80)\n      END DO\n", "target": ">>> import textwrap\n>>> help(textwrap.fill)\nHelp on function fill in module textwrap:\n\nfill(text, width=70, **kwargs)\n    Fill a single paragraph of text, returning a new string.\n    \n    Reformat the single paragraph in 'text' to fit in lines of no more\n    than 'width' columns, and return a new string containing the entire\n    wrapped paragraph.  As with wrap(), tabs are expanded and other\n    whitespace characters converted to space.  See TextWrapper class for\n    available keyword args to customize wrapping behaviour.\n\n>>> txt = \n>>> print(textwrap.fill(txt, width=75))\nReformat the single paragraph in 'text' to fit in lines of no more than\n'width' columns, and return a new string containing the entire wrapped\nparagraph.  As with wrap(), tabs are expanded and other whitespace\ncharacters converted to space.  See TextWrapper class for available keyword\nargs to customize wrapping behaviour.\n>>> print(textwrap.fill(txt, width=45))\nReformat the single paragraph in 'text' to\nfit in lines of no more than 'width' columns,\nand return a new string containing the entire\nwrapped paragraph.  As with wrap(), tabs are\nexpanded and other whitespace characters\nconverted to space.  See TextWrapper class\nfor available keyword args to customize\nwrapping behaviour.\n>>> print(textwrap.fill(txt, width=85))\nReformat the single paragraph in 'text' to fit in lines of no more than 'width'\ncolumns, and return a new string containing the entire wrapped paragraph.  As with\nwrap(), tabs are expanded and other whitespace characters converted to space.  See\nTextWrapper class for available keyword args to customize wrapping behaviour.\n>>>\n"}
{"id": 121128, "name": "Word wrap", "source": "Translate Fortran to Python:       CHARACTER*12345 TEXT\n       ...\n      DO I = 0,120\n        WRITE (6,*) TEXT(I*80 + 1:(I + 1)*80)\n      END DO\n", "target": ">>> import textwrap\n>>> help(textwrap.fill)\nHelp on function fill in module textwrap:\n\nfill(text, width=70, **kwargs)\n    Fill a single paragraph of text, returning a new string.\n    \n    Reformat the single paragraph in 'text' to fit in lines of no more\n    than 'width' columns, and return a new string containing the entire\n    wrapped paragraph.  As with wrap(), tabs are expanded and other\n    whitespace characters converted to space.  See TextWrapper class for\n    available keyword args to customize wrapping behaviour.\n\n>>> txt = \n>>> print(textwrap.fill(txt, width=75))\nReformat the single paragraph in 'text' to fit in lines of no more than\n'width' columns, and return a new string containing the entire wrapped\nparagraph.  As with wrap(), tabs are expanded and other whitespace\ncharacters converted to space.  See TextWrapper class for available keyword\nargs to customize wrapping behaviour.\n>>> print(textwrap.fill(txt, width=45))\nReformat the single paragraph in 'text' to\nfit in lines of no more than 'width' columns,\nand return a new string containing the entire\nwrapped paragraph.  As with wrap(), tabs are\nexpanded and other whitespace characters\nconverted to space.  See TextWrapper class\nfor available keyword args to customize\nwrapping behaviour.\n>>> print(textwrap.fill(txt, width=85))\nReformat the single paragraph in 'text' to fit in lines of no more than 'width'\ncolumns, and return a new string containing the entire wrapped paragraph.  As with\nwrap(), tabs are expanded and other whitespace characters converted to space.  See\nTextWrapper class for available keyword args to customize wrapping behaviour.\n>>>\n"}
{"id": 121581, "name": "Harshad or Niven series", "source": "Translate Fortran to C#: \n\n\n\n\n\n\n\n\nprogram Harshad\n  integer :: i, h = 0\n  do i=1, 20\n    call nextHarshad(h)\n    write(6, '(i5)', advance='no') h\n  enddo\n  h = 1000\n  call nextHarshad(h)\n  write(6, '(i5)') h\n\ncontains\n\n  subroutine nextHarshad(h) \n    integer, intent(inout) :: h\n    h = h+1 \n    do while (.not. isHarshad(h))\n      h = h+1\n    end do\n  end subroutine nextHarshad\n\n  logical function isHarshad(a)\n    integer, intent(in) :: a\n    integer :: mutable, digit_sum\n    isHarshad = .false.\n    if (a .lt. 1) return \n    mutable = a\n    digit_sum = 0\n    do while (mutable /= 0)\n      digit_sum = digit_sum + mod(mutable, 10)\n      mutable = mutable / 10\n    end do\n    isHarshad = 0 .eq. mod(a, digit_sum)\n  end function isHarshad\n\nend program Harshad\n", "target": "using System;\nusing System.Collections.Generic;\n\nnamespace Harshad\n{\n    class Program\n    {\n        public static bool IsHarshad(int n)\n        {\n            char[] inputChars = n.ToString().ToCharArray();\n            IList<byte> digits = new List<byte>();\n\n            foreach (char digit in inputChars)\n            {\n                digits.Add((byte)Char.GetNumericValue(digit));\n            }\n\n            if (n < 1)\n            {\n                return false;\n            }\n\n            int sum = 0;\n\n            foreach (byte digit in digits)\n            {\n                sum += digit;\n            }\n\n            return n % sum == 0;\n        }\n\n        static void Main(string[] args)\n        {\n            int i = 1;\n            int count = 0;\n\n            while (true)\n            {\n                if (IsHarshad(i))\n                {\n                    count++;\n\n                    if (count <= 20)\n                    {\n                        Console.Write(string.Format(\"{0} \", i));\n                    }\n                    else if (i > 1000)\n                    {\n                        Console.Write(string.Format(\"{0} \", i));\n                        break;\n                    }\n                }\n\n                i++;\n            }\n\n            Console.ReadKey();\n        }\n    }\n}\n"}
{"id": 121582, "name": "Harshad or Niven series", "source": "Translate Fortran to C#: \n\n\n\n\n\n\n\n\nprogram Harshad\n  integer :: i, h = 0\n  do i=1, 20\n    call nextHarshad(h)\n    write(6, '(i5)', advance='no') h\n  enddo\n  h = 1000\n  call nextHarshad(h)\n  write(6, '(i5)') h\n\ncontains\n\n  subroutine nextHarshad(h) \n    integer, intent(inout) :: h\n    h = h+1 \n    do while (.not. isHarshad(h))\n      h = h+1\n    end do\n  end subroutine nextHarshad\n\n  logical function isHarshad(a)\n    integer, intent(in) :: a\n    integer :: mutable, digit_sum\n    isHarshad = .false.\n    if (a .lt. 1) return \n    mutable = a\n    digit_sum = 0\n    do while (mutable /= 0)\n      digit_sum = digit_sum + mod(mutable, 10)\n      mutable = mutable / 10\n    end do\n    isHarshad = 0 .eq. mod(a, digit_sum)\n  end function isHarshad\n\nend program Harshad\n", "target": "using System;\nusing System.Collections.Generic;\n\nnamespace Harshad\n{\n    class Program\n    {\n        public static bool IsHarshad(int n)\n        {\n            char[] inputChars = n.ToString().ToCharArray();\n            IList<byte> digits = new List<byte>();\n\n            foreach (char digit in inputChars)\n            {\n                digits.Add((byte)Char.GetNumericValue(digit));\n            }\n\n            if (n < 1)\n            {\n                return false;\n            }\n\n            int sum = 0;\n\n            foreach (byte digit in digits)\n            {\n                sum += digit;\n            }\n\n            return n % sum == 0;\n        }\n\n        static void Main(string[] args)\n        {\n            int i = 1;\n            int count = 0;\n\n            while (true)\n            {\n                if (IsHarshad(i))\n                {\n                    count++;\n\n                    if (count <= 20)\n                    {\n                        Console.Write(string.Format(\"{0} \", i));\n                    }\n                    else if (i > 1000)\n                    {\n                        Console.Write(string.Format(\"{0} \", i));\n                        break;\n                    }\n                }\n\n                i++;\n            }\n\n            Console.ReadKey();\n        }\n    }\n}\n"}
{"id": 121588, "name": "Harshad or Niven series", "source": "Translate Fortran to Java: \n\n\n\n\n\n\n\n\nprogram Harshad\n  integer :: i, h = 0\n  do i=1, 20\n    call nextHarshad(h)\n    write(6, '(i5)', advance='no') h\n  enddo\n  h = 1000\n  call nextHarshad(h)\n  write(6, '(i5)') h\n\ncontains\n\n  subroutine nextHarshad(h) \n    integer, intent(inout) :: h\n    h = h+1 \n    do while (.not. isHarshad(h))\n      h = h+1\n    end do\n  end subroutine nextHarshad\n\n  logical function isHarshad(a)\n    integer, intent(in) :: a\n    integer :: mutable, digit_sum\n    isHarshad = .false.\n    if (a .lt. 1) return \n    mutable = a\n    digit_sum = 0\n    do while (mutable /= 0)\n      digit_sum = digit_sum + mod(mutable, 10)\n      mutable = mutable / 10\n    end do\n    isHarshad = 0 .eq. mod(a, digit_sum)\n  end function isHarshad\n\nend program Harshad\n", "target": "public class Harshad{\n    private static long sumDigits(long n){\n        long sum = 0;\n        for(char digit:Long.toString(n).toCharArray()){\n            sum += Character.digit(digit, 10);\n        }\n        return sum;\n    }\n    public static void main(String[] args){\n        for(int count = 0, i = 1; count < 20;i++){\n            if(i % sumDigits(i) == 0){\n                System.out.println(i);\n                count++;\n            }\n        }\n        System.out.println();\n        for(int i = 1001; ; i++){\n            if(i % sumDigits(i) == 0){\n                System.out.println(i);\n                break;\n            }\n        }\n    }\n}\n"}
{"id": 121589, "name": "Harshad or Niven series", "source": "Translate Fortran to Java: \n\n\n\n\n\n\n\n\nprogram Harshad\n  integer :: i, h = 0\n  do i=1, 20\n    call nextHarshad(h)\n    write(6, '(i5)', advance='no') h\n  enddo\n  h = 1000\n  call nextHarshad(h)\n  write(6, '(i5)') h\n\ncontains\n\n  subroutine nextHarshad(h) \n    integer, intent(inout) :: h\n    h = h+1 \n    do while (.not. isHarshad(h))\n      h = h+1\n    end do\n  end subroutine nextHarshad\n\n  logical function isHarshad(a)\n    integer, intent(in) :: a\n    integer :: mutable, digit_sum\n    isHarshad = .false.\n    if (a .lt. 1) return \n    mutable = a\n    digit_sum = 0\n    do while (mutable /= 0)\n      digit_sum = digit_sum + mod(mutable, 10)\n      mutable = mutable / 10\n    end do\n    isHarshad = 0 .eq. mod(a, digit_sum)\n  end function isHarshad\n\nend program Harshad\n", "target": "public class Harshad{\n    private static long sumDigits(long n){\n        long sum = 0;\n        for(char digit:Long.toString(n).toCharArray()){\n            sum += Character.digit(digit, 10);\n        }\n        return sum;\n    }\n    public static void main(String[] args){\n        for(int count = 0, i = 1; count < 20;i++){\n            if(i % sumDigits(i) == 0){\n                System.out.println(i);\n                count++;\n            }\n        }\n        System.out.println();\n        for(int i = 1001; ; i++){\n            if(i % sumDigits(i) == 0){\n                System.out.println(i);\n                break;\n            }\n        }\n    }\n}\n"}
{"id": 121590, "name": "Harshad or Niven series", "source": "Translate Fortran to Python: \n\n\n\n\n\n\n\n\nprogram Harshad\n  integer :: i, h = 0\n  do i=1, 20\n    call nextHarshad(h)\n    write(6, '(i5)', advance='no') h\n  enddo\n  h = 1000\n  call nextHarshad(h)\n  write(6, '(i5)') h\n\ncontains\n\n  subroutine nextHarshad(h) \n    integer, intent(inout) :: h\n    h = h+1 \n    do while (.not. isHarshad(h))\n      h = h+1\n    end do\n  end subroutine nextHarshad\n\n  logical function isHarshad(a)\n    integer, intent(in) :: a\n    integer :: mutable, digit_sum\n    isHarshad = .false.\n    if (a .lt. 1) return \n    mutable = a\n    digit_sum = 0\n    do while (mutable /= 0)\n      digit_sum = digit_sum + mod(mutable, 10)\n      mutable = mutable / 10\n    end do\n    isHarshad = 0 .eq. mod(a, digit_sum)\n  end function isHarshad\n\nend program Harshad\n", "target": ">>> import itertools\n>>> def harshad():\n\tfor n in itertools.count(1):\n\t\tif n % sum(int(ch) for ch in str(n)) == 0:\n\t\t\tyield n\n\n\t\t\n>>> list(itertools.islice(harshad(), 0, 20))\n[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 12, 18, 20, 21, 24, 27, 30, 36, 40, 42]\n>>> for n in harshad():\n\tif n > 1000:\n\t\tprint(n)\n\t\tbreak\n\n\t\n1002\n>>>\n"}
{"id": 121591, "name": "Harshad or Niven series", "source": "Translate Fortran to Python: \n\n\n\n\n\n\n\n\nprogram Harshad\n  integer :: i, h = 0\n  do i=1, 20\n    call nextHarshad(h)\n    write(6, '(i5)', advance='no') h\n  enddo\n  h = 1000\n  call nextHarshad(h)\n  write(6, '(i5)') h\n\ncontains\n\n  subroutine nextHarshad(h) \n    integer, intent(inout) :: h\n    h = h+1 \n    do while (.not. isHarshad(h))\n      h = h+1\n    end do\n  end subroutine nextHarshad\n\n  logical function isHarshad(a)\n    integer, intent(in) :: a\n    integer :: mutable, digit_sum\n    isHarshad = .false.\n    if (a .lt. 1) return \n    mutable = a\n    digit_sum = 0\n    do while (mutable /= 0)\n      digit_sum = digit_sum + mod(mutable, 10)\n      mutable = mutable / 10\n    end do\n    isHarshad = 0 .eq. mod(a, digit_sum)\n  end function isHarshad\n\nend program Harshad\n", "target": ">>> import itertools\n>>> def harshad():\n\tfor n in itertools.count(1):\n\t\tif n % sum(int(ch) for ch in str(n)) == 0:\n\t\t\tyield n\n\n\t\t\n>>> list(itertools.islice(harshad(), 0, 20))\n[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 12, 18, 20, 21, 24, 27, 30, 36, 40, 42]\n>>> for n in harshad():\n\tif n > 1000:\n\t\tprint(n)\n\t\tbreak\n\n\t\n1002\n>>>\n"}
{"id": 121940, "name": "Arithmetic_Rational", "source": "Translate Fortran to C#: module module_rational\n\n  implicit none\n  private\n  public :: rational\n  public :: rational_simplify\n  public :: assignment (=)\n  public :: operator (//)\n  public :: operator (+)\n  public :: operator (-)\n  public :: operator (*)\n  public :: operator (/)\n  public :: operator (<)\n  public :: operator (<=)\n  public :: operator (>)\n  public :: operator (>=)\n  public :: operator (==)\n  public :: operator (/=)\n  public :: abs\n  public :: int\n  public :: modulo\n  type rational\n    integer :: numerator\n    integer :: denominator\n  end type rational\n  interface assignment (=)\n    module procedure assign_rational_int, assign_rational_real\n  end interface\n  interface operator (//)\n    module procedure make_rational\n  end interface\n  interface operator (+)\n    module procedure rational_add\n  end interface\n  interface operator (-)\n    module procedure rational_minus, rational_subtract\n  end interface\n  interface operator (*)\n    module procedure rational_multiply\n  end interface\n  interface operator (/)\n    module procedure rational_divide\n  end interface\n  interface operator (<)\n    module procedure rational_lt\n  end interface\n  interface operator (<=)\n    module procedure rational_le\n  end interface\n  interface operator (>)\n    module procedure rational_gt\n  end interface\n  interface operator (>=)\n    module procedure rational_ge\n  end interface\n  interface operator (==)\n    module procedure rational_eq\n  end interface\n  interface operator (/=)\n    module procedure rational_ne\n  end interface\n  interface abs\n    module procedure rational_abs\n  end interface\n  interface int\n    module procedure rational_int\n  end interface\n  interface modulo\n    module procedure rational_modulo\n  end interface\n\ncontains\n\n  recursive function gcd (i, j) result (res)\n    integer, intent (in) :: i\n    integer, intent (in) :: j\n    integer :: res\n    if (j == 0) then\n      res = i\n    else\n      res = gcd (j, modulo (i, j))\n    end if\n  end function gcd\n\n  function rational_simplify (r) result (res)\n    type (rational), intent (in) :: r\n    type (rational) :: res\n    integer :: g\n    g = gcd (r % numerator, r % denominator)\n    res = r % numerator / g // r % denominator / g\n  end function rational_simplify\n\n  function make_rational (numerator, denominator) result (res)\n    integer, intent (in) :: numerator\n    integer, intent (in) :: denominator\n    type (rational) :: res\n    res = rational (numerator, denominator)\n  end function make_rational\n\n  subroutine assign_rational_int (res, i)\n    type (rational), intent (out), volatile :: res\n    integer, intent (in) :: i\n    res = i // 1\n  end subroutine assign_rational_int\n\n  subroutine assign_rational_real (res, x)\n    type (rational), intent(out), volatile :: res\n    real, intent (in) :: x\n    integer :: x_floor\n    real :: x_frac\n    x_floor = floor (x)\n    x_frac = x - x_floor\n    if (x_frac == 0) then\n      res = x_floor // 1\n    else\n      res = (x_floor // 1) + (1 // floor (1 / x_frac))\n    end if\n  end subroutine assign_rational_real\n\n  function rational_add (r, s) result (res)\n    type (rational), intent (in) :: r\n    type (rational), intent (in) :: s\n    type (rational) :: res\n    res = r % numerator * s % denominator + r % denominator * s % numerator // &\n        & r % denominator * s % denominator\n  end function rational_add\n\n  function rational_minus (r) result (res)\n    type (rational), intent (in) :: r\n    type (rational) :: res\n    res = - r % numerator // r % denominator\n  end function rational_minus\n\n  function rational_subtract (r, s) result (res)\n    type (rational), intent (in) :: r\n    type (rational), intent (in) :: s\n    type (rational) :: res\n    res = r % numerator * s % denominator - r % denominator * s % numerator // &\n        & r % denominator * s % denominator\n  end function rational_subtract\n\n  function rational_multiply (r, s) result (res)\n    type (rational), intent (in) :: r\n    type (rational), intent (in) :: s\n    type (rational) :: res\n    res = r % numerator * s % numerator // r % denominator * s % denominator\n  end function rational_multiply\n\n  function rational_divide (r, s) result (res)\n    type (rational), intent (in) :: r\n    type (rational), intent (in) :: s\n    type (rational) :: res\n    res = r % numerator * s % denominator // r % denominator * s % numerator\n  end function rational_divide\n\n  function rational_lt (r, s) result (res)\n    type (rational), intent (in) :: r\n    type (rational), intent (in) :: s\n    type (rational) :: r_simple\n    type (rational) :: s_simple\n    logical :: res\n    r_simple = rational_simplify (r)\n    s_simple = rational_simplify (s)\n    res = r_simple % numerator * s_simple % denominator < &\n        & s_simple % numerator * r_simple % denominator\n  end function rational_lt\n\n  function rational_le (r, s) result (res)\n    type (rational), intent (in) :: r\n    type (rational), intent (in) :: s\n    type (rational) :: r_simple\n    type (rational) :: s_simple\n    logical :: res\n    r_simple = rational_simplify (r)\n    s_simple = rational_simplify (s)\n    res = r_simple % numerator * s_simple % denominator <= &\n        & s_simple % numerator * r_simple % denominator\n  end function rational_le\n\n  function rational_gt (r, s) result (res)\n    type (rational), intent (in) :: r\n    type (rational), intent (in) :: s\n    type (rational) :: r_simple\n    type (rational) :: s_simple\n    logical :: res\n    r_simple = rational_simplify (r)\n    s_simple = rational_simplify (s)\n    res = r_simple % numerator * s_simple % denominator > &\n        & s_simple % numerator * r_simple % denominator\n  end function rational_gt\n\n  function rational_ge (r, s) result (res)\n    type (rational), intent (in) :: r\n    type (rational), intent (in) :: s\n    type (rational) :: r_simple\n    type (rational) :: s_simple\n    logical :: res\n    r_simple = rational_simplify (r)\n    s_simple = rational_simplify (s)\n    res = r_simple % numerator * s_simple % denominator >= &\n        & s_simple % numerator * r_simple % denominator\n  end function rational_ge\n\n  function rational_eq (r, s) result (res)\n    type (rational), intent (in) :: r\n    type (rational), intent (in) :: s\n    logical :: res\n    res = r % numerator * s % denominator == s % numerator * r % denominator\n  end function rational_eq\n\n  function rational_ne (r, s) result (res)\n    type (rational), intent (in) :: r\n    type (rational), intent (in) :: s\n    logical :: res\n    res = r % numerator * s % denominator /= s % numerator * r % denominator\n  end function rational_ne\n\n  function rational_abs (r) result (res)\n    type (rational), intent (in) :: r\n    type (rational) :: res\n    res = sign (r % numerator, r % denominator) // r % denominator\n  end function rational_abs\n\n  function rational_int (r) result (res)\n    type (rational), intent (in) :: r\n    integer :: res\n    res = r % numerator / r % denominator\n  end function rational_int\n\n  function rational_modulo (r) result (res)\n    type (rational), intent (in) :: r\n    integer :: res\n    res = modulo (r % numerator, r % denominator)\n  end function rational_modulo\n\nend module module_rational\n", "target": "using System;\n\nstruct Fraction : IEquatable<Fraction>, IComparable<Fraction>\n{\n    public readonly long Num;\n    public readonly long Denom;\n\n    public Fraction(long num, long denom)\n    {\n        if (num == 0)\n        {\n            denom = 1;\n        }\n        else if (denom == 0)\n        {\n            throw new ArgumentException(\"Denominator may not be zero\", \"denom\");\n        }\n        else if (denom < 0)\n        {\n            num = -num;\n            denom = -denom;\n        }\n\n        long d = GCD(num, denom);\n        this.Num = num / d;\n        this.Denom = denom / d;\n    }\n\n    private static long GCD(long x, long y)\n    {\n        return y == 0 ? x : GCD(y, x % y);\n    }\n\n    private static long LCM(long x, long y)\n    {\n        return x / GCD(x, y) * y;\n    }\n\n    public Fraction Abs()\n    {\n        return new Fraction(Math.Abs(Num), Denom);\n    }\n\n    public Fraction Reciprocal()\n    {\n        return new Fraction(Denom, Num);\n    }\n\n    #region Conversion Operators\n\n    public static implicit operator Fraction(long i)\n    {\n        return new Fraction(i, 1);\n    }\n\n    public static explicit operator double(Fraction f)\n    {\n        return f.Num == 0 ? 0 : (double)f.Num / f.Denom;\n    }\n\n    #endregion\n\n    #region Arithmetic Operators\n\n    public static Fraction operator -(Fraction f)\n    {\n        return new Fraction(-f.Num, f.Denom);\n    }\n\n    public static Fraction operator +(Fraction a, Fraction b)\n    {\n        long m = LCM(a.Denom, b.Denom);\n        long na = a.Num * m / a.Denom;\n        long nb = b.Num * m / b.Denom;\n        return new Fraction(na + nb, m);\n    }\n\n    public static Fraction operator -(Fraction a, Fraction b)\n    {\n        return a + (-b);\n    }\n\n    public static Fraction operator *(Fraction a, Fraction b)\n    {\n        return new Fraction(a.Num * b.Num, a.Denom * b.Denom);\n    }\n\n    public static Fraction operator /(Fraction a, Fraction b)\n    {\n        return a * b.Reciprocal();\n    }\n\n    public static Fraction operator %(Fraction a, Fraction b)\n    {\n        long l = a.Num * b.Denom, r = a.Denom * b.Num;\n        long n = l / r;\n        return new Fraction(l - n * r, a.Denom * b.Denom);\n    }\n\n    #endregion\n\n    #region Comparison Operators\n\n    public static bool operator ==(Fraction a, Fraction b)\n    {\n        return a.Num == b.Num && a.Denom == b.Denom;\n    }\n\n    public static bool operator !=(Fraction a, Fraction b)\n    {\n        return a.Num != b.Num || a.Denom != b.Denom;\n    }\n\n    public static bool operator <(Fraction a, Fraction b)\n    {\n        return (a.Num * b.Denom) < (a.Denom * b.Num);\n    }\n\n    public static bool operator >(Fraction a, Fraction b)\n    {\n        return (a.Num * b.Denom) > (a.Denom * b.Num);\n    }\n\n    public static bool operator <=(Fraction a, Fraction b)\n    {\n        return !(a > b);\n    }\n\n    public static bool operator >=(Fraction a, Fraction b)\n    {\n        return !(a < b);\n    }\n\n    #endregion\n\n    #region Object Members\n\n    public override bool Equals(object obj)\n    {\n        if (obj is Fraction)\n            return ((Fraction)obj) == this;\n        else\n            return false;\n    }\n\n    public override int GetHashCode()\n    {\n        return Num.GetHashCode() ^ Denom.GetHashCode();\n    }\n\n    public override string ToString()\n    {\n        return Num.ToString() + \"/\" + Denom.ToString();\n    }\n\n    #endregion\n\n    #region IEquatable<Fraction> Members\n\n    public bool Equals(Fraction other)\n    {\n        return other == this;\n    }\n\n    #endregion\n\n    #region IComparable<Fraction> Members\n\n    public int CompareTo(Fraction other)\n    {\n        return (this.Num * other.Denom).CompareTo(this.Denom * other.Num);\n    }\n\n    #endregion\n}\n"}
{"id": 121943, "name": "Arithmetic_Rational", "source": "Translate Fortran to Java: module module_rational\n\n  implicit none\n  private\n  public :: rational\n  public :: rational_simplify\n  public :: assignment (=)\n  public :: operator (//)\n  public :: operator (+)\n  public :: operator (-)\n  public :: operator (*)\n  public :: operator (/)\n  public :: operator (<)\n  public :: operator (<=)\n  public :: operator (>)\n  public :: operator (>=)\n  public :: operator (==)\n  public :: operator (/=)\n  public :: abs\n  public :: int\n  public :: modulo\n  type rational\n    integer :: numerator\n    integer :: denominator\n  end type rational\n  interface assignment (=)\n    module procedure assign_rational_int, assign_rational_real\n  end interface\n  interface operator (//)\n    module procedure make_rational\n  end interface\n  interface operator (+)\n    module procedure rational_add\n  end interface\n  interface operator (-)\n    module procedure rational_minus, rational_subtract\n  end interface\n  interface operator (*)\n    module procedure rational_multiply\n  end interface\n  interface operator (/)\n    module procedure rational_divide\n  end interface\n  interface operator (<)\n    module procedure rational_lt\n  end interface\n  interface operator (<=)\n    module procedure rational_le\n  end interface\n  interface operator (>)\n    module procedure rational_gt\n  end interface\n  interface operator (>=)\n    module procedure rational_ge\n  end interface\n  interface operator (==)\n    module procedure rational_eq\n  end interface\n  interface operator (/=)\n    module procedure rational_ne\n  end interface\n  interface abs\n    module procedure rational_abs\n  end interface\n  interface int\n    module procedure rational_int\n  end interface\n  interface modulo\n    module procedure rational_modulo\n  end interface\n\ncontains\n\n  recursive function gcd (i, j) result (res)\n    integer, intent (in) :: i\n    integer, intent (in) :: j\n    integer :: res\n    if (j == 0) then\n      res = i\n    else\n      res = gcd (j, modulo (i, j))\n    end if\n  end function gcd\n\n  function rational_simplify (r) result (res)\n    type (rational), intent (in) :: r\n    type (rational) :: res\n    integer :: g\n    g = gcd (r % numerator, r % denominator)\n    res = r % numerator / g // r % denominator / g\n  end function rational_simplify\n\n  function make_rational (numerator, denominator) result (res)\n    integer, intent (in) :: numerator\n    integer, intent (in) :: denominator\n    type (rational) :: res\n    res = rational (numerator, denominator)\n  end function make_rational\n\n  subroutine assign_rational_int (res, i)\n    type (rational), intent (out), volatile :: res\n    integer, intent (in) :: i\n    res = i // 1\n  end subroutine assign_rational_int\n\n  subroutine assign_rational_real (res, x)\n    type (rational), intent(out), volatile :: res\n    real, intent (in) :: x\n    integer :: x_floor\n    real :: x_frac\n    x_floor = floor (x)\n    x_frac = x - x_floor\n    if (x_frac == 0) then\n      res = x_floor // 1\n    else\n      res = (x_floor // 1) + (1 // floor (1 / x_frac))\n    end if\n  end subroutine assign_rational_real\n\n  function rational_add (r, s) result (res)\n    type (rational), intent (in) :: r\n    type (rational), intent (in) :: s\n    type (rational) :: res\n    res = r % numerator * s % denominator + r % denominator * s % numerator // &\n        & r % denominator * s % denominator\n  end function rational_add\n\n  function rational_minus (r) result (res)\n    type (rational), intent (in) :: r\n    type (rational) :: res\n    res = - r % numerator // r % denominator\n  end function rational_minus\n\n  function rational_subtract (r, s) result (res)\n    type (rational), intent (in) :: r\n    type (rational), intent (in) :: s\n    type (rational) :: res\n    res = r % numerator * s % denominator - r % denominator * s % numerator // &\n        & r % denominator * s % denominator\n  end function rational_subtract\n\n  function rational_multiply (r, s) result (res)\n    type (rational), intent (in) :: r\n    type (rational), intent (in) :: s\n    type (rational) :: res\n    res = r % numerator * s % numerator // r % denominator * s % denominator\n  end function rational_multiply\n\n  function rational_divide (r, s) result (res)\n    type (rational), intent (in) :: r\n    type (rational), intent (in) :: s\n    type (rational) :: res\n    res = r % numerator * s % denominator // r % denominator * s % numerator\n  end function rational_divide\n\n  function rational_lt (r, s) result (res)\n    type (rational), intent (in) :: r\n    type (rational), intent (in) :: s\n    type (rational) :: r_simple\n    type (rational) :: s_simple\n    logical :: res\n    r_simple = rational_simplify (r)\n    s_simple = rational_simplify (s)\n    res = r_simple % numerator * s_simple % denominator < &\n        & s_simple % numerator * r_simple % denominator\n  end function rational_lt\n\n  function rational_le (r, s) result (res)\n    type (rational), intent (in) :: r\n    type (rational), intent (in) :: s\n    type (rational) :: r_simple\n    type (rational) :: s_simple\n    logical :: res\n    r_simple = rational_simplify (r)\n    s_simple = rational_simplify (s)\n    res = r_simple % numerator * s_simple % denominator <= &\n        & s_simple % numerator * r_simple % denominator\n  end function rational_le\n\n  function rational_gt (r, s) result (res)\n    type (rational), intent (in) :: r\n    type (rational), intent (in) :: s\n    type (rational) :: r_simple\n    type (rational) :: s_simple\n    logical :: res\n    r_simple = rational_simplify (r)\n    s_simple = rational_simplify (s)\n    res = r_simple % numerator * s_simple % denominator > &\n        & s_simple % numerator * r_simple % denominator\n  end function rational_gt\n\n  function rational_ge (r, s) result (res)\n    type (rational), intent (in) :: r\n    type (rational), intent (in) :: s\n    type (rational) :: r_simple\n    type (rational) :: s_simple\n    logical :: res\n    r_simple = rational_simplify (r)\n    s_simple = rational_simplify (s)\n    res = r_simple % numerator * s_simple % denominator >= &\n        & s_simple % numerator * r_simple % denominator\n  end function rational_ge\n\n  function rational_eq (r, s) result (res)\n    type (rational), intent (in) :: r\n    type (rational), intent (in) :: s\n    logical :: res\n    res = r % numerator * s % denominator == s % numerator * r % denominator\n  end function rational_eq\n\n  function rational_ne (r, s) result (res)\n    type (rational), intent (in) :: r\n    type (rational), intent (in) :: s\n    logical :: res\n    res = r % numerator * s % denominator /= s % numerator * r % denominator\n  end function rational_ne\n\n  function rational_abs (r) result (res)\n    type (rational), intent (in) :: r\n    type (rational) :: res\n    res = sign (r % numerator, r % denominator) // r % denominator\n  end function rational_abs\n\n  function rational_int (r) result (res)\n    type (rational), intent (in) :: r\n    integer :: res\n    res = r % numerator / r % denominator\n  end function rational_int\n\n  function rational_modulo (r) result (res)\n    type (rational), intent (in) :: r\n    integer :: res\n    res = modulo (r % numerator, r % denominator)\n  end function rational_modulo\n\nend module module_rational\n", "target": "public class BigRationalFindPerfectNumbers {\n    public static void main(String[] args) {\n        int MAX_NUM = 1 << 19;\n        System.out.println(\"Searching for perfect numbers in the range [1, \" + (MAX_NUM - 1) + \"]\");\n\n        BigRational TWO = BigRational.valueOf(2);\n        for (int i = 1; i < MAX_NUM; i++) {\n            BigRational reciprocalSum = BigRational.ONE;\n            if (i > 1)\n                reciprocalSum = reciprocalSum.add(BigRational.valueOf(i).reciprocal());\n            int maxDivisor = (int) Math.sqrt(i);\n            if (maxDivisor >= i)\n                maxDivisor--;\n\n            for (int divisor = 2; divisor <= maxDivisor; divisor++) {\n                if (i % divisor == 0) {\n                    reciprocalSum = reciprocalSum.add(BigRational.valueOf(divisor).reciprocal());\n                    int dividend = i / divisor;\n                    if (divisor != dividend)\n                        reciprocalSum = reciprocalSum.add(BigRational.valueOf(dividend).reciprocal());\n                }\n            }\n            if (reciprocalSum.equals(TWO))\n                System.out.println(String.valueOf(i) + \" is a perfect number\");\n        }\n    }\n}\n"}
{"id": 121944, "name": "Arithmetic_Rational", "source": "Translate Fortran to Python: module module_rational\n\n  implicit none\n  private\n  public :: rational\n  public :: rational_simplify\n  public :: assignment (=)\n  public :: operator (//)\n  public :: operator (+)\n  public :: operator (-)\n  public :: operator (*)\n  public :: operator (/)\n  public :: operator (<)\n  public :: operator (<=)\n  public :: operator (>)\n  public :: operator (>=)\n  public :: operator (==)\n  public :: operator (/=)\n  public :: abs\n  public :: int\n  public :: modulo\n  type rational\n    integer :: numerator\n    integer :: denominator\n  end type rational\n  interface assignment (=)\n    module procedure assign_rational_int, assign_rational_real\n  end interface\n  interface operator (//)\n    module procedure make_rational\n  end interface\n  interface operator (+)\n    module procedure rational_add\n  end interface\n  interface operator (-)\n    module procedure rational_minus, rational_subtract\n  end interface\n  interface operator (*)\n    module procedure rational_multiply\n  end interface\n  interface operator (/)\n    module procedure rational_divide\n  end interface\n  interface operator (<)\n    module procedure rational_lt\n  end interface\n  interface operator (<=)\n    module procedure rational_le\n  end interface\n  interface operator (>)\n    module procedure rational_gt\n  end interface\n  interface operator (>=)\n    module procedure rational_ge\n  end interface\n  interface operator (==)\n    module procedure rational_eq\n  end interface\n  interface operator (/=)\n    module procedure rational_ne\n  end interface\n  interface abs\n    module procedure rational_abs\n  end interface\n  interface int\n    module procedure rational_int\n  end interface\n  interface modulo\n    module procedure rational_modulo\n  end interface\n\ncontains\n\n  recursive function gcd (i, j) result (res)\n    integer, intent (in) :: i\n    integer, intent (in) :: j\n    integer :: res\n    if (j == 0) then\n      res = i\n    else\n      res = gcd (j, modulo (i, j))\n    end if\n  end function gcd\n\n  function rational_simplify (r) result (res)\n    type (rational), intent (in) :: r\n    type (rational) :: res\n    integer :: g\n    g = gcd (r % numerator, r % denominator)\n    res = r % numerator / g // r % denominator / g\n  end function rational_simplify\n\n  function make_rational (numerator, denominator) result (res)\n    integer, intent (in) :: numerator\n    integer, intent (in) :: denominator\n    type (rational) :: res\n    res = rational (numerator, denominator)\n  end function make_rational\n\n  subroutine assign_rational_int (res, i)\n    type (rational), intent (out), volatile :: res\n    integer, intent (in) :: i\n    res = i // 1\n  end subroutine assign_rational_int\n\n  subroutine assign_rational_real (res, x)\n    type (rational), intent(out), volatile :: res\n    real, intent (in) :: x\n    integer :: x_floor\n    real :: x_frac\n    x_floor = floor (x)\n    x_frac = x - x_floor\n    if (x_frac == 0) then\n      res = x_floor // 1\n    else\n      res = (x_floor // 1) + (1 // floor (1 / x_frac))\n    end if\n  end subroutine assign_rational_real\n\n  function rational_add (r, s) result (res)\n    type (rational), intent (in) :: r\n    type (rational), intent (in) :: s\n    type (rational) :: res\n    res = r % numerator * s % denominator + r % denominator * s % numerator // &\n        & r % denominator * s % denominator\n  end function rational_add\n\n  function rational_minus (r) result (res)\n    type (rational), intent (in) :: r\n    type (rational) :: res\n    res = - r % numerator // r % denominator\n  end function rational_minus\n\n  function rational_subtract (r, s) result (res)\n    type (rational), intent (in) :: r\n    type (rational), intent (in) :: s\n    type (rational) :: res\n    res = r % numerator * s % denominator - r % denominator * s % numerator // &\n        & r % denominator * s % denominator\n  end function rational_subtract\n\n  function rational_multiply (r, s) result (res)\n    type (rational), intent (in) :: r\n    type (rational), intent (in) :: s\n    type (rational) :: res\n    res = r % numerator * s % numerator // r % denominator * s % denominator\n  end function rational_multiply\n\n  function rational_divide (r, s) result (res)\n    type (rational), intent (in) :: r\n    type (rational), intent (in) :: s\n    type (rational) :: res\n    res = r % numerator * s % denominator // r % denominator * s % numerator\n  end function rational_divide\n\n  function rational_lt (r, s) result (res)\n    type (rational), intent (in) :: r\n    type (rational), intent (in) :: s\n    type (rational) :: r_simple\n    type (rational) :: s_simple\n    logical :: res\n    r_simple = rational_simplify (r)\n    s_simple = rational_simplify (s)\n    res = r_simple % numerator * s_simple % denominator < &\n        & s_simple % numerator * r_simple % denominator\n  end function rational_lt\n\n  function rational_le (r, s) result (res)\n    type (rational), intent (in) :: r\n    type (rational), intent (in) :: s\n    type (rational) :: r_simple\n    type (rational) :: s_simple\n    logical :: res\n    r_simple = rational_simplify (r)\n    s_simple = rational_simplify (s)\n    res = r_simple % numerator * s_simple % denominator <= &\n        & s_simple % numerator * r_simple % denominator\n  end function rational_le\n\n  function rational_gt (r, s) result (res)\n    type (rational), intent (in) :: r\n    type (rational), intent (in) :: s\n    type (rational) :: r_simple\n    type (rational) :: s_simple\n    logical :: res\n    r_simple = rational_simplify (r)\n    s_simple = rational_simplify (s)\n    res = r_simple % numerator * s_simple % denominator > &\n        & s_simple % numerator * r_simple % denominator\n  end function rational_gt\n\n  function rational_ge (r, s) result (res)\n    type (rational), intent (in) :: r\n    type (rational), intent (in) :: s\n    type (rational) :: r_simple\n    type (rational) :: s_simple\n    logical :: res\n    r_simple = rational_simplify (r)\n    s_simple = rational_simplify (s)\n    res = r_simple % numerator * s_simple % denominator >= &\n        & s_simple % numerator * r_simple % denominator\n  end function rational_ge\n\n  function rational_eq (r, s) result (res)\n    type (rational), intent (in) :: r\n    type (rational), intent (in) :: s\n    logical :: res\n    res = r % numerator * s % denominator == s % numerator * r % denominator\n  end function rational_eq\n\n  function rational_ne (r, s) result (res)\n    type (rational), intent (in) :: r\n    type (rational), intent (in) :: s\n    logical :: res\n    res = r % numerator * s % denominator /= s % numerator * r % denominator\n  end function rational_ne\n\n  function rational_abs (r) result (res)\n    type (rational), intent (in) :: r\n    type (rational) :: res\n    res = sign (r % numerator, r % denominator) // r % denominator\n  end function rational_abs\n\n  function rational_int (r) result (res)\n    type (rational), intent (in) :: r\n    integer :: res\n    res = r % numerator / r % denominator\n  end function rational_int\n\n  function rational_modulo (r) result (res)\n    type (rational), intent (in) :: r\n    integer :: res\n    res = modulo (r % numerator, r % denominator)\n  end function rational_modulo\n\nend module module_rational\n", "target": "from fractions import Fraction\n\nfor candidate in range(2, 2**19):\n  sum = Fraction(1, candidate)\n  for factor in range(2, int(candidate**0.5)+1):\n    if candidate % factor == 0:\n      sum += Fraction(1, factor) + Fraction(1, candidate // factor)\n  if sum.denominator == 1:\n    print(\"Sum of recipr. factors of %d = %d exactly %s\" %\n           (candidate, int(sum), \"perfect!\" if sum == 1 else \"\"))\n"}
{"id": 122203, "name": "Even or odd", "source": "Translate Fortran to C#: \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nmodule bit0parity\n\n  interface odd\n    module procedure odd_scalar, odd_list\n  end interface\n\n  interface even\n    module procedure even_scalar, even_list\n  end interface\n\ncontains\n\n  logical function odd_scalar(a)\n    implicit none\n    integer, intent(in) :: a\n    odd_scalar = btest(a, 0)\n  end function odd_scalar\n\n  logical function even_scalar(a)\n    implicit none\n    integer, intent(in) :: a\n    even_scalar = .not. odd_scalar(a)\n  end function even_scalar\n\n  function odd_list(a) result(rv)\n    implicit none\n    integer, dimension(:), intent(in) :: a\n    logical, dimension(size(a)) :: rv\n    rv = btest(a, 0)\n  end function odd_list\n\n  function even_list(a) result(rv)\n    implicit none\n    integer, dimension(:), intent(in) :: a\n    logical, dimension(size(a)) :: rv\n    rv = .not. odd_list(a)\n  end function even_list\n\nend module bit0parity\n\nprogram oe\n  use bit0parity\n  implicit none\n  integer :: i\n  integer, dimension(13) :: j\n  write(6,'(a2,2a8)') 'n', 'odd', 'even'\n  write(6, '(i2,2l5)') (i, odd_scalar(i), even_scalar(i), i=-6,6)\n  do i=-6, 6\n    j(i+7) = i\n  end do\n  write(6, '((13i3),a8/(13l3),a8/(13l3),a8)') j, 'n', odd(j), 'odd', even(j), 'even'\nend program oe\n", "target": "namespace RosettaCode\n{\n    using System;\n\n    public static class EvenOrOdd\n    {\n        public static bool IsEvenBitwise(this int number)\n        {\n            return (number & 1) == 0;\n        }\n\n        public static bool IsOddBitwise(this int number)\n        {\n            return (number & 1) != 0;\n        }\n\n        public static bool IsEvenRemainder(this int number)\n        {\n            int remainder;\n            Math.DivRem(number, 2, out remainder);\n            return remainder == 0;\n        }\n\n        public static bool IsOddRemainder(this int number)\n        {\n            int remainder;\n            Math.DivRem(number, 2, out remainder);\n            return remainder != 0;\n        }\n\n        public static bool IsEvenModulo(this int number)\n        {\n            return (number % 2) == 0;\n        }\n\n        public static bool IsOddModulo(this int number)\n        {\n            return (number % 2) != 0;\n        }\n    }\n    public class Program\n    {\n        public static void Main()\n        {\n            int num = 26;               \n            if (num.IsEvenBitwise())    \n            {\n                Console.Write(\"Even\");\n            }\n            else\n            {\n                Console.Write(\"Odd\");\n            }\n            \n            if (num.IsOddBitwise())    \n            {\n                Console.Write(\"Odd\");\n            }\n            else\n            {\n                Console.Write(\"Even\");\n            }\n            \n        }\n    }\n}\n"}
{"id": 122204, "name": "Even or odd", "source": "Translate Fortran to C#: \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nmodule bit0parity\n\n  interface odd\n    module procedure odd_scalar, odd_list\n  end interface\n\n  interface even\n    module procedure even_scalar, even_list\n  end interface\n\ncontains\n\n  logical function odd_scalar(a)\n    implicit none\n    integer, intent(in) :: a\n    odd_scalar = btest(a, 0)\n  end function odd_scalar\n\n  logical function even_scalar(a)\n    implicit none\n    integer, intent(in) :: a\n    even_scalar = .not. odd_scalar(a)\n  end function even_scalar\n\n  function odd_list(a) result(rv)\n    implicit none\n    integer, dimension(:), intent(in) :: a\n    logical, dimension(size(a)) :: rv\n    rv = btest(a, 0)\n  end function odd_list\n\n  function even_list(a) result(rv)\n    implicit none\n    integer, dimension(:), intent(in) :: a\n    logical, dimension(size(a)) :: rv\n    rv = .not. odd_list(a)\n  end function even_list\n\nend module bit0parity\n\nprogram oe\n  use bit0parity\n  implicit none\n  integer :: i\n  integer, dimension(13) :: j\n  write(6,'(a2,2a8)') 'n', 'odd', 'even'\n  write(6, '(i2,2l5)') (i, odd_scalar(i), even_scalar(i), i=-6,6)\n  do i=-6, 6\n    j(i+7) = i\n  end do\n  write(6, '((13i3),a8/(13l3),a8/(13l3),a8)') j, 'n', odd(j), 'odd', even(j), 'even'\nend program oe\n", "target": "namespace RosettaCode\n{\n    using System;\n\n    public static class EvenOrOdd\n    {\n        public static bool IsEvenBitwise(this int number)\n        {\n            return (number & 1) == 0;\n        }\n\n        public static bool IsOddBitwise(this int number)\n        {\n            return (number & 1) != 0;\n        }\n\n        public static bool IsEvenRemainder(this int number)\n        {\n            int remainder;\n            Math.DivRem(number, 2, out remainder);\n            return remainder == 0;\n        }\n\n        public static bool IsOddRemainder(this int number)\n        {\n            int remainder;\n            Math.DivRem(number, 2, out remainder);\n            return remainder != 0;\n        }\n\n        public static bool IsEvenModulo(this int number)\n        {\n            return (number % 2) == 0;\n        }\n\n        public static bool IsOddModulo(this int number)\n        {\n            return (number % 2) != 0;\n        }\n    }\n    public class Program\n    {\n        public static void Main()\n        {\n            int num = 26;               \n            if (num.IsEvenBitwise())    \n            {\n                Console.Write(\"Even\");\n            }\n            else\n            {\n                Console.Write(\"Odd\");\n            }\n            \n            if (num.IsOddBitwise())    \n            {\n                Console.Write(\"Odd\");\n            }\n            else\n            {\n                Console.Write(\"Even\");\n            }\n            \n        }\n    }\n}\n"}
{"id": 122209, "name": "Even or odd", "source": "Translate Fortran to Java: \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nmodule bit0parity\n\n  interface odd\n    module procedure odd_scalar, odd_list\n  end interface\n\n  interface even\n    module procedure even_scalar, even_list\n  end interface\n\ncontains\n\n  logical function odd_scalar(a)\n    implicit none\n    integer, intent(in) :: a\n    odd_scalar = btest(a, 0)\n  end function odd_scalar\n\n  logical function even_scalar(a)\n    implicit none\n    integer, intent(in) :: a\n    even_scalar = .not. odd_scalar(a)\n  end function even_scalar\n\n  function odd_list(a) result(rv)\n    implicit none\n    integer, dimension(:), intent(in) :: a\n    logical, dimension(size(a)) :: rv\n    rv = btest(a, 0)\n  end function odd_list\n\n  function even_list(a) result(rv)\n    implicit none\n    integer, dimension(:), intent(in) :: a\n    logical, dimension(size(a)) :: rv\n    rv = .not. odd_list(a)\n  end function even_list\n\nend module bit0parity\n\nprogram oe\n  use bit0parity\n  implicit none\n  integer :: i\n  integer, dimension(13) :: j\n  write(6,'(a2,2a8)') 'n', 'odd', 'even'\n  write(6, '(i2,2l5)') (i, odd_scalar(i), even_scalar(i), i=-6,6)\n  do i=-6, 6\n    j(i+7) = i\n  end do\n  write(6, '((13i3),a8/(13l3),a8/(13l3),a8)') j, 'n', odd(j), 'odd', even(j), 'even'\nend program oe\n", "target": "public static boolean isEven(int i){\n    return (i & 1) == 0;\n}\n"}
{"id": 122210, "name": "Even or odd", "source": "Translate Fortran to Java: \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nmodule bit0parity\n\n  interface odd\n    module procedure odd_scalar, odd_list\n  end interface\n\n  interface even\n    module procedure even_scalar, even_list\n  end interface\n\ncontains\n\n  logical function odd_scalar(a)\n    implicit none\n    integer, intent(in) :: a\n    odd_scalar = btest(a, 0)\n  end function odd_scalar\n\n  logical function even_scalar(a)\n    implicit none\n    integer, intent(in) :: a\n    even_scalar = .not. odd_scalar(a)\n  end function even_scalar\n\n  function odd_list(a) result(rv)\n    implicit none\n    integer, dimension(:), intent(in) :: a\n    logical, dimension(size(a)) :: rv\n    rv = btest(a, 0)\n  end function odd_list\n\n  function even_list(a) result(rv)\n    implicit none\n    integer, dimension(:), intent(in) :: a\n    logical, dimension(size(a)) :: rv\n    rv = .not. odd_list(a)\n  end function even_list\n\nend module bit0parity\n\nprogram oe\n  use bit0parity\n  implicit none\n  integer :: i\n  integer, dimension(13) :: j\n  write(6,'(a2,2a8)') 'n', 'odd', 'even'\n  write(6, '(i2,2l5)') (i, odd_scalar(i), even_scalar(i), i=-6,6)\n  do i=-6, 6\n    j(i+7) = i\n  end do\n  write(6, '((13i3),a8/(13l3),a8/(13l3),a8)') j, 'n', odd(j), 'odd', even(j), 'even'\nend program oe\n", "target": "public static boolean isEven(int i){\n    return (i & 1) == 0;\n}\n"}
{"id": 122211, "name": "Even or odd", "source": "Translate Fortran to Python: \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nmodule bit0parity\n\n  interface odd\n    module procedure odd_scalar, odd_list\n  end interface\n\n  interface even\n    module procedure even_scalar, even_list\n  end interface\n\ncontains\n\n  logical function odd_scalar(a)\n    implicit none\n    integer, intent(in) :: a\n    odd_scalar = btest(a, 0)\n  end function odd_scalar\n\n  logical function even_scalar(a)\n    implicit none\n    integer, intent(in) :: a\n    even_scalar = .not. odd_scalar(a)\n  end function even_scalar\n\n  function odd_list(a) result(rv)\n    implicit none\n    integer, dimension(:), intent(in) :: a\n    logical, dimension(size(a)) :: rv\n    rv = btest(a, 0)\n  end function odd_list\n\n  function even_list(a) result(rv)\n    implicit none\n    integer, dimension(:), intent(in) :: a\n    logical, dimension(size(a)) :: rv\n    rv = .not. odd_list(a)\n  end function even_list\n\nend module bit0parity\n\nprogram oe\n  use bit0parity\n  implicit none\n  integer :: i\n  integer, dimension(13) :: j\n  write(6,'(a2,2a8)') 'n', 'odd', 'even'\n  write(6, '(i2,2l5)') (i, odd_scalar(i), even_scalar(i), i=-6,6)\n  do i=-6, 6\n    j(i+7) = i\n  end do\n  write(6, '((13i3),a8/(13l3),a8/(13l3),a8)') j, 'n', odd(j), 'odd', even(j), 'even'\nend program oe\n", "target": ">>> def is_odd(i): return bool(i & 1)\n\n>>> def is_even(i): return not is_odd(i)\n\n>>> [(j, is_odd(j)) for j in range(10)]\n[(0, False), (1, True), (2, False), (3, True), (4, False), (5, True), (6, False), (7, True), (8, False), (9, True)]\n>>> [(j, is_even(j)) for j in range(10)]\n[(0, True), (1, False), (2, True), (3, False), (4, True), (5, False), (6, True), (7, False), (8, True), (9, False)]\n>>>\n"}
{"id": 122212, "name": "Even or odd", "source": "Translate Fortran to Python: \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nmodule bit0parity\n\n  interface odd\n    module procedure odd_scalar, odd_list\n  end interface\n\n  interface even\n    module procedure even_scalar, even_list\n  end interface\n\ncontains\n\n  logical function odd_scalar(a)\n    implicit none\n    integer, intent(in) :: a\n    odd_scalar = btest(a, 0)\n  end function odd_scalar\n\n  logical function even_scalar(a)\n    implicit none\n    integer, intent(in) :: a\n    even_scalar = .not. odd_scalar(a)\n  end function even_scalar\n\n  function odd_list(a) result(rv)\n    implicit none\n    integer, dimension(:), intent(in) :: a\n    logical, dimension(size(a)) :: rv\n    rv = btest(a, 0)\n  end function odd_list\n\n  function even_list(a) result(rv)\n    implicit none\n    integer, dimension(:), intent(in) :: a\n    logical, dimension(size(a)) :: rv\n    rv = .not. odd_list(a)\n  end function even_list\n\nend module bit0parity\n\nprogram oe\n  use bit0parity\n  implicit none\n  integer :: i\n  integer, dimension(13) :: j\n  write(6,'(a2,2a8)') 'n', 'odd', 'even'\n  write(6, '(i2,2l5)') (i, odd_scalar(i), even_scalar(i), i=-6,6)\n  do i=-6, 6\n    j(i+7) = i\n  end do\n  write(6, '((13i3),a8/(13l3),a8/(13l3),a8)') j, 'n', odd(j), 'odd', even(j), 'even'\nend program oe\n", "target": ">>> def is_odd(i): return bool(i & 1)\n\n>>> def is_even(i): return not is_odd(i)\n\n>>> [(j, is_odd(j)) for j in range(10)]\n[(0, False), (1, True), (2, False), (3, True), (4, False), (5, True), (6, False), (7, True), (8, False), (9, True)]\n>>> [(j, is_even(j)) for j in range(10)]\n[(0, True), (1, False), (2, True), (3, False), (4, True), (5, False), (6, True), (7, False), (8, True), (9, False)]\n>>>\n"}
{"id": 122637, "name": "Quickselect algorithm", "source": "Translate Fortran to C#:       INTEGER FUNCTION FINDELEMENT(K,A,N)\t\nChase an order statistic: FindElement(N/2,A,N) leads to the median, with some odd/even caution.\nCareful\nCharles Anthony Richard Hoare devised this method, as related to his famous QuickSort.\n       INTEGER K,N\t\t\n       INTEGER A(N),HOPE,PESTY\t\n       INTEGER L,R,L2,R2\t\n        L = 1\t\t\t\n        R = N\t\t\t\n        DO WHILE (L .LT. R)\t\n          HOPE = A(K)\t\t\n          L2 = L\t\t\n          R2 = R\t\t\n          DO WHILE (L2 .LE. R2)\t\n            DO WHILE (A(L2) .LT. HOPE)\t\n              L2 = L2 + 1\t\t\n            END DO\t\t\t\n            DO WHILE (HOPE .LT. A(R2))\t\n              R2 = R2 - 1\t\t\n            END DO\t\t\t\n            IF (L2 - R2) 1,2,3\t\n    1       PESTY = A(L2)\t\t\n            A(L2) = A(R2)\t\t\n            A(R2) = PESTY\t\t\n    2       L2 = L2 + 1\t\t\n            R2 = R2 - 1\t\t\n    3     END DO\t\t\n          IF (R2 .LT. K) L = L2\t\n          IF (K .LT. L2) R = R2\t\n        END DO\t\t\t\n        FINDELEMENT = A(K)\t\n      END FUNCTION FINDELEMENT\t\n\n      PROGRAM POKE\n      INTEGER FINDELEMENT\t\n      INTEGER N\t\t\t\n      PARAMETER (N = 10)\t\n      INTEGER A(66)\t\t\n      DATA A(1:N)/9, 8, 7, 6, 5, 0, 1, 2, 3, 4/\t\n\n      WRITE (6,1) A(1:N)\t\n    1 FORMAT (\"Selection of the i'th element in order from an array.\",/\n     1 \"The array need not be in order, and may be reordered.\",/\n     2 \"  i Val:Array elements...\",/,8X,666I2)\n\n      DO I = 1,N\t\n        WRITE (6,2) I,FINDELEMENT(I,A,N),A(1:N)\t\n    2   FORMAT (I3,I4,\":\",666I2)\t\n      END DO\t\t\n\n      END\t\n", "target": "\n\n\n\n\n\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\n\nnamespace QuickSelect\n{\n    internal static class Program\n    {\n        #region Static Members\n\n        private static void Main()\n        {\n            var inputArray = new[] {9, 8, 7, 6, 5, 0, 1, 2, 3, 4};\n            \n            Console.WriteLine( \"Loop quick select 10 times.\" );\n            for( var i = 0 ; i < 10 ; i++ )\n            {\n                Console.Write( inputArray.NthSmallestElement( i ) );\n                if( i < 9 )\n                    Console.Write( \", \" );\n            }\n            Console.WriteLine();\n\n            \n            \n            Console.WriteLine( \"Just sort 10 elements.\" );\n            Console.WriteLine( string.Join( \", \", inputArray.TakeSmallest( 10 ).OrderBy( v => v ).Select( v => v.ToString() ).ToArray() ) );\n            \n            Console.WriteLine( \"Get 4 smallest and sort them.\" );\n            Console.WriteLine( string.Join( \", \", inputArray.TakeSmallest( 4 ).OrderBy( v => v ).Select( v => v.ToString() ).ToArray() ) );\n            Console.WriteLine( \"< Press any key >\" );\n            Console.ReadKey();\n        }\n\n        #endregion\n    }\n\n    internal static class ArrayExtension\n    {\n        #region Static Members\n\n        \n        \n        \n        \n        \n        \n        \n        public static IEnumerable<T> TakeSmallest<T>( this T[] array, int count ) where T : IComparable<T>\n        {\n            if( count < 0 )\n                throw new ArgumentOutOfRangeException( \"count\", \"Count is smaller than 0.\" );\n            if( count == 0 )\n                return new T[0];\n            if( array.Length <= count )\n                return array;\n\n            return QuickSelectSmallest( array, count - 1 ).Take( count );\n        }\n\n        \n        \n        \n        \n        \n        \n        \n        public static T NthSmallestElement<T>( this T[] array, int n ) where T : IComparable<T>\n        {\n            if( n < 0 || n > array.Length - 1 )\n                throw new ArgumentOutOfRangeException( \"n\", n, string.Format( \"n should be between 0 and {0} it was {1}.\", array.Length - 1, n ) );\n            if( array.Length == 0 )\n                throw new ArgumentException( \"Array is empty.\", \"array\" );\n            if( array.Length == 1 )\n                return array[ 0 ];\n\n            return QuickSelectSmallest( array, n )[ n ];\n        }\n\n        \n        \n        \n        \n        \n        \n        \n        private static T[] QuickSelectSmallest<T>( T[] input, int n ) where T : IComparable<T>\n        {\n            \n            \n            var partiallySortedArray = (T[]) input.Clone();\n           \n            \n            var startIndex = 0;\n            var endIndex = input.Length - 1;\n            \n            \n            \n            var pivotIndex = n;\n\n            \n            var r = new Random();\n            while( endIndex > startIndex )\n            {\n                pivotIndex = QuickSelectPartition( partiallySortedArray, startIndex, endIndex, pivotIndex );\n                if( pivotIndex == n )\n                    \n                    break;\n                if( pivotIndex > n )\n                    \n                    endIndex = pivotIndex - 1;\n                else                    \n                    \n                    startIndex = pivotIndex + 1;\n\n                \n                \n                pivotIndex = r.Next( startIndex,  endIndex );\n            }\n            return partiallySortedArray;\n        }\n\n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        private static int QuickSelectPartition<T>( this T[] array, int startIndex, int endIndex, int pivotIndex ) where T : IComparable<T>\n        {\n            var pivotValue = array[ pivotIndex ];\n            \n            array.Swap( pivotIndex, endIndex );\n            for( var i = startIndex ; i < endIndex ; i++ )\n            {\n                if( array[ i ].CompareTo( pivotValue ) > 0 )\n                    continue;\n\n                \n                array.Swap( i, startIndex );\n                \n                startIndex++;\n            }\n            \n            array.Swap( endIndex, startIndex );\n            return startIndex;\n        }\n\n        private static void Swap<T>( this T[] array, int index1, int index2 )\n        {\n            if( index1 == index2 )\n                return;\n\n            var temp = array[ index1 ];\n            array[ index1 ] = array[ index2 ];\n            array[ index2 ] = temp;\n        }\n\n        #endregion\n    }\n}\n"}
{"id": 122640, "name": "Quickselect algorithm", "source": "Translate Fortran to Java:       INTEGER FUNCTION FINDELEMENT(K,A,N)\t\nChase an order statistic: FindElement(N/2,A,N) leads to the median, with some odd/even caution.\nCareful\nCharles Anthony Richard Hoare devised this method, as related to his famous QuickSort.\n       INTEGER K,N\t\t\n       INTEGER A(N),HOPE,PESTY\t\n       INTEGER L,R,L2,R2\t\n        L = 1\t\t\t\n        R = N\t\t\t\n        DO WHILE (L .LT. R)\t\n          HOPE = A(K)\t\t\n          L2 = L\t\t\n          R2 = R\t\t\n          DO WHILE (L2 .LE. R2)\t\n            DO WHILE (A(L2) .LT. HOPE)\t\n              L2 = L2 + 1\t\t\n            END DO\t\t\t\n            DO WHILE (HOPE .LT. A(R2))\t\n              R2 = R2 - 1\t\t\n            END DO\t\t\t\n            IF (L2 - R2) 1,2,3\t\n    1       PESTY = A(L2)\t\t\n            A(L2) = A(R2)\t\t\n            A(R2) = PESTY\t\t\n    2       L2 = L2 + 1\t\t\n            R2 = R2 - 1\t\t\n    3     END DO\t\t\n          IF (R2 .LT. K) L = L2\t\n          IF (K .LT. L2) R = R2\t\n        END DO\t\t\t\n        FINDELEMENT = A(K)\t\n      END FUNCTION FINDELEMENT\t\n\n      PROGRAM POKE\n      INTEGER FINDELEMENT\t\n      INTEGER N\t\t\t\n      PARAMETER (N = 10)\t\n      INTEGER A(66)\t\t\n      DATA A(1:N)/9, 8, 7, 6, 5, 0, 1, 2, 3, 4/\t\n\n      WRITE (6,1) A(1:N)\t\n    1 FORMAT (\"Selection of the i'th element in order from an array.\",/\n     1 \"The array need not be in order, and may be reordered.\",/\n     2 \"  i Val:Array elements...\",/,8X,666I2)\n\n      DO I = 1,N\t\n        WRITE (6,2) I,FINDELEMENT(I,A,N),A(1:N)\t\n    2   FORMAT (I3,I4,\":\",666I2)\t\n      END DO\t\t\n\n      END\t\n", "target": "import java.util.Random;\n\npublic class QuickSelect {\n\n\tprivate static <E extends Comparable<? super E>> int partition(E[] arr, int left, int right, int pivot) {\n\t\tE pivotVal = arr[pivot];\n\t\tswap(arr, pivot, right);\n\t\tint storeIndex = left;\n\t\tfor (int i = left; i < right; i++) {\n\t\t\tif (arr[i].compareTo(pivotVal) < 0) {\n\t\t\t\tswap(arr, i, storeIndex);\n\t\t\t\tstoreIndex++;\n\t\t\t}\n\t\t}\n\t\tswap(arr, right, storeIndex);\n\t\treturn storeIndex;\n\t}\n\t\n\tprivate static <E extends Comparable<? super E>> E select(E[] arr, int n) {\n\t\tint left = 0;\n\t\tint right = arr.length - 1;\n\t\tRandom rand = new Random();\n\t\twhile (right >= left) {\n\t\t\tint pivotIndex = partition(arr, left, right, rand.nextInt(right - left + 1) + left);\n\t\t\tif (pivotIndex == n) {\n\t\t\t\treturn arr[pivotIndex];\n\t\t\t} else if (pivotIndex < n) {\n\t\t\t\tleft = pivotIndex + 1;\n\t\t\t} else {\n\t\t\t\tright = pivotIndex - 1;\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\t\n\tprivate static void swap(Object[] arr, int i1, int i2) {\n\t\tif (i1 != i2) {\n\t\t\tObject temp = arr[i1];\n\t\t\tarr[i1] = arr[i2];\n\t\t\tarr[i2] = temp;\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tfor (int i = 0; i < 10; i++) {\n\t\t\tInteger[] input = {9, 8, 7, 6, 5, 0, 1, 2, 3, 4};\n\t\t\tSystem.out.print(select(input, i));\n\t\t\tif (i < 9) System.out.print(\", \");\n\t\t}\n\t\tSystem.out.println();\n\t}\n\n}\n"}
{"id": 122641, "name": "Quickselect algorithm", "source": "Translate Fortran to Python:       INTEGER FUNCTION FINDELEMENT(K,A,N)\t\nChase an order statistic: FindElement(N/2,A,N) leads to the median, with some odd/even caution.\nCareful\nCharles Anthony Richard Hoare devised this method, as related to his famous QuickSort.\n       INTEGER K,N\t\t\n       INTEGER A(N),HOPE,PESTY\t\n       INTEGER L,R,L2,R2\t\n        L = 1\t\t\t\n        R = N\t\t\t\n        DO WHILE (L .LT. R)\t\n          HOPE = A(K)\t\t\n          L2 = L\t\t\n          R2 = R\t\t\n          DO WHILE (L2 .LE. R2)\t\n            DO WHILE (A(L2) .LT. HOPE)\t\n              L2 = L2 + 1\t\t\n            END DO\t\t\t\n            DO WHILE (HOPE .LT. A(R2))\t\n              R2 = R2 - 1\t\t\n            END DO\t\t\t\n            IF (L2 - R2) 1,2,3\t\n    1       PESTY = A(L2)\t\t\n            A(L2) = A(R2)\t\t\n            A(R2) = PESTY\t\t\n    2       L2 = L2 + 1\t\t\n            R2 = R2 - 1\t\t\n    3     END DO\t\t\n          IF (R2 .LT. K) L = L2\t\n          IF (K .LT. L2) R = R2\t\n        END DO\t\t\t\n        FINDELEMENT = A(K)\t\n      END FUNCTION FINDELEMENT\t\n\n      PROGRAM POKE\n      INTEGER FINDELEMENT\t\n      INTEGER N\t\t\t\n      PARAMETER (N = 10)\t\n      INTEGER A(66)\t\t\n      DATA A(1:N)/9, 8, 7, 6, 5, 0, 1, 2, 3, 4/\t\n\n      WRITE (6,1) A(1:N)\t\n    1 FORMAT (\"Selection of the i'th element in order from an array.\",/\n     1 \"The array need not be in order, and may be reordered.\",/\n     2 \"  i Val:Array elements...\",/,8X,666I2)\n\n      DO I = 1,N\t\n        WRITE (6,2) I,FINDELEMENT(I,A,N),A(1:N)\t\n    2   FORMAT (I3,I4,\":\",666I2)\t\n      END DO\t\t\n\n      END\t\n", "target": "import random\n\ndef partition(vector, left, right, pivotIndex):\n    pivotValue = vector[pivotIndex]\n    vector[pivotIndex], vector[right] = vector[right], vector[pivotIndex]  \n    storeIndex = left\n    for i in range(left, right):\n        if vector[i] < pivotValue:\n            vector[storeIndex], vector[i] = vector[i], vector[storeIndex]\n            storeIndex += 1\n    vector[right], vector[storeIndex] = vector[storeIndex], vector[right]  \n    return storeIndex\n\ndef _select(vector, left, right, k):\n    \"Returns the k-th smallest, (k >= 0), element of vector within vector[left:right+1] inclusive.\"\n    while True:\n        pivotIndex = random.randint(left, right)     \n        pivotNewIndex = partition(vector, left, right, pivotIndex)\n        pivotDist = pivotNewIndex - left\n        if pivotDist == k:\n            return vector[pivotNewIndex]\n        elif k < pivotDist:\n            right = pivotNewIndex - 1\n        else:\n            k -= pivotDist + 1\n            left = pivotNewIndex + 1\n\ndef select(vector, k, left=None, right=None):\n    \n    if left is None:\n        left = 0\n    lv1 = len(vector) - 1\n    if right is None:\n        right = lv1\n    assert vector and k >= 0, \"Either null vector or k < 0 \"\n    assert 0 <= left <= lv1, \"left is out of range\"\n    assert left <= right <= lv1, \"right is out of range\"\n    return _select(vector, left, right, k)\n\nif __name__ == '__main__':\n    v = [9, 8, 7, 6, 5, 0, 1, 2, 3, 4]\n    print([select(v, i) for i in range(10)])\n"}
{"id": 122914, "name": "Kaprekar numbers", "source": "Translate Fortran to C#: program Karpekar_Numbers\n  implicit none\n   \n  integer, parameter :: i64 = selected_int_kind(18)\n  integer :: count \n \n  call karpekar(10000_i64, .true.)\n  write(*,*)\n  call karpekar(1000000_i64, .false.)\n  \ncontains\n\nsubroutine karpekar(n, printnums)\n\n  integer(i64), intent(in) :: n\n  logical, intent(in) :: printnums\n  integer(i64) :: c, i, j, n1, n2\n  character(19) :: str, s1, s2\n  \n  c = 0\n  do i = 1, n\n    write(str, \"(i0)\") i*i\n    do j = 0, len_trim(str)-1\n      s1 = str(1:j)\n      s2 = str(j+1:len_trim(str)) \n      read(s1, \"(i19)\") n1\n      read(s2, \"(i19)\") n2\n      if(n2 == 0) cycle\n      if(n1 + n2 == i) then\n        c = c + 1\n        if (printnums .eqv. .true.) write(*, \"(i0)\") i\n        exit\n      end if\n    end do    \n  end do\n  if (printnums .eqv. .false.) write(*, \"(i0)\") c\nend subroutine\nend program\n", "target": "using System;\nusing System.Collections.Generic;\n\npublic class KaprekarNumbers {\n\n    \n    \n    \n    public static void Main() {\n        int count = 0;\n\n        foreach ( ulong i in _kaprekarGenerator(999999) ) {\n            Console.WriteLine(i);\n            count++;\n        }\n\n        Console.WriteLine(\"There are {0} Kaprekar numbers less than 1000000.\", count);\n    }\n\n    \n    \n    \n    \n    \n    private static IEnumerable<ulong> _kaprekarGenerator(ulong max) {\n\n        ulong next = 1;\n\n        \n        yield return next;\n\n        for ( next = 2; next <= max; next++ ) {\n\n            ulong square = next * next;\n\n            for ( ulong check = 10; check <= 10000000000000000000; check *= 10 ) {\n                \n                \n\n                \n                if ( square <= check )\n                    break;\n\n                \n                \n                \n                \n                \n\n                ulong r = square % check;\n                ulong q = (square - r) / check;\n\n                if ( r != 0 && q + r == next ) {\n                    yield return next;\n                    break;\n                }\n            }\n\n        }\n\n    }\n\n}\n"}
{"id": 122915, "name": "Kaprekar numbers", "source": "Translate Fortran to C#: program Karpekar_Numbers\n  implicit none\n   \n  integer, parameter :: i64 = selected_int_kind(18)\n  integer :: count \n \n  call karpekar(10000_i64, .true.)\n  write(*,*)\n  call karpekar(1000000_i64, .false.)\n  \ncontains\n\nsubroutine karpekar(n, printnums)\n\n  integer(i64), intent(in) :: n\n  logical, intent(in) :: printnums\n  integer(i64) :: c, i, j, n1, n2\n  character(19) :: str, s1, s2\n  \n  c = 0\n  do i = 1, n\n    write(str, \"(i0)\") i*i\n    do j = 0, len_trim(str)-1\n      s1 = str(1:j)\n      s2 = str(j+1:len_trim(str)) \n      read(s1, \"(i19)\") n1\n      read(s2, \"(i19)\") n2\n      if(n2 == 0) cycle\n      if(n1 + n2 == i) then\n        c = c + 1\n        if (printnums .eqv. .true.) write(*, \"(i0)\") i\n        exit\n      end if\n    end do    \n  end do\n  if (printnums .eqv. .false.) write(*, \"(i0)\") c\nend subroutine\nend program\n", "target": "using System;\nusing System.Collections.Generic;\n\npublic class KaprekarNumbers {\n\n    \n    \n    \n    public static void Main() {\n        int count = 0;\n\n        foreach ( ulong i in _kaprekarGenerator(999999) ) {\n            Console.WriteLine(i);\n            count++;\n        }\n\n        Console.WriteLine(\"There are {0} Kaprekar numbers less than 1000000.\", count);\n    }\n\n    \n    \n    \n    \n    \n    private static IEnumerable<ulong> _kaprekarGenerator(ulong max) {\n\n        ulong next = 1;\n\n        \n        yield return next;\n\n        for ( next = 2; next <= max; next++ ) {\n\n            ulong square = next * next;\n\n            for ( ulong check = 10; check <= 10000000000000000000; check *= 10 ) {\n                \n                \n\n                \n                if ( square <= check )\n                    break;\n\n                \n                \n                \n                \n                \n\n                ulong r = square % check;\n                ulong q = (square - r) / check;\n\n                if ( r != 0 && q + r == next ) {\n                    yield return next;\n                    break;\n                }\n            }\n\n        }\n\n    }\n\n}\n"}
{"id": 122921, "name": "Kaprekar numbers", "source": "Translate Fortran to Java: program Karpekar_Numbers\n  implicit none\n   \n  integer, parameter :: i64 = selected_int_kind(18)\n  integer :: count \n \n  call karpekar(10000_i64, .true.)\n  write(*,*)\n  call karpekar(1000000_i64, .false.)\n  \ncontains\n\nsubroutine karpekar(n, printnums)\n\n  integer(i64), intent(in) :: n\n  logical, intent(in) :: printnums\n  integer(i64) :: c, i, j, n1, n2\n  character(19) :: str, s1, s2\n  \n  c = 0\n  do i = 1, n\n    write(str, \"(i0)\") i*i\n    do j = 0, len_trim(str)-1\n      s1 = str(1:j)\n      s2 = str(j+1:len_trim(str)) \n      read(s1, \"(i19)\") n1\n      read(s2, \"(i19)\") n2\n      if(n2 == 0) cycle\n      if(n1 + n2 == i) then\n        c = c + 1\n        if (printnums .eqv. .true.) write(*, \"(i0)\") i\n        exit\n      end if\n    end do    \n  end do\n  if (printnums .eqv. .false.) write(*, \"(i0)\") c\nend subroutine\nend program\n", "target": "public class Kaprekar {\n    private static String[] splitAt(String str, int idx){\n        String[] ans = new String[2];\n        ans[0] = str.substring(0, idx);\n        if(ans[0].equals(\"\")) ans[0] = \"0\"; \n        ans[1] = str.substring(idx);\n        return ans;\n    }\n        \n    public static void main(String[] args){\n        int count = 0;\n        int base = (args.length > 0) ? Integer.parseInt(args[0]) : 10;\n        for(long i = 1; i <= 1000000; i++){\n            String sqrStr = Long.toString(i * i, base);\n            for(int j = 0; j < sqrStr.length() / 2 + 1; j++){\n                String[] parts = splitAt(sqrStr, j);\n                long firstNum = Long.parseLong(parts[0], base);\n                long secNum = Long.parseLong(parts[1], base);\n                \n                if(secNum == 0) break;\n                if(firstNum + secNum == i){\n                    System.out.println(i + \"\\t\" + Long.toString(i, base) +\n                            \"\\t\" + sqrStr + \"\\t\" + parts[0] + \" + \" + parts[1]);\n                    count++;\n                    break;\n                }\n            }\n        }\n        System.out.println(count + \" Kaprekar numbers < 1000000 (base 10) in base \"+base);\n    }\n}\n"}
{"id": 122922, "name": "Kaprekar numbers", "source": "Translate Fortran to Java: program Karpekar_Numbers\n  implicit none\n   \n  integer, parameter :: i64 = selected_int_kind(18)\n  integer :: count \n \n  call karpekar(10000_i64, .true.)\n  write(*,*)\n  call karpekar(1000000_i64, .false.)\n  \ncontains\n\nsubroutine karpekar(n, printnums)\n\n  integer(i64), intent(in) :: n\n  logical, intent(in) :: printnums\n  integer(i64) :: c, i, j, n1, n2\n  character(19) :: str, s1, s2\n  \n  c = 0\n  do i = 1, n\n    write(str, \"(i0)\") i*i\n    do j = 0, len_trim(str)-1\n      s1 = str(1:j)\n      s2 = str(j+1:len_trim(str)) \n      read(s1, \"(i19)\") n1\n      read(s2, \"(i19)\") n2\n      if(n2 == 0) cycle\n      if(n1 + n2 == i) then\n        c = c + 1\n        if (printnums .eqv. .true.) write(*, \"(i0)\") i\n        exit\n      end if\n    end do    \n  end do\n  if (printnums .eqv. .false.) write(*, \"(i0)\") c\nend subroutine\nend program\n", "target": "public class Kaprekar {\n    private static String[] splitAt(String str, int idx){\n        String[] ans = new String[2];\n        ans[0] = str.substring(0, idx);\n        if(ans[0].equals(\"\")) ans[0] = \"0\"; \n        ans[1] = str.substring(idx);\n        return ans;\n    }\n        \n    public static void main(String[] args){\n        int count = 0;\n        int base = (args.length > 0) ? Integer.parseInt(args[0]) : 10;\n        for(long i = 1; i <= 1000000; i++){\n            String sqrStr = Long.toString(i * i, base);\n            for(int j = 0; j < sqrStr.length() / 2 + 1; j++){\n                String[] parts = splitAt(sqrStr, j);\n                long firstNum = Long.parseLong(parts[0], base);\n                long secNum = Long.parseLong(parts[1], base);\n                \n                if(secNum == 0) break;\n                if(firstNum + secNum == i){\n                    System.out.println(i + \"\\t\" + Long.toString(i, base) +\n                            \"\\t\" + sqrStr + \"\\t\" + parts[0] + \" + \" + parts[1]);\n                    count++;\n                    break;\n                }\n            }\n        }\n        System.out.println(count + \" Kaprekar numbers < 1000000 (base 10) in base \"+base);\n    }\n}\n"}
{"id": 122923, "name": "Kaprekar numbers", "source": "Translate Fortran to Python: program Karpekar_Numbers\n  implicit none\n   \n  integer, parameter :: i64 = selected_int_kind(18)\n  integer :: count \n \n  call karpekar(10000_i64, .true.)\n  write(*,*)\n  call karpekar(1000000_i64, .false.)\n  \ncontains\n\nsubroutine karpekar(n, printnums)\n\n  integer(i64), intent(in) :: n\n  logical, intent(in) :: printnums\n  integer(i64) :: c, i, j, n1, n2\n  character(19) :: str, s1, s2\n  \n  c = 0\n  do i = 1, n\n    write(str, \"(i0)\") i*i\n    do j = 0, len_trim(str)-1\n      s1 = str(1:j)\n      s2 = str(j+1:len_trim(str)) \n      read(s1, \"(i19)\") n1\n      read(s2, \"(i19)\") n2\n      if(n2 == 0) cycle\n      if(n1 + n2 == i) then\n        c = c + 1\n        if (printnums .eqv. .true.) write(*, \"(i0)\") i\n        exit\n      end if\n    end do    \n  end do\n  if (printnums .eqv. .false.) write(*, \"(i0)\") c\nend subroutine\nend program\n", "target": ">>> def k(n):\n\tn2 = str(n**2)\n\tfor i in range(len(n2)):\n\t\ta, b = int(n2[:i] or 0), int(n2[i:])\n\t\tif b and a + b == n:\n\t\t\treturn n\n\t\t\t\n\n\t\t\n>>> [x for x in range(1,10000) if k(x)]\n[1, 9, 45, 55, 99, 297, 703, 999, 2223, 2728, 4879, 4950, 5050, 5292, 7272, 7777, 9999]\n>>> len([x for x in range(1,1000000) if k(x)])\n54\n>>>\n"}
{"id": 122924, "name": "Kaprekar numbers", "source": "Translate Fortran to Python: program Karpekar_Numbers\n  implicit none\n   \n  integer, parameter :: i64 = selected_int_kind(18)\n  integer :: count \n \n  call karpekar(10000_i64, .true.)\n  write(*,*)\n  call karpekar(1000000_i64, .false.)\n  \ncontains\n\nsubroutine karpekar(n, printnums)\n\n  integer(i64), intent(in) :: n\n  logical, intent(in) :: printnums\n  integer(i64) :: c, i, j, n1, n2\n  character(19) :: str, s1, s2\n  \n  c = 0\n  do i = 1, n\n    write(str, \"(i0)\") i*i\n    do j = 0, len_trim(str)-1\n      s1 = str(1:j)\n      s2 = str(j+1:len_trim(str)) \n      read(s1, \"(i19)\") n1\n      read(s2, \"(i19)\") n2\n      if(n2 == 0) cycle\n      if(n1 + n2 == i) then\n        c = c + 1\n        if (printnums .eqv. .true.) write(*, \"(i0)\") i\n        exit\n      end if\n    end do    \n  end do\n  if (printnums .eqv. .false.) write(*, \"(i0)\") c\nend subroutine\nend program\n", "target": ">>> def k(n):\n\tn2 = str(n**2)\n\tfor i in range(len(n2)):\n\t\ta, b = int(n2[:i] or 0), int(n2[i:])\n\t\tif b and a + b == n:\n\t\t\treturn n\n\t\t\t\n\n\t\t\n>>> [x for x in range(1,10000) if k(x)]\n[1, 9, 45, 55, 99, 297, 703, 999, 2223, 2728, 4879, 4950, 5050, 5292, 7272, 7777, 9999]\n>>> len([x for x in range(1,1000000) if k(x)])\n54\n>>>\n"}
{"id": 123276, "name": "Infinity", "source": "Translate Fortran to C#: program to_f_the_ineffable\n   use, intrinsic :: ieee_arithmetic\n   integer :: i\n   real dimension(2) :: y, x = (/ 30, ieee_value(y,ieee_positive_inf) /)\n   \n   do i = 1, 2\n      if (ieee_support_datatype(x(i))) then\n         if (ieee_is_finite(x(i))) then\n            print *, 'x(',i,') is finite'\n         else\n            print *, 'x(',i,') is infinite'\n         end if\n         \n      else\n         print *, 'x(',i,') is not in an IEEE-supported format'\n      end if\n   end do\nend program to_f_the_ineffable\n", "target": "using System;\n\nclass Program\n{\n    static double PositiveInfinity()\n    {\n        return double.PositiveInfinity;\n    }\n\n    static void Main()\n    {\n        Console.WriteLine(PositiveInfinity());\n    }\n}\n"}
{"id": 123280, "name": "Infinity", "source": "Translate Fortran to Java: program to_f_the_ineffable\n   use, intrinsic :: ieee_arithmetic\n   integer :: i\n   real dimension(2) :: y, x = (/ 30, ieee_value(y,ieee_positive_inf) /)\n   \n   do i = 1, 2\n      if (ieee_support_datatype(x(i))) then\n         if (ieee_is_finite(x(i))) then\n            print *, 'x(',i,') is finite'\n         else\n            print *, 'x(',i,') is infinite'\n         end if\n         \n      else\n         print *, 'x(',i,') is not in an IEEE-supported format'\n      end if\n   end do\nend program to_f_the_ineffable\n", "target": "double infinity = Double.POSITIVE_INFINITY; \nDouble.isInfinite(infinity); \n"}
{"id": 123281, "name": "Infinity", "source": "Translate Fortran to Python: program to_f_the_ineffable\n   use, intrinsic :: ieee_arithmetic\n   integer :: i\n   real dimension(2) :: y, x = (/ 30, ieee_value(y,ieee_positive_inf) /)\n   \n   do i = 1, 2\n      if (ieee_support_datatype(x(i))) then\n         if (ieee_is_finite(x(i))) then\n            print *, 'x(',i,') is finite'\n         else\n            print *, 'x(',i,') is infinite'\n         end if\n         \n      else\n         print *, 'x(',i,') is not in an IEEE-supported format'\n      end if\n   end do\nend program to_f_the_ineffable\n", "target": ">>> float('infinity')\ninf\n"}
{"id": 123477, "name": "Sort an integer array", "source": "Translate Fortran to C#: CALL ISORT@(b, a, n)\n\n\n\n", "target": "using System;\nusing System.Collections.Generic;\n\npublic class Program {\n    static void Main() {\n        int[] unsorted = { 6, 2, 7, 8, 3, 1, 10, 5, 4, 9 };\n        Array.Sort(unsorted);\n    }\n}\n"}
{"id": 123481, "name": "Sort an integer array", "source": "Translate Fortran to Java: CALL ISORT@(b, a, n)\n\n\n\n", "target": "import java.util.Arrays;\n\npublic class Example {\n    public static void main(String[] args)\n    {\n        int[] nums = {2,4,3,1,2};\n        Arrays.sort(nums);\n    }\n}\n"}
{"id": 124024, "name": "Substitution cipher", "source": "Translate Fortran to C#: program substitution\n  implicit none\n\n  integer, parameter :: len_max = 256\n  integer, parameter :: eof = -1\n  integer :: in_unit = 9, out_unit = 10, ios\n  character(len_max) :: line\n  \n  open(in_unit, file=\"plain.txt\",  iostat=ios)\n  if (ios /= 0) then\n    write(*,*) \"Error opening plain.txt file\"\n    stop\n  end if\n  \n  open(out_unit, file=\"encrypted.txt\", iostat=ios)\n  if (ios /= 0) then\n    write(*,*) \"Error opening encrypted.txt file\"\n    stop\n  end if\n\n\n  do \n    read(in_unit, \"(a)\", iostat=ios) line\n    if (ios > 0) then\n      write(*,*) \"Error reading plain.txt file\"\n      stop\n    else if (ios == eof) then\n      exit\n    end if\n            \n    call cipher(trim(line))\n    write(out_unit, \"(a)\", iostat=ios) trim(line)\n    if (ios /= 0) then\n      write(*,*) \"Error writing encrypted.txt file\"\n      stop\n    end if\n  end do\n\n  close(in_unit)\n  close(out_unit)\n\n  open(in_unit, file=\"encrypted.txt\",  iostat=ios)\n  if (ios /= 0) then\n    write(*,*) \"Error opening encrypted.txt file\"\n    stop\n  end if\n  \n  open(out_unit, file=\"decrypted.txt\", iostat=ios)\n  if (ios /= 0) then\n    write(*,*) \"Error opening decrypted.txt file\"\n    stop\n  end if\n \n\n  do \n    read(in_unit, \"(a)\", iostat=ios) line\n    if (ios > 0) then\n      write(*,*) \"Error reading encrypted.txt file\"\n      stop\n    else if (ios == eof) then\n      exit\n    end if\n            \n    call cipher(trim(line))\n    write(out_unit, \"(a)\", iostat=ios) trim(line)\n    if (ios /= 0) then\n      write(*,*) \"Error writing decrypted.txt file\"\n      stop\n    end if\n  end do  \n\n  close(in_unit)\n  close(out_unit)\n  \ncontains\n\nsubroutine cipher(text)\n  character(*), intent(in out) :: text\n  integer :: i\n\n\n\n\n  do i = 1, len(text)\n    select case(text(i:i))\n      case ('A':'Z')\n        text(i:i) = achar(155 - iachar(text(i:i)))\n      case ('a':'z')\n        text(i:i) = achar(219 - iachar(text(i:i)))\n    end select\n  end do\nend subroutine\n\nend program\n", "target": "using System;\nusing System.IO;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Threading.Tasks;\n\nnamespace SubstitutionCipherProject\n{\n    class SubstitutionCipher\n    {\n        static void Main(string[] args)\n        {\n            doEncDec(\"e:\\\\source.txt\", \"enc.txt\", true);\n            doEncDec(\"enc.txt\", \"dec.txt\", false);\n            Console.WriteLine(\"Done\");\n            Console.ReadKey();\n        }\n        static void doEncDec(String source, String target, bool IsEncrypt)\n        {\n            ITransform trans;\n\n            if (IsEncrypt)\n                trans = new Encrypt();\n            else\n                trans = new Decrypt();\n\n            FileInfo sfi = new FileInfo(source);\n            FileStream sstream = sfi.OpenRead();\n            StreamReader sr = new StreamReader(sstream);\n\n            FileInfo tfi = new FileInfo(target);\n            FileStream tstream = tfi.OpenWrite();\n            TransformWriter tw = new TransformWriter(tstream, trans);\n            StreamWriter sw = new StreamWriter(tw);\n\n            String line;\n            while ((line = sr.ReadLine()) != null)\n                sw.WriteLine(line);\n            sw.Close();\n        }\n    }\n    public interface ITransform\n    {\n        byte transform(byte ch);\n    }\n    public class Encrypt : ITransform\n    {\n        const String str = \"xyfagchbimpourvnqsdewtkjzl\";\n        byte ITransform.transform(byte ch)\n        {\n            if (char.IsLower((char)ch))\n                ch = (byte)str[ch - (byte)'a'];\n            return ch;\n        }\n    }\n    class Decrypt : ITransform\n    {\n        const String str = \"xyfagchbimpourvnqsdewtkjzl\";\n        byte ITransform.transform(byte ch)\n        {\n            if (char.IsLower((char)ch))\n                ch = (byte)(str.IndexOf((char)ch) + 'a');\n            return ch;\n        }\n    }\n    class TransformWriter : Stream, IDisposable\n    {\n        private Stream outs;\n        private ITransform trans;\n\n        public TransformWriter(Stream s, ITransform t)\n        {\n            this.outs = s;\n            this.trans = t;\n        }\n\n        public override bool CanRead\n        {\n            get { return false; }\n        }\n\n        public override bool CanSeek\n        {\n            get { return false; }\n        }\n\n        public override bool CanWrite\n        {\n            get { return true; }\n        }\n        public override void Flush()\n        {\n            outs.Flush();\n        }\n\n        public override long Length\n        {\n            get { return outs.Length; }\n        }\n        public override long Position\n        {\n            get\n            {\n                return outs.Position;\n            }\n            set\n            {\n                outs.Position = value;\n            }\n        }\n        public override long Seek(long offset, SeekOrigin origin)\n        {\n            return outs.Seek(offset, origin);\n        }\n\n        public override void SetLength(long value)\n        {\n            outs.SetLength(value);\n        }\n\n        public override void Write(byte[] buf, int off, int len)\n        {\n            for (int i = off; i < off + len; i++)\n                buf[i] = trans.transform(buf[i]);\n            outs.Write(buf, off, len);\n        }\n\n        void IDisposable.Dispose()\n        {\n            outs.Dispose();\n        }\n\n        public override void Close()\n        {\n            outs.Close();\n        }\n\n        public override int Read(byte[] cbuf, int off, int count)\n        {\n            return outs.Read(cbuf, off, count);\n        }\n    }\n}\n"}
{"id": 124027, "name": "Substitution cipher", "source": "Translate Fortran to Java: program substitution\n  implicit none\n\n  integer, parameter :: len_max = 256\n  integer, parameter :: eof = -1\n  integer :: in_unit = 9, out_unit = 10, ios\n  character(len_max) :: line\n  \n  open(in_unit, file=\"plain.txt\",  iostat=ios)\n  if (ios /= 0) then\n    write(*,*) \"Error opening plain.txt file\"\n    stop\n  end if\n  \n  open(out_unit, file=\"encrypted.txt\", iostat=ios)\n  if (ios /= 0) then\n    write(*,*) \"Error opening encrypted.txt file\"\n    stop\n  end if\n\n\n  do \n    read(in_unit, \"(a)\", iostat=ios) line\n    if (ios > 0) then\n      write(*,*) \"Error reading plain.txt file\"\n      stop\n    else if (ios == eof) then\n      exit\n    end if\n            \n    call cipher(trim(line))\n    write(out_unit, \"(a)\", iostat=ios) trim(line)\n    if (ios /= 0) then\n      write(*,*) \"Error writing encrypted.txt file\"\n      stop\n    end if\n  end do\n\n  close(in_unit)\n  close(out_unit)\n\n  open(in_unit, file=\"encrypted.txt\",  iostat=ios)\n  if (ios /= 0) then\n    write(*,*) \"Error opening encrypted.txt file\"\n    stop\n  end if\n  \n  open(out_unit, file=\"decrypted.txt\", iostat=ios)\n  if (ios /= 0) then\n    write(*,*) \"Error opening decrypted.txt file\"\n    stop\n  end if\n \n\n  do \n    read(in_unit, \"(a)\", iostat=ios) line\n    if (ios > 0) then\n      write(*,*) \"Error reading encrypted.txt file\"\n      stop\n    else if (ios == eof) then\n      exit\n    end if\n            \n    call cipher(trim(line))\n    write(out_unit, \"(a)\", iostat=ios) trim(line)\n    if (ios /= 0) then\n      write(*,*) \"Error writing decrypted.txt file\"\n      stop\n    end if\n  end do  \n\n  close(in_unit)\n  close(out_unit)\n  \ncontains\n\nsubroutine cipher(text)\n  character(*), intent(in out) :: text\n  integer :: i\n\n\n\n\n  do i = 1, len(text)\n    select case(text(i:i))\n      case ('A':'Z')\n        text(i:i) = achar(155 - iachar(text(i:i)))\n      case ('a':'z')\n        text(i:i) = achar(219 - iachar(text(i:i)))\n    end select\n  end do\nend subroutine\n\nend program\n", "target": "public class SubstitutionCipher {\n\n    final static String key = \"]kYV}(!7P$n5_0i R:?jOWtF/=-pe'AD&@r6%ZXs\\\"v*N\"\n            + \"[#wSl9zq2^+g;LoB`aGh{3.HIu4fbK)mU8|dMET><,Qc\\\\C1yxJ\";\n\n    static String text = \"Here we have to do is there will be a input/source \"\n            + \"file in which we are going to Encrypt the file by replacing every \"\n            + \"upper/lower case alphabets of the source file with another \"\n            + \"predetermined upper/lower case alphabets or symbols and save \"\n            + \"it into another output/encrypted file and then again convert \"\n            + \"that output/encrypted file into original/decrypted file. This \"\n            + \"type of Encryption/Decryption scheme is often called a \"\n            + \"Substitution Cipher.\";\n\n    public static void main(String[] args) {\n        String enc = encode(text);\n        System.out.println(\"Encoded: \" + enc);\n        System.out.println(\"\\nDecoded: \" + decode(enc));\n    }\n\n    static String encode(String s) {\n        StringBuilder sb = new StringBuilder(s.length());\n\n        for (char c : s.toCharArray())\n            sb.append(key.charAt((int) c - 32));\n\n        return sb.toString();\n    }\n\n    static String decode(String s) {\n        StringBuilder sb = new StringBuilder(s.length());\n\n        for (char c : s.toCharArray())\n            sb.append((char) (key.indexOf((int) c) + 32));\n\n        return sb.toString();\n    }\n}\n"}
{"id": 124028, "name": "Substitution cipher", "source": "Translate Fortran to Python: program substitution\n  implicit none\n\n  integer, parameter :: len_max = 256\n  integer, parameter :: eof = -1\n  integer :: in_unit = 9, out_unit = 10, ios\n  character(len_max) :: line\n  \n  open(in_unit, file=\"plain.txt\",  iostat=ios)\n  if (ios /= 0) then\n    write(*,*) \"Error opening plain.txt file\"\n    stop\n  end if\n  \n  open(out_unit, file=\"encrypted.txt\", iostat=ios)\n  if (ios /= 0) then\n    write(*,*) \"Error opening encrypted.txt file\"\n    stop\n  end if\n\n\n  do \n    read(in_unit, \"(a)\", iostat=ios) line\n    if (ios > 0) then\n      write(*,*) \"Error reading plain.txt file\"\n      stop\n    else if (ios == eof) then\n      exit\n    end if\n            \n    call cipher(trim(line))\n    write(out_unit, \"(a)\", iostat=ios) trim(line)\n    if (ios /= 0) then\n      write(*,*) \"Error writing encrypted.txt file\"\n      stop\n    end if\n  end do\n\n  close(in_unit)\n  close(out_unit)\n\n  open(in_unit, file=\"encrypted.txt\",  iostat=ios)\n  if (ios /= 0) then\n    write(*,*) \"Error opening encrypted.txt file\"\n    stop\n  end if\n  \n  open(out_unit, file=\"decrypted.txt\", iostat=ios)\n  if (ios /= 0) then\n    write(*,*) \"Error opening decrypted.txt file\"\n    stop\n  end if\n \n\n  do \n    read(in_unit, \"(a)\", iostat=ios) line\n    if (ios > 0) then\n      write(*,*) \"Error reading encrypted.txt file\"\n      stop\n    else if (ios == eof) then\n      exit\n    end if\n            \n    call cipher(trim(line))\n    write(out_unit, \"(a)\", iostat=ios) trim(line)\n    if (ios /= 0) then\n      write(*,*) \"Error writing decrypted.txt file\"\n      stop\n    end if\n  end do  \n\n  close(in_unit)\n  close(out_unit)\n  \ncontains\n\nsubroutine cipher(text)\n  character(*), intent(in out) :: text\n  integer :: i\n\n\n\n\n  do i = 1, len(text)\n    select case(text(i:i))\n      case ('A':'Z')\n        text(i:i) = achar(155 - iachar(text(i:i)))\n      case ('a':'z')\n        text(i:i) = achar(219 - iachar(text(i:i)))\n    end select\n  end do\nend subroutine\n\nend program\n", "target": "from string import printable\nimport random\n\nEXAMPLE_KEY = ''.join(sorted(printable, key=lambda _:random.random()))\n\ndef encode(plaintext, key):\n    return ''.join(key[printable.index(char)] for char in plaintext)\n\ndef decode(plaintext, key):\n    return ''.join(printable[key.index(char)] for char in plaintext)\n\noriginal = \"A simple example.\"\nencoded = encode(original, EXAMPLE_KEY)\ndecoded = decode(encoded, EXAMPLE_KEY)\nprint(.format(\n    original, EXAMPLE_KEY, encoded, decoded))\n"}
{"id": 124273, "name": "Cartesian product of two or more lists", "source": "Translate Fortran to C#:  \n  \n \n \n module tuple\n    implicit none\n    private\n    public :: tuple_t, operator(*), print\n \n    type tuple_t(n)\n        integer, len     :: n\n        integer, private :: v(n)\n    contains\n        procedure, public :: print => print_tuple_t\n        generic, public :: assignment(=) => eq_tuple_t\n        procedure, public :: eq_tuple_t\n    end type tuple_t\n \n    interface print\n        module procedure print_tuple_a_t\n    end interface print\n    interface operator(*)\n        module procedure tup_times_tup\n    end interface\n \n contains\n    subroutine eq_tuple_t(this, src)\n        class(tuple_t(*)), intent(inout) :: this\n        integer, intent(in)              :: src(:)\n        this%v = src\n    end subroutine eq_tuple_t\n\n    pure function tup_times_tup(a, b) result(r)\n        type(tuple_t(*)), intent(in)  :: a\n        type(tuple_t(*)), intent(in)  :: b\n        type(tuple_t(2)), allocatable :: r(:)\n        integer :: i, j, k\n \n        allocate(r(a%n*b%n))\n        k = 0\n        do i=1,a%n\n            do j=1,b%n\n                k = k + 1\n                r(k)%v = [a%v(i),b%v(j)]\n            end do\n        end do\n    end function tup_times_tup\n \n    subroutine print_tuple_t(this)\n        class(tuple_t(*)), intent(in) :: this\n        integer :: i\n        write(*,fmt='(a)',advance='no') '{'\n        do i=1,size(this%v)\n            write(*,fmt='(i0)',advance='no') this%v(i)\n            if (i < size(this%v)) write(*,fmt='(a)',advance='no') ','\n        end do\n        write(*,fmt='(a)',advance='no') '}'\n    end subroutine print_tuple_t\n \n    subroutine print_tuple_a_t(r)\n        type(tuple_t(*)), intent(in) :: r(:)\n        integer :: i\n        write(*,fmt='(a)',advance='no') '{'\n        do i=1,size(r)\n            call r(i)%print\n            if (i < size(r)) write(*,fmt='(a)',advance='no') ','\n        end do\n        write(*,fmt='(a)') '}'\n    end subroutine print_tuple_a_t\n end module tuple\n \n program cartesian_product\n    use tuple\n \n    implicit none\n    type(tuple_t(2)) :: a, b\n    type(tuple_t(0)) :: z\n \n    a = [1,2]\n    b = [3,4]\n \n    call print_product(a, b)\n    call print_product(b, a)\n    call print_product(z, a)\n    call print_product(a, z)\n \n    stop\n contains\n    subroutine print_product(s, t)\n        type(tuple_t(*)), intent(in) :: s\n        type(tuple_t(*)), intent(in) :: t\n        call s%print\n        write(*,fmt='(a)',advance='no') ' x '\n        call t%print\n        write(*,fmt='(a)',advance='no') ' = '\n        call print(s*t)\n    end subroutine print_product\n end program cartesian_product\n", "target": "using System;\npublic class Program\n{\n    public static void Main()\n    {\n        int[] empty = new int[0];\n        int[] list1 = { 1, 2 };\n        int[] list2 = { 3, 4 };\n        int[] list3 = { 1776, 1789 };\n        int[] list4 = { 7, 12 };\n        int[] list5 = { 4, 14, 23 };\n        int[] list6 = { 0, 1 };\n        int[] list7 = { 1, 2, 3 };\n        int[] list8 = { 30 };\n        int[] list9 = { 500, 100 };\n        \n        foreach (var sequenceList in new [] {\n            new [] { list1, list2 },\n            new [] { list2, list1 },\n            new [] { list1, empty },\n            new [] { empty, list1 },\n            new [] { list3, list4, list5, list6 },\n            new [] { list7, list8, list9 },\n            new [] { list7, empty, list9 }\n        }) {\n            var cart = sequenceList.CartesianProduct()\n                .Select(tuple => $\"({string.Join(\", \", tuple)})\");\n            Console.WriteLine($\"{{{string.Join(\", \", cart)}}}\");\n        }\n    }\n}\n\npublic static class Extensions\n{\n    public static IEnumerable<IEnumerable<T>> CartesianProduct<T>(this IEnumerable<IEnumerable<T>> sequences) {\n        IEnumerable<IEnumerable<T>> emptyProduct = new[] { Enumerable.Empty<T>() };\n        return sequences.Aggregate(\n            emptyProduct,\n            (accumulator, sequence) =>\n            from acc in accumulator\n            from item in sequence\n            select acc.Concat(new [] { item }));\n    }\n}\n"}
{"id": 124274, "name": "Cartesian product of two or more lists", "source": "Translate Fortran to C#:  \n  \n \n \n module tuple\n    implicit none\n    private\n    public :: tuple_t, operator(*), print\n \n    type tuple_t(n)\n        integer, len     :: n\n        integer, private :: v(n)\n    contains\n        procedure, public :: print => print_tuple_t\n        generic, public :: assignment(=) => eq_tuple_t\n        procedure, public :: eq_tuple_t\n    end type tuple_t\n \n    interface print\n        module procedure print_tuple_a_t\n    end interface print\n    interface operator(*)\n        module procedure tup_times_tup\n    end interface\n \n contains\n    subroutine eq_tuple_t(this, src)\n        class(tuple_t(*)), intent(inout) :: this\n        integer, intent(in)              :: src(:)\n        this%v = src\n    end subroutine eq_tuple_t\n\n    pure function tup_times_tup(a, b) result(r)\n        type(tuple_t(*)), intent(in)  :: a\n        type(tuple_t(*)), intent(in)  :: b\n        type(tuple_t(2)), allocatable :: r(:)\n        integer :: i, j, k\n \n        allocate(r(a%n*b%n))\n        k = 0\n        do i=1,a%n\n            do j=1,b%n\n                k = k + 1\n                r(k)%v = [a%v(i),b%v(j)]\n            end do\n        end do\n    end function tup_times_tup\n \n    subroutine print_tuple_t(this)\n        class(tuple_t(*)), intent(in) :: this\n        integer :: i\n        write(*,fmt='(a)',advance='no') '{'\n        do i=1,size(this%v)\n            write(*,fmt='(i0)',advance='no') this%v(i)\n            if (i < size(this%v)) write(*,fmt='(a)',advance='no') ','\n        end do\n        write(*,fmt='(a)',advance='no') '}'\n    end subroutine print_tuple_t\n \n    subroutine print_tuple_a_t(r)\n        type(tuple_t(*)), intent(in) :: r(:)\n        integer :: i\n        write(*,fmt='(a)',advance='no') '{'\n        do i=1,size(r)\n            call r(i)%print\n            if (i < size(r)) write(*,fmt='(a)',advance='no') ','\n        end do\n        write(*,fmt='(a)') '}'\n    end subroutine print_tuple_a_t\n end module tuple\n \n program cartesian_product\n    use tuple\n \n    implicit none\n    type(tuple_t(2)) :: a, b\n    type(tuple_t(0)) :: z\n \n    a = [1,2]\n    b = [3,4]\n \n    call print_product(a, b)\n    call print_product(b, a)\n    call print_product(z, a)\n    call print_product(a, z)\n \n    stop\n contains\n    subroutine print_product(s, t)\n        type(tuple_t(*)), intent(in) :: s\n        type(tuple_t(*)), intent(in) :: t\n        call s%print\n        write(*,fmt='(a)',advance='no') ' x '\n        call t%print\n        write(*,fmt='(a)',advance='no') ' = '\n        call print(s*t)\n    end subroutine print_product\n end program cartesian_product\n", "target": "using System;\npublic class Program\n{\n    public static void Main()\n    {\n        int[] empty = new int[0];\n        int[] list1 = { 1, 2 };\n        int[] list2 = { 3, 4 };\n        int[] list3 = { 1776, 1789 };\n        int[] list4 = { 7, 12 };\n        int[] list5 = { 4, 14, 23 };\n        int[] list6 = { 0, 1 };\n        int[] list7 = { 1, 2, 3 };\n        int[] list8 = { 30 };\n        int[] list9 = { 500, 100 };\n        \n        foreach (var sequenceList in new [] {\n            new [] { list1, list2 },\n            new [] { list2, list1 },\n            new [] { list1, empty },\n            new [] { empty, list1 },\n            new [] { list3, list4, list5, list6 },\n            new [] { list7, list8, list9 },\n            new [] { list7, empty, list9 }\n        }) {\n            var cart = sequenceList.CartesianProduct()\n                .Select(tuple => $\"({string.Join(\", \", tuple)})\");\n            Console.WriteLine($\"{{{string.Join(\", \", cart)}}}\");\n        }\n    }\n}\n\npublic static class Extensions\n{\n    public static IEnumerable<IEnumerable<T>> CartesianProduct<T>(this IEnumerable<IEnumerable<T>> sequences) {\n        IEnumerable<IEnumerable<T>> emptyProduct = new[] { Enumerable.Empty<T>() };\n        return sequences.Aggregate(\n            emptyProduct,\n            (accumulator, sequence) =>\n            from acc in accumulator\n            from item in sequence\n            select acc.Concat(new [] { item }));\n    }\n}\n"}
{"id": 124279, "name": "Cartesian product of two or more lists", "source": "Translate Fortran to Java:  \n  \n \n \n module tuple\n    implicit none\n    private\n    public :: tuple_t, operator(*), print\n \n    type tuple_t(n)\n        integer, len     :: n\n        integer, private :: v(n)\n    contains\n        procedure, public :: print => print_tuple_t\n        generic, public :: assignment(=) => eq_tuple_t\n        procedure, public :: eq_tuple_t\n    end type tuple_t\n \n    interface print\n        module procedure print_tuple_a_t\n    end interface print\n    interface operator(*)\n        module procedure tup_times_tup\n    end interface\n \n contains\n    subroutine eq_tuple_t(this, src)\n        class(tuple_t(*)), intent(inout) :: this\n        integer, intent(in)              :: src(:)\n        this%v = src\n    end subroutine eq_tuple_t\n\n    pure function tup_times_tup(a, b) result(r)\n        type(tuple_t(*)), intent(in)  :: a\n        type(tuple_t(*)), intent(in)  :: b\n        type(tuple_t(2)), allocatable :: r(:)\n        integer :: i, j, k\n \n        allocate(r(a%n*b%n))\n        k = 0\n        do i=1,a%n\n            do j=1,b%n\n                k = k + 1\n                r(k)%v = [a%v(i),b%v(j)]\n            end do\n        end do\n    end function tup_times_tup\n \n    subroutine print_tuple_t(this)\n        class(tuple_t(*)), intent(in) :: this\n        integer :: i\n        write(*,fmt='(a)',advance='no') '{'\n        do i=1,size(this%v)\n            write(*,fmt='(i0)',advance='no') this%v(i)\n            if (i < size(this%v)) write(*,fmt='(a)',advance='no') ','\n        end do\n        write(*,fmt='(a)',advance='no') '}'\n    end subroutine print_tuple_t\n \n    subroutine print_tuple_a_t(r)\n        type(tuple_t(*)), intent(in) :: r(:)\n        integer :: i\n        write(*,fmt='(a)',advance='no') '{'\n        do i=1,size(r)\n            call r(i)%print\n            if (i < size(r)) write(*,fmt='(a)',advance='no') ','\n        end do\n        write(*,fmt='(a)') '}'\n    end subroutine print_tuple_a_t\n end module tuple\n \n program cartesian_product\n    use tuple\n \n    implicit none\n    type(tuple_t(2)) :: a, b\n    type(tuple_t(0)) :: z\n \n    a = [1,2]\n    b = [3,4]\n \n    call print_product(a, b)\n    call print_product(b, a)\n    call print_product(z, a)\n    call print_product(a, z)\n \n    stop\n contains\n    subroutine print_product(s, t)\n        type(tuple_t(*)), intent(in) :: s\n        type(tuple_t(*)), intent(in) :: t\n        call s%print\n        write(*,fmt='(a)',advance='no') ' x '\n        call t%print\n        write(*,fmt='(a)',advance='no') ' = '\n        call print(s*t)\n    end subroutine print_product\n end program cartesian_product\n", "target": "import static java.util.Arrays.asList;\nimport static java.util.Collections.emptyList;\nimport static java.util.Optional.of;\nimport static java.util.stream.Collectors.toList;\n\nimport java.util.List;\n\npublic class CartesianProduct {\n\n    public List<?> product(List<?>... a) {\n        if (a.length >= 2) {\n            List<?> product = a[0];\n            for (int i = 1; i < a.length; i++) {\n                product = product(product, a[i]);\n            }\n            return product;\n        }\n\n        return emptyList();\n    }\n\n    private <A, B> List<?> product(List<A> a, List<B> b) {\n        return of(a.stream()\n                .map(e1 -> of(b.stream().map(e2 -> asList(e1, e2)).collect(toList())).orElse(emptyList()))\n                .flatMap(List::stream)\n                .collect(toList())).orElse(emptyList());\n    }\n}\n"}
{"id": 124280, "name": "Cartesian product of two or more lists", "source": "Translate Fortran to Java:  \n  \n \n \n module tuple\n    implicit none\n    private\n    public :: tuple_t, operator(*), print\n \n    type tuple_t(n)\n        integer, len     :: n\n        integer, private :: v(n)\n    contains\n        procedure, public :: print => print_tuple_t\n        generic, public :: assignment(=) => eq_tuple_t\n        procedure, public :: eq_tuple_t\n    end type tuple_t\n \n    interface print\n        module procedure print_tuple_a_t\n    end interface print\n    interface operator(*)\n        module procedure tup_times_tup\n    end interface\n \n contains\n    subroutine eq_tuple_t(this, src)\n        class(tuple_t(*)), intent(inout) :: this\n        integer, intent(in)              :: src(:)\n        this%v = src\n    end subroutine eq_tuple_t\n\n    pure function tup_times_tup(a, b) result(r)\n        type(tuple_t(*)), intent(in)  :: a\n        type(tuple_t(*)), intent(in)  :: b\n        type(tuple_t(2)), allocatable :: r(:)\n        integer :: i, j, k\n \n        allocate(r(a%n*b%n))\n        k = 0\n        do i=1,a%n\n            do j=1,b%n\n                k = k + 1\n                r(k)%v = [a%v(i),b%v(j)]\n            end do\n        end do\n    end function tup_times_tup\n \n    subroutine print_tuple_t(this)\n        class(tuple_t(*)), intent(in) :: this\n        integer :: i\n        write(*,fmt='(a)',advance='no') '{'\n        do i=1,size(this%v)\n            write(*,fmt='(i0)',advance='no') this%v(i)\n            if (i < size(this%v)) write(*,fmt='(a)',advance='no') ','\n        end do\n        write(*,fmt='(a)',advance='no') '}'\n    end subroutine print_tuple_t\n \n    subroutine print_tuple_a_t(r)\n        type(tuple_t(*)), intent(in) :: r(:)\n        integer :: i\n        write(*,fmt='(a)',advance='no') '{'\n        do i=1,size(r)\n            call r(i)%print\n            if (i < size(r)) write(*,fmt='(a)',advance='no') ','\n        end do\n        write(*,fmt='(a)') '}'\n    end subroutine print_tuple_a_t\n end module tuple\n \n program cartesian_product\n    use tuple\n \n    implicit none\n    type(tuple_t(2)) :: a, b\n    type(tuple_t(0)) :: z\n \n    a = [1,2]\n    b = [3,4]\n \n    call print_product(a, b)\n    call print_product(b, a)\n    call print_product(z, a)\n    call print_product(a, z)\n \n    stop\n contains\n    subroutine print_product(s, t)\n        type(tuple_t(*)), intent(in) :: s\n        type(tuple_t(*)), intent(in) :: t\n        call s%print\n        write(*,fmt='(a)',advance='no') ' x '\n        call t%print\n        write(*,fmt='(a)',advance='no') ' = '\n        call print(s*t)\n    end subroutine print_product\n end program cartesian_product\n", "target": "import static java.util.Arrays.asList;\nimport static java.util.Collections.emptyList;\nimport static java.util.Optional.of;\nimport static java.util.stream.Collectors.toList;\n\nimport java.util.List;\n\npublic class CartesianProduct {\n\n    public List<?> product(List<?>... a) {\n        if (a.length >= 2) {\n            List<?> product = a[0];\n            for (int i = 1; i < a.length; i++) {\n                product = product(product, a[i]);\n            }\n            return product;\n        }\n\n        return emptyList();\n    }\n\n    private <A, B> List<?> product(List<A> a, List<B> b) {\n        return of(a.stream()\n                .map(e1 -> of(b.stream().map(e2 -> asList(e1, e2)).collect(toList())).orElse(emptyList()))\n                .flatMap(List::stream)\n                .collect(toList())).orElse(emptyList());\n    }\n}\n"}
{"id": 124281, "name": "Cartesian product of two or more lists", "source": "Translate Fortran to Python:  \n  \n \n \n module tuple\n    implicit none\n    private\n    public :: tuple_t, operator(*), print\n \n    type tuple_t(n)\n        integer, len     :: n\n        integer, private :: v(n)\n    contains\n        procedure, public :: print => print_tuple_t\n        generic, public :: assignment(=) => eq_tuple_t\n        procedure, public :: eq_tuple_t\n    end type tuple_t\n \n    interface print\n        module procedure print_tuple_a_t\n    end interface print\n    interface operator(*)\n        module procedure tup_times_tup\n    end interface\n \n contains\n    subroutine eq_tuple_t(this, src)\n        class(tuple_t(*)), intent(inout) :: this\n        integer, intent(in)              :: src(:)\n        this%v = src\n    end subroutine eq_tuple_t\n\n    pure function tup_times_tup(a, b) result(r)\n        type(tuple_t(*)), intent(in)  :: a\n        type(tuple_t(*)), intent(in)  :: b\n        type(tuple_t(2)), allocatable :: r(:)\n        integer :: i, j, k\n \n        allocate(r(a%n*b%n))\n        k = 0\n        do i=1,a%n\n            do j=1,b%n\n                k = k + 1\n                r(k)%v = [a%v(i),b%v(j)]\n            end do\n        end do\n    end function tup_times_tup\n \n    subroutine print_tuple_t(this)\n        class(tuple_t(*)), intent(in) :: this\n        integer :: i\n        write(*,fmt='(a)',advance='no') '{'\n        do i=1,size(this%v)\n            write(*,fmt='(i0)',advance='no') this%v(i)\n            if (i < size(this%v)) write(*,fmt='(a)',advance='no') ','\n        end do\n        write(*,fmt='(a)',advance='no') '}'\n    end subroutine print_tuple_t\n \n    subroutine print_tuple_a_t(r)\n        type(tuple_t(*)), intent(in) :: r(:)\n        integer :: i\n        write(*,fmt='(a)',advance='no') '{'\n        do i=1,size(r)\n            call r(i)%print\n            if (i < size(r)) write(*,fmt='(a)',advance='no') ','\n        end do\n        write(*,fmt='(a)') '}'\n    end subroutine print_tuple_a_t\n end module tuple\n \n program cartesian_product\n    use tuple\n \n    implicit none\n    type(tuple_t(2)) :: a, b\n    type(tuple_t(0)) :: z\n \n    a = [1,2]\n    b = [3,4]\n \n    call print_product(a, b)\n    call print_product(b, a)\n    call print_product(z, a)\n    call print_product(a, z)\n \n    stop\n contains\n    subroutine print_product(s, t)\n        type(tuple_t(*)), intent(in) :: s\n        type(tuple_t(*)), intent(in) :: t\n        call s%print\n        write(*,fmt='(a)',advance='no') ' x '\n        call t%print\n        write(*,fmt='(a)',advance='no') ' = '\n        call print(s*t)\n    end subroutine print_product\n end program cartesian_product\n", "target": "import itertools\n\ndef cp(lsts):\n    return list(itertools.product(*lsts))\n\nif __name__ == '__main__':\n    from pprint import pprint as pp\n    \n    for lists in [[[1,2],[3,4]], [[3,4],[1,2]], [[], [1, 2]], [[1, 2], []],\n                  ((1776, 1789),  (7, 12), (4, 14, 23), (0, 1)),\n                  ((1, 2, 3), (30,), (500, 100)),\n                  ((1, 2, 3), (), (500, 100))]:\n        print(lists, '=>')\n        pp(cp(lists), indent=2)\n"}
{"id": 124282, "name": "Cartesian product of two or more lists", "source": "Translate Fortran to Python:  \n  \n \n \n module tuple\n    implicit none\n    private\n    public :: tuple_t, operator(*), print\n \n    type tuple_t(n)\n        integer, len     :: n\n        integer, private :: v(n)\n    contains\n        procedure, public :: print => print_tuple_t\n        generic, public :: assignment(=) => eq_tuple_t\n        procedure, public :: eq_tuple_t\n    end type tuple_t\n \n    interface print\n        module procedure print_tuple_a_t\n    end interface print\n    interface operator(*)\n        module procedure tup_times_tup\n    end interface\n \n contains\n    subroutine eq_tuple_t(this, src)\n        class(tuple_t(*)), intent(inout) :: this\n        integer, intent(in)              :: src(:)\n        this%v = src\n    end subroutine eq_tuple_t\n\n    pure function tup_times_tup(a, b) result(r)\n        type(tuple_t(*)), intent(in)  :: a\n        type(tuple_t(*)), intent(in)  :: b\n        type(tuple_t(2)), allocatable :: r(:)\n        integer :: i, j, k\n \n        allocate(r(a%n*b%n))\n        k = 0\n        do i=1,a%n\n            do j=1,b%n\n                k = k + 1\n                r(k)%v = [a%v(i),b%v(j)]\n            end do\n        end do\n    end function tup_times_tup\n \n    subroutine print_tuple_t(this)\n        class(tuple_t(*)), intent(in) :: this\n        integer :: i\n        write(*,fmt='(a)',advance='no') '{'\n        do i=1,size(this%v)\n            write(*,fmt='(i0)',advance='no') this%v(i)\n            if (i < size(this%v)) write(*,fmt='(a)',advance='no') ','\n        end do\n        write(*,fmt='(a)',advance='no') '}'\n    end subroutine print_tuple_t\n \n    subroutine print_tuple_a_t(r)\n        type(tuple_t(*)), intent(in) :: r(:)\n        integer :: i\n        write(*,fmt='(a)',advance='no') '{'\n        do i=1,size(r)\n            call r(i)%print\n            if (i < size(r)) write(*,fmt='(a)',advance='no') ','\n        end do\n        write(*,fmt='(a)') '}'\n    end subroutine print_tuple_a_t\n end module tuple\n \n program cartesian_product\n    use tuple\n \n    implicit none\n    type(tuple_t(2)) :: a, b\n    type(tuple_t(0)) :: z\n \n    a = [1,2]\n    b = [3,4]\n \n    call print_product(a, b)\n    call print_product(b, a)\n    call print_product(z, a)\n    call print_product(a, z)\n \n    stop\n contains\n    subroutine print_product(s, t)\n        type(tuple_t(*)), intent(in) :: s\n        type(tuple_t(*)), intent(in) :: t\n        call s%print\n        write(*,fmt='(a)',advance='no') ' x '\n        call t%print\n        write(*,fmt='(a)',advance='no') ' = '\n        call print(s*t)\n    end subroutine print_product\n end program cartesian_product\n", "target": "import itertools\n\ndef cp(lsts):\n    return list(itertools.product(*lsts))\n\nif __name__ == '__main__':\n    from pprint import pprint as pp\n    \n    for lists in [[[1,2],[3,4]], [[3,4],[1,2]], [[], [1, 2]], [[1, 2], []],\n                  ((1776, 1789),  (7, 12), (4, 14, 23), (0, 1)),\n                  ((1, 2, 3), (30,), (500, 100)),\n                  ((1, 2, 3), (), (500, 100))]:\n        print(lists, '=>')\n        pp(cp(lists), indent=2)\n"}
{"id": 124710, "name": "Prime decomposition", "source": "Translate Fortran to C#: module PrimeDecompose\n  implicit none\n\n  integer, parameter :: huge = selected_int_kind(18)\n  \n\ncontains\n\n  subroutine find_factors(n, d)\n    integer(huge), intent(in) :: n\n    integer, dimension(:), intent(out) :: d\n\n    integer(huge) :: div, next, rest\n    integer :: i\n\n    i = 1\n    div = 2; next = 3; rest = n\n    \n    do while ( rest /= 1 )\n       do while ( mod(rest, div) == 0 ) \n          d(i) = div\n          i = i + 1\n          rest = rest / div\n       end do\n       div = next\n       next = next + 2\n    end do\n\n  end subroutine find_factors\n\nend module PrimeDecompose\n", "target": "using System;\nusing System.Collections.Generic;\n\nnamespace PrimeDecomposition\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            GetPrimes(12);\n        }\n\n        static List<int> GetPrimes(decimal n)\n        {\n            List<int> storage = new List<int>();\n            while (n > 1)\n            {\n                int i = 1;\n                while (true)\n                {\n                    if (IsPrime(i))\n                    {                        \n                        if (((decimal)n / i) == Math.Round((decimal) n / i))\n                        {\n                            n /= i;\n                            storage.Add(i);                            \n                            break;\n                        }\n                    }\n                    i++;\n                }\n            }\n            return storage;\n        }\n\n        static bool IsPrime(int n)\n        {\n            if (n <= 1) return false;\n            for (int i = 2; i <= Math.Sqrt(n); i++)\n                if (n % i == 0) return false;\n            return true;\n        }\n    }\n}\n"}
{"id": 124714, "name": "Prime decomposition", "source": "Translate Fortran to Java: module PrimeDecompose\n  implicit none\n\n  integer, parameter :: huge = selected_int_kind(18)\n  \n\ncontains\n\n  subroutine find_factors(n, d)\n    integer(huge), intent(in) :: n\n    integer, dimension(:), intent(out) :: d\n\n    integer(huge) :: div, next, rest\n    integer :: i\n\n    i = 1\n    div = 2; next = 3; rest = n\n    \n    do while ( rest /= 1 )\n       do while ( mod(rest, div) == 0 ) \n          d(i) = div\n          i = i + 1\n          rest = rest / div\n       end do\n       div = next\n       next = next + 2\n    end do\n\n  end subroutine find_factors\n\nend module PrimeDecompose\n", "target": "public boolean prime(BigInteger i);\n"}
{"id": 124715, "name": "Prime decomposition", "source": "Translate Fortran to Python: module PrimeDecompose\n  implicit none\n\n  integer, parameter :: huge = selected_int_kind(18)\n  \n\ncontains\n\n  subroutine find_factors(n, d)\n    integer(huge), intent(in) :: n\n    integer, dimension(:), intent(out) :: d\n\n    integer(huge) :: div, next, rest\n    integer :: i\n\n    i = 1\n    div = 2; next = 3; rest = n\n    \n    do while ( rest /= 1 )\n       do while ( mod(rest, div) == 0 ) \n          d(i) = div\n          i = i + 1\n          rest = rest / div\n       end do\n       div = next\n       next = next + 2\n    end do\n\n  end subroutine find_factors\n\nend module PrimeDecompose\n", "target": "from __future__ import print_function\n\nimport sys\nfrom itertools import cycle\n\ndef is_prime(n):\n    return list(zip((True, False), decompose(n)))[-1][0]\n\nclass IsPrimeCached(dict):\n    def __missing__(self, n):\n        r = is_prime(n)\n        self[n] = r\n        return r\n\nis_prime_cached = IsPrimeCached()\n\ndef croft():\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    for p in (2, 3, 5):\n        yield p\n    roots = {}  \n    not_primeroot = tuple(x not in {1,7,11,13,17,19,23,29} for x in range(30))\n    q = 1\n    for x in cycle((6, 4, 2, 4, 2, 4, 6, 2)):\n        \n        q += x\n        \n        \n        if q in roots:\n            p = roots.pop(q)\n            x = q + p\n            while not_primeroot[x % 30] or x in roots:\n                x += p\n            roots[x] = p\n        else:\n            roots[q * q] = q + q\n            yield q\nprimes = croft\n\ndef decompose(n):\n    for p in primes():\n        if p*p > n: break\n        while n % p == 0:\n            yield p\n            n //=p\n    if n > 1:\n        yield n\n\n\nif __name__ == '__main__':\n    \n\n    import time\n\n    for m in primes():\n        p = 2 ** m - 1\n        print( \"2**{0:d}-1 = {1:d}, with factors:\".format(m, p) )\n        start = time.time()\n        for factor in decompose(p):\n            print(factor, end=' ')\n            sys.stdout.flush()\n\n        print( \"=> {0:.2f}s\".format( time.time()-start ) )\n        if m >= 59:\n            break\n"}
{"id": 125030, "name": "Happy numbers", "source": "Translate Fortran to C#: program happy\n\n  implicit none\n  integer, parameter :: find = 8\n  integer :: found\n  integer :: number\n\n  found = 0\n  number = 1\n  do\n    if (found == find) then\n      exit\n    end if\n    if (is_happy (number)) then\n      found = found + 1\n      write (*, '(i0)') number\n    end if\n    number = number + 1\n  end do\n\ncontains\n\n  function sum_digits_squared (number) result (result)\n\n    implicit none\n    integer, intent (in) :: number\n    integer :: result\n    integer :: digit\n    integer :: rest\n    integer :: work\n\n    result = 0\n    work = number\n    do\n      if (work == 0) then\n        exit\n      end if\n      rest = work / 10\n      digit = work - 10 * rest\n      result = result + digit * digit\n      work = rest\n    end do\n\n  end function sum_digits_squared\n\n  function is_happy (number) result (result)\n\n    implicit none\n    integer, intent (in) :: number\n    logical :: result\n    integer :: turtoise\n    integer :: hare\n\n    turtoise = number\n    hare = number\n    do\n      turtoise = sum_digits_squared (turtoise)\n      hare = sum_digits_squared (sum_digits_squared (hare))\n      if (turtoise == hare) then\n        exit\n      end if\n    end do\n    result = turtoise == 1\n\n  end function is_happy\n\nend program happy\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\nnamespace HappyNums\n{\n    class Program\n    {\n        public static bool ishappy(int n)\n        {\n            List<int> cache = new List<int>();\n            int sum = 0;\n            while (n != 1)\n            {\n                if (cache.Contains(n))\n                {\n                    return false;\n                }\n                cache.Add(n);\n                while (n != 0)\n                {\n                    int digit = n % 10;\n                    sum += digit * digit;\n                    n /= 10;\n                }\n                n = sum;\n                sum = 0;\n            }\n           return true;            \n        }\n\n        static void Main(string[] args)\n        {\n            int num = 1;\n            List<int> happynums = new List<int>();\n\n            while (happynums.Count < 8)\n            {\n                if (ishappy(num))\n                {\n                    happynums.Add(num);\n                }\n                num++;\n            }\n            Console.WriteLine(\"First 8 happy numbers\u00a0: \" + string.Join(\",\", happynums));\n        }\n    }\n}\n"}
{"id": 125033, "name": "Happy numbers", "source": "Translate Fortran to Java: program happy\n\n  implicit none\n  integer, parameter :: find = 8\n  integer :: found\n  integer :: number\n\n  found = 0\n  number = 1\n  do\n    if (found == find) then\n      exit\n    end if\n    if (is_happy (number)) then\n      found = found + 1\n      write (*, '(i0)') number\n    end if\n    number = number + 1\n  end do\n\ncontains\n\n  function sum_digits_squared (number) result (result)\n\n    implicit none\n    integer, intent (in) :: number\n    integer :: result\n    integer :: digit\n    integer :: rest\n    integer :: work\n\n    result = 0\n    work = number\n    do\n      if (work == 0) then\n        exit\n      end if\n      rest = work / 10\n      digit = work - 10 * rest\n      result = result + digit * digit\n      work = rest\n    end do\n\n  end function sum_digits_squared\n\n  function is_happy (number) result (result)\n\n    implicit none\n    integer, intent (in) :: number\n    logical :: result\n    integer :: turtoise\n    integer :: hare\n\n    turtoise = number\n    hare = number\n    do\n      turtoise = sum_digits_squared (turtoise)\n      hare = sum_digits_squared (sum_digits_squared (hare))\n      if (turtoise == hare) then\n        exit\n      end if\n    end do\n    result = turtoise == 1\n\n  end function is_happy\n\nend program happy\n", "target": "import java.util.HashSet;\npublic class Happy{\n   public static boolean happy(long number){\n       long m = 0;\n       int digit = 0;\n       HashSet<Long> cycle = new HashSet<Long>();\n       while(number != 1 && cycle.add(number)){\n           m = 0;\n           while(number > 0){\n               digit = (int)(number % 10);\n               m += digit*digit;\n               number /= 10;\n           }\n           number = m;\n       }\n       return number == 1;\n   }\n\n   public static void main(String[] args){\n       for(long num = 1,count = 0;count<8;num++){\n           if(happy(num)){\n               System.out.println(num);\n               count++;\n           }\n       }\n   }\n}\n"}
{"id": 125034, "name": "Happy numbers", "source": "Translate Fortran to Python: program happy\n\n  implicit none\n  integer, parameter :: find = 8\n  integer :: found\n  integer :: number\n\n  found = 0\n  number = 1\n  do\n    if (found == find) then\n      exit\n    end if\n    if (is_happy (number)) then\n      found = found + 1\n      write (*, '(i0)') number\n    end if\n    number = number + 1\n  end do\n\ncontains\n\n  function sum_digits_squared (number) result (result)\n\n    implicit none\n    integer, intent (in) :: number\n    integer :: result\n    integer :: digit\n    integer :: rest\n    integer :: work\n\n    result = 0\n    work = number\n    do\n      if (work == 0) then\n        exit\n      end if\n      rest = work / 10\n      digit = work - 10 * rest\n      result = result + digit * digit\n      work = rest\n    end do\n\n  end function sum_digits_squared\n\n  function is_happy (number) result (result)\n\n    implicit none\n    integer, intent (in) :: number\n    logical :: result\n    integer :: turtoise\n    integer :: hare\n\n    turtoise = number\n    hare = number\n    do\n      turtoise = sum_digits_squared (turtoise)\n      hare = sum_digits_squared (sum_digits_squared (hare))\n      if (turtoise == hare) then\n        exit\n      end if\n    end do\n    result = turtoise == 1\n\n  end function is_happy\n\nend program happy\n", "target": ">>> def happy(n):\n    past = set()\t\t\t\n    while n != 1:\n        n = sum(int(i)**2 for i in str(n))\n        if n in past:\n            return False\n        past.add(n)\n    return True\n\n>>> [x for x in xrange(500) if happy(x)][:8]\n[1, 7, 10, 13, 19, 23, 28, 31]\n"}
{"id": 125305, "name": "Random numbers", "source": "Translate Fortran to C#: PROGRAM Random\n\n  INTEGER, PARAMETER :: n = 1000\n  INTEGER :: i\n  REAL :: array(n), pi, temp, mean = 1.0, sd = 0.5\n\n  pi = 4.0*ATAN(1.0)\n  CALL RANDOM_NUMBER(array) \n \n\n  DO i = 1, n-1, 2\n    temp = sd * SQRT(-2.0*LOG(array(i))) * COS(2*pi*array(i+1)) + mean\n    array(i+1) = sd * SQRT(-2.0*LOG(array(i))) * SIN(2*pi*array(i+1)) + mean\n    array(i) = temp\n  END DO\n\n\n  mean = SUM(array)/n\n  sd = SQRT(SUM((array - mean)**2)/n)\n \n  WRITE(*, \"(A,F8.6)\") \"Mean = \", mean\n  WRITE(*, \"(A,F8.6)\") \"Standard Deviation = \", sd\n\nEND PROGRAM Random\n", "target": "private static double randomNormal()\n{\n\treturn Math.Cos(2 * Math.PI * tRand.NextDouble()) * Math.Sqrt(-2 * Math.Log(tRand.NextDouble()));\n}\n"}
{"id": 125309, "name": "Random numbers", "source": "Translate Fortran to Java: PROGRAM Random\n\n  INTEGER, PARAMETER :: n = 1000\n  INTEGER :: i\n  REAL :: array(n), pi, temp, mean = 1.0, sd = 0.5\n\n  pi = 4.0*ATAN(1.0)\n  CALL RANDOM_NUMBER(array) \n \n\n  DO i = 1, n-1, 2\n    temp = sd * SQRT(-2.0*LOG(array(i))) * COS(2*pi*array(i+1)) + mean\n    array(i+1) = sd * SQRT(-2.0*LOG(array(i))) * SIN(2*pi*array(i+1)) + mean\n    array(i) = temp\n  END DO\n\n\n  mean = SUM(array)/n\n  sd = SQRT(SUM((array - mean)**2)/n)\n \n  WRITE(*, \"(A,F8.6)\") \"Mean = \", mean\n  WRITE(*, \"(A,F8.6)\") \"Standard Deviation = \", sd\n\nEND PROGRAM Random\n", "target": "double[] list = new double[1000];\ndouble mean = 1.0, std = 0.5;\nRandom rng = new Random();\nfor(int i = 0;i<list.length;i++) {\n  list[i] = mean + std * rng.nextGaussian();\n}\n"}
{"id": 125310, "name": "Random numbers", "source": "Translate Fortran to Python: PROGRAM Random\n\n  INTEGER, PARAMETER :: n = 1000\n  INTEGER :: i\n  REAL :: array(n), pi, temp, mean = 1.0, sd = 0.5\n\n  pi = 4.0*ATAN(1.0)\n  CALL RANDOM_NUMBER(array) \n \n\n  DO i = 1, n-1, 2\n    temp = sd * SQRT(-2.0*LOG(array(i))) * COS(2*pi*array(i+1)) + mean\n    array(i+1) = sd * SQRT(-2.0*LOG(array(i))) * SIN(2*pi*array(i+1)) + mean\n    array(i) = temp\n  END DO\n\n\n  mean = SUM(array)/n\n  sd = SQRT(SUM((array - mean)**2)/n)\n \n  WRITE(*, \"(A,F8.6)\") \"Mean = \", mean\n  WRITE(*, \"(A,F8.6)\") \"Standard Deviation = \", sd\n\nEND PROGRAM Random\n", "target": ">>> import random\n>>> values = [random.gauss(1, .5) for i in range(1000)]\n>>>\n"}
{"id": 125535, "name": "Averages_Mean time of day", "source": "Translate Fortran to C#: program mean_time_of_day\n  implicit none\n  integer(kind=4), parameter :: dp = kind(0.0d0)\n\n  type time_t\n    integer(kind=4) :: hours, minutes, seconds\n  end type\n\n  character(len=8), dimension(4), parameter :: times = &\n    (/ '23:00:17', '23:40:20', '00:12:45', '00:17:19' /)\n  real(kind=dp), dimension(size(times)) :: angles\n  real(kind=dp) :: mean\n\n  angles = time_to_angle(str_to_time(times))\n  mean = mean_angle(angles)\n  if (mean < 0) mean = 360 + mean\n\n  write(*, fmt='(I2.2, '':'', I2.2, '':'', I2.2)') angle_to_time(mean)\ncontains\n  real(kind=dp) function mean_angle(angles)\n    real(kind=dp), dimension(:), intent (in) :: angles\n    real(kind=dp) :: x, y\n\n    x = sum(sin(radians(angles)))/size(angles)\n    y = sum(cos(radians(angles)))/size(angles)\n\n    mean_angle = degrees(atan2(x, y))\n  end function\n\n  elemental real(kind=dp) function radians(angle)\n    real(kind=dp), intent (in) :: angle\n    real(kind=dp), parameter :: pi = 4d0*atan(1d0)\n    radians = angle/180*pi\n  end function\n\n  elemental real(kind=dp) function degrees(angle)\n    real(kind=dp), intent (in) :: angle\n    real(kind=dp), parameter :: pi = 4d0*atan(1d0)\n    degrees = 180*angle/pi\n  end function\n\n  elemental type(time_t) function str_to_time(str)\n    character(len=*), intent (in) :: str\n    \n    read(str, fmt='(I2, 1X, I2, 1X, I2)') str_to_time\n  end function\n\n  elemental real(kind=dp) function time_to_angle(time) result (res)\n    type(time_t), intent (in) :: time\n\n    real(kind=dp) :: seconds\n    real(kind=dp), parameter :: seconds_in_day = 24*60*60\n\n    seconds = time%seconds + 60*time%minutes + 60*60*time%hours\n    res = 360*seconds/seconds_in_day\n  end function\n\n  elemental type(time_t) function angle_to_time(angle)\n    real(kind=dp), intent (in) :: angle\n\n    real(kind=dp) :: seconds\n    real(kind=dp), parameter :: seconds_in_day = 24*60*60\n\n    seconds = seconds_in_day*angle/360d0\n    angle_to_time%hours = int(seconds/60d0/60d0)\n    seconds = mod(seconds, 60d0*60d0)\n    angle_to_time%minutes = int(seconds/60d0)\n    angle_to_time%seconds = mod(seconds, 60d0)\n  end function\nend program\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing static System.Math;\n\nnamespace RosettaCode;\n\nclass Program\n{\n    private const int SecondsPerDay = 60 * 60 * 24;\n\n    static void Main()\n    {\n        var digitimes = new List<TimeSpan>();\n\n        Console.WriteLine(\"Enter times, end with no input: \");\n        while (true) {\n            string input = Console.ReadLine();\n            if (string.IsNullOrWhiteSpace(input)) break;\n            if (TimeSpan.TryParse(input, out var digitime)) {\n                digitimes.Add(digitime);\n            } else {\n                Console.WriteLine(\"Seems this is wrong input: ignoring time\");\n            }\n        }\n        if(digitimes.Count() > 0)\n            Console.WriteLine($\"The mean time is\u00a0: {MeanTime(digitimes)}\");\n    }\n\n    public static TimeSpan MeanTime(IEnumerable<TimeSpan> ts) => FromDegrees(MeanAngle(ts.Select(ToDegrees)));\n    public static double ToDegrees(TimeSpan ts) => ts.TotalSeconds * 360d / SecondsPerDay;\n    public static TimeSpan FromDegrees(double degrees) => TimeSpan.FromSeconds((int)(degrees * SecondsPerDay / 360));\n\n    public static double MeanAngle(IEnumerable<double> angles)\n    {\n        var x = angles.Average(a => Cos(a * PI / 180));\n        var y = angles.Average(a => Sin(a * PI / 180));\n        return (Atan2(y, x) * 180 / PI + 360) % 360;\n    }\n}\n"}
{"id": 125539, "name": "Averages_Mean time of day", "source": "Translate Fortran to Java: program mean_time_of_day\n  implicit none\n  integer(kind=4), parameter :: dp = kind(0.0d0)\n\n  type time_t\n    integer(kind=4) :: hours, minutes, seconds\n  end type\n\n  character(len=8), dimension(4), parameter :: times = &\n    (/ '23:00:17', '23:40:20', '00:12:45', '00:17:19' /)\n  real(kind=dp), dimension(size(times)) :: angles\n  real(kind=dp) :: mean\n\n  angles = time_to_angle(str_to_time(times))\n  mean = mean_angle(angles)\n  if (mean < 0) mean = 360 + mean\n\n  write(*, fmt='(I2.2, '':'', I2.2, '':'', I2.2)') angle_to_time(mean)\ncontains\n  real(kind=dp) function mean_angle(angles)\n    real(kind=dp), dimension(:), intent (in) :: angles\n    real(kind=dp) :: x, y\n\n    x = sum(sin(radians(angles)))/size(angles)\n    y = sum(cos(radians(angles)))/size(angles)\n\n    mean_angle = degrees(atan2(x, y))\n  end function\n\n  elemental real(kind=dp) function radians(angle)\n    real(kind=dp), intent (in) :: angle\n    real(kind=dp), parameter :: pi = 4d0*atan(1d0)\n    radians = angle/180*pi\n  end function\n\n  elemental real(kind=dp) function degrees(angle)\n    real(kind=dp), intent (in) :: angle\n    real(kind=dp), parameter :: pi = 4d0*atan(1d0)\n    degrees = 180*angle/pi\n  end function\n\n  elemental type(time_t) function str_to_time(str)\n    character(len=*), intent (in) :: str\n    \n    read(str, fmt='(I2, 1X, I2, 1X, I2)') str_to_time\n  end function\n\n  elemental real(kind=dp) function time_to_angle(time) result (res)\n    type(time_t), intent (in) :: time\n\n    real(kind=dp) :: seconds\n    real(kind=dp), parameter :: seconds_in_day = 24*60*60\n\n    seconds = time%seconds + 60*time%minutes + 60*60*time%hours\n    res = 360*seconds/seconds_in_day\n  end function\n\n  elemental type(time_t) function angle_to_time(angle)\n    real(kind=dp), intent (in) :: angle\n\n    real(kind=dp) :: seconds\n    real(kind=dp), parameter :: seconds_in_day = 24*60*60\n\n    seconds = seconds_in_day*angle/360d0\n    angle_to_time%hours = int(seconds/60d0/60d0)\n    seconds = mod(seconds, 60d0*60d0)\n    angle_to_time%minutes = int(seconds/60d0)\n    angle_to_time%seconds = mod(seconds, 60d0)\n  end function\nend program\n", "target": "public class MeanTimeOfDay {\n    \n    static double meanAngle(double[] angles) {\n        int len = angles.length;\n        double sinSum = 0.0;\n        for (int i = 0; i < len; i++) {\n            sinSum += Math.sin(angles[i] * Math.PI / 180.0);\n        }\n \n        double cosSum = 0.0;\n        for (int i = 0; i < len; i++) {\n            cosSum += Math.cos(angles[i] * Math.PI / 180.0);\n        }\n\n        return Math.atan2(sinSum / len, cosSum / len) * 180.0 / Math.PI;\n    }\n\n    \n    static int timeToSecs(String t) {\n        int hours = Integer.parseInt(t.substring(0, 2));\n        int mins  = Integer.parseInt(t.substring(3, 5));\n        int secs  = Integer.parseInt(t.substring(6, 8));\n        return 3600 * hours + 60 * mins + secs;\n    }\n\n    \n    static double timeToDegrees(String t) {\n        return timeToSecs(t) / 240.0;\n    }\n\n    static String degreesToTime(double d) {\n        if (d < 0.0) d += 360.0;\n        int secs  = (int)(d * 240.0);\n        int hours = secs / 3600;\n        int mins  = secs % 3600;\n        secs = mins % 60;\n        mins /= 60;\n        return String.format(\"%2d:%2d:%2d\", hours, mins, secs);\n    }\n\n    public static void main(String[] args) {\n        String[] tm = {\"23:00:17\", \"23:40:20\", \"00:12:45\", \"00:17:19\"};\n        double[] angles = new double[4];\n        for (int i = 0; i < 4; i++) angles[i] = timeToDegrees(tm[i]);        \n        double mean = meanAngle(angles);\n        System.out.println(\"Average time is\u00a0: \" + degreesToTime(mean));\n    }\n}\n"}
{"id": 125540, "name": "Averages_Mean time of day", "source": "Translate Fortran to Python: program mean_time_of_day\n  implicit none\n  integer(kind=4), parameter :: dp = kind(0.0d0)\n\n  type time_t\n    integer(kind=4) :: hours, minutes, seconds\n  end type\n\n  character(len=8), dimension(4), parameter :: times = &\n    (/ '23:00:17', '23:40:20', '00:12:45', '00:17:19' /)\n  real(kind=dp), dimension(size(times)) :: angles\n  real(kind=dp) :: mean\n\n  angles = time_to_angle(str_to_time(times))\n  mean = mean_angle(angles)\n  if (mean < 0) mean = 360 + mean\n\n  write(*, fmt='(I2.2, '':'', I2.2, '':'', I2.2)') angle_to_time(mean)\ncontains\n  real(kind=dp) function mean_angle(angles)\n    real(kind=dp), dimension(:), intent (in) :: angles\n    real(kind=dp) :: x, y\n\n    x = sum(sin(radians(angles)))/size(angles)\n    y = sum(cos(radians(angles)))/size(angles)\n\n    mean_angle = degrees(atan2(x, y))\n  end function\n\n  elemental real(kind=dp) function radians(angle)\n    real(kind=dp), intent (in) :: angle\n    real(kind=dp), parameter :: pi = 4d0*atan(1d0)\n    radians = angle/180*pi\n  end function\n\n  elemental real(kind=dp) function degrees(angle)\n    real(kind=dp), intent (in) :: angle\n    real(kind=dp), parameter :: pi = 4d0*atan(1d0)\n    degrees = 180*angle/pi\n  end function\n\n  elemental type(time_t) function str_to_time(str)\n    character(len=*), intent (in) :: str\n    \n    read(str, fmt='(I2, 1X, I2, 1X, I2)') str_to_time\n  end function\n\n  elemental real(kind=dp) function time_to_angle(time) result (res)\n    type(time_t), intent (in) :: time\n\n    real(kind=dp) :: seconds\n    real(kind=dp), parameter :: seconds_in_day = 24*60*60\n\n    seconds = time%seconds + 60*time%minutes + 60*60*time%hours\n    res = 360*seconds/seconds_in_day\n  end function\n\n  elemental type(time_t) function angle_to_time(angle)\n    real(kind=dp), intent (in) :: angle\n\n    real(kind=dp) :: seconds\n    real(kind=dp), parameter :: seconds_in_day = 24*60*60\n\n    seconds = seconds_in_day*angle/360d0\n    angle_to_time%hours = int(seconds/60d0/60d0)\n    seconds = mod(seconds, 60d0*60d0)\n    angle_to_time%minutes = int(seconds/60d0)\n    angle_to_time%seconds = mod(seconds, 60d0)\n  end function\nend program\n", "target": "from cmath import rect, phase\nfrom math import radians, degrees\n\n\ndef mean_angle(deg):\n    return degrees(phase(sum(rect(1, radians(d)) for d in deg)/len(deg)))\n\ndef mean_time(times):\n    t = (time.split(':') for time in times)\n    seconds = ((float(s) + int(m) * 60 + int(h) * 3600) \n               for h, m, s in t)\n    day = 24 * 60 * 60\n    to_angles = [s * 360. / day for s in seconds]\n    mean_as_angle = mean_angle(to_angles)\n    mean_seconds = mean_as_angle * day / 360.\n    if mean_seconds < 0:\n        mean_seconds += day\n    h, m = divmod(mean_seconds, 3600)\n    m, s = divmod(m, 60)\n    return '%02i:%02i:%02i' % (h, m, s)\n\n\nif __name__ == '__main__':\n    print( mean_time([\"23:00:17\", \"23:40:20\", \"00:12:45\", \"00:17:19\"]) )\n"}
{"id": 125768, "name": "Convert decimal number to rational", "source": "Translate Fortran to C#:       MODULE PQ\t\n       INTEGER MSG\t\n       CONTAINS\t\t\n        INTEGER FUNCTION GCD(I,J)\t\n         INTEGER I,J\t\n         INTEGER N,M,R\t\n          N = MAX(I,J)\t\n          M = MIN(I,J)\t\n    1     R = MOD(N,M)\t\t\n          IF (R.GT.0) THEN\t\n            N = M\t\t\t\n            M = R\t\t\t\n            IF (R .GT. 1) GO TO 1\t\n          END IF\t\t\t\n          GCD = M\t\t\t\n        END FUNCTION GCD\t\n\n        SUBROUTINE RATIONAL10(X)\n         DOUBLE PRECISION X\t\n         DOUBLE PRECISION R\t\n         INTEGER P,Q\t\t\n         INTEGER F,WHACK\t\n         PARAMETER (WHACK = 10**8)\t\n          P = X*WHACK + 0.5\t\n          Q = WHACK\t\t\n          F = GCD(P,Q)\t\t\n          P = P/F\t\t\n          Q = Q/F\t\t\n          R = DBLE(P)/DBLE(Q)\t\n          WRITE (MSG,1) P,Q,X - R,WHACK\t\n    1     FORMAT (\"x - \",I0,\"/\",I0,T28,\" = \",F18.14,\n     1     \" via multiplication by \",I0)\n        END SUBROUTINE RATIONAL10\t\n\n        SUBROUTINE RATIONAL(X)\t\n         DOUBLE PRECISION X\t\n         DOUBLE PRECISION R,E,BEST\t\n         INTEGER P,Q\t\t\n         INTEGER TRY,F\t\t\n          P = 1 + X\t\n          Q = 1\t\t\n          BEST = X*6\t\n          DO TRY = 1,10000000\t\n            R = DBLE(P)/DBLE(Q)\t\t\n            E = X - R\t\t\t\n            IF (ABS(E) .LE. BEST) THEN\t\n              BEST = ABS(E)*0.125\t\t\n              F = GCD(P,Q)\t\t\t\n              IF (BEST.LT.0.1D0) WRITE (MSG,1) P/F,Q/F,E\t\n    1         FORMAT (\"x - \",I0,\"/\",I0,T28,\" = \",F18.14)\t\n              IF (F.NE.1) WRITE (MSG,*) \"Common factor\n              IF (E.EQ.0) EXIT\t\t\t\n            END IF\t\t\t\n            IF (E.GT.0) THEN\t\n              P = P + CEILING(E*Q)\t\n            ELSE IF (E .LT. 0) THEN\t\n              Q = Q + 1\t\t\t\n            END IF\t\t\n          END DO\t\t\n        END SUBROUTINE RATIONAL\t\n\n        SUBROUTINE RATIONALISE(X,WOT)\t\n         DOUBLE PRECISION X\t\n         CHARACTER*(*) WOT\t\n          WRITE (MSG,*) X,WOT\t\n          CALL RATIONAL10(X)\t\n          CALL RATIONAL(X)\t\n          WRITE (MSG,*)\t\t\n        END SUBROUTINE RATIONALISE\t\n      END MODULE PQ\t\n\n      PROGRAM APPROX\n      USE PQ\n      DOUBLE PRECISION PI,E\n      MSG = 6\n      WRITE (MSG,*) \"Rational numbers near to decimal values.\"\n      WRITE (MSG,*)\n      PI = 1\t\t\n      PI = 4*ATAN(PI)\t\n      E = DEXP(1.0D0)\t\n      CALL RATIONALISE(0.1D0,\"1/10 Repeating in binary..\")\n      CALL RATIONALISE(3.14159D0,\"Pi approx.\")\n      CALL RATIONALISE(PI,\"Pi approximated better.\")\n      CALL RATIONALISE(E,\"e: rational approximations aren't much use.\")\n      CALL RATIONALISE(10.15D0,\"Exact in decimal, recurring in binary.\")\n      WRITE (MSG,*)\n      WRITE (MSG,*) \"Variations on 67/74\"\n      CALL RATIONALISE(0.9054D0,\"67/74 = 0\u00b79(054) repeating in base 10\")\n      CALL RATIONALISE(0.9054054D0,\"Two repeats.\")\n      CALL RATIONALISE(0.9054054054D0,\"Three repeats.\")\n      WRITE (MSG,*)\n      WRITE (MSG,*) \"Variations on 14/27\"\n      CALL RATIONALISE(0.518D0,\"14/27 = 0\u00b7(518) repeating in decimal.\")\n      CALL RATIONALISE(0.519D0,\"Rounded.\")\n      CALL RATIONALISE(0.518518D0,\"Two repeats, truncated.\")\n      CALL RATIONALISE(0.518519D0,\"Two repeats, rounded.\")\n      END\n", "target": "using System;\nusing System.Text;\n\nnamespace RosettaDecimalToFraction\n{\n    public class Fraction\n    {\n        public Int64 Numerator;\n        public Int64 Denominator;\n        public Fraction(double f, Int64 MaximumDenominator = 4096)\n        {\n            \n            \n            Int64 a;\n            var h = new Int64[3] { 0, 1, 0 };\n            var k = new Int64[3] { 1, 0, 0 };\n            Int64 x, d, n = 1;\n            int i, neg = 0;\n\n            if (MaximumDenominator <= 1)\n            {\n                Denominator = 1;\n                Numerator = (Int64)f;\n                return;\n            }\n\n            if (f < 0) { neg = 1; f = -f; }\n\n            while (f != Math.Floor(f)) { n <<= 1; f *= 2; }\n            d = (Int64)f;\n\n            \n            for (i = 0; i < 64; i++)\n            {\n                a = (n != 0) ? d / n : 0;\n                if ((i != 0) && (a == 0)) break;\n\n                x = d; d = n; n = x % n;\n\n                x = a;\n                if (k[1] * a + k[0] >= MaximumDenominator)\n                {\n                    x = (MaximumDenominator - k[0]) / k[1];\n                    if (x * 2 >= a || k[1] >= MaximumDenominator)\n                        i = 65;\n                    else\n                        break;\n                }\n\n                h[2] = x * h[1] + h[0]; h[0] = h[1]; h[1] = h[2];\n                k[2] = x * k[1] + k[0]; k[0] = k[1]; k[1] = k[2];\n            }\n            Denominator = k[1];\n            Numerator = neg != 0 ? -h[1] : h[1];\n        }\n        public override string ToString()\n        {\n            return string.Format(\"{0} / {1}\", Numerator, Denominator);\n        }\n    }\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            Console.OutputEncoding = UTF8Encoding.UTF8;\n            foreach (double d in new double[] { 0.9054054, 0.518518, 0.75, 0.4285714, 0.833333,\n                0.90909, 3.14159265358979, 2.7182818284590451 })\n            {\n                var f = new Fraction(d, d >= 2 ? 65536 : 4096);\n                Console.WriteLine(\"{0,20} \u2192 {1}\", d, f);\n\n            }\n        }\n    }\n}\n"}
{"id": 125769, "name": "Convert decimal number to rational", "source": "Translate Fortran to C#:       MODULE PQ\t\n       INTEGER MSG\t\n       CONTAINS\t\t\n        INTEGER FUNCTION GCD(I,J)\t\n         INTEGER I,J\t\n         INTEGER N,M,R\t\n          N = MAX(I,J)\t\n          M = MIN(I,J)\t\n    1     R = MOD(N,M)\t\t\n          IF (R.GT.0) THEN\t\n            N = M\t\t\t\n            M = R\t\t\t\n            IF (R .GT. 1) GO TO 1\t\n          END IF\t\t\t\n          GCD = M\t\t\t\n        END FUNCTION GCD\t\n\n        SUBROUTINE RATIONAL10(X)\n         DOUBLE PRECISION X\t\n         DOUBLE PRECISION R\t\n         INTEGER P,Q\t\t\n         INTEGER F,WHACK\t\n         PARAMETER (WHACK = 10**8)\t\n          P = X*WHACK + 0.5\t\n          Q = WHACK\t\t\n          F = GCD(P,Q)\t\t\n          P = P/F\t\t\n          Q = Q/F\t\t\n          R = DBLE(P)/DBLE(Q)\t\n          WRITE (MSG,1) P,Q,X - R,WHACK\t\n    1     FORMAT (\"x - \",I0,\"/\",I0,T28,\" = \",F18.14,\n     1     \" via multiplication by \",I0)\n        END SUBROUTINE RATIONAL10\t\n\n        SUBROUTINE RATIONAL(X)\t\n         DOUBLE PRECISION X\t\n         DOUBLE PRECISION R,E,BEST\t\n         INTEGER P,Q\t\t\n         INTEGER TRY,F\t\t\n          P = 1 + X\t\n          Q = 1\t\t\n          BEST = X*6\t\n          DO TRY = 1,10000000\t\n            R = DBLE(P)/DBLE(Q)\t\t\n            E = X - R\t\t\t\n            IF (ABS(E) .LE. BEST) THEN\t\n              BEST = ABS(E)*0.125\t\t\n              F = GCD(P,Q)\t\t\t\n              IF (BEST.LT.0.1D0) WRITE (MSG,1) P/F,Q/F,E\t\n    1         FORMAT (\"x - \",I0,\"/\",I0,T28,\" = \",F18.14)\t\n              IF (F.NE.1) WRITE (MSG,*) \"Common factor\n              IF (E.EQ.0) EXIT\t\t\t\n            END IF\t\t\t\n            IF (E.GT.0) THEN\t\n              P = P + CEILING(E*Q)\t\n            ELSE IF (E .LT. 0) THEN\t\n              Q = Q + 1\t\t\t\n            END IF\t\t\n          END DO\t\t\n        END SUBROUTINE RATIONAL\t\n\n        SUBROUTINE RATIONALISE(X,WOT)\t\n         DOUBLE PRECISION X\t\n         CHARACTER*(*) WOT\t\n          WRITE (MSG,*) X,WOT\t\n          CALL RATIONAL10(X)\t\n          CALL RATIONAL(X)\t\n          WRITE (MSG,*)\t\t\n        END SUBROUTINE RATIONALISE\t\n      END MODULE PQ\t\n\n      PROGRAM APPROX\n      USE PQ\n      DOUBLE PRECISION PI,E\n      MSG = 6\n      WRITE (MSG,*) \"Rational numbers near to decimal values.\"\n      WRITE (MSG,*)\n      PI = 1\t\t\n      PI = 4*ATAN(PI)\t\n      E = DEXP(1.0D0)\t\n      CALL RATIONALISE(0.1D0,\"1/10 Repeating in binary..\")\n      CALL RATIONALISE(3.14159D0,\"Pi approx.\")\n      CALL RATIONALISE(PI,\"Pi approximated better.\")\n      CALL RATIONALISE(E,\"e: rational approximations aren't much use.\")\n      CALL RATIONALISE(10.15D0,\"Exact in decimal, recurring in binary.\")\n      WRITE (MSG,*)\n      WRITE (MSG,*) \"Variations on 67/74\"\n      CALL RATIONALISE(0.9054D0,\"67/74 = 0\u00b79(054) repeating in base 10\")\n      CALL RATIONALISE(0.9054054D0,\"Two repeats.\")\n      CALL RATIONALISE(0.9054054054D0,\"Three repeats.\")\n      WRITE (MSG,*)\n      WRITE (MSG,*) \"Variations on 14/27\"\n      CALL RATIONALISE(0.518D0,\"14/27 = 0\u00b7(518) repeating in decimal.\")\n      CALL RATIONALISE(0.519D0,\"Rounded.\")\n      CALL RATIONALISE(0.518518D0,\"Two repeats, truncated.\")\n      CALL RATIONALISE(0.518519D0,\"Two repeats, rounded.\")\n      END\n", "target": "using System;\nusing System.Text;\n\nnamespace RosettaDecimalToFraction\n{\n    public class Fraction\n    {\n        public Int64 Numerator;\n        public Int64 Denominator;\n        public Fraction(double f, Int64 MaximumDenominator = 4096)\n        {\n            \n            \n            Int64 a;\n            var h = new Int64[3] { 0, 1, 0 };\n            var k = new Int64[3] { 1, 0, 0 };\n            Int64 x, d, n = 1;\n            int i, neg = 0;\n\n            if (MaximumDenominator <= 1)\n            {\n                Denominator = 1;\n                Numerator = (Int64)f;\n                return;\n            }\n\n            if (f < 0) { neg = 1; f = -f; }\n\n            while (f != Math.Floor(f)) { n <<= 1; f *= 2; }\n            d = (Int64)f;\n\n            \n            for (i = 0; i < 64; i++)\n            {\n                a = (n != 0) ? d / n : 0;\n                if ((i != 0) && (a == 0)) break;\n\n                x = d; d = n; n = x % n;\n\n                x = a;\n                if (k[1] * a + k[0] >= MaximumDenominator)\n                {\n                    x = (MaximumDenominator - k[0]) / k[1];\n                    if (x * 2 >= a || k[1] >= MaximumDenominator)\n                        i = 65;\n                    else\n                        break;\n                }\n\n                h[2] = x * h[1] + h[0]; h[0] = h[1]; h[1] = h[2];\n                k[2] = x * k[1] + k[0]; k[0] = k[1]; k[1] = k[2];\n            }\n            Denominator = k[1];\n            Numerator = neg != 0 ? -h[1] : h[1];\n        }\n        public override string ToString()\n        {\n            return string.Format(\"{0} / {1}\", Numerator, Denominator);\n        }\n    }\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            Console.OutputEncoding = UTF8Encoding.UTF8;\n            foreach (double d in new double[] { 0.9054054, 0.518518, 0.75, 0.4285714, 0.833333,\n                0.90909, 3.14159265358979, 2.7182818284590451 })\n            {\n                var f = new Fraction(d, d >= 2 ? 65536 : 4096);\n                Console.WriteLine(\"{0,20} \u2192 {1}\", d, f);\n\n            }\n        }\n    }\n}\n"}
{"id": 125773, "name": "Convert decimal number to rational", "source": "Translate Fortran to Java:       MODULE PQ\t\n       INTEGER MSG\t\n       CONTAINS\t\t\n        INTEGER FUNCTION GCD(I,J)\t\n         INTEGER I,J\t\n         INTEGER N,M,R\t\n          N = MAX(I,J)\t\n          M = MIN(I,J)\t\n    1     R = MOD(N,M)\t\t\n          IF (R.GT.0) THEN\t\n            N = M\t\t\t\n            M = R\t\t\t\n            IF (R .GT. 1) GO TO 1\t\n          END IF\t\t\t\n          GCD = M\t\t\t\n        END FUNCTION GCD\t\n\n        SUBROUTINE RATIONAL10(X)\n         DOUBLE PRECISION X\t\n         DOUBLE PRECISION R\t\n         INTEGER P,Q\t\t\n         INTEGER F,WHACK\t\n         PARAMETER (WHACK = 10**8)\t\n          P = X*WHACK + 0.5\t\n          Q = WHACK\t\t\n          F = GCD(P,Q)\t\t\n          P = P/F\t\t\n          Q = Q/F\t\t\n          R = DBLE(P)/DBLE(Q)\t\n          WRITE (MSG,1) P,Q,X - R,WHACK\t\n    1     FORMAT (\"x - \",I0,\"/\",I0,T28,\" = \",F18.14,\n     1     \" via multiplication by \",I0)\n        END SUBROUTINE RATIONAL10\t\n\n        SUBROUTINE RATIONAL(X)\t\n         DOUBLE PRECISION X\t\n         DOUBLE PRECISION R,E,BEST\t\n         INTEGER P,Q\t\t\n         INTEGER TRY,F\t\t\n          P = 1 + X\t\n          Q = 1\t\t\n          BEST = X*6\t\n          DO TRY = 1,10000000\t\n            R = DBLE(P)/DBLE(Q)\t\t\n            E = X - R\t\t\t\n            IF (ABS(E) .LE. BEST) THEN\t\n              BEST = ABS(E)*0.125\t\t\n              F = GCD(P,Q)\t\t\t\n              IF (BEST.LT.0.1D0) WRITE (MSG,1) P/F,Q/F,E\t\n    1         FORMAT (\"x - \",I0,\"/\",I0,T28,\" = \",F18.14)\t\n              IF (F.NE.1) WRITE (MSG,*) \"Common factor\n              IF (E.EQ.0) EXIT\t\t\t\n            END IF\t\t\t\n            IF (E.GT.0) THEN\t\n              P = P + CEILING(E*Q)\t\n            ELSE IF (E .LT. 0) THEN\t\n              Q = Q + 1\t\t\t\n            END IF\t\t\n          END DO\t\t\n        END SUBROUTINE RATIONAL\t\n\n        SUBROUTINE RATIONALISE(X,WOT)\t\n         DOUBLE PRECISION X\t\n         CHARACTER*(*) WOT\t\n          WRITE (MSG,*) X,WOT\t\n          CALL RATIONAL10(X)\t\n          CALL RATIONAL(X)\t\n          WRITE (MSG,*)\t\t\n        END SUBROUTINE RATIONALISE\t\n      END MODULE PQ\t\n\n      PROGRAM APPROX\n      USE PQ\n      DOUBLE PRECISION PI,E\n      MSG = 6\n      WRITE (MSG,*) \"Rational numbers near to decimal values.\"\n      WRITE (MSG,*)\n      PI = 1\t\t\n      PI = 4*ATAN(PI)\t\n      E = DEXP(1.0D0)\t\n      CALL RATIONALISE(0.1D0,\"1/10 Repeating in binary..\")\n      CALL RATIONALISE(3.14159D0,\"Pi approx.\")\n      CALL RATIONALISE(PI,\"Pi approximated better.\")\n      CALL RATIONALISE(E,\"e: rational approximations aren't much use.\")\n      CALL RATIONALISE(10.15D0,\"Exact in decimal, recurring in binary.\")\n      WRITE (MSG,*)\n      WRITE (MSG,*) \"Variations on 67/74\"\n      CALL RATIONALISE(0.9054D0,\"67/74 = 0\u00b79(054) repeating in base 10\")\n      CALL RATIONALISE(0.9054054D0,\"Two repeats.\")\n      CALL RATIONALISE(0.9054054054D0,\"Three repeats.\")\n      WRITE (MSG,*)\n      WRITE (MSG,*) \"Variations on 14/27\"\n      CALL RATIONALISE(0.518D0,\"14/27 = 0\u00b7(518) repeating in decimal.\")\n      CALL RATIONALISE(0.519D0,\"Rounded.\")\n      CALL RATIONALISE(0.518518D0,\"Two repeats, truncated.\")\n      CALL RATIONALISE(0.518519D0,\"Two repeats, rounded.\")\n      END\n", "target": "import org.apache.commons.math3.fraction.BigFraction;\n\npublic class Test {\n\n    public static void main(String[] args) {\n        double[] n = {0.750000000, 0.518518000, 0.905405400, 0.142857143,\n            3.141592654, 2.718281828, -0.423310825, 31.415926536};\n\n        for (double d : n)\n            System.out.printf(\"%-12s\u00a0: %s%n\", d, new BigFraction(d, 0.00000002D, 10000));\n    }\n}\n"}
{"id": 125774, "name": "Convert decimal number to rational", "source": "Translate Fortran to Java:       MODULE PQ\t\n       INTEGER MSG\t\n       CONTAINS\t\t\n        INTEGER FUNCTION GCD(I,J)\t\n         INTEGER I,J\t\n         INTEGER N,M,R\t\n          N = MAX(I,J)\t\n          M = MIN(I,J)\t\n    1     R = MOD(N,M)\t\t\n          IF (R.GT.0) THEN\t\n            N = M\t\t\t\n            M = R\t\t\t\n            IF (R .GT. 1) GO TO 1\t\n          END IF\t\t\t\n          GCD = M\t\t\t\n        END FUNCTION GCD\t\n\n        SUBROUTINE RATIONAL10(X)\n         DOUBLE PRECISION X\t\n         DOUBLE PRECISION R\t\n         INTEGER P,Q\t\t\n         INTEGER F,WHACK\t\n         PARAMETER (WHACK = 10**8)\t\n          P = X*WHACK + 0.5\t\n          Q = WHACK\t\t\n          F = GCD(P,Q)\t\t\n          P = P/F\t\t\n          Q = Q/F\t\t\n          R = DBLE(P)/DBLE(Q)\t\n          WRITE (MSG,1) P,Q,X - R,WHACK\t\n    1     FORMAT (\"x - \",I0,\"/\",I0,T28,\" = \",F18.14,\n     1     \" via multiplication by \",I0)\n        END SUBROUTINE RATIONAL10\t\n\n        SUBROUTINE RATIONAL(X)\t\n         DOUBLE PRECISION X\t\n         DOUBLE PRECISION R,E,BEST\t\n         INTEGER P,Q\t\t\n         INTEGER TRY,F\t\t\n          P = 1 + X\t\n          Q = 1\t\t\n          BEST = X*6\t\n          DO TRY = 1,10000000\t\n            R = DBLE(P)/DBLE(Q)\t\t\n            E = X - R\t\t\t\n            IF (ABS(E) .LE. BEST) THEN\t\n              BEST = ABS(E)*0.125\t\t\n              F = GCD(P,Q)\t\t\t\n              IF (BEST.LT.0.1D0) WRITE (MSG,1) P/F,Q/F,E\t\n    1         FORMAT (\"x - \",I0,\"/\",I0,T28,\" = \",F18.14)\t\n              IF (F.NE.1) WRITE (MSG,*) \"Common factor\n              IF (E.EQ.0) EXIT\t\t\t\n            END IF\t\t\t\n            IF (E.GT.0) THEN\t\n              P = P + CEILING(E*Q)\t\n            ELSE IF (E .LT. 0) THEN\t\n              Q = Q + 1\t\t\t\n            END IF\t\t\n          END DO\t\t\n        END SUBROUTINE RATIONAL\t\n\n        SUBROUTINE RATIONALISE(X,WOT)\t\n         DOUBLE PRECISION X\t\n         CHARACTER*(*) WOT\t\n          WRITE (MSG,*) X,WOT\t\n          CALL RATIONAL10(X)\t\n          CALL RATIONAL(X)\t\n          WRITE (MSG,*)\t\t\n        END SUBROUTINE RATIONALISE\t\n      END MODULE PQ\t\n\n      PROGRAM APPROX\n      USE PQ\n      DOUBLE PRECISION PI,E\n      MSG = 6\n      WRITE (MSG,*) \"Rational numbers near to decimal values.\"\n      WRITE (MSG,*)\n      PI = 1\t\t\n      PI = 4*ATAN(PI)\t\n      E = DEXP(1.0D0)\t\n      CALL RATIONALISE(0.1D0,\"1/10 Repeating in binary..\")\n      CALL RATIONALISE(3.14159D0,\"Pi approx.\")\n      CALL RATIONALISE(PI,\"Pi approximated better.\")\n      CALL RATIONALISE(E,\"e: rational approximations aren't much use.\")\n      CALL RATIONALISE(10.15D0,\"Exact in decimal, recurring in binary.\")\n      WRITE (MSG,*)\n      WRITE (MSG,*) \"Variations on 67/74\"\n      CALL RATIONALISE(0.9054D0,\"67/74 = 0\u00b79(054) repeating in base 10\")\n      CALL RATIONALISE(0.9054054D0,\"Two repeats.\")\n      CALL RATIONALISE(0.9054054054D0,\"Three repeats.\")\n      WRITE (MSG,*)\n      WRITE (MSG,*) \"Variations on 14/27\"\n      CALL RATIONALISE(0.518D0,\"14/27 = 0\u00b7(518) repeating in decimal.\")\n      CALL RATIONALISE(0.519D0,\"Rounded.\")\n      CALL RATIONALISE(0.518518D0,\"Two repeats, truncated.\")\n      CALL RATIONALISE(0.518519D0,\"Two repeats, rounded.\")\n      END\n", "target": "import org.apache.commons.math3.fraction.BigFraction;\n\npublic class Test {\n\n    public static void main(String[] args) {\n        double[] n = {0.750000000, 0.518518000, 0.905405400, 0.142857143,\n            3.141592654, 2.718281828, -0.423310825, 31.415926536};\n\n        for (double d : n)\n            System.out.printf(\"%-12s\u00a0: %s%n\", d, new BigFraction(d, 0.00000002D, 10000));\n    }\n}\n"}
{"id": 125775, "name": "Convert decimal number to rational", "source": "Translate Fortran to Python:       MODULE PQ\t\n       INTEGER MSG\t\n       CONTAINS\t\t\n        INTEGER FUNCTION GCD(I,J)\t\n         INTEGER I,J\t\n         INTEGER N,M,R\t\n          N = MAX(I,J)\t\n          M = MIN(I,J)\t\n    1     R = MOD(N,M)\t\t\n          IF (R.GT.0) THEN\t\n            N = M\t\t\t\n            M = R\t\t\t\n            IF (R .GT. 1) GO TO 1\t\n          END IF\t\t\t\n          GCD = M\t\t\t\n        END FUNCTION GCD\t\n\n        SUBROUTINE RATIONAL10(X)\n         DOUBLE PRECISION X\t\n         DOUBLE PRECISION R\t\n         INTEGER P,Q\t\t\n         INTEGER F,WHACK\t\n         PARAMETER (WHACK = 10**8)\t\n          P = X*WHACK + 0.5\t\n          Q = WHACK\t\t\n          F = GCD(P,Q)\t\t\n          P = P/F\t\t\n          Q = Q/F\t\t\n          R = DBLE(P)/DBLE(Q)\t\n          WRITE (MSG,1) P,Q,X - R,WHACK\t\n    1     FORMAT (\"x - \",I0,\"/\",I0,T28,\" = \",F18.14,\n     1     \" via multiplication by \",I0)\n        END SUBROUTINE RATIONAL10\t\n\n        SUBROUTINE RATIONAL(X)\t\n         DOUBLE PRECISION X\t\n         DOUBLE PRECISION R,E,BEST\t\n         INTEGER P,Q\t\t\n         INTEGER TRY,F\t\t\n          P = 1 + X\t\n          Q = 1\t\t\n          BEST = X*6\t\n          DO TRY = 1,10000000\t\n            R = DBLE(P)/DBLE(Q)\t\t\n            E = X - R\t\t\t\n            IF (ABS(E) .LE. BEST) THEN\t\n              BEST = ABS(E)*0.125\t\t\n              F = GCD(P,Q)\t\t\t\n              IF (BEST.LT.0.1D0) WRITE (MSG,1) P/F,Q/F,E\t\n    1         FORMAT (\"x - \",I0,\"/\",I0,T28,\" = \",F18.14)\t\n              IF (F.NE.1) WRITE (MSG,*) \"Common factor\n              IF (E.EQ.0) EXIT\t\t\t\n            END IF\t\t\t\n            IF (E.GT.0) THEN\t\n              P = P + CEILING(E*Q)\t\n            ELSE IF (E .LT. 0) THEN\t\n              Q = Q + 1\t\t\t\n            END IF\t\t\n          END DO\t\t\n        END SUBROUTINE RATIONAL\t\n\n        SUBROUTINE RATIONALISE(X,WOT)\t\n         DOUBLE PRECISION X\t\n         CHARACTER*(*) WOT\t\n          WRITE (MSG,*) X,WOT\t\n          CALL RATIONAL10(X)\t\n          CALL RATIONAL(X)\t\n          WRITE (MSG,*)\t\t\n        END SUBROUTINE RATIONALISE\t\n      END MODULE PQ\t\n\n      PROGRAM APPROX\n      USE PQ\n      DOUBLE PRECISION PI,E\n      MSG = 6\n      WRITE (MSG,*) \"Rational numbers near to decimal values.\"\n      WRITE (MSG,*)\n      PI = 1\t\t\n      PI = 4*ATAN(PI)\t\n      E = DEXP(1.0D0)\t\n      CALL RATIONALISE(0.1D0,\"1/10 Repeating in binary..\")\n      CALL RATIONALISE(3.14159D0,\"Pi approx.\")\n      CALL RATIONALISE(PI,\"Pi approximated better.\")\n      CALL RATIONALISE(E,\"e: rational approximations aren't much use.\")\n      CALL RATIONALISE(10.15D0,\"Exact in decimal, recurring in binary.\")\n      WRITE (MSG,*)\n      WRITE (MSG,*) \"Variations on 67/74\"\n      CALL RATIONALISE(0.9054D0,\"67/74 = 0\u00b79(054) repeating in base 10\")\n      CALL RATIONALISE(0.9054054D0,\"Two repeats.\")\n      CALL RATIONALISE(0.9054054054D0,\"Three repeats.\")\n      WRITE (MSG,*)\n      WRITE (MSG,*) \"Variations on 14/27\"\n      CALL RATIONALISE(0.518D0,\"14/27 = 0\u00b7(518) repeating in decimal.\")\n      CALL RATIONALISE(0.519D0,\"Rounded.\")\n      CALL RATIONALISE(0.518518D0,\"Two repeats, truncated.\")\n      CALL RATIONALISE(0.518519D0,\"Two repeats, rounded.\")\n      END\n", "target": ">>> from fractions import Fraction\n>>> for d in (0.9054054, 0.518518, 0.75): print(d, Fraction.from_float(d).limit_denominator(100))\n\n0.9054054 67/74\n0.518518 14/27\n0.75 3/4\n>>> for d in '0.9054054 0.518518 0.75'.split(): print(d, Fraction(d))\n\n0.9054054 4527027/5000000\n0.518518 259259/500000\n0.75 3/4\n>>>\n"}
{"id": 125776, "name": "Convert decimal number to rational", "source": "Translate Fortran to Python:       MODULE PQ\t\n       INTEGER MSG\t\n       CONTAINS\t\t\n        INTEGER FUNCTION GCD(I,J)\t\n         INTEGER I,J\t\n         INTEGER N,M,R\t\n          N = MAX(I,J)\t\n          M = MIN(I,J)\t\n    1     R = MOD(N,M)\t\t\n          IF (R.GT.0) THEN\t\n            N = M\t\t\t\n            M = R\t\t\t\n            IF (R .GT. 1) GO TO 1\t\n          END IF\t\t\t\n          GCD = M\t\t\t\n        END FUNCTION GCD\t\n\n        SUBROUTINE RATIONAL10(X)\n         DOUBLE PRECISION X\t\n         DOUBLE PRECISION R\t\n         INTEGER P,Q\t\t\n         INTEGER F,WHACK\t\n         PARAMETER (WHACK = 10**8)\t\n          P = X*WHACK + 0.5\t\n          Q = WHACK\t\t\n          F = GCD(P,Q)\t\t\n          P = P/F\t\t\n          Q = Q/F\t\t\n          R = DBLE(P)/DBLE(Q)\t\n          WRITE (MSG,1) P,Q,X - R,WHACK\t\n    1     FORMAT (\"x - \",I0,\"/\",I0,T28,\" = \",F18.14,\n     1     \" via multiplication by \",I0)\n        END SUBROUTINE RATIONAL10\t\n\n        SUBROUTINE RATIONAL(X)\t\n         DOUBLE PRECISION X\t\n         DOUBLE PRECISION R,E,BEST\t\n         INTEGER P,Q\t\t\n         INTEGER TRY,F\t\t\n          P = 1 + X\t\n          Q = 1\t\t\n          BEST = X*6\t\n          DO TRY = 1,10000000\t\n            R = DBLE(P)/DBLE(Q)\t\t\n            E = X - R\t\t\t\n            IF (ABS(E) .LE. BEST) THEN\t\n              BEST = ABS(E)*0.125\t\t\n              F = GCD(P,Q)\t\t\t\n              IF (BEST.LT.0.1D0) WRITE (MSG,1) P/F,Q/F,E\t\n    1         FORMAT (\"x - \",I0,\"/\",I0,T28,\" = \",F18.14)\t\n              IF (F.NE.1) WRITE (MSG,*) \"Common factor\n              IF (E.EQ.0) EXIT\t\t\t\n            END IF\t\t\t\n            IF (E.GT.0) THEN\t\n              P = P + CEILING(E*Q)\t\n            ELSE IF (E .LT. 0) THEN\t\n              Q = Q + 1\t\t\t\n            END IF\t\t\n          END DO\t\t\n        END SUBROUTINE RATIONAL\t\n\n        SUBROUTINE RATIONALISE(X,WOT)\t\n         DOUBLE PRECISION X\t\n         CHARACTER*(*) WOT\t\n          WRITE (MSG,*) X,WOT\t\n          CALL RATIONAL10(X)\t\n          CALL RATIONAL(X)\t\n          WRITE (MSG,*)\t\t\n        END SUBROUTINE RATIONALISE\t\n      END MODULE PQ\t\n\n      PROGRAM APPROX\n      USE PQ\n      DOUBLE PRECISION PI,E\n      MSG = 6\n      WRITE (MSG,*) \"Rational numbers near to decimal values.\"\n      WRITE (MSG,*)\n      PI = 1\t\t\n      PI = 4*ATAN(PI)\t\n      E = DEXP(1.0D0)\t\n      CALL RATIONALISE(0.1D0,\"1/10 Repeating in binary..\")\n      CALL RATIONALISE(3.14159D0,\"Pi approx.\")\n      CALL RATIONALISE(PI,\"Pi approximated better.\")\n      CALL RATIONALISE(E,\"e: rational approximations aren't much use.\")\n      CALL RATIONALISE(10.15D0,\"Exact in decimal, recurring in binary.\")\n      WRITE (MSG,*)\n      WRITE (MSG,*) \"Variations on 67/74\"\n      CALL RATIONALISE(0.9054D0,\"67/74 = 0\u00b79(054) repeating in base 10\")\n      CALL RATIONALISE(0.9054054D0,\"Two repeats.\")\n      CALL RATIONALISE(0.9054054054D0,\"Three repeats.\")\n      WRITE (MSG,*)\n      WRITE (MSG,*) \"Variations on 14/27\"\n      CALL RATIONALISE(0.518D0,\"14/27 = 0\u00b7(518) repeating in decimal.\")\n      CALL RATIONALISE(0.519D0,\"Rounded.\")\n      CALL RATIONALISE(0.518518D0,\"Two repeats, truncated.\")\n      CALL RATIONALISE(0.518519D0,\"Two repeats, rounded.\")\n      END\n", "target": ">>> from fractions import Fraction\n>>> for d in (0.9054054, 0.518518, 0.75): print(d, Fraction.from_float(d).limit_denominator(100))\n\n0.9054054 67/74\n0.518518 14/27\n0.75 3/4\n>>> for d in '0.9054054 0.518518 0.75'.split(): print(d, Fraction(d))\n\n0.9054054 4527027/5000000\n0.518518 259259/500000\n0.75 3/4\n>>>\n"}
{"id": 126459, "name": "Singly-linked list_Element insertion", "source": "Translate Fortran to C#: elemental subroutine addAfter(nodeBefore,value)\n   type (node), intent(inout) :: nodeBefore\n   real, intent(in)           :: value\n   type (node), pointer       :: newNode\n   \n   allocate(newNode)\n   newNode%data = value\n   newNode%next => nodeBefore%next\n   nodeBefore%next => newNode\nend subroutine addAfter\n", "target": "static void InsertAfter<T>(LinkedListNode<T> prev, T value)\n{\n    prev.Next = new Link() { Value = value, Next = prev.Next };\n}\n"}
{"id": 126463, "name": "Singly-linked list_Element insertion", "source": "Translate Fortran to Java: elemental subroutine addAfter(nodeBefore,value)\n   type (node), intent(inout) :: nodeBefore\n   real, intent(in)           :: value\n   type (node), pointer       :: newNode\n   \n   allocate(newNode)\n   newNode%data = value\n   newNode%next => nodeBefore%next\n   nodeBefore%next => newNode\nend subroutine addAfter\n", "target": "void insertNode(Node<T> anchor_node, Node<T> new_node)\n{\n    new_node.next = anchor_node.next;\n    anchor_node.next = new_node;\n}\n"}
{"id": 126464, "name": "Singly-linked list_Element insertion", "source": "Translate Fortran to Python: elemental subroutine addAfter(nodeBefore,value)\n   type (node), intent(inout) :: nodeBefore\n   real, intent(in)           :: value\n   type (node), pointer       :: newNode\n   \n   allocate(newNode)\n   newNode%data = value\n   newNode%next => nodeBefore%next\n   nodeBefore%next => newNode\nend subroutine addAfter\n", "target": "def chain_insert(lst, at, item):\n    while lst is not None:\n        if lst[0] == at:\n            lst[1] = [item, lst[1]]\n            return\n        else:\n            lst = lst[1]\n    raise ValueError(str(at) + \" not found\")\n\nchain = ['A', ['B', None]]\nchain_insert(chain, 'A', 'C')\nprint chain\n"}
{"id": 126836, "name": "Classes", "source": "Translate Fortran to C#: \n\n\nmodule accuracy_module\n   implicit none\n   integer, parameter, public :: rdp = kind(1.d0)\n   \n   real(rdp), parameter :: pi=3.141592653589793238462643383279502884197_rdp\nend module accuracy_module\n\n\n\n\n\n\nmodule typedefs_module\n   use accuracy_module\n   implicit none\n\n   private \n   public :: TPoint, TShape, TCircle, TRectangle, TSquare \n\n   \n   type, abstract :: TShape\n      real(rdp) :: area\n      character(len=:),allocatable :: name\n   contains\n      \n      procedure(calculate_area), deferred,pass :: calculate_area\n   end type TShape\n   \n   abstract interface\n      function  calculate_area(this)\n         use accuracy_module\n         import TShape \n         implicit none\n         class(TShape) :: this\n         real(rdp) :: calculate_area\n\n      end function calculate_area\n   end interface\n\n   \n   type TPoint\n      real(rdp) :: x,y\n   end type TPoint\n\n   \n   type, extends(TShape) :: TCircle\n      real(rdp) :: radius\n      real(rdp), private :: diameter\n      type(TPoint) :: centre\n   contains\n      procedure, pass :: calculate_area => calculate_circle_area\n      procedure, pass :: get_circle_diameter\n      final :: finalize_circle\n   end type TCircle\n\n   \n   type, extends(TShape) :: TRectangle\n      type(TPoint) :: A,B,C,D\n   contains\n      procedure, pass :: calculate_area => calculate_rectangle_area\n      final :: finalize_rectangle\n   end type TRectangle\n\n   \n   type, extends(TRectangle) :: TSquare\n   contains\n      procedure, pass :: calculate_area => calculate_square_area\n      final :: finalize_square\n   end type TSquare\n\n contains\n\n   \n   \n   \n   subroutine finalize_circle(x)\n      type(TCircle), intent(inout) :: x\n      write(*,*) \"Deleting TCircle object\"\n   end subroutine finalize_circle\n\n   subroutine finalize_rectangle(x)\n      type(TRectangle), intent(inout) :: x\n      write(*,*) \"Deleting also TRectangle object\"\n   end subroutine finalize_rectangle\n\n   subroutine finalize_square(x)\n      type(TSquare), intent(inout) :: x\n      write(*,*) \"Deleting TSquare object\"\n   end subroutine finalize_square\n\n   function calculate_circle_area(this)\n      implicit none\n      class(TCircle) :: this\n      real(rdp) :: calculate_circle_area\n      this%area = pi * this%radius**2\n      calculate_circle_area = this%area\n   end function calculate_circle_area\n\n   function calculate_rectangle_area(this)\n      implicit none\n      class(TRectangle) :: this\n      real(rdp) :: calculate_rectangle_area\n      \n      this%area = 1\n      calculate_rectangle_area = this%area\n   end function calculate_rectangle_area\n\n   function calculate_square_area(this)\n      implicit none\n      class(TSquare) :: this\n      real(rdp) :: calculate_square_area\n      \n      this%area = 1\n      calculate_square_area = this%area\n   end function calculate_square_area\n\n   function  get_circle_diameter(this)\n      implicit none\n      class(TCircle) :: this\n      real(rdp) :: get_circle_diameter\n      this % diameter = 2.0_rdp * this % radius\n      get_circle_diameter = this % diameter\n   end function get_circle_diameter\n\nend module typedefs_module\n\n\n\n\nprogram    rosetta_class\n   use accuracy_module\n   use typedefs_module\n   implicit none\n\n   \n   call test_types()\n\n contains\n\n   subroutine test_types()\n      implicit none\n      \n      type(TPoint), target :: point\n      \n      type(TCircle),target :: circle\n      \n      type(TSquare),target :: square\n\n      \n      class(TPoint), pointer :: ppo\n      class(TCircle), pointer :: pci\n      class(TSquare), pointer :: psq\n\n      \n      point = TPoint(5.d0,5.d0)\n      ppo => point\n      write(*,*) \"x=\",point%x,\"y=\",point%y\n\n      pci => circle\n\n      pci % radius = 1\n      write(*,*) pci % radius\n      \n      write(*,*) pci % get_circle_diameter()\n      write(*,*) pci % calculate_area()\n      write(*,*) pci % area\n\n      psq => square\n\n      write(*,*) psq % area\n      write(*,*) psq % calculate_area()\n      write(*,*) psq % area\n   end subroutine test_types\n\nend program rosetta_class\n", "target": "public class MyClass\n{\n    public MyClass()\n    {\n    }\n    public void SomeMethod()\n    {\n    }\n    private int _variable;\n    public int Variable\n    {\n        get { return _variable; }\n        set { _variable = value; }\n    }\n    public static void Main()\n    {\n        \n        MyClass instance = new MyClass();\n        \n        instance.SomeMethod();\n        \n        instance.Variable = 99;\n        \n        System.Console.WriteLine( \"Variable=\" + instance.Variable.ToString() );\n    }\n}\n"}
{"id": 126840, "name": "Classes", "source": "Translate Fortran to Java: \n\n\nmodule accuracy_module\n   implicit none\n   integer, parameter, public :: rdp = kind(1.d0)\n   \n   real(rdp), parameter :: pi=3.141592653589793238462643383279502884197_rdp\nend module accuracy_module\n\n\n\n\n\n\nmodule typedefs_module\n   use accuracy_module\n   implicit none\n\n   private \n   public :: TPoint, TShape, TCircle, TRectangle, TSquare \n\n   \n   type, abstract :: TShape\n      real(rdp) :: area\n      character(len=:),allocatable :: name\n   contains\n      \n      procedure(calculate_area), deferred,pass :: calculate_area\n   end type TShape\n   \n   abstract interface\n      function  calculate_area(this)\n         use accuracy_module\n         import TShape \n         implicit none\n         class(TShape) :: this\n         real(rdp) :: calculate_area\n\n      end function calculate_area\n   end interface\n\n   \n   type TPoint\n      real(rdp) :: x,y\n   end type TPoint\n\n   \n   type, extends(TShape) :: TCircle\n      real(rdp) :: radius\n      real(rdp), private :: diameter\n      type(TPoint) :: centre\n   contains\n      procedure, pass :: calculate_area => calculate_circle_area\n      procedure, pass :: get_circle_diameter\n      final :: finalize_circle\n   end type TCircle\n\n   \n   type, extends(TShape) :: TRectangle\n      type(TPoint) :: A,B,C,D\n   contains\n      procedure, pass :: calculate_area => calculate_rectangle_area\n      final :: finalize_rectangle\n   end type TRectangle\n\n   \n   type, extends(TRectangle) :: TSquare\n   contains\n      procedure, pass :: calculate_area => calculate_square_area\n      final :: finalize_square\n   end type TSquare\n\n contains\n\n   \n   \n   \n   subroutine finalize_circle(x)\n      type(TCircle), intent(inout) :: x\n      write(*,*) \"Deleting TCircle object\"\n   end subroutine finalize_circle\n\n   subroutine finalize_rectangle(x)\n      type(TRectangle), intent(inout) :: x\n      write(*,*) \"Deleting also TRectangle object\"\n   end subroutine finalize_rectangle\n\n   subroutine finalize_square(x)\n      type(TSquare), intent(inout) :: x\n      write(*,*) \"Deleting TSquare object\"\n   end subroutine finalize_square\n\n   function calculate_circle_area(this)\n      implicit none\n      class(TCircle) :: this\n      real(rdp) :: calculate_circle_area\n      this%area = pi * this%radius**2\n      calculate_circle_area = this%area\n   end function calculate_circle_area\n\n   function calculate_rectangle_area(this)\n      implicit none\n      class(TRectangle) :: this\n      real(rdp) :: calculate_rectangle_area\n      \n      this%area = 1\n      calculate_rectangle_area = this%area\n   end function calculate_rectangle_area\n\n   function calculate_square_area(this)\n      implicit none\n      class(TSquare) :: this\n      real(rdp) :: calculate_square_area\n      \n      this%area = 1\n      calculate_square_area = this%area\n   end function calculate_square_area\n\n   function  get_circle_diameter(this)\n      implicit none\n      class(TCircle) :: this\n      real(rdp) :: get_circle_diameter\n      this % diameter = 2.0_rdp * this % radius\n      get_circle_diameter = this % diameter\n   end function get_circle_diameter\n\nend module typedefs_module\n\n\n\n\nprogram    rosetta_class\n   use accuracy_module\n   use typedefs_module\n   implicit none\n\n   \n   call test_types()\n\n contains\n\n   subroutine test_types()\n      implicit none\n      \n      type(TPoint), target :: point\n      \n      type(TCircle),target :: circle\n      \n      type(TSquare),target :: square\n\n      \n      class(TPoint), pointer :: ppo\n      class(TCircle), pointer :: pci\n      class(TSquare), pointer :: psq\n\n      \n      point = TPoint(5.d0,5.d0)\n      ppo => point\n      write(*,*) \"x=\",point%x,\"y=\",point%y\n\n      pci => circle\n\n      pci % radius = 1\n      write(*,*) pci % radius\n      \n      write(*,*) pci % get_circle_diameter()\n      write(*,*) pci % calculate_area()\n      write(*,*) pci % area\n\n      psq => square\n\n      write(*,*) psq % area\n      write(*,*) psq % calculate_area()\n      write(*,*) psq % area\n   end subroutine test_types\n\nend program rosetta_class\n", "target": "public class MyClass{\n\n  \n  private int variable;  \n\n  \n  public MyClass(){\n    \n  }\n\n  \n  public void someMethod(){\n   this.variable = 1;\n  }\n}\n"}
{"id": 126841, "name": "Classes", "source": "Translate Fortran to Python: \n\n\nmodule accuracy_module\n   implicit none\n   integer, parameter, public :: rdp = kind(1.d0)\n   \n   real(rdp), parameter :: pi=3.141592653589793238462643383279502884197_rdp\nend module accuracy_module\n\n\n\n\n\n\nmodule typedefs_module\n   use accuracy_module\n   implicit none\n\n   private \n   public :: TPoint, TShape, TCircle, TRectangle, TSquare \n\n   \n   type, abstract :: TShape\n      real(rdp) :: area\n      character(len=:),allocatable :: name\n   contains\n      \n      procedure(calculate_area), deferred,pass :: calculate_area\n   end type TShape\n   \n   abstract interface\n      function  calculate_area(this)\n         use accuracy_module\n         import TShape \n         implicit none\n         class(TShape) :: this\n         real(rdp) :: calculate_area\n\n      end function calculate_area\n   end interface\n\n   \n   type TPoint\n      real(rdp) :: x,y\n   end type TPoint\n\n   \n   type, extends(TShape) :: TCircle\n      real(rdp) :: radius\n      real(rdp), private :: diameter\n      type(TPoint) :: centre\n   contains\n      procedure, pass :: calculate_area => calculate_circle_area\n      procedure, pass :: get_circle_diameter\n      final :: finalize_circle\n   end type TCircle\n\n   \n   type, extends(TShape) :: TRectangle\n      type(TPoint) :: A,B,C,D\n   contains\n      procedure, pass :: calculate_area => calculate_rectangle_area\n      final :: finalize_rectangle\n   end type TRectangle\n\n   \n   type, extends(TRectangle) :: TSquare\n   contains\n      procedure, pass :: calculate_area => calculate_square_area\n      final :: finalize_square\n   end type TSquare\n\n contains\n\n   \n   \n   \n   subroutine finalize_circle(x)\n      type(TCircle), intent(inout) :: x\n      write(*,*) \"Deleting TCircle object\"\n   end subroutine finalize_circle\n\n   subroutine finalize_rectangle(x)\n      type(TRectangle), intent(inout) :: x\n      write(*,*) \"Deleting also TRectangle object\"\n   end subroutine finalize_rectangle\n\n   subroutine finalize_square(x)\n      type(TSquare), intent(inout) :: x\n      write(*,*) \"Deleting TSquare object\"\n   end subroutine finalize_square\n\n   function calculate_circle_area(this)\n      implicit none\n      class(TCircle) :: this\n      real(rdp) :: calculate_circle_area\n      this%area = pi * this%radius**2\n      calculate_circle_area = this%area\n   end function calculate_circle_area\n\n   function calculate_rectangle_area(this)\n      implicit none\n      class(TRectangle) :: this\n      real(rdp) :: calculate_rectangle_area\n      \n      this%area = 1\n      calculate_rectangle_area = this%area\n   end function calculate_rectangle_area\n\n   function calculate_square_area(this)\n      implicit none\n      class(TSquare) :: this\n      real(rdp) :: calculate_square_area\n      \n      this%area = 1\n      calculate_square_area = this%area\n   end function calculate_square_area\n\n   function  get_circle_diameter(this)\n      implicit none\n      class(TCircle) :: this\n      real(rdp) :: get_circle_diameter\n      this % diameter = 2.0_rdp * this % radius\n      get_circle_diameter = this % diameter\n   end function get_circle_diameter\n\nend module typedefs_module\n\n\n\n\nprogram    rosetta_class\n   use accuracy_module\n   use typedefs_module\n   implicit none\n\n   \n   call test_types()\n\n contains\n\n   subroutine test_types()\n      implicit none\n      \n      type(TPoint), target :: point\n      \n      type(TCircle),target :: circle\n      \n      type(TSquare),target :: square\n\n      \n      class(TPoint), pointer :: ppo\n      class(TCircle), pointer :: pci\n      class(TSquare), pointer :: psq\n\n      \n      point = TPoint(5.d0,5.d0)\n      ppo => point\n      write(*,*) \"x=\",point%x,\"y=\",point%y\n\n      pci => circle\n\n      pci % radius = 1\n      write(*,*) pci % radius\n      \n      write(*,*) pci % get_circle_diameter()\n      write(*,*) pci % calculate_area()\n      write(*,*) pci % area\n\n      psq => square\n\n      write(*,*) psq % area\n      write(*,*) psq % calculate_area()\n      write(*,*) psq % area\n   end subroutine test_types\n\nend program rosetta_class\n", "target": "class MyClass:\n    name2 = 2 \n\n    def __init__(self):\n        \n        self.name1 = 0 \n  \n    def someMethod(self):\n        \n        self.name1 = 1\n        MyClass.name2 = 3\n  \n  \nmyclass = MyClass() \n\nclass MyOtherClass:\n    count = 0  \n    def __init__(self, name, gender=\"Male\", age=None):\n        \n        MyOtherClass.count += 1\n        self.name = name\n        self.gender = gender\n        if age is not None:\n            self.age = age\n    def __del__(self):\n        MyOtherClass.count -= 1\n\nperson1 = MyOtherClass(\"John\")\nprint person1.name, person1.gender  \nprint person1.age                   \nperson2 = MyOtherClass(\"Jane\", \"Female\", 23)\nprint person2.name, person2.gender, person2.age  \n"}
{"id": 127077, "name": "Long multiplication", "source": "Translate Fortran to C#: module LongMoltiplication\n  implicit none\n\n  type longnum\n     integer, dimension(:), pointer :: num\n  end type longnum\n\n  interface operator (*)\n     module procedure longmolt_ll\n  end interface\n\ncontains\n  \n  subroutine longmolt_s2l(istring, num)\n    character(len=*), intent(in) :: istring\n    type(longnum), intent(out) :: num\n    \n    integer :: i, l\n\n    l = len(istring)\n\n    allocate(num%num(l))\n\n    forall(i=1:l) num%num(l-i+1) = iachar(istring(i:i)) - 48\n\n  end subroutine longmolt_s2l\n\n  \n  function longmolt_ll(a, b) result(c)\n    type(longnum) :: c\n    type(longnum), intent(in) :: a, b\n    \n    integer, dimension(:,:), allocatable :: t\n    integer :: ntlen, i, j\n\n    ntlen = size(a%num) + size(b%num) + 1\n    allocate(c%num(ntlen))\n    c%num = 0\n\n    allocate(t(size(b%num), ntlen))\n    \n    t = 0\n    forall(i=1:size(b%num), j=1:size(a%num)) t(i, j+i-1) = b%num(i) * a%num(j)\n\n    do j=2, ntlen    \n       forall(i=1:size(b%num)) t(i, j) = t(i, j) + t(i, j-1)/10\n    end do\n\n    forall(j=1:ntlen) c%num(j) = sum(mod(t(:,j), 10))\n\n    do j=2, ntlen\n       c%num(j) = c%num(j) + c%num(j-1)/10\n    end do\n\n    c%num = mod(c%num, 10)\n    \n    deallocate(t)\n  end function longmolt_ll\n\n\n  subroutine longmolt_print(num)\n    type(longnum), intent(in) :: num\n\n    integer :: i, j\n    \n    do j=size(num%num), 2, -1\n       if ( num%num(j) /= 0 ) exit\n    end do\n\n    do i=j, 1, -1\n       write(*,\"(I1)\", advance=\"no\") num%num(i)\n    end do\n  end subroutine longmolt_print\n\nend module LongMoltiplication\n", "target": "using System;\nusing static System.Console;\nusing BI = System.Numerics.BigInteger;\n\nclass Program {\n\n  static decimal mx = 1E28M, hm = 1E14M, a;\n\n  \n  struct bi { public decimal hi, lo; }\n\n  \n  static bi set4sq(decimal a) { bi r; r.hi = Math.Floor(a / hm); r.lo = a % hm; return r; }\n\n  \n  static string toStr(bi a, bool comma = false) {\n    string r = a.hi == 0 ? string.Format(\"{0:0}\", a.lo) :\n                           string.Format(\"{0:0}{1:\" + new string('0', 28) + \"}\", a.hi, a.lo);\n    if (!comma) return r;  string rc = \"\";\n    for (int i = r.Length - 3; i > 0; i -= 3) rc = \",\" + r.Substring(i, 3) + rc;\n    return r.Substring(0, ((r.Length + 2) % 3) + 1) + rc; }\n\n  \n  static decimal Pow_dec(decimal bas, uint exp) {\n    if (exp == 0) return 1M; decimal tmp = Pow_dec(bas, exp >> 1); tmp *= tmp;\n    if ((exp & 1) == 0) return tmp; return tmp * bas; }\n\n  static void Main(string[] args) {\n    for (uint p = 64; p < 95; p += 30) {        \n      bi x = set4sq(a = Pow_dec(2M, p)), y;     \n      WriteLine(\"The square of (2^{0}):                    {1,38:n0}\", p, a); BI BS = BI.Pow((BI)a, 2);\n      y.lo = x.lo * x.lo; y.hi = x.hi * x.hi;   \n      a = x.hi * x.lo * 2M;                     \n      y.hi += Math.Floor(a / hm);               \n      y.lo += (a % hm) * hm;                    \n      while (y.lo > mx) { y.lo -= mx; y.hi++; } \n      WriteLine(\" is {0,75} (which {1} match the BigInteger computation)\\n\", toStr(y, true),\n          BS.ToString() == toStr(y) ? \"does\" : \"fails to\"); } }\n\n}\n"}
{"id": 127081, "name": "Long multiplication", "source": "Translate Fortran to Java: module LongMoltiplication\n  implicit none\n\n  type longnum\n     integer, dimension(:), pointer :: num\n  end type longnum\n\n  interface operator (*)\n     module procedure longmolt_ll\n  end interface\n\ncontains\n  \n  subroutine longmolt_s2l(istring, num)\n    character(len=*), intent(in) :: istring\n    type(longnum), intent(out) :: num\n    \n    integer :: i, l\n\n    l = len(istring)\n\n    allocate(num%num(l))\n\n    forall(i=1:l) num%num(l-i+1) = iachar(istring(i:i)) - 48\n\n  end subroutine longmolt_s2l\n\n  \n  function longmolt_ll(a, b) result(c)\n    type(longnum) :: c\n    type(longnum), intent(in) :: a, b\n    \n    integer, dimension(:,:), allocatable :: t\n    integer :: ntlen, i, j\n\n    ntlen = size(a%num) + size(b%num) + 1\n    allocate(c%num(ntlen))\n    c%num = 0\n\n    allocate(t(size(b%num), ntlen))\n    \n    t = 0\n    forall(i=1:size(b%num), j=1:size(a%num)) t(i, j+i-1) = b%num(i) * a%num(j)\n\n    do j=2, ntlen    \n       forall(i=1:size(b%num)) t(i, j) = t(i, j) + t(i, j-1)/10\n    end do\n\n    forall(j=1:ntlen) c%num(j) = sum(mod(t(:,j), 10))\n\n    do j=2, ntlen\n       c%num(j) = c%num(j) + c%num(j-1)/10\n    end do\n\n    c%num = mod(c%num, 10)\n    \n    deallocate(t)\n  end function longmolt_ll\n\n\n  subroutine longmolt_print(num)\n    type(longnum), intent(in) :: num\n\n    integer :: i, j\n    \n    do j=size(num%num), 2, -1\n       if ( num%num(j) /= 0 ) exit\n    end do\n\n    do i=j, 1, -1\n       write(*,\"(I1)\", advance=\"no\") num%num(i)\n    end do\n  end subroutine longmolt_print\n\nend module LongMoltiplication\n", "target": "public class LongMult {\n\n\tprivate static byte[] stringToDigits(String num) {\n\t\tbyte[] result = new byte[num.length()];\n\t\tfor (int i = 0; i < num.length(); i++) {\n\t\t\tchar c = num.charAt(i);\n\t\t\tif (c < '0' || c > '9') {\n\t\t\t\tthrow new IllegalArgumentException(\"Invalid digit \" + c\n\t\t\t\t\t\t+ \" found at position \" + i);\n\t\t\t}\n\t\t\tresult[num.length() - 1 - i] = (byte) (c - '0');\n\t\t}\n\t\treturn result;\n\t}\n\n\tpublic static String longMult(String num1, String num2) {\n\t\tbyte[] left = stringToDigits(num1);\n\t\tbyte[] right = stringToDigits(num2);\n\t\tbyte[] result = new byte[left.length + right.length];\n\t\tfor (int rightPos = 0; rightPos < right.length; rightPos++) {\n\t\t\tbyte rightDigit = right[rightPos];\n\t\t\tbyte temp = 0;\n\t\t\tfor (int leftPos = 0; leftPos < left.length; leftPos++) {\n\t\t\t\ttemp += result[leftPos + rightPos];\n\t\t\t\ttemp += rightDigit * left[leftPos];\n\t\t\t\tresult[leftPos + rightPos] = (byte) (temp % 10);\n\t\t\t\ttemp /= 10;\n\t\t\t}\n\t\t\tint destPos = rightPos + left.length;\n\t\t\twhile (temp != 0) {\n\t\t\t\ttemp += result[destPos] & 0xFFFFFFFFL;\n\t\t\t\tresult[destPos] = (byte) (temp % 10);\n\t\t\t\ttemp /= 10;\n\t\t\t\tdestPos++;\n\t\t\t}\n\t\t}\n\t\tStringBuilder stringResultBuilder = new StringBuilder(result.length);\n\t\tfor (int i = result.length - 1; i >= 0; i--) {\n\t\t\tbyte digit = result[i];\n\t\t\tif (digit != 0 || stringResultBuilder.length() > 0) {\n\t\t\t\tstringResultBuilder.append((char) (digit + '0'));\n\t\t\t}\n\t\t}\n\t\treturn stringResultBuilder.toString();\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tSystem.out.println(longMult(\"18446744073709551616\",\n\t\t\t\t\"18446744073709551616\"));\n\t}\n}\n"}
{"id": 127082, "name": "Long multiplication", "source": "Translate Fortran to Python: module LongMoltiplication\n  implicit none\n\n  type longnum\n     integer, dimension(:), pointer :: num\n  end type longnum\n\n  interface operator (*)\n     module procedure longmolt_ll\n  end interface\n\ncontains\n  \n  subroutine longmolt_s2l(istring, num)\n    character(len=*), intent(in) :: istring\n    type(longnum), intent(out) :: num\n    \n    integer :: i, l\n\n    l = len(istring)\n\n    allocate(num%num(l))\n\n    forall(i=1:l) num%num(l-i+1) = iachar(istring(i:i)) - 48\n\n  end subroutine longmolt_s2l\n\n  \n  function longmolt_ll(a, b) result(c)\n    type(longnum) :: c\n    type(longnum), intent(in) :: a, b\n    \n    integer, dimension(:,:), allocatable :: t\n    integer :: ntlen, i, j\n\n    ntlen = size(a%num) + size(b%num) + 1\n    allocate(c%num(ntlen))\n    c%num = 0\n\n    allocate(t(size(b%num), ntlen))\n    \n    t = 0\n    forall(i=1:size(b%num), j=1:size(a%num)) t(i, j+i-1) = b%num(i) * a%num(j)\n\n    do j=2, ntlen    \n       forall(i=1:size(b%num)) t(i, j) = t(i, j) + t(i, j-1)/10\n    end do\n\n    forall(j=1:ntlen) c%num(j) = sum(mod(t(:,j), 10))\n\n    do j=2, ntlen\n       c%num(j) = c%num(j) + c%num(j-1)/10\n    end do\n\n    c%num = mod(c%num, 10)\n    \n    deallocate(t)\n  end function longmolt_ll\n\n\n  subroutine longmolt_print(num)\n    type(longnum), intent(in) :: num\n\n    integer :: i, j\n    \n    do j=size(num%num), 2, -1\n       if ( num%num(j) /= 0 ) exit\n    end do\n\n    do i=j, 1, -1\n       write(*,\"(I1)\", advance=\"no\") num%num(i)\n    end do\n  end subroutine longmolt_print\n\nend module LongMoltiplication\n", "target": "\nprint 2**64*2**64\n"}
{"id": 127384, "name": "Detect division by zero", "source": "Translate Fortran to C#: program  rosetta_divbyzero\n   implicit none\n   integer, parameter :: rdp = kind(1.d0)\n   real(rdp) :: normal,zero\n\n   normal = 1.d0\n   zero = 0.d0\n\n   call div_by_zero_check(normal,zero)\n\n contains\n\n   subroutine  div_by_zero_check(x,y)\n      use, intrinsic  :: ieee_exceptions\n      use, intrinsic  :: ieee_arithmetic\n      implicit none\n      real(rdp), intent(in) :: x,y\n\n      real(rdp) :: check\n      type(ieee_status_type) :: status_value\n      logical :: flag\n      flag = .false.\n      \n      call ieee_get_status(status_value)\n      \n      call ieee_set_flag(ieee_divide_by_zero,.false.)\n      write(*,*)\"Inf supported? \",ieee_support_inf(check)\n\n      \n      check = x/y\n      write(*,*)\"Is check finite?\",ieee_is_finite(check), check\n\n      call ieee_get_flag(ieee_divide_by_zero, flag)\n      if (flag) write(*,*)\"Warning\n\n      \n      call ieee_set_status(status_value)\n\n   end subroutine div_by_zero_check\n\nend program rosetta_divbyzero\n", "target": "using System;\n\nnamespace RosettaCode {\n    class Program {\n        static void Main(string[] args) {\n            int x = 1;\n            int y = 0;\n            try {\n               int z = x / y;\n            } catch (DivideByZeroException e) {\n                Console.WriteLine(e);\n            }\n            \n        }\n    }\n}\n"}
{"id": 127385, "name": "Detect division by zero", "source": "Translate Fortran to C#: program  rosetta_divbyzero\n   implicit none\n   integer, parameter :: rdp = kind(1.d0)\n   real(rdp) :: normal,zero\n\n   normal = 1.d0\n   zero = 0.d0\n\n   call div_by_zero_check(normal,zero)\n\n contains\n\n   subroutine  div_by_zero_check(x,y)\n      use, intrinsic  :: ieee_exceptions\n      use, intrinsic  :: ieee_arithmetic\n      implicit none\n      real(rdp), intent(in) :: x,y\n\n      real(rdp) :: check\n      type(ieee_status_type) :: status_value\n      logical :: flag\n      flag = .false.\n      \n      call ieee_get_status(status_value)\n      \n      call ieee_set_flag(ieee_divide_by_zero,.false.)\n      write(*,*)\"Inf supported? \",ieee_support_inf(check)\n\n      \n      check = x/y\n      write(*,*)\"Is check finite?\",ieee_is_finite(check), check\n\n      call ieee_get_flag(ieee_divide_by_zero, flag)\n      if (flag) write(*,*)\"Warning\n\n      \n      call ieee_set_status(status_value)\n\n   end subroutine div_by_zero_check\n\nend program rosetta_divbyzero\n", "target": "using System;\n\nnamespace RosettaCode {\n    class Program {\n        static void Main(string[] args) {\n            int x = 1;\n            int y = 0;\n            try {\n               int z = x / y;\n            } catch (DivideByZeroException e) {\n                Console.WriteLine(e);\n            }\n            \n        }\n    }\n}\n"}
{"id": 127390, "name": "Detect division by zero", "source": "Translate Fortran to Java: program  rosetta_divbyzero\n   implicit none\n   integer, parameter :: rdp = kind(1.d0)\n   real(rdp) :: normal,zero\n\n   normal = 1.d0\n   zero = 0.d0\n\n   call div_by_zero_check(normal,zero)\n\n contains\n\n   subroutine  div_by_zero_check(x,y)\n      use, intrinsic  :: ieee_exceptions\n      use, intrinsic  :: ieee_arithmetic\n      implicit none\n      real(rdp), intent(in) :: x,y\n\n      real(rdp) :: check\n      type(ieee_status_type) :: status_value\n      logical :: flag\n      flag = .false.\n      \n      call ieee_get_status(status_value)\n      \n      call ieee_set_flag(ieee_divide_by_zero,.false.)\n      write(*,*)\"Inf supported? \",ieee_support_inf(check)\n\n      \n      check = x/y\n      write(*,*)\"Is check finite?\",ieee_is_finite(check), check\n\n      call ieee_get_flag(ieee_divide_by_zero, flag)\n      if (flag) write(*,*)\"Warning\n\n      \n      call ieee_set_status(status_value)\n\n   end subroutine div_by_zero_check\n\nend program rosetta_divbyzero\n", "target": "public static boolean infinity(double numer, double denom){\n\treturn Double.isInfinite(numer/denom);\n}\n"}
{"id": 127391, "name": "Detect division by zero", "source": "Translate Fortran to Java: program  rosetta_divbyzero\n   implicit none\n   integer, parameter :: rdp = kind(1.d0)\n   real(rdp) :: normal,zero\n\n   normal = 1.d0\n   zero = 0.d0\n\n   call div_by_zero_check(normal,zero)\n\n contains\n\n   subroutine  div_by_zero_check(x,y)\n      use, intrinsic  :: ieee_exceptions\n      use, intrinsic  :: ieee_arithmetic\n      implicit none\n      real(rdp), intent(in) :: x,y\n\n      real(rdp) :: check\n      type(ieee_status_type) :: status_value\n      logical :: flag\n      flag = .false.\n      \n      call ieee_get_status(status_value)\n      \n      call ieee_set_flag(ieee_divide_by_zero,.false.)\n      write(*,*)\"Inf supported? \",ieee_support_inf(check)\n\n      \n      check = x/y\n      write(*,*)\"Is check finite?\",ieee_is_finite(check), check\n\n      call ieee_get_flag(ieee_divide_by_zero, flag)\n      if (flag) write(*,*)\"Warning\n\n      \n      call ieee_set_status(status_value)\n\n   end subroutine div_by_zero_check\n\nend program rosetta_divbyzero\n", "target": "public static boolean infinity(double numer, double denom){\n\treturn Double.isInfinite(numer/denom);\n}\n"}
{"id": 127392, "name": "Detect division by zero", "source": "Translate Fortran to Python: program  rosetta_divbyzero\n   implicit none\n   integer, parameter :: rdp = kind(1.d0)\n   real(rdp) :: normal,zero\n\n   normal = 1.d0\n   zero = 0.d0\n\n   call div_by_zero_check(normal,zero)\n\n contains\n\n   subroutine  div_by_zero_check(x,y)\n      use, intrinsic  :: ieee_exceptions\n      use, intrinsic  :: ieee_arithmetic\n      implicit none\n      real(rdp), intent(in) :: x,y\n\n      real(rdp) :: check\n      type(ieee_status_type) :: status_value\n      logical :: flag\n      flag = .false.\n      \n      call ieee_get_status(status_value)\n      \n      call ieee_set_flag(ieee_divide_by_zero,.false.)\n      write(*,*)\"Inf supported? \",ieee_support_inf(check)\n\n      \n      check = x/y\n      write(*,*)\"Is check finite?\",ieee_is_finite(check), check\n\n      call ieee_get_flag(ieee_divide_by_zero, flag)\n      if (flag) write(*,*)\"Warning\n\n      \n      call ieee_set_status(status_value)\n\n   end subroutine div_by_zero_check\n\nend program rosetta_divbyzero\n", "target": "def div_check(x, y):\n  try:\n    x / y\n  except ZeroDivisionError:\n    return True\n  else:\n    return False\n"}
{"id": 127393, "name": "Detect division by zero", "source": "Translate Fortran to Python: program  rosetta_divbyzero\n   implicit none\n   integer, parameter :: rdp = kind(1.d0)\n   real(rdp) :: normal,zero\n\n   normal = 1.d0\n   zero = 0.d0\n\n   call div_by_zero_check(normal,zero)\n\n contains\n\n   subroutine  div_by_zero_check(x,y)\n      use, intrinsic  :: ieee_exceptions\n      use, intrinsic  :: ieee_arithmetic\n      implicit none\n      real(rdp), intent(in) :: x,y\n\n      real(rdp) :: check\n      type(ieee_status_type) :: status_value\n      logical :: flag\n      flag = .false.\n      \n      call ieee_get_status(status_value)\n      \n      call ieee_set_flag(ieee_divide_by_zero,.false.)\n      write(*,*)\"Inf supported? \",ieee_support_inf(check)\n\n      \n      check = x/y\n      write(*,*)\"Is check finite?\",ieee_is_finite(check), check\n\n      call ieee_get_flag(ieee_divide_by_zero, flag)\n      if (flag) write(*,*)\"Warning\n\n      \n      call ieee_set_status(status_value)\n\n   end subroutine div_by_zero_check\n\nend program rosetta_divbyzero\n", "target": "def div_check(x, y):\n  try:\n    x / y\n  except ZeroDivisionError:\n    return True\n  else:\n    return False\n"}
{"id": 128347, "name": "Roman numerals_Encode", "source": "Translate Fortran to C#: program roman_numerals\n\n  implicit none\n\n  write (*, '(a)') roman (2009)\n  write (*, '(a)') roman (1666)\n  write (*, '(a)') roman (3888)\n\ncontains\n\nfunction roman (n) result (r)\n\n  implicit none\n  integer, intent (in) :: n\n  integer, parameter   :: d_max = 13\n  integer              :: d\n  integer              :: m\n  integer              :: m_div\n  character (32)       :: r\n  integer,        dimension (d_max), parameter :: d_dec = &\n    & (/1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1/)\n  character (32), dimension (d_max), parameter :: d_rom = &\n    & (/'M ', 'CM', 'D ', 'CD', 'C ', 'XC', 'L ', 'XL', 'X ', 'IX', 'V ', 'IV', 'I '/)\n\n  r = ''\n  m = n\n  do d = 1, d_max\n    m_div = m / d_dec (d)\n    r = trim (r) // repeat (trim (d_rom (d)), m_div)\n    m = m - d_dec (d) * m_div\n  end do\n\nend function roman\n\nend program roman_numerals\n", "target": "using System;\nclass Program\n{\n    static uint[] nums = { 1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1 };\n    static string[] rum = { \"M\", \"CM\", \"D\", \"CD\", \"C\", \"XC\", \"L\", \"XL\", \"X\", \"IX\", \"V\", \"IV\", \"I\" };\n\n    static string ToRoman(uint number)\n    {\n        string value = \"\";\n        for (int i = 0; i < nums.Length && number != 0; i++)\n        {\n            while (number >= nums[i])\n            {\n                number -= nums[i];\n                value += rum[i];\n            }\n        }\n        return value;\n    }\n\n    static void Main()\n    {\n        for (uint number = 1; number <= 1 << 10; number *= 2)\n        {\n            Console.WriteLine(\"{0} = {1}\", number, ToRoman(number));\n        }\n    }\n}\n"}
{"id": 128348, "name": "Roman numerals_Encode", "source": "Translate Fortran to C#: program roman_numerals\n\n  implicit none\n\n  write (*, '(a)') roman (2009)\n  write (*, '(a)') roman (1666)\n  write (*, '(a)') roman (3888)\n\ncontains\n\nfunction roman (n) result (r)\n\n  implicit none\n  integer, intent (in) :: n\n  integer, parameter   :: d_max = 13\n  integer              :: d\n  integer              :: m\n  integer              :: m_div\n  character (32)       :: r\n  integer,        dimension (d_max), parameter :: d_dec = &\n    & (/1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1/)\n  character (32), dimension (d_max), parameter :: d_rom = &\n    & (/'M ', 'CM', 'D ', 'CD', 'C ', 'XC', 'L ', 'XL', 'X ', 'IX', 'V ', 'IV', 'I '/)\n\n  r = ''\n  m = n\n  do d = 1, d_max\n    m_div = m / d_dec (d)\n    r = trim (r) // repeat (trim (d_rom (d)), m_div)\n    m = m - d_dec (d) * m_div\n  end do\n\nend function roman\n\nend program roman_numerals\n", "target": "using System;\nclass Program\n{\n    static uint[] nums = { 1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1 };\n    static string[] rum = { \"M\", \"CM\", \"D\", \"CD\", \"C\", \"XC\", \"L\", \"XL\", \"X\", \"IX\", \"V\", \"IV\", \"I\" };\n\n    static string ToRoman(uint number)\n    {\n        string value = \"\";\n        for (int i = 0; i < nums.Length && number != 0; i++)\n        {\n            while (number >= nums[i])\n            {\n                number -= nums[i];\n                value += rum[i];\n            }\n        }\n        return value;\n    }\n\n    static void Main()\n    {\n        for (uint number = 1; number <= 1 << 10; number *= 2)\n        {\n            Console.WriteLine(\"{0} = {1}\", number, ToRoman(number));\n        }\n    }\n}\n"}
{"id": 128354, "name": "Roman numerals_Encode", "source": "Translate Fortran to Java: program roman_numerals\n\n  implicit none\n\n  write (*, '(a)') roman (2009)\n  write (*, '(a)') roman (1666)\n  write (*, '(a)') roman (3888)\n\ncontains\n\nfunction roman (n) result (r)\n\n  implicit none\n  integer, intent (in) :: n\n  integer, parameter   :: d_max = 13\n  integer              :: d\n  integer              :: m\n  integer              :: m_div\n  character (32)       :: r\n  integer,        dimension (d_max), parameter :: d_dec = &\n    & (/1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1/)\n  character (32), dimension (d_max), parameter :: d_rom = &\n    & (/'M ', 'CM', 'D ', 'CD', 'C ', 'XC', 'L ', 'XL', 'X ', 'IX', 'V ', 'IV', 'I '/)\n\n  r = ''\n  m = n\n  do d = 1, d_max\n    m_div = m / d_dec (d)\n    r = trim (r) // repeat (trim (d_rom (d)), m_div)\n    m = m - d_dec (d) * m_div\n  end do\n\nend function roman\n\nend program roman_numerals\n", "target": "public class RN {\n\n    enum Numeral {\n        I(1), IV(4), V(5), IX(9), X(10), XL(40), L(50), XC(90), C(100), CD(400), D(500), CM(900), M(1000);\n        int weight;\n\n        Numeral(int weight) {\n            this.weight = weight;\n        }\n    };\n\n    public static String roman(long n) {\n        \n        if( n <= 0) {\n            throw new IllegalArgumentException();\n        }\n        \n        StringBuilder buf = new StringBuilder();\n\n        final Numeral[] values = Numeral.values();\n        for (int i = values.length - 1; i >= 0; i--) {\n            while (n >= values[i].weight) {\n                buf.append(values[i]);\n                n -= values[i].weight;\n            }\n        }\n        return buf.toString();\n    }\n\n    public static void test(long n) {\n        System.out.println(n + \" = \" + roman(n));\n    }\n\n    public static void main(String[] args) {\n        test(1999);\n        test(25);\n        test(944);\n        test(0);\n    }\n\n}\n"}
{"id": 128355, "name": "Roman numerals_Encode", "source": "Translate Fortran to Java: program roman_numerals\n\n  implicit none\n\n  write (*, '(a)') roman (2009)\n  write (*, '(a)') roman (1666)\n  write (*, '(a)') roman (3888)\n\ncontains\n\nfunction roman (n) result (r)\n\n  implicit none\n  integer, intent (in) :: n\n  integer, parameter   :: d_max = 13\n  integer              :: d\n  integer              :: m\n  integer              :: m_div\n  character (32)       :: r\n  integer,        dimension (d_max), parameter :: d_dec = &\n    & (/1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1/)\n  character (32), dimension (d_max), parameter :: d_rom = &\n    & (/'M ', 'CM', 'D ', 'CD', 'C ', 'XC', 'L ', 'XL', 'X ', 'IX', 'V ', 'IV', 'I '/)\n\n  r = ''\n  m = n\n  do d = 1, d_max\n    m_div = m / d_dec (d)\n    r = trim (r) // repeat (trim (d_rom (d)), m_div)\n    m = m - d_dec (d) * m_div\n  end do\n\nend function roman\n\nend program roman_numerals\n", "target": "public class RN {\n\n    enum Numeral {\n        I(1), IV(4), V(5), IX(9), X(10), XL(40), L(50), XC(90), C(100), CD(400), D(500), CM(900), M(1000);\n        int weight;\n\n        Numeral(int weight) {\n            this.weight = weight;\n        }\n    };\n\n    public static String roman(long n) {\n        \n        if( n <= 0) {\n            throw new IllegalArgumentException();\n        }\n        \n        StringBuilder buf = new StringBuilder();\n\n        final Numeral[] values = Numeral.values();\n        for (int i = values.length - 1; i >= 0; i--) {\n            while (n >= values[i].weight) {\n                buf.append(values[i]);\n                n -= values[i].weight;\n            }\n        }\n        return buf.toString();\n    }\n\n    public static void test(long n) {\n        System.out.println(n + \" = \" + roman(n));\n    }\n\n    public static void main(String[] args) {\n        test(1999);\n        test(25);\n        test(944);\n        test(0);\n    }\n\n}\n"}
{"id": 128356, "name": "Roman numerals_Encode", "source": "Translate Fortran to Python: program roman_numerals\n\n  implicit none\n\n  write (*, '(a)') roman (2009)\n  write (*, '(a)') roman (1666)\n  write (*, '(a)') roman (3888)\n\ncontains\n\nfunction roman (n) result (r)\n\n  implicit none\n  integer, intent (in) :: n\n  integer, parameter   :: d_max = 13\n  integer              :: d\n  integer              :: m\n  integer              :: m_div\n  character (32)       :: r\n  integer,        dimension (d_max), parameter :: d_dec = &\n    & (/1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1/)\n  character (32), dimension (d_max), parameter :: d_rom = &\n    & (/'M ', 'CM', 'D ', 'CD', 'C ', 'XC', 'L ', 'XL', 'X ', 'IX', 'V ', 'IV', 'I '/)\n\n  r = ''\n  m = n\n  do d = 1, d_max\n    m_div = m / d_dec (d)\n    r = trim (r) // repeat (trim (d_rom (d)), m_div)\n    m = m - d_dec (d) * m_div\n  end do\n\nend function roman\n\nend program roman_numerals\n", "target": "import roman\nprint(roman.toRoman(2022))\n"}
{"id": 128357, "name": "Roman numerals_Encode", "source": "Translate Fortran to Python: program roman_numerals\n\n  implicit none\n\n  write (*, '(a)') roman (2009)\n  write (*, '(a)') roman (1666)\n  write (*, '(a)') roman (3888)\n\ncontains\n\nfunction roman (n) result (r)\n\n  implicit none\n  integer, intent (in) :: n\n  integer, parameter   :: d_max = 13\n  integer              :: d\n  integer              :: m\n  integer              :: m_div\n  character (32)       :: r\n  integer,        dimension (d_max), parameter :: d_dec = &\n    & (/1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1/)\n  character (32), dimension (d_max), parameter :: d_rom = &\n    & (/'M ', 'CM', 'D ', 'CD', 'C ', 'XC', 'L ', 'XL', 'X ', 'IX', 'V ', 'IV', 'I '/)\n\n  r = ''\n  m = n\n  do d = 1, d_max\n    m_div = m / d_dec (d)\n    r = trim (r) // repeat (trim (d_rom (d)), m_div)\n    m = m - d_dec (d) * m_div\n  end do\n\nend function roman\n\nend program roman_numerals\n", "target": "import roman\nprint(roman.toRoman(2022))\n"}
{"id": 128803, "name": "Loops_While", "source": "Translate Fortran to C#: INTEGER :: i = 1024\nDO WHILE (i > 0)\n  WRITE(*,*) i\n  i = i / 2\nEND DO\n", "target": "int i = 1024;\nwhile(i > 0){\n   System.Console.WriteLine(i);\n   i /= 2;\n}\n"}
{"id": 128807, "name": "Loops_While", "source": "Translate Fortran to Java: INTEGER :: i = 1024\nDO WHILE (i > 0)\n  WRITE(*,*) i\n  i = i / 2\nEND DO\n", "target": "int i = 1024;\nwhile(i > 0){\n   System.out.println(i);\n   i >>= 1; \n}\n"}
{"id": 128808, "name": "Loops_While", "source": "Translate Fortran to Python: INTEGER :: i = 1024\nDO WHILE (i > 0)\n  WRITE(*,*) i\n  i = i / 2\nEND DO\n", "target": "n = 1024\nwhile n > 0:\n    print n\n    n //= 2\n"}
{"id": 129082, "name": "Probabilistic choice", "source": "Translate Fortran to C#: PROGRAM PROBS\n \n  IMPLICIT NONE\n   \n  INTEGER, PARAMETER :: trials = 1000000\n  INTEGER :: i, j, probcount(8) = 0\n  REAL :: expected(8), mapping(8), rnum\n  CHARACTER(6) :: items(8) = (/ \"aleph \", \"beth  \", \"gimel \", \"daleth\", \"he    \", \"waw   \", \"zayin \", \"heth  \" /)\n\n  expected(1:7) = (/ (1.0/i, i=5,11) /)\n  expected(8) = 1.0 - SUM(expected(1:7))\n  mapping(1) = 1.0 / 5.0\n  DO i = 2, 7\n     mapping(i) = mapping(i-1) + 1.0/(i+4.0)\n  END DO\n  mapping(8) = 1.0\n\n  DO i = 1, trials\n     CALL RANDOM_NUMBER(rnum)\n     DO j = 1, 8\n        IF (rnum < mapping(j)) THEN\n           probcount(j) = probcount(j) + 1\n           EXIT\n        END IF\n     END DO\n  END DO\n\n  WRITE(*, \"(A,I10)\") \"Trials:             \", trials\n  WRITE(*, \"(A,8A10)\") \"Items:             \", items\n  WRITE(*, \"(A,8F10.6)\") \"Target Probability:  \", expected\n  WRITE(*, \"(A,8F10.6)\") \"Attained Probability:\", REAL(probcount) / REAL(trials)\n  \nENDPROGRAM PROBS\n", "target": "using System;\n\nclass Program\n{\n    static long TRIALS = 1000000L;\n    private class Expv\n    {\n        public string name;\n        public int probcount;\n        public double expect;\n        public double mapping;\n\n        public Expv(string name, int probcount, double expect, double mapping)\n        {\n            this.name = name;\n            this.probcount = probcount;\n            this.expect = expect;\n            this.mapping = mapping;\n        }\n    }\n\n    static Expv[] items = {\n        new Expv(\"aleph\", 0, 0.0, 0.0), new Expv(\"beth\", 0, 0.0, 0.0),\n        new Expv(\"gimel\", 0, 0.0, 0.0), new Expv(\"daleth\", 0, 0.0, 0.0),\n\tnew Expv(\"he\", 0, 0.0, 0.0),    new Expv(\"waw\", 0, 0.0, 0.0),\n\tnew Expv(\"zayin\", 0, 0.0, 0.0), new Expv(\"heth\", 0, 0.0, 0.0)\n    };\n\n    static void Main(string[] args)\n    {\n        double rnum, tsum = 0.0;\n        Random random = new Random();\n\n        for (int i = 0, rnum = 5.0; i < 7; i++, rnum += 1.0)\n        {\n            items[i].expect = 1.0 / rnum;\n            tsum += items[i].expect;\n        }\n        items[7].expect = 1.0 - tsum;\n\n        items[0].mapping = 1.0 / 5.0;\n        for (int i = 1; i < 7; i++)\n            items[i].mapping = items[i - 1].mapping + 1.0 / ((double)i + 5.0);\n        items[7].mapping = 1.0;\n\n        for (int i = 0; i < TRIALS; i++)\n        {\n            rnum = random.NextDouble();\n            for (int j = 0; j < 8; j++)\n                if (rnum < items[j].mapping)\n                {\n                    items[j].probcount++;\n                    break;\n                }\n        }\n\n        Console.WriteLine(\"Trials: {0}\", TRIALS);\n        Console.Write(\"Items:          \");\n        for (int i = 0; i < 8; i++)\n            Console.Write(items[i].name.PadRight(9));\n        Console.WriteLine();\n        Console.Write(\"Target prob.:   \");\n        for (int i = 0; i < 8; i++)\n            Console.Write(\"{0:0.000000} \", items[i].expect);\n        Console.WriteLine();\n        Console.Write(\"Attained prob.: \");\n        for (int i = 0; i < 8; i++)\n            Console.Write(\"{0:0.000000} \", (double)items[i].probcount / (double)TRIALS);\n        Console.WriteLine();\n    }\n}\n"}
{"id": 129085, "name": "Probabilistic choice", "source": "Translate Fortran to Java: PROGRAM PROBS\n \n  IMPLICIT NONE\n   \n  INTEGER, PARAMETER :: trials = 1000000\n  INTEGER :: i, j, probcount(8) = 0\n  REAL :: expected(8), mapping(8), rnum\n  CHARACTER(6) :: items(8) = (/ \"aleph \", \"beth  \", \"gimel \", \"daleth\", \"he    \", \"waw   \", \"zayin \", \"heth  \" /)\n\n  expected(1:7) = (/ (1.0/i, i=5,11) /)\n  expected(8) = 1.0 - SUM(expected(1:7))\n  mapping(1) = 1.0 / 5.0\n  DO i = 2, 7\n     mapping(i) = mapping(i-1) + 1.0/(i+4.0)\n  END DO\n  mapping(8) = 1.0\n\n  DO i = 1, trials\n     CALL RANDOM_NUMBER(rnum)\n     DO j = 1, 8\n        IF (rnum < mapping(j)) THEN\n           probcount(j) = probcount(j) + 1\n           EXIT\n        END IF\n     END DO\n  END DO\n\n  WRITE(*, \"(A,I10)\") \"Trials:             \", trials\n  WRITE(*, \"(A,8A10)\") \"Items:             \", items\n  WRITE(*, \"(A,8F10.6)\") \"Target Probability:  \", expected\n  WRITE(*, \"(A,8F10.6)\") \"Attained Probability:\", REAL(probcount) / REAL(trials)\n  \nENDPROGRAM PROBS\n", "target": "public class Prob{\n\tstatic long TRIALS= 1000000;\n\n\tprivate static class Expv{\n\t\tpublic String name;\n\t\tpublic int probcount;\n\t\tpublic double expect;\n\t\tpublic double mapping;\n\n\t\tpublic Expv(String name, int probcount, double expect, double mapping){\n\t\t\tthis.name= name;\n\t\t\tthis.probcount= probcount;\n\t\t\tthis.expect= expect;\n\t\t\tthis.mapping= mapping;\n\t\t}\n\t}\n\n\tstatic Expv[] items=\n\t\t\t{new Expv(\"aleph\", 0, 0.0, 0.0), new Expv(\"beth\", 0, 0.0, 0.0),\n\t\t\t\t\tnew Expv(\"gimel\", 0, 0.0, 0.0),\n\t\t\t\t\tnew Expv(\"daleth\", 0, 0.0, 0.0),\n\t\t\t\t\tnew Expv(\"he\", 0, 0.0, 0.0), new Expv(\"waw\", 0, 0.0, 0.0),\n\t\t\t\t\tnew Expv(\"zayin\", 0, 0.0, 0.0),\n\t\t\t\t\tnew Expv(\"heth\", 0, 0.0, 0.0)};\n\n\tpublic static void main(String[] args){\n\t\tint i, j;\n\t\tdouble rnum, tsum= 0.0;\n\n\t\tfor(i= 0, rnum= 5.0;i < 7;i++, rnum+= 1.0){\n\t\t\titems[i].expect= 1.0 / rnum;\n\t\t\ttsum+= items[i].expect;\n\t\t}\n\t\titems[7].expect= 1.0 - tsum;\n\n\t\titems[0].mapping= 1.0 / 5.0;\n\t\tfor(i= 1;i < 7;i++){\n\t\t\titems[i].mapping= items[i - 1].mapping + 1.0 / ((double)i + 5.0);\n\t\t}\n\t\titems[7].mapping= 1.0;\n\n\n\t\tfor(i= 0;i < TRIALS;i++){\n\t\t\trnum= Math.random();\n\t\t\tfor(j= 0;j < 8;j++){\n\t\t\t\tif(rnum < items[j].mapping){\n\t\t\t\t\titems[j].probcount++;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tSystem.out.printf(\"Trials: %d\\n\", TRIALS);\n\t\tSystem.out.printf(\"Items:          \");\n\t\tfor(i= 0;i < 8;i++)\n\t\t\tSystem.out.printf(\"%-8s \", items[i].name);\n\t\tSystem.out.printf(\"\\nTarget prob.:   \");\n\t\tfor(i= 0;i < 8;i++)\n\t\t\tSystem.out.printf(\"%8.6f \", items[i].expect);\n\t\tSystem.out.printf(\"\\nAttained prob.: \");\n\t\tfor(i= 0;i < 8;i++)\n\t\t\tSystem.out.printf(\"%8.6f \", (double)(items[i].probcount)\n\t\t\t\t\t/ (double)TRIALS);\n\t\tSystem.out.printf(\"\\n\");\n\n\t}\n}\n"}
{"id": 129086, "name": "Probabilistic choice", "source": "Translate Fortran to Python: PROGRAM PROBS\n \n  IMPLICIT NONE\n   \n  INTEGER, PARAMETER :: trials = 1000000\n  INTEGER :: i, j, probcount(8) = 0\n  REAL :: expected(8), mapping(8), rnum\n  CHARACTER(6) :: items(8) = (/ \"aleph \", \"beth  \", \"gimel \", \"daleth\", \"he    \", \"waw   \", \"zayin \", \"heth  \" /)\n\n  expected(1:7) = (/ (1.0/i, i=5,11) /)\n  expected(8) = 1.0 - SUM(expected(1:7))\n  mapping(1) = 1.0 / 5.0\n  DO i = 2, 7\n     mapping(i) = mapping(i-1) + 1.0/(i+4.0)\n  END DO\n  mapping(8) = 1.0\n\n  DO i = 1, trials\n     CALL RANDOM_NUMBER(rnum)\n     DO j = 1, 8\n        IF (rnum < mapping(j)) THEN\n           probcount(j) = probcount(j) + 1\n           EXIT\n        END IF\n     END DO\n  END DO\n\n  WRITE(*, \"(A,I10)\") \"Trials:             \", trials\n  WRITE(*, \"(A,8A10)\") \"Items:             \", items\n  WRITE(*, \"(A,8F10.6)\") \"Target Probability:  \", expected\n  WRITE(*, \"(A,8F10.6)\") \"Attained Probability:\", REAL(probcount) / REAL(trials)\n  \nENDPROGRAM PROBS\n", "target": "import random, bisect\n\ndef probchoice(items, probs):\n  \n  \n  prob_accumulator = 0\n  accumulator = []\n  for p in probs:\n    prob_accumulator += p\n    accumulator.append(prob_accumulator)\n    \n  while True:\n    r = random.random()\n    yield items[bisect.bisect(accumulator, r)]\n\ndef probchoice2(items, probs, bincount=10000):\n  \n  \n  bins = []\n  for item,prob in zip(items, probs):\n    bins += [item]*int(bincount*prob)\n  while True:\n    yield random.choice(bins)\n      \n      \ndef tester(func=probchoice, items='good bad ugly'.split(),\n                    probs=[0.5, 0.3, 0.2],\n                    trials = 100000\n                    ):\n  def problist2string(probs):\n    \n    return \",\".join('%8.6f' % (p,) for p in probs)\n  \n  from collections import defaultdict\n   \n  counter = defaultdict(int)\n  it = func(items, probs)\n  for dummy in xrange(trials):\n    counter[it.next()] += 1\n  print \"\\n\n  print \"Trials:              \", trials\n  print \"Items:               \", ' '.join(items)\n  print \"Target probability:  \", problist2string(probs)\n  print \"Attained probability:\", problist2string(\n    counter[x]/float(trials) for x in items)\n\nif __name__ == '__main__':\n  items = 'aleph beth gimel daleth he waw zayin heth'.split()\n  probs = [1/(float(n)+5) for n in range(len(items))]\n  probs[-1] = 1-sum(probs[:-1])\n  tester(probchoice, items, probs, 1000000)\n  tester(probchoice2, items, probs, 1000000)\n"}
{"id": 129298, "name": "Towers of Hanoi", "source": "Translate Fortran to C#: PROGRAM TOWER\n                             \n  CALL Move(4, 1, 2, 3)\n                \nCONTAINS\n\n  RECURSIVE SUBROUTINE Move(ndisks, from, to, via)\n    INTEGER, INTENT (IN) :: ndisks, from, to, via\n   \n    IF (ndisks == 1) THEN\n       WRITE(*, \"(A,I1,A,I1)\") \"Move disk from pole \", from, \" to pole \", to\n    ELSE\n       CALL Move(ndisks-1, from, via, to)\n       CALL Move(1, from, to, via)\n       CALL Move(ndisks-1, via, to, from)\n    END IF\n  END SUBROUTINE Move\n\nEND PROGRAM TOWER\n", "target": "public  void move(int n, int from, int to, int via) {\n   if (n == 1) {\n     System.Console.WriteLine(\"Move disk from pole \" + from + \" to pole \" + to);\n   } else {\n     move(n - 1, from, via, to);\n     move(1, from, to, via);\n     move(n - 1, via, to, from);\n   }\n }\n"}
{"id": 129302, "name": "Towers of Hanoi", "source": "Translate Fortran to Java: PROGRAM TOWER\n                             \n  CALL Move(4, 1, 2, 3)\n                \nCONTAINS\n\n  RECURSIVE SUBROUTINE Move(ndisks, from, to, via)\n    INTEGER, INTENT (IN) :: ndisks, from, to, via\n   \n    IF (ndisks == 1) THEN\n       WRITE(*, \"(A,I1,A,I1)\") \"Move disk from pole \", from, \" to pole \", to\n    ELSE\n       CALL Move(ndisks-1, from, via, to)\n       CALL Move(1, from, to, via)\n       CALL Move(ndisks-1, via, to, from)\n    END IF\n  END SUBROUTINE Move\n\nEND PROGRAM TOWER\n", "target": "public void move(int n, int from, int to, int via) {\n  if (n == 1) {\n    System.out.println(\"Move disk from pole \" + from + \" to pole \" + to);\n  } else {\n    move(n - 1, from, via, to);\n    move(1, from, to, via);\n    move(n - 1, via, to, from);\n  }\n}\n"}
{"id": 129303, "name": "Towers of Hanoi", "source": "Translate Fortran to Python: PROGRAM TOWER\n                             \n  CALL Move(4, 1, 2, 3)\n                \nCONTAINS\n\n  RECURSIVE SUBROUTINE Move(ndisks, from, to, via)\n    INTEGER, INTENT (IN) :: ndisks, from, to, via\n   \n    IF (ndisks == 1) THEN\n       WRITE(*, \"(A,I1,A,I1)\") \"Move disk from pole \", from, \" to pole \", to\n    ELSE\n       CALL Move(ndisks-1, from, via, to)\n       CALL Move(1, from, to, via)\n       CALL Move(ndisks-1, via, to, from)\n    END IF\n  END SUBROUTINE Move\n\nEND PROGRAM TOWER\n", "target": "\n\n\n\u0ba8\u0bbf\u0bb0\u0bb2\u0bcd\u0baa\u0bbe\u0b95\u0bae\u0bcd \u0bb9\u0bcb\u0ba9\u0bbe\u0baf\u0bcd(\u0bb5\u0b9f\u0bcd\u0b9f\u0bc1\u0b95\u0bb3\u0bcd, \u0bae\u0bc1\u0ba4\u0bb2\u0bcd\u0b85\u0b9a\u0bcd\u0b9a\u0bc1, \u0b87\u0bb1\u0bc1\u0ba4\u0bbf\u0b85\u0b9a\u0bcd\u0b9a\u0bc1,\u0bb5\u0b9f\u0bcd\u0b9f\u0bc1)\n\n  @(\u0bb5\u0b9f\u0bcd\u0b9f\u0bc1\u0b95\u0bb3\u0bcd == 1 ) \u0b86\u0ba9\u0bbe\u0bb2\u0bcd\n     \u0baa\u0ba4\u0bbf\u0baa\u0bcd\u0baa\u0bbf  \u201c\u0bb5\u0b9f\u0bcd\u0b9f\u0bc1 \u201d + str(\u0bb5\u0b9f\u0bcd\u0b9f\u0bc1) + \u201c\u0b90 \\t  (\u201d + str(\u0bae\u0bc1\u0ba4\u0bb2\u0bcd\u0b85\u0b9a\u0bcd\u0b9a\u0bc1) + \u201c  \u2014> \u201d +  str(\u0b87\u0bb1\u0bc1\u0ba4\u0bbf\u0b85\u0b9a\u0bcd\u0b9a\u0bc1)+ \u201c) \u0b85\u0b9a\u0bcd\u0b9a\u0bbf\u0bb1\u0bcd\u0b95\u0bc1 \u0ba8\u0b95\u0bb0\u0bcd\u0ba4\u0bcd\u0ba4\u0bc1\u0b95.\u201d\n  \u0b87\u0bb2\u0bcd\u0bb2\u0bc8\n\n  @( [\"\u0b87\", \"\u0b85\",  \"\u0b86\"]  \u0b87\u0bb2\u0bcd \u0b85\u0b9a\u0bcd\u0b9a\u0bc1 ) \u0b92\u0bb5\u0bcd\u0bb5\u0bca\u0ba9\u0bcd\u0bb1\u0bbe\u0b95\n          @( (\u0bae\u0bc1\u0ba4\u0bb2\u0bcd\u0b85\u0b9a\u0bcd\u0b9a\u0bc1 != \u0b85\u0b9a\u0bcd\u0b9a\u0bc1)  && (\u0b87\u0bb1\u0bc1\u0ba4\u0bbf\u0b85\u0b9a\u0bcd\u0b9a\u0bc1  != \u0b85\u0b9a\u0bcd\u0b9a\u0bc1) ) \u0b86\u0ba9\u0bbe\u0bb2\u0bcd\n              \u0ba8\u0b9f\u0bc1 = \u0b85\u0b9a\u0bcd\u0b9a\u0bc1\n          \u0bae\u0bc1\u0b9f\u0bbf\n  \u0bae\u0bc1\u0b9f\u0bbf\n\n    \n    \u0bb9\u0bcb\u0ba9\u0bbe\u0baf\u0bcd(\u0bb5\u0b9f\u0bcd\u0b9f\u0bc1\u0b95\u0bb3\u0bcd-1,   \u0bae\u0bc1\u0ba4\u0bb2\u0bcd\u0b85\u0b9a\u0bcd\u0b9a\u0bc1,\u0ba8\u0b9f\u0bc1,\u0bb5\u0b9f\u0bcd\u0b9f\u0bc1\u0b95\u0bb3\u0bcd-1)\n\n    \n    \u0bb9\u0bcb\u0ba9\u0bbe\u0baf\u0bcd(1, \u0bae\u0bc1\u0ba4\u0bb2\u0bcd\u0b85\u0b9a\u0bcd\u0b9a\u0bc1, \u0b87\u0bb1\u0bc1\u0ba4\u0bbf\u0b85\u0b9a\u0bcd\u0b9a\u0bc1,\u0bb5\u0b9f\u0bcd\u0b9f\u0bc1\u0b95\u0bb3\u0bcd)\n\n    \n    \u0bb9\u0bcb\u0ba9\u0bbe\u0baf\u0bcd(\u0bb5\u0b9f\u0bcd\u0b9f\u0bc1\u0b95\u0bb3\u0bcd-1, \u0ba8\u0b9f\u0bc1, \u0b87\u0bb1\u0bc1\u0ba4\u0bbf\u0b85\u0b9a\u0bcd\u0b9a\u0bc1,\u0bb5\u0b9f\u0bcd\u0b9f\u0bc1\u0b95\u0bb3\u0bcd-1)\n  \u0bae\u0bc1\u0b9f\u0bbf\n\u0bae\u0bc1\u0b9f\u0bbf\n\n\u0bb9\u0bcb\u0ba9\u0bbe\u0baf\u0bcd(4,\u201d\u0b85\u201d,\u201d\u0b86\u201d,0)\n"}
{"id": 129830, "name": "Remove duplicate elements", "source": "Translate Fortran to C#: program remove_dups\n  implicit none\n  integer :: example(12)         \n  integer :: res(size(example))  \n  integer :: k                   \n  integer :: i, j\n\n  example = [1, 2, 3, 2, 2, 4, 5, 5, 4, 6, 6, 5]\n  k = 1\n  res(1) = example(1)\n  outer: do i=2,size(example)\n     do j=1,k\n        if (res(j) == example(i)) then\n           \n           cycle outer\n        end if\n     end do\n     \n     k = k + 1\n     res(k) = example(i)\n  end do outer\n  write(*,advance='no',fmt='(a,i0,a)') 'Unique list has ',k,' elements: '\n  write(*,*) res(1:k)\nend program remove_dups\n", "target": "int[] nums = { 1, 1, 2, 3, 4, 4 };\nList<int> unique = new List<int>();\nforeach (int n in nums)\n    if (!unique.Contains(n))\n        unique.Add(n);\n"}
{"id": 129833, "name": "Remove duplicate elements", "source": "Translate Fortran to Java: program remove_dups\n  implicit none\n  integer :: example(12)         \n  integer :: res(size(example))  \n  integer :: k                   \n  integer :: i, j\n\n  example = [1, 2, 3, 2, 2, 4, 5, 5, 4, 6, 6, 5]\n  k = 1\n  res(1) = example(1)\n  outer: do i=2,size(example)\n     do j=1,k\n        if (res(j) == example(i)) then\n           \n           cycle outer\n        end if\n     end do\n     \n     k = k + 1\n     res(k) = example(i)\n  end do outer\n  write(*,advance='no',fmt='(a,i0,a)') 'Unique list has ',k,' elements: '\n  write(*,*) res(1:k)\nend program remove_dups\n", "target": "module RetainUniqueValues\n    {\n    @Inject Console console;\n    void run()\n        {\n        Int[] array = [1, 2, 3, 2, 1, 2, 3, 4, 5, 3, 2, 1];\n        array = array.distinct().toArray();\n        console.print($\"result={array}\");\n        }\n    }\n"}
{"id": 129834, "name": "Remove duplicate elements", "source": "Translate Fortran to Python: program remove_dups\n  implicit none\n  integer :: example(12)         \n  integer :: res(size(example))  \n  integer :: k                   \n  integer :: i, j\n\n  example = [1, 2, 3, 2, 2, 4, 5, 5, 4, 6, 6, 5]\n  k = 1\n  res(1) = example(1)\n  outer: do i=2,size(example)\n     do j=1,k\n        if (res(j) == example(i)) then\n           \n           cycle outer\n        end if\n     end do\n     \n     k = k + 1\n     res(k) = example(i)\n  end do outer\n  write(*,advance='no',fmt='(a,i0,a)') 'Unique list has ',k,' elements: '\n  write(*,*) res(1:k)\nend program remove_dups\n", "target": "items = [1, 2, 3, 'a', 'b', 'c', 2, 3, 4, 'b', 'c', 'd']\nunique = list(set(items))\n"}
{"id": 130095, "name": "Emirp primes", "source": "Translate Fortran to C#:       MODULE BAG\t\n       INTEGER MSG\t\n       INTEGER PF16LIMIT,PF32LIMIT,NP\t\t\t\n       PARAMETER (PF16LIMIT = 3512, PF32LIMIT = 4793)\t\n       INTEGER*2 PRIME16(PF16LIMIT)\t\t\t\n       INTEGER*4 PRIME32(PF16LIMIT + 1:PF32LIMIT)\t\n       DATA NP,PRIME16(1),PRIME16(2)/2,2,3/\t\n       INTEGER NGP,NNP,NIP\t\n       DATA NGP,NNP,NIP/3*0/\t\n       CONTAINS\t\t\n        RECURSIVE INTEGER FUNCTION GETPRIME(I)\t\nChooses from amongst two arrays, of sizes known from previous work.\n         INTEGER I\t\t\n         INTEGER P\t\t\n         INTEGER MP\t\t\n          NGP = NGP + 1\t\t\n          IF (I.LE.0) THEN\t\n            GETPRIME = -666\t\t\n          ELSE IF (I.LE.NP) THEN\t\n            IF (I.LE.PF16LIMIT) THEN\t\t\n              GETPRIME = PRIME16(I)\t\t\n             ELSE\t\t\t\t\n              GETPRIME = PRIME32(I)\t\t\n            END IF\t\t\t\n          ELSE IF (I.LE.PF32LIMIT) THEN\t\n            MP = NP\t\t\t\n            P = GETPRIME(NP)\t\t\n   10       P = NEXTPRIME(P)\t\t\n            MP = MP + 1\t\t\t\n            IF (MP.LT.I) GO TO 10\t\n            GETPRIME = P\t\t\n           ELSE\t\t\t\n            WRITE (MSG,*) \"Hic\n            STOP \"Too far...\"\t\t\n          END IF\t\t\n        END FUNCTION GETPRIME\t\n\n        SUBROUTINE STASHPRIME(P)\t\n         INTEGER P\t\n          NP = NP + 1\t\t\n          IF (NP.LE.PF16LIMIT) THEN\t\n            PRIME16(NP) = P\t\t\t\n          ELSE IF (NP.LE.PF32LIMIT) THEN\n            PRIME32(NP) = P\t\t\t\n          ELSE\t\t\t\t\n            STOP \"Stash overflow\n          END IF\t\t\t\n        END SUBROUTINE STASHPRIME\t\n\n        INTEGER FUNCTION FINDPRIME(IT)\t\n         INTEGER IT\t\n         INTEGER L,R,P\t\n          L = 0\t\t\n          R = NP + 1\t\n    1     P = (R - L)/2\t\t\n          IF (P.LE.0) THEN\t\n            FINDPRIME = -L\t\t\n            RETURN\t\t\t\n          END IF\t\t\n          P = P + L\t\t\n          IF (IT - GETPRIME(P)) 2,4,3\t\n    2     R = P; GO TO 1\t\n    3     L = P; GO TO 1\t\n    4     FINDPRIME = P\t\t\n        END FUNCTION FINDPRIME\t\n\n        RECURSIVE INTEGER FUNCTION NEXTPRIME(P)\t\nChecks the stash in PRIME in the hope of finding the next prime directly, otherwise advances from P.\nCollates a stash of primes in PRIME16 and PRIME32, advancing NP from 2 to PF32LIMIT as it goes.\n         INTEGER P\t\n         INTEGER PI\t\n         INTEGER IT\t\n          NNP = NNP + 1\t\n          IF (P.LE.1) THEN\t\n            PI = 2\t\t\n           ELSE\t\t\t\n            IT = (ABS(FINDPRIME(P)))\t\n            IF (IT.LT.NP) THEN\t\t\n              PI = GETPRIME(IT + 1)\t\n             ELSE\t\n              IF (NP.LT.PF32LIMIT) THEN\t\n                PI = GETPRIME(IT)\t\n               ELSE\t\t\t\n                PI = P\t\t\t\n                IF (MOD(PI,2).EQ.0) PI = PI - 1\t\n              END IF\t\t\t\n              DO WHILE (PI.LE.P)\t\n   11           PI = PI + 2\t\t\t\n                IF (.NOT.ISPRIME(PI)) GO TO 11\t\n                IF (IT.EQ.NP .AND. IT.LT.PF32LIMIT) THEN\t\n                  CALL STASHPRIME(PI)\t\t\n                  IT = IT + 1\t\t\t\n                END IF\t\t\t\n              END DO\t\t\n            END IF\t\t\n          END IF\t\t\n          NEXTPRIME = PI\t\n        END FUNCTION NEXTPRIME\t\n\n        RECURSIVE LOGICAL FUNCTION ISPRIME(N)\t\nCrunches up to SQRT(N), and at worst needs to be able to reach Prime(4793) = 46349; greater than SQRT(2147483647) = 46340\u00b795...\n         INTEGER N\t\n         INTEGER I,F,Q\t\n          NIP = NIP + 1\t\n          IF (N.LT.2) THEN\t\n            ISPRIME = .FALSE.\t\n          ELSE\t\t\t\n            ISPRIME = .FALSE.\t\n            I = 1\t\t\n   10       F = GETPRIME(I)\t\n            Q = N/F\t\t\n            IF (Q .GE. F) THEN\t\n              IF (Q*F .EQ. N) RETURN\t\n              I = I + 1\t\t\n              GO TO 10\t\t\n            END IF\t\t\n            ISPRIME = .TRUE.\t\n          END IF\t\t\n        END FUNCTION ISPRIME\t\n\n        INTEGER FUNCTION ESREVER(IT,BASE)\t\n         INTEGER IT\t\n         INTEGER BASE\t\n         INTEGER N,R\t\n          IF (BASE.LE.1) STOP \"Base 2 at least\n          N = IT\t\n          R = 0\t\t\n          DO WHILE(N.GT.0)\t\n            R = R*BASE + MOD(N,BASE)\t\n            N = N/BASE\t\t\t\n          END DO\t\t\n          ESREVER = R\t\t\n        END FUNCTION ESREVER\t\n\n        SUBROUTINE EMIRP(BASE,N1,N2,I1,I2)\t\n         INTEGER BASE\t\n         INTEGER N1,N2\t\n         INTEGER I1,I2\t\n         INTEGER N\t\n         INTEGER P,R\t\n          WRITE (MSG,1) N1,N2,BASE,I1,I2\t\n    1     FORMAT (\"Show the first \",I0,\" to \",I0,\t\n     &     \" emirP numbers (base \",I0,\") between \",I0,\" and \",I0)\t\n          N = 0\t\t\n          P = I1 - 1\t\nChase another emirP.\n   10     P = NEXTPRIME(P)\t\t\n          IF (P.LT.I1) GO TO 10\t\t\n          IF (P.GT.I2) GO TO 900\t\n          R = ESREVER(P,BASE)\t\t\n          IF (P .EQ. R) GO TO 10\t\n          IF (.NOT.ISPRIME(R)) GO TO 10\t\n          N = N + 1\t\t\t\nc          if (mod(n,100) .eq. 0) then\nc            write (6,66) N,P,R,NP,NGP,NNP,NIP\nc   66       format (\"N=\",I5,\",p=\",I6,\",R=\",I6,\",NP=\",I6,3I12)\nc          end if\n          IF (N.GE.N1) WRITE (6,*) P,R\t\n          IF (N.LT.N2) GO TO 10\t\t\nClosedown.\n  900     WRITE (MSG,901) NP,GETPRIME(NP)\t\n  901     FORMAT (\"Stashed up to Prime(\",I0,\") = \",I0,/)\n        END SUBROUTINE EMIRP\t\n      END MODULE BAG\t\n\n      PROGRAM POKE\t\n      USE BAG\t\t\n      MSG = 6\t\t\n\n      CALL EMIRP(10,    1,   20,   1,   1000)\t\n      CALL EMIRP(10,    1,   28,7700,   8000)\t\n      CALL EMIRP(10,10000,10000,   1,1000000)\t\n\n      END\t\n", "target": "using static System.Console;\nusing System;\nusing System.Linq;\nusing System.Collections.Generic;\n\npublic class Program\n{\n    public static void Main() {\n        const int limit = 1_000_000;\n        WriteLine(\"First 20:\");\n        WriteLine(FindEmirpPrimes(limit).Take(20).Delimit());\n        WriteLine();\n\t\t\n        WriteLine(\"Between 7700 and 8000:\");\n        WriteLine(FindEmirpPrimes(limit).SkipWhile(p => p < 7700).TakeWhile(p => p < 8000).Delimit());\n        WriteLine();\n\t\t\n        WriteLine(\"10000th:\");\n        WriteLine(FindEmirpPrimes(limit).ElementAt(9999));\n    }\n\t\n    private static IEnumerable<int> FindEmirpPrimes(int limit)\n    {\n        var primes = Primes(limit).ToHashSet();\n\t\t\n        foreach (int prime in primes) {\n            int reverse = prime.Reverse();\n            if (reverse != prime && primes.Contains(reverse)) yield return prime;\n\t}\n    }\n\t\n    private static IEnumerable<int> Primes(int bound) {\n        if (bound < 2) yield break;\n        yield return 2;\n\t\t\n        BitArray composite = new BitArray((bound - 1) / 2);\n        int limit = ((int)(Math.Sqrt(bound)) - 1) / 2;\n        for (int i = 0; i < limit; i++) {\n            if (composite[i]) continue;\n\t    int prime = 2 * i + 3;\n\t    yield return prime;\n\t\t\t\n\t    for (int j = (prime * prime - 2) / 2; j < composite.Count; j += prime)\n\t        composite[j] = true;\n        }\n\tfor (int i = limit; i < composite.Count; i++)\n\t    if (!composite[i]) yield return 2 * i + 3;\n    }\n}\n\npublic static class Extensions\n{\n    public static HashSet<T> ToHashSet<T>(this IEnumerable<T> source) => new HashSet<T>(source);\n\n    private const string defaultSeparator = \" \";\n    public static string Delimit<T>(this IEnumerable<T> source, string separator = defaultSeparator) =>\n        string.Join(separator ?? defaultSeparator, source);\n\n    public static int Reverse(this int number)\n    {\n\tif (number < 0) return -Reverse(-number);\n\tif (number < 10) return number;\n\tint reverse = 0;\n\twhile (number > 0) {\n\t    reverse = reverse * 10 + number % 10;\n\t    number /= 10;\n\t}\n\treturn reverse;\n    }\n}\n"}
{"id": 130099, "name": "Emirp primes", "source": "Translate Fortran to Java:       MODULE BAG\t\n       INTEGER MSG\t\n       INTEGER PF16LIMIT,PF32LIMIT,NP\t\t\t\n       PARAMETER (PF16LIMIT = 3512, PF32LIMIT = 4793)\t\n       INTEGER*2 PRIME16(PF16LIMIT)\t\t\t\n       INTEGER*4 PRIME32(PF16LIMIT + 1:PF32LIMIT)\t\n       DATA NP,PRIME16(1),PRIME16(2)/2,2,3/\t\n       INTEGER NGP,NNP,NIP\t\n       DATA NGP,NNP,NIP/3*0/\t\n       CONTAINS\t\t\n        RECURSIVE INTEGER FUNCTION GETPRIME(I)\t\nChooses from amongst two arrays, of sizes known from previous work.\n         INTEGER I\t\t\n         INTEGER P\t\t\n         INTEGER MP\t\t\n          NGP = NGP + 1\t\t\n          IF (I.LE.0) THEN\t\n            GETPRIME = -666\t\t\n          ELSE IF (I.LE.NP) THEN\t\n            IF (I.LE.PF16LIMIT) THEN\t\t\n              GETPRIME = PRIME16(I)\t\t\n             ELSE\t\t\t\t\n              GETPRIME = PRIME32(I)\t\t\n            END IF\t\t\t\n          ELSE IF (I.LE.PF32LIMIT) THEN\t\n            MP = NP\t\t\t\n            P = GETPRIME(NP)\t\t\n   10       P = NEXTPRIME(P)\t\t\n            MP = MP + 1\t\t\t\n            IF (MP.LT.I) GO TO 10\t\n            GETPRIME = P\t\t\n           ELSE\t\t\t\n            WRITE (MSG,*) \"Hic\n            STOP \"Too far...\"\t\t\n          END IF\t\t\n        END FUNCTION GETPRIME\t\n\n        SUBROUTINE STASHPRIME(P)\t\n         INTEGER P\t\n          NP = NP + 1\t\t\n          IF (NP.LE.PF16LIMIT) THEN\t\n            PRIME16(NP) = P\t\t\t\n          ELSE IF (NP.LE.PF32LIMIT) THEN\n            PRIME32(NP) = P\t\t\t\n          ELSE\t\t\t\t\n            STOP \"Stash overflow\n          END IF\t\t\t\n        END SUBROUTINE STASHPRIME\t\n\n        INTEGER FUNCTION FINDPRIME(IT)\t\n         INTEGER IT\t\n         INTEGER L,R,P\t\n          L = 0\t\t\n          R = NP + 1\t\n    1     P = (R - L)/2\t\t\n          IF (P.LE.0) THEN\t\n            FINDPRIME = -L\t\t\n            RETURN\t\t\t\n          END IF\t\t\n          P = P + L\t\t\n          IF (IT - GETPRIME(P)) 2,4,3\t\n    2     R = P; GO TO 1\t\n    3     L = P; GO TO 1\t\n    4     FINDPRIME = P\t\t\n        END FUNCTION FINDPRIME\t\n\n        RECURSIVE INTEGER FUNCTION NEXTPRIME(P)\t\nChecks the stash in PRIME in the hope of finding the next prime directly, otherwise advances from P.\nCollates a stash of primes in PRIME16 and PRIME32, advancing NP from 2 to PF32LIMIT as it goes.\n         INTEGER P\t\n         INTEGER PI\t\n         INTEGER IT\t\n          NNP = NNP + 1\t\n          IF (P.LE.1) THEN\t\n            PI = 2\t\t\n           ELSE\t\t\t\n            IT = (ABS(FINDPRIME(P)))\t\n            IF (IT.LT.NP) THEN\t\t\n              PI = GETPRIME(IT + 1)\t\n             ELSE\t\n              IF (NP.LT.PF32LIMIT) THEN\t\n                PI = GETPRIME(IT)\t\n               ELSE\t\t\t\n                PI = P\t\t\t\n                IF (MOD(PI,2).EQ.0) PI = PI - 1\t\n              END IF\t\t\t\n              DO WHILE (PI.LE.P)\t\n   11           PI = PI + 2\t\t\t\n                IF (.NOT.ISPRIME(PI)) GO TO 11\t\n                IF (IT.EQ.NP .AND. IT.LT.PF32LIMIT) THEN\t\n                  CALL STASHPRIME(PI)\t\t\n                  IT = IT + 1\t\t\t\n                END IF\t\t\t\n              END DO\t\t\n            END IF\t\t\n          END IF\t\t\n          NEXTPRIME = PI\t\n        END FUNCTION NEXTPRIME\t\n\n        RECURSIVE LOGICAL FUNCTION ISPRIME(N)\t\nCrunches up to SQRT(N), and at worst needs to be able to reach Prime(4793) = 46349; greater than SQRT(2147483647) = 46340\u00b795...\n         INTEGER N\t\n         INTEGER I,F,Q\t\n          NIP = NIP + 1\t\n          IF (N.LT.2) THEN\t\n            ISPRIME = .FALSE.\t\n          ELSE\t\t\t\n            ISPRIME = .FALSE.\t\n            I = 1\t\t\n   10       F = GETPRIME(I)\t\n            Q = N/F\t\t\n            IF (Q .GE. F) THEN\t\n              IF (Q*F .EQ. N) RETURN\t\n              I = I + 1\t\t\n              GO TO 10\t\t\n            END IF\t\t\n            ISPRIME = .TRUE.\t\n          END IF\t\t\n        END FUNCTION ISPRIME\t\n\n        INTEGER FUNCTION ESREVER(IT,BASE)\t\n         INTEGER IT\t\n         INTEGER BASE\t\n         INTEGER N,R\t\n          IF (BASE.LE.1) STOP \"Base 2 at least\n          N = IT\t\n          R = 0\t\t\n          DO WHILE(N.GT.0)\t\n            R = R*BASE + MOD(N,BASE)\t\n            N = N/BASE\t\t\t\n          END DO\t\t\n          ESREVER = R\t\t\n        END FUNCTION ESREVER\t\n\n        SUBROUTINE EMIRP(BASE,N1,N2,I1,I2)\t\n         INTEGER BASE\t\n         INTEGER N1,N2\t\n         INTEGER I1,I2\t\n         INTEGER N\t\n         INTEGER P,R\t\n          WRITE (MSG,1) N1,N2,BASE,I1,I2\t\n    1     FORMAT (\"Show the first \",I0,\" to \",I0,\t\n     &     \" emirP numbers (base \",I0,\") between \",I0,\" and \",I0)\t\n          N = 0\t\t\n          P = I1 - 1\t\nChase another emirP.\n   10     P = NEXTPRIME(P)\t\t\n          IF (P.LT.I1) GO TO 10\t\t\n          IF (P.GT.I2) GO TO 900\t\n          R = ESREVER(P,BASE)\t\t\n          IF (P .EQ. R) GO TO 10\t\n          IF (.NOT.ISPRIME(R)) GO TO 10\t\n          N = N + 1\t\t\t\nc          if (mod(n,100) .eq. 0) then\nc            write (6,66) N,P,R,NP,NGP,NNP,NIP\nc   66       format (\"N=\",I5,\",p=\",I6,\",R=\",I6,\",NP=\",I6,3I12)\nc          end if\n          IF (N.GE.N1) WRITE (6,*) P,R\t\n          IF (N.LT.N2) GO TO 10\t\t\nClosedown.\n  900     WRITE (MSG,901) NP,GETPRIME(NP)\t\n  901     FORMAT (\"Stashed up to Prime(\",I0,\") = \",I0,/)\n        END SUBROUTINE EMIRP\t\n      END MODULE BAG\t\n\n      PROGRAM POKE\t\n      USE BAG\t\t\n      MSG = 6\t\t\n\n      CALL EMIRP(10,    1,   20,   1,   1000)\t\n      CALL EMIRP(10,    1,   28,7700,   8000)\t\n      CALL EMIRP(10,10000,10000,   1,1000000)\t\n\n      END\t\n", "target": "public class Emirp{\n\t\n\t\n\tpublic static boolean isPrime(long x){\n\t\tif(x < 2) return false;\n\t\tif(x == 2) return true;\n\t\tif((x & 1) == 0) return false;\n\t\t\n\t\tfor(long i = 3; i <= Math.sqrt(x);i+=2){\n\t\t\tif(x % i == 0) return false;\n\t\t}\n\t\t\n\t\treturn true;\n\t}\n\t\n\tpublic static boolean isEmirp(long x){\n\t\tString xString = Long.toString(x);\n\t\tif(xString.length() == 1) return false;\n\t\tif(xString.matches(\"[24568].*\") || xString.matches(\".*[24568]\")) return false; \n\t\tlong xR = Long.parseLong(new StringBuilder(xString).reverse().toString());\n\t\tif(xR == x) return false;\n\t\treturn isPrime(x) && isPrime(xR);\n\t}\n\t\n\tpublic static void main(String[] args){\n\t\tint count = 0;\n\t\tlong x = 1;\n\t\t\n\t\tSystem.out.println(\"First 20 emirps:\");\n\t\twhile(count < 20){\n\t\t\tif(isEmirp(x)){\n\t\t\t\tcount++;\n\t\t\t\tSystem.out.print(x + \" \");\n\t\t\t}\n\t\t\tx++;\n\t\t}\n\t\t\n\t\tSystem.out.println(\"\\nEmirps between 7700 and 8000:\");\n\t\tfor(x = 7700; x <= 8000; x++){\n\t\t\tif(isEmirp(x)){\n\t\t\t\tSystem.out.print(x +\" \");\n\t\t\t}\n\t\t}\n\t\t\n\t\tSystem.out.println(\"\\n10,000th emirp:\");\n\t\tfor(x = 1, count = 0;count < 10000; x++){\n\t\t\tif(isEmirp(x)){\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t\t\n\t\tSystem.out.println(--x);\n\t}\n}\n"}
{"id": 130100, "name": "Emirp primes", "source": "Translate Fortran to Python:       MODULE BAG\t\n       INTEGER MSG\t\n       INTEGER PF16LIMIT,PF32LIMIT,NP\t\t\t\n       PARAMETER (PF16LIMIT = 3512, PF32LIMIT = 4793)\t\n       INTEGER*2 PRIME16(PF16LIMIT)\t\t\t\n       INTEGER*4 PRIME32(PF16LIMIT + 1:PF32LIMIT)\t\n       DATA NP,PRIME16(1),PRIME16(2)/2,2,3/\t\n       INTEGER NGP,NNP,NIP\t\n       DATA NGP,NNP,NIP/3*0/\t\n       CONTAINS\t\t\n        RECURSIVE INTEGER FUNCTION GETPRIME(I)\t\nChooses from amongst two arrays, of sizes known from previous work.\n         INTEGER I\t\t\n         INTEGER P\t\t\n         INTEGER MP\t\t\n          NGP = NGP + 1\t\t\n          IF (I.LE.0) THEN\t\n            GETPRIME = -666\t\t\n          ELSE IF (I.LE.NP) THEN\t\n            IF (I.LE.PF16LIMIT) THEN\t\t\n              GETPRIME = PRIME16(I)\t\t\n             ELSE\t\t\t\t\n              GETPRIME = PRIME32(I)\t\t\n            END IF\t\t\t\n          ELSE IF (I.LE.PF32LIMIT) THEN\t\n            MP = NP\t\t\t\n            P = GETPRIME(NP)\t\t\n   10       P = NEXTPRIME(P)\t\t\n            MP = MP + 1\t\t\t\n            IF (MP.LT.I) GO TO 10\t\n            GETPRIME = P\t\t\n           ELSE\t\t\t\n            WRITE (MSG,*) \"Hic\n            STOP \"Too far...\"\t\t\n          END IF\t\t\n        END FUNCTION GETPRIME\t\n\n        SUBROUTINE STASHPRIME(P)\t\n         INTEGER P\t\n          NP = NP + 1\t\t\n          IF (NP.LE.PF16LIMIT) THEN\t\n            PRIME16(NP) = P\t\t\t\n          ELSE IF (NP.LE.PF32LIMIT) THEN\n            PRIME32(NP) = P\t\t\t\n          ELSE\t\t\t\t\n            STOP \"Stash overflow\n          END IF\t\t\t\n        END SUBROUTINE STASHPRIME\t\n\n        INTEGER FUNCTION FINDPRIME(IT)\t\n         INTEGER IT\t\n         INTEGER L,R,P\t\n          L = 0\t\t\n          R = NP + 1\t\n    1     P = (R - L)/2\t\t\n          IF (P.LE.0) THEN\t\n            FINDPRIME = -L\t\t\n            RETURN\t\t\t\n          END IF\t\t\n          P = P + L\t\t\n          IF (IT - GETPRIME(P)) 2,4,3\t\n    2     R = P; GO TO 1\t\n    3     L = P; GO TO 1\t\n    4     FINDPRIME = P\t\t\n        END FUNCTION FINDPRIME\t\n\n        RECURSIVE INTEGER FUNCTION NEXTPRIME(P)\t\nChecks the stash in PRIME in the hope of finding the next prime directly, otherwise advances from P.\nCollates a stash of primes in PRIME16 and PRIME32, advancing NP from 2 to PF32LIMIT as it goes.\n         INTEGER P\t\n         INTEGER PI\t\n         INTEGER IT\t\n          NNP = NNP + 1\t\n          IF (P.LE.1) THEN\t\n            PI = 2\t\t\n           ELSE\t\t\t\n            IT = (ABS(FINDPRIME(P)))\t\n            IF (IT.LT.NP) THEN\t\t\n              PI = GETPRIME(IT + 1)\t\n             ELSE\t\n              IF (NP.LT.PF32LIMIT) THEN\t\n                PI = GETPRIME(IT)\t\n               ELSE\t\t\t\n                PI = P\t\t\t\n                IF (MOD(PI,2).EQ.0) PI = PI - 1\t\n              END IF\t\t\t\n              DO WHILE (PI.LE.P)\t\n   11           PI = PI + 2\t\t\t\n                IF (.NOT.ISPRIME(PI)) GO TO 11\t\n                IF (IT.EQ.NP .AND. IT.LT.PF32LIMIT) THEN\t\n                  CALL STASHPRIME(PI)\t\t\n                  IT = IT + 1\t\t\t\n                END IF\t\t\t\n              END DO\t\t\n            END IF\t\t\n          END IF\t\t\n          NEXTPRIME = PI\t\n        END FUNCTION NEXTPRIME\t\n\n        RECURSIVE LOGICAL FUNCTION ISPRIME(N)\t\nCrunches up to SQRT(N), and at worst needs to be able to reach Prime(4793) = 46349; greater than SQRT(2147483647) = 46340\u00b795...\n         INTEGER N\t\n         INTEGER I,F,Q\t\n          NIP = NIP + 1\t\n          IF (N.LT.2) THEN\t\n            ISPRIME = .FALSE.\t\n          ELSE\t\t\t\n            ISPRIME = .FALSE.\t\n            I = 1\t\t\n   10       F = GETPRIME(I)\t\n            Q = N/F\t\t\n            IF (Q .GE. F) THEN\t\n              IF (Q*F .EQ. N) RETURN\t\n              I = I + 1\t\t\n              GO TO 10\t\t\n            END IF\t\t\n            ISPRIME = .TRUE.\t\n          END IF\t\t\n        END FUNCTION ISPRIME\t\n\n        INTEGER FUNCTION ESREVER(IT,BASE)\t\n         INTEGER IT\t\n         INTEGER BASE\t\n         INTEGER N,R\t\n          IF (BASE.LE.1) STOP \"Base 2 at least\n          N = IT\t\n          R = 0\t\t\n          DO WHILE(N.GT.0)\t\n            R = R*BASE + MOD(N,BASE)\t\n            N = N/BASE\t\t\t\n          END DO\t\t\n          ESREVER = R\t\t\n        END FUNCTION ESREVER\t\n\n        SUBROUTINE EMIRP(BASE,N1,N2,I1,I2)\t\n         INTEGER BASE\t\n         INTEGER N1,N2\t\n         INTEGER I1,I2\t\n         INTEGER N\t\n         INTEGER P,R\t\n          WRITE (MSG,1) N1,N2,BASE,I1,I2\t\n    1     FORMAT (\"Show the first \",I0,\" to \",I0,\t\n     &     \" emirP numbers (base \",I0,\") between \",I0,\" and \",I0)\t\n          N = 0\t\t\n          P = I1 - 1\t\nChase another emirP.\n   10     P = NEXTPRIME(P)\t\t\n          IF (P.LT.I1) GO TO 10\t\t\n          IF (P.GT.I2) GO TO 900\t\n          R = ESREVER(P,BASE)\t\t\n          IF (P .EQ. R) GO TO 10\t\n          IF (.NOT.ISPRIME(R)) GO TO 10\t\n          N = N + 1\t\t\t\nc          if (mod(n,100) .eq. 0) then\nc            write (6,66) N,P,R,NP,NGP,NNP,NIP\nc   66       format (\"N=\",I5,\",p=\",I6,\",R=\",I6,\",NP=\",I6,3I12)\nc          end if\n          IF (N.GE.N1) WRITE (6,*) P,R\t\n          IF (N.LT.N2) GO TO 10\t\t\nClosedown.\n  900     WRITE (MSG,901) NP,GETPRIME(NP)\t\n  901     FORMAT (\"Stashed up to Prime(\",I0,\") = \",I0,/)\n        END SUBROUTINE EMIRP\t\n      END MODULE BAG\t\n\n      PROGRAM POKE\t\n      USE BAG\t\t\n      MSG = 6\t\t\n\n      CALL EMIRP(10,    1,   20,   1,   1000)\t\n      CALL EMIRP(10,    1,   28,7700,   8000)\t\n      CALL EMIRP(10,10000,10000,   1,1000000)\t\n\n      END\t\n", "target": "from __future__ import print_function\nfrom prime_decomposition import primes, is_prime\nfrom heapq import *\nfrom itertools import islice\n\ndef emirp():\n    largest = set()\n    emirps = []\n    heapify(emirps)\n    for pr in primes():\n        while emirps and pr > emirps[0]:\n            yield heappop(emirps)\n        if pr in largest:\n            yield pr\n        else:\n            rp = int(str(pr)[::-1])\n            if rp > pr and is_prime(rp):\n                heappush(emirps, pr)\n                largest.add(rp)\n\nprint('First 20:\\n  ', list(islice(emirp(), 20)))\nprint('Between 7700 and 8000:\\n  [', end='')\nfor pr in emirp():\n    if pr >= 8000: break\n    if pr >= 7700: print(pr, end=', ')\nprint(']')\nprint('10000th:\\n  ', list(islice(emirp(), 10000-1, 10000)))\n"}
{"id": 131379, "name": "Constrained random points on a circle", "source": "Translate Fortran to C#: program Constrained_Points\n  implicit none\n \n  integer, parameter :: samples = 100\n  integer :: i, j, n, randpoint\n  real :: r\n \n  type points\n    integer :: x, y\n  end type\n\n  type(points) :: set(500), temp\n\n\n  n = 0\n  do i = -15, 15\n    do j = -15, 15\n      if(sqrt(real(i*i + j*j)) >= 10.0 .and. sqrt(real(i*i + j*j)) <= 15.0) then\n        n = n + 1\n        set(n)%x = i\n        set(n)%y = j\n      end if\n    end do\n  end do\n\n\n\n\n\n  call random_seed\n  do i = 1, samples\n    call random_number(r)\n    randpoint = r * (n + 1 - i) + i\n    temp = set(i)\n    set(i) = set(randpoint)\n    set(randpoint) = temp\n  end do\n\n\n\n  do i = 2, samples\n     j = i - 1\n     temp = set(i)\n        do while (j>=1 .and. set(j)%x > temp%x)\n           set(j+1) = set(j)\n           j = j - 1\n        end do\n     set(j+1) = temp\n  end do\n\n\n  do i = 2, samples\n     j = i - 1\n     temp = set(i)\n        do while (j>=1 .and. set(j)%x == temp%x .and. set(j)%y > temp%y)\n           set(j+1) = set(j)\n           j = j - 1\n        end do\n     set(j+1) = temp\n  end do\n  \n\n  write(*,\"(a,a)\", advance=\"no\") repeat(\" \", set(1)%y+15), \"*\"\n  do i = 2, samples\n    if(set(i)%x == set(i-1)%x) then\n      write(*,\"(a,a)\", advance=\"no\") repeat(\" \", set(i)%y - set(i-1)%y-1), \"*\"\n    else\n      n = set(i)%x - set(i-1)%x\n      do j = 1, n\n        write(*,*)\n      end do\n      write(*,\"(a,a)\", advance=\"no\") repeat(\" \", set(i)%y+15), \"*\"\n    end if\n  end do\n \nend program\n", "target": "using System;\nusing System.Diagnostics;\nusing System.Drawing;\n\nnamespace RosettaConstrainedRandomCircle\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            var points = new Point[404];\n            int i = 0;\n            for (int y = -15; y <= 15; y++)\n                for (int x = -15; x <= 15 && i < 404; x++)\n                {\n                    var c = Math.Sqrt(x * x + y * y);\n                    if (10 <= c && c <= 15)\n                    {\n                        points[i++] = new Point(x, y);\n                    }\n                }\n\n            var bm = new Bitmap(600, 600);\n            var g = Graphics.FromImage(bm);\n            var brush = new SolidBrush(Color.Magenta);\n\n            var r = new System.Random();\n            for (int count = 0; count < 100; count++)\n            {\n                var p = points[r.Next(404)];\n                g.FillEllipse(brush, new Rectangle(290 + 19 * p.X, 290 + 19 * p.Y, 10, 10));\n            }\n            const string filename = \"Constrained Random Circle.png\";\n            bm.Save(filename);\n            Process.Start(filename);\n        }\n    }\n}\n"}
{"id": 131383, "name": "Constrained random points on a circle", "source": "Translate Fortran to Java: program Constrained_Points\n  implicit none\n \n  integer, parameter :: samples = 100\n  integer :: i, j, n, randpoint\n  real :: r\n \n  type points\n    integer :: x, y\n  end type\n\n  type(points) :: set(500), temp\n\n\n  n = 0\n  do i = -15, 15\n    do j = -15, 15\n      if(sqrt(real(i*i + j*j)) >= 10.0 .and. sqrt(real(i*i + j*j)) <= 15.0) then\n        n = n + 1\n        set(n)%x = i\n        set(n)%y = j\n      end if\n    end do\n  end do\n\n\n\n\n\n  call random_seed\n  do i = 1, samples\n    call random_number(r)\n    randpoint = r * (n + 1 - i) + i\n    temp = set(i)\n    set(i) = set(randpoint)\n    set(randpoint) = temp\n  end do\n\n\n\n  do i = 2, samples\n     j = i - 1\n     temp = set(i)\n        do while (j>=1 .and. set(j)%x > temp%x)\n           set(j+1) = set(j)\n           j = j - 1\n        end do\n     set(j+1) = temp\n  end do\n\n\n  do i = 2, samples\n     j = i - 1\n     temp = set(i)\n        do while (j>=1 .and. set(j)%x == temp%x .and. set(j)%y > temp%y)\n           set(j+1) = set(j)\n           j = j - 1\n        end do\n     set(j+1) = temp\n  end do\n  \n\n  write(*,\"(a,a)\", advance=\"no\") repeat(\" \", set(1)%y+15), \"*\"\n  do i = 2, samples\n    if(set(i)%x == set(i-1)%x) then\n      write(*,\"(a,a)\", advance=\"no\") repeat(\" \", set(i)%y - set(i-1)%y-1), \"*\"\n    else\n      n = set(i)%x - set(i-1)%x\n      do j = 1, n\n        write(*,*)\n      end do\n      write(*,\"(a,a)\", advance=\"no\") repeat(\" \", set(i)%y+15), \"*\"\n    end if\n  end do\n \nend program\n", "target": "import java.util.Random;\n\npublic class FuzzyCircle {\n\tstatic final Random rnd = new Random();\n\tpublic static void main(String[] args){\n\t\tchar[][] field = new char[31][31];\n\t\tfor(int i = 0; i < field.length; i++){\n\t\t\tfor(int j = 0; j < field[i].length; j++){\n\t\t\t\tfield[i][j] = ' ';\n\t\t\t}\n\t\t}\n\t\tint pointsInDisc = 0;\n\t\twhile(pointsInDisc < 100){\n\t\t\tint x = rnd.nextInt(31) - 15;\n\t\t\tint y = rnd.nextInt(31) - 15;\n\t\t\tdouble dist = Math.hypot(x, y);\n\t\t\tif(dist >= 10 && dist <= 15 && field[x + 15][y + 15] == ' '){\n\t\t\t\tfield[x + 15][y + 15] = 'X';\n\t\t\t\tpointsInDisc++;\n\t\t\t}\n\t\t}\n\t\tfor(char[] row:field){\n\t\t\tfor(char space:row){\n\t\t\t\tSystem.out.print(space);\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t}\n}\n"}
{"id": 131384, "name": "Constrained random points on a circle", "source": "Translate Fortran to Python: program Constrained_Points\n  implicit none\n \n  integer, parameter :: samples = 100\n  integer :: i, j, n, randpoint\n  real :: r\n \n  type points\n    integer :: x, y\n  end type\n\n  type(points) :: set(500), temp\n\n\n  n = 0\n  do i = -15, 15\n    do j = -15, 15\n      if(sqrt(real(i*i + j*j)) >= 10.0 .and. sqrt(real(i*i + j*j)) <= 15.0) then\n        n = n + 1\n        set(n)%x = i\n        set(n)%y = j\n      end if\n    end do\n  end do\n\n\n\n\n\n  call random_seed\n  do i = 1, samples\n    call random_number(r)\n    randpoint = r * (n + 1 - i) + i\n    temp = set(i)\n    set(i) = set(randpoint)\n    set(randpoint) = temp\n  end do\n\n\n\n  do i = 2, samples\n     j = i - 1\n     temp = set(i)\n        do while (j>=1 .and. set(j)%x > temp%x)\n           set(j+1) = set(j)\n           j = j - 1\n        end do\n     set(j+1) = temp\n  end do\n\n\n  do i = 2, samples\n     j = i - 1\n     temp = set(i)\n        do while (j>=1 .and. set(j)%x == temp%x .and. set(j)%y > temp%y)\n           set(j+1) = set(j)\n           j = j - 1\n        end do\n     set(j+1) = temp\n  end do\n  \n\n  write(*,\"(a,a)\", advance=\"no\") repeat(\" \", set(1)%y+15), \"*\"\n  do i = 2, samples\n    if(set(i)%x == set(i-1)%x) then\n      write(*,\"(a,a)\", advance=\"no\") repeat(\" \", set(i)%y - set(i-1)%y-1), \"*\"\n    else\n      n = set(i)%x - set(i-1)%x\n      do j = 1, n\n        write(*,*)\n      end do\n      write(*,\"(a,a)\", advance=\"no\") repeat(\" \", set(i)%y+15), \"*\"\n    end if\n  end do\n \nend program\n", "target": ">>> from collections import defaultdict\n>>> from random import choice\n>>> world = defaultdict(int)\n>>> possiblepoints = [(x,y) for x in range(-15,16)\n\t\t  for y in range(-15,16)\n\t\t  if 10 <= abs(x+y*1j) <= 15]\n>>> for i in range(100): world[choice(possiblepoints)] += 1\n\n>>> for x in range(-15,16):\n\tprint(''.join(str(min([9, world[(x,y)]])) if world[(x,y)] else ' '\n\t\t\t  for y in range(-15,16)))\n\n\t\n                               \n             1     1           \n          1 1                  \n      11 1     1  1     1      \n     111  1     1211           \n      1   2    1 1    11       \n      1  11         21         \n     1   1            11  1    \n   1  2                1 1     \n                               \n 1  2                          \n   1 1                      1  \n   1 1                         \n   2                      11   \n  1                         1  \n                         1     \n                               \n                               \n  1                          1 \n                         1     \n                         2     \n                            1  \n     1                  1 1    \n      1                2   1   \n   1   3            11  2      \n    11   1    1      1   2     \n            1   1    2         \n        1  1                   \n         1      1     1        \n          2 2   1              \n               1\n"}
{"id": 131551, "name": "Call an object method", "source": "Translate Fortran to C#: \ntype my_type\n contains\nprocedure, pass :: method1\nprocedure, pass, pointer :: method2\nend type my_type\n\n\ntype(my_type) :: mytype_object\n\n\n call mytype_object%method1() \n\n mytype_object%method2() \n", "target": "\nMyClass.Method(someParameter);\n \n\nmyInstance.Method(someParameter);\n"}
{"id": 131554, "name": "Call an object method", "source": "Translate Fortran to Java: \ntype my_type\n contains\nprocedure, pass :: method1\nprocedure, pass, pointer :: method2\nend type my_type\n\n\ntype(my_type) :: mytype_object\n\n\n call mytype_object%method1() \n\n mytype_object%method2() \n", "target": "\nMyClass.method(someParameter);\n\n\nmyInstance.method(someParameter);\n"}
{"id": 131555, "name": "Call an object method", "source": "Translate Fortran to Python: \ntype my_type\n contains\nprocedure, pass :: method1\nprocedure, pass, pointer :: method2\nend type my_type\n\n\ntype(my_type) :: mytype_object\n\n\n call mytype_object%method1() \n\n mytype_object%method2() \n", "target": "class MyClass(object):\n\t@classmethod\n\tdef myClassMethod(self, x):\n\t\tpass\n\t@staticmethod\n\tdef myStaticMethod(x):\n\t\tpass\n\tdef myMethod(self, x):\n\t\treturn 42 + x\n\nmyInstance = MyClass()\n\n\nmyInstance.myMethod(someParameter)\n\nMyClass.myMethod(myInstance, someParameter)\n\n\n\nMyClass.myClassMethod(someParameter)\nMyClass.myStaticMethod(someParameter)\n\nmyInstance.myClassMethod(someParameter)\nmyInstance.myStaticMethod(someParameter)\n"}
{"id": 131742, "name": "SHA-256", "source": "Translate Fortran to C#: module sha256_mod\n    use kernel32\n    use advapi32\n    implicit none\n    integer, parameter :: SHA256LEN = 32\ncontains\n    subroutine sha256hash(name, hash, dwStatus, filesize)\n        implicit none\n        character(*) :: name\n        integer, parameter :: BUFLEN = 32768\n        integer(HANDLE) :: hFile, hProv, hHash\n        integer(DWORD) :: dwStatus, nRead\n        integer(BOOL) :: status\n        integer(BYTE) :: buffer(BUFLEN)\n        integer(BYTE) :: hash(SHA256LEN)\n        integer(UINT64) :: filesize\n \n        dwStatus = 0\n        filesize = 0\n        hFile = CreateFile(trim(name) // char(0), GENERIC_READ, FILE_SHARE_READ, NULL, &\n                           OPEN_EXISTING, FILE_FLAG_SEQUENTIAL_SCAN, NULL)\n \n        if (hFile == INVALID_HANDLE_VALUE) then\n            dwStatus = GetLastError()\n            print *, \"CreateFile failed.\"\n            return\n        end if\n \n        if (CryptAcquireContext(hProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, &\n                                CRYPT_VERIFYCONTEXT) == FALSE) then\n \n            dwStatus = GetLastError()\n            print *, \"CryptAcquireContext failed.\", dwStatus\n            goto 3\n        end if\n \n        if (CryptCreateHash(hProv, CALG_SHA_256, 0_ULONG_PTR, 0_DWORD, hHash) == FALSE) then\n \n            dwStatus = GetLastError()\n            print *, \"CryptCreateHash failed.\"\n            go to 2\n        end if\n \n        do\n            status = ReadFile(hFile, loc(buffer), BUFLEN, nRead, NULL)\n            if (status == FALSE .or. nRead == 0) exit\n            filesize = filesize + nRead\n            if (CryptHashData(hHash, buffer, nRead, 0) == FALSE) then\n                dwStatus = GetLastError()\n                print *, \"CryptHashData failed.\"\n                go to 1\n            end if\n        end do\n \n        if (status == FALSE) then\n            dwStatus = GetLastError()\n            print *, \"ReadFile failed.\"\n            go to 1\n        end if\n \n        nRead = SHA256LEN\n        if (CryptGetHashParam(hHash, HP_HASHVAL, hash, nRead, 0) == FALSE) then\n            dwStatus = GetLastError()\n            print *, \"CryptGetHashParam failed.\"\n        end if\n \n      1 status = CryptDestroyHash(hHash)\n      2 status = CryptReleaseContext(hProv, 0)\n      3 status = CloseHandle(hFile)\n    end subroutine\nend module\n \nprogram sha256\n    use sha256_mod\n    implicit none\n    integer :: n, m, i, j\n    character(:), allocatable :: name\n    integer(DWORD) :: dwStatus\n    integer(BYTE) :: hash(SHA256LEN)\n    integer(UINT64) :: filesize\n \n    n = command_argument_count()\n    do i = 1, n\n        call get_command_argument(i, length=m)\n        allocate(character(m) :: name)\n        call get_command_argument(i, name)\n        call sha256hash(name, hash, dwStatus, filesize)\n        if (dwStatus == 0) then\n            do j = 1, SHA256LEN\n                write(*, \"(Z2.2)\", advance=\"NO\") hash(j)\n            end do\n            write(*, \"(' ',A,' (',G0,' bytes)')\") name, filesize\n        end if\n        deallocate(name)\n    end do\nend program\n", "target": "using System;\nusing System.Security.Cryptography;\nusing System.Text;\nusing Microsoft.VisualStudio.TestTools.UnitTesting;\n\nnamespace RosettaCode.SHA256\n{\n    [TestClass]\n    public class SHA256ManagedTest\n    {\n        [TestMethod]\n        public void TestComputeHash()\n        {\n            var buffer = Encoding.UTF8.GetBytes(\"Rosetta code\");\n            var hashAlgorithm = new SHA256Managed();\n            var hash = hashAlgorithm.ComputeHash(buffer);\n            Assert.AreEqual(\n                \"76-4F-AF-5C-61-AC-31-5F-14-97-F9-DF-A5-42-71-39-65-B7-85-E5-CC-2F-70-7D-64-68-D7-D1-12-4C-DF-CF\",\n                BitConverter.ToString(hash));\n        }\n    }\n}\n"}
{"id": 131746, "name": "SHA-256", "source": "Translate Fortran to Python: module sha256_mod\n    use kernel32\n    use advapi32\n    implicit none\n    integer, parameter :: SHA256LEN = 32\ncontains\n    subroutine sha256hash(name, hash, dwStatus, filesize)\n        implicit none\n        character(*) :: name\n        integer, parameter :: BUFLEN = 32768\n        integer(HANDLE) :: hFile, hProv, hHash\n        integer(DWORD) :: dwStatus, nRead\n        integer(BOOL) :: status\n        integer(BYTE) :: buffer(BUFLEN)\n        integer(BYTE) :: hash(SHA256LEN)\n        integer(UINT64) :: filesize\n \n        dwStatus = 0\n        filesize = 0\n        hFile = CreateFile(trim(name) // char(0), GENERIC_READ, FILE_SHARE_READ, NULL, &\n                           OPEN_EXISTING, FILE_FLAG_SEQUENTIAL_SCAN, NULL)\n \n        if (hFile == INVALID_HANDLE_VALUE) then\n            dwStatus = GetLastError()\n            print *, \"CreateFile failed.\"\n            return\n        end if\n \n        if (CryptAcquireContext(hProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, &\n                                CRYPT_VERIFYCONTEXT) == FALSE) then\n \n            dwStatus = GetLastError()\n            print *, \"CryptAcquireContext failed.\", dwStatus\n            goto 3\n        end if\n \n        if (CryptCreateHash(hProv, CALG_SHA_256, 0_ULONG_PTR, 0_DWORD, hHash) == FALSE) then\n \n            dwStatus = GetLastError()\n            print *, \"CryptCreateHash failed.\"\n            go to 2\n        end if\n \n        do\n            status = ReadFile(hFile, loc(buffer), BUFLEN, nRead, NULL)\n            if (status == FALSE .or. nRead == 0) exit\n            filesize = filesize + nRead\n            if (CryptHashData(hHash, buffer, nRead, 0) == FALSE) then\n                dwStatus = GetLastError()\n                print *, \"CryptHashData failed.\"\n                go to 1\n            end if\n        end do\n \n        if (status == FALSE) then\n            dwStatus = GetLastError()\n            print *, \"ReadFile failed.\"\n            go to 1\n        end if\n \n        nRead = SHA256LEN\n        if (CryptGetHashParam(hHash, HP_HASHVAL, hash, nRead, 0) == FALSE) then\n            dwStatus = GetLastError()\n            print *, \"CryptGetHashParam failed.\"\n        end if\n \n      1 status = CryptDestroyHash(hHash)\n      2 status = CryptReleaseContext(hProv, 0)\n      3 status = CloseHandle(hFile)\n    end subroutine\nend module\n \nprogram sha256\n    use sha256_mod\n    implicit none\n    integer :: n, m, i, j\n    character(:), allocatable :: name\n    integer(DWORD) :: dwStatus\n    integer(BYTE) :: hash(SHA256LEN)\n    integer(UINT64) :: filesize\n \n    n = command_argument_count()\n    do i = 1, n\n        call get_command_argument(i, length=m)\n        allocate(character(m) :: name)\n        call get_command_argument(i, name)\n        call sha256hash(name, hash, dwStatus, filesize)\n        if (dwStatus == 0) then\n            do j = 1, SHA256LEN\n                write(*, \"(Z2.2)\", advance=\"NO\") hash(j)\n            end do\n            write(*, \"(' ',A,' (',G0,' bytes)')\") name, filesize\n        end if\n        deallocate(name)\n    end do\nend program\n", "target": ">>> import hashlib\n>>> hashlib.sha256( \"Rosetta code\".encode() ).hexdigest()\n'764faf5c61ac315f1497f9dfa542713965b785e5cc2f707d6468d7d1124cdfcf'\n>>>\n"}
{"id": 131923, "name": "Factors of a Mersenne number", "source": "Translate Fortran to C#: PROGRAM EXAMPLE\n  IMPLICIT NONE\n  INTEGER :: exponent, factor\n\n  WRITE(*,*) \"Enter exponent of Mersenne number\"\n  READ(*,*) exponent\n  factor = Mfactor(exponent)\n  IF (factor == 0) THEN\n    WRITE(*,*) \"No Factor found\"\n  ELSE\n    WRITE(*,\"(A,I0,A,I0)\") \"M\", exponent, \" has a factor: \", factor\n  END IF\n\nCONTAINS\n\nFUNCTION isPrime(number)\n\nEND FUNCTION\n\nFUNCTION  Mfactor(p)\n  INTEGER :: Mfactor\n  INTEGER, INTENT(IN) :: p\n  INTEGER :: i, k,  maxk, msb, n, q\n\n  DO i = 30, 0 , -1\n    IF(BTEST(p, i)) THEN\n      msb = i\n      EXIT\n    END IF\n  END DO\n \n  maxk = 16384  / p     \n  DO k = 1, maxk\n    q = 2*p*k + 1\n    IF (.NOT. isPrime(q)) CYCLE\n    IF (MOD(q, 8) /= 1 .AND. MOD(q, 8) /= 7) CYCLE\n    n = 1\n    DO i = msb, 0, -1\n      IF (BTEST(p, i)) THEN\n        n = MOD(n*n*2, q)\n      ELSE\n        n = MOD(n*n, q)\n      ENDIF\n    END DO\n    IF (n == 1) THEN\n      Mfactor = q\n      RETURN\n    END IF\n  END DO\n  Mfactor = 0\nEND FUNCTION\nEND PROGRAM EXAMPLE\n", "target": "using System;\n\nnamespace prog\n{\n\tclass MainClass\n\t{\n\t\tpublic static void Main (string[] args)\n\t\t{\n\t\t\tint q = 929;\n\t\t\tif ( !isPrime(q) ) return;\n\t\t\tint r = q;\n\t\t\twhile( r > 0 ) \n\t\t\t\tr <<= 1;\n\t\t\tint d = 2 * q + 1;\n\t\t\tdo\n\t\t\t{\n\t\t\t\tint i = 1;\n\t\t\t\tfor( int p=r; p!=0; p<<=1 )\n\t\t\t\t{\n\t\t\t\t\ti = (i*i) % d;\n\t\t\t\t\tif (p < 0) i *= 2;\n\t\t\t\t\tif (i > d) i -= d;\n\t\t\t\t}\n\t\t\t\tif (i != 1) d += 2 * q; else break;\t\t\t\t\n\t\t\t}\n\t\t\twhile(true);\n\t\t\t\n\t\t\tConsole.WriteLine(\"2^\"+q+\"-1 = 0 (mod \"+d+\")\"); \n\t\t}\n\t\t\n\t\tstatic bool isPrime(int n)\n\t\t{\n\t\t\tif ( n % 2 == 0 ) return n == 2;\n\t\t\tif ( n % 3 == 0 ) return n == 3;\n\t\t\tint d = 5;\n\t\t\twhile( d*d <= n )\n\t\t\t{\n\t\t\t\tif ( n % d == 0 ) return false;\n\t\t\t\td += 2;\n\t\t\t\tif ( n % d == 0 ) return false;\n\t\t\t\td += 4;\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\t}\n}\n"}
{"id": 131927, "name": "Factors of a Mersenne number", "source": "Translate Fortran to Java: PROGRAM EXAMPLE\n  IMPLICIT NONE\n  INTEGER :: exponent, factor\n\n  WRITE(*,*) \"Enter exponent of Mersenne number\"\n  READ(*,*) exponent\n  factor = Mfactor(exponent)\n  IF (factor == 0) THEN\n    WRITE(*,*) \"No Factor found\"\n  ELSE\n    WRITE(*,\"(A,I0,A,I0)\") \"M\", exponent, \" has a factor: \", factor\n  END IF\n\nCONTAINS\n\nFUNCTION isPrime(number)\n\nEND FUNCTION\n\nFUNCTION  Mfactor(p)\n  INTEGER :: Mfactor\n  INTEGER, INTENT(IN) :: p\n  INTEGER :: i, k,  maxk, msb, n, q\n\n  DO i = 30, 0 , -1\n    IF(BTEST(p, i)) THEN\n      msb = i\n      EXIT\n    END IF\n  END DO\n \n  maxk = 16384  / p     \n  DO k = 1, maxk\n    q = 2*p*k + 1\n    IF (.NOT. isPrime(q)) CYCLE\n    IF (MOD(q, 8) /= 1 .AND. MOD(q, 8) /= 7) CYCLE\n    n = 1\n    DO i = msb, 0, -1\n      IF (BTEST(p, i)) THEN\n        n = MOD(n*n*2, q)\n      ELSE\n        n = MOD(n*n, q)\n      ENDIF\n    END DO\n    IF (n == 1) THEN\n      Mfactor = q\n      RETURN\n    END IF\n  END DO\n  Mfactor = 0\nEND FUNCTION\nEND PROGRAM EXAMPLE\n", "target": "import java.math.BigInteger;\n\nclass MersenneFactorCheck\n{\n\n  private final static BigInteger TWO = BigInteger.valueOf(2);\n  \n  public static boolean isPrime(long n)\n  {\n    if (n == 2)\n      return true;\n    if ((n < 2) || ((n & 1) == 0))\n      return false;\n    long maxFactor = (long)Math.sqrt((double)n);\n    for (long possibleFactor = 3; possibleFactor <= maxFactor; possibleFactor += 2)\n      if ((n % possibleFactor) == 0)\n        return false;\n    return true;\n  }\n  \n  public static BigInteger findFactorMersenneNumber(int primeP)\n  {\n    if (primeP <= 0)\n      throw new IllegalArgumentException();\n    BigInteger bigP = BigInteger.valueOf(primeP);\n    BigInteger m = BigInteger.ONE.shiftLeft(primeP).subtract(BigInteger.ONE);\n    \n    BigInteger maxFactor = BigInteger.ONE.shiftLeft((primeP + 1) >>> 1);\n    BigInteger twoP = BigInteger.valueOf(primeP << 1);\n    BigInteger possibleFactor = BigInteger.ONE;\n    int possibleFactorBits12 = 0;\n    int twoPBits12 = primeP & 3;\n    \n    while ((possibleFactor = possibleFactor.add(twoP)).compareTo(maxFactor) <= 0)\n    {\n      possibleFactorBits12 = (possibleFactorBits12 + twoPBits12) & 3;\n      \n      if ((possibleFactorBits12 == 0) || (possibleFactorBits12 == 3))\n        if (TWO.modPow(bigP, possibleFactor).equals(BigInteger.ONE))\n          return possibleFactor;\n    }\n    return null;\n  }\n  \n  public static void checkMersenneNumber(int p)\n  {\n    if (!isPrime(p))\n    {\n      System.out.println(\"M\" + p + \" is not prime\");\n      return;\n    }\n    BigInteger factor = findFactorMersenneNumber(p);\n    if (factor == null)\n      System.out.println(\"M\" + p + \" is prime\");\n    else\n      System.out.println(\"M\" + p + \" is not prime, has factor \" + factor);\n    return;\n  }\n\n  public static void main(String[] args)\n  {\n    for (int p = 1; p <= 50; p++)\n      checkMersenneNumber(p);\n    checkMersenneNumber(929);\n    return;\n  }\n  \n}\n"}
{"id": 131928, "name": "Factors of a Mersenne number", "source": "Translate Fortran to Python: PROGRAM EXAMPLE\n  IMPLICIT NONE\n  INTEGER :: exponent, factor\n\n  WRITE(*,*) \"Enter exponent of Mersenne number\"\n  READ(*,*) exponent\n  factor = Mfactor(exponent)\n  IF (factor == 0) THEN\n    WRITE(*,*) \"No Factor found\"\n  ELSE\n    WRITE(*,\"(A,I0,A,I0)\") \"M\", exponent, \" has a factor: \", factor\n  END IF\n\nCONTAINS\n\nFUNCTION isPrime(number)\n\nEND FUNCTION\n\nFUNCTION  Mfactor(p)\n  INTEGER :: Mfactor\n  INTEGER, INTENT(IN) :: p\n  INTEGER :: i, k,  maxk, msb, n, q\n\n  DO i = 30, 0 , -1\n    IF(BTEST(p, i)) THEN\n      msb = i\n      EXIT\n    END IF\n  END DO\n \n  maxk = 16384  / p     \n  DO k = 1, maxk\n    q = 2*p*k + 1\n    IF (.NOT. isPrime(q)) CYCLE\n    IF (MOD(q, 8) /= 1 .AND. MOD(q, 8) /= 7) CYCLE\n    n = 1\n    DO i = msb, 0, -1\n      IF (BTEST(p, i)) THEN\n        n = MOD(n*n*2, q)\n      ELSE\n        n = MOD(n*n, q)\n      ENDIF\n    END DO\n    IF (n == 1) THEN\n      Mfactor = q\n      RETURN\n    END IF\n  END DO\n  Mfactor = 0\nEND FUNCTION\nEND PROGRAM EXAMPLE\n", "target": "def is_prime(number):\n    return True \n\ndef m_factor(p):\n    max_k = 16384 / p \n    for k in xrange(max_k):\n        q = 2*p*k + 1\n        if not is_prime(q):\n            continue\n        elif q % 8 != 1 and q % 8 != 7:\n            continue\n        elif pow(2, p, q) == 1:\n            return q\n    return None\n\nif __name__ == '__main__':\n    exponent = int(raw_input(\"Enter exponent of Mersenne number: \"))\n    if not is_prime(exponent):\n        print \"Exponent is not prime: %d\" % exponent\n    else:\n        factor = m_factor(exponent)\n        if not factor:\n            print \"No factor found for M%d\" % exponent\n        else:\n            print \"M%d has a factor: %d\" % (exponent, factor)\n"}
{"id": 132236, "name": "Population count", "source": "Translate Fortran to C#: program population_count\n  implicit none\n\n  integer, parameter :: i64 = selected_int_kind(18)\n  integer(i64) :: x\n  integer :: i, n\n    \n  x = 1\n  write(*, \"(a8)\", advance = \"no\") \"3**i\u00a0:\"\n  do i = 1, 30\n    write(*, \"(i3)\", advance = \"no\") popcnt(x)\n    x = x * 3\n  end do\n\n  write(*,*)\n  write(*, \"(a8)\", advance = \"no\") \"Evil\u00a0:\"\n  n = 0\n  x = 0 \n  do while(n < 30)\n    if(mod(popcnt(x), 2) == 0) then\n      n = n + 1\n      write(*, \"(i3)\", advance = \"no\") x\n    end if\n    x = x + 1\n  end do\n\n  write(*,*)\n  write(*, \"(a8)\", advance = \"no\") \"Odious\u00a0:\"\n  n = 0\n  x = 0 \n  do while(n < 30)\n    if(mod(popcnt(x), 2) /= 0) then\n      n = n + 1\n      write(*, \"(i3)\", advance = \"no\") x\n    end if\n    x = x + 1\n  end do\n\ncontains\n\ninteger function popcnt(x)\n  integer(i64), intent(in) :: x\n  integer :: i\n\n  popcnt = 0\n  do i = 0, 63\n    if(btest(x, i)) popcnt = popcnt + 1\n  end do\n\nend function\nend program\n", "target": "using System;\nusing System.Linq;\n\nnamespace PopulationCount\n{\n    class Program\n    {\n        private static int PopulationCount(long n)\n        {\n            string binaryn = Convert.ToString(n, 2);\n            return binaryn.ToCharArray().Where(t => t == '1').Count();\n        }\n\n        static void Main(string[] args)\n        {\n            Console.WriteLine(\"Population Counts:\");\n            Console.Write(\"3^n\u00a0:   \");\n\n            int count = 0;\n\n            while (count < 30)\n            {\n                double n = Math.Pow(3f, (double)count);\n                int popCount = PopulationCount((long)n);\n                Console.Write(string.Format(\"{0} \", popCount));\n                count++;\n            }\n\n            Console.WriteLine();\n            Console.Write(\"Evil:   \");\n\n            count = 0;\n            int i = 0;\n\n            while (count < 30)\n            {\n                int popCount = PopulationCount(i);\n\n                if (popCount % 2 == 0)\n                {\n                    count++;\n                    Console.Write(string.Format(\"{0} \", i));\n                }\n\n                i++;\n            }\n\n            Console.WriteLine();\n            Console.Write(\"Odious: \");\n\n            count = 0;\n            i = 0;\n\n            while (count < 30)\n            {\n                int popCount = PopulationCount(i);\n\n                if (popCount % 2 != 0)\n                {\n                    count++;\n                    Console.Write(string.Format(\"{0} \", i));\n                }\n\n                i++;\n            }\n\n            Console.ReadKey();\n        }\n    }\n}\n"}
{"id": 132237, "name": "Population count", "source": "Translate Fortran to C#: program population_count\n  implicit none\n\n  integer, parameter :: i64 = selected_int_kind(18)\n  integer(i64) :: x\n  integer :: i, n\n    \n  x = 1\n  write(*, \"(a8)\", advance = \"no\") \"3**i\u00a0:\"\n  do i = 1, 30\n    write(*, \"(i3)\", advance = \"no\") popcnt(x)\n    x = x * 3\n  end do\n\n  write(*,*)\n  write(*, \"(a8)\", advance = \"no\") \"Evil\u00a0:\"\n  n = 0\n  x = 0 \n  do while(n < 30)\n    if(mod(popcnt(x), 2) == 0) then\n      n = n + 1\n      write(*, \"(i3)\", advance = \"no\") x\n    end if\n    x = x + 1\n  end do\n\n  write(*,*)\n  write(*, \"(a8)\", advance = \"no\") \"Odious\u00a0:\"\n  n = 0\n  x = 0 \n  do while(n < 30)\n    if(mod(popcnt(x), 2) /= 0) then\n      n = n + 1\n      write(*, \"(i3)\", advance = \"no\") x\n    end if\n    x = x + 1\n  end do\n\ncontains\n\ninteger function popcnt(x)\n  integer(i64), intent(in) :: x\n  integer :: i\n\n  popcnt = 0\n  do i = 0, 63\n    if(btest(x, i)) popcnt = popcnt + 1\n  end do\n\nend function\nend program\n", "target": "using System;\nusing System.Linq;\n\nnamespace PopulationCount\n{\n    class Program\n    {\n        private static int PopulationCount(long n)\n        {\n            string binaryn = Convert.ToString(n, 2);\n            return binaryn.ToCharArray().Where(t => t == '1').Count();\n        }\n\n        static void Main(string[] args)\n        {\n            Console.WriteLine(\"Population Counts:\");\n            Console.Write(\"3^n\u00a0:   \");\n\n            int count = 0;\n\n            while (count < 30)\n            {\n                double n = Math.Pow(3f, (double)count);\n                int popCount = PopulationCount((long)n);\n                Console.Write(string.Format(\"{0} \", popCount));\n                count++;\n            }\n\n            Console.WriteLine();\n            Console.Write(\"Evil:   \");\n\n            count = 0;\n            int i = 0;\n\n            while (count < 30)\n            {\n                int popCount = PopulationCount(i);\n\n                if (popCount % 2 == 0)\n                {\n                    count++;\n                    Console.Write(string.Format(\"{0} \", i));\n                }\n\n                i++;\n            }\n\n            Console.WriteLine();\n            Console.Write(\"Odious: \");\n\n            count = 0;\n            i = 0;\n\n            while (count < 30)\n            {\n                int popCount = PopulationCount(i);\n\n                if (popCount % 2 != 0)\n                {\n                    count++;\n                    Console.Write(string.Format(\"{0} \", i));\n                }\n\n                i++;\n            }\n\n            Console.ReadKey();\n        }\n    }\n}\n"}
{"id": 132243, "name": "Population count", "source": "Translate Fortran to Java: program population_count\n  implicit none\n\n  integer, parameter :: i64 = selected_int_kind(18)\n  integer(i64) :: x\n  integer :: i, n\n    \n  x = 1\n  write(*, \"(a8)\", advance = \"no\") \"3**i\u00a0:\"\n  do i = 1, 30\n    write(*, \"(i3)\", advance = \"no\") popcnt(x)\n    x = x * 3\n  end do\n\n  write(*,*)\n  write(*, \"(a8)\", advance = \"no\") \"Evil\u00a0:\"\n  n = 0\n  x = 0 \n  do while(n < 30)\n    if(mod(popcnt(x), 2) == 0) then\n      n = n + 1\n      write(*, \"(i3)\", advance = \"no\") x\n    end if\n    x = x + 1\n  end do\n\n  write(*,*)\n  write(*, \"(a8)\", advance = \"no\") \"Odious\u00a0:\"\n  n = 0\n  x = 0 \n  do while(n < 30)\n    if(mod(popcnt(x), 2) /= 0) then\n      n = n + 1\n      write(*, \"(i3)\", advance = \"no\") x\n    end if\n    x = x + 1\n  end do\n\ncontains\n\ninteger function popcnt(x)\n  integer(i64), intent(in) :: x\n  integer :: i\n\n  popcnt = 0\n  do i = 0, 63\n    if(btest(x, i)) popcnt = popcnt + 1\n  end do\n\nend function\nend program\n", "target": "import java.math.BigInteger;\n\npublic class PopCount {\n    public static void main(String[] args) {\n\t{ \n\t    System.out.print(\"32-bit integer: \");\n\t    int n = 1;\n\t    for (int i = 0; i < 20; i++) {\n\t\tSystem.out.printf(\"%d \", Integer.bitCount(n));\n\t\tn *= 3;\n\t    }\n\t    System.out.println();\n\t}\n\t{ \n\t    System.out.print(\"64-bit integer: \");\n\t    long n = 1;\n\t    for (int i = 0; i < 30; i++) {\n\t\tSystem.out.printf(\"%d \", Long.bitCount(n));\n\t\tn *= 3;\n\t    }\n\t    System.out.println();\n\t}\n\t{ \n\t    System.out.print(\"big integer  \u00a0: \");\n\t    BigInteger n = BigInteger.ONE;\n\t    BigInteger three = BigInteger.valueOf(3);\n\t    for (int i = 0; i < 30; i++) {\n\t\tSystem.out.printf(\"%d \", n.bitCount());\n\t\tn = n.multiply(three);\n\t    }\n\t    System.out.println();\n\t}\n\n\tint[] od = new int[30];\n\tint ne = 0, no = 0;\n\tSystem.out.print(\"evil  \u00a0: \");\n\tfor (int n = 0; ne+no < 60; n++) {\n\t    if ((Integer.bitCount(n) & 1) == 0) {\n\t\tif (ne < 30) {\n\t\t    System.out.printf(\"%d \", n);\n\t\t    ne++;\n\t\t}\n\t    } else {\n\t\tif (no < 30) {\n\t\t    od[no++] = n;\n\t\t}\n\t    }\n\t}\n\tSystem.out.println();\n\tSystem.out.print(\"odious\u00a0: \");\n\tfor (int n : od) {\n\t    System.out.printf(\"%d \", n);\n\t}\n\tSystem.out.println();\n    }\n}\n"}
{"id": 132244, "name": "Population count", "source": "Translate Fortran to Java: program population_count\n  implicit none\n\n  integer, parameter :: i64 = selected_int_kind(18)\n  integer(i64) :: x\n  integer :: i, n\n    \n  x = 1\n  write(*, \"(a8)\", advance = \"no\") \"3**i\u00a0:\"\n  do i = 1, 30\n    write(*, \"(i3)\", advance = \"no\") popcnt(x)\n    x = x * 3\n  end do\n\n  write(*,*)\n  write(*, \"(a8)\", advance = \"no\") \"Evil\u00a0:\"\n  n = 0\n  x = 0 \n  do while(n < 30)\n    if(mod(popcnt(x), 2) == 0) then\n      n = n + 1\n      write(*, \"(i3)\", advance = \"no\") x\n    end if\n    x = x + 1\n  end do\n\n  write(*,*)\n  write(*, \"(a8)\", advance = \"no\") \"Odious\u00a0:\"\n  n = 0\n  x = 0 \n  do while(n < 30)\n    if(mod(popcnt(x), 2) /= 0) then\n      n = n + 1\n      write(*, \"(i3)\", advance = \"no\") x\n    end if\n    x = x + 1\n  end do\n\ncontains\n\ninteger function popcnt(x)\n  integer(i64), intent(in) :: x\n  integer :: i\n\n  popcnt = 0\n  do i = 0, 63\n    if(btest(x, i)) popcnt = popcnt + 1\n  end do\n\nend function\nend program\n", "target": "import java.math.BigInteger;\n\npublic class PopCount {\n    public static void main(String[] args) {\n\t{ \n\t    System.out.print(\"32-bit integer: \");\n\t    int n = 1;\n\t    for (int i = 0; i < 20; i++) {\n\t\tSystem.out.printf(\"%d \", Integer.bitCount(n));\n\t\tn *= 3;\n\t    }\n\t    System.out.println();\n\t}\n\t{ \n\t    System.out.print(\"64-bit integer: \");\n\t    long n = 1;\n\t    for (int i = 0; i < 30; i++) {\n\t\tSystem.out.printf(\"%d \", Long.bitCount(n));\n\t\tn *= 3;\n\t    }\n\t    System.out.println();\n\t}\n\t{ \n\t    System.out.print(\"big integer  \u00a0: \");\n\t    BigInteger n = BigInteger.ONE;\n\t    BigInteger three = BigInteger.valueOf(3);\n\t    for (int i = 0; i < 30; i++) {\n\t\tSystem.out.printf(\"%d \", n.bitCount());\n\t\tn = n.multiply(three);\n\t    }\n\t    System.out.println();\n\t}\n\n\tint[] od = new int[30];\n\tint ne = 0, no = 0;\n\tSystem.out.print(\"evil  \u00a0: \");\n\tfor (int n = 0; ne+no < 60; n++) {\n\t    if ((Integer.bitCount(n) & 1) == 0) {\n\t\tif (ne < 30) {\n\t\t    System.out.printf(\"%d \", n);\n\t\t    ne++;\n\t\t}\n\t    } else {\n\t\tif (no < 30) {\n\t\t    od[no++] = n;\n\t\t}\n\t    }\n\t}\n\tSystem.out.println();\n\tSystem.out.print(\"odious\u00a0: \");\n\tfor (int n : od) {\n\t    System.out.printf(\"%d \", n);\n\t}\n\tSystem.out.println();\n    }\n}\n"}
{"id": 132245, "name": "Population count", "source": "Translate Fortran to Python: program population_count\n  implicit none\n\n  integer, parameter :: i64 = selected_int_kind(18)\n  integer(i64) :: x\n  integer :: i, n\n    \n  x = 1\n  write(*, \"(a8)\", advance = \"no\") \"3**i\u00a0:\"\n  do i = 1, 30\n    write(*, \"(i3)\", advance = \"no\") popcnt(x)\n    x = x * 3\n  end do\n\n  write(*,*)\n  write(*, \"(a8)\", advance = \"no\") \"Evil\u00a0:\"\n  n = 0\n  x = 0 \n  do while(n < 30)\n    if(mod(popcnt(x), 2) == 0) then\n      n = n + 1\n      write(*, \"(i3)\", advance = \"no\") x\n    end if\n    x = x + 1\n  end do\n\n  write(*,*)\n  write(*, \"(a8)\", advance = \"no\") \"Odious\u00a0:\"\n  n = 0\n  x = 0 \n  do while(n < 30)\n    if(mod(popcnt(x), 2) /= 0) then\n      n = n + 1\n      write(*, \"(i3)\", advance = \"no\") x\n    end if\n    x = x + 1\n  end do\n\ncontains\n\ninteger function popcnt(x)\n  integer(i64), intent(in) :: x\n  integer :: i\n\n  popcnt = 0\n  do i = 0, 63\n    if(btest(x, i)) popcnt = popcnt + 1\n  end do\n\nend function\nend program\n", "target": ">>> def popcount(n): return bin(n).count(\"1\")\n... \n>>> [popcount(3**i) for i in range(30)]\n[1, 2, 2, 4, 3, 6, 6, 5, 6, 8, 9, 13, 10, 11, 14, 15, 11, 14, 14, 17, 17, 20, 19, 22, 16, 18, 24, 30, 25, 25]\n>>> evil, odious, i = [], [], 0\n>>> while len(evil) < 30 or len(odious) < 30:\n...     p = popcount(i)\n...     if p % 2: odious.append(i)\n...     else: evil.append(i)\n...     i += 1\n... \n>>> evil[:30]\n[0, 3, 5, 6, 9, 10, 12, 15, 17, 18, 20, 23, 24, 27, 29, 30, 33, 34, 36, 39, 40, 43, 45, 46, 48, 51, 53, 54, 57, 58]\n>>> odious[:30]\n[1, 2, 4, 7, 8, 11, 13, 14, 16, 19, 21, 22, 25, 26, 28, 31, 32, 35, 37, 38, 41, 42, 44, 47, 49, 50, 52, 55, 56, 59]\n>>>\n"}
{"id": 132246, "name": "Population count", "source": "Translate Fortran to Python: program population_count\n  implicit none\n\n  integer, parameter :: i64 = selected_int_kind(18)\n  integer(i64) :: x\n  integer :: i, n\n    \n  x = 1\n  write(*, \"(a8)\", advance = \"no\") \"3**i\u00a0:\"\n  do i = 1, 30\n    write(*, \"(i3)\", advance = \"no\") popcnt(x)\n    x = x * 3\n  end do\n\n  write(*,*)\n  write(*, \"(a8)\", advance = \"no\") \"Evil\u00a0:\"\n  n = 0\n  x = 0 \n  do while(n < 30)\n    if(mod(popcnt(x), 2) == 0) then\n      n = n + 1\n      write(*, \"(i3)\", advance = \"no\") x\n    end if\n    x = x + 1\n  end do\n\n  write(*,*)\n  write(*, \"(a8)\", advance = \"no\") \"Odious\u00a0:\"\n  n = 0\n  x = 0 \n  do while(n < 30)\n    if(mod(popcnt(x), 2) /= 0) then\n      n = n + 1\n      write(*, \"(i3)\", advance = \"no\") x\n    end if\n    x = x + 1\n  end do\n\ncontains\n\ninteger function popcnt(x)\n  integer(i64), intent(in) :: x\n  integer :: i\n\n  popcnt = 0\n  do i = 0, 63\n    if(btest(x, i)) popcnt = popcnt + 1\n  end do\n\nend function\nend program\n", "target": ">>> def popcount(n): return bin(n).count(\"1\")\n... \n>>> [popcount(3**i) for i in range(30)]\n[1, 2, 2, 4, 3, 6, 6, 5, 6, 8, 9, 13, 10, 11, 14, 15, 11, 14, 14, 17, 17, 20, 19, 22, 16, 18, 24, 30, 25, 25]\n>>> evil, odious, i = [], [], 0\n>>> while len(evil) < 30 or len(odious) < 30:\n...     p = popcount(i)\n...     if p % 2: odious.append(i)\n...     else: evil.append(i)\n...     i += 1\n... \n>>> evil[:30]\n[0, 3, 5, 6, 9, 10, 12, 15, 17, 18, 20, 23, 24, 27, 29, 30, 33, 34, 36, 39, 40, 43, 45, 46, 48, 51, 53, 54, 57, 58]\n>>> odious[:30]\n[1, 2, 4, 7, 8, 11, 13, 14, 16, 19, 21, 22, 25, 26, 28, 31, 32, 35, 37, 38, 41, 42, 44, 47, 49, 50, 52, 55, 56, 59]\n>>>\n"}
{"id": 132601, "name": "Statistics_Basic", "source": "Translate Fortran to C#: program basic_stats\n  implicit none\n  \n  integer, parameter :: i64 = selected_int_kind(18)\n  integer, parameter :: r64 = selected_real_kind(15)\n  integer(i64), parameter :: samples = 1000000000_i64\n     \n  real(r64) :: r\n  real(r64) :: mean, stddev\n  real(r64) :: sumn = 0, sumnsq = 0\n  integer(i64) :: n = 0 \n  integer(i64) :: bin(10) = 0\n  integer :: i, ind\n  \n  call random_seed\n\n  n = 0\n  do while(n <= samples)\n    call random_number(r)\n    ind = r * 10 + 1\n    bin(ind) = bin(ind) + 1_i64\n    sumn = sumn + r\n    sumnsq = sumnsq + r*r\n    n = n + 1_i64\n  end do\n\n  mean = sumn / n\n  stddev = sqrt(sumnsq/n - mean*mean)\n  write(*, \"(a, i0)\") \"sample size = \", samples\n  write(*, \"(a, f17.15)\") \"Mean\u00a0:   \", mean,\n  write(*, \"(a, f17.15)\") \"Stddev\u00a0: \", stddev  \n  do i = 1, 10\n    write(*, \"(f3.1, a, a)\") real(i)/10.0, \": \", repeat(\"=\", int(bin(i)*500/samples))\n  end do\n \nend program\n", "target": "using System;\nusing MathNet.Numerics.Statistics;\n\nclass Program\n{\n    static void Run(int sampleSize)\n    {\n        double[] X = new double[sampleSize];\n        var r = new Random();\n        for (int i = 0; i < sampleSize; i++)\n            X[i] = r.NextDouble();\n\n        const int numBuckets = 10;\n        var histogram = new Histogram(X, numBuckets);\n        Console.WriteLine(\"Sample size: {0:N0}\", sampleSize);\n        for (int i = 0; i < numBuckets; i++)\n        {\n            string bar = new String('#', (int)(histogram[i].Count * 360 / sampleSize));\n            Console.WriteLine(\" {0:0.00}\u00a0: {1}\", histogram[i].LowerBound, bar);\n        }\n        var statistics = new DescriptiveStatistics(X);\n        Console.WriteLine(\"  Mean: \" + statistics.Mean);\n        Console.WriteLine(\"StdDev: \" + statistics.StandardDeviation);\n        Console.WriteLine();\n    }\n    static void Main(string[] args)\n    {\n        Run(100);\n        Run(1000);\n        Run(10000);\n    }\n}\n"}
{"id": 132605, "name": "Statistics_Basic", "source": "Translate Fortran to Java: program basic_stats\n  implicit none\n  \n  integer, parameter :: i64 = selected_int_kind(18)\n  integer, parameter :: r64 = selected_real_kind(15)\n  integer(i64), parameter :: samples = 1000000000_i64\n     \n  real(r64) :: r\n  real(r64) :: mean, stddev\n  real(r64) :: sumn = 0, sumnsq = 0\n  integer(i64) :: n = 0 \n  integer(i64) :: bin(10) = 0\n  integer :: i, ind\n  \n  call random_seed\n\n  n = 0\n  do while(n <= samples)\n    call random_number(r)\n    ind = r * 10 + 1\n    bin(ind) = bin(ind) + 1_i64\n    sumn = sumn + r\n    sumnsq = sumnsq + r*r\n    n = n + 1_i64\n  end do\n\n  mean = sumn / n\n  stddev = sqrt(sumnsq/n - mean*mean)\n  write(*, \"(a, i0)\") \"sample size = \", samples\n  write(*, \"(a, f17.15)\") \"Mean\u00a0:   \", mean,\n  write(*, \"(a, f17.15)\") \"Stddev\u00a0: \", stddev  \n  do i = 1, 10\n    write(*, \"(f3.1, a, a)\") real(i)/10.0, \": \", repeat(\"=\", int(bin(i)*500/samples))\n  end do\n \nend program\n", "target": "import static java.lang.Math.pow;\nimport static java.util.Arrays.stream;\nimport static java.util.stream.Collectors.joining;\nimport static java.util.stream.IntStream.range;\n\npublic class Test {\n    static double[] meanStdDev(double[] numbers) {\n        if (numbers.length == 0)\n            return new double[]{0.0, 0.0};\n\n        double sx = 0.0, sxx = 0.0;\n        long n = 0;\n        for (double x : numbers) {\n            sx += x;\n            sxx += pow(x, 2);\n            n++;\n        }\n        return new double[]{sx / n, pow((n * sxx - pow(sx, 2)), 0.5) / n};\n    }\n\n    static String replicate(int n, String s) {\n        return range(0, n + 1).mapToObj(i -> s).collect(joining());\n    }\n\n    static void showHistogram01(double[] numbers) {\n        final int maxWidth = 50;\n        long[] bins = new long[10];\n\n        for (double x : numbers)\n            bins[(int) (x * bins.length)]++;\n\n        double maxFreq = stream(bins).max().getAsLong();\n\n        for (int i = 0; i < bins.length; i++)\n            System.out.printf(\" %3.1f: %s%n\", i / (double) bins.length,\n                    replicate((int) (bins[i] / maxFreq * maxWidth), \"*\"));\n        System.out.println();\n    }\n\n    public static void main(String[] a) {\n        Locale.setDefault(Locale.US);\n        for (int p = 1; p < 7; p++) {\n            double[] n = range(0, (int) pow(10, p))\n                    .mapToDouble(i -> Math.random()).toArray();\n\n            System.out.println((int)pow(10, p) + \" numbers:\");\n            double[] res = meanStdDev(n);\n            System.out.printf(\" Mean: %8.6f, SD: %8.6f%n\", res[0], res[1]);\n            showHistogram01(n);\n        }\n    }\n}\n"}
{"id": 132606, "name": "Statistics_Basic", "source": "Translate Fortran to Python: program basic_stats\n  implicit none\n  \n  integer, parameter :: i64 = selected_int_kind(18)\n  integer, parameter :: r64 = selected_real_kind(15)\n  integer(i64), parameter :: samples = 1000000000_i64\n     \n  real(r64) :: r\n  real(r64) :: mean, stddev\n  real(r64) :: sumn = 0, sumnsq = 0\n  integer(i64) :: n = 0 \n  integer(i64) :: bin(10) = 0\n  integer :: i, ind\n  \n  call random_seed\n\n  n = 0\n  do while(n <= samples)\n    call random_number(r)\n    ind = r * 10 + 1\n    bin(ind) = bin(ind) + 1_i64\n    sumn = sumn + r\n    sumnsq = sumnsq + r*r\n    n = n + 1_i64\n  end do\n\n  mean = sumn / n\n  stddev = sqrt(sumnsq/n - mean*mean)\n  write(*, \"(a, i0)\") \"sample size = \", samples\n  write(*, \"(a, f17.15)\") \"Mean\u00a0:   \", mean,\n  write(*, \"(a, f17.15)\") \"Stddev\u00a0: \", stddev  \n  do i = 1, 10\n    write(*, \"(f3.1, a, a)\") real(i)/10.0, \": \", repeat(\"=\", int(bin(i)*500/samples))\n  end do\n \nend program\n", "target": "def sd1(numbers):\n    if numbers:\n        mean = sum(numbers) / len(numbers)\n        sd = (sum((n - mean)**2 for n in numbers) / len(numbers))**0.5\n        return sd, mean\n    else:\n        return 0, 0\n\ndef sd2(numbers):\n    if numbers:\n        sx = sxx = n = 0\n        for x in numbers:\n            sx += x\n            sxx += x*x\n            n += 1\n        sd = (n * sxx - sx*sx)**0.5 / n\n        return sd, sx / n\n    else:\n        return 0, 0\n\ndef histogram(numbers):\n    h = [0] * 10\n    maxwidth = 50 \n    for n in numbers:\n        h[int(n*10)] += 1\n    mx = max(h)\n    print()\n    for n, i in enumerate(h):\n        print('%3.1f: %s' % (n / 10, '+' * int(i / mx * maxwidth)))\n    print()\n\nif __name__ == '__main__':\n    import random\n    for i in range(1, 6):\n        n = [random.random() for j in range(10**i)]\n        print(\"\\n\n        print('  Naive  method: sd: %8.6f, mean: %8.6f' % sd1(n))\n        print('  Second method: sd: %8.6f, mean: %8.6f' % sd2(n))\n        histogram(n)\n"}
{"id": 132788, "name": "Langton's ant", "source": "Translate Fortran to C#: program Langtons_Ant\n  implicit none\n\n  integer, parameter :: csize = 100\n  integer :: direction = 0, maxsteps = 20000\n  integer :: i, x, y  \n  logical :: cells(csize,csize) = .true.\n  logical :: cflag\n  \n  x = csize / 2;   y = x\n  \n  do i = 1, maxsteps\n    cflag = cells(x,y)\n    if(cflag) then\n      direction = direction + 1\n      if(direction == 4) direction = direction - 4\n    else\n      direction = direction - 1\n      if(direction == -1) direction = direction + 4\n    end if\n  \n    cells(x,y) = .not. cells(x,y)\n\n    select case(direction)\n      case(0)\n        y = y - 1\n      case(1)\n        x = x + 1\n      case(2)\n        y = y + 1\n      case(3)\n        x = x - 1\n    end select\n\n    if(x < 1 .or. x > csize .or. y < 1 .or. y > csize) exit\n  end do\n  \n  do y = 1, csize\n    do x = 1, csize\n      if(cells(x,y)) then\n        write(*, \"(a)\", advance=\"no\") \".\"\n      else\n        write(*, \"(a)\", advance=\"no\") \"#\"\n      end if\n    end do\n    write(*,*)\n  end do\nend program\n", "target": "using System;\n\nnamespace LangtonAnt\n{\n    public struct Point\n    {\n        public int X;\n        public int Y;\n\n        public Point(int x, int y)\n        {\n            X = x;\n            Y = y;\n        }\n    }\n\n    enum Direction\n    {\n        North, East, West, South\n    }\n\n    public class Langton\n    {\n        public readonly bool [,] IsBlack;\n        private Point _origin;\n        private Point _antPosition = new Point(0, 0);\n        public bool OutOfBounds { get; set;}\n\n        \n        private Direction _antDirection = Direction.East;\n\n        private readonly Direction[] _leftTurn = new[] { Direction.West, Direction.North, Direction.South, Direction.East };\n        private readonly Direction[] _rightTurn = new[] { Direction.East, Direction.South, Direction.North, Direction.West };\n        private readonly int[] _xInc = new[] { 0, 1,-1, 0};\n        private readonly int[] _yInc = new[] {-1, 0, 0, 1};\n\n        public Langton(int width, int height, Point origin)\n        {\n            _origin = origin;\n            IsBlack = new bool[width, height];\n            OutOfBounds = false;\n        }\n\n        public Langton(int width, int height) : this(width, height, new Point(width / 2, height / 2)) {}\n\n        private void MoveAnt()\n        {\n            _antPosition.X += _xInc[(int)_antDirection];\n            _antPosition.Y += _yInc[(int)_antDirection];\n        }\n\n        public Point Step()\n        {\n            if (OutOfBounds)\n            {\n                throw new InvalidOperationException(\"Trying to step after ant is out of bounds\");\n            }\n            Point ptCur = new Point(_antPosition.X + _origin.X, _antPosition.Y + _origin.Y);\n            bool leftTurn = IsBlack[ptCur.X, ptCur.Y];\n            int iDirection = (int) _antDirection;\n            _antDirection = leftTurn ? _leftTurn[iDirection] : _rightTurn[iDirection];\n            IsBlack[ptCur.X, ptCur.Y] = !IsBlack[ptCur.X, ptCur.Y];\n            MoveAnt();\n            ptCur = new Point(_antPosition.X + _origin.X, _antPosition.Y + _origin.Y);\n            OutOfBounds = \n                ptCur.X < 0 ||\n                ptCur.X >= IsBlack.GetUpperBound(0) ||\n                ptCur.Y < 0 ||\n                ptCur.Y >= IsBlack.GetUpperBound(1);\n            return _antPosition;\n        }\n    }\n    class Program\n    {\n        static void Main()\n        {\n            Langton ant = new Langton(100, 100);\n\n            while (!ant.OutOfBounds) ant.Step();\n\n            for (int iRow = 0; iRow < 100; iRow++)\n            {\n                for (int iCol = 0; iCol < 100; iCol++)\n                {\n                    Console.Write(ant.IsBlack[iCol, iRow] ? \"#\" : \" \");\n                }\n                Console.WriteLine();\n            }\n\n            Console.ReadKey();\n        }\n    }\n}\n"}
{"id": 132791, "name": "Langton's ant", "source": "Translate Fortran to Java: program Langtons_Ant\n  implicit none\n\n  integer, parameter :: csize = 100\n  integer :: direction = 0, maxsteps = 20000\n  integer :: i, x, y  \n  logical :: cells(csize,csize) = .true.\n  logical :: cflag\n  \n  x = csize / 2;   y = x\n  \n  do i = 1, maxsteps\n    cflag = cells(x,y)\n    if(cflag) then\n      direction = direction + 1\n      if(direction == 4) direction = direction - 4\n    else\n      direction = direction - 1\n      if(direction == -1) direction = direction + 4\n    end if\n  \n    cells(x,y) = .not. cells(x,y)\n\n    select case(direction)\n      case(0)\n        y = y - 1\n      case(1)\n        x = x + 1\n      case(2)\n        y = y + 1\n      case(3)\n        x = x - 1\n    end select\n\n    if(x < 1 .or. x > csize .or. y < 1 .or. y > csize) exit\n  end do\n  \n  do y = 1, csize\n    do x = 1, csize\n      if(cells(x,y)) then\n        write(*, \"(a)\", advance=\"no\") \".\"\n      else\n        write(*, \"(a)\", advance=\"no\") \"#\"\n      end if\n    end do\n    write(*,*)\n  end do\nend program\n", "target": "import java.awt.Color;\nimport java.awt.Graphics;\n\nimport javax.swing.JFrame;\nimport javax.swing.JPanel;\n\npublic class Langton extends JFrame{\n\tprivate JPanel planePanel;\n\tprivate static final int ZOOM = 4;\n\t\n\tpublic Langton(final boolean[][] plane){\n\t\tplanePanel = new JPanel(){\n\t\t\t@Override\n\t\t\tpublic void paint(Graphics g) {\n\t\t\t\tfor(int y = 0; y < plane.length;y++){\n\t\t\t\t\tfor(int x = 0; x < plane[0].length;x++){\n\t\t\t\t\t\tg.setColor(plane[y][x] ? Color.BLACK : Color.WHITE);\n\t\t\t\t\t\tg.fillRect(x * ZOOM, y * ZOOM, ZOOM, ZOOM);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tg.setColor(Color.GREEN);\n\t\t\t\tg.fillRect(plane[0].length / 2 * ZOOM,\n\t\t\t\t           plane.length / 2 * ZOOM, ZOOM/2, ZOOM/2);\n\t\t\t}\n\t\t};\n\t\tplanePanel.setSize(plane[0].length - 1, plane.length - 1);\n\t\tadd(planePanel);\n\t\tsetSize(ZOOM * plane[0].length, ZOOM * plane.length + 30);\n\t\tsetDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n\t\tsetVisible(true);\n\t}\n\t\n\tpublic static void main(String[] args){\n\t\tnew Langton(runAnt(100, 100));\n\t}\n\n\tprivate static boolean[][] runAnt(int height, int width){\n\t\tboolean[][] plane = new boolean[height][width];\n\t\tint antX = width/2, antY = height/2;\n\t\tint xChange = 0, yChange = -1; \n\t\twhile(antX < width && antY < height && antX >= 0 && antY >= 0){\n\t\t\tif(plane[antY][antX]){\n\t\t\t\t\n\t\t\t\tif(xChange == 0){ \n\t\t\t\t\txChange = yChange;\n\t\t\t\t\tyChange = 0;\n\t\t\t\t}else{ \n\t\t\t\t\tyChange = -xChange;\n\t\t\t\t\txChange = 0;\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\t\n\t\t\t\tif(xChange == 0){ \n\t\t\t\t\txChange = -yChange;\n\t\t\t\t\tyChange = 0;\n\t\t\t\t}else{ \n\t\t\t\t\tyChange = xChange;\n\t\t\t\t\txChange = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\tplane[antY][antX] = !plane[antY][antX];\n\t\t\tantX += xChange;\n\t\t\tantY += yChange;\n\t\t}\n\t\treturn plane;\n\t}\n}\n"}
{"id": 132792, "name": "Langton's ant", "source": "Translate Fortran to Python: program Langtons_Ant\n  implicit none\n\n  integer, parameter :: csize = 100\n  integer :: direction = 0, maxsteps = 20000\n  integer :: i, x, y  \n  logical :: cells(csize,csize) = .true.\n  logical :: cflag\n  \n  x = csize / 2;   y = x\n  \n  do i = 1, maxsteps\n    cflag = cells(x,y)\n    if(cflag) then\n      direction = direction + 1\n      if(direction == 4) direction = direction - 4\n    else\n      direction = direction - 1\n      if(direction == -1) direction = direction + 4\n    end if\n  \n    cells(x,y) = .not. cells(x,y)\n\n    select case(direction)\n      case(0)\n        y = y - 1\n      case(1)\n        x = x + 1\n      case(2)\n        y = y + 1\n      case(3)\n        x = x - 1\n    end select\n\n    if(x < 1 .or. x > csize .or. y < 1 .or. y > csize) exit\n  end do\n  \n  do y = 1, csize\n    do x = 1, csize\n      if(cells(x,y)) then\n        write(*, \"(a)\", advance=\"no\") \".\"\n      else\n        write(*, \"(a)\", advance=\"no\") \"#\"\n      end if\n    end do\n    write(*,*)\n  end do\nend program\n", "target": "\n\n\n\n\n\nSTEP = 100\ncount = 0\n\ndef setup():\n    global x, y, direction\n\n    \n    \n    size(100, 100, P2D)\n\n    background(255)\n    x = width / 2\n    y = height / 2\n    direction = 0\n\ndef draw():\n    global count\n    for i in range(STEP):\n        count += 1\n        pix = get(x, y) != -1 \n        setBool(x, y, pix)\n\n        turn(pix)\n        move()\n\n        if (x < 0 or y < 0 or x >= width or y >= height):\n            println(\"finished\")\n            noLoop()\n            break\n\n    if count % 1000 == 0:\n        println(\"iteration {}\".format(count))\n\ndef move():\n    global x, y\n    if direction == 0:\n        y -= 1\n    elif direction == 1:\n        x -= 1\n    elif direction == 2:\n        y += 1\n    elif direction == 3:\n        x += 1\n\ndef turn(rightleft):\n    global direction\n    direction += 1 if rightleft else -1\n    if direction == -1:\n        direction = 3\n    if direction == 4:\n        direction = 0\n\ndef setBool(x, y, white):\n    set(x, y, -1 if white else 0)\n"}
{"id": 133301, "name": "Pangram checker", "source": "Translate Fortran to C#: module pangram\n\n  implicit none\n  private\n  public :: is_pangram\n  character (*), parameter :: lower_case = 'abcdefghijklmnopqrstuvwxyz'\n  character (*), parameter :: upper_case = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n\ncontains\n\n  function to_lower_case (input) result (output)\n\n    implicit none\n    character (*), intent (in) :: input\n    character (len (input)) :: output\n    integer :: i\n    integer :: j\n\n    output = input\n    do i = 1, len (output)\n      j = index (upper_case, output (i : i))\n      if (j /= 0) then\n        output (i : i) = lower_case (j : j)\n      end if\n    end do\n\n  end function to_lower_case\n\n  function is_pangram (input) result (output)\n\n    implicit none\n    character (*), intent (in) :: input\n    character (len (input)) :: lower_case_input\n    logical :: output\n    integer :: i\n\n    lower_case_input = to_lower_case (input)\n    output = .true.\n    do i = 1, len (lower_case)\n      if (index (lower_case_input, lower_case (i : i)) == 0) then\n        output = .false.\n        exit\n      end if\n    end do\n\n  end function is_pangram\n\nend module pangram\n", "target": "using System;\nusing System.Linq;\n\nstatic class Program\n{\n    static bool IsPangram(this string text, string alphabet = \"abcdefghijklmnopqrstuvwxyz\")\n    {\n        return alphabet.All(text.ToLower().Contains);\n    }\n\n    static void Main(string[] arguments)\n    {\n        Console.WriteLine(arguments.Any() && arguments.First().IsPangram());\n    }\n}\n"}
{"id": 133302, "name": "Pangram checker", "source": "Translate Fortran to C#: module pangram\n\n  implicit none\n  private\n  public :: is_pangram\n  character (*), parameter :: lower_case = 'abcdefghijklmnopqrstuvwxyz'\n  character (*), parameter :: upper_case = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n\ncontains\n\n  function to_lower_case (input) result (output)\n\n    implicit none\n    character (*), intent (in) :: input\n    character (len (input)) :: output\n    integer :: i\n    integer :: j\n\n    output = input\n    do i = 1, len (output)\n      j = index (upper_case, output (i : i))\n      if (j /= 0) then\n        output (i : i) = lower_case (j : j)\n      end if\n    end do\n\n  end function to_lower_case\n\n  function is_pangram (input) result (output)\n\n    implicit none\n    character (*), intent (in) :: input\n    character (len (input)) :: lower_case_input\n    logical :: output\n    integer :: i\n\n    lower_case_input = to_lower_case (input)\n    output = .true.\n    do i = 1, len (lower_case)\n      if (index (lower_case_input, lower_case (i : i)) == 0) then\n        output = .false.\n        exit\n      end if\n    end do\n\n  end function is_pangram\n\nend module pangram\n", "target": "using System;\nusing System.Linq;\n\nstatic class Program\n{\n    static bool IsPangram(this string text, string alphabet = \"abcdefghijklmnopqrstuvwxyz\")\n    {\n        return alphabet.All(text.ToLower().Contains);\n    }\n\n    static void Main(string[] arguments)\n    {\n        Console.WriteLine(arguments.Any() && arguments.First().IsPangram());\n    }\n}\n"}
{"id": 133307, "name": "Pangram checker", "source": "Translate Fortran to Java: module pangram\n\n  implicit none\n  private\n  public :: is_pangram\n  character (*), parameter :: lower_case = 'abcdefghijklmnopqrstuvwxyz'\n  character (*), parameter :: upper_case = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n\ncontains\n\n  function to_lower_case (input) result (output)\n\n    implicit none\n    character (*), intent (in) :: input\n    character (len (input)) :: output\n    integer :: i\n    integer :: j\n\n    output = input\n    do i = 1, len (output)\n      j = index (upper_case, output (i : i))\n      if (j /= 0) then\n        output (i : i) = lower_case (j : j)\n      end if\n    end do\n\n  end function to_lower_case\n\n  function is_pangram (input) result (output)\n\n    implicit none\n    character (*), intent (in) :: input\n    character (len (input)) :: lower_case_input\n    logical :: output\n    integer :: i\n\n    lower_case_input = to_lower_case (input)\n    output = .true.\n    do i = 1, len (lower_case)\n      if (index (lower_case_input, lower_case (i : i)) == 0) then\n        output = .false.\n        exit\n      end if\n    end do\n\n  end function is_pangram\n\nend module pangram\n", "target": "public class Pangram {\n    public static boolean isPangram(String test){\n        for (char a = 'A'; a <= 'Z'; a++)\n            if ((test.indexOf(a) < 0) && (test.indexOf((char)(a + 32)) < 0))\n                return false;\n        return true;\n    }\n\n    public static void main(String[] args){\n        System.out.println(isPangram(\"the quick brown fox jumps over the lazy dog\"));\n        System.out.println(isPangram(\"the quick brown fox jumped over the lazy dog\"));\n        System.out.println(isPangram(\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"));\n        System.out.println(isPangram(\"ABCDEFGHIJKLMNOPQSTUVWXYZ\"));\n        System.out.println(isPangram(\"ABCDEFGHIJKL.NOPQRSTUVWXYZ\"));\n        System.out.println(isPangram(\"ABC.D.E.FGHI*J/KL-M+NO*PQ R\\nSTUVWXYZ\"));\n        System.out.println(isPangram(\"\"));\n    }\n}\n"}
{"id": 133308, "name": "Pangram checker", "source": "Translate Fortran to Java: module pangram\n\n  implicit none\n  private\n  public :: is_pangram\n  character (*), parameter :: lower_case = 'abcdefghijklmnopqrstuvwxyz'\n  character (*), parameter :: upper_case = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n\ncontains\n\n  function to_lower_case (input) result (output)\n\n    implicit none\n    character (*), intent (in) :: input\n    character (len (input)) :: output\n    integer :: i\n    integer :: j\n\n    output = input\n    do i = 1, len (output)\n      j = index (upper_case, output (i : i))\n      if (j /= 0) then\n        output (i : i) = lower_case (j : j)\n      end if\n    end do\n\n  end function to_lower_case\n\n  function is_pangram (input) result (output)\n\n    implicit none\n    character (*), intent (in) :: input\n    character (len (input)) :: lower_case_input\n    logical :: output\n    integer :: i\n\n    lower_case_input = to_lower_case (input)\n    output = .true.\n    do i = 1, len (lower_case)\n      if (index (lower_case_input, lower_case (i : i)) == 0) then\n        output = .false.\n        exit\n      end if\n    end do\n\n  end function is_pangram\n\nend module pangram\n", "target": "public class Pangram {\n    public static boolean isPangram(String test){\n        for (char a = 'A'; a <= 'Z'; a++)\n            if ((test.indexOf(a) < 0) && (test.indexOf((char)(a + 32)) < 0))\n                return false;\n        return true;\n    }\n\n    public static void main(String[] args){\n        System.out.println(isPangram(\"the quick brown fox jumps over the lazy dog\"));\n        System.out.println(isPangram(\"the quick brown fox jumped over the lazy dog\"));\n        System.out.println(isPangram(\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"));\n        System.out.println(isPangram(\"ABCDEFGHIJKLMNOPQSTUVWXYZ\"));\n        System.out.println(isPangram(\"ABCDEFGHIJKL.NOPQRSTUVWXYZ\"));\n        System.out.println(isPangram(\"ABC.D.E.FGHI*J/KL-M+NO*PQ R\\nSTUVWXYZ\"));\n        System.out.println(isPangram(\"\"));\n    }\n}\n"}
{"id": 133309, "name": "Pangram checker", "source": "Translate Fortran to Python: module pangram\n\n  implicit none\n  private\n  public :: is_pangram\n  character (*), parameter :: lower_case = 'abcdefghijklmnopqrstuvwxyz'\n  character (*), parameter :: upper_case = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n\ncontains\n\n  function to_lower_case (input) result (output)\n\n    implicit none\n    character (*), intent (in) :: input\n    character (len (input)) :: output\n    integer :: i\n    integer :: j\n\n    output = input\n    do i = 1, len (output)\n      j = index (upper_case, output (i : i))\n      if (j /= 0) then\n        output (i : i) = lower_case (j : j)\n      end if\n    end do\n\n  end function to_lower_case\n\n  function is_pangram (input) result (output)\n\n    implicit none\n    character (*), intent (in) :: input\n    character (len (input)) :: lower_case_input\n    logical :: output\n    integer :: i\n\n    lower_case_input = to_lower_case (input)\n    output = .true.\n    do i = 1, len (lower_case)\n      if (index (lower_case_input, lower_case (i : i)) == 0) then\n        output = .false.\n        exit\n      end if\n    end do\n\n  end function is_pangram\n\nend module pangram\n", "target": "import string, sys\nif sys.version_info[0] < 3:\n    input = raw_input\n\ndef ispangram(sentence, alphabet=string.ascii_lowercase):\n    alphaset = set(alphabet)\n    return alphaset <= set(sentence.lower())\n\nprint ( ispangram(input('Sentence: ')) )\n"}
{"id": 133310, "name": "Pangram checker", "source": "Translate Fortran to Python: module pangram\n\n  implicit none\n  private\n  public :: is_pangram\n  character (*), parameter :: lower_case = 'abcdefghijklmnopqrstuvwxyz'\n  character (*), parameter :: upper_case = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n\ncontains\n\n  function to_lower_case (input) result (output)\n\n    implicit none\n    character (*), intent (in) :: input\n    character (len (input)) :: output\n    integer :: i\n    integer :: j\n\n    output = input\n    do i = 1, len (output)\n      j = index (upper_case, output (i : i))\n      if (j /= 0) then\n        output (i : i) = lower_case (j : j)\n      end if\n    end do\n\n  end function to_lower_case\n\n  function is_pangram (input) result (output)\n\n    implicit none\n    character (*), intent (in) :: input\n    character (len (input)) :: lower_case_input\n    logical :: output\n    integer :: i\n\n    lower_case_input = to_lower_case (input)\n    output = .true.\n    do i = 1, len (lower_case)\n      if (index (lower_case_input, lower_case (i : i)) == 0) then\n        output = .false.\n        exit\n      end if\n    end do\n\n  end function is_pangram\n\nend module pangram\n", "target": "import string, sys\nif sys.version_info[0] < 3:\n    input = raw_input\n\ndef ispangram(sentence, alphabet=string.ascii_lowercase):\n    alphaset = set(alphabet)\n    return alphaset <= set(sentence.lower())\n\nprint ( ispangram(input('Sentence: ')) )\n"}
{"id": 134248, "name": "Empty string", "source": "Translate Fortran to C#:       SUBROUTINE TASTE(T)\n       CHARACTER*(*) T       \n        IF (LEN(T).LE.0) WRITE(6,*) \"Empty\n        IF (LEN(T).GT.0) WRITE(6,*) \"Not empty\n      END\n      CHARACTER*24 TEXT\n      CALL TASTE(\"\")\n      CALL TASTE(\"This\")\n      TEXT = \"\"              \n      CALL TASTE(TEXT)       \n      END\n", "target": "using System;\n\nnamespace EmptyString\n{\n  class Program\n  {\n    public static void Main()\n    {\n      String s = scope .();\n      if (s.IsEmpty)\n      {\n        Console.Writeln(\"string empty\");\n      }\n      if (!s.IsEmpty)\n      {\n        Console.Writeln(\"string not empty\");\n      }\n    }\n  }\n}\n"}
{"id": 134249, "name": "Empty string", "source": "Translate Fortran to C#:       SUBROUTINE TASTE(T)\n       CHARACTER*(*) T       \n        IF (LEN(T).LE.0) WRITE(6,*) \"Empty\n        IF (LEN(T).GT.0) WRITE(6,*) \"Not empty\n      END\n      CHARACTER*24 TEXT\n      CALL TASTE(\"\")\n      CALL TASTE(\"This\")\n      TEXT = \"\"              \n      CALL TASTE(TEXT)       \n      END\n", "target": "using System;\n\nnamespace EmptyString\n{\n  class Program\n  {\n    public static void Main()\n    {\n      String s = scope .();\n      if (s.IsEmpty)\n      {\n        Console.Writeln(\"string empty\");\n      }\n      if (!s.IsEmpty)\n      {\n        Console.Writeln(\"string not empty\");\n      }\n    }\n  }\n}\n"}
{"id": 134255, "name": "Empty string", "source": "Translate Fortran to Java:       SUBROUTINE TASTE(T)\n       CHARACTER*(*) T       \n        IF (LEN(T).LE.0) WRITE(6,*) \"Empty\n        IF (LEN(T).GT.0) WRITE(6,*) \"Not empty\n      END\n      CHARACTER*24 TEXT\n      CALL TASTE(\"\")\n      CALL TASTE(\"This\")\n      TEXT = \"\"              \n      CALL TASTE(TEXT)       \n      END\n", "target": "String s = \"\";\nif(s != null && s.isEmpty()){\n   System.out.println(\"s is empty\");\n}else{\n   System.out.println(\"s is not empty\");\n}\n"}
{"id": 134256, "name": "Empty string", "source": "Translate Fortran to Java:       SUBROUTINE TASTE(T)\n       CHARACTER*(*) T       \n        IF (LEN(T).LE.0) WRITE(6,*) \"Empty\n        IF (LEN(T).GT.0) WRITE(6,*) \"Not empty\n      END\n      CHARACTER*24 TEXT\n      CALL TASTE(\"\")\n      CALL TASTE(\"This\")\n      TEXT = \"\"              \n      CALL TASTE(TEXT)       \n      END\n", "target": "String s = \"\";\nif(s != null && s.isEmpty()){\n   System.out.println(\"s is empty\");\n}else{\n   System.out.println(\"s is not empty\");\n}\n"}
{"id": 134257, "name": "Empty string", "source": "Translate Fortran to Python:       SUBROUTINE TASTE(T)\n       CHARACTER*(*) T       \n        IF (LEN(T).LE.0) WRITE(6,*) \"Empty\n        IF (LEN(T).GT.0) WRITE(6,*) \"Not empty\n      END\n      CHARACTER*24 TEXT\n      CALL TASTE(\"\")\n      CALL TASTE(\"This\")\n      TEXT = \"\"              \n      CALL TASTE(TEXT)       \n      END\n", "target": "s = ''\n\ns = str()\n\nif not s or s == '':\n   print(\"String is empty\")\n\nif len(s) == 0:\n    print(\"String is empty\")\nelse:\n    print(\"String not empty\")\n\n\n\n\n\n\ndef emptystring(s):\n   if isinstance(s, (''.__class__ , u''.__class__) ):\n      if len(s) == 0: \n         return True\n      else \n         return False\n\n   elif s is None:\n        return True\n"}
{"id": 134258, "name": "Empty string", "source": "Translate Fortran to Python:       SUBROUTINE TASTE(T)\n       CHARACTER*(*) T       \n        IF (LEN(T).LE.0) WRITE(6,*) \"Empty\n        IF (LEN(T).GT.0) WRITE(6,*) \"Not empty\n      END\n      CHARACTER*24 TEXT\n      CALL TASTE(\"\")\n      CALL TASTE(\"This\")\n      TEXT = \"\"              \n      CALL TASTE(TEXT)       \n      END\n", "target": "s = ''\n\ns = str()\n\nif not s or s == '':\n   print(\"String is empty\")\n\nif len(s) == 0:\n    print(\"String is empty\")\nelse:\n    print(\"String not empty\")\n\n\n\n\n\n\ndef emptystring(s):\n   if isinstance(s, (''.__class__ , u''.__class__) ):\n      if len(s) == 0: \n         return True\n      else \n         return False\n\n   elif s is None:\n        return True\n"}
{"id": 134780, "name": "Equilibrium index", "source": "Translate Fortran to C#: program Equilibrium\n  implicit none\n  \n  integer :: array(7) = (/ -7, 1, 5, 2, -4, 3, 0 /)\n \n  call equil_index(array)\n \ncontains\n\nsubroutine equil_index(a)\n  integer, intent(in) :: a(:)\n  integer :: i\n\n  do i = 1, size(a)\n    if(sum(a(1:i-1)) == sum(a(i+1:size(a)))) write(*,*) i\n  end do\n\nend subroutine\nend program\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\nclass Program\n{\n    static IEnumerable<int> EquilibriumIndices(IEnumerable<int> sequence)\n    {\n        var left = 0;\n        var right = sequence.Sum();\n        var index = 0;\n        foreach (var element in sequence)\n        {\n            right -= element;\n            if (left == right)\n            {\n                yield return index;\n            }\n            left += element;\n            index++;\n        }\n    }\n\n    static void Main()\n    {\n        foreach (var index in EquilibriumIndices(new[] { -7, 1, 5, 2, -4, 3, 0 }))\n        {\n            Console.WriteLine(index);\n        }\n    }\n}\n"}
{"id": 134781, "name": "Equilibrium index", "source": "Translate Fortran to C#: program Equilibrium\n  implicit none\n  \n  integer :: array(7) = (/ -7, 1, 5, 2, -4, 3, 0 /)\n \n  call equil_index(array)\n \ncontains\n\nsubroutine equil_index(a)\n  integer, intent(in) :: a(:)\n  integer :: i\n\n  do i = 1, size(a)\n    if(sum(a(1:i-1)) == sum(a(i+1:size(a)))) write(*,*) i\n  end do\n\nend subroutine\nend program\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\nclass Program\n{\n    static IEnumerable<int> EquilibriumIndices(IEnumerable<int> sequence)\n    {\n        var left = 0;\n        var right = sequence.Sum();\n        var index = 0;\n        foreach (var element in sequence)\n        {\n            right -= element;\n            if (left == right)\n            {\n                yield return index;\n            }\n            left += element;\n            index++;\n        }\n    }\n\n    static void Main()\n    {\n        foreach (var index in EquilibriumIndices(new[] { -7, 1, 5, 2, -4, 3, 0 }))\n        {\n            Console.WriteLine(index);\n        }\n    }\n}\n"}
{"id": 134786, "name": "Equilibrium index", "source": "Translate Fortran to Java: program Equilibrium\n  implicit none\n  \n  integer :: array(7) = (/ -7, 1, 5, 2, -4, 3, 0 /)\n \n  call equil_index(array)\n \ncontains\n\nsubroutine equil_index(a)\n  integer, intent(in) :: a(:)\n  integer :: i\n\n  do i = 1, size(a)\n    if(sum(a(1:i-1)) == sum(a(i+1:size(a)))) write(*,*) i\n  end do\n\nend subroutine\nend program\n", "target": "public class Equlibrium {\n\tpublic static void main(String[] args) {\n\t\tint[] sequence = {-7, 1, 5, 2, -4, 3, 0};\n\t\tequlibrium_indices(sequence);\n\t}\n\n\tpublic static void equlibrium_indices(int[] sequence){\n\t\t\n\t\tint totalSum = 0;\n\t\tfor (int n : sequence) {\n\t\t\ttotalSum += n;\n\t\t}\n\t\t\n\t\tint runningSum = 0;\n\t\tfor (int i = 0; i < sequence.length; i++) {\n\t\t\tint n = sequence[i];\n\t\t\tif (totalSum - runningSum - n == runningSum) {\n\t\t\t\tSystem.out.println(i);\n\t\t\t}\n\t\t\trunningSum += n;\n\t\t}\n\t}\n}\n"}
{"id": 134787, "name": "Equilibrium index", "source": "Translate Fortran to Java: program Equilibrium\n  implicit none\n  \n  integer :: array(7) = (/ -7, 1, 5, 2, -4, 3, 0 /)\n \n  call equil_index(array)\n \ncontains\n\nsubroutine equil_index(a)\n  integer, intent(in) :: a(:)\n  integer :: i\n\n  do i = 1, size(a)\n    if(sum(a(1:i-1)) == sum(a(i+1:size(a)))) write(*,*) i\n  end do\n\nend subroutine\nend program\n", "target": "public class Equlibrium {\n\tpublic static void main(String[] args) {\n\t\tint[] sequence = {-7, 1, 5, 2, -4, 3, 0};\n\t\tequlibrium_indices(sequence);\n\t}\n\n\tpublic static void equlibrium_indices(int[] sequence){\n\t\t\n\t\tint totalSum = 0;\n\t\tfor (int n : sequence) {\n\t\t\ttotalSum += n;\n\t\t}\n\t\t\n\t\tint runningSum = 0;\n\t\tfor (int i = 0; i < sequence.length; i++) {\n\t\t\tint n = sequence[i];\n\t\t\tif (totalSum - runningSum - n == runningSum) {\n\t\t\t\tSystem.out.println(i);\n\t\t\t}\n\t\t\trunningSum += n;\n\t\t}\n\t}\n}\n"}
{"id": 134788, "name": "Equilibrium index", "source": "Translate Fortran to Python: program Equilibrium\n  implicit none\n  \n  integer :: array(7) = (/ -7, 1, 5, 2, -4, 3, 0 /)\n \n  call equil_index(array)\n \ncontains\n\nsubroutine equil_index(a)\n  integer, intent(in) :: a(:)\n  integer :: i\n\n  do i = 1, size(a)\n    if(sum(a(1:i-1)) == sum(a(i+1:size(a)))) write(*,*) i\n  end do\n\nend subroutine\nend program\n", "target": "def eqindex2Pass(data):\n    \"Two pass\"\n    suml, sumr, ddelayed = 0, sum(data), 0\n    for i, d in enumerate(data):\n        suml += ddelayed\n        sumr -= d\n        ddelayed = d\n        if suml == sumr:\n            yield i\n"}
{"id": 134789, "name": "Equilibrium index", "source": "Translate Fortran to Python: program Equilibrium\n  implicit none\n  \n  integer :: array(7) = (/ -7, 1, 5, 2, -4, 3, 0 /)\n \n  call equil_index(array)\n \ncontains\n\nsubroutine equil_index(a)\n  integer, intent(in) :: a(:)\n  integer :: i\n\n  do i = 1, size(a)\n    if(sum(a(1:i-1)) == sum(a(i+1:size(a)))) write(*,*) i\n  end do\n\nend subroutine\nend program\n", "target": "def eqindex2Pass(data):\n    \"Two pass\"\n    suml, sumr, ddelayed = 0, sum(data), 0\n    for i, d in enumerate(data):\n        suml += ddelayed\n        sumr -= d\n        ddelayed = d\n        if suml == sumr:\n            yield i\n"}
{"id": 135203, "name": "Matrix transposition", "source": "Translate Fortran to C#: integer, parameter   :: n = 3, m = 5\nreal, dimension(n,m) :: a = reshape( (/ (i,i=1,n*m) /), (/ n, m /) )\nreal, dimension(m,n) :: b\n\nb = transpose(a)\n\ndo i = 1, n\n    print *, a(i,:)\nend do\n\ndo j = 1, m\n    print *, b(j,:)\nend do\n", "target": "using System;\nusing System.Text;\n\nnamespace prog\n{\n\tclass MainClass\n\t{\t\t\t\t\t\t\n\t\tpublic static void Main (string[] args)\n\t\t{\n\t\t\tdouble[,] m = { {1,2,3},{4,5,6},{7,8,9} };\n\t\t\t\n\t\t\tdouble[,] t = Transpose( m );\t\n\t\t\t\n\t\t\tfor( int i=0; i<t.GetLength(0); i++ )\n\t\t\t{\n\t\t\t\tfor( int j=0; j<t.GetLength(1); j++ )\t\t\n\t\t\t\t\tConsole.Write( t[i,j] + \"  \" );\n\t\t\t\tConsole.WriteLine(\"\");\n\t\t\t}\n\t\t}\n\t\t\n\t\tpublic static double[,] Transpose( double[,] m )\n\t\t{\n\t\t\tdouble[,] t = new double[m.GetLength(1),m.GetLength(0)];\n\t\t\tfor( int i=0; i<m.GetLength(0); i++ )\n\t\t\t\tfor( int j=0; j<m.GetLength(1); j++ )\n\t\t\t\t\tt[j,i] = m[i,j];\t\t\t\n\t\t\t\n\t\t\treturn t;\n\t\t}\n\t}\n}\n"}
{"id": 135206, "name": "Matrix transposition", "source": "Translate Fortran to Java: integer, parameter   :: n = 3, m = 5\nreal, dimension(n,m) :: a = reshape( (/ (i,i=1,n*m) /), (/ n, m /) )\nreal, dimension(m,n) :: b\n\nb = transpose(a)\n\ndo i = 1, n\n    print *, a(i,:)\nend do\n\ndo j = 1, m\n    print *, b(j,:)\nend do\n", "target": "import java.util.Arrays;\npublic class Transpose{\n       public static void main(String[] args){\n               double[][] m = {{1, 1, 1, 1},\n                               {2, 4, 8, 16},\n                               {3, 9, 27, 81},\n                               {4, 16, 64, 256},\n                               {5, 25, 125, 625}};\n               double[][] ans = new double[m[0].length][m.length];\n               for(int rows = 0; rows < m.length; rows++){\n                       for(int cols = 0; cols < m[0].length; cols++){\n                               ans[cols][rows] = m[rows][cols];\n                       }\n               }\n               for(double[] i:ans){\n                       System.out.println(Arrays.toString(i));\n               }\n       }\n}\n"}
{"id": 135207, "name": "Matrix transposition", "source": "Translate Fortran to Python: integer, parameter   :: n = 3, m = 5\nreal, dimension(n,m) :: a = reshape( (/ (i,i=1,n*m) /), (/ n, m /) )\nreal, dimension(m,n) :: b\n\nb = transpose(a)\n\ndo i = 1, n\n    print *, a(i,:)\nend do\n\ndo j = 1, m\n    print *, b(j,:)\nend do\n", "target": "m=((1,  1,  1,   1),\n   (2,  4,  8,  16),\n   (3,  9, 27,  81),\n   (4, 16, 64, 256),\n   (5, 25,125, 625))\nprint(zip(*m))\n\n\n"}
{"id": 135558, "name": "Subtractive generator", "source": "Translate Fortran to C#: module subgenerator\n  implicit none\n\n  integer, parameter :: modulus = 1000000000\n  integer :: s(0:54), r(0:54)\n  \ncontains \n\nsubroutine initgen(seed)\n  integer :: seed\n  integer :: n, rnum\n\n  s(0) = seed\n  s(1) = 1\n\n  do n = 2, 54\n    s(n) = mod(s(n-2) - s(n-1), modulus)\n    if (s(n) < 0) s(n) = s(n) + modulus\n  end do\n   \n  do n = 0, 54\n    r(n) = s(mod(34*(n+1), 55))\n  end do\n\n  do n = 1, 165\n    rnum = subrand()\n  end do \n  \nend subroutine initgen\n\ninteger function subrand()\n  integer, save :: p1 = 0\n  integer, save :: p2 = 31\n\n  r(p1) = mod(r(p1) - r(p2), modulus)\n  if (r(p1) < 0) r(p1) = r(p1) + modulus\n  subrand = r(p1)\n  p1 = mod(p1 + 1, 55)\n  p2 = mod(p2 + 1, 55)\n\nend function subrand  \nend module subgenerator\n  \nprogram subgen_test\n  use subgenerator\n  implicit none\n \n  integer :: seed = 292929\n  integer :: i\n  \n  call initgen(seed)\n  do i = 1, 10\n    write(*,*) subrand()\n  end do \n \nend program\n", "target": "public class SubtractiveGenerator {\n    public static int MAX = 1000000000;\n    private int[] state;\n    private int pos;\n\n    private int mod(int n) {\n        return ((n % MAX) + MAX) % MAX;\n    }\n\n    public SubtractiveGenerator(int seed) {\n        state = new int[55];\n\n        int[] temp = new int[55];\n        temp[0] = mod(seed);\n        temp[1] = 1;\n        for(int i = 2; i < 55; ++i)\n            temp[i] = mod(temp[i - 2] - temp[i - 1]);\n\n        for(int i = 0; i < 55; ++i)\n            state[i] = temp[(34 * (i + 1)) % 55];\n\n        pos = 54;\n        for(int i = 55; i < 220; ++i)\n            next();\n    }\n\n    public int next() {\n        int temp = mod(state[(pos + 1) % 55] - state[(pos + 32) % 55]);\n        pos = (pos + 1) % 55;\n        state[pos] = temp;\n        return temp;\n    }\n\n    static void Main(string[] args) {\n        SubtractiveGenerator gen = new SubtractiveGenerator(292929);\n        for(int i = 220; i < 230; ++i)\n            Console.WriteLine(i.ToString() + \": \" + gen.next().ToString());\n    }\n}\n"}
{"id": 135562, "name": "Subtractive generator", "source": "Translate Fortran to Java: module subgenerator\n  implicit none\n\n  integer, parameter :: modulus = 1000000000\n  integer :: s(0:54), r(0:54)\n  \ncontains \n\nsubroutine initgen(seed)\n  integer :: seed\n  integer :: n, rnum\n\n  s(0) = seed\n  s(1) = 1\n\n  do n = 2, 54\n    s(n) = mod(s(n-2) - s(n-1), modulus)\n    if (s(n) < 0) s(n) = s(n) + modulus\n  end do\n   \n  do n = 0, 54\n    r(n) = s(mod(34*(n+1), 55))\n  end do\n\n  do n = 1, 165\n    rnum = subrand()\n  end do \n  \nend subroutine initgen\n\ninteger function subrand()\n  integer, save :: p1 = 0\n  integer, save :: p2 = 31\n\n  r(p1) = mod(r(p1) - r(p2), modulus)\n  if (r(p1) < 0) r(p1) = r(p1) + modulus\n  subrand = r(p1)\n  p1 = mod(p1 + 1, 55)\n  p2 = mod(p2 + 1, 55)\n\nend function subrand  \nend module subgenerator\n  \nprogram subgen_test\n  use subgenerator\n  implicit none\n \n  integer :: seed = 292929\n  integer :: i\n  \n  call initgen(seed)\n  do i = 1, 10\n    write(*,*) subrand()\n  end do \n \nend program\n", "target": "import java.util.function.IntSupplier;\nimport static java.util.stream.IntStream.generate;\n\npublic class SubtractiveGenerator implements IntSupplier {\n    static final int MOD = 1_000_000_000;\n    private int[] state = new int[55];\n    private int si, sj;\n\n    public SubtractiveGenerator(int p1) {\n        subrandSeed(p1);\n    }\n\n    void subrandSeed(int p1) {\n        int p2 = 1;\n\n        state[0] = p1 % MOD;\n        for (int i = 1, j = 21; i < 55; i++, j += 21) {\n            if (j >= 55)\n                j -= 55;\n            state[j] = p2;\n            if ((p2 = p1 - p2) < 0)\n                p2 += MOD;\n            p1 = state[j];\n        }\n\n        si = 0;\n        sj = 24;\n        for (int i = 0; i < 165; i++)\n            getAsInt();\n    }\n\n    @Override\n    public int getAsInt() {\n        if (si == sj)\n            subrandSeed(0);\n\n        if (si-- == 0)\n            si = 54;\n        if (sj-- == 0)\n            sj = 54;\n\n        int x = state[si] - state[sj];\n        if (x < 0)\n            x += MOD;\n\n        return state[si] = x;\n    }\n\n    public static void main(String[] args) {\n        generate(new SubtractiveGenerator(292_929)).limit(10)\n                .forEach(System.out::println);\n    }\n}\n"}
{"id": 135563, "name": "Subtractive generator", "source": "Translate Fortran to Python: module subgenerator\n  implicit none\n\n  integer, parameter :: modulus = 1000000000\n  integer :: s(0:54), r(0:54)\n  \ncontains \n\nsubroutine initgen(seed)\n  integer :: seed\n  integer :: n, rnum\n\n  s(0) = seed\n  s(1) = 1\n\n  do n = 2, 54\n    s(n) = mod(s(n-2) - s(n-1), modulus)\n    if (s(n) < 0) s(n) = s(n) + modulus\n  end do\n   \n  do n = 0, 54\n    r(n) = s(mod(34*(n+1), 55))\n  end do\n\n  do n = 1, 165\n    rnum = subrand()\n  end do \n  \nend subroutine initgen\n\ninteger function subrand()\n  integer, save :: p1 = 0\n  integer, save :: p2 = 31\n\n  r(p1) = mod(r(p1) - r(p2), modulus)\n  if (r(p1) < 0) r(p1) = r(p1) + modulus\n  subrand = r(p1)\n  p1 = mod(p1 + 1, 55)\n  p2 = mod(p2 + 1, 55)\n\nend function subrand  \nend module subgenerator\n  \nprogram subgen_test\n  use subgenerator\n  implicit none\n \n  integer :: seed = 292929\n  integer :: i\n  \n  call initgen(seed)\n  do i = 1, 10\n    write(*,*) subrand()\n  end do \n \nend program\n", "target": "import collections\ns= collections.deque(maxlen=55)\n\nseed = 292929\n\n\n\n\ns.append(seed)\ns.append(1)\n\n\n\nfor n in xrange(2, 55):\n    s.append((s[n-2] - s[n-1]) % 10**9)\n\n\n\n\nr = collections.deque(maxlen=55)\nfor n in xrange(55):\n    i = (34 * (n+1)) % 55\n    r.append(s[i])\n\n\n\n\n\n\ndef getnextr():\n    \n    r.append((r[0]-r[31])%10**9)\n    return r[54]\n\n\nfor n in xrange(219 - 54):\n    getnextr()\n\n\n\nfor i in xrange(5):\n    print \"result = \", getnextr()\n"}
{"id": 135917, "name": "Pernicious numbers", "source": "Translate Fortran to C#: program pernicious\n  implicit none\n\n  integer :: i, n\n\n  i = 1\n  n = 0\n  do\n    if(isprime(popcnt(i))) then\n      write(*, \"(i0, 1x)\", advance = \"no\") i\n      n = n + 1\n      if(n == 25) exit\n    end if\n    i = i + 1\n  end do\n  \n  write(*,*)\n  do i = 888888877, 888888888\n    if(isprime(popcnt(i))) write(*, \"(i0, 1x)\", advance = \"no\") i\n  end do \n\ncontains\n\nfunction popcnt(x)\n  integer :: popcnt\n  integer, intent(in) :: x\n  integer :: i\n \n  popcnt = 0\n  do i = 0, 31\n    if(btest(x, i)) popcnt = popcnt + 1\n  end do\n \nend function\n\nfunction isprime(number)\n  logical :: isprime\n  integer, intent(in) :: number\n  integer :: i\n \n  if(number == 2) then\n    isprime = .true.\n  else if(number < 2 .or. mod(number,2) == 0) then\n    isprime = .false.\n  else\n    isprime = .true.\n    do i = 3, int(sqrt(real(number))), 2\n      if(mod(number,i) == 0) then\n        isprime = .false.\n        exit\n      end if\n    end do\n  end if\nend function\nend program\n", "target": "using System;\nusing System.Linq;\n\nnamespace PerniciousNumbers\n{\n    class Program\n    {\n        public static int PopulationCount(long n)\n        {\n            int cnt = 0;\n            do\n            {\n                if ((n & 1) != 0) \n                {\n                    cnt++;\n                }\n            } while ((n >>= 1) > 0);\n\n            return cnt;\n        }\n\n         public static bool isPrime(int x)\n        {\n            if (x <= 2 || (x & 1) == 0)\n            {\n                return x == 2;\n            }\n\n            var limit = Math.Sqrt(x);\n            for (int i = 3; i <= limit; i += 2)\n            {\n                if (x % i == 0)\n                {\n                    return false;\n                }\n            }\n\n            return true;\n        }\n\n        private static IEnumerable<int> Pernicious(int start, int count, int take)\n        {\n            return Enumerable.Range(start, count).Where(n => isPrime(PopulationCount(n))).Take(take);\n        }\n\n        static void Main(string[] args)\n        {\n            foreach (var n in Pernicious(0, int.MaxValue, 25))\n            {\n                Console.Write(\"{0} \", n);\n            }\n\n            Console.WriteLine();\n\n            foreach (var n in Pernicious(888888877, 11, 11))\n            {\n                Console.Write(\"{0} \", n);\n            }\n\n            Console.ReadKey();\n        }\n    }\n}\n"}
{"id": 135921, "name": "Pernicious numbers", "source": "Translate Fortran to Java: program pernicious\n  implicit none\n\n  integer :: i, n\n\n  i = 1\n  n = 0\n  do\n    if(isprime(popcnt(i))) then\n      write(*, \"(i0, 1x)\", advance = \"no\") i\n      n = n + 1\n      if(n == 25) exit\n    end if\n    i = i + 1\n  end do\n  \n  write(*,*)\n  do i = 888888877, 888888888\n    if(isprime(popcnt(i))) write(*, \"(i0, 1x)\", advance = \"no\") i\n  end do \n\ncontains\n\nfunction popcnt(x)\n  integer :: popcnt\n  integer, intent(in) :: x\n  integer :: i\n \n  popcnt = 0\n  do i = 0, 31\n    if(btest(x, i)) popcnt = popcnt + 1\n  end do\n \nend function\n\nfunction isprime(number)\n  logical :: isprime\n  integer, intent(in) :: number\n  integer :: i\n \n  if(number == 2) then\n    isprime = .true.\n  else if(number < 2 .or. mod(number,2) == 0) then\n    isprime = .false.\n  else\n    isprime = .true.\n    do i = 3, int(sqrt(real(number))), 2\n      if(mod(number,i) == 0) then\n        isprime = .false.\n        exit\n      end if\n    end do\n  end if\nend function\nend program\n", "target": "public class Pernicious{\n    \n    public static boolean isPrime(int x){\n        if(x < 2) return false;\n        for(int i = 2; i < x; i++){\n            if(x % i == 0) return false;\n        }\n        return true;\n    }\n\n    public static int popCount(long x){\n        return Long.bitCount(x);\n    }\n\n    public static void main(String[] args){\n        for(long i = 1, n = 0; n < 25; i++){\n            if(isPrime(popCount(i))){\n                System.out.print(i + \" \");\n                n++;\n            }\n        }\n        \n        System.out.println();\n        \n        for(long i = 888888877; i <= 888888888; i++){\n            if(isPrime(popCount(i))) System.out.print(i + \" \");\n        }\n    }\n}\n"}
{"id": 135922, "name": "Pernicious numbers", "source": "Translate Fortran to Python: program pernicious\n  implicit none\n\n  integer :: i, n\n\n  i = 1\n  n = 0\n  do\n    if(isprime(popcnt(i))) then\n      write(*, \"(i0, 1x)\", advance = \"no\") i\n      n = n + 1\n      if(n == 25) exit\n    end if\n    i = i + 1\n  end do\n  \n  write(*,*)\n  do i = 888888877, 888888888\n    if(isprime(popcnt(i))) write(*, \"(i0, 1x)\", advance = \"no\") i\n  end do \n\ncontains\n\nfunction popcnt(x)\n  integer :: popcnt\n  integer, intent(in) :: x\n  integer :: i\n \n  popcnt = 0\n  do i = 0, 31\n    if(btest(x, i)) popcnt = popcnt + 1\n  end do\n \nend function\n\nfunction isprime(number)\n  logical :: isprime\n  integer, intent(in) :: number\n  integer :: i\n \n  if(number == 2) then\n    isprime = .true.\n  else if(number < 2 .or. mod(number,2) == 0) then\n    isprime = .false.\n  else\n    isprime = .true.\n    do i = 3, int(sqrt(real(number))), 2\n      if(mod(number,i) == 0) then\n        isprime = .false.\n        exit\n      end if\n    end do\n  end if\nend function\nend program\n", "target": ">>> def popcount(n): return bin(n).count(\"1\")\n\n>>> primes = {2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61}\n>>> p, i = [], 0\n>>> while len(p) < 25:\n        if popcount(i) in primes: p.append(i)\n        i += 1\n\n        \n>>> p\n[3, 5, 6, 7, 9, 10, 11, 12, 13, 14, 17, 18, 19, 20, 21, 22, 24, 25, 26, 28, 31, 33, 34, 35, 36]\n>>> p, i = [], 888888877\n>>> while i <= 888888888:\n        if popcount(i) in primes: p.append(i)\n        i += 1\n\n        \n>>> p\n[888888877, 888888878, 888888880, 888888883, 888888885, 888888886]\n>>>\n"}
{"id": 136139, "name": "IBAN", "source": "Translate Fortran to C#: program ibancheck\n\n   use ISO_FORTRAN_ENV\n\n   implicit none\n\n   character(4), dimension(75) :: cc = (/ &\n            \"AD24\",\"AE23\",\"AL28\",\"AT20\",\"AZ28\",\"BA20\",\"BE16\",\"BG22\",\"BH22\",\"BR29\", &\n            \"BY28\",\"CH21\",\"CR22\",\"CY28\",\"CZ24\",\"DE22\",\"DK18\",\"DO28\",\"EE20\",\"ES24\", &\n            \"FI18\",\"FO18\",\"FR27\",\"GB22\",\"GE22\",\"GI23\",\"GL18\",\"GR27\",\"GT28\",\"HR21\", &\n            \"HU28\",\"IE22\",\"IL23\",\"IQ23\",\"IS26\",\"IT27\",\"JO30\",\"KW30\",\"KZ20\",\"LB28\", &\n            \"LC32\",\"LI21\",\"LT20\",\"LU20\",\"LV21\",\"MC27\",\"MD24\",\"ME22\",\"MK19\",\"MR27\", &\n            \"MT31\",\"MU30\",\"NL18\",\"NO15\",\"PK24\",\"PL28\",\"PS29\",\"PT25\",\"QA29\",\"RO24\", &\n            \"RS22\",\"SA24\",\"SC31\",\"SE24\",\"SI19\",\"SK24\",\"SM27\",\"ST25\",\"SV28\",\"TL23\", &\n            \"TN24\",\"TR26\",\"UA29\",\"VG24\",\"XK20\" /)\n\n    character(34), dimension(12) :: ibans = (/ \"GB82 WEST 1234 5698 7654 32       \", &\n                                               \"GB82WEST12345698765432            \", & \n                                               \"gb82 west 1234 5698 7654 32       \", &\n                                               \"GB82 TEST 1234 5698 7654 32       \", &\n                                               \"GR16 0110 1250 0000 0001 2300 695 \", &\n                                               \"GB29 NWBK 6016 1331 9268 19       \", &\n                                               \"SA03 8000 0000 6080 1016 7519     \", &\n                                               \"CH93 0076 2011 6238 5295 7        \", &\n                                               \"IL62 0108 0000 0009 9999 999      \", &\n                                               \"IL62-0108-0000-0009-9999-999      \", &\n                                               \"US12 3456 7890 0987 6543 210      \", &\n                                               \"GR16 0110 1250 0000 0001 2300 695X\" /)\n\n    integer :: i\n    \n    do i=1, size(ibans)\n        if (checkIBAN(trim(ibans(i)))) then\n            print *, \"  valid IBAN: \", trim(ibans(i))\n        else\n            print *, \"invalid IBAN: \", trim(ibans(i))\n        end if\n    end do\n\n    return\n \ncontains\n\n    function checkIBAN(ibancode) result(valid)\n        character(len=*), intent(in) :: ibancode\n        character(len=len(ibancode)) :: iban\n        logical :: valid\n        integer(int32) :: j, ascii, ibanSize \n        character(100) :: ibanRearrange, ibantoint\n        character(2) :: temp\n        valid = .false.\n\n        iban = remove_blanks(ibancode)\n        ibanSize = checkCountryCode(iban)\n        if (ibanSize == len(trim(iban))) then\n            ibanRearrange = iban(5:ibanSize)//iban(1:4)\n            ibantoint = \"\"\n            do j=1, ibanSize\n                ascii = ichar(ibanRearrange(j:j))\n                if ((ascii >= 65) .and. (ascii<=90)) then\n                    write (temp,fmt='(I2)') ascii-55\n                    ibantoint = trim(ibantoint) // temp\n                else\n                    ibantoint = trim(ibantoint) // ibanRearrange(j:j)\n                end if \n            end do\n            if (mod97(ibantoint) == 1) then\n                valid = .true.\n            end if\n        end if\n    end function checkIBAN\n    \n    function mod97(strint) result(res)\n        character(len=*), intent(in) :: strint\n        integer :: i, num, res\n        res = 0\n        do  i=1, len(trim(strint))\n            read(strint(i:i),*) num\n            res = mod((res*10 + num),97);\n        end do\n    end function mod97\n\n    function checkCountryCode(iban) result(ibanlength)\n        character(len=*), intent(in) :: iban\n        integer(int16) :: ibanlength, i\n        ibanlength = 0\n        do i=1, size(cc)\n            if (iban(1:2) == cc(i)(1:2)) then\n                read(cc(i)(3:4),*) ibanlength\n                exit\n            end if\n        end do\n    end function checkCountryCode\n \n    Recursive Function Stripper(string,ch) Result(stripped)\n        Implicit None\n        character(len=*), intent(in) :: string\n        character, intent(in) :: ch\n        character(:), allocatable :: stripped\n\n        IF (LEN(string)==1) THEN\n           IF (string==ch) THEN \n              stripped = ''\n           ELSE\n              stripped = string\n           END IF\n        ELSE\n           IF (string(1:1)==ch) THEN\n              stripped = stripper(string(2:),ch)\n           ELSE\n              stripped = string(1:1)//stripper(string(2:),ch)\n           END IF\n        END IF\n    END Function stripper\n\n    Function Remove_Blanks(string) Result(stripped)\n        Implicit None\n        character(len=*), intent(in) ::   string\n        character(:), allocatable :: stripped\n\n        stripped = trim(Stripper(trim(Stripper(string,' ')),achar(9)))\n    END Function Remove_Blanks\n\nend program ibancheck\n", "target": "    public class IbanValidator : IValidateTypes\n    {\n        public ValidationResult Validate(string value)\n        {\n            \n            if (string.IsNullOrEmpty(value))\n                return ValidationResult.ValueMissing;\n\n            if (value.Length < 2)\n                return ValidationResult.ValueTooSmall;\n\n            var countryCode = value.Substring(0, 2).ToUpper();\n\n            int lengthForCountryCode;\n\n            var countryCodeKnown = Lengths.TryGetValue(countryCode, out lengthForCountryCode);\n            if (!countryCodeKnown)\n            {\n                return ValidationResult.CountryCodeNotKnown;\n            }\n\n            \n            if (value.Length < lengthForCountryCode)\n                return ValidationResult.ValueTooSmall;\n\n            if (value.Length > lengthForCountryCode)\n                return ValidationResult.ValueTooBig;\n\n            value = value.ToUpper();\n            var newIban = value.Substring(4) + value.Substring(0, 4);\n\n            newIban = Regex.Replace(newIban, @\"\\D\", match => (match.Value[0] - 55).ToString());\n\n            var remainder = BigInteger.Parse(newIban) % 97;\n\n            if (remainder != 1)\n                return ValidationResult.ValueFailsModule97Check;\n\n            return ValidationResult.IsValid;\n        }\n\n        public enum ValidationResult\n        {\n            IsValid,\n            ValueMissing,\n            ValueTooSmall,\n            ValueTooBig,\n            ValueFailsModule97Check,\n            CountryCodeNotKnown\n        }\n\n        private static readonly IDictionary<string, int> Lengths = new Dictionary<string, int>\n        {\n            {\"AL\", 28},\n            {\"AD\", 24},\n            {\"AT\", 20},\n            {\"AZ\", 28},\n            {\"BE\", 16},\n            {\"BH\", 22},\n            {\"BA\", 20},\n            {\"BR\", 29},\n            {\"BG\", 22},\n            {\"CR\", 21},\n            {\"HR\", 21},\n            {\"CY\", 28},\n            {\"CZ\", 24},\n            {\"DK\", 18},\n            {\"DO\", 28},\n            {\"EE\", 20},\n            {\"FO\", 18},\n            {\"FI\", 18},\n            {\"FR\", 27},\n            {\"GE\", 22},\n            {\"DE\", 22},\n            {\"GI\", 23},\n            {\"GR\", 27},\n            {\"GL\", 18},\n            {\"GT\", 28},\n            {\"HU\", 28},\n            {\"IS\", 26},\n            {\"IE\", 22},\n            {\"IL\", 23},\n            {\"IT\", 27},\n            {\"KZ\", 20},\n            {\"KW\", 30},\n            {\"LV\", 21},\n            {\"LB\", 28},\n            {\"LI\", 21},\n            {\"LT\", 20},\n            {\"LU\", 20},\n            {\"MK\", 19},\n            {\"MT\", 31},\n            {\"MR\", 27},\n            {\"MU\", 30},\n            {\"MC\", 27},\n            {\"MD\", 24},\n            {\"ME\", 22},\n            {\"NL\", 18},\n            {\"NO\", 15},\n            {\"PK\", 24},\n            {\"PS\", 29},\n            {\"PL\", 28},\n            {\"PT\", 25},\n            {\"RO\", 24},\n            {\"SM\", 27},\n            {\"SA\", 24},\n            {\"RS\", 22},\n            {\"SK\", 24},\n            {\"SI\", 19},\n            {\"ES\", 24},\n            {\"SE\", 24},\n            {\"CH\", 21},\n            {\"TN\", 24},\n            {\"TR\", 26},\n            {\"AE\", 23},\n            {\"GB\", 22},\n            {\"VG\", 24}\n        };\n    }\n"}
{"id": 136142, "name": "IBAN", "source": "Translate Fortran to Java: program ibancheck\n\n   use ISO_FORTRAN_ENV\n\n   implicit none\n\n   character(4), dimension(75) :: cc = (/ &\n            \"AD24\",\"AE23\",\"AL28\",\"AT20\",\"AZ28\",\"BA20\",\"BE16\",\"BG22\",\"BH22\",\"BR29\", &\n            \"BY28\",\"CH21\",\"CR22\",\"CY28\",\"CZ24\",\"DE22\",\"DK18\",\"DO28\",\"EE20\",\"ES24\", &\n            \"FI18\",\"FO18\",\"FR27\",\"GB22\",\"GE22\",\"GI23\",\"GL18\",\"GR27\",\"GT28\",\"HR21\", &\n            \"HU28\",\"IE22\",\"IL23\",\"IQ23\",\"IS26\",\"IT27\",\"JO30\",\"KW30\",\"KZ20\",\"LB28\", &\n            \"LC32\",\"LI21\",\"LT20\",\"LU20\",\"LV21\",\"MC27\",\"MD24\",\"ME22\",\"MK19\",\"MR27\", &\n            \"MT31\",\"MU30\",\"NL18\",\"NO15\",\"PK24\",\"PL28\",\"PS29\",\"PT25\",\"QA29\",\"RO24\", &\n            \"RS22\",\"SA24\",\"SC31\",\"SE24\",\"SI19\",\"SK24\",\"SM27\",\"ST25\",\"SV28\",\"TL23\", &\n            \"TN24\",\"TR26\",\"UA29\",\"VG24\",\"XK20\" /)\n\n    character(34), dimension(12) :: ibans = (/ \"GB82 WEST 1234 5698 7654 32       \", &\n                                               \"GB82WEST12345698765432            \", & \n                                               \"gb82 west 1234 5698 7654 32       \", &\n                                               \"GB82 TEST 1234 5698 7654 32       \", &\n                                               \"GR16 0110 1250 0000 0001 2300 695 \", &\n                                               \"GB29 NWBK 6016 1331 9268 19       \", &\n                                               \"SA03 8000 0000 6080 1016 7519     \", &\n                                               \"CH93 0076 2011 6238 5295 7        \", &\n                                               \"IL62 0108 0000 0009 9999 999      \", &\n                                               \"IL62-0108-0000-0009-9999-999      \", &\n                                               \"US12 3456 7890 0987 6543 210      \", &\n                                               \"GR16 0110 1250 0000 0001 2300 695X\" /)\n\n    integer :: i\n    \n    do i=1, size(ibans)\n        if (checkIBAN(trim(ibans(i)))) then\n            print *, \"  valid IBAN: \", trim(ibans(i))\n        else\n            print *, \"invalid IBAN: \", trim(ibans(i))\n        end if\n    end do\n\n    return\n \ncontains\n\n    function checkIBAN(ibancode) result(valid)\n        character(len=*), intent(in) :: ibancode\n        character(len=len(ibancode)) :: iban\n        logical :: valid\n        integer(int32) :: j, ascii, ibanSize \n        character(100) :: ibanRearrange, ibantoint\n        character(2) :: temp\n        valid = .false.\n\n        iban = remove_blanks(ibancode)\n        ibanSize = checkCountryCode(iban)\n        if (ibanSize == len(trim(iban))) then\n            ibanRearrange = iban(5:ibanSize)//iban(1:4)\n            ibantoint = \"\"\n            do j=1, ibanSize\n                ascii = ichar(ibanRearrange(j:j))\n                if ((ascii >= 65) .and. (ascii<=90)) then\n                    write (temp,fmt='(I2)') ascii-55\n                    ibantoint = trim(ibantoint) // temp\n                else\n                    ibantoint = trim(ibantoint) // ibanRearrange(j:j)\n                end if \n            end do\n            if (mod97(ibantoint) == 1) then\n                valid = .true.\n            end if\n        end if\n    end function checkIBAN\n    \n    function mod97(strint) result(res)\n        character(len=*), intent(in) :: strint\n        integer :: i, num, res\n        res = 0\n        do  i=1, len(trim(strint))\n            read(strint(i:i),*) num\n            res = mod((res*10 + num),97);\n        end do\n    end function mod97\n\n    function checkCountryCode(iban) result(ibanlength)\n        character(len=*), intent(in) :: iban\n        integer(int16) :: ibanlength, i\n        ibanlength = 0\n        do i=1, size(cc)\n            if (iban(1:2) == cc(i)(1:2)) then\n                read(cc(i)(3:4),*) ibanlength\n                exit\n            end if\n        end do\n    end function checkCountryCode\n \n    Recursive Function Stripper(string,ch) Result(stripped)\n        Implicit None\n        character(len=*), intent(in) :: string\n        character, intent(in) :: ch\n        character(:), allocatable :: stripped\n\n        IF (LEN(string)==1) THEN\n           IF (string==ch) THEN \n              stripped = ''\n           ELSE\n              stripped = string\n           END IF\n        ELSE\n           IF (string(1:1)==ch) THEN\n              stripped = stripper(string(2:),ch)\n           ELSE\n              stripped = string(1:1)//stripper(string(2:),ch)\n           END IF\n        END IF\n    END Function stripper\n\n    Function Remove_Blanks(string) Result(stripped)\n        Implicit None\n        character(len=*), intent(in) ::   string\n        character(:), allocatable :: stripped\n\n        stripped = trim(Stripper(trim(Stripper(string,' ')),achar(9)))\n    END Function Remove_Blanks\n\nend program ibancheck\n", "target": "import java.math.BigInteger;\nimport java.util.*;\n\npublic class IBAN {\n    private static final String DEFSTRS = \"\"\n            + \"AL28 AD24 AT20 AZ28 BE16 BH22 BA20 BR29 BG22 \"\n            + \"HR21 CY28 CZ24 DK18 DO28 EE20 FO18 FI18 FR27 GE22 DE22 GI23 \"\n            + \"GL18 GT28 HU28 IS26 IE22 IL23 IT27 KZ20 KW30 LV21 LB28 LI21 \"\n            + \"LT20 LU20 MK19 MT31 MR27 MU30 MC27 MD24 ME22 NL18 NO15 PK24 \"\n            + \"PS29 PL28 PT25 RO24 SM27 SA24 RS22 SK24 SI19 ES24 SE24 CH21 \"\n            + \"TN24 TR26 AE23 GB22 VG24 GR27 CR21\";\n    private static final Map<String, Integer> DEFINITIONS = new HashMap<>();\n\n    static {\n        for (String definition : DEFSTRS.split(\" \"))\n            DEFINITIONS.put(definition.substring(0, 2), Integer.parseInt(definition.substring(2)));\n    }\n\n    public static void main(String[] args) {\n        String[] ibans = {\n                \"GB82 WEST 1234 5698 7654 32\",\n                \"GB82 TEST 1234 5698 7654 32\",\n                \"GB81 WEST 1234 5698 7654 32\",\n                \"SA03 8000 0000 6080 1016 7519\",\n                \"CH93 0076 2011 6238 5295 7\",\n                \"XX00 0000\",\n                \"\",\n                \"DE\",\n                \"DE13 \u00e4\u00f6\u00fc_ 1234 1234 1234 12\"};\n        for (String iban : ibans)\n            System.out.printf(\"%s is %s.%n\", iban, validateIBAN(iban) ? \"valid\" : \"not valid\");\n    }\n\n    static boolean validateIBAN(String iban) {\n        iban = iban.replaceAll(\"\\\\s\", \"\").toUpperCase(Locale.ROOT);\n\n        int len = iban.length();\n        if (len < 4 || !iban.matches(\"[0-9A-Z]+\") || DEFINITIONS.getOrDefault(iban.substring(0, 2), 0) != len)\n            return false;\n\n        iban = iban.substring(4) + iban.substring(0, 4);\n\n        StringBuilder sb = new StringBuilder();\n        for (int i = 0; i < len; i++)\n            sb.append(Character.digit(iban.charAt(i), 36));\n\n        BigInteger bigInt = new BigInteger(sb.toString());\n\n        return bigInt.mod(BigInteger.valueOf(97)).intValue() == 1;\n    }\n}\n"}
{"id": 136143, "name": "IBAN", "source": "Translate Fortran to Python: program ibancheck\n\n   use ISO_FORTRAN_ENV\n\n   implicit none\n\n   character(4), dimension(75) :: cc = (/ &\n            \"AD24\",\"AE23\",\"AL28\",\"AT20\",\"AZ28\",\"BA20\",\"BE16\",\"BG22\",\"BH22\",\"BR29\", &\n            \"BY28\",\"CH21\",\"CR22\",\"CY28\",\"CZ24\",\"DE22\",\"DK18\",\"DO28\",\"EE20\",\"ES24\", &\n            \"FI18\",\"FO18\",\"FR27\",\"GB22\",\"GE22\",\"GI23\",\"GL18\",\"GR27\",\"GT28\",\"HR21\", &\n            \"HU28\",\"IE22\",\"IL23\",\"IQ23\",\"IS26\",\"IT27\",\"JO30\",\"KW30\",\"KZ20\",\"LB28\", &\n            \"LC32\",\"LI21\",\"LT20\",\"LU20\",\"LV21\",\"MC27\",\"MD24\",\"ME22\",\"MK19\",\"MR27\", &\n            \"MT31\",\"MU30\",\"NL18\",\"NO15\",\"PK24\",\"PL28\",\"PS29\",\"PT25\",\"QA29\",\"RO24\", &\n            \"RS22\",\"SA24\",\"SC31\",\"SE24\",\"SI19\",\"SK24\",\"SM27\",\"ST25\",\"SV28\",\"TL23\", &\n            \"TN24\",\"TR26\",\"UA29\",\"VG24\",\"XK20\" /)\n\n    character(34), dimension(12) :: ibans = (/ \"GB82 WEST 1234 5698 7654 32       \", &\n                                               \"GB82WEST12345698765432            \", & \n                                               \"gb82 west 1234 5698 7654 32       \", &\n                                               \"GB82 TEST 1234 5698 7654 32       \", &\n                                               \"GR16 0110 1250 0000 0001 2300 695 \", &\n                                               \"GB29 NWBK 6016 1331 9268 19       \", &\n                                               \"SA03 8000 0000 6080 1016 7519     \", &\n                                               \"CH93 0076 2011 6238 5295 7        \", &\n                                               \"IL62 0108 0000 0009 9999 999      \", &\n                                               \"IL62-0108-0000-0009-9999-999      \", &\n                                               \"US12 3456 7890 0987 6543 210      \", &\n                                               \"GR16 0110 1250 0000 0001 2300 695X\" /)\n\n    integer :: i\n    \n    do i=1, size(ibans)\n        if (checkIBAN(trim(ibans(i)))) then\n            print *, \"  valid IBAN: \", trim(ibans(i))\n        else\n            print *, \"invalid IBAN: \", trim(ibans(i))\n        end if\n    end do\n\n    return\n \ncontains\n\n    function checkIBAN(ibancode) result(valid)\n        character(len=*), intent(in) :: ibancode\n        character(len=len(ibancode)) :: iban\n        logical :: valid\n        integer(int32) :: j, ascii, ibanSize \n        character(100) :: ibanRearrange, ibantoint\n        character(2) :: temp\n        valid = .false.\n\n        iban = remove_blanks(ibancode)\n        ibanSize = checkCountryCode(iban)\n        if (ibanSize == len(trim(iban))) then\n            ibanRearrange = iban(5:ibanSize)//iban(1:4)\n            ibantoint = \"\"\n            do j=1, ibanSize\n                ascii = ichar(ibanRearrange(j:j))\n                if ((ascii >= 65) .and. (ascii<=90)) then\n                    write (temp,fmt='(I2)') ascii-55\n                    ibantoint = trim(ibantoint) // temp\n                else\n                    ibantoint = trim(ibantoint) // ibanRearrange(j:j)\n                end if \n            end do\n            if (mod97(ibantoint) == 1) then\n                valid = .true.\n            end if\n        end if\n    end function checkIBAN\n    \n    function mod97(strint) result(res)\n        character(len=*), intent(in) :: strint\n        integer :: i, num, res\n        res = 0\n        do  i=1, len(trim(strint))\n            read(strint(i:i),*) num\n            res = mod((res*10 + num),97);\n        end do\n    end function mod97\n\n    function checkCountryCode(iban) result(ibanlength)\n        character(len=*), intent(in) :: iban\n        integer(int16) :: ibanlength, i\n        ibanlength = 0\n        do i=1, size(cc)\n            if (iban(1:2) == cc(i)(1:2)) then\n                read(cc(i)(3:4),*) ibanlength\n                exit\n            end if\n        end do\n    end function checkCountryCode\n \n    Recursive Function Stripper(string,ch) Result(stripped)\n        Implicit None\n        character(len=*), intent(in) :: string\n        character, intent(in) :: ch\n        character(:), allocatable :: stripped\n\n        IF (LEN(string)==1) THEN\n           IF (string==ch) THEN \n              stripped = ''\n           ELSE\n              stripped = string\n           END IF\n        ELSE\n           IF (string(1:1)==ch) THEN\n              stripped = stripper(string(2:),ch)\n           ELSE\n              stripped = string(1:1)//stripper(string(2:),ch)\n           END IF\n        END IF\n    END Function stripper\n\n    Function Remove_Blanks(string) Result(stripped)\n        Implicit None\n        character(len=*), intent(in) ::   string\n        character(:), allocatable :: stripped\n\n        stripped = trim(Stripper(trim(Stripper(string,' ')),achar(9)))\n    END Function Remove_Blanks\n\nend program ibancheck\n", "target": "import re\n\n_country2length = dict(\n    AL=28, AD=24, AT=20, AZ=28, BE=16, BH=22, BA=20, BR=29,\n    BG=22, CR=21, HR=21, CY=28, CZ=24, DK=18, DO=28, EE=20,\n    FO=18, FI=18, FR=27, GE=22, DE=22, GI=23, GR=27, GL=18,\n    GT=28, HU=28, IS=26, IE=22, IL=23, IT=27, KZ=20, KW=30,\n    LV=21, LB=28, LI=21, LT=20, LU=20, MK=19, MT=31, MR=27,\n    MU=30, MC=27, MD=24, ME=22, NL=18, NO=15, PK=24, PS=29,\n    PL=28, PT=25, RO=24, SM=27, SA=24, RS=22, SK=24, SI=19,\n    ES=24, SE=24, CH=21, TN=24, TR=26, AE=23, GB=22, VG=24 )\n\ndef valid_iban(iban):\n    \n    iban = iban.replace(' ','').replace('\\t','')\n    if not re.match(r'^[\\dA-Z]+$', iban): \n        return False\n    \n    if len(iban) != _country2length[iban[:2]]:\n        return False\n    \n    iban = iban[4:] + iban[:4]\n    digits = int(''.join(str(int(ch, 36)) for ch in iban)) \n    return digits % 97 == 1\n\nif __name__ == '__main__':\n    for account in [\"GB82 WEST 1234 5698 7654 32\", \"GB82 TEST 1234 5698 7654 32\"]:\n        print('%s validation is: %s' % (account, valid_iban(account)))\n"}
{"id": 136351, "name": "Grayscale image", "source": "Translate Fortran to C#: type scimage\n   integer, dimension(:,:), pointer :: channel\n   integer :: width, height\nend type scimage\n", "target": "Bitmap tImage = new Bitmap(\"spectrum.bmp\");\n\nfor (int x = 0; x < tImage.Width; x++)\n{\n\tfor (int y = 0; y < tImage.Height; y++)\n\t{\n\t\tColor tCol = tImage.GetPixel(x, y);\n\n\t\t\n\t\tdouble L = 0.2126 * tCol.R + 0.7152 * tCol.G + 0.0722 * tCol.B;\n\t\ttImage.SetPixel(x, y, Color.FromArgb(Convert.ToInt32(L), Convert.ToInt32(L), Convert.ToInt32(L)));\n\t}\n}\n\n\ntImage.Save(\"spectrum2.bmp\");\n"}
{"id": 136353, "name": "Grayscale image", "source": "Translate Fortran to Java: type scimage\n   integer, dimension(:,:), pointer :: channel\n   integer :: width, height\nend type scimage\n", "target": "void convertToGrayscale(final BufferedImage image){\n    for(int i=0; i<image.getWidth(); i++){\n        for(int j=0; j<image.getHeight(); j++){\n            int color = image.getRGB(i,j);\n\n            int alpha = (color >> 24) & 255;\n            int red = (color >> 16) & 255;\n            int green = (color >> 8) & 255;\n            int blue = (color) & 255;\n\n            final int lum = (int)(0.2126 * red + 0.7152 * green + 0.0722 * blue);\n\n            alpha = (alpha << 24);\n            red = (lum << 16);\n            green = (lum << 8);\n            blue = lum;\n\n            color = alpha + red + green + blue;\n\n            image.setRGB(i,j,color);\n        }\n    }\n}\n"}
{"id": 136354, "name": "Grayscale image", "source": "Translate Fortran to Python: type scimage\n   integer, dimension(:,:), pointer :: channel\n   integer :: width, height\nend type scimage\n", "target": "\nimport io\nppmfileout = io.StringIO('')\n\ndef togreyscale(self):\n    for h in range(self.height):\n        for w in range(self.width):\n            r, g, b = self.get(w, h)\n            l = int(0.2126 * r + 0.7152 * g + 0.0722 * b)\n            self.set(w, h, Colour(l, l, l))\n\nBitmap.togreyscale = togreyscale    \n\n\n\nbitmap = Bitmap(4, 4, white)\nbitmap.fillrect(1, 0, 1, 2, Colour(127, 0, 63))\nbitmap.set(3, 3, Colour(0, 127, 31))\nprint('Colour:')\n\nbitmap.writeppmp3(ppmfileout)\nprint(ppmfileout.getvalue())\nprint('Grey:')\nbitmap.togreyscale()\nppmfileout = io.StringIO('')\nbitmap.writeppmp3(ppmfileout)\nprint(ppmfileout.getvalue())\n\n\n\n"}
{"id": 136545, "name": "Literals_String", "source": "Translate Fortran to C#:       DIMENSION ATWT(12)\n      PRINT 1\n    1 FORMAT (12HElement Name,F9.4)\n      DO 10 I = 1,12\n        READ  1,ATWT(I)\n   10   PRINT 1,ATWT(I)\n      END\n", "target": "string path = @\"C:\\Windows\\System32\";\nstring multiline = @\"Line 1.\nLine 2.\nLine 3.\";\n"}
{"id": 136548, "name": "Literals_String", "source": "Translate Fortran to Java:       DIMENSION ATWT(12)\n      PRINT 1\n    1 FORMAT (12HElement Name,F9.4)\n      DO 10 I = 1,12\n        READ  1,ATWT(I)\n   10   PRINT 1,ATWT(I)\n      END\n", "target": "  char a = 'a';  \n  String b = \"abc\";  \n  char doubleQuote = '\"';  \n  char singleQuote = '\\'';  \n  String singleQuotes = \"''\";  \n  String doubleQuotes = \"\\\"\\\"\";  \n"}
{"id": 136549, "name": "Literals_String", "source": "Translate Fortran to Python:       DIMENSION ATWT(12)\n      PRINT 1\n    1 FORMAT (12HElement Name,F9.4)\n      DO 10 I = 1,12\n        READ  1,ATWT(I)\n   10   PRINT 1,ATWT(I)\n      END\n", "target": "'c' == \"c\" \n'text' == \"text\"\n' \" '\n\" ' \"\n'\\x20' == ' '\nu'unicode string'\nu'\\u05d0' \n"}
{"id": 136795, "name": "Extend your language", "source": "Translate Fortran to C#:       LOGICAL A,B\t\t\n      INTEGER IA,IB\t\t\n      EQUIVALENCE (IA,A),(IB,B)\t\n\n      WRITE (6,*) \"Boolean tests via integers...\"\n      DO 199 IA = 0,1\t\n        DO 199 IB = 0,1\t\t\n          IF (IA) 666,99,109\t\t\n   99     IF (IB) 666,100,101\t\t\n  100     WRITE (6,*) \"FF\",IA,IB\n          GO TO 199\n  101     WRITE (6,*) \"FT\",IA,IB\n          GO TO 199\n  109     IF (IB) 666,110,111\t\t\n  110     WRITE (6,*) \"TF\",IA,IB\n          GO TO 199\n  111     WRITE (6,*) \"TT\",IA,IB\n  199 CONTINUE\t\t\n\n      WRITE (6,*) \"Boolean tests via integers and computed GO TO...\"\n      DO 299 IA = 0,1\t\n        DO 299 IB = 0,1\t\t\n          GO TO (200,201,210,211) 1 + IA*2 + IB\t\n  200     WRITE (6,*) \"FF\",IA,IB\n          GO TO 299\n  201     WRITE (6,*) \"FT\",IA,IB\n          GO TO 299\n  210     WRITE (6,*) \"TF\",IA,IB\n          GO TO 299\n  211     WRITE (6,*) \"TT\",IA,IB\n  299 CONTINUE\t\t\n\n  300 WRITE (6,301)\n  301 FORMAT (/,\"Boolean tests via LOGICAL variables...\",/\n     1 \" AB    IA    IB (IA*2 + IB)\")\n      A = .TRUE.\t\n      B = .TRUE.\t\n      DO I = 0,1\t\n        A = .NOT.A\t\t\n        DO J = 0,1\t\t\n          B = .NOT.B\t\t\t\n          WRITE (6,302) A,B,IA,IB,IA*2 + IB\t\n  302     FORMAT (1X,2L1,2I6,I8)\t\t\n        END DO\t\t\t\n      END DO\t\t\n      GO TO 999\n\n  666 WRITE (6,*) \"Huh?\"\n\n  999 CONTINUE\n      END\n", "target": "using System;\nusing System.Reflection;\n\nnamespace Extend_your_language\n{\n\t\n\n\tclass Program\n\t{\n\t\t\n\t\tpublic static void Main(string[] args)\n\t\t{\n\t\t\tConsole.WriteLine();\n\t\t\tConsole.WriteLine(\"Hello World!\");\n\t\t\tConsole.WriteLine();\n\t\t\t\n\t\t\tint x = 0;\n\t\t\tint y = 0;\n\t\t\t\n\t\t\tfor(x=0;x<2;x++)\n\t\t\t{\n\t\t\t\tfor(y=0;y<2;y++)\n\t\t\t\t{\n\t\t\t\t\t\n\t\t\t\t\tCONDITIONS( (x==0) , (y==0) ).\n\t\t\t\t\t\tIF2  (\"METHOD1\").\n\t\t\t\t\t\tELSE1(\"METHOD2\").\n\t\t\t\t\t\tELSE2(\"METHOD3\").\n\t\t\t\t\t\tELSE (\"METHOD4\");\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tConsole.WriteLine();\n\t\t\tConsole.Write(\"Press any key to continue . . . \");\n\t\t\tConsole.ReadKey(true);\n\t\t}\n\t\t\n\t\t\n\t\t\n\t\t\n\t\tpublic static void METHOD1()\n\t\t{\n\t\t\tConsole.WriteLine(\"METHOD 1 executed - both are true\");\n\t\t}\n\t\t\n\t\tpublic static void METHOD2()\n\t\t{\n\t\t\tConsole.WriteLine(\"METHOD 2 executed - first is true\");\n\t\t}\n\t\t\n\t\tpublic static void METHOD3()\n\t\t{\n\t\t\tConsole.WriteLine(\"METHOD 3 executed - second is true\");\n\t\t}\n\t\t\n\t\tpublic static void METHOD4()\n\t\t{\n\t\t\tConsole.WriteLine(\"METHOD 4 executed - both are false\");\n\t\t}\n\t\t\n\t\t\n\t\tstatic int CONDITIONS(bool condition1, bool condition2)\n\t\t{\n\t\t\tint c = 0;\n\t\t\tif(condition1 && condition2)\n\t\t\t\tc = 0;\n\t\t\telse if(condition1)\n\t\t\t\tc = 1;\n\t\t\telse if(condition2)\n\t\t\t\tc = 2;\n\t\t\telse\n\t\t\t\tc = 3;\n\t\t\t\n\t\t\treturn c;\n\t\t}\n\t}\n\t\n\t\n\tpublic static class ExtensionMethods\n\t{\n\n\t\tpublic static int IF2(this int value, string method)\n\t\t{\n\t\t\tif(value == 0)\n\t\t\t{\n\t\t\t\tMethodInfo m = typeof(Program).GetMethod(method);\n\t\t\t\tm.Invoke(null,null);\n\t\t\t}\n\t\t\t\n\t\t\treturn value;\n\t\t}\n\t\t\n\t\tpublic static int ELSE1(this int value, string method)\n\t\t{\n\t\t\tif(value == 1)\n\t\t\t{\n\t\t\t\tMethodInfo m = typeof(Program).GetMethod(method);\n\t\t\t\tm.Invoke(null,null);\n\t\t\t}\n\t\t\t\n\t\t\treturn value;\n\t\t}\n\t\t\n\t\tpublic static int ELSE2(this int value, string method)\n\t\t{\n\t\t\tif(value == 2)\n\t\t\t{\n\t\t\t\tMethodInfo m = typeof(Program).GetMethod(method);\n\t\t\t\tm.Invoke(null,null);\n\t\t\t}\n\t\t\t\n\t\t\treturn value;\n\t\t}\n\t\t\n\t\tpublic static void ELSE(this int value, string method)\n\t\t{\n\t\t\tif(value == 3)\n\t\t\t{\n\t\t\t\tMethodInfo m = typeof(Program).GetMethod(method);\n\t\t\t\tm.Invoke(null,null);\n\t\t\t}\n\t\t}\n\t\t\n\t}\n}\n"}
{"id": 136796, "name": "Extend your language", "source": "Translate Fortran to C#:       LOGICAL A,B\t\t\n      INTEGER IA,IB\t\t\n      EQUIVALENCE (IA,A),(IB,B)\t\n\n      WRITE (6,*) \"Boolean tests via integers...\"\n      DO 199 IA = 0,1\t\n        DO 199 IB = 0,1\t\t\n          IF (IA) 666,99,109\t\t\n   99     IF (IB) 666,100,101\t\t\n  100     WRITE (6,*) \"FF\",IA,IB\n          GO TO 199\n  101     WRITE (6,*) \"FT\",IA,IB\n          GO TO 199\n  109     IF (IB) 666,110,111\t\t\n  110     WRITE (6,*) \"TF\",IA,IB\n          GO TO 199\n  111     WRITE (6,*) \"TT\",IA,IB\n  199 CONTINUE\t\t\n\n      WRITE (6,*) \"Boolean tests via integers and computed GO TO...\"\n      DO 299 IA = 0,1\t\n        DO 299 IB = 0,1\t\t\n          GO TO (200,201,210,211) 1 + IA*2 + IB\t\n  200     WRITE (6,*) \"FF\",IA,IB\n          GO TO 299\n  201     WRITE (6,*) \"FT\",IA,IB\n          GO TO 299\n  210     WRITE (6,*) \"TF\",IA,IB\n          GO TO 299\n  211     WRITE (6,*) \"TT\",IA,IB\n  299 CONTINUE\t\t\n\n  300 WRITE (6,301)\n  301 FORMAT (/,\"Boolean tests via LOGICAL variables...\",/\n     1 \" AB    IA    IB (IA*2 + IB)\")\n      A = .TRUE.\t\n      B = .TRUE.\t\n      DO I = 0,1\t\n        A = .NOT.A\t\t\n        DO J = 0,1\t\t\n          B = .NOT.B\t\t\t\n          WRITE (6,302) A,B,IA,IB,IA*2 + IB\t\n  302     FORMAT (1X,2L1,2I6,I8)\t\t\n        END DO\t\t\t\n      END DO\t\t\n      GO TO 999\n\n  666 WRITE (6,*) \"Huh?\"\n\n  999 CONTINUE\n      END\n", "target": "using System;\nusing System.Reflection;\n\nnamespace Extend_your_language\n{\n\t\n\n\tclass Program\n\t{\n\t\t\n\t\tpublic static void Main(string[] args)\n\t\t{\n\t\t\tConsole.WriteLine();\n\t\t\tConsole.WriteLine(\"Hello World!\");\n\t\t\tConsole.WriteLine();\n\t\t\t\n\t\t\tint x = 0;\n\t\t\tint y = 0;\n\t\t\t\n\t\t\tfor(x=0;x<2;x++)\n\t\t\t{\n\t\t\t\tfor(y=0;y<2;y++)\n\t\t\t\t{\n\t\t\t\t\t\n\t\t\t\t\tCONDITIONS( (x==0) , (y==0) ).\n\t\t\t\t\t\tIF2  (\"METHOD1\").\n\t\t\t\t\t\tELSE1(\"METHOD2\").\n\t\t\t\t\t\tELSE2(\"METHOD3\").\n\t\t\t\t\t\tELSE (\"METHOD4\");\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tConsole.WriteLine();\n\t\t\tConsole.Write(\"Press any key to continue . . . \");\n\t\t\tConsole.ReadKey(true);\n\t\t}\n\t\t\n\t\t\n\t\t\n\t\t\n\t\tpublic static void METHOD1()\n\t\t{\n\t\t\tConsole.WriteLine(\"METHOD 1 executed - both are true\");\n\t\t}\n\t\t\n\t\tpublic static void METHOD2()\n\t\t{\n\t\t\tConsole.WriteLine(\"METHOD 2 executed - first is true\");\n\t\t}\n\t\t\n\t\tpublic static void METHOD3()\n\t\t{\n\t\t\tConsole.WriteLine(\"METHOD 3 executed - second is true\");\n\t\t}\n\t\t\n\t\tpublic static void METHOD4()\n\t\t{\n\t\t\tConsole.WriteLine(\"METHOD 4 executed - both are false\");\n\t\t}\n\t\t\n\t\t\n\t\tstatic int CONDITIONS(bool condition1, bool condition2)\n\t\t{\n\t\t\tint c = 0;\n\t\t\tif(condition1 && condition2)\n\t\t\t\tc = 0;\n\t\t\telse if(condition1)\n\t\t\t\tc = 1;\n\t\t\telse if(condition2)\n\t\t\t\tc = 2;\n\t\t\telse\n\t\t\t\tc = 3;\n\t\t\t\n\t\t\treturn c;\n\t\t}\n\t}\n\t\n\t\n\tpublic static class ExtensionMethods\n\t{\n\n\t\tpublic static int IF2(this int value, string method)\n\t\t{\n\t\t\tif(value == 0)\n\t\t\t{\n\t\t\t\tMethodInfo m = typeof(Program).GetMethod(method);\n\t\t\t\tm.Invoke(null,null);\n\t\t\t}\n\t\t\t\n\t\t\treturn value;\n\t\t}\n\t\t\n\t\tpublic static int ELSE1(this int value, string method)\n\t\t{\n\t\t\tif(value == 1)\n\t\t\t{\n\t\t\t\tMethodInfo m = typeof(Program).GetMethod(method);\n\t\t\t\tm.Invoke(null,null);\n\t\t\t}\n\t\t\t\n\t\t\treturn value;\n\t\t}\n\t\t\n\t\tpublic static int ELSE2(this int value, string method)\n\t\t{\n\t\t\tif(value == 2)\n\t\t\t{\n\t\t\t\tMethodInfo m = typeof(Program).GetMethod(method);\n\t\t\t\tm.Invoke(null,null);\n\t\t\t}\n\t\t\t\n\t\t\treturn value;\n\t\t}\n\t\t\n\t\tpublic static void ELSE(this int value, string method)\n\t\t{\n\t\t\tif(value == 3)\n\t\t\t{\n\t\t\t\tMethodInfo m = typeof(Program).GetMethod(method);\n\t\t\t\tm.Invoke(null,null);\n\t\t\t}\n\t\t}\n\t\t\n\t}\n}\n"}
{"id": 136799, "name": "Extend your language", "source": "Translate Fortran to Java:       LOGICAL A,B\t\t\n      INTEGER IA,IB\t\t\n      EQUIVALENCE (IA,A),(IB,B)\t\n\n      WRITE (6,*) \"Boolean tests via integers...\"\n      DO 199 IA = 0,1\t\n        DO 199 IB = 0,1\t\t\n          IF (IA) 666,99,109\t\t\n   99     IF (IB) 666,100,101\t\t\n  100     WRITE (6,*) \"FF\",IA,IB\n          GO TO 199\n  101     WRITE (6,*) \"FT\",IA,IB\n          GO TO 199\n  109     IF (IB) 666,110,111\t\t\n  110     WRITE (6,*) \"TF\",IA,IB\n          GO TO 199\n  111     WRITE (6,*) \"TT\",IA,IB\n  199 CONTINUE\t\t\n\n      WRITE (6,*) \"Boolean tests via integers and computed GO TO...\"\n      DO 299 IA = 0,1\t\n        DO 299 IB = 0,1\t\t\n          GO TO (200,201,210,211) 1 + IA*2 + IB\t\n  200     WRITE (6,*) \"FF\",IA,IB\n          GO TO 299\n  201     WRITE (6,*) \"FT\",IA,IB\n          GO TO 299\n  210     WRITE (6,*) \"TF\",IA,IB\n          GO TO 299\n  211     WRITE (6,*) \"TT\",IA,IB\n  299 CONTINUE\t\t\n\n  300 WRITE (6,301)\n  301 FORMAT (/,\"Boolean tests via LOGICAL variables...\",/\n     1 \" AB    IA    IB (IA*2 + IB)\")\n      A = .TRUE.\t\n      B = .TRUE.\t\n      DO I = 0,1\t\n        A = .NOT.A\t\t\n        DO J = 0,1\t\t\n          B = .NOT.B\t\t\t\n          WRITE (6,302) A,B,IA,IB,IA*2 + IB\t\n  302     FORMAT (1X,2L1,2I6,I8)\t\t\n        END DO\t\t\t\n      END DO\t\t\n      GO TO 999\n\n  666 WRITE (6,*) \"Huh?\"\n\n  999 CONTINUE\n      END\n", "target": "public class If2 {\n\n    public static void if2(boolean firstCondition, boolean secondCondition,\n                           Runnable bothTrue, Runnable firstTrue, Runnable secondTrue, Runnable noneTrue) {\n        if (firstCondition)\n            if (secondCondition)\n                bothTrue.run();\n            else firstTrue.run();\n        else if (secondCondition)\n            secondTrue.run();\n        else noneTrue.run();\n    }\n}\n"}
{"id": 136800, "name": "Extend your language", "source": "Translate Fortran to Java:       LOGICAL A,B\t\t\n      INTEGER IA,IB\t\t\n      EQUIVALENCE (IA,A),(IB,B)\t\n\n      WRITE (6,*) \"Boolean tests via integers...\"\n      DO 199 IA = 0,1\t\n        DO 199 IB = 0,1\t\t\n          IF (IA) 666,99,109\t\t\n   99     IF (IB) 666,100,101\t\t\n  100     WRITE (6,*) \"FF\",IA,IB\n          GO TO 199\n  101     WRITE (6,*) \"FT\",IA,IB\n          GO TO 199\n  109     IF (IB) 666,110,111\t\t\n  110     WRITE (6,*) \"TF\",IA,IB\n          GO TO 199\n  111     WRITE (6,*) \"TT\",IA,IB\n  199 CONTINUE\t\t\n\n      WRITE (6,*) \"Boolean tests via integers and computed GO TO...\"\n      DO 299 IA = 0,1\t\n        DO 299 IB = 0,1\t\t\n          GO TO (200,201,210,211) 1 + IA*2 + IB\t\n  200     WRITE (6,*) \"FF\",IA,IB\n          GO TO 299\n  201     WRITE (6,*) \"FT\",IA,IB\n          GO TO 299\n  210     WRITE (6,*) \"TF\",IA,IB\n          GO TO 299\n  211     WRITE (6,*) \"TT\",IA,IB\n  299 CONTINUE\t\t\n\n  300 WRITE (6,301)\n  301 FORMAT (/,\"Boolean tests via LOGICAL variables...\",/\n     1 \" AB    IA    IB (IA*2 + IB)\")\n      A = .TRUE.\t\n      B = .TRUE.\t\n      DO I = 0,1\t\n        A = .NOT.A\t\t\n        DO J = 0,1\t\t\n          B = .NOT.B\t\t\t\n          WRITE (6,302) A,B,IA,IB,IA*2 + IB\t\n  302     FORMAT (1X,2L1,2I6,I8)\t\t\n        END DO\t\t\t\n      END DO\t\t\n      GO TO 999\n\n  666 WRITE (6,*) \"Huh?\"\n\n  999 CONTINUE\n      END\n", "target": "public class If2 {\n\n    public static void if2(boolean firstCondition, boolean secondCondition,\n                           Runnable bothTrue, Runnable firstTrue, Runnable secondTrue, Runnable noneTrue) {\n        if (firstCondition)\n            if (secondCondition)\n                bothTrue.run();\n            else firstTrue.run();\n        else if (secondCondition)\n            secondTrue.run();\n        else noneTrue.run();\n    }\n}\n"}
{"id": 136801, "name": "Extend your language", "source": "Translate Fortran to Python:       LOGICAL A,B\t\t\n      INTEGER IA,IB\t\t\n      EQUIVALENCE (IA,A),(IB,B)\t\n\n      WRITE (6,*) \"Boolean tests via integers...\"\n      DO 199 IA = 0,1\t\n        DO 199 IB = 0,1\t\t\n          IF (IA) 666,99,109\t\t\n   99     IF (IB) 666,100,101\t\t\n  100     WRITE (6,*) \"FF\",IA,IB\n          GO TO 199\n  101     WRITE (6,*) \"FT\",IA,IB\n          GO TO 199\n  109     IF (IB) 666,110,111\t\t\n  110     WRITE (6,*) \"TF\",IA,IB\n          GO TO 199\n  111     WRITE (6,*) \"TT\",IA,IB\n  199 CONTINUE\t\t\n\n      WRITE (6,*) \"Boolean tests via integers and computed GO TO...\"\n      DO 299 IA = 0,1\t\n        DO 299 IB = 0,1\t\t\n          GO TO (200,201,210,211) 1 + IA*2 + IB\t\n  200     WRITE (6,*) \"FF\",IA,IB\n          GO TO 299\n  201     WRITE (6,*) \"FT\",IA,IB\n          GO TO 299\n  210     WRITE (6,*) \"TF\",IA,IB\n          GO TO 299\n  211     WRITE (6,*) \"TT\",IA,IB\n  299 CONTINUE\t\t\n\n  300 WRITE (6,301)\n  301 FORMAT (/,\"Boolean tests via LOGICAL variables...\",/\n     1 \" AB    IA    IB (IA*2 + IB)\")\n      A = .TRUE.\t\n      B = .TRUE.\t\n      DO I = 0,1\t\n        A = .NOT.A\t\t\n        DO J = 0,1\t\t\n          B = .NOT.B\t\t\t\n          WRITE (6,302) A,B,IA,IB,IA*2 + IB\t\n  302     FORMAT (1X,2L1,2I6,I8)\t\t\n        END DO\t\t\t\n      END DO\t\t\n      GO TO 999\n\n  666 WRITE (6,*) \"Huh?\"\n\n  999 CONTINUE\n      END\n", "target": "a, b = 1, 0\n\nif (c1 := a == 1) and (c2 := b == 3):\n  print('a = 1 and b = 3')\nelif c1:\n  print('a = 1 and b <> 3')\nelif c2:\n  print('a <> 1 and b = 3')\nelse:\n  print('a <> 1 and b <> 3')\n"}
{"id": 136802, "name": "Extend your language", "source": "Translate Fortran to Python:       LOGICAL A,B\t\t\n      INTEGER IA,IB\t\t\n      EQUIVALENCE (IA,A),(IB,B)\t\n\n      WRITE (6,*) \"Boolean tests via integers...\"\n      DO 199 IA = 0,1\t\n        DO 199 IB = 0,1\t\t\n          IF (IA) 666,99,109\t\t\n   99     IF (IB) 666,100,101\t\t\n  100     WRITE (6,*) \"FF\",IA,IB\n          GO TO 199\n  101     WRITE (6,*) \"FT\",IA,IB\n          GO TO 199\n  109     IF (IB) 666,110,111\t\t\n  110     WRITE (6,*) \"TF\",IA,IB\n          GO TO 199\n  111     WRITE (6,*) \"TT\",IA,IB\n  199 CONTINUE\t\t\n\n      WRITE (6,*) \"Boolean tests via integers and computed GO TO...\"\n      DO 299 IA = 0,1\t\n        DO 299 IB = 0,1\t\t\n          GO TO (200,201,210,211) 1 + IA*2 + IB\t\n  200     WRITE (6,*) \"FF\",IA,IB\n          GO TO 299\n  201     WRITE (6,*) \"FT\",IA,IB\n          GO TO 299\n  210     WRITE (6,*) \"TF\",IA,IB\n          GO TO 299\n  211     WRITE (6,*) \"TT\",IA,IB\n  299 CONTINUE\t\t\n\n  300 WRITE (6,301)\n  301 FORMAT (/,\"Boolean tests via LOGICAL variables...\",/\n     1 \" AB    IA    IB (IA*2 + IB)\")\n      A = .TRUE.\t\n      B = .TRUE.\t\n      DO I = 0,1\t\n        A = .NOT.A\t\t\n        DO J = 0,1\t\t\n          B = .NOT.B\t\t\t\n          WRITE (6,302) A,B,IA,IB,IA*2 + IB\t\n  302     FORMAT (1X,2L1,2I6,I8)\t\t\n        END DO\t\t\t\n      END DO\t\t\n      GO TO 999\n\n  666 WRITE (6,*) \"Huh?\"\n\n  999 CONTINUE\n      END\n", "target": "a, b = 1, 0\n\nif (c1 := a == 1) and (c2 := b == 3):\n  print('a = 1 and b = 3')\nelif c1:\n  print('a = 1 and b <> 3')\nelif c2:\n  print('a <> 1 and b = 3')\nelse:\n  print('a <> 1 and b <> 3')\n"}
{"id": 137031, "name": "Compare length of two strings", "source": "Translate Fortran to C#: program demo_sort_indexed\nimplicit none\n\n   call print_sorted_by_length( [character(len=20) :: \"shorter\",\"longer\"] )\n   call print_sorted_by_length( [character(len=20) :: \"abcd\",\"123456789\",\"abcdef\",\"1234567\"] )\n   call print_sorted_by_length( [character(len=20) :: 'the','quick','brown','fox','jumps','over','the','lazy','dog'])\n\ncontains\n\nsubroutine print_sorted_by_length(list)\ncharacter(len=*) :: list(:)\ninteger :: i\n\n   list(sort_int(len_trim(list)))=list \n   write(*,'(i9,1x,a)')(len_trim(list(i)), list(i),i=size(list),1,-1)\n   write(*,*)\n\nend subroutine print_sorted_by_length\n\nfunction sort_int(input) result(counts) \ninteger :: input(:), counts(size(input)), i\n   counts=[(count(input(i) > input)+count(input(i) == input(:i)),i=1, size(input) )]\nend function sort_int\n\nend program demo_sort_indexed\n", "target": "using System;\nusing System.Collections.Generic;\n\nnamespace example\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            var strings = new string[] { \"abcd\", \"123456789\", \"abcdef\", \"1234567\" };\n            compareAndReportStringsLength(strings);\n        }\n\n        private static void compareAndReportStringsLength(string[] strings)\n        {\n            if (strings.Length > 0)\n            {\n                char Q = '\"';\n                string hasLength = \" has length \";\n                string predicateMax = \" and is the longest string\";\n                string predicateMin = \" and is the shortest string\";\n                string predicateAve = \" and is neither the longest nor the shortest string\";\n                string predicate;\n\n                (int, int)[] li = new (int, int)[strings.Length];\n                for (int i = 0; i < strings.Length; i++)\n                    li[i] = (strings[i].Length, i);\n                Array.Sort(li, ((int, int) a, (int, int) b) => b.Item1 - a.Item1);\n                int maxLength = li[0].Item1;\n                int minLength = li[strings.Length - 1].Item1;\n\n                for (int i = 0; i < strings.Length; i++)\n                {\n                    int length = li[i].Item1;\n                    string str = strings[li[i].Item2];\n                    if (length == maxLength)\n                        predicate = predicateMax;\n                    else if (length == minLength)\n                        predicate = predicateMin;\n                    else\n                        predicate = predicateAve;\n                    Console.WriteLine(Q + str + Q + hasLength + length + predicate);\n                }\n            }\n        }\n\n    }\n}\n"}
{"id": 137034, "name": "Compare length of two strings", "source": "Translate Fortran to Java: program demo_sort_indexed\nimplicit none\n\n   call print_sorted_by_length( [character(len=20) :: \"shorter\",\"longer\"] )\n   call print_sorted_by_length( [character(len=20) :: \"abcd\",\"123456789\",\"abcdef\",\"1234567\"] )\n   call print_sorted_by_length( [character(len=20) :: 'the','quick','brown','fox','jumps','over','the','lazy','dog'])\n\ncontains\n\nsubroutine print_sorted_by_length(list)\ncharacter(len=*) :: list(:)\ninteger :: i\n\n   list(sort_int(len_trim(list)))=list \n   write(*,'(i9,1x,a)')(len_trim(list(i)), list(i),i=size(list),1,-1)\n   write(*,*)\n\nend subroutine print_sorted_by_length\n\nfunction sort_int(input) result(counts) \ninteger :: input(:), counts(size(input)), i\n   counts=[(count(input(i) > input)+count(input(i) == input(:i)),i=1, size(input) )]\nend function sort_int\n\nend program demo_sort_indexed\n", "target": "package stringlensort;\n\nimport java.io.PrintStream;\nimport java.util.Arrays;\nimport java.util.Comparator;\n\npublic class ReportStringLengths {\n\n    public static void main(String[] args) {\n        String[] list = {\"abcd\", \"123456789\", \"abcdef\", \"1234567\"};\n        String[] strings = args.length > 0 ? args : list;\n\n        compareAndReportStringsLength(strings);\n    }\n\n        \n    public static void compareAndReportStringsLength(String[] strings) {\n        compareAndReportStringsLength(strings, System.out);\n    }\n\n    \n    public static void compareAndReportStringsLength(String[] strings, PrintStream stream) {\n        if (strings.length > 0) {\n            strings = strings.clone();\n            final String QUOTE = \"\\\"\";\n            Arrays.sort(strings, Comparator.comparing(String::length));\n            int min = strings[0].length();\n            int max = strings[strings.length - 1].length();\n            for (int i = strings.length - 1; i >= 0; i--) {\n                int length = strings[i].length();\n                String predicate;\n                if (length == max) {\n                    predicate = \"is the longest string\";\n                } else if (length == min) {\n                    predicate = \"is the shortest string\";\n                } else {\n                    predicate = \"is neither the longest nor the shortest string\";\n                }\n                \n                stream.println(QUOTE + strings[i] + QUOTE + \" has length \" + length\n                        + \" and \" + predicate);\n            }\n        }\n    }\n}\n"}
{"id": 137035, "name": "Compare length of two strings", "source": "Translate Fortran to Python: program demo_sort_indexed\nimplicit none\n\n   call print_sorted_by_length( [character(len=20) :: \"shorter\",\"longer\"] )\n   call print_sorted_by_length( [character(len=20) :: \"abcd\",\"123456789\",\"abcdef\",\"1234567\"] )\n   call print_sorted_by_length( [character(len=20) :: 'the','quick','brown','fox','jumps','over','the','lazy','dog'])\n\ncontains\n\nsubroutine print_sorted_by_length(list)\ncharacter(len=*) :: list(:)\ninteger :: i\n\n   list(sort_int(len_trim(list)))=list \n   write(*,'(i9,1x,a)')(len_trim(list(i)), list(i),i=size(list),1,-1)\n   write(*,*)\n\nend subroutine print_sorted_by_length\n\nfunction sort_int(input) result(counts) \ninteger :: input(:), counts(size(input)), i\n   counts=[(count(input(i) > input)+count(input(i) == input(:i)),i=1, size(input) )]\nend function sort_int\n\nend program demo_sort_indexed\n", "target": "A = 'I am string'\nB = 'I am string too'\n\nif len(A) > len(B):\n    print('\"' + A + '\"', 'has length', len(A), 'and is the longest of the two strings')\n    print('\"' + B + '\"', 'has length', len(B), 'and is the shortest of the two strings')\nelif len(A) < len(B):\n    print('\"' + B + '\"', 'has length', len(B), 'and is the longest of the two strings')\n    print('\"' + A + '\"', 'has length', len(A), 'and is the shortest of the two strings')\nelse:\n    print('\"' + A + '\"', 'has length', len(A), 'and it is as long as the second string')\n    print('\"' + B + '\"', 'has length', len(B), 'and it is as long as the second string')\n"}
{"id": 137221, "name": "Zig-zag matrix", "source": "Translate Fortran to C#: PROGRAM ZIGZAG\n \n  IMPLICIT NONE\n    INTEGER, PARAMETER :: size = 5\n    INTEGER :: zzarray(size,size), x(size*size), y(size*size), i, j\n     \n    \n    x = (/ ((j, i = 1, size), j = 1, size) /)\n    y = (/ ((i, i = 1, size), j = 1, size) /)\n   \n    \n    DO i = 2, size*size\n       j = i - 1\n       DO WHILE (j>=1 .AND. (x(j)+y(j)) > (x(i)+y(i)))\n          j = j - 1\n       END DO\n       x(j+1:i) = cshift(x(j+1:i),-1)\n       y(j+1:i) = cshift(y(j+1:i),-1)\n    END DO\n \n    \n    DO i = 1, size*size\n       IF (MOD(x(i)+y(i), 2) == 0) THEN\n          zzarray(x(i),y(i)) = i - 1\n       ELSE\n          zzarray(y(i),x(i)) = i - 1\n       END IF\n    END DO\n  \n    \n    DO j = 1, size\n       DO i = 1, size\n          WRITE(*, \"(I5)\", ADVANCE=\"NO\") zzarray(i,j)\n       END DO\n       WRITE(*,*)\n    END DO\n  \n END PROGRAM ZIGZAG\n", "target": "public static int[,] ZigZag(int n)\n{\n    int[,] result = new int[n, n];\n    int i = 0, j = 0;\n    int d = -1; \n    int start = 0, end = n * n - 1;\n    do\n    {\n        result[i, j] = start++;\n        result[n - i - 1, n - j - 1] = end--;\n\n        i += d; j -= d;\n        if (i < 0)\n        {\n            i++; d = -d; \n        }\n        else if (j < 0)\n        {\n            j++; d = -d; \n        }\n    } while (start < end);\n    if (start == end)\n        result[i, j] = start;\n    return result;\n}\n"}
{"id": 137225, "name": "Zig-zag matrix", "source": "Translate Fortran to Java: PROGRAM ZIGZAG\n \n  IMPLICIT NONE\n    INTEGER, PARAMETER :: size = 5\n    INTEGER :: zzarray(size,size), x(size*size), y(size*size), i, j\n     \n    \n    x = (/ ((j, i = 1, size), j = 1, size) /)\n    y = (/ ((i, i = 1, size), j = 1, size) /)\n   \n    \n    DO i = 2, size*size\n       j = i - 1\n       DO WHILE (j>=1 .AND. (x(j)+y(j)) > (x(i)+y(i)))\n          j = j - 1\n       END DO\n       x(j+1:i) = cshift(x(j+1:i),-1)\n       y(j+1:i) = cshift(y(j+1:i),-1)\n    END DO\n \n    \n    DO i = 1, size*size\n       IF (MOD(x(i)+y(i), 2) == 0) THEN\n          zzarray(x(i),y(i)) = i - 1\n       ELSE\n          zzarray(y(i),x(i)) = i - 1\n       END IF\n    END DO\n  \n    \n    DO j = 1, size\n       DO i = 1, size\n          WRITE(*, \"(I5)\", ADVANCE=\"NO\") zzarray(i,j)\n       END DO\n       WRITE(*,*)\n    END DO\n  \n END PROGRAM ZIGZAG\n", "target": "public static int[][] Zig_Zag(final int size)\n{\n int[][] data = new int[size][size];\n int i = 1;\n int j = 1;\n for (int element = 0; element < size * size; element++)\n {\n  data[i - 1][j - 1] = element;\n  if ((i + j) % 2 == 0)\n  {\n   \n   if (j < size)\n    j++;\n   else\n    i+= 2;\n   if (i > 1)\n    i--;\n  }\n  else\n  {\n   \n   if (i < size)\n    i++;\n   else\n    j+= 2;\n   if (j > 1)\n    j--;\n  }\n }\n return data;\n}\n"}
{"id": 137226, "name": "Zig-zag matrix", "source": "Translate Fortran to Python: PROGRAM ZIGZAG\n \n  IMPLICIT NONE\n    INTEGER, PARAMETER :: size = 5\n    INTEGER :: zzarray(size,size), x(size*size), y(size*size), i, j\n     \n    \n    x = (/ ((j, i = 1, size), j = 1, size) /)\n    y = (/ ((i, i = 1, size), j = 1, size) /)\n   \n    \n    DO i = 2, size*size\n       j = i - 1\n       DO WHILE (j>=1 .AND. (x(j)+y(j)) > (x(i)+y(i)))\n          j = j - 1\n       END DO\n       x(j+1:i) = cshift(x(j+1:i),-1)\n       y(j+1:i) = cshift(y(j+1:i),-1)\n    END DO\n \n    \n    DO i = 1, size*size\n       IF (MOD(x(i)+y(i), 2) == 0) THEN\n          zzarray(x(i),y(i)) = i - 1\n       ELSE\n          zzarray(y(i),x(i)) = i - 1\n       END IF\n    END DO\n  \n    \n    DO j = 1, size\n       DO i = 1, size\n          WRITE(*, \"(I5)\", ADVANCE=\"NO\") zzarray(i,j)\n       END DO\n       WRITE(*,*)\n    END DO\n  \n END PROGRAM ZIGZAG\n", "target": "def zigzag(n):\n    \n    def compare(xy):\n        x, y = xy\n        return (x + y, -y if (x + y) % 2 else y)\n    xs = range(n)\n    return {index: n for n, index in enumerate(sorted(\n        ((x, y) for x in xs for y in xs),\n        key=compare\n    ))}\n\n\ndef printzz(myarray):\n    \n    n = int(len(myarray) ** 0.5 + 0.5)\n    xs = range(n)\n    print('\\n'.join(\n        [''.join(\"%3i\" % myarray[(x, y)] for x in xs) for y in xs]\n    ))\n\n\nprintzz(zigzag(6))\n"}
{"id": 137600, "name": "JSON", "source": "Translate Fortran to C#: program json_fortran\n   use json_module\n   implicit none\n\n   type phonebook_type\n      character(len=:),allocatable :: name\n      character(len=:),allocatable :: phone\n   end type phonebook_type\n\n   type(phonebook_type), dimension(3) :: PhoneBook\n   integer :: i\n   type(json_value),pointer :: json_phonebook,p,e\n   type(json_file) :: json\n\n   PhoneBook(1) % name = 'Adam'\n   PhoneBook(2) % name = 'Eve'\n   PhoneBook(3) % name = 'Julia'\n   PhoneBook(1) % phone = '0000001'\n   PhoneBook(2) % phone = '0000002'\n   PhoneBook(3) % phone = '6666666'\n\n   call json_initialize()\n\n   \n   call json_create_object(json_phonebook,'')\n\n   \n   call json_create_array(p,'PhoneBook')\n   do i=1,3\n      call json_create_object(e,'')\n      call json_add(e,'name',PhoneBook(i)%name)\n      call json_add(e,'phone',PhoneBook(i)%phone)\n      call json_add(p,e) \n      nullify(e) \n   end do\n   call json_add(json_phonebook,p) \n   nullify(p) \n\n   \n   call json_print(json_phonebook,'phonebook.json')\n\n   \n   call json%load_from_string('{ \"PhoneBook\": [ { \"name\": \"Adam\", \"phone\": \"0000001\" },&\n   { \"name\": \"Eve\", \"phone\": \"0000002\" }, { \"name\": \"Julia\", \"phone\": \"6666666\" } ]}')\n   \n   call json%print_file()\n\nend program json_fortran\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Web.Script.Serialization;\n\nclass Program\n{\n    static void Main()\n    {\n        var people = new Dictionary<string, object> {{\"1\", \"John\"}, {\"2\", \"Susan\"}};\n        var serializer = new JavaScriptSerializer();\n        \n        var json = serializer.Serialize(people);\n        Console.WriteLine(json);\n\n        var deserialized = serializer.Deserialize<Dictionary<string, object>>(json);\n        Console.WriteLine(deserialized[\"2\"]);\n\n        var jsonObject = serializer.DeserializeObject(@\"{ \"\"foo\"\": 1, \"\"bar\"\": [10, \"\"apples\"\"] }\");\n        var data = jsonObject as Dictionary<string, object>;\n        var array = data[\"bar\"] as object[];\n        Console.WriteLine(array[1]);\n    }\n}\n"}
{"id": 137601, "name": "JSON", "source": "Translate Fortran to C#: program json_fortran\n   use json_module\n   implicit none\n\n   type phonebook_type\n      character(len=:),allocatable :: name\n      character(len=:),allocatable :: phone\n   end type phonebook_type\n\n   type(phonebook_type), dimension(3) :: PhoneBook\n   integer :: i\n   type(json_value),pointer :: json_phonebook,p,e\n   type(json_file) :: json\n\n   PhoneBook(1) % name = 'Adam'\n   PhoneBook(2) % name = 'Eve'\n   PhoneBook(3) % name = 'Julia'\n   PhoneBook(1) % phone = '0000001'\n   PhoneBook(2) % phone = '0000002'\n   PhoneBook(3) % phone = '6666666'\n\n   call json_initialize()\n\n   \n   call json_create_object(json_phonebook,'')\n\n   \n   call json_create_array(p,'PhoneBook')\n   do i=1,3\n      call json_create_object(e,'')\n      call json_add(e,'name',PhoneBook(i)%name)\n      call json_add(e,'phone',PhoneBook(i)%phone)\n      call json_add(p,e) \n      nullify(e) \n   end do\n   call json_add(json_phonebook,p) \n   nullify(p) \n\n   \n   call json_print(json_phonebook,'phonebook.json')\n\n   \n   call json%load_from_string('{ \"PhoneBook\": [ { \"name\": \"Adam\", \"phone\": \"0000001\" },&\n   { \"name\": \"Eve\", \"phone\": \"0000002\" }, { \"name\": \"Julia\", \"phone\": \"6666666\" } ]}')\n   \n   call json%print_file()\n\nend program json_fortran\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Web.Script.Serialization;\n\nclass Program\n{\n    static void Main()\n    {\n        var people = new Dictionary<string, object> {{\"1\", \"John\"}, {\"2\", \"Susan\"}};\n        var serializer = new JavaScriptSerializer();\n        \n        var json = serializer.Serialize(people);\n        Console.WriteLine(json);\n\n        var deserialized = serializer.Deserialize<Dictionary<string, object>>(json);\n        Console.WriteLine(deserialized[\"2\"]);\n\n        var jsonObject = serializer.DeserializeObject(@\"{ \"\"foo\"\": 1, \"\"bar\"\": [10, \"\"apples\"\"] }\");\n        var data = jsonObject as Dictionary<string, object>;\n        var array = data[\"bar\"] as object[];\n        Console.WriteLine(array[1]);\n    }\n}\n"}
{"id": 137606, "name": "JSON", "source": "Translate Fortran to Java: program json_fortran\n   use json_module\n   implicit none\n\n   type phonebook_type\n      character(len=:),allocatable :: name\n      character(len=:),allocatable :: phone\n   end type phonebook_type\n\n   type(phonebook_type), dimension(3) :: PhoneBook\n   integer :: i\n   type(json_value),pointer :: json_phonebook,p,e\n   type(json_file) :: json\n\n   PhoneBook(1) % name = 'Adam'\n   PhoneBook(2) % name = 'Eve'\n   PhoneBook(3) % name = 'Julia'\n   PhoneBook(1) % phone = '0000001'\n   PhoneBook(2) % phone = '0000002'\n   PhoneBook(3) % phone = '6666666'\n\n   call json_initialize()\n\n   \n   call json_create_object(json_phonebook,'')\n\n   \n   call json_create_array(p,'PhoneBook')\n   do i=1,3\n      call json_create_object(e,'')\n      call json_add(e,'name',PhoneBook(i)%name)\n      call json_add(e,'phone',PhoneBook(i)%phone)\n      call json_add(p,e) \n      nullify(e) \n   end do\n   call json_add(json_phonebook,p) \n   nullify(p) \n\n   \n   call json_print(json_phonebook,'phonebook.json')\n\n   \n   call json%load_from_string('{ \"PhoneBook\": [ { \"name\": \"Adam\", \"phone\": \"0000001\" },&\n   { \"name\": \"Eve\", \"phone\": \"0000002\" }, { \"name\": \"Julia\", \"phone\": \"6666666\" } ]}')\n   \n   call json%print_file()\n\nend program json_fortran\n", "target": "\n\n\n\ngrammar JSON ;\n@members {\nString Indent = \"\";\n}\nNumber\t:\t(('0')|('-'? ('1'..'9') ('0'..'9')*)) ('.' ('0'..'9')+)? (('e'|'E') ('+'|'-')? ('0'..'9')+)?;\nWS\t:\t(' ' | '\\t' | '\\r' |'\\n') {skip();};\nTz\t:\t' ' .. '!' | '#' .. '[' | ']' .. '~';\nControl\t:\t'\\\\' ('\"'|'\\\\'|'/'|'b'|'f'|'n'|'r'|'t'|UCode);\nUCode\t:\t'u' ('0'..'9'|'a'..'f'|'A'..'F') ('0'..'9'|'a'..'f'|'A'..'F') ('0'..'9'|'a'..'f'|'A'..'F') ('0'..'9'|'a'..'f'|'A'..'F');\nKeyword\t:\t'true' | 'false' | 'null';\nString\t:\t'\"' (Control? Tz)* '\"';\nobject\t:       '{' {System.out.println(Indent + \"{Object}\"); Indent += \"    \";} (pair (',' pair*)*)? '}' {Indent = Indent.substring(4);};\npair\t:\te = String {System.out.println(Indent + \"{Property}\\t\" + $e.text);} ':' value;\nvalue\t:\tNumber             {System.out.println(Indent + \"{Number}  \\t\" + $Number.text);}\n\t|\tobject\n\t|\tString             {System.out.println(Indent + \"{String}  \\t\" + $String.text);}\n\t|\tKeyword            {System.out.println(Indent + \"{Keyword} \\t\" + $Keyword.text);}\n\t|\tarray;\narray\t:\t'[' {System.out.println(Indent + \"Array\"); Indent += \"    \";} (value (',' value)*)? ']' {Indent = Indent.substring(4);};\n"}
{"id": 137607, "name": "JSON", "source": "Translate Fortran to Java: program json_fortran\n   use json_module\n   implicit none\n\n   type phonebook_type\n      character(len=:),allocatable :: name\n      character(len=:),allocatable :: phone\n   end type phonebook_type\n\n   type(phonebook_type), dimension(3) :: PhoneBook\n   integer :: i\n   type(json_value),pointer :: json_phonebook,p,e\n   type(json_file) :: json\n\n   PhoneBook(1) % name = 'Adam'\n   PhoneBook(2) % name = 'Eve'\n   PhoneBook(3) % name = 'Julia'\n   PhoneBook(1) % phone = '0000001'\n   PhoneBook(2) % phone = '0000002'\n   PhoneBook(3) % phone = '6666666'\n\n   call json_initialize()\n\n   \n   call json_create_object(json_phonebook,'')\n\n   \n   call json_create_array(p,'PhoneBook')\n   do i=1,3\n      call json_create_object(e,'')\n      call json_add(e,'name',PhoneBook(i)%name)\n      call json_add(e,'phone',PhoneBook(i)%phone)\n      call json_add(p,e) \n      nullify(e) \n   end do\n   call json_add(json_phonebook,p) \n   nullify(p) \n\n   \n   call json_print(json_phonebook,'phonebook.json')\n\n   \n   call json%load_from_string('{ \"PhoneBook\": [ { \"name\": \"Adam\", \"phone\": \"0000001\" },&\n   { \"name\": \"Eve\", \"phone\": \"0000002\" }, { \"name\": \"Julia\", \"phone\": \"6666666\" } ]}')\n   \n   call json%print_file()\n\nend program json_fortran\n", "target": "\n\n\n\ngrammar JSON ;\n@members {\nString Indent = \"\";\n}\nNumber\t:\t(('0')|('-'? ('1'..'9') ('0'..'9')*)) ('.' ('0'..'9')+)? (('e'|'E') ('+'|'-')? ('0'..'9')+)?;\nWS\t:\t(' ' | '\\t' | '\\r' |'\\n') {skip();};\nTz\t:\t' ' .. '!' | '#' .. '[' | ']' .. '~';\nControl\t:\t'\\\\' ('\"'|'\\\\'|'/'|'b'|'f'|'n'|'r'|'t'|UCode);\nUCode\t:\t'u' ('0'..'9'|'a'..'f'|'A'..'F') ('0'..'9'|'a'..'f'|'A'..'F') ('0'..'9'|'a'..'f'|'A'..'F') ('0'..'9'|'a'..'f'|'A'..'F');\nKeyword\t:\t'true' | 'false' | 'null';\nString\t:\t'\"' (Control? Tz)* '\"';\nobject\t:       '{' {System.out.println(Indent + \"{Object}\"); Indent += \"    \";} (pair (',' pair*)*)? '}' {Indent = Indent.substring(4);};\npair\t:\te = String {System.out.println(Indent + \"{Property}\\t\" + $e.text);} ':' value;\nvalue\t:\tNumber             {System.out.println(Indent + \"{Number}  \\t\" + $Number.text);}\n\t|\tobject\n\t|\tString             {System.out.println(Indent + \"{String}  \\t\" + $String.text);}\n\t|\tKeyword            {System.out.println(Indent + \"{Keyword} \\t\" + $Keyword.text);}\n\t|\tarray;\narray\t:\t'[' {System.out.println(Indent + \"Array\"); Indent += \"    \";} (value (',' value)*)? ']' {Indent = Indent.substring(4);};\n"}
{"id": 137608, "name": "JSON", "source": "Translate Fortran to Python: program json_fortran\n   use json_module\n   implicit none\n\n   type phonebook_type\n      character(len=:),allocatable :: name\n      character(len=:),allocatable :: phone\n   end type phonebook_type\n\n   type(phonebook_type), dimension(3) :: PhoneBook\n   integer :: i\n   type(json_value),pointer :: json_phonebook,p,e\n   type(json_file) :: json\n\n   PhoneBook(1) % name = 'Adam'\n   PhoneBook(2) % name = 'Eve'\n   PhoneBook(3) % name = 'Julia'\n   PhoneBook(1) % phone = '0000001'\n   PhoneBook(2) % phone = '0000002'\n   PhoneBook(3) % phone = '6666666'\n\n   call json_initialize()\n\n   \n   call json_create_object(json_phonebook,'')\n\n   \n   call json_create_array(p,'PhoneBook')\n   do i=1,3\n      call json_create_object(e,'')\n      call json_add(e,'name',PhoneBook(i)%name)\n      call json_add(e,'phone',PhoneBook(i)%phone)\n      call json_add(p,e) \n      nullify(e) \n   end do\n   call json_add(json_phonebook,p) \n   nullify(p) \n\n   \n   call json_print(json_phonebook,'phonebook.json')\n\n   \n   call json%load_from_string('{ \"PhoneBook\": [ { \"name\": \"Adam\", \"phone\": \"0000001\" },&\n   { \"name\": \"Eve\", \"phone\": \"0000002\" }, { \"name\": \"Julia\", \"phone\": \"6666666\" } ]}')\n   \n   call json%print_file()\n\nend program json_fortran\n", "target": ">>> import json\n>>> data = json.loads('{ \"foo\": 1, \"bar\": [10, \"apples\"] }')\n>>> sample = { \"blue\": [1,2], \"ocean\": \"water\" }\n>>> json_string = json.dumps(sample)\n>>> json_string\n'{\"blue\": [1, 2], \"ocean\": \"water\"}'\n>>> sample\n{'blue': [1, 2], 'ocean': 'water'}\n>>> data\n{'foo': 1, 'bar': [10, 'apples']}\n"}
{"id": 137609, "name": "JSON", "source": "Translate Fortran to Python: program json_fortran\n   use json_module\n   implicit none\n\n   type phonebook_type\n      character(len=:),allocatable :: name\n      character(len=:),allocatable :: phone\n   end type phonebook_type\n\n   type(phonebook_type), dimension(3) :: PhoneBook\n   integer :: i\n   type(json_value),pointer :: json_phonebook,p,e\n   type(json_file) :: json\n\n   PhoneBook(1) % name = 'Adam'\n   PhoneBook(2) % name = 'Eve'\n   PhoneBook(3) % name = 'Julia'\n   PhoneBook(1) % phone = '0000001'\n   PhoneBook(2) % phone = '0000002'\n   PhoneBook(3) % phone = '6666666'\n\n   call json_initialize()\n\n   \n   call json_create_object(json_phonebook,'')\n\n   \n   call json_create_array(p,'PhoneBook')\n   do i=1,3\n      call json_create_object(e,'')\n      call json_add(e,'name',PhoneBook(i)%name)\n      call json_add(e,'phone',PhoneBook(i)%phone)\n      call json_add(p,e) \n      nullify(e) \n   end do\n   call json_add(json_phonebook,p) \n   nullify(p) \n\n   \n   call json_print(json_phonebook,'phonebook.json')\n\n   \n   call json%load_from_string('{ \"PhoneBook\": [ { \"name\": \"Adam\", \"phone\": \"0000001\" },&\n   { \"name\": \"Eve\", \"phone\": \"0000002\" }, { \"name\": \"Julia\", \"phone\": \"6666666\" } ]}')\n   \n   call json%print_file()\n\nend program json_fortran\n", "target": ">>> import json\n>>> data = json.loads('{ \"foo\": 1, \"bar\": [10, \"apples\"] }')\n>>> sample = { \"blue\": [1,2], \"ocean\": \"water\" }\n>>> json_string = json.dumps(sample)\n>>> json_string\n'{\"blue\": [1, 2], \"ocean\": \"water\"}'\n>>> sample\n{'blue': [1, 2], 'ocean': 'water'}\n>>> data\n{'foo': 1, 'bar': [10, 'apples']}\n"}
{"id": 138048, "name": "Check that file exists", "source": "Translate Fortran to C#: LOGICAL :: file_exists\nINQUIRE(FILE=\"input.txt\", EXIST=file_exists)   \n                                               \nINQUIRE(FILE=\"/input.txt\", EXIST=file_exists)\n", "target": "using System.IO;\n\nConsole.WriteLine(File.Exists(\"input.txt\"));\nConsole.WriteLine(File.Exists(\"/input.txt\"));\nConsole.WriteLine(Directory.Exists(\"docs\"));\nConsole.WriteLine(Directory.Exists(\"/docs\"));\n"}
{"id": 138051, "name": "Check that file exists", "source": "Translate Fortran to Java: LOGICAL :: file_exists\nINQUIRE(FILE=\"input.txt\", EXIST=file_exists)   \n                                               \nINQUIRE(FILE=\"/input.txt\", EXIST=file_exists)\n", "target": "import java.io.File;\npublic class FileExistsTest {\n   public static boolean isFileExists(String filename) {\n       boolean exists = new File(filename).exists();\n       return exists;\n   }\n   public static void test(String type, String filename) {\n       System.out.println(\"The following \" + type + \" called \" + filename + \n           (isFileExists(filename) ? \" exists.\" : \" not exists.\")\n       );\n   }\n   public static void main(String args[]) {\n        test(\"file\", \"input.txt\");\n        test(\"file\", File.separator + \"input.txt\");\n        test(\"directory\", \"docs\");\n        test(\"directory\", File.separator + \"docs\" + File.separator);\n   }\n}\n"}
{"id": 138052, "name": "Check that file exists", "source": "Translate Fortran to Python: LOGICAL :: file_exists\nINQUIRE(FILE=\"input.txt\", EXIST=file_exists)   \n                                               \nINQUIRE(FILE=\"/input.txt\", EXIST=file_exists)\n", "target": "import os\n\nos.path.isfile(\"input.txt\")\nos.path.isfile(\"/input.txt\")\nos.path.isdir(\"docs\")\nos.path.isdir(\"/docs\")\n"}
{"id": 138388, "name": "Evolutionary algorithm", "source": "Translate Fortran to C#:  \n \tmodule evolve_routines\n \n \timplicit none\n \t\n \t\n \tcharacter(len=*),parameter :: targ = 'METHINKS IT IS LIKE A WEASEL'\n \t\n \tcontains\n \n \t\n \n \tpure elemental function fitness(member) result(n)\n \n \n \n \n \t\n \timplicit none\n \tinteger :: n\n \tcharacter(len=*),intent(in) :: member\n \t\n \tinteger :: i\n \t\n \tn=0\n \tdo i=1,len(targ)\n \t\tn = n + abs( ichar(targ(i:i)) - ichar(member(i:i))  )\n \tend do\n \t\n \n \tend function fitness\n \n \t\n \n \tpure elemental subroutine mutate(member,factor)\n \n \n \n \t\n \timplicit none\n \tcharacter(len=*),intent(inout) :: member   \n \treal,intent(in) :: factor                  \n \t\n \tinteger,parameter :: n_chars = 27\t\n \tcharacter(len=n_chars),parameter :: chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ '\n \t\n \treal    :: rnd_val\n \tinteger :: i,j,n\n \t\n \tn = len(member)\n \t\t\n \tdo i=1,n\n \t\trnd_val = rand()\n \t\tif (rnd_val<=factor) then   \n \t\t\trnd_val = rand()\n \t\t\tj = int(rnd_val*n_chars)+1   \n \t\t\tmember(i:i) = chars(j:j)\n \t\tend if\n \tend do\n \t\n \n\tend subroutine mutate\n \n\n \n \tend module evolve_routines\n \n \n \n \tprogram evolve\n \n \n \n \tuse evolve_routines\n \t\n \timplicit none\n \t\n \t\n \tinteger,parameter :: seed = 12345             \n \tinteger,parameter :: max_iter = 10000         \n \tinteger,parameter :: population_size = 200    \n \treal,parameter    :: factor = 0.04            \n \tinteger,parameter :: iprint = 5               \n \t\n \t\n \tinteger :: i,iter\n \tinteger,dimension(1) :: i_best\n \tcharacter(len=len(targ)),dimension(population_size) :: population\n \t\n \t\n \tcall srand(seed)\n \t\n \t\n \t\n \tpopulation(1) = 'PACQXJB CQPWEYKSVDCIOUPKUOJY'  \n \titer=0\n \t\t\n \twrite(*,'(A10,A30,A10)') 'iter','best','fitness'\n \twrite(*,'(I10,A30,I10)') iter,population(1),fitness(population(1))\n \t\t\n \tdo \n \t\n \t\titer = iter + 1 \n \t\t\n  \t\t\n \t\tif (mod(iter,iprint)==0) write(*,'(I10,A30,I10)') iter,population(1),fitness(population(1))\n\t\t\n \t\t\n \t\tif ( iter>max_iter .or. fitness(population(1))==0 ) exit\n \t\n \t\t\n \t\tpopulation = population(1)\t\n \t\tdo i=2,population_size\n \t\t\tcall mutate(population(i),factor)\t\n \t\tend do\n \t\n \t\t\n \t\t\n \t\ti_best = minloc(fitness(population))\n \t\tpopulation(1) = population(i_best(1))\n \t\t \t\n \tend do\n \t\n \t\n \tif (mod(iter,iprint)/=0) write(*,'(I10,A30,I10)') iter,population(1),fitness(population(1))\n \t \t\n \tif (iter>max_iter) then\n \t\twrite(*,*) 'No solution found.'\n \telse\n \t\twrite(*,*) 'Solution found.'\n \tend if\n \t\n \n \tend program evolve\n \n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\nstatic class Program {\n    static Random Rng = new Random((int)DateTime.Now.Ticks);\n\n    static char NextCharacter(this Random self) {\n        const string AllowedChars = \" ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n        return AllowedChars[self.Next() % AllowedChars.Length];\n    }\n\n    static string NextString(this Random self, int length) {\n        return String.Join(\"\", Enumerable.Repeat(' ', length)\n            .Select(c => Rng.NextCharacter()));\n    }\n\n    static int Fitness(string target, string current) {\n        return target.Zip(current, (a, b) => a == b ? 1 : 0).Sum();\n    }\n\n    static string Mutate(string current, double rate) {\n        return String.Join(\"\", from c in current\n               select Rng.NextDouble() <= rate ? Rng.NextCharacter() : c);\n    }\n\n    static void Main(string[] args) {\n        const string target = \"METHINKS IT IS LIKE A WEASEL\";\n        const int C = 100;\n        const double P = 0.05;\n\n        \n        string parent = Rng.NextString(target.Length);\n\n        Console.WriteLine(\"START:       {0,20} fitness: {1}\", \n            parent, Fitness(target, parent));\n        int i = 0;\n\n        while (parent != target) {\n            \n            var candidates = Enumerable.Range(0, C + 1)\n                .Select(n => n > 0 ? Mutate(parent, P) : parent);\n\n            \n            parent = candidates.OrderByDescending(c => Fitness(target, c)).First();\n\n            ++i;\n            Console.WriteLine(\"     #{0,6} {1,20} fitness: {2}\", \n                i, parent, Fitness(target, parent));\n        }\n\n        Console.WriteLine(\"END: #{0,6} {1,20}\", i, parent);\n    }\n}\n"}
{"id": 138389, "name": "Evolutionary algorithm", "source": "Translate Fortran to C#:  \n \tmodule evolve_routines\n \n \timplicit none\n \t\n \t\n \tcharacter(len=*),parameter :: targ = 'METHINKS IT IS LIKE A WEASEL'\n \t\n \tcontains\n \n \t\n \n \tpure elemental function fitness(member) result(n)\n \n \n \n \n \t\n \timplicit none\n \tinteger :: n\n \tcharacter(len=*),intent(in) :: member\n \t\n \tinteger :: i\n \t\n \tn=0\n \tdo i=1,len(targ)\n \t\tn = n + abs( ichar(targ(i:i)) - ichar(member(i:i))  )\n \tend do\n \t\n \n \tend function fitness\n \n \t\n \n \tpure elemental subroutine mutate(member,factor)\n \n \n \n \t\n \timplicit none\n \tcharacter(len=*),intent(inout) :: member   \n \treal,intent(in) :: factor                  \n \t\n \tinteger,parameter :: n_chars = 27\t\n \tcharacter(len=n_chars),parameter :: chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ '\n \t\n \treal    :: rnd_val\n \tinteger :: i,j,n\n \t\n \tn = len(member)\n \t\t\n \tdo i=1,n\n \t\trnd_val = rand()\n \t\tif (rnd_val<=factor) then   \n \t\t\trnd_val = rand()\n \t\t\tj = int(rnd_val*n_chars)+1   \n \t\t\tmember(i:i) = chars(j:j)\n \t\tend if\n \tend do\n \t\n \n\tend subroutine mutate\n \n\n \n \tend module evolve_routines\n \n \n \n \tprogram evolve\n \n \n \n \tuse evolve_routines\n \t\n \timplicit none\n \t\n \t\n \tinteger,parameter :: seed = 12345             \n \tinteger,parameter :: max_iter = 10000         \n \tinteger,parameter :: population_size = 200    \n \treal,parameter    :: factor = 0.04            \n \tinteger,parameter :: iprint = 5               \n \t\n \t\n \tinteger :: i,iter\n \tinteger,dimension(1) :: i_best\n \tcharacter(len=len(targ)),dimension(population_size) :: population\n \t\n \t\n \tcall srand(seed)\n \t\n \t\n \t\n \tpopulation(1) = 'PACQXJB CQPWEYKSVDCIOUPKUOJY'  \n \titer=0\n \t\t\n \twrite(*,'(A10,A30,A10)') 'iter','best','fitness'\n \twrite(*,'(I10,A30,I10)') iter,population(1),fitness(population(1))\n \t\t\n \tdo \n \t\n \t\titer = iter + 1 \n \t\t\n  \t\t\n \t\tif (mod(iter,iprint)==0) write(*,'(I10,A30,I10)') iter,population(1),fitness(population(1))\n\t\t\n \t\t\n \t\tif ( iter>max_iter .or. fitness(population(1))==0 ) exit\n \t\n \t\t\n \t\tpopulation = population(1)\t\n \t\tdo i=2,population_size\n \t\t\tcall mutate(population(i),factor)\t\n \t\tend do\n \t\n \t\t\n \t\t\n \t\ti_best = minloc(fitness(population))\n \t\tpopulation(1) = population(i_best(1))\n \t\t \t\n \tend do\n \t\n \t\n \tif (mod(iter,iprint)/=0) write(*,'(I10,A30,I10)') iter,population(1),fitness(population(1))\n \t \t\n \tif (iter>max_iter) then\n \t\twrite(*,*) 'No solution found.'\n \telse\n \t\twrite(*,*) 'Solution found.'\n \tend if\n \t\n \n \tend program evolve\n \n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\nstatic class Program {\n    static Random Rng = new Random((int)DateTime.Now.Ticks);\n\n    static char NextCharacter(this Random self) {\n        const string AllowedChars = \" ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n        return AllowedChars[self.Next() % AllowedChars.Length];\n    }\n\n    static string NextString(this Random self, int length) {\n        return String.Join(\"\", Enumerable.Repeat(' ', length)\n            .Select(c => Rng.NextCharacter()));\n    }\n\n    static int Fitness(string target, string current) {\n        return target.Zip(current, (a, b) => a == b ? 1 : 0).Sum();\n    }\n\n    static string Mutate(string current, double rate) {\n        return String.Join(\"\", from c in current\n               select Rng.NextDouble() <= rate ? Rng.NextCharacter() : c);\n    }\n\n    static void Main(string[] args) {\n        const string target = \"METHINKS IT IS LIKE A WEASEL\";\n        const int C = 100;\n        const double P = 0.05;\n\n        \n        string parent = Rng.NextString(target.Length);\n\n        Console.WriteLine(\"START:       {0,20} fitness: {1}\", \n            parent, Fitness(target, parent));\n        int i = 0;\n\n        while (parent != target) {\n            \n            var candidates = Enumerable.Range(0, C + 1)\n                .Select(n => n > 0 ? Mutate(parent, P) : parent);\n\n            \n            parent = candidates.OrderByDescending(c => Fitness(target, c)).First();\n\n            ++i;\n            Console.WriteLine(\"     #{0,6} {1,20} fitness: {2}\", \n                i, parent, Fitness(target, parent));\n        }\n\n        Console.WriteLine(\"END: #{0,6} {1,20}\", i, parent);\n    }\n}\n"}
{"id": 138394, "name": "Evolutionary algorithm", "source": "Translate Fortran to Java:  \n \tmodule evolve_routines\n \n \timplicit none\n \t\n \t\n \tcharacter(len=*),parameter :: targ = 'METHINKS IT IS LIKE A WEASEL'\n \t\n \tcontains\n \n \t\n \n \tpure elemental function fitness(member) result(n)\n \n \n \n \n \t\n \timplicit none\n \tinteger :: n\n \tcharacter(len=*),intent(in) :: member\n \t\n \tinteger :: i\n \t\n \tn=0\n \tdo i=1,len(targ)\n \t\tn = n + abs( ichar(targ(i:i)) - ichar(member(i:i))  )\n \tend do\n \t\n \n \tend function fitness\n \n \t\n \n \tpure elemental subroutine mutate(member,factor)\n \n \n \n \t\n \timplicit none\n \tcharacter(len=*),intent(inout) :: member   \n \treal,intent(in) :: factor                  \n \t\n \tinteger,parameter :: n_chars = 27\t\n \tcharacter(len=n_chars),parameter :: chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ '\n \t\n \treal    :: rnd_val\n \tinteger :: i,j,n\n \t\n \tn = len(member)\n \t\t\n \tdo i=1,n\n \t\trnd_val = rand()\n \t\tif (rnd_val<=factor) then   \n \t\t\trnd_val = rand()\n \t\t\tj = int(rnd_val*n_chars)+1   \n \t\t\tmember(i:i) = chars(j:j)\n \t\tend if\n \tend do\n \t\n \n\tend subroutine mutate\n \n\n \n \tend module evolve_routines\n \n \n \n \tprogram evolve\n \n \n \n \tuse evolve_routines\n \t\n \timplicit none\n \t\n \t\n \tinteger,parameter :: seed = 12345             \n \tinteger,parameter :: max_iter = 10000         \n \tinteger,parameter :: population_size = 200    \n \treal,parameter    :: factor = 0.04            \n \tinteger,parameter :: iprint = 5               \n \t\n \t\n \tinteger :: i,iter\n \tinteger,dimension(1) :: i_best\n \tcharacter(len=len(targ)),dimension(population_size) :: population\n \t\n \t\n \tcall srand(seed)\n \t\n \t\n \t\n \tpopulation(1) = 'PACQXJB CQPWEYKSVDCIOUPKUOJY'  \n \titer=0\n \t\t\n \twrite(*,'(A10,A30,A10)') 'iter','best','fitness'\n \twrite(*,'(I10,A30,I10)') iter,population(1),fitness(population(1))\n \t\t\n \tdo \n \t\n \t\titer = iter + 1 \n \t\t\n  \t\t\n \t\tif (mod(iter,iprint)==0) write(*,'(I10,A30,I10)') iter,population(1),fitness(population(1))\n\t\t\n \t\t\n \t\tif ( iter>max_iter .or. fitness(population(1))==0 ) exit\n \t\n \t\t\n \t\tpopulation = population(1)\t\n \t\tdo i=2,population_size\n \t\t\tcall mutate(population(i),factor)\t\n \t\tend do\n \t\n \t\t\n \t\t\n \t\ti_best = minloc(fitness(population))\n \t\tpopulation(1) = population(i_best(1))\n \t\t \t\n \tend do\n \t\n \t\n \tif (mod(iter,iprint)/=0) write(*,'(I10,A30,I10)') iter,population(1),fitness(population(1))\n \t \t\n \tif (iter>max_iter) then\n \t\twrite(*,*) 'No solution found.'\n \telse\n \t\twrite(*,*) 'Solution found.'\n \tend if\n \t\n \n \tend program evolve\n \n", "target": "import java.util.Random;\n\npublic class EvoAlgo {\n  static final String target = \"METHINKS IT IS LIKE A WEASEL\";\n  static final char[] possibilities = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ \".toCharArray();\n  static int C = 100; \n  static double minMutateRate = 0.09;\n  static int perfectFitness = target.length();\n  private static String parent;\n  static Random rand = new Random();\n\n  private static int fitness(String trial){\n    int retVal = 0;\n    for(int i = 0;i < trial.length(); i++){\n      if (trial.charAt(i) == target.charAt(i)) retVal++;\n    }\n    return retVal;\n  }\n\n  private static double newMutateRate(){\n    return (((double)perfectFitness - fitness(parent)) / perfectFitness * (1 - minMutateRate));\n  }\n\n  private static String mutate(String parent, double rate){\n    String retVal = \"\";\n    for(int i = 0;i < parent.length(); i++){\n      retVal += (rand.nextDouble() <= rate) ?\n        possibilities[rand.nextInt(possibilities.length)]:\n        parent.charAt(i);\n    }\n    return retVal;\n  }\n  \n  public static void main(String[] args){\n    parent = mutate(target, 1);\n    int iter = 0;\n    while(!target.equals(parent)){\n      double rate = newMutateRate();\n      iter++;\n      if(iter % 100 == 0){\n        System.out.println(iter +\": \"+parent+ \", fitness: \"+fitness(parent)+\", rate: \"+rate);\n      }\n      String bestSpawn = null;\n      int bestFit = 0;\n      for(int i = 0; i < C; i++){\n        String spawn = mutate(parent, rate);\n        int fitness = fitness(spawn);\n        if(fitness > bestFit){\n          bestSpawn = spawn;\n          bestFit = fitness;\n        }\n      }\n      parent = bestFit > fitness(parent) ? bestSpawn : parent;\n    }\n    System.out.println(parent+\", \"+iter);\n  }\n\n}\n"}
{"id": 138395, "name": "Evolutionary algorithm", "source": "Translate Fortran to Java:  \n \tmodule evolve_routines\n \n \timplicit none\n \t\n \t\n \tcharacter(len=*),parameter :: targ = 'METHINKS IT IS LIKE A WEASEL'\n \t\n \tcontains\n \n \t\n \n \tpure elemental function fitness(member) result(n)\n \n \n \n \n \t\n \timplicit none\n \tinteger :: n\n \tcharacter(len=*),intent(in) :: member\n \t\n \tinteger :: i\n \t\n \tn=0\n \tdo i=1,len(targ)\n \t\tn = n + abs( ichar(targ(i:i)) - ichar(member(i:i))  )\n \tend do\n \t\n \n \tend function fitness\n \n \t\n \n \tpure elemental subroutine mutate(member,factor)\n \n \n \n \t\n \timplicit none\n \tcharacter(len=*),intent(inout) :: member   \n \treal,intent(in) :: factor                  \n \t\n \tinteger,parameter :: n_chars = 27\t\n \tcharacter(len=n_chars),parameter :: chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ '\n \t\n \treal    :: rnd_val\n \tinteger :: i,j,n\n \t\n \tn = len(member)\n \t\t\n \tdo i=1,n\n \t\trnd_val = rand()\n \t\tif (rnd_val<=factor) then   \n \t\t\trnd_val = rand()\n \t\t\tj = int(rnd_val*n_chars)+1   \n \t\t\tmember(i:i) = chars(j:j)\n \t\tend if\n \tend do\n \t\n \n\tend subroutine mutate\n \n\n \n \tend module evolve_routines\n \n \n \n \tprogram evolve\n \n \n \n \tuse evolve_routines\n \t\n \timplicit none\n \t\n \t\n \tinteger,parameter :: seed = 12345             \n \tinteger,parameter :: max_iter = 10000         \n \tinteger,parameter :: population_size = 200    \n \treal,parameter    :: factor = 0.04            \n \tinteger,parameter :: iprint = 5               \n \t\n \t\n \tinteger :: i,iter\n \tinteger,dimension(1) :: i_best\n \tcharacter(len=len(targ)),dimension(population_size) :: population\n \t\n \t\n \tcall srand(seed)\n \t\n \t\n \t\n \tpopulation(1) = 'PACQXJB CQPWEYKSVDCIOUPKUOJY'  \n \titer=0\n \t\t\n \twrite(*,'(A10,A30,A10)') 'iter','best','fitness'\n \twrite(*,'(I10,A30,I10)') iter,population(1),fitness(population(1))\n \t\t\n \tdo \n \t\n \t\titer = iter + 1 \n \t\t\n  \t\t\n \t\tif (mod(iter,iprint)==0) write(*,'(I10,A30,I10)') iter,population(1),fitness(population(1))\n\t\t\n \t\t\n \t\tif ( iter>max_iter .or. fitness(population(1))==0 ) exit\n \t\n \t\t\n \t\tpopulation = population(1)\t\n \t\tdo i=2,population_size\n \t\t\tcall mutate(population(i),factor)\t\n \t\tend do\n \t\n \t\t\n \t\t\n \t\ti_best = minloc(fitness(population))\n \t\tpopulation(1) = population(i_best(1))\n \t\t \t\n \tend do\n \t\n \t\n \tif (mod(iter,iprint)/=0) write(*,'(I10,A30,I10)') iter,population(1),fitness(population(1))\n \t \t\n \tif (iter>max_iter) then\n \t\twrite(*,*) 'No solution found.'\n \telse\n \t\twrite(*,*) 'Solution found.'\n \tend if\n \t\n \n \tend program evolve\n \n", "target": "import java.util.Random;\n\npublic class EvoAlgo {\n  static final String target = \"METHINKS IT IS LIKE A WEASEL\";\n  static final char[] possibilities = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ \".toCharArray();\n  static int C = 100; \n  static double minMutateRate = 0.09;\n  static int perfectFitness = target.length();\n  private static String parent;\n  static Random rand = new Random();\n\n  private static int fitness(String trial){\n    int retVal = 0;\n    for(int i = 0;i < trial.length(); i++){\n      if (trial.charAt(i) == target.charAt(i)) retVal++;\n    }\n    return retVal;\n  }\n\n  private static double newMutateRate(){\n    return (((double)perfectFitness - fitness(parent)) / perfectFitness * (1 - minMutateRate));\n  }\n\n  private static String mutate(String parent, double rate){\n    String retVal = \"\";\n    for(int i = 0;i < parent.length(); i++){\n      retVal += (rand.nextDouble() <= rate) ?\n        possibilities[rand.nextInt(possibilities.length)]:\n        parent.charAt(i);\n    }\n    return retVal;\n  }\n  \n  public static void main(String[] args){\n    parent = mutate(target, 1);\n    int iter = 0;\n    while(!target.equals(parent)){\n      double rate = newMutateRate();\n      iter++;\n      if(iter % 100 == 0){\n        System.out.println(iter +\": \"+parent+ \", fitness: \"+fitness(parent)+\", rate: \"+rate);\n      }\n      String bestSpawn = null;\n      int bestFit = 0;\n      for(int i = 0; i < C; i++){\n        String spawn = mutate(parent, rate);\n        int fitness = fitness(spawn);\n        if(fitness > bestFit){\n          bestSpawn = spawn;\n          bestFit = fitness;\n        }\n      }\n      parent = bestFit > fitness(parent) ? bestSpawn : parent;\n    }\n    System.out.println(parent+\", \"+iter);\n  }\n\n}\n"}
{"id": 138396, "name": "Evolutionary algorithm", "source": "Translate Fortran to Python:  \n \tmodule evolve_routines\n \n \timplicit none\n \t\n \t\n \tcharacter(len=*),parameter :: targ = 'METHINKS IT IS LIKE A WEASEL'\n \t\n \tcontains\n \n \t\n \n \tpure elemental function fitness(member) result(n)\n \n \n \n \n \t\n \timplicit none\n \tinteger :: n\n \tcharacter(len=*),intent(in) :: member\n \t\n \tinteger :: i\n \t\n \tn=0\n \tdo i=1,len(targ)\n \t\tn = n + abs( ichar(targ(i:i)) - ichar(member(i:i))  )\n \tend do\n \t\n \n \tend function fitness\n \n \t\n \n \tpure elemental subroutine mutate(member,factor)\n \n \n \n \t\n \timplicit none\n \tcharacter(len=*),intent(inout) :: member   \n \treal,intent(in) :: factor                  \n \t\n \tinteger,parameter :: n_chars = 27\t\n \tcharacter(len=n_chars),parameter :: chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ '\n \t\n \treal    :: rnd_val\n \tinteger :: i,j,n\n \t\n \tn = len(member)\n \t\t\n \tdo i=1,n\n \t\trnd_val = rand()\n \t\tif (rnd_val<=factor) then   \n \t\t\trnd_val = rand()\n \t\t\tj = int(rnd_val*n_chars)+1   \n \t\t\tmember(i:i) = chars(j:j)\n \t\tend if\n \tend do\n \t\n \n\tend subroutine mutate\n \n\n \n \tend module evolve_routines\n \n \n \n \tprogram evolve\n \n \n \n \tuse evolve_routines\n \t\n \timplicit none\n \t\n \t\n \tinteger,parameter :: seed = 12345             \n \tinteger,parameter :: max_iter = 10000         \n \tinteger,parameter :: population_size = 200    \n \treal,parameter    :: factor = 0.04            \n \tinteger,parameter :: iprint = 5               \n \t\n \t\n \tinteger :: i,iter\n \tinteger,dimension(1) :: i_best\n \tcharacter(len=len(targ)),dimension(population_size) :: population\n \t\n \t\n \tcall srand(seed)\n \t\n \t\n \t\n \tpopulation(1) = 'PACQXJB CQPWEYKSVDCIOUPKUOJY'  \n \titer=0\n \t\t\n \twrite(*,'(A10,A30,A10)') 'iter','best','fitness'\n \twrite(*,'(I10,A30,I10)') iter,population(1),fitness(population(1))\n \t\t\n \tdo \n \t\n \t\titer = iter + 1 \n \t\t\n  \t\t\n \t\tif (mod(iter,iprint)==0) write(*,'(I10,A30,I10)') iter,population(1),fitness(population(1))\n\t\t\n \t\t\n \t\tif ( iter>max_iter .or. fitness(population(1))==0 ) exit\n \t\n \t\t\n \t\tpopulation = population(1)\t\n \t\tdo i=2,population_size\n \t\t\tcall mutate(population(i),factor)\t\n \t\tend do\n \t\n \t\t\n \t\t\n \t\ti_best = minloc(fitness(population))\n \t\tpopulation(1) = population(i_best(1))\n \t\t \t\n \tend do\n \t\n \t\n \tif (mod(iter,iprint)/=0) write(*,'(I10,A30,I10)') iter,population(1),fitness(population(1))\n \t \t\n \tif (iter>max_iter) then\n \t\twrite(*,*) 'No solution found.'\n \telse\n \t\twrite(*,*) 'Solution found.'\n \tend if\n \t\n \n \tend program evolve\n \n", "target": "from string import letters\nfrom random import choice, random\n \ntarget  = list(\"METHINKS IT IS LIKE A WEASEL\")\ncharset = letters + ' '\nparent  = [choice(charset) for _ in range(len(target))]\nminmutaterate  = .09\nC = range(100)\n \nperfectfitness = float(len(target))\n    \ndef fitness(trial):\n    'Sum of matching chars by position'\n    return sum(t==h for t,h in zip(trial, target))\n \ndef mutaterate():\n    'Less mutation the closer the fit of the parent'\n    return 1-((perfectfitness - fitness(parent)) / perfectfitness * (1 - minmutaterate))\n \ndef mutate(parent, rate):\n    return [(ch if random() <= rate else choice(charset)) for ch in parent]\n \ndef que():\n    '(from the favourite saying of Manuel in Fawlty Towers)'\n    print (\"\n           (iterations, fitness(parent)*100./perfectfitness, ''.join(parent)))\n\ndef mate(a, b):\n    place = 0\n    if choice(xrange(10)) < 7:\n        place = choice(xrange(len(target)))\n    else:\n        return a, b\n    \n    return a, b, a[:place] + b[place:], b[:place] + a[place:]\n\niterations = 0\ncenter = len(C)/2\nwhile parent != target:\n    rate = mutaterate()\n    iterations += 1\n    if iterations % 100 == 0: que()\n    copies = [ mutate(parent, rate) for _ in C ]  + [parent]\n    parent1 = max(copies[:center], key=fitness)\n    parent2 = max(copies[center:], key=fitness)\n    parent = max(mate(parent1, parent2), key=fitness)\nque()\n"}
{"id": 138397, "name": "Evolutionary algorithm", "source": "Translate Fortran to Python:  \n \tmodule evolve_routines\n \n \timplicit none\n \t\n \t\n \tcharacter(len=*),parameter :: targ = 'METHINKS IT IS LIKE A WEASEL'\n \t\n \tcontains\n \n \t\n \n \tpure elemental function fitness(member) result(n)\n \n \n \n \n \t\n \timplicit none\n \tinteger :: n\n \tcharacter(len=*),intent(in) :: member\n \t\n \tinteger :: i\n \t\n \tn=0\n \tdo i=1,len(targ)\n \t\tn = n + abs( ichar(targ(i:i)) - ichar(member(i:i))  )\n \tend do\n \t\n \n \tend function fitness\n \n \t\n \n \tpure elemental subroutine mutate(member,factor)\n \n \n \n \t\n \timplicit none\n \tcharacter(len=*),intent(inout) :: member   \n \treal,intent(in) :: factor                  \n \t\n \tinteger,parameter :: n_chars = 27\t\n \tcharacter(len=n_chars),parameter :: chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ '\n \t\n \treal    :: rnd_val\n \tinteger :: i,j,n\n \t\n \tn = len(member)\n \t\t\n \tdo i=1,n\n \t\trnd_val = rand()\n \t\tif (rnd_val<=factor) then   \n \t\t\trnd_val = rand()\n \t\t\tj = int(rnd_val*n_chars)+1   \n \t\t\tmember(i:i) = chars(j:j)\n \t\tend if\n \tend do\n \t\n \n\tend subroutine mutate\n \n\n \n \tend module evolve_routines\n \n \n \n \tprogram evolve\n \n \n \n \tuse evolve_routines\n \t\n \timplicit none\n \t\n \t\n \tinteger,parameter :: seed = 12345             \n \tinteger,parameter :: max_iter = 10000         \n \tinteger,parameter :: population_size = 200    \n \treal,parameter    :: factor = 0.04            \n \tinteger,parameter :: iprint = 5               \n \t\n \t\n \tinteger :: i,iter\n \tinteger,dimension(1) :: i_best\n \tcharacter(len=len(targ)),dimension(population_size) :: population\n \t\n \t\n \tcall srand(seed)\n \t\n \t\n \t\n \tpopulation(1) = 'PACQXJB CQPWEYKSVDCIOUPKUOJY'  \n \titer=0\n \t\t\n \twrite(*,'(A10,A30,A10)') 'iter','best','fitness'\n \twrite(*,'(I10,A30,I10)') iter,population(1),fitness(population(1))\n \t\t\n \tdo \n \t\n \t\titer = iter + 1 \n \t\t\n  \t\t\n \t\tif (mod(iter,iprint)==0) write(*,'(I10,A30,I10)') iter,population(1),fitness(population(1))\n\t\t\n \t\t\n \t\tif ( iter>max_iter .or. fitness(population(1))==0 ) exit\n \t\n \t\t\n \t\tpopulation = population(1)\t\n \t\tdo i=2,population_size\n \t\t\tcall mutate(population(i),factor)\t\n \t\tend do\n \t\n \t\t\n \t\t\n \t\ti_best = minloc(fitness(population))\n \t\tpopulation(1) = population(i_best(1))\n \t\t \t\n \tend do\n \t\n \t\n \tif (mod(iter,iprint)/=0) write(*,'(I10,A30,I10)') iter,population(1),fitness(population(1))\n \t \t\n \tif (iter>max_iter) then\n \t\twrite(*,*) 'No solution found.'\n \telse\n \t\twrite(*,*) 'Solution found.'\n \tend if\n \t\n \n \tend program evolve\n \n", "target": "from string import letters\nfrom random import choice, random\n \ntarget  = list(\"METHINKS IT IS LIKE A WEASEL\")\ncharset = letters + ' '\nparent  = [choice(charset) for _ in range(len(target))]\nminmutaterate  = .09\nC = range(100)\n \nperfectfitness = float(len(target))\n    \ndef fitness(trial):\n    'Sum of matching chars by position'\n    return sum(t==h for t,h in zip(trial, target))\n \ndef mutaterate():\n    'Less mutation the closer the fit of the parent'\n    return 1-((perfectfitness - fitness(parent)) / perfectfitness * (1 - minmutaterate))\n \ndef mutate(parent, rate):\n    return [(ch if random() <= rate else choice(charset)) for ch in parent]\n \ndef que():\n    '(from the favourite saying of Manuel in Fawlty Towers)'\n    print (\"\n           (iterations, fitness(parent)*100./perfectfitness, ''.join(parent)))\n\ndef mate(a, b):\n    place = 0\n    if choice(xrange(10)) < 7:\n        place = choice(xrange(len(target)))\n    else:\n        return a, b\n    \n    return a, b, a[:place] + b[place:], b[:place] + a[place:]\n\niterations = 0\ncenter = len(C)/2\nwhile parent != target:\n    rate = mutaterate()\n    iterations += 1\n    if iterations % 100 == 0: que()\n    copies = [ mutate(parent, rate) for _ in C ]  + [parent]\n    parent1 = max(copies[:center], key=fitness)\n    parent2 = max(copies[center:], key=fitness)\n    parent = max(mate(parent1, parent2), key=fitness)\nque()\n"}
{"id": 139034, "name": "Ordered words", "source": "Translate Fortran to C#: \n module ordered_module\n\n implicit none \n\n\t\n\tinteger,parameter :: file_unit = 1000\n\tcharacter(len=*),parameter :: filename = 'unixdict.txt'\n\n\t\n\tinteger,parameter :: max_chars = 50\n\n\ttype word \n\t  character(len=max_chars) :: str    \n\t  integer\t:: n = 0    \n\t  logical\t:: ordered = .false.    \n\tend type word\n \n\t\n\ttype(word),dimension(:),allocatable :: dict\n \n\tcontains\n\n \n\t\n\t\tfunction count_lines_in_file(fid) result(n_lines)\n\t\n\t\timplicit none\n \n\t\tinteger             :: n_lines\n\t\tinteger,intent(in)  :: fid\t\t\n\t\tcharacter(len=1)    :: tmp\n\t\tinteger             :: i\n\t\tinteger             :: ios\n \n\t\t\n \n\t\trewind(fid)\t  \n \n\t\tn_lines = 0\n\t\tdo \n\t\t\tread(fid,'(A1)',iostat=ios) tmp\n\t\t\tif (ios < 0) exit      \n\t\t\tn_lines = n_lines + 1  \n\t\tend do\n \n\t\trewind(fid)   \n \n\t\n\t\tend function count_lines_in_file\n\t\n\n\t\n\t pure elemental function ordered_word(word) result(yn)\n\t\n\t\n\t\n\t \n\t implicit none\n\t character(len=*),intent(in) :: word\n\t logical :: yn\n\t \n\t integer :: i\n\t \n\t yn = .true.\n\t do i=1,len_trim(word)-1\n\t \tif (ichar(word(i+1:i+1))<ichar(word(i:i))) then\n\t \t\tyn = .false.\n\t \t\texit\n\t \tend if\n\t end do\n\t \n\t\n\t end function ordered_word\n\t\n \n\n end module ordered_module\n\n\n\n program main\n\n use ordered_module\n implicit none\n\n\tinteger :: i,n,n_max\n \n\t\n\topen(unit=file_unit,file=filename)     \t\t\n\tn = count_lines_in_file(file_unit)      \n\tallocate(dict(n))                       \n\tdo i=1,n                                \n\t\tread(file_unit,'(A)') dict(i)%str   \n\t\tdict(i)%n = len_trim(dict(i)%str)   \n\tend do\t\t\n\tclose(file_unit)                        \n\n\t\n\tdict%ordered = ordered_word(dict%str)\t\n\n\t\n\tn_max = maxval(dict%n, mask=dict%ordered)\n\t\t\n\t\n\tdo i=1,n\n\t\tif (dict(i)%ordered .and. dict(i)%n==n_max) write(*,'(A,A)',advance='NO') trim(dict(i)%str),' '\n\tend do\n\twrite(*,*) ''\n\n\n end program main\n\n", "target": "using System;\nusing System.Linq;\nusing System.Net;\n\nstatic class Program\n{\n    static void Main(string[] args)\n    {\n        WebClient client = new WebClient();\n        string text = client.DownloadString(\"http:\n        string[] words = text.Split(new char[] { '\\r', '\\n' }, StringSplitOptions.RemoveEmptyEntries);\n\n        var query = from w in words\n                    where IsOrderedWord(w)\n                    group w by w.Length into ows\n                    orderby ows.Key descending\n                    select ows;\n\n        Console.WriteLine(string.Join(\", \", query.First().ToArray()));\n    }\n\n    private static bool IsOrderedWord(string w)\n    {\n        for (int i = 1; i < w.Length; i++)\n            if (w[i] < w[i - 1])\n                return false;\n\n        return true;\n    }\n}\n"}
{"id": 139037, "name": "Ordered words", "source": "Translate Fortran to Java: \n module ordered_module\n\n implicit none \n\n\t\n\tinteger,parameter :: file_unit = 1000\n\tcharacter(len=*),parameter :: filename = 'unixdict.txt'\n\n\t\n\tinteger,parameter :: max_chars = 50\n\n\ttype word \n\t  character(len=max_chars) :: str    \n\t  integer\t:: n = 0    \n\t  logical\t:: ordered = .false.    \n\tend type word\n \n\t\n\ttype(word),dimension(:),allocatable :: dict\n \n\tcontains\n\n \n\t\n\t\tfunction count_lines_in_file(fid) result(n_lines)\n\t\n\t\timplicit none\n \n\t\tinteger             :: n_lines\n\t\tinteger,intent(in)  :: fid\t\t\n\t\tcharacter(len=1)    :: tmp\n\t\tinteger             :: i\n\t\tinteger             :: ios\n \n\t\t\n \n\t\trewind(fid)\t  \n \n\t\tn_lines = 0\n\t\tdo \n\t\t\tread(fid,'(A1)',iostat=ios) tmp\n\t\t\tif (ios < 0) exit      \n\t\t\tn_lines = n_lines + 1  \n\t\tend do\n \n\t\trewind(fid)   \n \n\t\n\t\tend function count_lines_in_file\n\t\n\n\t\n\t pure elemental function ordered_word(word) result(yn)\n\t\n\t\n\t\n\t \n\t implicit none\n\t character(len=*),intent(in) :: word\n\t logical :: yn\n\t \n\t integer :: i\n\t \n\t yn = .true.\n\t do i=1,len_trim(word)-1\n\t \tif (ichar(word(i+1:i+1))<ichar(word(i:i))) then\n\t \t\tyn = .false.\n\t \t\texit\n\t \tend if\n\t end do\n\t \n\t\n\t end function ordered_word\n\t\n \n\n end module ordered_module\n\n\n\n program main\n\n use ordered_module\n implicit none\n\n\tinteger :: i,n,n_max\n \n\t\n\topen(unit=file_unit,file=filename)     \t\t\n\tn = count_lines_in_file(file_unit)      \n\tallocate(dict(n))                       \n\tdo i=1,n                                \n\t\tread(file_unit,'(A)') dict(i)%str   \n\t\tdict(i)%n = len_trim(dict(i)%str)   \n\tend do\t\t\n\tclose(file_unit)                        \n\n\t\n\tdict%ordered = ordered_word(dict%str)\t\n\n\t\n\tn_max = maxval(dict%n, mask=dict%ordered)\n\t\t\n\t\n\tdo i=1,n\n\t\tif (dict(i)%ordered .and. dict(i)%n==n_max) write(*,'(A,A)',advance='NO') trim(dict(i)%str),' '\n\tend do\n\twrite(*,*) ''\n\n\n end program main\n\n", "target": "import java.io.BufferedReader;\nimport java.io.FileReader;\nimport java.io.IOException;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.LinkedList;\nimport java.util.List;\n\npublic class Ordered {\n\n\tprivate static boolean isOrderedWord(String word){\n\t\tchar[] sortedWord = word.toCharArray();\n\t\tArrays.sort(sortedWord);\n\t\treturn word.equals(new String(sortedWord));\n\t}\n\t\n\tpublic static void main(String[] args) throws IOException{\n\t\tList<String> orderedWords = new LinkedList<String>();\n\t\tBufferedReader in = new BufferedReader(new FileReader(args[0]));\n\t\twhile(in.ready()){\n\t\t\tString word = in.readLine();\n\t\t\tif(isOrderedWord(word)) orderedWords.add(word);\n\t\t}\n\t\tin.close();\n\t\t\n\t\tCollections.<String>sort(orderedWords, new Comparator<String>() {\n\t\t\t@Override\n\t\t\tpublic int compare(String o1, String o2) {\n\t\t\t\treturn new Integer(o2.length()).compareTo(o1.length());\n\t\t\t}\n\t\t});\n\t\t\n\t\tint maxLen = orderedWords.get(0).length();\n\t\tfor(String word: orderedWords){\n\t\t\tif(word.length() == maxLen){\n\t\t\t\tSystem.out.println(word);\n\t\t\t}else{\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}\n"}
{"id": 139038, "name": "Ordered words", "source": "Translate Fortran to Python: \n module ordered_module\n\n implicit none \n\n\t\n\tinteger,parameter :: file_unit = 1000\n\tcharacter(len=*),parameter :: filename = 'unixdict.txt'\n\n\t\n\tinteger,parameter :: max_chars = 50\n\n\ttype word \n\t  character(len=max_chars) :: str    \n\t  integer\t:: n = 0    \n\t  logical\t:: ordered = .false.    \n\tend type word\n \n\t\n\ttype(word),dimension(:),allocatable :: dict\n \n\tcontains\n\n \n\t\n\t\tfunction count_lines_in_file(fid) result(n_lines)\n\t\n\t\timplicit none\n \n\t\tinteger             :: n_lines\n\t\tinteger,intent(in)  :: fid\t\t\n\t\tcharacter(len=1)    :: tmp\n\t\tinteger             :: i\n\t\tinteger             :: ios\n \n\t\t\n \n\t\trewind(fid)\t  \n \n\t\tn_lines = 0\n\t\tdo \n\t\t\tread(fid,'(A1)',iostat=ios) tmp\n\t\t\tif (ios < 0) exit      \n\t\t\tn_lines = n_lines + 1  \n\t\tend do\n \n\t\trewind(fid)   \n \n\t\n\t\tend function count_lines_in_file\n\t\n\n\t\n\t pure elemental function ordered_word(word) result(yn)\n\t\n\t\n\t\n\t \n\t implicit none\n\t character(len=*),intent(in) :: word\n\t logical :: yn\n\t \n\t integer :: i\n\t \n\t yn = .true.\n\t do i=1,len_trim(word)-1\n\t \tif (ichar(word(i+1:i+1))<ichar(word(i:i))) then\n\t \t\tyn = .false.\n\t \t\texit\n\t \tend if\n\t end do\n\t \n\t\n\t end function ordered_word\n\t\n \n\n end module ordered_module\n\n\n\n program main\n\n use ordered_module\n implicit none\n\n\tinteger :: i,n,n_max\n \n\t\n\topen(unit=file_unit,file=filename)     \t\t\n\tn = count_lines_in_file(file_unit)      \n\tallocate(dict(n))                       \n\tdo i=1,n                                \n\t\tread(file_unit,'(A)') dict(i)%str   \n\t\tdict(i)%n = len_trim(dict(i)%str)   \n\tend do\t\t\n\tclose(file_unit)                        \n\n\t\n\tdict%ordered = ordered_word(dict%str)\t\n\n\t\n\tn_max = maxval(dict%n, mask=dict%ordered)\n\t\t\n\t\n\tdo i=1,n\n\t\tif (dict(i)%ordered .and. dict(i)%n==n_max) write(*,'(A,A)',advance='NO') trim(dict(i)%str),' '\n\tend do\n\twrite(*,*) ''\n\n\n end program main\n\n", "target": "import urllib.request\n\nurl = 'http://www.puzzlers.org/pub/wordlists/unixdict.txt'\nwords = urllib.request.urlopen(url).read().decode(\"utf-8\").split()\nordered = [word for word in words if word==''.join(sorted(word))]\nmaxlen = len(max(ordered, key=len))\nmaxorderedwords = [word for word in ordered if len(word) == maxlen]\nprint(' '.join(maxorderedwords))\n"}
{"id": 139275, "name": "Arrays", "source": "Translate Fortran to Java: integer a (10)\n", "target": "Int[] literalArray = [1,2,3];\nInt[] fixedLengthArray = new Int[10];\nInt[] variableArray = new Int[];\n\nassert literalArray.size == 3; \nInt n = literalArray[2];       \nfixedLengthArray[4] = 12345;   \n\nfixedLengthArray += 6789;  \nvariableArray    += 6789;  \n"}
{"id": 139276, "name": "Arrays", "source": "Translate Fortran to Python: integer a (10)\n", "target": "array = []\n\narray.append(1)\narray.append(3)\n\narray[0] = 2\n\nprint array[0]\n"}
{"id": 140725, "name": "Hofstadter-Conway $10,000 sequence", "source": "Translate Fortran to C#: program conway\n  implicit none\n  integer :: a(2**20)  \n  real    :: b(2**20)  \n  real    :: v         \n  integer :: nl(1)     \n  integer :: i, N, first, second, last, m\n\n  \n  a(1:2) = [1, 1]\n  b(1:2) = [1.0e0, 0.5e0]\n  N = 2\n  do i=1,2**20\n     last = a(N)\n     first = a(last)\n     second = a(N-last+1)\n     N = N+1\n     a(N:N) = first + second\n     b(N:N) = a(N:N)/real(N)\n  end do\n\n  \n  m = 0\n  do i=1,19\n     v = maxval(b(2**i:2**(i+1)))\n     nl = maxloc(b(2**i:2**(i+1)))\n     write(*,'(2(a,i0),a,f8.6,a,i0)') &\n          'Max. between 2**', i,      &\n          ' and 2**', (i+1),          &\n          ' is ', v,                  &\n          ' at n = ', 2**i+nl(1)-1\n     if (m == 0 .and. v < 0.55e0) then\n        m = i-1\n     end if\n  end do\n\n  \n  do i=2**(m+1), 2**m,-1\n     if (b(i) > 0.55e0) then\n        exit\n     end if\n  end do\n  write(*,'(a,i0)') 'Mallows number = ',i\n\nend program conway\n", "target": "using System;\nusing System.Linq;\n\nnamespace HofstadterConway\n{\n    class Program\n    {\n        static int[] GenHofstadterConway(int max)\n        {\n            int[] result = new int[max];\n            result[0]=result[1]=1;\n            for (int ix = 2; ix < max; ix++)\n                result[ix] = result[result[ix - 1] - 1] + result[ix - result[ix - 1]];\n            return result;\n        }\n\n        static void Main(string[] args)\n        {\n            double[] adiv = new double[1 << 20];\n            {\n                int[] a = GenHofstadterConway(1 << 20);\n                for (int i = 0; i < 1 << 20; i++)\n                    adiv[i] = a[i] / (double)(i + 1);\n            }\n            for (int p = 2; p <= 20; p++)\n            {\n                var max = Enumerable.Range(\n                     (1 << (p - 1)) - 1,\n                     (1 << p) - (1 << (p - 1))\n                     )\n                     .Select(ix => new { I = ix + 1, A = adiv[ix] })\n                     .OrderByDescending(x => x.A)\n                     .First();\n                Console.WriteLine(\"Maximum from 2^{0} to 2^{1} is {2} at {3}\",\n                    p - 1, p, max.A, max.I);\n            }\n            Console.WriteLine(\"The winning number is {0}.\",\n                Enumerable.Range(0, 1 << 20)\n                    .Last(i => (adiv[i] > 0.55)) + 1\n                );\n        }\n    }\n}\n"}
{"id": 140726, "name": "Hofstadter-Conway $10,000 sequence", "source": "Translate Fortran to C#: program conway\n  implicit none\n  integer :: a(2**20)  \n  real    :: b(2**20)  \n  real    :: v         \n  integer :: nl(1)     \n  integer :: i, N, first, second, last, m\n\n  \n  a(1:2) = [1, 1]\n  b(1:2) = [1.0e0, 0.5e0]\n  N = 2\n  do i=1,2**20\n     last = a(N)\n     first = a(last)\n     second = a(N-last+1)\n     N = N+1\n     a(N:N) = first + second\n     b(N:N) = a(N:N)/real(N)\n  end do\n\n  \n  m = 0\n  do i=1,19\n     v = maxval(b(2**i:2**(i+1)))\n     nl = maxloc(b(2**i:2**(i+1)))\n     write(*,'(2(a,i0),a,f8.6,a,i0)') &\n          'Max. between 2**', i,      &\n          ' and 2**', (i+1),          &\n          ' is ', v,                  &\n          ' at n = ', 2**i+nl(1)-1\n     if (m == 0 .and. v < 0.55e0) then\n        m = i-1\n     end if\n  end do\n\n  \n  do i=2**(m+1), 2**m,-1\n     if (b(i) > 0.55e0) then\n        exit\n     end if\n  end do\n  write(*,'(a,i0)') 'Mallows number = ',i\n\nend program conway\n", "target": "using System;\nusing System.Linq;\n\nnamespace HofstadterConway\n{\n    class Program\n    {\n        static int[] GenHofstadterConway(int max)\n        {\n            int[] result = new int[max];\n            result[0]=result[1]=1;\n            for (int ix = 2; ix < max; ix++)\n                result[ix] = result[result[ix - 1] - 1] + result[ix - result[ix - 1]];\n            return result;\n        }\n\n        static void Main(string[] args)\n        {\n            double[] adiv = new double[1 << 20];\n            {\n                int[] a = GenHofstadterConway(1 << 20);\n                for (int i = 0; i < 1 << 20; i++)\n                    adiv[i] = a[i] / (double)(i + 1);\n            }\n            for (int p = 2; p <= 20; p++)\n            {\n                var max = Enumerable.Range(\n                     (1 << (p - 1)) - 1,\n                     (1 << p) - (1 << (p - 1))\n                     )\n                     .Select(ix => new { I = ix + 1, A = adiv[ix] })\n                     .OrderByDescending(x => x.A)\n                     .First();\n                Console.WriteLine(\"Maximum from 2^{0} to 2^{1} is {2} at {3}\",\n                    p - 1, p, max.A, max.I);\n            }\n            Console.WriteLine(\"The winning number is {0}.\",\n                Enumerable.Range(0, 1 << 20)\n                    .Last(i => (adiv[i] > 0.55)) + 1\n                );\n        }\n    }\n}\n"}
{"id": 140731, "name": "Hofstadter-Conway $10,000 sequence", "source": "Translate Fortran to Java: program conway\n  implicit none\n  integer :: a(2**20)  \n  real    :: b(2**20)  \n  real    :: v         \n  integer :: nl(1)     \n  integer :: i, N, first, second, last, m\n\n  \n  a(1:2) = [1, 1]\n  b(1:2) = [1.0e0, 0.5e0]\n  N = 2\n  do i=1,2**20\n     last = a(N)\n     first = a(last)\n     second = a(N-last+1)\n     N = N+1\n     a(N:N) = first + second\n     b(N:N) = a(N:N)/real(N)\n  end do\n\n  \n  m = 0\n  do i=1,19\n     v = maxval(b(2**i:2**(i+1)))\n     nl = maxloc(b(2**i:2**(i+1)))\n     write(*,'(2(a,i0),a,f8.6,a,i0)') &\n          'Max. between 2**', i,      &\n          ' and 2**', (i+1),          &\n          ' is ', v,                  &\n          ' at n = ', 2**i+nl(1)-1\n     if (m == 0 .and. v < 0.55e0) then\n        m = i-1\n     end if\n  end do\n\n  \n  do i=2**(m+1), 2**m,-1\n     if (b(i) > 0.55e0) then\n        exit\n     end if\n  end do\n  write(*,'(a,i0)') 'Mallows number = ',i\n\nend program conway\n", "target": "\n\npublic class HofstadterConwaySequence {\n\n    private static int MAX = (int) Math.pow(2, 20) + 1;\n    private static int[] HCS = new int[MAX];\n    static {\n        HCS[1] = 1;\n        HCS[2] = 1;\n        for ( int n = 3 ; n < MAX ; n++ ) {\n            int nm1 = HCS[n - 1];\n            HCS[n] = HCS[nm1] + HCS[n - nm1];\n        }\n    }\n    \n    public static void main(String[] args) {\n        int mNum = 0;\n        for ( int m = 1 ; m < 20 ; m++ ) {\n            int min = (int) Math.pow(2, m);\n            int max = min * 2;\n            double maxRatio = 0.0;\n            int nVal = 0;\n            for ( int n = min ; n <= max ; n ++ ) {\n                double ratio = (double) HCS[n] / n;\n                if ( ratio > maxRatio ) {\n                    maxRatio = Math.max(ratio,  maxRatio);\n                    nVal = n;\n                }\n                if ( ratio >= 0.55 ) {\n                    mNum = n;\n                }\n            }\n            System.out.printf(\"Max ratio between 2^%d and 2^%d is %f at n =\u00a0%,d%n\", m, m+1, maxRatio, nVal);\n        }\n        System.out.printf(\"Mallow's number is %d.%n\", mNum);\n    }\n\n}\n"}
{"id": 140732, "name": "Hofstadter-Conway $10,000 sequence", "source": "Translate Fortran to Java: program conway\n  implicit none\n  integer :: a(2**20)  \n  real    :: b(2**20)  \n  real    :: v         \n  integer :: nl(1)     \n  integer :: i, N, first, second, last, m\n\n  \n  a(1:2) = [1, 1]\n  b(1:2) = [1.0e0, 0.5e0]\n  N = 2\n  do i=1,2**20\n     last = a(N)\n     first = a(last)\n     second = a(N-last+1)\n     N = N+1\n     a(N:N) = first + second\n     b(N:N) = a(N:N)/real(N)\n  end do\n\n  \n  m = 0\n  do i=1,19\n     v = maxval(b(2**i:2**(i+1)))\n     nl = maxloc(b(2**i:2**(i+1)))\n     write(*,'(2(a,i0),a,f8.6,a,i0)') &\n          'Max. between 2**', i,      &\n          ' and 2**', (i+1),          &\n          ' is ', v,                  &\n          ' at n = ', 2**i+nl(1)-1\n     if (m == 0 .and. v < 0.55e0) then\n        m = i-1\n     end if\n  end do\n\n  \n  do i=2**(m+1), 2**m,-1\n     if (b(i) > 0.55e0) then\n        exit\n     end if\n  end do\n  write(*,'(a,i0)') 'Mallows number = ',i\n\nend program conway\n", "target": "\n\npublic class HofstadterConwaySequence {\n\n    private static int MAX = (int) Math.pow(2, 20) + 1;\n    private static int[] HCS = new int[MAX];\n    static {\n        HCS[1] = 1;\n        HCS[2] = 1;\n        for ( int n = 3 ; n < MAX ; n++ ) {\n            int nm1 = HCS[n - 1];\n            HCS[n] = HCS[nm1] + HCS[n - nm1];\n        }\n    }\n    \n    public static void main(String[] args) {\n        int mNum = 0;\n        for ( int m = 1 ; m < 20 ; m++ ) {\n            int min = (int) Math.pow(2, m);\n            int max = min * 2;\n            double maxRatio = 0.0;\n            int nVal = 0;\n            for ( int n = min ; n <= max ; n ++ ) {\n                double ratio = (double) HCS[n] / n;\n                if ( ratio > maxRatio ) {\n                    maxRatio = Math.max(ratio,  maxRatio);\n                    nVal = n;\n                }\n                if ( ratio >= 0.55 ) {\n                    mNum = n;\n                }\n            }\n            System.out.printf(\"Max ratio between 2^%d and 2^%d is %f at n =\u00a0%,d%n\", m, m+1, maxRatio, nVal);\n        }\n        System.out.printf(\"Mallow's number is %d.%n\", mNum);\n    }\n\n}\n"}
{"id": 140733, "name": "Hofstadter-Conway $10,000 sequence", "source": "Translate Fortran to Python: program conway\n  implicit none\n  integer :: a(2**20)  \n  real    :: b(2**20)  \n  real    :: v         \n  integer :: nl(1)     \n  integer :: i, N, first, second, last, m\n\n  \n  a(1:2) = [1, 1]\n  b(1:2) = [1.0e0, 0.5e0]\n  N = 2\n  do i=1,2**20\n     last = a(N)\n     first = a(last)\n     second = a(N-last+1)\n     N = N+1\n     a(N:N) = first + second\n     b(N:N) = a(N:N)/real(N)\n  end do\n\n  \n  m = 0\n  do i=1,19\n     v = maxval(b(2**i:2**(i+1)))\n     nl = maxloc(b(2**i:2**(i+1)))\n     write(*,'(2(a,i0),a,f8.6,a,i0)') &\n          'Max. between 2**', i,      &\n          ' and 2**', (i+1),          &\n          ' is ', v,                  &\n          ' at n = ', 2**i+nl(1)-1\n     if (m == 0 .and. v < 0.55e0) then\n        m = i-1\n     end if\n  end do\n\n  \n  do i=2**(m+1), 2**m,-1\n     if (b(i) > 0.55e0) then\n        exit\n     end if\n  end do\n  write(*,'(a,i0)') 'Mallows number = ',i\n\nend program conway\n", "target": "from __future__ import division\n\ndef maxandmallows(nmaxpower2):\n    nmax = 2**nmaxpower2\n    mx = (0.5, 2)\n    mxpow2 = []\n    mallows = None\n\n    \n    \n    hc = [None, 1, 1]\n\n    for n in range(2, nmax + 1):\n        ratio = hc[n] / n\n        if ratio > mx[0]:\n            mx = (ratio, n)\n        if ratio >= 0.55:\n            mallows = n\n        if ratio == 0.5:\n            print(\"In the region %7i < n <= %7i: max a(n)/n = %6.4f at  n = %i\" %\n\t\t  (n//2, n, mx[0], mx[1]))\n            mxpow2.append(mx[0])\n            mx = (ratio, n)\n        hc.append(hc[hc[n]] + hc[-hc[n]])\n\n    return hc, mallows if mxpow2 and mxpow2[-1] < 0.55 and n > 4 else None\n\nif __name__ == '__main__':\n    hc, mallows = maxandmallows(20)\n    if mallows:\n        print(\"\\nYou too might have won $1000 with the mallows number of %i\" % mallows)\n"}
{"id": 140734, "name": "Hofstadter-Conway $10,000 sequence", "source": "Translate Fortran to Python: program conway\n  implicit none\n  integer :: a(2**20)  \n  real    :: b(2**20)  \n  real    :: v         \n  integer :: nl(1)     \n  integer :: i, N, first, second, last, m\n\n  \n  a(1:2) = [1, 1]\n  b(1:2) = [1.0e0, 0.5e0]\n  N = 2\n  do i=1,2**20\n     last = a(N)\n     first = a(last)\n     second = a(N-last+1)\n     N = N+1\n     a(N:N) = first + second\n     b(N:N) = a(N:N)/real(N)\n  end do\n\n  \n  m = 0\n  do i=1,19\n     v = maxval(b(2**i:2**(i+1)))\n     nl = maxloc(b(2**i:2**(i+1)))\n     write(*,'(2(a,i0),a,f8.6,a,i0)') &\n          'Max. between 2**', i,      &\n          ' and 2**', (i+1),          &\n          ' is ', v,                  &\n          ' at n = ', 2**i+nl(1)-1\n     if (m == 0 .and. v < 0.55e0) then\n        m = i-1\n     end if\n  end do\n\n  \n  do i=2**(m+1), 2**m,-1\n     if (b(i) > 0.55e0) then\n        exit\n     end if\n  end do\n  write(*,'(a,i0)') 'Mallows number = ',i\n\nend program conway\n", "target": "from __future__ import division\n\ndef maxandmallows(nmaxpower2):\n    nmax = 2**nmaxpower2\n    mx = (0.5, 2)\n    mxpow2 = []\n    mallows = None\n\n    \n    \n    hc = [None, 1, 1]\n\n    for n in range(2, nmax + 1):\n        ratio = hc[n] / n\n        if ratio > mx[0]:\n            mx = (ratio, n)\n        if ratio >= 0.55:\n            mallows = n\n        if ratio == 0.5:\n            print(\"In the region %7i < n <= %7i: max a(n)/n = %6.4f at  n = %i\" %\n\t\t  (n//2, n, mx[0], mx[1]))\n            mxpow2.append(mx[0])\n            mx = (ratio, n)\n        hc.append(hc[hc[n]] + hc[-hc[n]])\n\n    return hc, mallows if mxpow2 and mxpow2[-1] < 0.55 and n > 4 else None\n\nif __name__ == '__main__':\n    hc, mallows = maxandmallows(20)\n    if mallows:\n        print(\"\\nYou too might have won $1000 with the mallows number of %i\" % mallows)\n"}
{"id": 141259, "name": "Tokenize a string with escaping", "source": "Translate Fortran to C#:       SUBROUTINE SPLIT(TEXT,SEP,ESC)\t\n       CHARACTER*(*) TEXT\t\n       CHARACTER*(1) SEP\t\n       CHARACTER*(1) ESC\t\n       CHARACTER*(LEN(TEXT)) TOKEN\t\n       INTEGER N\t\n       INTEGER I\t\n       INTEGER L\t\n       LOGICAL ESCAPING\t\n        N = 0\t\t\n        L = 0\t\t\n        ESCAPING = .FALSE.\t\n        DO I = 1,LEN(TEXT)\t\n          IF (ESCAPING) THEN\t\n            L = L + 1\t\t\t\n            TOKEN(L:L) = TEXT(I:I)\t\n            ESCAPING = .FALSE.\t\t\n           ELSE\t\t\t\n            IF (TEXT(I:I).EQ.ESC) THEN\t\n             ESCAPING = .TRUE.\t\t\t\n            ELSE IF (TEXT(I:I).EQ.SEP) THEN\t\n             CALL SPLOT\t\t\t\t\n            ELSE\t\t\t\n             L = L + 1\t\t\t\t\n             TOKEN(L:L) = TEXT(I:I)\t\t\n            END IF\t\t\t\n          END IF\t\t\n        END DO\t\t\t\nCompletes on end-of-text with L > 0, or, if the last character had been SEP, a null token is deemed to be following.\n        CALL SPLOT\t\n       CONTAINS\t\n        SUBROUTINE SPLOT\t\n         N = N + 1\t\t\t\n         WRITE (6,1) N,TOKEN(1:L)\t\n    1    FORMAT (\"Token \",I0,\" >\",A,\"<\")\n         L = 0\t\t\t\t\n        END SUBROUTINE SPLOT\t\n      END SUBROUTINE SPLIT\t\n\n      PROGRAM POKE\n\n      CALL SPLIT(\"one^|uno||three^^^^|four^^^|^cuatro|\",\"|\",\"^\")\n\n      END\n", "target": "using System;\nusing System.Text;\nusing System.Collections.Generic;\n\npublic class TokenizeAStringWithEscaping\n{\n    public static void Main() {\n        string testcase = \"one^|uno||three^^^^|four^^^|^cuatro|\";\n        foreach (var token in testcase.Tokenize(separator: '|', escape: '^')) {\n            Console.WriteLine(\": \" + token); \n        }\n    }\n}\n\npublic static class Extensions\n{\n    public static IEnumerable<string> Tokenize(this string input, char separator, char escape) {\n        if (input == null) yield break;\n        var buffer = new StringBuilder();\n        bool escaping = false;\n        foreach (char c in input) {\n            if (escaping) {\n                buffer.Append(c);\n                escaping = false;\n            } else if (c == escape) {\n                escaping = true;\n            } else if (c == separator) {\n                yield return buffer.Flush();\n            } else {\n                buffer.Append(c);\n            }\n        }\n        if (buffer.Length > 0 || input[input.Length-1] == separator) yield return buffer.Flush();\n    }\n    \n    public static string Flush(this StringBuilder stringBuilder) {\n        string result = stringBuilder.ToString();\n        stringBuilder.Clear();\n        return result;\n    }\n}\n"}
{"id": 141262, "name": "Tokenize a string with escaping", "source": "Translate Fortran to Java:       SUBROUTINE SPLIT(TEXT,SEP,ESC)\t\n       CHARACTER*(*) TEXT\t\n       CHARACTER*(1) SEP\t\n       CHARACTER*(1) ESC\t\n       CHARACTER*(LEN(TEXT)) TOKEN\t\n       INTEGER N\t\n       INTEGER I\t\n       INTEGER L\t\n       LOGICAL ESCAPING\t\n        N = 0\t\t\n        L = 0\t\t\n        ESCAPING = .FALSE.\t\n        DO I = 1,LEN(TEXT)\t\n          IF (ESCAPING) THEN\t\n            L = L + 1\t\t\t\n            TOKEN(L:L) = TEXT(I:I)\t\n            ESCAPING = .FALSE.\t\t\n           ELSE\t\t\t\n            IF (TEXT(I:I).EQ.ESC) THEN\t\n             ESCAPING = .TRUE.\t\t\t\n            ELSE IF (TEXT(I:I).EQ.SEP) THEN\t\n             CALL SPLOT\t\t\t\t\n            ELSE\t\t\t\n             L = L + 1\t\t\t\t\n             TOKEN(L:L) = TEXT(I:I)\t\t\n            END IF\t\t\t\n          END IF\t\t\n        END DO\t\t\t\nCompletes on end-of-text with L > 0, or, if the last character had been SEP, a null token is deemed to be following.\n        CALL SPLOT\t\n       CONTAINS\t\n        SUBROUTINE SPLOT\t\n         N = N + 1\t\t\t\n         WRITE (6,1) N,TOKEN(1:L)\t\n    1    FORMAT (\"Token \",I0,\" >\",A,\"<\")\n         L = 0\t\t\t\t\n        END SUBROUTINE SPLOT\t\n      END SUBROUTINE SPLIT\t\n\n      PROGRAM POKE\n\n      CALL SPLIT(\"one^|uno||three^^^^|four^^^|^cuatro|\",\"|\",\"^\")\n\n      END\n", "target": "import java.util.*;\n\npublic class TokenizeStringWithEscaping {\n\n    public static void main(String[] args) {\n        String sample = \"one^|uno||three^^^^|four^^^|^cuatro|\";\n        char separator = '|';\n        char escape = '^';\n\n        System.out.println(sample);\n        try {\n            System.out.println(tokenizeString(sample, separator, escape));\n        } catch (Exception e) {\n            System.out.println(e);\n        }\n    }\n\n    public static List<String> tokenizeString(String s, char sep, char escape)\n            throws Exception {\n        List<String> tokens = new ArrayList<>();\n        StringBuilder sb = new StringBuilder();\n\n        boolean inEscape = false;\n        for (char c : s.toCharArray()) {\n            if (inEscape) {\n                inEscape = false;\n            } else if (c == escape) {\n                inEscape = true;\n                continue;\n            } else if (c == sep) {\n                tokens.add(sb.toString());\n                sb.setLength(0);\n                continue;\n            }\n            sb.append(c);\n        }\n        if (inEscape)\n            throw new Exception(\"Invalid terminal escape\");\n\n        tokens.add(sb.toString());\n\n        return tokens;\n    }\n}\n"}
{"id": 141263, "name": "Tokenize a string with escaping", "source": "Translate Fortran to Python:       SUBROUTINE SPLIT(TEXT,SEP,ESC)\t\n       CHARACTER*(*) TEXT\t\n       CHARACTER*(1) SEP\t\n       CHARACTER*(1) ESC\t\n       CHARACTER*(LEN(TEXT)) TOKEN\t\n       INTEGER N\t\n       INTEGER I\t\n       INTEGER L\t\n       LOGICAL ESCAPING\t\n        N = 0\t\t\n        L = 0\t\t\n        ESCAPING = .FALSE.\t\n        DO I = 1,LEN(TEXT)\t\n          IF (ESCAPING) THEN\t\n            L = L + 1\t\t\t\n            TOKEN(L:L) = TEXT(I:I)\t\n            ESCAPING = .FALSE.\t\t\n           ELSE\t\t\t\n            IF (TEXT(I:I).EQ.ESC) THEN\t\n             ESCAPING = .TRUE.\t\t\t\n            ELSE IF (TEXT(I:I).EQ.SEP) THEN\t\n             CALL SPLOT\t\t\t\t\n            ELSE\t\t\t\n             L = L + 1\t\t\t\t\n             TOKEN(L:L) = TEXT(I:I)\t\t\n            END IF\t\t\t\n          END IF\t\t\n        END DO\t\t\t\nCompletes on end-of-text with L > 0, or, if the last character had been SEP, a null token is deemed to be following.\n        CALL SPLOT\t\n       CONTAINS\t\n        SUBROUTINE SPLOT\t\n         N = N + 1\t\t\t\n         WRITE (6,1) N,TOKEN(1:L)\t\n    1    FORMAT (\"Token \",I0,\" >\",A,\"<\")\n         L = 0\t\t\t\t\n        END SUBROUTINE SPLOT\t\n      END SUBROUTINE SPLIT\t\n\n      PROGRAM POKE\n\n      CALL SPLIT(\"one^|uno||three^^^^|four^^^|^cuatro|\",\"|\",\"^\")\n\n      END\n", "target": "def token_with_escape(a, escape = '^', separator = '|'):\n    \n    result = []\n    token = ''\n    state = 0\n    for c in a:\n        if state == 0:\n            if c == escape:\n                state = 1\n            elif c == separator:\n                result.append(token)\n                token = ''\n            else:\n                token += c\n        elif state == 1:\n            token += c\n            state = 0\n    result.append(token)\n    return result\n"}
{"id": 141510, "name": "Damm algorithm", "source": "Translate Fortran to C#:       LOGICAL FUNCTION DAMM(DIGIT)\t\nCalculates according to the method of H. Michael Damm, described in 2004.\n       CHARACTER*(*) DIGIT\t\t\n       INTEGER*1 OPTABLE(0:9,0:9)\t\n       PARAMETER (OPTABLE = (/\t\t\n     o  0, 3, 1, 7, 5, 9, 8, 6, 4, 2,\t\n     1  7, 0, 9, 2, 1, 5, 4, 8, 6, 3,\t\n     2  4, 2, 0, 6, 8, 7, 1, 3, 5, 9,\t\n     3  1, 7, 5, 0, 9, 8, 3, 4, 2, 6,\t\n     4  6, 1, 2, 3, 0, 4, 5, 9, 7, 8,\t\n     5  3, 6, 7, 4, 2, 0, 9, 5, 8, 1,\t\n     6  5, 8, 6, 9, 7, 2, 0, 1, 3, 4,\t\n     7  8, 9, 4, 5, 3, 6, 2, 0, 1, 7,\t\n     8  9, 4, 3, 8, 6, 1, 7, 2, 0, 5,\t\n     9  2, 5, 8, 1, 4, 3, 6, 7, 9, 0/))\t\n       INTEGER I,D,ID\t\n        ID = 0\t\t\n        DO I = 1,LEN(DIGIT)\t\n          D = ICHAR(DIGIT(I:I)) - ICHAR(\"0\")\t\n          IF (D.LT.0 .OR. D.GT.9) STOP \"DAMM\n          ID = OPTABLE(D,ID)\t\t\n        END DO\t\t\t\n        DAMM = ID .EQ. 0\t\n      END FUNCTION DAMM\t\n \n      LOGICAL DAMM\t\n \n      WRITE (6,*) DAMM(\"5724\"),\"5724\"\n      WRITE (6,*) DAMM(\"5727\"),\"5727\"\n      WRITE (6,*) DAMM(\"112946\"),\"112946\"\n \n      END\n", "target": "using System;\n\nnamespace DammAlgorithm {\n    class Program {\n        static int[,] table = {\n            {0, 3, 1, 7, 5, 9, 8, 6, 4, 2},\n            {7, 0, 9, 2, 1, 5, 4, 8, 6, 3},\n            {4, 2, 0, 6, 8, 7, 1, 3, 5, 9},\n            {1, 7, 5, 0, 9, 8, 3, 4, 2, 6},\n            {6, 1, 2, 3, 0, 4, 5, 9, 7, 8},\n            {3, 6, 7, 4, 2, 0, 9, 5, 8, 1},\n            {5, 8, 6, 9, 7, 2, 0, 1, 3, 4},\n            {8, 9, 4, 5, 3, 6, 2, 0, 1, 7},\n            {9, 4, 3, 8, 6, 1, 7, 2, 0, 5},\n            {2, 5, 8, 1, 4, 3, 6, 7, 9, 0},\n        };\n\n        static bool Damm(string s) {\n            int interim = 0;\n            foreach (char c in s) {\n                interim = table[interim, c - '0'];\n            }\n            return interim == 0;\n        }\n\n        static void Main(string[] args) {\n            int[] numbers = { 5724, 5727, 112946, 112949 };\n            foreach (int number in numbers) {\n                bool isValid = Damm(number.ToString());\n                if (isValid) {\n                    Console.WriteLine(\"{0,6} is valid\", number);\n                }\n                else {\n                    Console.WriteLine(\"{0,6} is invalid\", number);\n                }\n            }\n        }\n    }\n}\n"}
{"id": 141511, "name": "Damm algorithm", "source": "Translate Fortran to C#:       LOGICAL FUNCTION DAMM(DIGIT)\t\nCalculates according to the method of H. Michael Damm, described in 2004.\n       CHARACTER*(*) DIGIT\t\t\n       INTEGER*1 OPTABLE(0:9,0:9)\t\n       PARAMETER (OPTABLE = (/\t\t\n     o  0, 3, 1, 7, 5, 9, 8, 6, 4, 2,\t\n     1  7, 0, 9, 2, 1, 5, 4, 8, 6, 3,\t\n     2  4, 2, 0, 6, 8, 7, 1, 3, 5, 9,\t\n     3  1, 7, 5, 0, 9, 8, 3, 4, 2, 6,\t\n     4  6, 1, 2, 3, 0, 4, 5, 9, 7, 8,\t\n     5  3, 6, 7, 4, 2, 0, 9, 5, 8, 1,\t\n     6  5, 8, 6, 9, 7, 2, 0, 1, 3, 4,\t\n     7  8, 9, 4, 5, 3, 6, 2, 0, 1, 7,\t\n     8  9, 4, 3, 8, 6, 1, 7, 2, 0, 5,\t\n     9  2, 5, 8, 1, 4, 3, 6, 7, 9, 0/))\t\n       INTEGER I,D,ID\t\n        ID = 0\t\t\n        DO I = 1,LEN(DIGIT)\t\n          D = ICHAR(DIGIT(I:I)) - ICHAR(\"0\")\t\n          IF (D.LT.0 .OR. D.GT.9) STOP \"DAMM\n          ID = OPTABLE(D,ID)\t\t\n        END DO\t\t\t\n        DAMM = ID .EQ. 0\t\n      END FUNCTION DAMM\t\n \n      LOGICAL DAMM\t\n \n      WRITE (6,*) DAMM(\"5724\"),\"5724\"\n      WRITE (6,*) DAMM(\"5727\"),\"5727\"\n      WRITE (6,*) DAMM(\"112946\"),\"112946\"\n \n      END\n", "target": "using System;\n\nnamespace DammAlgorithm {\n    class Program {\n        static int[,] table = {\n            {0, 3, 1, 7, 5, 9, 8, 6, 4, 2},\n            {7, 0, 9, 2, 1, 5, 4, 8, 6, 3},\n            {4, 2, 0, 6, 8, 7, 1, 3, 5, 9},\n            {1, 7, 5, 0, 9, 8, 3, 4, 2, 6},\n            {6, 1, 2, 3, 0, 4, 5, 9, 7, 8},\n            {3, 6, 7, 4, 2, 0, 9, 5, 8, 1},\n            {5, 8, 6, 9, 7, 2, 0, 1, 3, 4},\n            {8, 9, 4, 5, 3, 6, 2, 0, 1, 7},\n            {9, 4, 3, 8, 6, 1, 7, 2, 0, 5},\n            {2, 5, 8, 1, 4, 3, 6, 7, 9, 0},\n        };\n\n        static bool Damm(string s) {\n            int interim = 0;\n            foreach (char c in s) {\n                interim = table[interim, c - '0'];\n            }\n            return interim == 0;\n        }\n\n        static void Main(string[] args) {\n            int[] numbers = { 5724, 5727, 112946, 112949 };\n            foreach (int number in numbers) {\n                bool isValid = Damm(number.ToString());\n                if (isValid) {\n                    Console.WriteLine(\"{0,6} is valid\", number);\n                }\n                else {\n                    Console.WriteLine(\"{0,6} is invalid\", number);\n                }\n            }\n        }\n    }\n}\n"}
{"id": 141517, "name": "Damm algorithm", "source": "Translate Fortran to Java:       LOGICAL FUNCTION DAMM(DIGIT)\t\nCalculates according to the method of H. Michael Damm, described in 2004.\n       CHARACTER*(*) DIGIT\t\t\n       INTEGER*1 OPTABLE(0:9,0:9)\t\n       PARAMETER (OPTABLE = (/\t\t\n     o  0, 3, 1, 7, 5, 9, 8, 6, 4, 2,\t\n     1  7, 0, 9, 2, 1, 5, 4, 8, 6, 3,\t\n     2  4, 2, 0, 6, 8, 7, 1, 3, 5, 9,\t\n     3  1, 7, 5, 0, 9, 8, 3, 4, 2, 6,\t\n     4  6, 1, 2, 3, 0, 4, 5, 9, 7, 8,\t\n     5  3, 6, 7, 4, 2, 0, 9, 5, 8, 1,\t\n     6  5, 8, 6, 9, 7, 2, 0, 1, 3, 4,\t\n     7  8, 9, 4, 5, 3, 6, 2, 0, 1, 7,\t\n     8  9, 4, 3, 8, 6, 1, 7, 2, 0, 5,\t\n     9  2, 5, 8, 1, 4, 3, 6, 7, 9, 0/))\t\n       INTEGER I,D,ID\t\n        ID = 0\t\t\n        DO I = 1,LEN(DIGIT)\t\n          D = ICHAR(DIGIT(I:I)) - ICHAR(\"0\")\t\n          IF (D.LT.0 .OR. D.GT.9) STOP \"DAMM\n          ID = OPTABLE(D,ID)\t\t\n        END DO\t\t\t\n        DAMM = ID .EQ. 0\t\n      END FUNCTION DAMM\t\n \n      LOGICAL DAMM\t\n \n      WRITE (6,*) DAMM(\"5724\"),\"5724\"\n      WRITE (6,*) DAMM(\"5727\"),\"5727\"\n      WRITE (6,*) DAMM(\"112946\"),\"112946\"\n \n      END\n", "target": "public class DammAlgorithm {\n    private static final int[][] table = {\n        {0, 3, 1, 7, 5, 9, 8, 6, 4, 2},\n        {7, 0, 9, 2, 1, 5, 4, 8, 6, 3},\n        {4, 2, 0, 6, 8, 7, 1, 3, 5, 9},\n        {1, 7, 5, 0, 9, 8, 3, 4, 2, 6},\n        {6, 1, 2, 3, 0, 4, 5, 9, 7, 8},\n        {3, 6, 7, 4, 2, 0, 9, 5, 8, 1},\n        {5, 8, 6, 9, 7, 2, 0, 1, 3, 4},\n        {8, 9, 4, 5, 3, 6, 2, 0, 1, 7},\n        {9, 4, 3, 8, 6, 1, 7, 2, 0, 5},\n        {2, 5, 8, 1, 4, 3, 6, 7, 9, 0},\n    };\n\n    private static boolean damm(String s) {\n        int interim = 0;\n        for (char c : s.toCharArray()) interim = table[interim][c - '0'];\n        return interim == 0;\n    }\n\n    public static void main(String[] args) {\n        int[] numbers = {5724, 5727, 112946, 112949};\n        for (Integer number : numbers) {\n            boolean isValid = damm(number.toString());\n            if (isValid) {\n                System.out.printf(\"%6d is valid\\n\", number);\n            } else {\n                System.out.printf(\"%6d is invalid\\n\", number);\n            }\n        }\n    }\n}\n"}
{"id": 141518, "name": "Damm algorithm", "source": "Translate Fortran to Java:       LOGICAL FUNCTION DAMM(DIGIT)\t\nCalculates according to the method of H. Michael Damm, described in 2004.\n       CHARACTER*(*) DIGIT\t\t\n       INTEGER*1 OPTABLE(0:9,0:9)\t\n       PARAMETER (OPTABLE = (/\t\t\n     o  0, 3, 1, 7, 5, 9, 8, 6, 4, 2,\t\n     1  7, 0, 9, 2, 1, 5, 4, 8, 6, 3,\t\n     2  4, 2, 0, 6, 8, 7, 1, 3, 5, 9,\t\n     3  1, 7, 5, 0, 9, 8, 3, 4, 2, 6,\t\n     4  6, 1, 2, 3, 0, 4, 5, 9, 7, 8,\t\n     5  3, 6, 7, 4, 2, 0, 9, 5, 8, 1,\t\n     6  5, 8, 6, 9, 7, 2, 0, 1, 3, 4,\t\n     7  8, 9, 4, 5, 3, 6, 2, 0, 1, 7,\t\n     8  9, 4, 3, 8, 6, 1, 7, 2, 0, 5,\t\n     9  2, 5, 8, 1, 4, 3, 6, 7, 9, 0/))\t\n       INTEGER I,D,ID\t\n        ID = 0\t\t\n        DO I = 1,LEN(DIGIT)\t\n          D = ICHAR(DIGIT(I:I)) - ICHAR(\"0\")\t\n          IF (D.LT.0 .OR. D.GT.9) STOP \"DAMM\n          ID = OPTABLE(D,ID)\t\t\n        END DO\t\t\t\n        DAMM = ID .EQ. 0\t\n      END FUNCTION DAMM\t\n \n      LOGICAL DAMM\t\n \n      WRITE (6,*) DAMM(\"5724\"),\"5724\"\n      WRITE (6,*) DAMM(\"5727\"),\"5727\"\n      WRITE (6,*) DAMM(\"112946\"),\"112946\"\n \n      END\n", "target": "public class DammAlgorithm {\n    private static final int[][] table = {\n        {0, 3, 1, 7, 5, 9, 8, 6, 4, 2},\n        {7, 0, 9, 2, 1, 5, 4, 8, 6, 3},\n        {4, 2, 0, 6, 8, 7, 1, 3, 5, 9},\n        {1, 7, 5, 0, 9, 8, 3, 4, 2, 6},\n        {6, 1, 2, 3, 0, 4, 5, 9, 7, 8},\n        {3, 6, 7, 4, 2, 0, 9, 5, 8, 1},\n        {5, 8, 6, 9, 7, 2, 0, 1, 3, 4},\n        {8, 9, 4, 5, 3, 6, 2, 0, 1, 7},\n        {9, 4, 3, 8, 6, 1, 7, 2, 0, 5},\n        {2, 5, 8, 1, 4, 3, 6, 7, 9, 0},\n    };\n\n    private static boolean damm(String s) {\n        int interim = 0;\n        for (char c : s.toCharArray()) interim = table[interim][c - '0'];\n        return interim == 0;\n    }\n\n    public static void main(String[] args) {\n        int[] numbers = {5724, 5727, 112946, 112949};\n        for (Integer number : numbers) {\n            boolean isValid = damm(number.toString());\n            if (isValid) {\n                System.out.printf(\"%6d is valid\\n\", number);\n            } else {\n                System.out.printf(\"%6d is invalid\\n\", number);\n            }\n        }\n    }\n}\n"}
{"id": 141519, "name": "Damm algorithm", "source": "Translate Fortran to Python:       LOGICAL FUNCTION DAMM(DIGIT)\t\nCalculates according to the method of H. Michael Damm, described in 2004.\n       CHARACTER*(*) DIGIT\t\t\n       INTEGER*1 OPTABLE(0:9,0:9)\t\n       PARAMETER (OPTABLE = (/\t\t\n     o  0, 3, 1, 7, 5, 9, 8, 6, 4, 2,\t\n     1  7, 0, 9, 2, 1, 5, 4, 8, 6, 3,\t\n     2  4, 2, 0, 6, 8, 7, 1, 3, 5, 9,\t\n     3  1, 7, 5, 0, 9, 8, 3, 4, 2, 6,\t\n     4  6, 1, 2, 3, 0, 4, 5, 9, 7, 8,\t\n     5  3, 6, 7, 4, 2, 0, 9, 5, 8, 1,\t\n     6  5, 8, 6, 9, 7, 2, 0, 1, 3, 4,\t\n     7  8, 9, 4, 5, 3, 6, 2, 0, 1, 7,\t\n     8  9, 4, 3, 8, 6, 1, 7, 2, 0, 5,\t\n     9  2, 5, 8, 1, 4, 3, 6, 7, 9, 0/))\t\n       INTEGER I,D,ID\t\n        ID = 0\t\t\n        DO I = 1,LEN(DIGIT)\t\n          D = ICHAR(DIGIT(I:I)) - ICHAR(\"0\")\t\n          IF (D.LT.0 .OR. D.GT.9) STOP \"DAMM\n          ID = OPTABLE(D,ID)\t\t\n        END DO\t\t\t\n        DAMM = ID .EQ. 0\t\n      END FUNCTION DAMM\t\n \n      LOGICAL DAMM\t\n \n      WRITE (6,*) DAMM(\"5724\"),\"5724\"\n      WRITE (6,*) DAMM(\"5727\"),\"5727\"\n      WRITE (6,*) DAMM(\"112946\"),\"112946\"\n \n      END\n", "target": "def damm(num: int) -> bool:\n    row = 0\n    for digit in str(num):\n        row = _matrix[row][int(digit)] \n    return row == 0\n\n_matrix = (\n    (0, 3, 1, 7, 5, 9, 8, 6, 4, 2),\n    (7, 0, 9, 2, 1, 5, 4, 8, 6, 3),\n    (4, 2, 0, 6, 8, 7, 1, 3, 5, 9),\n    (1, 7, 5, 0, 9, 8, 3, 4, 2, 6),\n    (6, 1, 2, 3, 0, 4, 5, 9, 7, 8),\n    (3, 6, 7, 4, 2, 0, 9, 5, 8, 1),\n    (5, 8, 6, 9, 7, 2, 0, 1, 3, 4),\n    (8, 9, 4, 5, 3, 6, 2, 0, 1, 7),\n    (9, 4, 3, 8, 6, 1, 7, 2, 0, 5),\n    (2, 5, 8, 1, 4, 3, 6, 7, 9, 0)\n)\n\nif __name__ == '__main__':\n    for test in [5724, 5727, 112946]:\n        print(f'{test}\\t Validates as: {damm(test)}')\n"}
{"id": 141520, "name": "Damm algorithm", "source": "Translate Fortran to Python:       LOGICAL FUNCTION DAMM(DIGIT)\t\nCalculates according to the method of H. Michael Damm, described in 2004.\n       CHARACTER*(*) DIGIT\t\t\n       INTEGER*1 OPTABLE(0:9,0:9)\t\n       PARAMETER (OPTABLE = (/\t\t\n     o  0, 3, 1, 7, 5, 9, 8, 6, 4, 2,\t\n     1  7, 0, 9, 2, 1, 5, 4, 8, 6, 3,\t\n     2  4, 2, 0, 6, 8, 7, 1, 3, 5, 9,\t\n     3  1, 7, 5, 0, 9, 8, 3, 4, 2, 6,\t\n     4  6, 1, 2, 3, 0, 4, 5, 9, 7, 8,\t\n     5  3, 6, 7, 4, 2, 0, 9, 5, 8, 1,\t\n     6  5, 8, 6, 9, 7, 2, 0, 1, 3, 4,\t\n     7  8, 9, 4, 5, 3, 6, 2, 0, 1, 7,\t\n     8  9, 4, 3, 8, 6, 1, 7, 2, 0, 5,\t\n     9  2, 5, 8, 1, 4, 3, 6, 7, 9, 0/))\t\n       INTEGER I,D,ID\t\n        ID = 0\t\t\n        DO I = 1,LEN(DIGIT)\t\n          D = ICHAR(DIGIT(I:I)) - ICHAR(\"0\")\t\n          IF (D.LT.0 .OR. D.GT.9) STOP \"DAMM\n          ID = OPTABLE(D,ID)\t\t\n        END DO\t\t\t\n        DAMM = ID .EQ. 0\t\n      END FUNCTION DAMM\t\n \n      LOGICAL DAMM\t\n \n      WRITE (6,*) DAMM(\"5724\"),\"5724\"\n      WRITE (6,*) DAMM(\"5727\"),\"5727\"\n      WRITE (6,*) DAMM(\"112946\"),\"112946\"\n \n      END\n", "target": "def damm(num: int) -> bool:\n    row = 0\n    for digit in str(num):\n        row = _matrix[row][int(digit)] \n    return row == 0\n\n_matrix = (\n    (0, 3, 1, 7, 5, 9, 8, 6, 4, 2),\n    (7, 0, 9, 2, 1, 5, 4, 8, 6, 3),\n    (4, 2, 0, 6, 8, 7, 1, 3, 5, 9),\n    (1, 7, 5, 0, 9, 8, 3, 4, 2, 6),\n    (6, 1, 2, 3, 0, 4, 5, 9, 7, 8),\n    (3, 6, 7, 4, 2, 0, 9, 5, 8, 1),\n    (5, 8, 6, 9, 7, 2, 0, 1, 3, 4),\n    (8, 9, 4, 5, 3, 6, 2, 0, 1, 7),\n    (9, 4, 3, 8, 6, 1, 7, 2, 0, 5),\n    (2, 5, 8, 1, 4, 3, 6, 7, 9, 0)\n)\n\nif __name__ == '__main__':\n    for test in [5724, 5727, 112946]:\n        print(f'{test}\\t Validates as: {damm(test)}')\n"}
{"id": 142242, "name": "String prepend", "source": "Translate Fortran to C#:       INTEGER*4 I,TEXT(66)\n      DATA TEXT(1),TEXT(2),TEXT(3)/\"Wo\",\"rl\",\"d\n\n      WRITE (6,1) (TEXT(I), I = 1,3)\n    1 FORMAT (\"Hello \",66A2)\n\n      DO 2 I = 1,3\n    2   TEXT(I + 3) = TEXT(I)\n      TEXT(1) = \"He\"\n      TEXT(2) = \"ll\"\n      TEXT(3) = \"o \"\n\n      WRITE (6,3) (TEXT(I), I = 1,6)\n    3 FORMAT (66A2)\n      END\n", "target": "using System;\n\nnamespace PrependString\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            string str = \"World\";\n            str = \"Hello \" + str;\n            Console.WriteLine(str);\n            Console.ReadKey();\n        }\n    }\n}\n"}
{"id": 142245, "name": "String prepend", "source": "Translate Fortran to Java:       INTEGER*4 I,TEXT(66)\n      DATA TEXT(1),TEXT(2),TEXT(3)/\"Wo\",\"rl\",\"d\n\n      WRITE (6,1) (TEXT(I), I = 1,3)\n    1 FORMAT (\"Hello \",66A2)\n\n      DO 2 I = 1,3\n    2   TEXT(I + 3) = TEXT(I)\n      TEXT(1) = \"He\"\n      TEXT(2) = \"ll\"\n      TEXT(3) = \"o \"\n\n      WRITE (6,3) (TEXT(I), I = 1,6)\n    3 FORMAT (66A2)\n      END\n", "target": "\npublic class Prepend {\n    public static void main(String[] args) {\n        StringBuilder sb = new StringBuilder(\"world\");\n        sb.insert(0, \"Hello, \");\n        System.out.println(sb);\n    }\n}\n"}
{"id": 142246, "name": "String prepend", "source": "Translate Fortran to Python:       INTEGER*4 I,TEXT(66)\n      DATA TEXT(1),TEXT(2),TEXT(3)/\"Wo\",\"rl\",\"d\n\n      WRITE (6,1) (TEXT(I), I = 1,3)\n    1 FORMAT (\"Hello \",66A2)\n\n      DO 2 I = 1,3\n    2   TEXT(I + 3) = TEXT(I)\n      TEXT(1) = \"He\"\n      TEXT(2) = \"ll\"\n      TEXT(3) = \"o \"\n\n      WRITE (6,3) (TEXT(I), I = 1,6)\n    3 FORMAT (66A2)\n      END\n", "target": "\n\n\ns = \"12345678\"\ns = \"0\" + s  \nprint(s)\n"}
{"id": 142700, "name": "Fast Fourier transform", "source": "Translate Fortran to C#: module fft_mod\n  implicit none\n  integer,       parameter :: dp=selected_real_kind(15,300)\n  real(kind=dp), parameter :: pi=3.141592653589793238460_dp\ncontains\n\n  \n  recursive subroutine fft(x)\n    complex(kind=dp), dimension(:), intent(inout)  :: x\n    complex(kind=dp)                               :: t\n    integer                                        :: N\n    integer                                        :: i\n    complex(kind=dp), dimension(:), allocatable    :: even, odd\n\n    N=size(x)\n\n    if(N .le. 1) return\n\n    allocate(odd((N+1)/2))\n    allocate(even(N/2))\n\n    \n    odd =x(1:N:2)\n    even=x(2:N:2)\n\n    \n    call fft(odd)\n    call fft(even)\n\n    \n    do i=1,N/2\n       t=exp(cmplx(0.0_dp,-2.0_dp*pi*real(i-1,dp)/real(N,dp),kind=dp))*even(i)\n       x(i)     = odd(i) + t\n       x(i+N/2) = odd(i) - t\n    end do\n\n    deallocate(odd)\n    deallocate(even)\n\n  end subroutine fft\n\nend module fft_mod\n\nprogram test\n  use fft_mod\n  implicit none\n  complex(kind=dp), dimension(8) :: data = (/1.0, 1.0, 1.0, 1.0, 0.0, \n\n0.0, 0.0, 0.0/)\n  integer :: i\n\n  call fft(data)\n\n  do i=1,8\n     write(*,'(\"(\", F20.15, \",\", F20.15, \"i )\")') data(i)\n  end do\n\nend program test\n", "target": "using System;\nusing System.Numerics;\nusing System.Linq;\nusing System.Diagnostics;\n\n\npublic class Program {\n\n    \n    public static int BitReverse(int n, int bits) {\n       int reversedN = n;\n       int count = bits - 1;\n\n       n >>= 1;\n       while (n > 0) {\n            reversedN = (reversedN << 1) | (n & 1);\n            count--;\n            n >>= 1;\n        }\n\n        return ((reversedN << count) & ((1 << bits) - 1));\n    }\n\n    \n    public static void FFT(Complex[] buffer) {\n#if false\n        int bits = (int)Math.Log(buffer.Length, 2);\n        for (int j = 1; j < buffer.Length / 2; j++) {\n\n            int swapPos = BitReverse(j, bits);\n            var temp = buffer[j];\n            buffer[j] = buffer[swapPos];\n            buffer[swapPos] = temp;\n        }\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n#else\n            for (int j = 1; j < buffer.Length; j++)\n            {\n                int swapPos = BitReverse(j, bits);\n                if (swapPos <= j)\n                {\n                    continue;\n                }\n                var temp = buffer[j];\n                buffer[j] = buffer[swapPos];\n                buffer[swapPos] = temp;\n            }\n\n\n\n\n#endif\n\n        for (int N = 2; N <= buffer.Length; N <<= 1) {\n            for (int i = 0; i < buffer.Length; i += N) {\n                for (int k = 0; k < N / 2; k++) {\n\n                    int evenIndex = i + k;\n                    int oddIndex = i + k + (N / 2);\n                    var even = buffer[evenIndex];\n                    var odd = buffer[oddIndex];\n\n                    double term = -2 * Math.PI * k / (double)N;\n                    Complex exp = new Complex(Math.Cos(term), Math.Sin(term)) * odd;\n\n                    buffer[evenIndex] = even + exp;\n                    buffer[oddIndex] = even - exp;\n\n                }\n            }\n        }\n    }\n\n    public static void Main(string[] args) {\n        Complex[] input = {1.0, 1.0, 1.0, 1.0, 0.0, 0.0, 0.0, 0.0};       \n        \n        FFT(input);       \n                  \n        Console.WriteLine(\"Results:\");\n        foreach (Complex c in input) {\n            Console.WriteLine(c);   \n        }   \n    }\n}\n"}
{"id": 142701, "name": "Fast Fourier transform", "source": "Translate Fortran to C#: module fft_mod\n  implicit none\n  integer,       parameter :: dp=selected_real_kind(15,300)\n  real(kind=dp), parameter :: pi=3.141592653589793238460_dp\ncontains\n\n  \n  recursive subroutine fft(x)\n    complex(kind=dp), dimension(:), intent(inout)  :: x\n    complex(kind=dp)                               :: t\n    integer                                        :: N\n    integer                                        :: i\n    complex(kind=dp), dimension(:), allocatable    :: even, odd\n\n    N=size(x)\n\n    if(N .le. 1) return\n\n    allocate(odd((N+1)/2))\n    allocate(even(N/2))\n\n    \n    odd =x(1:N:2)\n    even=x(2:N:2)\n\n    \n    call fft(odd)\n    call fft(even)\n\n    \n    do i=1,N/2\n       t=exp(cmplx(0.0_dp,-2.0_dp*pi*real(i-1,dp)/real(N,dp),kind=dp))*even(i)\n       x(i)     = odd(i) + t\n       x(i+N/2) = odd(i) - t\n    end do\n\n    deallocate(odd)\n    deallocate(even)\n\n  end subroutine fft\n\nend module fft_mod\n\nprogram test\n  use fft_mod\n  implicit none\n  complex(kind=dp), dimension(8) :: data = (/1.0, 1.0, 1.0, 1.0, 0.0, \n\n0.0, 0.0, 0.0/)\n  integer :: i\n\n  call fft(data)\n\n  do i=1,8\n     write(*,'(\"(\", F20.15, \",\", F20.15, \"i )\")') data(i)\n  end do\n\nend program test\n", "target": "using System;\nusing System.Numerics;\nusing System.Linq;\nusing System.Diagnostics;\n\n\npublic class Program {\n\n    \n    public static int BitReverse(int n, int bits) {\n       int reversedN = n;\n       int count = bits - 1;\n\n       n >>= 1;\n       while (n > 0) {\n            reversedN = (reversedN << 1) | (n & 1);\n            count--;\n            n >>= 1;\n        }\n\n        return ((reversedN << count) & ((1 << bits) - 1));\n    }\n\n    \n    public static void FFT(Complex[] buffer) {\n#if false\n        int bits = (int)Math.Log(buffer.Length, 2);\n        for (int j = 1; j < buffer.Length / 2; j++) {\n\n            int swapPos = BitReverse(j, bits);\n            var temp = buffer[j];\n            buffer[j] = buffer[swapPos];\n            buffer[swapPos] = temp;\n        }\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n#else\n            for (int j = 1; j < buffer.Length; j++)\n            {\n                int swapPos = BitReverse(j, bits);\n                if (swapPos <= j)\n                {\n                    continue;\n                }\n                var temp = buffer[j];\n                buffer[j] = buffer[swapPos];\n                buffer[swapPos] = temp;\n            }\n\n\n\n\n#endif\n\n        for (int N = 2; N <= buffer.Length; N <<= 1) {\n            for (int i = 0; i < buffer.Length; i += N) {\n                for (int k = 0; k < N / 2; k++) {\n\n                    int evenIndex = i + k;\n                    int oddIndex = i + k + (N / 2);\n                    var even = buffer[evenIndex];\n                    var odd = buffer[oddIndex];\n\n                    double term = -2 * Math.PI * k / (double)N;\n                    Complex exp = new Complex(Math.Cos(term), Math.Sin(term)) * odd;\n\n                    buffer[evenIndex] = even + exp;\n                    buffer[oddIndex] = even - exp;\n\n                }\n            }\n        }\n    }\n\n    public static void Main(string[] args) {\n        Complex[] input = {1.0, 1.0, 1.0, 1.0, 0.0, 0.0, 0.0, 0.0};       \n        \n        FFT(input);       \n                  \n        Console.WriteLine(\"Results:\");\n        foreach (Complex c in input) {\n            Console.WriteLine(c);   \n        }   \n    }\n}\n"}
{"id": 142708, "name": "Fast Fourier transform", "source": "Translate Fortran to Java: module fft_mod\n  implicit none\n  integer,       parameter :: dp=selected_real_kind(15,300)\n  real(kind=dp), parameter :: pi=3.141592653589793238460_dp\ncontains\n\n  \n  recursive subroutine fft(x)\n    complex(kind=dp), dimension(:), intent(inout)  :: x\n    complex(kind=dp)                               :: t\n    integer                                        :: N\n    integer                                        :: i\n    complex(kind=dp), dimension(:), allocatable    :: even, odd\n\n    N=size(x)\n\n    if(N .le. 1) return\n\n    allocate(odd((N+1)/2))\n    allocate(even(N/2))\n\n    \n    odd =x(1:N:2)\n    even=x(2:N:2)\n\n    \n    call fft(odd)\n    call fft(even)\n\n    \n    do i=1,N/2\n       t=exp(cmplx(0.0_dp,-2.0_dp*pi*real(i-1,dp)/real(N,dp),kind=dp))*even(i)\n       x(i)     = odd(i) + t\n       x(i+N/2) = odd(i) - t\n    end do\n\n    deallocate(odd)\n    deallocate(even)\n\n  end subroutine fft\n\nend module fft_mod\n\nprogram test\n  use fft_mod\n  implicit none\n  complex(kind=dp), dimension(8) :: data = (/1.0, 1.0, 1.0, 1.0, 0.0, \n\n0.0, 0.0, 0.0/)\n  integer :: i\n\n  call fft(data)\n\n  do i=1,8\n     write(*,'(\"(\", F20.15, \",\", F20.15, \"i )\")') data(i)\n  end do\n\nend program test\n", "target": "import static java.lang.Math.*;\n\npublic class FastFourierTransform {\n\n    public static int bitReverse(int n, int bits) {\n        int reversedN = n;\n        int count = bits - 1;\n\n        n >>= 1;\n        while (n > 0) {\n            reversedN = (reversedN << 1) | (n & 1);\n            count--;\n            n >>= 1;\n        }\n\n        return ((reversedN << count) & ((1 << bits) - 1));\n    }\n\n    static void fft(Complex[] buffer) {\n\n        int bits = (int) (log(buffer.length) / log(2));\n        for (int j = 1; j < buffer.length / 2; j++) {\n\n            int swapPos = bitReverse(j, bits);\n            Complex temp = buffer[j];\n            buffer[j] = buffer[swapPos];\n            buffer[swapPos] = temp;\n        }\n\n        for (int N = 2; N <= buffer.length; N <<= 1) {\n            for (int i = 0; i < buffer.length; i += N) {\n                for (int k = 0; k < N / 2; k++) {\n\n                    int evenIndex = i + k;\n                    int oddIndex = i + k + (N / 2);\n                    Complex even = buffer[evenIndex];\n                    Complex odd = buffer[oddIndex];\n\n                    double term = (-2 * PI * k) / (double) N;\n                    Complex exp = (new Complex(cos(term), sin(term)).mult(odd));\n\n                    buffer[evenIndex] = even.add(exp);\n                    buffer[oddIndex] = even.sub(exp);\n                }\n            }\n        }\n    }\n\n    public static void main(String[] args) {\n        double[] input = {1.0, 1.0, 1.0, 1.0, 0.0, 0.0, 0.0, 0.0};\n\n        Complex[] cinput = new Complex[input.length];\n        for (int i = 0; i < input.length; i++)\n            cinput[i] = new Complex(input[i], 0.0);\n\n        fft(cinput);\n\n        System.out.println(\"Results:\");\n        for (Complex c : cinput) {\n            System.out.println(c);\n        }\n    }\n}\n\nclass Complex {\n    public final double re;\n    public final double im;\n\n    public Complex() {\n        this(0, 0);\n    }\n\n    public Complex(double r, double i) {\n        re = r;\n        im = i;\n    }\n\n    public Complex add(Complex b) {\n        return new Complex(this.re + b.re, this.im + b.im);\n    }\n\n    public Complex sub(Complex b) {\n        return new Complex(this.re - b.re, this.im - b.im);\n    }\n\n    public Complex mult(Complex b) {\n        return new Complex(this.re * b.re - this.im * b.im,\n                this.re * b.im + this.im * b.re);\n    }\n\n    @Override\n    public String toString() {\n        return String.format(\"(%f,%f)\", re, im);\n    }\n}\n"}
{"id": 142709, "name": "Fast Fourier transform", "source": "Translate Fortran to Java: module fft_mod\n  implicit none\n  integer,       parameter :: dp=selected_real_kind(15,300)\n  real(kind=dp), parameter :: pi=3.141592653589793238460_dp\ncontains\n\n  \n  recursive subroutine fft(x)\n    complex(kind=dp), dimension(:), intent(inout)  :: x\n    complex(kind=dp)                               :: t\n    integer                                        :: N\n    integer                                        :: i\n    complex(kind=dp), dimension(:), allocatable    :: even, odd\n\n    N=size(x)\n\n    if(N .le. 1) return\n\n    allocate(odd((N+1)/2))\n    allocate(even(N/2))\n\n    \n    odd =x(1:N:2)\n    even=x(2:N:2)\n\n    \n    call fft(odd)\n    call fft(even)\n\n    \n    do i=1,N/2\n       t=exp(cmplx(0.0_dp,-2.0_dp*pi*real(i-1,dp)/real(N,dp),kind=dp))*even(i)\n       x(i)     = odd(i) + t\n       x(i+N/2) = odd(i) - t\n    end do\n\n    deallocate(odd)\n    deallocate(even)\n\n  end subroutine fft\n\nend module fft_mod\n\nprogram test\n  use fft_mod\n  implicit none\n  complex(kind=dp), dimension(8) :: data = (/1.0, 1.0, 1.0, 1.0, 0.0, \n\n0.0, 0.0, 0.0/)\n  integer :: i\n\n  call fft(data)\n\n  do i=1,8\n     write(*,'(\"(\", F20.15, \",\", F20.15, \"i )\")') data(i)\n  end do\n\nend program test\n", "target": "import static java.lang.Math.*;\n\npublic class FastFourierTransform {\n\n    public static int bitReverse(int n, int bits) {\n        int reversedN = n;\n        int count = bits - 1;\n\n        n >>= 1;\n        while (n > 0) {\n            reversedN = (reversedN << 1) | (n & 1);\n            count--;\n            n >>= 1;\n        }\n\n        return ((reversedN << count) & ((1 << bits) - 1));\n    }\n\n    static void fft(Complex[] buffer) {\n\n        int bits = (int) (log(buffer.length) / log(2));\n        for (int j = 1; j < buffer.length / 2; j++) {\n\n            int swapPos = bitReverse(j, bits);\n            Complex temp = buffer[j];\n            buffer[j] = buffer[swapPos];\n            buffer[swapPos] = temp;\n        }\n\n        for (int N = 2; N <= buffer.length; N <<= 1) {\n            for (int i = 0; i < buffer.length; i += N) {\n                for (int k = 0; k < N / 2; k++) {\n\n                    int evenIndex = i + k;\n                    int oddIndex = i + k + (N / 2);\n                    Complex even = buffer[evenIndex];\n                    Complex odd = buffer[oddIndex];\n\n                    double term = (-2 * PI * k) / (double) N;\n                    Complex exp = (new Complex(cos(term), sin(term)).mult(odd));\n\n                    buffer[evenIndex] = even.add(exp);\n                    buffer[oddIndex] = even.sub(exp);\n                }\n            }\n        }\n    }\n\n    public static void main(String[] args) {\n        double[] input = {1.0, 1.0, 1.0, 1.0, 0.0, 0.0, 0.0, 0.0};\n\n        Complex[] cinput = new Complex[input.length];\n        for (int i = 0; i < input.length; i++)\n            cinput[i] = new Complex(input[i], 0.0);\n\n        fft(cinput);\n\n        System.out.println(\"Results:\");\n        for (Complex c : cinput) {\n            System.out.println(c);\n        }\n    }\n}\n\nclass Complex {\n    public final double re;\n    public final double im;\n\n    public Complex() {\n        this(0, 0);\n    }\n\n    public Complex(double r, double i) {\n        re = r;\n        im = i;\n    }\n\n    public Complex add(Complex b) {\n        return new Complex(this.re + b.re, this.im + b.im);\n    }\n\n    public Complex sub(Complex b) {\n        return new Complex(this.re - b.re, this.im - b.im);\n    }\n\n    public Complex mult(Complex b) {\n        return new Complex(this.re * b.re - this.im * b.im,\n                this.re * b.im + this.im * b.re);\n    }\n\n    @Override\n    public String toString() {\n        return String.format(\"(%f,%f)\", re, im);\n    }\n}\n"}
{"id": 142710, "name": "Fast Fourier transform", "source": "Translate Fortran to Python: module fft_mod\n  implicit none\n  integer,       parameter :: dp=selected_real_kind(15,300)\n  real(kind=dp), parameter :: pi=3.141592653589793238460_dp\ncontains\n\n  \n  recursive subroutine fft(x)\n    complex(kind=dp), dimension(:), intent(inout)  :: x\n    complex(kind=dp)                               :: t\n    integer                                        :: N\n    integer                                        :: i\n    complex(kind=dp), dimension(:), allocatable    :: even, odd\n\n    N=size(x)\n\n    if(N .le. 1) return\n\n    allocate(odd((N+1)/2))\n    allocate(even(N/2))\n\n    \n    odd =x(1:N:2)\n    even=x(2:N:2)\n\n    \n    call fft(odd)\n    call fft(even)\n\n    \n    do i=1,N/2\n       t=exp(cmplx(0.0_dp,-2.0_dp*pi*real(i-1,dp)/real(N,dp),kind=dp))*even(i)\n       x(i)     = odd(i) + t\n       x(i+N/2) = odd(i) - t\n    end do\n\n    deallocate(odd)\n    deallocate(even)\n\n  end subroutine fft\n\nend module fft_mod\n\nprogram test\n  use fft_mod\n  implicit none\n  complex(kind=dp), dimension(8) :: data = (/1.0, 1.0, 1.0, 1.0, 0.0, \n\n0.0, 0.0, 0.0/)\n  integer :: i\n\n  call fft(data)\n\n  do i=1,8\n     write(*,'(\"(\", F20.15, \",\", F20.15, \"i )\")') data(i)\n  end do\n\nend program test\n", "target": "from cmath import exp, pi\n\ndef fft(x):\n    N = len(x)\n    if N <= 1: return x\n    even = fft(x[0::2])\n    odd =  fft(x[1::2])\n    T= [exp(-2j*pi*k/N)*odd[k] for k in range(N//2)]\n    return [even[k] + T[k] for k in range(N//2)] + \\\n           [even[k] - T[k] for k in range(N//2)]\n\nprint( ' '.join(\"%5.3f\" % abs(f) \n                for f in fft([1.0, 1.0, 1.0, 1.0, 0.0, 0.0, 0.0, 0.0])) )\n"}
{"id": 142711, "name": "Fast Fourier transform", "source": "Translate Fortran to Python: module fft_mod\n  implicit none\n  integer,       parameter :: dp=selected_real_kind(15,300)\n  real(kind=dp), parameter :: pi=3.141592653589793238460_dp\ncontains\n\n  \n  recursive subroutine fft(x)\n    complex(kind=dp), dimension(:), intent(inout)  :: x\n    complex(kind=dp)                               :: t\n    integer                                        :: N\n    integer                                        :: i\n    complex(kind=dp), dimension(:), allocatable    :: even, odd\n\n    N=size(x)\n\n    if(N .le. 1) return\n\n    allocate(odd((N+1)/2))\n    allocate(even(N/2))\n\n    \n    odd =x(1:N:2)\n    even=x(2:N:2)\n\n    \n    call fft(odd)\n    call fft(even)\n\n    \n    do i=1,N/2\n       t=exp(cmplx(0.0_dp,-2.0_dp*pi*real(i-1,dp)/real(N,dp),kind=dp))*even(i)\n       x(i)     = odd(i) + t\n       x(i+N/2) = odd(i) - t\n    end do\n\n    deallocate(odd)\n    deallocate(even)\n\n  end subroutine fft\n\nend module fft_mod\n\nprogram test\n  use fft_mod\n  implicit none\n  complex(kind=dp), dimension(8) :: data = (/1.0, 1.0, 1.0, 1.0, 0.0, \n\n0.0, 0.0, 0.0/)\n  integer :: i\n\n  call fft(data)\n\n  do i=1,8\n     write(*,'(\"(\", F20.15, \",\", F20.15, \"i )\")') data(i)\n  end do\n\nend program test\n", "target": "from cmath import exp, pi\n\ndef fft(x):\n    N = len(x)\n    if N <= 1: return x\n    even = fft(x[0::2])\n    odd =  fft(x[1::2])\n    T= [exp(-2j*pi*k/N)*odd[k] for k in range(N//2)]\n    return [even[k] + T[k] for k in range(N//2)] + \\\n           [even[k] - T[k] for k in range(N//2)]\n\nprint( ' '.join(\"%5.3f\" % abs(f) \n                for f in fft([1.0, 1.0, 1.0, 1.0, 0.0, 0.0, 0.0, 0.0])) )\n"}
{"id": 143083, "name": "Increment a numerical string", "source": "Translate Fortran to C#: CHARACTER(10) :: intstr = \"12345\", realstr = \"1234.5\"\nINTEGER :: i\nREAL :: r\n \nREAD(intstr, \"(I10)\") i        \ni = i + 1                      \nWRITE(intstr, \"(I10)\") i       \n\nREAD(realstr, \"(F10.1)\") r \t\nr = r + 1.0\t\t\t\t\nWRITE(realstr, \"(F10.1)\") r\n", "target": "string s = \"12345\";\ns = (int.Parse(s) + 1).ToString();\n\n\n\n\n\n\nusing System.Numerics;\nstring bis = \"123456789012345678999999999\";\nbis = (BigInteger.Parse(bis) + 1).ToString();\n\n\n"}
{"id": 143086, "name": "Increment a numerical string", "source": "Translate Fortran to Java: CHARACTER(10) :: intstr = \"12345\", realstr = \"1234.5\"\nINTEGER :: i\nREAL :: r\n \nREAD(intstr, \"(I10)\") i        \ni = i + 1                      \nWRITE(intstr, \"(I10)\") i       \n\nREAD(realstr, \"(F10.1)\") r \t\nr = r + 1.0\t\t\t\t\nWRITE(realstr, \"(F10.1)\") r\n", "target": "String s = \"12345\";\nIntLiteral lit1 = new IntLiteral(s);\nIntLiteral lit2 = 6789;\n++lit1; \n++lit2; \n"}
{"id": 143087, "name": "Increment a numerical string", "source": "Translate Fortran to Python: CHARACTER(10) :: intstr = \"12345\", realstr = \"1234.5\"\nINTEGER :: i\nREAL :: r\n \nREAD(intstr, \"(I10)\") i        \ni = i + 1                      \nWRITE(intstr, \"(I10)\") i       \n\nREAD(realstr, \"(F10.1)\") r \t\nr = r + 1.0\t\t\t\t\nWRITE(realstr, \"(F10.1)\") r\n", "target": "next = str(int('123') + 1)\n"}
{"id": 143439, "name": "Gamma function", "source": "Translate Fortran to C#: program ComputeGammaInt\n\n  implicit none\n\n  integer :: i\n\n  write(*, \"(3A15)\") \"Simpson\", \"Lanczos\", \"Builtin\"\n  do i=1, 10\n     write(*, \"(3F15.8)\") my_gamma(i/3.0), lacz_gamma(i/3.0), gamma(i/3.0)\n  end do\n\ncontains\n\n  pure function intfuncgamma(x, y) result(z)\n    real :: z\n    real, intent(in) :: x, y\n    \n    z = x**(y-1.0) * exp(-x)\n  end function intfuncgamma\n\n\n  function my_gamma(a) result(g)\n    real :: g\n    real, intent(in) :: a\n\n    real, parameter :: small = 1.0e-4\n    integer, parameter :: points = 100000\n\n    real :: infty, dx, p, sp(2, points), x\n    integer :: i\n    logical :: correction\n\n    x = a\n\n    correction = .false.\n    \n    \n    \n    if ( x < 1.0 ) then\n       correction = .true.\n       x = x + 1\n    end if\n\n    \n    \n    \n    \n    infty = 1.0e4\n    do while ( intfuncgamma(infty, x) > small )\n       infty = infty * 10.0\n    end do\n\n    \n    dx = infty/real(points)\n    sp = 0.0\n    forall(i=1:points/2-1) sp(1, 2*i) = intfuncgamma(2.0*(i)*dx, x)\n    forall(i=1:points/2) sp(2, 2*i - 1) = intfuncgamma((2.0*(i)-1.0)*dx, x)\n    g = (intfuncgamma(0.0, x) + 2.0*sum(sp(1,:)) + 4.0*sum(sp(2,:)) + &\n         intfuncgamma(infty, x))*dx/3.0\n\n    if ( correction ) g = g/a\n\n  end function my_gamma\n\n  \n  recursive function lacz_gamma(a) result(g)\n    real, intent(in) :: a\n    real :: g\n\n    real, parameter :: pi = 3.14159265358979324\n    integer, parameter :: cg = 7\n\n    \n    \n    real, dimension(0:8), parameter :: p = &\n         (/ 0.99999999999980993, 676.5203681218851, -1259.1392167224028, &\n         771.32342877765313, -176.61502916214059, 12.507343278686905, &\n         -0.13857109526572012, 9.9843695780195716e-6, 1.5056327351493116e-7 /)\n\n    real :: t, w, x\n    integer :: i\n\n    x = a\n\n    if ( x < 0.5 ) then\n       g = pi / ( sin(pi*x) * lacz_gamma(1.0-x) )\n    else\n       x = x - 1.0\n       t = p(0)\n       do i=1, cg+2\n          t = t + p(i)/(x+real(i))\n       end do\n       w = x + real(cg) + 0.5\n       g = sqrt(2.0*pi) * w**(x+0.5) * exp(-w) * t\n    end if\n  end function lacz_gamma\n\nend program ComputeGammaInt\n", "target": "using System;\nusing System.Numerics;\n\nstatic int g = 7;\nstatic double[] p = {0.99999999999980993, 676.5203681218851, -1259.1392167224028,\n\t     771.32342877765313, -176.61502916214059, 12.507343278686905,\n\t     -0.13857109526572012, 9.9843695780195716e-6, 1.5056327351493116e-7};\n\t\t \nComplex Gamma(Complex z)\n{\n    \n    if (z.Real < 0.5)\n\t{\n        return Math.PI / (Complex.Sin( Math.PI * z) * Gamma(1 - z));\n\t}\n    else\n\t{\n        z -= 1;\n        Complex x = p[0];\n        for (var i = 1; i < g + 2; i++)\n\t\t{\n            x += p[i]/(z+i);\n\t\t}\n        Complex t = z + g + 0.5;\n        return Complex.Sqrt(2 * Math.PI) * (Complex.Pow(t, z + 0.5)) * Complex.Exp(-t) * x;\n\t}\n}\n"}
{"id": 143442, "name": "Gamma function", "source": "Translate Fortran to Java: program ComputeGammaInt\n\n  implicit none\n\n  integer :: i\n\n  write(*, \"(3A15)\") \"Simpson\", \"Lanczos\", \"Builtin\"\n  do i=1, 10\n     write(*, \"(3F15.8)\") my_gamma(i/3.0), lacz_gamma(i/3.0), gamma(i/3.0)\n  end do\n\ncontains\n\n  pure function intfuncgamma(x, y) result(z)\n    real :: z\n    real, intent(in) :: x, y\n    \n    z = x**(y-1.0) * exp(-x)\n  end function intfuncgamma\n\n\n  function my_gamma(a) result(g)\n    real :: g\n    real, intent(in) :: a\n\n    real, parameter :: small = 1.0e-4\n    integer, parameter :: points = 100000\n\n    real :: infty, dx, p, sp(2, points), x\n    integer :: i\n    logical :: correction\n\n    x = a\n\n    correction = .false.\n    \n    \n    \n    if ( x < 1.0 ) then\n       correction = .true.\n       x = x + 1\n    end if\n\n    \n    \n    \n    \n    infty = 1.0e4\n    do while ( intfuncgamma(infty, x) > small )\n       infty = infty * 10.0\n    end do\n\n    \n    dx = infty/real(points)\n    sp = 0.0\n    forall(i=1:points/2-1) sp(1, 2*i) = intfuncgamma(2.0*(i)*dx, x)\n    forall(i=1:points/2) sp(2, 2*i - 1) = intfuncgamma((2.0*(i)-1.0)*dx, x)\n    g = (intfuncgamma(0.0, x) + 2.0*sum(sp(1,:)) + 4.0*sum(sp(2,:)) + &\n         intfuncgamma(infty, x))*dx/3.0\n\n    if ( correction ) g = g/a\n\n  end function my_gamma\n\n  \n  recursive function lacz_gamma(a) result(g)\n    real, intent(in) :: a\n    real :: g\n\n    real, parameter :: pi = 3.14159265358979324\n    integer, parameter :: cg = 7\n\n    \n    \n    real, dimension(0:8), parameter :: p = &\n         (/ 0.99999999999980993, 676.5203681218851, -1259.1392167224028, &\n         771.32342877765313, -176.61502916214059, 12.507343278686905, &\n         -0.13857109526572012, 9.9843695780195716e-6, 1.5056327351493116e-7 /)\n\n    real :: t, w, x\n    integer :: i\n\n    x = a\n\n    if ( x < 0.5 ) then\n       g = pi / ( sin(pi*x) * lacz_gamma(1.0-x) )\n    else\n       x = x - 1.0\n       t = p(0)\n       do i=1, cg+2\n          t = t + p(i)/(x+real(i))\n       end do\n       w = x + real(cg) + 0.5\n       g = sqrt(2.0*pi) * w**(x+0.5) * exp(-w) * t\n    end if\n  end function lacz_gamma\n\nend program ComputeGammaInt\n", "target": "public class GammaFunction {\n\n\tpublic double st_gamma(double x){\n\t\treturn Math.sqrt(2*Math.PI/x)*Math.pow((x/Math.E), x);\n\t}\n\t\n\tpublic double la_gamma(double x){\n\t\tdouble[] p = {0.99999999999980993, 676.5203681218851, -1259.1392167224028,\n\t\t\t     \t  771.32342877765313, -176.61502916214059, 12.507343278686905,\n\t\t\t     \t  -0.13857109526572012, 9.9843695780195716e-6, 1.5056327351493116e-7};\n\t\tint g = 7;\n\t\tif(x < 0.5) return Math.PI / (Math.sin(Math.PI * x)*la_gamma(1-x));\n\n\t\tx -= 1;\n\t\tdouble a = p[0];\n\t\tdouble t = x+g+0.5;\n\t\tfor(int i = 1; i < p.length; i++){\n\t\t\ta += p[i]/(x+i);\n\t\t}\n\t\t\n\t\treturn Math.sqrt(2*Math.PI)*Math.pow(t, x+0.5)*Math.exp(-t)*a;\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tGammaFunction test = new GammaFunction();\n\t\tSystem.out.println(\"Gamma \\t\\tStirling \\t\\tLanczos\");\n\t\tfor(double i = 1; i <= 20; i += 1){\n\t\t\tSystem.out.println(\"\" + i/10.0 + \"\\t\\t\" + test.st_gamma(i/10.0) + \"\\t\" + test.la_gamma(i/10.0));\n\t\t}\n\t}\n}\n"}
{"id": 143443, "name": "Gamma function", "source": "Translate Fortran to Python: program ComputeGammaInt\n\n  implicit none\n\n  integer :: i\n\n  write(*, \"(3A15)\") \"Simpson\", \"Lanczos\", \"Builtin\"\n  do i=1, 10\n     write(*, \"(3F15.8)\") my_gamma(i/3.0), lacz_gamma(i/3.0), gamma(i/3.0)\n  end do\n\ncontains\n\n  pure function intfuncgamma(x, y) result(z)\n    real :: z\n    real, intent(in) :: x, y\n    \n    z = x**(y-1.0) * exp(-x)\n  end function intfuncgamma\n\n\n  function my_gamma(a) result(g)\n    real :: g\n    real, intent(in) :: a\n\n    real, parameter :: small = 1.0e-4\n    integer, parameter :: points = 100000\n\n    real :: infty, dx, p, sp(2, points), x\n    integer :: i\n    logical :: correction\n\n    x = a\n\n    correction = .false.\n    \n    \n    \n    if ( x < 1.0 ) then\n       correction = .true.\n       x = x + 1\n    end if\n\n    \n    \n    \n    \n    infty = 1.0e4\n    do while ( intfuncgamma(infty, x) > small )\n       infty = infty * 10.0\n    end do\n\n    \n    dx = infty/real(points)\n    sp = 0.0\n    forall(i=1:points/2-1) sp(1, 2*i) = intfuncgamma(2.0*(i)*dx, x)\n    forall(i=1:points/2) sp(2, 2*i - 1) = intfuncgamma((2.0*(i)-1.0)*dx, x)\n    g = (intfuncgamma(0.0, x) + 2.0*sum(sp(1,:)) + 4.0*sum(sp(2,:)) + &\n         intfuncgamma(infty, x))*dx/3.0\n\n    if ( correction ) g = g/a\n\n  end function my_gamma\n\n  \n  recursive function lacz_gamma(a) result(g)\n    real, intent(in) :: a\n    real :: g\n\n    real, parameter :: pi = 3.14159265358979324\n    integer, parameter :: cg = 7\n\n    \n    \n    real, dimension(0:8), parameter :: p = &\n         (/ 0.99999999999980993, 676.5203681218851, -1259.1392167224028, &\n         771.32342877765313, -176.61502916214059, 12.507343278686905, &\n         -0.13857109526572012, 9.9843695780195716e-6, 1.5056327351493116e-7 /)\n\n    real :: t, w, x\n    integer :: i\n\n    x = a\n\n    if ( x < 0.5 ) then\n       g = pi / ( sin(pi*x) * lacz_gamma(1.0-x) )\n    else\n       x = x - 1.0\n       t = p(0)\n       do i=1, cg+2\n          t = t + p(i)/(x+real(i))\n       end do\n       w = x + real(cg) + 0.5\n       g = sqrt(2.0*pi) * w**(x+0.5) * exp(-w) * t\n    end if\n  end function lacz_gamma\n\nend program ComputeGammaInt\n", "target": "_a =    ( 1.00000000000000000000, 0.57721566490153286061, -0.65587807152025388108,\n         -0.04200263503409523553, 0.16653861138229148950, -0.04219773455554433675,\n         -0.00962197152787697356, 0.00721894324666309954, -0.00116516759185906511,\n         -0.00021524167411495097, 0.00012805028238811619, -0.00002013485478078824,\n         -0.00000125049348214267, 0.00000113302723198170, -0.00000020563384169776,\n          0.00000000611609510448, 0.00000000500200764447, -0.00000000118127457049,\n          0.00000000010434267117, 0.00000000000778226344, -0.00000000000369680562,\n          0.00000000000051003703, -0.00000000000002058326, -0.00000000000000534812,\n          0.00000000000000122678, -0.00000000000000011813, 0.00000000000000000119,\n          0.00000000000000000141, -0.00000000000000000023, 0.00000000000000000002\n       )\ndef gamma (x): \n   y  = float(x) - 1.0;\n   sm = _a[-1];\n   for an in _a[-2::-1]:\n      sm = sm * y + an;\n   return 1.0 / sm;\n \n\nif __name__ == '__main__':\n    for i in range(1,11):\n        print \"  %20.14e\" % gamma(i/3.0)\n"}
{"id": 143599, "name": "Polynomial long division", "source": "Translate Fortran to C#: module Polynom\n  implicit none\n\ncontains\n\n  subroutine poly_long_div(n, d, q, r)\n    real, dimension(:), intent(in) :: n, d\n    real, dimension(:), intent(out), allocatable :: q\n    real, dimension(:), intent(out), allocatable, optional :: r\n\n    real, dimension(:), allocatable :: nt, dt, rt\n    integer :: gn, gt, gd\n\n    if ( (size(n) >= size(d)) .and. (size(d) > 0) .and. (size(n) > 0) ) then  \n       allocate(nt(size(n)), dt(size(n)), rt(size(n)))\n\n       nt = n\n       dt = 0\n       dt(1:size(d)) = d\n       rt = 0\n       gn = size(n)-1\n       gd = size(d)-1\n       gt = 0\n\n       do while ( d(gd+1) == 0 )\n          gd = gd - 1\n       end do\n\n       do while( gn >= gd )\n          dt = eoshift(dt, -(gn-gd))\n          rt(gn-gd+1) = nt(gn+1) / dt(gn+1)\n          nt = nt - dt * rt(gn-gd+1)\n          gt = max(gt, gn-gd)\n          do\n             gn = gn - 1\n             if ( nt(gn+1) /= 0 ) exit\n          end do\n          dt = 0\n          dt(1:size(d)) = d\n       end do\n\n       allocate(q(gt+1))\n       q = rt(1:gt+1)\n       if ( present(r) ) then\n          if ( (gn+1) > 0 ) then\n             allocate(r(gn+1))\n             r = nt(1:gn+1)\n          else\n             allocate(r(1))\n             r = 0.0\n          end if\n       end if\n       deallocate(nt, dt, rt)\n    else\n       allocate(q(1))\n       q = 0\n       if ( present(r) ) then\n          allocate(r(size(n)))\n          r = n\n       end if\n    end if\n\n  end subroutine poly_long_div\n\n  subroutine poly_print(p)\n    real, dimension(:), intent(in) :: p\n\n    integer :: i\n\n    do i = size(p), 1, -1\n       if ( i > 1 ) then\n          write(*, '(F0.2,\"x^\",I0,\" + \")', advance=\"no\") p(i), i-1\n       else\n          write(*, '(F0.2)') p(i)\n       end if\n    end do\n\n  end subroutine poly_print\n\nend module Polynom\n", "target": "using System;\n\nnamespace PolynomialLongDivision {\n    class Solution {\n        public Solution(double[] q, double[] r) {\n            Quotient = q;\n            Remainder = r;\n        }\n\n        public double[] Quotient { get; }\n        public double[] Remainder { get; }\n    }\n\n    class Program {\n        static int PolyDegree(double[] p) {\n            for (int i = p.Length - 1; i >= 0; --i) {\n                if (p[i] != 0.0) return i;\n            }\n            return int.MinValue;\n        }\n\n        static double[] PolyShiftRight(double[] p, int places) {\n            if (places <= 0) return p;\n            int pd = PolyDegree(p);\n            if (pd + places >= p.Length) {\n                throw new ArgumentOutOfRangeException(\"The number of places to be shifted is too large\");\n            }\n            double[] d = new double[p.Length];\n            p.CopyTo(d, 0);\n            for (int i = pd; i >= 0; --i) {\n                d[i + places] = d[i];\n                d[i] = 0.0;\n            }\n            return d;\n        }\n\n        static void PolyMultiply(double[] p, double m) {\n            for (int i = 0; i < p.Length; ++i) {\n                p[i] *= m;\n            }\n        }\n\n        static void PolySubtract(double[] p, double[] s) {\n            for (int i = 0; i < p.Length; ++i) {\n                p[i] -= s[i];\n            }\n        }\n\n        static Solution PolyLongDiv(double[] n, double[] d) {\n            if (n.Length != d.Length) {\n                throw new ArgumentException(\"Numerator and denominator vectors must have the same size\");\n            }\n            int nd = PolyDegree(n);\n            int dd = PolyDegree(d);\n            if (dd < 0) {\n                throw new ArgumentException(\"Divisor must have at least one one-zero coefficient\");\n            }\n            if (nd < dd) {\n                throw new ArgumentException(\"The degree of the divisor cannot exceed that of the numerator\");\n            }\n            double[] n2 = new double[n.Length];\n            n.CopyTo(n2, 0);\n            double[] q = new double[n.Length];\n            while (nd >= dd) {\n                double[] d2 = PolyShiftRight(d, nd - dd);\n                q[nd - dd] = n2[nd] / d2[nd];\n                PolyMultiply(d2, q[nd - dd]);\n                PolySubtract(n2, d2);\n                nd = PolyDegree(n2);\n            }\n            return new Solution(q, n2);\n        }\n\n        static void PolyShow(double[] p) {\n            int pd = PolyDegree(p);\n            for (int i = pd; i >= 0; --i) {\n                double coeff = p[i];\n                if (coeff == 0.0) continue;\n                if (coeff == 1.0) {\n                    if (i < pd) {\n                        Console.Write(\" + \");\n                    }\n                } else if (coeff == -1.0) {\n                    if (i < pd) {\n                        Console.Write(\" - \");\n                    } else {\n                        Console.Write(\"-\");\n                    }\n                } else if (coeff < 0.0) {\n                    if (i < pd) {\n                        Console.Write(\" - {0:F1}\", -coeff);\n                    } else {\n                        Console.Write(\"{0:F1}\", coeff);\n                    }\n                } else {\n                    if (i < pd) {\n                        Console.Write(\" + {0:F1}\", coeff);\n                    } else {\n                        Console.Write(\"{0:F1}\", coeff);\n                    }\n                }\n                if (i > 1) Console.Write(\"x^{0}\", i);\n                else if (i == 1) Console.Write(\"x\");\n            }\n            Console.WriteLine();\n        }\n\n        static void Main(string[] args) {\n            double[] n = { -42.0, 0.0, -12.0, 1.0 };\n            double[] d = { -3.0, 1.0, 0.0, 0.0 };\n            Console.Write(\"Numerator  \u00a0: \");\n            PolyShow(n);\n            Console.Write(\"Denominator\u00a0: \");\n            PolyShow(d);\n            Console.WriteLine(\"-------------------------------------\");\n            Solution sol = PolyLongDiv(n, d);\n            Console.Write(\"Quotient   \u00a0: \");\n            PolyShow(sol.Quotient);\n            Console.Write(\"Remainder  \u00a0: \");\n            PolyShow(sol.Remainder);\n        }\n    }\n}\n"}
{"id": 143602, "name": "Polynomial long division", "source": "Translate Fortran to Python: module Polynom\n  implicit none\n\ncontains\n\n  subroutine poly_long_div(n, d, q, r)\n    real, dimension(:), intent(in) :: n, d\n    real, dimension(:), intent(out), allocatable :: q\n    real, dimension(:), intent(out), allocatable, optional :: r\n\n    real, dimension(:), allocatable :: nt, dt, rt\n    integer :: gn, gt, gd\n\n    if ( (size(n) >= size(d)) .and. (size(d) > 0) .and. (size(n) > 0) ) then  \n       allocate(nt(size(n)), dt(size(n)), rt(size(n)))\n\n       nt = n\n       dt = 0\n       dt(1:size(d)) = d\n       rt = 0\n       gn = size(n)-1\n       gd = size(d)-1\n       gt = 0\n\n       do while ( d(gd+1) == 0 )\n          gd = gd - 1\n       end do\n\n       do while( gn >= gd )\n          dt = eoshift(dt, -(gn-gd))\n          rt(gn-gd+1) = nt(gn+1) / dt(gn+1)\n          nt = nt - dt * rt(gn-gd+1)\n          gt = max(gt, gn-gd)\n          do\n             gn = gn - 1\n             if ( nt(gn+1) /= 0 ) exit\n          end do\n          dt = 0\n          dt(1:size(d)) = d\n       end do\n\n       allocate(q(gt+1))\n       q = rt(1:gt+1)\n       if ( present(r) ) then\n          if ( (gn+1) > 0 ) then\n             allocate(r(gn+1))\n             r = nt(1:gn+1)\n          else\n             allocate(r(1))\n             r = 0.0\n          end if\n       end if\n       deallocate(nt, dt, rt)\n    else\n       allocate(q(1))\n       q = 0\n       if ( present(r) ) then\n          allocate(r(size(n)))\n          r = n\n       end if\n    end if\n\n  end subroutine poly_long_div\n\n  subroutine poly_print(p)\n    real, dimension(:), intent(in) :: p\n\n    integer :: i\n\n    do i = size(p), 1, -1\n       if ( i > 1 ) then\n          write(*, '(F0.2,\"x^\",I0,\" + \")', advance=\"no\") p(i), i-1\n       else\n          write(*, '(F0.2)') p(i)\n       end if\n    end do\n\n  end subroutine poly_print\n\nend module Polynom\n", "target": "\n\nfrom itertools import izip\n\ndef degree(poly):\n    while poly and poly[-1] == 0:\n        poly.pop()   \n    return len(poly)-1\n\ndef poly_div(N, D):\n    dD = degree(D)\n    dN = degree(N)\n    if dD < 0: raise ZeroDivisionError\n    if dN >= dD:\n        q = [0] * dN\n        while dN >= dD:\n            d = [0]*(dN - dD) + D\n            mult = q[dN - dD] = N[-1] / float(d[-1])\n            d = [coeff*mult for coeff in d]\n            N = [coeffN - coeffd for coeffN, coeffd in izip(N, d)]\n            dN = degree(N)\n        r = N\n    else:\n        q = [0]\n        r = N\n    return q, r\n\nif __name__ == '__main__':\n    print \"POLYNOMIAL LONG DIVISION\"\n    N = [-42, 0, -12, 1]\n    D = [-3, 1, 0, 0]\n    print \"  %s / %s =\" % (N,D),\n    print \" %s remainder %s\" % poly_div(N, D)\n"}
{"id": 144249, "name": "Terminal control_Clear the screen", "source": "Translate Fortran to C#: program clear\n    character(len=:), allocatable :: clear_command\n    clear_command = \"clear\" \n    call execute_command_line(clear_command)\nend program\n", "target": "System.Console.Clear();\n"}
{"id": 144251, "name": "Terminal control_Clear the screen", "source": "Translate Fortran to Java: program clear\n    character(len=:), allocatable :: clear_command\n    clear_command = \"clear\" \n    call execute_command_line(clear_command)\nend program\n", "target": "public class Clear\n{\n    public static void main (String[] args)\n    {\n        System.out.print(\"\\033[2J\");\n    }\n}\n"}
{"id": 144252, "name": "Terminal control_Clear the screen", "source": "Translate Fortran to Python: program clear\n    character(len=:), allocatable :: clear_command\n    clear_command = \"clear\" \n    call execute_command_line(clear_command)\nend program\n", "target": "import os\nos.system(\"clear\")\n"}
{"id": 144389, "name": "Arbitrary-precision integers (included)", "source": "Translate Fortran to C#: program bignum\n    use fmzm\n    implicit none\n    type(im) :: a\n    integer :: n\n    \n    call fm_set(50)\n    a = to_im(5)**(to_im(4)**(to_im(3)**to_im(2)))\n    n = to_int(floor(log10(to_fm(a))))\n    call im_print(a / to_im(10)**(n - 19))\n    call im_print(mod(a, to_im(10)**20))\nend program\n", "target": "using System;\nusing System.Diagnostics;\nusing System.Linq;\nusing System.Numerics;\n\nstatic class Program {\n    static void Main() {\n        BigInteger n = BigInteger.Pow(5, (int)BigInteger.Pow(4, (int)BigInteger.Pow(3, 2)));\n        string result = n.ToString();\n\n        Debug.Assert(result.Length == 183231);\n        Debug.Assert(result.StartsWith(\"62060698786608744707\"));\n        Debug.Assert(result.EndsWith(\"92256259918212890625\"));\n\n        Console.WriteLine(\"n = 5^4^3^2\");\n        Console.WriteLine(\"n = {0}...{1}\", \n            result.Substring(0, 20),\n            result.Substring(result.Length - 20, 20)\n            );\n\n        Console.WriteLine(\"n digits = {0}\", result.Length);\n    }\n}\n"}
{"id": 144392, "name": "Arbitrary-precision integers (included)", "source": "Translate Fortran to Java: program bignum\n    use fmzm\n    implicit none\n    type(im) :: a\n    integer :: n\n    \n    call fm_set(50)\n    a = to_im(5)**(to_im(4)**(to_im(3)**to_im(2)))\n    n = to_int(floor(log10(to_fm(a))))\n    call im_print(a / to_im(10)**(n - 19))\n    call im_print(mod(a, to_im(10)**20))\nend program\n", "target": "import java.math.BigInteger;\n\nclass IntegerPower {\n    public static void main(String[] args) {\n        BigInteger power = BigInteger.valueOf(5).pow(BigInteger.valueOf(4).pow(BigInteger.valueOf(3).pow(2).intValueExact()).intValueExact());\n        String str = power.toString();\n        int len = str.length();\n        System.out.printf(\"5**4**3**2 = %s...%s and has %d digits%n\",\n                str.substring(0, 20), str.substring(len - 20), len);\n    }\n}\n"}
{"id": 144393, "name": "Arbitrary-precision integers (included)", "source": "Translate Fortran to Python: program bignum\n    use fmzm\n    implicit none\n    type(im) :: a\n    integer :: n\n    \n    call fm_set(50)\n    a = to_im(5)**(to_im(4)**(to_im(3)**to_im(2)))\n    n = to_int(floor(log10(to_fm(a))))\n    call im_print(a / to_im(10)**(n - 19))\n    call im_print(mod(a, to_im(10)**20))\nend program\n", "target": ">>> y = str( 5**4**3**2 )\n>>> print (\"5**4**3**2 = %s...%s and has %i digits\" % (y[:20], y[-20:], len(y)))\n5**4**3**2 = 62060698786608744707...92256259918212890625 and has 183231 digits\n"}
{"id": 144819, "name": "Show ASCII table", "source": "Translate Fortran to C#:        PROGRAM ASCTBL  \n       IMPLICIT NONE\n       INTEGER I, J\n       CHARACTER*3 H\n\n  10   FORMAT (I3, ':', A3, '   ', $)\n  20   FORMAT ()\n       DO J = 0, 15, +1\n         DO I = 32+J, 127, +16\n           IF (I > 32 .AND. I < 127) THEN\n             H = ' ' // ACHAR(I) // ' '\n           ELSE IF (I .EQ. 32) THEN\n             H = 'Spc'\n           ELSE IF (I .EQ. 127) THEN\n             H = 'Del'\n           ELSE\n             STOP 'bad value of i'\n           END IF\n           PRINT 10, I, H\n         END DO\n         PRINT 20\n       END DO\n\n       END\n", "target": "using static System.Console;\nusing static System.Linq.Enumerable;\n\npublic class Program\n{\n    static void Main()\n    {\n        for (int start = 32; start + 16 * 5 < 128; start++) {\n            WriteLine(string.Concat(Range(0, 6).Select(i => $\"{start+16*i, 3}\u00a0: {Text(start+16*i), -6}\")));\n        }\n\n        string Text(int index) => index == 32 ? \"Sp\" : index == 127 ? \"Del\" : (char)index + \"\";\n    }\n}\n"}
{"id": 144820, "name": "Show ASCII table", "source": "Translate Fortran to C#:        PROGRAM ASCTBL  \n       IMPLICIT NONE\n       INTEGER I, J\n       CHARACTER*3 H\n\n  10   FORMAT (I3, ':', A3, '   ', $)\n  20   FORMAT ()\n       DO J = 0, 15, +1\n         DO I = 32+J, 127, +16\n           IF (I > 32 .AND. I < 127) THEN\n             H = ' ' // ACHAR(I) // ' '\n           ELSE IF (I .EQ. 32) THEN\n             H = 'Spc'\n           ELSE IF (I .EQ. 127) THEN\n             H = 'Del'\n           ELSE\n             STOP 'bad value of i'\n           END IF\n           PRINT 10, I, H\n         END DO\n         PRINT 20\n       END DO\n\n       END\n", "target": "using static System.Console;\nusing static System.Linq.Enumerable;\n\npublic class Program\n{\n    static void Main()\n    {\n        for (int start = 32; start + 16 * 5 < 128; start++) {\n            WriteLine(string.Concat(Range(0, 6).Select(i => $\"{start+16*i, 3}\u00a0: {Text(start+16*i), -6}\")));\n        }\n\n        string Text(int index) => index == 32 ? \"Sp\" : index == 127 ? \"Del\" : (char)index + \"\";\n    }\n}\n"}
{"id": 144826, "name": "Show ASCII table", "source": "Translate Fortran to Java:        PROGRAM ASCTBL  \n       IMPLICIT NONE\n       INTEGER I, J\n       CHARACTER*3 H\n\n  10   FORMAT (I3, ':', A3, '   ', $)\n  20   FORMAT ()\n       DO J = 0, 15, +1\n         DO I = 32+J, 127, +16\n           IF (I > 32 .AND. I < 127) THEN\n             H = ' ' // ACHAR(I) // ' '\n           ELSE IF (I .EQ. 32) THEN\n             H = 'Spc'\n           ELSE IF (I .EQ. 127) THEN\n             H = 'Del'\n           ELSE\n             STOP 'bad value of i'\n           END IF\n           PRINT 10, I, H\n         END DO\n         PRINT 20\n       END DO\n\n       END\n", "target": "module test\n    {\n    @Inject Console console;\n    void run()\n        {\n        for (Int offset : 0..<16)\n            {\n            for (Int ascii = 32+offset; ascii < 128; ascii += 16)\n                {\n                console.print($|{ascii.toString().rightJustify(3)}/\\\n                               |{ascii.toByte().toByteArray()}: \\\n                               |{new Char(ascii).quoted().leftJustify(5)}\n                              , suppressNewline=True);\n                }\n            console.print();\n            }\n        }\n    }\n"}
{"id": 144827, "name": "Show ASCII table", "source": "Translate Fortran to Java:        PROGRAM ASCTBL  \n       IMPLICIT NONE\n       INTEGER I, J\n       CHARACTER*3 H\n\n  10   FORMAT (I3, ':', A3, '   ', $)\n  20   FORMAT ()\n       DO J = 0, 15, +1\n         DO I = 32+J, 127, +16\n           IF (I > 32 .AND. I < 127) THEN\n             H = ' ' // ACHAR(I) // ' '\n           ELSE IF (I .EQ. 32) THEN\n             H = 'Spc'\n           ELSE IF (I .EQ. 127) THEN\n             H = 'Del'\n           ELSE\n             STOP 'bad value of i'\n           END IF\n           PRINT 10, I, H\n         END DO\n         PRINT 20\n       END DO\n\n       END\n", "target": "module test\n    {\n    @Inject Console console;\n    void run()\n        {\n        for (Int offset : 0..<16)\n            {\n            for (Int ascii = 32+offset; ascii < 128; ascii += 16)\n                {\n                console.print($|{ascii.toString().rightJustify(3)}/\\\n                               |{ascii.toByte().toByteArray()}: \\\n                               |{new Char(ascii).quoted().leftJustify(5)}\n                              , suppressNewline=True);\n                }\n            console.print();\n            }\n        }\n    }\n"}
{"id": 144828, "name": "Show ASCII table", "source": "Translate Fortran to Python:        PROGRAM ASCTBL  \n       IMPLICIT NONE\n       INTEGER I, J\n       CHARACTER*3 H\n\n  10   FORMAT (I3, ':', A3, '   ', $)\n  20   FORMAT ()\n       DO J = 0, 15, +1\n         DO I = 32+J, 127, +16\n           IF (I > 32 .AND. I < 127) THEN\n             H = ' ' // ACHAR(I) // ' '\n           ELSE IF (I .EQ. 32) THEN\n             H = 'Spc'\n           ELSE IF (I .EQ. 127) THEN\n             H = 'Del'\n           ELSE\n             STOP 'bad value of i'\n           END IF\n           PRINT 10, I, H\n         END DO\n         PRINT 20\n       END DO\n\n       END\n", "target": "for i in range(16):\n    for j in range(32+i, 127+1, 16):\n        if j == 32:\n            k = 'Spc'\n        elif j == 127:\n            k = 'Del'\n        else:\n            k = chr(j)\n        print(\"%3d\u00a0: %-3s\" % (j,k), end=\"\")\n    print()\n"}
{"id": 144829, "name": "Show ASCII table", "source": "Translate Fortran to Python:        PROGRAM ASCTBL  \n       IMPLICIT NONE\n       INTEGER I, J\n       CHARACTER*3 H\n\n  10   FORMAT (I3, ':', A3, '   ', $)\n  20   FORMAT ()\n       DO J = 0, 15, +1\n         DO I = 32+J, 127, +16\n           IF (I > 32 .AND. I < 127) THEN\n             H = ' ' // ACHAR(I) // ' '\n           ELSE IF (I .EQ. 32) THEN\n             H = 'Spc'\n           ELSE IF (I .EQ. 127) THEN\n             H = 'Del'\n           ELSE\n             STOP 'bad value of i'\n           END IF\n           PRINT 10, I, H\n         END DO\n         PRINT 20\n       END DO\n\n       END\n", "target": "for i in range(16):\n    for j in range(32+i, 127+1, 16):\n        if j == 32:\n            k = 'Spc'\n        elif j == 127:\n            k = 'Del'\n        else:\n            k = chr(j)\n        print(\"%3d\u00a0: %-3s\" % (j,k), end=\"\")\n    print()\n"}
{"id": 145201, "name": "Sorting algorithms_Gnome sort", "source": "Translate Fortran to C#: program example\n \n  implicit none\n \n  integer :: array(8) = (/ 2, 8, 6, 1, 3, 5, 4, 7 /)\n\n  call Gnomesort(array)\n  write(*,*) array\n\ncontains\n\nsubroutine Gnomesort(a)\n\n  integer, intent(in out) :: a(:)\n  integer :: i, j, temp\n\n  i = 2\n  j = 3\n  do while (i <= size(a))\n    if (a(i-1) <= a(i)) then\n      i = j\n      j = j + 1\n    else\n      temp = a(i-1)\n      a(i-1) = a(i)\n      a(i) = temp\n      i = i -  1\n      if (i == 1) then\n        i = j\n        j = j + 1\n      end if\n    end if\n  end do\n\nend subroutine Gnomesort\n\nOptimized Version\n\n      SUBROUTINE OPTIMIZEDGNOMESORT(A)     \n      IMPLICIT NONE\n\n\n\n      REAL , DIMENSION(0:)  ::  A\n      INTENT (INOUT) A\n\n\n\n      INTEGER  ::  posy\n\n      DO posy = 1 , UBOUND(A , 1)       \n         CALL GNOMESORT(A , posy)\n      END DO\n      RETURN\n      CONTAINS\n \n      SUBROUTINE GNOMESORT(A , Upperbound)\n      IMPLICIT NONE\n\n\n\n      INTEGER  ::  Upperbound\n      REAL , DIMENSION(0:)  ::  A\n      INTENT (IN) Upperbound\n      INTENT (INOUT) A\n\n\n\n      LOGICAL  ::  eval\n      INTEGER  ::  posy\n      REAL  ::  t\n\n      eval = .FALSE.\n      posy = Upperbound\n      eval = (posy>0) .AND. (A(posy - 1)>A(posy))\n\n      DO WHILE ( eval )\n         t = A(posy)\n         A(posy) = A(posy - 1)\n         A(posy - 1) = t\n\n         posy = posy - 1\n         eval = (posy>0)\n         IF( eval )THEN     \n            eval = (A(posy - 1)>A(posy))\n         ELSE\n            eval = .FALSE.\n         END IF\n      END DO\n      RETURN\n      END SUBROUTINE GNOMESORT\n \n      END SUBROUTINE OPTIMIZEDGNOMESORT\n\n  \nend program example\n", "target": "        public static void gnomeSort(int[] anArray)\n        {\n            int first = 1;\n            int second = 2;\n\n            while (first < anArray.Length)\n            {\n                if (anArray[first - 1] <= anArray[first])\n                {\n                    first = second;\n                    second++;\n                }\n                else\n                {\n                    int tmp = anArray[first - 1];\n                    anArray[first - 1] = anArray[first];\n                    anArray[first] = tmp;\n                    first -= 1;\n                    if (first == 0)\n                    {\n                        first = 1;\n                        second = 2;\n                    }\n                }\n                \n            }\n        }\n"}
{"id": 145204, "name": "Sorting algorithms_Gnome sort", "source": "Translate Fortran to Java: program example\n \n  implicit none\n \n  integer :: array(8) = (/ 2, 8, 6, 1, 3, 5, 4, 7 /)\n\n  call Gnomesort(array)\n  write(*,*) array\n\ncontains\n\nsubroutine Gnomesort(a)\n\n  integer, intent(in out) :: a(:)\n  integer :: i, j, temp\n\n  i = 2\n  j = 3\n  do while (i <= size(a))\n    if (a(i-1) <= a(i)) then\n      i = j\n      j = j + 1\n    else\n      temp = a(i-1)\n      a(i-1) = a(i)\n      a(i) = temp\n      i = i -  1\n      if (i == 1) then\n        i = j\n        j = j + 1\n      end if\n    end if\n  end do\n\nend subroutine Gnomesort\n\nOptimized Version\n\n      SUBROUTINE OPTIMIZEDGNOMESORT(A)     \n      IMPLICIT NONE\n\n\n\n      REAL , DIMENSION(0:)  ::  A\n      INTENT (INOUT) A\n\n\n\n      INTEGER  ::  posy\n\n      DO posy = 1 , UBOUND(A , 1)       \n         CALL GNOMESORT(A , posy)\n      END DO\n      RETURN\n      CONTAINS\n \n      SUBROUTINE GNOMESORT(A , Upperbound)\n      IMPLICIT NONE\n\n\n\n      INTEGER  ::  Upperbound\n      REAL , DIMENSION(0:)  ::  A\n      INTENT (IN) Upperbound\n      INTENT (INOUT) A\n\n\n\n      LOGICAL  ::  eval\n      INTEGER  ::  posy\n      REAL  ::  t\n\n      eval = .FALSE.\n      posy = Upperbound\n      eval = (posy>0) .AND. (A(posy - 1)>A(posy))\n\n      DO WHILE ( eval )\n         t = A(posy)\n         A(posy) = A(posy - 1)\n         A(posy - 1) = t\n\n         posy = posy - 1\n         eval = (posy>0)\n         IF( eval )THEN     \n            eval = (A(posy - 1)>A(posy))\n         ELSE\n            eval = .FALSE.\n         END IF\n      END DO\n      RETURN\n      END SUBROUTINE GNOMESORT\n \n      END SUBROUTINE OPTIMIZEDGNOMESORT\n\n  \nend program example\n", "target": "public static void gnomeSort(int[] a)\n{\n  int i=1;\n  int j=2;\n \n  while(i < a.length) {\n    if ( a[i-1] <= a[i] ) {\n      i = j; j++;\n    } else {\n      int tmp = a[i-1];\n      a[i-1] = a[i];\n      a[i--] = tmp;\n      i = (i==0) ? j++ : i;\n    }\n  }\n}\n"}
{"id": 145205, "name": "Sorting algorithms_Gnome sort", "source": "Translate Fortran to Python: program example\n \n  implicit none\n \n  integer :: array(8) = (/ 2, 8, 6, 1, 3, 5, 4, 7 /)\n\n  call Gnomesort(array)\n  write(*,*) array\n\ncontains\n\nsubroutine Gnomesort(a)\n\n  integer, intent(in out) :: a(:)\n  integer :: i, j, temp\n\n  i = 2\n  j = 3\n  do while (i <= size(a))\n    if (a(i-1) <= a(i)) then\n      i = j\n      j = j + 1\n    else\n      temp = a(i-1)\n      a(i-1) = a(i)\n      a(i) = temp\n      i = i -  1\n      if (i == 1) then\n        i = j\n        j = j + 1\n      end if\n    end if\n  end do\n\nend subroutine Gnomesort\n\nOptimized Version\n\n      SUBROUTINE OPTIMIZEDGNOMESORT(A)     \n      IMPLICIT NONE\n\n\n\n      REAL , DIMENSION(0:)  ::  A\n      INTENT (INOUT) A\n\n\n\n      INTEGER  ::  posy\n\n      DO posy = 1 , UBOUND(A , 1)       \n         CALL GNOMESORT(A , posy)\n      END DO\n      RETURN\n      CONTAINS\n \n      SUBROUTINE GNOMESORT(A , Upperbound)\n      IMPLICIT NONE\n\n\n\n      INTEGER  ::  Upperbound\n      REAL , DIMENSION(0:)  ::  A\n      INTENT (IN) Upperbound\n      INTENT (INOUT) A\n\n\n\n      LOGICAL  ::  eval\n      INTEGER  ::  posy\n      REAL  ::  t\n\n      eval = .FALSE.\n      posy = Upperbound\n      eval = (posy>0) .AND. (A(posy - 1)>A(posy))\n\n      DO WHILE ( eval )\n         t = A(posy)\n         A(posy) = A(posy - 1)\n         A(posy - 1) = t\n\n         posy = posy - 1\n         eval = (posy>0)\n         IF( eval )THEN     \n            eval = (A(posy - 1)>A(posy))\n         ELSE\n            eval = .FALSE.\n         END IF\n      END DO\n      RETURN\n      END SUBROUTINE GNOMESORT\n \n      END SUBROUTINE OPTIMIZEDGNOMESORT\n\n  \nend program example\n", "target": ">>> def gnomesort(a):\n\ti,j,size = 1,2,len(a)\n\twhile i < size:\n\t\tif a[i-1] <= a[i]:\n\t\t\ti,j = j, j+1\n\t\telse:\n\t\t\ta[i-1],a[i] = a[i],a[i-1]\n\t\t\ti -= 1\n\t\t\tif i == 0:\n\t\t\t\ti,j = j, j+1\n\treturn a\n\n>>> gnomesort([3,4,2,5,1,6])\n[1, 2, 3, 4, 5, 6]\n>>>\n"}
{"id": 145930, "name": "Balanced brackets", "source": "Translate Fortran to C#: \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nprogram balanced_brackets\n  implicit none\n  integer :: N\n  character(len=20) :: brackets, fmt\n  write(6,*)'compiles             syntax error'\n  call random_seed\n  do N=0, 10\n     call generate(N, brackets)\n     if (balanced(brackets)) then\n        fmt = '(a,a20)'\n     else\n        fmt = '(a,21x,a20)'\n     end if\n     write(6,fmt)':',brackets\n  end do\n\n  brackets = '[[][[[][]]][]]'\n  if (balanced(brackets)) then\n     fmt = '(a,a20)'\n  else\n     fmt = '(a,21x,a20)'\n  end if\n  write(6,fmt)':',brackets\n\n  N = 10\n  call generate(N, brackets)\n  do while (.not. balanced(brackets)) \n     call generate(N, brackets)\n  end do\n  fmt = '(a,a20)'\n  write(6,fmt)':',brackets\n\ncontains\n\n  logical function balanced(s)\n    implicit none\n    character(len=*), intent(in) :: s\n    integer :: i, a, n\n    n = len_trim(s)\n    a = 0\n    balanced = .true.\n    do i=1, n\n       if (s(i:i) == '[') then\n          a = a+1\n       else\n          a = a-1\n       end if\n       balanced = balanced .and. (0 <= a)\n    end do\n  end function balanced\n\n  subroutine generate(N, s)\n    implicit none\n    integer, intent(in) :: N\n    character(len=*), intent(out) :: s\n    integer :: L, R, i\n    real, dimension(2*N) :: harvest\n    character :: c\n    i = 1\n    L = 0\n    R = 0\n    s = ' '\n    call random_number(harvest)\n    do while ((L < N) .and. (R < N))\n       if (harvest(i) < 0.5) then\n          L = L+1\n          s(i:i) = '['\n       else\n          R = R+1\n          s(i:i) = ']'\n       end if\n       i = i+1\n    end do\n    c = merge('[', ']', L < N)\n    do while (i <= 2*N)\n       s(i:i) = c\n       i = i+1\n    end do\n  end subroutine generate\nend program balanced_brackets\n", "target": "using System;\nusing System.Linq;\n\nclass Program\n{\n    static bool IsBalanced(string text, char open = '[', char close = ']')\n    {\n        var level = 0;\n        foreach (var character in text)\n        {\n            if (character == close)\n            {\n                if (level == 0)\n                {\n                    return false;\n                }\n                level--;\n            }\n            if (character == open)\n            {\n                level++;\n            }\n        }\n        return level == 0;\n    }\n\n    static string RandomBrackets(int count, char open = '[', char close = ']')\n    {\n        var random = new Random();\n        return string.Join(string.Empty,\n                (new string(open, count) + new string(close, count)).OrderBy(c => random.Next()));\n    }\n\n    static void Main()\n    {\n        for (var count = 0; count < 9; count++)\n        {\n            var text = RandomBrackets(count);\n            Console.WriteLine(\"\\\"{0}\\\" is {1}balanced.\", text, IsBalanced(text) ? string.Empty : \"not \");\n        }\n    }\n}\n"}
{"id": 145931, "name": "Balanced brackets", "source": "Translate Fortran to C#: \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nprogram balanced_brackets\n  implicit none\n  integer :: N\n  character(len=20) :: brackets, fmt\n  write(6,*)'compiles             syntax error'\n  call random_seed\n  do N=0, 10\n     call generate(N, brackets)\n     if (balanced(brackets)) then\n        fmt = '(a,a20)'\n     else\n        fmt = '(a,21x,a20)'\n     end if\n     write(6,fmt)':',brackets\n  end do\n\n  brackets = '[[][[[][]]][]]'\n  if (balanced(brackets)) then\n     fmt = '(a,a20)'\n  else\n     fmt = '(a,21x,a20)'\n  end if\n  write(6,fmt)':',brackets\n\n  N = 10\n  call generate(N, brackets)\n  do while (.not. balanced(brackets)) \n     call generate(N, brackets)\n  end do\n  fmt = '(a,a20)'\n  write(6,fmt)':',brackets\n\ncontains\n\n  logical function balanced(s)\n    implicit none\n    character(len=*), intent(in) :: s\n    integer :: i, a, n\n    n = len_trim(s)\n    a = 0\n    balanced = .true.\n    do i=1, n\n       if (s(i:i) == '[') then\n          a = a+1\n       else\n          a = a-1\n       end if\n       balanced = balanced .and. (0 <= a)\n    end do\n  end function balanced\n\n  subroutine generate(N, s)\n    implicit none\n    integer, intent(in) :: N\n    character(len=*), intent(out) :: s\n    integer :: L, R, i\n    real, dimension(2*N) :: harvest\n    character :: c\n    i = 1\n    L = 0\n    R = 0\n    s = ' '\n    call random_number(harvest)\n    do while ((L < N) .and. (R < N))\n       if (harvest(i) < 0.5) then\n          L = L+1\n          s(i:i) = '['\n       else\n          R = R+1\n          s(i:i) = ']'\n       end if\n       i = i+1\n    end do\n    c = merge('[', ']', L < N)\n    do while (i <= 2*N)\n       s(i:i) = c\n       i = i+1\n    end do\n  end subroutine generate\nend program balanced_brackets\n", "target": "using System;\nusing System.Linq;\n\nclass Program\n{\n    static bool IsBalanced(string text, char open = '[', char close = ']')\n    {\n        var level = 0;\n        foreach (var character in text)\n        {\n            if (character == close)\n            {\n                if (level == 0)\n                {\n                    return false;\n                }\n                level--;\n            }\n            if (character == open)\n            {\n                level++;\n            }\n        }\n        return level == 0;\n    }\n\n    static string RandomBrackets(int count, char open = '[', char close = ']')\n    {\n        var random = new Random();\n        return string.Join(string.Empty,\n                (new string(open, count) + new string(close, count)).OrderBy(c => random.Next()));\n    }\n\n    static void Main()\n    {\n        for (var count = 0; count < 9; count++)\n        {\n            var text = RandomBrackets(count);\n            Console.WriteLine(\"\\\"{0}\\\" is {1}balanced.\", text, IsBalanced(text) ? string.Empty : \"not \");\n        }\n    }\n}\n"}
{"id": 145936, "name": "Balanced brackets", "source": "Translate Fortran to Java: \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nprogram balanced_brackets\n  implicit none\n  integer :: N\n  character(len=20) :: brackets, fmt\n  write(6,*)'compiles             syntax error'\n  call random_seed\n  do N=0, 10\n     call generate(N, brackets)\n     if (balanced(brackets)) then\n        fmt = '(a,a20)'\n     else\n        fmt = '(a,21x,a20)'\n     end if\n     write(6,fmt)':',brackets\n  end do\n\n  brackets = '[[][[[][]]][]]'\n  if (balanced(brackets)) then\n     fmt = '(a,a20)'\n  else\n     fmt = '(a,21x,a20)'\n  end if\n  write(6,fmt)':',brackets\n\n  N = 10\n  call generate(N, brackets)\n  do while (.not. balanced(brackets)) \n     call generate(N, brackets)\n  end do\n  fmt = '(a,a20)'\n  write(6,fmt)':',brackets\n\ncontains\n\n  logical function balanced(s)\n    implicit none\n    character(len=*), intent(in) :: s\n    integer :: i, a, n\n    n = len_trim(s)\n    a = 0\n    balanced = .true.\n    do i=1, n\n       if (s(i:i) == '[') then\n          a = a+1\n       else\n          a = a-1\n       end if\n       balanced = balanced .and. (0 <= a)\n    end do\n  end function balanced\n\n  subroutine generate(N, s)\n    implicit none\n    integer, intent(in) :: N\n    character(len=*), intent(out) :: s\n    integer :: L, R, i\n    real, dimension(2*N) :: harvest\n    character :: c\n    i = 1\n    L = 0\n    R = 0\n    s = ' '\n    call random_number(harvest)\n    do while ((L < N) .and. (R < N))\n       if (harvest(i) < 0.5) then\n          L = L+1\n          s(i:i) = '['\n       else\n          R = R+1\n          s(i:i) = ']'\n       end if\n       i = i+1\n    end do\n    c = merge('[', ']', L < N)\n    do while (i <= 2*N)\n       s(i:i) = c\n       i = i+1\n    end do\n  end subroutine generate\nend program balanced_brackets\n", "target": "module BalancedBrackets\n    {\n    Boolean balanced(String text)\n        {\n        Int depth = 0;\n        for (Char ch : text)\n            {\n            switch (ch, depth)\n                {\n                case ('[', _):\n                    ++depth;\n                    break;\n                case (']', 0):\n                    return False;\n                case (']', _):\n                    --depth;\n                    break;\n                }\n            }\n        return depth==0;\n        }\n\n    @Inject Console console;\n    void run()\n        {\n        String[] tests =\n            [\n            \"[]\",\n            \"[][]\",\n            \"[]][[]\",\n            \"[[[]][]]\",\n            \"][[[[]][]]\",\n            \"[[[]][[]][]]\",\n            \"]][[]][[[[][]]\",\n            \"[[]]]][]][[][[[]\",\n            ];\n        Int longest = tests.map(s -> s.size).reduce(0, (max, len) -> max.maxOf(len));\n        for (String test : tests)\n            {\n            console.print($\"{test}{' ' * (longest-test.size)} {balanced(test)\u00a0? \"OK\"\u00a0: \"NOT OK\"}\");\n            }\n        }\n    }\n"}
{"id": 145937, "name": "Balanced brackets", "source": "Translate Fortran to Java: \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nprogram balanced_brackets\n  implicit none\n  integer :: N\n  character(len=20) :: brackets, fmt\n  write(6,*)'compiles             syntax error'\n  call random_seed\n  do N=0, 10\n     call generate(N, brackets)\n     if (balanced(brackets)) then\n        fmt = '(a,a20)'\n     else\n        fmt = '(a,21x,a20)'\n     end if\n     write(6,fmt)':',brackets\n  end do\n\n  brackets = '[[][[[][]]][]]'\n  if (balanced(brackets)) then\n     fmt = '(a,a20)'\n  else\n     fmt = '(a,21x,a20)'\n  end if\n  write(6,fmt)':',brackets\n\n  N = 10\n  call generate(N, brackets)\n  do while (.not. balanced(brackets)) \n     call generate(N, brackets)\n  end do\n  fmt = '(a,a20)'\n  write(6,fmt)':',brackets\n\ncontains\n\n  logical function balanced(s)\n    implicit none\n    character(len=*), intent(in) :: s\n    integer :: i, a, n\n    n = len_trim(s)\n    a = 0\n    balanced = .true.\n    do i=1, n\n       if (s(i:i) == '[') then\n          a = a+1\n       else\n          a = a-1\n       end if\n       balanced = balanced .and. (0 <= a)\n    end do\n  end function balanced\n\n  subroutine generate(N, s)\n    implicit none\n    integer, intent(in) :: N\n    character(len=*), intent(out) :: s\n    integer :: L, R, i\n    real, dimension(2*N) :: harvest\n    character :: c\n    i = 1\n    L = 0\n    R = 0\n    s = ' '\n    call random_number(harvest)\n    do while ((L < N) .and. (R < N))\n       if (harvest(i) < 0.5) then\n          L = L+1\n          s(i:i) = '['\n       else\n          R = R+1\n          s(i:i) = ']'\n       end if\n       i = i+1\n    end do\n    c = merge('[', ']', L < N)\n    do while (i <= 2*N)\n       s(i:i) = c\n       i = i+1\n    end do\n  end subroutine generate\nend program balanced_brackets\n", "target": "module BalancedBrackets\n    {\n    Boolean balanced(String text)\n        {\n        Int depth = 0;\n        for (Char ch : text)\n            {\n            switch (ch, depth)\n                {\n                case ('[', _):\n                    ++depth;\n                    break;\n                case (']', 0):\n                    return False;\n                case (']', _):\n                    --depth;\n                    break;\n                }\n            }\n        return depth==0;\n        }\n\n    @Inject Console console;\n    void run()\n        {\n        String[] tests =\n            [\n            \"[]\",\n            \"[][]\",\n            \"[]][[]\",\n            \"[[[]][]]\",\n            \"][[[[]][]]\",\n            \"[[[]][[]][]]\",\n            \"]][[]][[[[][]]\",\n            \"[[]]]][]][[][[[]\",\n            ];\n        Int longest = tests.map(s -> s.size).reduce(0, (max, len) -> max.maxOf(len));\n        for (String test : tests)\n            {\n            console.print($\"{test}{' ' * (longest-test.size)} {balanced(test)\u00a0? \"OK\"\u00a0: \"NOT OK\"}\");\n            }\n        }\n    }\n"}
{"id": 145938, "name": "Balanced brackets", "source": "Translate Fortran to Python: \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nprogram balanced_brackets\n  implicit none\n  integer :: N\n  character(len=20) :: brackets, fmt\n  write(6,*)'compiles             syntax error'\n  call random_seed\n  do N=0, 10\n     call generate(N, brackets)\n     if (balanced(brackets)) then\n        fmt = '(a,a20)'\n     else\n        fmt = '(a,21x,a20)'\n     end if\n     write(6,fmt)':',brackets\n  end do\n\n  brackets = '[[][[[][]]][]]'\n  if (balanced(brackets)) then\n     fmt = '(a,a20)'\n  else\n     fmt = '(a,21x,a20)'\n  end if\n  write(6,fmt)':',brackets\n\n  N = 10\n  call generate(N, brackets)\n  do while (.not. balanced(brackets)) \n     call generate(N, brackets)\n  end do\n  fmt = '(a,a20)'\n  write(6,fmt)':',brackets\n\ncontains\n\n  logical function balanced(s)\n    implicit none\n    character(len=*), intent(in) :: s\n    integer :: i, a, n\n    n = len_trim(s)\n    a = 0\n    balanced = .true.\n    do i=1, n\n       if (s(i:i) == '[') then\n          a = a+1\n       else\n          a = a-1\n       end if\n       balanced = balanced .and. (0 <= a)\n    end do\n  end function balanced\n\n  subroutine generate(N, s)\n    implicit none\n    integer, intent(in) :: N\n    character(len=*), intent(out) :: s\n    integer :: L, R, i\n    real, dimension(2*N) :: harvest\n    character :: c\n    i = 1\n    L = 0\n    R = 0\n    s = ' '\n    call random_number(harvest)\n    do while ((L < N) .and. (R < N))\n       if (harvest(i) < 0.5) then\n          L = L+1\n          s(i:i) = '['\n       else\n          R = R+1\n          s(i:i) = ']'\n       end if\n       i = i+1\n    end do\n    c = merge('[', ']', L < N)\n    do while (i <= 2*N)\n       s(i:i) = c\n       i = i+1\n    end do\n  end subroutine generate\nend program balanced_brackets\n", "target": ">>> def gen(N):\n...     txt = ['[', ']'] * N\n...     random.shuffle( txt )\n...     return ''.join(txt)\n... \n>>> def balanced(txt):\n...     braced = 0\n...     for ch in txt:\n...         if ch == '[': braced += 1\n...         if ch == ']':\n...             braced -= 1\n...             if braced < 0: return False\n...     return braced == 0\n... \n>>> for txt in (gen(N) for N in range(10)):\n...     print (\"%-22r is%s balanced\" % (txt, '' if balanced(txt) else ' not'))\n... \n''                     is balanced\n'[]'                   is balanced\n'[][]'                 is balanced\n'][[[]]'               is not balanced\n'[]][[][]'             is not balanced\n'[][[][]]]['           is not balanced\n'][]][][[]][['         is not balanced\n'[[]]]]][]][[[['       is not balanced\n'[[[[]][]]][[][]]'     is balanced\n'][[][[]]][]]][[[[]'   is not balanced\n"}
{"id": 145939, "name": "Balanced brackets", "source": "Translate Fortran to Python: \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nprogram balanced_brackets\n  implicit none\n  integer :: N\n  character(len=20) :: brackets, fmt\n  write(6,*)'compiles             syntax error'\n  call random_seed\n  do N=0, 10\n     call generate(N, brackets)\n     if (balanced(brackets)) then\n        fmt = '(a,a20)'\n     else\n        fmt = '(a,21x,a20)'\n     end if\n     write(6,fmt)':',brackets\n  end do\n\n  brackets = '[[][[[][]]][]]'\n  if (balanced(brackets)) then\n     fmt = '(a,a20)'\n  else\n     fmt = '(a,21x,a20)'\n  end if\n  write(6,fmt)':',brackets\n\n  N = 10\n  call generate(N, brackets)\n  do while (.not. balanced(brackets)) \n     call generate(N, brackets)\n  end do\n  fmt = '(a,a20)'\n  write(6,fmt)':',brackets\n\ncontains\n\n  logical function balanced(s)\n    implicit none\n    character(len=*), intent(in) :: s\n    integer :: i, a, n\n    n = len_trim(s)\n    a = 0\n    balanced = .true.\n    do i=1, n\n       if (s(i:i) == '[') then\n          a = a+1\n       else\n          a = a-1\n       end if\n       balanced = balanced .and. (0 <= a)\n    end do\n  end function balanced\n\n  subroutine generate(N, s)\n    implicit none\n    integer, intent(in) :: N\n    character(len=*), intent(out) :: s\n    integer :: L, R, i\n    real, dimension(2*N) :: harvest\n    character :: c\n    i = 1\n    L = 0\n    R = 0\n    s = ' '\n    call random_number(harvest)\n    do while ((L < N) .and. (R < N))\n       if (harvest(i) < 0.5) then\n          L = L+1\n          s(i:i) = '['\n       else\n          R = R+1\n          s(i:i) = ']'\n       end if\n       i = i+1\n    end do\n    c = merge('[', ']', L < N)\n    do while (i <= 2*N)\n       s(i:i) = c\n       i = i+1\n    end do\n  end subroutine generate\nend program balanced_brackets\n", "target": ">>> def gen(N):\n...     txt = ['[', ']'] * N\n...     random.shuffle( txt )\n...     return ''.join(txt)\n... \n>>> def balanced(txt):\n...     braced = 0\n...     for ch in txt:\n...         if ch == '[': braced += 1\n...         if ch == ']':\n...             braced -= 1\n...             if braced < 0: return False\n...     return braced == 0\n... \n>>> for txt in (gen(N) for N in range(10)):\n...     print (\"%-22r is%s balanced\" % (txt, '' if balanced(txt) else ' not'))\n... \n''                     is balanced\n'[]'                   is balanced\n'[][]'                 is balanced\n'][[[]]'               is not balanced\n'[]][[][]'             is not balanced\n'[][[][]]]['           is not balanced\n'][]][][[]][['         is not balanced\n'[[]]]]][]][[[['       is not balanced\n'[[[[]][]]][[][]]'     is balanced\n'][[][[]]][]]][[[[]'   is not balanced\n"}
{"id": 146378, "name": "Numerical integration", "source": "Translate Fortran to C#: elemental function elemf(x)\n   real :: elemf, x\n   elemf = f(x)\nend function elemf\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\npublic class Interval\n{\n    public Interval(double leftEndpoint, double size)\n    {\n        LeftEndpoint = leftEndpoint;\n        RightEndpoint = leftEndpoint + size;\n    }\n\n    public double LeftEndpoint\n    {\n        get;\n        set;\n    }\n\n    public double RightEndpoint\n    {\n        get;\n        set;\n    }\n\n    public double Size\n    {\n        get\n        {\n            return RightEndpoint - LeftEndpoint;\n        }\n    }\n\n    public double Center\n    {\n        get\n        {\n            return (LeftEndpoint + RightEndpoint) / 2;\n        }\n    }\n\n    public IEnumerable<Interval> Subdivide(int subintervalCount)\n    {\n        double subintervalSize = Size / subintervalCount;\n        return Enumerable.Range(0, subintervalCount).Select(index => new Interval(LeftEndpoint + index * subintervalSize, subintervalSize));\n    }\n}\n\npublic class DefiniteIntegral\n{\n    public DefiniteIntegral(Func<double, double> integrand, Interval domain)\n    {\n        Integrand = integrand;\n        Domain = domain;\n    }\n\n    public Func<double, double> Integrand\n    {\n        get;\n        set;\n    }\n\n    public Interval Domain\n    {\n        get;\n        set;\n    }\n\n    public double SampleIntegrand(ApproximationMethod approximationMethod, Interval subdomain)\n    {\n        switch (approximationMethod)\n        {\n            case ApproximationMethod.RectangleLeft:\n                return Integrand(subdomain.LeftEndpoint);\n            case ApproximationMethod.RectangleMidpoint:\n                return Integrand(subdomain.Center);\n            case ApproximationMethod.RectangleRight:\n                return Integrand(subdomain.RightEndpoint);\n            case ApproximationMethod.Trapezium:\n                return (Integrand(subdomain.LeftEndpoint) + Integrand(subdomain.RightEndpoint)) / 2;\n            case ApproximationMethod.Simpson:\n                return (Integrand(subdomain.LeftEndpoint) + 4 * Integrand(subdomain.Center) + Integrand(subdomain.RightEndpoint)) / 6;\n            default:\n                throw new NotImplementedException();\n        }\n    }\n\n    public double Approximate(ApproximationMethod approximationMethod, int subdomainCount)\n    {\n        return Domain.Size * Domain.Subdivide(subdomainCount).Sum(subdomain => SampleIntegrand(approximationMethod, subdomain)) / subdomainCount;\n    }\n\n    public enum ApproximationMethod\n    {\n        RectangleLeft,\n        RectangleMidpoint,\n        RectangleRight,\n        Trapezium,\n        Simpson\n    }\n}\n\npublic class Program\n{\n    private static void TestApproximationMethods(DefiniteIntegral integral, int subdomainCount)\n    {\n        foreach (DefiniteIntegral.ApproximationMethod approximationMethod in Enum.GetValues(typeof(DefiniteIntegral.ApproximationMethod)))\n        {\n            Console.WriteLine(integral.Approximate(approximationMethod, subdomainCount));\n        }\n    }\n\n    public static void Main()\n    {\n        TestApproximationMethods(new DefiniteIntegral(x => x * x * x, new Interval(0, 1)), 10000);\n        TestApproximationMethods(new DefiniteIntegral(x => 1 / x, new Interval(1, 99)), 1000);\n        TestApproximationMethods(new DefiniteIntegral(x => x, new Interval(0, 5000)), 500000);\n        TestApproximationMethods(new DefiniteIntegral(x => x, new Interval(0, 6000)), 6000000);\n    }\n}\n"}
{"id": 146381, "name": "Numerical integration", "source": "Translate Fortran to Java: elemental function elemf(x)\n   real :: elemf, x\n   elemf = f(x)\nend function elemf\n", "target": "class NumericalIntegration\n{\n\n  interface FPFunction\n  {\n    double eval(double n);\n  }\n  \n  public static double rectangularLeft(double a, double b, int n, FPFunction f)\n  {\n    return rectangular(a, b, n, f, 0);\n  }\n  \n  public static double rectangularMidpoint(double a, double b, int n, FPFunction f)\n  {\n    return rectangular(a, b, n, f, 1);\n  }\n  \n  public static double rectangularRight(double a, double b, int n, FPFunction f)\n  {\n    return rectangular(a, b, n, f, 2);\n  }\n  \n  public static double trapezium(double a, double b, int n, FPFunction f)\n  {\n    double range = checkParamsGetRange(a, b, n);\n    double nFloat = (double)n;\n    double sum = 0.0;\n    for (int i = 1; i < n; i++)\n    {\n      double x = a + range * (double)i / nFloat;\n      sum += f.eval(x);\n    }\n    sum += (f.eval(a) + f.eval(b)) / 2.0;\n    return sum * range / nFloat;\n  }\n  \n  public static double simpsons(double a, double b, int n, FPFunction f)\n  {\n    double range = checkParamsGetRange(a, b, n);\n    double nFloat = (double)n;\n    double sum1 = f.eval(a + range / (nFloat * 2.0));\n    double sum2 = 0.0;\n    for (int i = 1; i < n; i++)\n    {\n      double x1 = a + range * ((double)i + 0.5) / nFloat;\n      sum1 += f.eval(x1);\n      double x2 = a + range * (double)i / nFloat;\n      sum2 += f.eval(x2);\n    }\n    return (f.eval(a) + f.eval(b) + sum1 * 4.0 + sum2 * 2.0) * range / (nFloat * 6.0);\n  }\n  \n  private static double rectangular(double a, double b, int n, FPFunction f, int mode)\n  {\n    double range = checkParamsGetRange(a, b, n);\n    double modeOffset = (double)mode / 2.0;\n    double nFloat = (double)n;\n    double sum = 0.0;\n    for (int i = 0; i < n; i++)\n    {\n      double x = a + range * ((double)i + modeOffset) / nFloat;\n      sum += f.eval(x);\n    }\n    return sum * range / nFloat;\n  }\n  \n  private static double checkParamsGetRange(double a, double b, int n)\n  {\n    if (n <= 0)\n      throw new IllegalArgumentException(\"Invalid value of n\");\n    double range = b - a;\n    if (range <= 0)\n      throw new IllegalArgumentException(\"Invalid range\");\n    return range;\n  }\n  \n  \n  private static void testFunction(String fname, double a, double b, int n, FPFunction f)\n  {\n    System.out.println(\"Testing function \\\"\" + fname + \"\\\", a=\" + a + \", b=\" + b + \", n=\" + n);\n    System.out.println(\"rectangularLeft: \" + rectangularLeft(a, b, n, f));\n    System.out.println(\"rectangularMidpoint: \" + rectangularMidpoint(a, b, n, f));\n    System.out.println(\"rectangularRight: \" + rectangularRight(a, b, n, f));\n    System.out.println(\"trapezium: \" + trapezium(a, b, n, f));\n    System.out.println(\"simpsons: \" + simpsons(a, b, n, f));\n    System.out.println();\n    return;\n  }\n  \n  public static void main(String[] args)\n  {\n    testFunction(\"x^3\", 0.0, 1.0, 100, new FPFunction() {\n        public double eval(double n) {\n          return n * n * n;\n        }\n      }\n    );\n    \n    testFunction(\"1/x\", 1.0, 100.0, 1000, new FPFunction() {\n        public double eval(double n) {\n          return 1.0 / n;\n        }\n      }\n    );\n    \n    testFunction(\"x\", 0.0, 5000.0, 5000000, new FPFunction() {\n        public double eval(double n) {\n          return n;\n        }\n      }\n    );\n    \n    testFunction(\"x\", 0.0, 6000.0, 6000000, new FPFunction() {\n        public double eval(double n) {\n          return n;\n        }\n      }\n    );\n    \n    return;\n  }\n}\n"}
{"id": 146382, "name": "Numerical integration", "source": "Translate Fortran to Python: elemental function elemf(x)\n   real :: elemf, x\n   elemf = f(x)\nend function elemf\n", "target": "from fractions import Fraction\n\ndef left_rect(f,x,h):\n  return f(x)\n \ndef mid_rect(f,x,h):\n  return f(x + h/2)\n \ndef right_rect(f,x,h):\n  return f(x+h)\n \ndef trapezium(f,x,h):\n  return (f(x) + f(x+h))/2.0\n \ndef simpson(f,x,h):\n  return (f(x) + 4*f(x + h/2) + f(x+h))/6.0\n \ndef cube(x):\n  return x*x*x\n \ndef reciprocal(x):\n  return 1/x\n \ndef identity(x):\n  return x\n \ndef integrate( f, a, b, steps, meth):\n   h = (b-a)/steps\n   ival = h * sum(meth(f, a+i*h, h) for i in range(steps))\n   return ival  \n\n\nfor a, b, steps, func in ((0., 1., 100, cube), (1., 100., 1000, reciprocal)):\n    for rule in (left_rect, mid_rect, right_rect, trapezium, simpson):\n        print('%s integrated using %s\\n  from %r to %r (%i steps) = %r' %\n              (func.__name__, rule.__name__, a, b, steps,\n               integrate( func, a, b, steps, rule)))\n    a, b = Fraction.from_float(a), Fraction.from_float(b)\n    for rule in (left_rect, mid_rect, right_rect, trapezium, simpson):\n        print('%s integrated using %s\\n  from %r to %r (%i steps and fractions) = %r' %\n              (func.__name__, rule.__name__, a, b, steps,\n               float(integrate( func, a, b, steps, rule))))\n\n\nfor a, b, steps, func in ((0., 5000., 5000000, identity),\n                          (0., 6000., 6000000, identity)):\n    for rule in (left_rect, mid_rect, right_rect, trapezium, simpson):\n        print('%s integrated using %s\\n  from %r to %r (%i steps) = %r' %\n              (func.__name__, rule.__name__, a, b, steps,\n               integrate( func, a, b, steps, rule)))\n    a, b = Fraction.from_float(a), Fraction.from_float(b)\n    for rule in (left_rect, mid_rect, right_rect, trapezium, simpson):\n        print('%s integrated using %s\\n  from %r to %r (%i steps and fractions) = %r' %\n              (func.__name__, rule.__name__, a, b, steps,\n               float(integrate( func, a, b, steps, rule))))\n"}
{"id": 146580, "name": "Universal Turing machine", "source": "Translate Fortran to C#:   200 I = STATE*NSYMBOL - ICHAR(TAPE(HEAD))\t\n      TAPE(HEAD) = MARK(I)\t\t\t\n      HEAD = HEAD + MOVE(I)\t\t\t\n      STATE = ICHAR(NEXT(I))\t\t\t\n      IF (STATE.GT.0) GO TO 200\t\t\t\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\nusing System.Linq;\nusing System.Text;\nusing System.Threading;\nusing System.Threading.Tasks;\n\npublic class TuringMachine\n{\n    public static async Task Main() {\n        var fiveStateBusyBeaver = new TuringMachine(\"A\", '0', \"H\").WithTransitions(\n            (\"A\", '0', '1', Right, \"B\"),\n            (\"A\", '1', '1', Left,  \"C\"),\n            (\"B\", '0', '1', Right, \"C\"),\n            (\"B\", '1', '1', Right, \"B\"),\n            (\"C\", '0', '1', Right, \"D\"),\n            (\"C\", '1', '0', Left,  \"E\"),\n            (\"D\", '0', '1', Left,  \"A\"),\n            (\"D\", '1', '1', Left,  \"D\"),\n            (\"E\", '0', '1', Stay,  \"H\"),\n            (\"E\", '1', '0', Left,  \"A\")\n        );\n        var busyBeaverTask = fiveStateBusyBeaver.TimeAsync();\n\n        var incrementer = new TuringMachine(\"q0\", 'B', \"qf\").WithTransitions(\n            (\"q0\", '1', '1', Right, \"q0\"),\n            (\"q0\", 'B', '1', Stay,  \"qf\")\n        )\n        .WithInput(\"111\");\n        foreach (var _ in incrementer.Run()) PrintLine(incrementer);\n        PrintResults(incrementer);\n\n        var threeStateBusyBeaver = new TuringMachine(\"a\", '0', \"halt\").WithTransitions(\n            (\"a\", '0', '1', Right, \"b\"),\n            (\"a\", '1', '1', Left,  \"c\"),\n            (\"b\", '0', '1', Left,  \"a\"),\n            (\"b\", '1', '1', Right, \"b\"),\n            (\"c\", '0', '1', Left,  \"b\"),\n            (\"c\", '1', '1', Stay,  \"halt\")\n        );\n        foreach (var _ in threeStateBusyBeaver.Run()) PrintLine(threeStateBusyBeaver);\n        PrintResults(threeStateBusyBeaver);\n\n        var sorter = new TuringMachine(\"A\", '*', \"X\").WithTransitions(\n            (\"A\", 'a', 'a', Right, \"A\"),\n            (\"A\", 'b', 'B', Right, \"B\"),\n            (\"A\", '*', '*', Left,  \"E\"),\n            (\"B\", 'a', 'a', Right, \"B\"),\n            (\"B\", 'b', 'b', Right, \"B\"),\n            (\"B\", '*', '*', Left,  \"C\"),\n            (\"C\", 'a', 'b', Left,  \"D\"),\n            (\"C\", 'b', 'b', Left,  \"C\"),\n            (\"C\", 'B', 'b', Left,  \"E\"),\n            (\"D\", 'a', 'a', Left,  \"D\"),\n            (\"D\", 'b', 'b', Left,  \"D\"),\n            (\"D\", 'B', 'a', Right, \"A\"),\n            (\"E\", 'a', 'a', Left,  \"E\"),\n            (\"E\", '*', '*', Right, \"X\")\n        )\n        .WithInput(\"babbababaa\");\n        sorter.Run().Last();\n        Console.WriteLine(\"Sorted: \" + sorter.TapeString);\n        PrintResults(sorter);\n\n        sorter.Reset().WithInput(\"bbbababaaabba\");\n        sorter.Run().Last();\n        Console.WriteLine(\"Sorted: \" + sorter.TapeString);\n        PrintResults(sorter);\n\n        Console.WriteLine(await busyBeaverTask);\n        PrintResults(fiveStateBusyBeaver);\n\n        void PrintLine(TuringMachine tm) => Console.WriteLine(tm.TapeString + \"\\tState \" + tm.State);\n\n        void PrintResults(TuringMachine tm) {\n            Console.WriteLine($\"End state: {tm.State} = {(tm.Success\u00a0? \"Success\"\u00a0: \"Failure\")}\");\n            Console.WriteLine(tm.Steps + \" steps\");\n            Console.WriteLine(\"tape length: \" + tm.TapeLength);\n            Console.WriteLine();\n        }\n    }\n\n    public const int Left = -1, Stay = 0, Right = 1;\n    private readonly Tape tape;\n    private readonly string initialState;\n    private readonly HashSet<string> terminatingStates;\n    private Dictionary<(string state, char read), (char write, int move, string toState)> transitions;\n\n    public TuringMachine(string initialState, char blankSymbol, params string[] terminatingStates) {\n        State = this.initialState = initialState;\n        tape = new Tape(blankSymbol);\n        this.terminatingStates = terminatingStates.ToHashSet();\n    }\n\n    public TuringMachine WithTransitions(\n        params (string state, char read, char write, int move, string toState)[] transitions)\n    {\n        this.transitions = transitions.ToDictionary(k => (k.state, k.read), k => (k.write, k.move, k.toState));\n        return this;\n    }\n\n    public TuringMachine Reset() {\n        State = initialState;\n        Steps = 0;\n        tape.Reset();\n        return this;\n    }\n\n    public TuringMachine WithInput(string input) {\n        tape.Input(input);\n        return this;\n    }\n\n    public int Steps { get; private set; }\n    public string State { get; private set; }\n    public bool Success => terminatingStates.Contains(State);\n    public int TapeLength => tape.Length;\n    public string TapeString => tape.ToString();\n\n    public IEnumerable<string> Run() {\n        yield return State;\n        while (Step()) yield return State;\n    }\n\n    public async Task<TimeSpan> TimeAsync(CancellationToken cancel = default) {\n        var chrono = Stopwatch.StartNew();\n        await RunAsync(cancel);\n        chrono.Stop();\n        return chrono.Elapsed;\n    }\n\n    public Task RunAsync(CancellationToken cancel = default)\n        => Task.Run(() => {\n            while (Step()) cancel.ThrowIfCancellationRequested();\n        });\n\n    private bool Step() {\n        if (!transitions.TryGetValue((State, tape.Current), out var action)) return false;\n        tape.Current = action.write;\n        tape.Move(action.move);\n        State = action.toState;\n        Steps++;\n        return true;\n    }\n\n\n    private class Tape\n    {\n        private List<char> forwardTape = new List<char>(), backwardTape = new List<char>();\n        private int head = 0;\n        private char blank;\n\n        public Tape(char blankSymbol) => forwardTape.Add(blank = blankSymbol);\n\n        public void Reset() {\n            backwardTape.Clear();\n            forwardTape.Clear();\n            head = 0;\n            forwardTape.Add(blank);\n        }\n\n        public void Input(string input) {\n            Reset();\n            forwardTape.Clear();\n            forwardTape.AddRange(input);\n        }\n\n        public void Move(int direction) {\n            head += direction;\n            if (head >= 0 && forwardTape.Count <= head) forwardTape.Add(blank);\n            if (head < 0 && backwardTape.Count <= ~head) backwardTape.Add(blank);\n        }\n\n        public char Current {\n            get => head < 0 ? backwardTape[~head] : forwardTape[head];\n            set {\n                if (head < 0) backwardTape[~head] = value;\n                else forwardTape[head] = value;\n            }\n        }\n\n        public int Length => backwardTape.Count + forwardTape.Count;\n\n        public override string ToString() {\n            int h = (head < 0 ? ~head : backwardTape.Count + head) * 2 + 1;\n            var builder = new StringBuilder(\" \", Length * 2 + 1);\n            if (backwardTape.Count > 0) {\n                builder.Append(string.Join(\" \", backwardTape)).Append(\" \");\n                if (head < 0) (builder[h + 1], builder[h - 1]) = ('(', ')');\n                for (int l = 0, r = builder.Length - 1; l < r; l++, r--) (builder[l], builder[r]) = (builder[r], builder[l]);\n            }\n            builder.Append(string.Join(\" \", forwardTape)).Append(\" \");\n            if (head >= 0) (builder[h - 1], builder[h + 1]) = ('(', ')');\n            return builder.ToString();\n        }\n\n    }\n\n}\n"}
{"id": 146581, "name": "Universal Turing machine", "source": "Translate Fortran to C#:   200 I = STATE*NSYMBOL - ICHAR(TAPE(HEAD))\t\n      TAPE(HEAD) = MARK(I)\t\t\t\n      HEAD = HEAD + MOVE(I)\t\t\t\n      STATE = ICHAR(NEXT(I))\t\t\t\n      IF (STATE.GT.0) GO TO 200\t\t\t\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\nusing System.Linq;\nusing System.Text;\nusing System.Threading;\nusing System.Threading.Tasks;\n\npublic class TuringMachine\n{\n    public static async Task Main() {\n        var fiveStateBusyBeaver = new TuringMachine(\"A\", '0', \"H\").WithTransitions(\n            (\"A\", '0', '1', Right, \"B\"),\n            (\"A\", '1', '1', Left,  \"C\"),\n            (\"B\", '0', '1', Right, \"C\"),\n            (\"B\", '1', '1', Right, \"B\"),\n            (\"C\", '0', '1', Right, \"D\"),\n            (\"C\", '1', '0', Left,  \"E\"),\n            (\"D\", '0', '1', Left,  \"A\"),\n            (\"D\", '1', '1', Left,  \"D\"),\n            (\"E\", '0', '1', Stay,  \"H\"),\n            (\"E\", '1', '0', Left,  \"A\")\n        );\n        var busyBeaverTask = fiveStateBusyBeaver.TimeAsync();\n\n        var incrementer = new TuringMachine(\"q0\", 'B', \"qf\").WithTransitions(\n            (\"q0\", '1', '1', Right, \"q0\"),\n            (\"q0\", 'B', '1', Stay,  \"qf\")\n        )\n        .WithInput(\"111\");\n        foreach (var _ in incrementer.Run()) PrintLine(incrementer);\n        PrintResults(incrementer);\n\n        var threeStateBusyBeaver = new TuringMachine(\"a\", '0', \"halt\").WithTransitions(\n            (\"a\", '0', '1', Right, \"b\"),\n            (\"a\", '1', '1', Left,  \"c\"),\n            (\"b\", '0', '1', Left,  \"a\"),\n            (\"b\", '1', '1', Right, \"b\"),\n            (\"c\", '0', '1', Left,  \"b\"),\n            (\"c\", '1', '1', Stay,  \"halt\")\n        );\n        foreach (var _ in threeStateBusyBeaver.Run()) PrintLine(threeStateBusyBeaver);\n        PrintResults(threeStateBusyBeaver);\n\n        var sorter = new TuringMachine(\"A\", '*', \"X\").WithTransitions(\n            (\"A\", 'a', 'a', Right, \"A\"),\n            (\"A\", 'b', 'B', Right, \"B\"),\n            (\"A\", '*', '*', Left,  \"E\"),\n            (\"B\", 'a', 'a', Right, \"B\"),\n            (\"B\", 'b', 'b', Right, \"B\"),\n            (\"B\", '*', '*', Left,  \"C\"),\n            (\"C\", 'a', 'b', Left,  \"D\"),\n            (\"C\", 'b', 'b', Left,  \"C\"),\n            (\"C\", 'B', 'b', Left,  \"E\"),\n            (\"D\", 'a', 'a', Left,  \"D\"),\n            (\"D\", 'b', 'b', Left,  \"D\"),\n            (\"D\", 'B', 'a', Right, \"A\"),\n            (\"E\", 'a', 'a', Left,  \"E\"),\n            (\"E\", '*', '*', Right, \"X\")\n        )\n        .WithInput(\"babbababaa\");\n        sorter.Run().Last();\n        Console.WriteLine(\"Sorted: \" + sorter.TapeString);\n        PrintResults(sorter);\n\n        sorter.Reset().WithInput(\"bbbababaaabba\");\n        sorter.Run().Last();\n        Console.WriteLine(\"Sorted: \" + sorter.TapeString);\n        PrintResults(sorter);\n\n        Console.WriteLine(await busyBeaverTask);\n        PrintResults(fiveStateBusyBeaver);\n\n        void PrintLine(TuringMachine tm) => Console.WriteLine(tm.TapeString + \"\\tState \" + tm.State);\n\n        void PrintResults(TuringMachine tm) {\n            Console.WriteLine($\"End state: {tm.State} = {(tm.Success\u00a0? \"Success\"\u00a0: \"Failure\")}\");\n            Console.WriteLine(tm.Steps + \" steps\");\n            Console.WriteLine(\"tape length: \" + tm.TapeLength);\n            Console.WriteLine();\n        }\n    }\n\n    public const int Left = -1, Stay = 0, Right = 1;\n    private readonly Tape tape;\n    private readonly string initialState;\n    private readonly HashSet<string> terminatingStates;\n    private Dictionary<(string state, char read), (char write, int move, string toState)> transitions;\n\n    public TuringMachine(string initialState, char blankSymbol, params string[] terminatingStates) {\n        State = this.initialState = initialState;\n        tape = new Tape(blankSymbol);\n        this.terminatingStates = terminatingStates.ToHashSet();\n    }\n\n    public TuringMachine WithTransitions(\n        params (string state, char read, char write, int move, string toState)[] transitions)\n    {\n        this.transitions = transitions.ToDictionary(k => (k.state, k.read), k => (k.write, k.move, k.toState));\n        return this;\n    }\n\n    public TuringMachine Reset() {\n        State = initialState;\n        Steps = 0;\n        tape.Reset();\n        return this;\n    }\n\n    public TuringMachine WithInput(string input) {\n        tape.Input(input);\n        return this;\n    }\n\n    public int Steps { get; private set; }\n    public string State { get; private set; }\n    public bool Success => terminatingStates.Contains(State);\n    public int TapeLength => tape.Length;\n    public string TapeString => tape.ToString();\n\n    public IEnumerable<string> Run() {\n        yield return State;\n        while (Step()) yield return State;\n    }\n\n    public async Task<TimeSpan> TimeAsync(CancellationToken cancel = default) {\n        var chrono = Stopwatch.StartNew();\n        await RunAsync(cancel);\n        chrono.Stop();\n        return chrono.Elapsed;\n    }\n\n    public Task RunAsync(CancellationToken cancel = default)\n        => Task.Run(() => {\n            while (Step()) cancel.ThrowIfCancellationRequested();\n        });\n\n    private bool Step() {\n        if (!transitions.TryGetValue((State, tape.Current), out var action)) return false;\n        tape.Current = action.write;\n        tape.Move(action.move);\n        State = action.toState;\n        Steps++;\n        return true;\n    }\n\n\n    private class Tape\n    {\n        private List<char> forwardTape = new List<char>(), backwardTape = new List<char>();\n        private int head = 0;\n        private char blank;\n\n        public Tape(char blankSymbol) => forwardTape.Add(blank = blankSymbol);\n\n        public void Reset() {\n            backwardTape.Clear();\n            forwardTape.Clear();\n            head = 0;\n            forwardTape.Add(blank);\n        }\n\n        public void Input(string input) {\n            Reset();\n            forwardTape.Clear();\n            forwardTape.AddRange(input);\n        }\n\n        public void Move(int direction) {\n            head += direction;\n            if (head >= 0 && forwardTape.Count <= head) forwardTape.Add(blank);\n            if (head < 0 && backwardTape.Count <= ~head) backwardTape.Add(blank);\n        }\n\n        public char Current {\n            get => head < 0 ? backwardTape[~head] : forwardTape[head];\n            set {\n                if (head < 0) backwardTape[~head] = value;\n                else forwardTape[head] = value;\n            }\n        }\n\n        public int Length => backwardTape.Count + forwardTape.Count;\n\n        public override string ToString() {\n            int h = (head < 0 ? ~head : backwardTape.Count + head) * 2 + 1;\n            var builder = new StringBuilder(\" \", Length * 2 + 1);\n            if (backwardTape.Count > 0) {\n                builder.Append(string.Join(\" \", backwardTape)).Append(\" \");\n                if (head < 0) (builder[h + 1], builder[h - 1]) = ('(', ')');\n                for (int l = 0, r = builder.Length - 1; l < r; l++, r--) (builder[l], builder[r]) = (builder[r], builder[l]);\n            }\n            builder.Append(string.Join(\" \", forwardTape)).Append(\" \");\n            if (head >= 0) (builder[h - 1], builder[h + 1]) = ('(', ')');\n            return builder.ToString();\n        }\n\n    }\n\n}\n"}
{"id": 146586, "name": "Universal Turing machine", "source": "Translate Fortran to Java:   200 I = STATE*NSYMBOL - ICHAR(TAPE(HEAD))\t\n      TAPE(HEAD) = MARK(I)\t\t\t\n      HEAD = HEAD + MOVE(I)\t\t\t\n      STATE = ICHAR(NEXT(I))\t\t\t\n      IF (STATE.GT.0) GO TO 200\t\t\t\n", "target": "import java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.LinkedList;\nimport java.util.ListIterator;\nimport java.util.List;\nimport java.util.Set;\nimport java.util.Map;\n\npublic class UTM {\n    private List<String> tape;\n    private String blankSymbol;\n    private ListIterator<String> head;\n    private Map<StateTapeSymbolPair, Transition> transitions = new HashMap<StateTapeSymbolPair, Transition>();\n    private Set<String> terminalStates;\n    private String initialState;\n    \n    public UTM(Set<Transition> transitions, Set<String> terminalStates, String initialState, String blankSymbol) {\n        this.blankSymbol = blankSymbol;\n        for (Transition t : transitions) {\n            this.transitions.put(t.from, t);\n        }\n        this.terminalStates = terminalStates;\n        this.initialState = initialState;\n    }\n    \n    public static class StateTapeSymbolPair {\n        private String state;\n        private String tapeSymbol;\n\n        public StateTapeSymbolPair(String state, String tapeSymbol) {\n            this.state = state;\n            this.tapeSymbol = tapeSymbol;\n        }\n\n        \n        @Override\n        public int hashCode() {\n            final int prime = 31;\n            int result = 1;\n            result = prime * result\n                    + ((state == null) ? 0 : state.hashCode());\n            result = prime\n                    * result\n                    + ((tapeSymbol == null) ? 0 : tapeSymbol\n                            .hashCode());\n            return result;\n        }\n\n        \n        @Override\n        public boolean equals(Object obj) {\n            if (this == obj)\n                return true;\n            if (obj == null)\n                return false;\n            if (getClass() != obj.getClass())\n                return false;\n            StateTapeSymbolPair other = (StateTapeSymbolPair) obj;\n            if (state == null) {\n                if (other.state != null)\n                    return false;\n            } else if (!state.equals(other.state))\n                return false;\n            if (tapeSymbol == null) {\n                if (other.tapeSymbol != null)\n                    return false;\n            } else if (!tapeSymbol.equals(other.tapeSymbol))\n                return false;\n            return true;\n        }\n\n        @Override\n        public String toString() {\n            return \"(\" + state + \",\" + tapeSymbol + \")\";\n        }\n    }\n    \n    public static class Transition {\n        private StateTapeSymbolPair from;\n        private StateTapeSymbolPair to;\n        private int direction; \n\n        public Transition(StateTapeSymbolPair from, StateTapeSymbolPair to, int direction) {\n             this.from = from;\n            this.to = to;\n            this.direction = direction;\n        }\n\n        @Override\n        public String toString() {\n            return from + \"=>\" + to + \"/\" + direction;\n        }\n    }\n    \n    public void initializeTape(List<String> input) { \n        tape = input;\n    }\n    \n    public void initializeTape(String input) { \n        tape = new LinkedList<String>();\n        for (int i = 0; i < input.length(); i++) {\n            tape.add(input.charAt(i) + \"\");\n        }\n    }\n    \n    public List<String> runTM() { \n        if (tape.size() == 0) {\n            tape.add(blankSymbol);\n        }\n        \n        head = tape.listIterator();\n        head.next();\n        head.previous();\n        \n        StateTapeSymbolPair tsp = new StateTapeSymbolPair(initialState, tape.get(0));\n        \n        while (transitions.containsKey(tsp)) { \n            System.out.println(this + \" --- \" + transitions.get(tsp));\n            Transition trans = transitions.get(tsp);\n            head.set(trans.to.tapeSymbol); \n            tsp.state = trans.to.state; \n            if (trans.direction == -1) { \n                if (!head.hasPrevious()) {\n                    head.add(blankSymbol); \n                }\n                tsp.tapeSymbol = head.previous(); \n            } else if (trans.direction == 1) { \n                head.next();\n                if (!head.hasNext()) {\n                    head.add(blankSymbol); \n                    head.previous();\n                }\n                tsp.tapeSymbol = head.next(); \n                head.previous();\n            } else {\n                tsp.tapeSymbol = trans.to.tapeSymbol;\n            }\n        }\n        \n        System.out.println(this + \" --- \" + tsp);\n        \n        if (terminalStates.contains(tsp.state)) {\n            return tape;\n        } else {\n            return null;\n        }\n    }\n\n    @Override\n    public String toString() {\n        try {\n        \tint headPos = head.previousIndex();\n            String s = \"[ \";\n            \n            for (int i = 0; i <= headPos; i++) {\n                s += tape.get(i) + \" \";\n            }\n\n            s += \"[H] \";\n            \n            for (int i = headPos + 1; i < tape.size(); i++) {\n                s += tape.get(i) + \" \";\n            }\n\n            return s + \"]\";\n        } catch (Exception e) {\n            return \"\";\n        }\n    }\n    \n    public static void main(String[] args) {\n        \n        String init = \"q0\";\n        String blank = \"b\";\n        \n        Set<String> term = new HashSet<String>();\n        term.add(\"qf\");\n        \n        Set<Transition> trans = new HashSet<Transition>();\n        \n        trans.add(new Transition(new StateTapeSymbolPair(\"q0\", \"1\"), new StateTapeSymbolPair(\"q0\", \"1\"), 1));\n        trans.add(new Transition(new StateTapeSymbolPair(\"q0\", \"b\"), new StateTapeSymbolPair(\"qf\", \"1\"), 0));\n        \n        UTM machine = new UTM(trans, term, init, blank);\n        machine.initializeTape(\"111\");\n        System.out.println(\"Output (si): \" + machine.runTM() + \"\\n\");\n        \n        \n        init = \"a\";\n        \n        term.clear();\n        term.add(\"halt\");\n        \n        blank = \"0\";\n        \n        trans.clear();\n\n        \n        trans.add(new Transition(new StateTapeSymbolPair(\"a\", \"0\"), new StateTapeSymbolPair(\"b\", \"1\"), 1));\n        trans.add(new Transition(new StateTapeSymbolPair(\"a\", \"1\"), new StateTapeSymbolPair(\"c\", \"1\"), -1));\n        trans.add(new Transition(new StateTapeSymbolPair(\"b\", \"0\"), new StateTapeSymbolPair(\"a\", \"1\"), -1));\n        trans.add(new Transition(new StateTapeSymbolPair(\"b\", \"1\"), new StateTapeSymbolPair(\"b\", \"1\"), 1));\n        trans.add(new Transition(new StateTapeSymbolPair(\"c\", \"0\"), new StateTapeSymbolPair(\"b\", \"1\"), -1));\n        trans.add(new Transition(new StateTapeSymbolPair(\"c\", \"1\"), new StateTapeSymbolPair(\"halt\", \"1\"), 0));\n        \n        machine = new UTM(trans, term, init, blank);\n        machine.initializeTape(\"\");\n        System.out.println(\"Output (bb): \" + machine.runTM());\n\n        \n        init = \"s0\";\n        blank = \"*\";\n        \n        term = new HashSet<String>();\n        term.add(\"see\");\n        \n        trans = new HashSet<Transition>();\n        \n        trans.add(new Transition(new StateTapeSymbolPair(\"s0\", \"a\"), new StateTapeSymbolPair(\"s0\", \"a\"), 1));\n        trans.add(new Transition(new StateTapeSymbolPair(\"s0\", \"b\"), new StateTapeSymbolPair(\"s1\", \"B\"), 1));\n        trans.add(new Transition(new StateTapeSymbolPair(\"s0\", \"*\"), new StateTapeSymbolPair(\"se\", \"*\"), -1));\n        trans.add(new Transition(new StateTapeSymbolPair(\"s1\", \"a\"), new StateTapeSymbolPair(\"s1\", \"a\"), 1));\n        trans.add(new Transition(new StateTapeSymbolPair(\"s1\", \"b\"), new StateTapeSymbolPair(\"s1\", \"b\"), 1));\n        trans.add(new Transition(new StateTapeSymbolPair(\"s1\", \"*\"), new StateTapeSymbolPair(\"s2\", \"*\"), -1));\n        trans.add(new Transition(new StateTapeSymbolPair(\"s2\", \"a\"), new StateTapeSymbolPair(\"s3\", \"b\"), -1));\n        trans.add(new Transition(new StateTapeSymbolPair(\"s2\", \"b\"), new StateTapeSymbolPair(\"s2\", \"b\"), -1));\n        trans.add(new Transition(new StateTapeSymbolPair(\"s2\", \"B\"), new StateTapeSymbolPair(\"se\", \"b\"), -1));\n        trans.add(new Transition(new StateTapeSymbolPair(\"s3\", \"a\"), new StateTapeSymbolPair(\"s3\", \"a\"), -1));\n        trans.add(new Transition(new StateTapeSymbolPair(\"s3\", \"b\"), new StateTapeSymbolPair(\"s3\", \"b\"), -1));\n        trans.add(new Transition(new StateTapeSymbolPair(\"s3\", \"B\"), new StateTapeSymbolPair(\"s0\", \"a\"), 1));\n        trans.add(new Transition(new StateTapeSymbolPair(\"se\", \"a\"), new StateTapeSymbolPair(\"se\", \"a\"), -1));\n        trans.add(new Transition(new StateTapeSymbolPair(\"se\", \"*\"), new StateTapeSymbolPair(\"see\", \"*\"), 1));\n\n        machine = new UTM(trans, term, init, blank);\n        machine.initializeTape(\"babbababaa\");\n        System.out.println(\"Output (sort): \" + machine.runTM() + \"\\n\");\n    }\n}\n"}
{"id": 146587, "name": "Universal Turing machine", "source": "Translate Fortran to Java:   200 I = STATE*NSYMBOL - ICHAR(TAPE(HEAD))\t\n      TAPE(HEAD) = MARK(I)\t\t\t\n      HEAD = HEAD + MOVE(I)\t\t\t\n      STATE = ICHAR(NEXT(I))\t\t\t\n      IF (STATE.GT.0) GO TO 200\t\t\t\n", "target": "import java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.LinkedList;\nimport java.util.ListIterator;\nimport java.util.List;\nimport java.util.Set;\nimport java.util.Map;\n\npublic class UTM {\n    private List<String> tape;\n    private String blankSymbol;\n    private ListIterator<String> head;\n    private Map<StateTapeSymbolPair, Transition> transitions = new HashMap<StateTapeSymbolPair, Transition>();\n    private Set<String> terminalStates;\n    private String initialState;\n    \n    public UTM(Set<Transition> transitions, Set<String> terminalStates, String initialState, String blankSymbol) {\n        this.blankSymbol = blankSymbol;\n        for (Transition t : transitions) {\n            this.transitions.put(t.from, t);\n        }\n        this.terminalStates = terminalStates;\n        this.initialState = initialState;\n    }\n    \n    public static class StateTapeSymbolPair {\n        private String state;\n        private String tapeSymbol;\n\n        public StateTapeSymbolPair(String state, String tapeSymbol) {\n            this.state = state;\n            this.tapeSymbol = tapeSymbol;\n        }\n\n        \n        @Override\n        public int hashCode() {\n            final int prime = 31;\n            int result = 1;\n            result = prime * result\n                    + ((state == null) ? 0 : state.hashCode());\n            result = prime\n                    * result\n                    + ((tapeSymbol == null) ? 0 : tapeSymbol\n                            .hashCode());\n            return result;\n        }\n\n        \n        @Override\n        public boolean equals(Object obj) {\n            if (this == obj)\n                return true;\n            if (obj == null)\n                return false;\n            if (getClass() != obj.getClass())\n                return false;\n            StateTapeSymbolPair other = (StateTapeSymbolPair) obj;\n            if (state == null) {\n                if (other.state != null)\n                    return false;\n            } else if (!state.equals(other.state))\n                return false;\n            if (tapeSymbol == null) {\n                if (other.tapeSymbol != null)\n                    return false;\n            } else if (!tapeSymbol.equals(other.tapeSymbol))\n                return false;\n            return true;\n        }\n\n        @Override\n        public String toString() {\n            return \"(\" + state + \",\" + tapeSymbol + \")\";\n        }\n    }\n    \n    public static class Transition {\n        private StateTapeSymbolPair from;\n        private StateTapeSymbolPair to;\n        private int direction; \n\n        public Transition(StateTapeSymbolPair from, StateTapeSymbolPair to, int direction) {\n             this.from = from;\n            this.to = to;\n            this.direction = direction;\n        }\n\n        @Override\n        public String toString() {\n            return from + \"=>\" + to + \"/\" + direction;\n        }\n    }\n    \n    public void initializeTape(List<String> input) { \n        tape = input;\n    }\n    \n    public void initializeTape(String input) { \n        tape = new LinkedList<String>();\n        for (int i = 0; i < input.length(); i++) {\n            tape.add(input.charAt(i) + \"\");\n        }\n    }\n    \n    public List<String> runTM() { \n        if (tape.size() == 0) {\n            tape.add(blankSymbol);\n        }\n        \n        head = tape.listIterator();\n        head.next();\n        head.previous();\n        \n        StateTapeSymbolPair tsp = new StateTapeSymbolPair(initialState, tape.get(0));\n        \n        while (transitions.containsKey(tsp)) { \n            System.out.println(this + \" --- \" + transitions.get(tsp));\n            Transition trans = transitions.get(tsp);\n            head.set(trans.to.tapeSymbol); \n            tsp.state = trans.to.state; \n            if (trans.direction == -1) { \n                if (!head.hasPrevious()) {\n                    head.add(blankSymbol); \n                }\n                tsp.tapeSymbol = head.previous(); \n            } else if (trans.direction == 1) { \n                head.next();\n                if (!head.hasNext()) {\n                    head.add(blankSymbol); \n                    head.previous();\n                }\n                tsp.tapeSymbol = head.next(); \n                head.previous();\n            } else {\n                tsp.tapeSymbol = trans.to.tapeSymbol;\n            }\n        }\n        \n        System.out.println(this + \" --- \" + tsp);\n        \n        if (terminalStates.contains(tsp.state)) {\n            return tape;\n        } else {\n            return null;\n        }\n    }\n\n    @Override\n    public String toString() {\n        try {\n        \tint headPos = head.previousIndex();\n            String s = \"[ \";\n            \n            for (int i = 0; i <= headPos; i++) {\n                s += tape.get(i) + \" \";\n            }\n\n            s += \"[H] \";\n            \n            for (int i = headPos + 1; i < tape.size(); i++) {\n                s += tape.get(i) + \" \";\n            }\n\n            return s + \"]\";\n        } catch (Exception e) {\n            return \"\";\n        }\n    }\n    \n    public static void main(String[] args) {\n        \n        String init = \"q0\";\n        String blank = \"b\";\n        \n        Set<String> term = new HashSet<String>();\n        term.add(\"qf\");\n        \n        Set<Transition> trans = new HashSet<Transition>();\n        \n        trans.add(new Transition(new StateTapeSymbolPair(\"q0\", \"1\"), new StateTapeSymbolPair(\"q0\", \"1\"), 1));\n        trans.add(new Transition(new StateTapeSymbolPair(\"q0\", \"b\"), new StateTapeSymbolPair(\"qf\", \"1\"), 0));\n        \n        UTM machine = new UTM(trans, term, init, blank);\n        machine.initializeTape(\"111\");\n        System.out.println(\"Output (si): \" + machine.runTM() + \"\\n\");\n        \n        \n        init = \"a\";\n        \n        term.clear();\n        term.add(\"halt\");\n        \n        blank = \"0\";\n        \n        trans.clear();\n\n        \n        trans.add(new Transition(new StateTapeSymbolPair(\"a\", \"0\"), new StateTapeSymbolPair(\"b\", \"1\"), 1));\n        trans.add(new Transition(new StateTapeSymbolPair(\"a\", \"1\"), new StateTapeSymbolPair(\"c\", \"1\"), -1));\n        trans.add(new Transition(new StateTapeSymbolPair(\"b\", \"0\"), new StateTapeSymbolPair(\"a\", \"1\"), -1));\n        trans.add(new Transition(new StateTapeSymbolPair(\"b\", \"1\"), new StateTapeSymbolPair(\"b\", \"1\"), 1));\n        trans.add(new Transition(new StateTapeSymbolPair(\"c\", \"0\"), new StateTapeSymbolPair(\"b\", \"1\"), -1));\n        trans.add(new Transition(new StateTapeSymbolPair(\"c\", \"1\"), new StateTapeSymbolPair(\"halt\", \"1\"), 0));\n        \n        machine = new UTM(trans, term, init, blank);\n        machine.initializeTape(\"\");\n        System.out.println(\"Output (bb): \" + machine.runTM());\n\n        \n        init = \"s0\";\n        blank = \"*\";\n        \n        term = new HashSet<String>();\n        term.add(\"see\");\n        \n        trans = new HashSet<Transition>();\n        \n        trans.add(new Transition(new StateTapeSymbolPair(\"s0\", \"a\"), new StateTapeSymbolPair(\"s0\", \"a\"), 1));\n        trans.add(new Transition(new StateTapeSymbolPair(\"s0\", \"b\"), new StateTapeSymbolPair(\"s1\", \"B\"), 1));\n        trans.add(new Transition(new StateTapeSymbolPair(\"s0\", \"*\"), new StateTapeSymbolPair(\"se\", \"*\"), -1));\n        trans.add(new Transition(new StateTapeSymbolPair(\"s1\", \"a\"), new StateTapeSymbolPair(\"s1\", \"a\"), 1));\n        trans.add(new Transition(new StateTapeSymbolPair(\"s1\", \"b\"), new StateTapeSymbolPair(\"s1\", \"b\"), 1));\n        trans.add(new Transition(new StateTapeSymbolPair(\"s1\", \"*\"), new StateTapeSymbolPair(\"s2\", \"*\"), -1));\n        trans.add(new Transition(new StateTapeSymbolPair(\"s2\", \"a\"), new StateTapeSymbolPair(\"s3\", \"b\"), -1));\n        trans.add(new Transition(new StateTapeSymbolPair(\"s2\", \"b\"), new StateTapeSymbolPair(\"s2\", \"b\"), -1));\n        trans.add(new Transition(new StateTapeSymbolPair(\"s2\", \"B\"), new StateTapeSymbolPair(\"se\", \"b\"), -1));\n        trans.add(new Transition(new StateTapeSymbolPair(\"s3\", \"a\"), new StateTapeSymbolPair(\"s3\", \"a\"), -1));\n        trans.add(new Transition(new StateTapeSymbolPair(\"s3\", \"b\"), new StateTapeSymbolPair(\"s3\", \"b\"), -1));\n        trans.add(new Transition(new StateTapeSymbolPair(\"s3\", \"B\"), new StateTapeSymbolPair(\"s0\", \"a\"), 1));\n        trans.add(new Transition(new StateTapeSymbolPair(\"se\", \"a\"), new StateTapeSymbolPair(\"se\", \"a\"), -1));\n        trans.add(new Transition(new StateTapeSymbolPair(\"se\", \"*\"), new StateTapeSymbolPair(\"see\", \"*\"), 1));\n\n        machine = new UTM(trans, term, init, blank);\n        machine.initializeTape(\"babbababaa\");\n        System.out.println(\"Output (sort): \" + machine.runTM() + \"\\n\");\n    }\n}\n"}
{"id": 146588, "name": "Universal Turing machine", "source": "Translate Fortran to Python:   200 I = STATE*NSYMBOL - ICHAR(TAPE(HEAD))\t\n      TAPE(HEAD) = MARK(I)\t\t\t\n      HEAD = HEAD + MOVE(I)\t\t\t\n      STATE = ICHAR(NEXT(I))\t\t\t\n      IF (STATE.GT.0) GO TO 200\t\t\t\n", "target": "from __future__ import print_function\n\ndef run_utm(\n        state = None,\n        blank = None,\n        rules = [],\n        tape = [],\n        halt = None,\n        pos = 0):\n    st = state\n    if not tape: tape = [blank]\n    if pos < 0: pos += len(tape)\n    if pos >= len(tape) or pos < 0: raise Error( \"bad init position\")\n    rules = dict(((s0, v0), (v1, dr, s1)) for (s0, v0, v1, dr, s1) in rules)\n\n    while True:\n        print(st, '\\t', end=\" \")\n        for i, v in enumerate(tape):\n            if i == pos: print(\"[%s]\" % (v,), end=\" \")\n            else: print(v, end=\" \")\n        print()\n\n        if st == halt: break\n        if (st, tape[pos]) not in rules: break\n\n        (v1, dr, s1) = rules[(st, tape[pos])]\n        tape[pos] = v1\n        if dr == 'left':\n            if pos > 0: pos -= 1\n            else: tape.insert(0, blank)\n        if dr == 'right':\n            pos += 1\n            if pos >= len(tape): tape.append(blank) \n        st = s1\n    \n\n\n            \nprint(\"incr machine\\n\")\nrun_utm(\n    halt = 'qf',\n\tstate = 'q0',\n\ttape = list(\"111\"),\n\tblank = 'B',\n\trules = map(tuple, \n               [\"q0 1 1 right q0\".split(),\n\t\t        \"q0 B 1 stay  qf\".split()]\n        )\n    )\n\nprint(\"\\nbusy beaver\\n\")\nrun_utm(\n    halt = 'halt',\n\tstate = 'a',\n\tblank = '0',\n\trules = map(tuple,\n        [\"a 0 1 right b\".split(),\n         \"a 1 1 left  c\".split(),\n         \"b 0 1 left  a\".split(),\n         \"b 1 1 right b\".split(),\n         \"c 0 1 left  b\".split(),\n         \"c 1 1 stay  halt\".split()]\n        )\n    )\n\nprint(\"\\nsorting test\\n\")\nrun_utm(halt = 'STOP',\n\tstate = 'A',\n\tblank = '0',\n\ttape = \"2 2 2 1 2 2 1 2 1 2 1 2 1 2\".split(),\n\trules = map(tuple,\n       [\"A 1 1 right A\".split(),\n\t\t\"A 2 3 right B\".split(),\n\t\t\"A 0 0 left  E\".split(),\n\t\t\"B 1 1 right B\".split(),\n\t\t\"B 2 2 right B\".split(),\n\t\t\"B 0 0 left  C\".split(),\n\t\t\"C 1 2 left  D\".split(),\n\t\t\"C 2 2 left  C\".split(),\n\t\t\"C 3 2 left  E\".split(),\n\t\t\"D 1 1 left  D\".split(),\n\t\t\"D 2 2 left  D\".split(),\n\t\t\"D 3 1 right A\".split(),\n\t\t\"E 1 1 left  E\".split(),\n\t\t\"E 0 0 right STOP\".split()]\n        )\n    )\n"}
{"id": 146589, "name": "Universal Turing machine", "source": "Translate Fortran to Python:   200 I = STATE*NSYMBOL - ICHAR(TAPE(HEAD))\t\n      TAPE(HEAD) = MARK(I)\t\t\t\n      HEAD = HEAD + MOVE(I)\t\t\t\n      STATE = ICHAR(NEXT(I))\t\t\t\n      IF (STATE.GT.0) GO TO 200\t\t\t\n", "target": "from __future__ import print_function\n\ndef run_utm(\n        state = None,\n        blank = None,\n        rules = [],\n        tape = [],\n        halt = None,\n        pos = 0):\n    st = state\n    if not tape: tape = [blank]\n    if pos < 0: pos += len(tape)\n    if pos >= len(tape) or pos < 0: raise Error( \"bad init position\")\n    rules = dict(((s0, v0), (v1, dr, s1)) for (s0, v0, v1, dr, s1) in rules)\n\n    while True:\n        print(st, '\\t', end=\" \")\n        for i, v in enumerate(tape):\n            if i == pos: print(\"[%s]\" % (v,), end=\" \")\n            else: print(v, end=\" \")\n        print()\n\n        if st == halt: break\n        if (st, tape[pos]) not in rules: break\n\n        (v1, dr, s1) = rules[(st, tape[pos])]\n        tape[pos] = v1\n        if dr == 'left':\n            if pos > 0: pos -= 1\n            else: tape.insert(0, blank)\n        if dr == 'right':\n            pos += 1\n            if pos >= len(tape): tape.append(blank) \n        st = s1\n    \n\n\n            \nprint(\"incr machine\\n\")\nrun_utm(\n    halt = 'qf',\n\tstate = 'q0',\n\ttape = list(\"111\"),\n\tblank = 'B',\n\trules = map(tuple, \n               [\"q0 1 1 right q0\".split(),\n\t\t        \"q0 B 1 stay  qf\".split()]\n        )\n    )\n\nprint(\"\\nbusy beaver\\n\")\nrun_utm(\n    halt = 'halt',\n\tstate = 'a',\n\tblank = '0',\n\trules = map(tuple,\n        [\"a 0 1 right b\".split(),\n         \"a 1 1 left  c\".split(),\n         \"b 0 1 left  a\".split(),\n         \"b 1 1 right b\".split(),\n         \"c 0 1 left  b\".split(),\n         \"c 1 1 stay  halt\".split()]\n        )\n    )\n\nprint(\"\\nsorting test\\n\")\nrun_utm(halt = 'STOP',\n\tstate = 'A',\n\tblank = '0',\n\ttape = \"2 2 2 1 2 2 1 2 1 2 1 2 1 2\".split(),\n\trules = map(tuple,\n       [\"A 1 1 right A\".split(),\n\t\t\"A 2 3 right B\".split(),\n\t\t\"A 0 0 left  E\".split(),\n\t\t\"B 1 1 right B\".split(),\n\t\t\"B 2 2 right B\".split(),\n\t\t\"B 0 0 left  C\".split(),\n\t\t\"C 1 2 left  D\".split(),\n\t\t\"C 2 2 left  C\".split(),\n\t\t\"C 3 2 left  E\".split(),\n\t\t\"D 1 1 left  D\".split(),\n\t\t\"D 2 2 left  D\".split(),\n\t\t\"D 3 1 right A\".split(),\n\t\t\"E 1 1 left  E\".split(),\n\t\t\"E 0 0 right STOP\".split()]\n        )\n    )\n"}
{"id": 146867, "name": "Number names", "source": "Translate Fortran to C#: program spell\n\n  implicit none\n  integer :: e\n  integer :: i\n  integer :: m\n  integer :: n\n  character (9), dimension (19), parameter :: small =       &\n    & (/'one      ', 'two      ', 'three    ', 'four     ', &\n    &   'five     ', 'six      ', 'seven    ', 'eight    ', &\n    &   'nine     ', 'ten      ', 'eleven   ', 'twelve   ', &\n    &   'thirteen ', 'fourteen ', 'fifteen  ', 'sixteen  ', &\n    &   'seventeen', 'eighteen ', 'nineteen '/)\n  character (7), dimension (2 : 9), parameter :: tens =        &\n    & (/'twenty ', 'thirty ', 'forty  ', 'fifty  ', 'sixty  ', &\n    &   'seventy', 'eighty ', 'ninety '/)\n  character (8), dimension (3), parameter :: big = &\n    & (/'thousand', 'million ', 'billion '/)\n  character (256) :: r\n\n  do\n    read (*, *, iostat = i) n\n    if (i /= 0) then\n      exit\n    end if\n    if (n == 0) then\n      r = 'zero'\n    else\n      r = ''\n      m = abs (n)\n      e = 0\n      do\n        if (m == 0) then\n          exit\n        end if\n        if (modulo (m, 1000) > 0) then\n          if (e > 0) then\n            r = trim (big (e)) // ' ' // r\n          end if\n          if (modulo (m, 100) > 0) then\n            if (modulo (m, 100) < 20) then\n              r = trim (small (modulo (m, 100))) // ' ' // r\n            else\n              if (modulo (m, 10) > 0) then\n                r = trim (small (modulo (m, 10))) // ' ' // r\n                r = trim (tens (modulo (m, 100) / 10)) // '-' // r\n              else\n                r = trim (tens (modulo (m, 100) / 10)) // ' ' // r\n              end if\n            end if\n          end if\n          if (modulo (m, 1000) / 100 > 0) then\n            r = 'hundred' // ' ' // r\n            r = trim (small (modulo (m, 1000) / 100)) // ' ' // r\n          end if\n        end if\n        m = m / 1000\n        e = e + 1\n      end do\n      if (n < 0) then\n        r = 'negative' // ' ' // r\n      end if\n    end if\n    write (*, '(a)') trim (r)\n  end do\n\nend program spell\n", "target": "using System;\n\nclass NumberNamer {\n    static readonly string[] incrementsOfOne =\n            { \"zero\",    \"one\",     \"two\",       \"three\",    \"four\",\n              \"five\",    \"six\",     \"seven\",     \"eight\",    \"nine\",\n              \"ten\",     \"eleven\",  \"twelve\",    \"thirteen\", \"fourteen\",\n              \"fifteen\", \"sixteen\", \"seventeen\", \"eighteen\", \"nineteen\" };\n\n    static readonly string[] incrementsOfTen =\n            { \"\",      \"\",      \"twenty\",  \"thirty\", \"fourty\",\n              \"fifty\", \"sixty\", \"seventy\", \"eighty\", \"ninety\" };\n\n    const string millionName = \"million\",\n                 thousandName = \"thousand\",\n                 hundredName = \"hundred\",\n                 andName = \"and\";\n\n\n    public static string GetName( int i ) {\n        string output = \"\";\n        if( i >= 1000000 ) {\n            output += ParseTriplet( i / 1000000 ) + \" \" + millionName;\n            i %= 1000000;\n            if( i == 0 ) return output;\n        }\n\n        if( i >= 1000 ) {\n            if( output.Length > 0 ) {\n                output += \", \";\n            }\n            output += ParseTriplet( i / 1000 ) + \" \" + thousandName;\n            i %= 1000;\n            if( i == 0 ) return output;\n        }\n\n        if( output.Length > 0 ) {\n            output += \", \";\n        }\n        output += ParseTriplet( i );\n        return output;\n    }\n\n\n    static string ParseTriplet( int i ) {\n        string output = \"\";\n        if( i >= 100 ) {\n            output += incrementsOfOne[i / 100] + \" \" + hundredName;\n            i %= 100;\n            if( i == 0 ) return output;\n        }\n\n        if( output.Length > 0 ) {\n            output += \" \" + andName + \" \";\n        }\n        if( i >= 20 ) {\n            output += incrementsOfTen[i / 10];\n            i %= 10;\n            if( i == 0 ) return output;\n        }\n\n        if( output.Length > 0 ) {\n            output += \" \";\n        }\n        output += incrementsOfOne[i];\n        return output;\n    }\n}\n\n\nclass Program { \n    static void Main( string[] args ) {\n        Console.WriteLine( NumberNamer.GetName( 1 ) );\n        Console.WriteLine( NumberNamer.GetName( 234 ) );\n        Console.WriteLine( NumberNamer.GetName( 31337 ) );\n        Console.WriteLine( NumberNamer.GetName( 987654321 ) );\n    }\n}\n"}
{"id": 146871, "name": "Number names", "source": "Translate Fortran to Java: program spell\n\n  implicit none\n  integer :: e\n  integer :: i\n  integer :: m\n  integer :: n\n  character (9), dimension (19), parameter :: small =       &\n    & (/'one      ', 'two      ', 'three    ', 'four     ', &\n    &   'five     ', 'six      ', 'seven    ', 'eight    ', &\n    &   'nine     ', 'ten      ', 'eleven   ', 'twelve   ', &\n    &   'thirteen ', 'fourteen ', 'fifteen  ', 'sixteen  ', &\n    &   'seventeen', 'eighteen ', 'nineteen '/)\n  character (7), dimension (2 : 9), parameter :: tens =        &\n    & (/'twenty ', 'thirty ', 'forty  ', 'fifty  ', 'sixty  ', &\n    &   'seventy', 'eighty ', 'ninety '/)\n  character (8), dimension (3), parameter :: big = &\n    & (/'thousand', 'million ', 'billion '/)\n  character (256) :: r\n\n  do\n    read (*, *, iostat = i) n\n    if (i /= 0) then\n      exit\n    end if\n    if (n == 0) then\n      r = 'zero'\n    else\n      r = ''\n      m = abs (n)\n      e = 0\n      do\n        if (m == 0) then\n          exit\n        end if\n        if (modulo (m, 1000) > 0) then\n          if (e > 0) then\n            r = trim (big (e)) // ' ' // r\n          end if\n          if (modulo (m, 100) > 0) then\n            if (modulo (m, 100) < 20) then\n              r = trim (small (modulo (m, 100))) // ' ' // r\n            else\n              if (modulo (m, 10) > 0) then\n                r = trim (small (modulo (m, 10))) // ' ' // r\n                r = trim (tens (modulo (m, 100) / 10)) // '-' // r\n              else\n                r = trim (tens (modulo (m, 100) / 10)) // ' ' // r\n              end if\n            end if\n          end if\n          if (modulo (m, 1000) / 100 > 0) then\n            r = 'hundred' // ' ' // r\n            r = trim (small (modulo (m, 1000) / 100)) // ' ' // r\n          end if\n        end if\n        m = m / 1000\n        e = e + 1\n      end do\n      if (n < 0) then\n        r = 'negative' // ' ' // r\n      end if\n    end if\n    write (*, '(a)') trim (r)\n  end do\n\nend program spell\n", "target": "module NumberNames\n    {\n    void run()\n        {\n        @Inject Console console;\n\n        Int[] tests = [0, 1, -1, 11, -17, 42, 99, 100, 101, -111, 1000, 1234, 10000, 100000,\n                       123456789000, 0x123456789ABCDEF];\n        for (Int test : tests)\n            {\n            console.print($\"{test} = {toEnglish(test)}\");\n            }\n        }\n\n    static String[] digits = [\"zero\", \"one\", \"two\", \"three\", \"four\",\n                              \"five\", \"six\", \"seven\", \"eight\", \"nine\"];\n    static String[] teens  = [\"ten\", \"eleven\", \"twelve\", \"thirteen\", \"fourteen\",\n                              \"fifteen\", \"sixteen\", \"seventeen\", \"eighteen\", \"nineteen\"];\n    static String[] tens   = [\"zero\", \"ten\", \"twenty\", \"thirty\", \"forty\",\n                              \"fifty\", \"sixty\", \"seventy\", \"eighty\", \"ninety\"];\n    static String[] ten3rd = [\"?\", \"thousand\", \"million\", \"billion\", \"trillion\",\n                              \"quadrillion\", \"quintillion\"];\n\n    static String toEnglish(Int n)\n        {\n        StringBuffer buf = new StringBuffer();\n        if (n < 0)\n            {\n            \"negative \".appendTo(buf);\n            n = -n;\n            }\n\n        format3digits(n, buf);\n        return buf.toString();\n        }\n\n    static void format3digits(Int n, StringBuffer buf, Int nested=0)\n        {\n        (Int left, Int right) = n /% 1000;\n        if (left != 0)\n            {\n            format3digits(left, buf, nested+1);\n            }\n\n        if (right != 0 || (left == 0 && nested==0))\n            {\n            if (right >= 100)\n                {\n                (left, right) = (right /% 100);\n                digits[left].appendTo(buf);\n                \" hundred \".appendTo(buf);\n                if (right != 0)\n                    {\n                    format2digits(right, buf);\n                    }\n                }\n            else\n                {\n                format2digits(right, buf);\n                }\n\n            if (nested > 0)\n                {\n                ten3rd[nested].appendTo(buf).add(' ');\n                }\n            }\n        }\n\n    static void format2digits(Int n, StringBuffer buf)\n        {\n        switch (n)\n            {\n            case 0..9:\n                digits[n].appendTo(buf).add(' ');\n                break;\n\n            case 10..19:\n                teens[n-10].appendTo(buf).add(' ');\n                break;\n\n            default:\n                (Int left, Int right) = n /% 10;\n                tens[left].appendTo(buf);\n                if (right == 0)\n                    {\n                    buf.add(' ');\n                    }\n                else\n                    {\n                    buf.add('-');\n                    digits[right].appendTo(buf).add(' ');\n                    }\n                break;\n            }\n        }\n    }\n"}
{"id": 146872, "name": "Number names", "source": "Translate Fortran to Python: program spell\n\n  implicit none\n  integer :: e\n  integer :: i\n  integer :: m\n  integer :: n\n  character (9), dimension (19), parameter :: small =       &\n    & (/'one      ', 'two      ', 'three    ', 'four     ', &\n    &   'five     ', 'six      ', 'seven    ', 'eight    ', &\n    &   'nine     ', 'ten      ', 'eleven   ', 'twelve   ', &\n    &   'thirteen ', 'fourteen ', 'fifteen  ', 'sixteen  ', &\n    &   'seventeen', 'eighteen ', 'nineteen '/)\n  character (7), dimension (2 : 9), parameter :: tens =        &\n    & (/'twenty ', 'thirty ', 'forty  ', 'fifty  ', 'sixty  ', &\n    &   'seventy', 'eighty ', 'ninety '/)\n  character (8), dimension (3), parameter :: big = &\n    & (/'thousand', 'million ', 'billion '/)\n  character (256) :: r\n\n  do\n    read (*, *, iostat = i) n\n    if (i /= 0) then\n      exit\n    end if\n    if (n == 0) then\n      r = 'zero'\n    else\n      r = ''\n      m = abs (n)\n      e = 0\n      do\n        if (m == 0) then\n          exit\n        end if\n        if (modulo (m, 1000) > 0) then\n          if (e > 0) then\n            r = trim (big (e)) // ' ' // r\n          end if\n          if (modulo (m, 100) > 0) then\n            if (modulo (m, 100) < 20) then\n              r = trim (small (modulo (m, 100))) // ' ' // r\n            else\n              if (modulo (m, 10) > 0) then\n                r = trim (small (modulo (m, 10))) // ' ' // r\n                r = trim (tens (modulo (m, 100) / 10)) // '-' // r\n              else\n                r = trim (tens (modulo (m, 100) / 10)) // ' ' // r\n              end if\n            end if\n          end if\n          if (modulo (m, 1000) / 100 > 0) then\n            r = 'hundred' // ' ' // r\n            r = trim (small (modulo (m, 1000) / 100)) // ' ' // r\n          end if\n        end if\n        m = m / 1000\n        e = e + 1\n      end do\n      if (n < 0) then\n        r = 'negative' // ' ' // r\n      end if\n    end if\n    write (*, '(a)') trim (r)\n  end do\n\nend program spell\n", "target": "TENS = [None, None, \"twenty\", \"thirty\", \"forty\",\n        \"fifty\", \"sixty\", \"seventy\", \"eighty\", \"ninety\"]\nSMALL = [\"zero\", \"one\", \"two\", \"three\", \"four\", \"five\",\n         \"six\", \"seven\", \"eight\", \"nine\", \"ten\", \"eleven\",\n         \"twelve\", \"thirteen\", \"fourteen\", \"fifteen\",\n         \"sixteen\", \"seventeen\", \"eighteen\", \"nineteen\"]\nHUGE = [None, None] + [h + \"illion\" \n                       for h in (\"m\", \"b\", \"tr\", \"quadr\", \"quint\", \"sext\", \n                                  \"sept\", \"oct\", \"non\", \"dec\")]\n\ndef nonzero(c, n, connect=''):\n    return \"\" if n == 0 else connect + c + spell_integer(n)\n\ndef last_and(num):\n    if ',' in num:\n        pre, last = num.rsplit(',', 1)\n        if ' and ' not in last:\n            last = ' and' + last\n        num = ''.join([pre, ',', last])\n    return num\n    \ndef big(e, n):\n    if e == 0:\n        return spell_integer(n)\n    elif e == 1:\n        return spell_integer(n) + \" thousand\"\n    else:\n        return spell_integer(n) + \" \" + HUGE[e]\n\ndef base1000_rev(n):\n    \n    \n    while n != 0:\n        n, r = divmod(n, 1000)\n        yield r\n \ndef spell_integer(n):\n    if n < 0:\n        return \"minus \" + spell_integer(-n)\n    elif n < 20:\n        return SMALL[n]\n    elif n < 100:\n        a, b = divmod(n, 10)\n        return TENS[a] + nonzero(\"-\", b)\n    elif n < 1000:\n        a, b = divmod(n, 100)\n        return SMALL[a] + \" hundred\" + nonzero(\" \", b, ' and')\n    else:\n        num = \", \".join([big(e, x) for e, x in\n                         enumerate(base1000_rev(n)) if x][::-1])\n        return last_and(num)\n\nif __name__ == '__main__':\n    \n    for n in (0, -3, 5, -7, 11, -13, 17, -19, 23, -29):\n        print('%+4i -> %s' % (n, spell_integer(n)))\n    print('')  \n    \n    n = 201021002001\n    while n:\n        print('%-12i -> %s' % (n, spell_integer(n)))\n        n //= -10\n    print('%-12i -> %s' % (n, spell_integer(n)))\n    print('')\n"}
{"id": 147092, "name": "Text processing_Max licenses in use", "source": "Translate Fortran to C#:  PROGRAM MAX_LICENSES\n   IMPLICIT NONE\n \n   INTEGER :: out=0, maxout=0, maxcount=0, err\n   CHARACTER(50) :: line\n   CHARACTER(19) :: maxtime(100)\n \n   OPEN (UNIT=5, FILE=\"Licenses.txt\", STATUS=\"OLD\", IOSTAT=err)\n   IF (err > 0) THEN\n     WRITE(*,*) \"Error opening file Licenses.txt\"\n     STOP\n   END IF\n \n   DO \n     READ(5, \"(A)\", IOSTAT=err) line\n     IF (err == -1) EXIT          \n     IF (line(9:9) == \"O\") THEN\n       out = out + 1\n     ELSE IF (line(9:9) == \"I\") THEN\n       out = out - 1\n     END IF\n     IF (out > maxout ) THEN\n       maxout = maxout + 1\n       maxcount = 1\n       maxtime(maxcount) = line(15:33)\n     ELSE IF (out == maxout) THEN\n       maxcount = maxcount + 1\n       maxtime(maxcount) = line(15:33)\n     END IF\n   END DO\n  \n   CLOSE(5)\n  \n   WRITE(*,\"(A,I4,A)\") \"Maximum simultaneous license use is\", maxout, \" at the following times:\"\n   WRITE(*,\"(A)\") maxtime(1:maxcount)\n  \n END PROGRAM MAX_LICENSES\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.IO;\n\nnamespace TextProc3\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {            \n            string line;\n            int count = 0, maxcount = 0;\n            List<string> times = new List<string>();\n            System.IO.StreamReader file = new StreamReader(\"mlijobs.txt\");\n            while ((line = file.ReadLine()) != null)\n            {\n                string[] lineelements = line.Split(' ');                \n                switch (lineelements[1])\n                {\n                    case \"IN\":\n                        count--;\n                        break;\n                    case \"OUT\":\n                        count++;\n                        if (count > maxcount)\n                        {\n                            maxcount = count;\n                            times.Clear();\n                            times.Add(lineelements[3]);\n                        }else if(count == maxcount){\n                            times.Add(lineelements[3]);\n                        }\n                        break;\n                }                \n            }\n            file.Close();\n            Console.WriteLine(maxcount);\n            foreach (string time in times)\n            {\n                Console.WriteLine(time);\n            }\n        }\n    }\n}\n"}
{"id": 147095, "name": "Text processing_Max licenses in use", "source": "Translate Fortran to Java:  PROGRAM MAX_LICENSES\n   IMPLICIT NONE\n \n   INTEGER :: out=0, maxout=0, maxcount=0, err\n   CHARACTER(50) :: line\n   CHARACTER(19) :: maxtime(100)\n \n   OPEN (UNIT=5, FILE=\"Licenses.txt\", STATUS=\"OLD\", IOSTAT=err)\n   IF (err > 0) THEN\n     WRITE(*,*) \"Error opening file Licenses.txt\"\n     STOP\n   END IF\n \n   DO \n     READ(5, \"(A)\", IOSTAT=err) line\n     IF (err == -1) EXIT          \n     IF (line(9:9) == \"O\") THEN\n       out = out + 1\n     ELSE IF (line(9:9) == \"I\") THEN\n       out = out - 1\n     END IF\n     IF (out > maxout ) THEN\n       maxout = maxout + 1\n       maxcount = 1\n       maxtime(maxcount) = line(15:33)\n     ELSE IF (out == maxout) THEN\n       maxcount = maxcount + 1\n       maxtime(maxcount) = line(15:33)\n     END IF\n   END DO\n  \n   CLOSE(5)\n  \n   WRITE(*,\"(A,I4,A)\") \"Maximum simultaneous license use is\", maxout, \" at the following times:\"\n   WRITE(*,\"(A)\") maxtime(1:maxcount)\n  \n END PROGRAM MAX_LICENSES\n", "target": "import java.io.BufferedReader;\nimport java.io.FileNotFoundException;\nimport java.io.FileReader;\nimport java.io.IOException;\nimport java.util.LinkedList;\n\npublic class License {\n  public static void main(String[] args) throws FileNotFoundException, IOException{\n    BufferedReader in = new BufferedReader(new FileReader(args[0]));\n    int max = Integer.MIN_VALUE;\n    LinkedList<String> dates = new LinkedList<String>();\n    String line;\n    int count = 0;\n    while((line = in.readLine()) != null){\n      if(line.startsWith(\"License OUT \")) count++;\n      if(line.startsWith(\"License IN \")) count--;\n      if(count > max){\n        max = count;\n        String date = line.split(\" \")[3];\n        dates.clear();\n        dates.add(date);\n      }else if(count == max){\n        String date = line.split(\" \")[3];\n        dates.add(date);\n      }\n    }\n    System.out.println(\"Max licenses out: \"+max);\n    System.out.println(\"At time(s): \"+dates);\n  }\n}\n"}
{"id": 147096, "name": "Text processing_Max licenses in use", "source": "Translate Fortran to Python:  PROGRAM MAX_LICENSES\n   IMPLICIT NONE\n \n   INTEGER :: out=0, maxout=0, maxcount=0, err\n   CHARACTER(50) :: line\n   CHARACTER(19) :: maxtime(100)\n \n   OPEN (UNIT=5, FILE=\"Licenses.txt\", STATUS=\"OLD\", IOSTAT=err)\n   IF (err > 0) THEN\n     WRITE(*,*) \"Error opening file Licenses.txt\"\n     STOP\n   END IF\n \n   DO \n     READ(5, \"(A)\", IOSTAT=err) line\n     IF (err == -1) EXIT          \n     IF (line(9:9) == \"O\") THEN\n       out = out + 1\n     ELSE IF (line(9:9) == \"I\") THEN\n       out = out - 1\n     END IF\n     IF (out > maxout ) THEN\n       maxout = maxout + 1\n       maxcount = 1\n       maxtime(maxcount) = line(15:33)\n     ELSE IF (out == maxout) THEN\n       maxcount = maxcount + 1\n       maxtime(maxcount) = line(15:33)\n     END IF\n   END DO\n  \n   CLOSE(5)\n  \n   WRITE(*,\"(A,I4,A)\") \"Maximum simultaneous license use is\", maxout, \" at the following times:\"\n   WRITE(*,\"(A)\") maxtime(1:maxcount)\n  \n END PROGRAM MAX_LICENSES\n", "target": "out, max_out, max_times = 0, -1, []\nfor job in open('mlijobs.txt'):\n    out += 1 if \"OUT\" in job else -1\n    if out > max_out:\n        max_out, max_times = out, []\n    if out == max_out:\n        max_times.append(job.split()[3])\n        \nprint(\"Maximum simultaneous license use is %i at the following times:\" % max_out)\nprint('  ' + '\\n  '.join(max_times))\n"}
{"id": 147288, "name": "Roots of a function", "source": "Translate Fortran to C#: PROGRAM ROOTS_OF_A_FUNCTION\n\n  IMPLICIT NONE\n\n  INTEGER, PARAMETER :: dp = SELECTED_REAL_KIND(15)\n  REAL(dp) :: f, e, x, step, value\n  LOGICAL :: s \n   \n  f(x) = x*x*x - 3.0_dp*x*x + 2.0_dp*x\n   \n  x = -1.0_dp ; step = 1.0e-6_dp ; e = 1.0e-9_dp\n \n  s = (f(x) > 0)\n  DO WHILE (x < 3.0)\n    value = f(x)\n    IF(ABS(value) < e) THEN\n      WRITE(*,\"(A,F12.9)\") \"Root found at x =\", x\n      s = .NOT. s\n    ELSE IF ((value > 0) .NEQV. s) THEN\n      WRITE(*,\"(A,F12.9)\") \"Root found near x = \", x\n      s = .NOT. s\n    END IF\n    x = x + step\n  END DO\n \nEND PROGRAM ROOTS_OF_A_FUNCTION\n", "target": "using System;\n\nclass Program\n{\n    public static void Main(string[] args)\n    {\n        Func<double, double> f = x => { return x * x * x - 3 * x * x + 2 * x; };\n\n        double step = 0.001; \n        double start = -1;\n        double stop = 3;\n        double value = f(start);\n        int sign = (value > 0) ? 1 : 0;\n \n        \n        if (value == 0)\n            Console.WriteLine(\"Root found at {0}\", start);\n\n        for (var x = start + step; x <= stop; x += step)\n        {\n            value = f(x);\n \n            if (((value > 0) ? 1 : 0) != sign)\n                \n                Console.WriteLine(\"Root found near {0}\", x);\n            else if (value == 0)\n                \n                Console.WriteLine(\"Root found at {0}\", x);\n \n            \n            sign = (value > 0) ? 1 : 0;\n        }\n    }\n}\n"}
{"id": 147292, "name": "Roots of a function", "source": "Translate Fortran to Java: PROGRAM ROOTS_OF_A_FUNCTION\n\n  IMPLICIT NONE\n\n  INTEGER, PARAMETER :: dp = SELECTED_REAL_KIND(15)\n  REAL(dp) :: f, e, x, step, value\n  LOGICAL :: s \n   \n  f(x) = x*x*x - 3.0_dp*x*x + 2.0_dp*x\n   \n  x = -1.0_dp ; step = 1.0e-6_dp ; e = 1.0e-9_dp\n \n  s = (f(x) > 0)\n  DO WHILE (x < 3.0)\n    value = f(x)\n    IF(ABS(value) < e) THEN\n      WRITE(*,\"(A,F12.9)\") \"Root found at x =\", x\n      s = .NOT. s\n    ELSE IF ((value > 0) .NEQV. s) THEN\n      WRITE(*,\"(A,F12.9)\") \"Root found near x = \", x\n      s = .NOT. s\n    END IF\n    x = x + step\n  END DO\n \nEND PROGRAM ROOTS_OF_A_FUNCTION\n", "target": "public class Roots {\n    public interface Function {\n\tpublic double f(double x);\n    }\n\n    private static int sign(double x) {\n\treturn (x < 0.0) ? -1 : (x > 0.0) ? 1 : 0;\n    }\n\n    public static void printRoots(Function f, double lowerBound,\n\t\t\t\t  double upperBound, double step) {\n\tdouble x = lowerBound, ox = x;\n\tdouble y = f.f(x), oy = y;\n\tint s = sign(y), os = s;\n\n\tfor (; x <= upperBound ; x += step) {\n\t    s = sign(y = f.f(x));\n\t    if (s == 0) {\n\t\tSystem.out.println(x);\n\t    } else if (s != os) {\n\t\tdouble dx = x - ox;\n\t\tdouble dy = y - oy;\n\t\tdouble cx = x - dx * (y / dy);\n\t\tSystem.out.println(\"~\" + cx);\n\t    }\n\t    ox = x; oy = y; os = s;\n\t}\n    }\n\n    public static void main(String[] args) {\n\tFunction poly = new Function () {\n\t    public double f(double x) {\n\t\treturn x*x*x - 3*x*x + 2*x;\n\t    }\n\t};\n\tprintRoots(poly, -1.0, 4, 0.002);\n    }\n}\n"}
{"id": 147293, "name": "Roots of a function", "source": "Translate Fortran to Python: PROGRAM ROOTS_OF_A_FUNCTION\n\n  IMPLICIT NONE\n\n  INTEGER, PARAMETER :: dp = SELECTED_REAL_KIND(15)\n  REAL(dp) :: f, e, x, step, value\n  LOGICAL :: s \n   \n  f(x) = x*x*x - 3.0_dp*x*x + 2.0_dp*x\n   \n  x = -1.0_dp ; step = 1.0e-6_dp ; e = 1.0e-9_dp\n \n  s = (f(x) > 0)\n  DO WHILE (x < 3.0)\n    value = f(x)\n    IF(ABS(value) < e) THEN\n      WRITE(*,\"(A,F12.9)\") \"Root found at x =\", x\n      s = .NOT. s\n    ELSE IF ((value > 0) .NEQV. s) THEN\n      WRITE(*,\"(A,F12.9)\") \"Root found near x = \", x\n      s = .NOT. s\n    END IF\n    x = x + step\n  END DO\n \nEND PROGRAM ROOTS_OF_A_FUNCTION\n", "target": "f = lambda x: x * x * x - 3 * x * x + 2 * x\n\nstep = 0.001 \nstart = -1\nstop = 3\n\nsign = f(start) > 0\n\nx = start\nwhile x <= stop:\n    value = f(x)\n\n    if value == 0:\n        \n        print \"Root found at\", x\n    elif (value > 0) != sign:\n        \n        print \"Root found near\", x\n\n    \n    sign = value > 0\n\n    x += step\n"}
{"id": 147444, "name": "Sequence of primes by trial division", "source": "Translate Fortran to C#: CONCOCTED BY R.N.MCLEAN, APPLIED MATHS COURSE, AUCKLAND UNIVERSITY, MCMLXXI.\n      INTEGER ENUFF,PRIME(44)\nCALCULATION SHOWS PRIME(43) = 181, AND PRIME(44) = 191.\n      INTEGER N,F,Q,XP2\n      INTEGER INC,IP,LP,PP\n      INTEGER ALINE(20),LL,I\n      DATA ENUFF/44/\n      DATA PP/4/\n      DATA PRIME(1),PRIME(2),PRIME(3),PRIME(4)/1,2,3,5/\nCOPY THE KNOWN PRIMES TO THE OUTPUT LINE.\n      DO 1 I = 1,PP\n    1   ALINE(I) = PRIME(I)\n      LL = PP\n      LP = 3\n      XP2 = PRIME(LP + 1)**2\n      N = 5\n      INC = 4\nCONSIDER ANOTHER CANDIDATE. VIA INC, DODGE MULTIPLES OF 2 AND 3.\n   10 INC = 6 - INC\n      N = N + INC\n      IF (N - XP2) 20,11,20\n   11 LP = LP + 1\n      XP2 = PRIME(LP + 1)**2\n      GO TO 40\nCHECK SUCCESSIVE PRIMES AS FACTORS, STARTING WITH PRIME(4) = 5.\n   20 IP = 4\n   21 F = PRIME(IP)\n      Q = N/F\n      IF (Q*F - N) 22,40,22\n   22 IP = IP + 1\n      IF (IP - LP) 21,21,30\nCAUGHT ANOTHER PRIME.\n   30 IF (PP - ENUFF) 31,32,32\n   31 PP = PP + 1\n      PRIME(PP) = N\n   32 IF (LL - 20) 35,33,33\n   33 WRITE (6,34) (ALINE(I), I = 1,LL)\n   34 FORMAT (20I6)\n      LL = 0\n   35 LL = LL + 1\n      ALINE(LL) = N\nCOMPLETED?\n   40 IF (N - 32767) 10,41,41\n   41 WRITE (6,34) (ALINE(I), I = 1,LL)\n      END\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\npublic class Program\n{\n    static void Main() {\n        Console.WriteLine(string.Join(\" \", Primes(100)));\n    }\n\n    static IEnumerable<int> Primes(int limit) => Enumerable.Range(2, limit-1).Where(IsPrime);\n    static bool IsPrime(int n) => Enumerable.Range(2, (int)Math.Sqrt(n)-1).All(i => n % i != 0);\n}\n"}
{"id": 147447, "name": "Sequence of primes by trial division", "source": "Translate Fortran to Java: CONCOCTED BY R.N.MCLEAN, APPLIED MATHS COURSE, AUCKLAND UNIVERSITY, MCMLXXI.\n      INTEGER ENUFF,PRIME(44)\nCALCULATION SHOWS PRIME(43) = 181, AND PRIME(44) = 191.\n      INTEGER N,F,Q,XP2\n      INTEGER INC,IP,LP,PP\n      INTEGER ALINE(20),LL,I\n      DATA ENUFF/44/\n      DATA PP/4/\n      DATA PRIME(1),PRIME(2),PRIME(3),PRIME(4)/1,2,3,5/\nCOPY THE KNOWN PRIMES TO THE OUTPUT LINE.\n      DO 1 I = 1,PP\n    1   ALINE(I) = PRIME(I)\n      LL = PP\n      LP = 3\n      XP2 = PRIME(LP + 1)**2\n      N = 5\n      INC = 4\nCONSIDER ANOTHER CANDIDATE. VIA INC, DODGE MULTIPLES OF 2 AND 3.\n   10 INC = 6 - INC\n      N = N + INC\n      IF (N - XP2) 20,11,20\n   11 LP = LP + 1\n      XP2 = PRIME(LP + 1)**2\n      GO TO 40\nCHECK SUCCESSIVE PRIMES AS FACTORS, STARTING WITH PRIME(4) = 5.\n   20 IP = 4\n   21 F = PRIME(IP)\n      Q = N/F\n      IF (Q*F - N) 22,40,22\n   22 IP = IP + 1\n      IF (IP - LP) 21,21,30\nCAUGHT ANOTHER PRIME.\n   30 IF (PP - ENUFF) 31,32,32\n   31 PP = PP + 1\n      PRIME(PP) = N\n   32 IF (LL - 20) 35,33,33\n   33 WRITE (6,34) (ALINE(I), I = 1,LL)\n   34 FORMAT (20I6)\n      LL = 0\n   35 LL = LL + 1\n      ALINE(LL) = N\nCOMPLETED?\n   40 IF (N - 32767) 10,41,41\n   41 WRITE (6,34) (ALINE(I), I = 1,LL)\n      END\n", "target": "import java.util.stream.IntStream;\n\npublic class Test {\n\n    static IntStream getPrimes(int start, int end) {\n        return IntStream.rangeClosed(start, end).filter(n -> isPrime(n));\n    }\n\n    public static boolean isPrime(long x) {\n        if (x < 3 || x % 2 == 0)\n            return x == 2;\n\n        long max = (long) Math.sqrt(x);\n        for (long n = 3; n <= max; n += 2) {\n            if (x % n == 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    public static void main(String[] args) {\n        getPrimes(0, 100).forEach(p -> System.out.printf(\"%d, \", p));\n    }\n}\n"}
{"id": 147448, "name": "Sequence of primes by trial division", "source": "Translate Fortran to Python: CONCOCTED BY R.N.MCLEAN, APPLIED MATHS COURSE, AUCKLAND UNIVERSITY, MCMLXXI.\n      INTEGER ENUFF,PRIME(44)\nCALCULATION SHOWS PRIME(43) = 181, AND PRIME(44) = 191.\n      INTEGER N,F,Q,XP2\n      INTEGER INC,IP,LP,PP\n      INTEGER ALINE(20),LL,I\n      DATA ENUFF/44/\n      DATA PP/4/\n      DATA PRIME(1),PRIME(2),PRIME(3),PRIME(4)/1,2,3,5/\nCOPY THE KNOWN PRIMES TO THE OUTPUT LINE.\n      DO 1 I = 1,PP\n    1   ALINE(I) = PRIME(I)\n      LL = PP\n      LP = 3\n      XP2 = PRIME(LP + 1)**2\n      N = 5\n      INC = 4\nCONSIDER ANOTHER CANDIDATE. VIA INC, DODGE MULTIPLES OF 2 AND 3.\n   10 INC = 6 - INC\n      N = N + INC\n      IF (N - XP2) 20,11,20\n   11 LP = LP + 1\n      XP2 = PRIME(LP + 1)**2\n      GO TO 40\nCHECK SUCCESSIVE PRIMES AS FACTORS, STARTING WITH PRIME(4) = 5.\n   20 IP = 4\n   21 F = PRIME(IP)\n      Q = N/F\n      IF (Q*F - N) 22,40,22\n   22 IP = IP + 1\n      IF (IP - LP) 21,21,30\nCAUGHT ANOTHER PRIME.\n   30 IF (PP - ENUFF) 31,32,32\n   31 PP = PP + 1\n      PRIME(PP) = N\n   32 IF (LL - 20) 35,33,33\n   33 WRITE (6,34) (ALINE(I), I = 1,LL)\n   34 FORMAT (20I6)\n      LL = 0\n   35 LL = LL + 1\n      ALINE(LL) = N\nCOMPLETED?\n   40 IF (N - 32767) 10,41,41\n   41 WRITE (6,34) (ALINE(I), I = 1,LL)\n      END\n", "target": "def prime(a):\n    return not (a < 2 or any(a % x == 0 for x in xrange(2, int(a**0.5) + 1)))\n\ndef primes_below(n):\n    return [i for i in range(n) if prime(i)]\n"}
{"id": 147640, "name": "Linear congruential generator", "source": "Translate Fortran to C#: module lcgs\n  implicit none\n\n  integer, parameter :: i64 = selected_int_kind(18)\n  integer, parameter :: a1 = 1103515245, a2 = 214013\n  integer, parameter :: c1 = 12345, c2 = 2531011\n  integer, parameter :: div = 65536\n  integer(i64), parameter :: m = 2147483648_i64  \n                                                 \ncontains \n\nfunction bsdrand(seed)\n  integer :: bsdrand\n  integer, optional, intent(in) :: seed\n  integer(i64) :: x = 0\n  \n  if(present(seed)) x = seed\n  x = mod(a1 * x + c1, m)\n  bsdrand = x\nend function\n\nfunction msrand(seed)\n  integer :: msrand\n  integer, optional, intent(in) :: seed\n  integer(i64) :: x = 0\n \n  if(present(seed)) x = seed \n  x = mod(a2 * x + c2, m)\n  msrand = x / div\nend function\nend module\n\nprogram lcgtest\n  use lcgs\n  implicit none\n  integer :: i\n  \n  write(*, \"(a)\") \"      BSD            MS\"\n  do i = 1, 10\n    write(*, \"(2i12)\") bsdrand(), msrand()\n  end do\nend program\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing static System.Console;\n\nnamespace LinearCongruentialGenerator\n{\n    static class LinearCongruentialGenerator\n    {\n        static int _seed = (int)DateTime.Now.Ticks; \n        static int _bsdCurrent = _seed;\n        static int _msvcrtCurrent = _seed;\n\n        static int Next(int seed, int a, int b) => (a * seed + b) & int.MaxValue;\n\n        static int BsdRand() => _bsdCurrent = Next(_bsdCurrent, 1103515245, 12345); \n\n        static int MscvrtRand() => _msvcrtCurrent = Next (_msvcrtCurrent << 16,214013,2531011) >> 16;\n\n        static void PrintRandom(int count, bool isBsd)\n        {\n            var name = isBsd ? \"BSD\" : \"MS\";\n            WriteLine($\"{name} next {count} Random\");\n            var gen = isBsd ? (Func<int>)(BsdRand) : MscvrtRand;\n            foreach (var r in Enumerable.Repeat(gen, count))\n                WriteLine(r.Invoke());\n        }\n\n        static void Main(string[] args)\n        {\n            PrintRandom(10, true);\n            PrintRandom(10, false);\n            Read();\n        }\n    }\n}\n"}
{"id": 147644, "name": "Linear congruential generator", "source": "Translate Fortran to Java: module lcgs\n  implicit none\n\n  integer, parameter :: i64 = selected_int_kind(18)\n  integer, parameter :: a1 = 1103515245, a2 = 214013\n  integer, parameter :: c1 = 12345, c2 = 2531011\n  integer, parameter :: div = 65536\n  integer(i64), parameter :: m = 2147483648_i64  \n                                                 \ncontains \n\nfunction bsdrand(seed)\n  integer :: bsdrand\n  integer, optional, intent(in) :: seed\n  integer(i64) :: x = 0\n  \n  if(present(seed)) x = seed\n  x = mod(a1 * x + c1, m)\n  bsdrand = x\nend function\n\nfunction msrand(seed)\n  integer :: msrand\n  integer, optional, intent(in) :: seed\n  integer(i64) :: x = 0\n \n  if(present(seed)) x = seed \n  x = mod(a2 * x + c2, m)\n  msrand = x / div\nend function\nend module\n\nprogram lcgtest\n  use lcgs\n  implicit none\n  integer :: i\n  \n  write(*, \"(a)\") \"      BSD            MS\"\n  do i = 1, 10\n    write(*, \"(2i12)\") bsdrand(), msrand()\n  end do\nend program\n", "target": "import java.util.stream.IntStream;\nimport static java.util.stream.IntStream.iterate;\n\npublic class LinearCongruentialGenerator {\n    final static int mask = (1 << 31) - 1;\n\n    public static void main(String[] args) {\n        System.out.println(\"BSD:\");\n        randBSD(0).limit(10).forEach(System.out::println);\n\n        System.out.println(\"\\nMS:\");\n        randMS(0).limit(10).forEach(System.out::println);\n    }\n\n    static IntStream randBSD(int seed) {\n        return iterate(seed, s -> (s * 1_103_515_245 + 12_345) & mask).skip(1);\n    }\n\n    static IntStream randMS(int seed) {\n        return iterate(seed, s -> (s * 214_013 + 2_531_011) & mask).skip(1)\n                .map(i -> i >> 16);\n    }\n}\n"}
{"id": 147645, "name": "Linear congruential generator", "source": "Translate Fortran to Python: module lcgs\n  implicit none\n\n  integer, parameter :: i64 = selected_int_kind(18)\n  integer, parameter :: a1 = 1103515245, a2 = 214013\n  integer, parameter :: c1 = 12345, c2 = 2531011\n  integer, parameter :: div = 65536\n  integer(i64), parameter :: m = 2147483648_i64  \n                                                 \ncontains \n\nfunction bsdrand(seed)\n  integer :: bsdrand\n  integer, optional, intent(in) :: seed\n  integer(i64) :: x = 0\n  \n  if(present(seed)) x = seed\n  x = mod(a1 * x + c1, m)\n  bsdrand = x\nend function\n\nfunction msrand(seed)\n  integer :: msrand\n  integer, optional, intent(in) :: seed\n  integer(i64) :: x = 0\n \n  if(present(seed)) x = seed \n  x = mod(a2 * x + c2, m)\n  msrand = x / div\nend function\nend module\n\nprogram lcgtest\n  use lcgs\n  implicit none\n  integer :: i\n  \n  write(*, \"(a)\") \"      BSD            MS\"\n  do i = 1, 10\n    write(*, \"(2i12)\") bsdrand(), msrand()\n  end do\nend program\n", "target": "def bsd_rand(seed):\n   def rand():\n      rand.seed = (1103515245*rand.seed + 12345) & 0x7fffffff\n      return rand.seed\n   rand.seed = seed\n   return rand\n\ndef msvcrt_rand(seed):\n   def rand():\n      rand.seed = (214013*rand.seed + 2531011) & 0x7fffffff\n      return rand.seed >> 16\n   rand.seed = seed\n   return rand\n"}
{"id": 147900, "name": "Sorting algorithms_Selection sort", "source": "Translate Fortran to C#: PROGRAM SELECTION\n\n  IMPLICIT NONE\n\n  INTEGER :: intArray(10) = (/ 4, 9, 3, -2, 0, 7, -5, 1, 6, 8 /)\n \n  WRITE(*,\"(A,10I5)\") \"Unsorted array:\", intArray\n  CALL Selection_sort(intArray)\n  WRITE(*,\"(A,10I5)\") \"Sorted array \u00a0:\", intArray\n   \nCONTAINS\n \n  SUBROUTINE Selection_sort(a)\n    INTEGER, INTENT(IN OUT) :: a(:)\n    INTEGER :: i, minIndex, temp\n\n    DO i = 1, SIZE(a)-1\n       minIndex = MINLOC(a(i:), 1) + i - 1\n       IF (a(i) > a(minIndex)) THEN\n          temp = a(i)\n          a(i) = a(minIndex)\n          a(minIndex) = temp\n       END IF\n    END DO\n  END SUBROUTINE Selection_sort\n\nEND PROGRAM SELECTION\n", "target": "class SelectionSort<T> where T : IComparable {\n    public T[] Sort(T[] list) {\n        int k;\n        T temp;\n\n        for (int i = 0; i < list.Length; i++) {\n            k = i;\n            for (int j=i + 1; j < list.Length; j++) {\n                if (list[j].CompareTo(list[k]) < 0) {\n                    k = j;\n                }\n            }\n            temp = list[i];\n            list[i] = list[k];\n            list[k] = temp;\n        }\n\n        return list;\n    }\n}\n"}
{"id": 147903, "name": "Sorting algorithms_Selection sort", "source": "Translate Fortran to Java: PROGRAM SELECTION\n\n  IMPLICIT NONE\n\n  INTEGER :: intArray(10) = (/ 4, 9, 3, -2, 0, 7, -5, 1, 6, 8 /)\n \n  WRITE(*,\"(A,10I5)\") \"Unsorted array:\", intArray\n  CALL Selection_sort(intArray)\n  WRITE(*,\"(A,10I5)\") \"Sorted array \u00a0:\", intArray\n   \nCONTAINS\n \n  SUBROUTINE Selection_sort(a)\n    INTEGER, INTENT(IN OUT) :: a(:)\n    INTEGER :: i, minIndex, temp\n\n    DO i = 1, SIZE(a)-1\n       minIndex = MINLOC(a(i:), 1) + i - 1\n       IF (a(i) > a(minIndex)) THEN\n          temp = a(i)\n          a(i) = a(minIndex)\n          a(minIndex) = temp\n       END IF\n    END DO\n  END SUBROUTINE Selection_sort\n\nEND PROGRAM SELECTION\n", "target": "public static void sort(int[] nums){\n\tfor(int currentPlace = 0;currentPlace<nums.length-1;currentPlace++){\n\t\tint smallest = Integer.MAX_VALUE;\n\t\tint smallestAt = currentPlace+1;\n\t\tfor(int check = currentPlace; check<nums.length;check++){\n\t\t\tif(nums[check]<smallest){\n\t\t\t\tsmallestAt = check;\n\t\t\t\tsmallest = nums[check];\n\t\t\t}\n\t\t}\n\t\tint temp = nums[currentPlace];\n\t\tnums[currentPlace] = nums[smallestAt];\n\t\tnums[smallestAt] = temp;\n\t}\n}\n"}
{"id": 147904, "name": "Sorting algorithms_Selection sort", "source": "Translate Fortran to Python: PROGRAM SELECTION\n\n  IMPLICIT NONE\n\n  INTEGER :: intArray(10) = (/ 4, 9, 3, -2, 0, 7, -5, 1, 6, 8 /)\n \n  WRITE(*,\"(A,10I5)\") \"Unsorted array:\", intArray\n  CALL Selection_sort(intArray)\n  WRITE(*,\"(A,10I5)\") \"Sorted array \u00a0:\", intArray\n   \nCONTAINS\n \n  SUBROUTINE Selection_sort(a)\n    INTEGER, INTENT(IN OUT) :: a(:)\n    INTEGER :: i, minIndex, temp\n\n    DO i = 1, SIZE(a)-1\n       minIndex = MINLOC(a(i:), 1) + i - 1\n       IF (a(i) > a(minIndex)) THEN\n          temp = a(i)\n          a(i) = a(minIndex)\n          a(minIndex) = temp\n       END IF\n    END DO\n  END SUBROUTINE Selection_sort\n\nEND PROGRAM SELECTION\n", "target": "def selection_sort(lst):\n    for i, e in enumerate(lst):\n        mn = min(range(i,len(lst)), key=lst.__getitem__)\n        lst[i], lst[mn] = lst[mn], e\n    return lst\n"}
{"id": 148142, "name": "Sorting algorithms_Comb sort", "source": "Translate Fortran to C#: program Combsort_Demo\n  implicit none\n \n  integer, parameter :: num = 20\n  real :: array(num)\n \n  call random_seed\n  call random_number(array)\n  write(*,*) \"Unsorted array:-\"\n  write(*,*) array\n  write(*,*)\n  call combsort(array)\n  write(*,*) \"Sorted array:-\"\n  write(*,*) array\n  \ncontains\n \n  subroutine combsort(a)\n \n    real, intent(in out) :: a(:)\n    real :: temp\n    integer :: i, gap\n    logical :: swapped = .true.\n \n    gap = size(a)\n    do while (gap > 1 .or. swapped)\n      gap = gap / 1.3\n      if (gap < 1) gap = 1\n      swapped = .false.\n      do i = 1, size(a)-gap\n        if (a(i) > a(i+gap)) then\n          temp = a(i)\n          a(i) = a(i+gap)\n          a(i+gap) = temp;\n          swapped = .true.\n        end if\n      end do\n    end do\n \n  end subroutine combsort\n \nend program Combsort_Demo\n", "target": "using System;\n\nnamespace CombSort\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            int[] unsorted = new int[] { 3, 5, 1, 9, 7, 6, 8, 2, 4 };\n            Console.WriteLine(string.Join(\",\", combSort(unsorted)));\n        }\n        public static int[] combSort(int[] input)\n        {\n            double gap = input.Length;\n            bool swaps = true;\n            while (gap > 1 || swaps)\n            {\n                gap /= 1.247330950103979;\n                if (gap < 1) { gap = 1; }\n                int i = 0;\n                swaps = false;\n                while (i + gap < input.Length)\n                {\n                    int igap = i + (int)gap;\n                    if (input[i] > input[igap])\n                    {\n                        int swap = input[i];\n                        input[i] = input[igap];\n                        input[igap] = swap;\n                        swaps = true;\n                    }\n                    i++;\n                }\n            }\n            return input;\n        }\n    }\n}\n"}
{"id": 148145, "name": "Sorting algorithms_Comb sort", "source": "Translate Fortran to Java: program Combsort_Demo\n  implicit none\n \n  integer, parameter :: num = 20\n  real :: array(num)\n \n  call random_seed\n  call random_number(array)\n  write(*,*) \"Unsorted array:-\"\n  write(*,*) array\n  write(*,*)\n  call combsort(array)\n  write(*,*) \"Sorted array:-\"\n  write(*,*) array\n  \ncontains\n \n  subroutine combsort(a)\n \n    real, intent(in out) :: a(:)\n    real :: temp\n    integer :: i, gap\n    logical :: swapped = .true.\n \n    gap = size(a)\n    do while (gap > 1 .or. swapped)\n      gap = gap / 1.3\n      if (gap < 1) gap = 1\n      swapped = .false.\n      do i = 1, size(a)-gap\n        if (a(i) > a(i+gap)) then\n          temp = a(i)\n          a(i) = a(i+gap)\n          a(i+gap) = temp;\n          swapped = .true.\n        end if\n      end do\n    end do\n \n  end subroutine combsort\n \nend program Combsort_Demo\n", "target": "public static <E extends Comparable<? super E>> void sort(E[] input) {\n    int gap = input.length;\n    boolean swapped = true;\n    while (gap > 1 || swapped) {\n        if (gap > 1) {\n            gap = (int) (gap / 1.3);\n        }\n        swapped = false;\n        for (int i = 0; i + gap < input.length; i++) {\n            if (input[i].compareTo(input[i + gap]) > 0) {\n                E t = input[i];\n                input[i] = input[i + gap];\n                input[i + gap] = t;\n                swapped = true;\n            }\n        }\n    }\n}\n"}
{"id": 148146, "name": "Sorting algorithms_Comb sort", "source": "Translate Fortran to Python: program Combsort_Demo\n  implicit none\n \n  integer, parameter :: num = 20\n  real :: array(num)\n \n  call random_seed\n  call random_number(array)\n  write(*,*) \"Unsorted array:-\"\n  write(*,*) array\n  write(*,*)\n  call combsort(array)\n  write(*,*) \"Sorted array:-\"\n  write(*,*) array\n  \ncontains\n \n  subroutine combsort(a)\n \n    real, intent(in out) :: a(:)\n    real :: temp\n    integer :: i, gap\n    logical :: swapped = .true.\n \n    gap = size(a)\n    do while (gap > 1 .or. swapped)\n      gap = gap / 1.3\n      if (gap < 1) gap = 1\n      swapped = .false.\n      do i = 1, size(a)-gap\n        if (a(i) > a(i+gap)) then\n          temp = a(i)\n          a(i) = a(i+gap)\n          a(i+gap) = temp;\n          swapped = .true.\n        end if\n      end do\n    end do\n \n  end subroutine combsort\n \nend program Combsort_Demo\n", "target": ">>> def combsort(input):\n    gap = len(input)\n    swaps = True\n    while gap > 1 or swaps:\n        gap = max(1, int(gap / 1.25))  \n        swaps = False\n        for i in range(len(input) - gap):\n            j = i+gap\n            if input[i] > input[j]:\n                input[i], input[j] = input[j], input[i]\n                swaps = True\n\n                \n>>> y = [88, 18, 31, 44, 4, 0, 8, 81, 14, 78, 20, 76, 84, 33, 73, 75, 82, 5, 62, 70]\n>>> combsort(y)\n>>> assert y == sorted(y)\n>>> y\n[0, 4, 5, 8, 14, 18, 20, 31, 33, 44, 62, 70, 73, 75, 76, 78, 81, 82, 84, 88]\n>>>\n"}
{"id": 148387, "name": "Horizontal sundial calculations", "source": "Translate Fortran to C#: program SunDial\n\n  real    :: lat, slat, lng, ref\n  real    :: hra, hla\n  integer :: h\n\n  real, parameter :: pi = 3.14159265358979323846\n\n  print *, \"Enter latitude\"\n  read *, lat\n  print *, \"Enter longitude\"\n  read *, lng\n  print *, \"Enter legal meridian\"\n  read *, ref\n\n  print *\n\n  slat = sin(dr(lat))\n  write(*, '(A,1F6.3)') \"sine of latitude: \", slat\n  write(*, '(A,1F6.3)') \"diff longitude: \", lng - ref\n\n  print *, \"Hour, sun hour angle, dial hour line angle from 6am to 6pm\"\n\n  do h = -6, 6\n     hra = 15.0*h\n     hra = hra - lng + ref\n     hla = rd( atan( slat * tan( dr(hra) ) ) )\n     write(*, '(\" HR= \",I3,\";  \\t  HRA=\",F7.3,\";  \\t  HLA= \", F7.3)'), h, hra, hla\n  end do\n\ncontains\n\n  function dr(angle)\n    real :: dr\n    real, intent(in) :: angle\n    dr = angle*pi/180.0\n  end function dr\n\n  function rd(angle)\n    real :: rd\n    real, intent(in) :: angle\n    rd = angle*180.0/pi\n  end function rd\n\nend program SunDial\n", "target": "using System;\n\nnamespace RosettaCode\n{\n  internal sealed class Program\n  {\n    private static void Main()\n    {\n      Func<double> getDouble = () => Convert.ToDouble(Console.ReadLine());\n      double h = 0, lat, lng, lme, slat, hra, hla;\n\n      Console.Write(\"Enter latitude       => \");\n      lat = getDouble();\n      Console.Write(\"Enter longitude      => \");\n      lng = getDouble();\n      Console.Write(\"Enter legal meridian => \");\n      lme = getDouble();\n\n      slat = Math.Sin(lat*2*Math.PI/360);\n      Console.WriteLine(\"\\n    sine of latitude:   {0:0.000}\", slat);\n      Console.WriteLine(\"    diff longitude:     {0:0.000}\\n\", lng-lme);\n      Console.WriteLine(\"Hour, sun hour angle, dial hour line angle from 6am to 6pm\");\n      for (h = -6; h<6; h++)\n      {\n        hra = 15*h;\n        hra -= lng-lme;\n        hla = Math.Atan(slat*Math.Tan(hra*2*Math.PI/360))*360/(2*Math.PI);\n        Console.WriteLine(\"HR= {0,7:0.000}; HRA {1,7:0.000}; HLA= {2,7:0.000}\", h, hra, hla);\n      }\n    }\n  }\n}\n"}
{"id": 148390, "name": "Horizontal sundial calculations", "source": "Translate Fortran to Java: program SunDial\n\n  real    :: lat, slat, lng, ref\n  real    :: hra, hla\n  integer :: h\n\n  real, parameter :: pi = 3.14159265358979323846\n\n  print *, \"Enter latitude\"\n  read *, lat\n  print *, \"Enter longitude\"\n  read *, lng\n  print *, \"Enter legal meridian\"\n  read *, ref\n\n  print *\n\n  slat = sin(dr(lat))\n  write(*, '(A,1F6.3)') \"sine of latitude: \", slat\n  write(*, '(A,1F6.3)') \"diff longitude: \", lng - ref\n\n  print *, \"Hour, sun hour angle, dial hour line angle from 6am to 6pm\"\n\n  do h = -6, 6\n     hra = 15.0*h\n     hra = hra - lng + ref\n     hla = rd( atan( slat * tan( dr(hra) ) ) )\n     write(*, '(\" HR= \",I3,\";  \\t  HRA=\",F7.3,\";  \\t  HLA= \", F7.3)'), h, hra, hla\n  end do\n\ncontains\n\n  function dr(angle)\n    real :: dr\n    real, intent(in) :: angle\n    dr = angle*pi/180.0\n  end function dr\n\n  function rd(angle)\n    real :: rd\n    real, intent(in) :: angle\n    rd = angle*180.0/pi\n  end function rd\n\nend program SunDial\n", "target": "import java.util.Scanner;\n\npublic class Sundial {\n    public static void main(String[] args) {\n        double lat, slat, lng, ref;\n        Scanner sc = new Scanner(System.in);\n\n        System.out.print(\"Enter latitude: \");\n        lat = sc.nextDouble();\n        System.out.print(\"Enter longitude: \");\n        lng = sc.nextDouble();\n        System.out.print(\"Enter legal meridian: \");\n        ref = sc.nextDouble();\n        System.out.println();\n\n        slat = Math.sin(Math.toRadians(lat));\n        System.out.printf(\"sine of latitude:\u00a0%.3f\\n\", slat);\n        System.out.printf(\"diff longitude:\u00a0%.3f\\n\\n\", lng - ref);\n\n        System.out.printf(\"Hour, sun hour angle, dial hour line angle from 6am to 6pm\\n\");\n\n        for (int h = -6; h <= 6; h++) {\n            double hla, hra, hraRad;\n            hra = 15.0 * h;\n            hra = hra - lng + ref;\n            hraRad = Math.toRadians(hra);\n            hla = Math.toDegrees(Math.atan2(Math.sin(hraRad)*Math.sin(Math.toRadians(lat)), Math.cos(hraRad)));\n            System.out.printf(\"HR= %3d;  \\t  HRA=%7.3f;  \\t  HLA= %7.3f\\n\",\n                    h, hra, hla);\n        }\n    }\n}\n"}
{"id": 148391, "name": "Horizontal sundial calculations", "source": "Translate Fortran to Python: program SunDial\n\n  real    :: lat, slat, lng, ref\n  real    :: hra, hla\n  integer :: h\n\n  real, parameter :: pi = 3.14159265358979323846\n\n  print *, \"Enter latitude\"\n  read *, lat\n  print *, \"Enter longitude\"\n  read *, lng\n  print *, \"Enter legal meridian\"\n  read *, ref\n\n  print *\n\n  slat = sin(dr(lat))\n  write(*, '(A,1F6.3)') \"sine of latitude: \", slat\n  write(*, '(A,1F6.3)') \"diff longitude: \", lng - ref\n\n  print *, \"Hour, sun hour angle, dial hour line angle from 6am to 6pm\"\n\n  do h = -6, 6\n     hra = 15.0*h\n     hra = hra - lng + ref\n     hla = rd( atan( slat * tan( dr(hra) ) ) )\n     write(*, '(\" HR= \",I3,\";  \\t  HRA=\",F7.3,\";  \\t  HLA= \", F7.3)'), h, hra, hla\n  end do\n\ncontains\n\n  function dr(angle)\n    real :: dr\n    real, intent(in) :: angle\n    dr = angle*pi/180.0\n  end function dr\n\n  function rd(angle)\n    real :: rd\n    real, intent(in) :: angle\n    rd = angle*180.0/pi\n  end function rd\n\nend program SunDial\n", "target": "from __future__ import print_function\nimport math\ntry: raw_input\nexcept: raw_input = input\n\nlat = float(raw_input(\"Enter latitude       => \"))\nlng = float(raw_input(\"Enter longitude      => \"))\nref = float(raw_input(\"Enter legal meridian => \"))\nprint()\n\nslat = math.sin(math.radians(lat))\nprint(\"    sine of latitude:   %.3f\" % slat)\nprint(\"    diff longitude:     %.3f\" % (lng-ref))\nprint()\nprint(\"Hour, sun hour angle, dial hour line angle from 6am to 6pm\")\n\nfor h in range(-6, 7):\n  hra = 15 * h\n  hra -= lng - ref\n  hla = math.degrees(math.atan(slat * math.tan(math.radians(hra))))\n  print(\"HR=%3d; HRA=%7.3f; HLA=%7.3f\" % (h, hra, hla))\n"}
{"id": 148612, "name": "Attractive numbers", "source": "Translate Fortran to C#: program attractive_numbers\n    use iso_fortran_env, only: output_unit\n    implicit none\n\n    integer, parameter  :: maximum=120, line_break=20\n    integer             :: i, counter\n\n    write(output_unit,'(A,x,I0,x,A)') \"The attractive numbers up to and including\", maximum, \"are:\"\n\n    counter = 0\n    do i = 1, maximum\n        if (is_prime(count_prime_factors(i))) then\n            write(output_unit,'(I0,x)',advance=\"no\") i\n            counter = counter + 1\n            if (modulo(counter, line_break) == 0) write(output_unit,*)\n        end if\n    end do\n    write(output_unit,*)\ncontains\n    pure function is_prime(n)\n        integer, intent(in) :: n\n        logical             :: is_prime\n        integer             :: d\n\n        is_prime = .false.\n\n        d = 5\n        if (n < 2) return\n        if (modulo(n, 2) == 0) then\n            is_prime = n==2\n            return\n        end if\n        if (modulo(n, 3) == 0) then\n            is_prime = n==3\n            return\n        end if\n\n        do\n            if (d**2 > n) then\n                is_prime = .true.\n                return\n            end if\n            if (modulo(n, d) == 0) then\n                is_prime = .false.\n                return\n            end if\n            d = d + 2\n            if (modulo(n, d) == 0) then\n                is_prime = .false.\n                return\n            end if\n            d = d + 4\n        end do\n\n        is_prime = .true.\n    end function is_prime\n\n    pure function count_prime_factors(n)\n        integer, intent(in)     :: n\n        integer                 :: count_prime_factors\n        integer                 :: i, f\n\n        count_prime_factors = 0\n        if (n == 1) return\n        if (is_prime(n)) then\n            count_prime_factors = 1\n            return\n        end if\n        count_prime_factors = 0\n        f = 2\n        i = n\n\n        do\n            if (modulo(i, f) == 0) then\n                count_prime_factors = count_prime_factors + 1\n                i = i/f\n                if (i == 1) exit\n                if (is_prime(i)) f = i\n            else if (f >= 3) then\n                f = f + 2\n            else\n                f = 3\n            end if\n        end do\n    end function count_prime_factors\nend program attractive_numbers\n", "target": "using System;\n\nnamespace AttractiveNumbers {\n    class Program {\n        const int MAX = 120;\n\n        static bool IsPrime(int n) {\n            if (n < 2) return false;\n            if (n % 2 == 0) return n == 2;\n            if (n % 3 == 0) return n == 3;\n            int d = 5;\n            while (d * d <= n) {\n                if (n % d == 0) return false;\n                d += 2;\n                if (n % d == 0) return false;\n                d += 4;\n            }\n            return true;\n        }\n\n        static int PrimeFactorCount(int n) {\n            if (n == 1) return 0;\n            if (IsPrime(n)) return 1;\n            int count = 0;\n            int f = 2;\n            while (true) {\n                if (n % f == 0) {\n                    count++;\n                    n /= f;\n                    if (n == 1) return count;\n                    if (IsPrime(n)) f = n;\n                } else if (f >= 3) {\n                    f += 2;\n                } else {\n                    f = 3;\n                }\n            }\n        }\n\n        static void Main(string[] args) {\n            Console.WriteLine(\"The attractive numbers up to and including {0} are:\", MAX);\n            int i = 1;\n            int count = 0;\n            while (i <= MAX) {\n                int n = PrimeFactorCount(i);\n                if (IsPrime(n)) {\n                    Console.Write(\"{0,4}\", i);\n                    if (++count % 20 == 0) Console.WriteLine();\n                }\n                ++i;\n            }\n            Console.WriteLine();\n        }\n    }\n}\n"}
{"id": 148618, "name": "Attractive numbers", "source": "Translate Fortran to Java: program attractive_numbers\n    use iso_fortran_env, only: output_unit\n    implicit none\n\n    integer, parameter  :: maximum=120, line_break=20\n    integer             :: i, counter\n\n    write(output_unit,'(A,x,I0,x,A)') \"The attractive numbers up to and including\", maximum, \"are:\"\n\n    counter = 0\n    do i = 1, maximum\n        if (is_prime(count_prime_factors(i))) then\n            write(output_unit,'(I0,x)',advance=\"no\") i\n            counter = counter + 1\n            if (modulo(counter, line_break) == 0) write(output_unit,*)\n        end if\n    end do\n    write(output_unit,*)\ncontains\n    pure function is_prime(n)\n        integer, intent(in) :: n\n        logical             :: is_prime\n        integer             :: d\n\n        is_prime = .false.\n\n        d = 5\n        if (n < 2) return\n        if (modulo(n, 2) == 0) then\n            is_prime = n==2\n            return\n        end if\n        if (modulo(n, 3) == 0) then\n            is_prime = n==3\n            return\n        end if\n\n        do\n            if (d**2 > n) then\n                is_prime = .true.\n                return\n            end if\n            if (modulo(n, d) == 0) then\n                is_prime = .false.\n                return\n            end if\n            d = d + 2\n            if (modulo(n, d) == 0) then\n                is_prime = .false.\n                return\n            end if\n            d = d + 4\n        end do\n\n        is_prime = .true.\n    end function is_prime\n\n    pure function count_prime_factors(n)\n        integer, intent(in)     :: n\n        integer                 :: count_prime_factors\n        integer                 :: i, f\n\n        count_prime_factors = 0\n        if (n == 1) return\n        if (is_prime(n)) then\n            count_prime_factors = 1\n            return\n        end if\n        count_prime_factors = 0\n        f = 2\n        i = n\n\n        do\n            if (modulo(i, f) == 0) then\n                count_prime_factors = count_prime_factors + 1\n                i = i/f\n                if (i == 1) exit\n                if (is_prime(i)) f = i\n            else if (f >= 3) then\n                f = f + 2\n            else\n                f = 3\n            end if\n        end do\n    end function count_prime_factors\nend program attractive_numbers\n", "target": "public class Attractive {\n\n    static boolean is_prime(int n) {\n        if (n < 2) return false;\n        if (n % 2 == 0) return n == 2;\n        if (n % 3 == 0) return n == 3;\n        int d = 5;\n        while (d *d <= n) {\n            if (n % d == 0) return false;\n            d += 2;\n            if (n % d == 0) return false;\n            d += 4;\n        }\n        return true;\n    }\n\n    static int count_prime_factors(int n) {\n        if (n == 1) return 0;\n        if (is_prime(n)) return 1;\n        int count = 0, f = 2;\n        while (true) {\n            if (n % f == 0) {\n                count++;\n                n /= f;\n                if (n == 1) return count;\n                if (is_prime(n)) f = n;\n            }\n            else if (f >= 3) f += 2;\n            else f = 3;\n        }\n    }\n\n    public static void main(String[] args) {\n        final int max = 120;\n        System.out.printf(\"The attractive numbers up to and including %d are:\\n\", max);\n        for (int i = 1, count = 0; i <= max; ++i) {\n            int n = count_prime_factors(i);\n            if (is_prime(n)) {\n                System.out.printf(\"%4d\", i);\n                if (++count % 20 == 0) System.out.println();\n            }\n        }\n        System.out.println();\n    }\n}\n"}
{"id": 148619, "name": "Attractive numbers", "source": "Translate Fortran to Java: program attractive_numbers\n    use iso_fortran_env, only: output_unit\n    implicit none\n\n    integer, parameter  :: maximum=120, line_break=20\n    integer             :: i, counter\n\n    write(output_unit,'(A,x,I0,x,A)') \"The attractive numbers up to and including\", maximum, \"are:\"\n\n    counter = 0\n    do i = 1, maximum\n        if (is_prime(count_prime_factors(i))) then\n            write(output_unit,'(I0,x)',advance=\"no\") i\n            counter = counter + 1\n            if (modulo(counter, line_break) == 0) write(output_unit,*)\n        end if\n    end do\n    write(output_unit,*)\ncontains\n    pure function is_prime(n)\n        integer, intent(in) :: n\n        logical             :: is_prime\n        integer             :: d\n\n        is_prime = .false.\n\n        d = 5\n        if (n < 2) return\n        if (modulo(n, 2) == 0) then\n            is_prime = n==2\n            return\n        end if\n        if (modulo(n, 3) == 0) then\n            is_prime = n==3\n            return\n        end if\n\n        do\n            if (d**2 > n) then\n                is_prime = .true.\n                return\n            end if\n            if (modulo(n, d) == 0) then\n                is_prime = .false.\n                return\n            end if\n            d = d + 2\n            if (modulo(n, d) == 0) then\n                is_prime = .false.\n                return\n            end if\n            d = d + 4\n        end do\n\n        is_prime = .true.\n    end function is_prime\n\n    pure function count_prime_factors(n)\n        integer, intent(in)     :: n\n        integer                 :: count_prime_factors\n        integer                 :: i, f\n\n        count_prime_factors = 0\n        if (n == 1) return\n        if (is_prime(n)) then\n            count_prime_factors = 1\n            return\n        end if\n        count_prime_factors = 0\n        f = 2\n        i = n\n\n        do\n            if (modulo(i, f) == 0) then\n                count_prime_factors = count_prime_factors + 1\n                i = i/f\n                if (i == 1) exit\n                if (is_prime(i)) f = i\n            else if (f >= 3) then\n                f = f + 2\n            else\n                f = 3\n            end if\n        end do\n    end function count_prime_factors\nend program attractive_numbers\n", "target": "public class Attractive {\n\n    static boolean is_prime(int n) {\n        if (n < 2) return false;\n        if (n % 2 == 0) return n == 2;\n        if (n % 3 == 0) return n == 3;\n        int d = 5;\n        while (d *d <= n) {\n            if (n % d == 0) return false;\n            d += 2;\n            if (n % d == 0) return false;\n            d += 4;\n        }\n        return true;\n    }\n\n    static int count_prime_factors(int n) {\n        if (n == 1) return 0;\n        if (is_prime(n)) return 1;\n        int count = 0, f = 2;\n        while (true) {\n            if (n % f == 0) {\n                count++;\n                n /= f;\n                if (n == 1) return count;\n                if (is_prime(n)) f = n;\n            }\n            else if (f >= 3) f += 2;\n            else f = 3;\n        }\n    }\n\n    public static void main(String[] args) {\n        final int max = 120;\n        System.out.printf(\"The attractive numbers up to and including %d are:\\n\", max);\n        for (int i = 1, count = 0; i <= max; ++i) {\n            int n = count_prime_factors(i);\n            if (is_prime(n)) {\n                System.out.printf(\"%4d\", i);\n                if (++count % 20 == 0) System.out.println();\n            }\n        }\n        System.out.println();\n    }\n}\n"}
{"id": 148620, "name": "Attractive numbers", "source": "Translate Fortran to Python: program attractive_numbers\n    use iso_fortran_env, only: output_unit\n    implicit none\n\n    integer, parameter  :: maximum=120, line_break=20\n    integer             :: i, counter\n\n    write(output_unit,'(A,x,I0,x,A)') \"The attractive numbers up to and including\", maximum, \"are:\"\n\n    counter = 0\n    do i = 1, maximum\n        if (is_prime(count_prime_factors(i))) then\n            write(output_unit,'(I0,x)',advance=\"no\") i\n            counter = counter + 1\n            if (modulo(counter, line_break) == 0) write(output_unit,*)\n        end if\n    end do\n    write(output_unit,*)\ncontains\n    pure function is_prime(n)\n        integer, intent(in) :: n\n        logical             :: is_prime\n        integer             :: d\n\n        is_prime = .false.\n\n        d = 5\n        if (n < 2) return\n        if (modulo(n, 2) == 0) then\n            is_prime = n==2\n            return\n        end if\n        if (modulo(n, 3) == 0) then\n            is_prime = n==3\n            return\n        end if\n\n        do\n            if (d**2 > n) then\n                is_prime = .true.\n                return\n            end if\n            if (modulo(n, d) == 0) then\n                is_prime = .false.\n                return\n            end if\n            d = d + 2\n            if (modulo(n, d) == 0) then\n                is_prime = .false.\n                return\n            end if\n            d = d + 4\n        end do\n\n        is_prime = .true.\n    end function is_prime\n\n    pure function count_prime_factors(n)\n        integer, intent(in)     :: n\n        integer                 :: count_prime_factors\n        integer                 :: i, f\n\n        count_prime_factors = 0\n        if (n == 1) return\n        if (is_prime(n)) then\n            count_prime_factors = 1\n            return\n        end if\n        count_prime_factors = 0\n        f = 2\n        i = n\n\n        do\n            if (modulo(i, f) == 0) then\n                count_prime_factors = count_prime_factors + 1\n                i = i/f\n                if (i == 1) exit\n                if (is_prime(i)) f = i\n            else if (f >= 3) then\n                f = f + 2\n            else\n                f = 3\n            end if\n        end do\n    end function count_prime_factors\nend program attractive_numbers\n", "target": "from sympy import sieve \n\ndef get_pfct(n): \n\ti = 2; factors = []\n\twhile i * i <= n:\n\t\tif n % i:\n\t\t\ti += 1\n\t\telse:\n\t\t\tn //= i\n\t\t\tfactors.append(i)\n\tif n > 1:\n\t\tfactors.append(n)\n\treturn len(factors) \n\nsieve.extend(110) \nprimes=sieve._list\n\npool=[]\n\nfor each in xrange(0,121):\n\tpool.append(get_pfct(each))\n\nfor i,each in enumerate(pool):\n\tif each in primes:\n\t\tprint i,\n"}
{"id": 148949, "name": "Convex hull", "source": "Translate Fortran to C#: module convex_hulls\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n\n  implicit none\n  private\n\n  public :: find_convex_hull\n\ncontains\n\n  elemental function x (u)\n    complex, intent(in) :: u\n    real :: x\n\n    x = real (u)\n  end function x\n\n  elemental function y (u)\n    complex, intent(in) :: u\n    real :: y\n\n    y = aimag (u)\n  end function y\n\n  elemental function cross (u, v) result (p)\n    complex, intent(in) :: u, v\n    real :: p\n\n    \n    p = (x (u) * y (v)) - (y (u) * x (v))\n  end function cross\n\n  subroutine sort_points (num_points, points)\n    integer, intent(in) :: num_points\n    complex, intent(inout) :: points(0:*)\n\n    \n    \n    \n    \n\n    integer, parameter :: gaps(1:8) = (/ 701, 301, 132, 57, 23, 10, 4, 1 /)\n\n    integer :: i, j, k, gap, offset\n    complex :: temp\n    logical :: done\n\n    do k = 1, 8\n       gap = gaps(k)\n       do offset = 0, gap - 1\n          do i = offset, num_points - 1, gap\n             temp = points(i)\n             j = i\n             done = .false.\n             do while (.not. done)\n                if (j < gap) then\n                   done = .true.\n                else if (x (points(j - gap)) < x (temp)) then\n                   done = .true.\n                else if (x (points(j - gap)) == x (temp) .and. &\n                     &    (y (points(j - gap)) <= y (temp))) then\n                   done = .true.\n                else\n                   points(j) = points(j - gap)\n                   j = j - gap\n                end if\n             end do\n             points(j) = temp\n          end do\n       end do\n    end do\n  end subroutine sort_points\n\n  subroutine delete_neighbor_duplicates (n, pt)\n    integer, intent(inout) :: n\n    complex, intent(inout) :: pt(0:*)\n\n    call delete_trailing_duplicates\n    call delete_nontrailing_duplicates\n\n  contains\n\n    subroutine delete_trailing_duplicates\n      integer :: i\n      logical :: done\n\n      i = n - 1\n      done = .false.\n      do while (.not. done)\n         if (i == 0) then\n            n = 1\n            done = .true.\n         else if (pt(i - 1) /= pt(i)) then\n            n = i + 1\n            done = .true.\n         else\n            i = i - 1\n         end if\n      end do\n    end subroutine delete_trailing_duplicates\n\n    subroutine delete_nontrailing_duplicates\n      integer :: i, j, num_deleted\n      logical :: done\n\n      i = 0\n      do while (i < n - 1)\n         j = i + 1\n         done = .false.\n         do while (.not. done)\n            if (j == n) then\n               done = .true.\n            else if (pt(j) /= pt(i)) then\n               done = .true.\n            else\n               j = j + 1\n            end if\n         end do\n         if (j /= i + 1) then\n            num_deleted = j - i - 1\n            do while (j /= n)\n               pt(j - num_deleted) = pt(j)\n               j = j + 1\n            end do\n            n = n - num_deleted\n         end if\n         i = i + 1\n      end do\n    end subroutine delete_nontrailing_duplicates\n\n  end subroutine delete_neighbor_duplicates\n\n  subroutine construct_lower_hull (n, pt, hull_size, hull)\n    integer, intent(in) :: n    \n    complex, intent(in) :: pt(0:*)\n    integer, intent(inout) :: hull_size\n    complex, intent(inout) :: hull(0:*)\n\n    integer :: i, j\n    logical :: done\n\n    j = 1\n    hull(0:1) = pt(0:1)\n    do i = 2, n - 1\n       done = .false.\n       do while (.not. done)\n          if (j == 0) then\n             j = j + 1\n             hull(j) = pt(i)\n             done = .true.\n          else if (0.0 < cross (hull(j) - hull(j - 1), &\n               &                pt(i) - hull(j - 1))) then\n             j = j + 1\n             hull(j) = pt(i)\n             done = .true.\n          else\n             j = j - 1\n          end if\n       end do\n    end do\n    hull_size = j + 1\n  end subroutine construct_lower_hull\n\n  subroutine construct_upper_hull (n, pt, hull_size, hull)\n    integer, intent(in) :: n    \n    complex, intent(in) :: pt(0:*)\n    integer, intent(inout) :: hull_size\n    complex, intent(inout) :: hull(0:*)\n\n    integer :: i, j\n    logical :: done\n\n    j = 1\n    hull(0:1) = pt(n - 1 : n - 2 : -1)\n    do i = n - 3, 0, -1\n       done = .false.\n       do while (.not. done)\n          if (j == 0) then\n             j = j + 1\n             hull(j) = pt(i)\n             done = .true.\n          else if (0.0 < cross (hull(j) - hull(j - 1), &\n               &                pt(i) - hull(j - 1))) then\n             j = j + 1\n             hull(j) = pt(i)\n             done = .true.\n          else\n             j = j - 1\n          end if\n       end do\n    end do\n    hull_size = j + 1\n  end subroutine construct_upper_hull\n\n  subroutine contruct_hull (n, pt, hull_size, hull)\n    integer, intent(in) :: n    \n    complex, intent(in) :: pt(0:*)\n    integer, intent(inout) :: hull_size\n    complex, intent(inout) :: hull(0:*)\n\n    integer :: lower_hull_size, upper_hull_size\n    complex :: lower_hull(0 : n - 1), upper_hull(0 : n - 1)\n    integer :: ihull0\n\n    ihull0 = lbound (hull, 1)\n\n    \n    \n    call construct_lower_hull (n, pt, lower_hull_size, lower_hull)\n    call construct_upper_hull (n, pt, upper_hull_size, upper_hull)\n\n    hull_size = lower_hull_size + upper_hull_size - 2\n\n    hull(:ihull0 + lower_hull_size - 2) =                          &\n         & lower_hull(:lower_hull_size - 2)\n    hull(ihull0 + lower_hull_size - 1 : ihull0 + hull_size - 1) =  &\n         & upper_hull(0 : upper_hull_size - 2)\n  end subroutine contruct_hull\n\n  subroutine find_convex_hull (n, points, hull_size, hull)\n    integer, intent(in) :: n            \n    complex, intent(in) :: points(*)    \n    integer, intent(inout) :: hull_size \n    complex, intent(inout) :: hull(*)   \n\n    \n    \n    \n    \n    \n    \n    \n\n    complex :: pt(0 : n - 1)\n    integer :: ipoints0, ihull0, numpt\n\n    ipoints0 = lbound (points, 1)\n    ihull0 = lbound (hull, 1)\n\n    pt = points(:ipoints0 + n - 1)\n    numpt = n\n\n    call sort_points (numpt, pt)\n    call delete_neighbor_duplicates (numpt, pt)\n\n    if (numpt == 0) then\n       hull_size = 0\n    else if (numpt <= 2) then\n       hull_size = numpt\n       hull(:ihull0 + numpt - 1) = pt(:numpt - 1)\n    else\n       call contruct_hull (numpt, pt, hull_size, hull)\n    end if\n  end subroutine find_convex_hull\n\nend module convex_hulls\n\nprogram convex_hull_task\n  use, non_intrinsic :: convex_hulls\n  implicit none\n\n  complex, parameter :: example_points(20) =                   &\n       & (/ (16, 3), (12, 17), (0, 6), (-4, -6), (16, 6),      &\n       &    (16, -7), (16, -3), (17, -4), (5, 19), (19, -8),   &\n       &    (3, 16), (12, 13), (3, -4), (17, 5), (-3, 15),     &\n       &    (-3, -9), (0, 11), (-9, -3), (-4, -2), (12, 10) /)\n\n  integer :: n, i\n  complex :: points(0:100)\n  character(len = 100) :: fmt\n\n  n = 20\n  points(1:n) = example_points\n  call find_convex_hull (n, points(1:n), n, points(1:n))\n\n  write (fmt, '(\"(\", I20, ''(\"(\", F3.0, 1X, F3.0, \") \")'', \")\")') n\n  write (*, fmt) (points(i), i = 1, n)\n\nend program convex_hull_task\n", "target": "using System;\nusing System.Collections.Generic;\n\nnamespace ConvexHull {\n    class Point : IComparable<Point> {\n        private int x, y;\n\n        public Point(int x, int y) {\n            this.x = x;\n            this.y = y;\n        }\n\n        public int X { get => x; set => x = value; }\n        public int Y { get => y; set => y = value; }\n\n        public int CompareTo(Point other) {\n            return x.CompareTo(other.x);\n        }\n\n        public override string ToString() {\n            return string.Format(\"({0}, {1})\", x, y);\n        }\n    }\n\n    class Program {\n        private static List<Point> ConvexHull(List<Point> p) {\n            if (p.Count == 0) return new List<Point>();\n            p.Sort();\n            List<Point> h = new List<Point>();\n\n            \n            foreach (var pt in p) {\n                while (h.Count >= 2 && !Ccw(h[h.Count - 2], h[h.Count - 1], pt)) {\n                    h.RemoveAt(h.Count - 1);\n                }\n                h.Add(pt);\n            }\n\n            \n            int t = h.Count + 1;\n            for (int i = p.Count - 1; i >= 0; i--) {\n                Point pt = p[i];\n                while (h.Count >= t && !Ccw(h[h.Count - 2], h[h.Count - 1], pt)) {\n                    h.RemoveAt(h.Count - 1);\n                }\n                h.Add(pt);\n            }\n\n            h.RemoveAt(h.Count - 1);\n            return h;\n        }\n\n        private static bool Ccw(Point a, Point b, Point c) {\n            return ((b.X - a.X) * (c.Y - a.Y)) > ((b.Y - a.Y) * (c.X - a.X));\n        }\n\n        static void Main(string[] args) {\n            List<Point> points = new List<Point>() {\n                new Point(16, 3),\n                new Point(12, 17),\n                new Point(0, 6),\n                new Point(-4, -6),\n                new Point(16, 6),\n\n                new Point(16, -7),\n                new Point(16, -3),\n                new Point(17, -4),\n                new Point(5, 19),\n                new Point(19, -8),\n\n                new Point(3, 16),\n                new Point(12, 13),\n                new Point(3, -4),\n                new Point(17, 5),\n                new Point(-3, 15),\n\n                new Point(-3, -9),\n                new Point(0, 11),\n                new Point(-9, -3),\n                new Point(-4, -2),\n                new Point(12, 10)\n            };\n\n            List<Point> hull = ConvexHull(points);\n            Console.Write(\"Convex Hull: [\");\n            for (int i = 0; i < hull.Count; i++) {\n                if (i > 0) {\n                    Console.Write(\", \");\n                }\n                Point pt = hull[i];\n                Console.Write(pt);\n            }\n            Console.WriteLine(\"]\");\n        }\n    }\n}\n"}
{"id": 148952, "name": "Convex hull", "source": "Translate Fortran to Java: module convex_hulls\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n\n  implicit none\n  private\n\n  public :: find_convex_hull\n\ncontains\n\n  elemental function x (u)\n    complex, intent(in) :: u\n    real :: x\n\n    x = real (u)\n  end function x\n\n  elemental function y (u)\n    complex, intent(in) :: u\n    real :: y\n\n    y = aimag (u)\n  end function y\n\n  elemental function cross (u, v) result (p)\n    complex, intent(in) :: u, v\n    real :: p\n\n    \n    p = (x (u) * y (v)) - (y (u) * x (v))\n  end function cross\n\n  subroutine sort_points (num_points, points)\n    integer, intent(in) :: num_points\n    complex, intent(inout) :: points(0:*)\n\n    \n    \n    \n    \n\n    integer, parameter :: gaps(1:8) = (/ 701, 301, 132, 57, 23, 10, 4, 1 /)\n\n    integer :: i, j, k, gap, offset\n    complex :: temp\n    logical :: done\n\n    do k = 1, 8\n       gap = gaps(k)\n       do offset = 0, gap - 1\n          do i = offset, num_points - 1, gap\n             temp = points(i)\n             j = i\n             done = .false.\n             do while (.not. done)\n                if (j < gap) then\n                   done = .true.\n                else if (x (points(j - gap)) < x (temp)) then\n                   done = .true.\n                else if (x (points(j - gap)) == x (temp) .and. &\n                     &    (y (points(j - gap)) <= y (temp))) then\n                   done = .true.\n                else\n                   points(j) = points(j - gap)\n                   j = j - gap\n                end if\n             end do\n             points(j) = temp\n          end do\n       end do\n    end do\n  end subroutine sort_points\n\n  subroutine delete_neighbor_duplicates (n, pt)\n    integer, intent(inout) :: n\n    complex, intent(inout) :: pt(0:*)\n\n    call delete_trailing_duplicates\n    call delete_nontrailing_duplicates\n\n  contains\n\n    subroutine delete_trailing_duplicates\n      integer :: i\n      logical :: done\n\n      i = n - 1\n      done = .false.\n      do while (.not. done)\n         if (i == 0) then\n            n = 1\n            done = .true.\n         else if (pt(i - 1) /= pt(i)) then\n            n = i + 1\n            done = .true.\n         else\n            i = i - 1\n         end if\n      end do\n    end subroutine delete_trailing_duplicates\n\n    subroutine delete_nontrailing_duplicates\n      integer :: i, j, num_deleted\n      logical :: done\n\n      i = 0\n      do while (i < n - 1)\n         j = i + 1\n         done = .false.\n         do while (.not. done)\n            if (j == n) then\n               done = .true.\n            else if (pt(j) /= pt(i)) then\n               done = .true.\n            else\n               j = j + 1\n            end if\n         end do\n         if (j /= i + 1) then\n            num_deleted = j - i - 1\n            do while (j /= n)\n               pt(j - num_deleted) = pt(j)\n               j = j + 1\n            end do\n            n = n - num_deleted\n         end if\n         i = i + 1\n      end do\n    end subroutine delete_nontrailing_duplicates\n\n  end subroutine delete_neighbor_duplicates\n\n  subroutine construct_lower_hull (n, pt, hull_size, hull)\n    integer, intent(in) :: n    \n    complex, intent(in) :: pt(0:*)\n    integer, intent(inout) :: hull_size\n    complex, intent(inout) :: hull(0:*)\n\n    integer :: i, j\n    logical :: done\n\n    j = 1\n    hull(0:1) = pt(0:1)\n    do i = 2, n - 1\n       done = .false.\n       do while (.not. done)\n          if (j == 0) then\n             j = j + 1\n             hull(j) = pt(i)\n             done = .true.\n          else if (0.0 < cross (hull(j) - hull(j - 1), &\n               &                pt(i) - hull(j - 1))) then\n             j = j + 1\n             hull(j) = pt(i)\n             done = .true.\n          else\n             j = j - 1\n          end if\n       end do\n    end do\n    hull_size = j + 1\n  end subroutine construct_lower_hull\n\n  subroutine construct_upper_hull (n, pt, hull_size, hull)\n    integer, intent(in) :: n    \n    complex, intent(in) :: pt(0:*)\n    integer, intent(inout) :: hull_size\n    complex, intent(inout) :: hull(0:*)\n\n    integer :: i, j\n    logical :: done\n\n    j = 1\n    hull(0:1) = pt(n - 1 : n - 2 : -1)\n    do i = n - 3, 0, -1\n       done = .false.\n       do while (.not. done)\n          if (j == 0) then\n             j = j + 1\n             hull(j) = pt(i)\n             done = .true.\n          else if (0.0 < cross (hull(j) - hull(j - 1), &\n               &                pt(i) - hull(j - 1))) then\n             j = j + 1\n             hull(j) = pt(i)\n             done = .true.\n          else\n             j = j - 1\n          end if\n       end do\n    end do\n    hull_size = j + 1\n  end subroutine construct_upper_hull\n\n  subroutine contruct_hull (n, pt, hull_size, hull)\n    integer, intent(in) :: n    \n    complex, intent(in) :: pt(0:*)\n    integer, intent(inout) :: hull_size\n    complex, intent(inout) :: hull(0:*)\n\n    integer :: lower_hull_size, upper_hull_size\n    complex :: lower_hull(0 : n - 1), upper_hull(0 : n - 1)\n    integer :: ihull0\n\n    ihull0 = lbound (hull, 1)\n\n    \n    \n    call construct_lower_hull (n, pt, lower_hull_size, lower_hull)\n    call construct_upper_hull (n, pt, upper_hull_size, upper_hull)\n\n    hull_size = lower_hull_size + upper_hull_size - 2\n\n    hull(:ihull0 + lower_hull_size - 2) =                          &\n         & lower_hull(:lower_hull_size - 2)\n    hull(ihull0 + lower_hull_size - 1 : ihull0 + hull_size - 1) =  &\n         & upper_hull(0 : upper_hull_size - 2)\n  end subroutine contruct_hull\n\n  subroutine find_convex_hull (n, points, hull_size, hull)\n    integer, intent(in) :: n            \n    complex, intent(in) :: points(*)    \n    integer, intent(inout) :: hull_size \n    complex, intent(inout) :: hull(*)   \n\n    \n    \n    \n    \n    \n    \n    \n\n    complex :: pt(0 : n - 1)\n    integer :: ipoints0, ihull0, numpt\n\n    ipoints0 = lbound (points, 1)\n    ihull0 = lbound (hull, 1)\n\n    pt = points(:ipoints0 + n - 1)\n    numpt = n\n\n    call sort_points (numpt, pt)\n    call delete_neighbor_duplicates (numpt, pt)\n\n    if (numpt == 0) then\n       hull_size = 0\n    else if (numpt <= 2) then\n       hull_size = numpt\n       hull(:ihull0 + numpt - 1) = pt(:numpt - 1)\n    else\n       call contruct_hull (numpt, pt, hull_size, hull)\n    end if\n  end subroutine find_convex_hull\n\nend module convex_hulls\n\nprogram convex_hull_task\n  use, non_intrinsic :: convex_hulls\n  implicit none\n\n  complex, parameter :: example_points(20) =                   &\n       & (/ (16, 3), (12, 17), (0, 6), (-4, -6), (16, 6),      &\n       &    (16, -7), (16, -3), (17, -4), (5, 19), (19, -8),   &\n       &    (3, 16), (12, 13), (3, -4), (17, 5), (-3, 15),     &\n       &    (-3, -9), (0, 11), (-9, -3), (-4, -2), (12, 10) /)\n\n  integer :: n, i\n  complex :: points(0:100)\n  character(len = 100) :: fmt\n\n  n = 20\n  points(1:n) = example_points\n  call find_convex_hull (n, points(1:n), n, points(1:n))\n\n  write (fmt, '(\"(\", I20, ''(\"(\", F3.0, 1X, F3.0, \") \")'', \")\")') n\n  write (*, fmt) (points(i), i = 1, n)\n\nend program convex_hull_task\n", "target": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.stream.Collectors;\n\nimport static java.util.Collections.emptyList;\n\npublic class ConvexHull {\n    private static class Point implements Comparable<Point> {\n        private int x, y;\n\n        public Point(int x, int y) {\n            this.x = x;\n            this.y = y;\n        }\n\n        @Override\n        public int compareTo(Point o) {\n            return Integer.compare(x, o.x);\n        }\n\n        @Override\n        public String toString() {\n            return String.format(\"(%d, %d)\", x, y);\n        }\n    }\n\n    private static List<Point> convexHull(List<Point> p) {\n        if (p.isEmpty()) return emptyList();\n        p.sort(Point::compareTo);\n        List<Point> h = new ArrayList<>();\n\n        \n        for (Point pt : p) {\n            while (h.size() >= 2 && !ccw(h.get(h.size() - 2), h.get(h.size() - 1), pt)) {\n                h.remove(h.size() - 1);\n            }\n            h.add(pt);\n        }\n\n        \n        int t = h.size() + 1;\n        for (int i = p.size() - 1; i >= 0; i--) {\n            Point pt = p.get(i);\n            while (h.size() >= t && !ccw(h.get(h.size() - 2), h.get(h.size() - 1), pt)) {\n                h.remove(h.size() - 1);\n            }\n            h.add(pt);\n        }\n\n        h.remove(h.size() - 1);\n        return h;\n    }\n\n    \n    private static boolean ccw(Point a, Point b, Point c) {\n        return ((b.x - a.x) * (c.y - a.y)) > ((b.y - a.y) * (c.x - a.x));\n    }\n\n    public static void main(String[] args) {\n        List<Point> points = Arrays.asList(new Point(16, 3),\n                                           new Point(12, 17),\n                                           new Point(0, 6),\n                                           new Point(-4, -6),\n                                           new Point(16, 6),\n\n                                           new Point(16, -7),\n                                           new Point(16, -3),\n                                           new Point(17, -4),\n                                           new Point(5, 19),\n                                           new Point(19, -8),\n\n                                           new Point(3, 16),\n                                           new Point(12, 13),\n                                           new Point(3, -4),\n                                           new Point(17, 5),\n                                           new Point(-3, 15),\n\n                                           new Point(-3, -9),\n                                           new Point(0, 11),\n                                           new Point(-9, -3),\n                                           new Point(-4, -2),\n                                           new Point(12, 10));\n\n        List<Point> hull = convexHull(points);\n        System.out.printf(\"Convex Hull: %s\\n\", hull);\n    }\n}\n"}
{"id": 148953, "name": "Convex hull", "source": "Translate Fortran to Python: module convex_hulls\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n\n  implicit none\n  private\n\n  public :: find_convex_hull\n\ncontains\n\n  elemental function x (u)\n    complex, intent(in) :: u\n    real :: x\n\n    x = real (u)\n  end function x\n\n  elemental function y (u)\n    complex, intent(in) :: u\n    real :: y\n\n    y = aimag (u)\n  end function y\n\n  elemental function cross (u, v) result (p)\n    complex, intent(in) :: u, v\n    real :: p\n\n    \n    p = (x (u) * y (v)) - (y (u) * x (v))\n  end function cross\n\n  subroutine sort_points (num_points, points)\n    integer, intent(in) :: num_points\n    complex, intent(inout) :: points(0:*)\n\n    \n    \n    \n    \n\n    integer, parameter :: gaps(1:8) = (/ 701, 301, 132, 57, 23, 10, 4, 1 /)\n\n    integer :: i, j, k, gap, offset\n    complex :: temp\n    logical :: done\n\n    do k = 1, 8\n       gap = gaps(k)\n       do offset = 0, gap - 1\n          do i = offset, num_points - 1, gap\n             temp = points(i)\n             j = i\n             done = .false.\n             do while (.not. done)\n                if (j < gap) then\n                   done = .true.\n                else if (x (points(j - gap)) < x (temp)) then\n                   done = .true.\n                else if (x (points(j - gap)) == x (temp) .and. &\n                     &    (y (points(j - gap)) <= y (temp))) then\n                   done = .true.\n                else\n                   points(j) = points(j - gap)\n                   j = j - gap\n                end if\n             end do\n             points(j) = temp\n          end do\n       end do\n    end do\n  end subroutine sort_points\n\n  subroutine delete_neighbor_duplicates (n, pt)\n    integer, intent(inout) :: n\n    complex, intent(inout) :: pt(0:*)\n\n    call delete_trailing_duplicates\n    call delete_nontrailing_duplicates\n\n  contains\n\n    subroutine delete_trailing_duplicates\n      integer :: i\n      logical :: done\n\n      i = n - 1\n      done = .false.\n      do while (.not. done)\n         if (i == 0) then\n            n = 1\n            done = .true.\n         else if (pt(i - 1) /= pt(i)) then\n            n = i + 1\n            done = .true.\n         else\n            i = i - 1\n         end if\n      end do\n    end subroutine delete_trailing_duplicates\n\n    subroutine delete_nontrailing_duplicates\n      integer :: i, j, num_deleted\n      logical :: done\n\n      i = 0\n      do while (i < n - 1)\n         j = i + 1\n         done = .false.\n         do while (.not. done)\n            if (j == n) then\n               done = .true.\n            else if (pt(j) /= pt(i)) then\n               done = .true.\n            else\n               j = j + 1\n            end if\n         end do\n         if (j /= i + 1) then\n            num_deleted = j - i - 1\n            do while (j /= n)\n               pt(j - num_deleted) = pt(j)\n               j = j + 1\n            end do\n            n = n - num_deleted\n         end if\n         i = i + 1\n      end do\n    end subroutine delete_nontrailing_duplicates\n\n  end subroutine delete_neighbor_duplicates\n\n  subroutine construct_lower_hull (n, pt, hull_size, hull)\n    integer, intent(in) :: n    \n    complex, intent(in) :: pt(0:*)\n    integer, intent(inout) :: hull_size\n    complex, intent(inout) :: hull(0:*)\n\n    integer :: i, j\n    logical :: done\n\n    j = 1\n    hull(0:1) = pt(0:1)\n    do i = 2, n - 1\n       done = .false.\n       do while (.not. done)\n          if (j == 0) then\n             j = j + 1\n             hull(j) = pt(i)\n             done = .true.\n          else if (0.0 < cross (hull(j) - hull(j - 1), &\n               &                pt(i) - hull(j - 1))) then\n             j = j + 1\n             hull(j) = pt(i)\n             done = .true.\n          else\n             j = j - 1\n          end if\n       end do\n    end do\n    hull_size = j + 1\n  end subroutine construct_lower_hull\n\n  subroutine construct_upper_hull (n, pt, hull_size, hull)\n    integer, intent(in) :: n    \n    complex, intent(in) :: pt(0:*)\n    integer, intent(inout) :: hull_size\n    complex, intent(inout) :: hull(0:*)\n\n    integer :: i, j\n    logical :: done\n\n    j = 1\n    hull(0:1) = pt(n - 1 : n - 2 : -1)\n    do i = n - 3, 0, -1\n       done = .false.\n       do while (.not. done)\n          if (j == 0) then\n             j = j + 1\n             hull(j) = pt(i)\n             done = .true.\n          else if (0.0 < cross (hull(j) - hull(j - 1), &\n               &                pt(i) - hull(j - 1))) then\n             j = j + 1\n             hull(j) = pt(i)\n             done = .true.\n          else\n             j = j - 1\n          end if\n       end do\n    end do\n    hull_size = j + 1\n  end subroutine construct_upper_hull\n\n  subroutine contruct_hull (n, pt, hull_size, hull)\n    integer, intent(in) :: n    \n    complex, intent(in) :: pt(0:*)\n    integer, intent(inout) :: hull_size\n    complex, intent(inout) :: hull(0:*)\n\n    integer :: lower_hull_size, upper_hull_size\n    complex :: lower_hull(0 : n - 1), upper_hull(0 : n - 1)\n    integer :: ihull0\n\n    ihull0 = lbound (hull, 1)\n\n    \n    \n    call construct_lower_hull (n, pt, lower_hull_size, lower_hull)\n    call construct_upper_hull (n, pt, upper_hull_size, upper_hull)\n\n    hull_size = lower_hull_size + upper_hull_size - 2\n\n    hull(:ihull0 + lower_hull_size - 2) =                          &\n         & lower_hull(:lower_hull_size - 2)\n    hull(ihull0 + lower_hull_size - 1 : ihull0 + hull_size - 1) =  &\n         & upper_hull(0 : upper_hull_size - 2)\n  end subroutine contruct_hull\n\n  subroutine find_convex_hull (n, points, hull_size, hull)\n    integer, intent(in) :: n            \n    complex, intent(in) :: points(*)    \n    integer, intent(inout) :: hull_size \n    complex, intent(inout) :: hull(*)   \n\n    \n    \n    \n    \n    \n    \n    \n\n    complex :: pt(0 : n - 1)\n    integer :: ipoints0, ihull0, numpt\n\n    ipoints0 = lbound (points, 1)\n    ihull0 = lbound (hull, 1)\n\n    pt = points(:ipoints0 + n - 1)\n    numpt = n\n\n    call sort_points (numpt, pt)\n    call delete_neighbor_duplicates (numpt, pt)\n\n    if (numpt == 0) then\n       hull_size = 0\n    else if (numpt <= 2) then\n       hull_size = numpt\n       hull(:ihull0 + numpt - 1) = pt(:numpt - 1)\n    else\n       call contruct_hull (numpt, pt, hull_size, hull)\n    end if\n  end subroutine find_convex_hull\n\nend module convex_hulls\n\nprogram convex_hull_task\n  use, non_intrinsic :: convex_hulls\n  implicit none\n\n  complex, parameter :: example_points(20) =                   &\n       & (/ (16, 3), (12, 17), (0, 6), (-4, -6), (16, 6),      &\n       &    (16, -7), (16, -3), (17, -4), (5, 19), (19, -8),   &\n       &    (3, 16), (12, 13), (3, -4), (17, 5), (-3, 15),     &\n       &    (-3, -9), (0, 11), (-9, -3), (-4, -2), (12, 10) /)\n\n  integer :: n, i\n  complex :: points(0:100)\n  character(len = 100) :: fmt\n\n  n = 20\n  points(1:n) = example_points\n  call find_convex_hull (n, points(1:n), n, points(1:n))\n\n  write (fmt, '(\"(\", I20, ''(\"(\", F3.0, 1X, F3.0, \") \")'', \")\")') n\n  write (*, fmt) (points(i), i = 1, n)\n\nend program convex_hull_task\n", "target": "from __future__ import print_function\nfrom shapely.geometry import MultiPoint\n\nif __name__==\"__main__\":\n\tpts = MultiPoint([(16,3), (12,17), (0,6), (-4,-6), (16,6), (16,-7), (16,-3), (17,-4), (5,19), (19,-8), (3,16), (12,13), (3,-4), (17,5), (-3,15), (-3,-9), (0,11), (-9,-3), (-4,-2), (12,10)])\n\tprint (pts.convex_hull)\n"}
{"id": 149157, "name": "Trigonometric functions", "source": "Translate Fortran to C#: PROGRAM Trig\n\n  REAL pi, dtor, rtod, radians, degrees\n \n  pi = 4.0 * ATAN(1.0)\n  dtor = pi / 180.0\n  rtod = 180.0 / pi\n  radians = pi / 4.0\n  degrees = 45.0 \n \n  WRITE(*,*) SIN(radians), SIN(degrees*dtor)\n  WRITE(*,*) COS(radians), COS(degrees*dtor)\n  WRITE(*,*) TAN(radians), TAN(degrees*dtor)\n  WRITE(*,*) ASIN(SIN(radians)), ASIN(SIN(degrees*dtor))*rtod\n  WRITE(*,*) ACOS(COS(radians)), ACOS(COS(degrees*dtor))*rtod\n  WRITE(*,*) ATAN(TAN(radians)), ATAN(TAN(degrees*dtor))*rtod\n\nEND PROGRAM Trig\n", "target": "using System;\n\nnamespace RosettaCode {\n    class Program {\n        static void Main(string[] args) {\n            Console.WriteLine(\"=== radians ===\");\n            Console.WriteLine(\"sin (pi/3) = {0}\", Math.Sin(Math.PI / 3));\n            Console.WriteLine(\"cos (pi/3) = {0}\", Math.Cos(Math.PI / 3));\n            Console.WriteLine(\"tan (pi/3) = {0}\", Math.Tan(Math.PI / 3));\n            Console.WriteLine(\"arcsin (1/2) = {0}\", Math.Asin(0.5));\n            Console.WriteLine(\"arccos (1/2) = {0}\", Math.Acos(0.5));\n            Console.WriteLine(\"arctan (1/2) = {0}\", Math.Atan(0.5));\n            Console.WriteLine(\"\");\n            Console.WriteLine(\"=== degrees ===\");\n            Console.WriteLine(\"sin (60) = {0}\", Math.Sin(60 * Math.PI / 180));\n            Console.WriteLine(\"cos (60) = {0}\", Math.Cos(60 * Math.PI / 180));\n            Console.WriteLine(\"tan (60) = {0}\", Math.Tan(60 * Math.PI / 180));\n            Console.WriteLine(\"arcsin (1/2) = {0}\", Math.Asin(0.5) * 180/ Math.PI);\n            Console.WriteLine(\"arccos (1/2) = {0}\", Math.Acos(0.5) * 180 / Math.PI);\n            Console.WriteLine(\"arctan (1/2) = {0}\", Math.Atan(0.5) * 180 / Math.PI);\n\n            Console.ReadLine();\n        }\n    }\n}\n"}
{"id": 149161, "name": "Trigonometric functions", "source": "Translate Fortran to Java: PROGRAM Trig\n\n  REAL pi, dtor, rtod, radians, degrees\n \n  pi = 4.0 * ATAN(1.0)\n  dtor = pi / 180.0\n  rtod = 180.0 / pi\n  radians = pi / 4.0\n  degrees = 45.0 \n \n  WRITE(*,*) SIN(radians), SIN(degrees*dtor)\n  WRITE(*,*) COS(radians), COS(degrees*dtor)\n  WRITE(*,*) TAN(radians), TAN(degrees*dtor)\n  WRITE(*,*) ASIN(SIN(radians)), ASIN(SIN(degrees*dtor))*rtod\n  WRITE(*,*) ACOS(COS(radians)), ACOS(COS(degrees*dtor))*rtod\n  WRITE(*,*) ATAN(TAN(radians)), ATAN(TAN(degrees*dtor))*rtod\n\nEND PROGRAM Trig\n", "target": "public class Trig {\n        public static void main(String[] args) {\n                \n                double radians = Math.PI / 4;\n                double degrees = 45.0;\n                \n                System.out.println(Math.sin(radians) + \" \" + Math.sin(Math.toRadians(degrees)));\n                \n                System.out.println(Math.cos(radians) + \" \" + Math.cos(Math.toRadians(degrees)));\n                \n                System.out.println(Math.tan(radians) + \" \" + Math.tan(Math.toRadians(degrees)));\n                \n                double arcsin = Math.asin(Math.sin(radians));\n                System.out.println(arcsin + \" \" + Math.toDegrees(arcsin));\n                \n                double arccos = Math.acos(Math.cos(radians));\n                System.out.println(arccos + \" \" + Math.toDegrees(arccos));\n                \n                double arctan = Math.atan(Math.tan(radians));\n                System.out.println(arctan + \" \" + Math.toDegrees(arctan));\n        }\n}\n"}
{"id": 149162, "name": "Trigonometric functions", "source": "Translate Fortran to Python: PROGRAM Trig\n\n  REAL pi, dtor, rtod, radians, degrees\n \n  pi = 4.0 * ATAN(1.0)\n  dtor = pi / 180.0\n  rtod = 180.0 / pi\n  radians = pi / 4.0\n  degrees = 45.0 \n \n  WRITE(*,*) SIN(radians), SIN(degrees*dtor)\n  WRITE(*,*) COS(radians), COS(degrees*dtor)\n  WRITE(*,*) TAN(radians), TAN(degrees*dtor)\n  WRITE(*,*) ASIN(SIN(radians)), ASIN(SIN(degrees*dtor))*rtod\n  WRITE(*,*) ACOS(COS(radians)), ACOS(COS(degrees*dtor))*rtod\n  WRITE(*,*) ATAN(TAN(radians)), ATAN(TAN(degrees*dtor))*rtod\n\nEND PROGRAM Trig\n", "target": "Python 3.2.2 (default, Sep  4 2011, 09:51:08) [MSC v.1500 32 bit (Intel)] on win32\nType \"copyright\", \"credits\" or \"license()\" for more information.\n>>> from math import degrees, radians, sin, cos, tan, asin, acos, atan, pi\n>>> rad, deg = pi/4, 45.0\n>>> print(\"Sine:\", sin(rad), sin(radians(deg)))\nSine: 0.7071067811865475 0.7071067811865475\n>>> print(\"Cosine:\", cos(rad), cos(radians(deg)))\nCosine: 0.7071067811865476 0.7071067811865476\n>>> print(\"Tangent:\", tan(rad), tan(radians(deg)))\nTangent: 0.9999999999999999 0.9999999999999999\n>>> arcsine = asin(sin(rad))\n>>> print(\"Arcsine:\", arcsine, degrees(arcsine))\nArcsine: 0.7853981633974482 44.99999999999999\n>>> arccosine = acos(cos(rad))\n>>> print(\"Arccosine:\", arccosine, degrees(arccosine))\nArccosine: 0.7853981633974483 45.0\n>>> arctangent = atan(tan(rad))\n>>> print(\"Arctangent:\", arctangent, degrees(arctangent))\nArctangent: 0.7853981633974483 45.0\n>>>\n"}
{"id": 149435, "name": "Loops_For", "source": "Translate Fortran to C#: C     WARNING: This program is not valid ANSI FORTRAN 77 code. It uses\nC     one nonstandard character on the line labelled 5001. Many F77\nC     compilers should be okay with it, but it is *not* standard.\n      PROGRAM FORLOOP\n        INTEGER I, J\n\n        DO 20 I = 1, 5\n          DO 10 J = 1, I\nC           Print the asterisk.\n            WRITE (*,5001) '*'\n   10     CONTINUE\nC         Print a newline.\n          WRITE (*,5000) ''\n   20   CONTINUE\n\n        STOP\n\n 5000   FORMAT (A)\nC       Standard FORTRAN 77 is completely incapable of completing a\nC       WRITE statement without printing a newline. If you wanted to\nC       write this program in valid F77, you would have to come up with\nC       a creative way of printing varying numbers of asterisks in a\nC       single write statement.\nC\nC       The dollar sign at the end of the format is a nonstandard\nC       character. It tells the compiler not to print a newline. If you\nC       are actually using FORTRAN 77, you should figure out what your\nC       particular compiler accepts. If you are actually using Fortran\nC       90 or later, you should replace this line with the commented\nC       line that follows it.\n 5001   FORMAT (A, $)\nC5001   FORMAT (A, ADVANCE='NO')\n      END\n", "target": "using System;\n\nclass Program {\n    static void Main(string[] args)\n    {\n        for (int i = 0; i < 5; i++)\n        {\n            for (int j = 0; j <= i; j++)\n            {\n                Console.Write(\"*\");\n            }\n            Console.WriteLine();\n        }\n    }\n}\n"}
{"id": 149439, "name": "Loops_For", "source": "Translate Fortran to Java: C     WARNING: This program is not valid ANSI FORTRAN 77 code. It uses\nC     one nonstandard character on the line labelled 5001. Many F77\nC     compilers should be okay with it, but it is *not* standard.\n      PROGRAM FORLOOP\n        INTEGER I, J\n\n        DO 20 I = 1, 5\n          DO 10 J = 1, I\nC           Print the asterisk.\n            WRITE (*,5001) '*'\n   10     CONTINUE\nC         Print a newline.\n          WRITE (*,5000) ''\n   20   CONTINUE\n\n        STOP\n\n 5000   FORMAT (A)\nC       Standard FORTRAN 77 is completely incapable of completing a\nC       WRITE statement without printing a newline. If you wanted to\nC       write this program in valid F77, you would have to come up with\nC       a creative way of printing varying numbers of asterisks in a\nC       single write statement.\nC\nC       The dollar sign at the end of the format is a nonstandard\nC       character. It tells the compiler not to print a newline. If you\nC       are actually using FORTRAN 77, you should figure out what your\nC       particular compiler accepts. If you are actually using Fortran\nC       90 or later, you should replace this line with the commented\nC       line that follows it.\n 5001   FORMAT (A, $)\nC5001   FORMAT (A, ADVANCE='NO')\n      END\n", "target": "for (Integer i = 0; i < 5; i++) {\n    String line = '';\n\n    for (Integer j = 0; j < i; j++) {\n        line += '*';\n    }\n\n    System.debug(line);\n}\n\nList<String> lines = new List<String> {\n    '*',\n    '**',\n    '***',\n    '****',\n    '*****'\n};\n\nfor (String line : lines) {\n    System.debug(line);\n}\n"}
{"id": 149440, "name": "Loops_For", "source": "Translate Fortran to Python: C     WARNING: This program is not valid ANSI FORTRAN 77 code. It uses\nC     one nonstandard character on the line labelled 5001. Many F77\nC     compilers should be okay with it, but it is *not* standard.\n      PROGRAM FORLOOP\n        INTEGER I, J\n\n        DO 20 I = 1, 5\n          DO 10 J = 1, I\nC           Print the asterisk.\n            WRITE (*,5001) '*'\n   10     CONTINUE\nC         Print a newline.\n          WRITE (*,5000) ''\n   20   CONTINUE\n\n        STOP\n\n 5000   FORMAT (A)\nC       Standard FORTRAN 77 is completely incapable of completing a\nC       WRITE statement without printing a newline. If you wanted to\nC       write this program in valid F77, you would have to come up with\nC       a creative way of printing varying numbers of asterisks in a\nC       single write statement.\nC\nC       The dollar sign at the end of the format is a nonstandard\nC       character. It tells the compiler not to print a newline. If you\nC       are actually using FORTRAN 77, you should figure out what your\nC       particular compiler accepts. If you are actually using Fortran\nC       90 or later, you should replace this line with the commented\nC       line that follows it.\n 5001   FORMAT (A, $)\nC5001   FORMAT (A, ADVANCE='NO')\n      END\n", "target": "for i in 1..5:\n  for j in 1..i:\n    stdout.write(\"*\")\n  echo(\"\")\n"}
{"id": 149694, "name": "Loops_Downward for", "source": "Translate Fortran to C#: DO i = 10, 0, -1\n  WRITE(*, *) i\nEND DO\n", "target": "for (int i = 10; i >= 0; i--)\n{\n   Console.WriteLine(i);\n}\n"}
{"id": 149697, "name": "Loops_Downward for", "source": "Translate Fortran to Java: DO i = 10, 0, -1\n  WRITE(*, *) i\nEND DO\n", "target": "for (int i = 10; i >= 0; i--) {\n    System.out.println(i);\n}\n"}
{"id": 149698, "name": "Loops_Downward for", "source": "Translate Fortran to Python: DO i = 10, 0, -1\n  WRITE(*, *) i\nEND DO\n", "target": "for i in xrange(10, -1, -1):\n    print i\n"}
{"id": 149950, "name": "Entropy", "source": "Translate Fortran to C#: \n\n\n\n\n\n\n\n\nprogram shannonEntropy\n  implicit none\n  integer :: num, L, status\n  character(len=2048) :: s\n  num = 1\n  call get_command_argument(num, s, L, status)\n  if ((0 /= status) .or. (L .eq. 0)) then\n    write(0,*)'Expected a command line argument with some length.'\n  else\n    write(6,*)'Shannon entropy of '//(s(1:L))//' is ', se(s(1:L))\n  endif\n\ncontains\n  \n  \n  \n  \n  \n\n  \n  \n  \n  \n  \n  real function se(s)\n    implicit none\n    character(len=*), intent(in) :: s\n    integer, dimension(256) :: tallies\n    real, dimension(256) :: norm\n    tallies = 0\n    call TallyKey(s, tallies)\n    \n    \n    norm = tallies / real(len(s))\n    se = sum(-(norm*log(merge(1.0, norm, norm .eq. 0))/log(2.0)))\n  end function se\n\n  subroutine TallyKey(s, counts)\n    character(len=*), intent(in) :: s\n    integer, dimension(256), intent(out) :: counts\n    integer :: i, j\n    counts = 0\n    do i=1,len(s)\n      j = iachar(s(i:i))\n      counts(j) = counts(j) + 1\n    end do\n  end subroutine TallyKey\n\nend program shannonEntropy\n", "target": "using System;\nusing System.Collections.Generic;\nnamespace Entropy\n{\n\tclass Program\n\t{\n\t\tpublic static double logtwo(double num)\n\t\t{\n\t\t\treturn Math.Log(num)/Math.Log(2);\n\t\t}\n\t\tpublic static void Main(string[] args)\n\t\t{\n\t\tlabel1:\n\t\t\tstring input = Console.ReadLine();\n\t\t\tdouble infoC=0;\n\t\t\tDictionary<char,double> table = new Dictionary<char, double>();\n\n\t\t\t\n\t\t\tforeach (char c in input)\n\t\t\t{\n\t\t\t\tif (table.ContainsKey(c))\n\t\t\t\t\ttable[c]++;\n\t\t\t\t    else\n\t\t\t\t    \ttable.Add(c,1);\n\t\n\t\t\t}\n\t\t\tdouble freq;\n\t\t\tforeach (KeyValuePair<char,double> letter in table)\n\t\t\t{\n\t\t\t\tfreq=letter.Value/input.Length;\n\t\t\t\tinfoC+=freq*logtwo(freq);\n\t\t\t}\n\t\t\tinfoC*=-1;\n\t\t\tConsole.WriteLine(\"The Entropy of {0} is {1}\",input,infoC);\n\t\t\tgoto label1;\n\t\t\n\t\t}\n\t}\n}\n"}
{"id": 149953, "name": "Entropy", "source": "Translate Fortran to Java: \n\n\n\n\n\n\n\n\nprogram shannonEntropy\n  implicit none\n  integer :: num, L, status\n  character(len=2048) :: s\n  num = 1\n  call get_command_argument(num, s, L, status)\n  if ((0 /= status) .or. (L .eq. 0)) then\n    write(0,*)'Expected a command line argument with some length.'\n  else\n    write(6,*)'Shannon entropy of '//(s(1:L))//' is ', se(s(1:L))\n  endif\n\ncontains\n  \n  \n  \n  \n  \n\n  \n  \n  \n  \n  \n  real function se(s)\n    implicit none\n    character(len=*), intent(in) :: s\n    integer, dimension(256) :: tallies\n    real, dimension(256) :: norm\n    tallies = 0\n    call TallyKey(s, tallies)\n    \n    \n    norm = tallies / real(len(s))\n    se = sum(-(norm*log(merge(1.0, norm, norm .eq. 0))/log(2.0)))\n  end function se\n\n  subroutine TallyKey(s, counts)\n    character(len=*), intent(in) :: s\n    integer, dimension(256), intent(out) :: counts\n    integer :: i, j\n    counts = 0\n    do i=1,len(s)\n      j = iachar(s(i:i))\n      counts(j) = counts(j) + 1\n    end do\n  end subroutine TallyKey\n\nend program shannonEntropy\n", "target": "import java.lang.Math;\nimport java.util.Map;\nimport java.util.HashMap;\n\npublic class REntropy {\n\n  @SuppressWarnings(\"boxing\")\n  public static double getShannonEntropy(String s) {\n    int n = 0;\n    Map<Character, Integer> occ = new HashMap<>();\n\n    for (int c_ = 0; c_ < s.length(); ++c_) {\n      char cx = s.charAt(c_);\n      if (occ.containsKey(cx)) {\n        occ.put(cx, occ.get(cx) + 1);\n      } else {\n        occ.put(cx, 1);\n      }\n      ++n;\n    }\n\n    double e = 0.0;\n    for (Map.Entry<Character, Integer> entry : occ.entrySet()) {\n      char cx = entry.getKey();\n      double p = (double) entry.getValue() / n;\n      e += p * log2(p);\n    }\n    return -e;\n  }\n\n  private static double log2(double a) {\n    return Math.log(a) / Math.log(2);\n  }\n  public static void main(String[] args) {\n    String[] sstr = {\n      \"1223334444\",\n      \"1223334444555555555\", \n      \"122333\", \n      \"1227774444\",\n      \"aaBBcccDDDD\",\n      \"1234567890abcdefghijklmnopqrstuvwxyz\",\n      \"Rosetta Code\",\n    };\n\n    for (String ss : sstr) {\n      double entropy = REntropy.getShannonEntropy(ss);\n      System.out.printf(\"Shannon entropy of %40s:\u00a0%.12f%n\", \"\\\"\" + ss + \"\\\"\", entropy);\n    }\n    return;\n  }\n}\n"}
{"id": 149954, "name": "Entropy", "source": "Translate Fortran to Python: \n\n\n\n\n\n\n\n\nprogram shannonEntropy\n  implicit none\n  integer :: num, L, status\n  character(len=2048) :: s\n  num = 1\n  call get_command_argument(num, s, L, status)\n  if ((0 /= status) .or. (L .eq. 0)) then\n    write(0,*)'Expected a command line argument with some length.'\n  else\n    write(6,*)'Shannon entropy of '//(s(1:L))//' is ', se(s(1:L))\n  endif\n\ncontains\n  \n  \n  \n  \n  \n\n  \n  \n  \n  \n  \n  real function se(s)\n    implicit none\n    character(len=*), intent(in) :: s\n    integer, dimension(256) :: tallies\n    real, dimension(256) :: norm\n    tallies = 0\n    call TallyKey(s, tallies)\n    \n    \n    norm = tallies / real(len(s))\n    se = sum(-(norm*log(merge(1.0, norm, norm .eq. 0))/log(2.0)))\n  end function se\n\n  subroutine TallyKey(s, counts)\n    character(len=*), intent(in) :: s\n    integer, dimension(256), intent(out) :: counts\n    integer :: i, j\n    counts = 0\n    do i=1,len(s)\n      j = iachar(s(i:i))\n      counts(j) = counts(j) + 1\n    end do\n  end subroutine TallyKey\n\nend program shannonEntropy\n", "target": "from __future__ import division\nimport math\n\ndef hist(source):\n    hist = {}; l = 0;\n    for e in source:\n        l += 1\n        if e not in hist:\n            hist[e] = 0\n        hist[e] += 1\n    return (l,hist)\n\ndef entropy(hist,l):\n    elist = []\n    for v in hist.values():\n        c = v / l\n        elist.append(-c * math.log(c ,2))\n    return sum(elist)\n\ndef printHist(h):\n    flip = lambda (k,v) : (v,k)\n    h = sorted(h.iteritems(), key = flip)\n    print 'Sym\\thi\\tfi\\tInf'\n    for (k,v) in h:\n        print '%s\\t%f\\t%f\\t%f'%(k,v,v/l,-math.log(v/l, 2))\n    \n    \n\nsource = \"1223334444\"\n(l,h) = hist(source);\nprint '.[Results].'\nprint 'Length',l\nprint 'Entropy:', entropy(h, l)\nprintHist(h)\n"}
{"id": 150161, "name": "Host introspection", "source": "Translate Fortran to C#:    integer :: i\n   character(len=1) :: c(20)\n   equivalence (c, i)\n\n   WRITE(*,*) bit_size(1)  \n                           \n   i = 1\n\n   IF (ichar(c(1)) == 0) THEN\n      WRITE(*,*) \"Big Endian\"\n   ELSE\n     WRITE(*,*) \"Little Endian\"\n   END IF\n", "target": "static void Main()\n{\n  Console.WriteLine(\"Word size = {0} bytes,\",sizeof(int));\n\n  if (BitConverter.IsLittleEndian)\n    Console.WriteLine(\"Little-endian.\");\n  else\n    Console.WriteLine(\"Big-endian.\");\n}\n"}
{"id": 150164, "name": "Host introspection", "source": "Translate Fortran to Java:    integer :: i\n   character(len=1) :: c(20)\n   equivalence (c, i)\n\n   WRITE(*,*) bit_size(1)  \n                           \n   i = 1\n\n   IF (ichar(c(1)) == 0) THEN\n      WRITE(*,*) \"Big Endian\"\n   ELSE\n     WRITE(*,*) \"Little Endian\"\n   END IF\n", "target": "import java.nio.ByteOrder;\n\npublic class ShowByteOrder {\n    public static void main(String[] args) {\n        \n        System.out.println(ByteOrder.nativeOrder());\n    }\n}\n"}
{"id": 150165, "name": "Host introspection", "source": "Translate Fortran to Python:    integer :: i\n   character(len=1) :: c(20)\n   equivalence (c, i)\n\n   WRITE(*,*) bit_size(1)  \n                           \n   i = 1\n\n   IF (ichar(c(1)) == 0) THEN\n      WRITE(*,*) \"Big Endian\"\n   ELSE\n     WRITE(*,*) \"Little Endian\"\n   END IF\n", "target": ">>> import platform, sys, socket\n>>> platform.architecture()\n('64bit', 'ELF')\n>>> platform.machine()\n'x86_64'\n>>> platform.node()\n'yourhostname'\n>>> platform.system()\n'Linux'\n>>> sys.byteorder\nlittle\n>>> socket.gethostname()\n'yourhostname'\n>>>\n"}
{"id": 151157, "name": "Identity matrix", "source": "Translate Fortran to C#: program identitymatrix\n\n  real, dimension(:, :), allocatable :: I\n  character(len=8) :: fmt\n  integer :: ms, j\n\n  ms = 10   \n\n  allocate(I(ms,ms))\n  I = 0                           \n  forall(j = 1:ms) I(j,j) = 1     \n\n  \n\n  write (fmt, '(A,I2,A)') '(', ms, 'F6.2)'\n  \n  \n  \n  write (*, fmt) I(:,:)\n\n  deallocate(I)\n\nend program identitymatrix\n", "target": "using System;\nusing System.Linq;\n\nnamespace IdentityMatrix\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            if (args.Length != 1)\n            {\n                Console.WriteLine(\"Requires exactly one argument\");\n                return;\n            }\n            int n;\n            if (!int.TryParse(args[0], out n))\n            {\n                Console.WriteLine(\"Requires integer parameter\");\n                return;\n            }\n\n            var identity =\n                Enumerable.Range(0, n).Select(i => Enumerable.Repeat(0, n).Select((z,j) => j == i ? 1 : 0).ToList()).ToList();\n            foreach (var row in identity)\n            {\n                foreach (var elem in row)\n                {\n                    Console.Write(\" \" + elem);\n                }\n                Console.WriteLine();\n            }\n            Console.ReadKey();\n        }\n    }\n}\n"}
{"id": 151158, "name": "Identity matrix", "source": "Translate Fortran to C#: program identitymatrix\n\n  real, dimension(:, :), allocatable :: I\n  character(len=8) :: fmt\n  integer :: ms, j\n\n  ms = 10   \n\n  allocate(I(ms,ms))\n  I = 0                           \n  forall(j = 1:ms) I(j,j) = 1     \n\n  \n\n  write (fmt, '(A,I2,A)') '(', ms, 'F6.2)'\n  \n  \n  \n  write (*, fmt) I(:,:)\n\n  deallocate(I)\n\nend program identitymatrix\n", "target": "using System;\nusing System.Linq;\n\nnamespace IdentityMatrix\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            if (args.Length != 1)\n            {\n                Console.WriteLine(\"Requires exactly one argument\");\n                return;\n            }\n            int n;\n            if (!int.TryParse(args[0], out n))\n            {\n                Console.WriteLine(\"Requires integer parameter\");\n                return;\n            }\n\n            var identity =\n                Enumerable.Range(0, n).Select(i => Enumerable.Repeat(0, n).Select((z,j) => j == i ? 1 : 0).ToList()).ToList();\n            foreach (var row in identity)\n            {\n                foreach (var elem in row)\n                {\n                    Console.Write(\" \" + elem);\n                }\n                Console.WriteLine();\n            }\n            Console.ReadKey();\n        }\n    }\n}\n"}
{"id": 151165, "name": "Identity matrix", "source": "Translate Fortran to Java: program identitymatrix\n\n  real, dimension(:, :), allocatable :: I\n  character(len=8) :: fmt\n  integer :: ms, j\n\n  ms = 10   \n\n  allocate(I(ms,ms))\n  I = 0                           \n  forall(j = 1:ms) I(j,j) = 1     \n\n  \n\n  write (fmt, '(A,I2,A)') '(', ms, 'F6.2)'\n  \n  \n  \n  write (*, fmt) I(:,:)\n\n  deallocate(I)\n\nend program identitymatrix\n", "target": "public class PrintIdentityMatrix {\n\n    public static void main(String[] args) {\n        int n = 5;\n        int[][] array = new int[n][n];\n\n        IntStream.range(0, n).forEach(i -> array[i][i] = 1);\n\n        Arrays.stream(array)\n                .map((int[] a) -> Arrays.toString(a))\n                .forEach(System.out::println);\n    }\n}\n"}
{"id": 151166, "name": "Identity matrix", "source": "Translate Fortran to Java: program identitymatrix\n\n  real, dimension(:, :), allocatable :: I\n  character(len=8) :: fmt\n  integer :: ms, j\n\n  ms = 10   \n\n  allocate(I(ms,ms))\n  I = 0                           \n  forall(j = 1:ms) I(j,j) = 1     \n\n  \n\n  write (fmt, '(A,I2,A)') '(', ms, 'F6.2)'\n  \n  \n  \n  write (*, fmt) I(:,:)\n\n  deallocate(I)\n\nend program identitymatrix\n", "target": "public class PrintIdentityMatrix {\n\n    public static void main(String[] args) {\n        int n = 5;\n        int[][] array = new int[n][n];\n\n        IntStream.range(0, n).forEach(i -> array[i][i] = 1);\n\n        Arrays.stream(array)\n                .map((int[] a) -> Arrays.toString(a))\n                .forEach(System.out::println);\n    }\n}\n"}
{"id": 151167, "name": "Identity matrix", "source": "Translate Fortran to Python: program identitymatrix\n\n  real, dimension(:, :), allocatable :: I\n  character(len=8) :: fmt\n  integer :: ms, j\n\n  ms = 10   \n\n  allocate(I(ms,ms))\n  I = 0                           \n  forall(j = 1:ms) I(j,j) = 1     \n\n  \n\n  write (fmt, '(A,I2,A)') '(', ms, 'F6.2)'\n  \n  \n  \n  write (*, fmt) I(:,:)\n\n  deallocate(I)\n\nend program identitymatrix\n", "target": "def identity(size):\n    matrix = [[0]*size for i in range(size)]\n    \n\n    for i in range(size):\n        matrix[i][i] = 1\n    \n    for rows in matrix:\n        for elements in rows:\n            print elements,\n        print \"\"\n"}
{"id": 151168, "name": "Identity matrix", "source": "Translate Fortran to Python: program identitymatrix\n\n  real, dimension(:, :), allocatable :: I\n  character(len=8) :: fmt\n  integer :: ms, j\n\n  ms = 10   \n\n  allocate(I(ms,ms))\n  I = 0                           \n  forall(j = 1:ms) I(j,j) = 1     \n\n  \n\n  write (fmt, '(A,I2,A)') '(', ms, 'F6.2)'\n  \n  \n  \n  write (*, fmt) I(:,:)\n\n  deallocate(I)\n\nend program identitymatrix\n", "target": "def identity(size):\n    matrix = [[0]*size for i in range(size)]\n    \n\n    for i in range(size):\n        matrix[i][i] = 1\n    \n    for rows in matrix:\n        for elements in rows:\n            print elements,\n        print \"\"\n"}
{"id": 152456, "name": "Averages_Mean angle", "source": "Translate Fortran to C#: \n\n\n\n\n\n\n\n\n\n\nprogram average_angles\n  \n  \n  \n  \n  \n  real, parameter :: TAU = 6.283185307179586232 \n  integer, dimension(13), parameter :: test_data = (/2,350,10, 4,90,180,270,360, 3,10,20,30, 0/)\n  integer :: i, j, n\n  complex :: some\n  real :: angle\n  i = 1\n  n = int(test_data(i))\n  do while (0 .lt. n)\n    some = 0\n    do j = 1, n\n      angle = (TAU/360)*test_data(i+j)\n      some = some + cmplx(cos(angle), sin(angle))\n    end do\n    some = some / n\n    write(6,*)(360/TAU)*atan2(aimag(some), real(some)),test_data(i+1:i+n)\n    i = i + n + 1\n    n = int(test_data(i))\n  end do\nend program average_angles\n", "target": "using System;\nusing System.Linq;\nusing static System.Math;\nclass Program\n{\n    static double MeanAngle(double[] angles)\n    {\n        var x = angles.Sum(a => Cos(a * PI / 180)) / angles.Length;\n        var y = angles.Sum(a => Sin(a * PI / 180)) / angles.Length;\n        return Atan2(y, x) * 180 / PI;\n    }\n    static void Main()\n    {\n        Action<double[]> printMean = x => Console.WriteLine(\"{0:0.###}\", MeanAngle(x));\n        printMean(new double[] { 350, 10 });\n        printMean(new double[] { 90, 180, 270, 360 });\n        printMean(new double[] { 10, 20, 30 });\n    }\n}\n"}
{"id": 152457, "name": "Averages_Mean angle", "source": "Translate Fortran to C#: \n\n\n\n\n\n\n\n\n\n\nprogram average_angles\n  \n  \n  \n  \n  \n  real, parameter :: TAU = 6.283185307179586232 \n  integer, dimension(13), parameter :: test_data = (/2,350,10, 4,90,180,270,360, 3,10,20,30, 0/)\n  integer :: i, j, n\n  complex :: some\n  real :: angle\n  i = 1\n  n = int(test_data(i))\n  do while (0 .lt. n)\n    some = 0\n    do j = 1, n\n      angle = (TAU/360)*test_data(i+j)\n      some = some + cmplx(cos(angle), sin(angle))\n    end do\n    some = some / n\n    write(6,*)(360/TAU)*atan2(aimag(some), real(some)),test_data(i+1:i+n)\n    i = i + n + 1\n    n = int(test_data(i))\n  end do\nend program average_angles\n", "target": "using System;\nusing System.Linq;\nusing static System.Math;\nclass Program\n{\n    static double MeanAngle(double[] angles)\n    {\n        var x = angles.Sum(a => Cos(a * PI / 180)) / angles.Length;\n        var y = angles.Sum(a => Sin(a * PI / 180)) / angles.Length;\n        return Atan2(y, x) * 180 / PI;\n    }\n    static void Main()\n    {\n        Action<double[]> printMean = x => Console.WriteLine(\"{0:0.###}\", MeanAngle(x));\n        printMean(new double[] { 350, 10 });\n        printMean(new double[] { 90, 180, 270, 360 });\n        printMean(new double[] { 10, 20, 30 });\n    }\n}\n"}
{"id": 152463, "name": "Averages_Mean angle", "source": "Translate Fortran to Java: \n\n\n\n\n\n\n\n\n\n\nprogram average_angles\n  \n  \n  \n  \n  \n  real, parameter :: TAU = 6.283185307179586232 \n  integer, dimension(13), parameter :: test_data = (/2,350,10, 4,90,180,270,360, 3,10,20,30, 0/)\n  integer :: i, j, n\n  complex :: some\n  real :: angle\n  i = 1\n  n = int(test_data(i))\n  do while (0 .lt. n)\n    some = 0\n    do j = 1, n\n      angle = (TAU/360)*test_data(i+j)\n      some = some + cmplx(cos(angle), sin(angle))\n    end do\n    some = some / n\n    write(6,*)(360/TAU)*atan2(aimag(some), real(some)),test_data(i+1:i+n)\n    i = i + n + 1\n    n = int(test_data(i))\n  end do\nend program average_angles\n", "target": "import java.util.Arrays;\n\npublic class AverageMeanAngle {\n\n    public static void main(String[] args) {\n        printAverageAngle(350.0, 10.0);\n        printAverageAngle(90.0, 180.0, 270.0, 360.0);\n        printAverageAngle(10.0, 20.0, 30.0);\n        printAverageAngle(370.0);\n        printAverageAngle(180.0);\n    }\n\n    private static void printAverageAngle(double... sample) {\n        double meanAngle = getMeanAngle(sample);\n        System.out.printf(\"The mean angle of %s is %s%n\", Arrays.toString(sample), meanAngle);\n    }\n\n    public static double getMeanAngle(double... anglesDeg) {\n        double x = 0.0;\n        double y = 0.0;\n\n        for (double angleD : anglesDeg) {\n            double angleR = Math.toRadians(angleD);\n            x += Math.cos(angleR);\n            y += Math.sin(angleR);\n        }\n        double avgR = Math.atan2(y / anglesDeg.length, x / anglesDeg.length);\n        return Math.toDegrees(avgR);\n    }\n}\n"}
{"id": 152464, "name": "Averages_Mean angle", "source": "Translate Fortran to Java: \n\n\n\n\n\n\n\n\n\n\nprogram average_angles\n  \n  \n  \n  \n  \n  real, parameter :: TAU = 6.283185307179586232 \n  integer, dimension(13), parameter :: test_data = (/2,350,10, 4,90,180,270,360, 3,10,20,30, 0/)\n  integer :: i, j, n\n  complex :: some\n  real :: angle\n  i = 1\n  n = int(test_data(i))\n  do while (0 .lt. n)\n    some = 0\n    do j = 1, n\n      angle = (TAU/360)*test_data(i+j)\n      some = some + cmplx(cos(angle), sin(angle))\n    end do\n    some = some / n\n    write(6,*)(360/TAU)*atan2(aimag(some), real(some)),test_data(i+1:i+n)\n    i = i + n + 1\n    n = int(test_data(i))\n  end do\nend program average_angles\n", "target": "import java.util.Arrays;\n\npublic class AverageMeanAngle {\n\n    public static void main(String[] args) {\n        printAverageAngle(350.0, 10.0);\n        printAverageAngle(90.0, 180.0, 270.0, 360.0);\n        printAverageAngle(10.0, 20.0, 30.0);\n        printAverageAngle(370.0);\n        printAverageAngle(180.0);\n    }\n\n    private static void printAverageAngle(double... sample) {\n        double meanAngle = getMeanAngle(sample);\n        System.out.printf(\"The mean angle of %s is %s%n\", Arrays.toString(sample), meanAngle);\n    }\n\n    public static double getMeanAngle(double... anglesDeg) {\n        double x = 0.0;\n        double y = 0.0;\n\n        for (double angleD : anglesDeg) {\n            double angleR = Math.toRadians(angleD);\n            x += Math.cos(angleR);\n            y += Math.sin(angleR);\n        }\n        double avgR = Math.atan2(y / anglesDeg.length, x / anglesDeg.length);\n        return Math.toDegrees(avgR);\n    }\n}\n"}
{"id": 152465, "name": "Averages_Mean angle", "source": "Translate Fortran to Python: \n\n\n\n\n\n\n\n\n\n\nprogram average_angles\n  \n  \n  \n  \n  \n  real, parameter :: TAU = 6.283185307179586232 \n  integer, dimension(13), parameter :: test_data = (/2,350,10, 4,90,180,270,360, 3,10,20,30, 0/)\n  integer :: i, j, n\n  complex :: some\n  real :: angle\n  i = 1\n  n = int(test_data(i))\n  do while (0 .lt. n)\n    some = 0\n    do j = 1, n\n      angle = (TAU/360)*test_data(i+j)\n      some = some + cmplx(cos(angle), sin(angle))\n    end do\n    some = some / n\n    write(6,*)(360/TAU)*atan2(aimag(some), real(some)),test_data(i+1:i+n)\n    i = i + n + 1\n    n = int(test_data(i))\n  end do\nend program average_angles\n", "target": ">>> from cmath import rect, phase\n>>> from math import radians, degrees\n>>> def mean_angle(deg):\n...     return degrees(phase(sum(rect(1, radians(d)) for d in deg)/len(deg)))\n... \n>>> for angles in [[350, 10], [90, 180, 270, 360], [10, 20, 30]]:\n...     print('The mean angle of', angles, 'is:', round(mean_angle(angles), 12), 'degrees')\n...     \nThe mean angle of [350, 10] is: -0.0 degrees\nThe mean angle of [90, 180, 270, 360] is: -90.0 degrees\nThe mean angle of [10, 20, 30] is: 20.0 degrees\n>>>\n"}
{"id": 152466, "name": "Averages_Mean angle", "source": "Translate Fortran to Python: \n\n\n\n\n\n\n\n\n\n\nprogram average_angles\n  \n  \n  \n  \n  \n  real, parameter :: TAU = 6.283185307179586232 \n  integer, dimension(13), parameter :: test_data = (/2,350,10, 4,90,180,270,360, 3,10,20,30, 0/)\n  integer :: i, j, n\n  complex :: some\n  real :: angle\n  i = 1\n  n = int(test_data(i))\n  do while (0 .lt. n)\n    some = 0\n    do j = 1, n\n      angle = (TAU/360)*test_data(i+j)\n      some = some + cmplx(cos(angle), sin(angle))\n    end do\n    some = some / n\n    write(6,*)(360/TAU)*atan2(aimag(some), real(some)),test_data(i+1:i+n)\n    i = i + n + 1\n    n = int(test_data(i))\n  end do\nend program average_angles\n", "target": ">>> from cmath import rect, phase\n>>> from math import radians, degrees\n>>> def mean_angle(deg):\n...     return degrees(phase(sum(rect(1, radians(d)) for d in deg)/len(deg)))\n... \n>>> for angles in [[350, 10], [90, 180, 270, 360], [10, 20, 30]]:\n...     print('The mean angle of', angles, 'is:', round(mean_angle(angles), 12), 'degrees')\n...     \nThe mean angle of [350, 10] is: -0.0 degrees\nThe mean angle of [90, 180, 270, 360] is: -90.0 degrees\nThe mean angle of [10, 20, 30] is: 20.0 degrees\n>>>\n"}
{"id": 152992, "name": "Least common multiple", "source": "Translate Fortran to C#:     integer function lcm(a,b)\n    integer:: a,b\n        lcm = a*b / gcd(a,b)\n    end function lcm\n\n    integer function gcd(a,b)\n    integer :: a,b,t\n        do while (b/=0)\n            t = b\n            b = mod(a,b)\n            a = t\n        end do\n        gcd = abs(a)\n    end function gcd\n", "target": "Using System;\nclass Program\n{\n    static int gcd(int m, int n)\n    {\n        return n == 0 ? Math.Abs(m) : gcd(n, n % m);\n    }\n    static int lcm(int m, int n)\n    {\n        return Math.Abs(m * n) / gcd(m, n);\n    }\n    static void Main()\n    {\n        Console.WriteLine(\"lcm(12,18)=\" + lcm(12,18));\n    }\n}\n"}
{"id": 152993, "name": "Least common multiple", "source": "Translate Fortran to C#:     integer function lcm(a,b)\n    integer:: a,b\n        lcm = a*b / gcd(a,b)\n    end function lcm\n\n    integer function gcd(a,b)\n    integer :: a,b,t\n        do while (b/=0)\n            t = b\n            b = mod(a,b)\n            a = t\n        end do\n        gcd = abs(a)\n    end function gcd\n", "target": "Using System;\nclass Program\n{\n    static int gcd(int m, int n)\n    {\n        return n == 0 ? Math.Abs(m) : gcd(n, n % m);\n    }\n    static int lcm(int m, int n)\n    {\n        return Math.Abs(m * n) / gcd(m, n);\n    }\n    static void Main()\n    {\n        Console.WriteLine(\"lcm(12,18)=\" + lcm(12,18));\n    }\n}\n"}
{"id": 152998, "name": "Least common multiple", "source": "Translate Fortran to Java:     integer function lcm(a,b)\n    integer:: a,b\n        lcm = a*b / gcd(a,b)\n    end function lcm\n\n    integer function gcd(a,b)\n    integer :: a,b,t\n        do while (b/=0)\n            t = b\n            b = mod(a,b)\n            a = t\n        end do\n        gcd = abs(a)\n    end function gcd\n", "target": "import java.util.Scanner;\n\npublic class LCM{\n   public static void main(String[] args){\n      Scanner aScanner = new Scanner(System.in);\n   \n      \n      System.out.print(\"Enter the value of m:\");\n      int m = aScanner.nextInt();\n      System.out.print(\"Enter the value of n:\");\n      int n = aScanner.nextInt();\n      int lcm = (n == m || n == 1) ? m :(m == 1 ? n : 0);\n      \n      if (lcm == 0) {\n         int mm = m, nn = n;\n         while (mm != nn) {\n             while (mm < nn) { mm += m; }\n             while (nn < mm) { nn += n; }\n         }  \n         lcm = mm;\n      }\n      System.out.println(\"lcm(\" + m + \", \" + n + \") = \" + lcm);\n   }\n}\n"}
{"id": 152999, "name": "Least common multiple", "source": "Translate Fortran to Java:     integer function lcm(a,b)\n    integer:: a,b\n        lcm = a*b / gcd(a,b)\n    end function lcm\n\n    integer function gcd(a,b)\n    integer :: a,b,t\n        do while (b/=0)\n            t = b\n            b = mod(a,b)\n            a = t\n        end do\n        gcd = abs(a)\n    end function gcd\n", "target": "import java.util.Scanner;\n\npublic class LCM{\n   public static void main(String[] args){\n      Scanner aScanner = new Scanner(System.in);\n   \n      \n      System.out.print(\"Enter the value of m:\");\n      int m = aScanner.nextInt();\n      System.out.print(\"Enter the value of n:\");\n      int n = aScanner.nextInt();\n      int lcm = (n == m || n == 1) ? m :(m == 1 ? n : 0);\n      \n      if (lcm == 0) {\n         int mm = m, nn = n;\n         while (mm != nn) {\n             while (mm < nn) { mm += m; }\n             while (nn < mm) { nn += n; }\n         }  \n         lcm = mm;\n      }\n      System.out.println(\"lcm(\" + m + \", \" + n + \") = \" + lcm);\n   }\n}\n"}
{"id": 153000, "name": "Least common multiple", "source": "Translate Fortran to Python:     integer function lcm(a,b)\n    integer:: a,b\n        lcm = a*b / gcd(a,b)\n    end function lcm\n\n    integer function gcd(a,b)\n    integer :: a,b,t\n        do while (b/=0)\n            t = b\n            b = mod(a,b)\n            a = t\n        end do\n        gcd = abs(a)\n    end function gcd\n", "target": ">>> import fractions\n>>> def lcm(a,b): return abs(a * b) / fractions.gcd(a,b) if a and b else 0\n\n>>> lcm(12, 18)\n36\n>>> lcm(-6, 14)\n42\n>>> assert lcm(0, 2) == lcm(2, 0) == 0\n>>>\n"}
{"id": 153001, "name": "Least common multiple", "source": "Translate Fortran to Python:     integer function lcm(a,b)\n    integer:: a,b\n        lcm = a*b / gcd(a,b)\n    end function lcm\n\n    integer function gcd(a,b)\n    integer :: a,b,t\n        do while (b/=0)\n            t = b\n            b = mod(a,b)\n            a = t\n        end do\n        gcd = abs(a)\n    end function gcd\n", "target": ">>> import fractions\n>>> def lcm(a,b): return abs(a * b) / fractions.gcd(a,b) if a and b else 0\n\n>>> lcm(12, 18)\n36\n>>> lcm(-6, 14)\n42\n>>> assert lcm(0, 2) == lcm(2, 0) == 0\n>>>\n"}
{"id": 153588, "name": "Averages_Simple moving average", "source": "Translate Fortran to C#: program Movavg\n  implicit none\n\n  integer :: i\n\t\n  write (*, \"(a)\") \"SIMPLE MOVING AVERAGE: PERIOD = 3\"\n\n  do i = 1, 5\n    write (*, \"(a, i2, a, f8.6)\") \"Next number:\", i, \"   sma = \", sma(real(i))\n  end do\n  do i = 5, 1, -1\n    write (*, \"(a, i2, a, f8.6)\") \"Next number:\", i, \"   sma = \", sma(real(i))\n  end do \n \ncontains\n\nfunction sma(n)\n  real :: sma\n  real, intent(in) :: n\n  real, save :: a(3) = 0\n  integer, save :: count = 0\n\n  if (count < 3) then\n    count = count + 1\n    a(count) = n\n  else\n    a = eoshift(a, 1, n)\n  end if\n\n  sma = sum(a(1:count)) / real(count)\nend function\n\nend program Movavg\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\nnamespace SMA {\n    class Program {\n        static void Main(string[] args) {\n            var nums = Enumerable.Range(1, 5).Select(n => (double)n);\n            nums = nums.Concat(nums.Reverse());\n\n            var sma3 = SMA(3);\n            var sma5 = SMA(5);\n\n            foreach (var n in nums) {\n                Console.WriteLine(\"{0}    (sma3) {1,-16} (sma5) {2,-16}\", n, sma3(n), sma5(n));\n            }\n        }\n\n        static Func<double, double> SMA(int p) {\n            Queue<double> s = new Queue<double>(p);\n            return (x) => {\n                if (s.Count >= p) {\n                    s.Dequeue();\n                }\n                s.Enqueue(x);\n                return s.Average();\n            };\n        }\n    }\n}\n"}
{"id": 153591, "name": "Averages_Simple moving average", "source": "Translate Fortran to Java: program Movavg\n  implicit none\n\n  integer :: i\n\t\n  write (*, \"(a)\") \"SIMPLE MOVING AVERAGE: PERIOD = 3\"\n\n  do i = 1, 5\n    write (*, \"(a, i2, a, f8.6)\") \"Next number:\", i, \"   sma = \", sma(real(i))\n  end do\n  do i = 5, 1, -1\n    write (*, \"(a, i2, a, f8.6)\") \"Next number:\", i, \"   sma = \", sma(real(i))\n  end do \n \ncontains\n\nfunction sma(n)\n  real :: sma\n  real, intent(in) :: n\n  real, save :: a(3) = 0\n  integer, save :: count = 0\n\n  if (count < 3) then\n    count = count + 1\n    a(count) = n\n  else\n    a = eoshift(a, 1, n)\n  end if\n\n  sma = sum(a(1:count)) / real(count)\nend function\n\nend program Movavg\n", "target": "import java.util.LinkedList;\nimport java.util.Queue;\n\npublic class MovingAverage {\n    private final Queue<Double> window = new LinkedList<Double>();\n    private final int period;\n    private double sum;\n\n    public MovingAverage(int period) {\n        assert period > 0 : \"Period must be a positive integer\";\n        this.period = period;\n    }\n\n    public void newNum(double num) {\n        sum += num;\n        window.add(num);\n        if (window.size() > period) {\n            sum -= window.remove();\n        }\n    }\n\n    public double getAvg() {\n        if (window.isEmpty()) return 0.0; \n        return sum / window.size();\n    }\n\n    public static void main(String[] args) {\n        double[] testData = {1, 2, 3, 4, 5, 5, 4, 3, 2, 1};\n        int[] windowSizes = {3, 5};\n        for (int windSize : windowSizes) {\n            MovingAverage ma = new MovingAverage(windSize);\n            for (double x : testData) {\n                ma.newNum(x);\n                System.out.println(\"Next number = \" + x + \", SMA = \" + ma.getAvg());\n            }\n            System.out.println();\n        }\n    }\n}\n"}
{"id": 153592, "name": "Averages_Simple moving average", "source": "Translate Fortran to Python: program Movavg\n  implicit none\n\n  integer :: i\n\t\n  write (*, \"(a)\") \"SIMPLE MOVING AVERAGE: PERIOD = 3\"\n\n  do i = 1, 5\n    write (*, \"(a, i2, a, f8.6)\") \"Next number:\", i, \"   sma = \", sma(real(i))\n  end do\n  do i = 5, 1, -1\n    write (*, \"(a, i2, a, f8.6)\") \"Next number:\", i, \"   sma = \", sma(real(i))\n  end do \n \ncontains\n\nfunction sma(n)\n  real :: sma\n  real, intent(in) :: n\n  real, save :: a(3) = 0\n  integer, save :: count = 0\n\n  if (count < 3) then\n    count = count + 1\n    a(count) = n\n  else\n    a = eoshift(a, 1, n)\n  end if\n\n  sma = sum(a(1:count)) / real(count)\nend function\n\nend program Movavg\n", "target": "from collections import deque\n\ndef simplemovingaverage(period):\n    assert period == int(period) and period > 0, \"Period must be an integer >0\"\n    \n    summ = n = 0.0\n    values = deque([0.0] * period)     \n\n    def sma(x):\n        nonlocal summ, n\n        \n        values.append(x)\n        summ += x - values.popleft()\n        n = min(n+1, period)\n        return summ / n\n\n    return sma\n"}
{"id": 153820, "name": "Literals_Integer", "source": "Translate Fortran to C#: program IntegerLiteral\n\n  implicit none\n  integer, parameter   :: dec = 727\n  integer, parameter   :: hex = Z'2d7'\n  integer, parameter   :: oct = O'1327'\n  integer, parameter   :: bin = B'1011010111' \n\n  print *, dec, hex, oct, bin\n\nend program IntegerLiteral\n", "target": "int a = 42;\nint b = 0x2a;\n"}
{"id": 153824, "name": "Literals_Integer", "source": "Translate Fortran to Java: program IntegerLiteral\n\n  implicit none\n  integer, parameter   :: dec = 727\n  integer, parameter   :: hex = Z'2d7'\n  integer, parameter   :: oct = O'1327'\n  integer, parameter   :: bin = B'1011010111' \n\n  print *, dec, hex, oct, bin\n\nend program IntegerLiteral\n", "target": "public class IntegerLiterals {\n    public static void main(String[] args) {\n        System.out.println( 727 == 0x2d7 && \n                            727 == 01327   );\n    }\n}\n"}
{"id": 153825, "name": "Literals_Integer", "source": "Translate Fortran to Python: program IntegerLiteral\n\n  implicit none\n  integer, parameter   :: dec = 727\n  integer, parameter   :: hex = Z'2d7'\n  integer, parameter   :: oct = O'1327'\n  integer, parameter   :: bin = B'1011010111' \n\n  print *, dec, hex, oct, bin\n\nend program IntegerLiteral\n", "target": ">>> \n>>> 0b1011010111 == 0o1327 == 727 == 0x2d7\nTrue\n>>>\n"}
{"id": 154282, "name": "String concatenation", "source": "Translate Fortran to C#: program StringConcatenation\n\ninteger, parameter          :: maxstringlength = 64\ncharacter (maxstringlength) :: s1, s = \"hello\"\n\nprint *,s // \" literal\"\ns1 = trim(s) // \" literal\"\nprint *,s1\n\nend program\n", "target": "using System;\nnamespace StringConcatenation\n{\n  class Program {\n    static void Main() {\n        String s = scope (\"hello\");\n        Console.Write(s);\n        Console.WriteLine(\" literal\");\n        s.Append(\" literal\");\n        Console.WriteLine(s);\n    }\n  }\n}\n"}
{"id": 154286, "name": "String concatenation", "source": "Translate Fortran to Java: program StringConcatenation\n\ninteger, parameter          :: maxstringlength = 64\ncharacter (maxstringlength) :: s1, s = \"hello\"\n\nprint *,s // \" literal\"\ns1 = trim(s) // \" literal\"\nprint *,s1\n\nend program\n", "target": "public class Str{\n   public static void main(String[] args){\n      String s = \"hello\";\n      System.out.println(s + \" literal\");\n      String s2 = s + \" literal\";\n      System.out.println(s2);\n   }\n}\n"}
{"id": 154287, "name": "String concatenation", "source": "Translate Fortran to Python: program StringConcatenation\n\ninteger, parameter          :: maxstringlength = 64\ncharacter (maxstringlength) :: s1, s = \"hello\"\n\nprint *,s // \" literal\"\ns1 = trim(s) // \" literal\"\nprint *,s1\n\nend program\n", "target": "s1 = \"hello\"\nprint s1 + \" world\"\n\ns2 = s1 + \" world\"\nprint s2\n"}
{"id": 154740, "name": "Thue-Morse", "source": "Translate Fortran to C#: program thue_morse\n  implicit none\n  logical :: f(32) = .false.\n  integer :: n = 1\n\n  do\n    write(*,*) f(1:n)\n    if (n > size(f)/2) exit  \n    f(n+1:2*n) = .not. f(1:n)\n    n = n * 2\n  end do\n  \nend program thue_morse\n", "target": "using System;\nusing System.Text;\n\nnamespace ThueMorse\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            Sequence(6);\n        }\n\n        public static void Sequence(int steps)\n        {\n            var sb1 = new StringBuilder(\"0\");\n            var sb2 = new StringBuilder(\"1\");\n            for (int i = 0; i < steps; i++)\n            {\n                var tmp = sb1.ToString();\n                sb1.Append(sb2);\n                sb2.Append(tmp);\n            }\n            Console.WriteLine(sb1);\n            Console.ReadLine();\n        }\n    }\n}\n"}
{"id": 154741, "name": "Thue-Morse", "source": "Translate Fortran to C#: program thue_morse\n  implicit none\n  logical :: f(32) = .false.\n  integer :: n = 1\n\n  do\n    write(*,*) f(1:n)\n    if (n > size(f)/2) exit  \n    f(n+1:2*n) = .not. f(1:n)\n    n = n * 2\n  end do\n  \nend program thue_morse\n", "target": "using System;\nusing System.Text;\n\nnamespace ThueMorse\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            Sequence(6);\n        }\n\n        public static void Sequence(int steps)\n        {\n            var sb1 = new StringBuilder(\"0\");\n            var sb2 = new StringBuilder(\"1\");\n            for (int i = 0; i < steps; i++)\n            {\n                var tmp = sb1.ToString();\n                sb1.Append(sb2);\n                sb2.Append(tmp);\n            }\n            Console.WriteLine(sb1);\n            Console.ReadLine();\n        }\n    }\n}\n"}
{"id": 154747, "name": "Thue-Morse", "source": "Translate Fortran to Java: program thue_morse\n  implicit none\n  logical :: f(32) = .false.\n  integer :: n = 1\n\n  do\n    write(*,*) f(1:n)\n    if (n > size(f)/2) exit  \n    f(n+1:2*n) = .not. f(1:n)\n    n = n * 2\n  end do\n  \nend program thue_morse\n", "target": "public class ThueMorse {\n\n    public static void main(String[] args) {\n        sequence(6);\n    }\n\n    public static void sequence(int steps) {\n        StringBuilder sb1 = new StringBuilder(\"0\");\n        StringBuilder sb2 = new StringBuilder(\"1\");\n        for (int i = 0; i < steps; i++) {\n            String tmp = sb1.toString();\n            sb1.append(sb2);\n            sb2.append(tmp);\n        }\n        System.out.println(sb1);\n    }\n}\n"}
{"id": 154748, "name": "Thue-Morse", "source": "Translate Fortran to Java: program thue_morse\n  implicit none\n  logical :: f(32) = .false.\n  integer :: n = 1\n\n  do\n    write(*,*) f(1:n)\n    if (n > size(f)/2) exit  \n    f(n+1:2*n) = .not. f(1:n)\n    n = n * 2\n  end do\n  \nend program thue_morse\n", "target": "public class ThueMorse {\n\n    public static void main(String[] args) {\n        sequence(6);\n    }\n\n    public static void sequence(int steps) {\n        StringBuilder sb1 = new StringBuilder(\"0\");\n        StringBuilder sb2 = new StringBuilder(\"1\");\n        for (int i = 0; i < steps; i++) {\n            String tmp = sb1.toString();\n            sb1.append(sb2);\n            sb2.append(tmp);\n        }\n        System.out.println(sb1);\n    }\n}\n"}
{"id": 154749, "name": "Thue-Morse", "source": "Translate Fortran to Python: program thue_morse\n  implicit none\n  logical :: f(32) = .false.\n  integer :: n = 1\n\n  do\n    write(*,*) f(1:n)\n    if (n > size(f)/2) exit  \n    f(n+1:2*n) = .not. f(1:n)\n    n = n * 2\n  end do\n  \nend program thue_morse\n", "target": "m='0'\nprint(m)\nfor i in range(0,6):\n     m0=m\n     m=m.replace('0','a')\n     m=m.replace('1','0')\n     m=m.replace('a','1')\n     m=m0+m\n     print(m)\n"}
{"id": 154750, "name": "Thue-Morse", "source": "Translate Fortran to Python: program thue_morse\n  implicit none\n  logical :: f(32) = .false.\n  integer :: n = 1\n\n  do\n    write(*,*) f(1:n)\n    if (n > size(f)/2) exit  \n    f(n+1:2*n) = .not. f(1:n)\n    n = n * 2\n  end do\n  \nend program thue_morse\n", "target": "m='0'\nprint(m)\nfor i in range(0,6):\n     m0=m\n     m=m.replace('0','a')\n     m=m.replace('1','0')\n     m=m.replace('a','1')\n     m=m0+m\n     print(m)\n"}
{"id": 155050, "name": "Matrix chain multiplication", "source": "Translate Fortran to C#: module optim_mod\n    implicit none\ncontains\n    subroutine optim(a)\n        implicit none\n        integer :: a(:), n, i, j, k\n        integer, allocatable :: u(:, :)\n        integer(8) :: c\n        integer(8), allocatable :: v(:, :)\n\n        n = ubound(a, 1) - 1\n        allocate (u(n, n), v(n, n))\n        v = huge(v)\n        u(:, 1) = -1\n        v(:, 1) = 0\n        do j = 2, n\n            do i = 1, n - j + 1\n                do k = 1, j - 1\n                    c = v(i, k) + v(i + k, j - k) + int(a(i), 8) * int(a(i + k), 8) * int(a(i + j), 8)\n                    if (c < v(i, j)) then\n                        u(i, j) = k\n                        v(i, j) = c\n                    end if\n                end do\n            end do\n        end do\n        write (*, \"(I0,' ')\", advance=\"no\") v(1, n)\n        call aux(1, n)\n        print *\n        deallocate (u, v)\n    contains\n        recursive subroutine aux(i, j)\n            integer :: i, j, k\n\n            k = u(i, j)\n            if (k < 0) then\n                write (*, \"(I0)\", advance=\"no\") i\n            else\n                write (*, \"('(')\", advance=\"no\")\n                call aux(i, k)\n                write (*, \"('*')\", advance=\"no\")\n                call aux(i + k, j - k)\n                write (*, \"(')')\", advance=\"no\")\n            end if\n        end subroutine\n    end subroutine\nend module\n\nprogram matmulchain\n    use optim_mod\n    implicit none\n\n    call optim([5, 6, 3, 1])\n    call optim([1, 5, 25, 30, 100, 70, 2, 1, 100, 250, 1, 1000, 2])\n    call optim([1000, 1, 500, 12, 1, 700, 2500, 3, 2, 5, 14, 10])\nend program\n", "target": "using System;\n\nclass MatrixChainOrderOptimizer {\n    private int[,] m;\n    private int[,] s;\n\n    void OptimalMatrixChainOrder(int[] dims) {\n        int n = dims.Length - 1;\n        m = new int[n, n];\n        s = new int[n, n];\n        for (int len = 1; len < n; ++len) {\n            for (int i = 0; i < n - len; ++i) {\n                int j = i + len;\n                m[i, j] = Int32.MaxValue;\n                for (int k = i; k < j; ++k) {\n                    int temp = dims[i] * dims[k + 1] * dims[j + 1];\n                    int cost = m[i, k] + m[k + 1, j] + temp;\n                    if (cost < m[i, j]) {\n                        m[i, j] = cost;\n                        s[i, j] = k;\n                    }\n                }\n            }\n        }\n    }\n\n    void PrintOptimalChainOrder(int i, int j) {\n        if (i == j)\n            Console.Write((char)(i + 65));\n        else {\n            Console.Write(\"(\");\n            PrintOptimalChainOrder(i, s[i, j]);\n            PrintOptimalChainOrder(s[i, j] + 1, j);\n            Console.Write(\")\");\n        }\n    }\n\n    static void Main() {\n        var mcoo = new MatrixChainOrderOptimizer();\n        var dimsList = new int[3][];\n        dimsList[0] = new int[4] {5, 6, 3, 1};\n        dimsList[1] = new int[13] {1, 5, 25, 30, 100, 70, 2, 1, 100, 250, 1, 1000, 2};\n        dimsList[2] = new int[12] {1000, 1, 500, 12, 1, 700, 2500, 3, 2, 5, 14, 10};\n        for (int i = 0; i < dimsList.Length; ++i) {\n            Console.Write(\"Dims \u00a0: [\");\n            int n = dimsList[i].Length;\n            for (int j = 0; j < n; ++j) {\n                Console.Write(dimsList[i][j]);\n                if (j < n - 1)\n                    Console.Write(\", \");\n                else\n                    Console.WriteLine(\"]\");\n            }\n            mcoo.OptimalMatrixChainOrder(dimsList[i]);\n            Console.Write(\"Order\u00a0: \");\n            mcoo.PrintOptimalChainOrder(0, n - 2);\n            Console.WriteLine(\"\\nCost \u00a0: {0}\\n\",  mcoo.m[0, n - 2]);\n        }\n    }\n}\n"}
{"id": 155053, "name": "Matrix chain multiplication", "source": "Translate Fortran to Java: module optim_mod\n    implicit none\ncontains\n    subroutine optim(a)\n        implicit none\n        integer :: a(:), n, i, j, k\n        integer, allocatable :: u(:, :)\n        integer(8) :: c\n        integer(8), allocatable :: v(:, :)\n\n        n = ubound(a, 1) - 1\n        allocate (u(n, n), v(n, n))\n        v = huge(v)\n        u(:, 1) = -1\n        v(:, 1) = 0\n        do j = 2, n\n            do i = 1, n - j + 1\n                do k = 1, j - 1\n                    c = v(i, k) + v(i + k, j - k) + int(a(i), 8) * int(a(i + k), 8) * int(a(i + j), 8)\n                    if (c < v(i, j)) then\n                        u(i, j) = k\n                        v(i, j) = c\n                    end if\n                end do\n            end do\n        end do\n        write (*, \"(I0,' ')\", advance=\"no\") v(1, n)\n        call aux(1, n)\n        print *\n        deallocate (u, v)\n    contains\n        recursive subroutine aux(i, j)\n            integer :: i, j, k\n\n            k = u(i, j)\n            if (k < 0) then\n                write (*, \"(I0)\", advance=\"no\") i\n            else\n                write (*, \"('(')\", advance=\"no\")\n                call aux(i, k)\n                write (*, \"('*')\", advance=\"no\")\n                call aux(i + k, j - k)\n                write (*, \"(')')\", advance=\"no\")\n            end if\n        end subroutine\n    end subroutine\nend module\n\nprogram matmulchain\n    use optim_mod\n    implicit none\n\n    call optim([5, 6, 3, 1])\n    call optim([1, 5, 25, 30, 100, 70, 2, 1, 100, 250, 1, 1000, 2])\n    call optim([1000, 1, 500, 12, 1, 700, 2500, 3, 2, 5, 14, 10])\nend program\n", "target": "import java.util.Arrays;\n\npublic class MatrixChainMultiplication {\n\n    public static void main(String[] args) {\n        runMatrixChainMultiplication(new int[] {5, 6, 3, 1});\n        runMatrixChainMultiplication(new int[] {1, 5, 25, 30, 100, 70, 2, 1, 100, 250, 1, 1000, 2});\n        runMatrixChainMultiplication(new int[] {1000, 1, 500, 12, 1, 700, 2500, 3, 2, 5, 14, 10});\n    }\n    \n    private static void runMatrixChainMultiplication(int[] dims) {\n        System.out.printf(\"Array Dimension  = %s%n\", Arrays.toString(dims));\n        System.out.printf(\"Cost             = %d%n\", matrixChainOrder(dims));\n        System.out.printf(\"Optimal Multiply = %s%n%n\", getOptimalParenthesizations());\n    }\n\n    private static int[][]cost;\n    private static int[][]order;\n    \n    public static int matrixChainOrder(int[] dims) {\n        int n = dims.length - 1;\n        cost = new int[n][n];\n        order = new int[n][n];\n\n        for (int lenMinusOne = 1 ; lenMinusOne < n ; lenMinusOne++) {\n            for (int i = 0; i < n - lenMinusOne; i++) {\n                int j = i + lenMinusOne;\n                cost[i][j] = Integer.MAX_VALUE;\n                for (int k = i; k < j; k++) {\n                    int currentCost = cost[i][k] + cost[k+1][j] + dims[i]*dims[k+1]*dims[j+1];\n                    if (currentCost < cost[i][j]) {\n                        cost[i][j] = currentCost;\n                        order[i][j] = k;\n                    }\n                }\n            }\n        }\n        return cost[0][n-1];\n    }\n\n    private static String getOptimalParenthesizations() {\n        return getOptimalParenthesizations(order, 0, order.length - 1);\n    }\n    \n    private static String getOptimalParenthesizations(int[][]s, int i, int j) {\n        if (i == j) {\n            return String.format(\"%c\", i+65);\n        }\n        else {\n            StringBuilder sb = new StringBuilder();\n            sb.append(\"(\");\n            sb.append(getOptimalParenthesizations(s, i, s[i][j]));\n            sb.append(\" * \");\n            sb.append(getOptimalParenthesizations(s, s[i][j] + 1, j));\n            sb.append(\")\");\n            return sb.toString();\n        }\n    }\n\n}\n"}
{"id": 155054, "name": "Matrix chain multiplication", "source": "Translate Fortran to Python: module optim_mod\n    implicit none\ncontains\n    subroutine optim(a)\n        implicit none\n        integer :: a(:), n, i, j, k\n        integer, allocatable :: u(:, :)\n        integer(8) :: c\n        integer(8), allocatable :: v(:, :)\n\n        n = ubound(a, 1) - 1\n        allocate (u(n, n), v(n, n))\n        v = huge(v)\n        u(:, 1) = -1\n        v(:, 1) = 0\n        do j = 2, n\n            do i = 1, n - j + 1\n                do k = 1, j - 1\n                    c = v(i, k) + v(i + k, j - k) + int(a(i), 8) * int(a(i + k), 8) * int(a(i + j), 8)\n                    if (c < v(i, j)) then\n                        u(i, j) = k\n                        v(i, j) = c\n                    end if\n                end do\n            end do\n        end do\n        write (*, \"(I0,' ')\", advance=\"no\") v(1, n)\n        call aux(1, n)\n        print *\n        deallocate (u, v)\n    contains\n        recursive subroutine aux(i, j)\n            integer :: i, j, k\n\n            k = u(i, j)\n            if (k < 0) then\n                write (*, \"(I0)\", advance=\"no\") i\n            else\n                write (*, \"('(')\", advance=\"no\")\n                call aux(i, k)\n                write (*, \"('*')\", advance=\"no\")\n                call aux(i + k, j - k)\n                write (*, \"(')')\", advance=\"no\")\n            end if\n        end subroutine\n    end subroutine\nend module\n\nprogram matmulchain\n    use optim_mod\n    implicit none\n\n    call optim([5, 6, 3, 1])\n    call optim([1, 5, 25, 30, 100, 70, 2, 1, 100, 250, 1, 1000, 2])\n    call optim([1000, 1, 500, 12, 1, 700, 2500, 3, 2, 5, 14, 10])\nend program\n", "target": "def parens(n):\n    def aux(n, k):\n        if n == 1:\n            yield k\n        elif n == 2:\n            yield [k, k + 1]\n        else:\n            a = []\n            for i in range(1, n):\n                for u in aux(i, k):\n                    for v in aux(n - i, k + i):\n                        yield [u, v]\n    yield from aux(n, 0)\n"}
{"id": 155197, "name": "Repeat a string", "source": "Translate Fortran to C#: program test_repeat\n\n  write (*, '(a)') repeat ('ha', 5)\n\nend program test_repeat\n", "target": "String s = new String('X', 5);\ns.Replace(\"X\", \"ha\");\n"}
{"id": 155201, "name": "Repeat a string", "source": "Translate Fortran to Java: program test_repeat\n\n  write (*, '(a)') repeat ('ha', 5)\n\nend program test_repeat\n", "target": "String funny = \"ha\" * 5;\nString stars = '*' * 80;\n"}
{"id": 155202, "name": "Repeat a string", "source": "Translate Fortran to Python: program test_repeat\n\n  write (*, '(a)') repeat ('ha', 5)\n\nend program test_repeat\n", "target": "def setup():\n    rep = repeat(\"ha\", 5)\n    println(rep)\n\ndef repeat(s, times):\n    return s * times\n"}
{"id": 155413, "name": "Ethiopian multiplication", "source": "Translate Fortran to C#: program EthiopicMult\n  implicit none\n\n  print *, ethiopic(17, 34, .true.)\n\ncontains\n\n  subroutine halve(v)\n    integer, intent(inout) :: v\n    v = int(v / 2)\n  end subroutine halve\n\n  subroutine doublit(v)\n    integer, intent(inout) :: v\n    v = v * 2\n  end subroutine doublit\n\n  function iseven(x)\n    logical :: iseven\n    integer, intent(in) :: x\n    iseven = mod(x, 2) == 0\n  end function iseven\n\n  function ethiopic(multiplier, multiplicand, tutorialized) result(r)\n    integer :: r\n    integer, intent(in) :: multiplier, multiplicand\n    logical, intent(in), optional :: tutorialized\n\n    integer :: plier, plicand\n    logical :: tutor\n\n    plier = multiplier\n    plicand = multiplicand\n\n    if ( .not. present(tutorialized) ) then\n       tutor = .false.\n    else\n       tutor = tutorialized\n    endif\n\n    r = 0\n\n    if ( tutor ) write(*, '(A, I0, A, I0)') \"ethiopian multiplication of \", plier, \" by \", plicand\n\n    do while(plier >= 1)\n       if ( iseven(plier) ) then\n          if (tutor) write(*, '(I4, \" \", I6, A)') plier, plicand, \" struck\"\n       else\n          if (tutor) write(*, '(I4, \" \", I6, A)') plier, plicand, \" kept\"\n          r = r + plicand\n       endif\n       call halve(plier)\n       call doublit(plicand)\n    end do\n\n  end function ethiopic\n\nend program EthiopicMult\n", "target": "using System;\nusing System.Linq;\n\nnamespace RosettaCode.Tasks\n{\n\tpublic static class EthiopianMultiplication_Task\n\t{\n\t\tpublic static void Test ( )\n\t\t{\n\t\t\tConsole.WriteLine ( \"Ethiopian Multiplication\" );\n\t\t\tint A = 17, B = 34;\n\t\t\tConsole.WriteLine ( \"Recursion: {0}*{1}={2}\", A, B, EM_Recursion ( A, B ) );\n\t\t\tConsole.WriteLine ( \"Linq: {0}*{1}={2}\", A, B, EM_Linq ( A, B ) );\n\t\t\tConsole.WriteLine ( \"Loop: {0}*{1}={2}\", A, B, EM_Loop ( A, B ) );\n\t\t\tConsole.WriteLine ( );\n\t\t}\n\n\t\tpublic static int Halve ( this int p_Number )\n\t\t{\n\t\t\treturn p_Number >> 1;\n\t\t}\n\t\tpublic static int Double ( this int p_Number )\n\t\t{\n\t\t\treturn p_Number << 1;\n\t\t}\n\t\tpublic static bool IsEven ( this int p_Number )\n\t\t{\n\t\t\treturn ( p_Number % 2 ) == 0;\n\t\t}\n\n\t\tpublic static int EM_Recursion ( int p_NumberA, int p_NumberB )\n\t\t{\n\t\t\t\n\t\t\treturn p_NumberA == 1 ? p_NumberB : EM_Recursion ( p_NumberA.Halve ( ), p_NumberB.Double ( ) ) + ( p_NumberA.IsEven ( ) ? 0 : p_NumberB );\n\t\t}\n\t\tpublic static int EM_Linq ( int p_NumberA, int p_NumberB )\n\t\t{\n\t\t\t\n\t\t\t\n\t\t\treturn Enumerable.Range ( 1, Convert.ToInt32 ( Math.Log ( p_NumberA, Math.E ) / Math.Log ( 2, Math.E ) ) + 1 )\n\t\t\t\t\n\t\t\t\t.Select ( ( item ) => Enumerable.Repeat ( new { Col1 = p_NumberA, Col2 = p_NumberB }, item )\n\t\t\t\t\t\n\t\t\t\t\t.Aggregate ( ( agg_pair, orig_pair ) => new { Col1 = agg_pair.Col1.Halve ( ), Col2 = agg_pair.Col2.Double ( ) } ) )\n\t\t\t\t\n\t\t\t\t.Where ( pair => !pair.Col1.IsEven ( ) )\n\t\t\t\t\n\t\t\t\t.Sum ( pair => pair.Col2 );\n\t\t}\n\t\tpublic static int EM_Loop ( int p_NumberA, int p_NumberB )\n\t\t{\n\t\t\tint RetVal = 0;\n\t\t\twhile ( p_NumberA >= 1 )\n\t\t\t{\n\t\t\t\tRetVal += p_NumberA.IsEven ( ) ? 0 : p_NumberB;\n\t\t\t\tp_NumberA = p_NumberA.Halve ( );\n\t\t\t\tp_NumberB = p_NumberB.Double ( );\n\t\t\t}\n\t\t\treturn RetVal;\n\t\t}\n\t}\n}\n"}
{"id": 155417, "name": "Ethiopian multiplication", "source": "Translate Fortran to Java: program EthiopicMult\n  implicit none\n\n  print *, ethiopic(17, 34, .true.)\n\ncontains\n\n  subroutine halve(v)\n    integer, intent(inout) :: v\n    v = int(v / 2)\n  end subroutine halve\n\n  subroutine doublit(v)\n    integer, intent(inout) :: v\n    v = v * 2\n  end subroutine doublit\n\n  function iseven(x)\n    logical :: iseven\n    integer, intent(in) :: x\n    iseven = mod(x, 2) == 0\n  end function iseven\n\n  function ethiopic(multiplier, multiplicand, tutorialized) result(r)\n    integer :: r\n    integer, intent(in) :: multiplier, multiplicand\n    logical, intent(in), optional :: tutorialized\n\n    integer :: plier, plicand\n    logical :: tutor\n\n    plier = multiplier\n    plicand = multiplicand\n\n    if ( .not. present(tutorialized) ) then\n       tutor = .false.\n    else\n       tutor = tutorialized\n    endif\n\n    r = 0\n\n    if ( tutor ) write(*, '(A, I0, A, I0)') \"ethiopian multiplication of \", plier, \" by \", plicand\n\n    do while(plier >= 1)\n       if ( iseven(plier) ) then\n          if (tutor) write(*, '(I4, \" \", I6, A)') plier, plicand, \" struck\"\n       else\n          if (tutor) write(*, '(I4, \" \", I6, A)') plier, plicand, \" kept\"\n          r = r + plicand\n       endif\n       call halve(plier)\n       call doublit(plicand)\n    end do\n\n  end function ethiopic\n\nend program EthiopicMult\n", "target": "import java.util.HashMap;\nimport java.util.Map;\nimport java.util.Scanner;\npublic class Mult{\n  public static void main(String[] args){\n    Scanner sc = new Scanner(System.in);\n    int first = sc.nextInt();\n    int second = sc.nextInt();\n\n    if(first < 0){\n        first = -first;\n        second = -second;\n    }\n\n    Map<Integer, Integer> columns = new HashMap<Integer, Integer>();\n        columns.put(first, second);\n    int sum = isEven(first)? 0 : second;\n    do{\n      first = halveInt(first);\n      second = doubleInt(second);\n      columns.put(first, second);\n      if(!isEven(first)){\n          sum += second;\n      }\n    }while(first > 1);\n \n    System.out.println(sum);\n  }\n\n  public static int doubleInt(int doubleMe){\n    return doubleMe << 1; \n  }\n\n  public static int halveInt(int halveMe){\n    return halveMe >>> 1; \n  }\n\n  public static boolean isEven(int num){\n    return (num & 1) == 0;\n  }\n}\n"}
{"id": 155418, "name": "Ethiopian multiplication", "source": "Translate Fortran to Python: program EthiopicMult\n  implicit none\n\n  print *, ethiopic(17, 34, .true.)\n\ncontains\n\n  subroutine halve(v)\n    integer, intent(inout) :: v\n    v = int(v / 2)\n  end subroutine halve\n\n  subroutine doublit(v)\n    integer, intent(inout) :: v\n    v = v * 2\n  end subroutine doublit\n\n  function iseven(x)\n    logical :: iseven\n    integer, intent(in) :: x\n    iseven = mod(x, 2) == 0\n  end function iseven\n\n  function ethiopic(multiplier, multiplicand, tutorialized) result(r)\n    integer :: r\n    integer, intent(in) :: multiplier, multiplicand\n    logical, intent(in), optional :: tutorialized\n\n    integer :: plier, plicand\n    logical :: tutor\n\n    plier = multiplier\n    plicand = multiplicand\n\n    if ( .not. present(tutorialized) ) then\n       tutor = .false.\n    else\n       tutor = tutorialized\n    endif\n\n    r = 0\n\n    if ( tutor ) write(*, '(A, I0, A, I0)') \"ethiopian multiplication of \", plier, \" by \", plicand\n\n    do while(plier >= 1)\n       if ( iseven(plier) ) then\n          if (tutor) write(*, '(I4, \" \", I6, A)') plier, plicand, \" struck\"\n       else\n          if (tutor) write(*, '(I4, \" \", I6, A)') plier, plicand, \" kept\"\n          r = r + plicand\n       endif\n       call halve(plier)\n       call doublit(plicand)\n    end do\n\n  end function ethiopic\n\nend program EthiopicMult\n", "target": "tutor = True\n\ndef halve(x):\n    return x // 2\n\ndef double(x):\n    return x * 2\n\ndef even(x):\n    return not x % 2\n\ndef ethiopian(multiplier, multiplicand):\n    if tutor:\n        print(\"Ethiopian multiplication of %i and %i\" %\n              (multiplier, multiplicand))\n    result = 0\n    while multiplier >= 1:\n        if even(multiplier):\n            if tutor:\n                print(\"%4i %6i STRUCK\" %\n                      (multiplier, multiplicand))\n        else:\n            if tutor:\n                print(\"%4i %6i KEPT\" %\n                      (multiplier, multiplicand))\n            result += multiplicand\n        multiplier   = halve(multiplier)\n        multiplicand = double(multiplicand)\n    if tutor:\n        print()\n    return result\n"}
{"id": 155671, "name": "Forest fire", "source": "Translate Fortran to C#: module ForestFireModel\n  implicit none\n\n  type :: forestfire\n     integer, dimension(:,:,:), allocatable :: field\n     integer :: width, height\n     integer :: swapu\n     real :: prob_tree, prob_f, prob_p\n  end type forestfire\n\n  integer, parameter :: &\n       empty = 0, &\n       tree = 1, &\n       burning = 2\n\n  private :: bcheck, set, oget, burning_neighbor \n\ncontains\n\n  \n  function forestfire_new(w, h, pt, pf, pp) result(res)\n    type(forestfire) :: res\n    integer, intent(in) :: w, h\n    real, intent(in), optional :: pt, pf, pp\n\n    integer :: i, j\n    real :: r\n\n    allocate(res%field(2,w,h)) \n    res%prob_tree = 0.5\n    res%prob_f = 0.00001\n    res%prob_p = 0.001\n    if ( present(pt) ) res%prob_tree = pt\n    if ( present(pf) ) res%prob_f = pf\n    if ( present(pp) ) res%prob_p = pp\n\n    res%width = w\n    res%height = h\n    res%swapu = 0\n\n    res%field = empty\n\n    do i = 1,w\n       do j = 1,h\n          call random_number(r)\n          if ( r <= res%prob_tree ) call cset(res, i, j, tree)\n       end do\n    end do\n    \n  end function forestfire_new\n  \n  \n  subroutine forestfire_destroy(f)\n    type(forestfire), intent(inout) :: f\n\n    if ( allocated(f%field) ) deallocate(f%field)\n    \n  end subroutine forestfire_destroy\n\n  \n  subroutine forestfire_evolve(f)\n    type(forestfire), intent(inout) :: f\n\n    integer :: i, j\n    real :: r\n\n    do i = 1, f%width\n       do j = 1, f%height\n          select case ( get(f, i, j) )\n          case (burning)\n             call set(f, i, j, empty)\n          case (empty)\n             call random_number(r)\n             if ( r > f%prob_p ) then\n                call set(f, i, j, empty)\n             else\n                call set(f, i, j, tree)\n             end if\n          case (tree)\n             if ( burning_neighbor(f, i, j) ) then\n                call set(f, i, j, burning)\n             else\n                call random_number(r)\n                if ( r > f%prob_f ) then\n                   call set(f, i, j, tree)\n                else\n                   call set(f, i, j, burning)\n                end if\n             end if\n          end select\n       end do\n    end do\n    f%swapu = ieor(f%swapu, 1)\n  end subroutine forestfire_evolve\n\n  \n  subroutine set(f, i, j, t)\n    type(forestfire), intent(inout) :: f\n    integer, intent(in) :: i, j, t\n\n    if ( bcheck(f, i, j) ) then\n       f%field(ieor(f%swapu,1), i, j) = t\n    end if\n  end subroutine set\n\n  subroutine cset(f, i, j, t)\n    type(forestfire), intent(inout) :: f\n    integer, intent(in) :: i, j, t\n\n    if ( bcheck(f, i, j) ) then\n       f%field(f%swapu, i, j) = t\n    end if\n  end subroutine cset\n\n  function bcheck(f, i, j)\n    logical :: bcheck\n    type(forestfire), intent(in) :: f\n    integer, intent(in) :: i, j\n    \n    bcheck = .false.\n    if ( (i >= 1) .and. (i <= f%width) .and. &\n         (j >= 1) .and. (j <= f%height) ) bcheck = .true.\n \n  end function bcheck\n    \n\n  function get(f, i, j) result(r)\n    integer :: r\n    type(forestfire), intent(in) :: f\n    integer, intent(in) :: i, j\n    \n    if ( .not. bcheck(f, i, j) ) then\n       r = empty\n    else\n       r = f%field(f%swapu, i, j)\n    end if\n  end function get\n\n  function oget(f, i, j) result(r)\n    integer :: r\n    type(forestfire), intent(in) :: f\n    integer, intent(in) :: i, j\n    \n    if ( .not. bcheck(f, i, j) ) then\n       r = empty\n    else\n       r = f%field(ieor(f%swapu,1), i, j)\n    end if\n  end function oget\n\n  function burning_neighbor(f, i, j) result(r)\n    logical :: r\n    type(forestfire), intent(in) :: f\n    integer, intent(in) :: i, j\n\n    integer, dimension(3,3) :: s\n    \n    s = f%field(f%swapu, i-1:i+1, j-1:j+1)\n    s(2,2) = empty\n    r = any(s == burning)\n  end function burning_neighbor\n\n  subroutine forestfire_print(f)\n    type(forestfire), intent(in) :: f\n\n    integer :: i, j\n\n    do j = 1, f%height\n       do i = 1, f%width\n          select case(get(f, i, j))\n          case (empty) \n             write(*,'(A)', advance='no') '.'\n          case (tree)\n             write(*,'(A)', advance='no') 'Y'\n          case (burning) \n             write(*,'(A)', advance='no') '*'\n          end select\n       end do\n       write(*,*)\n    end do\n  end subroutine forestfire_print\n\nend module ForestFireModel\n", "target": "using System;\nusing System.Drawing;\nusing System.Drawing.Drawing2D;\nusing System.Threading;\nusing System.Windows.Forms;\n\nnamespace ForestFire\n{\n    class Program : Form\n    {\n        private static readonly Random rand = new Random();\n        private Bitmap img;\n\n        public Program(int w, int h, int f, int p)\n        {\n            Size = new Size(w, h);\n            StartPosition = FormStartPosition.CenterScreen;\n\n            Thread t = new Thread(() => fire(f, p));\n            t.Start();\n\n            FormClosing += (object sender, FormClosingEventArgs e) => { t.Abort(); t = null; };\n        }\n\n        private void fire(int f, int p)\n        {\n            int clientWidth = ClientRectangle.Width;\n            int clientHeight = ClientRectangle.Height;\n            int cellSize = 10;\n\n            img = new Bitmap(clientWidth, clientHeight);\n            Graphics g = Graphics.FromImage(img);\n\n            CellState[,] state = InitializeForestFire(clientWidth, clientHeight);\n\n            uint generation = 0;\n\n            do\n            {\n                g.FillRectangle(Brushes.White, 0, 0, img.Width, img.Height);\n                state = StepForestFire(state, f, p);\n\n                for (int y = 0; y < clientHeight - cellSize; y += cellSize)\n                {\n                    for (int x = 0; x < clientWidth - cellSize; x += cellSize)\n                    {\n                        switch (state[y, x])\n                        {\n                            case CellState.Empty:\n                                break;\n                            case CellState.Tree:\n                                g.FillRectangle(Brushes.DarkGreen, x, y, cellSize, cellSize);\n                                break;\n                            case CellState.Burning:\n                                g.FillRectangle(Brushes.DarkRed, x, y, cellSize, cellSize);\n                                break;\n                        }\n                    }\n                }\n\n                Thread.Sleep(500);\n\n                Invoke((MethodInvoker)Refresh);\n\n            } while (generation < uint.MaxValue);\n\n            g.Dispose();\n        }\n\n        private CellState[,] InitializeForestFire(int width, int height)\n        {\n            \n            var state = new CellState[height, width];\n            state.Initialize();\n            return state;\n        }\n\n        private enum CellState : byte\n        {\n            Empty = 0,\n            Tree = 1,\n            Burning = 2\n        }\n\n        private CellState[,] StepForestFire(CellState[,] state, int f, int p)\n        {\n            \n            var newState = (CellState[,])state.Clone();\n\n            int numRows = state.GetLength(0);\n            int numCols = state.GetLength(1);\n\n            for (int r = 1; r < numRows - 1; r++)\n            {\n                for (int c = 1; c < numCols - 1; c++)\n                {\n                    \n                    switch (state[r, c])\n                    {\n                        case CellState.Empty:\n                            if (rand.Next(0, p) == 0)\n                                newState[r, c] = CellState.Tree;\n                            break;\n\n                        case CellState.Tree:\n                            if (NeighborHasState(state, r, c, CellState.Burning) || rand.Next(0, f) == 0)\n                                newState[r, c] = CellState.Burning;\n                            break;\n\n                        case CellState.Burning:\n                            newState[r, c] = CellState.Empty;\n                            break;\n                    }\n                }\n            }\n\n            return newState;\n        }\n\n        private bool NeighborHasState(CellState[,] state, int x, int y, CellState value)\n        {\n            \n            for (int r = -1; r <= 1; r++)\n            {\n                for (int c = -1; c <= 1; c++)\n                {\n                    if (r == 0 && c == 0)\n                        continue;\n\n                    if (state[x + r, y + c] == value)\n                        return true;\n                }\n            }\n\n            return false;\n        }\n\n        protected override void OnPaint(PaintEventArgs e)\n        {\n            base.OnPaint(e);\n            e.Graphics.DrawImage(img, 0, 0);\n        }\n\n        [STAThread]\n        static void Main(string[] args)\n        {\n            Application.Run(new Program(w: 500, h: 500, f: 2, p: 5));\n        }\n    }\n}\n"}
{"id": 155674, "name": "Forest fire", "source": "Translate Fortran to Java: module ForestFireModel\n  implicit none\n\n  type :: forestfire\n     integer, dimension(:,:,:), allocatable :: field\n     integer :: width, height\n     integer :: swapu\n     real :: prob_tree, prob_f, prob_p\n  end type forestfire\n\n  integer, parameter :: &\n       empty = 0, &\n       tree = 1, &\n       burning = 2\n\n  private :: bcheck, set, oget, burning_neighbor \n\ncontains\n\n  \n  function forestfire_new(w, h, pt, pf, pp) result(res)\n    type(forestfire) :: res\n    integer, intent(in) :: w, h\n    real, intent(in), optional :: pt, pf, pp\n\n    integer :: i, j\n    real :: r\n\n    allocate(res%field(2,w,h)) \n    res%prob_tree = 0.5\n    res%prob_f = 0.00001\n    res%prob_p = 0.001\n    if ( present(pt) ) res%prob_tree = pt\n    if ( present(pf) ) res%prob_f = pf\n    if ( present(pp) ) res%prob_p = pp\n\n    res%width = w\n    res%height = h\n    res%swapu = 0\n\n    res%field = empty\n\n    do i = 1,w\n       do j = 1,h\n          call random_number(r)\n          if ( r <= res%prob_tree ) call cset(res, i, j, tree)\n       end do\n    end do\n    \n  end function forestfire_new\n  \n  \n  subroutine forestfire_destroy(f)\n    type(forestfire), intent(inout) :: f\n\n    if ( allocated(f%field) ) deallocate(f%field)\n    \n  end subroutine forestfire_destroy\n\n  \n  subroutine forestfire_evolve(f)\n    type(forestfire), intent(inout) :: f\n\n    integer :: i, j\n    real :: r\n\n    do i = 1, f%width\n       do j = 1, f%height\n          select case ( get(f, i, j) )\n          case (burning)\n             call set(f, i, j, empty)\n          case (empty)\n             call random_number(r)\n             if ( r > f%prob_p ) then\n                call set(f, i, j, empty)\n             else\n                call set(f, i, j, tree)\n             end if\n          case (tree)\n             if ( burning_neighbor(f, i, j) ) then\n                call set(f, i, j, burning)\n             else\n                call random_number(r)\n                if ( r > f%prob_f ) then\n                   call set(f, i, j, tree)\n                else\n                   call set(f, i, j, burning)\n                end if\n             end if\n          end select\n       end do\n    end do\n    f%swapu = ieor(f%swapu, 1)\n  end subroutine forestfire_evolve\n\n  \n  subroutine set(f, i, j, t)\n    type(forestfire), intent(inout) :: f\n    integer, intent(in) :: i, j, t\n\n    if ( bcheck(f, i, j) ) then\n       f%field(ieor(f%swapu,1), i, j) = t\n    end if\n  end subroutine set\n\n  subroutine cset(f, i, j, t)\n    type(forestfire), intent(inout) :: f\n    integer, intent(in) :: i, j, t\n\n    if ( bcheck(f, i, j) ) then\n       f%field(f%swapu, i, j) = t\n    end if\n  end subroutine cset\n\n  function bcheck(f, i, j)\n    logical :: bcheck\n    type(forestfire), intent(in) :: f\n    integer, intent(in) :: i, j\n    \n    bcheck = .false.\n    if ( (i >= 1) .and. (i <= f%width) .and. &\n         (j >= 1) .and. (j <= f%height) ) bcheck = .true.\n \n  end function bcheck\n    \n\n  function get(f, i, j) result(r)\n    integer :: r\n    type(forestfire), intent(in) :: f\n    integer, intent(in) :: i, j\n    \n    if ( .not. bcheck(f, i, j) ) then\n       r = empty\n    else\n       r = f%field(f%swapu, i, j)\n    end if\n  end function get\n\n  function oget(f, i, j) result(r)\n    integer :: r\n    type(forestfire), intent(in) :: f\n    integer, intent(in) :: i, j\n    \n    if ( .not. bcheck(f, i, j) ) then\n       r = empty\n    else\n       r = f%field(ieor(f%swapu,1), i, j)\n    end if\n  end function oget\n\n  function burning_neighbor(f, i, j) result(r)\n    logical :: r\n    type(forestfire), intent(in) :: f\n    integer, intent(in) :: i, j\n\n    integer, dimension(3,3) :: s\n    \n    s = f%field(f%swapu, i-1:i+1, j-1:j+1)\n    s(2,2) = empty\n    r = any(s == burning)\n  end function burning_neighbor\n\n  subroutine forestfire_print(f)\n    type(forestfire), intent(in) :: f\n\n    integer :: i, j\n\n    do j = 1, f%height\n       do i = 1, f%width\n          select case(get(f, i, j))\n          case (empty) \n             write(*,'(A)', advance='no') '.'\n          case (tree)\n             write(*,'(A)', advance='no') 'Y'\n          case (burning) \n             write(*,'(A)', advance='no') '*'\n          end select\n       end do\n       write(*,*)\n    end do\n  end subroutine forestfire_print\n\nend module ForestFireModel\n", "target": "import java.util.Arrays;\nimport java.util.LinkedList;\nimport java.util.List;\n\npublic class Fire {\n\tprivate static final char BURNING = 'w'; \n\tprivate static final char TREE = 'T';\n\tprivate static final char EMPTY = '.';\n\tprivate static final double F = 0.2;\n\tprivate static final double P = 0.4;\n\tprivate static final double TREE_PROB = 0.5;\n\t\n\tprivate static List<String> process(List<String> land){\n\t\tList<String> newLand = new LinkedList<String>();\n\t\tfor(int i = 0; i < land.size(); i++){\n\t\t\tString rowAbove, thisRow = land.get(i), rowBelow;\n\t\t\tif(i == 0){\n\t\t\t\trowAbove = null;\n\t\t\t\trowBelow = land.get(i + 1);\n\t\t\t}else if(i == land.size() - 1){\n\t\t\t\trowBelow = null;\n\t\t\t\trowAbove = land.get(i - 1);\n\t\t\t}else{\n\t\t\t\trowBelow = land.get(i + 1);\n\t\t\t\trowAbove = land.get(i - 1);\n\t\t\t}\n\t\t\tnewLand.add(processRows(rowAbove, thisRow, rowBelow));\n\t\t}\n\t\treturn newLand;\n\t}\n\n\tprivate static String processRows(String rowAbove, String thisRow,\n\t\t\tString rowBelow){\n\t\tString newRow = \"\";\n\t\tfor(int i = 0; i < thisRow.length();i++){\n\t\t\tswitch(thisRow.charAt(i)){\n\t\t\tcase BURNING:\n\t\t\t\tnewRow+= EMPTY;\n\t\t\t\tbreak;\n\t\t\tcase EMPTY:\n\t\t\t\tnewRow+= Math.random() < P ? TREE : EMPTY;\n\t\t\t\tbreak;\n\t\t\tcase TREE:\n\t\t\t\tString neighbors = \"\";\n\t\t\t\tif(i == 0){\n\t\t\t\t\tneighbors+= rowAbove == null ? \"\" : rowAbove.substring(i, i + 2);\n\t\t\t\t\tneighbors+= thisRow.charAt(i + 1);\n\t\t\t\t\tneighbors+= rowBelow == null ? \"\" : rowBelow.substring(i, i + 2);\n\t\t\t\t\tif(neighbors.contains(Character.toString(BURNING))){\n\t\t\t\t\t\tnewRow+= BURNING;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}else if(i == thisRow.length() - 1){\n\t\t\t\t\tneighbors+= rowAbove == null ? \"\" : rowAbove.substring(i - 1, i + 1);\n\t\t\t\t\tneighbors+= thisRow.charAt(i - 1);\n\t\t\t\t\tneighbors+= rowBelow == null ? \"\" : rowBelow.substring(i - 1, i + 1);\n\t\t\t\t\tif(neighbors.contains(Character.toString(BURNING))){\n\t\t\t\t\t\tnewRow+= BURNING;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}else{\n\t\t\t\t\tneighbors+= rowAbove == null ? \"\" : rowAbove.substring(i - 1, i + 2);\n\t\t\t\t\tneighbors+= thisRow.charAt(i + 1);\n\t\t\t\t\tneighbors+= thisRow.charAt(i - 1);\n\t\t\t\t\tneighbors+= rowBelow == null ? \"\" : rowBelow.substring(i - 1, i + 2);\n\t\t\t\t\tif(neighbors.contains(Character.toString(BURNING))){\n\t\t\t\t\t\tnewRow+= BURNING;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tnewRow+= Math.random() < F ? BURNING : TREE;\n\t\t\t}\n\t\t}\n\t\treturn newRow;\n\t}\n\t\n\tpublic static List<String> populate(int width, int height){\n\t\tList<String> land = new LinkedList<String>();\n\t\tfor(;height > 0; height--){\n\t\t\tStringBuilder line = new StringBuilder(width);\n\t\t\tfor(int i = width; i > 0; i--){\n\t\t\t\tline.append((Math.random() < TREE_PROB) ? TREE : EMPTY);\n\t\t\t}\n\t\t\tland.add(line.toString());\n\t\t}\n\t\treturn land;\n\t}\n\t\n\t\n\tpublic static void processN(List<String> land, int n){\n\t\tfor(int i = 0;i < n; i++){\n\t\t\tland = process(land);\n\t\t}\n\t}\n\t\n\t\n\tpublic static void processNPrint(List<String> land, int n){\n\t\tfor(int i = 0;i < n; i++){\n\t\t\tland = process(land);\n\t\t\tprint(land);\n\t\t}\n\t}\n\t\n\t\n\tpublic static void print(List<String> land){\n\t\tfor(String row: land){\n\t\t\tSystem.out.println(row);\n\t\t}\n\t\tSystem.out.println();\n\t}\n\t\n\tpublic static void main(String[] args){\n\t\tList<String> land = Arrays.asList(\".TTT.T.T.TTTT.T\",\n\t\t\t\t\"T.T.T.TT..T.T..\",\n\t\t\t\t\"TT.TTTT...T.TT.\",\n\t\t\t\t\"TTT..TTTTT.T..T\",\n\t\t\t\t\".T.TTT....TT.TT\",\n\t\t\t\t\"...T..TTT.TT.T.\",\n\t\t\t\t\".TT.TT...TT..TT\",\n\t\t\t\t\".TT.T.T..T.T.T.\",\n\t\t\t\t\"..TTT.TT.T..T..\",\n\t\t\t\t\".T....T.....TTT\",\n\t\t\t\t\"T..TTT..T..T...\",\n\t\t\t\t\"TTT....TTTTTT.T\",\n\t\t\t\t\"......TwTTT...T\",\n\t\t\t\t\"..T....TTTTTTTT\",\n\t\t\t\t\".T.T.T....TT...\");\n\t\tprint(land);\n\t\tprocessNPrint(land, 10);\n\t\t\n\t\tSystem.out.println(\"Random land test:\");\n\t\t\n\t\tland = populate(10, 10);\n\t\tprint(land);\n\t\tprocessNPrint(land, 10);\n\t}\n}\n"}
{"id": 155675, "name": "Forest fire", "source": "Translate Fortran to Python: module ForestFireModel\n  implicit none\n\n  type :: forestfire\n     integer, dimension(:,:,:), allocatable :: field\n     integer :: width, height\n     integer :: swapu\n     real :: prob_tree, prob_f, prob_p\n  end type forestfire\n\n  integer, parameter :: &\n       empty = 0, &\n       tree = 1, &\n       burning = 2\n\n  private :: bcheck, set, oget, burning_neighbor \n\ncontains\n\n  \n  function forestfire_new(w, h, pt, pf, pp) result(res)\n    type(forestfire) :: res\n    integer, intent(in) :: w, h\n    real, intent(in), optional :: pt, pf, pp\n\n    integer :: i, j\n    real :: r\n\n    allocate(res%field(2,w,h)) \n    res%prob_tree = 0.5\n    res%prob_f = 0.00001\n    res%prob_p = 0.001\n    if ( present(pt) ) res%prob_tree = pt\n    if ( present(pf) ) res%prob_f = pf\n    if ( present(pp) ) res%prob_p = pp\n\n    res%width = w\n    res%height = h\n    res%swapu = 0\n\n    res%field = empty\n\n    do i = 1,w\n       do j = 1,h\n          call random_number(r)\n          if ( r <= res%prob_tree ) call cset(res, i, j, tree)\n       end do\n    end do\n    \n  end function forestfire_new\n  \n  \n  subroutine forestfire_destroy(f)\n    type(forestfire), intent(inout) :: f\n\n    if ( allocated(f%field) ) deallocate(f%field)\n    \n  end subroutine forestfire_destroy\n\n  \n  subroutine forestfire_evolve(f)\n    type(forestfire), intent(inout) :: f\n\n    integer :: i, j\n    real :: r\n\n    do i = 1, f%width\n       do j = 1, f%height\n          select case ( get(f, i, j) )\n          case (burning)\n             call set(f, i, j, empty)\n          case (empty)\n             call random_number(r)\n             if ( r > f%prob_p ) then\n                call set(f, i, j, empty)\n             else\n                call set(f, i, j, tree)\n             end if\n          case (tree)\n             if ( burning_neighbor(f, i, j) ) then\n                call set(f, i, j, burning)\n             else\n                call random_number(r)\n                if ( r > f%prob_f ) then\n                   call set(f, i, j, tree)\n                else\n                   call set(f, i, j, burning)\n                end if\n             end if\n          end select\n       end do\n    end do\n    f%swapu = ieor(f%swapu, 1)\n  end subroutine forestfire_evolve\n\n  \n  subroutine set(f, i, j, t)\n    type(forestfire), intent(inout) :: f\n    integer, intent(in) :: i, j, t\n\n    if ( bcheck(f, i, j) ) then\n       f%field(ieor(f%swapu,1), i, j) = t\n    end if\n  end subroutine set\n\n  subroutine cset(f, i, j, t)\n    type(forestfire), intent(inout) :: f\n    integer, intent(in) :: i, j, t\n\n    if ( bcheck(f, i, j) ) then\n       f%field(f%swapu, i, j) = t\n    end if\n  end subroutine cset\n\n  function bcheck(f, i, j)\n    logical :: bcheck\n    type(forestfire), intent(in) :: f\n    integer, intent(in) :: i, j\n    \n    bcheck = .false.\n    if ( (i >= 1) .and. (i <= f%width) .and. &\n         (j >= 1) .and. (j <= f%height) ) bcheck = .true.\n \n  end function bcheck\n    \n\n  function get(f, i, j) result(r)\n    integer :: r\n    type(forestfire), intent(in) :: f\n    integer, intent(in) :: i, j\n    \n    if ( .not. bcheck(f, i, j) ) then\n       r = empty\n    else\n       r = f%field(f%swapu, i, j)\n    end if\n  end function get\n\n  function oget(f, i, j) result(r)\n    integer :: r\n    type(forestfire), intent(in) :: f\n    integer, intent(in) :: i, j\n    \n    if ( .not. bcheck(f, i, j) ) then\n       r = empty\n    else\n       r = f%field(ieor(f%swapu,1), i, j)\n    end if\n  end function oget\n\n  function burning_neighbor(f, i, j) result(r)\n    logical :: r\n    type(forestfire), intent(in) :: f\n    integer, intent(in) :: i, j\n\n    integer, dimension(3,3) :: s\n    \n    s = f%field(f%swapu, i-1:i+1, j-1:j+1)\n    s(2,2) = empty\n    r = any(s == burning)\n  end function burning_neighbor\n\n  subroutine forestfire_print(f)\n    type(forestfire), intent(in) :: f\n\n    integer :: i, j\n\n    do j = 1, f%height\n       do i = 1, f%width\n          select case(get(f, i, j))\n          case (empty) \n             write(*,'(A)', advance='no') '.'\n          case (tree)\n             write(*,'(A)', advance='no') 'Y'\n          case (burning) \n             write(*,'(A)', advance='no') '*'\n          end select\n       end do\n       write(*,*)\n    end do\n  end subroutine forestfire_print\n\nend module ForestFireModel\n", "target": "\n\nL = 15\n\ninitial_trees = 0.55\np = 0.01\nf = 0.001\n\ntry:\n    raw_input\nexcept:\n    raw_input = input\n    \nimport random\n\n\ntree, burning, space = 'TB.'\nhood = ((-1,-1), (-1,0), (-1,1),\n        (0,-1),          (0, 1),\n        (1,-1),  (1,0),  (1,1))\n\ndef initialise():\n    grid = {(x,y): (tree if random.random()<= initial_trees else space)\n            for x in range(L)\n            for y in range(L) }\n    return grid\n\ndef gprint(grid):\n    txt = '\\n'.join(''.join(grid[(x,y)] for x in range(L))\n                    for y in range(L))\n    print(txt)\n\ndef quickprint(grid):\n    t = b = 0\n    ll = L * L\n    for x in range(L):\n        for y in range(L):\n            if grid[(x,y)] in (tree, burning):\n                t += 1\n                if grid[(x,y)] == burning:\n                    b += 1\n    print(('Of %6i cells, %6i are trees of which %6i are currently burning.'\n          + ' (%6.3f%%, %6.3f%%)')\n          % (ll, t, b, 100. * t / ll, 100. * b / ll))\n                \n\ndef gnew(grid):\n    newgrid = {}\n    for x in range(L):\n        for y in range(L):\n            if grid[(x,y)] == burning:\n                newgrid[(x,y)] = space\n            elif grid[(x,y)] == space:\n                newgrid[(x,y)] = tree if random.random()<= p else space\n            elif grid[(x,y)] == tree:\n                newgrid[(x,y)] = (burning\n                                   if any(grid.get((x+dx,y+dy),space) == burning\n                                            for dx,dy in hood)\n                                        or random.random()<= f \n                                   else tree)\n    return newgrid\n\nif __name__ == '__main__':\n    grid = initialise()\n    iter = 0\n    while True:\n        quickprint(grid)\n        inp = raw_input('Print/Quit/<int>/<return> %6i: ' % iter).lower().strip()\n        if inp:\n            if inp[0] == 'p':\n                gprint(grid)\n            elif inp.isdigit():\n                for i in range(int(inp)):\n                    iter +=1\n                    grid = gnew(grid)\n                    quickprint(grid)\n            elif inp[0] == 'q':\n                break\n        grid = gnew(grid)\n        iter +=1\n"}
{"id": 156467, "name": "Number reversal game", "source": "Translate Fortran to C#: program Reversal_game\n  implicit none\n \n  integer :: list(9) = (/ 1, 2, 3, 4, 5, 6, 7, 8, 9 /)\n  integer :: pos, attempts = 0\n    \n  call random_seed\n  do while (sorted(list))\n    call Shuffle(list)\n  end do\n  write(*, \"(9i5)\") list\n  write(*,*)\n  do while (.not. Sorted(list))\n    write(*, \"(a)\", advance=\"no\") \"How many numbers from the left do you want to reverse?\u00a0: \"\n    read*, pos\n    attempts = attempts + 1\n    list(1:pos) = list(pos:1:-1)\n    write(*, \"(9i5)\") list\n    write(*,*)\n  end do\n  write(*,*)\n  write(*, \"(a,i0,a)\") \"Congratulations\n\ncontains\n\nsubroutine Shuffle(a)\n  integer, intent(inout) :: a(:)\n  integer :: i, randpos, temp\n  real :: r\n\n  do i = size(a), 2, -1\n    call random_number(r)\n    randpos = int(r * i) + 1\n    temp = a(randpos)\n    a(randpos) = a(i)\n    a(i) = temp\n  end do\nend subroutine\n\nfunction Sorted(a)\n  logical :: Sorted\n  integer, intent(in) :: a(:)\n  integer :: i\n  \n  do i = 1, size(a)-1\n    if(list(i+1) /= list(i)+1) then\n      Sorted = .false.\n      return\n    end if\n  end do\n  Sorted = .true.\nend function\n  \nend program\n", "target": "using System;\nusing System.Linq;\n\nclass Program\n{\n    static void Main(string[] args)\n    {\n        var r = new Random();\n\n        var tries = 1;\n        var sorted = Enumerable.Range(1, 9).ToList();\n        var values = sorted.OrderBy(x => r.Next(-1, 1)).ToList();\n\n        while (Enumerable.SequenceEqual(sorted, values)) {\n            values = sorted.OrderBy(x => r.Next(-1, 1)).ToList();\n        }\n\n        \n\n        while (!Enumerable.SequenceEqual(sorted, values))\n        {\n            Console.Write(\"# {0}: LIST: {1} - Flip how many? \", tries, String.Join(\" \", values));\n\n            values.Reverse(0, int.Parse(Console.ReadLine()));\n            tries += 1;\n        }\n\n        Console.WriteLine(\"\\nYou took {0} attempts to put the digits in order!\", tries - 1);\n        Console.ReadLine();\n    }\n}\n"}
{"id": 156470, "name": "Number reversal game", "source": "Translate Fortran to Java: program Reversal_game\n  implicit none\n \n  integer :: list(9) = (/ 1, 2, 3, 4, 5, 6, 7, 8, 9 /)\n  integer :: pos, attempts = 0\n    \n  call random_seed\n  do while (sorted(list))\n    call Shuffle(list)\n  end do\n  write(*, \"(9i5)\") list\n  write(*,*)\n  do while (.not. Sorted(list))\n    write(*, \"(a)\", advance=\"no\") \"How many numbers from the left do you want to reverse?\u00a0: \"\n    read*, pos\n    attempts = attempts + 1\n    list(1:pos) = list(pos:1:-1)\n    write(*, \"(9i5)\") list\n    write(*,*)\n  end do\n  write(*,*)\n  write(*, \"(a,i0,a)\") \"Congratulations\n\ncontains\n\nsubroutine Shuffle(a)\n  integer, intent(inout) :: a(:)\n  integer :: i, randpos, temp\n  real :: r\n\n  do i = size(a), 2, -1\n    call random_number(r)\n    randpos = int(r * i) + 1\n    temp = a(randpos)\n    a(randpos) = a(i)\n    a(i) = temp\n  end do\nend subroutine\n\nfunction Sorted(a)\n  logical :: Sorted\n  integer, intent(in) :: a(:)\n  integer :: i\n  \n  do i = 1, size(a)-1\n    if(list(i+1) /= list(i)+1) then\n      Sorted = .false.\n      return\n    end if\n  end do\n  Sorted = .true.\nend function\n  \nend program\n", "target": "import java.util.List;\nimport java.util.ArrayList;\nimport java.util.Scanner;\nimport java.util.Collections;\n\n\npublic class ReversalGame {\n    private List<Integer> gameList;\n\n    public ReversalGame() {\n        initialize();\n    }\n\n    public void play() throws Exception {\n        int i = 0;\n        int moveCount = 0;\n        Scanner scanner = new Scanner(System.in);\n        while (true) {\n            System.out.println(gameList);\n            System.out.println(\"Please enter a index to reverse from 2 to 9. Enter 99 to quit\");\n            i = scanner.nextInt();\n            if (i == 99) {\n                break;\n            }\n            if (i < 2 || i > 9) {\n                System.out.println(\"Invalid input\");\n            } else {\n                moveCount++;\n                reverse(i);\n                if (isSorted()) {\n                    System.out.println(\"Congratulations you solved this in \" + moveCount + \" moves!\");\n                    break;\n                }\n            }\n\n        }\n        scanner.close();\n    }\n\n    private void reverse(int position) {\n        Collections.reverse(gameList.subList(0, position));\n    }\n\n    private boolean isSorted() {\n        for (int i=0; i < gameList.size() - 1; ++i) {\n            if (gameList.get(i).compareTo(gameList.get(i + 1)) > 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    private void initialize() {\n        this.gameList = new ArrayList<Integer>(9);\n        for (int i=1; i < 10; ++i) {\n            gameList.add(i);\n        }\n        while (isSorted()) {\n            Collections.shuffle(gameList);\n        }\n    }\n\n\n    public static void main(String[] args) {\n        try {\n            ReversalGame game = new ReversalGame();\n            game.play();\n        } catch (Exception e) {\n            System.out.println(e.getMessage());\n            e.printStackTrace();\n        }\n    }\n}\n"}
{"id": 156471, "name": "Number reversal game", "source": "Translate Fortran to Python: program Reversal_game\n  implicit none\n \n  integer :: list(9) = (/ 1, 2, 3, 4, 5, 6, 7, 8, 9 /)\n  integer :: pos, attempts = 0\n    \n  call random_seed\n  do while (sorted(list))\n    call Shuffle(list)\n  end do\n  write(*, \"(9i5)\") list\n  write(*,*)\n  do while (.not. Sorted(list))\n    write(*, \"(a)\", advance=\"no\") \"How many numbers from the left do you want to reverse?\u00a0: \"\n    read*, pos\n    attempts = attempts + 1\n    list(1:pos) = list(pos:1:-1)\n    write(*, \"(9i5)\") list\n    write(*,*)\n  end do\n  write(*,*)\n  write(*, \"(a,i0,a)\") \"Congratulations\n\ncontains\n\nsubroutine Shuffle(a)\n  integer, intent(inout) :: a(:)\n  integer :: i, randpos, temp\n  real :: r\n\n  do i = size(a), 2, -1\n    call random_number(r)\n    randpos = int(r * i) + 1\n    temp = a(randpos)\n    a(randpos) = a(i)\n    a(i) = temp\n  end do\nend subroutine\n\nfunction Sorted(a)\n  logical :: Sorted\n  integer, intent(in) :: a(:)\n  integer :: i\n  \n  do i = 1, size(a)-1\n    if(list(i+1) /= list(i)+1) then\n      Sorted = .false.\n      return\n    end if\n  end do\n  Sorted = .true.\nend function\n  \nend program\n", "target": "print '\n\nvar data, trials = list(1..9), 0\n\nwhile data == sort data:\n    random.shuffle data\n\nwhile data != sort data:\n    trials += 1\n    flip = int input '\n    data[:flip] = reverse data[:flip]\n\nprint '\\nYou took ${trials} attempts to put digits in order!'\n"}
{"id": 156753, "name": "Van Eck sequence", "source": "Translate Fortran to C#:       program VanEck\n      implicit none\n      integer eck(1000), i, j\n      \n      eck(1) = 0\n      do 20 i=1, 999\n          do 10 j=i-1, 1, -1\n              if (eck(i) .eq. eck(j)) then\n                  eck(i+1) = i-j\n                  go to 20\n              end if\n 10       continue\n          eck(i+1) = 0\n 20   continue\n \n      do 30 i=1, 10\n 30       write (*,'(I4)',advance='no') eck(i)\n      write (*,*)\n      \n      do 40 i=991, 1000\n 40       write (*,'(I4)',advance='no') eck(i)\n      write (*,*)\n      \n      end program\n", "target": "using System.Linq; class Program { static void Main() {\n    int a, b, c, d, e, f, g; int[] h = new int[g = 1000];\n    for (a = 0, b = 1, c = 2; c < g; a = b, b = c++)\n        for (d = a, e = b - d, f = h[b]; e <= b; e++)\n            if (f == h[d--]) { h[c] = e; break; }\n    void sho(int i) { System.Console.WriteLine(string.Join(\" \",\n        h.Skip(i).Take(10))); } sho(0); sho(990); } }\n"}
{"id": 156754, "name": "Van Eck sequence", "source": "Translate Fortran to C#:       program VanEck\n      implicit none\n      integer eck(1000), i, j\n      \n      eck(1) = 0\n      do 20 i=1, 999\n          do 10 j=i-1, 1, -1\n              if (eck(i) .eq. eck(j)) then\n                  eck(i+1) = i-j\n                  go to 20\n              end if\n 10       continue\n          eck(i+1) = 0\n 20   continue\n \n      do 30 i=1, 10\n 30       write (*,'(I4)',advance='no') eck(i)\n      write (*,*)\n      \n      do 40 i=991, 1000\n 40       write (*,'(I4)',advance='no') eck(i)\n      write (*,*)\n      \n      end program\n", "target": "using System.Linq; class Program { static void Main() {\n    int a, b, c, d, e, f, g; int[] h = new int[g = 1000];\n    for (a = 0, b = 1, c = 2; c < g; a = b, b = c++)\n        for (d = a, e = b - d, f = h[b]; e <= b; e++)\n            if (f == h[d--]) { h[c] = e; break; }\n    void sho(int i) { System.Console.WriteLine(string.Join(\" \",\n        h.Skip(i).Take(10))); } sho(0); sho(990); } }\n"}
{"id": 156759, "name": "Van Eck sequence", "source": "Translate Fortran to Java:       program VanEck\n      implicit none\n      integer eck(1000), i, j\n      \n      eck(1) = 0\n      do 20 i=1, 999\n          do 10 j=i-1, 1, -1\n              if (eck(i) .eq. eck(j)) then\n                  eck(i+1) = i-j\n                  go to 20\n              end if\n 10       continue\n          eck(i+1) = 0\n 20   continue\n \n      do 30 i=1, 10\n 30       write (*,'(I4)',advance='no') eck(i)\n      write (*,*)\n      \n      do 40 i=991, 1000\n 40       write (*,'(I4)',advance='no') eck(i)\n      write (*,*)\n      \n      end program\n", "target": "import java.util.HashMap;\nimport java.util.Map;\n\npublic class VanEckSequence {\n\n    public static void main(String[] args) {\n        System.out.println(\"First 10 terms of Van Eck's sequence:\");\n        vanEck(1, 10);\n        System.out.println(\"\");\n        System.out.println(\"Terms 991 to 1000 of Van Eck's sequence:\");\n        vanEck(991, 1000);\n    }\n    \n    private static void vanEck(int firstIndex, int lastIndex) {\n        Map<Integer,Integer> vanEckMap = new HashMap<>();        \n        int last = 0;\n        if ( firstIndex == 1 ) {\n            System.out.printf(\"VanEck[%d] = %d%n\", 1, 0);\n        }\n        for ( int n = 2 ; n <= lastIndex ; n++ ) {\n            int vanEck = vanEckMap.containsKey(last) ? n - vanEckMap.get(last) : 0;\n            vanEckMap.put(last, n);\n            last = vanEck;\n            if ( n >= firstIndex ) {\n                System.out.printf(\"VanEck[%d] = %d%n\", n, vanEck);\n            }\n        }\n        \n    }\n\n}\n"}
{"id": 156760, "name": "Van Eck sequence", "source": "Translate Fortran to Java:       program VanEck\n      implicit none\n      integer eck(1000), i, j\n      \n      eck(1) = 0\n      do 20 i=1, 999\n          do 10 j=i-1, 1, -1\n              if (eck(i) .eq. eck(j)) then\n                  eck(i+1) = i-j\n                  go to 20\n              end if\n 10       continue\n          eck(i+1) = 0\n 20   continue\n \n      do 30 i=1, 10\n 30       write (*,'(I4)',advance='no') eck(i)\n      write (*,*)\n      \n      do 40 i=991, 1000\n 40       write (*,'(I4)',advance='no') eck(i)\n      write (*,*)\n      \n      end program\n", "target": "import java.util.HashMap;\nimport java.util.Map;\n\npublic class VanEckSequence {\n\n    public static void main(String[] args) {\n        System.out.println(\"First 10 terms of Van Eck's sequence:\");\n        vanEck(1, 10);\n        System.out.println(\"\");\n        System.out.println(\"Terms 991 to 1000 of Van Eck's sequence:\");\n        vanEck(991, 1000);\n    }\n    \n    private static void vanEck(int firstIndex, int lastIndex) {\n        Map<Integer,Integer> vanEckMap = new HashMap<>();        \n        int last = 0;\n        if ( firstIndex == 1 ) {\n            System.out.printf(\"VanEck[%d] = %d%n\", 1, 0);\n        }\n        for ( int n = 2 ; n <= lastIndex ; n++ ) {\n            int vanEck = vanEckMap.containsKey(last) ? n - vanEckMap.get(last) : 0;\n            vanEckMap.put(last, n);\n            last = vanEck;\n            if ( n >= firstIndex ) {\n                System.out.printf(\"VanEck[%d] = %d%n\", n, vanEck);\n            }\n        }\n        \n    }\n\n}\n"}
{"id": 156761, "name": "Van Eck sequence", "source": "Translate Fortran to Python:       program VanEck\n      implicit none\n      integer eck(1000), i, j\n      \n      eck(1) = 0\n      do 20 i=1, 999\n          do 10 j=i-1, 1, -1\n              if (eck(i) .eq. eck(j)) then\n                  eck(i+1) = i-j\n                  go to 20\n              end if\n 10       continue\n          eck(i+1) = 0\n 20   continue\n \n      do 30 i=1, 10\n 30       write (*,'(I4)',advance='no') eck(i)\n      write (*,*)\n      \n      do 40 i=991, 1000\n 40       write (*,'(I4)',advance='no') eck(i)\n      write (*,*)\n      \n      end program\n", "target": "def van_eck():\n    n, seen, val = 0, {}, 0\n    while True:\n        yield val\n        last = {val: n}\n        val = n - seen.get(val, n)\n        seen.update(last)\n        n += 1\n\nif __name__ == '__main__':\n    print(\"Van Eck: first 10 terms:  \", list(islice(van_eck(), 10)))\n    print(\"Van Eck: terms 991 - 1000:\", list(islice(van_eck(), 1000))[-10:])\n"}
{"id": 156762, "name": "Van Eck sequence", "source": "Translate Fortran to Python:       program VanEck\n      implicit none\n      integer eck(1000), i, j\n      \n      eck(1) = 0\n      do 20 i=1, 999\n          do 10 j=i-1, 1, -1\n              if (eck(i) .eq. eck(j)) then\n                  eck(i+1) = i-j\n                  go to 20\n              end if\n 10       continue\n          eck(i+1) = 0\n 20   continue\n \n      do 30 i=1, 10\n 30       write (*,'(I4)',advance='no') eck(i)\n      write (*,*)\n      \n      do 40 i=991, 1000\n 40       write (*,'(I4)',advance='no') eck(i)\n      write (*,*)\n      \n      end program\n", "target": "def van_eck():\n    n, seen, val = 0, {}, 0\n    while True:\n        yield val\n        last = {val: n}\n        val = n - seen.get(val, n)\n        seen.update(last)\n        n += 1\n\nif __name__ == '__main__':\n    print(\"Van Eck: first 10 terms:  \", list(islice(van_eck(), 10)))\n    print(\"Van Eck: terms 991 - 1000:\", list(islice(van_eck(), 1000))[-10:])\n"}
{"id": 157018, "name": "Bitmap_Midpoint circle algorithm", "source": "Translate Fortran to C#: interface draw_circle\n   module procedure draw_circle_sc, draw_circle_rgb\nend interface\n\nprivate :: plot, draw_circle_toch\n", "target": "        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        public static void DrawCircle(this GenericImage image, int centerX, int centerY, int radius, Color color)\n        {\n            int d = (5 - radius * 4) / 4;\n            int x = 0;\n            int y = radius;\n\n            do\n            {\n                \n                \n                if (centerX + x >= 0 && centerX + x <= image.Width - 1 && centerY + y >= 0 && centerY + y <= image.Height - 1) image[centerX + x, centerY + y] = color;\n                if (centerX + x >= 0 && centerX + x <= image.Width - 1 && centerY - y >= 0 && centerY - y <= image.Height - 1) image[centerX + x, centerY - y] = color;\n                if (centerX - x >= 0 && centerX - x <= image.Width - 1 && centerY + y >= 0 && centerY + y <= image.Height - 1) image[centerX - x, centerY + y] = color;\n                if (centerX - x >= 0 && centerX - x <= image.Width - 1 && centerY - y >= 0 && centerY - y <= image.Height - 1) image[centerX - x, centerY - y] = color;\n                if (centerX + y >= 0 && centerX + y <= image.Width - 1 && centerY + x >= 0 && centerY + x <= image.Height - 1) image[centerX + y, centerY + x] = color;\n                if (centerX + y >= 0 && centerX + y <= image.Width - 1 && centerY - x >= 0 && centerY - x <= image.Height - 1) image[centerX + y, centerY - x] = color;\n                if (centerX - y >= 0 && centerX - y <= image.Width - 1 && centerY + x >= 0 && centerY + x <= image.Height - 1) image[centerX - y, centerY + x] = color;\n                if (centerX - y >= 0 && centerX - y <= image.Width - 1 && centerY - x >= 0 && centerY - x <= image.Height - 1) image[centerX - y, centerY - x] = color;\n                if (d < 0)\n                {\n                    d += 2 * x + 1;\n                }\n                else\n                {\n                    d += 2 * (x - y) + 1;\n                    y--;\n                }\n                x++;\n            } while (x <= y);\n        }\n"}
{"id": 157021, "name": "Bitmap_Midpoint circle algorithm", "source": "Translate Fortran to Java: interface draw_circle\n   module procedure draw_circle_sc, draw_circle_rgb\nend interface\n\nprivate :: plot, draw_circle_toch\n", "target": "import java.awt.Color;\n\npublic class MidPointCircle {\n\tprivate BasicBitmapStorage image;\n\n\tpublic MidPointCircle(final int imageWidth, final int imageHeight) {\n\t\tthis.image = new BasicBitmapStorage(imageWidth, imageHeight);\n\t}\n\n\tprivate void drawCircle(final int centerX, final int centerY, final int radius) {\n\t\tint d = (5 - radius * 4)/4;\n\t\tint x = 0;\n\t\tint y = radius;\n\t\tColor circleColor = Color.white;\n\n\t\tdo {\n\t\t\timage.setPixel(centerX + x, centerY + y, circleColor);\n\t\t\timage.setPixel(centerX + x, centerY - y, circleColor);\n\t\t\timage.setPixel(centerX - x, centerY + y, circleColor);\n\t\t\timage.setPixel(centerX - x, centerY - y, circleColor);\n\t\t\timage.setPixel(centerX + y, centerY + x, circleColor);\n\t\t\timage.setPixel(centerX + y, centerY - x, circleColor);\n\t\t\timage.setPixel(centerX - y, centerY + x, circleColor);\n\t\t\timage.setPixel(centerX - y, centerY - x, circleColor);\n\t\t\tif (d < 0) {\n\t\t\t\td += 2 * x + 1;\n\t\t\t} else {\n\t\t\t\td += 2 * (x - y) + 1;\n\t\t\t\ty--;\n\t\t\t}\n\t\t\tx++;\n\t\t} while (x <= y);\n\n\t}\n}\n"}
{"id": 157022, "name": "Bitmap_Midpoint circle algorithm", "source": "Translate Fortran to Python: interface draw_circle\n   module procedure draw_circle_sc, draw_circle_rgb\nend interface\n\nprivate :: plot, draw_circle_toch\n", "target": "def circle(self, x0, y0, radius, colour=black):\n    f = 1 - radius\n    ddf_x = 1\n    ddf_y = -2 * radius\n    x = 0\n    y = radius\n    self.set(x0, y0 + radius, colour)\n    self.set(x0, y0 - radius, colour)\n    self.set(x0 + radius, y0, colour)\n    self.set(x0 - radius, y0, colour)\n\n    while x < y:\n        if f >= 0: \n            y -= 1\n            ddf_y += 2\n            f += ddf_y\n        x += 1\n        ddf_x += 2\n        f += ddf_x    \n        self.set(x0 + x, y0 + y, colour)\n        self.set(x0 - x, y0 + y, colour)\n        self.set(x0 + x, y0 - y, colour)\n        self.set(x0 - x, y0 - y, colour)\n        self.set(x0 + y, y0 + x, colour)\n        self.set(x0 - y, y0 + x, colour)\n        self.set(x0 + y, y0 - x, colour)\n        self.set(x0 - y, y0 - x, colour)\nBitmap.circle = circle\n\nbitmap = Bitmap(25,25)\nbitmap.circle(x0=12, y0=12, radius=12)\nbitmap.chardisplay()\n\n\n"}
{"id": 157169, "name": "Permutations", "source": "Translate Fortran to C#: program permutations\n\n  implicit none\n  integer, parameter :: value_min = 1\n  integer, parameter :: value_max = 3\n  integer, parameter :: position_min = value_min\n  integer, parameter :: position_max = value_max\n  integer, dimension (position_min : position_max) :: permutation\n\n  call generate (position_min)\n\ncontains\n\n  recursive subroutine generate (position)\n\n    implicit none\n    integer, intent (in) :: position\n    integer :: value\n\n    if (position > position_max) then\n      write (*, *) permutation\n    else\n      do value = value_min, value_max\n        if (.not. any (permutation (: position - 1) == value)) then\n          permutation (position) = value\n          call generate (position + 1)\n        end if\n      end do\n    end if\n\n  end subroutine generate\n\nend program permutations\n", "target": "public static class Extension\n{\n    public static IEnumerable<IEnumerable<T>> Permutations<T>(this IEnumerable<T> values) where T : IComparable<T>\n    {\n        if (values.Count() == 1)\n            return new[] { values };\n        return values.SelectMany(v => Permutations(values.Where(x => x.CompareTo(v) != 0)), (v, p) => p.Prepend(v));\n    }\n}\n"}
{"id": 157172, "name": "Permutations", "source": "Translate Fortran to Java: program permutations\n\n  implicit none\n  integer, parameter :: value_min = 1\n  integer, parameter :: value_max = 3\n  integer, parameter :: position_min = value_min\n  integer, parameter :: position_max = value_max\n  integer, dimension (position_min : position_max) :: permutation\n\n  call generate (position_min)\n\ncontains\n\n  recursive subroutine generate (position)\n\n    implicit none\n    integer, intent (in) :: position\n    integer :: value\n\n    if (position > position_max) then\n      write (*, *) permutation\n    else\n      do value = value_min, value_max\n        if (.not. any (permutation (: position - 1) == value)) then\n          permutation (position) = value\n          call generate (position + 1)\n        end if\n      end do\n    end if\n\n  end subroutine generate\n\nend program permutations\n", "target": "\nmodule Permutations\n    {\n    static Int[][] permut(Int items)\n        {\n        if (items <= 1)\n            {\n            \n            return items == 1 ? [[0]] : [];\n            }\n\n        \n        \n        Int[][] pattern = permut(items - 1);\n\n        \n        \n        Int[][] result = new Int[][];\n        for (Int prefix : 0 ..< items)\n            {\n            for (Int[] suffix : pattern)\n                {\n                result.add(new Int[items](i -> i == 0 ? prefix : (prefix + suffix[i-1] + 1) % items));\n                }\n            }\n        return result;\n        }\n\n    void run()\n        {\n        @Inject Console console;\n        console.print($\"permut(3) = {permut(3)}\");\n        }\n    }\n"}
{"id": 157173, "name": "Permutations", "source": "Translate Fortran to Python: program permutations\n\n  implicit none\n  integer, parameter :: value_min = 1\n  integer, parameter :: value_max = 3\n  integer, parameter :: position_min = value_min\n  integer, parameter :: position_max = value_max\n  integer, dimension (position_min : position_max) :: permutation\n\n  call generate (position_min)\n\ncontains\n\n  recursive subroutine generate (position)\n\n    implicit none\n    integer, intent (in) :: position\n    integer :: value\n\n    if (position > position_max) then\n      write (*, *) permutation\n    else\n      do value = value_min, value_max\n        if (.not. any (permutation (: position - 1) == value)) then\n          permutation (position) = value\n          call generate (position + 1)\n        end if\n      end do\n    end if\n\n  end subroutine generate\n\nend program permutations\n", "target": "import itertools\nfor values in itertools.permutations([1,2,3]):\n    print (values)\n"}
{"id": 157394, "name": "Proper divisors", "source": "Translate Fortran to C#:  \n      function icntprop(num  )\n      icnt=0\n      do i=1 , num-1\n          if (mod(num , i)  .eq. 0)  then\n          icnt = icnt + 1\n          if (num .lt. 11) print *,'    ',i\n          end if\n          end do\n      icntprop =  icnt\n      end function\n \n      limit = 20000\n      maxcnt = 0\n      print *,'N   divisors'\n      do j=1,limit,1\n      if (j .lt. 11) print *,j\n      icnt = icntprop(j)\n \n      if (icnt .gt. maxcnt) then\n      maxcnt = icnt\n      maxj = j\n      end if\n \n      end do\n \n      print *,' '\n      print *,' from 1 to ',limit\n      print *,maxj,' has max proper divisors: ',maxcnt\n      end\n", "target": "namespace RosettaCode.ProperDivisors\n{\n    using System;\n    using System.Collections.Generic;\n    using System.Linq;\n\n    internal static class Program\n    {\n        private static IEnumerable<int> ProperDivisors(int number)\n        {\n            return\n                Enumerable.Range(1, number / 2)\n                    .Where(divisor => number % divisor == 0);\n        }\n\n        private static void Main()\n        {\n            foreach (var number in Enumerable.Range(1, 10))\n            {\n                Console.WriteLine(\"{0}: {{{1}}}\", number,\n                    string.Join(\", \", ProperDivisors(number)));\n            }\n\n            var record = Enumerable.Range(1, 20000).Select(number => new\n            {\n                Number = number,\n                Count = ProperDivisors(number).Count()\n            }).OrderByDescending(currentRecord => currentRecord.Count).First();\n            Console.WriteLine(\"{0}: {1}\", record.Number, record.Count);\n        }\n    }\n}\n"}
{"id": 157397, "name": "Proper divisors", "source": "Translate Fortran to Java:  \n      function icntprop(num  )\n      icnt=0\n      do i=1 , num-1\n          if (mod(num , i)  .eq. 0)  then\n          icnt = icnt + 1\n          if (num .lt. 11) print *,'    ',i\n          end if\n          end do\n      icntprop =  icnt\n      end function\n \n      limit = 20000\n      maxcnt = 0\n      print *,'N   divisors'\n      do j=1,limit,1\n      if (j .lt. 11) print *,j\n      icnt = icntprop(j)\n \n      if (icnt .gt. maxcnt) then\n      maxcnt = icnt\n      maxj = j\n      end if\n \n      end do\n \n      print *,' '\n      print *,' from 1 to ',limit\n      print *,maxj,' has max proper divisors: ',maxcnt\n      end\n", "target": "import java.util.Collections;\nimport java.util.LinkedList;\nimport java.util.List;\n\npublic class Proper{\n    public static List<Integer> properDivs(int n){\n        List<Integer> divs = new LinkedList<Integer>();\n        if(n == 1) return divs;\n        divs.add(1);\n        for(int x = 2; x < n; x++){\n            if(n % x == 0) divs.add(x);\n        }\n        \n        Collections.sort(divs);\n        \n        return divs;\n    }\n    \n    public static void main(String[] args){\n        for(int x = 1; x <= 10; x++){\n            System.out.println(x + \": \" + properDivs(x));\n        }\n        \n        int x = 0, count = 0;\n        for(int n = 1; n <= 20000; n++){\n            if(properDivs(n).size() > count){\n                x = n;\n                count = properDivs(n).size();\n            }\n        }\n        System.out.println(x + \": \" + count);\n    }\n}\n"}
{"id": 157398, "name": "Proper divisors", "source": "Translate Fortran to Python:  \n      function icntprop(num  )\n      icnt=0\n      do i=1 , num-1\n          if (mod(num , i)  .eq. 0)  then\n          icnt = icnt + 1\n          if (num .lt. 11) print *,'    ',i\n          end if\n          end do\n      icntprop =  icnt\n      end function\n \n      limit = 20000\n      maxcnt = 0\n      print *,'N   divisors'\n      do j=1,limit,1\n      if (j .lt. 11) print *,j\n      icnt = icntprop(j)\n \n      if (icnt .gt. maxcnt) then\n      maxcnt = icnt\n      maxj = j\n      end if\n \n      end do\n \n      print *,' '\n      print *,' from 1 to ',limit\n      print *,maxj,' has max proper divisors: ',maxcnt\n      end\n", "target": ">>> def proper_divs2(n):\n...     return {x for x in range(1, (n + 1) // 2 + 1) if n % x == 0 and n != x}\n... \n>>> [proper_divs2(n) for n in range(1, 11)]\n[set(), {1}, {1}, {1, 2}, {1}, {1, 2, 3}, {1}, {1, 2, 4}, {1, 3}, {1, 2, 5}]\n>>> \n>>> n, length = max(((n, len(proper_divs2(n))) for n in range(1, 20001)), key=lambda pd: pd[1])\n>>> n\n15120\n>>> length\n79\n>>>\n"}
{"id": 157579, "name": "Define a primitive data type", "source": "Translate Fortran to C#: module Bounded\n  implicit none\n\n  type BoundedInteger\n     integer, private :: v         \n     integer, private :: from, to  \n     logical, private :: critical\n  end type BoundedInteger\n\n  interface assignment(=)\n     module procedure bounded_assign_bb, bounded_assign_bi \n                    \n  end interface\n\n  interface operator(+)\n     module procedure bounded_add_bbb \n                    \n                    \n                    \n  end interface\n\n  private :: bounded_assign_bb, bounded_assign_bi, &\n             bounded_add_bbb\n\ncontains\n\n  subroutine set_bound(bi, lower, upper, critical, value)\n    type(BoundedInteger), intent(out) :: bi\n    integer, intent(in) :: lower, upper\n    integer, intent(in), optional :: value\n    logical, intent(in), optional :: critical\n\n    bi%from = min(lower, upper)\n    bi%to = max(lower, upper)\n    if ( present(critical) ) then\n       bi%critical = critical\n    else\n       bi%critical = .false.\n    end if\n    if ( present(value) ) then\n       bi = value\n    end if\n  end subroutine set_bound\n\n  subroutine bounded_assign_bb(a, b)\n    type(BoundedInteger), intent(out) :: a\n    type(BoundedInteger), intent(in)  :: b\n\n    call bounded_assign_bi(a, b%v)\n\n  end subroutine bounded_assign_bb\n\n\n  subroutine bounded_assign_bi(a, b)\n    type(BoundedInteger), intent(out) :: a\n    integer,              intent(in)  :: b\n\n    if ( (a%from <= b) .and. (a%to >= b) ) then\n       a%v = b\n    else\n       write(0,*) \"BoundedInteger: out of bound assignment\"\n       if ( a%critical ) then\n          stop \n       else\n          if ( b < a%from ) then\n             a%v = a%from\n          else\n             a%v = a%to\n          end if\n          write(0,\"(A,' (',I0, ')')\") \"BoundedInteger: set to nearest bound\", a%v\n       end if\n    end if\n  end subroutine bounded_assign_bi\n\n\n  function bounded_add_bbb(a, b) result(c)\n    type(BoundedInteger) :: c\n    type(BoundedInteger), intent(in) :: a, b\n\n    integer :: t\n\n    c%from = max(a%from, b%from)\n    c%to   = min(a%to,   b%to)\n    t = a%v + b%v\n    if ( c%from <= t .and. c%to >= t ) then\n       c%v = t\n    else\n       write(0,*) \"BoundedInteger: out of bound sum\"\n       if ( a%critical .or. b%critical ) then\n          stop\n       else\n          if ( t < c%from ) then\n             c%v = c%from\n          else\n             c%v = c%to\n          end if\n          write(0,\"(A,' (',I0,')')\") \"BoundedInteger: set to nearest bound\", c%v\n       end if\n    end if\n  end function bounded_add_bbb\n\nend module Bounded\n", "target": "using System;\nusing System.Globalization;\n\nstruct LimitedInt : IComparable, IComparable<LimitedInt>, IConvertible, IEquatable<LimitedInt>, IFormattable\n{\n    const int MIN_VALUE = 1;\n    const int MAX_VALUE = 10;\n\n    public static readonly LimitedInt MinValue = new LimitedInt(MIN_VALUE);\n    public static readonly LimitedInt MaxValue = new LimitedInt(MAX_VALUE);\n\n    static bool IsValidValue(int value) => value >= MIN_VALUE && value <= MAX_VALUE;\n\n    readonly int _value;\n    public int Value => this._value == 0 ? MIN_VALUE : this._value; \n\n    public LimitedInt(int value)\n    {\n        if (!IsValidValue(value))\n            throw new ArgumentOutOfRangeException(nameof(value), value, $\"Value must be between {MIN_VALUE} and {MAX_VALUE}.\");\n        this._value = value;\n    }\n\n    #region IComparable\n    public int CompareTo(object obj)\n    {\n        if (obj is LimitedInt l) return this.Value.CompareTo(l);\n        throw new ArgumentException(\"Object must be of type \" + nameof(LimitedInt), nameof(obj));\n    }\n    #endregion\n\n    #region IComparable<LimitedInt>\n    public int CompareTo(LimitedInt other) => this.Value.CompareTo(other.Value);\n    #endregion\n\n    #region IConvertible\n    public TypeCode GetTypeCode() => this.Value.GetTypeCode();\n    bool IConvertible.ToBoolean(IFormatProvider provider) => ((IConvertible)this.Value).ToBoolean(provider);\n    byte IConvertible.ToByte(IFormatProvider provider) => ((IConvertible)this.Value).ToByte(provider);\n    char IConvertible.ToChar(IFormatProvider provider) => ((IConvertible)this.Value).ToChar(provider);\n    DateTime IConvertible.ToDateTime(IFormatProvider provider) => ((IConvertible)this.Value).ToDateTime(provider);\n    decimal IConvertible.ToDecimal(IFormatProvider provider) => ((IConvertible)this.Value).ToDecimal(provider);\n    double IConvertible.ToDouble(IFormatProvider provider) => ((IConvertible)this.Value).ToDouble(provider);\n    short IConvertible.ToInt16(IFormatProvider provider) => ((IConvertible)this.Value).ToInt16(provider);\n    int IConvertible.ToInt32(IFormatProvider provider) => ((IConvertible)this.Value).ToInt32(provider);\n    long IConvertible.ToInt64(IFormatProvider provider) => ((IConvertible)this.Value).ToInt64(provider);\n    sbyte IConvertible.ToSByte(IFormatProvider provider) => ((IConvertible)this.Value).ToSByte(provider);\n    float IConvertible.ToSingle(IFormatProvider provider) => ((IConvertible)this.Value).ToSingle(provider);\n    string IConvertible.ToString(IFormatProvider provider) => this.Value.ToString(provider);\n    object IConvertible.ToType(Type conversionType, IFormatProvider provider) => ((IConvertible)this.Value).ToType(conversionType, provider);\n    ushort IConvertible.ToUInt16(IFormatProvider provider) => ((IConvertible)this.Value).ToUInt16(provider);\n    uint IConvertible.ToUInt32(IFormatProvider provider) => ((IConvertible)this.Value).ToUInt32(provider);\n    ulong IConvertible.ToUInt64(IFormatProvider provider) => ((IConvertible)this.Value).ToUInt64(provider);\n    #endregion\n\n    #region IEquatable<LimitedInt>\n    public bool Equals(LimitedInt other) => this == other;\n    #endregion\n\n    #region IFormattable\n    public string ToString(string format, IFormatProvider formatProvider) => this.Value.ToString(format, formatProvider);\n    #endregion\n\n    #region operators\n    public static bool operator ==(LimitedInt left, LimitedInt right) => left.Value == right.Value;\n    public static bool operator !=(LimitedInt left, LimitedInt right) => left.Value != right.Value;\n    public static bool operator <(LimitedInt left, LimitedInt right) => left.Value < right.Value;\n    public static bool operator >(LimitedInt left, LimitedInt right) => left.Value > right.Value;\n    public static bool operator <=(LimitedInt left, LimitedInt right) => left.Value <= right.Value;\n    public static bool operator >=(LimitedInt left, LimitedInt right) => left.Value >= right.Value;\n\n    public static LimitedInt operator ++(LimitedInt left) => (LimitedInt)(left.Value + 1);\n    public static LimitedInt operator --(LimitedInt left) => (LimitedInt)(left.Value - 1);\n\n    public static LimitedInt operator +(LimitedInt left, LimitedInt right) => (LimitedInt)(left.Value + right.Value);\n    public static LimitedInt operator -(LimitedInt left, LimitedInt right) => (LimitedInt)(left.Value - right.Value);\n    public static LimitedInt operator *(LimitedInt left, LimitedInt right) => (LimitedInt)(left.Value * right.Value);\n    public static LimitedInt operator /(LimitedInt left, LimitedInt right) => (LimitedInt)(left.Value / right.Value);\n    public static LimitedInt operator %(LimitedInt left, LimitedInt right) => (LimitedInt)(left.Value % right.Value);\n\n    public static LimitedInt operator &(LimitedInt left, LimitedInt right) => (LimitedInt)(left.Value & right.Value);\n    public static LimitedInt operator |(LimitedInt left, LimitedInt right) => (LimitedInt)(left.Value | right.Value);\n    public static LimitedInt operator ^(LimitedInt left, LimitedInt right) => (LimitedInt)(left.Value ^ right.Value);\n    public static LimitedInt operator ~(LimitedInt left) => (LimitedInt)~left.Value;\n\n    public static LimitedInt operator >>(LimitedInt left, int right) => (LimitedInt)(left.Value >> right);\n    public static LimitedInt operator <<(LimitedInt left, int right) => (LimitedInt)(left.Value << right);\n\n    public static implicit operator int(LimitedInt value) => value.Value;\n    public static explicit operator LimitedInt(int value)\n    {\n        if (!IsValidValue(value)) throw new OverflowException();\n        return new LimitedInt(value);\n    }\n    #endregion\n\n    public bool TryFormat(Span<char> destination, out int charsWritten, ReadOnlySpan<char> format = default, IFormatProvider provider = null)\n        => this.Value.TryFormat(destination, out charsWritten, format, provider);\n\n    public override int GetHashCode() => this.Value.GetHashCode();\n    public override bool Equals(object obj) => obj is LimitedInt l && this.Equals(l);\n    public override string ToString() => this.Value.ToString();\n\n    #region static methods\n    public static bool TryParse(ReadOnlySpan<char> s, out int result) => int.TryParse(s, out result);\n    public static bool TryParse(ReadOnlySpan<char> s, NumberStyles style, IFormatProvider provider, out int result) => int.TryParse(s, style, provider, out result);\n    public static int Parse(string s, IFormatProvider provider) => int.Parse(s, provider);\n    public static int Parse(string s, NumberStyles style, IFormatProvider provider) => int.Parse(s, style, provider);\n    public static bool TryParse(string s, NumberStyles style, IFormatProvider provider, ref int result) => int.TryParse(s, style, provider, out result);\n    public static int Parse(string s) => int.Parse(s);\n    public static int Parse(string s, NumberStyles style) => int.Parse(s, style);\n    public static int Parse(ReadOnlySpan<char> s, NumberStyles style = NumberStyles.Integer, IFormatProvider provider = null) => int.Parse(s, style, provider);\n    public static bool TryParse(string s, ref int result) => int.TryParse(s, out result);\n    #endregion\n}\n"}
{"id": 157581, "name": "Define a primitive data type", "source": "Translate Fortran to Java: module Bounded\n  implicit none\n\n  type BoundedInteger\n     integer, private :: v         \n     integer, private :: from, to  \n     logical, private :: critical\n  end type BoundedInteger\n\n  interface assignment(=)\n     module procedure bounded_assign_bb, bounded_assign_bi \n                    \n  end interface\n\n  interface operator(+)\n     module procedure bounded_add_bbb \n                    \n                    \n                    \n  end interface\n\n  private :: bounded_assign_bb, bounded_assign_bi, &\n             bounded_add_bbb\n\ncontains\n\n  subroutine set_bound(bi, lower, upper, critical, value)\n    type(BoundedInteger), intent(out) :: bi\n    integer, intent(in) :: lower, upper\n    integer, intent(in), optional :: value\n    logical, intent(in), optional :: critical\n\n    bi%from = min(lower, upper)\n    bi%to = max(lower, upper)\n    if ( present(critical) ) then\n       bi%critical = critical\n    else\n       bi%critical = .false.\n    end if\n    if ( present(value) ) then\n       bi = value\n    end if\n  end subroutine set_bound\n\n  subroutine bounded_assign_bb(a, b)\n    type(BoundedInteger), intent(out) :: a\n    type(BoundedInteger), intent(in)  :: b\n\n    call bounded_assign_bi(a, b%v)\n\n  end subroutine bounded_assign_bb\n\n\n  subroutine bounded_assign_bi(a, b)\n    type(BoundedInteger), intent(out) :: a\n    integer,              intent(in)  :: b\n\n    if ( (a%from <= b) .and. (a%to >= b) ) then\n       a%v = b\n    else\n       write(0,*) \"BoundedInteger: out of bound assignment\"\n       if ( a%critical ) then\n          stop \n       else\n          if ( b < a%from ) then\n             a%v = a%from\n          else\n             a%v = a%to\n          end if\n          write(0,\"(A,' (',I0, ')')\") \"BoundedInteger: set to nearest bound\", a%v\n       end if\n    end if\n  end subroutine bounded_assign_bi\n\n\n  function bounded_add_bbb(a, b) result(c)\n    type(BoundedInteger) :: c\n    type(BoundedInteger), intent(in) :: a, b\n\n    integer :: t\n\n    c%from = max(a%from, b%from)\n    c%to   = min(a%to,   b%to)\n    t = a%v + b%v\n    if ( c%from <= t .and. c%to >= t ) then\n       c%v = t\n    else\n       write(0,*) \"BoundedInteger: out of bound sum\"\n       if ( a%critical .or. b%critical ) then\n          stop\n       else\n          if ( t < c%from ) then\n             c%v = c%from\n          else\n             c%v = c%to\n          end if\n          write(0,\"(A,' (',I0,')')\") \"BoundedInteger: set to nearest bound\", c%v\n       end if\n    end if\n  end function bounded_add_bbb\n\nend module Bounded\n", "target": "class BoundedIntOutOfBoundsException extends Exception\n{\n  public BoundedIntOutOfBoundsException(int v, int l, int u) {\n    super(\"value \" + v + \" is out of bounds [\" + l + \",\" + u + \"]\");\n  }\n}\n\nclass BoundedInt {\n  private int value;\n  private int lower;\n  private int upper;\n\n  public BoundedInt(int l, int u) {\n    lower = Math.min(l, u);\n    upper = Math.max(l, u);\n  }\n\n  private boolean checkBounds(int v) {\n    return (v >= this.lower) && (v <= this.upper);\n  }\n\n  public void assign(BoundedInt i) throws BoundedIntOutOfBoundsException {{\n    assign(i.value()); \n  }\n\n  public void assign(int v) throws BoundedIntOutOfBoundsException {\n    if ( checkBounds(v) ) {\n      this.value = v;\n    } else {\n      throw new BoundedIntOutOfBoundsException(v, this.lower, this.upper);\n    }\n  }\n\n  public int add(BoundedInt i) throws BoundedIntOutOfBoundsException {\n    return add(i.value());\n  }\n\n  public int add(int i) throws BoundedIntOutOfBoundsException {\n    if ( checkBounds(this.value + i) ) {\n      this.value += i;\n    }  else {\n      throw new BoundedIntOutOfBoundsException(this.value + i, this.lower, this.upper);\n    }\n    return this.value;\n  }\n\n  public int value() {\n    return this.value;\n  }\n}\n\n\npublic class Bounded {\n  public static void main(String[] args) throws BoundedIntOutOfBoundsException {\n    BoundedInt a = new BoundedInt(1, 10);\n    BoundedInt b = new BoundedInt(1, 10);\n\n    a.assign(6);\n    try {\n      b.assign(12);\n    } catch (Exception e) {\n      System.out.println(e.getMessage());\n    }\n    b.assign(9);\n    try {\n      a.add(b.value());\n    } catch (Exception e) {\n      System.out.println(e.getMessage());\n    }\n  }\n}\n"}
{"id": 157582, "name": "Define a primitive data type", "source": "Translate Fortran to Python: module Bounded\n  implicit none\n\n  type BoundedInteger\n     integer, private :: v         \n     integer, private :: from, to  \n     logical, private :: critical\n  end type BoundedInteger\n\n  interface assignment(=)\n     module procedure bounded_assign_bb, bounded_assign_bi \n                    \n  end interface\n\n  interface operator(+)\n     module procedure bounded_add_bbb \n                    \n                    \n                    \n  end interface\n\n  private :: bounded_assign_bb, bounded_assign_bi, &\n             bounded_add_bbb\n\ncontains\n\n  subroutine set_bound(bi, lower, upper, critical, value)\n    type(BoundedInteger), intent(out) :: bi\n    integer, intent(in) :: lower, upper\n    integer, intent(in), optional :: value\n    logical, intent(in), optional :: critical\n\n    bi%from = min(lower, upper)\n    bi%to = max(lower, upper)\n    if ( present(critical) ) then\n       bi%critical = critical\n    else\n       bi%critical = .false.\n    end if\n    if ( present(value) ) then\n       bi = value\n    end if\n  end subroutine set_bound\n\n  subroutine bounded_assign_bb(a, b)\n    type(BoundedInteger), intent(out) :: a\n    type(BoundedInteger), intent(in)  :: b\n\n    call bounded_assign_bi(a, b%v)\n\n  end subroutine bounded_assign_bb\n\n\n  subroutine bounded_assign_bi(a, b)\n    type(BoundedInteger), intent(out) :: a\n    integer,              intent(in)  :: b\n\n    if ( (a%from <= b) .and. (a%to >= b) ) then\n       a%v = b\n    else\n       write(0,*) \"BoundedInteger: out of bound assignment\"\n       if ( a%critical ) then\n          stop \n       else\n          if ( b < a%from ) then\n             a%v = a%from\n          else\n             a%v = a%to\n          end if\n          write(0,\"(A,' (',I0, ')')\") \"BoundedInteger: set to nearest bound\", a%v\n       end if\n    end if\n  end subroutine bounded_assign_bi\n\n\n  function bounded_add_bbb(a, b) result(c)\n    type(BoundedInteger) :: c\n    type(BoundedInteger), intent(in) :: a, b\n\n    integer :: t\n\n    c%from = max(a%from, b%from)\n    c%to   = min(a%to,   b%to)\n    t = a%v + b%v\n    if ( c%from <= t .and. c%to >= t ) then\n       c%v = t\n    else\n       write(0,*) \"BoundedInteger: out of bound sum\"\n       if ( a%critical .or. b%critical ) then\n          stop\n       else\n          if ( t < c%from ) then\n             c%v = c%from\n          else\n             c%v = c%to\n          end if\n          write(0,\"(A,' (',I0,')')\") \"BoundedInteger: set to nearest bound\", c%v\n       end if\n    end if\n  end function bounded_add_bbb\n\nend module Bounded\n", "target": ">>> class num(int):\n    def __init__(self, b):\n        if 1 <= b <= 10:\n            return int.__init__(self+0)\n        else:\n            raise ValueError,\"Value %s should be >=0 and <= 10\" % b\n\n        \n>>> x = num(3)\n>>> x = num(11)\n\nTraceback (most recent call last):\n  File \"<pyshell\n    x = num(11)\n  File \"<pyshell\n    raise ValueError,\"Value %s should be >=0 and <= 10\" % b\nValueError: Value 11 should be >=0 and <= 10\n>>> x\n3\n>>> type(x)\n<class '__main__.num'>\n>>>\n"}
{"id": 157829, "name": "Multi-dimensional array", "source": "Translate Fortran to C#:       DIMENSION A(5,4,3,2)                 \n      X = 3*A(2,I,1,K)                     \n      A(1,2,3,4) = X + 1                   \n", "target": "var array = new int[,] { \n    { 1, 2, 3 },\n    { 4, 5, 6}\n}\n\narray[0, 0] = 999;\n\n\nvar array = new int[5, 4, 3, 2];\n"}
{"id": 157832, "name": "Multi-dimensional array", "source": "Translate Fortran to Java:       DIMENSION A(5,4,3,2)                 \n      X = 3*A(2,I,1,K)                     \n      A(1,2,3,4) = X + 1                   \n", "target": "public class MultiDimensionalArray {\n    public static void main(String[] args) {\n        \n        int m = 1;\n        int[][][][] a4 = new int[5][4][3][2];\n        for (int i = 0; i < a4.length; ++i) {\n            for (int j = 0; j < a4[0].length; ++j) {\n                for (int k = 0; k < a4[0][0].length; ++k) {\n                    for (int l = 0; l < a4[0][0][0].length; ++l) {\n                        a4[i][j][k][l] = m++;\n                    }\n                }\n            }\n        }\n\n        System.out.println(\"First element = \" + a4[0][0][0][0]);  \n        a4[0][0][0][0] = 121;                                     \n        System.out.println();\n\n        for (int i = 0; i < a4.length; ++i) {\n            for (int j = 0; j < a4[0].length; ++j) {\n                for (int k = 0; k < a4[0][0].length; ++k) {\n                    for (int l = 0; l < a4[0][0][0].length; ++l) {\n                        System.out.printf(\"%4d\", a4[i][j][k][l]);\n                    }\n                }\n            }\n        }\n    }\n}\n"}
{"id": 157833, "name": "Multi-dimensional array", "source": "Translate Fortran to Python:       DIMENSION A(5,4,3,2)                 \n      X = 3*A(2,I,1,K)                     \n      A(1,2,3,4) = X + 1                   \n", "target": ">>> from pprint import pprint as pp   \n>>> from itertools import product\n>>> \n>>> def dict_as_mdarray(dimensions=(2, 3), init=0.0):\n...     return {indices: init for indices in product(*(range(i) for i in dimensions))}\n... \n>>> \n>>> mdarray = dict_as_mdarray((2, 3, 4, 5))\n>>> pp(mdarray)\n{(0, 0, 0, 0): 0.0,\n (0, 0, 0, 1): 0.0,\n (0, 0, 0, 2): 0.0,\n (0, 0, 0, 3): 0.0,\n (0, 0, 0, 4): 0.0,\n (0, 0, 1, 0): 0.0,\n...\n (1, 2, 3, 0): 0.0,\n (1, 2, 3, 1): 0.0,\n (1, 2, 3, 2): 0.0,\n (1, 2, 3, 3): 0.0,\n (1, 2, 3, 4): 0.0}\n>>> mdarray[(0, 1, 2, 3)]\n0.0\n>>> mdarray[(0, 1, 2, 3)] = 6.78\n>>> mdarray[(0, 1, 2, 3)]\n6.78\n>>> mdarray[(0, 1, 2, 3)] = 5.4321\n>>> mdarray[(0, 1, 2, 3)]\n5.4321\n>>> pp(mdarray)\n{(0, 0, 0, 0): 0.0,\n (0, 0, 0, 1): 0.0,\n (0, 0, 0, 2): 0.0,\n...\n (0, 1, 2, 2): 0.0,\n (0, 1, 2, 3): 5.4321,\n (0, 1, 2, 4): 0.0,\n...\n (1, 2, 3, 3): 0.0,\n (1, 2, 3, 4): 0.0}\n>>>\n"}
{"id": 157951, "name": "Phrase reversals", "source": "Translate Fortran to C#:       DO WHILE (L1.LE.L .AND. ATXT(L1).LE.\" \")\n        L1 = L1 + 1\n      END DO\n", "target": "using System;\nusing System.Linq;\nnamespace ConsoleApplication\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            \n            \n            Func<string, string> reverse = s => new string(s.Reverse().ToArray());\n\n            string phrase = \"rosetta code phrase reversal\";\n            \n            Console.WriteLine(reverse(phrase));\n            \n            Console.WriteLine(string.Join(\" \", phrase.Split(' ').Select(word => reverse(word))));\n            \n            Console.WriteLine(string.Join(\" \", phrase.Split(' ').Reverse()));\n        }\n    }\n}\n"}
{"id": 157954, "name": "Phrase reversals", "source": "Translate Fortran to Java:       DO WHILE (L1.LE.L .AND. ATXT(L1).LE.\" \")\n        L1 = L1 + 1\n      END DO\n", "target": "import java.util.Arrays;\n\npublic class PhraseRev{\n\tprivate static String reverse(String x){\n\t\treturn new StringBuilder(x).reverse().toString();\n\t}\n\t\n\tprivate static <T> T[] reverse(T[] x){\n\t\tT[] rev = Arrays.copyOf(x, x.length);\n\t\tfor(int i = x.length - 1; i >= 0; i--){\n\t\t\trev[x.length - 1 - i] = x[i];\n\t\t}\n\t\treturn rev;\n\t}\n\t\n\tprivate static String join(String[] arr, String joinStr){\n\t\tStringBuilder joined = new StringBuilder();\n\t\tfor(int i = 0; i < arr.length; i++){\n\t\t\tjoined.append(arr[i]);\n\t\t\tif(i < arr.length - 1) joined.append(joinStr);\n\t\t}\n\t\treturn joined.toString();\n\t}\n\t\n\tpublic static void main(String[] args){\n\t\tString str = \"rosetta code phrase reversal\";\n\t\t\n\t\tSystem.out.println(\"Straight-up reversed: \" + reverse(str));\n\t\tString[] words = str.split(\" \");\n\t\tfor(int i = 0; i < words.length; i++){\n\t\t\twords[i] = reverse(words[i]);\n\t\t}\n\t\tSystem.out.println(\"Reversed words: \" + join(words, \" \"));\n\t\tSystem.out.println(\"Reversed word order: \" + join(reverse(str.split(\" \")), \" \"));\n\t}\n}\n"}
{"id": 157955, "name": "Phrase reversals", "source": "Translate Fortran to Python:       DO WHILE (L1.LE.L .AND. ATXT(L1).LE.\" \")\n        L1 = L1 + 1\n      END DO\n", "target": ">>> phrase = \"rosetta code phrase reversal\"\n>>> phrase[::-1]\t\t\t\t\t  \n'lasrever esarhp edoc attesor'\n>>> ' '.join(word[::-1] for word in phrase.split())\t  \n'attesor edoc esarhp lasrever'\n>>> ' '.join(phrase.split()[::-1])\t                  \n'reversal phrase code rosetta'\n>>>\n"}
{"id": 158271, "name": "Old lady swallowed a fly", "source": "Translate Fortran to C#: program fly\n  \n  implicit none\n\n  character(len=52), dimension(0:8,2) :: line\n  integer :: i,j\n  \n  line(1,1) = 'fly'\n  line(2,1) = 'spider'\n  line(3,1) = 'bird'\n  line(4,1) = 'cat'\n  line(5,1) = 'dog'\n  line(6,1) = 'goat'\n  line(7,1) = 'cow'\n  line(8,1) = 'horse'\n  line(0,2) = \"Perhaps she'll die.\"\n  line(1,2) = \"I don't know why she swallowed that fly.\"\n  line(2,2) = \"That wiggled and jiggled and tickled inside her.\" \n  line(3,2) = \"How absurd to swallow a bird.\"                      \n  line(4,2) = \"Imagine that. She swallowed a cat.\"                  \n  line(5,2) = \"What a hog to swallow a dog.\"                        \n  line(6,2) = \"She just opened her throat and swallowed that goat.\" \n  line(7,2) = \"I don't know how she swallowed that cow.\"            \n  line(8,2) = \"She's dead of course.\"                                  \n\n  \n  verses:do i = 1,8\n     write(*,*) 'There was an old lady who swallowed a '//trim(line(i,1))//\".\"\n     write(*,*) trim(line(i,2))\n     \n     swallowed:do j = i,2,-1\n        write(*,*) \"She swallowed the \"//trim(line(j,1))//\" to catch the \"//trim(line(j-1,1))//\",\"\n     end do swallowed\n     write(*,*)  trim(line(0,2))\n     write(*,*)\n  end do verses\n     \nend program fly\n", "target": "using System;\n\nnamespace OldLady\n{\n    internal class Program\n    {\n        private const string reason = \"She swallowed the {0} to catch the {1}\";\n        private static readonly string[] creatures = {\"fly\", \"spider\", \"bird\", \"cat\", \"dog\", \"goat\", \"cow\", \"horse\"};\n\n        private static readonly string[] comments =\n        {\n            \"I don't know why she swallowed that fly.\\nPerhaps she'll die\\n\",\n            \"That wiggled and jiggled and tickled inside her\",\n            \"How absurd, to swallow a bird\",\n            \"Imagine that. She swallowed a cat\",\n            \"What a hog to swallow a dog\",\n            \"She just opened her throat and swallowed that goat\",\n            \"I don't know how she swallowed that cow\",\n            \"She's dead of course\"\n        };\n\n        private static void Main()\n        {\n            int max = creatures.Length;\n            for (int i = 0; i < max; i++)\n            {\n                Console.WriteLine(\"There was an old lady who swallowed a {0}\", creatures[i]);\n                Console.WriteLine(comments[i]);\n                for (int j = i; j > 0 && i < max - 1; j--)\n                {\n                    Console.WriteLine(reason, creatures[j], creatures[j - 1]);\n                    if (j == 1)\n                    {\n                        Console.WriteLine(comments[j - 1]);\n                    }\n                }\n            }\n            Console.Read();\n        }\n    }\n}\n"}
{"id": 158274, "name": "Old lady swallowed a fly", "source": "Translate Fortran to Java: program fly\n  \n  implicit none\n\n  character(len=52), dimension(0:8,2) :: line\n  integer :: i,j\n  \n  line(1,1) = 'fly'\n  line(2,1) = 'spider'\n  line(3,1) = 'bird'\n  line(4,1) = 'cat'\n  line(5,1) = 'dog'\n  line(6,1) = 'goat'\n  line(7,1) = 'cow'\n  line(8,1) = 'horse'\n  line(0,2) = \"Perhaps she'll die.\"\n  line(1,2) = \"I don't know why she swallowed that fly.\"\n  line(2,2) = \"That wiggled and jiggled and tickled inside her.\" \n  line(3,2) = \"How absurd to swallow a bird.\"                      \n  line(4,2) = \"Imagine that. She swallowed a cat.\"                  \n  line(5,2) = \"What a hog to swallow a dog.\"                        \n  line(6,2) = \"She just opened her throat and swallowed that goat.\" \n  line(7,2) = \"I don't know how she swallowed that cow.\"            \n  line(8,2) = \"She's dead of course.\"                                  \n\n  \n  verses:do i = 1,8\n     write(*,*) 'There was an old lady who swallowed a '//trim(line(i,1))//\".\"\n     write(*,*) trim(line(i,2))\n     \n     swallowed:do j = i,2,-1\n        write(*,*) \"She swallowed the \"//trim(line(j,1))//\" to catch the \"//trim(line(j-1,1))//\",\"\n     end do swallowed\n     write(*,*)  trim(line(0,2))\n     write(*,*)\n  end do verses\n     \nend program fly\n", "target": "public class OldLadySwallowedAFly {\n\n    final static String[] data = {\n        \"_ha _c _e _p,/Quite absurd_f_p;_`cat,/Fancy that_fcat;_j`dog,/What a hog\"\n        + \"_fdog;_l`pig,/Her mouth_qso big_fpig;_d_r,/She just opened her throat_f_\"\n        + \"r;_icow,/_mhow she_ga cow;_k_o,/It_qrather wonky_f_o;_a_o_bcow,_khorse..\"\n        + \"./She's dead, of course!/\", \"_a_p_b_e \", \"/S_t \", \" to catch the \", \"fly,/Bu\"\n        + \"t _mwhy s_t fly,/Perhaps she'll die!\n        + \"t wr_nj_ntickled inside her;_aspider_b_c\", \", to_s a \", \"_sed \", \"There_qan\"\n        + \" old lady who_g\", \"_a_r_bpig,_d\", \"_acat_b_p,_\", \"_acow_b_r,_i\", \"_adog_bcat\"\n        + \",_j\", \"I don't know \", \"iggled and \", \"donkey\", \"bird\", \" was \", \"goat\", \" swal\"\n        + \"low\", \"he_gthe\"};\n\n    static boolean oldLady(String part, boolean s) {\n        for (char c : part.toCharArray()) {\n            if (s)\n                s = oldLady(data[c - '_'], false);\n            else if (c == '_')\n                s = true;\n            else\n                System.out.print(c == '/' ? '\\n' : c);\n        }\n        return s;\n    }\n\n    public static void main(String[] args) {\n        oldLady(data[0], false);\n    }\n}\n"}
{"id": 158275, "name": "Old lady swallowed a fly", "source": "Translate Fortran to Python: program fly\n  \n  implicit none\n\n  character(len=52), dimension(0:8,2) :: line\n  integer :: i,j\n  \n  line(1,1) = 'fly'\n  line(2,1) = 'spider'\n  line(3,1) = 'bird'\n  line(4,1) = 'cat'\n  line(5,1) = 'dog'\n  line(6,1) = 'goat'\n  line(7,1) = 'cow'\n  line(8,1) = 'horse'\n  line(0,2) = \"Perhaps she'll die.\"\n  line(1,2) = \"I don't know why she swallowed that fly.\"\n  line(2,2) = \"That wiggled and jiggled and tickled inside her.\" \n  line(3,2) = \"How absurd to swallow a bird.\"                      \n  line(4,2) = \"Imagine that. She swallowed a cat.\"                  \n  line(5,2) = \"What a hog to swallow a dog.\"                        \n  line(6,2) = \"She just opened her throat and swallowed that goat.\" \n  line(7,2) = \"I don't know how she swallowed that cow.\"            \n  line(8,2) = \"She's dead of course.\"                                  \n\n  \n  verses:do i = 1,8\n     write(*,*) 'There was an old lady who swallowed a '//trim(line(i,1))//\".\"\n     write(*,*) trim(line(i,2))\n     \n     swallowed:do j = i,2,-1\n        write(*,*) \"She swallowed the \"//trim(line(j,1))//\" to catch the \"//trim(line(j-1,1))//\",\"\n     end do swallowed\n     write(*,*)  trim(line(0,2))\n     write(*,*)\n  end do verses\n     \nend program fly\n", "target": "import zlib, base64\n\nb64 = b\nprint(zlib.decompress(base64.b64decode(b64)).decode(\"utf-8\", \"strict\"))\n"}
{"id": 159044, "name": "Semordnilap", "source": "Translate Fortran to C#: \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nprogram Semordnilap\n  implicit none\n  integer :: i, ios, words, swords\n  character(len=24), dimension(32768) :: dictionary, backword\n  real, dimension(5) :: harvest\n  \n  open(7,file='unixdict.txt')\n  do words = 1, 32768\n    read(7, '(a)', iostat = ios) dictionary(words)\n    if (ios .ne. 0) exit\n  enddo\n  close(7)\n  if (iachar(dictionary(words)(1:1)) .eq. 0) words = words-1\n  \n  call bs(dictionary, words)\n  \n  \n  \n  swords = 0\n  do i = 1, words\n    call reverse(dictionary(i), backword(swords+1))\n    if ((binary_search(dictionary, words, backword(swords+1))) &      \n      .and. (.not. binary_search(backword, swords, dictionary(i))) &  \n      .and. (dictionary(i) .ne. backword(swords+1))) then             \n      swords = swords + 1\n      call bs(backword, swords)\n    endif\n  enddo\n  call random_number(harvest)\n  call reverse('spalindromes', backword(swords+1))\n  write(6, *) '5 of ', swords, backword(swords+1)\n  write(6,'(5(a/))') (backword(1+int(harvest(i)*(swords-2))), i=1,5)\n\ncontains\n\n  subroutine reverse(inp, outp)\n    character(len=*), intent(in) :: inp\n    character(len=*), intent(inout) :: outp\n    integer :: k, L\n    L = len_trim(inp)\n    do k = 1, L\n      outp(L+1-k:L+1-k) = inp(k:k)\n    enddo\n    do k = L+1, len(outp)\n      outp(k:k) = ' '\n    enddo\n  end subroutine reverse\n\n  subroutine bs(a, n) \n    \n    character(len=*),dimension(*),intent(inout) :: a\n    integer, intent(in) :: n\n    integer :: i, j, k\n    logical :: done\n    character(len=1) :: t\n    do i=n-1, 1, -1\n      done = .true.\n      do j=1, i\n        if (a(j+1) .lt. a(j)) then\n          done = .false.\n          do k = 1, max(len_trim(a(j+1)), len_trim(a(j)))\n            t = a(j+1)(k:k)\n            a(j+1)(k:k) = a(j)(k:k)\n            a(j)(k:k) = t(1:1)\n          enddo\n        endif\n      enddo\n      if (done) return\n    enddo\n  end subroutine bs\n\n  logical function binary_search(source, n, target)\n    character(len=*),dimension(*),intent(in) :: source\n    character(len=*),intent(in) :: target\n    integer, intent(in) :: n\n    integer :: a,m,z\n    a = 1\n    z = n\n    do while (a .lt. z)\n      m = a + (z - a) / 2\n      if (target .lt. source(m)) then\n        z = m-1\n      else\n        if (m .eq. a) exit\n        a = m\n      endif\n    enddo\n    binary_search = (target .eq. source(a)) .or. (target .eq. source(z))\n  end function binary_search\n\nend program Semordnilap\n", "target": "using System;\nusing System.Net;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.IO;\n\npublic class Semordnilap\n{\n    public static void Main() {\n        var results = FindSemordnilaps(\"http:\n        Console.WriteLine(results.Count);\n        var random = new Random();\n        Console.WriteLine(\"5 random results:\");\n        foreach (string s in results.OrderBy(_ => random.Next()).Distinct().Take(5)) Console.WriteLine(s + \" \" + Reversed(s));\n    }\n    \n    private static IEnumerable<string> FindSemordnilaps(string url) {\n        var found = new HashSet<string>();\n        foreach (string line in GetLines(url)) {\n            string reversed = Reversed(line);\n            \n            if (line.CompareTo(reversed) != 0) {\n                if (found.Remove(reversed)) yield return reversed;\n                else found.Add(line);\n            }\n        }\n    }\n    \n    private static IEnumerable<string> GetLines(string url) {\n        WebRequest request = WebRequest.Create(url);\n        using (var reader = new StreamReader(request.GetResponse().GetResponseStream(), true)) {\n            while (!reader.EndOfStream) {\n                yield return reader.ReadLine();\n            }\n        }\n    }\n    \n    private static string Reversed(string value) => new string(value.Reverse().ToArray());\n}\n"}
{"id": 159047, "name": "Semordnilap", "source": "Translate Fortran to Java: \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nprogram Semordnilap\n  implicit none\n  integer :: i, ios, words, swords\n  character(len=24), dimension(32768) :: dictionary, backword\n  real, dimension(5) :: harvest\n  \n  open(7,file='unixdict.txt')\n  do words = 1, 32768\n    read(7, '(a)', iostat = ios) dictionary(words)\n    if (ios .ne. 0) exit\n  enddo\n  close(7)\n  if (iachar(dictionary(words)(1:1)) .eq. 0) words = words-1\n  \n  call bs(dictionary, words)\n  \n  \n  \n  swords = 0\n  do i = 1, words\n    call reverse(dictionary(i), backword(swords+1))\n    if ((binary_search(dictionary, words, backword(swords+1))) &      \n      .and. (.not. binary_search(backword, swords, dictionary(i))) &  \n      .and. (dictionary(i) .ne. backword(swords+1))) then             \n      swords = swords + 1\n      call bs(backword, swords)\n    endif\n  enddo\n  call random_number(harvest)\n  call reverse('spalindromes', backword(swords+1))\n  write(6, *) '5 of ', swords, backword(swords+1)\n  write(6,'(5(a/))') (backword(1+int(harvest(i)*(swords-2))), i=1,5)\n\ncontains\n\n  subroutine reverse(inp, outp)\n    character(len=*), intent(in) :: inp\n    character(len=*), intent(inout) :: outp\n    integer :: k, L\n    L = len_trim(inp)\n    do k = 1, L\n      outp(L+1-k:L+1-k) = inp(k:k)\n    enddo\n    do k = L+1, len(outp)\n      outp(k:k) = ' '\n    enddo\n  end subroutine reverse\n\n  subroutine bs(a, n) \n    \n    character(len=*),dimension(*),intent(inout) :: a\n    integer, intent(in) :: n\n    integer :: i, j, k\n    logical :: done\n    character(len=1) :: t\n    do i=n-1, 1, -1\n      done = .true.\n      do j=1, i\n        if (a(j+1) .lt. a(j)) then\n          done = .false.\n          do k = 1, max(len_trim(a(j+1)), len_trim(a(j)))\n            t = a(j+1)(k:k)\n            a(j+1)(k:k) = a(j)(k:k)\n            a(j)(k:k) = t(1:1)\n          enddo\n        endif\n      enddo\n      if (done) return\n    enddo\n  end subroutine bs\n\n  logical function binary_search(source, n, target)\n    character(len=*),dimension(*),intent(in) :: source\n    character(len=*),intent(in) :: target\n    integer, intent(in) :: n\n    integer :: a,m,z\n    a = 1\n    z = n\n    do while (a .lt. z)\n      m = a + (z - a) / 2\n      if (target .lt. source(m)) then\n        z = m-1\n      else\n        if (m .eq. a) exit\n        a = m\n      endif\n    enddo\n    binary_search = (target .eq. source(a)) .or. (target .eq. source(z))\n  end function binary_search\n\nend program Semordnilap\n", "target": "import java.nio.file.*;\nimport java.util.*;\n\npublic class Semordnilap {\n\n    public static void main(String[] args) throws Exception {\n        List<String> lst = Files.readAllLines(Paths.get(\"unixdict.txt\"));\n        Set<String> seen = new HashSet<>();\n        int count = 0;\n        for (String w : lst) {\n            w = w.toLowerCase();\n            String r = new StringBuilder(w).reverse().toString();\n            if (seen.contains(r)) {\n                if (count++ < 5)\n                    System.out.printf(\"%-10s\u00a0%-10s\\n\", w, r);\n            } else seen.add(w);\n        }\n        System.out.println(\"\\nSemordnilap pairs found: \" + count);\n    }\n}\n"}
{"id": 159048, "name": "Semordnilap", "source": "Translate Fortran to Python: \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nprogram Semordnilap\n  implicit none\n  integer :: i, ios, words, swords\n  character(len=24), dimension(32768) :: dictionary, backword\n  real, dimension(5) :: harvest\n  \n  open(7,file='unixdict.txt')\n  do words = 1, 32768\n    read(7, '(a)', iostat = ios) dictionary(words)\n    if (ios .ne. 0) exit\n  enddo\n  close(7)\n  if (iachar(dictionary(words)(1:1)) .eq. 0) words = words-1\n  \n  call bs(dictionary, words)\n  \n  \n  \n  swords = 0\n  do i = 1, words\n    call reverse(dictionary(i), backword(swords+1))\n    if ((binary_search(dictionary, words, backword(swords+1))) &      \n      .and. (.not. binary_search(backword, swords, dictionary(i))) &  \n      .and. (dictionary(i) .ne. backword(swords+1))) then             \n      swords = swords + 1\n      call bs(backword, swords)\n    endif\n  enddo\n  call random_number(harvest)\n  call reverse('spalindromes', backword(swords+1))\n  write(6, *) '5 of ', swords, backword(swords+1)\n  write(6,'(5(a/))') (backword(1+int(harvest(i)*(swords-2))), i=1,5)\n\ncontains\n\n  subroutine reverse(inp, outp)\n    character(len=*), intent(in) :: inp\n    character(len=*), intent(inout) :: outp\n    integer :: k, L\n    L = len_trim(inp)\n    do k = 1, L\n      outp(L+1-k:L+1-k) = inp(k:k)\n    enddo\n    do k = L+1, len(outp)\n      outp(k:k) = ' '\n    enddo\n  end subroutine reverse\n\n  subroutine bs(a, n) \n    \n    character(len=*),dimension(*),intent(inout) :: a\n    integer, intent(in) :: n\n    integer :: i, j, k\n    logical :: done\n    character(len=1) :: t\n    do i=n-1, 1, -1\n      done = .true.\n      do j=1, i\n        if (a(j+1) .lt. a(j)) then\n          done = .false.\n          do k = 1, max(len_trim(a(j+1)), len_trim(a(j)))\n            t = a(j+1)(k:k)\n            a(j+1)(k:k) = a(j)(k:k)\n            a(j)(k:k) = t(1:1)\n          enddo\n        endif\n      enddo\n      if (done) return\n    enddo\n  end subroutine bs\n\n  logical function binary_search(source, n, target)\n    character(len=*),dimension(*),intent(in) :: source\n    character(len=*),intent(in) :: target\n    integer, intent(in) :: n\n    integer :: a,m,z\n    a = 1\n    z = n\n    do while (a .lt. z)\n      m = a + (z - a) / 2\n      if (target .lt. source(m)) then\n        z = m-1\n      else\n        if (m .eq. a) exit\n        a = m\n      endif\n    enddo\n    binary_search = (target .eq. source(a)) .or. (target .eq. source(z))\n  end function binary_search\n\nend program Semordnilap\n", "target": ">>> with open('unixdict.txt') as f:\n\twordset = set(f.read().strip().split())\n\n>>> revlist = (''.join(word[::-1]) for word in wordset)\n>>> pairs   = set((word, rev) for word, rev in zip(wordset, revlist) \n                  if word < rev and rev in wordset)\n>>> len(pairs)\n158\n>>> sorted(pairs, key=lambda p: (len(p[0]), p))[-5:]\n[('damon', 'nomad'), ('lager', 'regal'), ('leper', 'repel'), ('lever', 'revel'), ('kramer', 'remark')]\n>>>\n"}
{"id": 159369, "name": "Longest common substring", "source": "Translate Fortran to C#: program main\nimplicit none\n   call  compare('testing123testingthing', 'thisis',                 'thi')\n   call  compare('testing',                'sting',                  'sting')\n   call  compare('thisisatest_stinger',    'testing123testingthing', 'sting')\n   call  compare('thisisatest_stinger',    'thisis',                 'thisis')\n   call  compare('thisisatest',            'testing123testing',      'test')\n   call  compare('thisisatest',            'thisisatest',            'thisisatest')\ncontains\nsubroutine compare(a,b,answer)\ncharacter(len=*),intent(in) :: a, b, answer\ncharacter(len=:),allocatable :: a2, match\ncharacter(len=*),parameter :: g='(*(g0))'\ninteger :: i\n   a2=a \n   match=''\n   do i=1,len(a2)-1\n      call compare_sub(a2,b,match)\n      if(len(a2).lt.len(match))exit\n      a2=a2(:len(a2)-1)\n   enddo\n   write(*,g) merge('(PASSED)','(FAILED)',answer.eq.match), &\n   & ' longest match found: \"',match,'\"; expected \"',answer,'\"', &\n   & ' comparing \"',a,'\" and \"',b,'\"'\nend subroutine\nsubroutine compare_sub(a,b,match)\ncharacter(len=*),intent(in) :: a, b\ncharacter(len=:),allocatable :: match\ninteger :: left, foundat, len_a\n   len_a=len(a)\n   do left=1,len_a\n      foundat=index(b,a(left:))\n      if(foundat.ne.0.and.len(match).lt.len_a-left+1)then\n         if(len(a(left:)).gt.len(match))then\n            match=a(left:)\n            exit\n         endif\n      endif\n   enddo\nend subroutine compare_sub\nend program main\n", "target": "using System;\n\nnamespace LongestCommonSubstring\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            Console.WriteLine(lcs(\"thisisatest\", \"testing123testing\"));\n            Console.ReadKey(true);\n        }\n\n        public static string lcs(string a, string b)\n        {\n            var lengths = new int[a.Length, b.Length];\n            int greatestLength = 0;\n            string output = \"\";\n            for (int i = 0; i < a.Length; i++)\n            {\n                for (int j = 0; j < b.Length; j++)\n                {\n                    if (a[i] == b[j])\n                    {\n                        lengths[i, j] = i == 0 || j == 0 ? 1 : lengths[i - 1, j - 1] + 1;\n                        if (lengths[i, j] > greatestLength)\n                        {\n                            greatestLength = lengths[i, j];\n                            output = a.Substring(i - greatestLength + 1, greatestLength);\n                        }\n                    }\n                    else\n                    {\n                        lengths[i, j] = 0;\n                    }\n                }\n            }\n            return output;\n        }\n    }\n}\n"}
{"id": 159373, "name": "Longest common substring", "source": "Translate Fortran to Java: program main\nimplicit none\n   call  compare('testing123testingthing', 'thisis',                 'thi')\n   call  compare('testing',                'sting',                  'sting')\n   call  compare('thisisatest_stinger',    'testing123testingthing', 'sting')\n   call  compare('thisisatest_stinger',    'thisis',                 'thisis')\n   call  compare('thisisatest',            'testing123testing',      'test')\n   call  compare('thisisatest',            'thisisatest',            'thisisatest')\ncontains\nsubroutine compare(a,b,answer)\ncharacter(len=*),intent(in) :: a, b, answer\ncharacter(len=:),allocatable :: a2, match\ncharacter(len=*),parameter :: g='(*(g0))'\ninteger :: i\n   a2=a \n   match=''\n   do i=1,len(a2)-1\n      call compare_sub(a2,b,match)\n      if(len(a2).lt.len(match))exit\n      a2=a2(:len(a2)-1)\n   enddo\n   write(*,g) merge('(PASSED)','(FAILED)',answer.eq.match), &\n   & ' longest match found: \"',match,'\"; expected \"',answer,'\"', &\n   & ' comparing \"',a,'\" and \"',b,'\"'\nend subroutine\nsubroutine compare_sub(a,b,match)\ncharacter(len=*),intent(in) :: a, b\ncharacter(len=:),allocatable :: match\ninteger :: left, foundat, len_a\n   len_a=len(a)\n   do left=1,len_a\n      foundat=index(b,a(left:))\n      if(foundat.ne.0.and.len(match).lt.len_a-left+1)then\n         if(len(a(left:)).gt.len(match))then\n            match=a(left:)\n            exit\n         endif\n      endif\n   enddo\nend subroutine compare_sub\nend program main\n", "target": "public class LongestCommonSubstring {\n\n    public static void main(String[] args) {\n        System.out.println(lcs(\"testing123testing\", \"thisisatest\"));\n        System.out.println(lcs(\"test\", \"thisisatest\"));\n        System.out.println(lcs(\"testing\", \"sting\"));\n        System.out.println(lcs(\"testing\", \"thisisasting\"));\n    }\n\n    static String lcs(String a, String b) {\n        if (a.length() > b.length())\n            return lcs(b, a);\n\n        String res = \"\";\n        for (int ai = 0; ai < a.length(); ai++) {\n            for (int len = a.length() - ai; len > 0; len--) {\n\n                for (int bi = 0; bi <= b.length() - len; bi++) {\n\n                    if (a.regionMatches(ai, b, bi, len) && len > res.length()) {\n                        res = a.substring(ai, ai + len);\n                    }\n                }\n            }\n        }\n        return res;\n    }\n}\n"}
{"id": 159374, "name": "Longest common substring", "source": "Translate Fortran to Python: program main\nimplicit none\n   call  compare('testing123testingthing', 'thisis',                 'thi')\n   call  compare('testing',                'sting',                  'sting')\n   call  compare('thisisatest_stinger',    'testing123testingthing', 'sting')\n   call  compare('thisisatest_stinger',    'thisis',                 'thisis')\n   call  compare('thisisatest',            'testing123testing',      'test')\n   call  compare('thisisatest',            'thisisatest',            'thisisatest')\ncontains\nsubroutine compare(a,b,answer)\ncharacter(len=*),intent(in) :: a, b, answer\ncharacter(len=:),allocatable :: a2, match\ncharacter(len=*),parameter :: g='(*(g0))'\ninteger :: i\n   a2=a \n   match=''\n   do i=1,len(a2)-1\n      call compare_sub(a2,b,match)\n      if(len(a2).lt.len(match))exit\n      a2=a2(:len(a2)-1)\n   enddo\n   write(*,g) merge('(PASSED)','(FAILED)',answer.eq.match), &\n   & ' longest match found: \"',match,'\"; expected \"',answer,'\"', &\n   & ' comparing \"',a,'\" and \"',b,'\"'\nend subroutine\nsubroutine compare_sub(a,b,match)\ncharacter(len=*),intent(in) :: a, b\ncharacter(len=:),allocatable :: match\ninteger :: left, foundat, len_a\n   len_a=len(a)\n   do left=1,len_a\n      foundat=index(b,a(left:))\n      if(foundat.ne.0.and.len(match).lt.len_a-left+1)then\n         if(len(a(left:)).gt.len(match))then\n            match=a(left:)\n            exit\n         endif\n      endif\n   enddo\nend subroutine compare_sub\nend program main\n", "target": "s1 = \"thisisatest\"\ns2 = \"testing123testing\"\nlen1, len2 = len(s1), len(s2)\nir, jr = 0, -1\nfor i1 in range(len1):\n    i2 = s2.find(s1[i1])\n    while i2 >= 0:\n        j1, j2 = i1, i2\n        while j1 < len1 and j2 < len2 and s2[j2] == s1[j1]:\n            if j1-i1 >= jr-ir:\n                ir, jr = i1, j1\n            j1 += 1; j2 += 1\n        i2 = s2.find(s1[i1], i2+1)\nprint (s1[ir:jr+1])\n"}
{"id": 159736, "name": "Largest int from concatenated ints", "source": "Translate Fortran to C#:       SUBROUTINE SWAP(A,B)\t\n       INTEGER A,B,T\n        T = B\n        B = A\n        A = T\n      END\n\n      SUBROUTINE BIGUP(TEXT,N)\t\n       CHARACTER*(*) TEXT(*)\t\n       INTEGER N\t\t\n       INTEGER XLAT(N),L(N)\t\n       INTEGER I,J,M\t\t\n       INTEGER TI,TJ\t\t\n       INTEGER LI,LJ\t\t\n       INTEGER MSG\t\t\n       COMMON /IODEV/ MSG\t\n        DO I = 1,N\t\n          XLAT(I) = I\t\t\n          L(I) = LEN_TRIM(TEXT(I))\t\n        END DO\t\t\n        WRITE (MSG,1) \"Supplied\",(TEXT(I)(1:L(I)), I = 1,N)\t\n    1   FORMAT (A12,\":\",<N>(A,\",\"))\t\nCrude bubblesort. No attempt at noting the bounds of swaps made.\n        DO M = N,1,-1\t\n          DO I = 2,M\t\t\n            J = I - 1\t\t\n            TI = XLAT(I)\t\n            TJ = XLAT(J)\t\n            LI = L(TI)\t\t\n            LJ = L(TJ)\t\t\n            IF (LI .EQ. LJ) THEN\t\n              IF (TEXT(TI).LT.TEXT(TJ)) CALL SWAP(XLAT(I),XLAT(J))\t\n             ELSE\t\n              IF (TEXT(TI)(1:LI)//TEXT(TJ)(1:LJ)\t\n     1        .LT.TEXT(TJ)(1:LJ)//TEXT(TI)(1:LI))\t\n     2        CALL SWAP(XLAT(I),XLAT(J))\t\n            END IF\t\t\t\n          END DO\t\t\n        END DO\t\n        WRITE (MSG,2) \"Biggest\",(TEXT(XLAT(I))(1:L(XLAT(I))),I = N,1,-1)\t\n    2   FORMAT (A12,\":\",<N>(A,\" \"))\t\n      END\t\n\n      PROGRAM POKE\n      CHARACTER*4 T1(10)\t\n      CHARACTER*4 T2(4)\t\t\n      INTEGER MSG\n      COMMON /IODEV/ MSG\n      DATA T1(1:8)/\"1\",\"34\",\"3\",\"98\",\"9\",\"76\",\"45\",\"4\"/\n      DATA T2/\"54\",\"546\",\"548\",\"60\"/\n      MSG = 6\t\t\n      WRITE (MSG,1)\n    1 FORMAT (\"Takes a list of integers and concatenates them so as \",\n     1 \"to produce the biggest possible number.\",/,\n     2 \"The result is shown with spaces between the parts \",\n     3 \"to show provenance. Ignore them otherwise.\"/)\n      CALL BIGUP(T1,8)\n\n      WRITE (MSG,*)\n      CALL BIGUP(T2,4)\n\n      WRITE (MSG,*) \"These are supplied in lexicographical order...\"\n      CALL BIGUP((/\"5\",\"54\"/),2)\n\n      WRITE (MSG,*) \"But this is not necessarily the biggest order.\"\n      CALL BIGUP((/\"5\",\"56\"/),2)\n\n      WRITE (MSG,*) \"And for those who count...\"\n      DO I = 1,10\n        WRITE (T1(I),\"(I0)\") I\t\n      END DO\t\t\t\n      CALL BIGUP(T1,10)\n      END\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\nclass Program\n{\n    static void Main(string[] args)\n    {\n        var source1 = new int[] { 1, 34, 3, 98, 9, 76, 45, 4 };\n        var source2 = new int[] { 54, 546, 548, 60 };\n\n        var largest1 = LargestPossibleSequence(source1);\n        var largest2 = LargestPossibleSequence(source2);\n\n        Console.WriteLine(\"The largest possible integer from set 1 is: {0}\", largest1);\n        Console.WriteLine(\"The largest possible integer from set 2 is: {0}\", largest2);\n    }\n\n    static long LargestPossibleSequence(int[] ints)\n    {\n        return long.Parse(string.Join(\"\", ints.OrderBy(i => i, new IntConcatenationComparer()).Reverse()));\n    }\n}\n\nclass IntConcatenationComparer : IComparer<int>\n{\n    public int Compare(int x, int y)\n    {\n        var xy = int.Parse(x.ToString() + y.ToString());\n        var yx = int.Parse(y.ToString() + x.ToString());\n\n        return xy - yx;\n    }\n}\n"}
{"id": 159739, "name": "Largest int from concatenated ints", "source": "Translate Fortran to Java:       SUBROUTINE SWAP(A,B)\t\n       INTEGER A,B,T\n        T = B\n        B = A\n        A = T\n      END\n\n      SUBROUTINE BIGUP(TEXT,N)\t\n       CHARACTER*(*) TEXT(*)\t\n       INTEGER N\t\t\n       INTEGER XLAT(N),L(N)\t\n       INTEGER I,J,M\t\t\n       INTEGER TI,TJ\t\t\n       INTEGER LI,LJ\t\t\n       INTEGER MSG\t\t\n       COMMON /IODEV/ MSG\t\n        DO I = 1,N\t\n          XLAT(I) = I\t\t\n          L(I) = LEN_TRIM(TEXT(I))\t\n        END DO\t\t\n        WRITE (MSG,1) \"Supplied\",(TEXT(I)(1:L(I)), I = 1,N)\t\n    1   FORMAT (A12,\":\",<N>(A,\",\"))\t\nCrude bubblesort. No attempt at noting the bounds of swaps made.\n        DO M = N,1,-1\t\n          DO I = 2,M\t\t\n            J = I - 1\t\t\n            TI = XLAT(I)\t\n            TJ = XLAT(J)\t\n            LI = L(TI)\t\t\n            LJ = L(TJ)\t\t\n            IF (LI .EQ. LJ) THEN\t\n              IF (TEXT(TI).LT.TEXT(TJ)) CALL SWAP(XLAT(I),XLAT(J))\t\n             ELSE\t\n              IF (TEXT(TI)(1:LI)//TEXT(TJ)(1:LJ)\t\n     1        .LT.TEXT(TJ)(1:LJ)//TEXT(TI)(1:LI))\t\n     2        CALL SWAP(XLAT(I),XLAT(J))\t\n            END IF\t\t\t\n          END DO\t\t\n        END DO\t\n        WRITE (MSG,2) \"Biggest\",(TEXT(XLAT(I))(1:L(XLAT(I))),I = N,1,-1)\t\n    2   FORMAT (A12,\":\",<N>(A,\" \"))\t\n      END\t\n\n      PROGRAM POKE\n      CHARACTER*4 T1(10)\t\n      CHARACTER*4 T2(4)\t\t\n      INTEGER MSG\n      COMMON /IODEV/ MSG\n      DATA T1(1:8)/\"1\",\"34\",\"3\",\"98\",\"9\",\"76\",\"45\",\"4\"/\n      DATA T2/\"54\",\"546\",\"548\",\"60\"/\n      MSG = 6\t\t\n      WRITE (MSG,1)\n    1 FORMAT (\"Takes a list of integers and concatenates them so as \",\n     1 \"to produce the biggest possible number.\",/,\n     2 \"The result is shown with spaces between the parts \",\n     3 \"to show provenance. Ignore them otherwise.\"/)\n      CALL BIGUP(T1,8)\n\n      WRITE (MSG,*)\n      CALL BIGUP(T2,4)\n\n      WRITE (MSG,*) \"These are supplied in lexicographical order...\"\n      CALL BIGUP((/\"5\",\"54\"/),2)\n\n      WRITE (MSG,*) \"But this is not necessarily the biggest order.\"\n      CALL BIGUP((/\"5\",\"56\"/),2)\n\n      WRITE (MSG,*) \"And for those who count...\"\n      DO I = 1,10\n        WRITE (T1(I),\"(I0)\") I\t\n      END DO\t\t\t\n      CALL BIGUP(T1,10)\n      END\n", "target": "import java.util.*;\n\npublic class IntConcat {\n \n    private static Comparator<Integer> sorter = new Comparator<Integer>(){\n        @Override\n        public int compare(Integer o1, Integer o2){\n            String o1s = o1.toString();\n            String o2s = o2.toString();\n            \n            if(o1s.length() == o2s.length()){\n                return o2s.compareTo(o1s);\n            }\n\n            int mlen = Math.max(o1s.length(), o2s.length());\n            while(o1s.length() < mlen * 2) o1s += o1s;\n            while(o2s.length() < mlen * 2) o2s += o2s;\n            \n            return o2s.compareTo(o1s);\n        }\n    };\n    \n    public static String join(List<?> things){\n        String output = \"\";\n        for(Object obj:things){\n            output += obj;\n        }\n        return output;\n    }\n    \n    public static void main(String[] args){\n        List<Integer> ints1 = new ArrayList<Integer>(Arrays.asList(1, 34, 3, 98, 9, 76, 45, 4));\n        \n        Collections.sort(ints1, sorter);\n        System.out.println(join(ints1));\n        \n        List<Integer> ints2 = new ArrayList<Integer>(Arrays.asList(54, 546, 548, 60));\n        \n        Collections.sort(ints2, sorter);\n        System.out.println(join(ints2));\n    }\n}\n"}
{"id": 159740, "name": "Largest int from concatenated ints", "source": "Translate Fortran to Python:       SUBROUTINE SWAP(A,B)\t\n       INTEGER A,B,T\n        T = B\n        B = A\n        A = T\n      END\n\n      SUBROUTINE BIGUP(TEXT,N)\t\n       CHARACTER*(*) TEXT(*)\t\n       INTEGER N\t\t\n       INTEGER XLAT(N),L(N)\t\n       INTEGER I,J,M\t\t\n       INTEGER TI,TJ\t\t\n       INTEGER LI,LJ\t\t\n       INTEGER MSG\t\t\n       COMMON /IODEV/ MSG\t\n        DO I = 1,N\t\n          XLAT(I) = I\t\t\n          L(I) = LEN_TRIM(TEXT(I))\t\n        END DO\t\t\n        WRITE (MSG,1) \"Supplied\",(TEXT(I)(1:L(I)), I = 1,N)\t\n    1   FORMAT (A12,\":\",<N>(A,\",\"))\t\nCrude bubblesort. No attempt at noting the bounds of swaps made.\n        DO M = N,1,-1\t\n          DO I = 2,M\t\t\n            J = I - 1\t\t\n            TI = XLAT(I)\t\n            TJ = XLAT(J)\t\n            LI = L(TI)\t\t\n            LJ = L(TJ)\t\t\n            IF (LI .EQ. LJ) THEN\t\n              IF (TEXT(TI).LT.TEXT(TJ)) CALL SWAP(XLAT(I),XLAT(J))\t\n             ELSE\t\n              IF (TEXT(TI)(1:LI)//TEXT(TJ)(1:LJ)\t\n     1        .LT.TEXT(TJ)(1:LJ)//TEXT(TI)(1:LI))\t\n     2        CALL SWAP(XLAT(I),XLAT(J))\t\n            END IF\t\t\t\n          END DO\t\t\n        END DO\t\n        WRITE (MSG,2) \"Biggest\",(TEXT(XLAT(I))(1:L(XLAT(I))),I = N,1,-1)\t\n    2   FORMAT (A12,\":\",<N>(A,\" \"))\t\n      END\t\n\n      PROGRAM POKE\n      CHARACTER*4 T1(10)\t\n      CHARACTER*4 T2(4)\t\t\n      INTEGER MSG\n      COMMON /IODEV/ MSG\n      DATA T1(1:8)/\"1\",\"34\",\"3\",\"98\",\"9\",\"76\",\"45\",\"4\"/\n      DATA T2/\"54\",\"546\",\"548\",\"60\"/\n      MSG = 6\t\t\n      WRITE (MSG,1)\n    1 FORMAT (\"Takes a list of integers and concatenates them so as \",\n     1 \"to produce the biggest possible number.\",/,\n     2 \"The result is shown with spaces between the parts \",\n     3 \"to show provenance. Ignore them otherwise.\"/)\n      CALL BIGUP(T1,8)\n\n      WRITE (MSG,*)\n      CALL BIGUP(T2,4)\n\n      WRITE (MSG,*) \"These are supplied in lexicographical order...\"\n      CALL BIGUP((/\"5\",\"54\"/),2)\n\n      WRITE (MSG,*) \"But this is not necessarily the biggest order.\"\n      CALL BIGUP((/\"5\",\"56\"/),2)\n\n      WRITE (MSG,*) \"And for those who count...\"\n      DO I = 1,10\n        WRITE (T1(I),\"(I0)\") I\t\n      END DO\t\t\t\n      CALL BIGUP(T1,10)\n      END\n", "target": "try:\n    cmp     \n    def maxnum(x):\n        return ''.join(sorted((str(n) for n in x),\n                              cmp=lambda x,y:cmp(y+x, x+y)))\nexcept NameError:\n    \n    from functools import cmp_to_key\n    def cmp(x, y):\n        return -1 if x<y else ( 0 if x==y else 1)\n    def maxnum(x):\n        return ''.join(sorted((str(n) for n in x),\n                              key=cmp_to_key(lambda x,y:cmp(y+x, x+y))))\n\nfor numbers in [(1, 34, 3, 98, 9, 76, 45, 4), (54, 546, 548, 60)]:\n    print('Numbers: %r\\n  Largest integer: %15s' % (numbers, maxnum(numbers)))\n"}
{"id": 159969, "name": "Maximum triangle path sum", "source": "Translate Fortran to C#:       MODULE PYRAMIDS\t\n       INTEGER MANY\t\t\n       PARAMETER (MANY = 666)\t\n       INTEGER BRICK(MANY),IN,LAYERS\t\n       CONTAINS\n        SUBROUTINE IMHOTEP(PLAN)\nCounting is from the apex down, the Erich von Daniken construction.\n         CHARACTER*(*) PLAN\t\n         INTEGER I,IT\t\t\n         CHARACTER*666 ALINE\t\n          IN = 0\t\t\n          LAYERS = 0\t\t\n          WRITE (6,*) \"Reading from \",PLAN\t\n          OPEN(10,FILE=PLAN,FORM=\"FORMATTED\",ACTION=\"READ\",ERR=6)\t\n          GO TO 10\t\t\n    6     STOP \"Can't grab the file\nChew into the plan.\n   10     READ (10,11,END = 20) ALINE\t\n   11     FORMAT (A)\t\t\t\n          IF (ALINE .EQ. \"\") GO TO 10\t\n          IF (ALINE(1:1).EQ.\"%\") GO TO 10\t\n          LAYERS = LAYERS + 1\t\t\n          IF (IN + LAYERS.GT.MANY) STOP \"Too many bricks\n          READ (ALINE,*,END = 15,ERR = 15) BRICK(IN + 1:IN + LAYERS)\t\n          IN = IN + LAYERS\t\t\n          GO TO 10\t\t\t\nCaught a crab? A bad number, or too few numbers on a line? No read-next-record antics, thanks.\n   15     WRITE (6,16) LAYERS,ALINE\t\n   16     FORMAT (\"Bad layer \",I0,\": \",A)\nCompleted the plan.\n   20     WRITE (6,21) IN,LAYERS\t\n   21     FORMAT (I0,\" bricks in \",I0,\" layers.\")\n          CLOSE(10)\t\t\t\nCast forth the numbers in a nice pyramid.\n   30     IT = 0\t\t\n          DO I = 1,LAYERS\t\n            WRITE (6,31) BRICK(IT + 1:IT + I)\t\n   31       FORMAT (<LAYERS*2 - 2*I>X,666I4)\t\n            IT = IT + I\t\t\t\t\n          END DO\t\t\n        END SUBROUTINE IMHOTEP\t\n\n        SUBROUTINE TRAVERSE\t\nC   The idea is that a pyramid of numbers is provided, and then, starting at the peak,\nc work down to the base summing the numbers at each step to find the maximum value path.\nc The constraint is that from a particular brick, only the two numbers below left and below right\nc may be reached in stepping to that lower layer.\nc   Since that is a 0/1 choice, recorded in MOVE, a base-two scan searches the possibilities.\n         INTEGER MOVE(LAYERS)\t\t\n         INTEGER STEP(LAYERS),WALK(LAYERS)\t\n         INTEGER I,L,IT\t\t\n         INTEGER PS,WS\t\t\n          WRITE (6,1) LAYERS\t\t\n    1     FORMAT (//,\"Find the highest score path across a pyramid of \",\n     1     I0,\" layers.\"/)\t\n          MOVE = 0\t\n          MOVE(1) = 1\t\n          STEP(1) = 1\t\n          WS = -666\t\nCommence a multi-level loop, using the values of MOVE as the digits, one digit per level.\n   10       IT = 1\t\t\n            PS = BRICK(1)\t\nc            write (6,8) \"Move\",MOVE,WS\n            DO L = 2,LAYERS\t\n              IT = IT + L - 1 + MOVE(L)\t\n              STEP(L) = IT\t\t\n              PS = PS + BRICK(IT)\t\nc              WRITE (6,6) L,IT,BRICK(IT),PS\n    6         FORMAT (\"Layer \",I0,\",Brick(\",I0,\")=\",I0,\",Sum=\",I0)\n            END DO\t\t\n            IF (PS .GT. WS) THEN\t\n              IF (WS.GT.0) WRITE (6,7) WS,PS\t\n    7         FORMAT (\"Improved path score: \",I0,\" to \",I0)\n              WRITE (6,8) \"Moves\",MOVE\t\t\n              WRITE (6,8) \"Steps\",STEP\t\t\n              WRITE (6,8) \"Score\",BRICK(STEP)\t\n    8         FORMAT (A8,666I4)\t\t\t\n              WS = PS\t\t\t\t\n              WALK = STEP\t\t\t\n            END IF\t\t\t\n            DO L = LAYERS,1,-1\t\t\n              IF (MOVE(L).EQ.0) THEN\t\n                MOVE(L) = 1\t\t\n                MOVE(L + 1:LAYERS) = 0\t\n                GO TO 10\t\t\n              END IF\t\t\n            END DO\t\t\n          WRITE (6,*) WS,\" is the highest score.\"\t\n        END SUBROUTINE TRAVERSE\t\n\n        SUBROUTINE REFINE\t\n         INTEGER BEST(LAYERS)\t\n         INTEGER I,L\t\t\n          L = LAYERS*(LAYERS - 1)/2 + 1\t\n          BEST = BRICK(L:L + LAYERS - 1)\n          DO L = LAYERS - 1,1,-1\t\n            FORALL (I = 1:L) BEST(I) = BRICK(L*(L - 1)/2 + I)\t\n     1                               + MAXVAL(BEST(I:I + 1))\t\n          END DO\t\t\t\n          WRITE (6,*) BEST(1),\" is the highest score. By some path.\"\n        END SUBROUTINE REFINE\t\n      END MODULE PYRAMIDS\n\n      PROGRAM TRICKLE\n      USE PYRAMIDS\nc      CALL IMHOTEP(\"Sakkara.txt\")\n      CALL IMHOTEP(\"Cheops.txt\")\n      CALL TRAVERSE\t\t\t\n      CALL REFINE\t\t\t\n      END\n", "target": "using System;\n\nnamespace RosetaCode\n{\n\tclass MainClass\n\t{\n\t\tpublic static void Main (string[] args)\n\t\t{\n\t\t\tint[,] list = new int[18,19];\n\t\t\tstring input = @\"55\n\t                        94 48\n\t                       95 30 96\n\t                     77 71 26 67\n\t                    97 13 76 38 45\n\t                  07 36 79 16 37 68\n\t                 48 07 09 18 70 26 06\n\t               18 72 79 46 59 79 29 90\n\t              20 76 87 11 32 07 07 49 18\n\t            27 83 58 35 71 11 25 57 29 85\n\t           14 64 36 96 27 11 58 56 92 18 55\n\t         02 90 03 60 48 49 41 46 33 36 47 23\n\t        92 50 48 02 36 59 42 79 72 20 82 77 42\n\t      56 78 38 80 39 75 02 71 66 66 01 03 55 72\n\t     44 25 67 84 71 67 11 61 40 57 58 89 40 56 36\n\t   85 32 25 85 57 48 84 35 47 62 17 01 01 99 89 52\n\t  06 71 28 75 94 48 37 10 23 51 06 48 53 18 74 98 15\n\t27 02 92 23 08 71 76 84 15 52 92 63 81 10 44 10 69 93\";\n\t\t\tvar charArray = input.Split ('\\n');\n\n\t\t\tfor (int i=0; i < charArray.Length; i++) {\n\t\t\t\tvar numArr = charArray[i].Trim().Split(' ');\n\n\t\t\t\tfor (int j = 0; j<numArr.Length; j++)\n\t\t\t\t{\n\t\t\t\t\tint number = Convert.ToInt32 (numArr[j]);\n\t\t\t\t\tlist [i, j] = number;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor (int i = 16; i >= 0; i--) {\n\t\t\t\tfor (int j = 0; j < 18; j++) {\n\t\t\t\t\tlist[i,j] = Math.Max(list[i, j] + list[i+1, j], list[i,j] + list[i+1, j+1]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tConsole.WriteLine (string.Format(\"Maximum total: {0}\", list [0, 0]));\n\t\t}\n\t}\n}\n"}
{"id": 159972, "name": "Maximum triangle path sum", "source": "Translate Fortran to Java:       MODULE PYRAMIDS\t\n       INTEGER MANY\t\t\n       PARAMETER (MANY = 666)\t\n       INTEGER BRICK(MANY),IN,LAYERS\t\n       CONTAINS\n        SUBROUTINE IMHOTEP(PLAN)\nCounting is from the apex down, the Erich von Daniken construction.\n         CHARACTER*(*) PLAN\t\n         INTEGER I,IT\t\t\n         CHARACTER*666 ALINE\t\n          IN = 0\t\t\n          LAYERS = 0\t\t\n          WRITE (6,*) \"Reading from \",PLAN\t\n          OPEN(10,FILE=PLAN,FORM=\"FORMATTED\",ACTION=\"READ\",ERR=6)\t\n          GO TO 10\t\t\n    6     STOP \"Can't grab the file\nChew into the plan.\n   10     READ (10,11,END = 20) ALINE\t\n   11     FORMAT (A)\t\t\t\n          IF (ALINE .EQ. \"\") GO TO 10\t\n          IF (ALINE(1:1).EQ.\"%\") GO TO 10\t\n          LAYERS = LAYERS + 1\t\t\n          IF (IN + LAYERS.GT.MANY) STOP \"Too many bricks\n          READ (ALINE,*,END = 15,ERR = 15) BRICK(IN + 1:IN + LAYERS)\t\n          IN = IN + LAYERS\t\t\n          GO TO 10\t\t\t\nCaught a crab? A bad number, or too few numbers on a line? No read-next-record antics, thanks.\n   15     WRITE (6,16) LAYERS,ALINE\t\n   16     FORMAT (\"Bad layer \",I0,\": \",A)\nCompleted the plan.\n   20     WRITE (6,21) IN,LAYERS\t\n   21     FORMAT (I0,\" bricks in \",I0,\" layers.\")\n          CLOSE(10)\t\t\t\nCast forth the numbers in a nice pyramid.\n   30     IT = 0\t\t\n          DO I = 1,LAYERS\t\n            WRITE (6,31) BRICK(IT + 1:IT + I)\t\n   31       FORMAT (<LAYERS*2 - 2*I>X,666I4)\t\n            IT = IT + I\t\t\t\t\n          END DO\t\t\n        END SUBROUTINE IMHOTEP\t\n\n        SUBROUTINE TRAVERSE\t\nC   The idea is that a pyramid of numbers is provided, and then, starting at the peak,\nc work down to the base summing the numbers at each step to find the maximum value path.\nc The constraint is that from a particular brick, only the two numbers below left and below right\nc may be reached in stepping to that lower layer.\nc   Since that is a 0/1 choice, recorded in MOVE, a base-two scan searches the possibilities.\n         INTEGER MOVE(LAYERS)\t\t\n         INTEGER STEP(LAYERS),WALK(LAYERS)\t\n         INTEGER I,L,IT\t\t\n         INTEGER PS,WS\t\t\n          WRITE (6,1) LAYERS\t\t\n    1     FORMAT (//,\"Find the highest score path across a pyramid of \",\n     1     I0,\" layers.\"/)\t\n          MOVE = 0\t\n          MOVE(1) = 1\t\n          STEP(1) = 1\t\n          WS = -666\t\nCommence a multi-level loop, using the values of MOVE as the digits, one digit per level.\n   10       IT = 1\t\t\n            PS = BRICK(1)\t\nc            write (6,8) \"Move\",MOVE,WS\n            DO L = 2,LAYERS\t\n              IT = IT + L - 1 + MOVE(L)\t\n              STEP(L) = IT\t\t\n              PS = PS + BRICK(IT)\t\nc              WRITE (6,6) L,IT,BRICK(IT),PS\n    6         FORMAT (\"Layer \",I0,\",Brick(\",I0,\")=\",I0,\",Sum=\",I0)\n            END DO\t\t\n            IF (PS .GT. WS) THEN\t\n              IF (WS.GT.0) WRITE (6,7) WS,PS\t\n    7         FORMAT (\"Improved path score: \",I0,\" to \",I0)\n              WRITE (6,8) \"Moves\",MOVE\t\t\n              WRITE (6,8) \"Steps\",STEP\t\t\n              WRITE (6,8) \"Score\",BRICK(STEP)\t\n    8         FORMAT (A8,666I4)\t\t\t\n              WS = PS\t\t\t\t\n              WALK = STEP\t\t\t\n            END IF\t\t\t\n            DO L = LAYERS,1,-1\t\t\n              IF (MOVE(L).EQ.0) THEN\t\n                MOVE(L) = 1\t\t\n                MOVE(L + 1:LAYERS) = 0\t\n                GO TO 10\t\t\n              END IF\t\t\n            END DO\t\t\n          WRITE (6,*) WS,\" is the highest score.\"\t\n        END SUBROUTINE TRAVERSE\t\n\n        SUBROUTINE REFINE\t\n         INTEGER BEST(LAYERS)\t\n         INTEGER I,L\t\t\n          L = LAYERS*(LAYERS - 1)/2 + 1\t\n          BEST = BRICK(L:L + LAYERS - 1)\n          DO L = LAYERS - 1,1,-1\t\n            FORALL (I = 1:L) BEST(I) = BRICK(L*(L - 1)/2 + I)\t\n     1                               + MAXVAL(BEST(I:I + 1))\t\n          END DO\t\t\t\n          WRITE (6,*) BEST(1),\" is the highest score. By some path.\"\n        END SUBROUTINE REFINE\t\n      END MODULE PYRAMIDS\n\n      PROGRAM TRICKLE\n      USE PYRAMIDS\nc      CALL IMHOTEP(\"Sakkara.txt\")\n      CALL IMHOTEP(\"Cheops.txt\")\n      CALL TRAVERSE\t\t\t\n      CALL REFINE\t\t\t\n      END\n", "target": "import java.nio.file.*;\nimport static java.util.Arrays.stream;\n\npublic class MaxPathSum {\n\n    public static void main(String[] args) throws Exception {\n        int[][] data = Files.lines(Paths.get(\"triangle.txt\"))\n                .map(s -> stream(s.trim().split(\"\\\\s+\"))\n                        .mapToInt(Integer::parseInt)\n                        .toArray())\n                .toArray(int[][]::new);\n\n        for (int r = data.length - 1; r > 0; r--)\n            for (int c = 0; c < data[r].length - 1; c++)\n                data[r - 1][c] += Math.max(data[r][c], data[r][c + 1]);\n\n        System.out.println(data[0][0]);\n    }\n}\n"}
{"id": 159973, "name": "Maximum triangle path sum", "source": "Translate Fortran to Python:       MODULE PYRAMIDS\t\n       INTEGER MANY\t\t\n       PARAMETER (MANY = 666)\t\n       INTEGER BRICK(MANY),IN,LAYERS\t\n       CONTAINS\n        SUBROUTINE IMHOTEP(PLAN)\nCounting is from the apex down, the Erich von Daniken construction.\n         CHARACTER*(*) PLAN\t\n         INTEGER I,IT\t\t\n         CHARACTER*666 ALINE\t\n          IN = 0\t\t\n          LAYERS = 0\t\t\n          WRITE (6,*) \"Reading from \",PLAN\t\n          OPEN(10,FILE=PLAN,FORM=\"FORMATTED\",ACTION=\"READ\",ERR=6)\t\n          GO TO 10\t\t\n    6     STOP \"Can't grab the file\nChew into the plan.\n   10     READ (10,11,END = 20) ALINE\t\n   11     FORMAT (A)\t\t\t\n          IF (ALINE .EQ. \"\") GO TO 10\t\n          IF (ALINE(1:1).EQ.\"%\") GO TO 10\t\n          LAYERS = LAYERS + 1\t\t\n          IF (IN + LAYERS.GT.MANY) STOP \"Too many bricks\n          READ (ALINE,*,END = 15,ERR = 15) BRICK(IN + 1:IN + LAYERS)\t\n          IN = IN + LAYERS\t\t\n          GO TO 10\t\t\t\nCaught a crab? A bad number, or too few numbers on a line? No read-next-record antics, thanks.\n   15     WRITE (6,16) LAYERS,ALINE\t\n   16     FORMAT (\"Bad layer \",I0,\": \",A)\nCompleted the plan.\n   20     WRITE (6,21) IN,LAYERS\t\n   21     FORMAT (I0,\" bricks in \",I0,\" layers.\")\n          CLOSE(10)\t\t\t\nCast forth the numbers in a nice pyramid.\n   30     IT = 0\t\t\n          DO I = 1,LAYERS\t\n            WRITE (6,31) BRICK(IT + 1:IT + I)\t\n   31       FORMAT (<LAYERS*2 - 2*I>X,666I4)\t\n            IT = IT + I\t\t\t\t\n          END DO\t\t\n        END SUBROUTINE IMHOTEP\t\n\n        SUBROUTINE TRAVERSE\t\nC   The idea is that a pyramid of numbers is provided, and then, starting at the peak,\nc work down to the base summing the numbers at each step to find the maximum value path.\nc The constraint is that from a particular brick, only the two numbers below left and below right\nc may be reached in stepping to that lower layer.\nc   Since that is a 0/1 choice, recorded in MOVE, a base-two scan searches the possibilities.\n         INTEGER MOVE(LAYERS)\t\t\n         INTEGER STEP(LAYERS),WALK(LAYERS)\t\n         INTEGER I,L,IT\t\t\n         INTEGER PS,WS\t\t\n          WRITE (6,1) LAYERS\t\t\n    1     FORMAT (//,\"Find the highest score path across a pyramid of \",\n     1     I0,\" layers.\"/)\t\n          MOVE = 0\t\n          MOVE(1) = 1\t\n          STEP(1) = 1\t\n          WS = -666\t\nCommence a multi-level loop, using the values of MOVE as the digits, one digit per level.\n   10       IT = 1\t\t\n            PS = BRICK(1)\t\nc            write (6,8) \"Move\",MOVE,WS\n            DO L = 2,LAYERS\t\n              IT = IT + L - 1 + MOVE(L)\t\n              STEP(L) = IT\t\t\n              PS = PS + BRICK(IT)\t\nc              WRITE (6,6) L,IT,BRICK(IT),PS\n    6         FORMAT (\"Layer \",I0,\",Brick(\",I0,\")=\",I0,\",Sum=\",I0)\n            END DO\t\t\n            IF (PS .GT. WS) THEN\t\n              IF (WS.GT.0) WRITE (6,7) WS,PS\t\n    7         FORMAT (\"Improved path score: \",I0,\" to \",I0)\n              WRITE (6,8) \"Moves\",MOVE\t\t\n              WRITE (6,8) \"Steps\",STEP\t\t\n              WRITE (6,8) \"Score\",BRICK(STEP)\t\n    8         FORMAT (A8,666I4)\t\t\t\n              WS = PS\t\t\t\t\n              WALK = STEP\t\t\t\n            END IF\t\t\t\n            DO L = LAYERS,1,-1\t\t\n              IF (MOVE(L).EQ.0) THEN\t\n                MOVE(L) = 1\t\t\n                MOVE(L + 1:LAYERS) = 0\t\n                GO TO 10\t\t\n              END IF\t\t\n            END DO\t\t\n          WRITE (6,*) WS,\" is the highest score.\"\t\n        END SUBROUTINE TRAVERSE\t\n\n        SUBROUTINE REFINE\t\n         INTEGER BEST(LAYERS)\t\n         INTEGER I,L\t\t\n          L = LAYERS*(LAYERS - 1)/2 + 1\t\n          BEST = BRICK(L:L + LAYERS - 1)\n          DO L = LAYERS - 1,1,-1\t\n            FORALL (I = 1:L) BEST(I) = BRICK(L*(L - 1)/2 + I)\t\n     1                               + MAXVAL(BEST(I:I + 1))\t\n          END DO\t\t\t\n          WRITE (6,*) BEST(1),\" is the highest score. By some path.\"\n        END SUBROUTINE REFINE\t\n      END MODULE PYRAMIDS\n\n      PROGRAM TRICKLE\n      USE PYRAMIDS\nc      CALL IMHOTEP(\"Sakkara.txt\")\n      CALL IMHOTEP(\"Cheops.txt\")\n      CALL TRAVERSE\t\t\t\n      CALL REFINE\t\t\t\n      END\n", "target": "fun maxpathsum(t): \n    let a = val t\n    for i in a.length-1..-1..1, c in linearindices a[r]:\n        a[r, c] += max(a[r+1, c], a[r=1, c+1])\n    return a[1, 1]\n\nlet test = [\n    [55],\n    [94, 48],\n    [95, 30, 96],\n    [77, 71, 26, 67],\n    [97, 13, 76, 38, 45],\n    [07, 36, 79, 16, 37, 68],\n    [48, 07, 09, 18, 70, 26, 06],\n    [18, 72, 79, 46, 59, 79, 29, 90],\n    [20, 76, 87, 11, 32, 07, 07, 49, 18],\n    [27, 83, 58, 35, 71, 11, 25, 57, 29, 85],\n    [14, 64, 36, 96, 27, 11, 58, 56, 92, 18, 55],\n    [02, 90, 03, 60, 48, 49, 41, 46, 33, 36, 47, 23],\n    [92, 50, 48, 02, 36, 59, 42, 79, 72, 20, 82, 77, 42],\n    [56, 78, 38, 80, 39, 75, 02, 71, 66, 66, 01, 03, 55, 72],\n    [44, 25, 67, 84, 71, 67, 11, 61, 40, 57, 58, 89, 40, 56, 36],\n    [85, 32, 25, 85, 57, 48, 84, 35, 47, 62, 17, 01, 01, 99, 89, 52],\n    [06, 71, 28, 75, 94, 48, 37, 10, 23, 51, 06, 48, 53, 18, 74, 98, 15],\n    [27, 02, 92, 23, 08, 71, 76, 84, 15, 52, 92, 63, 81, 10, 44, 10, 69, 93]\n]\n\n@print maxpathsum test\n"}
{"id": 160136, "name": "Unix_ls", "source": "Translate Fortran to C#:       PROGRAM LS\t\t\n      USE DFLIB\t\t\t\n      TYPE(FILE$INFO) INFO\t\n      NAMELIST /HIC/INFO\t\n      INTEGER MARK,L\t\t\n\n      MARK = FILE$FIRST\t\t\nCall for the next file.\n   10 L = GETFILEINFOQQ(\"*\",INFO,MARK)\t\n      IF (MARK.EQ.FILE$ERROR) THEN\t\n        WRITE (6,*) \"Error\n        WRITE (6,HIC)\t\t\t\n        STOP \"That wasn't nice.\"\t\n      ELSE IF (IAND(INFO.PERMIT,FILE$DIR) .EQ. 0) THEN\t\n        IF (L.GT.0) WRITE (6,*) INFO.NAME(1:L)\t\n      END IF\t\t\t\t\n      IF (MARK.NE.FILE$LAST) GO TO 10\t\n      END\t\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.IO;\nusing System.Linq;\nusing System.Threading.Tasks;\n\nnamespace Unix_ls\n{\n    public class UnixLS\n    {\n        public static void Main(string[] args)\n        {\n            UnixLS ls = new UnixLS();\n            ls.list(args.Length.Equals(0) ? \".\" : args[0]);\n        }\n\n        private void list(string folder)\n        {\n            foreach (FileSystemInfo fileSystemInfo in new DirectoryInfo(folder).EnumerateFileSystemInfos(\"*\", SearchOption.TopDirectoryOnly))\n            {\n                Console.WriteLine(fileSystemInfo.Name);\n            }\n        }\n    }\n}\n"}
{"id": 160139, "name": "Unix_ls", "source": "Translate Fortran to Java:       PROGRAM LS\t\t\n      USE DFLIB\t\t\t\n      TYPE(FILE$INFO) INFO\t\n      NAMELIST /HIC/INFO\t\n      INTEGER MARK,L\t\t\n\n      MARK = FILE$FIRST\t\t\nCall for the next file.\n   10 L = GETFILEINFOQQ(\"*\",INFO,MARK)\t\n      IF (MARK.EQ.FILE$ERROR) THEN\t\n        WRITE (6,*) \"Error\n        WRITE (6,HIC)\t\t\t\n        STOP \"That wasn't nice.\"\t\n      ELSE IF (IAND(INFO.PERMIT,FILE$DIR) .EQ. 0) THEN\t\n        IF (L.GT.0) WRITE (6,*) INFO.NAME(1:L)\t\n      END IF\t\t\t\t\n      IF (MARK.NE.FILE$LAST) GO TO 10\t\n      END\t\n", "target": "package rosetta;\n\nimport java.io.IOException;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\n\npublic class UnixLS {\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tFiles.list(Path.of(\"\")).sorted().forEach(System.out::println);\n\t}\n}\n"}
{"id": 160140, "name": "Unix_ls", "source": "Translate Fortran to Python:       PROGRAM LS\t\t\n      USE DFLIB\t\t\t\n      TYPE(FILE$INFO) INFO\t\n      NAMELIST /HIC/INFO\t\n      INTEGER MARK,L\t\t\n\n      MARK = FILE$FIRST\t\t\nCall for the next file.\n   10 L = GETFILEINFOQQ(\"*\",INFO,MARK)\t\n      IF (MARK.EQ.FILE$ERROR) THEN\t\n        WRITE (6,*) \"Error\n        WRITE (6,HIC)\t\t\t\n        STOP \"That wasn't nice.\"\t\n      ELSE IF (IAND(INFO.PERMIT,FILE$DIR) .EQ. 0) THEN\t\n        IF (L.GT.0) WRITE (6,*) INFO.NAME(1:L)\t\n      END IF\t\t\t\t\n      IF (MARK.NE.FILE$LAST) GO TO 10\t\n      END\t\n", "target": ">>> import os\n>>> print('\\n'.join(sorted(os.listdir('.'))))\nDLLs\nDoc\nLICENSE.txt\nLib\nNEWS.txt\nREADME.txt\nScripts\nTools\ninclude\nlibs\npython.exe\npythonw.exe\ntcl\n>>>\n"}
{"id": 160281, "name": "Law of cosines - triples", "source": "Translate Fortran to C#: MODULE LAW_OF_COSINES\n    IMPLICIT NONE\n\n    CONTAINS\n\n    \n    REAL FUNCTION COSINE_SIDE(SIDE_A, SIDE_B, ANGLE)\n        INTEGER, INTENT(IN) :: SIDE_A, SIDE_B\n        REAL(8), INTENT(IN) :: ANGLE\n        \n        COSINE_SIDE = SIDE_A**2 + SIDE_B**2 - 2*SIDE_A*SIDE_B*COS(ANGLE)\n        COSINE_SIDE = COSINE_SIDE**0.5\n    END FUNCTION COSINE_SIDE\n\n    \n    REAL(8) FUNCTION DEG2RAD(ANGLE)\n        REAL(8), INTENT(IN) :: ANGLE\n        REAL(8), PARAMETER :: PI = 4.0D0*DATAN(1.D0)\n\n        DEG2RAD = ANGLE*(PI/180)\n    END FUNCTION DEG2RAD\n\n    \n    FUNCTION INT_SORTED(ARRAY) RESULT(SORTED)\n        INTEGER, DIMENSION(:), INTENT(IN) :: ARRAY\n        INTEGER, DIMENSION(SIZE(ARRAY)) :: SORTED, TEMP\n        INTEGER :: MAX_VAL, DIVIDE\n            \n        SORTED = ARRAY\n        TEMP = ARRAY\n        DIVIDE = SIZE(ARRAY)\n\n        DO WHILE (DIVIDE .NE. 1)\n            MAX_VAL = MAXVAL(SORTED(1:DIVIDE))\n            TEMP(DIVIDE) = MAX_VAL\n            TEMP(MAXLOC(SORTED(1:DIVIDE))) = SORTED(DIVIDE)\n            SORTED = TEMP\n            DIVIDE = DIVIDE - 1\n        END DO\n    END FUNCTION INT_SORTED\n\n    \n    SUBROUTINE APPEND(ARRAY, ELEMENT)\n        INTEGER, DIMENSION(:), ALLOCATABLE, INTENT(INOUT) :: ARRAY\n        INTEGER, DIMENSION(:), ALLOCATABLE :: TEMP\n        INTEGER :: ELEMENT\n        INTEGER :: I, ISIZE\n\n        IF (ALLOCATED(ARRAY)) THEN\n            ISIZE = SIZE(ARRAY)\n            ALLOCATE(TEMP(ISIZE+1))\n\n            DO I=1, ISIZE\n                TEMP(I) = ARRAY(I)\n            END DO\n\n            TEMP(ISIZE+1) = ELEMENT\n\n            DEALLOCATE(ARRAY)\n\n            CALL MOVE_ALLOC(TEMP, ARRAY)\n        ELSE\n            ALLOCATE(ARRAY(1))\n            ARRAY(1) = ELEMENT\n        END IF\n        \n    END SUBROUTINE APPEND\n\n    \n    LOGICAL FUNCTION CONTAINS_ARR(ARRAY, ELEMENT)\n        INTEGER, DIMENSION(:), INTENT(IN) :: ARRAY\n        INTEGER, DIMENSION(:) :: ELEMENT\n        INTEGER, DIMENSION(SIZE(ELEMENT)) :: TEMP, SORTED_ELEMENT\n        INTEGER :: I, COUNTER, J\n\n        COUNTER = 0\n\n        ELEMENT = INT_SORTED(ELEMENT)\n\n        DO I=1,SIZE(ARRAY),SIZE(ELEMENT)\n            TEMP = ARRAY(I:I+SIZE(ELEMENT)-1)\n            DO J=1,SIZE(ELEMENT)\n                IF (ELEMENT(J) .EQ. TEMP(J)) THEN\n                    COUNTER = COUNTER + 1\n                END IF\n            END DO\n\n            IF (COUNTER .EQ. SIZE(ELEMENT)) THEN\n                CONTAINS_ARR = .TRUE.\n                RETURN\n            END IF\n        END DO\n\n        CONTAINS_ARR = .FALSE.\n    END FUNCTION CONTAINS_ARR\n\n    \n    INTEGER FUNCTION COSINE_TRIPLES(MIN_NUM, MAX_NUM, ANGLE, PRINT_RESULTS) RESULT(COUNTER)\n        INTEGER, INTENT(IN) :: MIN_NUM, MAX_NUM\n        REAL(8), INTENT(IN) :: ANGLE\n        LOGICAL, INTENT(IN) :: PRINT_RESULTS\n        INTEGER, DIMENSION(:), ALLOCATABLE :: CANDIDATES\n        INTEGER, DIMENSION(3) :: CANDIDATE\n        INTEGER :: A, B\n        REAL :: C\n\n        COUNTER = 0\n\n        DO A = MIN_NUM, MAX_NUM\n            DO B = MIN_NUM, MAX_NUM\n                C = COSINE_SIDE(A, B, DEG2RAD(ANGLE))\n                IF (C .GT. MAX_NUM .OR. MOD(C, 1.) .NE. 0) THEN\n                    CYCLE\n                END IF\n\n                CANDIDATE(1) = A\n                CANDIDATE(2) = B\n                CANDIDATE(3) = C\n                IF (.NOT. CONTAINS_ARR(CANDIDATES, CANDIDATE)) THEN\n                    COUNTER = COUNTER + 1\n                    CALL APPEND(CANDIDATES, CANDIDATE(1))\n                    CALL APPEND(CANDIDATES, CANDIDATE(2))\n                    CALL APPEND(CANDIDATES, CANDIDATE(3))\n\n                    IF (PRINT_RESULTS) THEN\n                        WRITE(*,'(A,I0,A,I0,A,I0,A)') \" (\", CANDIDATE(1), \", \", CANDIDATE(2), \", \", CANDIDATE(3), \")\"\n                    END IF\n                END IF\n            END DO\n        END DO\n    END FUNCTION COSINE_TRIPLES\n                  \nEND MODULE LAW_OF_COSINES\n\n\n\n\n\n\nPROGRAM LOC\n    USE LAW_OF_COSINES\n\n    REAL(8), DIMENSION(3) :: TEST_ANGLES = (/90., 60., 120./)\n    INTEGER :: I, COUNTER\n\n    DO I = 1,SIZE(TEST_ANGLES)\n        WRITE(*, '(F0.0, A)') TEST_ANGLES(I), \" degree triangles: \" \n        COUNTER = COSINE_TRIPLES(1, 13, TEST_ANGLES(I), .TRUE.)\n        WRITE(*,'(A, I0)') \"TOTAL: \", COUNTER\n        WRITE(*,*) NEW_LINE('A')\n    END DO\n\nEND PROGRAM LOC\n", "target": "using System;\nusing System.Collections.Generic;\nusing static System.Linq.Enumerable;\n\npublic static class LawOfCosinesTriples\n{\n    public static void Main2() {\n        PrintTriples(60, 13);\n        PrintTriples(90, 13);\n        PrintTriples(120, 13);\n        PrintTriples(60, 10_000, true, false);\n    }\n\n    private static void PrintTriples(int degrees, int maxSideLength, bool notAllTheSameLength = false, bool print = true) {\n        string s = $\"{degrees} degree triangles in range 1..{maxSideLength}\";\n        if (notAllTheSameLength) s += \" where not all sides are the same\";\n        Console.WriteLine(s);\n        int count = 0;\n        var triples = FindTriples(degrees, maxSideLength);\n        if (notAllTheSameLength) triples = triples.Where(NotAllTheSameLength);\n        foreach (var triple in triples) {\n            count++;\n            if (print) Console.WriteLine(triple);\n        }\n        Console.WriteLine($\"{count} solutions\");\n    }\n\n    private static IEnumerable<(int a, int b, int c)> FindTriples(int degrees, int maxSideLength) {\n        double radians = degrees * Math.PI / 180;\n        int coefficient = (int)Math.Round(Math.Cos(radians) * -2, MidpointRounding.AwayFromZero);\n        int maxSideLengthSquared = maxSideLength * maxSideLength;\n        return\n            from a in Range(1, maxSideLength)\n            from b in Range(1, a)\n            let cc = a * a + b * b + a * b * coefficient\n            where cc <= maxSideLengthSquared\n            let c = (int)Math.Sqrt(cc)\n            where c * c == cc\n            select (a, b, c);\n    }\n\n    private static bool NotAllTheSameLength((int a, int b, int c) triple) => triple.a != triple.b || triple.a != triple.c;\n}\n"}
{"id": 160284, "name": "Law of cosines - triples", "source": "Translate Fortran to Java: MODULE LAW_OF_COSINES\n    IMPLICIT NONE\n\n    CONTAINS\n\n    \n    REAL FUNCTION COSINE_SIDE(SIDE_A, SIDE_B, ANGLE)\n        INTEGER, INTENT(IN) :: SIDE_A, SIDE_B\n        REAL(8), INTENT(IN) :: ANGLE\n        \n        COSINE_SIDE = SIDE_A**2 + SIDE_B**2 - 2*SIDE_A*SIDE_B*COS(ANGLE)\n        COSINE_SIDE = COSINE_SIDE**0.5\n    END FUNCTION COSINE_SIDE\n\n    \n    REAL(8) FUNCTION DEG2RAD(ANGLE)\n        REAL(8), INTENT(IN) :: ANGLE\n        REAL(8), PARAMETER :: PI = 4.0D0*DATAN(1.D0)\n\n        DEG2RAD = ANGLE*(PI/180)\n    END FUNCTION DEG2RAD\n\n    \n    FUNCTION INT_SORTED(ARRAY) RESULT(SORTED)\n        INTEGER, DIMENSION(:), INTENT(IN) :: ARRAY\n        INTEGER, DIMENSION(SIZE(ARRAY)) :: SORTED, TEMP\n        INTEGER :: MAX_VAL, DIVIDE\n            \n        SORTED = ARRAY\n        TEMP = ARRAY\n        DIVIDE = SIZE(ARRAY)\n\n        DO WHILE (DIVIDE .NE. 1)\n            MAX_VAL = MAXVAL(SORTED(1:DIVIDE))\n            TEMP(DIVIDE) = MAX_VAL\n            TEMP(MAXLOC(SORTED(1:DIVIDE))) = SORTED(DIVIDE)\n            SORTED = TEMP\n            DIVIDE = DIVIDE - 1\n        END DO\n    END FUNCTION INT_SORTED\n\n    \n    SUBROUTINE APPEND(ARRAY, ELEMENT)\n        INTEGER, DIMENSION(:), ALLOCATABLE, INTENT(INOUT) :: ARRAY\n        INTEGER, DIMENSION(:), ALLOCATABLE :: TEMP\n        INTEGER :: ELEMENT\n        INTEGER :: I, ISIZE\n\n        IF (ALLOCATED(ARRAY)) THEN\n            ISIZE = SIZE(ARRAY)\n            ALLOCATE(TEMP(ISIZE+1))\n\n            DO I=1, ISIZE\n                TEMP(I) = ARRAY(I)\n            END DO\n\n            TEMP(ISIZE+1) = ELEMENT\n\n            DEALLOCATE(ARRAY)\n\n            CALL MOVE_ALLOC(TEMP, ARRAY)\n        ELSE\n            ALLOCATE(ARRAY(1))\n            ARRAY(1) = ELEMENT\n        END IF\n        \n    END SUBROUTINE APPEND\n\n    \n    LOGICAL FUNCTION CONTAINS_ARR(ARRAY, ELEMENT)\n        INTEGER, DIMENSION(:), INTENT(IN) :: ARRAY\n        INTEGER, DIMENSION(:) :: ELEMENT\n        INTEGER, DIMENSION(SIZE(ELEMENT)) :: TEMP, SORTED_ELEMENT\n        INTEGER :: I, COUNTER, J\n\n        COUNTER = 0\n\n        ELEMENT = INT_SORTED(ELEMENT)\n\n        DO I=1,SIZE(ARRAY),SIZE(ELEMENT)\n            TEMP = ARRAY(I:I+SIZE(ELEMENT)-1)\n            DO J=1,SIZE(ELEMENT)\n                IF (ELEMENT(J) .EQ. TEMP(J)) THEN\n                    COUNTER = COUNTER + 1\n                END IF\n            END DO\n\n            IF (COUNTER .EQ. SIZE(ELEMENT)) THEN\n                CONTAINS_ARR = .TRUE.\n                RETURN\n            END IF\n        END DO\n\n        CONTAINS_ARR = .FALSE.\n    END FUNCTION CONTAINS_ARR\n\n    \n    INTEGER FUNCTION COSINE_TRIPLES(MIN_NUM, MAX_NUM, ANGLE, PRINT_RESULTS) RESULT(COUNTER)\n        INTEGER, INTENT(IN) :: MIN_NUM, MAX_NUM\n        REAL(8), INTENT(IN) :: ANGLE\n        LOGICAL, INTENT(IN) :: PRINT_RESULTS\n        INTEGER, DIMENSION(:), ALLOCATABLE :: CANDIDATES\n        INTEGER, DIMENSION(3) :: CANDIDATE\n        INTEGER :: A, B\n        REAL :: C\n\n        COUNTER = 0\n\n        DO A = MIN_NUM, MAX_NUM\n            DO B = MIN_NUM, MAX_NUM\n                C = COSINE_SIDE(A, B, DEG2RAD(ANGLE))\n                IF (C .GT. MAX_NUM .OR. MOD(C, 1.) .NE. 0) THEN\n                    CYCLE\n                END IF\n\n                CANDIDATE(1) = A\n                CANDIDATE(2) = B\n                CANDIDATE(3) = C\n                IF (.NOT. CONTAINS_ARR(CANDIDATES, CANDIDATE)) THEN\n                    COUNTER = COUNTER + 1\n                    CALL APPEND(CANDIDATES, CANDIDATE(1))\n                    CALL APPEND(CANDIDATES, CANDIDATE(2))\n                    CALL APPEND(CANDIDATES, CANDIDATE(3))\n\n                    IF (PRINT_RESULTS) THEN\n                        WRITE(*,'(A,I0,A,I0,A,I0,A)') \" (\", CANDIDATE(1), \", \", CANDIDATE(2), \", \", CANDIDATE(3), \")\"\n                    END IF\n                END IF\n            END DO\n        END DO\n    END FUNCTION COSINE_TRIPLES\n                  \nEND MODULE LAW_OF_COSINES\n\n\n\n\n\n\nPROGRAM LOC\n    USE LAW_OF_COSINES\n\n    REAL(8), DIMENSION(3) :: TEST_ANGLES = (/90., 60., 120./)\n    INTEGER :: I, COUNTER\n\n    DO I = 1,SIZE(TEST_ANGLES)\n        WRITE(*, '(F0.0, A)') TEST_ANGLES(I), \" degree triangles: \" \n        COUNTER = COSINE_TRIPLES(1, 13, TEST_ANGLES(I), .TRUE.)\n        WRITE(*,'(A, I0)') \"TOTAL: \", COUNTER\n        WRITE(*,*) NEW_LINE('A')\n    END DO\n\nEND PROGRAM LOC\n", "target": "public class LawOfCosines {\n\n    public static void main(String[] args) {\n        generateTriples(13);\n        generateTriples60(10000);\n    }\n    \n    private static void generateTriples(int max) {\n        for ( int coeff : new int[] {0, -1, 1} ) {\n            int count = 0;\n            System.out.printf(\"Max side length %d, formula:  a*a + b*b %s= c*c%n\", max, coeff == 0 ? \"\" : (coeff<0 ? \"-\"  : \"+\") + \" a*b \");\n            for ( int a = 1 ; a <= max ; a++ ) {\n                for ( int b = 1 ; b <= a ; b++ ) {\n                    int val = a*a + b*b + coeff*a*b;\n                    int c = (int) (Math.sqrt(val) + .5d);\n                    if ( c > max ) {\n                        break;\n                    }\n                    if ( c*c == val ) {\n                        System.out.printf(\"  (%d, %d, %d)%n\", a, b ,c);\n                        count++;\n                    }\n                }\n            }\n            System.out.printf(\"%d triangles%n\", count);\n        }        \n    }\n\n    private static void generateTriples60(int max) {\n        int count = 0;\n        System.out.printf(\"%nExtra Credit.%nMax side length %d, sides different length, formula:  a*a + b*b - a*b = c*c%n\", max);\n        for ( int a = 1 ; a <= max ; a++ ) {\n            for ( int b = 1 ; b < a ; b++ ) {\n                int val = a*a + b*b - a*b;\n                int c = (int) (Math.sqrt(val) + .5d);\n                if ( c*c == val ) {\n                    count++;\n                }\n            }\n        }\n        System.out.printf(\"%d triangles%n\", count);\n    }\n\n}\n"}
{"id": 160285, "name": "Law of cosines - triples", "source": "Translate Fortran to Python: MODULE LAW_OF_COSINES\n    IMPLICIT NONE\n\n    CONTAINS\n\n    \n    REAL FUNCTION COSINE_SIDE(SIDE_A, SIDE_B, ANGLE)\n        INTEGER, INTENT(IN) :: SIDE_A, SIDE_B\n        REAL(8), INTENT(IN) :: ANGLE\n        \n        COSINE_SIDE = SIDE_A**2 + SIDE_B**2 - 2*SIDE_A*SIDE_B*COS(ANGLE)\n        COSINE_SIDE = COSINE_SIDE**0.5\n    END FUNCTION COSINE_SIDE\n\n    \n    REAL(8) FUNCTION DEG2RAD(ANGLE)\n        REAL(8), INTENT(IN) :: ANGLE\n        REAL(8), PARAMETER :: PI = 4.0D0*DATAN(1.D0)\n\n        DEG2RAD = ANGLE*(PI/180)\n    END FUNCTION DEG2RAD\n\n    \n    FUNCTION INT_SORTED(ARRAY) RESULT(SORTED)\n        INTEGER, DIMENSION(:), INTENT(IN) :: ARRAY\n        INTEGER, DIMENSION(SIZE(ARRAY)) :: SORTED, TEMP\n        INTEGER :: MAX_VAL, DIVIDE\n            \n        SORTED = ARRAY\n        TEMP = ARRAY\n        DIVIDE = SIZE(ARRAY)\n\n        DO WHILE (DIVIDE .NE. 1)\n            MAX_VAL = MAXVAL(SORTED(1:DIVIDE))\n            TEMP(DIVIDE) = MAX_VAL\n            TEMP(MAXLOC(SORTED(1:DIVIDE))) = SORTED(DIVIDE)\n            SORTED = TEMP\n            DIVIDE = DIVIDE - 1\n        END DO\n    END FUNCTION INT_SORTED\n\n    \n    SUBROUTINE APPEND(ARRAY, ELEMENT)\n        INTEGER, DIMENSION(:), ALLOCATABLE, INTENT(INOUT) :: ARRAY\n        INTEGER, DIMENSION(:), ALLOCATABLE :: TEMP\n        INTEGER :: ELEMENT\n        INTEGER :: I, ISIZE\n\n        IF (ALLOCATED(ARRAY)) THEN\n            ISIZE = SIZE(ARRAY)\n            ALLOCATE(TEMP(ISIZE+1))\n\n            DO I=1, ISIZE\n                TEMP(I) = ARRAY(I)\n            END DO\n\n            TEMP(ISIZE+1) = ELEMENT\n\n            DEALLOCATE(ARRAY)\n\n            CALL MOVE_ALLOC(TEMP, ARRAY)\n        ELSE\n            ALLOCATE(ARRAY(1))\n            ARRAY(1) = ELEMENT\n        END IF\n        \n    END SUBROUTINE APPEND\n\n    \n    LOGICAL FUNCTION CONTAINS_ARR(ARRAY, ELEMENT)\n        INTEGER, DIMENSION(:), INTENT(IN) :: ARRAY\n        INTEGER, DIMENSION(:) :: ELEMENT\n        INTEGER, DIMENSION(SIZE(ELEMENT)) :: TEMP, SORTED_ELEMENT\n        INTEGER :: I, COUNTER, J\n\n        COUNTER = 0\n\n        ELEMENT = INT_SORTED(ELEMENT)\n\n        DO I=1,SIZE(ARRAY),SIZE(ELEMENT)\n            TEMP = ARRAY(I:I+SIZE(ELEMENT)-1)\n            DO J=1,SIZE(ELEMENT)\n                IF (ELEMENT(J) .EQ. TEMP(J)) THEN\n                    COUNTER = COUNTER + 1\n                END IF\n            END DO\n\n            IF (COUNTER .EQ. SIZE(ELEMENT)) THEN\n                CONTAINS_ARR = .TRUE.\n                RETURN\n            END IF\n        END DO\n\n        CONTAINS_ARR = .FALSE.\n    END FUNCTION CONTAINS_ARR\n\n    \n    INTEGER FUNCTION COSINE_TRIPLES(MIN_NUM, MAX_NUM, ANGLE, PRINT_RESULTS) RESULT(COUNTER)\n        INTEGER, INTENT(IN) :: MIN_NUM, MAX_NUM\n        REAL(8), INTENT(IN) :: ANGLE\n        LOGICAL, INTENT(IN) :: PRINT_RESULTS\n        INTEGER, DIMENSION(:), ALLOCATABLE :: CANDIDATES\n        INTEGER, DIMENSION(3) :: CANDIDATE\n        INTEGER :: A, B\n        REAL :: C\n\n        COUNTER = 0\n\n        DO A = MIN_NUM, MAX_NUM\n            DO B = MIN_NUM, MAX_NUM\n                C = COSINE_SIDE(A, B, DEG2RAD(ANGLE))\n                IF (C .GT. MAX_NUM .OR. MOD(C, 1.) .NE. 0) THEN\n                    CYCLE\n                END IF\n\n                CANDIDATE(1) = A\n                CANDIDATE(2) = B\n                CANDIDATE(3) = C\n                IF (.NOT. CONTAINS_ARR(CANDIDATES, CANDIDATE)) THEN\n                    COUNTER = COUNTER + 1\n                    CALL APPEND(CANDIDATES, CANDIDATE(1))\n                    CALL APPEND(CANDIDATES, CANDIDATE(2))\n                    CALL APPEND(CANDIDATES, CANDIDATE(3))\n\n                    IF (PRINT_RESULTS) THEN\n                        WRITE(*,'(A,I0,A,I0,A,I0,A)') \" (\", CANDIDATE(1), \", \", CANDIDATE(2), \", \", CANDIDATE(3), \")\"\n                    END IF\n                END IF\n            END DO\n        END DO\n    END FUNCTION COSINE_TRIPLES\n                  \nEND MODULE LAW_OF_COSINES\n\n\n\n\n\n\nPROGRAM LOC\n    USE LAW_OF_COSINES\n\n    REAL(8), DIMENSION(3) :: TEST_ANGLES = (/90., 60., 120./)\n    INTEGER :: I, COUNTER\n\n    DO I = 1,SIZE(TEST_ANGLES)\n        WRITE(*, '(F0.0, A)') TEST_ANGLES(I), \" degree triangles: \" \n        COUNTER = COSINE_TRIPLES(1, 13, TEST_ANGLES(I), .TRUE.)\n        WRITE(*,'(A, I0)') \"TOTAL: \", COUNTER\n        WRITE(*,*) NEW_LINE('A')\n    END DO\n\nEND PROGRAM LOC\n", "target": "N = 13\n\ndef method1(N=N):\n    squares = [x**2 for x in range(0, N+1)]\n    sqrset = set(squares)\n    tri90, tri60, tri120 = (set() for _ in range(3))\n    for a in range(1, N+1):\n        a2 = squares[a]\n        for b in range(1, a + 1):\n            b2 = squares[b]\n            c2 = a2 + b2\n            if c2 in sqrset:\n                tri90.add(tuple(sorted((a, b, int(c2**0.5)))))\n            ab = a * b\n            c2 -= ab\n            if c2 in sqrset:\n                tri60.add(tuple(sorted((a, b, int(c2**0.5)))))\n            c2 += 2 * ab\n            if c2 in sqrset:\n                tri120.add(tuple(sorted((a, b, int(c2**0.5)))))\n    return  sorted(tri90), sorted(tri60), sorted(tri120)\n\nif __name__ == '__main__':\n    print(f'Integer triangular triples for sides 1..{N}:')\n    for angle, triples in zip([90, 60, 120], method1(N)):\n        print(f'  {angle:3}\u00b0 has {len(triples)} solutions:\\n    {triples}')\n    _, t60, _ = method1(10_000)\n    notsame = sum(1 for a, b, c in t60 if a != b or b != c)\n    print('Extra credit:', notsame)\n"}
{"id": 160421, "name": "Top rank per group", "source": "Translate Fortran to C#:       DATA EMPLOYEE(1:3)/\n     1 GRIST(\"Tyler Bennett\",\"E10297\",32000,\"D101\"),\n     2 GRIST(\"John Rappl\",\"E21437\",47000,\"D050\"),\n     3 GRIST(\"George Woltman\",\"E00127\",53500,\"D101\")/\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\npublic class Program\n{\n    class Employee\n    {\n        public Employee(string name, string id, int salary, string department)\n        {\n            Name = name;\n            Id = id;\n            Salary = salary;\n            Department = department;\n        }\n\n        public string Name { get; private set; }\n        public string Id { get; private set; }\n        public int Salary { get; private set; }\n        public string Department { get; private set; }\n\n        public override string ToString()\n        {\n            return String.Format(\"{0, -25}\\t{1}\\t{2}\", Name, Id, Salary);\n        }\n    }\n\n    private static void Main(string[] args)\n    {\n        var employees = new List<Employee>\n                        {\n                            new Employee(\"Tyler Bennett\", \"E10297\", 32000, \"D101\"),\n                            new Employee(\"John Rappl\", \"E21437\", 47000, \"D050\"),\n                            new Employee(\"George Woltman\", \"E21437\", 53500, \"D101\"),\n                            new Employee(\"Adam Smith\", \"E21437\", 18000, \"D202\"),\n                            new Employee(\"Claire Buckman\", \"E39876\", 27800, \"D202\"),\n                            new Employee(\"David McClellan\", \"E04242\", 41500, \"D101\"),\n                            new Employee(\"Rich Holcomb\", \"E01234\", 49500, \"D202\"),\n                            new Employee(\"Nathan Adams\", \"E41298\", 21900, \"D050\"),\n                            new Employee(\"Richard Potter\", \"E43128\", 15900, \"D101\"),\n                            new Employee(\"David Motsinger\", \"E27002\", 19250, \"D202\"),\n                            new Employee(\"Tim Sampair\", \"E03033\", 27000, \"D101\"),\n                            new Employee(\"Kim Arlich\", \"E10001\", 57000, \"D190\"),\n                            new Employee(\"Timothy Grove\", \"E16398\", 29900, \"D190\")\n                        };\n\n        DisplayTopNPerDepartment(employees, 2);\n    }\n\n    static void DisplayTopNPerDepartment(IEnumerable<Employee> employees, int n)\n    {\n        var topSalariesByDepartment =\n            from employee in employees\n            group employee by employee.Department\n            into g\n            select new\n                    {\n                        Department = g.Key,\n                        TopEmployeesBySalary = g.OrderByDescending(e => e.Salary).Take(n)\n                    };\n\n        foreach (var x in topSalariesByDepartment)\n        {\n            Console.WriteLine(\"Department: \" + x.Department);\n            foreach (var employee in x.TopEmployeesBySalary)\n                Console.WriteLine(employee);\n            Console.WriteLine(\"----------------------------\");\n        }\n    }\n}\n"}
{"id": 160424, "name": "Top rank per group", "source": "Translate Fortran to Java:       DATA EMPLOYEE(1:3)/\n     1 GRIST(\"Tyler Bennett\",\"E10297\",32000,\"D101\"),\n     2 GRIST(\"John Rappl\",\"E21437\",47000,\"D050\"),\n     3 GRIST(\"George Woltman\",\"E00127\",53500,\"D101\")/\n", "target": "import java.io.File;\nimport java.util.*;\n\npublic class TopRankPerGroup {\n\n    private static class Employee {\n        final String name;\n        final String id;\n        final String department;\n        final int salary;\n\n        Employee(String[] rec) {\n            name = rec[0];\n            id = rec[1];\n            salary = Integer.parseInt(rec[2]);\n            department = rec[3];\n        }\n\n        @Override\n        public String toString() {\n            return String.format(\"%s %s %d %s\", id, name, salary, department);\n        }\n    }\n\n    public static void main(String[] args) throws Exception {\n        int N = args.length > 0 ? Integer.parseInt(args[0]) : 3;\n\n        Map<String, List<Employee>> records = new TreeMap<>();\n        try (Scanner sc = new Scanner(new File(\"data.txt\"))) {\n            while (sc.hasNextLine()) {\n                String[] rec = sc.nextLine().trim().split(\", \");\n\n                List<Employee> lst = records.get(rec[3]);\n                if (lst == null) {\n                    lst = new ArrayList<>();\n                    records.put(rec[3], lst);\n                }\n                lst.add(new Employee(rec));\n            }\n        }\n\n        records.forEach((key, val) -> {\n            System.out.printf(\"%nDepartment %s%n\", key);\n            val.stream()\n                .sorted((a, b) -> Integer.compare(b.salary, a.salary))\n                .limit(N).forEach(System.out::println);\n        });\n    }\n}\n"}
{"id": 160425, "name": "Top rank per group", "source": "Translate Fortran to Python:       DATA EMPLOYEE(1:3)/\n     1 GRIST(\"Tyler Bennett\",\"E10297\",32000,\"D101\"),\n     2 GRIST(\"John Rappl\",\"E21437\",47000,\"D050\"),\n     3 GRIST(\"George Woltman\",\"E00127\",53500,\"D101\")/\n", "target": "from collections import defaultdict\nfrom heapq import nlargest\n \ndata = [('Employee Name', 'Employee ID', 'Salary', 'Department'),\n        ('Tyler Bennett', 'E10297', 32000, 'D101'),\n        ('John Rappl', 'E21437', 47000, 'D050'),\n        ('George Woltman', 'E00127', 53500, 'D101'),\n        ('Adam Smith', 'E63535', 18000, 'D202'),\n        ('Claire Buckman', 'E39876', 27800, 'D202'),\n        ('David McClellan', 'E04242', 41500, 'D101'),\n        ('Rich Holcomb', 'E01234', 49500, 'D202'),\n        ('Nathan Adams', 'E41298', 21900, 'D050'),\n        ('Richard Potter', 'E43128', 15900, 'D101'),\n        ('David Motsinger', 'E27002', 19250, 'D202'),\n        ('Tim Sampair', 'E03033', 27000, 'D101'),\n        ('Kim Arlich', 'E10001', 57000, 'D190'),\n        ('Timothy Grove', 'E16398', 29900, 'D190')]\n \ndepartments = defaultdict(list)\nfor rec in data[1:]:\n    departments[rec[-1]].append(rec)\n \nN = 3\nformat = \" %-15s \" * len(data[0])\nfor department, recs in sorted(departments.items()):\n    print (\"Department %s\" % department)\n    print (format % data[0])\n    for rec in nlargest(N, recs, key=lambda rec: rec[-2]):\n        print (format % rec)\n    print('')\n"}
{"id": 160660, "name": "Subleq", "source": "Translate Fortran to C#:       PROGRAM SUBLEQ0\t\n      INTEGER LOTS,LOAD\t\t\n      PARAMETER (LOTS = 36, LOAD = 31)\t\n      INTEGER IAR, MEM(0:LOTS)\t\t\n      INTEGER ABC(3),A,B,C\t\t\n      EQUIVALENCE (ABC(1),A),(ABC(2),B),(ABC(3),C)\t\n      INTEGER INITIAL(0:LOAD)\t\t\n      DATA INITIAL/15,17,-1,17,-1,-1,16,1,-1,16,3,-1,15,15,0,0,-1,\t\n     1          72,101,108,108,111,44,32,119,111,114,108,100,33,10,0/\t\nCore memory initialisation.\n      MEM = -66\t\t\t\n      MEM(0:LOAD) = INITIAL\t\n      IAR = 0\t\t\t\nCommence execution of the current instruction.\n  100 ABC = MEM(IAR:IAR + 2)\t\n      IAR = IAR + 3\t\t\n      IF (A .EQ. -1) THEN\t\n        WRITE (6,102)\t\t\t\n  102   FORMAT (\" A number:\",$)\t\t\n        READ (5,*) MEM(B)\t\t\n      ELSE IF (B .EQ. -1) THEN\t\n        WRITE (6,103) CHAR(MEM(A))\t\n  103   FORMAT (A1,$)\t\t\t\n      ELSE\t\t\t\n        MEM(B) = MEM(B) - MEM(A)\t\n        IF (MEM(B).LE.0) IAR = C\t\n      END IF\t\t\t\n      IF (IAR.GE.0) GO TO 100\t\n      END\t\n", "target": "using System;\n\nnamespace Subleq {\n    class Program {\n        static void Main(string[] args) {\n            int[] mem = {\n                15, 17, -1, 17, -1, -1, 16, 1, -1, 16,\n                3, -1, 15, 15, 0, 0, -1, 72, 101, 108,\n                108, 111, 44, 32, 119, 111, 114, 108, 100, 33,\n                10, 0,\n            };\n\n            int instructionPointer = 0;\n\n            do {\n                int a = mem[instructionPointer];\n                int b = mem[instructionPointer + 1];\n\n                if (a == -1) {\n                    mem[b] = Console.Read();\n                }\n                else if (b == -1) {\n                    Console.Write((char)mem[a]);\n                }\n                else {\n                    mem[b] -= mem[a];\n                    if (mem[b] < 1) {\n                        instructionPointer = mem[instructionPointer + 2];\n                        continue;\n                    }\n                }\n\n                instructionPointer += 3;\n            } while (instructionPointer >= 0);\n        }\n    }\n}\n"}
{"id": 160663, "name": "Subleq", "source": "Translate Fortran to Java:       PROGRAM SUBLEQ0\t\n      INTEGER LOTS,LOAD\t\t\n      PARAMETER (LOTS = 36, LOAD = 31)\t\n      INTEGER IAR, MEM(0:LOTS)\t\t\n      INTEGER ABC(3),A,B,C\t\t\n      EQUIVALENCE (ABC(1),A),(ABC(2),B),(ABC(3),C)\t\n      INTEGER INITIAL(0:LOAD)\t\t\n      DATA INITIAL/15,17,-1,17,-1,-1,16,1,-1,16,3,-1,15,15,0,0,-1,\t\n     1          72,101,108,108,111,44,32,119,111,114,108,100,33,10,0/\t\nCore memory initialisation.\n      MEM = -66\t\t\t\n      MEM(0:LOAD) = INITIAL\t\n      IAR = 0\t\t\t\nCommence execution of the current instruction.\n  100 ABC = MEM(IAR:IAR + 2)\t\n      IAR = IAR + 3\t\t\n      IF (A .EQ. -1) THEN\t\n        WRITE (6,102)\t\t\t\n  102   FORMAT (\" A number:\",$)\t\t\n        READ (5,*) MEM(B)\t\t\n      ELSE IF (B .EQ. -1) THEN\t\n        WRITE (6,103) CHAR(MEM(A))\t\n  103   FORMAT (A1,$)\t\t\t\n      ELSE\t\t\t\n        MEM(B) = MEM(B) - MEM(A)\t\n        IF (MEM(B).LE.0) IAR = C\t\n      END IF\t\t\t\n      IF (IAR.GE.0) GO TO 100\t\n      END\t\n", "target": "import java.util.Scanner;\n\npublic class Subleq {\n\n    public static void main(String[] args) {\n        int[] mem = {15, 17, -1, 17, -1, -1, 16, 1, -1, 16, 3, -1, 15, 15, 0, 0,\n            -1, 72, 101, 108, 108, 111, 44, 32, 119, 111, 114, 108, 100, 33, 10, 0};\n\n        Scanner input = new Scanner(System.in);\n        int instructionPointer = 0;\n\n        do {\n            int a = mem[instructionPointer];\n            int b = mem[instructionPointer + 1];\n\n            if (a == -1) {\n                mem[b] = input.nextInt();\n\n            } else if (b == -1) {\n                System.out.printf(\"%c\", (char) mem[a]);\n\n            } else {\n\n                mem[b] -= mem[a];\n                if (mem[b] < 1) {\n                    instructionPointer = mem[instructionPointer + 2];\n                    continue;\n                }\n            }\n\n            instructionPointer += 3;\n\n        } while (instructionPointer >= 0);\n    }\n}\n"}
{"id": 160664, "name": "Subleq", "source": "Translate Fortran to Python:       PROGRAM SUBLEQ0\t\n      INTEGER LOTS,LOAD\t\t\n      PARAMETER (LOTS = 36, LOAD = 31)\t\n      INTEGER IAR, MEM(0:LOTS)\t\t\n      INTEGER ABC(3),A,B,C\t\t\n      EQUIVALENCE (ABC(1),A),(ABC(2),B),(ABC(3),C)\t\n      INTEGER INITIAL(0:LOAD)\t\t\n      DATA INITIAL/15,17,-1,17,-1,-1,16,1,-1,16,3,-1,15,15,0,0,-1,\t\n     1          72,101,108,108,111,44,32,119,111,114,108,100,33,10,0/\t\nCore memory initialisation.\n      MEM = -66\t\t\t\n      MEM(0:LOAD) = INITIAL\t\n      IAR = 0\t\t\t\nCommence execution of the current instruction.\n  100 ABC = MEM(IAR:IAR + 2)\t\n      IAR = IAR + 3\t\t\n      IF (A .EQ. -1) THEN\t\n        WRITE (6,102)\t\t\t\n  102   FORMAT (\" A number:\",$)\t\t\n        READ (5,*) MEM(B)\t\t\n      ELSE IF (B .EQ. -1) THEN\t\n        WRITE (6,103) CHAR(MEM(A))\t\n  103   FORMAT (A1,$)\t\t\t\n      ELSE\t\t\t\n        MEM(B) = MEM(B) - MEM(A)\t\n        IF (MEM(B).LE.0) IAR = C\t\n      END IF\t\t\t\n      IF (IAR.GE.0) GO TO 100\t\n      END\t\n", "target": "import sys\n\ndef subleq(a):\n    i = 0\n    try:\n        while i >= 0:\n            if a[i] == -1:\n                a[a[i + 1]] = ord(sys.stdin.read(1))\n            elif a[i + 1] == -1:\n                print(chr(a[a[i]]), end=\"\")\n            else:\n                a[a[i + 1]] -= a[a[i]]\n                if a[a[i + 1]] <= 0:\n                    i = a[i + 2]\n                    continue\n            i += 3\n    except (ValueError, IndexError, KeyboardInterrupt):\n        print(\"abort\")\n        print(a)\n\nsubleq([15, 17, -1, 17, -1, -1, 16, 1, -1, 16, 3, -1, 15, 15,\n        0, 0, -1, 72, 101, 108, 108, 111, 44, 32, 119, 111,\n        114, 108, 100, 33, 10, 0])\n"}
{"id": 160998, "name": "Range extraction", "source": "Translate Fortran to C#:       SUBROUTINE IRANGE(TEXT)\t\nCould make this a function, but then a maximum text length returned would have to be specified.\n       CHARACTER*(*) TEXT\t\n       INTEGER LOTS\t\t\n       PARAMETER (LOTS = 666)\t\n       INTEGER VAL(LOTS)\t\n       INTEGER N\t\t\n       INTEGER I,I1\t\t\n        N = 1\t\t\n        DO I = 1,LEN(TEXT)\t\n          IF (TEXT(I:I).EQ.\",\") N = N + 1\t\n        END DO\t\t\t\n        IF (N.LE.2) RETURN\t\n        IF (N.GT.LOTS) STOP \"Too many values\n        READ (TEXT,*) VAL(1:N)\t\n        TEXT = \"\"\t\t\n        L = 0\t\t\t\n        I1 = 1\t\t\t\n   10   IF (L.GT.0) CALL EMIT(\",\")\t\n        CALL SPLOT(VAL(I1))\t\t\n        DO I = I1 + 1,N\t\t\t\n          IF (VAL(I - 1) + 1 .NE. VAL(I)) EXIT\t\n        END DO\t\t\t\t\n        IF (I - I1 .GT. 2) THEN\t\t\n          CALL EMIT(\"-\")\t\t\n          CALL SPLOT(VAL(I - 1))\t\n          I1 = I\t\t\t\n         ELSE\t\t\t\n          I1 = I1 + 1\t\t\t\n        END IF\t\t\t\n        IF (I.LE.N) GO TO 10\t\n       CONTAINS\t\t\n        SUBROUTINE EMIT(C)\t\n         CHARACTER*1 C\t\t\n          L = L + 1\t\t\n          IF (L.GT.LEN(TEXT)) STOP \"Ran out of text\n          TEXT(L:L) = C\t\t\n        END SUBROUTINE EMIT\t\n        SUBROUTINE SPLOT(N)\t\n         INTEGER N\t\t\n         CHARACTER*12 FIELD\t\n         INTEGER I\t\t\n          WRITE (FIELD,\"(I0)\") N\n          DO I = 1,12\t\t\n            IF (FIELD(I:I).LE.\" \") EXIT\t\n            CALL EMIT(FIELD(I:I))\t\n          END DO\t\t\n        END SUBROUTINE SPLOT\t\n      END\t\n\n      PROGRAM POKE\n      CHARACTER*(200) SOME\n      SOME = \"  0,  1,  2,  4,  6,  7,  8, 11, 12, 14,  \"\n     1      //\"  15, 16, 17, 18, 19, 20, 21, 22, 23, 24,\"\n     2      //\"25, 27, 28, 29, 30, 31, 32, 33, 35, 36,  \"\n     3      //\"37, 38, 39                               \"\n      CALL IRANGE(SOME)\n      WRITE (6,*) SOME\n      END\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\nclass RangeExtraction\n{\n    static void Main()\n    {\n        const string testString = \"0,  1,  2,  4,  6,  7,  8, 11, 12, 14,15, 16, 17, 18, 19, 20, 21, 22, 23, 24,25, 27, 28, 29, 30, 31, 32, 33, 35, 36,37, 38, 39\";\n        var result = String.Join(\",\", RangesToStrings(GetRanges(testString)));\n        Console.Out.WriteLine(result);\n    }\n\n    public static IEnumerable<IEnumerable<int>> GetRanges(string testString)\n    {\n        var numbers = testString.Split(new[] { ',' }).Select(x => Convert.ToInt32(x));\n        var current = new List<int>();\n        foreach (var n in numbers)\n        {\n            if (current.Count == 0)\n            {\n                current.Add(n);\n            }\n            else\n            {\n                if (current.Max() + 1 == n)\n                {\n                    current.Add(n);\n                }\n                else\n                {\n                    yield return current;\n                    current = new List<int> { n };\n                }\n            }\n        }\n        yield return current;\n    }\n\n    public static IEnumerable<string> RangesToStrings(IEnumerable<IEnumerable<int>> ranges)\n    {\n        foreach (var range in ranges)\n        {\n            if (range.Count() == 1)\n            {\n                yield return range.Single().ToString();\n            }\n            else if (range.Count() == 2)\n            {\n                yield return range.Min() + \",\" + range.Max();\n            }\n            else\n            {\n                yield return range.Min() + \"-\" + range.Max();\n            }\n        }\n    }\n}\n"}
{"id": 161001, "name": "Range extraction", "source": "Translate Fortran to Java:       SUBROUTINE IRANGE(TEXT)\t\nCould make this a function, but then a maximum text length returned would have to be specified.\n       CHARACTER*(*) TEXT\t\n       INTEGER LOTS\t\t\n       PARAMETER (LOTS = 666)\t\n       INTEGER VAL(LOTS)\t\n       INTEGER N\t\t\n       INTEGER I,I1\t\t\n        N = 1\t\t\n        DO I = 1,LEN(TEXT)\t\n          IF (TEXT(I:I).EQ.\",\") N = N + 1\t\n        END DO\t\t\t\n        IF (N.LE.2) RETURN\t\n        IF (N.GT.LOTS) STOP \"Too many values\n        READ (TEXT,*) VAL(1:N)\t\n        TEXT = \"\"\t\t\n        L = 0\t\t\t\n        I1 = 1\t\t\t\n   10   IF (L.GT.0) CALL EMIT(\",\")\t\n        CALL SPLOT(VAL(I1))\t\t\n        DO I = I1 + 1,N\t\t\t\n          IF (VAL(I - 1) + 1 .NE. VAL(I)) EXIT\t\n        END DO\t\t\t\t\n        IF (I - I1 .GT. 2) THEN\t\t\n          CALL EMIT(\"-\")\t\t\n          CALL SPLOT(VAL(I - 1))\t\n          I1 = I\t\t\t\n         ELSE\t\t\t\n          I1 = I1 + 1\t\t\t\n        END IF\t\t\t\n        IF (I.LE.N) GO TO 10\t\n       CONTAINS\t\t\n        SUBROUTINE EMIT(C)\t\n         CHARACTER*1 C\t\t\n          L = L + 1\t\t\n          IF (L.GT.LEN(TEXT)) STOP \"Ran out of text\n          TEXT(L:L) = C\t\t\n        END SUBROUTINE EMIT\t\n        SUBROUTINE SPLOT(N)\t\n         INTEGER N\t\t\n         CHARACTER*12 FIELD\t\n         INTEGER I\t\t\n          WRITE (FIELD,\"(I0)\") N\n          DO I = 1,12\t\t\n            IF (FIELD(I:I).LE.\" \") EXIT\t\n            CALL EMIT(FIELD(I:I))\t\n          END DO\t\t\n        END SUBROUTINE SPLOT\t\n      END\t\n\n      PROGRAM POKE\n      CHARACTER*(200) SOME\n      SOME = \"  0,  1,  2,  4,  6,  7,  8, 11, 12, 14,  \"\n     1      //\"  15, 16, 17, 18, 19, 20, 21, 22, 23, 24,\"\n     2      //\"25, 27, 28, 29, 30, 31, 32, 33, 35, 36,  \"\n     3      //\"37, 38, 39                               \"\n      CALL IRANGE(SOME)\n      WRITE (6,*) SOME\n      END\n", "target": "public class RangeExtraction {\n\n    public static void main(String[] args) {\n        int[] arr = {0, 1, 2, 4, 6, 7, 8, 11, 12, 14,\n            15, 16, 17, 18, 19, 20, 21, 22, 23, 24,\n            25, 27, 28, 29, 30, 31, 32, 33, 35, 36,\n            37, 38, 39};\n\n        int len = arr.length;\n        int idx = 0, idx2 = 0;\n        while (idx < len) {\n            while (++idx2 < len && arr[idx2] - arr[idx2 - 1] == 1);\n            if (idx2 - idx > 2) {\n                System.out.printf(\"%s-%s,\", arr[idx], arr[idx2 - 1]);\n                idx = idx2;\n            } else {\n                for (; idx < idx2; idx++)\n                    System.out.printf(\"%s,\", arr[idx]);\n            }\n        }\n    }\n}\n"}
{"id": 161002, "name": "Range extraction", "source": "Translate Fortran to Python:       SUBROUTINE IRANGE(TEXT)\t\nCould make this a function, but then a maximum text length returned would have to be specified.\n       CHARACTER*(*) TEXT\t\n       INTEGER LOTS\t\t\n       PARAMETER (LOTS = 666)\t\n       INTEGER VAL(LOTS)\t\n       INTEGER N\t\t\n       INTEGER I,I1\t\t\n        N = 1\t\t\n        DO I = 1,LEN(TEXT)\t\n          IF (TEXT(I:I).EQ.\",\") N = N + 1\t\n        END DO\t\t\t\n        IF (N.LE.2) RETURN\t\n        IF (N.GT.LOTS) STOP \"Too many values\n        READ (TEXT,*) VAL(1:N)\t\n        TEXT = \"\"\t\t\n        L = 0\t\t\t\n        I1 = 1\t\t\t\n   10   IF (L.GT.0) CALL EMIT(\",\")\t\n        CALL SPLOT(VAL(I1))\t\t\n        DO I = I1 + 1,N\t\t\t\n          IF (VAL(I - 1) + 1 .NE. VAL(I)) EXIT\t\n        END DO\t\t\t\t\n        IF (I - I1 .GT. 2) THEN\t\t\n          CALL EMIT(\"-\")\t\t\n          CALL SPLOT(VAL(I - 1))\t\n          I1 = I\t\t\t\n         ELSE\t\t\t\n          I1 = I1 + 1\t\t\t\n        END IF\t\t\t\n        IF (I.LE.N) GO TO 10\t\n       CONTAINS\t\t\n        SUBROUTINE EMIT(C)\t\n         CHARACTER*1 C\t\t\n          L = L + 1\t\t\n          IF (L.GT.LEN(TEXT)) STOP \"Ran out of text\n          TEXT(L:L) = C\t\t\n        END SUBROUTINE EMIT\t\n        SUBROUTINE SPLOT(N)\t\n         INTEGER N\t\t\n         CHARACTER*12 FIELD\t\n         INTEGER I\t\t\n          WRITE (FIELD,\"(I0)\") N\n          DO I = 1,12\t\t\n            IF (FIELD(I:I).LE.\" \") EXIT\t\n            CALL EMIT(FIELD(I:I))\t\n          END DO\t\t\n        END SUBROUTINE SPLOT\t\n      END\t\n\n      PROGRAM POKE\n      CHARACTER*(200) SOME\n      SOME = \"  0,  1,  2,  4,  6,  7,  8, 11, 12, 14,  \"\n     1      //\"  15, 16, 17, 18, 19, 20, 21, 22, 23, 24,\"\n     2      //\"25, 27, 28, 29, 30, 31, 32, 33, 35, 36,  \"\n     3      //\"37, 38, 39                               \"\n      CALL IRANGE(SOME)\n      WRITE (6,*) SOME\n      END\n", "target": "def range_extract(lst):\n    'Yield 2-tuple ranges or 1-tuple single elements from list of increasing ints'\n    lenlst = len(lst)\n    i = 0\n    while i< lenlst:\n        low = lst[i]\n        while i <lenlst-1 and lst[i]+1 == lst[i+1]: i +=1\n        hi = lst[i]\n        if   hi - low >= 2:\n            yield (low, hi)\n        elif hi - low == 1:\n            yield (low,)\n            yield (hi,)\n        else:\n            yield (low,)\n        i += 1\n\ndef printr(ranges):\n    print( ','.join( (('%i-%i' % r) if len(r) == 2 else '%i' % r)\n                     for r in ranges ) )\n\nif __name__ == '__main__':\n    for lst in [[-8, -7, -6, -3, -2, -1, 0, 1, 3, 4, 5, 7,\n                 8, 9, 10, 11, 14, 15, 17, 18, 19, 20],\n                [0, 1, 2, 4, 6, 7, 8, 11, 12, 14, 15, 16, 17, 18, 19, 20, 21, 22,\n                 23, 24, 25, 27, 28, 29, 30, 31, 32, 33, 35, 36, 37, 38, 39]]:\n        \n        printr(range_extract(lst))\n"}
{"id": 161348, "name": "Zeckendorf number representation", "source": "Translate Fortran to C#: F(N) = ((1 + SQRT(5))**N - (1 - SQRT(5))**N)/(SQRT(5)*2**N)\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\nnamespace Zeckendorf\n{\n    class Program\n    {\n        private static uint Fibonacci(uint n)\n        {\n            if (n < 2)\n            {\n                return n;\n            }\n            else\n            {\n                return Fibonacci(n - 1) + Fibonacci(n - 2);\n            }\n        }\n\n        private static string Zeckendorf(uint num)\n        {\n            IList<uint> fibonacciNumbers = new List<uint>();\n            uint fibPosition = 2;\n\n            uint currentFibonaciNum = Fibonacci(fibPosition);\n\n            do\n            {\n                fibonacciNumbers.Add(currentFibonaciNum);\n                currentFibonaciNum = Fibonacci(++fibPosition);\n            } while (currentFibonaciNum <= num);\n\n            uint temp = num;\n            StringBuilder output = new StringBuilder();\n\n            foreach (uint item in fibonacciNumbers.Reverse())\n            {\n                if (item <= temp)\n                {\n                    output.Append(\"1\");\n                    temp -= item;\n                }\n                else\n                {\n                    output.Append(\"0\");\n                }\n            }\n\n            return output.ToString();\n        }\n\n        static void Main(string[] args)\n        {\n            for (uint i = 1; i <= 20; i++)\n            {\n                string zeckendorfRepresentation = Zeckendorf(i);\n                Console.WriteLine(string.Format(\"{0}\u00a0: {1}\", i, zeckendorfRepresentation));\n            }\n\n            Console.ReadKey();\n        }\n    }\n}\n"}
{"id": 161351, "name": "Zeckendorf number representation", "source": "Translate Fortran to Java: F(N) = ((1 + SQRT(5))**N - (1 - SQRT(5))**N)/(SQRT(5)*2**N)\n", "target": "import java.util.*;\n\nclass Zeckendorf\n{\n  public static String getZeckendorf(int n)\n  {\n    if (n == 0)\n      return \"0\";\n    List<Integer> fibNumbers = new ArrayList<Integer>();\n    fibNumbers.add(1);\n    int nextFib = 2;\n    while (nextFib <= n)\n    {\n      fibNumbers.add(nextFib);\n      nextFib += fibNumbers.get(fibNumbers.size() - 2);\n    }\n    StringBuilder sb = new StringBuilder();\n    for (int i = fibNumbers.size() - 1; i >= 0; i--)\n    {\n      int fibNumber = fibNumbers.get(i);\n      sb.append((fibNumber <= n) ? \"1\" : \"0\");\n      if (fibNumber <= n)\n        n -= fibNumber;\n    }\n    return sb.toString();\n  }\n  \n  public static void main(String[] args)\n  {\n    for (int i = 0; i <= 20; i++)\n      System.out.println(\"Z(\" + i + \")=\" + getZeckendorf(i));\n  }\n}\n"}
{"id": 161352, "name": "Zeckendorf number representation", "source": "Translate Fortran to Python: F(N) = ((1 + SQRT(5))**N - (1 - SQRT(5))**N)/(SQRT(5)*2**N)\n", "target": "def fib():\n    memo = [1, 2]\n    while True:\n        memo.append(sum(memo))\n        yield memo.pop(0)\n\ndef sequence_down_from_n(n, seq_generator):\n    seq = []\n    for s in seq_generator():\n        seq.append(s)\n        if s >= n: break\n    return seq[::-1]\n\ndef zeckendorf(n):\n    if n == 0: return [0]\n    seq = sequence_down_from_n(n, fib)\n    digits, nleft = [], n\n    for s in seq:\n        if s <= nleft:\n            digits.append(1)\n            nleft -= s\n        else:\n            digits.append(0)\n    assert nleft == 0, 'Check all of n is accounted for'\n    assert sum(x*y for x,y in zip(digits, seq)) == n, 'Assert digits are correct'\n    while digits[0] == 0:\n        \n        digits.pop(0)\n    return digits\n\nn = 20\nprint('Fibonacci digit multipliers: %r' % sequence_down_from_n(n, fib))\nfor i in range(n + 1):\n    print('%3i: %8s' % (i, ''.join(str(d) for d in zeckendorf(i))))\n"}
{"id": 161578, "name": "Reverse words in a string", "source": "Translate Fortran to C#:  character*40 words\n character*40 reversed\n logical inblank\n ierr=0\n read (5,fmt=\"(a)\",iostat=ierr)words\n do while (ierr.eq.0)\n inblank=.true.\n ipos=1\n do i=40,1,-1\n   if(words(i:i).ne.' '.and.inblank) then\n     last=i\n     inblank=.false.\n     end if\n    if(.not.inblank.and.words(i:i).eq.' ') then\n      reversed(ipos:ipos+last-i)=words(i+1:last)\n      ipos=ipos+last-i+1\n      inblank=.true.\n      end if\n     if(.not.inblank.and.i.eq.1) then\n       reversed(ipos:ipos+last-1)=words(1:last)\n       ipos=ipos+last\n       end if\n   end do\n print *,words,'=> ',reversed(1:ipos-1)\n read (5,fmt=\"(a)\",iostat=ierr)words\n end do\n end\n", "target": "using System;\n\npublic class ReverseWordsInString\n{\n    public static void Main(string[] args)\n    {\n        string text = @\"\n            ---------- Ice and Fire ------------\n\n            fire, in end will world the say Some\n            ice. in say Some\n            desire of tasted I've what From\n            fire. favor who those with hold I\n\n            ... elided paragraph last ...\n\n            Frost Robert -----------------------\n            \";\n\n        foreach (string line in text.Split(Environment.NewLine)) {\n            \n            string[] words = line.Split(default(char[]), StringSplitOptions.RemoveEmptyEntries);\n            Array.Reverse(words);\n            WriteLine(string.Join(\" \", words));\n        }\n    }\n}\n"}
{"id": 161581, "name": "Reverse words in a string", "source": "Translate Fortran to Java:  character*40 words\n character*40 reversed\n logical inblank\n ierr=0\n read (5,fmt=\"(a)\",iostat=ierr)words\n do while (ierr.eq.0)\n inblank=.true.\n ipos=1\n do i=40,1,-1\n   if(words(i:i).ne.' '.and.inblank) then\n     last=i\n     inblank=.false.\n     end if\n    if(.not.inblank.and.words(i:i).eq.' ') then\n      reversed(ipos:ipos+last-i)=words(i+1:last)\n      ipos=ipos+last-i+1\n      inblank=.true.\n      end if\n     if(.not.inblank.and.i.eq.1) then\n       reversed(ipos:ipos+last-1)=words(1:last)\n       ipos=ipos+last\n       end if\n   end do\n print *,words,'=> ',reversed(1:ipos-1)\n read (5,fmt=\"(a)\",iostat=ierr)words\n end do\n end\n", "target": "public class ReverseWords {\n\n    static final String[] lines = {\n        \" ----------- Ice and Fire ----------- \",\n        \"                                      \",\n        \" fire, in end will world the say Some \",\n        \" ice. in say Some                     \",\n        \" desire of tasted I've what From      \",\n        \" fire. favor who those with hold I    \",\n        \"                                      \",\n        \" ... elided paragraph last ...        \",\n        \" Frost Robert ----------------------- \"};\n\n    public static void main(String[] args) {\n        for (String line : lines) {\n            String[] words = line.split(\"\\\\s\");\n            for (int i = words.length - 1; i >= 0; i--)\n                System.out.printf(\"%s \", words[i]);\n            System.out.println();\n        }\n    }\n}\n"}
{"id": 161582, "name": "Reverse words in a string", "source": "Translate Fortran to Python:  character*40 words\n character*40 reversed\n logical inblank\n ierr=0\n read (5,fmt=\"(a)\",iostat=ierr)words\n do while (ierr.eq.0)\n inblank=.true.\n ipos=1\n do i=40,1,-1\n   if(words(i:i).ne.' '.and.inblank) then\n     last=i\n     inblank=.false.\n     end if\n    if(.not.inblank.and.words(i:i).eq.' ') then\n      reversed(ipos:ipos+last-i)=words(i+1:last)\n      ipos=ipos+last-i+1\n      inblank=.true.\n      end if\n     if(.not.inblank.and.i.eq.1) then\n       reversed(ipos:ipos+last-1)=words(1:last)\n       ipos=ipos+last\n       end if\n   end do\n print *,words,'=> ',reversed(1:ipos-1)\n read (5,fmt=\"(a)\",iostat=ierr)words\n end do\n end\n", "target": " text = \n\nfor line in text.split('\\n'): print(' '.join(line.split()[::-1]))\n"}
{"id": 162002, "name": "Middle three digits", "source": "Translate Fortran to C#: \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nprogram MiddleMuddle\n  integer, dimension(17) :: itest, idigits\n  integer :: i, n\n  data itest/123,12345,1234567,987654321,10001,-10001,-123,-100,100,-12345,1,2,-1,-10,2002,-2002,0/\n  do i = 1, size(itest)\n    call antibase(10, abs(itest(i)), idigits, n)\n    write(6,'(i20,2x,a20)') itest(i), classifym3(idigits, n)\n    if (0 .eq. itest(i)) exit\n  end do\n\ncontains\n\n  logical function even(n)\n    integer, intent(in) :: n\n    even = 0 .eq. iand(n,1)\n  end function even\n\n  function classifym3(iarray, n) result(s)\n    integer, dimension(:), intent(in) :: iarray\n    integer, intent(in) :: n\n    character(len=20) :: s\n    integer :: i,m\n    if (n < 3) then\n      s = 'Too short'\n    else if (even(n)) then\n      s = 'Digit count too even'\n    else\n      m = (n+1)/2\n      write(s,'(3i1)')(iarray(i), i=m+1,m-1,-1)\n    end if\n  end function classifym3\n\n  subroutine antibase(base, m, digits, n) \n    integer, intent(in) :: base, m\n    integer, intent(out) :: n  \n    integer, dimension(:), intent(out) :: digits\n    integer :: em\n    em = m\n    do n=1, size(digits)\n      digits(n) = mod(em, base)\n      em = em / base\n      if (0 .eq. em) return\n    end do\n    stop 'antibase ran out of space to store result'\n  end subroutine antibase\n\nend program MiddleMuddle\n", "target": "using System;\n\nnamespace RosettaCode\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            string text = Math.Abs(int.Parse(Console.ReadLine())).ToString();\n            Console.WriteLine(text.Length < 2 || text.Length % 2 == 0 ? \"Error\" : text.Substring((text.Length - 3) / 2, 3));\n        }\n    }\n}\n"}
{"id": 162005, "name": "Middle three digits", "source": "Translate Fortran to Java: \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nprogram MiddleMuddle\n  integer, dimension(17) :: itest, idigits\n  integer :: i, n\n  data itest/123,12345,1234567,987654321,10001,-10001,-123,-100,100,-12345,1,2,-1,-10,2002,-2002,0/\n  do i = 1, size(itest)\n    call antibase(10, abs(itest(i)), idigits, n)\n    write(6,'(i20,2x,a20)') itest(i), classifym3(idigits, n)\n    if (0 .eq. itest(i)) exit\n  end do\n\ncontains\n\n  logical function even(n)\n    integer, intent(in) :: n\n    even = 0 .eq. iand(n,1)\n  end function even\n\n  function classifym3(iarray, n) result(s)\n    integer, dimension(:), intent(in) :: iarray\n    integer, intent(in) :: n\n    character(len=20) :: s\n    integer :: i,m\n    if (n < 3) then\n      s = 'Too short'\n    else if (even(n)) then\n      s = 'Digit count too even'\n    else\n      m = (n+1)/2\n      write(s,'(3i1)')(iarray(i), i=m+1,m-1,-1)\n    end if\n  end function classifym3\n\n  subroutine antibase(base, m, digits, n) \n    integer, intent(in) :: base, m\n    integer, intent(out) :: n  \n    integer, dimension(:), intent(out) :: digits\n    integer :: em\n    em = m\n    do n=1, size(digits)\n      digits(n) = mod(em, base)\n      em = em / base\n      if (0 .eq. em) return\n    end do\n    stop 'antibase ran out of space to store result'\n  end subroutine antibase\n\nend program MiddleMuddle\n", "target": "public class MiddleThreeDigits {\n\n    public static void main(String[] args) {\n        final long[] passing = {123, 12345, 1234567, 987654321, 10001, -10001,\n            -123, -100, 100, -12345, Long.MIN_VALUE, Long.MAX_VALUE};\n\n        final int[] failing = {1, 2, -1, -10, 2002, -2002, 0, Integer.MIN_VALUE,\n            Integer.MAX_VALUE};\n\n        for (long n : passing)\n            System.out.printf(\"middleThreeDigits(%s): %s\\n\", n, middleThreeDigits(n));\n\n        for (int n : failing)\n            System.out.printf(\"middleThreeDigits(%s): %s\\n\", n, middleThreeDigits(n));\n    }\n\n    public static <T> String middleThreeDigits(T n) {\n        String s = String.valueOf(n);\n        if (s.charAt(0) == '-')\n            s = s.substring(1);\n        int len = s.length();\n        if (len < 3 || len % 2 == 0)\n            return \"Need odd and >= 3 digits\";\n        int mid = len / 2;\n        return s.substring(mid - 1, mid + 2);\n    }\n}\n"}
{"id": 162006, "name": "Middle three digits", "source": "Translate Fortran to Python: \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nprogram MiddleMuddle\n  integer, dimension(17) :: itest, idigits\n  integer :: i, n\n  data itest/123,12345,1234567,987654321,10001,-10001,-123,-100,100,-12345,1,2,-1,-10,2002,-2002,0/\n  do i = 1, size(itest)\n    call antibase(10, abs(itest(i)), idigits, n)\n    write(6,'(i20,2x,a20)') itest(i), classifym3(idigits, n)\n    if (0 .eq. itest(i)) exit\n  end do\n\ncontains\n\n  logical function even(n)\n    integer, intent(in) :: n\n    even = 0 .eq. iand(n,1)\n  end function even\n\n  function classifym3(iarray, n) result(s)\n    integer, dimension(:), intent(in) :: iarray\n    integer, intent(in) :: n\n    character(len=20) :: s\n    integer :: i,m\n    if (n < 3) then\n      s = 'Too short'\n    else if (even(n)) then\n      s = 'Digit count too even'\n    else\n      m = (n+1)/2\n      write(s,'(3i1)')(iarray(i), i=m+1,m-1,-1)\n    end if\n  end function classifym3\n\n  subroutine antibase(base, m, digits, n) \n    integer, intent(in) :: base, m\n    integer, intent(out) :: n  \n    integer, dimension(:), intent(out) :: digits\n    integer :: em\n    em = m\n    do n=1, size(digits)\n      digits(n) = mod(em, base)\n      em = em / base\n      if (0 .eq. em) return\n    end do\n    stop 'antibase ran out of space to store result'\n  end subroutine antibase\n\nend program MiddleMuddle\n", "target": ">>> def middle_three_digits(i):\n\ts = str(abs(i))\n\tlength = len(s)\n\tassert length >= 3 and length % 2 == 1, \"Need odd and >= 3 digits\"\n\tmid = length // 2\n\treturn s[mid-1:mid+2]\n\n>>> passing = [123, 12345, 1234567, 987654321, 10001, -10001, -123, -100, 100, -12345]\n>>> failing = [1, 2, -1, -10, 2002, -2002, 0]\n>>> for x in passing + failing:\n\ttry:\n\t\tanswer = middle_three_digits(x)\n\texcept AssertionError as error:\n\t\tanswer = error\n\tprint(\"middle_three_digits(%s) returned: %r\" % (x, answer))\n\n\t\nmiddle_three_digits(123) returned: '123'\nmiddle_three_digits(12345) returned: '234'\nmiddle_three_digits(1234567) returned: '345'\nmiddle_three_digits(987654321) returned: '654'\nmiddle_three_digits(10001) returned: '000'\nmiddle_three_digits(-10001) returned: '000'\nmiddle_three_digits(-123) returned: '123'\nmiddle_three_digits(-100) returned: '100'\nmiddle_three_digits(100) returned: '100'\nmiddle_three_digits(-12345) returned: '234'\nmiddle_three_digits(1) returned: AssertionError('Need odd and >= 3 digits',)\nmiddle_three_digits(2) returned: AssertionError('Need odd and >= 3 digits',)\nmiddle_three_digits(-1) returned: AssertionError('Need odd and >= 3 digits',)\nmiddle_three_digits(-10) returned: AssertionError('Need odd and >= 3 digits',)\nmiddle_three_digits(2002) returned: AssertionError('Need odd and >= 3 digits',)\nmiddle_three_digits(-2002) returned: AssertionError('Need odd and >= 3 digits',)\nmiddle_three_digits(0) returned: AssertionError('Need odd and >= 3 digits',)\n>>>\n"}
{"id": 162257, "name": "Range expansion", "source": "Translate Fortran to C#:       MODULE HOMEONTHERANGE\n       CONTAINS\t\n        CHARACTER*200 FUNCTION ERANGE(TEXT)\t\nCan't return a character value of variable size.\n         CHARACTER*(*) TEXT\t\n         CHARACTER*200 ALINE\t\n         INTEGER N,N1,N2\t\n         INTEGER I,I1\t\t\n          ALINE = \"\"\t\t\n          L = 0\t\t\t\n          I = 1\t\t\t\n          CALL FORASIGN\t\t\nChug through another number or number - number range.\n        R:DO WHILE(EATINT(N1))\t\n            N2 = N1\t\t\t\n            IF (PASSBY(\"-\")) CALL EATINT(N2)\t\n            IF (L.GT.0) CALL EMIT(\",\")\t\t\n            DO N = N1,N2,SIGN(+1,N2 - N1)\t\n              CALL SPLOT(N)\t\t\t\t\n              IF (N.NE.N2) CALL EMIT(\",\")\t\t\n            END DO\t\t\t\t\n            IF (.NOT.PASSBY(\",\")) EXIT R\t\n          END DO R\t\t\nCompleted the scan. Just return the result.\n          ERANGE = ALINE(1:L)\t\n         CONTAINS\t\n          SUBROUTINE FORASIGN\t\n    1       IF (I.LE.LEN(TEXT)) THEN\t\n              IF (TEXT(I:I).LE.\" \") THEN\t\n                I = I + 1\t\t\t\t\n                GO TO 1\t\t\t\t\t\n              END IF\t\t\t\n            END IF\t\t\t\n          END SUBROUTINE FORASIGN\t\n\n          LOGICAL FUNCTION PASSBY(C)\t\nCould consider or ignore case for letters, but this is really for single symbols.\n           CHARACTER*1 C\t\n            PASSBY = .FALSE.\t\n            IF (I.LE.LEN(TEXT)) THEN\t\n              IF (TEXT(I:I).EQ.C) THEN\t\n                PASSBY = .TRUE.\t\t\n                I = I + 1\t\t\n                CALL FORASIGN\t\t\n              END IF\t\t\n            END IF\t\t\n          END FUNCTION PASSBY\t\n\n          LOGICAL FUNCTION EATINT(N)\t\n           INTEGER N\t\n           INTEGER D\t\n           LOGICAL NEG\t\n            EATINT = .FALSE.\t\n            IF (I.GT.LEN(TEXT)) RETURN\t\n            N = 0\t\t\t\n            IF (PASSBY(\"+\")) THEN\t\n              NEG = .FALSE.\t\t\n             ELSE\t\t\t\n              NEG = PASSBY(\"-\")\t\t\n            END IF\t\t\t\n            IF (I.GT.LEN(TEXT)) RETURN\t\nChug through digits. Can develop -2147483648, thanks to the workings of two's complement.\n   10       D = ICHAR(TEXT(I:I)) - ICHAR(\"0\")\t\n            IF (0.LE.D .AND. D.LE.9) THEN\t\n              N = N*10 + D\t\t\t\n              I = I + 1\t\t\t\t\n              IF (I.LE.LEN(TEXT)) GO TO 10\t\n            END IF\t\t\t\n            IF (NEG) N = -N\t\t\n            EATINT = .TRUE.\t\t\n            CALL FORASIGN\t\t\n          END FUNCTION EATINT\t\n\n          SUBROUTINE EMIT(C)\t\n           CHARACTER*1 C\t\n            L = L + 1\t\t\n            IF (L.GT.LEN(ALINE)) STOP \"Ran out of ALINE\n            ALINE(L:L) = C\t\n          END SUBROUTINE EMIT\t\n\n          SUBROUTINE SPLOT(N)\t\n           INTEGER N\t\t\n           CHARACTER*12 FIELD\t\n           INTEGER I\t\t\n            WRITE (FIELD,\"(I0)\") N\t\n            DO I = 1,12\t\t\n              IF (FIELD(I:I).LE.\" \") EXIT\t\n              CALL EMIT(FIELD(I:I))\t\n            END DO\t\t\n          END SUBROUTINE SPLOT\t\n        END FUNCTION ERANGE\t\n      END MODULE HOMEONTHERANGE\n\n      PROGRAM POKE\n      USE HOMEONTHERANGE\n      CHARACTER*(200) SOME\n      SOME = \"-6,-3--1,3-5,7-11,14,15,17-20\"\n      SOME = ERANGE(SOME)\n      WRITE (6,*) SOME\t\n      END\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text.RegularExpressions;\n\nclass Program\n{\n    static void Main(string[] args)\n    {\n        var rangeString = \"-6,-3--1,3-5,7-11,14,15,17-20\";\n        var matches = Regex.Matches(rangeString, @\"(?<f>-?\\d+)-(?<s>-?\\d+)|(-?\\d+)\");\n        var values = new List<string>();\n\n        foreach (var m in matches.OfType<Match>())\n        {\n            if (m.Groups[1].Success)\n            {\n                values.Add(m.Value);\n                continue;\n            }\n\n            var start = Convert.ToInt32(m.Groups[\"f\"].Value);\n            var end = Convert.ToInt32(m.Groups[\"s\"].Value) + 1;\n\n            values.AddRange(Enumerable.Range(start, end - start).Select(v => v.ToString()));\n        }\n\n        Console.WriteLine(string.Join(\", \", values));\n    }\n}\n"}
{"id": 162260, "name": "Range expansion", "source": "Translate Fortran to Java:       MODULE HOMEONTHERANGE\n       CONTAINS\t\n        CHARACTER*200 FUNCTION ERANGE(TEXT)\t\nCan't return a character value of variable size.\n         CHARACTER*(*) TEXT\t\n         CHARACTER*200 ALINE\t\n         INTEGER N,N1,N2\t\n         INTEGER I,I1\t\t\n          ALINE = \"\"\t\t\n          L = 0\t\t\t\n          I = 1\t\t\t\n          CALL FORASIGN\t\t\nChug through another number or number - number range.\n        R:DO WHILE(EATINT(N1))\t\n            N2 = N1\t\t\t\n            IF (PASSBY(\"-\")) CALL EATINT(N2)\t\n            IF (L.GT.0) CALL EMIT(\",\")\t\t\n            DO N = N1,N2,SIGN(+1,N2 - N1)\t\n              CALL SPLOT(N)\t\t\t\t\n              IF (N.NE.N2) CALL EMIT(\",\")\t\t\n            END DO\t\t\t\t\n            IF (.NOT.PASSBY(\",\")) EXIT R\t\n          END DO R\t\t\nCompleted the scan. Just return the result.\n          ERANGE = ALINE(1:L)\t\n         CONTAINS\t\n          SUBROUTINE FORASIGN\t\n    1       IF (I.LE.LEN(TEXT)) THEN\t\n              IF (TEXT(I:I).LE.\" \") THEN\t\n                I = I + 1\t\t\t\t\n                GO TO 1\t\t\t\t\t\n              END IF\t\t\t\n            END IF\t\t\t\n          END SUBROUTINE FORASIGN\t\n\n          LOGICAL FUNCTION PASSBY(C)\t\nCould consider or ignore case for letters, but this is really for single symbols.\n           CHARACTER*1 C\t\n            PASSBY = .FALSE.\t\n            IF (I.LE.LEN(TEXT)) THEN\t\n              IF (TEXT(I:I).EQ.C) THEN\t\n                PASSBY = .TRUE.\t\t\n                I = I + 1\t\t\n                CALL FORASIGN\t\t\n              END IF\t\t\n            END IF\t\t\n          END FUNCTION PASSBY\t\n\n          LOGICAL FUNCTION EATINT(N)\t\n           INTEGER N\t\n           INTEGER D\t\n           LOGICAL NEG\t\n            EATINT = .FALSE.\t\n            IF (I.GT.LEN(TEXT)) RETURN\t\n            N = 0\t\t\t\n            IF (PASSBY(\"+\")) THEN\t\n              NEG = .FALSE.\t\t\n             ELSE\t\t\t\n              NEG = PASSBY(\"-\")\t\t\n            END IF\t\t\t\n            IF (I.GT.LEN(TEXT)) RETURN\t\nChug through digits. Can develop -2147483648, thanks to the workings of two's complement.\n   10       D = ICHAR(TEXT(I:I)) - ICHAR(\"0\")\t\n            IF (0.LE.D .AND. D.LE.9) THEN\t\n              N = N*10 + D\t\t\t\n              I = I + 1\t\t\t\t\n              IF (I.LE.LEN(TEXT)) GO TO 10\t\n            END IF\t\t\t\n            IF (NEG) N = -N\t\t\n            EATINT = .TRUE.\t\t\n            CALL FORASIGN\t\t\n          END FUNCTION EATINT\t\n\n          SUBROUTINE EMIT(C)\t\n           CHARACTER*1 C\t\n            L = L + 1\t\t\n            IF (L.GT.LEN(ALINE)) STOP \"Ran out of ALINE\n            ALINE(L:L) = C\t\n          END SUBROUTINE EMIT\t\n\n          SUBROUTINE SPLOT(N)\t\n           INTEGER N\t\t\n           CHARACTER*12 FIELD\t\n           INTEGER I\t\t\n            WRITE (FIELD,\"(I0)\") N\t\n            DO I = 1,12\t\t\n              IF (FIELD(I:I).LE.\" \") EXIT\t\n              CALL EMIT(FIELD(I:I))\t\n            END DO\t\t\n          END SUBROUTINE SPLOT\t\n        END FUNCTION ERANGE\t\n      END MODULE HOMEONTHERANGE\n\n      PROGRAM POKE\n      USE HOMEONTHERANGE\n      CHARACTER*(200) SOME\n      SOME = \"-6,-3--1,3-5,7-11,14,15,17-20\"\n      SOME = ERANGE(SOME)\n      WRITE (6,*) SOME\t\n      END\n", "target": "import java.util.*;\n\nclass RangeExpander implements Iterator<Integer>, Iterable<Integer> {\n\n    private static final Pattern TOKEN_PATTERN = Pattern.compile(\"([+-]?\\\\d+)-([+-]?\\\\d+)\");\n\n    private final Iterator<String> tokensIterator;\n\n    private boolean inRange;\n    private int upperRangeEndpoint;\n    private int nextRangeValue;\n\n    public RangeExpander(String range) {\n        String[] tokens = range.split(\"\\\\s*,\\\\s*\");\n        this.tokensIterator = Arrays.asList(tokens).iterator();\n    }\n\n    @Override\n    public boolean hasNext() {\n        return hasNextRangeValue() || this.tokensIterator.hasNext();\n    }\n\n    private boolean hasNextRangeValue() {\n        return this.inRange && this.nextRangeValue <= this.upperRangeEndpoint;\n    }\n\n    @Override\n    public Integer next() {\n        if (!hasNext()) {\n            throw new NoSuchElementException();\n        }\n\n        if (hasNextRangeValue()) {\n            return this.nextRangeValue++;\n        }\n\n        String token = this.tokensIterator.next();\n\n        Matcher matcher = TOKEN_PATTERN.matcher(token);\n        if (matcher.find()) {\n            this.inRange = true;\n            this.upperRangeEndpoint = Integer.valueOf(matcher.group(2));\n            this.nextRangeValue = Integer.valueOf(matcher.group(1));\n            return this.nextRangeValue++;\n        }\n\n        this.inRange = false;\n        return Integer.valueOf(token);\n    }\n\n    @Override\n    public Iterator<Integer> iterator() {\n        return this;\n    }\n\n}\n\nclass RangeExpanderTest {\n    public static void main(String[] args) {\n        RangeExpander re = new RangeExpander(\"-6,-3--1,3-5,7-11,14,15,17-20\");\n        for (int i : re) {\n            System.out.print(i + \" \");\n        }\n    }\n}\n"}
{"id": 162261, "name": "Range expansion", "source": "Translate Fortran to Python:       MODULE HOMEONTHERANGE\n       CONTAINS\t\n        CHARACTER*200 FUNCTION ERANGE(TEXT)\t\nCan't return a character value of variable size.\n         CHARACTER*(*) TEXT\t\n         CHARACTER*200 ALINE\t\n         INTEGER N,N1,N2\t\n         INTEGER I,I1\t\t\n          ALINE = \"\"\t\t\n          L = 0\t\t\t\n          I = 1\t\t\t\n          CALL FORASIGN\t\t\nChug through another number or number - number range.\n        R:DO WHILE(EATINT(N1))\t\n            N2 = N1\t\t\t\n            IF (PASSBY(\"-\")) CALL EATINT(N2)\t\n            IF (L.GT.0) CALL EMIT(\",\")\t\t\n            DO N = N1,N2,SIGN(+1,N2 - N1)\t\n              CALL SPLOT(N)\t\t\t\t\n              IF (N.NE.N2) CALL EMIT(\",\")\t\t\n            END DO\t\t\t\t\n            IF (.NOT.PASSBY(\",\")) EXIT R\t\n          END DO R\t\t\nCompleted the scan. Just return the result.\n          ERANGE = ALINE(1:L)\t\n         CONTAINS\t\n          SUBROUTINE FORASIGN\t\n    1       IF (I.LE.LEN(TEXT)) THEN\t\n              IF (TEXT(I:I).LE.\" \") THEN\t\n                I = I + 1\t\t\t\t\n                GO TO 1\t\t\t\t\t\n              END IF\t\t\t\n            END IF\t\t\t\n          END SUBROUTINE FORASIGN\t\n\n          LOGICAL FUNCTION PASSBY(C)\t\nCould consider or ignore case for letters, but this is really for single symbols.\n           CHARACTER*1 C\t\n            PASSBY = .FALSE.\t\n            IF (I.LE.LEN(TEXT)) THEN\t\n              IF (TEXT(I:I).EQ.C) THEN\t\n                PASSBY = .TRUE.\t\t\n                I = I + 1\t\t\n                CALL FORASIGN\t\t\n              END IF\t\t\n            END IF\t\t\n          END FUNCTION PASSBY\t\n\n          LOGICAL FUNCTION EATINT(N)\t\n           INTEGER N\t\n           INTEGER D\t\n           LOGICAL NEG\t\n            EATINT = .FALSE.\t\n            IF (I.GT.LEN(TEXT)) RETURN\t\n            N = 0\t\t\t\n            IF (PASSBY(\"+\")) THEN\t\n              NEG = .FALSE.\t\t\n             ELSE\t\t\t\n              NEG = PASSBY(\"-\")\t\t\n            END IF\t\t\t\n            IF (I.GT.LEN(TEXT)) RETURN\t\nChug through digits. Can develop -2147483648, thanks to the workings of two's complement.\n   10       D = ICHAR(TEXT(I:I)) - ICHAR(\"0\")\t\n            IF (0.LE.D .AND. D.LE.9) THEN\t\n              N = N*10 + D\t\t\t\n              I = I + 1\t\t\t\t\n              IF (I.LE.LEN(TEXT)) GO TO 10\t\n            END IF\t\t\t\n            IF (NEG) N = -N\t\t\n            EATINT = .TRUE.\t\t\n            CALL FORASIGN\t\t\n          END FUNCTION EATINT\t\n\n          SUBROUTINE EMIT(C)\t\n           CHARACTER*1 C\t\n            L = L + 1\t\t\n            IF (L.GT.LEN(ALINE)) STOP \"Ran out of ALINE\n            ALINE(L:L) = C\t\n          END SUBROUTINE EMIT\t\n\n          SUBROUTINE SPLOT(N)\t\n           INTEGER N\t\t\n           CHARACTER*12 FIELD\t\n           INTEGER I\t\t\n            WRITE (FIELD,\"(I0)\") N\t\n            DO I = 1,12\t\t\n              IF (FIELD(I:I).LE.\" \") EXIT\t\n              CALL EMIT(FIELD(I:I))\t\n            END DO\t\t\n          END SUBROUTINE SPLOT\t\n        END FUNCTION ERANGE\t\n      END MODULE HOMEONTHERANGE\n\n      PROGRAM POKE\n      USE HOMEONTHERANGE\n      CHARACTER*(200) SOME\n      SOME = \"-6,-3--1,3-5,7-11,14,15,17-20\"\n      SOME = ERANGE(SOME)\n      WRITE (6,*) SOME\t\n      END\n", "target": "def rangeexpand(txt):\n    lst = []\n    for r in txt.split(','):\n        if '-' in r[1:]:\n            r0, r1 = r[1:].split('-', 1)\n            lst += range(int(r[0] + r0), int(r1) + 1)\n        else:\n            lst.append(int(r))\n    return lst\n\nprint(rangeexpand('-6,-3--1,3-5,7-11,14,15,17-20'))\n"}
{"id": 162716, "name": "Modular inverse", "source": "Translate Fortran to C#: program modular_inverse_task\n\n  implicit none\n\n  write (*,*) inverse (42, 2017)\n\ncontains\n\n  \n  \n  \n  function inverse (a, n) result (inverse_value)\n    integer, intent(in) :: a, n\n    integer :: inverse_value\n\n    integer :: t, newt\n    integer :: r, newr\n    integer :: quotient, remainder, tmp\n\n    if (n <= 0) error stop\n    t = 0;  newt = 1\n    r = n;  newr = a\n    do while (newr /= 0)\n       remainder = modulo (r, newr) \n       quotient = (r - remainder) / newr\n       tmp = newt;  newt = t - (quotient * newt);  t = tmp\n       r   = newr;  newr = remainder\n    end do\n    if (r > 1) then\n       inverse_value = -1\n    else if (t < 0) then\n       inverse_value = t + n\n    else\n       inverse_value = t\n    end if\n  end function inverse\n\nend program modular_inverse_task\n", "target": "public class Program\n{\n    static void Main()\n    {\n        System.Console.WriteLine(42.ModInverse(2017));\n    }\n}\n\npublic static class IntExtensions\n{\n    public static int ModInverse(this int a, int m)\n    {\n        if (m == 1) return 0;\n        int m0 = m;\n        (int x, int y) = (1, 0);\n\n        while (a > 1) {\n            int q = a / m;\n            (a, m) = (m, a % m);\n            (x, y) = (y, x - q * y);\n        }\n        return x < 0 ? x + m0 : x;\n    }\n}\n"}
{"id": 162719, "name": "Modular inverse", "source": "Translate Fortran to Java: program modular_inverse_task\n\n  implicit none\n\n  write (*,*) inverse (42, 2017)\n\ncontains\n\n  \n  \n  \n  function inverse (a, n) result (inverse_value)\n    integer, intent(in) :: a, n\n    integer :: inverse_value\n\n    integer :: t, newt\n    integer :: r, newr\n    integer :: quotient, remainder, tmp\n\n    if (n <= 0) error stop\n    t = 0;  newt = 1\n    r = n;  newr = a\n    do while (newr /= 0)\n       remainder = modulo (r, newr) \n       quotient = (r - remainder) / newr\n       tmp = newt;  newt = t - (quotient * newt);  t = tmp\n       r   = newr;  newr = remainder\n    end do\n    if (r > 1) then\n       inverse_value = -1\n    else if (t < 0) then\n       inverse_value = t + n\n    else\n       inverse_value = t\n    end if\n  end function inverse\n\nend program modular_inverse_task\n", "target": "System.out.println(BigInteger.valueOf(42).modInverse(BigInteger.valueOf(2017)));\n"}
{"id": 162720, "name": "Modular inverse", "source": "Translate Fortran to Python: program modular_inverse_task\n\n  implicit none\n\n  write (*,*) inverse (42, 2017)\n\ncontains\n\n  \n  \n  \n  function inverse (a, n) result (inverse_value)\n    integer, intent(in) :: a, n\n    integer :: inverse_value\n\n    integer :: t, newt\n    integer :: r, newr\n    integer :: quotient, remainder, tmp\n\n    if (n <= 0) error stop\n    t = 0;  newt = 1\n    r = n;  newr = a\n    do while (newr /= 0)\n       remainder = modulo (r, newr) \n       quotient = (r - remainder) / newr\n       tmp = newt;  newt = t - (quotient * newt);  t = tmp\n       r   = newr;  newr = remainder\n    end do\n    if (r > 1) then\n       inverse_value = -1\n    else if (t < 0) then\n       inverse_value = t + n\n    else\n       inverse_value = t\n    end if\n  end function inverse\n\nend program modular_inverse_task\n", "target": ">>> def extended_gcd(aa, bb):\n    lastremainder, remainder = abs(aa), abs(bb)\n    x, lastx, y, lasty = 0, 1, 1, 0\n    while remainder:\n        lastremainder, (quotient, remainder) = remainder, divmod(lastremainder, remainder)\n        x, lastx = lastx - quotient*x, x\n        y, lasty = lasty - quotient*y, y\n    return lastremainder, lastx * (-1 if aa < 0 else 1), lasty * (-1 if bb < 0 else 1)\n\n>>> def modinv(a, m):\n\tg, x, y = extended_gcd(a, m)\n\tif g != 1:\n\t\traise ValueError\n\treturn x % m\n\n>>> modinv(42, 2017)\n1969\n>>>\n"}
{"id": 163473, "name": "Stern-Brocot sequence", "source": "Translate Fortran to C#: * STERN-BROCOT SEQUENCE - FORTRAN IV\n      DIMENSION ISB(2400)\n      NN=2400\n      ISB(1)=1\n      ISB(2)=1\n      I=1\n      J=2\n      K=2\n 1    IF(K.GE.NN) GOTO 2\n        K=K+1\n        ISB(K)=ISB(K-I)+ISB(K-J)\n        K=K+1\n        ISB(K)=ISB(K-J)\n        I=I+1\n        J=J+1\n        GOTO 1\n 2    N=15\n      WRITE(*,101) N\n  101 FORMAT(1X,'FIRST',I4)\n      WRITE(*,102) (ISB(I),I=1,15)\n  102 FORMAT(15I4)\n      DO 5 J=1,11\n        JJ=J\n        IF(J.EQ.11) JJ=100\n        DO 3 I=1,K\n          IF(ISB(I).EQ.JJ) GOTO 4\n 3      CONTINUE\n 4      WRITE(*,103) JJ,I\n  103   FORMAT(1X,'FIRST',I4,' AT ',I4)\n 5    CONTINUE\n      END\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\nstatic class Program {\n    static List<int> l = new List<int>() { 1, 1 };\n\n    static int gcd(int a, int b) {\n        return a > 0 ? a < b ? gcd(b % a, a) : gcd(a % b, b) : b; }\n\n    static void Main(string[] args) {\n        int max = 1000; int take = 15; int i = 1;\n        int[] selection = new[] { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 100 };\n        do { l.AddRange(new List<int>() { l[i] + l[i - 1], l[i] }); i += 1; }\n        while (l.Count < max || l[l.Count - 2] != selection.Last());\n        Console.Write(\"The first {0} items In the Stern-Brocot sequence: \", take);\n        Console.WriteLine(\"{0}\\n\", string.Join(\", \", l.Take(take)));\n        Console.WriteLine(\"The locations of where the selected numbers (1-to-10, & 100) first appear:\");\n        foreach (int ii in selection) {\n            int j = l.FindIndex(x => x == ii) + 1; Console.WriteLine(\"{0,3}: {1:n0}\", ii, j); }\n        Console.WriteLine(); bool good = true;\n        for (i = 1; i <= max; i++) { if (gcd(l[i], l[i - 1]) != 1) { good = false; break; } }\n        Console.WriteLine(\"The greatest common divisor of all the two consecutive items of the\" + \n                          \" series up to the {0}th item is {1}always one.\", max, good ? \"\" : \"not \");\n    }\n}\n"}
{"id": 163476, "name": "Stern-Brocot sequence", "source": "Translate Fortran to Java: * STERN-BROCOT SEQUENCE - FORTRAN IV\n      DIMENSION ISB(2400)\n      NN=2400\n      ISB(1)=1\n      ISB(2)=1\n      I=1\n      J=2\n      K=2\n 1    IF(K.GE.NN) GOTO 2\n        K=K+1\n        ISB(K)=ISB(K-I)+ISB(K-J)\n        K=K+1\n        ISB(K)=ISB(K-J)\n        I=I+1\n        J=J+1\n        GOTO 1\n 2    N=15\n      WRITE(*,101) N\n  101 FORMAT(1X,'FIRST',I4)\n      WRITE(*,102) (ISB(I),I=1,15)\n  102 FORMAT(15I4)\n      DO 5 J=1,11\n        JJ=J\n        IF(J.EQ.11) JJ=100\n        DO 3 I=1,K\n          IF(ISB(I).EQ.JJ) GOTO 4\n 3      CONTINUE\n 4      WRITE(*,103) JJ,I\n  103   FORMAT(1X,'FIRST',I4,' AT ',I4)\n 5    CONTINUE\n      END\n", "target": "import java.math.BigInteger;\nimport java.util.LinkedList;\n\npublic class SternBrocot {\n\tstatic LinkedList<Integer> sequence = new LinkedList<Integer>(){{\n\t\tadd(1); add(1);\n\t}};\n\t\n\tprivate static void genSeq(int n){\n\t\tfor(int conIdx = 1; sequence.size() < n; conIdx++){\n\t\t\tint consider = sequence.get(conIdx);\n\t\t\tint pre = sequence.get(conIdx - 1);\n\t\t\tsequence.add(consider + pre);\n\t\t\tsequence.add(consider);\n\t\t}\n\t\t\n\t}\n\t\n\tpublic static void main(String[] args){\n\t\tgenSeq(1200);\n\t\tSystem.out.println(\"The first 15 elements are: \" + sequence.subList(0, 15));\n\t\tfor(int i = 1; i <= 10; i++){\n\t\t\tSystem.out.println(\"First occurrence of \" + i + \" is at \" + (sequence.indexOf(i) + 1));\n\t\t}\n\t\t\n\t\tSystem.out.println(\"First occurrence of 100 is at \" + (sequence.indexOf(100) + 1));\n\t\t\n\t\tboolean failure = false;\n\t\tfor(int i = 0; i < 999; i++){\n\t\t\tfailure |= !BigInteger.valueOf(sequence.get(i)).gcd(BigInteger.valueOf(sequence.get(i + 1))).equals(BigInteger.ONE);\n\t\t}\n\t\tSystem.out.println(\"All GCDs are\" + (failure ? \" not\" : \"\") + \" 1\");\n\t}\n}\n"}
{"id": 163477, "name": "Stern-Brocot sequence", "source": "Translate Fortran to Python: * STERN-BROCOT SEQUENCE - FORTRAN IV\n      DIMENSION ISB(2400)\n      NN=2400\n      ISB(1)=1\n      ISB(2)=1\n      I=1\n      J=2\n      K=2\n 1    IF(K.GE.NN) GOTO 2\n        K=K+1\n        ISB(K)=ISB(K-I)+ISB(K-J)\n        K=K+1\n        ISB(K)=ISB(K-J)\n        I=I+1\n        J=J+1\n        GOTO 1\n 2    N=15\n      WRITE(*,101) N\n  101 FORMAT(1X,'FIRST',I4)\n      WRITE(*,102) (ISB(I),I=1,15)\n  102 FORMAT(15I4)\n      DO 5 J=1,11\n        JJ=J\n        IF(J.EQ.11) JJ=100\n        DO 3 I=1,K\n          IF(ISB(I).EQ.JJ) GOTO 4\n 3      CONTINUE\n 4      WRITE(*,103) JJ,I\n  103   FORMAT(1X,'FIRST',I4,' AT ',I4)\n 5    CONTINUE\n      END\n", "target": "def stern_brocot(predicate=lambda series: len(series) < 20):\n    \n\n    sb, i = [1, 1], 0\n    while predicate(sb):\n        sb += [sum(sb[i:i + 2]), sb[i + 1]]\n        i += 1\n    return sb\n\n\nif __name__ == '__main__':\n    from fractions import gcd\n\n    n_first = 15\n    print('The first %i values:\\n  ' % n_first,\n          stern_brocot(lambda series: len(series) < n_first)[:n_first])\n    print()\n    n_max = 10\n    for n_occur in list(range(1, n_max + 1)) + [100]:\n        print('1-based index of the first occurrence of %3i in the series:' % n_occur,\n              stern_brocot(lambda series: n_occur not in series).index(n_occur) + 1)\n              \n              \n\n    print()\n    n_gcd = 1000\n    s = stern_brocot(lambda series: len(series) < n_gcd)[:n_gcd]\n    assert all(gcd(prev, this) == 1\n               for prev, this in zip(s, s[1:])), 'A fraction from adjacent terms is reducible'\n"}
{"id": 163681, "name": "Temperature conversion", "source": "Translate Fortran to C#: Program Temperature\n  implicit none\n  \n  real :: kel, cel, fah, ran\n\n  write(*,*) \"Input Kelvin temperature to convert\"\n  read(*,*) kel\n\n  call temp_convert(kel, cel, fah, ran)\n  write(*, \"((a10), f10.3)\") \"Kelvin\", kel\n  write(*, \"((a10), f10.3)\") \"Celsius\", cel\n  write(*, \"((a10), f10.3)\") \"Fahrenheit\", fah\n  write(*, \"((a10), f10.3)\") \"Rankine\", ran\n    \ncontains\n\nsubroutine temp_convert(kelvin, celsius, fahrenheit, rankine)\n  real, intent(in)  :: kelvin\n  real, intent(out) :: celsius, fahrenheit, rankine\n\n  celsius = kelvin - 273.15\n  fahrenheit = kelvin * 1.8 - 459.67\n  rankine = kelvin * 1.8\n\nend subroutine\nend program\n", "target": "using System;\n\nnamespace TemperatureConversion\n{\n    class Program\n    {\n        static Func<double, double> ConvertKelvinToFahrenheit = x => (x * 1.8) - 459.67;\n        static Func<double, double> ConvertKelvinToRankine = x => x * 1.8;\n        static Func<double, double> ConvertKelvinToCelsius = x => x = 273.13;\n\n        static void Main(string[] args)\n        {\n            Console.Write(\"Enter a Kelvin Temperature: \");\n            string inputVal = Console.ReadLine();\n            double kelvinTemp = 0f;\n\n            if (double.TryParse(inputVal, out kelvinTemp))\n            {\n                Console.WriteLine(string.Format(\"Kelvin: {0}\", kelvinTemp));\n                Console.WriteLine(string.Format(\"Fahrenheit: {0}\", ConvertKelvinToFahrenheit(kelvinTemp)));\n                Console.WriteLine(string.Format(\"Rankine: {0}\", ConvertKelvinToRankine(kelvinTemp)));\n                Console.WriteLine(string.Format(\"Celsius: {0}\", ConvertKelvinToCelsius(kelvinTemp)));\n                Console.ReadKey();\n            }\n            else\n            {\n                Console.WriteLine(\"Invalid input value: \" + inputVal);\n            }\n        }\n    }\n}\n"}
{"id": 163685, "name": "Temperature conversion", "source": "Translate Fortran to Java: Program Temperature\n  implicit none\n  \n  real :: kel, cel, fah, ran\n\n  write(*,*) \"Input Kelvin temperature to convert\"\n  read(*,*) kel\n\n  call temp_convert(kel, cel, fah, ran)\n  write(*, \"((a10), f10.3)\") \"Kelvin\", kel\n  write(*, \"((a10), f10.3)\") \"Celsius\", cel\n  write(*, \"((a10), f10.3)\") \"Fahrenheit\", fah\n  write(*, \"((a10), f10.3)\") \"Rankine\", ran\n    \ncontains\n\nsubroutine temp_convert(kelvin, celsius, fahrenheit, rankine)\n  real, intent(in)  :: kelvin\n  real, intent(out) :: celsius, fahrenheit, rankine\n\n  celsius = kelvin - 273.15\n  fahrenheit = kelvin * 1.8 - 459.67\n  rankine = kelvin * 1.8\n\nend subroutine\nend program\n", "target": "public class TemperatureConversion {\n    public static void main(String args[]) {\n        if (args.length == 1) {\n            try {\n                double kelvin = Double.parseDouble(args[0]);\n                if (kelvin >= 0) {\n                    System.out.printf(\"K  %2.2f\\n\", kelvin);\n                    System.out.printf(\"C  %2.2f\\n\", kelvinToCelsius(kelvin));\n                    System.out.printf(\"F  %2.2f\\n\", kelvinToFahrenheit(kelvin));\n                    System.out.printf(\"R  %2.2f\\n\", kelvinToRankine(kelvin));\n                } else {\n                    System.out.printf(\"%2.2f K is below absolute zero\", kelvin);\n                }\n            } catch (NumberFormatException e) {\n                System.out.println(e);\n            }\n        }\n    }\n\n    public static double kelvinToCelsius(double k) {\n        return k - 273.15;\n    }\n\n    public static double kelvinToFahrenheit(double k) {\n        return k * 1.8 - 459.67;\n    }\n\n    public static double kelvinToRankine(double k) {\n        return k * 1.8;\n    }\n}\n"}
{"id": 163686, "name": "Temperature conversion", "source": "Translate Fortran to Python: Program Temperature\n  implicit none\n  \n  real :: kel, cel, fah, ran\n\n  write(*,*) \"Input Kelvin temperature to convert\"\n  read(*,*) kel\n\n  call temp_convert(kel, cel, fah, ran)\n  write(*, \"((a10), f10.3)\") \"Kelvin\", kel\n  write(*, \"((a10), f10.3)\") \"Celsius\", cel\n  write(*, \"((a10), f10.3)\") \"Fahrenheit\", fah\n  write(*, \"((a10), f10.3)\") \"Rankine\", ran\n    \ncontains\n\nsubroutine temp_convert(kelvin, celsius, fahrenheit, rankine)\n  real, intent(in)  :: kelvin\n  real, intent(out) :: celsius, fahrenheit, rankine\n\n  celsius = kelvin - 273.15\n  fahrenheit = kelvin * 1.8 - 459.67\n  rankine = kelvin * 1.8\n\nend subroutine\nend program\n", "target": ">>> while True:\n    k = float(input('K\u00a0? '))\n    print(\"%g Kelvin = %g Celsius = %g Fahrenheit = %g Rankine degrees.\"\n          % (k, k - 273.15, k * 1.8 - 459.67, k * 1.8))\n\n    \nK ? 21.0\n21 Kelvin = -252.15 Celsius = -421.87 Fahrenheit = 37.8 Rankine degrees.\nK ? 222.2\n222.2 Kelvin = -50.95 Celsius = -59.71 Fahrenheit = 399.96 Rankine degrees.\nK ?\n"}
{"id": 164064, "name": "Soloway's recurring rainfall", "source": "Translate Fortran to C#: function getNextInput() result(Input)\n    implicit none\n    integer :: Input\n    integer :: Reason\n    Reason = 1\n    \n    do while (Reason > 0)\n        print *, \"Enter rainfall int, 99999 to quit: \"\n        read (*,*,IOSTAT=Reason) Input\n        \n        if (Reason > 0) then\n            print *, \"Invalid input\"\n        end if\n    enddo\n    \nend function getNextInput\n\nprogram recurringrainfall\n    implicit none\n    real        :: currentAverage\n    integer     :: currentCount\n    integer     :: lastInput\n    integer     :: getNextInput\n    \n    currentAverage = 0\n    currentCount = 0\n\n    do\n        lastInput = getNextInput()\n        \n        if (lastInput == 99999) exit\n        \n        currentCount = currentCount + 1\n        currentAverage = currentAverage + (1/real(currentCount))*lastInput - (1/real(currentCount))*currentAverage\n        \n        print *, 'New Average: ', currentAverage\n    enddo \n\n    \nend program recurringrainfall\n", "target": "namespace RosettaCode\n{\n\tclass CSharpRecurringRainfall\n    {\t\t\n\t\tstatic int ReadNextInput()\n\t\t{\n\t\t\tSystem.Console.Write(\"Enter rainfall int, 99999 to quit: \");\n\t\t\tstring input = System.Console.ReadLine();\n\t\t\t\n\t\t\tif (System.Int32.TryParse(input, out int num))\n\t\t\t{\n\t\t\t\treturn num;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tSystem.Console.WriteLine(\"Invalid input\");\n\t\t\t\treturn ReadNextInput();\n\t\t\t}\n\t\t}\n\t\t\n        static void Main()\n        {\n\t\t\tdouble currentAverage = 0;\n\t\t\tint currentEntryNumber = 0;\n\t\t\t\n            for (int lastInput = ReadNextInput(); lastInput != 99999; lastInput = ReadNextInput())\n            {\n\t\t\t\tcurrentEntryNumber++;\n\t\t\t\tcurrentAverage = currentAverage + (1.0/(float)currentEntryNumber)*lastInput - (1.0/(float)currentEntryNumber)*currentAverage;\n\t\t\t\tSystem.Console.WriteLine(\"New Average: \" + currentAverage);\n\t\t\t}\n        }\n    }\n}\n"}
{"id": 164067, "name": "Soloway's recurring rainfall", "source": "Translate Fortran to Java: function getNextInput() result(Input)\n    implicit none\n    integer :: Input\n    integer :: Reason\n    Reason = 1\n    \n    do while (Reason > 0)\n        print *, \"Enter rainfall int, 99999 to quit: \"\n        read (*,*,IOSTAT=Reason) Input\n        \n        if (Reason > 0) then\n            print *, \"Invalid input\"\n        end if\n    enddo\n    \nend function getNextInput\n\nprogram recurringrainfall\n    implicit none\n    real        :: currentAverage\n    integer     :: currentCount\n    integer     :: lastInput\n    integer     :: getNextInput\n    \n    currentAverage = 0\n    currentCount = 0\n\n    do\n        lastInput = getNextInput()\n        \n        if (lastInput == 99999) exit\n        \n        currentCount = currentCount + 1\n        currentAverage = currentAverage + (1/real(currentCount))*lastInput - (1/real(currentCount))*currentAverage\n        \n        print *, 'New Average: ', currentAverage\n    enddo \n\n    \nend program recurringrainfall\n", "target": "class recurringrainfall\n{ \n\tprivate static int GetNextInt()\n\t{\n\t\twhile (true)\n\t\t{\n\t\t\tSystem.out.print(\"Enter rainfall int, 99999 to quit: \");\n\t\t\tString input = System.console().readLine();\n        \n\t\t\ttry\n\t\t\t{\n\t\t\t\tint n = Integer.parseInt(input);\n\t\t\t\treturn n;\n\t\t\t}\n\t\t\tcatch (Exception e)\n\t\t\t{\n\t\t\t\tSystem.out.println(\"Invalid input\");\n\t\t\t}\n\t\t}\n\t}\n\t\n    private static void recurringRainfall() {\n\t\tfloat currentAverage = 0;\n\t\tint currentEntryNumber = 0;\n\t\t\n\t\twhile (true) {\n\t\t\tint entry = GetNextInt();\n\t\t\t\n\t\t\tif (entry == 99999)\n\t\t\t\treturn;\n\t\t\t\n\t\t\tcurrentEntryNumber++;\n\t\t\tcurrentAverage = currentAverage + ((float)1/currentEntryNumber)*entry - ((float)1/currentEntryNumber)*currentAverage;\n\t\t\t\n\t\t\tSystem.out.println(\"New Average: \" + currentAverage);\n\t\t}\n    }\n    \n    public static void main(String args[]) { \n        recurringRainfall();\n    } \n}\n"}
{"id": 164068, "name": "Soloway's recurring rainfall", "source": "Translate Fortran to Python: function getNextInput() result(Input)\n    implicit none\n    integer :: Input\n    integer :: Reason\n    Reason = 1\n    \n    do while (Reason > 0)\n        print *, \"Enter rainfall int, 99999 to quit: \"\n        read (*,*,IOSTAT=Reason) Input\n        \n        if (Reason > 0) then\n            print *, \"Invalid input\"\n        end if\n    enddo\n    \nend function getNextInput\n\nprogram recurringrainfall\n    implicit none\n    real        :: currentAverage\n    integer     :: currentCount\n    integer     :: lastInput\n    integer     :: getNextInput\n    \n    currentAverage = 0\n    currentCount = 0\n\n    do\n        lastInput = getNextInput()\n        \n        if (lastInput == 99999) exit\n        \n        currentCount = currentCount + 1\n        currentAverage = currentAverage + (1/real(currentCount))*lastInput - (1/real(currentCount))*currentAverage\n        \n        print *, 'New Average: ', currentAverage\n    enddo \n\n    \nend program recurringrainfall\n", "target": "import sys\n\ndef get_next_input():\n    try:\n        num = int(input(\"Enter rainfall int, 99999 to quit: \"))\n    except:\n        print(\"Invalid input\")\n        return get_next_input()\n    return num\n\ncurrent_average = 0.0\ncurrent_count = 0\n\nwhile True:\n    next = get_next_input()\n\n    if next == 99999:\n        sys.exit()\n    else:\n        current_count += 1\n        current_average = current_average + (1.0/current_count)*next - (1.0/current_count)*current_average\n        \n        print(\"New average: \", current_average)\n"}
{"id": 164549, "name": "One of n lines in a file", "source": "Translate Fortran to C#: \n\n\nprogram reservoir_sample\nuse, intrinsic :: iso_fortran_env, only : dp=>real64\nimplicit none\ncharacter(len=256)   :: line\ninteger              :: lun, n, i, count(10)\n   call random_seed()\n   \n   open(file='_data.txt',newunit=lun)\n   do i=1,10\n      write(lun,'(*(g0))')'test line ',i\n   enddo\n   \n   call one_of_n(line,n)\n   write(*,'(i10,\":\",a)')n,trim(line)\n   \n   count=0\n   do i=1,1000000\n      call one_of_n(line,n)\n      if(n.gt.0.and.n.le.10)then\n         count(n)=count(n)+1\n      else\n         write(*,*)'<ERROR>'\n      endif\n   enddo\n   write(*,*)count\n   write(*,*)count-100000\ncontains\nsubroutine one_of_n(line,n)\ncharacter(len=256),intent(out) :: line\ninteger,intent(out)            :: n\nreal(kind=dp)                  :: rand_val\ninteger                        :: ios, ilines\n   line=''\n   ios=0\n   ilines=1\n   n=0\n   rewind(lun)\n   do\n      call random_number(rand_val)\n      if( rand_val < 1.0d0/(ilines) )then\n         read(lun,'(a)',iostat=ios)line\n         if(ios/=0)exit\n         n=ilines\n      else\n         read(lun,'(a)',iostat=ios)\n         if(ios/=0)exit\n      endif\n      ilines=ilines+1\n   enddo\nend subroutine one_of_n\nend program reservoir_sample\n}\n", "target": "    class Program\n    {\n        private static Random rnd = new Random();\n        public static int one_of_n(int n)\n        {\n            int currentChoice = 1;\n            for (int i = 2; i <= n; i++)\n            {\n                double outerLimit = 1D / (double)i;\n                if (rnd.NextDouble() < outerLimit)\n                    currentChoice = i;\n            }\n            return currentChoice;\n        }\n\n        static void Main(string[] args)\n        {\n            Dictionary<int, int> results = new Dictionary<int, int>();\n            for (int i = 1; i < 11; i++)\n                results.Add(i, 0);\n\n            for (int i = 0; i < 1000000; i++)\n            {\n                int result = one_of_n(10);\n                results[result] = results[result] + 1;\n            }\n\n            for (int i = 1; i < 11; i++)\n                Console.WriteLine(\"{0}\\t{1}\", i, results[i]);\n            Console.ReadLine();\n        }\n    }\n"}
{"id": 164552, "name": "One of n lines in a file", "source": "Translate Fortran to Java: \n\n\nprogram reservoir_sample\nuse, intrinsic :: iso_fortran_env, only : dp=>real64\nimplicit none\ncharacter(len=256)   :: line\ninteger              :: lun, n, i, count(10)\n   call random_seed()\n   \n   open(file='_data.txt',newunit=lun)\n   do i=1,10\n      write(lun,'(*(g0))')'test line ',i\n   enddo\n   \n   call one_of_n(line,n)\n   write(*,'(i10,\":\",a)')n,trim(line)\n   \n   count=0\n   do i=1,1000000\n      call one_of_n(line,n)\n      if(n.gt.0.and.n.le.10)then\n         count(n)=count(n)+1\n      else\n         write(*,*)'<ERROR>'\n      endif\n   enddo\n   write(*,*)count\n   write(*,*)count-100000\ncontains\nsubroutine one_of_n(line,n)\ncharacter(len=256),intent(out) :: line\ninteger,intent(out)            :: n\nreal(kind=dp)                  :: rand_val\ninteger                        :: ios, ilines\n   line=''\n   ios=0\n   ilines=1\n   n=0\n   rewind(lun)\n   do\n      call random_number(rand_val)\n      if( rand_val < 1.0d0/(ilines) )then\n         read(lun,'(a)',iostat=ios)line\n         if(ios/=0)exit\n         n=ilines\n      else\n         read(lun,'(a)',iostat=ios)\n         if(ios/=0)exit\n      endif\n      ilines=ilines+1\n   enddo\nend subroutine one_of_n\nend program reservoir_sample\n}\n", "target": "import java.util.Arrays;\nimport java.util.Random;\n\npublic class OneOfNLines {\n\n\tstatic Random rand;\n\t\n\tpublic static int oneOfN(int n) {\n\t\tint choice = 0;\n\t\t\n\t\tfor(int i = 1; i < n; i++) {\n\t\t\tif(rand.nextInt(i+1) == 0)\n\t\t\t\tchoice = i;\n\t\t}\n\t\t\n\t\treturn choice;\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tint n = 10;\n\t\tint trials = 1000000;\n\t\tint[] bins = new int[n];\n\t\trand = new Random();\n\t\t\n\t\tfor(int i = 0; i < trials; i++)\n\t\t\tbins[oneOfN(n)]++;\n\t\t\n\t\t\n\t\tSystem.out.println(Arrays.toString(bins));\n\t}\n}\n"}
{"id": 164553, "name": "One of n lines in a file", "source": "Translate Fortran to Python: \n\n\nprogram reservoir_sample\nuse, intrinsic :: iso_fortran_env, only : dp=>real64\nimplicit none\ncharacter(len=256)   :: line\ninteger              :: lun, n, i, count(10)\n   call random_seed()\n   \n   open(file='_data.txt',newunit=lun)\n   do i=1,10\n      write(lun,'(*(g0))')'test line ',i\n   enddo\n   \n   call one_of_n(line,n)\n   write(*,'(i10,\":\",a)')n,trim(line)\n   \n   count=0\n   do i=1,1000000\n      call one_of_n(line,n)\n      if(n.gt.0.and.n.le.10)then\n         count(n)=count(n)+1\n      else\n         write(*,*)'<ERROR>'\n      endif\n   enddo\n   write(*,*)count\n   write(*,*)count-100000\ncontains\nsubroutine one_of_n(line,n)\ncharacter(len=256),intent(out) :: line\ninteger,intent(out)            :: n\nreal(kind=dp)                  :: rand_val\ninteger                        :: ios, ilines\n   line=''\n   ios=0\n   ilines=1\n   n=0\n   rewind(lun)\n   do\n      call random_number(rand_val)\n      if( rand_val < 1.0d0/(ilines) )then\n         read(lun,'(a)',iostat=ios)line\n         if(ios/=0)exit\n         n=ilines\n      else\n         read(lun,'(a)',iostat=ios)\n         if(ios/=0)exit\n      endif\n      ilines=ilines+1\n   enddo\nend subroutine one_of_n\nend program reservoir_sample\n}\n", "target": "from random import randrange\ntry:\n    range = xrange\nexcept: pass\n\ndef one_of_n(lines): \n    choice = None\n    for i, line in enumerate(lines):\n        if randrange(i+1) == 0:\n            choice = line\n    return choice\n            \ndef one_of_n_test(n=10, trials=1000000):\n    bins = [0] * n\n    if n:\n        for i in range(trials):\n            bins[one_of_n(range(n))] += 1\n    return bins\n\nprint(one_of_n_test())\n"}
{"id": 165061, "name": "Stream merge", "source": "Translate Fortran to C#:       SUBROUTINE FILEMERGE(N,INF,OUTF)\t\n       INTEGER N\t\n       INTEGER INF(*)\t\n       INTEGER OUTF\t\n       INTEGER L(N)\t\n       INTEGER LIST(0:N)\n       LOGICAL LIVE(N)\t\n       INTEGER ENUFF\t\t\n       PARAMETER (ENUFF = 666)\t\n       CHARACTER*(ENUFF) AREC(N)\n       INTEGER I,IT\t\n        LIST = 0\t\n        LIVE = .TRUE.\t\nCharge the battery.\n        DO I = 1,N\t\n          CALL GRAB(I)\t\t\n        END DO\t\t\nChug away.\n        DO WHILE(LIST(0).GT.0)\t\n          IT = LIST(0)\t\t\n          WRITE (OUTF,\"(A)\") AREC(IT)(1:L(IT))\t\n          LIST(0) = LIST(IT)\t\n          CALL GRAB(IT)\t\t\n        END DO\t\t\t\n\n       CONTAINS\t\n        SUBROUTINE GRAB(IN)\t\n         INTEGER IN\t\t\n         INTEGER IT,P\t\t\n          IF (.NOT.LIVE(IN)) RETURN\t\n          READ (INF(IN),1,END = 10) L(IN),AREC(IN)(1:MIN(ENUFF,L(IN)))\t\n    1     FORMAT (Q,A)\t\t\nConsider the place of AREC(IN) in the LIST. Entry LIST(IN) is to be linked back in.\n          P = 0\t\t\n    2     IT = LIST(P)\t\t\n          IF (IT.GT.0) THEN\t\n            IF (AREC(IN)(1:L(IN)).GT.AREC(IT)(1:L(IT))) THEN\t\n              P = IT\t\t\t\n              GO TO 2\t\t\t\n            END IF\t\t\n          END IF\t\n          LIST(IN) = IT\t\t\n          LIST(P) = IN\t\t\n          RETURN\t\n   10     LIVE(IN) = .FALSE.\t\n          LIST(IN) = -666\t\n        END SUBROUTINE GRAB\t\n      END SUBROUTINE FILEMERGE\t\n\n      PROGRAM MASH\n      INTEGER MANY\n      PARAMETER (MANY = 4)\t\n      INTEGER FI(MANY)\n      CHARACTER*(28) FNAME(MANY)\n      DATA FNAME/\"FileAppend.for\",\"FileChop.for\",\n     1 \"FileExt.for\",\"FileHack.for\"/\n      INTEGER I,F\n\n      F = 10\t\n      OPEN (F,FILE=\"Merged.txt\",STATUS=\"REPLACE\",ACTION=\"WRITE\")\t\n      DO I = 1,MANY\t\n        FI(I) = F + I\t\t\n        OPEN (FI(I),FILE=FNAME(I),STATUS=\"OLD\",ACTION=\"READ\")\t\n      END DO\t\t\n\n      CALL FILEMERGE(MANY,FI,F)\t\n\n      END\t\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\nnamespace RosettaCode\n{\n    static class StreamMerge\n    {\n        static IEnumerable<T> Merge2<T>(IEnumerable<T> source1, IEnumerable<T> source2) where T : IComparable\n        {\n            var q1 = new Queue<T>(source1);\n            var q2 = new Queue<T>(source2);\n            while (q1.Any() && q2.Any())\n            {\n                var c = q1.Peek().CompareTo(q2.Peek());\n                if (c <= 0) yield return q1.Dequeue(); else yield return q2.Dequeue();\n            }\n            while (q1.Any()) yield return q1.Dequeue();\n            while (q2.Any()) yield return q2.Dequeue();\n        }\n\n        static IEnumerable<T> MergeN<T>(params IEnumerable<T>[] sources) where T : IComparable\n        {\n            var queues = sources.Select(e => new Queue<T>(e)).Where(q => q.Any()).ToList();\n            var headComparer = Comparer<Queue<T>>.Create((x, y) => x.Peek().CompareTo(y.Peek()));\n            queues.Sort(headComparer);\n            \n            while (queues.Any())\n            {\n                var q = queues.First();\n                queues.RemoveAt(0);\n                yield return q.Dequeue();\n                if (q.Any())\n                {\n                    var index = queues.BinarySearch(q, headComparer);\n                    queues.Insert(index < 0 ? ~index : index, q);\n                }\n            }\n        }\n\n        static void Main()\n        {\n            var a = new[] { 1, 4, 7, 10 };\n            var b = new[] { 2, 5, 8, 11 };\n            var c = new[] { 3, 6, 9, 12 };\n\n            foreach (var i in Merge2(a, b)) Console.Write($\"{i} \");\n            Console.WriteLine();\n\n            foreach (var i in MergeN(a, b, c)) Console.Write($\"{i} \");\n            Console.WriteLine();\n        }\n    }\n}\n"}
{"id": 165064, "name": "Stream merge", "source": "Translate Fortran to Java:       SUBROUTINE FILEMERGE(N,INF,OUTF)\t\n       INTEGER N\t\n       INTEGER INF(*)\t\n       INTEGER OUTF\t\n       INTEGER L(N)\t\n       INTEGER LIST(0:N)\n       LOGICAL LIVE(N)\t\n       INTEGER ENUFF\t\t\n       PARAMETER (ENUFF = 666)\t\n       CHARACTER*(ENUFF) AREC(N)\n       INTEGER I,IT\t\n        LIST = 0\t\n        LIVE = .TRUE.\t\nCharge the battery.\n        DO I = 1,N\t\n          CALL GRAB(I)\t\t\n        END DO\t\t\nChug away.\n        DO WHILE(LIST(0).GT.0)\t\n          IT = LIST(0)\t\t\n          WRITE (OUTF,\"(A)\") AREC(IT)(1:L(IT))\t\n          LIST(0) = LIST(IT)\t\n          CALL GRAB(IT)\t\t\n        END DO\t\t\t\n\n       CONTAINS\t\n        SUBROUTINE GRAB(IN)\t\n         INTEGER IN\t\t\n         INTEGER IT,P\t\t\n          IF (.NOT.LIVE(IN)) RETURN\t\n          READ (INF(IN),1,END = 10) L(IN),AREC(IN)(1:MIN(ENUFF,L(IN)))\t\n    1     FORMAT (Q,A)\t\t\nConsider the place of AREC(IN) in the LIST. Entry LIST(IN) is to be linked back in.\n          P = 0\t\t\n    2     IT = LIST(P)\t\t\n          IF (IT.GT.0) THEN\t\n            IF (AREC(IN)(1:L(IN)).GT.AREC(IT)(1:L(IT))) THEN\t\n              P = IT\t\t\t\n              GO TO 2\t\t\t\n            END IF\t\t\n          END IF\t\n          LIST(IN) = IT\t\t\n          LIST(P) = IN\t\t\n          RETURN\t\n   10     LIVE(IN) = .FALSE.\t\n          LIST(IN) = -666\t\n        END SUBROUTINE GRAB\t\n      END SUBROUTINE FILEMERGE\t\n\n      PROGRAM MASH\n      INTEGER MANY\n      PARAMETER (MANY = 4)\t\n      INTEGER FI(MANY)\n      CHARACTER*(28) FNAME(MANY)\n      DATA FNAME/\"FileAppend.for\",\"FileChop.for\",\n     1 \"FileExt.for\",\"FileHack.for\"/\n      INTEGER I,F\n\n      F = 10\t\n      OPEN (F,FILE=\"Merged.txt\",STATUS=\"REPLACE\",ACTION=\"WRITE\")\t\n      DO I = 1,MANY\t\n        FI(I) = F + I\t\t\n        OPEN (FI(I),FILE=FNAME(I),STATUS=\"OLD\",ACTION=\"READ\")\t\n      END DO\t\t\n\n      CALL FILEMERGE(MANY,FI,F)\t\n\n      END\t\n", "target": "import java.util.Iterator;\nimport java.util.List;\nimport java.util.Objects;\n\npublic class StreamMerge {\n    private static <T extends Comparable<T>> void merge2(Iterator<T> i1, Iterator<T> i2) {\n        T a = null, b = null;\n\n        while (i1.hasNext() || i2.hasNext()) {\n            if (null == a && i1.hasNext()) {\n                a = i1.next();\n            }\n            if (null == b && i2.hasNext()) {\n                b = i2.next();\n            }\n\n            if (null != a) {\n                if (null != b) {\n                    if (a.compareTo(b) < 0) {\n                        System.out.print(a);\n                        a = null;\n                    } else {\n                        System.out.print(b);\n                        b = null;\n                    }\n                } else {\n                    System.out.print(a);\n                    a = null;\n                }\n            } else if (null != b) {\n                System.out.print(b);\n                b = null;\n            }\n        }\n\n        if (null != a) {\n            System.out.print(a);\n        }\n        if (null != b) {\n            System.out.print(b);\n        }\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    @SafeVarargs\n    private static <T extends Comparable<T>> void mergeN(Iterator<T>... iter) {\n        Objects.requireNonNull(iter);\n        if (iter.length == 0) {\n            throw new IllegalArgumentException(\"Must have at least one iterator\");\n        }\n\n        Object[] pa = new Object[iter.length];\n        boolean done;\n\n        do {\n            done = true;\n\n            for (int i = 0; i < iter.length; i++) {\n                Iterator<T> t = iter[i];\n                if (null == pa[i] && t.hasNext()) {\n                    pa[i] = t.next();\n                }\n            }\n\n            T min = null;\n            int idx = -1;\n            for (int i = 0; i < pa.length; ++i) {\n                T t = (T) pa[i];\n                if (null != t) {\n                    if (null == min) {\n                        min = t;\n                        idx = i;\n                        done = false;\n                    } else if (t.compareTo(min) < 0) {\n                        min = t;\n                        idx = i;\n                        done = false;\n                    }\n                }\n            }\n            if (idx != -1) {\n                System.out.print(min);\n                pa[idx] = null;\n            }\n        } while (!done);\n    }\n\n    public static void main(String[] args) {\n        List<Integer> l1 = List.of(1, 4, 7, 10);\n        List<Integer> l2 = List.of(2, 5, 8, 11);\n        List<Integer> l3 = List.of(3, 6, 9, 12);\n\n        merge2(l1.iterator(), l2.iterator());\n        System.out.println();\n\n        mergeN(l1.iterator(), l2.iterator(), l3.iterator());\n        System.out.println();\n        System.out.flush();\n    }\n}\n"}
{"id": 165065, "name": "Stream merge", "source": "Translate Fortran to Python:       SUBROUTINE FILEMERGE(N,INF,OUTF)\t\n       INTEGER N\t\n       INTEGER INF(*)\t\n       INTEGER OUTF\t\n       INTEGER L(N)\t\n       INTEGER LIST(0:N)\n       LOGICAL LIVE(N)\t\n       INTEGER ENUFF\t\t\n       PARAMETER (ENUFF = 666)\t\n       CHARACTER*(ENUFF) AREC(N)\n       INTEGER I,IT\t\n        LIST = 0\t\n        LIVE = .TRUE.\t\nCharge the battery.\n        DO I = 1,N\t\n          CALL GRAB(I)\t\t\n        END DO\t\t\nChug away.\n        DO WHILE(LIST(0).GT.0)\t\n          IT = LIST(0)\t\t\n          WRITE (OUTF,\"(A)\") AREC(IT)(1:L(IT))\t\n          LIST(0) = LIST(IT)\t\n          CALL GRAB(IT)\t\t\n        END DO\t\t\t\n\n       CONTAINS\t\n        SUBROUTINE GRAB(IN)\t\n         INTEGER IN\t\t\n         INTEGER IT,P\t\t\n          IF (.NOT.LIVE(IN)) RETURN\t\n          READ (INF(IN),1,END = 10) L(IN),AREC(IN)(1:MIN(ENUFF,L(IN)))\t\n    1     FORMAT (Q,A)\t\t\nConsider the place of AREC(IN) in the LIST. Entry LIST(IN) is to be linked back in.\n          P = 0\t\t\n    2     IT = LIST(P)\t\t\n          IF (IT.GT.0) THEN\t\n            IF (AREC(IN)(1:L(IN)).GT.AREC(IT)(1:L(IT))) THEN\t\n              P = IT\t\t\t\n              GO TO 2\t\t\t\n            END IF\t\t\n          END IF\t\n          LIST(IN) = IT\t\t\n          LIST(P) = IN\t\t\n          RETURN\t\n   10     LIVE(IN) = .FALSE.\t\n          LIST(IN) = -666\t\n        END SUBROUTINE GRAB\t\n      END SUBROUTINE FILEMERGE\t\n\n      PROGRAM MASH\n      INTEGER MANY\n      PARAMETER (MANY = 4)\t\n      INTEGER FI(MANY)\n      CHARACTER*(28) FNAME(MANY)\n      DATA FNAME/\"FileAppend.for\",\"FileChop.for\",\n     1 \"FileExt.for\",\"FileHack.for\"/\n      INTEGER I,F\n\n      F = 10\t\n      OPEN (F,FILE=\"Merged.txt\",STATUS=\"REPLACE\",ACTION=\"WRITE\")\t\n      DO I = 1,MANY\t\n        FI(I) = F + I\t\t\n        OPEN (FI(I),FILE=FNAME(I),STATUS=\"OLD\",ACTION=\"READ\")\t\n      END DO\t\t\n\n      CALL FILEMERGE(MANY,FI,F)\t\n\n      END\t\n", "target": "import heapq\nimport sys\n\nsources = sys.argv[1:]\nfor item in heapq.merge(open(source) for source in sources):\n    print(item)\n"}
{"id": 165204, "name": "The Twelve Days of Christmas", "source": "Translate Fortran to C#:       program twelve_days\n\n      character days(12)*8\n      data days/'first', 'second', 'third',    'fourth',\n     c          'fifth', 'sixth',  'seventh',  'eighth',\n     c          'ninth', 'tenth',  'eleventh', 'twelfth'/\n\n      character gifts(12)*27\n      data gifts/'A partridge in a pear tree.',\n     c           'Two turtle doves and',\n     c           'Three French hens,',\n     c           'Four calling birds,',\n     c           'Five gold rings,',\n     c           'Six geese a-laying,',\n     c           'Seven swans a-swimming,',\n     c           'Eight maids a-milking,',\n     c           'Nine ladies dancing,',\n     c           'Ten lords a-leaping,',\n     c           'Eleven pipers piping,',\n     c           'Twelve drummers drumming,'/\n\n      integer day, gift\n\n      do 10 day=1,12\n        write (*,'(a)') 'On the ', trim(days(day)),\n     c              ' day of Christmas, my true love sent to me:'\n        do 20 gift=day,1,-1\n          write (*,'(a)') trim(gifts(gift))\n  20    continue\n        write(*,*)\n  10  continue\n      end\n", "target": "using System;\n\npublic class TwelveDaysOfChristmas {\n\n    public static void Main() {\n\n        string[] days = new string[12] {\n            \"first\", \"second\", \"third\", \"fourth\", \"fifth\", \"sixth\", \"seventh\", \"eighth\", \"ninth\",\n            \"tenth\", \"eleventh\", \"twelfth\",\n        };\n\n        string[] gifts = new string[12] {\n            \"A partridge in a pear tree\",\n            \"Two turtle doves\",\n            \"Three french hens\",\n            \"Four calling birds\",\n            \"Five golden rings\",\n            \"Six geese a-laying\",\n            \"Seven swans a-swimming\",\n            \"Eight maids a-milking\",\n            \"Nine ladies dancing\",\n            \"Ten lords a-leaping\",\n            \"Eleven pipers piping\",\n            \"Twelve drummers drumming\"\n        };\n\n        for ( int i = 0; i < 12; i++ ) {\n\n            Console.WriteLine(\"On the \" + days[i] + \" day of Christmas, my true love gave to me\");\n\n            int j = i + 1;\n            while ( j-- > 0 )\n                Console.WriteLine(gifts[j]);\n\n            Console.WriteLine();\n\n            if ( i == 0 )\n                gifts[0] = \"And a partridge in a pear tree\";\n        }\n\n    }\n\n}\n"}
{"id": 165207, "name": "The Twelve Days of Christmas", "source": "Translate Fortran to Java:       program twelve_days\n\n      character days(12)*8\n      data days/'first', 'second', 'third',    'fourth',\n     c          'fifth', 'sixth',  'seventh',  'eighth',\n     c          'ninth', 'tenth',  'eleventh', 'twelfth'/\n\n      character gifts(12)*27\n      data gifts/'A partridge in a pear tree.',\n     c           'Two turtle doves and',\n     c           'Three French hens,',\n     c           'Four calling birds,',\n     c           'Five gold rings,',\n     c           'Six geese a-laying,',\n     c           'Seven swans a-swimming,',\n     c           'Eight maids a-milking,',\n     c           'Nine ladies dancing,',\n     c           'Ten lords a-leaping,',\n     c           'Eleven pipers piping,',\n     c           'Twelve drummers drumming,'/\n\n      integer day, gift\n\n      do 10 day=1,12\n        write (*,'(a)') 'On the ', trim(days(day)),\n     c              ' day of Christmas, my true love sent to me:'\n        do 20 gift=day,1,-1\n          write (*,'(a)') trim(gifts(gift))\n  20    continue\n        write(*,*)\n  10  continue\n      end\n", "target": "public class TwelveDaysOfChristmas {\n\n    final static String[] gifts = {\n        \"A partridge in a pear tree.\", \"Two turtle doves and\",\n        \"Three french hens\", \"Four calling birds\",\n        \"Five golden rings\", \"Six geese a-laying\",\n        \"Seven swans a-swimming\", \"Eight maids a-milking\",\n        \"Nine ladies dancing\", \"Ten lords a-leaping\",\n        \"Eleven pipers piping\", \"Twelve drummers drumming\",\n        \"And a partridge in a pear tree.\", \"Two turtle doves\"\n    };\n\n    final static String[] days = {\n        \"first\", \"second\", \"third\", \"fourth\", \"fifth\", \"sixth\", \"seventh\",\n        \"eighth\", \"ninth\", \"tenth\", \"eleventh\", \"Twelfth\"\n    };\n\n    public static void main(String[] args) {\n        for (int i = 0; i < days.length; i++) {\n            System.out.printf(\"%nOn the %s day of Christmas%n\", days[i]);\n            System.out.println(\"My true love gave to me:\");\n            for (int j = i; j >= 0; j--)\n                System.out.println(gifts[i == 11 && j < 2 ? j + 12 : j]);\n        }\n    }\n}\n"}
{"id": 165208, "name": "The Twelve Days of Christmas", "source": "Translate Fortran to Python:       program twelve_days\n\n      character days(12)*8\n      data days/'first', 'second', 'third',    'fourth',\n     c          'fifth', 'sixth',  'seventh',  'eighth',\n     c          'ninth', 'tenth',  'eleventh', 'twelfth'/\n\n      character gifts(12)*27\n      data gifts/'A partridge in a pear tree.',\n     c           'Two turtle doves and',\n     c           'Three French hens,',\n     c           'Four calling birds,',\n     c           'Five gold rings,',\n     c           'Six geese a-laying,',\n     c           'Seven swans a-swimming,',\n     c           'Eight maids a-milking,',\n     c           'Nine ladies dancing,',\n     c           'Ten lords a-leaping,',\n     c           'Eleven pipers piping,',\n     c           'Twelve drummers drumming,'/\n\n      integer day, gift\n\n      do 10 day=1,12\n        write (*,'(a)') 'On the ', trim(days(day)),\n     c              ' day of Christmas, my true love sent to me:'\n        do 20 gift=day,1,-1\n          write (*,'(a)') trim(gifts(gift))\n  20    continue\n        write(*,*)\n  10  continue\n      end\n", "target": "gifts = .split('\\n')\n\ndays = .split()\n\nfor n, day in enumerate(days, 1):\n    g = gifts[:n][::-1]\n    print(('\\nOn the %s day of Christmas\\nMy true love gave to me:\\n' % day) +\n          '\\n'.join(g[:-1]) +\n          (' and\\n' + g[-1] if n > 1 else g[-1].capitalize()))\n"}

{"id": 335312, "name": "Pascal matrix generation", "source": "Translate Ruby to C#: \nrequire 'pp'\n\nng = (g = 0..4).collect{[]}\ng.each{|i| g.each{|j| ng[i][j] = i==0 ? 1 : j<i ? 0 : ng[i-1][j-1]+ng[i][j-1]}}\npp ng; puts\ng.each{|i| g.each{|j| ng[i][j] = j==0 ? 1 : i<j ? 0 : ng[i-1][j-1]+ng[i-1][j]}}\npp ng; puts\ng.each{|i| g.each{|j| ng[i][j] = (i==0 or j==0) ? 1 : ng[i-1][j  ]+ng[i][j-1]}}\npp ng\n", "target": "using System;\n\npublic static class PascalMatrixGeneration\n{\n    public static void Main() {\n        Print(GenerateUpper(5));\n        Console.WriteLine();\n        Print(GenerateLower(5));\n        Console.WriteLine();\n        Print(GenerateSymmetric(5));\n    }\n\n    static int[,] GenerateUpper(int size) {\n        int[,] m = new int[size, size];\n        for (int c = 0; c < size; c++) m[0, c] = 1;\n        for (int r = 1; r < size; r++) {\n            for (int c = r; c < size; c++) {\n                m[r, c] = m[r-1, c-1] + m[r, c-1];\n            }\n        }\n        return m;\n    }\n\n    static int[,] GenerateLower(int size) {\n        int[,] m = new int[size, size];\n        for (int r = 0; r < size; r++) m[r, 0] = 1;\n        for (int c = 1; c < size; c++) {\n            for (int r = c; r < size; r++) {\n                m[r, c] = m[r-1, c-1] + m[r-1, c];\n            }\n        }\n        return m;\n    }\n\n    static int[,] GenerateSymmetric(int size) {\n        int[,] m = new int[size, size];\n        for (int i = 0; i < size; i++) m[0, i] = m[i, 0] = 1;\n        for (int r = 1; r < size; r++) {\n            for (int c = 1; c < size; c++) {\n                m[r, c] = m[r-1, c] + m[r, c-1];\n            }\n        }\n        return m;\n    }\n\n    static void Print(int[,] matrix) {\n        string[,] m = ToString(matrix);\n        int width = m.Cast<string>().Select(s => s.Length).Max();\n        int rows = matrix.GetLength(0), columns = matrix.GetLength(1);\n        for (int row = 0; row < rows; row++) {\n            Console.WriteLine(\"|\" + string.Join(\" \", Range(0, columns).Select(column => m[row, column].PadLeft(width, ' '))) + \"|\");\n        }\n    }\n\n    static string[,] ToString(int[,] matrix) {\n        int rows = matrix.GetLength(0), columns = matrix.GetLength(1);\n        string[,] m = new string[rows, columns];\n        for (int r = 0; r < rows; r++) {\n            for (int c = 0; c < columns; c++) {\n                m[r, c] = matrix[r, c].ToString();\n            }\n        }\n        return m;\n    }\n    \n}\n"}
{"id": 335313, "name": "Mad Libs", "source": "Translate Ruby to C#: puts \"Enter a story, terminated by an empty line:\"\nstory = \"\"\nuntil (line = gets).chomp.empty?\n  story << line\nend\n\nstory.scan(/(?<=[<]).+?(?=[>])/).uniq.each do |var|\n  print \"Enter a value for '\n  story.gsub!(/<\nend\n\nputs\nputs story\n", "target": "using System;\nusing System.Linq;\nusing System.Text;\nusing System.Text.RegularExpressions;\n\nnamespace MadLibs_RosettaCode\n{\n\tclass Program\n\t{\n\t\tstatic void Main(string[] args)\n\t\t{\n\t\t\tstring madLibs = \n@\"Write a program to create a Mad Libs like story.\nThe program should read an arbitrary multiline story from input.\nThe story will be terminated with a blank line.\nThen, find each replacement to be made within the story, \nask the user for a word to replace it with, and make all the replacements.\nStop when there are none left and print the final story.\nThe input should be an arbitrary story in the form:\n<name> went for a walk in the park. <he or she>\nfound a <noun>. <name> decided to take it home.\nGiven this example, it should then ask for a name, \na he or she and a noun (<name> gets replaced both times with the same value).\";\n\n\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\tRegex pattern = new Regex(@\"\\<(.*?)\\>\");\n\t\t\tstring storyLine;\n\t\t\tstring replacement;\n\n\t\t\tConsole.WriteLine(madLibs + Environment.NewLine + Environment.NewLine);\n\t\t\tConsole.WriteLine(\"Enter a story: \");\n\n\t\t\t\n\t\t\tdo\n\t\t\t{\n\t\t\t\tstoryLine = Console.ReadLine();\n\t\t\t\tsb.Append(storyLine + Environment.NewLine);\n\t\t\t} while (!string.IsNullOrEmpty(storyLine) && !string.IsNullOrWhiteSpace(storyLine));\n\n\t\t\t\n\t\t\tMatch nameMatch = pattern.Matches(sb.ToString()).OfType<Match>().Where(x => x.Value.Equals(\"<name>\")).Select(x => x.Value).Distinct() as Match;\n\t\t\tif(nameMatch != null)\n\t\t\t{\n\t\t\t\tdo\n\t\t\t\t{\n\t\t\t\t\tConsole.WriteLine(\"Enter value for: \" + nameMatch.Value);\n\t\t\t\t\treplacement = Console.ReadLine();\n\t\t\t\t} while (string.IsNullOrEmpty(replacement) || string.IsNullOrWhiteSpace(replacement));\n\t\t\t\tsb.Replace(nameMatch.Value, replacement);\n\t\t\t}\n\n\t\t\tforeach (Match match in pattern.Matches(sb.ToString()))\n\t\t\t{\n\t\t\t\treplacement = string.Empty;\n\t\t\t\t\n\t\t\t\tdo\n\t\t\t\t{\n\t\t\t\t\tConsole.WriteLine(\"Enter value for: \" + match.Value);\n\t\t\t\t\treplacement = Console.ReadLine();\n\t\t\t\t} while (string.IsNullOrEmpty(replacement) || string.IsNullOrWhiteSpace(replacement));\n\n\t\t\t\tint location = sb.ToString().IndexOf(match.Value);\n\t\t\t\tsb.Remove(location, match.Value.Length).Insert(location, replacement);\n\t\t\t}\n\n\t\t\tConsole.WriteLine(Environment.NewLine + Environment.NewLine + \"--[ Here's your story! ]--\");\n\t\t\tConsole.WriteLine(sb.ToString());\n\t\t}\n\t}\n}\n"}
{"id": 335314, "name": "Shortest common supersequence", "source": "Translate Ruby to C#: require 'lcs'\n\ndef scs(u, v)\n  lcs = lcs(u, v)\n  u, v = u.dup, v.dup\n  scs = \"\"\n  \n  until lcs.empty?\n    if u[0]==lcs[0] and v[0]==lcs[0]\n      \n      scs << lcs.slice!(0)\n      u.slice!(0)\n      v.slice!(0)\n    elsif u[0]==lcs[0]\n      \n      scs << v.slice!(0)\n    else\n      \n      scs << u.slice!(0)\n    end\n  end\n  \n  scs + u + v\nend\n\nu = \"abcbdab\"\nv = \"bdcaba\"\nputs \"SCS(\n", "target": "public class ShortestCommonSupersequence\n{\n    Dictionary<(string, string), string> cache = new();\n\n    public string scs(string x, string y)\n    {\n        if (x.Length == 0) return y;\n        if (y.Length == 0) return x;\n\n        if (cache.TryGetValue((x, y), out var result)) return result;\n\n        if (x[0] == y[0])\n        {\n            return cache[(x, y)] = x[0] + scs(x.Substring(1), y.Substring(1));\n        }\n\n        var xr = scs(x.Substring(1), y);\n        var yr = scs(x, y.Substring(1));\n        if (yr.Length <= xr.Length)\n        {\n            return cache[(x, y)] = y[0] + yr;\n        }\n        else\n        {\n            return cache[(x, y)] = x[0] + xr;\n        }\n    }\n\n    public static void Main(string[] args)\n    {\n        var scs = new ShortestCommonSupersequence();\n        Console.WriteLine(scs.scs(\"abcbdab\", \"bdcaba\"));\n    }\n}\n"}
{"id": 335315, "name": "Long year", "source": "Translate Ruby to C#: require 'date'\n\ndef long_year?(year = Date.today.year)\n  Date.new(year, 12, 28).cweek == 53\nend\n\n(2020..2030).each{|year| puts \"\n", "target": "using static System.Console;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Globalization;\n\npublic static class Program\n{\n    public static void Main()\n    {\n        WriteLine(\"Long years in the 21st century:\");\n        WriteLine(string.Join(\" \", 2000.To(2100).Where(y => ISOWeek.GetWeeksInYear(y) == 53)));\n    }\n    \n    public static IEnumerable<int> To(this int start, int end) {\n        for (int i = start; i < end; i++) yield return i;\n    }\n    \n}\n"}
{"id": 335316, "name": "Mian-Chowla sequence", "source": "Translate Ruby to C#: require 'set'\nn, ts, mc, sums = 100, [], [1], Set.new\nsums << 2\nst = Time.now\nfor i in (1 .. (n-1))\n   for j in mc[i-1]+1 .. Float::INFINITY\n      mc[i] = j\n      for k in (0 .. i)\n         if (sums.include?(sum = mc[k]+j))\n            ts.clear\n            break \n         end\n         ts << sum\n      end\n      if (ts.length > 0)\n         sums = sums | ts\n         break\n      end\n   end\nend\net = (Time.now - st) * 1000\ns = \" of the Mian-Chowla sequence are:\\n\"\nputs \"The first 30 terms\nputs \"Terms 91 to 100\nputs \"Computation time was \n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\nusing System.Linq;\n\nstatic class Program {\n    static int[] MianChowla(int n) {\n        int[] mc = new int[n - 1 + 1];\n        HashSet<int> sums = new HashSet<int>(), ts = new HashSet<int>();\n        int sum; mc[0] = 1; sums.Add(2);\n        for (int i = 1; i <= n - 1; i++) {\n            for (int j = mc[i - 1] + 1; ; j++) {\n                mc[i] = j;\n                for (int k = 0; k <= i; k++) {\n                    sum = mc[k] + j;\n                    if (sums.Contains(sum)) { ts.Clear(); break; }\n                    ts.Add(sum);\n                }\n                if (ts.Count > 0) { sums.UnionWith(ts); break; }\n            }\n        }\n        return mc;\n    }\n\n    static void Main(string[] args)\n    {\n        const int n = 100; Stopwatch sw = new Stopwatch();\n        string str = \" of the Mian-Chowla sequence are:\\n\";\n        sw.Start(); int[] mc = MianChowla(n); sw.Stop();\n        Console.Write(\"The first 30 terms{1}{2}{0}{0}Terms 91 to 100{1}{3}{0}{0}\" +\n            \"Computation time was {4}ms.{0}\", '\\n', str, string.Join(\" \", mc.Take(30)),\n            string.Join(\" \", mc.Skip(n - 10)), sw.ElapsedMilliseconds);\n    }\n}\n"}
{"id": 335317, "name": "Water collected between towers", "source": "Translate Ruby to C#: def a(array)\nn=array.length\nleft={}\nright={}\nleft[0]=array[0]\ni=1\nloop do\n   break if i >=n\nleft[i]=[left[i-1],array[i]].max\n   i += 1  \nend\nright[n-1]=array[n-1]\ni=n-2\nloop do \nbreak if i<0\n right[i]=[right[i+1],array[i]].max\ni-=1\nend\ni=0\nwater=0\nloop do\nbreak if i>=n\nwater+=[left[i],right[i]].min-array[i]\ni+=1\nend\nputs water\nend\n\na([ 5, 3,  7, 2, 6, 4, 5, 9, 1, 2 ])\na([ 2, 6,  3, 5, 2, 8, 1, 4, 2, 2, 5, 3, 5, 7, 4, 1 ])\na([ 5, 5,  5, 5 ])\na([ 5, 6,  7, 8 ])\na([ 8, 7,  7, 6 ])\na([ 6, 7, 10, 7, 6 ])\nreturn\n", "target": "class Program\n{\n    static void Main(string[] args)\n    {\n        int[][] wta = {\n            new int[] {1, 5, 3, 7, 2},   new int[] { 5, 3, 7, 2, 6, 4, 5, 9, 1, 2 },\n            new int[] { 2, 6, 3, 5, 2, 8, 1, 4, 2, 2, 5, 3, 5, 7, 4, 1 },\n            new int[] { 5, 5, 5, 5 },    new int[] { 5, 6, 7, 8 },\n            new int[] { 8, 7, 7, 6 },    new int[] { 6, 7, 10, 7, 6 }};\n        string blk, lf = \"\\n\", tb = \"\u2588\u2588\", wr = \"\u2248\u2248\", mt = \"  \";\n        for (int i = 0; i < wta.Length; i++)\n        {\n            int bpf; blk = \"\"; do\n            {\n                string floor = \"\"; bpf = 0; for (int j = 0; j < wta[i].Length; j++)\n                {\n                    if (wta[i][j] > 0)\n                    {    floor += tb; wta[i][j] -= 1; bpf += 1; }\n                    else floor += (j > 0 && j < wta[i].Length - 1 ? wr : mt);\n                }\n                if (bpf > 0) blk = floor + lf + blk;\n            } while (bpf > 0);\n            while (blk.Contains(mt + wr)) blk = blk.Replace(mt + wr, mt + mt);\n            while (blk.Contains(wr + mt)) blk = blk.Replace(wr + mt, mt + mt);\n            if (args.Length > 0) System.Console.Write(\"\\n{0}\", blk);\n            System.Console.WriteLine(\"Block {0} retains {1,2} water units.\",\n                i + 1, (blk.Length - blk.Replace(wr, \"\").Length) / 2);\n        }\n    }\n}\n"}
{"id": 335318, "name": "FASTA format", "source": "Translate Ruby to C#: \ntmpfile = \"/tmp/tmp\"+Random.rand.to_s+\".fasta\"\nFile.write(tmpfile, \">Rosetta_Example_1\nTHERECANBENOSPACE\n>Rosetta_Example_2\nTHERECANBESEVERAL\nLINESBUTTHEYALLMUST\nBECONCATENATED\")\n\n\nref = tmpfile\nid = seq = \"\"\nfasta = {} of String => String\nFile.each_line(ref) do |line|\n  if line.starts_with?(\">\")\n    fasta[id] = seq.sub(/\\s/, \"\") if id != \"\"\n    id = line.split(/\\s/)[0].lstrip(\">\")\n    seq = \"\"\n  else\n    seq += line\n  end\nend\nfasta[id] = seq.sub(/\\s/, \"\")\n\n\nfasta.each { |k,v| puts \"\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.IO;\nusing System.Text;\n\nclass Program\n{\n    public class FastaEntry\n    {\n        public string Name { get; set; }\n        public StringBuilder Sequence { get; set; }\n    }\n\n    static IEnumerable<FastaEntry> ParseFasta(StreamReader fastaFile)\n    {\n        FastaEntry f = null;\n        string line;\n        while ((line = fastaFile.ReadLine()) != null)\n        {\n            \n            if (line.StartsWith(\";\"))\n                continue;\n\n            if (line.StartsWith(\">\"))\n            {\n                if (f != null)\n                    yield return f;\n                f = new FastaEntry { Name = line.Substring(1), Sequence = new StringBuilder() };\n            }\n            else if (f != null)\n                f.Sequence.Append(line);\n        }\n        yield return f;\n    }\n\n    static void Main(string[] args)\n    {\n        try\n        {\n            using (var fastaFile = new StreamReader(\"fasta.txt\"))\n            {\n                foreach (FastaEntry f in ParseFasta(fastaFile))\n                    Console.WriteLine(\"{0}: {1}\", f.Name, f.Sequence);\n            }\n        }\n        catch (FileNotFoundException e)\n        {\n            Console.WriteLine(e);\n        }\n        Console.ReadLine();\n    }\n}\n"}
{"id": 335319, "name": "MAC vendor lookup", "source": "Translate Ruby to C#: require 'net/http'\n\narr = ['88:53:2E:67:07:BE', 'FC:FB:FB:01:FA:21', 'D4:F4:6F:C9:EF:8D', '23:45:67']\n\narr.each do |addr|\n  vendor = Net::HTTP.get('api.macvendors.com', \"/\n  puts \"\nend\n", "target": "using System;\nusing System.Net;\nusing System.Net.Http;\nusing System.Threading.Tasks;\n\nclass Program\n{\n    static async Task<string> LookupMac(string MacAddress)\n    {\n        var uri = new Uri(\"http:\n        using (var wc = new HttpClient())\n            return await wc.GetStringAsync(uri);\n    }\n    static void Main(string[] args)\n    {\n        foreach (var mac in new string[] { \"88:53:2E:67:07:BE\", \"FC:FB:FB:01:FA:21\", \"D4:F4:6F:C9:EF:8D\" })\n            Console.WriteLine(mac + \"\\t\" + LookupMac(mac).Result);\n        Console.ReadLine();\n    }\n}\n"}
{"id": 335320, "name": "Magic 8-ball", "source": "Translate Ruby to C#: \n\nclass EightBall\n  def initialize\n    print \"Welcome to 8 ball! Ask your question below. \"\n    puts \"Type 'quit' to exit the program.\\n\\n\"\n    @responses = [\"It is certain\", \"It is decidedly so\",\n                          \"Without a doubt\", \"Yes, definitely\",\n                          \"You may rely on it\", \"As I see it, yes\",\n                          \"Most likely\", \"Outlook good\",\n                          \"Signs point to yes\", \"Yes\",\n                          \"Reply hazy, try again\", \"Ask again later\",\n                          \"Better not tell you now\",\n                          \"Cannot predict now\",\n                          \"Concentrate and ask again\", \"Don't bet on it\",\n                          \"My reply is no\", \"My sources say no\",\n                          \"Outlook not so good\", \"Very doubtful\"]\n  end\n\n  def ask_question\n    print \"Question: \"\n    question = gets\n\n    if question.chomp.eql? \"quit\"\n      exit(0)\n    end\n\n    puts \"Response: \n  end\n\n  def run\n    loop do\n      ask_question\n    end\n  end\nend\n\neight_ball = EightBall.new\neight_ball.run\n", "target": "using System;\n\nnamespace newProg\n{\n\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            string[] answers =\n            {\n                \"It is certain.\",\n                \"It is decidedly so.\",\n                \"Without a doubt.\",\n                \"Yes \u2013 definitely.\",\n                \"You may rely on it.\",\n                \"As I see it, yes.\",\n                \"Most likely.\",\n                \"Outlook good.\",\n                \"Yes.\",\n                \"Signs point to yes.\",\n                \"Reply hazy, try again.\",\n                \"Ask again later\",\n                \"Better not tell you now.\",\n                \"Cannot predict now.\",\n                \"Concentrate and ask again.\",\n                \"Don't count on it.\",\n                \"My reply is no.\",\n                \"My sources say no.\",\n                \"Outlook not so good.\",\n                \"Very doubtful.\"\n            };\n\n            while (true)\n            {\n                Random rnd = new Random();\n                int result = rnd.Next(0, 19);\n\n                Console.WriteLine(\"Magic 8 Ball! Ask question and hit a key for the answer!\");\n\n                string inp = Console.ReadLine();\n                \n                Console.WriteLine(answers[result]);\n\n            }\n        }\n    }\n}\n"}
{"id": 335321, "name": "Validate International Securities Identification Number", "source": "Translate Ruby to C#: RE = /\\A[A-Z]{2}[A-Z0-9]{9}[0-9]{1}\\z/\n\ndef valid_isin?(str)\n  return false unless str =~ RE\n  luhn(str.chars.map{|c| c.to_i(36)}.join)\nend\n\np %w(US0378331005\nUS0373831005\nU50378331005\nUS03378331005\nAU0000XVGZA3\nAU0000VXGZA3\nFR0000988040).map{|tc| valid_isin?(tc) }\t \n \n\n", "target": "using System;\nusing System.Linq;\nusing System.Text.RegularExpressions;\n\nnamespace ValidateIsin\n{\n    public static class IsinValidator\n    {\n        public static bool IsValidIsin(string isin) => \n            IsinRegex.IsMatch(isin) && LuhnTest(Digitize(isin));\n\n        private static readonly Regex IsinRegex = \n            new Regex(\"^[A-Z]{2}[A-Z0-9]{9}\\\\d$\", RegexOptions.Compiled);\n\n        private static string Digitize(string isin) =>\n            string.Join(\"\", isin.Select(c => $\"{DigitValue(c)}\"));\n\n        private static bool LuhnTest(string number) => \n            number.Reverse().Select(DigitValue).Select(Summand).Sum() % 10 == 0;\n\n        private static int Summand(int digit, int i) =>\n            digit + (i % 2) * (digit - digit / 5 * 9);\n\n        private static int DigitValue(char c) =>\n            c >= '0' && c <= '9' \n                ? c - '0' \n                : c - 'A' + 10;\n   }\n\t\n   public class Program\n   {\n        public static void Main() \n        {\n            string[] isins = \n            {\n                \"US0378331005\",\n                \"US0373831005\",\n                \"U50378331005\",\n                \"US03378331005\",\n                \"AU0000XVGZA3\",\n                \"AU0000VXGZA3\",\n                \"FR0000988040\"\n            };\n\n            foreach (string isin in isins) {\n                string validOrNot = IsinValidator.IsValidIsin(isin) ? \"valid\" : \"not valid\";\n                Console.WriteLine($\"{isin} is {validOrNot}\");\n            }\n        }\n    }\n}\n"}
{"id": 335322, "name": "Orbital elements", "source": "Translate Ruby to C#: func orbital_state_vectors(\n    semimajor_axis,\n    eccentricity,\n    inclination,\n    longitude_of_ascending_node,\n    argument_of_periapsis,\n    true_anomaly\n) {\n\n    var (i, j, k) = (\n        Vector(1, 0, 0),\n        Vector(0, 1, 0),\n        Vector(0, 0, 1),\n    )\n\n    func muladd(v1, x1, v2, x2) {\n        (v1 * x1) + (v2 * x2)\n    }\n\n    func rotate(Ref i, Ref j, \u03b1) {\n        (*i, *j) = (\n            muladd(*i, +cos(\u03b1), *j, sin(\u03b1)),\n            muladd(*i, -sin(\u03b1), *j, cos(\u03b1)),\n        )\n    }\n\n    rotate(\\i, \\j, longitude_of_ascending_node)\n    rotate(\\j, \\k, inclination)\n    rotate(\\i, \\j, argument_of_periapsis)\n\n    var l = (eccentricity == 1 ? 2*semimajor_axis\n                               : semimajor_axis*(1 - eccentricity**2))\n\n    var (c, s) = with(true_anomaly) { (.cos, .sin) }\n\n    var r = l/(1 + eccentricity*c)\n    var rprime = (s * r**2 / l)\n    var position = muladd(i, c, j, s)*r\n\n    var speed = muladd(i, rprime*c - r*s, j, rprime*s + r*c)\n    speed /= speed.abs\n    speed *= sqrt(2/r - 1/semimajor_axis)\n\n    struct Result { position, speed }\n    Result(position, speed)\n}\n\nfor args in ([\n    [1, 0.1, 0, 355/(113*6), 0, 0],\n    [1, 0.1, Num.pi/18, Num.pi/6, Num.pi/4, 0]\n]) {\n    var r = orbital_state_vectors(args...)\n\n    say \"Arguments: \n    say \"Position\u00a0: \n    say \"Speed   \u00a0: \n}\n", "target": "using System;\n\nnamespace OrbitalElements {\n    class Vector {\n        public Vector(double x, double y, double z) {\n            X = x;\n            Y = y;\n            Z = z;\n        }\n\n        public double X { get; set; }\n        public double Y { get; set; }\n        public double Z { get; set; }\n\n        public double Abs() {\n            return Math.Sqrt(X * X + Y * Y + Z * Z);\n        }\n\n        public static Vector operator +(Vector lhs, Vector rhs) {\n            return new Vector(lhs.X + rhs.X, lhs.Y + rhs.Y, lhs.Z + rhs.Z);\n        }\n\n        public static Vector operator *(Vector self, double m) {\n            return new Vector(self.X * m, self.Y * m, self.Z * m);\n        }\n\n        public static Vector operator /(Vector self, double m) {\n            return new Vector(self.X / m, self.Y / m, self.Z / m);\n        }\n\n        public override string ToString() {\n            return string.Format(\"({0}, {1}, {2})\", X, Y, Z);\n        }\n    }\n\n    class Program {\n        static Tuple<Vector, Vector> OrbitalStateVectors(\n            double semiMajorAxis,\n            double eccentricity,\n            double inclination,\n            double longitudeOfAscendingNode,\n            double argumentOfPeriapsis,\n            double trueAnomaly\n        ) {\n            Vector mulAdd(Vector v1, double x1, Vector v2, double x2) {\n                return v1 * x1 + v2 * x2;\n            }\n\n            Tuple<Vector, Vector> rotate(Vector iv, Vector jv, double alpha) {\n                return new Tuple<Vector, Vector>(\n                    mulAdd(iv, +Math.Cos(alpha), jv, Math.Sin(alpha)),\n                    mulAdd(iv, -Math.Sin(alpha), jv, Math.Cos(alpha))\n                );\n            }\n\n            var i = new Vector(1, 0, 0);\n            var j = new Vector(0, 1, 0);\n            var k = new Vector(0, 0, 1);\n\n            var p = rotate(i, j, longitudeOfAscendingNode);\n            i = p.Item1; j = p.Item2;\n            p = rotate(j, k, inclination);\n            j = p.Item1;\n            p = rotate(i, j, argumentOfPeriapsis);\n            i = p.Item1; j = p.Item2;\n\n            var l = semiMajorAxis * ((eccentricity == 1.0) ? 2.0 : (1.0 - eccentricity * eccentricity));\n            var c = Math.Cos(trueAnomaly);\n            var s = Math.Sin(trueAnomaly);\n            var r = l / (1.0 + eccentricity * c);\n            var rprime = s * r * r / l;\n            var position = mulAdd(i, c, j, s) * r;\n            var speed = mulAdd(i, rprime * c - r * s, j, rprime * s + r * c);\n            speed /= speed.Abs();\n            speed *= Math.Sqrt(2.0 / r - 1.0 / semiMajorAxis);\n\n            return new Tuple<Vector, Vector>(position, speed);\n        }\n\n        static void Main(string[] args) {\n            var res = OrbitalStateVectors(1.0, 0.1, 0.0, 355.0 / (113.0 * 6.0), 0.0, 0.0);\n            Console.WriteLine(\"Position\u00a0: {0}\", res.Item1);\n            Console.WriteLine(\"Speed   \u00a0: {0}\", res.Item2);\n        }\n    }\n}\n"}
{"id": 335323, "name": "Cycle detection", "source": "Translate Ruby to C#: \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ndef findCycle(x0)\n  power = lambda = 1\n  tortoise = x0\n  hare = yield(x0)\n  \n  \n  while tortoise != hare\n    if power == lambda\n      tortoise = hare\n      power *= 2\n      lambda = 0\n    end\n    hare = yield(hare)\n    lambda += 1\n  end\n  \n  \n  hare = x0\n  lambda.times { hare = yield(hare) }\n  \n  tortoise, mu = x0, 0\n  while tortoise != hare\n    tortoise = yield(tortoise)\n    hare = yield(hare)\n    mu += 1\n  end\n  \n  return lambda, mu\nend\n\n\ndef f(x) (x * x + 1) % 255 end\n\n\nputs (1..40).reduce([3]){|acc,_| acc << f(acc.last)}.join(\",\")\n\n\nclength, cstart = findCycle(3) { |x| f(x) }\nputs \"Cycle length = \n", "target": "\n\n\nusing System;\n\nnamespace DetectCycles\n{\n  \n  \n  \n  public class Cycles<T> where T : IEquatable<T>\n  {\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    public static Tuple<int,int> FindCycle(T x0, Func<T,T> yielder)\n    {\n      int power, lambda;\n      T tortoise, hare;\n      power = lambda = 1;\n      tortoise = x0;\n      hare = yielder(x0);\n\n      \n      while (!tortoise.Equals (hare)) {\n        if (power == lambda) {\n          tortoise = hare;\n          power *= 2;\n          lambda = 0;  \n        }\n        hare = yielder (hare);\n        lambda += 1;\n      }\n\n      \n      var mu = 0;\n      tortoise = hare = x0;\n      for (var times = 0; times < lambda; times++) \n        hare = yielder (hare);\n      \n      while (!tortoise.Equals (hare)) \n      {\n        tortoise = yielder (tortoise);\n        hare = yielder (hare);\n        mu += 1;\n      }\n\n      return new Tuple<int,int> (lambda, mu);\n    }\n  }\n}\n\n\n\nusing System;\n\nnamespace DetectCycles\n{\n\tclass MainClass\n\t{\n\t\tpublic static void Main (string[] args)\n\t\t{\n\t\t\t\n\t\t\tFunc<int,int> sequence = (int _x) => (_x * _x + 1) % 255;\n\n\t\t\t\n\t\t\tvar x = 3;\n\t\t\tConsole.Write(x);\n\t\t\tfor (var times = 0; times < 40; times++) \n\t\t\t{\n\t\t\t\tx = sequence(x);\n\t\t\t\tConsole.Write(String.Format(\",{0}\", x));\n\t\t\t}\n\t\t\tConsole.WriteLine();\n\n\t\t\t\n\t\t\tvar cycle = Cycles<int>.FindCycle(3, sequence);\n\t\t\tvar clength = cycle.Item1;\n\t\t\tvar cstart = cycle.Item2;\n\t\t\tConsole.Write(String.Format(\"Cycle length = {0}\\nStart index = {1}\\n\", clength, cstart));\n\t\t}\n\t}\n}\n"}
{"id": 335324, "name": "Input_Output for pairs of numbers", "source": "Translate Ruby to C#: n = gets.to_i\nn.times do\n  a, b = gets.split.map(&:to_i)\n  puts a + b\nend\n", "target": "using System;\nusing static System.Linq.Enumerable;\n\npublic class Program\n{\n    static void Main(string[] args)\n    {\n\tint count = Convert.ToInt32(Console.ReadLine());\n\tfor (int line = 0; line < count; line++) {\n            Console.WriteLine(Console.ReadLine().Split(' ').Sum(i => Convert.ToInt32(i)));\n\t}\n    }\n}\n"}
{"id": 335325, "name": "Kahan summation", "source": "Translate Ruby to C#: epsilon = 1.0\nepsilon /= 2 until 1.0 + epsilon == 1.0\n\na = 1.0\nb = epsilon\nc = -b\n\nputs \"epsilon   \u00a0: \nputs \"(a+b)+c   \u00a0: \nputs \"[a,b,c].sum: \n", "target": "using System;\n\nnamespace KahanSummation {\n    class Program {\n        static float KahanSum(params float[] fa) {\n            float sum = 0.0f;\n            float c = 0.0f;\n            foreach (float f in fa) {\n                float y = f - c;\n                float t = sum + y;\n                c = (t - sum) - y;\n                sum = t;\n            }\n\n            return sum;\n        }\n\n        static float Epsilon() {\n            float eps = 1.0f;\n            while (1.0f + eps != 1.0f) eps /= 2.0f;\n            return eps;\n        }\n\n        static void Main(string[] args) {\n            float a = 1.0f;\n            float b = Epsilon();\n            float c = -b;\n            Console.WriteLine(\"Epsilon      = {0}\", b);\n            Console.WriteLine(\"(a + b) + c  = {0}\", (a + b) + c);\n            Console.WriteLine(\"Kahan sum    = {0}\", KahanSum(a, b, c));\n        }\n    }\n}\n"}
{"id": 335326, "name": "ABC words", "source": "Translate Ruby to C#: puts File.open(\"unixdict.txt\").grep(/^[^bc]*a[^c]*b.*c/)\n", "target": "class Program {\n    static void Main(string[] args) { int bi, i = 0; string chars = args.Length < 1 ? \"abc\" : args[0];\n        foreach (var item in System.IO.File.ReadAllLines(\"unixdict.txt\")) {\n            int ai = -1; foreach (var ch in chars)\n                if ((bi = item.IndexOf(ch)) > ai) ai = bi; else goto skip;\n            System.Console.Write(\"{0,3} {1,-18} {2}\", ++i, item, i % 5 == 0 ? \"\\n\" : \"\");\n        skip: ; } }\n}\n"}
{"id": 335327, "name": "Text between", "source": "Translate Ruby to C#: class String\n  def textBetween startDelimiter, endDelimiter\n  \n  \tif (startDelimiter == \"start\") then\n  \t\tstartIndex = 0\n  \telse\n  \t\tstartIndex = self.index(startDelimiter) + startDelimiter.length\n  \tend\n  \t\n  \tif (startIndex == nil) then\n  \t\treturn \"Start delimiter not found\"\n  \tend\n  \t\n  \tthisLength = self.length\n  \t\n  \treturnText = self[startIndex, thisLength]\n  \t  \t\n \tif (endDelimiter == \"end\") then\n  \t\tendIndex = thisLength\n  \telse\n  \t\tendIndex = returnText.index(endDelimiter)\n  \tend\n  \t\n  \tif (endIndex == nil) then\n  \t\treturn \"End delimiter not found\"\n  \tend\n  \t  \t\n  \treturnText = returnText[0, endIndex]\n  \t\n  \treturn returnText\n  \n  end\nend\n\nthisText = ARGV[0]\nstartDelimiter = ARGV[1]\nendDelimiter = ARGV[2]\n\n\n\n\n\nreturnText = thisText.textBetween(startDelimiter, endDelimiter)\n\nputs returnText\n", "target": "using System;\n\nnamespace TextBetween {\n    class Program {\n        static string TextBetween(string source, string beg, string end) {\n            int startIndex;\n\n            if (beg == \"start\") {\n                startIndex = 0;\n            }\n            else {\n                startIndex = source.IndexOf(beg);\n                if (startIndex < 0) {\n                    return \"\";\n                }\n                startIndex += beg.Length;\n            }\n\n            int endIndex = source.IndexOf(end, startIndex);\n            if (endIndex < 0 || end == \"end\") {\n                return source.Substring(startIndex);\n            }\n            return source.Substring(startIndex, endIndex - startIndex);\n        }\n\n        static void Print(string s, string b, string e) {\n            Console.WriteLine(\"text: '{0}'\", s);\n            Console.WriteLine(\"start: '{0}'\", b);\n            Console.WriteLine(\"end: '{0}'\", e);\n            Console.WriteLine(\"result: '{0}'\", TextBetween(s, b, e));\n            Console.WriteLine();\n        }\n\n        static void Main(string[] args) {\n            Print(\"Hello Rosetta Code world\", \"Hello \", \" world\");\n            Print(\"Hello Rosetta Code world\", \"start\", \" world\");\n            Print(\"Hello Rosetta Code world\", \"Hello \", \"end\");\n            Print(\"</div><div style=\\\"chinese\\\">\u4f60\u597d\u55ce</div>\", \"<div style=\\\"chinese\\\">\", \"</div>\");\n            Print(\"<text>Hello <span>Rosetta Code</span> world</text><table style=\\\"myTable\\\">\", \"<text>\", \"<table>\");\n            Print(\"<table style=\\\"myTable\\\"><tr><td>hello world</td></tr></table>\", \"<table>\", \"</table>\");\n            Print(\"The quick brown fox jumps over the lazy other fox\", \"quick \", \" fox\");\n            Print(\"One fish two fish red fish blue fish\", \"fish \", \" red\");\n            Print(\"FooBarBazFooBuxQuux\", \"Foo\", \"Foo\");\n        }\n    }\n}\n"}
{"id": 335328, "name": "Two identical strings", "source": "Translate Ruby to C#: (0..1000).each do |i|\n  bin = i.to_s(2)\n  if bin.size.even?\n    half = bin.size // 2\n    if bin[0..half-1] == bin[half..]\n      print \"%3d: %10s\\n\" % [i, bin]\n    end\n  end\nend\n", "target": "using System; using static System.Console;\nclass Program { static void Main() { int c = 0, lmt = 1000;\n    for (int n = 1, p = 2, k; n <= lmt; n++)\n      if ((k = n + n * (p += n >= p ? p : 0)) > lmt) break;\n      else Console.Write(\"{0,3} ({1,-10})  {2}\", k,\n          Convert.ToString(k, 2), ++c % 5 == 0 ? \"\\n\" : \"\");\n    Write(\"\\nFound {0} numbers whose base 2 representation is the \" +\n      \"concatenation of two identical binary strings.\", c); } }\n"}
{"id": 335329, "name": "Sum of first n cubes", "source": "Translate Ruby to C#: sum = 0\n(0...50).each do |n|\n  print (sum += n**3).to_s.ljust(10)\n  puts \"\" if (n+1) % 10 == 0\nend\n", "target": "using System; using static System.Console;\nclass Program { static void Main(string[] args) {\n    for (int i=0,j=-6,k=1,c=0,s=0;s<1600000;s+=c+=k+=j+=6)\n      Write(\"{0,-7}{1}\",s, (i+=i==3?-4:1)==0?\"\\n\":\" \"); } }\n"}
{"id": 335330, "name": "Flow-control structures", "source": "Translate Ruby to C#: begin\n  \nrescue ExceptionClassA => a\n  \nrescue ExceptionClassB, ExceptionClassC => b_or_c\n  \nrescue\n  \nelse\n  \nensure\n  \nend\n", "target": "int GetNumber() {\n    return 5;\n}\n"}
{"id": 335331, "name": "Boolean values", "source": "Translate Ruby to C#: if false\n  puts \"false\"\nelsif nil\n  puts \"nil\"\nelsif Pointer(Nil).new 0\n  puts \"null pointer\"\nelsif true && \"any other value\"\n  puts \"finally true!\"\nend\n", "target": "bool? value = null\n"}
{"id": 335332, "name": "Copy a string", "source": "Translate Ruby to C#: original = \"hello\"\nreference = original          \ncopy1 = original.dup          \ncopy2 = String.new(original)  \n\noriginal << \" world!\"         \np reference                   \np copy1                       \np copy2                       \n", "target": "string src = \"Hello\";\nstring dst = src;\n"}
{"id": 335333, "name": "Enforced immutability", "source": "Translate Ruby to C#: msg = \"Hello World\"\nmsg << \"!\"\nputs msg                \n\nputs msg.frozen?        \nmsg.freeze\nputs msg.frozen?        \nbegin\n  msg << \"!\"\nrescue => e\n  p e                   \nend\n\nputs msg                \nmsg2 = msg\n\n\nmsg = \"hello world\"     \n\nputs msg.frozen?        \nputs msg2.frozen?       \n", "target": "readonly DateTime now = DateTime.Now;\n"}
{"id": 335334, "name": "Address of a variable", "source": "Translate Ruby to C#: >foo = Object.new  \n>id = foo.object_id  \n>\"%x\" % (id << 1)  \n", "target": "int i = 5;\nint* p = &i;\n"}
{"id": 335335, "name": "Successive prime differences", "source": "Translate Ruby to C#: require 'prime'\nPRIMES = Prime.each(1_000_000).to_a\ndifs = [[2], [1], [2,2], [2,4], [4,2], [6,4,2]]\n\ndifs.each do |ar|\n  res = PRIMES.each_cons(ar.size+1).select do |slice|\n    slice.each_cons(2).zip(ar).all? {|(a,b), c| a+c == b}\n  end\n  puts \"\nend\n", "target": "using System;\nusing System.Collections.Generic;\nusing static System.Linq.Enumerable;\n\npublic static class SuccessivePrimeDifferences {\n\n    public static void Main() {\n        var primes = GeneratePrimes(1_000_000).ToList();\n        foreach (var d in new[] {\n            new [] { 2 },\n            new [] { 1 },\n            new [] { 2, 2 },\n            new [] { 2, 4 },\n            new [] { 4, 2 },\n            new [] { 6, 4, 2 },\n        }) {\n            IEnumerable<int> first = null, last = null;\n            int count = 0;\n            foreach (var grp in FindDifferenceGroups(d)) {\n                if (first == null) first = grp;\n                last = grp;\n                count++;\n            }\n            Console.WriteLine($\"{$\"({string.Join(\", \", first)})\"}, {$\"({string.Join(\", \", last)})\"}, {count}\");\n        }\n\n        IEnumerable<IEnumerable<int>> FindDifferenceGroups(int[] diffs) {\n            for (int pi = diffs.Length; pi < primes.Count; pi++)\n                if (Range(0, diffs.Length).All(di => primes[pi-diffs.Length+di+1] - primes[pi-diffs.Length+di] == diffs[di]))\n                    yield return Range(pi - diffs.Length, diffs.Length + 1).Select(i => primes[i]);\n        }\n\n        IEnumerable<int> GeneratePrimes(int lmt) {\n            bool[] comps = new bool[lmt + 1];\n            comps[0] = comps[1] = true;\n            yield return 2; yield return 3;\n            for (int j = 4; j <= lmt; j += 2) comps[j] = true;\n            for (int j = 9; j <= lmt; j += 6) comps[j] = true;\n            int i = 5, d = 4, rt = (int)Math.Sqrt(lmt);\n            for ( ; i <= rt; i += (d = 6 - d))\n                if (!comps[i]) {\n                    yield return i;\n                    for (int j = i * i, k = i << 1; j <= lmt; j += k)\n                        comps[j] = true;\n                }\n            for ( ; i <= lmt; i += (d = 6 - d)) if (!comps[i]) yield return i;\n        }\n    }\n}\n"}
{"id": 335336, "name": "10001th prime", "source": "Translate Ruby to C#: require \"prime\"\nputs  Prime.lazy.drop(10_000).next\n", "target": "using System; class Program {\n\n  static bool isprime(uint p ) { if ((p & 1) == 0) return p == 2;\n    if ((p % 3) == 0) return p == 3;\n    for (uint i = 5, d = 4; i * i <= p; i += (d = 6 - d))\n      if (p % i == 0) return false; return true; }\n \n  static uint prime(uint n) { uint p, d, pn;\n    for (p = 5, d = 4, pn = 2; pn < n; p += (d = 6 - d))\n      if (isprime(p)) pn++; return p - d; }\n\n  static void Main(string[] args) {\n    Console.WriteLine(\"One-at-a-time trial division vs sieve of Eratosthenes\");\n    var sw = System.Diagnostics.Stopwatch.StartNew();\n    var t = prime(10001); sw.Stop(); double e1, e2;\n    Console.Write(\"{0:n0} {1} ms\", prime(10001),\n      e1 = sw.Elapsed.TotalMilliseconds);\n    sw.Restart(); uint n = 105000, i, j; var pr = new uint[10100];\n    pr[0] = 2; pr[1] = 3; uint pc = 2, r, d, ii;\n    var pl = new bool[n + 1]; r = (uint)Math.Sqrt(n);\n    for (i = 9; i < n; i += 6) pl[i] = true;\n    for (i = 5, d = 4; i <= r; i += (d = 6 - d)) if (!pl[i]) {\n      pr[pc++] = i; for (j = i * i, ii = i << 1; j <= n; j += ii)\n        pl[j] = true; }\n    for ( ;i <= n; i += (d = 6 - d)) if (!pl[i]) pr[pc++] = i;\n    t = pr[10000]; sw.Stop();\n    Console.Write(\"  {0:n0} {1} \u03bcs  {2:0.000} times faster\", t,\n      (e2 = sw.Elapsed.TotalMilliseconds) * 1000.0, e1 / e2); } }\n"}
{"id": 335337, "name": "10001th prime", "source": "Translate Ruby to C#: require \"prime\"\nputs  Prime.lazy.drop(10_000).next\n", "target": "using System; class Program {\n\n  static bool isprime(uint p ) { if ((p & 1) == 0) return p == 2;\n    if ((p % 3) == 0) return p == 3;\n    for (uint i = 5, d = 4; i * i <= p; i += (d = 6 - d))\n      if (p % i == 0) return false; return true; }\n \n  static uint prime(uint n) { uint p, d, pn;\n    for (p = 5, d = 4, pn = 2; pn < n; p += (d = 6 - d))\n      if (isprime(p)) pn++; return p - d; }\n\n  static void Main(string[] args) {\n    Console.WriteLine(\"One-at-a-time trial division vs sieve of Eratosthenes\");\n    var sw = System.Diagnostics.Stopwatch.StartNew();\n    var t = prime(10001); sw.Stop(); double e1, e2;\n    Console.Write(\"{0:n0} {1} ms\", prime(10001),\n      e1 = sw.Elapsed.TotalMilliseconds);\n    sw.Restart(); uint n = 105000, i, j; var pr = new uint[10100];\n    pr[0] = 2; pr[1] = 3; uint pc = 2, r, d, ii;\n    var pl = new bool[n + 1]; r = (uint)Math.Sqrt(n);\n    for (i = 9; i < n; i += 6) pl[i] = true;\n    for (i = 5, d = 4; i <= r; i += (d = 6 - d)) if (!pl[i]) {\n      pr[pc++] = i; for (j = i * i, ii = i << 1; j <= n; j += ii)\n        pl[j] = true; }\n    for ( ;i <= n; i += (d = 6 - d)) if (!pl[i]) pr[pc++] = i;\n    t = pr[10000]; sw.Stop();\n    Console.Write(\"  {0:n0} {1} \u03bcs  {2:0.000} times faster\", t,\n      (e2 = sw.Elapsed.TotalMilliseconds) * 1000.0, e1 / e2); } }\n"}
{"id": 335338, "name": "Terminal control_Dimensions", "source": "Translate Ruby to C#: def winsize\n  \n  require 'io/console'\n  IO.console.winsize\nrescue LoadError\n  \n  \n  [Integer(`tput li`), Integer(`tput co`)]\nend\n\nrows, cols = winsize\nprintf \"%d rows by %d columns\\n\", rows, cols\n", "target": "static void Main(string[] args)\n{\n    int bufferHeight = Console.BufferHeight;\n    int bufferWidth = Console.BufferWidth;\n    int windowHeight = Console.WindowHeight;\n    int windowWidth = Console.WindowWidth;\n\n    Console.Write(\"Buffer Height: \");\n    Console.WriteLine(bufferHeight);\n    Console.Write(\"Buffer Width: \");\n    Console.WriteLine(bufferWidth);\n    Console.Write(\"Window Height: \");\n    Console.WriteLine(windowHeight);\n    Console.Write(\"Window Width: \");\n    Console.WriteLine(windowWidth);\n    Console.ReadLine();\n}\n"}
{"id": 335339, "name": "Largest number divisible by its digits", "source": "Translate Ruby to C#: magic_number = 9*8*7\ndiv          = (9876432 // magic_number) * magic_number\ncandidates   = div.step(to: 0, by: -magic_number)\n\nres = candidates.find do |c|\n  digits = c.to_s.chars.map(&.to_i)\n  (digits & [0,5]).empty? && digits == digits.uniq\nend\n\nputs \"Largest decimal number is \n", "target": "using System;\n\nclass Program {\n    static int gcd(int a, int b) { return b > 0 ? gcd(b, a % b) : a; }\n\n    \n    static int lcmd(long x, int b) {\n      int r = (int)(x % b), a; x /= b; while (x > 0) {\n        r = (r * (a = (int)(x % b))) / gcd(r, a); x /= b; } return r; }\n\n    static void Main(string[] args) {\n        var sw = System.Diagnostics.Stopwatch.StartNew();\n        long mx = 987654321; \n             mx = 98764321; \n             mx /= 10;     \n        long skip = lcmd(mx, 10), i; bool nDup;\n        for (i = mx - mx % skip; ; i -= skip) {\n            var s = i.ToString().ToCharArray(); Array.Sort(s);\n            if (s[0] == '0') continue; \n            nDup = true; \n            for (int j = 0, k = 1; k < s.Length; j = k++)\n                if (s[j] == s[k] || s[k] == '5') { nDup = false; break; }\n            if (nDup) break; } sw.Stop(); \n        Console.Write(\"base 10 = {0} in {1} \u03bcs\\n\", i,\n          1000 * sw.Elapsed.TotalMilliseconds);\n        sw.Restart();\n        mx = 0xfedcba987654321;    \n        skip = lcmd(mx >> 4, 16); \n        for (i = mx - mx % skip; ; i -= skip) {\n            var s = i.ToString(\"x\").ToCharArray(); Array.Sort(s);\n            if (s[0] == '0') continue; \n            nDup = true; \n            for (int j = 0, k = 1; k < s.Length; j = k++)\n                if (s[j] == s[k]) { nDup = false; break; }\n            if (nDup) break; } sw.Stop(); \n        Console.Write(\"base 16 = {0} in {1} ms\", i.ToString(\"x\"),\n          sw.Elapsed.TotalMilliseconds); } }\n"}
{"id": 335340, "name": "Largest number divisible by its digits", "source": "Translate Ruby to C#: magic_number = 9*8*7\ndiv          = (9876432 // magic_number) * magic_number\ncandidates   = div.step(to: 0, by: -magic_number)\n\nres = candidates.find do |c|\n  digits = c.to_s.chars.map(&.to_i)\n  (digits & [0,5]).empty? && digits == digits.uniq\nend\n\nputs \"Largest decimal number is \n", "target": "using System;\n\nclass Program {\n    static int gcd(int a, int b) { return b > 0 ? gcd(b, a % b) : a; }\n\n    \n    static int lcmd(long x, int b) {\n      int r = (int)(x % b), a; x /= b; while (x > 0) {\n        r = (r * (a = (int)(x % b))) / gcd(r, a); x /= b; } return r; }\n\n    static void Main(string[] args) {\n        var sw = System.Diagnostics.Stopwatch.StartNew();\n        long mx = 987654321; \n             mx = 98764321; \n             mx /= 10;     \n        long skip = lcmd(mx, 10), i; bool nDup;\n        for (i = mx - mx % skip; ; i -= skip) {\n            var s = i.ToString().ToCharArray(); Array.Sort(s);\n            if (s[0] == '0') continue; \n            nDup = true; \n            for (int j = 0, k = 1; k < s.Length; j = k++)\n                if (s[j] == s[k] || s[k] == '5') { nDup = false; break; }\n            if (nDup) break; } sw.Stop(); \n        Console.Write(\"base 10 = {0} in {1} \u03bcs\\n\", i,\n          1000 * sw.Elapsed.TotalMilliseconds);\n        sw.Restart();\n        mx = 0xfedcba987654321;    \n        skip = lcmd(mx >> 4, 16); \n        for (i = mx - mx % skip; ; i -= skip) {\n            var s = i.ToString(\"x\").ToCharArray(); Array.Sort(s);\n            if (s[0] == '0') continue; \n            nDup = true; \n            for (int j = 0, k = 1; k < s.Length; j = k++)\n                if (s[j] == s[k]) { nDup = false; break; }\n            if (nDup) break; } sw.Stop(); \n        Console.Write(\"base 16 = {0} in {1} ms\", i.ToString(\"x\"),\n          sw.Elapsed.TotalMilliseconds); } }\n"}
{"id": 335341, "name": "Sattolo cycle", "source": "Translate Ruby to C#: > class Array\n>   def sattolo_cycle!\n>     (length - 1).downto(1) do |i|\n*       j = rand(i)\n>       self[i], self[j] = self[j], self[i]\n>     end\n>     self\n>   end\n> end\n=> :sattolo_cycle!\n\n> \n> 10.times do\n*   p [1, 2, 3, 4, 5, 6, 7, 8, 9, 10].sattolo_cycle!\n> end\n[10, 6, 9, 7, 8, 1, 3, 2, 5, 4]\n[3, 7, 5, 10, 4, 8, 1, 2, 6, 9]\n[10, 3, 4, 8, 9, 7, 1, 5, 6, 2]\n[8, 7, 4, 2, 6, 9, 1, 5, 10, 3]\n[2, 7, 5, 10, 8, 3, 6, 9, 4, 1]\n[2, 10, 8, 6, 1, 3, 5, 9, 7, 4]\n[8, 5, 6, 1, 4, 9, 2, 10, 7, 3]\n[5, 4, 10, 7, 2, 1, 8, 9, 3, 6]\n[9, 8, 4, 2, 6, 1, 5, 10, 3, 7]\n[9, 4, 2, 7, 6, 1, 10, 3, 8, 5]\n=> 10\n", "target": "private static readonly Random Rand = new Random();\n\nvoid sattoloCycle<T>(IList<T> items) {\n    for (var i = items.Count; i-- > 1;) {\n        int j = Rand.Next(i);\n        var tmp = items[i];\n        items[i] = items[j];\n        items[j] = tmp;\n    }\n}\n"}
{"id": 335342, "name": "Sattolo cycle", "source": "Translate Ruby to C#: > class Array\n>   def sattolo_cycle!\n>     (length - 1).downto(1) do |i|\n*       j = rand(i)\n>       self[i], self[j] = self[j], self[i]\n>     end\n>     self\n>   end\n> end\n=> :sattolo_cycle!\n\n> \n> 10.times do\n*   p [1, 2, 3, 4, 5, 6, 7, 8, 9, 10].sattolo_cycle!\n> end\n[10, 6, 9, 7, 8, 1, 3, 2, 5, 4]\n[3, 7, 5, 10, 4, 8, 1, 2, 6, 9]\n[10, 3, 4, 8, 9, 7, 1, 5, 6, 2]\n[8, 7, 4, 2, 6, 9, 1, 5, 10, 3]\n[2, 7, 5, 10, 8, 3, 6, 9, 4, 1]\n[2, 10, 8, 6, 1, 3, 5, 9, 7, 4]\n[8, 5, 6, 1, 4, 9, 2, 10, 7, 3]\n[5, 4, 10, 7, 2, 1, 8, 9, 3, 6]\n[9, 8, 4, 2, 6, 1, 5, 10, 3, 7]\n[9, 4, 2, 7, 6, 1, 10, 3, 8, 5]\n=> 10\n", "target": "private static readonly Random Rand = new Random();\n\nvoid sattoloCycle<T>(IList<T> items) {\n    for (var i = items.Count; i-- > 1;) {\n        int j = Rand.Next(i);\n        var tmp = items[i];\n        items[i] = items[j];\n        items[j] = tmp;\n    }\n}\n"}
{"id": 335343, "name": "Twin primes", "source": "Translate Ruby to C#: require 'prime'\n\n(1..8).each do |n|\n  count = Prime.each(10**n).each_cons(2).count{|p1, p2| p2-p1 == 2}\n  puts \"Twin primes below 10**\nend\n", "target": "using System;\n\nclass Program {\n\n    static uint[] res = new uint[10];\n    static uint ri = 1, p = 10, count = 0;\n\n    static void TabulateTwinPrimes(uint bound) {\n        if (bound < 5) return; count++;\n        uint cl = (bound - 1) >> 1, i = 1, j,\n             limit = (uint)(Math.Sqrt(bound) - 1) >> 1;\n        var comp = new bool[cl]; bool lp;\n        for (j = 3; j < cl; j += 3) comp[j] = true;\n        while (i < limit) {\n            if (lp = !comp[i]) {\n                uint pr = (i << 1) + 3;\n                for (j = (pr * pr - 2) >> 1; j < cl; j += pr)\n                    comp[j] = true;\n            }\n            if (!comp[++i]) {\n                uint pr = (i << 1) + 3;\n                if (lp) {\n                    if (pr > p) {\n                        res[ri++] = count;\n                        p *= 10;\n                    }\n                    count++;\n                    i++;\n                }\n                for (j = (pr * pr - 2) >> 1; j < cl; j += pr)\n                    comp[j] = true; \n            }\n        }\n        cl--;\n        while (i < cl) {\n            lp = !comp[i++];\n            if (!comp[i] && lp) {\n                if ((i++ << 1) + 3 > p) {\n                    res[ri++] = count;\n                    p *= 10;\n                }\n                count++;\n            }\n        }\n        res[ri] = count;\n    }\n\n    static void Main(string[] args) {\n        var sw = System.Diagnostics.Stopwatch.StartNew();\n        string fmt = \"{0,9:n0} twin primes below {1,-13:n0}\";\n        TabulateTwinPrimes(1_000_000_000);\n        sw.Stop();\n        p = 1;\n        for (var j = 1; j <= ri; j++)\n            Console.WriteLine(fmt, res[j], p *= 10);\n        Console.Write(\"{0} sec\", sw.Elapsed.TotalSeconds);\n    }\n}\n"}
{"id": 335344, "name": "Brazilian numbers", "source": "Translate Ruby to C#: def sameDigits(n,b)\n    f = n % b\n    while (n /= b) > 0 do\n        if n % b != f then\n            return false\n        end\n    end\n    return true\nend\n\ndef isBrazilian(n)\n    if n < 7 then\n        return false\n    end\n    if n % 2 == 0 then\n        return true\n    end\n    for b in 2 .. n - 2 do\n        if sameDigits(n, b) then\n            return true\n        end\n    end\n    return false\nend\n\ndef isPrime(n)\n    if n < 2 then\n        return false\n    end\n    if n % 2 == 0 then\n        return n == 2\n    end\n    if n % 3 == 0 then\n        return n == 3\n    end\n    d = 5\n    while d * d <= n do\n        if n % d == 0 then\n            return false\n        end\n        d = d + 2\n\n        if n % d == 0 then\n            return false\n        end\n        d = d + 4\n    end\n    return true\nend\n\ndef main\n    for kind in [\"\", \"odd \", \"prime \"] do\n        quiet = false\n        bigLim = 99999\n        limit = 20\n        puts \"First %d %sBrazilian numbers:\" % [limit, kind]\n        c = 0\n        n = 7\n        while c < bigLim do\n            if isBrazilian(n) then\n                if not quiet then\n                    print \"%d \" % [n]\n                end\n                c = c + 1\n                if c == limit then\n                    puts\n                    puts\n                    quiet = true\n                end\n            end\n            if quiet and kind != \"\" then\n                next\n            end\n            if kind == \"\" then\n                n = n + 1\n            elsif kind == \"odd \" then\n                n = n + 2\n            elsif kind == \"prime \" then\n                loop do\n                    n = n + 2\n                    if isPrime(n) then\n                        break\n                    end\n                end\n            else\n                raise \"Unexpected\"\n            end\n        end\n        if kind == \"\" then\n            puts \"The %dth Brazillian number is: %d\" % [bigLim + 1, n]\n            puts\n        end\n    end\nend\n\nmain()\n", "target": "using System;\nclass Program {\n \n  static bool sameDigits(int n, int b) {\n    int f = n % b;\n    while ((n /= b) > 0) if (n % b != f) return false;\n    return true;\n  }\n \n  static bool isBrazilian(int n) {\n    if (n < 7) return false;\n    if (n % 2 == 0) return true;\n    for (int b = 2; b < n - 1; b++) if (sameDigits(n, b)) return true;\n    return false;\n  }\n \n  static bool isPrime(int n) {\n    if (n < 2) return false;\n    if (n % 2 == 0) return n == 2;\n    if (n % 3 == 0) return n == 3;\n    int d = 5;\n    while (d * d <= n) {\n      if (n % d == 0) return false; d += 2;\n      if (n % d == 0) return false; d += 4;\n    }\n    return true;\n  }\n \n  static void Main(string[] args) {\n    foreach (string kind in \",odd ,prime \".Split(',')) {\n      bool quiet = false; int BigLim = 99999, limit = 20;\n      Console.WriteLine(\"First {0} {1}Brazilian numbers:\", limit, kind);\n      int c = 0, n = 7;\n      while (c < BigLim) {\n        if (isBrazilian(n)) {\n          if (!quiet) Console.Write(\"{0:n0} \", n);\n          if (++c == limit) { Console.Write(\"\\n\\n\"); quiet = true; }\n        }\n        if (quiet && kind != \"\") continue;\n        switch (kind) {\n          case \"\": n++; break;\n          case \"odd \": n += 2; break;\n          case \"prime \":\n            while (true) {\n              n += 2;\n              if (isPrime(n)) break;\n            } break;\n        }\n      }\n      if (kind == \"\") Console.WriteLine(\"The {0:n0}th Brazilian number is: {1:n0}\\n\", BigLim + 1, n);\n    }\n  }\n}\n"}
{"id": 335345, "name": "Brazilian numbers", "source": "Translate Ruby to C#: def sameDigits(n,b)\n    f = n % b\n    while (n /= b) > 0 do\n        if n % b != f then\n            return false\n        end\n    end\n    return true\nend\n\ndef isBrazilian(n)\n    if n < 7 then\n        return false\n    end\n    if n % 2 == 0 then\n        return true\n    end\n    for b in 2 .. n - 2 do\n        if sameDigits(n, b) then\n            return true\n        end\n    end\n    return false\nend\n\ndef isPrime(n)\n    if n < 2 then\n        return false\n    end\n    if n % 2 == 0 then\n        return n == 2\n    end\n    if n % 3 == 0 then\n        return n == 3\n    end\n    d = 5\n    while d * d <= n do\n        if n % d == 0 then\n            return false\n        end\n        d = d + 2\n\n        if n % d == 0 then\n            return false\n        end\n        d = d + 4\n    end\n    return true\nend\n\ndef main\n    for kind in [\"\", \"odd \", \"prime \"] do\n        quiet = false\n        bigLim = 99999\n        limit = 20\n        puts \"First %d %sBrazilian numbers:\" % [limit, kind]\n        c = 0\n        n = 7\n        while c < bigLim do\n            if isBrazilian(n) then\n                if not quiet then\n                    print \"%d \" % [n]\n                end\n                c = c + 1\n                if c == limit then\n                    puts\n                    puts\n                    quiet = true\n                end\n            end\n            if quiet and kind != \"\" then\n                next\n            end\n            if kind == \"\" then\n                n = n + 1\n            elsif kind == \"odd \" then\n                n = n + 2\n            elsif kind == \"prime \" then\n                loop do\n                    n = n + 2\n                    if isPrime(n) then\n                        break\n                    end\n                end\n            else\n                raise \"Unexpected\"\n            end\n        end\n        if kind == \"\" then\n            puts \"The %dth Brazillian number is: %d\" % [bigLim + 1, n]\n            puts\n        end\n    end\nend\n\nmain()\n", "target": "using System;\nclass Program {\n \n  static bool sameDigits(int n, int b) {\n    int f = n % b;\n    while ((n /= b) > 0) if (n % b != f) return false;\n    return true;\n  }\n \n  static bool isBrazilian(int n) {\n    if (n < 7) return false;\n    if (n % 2 == 0) return true;\n    for (int b = 2; b < n - 1; b++) if (sameDigits(n, b)) return true;\n    return false;\n  }\n \n  static bool isPrime(int n) {\n    if (n < 2) return false;\n    if (n % 2 == 0) return n == 2;\n    if (n % 3 == 0) return n == 3;\n    int d = 5;\n    while (d * d <= n) {\n      if (n % d == 0) return false; d += 2;\n      if (n % d == 0) return false; d += 4;\n    }\n    return true;\n  }\n \n  static void Main(string[] args) {\n    foreach (string kind in \",odd ,prime \".Split(',')) {\n      bool quiet = false; int BigLim = 99999, limit = 20;\n      Console.WriteLine(\"First {0} {1}Brazilian numbers:\", limit, kind);\n      int c = 0, n = 7;\n      while (c < BigLim) {\n        if (isBrazilian(n)) {\n          if (!quiet) Console.Write(\"{0:n0} \", n);\n          if (++c == limit) { Console.Write(\"\\n\\n\"); quiet = true; }\n        }\n        if (quiet && kind != \"\") continue;\n        switch (kind) {\n          case \"\": n++; break;\n          case \"odd \": n += 2; break;\n          case \"prime \":\n            while (true) {\n              n += 2;\n              if (isPrime(n)) break;\n            } break;\n        }\n      }\n      if (kind == \"\") Console.WriteLine(\"The {0:n0}th Brazilian number is: {1:n0}\\n\", BigLim + 1, n);\n    }\n  }\n}\n"}
{"id": 335346, "name": "Recaman's sequence", "source": "Translate Ruby to C#: require 'set'\n\na = [0]\nused = Set[0]\nused1000 = Set[0]\nfoundDup = false\nn = 1\nwhile n <= 15 or not foundDup or used1000.size < 1001\n    nxt = a[n - 1] - n\n    if nxt < 1 or used === nxt then\n        nxt = nxt + 2 * n\n    end\n    alreadyUsed = used === nxt\n    a << nxt\n    if not alreadyUsed then\n        used << nxt\n        if nxt >= 0 and nxt <= 1000 then\n            used1000 << nxt\n        end\n    end\n    if n == 14 then\n        print \"The first 15 terms of the Recaman's sequence are \", a, \"\\n\"\n    end\n    if not foundDup and alreadyUsed then\n        print \"The first duplicated term is a[\", n, \"] = \", nxt, \"\\n\"\n        foundDup = true\n    end\n    if used1000.size == 1001 then\n        print \"Terms up to a[\", n, \"] are needed to generate 0 to 1000\\n\"\n    end\n    n = n + 1\nend\n", "target": "using System;\nusing System.Collections.Generic;\n\nnamespace RecamanSequence {\n    class Program {\n        static void Main(string[] args) {\n            List<int> a = new List<int>() { 0 };\n            HashSet<int> used = new HashSet<int>() { 0 };\n            HashSet<int> used1000 = new HashSet<int>() { 0 };\n            bool foundDup = false;\n            int n = 1;\n            while (n <= 15 || !foundDup || used1000.Count < 1001) {\n                int next = a[n - 1] - n;\n                if (next < 1 || used.Contains(next)) {\n                    next += 2 * n;\n                }\n                bool alreadyUsed = used.Contains(next);\n                a.Add(next);\n                if (!alreadyUsed) {\n                    used.Add(next);\n                    if (0 <= next && next <= 1000) {\n                        used1000.Add(next);\n                    }\n                }\n                if (n == 14) {\n                    Console.WriteLine(\"The first 15 terms of the Recaman sequence are: [{0}]\", string.Join(\", \", a));\n                }\n                if (!foundDup && alreadyUsed) {\n                    Console.WriteLine(\"The first duplicated term is a[{0}] = {1}\", n, next);\n                    foundDup = true;\n                }\n                if (used1000.Count == 1001) {\n                    Console.WriteLine(\"Terms up to a[{0}] are needed to generate 0 to 1000\", n);\n                }\n                n++;\n            }\n        }\n    }\n}\n"}
{"id": 335347, "name": "Recaman's sequence", "source": "Translate Ruby to C#: require 'set'\n\na = [0]\nused = Set[0]\nused1000 = Set[0]\nfoundDup = false\nn = 1\nwhile n <= 15 or not foundDup or used1000.size < 1001\n    nxt = a[n - 1] - n\n    if nxt < 1 or used === nxt then\n        nxt = nxt + 2 * n\n    end\n    alreadyUsed = used === nxt\n    a << nxt\n    if not alreadyUsed then\n        used << nxt\n        if nxt >= 0 and nxt <= 1000 then\n            used1000 << nxt\n        end\n    end\n    if n == 14 then\n        print \"The first 15 terms of the Recaman's sequence are \", a, \"\\n\"\n    end\n    if not foundDup and alreadyUsed then\n        print \"The first duplicated term is a[\", n, \"] = \", nxt, \"\\n\"\n        foundDup = true\n    end\n    if used1000.size == 1001 then\n        print \"Terms up to a[\", n, \"] are needed to generate 0 to 1000\\n\"\n    end\n    n = n + 1\nend\n", "target": "using System;\nusing System.Collections.Generic;\n\nnamespace RecamanSequence {\n    class Program {\n        static void Main(string[] args) {\n            List<int> a = new List<int>() { 0 };\n            HashSet<int> used = new HashSet<int>() { 0 };\n            HashSet<int> used1000 = new HashSet<int>() { 0 };\n            bool foundDup = false;\n            int n = 1;\n            while (n <= 15 || !foundDup || used1000.Count < 1001) {\n                int next = a[n - 1] - n;\n                if (next < 1 || used.Contains(next)) {\n                    next += 2 * n;\n                }\n                bool alreadyUsed = used.Contains(next);\n                a.Add(next);\n                if (!alreadyUsed) {\n                    used.Add(next);\n                    if (0 <= next && next <= 1000) {\n                        used1000.Add(next);\n                    }\n                }\n                if (n == 14) {\n                    Console.WriteLine(\"The first 15 terms of the Recaman sequence are: [{0}]\", string.Join(\", \", a));\n                }\n                if (!foundDup && alreadyUsed) {\n                    Console.WriteLine(\"The first duplicated term is a[{0}] = {1}\", n, next);\n                    foundDup = true;\n                }\n                if (used1000.Count == 1001) {\n                    Console.WriteLine(\"Terms up to a[{0}] are needed to generate 0 to 1000\", n);\n                }\n                n++;\n            }\n        }\n    }\n}\n"}
{"id": 335348, "name": "Y combinator", "source": "Translate Ruby to C#: y = lambda do |f|\n  lambda {|g| g[g]}[lambda do |g|\n      f[lambda {|*args| g[g][*args]}]\n    end]\nend\n\nfac = lambda{|f| lambda{|n| n < 2 ? 1 : n * f[n-1]}}\np Array.new(10) {|i| y[fac][i]}   \n\nfib = lambda{|f| lambda{|n| n < 2 ? n : f[n-1] + f[n-2]}}\np Array.new(10) {|i| y[fib][i]}   \n", "target": "using System;\n\nstatic class YCombinator<T, TResult>\n{\n    \n    private delegate Func<T, TResult> RecursiveFunc(RecursiveFunc r);\n\n    public static Func<Func<Func<T, TResult>, Func<T, TResult>>, Func<T, TResult>> Fix { get; } =\n        f => ((RecursiveFunc)(g => f(x => g(g)(x))))(g => f(x => g(g)(x)));\n}\n\nstatic class Program\n{\n    static void Main()\n    {\n        var fac = YCombinator<int, int>.Fix(f => x => x < 2 ? 1 : x * f(x - 1));\n        var fib = YCombinator<int, int>.Fix(f => x => x < 2 ? x : f(x - 1) + f(x - 2));\n\n        Console.WriteLine(fac(10));\n        Console.WriteLine(fib(10));\n    }\n}\n"}
{"id": 335349, "name": "Casting out nines", "source": "Translate Ruby to C#: N = 2\nbase = 10\nc1 = 0\nc2 = 0\n\nfor k in 1 .. (base ** N) - 1\n    c1 = c1 + 1\n    if k % (base - 1) == (k * k) % (base - 1) then\n        c2 = c2 + 1\n        print \"%d \" % [k]\n    end\nend\n\nputs\nprint \"Trying %d numbers instead of %d numbers saves %f%%\" % [c2, c1, 100.0 - 100.0 * c2 / c1]\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\nnamespace CastingOutNines {\n    public static class Helper {\n        public static string AsString<T>(this IEnumerable<T> e) {\n            var it = e.GetEnumerator();\n\n            StringBuilder builder = new StringBuilder();\n            builder.Append(\"[\");\n\n            if (it.MoveNext()) {\n                builder.Append(it.Current);\n            }\n            while (it.MoveNext()) {\n                builder.Append(\", \");\n                builder.Append(it.Current);\n            }\n\n            builder.Append(\"]\");\n            return builder.ToString();\n        }\n    }\n\n    class Program {\n        static List<int> CastOut(int @base, int start, int end) {\n            int[] ran = Enumerable\n                .Range(0, @base - 1)\n                .Where(a => a % (@base - 1) == (a * a) % (@base - 1))\n                .ToArray();\n            int x = start / (@base - 1);\n\n            List<int> result = new List<int>();\n            while (true) {\n                foreach (int n in ran) {\n                    int k = (@base - 1) * x + n;\n                    if (k < start) {\n                        continue;\n                    }\n                    if (k > end) {\n                        return result;\n                    }\n                    result.Add(k);\n                }\n                x++;\n            }\n        }\n\n        static void Main() {\n            Console.WriteLine(CastOut(16, 1, 255).AsString());\n            Console.WriteLine(CastOut(10, 1, 99).AsString());\n            Console.WriteLine(CastOut(17, 1, 288).AsString());\n        }\n    }\n}\n"}
{"id": 335350, "name": "Casting out nines", "source": "Translate Ruby to C#: N = 2\nbase = 10\nc1 = 0\nc2 = 0\n\nfor k in 1 .. (base ** N) - 1\n    c1 = c1 + 1\n    if k % (base - 1) == (k * k) % (base - 1) then\n        c2 = c2 + 1\n        print \"%d \" % [k]\n    end\nend\n\nputs\nprint \"Trying %d numbers instead of %d numbers saves %f%%\" % [c2, c1, 100.0 - 100.0 * c2 / c1]\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\nnamespace CastingOutNines {\n    public static class Helper {\n        public static string AsString<T>(this IEnumerable<T> e) {\n            var it = e.GetEnumerator();\n\n            StringBuilder builder = new StringBuilder();\n            builder.Append(\"[\");\n\n            if (it.MoveNext()) {\n                builder.Append(it.Current);\n            }\n            while (it.MoveNext()) {\n                builder.Append(\", \");\n                builder.Append(it.Current);\n            }\n\n            builder.Append(\"]\");\n            return builder.ToString();\n        }\n    }\n\n    class Program {\n        static List<int> CastOut(int @base, int start, int end) {\n            int[] ran = Enumerable\n                .Range(0, @base - 1)\n                .Where(a => a % (@base - 1) == (a * a) % (@base - 1))\n                .ToArray();\n            int x = start / (@base - 1);\n\n            List<int> result = new List<int>();\n            while (true) {\n                foreach (int n in ran) {\n                    int k = (@base - 1) * x + n;\n                    if (k < start) {\n                        continue;\n                    }\n                    if (k > end) {\n                        return result;\n                    }\n                    result.Add(k);\n                }\n                x++;\n            }\n        }\n\n        static void Main() {\n            Console.WriteLine(CastOut(16, 1, 255).AsString());\n            Console.WriteLine(CastOut(10, 1, 99).AsString());\n            Console.WriteLine(CastOut(17, 1, 288).AsString());\n        }\n    }\n}\n"}
{"id": 335351, "name": "Execute HQ9+", "source": "Translate Ruby to C#: class HQ9Interpreter {\n    has pointer;\n    has accumulator;\n\n    func bob (beer) {\n        func what  { \"\n        func where { 'on the wall' }\n        func drink { beer--; \"Take one down, pass it around,\" }\n\n        while (beer.is_pos) {\n            [[what(), where()], [what()],\n            [drink()], [what(), where()], []].each{.join(' ').say}\n        }\n    }\n\n    method run (code) {\n        var chars = code.chars;\n        accumulator = 0;\n        pointer = 0;\n        while (pointer < chars.len) {\n            given (chars[pointer].lc) {\n                when ('h') { say 'Hello world!' }\n                when ('q') { say code }\n                when ('9') { bob(99) }\n                when ('+') { accumulator++ }\n                default    { warn %Q(Syntax error: Unknown command \"\n            }\n            pointer++;\n        }\n    }\n}\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\nclass Program\n{\n    static void RunCode(string code)\n    {\n        int accumulator = 0;\n        var opcodes = new Dictionary<char, Action>\n        {\n            {'H', () => Console.WriteLine(\"Hello, World!\"))},\n            {'Q', () => Console.WriteLine(code) },\n            {'9', () => Console.WriteLine(Enumerable.Range(1,100).Reverse().Select(n => string.Format(\"{0} bottles of beer on the wall\\n{0} bottles of beer\\nTake one down, pass it around\\n{1} bottles of beer on the wall\\n\", n, n-1)).Aggregate((a,b) => a + \"\\n\" + b))},\n            {'+', () => accumulator++ }\n        }\n\n        foreach(var c in code)\n            opcodes[c]();\n    }\n}\n"}
{"id": 335352, "name": "Execute HQ9+", "source": "Translate Ruby to C#: class HQ9Interpreter {\n    has pointer;\n    has accumulator;\n\n    func bob (beer) {\n        func what  { \"\n        func where { 'on the wall' }\n        func drink { beer--; \"Take one down, pass it around,\" }\n\n        while (beer.is_pos) {\n            [[what(), where()], [what()],\n            [drink()], [what(), where()], []].each{.join(' ').say}\n        }\n    }\n\n    method run (code) {\n        var chars = code.chars;\n        accumulator = 0;\n        pointer = 0;\n        while (pointer < chars.len) {\n            given (chars[pointer].lc) {\n                when ('h') { say 'Hello world!' }\n                when ('q') { say code }\n                when ('9') { bob(99) }\n                when ('+') { accumulator++ }\n                default    { warn %Q(Syntax error: Unknown command \"\n            }\n            pointer++;\n        }\n    }\n}\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\nclass Program\n{\n    static void RunCode(string code)\n    {\n        int accumulator = 0;\n        var opcodes = new Dictionary<char, Action>\n        {\n            {'H', () => Console.WriteLine(\"Hello, World!\"))},\n            {'Q', () => Console.WriteLine(code) },\n            {'9', () => Console.WriteLine(Enumerable.Range(1,100).Reverse().Select(n => string.Format(\"{0} bottles of beer on the wall\\n{0} bottles of beer\\nTake one down, pass it around\\n{1} bottles of beer on the wall\\n\", n, n-1)).Aggregate((a,b) => a + \"\\n\" + b))},\n            {'+', () => accumulator++ }\n        }\n\n        foreach(var c in code)\n            opcodes[c]();\n    }\n}\n"}
{"id": 335353, "name": "Erd\u0151s-primes", "source": "Translate Ruby to C#: func is_erdos_prime(p) {\n\n    return true  if p==2\n    return false if !p.is_prime\n\n    var f = 1\n\n    for (var k = 2; f < p; k++) {\n        p - f -> is_composite || return false\n        f *= k\n    }\n\n    return true\n}\n\nsay (\"Erd\u0151s primes <= 2500: \", 1..2500 -> grep(is_erdos_prime))\nsay (\"The 7875th Erd\u0151s prime is: \", is_erdos_prime.nth(7875))\n", "target": "using System; using static System.Console;\nclass Program {\n  const int lmt = (int)1e6, first = 2500; static int[] f = new int[10];\n  static void Main(string[] args) {\n    f[0] = 1; for (int a = 0, b = 1; b < f.Length; a = b++)\n      f[b] = f[a] * (b + 1);\n    int pc = 0, nth = 0, lv = 0;\n    for (int i = 2; i < lmt; i++) if (is_erdos_prime(i)) {\n        if (i < first) Write(\"{0,5:n0}{1}\", i, pc++ % 5 == 4 ? \"\\n\" : \"  \");\n        nth++; lv = i; }\n    Write(\"\\nCount of Erd\u0151s primes between 1 and {0:n0}: {1}\\n{2} Erd\u0151s prime (the last one under {3:n0}): {4:n0}\", first, pc, ord(nth), lmt, lv); }\n\n  static string ord(int n) {\n    return string.Format(\"{0:n0}\", n) + new string[]{\"th\", \"st\", \"nd\", \"rd\", \"th\", \"th\", \"th\", \"th\", \"th\", \"th\"}[n % 10]; }\n\n  static bool is_erdos_prime(int p) {\n    if (!is_pr(p)) return false; int m = 0, t;\n    while ((t = p - f[m++]) > 0) if (is_pr(t)) return false;\n    return true;\n    bool is_pr(int x) {\n      if (x < 4) return x > 1; if ((x & 1) == 0) return false;\n      for (int i = 3; i * i <= x; i += 2) if (x % i == 0) return false;\n    return true; } } }\n"}
{"id": 335354, "name": "Erd\u0151s-primes", "source": "Translate Ruby to C#: func is_erdos_prime(p) {\n\n    return true  if p==2\n    return false if !p.is_prime\n\n    var f = 1\n\n    for (var k = 2; f < p; k++) {\n        p - f -> is_composite || return false\n        f *= k\n    }\n\n    return true\n}\n\nsay (\"Erd\u0151s primes <= 2500: \", 1..2500 -> grep(is_erdos_prime))\nsay (\"The 7875th Erd\u0151s prime is: \", is_erdos_prime.nth(7875))\n", "target": "using System; using static System.Console;\nclass Program {\n  const int lmt = (int)1e6, first = 2500; static int[] f = new int[10];\n  static void Main(string[] args) {\n    f[0] = 1; for (int a = 0, b = 1; b < f.Length; a = b++)\n      f[b] = f[a] * (b + 1);\n    int pc = 0, nth = 0, lv = 0;\n    for (int i = 2; i < lmt; i++) if (is_erdos_prime(i)) {\n        if (i < first) Write(\"{0,5:n0}{1}\", i, pc++ % 5 == 4 ? \"\\n\" : \"  \");\n        nth++; lv = i; }\n    Write(\"\\nCount of Erd\u0151s primes between 1 and {0:n0}: {1}\\n{2} Erd\u0151s prime (the last one under {3:n0}): {4:n0}\", first, pc, ord(nth), lmt, lv); }\n\n  static string ord(int n) {\n    return string.Format(\"{0:n0}\", n) + new string[]{\"th\", \"st\", \"nd\", \"rd\", \"th\", \"th\", \"th\", \"th\", \"th\", \"th\"}[n % 10]; }\n\n  static bool is_erdos_prime(int p) {\n    if (!is_pr(p)) return false; int m = 0, t;\n    while ((t = p - f[m++]) > 0) if (is_pr(t)) return false;\n    return true;\n    bool is_pr(int x) {\n      if (x < 4) return x > 1; if ((x & 1) == 0) return false;\n      for (int i = 3; i * i <= x; i += 2) if (x % i == 0) return false;\n    return true; } } }\n"}
{"id": 335355, "name": "Playing cards", "source": "Translate Ruby to C#: class Card\n  \n  SUITS = %i[ Clubs Hearts Spades Diamonds ]\n  PIPS  = %i[ 2 3 4 5 6 7 8 9 10 Jack Queen King Ace ]\n  \n  \n  @@suit_value = Hash[ SUITS.each_with_index.to_a ]\n  @@pip_value  = Hash[ PIPS.each_with_index.to_a ]\n  \n  attr_reader :pip, :suit\n  \n  def initialize(pip,suit)\n    @pip = pip\n    @suit = suit\n  end\n  \n  def to_s\n    \"\n  end\n  \n  \n  def <=>(other)\n    (@@suit_value[@suit] <=> @@suit_value[other.suit]).nonzero? or\n    @@pip_value[@pip] <=> @@pip_value[other.pip]\n  end\nend\n\nclass Deck\n  def initialize\n    @deck = Card::SUITS.product(Card::PIPS).map{|suit,pip| Card.new(pip,suit)}\n  end\n  \n  def to_s\n    @deck.inspect\n  end\n  \n  def shuffle!\n    @deck.shuffle!\n    self\n  end\n  \n  def deal(*args)\n    @deck.shift(*args)\n  end\nend\n\ndeck = Deck.new.shuffle!\nputs card = deck.deal\nhand = deck.deal(5)\nputs hand.join(\", \")\nputs hand.sort.join(\", \")\n", "target": "using System;\nusing System.Linq;\nusing System.Collections.Generic;\n\npublic struct Card\n{\n    public Card(string rank, string suit) : this()\n    {\n        Rank = rank;\n        Suit = suit;\n    }\n\n    public string Rank { get; }\n    public string Suit { get; }\n\n    public override string ToString() => $\"{Rank} of {Suit}\";\n}\n\npublic class Deck : IEnumerable<Card>\n{\n    static readonly string[] ranks = { \"Two\", \"Three\", \"Four\", \"Five\", \"Six\",\n        \"Seven\", \"Eight\", \"Nine\", \"Ten\", \"Jack\", \"Queen\", \"King\", \"Ace\" };\n    static readonly string[] suits = { \"Clubs\", \"Diamonds\", \"Hearts\", \"Spades\" };\n    readonly List<Card> cards;\n \n    public Deck() {\n        cards = (from suit in suits\n                from rank in ranks\n                select new Card(rank, suit)).ToList();\n    }\n\n    public int Count => cards.Count;\n\n    public void Shuffle() {\n        \n        var random = new Random();\n        for (int i = 0; i < cards.Count; i++) {\n            int r = random.Next(i, cards.Count);\n            var temp = cards[i];\n            cards[i] = cards[r];\n            cards[r] = temp;\n        }\n    }\n\n    public Card Deal() {\n        int last = cards.Count - 1;\n        Card card = cards[last];\n        \n        \n        cards.RemoveAt(last);\n        return card;\n    }\n\n    public IEnumerator<Card> GetEnumerator() {\n        \n        \n        for (int i = cards.Count - 1; i >= 0; i--)\n            yield return cards[i];\n    }\n\n    System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() => GetEnumerator();\n}\n"}
{"id": 335356, "name": "Lah numbers", "source": "Translate Ruby to C#: def fact(n) = n.zero? ? 1 :  1.upto(n).inject(&:*)\n\ndef lah(n, k)\n  case k\n    when 1 then fact(n)\n    when n then 1\n    when (..1),(n..) then 0\n    else n<1 ? 0 : (fact(n)*fact(n-1)) / (fact(k)*fact(k-1)) / fact(n-k)\n  end\nend\n      \nr = (0..12)\nputs \"Unsigned Lah numbers: L(n, k):\"\nputs \"n/k \n\nr.each do |row|\n  print \"%-4s\" % row\n  puts \"\nend\n\nputs \"\\nMaximum value from the L(100, *) row:\";\nputs (1..100).map{|a| lah(100,a)}.max\n", "target": "using System;\nusing System.Linq;\nusing System.Numerics;\n\nnamespace LahNumbers {\n    class Program {\n        static BigInteger Factorial(BigInteger n) {\n            if (n == 0) return 1;\n            BigInteger res = 1;\n            while (n > 0) {\n                res *= n--;\n            }\n            return res;\n        }\n\n        static BigInteger Lah(BigInteger n, BigInteger k) {\n            if (k == 1) return Factorial(n);\n            if (k == n) return 1;\n            if (k > n) return 0;\n            if (k < 1 || n < 1) return 0;\n            return (Factorial(n) * Factorial(n - 1)) / (Factorial(k) * Factorial(k - 1)) / Factorial(n - k);\n        }\n\n        static void Main() {\n            Console.WriteLine(\"Unsigned Lah numbers: L(n, k):\");\n            Console.Write(\"n/k \");\n            foreach (var i in Enumerable.Range(0, 13)) {\n                Console.Write(\"{0,10} \", i);\n            }\n            Console.WriteLine();\n            foreach (var row in Enumerable.Range(0, 13)) {\n                Console.Write(\"{0,-3}\", row);\n                foreach (var i in Enumerable.Range(0, row + 1)) {\n                    var l = Lah(row, i);\n                    Console.Write(\"{0,11}\", l);\n                }\n                Console.WriteLine();\n            }\n            Console.WriteLine(\"\\nMaximum value from the L(100, *) row:\");\n            var maxVal = Enumerable.Range(0, 100).Select(a => Lah(100, a)).Max();\n            Console.WriteLine(maxVal);\n        }\n    }\n}\n"}
{"id": 335357, "name": "Lah numbers", "source": "Translate Ruby to C#: def fact(n) = n.zero? ? 1 :  1.upto(n).inject(&:*)\n\ndef lah(n, k)\n  case k\n    when 1 then fact(n)\n    when n then 1\n    when (..1),(n..) then 0\n    else n<1 ? 0 : (fact(n)*fact(n-1)) / (fact(k)*fact(k-1)) / fact(n-k)\n  end\nend\n      \nr = (0..12)\nputs \"Unsigned Lah numbers: L(n, k):\"\nputs \"n/k \n\nr.each do |row|\n  print \"%-4s\" % row\n  puts \"\nend\n\nputs \"\\nMaximum value from the L(100, *) row:\";\nputs (1..100).map{|a| lah(100,a)}.max\n", "target": "using System;\nusing System.Linq;\nusing System.Numerics;\n\nnamespace LahNumbers {\n    class Program {\n        static BigInteger Factorial(BigInteger n) {\n            if (n == 0) return 1;\n            BigInteger res = 1;\n            while (n > 0) {\n                res *= n--;\n            }\n            return res;\n        }\n\n        static BigInteger Lah(BigInteger n, BigInteger k) {\n            if (k == 1) return Factorial(n);\n            if (k == n) return 1;\n            if (k > n) return 0;\n            if (k < 1 || n < 1) return 0;\n            return (Factorial(n) * Factorial(n - 1)) / (Factorial(k) * Factorial(k - 1)) / Factorial(n - k);\n        }\n\n        static void Main() {\n            Console.WriteLine(\"Unsigned Lah numbers: L(n, k):\");\n            Console.Write(\"n/k \");\n            foreach (var i in Enumerable.Range(0, 13)) {\n                Console.Write(\"{0,10} \", i);\n            }\n            Console.WriteLine();\n            foreach (var row in Enumerable.Range(0, 13)) {\n                Console.Write(\"{0,-3}\", row);\n                foreach (var i in Enumerable.Range(0, row + 1)) {\n                    var l = Lah(row, i);\n                    Console.Write(\"{0,11}\", l);\n                }\n                Console.WriteLine();\n            }\n            Console.WriteLine(\"\\nMaximum value from the L(100, *) row:\");\n            var maxVal = Enumerable.Range(0, 100).Select(a => Lah(100, a)).Max();\n            Console.WriteLine(maxVal);\n        }\n    }\n}\n"}
{"id": 335358, "name": "Two sum", "source": "Translate Ruby to C#: def two_sum(numbers, sum)\n  numbers.each_with_index do |x,i|\n    if j = numbers.index(sum - x) then return [i,j] end\n  end\n  []\nend\n\nnumbers = [0, 2, 11, 19, 90]\np two_sum(numbers, 21)\np two_sum(numbers, 25)\n", "target": "using System;\nusing System.Collections.Generic;\n\npublic class Program\n{\n    public static void Main(string[] args)\n    {\n        int[] arr = { 0, 2, 11, 19, 90 };\n        const int sum = 21;\n\n        var ts = TwoSum(arr, sum);\n        Console.WriteLine(ts != null ? $\"{ts[0]}, {ts[1]}\" : \"no result\");\n\n        Console.ReadLine();\n    }\n\n    public static int[] TwoSum(int[] numbers, int sum)\n    {\n        var map = new Dictionary<int, int>();\n        for (int i = 0; i < numbers.Length; i++)\n        {\n            \n            var key = sum - numbers[i];\n            if (map.ContainsKey(key))\n            {\n                return new[] { map[key], i };\n            }\n            map.Add(numbers[i], i);\n        }\n        return null;\n    }\n}\n"}
{"id": 335359, "name": "Two sum", "source": "Translate Ruby to C#: def two_sum(numbers, sum)\n  numbers.each_with_index do |x,i|\n    if j = numbers.index(sum - x) then return [i,j] end\n  end\n  []\nend\n\nnumbers = [0, 2, 11, 19, 90]\np two_sum(numbers, 21)\np two_sum(numbers, 25)\n", "target": "using System;\nusing System.Collections.Generic;\n\npublic class Program\n{\n    public static void Main(string[] args)\n    {\n        int[] arr = { 0, 2, 11, 19, 90 };\n        const int sum = 21;\n\n        var ts = TwoSum(arr, sum);\n        Console.WriteLine(ts != null ? $\"{ts[0]}, {ts[1]}\" : \"no result\");\n\n        Console.ReadLine();\n    }\n\n    public static int[] TwoSum(int[] numbers, int sum)\n    {\n        var map = new Dictionary<int, int>();\n        for (int i = 0; i < numbers.Length; i++)\n        {\n            \n            var key = sum - numbers[i];\n            if (map.ContainsKey(key))\n            {\n                return new[] { map[key], i };\n            }\n            map.Add(numbers[i], i);\n        }\n        return null;\n    }\n}\n"}
{"id": 335360, "name": "Numbers with prime digits whose sum is 13", "source": "Translate Ruby to C#: def primeDigitsSum13(n)\n    sum = 0\n    while n > 0\n        r = n % 10\n        if r != 2 and r != 3 and r != 5 and r != 7 then\n            return false\n        end\n        n = (n / 10).floor\n        sum = sum + r\n    end\n    return sum == 13\nend\n\nc = 0\nfor i in 1 .. 1000000\n    if primeDigitsSum13(i) then\n        print \"%6d \" % [i]\n        if c == 10 then\n            c = 0\n            print \"\\n\"\n        else\n            c = c + 1\n        end\n    end\nend\nprint \"\\n\"\n", "target": "using System;\nusing static System.Console; \nusing LI = System.Collections.Generic.SortedSet<int>;\n\nclass Program {\n\n  static LI unl(LI res, LI set, int lft, int mul = 1, int vlu = 0) {\n    if (lft == 0) res.Add(vlu);\n    else if (lft > 0) foreach (int itm in set)\n      res = unl(res, set, lft - itm, mul * 10, vlu + itm * mul);\n    return res; }\n\n  static void Main(string[] args) { WriteLine(string.Join(\" \",\n      unl(new LI {}, new LI { 2, 3, 5, 7 }, 13))); }\n}\n"}
{"id": 335361, "name": "Numbers with prime digits whose sum is 13", "source": "Translate Ruby to C#: def primeDigitsSum13(n)\n    sum = 0\n    while n > 0\n        r = n % 10\n        if r != 2 and r != 3 and r != 5 and r != 7 then\n            return false\n        end\n        n = (n / 10).floor\n        sum = sum + r\n    end\n    return sum == 13\nend\n\nc = 0\nfor i in 1 .. 1000000\n    if primeDigitsSum13(i) then\n        print \"%6d \" % [i]\n        if c == 10 then\n            c = 0\n            print \"\\n\"\n        else\n            c = c + 1\n        end\n    end\nend\nprint \"\\n\"\n", "target": "using System;\nusing static System.Console; \nusing LI = System.Collections.Generic.SortedSet<int>;\n\nclass Program {\n\n  static LI unl(LI res, LI set, int lft, int mul = 1, int vlu = 0) {\n    if (lft == 0) res.Add(vlu);\n    else if (lft > 0) foreach (int itm in set)\n      res = unl(res, set, lft - itm, mul * 10, vlu + itm * mul);\n    return res; }\n\n  static void Main(string[] args) { WriteLine(string.Join(\" \",\n      unl(new LI {}, new LI { 2, 3, 5, 7 }, 13))); }\n}\n"}
{"id": 335362, "name": "Deepcopy", "source": "Translate Ruby to C#: \norig = { :num => 1, :ary => [2, 3] }\norig[:cycle] = orig\t\n\n\ncopy = Marshal.load(Marshal.dump orig)\n\n\n\norig[:ary] << 4\norig[:rng] = (5..6)\n\n\n\np orig\t\np copy\t\n\n\n\np [(orig.equal? orig[:cycle]),\n   (copy.equal? copy[:cycle]),\n   (not orig.equal? copy)]\t\n", "target": "using System;\n\nnamespace prog\n{\n\tclass MainClass\n\t{\n\t\tclass MyClass : ICloneable\n\t\t{\n\t\t\tpublic MyClass() { f = new int[3]{2,3,5}; c = '1'; }\n\t\t\t\n\t\t\tpublic object Clone()\n\t\t\t{\t\t\t\t\n\t\t\t\tMyClass cpy = (MyClass) this.MemberwiseClone();\n\t\t\t\tcpy.f = (int[]) this.f.Clone();\t\t\t\n\t\t\t\treturn cpy;\n\t\t\t}\n\t\t\t\n\t\t\tpublic char c;\n\t\t\tpublic int[] f;\n\t\t}\n\t\t\n\t\tpublic static void Main( string[] args )\n\t\t{\n\t\t\tMyClass c1 = new MyClass();\n\t\t\tMyClass c2 = (MyClass) c1.Clone();\n\t\t}\n\t}\n}\n"}
{"id": 335363, "name": "Deepcopy", "source": "Translate Ruby to C#: \norig = { :num => 1, :ary => [2, 3] }\norig[:cycle] = orig\t\n\n\ncopy = Marshal.load(Marshal.dump orig)\n\n\n\norig[:ary] << 4\norig[:rng] = (5..6)\n\n\n\np orig\t\np copy\t\n\n\n\np [(orig.equal? orig[:cycle]),\n   (copy.equal? copy[:cycle]),\n   (not orig.equal? copy)]\t\n", "target": "using System;\n\nnamespace prog\n{\n\tclass MainClass\n\t{\n\t\tclass MyClass : ICloneable\n\t\t{\n\t\t\tpublic MyClass() { f = new int[3]{2,3,5}; c = '1'; }\n\t\t\t\n\t\t\tpublic object Clone()\n\t\t\t{\t\t\t\t\n\t\t\t\tMyClass cpy = (MyClass) this.MemberwiseClone();\n\t\t\t\tcpy.f = (int[]) this.f.Clone();\t\t\t\n\t\t\t\treturn cpy;\n\t\t\t}\n\t\t\t\n\t\t\tpublic char c;\n\t\t\tpublic int[] f;\n\t\t}\n\t\t\n\t\tpublic static void Main( string[] args )\n\t\t{\n\t\t\tMyClass c1 = new MyClass();\n\t\t\tMyClass c2 = (MyClass) c1.Clone();\n\t\t}\n\t}\n}\n"}
{"id": 335364, "name": "Frobenius numbers", "source": "Translate Ruby to C#: require 'prime'\n\nPrime.each_cons(2) do |p1, p2|\n  f = p1*p2-p1-p2\n  break if f > 10_000\n  puts f\nend\n", "target": "using System.Collections.Generic; using System.Linq; using static System.Console; using static System.Math;\n\nclass Program {\n\n    static bool ispr(int x) { int lim = (int)Sqrt((double)x);\n        if (x < 2) return false; if ((x % 3) == 0) return x == 0; bool odd = false;\n        for (int d = 5; d <= lim; d += (odd = !odd) ? 2 : 4) {\n        if (x % d == 0) return false; } return true; }\n\n    static void Main() {\n        int c = 0, d = 0, f, lim = 1000000, l2 = lim / 100; var Frob = PG.Primes((int)Sqrt(lim) + 1).ToArray();\n        for (int n = 0, m = 1; m < Frob.Length; n = m++) {\n            if ((f = Frob[n] * Frob[m] - Frob[n] - Frob[m]) < l2) d++;\n            Write(\"{0,7:n0}{2} {1}\", f , ++c % 10 == 0 ? \"\\n\" : \"\", ispr(f) ? \" \" : \"*\"); }\n        Write(\"\\n\\nCalculated {0} Frobenius numbers of consecutive primes under {1:n0}, \" +\n            \"of which {2} were under {3:n0}\", c, lim, d, l2); } }\n\nclass PG { public static IEnumerable<int> Primes(int lim) { \n    var flags = new bool[lim + 1]; int j = 3; yield return 2; \n    for (int d = 8, sq = 9; sq <= lim; j += 2, sq += d += 8)\n      if (!flags[j]) { yield return j;\n        for (int k = sq, i = j << 1; k <= lim; k += i) flags[k] = true; }\n    for (; j <= lim; j += 2) if (!flags[j]) yield return j; } }\n"}
{"id": 335365, "name": "Frobenius numbers", "source": "Translate Ruby to C#: require 'prime'\n\nPrime.each_cons(2) do |p1, p2|\n  f = p1*p2-p1-p2\n  break if f > 10_000\n  puts f\nend\n", "target": "using System.Collections.Generic; using System.Linq; using static System.Console; using static System.Math;\n\nclass Program {\n\n    static bool ispr(int x) { int lim = (int)Sqrt((double)x);\n        if (x < 2) return false; if ((x % 3) == 0) return x == 0; bool odd = false;\n        for (int d = 5; d <= lim; d += (odd = !odd) ? 2 : 4) {\n        if (x % d == 0) return false; } return true; }\n\n    static void Main() {\n        int c = 0, d = 0, f, lim = 1000000, l2 = lim / 100; var Frob = PG.Primes((int)Sqrt(lim) + 1).ToArray();\n        for (int n = 0, m = 1; m < Frob.Length; n = m++) {\n            if ((f = Frob[n] * Frob[m] - Frob[n] - Frob[m]) < l2) d++;\n            Write(\"{0,7:n0}{2} {1}\", f , ++c % 10 == 0 ? \"\\n\" : \"\", ispr(f) ? \" \" : \"*\"); }\n        Write(\"\\n\\nCalculated {0} Frobenius numbers of consecutive primes under {1:n0}, \" +\n            \"of which {2} were under {3:n0}\", c, lim, d, l2); } }\n\nclass PG { public static IEnumerable<int> Primes(int lim) { \n    var flags = new bool[lim + 1]; int j = 3; yield return 2; \n    for (int d = 8, sq = 9; sq <= lim; j += 2, sq += d += 8)\n      if (!flags[j]) { yield return j;\n        for (int k = sq, i = j << 1; k <= lim; k += i) flags[k] = true; }\n    for (; j <= lim; j += 2) if (!flags[j]) yield return j; } }\n"}
{"id": 335366, "name": "Integer roots", "source": "Translate Ruby to C#: def root(a,b)\n  return b if b<2\n  a1, c = a-1, 1\n  f = -> x {(a1*x+b/(x**a1))/a}  \n  d = f[c]\n  e = f[d]\n  c, d, e = d, e, f[e] until [d,e].include?(c)\n  [d,e].min\nend\n\nputs \"First 2,001 digits of the square root of two:\"\nputs root(2, 2*100**2000)\n", "target": "using System;\nusing System.Numerics;\n\nnamespace IntegerRoots {\n    class Program {\n        static BigInteger IRoot(BigInteger @base, int n) {\n            if (@base < 0 || n <= 0) {\n                throw new ArgumentException();\n            }\n\n            int n1 = n - 1;\n            BigInteger n2 = n;\n            BigInteger n3 = n1;\n            BigInteger c = 1;\n            BigInteger d = (n3 + @base) / n2;\n            BigInteger e = ((n3 * d) + (@base / BigInteger.Pow(d, n1))) / n2;\n            while (c != d && c != e) {\n                c = d;\n                d = e;\n                e = (n3 * e + @base / BigInteger.Pow(e, n1)) / n2;\n            }\n            if (d < e) {\n                return d;\n            }\n            return e;\n        }\n\n        static void Main(string[] args) {\n            Console.WriteLine(\"3rd integer root of 8 = {0}\", IRoot(8, 3));\n            Console.WriteLine(\"3rd integer root of 9 = {0}\", IRoot(9, 3));\n\n            BigInteger b = BigInteger.Pow(100, 2000) * 2;\n            Console.WriteLine(\"First 2001 digits of the sqaure root of 2: {0}\", IRoot(b, 2));\n        }\n    }\n}\n"}
{"id": 335367, "name": "Integer roots", "source": "Translate Ruby to C#: def root(a,b)\n  return b if b<2\n  a1, c = a-1, 1\n  f = -> x {(a1*x+b/(x**a1))/a}  \n  d = f[c]\n  e = f[d]\n  c, d, e = d, e, f[e] until [d,e].include?(c)\n  [d,e].min\nend\n\nputs \"First 2,001 digits of the square root of two:\"\nputs root(2, 2*100**2000)\n", "target": "using System;\nusing System.Numerics;\n\nnamespace IntegerRoots {\n    class Program {\n        static BigInteger IRoot(BigInteger @base, int n) {\n            if (@base < 0 || n <= 0) {\n                throw new ArgumentException();\n            }\n\n            int n1 = n - 1;\n            BigInteger n2 = n;\n            BigInteger n3 = n1;\n            BigInteger c = 1;\n            BigInteger d = (n3 + @base) / n2;\n            BigInteger e = ((n3 * d) + (@base / BigInteger.Pow(d, n1))) / n2;\n            while (c != d && c != e) {\n                c = d;\n                d = e;\n                e = (n3 * e + @base / BigInteger.Pow(e, n1)) / n2;\n            }\n            if (d < e) {\n                return d;\n            }\n            return e;\n        }\n\n        static void Main(string[] args) {\n            Console.WriteLine(\"3rd integer root of 8 = {0}\", IRoot(8, 3));\n            Console.WriteLine(\"3rd integer root of 9 = {0}\", IRoot(9, 3));\n\n            BigInteger b = BigInteger.Pow(100, 2000) * 2;\n            Console.WriteLine(\"First 2001 digits of the sqaure root of 2: {0}\", IRoot(b, 2));\n        }\n    }\n}\n"}
{"id": 335368, "name": "Find the last Sunday of each month", "source": "Translate Ruby to C#: require 'date'\n\ndef last_sundays_of_year(year = Date.today.year)\n  (1..12).map do |month|\n    d = Date.new(year, month, -1) \n    d - d.wday\n  end\nend\n\nputs last_sundays_of_year(2013)\n", "target": "using System;\n\nnamespace LastSundayOfEachMonth\n{\n    class Program\n    {\n        static void Main()\n        {\n            Console.Write(\"Year to calculate: \");\n\n            string strYear = Console.ReadLine();\n            int year = Convert.ToInt32(strYear);\n\n            DateTime date;\n            for (int i = 1; i <= 12; i++)\n            {\n                date = new DateTime(year, i, DateTime.DaysInMonth(year, i), System.Globalization.CultureInfo.CurrentCulture.Calendar);\n                \n                \n                int daysOffset = date.DayOfWeek - dayOfWeek; \n                if (daysOffset < 0) daysOffset += 7; \n                date = date.AddDays(-daysOffset ); \n                Console.WriteLine(date.ToString(\"yyyy-MM-dd\"));\n            }\n        }\n    }\n}\n"}
{"id": 335369, "name": "Find the last Sunday of each month", "source": "Translate Ruby to C#: require 'date'\n\ndef last_sundays_of_year(year = Date.today.year)\n  (1..12).map do |month|\n    d = Date.new(year, month, -1) \n    d - d.wday\n  end\nend\n\nputs last_sundays_of_year(2013)\n", "target": "using System;\n\nnamespace LastSundayOfEachMonth\n{\n    class Program\n    {\n        static void Main()\n        {\n            Console.Write(\"Year to calculate: \");\n\n            string strYear = Console.ReadLine();\n            int year = Convert.ToInt32(strYear);\n\n            DateTime date;\n            for (int i = 1; i <= 12; i++)\n            {\n                date = new DateTime(year, i, DateTime.DaysInMonth(year, i), System.Globalization.CultureInfo.CurrentCulture.Calendar);\n                \n                \n                int daysOffset = date.DayOfWeek - dayOfWeek; \n                if (daysOffset < 0) daysOffset += 7; \n                date = date.AddDays(-daysOffset ); \n                Console.WriteLine(date.ToString(\"yyyy-MM-dd\"));\n            }\n        }\n    }\n}\n"}
{"id": 335370, "name": "Random Latin squares", "source": "Translate Ruby to C#: N = 5\n\ndef generate_square\n  perms  =  (1..N).to_a.permutation(N).to_a.shuffle\n  square = []\n  N.times do\n    square << perms.pop\n    perms.reject!{|perm| perm.zip(square.last).any?{|el1, el2| el1 == el2} }\n  end\n  square\nend\n\ndef print_square(square)\n  cell_size = N.digits.size + 1\n  strings = square.map!{|row| row.map!{|el| el.to_s.rjust(cell_size)}.join }\n  puts strings, \"\\n\"\nend\n\n2.times{print_square( generate_square)}\n", "target": "using System;\nusing System.Collections.Generic;\n\nnamespace RandomLatinSquares {\n    using Matrix = List<List<int>>;\n\n    \n    static class Helper {\n        private static readonly Random rng = new Random();\n\n        public static void Shuffle<T>(this IList<T> list) {\n            int n = list.Count;\n            while (n > 1) {\n                n--;\n                int k = rng.Next(n + 1);\n                T value = list[k];\n                list[k] = list[n];\n                list[n] = value;\n            }\n        }\n    }\n\n    class Program {\n        static void PrintSquare(Matrix latin) {\n            foreach (var row in latin) {\n                Console.Write('[');\n\n                var it = row.GetEnumerator();\n                if (it.MoveNext()) {\n                    Console.Write(it.Current);\n                }\n                while (it.MoveNext()) {\n                    Console.Write(\", \");\n                    Console.Write(it.Current);\n                }\n\n                Console.WriteLine(']');\n            }\n            Console.WriteLine();\n        }\n\n        static void LatinSquare(int n) {\n            if (n <= 0) {\n                Console.WriteLine(\"[]\");\n                return;\n            }\n\n            var latin = new Matrix();\n            for (int i = 0; i < n; i++) {\n                List<int> temp = new List<int>();\n                for (int j = 0; j < n; j++) {\n                    temp.Add(j);\n                }\n                latin.Add(temp);\n            }\n            \n            latin[0].Shuffle();\n\n            \n            for (int i = 1; i < n - 1; i++) {\n                bool shuffled = false;\n\n                while (!shuffled) {\n                    latin[i].Shuffle();\n                    for (int k = 0; k < i; k++) {\n                        for (int j = 0; j < n; j++) {\n                            if (latin[k][j] == latin[i][j]) {\n                                goto shuffling;\n                            }\n                        }\n                    }\n                    shuffled = true;\n\n                shuffling: { }\n                }\n            }\n\n            \n            for (int j = 0; j < n; j++) {\n                List<bool> used = new List<bool>();\n                for (int i = 0; i < n; i++) {\n                    used.Add(false);\n                }\n\n                for (int i = 0; i < n-1; i++) {\n                    used[latin[i][j]] = true;\n                }\n                for (int k = 0; k < n; k++) {\n                    if (!used[k]) {\n                        latin[n - 1][j] = k;\n                        break;\n                    }\n                }\n            }\n\n            PrintSquare(latin);\n        }\n\n        static void Main() {\n            LatinSquare(5);\n            LatinSquare(5);\n            LatinSquare(10); \n        }\n    }\n}\n"}
{"id": 335371, "name": "Descending primes", "source": "Translate Ruby to C#: require 'prime'\n\ndigits = [9,8,7,6,5,4,3,2,1].to_a\nres = 1.upto(digits.size).flat_map do |n|\n   digits.combination(n).filter_map do |set|\n      candidate = set.join.to_i\n      candidate if candidate.prime?\n   end.reverse\n end\n\n puts res.join(\",\")\n", "target": "using System;\n\nclass Program {\n\n  static bool ispr(uint n) {\n    if ((n & 1) == 0 || n < 2) return n == 2;\n    for (uint j = 3; j * j <= n; j += 2)\n      if (n % j == 0) return false; return true; }\n\n  static void Main(string[] args) {\n    uint c = 0; int nc;\n    var ps = new uint[]{ 1, 2, 3, 4, 5, 6, 7, 8, 9 };\n    var nxt = new uint[128];\n    while (true) {\n      nc = 0;\n      foreach (var a in ps) {\n        if (ispr(a))\n          Console.Write(\"{0,8}{1}\", a, ++c % 5 == 0 ? \"\\n\" : \" \");\n        for (uint b = a * 10, l = a % 10 + b++; b < l; b++)\n          nxt[nc++] = b;\n      }\n      if (nc > 1) {\n        Array.Resize (ref ps, nc); Array.Copy(nxt, ps, nc); }\n      else break;\n    }\n    Console.WriteLine(\"\\n{0} descending primes found\", c);\n  }\n}\n"}
{"id": 335372, "name": "RPG attributes generator", "source": "Translate Ruby to C#: def roll_stat\n  dices = Array(Int32).new(4) { rand(1..6) }\n  dices.sum - dices.min\nend\n\ndef roll_character\n  loop do\n    stats = Array(Int32).new(6) { roll_stat }\n    return stats if stats.sum >= 75 && stats.count(&.>=(15)) >= 2\n  end\nend\n\n10.times do\n  stats = roll_character\n  puts \"stats: \nend\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\nstatic class Module1\n{\n    static Random r = new Random();\n\n    static List<int> getThree(int n)\n    {\n        List<int> g3 = new List<int>();\n        for (int i = 0; i < 4; i++) g3.Add(r.Next(n) + 1);\n        g3.Sort(); g3.RemoveAt(0); return g3;\n    }\n\n    static List<int> getSix()\n    {\n        List<int> g6 = new List<int>();\n        for (int i = 0; i < 6; i++) g6.Add(getThree(6).Sum());\n        return g6;\n    }\n\n    static void Main(string[] args)\n    {\n        bool good = false; do {\n            List<int> gs = getSix(); int gss = gs.Sum(); int hvc = gs.FindAll(x => x > 14).Count;\n            Console.Write(\"attribs: {0}, sum={1}, ({2} sum, high vals={3})\",\n                          string.Join(\", \", gs), gss, gss >= 75 ? \"good\" : \"low\", hvc);\n            Console.WriteLine(\" - {0}\", (good = gs.Sum() >= 75 && hvc > 1) ? \"success\" : \"failure\");\n        } while (!good);\n    }\n}\n"}
{"id": 335373, "name": "Kolakoski sequence", "source": "Translate Ruby to C#: def create_generator(ar)\n  Enumerator.new do |y|\n    cycle = ar.cycle\n    s = []\n    loop do\n      t = cycle.next\n      s.push(t)\n      v = s.shift\n      y << v\n      (v-1).times{s.push(t)}\n    end\n  end\nend\n\ndef rle(ar)\n  ar.slice_when{|a,b| a != b}.map(&:size)\nend\n\n[[20, [1,2]], \n [20, [2,1]], \n [30, [1,3,1,2]],\n [30, [1,3,2,1]]].each do |num,ar|\n  puts \"\\nFirst \n  p res = create_generator(ar).take(num)\n  puts \"Possible Kolakoski sequence? \nend\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Threading.Tasks;\n\nnamespace KolakoskiSequence {\n    class Crutch {\n        public readonly int len;\n        public int[] s;\n        public int i;\n\n        public Crutch(int len) {\n            this.len = len;\n            s = new int[len];\n            i = 0;\n        }\n\n        public void Repeat(int count) {\n            for (int j = 0; j < count; j++) {\n                if (++i == len) return;\n                s[i] = s[i - 1];\n            }\n        }\n    }\n\n    static class Extension {\n        public static int NextInCycle(this int[] self, int index) {\n            return self[index % self.Length];\n        }\n\n        public static int[] Kolakoski(this int[] self, int len) {\n            Crutch c = new Crutch(len);\n\n            int k = 0;\n            while (c.i < len) {\n                c.s[c.i] = self.NextInCycle(k);\n                if (c.s[k] > 1) {\n                    c.Repeat(c.s[k] - 1);\n                }\n                if (++c.i == len) return c.s;\n                k++;\n            }\n            return c.s;\n        }\n\n        public static bool PossibleKolakoski(this int[] self) {\n            int[] rle = new int[self.Length];\n            int prev = self[0];\n            int count = 1;\n            int pos = 0;\n            for (int i = 1; i < self.Length; i++) {\n                if (self[i] == prev) {\n                    count++;\n                }\n                else {\n                    rle[pos++] = count;\n                    count = 1;\n                    prev = self[i];\n                }\n            }\n            \n            for (int i = 0; i < pos; i++) {\n                if (rle[i] != self[i]) {\n                    return false;\n                }\n            }\n            return true;\n        }\n\n        public static string AsString(this int[] self) {\n            StringBuilder sb = new StringBuilder(\"[\");\n            int count = 0;\n            foreach (var item in self) {\n                if (count > 0) {\n                    sb.Append(\", \");\n                }\n                sb.Append(item);\n                count++;\n            }\n            return sb.Append(\"]\").ToString();\n        }\n    }\n\n    class Program {\n        static void Main(string[] args) {\n            int[][] ias = {\n                new int[]{1, 2},\n                new int[]{2, 1},\n                new int[]{1, 3, 1, 2},\n                new int[]{1, 3, 2, 1}\n            };\n            int[] lens = { 20, 20, 30, 30 };\n\n            for (int i = 0; i < ias.Length; i++) {\n                int len = lens[i];\n                int[] kol = ias[i].Kolakoski(len);\n\n                Console.WriteLine(\"First {0} members of the sequence by {1}: \", len, ias[i].AsString());\n                Console.WriteLine(kol.AsString());\n                Console.WriteLine(\"Possible Kolakoski sequence? {0}\", kol.PossibleKolakoski());\n                Console.WriteLine();\n            }\n        }\n    }\n}\n"}
{"id": 335374, "name": "Longest increasing subsequence", "source": "Translate Ruby to C#: Node = Struct.new(:val, :back)\n\ndef lis(n)\n  pileTops = []\n  \n  for x in n\n    \n    low, high = 0, pileTops.size-1\n    while low <= high\n      mid = low + (high - low) / 2\n      if pileTops[mid].val >= x\n        high = mid - 1\n      else\n        low = mid + 1\n      end\n    end\n    i = low\n    node = Node.new(x)\n    node.back = pileTops[i-1]  if i > 0\n    pileTops[i] = node\n  end\n  \n  result = []\n  node = pileTops.last\n  while node\n    result.unshift(node.val)\n    node = node.back\n  end\n  result\nend\n\np lis([3, 2, 6, 4, 5, 1])\np lis([0, 8, 4, 12, 2, 10, 6, 14, 1, 9, 5, 13, 3, 11, 7, 15])\n", "target": "using System;\nusing System.Collections;\nusing System.Collections.Generic;\nusing System.Linq;\n\npublic static class LIS\n{\n    public static IEnumerable<T> FindRec<T>(IList<T> values, IComparer<T> comparer = null) =>\n        values == null ? throw new ArgumentNullException() :\n            FindRecImpl(values, Sequence<T>.Empty, 0, comparer ?? Comparer<T>.Default).Reverse();\n\n    private static Sequence<T> FindRecImpl<T>(IList<T> values, Sequence<T> current, int index, IComparer<T> comparer) {\n        if (index == values.Count) return current;\n        if (current.Length > 0 && comparer.Compare(values[index], current.Value) <= 0)\n            return FindRecImpl(values, current, index + 1, comparer);\n        return Max(\n            FindRecImpl(values, current, index + 1, comparer),\n            FindRecImpl(values, current + values[index], index + 1, comparer)\n        );\n    }\n\n    private static Sequence<T> Max<T>(Sequence<T> a, Sequence<T> b) => a.Length < b.Length ? b : a;\n\n    class Sequence<T> : IEnumerable<T>\n    {\n        public static readonly Sequence<T> Empty = new Sequence<T>(default(T), null);\n\n        public Sequence(T value, Sequence<T> tail)\n        {\n            Value = value;\n            Tail = tail;\n            Length = tail == null ? 0 : tail.Length + 1;\n        }\n\n        public T Value { get; }\n        public Sequence<T> Tail { get; }\n        public int Length { get; }\n\n        public static Sequence<T> operator +(Sequence<T> s, T value) => new Sequence<T>(value, s);\n\n        public IEnumerator<T> GetEnumerator()\n        {\n            for (var s = this; s.Length > 0; s = s.Tail) yield return s.Value;\n        }\n\n        IEnumerator IEnumerable.GetEnumerator() => GetEnumerator();\n    }\n}\n"}
{"id": 335375, "name": "Dynamic variable names", "source": "Translate Ruby to C#: p \"Enter a variable name\"\nx = \"@\" + gets.chomp!\ninstance_variable_set x, 42\np \"The value of \n", "target": "using System;\nusing System.Dynamic;\nusing System.Collections.Generic;\n\npublic class Program\n{\n    public static void Main()\n    {\n        string varname = Console.ReadLine();\n        \n        dynamic expando = new ExpandoObject();\n        var map = expando as IDictionary<string, object>;\n        map.Add(varname, \"Hello world!\");\n \n        Console.WriteLine(expando.foo);\n    }\n}\n"}
{"id": 335376, "name": "Odd squarefree semiprimes", "source": "Translate Ruby to C#: func odd_squarefree_almost_primes(upto, k=2) {\n    k.squarefree_almost_primes(upto).grep{.is_odd}\n}\n\nwith (1e3) {|n|\n    var list = odd_squarefree_almost_primes(n, 2)\n    say \"Found \n    say (list.first(10).join(', '), ', ..., ', list.last(10).join(', '))\n}\n", "target": "using System; using static System.Console; using System.Collections;\nusing System.Linq; using System.Collections.Generic;\n\nclass Program { static void Main(string[] args) {\n    int lmt = 1000, amt, c = 0, sr = (int)Math.Sqrt(lmt), lm2; var res = new List<int>();\n    var pr = PG.Primes(lmt / 3 + 5).ToArray(); lm2 = pr.OrderBy(i => Math.Abs(sr - i)).First();\n    lm2 = Array.IndexOf(pr, lm2); for (var p = 0; p < lm2; p++) { amt = 0; for (var q = p + 1; amt < lmt; q++)\n      res.Add(amt = pr[p] * pr[q]); } res.Sort(); foreach(var item in res.TakeWhile(x => x < lmt))\n        Write(\"{0,4} {1}\", item, ++c % 20 == 0 ? \"\\n\" : \"\");\n    Write(\"\\n\\nCounted {0} odd squarefree semiprimes under {1}\", c, lmt); } }\n\nclass PG { public static IEnumerable<int> Primes(int lim) {\n    var flags = new bool[lim + 1]; int j = 3;\n    for (int d = 8, sq = 9; sq <= lim; j += 2, sq += d += 8)\n      if (!flags[j]) { yield return j;\n        for (int k = sq, i = j << 1; k <= lim; k += i) flags[k] = true; }\n    for (; j <= lim; j += 2) if (!flags[j]) yield return j; } }\n"}
{"id": 335377, "name": "Odd squarefree semiprimes", "source": "Translate Ruby to C#: func odd_squarefree_almost_primes(upto, k=2) {\n    k.squarefree_almost_primes(upto).grep{.is_odd}\n}\n\nwith (1e3) {|n|\n    var list = odd_squarefree_almost_primes(n, 2)\n    say \"Found \n    say (list.first(10).join(', '), ', ..., ', list.last(10).join(', '))\n}\n", "target": "using System; using static System.Console; using System.Collections;\nusing System.Linq; using System.Collections.Generic;\n\nclass Program { static void Main(string[] args) {\n    int lmt = 1000, amt, c = 0, sr = (int)Math.Sqrt(lmt), lm2; var res = new List<int>();\n    var pr = PG.Primes(lmt / 3 + 5).ToArray(); lm2 = pr.OrderBy(i => Math.Abs(sr - i)).First();\n    lm2 = Array.IndexOf(pr, lm2); for (var p = 0; p < lm2; p++) { amt = 0; for (var q = p + 1; amt < lmt; q++)\n      res.Add(amt = pr[p] * pr[q]); } res.Sort(); foreach(var item in res.TakeWhile(x => x < lmt))\n        Write(\"{0,4} {1}\", item, ++c % 20 == 0 ? \"\\n\" : \"\");\n    Write(\"\\n\\nCounted {0} odd squarefree semiprimes under {1}\", c, lmt); } }\n\nclass PG { public static IEnumerable<int> Primes(int lim) {\n    var flags = new bool[lim + 1]; int j = 3;\n    for (int d = 8, sq = 9; sq <= lim; j += 2, sq += d += 8)\n      if (!flags[j]) { yield return j;\n        for (int k = sq, i = j << 1; k <= lim; k += i) flags[k] = true; }\n    for (; j <= lim; j += 2) if (!flags[j]) yield return j; } }\n"}
{"id": 335378, "name": "Primes with digits in nondecreasing order", "source": "Translate Ruby to C#: require 'prime'\n\nbase = 10\nupto = 1000\n\nres = Prime.each(upto).select do |pr|\n   pr.digits(base).each_cons(2).all?{|p1, p2| p1 >= p2}\nend\n\nputs \"There are \nputs res.join(\", \")\n", "target": "using System.Linq; using System.Collections.Generic; using static System.Console; using static System.Math;\n \nclass Program {\n\n  static int ba; static string chars = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\";\n\n  \n  static string from10(int b) { string res = \"\"; int re; while (b > 0) {\n    b = DivRem(b, ba, out re); res = chars[(byte)re] + res; } return res; }\n\n  \n  static int to10(string s) { int res = 0; foreach (char i in s)\n    res = res * ba + chars.IndexOf(i); return res; }\n\n  \n  static bool nd(string s) { if (s.Length < 2) return true;\n    char l = s[0]; for (int i = 1; i < s.Length; i++)\n      if (chars.IndexOf(l) > chars.IndexOf(s[i]))\n        return false; else l = s[i] ; return true; }\n\n  static void Main(string[] args) { int c, lim = 1000; string s;\n    foreach (var b in new List<int>{ 2, 3, 4, 5, 6, 7, 8, 9, 10, 16, 17, 27, 31, 62 }) {\n      ba = b; c = 0; foreach (var a in PG.Primes(lim))\n        if (nd(s = from10(a))) Write(\"{0,4} {1}\", s, ++c % 20 == 0 ? \"\\n\" : \"\");\n    WriteLine(\"\\nBase {0}: found {1} non-decreasing primes under {2:n0}\\n\", b, c, from10(lim)); } } } \n \nclass PG { public static IEnumerable<int> Primes(int lim) {\n    var flags = new bool[lim + 1]; int j; yield return 2;\n    for (j = 4; j <= lim; j += 2) flags[j] = true; j = 3;\n    for (int d = 8, sq = 9; sq <= lim; j += 2, sq += d += 8)\n      if (!flags[j]) { yield return j;\n        for (int k = sq, i = j << 1; k <= lim; k += i) flags[k] = true; }\n    for (; j <= lim; j += 2) if (!flags[j]) yield return j; } }\n"}
{"id": 335379, "name": "Primes with digits in nondecreasing order", "source": "Translate Ruby to C#: require 'prime'\n\nbase = 10\nupto = 1000\n\nres = Prime.each(upto).select do |pr|\n   pr.digits(base).each_cons(2).all?{|p1, p2| p1 >= p2}\nend\n\nputs \"There are \nputs res.join(\", \")\n", "target": "using System.Linq; using System.Collections.Generic; using static System.Console; using static System.Math;\n \nclass Program {\n\n  static int ba; static string chars = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\";\n\n  \n  static string from10(int b) { string res = \"\"; int re; while (b > 0) {\n    b = DivRem(b, ba, out re); res = chars[(byte)re] + res; } return res; }\n\n  \n  static int to10(string s) { int res = 0; foreach (char i in s)\n    res = res * ba + chars.IndexOf(i); return res; }\n\n  \n  static bool nd(string s) { if (s.Length < 2) return true;\n    char l = s[0]; for (int i = 1; i < s.Length; i++)\n      if (chars.IndexOf(l) > chars.IndexOf(s[i]))\n        return false; else l = s[i] ; return true; }\n\n  static void Main(string[] args) { int c, lim = 1000; string s;\n    foreach (var b in new List<int>{ 2, 3, 4, 5, 6, 7, 8, 9, 10, 16, 17, 27, 31, 62 }) {\n      ba = b; c = 0; foreach (var a in PG.Primes(lim))\n        if (nd(s = from10(a))) Write(\"{0,4} {1}\", s, ++c % 20 == 0 ? \"\\n\" : \"\");\n    WriteLine(\"\\nBase {0}: found {1} non-decreasing primes under {2:n0}\\n\", b, c, from10(lim)); } } } \n \nclass PG { public static IEnumerable<int> Primes(int lim) {\n    var flags = new bool[lim + 1]; int j; yield return 2;\n    for (j = 4; j <= lim; j += 2) flags[j] = true; j = 3;\n    for (int d = 8, sq = 9; sq <= lim; j += 2, sq += d += 8)\n      if (!flags[j]) { yield return j;\n        for (int k = sq, i = j << 1; k <= lim; k += i) flags[k] = true; }\n    for (; j <= lim; j += 2) if (!flags[j]) yield return j; } }\n"}
{"id": 335380, "name": "Read a file character by character_UTF8", "source": "Translate Ruby to C#: File.open(\"input.txt\") do |file|\n  file.each_char { |c| p c }\nend\n", "target": "using System;\nusing System.IO;\nusing System.Text;\n\nnamespace RosettaFileByChar\n{\n    class Program\n    {\n        static char GetNextCharacter(StreamReader streamReader) => (char)streamReader.Read();\n\n        static void Main(string[] args)\n        {\n            Console.OutputEncoding = Encoding.UTF8;\n            char c;\n            using (FileStream fs = File.OpenRead(\"input.txt\"))\n            {\n                using (StreamReader streamReader = new StreamReader(fs, Encoding.UTF8))\n                {\n                    while (!streamReader.EndOfStream)\n                    {\n                        c = GetNextCharacter(streamReader);\n                        Console.Write(c);\n                    }\n                }\n            }\n        }\n    }\n}\n"}
{"id": 335381, "name": "Smallest square that begins with n", "source": "Translate Ruby to C#: def f(n)\n    if n < 1 then\n        return\n    end\n\n    i = 1\n    while true do\n        sq = i * i\n        while sq > n do\n            sq = (sq / 10).floor\n        end\n        if sq == n then\n            print \"%3d %9d %4d\\n\" % [n, i * i, i]\n            return\n        end\n        i = i + 1\n    end\nend\n\nprint(\"Prefix    n^2    n\\n\")\nprint()\nfor i in 1 .. 49\n    f(i)\nend\n", "target": "using System;\n\nclass Program\n{\n    static void Main(string[] args)\n    {\n        int i, d, s, t, n = 50, c = 1;\n        var sw = new int[n];\n        for (i = d = s = 1; c < n; i++, s += d += 2)\n            for (t = s; t > 0; t /= 10)\n                if (t < n && sw[t] < 1)\n                    Console.Write(\"\", sw[t] = s, c++);\n        Console.Write(string.Join(\" \", sw).Substring(2));\n    }\n}\n"}
{"id": 335382, "name": "Smallest square that begins with n", "source": "Translate Ruby to C#: def f(n)\n    if n < 1 then\n        return\n    end\n\n    i = 1\n    while true do\n        sq = i * i\n        while sq > n do\n            sq = (sq / 10).floor\n        end\n        if sq == n then\n            print \"%3d %9d %4d\\n\" % [n, i * i, i]\n            return\n        end\n        i = i + 1\n    end\nend\n\nprint(\"Prefix    n^2    n\\n\")\nprint()\nfor i in 1 .. 49\n    f(i)\nend\n", "target": "using System;\n\nclass Program\n{\n    static void Main(string[] args)\n    {\n        int i, d, s, t, n = 50, c = 1;\n        var sw = new int[n];\n        for (i = d = s = 1; c < n; i++, s += d += 2)\n            for (t = s; t > 0; t /= 10)\n                if (t < n && sw[t] < 1)\n                    Console.Write(\"\", sw[t] = s, c++);\n        Console.Write(string.Join(\" \", sw).Substring(2));\n    }\n}\n"}
{"id": 335383, "name": "Brace expansion", "source": "Translate Ruby to C#: def getitem(s, depth=0)\n  out = [\"\"]\n  until s.empty?\n    c = s[0]\n    break  if depth>0 and (c == ',' or c == '}')\n    if c == '{' and x = getgroup(s[1..-1], depth+1)\n      out = out.product(x[0]).map{|a,b| a+b}\n      s = x[1]\n    else\n      s, c = s[1..-1], c + s[1]  if c == '\\\\' and s.size > 1\n      out, s = out.map{|a| a+c}, s[1..-1]\n    end\n  end\n  return out, s\nend\n\ndef getgroup(s, depth)\n  out, comma = [], false\n  until s.empty?\n    g, s = getitem(s, depth)\n    break  if s.empty?\n    out += g\n    case s[0]\n      when '}' then return (comma ? out : out.map{|a| \"{\n      when ',' then comma, s = true, s[1..-1]\n    end\n  end\nend\n\nstrs = <<'EOS'\n~/{Downloads,Pictures}/*.{jpg,gif,png}\nIt{{em,alic}iz,erat}e{d,}, please.\n{,{,gotta have{ ,\\, again\\, }}more }cowbell!\n{}} some }{,{\\\\{ edge, edge} \\,}{ cases, {here} \\\\\\\\\\}\nEOS\n\nstrs.each_line do |s|\n  puts s.chomp!\n  puts getitem(s)[0].map{|str| \"\\t\"+str}\n  puts\nend\n", "target": "using System;\nusing System.Collections;\nusing System.Collections.Generic;\nusing System.Text;\nusing static System.Linq.Enumerable;\n\npublic static class BraceExpansion\n{\n    enum TokenType { OpenBrace, CloseBrace, Separator, Text, Alternate, Concat }\n    const char L = '{', R = '}', S = ',';\n    \n    public static void Main() {\n        string[] input = {\n            \"It{{em,alic}iz,erat}e{d,}, please.\",\n            \"~/{Downloads,Pictures}/*.{jpg,gif,png}\",\n            @\"{,{,gotta have{ ,\\, again\\, }}more }cowbell!\",\n            @\"{}} some }{,{\\\\{ edge, edge} \\,}{ cases, {here} \\\\\\\\\\}\"\n        };\n        foreach (string text in input) Expand(text);\n    }\n    \n    static void Expand(string input) {\n        Token token = Tokenize(input);\n        foreach (string value in token) Console.WriteLine(value);\n        Console.WriteLine();\n    }\n    \n    static Token Tokenize(string input) {\n        var tokens = new List<Token>();\n        var buffer = new StringBuilder();\n        bool escaping = false;\n        int level = 0;\n        \n        foreach (char c in input) {\n            (escaping, level, tokens, buffer) = c switch {\n                _ when escaping => (false, level, tokens, buffer.Append(c)),\n                '\\\\' => (true, level, tokens, buffer.Append(c)),\n                L => (escaping, level + 1,\n                    tokens.With(buffer.Flush()).With(new Token(c.ToString(), TokenType.OpenBrace)), buffer),\n                S when level > 0 => (escaping, level,\n                    tokens.With(buffer.Flush()).With(new Token(c.ToString(), TokenType.Separator)), buffer),\n                R when level > 0 => (escaping, level - 1,\n                    tokens.With(buffer.Flush()).With(new Token(c.ToString(), TokenType.CloseBrace)).Merge(), buffer),\n                _ => (escaping, level, tokens, buffer.Append(c))\n            };\n        }\n        if (buffer.Length > 0) tokens.Add(buffer.Flush());\n        for (int i = 0; i < tokens.Count; i++) {\n            if (tokens[i].Type == TokenType.OpenBrace || tokens[i].Type == TokenType.Separator) {\n                tokens[i] = tokens[i].Value; \n            }\n        }\n        return new Token(tokens, TokenType.Concat);\n    }\n    \n    static List<Token> Merge(this List<Token> list) {\n        int separators = 0;\n        int last = list.Count - 1;\n        for (int i = list.Count - 3; i >= 0; i--) {\n            if (list[i].Type == TokenType.Separator) {\n                separators++;\n                Concat(list, i + 1, last);\n                list.RemoveAt(i);\n                last = i;\n            } else if (list[i].Type == TokenType.OpenBrace) {\n                Concat(list, i + 1, last);\n                if (separators > 0) {\n                    list[i] = new Token(list.Range((i+1)..^1), TokenType.Alternate);\n                    list.RemoveRange(i+1, list.Count - i - 1);\n                } else {\n                    list[i] = L.ToString();\n                    list[^1] = R.ToString();\n                    Concat(list, i, list.Count);\n                }\n                break;\n            }\n        }\n        return list;\n    }\n    \n    static void Concat(List<Token> list, int s, int e) {\n        for (int i = e - 2; i >= s; i--) {\n            (Token a, Token b) = (list[i], list[i+1]);\n            switch (a.Type, b.Type) {\n                case (TokenType.Text, TokenType.Text):\n                    list[i] = a.Value + b.Value;\n                    list.RemoveAt(i+1);\n                    break;\n                case (TokenType.Concat, TokenType.Concat):\n                    a.SubTokens.AddRange(b.SubTokens);\n                    list.RemoveAt(i+1);\n                    break;\n                case (TokenType.Concat, TokenType.Text) when b.Value == \"\":\n                    list.RemoveAt(i+1);\n                    break;\n                case (TokenType.Text, TokenType.Concat) when a.Value == \"\":\n                    list.RemoveAt(i);\n                    break;\n                default:\n                    list[i] = new Token(new [] { a, b }, TokenType.Concat);\n                    list.RemoveAt(i+1);\n                    break;\n            }\n        }\n    }\n    \n    private struct Token : IEnumerable<string>\n    {\n        private List<Token>? _subTokens;\n        \n        public string Value { get; }\n        public TokenType Type { get; }\n        public List<Token> SubTokens => _subTokens ??= new List<Token>();\n        \n        public Token(string value, TokenType type) => (Value, Type, _subTokens) = (value, type, null);\n        public Token(IEnumerable<Token> subTokens, TokenType type) => (Value, Type, _subTokens) = (\"\", type, subTokens.ToList());\n        \n        public static implicit operator Token(string value) => new Token(value, TokenType.Text);\n        \n        public IEnumerator<string> GetEnumerator() => (Type switch\n        {\n            TokenType.Concat => SubTokens.Select(t => t.AsEnumerable()).CartesianProduct().Select(p => string.Join(\"\", p)),\n            TokenType.Alternate => from t in SubTokens from s in t select s,\n            _ => Repeat(Value, 1)\n        }).GetEnumerator();\n        \n        IEnumerator IEnumerable.GetEnumerator() => GetEnumerator();        \n    }\n    \n    \n    static IEnumerable<IEnumerable<T>> CartesianProduct<T>(this IEnumerable<IEnumerable<T>> sequences) {\n        IEnumerable<IEnumerable<T>> emptyProduct = new[] { Empty<T>() };\n        return sequences.Aggregate(\n            emptyProduct,\n            (accumulator, sequence) =>\n                from acc in accumulator\n                from item in sequence\n                select acc.Concat(new [] { item }));\n    }\n    \n    static List<Token> With(this List<Token> list, Token token) {\n        list.Add(token);\n        return list;\n    }\n    \n    static IEnumerable<Token> Range(this List<Token> list, Range range) {\n        int start = range.Start.GetOffset(list.Count);\n        int end = range.End.GetOffset(list.Count);\n        for (int i = start; i < end; i++) yield return list[i];\n    }\n    \n    static string Flush(this StringBuilder builder) {\n        string result = builder.ToString();\n        builder.Clear();\n        return result;\n    }\n}\n"}
{"id": 335384, "name": "Intersecting number wheels", "source": "Translate Ruby to C#: groups = [{A: [1, 2, 3]},\n          {A: [1, :B, 2], B: [3, 4]},\n          {A: [1, :D, :D], D: [6, 7, 8]},\n          {A: [1, :B, :C], B: [3, 4], C: [5, :B]} ]\n\ngroups.each do |group|\n  p group\n  wheels = group.transform_values(&:cycle) \n  res = 20.times.map do\n    el = wheels[:A].next\n    el = wheels[el].next until el.is_a?(Integer)\n    el\n  end\n  puts res.join(\" \"),\"\"\nend\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\npublic static class IntersectingNumberWheels\n{\n    public static void Main() {\n        TurnWheels(('A', \"123\")).Take(20).Print();\n        TurnWheels(('A', \"1B2\"), ('B', \"34\")).Take(20).Print();\n        TurnWheels(('A', \"1DD\"), ('D', \"678\")).Take(20).Print();\n        TurnWheels(('A', \"1BC\"), ('B', \"34\"), ('C', \"5B\")).Take(20).Print();\n    }\n\n    static IEnumerable<char> TurnWheels(params (char name, string values)[] wheels) {\n        var data = wheels.ToDictionary(wheel => wheel.name, wheel => wheel.values.Loop().GetEnumerator());\n        var primary = data[wheels[0].name];\n        while (true) {\n            yield return Turn(primary);\n        }\n\n        char Turn(IEnumerator<char> sequence) {\n            sequence.MoveNext();\n            char c = sequence.Current;\n            return char.IsDigit(c) ? c : Turn(data[c]);\n        }\n    }\n\n    static IEnumerable<T> Loop<T>(this IEnumerable<T> seq) {\n        while (true) {\n            foreach (T element in seq) yield return element;\n        }\n    }\n\n    static void Print(this IEnumerable<char> sequence) => Console.WriteLine(string.Join(\" \", sequence));\n}\n"}
{"id": 335385, "name": "Intersecting number wheels", "source": "Translate Ruby to C#: groups = [{A: [1, 2, 3]},\n          {A: [1, :B, 2], B: [3, 4]},\n          {A: [1, :D, :D], D: [6, 7, 8]},\n          {A: [1, :B, :C], B: [3, 4], C: [5, :B]} ]\n\ngroups.each do |group|\n  p group\n  wheels = group.transform_values(&:cycle) \n  res = 20.times.map do\n    el = wheels[:A].next\n    el = wheels[el].next until el.is_a?(Integer)\n    el\n  end\n  puts res.join(\" \"),\"\"\nend\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\npublic static class IntersectingNumberWheels\n{\n    public static void Main() {\n        TurnWheels(('A', \"123\")).Take(20).Print();\n        TurnWheels(('A', \"1B2\"), ('B', \"34\")).Take(20).Print();\n        TurnWheels(('A', \"1DD\"), ('D', \"678\")).Take(20).Print();\n        TurnWheels(('A', \"1BC\"), ('B', \"34\"), ('C', \"5B\")).Take(20).Print();\n    }\n\n    static IEnumerable<char> TurnWheels(params (char name, string values)[] wheels) {\n        var data = wheels.ToDictionary(wheel => wheel.name, wheel => wheel.values.Loop().GetEnumerator());\n        var primary = data[wheels[0].name];\n        while (true) {\n            yield return Turn(primary);\n        }\n\n        char Turn(IEnumerator<char> sequence) {\n            sequence.MoveNext();\n            char c = sequence.Current;\n            return char.IsDigit(c) ? c : Turn(data[c]);\n        }\n    }\n\n    static IEnumerable<T> Loop<T>(this IEnumerable<T> seq) {\n        while (true) {\n            foreach (T element in seq) yield return element;\n        }\n    }\n\n    static void Print(this IEnumerable<char> sequence) => Console.WriteLine(string.Join(\" \", sequence));\n}\n"}
{"id": 335386, "name": "Color of a screen pixel", "source": "Translate Ruby to C#: module Screen\n  IMPORT_COMMAND = '/usr/bin/import'\n\n  \n  def self.pixel(x, y)\n    if m = `\n      m[1..3].map(&:to_i)\n    else\n      false\n    end\n  end\nend\n", "target": "using System;\nusing System.Drawing;\nusing System.Windows.Forms;\n\nclass Program\n{\n    static Color GetPixel(Point position)\n    {\n        using (var bitmap = new Bitmap(1, 1))\n        {\n            using (var graphics = Graphics.FromImage(bitmap))\n            {\n                graphics.CopyFromScreen(position, new Point(0, 0), new Size(1, 1));\n            }\n            return bitmap.GetPixel(0, 0);\n        }\n    }\n\n    static void Main()\n    {\n        Console.WriteLine(GetPixel(Cursor.Position));\n    }\n}\n"}
{"id": 335387, "name": "Yahoo! search interface", "source": "Translate Ruby to C#: require 'open-uri'\nrequire 'hpricot'\n\nSearchResult = Struct.new(:url, :title, :content)\n\nclass SearchYahoo\n  @@urlinfo = [nil, 'ca.search.yahoo.com', 80, '/search', nil, nil]\n\n  def initialize(term)\n    @term = term\n    @page = 1\n    @results = nil\n    @url = URI::HTTP.build(@@urlinfo)\n  end\n\n  def next_result\n    if not @results\n      @results = []\n      fetch_results\n    elsif @results.empty?\n      next_page\n    end\n    @results.shift\n  end\n\n  def fetch_results\n    @url.query = URI.escape(\"p=%s&b=%d\" % [@term, @page])\n    doc = open(@url) { |f| Hpricot(f) }  \n    parse_html(doc)\n  end\n\n  def next_page\n    @page += 10\n    fetch_results\n  end\n\n  def parse_html(doc)\n    doc.search(\"div\n      next unless div.has_attribute?(\"class\") and div.get_attribute(\"class\").index(\"res\") == 0\n      result = SearchResult.new\n      div.search(\"a\").each do |link|\n        next unless link.has_attribute?(\"class\") and link.get_attribute(\"class\") == \"yschttl spt\"\n        result.url = link.get_attribute(\"href\")\n        result.title = link.inner_text\n      end\n      div.search(\"div\").each do |abstract|\n        next unless abstract.has_attribute?(\"class\") and abstract.get_attribute(\"class\").index(\"abstr\")\n        result.content = abstract.inner_text\n      end\n      @results << result\n    end\n  end\nend\n\ns = SearchYahoo.new(\"test\")\n15.times do |i|\n  result = s.next_result\n  puts i+1\n  puts result.title\n  puts result.url\n  puts result.content\n  puts\nend\n", "target": "using System;\nusing System.Net;\nusing System.Text.RegularExpressions;\nusing System.Collections.Generic;\n\nclass YahooSearch {\n    private string query;\n    private string content;\n    private int page;\n\n    const string yahoo = \"http:\n\n    public YahooSearch(string query) : this(query, 0) { }\n\n    public YahooSearch(string query, int page) {\n        this.query = query;\n        this.page = page;\n        this.content = new WebClient()\n            .DownloadString(\n                string.Format(yahoo + \"p={0}&b={1}\", query, this.page * 10 + 1)\n            );\n    }\n\n    public YahooResult[] Results {\n        get {\n            List<YahooResult> results = new List<YahooResult>();\n\n            Func<string, string, string> substringBefore = (str, before) =>\n            {\n                int iHref = str.IndexOf(before);\n                return iHref < 0 ? \"\" : str.Substring(0, iHref);\n            };\n            Func<string, string, string> substringAfter = (str, after) =>\n            {\n                int iHref = str.IndexOf(after);\n                return iHref < 0 ? \"\" : str.Substring(iHref + after.Length);\n            };\n            Converter<string, string> getText = p => \n                Regex.Replace(p, \"<[^>]*>\", x => \"\");\n\n            Regex rx = new Regex(@\"\n                <li>\n                    <div \\s class=\"\"res\"\">\n                        <div>\n                            <h3>\n                                <a \\s (?'LinkAttributes'[^>]+)>\n                                    (?'LinkText' .*?)\n                                (?></a>)\n                            </h3>\n                        </div>\n                        <div \\s class=\"\"abstr\"\">\n                            (?'Abstract' .*?)\n                        (?></div>)\n                        .*?\n                    (?></div>)\n                </li>\",\n                RegexOptions.IgnorePatternWhitespace\n                | RegexOptions.ExplicitCapture\n            );\n            foreach (Match e in rx.Matches(this.content)) {\n                string rurl = getText(substringBefore(substringAfter(\n                    e.Groups[\"LinkAttributes\"].Value, @\"href=\"\"\"), @\"\"\"\"));\n                string rtitle = getText(e.Groups[\"LinkText\"].Value);\n                string rcontent = getText(e.Groups[\"Abstract\"].Value);\n                \n                results.Add(new YahooResult(rurl, rtitle, rcontent));\n            }\n            return results.ToArray();\n        }\n    }\n\n    public YahooSearch NextPage() {\n        return new YahooSearch(this.query, this.page + 1);\n    }\n\n    public YahooSearch GetPage(int page) {\n        return new YahooSearch(this.query, page);\n    }\n}\n\nclass YahooResult {\n    public string URL { get; set; }\n    public string Title { get; set; }\n    public string Content { get; set; }\n\n    public YahooResult(string url, string title, string content) {\n        this.URL = url;\n        this.Title = title;\n        this.Content = content;\n    }\n\n    public override string ToString()\n    {\n        return string.Format(\"\\nTitle: {0}\\nLink:  {1}\\nText:  {2}\",\n            Title, URL, Content);\n    }\n}\n\n\n\nclass Prog {\n    static void Main() {\n        foreach (int page in new[] { 0, 1 })\n        {\n            YahooSearch x = new YahooSearch(\"test\", page);\n\n            foreach (YahooResult result in x.Results)\n            {\n                Console.WriteLine(result);\n            }\n        }\n    }\n}\n"}
{"id": 335388, "name": "Circles of given radius through two points", "source": "Translate Ruby to C#: Pt     = Struct.new(:x, :y)\nCircle = Struct.new(:x, :y, :r)\n\ndef circles_from(pt1, pt2, r)\n  raise ArgumentError, \"Infinite number of circles, points coincide.\" if pt1 == pt2 && r > 0\n  \n  return [Circle.new(pt1.x, pt1.y, r)] if pt1 == pt2 && r == 0\n  dx, dy = pt2.x - pt1.x, pt2.y - pt1.y\n  \n  q = Math.hypot(dx, dy)\n  \n  raise ArgumentError, \"Distance of points > diameter.\" if q > 2.0*r\n  \n  x3, y3 = (pt1.x + pt2.x)/2.0, (pt1.y + pt2.y)/2.0\n  d = (r**2 - (q/2)**2)**0.5\n  [Circle.new(x3 - d*dy/q, y3 + d*dx/q, r),\n   Circle.new(x3 + d*dy/q, y3 - d*dx/q, r)].uniq\nend\n\n\nar = [[Pt.new(0.1234, 0.9876), Pt.new(0.8765, 0.2345), 2.0],\n      [Pt.new(0.0000, 2.0000), Pt.new(0.0000, 0.0000), 1.0],\n      [Pt.new(0.1234, 0.9876), Pt.new(0.1234, 0.9876), 2.0],\n      [Pt.new(0.1234, 0.9876), Pt.new(0.8765, 0.2345), 0.5],\n      [Pt.new(0.1234, 0.9876), Pt.new(0.1234, 0.9876), 0.0]]\n\nar.each do |p1, p2, r|\n  print \"Given points:\\n  \n  begin\n    circles = circles_from(p1, p2, r)\n    puts \"You can construct the following circles:\"\n    circles.each{|c| puts \"  \n  rescue ArgumentError => e\n    puts e\n  end\n  puts\nend\n", "target": "using System;\npublic class CirclesOfGivenRadiusThroughTwoPoints\n{\n    public static void Main()\n    {\n        double[][] values = new double[][] {\n            new [] { 0.1234, 0.9876, 0.8765, 0.2345,   2 },\n            new [] { 0.0,       2.0,    0.0,    0.0,   1 },\n            new [] { 0.1234, 0.9876, 0.1234, 0.9876,   2 },\n            new [] { 0.1234, 0.9876, 0.8765, 0.2345, 0.5 },\n            new [] { 0.1234, 0.9876, 0.1234, 0.9876,   0 }\n        };\n\t\t\n        foreach (var a in values) {\n            var p = new Point(a[0], a[1]);\n            var q = new Point(a[2], a[3]);\n            Console.WriteLine($\"Points {p} and {q} with radius {a[4]}:\");\n            try {\n                var centers = FindCircles(p, q, a[4]);\n                Console.WriteLine(\"\\t\" + string.Join(\" and \", centers));\n            } catch (Exception ex) {\n                Console.WriteLine(\"\\t\" + ex.Message);\n            }\n        }\n    }\n\t\n    static Point[] FindCircles(Point p, Point q, double radius) {\n        if(radius < 0) throw new ArgumentException(\"Negative radius.\");\n        if(radius == 0) {\n            if(p == q) return new [] { p };\n            else throw new InvalidOperationException(\"No circles.\");\n        }\n        if (p == q) throw new InvalidOperationException(\"Infinite number of circles.\");\n\t\t\n        double sqDistance = Point.SquaredDistance(p, q);\n        double sqDiameter = 4 * radius * radius;\n        if (sqDistance > sqDiameter) throw new InvalidOperationException(\"Points are too far apart.\");\n\t\t\n        Point midPoint = new Point((p.X + q.X) / 2, (p.Y + q.Y) / 2);\n        if (sqDistance == sqDiameter) return new [] { midPoint };\n\t\t\n        double d = Math.Sqrt(radius * radius - sqDistance / 4);\n        double distance = Math.Sqrt(sqDistance);\n        double ox = d * (q.X - p.X) / distance, oy = d * (q.Y - p.Y) / distance;\n        return new [] {\n            new Point(midPoint.X - oy, midPoint.Y + ox),\n            new Point(midPoint.X + oy, midPoint.Y - ox)\n        };\n    }\n\t\n    public struct Point\n    {\n        public Point(double x, double y) : this() {\n            X = x;\n            Y = y;\n        }\n\t\n        public double X { get; }\n        public double Y { get; }\n\t\n        public static bool operator ==(Point p, Point q) => p.X == q.X && p.Y == q.Y;\n        public static bool operator !=(Point p, Point q) => p.X != q.X || p.Y != q.Y;\n\t\n        public static double SquaredDistance(Point p, Point q) {\n            double dx = q.X - p.X, dy = q.Y - p.Y;\n            return dx * dx + dy * dy;\n        }\n\t\t\n        public override string ToString() => $\"({X}, {Y})\";\n\t\t\n    }\t\n}\n"}
{"id": 335389, "name": "Circles of given radius through two points", "source": "Translate Ruby to C#: Pt     = Struct.new(:x, :y)\nCircle = Struct.new(:x, :y, :r)\n\ndef circles_from(pt1, pt2, r)\n  raise ArgumentError, \"Infinite number of circles, points coincide.\" if pt1 == pt2 && r > 0\n  \n  return [Circle.new(pt1.x, pt1.y, r)] if pt1 == pt2 && r == 0\n  dx, dy = pt2.x - pt1.x, pt2.y - pt1.y\n  \n  q = Math.hypot(dx, dy)\n  \n  raise ArgumentError, \"Distance of points > diameter.\" if q > 2.0*r\n  \n  x3, y3 = (pt1.x + pt2.x)/2.0, (pt1.y + pt2.y)/2.0\n  d = (r**2 - (q/2)**2)**0.5\n  [Circle.new(x3 - d*dy/q, y3 + d*dx/q, r),\n   Circle.new(x3 + d*dy/q, y3 - d*dx/q, r)].uniq\nend\n\n\nar = [[Pt.new(0.1234, 0.9876), Pt.new(0.8765, 0.2345), 2.0],\n      [Pt.new(0.0000, 2.0000), Pt.new(0.0000, 0.0000), 1.0],\n      [Pt.new(0.1234, 0.9876), Pt.new(0.1234, 0.9876), 2.0],\n      [Pt.new(0.1234, 0.9876), Pt.new(0.8765, 0.2345), 0.5],\n      [Pt.new(0.1234, 0.9876), Pt.new(0.1234, 0.9876), 0.0]]\n\nar.each do |p1, p2, r|\n  print \"Given points:\\n  \n  begin\n    circles = circles_from(p1, p2, r)\n    puts \"You can construct the following circles:\"\n    circles.each{|c| puts \"  \n  rescue ArgumentError => e\n    puts e\n  end\n  puts\nend\n", "target": "using System;\npublic class CirclesOfGivenRadiusThroughTwoPoints\n{\n    public static void Main()\n    {\n        double[][] values = new double[][] {\n            new [] { 0.1234, 0.9876, 0.8765, 0.2345,   2 },\n            new [] { 0.0,       2.0,    0.0,    0.0,   1 },\n            new [] { 0.1234, 0.9876, 0.1234, 0.9876,   2 },\n            new [] { 0.1234, 0.9876, 0.8765, 0.2345, 0.5 },\n            new [] { 0.1234, 0.9876, 0.1234, 0.9876,   0 }\n        };\n\t\t\n        foreach (var a in values) {\n            var p = new Point(a[0], a[1]);\n            var q = new Point(a[2], a[3]);\n            Console.WriteLine($\"Points {p} and {q} with radius {a[4]}:\");\n            try {\n                var centers = FindCircles(p, q, a[4]);\n                Console.WriteLine(\"\\t\" + string.Join(\" and \", centers));\n            } catch (Exception ex) {\n                Console.WriteLine(\"\\t\" + ex.Message);\n            }\n        }\n    }\n\t\n    static Point[] FindCircles(Point p, Point q, double radius) {\n        if(radius < 0) throw new ArgumentException(\"Negative radius.\");\n        if(radius == 0) {\n            if(p == q) return new [] { p };\n            else throw new InvalidOperationException(\"No circles.\");\n        }\n        if (p == q) throw new InvalidOperationException(\"Infinite number of circles.\");\n\t\t\n        double sqDistance = Point.SquaredDistance(p, q);\n        double sqDiameter = 4 * radius * radius;\n        if (sqDistance > sqDiameter) throw new InvalidOperationException(\"Points are too far apart.\");\n\t\t\n        Point midPoint = new Point((p.X + q.X) / 2, (p.Y + q.Y) / 2);\n        if (sqDistance == sqDiameter) return new [] { midPoint };\n\t\t\n        double d = Math.Sqrt(radius * radius - sqDistance / 4);\n        double distance = Math.Sqrt(sqDistance);\n        double ox = d * (q.X - p.X) / distance, oy = d * (q.Y - p.Y) / distance;\n        return new [] {\n            new Point(midPoint.X - oy, midPoint.Y + ox),\n            new Point(midPoint.X + oy, midPoint.Y - ox)\n        };\n    }\n\t\n    public struct Point\n    {\n        public Point(double x, double y) : this() {\n            X = x;\n            Y = y;\n        }\n\t\n        public double X { get; }\n        public double Y { get; }\n\t\n        public static bool operator ==(Point p, Point q) => p.X == q.X && p.Y == q.Y;\n        public static bool operator !=(Point p, Point q) => p.X != q.X || p.Y != q.Y;\n\t\n        public static double SquaredDistance(Point p, Point q) {\n            double dx = q.X - p.X, dy = q.Y - p.Y;\n            return dx * dx + dy * dy;\n        }\n\t\t\n        public override string ToString() => $\"({X}, {Y})\";\n\t\t\n    }\t\n}\n"}
{"id": 336527, "name": "Pascal matrix generation", "source": "Translate Ruby to Python: \nrequire 'pp'\n\nng = (g = 0..4).collect{[]}\ng.each{|i| g.each{|j| ng[i][j] = i==0 ? 1 : j<i ? 0 : ng[i-1][j-1]+ng[i][j-1]}}\npp ng; puts\ng.each{|i| g.each{|j| ng[i][j] = j==0 ? 1 : i<j ? 0 : ng[i-1][j-1]+ng[i-1][j]}}\npp ng; puts\ng.each{|i| g.each{|j| ng[i][j] = (i==0 or j==0) ? 1 : ng[i-1][j  ]+ng[i][j-1]}}\npp ng\n", "target": "from pprint import pprint as pp\n\ndef pascal_upp(n):\n    s = [[0] * n for _ in range(n)]\n    s[0] = [1] * n\n    for i in range(1, n):\n        for j in range(i, n):\n            s[i][j] = s[i-1][j-1] + s[i][j-1]\n    return s\n\ndef pascal_low(n):\n    \n    return [list(x) for x in zip(*pascal_upp(n))]\n\ndef pascal_sym(n):\n    s = [[1] * n for _ in range(n)]\n    for i in range(1, n):\n        for j in range(1, n):\n            s[i][j] = s[i-1][j] + s[i][j-1]\n    return s\n    \n\nif __name__ == \"__main__\":\n    n = 5\n    print(\"\\nUpper:\")\n    pp(pascal_upp(n))\n    print(\"\\nLower:\")\n    pp(pascal_low(n))\n    print(\"\\nSymmetric:\")\n    pp(pascal_sym(n))\n"}
{"id": 336528, "name": "Mad Libs", "source": "Translate Ruby to Python: puts \"Enter a story, terminated by an empty line:\"\nstory = \"\"\nuntil (line = gets).chomp.empty?\n  story << line\nend\n\nstory.scan(/(?<=[<]).+?(?=[>])/).uniq.each do |var|\n  print \"Enter a value for '\n  story.gsub!(/<\nend\n\nputs\nputs story\n", "target": "import re\n\n\n\n\n\ntemplate = \n\ndef madlibs(template):\n    print('The story template is:\\n' + template)\n    fields = sorted(set( re.findall('<[^>]+>', template) ))\n    values = input('\\nInput a comma-separated list of words to replace the following items'\n                   '\\n  %s: ' % ','.join(fields)).split(',')\n    story = template\n    for f,v in zip(fields, values):\n        story = story.replace(f, v)\n    print('\\nThe story becomes:\\n\\n' + story)\n\nmadlibs(template)\n"}
{"id": 336529, "name": "Shortest common supersequence", "source": "Translate Ruby to Python: require 'lcs'\n\ndef scs(u, v)\n  lcs = lcs(u, v)\n  u, v = u.dup, v.dup\n  scs = \"\"\n  \n  until lcs.empty?\n    if u[0]==lcs[0] and v[0]==lcs[0]\n      \n      scs << lcs.slice!(0)\n      u.slice!(0)\n      v.slice!(0)\n    elsif u[0]==lcs[0]\n      \n      scs << v.slice!(0)\n    else\n      \n      scs << u.slice!(0)\n    end\n  end\n  \n  scs + u + v\nend\n\nu = \"abcbdab\"\nv = \"bdcaba\"\nputs \"SCS(\n", "target": "\n\ndef shortest_common_supersequence(a, b):\n    lcs = longest_common_subsequence(a, b)\n    scs = \"\"\n    \n    while len(lcs) > 0:\n        if a[0]==lcs[0] and b[0]==lcs[0]:\n        \n            scs += lcs[0]\n            lcs = lcs[1:]\n            a = a[1:]\n            b = b[1:]\n        elif a[0]==lcs[0]:\n            scs += b[0]\n            b = b[1:]\n        else:\n            scs += a[0]\n            a = a[1:]\n    \n    return scs + a + b\n"}
{"id": 336530, "name": "Long year", "source": "Translate Ruby to Python: require 'date'\n\ndef long_year?(year = Date.today.year)\n  Date.new(year, 12, 28).cweek == 53\nend\n\n(2020..2030).each{|year| puts \"\n", "target": "\n\nfrom datetime import date\n\n\n\ndef longYear(y):\n    \n    return 52 < date(y, 12, 28).isocalendar()[1]\n\n\n\n\ndef main():\n    \n    for year in [\n            x for x in range(2000, 1 + 2100)\n            if longYear(x)\n    ]:\n        print(year)\n\n\n\nif __name__ == '__main__':\n    main()\n"}
{"id": 336531, "name": "Mian-Chowla sequence", "source": "Translate Ruby to Python: require 'set'\nn, ts, mc, sums = 100, [], [1], Set.new\nsums << 2\nst = Time.now\nfor i in (1 .. (n-1))\n   for j in mc[i-1]+1 .. Float::INFINITY\n      mc[i] = j\n      for k in (0 .. i)\n         if (sums.include?(sum = mc[k]+j))\n            ts.clear\n            break \n         end\n         ts << sum\n      end\n      if (ts.length > 0)\n         sums = sums | ts\n         break\n      end\n   end\nend\net = (Time.now - st) * 1000\ns = \" of the Mian-Chowla sequence are:\\n\"\nputs \"The first 30 terms\nputs \"Terms 91 to 100\nputs \"Computation time was \n", "target": "from itertools import count, islice, chain\nimport time\n\ndef mian_chowla():\n    mc = [1]\n    yield mc[-1]\n    psums = set([2])\n    newsums = set([])\n    for trial in count(2):\n        for n in chain(mc, [trial]):\n            sum = n + trial\n            if sum in psums:\n                newsums.clear()\n                break\n            newsums.add(sum)\n        else:\n            psums |= newsums\n            newsums.clear()\n            mc.append(trial)\n            yield trial\n\ndef pretty(p, t, s, f):\n    print(p, t, \" \".join(str(n) for n in (islice(mian_chowla(), s, f))))\n\nif __name__ == '__main__':\n    st = time.time()\n    ts = \"of the Mian-Chowla sequence are:\\n\"\n    pretty(\"The first 30 terms\", ts, 0, 30)\n    pretty(\"\\nTerms 91 to 100\", ts, 90, 100)\n    print(\"\\nComputation time was\", (time.time()-st) * 1000, \"ms\")\n"}
{"id": 336532, "name": "Water collected between towers", "source": "Translate Ruby to Python: def a(array)\nn=array.length\nleft={}\nright={}\nleft[0]=array[0]\ni=1\nloop do\n   break if i >=n\nleft[i]=[left[i-1],array[i]].max\n   i += 1  \nend\nright[n-1]=array[n-1]\ni=n-2\nloop do \nbreak if i<0\n right[i]=[right[i+1],array[i]].max\ni-=1\nend\ni=0\nwater=0\nloop do\nbreak if i>=n\nwater+=[left[i],right[i]].min-array[i]\ni+=1\nend\nputs water\nend\n\na([ 5, 3,  7, 2, 6, 4, 5, 9, 1, 2 ])\na([ 2, 6,  3, 5, 2, 8, 1, 4, 2, 2, 5, 3, 5, 7, 4, 1 ])\na([ 5, 5,  5, 5 ])\na([ 5, 6,  7, 8 ])\na([ 8, 7,  7, 6 ])\na([ 6, 7, 10, 7, 6 ])\nreturn\n", "target": "def water_collected(tower):\n    N = len(tower)\n    highest_left = [0] + [max(tower[:n]) for n in range(1,N)]\n    highest_right = [max(tower[n:N]) for n in range(1,N)] + [0]\n    water_level = [max(min(highest_left[n], highest_right[n]) - tower[n], 0)\n        for n in range(N)]\n    print(\"highest_left:  \", highest_left)\n    print(\"highest_right: \", highest_right)\n    print(\"water_level:   \", water_level)\n    print(\"tower_level:   \", tower)\n    print(\"total_water:   \", sum(water_level))\n    print(\"\")\n    return sum(water_level)\n\ntowers = [[1, 5, 3, 7, 2],\n    [5, 3, 7, 2, 6, 4, 5, 9, 1, 2],\n    [2, 6, 3, 5, 2, 8, 1, 4, 2, 2, 5, 3, 5, 7, 4, 1],\n    [5, 5, 5, 5],\n    [5, 6, 7, 8],\n    [8, 7, 7, 6],\n    [6, 7, 10, 7, 6]]\n\n[water_collected(tower) for tower in towers]\n"}
{"id": 336533, "name": "FASTA format", "source": "Translate Ruby to Python: \ntmpfile = \"/tmp/tmp\"+Random.rand.to_s+\".fasta\"\nFile.write(tmpfile, \">Rosetta_Example_1\nTHERECANBENOSPACE\n>Rosetta_Example_2\nTHERECANBESEVERAL\nLINESBUTTHEYALLMUST\nBECONCATENATED\")\n\n\nref = tmpfile\nid = seq = \"\"\nfasta = {} of String => String\nFile.each_line(ref) do |line|\n  if line.starts_with?(\">\")\n    fasta[id] = seq.sub(/\\s/, \"\") if id != \"\"\n    id = line.split(/\\s/)[0].lstrip(\">\")\n    seq = \"\"\n  else\n    seq += line\n  end\nend\nfasta[id] = seq.sub(/\\s/, \"\")\n\n\nfasta.each { |k,v| puts \"\n", "target": "import io\n\nFASTA=\n\ninfile = io.StringIO(FASTA)\n\ndef fasta_parse(infile):\n    key = ''\n    for line in infile:\n        if line.startswith('>'):\n            if key:\n                yield key, val\n            key, val = line[1:].rstrip().split()[0], ''\n        elif key:\n            val += line.rstrip()\n    if key:\n        yield key, val\n\nprint('\\n'.join('%s: %s' % keyval for keyval in fasta_parse(infile)))\n"}
{"id": 336534, "name": "MAC vendor lookup", "source": "Translate Ruby to Python: require 'net/http'\n\narr = ['88:53:2E:67:07:BE', 'FC:FB:FB:01:FA:21', 'D4:F4:6F:C9:EF:8D', '23:45:67']\n\narr.each do |addr|\n  vendor = Net::HTTP.get('api.macvendors.com', \"/\n  puts \"\nend\n", "target": "import requests\n\nfor addr in ['88:53:2E:67:07:BE', 'FC:FB:FB:01:FA:21',\n        'D4:F4:6F:C9:EF:8D', '23:45:67']:\n    vendor = requests.get('http://api.macvendors.com/' + addr).text\n    print(addr, vendor)\n"}
{"id": 336535, "name": "Magic 8-ball", "source": "Translate Ruby to Python: \n\nclass EightBall\n  def initialize\n    print \"Welcome to 8 ball! Ask your question below. \"\n    puts \"Type 'quit' to exit the program.\\n\\n\"\n    @responses = [\"It is certain\", \"It is decidedly so\",\n                          \"Without a doubt\", \"Yes, definitely\",\n                          \"You may rely on it\", \"As I see it, yes\",\n                          \"Most likely\", \"Outlook good\",\n                          \"Signs point to yes\", \"Yes\",\n                          \"Reply hazy, try again\", \"Ask again later\",\n                          \"Better not tell you now\",\n                          \"Cannot predict now\",\n                          \"Concentrate and ask again\", \"Don't bet on it\",\n                          \"My reply is no\", \"My sources say no\",\n                          \"Outlook not so good\", \"Very doubtful\"]\n  end\n\n  def ask_question\n    print \"Question: \"\n    question = gets\n\n    if question.chomp.eql? \"quit\"\n      exit(0)\n    end\n\n    puts \"Response: \n  end\n\n  def run\n    loop do\n      ask_question\n    end\n  end\nend\n\neight_ball = EightBall.new\neight_ball.run\n", "target": "import random\n\ns = ('It is certain', 'It is decidedly so', 'Without a doubt', 'Yes, definitely',\n 'You may rely on it', 'As I see it, yes', 'Most likely', 'Outlook good',\n 'Signs point to yes', 'Yes', 'Reply hazy, try again', 'Ask again later',\n 'Better not tell you now', 'Cannot predict now', 'Concentrate and ask again',\n \"Don't bet on it\", 'My reply is no', 'My sources say no', 'Outlook not so good',\n 'Very doubtful')\n\nq_and_a = {}\n\nwhile True:\n    question = input('Ask your question:')\n    if len(question) == 0: break\n        \n    if question in q_and_a:\n        print('Your question has already been answered')\n    else:\n        answer = random.choice(s)\n        q_and_a[question] = answer\n        print(answer)\n"}
{"id": 336536, "name": "Validate International Securities Identification Number", "source": "Translate Ruby to Python: RE = /\\A[A-Z]{2}[A-Z0-9]{9}[0-9]{1}\\z/\n\ndef valid_isin?(str)\n  return false unless str =~ RE\n  luhn(str.chars.map{|c| c.to_i(36)}.join)\nend\n\np %w(US0378331005\nUS0373831005\nU50378331005\nUS03378331005\nAU0000XVGZA3\nAU0000VXGZA3\nFR0000988040).map{|tc| valid_isin?(tc) }\t \n \n\n", "target": "def check_isin(a):\n    if len(a) != 12 or not all(c.isalpha() for c in a[:2]) or not all(c.isalnum() for c in a[2:]):\n        return False\n    s = \"\".join(str(int(c, 36)) for c in a)\n    return 0 == (sum(sum(divmod(2 * (ord(c) - 48), 10)) for c in s[-2::-2]) +\n                 sum(ord(c) - 48 for c in s[::-2])) % 10\n\n\ndef check_isin_alt(a):\n    if len(a) != 12:\n        return False\n    s = []\n    for i, c in enumerate(a):\n        if c.isdigit():\n            if i < 2:\n                return False\n            s.append(ord(c) - 48)\n        elif c.isupper():\n            if i == 11:\n                return False\n            s += divmod(ord(c) - 55, 10)\n        else:\n            return False\n    v = sum(s[::-2])\n    for k in s[-2::-2]:\n        k = 2 * k\n        v += k - 9 if k > 9 else k\n    return v % 10 == 0\n\n[check_isin(s) for s in [\"US0378331005\", \"US0373831005\", \"U50378331005\", \"US03378331005\",\n                         \"AU0000XVGZA3\", \"AU0000VXGZA3\", \"FR0000988040\"]]\n\n\n"}
{"id": 336537, "name": "Orbital elements", "source": "Translate Ruby to Python: func orbital_state_vectors(\n    semimajor_axis,\n    eccentricity,\n    inclination,\n    longitude_of_ascending_node,\n    argument_of_periapsis,\n    true_anomaly\n) {\n\n    var (i, j, k) = (\n        Vector(1, 0, 0),\n        Vector(0, 1, 0),\n        Vector(0, 0, 1),\n    )\n\n    func muladd(v1, x1, v2, x2) {\n        (v1 * x1) + (v2 * x2)\n    }\n\n    func rotate(Ref i, Ref j, \u03b1) {\n        (*i, *j) = (\n            muladd(*i, +cos(\u03b1), *j, sin(\u03b1)),\n            muladd(*i, -sin(\u03b1), *j, cos(\u03b1)),\n        )\n    }\n\n    rotate(\\i, \\j, longitude_of_ascending_node)\n    rotate(\\j, \\k, inclination)\n    rotate(\\i, \\j, argument_of_periapsis)\n\n    var l = (eccentricity == 1 ? 2*semimajor_axis\n                               : semimajor_axis*(1 - eccentricity**2))\n\n    var (c, s) = with(true_anomaly) { (.cos, .sin) }\n\n    var r = l/(1 + eccentricity*c)\n    var rprime = (s * r**2 / l)\n    var position = muladd(i, c, j, s)*r\n\n    var speed = muladd(i, rprime*c - r*s, j, rprime*s + r*c)\n    speed /= speed.abs\n    speed *= sqrt(2/r - 1/semimajor_axis)\n\n    struct Result { position, speed }\n    Result(position, speed)\n}\n\nfor args in ([\n    [1, 0.1, 0, 355/(113*6), 0, 0],\n    [1, 0.1, Num.pi/18, Num.pi/6, Num.pi/4, 0]\n]) {\n    var r = orbital_state_vectors(args...)\n\n    say \"Arguments: \n    say \"Position\u00a0: \n    say \"Speed   \u00a0: \n}\n", "target": "import math\n\nclass Vector:\n    def __init__(self, x, y, z):\n        self.x = x\n        self.y = y\n        self.z = z\n\n    def __add__(self, other):\n        return Vector(self.x + other.x, self.y + other.y, self.z + other.z)\n\n    def __mul__(self, other):\n        return Vector(self.x * other, self.y * other, self.z * other)\n\n    def __div__(self, other):\n        return Vector(self.x / other, self.y / other, self.z / other)\n\n    def __str__(self):\n        return '({x}, {y}, {z})'.format(x=self.x, y=self.y, z=self.z)\n\n    def abs(self):\n        return math.sqrt(self.x*self.x + self.y*self.y + self.z*self.z)\n\ndef mulAdd(v1, x1, v2, x2):\n    return v1 * x1 + v2 * x2\n\ndef rotate(i, j, alpha):\n    return [mulAdd(i,math.cos(alpha),j,math.sin(alpha)), mulAdd(i,-math.sin(alpha),j,math.cos(alpha))]\n\ndef orbitalStateVectors(semimajorAxis, eccentricity, inclination, longitudeOfAscendingNode, argumentOfPeriapsis, trueAnomaly):\n    i = Vector(1, 0, 0)\n    j = Vector(0, 1, 0)\n    k = Vector(0, 0, 1)\n\n    p = rotate(i, j, longitudeOfAscendingNode)\n    i = p[0]\n    j = p[1]\n    p = rotate(j, k, inclination)\n    j = p[0]\n    p  =rotate(i, j, argumentOfPeriapsis)\n    i = p[0]\n    j = p[1]\n\n    l = 2.0 if (eccentricity == 1.0) else 1.0 - eccentricity * eccentricity\n    l *= semimajorAxis\n    c = math.cos(trueAnomaly)\n    s = math.sin(trueAnomaly)\n    r = 1 / (1.0 + eccentricity * c)\n    rprime = s * r * r / l\n    position = mulAdd(i, c, j, s) * r\n    speed = mulAdd(i, rprime * c - r * s, j, rprime * s + r * c)\n    speed = speed / speed.abs()\n    speed = speed * math.sqrt(2.0 / r - 1.0 / semimajorAxis)\n\n    return [position, speed]\n\nps = orbitalStateVectors(1.0, 0.1, 0.0, 355.0 / (113.0 * 6.0), 0.0, 0.0)\nprint \"Position\u00a0:\", ps[0]\nprint \"Speed   \u00a0:\", ps[1]\n"}
{"id": 336538, "name": "Cycle detection", "source": "Translate Ruby to Python: \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ndef findCycle(x0)\n  power = lambda = 1\n  tortoise = x0\n  hare = yield(x0)\n  \n  \n  while tortoise != hare\n    if power == lambda\n      tortoise = hare\n      power *= 2\n      lambda = 0\n    end\n    hare = yield(hare)\n    lambda += 1\n  end\n  \n  \n  hare = x0\n  lambda.times { hare = yield(hare) }\n  \n  tortoise, mu = x0, 0\n  while tortoise != hare\n    tortoise = yield(tortoise)\n    hare = yield(hare)\n    mu += 1\n  end\n  \n  return lambda, mu\nend\n\n\ndef f(x) (x * x + 1) % 255 end\n\n\nputs (1..40).reduce([3]){|acc,_| acc << f(acc.last)}.join(\",\")\n\n\nclength, cstart = findCycle(3) { |x| f(x) }\nputs \"Cycle length = \n", "target": "import itertools\n\ndef brent(f, x0):\n    \n    power = lam = 1\n    tortoise = x0\n    hare = f(x0)  \n    while tortoise != hare:\n        if power == lam:  \n            tortoise = hare\n            power *= 2\n            lam = 0\n        hare = f(hare)\n        lam += 1\n\n    \n    mu = 0\n    tortoise = hare = x0\n    for i in range(lam):\n    \n        hare = f(hare)\n    \n\n    \n    while tortoise != hare:\n        tortoise = f(tortoise)\n        hare = f(hare)\n        mu += 1\n \n    return lam, mu\n\ndef iterate(f, x0):\n    while True:\n        yield x0\n        x0 = f(x0)\n\nif __name__ == '__main__':\n    f = lambda x: (x * x + 1) % 255\n    x0 = 3\n    lam, mu = brent(f, x0)\n    print(\"Cycle length: %d\" % lam)\n    print(\"Cycle start index: %d\" % mu)\n    print(\"Cycle: %s\" % list(itertools.islice(iterate(f, x0), mu, mu+lam)))\n"}
{"id": 336539, "name": "Input_Output for pairs of numbers", "source": "Translate Ruby to Python: n = gets.to_i\nn.times do\n  a, b = gets.split.map(&:to_i)\n  puts a + b\nend\n", "target": "def do_stuff(a, b):\n\treturn a + b\n\nt = input()\nfor x in range(0, t):\n\ta, b = raw_input().strip().split()\n\tprint do_stuff(int(a), int(b))\n"}
{"id": 336540, "name": "Kahan summation", "source": "Translate Ruby to Python: epsilon = 1.0\nepsilon /= 2 until 1.0 + epsilon == 1.0\n\na = 1.0\nb = epsilon\nc = -b\n\nputs \"epsilon   \u00a0: \nputs \"(a+b)+c   \u00a0: \nputs \"[a,b,c].sum: \n", "target": "epsilon = 1.0\nwhile 1.0 + epsilon != 1.0:\n    epsilon = epsilon / 2.0\n"}
{"id": 336541, "name": "ABC words", "source": "Translate Ruby to Python: puts File.open(\"unixdict.txt\").grep(/^[^bc]*a[^c]*b.*c/)\n", "target": "python -c '\nimport sys\nfor ln in sys.stdin:\n    if \"a\" in ln and ln.find(\"a\") < ln.find(\"b\") < ln.find(\"c\"):\n        print(ln.rstrip())\n' < unixdict.txt\n"}
{"id": 336542, "name": "Text between", "source": "Translate Ruby to Python: class String\n  def textBetween startDelimiter, endDelimiter\n  \n  \tif (startDelimiter == \"start\") then\n  \t\tstartIndex = 0\n  \telse\n  \t\tstartIndex = self.index(startDelimiter) + startDelimiter.length\n  \tend\n  \t\n  \tif (startIndex == nil) then\n  \t\treturn \"Start delimiter not found\"\n  \tend\n  \t\n  \tthisLength = self.length\n  \t\n  \treturnText = self[startIndex, thisLength]\n  \t  \t\n \tif (endDelimiter == \"end\") then\n  \t\tendIndex = thisLength\n  \telse\n  \t\tendIndex = returnText.index(endDelimiter)\n  \tend\n  \t\n  \tif (endIndex == nil) then\n  \t\treturn \"End delimiter not found\"\n  \tend\n  \t  \t\n  \treturnText = returnText[0, endIndex]\n  \t\n  \treturn returnText\n  \n  end\nend\n\nthisText = ARGV[0]\nstartDelimiter = ARGV[1]\nendDelimiter = ARGV[2]\n\n\n\n\n\nreturnText = thisText.textBetween(startDelimiter, endDelimiter)\n\nputs returnText\n", "target": "\nfrom sys import argv\n\n\n\n\n\n\ndef textBetween( thisText, startString, endString ):\n    try:\n    \tif startString is 'start':\n    \t\tstartIndex = 0\n    \telse:\n    \t\tstartIndex = thisText.index( startString ) \n    \t\n    \tif not (startIndex >= 0):\n    \t\treturn 'Start delimiter not found'\n    \telse:\n        \tif startString is not 'start':\n        \t\tstartIndex = startIndex + len( startString )\n        \n        returnText = thisText[startIndex:]\n\n\n    \tif endString is 'end':\n    \t\treturn returnText\n    \telse:\n    \t\tendIndex = returnText.index( endString )\n\n    \tif not (endIndex >= 0):\n    \t\treturn 'End delimiter not found'\n    \telse:\n        \treturnText = returnText[:endIndex]\n\n        return returnText\n    except ValueError:\n        return \"Value error\"\n\nscript, first, second, third = argv\n\nthisText = first\nstartString = second\nendString = third\n\nprint textBetween( thisText, startString, endString )\n"}
{"id": 336543, "name": "Two identical strings", "source": "Translate Ruby to Python: (0..1000).each do |i|\n  bin = i.to_s(2)\n  if bin.size.even?\n    half = bin.size // 2\n    if bin[0..half-1] == bin[half..]\n      print \"%3d: %10s\\n\" % [i, bin]\n    end\n  end\nend\n", "target": "def bits(n):\n    \n    r = 0\n    while n:\n        n >>= 1\n        r += 1\n    return r\n    \ndef concat(n):\n    \n    return n << bits(n) | n\n    \nn = 1\nwhile concat(n) <= 1000:\n    print(\"{0}: {0:b}\".format(concat(n)))\n    n += 1\n"}
{"id": 336544, "name": "Sum of first n cubes", "source": "Translate Ruby to Python: sum = 0\n(0...50).each do |n|\n  print (sum += n**3).to_s.ljust(10)\n  puts \"\" if (n+1) % 10 == 0\nend\n", "target": "def main():\n    fila = 0\n    lenCubos = 51\n\n    print(\"Suma de N cubos para n = [0..49]\\n\")\n\n    for n in range(1, lenCubos):\n        sumCubos = 0\n        for m in range(1, n):\n            sumCubos = sumCubos + (m ** 3)\n            \n        fila += 1\n        print(f'{sumCubos:7} ', end='')\n        if fila % 5 == 0:\n            print(\" \")\n\n    print(f\"\\nEncontrados {fila} cubos.\")\n\nif __name__ == '__main__': main()\n"}
{"id": 336545, "name": "Pentagram", "source": "Translate Ruby to Python: func pentagram(dim=200, sides=5) {\n    var pentagram = <<-EOT\n    <?xml version=\"1.0\" standalone=\"no\"\u00a0?>\n    <!DOCTYPE svg PUBLIC \"-//W3C//DTD SVG 1.0//EN\"\n    \"http://www.w3.org/TR/2001/PR-SVG-20010719/DTD/svg10.dtd\">\n    <svg height=\"\n    <rect height=\"100%\" width=\"100%\" style=\"fill:black;\" />\n    EOT\n\n    func cis(x) {\n        cos(x) + sin(x).i\n    }\n\n    func pline(q) {\n        <<-EOT\n        <polyline points=\"\n        style=\"fill:blue; stroke:white; stroke-width:3;\"\n        transform=\"translate(\n        EOT\n    }\n\n    var v = sides.range.map {|k| 0.9 * dim * cis(k * Num.tau / sides) }\n    pentagram += pline([v[range(0, v.end, 2)], v[range(1, v.end, 2)]].map{.reals})\n    pentagram += '</svg>'\n\n    return pentagram\n}\n\nsay pentagram()\n", "target": "import turtle\n\nturtle.bgcolor(\"green\")\nt = turtle.Turtle()\nt.color(\"red\", \"blue\")\nt.begin_fill()\nfor i in range(0, 5):\n    t.forward(200)\n    t.right(144)\nt.end_fill()\n"}
{"id": 336546, "name": "Pentagram", "source": "Translate Ruby to Python: func pentagram(dim=200, sides=5) {\n    var pentagram = <<-EOT\n    <?xml version=\"1.0\" standalone=\"no\"\u00a0?>\n    <!DOCTYPE svg PUBLIC \"-//W3C//DTD SVG 1.0//EN\"\n    \"http://www.w3.org/TR/2001/PR-SVG-20010719/DTD/svg10.dtd\">\n    <svg height=\"\n    <rect height=\"100%\" width=\"100%\" style=\"fill:black;\" />\n    EOT\n\n    func cis(x) {\n        cos(x) + sin(x).i\n    }\n\n    func pline(q) {\n        <<-EOT\n        <polyline points=\"\n        style=\"fill:blue; stroke:white; stroke-width:3;\"\n        transform=\"translate(\n        EOT\n    }\n\n    var v = sides.range.map {|k| 0.9 * dim * cis(k * Num.tau / sides) }\n    pentagram += pline([v[range(0, v.end, 2)], v[range(1, v.end, 2)]].map{.reals})\n    pentagram += '</svg>'\n\n    return pentagram\n}\n\nsay pentagram()\n", "target": "import turtle\n\nturtle.bgcolor(\"green\")\nt = turtle.Turtle()\nt.color(\"red\", \"blue\")\nt.begin_fill()\nfor i in range(0, 5):\n    t.forward(200)\n    t.right(144)\nt.end_fill()\n"}
{"id": 336547, "name": "Median filter", "source": "Translate Ruby to Python: class Pixmap\n  def median_filter(radius=3)\n    radius += 1 if radius.even?\n    filtered = self.class.new(@width, @height)\n    pb = ProgressBar.new(@height) if $DEBUG\n    @height.times do |y|\n      @width.times do |x|\n        window = []\n        (x - radius).upto(x + radius).each do |win_x|\n          (y - radius).upto(y + radius).each do |win_y|\n            win_x = 0 if win_x < 0\n            win_y = 0 if win_y < 0\n            win_x = @width-1 if win_x >= @width\n            win_y = @height-1 if win_y >= @height\n            window << self[win_x, win_y]\n          end\n        end\n        \n        filtered[x, y] = window.sort[window.length / 2]\n      end\n      pb.update(y) if $DEBUG\n    end\n    pb.close if $DEBUG\n    filtered\n  end\nend\n\nclass RGBColour\n  \n  def luminosity\n    Integer(0.2126*@red + 0.7152*@green + 0.0722*@blue)\n  end\n  def to_grayscale\n    l = luminosity\n    self.class.new(l, l, l)\n  end\n\n  \n  def <=>(other)\n    self.luminosity <=> other.luminosity\n  end\nend\n\nclass ProgressBar\n  def initialize(max)\n    $stdout.sync = true\n    @progress_max = max\n    @progress_pos = 0\n    @progress_view = 68\n    $stdout.print \"[\n  end\n\n  def update(n)\n    new_pos = n * @progress_view/@progress_max\n    if new_pos > @progress_pos\n      @progress_pos = new_pos \n      $stdout.print '='\n    end\n  end\n\n  def close\n    $stdout.puts '=]'\n  end\nend\n\nbitmap = Pixmap.open('file')\nfiltered = bitmap.median_filter\n", "target": "import Image, ImageFilter\nim = Image.open('image.ppm')\n\nmedian = im.filter(ImageFilter.MedianFilter(3))\nmedian.save('image2.ppm')\n"}
{"id": 336548, "name": "Verify distribution uniformity_Chi-squared test", "source": "Translate Ruby to Python: def gammaInc_Q(a, x)\n  a1, a2 = a-1, a-2\n  f0  = lambda {|t| t**a1 * Math.exp(-t)}\n  df0 = lambda {|t| (a1-t) * t**a2 * Math.exp(-t)}\n  \n  y = a1\n  y += 0.3  while f0[y]*(x-y) > 2.0e-8 and y < x\n  y = x  if y > x\n  \n  h = 3.0e-4\n  n = (y/h).to_i\n  h = y/n\n  hh = 0.5 * h\n  sum = 0\n  (n-1).step(0, -1) do |j|\n    t = h * j\n    sum += f0[t] + hh * df0[t]\n  end\n  h * sum / gamma_spounge(a)\nend\n\nA = 12\nk1_factrl = 1.0\ncoef = [Math.sqrt(2.0*Math::PI)]\nCOEF = (1...A).each_with_object(coef) do |k,c|\n  c << Math.exp(A-k) * (A-k)**(k-0.5) / k1_factrl\n  k1_factrl *= -k\nend\n\ndef gamma_spounge(z)\n  accm = (1...A).inject(COEF[0]){|res,k| res += COEF[k] / (z+k)}\n  accm * Math.exp(-(z+A)) * (z+A)**(z+0.5) / z\nend\n\ndef chi2UniformDistance(dataSet)\n  expected = dataSet.inject(:+).to_f / dataSet.size\n  dataSet.map{|d|(d-expected)**2}.inject(:+) / expected\nend\n\ndef chi2Probability(dof, distance)\n  1.0 - gammaInc_Q(0.5*dof, 0.5*distance)\nend\n\ndef chi2IsUniform(dataSet, significance=0.05)\n  dof = dataSet.size - 1\n  dist = chi2UniformDistance(dataSet)\n  chi2Probability(dof, dist) > significance\nend\n\ndsets = [ [ 199809, 200665, 199607, 200270, 199649 ],\n          [ 522573, 244456, 139979,  71531,  21461 ] ]\n\nfor ds in dsets\n  puts \"Data set:\n  dof = ds.size - 1\n  puts \"  degrees of freedom: %d\" % dof\n  distance = chi2UniformDistance(ds)\n  puts \"  distance:          \u00a0%.4f\" % distance\n  puts \"  probability:       \u00a0%.4f\" % chi2Probability(dof, distance)\n  puts \"  uniform?            %s\" % (chi2IsUniform(ds) ? \"Yes\" : \"No\")\nend\n", "target": "import math\nimport random\n\ndef GammaInc_Q( a, x):\n    a1 = a-1\n    a2 = a-2\n    def f0( t ):\n        return t**a1*math.exp(-t)\n\n    def df0(t):\n        return (a1-t)*t**a2*math.exp(-t)\n    \n    y = a1\n    while f0(y)*(x-y) >2.0e-8 and y < x: y += .3\n    if y > x: y = x\n\n    h = 3.0e-4\n    n = int(y/h)\n    h = y/n\n    hh = 0.5*h\n    gamax = h * sum( f0(t)+hh*df0(t) for t in ( h*j for j in xrange(n-1, -1, -1)))\n\n    return gamax/gamma_spounge(a)\n\nc = None\ndef gamma_spounge( z):\n    global c\n    a = 12\n\n    if c is None:\n       k1_factrl = 1.0\n       c = []\n       c.append(math.sqrt(2.0*math.pi))\n       for k in range(1,a):\n          c.append( math.exp(a-k) * (a-k)**(k-0.5) / k1_factrl )\n          k1_factrl *= -k\n    \n    accm = c[0]\n    for k in range(1,a):\n        accm += c[k] / (z+k)\n    accm *= math.exp( -(z+a)) * (z+a)**(z+0.5)\n    return accm/z;\n\ndef chi2UniformDistance( dataSet ):\n    expected = sum(dataSet)*1.0/len(dataSet)\n    cntrd = (d-expected for d in dataSet)\n    return sum(x*x for x in cntrd)/expected\n\ndef chi2Probability(dof, distance):\n    return 1.0 - GammaInc_Q( 0.5*dof, 0.5*distance)\n\ndef chi2IsUniform(dataSet, significance):\n    dof = len(dataSet)-1\n    dist = chi2UniformDistance(dataSet)\n    return chi2Probability( dof, dist ) > significance\n\ndset1 = [ 199809, 200665, 199607, 200270, 199649 ]\ndset2 = [ 522573, 244456, 139979,  71531,  21461 ]\n\nfor ds in (dset1, dset2):\n    print \"Data set:\", ds\n    dof = len(ds)-1\n    distance =chi2UniformDistance(ds)\n    print \"dof: %d distance: %.4f\" % (dof, distance),\n    prob = chi2Probability( dof, distance)\n    print \"probability: %.4f\"%prob,\n    print \"uniform? \", \"Yes\"if chi2IsUniform(ds,0.05) else \"No\"\n"}
{"id": 336549, "name": "CSV to HTML translation", "source": "Translate Ruby to Python: require 'cgi'\n\nputs '<table summary=\"csv2html program output\">'\n\ndef row2html str, wrap = \"td\"\n  \"<tr>\" +\n    str.split(\",\").map { |cell| \"<\n  \"</tr>\"\nend\n\nputs row2html gets.chomp, \"th\" if ARGV.delete \"header\"\n\nwhile str = gets\n  puts row2html str.chomp\nend\n\nputs \"</table>\"\n", "target": "csvtxt = \n\nfrom cgi import escape\n\ndef _row2tr(row, attr=None):\n    cols = escape(row).split(',')\n    return ('<TR>'\n            + ''.join('<TD>%s</TD>' % data for data in cols)\n            + '</TR>')\n\ndef csv2html(txt):\n    htmltxt = '<TABLE summary=\"csv2html program output\">\\n'\n    for rownum, row in enumerate(txt.split('\\n')):\n        htmlrow = _row2tr(row)\n        htmlrow = '  <TBODY>%s</TBODY>\\n' % htmlrow\n        htmltxt += htmlrow\n    htmltxt += '</TABLE>\\n'\n    return htmltxt\n\nhtmltxt = csv2html(csvtxt)\nprint(htmltxt)\n"}
{"id": 336550, "name": "CSV to HTML translation", "source": "Translate Ruby to Python: require 'cgi'\n\nputs '<table summary=\"csv2html program output\">'\n\ndef row2html str, wrap = \"td\"\n  \"<tr>\" +\n    str.split(\",\").map { |cell| \"<\n  \"</tr>\"\nend\n\nputs row2html gets.chomp, \"th\" if ARGV.delete \"header\"\n\nwhile str = gets\n  puts row2html str.chomp\nend\n\nputs \"</table>\"\n", "target": "csvtxt = \n\nfrom cgi import escape\n\ndef _row2tr(row, attr=None):\n    cols = escape(row).split(',')\n    return ('<TR>'\n            + ''.join('<TD>%s</TD>' % data for data in cols)\n            + '</TR>')\n\ndef csv2html(txt):\n    htmltxt = '<TABLE summary=\"csv2html program output\">\\n'\n    for rownum, row in enumerate(txt.split('\\n')):\n        htmlrow = _row2tr(row)\n        htmlrow = '  <TBODY>%s</TBODY>\\n' % htmlrow\n        htmltxt += htmlrow\n    htmltxt += '</TABLE>\\n'\n    return htmltxt\n\nhtmltxt = csv2html(csvtxt)\nprint(htmltxt)\n"}
{"id": 336551, "name": "Alternade words", "source": "Translate Ruby to Python: words = File.open(\"unixdict.txt\").map(&:chomp)\n\nres = words.filter_map do |word|\n  next if word.size < 6\n  splitted = word.each_char.partition.with_index{|_,i| i.even? }.map(&:join)\n  next unless splitted.all?{|split| words.bsearch{|w| split <=> w} }\n  \"\nend\n\nputs res\n", "target": "WORDFILE = 'unixdict.txt'\nMINLEN = 6\n\nclass Trie(object):\n    \n    class Node(object):\n        \n        def __init__(self, char='\\0', parent=None):\n            self.children = {}\n            self.char = char\n            self.final = False\n            self.parent = parent\n            \n        def descend(self, char, extend=False):\n            \n            if not char in self.children:\n                if not extend: return None\n                self.children[char] = Trie.Node(char,self)\n            return self.children[char]\n        \n    def __init__(self):\n        self.root = Trie.Node()\n    \n    def insert(self, word):\n        \n        node = self.root\n        for char in word: node = node.descend(char, extend=True)\n        node.final = True\n        return node\n    \n    def __contains__(self, word):\n        \n        node = self.root\n        for char in word:\n            node = node.descend(char)\n            if not node: return False\n        return node.final \n    \n    def words(self):\n        \n        nodes = [self.root]\n        while nodes:\n            node = nodes.pop()\n            nodes += node.children.values()\n            if node.final:\n                word = []\n                while node:\n                    if node.char != '\\0': word.append(node.char)\n                    node = node.parent\n                yield \"\".join(reversed(word))\n    \n    def __iter__(self):\n        return self.words()\n                \n\nwords = Trie()\nwith open(WORDFILE, \"rt\") as f:\n    for word in f.readlines():\n        words.insert(word.strip())\n\nfor word in words:\n    if len(word) < MINLEN: continue\n    even = word[::2]\n    odd = word[1::2]\n    if even in words and odd in words:\n        print(word, even, odd)\n"}
{"id": 336552, "name": "Alternade words", "source": "Translate Ruby to Python: words = File.open(\"unixdict.txt\").map(&:chomp)\n\nres = words.filter_map do |word|\n  next if word.size < 6\n  splitted = word.each_char.partition.with_index{|_,i| i.even? }.map(&:join)\n  next unless splitted.all?{|split| words.bsearch{|w| split <=> w} }\n  \"\nend\n\nputs res\n", "target": "WORDFILE = 'unixdict.txt'\nMINLEN = 6\n\nclass Trie(object):\n    \n    class Node(object):\n        \n        def __init__(self, char='\\0', parent=None):\n            self.children = {}\n            self.char = char\n            self.final = False\n            self.parent = parent\n            \n        def descend(self, char, extend=False):\n            \n            if not char in self.children:\n                if not extend: return None\n                self.children[char] = Trie.Node(char,self)\n            return self.children[char]\n        \n    def __init__(self):\n        self.root = Trie.Node()\n    \n    def insert(self, word):\n        \n        node = self.root\n        for char in word: node = node.descend(char, extend=True)\n        node.final = True\n        return node\n    \n    def __contains__(self, word):\n        \n        node = self.root\n        for char in word:\n            node = node.descend(char)\n            if not node: return False\n        return node.final \n    \n    def words(self):\n        \n        nodes = [self.root]\n        while nodes:\n            node = nodes.pop()\n            nodes += node.children.values()\n            if node.final:\n                word = []\n                while node:\n                    if node.char != '\\0': word.append(node.char)\n                    node = node.parent\n                yield \"\".join(reversed(word))\n    \n    def __iter__(self):\n        return self.words()\n                \n\nwords = Trie()\nwith open(WORDFILE, \"rt\") as f:\n    for word in f.readlines():\n        words.insert(word.strip())\n\nfor word in words:\n    if len(word) < MINLEN: continue\n    even = word[::2]\n    odd = word[1::2]\n    if even in words and odd in words:\n        print(word, even, odd)\n"}
{"id": 336553, "name": "Count how many vowels and consonants occur in a string", "source": "Translate Ruby to Python: RE_V = /[aeiou]/\nRE_C = /[bcdfghjklmnpqrstvwxyz]/\nstr  = \"Now is the time for all good men to come to the aid of their country.\"\n\ngrouped = str.downcase.chars.group_by do |c|\n  case c\n    when RE_V then :Vowels\n    when RE_C then :Consonants\n    else :Other\n  end\nend\n\ngrouped.each{|k,v| puts \"\n", "target": "def isvowel(c):\n    \n    return c in ['a', 'e', 'i', 'o', 'u', 'A', 'E', \"I\", 'O', 'U']\n\ndef isletter(c):\n    \n    return 'a' <= c <= 'z' or 'A' <= c <= 'Z'\n\ndef isconsonant(c):\n    \n    return  not isvowel(c) and isletter(c)\n\ndef vccounts(s):\n    \n    a = list(s.lower())\n    au = set(a)\n    return sum([isvowel(c) for c in a]), sum([isconsonant(c) for c in a]), \\\n        sum([isvowel(c) for c in au]), sum([isconsonant(c) for c in au])\n\ndef testvccount():\n    teststrings = [\n        \"Forever Python programming language\",\n        \"Now is the time for all good men to come to the aid of their country.\"]\n    for s in teststrings:\n        vcnt, ccnt, vu, cu = vccounts(s)\n        print(f\"String: {s}\\n    Vowels: {vcnt} (distinct {vu})\\n    Consonants: {ccnt} (distinct {cu})\\n\")\n\ntestvccount()\n"}
{"id": 336554, "name": "Pythagorean triples", "source": "Translate Ruby to Python: class PythagoranTriplesCounter\n  def initialize(limit = 0)\n    @limit = limit\n    @total = 0\n    @primitives = 0\n    generate_triples(3, 4, 5)\n  end\n\n  def total; @total end\n  def primitives; @primitives end\n \n  private def generate_triples(a, b, c)\n    perim = a + b + c\n    return if perim > @limit\n \n    @primitives += 1\n    @total += @limit // perim\n \n    generate_triples( a-2*b+2*c, 2*a-b+2*c, 2*a-2*b+3*c )\n    generate_triples( a+2*b+2*c, 2*a+b+2*c, 2*a+2*b+3*c )\n    generate_triples(-a+2*b+2*c,-2*a+b+2*c,-2*a+2*b+3*c )\n  end\nend\n \nperim = 10\nwhile perim <= 100_000_000 \n  c = PythagoranTriplesCounter.new perim\n  p [perim, c.total, c.primitives]\n  perim *= 10\nend\n", "target": "from fractions import gcd\n\n\ndef pt1(maxperimeter=100):\n    \n    trips = []\n    for a in range(1, maxperimeter):\n        aa = a*a\n        for b in range(a, maxperimeter-a+1):\n            bb = b*b\n            for c in range(b, maxperimeter-b-a+1):\n                cc = c*c\n                if a+b+c > maxperimeter or cc > aa + bb: break\n                if aa + bb == cc:\n                    trips.append((a,b,c, gcd(a, b) == 1))\n    return trips\n\ndef pytrip(trip=(3,4,5),perim=100, prim=1):\n    a0, b0, c0 = a, b, c = sorted(trip)\n    t, firstprim = set(), prim>0\n    while a + b + c <= perim:\n        t.add((a, b, c, firstprim>0))\n        a, b, c, firstprim = a+a0, b+b0, c+c0, False\n    \n    t2 = set()\n    for a, b, c, firstprim in t:\n        a2, a5, b2, b5, c2, c3, c7 = a*2, a*5, b*2, b*5, c*2, c*3, c*7\n        if  a5 - b5 + c7 <= perim:\n            t2 |= pytrip(( a - b2 + c2,  a2 - b + c2,  a2 - b2 + c3), perim, firstprim)\n        if  a5 + b5 + c7 <= perim:\n            t2 |= pytrip(( a + b2 + c2,  a2 + b + c2,  a2 + b2 + c3), perim, firstprim)\n        if -a5 + b5 + c7 <= perim:\n            t2 |= pytrip((-a + b2 + c2, -a2 + b + c2, -a2 + b2 + c3), perim, firstprim)\n    return t | t2\n\ndef pt2(maxperimeter=100):\n    \n    trips = pytrip((3,4,5), maxperimeter, 1)\n    return trips\n\ndef printit(maxperimeter=100, pt=pt1):\n    trips = pt(maxperimeter)\n    print(\"  Up to a perimeter of %i there are %i triples, of which %i are primitive\"\n          % (maxperimeter,\n             len(trips),\n             len([prim for a,b,c,prim in trips if prim])))\n  \nfor algo, mn, mx in ((pt1, 250, 2500), (pt2, 500, 20000)):\n    print(algo.__doc__)\n    for maxperimeter in range(mn, mx+1, mn):\n        printit(maxperimeter, algo)\n"}
{"id": 336555, "name": "Pythagorean triples", "source": "Translate Ruby to Python: class PythagoranTriplesCounter\n  def initialize(limit = 0)\n    @limit = limit\n    @total = 0\n    @primitives = 0\n    generate_triples(3, 4, 5)\n  end\n\n  def total; @total end\n  def primitives; @primitives end\n \n  private def generate_triples(a, b, c)\n    perim = a + b + c\n    return if perim > @limit\n \n    @primitives += 1\n    @total += @limit // perim\n \n    generate_triples( a-2*b+2*c, 2*a-b+2*c, 2*a-2*b+3*c )\n    generate_triples( a+2*b+2*c, 2*a+b+2*c, 2*a+2*b+3*c )\n    generate_triples(-a+2*b+2*c,-2*a+b+2*c,-2*a+2*b+3*c )\n  end\nend\n \nperim = 10\nwhile perim <= 100_000_000 \n  c = PythagoranTriplesCounter.new perim\n  p [perim, c.total, c.primitives]\n  perim *= 10\nend\n", "target": "from fractions import gcd\n\n\ndef pt1(maxperimeter=100):\n    \n    trips = []\n    for a in range(1, maxperimeter):\n        aa = a*a\n        for b in range(a, maxperimeter-a+1):\n            bb = b*b\n            for c in range(b, maxperimeter-b-a+1):\n                cc = c*c\n                if a+b+c > maxperimeter or cc > aa + bb: break\n                if aa + bb == cc:\n                    trips.append((a,b,c, gcd(a, b) == 1))\n    return trips\n\ndef pytrip(trip=(3,4,5),perim=100, prim=1):\n    a0, b0, c0 = a, b, c = sorted(trip)\n    t, firstprim = set(), prim>0\n    while a + b + c <= perim:\n        t.add((a, b, c, firstprim>0))\n        a, b, c, firstprim = a+a0, b+b0, c+c0, False\n    \n    t2 = set()\n    for a, b, c, firstprim in t:\n        a2, a5, b2, b5, c2, c3, c7 = a*2, a*5, b*2, b*5, c*2, c*3, c*7\n        if  a5 - b5 + c7 <= perim:\n            t2 |= pytrip(( a - b2 + c2,  a2 - b + c2,  a2 - b2 + c3), perim, firstprim)\n        if  a5 + b5 + c7 <= perim:\n            t2 |= pytrip(( a + b2 + c2,  a2 + b + c2,  a2 + b2 + c3), perim, firstprim)\n        if -a5 + b5 + c7 <= perim:\n            t2 |= pytrip((-a + b2 + c2, -a2 + b + c2, -a2 + b2 + c3), perim, firstprim)\n    return t | t2\n\ndef pt2(maxperimeter=100):\n    \n    trips = pytrip((3,4,5), maxperimeter, 1)\n    return trips\n\ndef printit(maxperimeter=100, pt=pt1):\n    trips = pt(maxperimeter)\n    print(\"  Up to a perimeter of %i there are %i triples, of which %i are primitive\"\n          % (maxperimeter,\n             len(trips),\n             len([prim for a,b,c,prim in trips if prim])))\n  \nfor algo, mn, mx in ((pt1, 250, 2500), (pt2, 500, 20000)):\n    print(algo.__doc__)\n    for maxperimeter in range(mn, mx+1, mn):\n        printit(maxperimeter, algo)\n"}
{"id": 336556, "name": "Call a foreign-language function", "source": "Translate Ruby to Python: @[Link(\"c\")] \nlib LibC\n  fun free(ptr : Void*) : Void \n  fun strdup(ptr : Char*) : Char*\nend\n\ns1 = \"Hello World!\"\np = LibC.strdup(s1) \ns2 = String.new(p)\nLibC.free p \n\nputs s2\n", "target": "import ctypes\nlibc = ctypes.CDLL(\"/lib/libc.so.6\")\nlibc.strcmp(\"abc\", \"def\")     \nlibc.strcmp(\"hello\", \"hello\") \n"}
{"id": 336557, "name": "Yellowstone sequence", "source": "Translate Ruby to Python: def yellow(n)\n  a = [1, 2, 3]\n  b = { 1 => true, 2 => true, 3 => true }\n  i = 4\n  while n > a.length\n    if !b[i] && i.gcd(a[-1]) == 1 && i.gcd(a[-2]) > 1\n      a << i\n      b[i] = true\n      i = 4\n    end\n    i += 1\n  end\n  a\nend\n\np yellow(30)\n", "target": "\n\nfrom itertools import chain, count, islice\nfrom operator import itemgetter\nfrom math import gcd\n\nfrom matplotlib import pyplot\n\n\n\ndef yellowstone():\n    \n    \n    def relativelyPrime(a):\n        return lambda b: 1 == gcd(a, b)\n\n    \n    def nextWindow(triple):\n        p2, p1, rest = triple\n        [rp2, rp1] = map(relativelyPrime, [p2, p1])\n\n        \n        def match(xxs):\n            x, xs = uncons(xxs)['Just']\n            return (x, xs) if rp1(x) and not rp2(x) else (\n                second(cons(x))(\n                    match(xs)\n                )\n            )\n        n, residue = match(rest)\n        return (p1, n, residue)\n\n    return chain(\n        range(1, 3),\n        map(\n            itemgetter(1),\n            iterate(nextWindow)(\n                (2, 3, count(4))\n            )\n        )\n    )\n\n\n\n\ndef main():\n    \n\n    print(showList(\n        take(30)(yellowstone())\n    ))\n    pyplot.plot(\n        take(100)(yellowstone())\n    )\n    pyplot.xlabel(main.__doc__)\n    pyplot.show()\n\n\n\n\n\ndef Just(x):\n    \n    return {'type': 'Maybe', 'Nothing': False, 'Just': x}\n\n\n\ndef Nothing():\n    \n    return {'type': 'Maybe', 'Nothing': True}\n\n\n\ndef cons(x):\n    \n    return lambda xs: [x] + xs if (\n        isinstance(xs, list)\n    ) else x + xs if (\n        isinstance(xs, str)\n    ) else chain([x], xs)\n\n\n\ndef iterate(f):\n    \n    def go(x):\n        v = x\n        while True:\n            yield v\n            v = f(v)\n    return go\n\n\n\ndef second(f):\n    \n    return lambda xy: (xy[0], f(xy[1]))\n\n\n\ndef showList(xs):\n    \n    return '[' + ','.join(repr(x) for x in xs) + ']'\n\n\n\n\ndef take(n):\n    \n    return lambda xs: (\n        xs[0:n]\n        if isinstance(xs, (list, tuple))\n        else list(islice(xs, n))\n    )\n\n\n\ndef uncons(xs):\n    \n    if isinstance(xs, list):\n        return Just((xs[0], xs[1:])) if xs else Nothing()\n    else:\n        nxt = take(1)(xs)\n        return Just((nxt[0], xs)) if nxt else Nothing()\n\n\n\nif __name__ == '__main__':\n    main()\n"}
{"id": 336558, "name": "Yellowstone sequence", "source": "Translate Ruby to Python: def yellow(n)\n  a = [1, 2, 3]\n  b = { 1 => true, 2 => true, 3 => true }\n  i = 4\n  while n > a.length\n    if !b[i] && i.gcd(a[-1]) == 1 && i.gcd(a[-2]) > 1\n      a << i\n      b[i] = true\n      i = 4\n    end\n    i += 1\n  end\n  a\nend\n\np yellow(30)\n", "target": "\n\nfrom itertools import chain, count, islice\nfrom operator import itemgetter\nfrom math import gcd\n\nfrom matplotlib import pyplot\n\n\n\ndef yellowstone():\n    \n    \n    def relativelyPrime(a):\n        return lambda b: 1 == gcd(a, b)\n\n    \n    def nextWindow(triple):\n        p2, p1, rest = triple\n        [rp2, rp1] = map(relativelyPrime, [p2, p1])\n\n        \n        def match(xxs):\n            x, xs = uncons(xxs)['Just']\n            return (x, xs) if rp1(x) and not rp2(x) else (\n                second(cons(x))(\n                    match(xs)\n                )\n            )\n        n, residue = match(rest)\n        return (p1, n, residue)\n\n    return chain(\n        range(1, 3),\n        map(\n            itemgetter(1),\n            iterate(nextWindow)(\n                (2, 3, count(4))\n            )\n        )\n    )\n\n\n\n\ndef main():\n    \n\n    print(showList(\n        take(30)(yellowstone())\n    ))\n    pyplot.plot(\n        take(100)(yellowstone())\n    )\n    pyplot.xlabel(main.__doc__)\n    pyplot.show()\n\n\n\n\n\ndef Just(x):\n    \n    return {'type': 'Maybe', 'Nothing': False, 'Just': x}\n\n\n\ndef Nothing():\n    \n    return {'type': 'Maybe', 'Nothing': True}\n\n\n\ndef cons(x):\n    \n    return lambda xs: [x] + xs if (\n        isinstance(xs, list)\n    ) else x + xs if (\n        isinstance(xs, str)\n    ) else chain([x], xs)\n\n\n\ndef iterate(f):\n    \n    def go(x):\n        v = x\n        while True:\n            yield v\n            v = f(v)\n    return go\n\n\n\ndef second(f):\n    \n    return lambda xy: (xy[0], f(xy[1]))\n\n\n\ndef showList(xs):\n    \n    return '[' + ','.join(repr(x) for x in xs) + ']'\n\n\n\n\ndef take(n):\n    \n    return lambda xs: (\n        xs[0:n]\n        if isinstance(xs, (list, tuple))\n        else list(islice(xs, n))\n    )\n\n\n\ndef uncons(xs):\n    \n    if isinstance(xs, list):\n        return Just((xs[0], xs[1:])) if xs else Nothing()\n    else:\n        nxt = take(1)(xs)\n        return Just((nxt[0], xs)) if nxt else Nothing()\n\n\n\nif __name__ == '__main__':\n    main()\n"}
{"id": 336559, "name": "Sorting algorithms_Patience sort", "source": "Translate Ruby to Python: class Array\n  def patience_sort\n    piles = []\n    each do |i|\n      if (idx = piles.index{|pile| pile.last <= i})\n        piles[idx] << i\n      else\n        piles << [i]    \n      end\n    end\n    \n    result = []\n    until piles.empty?\n      first = piles.map(&:first)\n      idx = first.index(first.min)\n      result << piles[idx].shift\n      piles.delete_at(idx) if piles[idx].empty?\n    end\n    result\n  end\nend\n\na = [4, 65, 2, -31, 0, 99, 83, 782, 1]\np a.patience_sort\n", "target": "from functools import total_ordering\nfrom bisect import bisect_left\nfrom heapq import merge\n\n@total_ordering\nclass Pile(list):\n    def __lt__(self, other): return self[-1] < other[-1]\n    def __eq__(self, other): return self[-1] == other[-1]\n\ndef patience_sort(n):\n    piles = []\n    \n    for x in n:\n        new_pile = Pile([x])\n        i = bisect_left(piles, new_pile)\n        if i != len(piles):\n            piles[i].append(x)\n        else:\n            piles.append(new_pile)\n\n    \n    n[:] = merge(*[reversed(pile) for pile in piles])\n\nif __name__ == \"__main__\":\n    a = [4, 65, 2, -31, 0, 99, 83, 782, 1]\n    patience_sort(a)\n    print a\n"}
{"id": 336560, "name": "Extensible prime generator", "source": "Translate Ruby to Python: require \"prime\"\n\nputs Prime.take(20).join(\", \")\nputs Prime.each(150).drop_while{|pr| pr < 100}.join(\", \")\nputs Prime.each(8000).drop_while{|pr| pr < 7700}.count\nputs Prime.take(10_000).last\n", "target": "islice(count(7), 0, None, 2)\n"}
{"id": 336561, "name": "Flipping bits game", "source": "Translate Ruby to Python: class FlipBoard\n  def initialize(size)\n    raise ArgumentError.new(\"Invalid board size: \n    \n    @size = size\n    @board = Array.new(size**2, 0)\n    \n    randomize_board\n    loop do\n      @target = generate_target\n      break unless solved?\n    end \n    \n    \n    @columns = [*'a'...('a'.ord+@size).chr]\n    @rows = (1..@size).map(&:to_s)\n  end\n  \n  \n  \n  def play\n    moves = 0\n    puts \"your target:\", target\n    \n    until solved? \n      puts \"\", \"move \n      print \"Row/column to flip: \"\n      ans = $stdin.gets.strip\n      \n      if @columns.include? ans\n        flip_column @columns.index(ans)\n        moves += 1\n      elsif @rows.include? ans\n        flip_row @rows.index(ans)\n        moves += 1\n      else\n        puts \"invalid input: \" + ans\n      end\n    end\n    \n    puts \"\", \"you solved the game in \n  end\n  \n  \n  def target\n    format_array @target\n  end\n  \n  \n  def to_s\n    format_array @board\n  end\n  \n  \n  private\n  \n  def solved?\n    @board == @target\n  end\n  \n  \n  def randomize_board\n    (@size + rand(@size)).times do\n      flip_bit rand(@size), rand(@size)\n    end\n  end\n  \n  \n  def generate_target\n    orig_board = @board.clone\n    (@size + rand(@size)).times do \n      rand(2).zero? ? flip_row( rand(@size) ) : flip_column( rand(@size) )\n    end\n    target, @board = @board, orig_board\n    target\n  end\n  \n  def flip_row(row)\n    @size.times {|col| flip_bit(row, col)}\n  end\n  \n  def flip_column(col)\n    @size.times {|row| flip_bit(row, col)}\n  end\n  \n  def flip_bit(row, col)\n    @board[@size * row + col] ^= 1\n  end\n  \n  def format_array(ary)\n    str = \"   \" + @columns.join(\" \") + \"\\n\"\n    @size.times do |row|\n      str << \"%2s \" % @rows[row] + ary[@size*row, @size].join(\" \") + \"\\n\"\n    end\n    str\n  end\nend\n\n\nbegin\n  FlipBoard.new(ARGV.shift.to_i).play\nrescue => e\n  puts e.message\nend\n", "target": "\n\nfrom random import randrange\nfrom copy import deepcopy\nfrom string import ascii_lowercase\n\n\ntry:    \n    input = raw_input\nexcept:\n    pass\n\nN = 3   \n\nboard  = [[0]* N for i in range(N)]\n\ndef setbits(board, count=1):\n    for i in range(count):\n        board[randrange(N)][randrange(N)] ^= 1\n\ndef shuffle(board, count=1):\n    for i in range(count):\n        if randrange(0, 2):\n            fliprow(randrange(N))\n        else:\n            flipcol(randrange(N))\n\n\ndef pr(board, comment=''):\n    print(str(comment))\n    print('     ' + ' '.join(ascii_lowercase[i] for i in range(N)))\n    print('  ' + '\\n  '.join(' '.join(['%2s' % j] + [str(i) for i in line])\n                             for j, line in enumerate(board, 1)))\n\ndef init(board):\n    setbits(board, count=randrange(N)+1)\n    target = deepcopy(board)\n    while board == target:\n        shuffle(board, count=2 * N)\n    prompt = '  X, T, or 1-%i / %s-%s to flip: ' % (N, ascii_lowercase[0], \n                                                    ascii_lowercase[N-1])\n    return target, prompt\n\ndef fliprow(i):\n    board[i-1][:] = [x ^ 1 for x in board[i-1] ]\n    \ndef flipcol(i):\n    for row in board:\n        row[i] ^= 1\n\nif __name__ == '__main__':\n    print(__doc__ % (N, N))\n    target, prompt = init(board)\n    pr(target, 'Target configuration is:')\n    print('')\n    turns = 0\n    while board != target:\n        turns += 1\n        pr(board, '%i:' % turns)\n        ans = input(prompt).strip()\n        if (len(ans) == 1 \n            and ans in ascii_lowercase and ascii_lowercase.index(ans) < N):\n            flipcol(ascii_lowercase.index(ans))\n        elif ans and all(ch in '0123456789' for ch in ans) and 1 <= int(ans) <= N:\n            fliprow(int(ans))\n        elif ans == 'T':\n            pr(target, 'Target configuration is:')\n            turns -= 1\n        elif ans == 'X':\n            break\n        else:\n            print(\"  I don't understand %r... Try again. \"\n                  \"(X to exit or T to show target)\\n\" % ans[:9])\n            turns -= 1\n    else:\n        print('\\nWell done!\\nBye.')\n"}
{"id": 336562, "name": "Flipping bits game", "source": "Translate Ruby to Python: class FlipBoard\n  def initialize(size)\n    raise ArgumentError.new(\"Invalid board size: \n    \n    @size = size\n    @board = Array.new(size**2, 0)\n    \n    randomize_board\n    loop do\n      @target = generate_target\n      break unless solved?\n    end \n    \n    \n    @columns = [*'a'...('a'.ord+@size).chr]\n    @rows = (1..@size).map(&:to_s)\n  end\n  \n  \n  \n  def play\n    moves = 0\n    puts \"your target:\", target\n    \n    until solved? \n      puts \"\", \"move \n      print \"Row/column to flip: \"\n      ans = $stdin.gets.strip\n      \n      if @columns.include? ans\n        flip_column @columns.index(ans)\n        moves += 1\n      elsif @rows.include? ans\n        flip_row @rows.index(ans)\n        moves += 1\n      else\n        puts \"invalid input: \" + ans\n      end\n    end\n    \n    puts \"\", \"you solved the game in \n  end\n  \n  \n  def target\n    format_array @target\n  end\n  \n  \n  def to_s\n    format_array @board\n  end\n  \n  \n  private\n  \n  def solved?\n    @board == @target\n  end\n  \n  \n  def randomize_board\n    (@size + rand(@size)).times do\n      flip_bit rand(@size), rand(@size)\n    end\n  end\n  \n  \n  def generate_target\n    orig_board = @board.clone\n    (@size + rand(@size)).times do \n      rand(2).zero? ? flip_row( rand(@size) ) : flip_column( rand(@size) )\n    end\n    target, @board = @board, orig_board\n    target\n  end\n  \n  def flip_row(row)\n    @size.times {|col| flip_bit(row, col)}\n  end\n  \n  def flip_column(col)\n    @size.times {|row| flip_bit(row, col)}\n  end\n  \n  def flip_bit(row, col)\n    @board[@size * row + col] ^= 1\n  end\n  \n  def format_array(ary)\n    str = \"   \" + @columns.join(\" \") + \"\\n\"\n    @size.times do |row|\n      str << \"%2s \" % @rows[row] + ary[@size*row, @size].join(\" \") + \"\\n\"\n    end\n    str\n  end\nend\n\n\nbegin\n  FlipBoard.new(ARGV.shift.to_i).play\nrescue => e\n  puts e.message\nend\n", "target": "\n\nfrom random import randrange\nfrom copy import deepcopy\nfrom string import ascii_lowercase\n\n\ntry:    \n    input = raw_input\nexcept:\n    pass\n\nN = 3   \n\nboard  = [[0]* N for i in range(N)]\n\ndef setbits(board, count=1):\n    for i in range(count):\n        board[randrange(N)][randrange(N)] ^= 1\n\ndef shuffle(board, count=1):\n    for i in range(count):\n        if randrange(0, 2):\n            fliprow(randrange(N))\n        else:\n            flipcol(randrange(N))\n\n\ndef pr(board, comment=''):\n    print(str(comment))\n    print('     ' + ' '.join(ascii_lowercase[i] for i in range(N)))\n    print('  ' + '\\n  '.join(' '.join(['%2s' % j] + [str(i) for i in line])\n                             for j, line in enumerate(board, 1)))\n\ndef init(board):\n    setbits(board, count=randrange(N)+1)\n    target = deepcopy(board)\n    while board == target:\n        shuffle(board, count=2 * N)\n    prompt = '  X, T, or 1-%i / %s-%s to flip: ' % (N, ascii_lowercase[0], \n                                                    ascii_lowercase[N-1])\n    return target, prompt\n\ndef fliprow(i):\n    board[i-1][:] = [x ^ 1 for x in board[i-1] ]\n    \ndef flipcol(i):\n    for row in board:\n        row[i] ^= 1\n\nif __name__ == '__main__':\n    print(__doc__ % (N, N))\n    target, prompt = init(board)\n    pr(target, 'Target configuration is:')\n    print('')\n    turns = 0\n    while board != target:\n        turns += 1\n        pr(board, '%i:' % turns)\n        ans = input(prompt).strip()\n        if (len(ans) == 1 \n            and ans in ascii_lowercase and ascii_lowercase.index(ans) < N):\n            flipcol(ascii_lowercase.index(ans))\n        elif ans and all(ch in '0123456789' for ch in ans) and 1 <= int(ans) <= N:\n            fliprow(int(ans))\n        elif ans == 'T':\n            pr(target, 'Target configuration is:')\n            turns -= 1\n        elif ans == 'X':\n            break\n        else:\n            print(\"  I don't understand %r... Try again. \"\n                  \"(X to exit or T to show target)\\n\" % ans[:9])\n            turns -= 1\n    else:\n        print('\\nWell done!\\nBye.')\n"}
{"id": 336563, "name": "Gray code", "source": "Translate Ruby to Python: def gray_encode(bin)\n  bin ^ (bin >> 1)\nend\n\ndef gray_decode(gray)\n  bin = gray\n  while gray > 0\n    gray >>= 1\n    bin ^= gray\n  end\n  bin\nend\n", "target": ">>> def int2bin(n):\n\t'From positive integer to list of binary bits, msb at index 0'\n\tif n:\n\t\tbits = []\n\t\twhile n:\n\t\t\tn,remainder = divmod(n, 2)\n\t\t\tbits.insert(0, remainder)\n\t\treturn bits\n\telse: return [0]\n\n\t\n>>> def bin2int(bits):\n\t'From binary bits, msb at index 0 to integer'\n\ti = 0\n\tfor bit in bits:\n\t\ti = i * 2 + bit\n\treturn i\n"}
{"id": 336564, "name": "Gray code", "source": "Translate Ruby to Python: def gray_encode(bin)\n  bin ^ (bin >> 1)\nend\n\ndef gray_decode(gray)\n  bin = gray\n  while gray > 0\n    gray >>= 1\n    bin ^= gray\n  end\n  bin\nend\n", "target": ">>> def int2bin(n):\n\t'From positive integer to list of binary bits, msb at index 0'\n\tif n:\n\t\tbits = []\n\t\twhile n:\n\t\t\tn,remainder = divmod(n, 2)\n\t\t\tbits.insert(0, remainder)\n\t\treturn bits\n\telse: return [0]\n\n\t\n>>> def bin2int(bits):\n\t'From binary bits, msb at index 0 to integer'\n\ti = 0\n\tfor bit in bits:\n\t\ti = i * 2 + bit\n\treturn i\n"}
{"id": 336565, "name": "File extension is in extensions list", "source": "Translate Ruby to Python: def is_ext(filename, extensions)\n  if filename.respond_to?(:each) \n    filename.each do |fn|\n      is_ext(fn, extensions)\n    end\n  else\n    fndc = filename.downcase\n    extensions.each do |ext|\n      bool = fndc.end_with?(?. + ext.downcase)\n      puts \"%20s\u00a0: %s\" % [filename, bool] if bool\n    end\n  end\nend\n", "target": "def isExt(fileName, extensions):\n  return True in map(fileName.lower().endswith, (\".\" + e.lower() for e in extensions))\n"}
{"id": 336566, "name": "File extension is in extensions list", "source": "Translate Ruby to Python: def is_ext(filename, extensions)\n  if filename.respond_to?(:each) \n    filename.each do |fn|\n      is_ext(fn, extensions)\n    end\n  else\n    fndc = filename.downcase\n    extensions.each do |ext|\n      bool = fndc.end_with?(?. + ext.downcase)\n      puts \"%20s\u00a0: %s\" % [filename, bool] if bool\n    end\n  end\nend\n", "target": "def isExt(fileName, extensions):\n  return True in map(fileName.lower().endswith, (\".\" + e.lower() for e in extensions))\n"}
{"id": 336567, "name": "Extreme floating point values", "source": "Translate Ruby to Python: inf = 1.0 / 0.0    \nnan = 0.0 / 0.0               \n\nexpression = [\n  \"1.0 / 0.0\", \"-1.0 / 0.0\", \"0.0 / 0.0\", \"- 0.0\",\n  \"inf + 1\", \"5 - inf\", \"inf * 5\", \"inf / 5\", \"inf * 0\",\n  \"1.0 / inf\", \"-1.0 / inf\", \"inf + inf\", \"inf - inf\",\n  \"inf * inf\", \"inf / inf\", \"inf * 0.0\", \" 0 < inf\", \"inf == inf\",\n  \"nan + 1\", \"nan * 5\", \"nan - nan\", \"nan * inf\", \"- nan\",\n  \"nan == nan\", \"nan > 0\", \"nan < 0\", \"nan == 0\", \"nan <=> 0.0\", \"0.0 == -0.0\",\n]\n\nexpression.each do |exp|\n  puts \"%15s => %p\" % [exp, eval(exp)]\nend\n", "target": ">>> \n>>> inf = 1e234 * 1e234\n>>> _inf = 1e234 * -1e234\n>>> _zero = 1 / _inf\n>>> nan = inf + _inf\n>>> inf, _inf, _zero, nan\n(inf, -inf, -0.0, nan)\n>>> \n>>> for value in (inf, _inf, _zero, nan): print (value)\n\ninf\n-inf\n-0.0\nnan\n>>> \n>>> float('nan')\nnan\n>>> float('inf')\ninf\n>>> float('-inf')\n-inf\n>>> -0.\n-0.0\n>>> \n>>> nan == nan\nFalse\n>>> nan is nan\nTrue\n>>> 0. == -0.\nTrue\n>>> 0. is -0.\nFalse\n>>> inf + _inf\nnan\n>>> 0.0 * nan\nnan\n>>> nan * 0.0\nnan\n>>> 0.0 * inf\nnan\n>>> inf * 0.0\nnan\n"}
{"id": 336568, "name": "Extreme floating point values", "source": "Translate Ruby to Python: inf = 1.0 / 0.0    \nnan = 0.0 / 0.0               \n\nexpression = [\n  \"1.0 / 0.0\", \"-1.0 / 0.0\", \"0.0 / 0.0\", \"- 0.0\",\n  \"inf + 1\", \"5 - inf\", \"inf * 5\", \"inf / 5\", \"inf * 0\",\n  \"1.0 / inf\", \"-1.0 / inf\", \"inf + inf\", \"inf - inf\",\n  \"inf * inf\", \"inf / inf\", \"inf * 0.0\", \" 0 < inf\", \"inf == inf\",\n  \"nan + 1\", \"nan * 5\", \"nan - nan\", \"nan * inf\", \"- nan\",\n  \"nan == nan\", \"nan > 0\", \"nan < 0\", \"nan == 0\", \"nan <=> 0.0\", \"0.0 == -0.0\",\n]\n\nexpression.each do |exp|\n  puts \"%15s => %p\" % [exp, eval(exp)]\nend\n", "target": ">>> \n>>> inf = 1e234 * 1e234\n>>> _inf = 1e234 * -1e234\n>>> _zero = 1 / _inf\n>>> nan = inf + _inf\n>>> inf, _inf, _zero, nan\n(inf, -inf, -0.0, nan)\n>>> \n>>> for value in (inf, _inf, _zero, nan): print (value)\n\ninf\n-inf\n-0.0\nnan\n>>> \n>>> float('nan')\nnan\n>>> float('inf')\ninf\n>>> float('-inf')\n-inf\n>>> -0.\n-0.0\n>>> \n>>> nan == nan\nFalse\n>>> nan is nan\nTrue\n>>> 0. == -0.\nTrue\n>>> 0. is -0.\nFalse\n>>> inf + _inf\nnan\n>>> 0.0 * nan\nnan\n>>> nan * 0.0\nnan\n>>> 0.0 * inf\nnan\n>>> inf * 0.0\nnan\n"}
{"id": 336569, "name": "Soundex", "source": "Translate Ruby to Python: \n\ndef get_code(c : Char)\n  case c\n  when 'B', 'F', 'P', 'V' \n    \"1\"\n  when 'C', 'G', 'J', 'K', 'Q', 'S', 'X', 'Z'\n    \"2\"\n  when 'D', 'T'\n    \"3\"\n  when 'L'\n    \"4\"\n  when 'M', 'N'\n    \"5\"\n  when 'R'\n    \"6\"\n  when 'H', 'W'\n    \"-\"\n  else \n    \"\"\n  end\nend\n\ndef soundex(s : String)\n  return \"\" if s == \"\"\n  s = s.upcase\n  result = s[0,1] \n  prev = get_code s[0]\n  s.lchop.each_char {|c|\n    curr = get_code c\n    result += curr if curr != \"\" && curr != \"-\" && curr != prev\n    prev = curr unless curr == \"-\"\n  }\n  result.ljust(4, '0')[0, 4]\nend\n\npairs = [\n          [\"Ashcraft\"  , \"A261\"],\n          [\"Ashcroft\"  , \"A261\"],\n          [\"Gauss\"     , \"G200\"],\n          [\"Ghosh\"     , \"G200\"],\n          [\"Hilbert\"   , \"H416\"],\n          [\"Heilbronn\" , \"H416\"],\n          [\"Lee\"       , \"L000\"],\n          [\"Lloyd\"     , \"L300\"],\n          [\"Moses\"     , \"M220\"],\n          [\"Pfister\"   , \"P236\"],\n          [\"Robert\"    , \"R163\"],\n          [\"Rupert\"    , \"R163\"],\n          [\"Rubin\"     , \"R150\"],\n          [\"Tymczak\"   , \"T522\"],\n          [\"Soundex\"   , \"S532\"],\n          [\"Example\"   , \"E251\"] \n        ]\n\npairs.each { |pair|\n  puts \"\n}\n", "target": "from itertools import groupby\n\ndef soundex(word):\n   codes = (\"bfpv\",\"cgjkqsxz\", \"dt\", \"l\", \"mn\", \"r\")\n   soundDict = dict((ch, str(ix+1)) for ix,cod in enumerate(codes) for ch in cod)\n   cmap2 = lambda kar: soundDict.get(kar, '9')\n   sdx =  ''.join(cmap2(kar) for kar in word.lower())\n   sdx2 = word[0].upper() + ''.join(k for k,g in list(groupby(sdx))[1:] if k!='9')\n   sdx3 = sdx2[0:4].ljust(4,'0')\n   return sdx3\n"}
{"id": 336570, "name": "Knuth's algorithm S", "source": "Translate Ruby to Python: def s_of_n_creator(n)\n  sample = []\n  i = 0\n  Proc.new do |item|\n    i += 1\n    if i <= n\n      sample << item\n    elsif rand(i) < n\n      sample[rand(n)] = item\n    end\n    sample\n  end\nend\n\nfrequency = Array.new(10,0)\n100_000.times do\n  s_of_n = s_of_n_creator(3)\n  sample = nil\n  (0..9).each {|digit| sample = s_of_n[digit]}\n  sample.each {|digit| frequency[digit] += 1}\nend\n\n(0..9).each {|digit| puts \"\n", "target": "from random import randrange\n\ndef s_of_n_creator(n):\n    sample, i = [], 0\n    def s_of_n(item):\n        nonlocal i\n\n        i += 1\n        if i <= n:\n            \n            sample.append(item)\n        elif randrange(i) < n:\n            \n            sample[randrange(n)] = item\n        return sample\n    return s_of_n\n\nif __name__ == '__main__':\n    bin = [0]* 10\n    items = range(10)\n    print(\"Single run samples for n = 3:\")\n    s_of_n = s_of_n_creator(3)\n    for item in items:\n        sample = s_of_n(item)\n        print(\"  Item: %i -> sample: %s\" % (item, sample))\n    \n    for trial in range(100000):\n        s_of_n = s_of_n_creator(3)\n        for item in items:\n            sample = s_of_n(item)\n        for s in sample:\n            bin[s] += 1\n    print(\"\\nTest item frequencies for 100000 runs:\\n \",\n          '\\n  '.join(\"%i:%i\" % x for x in enumerate(bin)))\n"}
{"id": 336571, "name": "Knuth's algorithm S", "source": "Translate Ruby to Python: def s_of_n_creator(n)\n  sample = []\n  i = 0\n  Proc.new do |item|\n    i += 1\n    if i <= n\n      sample << item\n    elsif rand(i) < n\n      sample[rand(n)] = item\n    end\n    sample\n  end\nend\n\nfrequency = Array.new(10,0)\n100_000.times do\n  s_of_n = s_of_n_creator(3)\n  sample = nil\n  (0..9).each {|digit| sample = s_of_n[digit]}\n  sample.each {|digit| frequency[digit] += 1}\nend\n\n(0..9).each {|digit| puts \"\n", "target": "from random import randrange\n\ndef s_of_n_creator(n):\n    sample, i = [], 0\n    def s_of_n(item):\n        nonlocal i\n\n        i += 1\n        if i <= n:\n            \n            sample.append(item)\n        elif randrange(i) < n:\n            \n            sample[randrange(n)] = item\n        return sample\n    return s_of_n\n\nif __name__ == '__main__':\n    bin = [0]* 10\n    items = range(10)\n    print(\"Single run samples for n = 3:\")\n    s_of_n = s_of_n_creator(3)\n    for item in items:\n        sample = s_of_n(item)\n        print(\"  Item: %i -> sample: %s\" % (item, sample))\n    \n    for trial in range(100000):\n        s_of_n = s_of_n_creator(3)\n        for item in items:\n            sample = s_of_n(item)\n        for s in sample:\n            bin[s] += 1\n    print(\"\\nTest item frequencies for 100000 runs:\\n \",\n          '\\n  '.join(\"%i:%i\" % x for x in enumerate(bin)))\n"}
{"id": 336572, "name": "Conjugate transpose", "source": "Translate Ruby to Python: require 'matrix'\n\n\ni = Complex::I\nmatrix = Matrix[[i, 0, 0],\n                [0, i, 0],\n                [0, 0, i]]\n\n\n\nconjt = matrix.conj.t           \nprint 'conjugate tranpose: '; puts conjt\n\nif matrix.square?\n  \n  print 'Hermitian? '; puts matrix.hermitian?\n  print '   normal? '; puts matrix.normal?\n  print '  unitary? '; puts matrix.unitary?\nelse\n  \n  \n  print 'Hermitian? false'\n  print '   normal? false'\n  print '  unitary? false'\nend\n", "target": "def conjugate_transpose(m):\n    return tuple(tuple(n.conjugate() for n in row) for row in zip(*m))\n\ndef mmul( ma, mb):\n    return tuple(tuple(sum( ea*eb for ea,eb in zip(a,b)) for b in zip(*mb)) for a in ma)\n\ndef mi(size):\n    'Complex Identity matrix'\n    sz = range(size)\n    m = [[0 + 0j for i in sz] for j in sz]\n    for i in range(size):\n        m[i][i] = 1 + 0j\n    return tuple(tuple(row) for row in m)\n\ndef __allsame(vector):\n    first, rest = vector[0], vector[1:]\n    return all(i == first for i in rest)\n\ndef __allnearsame(vector, eps=1e-14):\n    first, rest = vector[0], vector[1:]\n    return all(abs(first.real - i.real) < eps and abs(first.imag - i.imag) < eps\n               for i in rest)\n\ndef isequal(matrices, eps=1e-14):\n    'Check any number of matrices for equality within eps'\n    x = [len(m) for m in matrices]\n    if not __allsame(x): return False\n    y = [len(m[0]) for m in matrices]\n    if not __allsame(y): return False\n    for s in range(x[0]):\n        for t in range(y[0]):\n            if not __allnearsame([m[s][t] for m in matrices], eps): return False\n    return True\n    \n\ndef ishermitian(m, ct):\n    return isequal([m, ct])\n\ndef isnormal(m, ct):\n    return isequal([mmul(m, ct), mmul(ct, m)])\n\ndef isunitary(m, ct):\n    mct, ctm = mmul(m, ct), mmul(ct, m)\n    mctx, mcty, cmx, ctmy = len(mct), len(mct[0]), len(ctm), len(ctm[0])\n    ident = mi(mctx)\n    return isequal([mct, ctm, ident])\n\ndef printm(comment, m):\n    print(comment)\n    fields = [['%g%+gj' % (f.real, f.imag) for f in row] for row in m]\n    width = max(max(len(f) for f in row) for row in fields)\n    lines = (', '.join('%*s' % (width, f) for f in row) for row in fields)\n    print('\\n'.join(lines))\n\nif __name__ == '__main__':\n    for matrix in [\n            ((( 3.000+0.000j), (+2.000+1.000j)), \n            (( 2.000-1.000j), (+1.000+0.000j))),\n\n            ((( 1.000+0.000j), (+1.000+0.000j), (+0.000+0.000j)), \n            (( 0.000+0.000j), (+1.000+0.000j), (+1.000+0.000j)), \n            (( 1.000+0.000j), (+0.000+0.000j), (+1.000+0.000j))),\n\n            ((( 2**0.5/2+0.000j), (+2**0.5/2+0.000j), (+0.000+0.000j)), \n            (( 0.000+2**0.5/2j), (+0.000-2**0.5/2j), (+0.000+0.000j)), \n            (( 0.000+0.000j), (+0.000+0.000j), (+0.000+1.000j)))]:\n        printm('\\nMatrix:', matrix)\n        ct = conjugate_transpose(matrix)\n        printm('Its conjugate transpose:', ct)\n        print('Hermitian? %s.' % ishermitian(matrix, ct))\n        print('Normal?    %s.' % isnormal(matrix, ct))\n        print('Unitary?   %s.' % isunitary(matrix, ct))\n"}
{"id": 336573, "name": "Conjugate transpose", "source": "Translate Ruby to Python: require 'matrix'\n\n\ni = Complex::I\nmatrix = Matrix[[i, 0, 0],\n                [0, i, 0],\n                [0, 0, i]]\n\n\n\nconjt = matrix.conj.t           \nprint 'conjugate tranpose: '; puts conjt\n\nif matrix.square?\n  \n  print 'Hermitian? '; puts matrix.hermitian?\n  print '   normal? '; puts matrix.normal?\n  print '  unitary? '; puts matrix.unitary?\nelse\n  \n  \n  print 'Hermitian? false'\n  print '   normal? false'\n  print '  unitary? false'\nend\n", "target": "def conjugate_transpose(m):\n    return tuple(tuple(n.conjugate() for n in row) for row in zip(*m))\n\ndef mmul( ma, mb):\n    return tuple(tuple(sum( ea*eb for ea,eb in zip(a,b)) for b in zip(*mb)) for a in ma)\n\ndef mi(size):\n    'Complex Identity matrix'\n    sz = range(size)\n    m = [[0 + 0j for i in sz] for j in sz]\n    for i in range(size):\n        m[i][i] = 1 + 0j\n    return tuple(tuple(row) for row in m)\n\ndef __allsame(vector):\n    first, rest = vector[0], vector[1:]\n    return all(i == first for i in rest)\n\ndef __allnearsame(vector, eps=1e-14):\n    first, rest = vector[0], vector[1:]\n    return all(abs(first.real - i.real) < eps and abs(first.imag - i.imag) < eps\n               for i in rest)\n\ndef isequal(matrices, eps=1e-14):\n    'Check any number of matrices for equality within eps'\n    x = [len(m) for m in matrices]\n    if not __allsame(x): return False\n    y = [len(m[0]) for m in matrices]\n    if not __allsame(y): return False\n    for s in range(x[0]):\n        for t in range(y[0]):\n            if not __allnearsame([m[s][t] for m in matrices], eps): return False\n    return True\n    \n\ndef ishermitian(m, ct):\n    return isequal([m, ct])\n\ndef isnormal(m, ct):\n    return isequal([mmul(m, ct), mmul(ct, m)])\n\ndef isunitary(m, ct):\n    mct, ctm = mmul(m, ct), mmul(ct, m)\n    mctx, mcty, cmx, ctmy = len(mct), len(mct[0]), len(ctm), len(ctm[0])\n    ident = mi(mctx)\n    return isequal([mct, ctm, ident])\n\ndef printm(comment, m):\n    print(comment)\n    fields = [['%g%+gj' % (f.real, f.imag) for f in row] for row in m]\n    width = max(max(len(f) for f in row) for row in fields)\n    lines = (', '.join('%*s' % (width, f) for f in row) for row in fields)\n    print('\\n'.join(lines))\n\nif __name__ == '__main__':\n    for matrix in [\n            ((( 3.000+0.000j), (+2.000+1.000j)), \n            (( 2.000-1.000j), (+1.000+0.000j))),\n\n            ((( 1.000+0.000j), (+1.000+0.000j), (+0.000+0.000j)), \n            (( 0.000+0.000j), (+1.000+0.000j), (+1.000+0.000j)), \n            (( 1.000+0.000j), (+0.000+0.000j), (+1.000+0.000j))),\n\n            ((( 2**0.5/2+0.000j), (+2**0.5/2+0.000j), (+0.000+0.000j)), \n            (( 0.000+2**0.5/2j), (+0.000-2**0.5/2j), (+0.000+0.000j)), \n            (( 0.000+0.000j), (+0.000+0.000j), (+0.000+1.000j)))]:\n        printm('\\nMatrix:', matrix)\n        ct = conjugate_transpose(matrix)\n        printm('Its conjugate transpose:', ct)\n        print('Hermitian? %s.' % ishermitian(matrix, ct))\n        print('Normal?    %s.' % isnormal(matrix, ct))\n        print('Unitary?   %s.' % isunitary(matrix, ct))\n"}
{"id": 336574, "name": "Disarium numbers", "source": "Translate Ruby to Python: disariums = Enumerator.new do |y|\n  (0..).each do |n|\n    i = 0\n    y << n if n.digits.reverse.sum{|d| d ** (i+=1) } == n\n  end\nend\n\nputs disariums.take(19).to_a.join(\" \")\n", "target": "\n\ndef isDisarium(n):\n    digitos = len(str(n))\n    suma = 0\n    x = n\n    while x != 0:\n        suma += (x % 10) ** digitos\n        digitos -= 1\n        x //= 10\n    if suma == n:\n        return True\n    else:\n        return False\n\nif __name__ == '__main__':\n    limite = 19\n    cont = 0\n    n = 0\n    print(\"The first\",limite,\"Disarium numbers are:\")\n    while cont < limite:\n        if isDisarium(n):\n            print(n, end = \" \")\n            cont += 1\n        n += 1\n"}
{"id": 336575, "name": "Disarium numbers", "source": "Translate Ruby to Python: disariums = Enumerator.new do |y|\n  (0..).each do |n|\n    i = 0\n    y << n if n.digits.reverse.sum{|d| d ** (i+=1) } == n\n  end\nend\n\nputs disariums.take(19).to_a.join(\" \")\n", "target": "\n\ndef isDisarium(n):\n    digitos = len(str(n))\n    suma = 0\n    x = n\n    while x != 0:\n        suma += (x % 10) ** digitos\n        digitos -= 1\n        x //= 10\n    if suma == n:\n        return True\n    else:\n        return False\n\nif __name__ == '__main__':\n    limite = 19\n    cont = 0\n    n = 0\n    print(\"The first\",limite,\"Disarium numbers are:\")\n    while cont < limite:\n        if isDisarium(n):\n            print(n, end = \" \")\n            cont += 1\n        n += 1\n"}
{"id": 336576, "name": "Cousin primes", "source": "Translate Ruby to Python: require 'prime'\nprimes = Prime.each(1000).to_a\np cousins = primes.filter_map{|pr| [pr, pr+4] if primes.include?(pr+4) }\nputs \"\n", "target": "\n\nfrom itertools import chain, takewhile\n\n\n\ndef cousinPrimes():\n    \n    def go(x):\n        n = 4 + x\n        return [(x, n)] if isPrime(n) else []\n\n    return chain.from_iterable(\n        map(go, primes())\n    )\n\n\n\n\ndef main():\n    \n\n    pairs = list(\n        takewhile(\n            lambda ab: 1000 > ab[1],\n            cousinPrimes()\n        )\n    )\n\n    print(f'{len(pairs)} cousin pairs below 1000:\\n')\n    print(\n        spacedTable(list(\n            chunksOf(4)([\n                repr(x) for x in pairs\n            ])\n        ))\n    )\n\n\n\n\n\ndef chunksOf(n):\n    \n    def go(xs):\n        return (\n            xs[i:n + i] for i in range(0, len(xs), n)\n        ) if 0 < n else None\n    return go\n\n\n\ndef isPrime(n):\n    \n    if n in (2, 3):\n        return True\n    if 2 > n or 0 == n % 2:\n        return False\n    if 9 > n:\n        return True\n    if 0 == n % 3:\n        return False\n\n    def p(x):\n        return 0 == n % x or 0 == n % (2 + x)\n\n    return not any(map(p, range(5, 1 + int(n ** 0.5), 6)))\n\n\n\ndef primes():\n    \n    n = 2\n    dct = {}\n    while True:\n        if n in dct:\n            for p in dct[n]:\n                dct.setdefault(n + p, []).append(p)\n            del dct[n]\n        else:\n            yield n\n            dct[n * n] = [n]\n        n = 1 + n\n\n\n\ndef listTranspose(xss):\n    \n    def go(xss):\n        if xss:\n            h, *t = xss\n            return (\n                [[h[0]] + [xs[0] for xs in t if xs]] + (\n                    go([h[1:]] + [xs[1:] for xs in t])\n                )\n            ) if h and isinstance(h, list) else go(t)\n        else:\n            return []\n    return go(xss)\n\n\n\ndef spacedTable(rows):\n    \n    columnWidths = [\n        len(str(row[-1])) for row in listTranspose(rows)\n    ]\n    return '\\n'.join([\n        ' '.join(\n            map(\n                lambda w, s: s.rjust(w, ' '),\n                columnWidths, row\n            )\n        ) for row in rows\n    ])\n\n\n\nif __name__ == '__main__':\n    main()\n"}
{"id": 336577, "name": "Cousin primes", "source": "Translate Ruby to Python: require 'prime'\nprimes = Prime.each(1000).to_a\np cousins = primes.filter_map{|pr| [pr, pr+4] if primes.include?(pr+4) }\nputs \"\n", "target": "\n\nfrom itertools import chain, takewhile\n\n\n\ndef cousinPrimes():\n    \n    def go(x):\n        n = 4 + x\n        return [(x, n)] if isPrime(n) else []\n\n    return chain.from_iterable(\n        map(go, primes())\n    )\n\n\n\n\ndef main():\n    \n\n    pairs = list(\n        takewhile(\n            lambda ab: 1000 > ab[1],\n            cousinPrimes()\n        )\n    )\n\n    print(f'{len(pairs)} cousin pairs below 1000:\\n')\n    print(\n        spacedTable(list(\n            chunksOf(4)([\n                repr(x) for x in pairs\n            ])\n        ))\n    )\n\n\n\n\n\ndef chunksOf(n):\n    \n    def go(xs):\n        return (\n            xs[i:n + i] for i in range(0, len(xs), n)\n        ) if 0 < n else None\n    return go\n\n\n\ndef isPrime(n):\n    \n    if n in (2, 3):\n        return True\n    if 2 > n or 0 == n % 2:\n        return False\n    if 9 > n:\n        return True\n    if 0 == n % 3:\n        return False\n\n    def p(x):\n        return 0 == n % x or 0 == n % (2 + x)\n\n    return not any(map(p, range(5, 1 + int(n ** 0.5), 6)))\n\n\n\ndef primes():\n    \n    n = 2\n    dct = {}\n    while True:\n        if n in dct:\n            for p in dct[n]:\n                dct.setdefault(n + p, []).append(p)\n            del dct[n]\n        else:\n            yield n\n            dct[n * n] = [n]\n        n = 1 + n\n\n\n\ndef listTranspose(xss):\n    \n    def go(xss):\n        if xss:\n            h, *t = xss\n            return (\n                [[h[0]] + [xs[0] for xs in t if xs]] + (\n                    go([h[1:]] + [xs[1:] for xs in t])\n                )\n            ) if h and isinstance(h, list) else go(t)\n        else:\n            return []\n    return go(xss)\n\n\n\ndef spacedTable(rows):\n    \n    columnWidths = [\n        len(str(row[-1])) for row in listTranspose(rows)\n    ]\n    return '\\n'.join([\n        ' '.join(\n            map(\n                lambda w, s: s.rjust(w, ' '),\n                columnWidths, row\n            )\n        ) for row in rows\n    ])\n\n\n\nif __name__ == '__main__':\n    main()\n"}
{"id": 336578, "name": "Flow-control structures", "source": "Translate Ruby to Python: begin\n  \nrescue ExceptionClassA => a\n  \nrescue ExceptionClassB, ExceptionClassC => b_or_c\n  \nrescue\n  \nelse\n  \nensure\n  \nend\n", "target": "\nfor i in range(n):\n    if (n%2) == 0:\n        continue\n    if (n%i) == 0:\n        result = i\n        break\nelse:\n    result = None\n    print \"No odd factors found\"\n"}
{"id": 336579, "name": "Find if a point is within a triangle", "source": "Translate Ruby to Python: EPS = 0.001\nEPS_SQUARE = EPS * EPS\n\ndef side(x1, y1, x2, y2, x, y)\n    return (y2 - y1) * (x - x1) + (-x2 + x1) * (y - y1)\nend\n\ndef naivePointInTriangle(x1, y1, x2, y2, x3, y3, x, y)\n    checkSide1 = side(x1, y1, x2, y2, x, y) >= 0\n    checkSide2 = side(x2, y2, x3, y3, x, y) >= 0\n    checkSide3 = side(x3, y3, x1, y1, x, y) >= 0\n    return checkSide1 && checkSide2 && checkSide3\nend\n\ndef pointInTriangleBoundingBox(x1, y1, x2, y2, x3, y3, x, y)\n    xMin = [x1, x2, x3].min - EPS\n    xMax = [x1, x2, x3].max + EPS\n    yMin = [y1, y2, y3].min - EPS\n    yMax = [y1, y2, y3].max + EPS\n    return !(x < xMin || xMax < x || y < yMin || yMax < y)\nend\n\ndef distanceSquarePointToSegment(x1, y1, x2, y2, x, y)\n    p1_p2_squareLength = (x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1)\n    dotProduct = ((x - x1) * (x2 - x1) + (y - y1) * (y2 - y1)) / p1_p2_squareLength\n    if dotProduct < 0 then\n        return (x - x1) * (x - x1) + (y - y1) * (y - y1)\n    end\n    if dotProduct <= 1 then\n        p_p1_squareLength = (x1 - x) * (x1 - x) + (y1 - y) * (y1 - y)\n        return p_p1_squareLength - dotProduct * dotProduct * p1_p2_squareLength\n    end\n    return (x - x2) * (x - x2) + (y - y2) * (y - y2)\nend\n\ndef accuratePointInTriangle(x1, y1, x2, y2, x3, y3, x, y)\n    if !pointInTriangleBoundingBox(x1, y1, x2, y2, x3, y3, x, y) then\n        return false\n    end\n    if naivePointInTriangle(x1, y1, x2, y2, x3, y3, x, y) then\n        return true\n    end\n    if distanceSquarePointToSegment(x1, y1, x2, y2, x, y) <= EPS_SQUARE then\n        return true\n    end\n    if distanceSquarePointToSegment(x2, y2, x3, y3, x, y) <= EPS_SQUARE then\n        return true\n    end\n    if distanceSquarePointToSegment(x3, y3, x1, y1, x, y) <= EPS_SQUARE then\n        return true\n    end\n    return false\nend\n\ndef main\n    pts = [[0, 0], [0, 1], [3, 1]]\n    tri = [[1.5, 2.4], [5.1, -3.1], [-3.8, 1.2]]\n    print \"Triangle is \", tri, \"\\n\"\n    x1, y1 = tri[0][0], tri[0][1]\n    x2, y2 = tri[1][0], tri[1][1]\n    x3, y3 = tri[2][0], tri[2][1]\n    for pt in pts\n        x, y = pt[0], pt[1]\n        within = accuratePointInTriangle(x1, y1, x2, y2, x3, y3, x, y)\n        print \"Point \", pt, \" is within triangle? \", within, \"\\n\"\n    end\n    print \"\\n\"\n\n    tri = [[0.1, 1.0 / 9.0], [12.5, 100.0 / 3.0], [25.0, 100.0 / 9.0]]\n    print \"Triangle is \", tri, \"\\n\"\n    x1, y1 = tri[0][0], tri[0][1]\n    x2, y2 = tri[1][0], tri[1][1]\n    x3, y3 = tri[2][0], tri[2][1]\n    x = x1 + (3.0 / 7.0) * (x2 - x1)\n    y = y1 + (3.0 / 7.0) * (y2 - y1)\n    pt = [x, y]\n    within = accuratePointInTriangle(x1, y1, x2, y2, x3, y3, x, y)\n    print \"Point \", pt, \" is within triangle? \", within, \"\\n\"\n    print \"\\n\"\n\n    tri = [[0.1, 1.0 / 9.0], [12.5, 100.0 / 3.0], [-12.5, 100.0 / 6.0]]\n    print \"Triangle is \", tri, \"\\n\"\n    x3, y3 = tri[2][0], tri[2][1]\n    within = accuratePointInTriangle(x1, y1, x2, y2, x3, y3, x, y)\n    print \"Point \", pt, \" is within triangle? \", within, \"\\n\"\nend\n\nmain()\n", "target": "\n\nfrom sympy.geometry import Point, Triangle\n\ndef sign(pt1, pt2, pt3):\n    \n    return (pt1.x - pt3.x) * (pt2.y - pt3.y) - (pt2.x - pt3.x) * (pt1.y - pt3.y)\n\n\ndef iswithin(point, pt1, pt2, pt3):\n    \n    zval1 = sign(point, pt1, pt2)\n    zval2 = sign(point, pt2, pt3)\n    zval3 = sign(point, pt3, pt1)\n    notanyneg = zval1 >= 0 and zval2 >= 0 and zval3 >= 0\n    notanypos = zval1 <= 0 and zval2 <= 0 and zval3 <= 0\n    return notanyneg or notanypos\n\nif __name__ == \"__main__\":\n    POINTS = [Point(0, 0)]\n    TRI = Triangle(Point(1.5, 2.4), Point(5.1, -3.1), Point(-3.8, 0.5))\n    for pnt in POINTS:\n        a, b, c = TRI.vertices\n        isornot = \"is\" if iswithin(pnt, a, b, c) else \"is not\"\n        print(\"Point\", pnt, isornot, \"within the triangle\", TRI)\n"}
{"id": 336580, "name": "Find if a point is within a triangle", "source": "Translate Ruby to Python: EPS = 0.001\nEPS_SQUARE = EPS * EPS\n\ndef side(x1, y1, x2, y2, x, y)\n    return (y2 - y1) * (x - x1) + (-x2 + x1) * (y - y1)\nend\n\ndef naivePointInTriangle(x1, y1, x2, y2, x3, y3, x, y)\n    checkSide1 = side(x1, y1, x2, y2, x, y) >= 0\n    checkSide2 = side(x2, y2, x3, y3, x, y) >= 0\n    checkSide3 = side(x3, y3, x1, y1, x, y) >= 0\n    return checkSide1 && checkSide2 && checkSide3\nend\n\ndef pointInTriangleBoundingBox(x1, y1, x2, y2, x3, y3, x, y)\n    xMin = [x1, x2, x3].min - EPS\n    xMax = [x1, x2, x3].max + EPS\n    yMin = [y1, y2, y3].min - EPS\n    yMax = [y1, y2, y3].max + EPS\n    return !(x < xMin || xMax < x || y < yMin || yMax < y)\nend\n\ndef distanceSquarePointToSegment(x1, y1, x2, y2, x, y)\n    p1_p2_squareLength = (x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1)\n    dotProduct = ((x - x1) * (x2 - x1) + (y - y1) * (y2 - y1)) / p1_p2_squareLength\n    if dotProduct < 0 then\n        return (x - x1) * (x - x1) + (y - y1) * (y - y1)\n    end\n    if dotProduct <= 1 then\n        p_p1_squareLength = (x1 - x) * (x1 - x) + (y1 - y) * (y1 - y)\n        return p_p1_squareLength - dotProduct * dotProduct * p1_p2_squareLength\n    end\n    return (x - x2) * (x - x2) + (y - y2) * (y - y2)\nend\n\ndef accuratePointInTriangle(x1, y1, x2, y2, x3, y3, x, y)\n    if !pointInTriangleBoundingBox(x1, y1, x2, y2, x3, y3, x, y) then\n        return false\n    end\n    if naivePointInTriangle(x1, y1, x2, y2, x3, y3, x, y) then\n        return true\n    end\n    if distanceSquarePointToSegment(x1, y1, x2, y2, x, y) <= EPS_SQUARE then\n        return true\n    end\n    if distanceSquarePointToSegment(x2, y2, x3, y3, x, y) <= EPS_SQUARE then\n        return true\n    end\n    if distanceSquarePointToSegment(x3, y3, x1, y1, x, y) <= EPS_SQUARE then\n        return true\n    end\n    return false\nend\n\ndef main\n    pts = [[0, 0], [0, 1], [3, 1]]\n    tri = [[1.5, 2.4], [5.1, -3.1], [-3.8, 1.2]]\n    print \"Triangle is \", tri, \"\\n\"\n    x1, y1 = tri[0][0], tri[0][1]\n    x2, y2 = tri[1][0], tri[1][1]\n    x3, y3 = tri[2][0], tri[2][1]\n    for pt in pts\n        x, y = pt[0], pt[1]\n        within = accuratePointInTriangle(x1, y1, x2, y2, x3, y3, x, y)\n        print \"Point \", pt, \" is within triangle? \", within, \"\\n\"\n    end\n    print \"\\n\"\n\n    tri = [[0.1, 1.0 / 9.0], [12.5, 100.0 / 3.0], [25.0, 100.0 / 9.0]]\n    print \"Triangle is \", tri, \"\\n\"\n    x1, y1 = tri[0][0], tri[0][1]\n    x2, y2 = tri[1][0], tri[1][1]\n    x3, y3 = tri[2][0], tri[2][1]\n    x = x1 + (3.0 / 7.0) * (x2 - x1)\n    y = y1 + (3.0 / 7.0) * (y2 - y1)\n    pt = [x, y]\n    within = accuratePointInTriangle(x1, y1, x2, y2, x3, y3, x, y)\n    print \"Point \", pt, \" is within triangle? \", within, \"\\n\"\n    print \"\\n\"\n\n    tri = [[0.1, 1.0 / 9.0], [12.5, 100.0 / 3.0], [-12.5, 100.0 / 6.0]]\n    print \"Triangle is \", tri, \"\\n\"\n    x3, y3 = tri[2][0], tri[2][1]\n    within = accuratePointInTriangle(x1, y1, x2, y2, x3, y3, x, y)\n    print \"Point \", pt, \" is within triangle? \", within, \"\\n\"\nend\n\nmain()\n", "target": "\n\nfrom sympy.geometry import Point, Triangle\n\ndef sign(pt1, pt2, pt3):\n    \n    return (pt1.x - pt3.x) * (pt2.y - pt3.y) - (pt2.x - pt3.x) * (pt1.y - pt3.y)\n\n\ndef iswithin(point, pt1, pt2, pt3):\n    \n    zval1 = sign(point, pt1, pt2)\n    zval2 = sign(point, pt2, pt3)\n    zval3 = sign(point, pt3, pt1)\n    notanyneg = zval1 >= 0 and zval2 >= 0 and zval3 >= 0\n    notanypos = zval1 <= 0 and zval2 <= 0 and zval3 <= 0\n    return notanyneg or notanypos\n\nif __name__ == \"__main__\":\n    POINTS = [Point(0, 0)]\n    TRI = Triangle(Point(1.5, 2.4), Point(5.1, -3.1), Point(-3.8, 0.5))\n    for pnt in POINTS:\n        a, b, c = TRI.vertices\n        isornot = \"is\" if iswithin(pnt, a, b, c) else \"is not\"\n        print(\"Point\", pnt, isornot, \"within the triangle\", TRI)\n"}
{"id": 336581, "name": "Return multiple values", "source": "Translate Ruby to Python: def addsub(x, y)\n  [x + y, x - y]\nend\n", "target": "def addsub(x, y):\n  return x + y, x - y\n"}
{"id": 336582, "name": "Change e letters to i in words", "source": "Translate Ruby to Python: words = File.readlines(\"unixdict.txt\").map(&:chomp)\nwords.each do |word|\n  next if word.size < 6 \n  next unless word.match?(/e/)\n  e2i = word.tr(\"e\", \"i\")\n  next unless words.bsearch{|w| e2i <=> w}\n  puts \"\nend\n", "target": "\n\n\n\ndef ieTwins(s):\n    \n    longWords = [\n        w for w in s.splitlines()\n        if 5 < len(w)\n    ]\n    lexicon = {\n        w for w in longWords\n        if 'i' in w\n    }\n\n    return [\n        (w, twin) for w in longWords\n        if 'e' in w and (\n            twin := w.replace('e', 'i')\n        ) in lexicon\n    ]\n\n\n\n\ndef main():\n    \n    for pair in ieTwins(\n        readFile(\"unixdict.txt\")\n    ):\n        print(pair)\n\n\n\n\n\ndef readFile(fp):\n    \n    with open(fp, 'r', encoding='utf-8') as f:\n        return f.read()\n\n\n\nif __name__ == '__main__':\n    main()\n"}
{"id": 336583, "name": "Change e letters to i in words", "source": "Translate Ruby to Python: words = File.readlines(\"unixdict.txt\").map(&:chomp)\nwords.each do |word|\n  next if word.size < 6 \n  next unless word.match?(/e/)\n  e2i = word.tr(\"e\", \"i\")\n  next unless words.bsearch{|w| e2i <=> w}\n  puts \"\nend\n", "target": "\n\n\n\ndef ieTwins(s):\n    \n    longWords = [\n        w for w in s.splitlines()\n        if 5 < len(w)\n    ]\n    lexicon = {\n        w for w in longWords\n        if 'i' in w\n    }\n\n    return [\n        (w, twin) for w in longWords\n        if 'e' in w and (\n            twin := w.replace('e', 'i')\n        ) in lexicon\n    ]\n\n\n\n\ndef main():\n    \n    for pair in ieTwins(\n        readFile(\"unixdict.txt\")\n    ):\n        print(pair)\n\n\n\n\n\ndef readFile(fp):\n    \n    with open(fp, 'r', encoding='utf-8') as f:\n        return f.read()\n\n\n\nif __name__ == '__main__':\n    main()\n"}
{"id": 336584, "name": "Fractran", "source": "Translate Ruby to Python: ar = %w[17/91 78/85 19/51 23/38 29/33 77/29 95/23 77/19 1/17 11/13 13/11 15/14 15/2 55/1]\nFractalProgram = ar.map(&:to_r)                                \n\nRunner = Enumerator.new do |y|\n  num = 2\n  loop{ y << num *= FractalProgram.detect{|f| (num*f).denominator == 1} }\nend\n\nprime_generator = Enumerator.new do |y| \n  Runner.each do |num|\n    l = Math.log2(num)\n    y << l.to_i if l.floor == l\n  end\nend\n\n\np Runner.take(20).map(&:numerator)\np prime_generator.take(20)\n", "target": "from fractions import Fraction\n\ndef fractran(n, fstring='17 / 91, 78 / 85, 19 / 51, 23 / 38, 29 / 33,'\n                        '77 / 29, 95 / 23, 77 / 19, 1 / 17, 11 / 13,'\n                        '13 / 11, 15 / 14, 15 / 2, 55 / 1'):\n    flist = [Fraction(f) for f in fstring.replace(' ', '').split(',')]\n\n    n = Fraction(n)\n    while True:\n        yield n.numerator\n        for f in flist:\n            if (n * f).denominator == 1:\n                break\n        else:\n            break\n        n *= f\n    \nif __name__ == '__main__':\n    n, m = 2, 15\n    print('First %i members of fractran(%i):\\n  ' % (m, n) +\n          ', '.join(str(f) for f,i in zip(fractran(n), range(m))))\n"}
{"id": 336585, "name": "Substring_Top and tail", "source": "Translate Ruby to Python: puts \"knight\"[1..-1]   \nputs \"socks\"[0..-2]    \nputs \"socks\".chop      \nputs \"brooms\"[1..-2]   \nputs \"\u4e0e\u4eca\u4ee4\"[1..-2]    \n", "target": "print \"knight\"[1:]     \nprint \"socks\"[:-1]     \nprint \"brooms\"[1:-1]   \n"}
{"id": 336586, "name": "Substring_Top and tail", "source": "Translate Ruby to Python: puts \"knight\"[1..-1]   \nputs \"socks\"[0..-2]    \nputs \"socks\".chop      \nputs \"brooms\"[1..-2]   \nputs \"\u4e0e\u4eca\u4ee4\"[1..-2]    \n", "target": "print \"knight\"[1:]     \nprint \"socks\"[:-1]     \nprint \"brooms\"[1:-1]   \n"}
{"id": 336587, "name": "Boolean values", "source": "Translate Ruby to Python: if false\n  puts \"false\"\nelsif nil\n  puts \"nil\"\nelsif Pointer(Nil).new 0\n  puts \"null pointer\"\nelsif true && \"any other value\"\n  puts \"finally true!\"\nend\n", "target": ">>> True\nTrue\n>>> not True\nFalse\n>>> \n>>> False + 0\n0\n>>> True + 0\n1\n>>> False + 0j\n0j\n>>> True * 3.141\n3.141\n>>> \n>>> not 0\nTrue\n>>> not not 0\nFalse\n>>> not 1234\nFalse\n>>> bool(0.0)\nFalse\n>>> bool(0j)\nFalse\n>>> bool(1+2j)\nTrue\n>>> \n>>> bool([])\nFalse\n>>> bool([None])\nTrue\n>>> 'I contain something' if (None,) else 'I am empty'\n'I contain something'\n>>> bool({})\nFalse\n>>> bool(\"\")\nFalse\n>>> bool(\"False\")\nTrue\n"}
{"id": 336588, "name": "Multiline shebang", "source": "Translate Ruby to Python: \n\n\nprintf '%s\\n' \"Shell running $0\"\ni=1\nfor arg do\n  printf '  %s\\n' \"\\${$i}: $arg\"\n  i=`expr $i + 1`\ndone\n\n\nexec ${RUBY-ruby} -x \"$0\" --coming-from-sh \"$@\"\n\n\n\nARGV[0] == \"--coming-from-sh\" or exec \"/bin/sh\", $0, *ARGV\nARGV.shift\n\n\nputs \"Ruby running \nARGV.each_with_index do |arg, i|\n  puts \"  ARGV[\nend\n", "target": "\n\"exec\" \"python\" \"$0\"\n\nprint \"Hello World\"\n"}
{"id": 336589, "name": "Multiline shebang", "source": "Translate Ruby to Python: \n\n\nprintf '%s\\n' \"Shell running $0\"\ni=1\nfor arg do\n  printf '  %s\\n' \"\\${$i}: $arg\"\n  i=`expr $i + 1`\ndone\n\n\nexec ${RUBY-ruby} -x \"$0\" --coming-from-sh \"$@\"\n\n\n\nARGV[0] == \"--coming-from-sh\" or exec \"/bin/sh\", $0, *ARGV\nARGV.shift\n\n\nputs \"Ruby running \nARGV.each_with_index do |arg, i|\n  puts \"  ARGV[\nend\n", "target": "\n\"exec\" \"python\" \"$0\"\n\nprint \"Hello World\"\n"}
{"id": 336590, "name": "Bitmap_Histogram", "source": "Translate Ruby to Python: class Pixmap\n  def histogram\n    histogram = Hash.new(0)\n    @height.times do |y|\n      @width.times do |x|\n        histogram[self[x,y].luminosity] += 1\n      end\n    end\n    histogram \n  end\n\n  def to_blackandwhite\n    hist = histogram\n\n    \n    median = nil\n    sum = 0\n    hist.keys.sort.each do |lum|\n      sum += hist[lum]\n      if sum > @height * @width / 2\n        median = lum\n        break\n      end\n    end\n\n    \n    bw = self.class.new(@width, @height)\n    @height.times do |y|\n      @width.times do |x|\n        bw[x,y] = self[x,y].luminosity < median ? RGBColour::BLACK : RGBColour::WHITE\n      end\n    end\n    bw\n  end\n\n  def save_as_blackandwhite(filename)\n    to_blackandwhite.save(filename)\n  end\nend\n\nPixmap.open('file.ppm').save_as_blackandwhite('file_bw.ppm')\n", "target": "from PIL import Image\n\n\nimage = Image.open(\"lena.jpg\")\n\nwidth, height = image.size\n\namount = width * height\n\n\ntotal = 0\n\nbw_image = Image.new('L', (width, height), 0)\n\nbm_image = Image.new('1', (width, height), 0)\n\nfor h in range(0, height):\n    for w in range(0, width):\n        r, g, b = image.getpixel((w, h))\n\n        greyscale = int((r + g + b) / 3)\n        total += greyscale\n\n        bw_image.putpixel((w, h), gray_scale)\n\n\navg = total / amount\n\nblack = 0\nwhite = 1\n\nfor h in range(0, height):\n    for w in range(0, width):\n        v = bw_image.getpixel((w, h))\n\n        if v >= avg:\n            bm_image.putpixel((w, h), white)\n        else:\n            bm_image.putpixel((w, h), black)\n\nbw_image.show()\nbm_image.show()\n"}
{"id": 336591, "name": "Plot coordinate pairs", "source": "Translate Ruby to Python: require 'gnuplot'\n\nx = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\ny = [2.7, 2.8, 31.4, 38.1, 58.0, 76.2, 100.5, 130.0, 149.3, 180.0]\nGnuplot.open do |gp|\n  Gnuplot::Plot.new( gp ) do |plot|\n    plot.data << Gnuplot::DataSet.new( [x, y] ) do |ds|\n      ds.with = \"linespoints\"\n      ds.notitle\n    end\n  end\nend\n", "target": ">>> x = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n>>> y = [2.7, 2.8, 31.4, 38.1, 58.0, 76.2, 100.5, 130.0, 149.3, 180.0]\n\n>>> import pylab\n>>> pylab.plot(x, y, 'bo')\n>>> pylab.savefig('qsort-range-10-9.png')\n"}
{"id": 336592, "name": "Plot coordinate pairs", "source": "Translate Ruby to Python: require 'gnuplot'\n\nx = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\ny = [2.7, 2.8, 31.4, 38.1, 58.0, 76.2, 100.5, 130.0, 149.3, 180.0]\nGnuplot.open do |gp|\n  Gnuplot::Plot.new( gp ) do |plot|\n    plot.data << Gnuplot::DataSet.new( [x, y] ) do |ds|\n      ds.with = \"linespoints\"\n      ds.notitle\n    end\n  end\nend\n", "target": ">>> x = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n>>> y = [2.7, 2.8, 31.4, 38.1, 58.0, 76.2, 100.5, 130.0, 149.3, 180.0]\n\n>>> import pylab\n>>> pylab.plot(x, y, 'bo')\n>>> pylab.savefig('qsort-range-10-9.png')\n"}
{"id": 336593, "name": "LZW compression", "source": "Translate Ruby to Python: \ndef compress(uncompressed)\n    \n    dict_size = 256\n    dictionary = Hash[ Array.new(dict_size) {|i| [i.chr, i.chr]} ]\n\n    w = \"\"\n    result = []\n    for c in uncompressed.split('')\n        wc = w + c\n        if dictionary.has_key?(wc)\n            w = wc\n        else\n            result << dictionary[w]\n            \n            dictionary[wc] = dict_size\n            dict_size += 1\n            w = c\n        end\n    end\n\n    \n    result << dictionary[w] unless w.empty?\n    result\nend\n\n\ndef decompress(compressed)\n    \n    dict_size = 256\n    dictionary = Hash[ Array.new(dict_size) {|i| [i.chr, i.chr]} ]\n\n    w = result = compressed.shift\n    for k in compressed\n        if dictionary.has_key?(k)\n            entry = dictionary[k]\n        elsif k == dict_size\n            entry = w + w[0,1]\n        else\n            raise 'Bad compressed k: %s' % k\n        end\n        result += entry\n\n        \n        dictionary[dict_size] = w + entry[0,1]\n        dict_size += 1\n\n        w = entry\n    end\n    result\nend\n\n\ncompressed = compress('TOBEORNOTTOBEORTOBEORNOT')\np compressed\ndecompressed = decompress(compressed)\nputs decompressed\n", "target": "def compress(uncompressed):\n    \n\n    \n    dict_size = 256\n    dictionary = dict((chr(i), i) for i in range(dict_size))\n    \n\n    w = \"\"\n    result = []\n    for c in uncompressed:\n        wc = w + c\n        if wc in dictionary:\n            w = wc\n        else:\n            result.append(dictionary[w])\n            \n            dictionary[wc] = dict_size\n            dict_size += 1\n            w = c\n\n    \n    if w:\n        result.append(dictionary[w])\n    return result\n\n\ndef decompress(compressed):\n    \n    from io import StringIO\n\n    \n    dict_size = 256\n    dictionary = dict((i, chr(i)) for i in range(dict_size))\n    \n\n    \n    \n    result = StringIO()\n    w = chr(compressed.pop(0))\n    result.write(w)\n    for k in compressed:\n        if k in dictionary:\n            entry = dictionary[k]\n        elif k == dict_size:\n            entry = w + w[0]\n        else:\n            raise ValueError('Bad compressed k: %s' % k)\n        result.write(entry)\n\n        \n        dictionary[dict_size] = w + entry[0]\n        dict_size += 1\n\n        w = entry\n    return result.getvalue()\n\n\n\ncompressed = compress('TOBEORNOTTOBEORTOBEORNOT')\nprint (compressed)\ndecompressed = decompress(compressed)\nprint (decompressed)\n"}
{"id": 336594, "name": "Peano curve", "source": "Translate Ruby to Python: load_library :grammar\n\n\nclass Peano\n  include Processing::Proxy\n  attr_reader :draw_length, :vec, :theta, :axiom, :grammar\n  DELTA = 60 \n  def initialize(vec)\n    @axiom = 'XF' \n    rules = {\n      'X' => 'X+YF++YF-FX--FXFX-YF+', \n      'Y' => '-FX+YFYF++YF+FX--FX-Y'\n    }\n    @grammar = Grammar.new(axiom, rules)\n    @theta   = 0\n    @draw_length = 100\n    @vec = vec\n  end\n\n  def generate(gen)\n    @draw_length = draw_length * 0.6**gen\n    grammar.generate gen\n  end\n\n  def translate_rules(prod)\n    coss = ->(orig, alpha, len) { orig + len * DegLut.cos(alpha) }\n    sinn = ->(orig, alpha, len) { orig - len * DegLut.sin(alpha) }\n    [].tap do |pts| \n      prod.scan(/./) do |ch|\n        case ch\n        when 'F'\n          pts << vec.copy\n          @vec = Vec2D.new(\n            coss.call(vec.x, theta, draw_length),\n            sinn.call(vec.y, theta, draw_length)\n          )\n          pts << vec\n        when '+'\n          @theta += DELTA\n        when '-'\n          @theta -= DELTA\n        when 'X', 'Y'\n        else\n          puts(\"character \n        end\n      end\n    end\n  end\nend\n\nattr_reader :points\n\ndef setup\n  sketch_title 'Peano'\n  peano = Peano.new(Vec2D.new(width * 0.65, height * 0.9))\n  production = peano.generate 4 \n  @points = peano.translate_rules(production)\n  no_loop\nend\n\ndef draw\n  background(0)\n  render points\nend\n\ndef render(points)\n  no_fill\n  stroke 200.0\n  stroke_weight 3\n  begin_shape\n  points.each_slice(2) do |v0, v1|\n    v0.to_vertex(renderer)\n    v1.to_vertex(renderer)\n  end\n  end_shape\nend\n\ndef renderer\n  @renderer ||= GfxRender.new(g)\nend\n\ndef settings\n  size(800, 800)\nend\n", "target": "import turtle as tt\nimport inspect\n\nstack = [] \ndef peano(iterations=1):\n    global stack\n\n    \n    ivan = tt.Turtle(shape = \"classic\", visible = True)\n\n\n    \n    screen = tt.Screen()\n    screen.title(\"Desenhin do Peano\")\n    screen.bgcolor(\"\n    screen.delay(0) \n    screen.setup(width=0.95, height=0.9)\n\n    \n    walk = 1\n\n    def screenlength(k):\n        \n        \n        if k != 0:\n            length = screenlength(k-1)\n            return 2*length + 1\n        else: return 0\n\n    kkkj = screenlength(iterations)\n    screen.setworldcoordinates(-1, -1, kkkj + 1, kkkj + 1)\n    ivan.color(\"\n\n\n    \n    def step1(k):\n        global stack\n        stack.append(len(inspect.stack()))\n        if k != 0:\n            ivan.left(90)\n            step2(k - 1)\n            ivan.forward(walk)\n            ivan.right(90)\n            step1(k - 1)\n            ivan.forward(walk)\n            step1(k - 1)\n            ivan.right(90)\n            ivan.forward(walk)\n            step2(k - 1)\n            ivan.left(90)\n    def step2(k):\n        global stack\n        stack.append(len(inspect.stack()))\n        if k != 0:\n            ivan.right(90)\n            step1(k - 1)\n            ivan.forward(walk)\n            ivan.left(90)\n            step2(k - 1)\n            ivan.forward(walk)\n            step2(k - 1)\n            ivan.left(90)\n            ivan.forward(walk)\n            step1(k - 1)\n            ivan.right(90)\n\n    \n    ivan.left(90)\n    step2(iterations)\n\n    tt.done()\n\nif __name__ == \"__main__\":\n    peano(4)\n    import pylab as P \n    P.plot(stack)\n    P.show()\n"}
{"id": 336595, "name": "Check input device is a terminal", "source": "Translate Ruby to Python: File.new(\"testfile\").tty?   \nFile.new(\"/dev/tty\").tty?   \nSTDIN.tty?  \n", "target": "from sys import stdin\nif stdin.isatty():\n    print(\"Input comes from tty.\")\nelse:\n    print(\"Input doesn't come from tty.\")\n"}
{"id": 336596, "name": "Check input device is a terminal", "source": "Translate Ruby to Python: File.new(\"testfile\").tty?   \nFile.new(\"/dev/tty\").tty?   \nSTDIN.tty?  \n", "target": "from sys import stdin\nif stdin.isatty():\n    print(\"Input comes from tty.\")\nelse:\n    print(\"Input doesn't come from tty.\")\n"}
{"id": 336597, "name": "First 9 prime Fibonacci number", "source": "Translate Ruby to Python: require 'prime'\n\nprime_fibs = Enumerator.new do |y|\n  a, b = 1, 1\n  loop do\n    y << a if a.prime?\n    a, b = b, a + b\n  end\nend\nputs prime_fibs.take(9)\n", "target": "from math import sqrt\nfrom time import time\n\nn = 12\nstart = time()\n\n\ndef prime(x):\n    if x < 2:\n        return False\n    if x == 2 or x == 3:\n        return True\n    if x % 2 == 0:\n        return False\n    for i in range(3, int(sqrt(x)) + 1, 2):\n        if x % i == 0:\n            return False\n    return True\n\n\na, b, = 1, 1\nfibn = 3\nf = []\nwhile len(f) < n:\n    a, b, = b, a + b\n    if prime(b):\n        f.append(b)\n        print(\"fib(%d): %s (%s s)\" % (fibn, b, time() - start))\n    fibn += 1\n"}
{"id": 336598, "name": "First 9 prime Fibonacci number", "source": "Translate Ruby to Python: require 'prime'\n\nprime_fibs = Enumerator.new do |y|\n  a, b = 1, 1\n  loop do\n    y << a if a.prime?\n    a, b = b, a + b\n  end\nend\nputs prime_fibs.take(9)\n", "target": "from math import sqrt\nfrom time import time\n\nn = 12\nstart = time()\n\n\ndef prime(x):\n    if x < 2:\n        return False\n    if x == 2 or x == 3:\n        return True\n    if x % 2 == 0:\n        return False\n    for i in range(3, int(sqrt(x)) + 1, 2):\n        if x % i == 0:\n            return False\n    return True\n\n\na, b, = 1, 1\nfibn = 3\nf = []\nwhile len(f) < n:\n    a, b, = b, a + b\n    if prime(b):\n        f.append(b)\n        print(\"fib(%d): %s (%s s)\" % (fibn, b, time() - start))\n    fibn += 1\n"}
{"id": 336599, "name": "Bioinformatics_base count", "source": "Translate Ruby to Python: dna = <<DNA_STR\nCGTAAAAAATTACAACGTCCTTTGGCTATCTCTTAAACTCCTGCTAAATG\nCTCGTGCTTTCCAATTATGTAAGCGTTCCGAGACGGGGTGGTCGATTCTG\nAGGACAAAGGTCAAGATGGAGCGCATCGAACGCAATAAGGATCATTTGAT\nGGGACGTTTCGTCGACAAAGTCTTGTTTCGAGAGTAACGGCTACCGTCTT\nCGATTCTGCTTATAACACTATGTTCTTATGAAATGGATGTTCTGAGTTGG\nTCAGTCCCAATGTGCGGGGTTTCTTTTAGTACGTCGGGAGTGGTATTATA\nTTTAATTTTTCTATATAGCGATCTGTATTTAAGCAATTCATTTAGGTTAT\nCGCCGCGATGCTCGGTTCGGACCGCCAAGCATCTGGCTCCACTGCTAGTG\nTCCTAAATTTGAATGGCAAACACAAATAAGATTTAGCAATTCGTGTAGAC\nGACCGGGGACTTGCATGATGGGAGCAGCTTTGTTAAACTACGAACGTAAT\nDNA_STR\n\nchunk_size = 60\ndna        = dna.delete(\"\\n\")\nsize       = dna.size\n\n0.step(size, chunk_size) do |pos|\n  puts \"\nend\n\nputs dna.chars.tally.sort.map{|ar| ar.join(\"\u00a0: \") }\nputs \"Total\u00a0: \n", "target": "from collections import Counter\n\ndef basecount(dna):\n    return sorted(Counter(dna).items())\n\ndef seq_split(dna, n=50):\n    return [dna[i: i+n] for i in range(0, len(dna), n)]\n\ndef seq_pp(dna, n=50):\n    for i, part in enumerate(seq_split(dna, n)):\n        print(f\"{i*n:>5}: {part}\")\n    print(\"\\n  BASECOUNT:\")\n    tot = 0\n    for base, count in basecount(dna):\n        print(f\"    {base:>3}: {count}\")\n        tot += count\n    base, count = 'TOT', tot\n    print(f\"    {base:>3}= {count}\")\n    \nif __name__ == '__main__':\n    print(\"SEQUENCE:\")\n    sequence = \n    seq_pp(sequence)\n"}
{"id": 336600, "name": "Bioinformatics_base count", "source": "Translate Ruby to Python: dna = <<DNA_STR\nCGTAAAAAATTACAACGTCCTTTGGCTATCTCTTAAACTCCTGCTAAATG\nCTCGTGCTTTCCAATTATGTAAGCGTTCCGAGACGGGGTGGTCGATTCTG\nAGGACAAAGGTCAAGATGGAGCGCATCGAACGCAATAAGGATCATTTGAT\nGGGACGTTTCGTCGACAAAGTCTTGTTTCGAGAGTAACGGCTACCGTCTT\nCGATTCTGCTTATAACACTATGTTCTTATGAAATGGATGTTCTGAGTTGG\nTCAGTCCCAATGTGCGGGGTTTCTTTTAGTACGTCGGGAGTGGTATTATA\nTTTAATTTTTCTATATAGCGATCTGTATTTAAGCAATTCATTTAGGTTAT\nCGCCGCGATGCTCGGTTCGGACCGCCAAGCATCTGGCTCCACTGCTAGTG\nTCCTAAATTTGAATGGCAAACACAAATAAGATTTAGCAATTCGTGTAGAC\nGACCGGGGACTTGCATGATGGGAGCAGCTTTGTTAAACTACGAACGTAAT\nDNA_STR\n\nchunk_size = 60\ndna        = dna.delete(\"\\n\")\nsize       = dna.size\n\n0.step(size, chunk_size) do |pos|\n  puts \"\nend\n\nputs dna.chars.tally.sort.map{|ar| ar.join(\"\u00a0: \") }\nputs \"Total\u00a0: \n", "target": "from collections import Counter\n\ndef basecount(dna):\n    return sorted(Counter(dna).items())\n\ndef seq_split(dna, n=50):\n    return [dna[i: i+n] for i in range(0, len(dna), n)]\n\ndef seq_pp(dna, n=50):\n    for i, part in enumerate(seq_split(dna, n)):\n        print(f\"{i*n:>5}: {part}\")\n    print(\"\\n  BASECOUNT:\")\n    tot = 0\n    for base, count in basecount(dna):\n        print(f\"    {base:>3}: {count}\")\n        tot += count\n    base, count = 'TOT', tot\n    print(f\"    {base:>3}= {count}\")\n    \nif __name__ == '__main__':\n    print(\"SEQUENCE:\")\n    sequence = \n    seq_pp(sequence)\n"}
{"id": 336601, "name": "Wireworld", "source": "Translate Ruby to Python: var f = [[], DATA.lines.map {['', .chars..., '']}..., []];\n\n10.times {\n    say f.map { .join(\" \") + \"\\n\" }.join;\n    var a = [[]];\n    for y in (1 .. f.end-1) {\n        var r = f[y];\n        var rr = [''];\n        for x in (1 .. r.end-1) {\n            var c = r[x];\n            rr << (\n              given(c) {\n                when('H') { 't' }\n                when('t') { '.' }\n                when('.') { <. H>[f.ft(y-1, y+1).map{.ft(x-1, x+1)...}.count('H') ~~ [1,2]] }\n                default   { c }\n              }\n            )\n        }\n        rr << '';\n        a << rr;\n    }\n    f = [a..., []];\n}\n\n__DATA__\ntH.........\n.   .\n   ...\n.   .\nHt.. ......\n", "target": "\n\nfrom io import StringIO\nfrom collections import namedtuple\nfrom pprint import pprint as pp\nimport copy\n\nWW = namedtuple('WW', 'world, w, h')\nhead, tail, conductor, empty = allstates = 'Ht. '\n\n\ninfile = StringIO()\n\ndef readfile(f):\n    \n    world  = [row.rstrip('\\r\\n') for row in f]\n    height = len(world)\n    width  = max(len(row) for row in world)\n    \n    nonrow = [ \" %*s \" % (-width, \"\") ]\n    world  = nonrow + \\\n               [ \" %*s \" % (-width, row) for row in world ] + \\\n               nonrow   \n    world = [list(row) for row in world]\n    return WW(world, width, height)\n\ndef newcell(currentworld, x, y):\n    istate = currentworld[y][x]\n    assert istate in allstates, 'Wireworld cell set to unknown value \"%s\"' % istate\n    if istate == head:\n        ostate = tail\n    elif istate == tail:\n        ostate = conductor\n    elif istate == empty:\n        ostate = empty\n    else: \n        n = sum( currentworld[y+dy][x+dx] == head\n                 for dx,dy in ( (-1,-1), (-1,+0), (-1,+1),\n                                (+0,-1),          (+0,+1),\n                                (+1,-1), (+1,+0), (+1,+1) ) )\n        ostate = head if 1 <= n <= 2 else conductor\n    return ostate\n\ndef nextgen(ww):\n    'compute next generation of wireworld'\n    world, width, height = ww\n    newworld = copy.deepcopy(world)\n    for x in range(1, width+1):\n        for y in range(1, height+1):\n            newworld[y][x] = newcell(world, x, y)\n    return WW(newworld, width, height)\n\ndef world2string(ww):\n    return '\\n'.join( ''.join(row[1:-1]).rstrip() for row in ww.world[1:-1] )\n\nww = readfile(infile)\ninfile.close()\n\nfor gen in range(10):\n    print ( (\"\\n%3i \" % gen) + '=' * (ww.w-4) + '\\n' )\n    print ( world2string(ww) )\n    ww = nextgen(ww)\n"}
{"id": 336602, "name": "Ulam spiral (for primes)", "source": "Translate Ruby to Python: enum Direction\n  RIGHT\n  UP\n  LEFT\n  DOWN\nend\n\ndef generate(n : Int32, i : Int32, c : Int32 | String)\n  s = Array.new(n) { Array.new(n) { \"\" } }\n\n  dir = Direction::RIGHT\n  y = n // 2\n  x = n % 2 == 0 ? y - 1 : y\n\n  j = 1\n  while j <= n * n - 1 + i\n    s[y][x] = is_prime(j) ? j.to_s : c.to_s\n\n    \n\n    case dir\n    when Direction::RIGHT\n      dir = Direction::UP if x <= n - 1 && s[y - 1][x] == \"\" && j > i\n    when Direction::UP\n      dir = Direction::LEFT if s[y][x - 1] == \"\"\n    when Direction::LEFT\n      dir = Direction::DOWN if x == 0 || s[y + 1][x] == \"\"\n    when Direction::DOWN\n      dir = Direction::RIGHT if s[y][x + 1] == \"\"\n    end\n\n    case dir\n    when Direction::RIGHT\n      x += 1\n    when Direction::UP\n      y -= 1\n    when Direction::LEFT\n      x -= 1\n    when Direction::DOWN\n      y += 1\n    end\n\n    j += 1\n  end\n\n  s.map(&.join(\"\\t\")).join(\"\\n\")\nend\n\ndef is_prime(n : Int32) : Bool\n  return true if n == 2\n  return false if n % 2 == 0 || n < 1\n\n  i = 3\n  while i <= Math.sqrt(n)\n    return false if n % i == 0\n    i += 2\n  end\n\n  true\nend\n\nputs generate 7, 1, \"*\"\n", "target": "\nfrom __future__ import print_function, division\nfrom math import sqrt\n\ndef cell(n, x, y, start=1):\n    d, y, x = 0, y - n//2, x - (n - 1)//2\n    l = 2*max(abs(x), abs(y))\n    d = (l*3 + x + y) if y >= x else (l - x - y)\n    return (l - 1)**2 + d + start - 1\n\ndef show_spiral(n, symbol='\n    top = start + n*n + 1\n    is_prime = [False,False,True] + [True,False]*(top//2)\n    for x in range(3, 1 + int(sqrt(top))):\n        if not is_prime[x]: continue\n        for i in range(x*x, top, x*2):\n            is_prime[i] = False\n\n    cell_str = lambda x: f(x) if is_prime[x] else space\n    f = lambda _: symbol \n\n    if space == None: space = ' '*len(symbol)\n\n    if not len(symbol): \n        max_str = len(str(n*n + start - 1))\n        if space == None: space = '.'*max_str + ' '\n        f = lambda x: ('%' + str(max_str) + 'd ')%x\n\n    for y in range(n):\n        print(''.join(cell_str(v) for v in [cell(n, x, y, start) for x in range(n)]))\n    print()\n\nshow_spiral(10, symbol=u'\u265e', space=u'\u2658') \nshow_spiral(9, symbol='', space=' - ')\n\n\n"}
{"id": 336603, "name": "Fibonacci word", "source": "Translate Ruby to Python: \n\ndef entropy(s)\n  counts = Hash.new(0.0)\n  s.each_char { |c| counts[c] += 1 }\n  leng = s.length\n  \n  counts.values.reduce(0) do |entropy, count|\n    freq = count / leng\n    entropy - freq * Math.log2(freq)\n  end\nend\n\nn_max = 37\nwords = ['1', '0']\n\nfor n in words.length ... n_max\n  words << words[-1] + words[-2]\nend\n\nputs '%3s %9s %15s  %s' % %w[N Length Entropy Fibword]\nwords.each.with_index(1) do |word, i|\n  puts '%3i %9i %15.12f  %s' % [i, word.length, entropy(word), word.length<60 ? word : '<too long>']\nend\n", "target": ">>> import math\n>>> from collections import Counter\n>>> \n>>> def entropy(s):\n...     p, lns = Counter(s), float(len(s))\n...     return -sum( count/lns * math.log(count/lns, 2) for count in p.values())\n... \n>>> \n>>> def fibword(nmax=37):\n...     fwords = ['1', '0']\n...     print('%-3s %10s %-10s %s' % tuple('N Length Entropy Fibword'.split()))\n...     def pr(n, fwords):\n...         while len(fwords) < n:\n...             fwords += [''.join(fwords[-2:][::-1])]\n...         v = fwords[n-1]\n...         print('%3i %10i %10.7g %s' % (n, len(v), entropy(v), v if len(v) < 20 else '<too long>'))\n...     for n in range(1, nmax+1): pr(n, fwords)\n... \n>>> fibword()\nN       Length Entropy    Fibword\n  1          1         -0 1\n  2          1         -0 0\n  3          2          1 01\n  4          3  0.9182958 010\n  5          5  0.9709506 01001\n  6          8   0.954434 01001010\n  7         13  0.9612366 0100101001001\n  8         21  0.9587119 <too long>\n  9         34  0.9596869 <too long>\n 10         55   0.959316 <too long>\n 11         89  0.9594579 <too long>\n 12        144  0.9594038 <too long>\n 13        233  0.9594244 <too long>\n 14        377  0.9594165 <too long>\n 15        610  0.9594196 <too long>\n 16        987  0.9594184 <too long>\n 17       1597  0.9594188 <too long>\n 18       2584  0.9594187 <too long>\n 19       4181  0.9594187 <too long>\n 20       6765  0.9594187 <too long>\n 21      10946  0.9594187 <too long>\n 22      17711  0.9594187 <too long>\n 23      28657  0.9594187 <too long>\n 24      46368  0.9594187 <too long>\n 25      75025  0.9594187 <too long>\n 26     121393  0.9594187 <too long>\n 27     196418  0.9594187 <too long>\n 28     317811  0.9594187 <too long>\n 29     514229  0.9594187 <too long>\n 30     832040  0.9594187 <too long>\n 31    1346269  0.9594187 <too long>\n 32    2178309  0.9594187 <too long>\n 33    3524578  0.9594187 <too long>\n 34    5702887  0.9594187 <too long>\n 35    9227465  0.9594187 <too long>\n 36   14930352  0.9594187 <too long>\n 37   24157817  0.9594187 <too long>\n>>>\n"}
{"id": 336604, "name": "Fibonacci word", "source": "Translate Ruby to Python: \n\ndef entropy(s)\n  counts = Hash.new(0.0)\n  s.each_char { |c| counts[c] += 1 }\n  leng = s.length\n  \n  counts.values.reduce(0) do |entropy, count|\n    freq = count / leng\n    entropy - freq * Math.log2(freq)\n  end\nend\n\nn_max = 37\nwords = ['1', '0']\n\nfor n in words.length ... n_max\n  words << words[-1] + words[-2]\nend\n\nputs '%3s %9s %15s  %s' % %w[N Length Entropy Fibword]\nwords.each.with_index(1) do |word, i|\n  puts '%3i %9i %15.12f  %s' % [i, word.length, entropy(word), word.length<60 ? word : '<too long>']\nend\n", "target": ">>> import math\n>>> from collections import Counter\n>>> \n>>> def entropy(s):\n...     p, lns = Counter(s), float(len(s))\n...     return -sum( count/lns * math.log(count/lns, 2) for count in p.values())\n... \n>>> \n>>> def fibword(nmax=37):\n...     fwords = ['1', '0']\n...     print('%-3s %10s %-10s %s' % tuple('N Length Entropy Fibword'.split()))\n...     def pr(n, fwords):\n...         while len(fwords) < n:\n...             fwords += [''.join(fwords[-2:][::-1])]\n...         v = fwords[n-1]\n...         print('%3i %10i %10.7g %s' % (n, len(v), entropy(v), v if len(v) < 20 else '<too long>'))\n...     for n in range(1, nmax+1): pr(n, fwords)\n... \n>>> fibword()\nN       Length Entropy    Fibword\n  1          1         -0 1\n  2          1         -0 0\n  3          2          1 01\n  4          3  0.9182958 010\n  5          5  0.9709506 01001\n  6          8   0.954434 01001010\n  7         13  0.9612366 0100101001001\n  8         21  0.9587119 <too long>\n  9         34  0.9596869 <too long>\n 10         55   0.959316 <too long>\n 11         89  0.9594579 <too long>\n 12        144  0.9594038 <too long>\n 13        233  0.9594244 <too long>\n 14        377  0.9594165 <too long>\n 15        610  0.9594196 <too long>\n 16        987  0.9594184 <too long>\n 17       1597  0.9594188 <too long>\n 18       2584  0.9594187 <too long>\n 19       4181  0.9594187 <too long>\n 20       6765  0.9594187 <too long>\n 21      10946  0.9594187 <too long>\n 22      17711  0.9594187 <too long>\n 23      28657  0.9594187 <too long>\n 24      46368  0.9594187 <too long>\n 25      75025  0.9594187 <too long>\n 26     121393  0.9594187 <too long>\n 27     196418  0.9594187 <too long>\n 28     317811  0.9594187 <too long>\n 29     514229  0.9594187 <too long>\n 30     832040  0.9594187 <too long>\n 31    1346269  0.9594187 <too long>\n 32    2178309  0.9594187 <too long>\n 33    3524578  0.9594187 <too long>\n 34    5702887  0.9594187 <too long>\n 35    9227465  0.9594187 <too long>\n 36   14930352  0.9594187 <too long>\n 37   24157817  0.9594187 <too long>\n>>>\n"}
{"id": 336605, "name": "Text processing_1", "source": "Translate Ruby to Python: filename = \"readings.txt\"\ntotal = { \"num_readings\" => 0, \"num_good_readings\" => 0, \"sum_readings\" => 0.0 }\ninvalid_count = 0\nmax_invalid_count = 0\ninvalid_run_end = \"\"\n\nFile.new(filename).each do |line|\n  num_readings = 0\n  num_good_readings = 0\n  sum_readings = 0.0\n\n  fields = line.split\n  fields[1..-1].each_slice(2) do |reading, flag|\n    num_readings += 1\n    if Integer(flag) > 0\n      num_good_readings += 1\n      sum_readings += Float(reading)\n      invalid_count = 0\n    else\n      invalid_count += 1\n      if invalid_count > max_invalid_count\n        max_invalid_count = invalid_count\n        invalid_run_end = fields[0]\n      end\n    end\n  end\n\n  printf \"Line: %11s  Reject: %2d  Accept: %2d  Line_tot: %10.3f  Line_avg: %10.3f\\n\",\n    fields[0], num_readings - num_good_readings, num_good_readings, sum_readings,\n    num_good_readings > 0 ? sum_readings/num_good_readings : 0.0\n\n  total[\"num_readings\"] += num_readings\n  total[\"num_good_readings\"] += num_good_readings\n  total[\"sum_readings\"] += sum_readings\nend\n\nputs \"\"\nputs \"File(s)  = \nprintf \"Total    =\u00a0%.3f\\n\", total['sum_readings']\nputs \"Readings = \nprintf \"Average  =\u00a0%.3f\\n\", total['sum_readings']/total['num_good_readings']\nputs \"\"\nputs \"Maximum run(s) of \n", "target": "import fileinput\nimport sys\n\nnodata = 0;             \nnodata_max=-1;          \nnodata_maxline=[];      \n\ntot_file = 0            \nnum_file = 0            \n\ninfiles = sys.argv[1:]\n\nfor line in fileinput.input():\n  tot_line=0;             \n  num_line=0;             \n\n  \n  field = line.split()\n  date  = field[0]\n  data  = [float(f) for f in field[1::2]]\n  flags = [int(f)   for f in field[2::2]]\n\n  for datum, flag in zip(data, flags):\n    if flag<1:\n      nodata += 1\n    else:\n      \n      if nodata_max==nodata and nodata>0:\n        nodata_maxline.append(date)\n      if nodata_max<nodata and nodata>0:\n        nodata_max=nodata\n        nodata_maxline=[date]\n      \n      nodata=0; \n      \n      tot_line += datum\n      num_line += 1\n\n  \n  tot_file += tot_line\n  num_file += num_line\n\n  print \"Line: %11s  Reject: %2i  Accept: %2i  Line_tot: %10.3f  Line_avg: %10.3f\" % (\n        date, \n        len(data) -num_line, \n        num_line, tot_line, \n        tot_line/num_line if (num_line>0) else 0)\n\nprint \"\"\nprint \"File(s)  = %s\" % (\", \".join(infiles),)\nprint \"Total    = %10.3f\" % (tot_file,)\nprint \"Readings = %6i\" % (num_file,)\nprint \"Average  = %10.3f\" % (tot_file / num_file,)\n\nprint \"\\nMaximum run(s) of %i consecutive false readings ends at line starting with date(s): %s\" % (\n    nodata_max, \", \".join(nodata_maxline))\n"}
{"id": 336606, "name": "Death Star", "source": "Translate Ruby to Python: func hitf(sph, x, y) {\n    x -= sph[0]\n    y -= sph[1]\n\n    var z = (sph[3]**2 - (x**2 + y**2))\n\n    z < 0 && return nil\n\n    z.sqrt!\n    [sph[2] - z, sph[2] + z]\n}\n\nfunc normalize(v) {\n    v / v.abs\n}\n\nfunc dot(x, y) {\n    max(0, x*y)\n}\n\nvar pos = [120, 120, 0, 120]\nvar neg = [-77, -33, -100, 190]\nvar light = normalize(Vector(-12, 13, -10))\n\nfunc draw(k, amb) {\n    STDOUT.binmode(':raw')\n    print (\"P5\\n\", pos[0]*2 + 3, \" \", pos[1]*2 + 3, \"\\n255\\n\")\n\n    for y in ((pos[1] - pos[3] - 1) .. (pos[1] + pos[3] + 1)) {\n        var row = []\n        for x in ((pos[0] - pos[3] - 1) .. (pos[0] + pos[3] + 1)) {\n\n            var hit = 0\n            var hs = []\n            var h = hitf(pos, x, y)\n\n            if    (!h)                      { hit = 0; h  = [0, 0] }\n            elsif (!(hs = hitf(neg, x, y))) { hit = 1; hs = [0, 0] }\n            elsif (hs[0] > h[0])            { hit = 1 }\n            elsif (hs[1] > h[0])            { hit = (hs[1] > h[1] ? 0 : 2) }\n            else                            { hit = 1 }\n\n            var (val, v)\n\n            given(hit) {\n                when (0) { val = 0}\n                when (1) { v = Vector(x-pos[0], y-pos[1], h[0]-pos[2]) }\n                default  { v = Vector(neg[0]-x, neg[1]-y, neg[2]-hs[1]) }\n            }\n\n            if (defined(v)) {\n                v = normalize(v)\n                val = int((dot(v, light)**k + amb) * 255)\n                val = (val > 255 ? 255 : (val < 0 ? 0 : val))\n            }\n            row.append(val)\n        }\n        print 'C*'.pack(row...)\n    }\n}\n\ndraw(2, 0.2)\n", "target": "import sys, math, collections\n\nSphere = collections.namedtuple(\"Sphere\", \"cx cy cz r\")\nV3 = collections.namedtuple(\"V3\", \"x y z\")\n\ndef normalize((x, y, z)):\n    len = math.sqrt(x**2 + y**2 + z**2)\n    return V3(x / len, y / len, z / len)\n\ndef dot(v1, v2):\n    d = v1.x*v2.x + v1.y*v2.y + v1.z*v2.z\n    return -d if d < 0 else 0.0\n\ndef hit_sphere(sph, x0, y0):\n    x = x0 - sph.cx\n    y = y0 - sph.cy\n    zsq = sph.r ** 2 - (x ** 2 + y ** 2)\n    if zsq < 0:\n        return (False, 0, 0)\n    szsq = math.sqrt(zsq)\n    return (True, sph.cz - szsq, sph.cz + szsq)\n\ndef draw_sphere(k, ambient, light):\n    shades = \".:!*oe&\n    pos = Sphere(20.0, 20.0, 0.0, 20.0)\n    neg = Sphere(1.0, 1.0, -6.0, 20.0)\n\n    for i in xrange(int(math.floor(pos.cy - pos.r)),\n                    int(math.ceil(pos.cy + pos.r) + 1)):\n        y = i + 0.5\n        for j in xrange(int(math.floor(pos.cx - 2 * pos.r)),\n                        int(math.ceil(pos.cx + 2 * pos.r) + 1)):\n            x = (j - pos.cx) / 2.0 + 0.5 + pos.cx\n\n            (h, zb1, zb2) = hit_sphere(pos, x, y)\n            if not h:\n                hit_result = 0\n            else:\n                (h, zs1, zs2) = hit_sphere(neg, x, y)\n                if not h:\n                    hit_result = 1\n                elif zs1 > zb1:\n                    hit_result = 1\n                elif zs2 > zb2:\n                    hit_result = 0\n                elif zs2 > zb1:\n                    hit_result = 2\n                else:\n                    hit_result = 1\n\n            if hit_result == 0:\n                sys.stdout.write(' ')\n                continue\n            elif hit_result == 1:\n                vec = V3(x - pos.cx, y - pos.cy, zb1 - pos.cz)\n            elif hit_result == 2:\n                vec = V3(neg.cx-x, neg.cy-y, neg.cz-zs2)\n            vec = normalize(vec)\n\n            b = dot(light, vec) ** k + ambient\n            intensity = int((1 - b) * len(shades))\n            intensity = min(len(shades), max(0, intensity))\n            sys.stdout.write(shades[intensity])\n        print\n\nlight = normalize(V3(-50, 30, 50))\ndraw_sphere(2, 0.5, light)\n"}
{"id": 336607, "name": "Colour pinstripe_Display", "source": "Translate Ruby to Python: require('GD')\n\nfunc pinstripes(width = 1280, height = 720) {\n\n    var im = %O<GD::Image>.new(width, height)\n    var colors = [0, 255].variations_with_repetition(3)\n\n    var paintcolors = colors.shuffle.map {|rgb|\n        im.colorAllocate(rgb...)\n    }\n\n    var starty     = 0\n    var barheight  = height//4\n\n    for barwidth in (1..4) {\n        for (\n            var(startx = 0, colorindex = 0);\n            startx + barwidth <= width;\n            startx += barwidth\n        ) {\n            im.filledRectangle(startx, starty, startx+barwidth,\n                starty + barheight - 1, paintcolors[colorindex++ % 8])\n        }\n        starty += barheight\n    }\n\n    return im\n}\n\nFile('pinstripes.png').write(pinstripes().png, :raw)\n", "target": "from turtle import *\n\ncolors = [\"black\", \"red\", \"green\", \"blue\", \"magenta\", \"cyan\", \"yellow\", \"white\"]\n\n\n\nscreen = getscreen()\n\nleft_edge = -screen.window_width()//2\n\nright_edge = screen.window_width()//2\n\nquarter_height = screen.window_height()//4\n\nhalf_height = quarter_height * 2\n\nspeed(\"fastest\")\n\nfor quarter in range(4):\n    pensize(quarter+1)\n    colornum = 0\n\n    min_y = half_height - ((quarter + 1) * quarter_height)\n    max_y = half_height - ((quarter) * quarter_height)\n    \n    for x in range(left_edge,right_edge,quarter+1):\n        penup()\n        pencolor(colors[colornum])\n        colornum = (colornum + 1) % len(colors)\n        setposition(x,min_y)\n        pendown()\n        setposition(x,max_y)\n         \nnotused = input(\"Hit enter to continue: \")\n"}
{"id": 336608, "name": "Bitmap_B\u00e9zier curves_Cubic", "source": "Translate Ruby to Python: class Pixmap\n  def draw_bezier_curve(points, colour)\n    \n    points = points.sort_by {|p| [p.x, p.y]}\n    xmin = points[0].x\n    xmax = points[-1].x\n    increment = 2\n    prev = points[0]\n    ((xmin + increment) .. xmax).step(increment) do |x|\n      t = 1.0 * (x - xmin) / (xmax - xmin)\n      p = Pixel[x, bezier(t, points).round]\n      draw_line(prev, p, colour)\n      prev = p\n    end\n  end\nend\n\n\ndef bezier(t, points)\n  n = points.length - 1\n  points.each_with_index.inject(0.0) do |sum, (point, i)|\n    sum += n.choose(i) * (1-t)**(n - i) * t**i * point.y\n  end\nend\n \nclass Fixnum\n  def choose(k)\n    self.factorial / (k.factorial * (self - k).factorial)\n  end\n  def factorial\n    (2 .. self).reduce(1, :*)\n  end\nend\n\nbitmap = Pixmap.new(400, 400)\npoints = [\n  Pixel[40,100], Pixel[100,350], Pixel[150,50], \n  Pixel[150,150], Pixel[350,250], Pixel[250,250]\n]\npoints.each {|p| bitmap.draw_circle(p, 3, RGBColour::RED)}\nbitmap.draw_bezier_curve(points, RGBColour::BLUE)\n", "target": "def cubicbezier(self, x0, y0, x1, y1, x2, y2, x3, y3, n=20):\n    pts = []\n    for i in range(n+1):\n        t = i / n\n        a = (1. - t)**3\n        b = 3. * t * (1. - t)**2\n        c = 3.0 * t**2 * (1.0 - t)\n        d = t**3\n        \n        x = int(a * x0 + b * x1 + c * x2 + d * x3)\n        y = int(a * y0 + b * y1 + c * y2 + d * y3)\n        pts.append( (x, y) )\n    for i in range(n):\n        self.line(pts[i][0], pts[i][1], pts[i+1][0], pts[i+1][1])\nBitmap.cubicbezier = cubicbezier\n\nbitmap = Bitmap(17,17)\nbitmap.cubicbezier(16,1, 1,4, 3,16, 15,11)\nbitmap.chardisplay()\n\n\n\n"}
{"id": 336609, "name": "Birthday problem", "source": "Translate Ruby to Python: def equalBirthdays(nSharers, groupSize, nRepetitions)\n    eq = 0\n\n    for i in 1 .. nRepetitions\n        group = [0] * 365\n        for j in 1 .. groupSize\n            group[rand(group.length)] += 1\n        end\n        eq += group.any? { |n| n >= nSharers } ? 1 : 0\n    end\n\n    return (eq * 100.0) / nRepetitions\nend\n\ndef main\n    groupEst = 2\n    for sharers in 2 .. 5\n        \n        groupSize = groupEst + 1\n        while equalBirthdays(sharers, groupSize, 100) < 50.0\n            groupSize += 1\n        end\n\n        \n        inf = (groupSize - (groupSize - groupEst) / 4.0).floor\n        for gs in inf .. groupSize + 999\n            eq = equalBirthdays(sharers, groupSize, 250)\n            if eq > 50.0 then\n                groupSize = gs\n                break\n            end\n        end\n\n        \n        for gs in groupSize - 1 .. groupSize + 999\n            eq = equalBirthdays(sharers, gs, 50000)\n            if eq > 50.0 then\n                groupEst = gs\n                print \"%d independant people in a group of %s share a common birthday. (%5.1f)\\n\" % [sharers, gs, eq]\n                break\n            end\n        end\n    end\nend\n\nmain()\n", "target": "from random import randint\n\ndef equal_birthdays(sharers=2, groupsize=23, rep=100000):\n    'Note: 4 sharing common birthday may have 2 dates shared between two people each' \n    g = range(groupsize)\n    sh = sharers - 1\n    eq = sum((groupsize - len(set(randint(1,365) for i in g)) >= sh)\n             for j in range(rep))\n    return (eq * 100.) / rep\n\ndef equal_birthdays(sharers=2, groupsize=23, rep=100000):\n    'Note: 4 sharing common birthday must all share same common day' \n    g = range(groupsize)\n    sh = sharers - 1\n    eq = 0\n    for j in range(rep):\n        group = [randint(1,365) for i in g]\n        if (groupsize - len(set(group)) >= sh and\n            any( group.count(member) >= sharers for member in set(group))):\n            eq += 1\n    return (eq * 100.) / rep\n\ngroup_est = [2]\nfor sharers in (2, 3, 4, 5):\n    groupsize = group_est[-1]+1\n    while equal_birthdays(sharers, groupsize, 100) < 50.:\n        \n        groupsize += 1\n    for groupsize in range(int(groupsize - (groupsize - group_est[-1])/4.), groupsize + 999):\n        \n        eq = equal_birthdays(sharers, groupsize, 250)\n        if eq > 50.:\n            break\n    for groupsize in range(groupsize - 1, groupsize +999):\n        \n        eq = equal_birthdays(sharers, groupsize, 50000)\n        if eq > 50.:\n            break\n    group_est.append(groupsize)\n    print(\"%i independent people in a group of %s share a common birthday. (%5.1f)\" % (sharers, groupsize, eq))\n"}
{"id": 336610, "name": "Birthday problem", "source": "Translate Ruby to Python: def equalBirthdays(nSharers, groupSize, nRepetitions)\n    eq = 0\n\n    for i in 1 .. nRepetitions\n        group = [0] * 365\n        for j in 1 .. groupSize\n            group[rand(group.length)] += 1\n        end\n        eq += group.any? { |n| n >= nSharers } ? 1 : 0\n    end\n\n    return (eq * 100.0) / nRepetitions\nend\n\ndef main\n    groupEst = 2\n    for sharers in 2 .. 5\n        \n        groupSize = groupEst + 1\n        while equalBirthdays(sharers, groupSize, 100) < 50.0\n            groupSize += 1\n        end\n\n        \n        inf = (groupSize - (groupSize - groupEst) / 4.0).floor\n        for gs in inf .. groupSize + 999\n            eq = equalBirthdays(sharers, groupSize, 250)\n            if eq > 50.0 then\n                groupSize = gs\n                break\n            end\n        end\n\n        \n        for gs in groupSize - 1 .. groupSize + 999\n            eq = equalBirthdays(sharers, gs, 50000)\n            if eq > 50.0 then\n                groupEst = gs\n                print \"%d independant people in a group of %s share a common birthday. (%5.1f)\\n\" % [sharers, gs, eq]\n                break\n            end\n        end\n    end\nend\n\nmain()\n", "target": "from random import randint\n\ndef equal_birthdays(sharers=2, groupsize=23, rep=100000):\n    'Note: 4 sharing common birthday may have 2 dates shared between two people each' \n    g = range(groupsize)\n    sh = sharers - 1\n    eq = sum((groupsize - len(set(randint(1,365) for i in g)) >= sh)\n             for j in range(rep))\n    return (eq * 100.) / rep\n\ndef equal_birthdays(sharers=2, groupsize=23, rep=100000):\n    'Note: 4 sharing common birthday must all share same common day' \n    g = range(groupsize)\n    sh = sharers - 1\n    eq = 0\n    for j in range(rep):\n        group = [randint(1,365) for i in g]\n        if (groupsize - len(set(group)) >= sh and\n            any( group.count(member) >= sharers for member in set(group))):\n            eq += 1\n    return (eq * 100.) / rep\n\ngroup_est = [2]\nfor sharers in (2, 3, 4, 5):\n    groupsize = group_est[-1]+1\n    while equal_birthdays(sharers, groupsize, 100) < 50.:\n        \n        groupsize += 1\n    for groupsize in range(int(groupsize - (groupsize - group_est[-1])/4.), groupsize + 999):\n        \n        eq = equal_birthdays(sharers, groupsize, 250)\n        if eq > 50.:\n            break\n    for groupsize in range(groupsize - 1, groupsize +999):\n        \n        eq = equal_birthdays(sharers, groupsize, 50000)\n        if eq > 50.:\n            break\n    group_est.append(groupsize)\n    print(\"%i independent people in a group of %s share a common birthday. (%5.1f)\" % (sharers, groupsize, eq))\n"}
{"id": 336611, "name": "Draw a sphere", "source": "Translate Ruby to Python: Shoes.app :width => 500, :height => 500, :resizable => false do\n  image 400, 470, :top => 30, :left => 50 do\n    nostroke\n    fill \"\n    image :top => 230, :left => 0 do\n      oval 70, 130, 260, 40\n      blur 30\n    end\n    oval 10, 10, 380, 380\n    image :top => 0, :left => 0 do\n      fill \"\n      oval 30, 30, 338, 338\n      blur 10\n    end\n    fill gradient(rgb(1.0, 1.0, 1.0, 0.7), rgb(1.0, 1.0, 1.0, 0.0))\n    oval 80, 14, 240, 176\n    image :top => 0, :left => 0 do\n      fill \"\n      oval 134, 134, 130, 130\n      blur 40\n    end\n    image :top => 150, :left => 40, :width => 320, :height => 260 do\n      fill gradient(rgb(0.7, 0.9, 1.0, 0.0), rgb(0.7, 0.9, 1.0, 0.6))\n      oval 60, 60, 200, 136\n      blur 20\n    end\n  end\nend\n", "target": "import math\n\nshades = ('.',':','!','*','o','e','&','\n\ndef normalize(v):\n\tlen = math.sqrt(v[0]**2 + v[1]**2 + v[2]**2)\n\treturn (v[0]/len, v[1]/len, v[2]/len)\n\ndef dot(x,y):\n\td = x[0]*y[0] + x[1]*y[1] + x[2]*y[2]\n\treturn -d if d < 0 else 0\n\ndef draw_sphere(r, k, ambient, light):\n\tfor i in range(int(math.floor(-r)),int(math.ceil(r)+1)):\n\t\tx = i + 0.5\n\t\tline = ''\n\n\t\tfor j in range(int(math.floor(-2*r)),int(math.ceil(2*r)+1)):\n\t\t\ty = j/2 + 0.5\n\t\t\tif x*x + y*y <= r*r:\n\t\t\t\tvec = normalize((x,y,math.sqrt(r*r - x*x - y*y)))\n\t\t\t\tb = dot(light,vec)**k + ambient\n\t\t\t\tintensity = int((1-b)*(len(shades)-1))\n\t\t\t\tline += shades[intensity] if 0 <= intensity < len(shades) else shades[0]\n\t\t\telse:\n\t\t\t\tline += ' '\n\n\t\tprint(line)\n\nlight = normalize((30,30,-50))\ndraw_sphere(20,4,0.1, light)\ndraw_sphere(10,2,0.4, light)\n"}
{"id": 336612, "name": "Draw a sphere", "source": "Translate Ruby to Python: Shoes.app :width => 500, :height => 500, :resizable => false do\n  image 400, 470, :top => 30, :left => 50 do\n    nostroke\n    fill \"\n    image :top => 230, :left => 0 do\n      oval 70, 130, 260, 40\n      blur 30\n    end\n    oval 10, 10, 380, 380\n    image :top => 0, :left => 0 do\n      fill \"\n      oval 30, 30, 338, 338\n      blur 10\n    end\n    fill gradient(rgb(1.0, 1.0, 1.0, 0.7), rgb(1.0, 1.0, 1.0, 0.0))\n    oval 80, 14, 240, 176\n    image :top => 0, :left => 0 do\n      fill \"\n      oval 134, 134, 130, 130\n      blur 40\n    end\n    image :top => 150, :left => 40, :width => 320, :height => 260 do\n      fill gradient(rgb(0.7, 0.9, 1.0, 0.0), rgb(0.7, 0.9, 1.0, 0.6))\n      oval 60, 60, 200, 136\n      blur 20\n    end\n  end\nend\n", "target": "import math\n\nshades = ('.',':','!','*','o','e','&','\n\ndef normalize(v):\n\tlen = math.sqrt(v[0]**2 + v[1]**2 + v[2]**2)\n\treturn (v[0]/len, v[1]/len, v[2]/len)\n\ndef dot(x,y):\n\td = x[0]*y[0] + x[1]*y[1] + x[2]*y[2]\n\treturn -d if d < 0 else 0\n\ndef draw_sphere(r, k, ambient, light):\n\tfor i in range(int(math.floor(-r)),int(math.ceil(r)+1)):\n\t\tx = i + 0.5\n\t\tline = ''\n\n\t\tfor j in range(int(math.floor(-2*r)),int(math.ceil(2*r)+1)):\n\t\t\ty = j/2 + 0.5\n\t\t\tif x*x + y*y <= r*r:\n\t\t\t\tvec = normalize((x,y,math.sqrt(r*r - x*x - y*y)))\n\t\t\t\tb = dot(light,vec)**k + ambient\n\t\t\t\tintensity = int((1-b)*(len(shades)-1))\n\t\t\t\tline += shades[intensity] if 0 <= intensity < len(shades) else shades[0]\n\t\t\telse:\n\t\t\t\tline += ' '\n\n\t\tprint(line)\n\nlight = normalize((30,30,-50))\ndraw_sphere(20,4,0.1, light)\ndraw_sphere(10,2,0.4, light)\n"}
{"id": 336613, "name": "Thiele's interpolation formula", "source": "Translate Ruby to Python: func thiele(x, y) {\n    var \u03c1 = {|i| [y[i]]*(y.len-i) }.map(^y)\n\u00a0\n    for i in ^(\u03c1.end) {\n        \u03c1[i][1] = ((x[i] - x[i+1]) / (\u03c1[i][0] - \u03c1[i+1][0]))\n    }\n    for i (2 .. \u03c1.end) {\n        for j (0 .. \u03c1.end-i) {\n            \u03c1[j][i] = (((x[j]-x[j+i]) / (\u03c1[j][i-1]-\u03c1[j+1][i-1])) + \u03c1[j+1][i-2])\n        }\n    }\n\u00a0\n    var \u03c10 = \u03c1[0]\n\u00a0\n    func t(xin) {\n        var a = 0\n        for i (\u03c10.len ^.. 2) {\n            a = ((xin - x[i-1]) / (\u03c10[i] - \u03c10[i-2] + a))\n        }\n        y[0] + ((xin-x[0]) / (\u03c10[1]+a))\n    }\n    return t\n}\n\u00a0\n\nvar xVal = {|k| k * 0.05 }.map(^32)\nvar tSin = xVal.map { .sin }\nvar tCos = xVal.map { .cos }\nvar tTan = xVal.map { .tan }\n\u00a0\n\nvar iSin = thiele(tSin, xVal)\nvar iCos = thiele(tCos, xVal)\nvar iTan = thiele(tTan, xVal)\n\u00a0\n\nsay 6*iSin(0.5)\nsay 3*iCos(0.5)\nsay 4*iTan(1)\n", "target": "\n\nimport math\n\ndef thieleInterpolator(x, y):\n    \u03c1 = [[yi]*(len(y)-i) for i, yi in enumerate(y)]\n    for i in range(len(\u03c1)-1):\n        \u03c1[i][1] = (x[i] - x[i+1]) / (\u03c1[i][0] - \u03c1[i+1][0])\n    for i in range(2, len(\u03c1)):\n        for j in range(len(\u03c1)-i):\n            \u03c1[j][i] = (x[j]-x[j+i]) / (\u03c1[j][i-1]-\u03c1[j+1][i-1]) + \u03c1[j+1][i-2]\n    \u03c10 = \u03c1[0]\n    def t(xin):\n        a = 0\n        for i in range(len(\u03c10)-1, 1, -1):\n            a = (xin - x[i-1]) / (\u03c10[i] - \u03c10[i-2] + a)\n        return y[0] + (xin-x[0]) / (\u03c10[1]+a)\n    return t\n\n\nxVal = [i*.05 for i in range(32)]\ntSin = [math.sin(x) for x in xVal]\ntCos = [math.cos(x) for x in xVal]\ntTan = [math.tan(x) for x in xVal]\n\niSin = thieleInterpolator(tSin, xVal)\niCos = thieleInterpolator(tCos, xVal)\niTan = thieleInterpolator(tTan, xVal)\n\nprint('{:16.14f}'.format(6*iSin(.5)))\nprint('{:16.14f}'.format(3*iCos(.5)))\nprint('{:16.14f}'.format(4*iTan(1)))\n"}
{"id": 336614, "name": "Longest string challenge", "source": "Translate Ruby to Python: \nBEGIN {\n   v = [ ]\n   m = 0\n}\n\nn = $_.length\nif n == m then\n   v <<= $_\nelsif n > m then\n   v = [$_]\n   m = n\nend\n\nEND {\n   v.each { |s| puts s }\n}\n", "target": "import fileinput\n\n\n\n\n\n\ndef longer(a, b):\n    try:\n        b[len(a)-1]\n        return False\n    except:\n        return True\n\nlongest, lines = '', ''\nfor x in fileinput.input():\n    if longer(x, longest):\n        lines, longest = x, x\n    elif not longer(longest, x):\n        lines += x\n\nprint(lines, end='')\n"}
{"id": 336615, "name": "Sierpinski arrowhead curve", "source": "Translate Ruby to Python: load_libraries :grammar\nattr_reader :points\n\ndef setup\n  sketch_title 'Sierpinski Arrowhead'\n  sierpinski = SierpinskiArrowhead.new(Vec2D.new(width * 0.15, height * 0.7))\n  production = sierpinski.generate 6 \n  @points = sierpinski.translate_rules(production)\n  no_loop\nend\n  \ndef draw\n  background(0)\n  render points\nend\n\ndef render(points)\n  no_fill\n  stroke 200.0\n  stroke_weight 3\n  begin_shape\n  points.each_slice(2) do |v0, v1|\n    v0.to_vertex(renderer)\n    v1.to_vertex(renderer)\n  end\n  end_shape\nend\n\ndef renderer\n  @renderer ||= GfxRender.new(g)\nend \n\ndef settings  \n  size(800, 800)\nend\n\n\nclass SierpinskiArrowhead\n  include Processing::Proxy\n  attr_reader :draw_length, :pos, :theta, :axiom, :grammar\n  DELTA = PI / 3 \n  def initialize(pos)\n    @axiom = 'XF' \n    rules = {\n      'X' => 'YF+XF+Y',\n      'Y' => 'XF-YF-X'\n    }\n    @grammar = Grammar.new(axiom, rules)\n    @theta = 0\n    @draw_length = 200\n    @pos = pos\n  end\n\n  def generate(gen)\n    @draw_length = draw_length * 0.6**gen\n    grammar.generate gen\n  end\n\n  def forward(pos)\n    pos + Vec2D.from_angle(theta) * draw_length\n  end\n\n  def translate_rules(prod)\n    [].tap do |pts| \n      prod.scan(/./) do |ch|\n        case ch\n        when 'F'\n          new_pos = forward(pos)\n          pts << pos << new_pos\n          @pos = new_pos\n        when '+'\n          @theta += DELTA\n        when '-'\n          @theta -= DELTA\n        when 'X', 'Y'\n        else\n          puts(\"character \n        end\n      end\n    end\n  end\nend\n", "target": "t = { 'x': 20, 'y': 30, 'a': 60 }\n\ndef setup():\n    size(450, 400)\n    background(0, 0, 200)\n    stroke(-1)\n    sc(7, 400, -60)\n\ndef sc(o, l, a, s = t, X = 'x', Y = 'y', A = 'a', HALF = .5):\n    if o:\n        o -= 1\n        l *= HALF\n        sc(o, l, -a)[A] += a\n        sc(o, l, a)[A] += a\n        sc(o, l, -a)\n    else:\n        x, y = s[X], s[Y]\n        s[X] += cos(radians(s[A])) * l\n        s[Y] += sin(radians(s[A])) * l\n        line(x, y, s[X], s[Y])\n\n    return s\n"}
{"id": 336616, "name": "Hello world_Line printer", "source": "Translate Ruby to Python: open(\"| lpr\", \"w\") { |f| f.puts \"Hello World!\" }\n", "target": "lp = open(\"/dev/lp0\")\nlp.write(\"Hello World!\\n\")\nlp.close()\n"}
{"id": 336617, "name": "Hello world_Line printer", "source": "Translate Ruby to Python: open(\"| lpr\", \"w\") { |f| f.puts \"Hello World!\" }\n", "target": "lp = open(\"/dev/lp0\")\nlp.write(\"Hello World!\\n\")\nlp.close()\n"}
{"id": 336618, "name": "Magic squares of odd order", "source": "Translate Ruby to Python: def odd_magic_square(n)\n  raise ArgumentError \"Need odd positive number\" if n.even? || n <= 0\n  n.times.map{|i| n.times.map{|j| n*((i+j+1+n/2)%n) + ((i+2*j-5)%n) + 1} }\nend\n\n[3, 5, 9].each do |n|\n  puts \"\\nSize \n  fmt = \"%\n  odd_magic_square(n).each{|row| puts fmt % row}\nend\n", "target": ">>> def magic(n):\n    for row in range(1, n + 1):\n        print(' '.join('%*i' % (len(str(n**2)), cell) for cell in\n                       (n * ((row + col - 1 + n // 2) % n) +\n                       ((row + 2 * col - 2) % n) + 1\n                       for col in range(1, n + 1))))\n    print('\\nAll sum to magic number %i' % ((n * n + 1) * n // 2))\n\n    \n>>> for n in (5, 3, 7):\n\tprint('\\nOrder %i\\n=======' % n)\n\tmagic(n)\n\n\t\n\nOrder 5\n=======\n17 24  1  8 15\n23  5  7 14 16\n 4  6 13 20 22\n10 12 19 21  3\n11 18 25  2  9\n\nAll sum to magic number 65\n\nOrder 3\n=======\n8 1 6\n3 5 7\n4 9 2\n\nAll sum to magic number 15\n\nOrder 7\n=======\n30 39 48  1 10 19 28\n38 47  7  9 18 27 29\n46  6  8 17 26 35 37\n 5 14 16 25 34 36 45\n13 15 24 33 42 44  4\n21 23 32 41 43  3 12\n22 31 40 49  2 11 20\n\nAll sum to magic number 175\n>>>\n"}
{"id": 336619, "name": "Magic squares of odd order", "source": "Translate Ruby to Python: def odd_magic_square(n)\n  raise ArgumentError \"Need odd positive number\" if n.even? || n <= 0\n  n.times.map{|i| n.times.map{|j| n*((i+j+1+n/2)%n) + ((i+2*j-5)%n) + 1} }\nend\n\n[3, 5, 9].each do |n|\n  puts \"\\nSize \n  fmt = \"%\n  odd_magic_square(n).each{|row| puts fmt % row}\nend\n", "target": ">>> def magic(n):\n    for row in range(1, n + 1):\n        print(' '.join('%*i' % (len(str(n**2)), cell) for cell in\n                       (n * ((row + col - 1 + n // 2) % n) +\n                       ((row + 2 * col - 2) % n) + 1\n                       for col in range(1, n + 1))))\n    print('\\nAll sum to magic number %i' % ((n * n + 1) * n // 2))\n\n    \n>>> for n in (5, 3, 7):\n\tprint('\\nOrder %i\\n=======' % n)\n\tmagic(n)\n\n\t\n\nOrder 5\n=======\n17 24  1  8 15\n23  5  7 14 16\n 4  6 13 20 22\n10 12 19 21  3\n11 18 25  2  9\n\nAll sum to magic number 65\n\nOrder 3\n=======\n8 1 6\n3 5 7\n4 9 2\n\nAll sum to magic number 15\n\nOrder 7\n=======\n30 39 48  1 10 19 28\n38 47  7  9 18 27 29\n46  6  8 17 26 35 37\n 5 14 16 25 34 36 45\n13 15 24 33 42 44  4\n21 23 32 41 43  3 12\n22 31 40 49  2 11 20\n\nAll sum to magic number 175\n>>>\n"}
{"id": 336620, "name": "Sutherland-Hodgman polygon clipping", "source": "Translate Ruby to Python: Point = Struct.new(:x,:y) do\n  def to_s; \"(\nend\n\ndef sutherland_hodgman(subjectPolygon, clipPolygon)\n  \n  \n  cp1, cp2, s, e = nil\n  inside = proc do |p|\n    (cp2.x-cp1.x)*(p.y-cp1.y) > (cp2.y-cp1.y)*(p.x-cp1.x)\n  end\n  intersection = proc do\n    dcx, dcy = cp1.x-cp2.x, cp1.y-cp2.y\n    dpx, dpy = s.x-e.x, s.y-e.y\n    n1 = cp1.x*cp2.y - cp1.y*cp2.x\n    n2 = s.x*e.y - s.y*e.x\n    n3 = 1.0 / (dcx*dpy - dcy*dpx)\n    Point[(n1*dpx - n2*dcx) * n3, (n1*dpy - n2*dcy) * n3]\n  end\n  \n  outputList = subjectPolygon\n  cp1 = clipPolygon.last\n  for cp2 in clipPolygon\n    inputList = outputList\n    outputList = []\n    s = inputList.last\n    for e in inputList\n      if inside[e]\n        outputList << intersection[] unless inside[s]\n        outputList << e\n      elsif inside[s]\n        outputList << intersection[]\n      end\n      s = e\n    end\n    cp1 = cp2\n  end\n  outputList\nend\n\nsubjectPolygon = [[50, 150], [200, 50], [350, 150], [350, 300],\n                  [250, 300], [200, 250], [150, 350], [100, 250],\n                  [100, 200]].collect{|pnt| Point[*pnt]}\n \nclipPolygon = [[100, 100], [300, 100], [300, 300], [100, 300]].collect{|pnt| Point[*pnt]}\n \nputs sutherland_hodgman(subjectPolygon, clipPolygon)\n", "target": "def clip(subjectPolygon, clipPolygon):\n   def inside(p):\n      return(cp2[0]-cp1[0])*(p[1]-cp1[1]) > (cp2[1]-cp1[1])*(p[0]-cp1[0])\n      \n   def computeIntersection():\n      dc = [ cp1[0] - cp2[0], cp1[1] - cp2[1] ]\n      dp = [ s[0] - e[0], s[1] - e[1] ]\n      n1 = cp1[0] * cp2[1] - cp1[1] * cp2[0]\n      n2 = s[0] * e[1] - s[1] * e[0] \n      n3 = 1.0 / (dc[0] * dp[1] - dc[1] * dp[0])\n      return [(n1*dp[0] - n2*dc[0]) * n3, (n1*dp[1] - n2*dc[1]) * n3]\n\n   outputList = subjectPolygon\n   cp1 = clipPolygon[-1]\n   \n   for clipVertex in clipPolygon:\n      cp2 = clipVertex\n      inputList = outputList\n      outputList = []\n      s = inputList[-1]\n\n      for subjectVertex in inputList:\n         e = subjectVertex\n         if inside(e):\n            if not inside(s):\n               outputList.append(computeIntersection())\n            outputList.append(e)\n         elif inside(s):\n            outputList.append(computeIntersection())\n         s = e\n      cp1 = cp2\n   return(outputList)\n"}
{"id": 336621, "name": "Sorting algorithms_Pancake sort", "source": "Translate Ruby to Python: class Array\n  def pancake_sort!\n    num_flips = 0\n    (self.size-1).downto(1) do |end_idx|\n      max     = self[0..end_idx].max\n      max_idx = self[0..end_idx].index(max)\n      next if max_idx == end_idx\n      \n      if max_idx > 0\n        self[0..max_idx] = self[0..max_idx].reverse \n        p [num_flips += 1, self]  if $DEBUG\n      end\n      \n      self[0..end_idx] = self[0..end_idx].reverse \n      p [num_flips += 1, self]  if $DEBUG\n    end\n    self\n  end\nend\n\np a = (1..9).to_a.shuffle\np a.pancake_sort!\n", "target": "tutor = False\n\ndef pancakesort(data):\n    if len(data) <= 1:\n        return data\n    if tutor: print()\n    for size in range(len(data), 1, -1):\n        maxindex = max(range(size), key=data.__getitem__)\n        if maxindex+1 != size:\n            \n            if maxindex != 0:\n                \n                if tutor: print('With: %r doflip  %i'\n                                % ( ' '.join(str(x) for x in data), maxindex+1 ))\n                data[:maxindex+1] = reversed(data[:maxindex+1])\n            \n            if tutor: print('With: %r  doflip %i'\n                                % ( ' '.join(str(x) for x in data), size ))\n            data[:size] = reversed(data[:size])\n    if tutor: print()\n"}
{"id": 336622, "name": "Call a function", "source": "Translate Ruby to Python: def foo() p \"foo\" end\n\nfoo                             \nfoo()                           \n", "target": "def no_args():\n    pass\n\nno_args()\n\ndef fixed_args(x, y):\n    print('x=%r, y=%r' % (x, y))\n\nfixed_args(1, 2)        \n\n\nfixed_args(y=2, x=1)\n\n\nmyargs=(1,2) \nfixed_args(*myargs)\n\ndef opt_args(x=1):\n    print(x)\n\nopt_args()              \nopt_args(3.141)         \n\ndef var_args(*v):\n    print(v)\n\nvar_args(1, 2, 3)       \nvar_args(1, (2,3))      \nvar_args()              \n\n\nfixed_args(y=2, x=1)    \n\n\nif 1:\n    no_args()\n\n\nassert no_args() is None\n\ndef return_something():\n    return 1\nx = return_something()\n\ndef is_builtin(x):\n\tprint(x.__name__ in dir(__builtins__))\n\nis_builtin(pow)         \nis_builtin(is_builtin)  \n\n\n\ndef takes_anything(*args, **kwargs):\n    for each in args:\n        print(each)\n    for key, value in sorted(kwargs.items()):\n        print(\"%s:%s\" % (key, value))\n    \n    wrapped_fn(*args, **kwargs)\n    \n    \n\n\n\n\n\n\n\n\n\n"}
{"id": 336623, "name": "Call a function", "source": "Translate Ruby to Python: def foo() p \"foo\" end\n\nfoo                             \nfoo()                           \n", "target": "def no_args():\n    pass\n\nno_args()\n\ndef fixed_args(x, y):\n    print('x=%r, y=%r' % (x, y))\n\nfixed_args(1, 2)        \n\n\nfixed_args(y=2, x=1)\n\n\nmyargs=(1,2) \nfixed_args(*myargs)\n\ndef opt_args(x=1):\n    print(x)\n\nopt_args()              \nopt_args(3.141)         \n\ndef var_args(*v):\n    print(v)\n\nvar_args(1, 2, 3)       \nvar_args(1, (2,3))      \nvar_args()              \n\n\nfixed_args(y=2, x=1)    \n\n\nif 1:\n    no_args()\n\n\nassert no_args() is None\n\ndef return_something():\n    return 1\nx = return_something()\n\ndef is_builtin(x):\n\tprint(x.__name__ in dir(__builtins__))\n\nis_builtin(pow)         \nis_builtin(is_builtin)  \n\n\n\ndef takes_anything(*args, **kwargs):\n    for each in args:\n        print(each)\n    for key, value in sorted(kwargs.items()):\n        print(\"%s:%s\" % (key, value))\n    \n    wrapped_fn(*args, **kwargs)\n    \n    \n\n\n\n\n\n\n\n\n\n"}
{"id": 336624, "name": "Extract file extension", "source": "Translate Ruby to Python: names = \n%w(http://example.com/download.tar.gz\n   CharacterModel.3DS\n   .desktop\n   document\n   /etc/pam.d/login)\nnames.each{|name| p File.extname(name)}\n", "target": "import re\ndef extractExt(url):\n  m = re.search(r'\\.[A-Za-z0-9]+$', url)\n  return m.group(0) if m else \"\"\n"}
{"id": 336625, "name": "Extract file extension", "source": "Translate Ruby to Python: names = \n%w(http://example.com/download.tar.gz\n   CharacterModel.3DS\n   .desktop\n   document\n   /etc/pam.d/login)\nnames.each{|name| p File.extname(name)}\n", "target": "import re\ndef extractExt(url):\n  m = re.search(r'\\.[A-Za-z0-9]+$', url)\n  return m.group(0) if m else \"\"\n"}
{"id": 336626, "name": "Solve the no connection puzzle", "source": "Translate Ruby to Python: \n\n\n\nrequire 'HLPSolver'\nADJACENT = [[0,0]]\nA,B,C,D,E,F,G,H = [0,1],[0,2],[1,0],[1,1],[1,2],[1,3],[2,1],[2,2]\n\nboard1 = <<EOS\n  . 0 0 .\n  0 0 1 0 \n  . 0 0 .\n\nEOS\ng = HLPsolver.new(board1)\ng.board[A[0]][A[1]].adj = [B,G,H,F]            \ng.board[B[0]][B[1]].adj = [A,C,G,H]            \ng.board[C[0]][C[1]].adj = [B,E,F,H]          \ng.board[D[0]][D[1]].adj = [F]                \ng.board[E[0]][E[1]].adj = [C]                \ng.board[F[0]][F[1]].adj = [A,C,D,G]          \ng.board[G[0]][G[1]].adj = [A,B,F,H]            \ng.board[H[0]][H[1]].adj = [A,B,C,G]            \ng.solve\n", "target": "from __future__ import print_function\nfrom itertools import permutations\nfrom enum import Enum\n\nA, B, C, D, E, F, G, H = Enum('Peg', 'A, B, C, D, E, F, G, H')\n\nconnections = ((A, C), (A, D), (A, E),\n               (B, D), (B, E), (B, F),\n               (G, C), (G, D), (G, E),\n               (H, D), (H, E), (H, F),\n               (C, D), (D, E), (E, F))\n\n\ndef ok(conn, perm):\n    \n    this, that = (c.value - 1 for c in conn)\n    return abs(perm[this] - perm[that]) != 1\n\n\ndef solve():\n    return [perm for perm in permutations(range(1, 9))\n            if all(ok(conn, perm) for conn in connections)]\n\n\nif __name__ == '__main__':\n    solutions = solve()\n    print(\"A, B, C, D, E, F, G, H =\", ', '.join(str(i) for i in solutions[0]))\n"}
{"id": 336627, "name": "Permutation test", "source": "Translate Ruby to Python: def statistic(ab, a)\n  sumab, suma = ab.inject(:+).to_f, a.inject(:+).to_f\n  suma / a.size - (sumab - suma) / (ab.size - a.size)\nend\n\ndef permutationTest(a, b)\n  ab = a + b\n  tobs = statistic(ab, a)\n  under = count = 0\n  ab.combination(a.size) do |perm|\n    under += 1 if statistic(ab, perm) <= tobs\n    count += 1\n  end\n  under * 100.0 / count\nend\n\ntreatmentGroup = [85, 88, 75, 66, 25, 29, 83, 39, 97]\ncontrolGroup   = [68, 41, 10, 49, 16, 65, 32, 92, 28, 98]\nunder = permutationTest(treatmentGroup, controlGroup)\nputs \"under=%.2f%%, over=%.2f%%\" % [under, 100 - under]\n", "target": "from itertools import combinations as comb\n\ndef statistic(ab, a):\n    sumab, suma = sum(ab), sum(a)\n    return ( suma / len(a) -\n             (sumab -suma) / (len(ab) - len(a)) )\n\ndef permutationTest(a, b):\n    ab = a + b\n    Tobs = statistic(ab, a)\n    under = 0\n    for count, perm in enumerate(comb(ab, len(a)), 1):\n        if statistic(ab, perm) <= Tobs:\n            under += 1\n    return under * 100. / count\n\ntreatmentGroup = [85, 88, 75, 66, 25, 29, 83, 39, 97]\ncontrolGroup   = [68, 41, 10, 49, 16, 65, 32, 92, 28, 98]\nunder = permutationTest(treatmentGroup, controlGroup)\nprint(\"under=%.2f%%, over=%.2f%%\" % (under, 100. - under))\n"}
{"id": 336628, "name": "Image convolution", "source": "Translate Ruby to Python: class Pixmap\n  \n  def convolute(kernel)\n    newimg = Pixmap.new(@width, @height)\n    pb = ProgressBar.new(@width) if $DEBUG\n    @width.times do |x|\n      @height.times do |y|\n        apply_kernel(x, y, kernel, newimg)\n      end\n      pb.update(x) if $DEBUG\n    end\n    pb.close if $DEBUG\n    newimg\n  end\n\n  \n  def apply_kernel(x, y, kernel, newimg)\n    x0 = x==0 ? 0 : x-1\n    y0 = y==0 ? 0 : y-1\n    x1 = x\n    y1 = y\n    x2 = x+1==@width  ? x : x+1\n    y2 = y+1==@height ? y : y+1\n \n    r = g = b = 0.0\n    [x0, x1, x2].zip(kernel).each do |xx, kcol|\n      [y0, y1, y2].zip(kcol).each do |yy, k|\n        r += k * self[xx,yy].r\n        g += k * self[xx,yy].g\n        b += k * self[xx,yy].b\n      end\n    end\n    newimg[x,y] = RGBColour.new(luma(r), luma(g), luma(b))\n  end\n\n  \n  def luma(value)\n    if value < 0\n      0\n    elsif value > 255\n      255\n    else\n      value\n    end\n  end\nend\n\n \n\nteapot = Pixmap.open('teapot.ppm')\n[ ['Emboss',  [[-2.0, -1.0, 0.0],  [-1.0, 1.0, 1.0],  [0.0, 1.0, 2.0]]], \n  ['Sharpen', [[-1.0, -1.0, -1.0], [-1.0, 9.0, -1.0], [-1.0, -1.0, -1.0]]], \n  ['Blur',    [[0.1111,0.1111,0.1111],[0.1111,0.1111,0.1111],[0.1111,0.1111,0.1111]]],\n].each do |label, kernel|\n  savefile = 'teapot_' + label.downcase + '.ppm'\n  teapot.convolute(kernel).save(savefile)\nend\n", "target": "\nfrom PIL import Image, ImageFilter\n\nif __name__==\"__main__\":\n\tim = Image.open(\"test.jpg\")\n\n\tkernelValues = [-2,-1,0,-1,1,1,0,1,2] \n\tkernel = ImageFilter.Kernel((3,3), kernelValues)\n\n\tim2 = im.filter(kernel)\n\n\tim2.show()\n"}
{"id": 336629, "name": "Copy a string", "source": "Translate Ruby to Python: original = \"hello\"\nreference = original          \ncopy1 = original.dup          \ncopy2 = String.new(original)  \n\noriginal << \" world!\"         \np reference                   \np copy1                       \np copy2                       \n", "target": ">>> src = \"hello\"\n>>> a = src\n>>> b = src[:]\n>>> import copy\n>>> c = copy.copy(src)\n>>> d = copy.deepcopy(src)\n>>> src is a is b is c is d\nTrue\n"}
{"id": 336630, "name": "Keyboard input_Obtain a Y or N response", "source": "Translate Ruby to Python: def yesno\n  begin\n    system(\"stty raw -echo\")\n    str = STDIN.getc\n  ensure\n    system(\"stty -raw echo\")\n  end\n  if str == \"Y\"\n    return true\n  elsif str == \"N\"\n    return false\n  else\n    raise \"Invalid character.\"\n  end\nend\n", "target": "\n\ntry:\n    from msvcrt import getch\nexcept ImportError:\n    def getch():\n        import sys, tty, termios\n        fd = sys.stdin.fileno()\n        old_settings = termios.tcgetattr(fd)\n        try:\n            tty.setraw(sys.stdin.fileno())\n            ch = sys.stdin.read(1)\n        finally:\n            termios.tcsetattr(fd, termios.TCSADRAIN, old_settings)\n        return ch\n\nprint \"Press Y or N to continue\"\nwhile True:\n    char = getch()\n    if char.lower() in (\"y\", \"n\"):\n        print char\n        break\n"}
{"id": 336631, "name": "Keyboard input_Obtain a Y or N response", "source": "Translate Ruby to Python: def yesno\n  begin\n    system(\"stty raw -echo\")\n    str = STDIN.getc\n  ensure\n    system(\"stty -raw echo\")\n  end\n  if str == \"Y\"\n    return true\n  elsif str == \"N\"\n    return false\n  else\n    raise \"Invalid character.\"\n  end\nend\n", "target": "\n\ntry:\n    from msvcrt import getch\nexcept ImportError:\n    def getch():\n        import sys, tty, termios\n        fd = sys.stdin.fileno()\n        old_settings = termios.tcgetattr(fd)\n        try:\n            tty.setraw(sys.stdin.fileno())\n            ch = sys.stdin.read(1)\n        finally:\n            termios.tcsetattr(fd, termios.TCSADRAIN, old_settings)\n        return ch\n\nprint \"Press Y or N to continue\"\nwhile True:\n    char = getch()\n    if char.lower() in (\"y\", \"n\"):\n        print char\n        break\n"}
{"id": 336632, "name": "Abbreviations, simple", "source": "Translate Ruby to Python: str = \"add 1  alter 3  backup 2  bottom 1  Cappend 2  change 1  Schange  Cinsert 2  Clast 3 \n   compress 4 copy 2 count 3 Coverlay 3 cursor 3  delete 3 Cdelete 2  down 1  duplicate\n   3 xEdit 1 expand 3 extract 3  find 1 Nfind 2 Nfindup 6 NfUP 3 Cfind 2 findUP 3 fUP 2\n   forward 2  get  help 1 hexType 4  input 1 powerInput 3  join 1 split 2 spltJOIN load\n   locate 1 Clocate 2 lowerCase 3 upperCase 3 Lprefix 2  macro  merge 2 modify 3 move 2\n   msg  next 1 overlay 1 parse preserve 4 purge 3 put putD query 1 quit  read recover 3\n   refresh renum 3 repeat 3 replace 1 Creplace 2 reset 3 restore 4 rgtLEFT right 2 left\n   2  save  set  shift 2  si  sort  sos  stack 3 status 4 top  transfer 3  type 1  up 1\"\n\nRE = /(?<word1>[a-zA-Z]+)\\s+(?<word2>[a-zA-Z]+)/\nstr = str.upcase\n\n2.times{ str.gsub!(RE){ [  $~[:word1], $~[:word1].size, $~[:word2] ].join(\" \")} }\n\ntable = Hash[*str.split].transform_values(&:to_i)\n\ntest =  \"riG   rePEAT copies  put mo   rest    types   fup.    6       poweRin\"\nar = test.split.map do |w|\n  (res = table.detect{|k,v| k.start_with?(w.upcase) && w.size >= v}) ? res[0] : \"*error*\"\nend\n\nputs ar.join(\" \")\n", "target": "command_table_text = \n\nuser_words = \"riG   rePEAT copies  put mo   rest    types   fup.    6       poweRin\"\n\n\ndef find_abbreviations_length(command_table_text):\n    \n    command_table = dict()\n    input_iter = iter(command_table_text.split())\n\n    word = None\n    try:\n        while True:\n            if word is None:\n                word = next(input_iter)\n            abbr_len = next(input_iter, len(word))\n            try:\n                command_table[word] = int(abbr_len)\n                word = None\n            except ValueError:\n                command_table[word] = len(word)\n                word = abbr_len\n    except StopIteration:\n        pass\n    return command_table\n\n\ndef find_abbreviations(command_table):\n    \n    abbreviations = dict()\n    for command, min_abbr_len in command_table.items():\n        for l in range(min_abbr_len, len(command)+1):\n            abbr = command[:l].lower()\n            abbreviations[abbr] = command.upper()\n    return abbreviations\n\n\ndef parse_user_string(user_string, abbreviations):\n    user_words = [word.lower() for word in user_string.split()]\n    commands = [abbreviations.get(user_word, \"*error*\") for user_word in user_words]\n    return \" \".join(commands)\n\n\ncommand_table = find_abbreviations_length(command_table_text)\nabbreviations_table = find_abbreviations(command_table)\n\nfull_words = parse_user_string(user_words, abbreviations_table)\n\nprint(\"user words:\", user_words)\nprint(\"full words:\", full_words)\n"}
{"id": 336633, "name": "Abbreviations, simple", "source": "Translate Ruby to Python: str = \"add 1  alter 3  backup 2  bottom 1  Cappend 2  change 1  Schange  Cinsert 2  Clast 3 \n   compress 4 copy 2 count 3 Coverlay 3 cursor 3  delete 3 Cdelete 2  down 1  duplicate\n   3 xEdit 1 expand 3 extract 3  find 1 Nfind 2 Nfindup 6 NfUP 3 Cfind 2 findUP 3 fUP 2\n   forward 2  get  help 1 hexType 4  input 1 powerInput 3  join 1 split 2 spltJOIN load\n   locate 1 Clocate 2 lowerCase 3 upperCase 3 Lprefix 2  macro  merge 2 modify 3 move 2\n   msg  next 1 overlay 1 parse preserve 4 purge 3 put putD query 1 quit  read recover 3\n   refresh renum 3 repeat 3 replace 1 Creplace 2 reset 3 restore 4 rgtLEFT right 2 left\n   2  save  set  shift 2  si  sort  sos  stack 3 status 4 top  transfer 3  type 1  up 1\"\n\nRE = /(?<word1>[a-zA-Z]+)\\s+(?<word2>[a-zA-Z]+)/\nstr = str.upcase\n\n2.times{ str.gsub!(RE){ [  $~[:word1], $~[:word1].size, $~[:word2] ].join(\" \")} }\n\ntable = Hash[*str.split].transform_values(&:to_i)\n\ntest =  \"riG   rePEAT copies  put mo   rest    types   fup.    6       poweRin\"\nar = test.split.map do |w|\n  (res = table.detect{|k,v| k.start_with?(w.upcase) && w.size >= v}) ? res[0] : \"*error*\"\nend\n\nputs ar.join(\" \")\n", "target": "command_table_text = \n\nuser_words = \"riG   rePEAT copies  put mo   rest    types   fup.    6       poweRin\"\n\n\ndef find_abbreviations_length(command_table_text):\n    \n    command_table = dict()\n    input_iter = iter(command_table_text.split())\n\n    word = None\n    try:\n        while True:\n            if word is None:\n                word = next(input_iter)\n            abbr_len = next(input_iter, len(word))\n            try:\n                command_table[word] = int(abbr_len)\n                word = None\n            except ValueError:\n                command_table[word] = len(word)\n                word = abbr_len\n    except StopIteration:\n        pass\n    return command_table\n\n\ndef find_abbreviations(command_table):\n    \n    abbreviations = dict()\n    for command, min_abbr_len in command_table.items():\n        for l in range(min_abbr_len, len(command)+1):\n            abbr = command[:l].lower()\n            abbreviations[abbr] = command.upper()\n    return abbreviations\n\n\ndef parse_user_string(user_string, abbreviations):\n    user_words = [word.lower() for word in user_string.split()]\n    commands = [abbreviations.get(user_word, \"*error*\") for user_word in user_words]\n    return \" \".join(commands)\n\n\ncommand_table = find_abbreviations_length(command_table_text)\nabbreviations_table = find_abbreviations(command_table)\n\nfull_words = parse_user_string(user_words, abbreviations_table)\n\nprint(\"user words:\", user_words)\nprint(\"full words:\", full_words)\n"}
{"id": 336634, "name": "String comparison", "source": "Translate Ruby to Python: method_names = [:==,:!=, :>, :>=, :<, :<=, :<=>, :casecmp]\n[[\"YUP\", \"YUP\"], [\"YUP\", \"Yup\"], [\"bot\",\"bat\"], [\"aaa\", \"zz\"]].each do |str1, str2|\n  method_names.each{|m| puts \"%s %s %s\\t%s\" % [str1, m, str2, str1.send(m, str2)]}\n  puts\nend\n", "target": "fun compare(a, b):\n    print(\"\\n$a is of type ${typeof(a)} and $b is of type ${typeof(b)}\")\n    if a < b: print(\"$a is strictly less than $b\")\n    if a <= b: print(\"$a is less than or equal to $b\")\n    if a >  b: print(\"$a is strictly greater than $b\")\n    if a >= b: print(\"$a is greater than or equal to $b\")\n    if a == b: print(\"$a is equal to $b\")\n    if a != b: print(\"$a is not equal to $b\")\n    if a is b: print(\"$a has object identity with $b\")\n    if a is not b: print(\"$a has negated object identity with $b\")\n\ncompare(\"YUP\", \"YUP\")\ncompare('a', 'z')\ncompare(\"24\", \"123\")\ncompare(24, 123)\ncompare(5.0, 5)\n"}
{"id": 336635, "name": "Find prime numbers of the form n_n_n+2", "source": "Translate Ruby to Python: require 'prime'\np (1..200).filter_map{|n| cand = n**3 + 2; cand if cand.prime? }\n", "target": "\n\ndef isPrime(n):\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return False        \n    return True\n\nif __name__ == '__main__':\n    for n in range(1, 200):\n        if isPrime(n**3+2):\n            print(f'{n}\\t{n**3+2}');\n"}
{"id": 336636, "name": "Find prime numbers of the form n_n_n+2", "source": "Translate Ruby to Python: require 'prime'\np (1..200).filter_map{|n| cand = n**3 + 2; cand if cand.prime? }\n", "target": "\n\ndef isPrime(n):\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return False        \n    return True\n\nif __name__ == '__main__':\n    for n in range(1, 200):\n        if isPrime(n**3+2):\n            print(f'{n}\\t{n**3+2}');\n"}
{"id": 336637, "name": "Pseudo-random numbers_Middle-square method", "source": "Translate Ruby to Python: def middle_square (seed)\n  return to_enum(__method__, seed) unless block_given?\n  s = seed.digits.size\n  loop { yield seed = (seed*seed).to_s.rjust(s*2, \"0\")[s/2, s].to_i }\nend\n\nputs middle_square(675248).take(5)\n", "target": "seed = 675248\ndef random():\n    global seed\n    seed = int(str(seed ** 2).zfill(12)[3:9])\n    return seed\nfor _ in range(5):\n    print(random())\n"}
{"id": 336638, "name": "Pseudo-random numbers_Middle-square method", "source": "Translate Ruby to Python: def middle_square (seed)\n  return to_enum(__method__, seed) unless block_given?\n  s = seed.digits.size\n  loop { yield seed = (seed*seed).to_s.rjust(s*2, \"0\")[s/2, s].to_i }\nend\n\nputs middle_square(675248).take(5)\n", "target": "seed = 675248\ndef random():\n    global seed\n    seed = int(str(seed ** 2).zfill(12)[3:9])\n    return seed\nfor _ in range(5):\n    print(random())\n"}
{"id": 336639, "name": "Entropy_Narcissist", "source": "Translate Ruby to Python: def entropy(s)\n  counts = s.chars.each_with_object(Hash(Char, Float64).new(0.0)) { |c, h| h[c] += 1 }\n  counts.values.sum do |count|\n    freq = count / s.size\n    -freq * Math.log2(freq)\n  end\nend\n\nputs entropy File.read(__FILE__)\n", "target": "import math\nfrom collections import Counter\n\ndef entropy(s):\n    p, lns = Counter(s), float(len(s))\n    return -sum( count/lns * math.log(count/lns, 2) for count in p.values())\n\nwith open(__file__) as f:\n    b=f.read()\n    \nprint(entropy(b))\n"}
{"id": 336640, "name": "Entropy_Narcissist", "source": "Translate Ruby to Python: def entropy(s)\n  counts = s.chars.each_with_object(Hash(Char, Float64).new(0.0)) { |c, h| h[c] += 1 }\n  counts.values.sum do |count|\n    freq = count / s.size\n    -freq * Math.log2(freq)\n  end\nend\n\nputs entropy File.read(__FILE__)\n", "target": "import math\nfrom collections import Counter\n\ndef entropy(s):\n    p, lns = Counter(s), float(len(s))\n    return -sum( count/lns * math.log(count/lns, 2) for count in p.values())\n\nwith open(__file__) as f:\n    b=f.read()\n    \nprint(entropy(b))\n"}
{"id": 336641, "name": "Draw a pixel", "source": "Translate Ruby to Python: require 'gtk3'\n\nWidth, Height = 320, 240\nPosX, PosY = 100, 100\n\nwindow = Gtk::Window.new\nwindow.set_default_size(Width, Height)\nwindow.title = 'Draw a pixel'\n\nwindow.signal_connect(:draw) do |widget, context|\n  context.set_antialias(Cairo::Antialias::NONE)\n  \n  \n  \n  \n  context.set_source_rgb(1.0, 0.0, 0.0)\n  context.fill do\n    context.rectangle(PosX, PosY, 1, 1)\n  end\nend\n\nwindow.signal_connect(:destroy) { Gtk.main_quit }\n\nwindow.show\nGtk.main\n", "target": "from PIL import Image\n\nimg = Image.new('RGB', (320, 240))\npixels = img.load()\npixels[100,100] = (255,0,0)\nimg.show()\n"}
{"id": 336642, "name": "Verify distribution uniformity_Naive", "source": "Translate Ruby to Python: def distcheck(n, delta=1)\n  unless block_given?\n    raise ArgumentError, \"pass a block to this method\"\n  end\n  \n  h = Hash.new(0)\n  n.times {h[ yield ] += 1}\n  \n  target = 1.0 * n / h.length\n  h.each do |key, value| \n    if (value - target).abs > 0.01 * delta * n\n      raise StandardError,\n        \"distribution potentially skewed for '\n    end\n  end\n  \n  puts h.sort.map{|k, v| \"\nend\n\nif __FILE__ == $0\n  begin\n    distcheck(100_000) {rand(10)}\n    distcheck(100_000) {rand > 0.95} \n  rescue StandardError => e\n    p e\n  end\nend\n", "target": "from collections import Counter\nfrom pprint import pprint as pp\n\ndef distcheck(fn, repeats, delta):\n    \n    bin = Counter(fn() for i in range(repeats))\n    target = repeats // len(bin)\n    deltacount = int(delta / 100. * target)\n    assert all( abs(target - count) < deltacount\n                for count in bin.values() ), \"Bin distribution skewed from %i +/- %i: %s\" % (\n                    target, deltacount, [ (key, target - count)\n                                          for key, count in sorted(bin.items()) ]\n                    )\n    pp(dict(bin))\n"}
{"id": 336643, "name": "Use another language to call a function", "source": "Translate Ruby to Python: \nrequire 'fiddle'\n\n\n\nc_var = Fiddle.dlopen(nil)['QueryPointer']\n\nint = Fiddle::TYPE_INT\nvoidp = Fiddle::TYPE_VOIDP\nsz_voidp = Fiddle::SIZEOF_VOIDP\n\n\n\n\n\n\nQuery = Fiddle::Closure::BlockCaller\n          .new(int, [voidp, voidp]) do |datap, lengthp|\n  message = \"Here am I\"\n\n  \n  \n  length = lengthp[0, sz_voidp].unpack('J').first\n\n  \n  if length < message.bytesize\n    0  \n  else\n    length = message.bytesize\n    datap[0, length] = message  \n    lengthp[0, sz_voidp] = [length].pack('J')  \n    1  \n  end\nend\n\n\nFiddle::Pointer.new(c_var)[0, sz_voidp] = [Query.to_i].pack('J')\n", "target": "\n\ndef query(buffer_length):\n    message = b'Here am I'\n    L = len(message)\n    return message[0:L*(L <= buffer_length)]\n"}
{"id": 336644, "name": "Find first and last set bit of a long integer", "source": "Translate Ruby to Python: def msb(x)\n  x.bit_length - 1\nend\n\ndef lsb(x)\n  msb(x & -x)\nend\n\n6.times do |i|\n  x = 42 ** i\n  puts \"%10d MSB: %2d LSB: %2d\" % [x, msb(x), lsb(x)]\nend\n\n6.times do |i|\n  x = 1302 ** i\n  puts \"%20d MSB: %2d LSB: %2d\" % [x, msb(x), lsb(x)]\nend\n", "target": "def msb(x):\n    return x.bit_length() - 1\n\ndef lsb(x):\n    return msb(x & -x)\n\nfor i in range(6):\n    x = 42 ** i\n    print(\"%10d MSB: %2d LSB: %2d\" % (x, msb(x), lsb(x)))\n\nfor i in range(6):\n    x = 1302 ** i\n    print(\"%20d MSB: %2d LSB: %2d\" % (x, msb(x), lsb(x)))\n"}
{"id": 336645, "name": "Find first and last set bit of a long integer", "source": "Translate Ruby to Python: def msb(x)\n  x.bit_length - 1\nend\n\ndef lsb(x)\n  msb(x & -x)\nend\n\n6.times do |i|\n  x = 42 ** i\n  puts \"%10d MSB: %2d LSB: %2d\" % [x, msb(x), lsb(x)]\nend\n\n6.times do |i|\n  x = 1302 ** i\n  puts \"%20d MSB: %2d LSB: %2d\" % [x, msb(x), lsb(x)]\nend\n", "target": "def msb(x):\n    return x.bit_length() - 1\n\ndef lsb(x):\n    return msb(x & -x)\n\nfor i in range(6):\n    x = 42 ** i\n    print(\"%10d MSB: %2d LSB: %2d\" % (x, msb(x), lsb(x)))\n\nfor i in range(6):\n    x = 1302 ** i\n    print(\"%20d MSB: %2d LSB: %2d\" % (x, msb(x), lsb(x)))\n"}
{"id": 336646, "name": "Bioinformatics_Sequence mutation", "source": "Translate Ruby to Python: class DNA_Seq\n  attr_accessor :seq\n  \n  def initialize(bases: %i[A C G T] , size: 0)\n    @bases = bases\n    @seq   = Array.new(size){ bases.sample }\n  end\n  \n  def mutate(n = 10)\n    n.times{|n| method([:s, :d, :i].sample).call}\n  end\n  \n  def to_s(n = 50)\n    just_size = @seq.size / n\n    (0...@seq.size).step(n).map{|from|  \"\n    \"\\nTotal \n  end\n\n  def s = @seq[rand_index]= @bases.sample  \n  def d = @seq.delete_at(rand_index)\n  def i = @seq.insert(rand_index, @bases.sample )\n  alias :swap   :s \n  alias :delete :d\n  alias :insert :i\n    \n  private\n  def rand_index = rand( @seq.size )\nend\n\nputs test = DNA_Seq.new(size: 200)\ntest.mutate\nputs test\ntest.delete\nputs test\n", "target": "import random\nfrom collections import Counter\n\ndef basecount(dna):\n    return sorted(Counter(dna).items())\n\ndef seq_split(dna, n=50):\n    return [dna[i: i+n] for i in range(0, len(dna), n)]\n\ndef seq_pp(dna, n=50):\n    for i, part in enumerate(seq_split(dna, n)):\n        print(f\"{i*n:>5}: {part}\")\n    print(\"\\n  BASECOUNT:\")\n    tot = 0\n    for base, count in basecount(dna):\n        print(f\"    {base:>3}: {count}\")\n        tot += count\n    base, count = 'TOT', tot\n    print(f\"    {base:>3}= {count}\")\n\ndef seq_mutate(dna, count=1, kinds=\"IDSSSS\", choice=\"ATCG\" ):\n    mutation = []\n    k2txt = dict(I='Insert', D='Delete', S='Substitute')\n    for _ in range(count):\n        kind = random.choice(kinds)\n        index = random.randint(0, len(dna))\n        if kind == 'I':    \n            dna = dna[:index] + random.choice(choice) + dna[index:]\n        elif kind == 'D' and dna:  \n            dna = dna[:index] + dna[index+1:]\n        elif kind == 'S' and dna:  \n            dna = dna[:index] + random.choice(choice) + dna[index+1:]\n        mutation.append((k2txt[kind], index))\n    return dna, mutation\n\nif __name__ == '__main__':\n    length = 250\n    print(\"SEQUENCE:\")\n    sequence = ''.join(random.choices('ACGT', weights=(1, 0.8, .9, 1.1), k=length))\n    seq_pp(sequence)\n    print(\"\\n\\nMUTATIONS:\")\n    mseq, m = seq_mutate(sequence, 10)\n    for kind, index in m:\n        print(f\" {kind:>10} @{index}\")\n    print()\n    seq_pp(mseq)\n"}
{"id": 336647, "name": "Bioinformatics_Sequence mutation", "source": "Translate Ruby to Python: class DNA_Seq\n  attr_accessor :seq\n  \n  def initialize(bases: %i[A C G T] , size: 0)\n    @bases = bases\n    @seq   = Array.new(size){ bases.sample }\n  end\n  \n  def mutate(n = 10)\n    n.times{|n| method([:s, :d, :i].sample).call}\n  end\n  \n  def to_s(n = 50)\n    just_size = @seq.size / n\n    (0...@seq.size).step(n).map{|from|  \"\n    \"\\nTotal \n  end\n\n  def s = @seq[rand_index]= @bases.sample  \n  def d = @seq.delete_at(rand_index)\n  def i = @seq.insert(rand_index, @bases.sample )\n  alias :swap   :s \n  alias :delete :d\n  alias :insert :i\n    \n  private\n  def rand_index = rand( @seq.size )\nend\n\nputs test = DNA_Seq.new(size: 200)\ntest.mutate\nputs test\ntest.delete\nputs test\n", "target": "import random\nfrom collections import Counter\n\ndef basecount(dna):\n    return sorted(Counter(dna).items())\n\ndef seq_split(dna, n=50):\n    return [dna[i: i+n] for i in range(0, len(dna), n)]\n\ndef seq_pp(dna, n=50):\n    for i, part in enumerate(seq_split(dna, n)):\n        print(f\"{i*n:>5}: {part}\")\n    print(\"\\n  BASECOUNT:\")\n    tot = 0\n    for base, count in basecount(dna):\n        print(f\"    {base:>3}: {count}\")\n        tot += count\n    base, count = 'TOT', tot\n    print(f\"    {base:>3}= {count}\")\n\ndef seq_mutate(dna, count=1, kinds=\"IDSSSS\", choice=\"ATCG\" ):\n    mutation = []\n    k2txt = dict(I='Insert', D='Delete', S='Substitute')\n    for _ in range(count):\n        kind = random.choice(kinds)\n        index = random.randint(0, len(dna))\n        if kind == 'I':    \n            dna = dna[:index] + random.choice(choice) + dna[index:]\n        elif kind == 'D' and dna:  \n            dna = dna[:index] + dna[index+1:]\n        elif kind == 'S' and dna:  \n            dna = dna[:index] + random.choice(choice) + dna[index+1:]\n        mutation.append((k2txt[kind], index))\n    return dna, mutation\n\nif __name__ == '__main__':\n    length = 250\n    print(\"SEQUENCE:\")\n    sequence = ''.join(random.choices('ACGT', weights=(1, 0.8, .9, 1.1), k=length))\n    seq_pp(sequence)\n    print(\"\\n\\nMUTATIONS:\")\n    mseq, m = seq_mutate(sequence, 10)\n    for kind, index in m:\n        print(f\" {kind:>10} @{index}\")\n    print()\n    seq_pp(mseq)\n"}
{"id": 336648, "name": "Colour bars_Display", "source": "Translate Ruby to Python: \nPALETTE = %w[\n\ndef settings\n  full_screen\nend\n\ndef setup\n  PALETTE.each_with_index do |col, idx|\n    fill color(col)\n    rect(idx * width / 8, 0, width / 8, height)\n  end\nend\n", "target": "\n\n\nfrom livewires import *\n\nhoriz=640; vert=480\nbegin_graphics(width=horiz,height=vert,title=\"v_stripes\",background=Colour.black)\nNameColors=[\"black\",\"red\",\"green\",\"dark_blue\",\"purple\",\"blue\",\"yellow\",\"white\"]\nstepik=horiz/len(NameColors)\n\nfor index,each in enumerate(NameColors):\n\tExcStrng=\"set_colour(Colour.\"+each+\")\"\n\texec ExcStrng\n\tbox(index*stepik,0,(index+1)*stepik,vert,filled=1)\n\nwhile keys_pressed() != ['x']: \n\tpass\n\nend_graphics()\n"}
{"id": 336649, "name": "Colour bars_Display", "source": "Translate Ruby to Python: \nPALETTE = %w[\n\ndef settings\n  full_screen\nend\n\ndef setup\n  PALETTE.each_with_index do |col, idx|\n    fill color(col)\n    rect(idx * width / 8, 0, width / 8, height)\n  end\nend\n", "target": "\n\n\nfrom livewires import *\n\nhoriz=640; vert=480\nbegin_graphics(width=horiz,height=vert,title=\"v_stripes\",background=Colour.black)\nNameColors=[\"black\",\"red\",\"green\",\"dark_blue\",\"purple\",\"blue\",\"yellow\",\"white\"]\nstepik=horiz/len(NameColors)\n\nfor index,each in enumerate(NameColors):\n\tExcStrng=\"set_colour(Colour.\"+each+\")\"\n\texec ExcStrng\n\tbox(index*stepik,0,(index+1)*stepik,vert,filled=1)\n\nwhile keys_pressed() != ['x']: \n\tpass\n\nend_graphics()\n"}
{"id": 336650, "name": "Dining philosophers", "source": "Translate Ruby to Python: require 'mutex_m'\n\nclass Philosopher\n  def initialize(name, left_fork, right_fork)\n    @name = name\n    @left_fork = left_fork\n    @right_fork = right_fork\n    @meals = 0\n  end\n\n  def go\n    while @meals < 5\n      think\n      dine\n    end\n    puts \"philosopher \n  end\n\n  def think\n    puts \"philosopher \n    sleep(rand())\n    puts \"philosopher \n  end\n\n  def dine\n    fork1, fork2 = @left_fork, @right_fork\n    while true\n      pickup(fork1, :wait => true)\n      puts \"philosopher \n      if pickup(fork2, :wait => false)\n        break\n      end\n      puts \"philosopher \n      release(fork1)\n      fork1, fork2 = fork2, fork1\n    end\n    puts \"philosopher \n\n    puts \"philosopher \n    sleep(rand())\n    puts \"philosopher \n    @meals += 1\n\n    release(@left_fork)\n    release(@right_fork)\n  end\n\n  def pickup(fork, opt)\n    puts \"philosopher \n    opt[:wait] ? fork.mutex.mu_lock : fork.mutex.mu_try_lock\n  end\n\n  def release(fork)\n    puts \"philosopher \n    fork.mutex.unlock\n  end\nend\n\nn = 5\n\nFork = Struct.new(:fork_id, :mutex)\nforks = Array.new(n) {|i| Fork.new(i, Object.new.extend(Mutex_m))}\n\nphilosophers = Array.new(n) do |i| \n                 Thread.new(i, forks[i], forks[(i+1)%n]) do |id, f1, f2|\n                   ph = Philosopher.new(id, f1, f2).go\n                 end\n               end\n  \nphilosophers.each {|thread| thread.join}\n", "target": "import threading\nimport random\nimport time\n\n\n\n\n\n\n\n\n\n\nclass Philosopher(threading.Thread):\n    \n    running = True\n\n    def __init__(self, xname, forkOnLeft, forkOnRight):\n        threading.Thread.__init__(self)\n        self.name = xname\n        self.forkOnLeft = forkOnLeft\n        self.forkOnRight = forkOnRight\n\n    def run(self):\n        while(self.running):\n            \n            time.sleep( random.uniform(3,13))\n            print '%s is hungry.' % self.name\n            self.dine()\n\n    def dine(self):\n        fork1, fork2 = self.forkOnLeft, self.forkOnRight\n\n        while self.running:\n            fork1.acquire(True)\n            locked = fork2.acquire(False)\n            if locked: break\n            fork1.release()\n            print '%s swaps forks' % self.name\n            fork1, fork2 = fork2, fork1\n        else:\n            return\n\n        self.dining()\n        fork2.release()\n        fork1.release()\n\n    def dining(self):\t\t\t\n        print '%s starts eating '% self.name\n        time.sleep(random.uniform(1,10))\n        print '%s finishes eating and leaves to think.' % self.name\n\ndef DiningPhilosophers():\n    forks = [threading.Lock() for n in range(5)]\n    philosopherNames = ('Aristotle','Kant','Spinoza','Marx', 'Russel')\n\n    philosophers= [Philosopher(philosopherNames[i], forks[i%5], forks[(i+1)%5]) \\\n            for i in range(5)]\n\n    random.seed(507129)\n    Philosopher.running = True\n    for p in philosophers: p.start()\n    time.sleep(100)\n    Philosopher.running = False\n    print (\"Now we're finishing.\")\n\nDiningPhilosophers()\n"}
{"id": 336651, "name": "Exceptions", "source": "Translate Ruby to Python: \nclass SillyError < Exception\nend\n", "target": "import exceptions\nclass SillyError(exceptions.Exception):\n    def __init__(self,args=None):\n         self.args=args\n"}
{"id": 336652, "name": "24 game", "source": "Translate Ruby to Python: class Guess < String\n  def self.play\n    nums = Array.new(4){rand(1..9)}\n    loop do\n      result = get(nums).evaluate!\n      break if result == 24.0\n      puts \"Try again! That gives \n    end\n    puts \"You win!\"\n  end\n  \n  def self.get(nums)\n    loop do\n      print \"\\nEnter a guess using \n      input = gets.chomp\n      return new(input) if validate(input, nums)\n    end\n  end\n  \n  def self.validate(guess, nums)\n    name, error =\n      {\n        invalid_character:  ->(str){ !str.scan(%r{[^\\d\\s()+*/-]}).empty? },\n        wrong_number:       ->(str){ str.scan(/\\d/).map(&:to_i).sort != nums.sort },\n        multi_digit_number: ->(str){ str.match(/\\d\\d/) }\n      }\n        .find {|name, validator| validator[guess] }\n    \n    error ? puts(\"Invalid input of a(n) \n  end\n  \n  def evaluate!\n    as_rat = gsub(/(\\d)/, '\\1r')        \n    eval \"(\n  rescue SyntaxError\n    \"[syntax error]\"\n  end\nend\n\nGuess.play\n", "target": "\n\nfrom __future__ import division, print_function\nimport random, ast, re\nimport sys\n\nif sys.version_info[0] < 3: input = raw_input\n\ndef choose4():\n    'four random digits >0 as characters'\n    return [str(random.randint(1,9)) for i in range(4)]\n\ndef welcome(digits):\n    print (__doc__)\n    print (\"Your four digits: \" + ' '.join(digits))\n\ndef check(answer, digits):\n    allowed = set('() +-*/\\t'+''.join(digits))\n    ok = all(ch in allowed for ch in answer) and \\\n         all(digits.count(dig) == answer.count(dig) for dig in set(digits)) \\\n         and not re.search('\\d\\d', answer)\n    if ok:\n        try:\n            ast.parse(answer)\n        except:\n            ok = False\n    return ok\n\ndef main():    \n    digits = choose4()\n    welcome(digits)\n    trial = 0\n    answer = ''\n    chk = ans = False\n    while not (chk and ans == 24):\n        trial +=1\n        answer = input(\"Expression %i: \" % trial)\n        chk = check(answer, digits)\n        if answer.lower() == 'q':\n            break\n        if answer == '!':\n            digits = choose4()\n            print (\"New digits:\", ' '.join(digits))\n            continue\n        if not chk:\n            print (\"The input '%s' was wonky!\" % answer)\n        else:\n            ans = eval(answer)\n            print (\" = \", ans)\n            if ans == 24:\n                print (\"Thats right!\")\n    print (\"Thank you and goodbye\")   \n\nif __name__ == '__main__': main()\n"}
{"id": 336653, "name": "24 game", "source": "Translate Ruby to Python: class Guess < String\n  def self.play\n    nums = Array.new(4){rand(1..9)}\n    loop do\n      result = get(nums).evaluate!\n      break if result == 24.0\n      puts \"Try again! That gives \n    end\n    puts \"You win!\"\n  end\n  \n  def self.get(nums)\n    loop do\n      print \"\\nEnter a guess using \n      input = gets.chomp\n      return new(input) if validate(input, nums)\n    end\n  end\n  \n  def self.validate(guess, nums)\n    name, error =\n      {\n        invalid_character:  ->(str){ !str.scan(%r{[^\\d\\s()+*/-]}).empty? },\n        wrong_number:       ->(str){ str.scan(/\\d/).map(&:to_i).sort != nums.sort },\n        multi_digit_number: ->(str){ str.match(/\\d\\d/) }\n      }\n        .find {|name, validator| validator[guess] }\n    \n    error ? puts(\"Invalid input of a(n) \n  end\n  \n  def evaluate!\n    as_rat = gsub(/(\\d)/, '\\1r')        \n    eval \"(\n  rescue SyntaxError\n    \"[syntax error]\"\n  end\nend\n\nGuess.play\n", "target": "\n\nfrom __future__ import division, print_function\nimport random, ast, re\nimport sys\n\nif sys.version_info[0] < 3: input = raw_input\n\ndef choose4():\n    'four random digits >0 as characters'\n    return [str(random.randint(1,9)) for i in range(4)]\n\ndef welcome(digits):\n    print (__doc__)\n    print (\"Your four digits: \" + ' '.join(digits))\n\ndef check(answer, digits):\n    allowed = set('() +-*/\\t'+''.join(digits))\n    ok = all(ch in allowed for ch in answer) and \\\n         all(digits.count(dig) == answer.count(dig) for dig in set(digits)) \\\n         and not re.search('\\d\\d', answer)\n    if ok:\n        try:\n            ast.parse(answer)\n        except:\n            ok = False\n    return ok\n\ndef main():    \n    digits = choose4()\n    welcome(digits)\n    trial = 0\n    answer = ''\n    chk = ans = False\n    while not (chk and ans == 24):\n        trial +=1\n        answer = input(\"Expression %i: \" % trial)\n        chk = check(answer, digits)\n        if answer.lower() == 'q':\n            break\n        if answer == '!':\n            digits = choose4()\n            print (\"New digits:\", ' '.join(digits))\n            continue\n        if not chk:\n            print (\"The input '%s' was wonky!\" % answer)\n        else:\n            ans = eval(answer)\n            print (\" = \", ans)\n            if ans == 24:\n                print (\"Thats right!\")\n    print (\"Thank you and goodbye\")   \n\nif __name__ == '__main__': main()\n"}
{"id": 336654, "name": "Enforced immutability", "source": "Translate Ruby to Python: msg = \"Hello World\"\nmsg << \"!\"\nputs msg                \n\nputs msg.frozen?        \nmsg.freeze\nputs msg.frozen?        \nbegin\n  msg << \"!\"\nrescue => e\n  p e                   \nend\n\nputs msg                \nmsg2 = msg\n\n\nmsg = \"hello world\"     \n\nputs msg.frozen?        \nputs msg2.frozen?       \n", "target": ">>> s = \"Hello\"\n>>> s[0] = \"h\"\n\nTraceback (most recent call last):\n  File \"<pyshell\n    s[0] = \"h\"\nTypeError: 'str' object does not support item assignment\n"}
{"id": 336655, "name": "Strange numbers", "source": "Translate Ruby to Python: def digits(n)\n    result = []\n    while n > 0\n        rem = n % 10\n        result.unshift(rem)\n        n = n / 10\n    end\n    return result\nend\n\ndef isStrange(n)\n    def test(a, b)\n        abs = (a - b).abs\n        return abs == 2 || abs == 3 || abs == 5 || abs == 7\n    end\n\n    xs = digits(n)\n    for i in 1 .. xs.length - 1\n        if !test(xs[i - 1], xs[i]) then\n            return false\n        end\n    end\n    return true\nend\n\nxs = []\nfor i in 100 .. 500\n    if isStrange(i) then\n        xs << i\n    end\nend\n\nprint \"Strange numbers in range [100 .. 500]\\n\"\nprint \"(Total: %d)\\n\\n\" % [xs.length]\n\nxs.each_slice(10) do |s|\n    print s, \"\\n\"\nend\n", "target": "\n\n\n\ndef isStrange(n):\n    \n    def test(a, b):\n        return abs(a - b) in [2, 3, 5, 7]\n\n    xs = digits(n)\n    return all(map(test, xs, xs[1:]))\n\n\n\n\ndef main():\n    \n\n    xs = [\n        n for n in range(100, 1 + 500)\n        if isStrange(n)\n    ]\n    print('\\nStrange numbers in range [100..500]\\n')\n    print('(Total: ' + str(len(xs)) + ')\\n')\n    print(\n        '\\n'.join(\n            ' '.join(\n                str(x) for x in row\n            ) for row in chunksOf(10)(xs)\n        )\n    )\n\n\n\n\n\ndef chunksOf(n):\n    \n    def go(xs):\n        return (\n            xs[i:n + i] for i in range(0, len(xs), n)\n        ) if 0 < n else None\n    return go\n\n\n\ndef digits(n):\n    \n    return [int(c) for c in str(n)]\n\n\n\nif __name__ == '__main__':\n    main()\n"}
{"id": 336656, "name": "Strange numbers", "source": "Translate Ruby to Python: def digits(n)\n    result = []\n    while n > 0\n        rem = n % 10\n        result.unshift(rem)\n        n = n / 10\n    end\n    return result\nend\n\ndef isStrange(n)\n    def test(a, b)\n        abs = (a - b).abs\n        return abs == 2 || abs == 3 || abs == 5 || abs == 7\n    end\n\n    xs = digits(n)\n    for i in 1 .. xs.length - 1\n        if !test(xs[i - 1], xs[i]) then\n            return false\n        end\n    end\n    return true\nend\n\nxs = []\nfor i in 100 .. 500\n    if isStrange(i) then\n        xs << i\n    end\nend\n\nprint \"Strange numbers in range [100 .. 500]\\n\"\nprint \"(Total: %d)\\n\\n\" % [xs.length]\n\nxs.each_slice(10) do |s|\n    print s, \"\\n\"\nend\n", "target": "\n\n\n\ndef isStrange(n):\n    \n    def test(a, b):\n        return abs(a - b) in [2, 3, 5, 7]\n\n    xs = digits(n)\n    return all(map(test, xs, xs[1:]))\n\n\n\n\ndef main():\n    \n\n    xs = [\n        n for n in range(100, 1 + 500)\n        if isStrange(n)\n    ]\n    print('\\nStrange numbers in range [100..500]\\n')\n    print('(Total: ' + str(len(xs)) + ')\\n')\n    print(\n        '\\n'.join(\n            ' '.join(\n                str(x) for x in row\n            ) for row in chunksOf(10)(xs)\n        )\n    )\n\n\n\n\n\ndef chunksOf(n):\n    \n    def go(xs):\n        return (\n            xs[i:n + i] for i in range(0, len(xs), n)\n        ) if 0 < n else None\n    return go\n\n\n\ndef digits(n):\n    \n    return [int(c) for c in str(n)]\n\n\n\nif __name__ == '__main__':\n    main()\n"}
{"id": 336657, "name": "Hofstadter Q sequence", "source": "Translate Ruby to Python: @cache = []\ndef Q(n)\n  if @cache[n].nil?\n    case n\n    when 1, 2 then @cache[n] = 1\n    else @cache[n] = Q(n - Q(n-1)) + Q(n - Q(n-2))\n    end\n  end\n  @cache[n]\nend\n\nputs \"first 10 numbers in the sequence: \nputs \"1000'th term: \n\nprev = Q(1)\ncount = 0\n2.upto(100_000) do |n| \n  q = Q(n)\n  count += 1 if q < prev \n  prev = q\nend\nputs \"number of times in the first 100,000 terms where Q(i)<Q(i-1): \n", "target": "def q(n):\n    if n < 1 or type(n) != int: raise ValueError(\"n must be an int >= 1\")\n    try:\n        return q.seq[n]\n    except IndexError:\n        ans = q(n - q(n - 1)) + q(n - q(n - 2))\n        q.seq.append(ans)\n        return ans\nq.seq = [None, 1, 1]\n\nif __name__ == '__main__':\n    first10 = [q(i) for i in range(1,11)]\n    assert first10 == [1, 1, 2, 3, 3, 4, 5, 5, 6, 6], \"Q() value error(s)\"\n    print(\"Q(n) for n = [1..10] is:\", ', '.join(str(i) for i in first10))\n    assert q(1000) == 502, \"Q(1000) value error\"\n    print(\"Q(1000) =\", q(1000))\n"}
{"id": 336658, "name": "Hofstadter Q sequence", "source": "Translate Ruby to Python: @cache = []\ndef Q(n)\n  if @cache[n].nil?\n    case n\n    when 1, 2 then @cache[n] = 1\n    else @cache[n] = Q(n - Q(n-1)) + Q(n - Q(n-2))\n    end\n  end\n  @cache[n]\nend\n\nputs \"first 10 numbers in the sequence: \nputs \"1000'th term: \n\nprev = Q(1)\ncount = 0\n2.upto(100_000) do |n| \n  q = Q(n)\n  count += 1 if q < prev \n  prev = q\nend\nputs \"number of times in the first 100,000 terms where Q(i)<Q(i-1): \n", "target": "def q(n):\n    if n < 1 or type(n) != int: raise ValueError(\"n must be an int >= 1\")\n    try:\n        return q.seq[n]\n    except IndexError:\n        ans = q(n - q(n - 1)) + q(n - q(n - 2))\n        q.seq.append(ans)\n        return ans\nq.seq = [None, 1, 1]\n\nif __name__ == '__main__':\n    first10 = [q(i) for i in range(1,11)]\n    assert first10 == [1, 1, 2, 3, 3, 4, 5, 5, 6, 6], \"Q() value error(s)\"\n    print(\"Q(n) for n = [1..10] is:\", ', '.join(str(i) for i in first10))\n    assert q(1000) == 502, \"Q(1000) value error\"\n    print(\"Q(1000) =\", q(1000))\n"}
{"id": 336659, "name": "Count occurrences of a substring", "source": "Translate Ruby to Python: def countSubstrings str, subStr\n  str.scan(subStr).length\nend\n\np countSubstrings \"the three truths\", \"th\"      \np countSubstrings \"ababababab\", \"abab\"          \n", "target": ">>> \"the three truths\".count(\"th\")\n3\n>>> \"ababababab\".count(\"abab\")\n2\n"}
{"id": 336660, "name": "Append numbers at same position in strings", "source": "Translate Ruby to Python: list1 = (1..9)  .to_a\nlist2 = (10..18).to_a\nlist3 = (19..27).to_a\n\np list = [list1, list2, list3].transpose.map{|trio| trio.join.to_i }\n", "target": "list1 = [1, 2, 3, 4, 5, 6, 7, 8, 9]\nlist2 = [10, 11, 12, 13, 14, 15, 16, 17, 18]\nlist3 = [19, 20, 21, 22, 23, 24, 25, 26, 27]\n\nprint([\n    ''.join(str(n) for n in z) for z\n    in zip(list1, list2, list3)\n])\n"}
{"id": 336661, "name": "Append numbers at same position in strings", "source": "Translate Ruby to Python: list1 = (1..9)  .to_a\nlist2 = (10..18).to_a\nlist3 = (19..27).to_a\n\np list = [list1, list2, list3].transpose.map{|trio| trio.join.to_i }\n", "target": "list1 = [1, 2, 3, 4, 5, 6, 7, 8, 9]\nlist2 = [10, 11, 12, 13, 14, 15, 16, 17, 18]\nlist3 = [19, 20, 21, 22, 23, 24, 25, 26, 27]\n\nprint([\n    ''.join(str(n) for n in z) for z\n    in zip(list1, list2, list3)\n])\n"}
{"id": 336662, "name": "Logistic curve fitting in epidemiology", "source": "Translate Ruby to Python: K = 7.9e9\nN0 = 27\nACTUAL = [\n    27, 27, 27, 44, 44, 59, 59, 59, 59, 59, 59, 59, 59, 60, 60,\n    61, 61, 66, 83, 219, 239, 392, 534, 631, 897, 1350, 2023, 2820,\n    4587, 6067, 7823, 9826, 11946, 14554, 17372, 20615, 24522, 28273,\n    31491, 34933, 37552, 40540, 43105, 45177, 60328, 64543, 67103,\n    69265, 71332, 73327, 75191, 75723, 76719, 77804, 78812, 79339,\n    80132, 80995, 82101, 83365, 85203, 87024, 89068, 90664, 93077,\n    95316, 98172, 102133, 105824, 109695, 114232, 118610, 125497,\n    133852, 143227, 151367, 167418, 180096, 194836, 213150, 242364,\n    271106, 305117, 338133, 377918, 416845, 468049, 527767, 591704,\n    656866, 715353, 777796, 851308, 928436, 1000249, 1082054, 1174652\n]\n\ndef f(r)\n    sq = 0.0\n    len = ACTUAL.length\n    for i in 1 .. len\n        j = i - 1\n        eri = Math.exp(r * j)\n        guess = (N0 * eri) / (1 + N0 * (eri - 1.0) / K)\n        diff = guess - ACTUAL[j]\n        sq += diff * diff\n    end\n    return sq\nend\n\ndef solve(fn, guess=0.5, epsilon=0.0)\n    delta = guess ? guess : 1.0\n    f0 = send(fn, guess)\n    factor = 2.0\n    while delta > epsilon and guess != guess - delta\n        nf = send(fn, guess - delta)\n        if nf < f0 then\n            f0 = nf\n            guess -= delta\n        else\n            nf = send(fn, guess + delta)\n            if nf < f0 then\n                f0 = nf\n                guess += delta\n            else\n                factor = 0.5\n            end\n        end\n\n        delta *= factor\n    end\n    return guess\nend\n\ndef main\n    r = solve(:f)\n    r0 = Math.exp(12.0 * r)\n    print \"r = \", r, \", R0 = \", r0, \"\\n\"\nend\n\nmain()\n", "target": "import numpy as np\nimport scipy.optimize as opt\n\nn0, K = 27, 7_800_000_000\n\ndef f(t, r):\n    return (n0 * np.exp(r * t)) / (( 1 + n0 * (np.exp(r * t) - 1) / K))\n\ny = [\n27, 27, 27, 44, 44, 59, 59, 59, 59, 59, 59, 59, 59, 60, 60,\n61, 61, 66, 83, 219, 239, 392, 534, 631, 897, 1350, 2023,\n2820, 4587, 6067, 7823, 9826, 11946, 14554, 17372, 20615,\n24522, 28273, 31491, 34933, 37552, 40540, 43105, 45177,\n60328, 64543, 67103, 69265, 71332, 73327, 75191, 75723,\n76719, 77804, 78812, 79339, 80132, 80995, 82101, 83365,\n85203, 87024, 89068, 90664, 93077, 95316, 98172, 102133,\n105824, 109695, 114232, 118610, 125497, 133852, 143227,\n151367, 167418, 180096, 194836, 213150, 242364, 271106,\n305117, 338133, 377918, 416845, 468049, 527767, 591704,\n656866, 715353, 777796, 851308, 928436, 1000249, 1082054,\n1174652,\n]\nx = np.linspace(0.0, 96, 97)\n\nr, cov = opt.curve_fit(f, x, y, [0.5])\n\n\nprint(\"The r for the world Covid-19 data is:\", r,\n    \", with covariance of\", cov)   \nprint(\"The calculated R0 is then\", np.exp(12 * r))\n"}
{"id": 336663, "name": "User input_Graphical", "source": "Translate Ruby to Python: require 'tk'\n\ndef main\n  root = TkRoot.new\n  l1 = TkLabel.new(root, \"text\" => \"input a string\")\n  e1 = TkEntry.new(root)\n  l2 = TkLabel.new(root, \"text\" => \"input the number 75000\")\n  e2 = TkEntry.new(root) do\n    validate \"focusout\"\n    validatecommand lambda {e2.value.to_i == 75_000}\n    invalidcommand  lambda {focus_number_entry(e2)}\n  end\n  ok = TkButton.new(root) do\n    text \"OK\"\n    command lambda {validate_input(e1, e2)}\n  end\n  Tk.grid(l1, e1)\n  Tk.grid(l2, e2)\n  Tk.grid(\"x\",ok, \"sticky\" => \"w\")  \n  Tk.mainloop\nend\n\ndef validate_input(text_entry, number_entry)\n  if number_entry.value.to_i != 75_000\n    focus_number_entry(number_entry)\n  else\n    puts %Q{You entered: \"\n    root.destroy\n  end\nend\n\ndef focus_number_entry(widget)\n  widget \\\n    .configure(\"background\" => \"red\", \"foreground\" => \"white\") \\\n    .selection_range(0, \"end\") \\\n    .focus\nend\n\nmain\n", "target": "from javax.swing import JOptionPane\n\ndef to_int(n, default=0):\n    try:\n        return int(n)\n    except ValueError:\n        return default\n\nnumber = to_int(JOptionPane.showInputDialog (\"Enter an Integer\")) \nprintln(number)\n\na_string = JOptionPane.showInputDialog (\"Enter a String\")\nprintln(a_string)\n"}
{"id": 336664, "name": "Carmichael 3 strong pseudoprimes", "source": "Translate Ruby to Python: \n\nrequire 'prime'\n\nPrime.each(61) do |p|\n  (2...p).each do |h3|\n    g = h3 + p\n    (1...g).each do |d|\n      next if (g*(p-1)) % d != 0 or (-p*p) % h3 != d % h3\n      q = 1 + ((p - 1) * g / d)\n      next unless q.prime?\n      r = 1 + (p * q / h3)\n      next unless r.prime? and (q * r) % (p - 1) == 1\n      puts \"\n    end\n  end\n  puts\nend\n", "target": "class Isprime():\n    \n    multiples = {2}\n    primes = [2]\n    nmax = 2\n    \n    def __init__(self, nmax):\n        if nmax > self.nmax:\n            self.check(nmax)\n\n    def check(self, n):\n        if type(n) == float:\n            if not n.is_integer(): return False\n            n = int(n)\n        multiples = self.multiples\n        if n <= self.nmax:\n            return n not in multiples\n        else:\n            \n            primes, nmax = self.primes, self.nmax\n            newmax = max(nmax*2, n)\n            for p in primes:\n                multiples.update(range(p*((nmax + p + 1) // p), newmax+1, p))\n            for i in range(nmax+1, newmax+1):\n                if i not in multiples:\n                    primes.append(i)\n                    multiples.update(range(i*2, newmax+1, i))\n            self.nmax = newmax\n            return n not in multiples\n\n    __call__ = check\n            \n        \ndef carmichael(p1):\n    ans = []\n    if isprime(p1):\n        for h3 in range(2, p1):\n            g = h3 + p1\n            for d in range(1, g):\n                if (g * (p1 - 1)) % d == 0 and (-p1 * p1) % h3 == d % h3:\n                    p2 = 1 + ((p1 - 1)* g // d)\n                    if isprime(p2):\n                        p3 = 1 + (p1 * p2 // h3)\n                        if isprime(p3):\n                            if (p2 * p3) % (p1 - 1) == 1:\n                                \n                                ans += [tuple(sorted((p1, p2, p3)))]\n    return ans\n                \nisprime = Isprime(2)\n \nans = sorted(sum((carmichael(n) for n in range(62) if isprime(n)), []))\nprint(',\\n'.join(repr(ans[i:i+5])[1:-1] for i in range(0, len(ans)+1, 5)))\n"}
{"id": 336665, "name": "Find square difference", "source": "Translate Ruby to Python: p (1..).detect{|n| n*n - (n-1)*(n-1) > 1000 }\n", "target": "import math\nprint(\"working...\")\nlimit1 = 6000\nlimit2 = 1000\noldSquare = 0\nnewSquare = 0\n\nfor n in range(limit1):\n    newSquare = n*n\n    if (newSquare - oldSquare > limit2):\n     print(\"Least number is = \", end = \"\");\n     print(int(math.sqrt(newSquare)))\n     break\n    oldSquare = n*n\n\nprint(\"done...\")\nprint()\n"}
{"id": 336666, "name": "Find square difference", "source": "Translate Ruby to Python: p (1..).detect{|n| n*n - (n-1)*(n-1) > 1000 }\n", "target": "import math\nprint(\"working...\")\nlimit1 = 6000\nlimit2 = 1000\noldSquare = 0\nnewSquare = 0\n\nfor n in range(limit1):\n    newSquare = n*n\n    if (newSquare - oldSquare > limit2):\n     print(\"Least number is = \", end = \"\");\n     print(int(math.sqrt(newSquare)))\n     break\n    oldSquare = n*n\n\nprint(\"done...\")\nprint()\n"}
{"id": 336667, "name": "Snake", "source": "Translate Ruby to Python: class SnakeGame(w, h) {\n    const readkey = frequire('Term::ReadKey')\n    const ansi    = frequire('Term::ANSIColor')\n\n    enum (VOID, HEAD, BODY, TAIL, FOOD)\n\n    define (\n        LEFT  = [+0, -1],\n        RIGHT = [+0, +1],\n        UP    = [-1, +0],\n        DOWN  = [+1, +0],\n    )\n\n    define BG_COLOR    = \"on_black\"\n    define FOOD_COLOR  = (\"red\"        + \" \" + BG_COLOR)\n    define SNAKE_COLOR = (\"bold green\" + \" \" + BG_COLOR)\n    define SLEEP_SEC   = 0.02\n\n    const (\n        A_VOID  = ansi.colored(' ', BG_COLOR),\n        A_FOOD  = ansi.colored('\u2747', FOOD_COLOR),\n        A_BLOCK = ansi.colored('\u25a0', SNAKE_COLOR),\n    )\n\n    has dir = LEFT\n    has grid = [[]]\n    has head_pos = [0, 0]\n    has tail_pos = [0, 0]\n\n    method init {\n        grid = h.of { w.of { [VOID] } }\n\n        head_pos = [h//2, w//2]\n        tail_pos = [head_pos[0], head_pos[1]+1]\n\n        grid[head_pos[0]][head_pos[1]] = [HEAD, dir]    \n        grid[tail_pos[0]][tail_pos[1]] = [TAIL, dir]    \n\n        self.make_food()\n    }\n\n    method make_food {\n        var (food_x, food_y)\n\n        do {\n            food_x = w.rand.int\n            food_y = h.rand.int\n        } while (grid[food_y][food_x][0] != VOID)\n\n        grid[food_y][food_x][0] = FOOD\n    }\n\n    method display {\n        print(\"\\033[H\", grid.map { |row|\n            row.map { |cell|\n                given (cell[0]) {\n                    when (VOID) { A_VOID }\n                    when (FOOD) { A_FOOD }\n                    default     { A_BLOCK }\n                }\n              }.join('')\n            }.join(\"\\n\")\n        )\n    }\n\n    method move {\n        var grew = false\n\n        \n        var (y, x) = head_pos...\n\n        var new_y = (y+dir[0] % h)\n        var new_x = (x+dir[1] % w)\n\n        var cell = grid[new_y][new_x]\n\n        given (cell[0]) {\n            when (BODY) { die \"\\nYou just bit your own body!\\n\" }\n            when (TAIL) { die \"\\nYou just bit your own tail!\\n\" }\n            when (FOOD) { grew = true; self.make_food()         }\n        }\n\n        \n        grid[new_y][new_x] = [HEAD, dir]\n\n        \n        grid[y][x] = [BODY, dir]\n\n        \n        head_pos = [new_y, new_x]\n\n        \n        if (!grew) {\n            var (y, x) = tail_pos...\n\n            var pos   = grid[y][x][1]\n            var new_y = (y+pos[0] % h)\n            var new_x = (x+pos[1] % w)\n\n            grid[y][x][0]         = VOID    \n            grid[new_y][new_x][0] = TAIL    \n\n            tail_pos = [new_y, new_x]\n        }\n    }\n\n    method play {\n        STDOUT.autoflush(true)\n        readkey.ReadMode(3)\n\n        try {\n            loop {\n                var key\n                while (!defined(key = readkey.ReadLine(-1))) {\n                    self.move()\n                    self.display()\n                    Sys.sleep(SLEEP_SEC)\n                }\n\n                given (key) {\n                    when (\"\\e[A\") { if (dir != DOWN ) { dir = UP    } }\n                    when (\"\\e[B\") { if (dir != UP   ) { dir = DOWN  } }\n                    when (\"\\e[C\") { if (dir != LEFT ) { dir = RIGHT } }\n                    when (\"\\e[D\") { if (dir != RIGHT) { dir = LEFT  } }\n                }\n            }\n        }\n        catch {\n            readkey.ReadMode(0)\n        }\n    }\n}\n\nvar w = `tput cols`.to_i\nvar h = `tput lines`.to_i\n\nSnakeGame(w || 80, h || 24).play\n", "target": "from __future__ import annotations\n\nimport itertools\nimport random\n\nfrom enum import Enum\n\nfrom typing import Any\nfrom typing import Tuple\n\nimport pygame as pg\n\nfrom pygame import Color\nfrom pygame import Rect\n\nfrom pygame.surface import Surface\n\nfrom pygame.sprite import AbstractGroup\nfrom pygame.sprite import Group\nfrom pygame.sprite import RenderUpdates\nfrom pygame.sprite import Sprite\n\n\nclass Direction(Enum):\n    UP = (0, -1)\n    DOWN = (0, 1)\n    LEFT = (-1, 0)\n    RIGHT = (1, 0)\n\n    def opposite(self, other: Direction):\n        return (self[0] + other[0], self[1] + other[1]) == (0, 0)\n\n    def __getitem__(self, i: int):\n        return self.value[i]\n\n\nclass SnakeHead(Sprite):\n    def __init__(\n        self,\n        size: int,\n        position: Tuple[int, int],\n        facing: Direction,\n        bounds: Rect,\n    ) -> None:\n        super().__init__()\n        self.image = Surface((size, size))\n        self.image.fill(Color(\"aquamarine4\"))\n        self.rect = self.image.get_rect()\n        self.rect.center = position\n        self.facing = facing\n        self.size = size\n        self.speed = size\n        self.bounds = bounds\n\n    def update(self, *args: Any, **kwargs: Any) -> None:\n        \n        self.rect.move_ip(\n            (\n                self.facing[0] * self.speed,\n                self.facing[1] * self.speed,\n            )\n        )\n\n        \n        if self.rect.right > self.bounds.right:\n            self.rect.left = 0\n        elif self.rect.left < 0:\n            self.rect.right = self.bounds.right\n\n        if self.rect.bottom > self.bounds.bottom:\n            self.rect.top = 0\n        elif self.rect.top < 0:\n            self.rect.bottom = self.bounds.bottom\n\n    def change_direction(self, direction: Direction):\n        if not self.facing == direction and not direction.opposite(self.facing):\n            self.facing = direction\n\n\nclass SnakeBody(Sprite):\n    def __init__(\n        self,\n        size: int,\n        position: Tuple[int, int],\n        colour: str = \"white\",\n    ) -> None:\n        super().__init__()\n        self.image = Surface((size, size))\n        self.image.fill(Color(colour))\n        self.rect = self.image.get_rect()\n        self.rect.center = position\n\n\nclass Snake(RenderUpdates):\n    def __init__(self, game: Game) -> None:\n        self.segment_size = game.segment_size\n        self.colours = itertools.cycle([\"aquamarine1\", \"aquamarine3\"])\n\n        self.head = SnakeHead(\n            size=self.segment_size,\n            position=game.rect.center,\n            facing=Direction.RIGHT,\n            bounds=game.rect,\n        )\n\n        neck = [\n            SnakeBody(\n                size=self.segment_size,\n                position=game.rect.center,\n                colour=next(self.colours),\n            )\n            for _ in range(2)\n        ]\n\n        super().__init__(*[self.head, *neck])\n\n        self.body = Group()\n        self.tail = neck[-1]\n\n    def update(self, *args: Any, **kwargs: Any) -> None:\n        self.head.update()\n\n        \n        segments = self.sprites()\n        for i in range(len(segments) - 1, 0, -1):\n            \n            segments[i].rect.center = segments[i - 1].rect.center\n\n    def change_direction(self, direction: Direction):\n        self.head.change_direction(direction)\n\n    def grow(self):\n        tail = SnakeBody(\n            size=self.segment_size,\n            position=self.tail.rect.center,\n            colour=next(self.colours),\n        )\n        self.tail = tail\n        self.add(self.tail)\n        self.body.add(self.tail)\n\n\nclass SnakeFood(Sprite):\n    def __init__(self, game: Game, size: int, *groups: AbstractGroup) -> None:\n        super().__init__(*groups)\n        self.image = Surface((size, size))\n        self.image.fill(Color(\"red\"))\n        self.rect = self.image.get_rect()\n\n        self.rect.topleft = (\n            random.randint(0, game.rect.width),\n            random.randint(0, game.rect.height),\n        )\n\n        self.rect.clamp_ip(game.rect)\n\n        \n        \n        while pg.sprite.spritecollideany(self, game.snake):\n            self.rect.topleft = (\n                random.randint(0, game.rect.width),\n                random.randint(0, game.rect.height),\n            )\n\n            self.rect.clamp_ip(game.rect)\n\n\nclass Game:\n    def __init__(self) -> None:\n        self.rect = Rect(0, 0, 640, 480)\n        self.background = Surface(self.rect.size)\n        self.background.fill(Color(\"black\"))\n\n        self.score = 0\n        self.framerate = 16\n\n        self.segment_size = 10\n        self.snake = Snake(self)\n        self.food_group = RenderUpdates(SnakeFood(game=self, size=self.segment_size))\n\n        pg.init()\n\n    def _init_display(self) -> Surface:\n        bestdepth = pg.display.mode_ok(self.rect.size, 0, 32)\n        screen = pg.display.set_mode(self.rect.size, 0, bestdepth)\n\n        pg.display.set_caption(\"Snake\")\n        pg.mouse.set_visible(False)\n\n        screen.blit(self.background, (0, 0))\n        pg.display.flip()\n\n        return screen\n\n    def draw(self, screen: Surface):\n        dirty = self.snake.draw(screen)\n        pg.display.update(dirty)\n\n        dirty = self.food_group.draw(screen)\n        pg.display.update(dirty)\n\n    def update(self, screen):\n        self.food_group.clear(screen, self.background)\n        self.food_group.update()\n        self.snake.clear(screen, self.background)\n        self.snake.update()\n\n    def main(self) -> int:\n        screen = self._init_display()\n        clock = pg.time.Clock()\n\n        while self.snake.head.alive():\n            for event in pg.event.get():\n                if event.type == pg.QUIT or (\n                    event.type == pg.KEYDOWN and event.key in (pg.K_ESCAPE, pg.K_q)\n                ):\n                    return self.score\n\n            \n            keystate = pg.key.get_pressed()\n\n            if keystate[pg.K_RIGHT]:\n                self.snake.change_direction(Direction.RIGHT)\n            elif keystate[pg.K_LEFT]:\n                self.snake.change_direction(Direction.LEFT)\n            elif keystate[pg.K_UP]:\n                self.snake.change_direction(Direction.UP)\n            elif keystate[pg.K_DOWN]:\n                self.snake.change_direction(Direction.DOWN)\n\n            \n            self.update(screen)\n\n            \n            for food in pg.sprite.spritecollide(\n                self.snake.head, self.food_group, dokill=False\n            ):\n                food.kill()\n                self.snake.grow()\n                self.score += 1\n\n                \n                if self.score % 5 == 0:\n                    self.framerate += 1\n\n                self.food_group.add(SnakeFood(self, self.segment_size))\n\n            \n            if pg.sprite.spritecollideany(self.snake.head, self.snake.body):\n                self.snake.head.kill()\n\n            self.draw(screen)\n            clock.tick(self.framerate)\n\n        return self.score\n\n\nif __name__ == \"__main__\":\n    game = Game()\n    score = game.main()\n    print(score)\n"}
{"id": 336668, "name": "Pascal's triangle_Puzzle", "source": "Translate Ruby to Python: require 'rref'\n\npyramid = [\n           [ 151],\n          [nil,nil],\n        [40,nil,nil],\n      [nil,nil,nil,nil],\n    [\"x\", 11,\"y\", 4,\"z\"]\n]\npyramid.each{|row| p row}\n\nequations = [[1,-1,1,0]]   \n\ndef parse_equation(str)\n  eqn = [0] * 4\n  lhs, rhs = str.split(\"=\")\n  eqn[3] = rhs.to_i\n  for term in lhs.split(\"+\")\n    case term\n    when \"x\" then eqn[0] += 1\n    when \"y\" then eqn[1] += 1\n    when \"z\" then eqn[2] += 1\n    else          eqn[3] -= term.to_i\n    end\n  end\n  eqn \nend\n\n-2.downto(-5) do |row|\n  pyramid[row].each_index do |col|\n    val = pyramid[row][col]\n    sum = \"%s+%s\" % [pyramid[row+1][col], pyramid[row+1][col+1]]\n    if val.nil?\n      pyramid[row][col] = sum\n    else\n      equations << parse_equation(sum + \"=\n    end\n  end\nend\n\nreduced = convert_to(reduced_row_echelon_form(equations), :to_i)\n\nfor eqn in reduced\n  if eqn[0] + eqn[1] + eqn[2] != 1\n    fail \"no unique solution! \n  elsif eqn[0] == 1 then x = eqn[3]\n  elsif eqn[1] == 1 then y = eqn[3]\n  elsif eqn[2] == 1 then z = eqn[3]\n  end\nend\n\nputs\nputs \"x == \nputs \"y == \nputs \"z == \n\nanswer = []\nfor row in pyramid\n  answer << row.collect {|cell| eval cell.to_s}\nend\nputs\nanswer.each{|row| p row}\n", "target": "\n\n\n\n\n\n\n\ndef combine( snl, snr ):\n\n\tcl = {}\n\tif isinstance(snl, int):\n\t\tcl['1'] = snl\n\telif isinstance(snl, string):\n\t\tcl[snl] = 1\n\telse:\n\t\tcl.update( snl)\n\n\tif isinstance(snr, int):\n\t\tn = cl.get('1', 0)\n\t\tcl['1'] = n + snr\n\telif isinstance(snr, string):\n\t\tn = cl.get(snr, 0)\n\t\tcl[snr] = n + 1\n\telse:\n\t\tfor k,v in snr.items():\n\t\t\tn = cl.get(k, 0)\n\t\t\tcl[k] = n+v\n\treturn cl\n\n\ndef constrain(nsum, vn ):\n\tnn = {}\n\tnn.update(vn)\n\tn = nn.get('1', 0)\n\tnn['1'] = n - nsum\n\treturn nn\n\ndef makeMatrix( constraints ):\n\tvmap = set()\n\tfor c in constraints:\n\t\tvmap.update( c.keys())\n\tvmap.remove('1')\n\tnvars = len(vmap)\n\tvmap = sorted(vmap)\t\t\n\tmtx = []\n\tfor c in constraints:\n\t\trow = []\n\t\tfor vv in vmap:\n\t\t\trow.append(float(c.get(vv, 0)))\n\t\trow.append(-float(c.get('1',0)))\n\t\tmtx.append(row)\n\t\n\tif len(constraints) == nvars:\n\t\tprint 'System appears solvable'\n\telif len(constraints) < nvars:\n\t\tprint 'System is not solvable - needs more constraints.'\n\treturn mtx, vmap\n\n\ndef SolvePyramid( vl, cnstr ):\n\n\tvl.reverse()\n\tconstraints = [cnstr]\n\tlvls = len(vl)\n\tfor lvln in range(1,lvls):\n\t\tlvd = vl[lvln]\n\t\tfor k in range(lvls - lvln):\n\t\t\tsn = lvd[k]\n\t\t\tll = vl[lvln-1]\n\t\t\tvn = combine(ll[k], ll[k+1])\n\t\t\tif sn is None:\n\t\t\t\tlvd[k] = vn\n\t\t\telse:\n\t\t\t\tconstraints.append(constrain( sn, vn ))\n\n\tprint 'Constraint Equations:'\n\tfor cstr in constraints:\n\t\tfset = ('%d*%s'%(v,k) for k,v in cstr.items() )\n\t\tprint ' + '.join(fset), ' = 0'\n\n\tmtx,vmap = makeMatrix(constraints)\n\n\tMtxSolve(mtx)\n\n\td = len(vmap)\n\tfor j in range(d):\n\t\tprint vmap[j],'=', mtx[j][d]\n\n\ndef MtxSolve(mtx):\n\t\n\n\tmDim = len(mtx)\t\t\t\n\tfor j in range(mDim):\n\t\trw0= mtx[j]\n\t\tf = 1.0/rw0[j]\n\t\tfor k in range(j, mDim+1):\n\t\t\trw0[k] *= f\n\t\t\n\t\tfor l in range(1+j,mDim):\n\t\t\trwl = mtx[l]\n\t\t\tf = -rwl[j]\n\t\t\tfor k in range(j, mDim+1):\n\t\t\t\trwl[k] += f * rw0[k]\n\n\t\n\tfor j1 in range(1,mDim):\n\t\tj = mDim - j1\n\t\trw0= mtx[j]\n\t\tfor l in range(0, j):\n\t\t\trwl = mtx[l]\n\t\t\tf = -rwl[j]\n\t\t\trwl[j]    += f * rw0[j]\n\t\t\trwl[mDim] += f * rw0[mDim]\n\n\treturn mtx\n\n\np = [ [151], [None,None], [40,None,None], [None,None,None,None], ['X', 11, 'Y', 4, 'Z'] ]\naddlConstraint = { 'X':1, 'Y':-1, 'Z':1, '1':0 }\nSolvePyramid( p, addlConstraint)\n"}
{"id": 336669, "name": "Pascal's triangle_Puzzle", "source": "Translate Ruby to Python: require 'rref'\n\npyramid = [\n           [ 151],\n          [nil,nil],\n        [40,nil,nil],\n      [nil,nil,nil,nil],\n    [\"x\", 11,\"y\", 4,\"z\"]\n]\npyramid.each{|row| p row}\n\nequations = [[1,-1,1,0]]   \n\ndef parse_equation(str)\n  eqn = [0] * 4\n  lhs, rhs = str.split(\"=\")\n  eqn[3] = rhs.to_i\n  for term in lhs.split(\"+\")\n    case term\n    when \"x\" then eqn[0] += 1\n    when \"y\" then eqn[1] += 1\n    when \"z\" then eqn[2] += 1\n    else          eqn[3] -= term.to_i\n    end\n  end\n  eqn \nend\n\n-2.downto(-5) do |row|\n  pyramid[row].each_index do |col|\n    val = pyramid[row][col]\n    sum = \"%s+%s\" % [pyramid[row+1][col], pyramid[row+1][col+1]]\n    if val.nil?\n      pyramid[row][col] = sum\n    else\n      equations << parse_equation(sum + \"=\n    end\n  end\nend\n\nreduced = convert_to(reduced_row_echelon_form(equations), :to_i)\n\nfor eqn in reduced\n  if eqn[0] + eqn[1] + eqn[2] != 1\n    fail \"no unique solution! \n  elsif eqn[0] == 1 then x = eqn[3]\n  elsif eqn[1] == 1 then y = eqn[3]\n  elsif eqn[2] == 1 then z = eqn[3]\n  end\nend\n\nputs\nputs \"x == \nputs \"y == \nputs \"z == \n\nanswer = []\nfor row in pyramid\n  answer << row.collect {|cell| eval cell.to_s}\nend\nputs\nanswer.each{|row| p row}\n", "target": "\n\n\n\n\n\n\n\ndef combine( snl, snr ):\n\n\tcl = {}\n\tif isinstance(snl, int):\n\t\tcl['1'] = snl\n\telif isinstance(snl, string):\n\t\tcl[snl] = 1\n\telse:\n\t\tcl.update( snl)\n\n\tif isinstance(snr, int):\n\t\tn = cl.get('1', 0)\n\t\tcl['1'] = n + snr\n\telif isinstance(snr, string):\n\t\tn = cl.get(snr, 0)\n\t\tcl[snr] = n + 1\n\telse:\n\t\tfor k,v in snr.items():\n\t\t\tn = cl.get(k, 0)\n\t\t\tcl[k] = n+v\n\treturn cl\n\n\ndef constrain(nsum, vn ):\n\tnn = {}\n\tnn.update(vn)\n\tn = nn.get('1', 0)\n\tnn['1'] = n - nsum\n\treturn nn\n\ndef makeMatrix( constraints ):\n\tvmap = set()\n\tfor c in constraints:\n\t\tvmap.update( c.keys())\n\tvmap.remove('1')\n\tnvars = len(vmap)\n\tvmap = sorted(vmap)\t\t\n\tmtx = []\n\tfor c in constraints:\n\t\trow = []\n\t\tfor vv in vmap:\n\t\t\trow.append(float(c.get(vv, 0)))\n\t\trow.append(-float(c.get('1',0)))\n\t\tmtx.append(row)\n\t\n\tif len(constraints) == nvars:\n\t\tprint 'System appears solvable'\n\telif len(constraints) < nvars:\n\t\tprint 'System is not solvable - needs more constraints.'\n\treturn mtx, vmap\n\n\ndef SolvePyramid( vl, cnstr ):\n\n\tvl.reverse()\n\tconstraints = [cnstr]\n\tlvls = len(vl)\n\tfor lvln in range(1,lvls):\n\t\tlvd = vl[lvln]\n\t\tfor k in range(lvls - lvln):\n\t\t\tsn = lvd[k]\n\t\t\tll = vl[lvln-1]\n\t\t\tvn = combine(ll[k], ll[k+1])\n\t\t\tif sn is None:\n\t\t\t\tlvd[k] = vn\n\t\t\telse:\n\t\t\t\tconstraints.append(constrain( sn, vn ))\n\n\tprint 'Constraint Equations:'\n\tfor cstr in constraints:\n\t\tfset = ('%d*%s'%(v,k) for k,v in cstr.items() )\n\t\tprint ' + '.join(fset), ' = 0'\n\n\tmtx,vmap = makeMatrix(constraints)\n\n\tMtxSolve(mtx)\n\n\td = len(vmap)\n\tfor j in range(d):\n\t\tprint vmap[j],'=', mtx[j][d]\n\n\ndef MtxSolve(mtx):\n\t\n\n\tmDim = len(mtx)\t\t\t\n\tfor j in range(mDim):\n\t\trw0= mtx[j]\n\t\tf = 1.0/rw0[j]\n\t\tfor k in range(j, mDim+1):\n\t\t\trw0[k] *= f\n\t\t\n\t\tfor l in range(1+j,mDim):\n\t\t\trwl = mtx[l]\n\t\t\tf = -rwl[j]\n\t\t\tfor k in range(j, mDim+1):\n\t\t\t\trwl[k] += f * rw0[k]\n\n\t\n\tfor j1 in range(1,mDim):\n\t\tj = mDim - j1\n\t\trw0= mtx[j]\n\t\tfor l in range(0, j):\n\t\t\trwl = mtx[l]\n\t\t\tf = -rwl[j]\n\t\t\trwl[j]    += f * rw0[j]\n\t\t\trwl[mDim] += f * rw0[mDim]\n\n\treturn mtx\n\n\np = [ [151], [None,None], [40,None,None], [None,None,None,None], ['X', 11, 'Y', 4, 'Z'] ]\naddlConstraint = { 'X':1, 'Y':-1, 'Z':1, '1':0 }\nSolvePyramid( p, addlConstraint)\n"}
{"id": 336670, "name": "Keyboard input_Flush the keyboard buffer", "source": "Translate Ruby to Python: require 'io/console'\n$stdin.iflush\n", "target": "def flush_input():\n    try:\n        import msvcrt\n        while msvcrt.kbhit():\n            msvcrt.getch()\n    except ImportError:\n        import sys, termios\n        termios.tcflush(sys.stdin, termios.TCIOFLUSH)\n"}
{"id": 336671, "name": "Fractal tree", "source": "Translate Ruby to Python: Shoes.app(:title => \"Fractal Tree\", :width => 600, :height => 600) do\n  background \"\n  stroke \"\n  @deg_to_rad = Math::PI / 180.0\n  \n  def drawTree(x1, y1, angle, depth)\n    if depth != 0\n      x2 = x1 + (Math.cos(angle * @deg_to_rad) * depth * 10.0).to_i\n      y2 = y1 + (Math.sin(angle * @deg_to_rad) * depth * 10.0).to_i\n      \n      line x1, y1, x2, y2\n      \n      drawTree(x2, y2, angle - 20, depth - 1)\n      drawTree(x2, y2, angle + 20, depth - 1)      \n    end\n  end\n  \n  drawTree(300,550,-90,9)\nend\n", "target": "def setup():\n    size(600, 600)\n    background(0)\n    stroke(255)\n    drawTree(300, 550, 9)\n    \ndef drawTree(x, y, depth):\n    fork_ang = radians(20)\n    base_len = 10\n    if depth > 0:\n        pushMatrix()\n        translate(x, y - baseLen * depth)\n        line(0, baseLen * depth, 0, 0)  \n        rotate(fork_ang)\n        drawTree(0, 0, depth - 1)  \n        rotate(2 * -fork_ang)\n        drawTree(0, 0, depth - 1) \n        popMatrix()\n"}
{"id": 336672, "name": "Rock-paper-scissors", "source": "Translate Ruby to Python: \nenum Choice\n  Rock\n  Paper\n  Scissors\nend\n\nBEATS = {\n  Choice::Rock     => [Choice::Paper],\n  Choice::Paper    => [Choice::Scissors],\n  Choice::Scissors => [Choice::Rock],\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nclass RPSAI\n  @stats = {} of Choice => Int32\n\n  def initialize\n    Choice.values.each do |c|\n      @stats[c] = 1\n    end\n  end\n\n  def choose\n    v = rand(@stats.values.sum)\n    @stats.each do |choice, rate|\n      v -= rate\n      return choice if v < 0\n    end\n    raise \"\"\n  end\n\n  def train(selected)\n    BEATS[selected].each do |c|\n      @stats[c] += 1\n    end\n  end\nend\n\nenum GameResult\n  HumanWin\n  ComputerWin\n  Draw\n\n  def to_s\n    case self\n    when .draw?\n      \"Draw\"\n    when .human_win?\n      \"You win!\"\n    when .computer_win?\n      \"I win!\"\n    end\n  end\nend\n\nclass RPSGame\n  @score = Hash(GameResult, Int32).new(0)\n  @ai = RPSAI.new\n\n  def check(player, computer)\n    return GameResult::ComputerWin if BEATS[player].includes? computer\n    return GameResult::HumanWin if BEATS[computer].includes? player\n    return GameResult::Draw\n  end\n\n  def round\n    puts \"\"\n    print \"Your choice (\n    s = gets.not_nil!.strip.downcase\n    return false if \"quit\".starts_with? s\n    player_turn = Choice.values.find { |choice| choice.to_s.downcase.starts_with? s }\n    unless player_turn\n      puts \"Invalid choice\"\n      return true\n    end\n    ai_turn = @ai.choose\n    result = check(player_turn, ai_turn)\n    puts \"H: \n    @score[result] += 1\n    puts \"score: human=%d, computer=%d, draw=%d\" % GameResult.values.map { |r| @score[r] }\n    @ai.train player_turn\n    true\n  end\nend\n\ngame = RPSGame.new\nloop do\n  break unless game.round\nend\n", "target": "from random import choice\n\nrules = {'rock': 'paper', 'scissors': 'rock', 'paper': 'scissors'}\nprevious = ['rock', 'paper', 'scissors']\n\nwhile True:\n    human = input('\\nchoose your weapon: ')\n    computer = rules[choice(previous)]  \n\n    if human in ('quit', 'exit'): break\n\n    elif human in rules:\n        previous.append(human)\n        print('the computer played', computer, end='; ')\n\n        if rules[computer] == human:  \n            print('yay you win!')\n        elif rules[human] == computer:  \n            print('the computer beat you...\u00a0:(')\n        else: print(\"it's a tie!\")\n\n    else: print(\"that's not a valid choice\")\n"}
{"id": 336673, "name": "Benford's law", "source": "Translate Ruby to Python: require \"big\"\n\nEXPECTED = (1..9).map{ |d| Math.log10(1 + 1.0 / d) }\n \ndef fib(n)\n  a, b = 0.to_big_i, 1.to_big_i\n  (0...n).map { ret, a, b = a, b, a + b; ret }\nend\n \n\ndef power_of_threes(n)\n  (0...n).map { |k| 3.to_big_i ** k }\nend\n \ndef heads(s)\n  s.map { |a| a.to_s[0].to_i }\nend\n\ndef show_dist(title, s)\n  s = heads(s)\n  c = Array.new(10, 0)\n  s.each{ |x| c[x] += 1 }\n  siz = s.size\n  res = (1..9).map{ |d| c[d] / siz }\n  puts \"\\n    %s Benfords deviation\" % title\n  res.zip(EXPECTED).each_with_index(1) do |(r, e), i|\n    puts \"%2d: %5.1f%%  %5.1f%%  %5.1f%%\" % [i, r*100, e*100, (r - e).abs*100]\n  end\nend\n\ndef random(n)\n  (0...n).map { |i| rand(1..n) }\nend\n \nshow_dist(\"fibbed\", fib(1000))\nshow_dist(\"threes\", power_of_threes(1000))\n \n\nshow_dist(\"random\", random(10000))\n", "target": "from __future__ import division\nfrom itertools import islice, count\nfrom collections import Counter\nfrom math import log10\nfrom random import randint\n\nexpected = [log10(1+1/d) for d in range(1,10)]\n\ndef fib():\n    a,b = 1,1\n    while True:\n        yield a\n        a,b = b,a+b\n\n\ndef power_of_threes():\n    return (3**k for k in count(0))\n\ndef heads(s):\n    for a in s: yield int(str(a)[0])\n\ndef show_dist(title, s):\n    c = Counter(s)\n    size = sum(c.values())\n    res = [c[d]/size for d in range(1,10)]\n\n    print(\"\\n%s Benfords deviation\" % title)\n    for r, e in zip(res, expected):\n        print(\"%5.1f%% %5.1f%%  %5.1f%%\" % (r*100., e*100., abs(r - e)*100.))\n\ndef rand1000():\n    while True: yield randint(1,9999)\n\nif __name__ == '__main__':\n    show_dist(\"fibbed\", islice(heads(fib()), 1000))\n    show_dist(\"threes\", islice(heads(power_of_threes()), 1000))\n\n    \n    show_dist(\"random\", islice(heads(rand1000()), 10000))\n"}
{"id": 336674, "name": "Benford's law", "source": "Translate Ruby to Python: require \"big\"\n\nEXPECTED = (1..9).map{ |d| Math.log10(1 + 1.0 / d) }\n \ndef fib(n)\n  a, b = 0.to_big_i, 1.to_big_i\n  (0...n).map { ret, a, b = a, b, a + b; ret }\nend\n \n\ndef power_of_threes(n)\n  (0...n).map { |k| 3.to_big_i ** k }\nend\n \ndef heads(s)\n  s.map { |a| a.to_s[0].to_i }\nend\n\ndef show_dist(title, s)\n  s = heads(s)\n  c = Array.new(10, 0)\n  s.each{ |x| c[x] += 1 }\n  siz = s.size\n  res = (1..9).map{ |d| c[d] / siz }\n  puts \"\\n    %s Benfords deviation\" % title\n  res.zip(EXPECTED).each_with_index(1) do |(r, e), i|\n    puts \"%2d: %5.1f%%  %5.1f%%  %5.1f%%\" % [i, r*100, e*100, (r - e).abs*100]\n  end\nend\n\ndef random(n)\n  (0...n).map { |i| rand(1..n) }\nend\n \nshow_dist(\"fibbed\", fib(1000))\nshow_dist(\"threes\", power_of_threes(1000))\n \n\nshow_dist(\"random\", random(10000))\n", "target": "from __future__ import division\nfrom itertools import islice, count\nfrom collections import Counter\nfrom math import log10\nfrom random import randint\n\nexpected = [log10(1+1/d) for d in range(1,10)]\n\ndef fib():\n    a,b = 1,1\n    while True:\n        yield a\n        a,b = b,a+b\n\n\ndef power_of_threes():\n    return (3**k for k in count(0))\n\ndef heads(s):\n    for a in s: yield int(str(a)[0])\n\ndef show_dist(title, s):\n    c = Counter(s)\n    size = sum(c.values())\n    res = [c[d]/size for d in range(1,10)]\n\n    print(\"\\n%s Benfords deviation\" % title)\n    for r, e in zip(res, expected):\n        print(\"%5.1f%% %5.1f%%  %5.1f%%\" % (r*100., e*100., abs(r - e)*100.))\n\ndef rand1000():\n    while True: yield randint(1,9999)\n\nif __name__ == '__main__':\n    show_dist(\"fibbed\", islice(heads(fib()), 1000))\n    show_dist(\"threes\", islice(heads(power_of_threes()), 1000))\n\n    \n    show_dist(\"random\", islice(heads(rand1000()), 10000))\n"}
{"id": 336675, "name": "Hickerson series of almost integers", "source": "Translate Ruby to Python: require \"big\"\n \nLN2 = Math.log(2).to_big_f\n\nFACTORIALS = Hash(Int32, Float64).new{|h,k| h[k] = k * h[k-1]}\nFACTORIALS[0] = 1\n \ndef hickerson(n)\n  FACTORIALS[n] / (2 * LN2 ** (n+1))\nend\n \ndef nearly_int?(n)\n  int = n.round\n  (int - 0.1..int + 0.1).includes? n\nend\n \n1.upto(17) do |n|\n  h = hickerson(n)\n  str = nearly_int?(h) ? \"nearly integer\" : \"NOT nearly integer\"\n  puts \"n:%3i h: %s\\t%s\" % [n, h, str]\nend\n", "target": "from decimal import Decimal\nimport math\n\ndef h(n):\n    'Simple, reduced precision calculation'\n    return math.factorial(n) / (2 * math.log(2) ** (n + 1))\n    \ndef h2(n):\n    'Extended precision Hickerson function'\n    return Decimal(math.factorial(n)) / (2 * Decimal(2).ln() ** (n + 1))\n\nfor n in range(18):\n    x = h2(n)\n    norm = str(x.normalize())\n    almostinteger = (' Nearly integer' \n                     if 'E' not in norm and ('.0' in norm or '.9' in norm) \n                     else ' NOT nearly integer!')\n    print('n:%2i h:%s%s' % (n, norm, almostinteger))\n"}
{"id": 336676, "name": "Hickerson series of almost integers", "source": "Translate Ruby to Python: require \"big\"\n \nLN2 = Math.log(2).to_big_f\n\nFACTORIALS = Hash(Int32, Float64).new{|h,k| h[k] = k * h[k-1]}\nFACTORIALS[0] = 1\n \ndef hickerson(n)\n  FACTORIALS[n] / (2 * LN2 ** (n+1))\nend\n \ndef nearly_int?(n)\n  int = n.round\n  (int - 0.1..int + 0.1).includes? n\nend\n \n1.upto(17) do |n|\n  h = hickerson(n)\n  str = nearly_int?(h) ? \"nearly integer\" : \"NOT nearly integer\"\n  puts \"n:%3i h: %s\\t%s\" % [n, h, str]\nend\n", "target": "from decimal import Decimal\nimport math\n\ndef h(n):\n    'Simple, reduced precision calculation'\n    return math.factorial(n) / (2 * math.log(2) ** (n + 1))\n    \ndef h2(n):\n    'Extended precision Hickerson function'\n    return Decimal(math.factorial(n)) / (2 * Decimal(2).ln() ** (n + 1))\n\nfor n in range(18):\n    x = h2(n)\n    norm = str(x.normalize())\n    almostinteger = (' Nearly integer' \n                     if 'E' not in norm and ('.0' in norm or '.9' in norm) \n                     else ' NOT nearly integer!')\n    print('n:%2i h:%s%s' % (n, norm, almostinteger))\n"}
{"id": 336677, "name": "Read a configuration file", "source": "Translate Ruby to Python: fullname = favouritefruit = \"\"\nneedspeeling = seedsremoved = false\notherfamily = []\n\nIO.foreach(\"config.file\") do |line|\n  line.chomp!\n  key, value = line.split(nil, 2)\n  case key\n  when /^([\n  when \"FULLNAME\"; fullname = value\n  when \"FAVOURITEFRUIT\"; favouritefruit = value\n  when \"NEEDSPEELING\"; needspeeling = true\n  when \"SEEDSREMOVED\"; seedsremoved = true\n  when \"OTHERFAMILY\"; otherfamily = value.split(\",\").map(&:strip)\n  when /^./; puts \"\n  end\nend\n\nputs \"fullname       = \nputs \"favouritefruit = \nputs \"needspeeling   = \nputs \"seedsremoved   = \notherfamily.each_with_index do |name, i|\n  puts \"otherfamily(\nend\n", "target": "def readconf(fn):\n    ret = {}\n    with file(fn) as fp:\n        for line in fp:\n            \n            line = line.strip()\n            if not line or line.startswith('\n            \n            boolval = True\n            \n            if line.startswith(';'):\n                \n                line = line.lstrip(';')\n                \n                if len(line.split()) != 1: continue\n                boolval = False\n            \n            bits = line.split(None, 1)\n            if len(bits) == 1:\n                \n                k = bits[0]\n                v = boolval\n            else:\n                \n                k, v = bits\n            ret[k.lower()] = v\n    return ret\n\n\nif __name__ == '__main__':\n    import sys\n    conf = readconf(sys.argv[1])\n    for k, v in sorted(conf.items()):\n        print k, '=', v\n"}
{"id": 336678, "name": "Kronecker product based fractals", "source": "Translate Ruby to Python: func kronecker_product (a, b) { a ~X b -> map { _[0] ~X* _[1] } }\n\nfunc kronecker_fractal(pattern, order=4) {\n    var kronecker = pattern\n    { kronecker = kronecker_product(kronecker, pattern) } * order\n    return kronecker\n}\n\nvar vicsek = [[0,1,0], [1,1,1], [0,1,0]]\nvar carpet = [[1,1,1], [1,0,1], [1,1,1]]\nvar six    = [[0,1,1,1,0], [1,0,0,0,1], [1,0,0,0,0],\n              [1,1,1,1,0], [1,0,0,0,1], [1,0,0,0,1], [0,1,1,1,0]]\n\nrequire(\"Imager\")\n\nfor name,shape,order in [\n    [:vicsek, vicsek, 4],\n    [:carpet, carpet, 4],\n    [:six,    six,    3],\n] {\n    var pat = kronecker_fractal(shape, order)\n    var img = %O<Imager>.new(xsize => pat[0].len, ysize => pat.len)\n    for x,y in (^pat[0].len ~X ^pat.len) {\n        img.setpixel(x => x, y => y, color => (pat[y][x] ? <255 255 32> : <16 16 16>))\n    }\n    img.write(file => \"kronecker-\n}\n", "target": "import os\nfrom PIL import Image\n\n\ndef imgsave(path, arr):\n    w, h = len(arr), len(arr[0])\n    img = Image.new('1', (w, h))\n    for x in range(w):\n        for y in range(h):\n            img.putpixel((x, y), arr[x][y])\n    img.save(path)\n\n\ndef get_shape(mat):\n    return len(mat), len(mat[0])\n\n\ndef kron(matrix1, matrix2):\n    \n    final_list = []\n\n    count = len(matrix2)\n\n    for elem1 in matrix1:\n        for i in range(count):\n            sub_list = []\n            for num1 in elem1:\n                for num2 in matrix2[i]:\n                    sub_list.append(num1 * num2)\n            final_list.append(sub_list)\n\n    return final_list\n\n\ndef kronpow(mat):\n    \n    matrix = mat\n    while True:\n        yield matrix\n        matrix = kron(mat, matrix)\n\n\ndef fractal(name, mat, order=6):\n    \n    path = os.path.join('fractals', name)\n    os.makedirs(path, exist_ok=True)\n\n    fgen = kronpow(mat)\n    print(name)\n    for i in range(order):\n        p = os.path.join(path, f'{i}.jpg')\n        print('Calculating n =', i, end='\\t', flush=True)\n\n        mat = next(fgen)\n        imgsave(p, mat)\n\n        x, y = get_shape(mat)\n        print('Saved as', x, 'x', y, 'image', p)\n\n\ntest1 = [\n    [0, 1, 0],\n    [1, 1, 1],\n    [0, 1, 0]\n]\n\ntest2 = [\n    [1, 1, 1],\n    [1, 0, 1],\n    [1, 1, 1]\n]\n\ntest3 = [\n    [1, 0, 1],\n    [0, 1, 0],\n    [1, 0, 1]\n]\n\nfractal('test1', test1)\nfractal('test2', test2)\nfractal('test3', test3)\n"}
{"id": 336679, "name": "Additive primes", "source": "Translate Ruby to Python: \n\n\ndef prime?(n) \n  return false unless (n | 1 == 3 if n < 5) || (n % 6) | 4 == 5\n  sqrt_n = Math.isqrt(n)  \n  pc = typeof(n).new(5)\n  while pc <= sqrt_n\n    return false if n % pc == 0 || n % (pc + 2) == 0\n    pc += 6\n  end\n  true\nend\n\ndef additive_primes(n)\n  primes = [2, 3]\n  pc, inc = 5, 2\n  while pc < n\n    primes << pc if prime?(pc) && prime?(pc.digits.sum)\n    pc += inc; inc ^= 0b110  \n  end\n  primes \nend\n\nnn = 500\naddprimes = additive_primes(nn)\nmaxdigits = addprimes.last.digits.size\naddprimes.each_with_index { |n, idx| printf \"%*d \", maxdigits, n; print \"\\n\" if idx % 10 == 9 } \n\nputs \"\\n\n\nputs\n\nnn = 5000\naddprimes = additive_primes(nn)\nmaxdigits = addprimes.last.digits.size\naddprimes.each_with_index { |n, idx| printf \"%*d \", maxdigits, n; print \"\\n\" if idx % 10 == 9 } \nputs \"\\n\n", "target": "def is_prime(n: int) -> bool:\n    if n <= 3:\n        return n > 1\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i ** 2 <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True\n\ndef digit_sum(n: int) -> int:\n    sum = 0\n    while n > 0:\n        sum += n % 10\n        n //= 10\n    return sum\n\ndef main() -> None:\n    additive_primes = 0\n    for i in range(2, 500):\n        if is_prime(i) and is_prime(digit_sum(i)):\n            additive_primes += 1\n            print(i, end=\" \")\n    print(f\"\\nFound {additive_primes} additive primes less than 500\")\n\nif __name__ == \"__main__\":\n    main()\n"}
{"id": 336680, "name": "Case-sensitivity of identifiers", "source": "Translate Ruby to Python: module FiveDogs\n  dog = \"Benjamin\"\n  dOg = \"Dogley\"\n  doG = \"Fido\"\n  Dog = \"Samba\"   \n  DOG = \"Bernie\"  \n\n  names = [dog, dOg, doG, Dog, DOG]\n  names.uniq!\n  puts \"There are %d dogs named %s.\" % [names.length, names.join(\", \")]\n  puts\n  puts \"The local variables are %s.\" % local_variables.join(\", \")\n  puts \"The constants are %s.\" % constants.join(\", \")\nend\n", "target": ">>> dog = 'Benjamin'; Dog = 'Samba'; DOG = 'Bernie'\n>>> print ('The three dogs are named ',dog,', ',Dog,', and ',DOG)\nThe three dogs are named  Benjamin ,  Samba , and  Bernie\n>>>\n"}
{"id": 336681, "name": "Extra primes", "source": "Translate Ruby to Python: def nextPrimeDigitNumber(n)\n    if n == 0 then\n        return 2\n    end\n    if n % 10 == 2 then\n        return n + 1\n    end\n    if n % 10 == 3 or n % 10 == 5 then\n        return n + 2\n    end\n    return 2 + nextPrimeDigitNumber((n / 10).floor) * 10\nend\n\ndef isPrime(n)\n    if n < 2 then\n        return false\n    end\n    if n % 2 == 0 then\n        return n == 2\n    end\n    if n % 3 == 0 then\n        return n == 3\n    end\n    if n % 5 == 0 then\n        return n == 5\n    end\n\n    wheel = [4, 2, 4, 2, 4, 6, 2, 6]\n    p = 7\n    loop do\n        for w in wheel\n            if p * p > n then\n                return true\n            end\n            if n % p == 0 then\n                return false\n            end\n            p = p + w\n        end\n    end\nend\n\ndef digitSum(n)\n    sum = 0\n    while n > 0\n        sum = sum + n % 10\n        n = (n / 10).floor\n    end\n    return sum\nend\n\nLIMIT = 10000\np = 0\nn = 0\n\nprint \"Extra primes under %d:\\n\" % [LIMIT]\nwhile p < LIMIT\n    p = nextPrimeDigitNumber(p)\n    if isPrime(p) and isPrime(digitSum(p)) then\n        n = n + 1\n        print \"%2d: %d\\n\" % [n, p]\n    end\nend\nprint \"\\n\"\n", "target": "from itertools import *\nfrom functools import reduce\n\nclass Sieve(object):\n    \n    def __init__(self):\n        self._primes = []\n        self._comps = {}\n        self._max = 2;\n    \n    def isprime(self, n):\n        \n        if n >= self._max: self._genprimes(n)\n        return n >= 2 and n in self._primes\n    \n    def _genprimes(self, max):\n        while self._max <= max:\n            if self._max not in self._comps:\n                self._primes.append(self._max)\n                self._comps[self._max*self._max] = [self._max]\n            else:\n                for p in self._comps[self._max]:\n                    ps = self._comps.setdefault(self._max+p, [])\n                    ps.append(p)\n                del self._comps[self._max]\n            self._max += 1\n                \ndef extra_primes():\n    \n    d = [2,3,5,7]\n    s = Sieve()\n    for cand in chain.from_iterable(product(d, repeat=r) for r in count(1)):\n        num = reduce(lambda x, y: x*10+y, cand)\n        if s.isprime(num) and s.isprime(sum(cand)): yield num\n        \nfor n in takewhile(lambda n: n < 10000, extra_primes()):\n    print(n)\n"}
{"id": 336682, "name": "Extra primes", "source": "Translate Ruby to Python: def nextPrimeDigitNumber(n)\n    if n == 0 then\n        return 2\n    end\n    if n % 10 == 2 then\n        return n + 1\n    end\n    if n % 10 == 3 or n % 10 == 5 then\n        return n + 2\n    end\n    return 2 + nextPrimeDigitNumber((n / 10).floor) * 10\nend\n\ndef isPrime(n)\n    if n < 2 then\n        return false\n    end\n    if n % 2 == 0 then\n        return n == 2\n    end\n    if n % 3 == 0 then\n        return n == 3\n    end\n    if n % 5 == 0 then\n        return n == 5\n    end\n\n    wheel = [4, 2, 4, 2, 4, 6, 2, 6]\n    p = 7\n    loop do\n        for w in wheel\n            if p * p > n then\n                return true\n            end\n            if n % p == 0 then\n                return false\n            end\n            p = p + w\n        end\n    end\nend\n\ndef digitSum(n)\n    sum = 0\n    while n > 0\n        sum = sum + n % 10\n        n = (n / 10).floor\n    end\n    return sum\nend\n\nLIMIT = 10000\np = 0\nn = 0\n\nprint \"Extra primes under %d:\\n\" % [LIMIT]\nwhile p < LIMIT\n    p = nextPrimeDigitNumber(p)\n    if isPrime(p) and isPrime(digitSum(p)) then\n        n = n + 1\n        print \"%2d: %d\\n\" % [n, p]\n    end\nend\nprint \"\\n\"\n", "target": "from itertools import *\nfrom functools import reduce\n\nclass Sieve(object):\n    \n    def __init__(self):\n        self._primes = []\n        self._comps = {}\n        self._max = 2;\n    \n    def isprime(self, n):\n        \n        if n >= self._max: self._genprimes(n)\n        return n >= 2 and n in self._primes\n    \n    def _genprimes(self, max):\n        while self._max <= max:\n            if self._max not in self._comps:\n                self._primes.append(self._max)\n                self._comps[self._max*self._max] = [self._max]\n            else:\n                for p in self._comps[self._max]:\n                    ps = self._comps.setdefault(self._max+p, [])\n                    ps.append(p)\n                del self._comps[self._max]\n            self._max += 1\n                \ndef extra_primes():\n    \n    d = [2,3,5,7]\n    s = Sieve()\n    for cand in chain.from_iterable(product(d, repeat=r) for r in count(1)):\n        num = reduce(lambda x, y: x*10+y, cand)\n        if s.isprime(num) and s.isprime(sum(cand)): yield num\n        \nfor n in takewhile(lambda n: n < 10000, extra_primes()):\n    print(n)\n"}
{"id": 336683, "name": "Abbreviations, easy", "source": "Translate Ruby to Python: \n\ncmd_table = File.read(ARGV[0]).split\nuser_str = File.read(ARGV[1]).split\n\nuser_str.each do |abbr|\n  candidate = cmd_table.find do |cmd|\n    cmd.count('A-Z') <= abbr.length && abbr.casecmp(cmd[0...abbr.length]).zero?\n  end\n\n  print candidate.nil? ? '*error*' : candidate.upcase\n\n  print ' '\nend\n\nputs\n", "target": "command_table_text = \\\n\n\nuser_words = \"riG   rePEAT copies  put mo   rest    types   fup.    6       poweRin\"\n\ndef find_abbreviations_length(command_table_text):\n    \n    command_table = dict()\n    for word in command_table_text.split():\n        abbr_len = sum(1 for c in word if c.isupper())\n        if abbr_len == 0:\n            abbr_len = len(word)\n        command_table[word] = abbr_len\n    return command_table\n\ndef find_abbreviations(command_table):\n    \n    abbreviations = dict()\n    for command, min_abbr_len in command_table.items():\n        for l in range(min_abbr_len, len(command)+1):\n            abbr = command[:l].lower()\n            abbreviations[abbr] = command.upper()\n    return abbreviations\n\ndef parse_user_string(user_string, abbreviations):\n    user_words = [word.lower() for word in user_string.split()]\n    commands = [abbreviations.get(user_word, \"*error*\") for user_word in user_words]\n    return \" \".join(commands)\n\ncommand_table = find_abbreviations_length(command_table_text)\nabbreviations_table = find_abbreviations(command_table)\n\nfull_words = parse_user_string(user_words, abbreviations_table)\n\nprint(\"user words:\", user_words)\nprint(\"full words:\", full_words)\n"}
{"id": 336684, "name": "Abbreviations, easy", "source": "Translate Ruby to Python: \n\ncmd_table = File.read(ARGV[0]).split\nuser_str = File.read(ARGV[1]).split\n\nuser_str.each do |abbr|\n  candidate = cmd_table.find do |cmd|\n    cmd.count('A-Z') <= abbr.length && abbr.casecmp(cmd[0...abbr.length]).zero?\n  end\n\n  print candidate.nil? ? '*error*' : candidate.upcase\n\n  print ' '\nend\n\nputs\n", "target": "command_table_text = \\\n\n\nuser_words = \"riG   rePEAT copies  put mo   rest    types   fup.    6       poweRin\"\n\ndef find_abbreviations_length(command_table_text):\n    \n    command_table = dict()\n    for word in command_table_text.split():\n        abbr_len = sum(1 for c in word if c.isupper())\n        if abbr_len == 0:\n            abbr_len = len(word)\n        command_table[word] = abbr_len\n    return command_table\n\ndef find_abbreviations(command_table):\n    \n    abbreviations = dict()\n    for command, min_abbr_len in command_table.items():\n        for l in range(min_abbr_len, len(command)+1):\n            abbr = command[:l].lower()\n            abbreviations[abbr] = command.upper()\n    return abbreviations\n\ndef parse_user_string(user_string, abbreviations):\n    user_words = [word.lower() for word in user_string.split()]\n    commands = [abbreviations.get(user_word, \"*error*\") for user_word in user_words]\n    return \" \".join(commands)\n\ncommand_table = find_abbreviations_length(command_table_text)\nabbreviations_table = find_abbreviations(command_table)\n\nfull_words = parse_user_string(user_words, abbreviations_table)\n\nprint(\"user words:\", user_words)\nprint(\"full words:\", full_words)\n"}
{"id": 336685, "name": "Common sorted list", "source": "Translate Ruby to Python: nums = [5,1,3,8,9,4,8,7], [3,5,9,8,4], [1,3,7,9]\np nums.inject(:+).sort.uniq\n", "target": "\n\nfrom itertools import chain\n\n\n\n\ndef main():\n    \n\n    print(\n        sorted(nub(concat([\n            [5, 1, 3, 8, 9, 4, 8, 7],\n            [3, 5, 9, 8, 4],\n            [1, 3, 7, 9]\n        ])))\n    )\n\n\n\n\n\n\ndef concat(xs):\n    \n    return list(chain(*xs))\n\n\n\ndef nub(xs):\n    \n    return list(dict.fromkeys(xs))\n\n\n\nif __name__ == '__main__':\n    main()\n"}
{"id": 336686, "name": "Common sorted list", "source": "Translate Ruby to Python: nums = [5,1,3,8,9,4,8,7], [3,5,9,8,4], [1,3,7,9]\np nums.inject(:+).sort.uniq\n", "target": "\n\nfrom itertools import chain\n\n\n\n\ndef main():\n    \n\n    print(\n        sorted(nub(concat([\n            [5, 1, 3, 8, 9, 4, 8, 7],\n            [3, 5, 9, 8, 4],\n            [1, 3, 7, 9]\n        ])))\n    )\n\n\n\n\n\n\ndef concat(xs):\n    \n    return list(chain(*xs))\n\n\n\ndef nub(xs):\n    \n    return list(dict.fromkeys(xs))\n\n\n\nif __name__ == '__main__':\n    main()\n"}
{"id": 336687, "name": "Sorting algorithms_Stooge sort", "source": "Translate Ruby to Python: class Array\n  def stoogesort\n    self.dup.stoogesort!\n  end\n\n  def stoogesort!(i = 0, j = self.length-1)\n    if self[j] < self[i]\n      self[i], self[j] = self[j], self[i]\n    end\n    if j - i > 1\n      t = (j - i + 1)/3\n      stoogesort!(i, j-t)\n      stoogesort!(i+t, j)\n      stoogesort!(i, j-t)\n    end\n    self\n  end\nend\n\np [1,4,5,3,-6,3,7,10,-2,-5].stoogesort\n", "target": ">>> data = [1, 4, 5, 3, -6, 3, 7, 10, -2, -5, 7, 5, 9, -3, 7]\n>>> def stoogesort(L, i=0, j=None):\n\tif j is None:\n\t\tj = len(L) - 1\n\tif L[j] < L[i]:\n\t\tL[i], L[j] = L[j], L[i]\n\tif j - i > 1:\n\t\tt = (j - i + 1) // 3\n\t\tstoogesort(L, i  , j-t)\n\t\tstoogesort(L, i+t, j  )\n\t\tstoogesort(L, i  , j-t)\n\treturn L\n\n>>> stoogesort(data)\n[-6, -5, -3, -2, 1, 3, 3, 4, 5, 5, 7, 7, 7, 9, 10]\n"}
{"id": 336688, "name": "Truncate a file", "source": "Translate Ruby to Python: \nFile.open(\"file\", \"ab\") do |f|\n  f.truncate(1234)\n  f << \"Killroy was here\" \nend  \n\n\nFile.truncate(\"file\", 567)\n", "target": "def truncate_file(name, length):\n    if not os.path.isfile(name):\n        return False\n    if length >= os.path.getsize(name):\n        return False\n    with open(name, 'ab') as f:\n        f.truncate(length)\n    return True\n"}
{"id": 336689, "name": "Truncate a file", "source": "Translate Ruby to Python: \nFile.open(\"file\", \"ab\") do |f|\n  f.truncate(1234)\n  f << \"Killroy was here\" \nend  \n\n\nFile.truncate(\"file\", 567)\n", "target": "def truncate_file(name, length):\n    if not os.path.isfile(name):\n        return False\n    if length >= os.path.getsize(name):\n        return False\n    with open(name, 'ab') as f:\n        f.truncate(length)\n    return True\n"}
{"id": 336690, "name": "Sorting algorithms_Shell sort", "source": "Translate Ruby to Python: class Array\n  def shellsort!\n    inc = length / 2\n    while inc != 0\n      inc.step(length-1) do |i|\n        el = self[i]\n        while i >= inc and self[i - inc] > el\n          self[i] = self[i - inc]\n          i -= inc\n        end\n        self[i] = el\n      end\n      inc = (inc == 2 ? 1 : (inc * 5.0 / 11).to_i)\n    end\n    self\n  end\nend\n\ndata = [22, 7, 2, -5, 8, 4]\ndata.shellsort!\np data \n", "target": "def shell(seq):\n    inc = len(seq) // 2\n    while inc:\n        for i, el in enumerate(seq[inc:], inc):\n            while i >= inc and seq[i - inc] > el:\n                seq[i] = seq[i - inc]\n                i -= inc\n            seq[i] = el\n        inc = 1 if inc == 2 else inc * 5 // 11\n"}
{"id": 336691, "name": "Formal power series", "source": "Translate Ruby to Python: \n\nclass Fps\n\n  \n  \n  \n  \n  \n  \n  \n  def initialize(const: nil, delta: nil, iota: nil, init: nil, enum: nil)\n    \n    case\n      when const\n        @coeffenum = make_const(const)\n      when delta\n        @coeffenum = make_delta(delta)\n      when iota\n        @coeffenum = make_iota(iota)\n      when init\n        @coeffenum = make_init(init)\n      when enum\n        @coeffenum = enum\n      else\n        @coeffenum = make_const(0)\n    end\n    \n    @coeffenum.instance_eval do\n      def [](index)\n        self.drop(index).first\n      end\n    end\n  end\n\n  \n  def [](index)\n    @coeffenum.drop(index).first\n  end\n\n  \n  def +(other)\n    other = convert(other)\n    Fps.new(enum:\n      Enumerator.new do |yielder, inx: 0|\n        loop do\n          yielder.yield(@coeffenum[inx] + other[inx])\n          inx += 1\n        end\n      end.lazy)\n  end\n\n  \n  def -(other)\n    other = convert(other)\n    Fps.new(enum:\n      Enumerator.new do |yielder, inx: 0|\n        loop do\n          yielder.yield(@coeffenum[inx] - other[inx])\n          inx += 1\n        end\n      end.lazy)\n  end\n\n  \n  def *(other)\n    other = convert(other)\n    Fps.new(enum:\n      Enumerator.new do |yielder, inx: 0|\n        loop do\n          coeff = (0..inx).reduce(0) { |sum, i| sum + (@coeffenum[i] * other[inx - i]) }\n          yielder.yield(coeff)\n          inx += 1\n        end\n      end.lazy)\n  end\n\n  \n  def /(other)\n    other = convert(other)\n    Fps.new(enum:\n      Enumerator.new do |yielder, inx: 1|\n        coeffs = [ Rational(@coeffenum[0], other[0]) ]\n        yielder.yield(coeffs[-1])\n        loop do\n          coeffs <<\n            Rational(\n              @coeffenum[inx] -\n                (1..inx).reduce(0) { |sum, i| sum + (other[i] * coeffs[inx - i]) },\n              other[0])\n          yielder.yield(coeffs[-1])\n          inx += 1\n        end\n      end.lazy)\n  end\n\n  \n  def deriv()\n    Fps.new(enum:\n      Enumerator.new do |yielder, inx: 0|\n        iota = Fps.new(iota: 1)\n        loop do\n          yielder.yield(@coeffenum[inx + 1] * iota[inx])\n          inx += 1\n        end\n      end.lazy)\n  end\n\n  \n  def integ()\n    Fps.new(enum:\n      Enumerator.new do |yielder, inx: 0|\n        iota = Fps.new(iota: 1)\n        yielder.yield(Rational(0, 1))\n        loop do\n          yielder.yield(Rational(@coeffenum[inx], iota[inx]))\n          inx += 1\n        end\n      end.lazy)\n  end\n\n  \n  def assign(other)\n    other = convert(other)\n    @coeffenum = other.get_enum\n  end\n\n  \n  def coerce(other)\n    if other.kind_of?(Numeric)\n      [ Fps.new(delta: other), self ]\n    else\n      raise TypeError 'non-numeric can\\'t be coerced into FPS type'\n    end\n  end\n\n  \n  def to_i()\n    @coeffenum[0].to_i\n  end\n\n  \n  def to_f()\n    @coeffenum[0].to_f\n  end\n\n  \n  def to_r()\n    @coeffenum[0].to_r\n  end\n\n  \n  def to_s(count = 0)\n    if count <= 0\n      super()\n    else\n      retstr = ''\n      count.times do |inx|\n        coeff = (@coeffenum[inx].to_r.denominator == 1) ? @coeffenum[inx].to_i : @coeffenum[inx]\n        if !(coeff.zero?)\n          prefix = (retstr != '') ? ' ' : ''\n          coeffstr =\n            ((coeff.abs == 1) && (inx != 0)) ? '' : \"\n          suffix = (inx == 0) ? '' : (inx == 1) ? 'x' : \"x^\n          if coeff < 0\n            prefix << ((retstr != '') ? '- ' : '-')\n          else\n            prefix << ((retstr != '') ? '+ ' : '')\n          end\n          retstr << \"\n        end\n      end\n      (retstr == '') ? '0' : retstr\n    end\n  end\n\n  \n  def eval(x, count)\n    @coeffenum.first(count).each_with_index.reduce(0) { |sum, (coeff, inx) | sum + coeff * x**inx }\n  end\n\n  \n  def method_missing(name, *args, &block)\n    @coeffenum.send(name, *args, &block)\n  end\n\n  \n  def respond_to_missing?(name, incl_priv)\n    @coeffenum.respond_to?(name, incl_priv)\n  end\n\nprotected\n\n  \n  def get_enum()\n    @coeffenum\n  end\n\nprivate\n\n  \n  \n  def make_const(n)\n    Enumerator.new do |yielder|\n      loop { yielder.yield(n) }\n    end.lazy\n  end\n\n  \n  \n  def make_delta(n)\n    Enumerator.new do |yielder|\n      yielder.yield(n)\n      loop { yielder.yield(0) }\n    end.lazy\n  end\n\n  \n  \n  def make_iota(n)\n    Enumerator.new do |yielder, i: n|\n      loop { yielder.yield(i); i += 1 }\n    end.lazy\n  end\n\n  \n  \n  def make_init(array)\n    Enumerator.new do |yielder, inx: -1|\n      loop { yielder.yield((inx < (array.length - 1)) ? array[inx += 1] : 0) }\n    end.lazy\n  end\n\n  \n  def convert(other)\n    if other.kind_of?(Fps)\n      other\n    else\n      if other.kind_of?(Numeric)\n        Fps.new(delta: other)\n      else\n        raise TypeError 'non-numeric can\\'t be converted to FPS type'\n      end\n    end\n  end\n\nend\n", "target": "\n\nfrom itertools import islice\nfrom fractions import Fraction\nfrom functools import reduce\ntry:\n    from itertools import izip as zip \nexcept:\n    pass\n\ndef head(n):\n    \n    return lambda seq: islice(seq, n)\n\ndef pipe(gen, *cmds):\n    \n    return reduce(lambda gen, cmd: cmd(gen), cmds, gen)\n\ndef sinepower():\n    n = 0\n    fac = 1\n    sign = +1\n    zero = 0\n    yield zero\n    while True:\n        n +=1\n        fac *= n\n        yield Fraction(1, fac*sign)\n        sign = -sign\n        n +=1\n        fac *= n\n        yield zero\ndef cosinepower():\n    n = 0\n    fac = 1\n    sign = +1\n    yield Fraction(1,fac)\n    zero = 0\n    while True:\n        n +=1\n        fac *= n\n        yield zero\n        sign = -sign\n        n +=1\n        fac *= n\n        yield Fraction(1, fac*sign)\ndef pluspower(*powergenerators):\n    for elements in zip(*powergenerators):\n        yield sum(elements)\ndef minuspower(*powergenerators):\n    for elements in zip(*powergenerators):\n        yield elements[0] - sum(elements[1:])\ndef mulpower(fgen,ggen):\n    'From: http://en.wikipedia.org/wiki/Power_series\n    a,b = [],[]\n    for f,g in zip(fgen, ggen):\n        a.append(f)\n        b.append(g)\n        yield sum(f*g for f,g in zip(a, reversed(b)))\ndef constpower(n):\n    yield n\n    while True:\n        yield 0\ndef diffpower(gen):\n    'differentiatiate power series'\n    next(gen)\n    for n, an in enumerate(gen, start=1):\n        yield an*n\ndef intgpower(k=0):\n    'integrate power series with constant k'\n    def _intgpower(gen):\n        yield k\n        for n, an in enumerate(gen, start=1):\n            yield an * Fraction(1,n)\n    return _intgpower\n\n\nprint(\"cosine\")\nc = list(pipe(cosinepower(), head(10)))\nprint(c)\nprint(\"sine\")\ns = list(pipe(sinepower(), head(10)))\nprint(s)\n\nintegc = list(pipe(cosinepower(),intgpower(0), head(10)))\n\nintegs1 = list(minuspower(pipe(constpower(1), head(10)),\n                          pipe(sinepower(),intgpower(0), head(10))))\n\nassert s == integc, \"The integral of cos should be sin\"\nassert c == integs1, \"1 minus the integral of sin should be cos\"\n"}
{"id": 336692, "name": "Read a specific line from a file", "source": "Translate Ruby to Python:  seventh_line = open(\"/etc/passwd\").each_line.take(7).last\n", "target": "with open('xxx.txt') as f:\n    for i, line in enumerate(f):\n        if i == 6:\n            break\n    else:\n        print('Not 7 lines in file')\n        line = None\n"}
{"id": 336693, "name": "Read a specific line from a file", "source": "Translate Ruby to Python:  seventh_line = open(\"/etc/passwd\").each_line.take(7).last\n", "target": "with open('xxx.txt') as f:\n    for i, line in enumerate(f):\n        if i == 6:\n            break\n    else:\n        print('Not 7 lines in file')\n        line = None\n"}
{"id": 336694, "name": "Digit fifth powers", "source": "Translate Ruby to Python: arr = (2..9**5*6).select{|n| n.digits.sum{|d| d**5} == n }\nputs \"\n", "target": "from time import time\n\n\nst = time()\nprint(sum([n for n in range(2, 6*9**5) if sum(int(i)**5 for i in str(n)) == n]), \"  \", (time() - st) * 1000, \"ms\")\n\n\nst = time()\nnums = list(range(10))\nnu = list(range(((6 * 9**5) // 100000) + 1))\nnumbers = []\np5 = []\nfor i in nums: p5.append(i**5)\nfor i in nu:\n    im = i * 100000\n    ip = p5[i]\n    for j in nums:\n        jm = im + 10000 * j\n        jp = ip + p5[j]\n        for k in nums:\n            km = jm + 1000 * k\n            kp = jp + p5[k]\n            for l in nums:\n                lm = km + 100 * l\n                lp = kp + p5[l]\n                for m in nums:\n                    mm = lm + 10 * m\n                    mp = lp + p5[m]\n                    for n in nums:\n                        nm = mm + n\n                        np = mp + p5[n]\n                        if np == nm:\n                            if nm > 1: numbers.append(nm)\nprint(sum(numbers), \"  \", (time() - st) * 1000, \"ms\", end = \"\")\n"}
{"id": 336695, "name": "Digit fifth powers", "source": "Translate Ruby to Python: arr = (2..9**5*6).select{|n| n.digits.sum{|d| d**5} == n }\nputs \"\n", "target": "from time import time\n\n\nst = time()\nprint(sum([n for n in range(2, 6*9**5) if sum(int(i)**5 for i in str(n)) == n]), \"  \", (time() - st) * 1000, \"ms\")\n\n\nst = time()\nnums = list(range(10))\nnu = list(range(((6 * 9**5) // 100000) + 1))\nnumbers = []\np5 = []\nfor i in nums: p5.append(i**5)\nfor i in nu:\n    im = i * 100000\n    ip = p5[i]\n    for j in nums:\n        jm = im + 10000 * j\n        jp = ip + p5[j]\n        for k in nums:\n            km = jm + 1000 * k\n            kp = jp + p5[k]\n            for l in nums:\n                lm = km + 100 * l\n                lp = kp + p5[l]\n                for m in nums:\n                    mm = lm + 10 * m\n                    mp = lp + p5[m]\n                    for n in nums:\n                        nm = mm + n\n                        np = mp + p5[n]\n                        if np == nm:\n                            if nm > 1: numbers.append(nm)\nprint(sum(numbers), \"  \", (time() - st) * 1000, \"ms\", end = \"\")\n"}
{"id": 336696, "name": "Find prime n such that reversed n is also prime", "source": "Translate Ruby to Python: p Prime.each(500).select{|pr| pr.digits.join.to_i.prime? }\n", "target": "\n\ndef isPrime(n):\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return False        \n    return True\n\ndef isBackPrime(n):\n    if not isPrime(n):\n        return False\n    m = 0\n    while n:\n        m *= 10\n        m += n % 10\n        n //= 10\n    return isPrime(m)\n\nif __name__ == '__main__':\n    for n in range(2, 499):\n        if isBackPrime(n):\n            print(n, end=' ');\n"}
{"id": 336697, "name": "Find prime n such that reversed n is also prime", "source": "Translate Ruby to Python: p Prime.each(500).select{|pr| pr.digits.join.to_i.prime? }\n", "target": "\n\ndef isPrime(n):\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return False        \n    return True\n\ndef isBackPrime(n):\n    if not isPrime(n):\n        return False\n    m = 0\n    while n:\n        m *= 10\n        m += n % 10\n        n //= 10\n    return isPrime(m)\n\nif __name__ == '__main__':\n    for n in range(2, 499):\n        if isBackPrime(n):\n            print(n, end=' ');\n"}
{"id": 336698, "name": "Inverted syntax", "source": "Translate Ruby to Python: \nif n < 0 then raise ArgumentError, \"negative n\" end\nraise ArgumentError, \"negative n\" if n < 0\n\n\nunless Process.respond_to? :fork then exit 1 end\nexit 1 unless Process.respond_to? :fork\n\n\nwhile ary.length > 0 do puts ary.shift end\nputs ary.shift while ary.length > 0\n\n\nuntil ary.empty? do puts ary.shift end\nputs ary.shift until ary.empty?\n", "target": "x = truevalue if condition else falsevalue\n"}
{"id": 336699, "name": "Inverted syntax", "source": "Translate Ruby to Python: \nif n < 0 then raise ArgumentError, \"negative n\" end\nraise ArgumentError, \"negative n\" if n < 0\n\n\nunless Process.respond_to? :fork then exit 1 end\nexit 1 unless Process.respond_to? :fork\n\n\nwhile ary.length > 0 do puts ary.shift end\nputs ary.shift while ary.length > 0\n\n\nuntil ary.empty? do puts ary.shift end\nputs ary.shift until ary.empty?\n", "target": "x = truevalue if condition else falsevalue\n"}
{"id": 336700, "name": "URL encoding", "source": "Translate Ruby to Python: require 'cgi'\nputs CGI.escape(\"http://foo bar/\").gsub(\"+\", \"%20\")\n\n", "target": "import urllib\ns = 'http://foo/bar/'\ns = urllib.quote(s)\n"}
{"id": 336701, "name": "URL encoding", "source": "Translate Ruby to Python: require 'cgi'\nputs CGI.escape(\"http://foo bar/\").gsub(\"+\", \"%20\")\n\n", "target": "import urllib\ns = 'http://foo/bar/'\ns = urllib.quote(s)\n"}
{"id": 336702, "name": "LU decomposition", "source": "Translate Ruby to Python: require 'matrix'\n\nclass Matrix\n  def lu_decomposition\n    p = get_pivot\n    tmp = p * self\n    u = Matrix.zero(row_size).to_a\n    l = Matrix.identity(row_size).to_a\n    (0 ... row_size).each do |i|\n      (0 ... row_size).each do |j|\n        if j >= i\n          \n          u[i][j] = tmp[i,j] - (0 ... i).inject(0.0) {|sum, k| sum + u[k][j] * l[i][k]}\n        else\n          \n          l[i][j] = (tmp[i,j] - (0 ... j).inject(0.0) {|sum, k| sum + u[k][j] * l[i][k]}) / u[j][j]\n        end\n      end\n    end\n    [ Matrix[*l], Matrix[*u], p ]\n  end\n  \n  def get_pivot\n    raise ArgumentError, \"must be square\" unless square?\n    id = Matrix.identity(row_size).to_a\n    (0 ... row_size).each do |i|\n      max = self[i,i]\n      row = i\n      (i ... row_size).each do |j|\n        if self[j,i] > max\n          max = self[j,i]\n          row = j\n        end\n      end\n      id[i], id[row] = id[row], id[i]\n    end\n    Matrix[*id]\n  end\n  \n  def pretty_print(format, head=nil)\n    puts head if head\n    puts each_slice(column_size).map{|row| format*row_size % row}\n  end\nend\n\nputs \"Example 1:\"\na = Matrix[[1,  3,  5],\n           [2,  4,  7],\n           [1,  1,  0]]\na.pretty_print(\" %2d\", \"A\")\nl, u, p = a.lu_decomposition\nl.pretty_print(\" %8.5f\", \"L\")\nu.pretty_print(\" %8.5f\", \"U\")\np.pretty_print(\" %d\",    \"P\")\n\nputs \"\\nExample 2:\"\na = Matrix[[11, 9,24,2], \n           [ 1, 5, 2,6], \n           [ 3,17,18,1], \n           [ 2, 5, 7,1]]\na.pretty_print(\" %2d\", \"A\")\nl, u, p = a.lu_decomposition\nl.pretty_print(\" %8.5f\", \"L\")\nu.pretty_print(\" %8.5f\", \"U\")\np.pretty_print(\" %d\",    \"P\")\n", "target": "from pprint import pprint\n\ndef matrixMul(A, B):\n    TB = zip(*B)\n    return [[sum(ea*eb for ea,eb in zip(a,b)) for b in TB] for a in A]\n\ndef pivotize(m):\n    \n    n = len(m)\n    ID = [[float(i == j) for i in xrange(n)] for j in xrange(n)]\n    for j in xrange(n):\n        row = max(xrange(j, n), key=lambda i: abs(m[i][j]))\n        if j != row:\n            ID[j], ID[row] = ID[row], ID[j]\n    return ID\n\ndef lu(A):\n    \n    n = len(A)\n    L = [[0.0] * n for i in xrange(n)]\n    U = [[0.0] * n for i in xrange(n)]\n    P = pivotize(A)\n    A2 = matrixMul(P, A)\n    for j in xrange(n):\n        L[j][j] = 1.0\n        for i in xrange(j+1):\n            s1 = sum(U[k][j] * L[i][k] for k in xrange(i))\n            U[i][j] = A2[i][j] - s1\n        for i in xrange(j, n):\n            s2 = sum(U[k][j] * L[i][k] for k in xrange(j))\n            L[i][j] = (A2[i][j] - s2) / U[j][j]\n    return (L, U, P)\n\na = [[1, 3, 5], [2, 4, 7], [1, 1, 0]]\nfor part in lu(a):\n    pprint(part, width=19)\n    print\nprint\nb = [[11,9,24,2],[1,5,2,6],[3,17,18,1],[2,5,7,1]]\nfor part in lu(b):\n    pprint(part)\n    print\n"}
{"id": 336703, "name": "Optional parameters", "source": "Translate Ruby to Python: def table_sort(table, ordering=:<=>, column=0, reverse=false)\n  \n", "target": ">>> def printtable(data):\n    for row in data:\n        print ' '.join('%-5s' % ('\"%s\"' % cell) for cell in row)\n\n        \n>>> import operator\n>>> def sorttable(table, ordering=None, column=0, reverse=False):\n    return sorted(table, cmp=ordering, key=operator.itemgetter(column), reverse=reverse)\n\n>>> data = [[\"a\", \"b\", \"c\"], [\"\", \"q\", \"z\"], [\"zap\", \"zip\", \"Zot\"]]\n>>> printtable(data)\n\"a\"   \"b\"   \"c\"  \n\"\"    \"q\"   \"z\"  \n\"zap\" \"zip\" \"Zot\"\n>>> printtable( sorttable(data) )\n\"\"    \"q\"   \"z\"  \n\"a\"   \"b\"   \"c\"  \n\"zap\" \"zip\" \"Zot\"\n>>> printtable( sorttable(data, column=2) )\n\"zap\" \"zip\" \"Zot\"\n\"a\"   \"b\"   \"c\"  \n\"\"    \"q\"   \"z\"  \n>>> printtable( sorttable(data, column=1) )\n\"a\"   \"b\"   \"c\"  \n\"\"    \"q\"   \"z\"  \n\"zap\" \"zip\" \"Zot\"\n>>> printtable( sorttable(data, column=1, reverse=True) )\n\"zap\" \"zip\" \"Zot\"\n\"\"    \"q\"   \"z\"  \n\"a\"   \"b\"   \"c\"  \n>>> printtable( sorttable(data, ordering=lambda a,b: cmp(len(b),len(a))) )\n\"zap\" \"zip\" \"Zot\"\n\"a\"   \"b\"   \"c\"  \n\"\"    \"q\"   \"z\"  \n>>>\n"}
{"id": 336704, "name": "Numeric error propagation", "source": "Translate Ruby to Python: class NumberWithUncertainty\n  def initialize(number, error)\n    @num = number\n    @err = error.abs\n  end\n  attr_reader :num, :err\n\n  def +(other)\n    if other.kind_of?(self.class)\n      self.class.new(num + other.num, Math::hypot(err, other.err))\n    else\n      self.class.new(num + other, err)\n    end\n  end\n\n  def -(other)\n    if other.kind_of?(self.class)\n      self.class.new(num - other.num, Math::hypot(err, other.err))\n    else\n      self.class.new(num - other, err)\n    end\n  end\n\n  def *(other)\n    if other.kind_of?(self.class)\n      prod = num * other.num\n      e = Math::hypot((prod * err / num), (prod * other.err / other.num))\n      self.class.new(prod, e)\n    else\n      self.class.new(num * other, (err * other).abs)\n    end\n  end\n\n  def /(other)\n    if other.kind_of?(self.class)\n      quo = num / other.num\n      e = Math::hypot((quo * err / num), (quo * other.err / other.num))\n      self.class.new(quo, e)\n    else\n      self.class.new(num / other, (err * other).abs)\n    end\n  end\n\n  def **(exponent)\n    Float(exponent) rescue raise ArgumentError, \"not an number: \n    prod = num ** exponent\n    self.class.new(prod, (prod * exponent * err / num).abs)\n  end\n\n  def sqrt\n    self ** 0.5\n  end\n\n  def to_s\n    \"\n  end\nend\n\nx1 = NumberWithUncertainty.new(100, 1.1)\ny1 = NumberWithUncertainty.new( 50, 1.2)\nx2 = NumberWithUncertainty.new(200, 2.2)\ny2 = NumberWithUncertainty.new(100, 2.3)\n\nputs ((x1 - x2) ** 2 + (y1 - y2) ** 2).sqrt\n", "target": "from collections import namedtuple\nimport math\n \nclass I(namedtuple('Imprecise', 'value, delta')):\n    'Imprecise type: I(value=0.0, delta=0.0)' \n \n    __slots__ = () \n \n    def __new__(_cls, value=0.0, delta=0.0):\n        'Defaults to 0.0 \u00b1 delta'\n        return super().__new__(_cls, float(value), abs(float(delta)))\n \n    def reciprocal(self):\n        return I(1. / self.value, self.delta / (self.value**2)) \n \n    def __str__(self):\n        'Shorter form of Imprecise as string'\n        return 'I(%g, %g)' % self\n \n    def __neg__(self):\n        return I(-self.value, self.delta)\n \n    def __add__(self, other):\n        if type(other) == I:\n            return I( self.value + other.value, (self.delta**2 + other.delta**2)**0.5 )\n        try:\n            c = float(other)\n        except:\n            return NotImplemented\n        return I(self.value + c, self.delta)\n\n    def __sub__(self, other):\n        return self + (-other)\n \n    def __radd__(self, other):\n        return I.__add__(self, other)\n \n    def __mul__(self, other):\n        if type(other) == I:\n            \n            \n            a1,b1 = self\n            a2,b2 = other\n            f = a1 * a2\n            return I( f, f * ( (b1 / a1)**2 + (b2 / a2)**2 )**0.5 )\n        try:\n            c = float(other)\n        except:\n            return NotImplemented\n        return I(self.value * c, self.delta * c)\n \n    def __pow__(self, other):\n        if type(other) == I:\n            return NotImplemented\n        try:\n            c = float(other)\n        except:\n            return NotImplemented\n        f = self.value ** c\n        return I(f, f * c * (self.delta / self.value))\n \n    def __rmul__(self, other):\n        return I.__mul__(self, other)\n \n    def __truediv__(self, other):\n        if type(other) == I:\n            return self.__mul__(other.reciprocal())\n        try:\n            c = float(other)\n        except:\n            return NotImplemented\n        return I(self.value / c, self.delta / c)\n \n    def __rtruediv__(self, other):\n        return other * self.reciprocal()\n \n    __div__, __rdiv__ = __truediv__, __rtruediv__\n \nImprecise = I\n\ndef distance(p1, p2):\n    x1, y1 = p1\n    x2, y2 = p2\n    return ((x1 - x2)**2 + (y1 - y2)**2)**0.5\n \nx1 = I(100, 1.1)\nx2 = I(200, 2.2)\ny1 = I( 50, 1.2)\ny2 = I(100, 2.3)\n\np1, p2 = (x1, y1), (x2, y2)\nprint(\"Distance between points\\n  p1: %s\\n  and p2: %s\\n  = %r\" % (\n      p1, p2, distance(p1, p2)))\n"}
{"id": 336705, "name": "Trabb Pardo\u2013Knuth algorithm", "source": "Translate Ruby to Python: def f(x) x.abs ** 0.5 + 5 * x ** 3 end\n\nputs \"Please enter 11 numbers:\"\nnums = 11.times.map{ gets.to_f }\n\nnums.reverse_each do |n|\n  print \"f(\n  res = f(n)\n  puts res > 400 ? \"Overflow!\" : res\nend\n", "target": "Python 3.2.2 (default, Sep  4 2011, 09:51:08) [MSC v.1500 32 bit (Intel)] on win32\nType \"copyright\", \"credits\" or \"license()\" for more information.\n>>> def f(x): return abs(x) ** 0.5 + 5 * x**3\n\n>>> print(', '.join('%s:%s' % (x, v if v<=400 else \"TOO LARGE!\")\n\t           for x,v in ((y, f(float(y))) for y in input('\\nnumbers: ').strip().split()[:11][::-1])))\n\n11 numbers: 1 2 3 4 5 6 7 8 9 10 11\n11:TOO LARGE!, 10:TOO LARGE!, 9:TOO LARGE!, 8:TOO LARGE!, 7:TOO LARGE!, 6:TOO LARGE!, 5:TOO LARGE!, 4:322.0, 3:136.73205080756887, 2:41.41421356237309, 1:6.0\n>>>\n"}
{"id": 336706, "name": "Rate counter", "source": "Translate Ruby to Python: require \"benchmark\"\n\nstruct Document\n  property :id\n  def initialize(@id : Int32) end\nend\n\ndocuments_a = [] of Int32 | Document\ndocuments_h = {} of Int32 => Int32 | Document \n\n1.upto(10_000) do |n|\n  d = Document.new(n)\n  documents_a << d\n  documents_h[d.id] = d\nend\n\nsearchlist = Array.new(1000){ rand(10_000)+1 }\n \nBenchmark.bm do |x|\n  x.report(\"array\"){searchlist.each{ |el| documents_a.any?{ |d| d == el }} }\n  x.report(\"hash\") {searchlist.each{ |el| documents_h.has_key?(el) } }\nend\nputs\nBenchmark.ips do |x|\n  x.report(\"array\"){searchlist.each{ |el| documents_a.any?{ |d| d == el }} }\n  x.report(\"hash\") {searchlist.each{ |el| documents_h.has_key?(el) } }\nend\n", "target": "import subprocess\nimport time\n\nclass Tlogger(object):\n    def __init__(self):\n        self.counts = 0\n        self.tottime = 0.0\n        self.laststart = 0.0\n        self.lastreport = time.time()\n\n    def logstart(self):\n        self.laststart = time.time()\n\n    def logend(self):\n        self.counts +=1\n        self.tottime += (time.time()-self.laststart)\n        if (time.time()-self.lastreport)>5.0:   \n           self.report()\n\n    def report(self):\n        if ( self.counts > 4*self.tottime):\n            print \"Subtask execution rate: %f times/second\"% (self.counts/self.tottime);\n        else:\n            print \"Average execution time: %f seconds\"%(self.tottime/self.counts);\n        self.lastreport = time.time()\n\n\ndef taskTimer( n, subproc_args ):\n    logger = Tlogger()\n\n    for x in range(n):\n        logger.logstart()\n        p = subprocess.Popen(subproc_args)\n        p.wait()\n        logger.logend()\n    logger.report()\n\n\nimport timeit\nimport sys\n\ndef main( ):\n\n    \n    s = \n    timer = timeit.Timer(s)\n    rzlts = timer.repeat(5, 5000)\n    for t in rzlts:\n        print \"Time for 5000 executions of statement = \",t\n    \n    \n    print \"\n    print \"Command:\",sys.argv[2:]\n    print \"\"\n    for k in range(3):\n       taskTimer( int(sys.argv[1]), sys.argv[2:])\n\nmain()\n"}
{"id": 336707, "name": "EKG sequence convergence", "source": "Translate Ruby to Python: class Seq(terms, callback) {\n    method next {\n        terms += callback(terms)\n    }\n\n    method nth(n) {\n        while (terms.len < n) {\n            self.next\n        }\n        terms[n-1]\n    }\n\n    method first(n) {\n        while (terms.len < n) {\n            self.next\n        }\n        terms.first(n)\n    }\n}\n\nfunc next_EKG (s) {\n    2..Inf -> first {|k|\n        !(s.contains(k) || s[-1].is_coprime(k))\n    }\n}\n\nfunc EKG (start) {\n    Seq([1, start], next_EKG)\n}\n\nfunc converge_at(ints) {\n    var ekgs = ints.map(EKG)\n\n    2..Inf -> first {|k|\n        (ekgs.map { .nth(k)        }.uniq.len == 1) &&\n        (ekgs.map { .first(k).sort }.uniq.len == 1)\n    }\n}\n\nfor k in [2, 5, 7, 9, 10] {\n    say \"EKG(\n}\n\nfor arr in [[5,7], [2, 5, 7, 9, 10]] {\n    var c = converge_at(arr)\n    say \"EKGs of \n}\n", "target": "from itertools import count, islice, takewhile\nfrom math import gcd\n\ndef EKG_gen(start=2):\n    \n    c = count(start + 1)\n    last, so_far = start, list(range(2, start))\n    yield 1, []\n    yield last, []\n    while True:\n        for index, sf in enumerate(so_far):\n            if gcd(last, sf) > 1:\n                last = so_far.pop(index)\n                yield last, so_far[::]\n                break\n        else:\n            so_far.append(next(c))\n\ndef find_convergence(ekgs=(5,7)):\n    \"Returns the convergence point or zero if not found within the limit\"\n    ekg = [EKG_gen(n) for n in ekgs]\n    for e in ekg:\n        next(e)    \n    return 2 + len(list(takewhile(lambda state: not all(state[0] == s for  s in state[1:]),\n                                  zip(*ekg))))\n\nif __name__ == '__main__':\n    for start in 2, 5, 7, 9, 10:\n        print(f\"EKG({start}):\", str([n[0] for n in islice(EKG_gen(start), 10)])[1: -1])\n    print(f\"\\nEKG(5) and EKG(7) converge at term {find_convergence(ekgs=(5,7))}!\")\n"}
{"id": 336708, "name": "Dice game probabilities", "source": "Translate Ruby to Python: def roll_dice(n_dice, n_faces)\n  return [[0,1]] if n_dice.zero?\n  one  = [1] * n_faces\n  zero = [0] * (n_faces-1)\n  (1...n_dice).inject(one){|ary,_|\n    (zero + ary + zero).each_cons(n_faces).map{|a| a.inject(:+)}\n  }.map.with_index(n_dice){|n,sum| [sum,n]}  \nend\n\ndef game(dice1, faces1, dice2, faces2)\n  p1 = roll_dice(dice1, faces1)\n  p2 = roll_dice(dice2, faces2)\n  p1.product(p2).each_with_object([0,0,0]) do |((sum1, n1), (sum2, n2)), win|\n    win[sum1 <=> sum2] += n1 * n2        \n  end\nend\n\n[[9, 4, 6, 6], [5, 10, 6, 7]].each do |d1, f1, d2, f2|\n  puts \"player 1 has \n  puts \"player 2 has \n  win = game(d1, f1, d2, f2)\n  sum = win.inject(:+)\n  puts \"Probability for player 1 to win: \n       \"                              -> \nend\n", "target": "from itertools import product\n\ndef gen_dict(n_faces, n_dice):\n    counts = [0] * ((n_faces + 1) * n_dice)\n    for t in product(range(1, n_faces + 1), repeat=n_dice):\n        counts[sum(t)] += 1\n    return counts, n_faces ** n_dice\n\ndef beating_probability(n_sides1, n_dice1, n_sides2, n_dice2):\n    c1, p1 = gen_dict(n_sides1, n_dice1)\n    c2, p2 = gen_dict(n_sides2, n_dice2)\n    p12 = float(p1 * p2)\n\n    return sum(p[1] * q[1] / p12\n               for p, q in product(enumerate(c1), enumerate(c2))\n               if p[0] > q[0])\n\nprint beating_probability(4, 9, 6, 6)\nprint beating_probability(10, 5, 7, 6)\n"}
{"id": 336709, "name": "Metronome", "source": "Translate Ruby to Python: \n\nbpm = Integer(ARGV[0]) rescue 60 \nmsr = Integer(ARGV[1]) rescue 4 \ni = 0\n\nloop do\n  (msr-1).times do \n    puts \"\\a\"\n    sleep(60.0/bpm)\n  end\n  puts \"\\aAND \n  sleep(60.0/bpm)\nend\n", "target": "\nimport time\n\ndef main(bpm = 72, bpb = 4):\n    sleep = 60.0 / bpm\n    counter = 0\n    while True:\n        counter += 1\n        if counter % bpb:\n            print 'tick'\n        else:\n            print 'TICK'\n        time.sleep(sleep)\n        \n\n\nmain()\n"}
{"id": 336710, "name": "Sum of elements below main diagonal of matrix", "source": "Translate Ruby to Python: arr = [\n   [ 1,  3,  7,  8, 10],\n   [ 2,  4, 16, 14,  4],\n   [ 3,  1,  9, 18, 11],\n   [12, 14, 17, 18, 20],\n   [ 7,  1,  3,  9,  5]\n]\np  arr.each_with_index.sum {|row, x| row[0, x].sum}\n", "target": "from numpy import array, tril, sum\n\nA = [[1,3,7,8,10],\n    [2,4,16,14,4],\n    [3,1,9,18,11],\n    [12,14,17,18,20],\n    [7,1,3,9,5]]\n\nprint(sum(tril(A, -1)))   \n"}
{"id": 336711, "name": "Pythagoras tree", "source": "Translate Ruby to Python: \n\ndef setup\n  sketch_title 'Pythagoras Tree'\n  background(255)\n  stroke(0, 255, 0)\n  tree(width / 2.3, height, width / 1.8, height, 10)\nend\n\ndef tree(x1, y1, x2, y2, depth)\n  return if depth <= 0\n\n  dx = (x2 - x1)\n  dy = (y1 - y2)\n\n  x3 = (x2 - dy)\n  y3 = (y2 - dx)\n  x4 = (x1 - dy)\n  y4 = (y1 - dx)\n  x5 = (x4 + 0.5 * (dx - dy))\n  y5 = (y4 - 0.5 * (dx + dy))\n  \n  begin_shape\n  fill(0.0, 255.0 / depth, 0.0)\n  vertex(x1, y1)\n  vertex(x2, y2)\n  vertex(x3, y3)\n  vertex(x4, y4)\n  vertex(x1, y1)\n  end_shape\n  \n  begin_shape\n  fill(0.0, 255.0 / depth, 0.0)\n  vertex(x3, y3)\n  vertex(x4, y4)\n  vertex(x5, y5)\n  vertex(x3, y3)\n  end_shape\n  tree(x4, y4, x5, y5, depth - 1)\n  tree(x5, y5, x3, y3, depth - 1)\nend\n\ndef settings\n  size(800, 400)\nend\n", "target": "def setup():\n    size(800, 400)\n    background(255)\n    stroke(0, 255, 0)\n    tree(width / 2.3, height, width / 1.8, height, 10)\n\n\ndef tree(x1, y1, x2, y2, depth):\n    if depth <= 0: return\n    dx = (x2 - x1)\n    dy = (y1 - y2)\n\n    x3 = (x2 - dy)\n    y3 = (y2 - dx)\n    x4 = (x1 - dy)\n    y4 = (y1 - dx)\n    x5 = (x4 + 0.5 * (dx - dy))\n    y5 = (y4 - 0.5 * (dx + dy))\n\n    \n    beginShape()\n    fill(0.0, 255.0 / depth, 0.0)\n    vertex(x1, y1)\n    vertex(x2, y2)\n    vertex(x3, y3)\n    vertex(x4, y4)\n    vertex(x1, y1)\n    endShape()\n\n    \n    beginShape()\n    fill(0.0, 255.0 / depth, 0.0)\n    vertex(x3, y3)\n    vertex(x4, y4)\n    vertex(x5, y5)\n    vertex(x3, y3)\n    endShape()\n\n    tree(x4, y4, x5, y5, depth - 1)\n    tree(x5, y5, x3, y3, depth - 1)\n"}
{"id": 336712, "name": "Rep-string", "source": "Translate Ruby to Python: def rep(s : String) : Int32\n  x = s.size // 2\n\n  while x > 0\n    return x if s.starts_with? s[x..]\n    x -= 1\n  end\n\n  0\nend\n\ndef main\n  %w(\n    1001110011\n    1110111011\n    0010010010\n    1010101010\n    1111111111\n    0100101101\n    0100100\n    101\n    11\n    00\n    1\n  ).each do |s|\n    n = rep s\n    puts n > 0 ? \"\\\"\n  end\nend\n\nmain\n", "target": "def is_repeated(text):\n    'check if the first part of the string is repeated throughout the string'\n    for x in range(len(text)//2, 0, -1):\n        if text.startswith(text[x:]): return x\n    return 0\n\nmatchstr = \nfor line in matchstr.split():\n    ln = is_repeated(line)\n    print('%r has a repetition length of %i i.e. %s' \n           % (line, ln, repr(line[:ln]) if ln else '*not* a rep-string'))\n"}
{"id": 336713, "name": "File size distribution", "source": "Translate Ruby to Python: func traverse(Block callback, Dir dir) {\n    dir.open(\\var dir_h) || return nil\n\u00a0\n    for entry in (dir_h.entries) {\n        if (entry.kind_of(Dir)) {\n            traverse(callback, entry)\n        } else {\n            callback(entry)\n        }\n    }\n}\n\u00a0\nvar dir = (ARGV ? Dir(ARGV[0]) : Dir.cwd)\n\nvar group = Hash()\nvar files_num = 0\nvar total_size = 0\n\ntraverse({ |file|\n    group{file.size+1 -> log10.round} := 0 += 1\n    total_size += file.size\n    files_num += 1\n}, dir)\n\nfor k,v in (group.sort_by { |k,_| Num(k) }) {\n    say \"log10(size) ~~ \n}\n\nsay \"Total: \n", "target": "import sys, os\nfrom collections import Counter\n\ndef dodir(path):\n    global h\n\n    for name in os.listdir(path):\n        p = os.path.join(path, name)\n\n        if os.path.islink(p):\n            pass\n        elif os.path.isfile(p):\n            h[os.stat(p).st_size] += 1\n        elif os.path.isdir(p):\n            dodir(p)\n        else:\n            pass\n\ndef main(arg):\n    global h\n    h = Counter()\n    for dir in arg:\n        dodir(dir)\n\n    s = n = 0\n    for k, v in sorted(h.items()):\n        print(\"Size %d -> %d file(s)\" % (k, v))\n        n += v\n        s += k * v\n    print(\"Total %d bytes for %d files\" % (s, n))\n\nmain(sys.argv[1:])\n"}
{"id": 336714, "name": "Topswops", "source": "Translate Ruby to Python: def f1(a)\n  i = 0\n  while (a0 = a[0]) > 1\n    a[0...a0] = a[0...a0].reverse\n    i += 1\n  end\n  i\nend\n\ndef fannkuch(n)\n  [*1..n].permutation.map{|a| f1(a)}.max\nend\n\nfor n in 1..10\n  puts \"%2d\u00a0: %d\" % [n, fannkuch(n)]\nend\n", "target": ">>> from itertools import permutations\n>>> def f1(p):\n\ti = 0\n\twhile True:\n\t\tp0  = p[0]\n\t\tif p0 == 1: break\n\t\tp[:p0] = p[:p0][::-1]\n\t\ti  += 1\n\treturn i\n\n>>> def fannkuch(n):\n\treturn max(f1(list(p)) for p in permutations(range(1, n+1)))\n\n>>> for n in range(1, 11): print(n,fannkuch(n))\n\n1 0\n2 1\n3 2\n4 4\n5 7\n6 10\n7 16\n8 22\n9 30\n10 38\n>>>\n"}
{"id": 336715, "name": "Sequence_ smallest number greater than previous term with exactly n divisors", "source": "Translate Ruby to Python: require 'prime'\n \ndef num_divisors(n)\n  n.prime_division.inject(1){|prod, (_p,n)| prod *= (n + 1) } \nend\n\nseq = Enumerator.new do |y|\n  cur = 0\n  (1..).each do |i|\n    if num_divisors(i) == cur + 1 then\n      y << i\n      cur += 1\n    end\n  end\nend\n\np seq.take(15)\n", "target": "def divisors(n):\n    divs = [1]\n    for ii in range(2, int(n ** 0.5) + 3):\n        if n % ii == 0:\n            divs.append(ii)\n            divs.append(int(n / ii))\n    divs.append(n)\n    return list(set(divs))\n\n\ndef sequence(max_n=None):\n    previous = 0\n    n = 0\n    while True:\n        n += 1\n        ii = previous\n        if max_n is not None:\n            if n > max_n:\n                break\n        while True:\n            ii += 1\n            if len(divisors(ii)) == n:\n                yield ii\n                previous = ii\n                break\n\n\nif __name__ == '__main__':\n    for item in sequence(15):\n        print(item)\n"}
{"id": 336716, "name": "McNuggets problem", "source": "Translate Ruby to Python: def mcnugget(limit)\n  sv = (0..limit).to_a\n\n  (0..limit).step(6) do |s|\n    (0..limit).step(9) do |n|\n      (0..limit).step(20) do |t|\n        sv.delete(s + n + t)\n      end\n    end\n  end\n\n  sv.max\nend\n\nputs(mcnugget 100)\n", "target": ">>> from itertools import product\n>>> nuggets = set(range(101))\n>>> for s, n, t in product(range(100//6+1), range(100//9+1), range(100//20+1)):\n\tnuggets.discard(6*s + 9*n + 20*t)\n\n\t\n>>> max(nuggets)\n43\n>>>\n"}
{"id": 336717, "name": "Idiomatically determine all the lowercase and uppercase letters", "source": "Translate Ruby to Python: puts \"Lowercase:\", [*\"a\"..\"z\"].join, \"Uppercase:\", [*\"A\"..\"Z\"].join\n", "target": "classes = (str.isupper, str.islower, str.isalnum, str.isalpha, str.isdecimal,\n           str.isdigit, str.isidentifier, str.isnumeric, str.isprintable,\n           str.isspace, str.istitle)\n\nfor stringclass in classes:\n    chars = ''.join(chr(i) for i in range(0x10FFFF+1) if stringclass(chr(i)))\n    print('\\nString class %s has %i characters the first of which are:\\n  %r'\n          % (stringclass.__name__, len(chars), chars[:100]))\n"}
{"id": 336718, "name": "Superellipse", "source": "Translate Ruby to Python: const (\n    a = 200,\n    b = 200,\n    n = 2.5,\n)\n\n\nfunc y(x) { b * (1 - abs(x/a)**n -> root(n)) -> int }\n\nfunc pline(q) {\n    <<-\"EOT\";\n    <polyline points=\"\n    style=\"fill:none; stroke:black; stroke-width:3\" transform=\"translate(\n    EOT\n}\n\n\nsay <<-\"EOT\"\n    <?xml version=\"1.0\" standalone=\"no\"?>\n    <!DOCTYPE svg PUBLIC \"-//W3C//DTD SVG 1.1//EN\" \"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd\">\n    <svg height=\"\n    EOT\n\n\nvar q = { |x| (x, y(x)) }.map(0..200 `by` 2)\n\n[\n    pline(q),\n    pline(q\u00a0\u00bb*\u00ab\u00a0[ 1,-1]), \n    pline(q\u00a0\u00bb*\u00ab\u00a0[-1,-1]), \n    pline(q\u00a0\u00bb*\u00ab\u00a0[-1, 1]), \n].each { .print }\n\u00a0\nsay '</svg>'\n", "target": "\n\n\nimport matplotlib.pyplot as plt\nfrom math import sin, cos, pi\n\ndef sgn(x):\n\treturn ((x>0)-(x<0))*1\n\na,b,n=200,200,2.5 \nna=2/n\nstep=100 \npiece=(pi*2)/step\nxp=[];yp=[]\n\nt=0\nfor t1 in range(step+1):\n\t\n\tx=(abs((cos(t)))**na)*a*sgn(cos(t))\n\ty=(abs((sin(t)))**na)*b*sgn(sin(t))\n\txp.append(x);yp.append(y)\n\tt+=piece\n\nplt.plot(xp,yp) \nplt.title(\"Superellipse with parameter \"+str(n))\nplt.show()\n"}
{"id": 336719, "name": "Mutex", "source": "Translate Ruby to Python: require 'mutex_m'\n\nclass SomethingWithMutex\n  include Mutex_m\n  ...\nend\n", "target": "import threading\nfrom time import sleep\n\n\n\nres = 2\nsema = threading.Semaphore(res)\n\nclass res_thread(threading.Thread):\n    def run(self):\n        global res\n        n = self.getName()\n        for i in range(1, 4):\n            \n            \n            \n            sema.acquire()\n            res = res - 1\n            print n, \"+  res count\", res\n            sleep(2)\n\n                        \n            res = res + 1\n            print n, \"-  res count\", res\n            sema.release()\n\n\nfor i in range(1, 5):\n    t = res_thread()\n    t.start()\n"}
{"id": 336720, "name": "Jaro similarity", "source": "Translate Ruby to Python: def jaro(s, t)\n    return 1.0 if s == t\n \n    s_len = s.size\n    t_len = t.size\n    match_distance = ({s_len, t_len}.max // 2) - 1\n\n    s_matches = Array.new(s_len, false)\n    t_matches = Array.new(t_len, false)\n    matches = 0.0\n\n    s_len.times do |i|\n        j_start = {0, i - match_distance}.max\n        j_end = {i + match_distance, t_len - 1}.min\n\n        (j_start..j_end).each do |j|\n            t_matches[j] && next                \n            s[i] == t[j] || next                \n            s_matches[i] = true\n            t_matches[j] = true\n            matches += 1.0\n            break\n        end\n    end\n\n    return 0.0 if matches == 0.0\n \n    k = 0\n    transpositions = 0.0\n    s_len.times do |i|\n        s_matches[i] || next                    \n        while ! t_matches[k]; k += 1 end        \n        s[i] == t[k] || (transpositions += 1.0) \n        k += 1\n    end\n \n    ((matches / s_len) + (matches / t_len) +\n    ((matches - transpositions / 2.0) / matches)) / 3.0\nend\n\n%w( MARTHA    MARHTA\n    DIXON     DICKSONX\n    JELLYFISH SMELLYFISH\n  ).each_slice(2) { |(s ,t)| puts \"jaro(\n", "target": "\n\nfrom __future__ import division\n\n\ndef jaro(s, t):\n    \n    s_len = len(s)\n    t_len = len(t)\n\n    if s_len == 0 and t_len == 0:\n        return 1\n\n    match_distance = (max(s_len, t_len) // 2) - 1\n\n    s_matches = [False] * s_len\n    t_matches = [False] * t_len\n\n    matches = 0\n    transpositions = 0\n\n    for i in range(s_len):\n        start = max(0, i - match_distance)\n        end = min(i + match_distance + 1, t_len)\n\n        for j in range(start, end):\n            if t_matches[j]:\n                continue\n            if s[i] != t[j]:\n                continue\n            s_matches[i] = True\n            t_matches[j] = True\n            matches += 1\n            break\n\n    if matches == 0:\n        return 0\n\n    k = 0\n    for i in range(s_len):\n        if not s_matches[i]:\n            continue\n        while not t_matches[k]:\n            k += 1\n        if s[i] != t[k]:\n            transpositions += 1\n        k += 1\n\n    return ((matches / s_len) +\n            (matches / t_len) +\n            ((matches - transpositions / 2) / matches)) / 3\n\n\ndef main():\n    \n\n    for s, t in [('MARTHA', 'MARHTA'),\n                 ('DIXON', 'DICKSONX'),\n                 ('JELLYFISH', 'SMELLYFISH')]:\n        print(\"jaro(%r, %r) = %.10f\" % (s, t, jaro(s, t)))\n\n\nif __name__ == '__main__':\n    main()\n"}
{"id": 336721, "name": "Odd word problem", "source": "Translate Ruby to Python: f, r = nil\nfwd = proc {|c|\n  c =~ /[[:alpha:]]/ ? [(print c), fwd[Fiber.yield f]][1] : c }\nrev = proc {|c|\n  c =~ /[[:alpha:]]/ ? [rev[Fiber.yield r], (print c)][0] : c }\n\n(f = Fiber.new { loop { print fwd[Fiber.yield r] }}).resume\n(r = Fiber.new { loop { print rev[Fiber.yield f] }}).resume\n\ncoro = f\nuntil $stdin.eof?\n  coro = coro.resume($stdin.getc)\nend\n", "target": "from sys import stdin, stdout\n\ndef char_in(): return stdin.read(1)\ndef char_out(c): stdout.write(c)\n\ndef odd(prev = lambda: None):\n\ta = char_in()\n\tif not a.isalpha():\n\t\tprev()\n\t\tchar_out(a)\n\t\treturn a != '.'\n\n\t\n\tdef clos():\n\t\tchar_out(a)\n\t\tprev()\n\n\treturn odd(clos)\n\ndef even():\n\twhile True:\n\t\tc = char_in()\n\t\tchar_out(c)\n\t\tif not c.isalpha(): return c != '.'\n\ne = False\nwhile odd() if e else even():\n\te = not e\n"}
{"id": 336722, "name": "Pseudo-random numbers_PCG32", "source": "Translate Ruby to Python: class PCG32\n  MASK64 = (1 << 64) - 1\n  MASK32 = (1 << 32) - 1\n  CONST  = 6364136223846793005\n\n  def seed(seed_state, seed_sequence)\n    @state = 0\n    @inc = ((seed_sequence << 1) | 1) & MASK64\n    next_int\n    @state = @state + seed_state\n    next_int\n  end\n  \n  def next_int\n    old = @state\n    @state = ((old * CONST) + @inc) & MASK64\n    xorshifted = (((old >> 18) ^ old) >> 27) & MASK32\n    rot = (old >> 59) & MASK32\n    answer = (xorshifted >> rot) | (xorshifted << ((-rot) & 31))\n    answer & MASK32\n  end\n  \n  def next_float\n    next_int.fdiv(1 << 32)\n  end\n  \nend\n\nrandom_gen = PCG32.new\nrandom_gen.seed(42, 54)\n5.times{puts random_gen.next_int}\n\nrandom_gen.seed(987654321, 1)\np 100_000.times.each{(random_gen.next_float * 5).floor}.tally.sort.to_h\n", "target": "mask64 = (1 << 64) - 1\nmask32 = (1 << 32) - 1\nCONST = 6364136223846793005\n\n\nclass PCG32():\n    \n    def __init__(self, seed_state=None, seed_sequence=None):\n        if all(type(x) == int for x in (seed_state, seed_sequence)):\n            self.seed(seed_state, seed_sequence)\n        else:\n            self.state = self.inc = 0\n    \n    def seed(self, seed_state, seed_sequence):\n        self.state = 0\n        self.inc = ((seed_sequence << 1) | 1) & mask64\n        self.next_int()\n        self.state = (self.state + seed_state)\n        self.next_int()\n        \n    def next_int(self):\n        \"return random 32 bit unsigned int\"\n        old = self.state\n        self.state = ((old * CONST) + self.inc) & mask64\n        xorshifted = (((old >> 18) ^ old) >> 27) & mask32\n        rot = (old >> 59) & mask32\n        answer = (xorshifted >> rot) | (xorshifted << ((-rot) & 31))\n        answer = answer &mask32\n        \n        return answer\n    \n    def  next_float(self):\n        \"return random float between 0 and 1\"\n        return self.next_int() / (1 << 32)\n    \n\nif __name__ == '__main__':\n    random_gen = PCG32()\n    random_gen.seed(42, 54)\n    for i in range(5):\n        print(random_gen.next_int())\n        \n    random_gen.seed(987654321, 1)\n    hist = {i:0 for i in range(5)}\n    for i in range(100_000):\n        hist[int(random_gen.next_float() *5)] += 1\n    print(hist)\n"}
{"id": 336723, "name": "Memory layout of a data structure", "source": "Translate Ruby to Python: require 'bit-struct'\n\nclass RS232_9 < BitStruct\n  unsigned :cd,  1, \"Carrier detect\"       \n  unsigned :rd,  1, \"Received data\"        \n  unsigned :td,  1, \"Transmitted data\"     \n  unsigned :dtr, 1, \"Data terminal ready\"  \n  unsigned :sg,  1, \"Signal ground\"        \n  unsigned :dsr, 1, \"Data set ready\"       \n  unsigned :rts, 1, \"Request to send\"      \n  unsigned :cts, 1, \"Clear to send\"        \n  unsigned :ri,  1, \"Ring indicator\"       \n  \n  def self.new_with_int(value)\n    data = {}\n    fields.each_with_index {|f, i| data[f.name] = value[i]}\n    new(data)\n  end\nend\n\nnum = rand(2**9 - 1)\nputs \"num = \n\nsample1 = RS232_9.new([(\"%09d\" % num.to_s(2)).reverse].pack(\"B*\"))\nputs sample1.inspect_detailed\n\nsample2 = RS232_9.new_with_int(num)\nputs sample2.inspect_detailed\n\nputs \"CD is \n", "target": "from ctypes import Structure, c_int\n\nrs232_9pin  = \"_0 CD RD TD DTR SG DSR RTS CTS RI\".split()\nrs232_25pin = ( \"_0  PG  TD  RD  RTS CTS DSR SG  CD  pos neg\"\n                \"_11 SCD SCS STD TC  SRD RC\"\n                \"_18 SRS DTR SQD RI DRS XTC\" ).split()\n\nclass RS232_9pin(Structure):\n    _fields_ = [(__, c_int, 1) for __ in rs232_9pin]\n\n\t\nclass RS232_25pin(Structure):\n    _fields_ = [(__, c_int, 1) for __ in rs232_25pin]\n"}
{"id": 336724, "name": "Largest proper divisor of n", "source": "Translate Ruby to Python: require 'prime'\n\ndef a(n)\n  return 1 if n == 1 || n.prime?\n  (n/2).downto(1).detect{|d| n.remainder(d) == 0}\nend\n\n(1..100).map{|n| a(n).to_s.rjust(3)}.each_slice(10){|slice| puts slice.join}\n", "target": "def lpd(n):\n    for i in range(n-1,0,-1):\n        if n%i==0: return i\n    return 1\n\nfor i in range(1,101):\n    print(\"{:3}\".format(lpd(i)), end=i%10==0 and '\\n' or '')\n"}
{"id": 336725, "name": "Summarize and say sequence", "source": "Translate Ruby to Python: $cache = {}\ndef selfReferentialSequence_cached(n, seen = [])\n  return $cache[n] if $cache.include? n\n  return [] if seen.include? n\n\n  digit_count = Array.new(10, 0)\n  n.to_s.chars.collect {|char| digit_count[char.to_i] += 1}\n  term = ''\n  9.downto(0).each do |d|\n    if digit_count[d] > 0\n      term += digit_count[d].to_s + d.to_s\n    end\n  end\n  term = term.to_i\n  $cache[n] = [n] + selfReferentialSequence_cached(term, [n] + seen)\nend\n\nlimit = 1_000_000\nmax_len = 0\nmax_vals = []\n\n1.upto(limit - 1) do |n| \n  seq = selfReferentialSequence_cached(n)\n  if seq.length > max_len\n    max_len = seq.length\n    max_vals = [n]\n  elsif seq.length == max_len\n    max_vals << n\n  end\nend\n\nputs \"values: \nputs \"iterations: \nputs \"sequence:\"\nselfReferentialSequence_cached(max_vals[0]).each_with_index do |val, idx| \n  puts \"%2d %d\" % [idx + 1, val]\nend\n", "target": "from itertools import groupby, permutations\n\ndef A036058(number):\n    return ''.join( str(len(list(g))) + k\n                    for k,g in groupby(sorted(str(number), reverse=True)) )\n\ndef A036058_length(numberstring='0', printit=False):\n    iterations, last_three, queue_index = 1, ([None] * 3), 0\n\n    def A036058(number):\n        \n        return ''.join( str(len(list(g))) + k\n                        for k,g in groupby(number) )\n\n    while True:\n        if printit:\n            print(\"  %2i %s\" % (iterations, numberstring))\n        numberstring = ''.join(sorted(numberstring, reverse=True))\n        if numberstring in last_three:\n            break\n        assert iterations < 1000000\n        last_three[queue_index], numberstring = numberstring, A036058(numberstring)\n        iterations += 1\n        queue_index +=1\n        queue_index %=3\n    return iterations\n    \ndef max_A036058_length( start_range=range(11) ):\n    already_done = set()\n    max_len = (-1, [])\n    for n in start_range:\n        sn = str(n)\n        sns = tuple(sorted(sn, reverse=True))\n        if sns not in already_done:\n            already_done.add(sns)\n            size = A036058_length(sns)\n            if size > max_len[0]:\n                max_len = (size, [n])\n            elif size == max_len[0]:\n                max_len[1].append(n)\n    return max_len\n\nlenmax, starts = max_A036058_length( range(1000000) )\n\n\nallstarts = []\nfor n in starts:\n    allstarts += [int(''.join(x))\n                  for x in set(k\n                               for k in permutations(str(n), 4)\n                               if k[0] != '0')]\nallstarts = [x for x in sorted(allstarts) if x < 1000000]\n\nprint (  % (lenmax, allstarts)   )\n\nprint (  )\n\nfor n in starts:\n    print()\n    A036058_length(str(n), printit=True)\n"}
{"id": 336726, "name": "Koch curve", "source": "Translate Ruby to Python: attr_reader :koch\ndef settings\n  size 600, 600\nend\n\ndef setup\n  sketch_title '2D Koch'\n  @koch = KochSnowflake.new\n  koch.create_grammar 5\n  no_loop\nend\n\ndef draw\n  background 0\n  koch.render\nend\n\n\nclass Grammar\n  attr_reader :axiom, :rules\n  def initialize(axiom, rules)\n    @axiom = axiom\n    @rules = rules\n  end\n\n  def apply_rules(prod)\n    prod.gsub(/./) { |token| rules.fetch(token, token) }\n  end\n\n  def generate(gen)\n    return axiom if gen.zero?\n\n    prod = axiom\n    gen.times do\n      prod = apply_rules(prod)\n    end\n    prod\n  end\nend\n\nTurtle = Struct.new(:x, :y, :theta)\n\n\nclass KochSnowflake\n  include Processing::Proxy\n\n  attr_reader :grammar, :axiom, :draw_length, :production, :turtle\n  DELTA = 60.radians\n\n  def initialize\n    @axiom = 'F--F--F' \n    @grammar = Grammar.new(\n      axiom,\n      'F' => 'F+F--F+F'\n    )\n    @draw_length = 20\n    stroke 0, 255, 0\n    stroke_weight 2\n    @turtle = Turtle.new(width / 5, height * 0.7, 0)\n  end\n\n  def render\n    production.scan(/./) do |element|\n      case element\n      when 'F' \n        draw_line(turtle)\n      when '+'\n        turtle.theta += DELTA\n      when '-'\n        turtle.theta -= DELTA\n      when 'L', 'R'\n      else puts 'Grammar not recognized'\n      end\n    end\n  end\n\n  def draw_line(turtle)\n    x_temp = turtle.x\n    y_temp = turtle.y\n    @turtle.x += draw_length * Math.cos(turtle.theta)\n    @turtle.y += draw_length * Math.sin(turtle.theta)\n    line(x_temp, y_temp, turtle.x, turtle.y)\n  end\n\n  \n  \n  \n  \n\n  def create_grammar(gen)\n    @draw_length *= 0.6**gen\n    @production = @grammar.generate gen\n  end\nend\n", "target": "l = 300\n\ndef setup():\n    size(400, 400)\n    background(0, 0, 255)\n    stroke(255)\n    \n    translate(width / 2.0, height / 2.0)\n    \n    translate(-l / 2.0, l * sqrt(3) / 6.0)\n    for i in range(4):\n        kcurve(0, l)\n        rotate(radians(120))\n        translate(-l, 0)\n\n\ndef kcurve(x1, x2):\n    s = (x2 - x1) / 3.0\n    if s < 5:\n        pushMatrix()\n        translate(x1, 0)\n        line(0, 0, s, 0)\n        line(2 * s, 0, 3 * s, 0)\n        translate(s, 0)\n        rotate(radians(60))\n        line(0, 0, s, 0)\n        translate(s, 0)\n        rotate(radians(-120))\n        line(0, 0, s, 0)\n        popMatrix()\n        return\n\n    pushMatrix()\n    translate(x1, 0)\n    kcurve(0, s)\n    kcurve(2 * s, 3 * s)\n    translate(s, 0)\n    rotate(radians(60))\n    kcurve(0, s)\n    translate(s, 0)\n    rotate(radians(-120))\n    kcurve(0, s)\n    popMatrix()\n"}
{"id": 336727, "name": "Pseudo-random numbers_Xorshift star", "source": "Translate Ruby to Python: class Xorshift_star\n  MASK64 = (1 << 64) - 1\n  MASK32 = (1 << 32) - 1\n\n  def initialize(seed = 0) = @state = seed & MASK64\n\n  def next_int\n    x = @state\n    x =  x ^ (x >> 12) \n    x = (x ^ (x << 25)) & MASK64\n    x =  x ^ (x >> 27) \n    @state = x\n    (((x * 0x2545F4914F6CDD1D) & MASK64) >> 32) & MASK32\n  end\n  \n  def next_float = next_int.fdiv((1 << 32))\n\nend\n\nrandom_gen =  Xorshift_star.new(1234567)\n5.times{ puts random_gen.next_int}\n\nrandom_gen = Xorshift_star.new(987654321)\ntally      = Hash.new(0)\n100_000.times{ tally[(random_gen.next_float*5).floor] += 1 }\nputs tally.sort.map{|ar| ar.join(\": \") }\n", "target": "mask64 = (1 << 64) - 1\nmask32 = (1 << 32) - 1\nconst = 0x2545F4914F6CDD1D\n\n\n\nclass Xorshift_star():\n    \n    def __init__(self, seed=0):\n        self.state = seed & mask64\n\n    def seed(self, num):\n        self.state =  num & mask64\n    \n    def next_int(self):\n        \"return random int between 0 and 2**32\"\n        x = self.state\n        x = (x ^ (x >> 12)) & mask64\n        x = (x ^ (x << 25)) & mask64\n        x = (x ^ (x >> 27)) & mask64\n        self.state = x\n        answer = (((x * const) & mask64) >> 32) & mask32 \n        return answer\n    \n    def  next_float(self):\n        \"return random float between 0 and 1\"\n        return self.next_int() / (1 << 32)\n    \n\nif __name__ == '__main__':\n    random_gen = Xorshift_star()\n    random_gen.seed(1234567)\n    for i in range(5):\n        print(random_gen.next_int())\n        \n    random_gen.seed(987654321)\n    hist = {i:0 for i in range(5)}\n    for i in range(100_000):\n        hist[int(random_gen.next_float() *5)] += 1\n    print(hist)\n"}
{"id": 336728, "name": "Numbers with equal rises and falls", "source": "Translate Ruby to Python: class Integer\n  def eq_rise_fall? = digits.each_cons(2).sum{|a,b| a <=> b} == 0\nend\n\nputs (1..).lazy.select(&:eq_rise_fall?).take(200).force.join(\" \")\n\nn = 10_000_000\nres = (1..).lazy.select(&:eq_rise_fall?).take(n).drop(n-1).first\nputs \"The \n", "target": "import itertools\n\ndef riseEqFall(num):\n    \n    height = 0\n    d1 = num % 10\n    num //= 10\n    while num:\n        d2 = num % 10\n        height += (d1<d2) - (d1>d2)\n        d1 = d2\n        num //= 10\n    return height == 0\n    \ndef sequence(start, fn):\n    \n    num=start-1\n    while True:\n        num += 1\n        while not fn(num): num += 1\n        yield num\n\na296712 = sequence(1, riseEqFall)\n\n\nprint(\"The first 200 numbers are:\")\nprint(*itertools.islice(a296712, 200))\n\n\nprint(\"The 10,000,000th number is:\")\nprint(*itertools.islice(a296712, 10000000-200-1, 10000000-200))\n\n\n"}
{"id": 336729, "name": "Pseudo-random numbers_Combined recursive generator MRG32k3a", "source": "Translate Ruby to Python: def mod(x, y)\n    m = x % y\n    if m < 0 then\n        if y < 0 then\n            return m - y\n        else\n            return m + y\n        end\n    end\n    return m\nend\n\n\n\nA1 = [0, 1403580, -810728]\nA1.freeze\nM1 = (1 << 32) - 209\n\nA2 = [527612, 0, -1370589]\nA2.freeze\nM2 = (1 << 32) - 22853\n\nD = M1 + 1\n\n\n$x1 = [0, 0, 0]\n\n$x2 = [0, 0, 0]\n\ndef seed(seed_state)\n    $x1 = [seed_state, 0, 0]\n    $x2 = [seed_state, 0, 0]\nend\n\ndef next_int()\n    x1i = mod((A1[0] * $x1[0] + A1[1] * $x1[1] + A1[2] * $x1[2]), M1)\n    x2i = mod((A2[0] * $x2[0] + A2[1] * $x2[1] + A2[2] * $x2[2]), M2)\n    z = mod(x1i - x2i, M1)\n\n    $x1 = [x1i, $x1[0], $x1[1]]\n    $x2 = [x2i, $x2[0], $x2[1]]\n\n    return z + 1\nend\n\ndef next_float()\n    return 1.0 * next_int() / D\nend\n\n\n\nseed(1234567)\nprint next_int(), \"\\n\"\nprint next_int(), \"\\n\"\nprint next_int(), \"\\n\"\nprint next_int(), \"\\n\"\nprint next_int(), \"\\n\"\nprint \"\\n\"\n\ncounts = [0, 0, 0, 0, 0]\nseed(987654321)\nfor i in 1 .. 100000\n    value = (next_float() * 5.0).floor\n    counts[value] = counts[value] + 1\nend\ncounts.each_with_index { |v,i|\n    print i, \": \", v, \"\\n\"\n}\n", "target": "\na1 = [0, 1403580, -810728]\nm1 = 2**32 - 209\n\na2 = [527612, 0, -1370589]\nm2 = 2**32 - 22853\n\nd = m1 + 1\n\nclass MRG32k3a():\n    \n    def __init__(self, seed_state=123):\n        self.seed(seed_state)\n    \n    def seed(self, seed_state):\n        assert 0 <seed_state < d, f\"Out of Range 0 x < {d}\"\n        self.x1 = [seed_state, 0, 0]\n        self.x2 = [seed_state, 0, 0]\n        \n    def next_int(self):\n        \"return random int in range 0..d\"\n        x1i = sum(aa * xx  for aa, xx in zip(a1, self.x1)) % m1\n        x2i = sum(aa * xx  for aa, xx in zip(a2, self.x2)) % m2\n        self.x1 = [x1i] + self.x1[:2]\n        self.x2 = [x2i] + self.x2[:2]\n\n        z = (x1i - x2i) % m1\n        answer = (z + 1)\n        \n        return answer\n    \n    def  next_float(self):\n        \"return random float between 0 and 1\"\n        return self.next_int() / d\n    \n\nif __name__ == '__main__':\n    random_gen = MRG32k3a()\n    random_gen.seed(1234567)\n    for i in range(5):\n        print(random_gen.next_int())\n        \n    random_gen.seed(987654321)\n    hist = {i:0 for i in range(5)}\n    for i in range(100_000):\n        hist[int(random_gen.next_float() *5)] += 1\n    print(hist)\n"}
{"id": 336730, "name": "Self-describing numbers", "source": "Translate Ruby to Python: def self_describing?(n)\n  digits = n.to_s.chars.map(&.to_i)         \n  digits.each_with_index.all? { |digit, idx| digits.count(idx) == digit }\nend\n\nt = Time.monotonic\n600_000_000.times { |n| (puts \"\n                        t = Time.monotonic) if self_describing?(n) }\n", "target": ">>> def isSelfDescribing(n):\n\ts = str(n)\n\treturn all(s.count(str(i)) == int(ch) for i, ch in enumerate(s))\n\n>>> [x for x in range(4000000) if isSelfDescribing(x)]\n[1210, 2020, 21200, 3211000]\n>>> [(x, isSelfDescribing(x)) for x in (1210, 2020, 21200, 3211000, 42101000, 521001000, 6210001000)]\n[(1210, True), (2020, True), (21200, True), (3211000, True), (42101000, True), (521001000, True), (6210001000, True)]\n"}
{"id": 336731, "name": "Changeable words", "source": "Translate Ruby to Python: words = File.open(\"unixdict.txt\").readlines.map(&:chomp).select{|w| w.size > 11 }\n\nsize_groups = words.group_by(&:size).sort.map(&:last)\nres =  size_groups.flat_map do |group|\n  group.combination(2).select{|word1, word2| word1.chars.zip(word2.chars).one?{|c1, c2| c1 != c2} }\nend\n\nputs \"Found \nres.each{|w1, w2|puts \"\n", "target": "from collections import defaultdict, Counter\n\n\ndef getwords(minlength=11, fname='unixdict.txt'):\n    \"Return set of lowercased words of > given number of characters\"\n    with open(fname) as f:\n        words = f.read().strip().lower().split()\n    return {w for w in words if len(w) > minlength}\n\nwords11 = getwords()\nword_minus_1 = defaultdict(list)    \nminus_1_to_word = defaultdict(list) \n\nfor w in words11:\n    for i in range(len(w)):\n        minus_1 = w[:i] + w[i+1:]\n        word_minus_1[minus_1].append((w, i))   \n        if minus_1 in words11:\n            minus_1_to_word[minus_1].append(w)\n    \ncwords = set()  \nfor _, v in word_minus_1.items():\n    if len(v) >1:\n        change_indices = Counter(i for wrd, i in v)\n        change_words = set(wrd for wrd, i in v)\n        words_changed = None\n        if len(change_words) > 1 and change_indices.most_common(1)[0][1] > 1:\n            words_changed = [wrd for wrd, i in v\n                             if change_indices[i] > 1]\n        if words_changed:\n            cwords.add(tuple(sorted(words_changed)))\n\nprint(f\"{len(minus_1_to_word)} words that are from deleting a char from other words:\")\nfor k, v in sorted(minus_1_to_word.items()):\n    print(f\"  {k:12} From {', '.join(v)}\")\n\nprint(f\"\\n{len(cwords)} words that are from changing a char from other words:\")\nfor v in sorted(cwords):\n    print(f\"  {v[0]:12} From {', '.join(v[1:])}\")\n"}
{"id": 336732, "name": "Exactly three adjacent 3 in lists", "source": "Translate Ruby to Python: tests = [[9,3,3,3,2,1,7,8,5],\n         [5,2,9,3,3,7,8,4,1],\n         [1,4,3,6,7,3,8,3,2],\n         [1,2,3,4,5,6,7,8,9],\n         [4,6,8,7,2,3,3,3,1],\n         [3,3,3,1,2,4,5,1,3],\n         [0,3,3,3,3,7,2,2,6],\n         [3,3,3,3,3,4,4,4,4]]\n\n(1..4).each do |n|\n  c = [n]*n\n  puts \"Contains exactly \n  tests.each { |t| puts \"\nend\n", "target": "\n\nfrom itertools import dropwhile, takewhile\n\n\n\ndef nnPeers(n):\n    \n    def p(x):\n        return n == x\n\n    def go(xs):\n        fromFirstMatch = list(dropwhile(\n            lambda v: not p(v),\n            xs\n        ))\n        ns = list(takewhile(p, fromFirstMatch))\n        rest = fromFirstMatch[len(ns):]\n\n        return p(len(ns)) and (\n            not any(p(x) for x in rest)\n        )\n\n    return go\n\n\n\n\ndef main():\n    \n    print(\n        '\\n'.join([\n            f'{xs} -> {nnPeers(3)(xs)}' for xs in [\n                [9, 3, 3, 3, 2, 1, 7, 8, 5],\n                [5, 2, 9, 3, 3, 7, 8, 4, 1],\n                [1, 4, 3, 6, 7, 3, 8, 3, 2],\n                [1, 2, 3, 4, 5, 6, 7, 8, 9],\n                [4, 6, 8, 7, 2, 3, 3, 3, 1]\n            ]\n        ])\n    )\n\n\n\nif __name__ == '__main__':\n    main()\n"}
{"id": 336733, "name": "Decision tables", "source": "Translate Ruby to Python: class DecisionTable\n  def initialize(conditions, actions)\n    @conditions = conditions\n    @actions = []\n    @rules = []\n    actions.each {|action, ruleset| @actions << action; @rules << ruleset} \n  end\n\n  def run\n    puts \"Conditions:\"\n    index = ask_conditions\n    puts \"Actions:\"\n    results = @rules.each_with_index.inject([]) do |sum, (ruleset, idx)| \n      sum << @actions[idx] if ruleset[index] == 1\n      sum\n    end\n    results << \"PC LOAD LETTER\" if results.empty?\n    results.each {|res| puts \"  \n    puts \"\"\n  end\n  \n  private\n  def ask_conditions\n    answers = @conditions.inject(\"\") {|sum, c| sum + get_response(c)}\n    answers.to_i(2)\n  end\n\n  def get_response(prompt)\n    loop do\n      print \"  \n      case STDIN.gets.strip.downcase\n      when /^y/ then return \"0\"\n      when /^n/ then return \"1\"\n      end\n    end\n  end\nend\n\ndt = DecisionTable.new(\n      [\n        \"Printer does not print\",              \n        \"A red light is flashing\",             \n        \"Printer is unrecognised\",             \n      ], \n      [\n        [\"Check the power cable\",                [0,0,1,0,0,0,0,0]],\n        [\"Check the printer-computer cable\",     [1,0,1,0,0,0,0,0]],\n        [\"Ensure printer software is installed\", [1,0,1,0,1,0,1,0]],\n        [\"Check/replace ink\",                    [1,1,0,0,1,1,0,0]],\n        [\"Check for paper jam\",                  [0,1,0,1,0,0,0,0]],\n      ]\n     )\nloop {dt.run}\n", "target": "\n\ndef dt_creator():\n    print(\"\\n\\nCREATING THE DECISION TABLE\\n\")\n    conditions = input(\"Input conditions, in order, separated by commas: \")\n    conditions = [c.strip() for c in conditions.split(',')]\n    print( (\"\\nThat was %s conditions:\\n  \" % len(conditions))\n           + '\\n  '.join(\"%i: %s\" % x for x in enumerate(conditions, 1)) )\n    print(\"\\nInput an action, a semicolon, then a list of tuples of rules that trigger it. End with a blank line\")\n    action2rules, action = [], ' '\n    while action:\n        action = input(\"%i: \" % (len(action2rules) + 1)).strip()\n        if action:\n            name, _, rules = [x.strip() for x in action.partition(';')]\n            rules = eval(rules)\n            assert all(len(rule) == len(conditions) for rule in rules), \\\n                   \"The number of conditions in a rule to trigger this action is wrong\" \n            action2rules.append((name, rules))\n    actions = [x[0] for x in action2rules]\n    \n    rule2actions = dict((y,[]) for y in set(sum((x[1] for x in action2rules), [])))\n    for action, rules in action2rules:\n        for r in rules:\n            rule2actions[r].append( action )\n    return conditions, rule2actions\n\ndef dt_user(dt, default=['Pray!']):\n    conditions, rule2actions = dt\n    print(\"\\n\\nUSING THE DECISION TABLE\\n\")\n    rule = tuple(int('y' == input(\"%s? (Answer y if statement is true or n): \" % c)) for c in conditions)\n    print(\"Try this:\\n  \" + '\\n  '.join(rule2actions.get(rule, default)))\n\nif __name__ == '__main__':\n    dt = dt_creator()\n    dt_user(dt)\n    dt_user(dt)\n    dt_user(dt)\n"}
{"id": 336734, "name": "Find words which contains more than 3 e vowels", "source": "Translate Ruby to Python: File.new(\"unixdict.txt\").each do |word| \n  puts word if word.count(\"e\") > 3 && word.count(\"aiou\") == 0\nend\n", "target": "with open('unixdict.txt', 'rt') as f:\n    for line in f.readlines():\n        if not any(c in 'aiou' for c in line) and sum(c=='e' for c in line)>3:\n            print(line.strip())\n"}
{"id": 336735, "name": "Find words with alternating vowels and consonants", "source": "Translate Ruby to Python: VOWELS =%w(a e i o u).map(&:freeze)\n\nres = File.open(\"unixdict.txt\").each_line.select do |line|\n  word = line.chomp\n  word.size > 9 && word.chars.each_cons(2).all?{|c1, c2| VOWELS.include?(c1) != VOWELS.include?(c2) }\nend\nputs res\n", "target": "\n\n\n\ndef isLongAlternator(s):\n    \n    def p(a, b):\n        return isVowel(a) != isVowel(b)\n    return 9 < len(s) and all(map(p, s, s[1:]))\n\n\ndef isVowel(c):\n    \n    return c in 'aeiou'\n\n\n\n\ndef main():\n    \n    matches = [\n        x for x in readFile('unixdict.txt').splitlines()\n        if isLongAlternator(x)\n    ]\n    w = max(len(x) for x in matches)\n    print(str(len(matches)) + ' matching words:\\n')\n    print(\n        '\\n'.join(\n            ' '.join(s) for s in chunksOf(4)([\n                x.ljust(w, ' ') for x in matches\n            ])\n        )\n    )\n\n\n\n\n\ndef chunksOf(n):\n    \n    def go(xs):\n        return (\n            xs[i:n + i] for i in range(0, len(xs), n)\n        ) if 0 < n else None\n    return go\n\n\n\ndef readFile(fp):\n    \n    with open(fp, 'r', encoding='utf-8') as f:\n        return f.read()\n\n\n\nif __name__ == '__main__':\n    main()\n"}
{"id": 336736, "name": "Input_Output for lines of text", "source": "Translate Ruby to Python: def do_stuff(line)\n  puts line\nend\n\nn = gets.to_i\nn.times do\n  line = gets\n  do_stuff(line)\nend\n", "target": "try: input = raw_input\nexcept: pass\n\ndef do_stuff(words):\n\tprint(words)\n\nlinecount = int(input())\nfor x in range(linecount):\n\tline = input()\n\tdo_stuff(line)\n"}
{"id": 336737, "name": "Largest five adjacent number", "source": "Translate Ruby to Python: digits = %w(0 1 2 3 4 5 6 7 8 9)\narr = Array.new(1000){ digits.sample }\nputs \"minimum sequence %s, maximum sequence %s.\" % arr.each_cons(5).minmax_by{|slice| slice.join.to_i}.map(&:join)\n", "target": "\n\nfrom random import seed,randint\nfrom datetime import datetime\n\nseed(str(datetime.now()))\n\nlargeNum = [randint(1,9)]\n\nfor i in range(1,1000):\n    largeNum.append(randint(0,9))\n\nmaxNum,minNum = 0,99999\n\nfor i in range(0,994):\n    num = int(\"\".join(map(str,largeNum[i:i+5])))\n    if num > maxNum:\n        maxNum = num\n    elif num < minNum:\n        minNum = num\n\nprint(\"Largest 5-adjacent number found \", maxNum)\nprint(\"Smallest 5-adjacent number found \", minNum)\n"}
{"id": 336738, "name": "Length of an arc between two angles", "source": "Translate Ruby to Python: def arc_length(radius, angle1, angle2)\n    return (360.0 - (angle2 - angle1).abs) * Math::PI / 180.0 * radius\nend\n\nprint \"%.7f\\n\" % [arc_length(10, 10, 120)]\n", "target": "import math\n\ndef arc_length(r, angleA, angleB):\n    return (360.0 - abs(angleB - angleA)) * math.pi * r / 180.0\n"}
{"id": 336739, "name": "Last list item", "source": "Translate Ruby to Python: p original = [6, 81, 243, 14, 25, 49, 123, 69, 11]\nuntil original.size == 1 do\n  mins = original.min(2)\n  mins.each{|el| original.delete_at(original.index(el)) }\n  p original << mins.sum\nend\n", "target": "\n\ndef add_least_reduce(lis):\n    \n    while len(lis) > 1:\n        lis.append(lis.pop(lis.index(min(lis))) + lis.pop(lis.index(min(lis))))\n        print('Interim list:', lis)\n    return lis\n\nLIST = [6, 81, 243, 14, 25, 49, 123, 69, 11]\n\nprint(LIST, ' ==> ', add_least_reduce(LIST.copy()))\n"}
{"id": 336740, "name": "Shift list elements to left by 3", "source": "Translate Ruby to Python: list = [1,2,3,4,5,6,7,8,9]\np list.rotate(3)\n", "target": "def rotate(list, n):\n    for _ in range(n):\n        list.append(list.pop(0))\n\n    return list\n\n\n\ndef rotate(list, n):\n    k = (len(list) + n) % len(list)\n    return list[k::] + list[:k:]\n\n\nlist = [1,2,3,4,5,6,7,8,9]\nprint(list, \" => \", rotate(list, 3))\n"}
{"id": 336741, "name": "Numbers with same digit set in base 10 and base 16", "source": "Translate Ruby to Python: p (1..100_000).select{|n| n.digits.to_set == n.digits(16).to_set}\n", "target": "col = 0\nfor i in range(100000):\n    if set(str(i)) == set(hex(i)[2:]):\n        col += 1\n        print(\"{:7}\".format(i), end='\\n'[:col % 10 == 0])\nprint()\n"}
{"id": 336742, "name": "Matrix with two diagonals", "source": "Translate Ruby to Python: require 'matrix'\n\nclass Matrix\n  def self.two_diagonals(n)\n    Matrix.build(n, n) do |row, col|\n      row == col || row == n-col-1 ? 1 : 0\n    end\n  end\nend\n\nMatrix.two_diagonals(5).row_vectors.each{|row| puts row.to_a.join(\" \") }\n", "target": "\n\n\n\ndef twoDiagonalMatrix(n):\n    \n    return matrix(\n        n, n, lambda row, col: int(\n            row in (col, 1 + (n - col))\n        )\n    )\n\n\n\n\ndef main():\n    \n    for n in [7, 8]:\n        print(\n            showMatrix(\n                twoDiagonalMatrix(n)\n            ) + '\\n'\n        )\n\n\n\n\n\ndef matrix(nRows, nCols, f):\n    \n    return [\n        [f(y, x) for x in range(1, 1 + nCols)]\n        for y in range(1, 1 + nRows)\n    ]\n\n\n\ndef showMatrix(rows):\n    \n    return '\\n'.join([\n        ' '.join([str(x) for x in y]) for y in rows\n    ])\n\n\n\nif __name__ == '__main__':\n    main()\n"}
{"id": 336743, "name": "Words containing _the_ substring", "source": "Translate Ruby to Python: File.foreach(\"unixdict.txt\"){|w| puts w if w.size > 11 && w.match?(\"the\") }\n", "target": "import urllib.request as request\n\nwith request.urlopen(\"http://wiki.puzzlers.org/pub/wordlists/unixdict.txt\") as f:\n    a = f.read().decode(\"ASCII\").split()\n\nfor s in a:\n    if len(s) > 11 and \"the\" in s:\n        print(s)\n"}
{"id": 336744, "name": "Four sides of square", "source": "Translate Ruby to Python: def square_sides(size = 9)\n  Array.new(size){|n| n==0 || n==size-1 ? [1]*size : [1]+[0]*(size-2)+[1]}\nend\n\nputs square_sides.map{|line| line.join (\" \") }\n", "target": "size = 9\nfor row in range(size):\n    for col in range(size):\n        if row == 0 or row == size-1 or col == 0 or col == size-1:\n            print(\"1\", end=\" \")\n        else:\n            print(\"0\", end=\" \")\n    print()\n"}
{"id": 336745, "name": "Longest common suffix", "source": "Translate Ruby to Python: tests = [[\"baabababc\", \"baabc\", \"bbbabc\"],\n [\"baabababc\", \"baabc\", \"bbbazc\"],\n [\"Sunday\", \"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\"],\n [\"longest\", \"common\", \"suffix\"],\n [\"suffix\"],\n [\"\"], \n]\ndef lcs(ar)\n  i = (0..ar.first.size).detect{|s| ar.all?{|word| word.end_with? ar.first[s..-1]} }\n  ar.first[i..-1]\nend\n\ntests.each{|test| p lcs(test) }\n", "target": "\n\nfrom itertools import takewhile\nfrom functools import reduce\n\n\n\ndef longestCommonSuffix(xs):\n    \n    def allSame(cs):\n        h = cs[0]\n        return all(h == c for c in cs[1:])\n\n    def firstCharPrepended(s, cs):\n        return cs[0] + s\n    return reduce(\n        firstCharPrepended,\n        takewhile(\n            allSame,\n            zip(*(reversed(x) for x in xs))\n        ),\n        ''\n    )\n\n\n\n\ndef main():\n    \n\n    samples = [\n        [\n            \"Sunday\", \"Monday\", \"Tuesday\", \"Wednesday\",\n            \"Thursday\", \"Friday\", \"Saturday\"\n        ], [\n            \"Sondag\", \"Maandag\", \"Dinsdag\", \"Woensdag\",\n            \"Donderdag\", \"Vrydag\", \"Saterdag\"\n        ]\n    ]\n    for xs in samples:\n        print(\n            longestCommonSuffix(xs)\n        )\n\n\n\nif __name__ == '__main__':\n    main()\n"}
{"id": 336746, "name": "Distinct power numbers", "source": "Translate Ruby to Python: a = (2..5).to_a\np a.product(a).map{_1 ** _2}.sort.uniq\n", "target": "from itertools import product\nprint(sorted(set(a**b for (a,b) in product(range(2,6), range(2,6)))))\n"}
{"id": 336747, "name": "Unique characters", "source": "Translate Ruby to Python: words = [\"133252abcdeeffd\", \"a6789798st\", \"yxcdfgxcyz\"]\n\ncounter = words.inject({}){|h, word| word.chars.tally(h)}\nputs counter.filter_map{|char, count| char if count == 1}.sort.join\n", "target": "\n\nfrom itertools import chain, groupby\n\n\n\ndef uniques(xs):\n    \n    return [\n        h for h, (_, *tail) in\n        groupby(sorted(chain(*xs)))\n        if not tail\n    ]\n\n\n\n\ndef main():\n    \n    print(\n        uniques([\n            \"133252abcdeeffd\",\n            \"a6789798st\",\n            \"yxcdfgxcyz\"\n        ])\n    )\n\n\n\nif __name__ == '__main__':\n    main()\n"}
{"id": 336748, "name": "Day of the week of Christmas and New Year", "source": "Translate Ruby to Python: require 'date'\n\nyears = [1578, 1590, 1642, 1957, 2020, 2021, 2022, 2242, 2245, 2393]\nyears.each do |year|\n  xmas = Date.new(year,12,25).strftime(\"%A\")\n  ny =   Date.new(year, 1, 1).strftime(\"%A\")\n  puts \"In \nend\n", "target": "import datetime\n\nweekDays = (\"Monday\",\"Tuesday\",\"Wednesday\",\"Thursday\",\"Friday\",\"Saturday\",\"Sunday\")\nthisXMas  = datetime.date(2021,12,25)\nthisXMasDay = thisXMas.weekday()\nthisXMasDayAsString = weekDays[thisXMasDay]\nprint(\"This year's Christmas is on a {}\".format(thisXMasDayAsString))\n\nnextNewYear = datetime.date(2022,1,1)\nnextNewYearDay = nextNewYear.weekday()\nnextNewYearDayAsString = weekDays[nextNewYearDay]\nprint(\"Next new year is on a {}\".format(nextNewYearDayAsString))\n"}
{"id": 336749, "name": "Continued fraction_Arithmetic_G(matrix ng, continued fraction n)", "source": "Translate Ruby to Python: \nclass NG\n  def initialize(a1, a, b1, b)\n    @a1, @a, @b1, @b = a1, a, b1, b\n  end\n  def ingress(n)\n    @a, @a1 = @a1, @a + @a1 * n\n    @b, @b1 = @b1, @b + @b1 * n\n  end\n  def needterm?\n    return true if @b == 0 or @b1 == 0\n    return true unless @a/@b == @a1/@b1\n    false\n  end\n  def egress\n    n = @a / @b\n    @a,  @b  = @b,  @a  - @b  * n\n    @a1, @b1 = @b1, @a1 - @b1 * n\n    n\n  end\n  def egress_done\n    @a, @b = @a1, @b1 if needterm?\n    egress\n  end\n  def done?\n    @b == 0 and @b1 == 0\n  end\nend\n", "target": "class NG:\n  def __init__(self, a1, a, b1, b):\n    self.a1, self.a, self.b1, self.b = a1, a, b1, b\n\n  def ingress(self, n):\n    self.a, self.a1 = self.a1, self.a + self.a1 * n\n    self.b, self.b1 = self.b1, self.b + self.b1 * n\n\n  @property\n  def needterm(self):\n    return (self.b == 0 or self.b1 == 0) or not self.a//self.b == self.a1//self.b1\n\n  @property\n  def egress(self):\n    n = self.a // self.b\n    self.a,  self.b  = self.b,  self.a  - self.b  * n\n    self.a1, self.b1 = self.b1, self.a1 - self.b1 * n\n    return n\n\n  @property\n  def egress_done(self):\n    if self.needterm: self.a, self.b = self.a1, self.b1\n    return self.egress\n\n  @property\n  def done(self):\n    return self.b == 0 and self.b1 == 0\n"}
{"id": 336750, "name": "Continued fraction_Arithmetic_G(matrix ng, continued fraction n)", "source": "Translate Ruby to Python: \nclass NG\n  def initialize(a1, a, b1, b)\n    @a1, @a, @b1, @b = a1, a, b1, b\n  end\n  def ingress(n)\n    @a, @a1 = @a1, @a + @a1 * n\n    @b, @b1 = @b1, @b + @b1 * n\n  end\n  def needterm?\n    return true if @b == 0 or @b1 == 0\n    return true unless @a/@b == @a1/@b1\n    false\n  end\n  def egress\n    n = @a / @b\n    @a,  @b  = @b,  @a  - @b  * n\n    @a1, @b1 = @b1, @a1 - @b1 * n\n    n\n  end\n  def egress_done\n    @a, @b = @a1, @b1 if needterm?\n    egress\n  end\n  def done?\n    @b == 0 and @b1 == 0\n  end\nend\n", "target": "class NG:\n  def __init__(self, a1, a, b1, b):\n    self.a1, self.a, self.b1, self.b = a1, a, b1, b\n\n  def ingress(self, n):\n    self.a, self.a1 = self.a1, self.a + self.a1 * n\n    self.b, self.b1 = self.b1, self.b + self.b1 * n\n\n  @property\n  def needterm(self):\n    return (self.b == 0 or self.b1 == 0) or not self.a//self.b == self.a1//self.b1\n\n  @property\n  def egress(self):\n    n = self.a // self.b\n    self.a,  self.b  = self.b,  self.a  - self.b  * n\n    self.a1, self.b1 = self.b1, self.a1 - self.b1 * n\n    return n\n\n  @property\n  def egress_done(self):\n    if self.needterm: self.a, self.b = self.a1, self.b1\n    return self.egress\n\n  @property\n  def done(self):\n    return self.b == 0 and self.b1 == 0\n"}
{"id": 336751, "name": "Here document", "source": "Translate Ruby to Python: puts <<-DOC\nthis is a heredoc\n  it preserves indents and newlines\n  the DOC identifier is completely arbitrary\n  it can be lowercase, a keyword, or even a number (but not a float)\nDOC\n", "target": "print()\n"}
{"id": 336752, "name": "Here document", "source": "Translate Ruby to Python: puts <<-DOC\nthis is a heredoc\n  it preserves indents and newlines\n  the DOC identifier is completely arbitrary\n  it can be lowercase, a keyword, or even a number (but not a float)\nDOC\n", "target": "print()\n"}
{"id": 336753, "name": "Abelian sandpile model_Identity", "source": "Translate Ruby to Python: class Sandpile\n  \n  def initialize(ar) = @grid = ar\n \n  def to_a = @grid.dup\n    \n  def + (other)\n    res = self.to_a.zip(other.to_a).map{|row1, row2| row1.zip(row2).map(&:sum) }\n    Sandpile.new(res)\n  end\n  \n  def stable? = @grid.flatten.none?{|v| v > 3}\n  \n  def avalanche \n    topple until stable?\n    self\n  end\n  \n  def == (other) = self.avalanche.to_a == other.avalanche.to_a\n   \n  def topple\n    a = @grid\n    a.each_index do |row|\n       a[row].each_index do |col|\n        next if a[row][col] < 4 \n        a[row+1][col] += 1 unless row == a.size-1\n        a[row-1][col] += 1 if row > 0\n        a[row][col+1] += 1 unless col == a.size-1\n        a[row][col-1] += 1 if col > 0\n        a[row][col]   -= 4\n      end\n    end\n    self\n  end\n    \n  def to_s = \"\\n\" + @grid.map {|row| row.join(\" \") }.join(\"\\n\") \n      \nend\n    \nputs \"Sandpile:\"\nputs demo = Sandpile.new( [[4,3,3], [3,1,2],[0,2,3]] )\nputs \"\\nAfter the avalanche:\"\nputs demo.avalanche\nputs \"_\" * 30,\"\"\n  \ns1 = Sandpile.new([[1, 2, 0], [2, 1, 1], [0, 1, 3]] )\nputs \"s1: \ns2 = Sandpile.new([[2, 1, 3], [1, 0, 1], [0, 1, 0]] )\nputs \"\\ns2: \nputs \"\\ns1 + s2 == s2 + s1: \nputs \"_\" * 30,\"\"\n  \ns3    = Sandpile.new([[3, 3, 3], [3, 3, 3], [3, 3, 3]] )\ns3_id = Sandpile.new([[2, 1, 2], [1, 0, 1], [2, 1, 2]] )\nputs \"s3 + s3_id == s3: \nputs \"s3_id + s3_id == s3_id: \n", "target": "from itertools import product\nfrom collections import defaultdict\n\n\nclass Sandpile():\n    def __init__(self, gridtext):\n        array = [int(x) for x in gridtext.strip().split()]\n        self.grid = defaultdict(int,\n                                {(i //3, i % 3): x \n                                 for i, x in enumerate(array)})\n\n    _border = set((r, c) \n                  for r, c in product(range(-1, 4), repeat=2) \n                  if not 0 <= r <= 2 or not 0 <= c <= 2\n                  )\n    _cell_coords = list(product(range(3), repeat=2))\n    \n    def topple(self):\n        g = self.grid\n        for r, c in self._cell_coords:\n            if g[(r, c)] >= 4:\n                g[(r - 1, c)] += 1\n                g[(r + 1, c)] += 1\n                g[(r, c - 1)] += 1\n                g[(r, c + 1)] += 1\n                g[(r, c)] -= 4\n                return True\n        return False\n    \n    def stabilise(self):\n        while self.topple():\n            pass\n        \n        g = self.grid\n        for row_col in self._border.intersection(g.keys()):\n            del g[row_col]\n        return self\n    \n    __pos__ = stabilise     \n    \n    def __eq__(self, other):\n        g = self.grid\n        return all(g[row_col] == other.grid[row_col]\n                   for row_col in self._cell_coords)\n\n    def __add__(self, other):\n        g = self.grid\n        ans = Sandpile(\"\")\n        for row_col in self._cell_coords:\n            ans.grid[row_col] = g[row_col] + other.grid[row_col]\n        return ans.stabilise()\n       \n    def __str__(self):\n        g, txt = self.grid, []\n        for row in range(3):\n            txt.append(' '.join(str(g[(row, col)]) \n                                for col in range(3)))\n        return '\\n'.join(txt)\n    \n    def __repr__(self):\n        return f'{self.__class__.__name__}()'\n        \n\nunstable = Sandpile()\ns1 = Sandpile()\ns2 = Sandpile()\ns3 = Sandpile(\"3 3 3  3 3 3  3 3 3\")\ns3_id = Sandpile(\"2 1 2  1 0 1  2 1 2\")\n"}
{"id": 336754, "name": "Abelian sandpile model_Identity", "source": "Translate Ruby to Python: class Sandpile\n  \n  def initialize(ar) = @grid = ar\n \n  def to_a = @grid.dup\n    \n  def + (other)\n    res = self.to_a.zip(other.to_a).map{|row1, row2| row1.zip(row2).map(&:sum) }\n    Sandpile.new(res)\n  end\n  \n  def stable? = @grid.flatten.none?{|v| v > 3}\n  \n  def avalanche \n    topple until stable?\n    self\n  end\n  \n  def == (other) = self.avalanche.to_a == other.avalanche.to_a\n   \n  def topple\n    a = @grid\n    a.each_index do |row|\n       a[row].each_index do |col|\n        next if a[row][col] < 4 \n        a[row+1][col] += 1 unless row == a.size-1\n        a[row-1][col] += 1 if row > 0\n        a[row][col+1] += 1 unless col == a.size-1\n        a[row][col-1] += 1 if col > 0\n        a[row][col]   -= 4\n      end\n    end\n    self\n  end\n    \n  def to_s = \"\\n\" + @grid.map {|row| row.join(\" \") }.join(\"\\n\") \n      \nend\n    \nputs \"Sandpile:\"\nputs demo = Sandpile.new( [[4,3,3], [3,1,2],[0,2,3]] )\nputs \"\\nAfter the avalanche:\"\nputs demo.avalanche\nputs \"_\" * 30,\"\"\n  \ns1 = Sandpile.new([[1, 2, 0], [2, 1, 1], [0, 1, 3]] )\nputs \"s1: \ns2 = Sandpile.new([[2, 1, 3], [1, 0, 1], [0, 1, 0]] )\nputs \"\\ns2: \nputs \"\\ns1 + s2 == s2 + s1: \nputs \"_\" * 30,\"\"\n  \ns3    = Sandpile.new([[3, 3, 3], [3, 3, 3], [3, 3, 3]] )\ns3_id = Sandpile.new([[2, 1, 2], [1, 0, 1], [2, 1, 2]] )\nputs \"s3 + s3_id == s3: \nputs \"s3_id + s3_id == s3_id: \n", "target": "from itertools import product\nfrom collections import defaultdict\n\n\nclass Sandpile():\n    def __init__(self, gridtext):\n        array = [int(x) for x in gridtext.strip().split()]\n        self.grid = defaultdict(int,\n                                {(i //3, i % 3): x \n                                 for i, x in enumerate(array)})\n\n    _border = set((r, c) \n                  for r, c in product(range(-1, 4), repeat=2) \n                  if not 0 <= r <= 2 or not 0 <= c <= 2\n                  )\n    _cell_coords = list(product(range(3), repeat=2))\n    \n    def topple(self):\n        g = self.grid\n        for r, c in self._cell_coords:\n            if g[(r, c)] >= 4:\n                g[(r - 1, c)] += 1\n                g[(r + 1, c)] += 1\n                g[(r, c - 1)] += 1\n                g[(r, c + 1)] += 1\n                g[(r, c)] -= 4\n                return True\n        return False\n    \n    def stabilise(self):\n        while self.topple():\n            pass\n        \n        g = self.grid\n        for row_col in self._border.intersection(g.keys()):\n            del g[row_col]\n        return self\n    \n    __pos__ = stabilise     \n    \n    def __eq__(self, other):\n        g = self.grid\n        return all(g[row_col] == other.grid[row_col]\n                   for row_col in self._cell_coords)\n\n    def __add__(self, other):\n        g = self.grid\n        ans = Sandpile(\"\")\n        for row_col in self._cell_coords:\n            ans.grid[row_col] = g[row_col] + other.grid[row_col]\n        return ans.stabilise()\n       \n    def __str__(self):\n        g, txt = self.grid, []\n        for row in range(3):\n            txt.append(' '.join(str(g[(row, col)]) \n                                for col in range(3)))\n        return '\\n'.join(txt)\n    \n    def __repr__(self):\n        return f'{self.__class__.__name__}()'\n        \n\nunstable = Sandpile()\ns1 = Sandpile()\ns2 = Sandpile()\ns3 = Sandpile(\"3 3 3  3 3 3  3 3 3\")\ns3_id = Sandpile(\"2 1 2  1 0 1  2 1 2\")\n"}
{"id": 336755, "name": "Base 16 numbers needing a to f", "source": "Translate Ruby to Python: puts (0..500).select{|n| n.digits(16).any?{|d| d >= 10} }.join(\" \")\n", "target": "\n\n\n\ndef p(n):\n    \n    return 9 < n and (9 < n % 16 or p(n // 16))\n\n\n\n\ndef main():\n    \n    xs = [\n        str(n) for n in range(1, 1 + 500)\n        if p(n)\n    ]\n    print(f'{len(xs)} matches for the predicate:\\n')\n    print(\n        table(6)(xs)\n    )\n\n\n\n\n\ndef chunksOf(n):\n    \n    def go(xs):\n        return (\n            xs[i:n + i] for i in range(0, len(xs), n)\n        ) if 0 < n else None\n    return go\n\n\n\ndef table(n):\n    \n    def go(xs):\n        w = len(xs[-1])\n        return '\\n'.join(\n            ' '.join(row) for row in chunksOf(n)([\n                s.rjust(w, ' ') for s in xs\n            ])\n        )\n    return go\n\n\n\nif __name__ == '__main__':\n    main()\n"}
{"id": 336756, "name": "Base 16 numbers needing a to f", "source": "Translate Ruby to Python: puts (0..500).select{|n| n.digits(16).any?{|d| d >= 10} }.join(\" \")\n", "target": "\n\n\n\ndef p(n):\n    \n    return 9 < n and (9 < n % 16 or p(n // 16))\n\n\n\n\ndef main():\n    \n    xs = [\n        str(n) for n in range(1, 1 + 500)\n        if p(n)\n    ]\n    print(f'{len(xs)} matches for the predicate:\\n')\n    print(\n        table(6)(xs)\n    )\n\n\n\n\n\ndef chunksOf(n):\n    \n    def go(xs):\n        return (\n            xs[i:n + i] for i in range(0, len(xs), n)\n        ) if 0 < n else None\n    return go\n\n\n\ndef table(n):\n    \n    def go(xs):\n        w = len(xs[-1])\n        return '\\n'.join(\n            ' '.join(row) for row in chunksOf(n)([\n                s.rjust(w, ' ') for s in xs\n            ])\n        )\n    return go\n\n\n\nif __name__ == '__main__':\n    main()\n"}
{"id": 336757, "name": "Address of a variable", "source": "Translate Ruby to Python: >foo = Object.new  \n>id = foo.object_id  \n>\"%x\" % (id << 1)  \n", "target": "var num = 12\nvar pointer = ptr(num) \n\nprint pointer \n\n@unsafe \npointer.addr = 0xFFFE \n"}
{"id": 336758, "name": "Juggler sequence", "source": "Translate Ruby to Python: def juggler(k) = k.even? ? Integer.sqrt(k) : Integer.sqrt(k*k*k)\n\n(20..39).chain([113, 173, 193, 2183, 11229, 15065, 15845, 30817, 48443, 275485, 1267909, 2264915]).each do |k|\n  k1 = k\n  l = h = i = 0\n  until k == 1 do\n    h, i = k, l if k > h\n    l += 1\n    k =  juggler(k)\n  end\n  if k1 < 40 then\n    puts \"\n  else\n    puts \"\n  end\nend\n", "target": "from math import isqrt\n\ndef juggler(k, countdig=True, maxiters=1000):\n    m, maxj, maxjpos = k, k, 0\n    for i in range(1, maxiters):\n        m = isqrt(m) if m % 2 == 0 else isqrt(m * m * m)\n        if m >= maxj:\n            maxj, maxjpos  = m, i\n        if m == 1:\n            print(f\"{k: 9}{i: 6,}{maxjpos: 6}{len(str(maxj)) if countdig else maxj: 20,}{' digits' if countdig else ''}\")\n            return i\n\n    print(\"ERROR: Juggler series starting with $k did not converge in $maxiters iterations\")\n\n\nprint(\"       n    l(n)  i(n)       h(n) or d(n)\\n-------------------------------------------\")\nfor k in range(20, 40):\n    juggler(k, False)\n\nfor k in [113, 173, 193, 2183, 11229, 15065, 15845, 30817, 48443, 275485, 1267909]:\n    juggler(k)\n"}
{"id": 336759, "name": "Juggler sequence", "source": "Translate Ruby to Python: def juggler(k) = k.even? ? Integer.sqrt(k) : Integer.sqrt(k*k*k)\n\n(20..39).chain([113, 173, 193, 2183, 11229, 15065, 15845, 30817, 48443, 275485, 1267909, 2264915]).each do |k|\n  k1 = k\n  l = h = i = 0\n  until k == 1 do\n    h, i = k, l if k > h\n    l += 1\n    k =  juggler(k)\n  end\n  if k1 < 40 then\n    puts \"\n  else\n    puts \"\n  end\nend\n", "target": "from math import isqrt\n\ndef juggler(k, countdig=True, maxiters=1000):\n    m, maxj, maxjpos = k, k, 0\n    for i in range(1, maxiters):\n        m = isqrt(m) if m % 2 == 0 else isqrt(m * m * m)\n        if m >= maxj:\n            maxj, maxjpos  = m, i\n        if m == 1:\n            print(f\"{k: 9}{i: 6,}{maxjpos: 6}{len(str(maxj)) if countdig else maxj: 20,}{' digits' if countdig else ''}\")\n            return i\n\n    print(\"ERROR: Juggler series starting with $k did not converge in $maxiters iterations\")\n\n\nprint(\"       n    l(n)  i(n)       h(n) or d(n)\\n-------------------------------------------\")\nfor k in range(20, 40):\n    juggler(k, False)\n\nfor k in [113, 173, 193, 2183, 11229, 15065, 15845, 30817, 48443, 275485, 1267909]:\n    juggler(k)\n"}
{"id": 336760, "name": "Pig the dice game_Player", "source": "Translate Ruby to Python: def player1(sum,sm)\nfor i in 1..100\nputs \"player1 rolled\"\na=gets.chomp().to_i\nif (a>1 && a<7)\n\tsum+=a\n\tif sum>=100\n\tputs \"player1 wins\"\n\tbreak\n\tend\nelse\n\ngoto player2(sum,sm)\nend\ni+=1\nend\nend\n\ndef player2(sum,sm)\nfor j in 1..100\nputs \"player2 rolled\"\nb=gets.chomp().to_i\nif(b>1 && b<7)\n sm+=b\n\tif sm>=100\n\t puts \"player2 wins\"\n\tbreak\n\tend\nelse\n\nplayer1(sum,sm)\nend\nj+=1\nend\nend\ni=0\nj=0\nsum=0\nsm=0\nplayer1(sum,sm)\nreturn\n", "target": "\n\n\n\nfrom random import randint\nfrom collections import namedtuple\nimport random\nfrom pprint import pprint as pp\nfrom collections import Counter\n\n\nplayercount = 2\nmaxscore = 100\nmaxgames = 100000\n\n\nGame = namedtuple('Game', 'players, maxscore, rounds')\nRound = namedtuple('Round', 'who, start, scores, safe')\n\n\nclass Player():\n    def __init__(self, player_index):\n        self.player_index = player_index\n\n    def __repr__(self):\n        return '%s(%i)' % (self.__class__.__name__, self.player_index)\n\n    def __call__(self, safescore, scores, game):\n        'Returns boolean True to roll again'\n        pass\n\nclass RandPlay(Player):\n    def __call__(self, safe, scores, game):\n        'Returns random boolean choice of whether to roll again'\n        return bool(random.randint(0, 1))\n\nclass RollTo20(Player):\n    def __call__(self, safe, scores, game):\n        'Roll again if this rounds score < 20'\n        return (((sum(scores) + safe[self.player_index]) < maxscore)    \n                and(sum(scores) < 20))                                  \n\nclass Desparat(Player):\n    def __call__(self, safe, scores, game):\n        'Roll again if this rounds score < 20 or someone is within 20 of winning'\n        return (((sum(scores) + safe[self.player_index]) < maxscore)    \n                and( (sum(scores) < 20)                                 \n                     or max(safe) >= (maxscore - 20)))                  \n\n\ndef game__str__(self):\n    'Pretty printer for Game class'\n    return (\"Game(players=%r, maxscore=%i,\\n  rounds=[\\n    %s\\n  ])\"\n            % (self.players, self.maxscore,\n               ',\\n    '.join(repr(round) for round in self.rounds)))\nGame.__str__ = game__str__\n\n\ndef winningorder(players, safescores):\n    'Return (players in winning order, their scores)'\n    return tuple(zip(*sorted(zip(players, safescores),\n                            key=lambda x: x[1], reverse=True)))\n\ndef playpig(game):\n    \n    players, maxscore, rounds = game\n    playercount = len(players)\n    safescore = [0] * playercount   \n    player = 0                      \n    scores=[]                       \n\n    while max(safescore) < maxscore:\n        startscore = safescore[player]\n        rolling = players[player](safescore, scores, game)\n        if rolling:\n            rolled = randint(1, 6)\n            scores.append(rolled)\n            if rolled == 1:\n                \n                round = Round(who=players[player],\n                              start=startscore,\n                              scores=scores,\n                              safe=safescore[player])\n                rounds.append(round)\n                scores, player = [], (player + 1) % playercount\n        else:\n            \n            safescore[player] += sum(scores)\n            round = Round(who=players[player],\n                          start=startscore,\n                          scores=scores,\n                          safe=safescore[player])\n            rounds.append(round)\n            if safescore[player] >= maxscore:\n                break\n            scores, player = [], (player + 1) % playercount\n\n    \n    return winningorder(players, safescore)\n\nif __name__ == '__main__':\n    game = Game(players=tuple(RandPlay(i) for i in range(playercount)),\n                maxscore=20,\n                rounds=[])\n    print('ONE GAME')\n    print('Winning order: %r; Respective scores: %r\\n' % playpig(game))\n    print(game)\n    game = Game(players=tuple(RandPlay(i) for i in range(playercount)),\n                maxscore=maxscore,\n                rounds=[])\n    algos = (RollTo20, RandPlay, Desparat)\n    print('\\n\\nMULTIPLE STATISTICS using %r\\n  for %i GAMES'\n          % (', '.join(p.__name__ for p in algos), maxgames,))\n    winners = Counter(repr(playpig(game._replace(players=tuple(random.choice(algos)(i)\n                                                               for i in range(playercount)),\n                                                 rounds=[]))[0])\n                      for i in range(maxgames))\n    print('  Players(position) winning on left; occurrences on right:\\n    %s'\n          % ',\\n    '.join(str(w) for w in winners.most_common()))\n"}
{"id": 336761, "name": "Pig the dice game_Player", "source": "Translate Ruby to Python: def player1(sum,sm)\nfor i in 1..100\nputs \"player1 rolled\"\na=gets.chomp().to_i\nif (a>1 && a<7)\n\tsum+=a\n\tif sum>=100\n\tputs \"player1 wins\"\n\tbreak\n\tend\nelse\n\ngoto player2(sum,sm)\nend\ni+=1\nend\nend\n\ndef player2(sum,sm)\nfor j in 1..100\nputs \"player2 rolled\"\nb=gets.chomp().to_i\nif(b>1 && b<7)\n sm+=b\n\tif sm>=100\n\t puts \"player2 wins\"\n\tbreak\n\tend\nelse\n\nplayer1(sum,sm)\nend\nj+=1\nend\nend\ni=0\nj=0\nsum=0\nsm=0\nplayer1(sum,sm)\nreturn\n", "target": "\n\n\n\nfrom random import randint\nfrom collections import namedtuple\nimport random\nfrom pprint import pprint as pp\nfrom collections import Counter\n\n\nplayercount = 2\nmaxscore = 100\nmaxgames = 100000\n\n\nGame = namedtuple('Game', 'players, maxscore, rounds')\nRound = namedtuple('Round', 'who, start, scores, safe')\n\n\nclass Player():\n    def __init__(self, player_index):\n        self.player_index = player_index\n\n    def __repr__(self):\n        return '%s(%i)' % (self.__class__.__name__, self.player_index)\n\n    def __call__(self, safescore, scores, game):\n        'Returns boolean True to roll again'\n        pass\n\nclass RandPlay(Player):\n    def __call__(self, safe, scores, game):\n        'Returns random boolean choice of whether to roll again'\n        return bool(random.randint(0, 1))\n\nclass RollTo20(Player):\n    def __call__(self, safe, scores, game):\n        'Roll again if this rounds score < 20'\n        return (((sum(scores) + safe[self.player_index]) < maxscore)    \n                and(sum(scores) < 20))                                  \n\nclass Desparat(Player):\n    def __call__(self, safe, scores, game):\n        'Roll again if this rounds score < 20 or someone is within 20 of winning'\n        return (((sum(scores) + safe[self.player_index]) < maxscore)    \n                and( (sum(scores) < 20)                                 \n                     or max(safe) >= (maxscore - 20)))                  \n\n\ndef game__str__(self):\n    'Pretty printer for Game class'\n    return (\"Game(players=%r, maxscore=%i,\\n  rounds=[\\n    %s\\n  ])\"\n            % (self.players, self.maxscore,\n               ',\\n    '.join(repr(round) for round in self.rounds)))\nGame.__str__ = game__str__\n\n\ndef winningorder(players, safescores):\n    'Return (players in winning order, their scores)'\n    return tuple(zip(*sorted(zip(players, safescores),\n                            key=lambda x: x[1], reverse=True)))\n\ndef playpig(game):\n    \n    players, maxscore, rounds = game\n    playercount = len(players)\n    safescore = [0] * playercount   \n    player = 0                      \n    scores=[]                       \n\n    while max(safescore) < maxscore:\n        startscore = safescore[player]\n        rolling = players[player](safescore, scores, game)\n        if rolling:\n            rolled = randint(1, 6)\n            scores.append(rolled)\n            if rolled == 1:\n                \n                round = Round(who=players[player],\n                              start=startscore,\n                              scores=scores,\n                              safe=safescore[player])\n                rounds.append(round)\n                scores, player = [], (player + 1) % playercount\n        else:\n            \n            safescore[player] += sum(scores)\n            round = Round(who=players[player],\n                          start=startscore,\n                          scores=scores,\n                          safe=safescore[player])\n            rounds.append(round)\n            if safescore[player] >= maxscore:\n                break\n            scores, player = [], (player + 1) % playercount\n\n    \n    return winningorder(players, safescore)\n\nif __name__ == '__main__':\n    game = Game(players=tuple(RandPlay(i) for i in range(playercount)),\n                maxscore=20,\n                rounds=[])\n    print('ONE GAME')\n    print('Winning order: %r; Respective scores: %r\\n' % playpig(game))\n    print(game)\n    game = Game(players=tuple(RandPlay(i) for i in range(playercount)),\n                maxscore=maxscore,\n                rounds=[])\n    algos = (RollTo20, RandPlay, Desparat)\n    print('\\n\\nMULTIPLE STATISTICS using %r\\n  for %i GAMES'\n          % (', '.join(p.__name__ for p in algos), maxgames,))\n    winners = Counter(repr(playpig(game._replace(players=tuple(random.choice(algos)(i)\n                                                               for i in range(playercount)),\n                                                 rounds=[]))[0])\n                      for i in range(maxgames))\n    print('  Players(position) winning on left; occurrences on right:\\n    %s'\n          % ',\\n    '.join(str(w) for w in winners.most_common()))\n"}
{"id": 336762, "name": "Fixed length records", "source": "Translate Ruby to Python: open(\"outfile.dat\", \"w\") do |out_f|\n  open(\"infile.dat\") do |in_f| \n     while record = in_f.read(80) \n       out_f << record.reverse\n     end\n  end\nend  \n", "target": "infile = open('infile.dat', 'rb')\noutfile = open('outfile.dat', 'wb')\n\nwhile True:\n    onerecord = infile.read(80)\n    if len(onerecord) < 80:\n        break\n    onerecordreversed = bytes(reversed(onerecord))\n    outfile.write(onerecordreversed)\n\ninfile.close()\noutfile.close()\n"}
{"id": 336763, "name": "Find words whose first and last three letters are equal", "source": "Translate Ruby to Python: puts File.readlines(\"unixdict.txt\", chomp: true).select{|w| w.end_with?(w[0,3]) && w.size > 5}\n", "target": "import urllib.request\nurllib.request.urlretrieve(\"http://wiki.puzzlers.org/pub/wordlists/unixdict.txt\", \"unixdict.txt\")\n\ndictionary = open(\"unixdict.txt\",\"r\")\n\nwordList = dictionary.read().split('\\n')\n\ndictionary.close()\n\nfor word in wordList:\n    if len(word)>5 and word[:3].lower()==word[-3:].lower():\n        print(word)\n"}
{"id": 336764, "name": "Find words which contain the most consonants", "source": "Translate Ruby to Python: filtered = File.open(\"unixdict.txt\").each( chomp: true).select do |word|\n  next unless word.size > 10 \n  cons = word.delete('aeiou')\n  cons.chars.uniq.join == cons\nend\n\ngrouped = filtered.group_by{|word| word.count('^aeiou')}\ngrouped.sort_by{|k,v| -k}.each do |chunk|\n  puts\"\\n\n  puts chunk.last.first(10)\n  puts \"...\" if chunk.last.size > 10\nend\n", "target": "print('\\n'.join((f'{x[0]}: {\" \".join(sorted(x[1]))}' if len(x[1]) < 30 else f'{x[0]}: {len(x[1])} words' for x in\n      (x for x in ((n, [x[1] for x in l if x[0] == n]) for n in range(maxlen, -1, -1)) if x[1]))) if (maxlen := max(l := [(len(c), w)\n      for w in [l for l in [l.rstrip() for l in open('unixdict.txt')] if len(l) > 10 and all(c >= 'a' and c <= 'z' for c in l)]\n      if sorted(c := w.replace('a', '').replace('e', '').replace('i', '').replace('o', '').replace('u', '')) == sorted(set(c))])[0]) else None)\n"}
{"id": 336765, "name": "Find words which contains all the vowels", "source": "Translate Ruby to Python: File.open(\"unixdict.txt\").each(chomp: true) do |word|\n  puts word if word.size > 10 && word.chars.tally.values_at('a','e','i','o','u').all?(1)\nend\n", "target": "import urllib.request\nfrom collections import Counter\n\nurllib.request.urlretrieve(\"http://wiki.puzzlers.org/pub/wordlists/unixdict.txt\", \"unixdict.txt\")\n\ndictionary = open(\"unixdict.txt\",\"r\")\n\nwordList = dictionary.read().split('\\n')\n\ndictionary.close()\n\nfor word in wordList:\n    if len(word)>10:\n        frequency = Counter(word.lower())\n        if frequency['a']==frequency['e']==frequency['i']==frequency['o']==frequency['u']==1:\n            print(word)\n"}
{"id": 336766, "name": "Common list elements", "source": "Translate Ruby to Python: nums = [2,5,1,3,8,9,4,6], [3,5,6,2,9,8,4], [1,3,7,6,9]\np nums.inject(&:intersection)  \n", "target": "\n\ndef common_list_elements(*lists):\n    return list(set.intersection(*(set(list_) for list_ in lists)))\n\n\nif __name__ == \"__main__\":\n    test_cases = [\n        ([2, 5, 1, 3, 8, 9, 4, 6], [3, 5, 6, 2, 9, 8, 4], [1, 3, 7, 6, 9]),\n        ([2, 2, 1, 3, 8, 9, 4, 6], [3, 5, 6, 2, 2, 2, 4], [2, 3, 7, 6, 2]),\n    ]\n\n    for case in test_cases:\n        result = common_list_elements(*case)\n        print(f\"Intersection of {case} is {result}\")\n"}
{"id": 336767, "name": "Common list elements", "source": "Translate Ruby to Python: nums = [2,5,1,3,8,9,4,6], [3,5,6,2,9,8,4], [1,3,7,6,9]\np nums.inject(&:intersection)  \n", "target": "\n\ndef common_list_elements(*lists):\n    return list(set.intersection(*(set(list_) for list_ in lists)))\n\n\nif __name__ == \"__main__\":\n    test_cases = [\n        ([2, 5, 1, 3, 8, 9, 4, 6], [3, 5, 6, 2, 9, 8, 4], [1, 3, 7, 6, 9]),\n        ([2, 2, 1, 3, 8, 9, 4, 6], [3, 5, 6, 2, 2, 2, 4], [2, 3, 7, 6, 2]),\n    ]\n\n    for case in test_cases:\n        result = common_list_elements(*case)\n        print(f\"Intersection of {case} is {result}\")\n"}
{"id": 336768, "name": "Maze solving", "source": "Translate Ruby to Python: class Maze\n  \n  \n  \n  def solve\n    \n    \n    reset_visiting_state\n    \n    \n    @queue = []\n    enqueue_cell([], @start_x, @start_y)\n    \n    \n    \n    path = nil\n    until path || @queue.empty?\n      path = solve_visit_cell\n    end\n    \n    if path\n      \n      for x, y in path\n        @path[x][y] = true\n      end\n    else\n      puts \"No solution found?!\"\n    end\n  end\n  \n  private\n  \n  \n  def solve_visit_cell\n    \n    path = @queue.shift\n    \n    x, y = path.last\n    \n    \n    return path  if x == @end_x && y == @end_y\n    \n    \n    @visited[x][y] = true\n    \n    for dx, dy in DIRECTIONS\n      if dx.nonzero?\n        \n        new_x = x + dx\n        if move_valid?(new_x, y) && !@vertical_walls[ [x, new_x].min ][y]\n          enqueue_cell(path, new_x, y)\n        end\n      else\n        \n        new_y = y + dy\n        if move_valid?(x, new_y) && !@horizontal_walls[x][ [y, new_y].min ]\n          enqueue_cell(path, x, new_y)\n        end\n      end\n    end\n    \n    nil         \n  end\n  \n  \n  def enqueue_cell(path, x, y)\n    \n    @queue << path + [[x, y]]\n  end\nend\n\n\nmaze = Maze.new 20, 10\nmaze.solve\nmaze.print\n", "target": "\n\ndef Dijkstra(Graph, source):\n    \n    \n    infinity = float('infinity')\n    n = len(graph)\n    dist = [infinity]*n   \n    previous = [infinity]*n \n    dist[source] = 0        \n    Q = list(range(n)) \n    while Q:           \n        u = min(Q, key=lambda n:dist[n])                 \n        Q.remove(u)\n        if dist[u] == infinity:\n            break \n        for v in range(n):               \n            if Graph[u][v] and (v in Q): \n                alt = dist[u] + Graph[u][v]\n                if alt < dist[v]:       \n                    dist[v] = alt\n                    previous[v] = u\n    return dist,previous\n\ndef display_solution(predecessor):\n    cell = len(predecessor)-1\n    while cell:\n        print(cell,end='<')\n        cell = predecessor[cell]\n    print(0)\n"}
{"id": 336769, "name": "Deming's funnel", "source": "Translate Ruby to Python: def funnel(dxs, &rule)\n  x, rxs = 0, []\n  for dx in dxs\n    rxs << (x + dx)\n    x = rule[x, dx]\n  end\n  rxs\nend\n\ndef mean(xs) xs.inject(:+) / xs.size end\n\ndef stddev(xs)\n  m = mean(xs)\n  Math.sqrt(xs.inject(0.0){|sum,x| sum + (x-m)**2} / xs.size)\nend\n\ndef experiment(label, dxs, dys, &rule)\n  rxs, rys = funnel(dxs, &rule), funnel(dys, &rule)\n  puts label\n  puts 'Mean x, y   \u00a0: %7.4f, %7.4f' % [mean(rxs), mean(rys)]\n  puts 'Std dev x, y\u00a0: %7.4f, %7.4f' % [stddev(rxs), stddev(rys)]\n  puts\nend\n\ndxs = [ -0.533,  0.270,  0.859, -0.043, -0.205, -0.127, -0.071,  0.275,\n         1.251, -0.231, -0.401,  0.269,  0.491,  0.951,  1.150,  0.001,\n        -0.382,  0.161,  0.915,  2.080, -2.337,  0.034, -0.126,  0.014,\n         0.709,  0.129, -1.093, -0.483, -1.193,  0.020, -0.051,  0.047,\n        -0.095,  0.695,  0.340, -0.182,  0.287,  0.213, -0.423, -0.021,\n        -0.134,  1.798,  0.021, -1.099, -0.361,  1.636, -1.134,  1.315,\n         0.201,  0.034,  0.097, -0.170,  0.054, -0.553, -0.024, -0.181,\n        -0.700, -0.361, -0.789,  0.279, -0.174, -0.009, -0.323, -0.658,\n         0.348, -0.528,  0.881,  0.021, -0.853,  0.157,  0.648,  1.774,\n        -1.043,  0.051,  0.021,  0.247, -0.310,  0.171,  0.000,  0.106,\n         0.024, -0.386,  0.962,  0.765, -0.125, -0.289,  0.521,  0.017,\n         0.281, -0.749, -0.149, -2.436, -0.909,  0.394, -0.113, -0.598,\n         0.443, -0.521, -0.799,  0.087]\n\ndys = [  0.136,  0.717,  0.459, -0.225,  1.392,  0.385,  0.121, -0.395,\n         0.490, -0.682, -0.065,  0.242, -0.288,  0.658,  0.459,  0.000,\n         0.426,  0.205, -0.765, -2.188, -0.742, -0.010,  0.089,  0.208,\n         0.585,  0.633, -0.444, -0.351, -1.087,  0.199,  0.701,  0.096,\n        -0.025, -0.868,  1.051,  0.157,  0.216,  0.162,  0.249, -0.007,\n         0.009,  0.508, -0.790,  0.723,  0.881, -0.508,  0.393, -0.226,\n         0.710,  0.038, -0.217,  0.831,  0.480,  0.407,  0.447, -0.295,\n         1.126,  0.380,  0.549, -0.445, -0.046,  0.428, -0.074,  0.217,\n        -0.822,  0.491,  1.347, -0.141,  1.230, -0.044,  0.079,  0.219,\n         0.698,  0.275,  0.056,  0.031,  0.421,  0.064,  0.721,  0.104,\n        -0.729,  0.650, -1.103,  0.154, -1.720,  0.051, -0.385,  0.477,\n         1.537, -0.901,  0.939, -0.411,  0.341, -0.411,  0.106,  0.224,\n        -0.947, -1.424, -0.542, -1.032]\n\nexperiment('Rule 1:', dxs, dys) {|z, dz| 0}\nexperiment('Rule 2:', dxs, dys) {|z, dz| -dz}\nexperiment('Rule 3:', dxs, dys) {|z, dz| -(z+dz)}\nexperiment('Rule 4:', dxs, dys) {|z, dz| z+dz}\n", "target": "import math \n\ndxs = [-0.533, 0.27, 0.859, -0.043, -0.205, -0.127, -0.071, 0.275, 1.251,\n       -0.231, -0.401, 0.269, 0.491, 0.951, 1.15, 0.001, -0.382, 0.161, 0.915,\n       2.08, -2.337, 0.034, -0.126, 0.014, 0.709, 0.129, -1.093, -0.483, -1.193, \n       0.02, -0.051, 0.047, -0.095, 0.695, 0.34, -0.182, 0.287, 0.213, -0.423,\n       -0.021, -0.134, 1.798, 0.021, -1.099, -0.361, 1.636, -1.134, 1.315, 0.201, \n       0.034, 0.097, -0.17, 0.054, -0.553, -0.024, -0.181, -0.7, -0.361, -0.789,\n       0.279, -0.174, -0.009, -0.323, -0.658, 0.348, -0.528, 0.881, 0.021, -0.853,\n       0.157, 0.648, 1.774, -1.043, 0.051, 0.021, 0.247, -0.31, 0.171, 0.0, 0.106,\n       0.024, -0.386, 0.962, 0.765, -0.125, -0.289, 0.521, 0.017, 0.281, -0.749,\n       -0.149, -2.436, -0.909, 0.394, -0.113, -0.598, 0.443, -0.521, -0.799, \n       0.087]\n\ndys = [0.136, 0.717, 0.459, -0.225, 1.392, 0.385, 0.121, -0.395, 0.49, -0.682,\n       -0.065, 0.242, -0.288, 0.658, 0.459, 0.0, 0.426, 0.205, -0.765, -2.188, \n       -0.742, -0.01, 0.089, 0.208, 0.585, 0.633, -0.444, -0.351, -1.087, 0.199,\n       0.701, 0.096, -0.025, -0.868, 1.051, 0.157, 0.216, 0.162, 0.249, -0.007, \n       0.009, 0.508, -0.79, 0.723, 0.881, -0.508, 0.393, -0.226, 0.71, 0.038, \n       -0.217, 0.831, 0.48, 0.407, 0.447, -0.295, 1.126, 0.38, 0.549, -0.445, \n       -0.046, 0.428, -0.074, 0.217, -0.822, 0.491, 1.347, -0.141, 1.23, -0.044, \n       0.079, 0.219, 0.698, 0.275, 0.056, 0.031, 0.421, 0.064, 0.721, 0.104, \n       -0.729, 0.65, -1.103, 0.154, -1.72, 0.051, -0.385, 0.477, 1.537, -0.901, \n       0.939, -0.411, 0.341, -0.411, 0.106, 0.224, -0.947, -1.424, -0.542, -1.032]\n\ndef funnel(dxs, rule):\n    x, rxs = 0, []\n    for dx in dxs:\n        rxs.append(x + dx)\n        x = rule(x, dx)\n    return rxs\n\ndef mean(xs): return sum(xs) / len(xs)\n\ndef stddev(xs):\n    m = mean(xs)\n    return math.sqrt(sum((x-m)**2 for x in xs) / len(xs))\n\ndef experiment(label, rule):\n    rxs, rys = funnel(dxs, rule), funnel(dys, rule)\n    print label\n    print 'Mean x, y   \u00a0: %.4f, %.4f' % (mean(rxs), mean(rys))\n    print 'Std dev x, y\u00a0: %.4f, %.4f' % (stddev(rxs), stddev(rys))\n    print\n\n\nexperiment('Rule 1:', lambda z, dz: 0)\nexperiment('Rule 2:', lambda z, dz: -dz)\nexperiment('Rule 3:', lambda z, dz: -(z+dz))\nexperiment('Rule 4:', lambda z, dz: z+dz)\n"}
{"id": 336770, "name": "Deming's funnel", "source": "Translate Ruby to Python: def funnel(dxs, &rule)\n  x, rxs = 0, []\n  for dx in dxs\n    rxs << (x + dx)\n    x = rule[x, dx]\n  end\n  rxs\nend\n\ndef mean(xs) xs.inject(:+) / xs.size end\n\ndef stddev(xs)\n  m = mean(xs)\n  Math.sqrt(xs.inject(0.0){|sum,x| sum + (x-m)**2} / xs.size)\nend\n\ndef experiment(label, dxs, dys, &rule)\n  rxs, rys = funnel(dxs, &rule), funnel(dys, &rule)\n  puts label\n  puts 'Mean x, y   \u00a0: %7.4f, %7.4f' % [mean(rxs), mean(rys)]\n  puts 'Std dev x, y\u00a0: %7.4f, %7.4f' % [stddev(rxs), stddev(rys)]\n  puts\nend\n\ndxs = [ -0.533,  0.270,  0.859, -0.043, -0.205, -0.127, -0.071,  0.275,\n         1.251, -0.231, -0.401,  0.269,  0.491,  0.951,  1.150,  0.001,\n        -0.382,  0.161,  0.915,  2.080, -2.337,  0.034, -0.126,  0.014,\n         0.709,  0.129, -1.093, -0.483, -1.193,  0.020, -0.051,  0.047,\n        -0.095,  0.695,  0.340, -0.182,  0.287,  0.213, -0.423, -0.021,\n        -0.134,  1.798,  0.021, -1.099, -0.361,  1.636, -1.134,  1.315,\n         0.201,  0.034,  0.097, -0.170,  0.054, -0.553, -0.024, -0.181,\n        -0.700, -0.361, -0.789,  0.279, -0.174, -0.009, -0.323, -0.658,\n         0.348, -0.528,  0.881,  0.021, -0.853,  0.157,  0.648,  1.774,\n        -1.043,  0.051,  0.021,  0.247, -0.310,  0.171,  0.000,  0.106,\n         0.024, -0.386,  0.962,  0.765, -0.125, -0.289,  0.521,  0.017,\n         0.281, -0.749, -0.149, -2.436, -0.909,  0.394, -0.113, -0.598,\n         0.443, -0.521, -0.799,  0.087]\n\ndys = [  0.136,  0.717,  0.459, -0.225,  1.392,  0.385,  0.121, -0.395,\n         0.490, -0.682, -0.065,  0.242, -0.288,  0.658,  0.459,  0.000,\n         0.426,  0.205, -0.765, -2.188, -0.742, -0.010,  0.089,  0.208,\n         0.585,  0.633, -0.444, -0.351, -1.087,  0.199,  0.701,  0.096,\n        -0.025, -0.868,  1.051,  0.157,  0.216,  0.162,  0.249, -0.007,\n         0.009,  0.508, -0.790,  0.723,  0.881, -0.508,  0.393, -0.226,\n         0.710,  0.038, -0.217,  0.831,  0.480,  0.407,  0.447, -0.295,\n         1.126,  0.380,  0.549, -0.445, -0.046,  0.428, -0.074,  0.217,\n        -0.822,  0.491,  1.347, -0.141,  1.230, -0.044,  0.079,  0.219,\n         0.698,  0.275,  0.056,  0.031,  0.421,  0.064,  0.721,  0.104,\n        -0.729,  0.650, -1.103,  0.154, -1.720,  0.051, -0.385,  0.477,\n         1.537, -0.901,  0.939, -0.411,  0.341, -0.411,  0.106,  0.224,\n        -0.947, -1.424, -0.542, -1.032]\n\nexperiment('Rule 1:', dxs, dys) {|z, dz| 0}\nexperiment('Rule 2:', dxs, dys) {|z, dz| -dz}\nexperiment('Rule 3:', dxs, dys) {|z, dz| -(z+dz)}\nexperiment('Rule 4:', dxs, dys) {|z, dz| z+dz}\n", "target": "import math \n\ndxs = [-0.533, 0.27, 0.859, -0.043, -0.205, -0.127, -0.071, 0.275, 1.251,\n       -0.231, -0.401, 0.269, 0.491, 0.951, 1.15, 0.001, -0.382, 0.161, 0.915,\n       2.08, -2.337, 0.034, -0.126, 0.014, 0.709, 0.129, -1.093, -0.483, -1.193, \n       0.02, -0.051, 0.047, -0.095, 0.695, 0.34, -0.182, 0.287, 0.213, -0.423,\n       -0.021, -0.134, 1.798, 0.021, -1.099, -0.361, 1.636, -1.134, 1.315, 0.201, \n       0.034, 0.097, -0.17, 0.054, -0.553, -0.024, -0.181, -0.7, -0.361, -0.789,\n       0.279, -0.174, -0.009, -0.323, -0.658, 0.348, -0.528, 0.881, 0.021, -0.853,\n       0.157, 0.648, 1.774, -1.043, 0.051, 0.021, 0.247, -0.31, 0.171, 0.0, 0.106,\n       0.024, -0.386, 0.962, 0.765, -0.125, -0.289, 0.521, 0.017, 0.281, -0.749,\n       -0.149, -2.436, -0.909, 0.394, -0.113, -0.598, 0.443, -0.521, -0.799, \n       0.087]\n\ndys = [0.136, 0.717, 0.459, -0.225, 1.392, 0.385, 0.121, -0.395, 0.49, -0.682,\n       -0.065, 0.242, -0.288, 0.658, 0.459, 0.0, 0.426, 0.205, -0.765, -2.188, \n       -0.742, -0.01, 0.089, 0.208, 0.585, 0.633, -0.444, -0.351, -1.087, 0.199,\n       0.701, 0.096, -0.025, -0.868, 1.051, 0.157, 0.216, 0.162, 0.249, -0.007, \n       0.009, 0.508, -0.79, 0.723, 0.881, -0.508, 0.393, -0.226, 0.71, 0.038, \n       -0.217, 0.831, 0.48, 0.407, 0.447, -0.295, 1.126, 0.38, 0.549, -0.445, \n       -0.046, 0.428, -0.074, 0.217, -0.822, 0.491, 1.347, -0.141, 1.23, -0.044, \n       0.079, 0.219, 0.698, 0.275, 0.056, 0.031, 0.421, 0.064, 0.721, 0.104, \n       -0.729, 0.65, -1.103, 0.154, -1.72, 0.051, -0.385, 0.477, 1.537, -0.901, \n       0.939, -0.411, 0.341, -0.411, 0.106, 0.224, -0.947, -1.424, -0.542, -1.032]\n\ndef funnel(dxs, rule):\n    x, rxs = 0, []\n    for dx in dxs:\n        rxs.append(x + dx)\n        x = rule(x, dx)\n    return rxs\n\ndef mean(xs): return sum(xs) / len(xs)\n\ndef stddev(xs):\n    m = mean(xs)\n    return math.sqrt(sum((x-m)**2 for x in xs) / len(xs))\n\ndef experiment(label, rule):\n    rxs, rys = funnel(dxs, rule), funnel(dys, rule)\n    print label\n    print 'Mean x, y   \u00a0: %.4f, %.4f' % (mean(rxs), mean(rys))\n    print 'Std dev x, y\u00a0: %.4f, %.4f' % (stddev(rxs), stddev(rys))\n    print\n\n\nexperiment('Rule 1:', lambda z, dz: 0)\nexperiment('Rule 2:', lambda z, dz: -dz)\nexperiment('Rule 3:', lambda z, dz: -(z+dz))\nexperiment('Rule 4:', lambda z, dz: z+dz)\n"}
{"id": 336771, "name": "MD5_Implementation", "source": "Translate Ruby to Python: class MD5(String msg) {\n\n    method init {\n        msg = msg.bytes\n    }\n\n    const FGHI = [\n        {|a,b,c| (a & b) | (~a & c) },\n        {|a,b,c| (a & c) | (b & ~c) },\n        {|a,b,c| (a ^ b ^ c)        },\n        {|a,b,c| (b ^ (a | ~c))     },\n    ]\n\n    const S = [\n        [7, 12, 17, 22] * 4,\n        [5,  9, 14, 20] * 4,\n        [4, 11, 16, 23] * 4,\n        [6, 10, 15, 21] * 4,\n    ].flat\n\n    const T = 64.of {|i| floor(abs(sin(i+1)) * 1<<32) }\n\n    const K = [\n        ^16 -> map {|n|    n           },\n        ^16 -> map {|n| (5*n + 1) % 16 },\n        ^16 -> map {|n| (3*n + 5) % 16 },\n        ^16 -> map {|n| (7*n    ) % 16 },\n    ].flat\n\n    func radix(Number b, Array a) {\n        ^a -> sum {|i| b**i * a[i] }\n    }\n\n    func little_endian(Number w, Number n, Array v) {\n        var step1 = (^n \u00bb*\u00bb w)\n        var step2 = (v ~X>> step1)\n        step2 \u00bb%\u00bb (1 << w)\n    }\n\n    func block(Number a, Number b) { (a  + b) & 0xffffffff }\n    func srble(Number a, Number n) { (a << n) & 0xffffffff | (a >> (32-n)) }\n\n    func md5_pad(msg) {\n        var bits = 8*msg.len\n        var padded = [msg..., 128, [0] * (-(floor(bits / 8) + 1 + 8) % 64)].flat\n\n        gather {\n            padded.each_slice(4, {|*a|\n                take(radix(256, a))\n            })\n            take(little_endian(32, 2, [bits]))\n        }.flat\n    }\n\n    func md5_block(Array H, Array X) {\n        var (A, B, C, D) = H...\n\n        for i in ^64 {\n            (A, B, C, D) = (D,\n                block(B, srble(\n                    block(\n                        block(\n                            block(A, FGHI[floor(i / 16)](B, C, D)), T[i]\n                        ), X[K[i]]\n                    ), S[i])\n                ), B, C)\n        }\n\n        for k,v in ([A, B, C, D].kv) {\n            H[k] = block(H[k], v)\n        }\n\n        return H\n    }\n\n    method md5_hex {\n        self.md5.map {|n| '%02x' % n }.join\n    }\n\n    method md5 {\n        var M = md5_pad(msg)\n        var H = [0x67452301, 0xefcdab89, 0x98badcfe, 0x10325476]\n\n        for i in (range(0, M.end, 16)) {\n            md5_block(H, M.ft(i, i+15))\n        }\n\n        little_endian(8, 4, H)\n    }\n}\n\nvar tests = [\n    ['d41d8cd98f00b204e9800998ecf8427e', ''],\n    ['0cc175b9c0f1b6a831c399e269772661', 'a'],\n    ['900150983cd24fb0d6963f7d28e17f72', 'abc'],\n    ['f96b697d7cb7938d525a2f31aaf161d0', 'message digest'],\n    ['c3fcd3d76192e4007dfb496cca67e13b', 'abcdefghijklmnopqrstuvwxyz'],\n    ['d174ab98d277d9f5a5611c2c9f419d9f', 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789'],\n    ['57edf4a22be3c955ac49da2e2107b67a', '12345678901234567890123456789012345678901234567890123456789012345678901234567890'],\n]\n\nfor md5,msg in tests {\n    var hash = MD5(msg).md5_hex\n    say \"\n\n    if (hash != md5) {\n        say \"\\tHowever, that is incorrect (expected: \n    }\n}\n", "target": "import math\n\nrotate_amounts = [7, 12, 17, 22, 7, 12, 17, 22, 7, 12, 17, 22, 7, 12, 17, 22,\n                  5,  9, 14, 20, 5,  9, 14, 20, 5,  9, 14, 20, 5,  9, 14, 20,\n                  4, 11, 16, 23, 4, 11, 16, 23, 4, 11, 16, 23, 4, 11, 16, 23,\n                  6, 10, 15, 21, 6, 10, 15, 21, 6, 10, 15, 21, 6, 10, 15, 21]\n\nconstants = [int(abs(math.sin(i+1)) * 2**32) & 0xFFFFFFFF for i in range(64)]\n\ninit_values = [0x67452301, 0xefcdab89, 0x98badcfe, 0x10325476]\n\nfunctions = 16*[lambda b, c, d: (b & c) | (~b & d)] + \\\n            16*[lambda b, c, d: (d & b) | (~d & c)] + \\\n            16*[lambda b, c, d: b ^ c ^ d] + \\\n            16*[lambda b, c, d: c ^ (b | ~d)]\n\nindex_functions = 16*[lambda i: i] + \\\n                  16*[lambda i: (5*i + 1)%16] + \\\n                  16*[lambda i: (3*i + 5)%16] + \\\n                  16*[lambda i: (7*i)%16]\n\ndef left_rotate(x, amount):\n    x &= 0xFFFFFFFF\n    return ((x<<amount) | (x>>(32-amount))) & 0xFFFFFFFF\n\ndef md5(message):\n\n    message = bytearray(message) \n    orig_len_in_bits = (8 * len(message)) & 0xffffffffffffffff\n    message.append(0x80)\n    while len(message)%64 != 56:\n        message.append(0)\n    message += orig_len_in_bits.to_bytes(8, byteorder='little')\n\n    hash_pieces = init_values[:]\n\n    for chunk_ofst in range(0, len(message), 64):\n        a, b, c, d = hash_pieces\n        chunk = message[chunk_ofst:chunk_ofst+64]\n        for i in range(64):\n            f = functions[i](b, c, d)\n            g = index_functions[i](i)\n            to_rotate = a + f + constants[i] + int.from_bytes(chunk[4*g:4*g+4], byteorder='little')\n            new_b = (b + left_rotate(to_rotate, rotate_amounts[i])) & 0xFFFFFFFF\n            a, b, c, d = d, new_b, b, c\n        for i, val in enumerate([a, b, c, d]):\n            hash_pieces[i] += val\n            hash_pieces[i] &= 0xFFFFFFFF\n    \n    return sum(x<<(32*i) for i, x in enumerate(hash_pieces))\n        \ndef md5_to_hex(digest):\n    raw = digest.to_bytes(16, byteorder='little')\n    return '{:032x}'.format(int.from_bytes(raw, byteorder='big'))\n\nif __name__=='__main__':\n    demo = [b\"\", b\"a\", b\"abc\", b\"message digest\", b\"abcdefghijklmnopqrstuvwxyz\",\n            b\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789\",\n            b\"12345678901234567890123456789012345678901234567890123456789012345678901234567890\"]\n    for message in demo:\n        print(md5_to_hex(md5(message)),' <= \"',message.decode('ascii'),'\"', sep='')\n"}
{"id": 336772, "name": "Exponentiation with infix operators in (or operating on) the base", "source": "Translate Ruby to Python: nums = [-5, 5]\npows = [2, 3]\nnums.product(pows) do |x, p|\n  puts \"x = \nend\n", "target": "from itertools import product\n\nxx = '-5 +5'.split()\npp = '2 3'.split()\ntexts = '-x**p -(x)**p (-x)**p -(x**p)'.split()\n\nprint('Integer variable exponentiation')\nfor x, p in product(xx, pp):\n    print(f'  x,p = {x:2},{p}; ', end=' ')\n    x, p = int(x), int(p)\n    print('; '.join(f\"{t} =={eval(t):4}\" for t in texts))\n\nprint('\\nBonus integer literal exponentiation')\nX, P = 'xp'\nxx.insert(0, ' 5')\ntexts.insert(0, 'x**p')\nfor x, p in product(xx, pp):\n    texts2 = [t.replace(X, x).replace(P, p) for t in texts]\n    print(' ', '; '.join(f\"{t2} =={eval(t2):4}\" for t2 in texts2))\n"}
{"id": 336773, "name": "Exponentiation with infix operators in (or operating on) the base", "source": "Translate Ruby to Python: nums = [-5, 5]\npows = [2, 3]\nnums.product(pows) do |x, p|\n  puts \"x = \nend\n", "target": "from itertools import product\n\nxx = '-5 +5'.split()\npp = '2 3'.split()\ntexts = '-x**p -(x)**p (-x)**p -(x**p)'.split()\n\nprint('Integer variable exponentiation')\nfor x, p in product(xx, pp):\n    print(f'  x,p = {x:2},{p}; ', end=' ')\n    x, p = int(x), int(p)\n    print('; '.join(f\"{t} =={eval(t):4}\" for t in texts))\n\nprint('\\nBonus integer literal exponentiation')\nX, P = 'xp'\nxx.insert(0, ' 5')\ntexts.insert(0, 'x**p')\nfor x, p in product(xx, pp):\n    texts2 = [t.replace(X, x).replace(P, p) for t in texts]\n    print(' ', '; '.join(f\"{t2} =={eval(t2):4}\" for t2 in texts2))\n"}
{"id": 336774, "name": "History variables", "source": "Translate Ruby to Python: foo_hist = []\ntrace_var(:$foo){|v| foo_hist.unshift(v)}\n\n$foo = \"apple\"\n$foo = \"pear\"\n$foo = \"banana\"\n\np foo_hist \n", "target": "import sys\n\nHIST = {}\n\ndef trace(frame, event, arg):\n    for name,val in frame.f_locals.items():\n        if name not in HIST:\n            HIST[name] = []\n        else:\n            if HIST[name][-1] is val:\n                continue\n        HIST[name].append(val)\n    return trace\n\ndef undo(name):\n    HIST[name].pop(-1)\n    return HIST[name][-1]\n\ndef main():\n    a = 10\n    a = 20\n\n    for i in range(5):\n        c = i\n\n    print \"c:\", c, \"-> undo x3 ->\",\n    c = undo('c')\n    c = undo('c')\n    c = undo('c')\n    print c\n    print 'HIST:', HIST\n\nsys.settrace(trace)\nmain()\n"}
{"id": 336775, "name": "Reverse the order of lines in a text file while preserving the contents of each line", "source": "Translate Ruby to Python: puts File.readlines(\"diplomacy.txt\").reverse\n", "target": "\n\nimport sys\n\nif len(sys.argv)!=2:\n    print(\"Usage\u00a0: python \" + sys.argv[0] + \" <filename>\")\n    exit()\n\ndataFile = open(sys.argv[1],\"r\")\n\nfileData = dataFile.read().split('\\n')\n\ndataFile.close()\n\n[print(i) for i in fileData[::-1]]\n"}
{"id": 336776, "name": "Positive decimal integers with the digit 1 occurring exactly twice", "source": "Translate Ruby to Python: p (1..1000).select{|n| n.digits.count(1) == 2}\n", "target": "\n\nfrom itertools import permutations\n\nfor i in range(0,10):\n    if i!=1:\n        baseList = [1,1]\n        baseList.append(i)\n        [print(int(''.join(map(str,j)))) for j in sorted(set(permutations(baseList)))]\n"}
{"id": 336777, "name": "Unique characters in each string", "source": "Translate Ruby to Python: arr = [\"1a3c52debeffd\", \"2b6178c97a938stf\", \"3ycxdb1fgxa2yz\"]\n\nuniqs_in_str = arr.map{|str| str.chars.tally.filter_map{|char, count| char if count == 1} }\nputs uniqs_in_str.inject(&:intersection).sort.join(\" \")\n", "target": "LIST = [\"1a3c52debeffd\", \"2b6178c97a938stf\", \"3ycxdb1fgxa2yz\"]\n\nprint(sorted([ch for ch in set([c for c in ''.join(LIST)]) if all(w.count(ch) == 1 for w in LIST)]))\n"}
{"id": 336778, "name": "Jacobsthal numbers", "source": "Translate Ruby to Python: require 'prime'\n\ndef jacobsthal(n) = (2**n + n[0])/3\ndef jacobsthal_lucas(n) = 2**n + (-1)**n\ndef jacobsthal_oblong(n) = jacobsthal(n) * jacobsthal(n+1)\n\nputs \"First 30 Jacobsthal numbers:\"\nputs (0..29).map{|n| jacobsthal(n) }.join(\" \")\n\nputs \"\\nFirst 30 Jacobsthal-Lucas numbers: \"\nputs (0..29).map{|n| jacobsthal_lucas(n) }.join(\" \")\n\nputs \"\\nFirst 20 Jacobsthal-Oblong numbers: \"\nputs (0..19).map{|n| jacobsthal_oblong(n) }.join(\" \")\n\nputs \"\\nFirst 10 prime Jacobsthal numbers: \"\nres = (0..).lazy.filter_map do |i|\n  j = jacobsthal(i) \n  j if j.prime?\nend\nputs res.take(10).force.join(\" \")\n", "target": "\nfrom math import floor, pow\n\ndef isPrime(n):\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return False        \n    return True\n\ndef odd(n):\n    return n and 1 != 0\n    \ndef jacobsthal(n):\n    return floor((pow(2,n)+odd(n))/3)\n\ndef jacobsthal_lucas(n):\n    return int(pow(2,n)+pow(-1,n))\n\ndef jacobsthal_oblong(n):\n    return jacobsthal(n)*jacobsthal(n+1)\n\n\nif __name__ == '__main__':\n    print(\"First 30 Jacobsthal numbers:\")\n    for j in range(0, 30):\n        print(jacobsthal(j), end=\"  \")\n\n    print(\"\\n\\nFirst 30 Jacobsthal-Lucas numbers: \")\n    for j in range(0, 30):\n        print(jacobsthal_lucas(j), end = '\\t')\n\n    print(\"\\n\\nFirst 20 Jacobsthal oblong numbers: \")\n    for j in range(0, 20):\n        print(jacobsthal_oblong(j), end=\"  \")\n\n    print(\"\\n\\nFirst 10 Jacobsthal primes: \")\n    for j in range(3, 33):\n        if isPrime(jacobsthal(j)):\n            print(jacobsthal(j))\n"}
{"id": 354199, "name": "Pascal matrix generation", "source": "Translate Ruby to Java: \nrequire 'pp'\n\nng = (g = 0..4).collect{[]}\ng.each{|i| g.each{|j| ng[i][j] = i==0 ? 1 : j<i ? 0 : ng[i-1][j-1]+ng[i][j-1]}}\npp ng; puts\ng.each{|i| g.each{|j| ng[i][j] = j==0 ? 1 : i<j ? 0 : ng[i-1][j-1]+ng[i-1][j]}}\npp ng; puts\ng.each{|i| g.each{|j| ng[i][j] = (i==0 or j==0) ? 1 : ng[i-1][j  ]+ng[i][j-1]}}\npp ng\n", "target": "import static java.lang.System.out;\nimport java.util.List;\nimport java.util.function.Function;\nimport java.util.stream.*;\nimport static java.util.stream.Collectors.toList;\nimport static java.util.stream.IntStream.range;\n\npublic class PascalMatrix {\n    static int binomialCoef(int n, int k) {\n        int result = 1;\n        for (int i = 1; i <= k; i++)\n            result = result * (n - i + 1) / i;\n        return result;\n    }\n\n    static List<IntStream> pascal(int n, Function<Integer, IntStream> f) {\n        return range(0, n).mapToObj(i -> f.apply(i)).collect(toList());\n    }\n\n    static List<IntStream> pascalUpp(int n) {\n        return pascal(n, i -> range(0, n).map(j -> binomialCoef(j, i)));\n    }\n\n    static List<IntStream> pascalLow(int n) {\n        return pascal(n, i -> range(0, n).map(j -> binomialCoef(i, j)));\n    }\n\n    static List<IntStream> pascalSym(int n) {\n        return pascal(n, i -> range(0, n).map(j -> binomialCoef(i + j, i)));\n    }\n\n    static void print(String label, List<IntStream> result) {\n        out.println(\"\\n\" + label);\n        for (IntStream row : result) {\n            row.forEach(i -> out.printf(\"%2d \", i));\n            System.out.println();\n        }\n    }\n\n    public static void main(String[] a) {\n        print(\"Upper: \", pascalUpp(5));\n        print(\"Lower: \", pascalLow(5));\n        print(\"Symmetric:\", pascalSym(5));\n    }\n}\n"}
{"id": 354200, "name": "Mad Libs", "source": "Translate Ruby to Java: puts \"Enter a story, terminated by an empty line:\"\nstory = \"\"\nuntil (line = gets).chomp.empty?\n  story << line\nend\n\nstory.scan(/(?<=[<]).+?(?=[>])/).uniq.each do |var|\n  print \"Enter a value for '\n  story.gsub!(/<\nend\n\nputs\nputs story\n", "target": "import java.util.*;\n\npublic class MadLibs {\n    \n    public static void main(String[] args){\n        Scanner input = new Scanner(System.in);\n        \n        String name, gender, noun;\n        \n        System.out.print(\"Enter a name: \");\n        name = input.next();\n        \n        System.out.print(\"He or she: \");\n        gender = input.next();\n        \n        System.out.print(\"Enter a noun: \");\n        noun = input.next();\n        \n        System.out.println(\"\\f\" + name + \" went for a walk in the park. \" + gender + \"\\nfound a \" + noun + \". \" + name + \" decided to take it home.\");\n        \n    \n    }\n}\n"}
{"id": 354201, "name": "Shortest common supersequence", "source": "Translate Ruby to Java: require 'lcs'\n\ndef scs(u, v)\n  lcs = lcs(u, v)\n  u, v = u.dup, v.dup\n  scs = \"\"\n  \n  until lcs.empty?\n    if u[0]==lcs[0] and v[0]==lcs[0]\n      \n      scs << lcs.slice!(0)\n      u.slice!(0)\n      v.slice!(0)\n    elsif u[0]==lcs[0]\n      \n      scs << v.slice!(0)\n    else\n      \n      scs << u.slice!(0)\n    end\n  end\n  \n  scs + u + v\nend\n\nu = \"abcbdab\"\nv = \"bdcaba\"\nputs \"SCS(\n", "target": "public class ShortestCommonSuperSequence {\n    private static boolean isEmpty(String s) {\n        return null == s || s.isEmpty();\n    }\n\n    private static String scs(String x, String y) {\n        if (isEmpty(x)) {\n            return y;\n        }\n        if (isEmpty(y)) {\n            return x;\n        }\n\n        if (x.charAt(0) == y.charAt(0)) {\n            return x.charAt(0) + scs(x.substring(1), y.substring(1));\n        }\n\n        if (scs(x, y.substring(1)).length() <= scs(x.substring(1), y).length()) {\n            return y.charAt(0) + scs(x, y.substring(1));\n        } else {\n            return x.charAt(0) + scs(x.substring(1), y);\n        }\n    }\n\n    public static void main(String[] args) {\n        System.out.println(scs(\"abcbdab\", \"bdcaba\"));\n    }\n}\n"}
{"id": 354202, "name": "Long year", "source": "Translate Ruby to Java: require 'date'\n\ndef long_year?(year = Date.today.year)\n  Date.new(year, 12, 28).cweek == 53\nend\n\n(2020..2030).each{|year| puts \"\n", "target": "import java.time.LocalDate;\nimport java.time.temporal.WeekFields;\n\npublic class LongYear {\n\n    public static void main(String[] args) {\n        System.out.printf(\"Long years this century:%n\");\n        for (int year = 2000 ; year < 2100 ; year++ ) {\n            if ( longYear(year) ) {\n                System.out.print(year + \"  \");\n            }\n        }\n    }\n    \n    private static boolean longYear(int year) {\n        return LocalDate.of(year, 12, 28).get(WeekFields.ISO.weekOfYear()) == 53;\n    }\n\n}\n"}
{"id": 354203, "name": "Mian-Chowla sequence", "source": "Translate Ruby to Java: require 'set'\nn, ts, mc, sums = 100, [], [1], Set.new\nsums << 2\nst = Time.now\nfor i in (1 .. (n-1))\n   for j in mc[i-1]+1 .. Float::INFINITY\n      mc[i] = j\n      for k in (0 .. i)\n         if (sums.include?(sum = mc[k]+j))\n            ts.clear\n            break \n         end\n         ts << sum\n      end\n      if (ts.length > 0)\n         sums = sums | ts\n         break\n      end\n   end\nend\net = (Time.now - st) * 1000\ns = \" of the Mian-Chowla sequence are:\\n\"\nputs \"The first 30 terms\nputs \"Terms 91 to 100\nputs \"Computation time was \n", "target": "import java.util.Arrays;\n\npublic class MianChowlaSequence {\n\n    public static void main(String[] args) {\n        long start = System.currentTimeMillis();\n        System.out.println(\"First 30 terms of the Mian\u2013Chowla sequence.\");\n        mianChowla(1, 30);\n        System.out.println(\"Terms 91 through 100 of the Mian\u2013Chowla sequence.\");\n        mianChowla(91, 100);\n        long end = System.currentTimeMillis();\n        System.out.printf(\"Elapsed = %d ms%n\", (end-start));\n    }\n\n    private static void mianChowla(int minIndex, int maxIndex) {\n        int [] sums = new int[1];\n        int [] chowla = new int[maxIndex+1];\n        sums[0] = 2;\n        chowla[0] = 0;\n        chowla[1] = 1;\n        if ( minIndex == 1 ) {\n            System.out.printf(\"%d \", 1);\n        }\n        int chowlaLength = 1;\n        for ( int n = 2 ; n <= maxIndex ; n++ ) {\n\n            \n            int test = chowla[n - 1];\n            \n            int[] sumsNew = Arrays.copyOf(sums, sums.length + n);\n            int sumNewLength = sums.length;\n            int savedsSumNewLength = sumNewLength;\n            \n            \n            boolean found = false;\n            while ( ! found ) {\n                test++;\n                found = true;\n                sumNewLength = savedsSumNewLength;\n                \n                for ( int j = 0 ; j <= chowlaLength ; j++ ) {\n                    int testSum = (j == 0 ? test : chowla[j]) + test;\n                    boolean duplicate = false;\n                    \n                    \n                    for ( int k = 0 ; k < sumNewLength ; k++ ) {\n                        if ( sumsNew[k] == testSum ) {\n                            duplicate = true;\n                            break;\n                        }\n                    }\n                    if ( ! duplicate ) {\n                        \n                        sumsNew[sumNewLength] = testSum;\n                        sumNewLength++;\n                    }\n                    else {\n                        \n                        found = false;\n                        break;\n                    }\n                }\n            }\n            \n            \n            chowla[n] = test;\n            chowlaLength++;            \n            sums = sumsNew;\n            if ( n >= minIndex ) {\n                System.out.printf(\"%d %s\", chowla[n], (n==maxIndex ? \"\\n\" : \"\"));\n            }\n        }\n    }\n\n}\n"}
{"id": 354204, "name": "Water collected between towers", "source": "Translate Ruby to Java: def a(array)\nn=array.length\nleft={}\nright={}\nleft[0]=array[0]\ni=1\nloop do\n   break if i >=n\nleft[i]=[left[i-1],array[i]].max\n   i += 1  \nend\nright[n-1]=array[n-1]\ni=n-2\nloop do \nbreak if i<0\n right[i]=[right[i+1],array[i]].max\ni-=1\nend\ni=0\nwater=0\nloop do\nbreak if i>=n\nwater+=[left[i],right[i]].min-array[i]\ni+=1\nend\nputs water\nend\n\na([ 5, 3,  7, 2, 6, 4, 5, 9, 1, 2 ])\na([ 2, 6,  3, 5, 2, 8, 1, 4, 2, 2, 5, 3, 5, 7, 4, 1 ])\na([ 5, 5,  5, 5 ])\na([ 5, 6,  7, 8 ])\na([ 8, 7,  7, 6 ])\na([ 6, 7, 10, 7, 6 ])\nreturn\n", "target": "public class WaterBetweenTowers {\n    public static void main(String[] args) {\n        int i = 1;\n        int[][] tba = new int[][]{\n            new int[]{1, 5, 3, 7, 2},\n            new int[]{5, 3, 7, 2, 6, 4, 5, 9, 1, 2},\n            new int[]{2, 6, 3, 5, 2, 8, 1, 4, 2, 2, 5, 3, 5, 7, 4, 1},\n            new int[]{5, 5, 5, 5},\n            new int[]{5, 6, 7, 8},\n            new int[]{8, 7, 7, 6},\n            new int[]{6, 7, 10, 7, 6}\n        };\n\n        for (int[] tea : tba) {\n            int rht, wu = 0, bof;\n            do {\n                for (rht = tea.length - 1; rht >= 0; rht--) {\n                    if (tea[rht] > 0) {\n                        break;\n                    }\n                }\n\n                if (rht < 0) {\n                    break;\n                }\n\n                bof = 0;\n                for (int col = 0; col <= rht; col++) {\n                    if (tea[col] > 0) {\n                        tea[col]--;\n                        bof += 1;\n                    } else if (bof > 0) {\n                        wu++;\n                    }\n                }\n                if (bof < 2) {\n                    break;\n                }\n            } while (true);\n\n            System.out.printf(\"Block %d\", i++);\n            if (wu == 0) {\n                System.out.print(\" does not hold any\");\n            } else {\n                System.out.printf(\" holds %d\", wu);\n            }\n            System.out.println(\" water units.\");\n        }\n    }\n}\n"}
{"id": 354205, "name": "FASTA format", "source": "Translate Ruby to Java: \ntmpfile = \"/tmp/tmp\"+Random.rand.to_s+\".fasta\"\nFile.write(tmpfile, \">Rosetta_Example_1\nTHERECANBENOSPACE\n>Rosetta_Example_2\nTHERECANBESEVERAL\nLINESBUTTHEYALLMUST\nBECONCATENATED\")\n\n\nref = tmpfile\nid = seq = \"\"\nfasta = {} of String => String\nFile.each_line(ref) do |line|\n  if line.starts_with?(\">\")\n    fasta[id] = seq.sub(/\\s/, \"\") if id != \"\"\n    id = line.split(/\\s/)[0].lstrip(\">\")\n    seq = \"\"\n  else\n    seq += line\n  end\nend\nfasta[id] = seq.sub(/\\s/, \"\")\n\n\nfasta.each { |k,v| puts \"\n", "target": "import java.io.*;\nimport java.util.Scanner;\n\npublic class ReadFastaFile {\n\n    public static void main(String[] args) throws FileNotFoundException {\n\n        boolean first = true;\n\n        try (Scanner sc = new Scanner(new File(\"test.fasta\"))) {\n            while (sc.hasNextLine()) {\n                String line = sc.nextLine().trim();\n                if (line.charAt(0) == '>') {\n                    if (first)\n                        first = false;\n                    else\n                        System.out.println();\n                    System.out.printf(\"%s: \", line.substring(1));\n                } else {\n                    System.out.print(line);\n                }\n            }\n        }\n        System.out.println();\n    }\n}\n"}
{"id": 354206, "name": "MAC vendor lookup", "source": "Translate Ruby to Java: require 'net/http'\n\narr = ['88:53:2E:67:07:BE', 'FC:FB:FB:01:FA:21', 'D4:F4:6F:C9:EF:8D', '23:45:67']\n\narr.each do |addr|\n  vendor = Net::HTTP.get('api.macvendors.com', \"/\n  puts \"\nend\n", "target": "package com.jamesdonnell.MACVendor;\n\nimport java.io.BufferedReader;\nimport java.io.FileNotFoundException;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\n\n\npublic class Lookup {\n\t\n\tprivate static final String baseURL = \"http:\n\n\t\n\tpublic static void main(String[] args) {\n\t\tfor (String arguments : args)\n\t\t\tSystem.out.println(arguments + \": \" + get(arguments));\n\t}\n\n\t\n\tprivate static String get(String macAddress) {\n\t\ttry {\n\t\t\tStringBuilder result = new StringBuilder();\n\t\t\tURL url = new URL(baseURL + macAddress);\n\t\t\tHttpURLConnection conn = (HttpURLConnection) url.openConnection();\n\t\t\tconn.setRequestMethod(\"GET\");\n\t\t\tBufferedReader rd = new BufferedReader(new InputStreamReader(conn.getInputStream()));\n\t\t\tString line;\n\t\t\twhile ((line = rd.readLine()) != null) {\n\t\t\t\tresult.append(line);\n\t\t\t}\n\t\t\trd.close();\n\t\t\treturn result.toString();\n\t\t} catch (FileNotFoundException e) {\n\t\t\t\n\t\t\treturn \"N/A\";\n\t\t} catch (IOException e) {\n\t\t\t\n\t\t\treturn null;\n\t\t}\n\t}\n}\n"}
{"id": 354207, "name": "Magic 8-ball", "source": "Translate Ruby to Java: \n\nclass EightBall\n  def initialize\n    print \"Welcome to 8 ball! Ask your question below. \"\n    puts \"Type 'quit' to exit the program.\\n\\n\"\n    @responses = [\"It is certain\", \"It is decidedly so\",\n                          \"Without a doubt\", \"Yes, definitely\",\n                          \"You may rely on it\", \"As I see it, yes\",\n                          \"Most likely\", \"Outlook good\",\n                          \"Signs point to yes\", \"Yes\",\n                          \"Reply hazy, try again\", \"Ask again later\",\n                          \"Better not tell you now\",\n                          \"Cannot predict now\",\n                          \"Concentrate and ask again\", \"Don't bet on it\",\n                          \"My reply is no\", \"My sources say no\",\n                          \"Outlook not so good\", \"Very doubtful\"]\n  end\n\n  def ask_question\n    print \"Question: \"\n    question = gets\n\n    if question.chomp.eql? \"quit\"\n      exit(0)\n    end\n\n    puts \"Response: \n  end\n\n  def run\n    loop do\n      ask_question\n    end\n  end\nend\n\neight_ball = EightBall.new\neight_ball.run\n", "target": "import java.util.Random;\nimport java.util.Scanner;\n\npublic class MagicEightBall {\n\n    public static void main(String[] args) {\n        new MagicEightBall().run();\n    }\n    \n    private static String[] ANSWERS = new String[] {\"It is certain.\", \"It is decidedly so.\", \"Without a doubt.\", \"Yes - definitely.\",\n            \"You may rely on it.\", \"As I see it, yes.\", \"Most likely.\", \"Outlook good.\", \"Yes.\", \"Signs point to yes.\",\n            \"Reply hazy, try again.\", \"Ask again later.\", \"Better not tell you now.\", \"Cannot predict now.\", \"Concentrate and ask again.\",\n            \"Don't count on it.\", \"My reply is no.\", \"My sources say no.\", \"Outlook not so good.\", \"Very doubtful. \"};\n\n    public void run() {\n        Random random = new Random();\n        System.out.printf(\"Hello.  The Magic 8 Ball knows all.  Type your question.%n%n\");\n        try ( Scanner in = new Scanner(System.in); ) {\n            System.out.printf(\"?  \");\n            while ( (in.nextLine()).length() > 0 ) {\n                System.out.printf(\"8 Ball Response:  %s%n\", ANSWERS[random.nextInt(ANSWERS.length)]);\n                System.out.printf(\"?  \");\n            }\n        }\n        System.out.printf(\"%n8 Ball Done.  Bye.\");\n    }\n}\n"}
{"id": 354208, "name": "Validate International Securities Identification Number", "source": "Translate Ruby to Java: RE = /\\A[A-Z]{2}[A-Z0-9]{9}[0-9]{1}\\z/\n\ndef valid_isin?(str)\n  return false unless str =~ RE\n  luhn(str.chars.map{|c| c.to_i(36)}.join)\nend\n\np %w(US0378331005\nUS0373831005\nU50378331005\nUS03378331005\nAU0000XVGZA3\nAU0000VXGZA3\nFR0000988040).map{|tc| valid_isin?(tc) }\t \n \n\n", "target": "public class ISIN {\n \n    public static void main(String[] args) {\n        String[] isins = {\n            \"US0378331005\", \n            \"US0373831005\", \n            \"U50378331005\", \n            \"US03378331005\",\n            \"AU0000XVGZA3\", \n            \"AU0000VXGZA3\", \n            \"FR0000988040\"\n        };\n        for (String isin : isins)\n            System.out.printf(\"%s is %s\\n\", isin, ISINtest(isin) ? \"valid\" : \"not valid\");\n    }\n \n    static boolean ISINtest(String isin) {\n        isin = isin.trim().toUpperCase();\n \n        if (!isin.matches(\"^[A-Z]{2}[A-Z0-9]{9}\\\\d$\"))\n            return false;\n \n        StringBuilder sb = new StringBuilder();\n        for (char c : isin.substring(0, 12).toCharArray())\n            sb.append(Character.digit(c, 36));\n \n        return luhnTest(sb.toString());\n    }\n\n    static boolean luhnTest(String number) {\n        int s1 = 0, s2 = 0;\n        String reverse = new StringBuffer(number).reverse().toString();\n        for (int i = 0; i < reverse.length(); i++){\n            int digit = Character.digit(reverse.charAt(i), 10);\n            \n            if (i % 2 == 0){\n                s1 += digit;\n            } else { \n                s2 += 2 * digit;\n                if(digit >= 5){\n                    s2 -= 9;\n                }\n            }\n        }\n        return (s1 + s2) % 10 == 0;\n    }\n}\n"}
{"id": 354209, "name": "Cycle detection", "source": "Translate Ruby to Java: \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ndef findCycle(x0)\n  power = lambda = 1\n  tortoise = x0\n  hare = yield(x0)\n  \n  \n  while tortoise != hare\n    if power == lambda\n      tortoise = hare\n      power *= 2\n      lambda = 0\n    end\n    hare = yield(hare)\n    lambda += 1\n  end\n  \n  \n  hare = x0\n  lambda.times { hare = yield(hare) }\n  \n  tortoise, mu = x0, 0\n  while tortoise != hare\n    tortoise = yield(tortoise)\n    hare = yield(hare)\n    mu += 1\n  end\n  \n  return lambda, mu\nend\n\n\ndef f(x) (x * x + 1) % 255 end\n\n\nputs (1..40).reduce([3]){|acc,_| acc << f(acc.last)}.join(\",\")\n\n\nclength, cstart = findCycle(3) { |x| f(x) }\nputs \"Cycle length = \n", "target": "import java.util.function.*;\nimport static java.util.stream.IntStream.*;\n\npublic class CycleDetection {\n\n    public static void main(String[] args) {\n        brent(i -> (i * i + 1) % 255, 3);\n    }\n\n    static void brent(IntUnaryOperator f, int x0) {\n        int cycleLength;\n        int hare = x0;\n        FOUND:\n        for (int power = 1; ; power *= 2) {\n            int tortoise = hare;\n            for (int i = 1; i <= power; i++) {\n                hare = f.applyAsInt(hare);\n                 if (tortoise == hare) {\n                    cycleLength = i;\n                    break FOUND;\n                }\n            }\n        }\n\n        hare = x0;\n        for (int i = 0; i < cycleLength; i++)\n            hare = f.applyAsInt(hare);\n\n        int cycleStart = 0;\n        for (int tortoise = x0; tortoise != hare; cycleStart++) {\n            tortoise = f.applyAsInt(tortoise);\n            hare = f.applyAsInt(hare);\n        }\n\n        printResult(x0, f, cycleLength, cycleStart);\n    }\n\n    static void printResult(int x0, IntUnaryOperator f, int len, int start) {\n        System.out.printf(\"Cycle length: %d%nCycle: \", len);\n        iterate(x0, f).skip(start).limit(len)\n                .forEach(n -> System.out.printf(\"%s \", n));\n    }\n}\n"}
{"id": 354210, "name": "Input_Output for pairs of numbers", "source": "Translate Ruby to Java: n = gets.to_i\nn.times do\n  a, b = gets.split.map(&:to_i)\n  puts a + b\nend\n", "target": "import java.util.Scanner;\n\npublic class Main {\n\n\tpublic static int doStuff(int a, int b){\n\t    int sum = a+b;\n\t    return sum;\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tScanner in = new Scanner(System.in);\n\n\t\tint n = in.nextInt();\n\t\tfor(int i=0; i<n; i++){\n\t\t\tint a = in.nextInt();\n\t\t\tint b= in.nextInt();\n\t\t\tint result = doStuff(a, b);\n\t\t\tSystem.out.println(result);\n\t\t}\n\t}\n}\n"}
{"id": 354211, "name": "ABC words", "source": "Translate Ruby to Java: puts File.open(\"unixdict.txt\").grep(/^[^bc]*a[^c]*b.*c/)\n", "target": "import java.io.BufferedReader;\nimport java.io.FileReader;\n\npublic class AbcWords {\n    public static void main(String[] args) {\n        String fileName = \"unixdict.txt\";\n        String chars = \"abc\";\n        for (int i = 0; i + 1 < args.length\n                && args[i].length() > 1\n                && args[i].charAt(0) == '-'; ++i) {\n            switch (args[i].charAt(1)) {\n            case 'f':\n                fileName = args[++i];\n                break;\n            case 'c':\n                chars = args[++i];\n                break;\n            }\n        }\n        \n        try (BufferedReader reader = new BufferedReader(new FileReader(fileName))) {\n            String line;\n            int n = 0;\n            while ((line = reader.readLine()) != null) {\n                if (match(line, chars)) {\n                    ++n;\n                    System.out.printf(\"%3d:\u00a0%-20s\", n, line);\n                    if (n % 3 == 0)\n                        System.out.println();\n                }\n            }\n            if (n > 0 && n % 3 != 0)\n                System.out.println();\n        } catch (Exception e)  {\n            e.printStackTrace();\n        }\n    }\n\n    \n    \n    private static boolean match(String word, String chars) {\n        int length = chars.length();\n        boolean[] seen = new boolean[length];\n        int wordLength = word.length();\n        for (int w = 0; w < wordLength; ++w) {\n            char ch = word.charAt(w);\n            int index = -1;\n            for (int c = 0; c < length; ++c) {\n                if (ch == chars.charAt(c) && !seen[c]) {\n                    index = c;\n                    break;\n                }\n            }\n            if (index == -1)\n                continue;\n            if (index + 1 == length)\n                return index == 0 ? true : seen[index - 1];\n            if (index > 0 && !seen[index - 1])\n                return false;\n            seen[index] = true;\n        }\n        return false;\n    }\n}\n"}
{"id": 354212, "name": "Text between", "source": "Translate Ruby to Java: class String\n  def textBetween startDelimiter, endDelimiter\n  \n  \tif (startDelimiter == \"start\") then\n  \t\tstartIndex = 0\n  \telse\n  \t\tstartIndex = self.index(startDelimiter) + startDelimiter.length\n  \tend\n  \t\n  \tif (startIndex == nil) then\n  \t\treturn \"Start delimiter not found\"\n  \tend\n  \t\n  \tthisLength = self.length\n  \t\n  \treturnText = self[startIndex, thisLength]\n  \t  \t\n \tif (endDelimiter == \"end\") then\n  \t\tendIndex = thisLength\n  \telse\n  \t\tendIndex = returnText.index(endDelimiter)\n  \tend\n  \t\n  \tif (endIndex == nil) then\n  \t\treturn \"End delimiter not found\"\n  \tend\n  \t  \t\n  \treturnText = returnText[0, endIndex]\n  \t\n  \treturn returnText\n  \n  end\nend\n\nthisText = ARGV[0]\nstartDelimiter = ARGV[1]\nendDelimiter = ARGV[2]\n\n\n\n\n\nreturnText = thisText.textBetween(startDelimiter, endDelimiter)\n\nputs returnText\n", "target": "public class textBetween\n{\n    \n    static String textBetween(String thisText, String startString, String endString)\n    {\n    \tString returnText = \"\";\n    \tint startIndex = 0;\n    \tint endIndex = 0;\n    \t\n    \tif (startString.equals(\"start\"))\n    \t{\n    \t\tstartIndex = 0;\n    \t} else {\n\t    \tstartIndex = thisText.indexOf(startString);\n\t    \t\n\t    \tif (startIndex < 0) \n\t        {\n\t        \treturn \"\";\t        \t\n\t        } else {\n\t        \tstartIndex = startIndex + startString.length();\n\t        }\n    \t}\n        \n    \tif (endString.equals(\"end\"))\n    \t{\n    \t\tendIndex = thisText.length();\n    \t} else {\n    \t\tendIndex = thisText.indexOf(endString);\n            \n            if (endIndex <= 0) \n            {\n            \treturn \"\";\n            } else {\n\n            }\t\n    \t}\n    \t\n    \treturnText = thisText.substring(startIndex,endIndex);\n    \t\n    \treturn returnText;\n    } \n\n    \n    public static void main(String[] args)\n    {\n    \tString thisText = args[0];\n    \tString startDelimiter = args[1];\n    \tString endDelimiter = args[2];\n    \t\n    \tString returnText = \"\";\n    \treturnText = textBetween(thisText, startDelimiter, endDelimiter);\n    \t\n        System.out.println(returnText);\n\n    } \n    \n} \n"}
{"id": 354213, "name": "Two identical strings", "source": "Translate Ruby to Java: (0..1000).each do |i|\n  bin = i.to_s(2)\n  if bin.size.even?\n    half = bin.size // 2\n    if bin[0..half-1] == bin[half..]\n      print \"%3d: %10s\\n\" % [i, bin]\n    end\n  end\nend\n", "target": "public class TwoIdenticalStrings {\n    public static void main(String[] args) {\n        System.out.println(\"Decimal Binary\");\n        for (int i = 0; i < 1_000; i++) {\n            String binStr = Integer.toBinaryString(i);\n            if (binStr.length() % 2 == 0) {\n                int len = binStr.length() / 2;\n                if (binStr.substring(0, len).equals(binStr.substring(len))) {\n                    System.out.printf(\"%7d %s%n\", i, binStr);\n                }\n            }\n        }\n    }\n}\n"}
{"id": 354214, "name": "Pentagram", "source": "Translate Ruby to Java: func pentagram(dim=200, sides=5) {\n    var pentagram = <<-EOT\n    <?xml version=\"1.0\" standalone=\"no\"\u00a0?>\n    <!DOCTYPE svg PUBLIC \"-//W3C//DTD SVG 1.0//EN\"\n    \"http://www.w3.org/TR/2001/PR-SVG-20010719/DTD/svg10.dtd\">\n    <svg height=\"\n    <rect height=\"100%\" width=\"100%\" style=\"fill:black;\" />\n    EOT\n\n    func cis(x) {\n        cos(x) + sin(x).i\n    }\n\n    func pline(q) {\n        <<-EOT\n        <polyline points=\"\n        style=\"fill:blue; stroke:white; stroke-width:3;\"\n        transform=\"translate(\n        EOT\n    }\n\n    var v = sides.range.map {|k| 0.9 * dim * cis(k * Num.tau / sides) }\n    pentagram += pline([v[range(0, v.end, 2)], v[range(1, v.end, 2)]].map{.reals})\n    pentagram += '</svg>'\n\n    return pentagram\n}\n\nsay pentagram()\n", "target": "import java.awt.*;\nimport java.awt.geom.Path2D;\nimport javax.swing.*;\n\npublic class Pentagram extends JPanel {\n\n    final double degrees144 = Math.toRadians(144);\n\n    public Pentagram() {\n        setPreferredSize(new Dimension(640, 640));\n        setBackground(Color.white);\n    }\n\n    private void drawPentagram(Graphics2D g, int len, int x, int y,\n            Color fill, Color stroke) {\n        double angle = 0;\n\n        Path2D p = new Path2D.Float();\n        p.moveTo(x, y);\n\n        for (int i = 0; i < 5; i++) {\n            int x2 = x + (int) (Math.cos(angle) * len);\n            int y2 = y + (int) (Math.sin(-angle) * len);\n            p.lineTo(x2, y2);\n            x = x2;\n            y = y2;\n            angle -= degrees144;\n        }\n        p.closePath();\n\n        g.setColor(fill);\n        g.fill(p);\n\n        g.setColor(stroke);\n        g.draw(p);\n    }\n\n    @Override\n    public void paintComponent(Graphics gg) {\n        super.paintComponent(gg);\n        Graphics2D g = (Graphics2D) gg;\n\n        g.setRenderingHint(RenderingHints.KEY_ANTIALIASING,\n                RenderingHints.VALUE_ANTIALIAS_ON);\n\n        g.setStroke(new BasicStroke(5, BasicStroke.CAP_ROUND, 0));\n\n        drawPentagram(g, 500, 70, 250, new Color(0x6495ED), Color.darkGray);\n    }\n\n    public static void main(String[] args) {\n        SwingUtilities.invokeLater(() -> {\n            JFrame f = new JFrame();\n            f.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n            f.setTitle(\"Pentagram\");\n            f.setResizable(false);\n            f.add(new Pentagram(), BorderLayout.CENTER);\n            f.pack();\n            f.setLocationRelativeTo(null);\n            f.setVisible(true);\n        });\n    }\n}\n"}
{"id": 354215, "name": "Pentagram", "source": "Translate Ruby to Java: func pentagram(dim=200, sides=5) {\n    var pentagram = <<-EOT\n    <?xml version=\"1.0\" standalone=\"no\"\u00a0?>\n    <!DOCTYPE svg PUBLIC \"-//W3C//DTD SVG 1.0//EN\"\n    \"http://www.w3.org/TR/2001/PR-SVG-20010719/DTD/svg10.dtd\">\n    <svg height=\"\n    <rect height=\"100%\" width=\"100%\" style=\"fill:black;\" />\n    EOT\n\n    func cis(x) {\n        cos(x) + sin(x).i\n    }\n\n    func pline(q) {\n        <<-EOT\n        <polyline points=\"\n        style=\"fill:blue; stroke:white; stroke-width:3;\"\n        transform=\"translate(\n        EOT\n    }\n\n    var v = sides.range.map {|k| 0.9 * dim * cis(k * Num.tau / sides) }\n    pentagram += pline([v[range(0, v.end, 2)], v[range(1, v.end, 2)]].map{.reals})\n    pentagram += '</svg>'\n\n    return pentagram\n}\n\nsay pentagram()\n", "target": "import java.awt.*;\nimport java.awt.geom.Path2D;\nimport javax.swing.*;\n\npublic class Pentagram extends JPanel {\n\n    final double degrees144 = Math.toRadians(144);\n\n    public Pentagram() {\n        setPreferredSize(new Dimension(640, 640));\n        setBackground(Color.white);\n    }\n\n    private void drawPentagram(Graphics2D g, int len, int x, int y,\n            Color fill, Color stroke) {\n        double angle = 0;\n\n        Path2D p = new Path2D.Float();\n        p.moveTo(x, y);\n\n        for (int i = 0; i < 5; i++) {\n            int x2 = x + (int) (Math.cos(angle) * len);\n            int y2 = y + (int) (Math.sin(-angle) * len);\n            p.lineTo(x2, y2);\n            x = x2;\n            y = y2;\n            angle -= degrees144;\n        }\n        p.closePath();\n\n        g.setColor(fill);\n        g.fill(p);\n\n        g.setColor(stroke);\n        g.draw(p);\n    }\n\n    @Override\n    public void paintComponent(Graphics gg) {\n        super.paintComponent(gg);\n        Graphics2D g = (Graphics2D) gg;\n\n        g.setRenderingHint(RenderingHints.KEY_ANTIALIASING,\n                RenderingHints.VALUE_ANTIALIAS_ON);\n\n        g.setStroke(new BasicStroke(5, BasicStroke.CAP_ROUND, 0));\n\n        drawPentagram(g, 500, 70, 250, new Color(0x6495ED), Color.darkGray);\n    }\n\n    public static void main(String[] args) {\n        SwingUtilities.invokeLater(() -> {\n            JFrame f = new JFrame();\n            f.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n            f.setTitle(\"Pentagram\");\n            f.setResizable(false);\n            f.add(new Pentagram(), BorderLayout.CENTER);\n            f.pack();\n            f.setLocationRelativeTo(null);\n            f.setVisible(true);\n        });\n    }\n}\n"}
{"id": 354216, "name": "Verify distribution uniformity_Chi-squared test", "source": "Translate Ruby to Java: def gammaInc_Q(a, x)\n  a1, a2 = a-1, a-2\n  f0  = lambda {|t| t**a1 * Math.exp(-t)}\n  df0 = lambda {|t| (a1-t) * t**a2 * Math.exp(-t)}\n  \n  y = a1\n  y += 0.3  while f0[y]*(x-y) > 2.0e-8 and y < x\n  y = x  if y > x\n  \n  h = 3.0e-4\n  n = (y/h).to_i\n  h = y/n\n  hh = 0.5 * h\n  sum = 0\n  (n-1).step(0, -1) do |j|\n    t = h * j\n    sum += f0[t] + hh * df0[t]\n  end\n  h * sum / gamma_spounge(a)\nend\n\nA = 12\nk1_factrl = 1.0\ncoef = [Math.sqrt(2.0*Math::PI)]\nCOEF = (1...A).each_with_object(coef) do |k,c|\n  c << Math.exp(A-k) * (A-k)**(k-0.5) / k1_factrl\n  k1_factrl *= -k\nend\n\ndef gamma_spounge(z)\n  accm = (1...A).inject(COEF[0]){|res,k| res += COEF[k] / (z+k)}\n  accm * Math.exp(-(z+A)) * (z+A)**(z+0.5) / z\nend\n\ndef chi2UniformDistance(dataSet)\n  expected = dataSet.inject(:+).to_f / dataSet.size\n  dataSet.map{|d|(d-expected)**2}.inject(:+) / expected\nend\n\ndef chi2Probability(dof, distance)\n  1.0 - gammaInc_Q(0.5*dof, 0.5*distance)\nend\n\ndef chi2IsUniform(dataSet, significance=0.05)\n  dof = dataSet.size - 1\n  dist = chi2UniformDistance(dataSet)\n  chi2Probability(dof, dist) > significance\nend\n\ndsets = [ [ 199809, 200665, 199607, 200270, 199649 ],\n          [ 522573, 244456, 139979,  71531,  21461 ] ]\n\nfor ds in dsets\n  puts \"Data set:\n  dof = ds.size - 1\n  puts \"  degrees of freedom: %d\" % dof\n  distance = chi2UniformDistance(ds)\n  puts \"  distance:          \u00a0%.4f\" % distance\n  puts \"  probability:       \u00a0%.4f\" % chi2Probability(dof, distance)\n  puts \"  uniform?            %s\" % (chi2IsUniform(ds) ? \"Yes\" : \"No\")\nend\n", "target": "import static java.lang.Math.pow;\nimport java.util.Arrays;\nimport static java.util.Arrays.stream;\nimport org.apache.commons.math3.special.Gamma;\n\npublic class Test {\n\n    static double x2Dist(double[] data) {\n        double avg = stream(data).sum() / data.length;\n        double sqs = stream(data).reduce(0, (a, b) -> a + pow((b - avg), 2));\n        return sqs / avg;\n    }\n\n    static double x2Prob(double dof, double distance) {\n        return Gamma.regularizedGammaQ(dof / 2, distance / 2);\n    }\n\n    static boolean x2IsUniform(double[] data, double significance) {\n        return x2Prob(data.length - 1.0, x2Dist(data)) > significance;\n    }\n\n    public static void main(String[] a) {\n        double[][] dataSets = {{199809, 200665, 199607, 200270, 199649},\n        {522573, 244456, 139979, 71531, 21461}};\n\n        System.out.printf(\" %4s %12s  %12s %8s   %s%n\",\n                \"dof\", \"distance\", \"probability\", \"Uniform?\", \"dataset\");\n\n        for (double[] ds : dataSets) {\n            int dof = ds.length - 1;\n            double dist = x2Dist(ds);\n            double prob = x2Prob(dof, dist);\n            System.out.printf(\"%4d %12.3f  %12.8f    %5s    %6s%n\",\n                    dof, dist, prob, x2IsUniform(ds, 0.05) ? \"YES\" : \"NO\",\n                    Arrays.toString(ds));\n        }\n    }\n}\n"}
{"id": 354217, "name": "CSV to HTML translation", "source": "Translate Ruby to Java: require 'cgi'\n\nputs '<table summary=\"csv2html program output\">'\n\ndef row2html str, wrap = \"td\"\n  \"<tr>\" +\n    str.split(\",\").map { |cell| \"<\n  \"</tr>\"\nend\n\nputs row2html gets.chomp, \"th\" if ARGV.delete \"header\"\n\nwhile str = gets\n  puts row2html str.chomp\nend\n\nputs \"</table>\"\n", "target": "\n\ngrammar csv2html;\ndialog : {System.out.println(\"<HTML><Table>\");}header body+{System.out.println(\"</Table></HTML>\");} ;\nheader : {System.out.println(\"<THEAD align=\\\"center\\\"><TR bgcolor=\\\"blue\\\">\");}row{System.out.println(\"</TR></THEAD\");};\nbody   : {System.out.println(\"<TBODY><TR>\");}row{System.out.println(\"</TR></TBODY\");};\nrow    : field ',' field '\\r'? '\\n';\nfield  : Field{System.out.println(\"<TD>\" + $Field.text.replace(\"<\",\"&lt;\").replace(\">\",\"&gt;\") + \"</TD>\");};\nField  : ~[,\\n\\r]+;\n"}
{"id": 354218, "name": "CSV to HTML translation", "source": "Translate Ruby to Java: require 'cgi'\n\nputs '<table summary=\"csv2html program output\">'\n\ndef row2html str, wrap = \"td\"\n  \"<tr>\" +\n    str.split(\",\").map { |cell| \"<\n  \"</tr>\"\nend\n\nputs row2html gets.chomp, \"th\" if ARGV.delete \"header\"\n\nwhile str = gets\n  puts row2html str.chomp\nend\n\nputs \"</table>\"\n", "target": "\n\ngrammar csv2html;\ndialog : {System.out.println(\"<HTML><Table>\");}header body+{System.out.println(\"</Table></HTML>\");} ;\nheader : {System.out.println(\"<THEAD align=\\\"center\\\"><TR bgcolor=\\\"blue\\\">\");}row{System.out.println(\"</TR></THEAD\");};\nbody   : {System.out.println(\"<TBODY><TR>\");}row{System.out.println(\"</TR></TBODY\");};\nrow    : field ',' field '\\r'? '\\n';\nfield  : Field{System.out.println(\"<TD>\" + $Field.text.replace(\"<\",\"&lt;\").replace(\">\",\"&gt;\") + \"</TD>\");};\nField  : ~[,\\n\\r]+;\n"}
{"id": 354219, "name": "Alternade words", "source": "Translate Ruby to Java: words = File.open(\"unixdict.txt\").map(&:chomp)\n\nres = words.filter_map do |word|\n  next if word.size < 6\n  splitted = word.each_char.partition.with_index{|_,i| i.even? }.map(&:join)\n  next unless splitted.all?{|split| words.bsearch{|w| split <=> w} }\n  \"\nend\n\nputs res\n", "target": "import java.io.*;\nimport java.util.*;\n\npublic class AlternadeWords {\n    public static void main(String[] args) {\n        try {\n            Set<String> dictionary = new TreeSet<>();\n            try (BufferedReader reader = new BufferedReader(new FileReader(\"unixdict.txt\"))) {\n                String line;\n                while ((line = reader.readLine()) != null)\n                    dictionary.add(line);\n            }\n            StringBuilder word1 = new StringBuilder();\n            StringBuilder word2 = new StringBuilder();\n            for (String word : dictionary) {\n                int length = word.length();\n                if (length < 6)\n                    continue;\n                word1.setLength(0);\n                word2.setLength(0);\n                for (int i = 0; i < length; i += 2) {\n                    word1.append(word.charAt(i));\n                    if (i + 1 < length)\n                        word2.append(word.charAt(i + 1));\n                }\n                String w1 = word1.toString();\n                String w2 = word2.toString();\n                if (dictionary.contains(w1) && dictionary.contains(w2))\n                    System.out.printf(\"%-10s%-6s%s\\n\", word, w1, w2);\n            }\n        } catch (Exception e)  {\n            e.printStackTrace();\n        }\n    }\n}\n"}
{"id": 354220, "name": "Alternade words", "source": "Translate Ruby to Java: words = File.open(\"unixdict.txt\").map(&:chomp)\n\nres = words.filter_map do |word|\n  next if word.size < 6\n  splitted = word.each_char.partition.with_index{|_,i| i.even? }.map(&:join)\n  next unless splitted.all?{|split| words.bsearch{|w| split <=> w} }\n  \"\nend\n\nputs res\n", "target": "import java.io.*;\nimport java.util.*;\n\npublic class AlternadeWords {\n    public static void main(String[] args) {\n        try {\n            Set<String> dictionary = new TreeSet<>();\n            try (BufferedReader reader = new BufferedReader(new FileReader(\"unixdict.txt\"))) {\n                String line;\n                while ((line = reader.readLine()) != null)\n                    dictionary.add(line);\n            }\n            StringBuilder word1 = new StringBuilder();\n            StringBuilder word2 = new StringBuilder();\n            for (String word : dictionary) {\n                int length = word.length();\n                if (length < 6)\n                    continue;\n                word1.setLength(0);\n                word2.setLength(0);\n                for (int i = 0; i < length; i += 2) {\n                    word1.append(word.charAt(i));\n                    if (i + 1 < length)\n                        word2.append(word.charAt(i + 1));\n                }\n                String w1 = word1.toString();\n                String w2 = word2.toString();\n                if (dictionary.contains(w1) && dictionary.contains(w2))\n                    System.out.printf(\"%-10s%-6s%s\\n\", word, w1, w2);\n            }\n        } catch (Exception e)  {\n            e.printStackTrace();\n        }\n    }\n}\n"}
{"id": 354221, "name": "Pythagorean triples", "source": "Translate Ruby to Java: class PythagoranTriplesCounter\n  def initialize(limit = 0)\n    @limit = limit\n    @total = 0\n    @primitives = 0\n    generate_triples(3, 4, 5)\n  end\n\n  def total; @total end\n  def primitives; @primitives end\n \n  private def generate_triples(a, b, c)\n    perim = a + b + c\n    return if perim > @limit\n \n    @primitives += 1\n    @total += @limit // perim\n \n    generate_triples( a-2*b+2*c, 2*a-b+2*c, 2*a-2*b+3*c )\n    generate_triples( a+2*b+2*c, 2*a+b+2*c, 2*a+2*b+3*c )\n    generate_triples(-a+2*b+2*c,-2*a+b+2*c,-2*a+2*b+3*c )\n  end\nend\n \nperim = 10\nwhile perim <= 100_000_000 \n  c = PythagoranTriplesCounter.new perim\n  p [perim, c.total, c.primitives]\n  perim *= 10\nend\n", "target": "import java.math.BigInteger;\nimport static java.math.BigInteger.ONE;\n\npublic class PythTrip{\n\n    public static void main(String[] args){\n        long tripCount = 0, primCount = 0;\n\n        \n        BigInteger periLimit = BigInteger.valueOf(100),\n                peri2 = periLimit.divide(BigInteger.valueOf(2)),\n                peri3 = periLimit.divide(BigInteger.valueOf(3));\n\n        for(BigInteger a = ONE; a.compareTo(peri3) < 0; a = a.add(ONE)){\n            BigInteger aa = a.multiply(a);\n            \n            for(BigInteger b = a.add(ONE);\n                    b.compareTo(peri2) < 0; b = b.add(ONE)){\n                BigInteger bb = b.multiply(b);\n                BigInteger ab = a.add(b);\n                BigInteger aabb = aa.add(bb);\n                \n                for(BigInteger c = b.add(ONE);\n                        c.compareTo(peri2) < 0; c = c.add(ONE)){\n\n                    int compare = aabb.compareTo(c.multiply(c));\n                    \n                    if(ab.add(c).compareTo(periLimit) > 0){\n                        break;\n                    }\n                    \n                    if(compare < 0){\n                        break;\n                    }else if (compare == 0){\n                        tripCount++;\n                        System.out.print(a + \", \" + b + \", \" + c);\n\n                        \n                        if(a.gcd(b).equals(ONE)){\n                            System.out.print(\" primitive\");\n                            primCount++;\n                        }\n                        System.out.println();\n                    }\n                }\n            }\n        }\n        System.out.println(\"Up to a perimeter of \" + periLimit + \", there are \"\n                + tripCount + \" triples, of which \" + primCount + \" are primitive.\");\n    }\n}\n"}
{"id": 354222, "name": "Pythagorean triples", "source": "Translate Ruby to Java: class PythagoranTriplesCounter\n  def initialize(limit = 0)\n    @limit = limit\n    @total = 0\n    @primitives = 0\n    generate_triples(3, 4, 5)\n  end\n\n  def total; @total end\n  def primitives; @primitives end\n \n  private def generate_triples(a, b, c)\n    perim = a + b + c\n    return if perim > @limit\n \n    @primitives += 1\n    @total += @limit // perim\n \n    generate_triples( a-2*b+2*c, 2*a-b+2*c, 2*a-2*b+3*c )\n    generate_triples( a+2*b+2*c, 2*a+b+2*c, 2*a+2*b+3*c )\n    generate_triples(-a+2*b+2*c,-2*a+b+2*c,-2*a+2*b+3*c )\n  end\nend\n \nperim = 10\nwhile perim <= 100_000_000 \n  c = PythagoranTriplesCounter.new perim\n  p [perim, c.total, c.primitives]\n  perim *= 10\nend\n", "target": "import java.math.BigInteger;\nimport static java.math.BigInteger.ONE;\n\npublic class PythTrip{\n\n    public static void main(String[] args){\n        long tripCount = 0, primCount = 0;\n\n        \n        BigInteger periLimit = BigInteger.valueOf(100),\n                peri2 = periLimit.divide(BigInteger.valueOf(2)),\n                peri3 = periLimit.divide(BigInteger.valueOf(3));\n\n        for(BigInteger a = ONE; a.compareTo(peri3) < 0; a = a.add(ONE)){\n            BigInteger aa = a.multiply(a);\n            \n            for(BigInteger b = a.add(ONE);\n                    b.compareTo(peri2) < 0; b = b.add(ONE)){\n                BigInteger bb = b.multiply(b);\n                BigInteger ab = a.add(b);\n                BigInteger aabb = aa.add(bb);\n                \n                for(BigInteger c = b.add(ONE);\n                        c.compareTo(peri2) < 0; c = c.add(ONE)){\n\n                    int compare = aabb.compareTo(c.multiply(c));\n                    \n                    if(ab.add(c).compareTo(periLimit) > 0){\n                        break;\n                    }\n                    \n                    if(compare < 0){\n                        break;\n                    }else if (compare == 0){\n                        tripCount++;\n                        System.out.print(a + \", \" + b + \", \" + c);\n\n                        \n                        if(a.gcd(b).equals(ONE)){\n                            System.out.print(\" primitive\");\n                            primCount++;\n                        }\n                        System.out.println();\n                    }\n                }\n            }\n        }\n        System.out.println(\"Up to a perimeter of \" + periLimit + \", there are \"\n                + tripCount + \" triples, of which \" + primCount + \" are primitive.\");\n    }\n}\n"}
{"id": 354223, "name": "Call a foreign-language function", "source": "Translate Ruby to Java: @[Link(\"c\")] \nlib LibC\n  fun free(ptr : Void*) : Void \n  fun strdup(ptr : Char*) : Char*\nend\n\ns1 = \"Hello World!\"\np = LibC.strdup(s1) \ns2 = String.new(p)\nLibC.free p \n\nputs s2\n", "target": "public class JNIDemo\n{\n  static\n  {  System.loadLibrary(\"JNIDemo\");  }\n  \n  public static void main(String[] args)\n  {\n    System.out.println(callStrdup(\"Hello World!\"));\n  }\n  \n  private static native String callStrdup(String s);\n}\n"}
{"id": 354224, "name": "Yellowstone sequence", "source": "Translate Ruby to Java: def yellow(n)\n  a = [1, 2, 3]\n  b = { 1 => true, 2 => true, 3 => true }\n  i = 4\n  while n > a.length\n    if !b[i] && i.gcd(a[-1]) == 1 && i.gcd(a[-2]) > 1\n      a << i\n      b[i] = true\n      i = 4\n    end\n    i += 1\n  end\n  a\nend\n\np yellow(30)\n", "target": "import java.util.ArrayList;\nimport java.util.List;\n\npublic class YellowstoneSequence {\n\n    public static void main(String[] args) {\n         System.out.printf(\"First 30 values in the yellowstone sequence:%n%s%n\", yellowstoneSequence(30));\n    }\n\n    private static List<Integer> yellowstoneSequence(int sequenceCount) {\n        List<Integer> yellowstoneList = new ArrayList<Integer>();\n        yellowstoneList.add(1);\n        yellowstoneList.add(2);\n        yellowstoneList.add(3);\n        int num = 4;\n        List<Integer> notYellowstoneList = new ArrayList<Integer>();\n        int yellowSize = 3;\n        while ( yellowSize < sequenceCount ) {\n            int found = -1;\n            for ( int index = 0 ; index < notYellowstoneList.size() ; index++ ) {\n                int test = notYellowstoneList.get(index);\n                if ( gcd(yellowstoneList.get(yellowSize-2), test) > 1 && gcd(yellowstoneList.get(yellowSize-1), test) == 1 ) {\n                    found = index;\n                    break;\n                }\n            }\n            if ( found >= 0 ) {\n                yellowstoneList.add(notYellowstoneList.remove(found));\n                yellowSize++;\n            }\n            else {\n                while ( true ) {\n                    if ( gcd(yellowstoneList.get(yellowSize-2), num) > 1 && gcd(yellowstoneList.get(yellowSize-1), num) == 1 ) {\n                        yellowstoneList.add(num);\n                        yellowSize++;\n                        num++;\n                        break;\n                    }\n                    notYellowstoneList.add(num);\n                    num++;\n                }\n            }\n        }\n        return yellowstoneList;\n    }\n        \n    private static final int gcd(int a, int b) {\n        if ( b == 0 ) {\n            return a;\n        }\n        return gcd(b, a%b);\n    }\n\n}\n"}
{"id": 354225, "name": "Yellowstone sequence", "source": "Translate Ruby to Java: def yellow(n)\n  a = [1, 2, 3]\n  b = { 1 => true, 2 => true, 3 => true }\n  i = 4\n  while n > a.length\n    if !b[i] && i.gcd(a[-1]) == 1 && i.gcd(a[-2]) > 1\n      a << i\n      b[i] = true\n      i = 4\n    end\n    i += 1\n  end\n  a\nend\n\np yellow(30)\n", "target": "import java.util.ArrayList;\nimport java.util.List;\n\npublic class YellowstoneSequence {\n\n    public static void main(String[] args) {\n         System.out.printf(\"First 30 values in the yellowstone sequence:%n%s%n\", yellowstoneSequence(30));\n    }\n\n    private static List<Integer> yellowstoneSequence(int sequenceCount) {\n        List<Integer> yellowstoneList = new ArrayList<Integer>();\n        yellowstoneList.add(1);\n        yellowstoneList.add(2);\n        yellowstoneList.add(3);\n        int num = 4;\n        List<Integer> notYellowstoneList = new ArrayList<Integer>();\n        int yellowSize = 3;\n        while ( yellowSize < sequenceCount ) {\n            int found = -1;\n            for ( int index = 0 ; index < notYellowstoneList.size() ; index++ ) {\n                int test = notYellowstoneList.get(index);\n                if ( gcd(yellowstoneList.get(yellowSize-2), test) > 1 && gcd(yellowstoneList.get(yellowSize-1), test) == 1 ) {\n                    found = index;\n                    break;\n                }\n            }\n            if ( found >= 0 ) {\n                yellowstoneList.add(notYellowstoneList.remove(found));\n                yellowSize++;\n            }\n            else {\n                while ( true ) {\n                    if ( gcd(yellowstoneList.get(yellowSize-2), num) > 1 && gcd(yellowstoneList.get(yellowSize-1), num) == 1 ) {\n                        yellowstoneList.add(num);\n                        yellowSize++;\n                        num++;\n                        break;\n                    }\n                    notYellowstoneList.add(num);\n                    num++;\n                }\n            }\n        }\n        return yellowstoneList;\n    }\n        \n    private static final int gcd(int a, int b) {\n        if ( b == 0 ) {\n            return a;\n        }\n        return gcd(b, a%b);\n    }\n\n}\n"}
{"id": 354226, "name": "Extensible prime generator", "source": "Translate Ruby to Java: require \"prime\"\n\nputs Prime.take(20).join(\", \")\nputs Prime.each(150).drop_while{|pr| pr < 100}.join(\", \")\nputs Prime.each(8000).drop_while{|pr| pr < 7700}.count\nputs Prime.take(10_000).last\n", "target": "import java.util.*;\n\npublic class PrimeGenerator {\n    private int limit_;\n    private int index_ = 0;\n    private int increment_;\n    private int count_ = 0;\n    private List<Integer> primes_ = new ArrayList<>();\n    private BitSet sieve_ = new BitSet();\n    private int sieveLimit_ = 0;\n\n    public PrimeGenerator(int initialLimit, int increment) {\n        limit_ = nextOddNumber(initialLimit);\n        increment_ = increment;\n        primes_.add(2);\n        findPrimes(3);\n    }\n\n    public int nextPrime() {\n        if (index_ == primes_.size()) {\n            if (Integer.MAX_VALUE - increment_ < limit_)\n                return 0;\n            int start = limit_ + 2;\n            limit_ = nextOddNumber(limit_ + increment_);\n            primes_.clear();\n            findPrimes(start);\n        }\n        ++count_;\n        return primes_.get(index_++);\n    }\n\n    public int count() {\n        return count_;\n    }\n\n    private void findPrimes(int start) {\n        index_ = 0;\n        int newLimit = sqrt(limit_);\n        for (int p = 3; p * p <= newLimit; p += 2) {\n            if (sieve_.get(p/2 - 1))\n                continue;\n            int q = p * Math.max(p, nextOddNumber((sieveLimit_ + p - 1)/p));\n            for (; q <= newLimit; q += 2*p)\n                sieve_.set(q/2 - 1, true);\n        }\n        sieveLimit_ = newLimit;\n        int count = (limit_ - start)/2 + 1;\n        BitSet composite = new BitSet(count);\n        for (int p = 3; p <= newLimit; p += 2) {\n            if (sieve_.get(p/2 - 1))\n                continue;\n            int q = p * Math.max(p, nextOddNumber((start + p - 1)/p)) - start;\n            q /= 2;\n            for (; q >= 0 && q < count; q += p)\n                composite.set(q, true);\n        }\n        for (int p = 0; p < count; ++p) {\n            if (!composite.get(p))\n                primes_.add(p * 2 + start);\n        }\n    }\n\n    private static int sqrt(int n) {\n        return nextOddNumber((int)Math.sqrt(n));\n    }\n\n    private static int nextOddNumber(int n) {\n        return 1 + 2 * (n/2);\n    }\n\n    public static void main(String[] args) {\n        PrimeGenerator pgen = new PrimeGenerator(20, 200000);\n        System.out.println(\"First 20 primes:\");\n        for (int i = 0; i < 20; ++i) {\n            if (i > 0)\n                System.out.print(\", \");\n            System.out.print(pgen.nextPrime());\n        }\n        System.out.println();\n        System.out.println(\"Primes between 100 and 150:\");\n        for (int i = 0; ; ) {\n            int prime = pgen.nextPrime();\n            if (prime > 150)\n                break;\n            if (prime >= 100) {\n                if (i++ != 0)\n                    System.out.print(\", \");\n                System.out.print(prime);\n            }\n        }\n        System.out.println();\n        int count = 0;\n        for (;;) {\n            int prime = pgen.nextPrime();\n            if (prime > 8000)\n                break;\n            if (prime >= 7700)\n                ++count;\n        }\n        System.out.println(\"Number of primes between 7700 and 8000: \" + count);\n        int n = 10000;\n        for (;;) {\n            int prime = pgen.nextPrime();\n            if (prime == 0) {\n                System.out.println(\"Can't generate any more primes.\");\n                break;\n            }\n            if (pgen.count() == n) {\n                System.out.println(n + \"th prime: \" + prime);\n                n *= 10;\n            }\n        }\n    }\n}\n"}
{"id": 354227, "name": "Flipping bits game", "source": "Translate Ruby to Java: class FlipBoard\n  def initialize(size)\n    raise ArgumentError.new(\"Invalid board size: \n    \n    @size = size\n    @board = Array.new(size**2, 0)\n    \n    randomize_board\n    loop do\n      @target = generate_target\n      break unless solved?\n    end \n    \n    \n    @columns = [*'a'...('a'.ord+@size).chr]\n    @rows = (1..@size).map(&:to_s)\n  end\n  \n  \n  \n  def play\n    moves = 0\n    puts \"your target:\", target\n    \n    until solved? \n      puts \"\", \"move \n      print \"Row/column to flip: \"\n      ans = $stdin.gets.strip\n      \n      if @columns.include? ans\n        flip_column @columns.index(ans)\n        moves += 1\n      elsif @rows.include? ans\n        flip_row @rows.index(ans)\n        moves += 1\n      else\n        puts \"invalid input: \" + ans\n      end\n    end\n    \n    puts \"\", \"you solved the game in \n  end\n  \n  \n  def target\n    format_array @target\n  end\n  \n  \n  def to_s\n    format_array @board\n  end\n  \n  \n  private\n  \n  def solved?\n    @board == @target\n  end\n  \n  \n  def randomize_board\n    (@size + rand(@size)).times do\n      flip_bit rand(@size), rand(@size)\n    end\n  end\n  \n  \n  def generate_target\n    orig_board = @board.clone\n    (@size + rand(@size)).times do \n      rand(2).zero? ? flip_row( rand(@size) ) : flip_column( rand(@size) )\n    end\n    target, @board = @board, orig_board\n    target\n  end\n  \n  def flip_row(row)\n    @size.times {|col| flip_bit(row, col)}\n  end\n  \n  def flip_column(col)\n    @size.times {|row| flip_bit(row, col)}\n  end\n  \n  def flip_bit(row, col)\n    @board[@size * row + col] ^= 1\n  end\n  \n  def format_array(ary)\n    str = \"   \" + @columns.join(\" \") + \"\\n\"\n    @size.times do |row|\n      str << \"%2s \" % @rows[row] + ary[@size*row, @size].join(\" \") + \"\\n\"\n    end\n    str\n  end\nend\n\n\nbegin\n  FlipBoard.new(ARGV.shift.to_i).play\nrescue => e\n  puts e.message\nend\n", "target": "import java.awt.*;\nimport java.awt.event.*;\nimport java.util.*;\nimport javax.swing.*;\n\npublic class FlippingBitsGame extends JPanel {\n    final int maxLevel = 7;\n    final int minLevel = 3;\n\n    private Random rand = new Random();\n    private int[][] grid, target;\n    private Rectangle box;\n    private int n = maxLevel;\n    private boolean solved = true;\n\n    FlippingBitsGame() {\n        setPreferredSize(new Dimension(640, 640));\n        setBackground(Color.white);\n        setFont(new Font(\"SansSerif\", Font.PLAIN, 18));\n\n        box = new Rectangle(120, 90, 400, 400);\n\n        startNewGame();\n\n        addMouseListener(new MouseAdapter() {\n            @Override\n            public void mousePressed(MouseEvent e) {\n                if (solved) {\n                    startNewGame();\n                } else {\n                    int x = e.getX();\n                    int y = e.getY();\n\n                    if (box.contains(x, y))\n                        return;\n\n                    if (x > box.x && x < box.x + box.width) {\n                        flipCol((x - box.x) / (box.width / n));\n\n                    } else if (y > box.y && y < box.y + box.height)\n                        flipRow((y - box.y) / (box.height / n));\n\n                    if (solved(grid, target))\n                        solved = true;\n\n                    printGrid(solved ? \"Solved!\" : \"The board\", grid);\n                }\n                repaint();\n            }\n        });\n    }\n\n    void startNewGame() {\n        if (solved) {\n\n            n = (n == maxLevel) ? minLevel : n + 1;\n\n            grid = new int[n][n];\n            target = new int[n][n];\n\n            do {\n                shuffle();\n\n                for (int i = 0; i < n; i++)\n                    target[i] = Arrays.copyOf(grid[i], n);\n\n                shuffle();\n\n            } while (solved(grid, target));\n\n            solved = false;\n            printGrid(\"The target\", target);\n            printGrid(\"The board\", grid);\n        }\n    }\n\n    void printGrid(String msg, int[][] g) {\n        System.out.println(msg);\n        for (int[] row : g)\n            System.out.println(Arrays.toString(row));\n        System.out.println();\n    }\n\n    boolean solved(int[][] a, int[][] b) {\n        for (int i = 0; i < n; i++)\n            if (!Arrays.equals(a[i], b[i]))\n                return false;\n        return true;\n    }\n\n    void shuffle() {\n        for (int i = 0; i < n * n; i++) {\n            if (rand.nextBoolean())\n                flipRow(rand.nextInt(n));\n            else\n                flipCol(rand.nextInt(n));\n        }\n    }\n\n    void flipRow(int r) {\n        for (int c = 0; c < n; c++) {\n            grid[r][c] ^= 1;\n        }\n    }\n\n    void flipCol(int c) {\n        for (int[] row : grid) {\n            row[c] ^= 1;\n        }\n    }\n\n    void drawGrid(Graphics2D g) {\n        g.setColor(getForeground());\n\n        if (solved)\n            g.drawString(\"Solved! Click here to play again.\", 180, 600);\n        else\n            g.drawString(\"Click next to a row or a column to flip.\", 170, 600);\n\n        int size = box.width / n;\n\n        for (int r = 0; r < n; r++)\n            for (int c = 0; c < n; c++) {\n                g.setColor(grid[r][c] == 1 ? Color.blue : Color.orange);\n                g.fillRect(box.x + c * size, box.y + r * size, size, size);\n                g.setColor(getBackground());\n                g.drawRect(box.x + c * size, box.y + r * size, size, size);\n                g.setColor(target[r][c] == 1 ? Color.blue : Color.orange);\n                g.fillRect(7 + box.x + c * size, 7 + box.y + r * size, 10, 10);\n            }\n    }\n\n    @Override\n    public void paintComponent(Graphics gg) {\n        super.paintComponent(gg);\n        Graphics2D g = (Graphics2D) gg;\n        g.setRenderingHint(RenderingHints.KEY_ANTIALIASING,\n                RenderingHints.VALUE_ANTIALIAS_ON);\n\n        drawGrid(g);\n    }\n\n    public static void main(String[] args) {\n        SwingUtilities.invokeLater(() -> {\n            JFrame f = new JFrame();\n            f.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n            f.setTitle(\"Flipping Bits Game\");\n            f.setResizable(false);\n            f.add(new FlippingBitsGame(), BorderLayout.CENTER);\n            f.pack();\n            f.setLocationRelativeTo(null);\n            f.setVisible(true);\n        });\n    }\n}\n"}
{"id": 354228, "name": "Flipping bits game", "source": "Translate Ruby to Java: class FlipBoard\n  def initialize(size)\n    raise ArgumentError.new(\"Invalid board size: \n    \n    @size = size\n    @board = Array.new(size**2, 0)\n    \n    randomize_board\n    loop do\n      @target = generate_target\n      break unless solved?\n    end \n    \n    \n    @columns = [*'a'...('a'.ord+@size).chr]\n    @rows = (1..@size).map(&:to_s)\n  end\n  \n  \n  \n  def play\n    moves = 0\n    puts \"your target:\", target\n    \n    until solved? \n      puts \"\", \"move \n      print \"Row/column to flip: \"\n      ans = $stdin.gets.strip\n      \n      if @columns.include? ans\n        flip_column @columns.index(ans)\n        moves += 1\n      elsif @rows.include? ans\n        flip_row @rows.index(ans)\n        moves += 1\n      else\n        puts \"invalid input: \" + ans\n      end\n    end\n    \n    puts \"\", \"you solved the game in \n  end\n  \n  \n  def target\n    format_array @target\n  end\n  \n  \n  def to_s\n    format_array @board\n  end\n  \n  \n  private\n  \n  def solved?\n    @board == @target\n  end\n  \n  \n  def randomize_board\n    (@size + rand(@size)).times do\n      flip_bit rand(@size), rand(@size)\n    end\n  end\n  \n  \n  def generate_target\n    orig_board = @board.clone\n    (@size + rand(@size)).times do \n      rand(2).zero? ? flip_row( rand(@size) ) : flip_column( rand(@size) )\n    end\n    target, @board = @board, orig_board\n    target\n  end\n  \n  def flip_row(row)\n    @size.times {|col| flip_bit(row, col)}\n  end\n  \n  def flip_column(col)\n    @size.times {|row| flip_bit(row, col)}\n  end\n  \n  def flip_bit(row, col)\n    @board[@size * row + col] ^= 1\n  end\n  \n  def format_array(ary)\n    str = \"   \" + @columns.join(\" \") + \"\\n\"\n    @size.times do |row|\n      str << \"%2s \" % @rows[row] + ary[@size*row, @size].join(\" \") + \"\\n\"\n    end\n    str\n  end\nend\n\n\nbegin\n  FlipBoard.new(ARGV.shift.to_i).play\nrescue => e\n  puts e.message\nend\n", "target": "import java.awt.*;\nimport java.awt.event.*;\nimport java.util.*;\nimport javax.swing.*;\n\npublic class FlippingBitsGame extends JPanel {\n    final int maxLevel = 7;\n    final int minLevel = 3;\n\n    private Random rand = new Random();\n    private int[][] grid, target;\n    private Rectangle box;\n    private int n = maxLevel;\n    private boolean solved = true;\n\n    FlippingBitsGame() {\n        setPreferredSize(new Dimension(640, 640));\n        setBackground(Color.white);\n        setFont(new Font(\"SansSerif\", Font.PLAIN, 18));\n\n        box = new Rectangle(120, 90, 400, 400);\n\n        startNewGame();\n\n        addMouseListener(new MouseAdapter() {\n            @Override\n            public void mousePressed(MouseEvent e) {\n                if (solved) {\n                    startNewGame();\n                } else {\n                    int x = e.getX();\n                    int y = e.getY();\n\n                    if (box.contains(x, y))\n                        return;\n\n                    if (x > box.x && x < box.x + box.width) {\n                        flipCol((x - box.x) / (box.width / n));\n\n                    } else if (y > box.y && y < box.y + box.height)\n                        flipRow((y - box.y) / (box.height / n));\n\n                    if (solved(grid, target))\n                        solved = true;\n\n                    printGrid(solved ? \"Solved!\" : \"The board\", grid);\n                }\n                repaint();\n            }\n        });\n    }\n\n    void startNewGame() {\n        if (solved) {\n\n            n = (n == maxLevel) ? minLevel : n + 1;\n\n            grid = new int[n][n];\n            target = new int[n][n];\n\n            do {\n                shuffle();\n\n                for (int i = 0; i < n; i++)\n                    target[i] = Arrays.copyOf(grid[i], n);\n\n                shuffle();\n\n            } while (solved(grid, target));\n\n            solved = false;\n            printGrid(\"The target\", target);\n            printGrid(\"The board\", grid);\n        }\n    }\n\n    void printGrid(String msg, int[][] g) {\n        System.out.println(msg);\n        for (int[] row : g)\n            System.out.println(Arrays.toString(row));\n        System.out.println();\n    }\n\n    boolean solved(int[][] a, int[][] b) {\n        for (int i = 0; i < n; i++)\n            if (!Arrays.equals(a[i], b[i]))\n                return false;\n        return true;\n    }\n\n    void shuffle() {\n        for (int i = 0; i < n * n; i++) {\n            if (rand.nextBoolean())\n                flipRow(rand.nextInt(n));\n            else\n                flipCol(rand.nextInt(n));\n        }\n    }\n\n    void flipRow(int r) {\n        for (int c = 0; c < n; c++) {\n            grid[r][c] ^= 1;\n        }\n    }\n\n    void flipCol(int c) {\n        for (int[] row : grid) {\n            row[c] ^= 1;\n        }\n    }\n\n    void drawGrid(Graphics2D g) {\n        g.setColor(getForeground());\n\n        if (solved)\n            g.drawString(\"Solved! Click here to play again.\", 180, 600);\n        else\n            g.drawString(\"Click next to a row or a column to flip.\", 170, 600);\n\n        int size = box.width / n;\n\n        for (int r = 0; r < n; r++)\n            for (int c = 0; c < n; c++) {\n                g.setColor(grid[r][c] == 1 ? Color.blue : Color.orange);\n                g.fillRect(box.x + c * size, box.y + r * size, size, size);\n                g.setColor(getBackground());\n                g.drawRect(box.x + c * size, box.y + r * size, size, size);\n                g.setColor(target[r][c] == 1 ? Color.blue : Color.orange);\n                g.fillRect(7 + box.x + c * size, 7 + box.y + r * size, 10, 10);\n            }\n    }\n\n    @Override\n    public void paintComponent(Graphics gg) {\n        super.paintComponent(gg);\n        Graphics2D g = (Graphics2D) gg;\n        g.setRenderingHint(RenderingHints.KEY_ANTIALIASING,\n                RenderingHints.VALUE_ANTIALIAS_ON);\n\n        drawGrid(g);\n    }\n\n    public static void main(String[] args) {\n        SwingUtilities.invokeLater(() -> {\n            JFrame f = new JFrame();\n            f.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n            f.setTitle(\"Flipping Bits Game\");\n            f.setResizable(false);\n            f.add(new FlippingBitsGame(), BorderLayout.CENTER);\n            f.pack();\n            f.setLocationRelativeTo(null);\n            f.setVisible(true);\n        });\n    }\n}\n"}
{"id": 354229, "name": "Gray code", "source": "Translate Ruby to Java: def gray_encode(bin)\n  bin ^ (bin >> 1)\nend\n\ndef gray_decode(gray)\n  bin = gray\n  while gray > 0\n    gray >>= 1\n    bin ^= gray\n  end\n  bin\nend\n", "target": "public class Gray {\n\tpublic static long grayEncode(long n){\n\t\treturn n ^ (n >>> 1);\n\t}\n\t\n\tpublic static long grayDecode(long n) {\n\t\tlong p = n;\n\t\twhile ((n >>>= 1) != 0)\n\t\t\tp ^= n;\n\t\treturn p;\n\t}\n\tpublic static void main(String[] args){\n\t\tSystem.out.println(\"i\\tBinary\\tGray\\tDecoded\");\n\t\tfor(int i = -1; i < 32;i++){\n\t\t\tSystem.out.print(i +\"\\t\");\n\t\t\tSystem.out.print(Integer.toBinaryString(i) + \"\\t\");\n\t\t\tSystem.out.print(Long.toBinaryString(grayEncode(i))+ \"\\t\");\n\t\t\tSystem.out.println(grayDecode(grayEncode(i)));\n\t\t}\n\t}\n}\n"}
{"id": 354230, "name": "Gray code", "source": "Translate Ruby to Java: def gray_encode(bin)\n  bin ^ (bin >> 1)\nend\n\ndef gray_decode(gray)\n  bin = gray\n  while gray > 0\n    gray >>= 1\n    bin ^= gray\n  end\n  bin\nend\n", "target": "public class Gray {\n\tpublic static long grayEncode(long n){\n\t\treturn n ^ (n >>> 1);\n\t}\n\t\n\tpublic static long grayDecode(long n) {\n\t\tlong p = n;\n\t\twhile ((n >>>= 1) != 0)\n\t\t\tp ^= n;\n\t\treturn p;\n\t}\n\tpublic static void main(String[] args){\n\t\tSystem.out.println(\"i\\tBinary\\tGray\\tDecoded\");\n\t\tfor(int i = -1; i < 32;i++){\n\t\t\tSystem.out.print(i +\"\\t\");\n\t\t\tSystem.out.print(Integer.toBinaryString(i) + \"\\t\");\n\t\t\tSystem.out.print(Long.toBinaryString(grayEncode(i))+ \"\\t\");\n\t\t\tSystem.out.println(grayDecode(grayEncode(i)));\n\t\t}\n\t}\n}\n"}
{"id": 354231, "name": "File extension is in extensions list", "source": "Translate Ruby to Java: def is_ext(filename, extensions)\n  if filename.respond_to?(:each) \n    filename.each do |fn|\n      is_ext(fn, extensions)\n    end\n  else\n    fndc = filename.downcase\n    extensions.each do |ext|\n      bool = fndc.end_with?(?. + ext.downcase)\n      puts \"%20s\u00a0: %s\" % [filename, bool] if bool\n    end\n  end\nend\n", "target": "import java.util.Arrays;\nimport java.util.Comparator;\n\npublic class FileExt{\n\tpublic static void main(String[] args){\n\t\tString[] tests = {\"text.txt\", \"text.TXT\", \"test.tar.gz\", \"test/test2.exe\", \"test\\\\test2.exe\", \"test\", \"a/b/c\\\\d/foo\"};\n\t\tString[] exts = {\".txt\",\".gz\",\"\",\".bat\"};\n\t\t\n\t\tSystem.out.println(\"Extensions: \" + Arrays.toString(exts) + \"\\n\");\n\t\t\n\t\tfor(String test:tests){\n\t\t\tSystem.out.println(test +\": \" + extIsIn(test, exts));\n\t\t}\n\t}\n\t\n\tpublic static boolean extIsIn(String test, String... exts){\n\t\tint lastSlash = Math.max(test.lastIndexOf('/'), test.lastIndexOf('\\\\')); \n\t\tString filename = test.substring(lastSlash + 1);\n\t\t\n\t\t\n\t\tint lastDot = filename.lastIndexOf('.') == -1 ? filename.length() : filename.lastIndexOf('.');\n\t\tString ext = filename.substring(lastDot);\n\t\t\n\t\tArrays.sort(exts);\n\t\t\n\t\treturn Arrays.binarySearch(exts, ext, new Comparator<String>() { \n\t\t\t@Override                                                \n\t\t\tpublic int compare(String o1, String o2) {\n\t\t\t\treturn o1.compareToIgnoreCase(o2);\n\t\t\t}\n\t\t}) >= 0;\n\t}\n}\n"}
{"id": 354232, "name": "Extreme floating point values", "source": "Translate Ruby to Java: inf = 1.0 / 0.0    \nnan = 0.0 / 0.0               \n\nexpression = [\n  \"1.0 / 0.0\", \"-1.0 / 0.0\", \"0.0 / 0.0\", \"- 0.0\",\n  \"inf + 1\", \"5 - inf\", \"inf * 5\", \"inf / 5\", \"inf * 0\",\n  \"1.0 / inf\", \"-1.0 / inf\", \"inf + inf\", \"inf - inf\",\n  \"inf * inf\", \"inf / inf\", \"inf * 0.0\", \" 0 < inf\", \"inf == inf\",\n  \"nan + 1\", \"nan * 5\", \"nan - nan\", \"nan * inf\", \"- nan\",\n  \"nan == nan\", \"nan > 0\", \"nan < 0\", \"nan == 0\", \"nan <=> 0.0\", \"0.0 == -0.0\",\n]\n\nexpression.each do |exp|\n  puts \"%15s => %p\" % [exp, eval(exp)]\nend\n", "target": "public class Extreme {\n    public static void main(String[] args) {\n        double negInf = -1.0 / 0.0; \n        double inf = 1.0 / 0.0; \n        double nan = 0.0 / 0.0; \n        double negZero = -2.0 / inf;\n\n        System.out.println(\"Negative inf: \" + negInf);\n        System.out.println(\"Positive inf: \" + inf);\n        System.out.println(\"NaN: \" + nan);\n        System.out.println(\"Negative 0: \" + negZero);\n        System.out.println(\"inf + -inf: \" + (inf + negInf));\n        System.out.println(\"0 * NaN: \" + (0 * nan));\n        System.out.println(\"NaN == NaN: \" + (nan == nan));\n    }\n}\n"}
{"id": 354233, "name": "Extreme floating point values", "source": "Translate Ruby to Java: inf = 1.0 / 0.0    \nnan = 0.0 / 0.0               \n\nexpression = [\n  \"1.0 / 0.0\", \"-1.0 / 0.0\", \"0.0 / 0.0\", \"- 0.0\",\n  \"inf + 1\", \"5 - inf\", \"inf * 5\", \"inf / 5\", \"inf * 0\",\n  \"1.0 / inf\", \"-1.0 / inf\", \"inf + inf\", \"inf - inf\",\n  \"inf * inf\", \"inf / inf\", \"inf * 0.0\", \" 0 < inf\", \"inf == inf\",\n  \"nan + 1\", \"nan * 5\", \"nan - nan\", \"nan * inf\", \"- nan\",\n  \"nan == nan\", \"nan > 0\", \"nan < 0\", \"nan == 0\", \"nan <=> 0.0\", \"0.0 == -0.0\",\n]\n\nexpression.each do |exp|\n  puts \"%15s => %p\" % [exp, eval(exp)]\nend\n", "target": "public class Extreme {\n    public static void main(String[] args) {\n        double negInf = -1.0 / 0.0; \n        double inf = 1.0 / 0.0; \n        double nan = 0.0 / 0.0; \n        double negZero = -2.0 / inf;\n\n        System.out.println(\"Negative inf: \" + negInf);\n        System.out.println(\"Positive inf: \" + inf);\n        System.out.println(\"NaN: \" + nan);\n        System.out.println(\"Negative 0: \" + negZero);\n        System.out.println(\"inf + -inf: \" + (inf + negInf));\n        System.out.println(\"0 * NaN: \" + (0 * nan));\n        System.out.println(\"NaN == NaN: \" + (nan == nan));\n    }\n}\n"}
{"id": 354234, "name": "Soundex", "source": "Translate Ruby to Java: \n\ndef get_code(c : Char)\n  case c\n  when 'B', 'F', 'P', 'V' \n    \"1\"\n  when 'C', 'G', 'J', 'K', 'Q', 'S', 'X', 'Z'\n    \"2\"\n  when 'D', 'T'\n    \"3\"\n  when 'L'\n    \"4\"\n  when 'M', 'N'\n    \"5\"\n  when 'R'\n    \"6\"\n  when 'H', 'W'\n    \"-\"\n  else \n    \"\"\n  end\nend\n\ndef soundex(s : String)\n  return \"\" if s == \"\"\n  s = s.upcase\n  result = s[0,1] \n  prev = get_code s[0]\n  s.lchop.each_char {|c|\n    curr = get_code c\n    result += curr if curr != \"\" && curr != \"-\" && curr != prev\n    prev = curr unless curr == \"-\"\n  }\n  result.ljust(4, '0')[0, 4]\nend\n\npairs = [\n          [\"Ashcraft\"  , \"A261\"],\n          [\"Ashcroft\"  , \"A261\"],\n          [\"Gauss\"     , \"G200\"],\n          [\"Ghosh\"     , \"G200\"],\n          [\"Hilbert\"   , \"H416\"],\n          [\"Heilbronn\" , \"H416\"],\n          [\"Lee\"       , \"L000\"],\n          [\"Lloyd\"     , \"L300\"],\n          [\"Moses\"     , \"M220\"],\n          [\"Pfister\"   , \"P236\"],\n          [\"Robert\"    , \"R163\"],\n          [\"Rupert\"    , \"R163\"],\n          [\"Rubin\"     , \"R150\"],\n          [\"Tymczak\"   , \"T522\"],\n          [\"Soundex\"   , \"S532\"],\n          [\"Example\"   , \"E251\"] \n        ]\n\npairs.each { |pair|\n  puts \"\n}\n", "target": "public static void main(String[] args){\n    System.out.println(soundex(\"Soundex\"));\n    System.out.println(soundex(\"Example\"));\n    System.out.println(soundex(\"Sownteks\"));\n    System.out.println(soundex(\"Ekzampul\"));\n  }\n\nprivate static String getCode(char c){\n  switch(c){\n    case 'B': case 'F': case 'P': case 'V':\n      return \"1\";\n    case 'C': case 'G': case 'J': case 'K':\n    case 'Q': case 'S': case 'X': case 'Z':\n      return \"2\";\n    case 'D': case 'T':\n      return \"3\";\n    case 'L':\n      return \"4\";\n    case 'M': case 'N':\n      return \"5\";\n    case 'R':\n      return \"6\";\n    default:\n      return \"\";\n  }\n}\n\npublic static String soundex(String s){\n  String code, previous, soundex;\n  code = s.toUpperCase().charAt(0) + \"\";\n\n  \n  previous = getCode(s.toUpperCase().charAt(0));\n\n  for(int i = 1;i < s.length();i++){\n    String current = getCode(s.toUpperCase().charAt(i));\n    if(current.length() > 0 && !current.equals(previous)){\n      code = code + current;\n    }\n    previous = current;\n  }\n  soundex = (code + \"0000\").substring(0, 4);\n  return soundex;\n}\n"}
{"id": 354235, "name": "Knuth's algorithm S", "source": "Translate Ruby to Java: def s_of_n_creator(n)\n  sample = []\n  i = 0\n  Proc.new do |item|\n    i += 1\n    if i <= n\n      sample << item\n    elsif rand(i) < n\n      sample[rand(n)] = item\n    end\n    sample\n  end\nend\n\nfrequency = Array.new(10,0)\n100_000.times do\n  s_of_n = s_of_n_creator(3)\n  sample = nil\n  (0..9).each {|digit| sample = s_of_n[digit]}\n  sample.each {|digit| frequency[digit] += 1}\nend\n\n(0..9).each {|digit| puts \"\n", "target": "import java.util.*;\n \nclass SOfN<T> {\n    private static final Random rand = new Random();\n \n    private List<T> sample;\n    private int i = 0;\n    private int n;\n\n    public SOfN(int _n) {\n        n = _n;\n        sample = new ArrayList<T>(n);\n    }\n\n    public List<T> process(T item) {\n        if (++i <= n) {\n            sample.add(item);\n        } else if (rand.nextInt(i) < n) {\n            sample.set(rand.nextInt(n), item);\n        }\n        return sample;\n    }\n}\n \npublic class AlgorithmS {\n    public static void main(String[] args) {\n        int[] bin = new int[10];\n        for (int trial = 0; trial < 100000; trial++) {\n            SOfN<Integer> s_of_n = new SOfN<Integer>(3);\n            for (int i = 0; i < 9; i++) s_of_n.process(i);\n            for (int s : s_of_n.process(9)) bin[s]++;\n        }\n        System.out.println(Arrays.toString(bin));\n    }\n}\n"}
{"id": 354236, "name": "Disarium numbers", "source": "Translate Ruby to Java: disariums = Enumerator.new do |y|\n  (0..).each do |n|\n    i = 0\n    y << n if n.digits.reverse.sum{|d| d ** (i+=1) } == n\n  end\nend\n\nputs disariums.take(19).to_a.join(\" \")\n", "target": "import java.lang.Math;\n\npublic class DisariumNumbers {\n    public static boolean is_disarium(int num) {\n        int n = num;\n        int len = Integer.toString(n).length();\n        int sum = 0;\n        int i = 1;\n        while (n > 0) {\n            sum += Math.pow(n % 10, len - i + 1);\n            n /= 10;\n            i ++;\n        }\n        return sum  == num;\n    }\n\n    public static void main(String[] args) {\n        int i = 0;\n        int count = 0;\n        while (count <= 18) {\n            if (is_disarium(i)) {\n                System.out.printf(\"%d \", i);\n                count++;\n            }\n            i++;\n        }\n        System.out.printf(\"%s\", \"\\n\");\n    }\n}\n"}
{"id": 354237, "name": "Disarium numbers", "source": "Translate Ruby to Java: disariums = Enumerator.new do |y|\n  (0..).each do |n|\n    i = 0\n    y << n if n.digits.reverse.sum{|d| d ** (i+=1) } == n\n  end\nend\n\nputs disariums.take(19).to_a.join(\" \")\n", "target": "import java.lang.Math;\n\npublic class DisariumNumbers {\n    public static boolean is_disarium(int num) {\n        int n = num;\n        int len = Integer.toString(n).length();\n        int sum = 0;\n        int i = 1;\n        while (n > 0) {\n            sum += Math.pow(n % 10, len - i + 1);\n            n /= 10;\n            i ++;\n        }\n        return sum  == num;\n    }\n\n    public static void main(String[] args) {\n        int i = 0;\n        int count = 0;\n        while (count <= 18) {\n            if (is_disarium(i)) {\n                System.out.printf(\"%d \", i);\n                count++;\n            }\n            i++;\n        }\n        System.out.printf(\"%s\", \"\\n\");\n    }\n}\n"}
{"id": 354238, "name": "Flow-control structures", "source": "Translate Ruby to Java: begin\n  \nrescue ExceptionClassA => a\n  \nrescue ExceptionClassB, ExceptionClassC => b_or_c\n  \nrescue\n  \nelse\n  \nensure\n  \nend\n", "target": "switch (xx) {\n  case 1:\n  case 2:\n    \n    ...\n    break;\n  case 4:\n    \n    ...\n    break;\n  case 5:\n    \n    ...\n    break;\n  default:\n    \n    break;\n}\n\nfor (int i = 0; i < 10; ++i) {\n  ...\n  if (some_condition) { break; }\n  ...\n}\n\n_Time_: do {\n  for (int i = 0; i < 10; ++i) {\n    ...\n    if (some_condition) { break _Time_; }\n    ...\n    }\n  ...\n} while (thisCondition);\n"}
{"id": 354239, "name": "Find if a point is within a triangle", "source": "Translate Ruby to Java: EPS = 0.001\nEPS_SQUARE = EPS * EPS\n\ndef side(x1, y1, x2, y2, x, y)\n    return (y2 - y1) * (x - x1) + (-x2 + x1) * (y - y1)\nend\n\ndef naivePointInTriangle(x1, y1, x2, y2, x3, y3, x, y)\n    checkSide1 = side(x1, y1, x2, y2, x, y) >= 0\n    checkSide2 = side(x2, y2, x3, y3, x, y) >= 0\n    checkSide3 = side(x3, y3, x1, y1, x, y) >= 0\n    return checkSide1 && checkSide2 && checkSide3\nend\n\ndef pointInTriangleBoundingBox(x1, y1, x2, y2, x3, y3, x, y)\n    xMin = [x1, x2, x3].min - EPS\n    xMax = [x1, x2, x3].max + EPS\n    yMin = [y1, y2, y3].min - EPS\n    yMax = [y1, y2, y3].max + EPS\n    return !(x < xMin || xMax < x || y < yMin || yMax < y)\nend\n\ndef distanceSquarePointToSegment(x1, y1, x2, y2, x, y)\n    p1_p2_squareLength = (x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1)\n    dotProduct = ((x - x1) * (x2 - x1) + (y - y1) * (y2 - y1)) / p1_p2_squareLength\n    if dotProduct < 0 then\n        return (x - x1) * (x - x1) + (y - y1) * (y - y1)\n    end\n    if dotProduct <= 1 then\n        p_p1_squareLength = (x1 - x) * (x1 - x) + (y1 - y) * (y1 - y)\n        return p_p1_squareLength - dotProduct * dotProduct * p1_p2_squareLength\n    end\n    return (x - x2) * (x - x2) + (y - y2) * (y - y2)\nend\n\ndef accuratePointInTriangle(x1, y1, x2, y2, x3, y3, x, y)\n    if !pointInTriangleBoundingBox(x1, y1, x2, y2, x3, y3, x, y) then\n        return false\n    end\n    if naivePointInTriangle(x1, y1, x2, y2, x3, y3, x, y) then\n        return true\n    end\n    if distanceSquarePointToSegment(x1, y1, x2, y2, x, y) <= EPS_SQUARE then\n        return true\n    end\n    if distanceSquarePointToSegment(x2, y2, x3, y3, x, y) <= EPS_SQUARE then\n        return true\n    end\n    if distanceSquarePointToSegment(x3, y3, x1, y1, x, y) <= EPS_SQUARE then\n        return true\n    end\n    return false\nend\n\ndef main\n    pts = [[0, 0], [0, 1], [3, 1]]\n    tri = [[1.5, 2.4], [5.1, -3.1], [-3.8, 1.2]]\n    print \"Triangle is \", tri, \"\\n\"\n    x1, y1 = tri[0][0], tri[0][1]\n    x2, y2 = tri[1][0], tri[1][1]\n    x3, y3 = tri[2][0], tri[2][1]\n    for pt in pts\n        x, y = pt[0], pt[1]\n        within = accuratePointInTriangle(x1, y1, x2, y2, x3, y3, x, y)\n        print \"Point \", pt, \" is within triangle? \", within, \"\\n\"\n    end\n    print \"\\n\"\n\n    tri = [[0.1, 1.0 / 9.0], [12.5, 100.0 / 3.0], [25.0, 100.0 / 9.0]]\n    print \"Triangle is \", tri, \"\\n\"\n    x1, y1 = tri[0][0], tri[0][1]\n    x2, y2 = tri[1][0], tri[1][1]\n    x3, y3 = tri[2][0], tri[2][1]\n    x = x1 + (3.0 / 7.0) * (x2 - x1)\n    y = y1 + (3.0 / 7.0) * (y2 - y1)\n    pt = [x, y]\n    within = accuratePointInTriangle(x1, y1, x2, y2, x3, y3, x, y)\n    print \"Point \", pt, \" is within triangle? \", within, \"\\n\"\n    print \"\\n\"\n\n    tri = [[0.1, 1.0 / 9.0], [12.5, 100.0 / 3.0], [-12.5, 100.0 / 6.0]]\n    print \"Triangle is \", tri, \"\\n\"\n    x3, y3 = tri[2][0], tri[2][1]\n    within = accuratePointInTriangle(x1, y1, x2, y2, x3, y3, x, y)\n    print \"Point \", pt, \" is within triangle? \", within, \"\\n\"\nend\n\nmain()\n", "target": "import java.util.Objects;\n\npublic class FindTriangle {\n    private static final double EPS = 0.001;\n    private static final double EPS_SQUARE = EPS * EPS;\n\n    public static class Point {\n        private final double x, y;\n\n        public Point(double x, double y) {\n            this.x = x;\n            this.y = y;\n        }\n\n        public double getX() {\n            return x;\n        }\n\n        public double getY() {\n            return y;\n        }\n\n        @Override\n        public String toString() {\n            return String.format(\"(%f, %f)\", x, y);\n        }\n    }\n\n    public static class Triangle {\n        private final Point p1, p2, p3;\n\n        public Triangle(Point p1, Point p2, Point p3) {\n            this.p1 = Objects.requireNonNull(p1);\n            this.p2 = Objects.requireNonNull(p2);\n            this.p3 = Objects.requireNonNull(p3);\n        }\n\n        public Point getP1() {\n            return p1;\n        }\n\n        public Point getP2() {\n            return p2;\n        }\n\n        public Point getP3() {\n            return p3;\n        }\n\n        private boolean pointInTriangleBoundingBox(Point p) {\n            var xMin = Math.min(p1.getX(), Math.min(p2.getX(), p3.getX())) - EPS;\n            var xMax = Math.max(p1.getX(), Math.max(p2.getX(), p3.getX())) + EPS;\n            var yMin = Math.min(p1.getY(), Math.min(p2.getY(), p3.getY())) - EPS;\n            var yMax = Math.max(p1.getY(), Math.max(p2.getY(), p3.getY())) + EPS;\n            return !(p.getX() < xMin || xMax < p.getX() || p.getY() < yMin || yMax < p.getY());\n        }\n\n        private static double side(Point p1, Point p2, Point p) {\n            return (p2.getY() - p1.getY()) * (p.getX() - p1.getX()) + (-p2.getX() + p1.getX()) * (p.getY() - p1.getY());\n        }\n\n        private boolean nativePointInTriangle(Point p) {\n            boolean checkSide1 = side(p1, p2, p) >= 0;\n            boolean checkSide2 = side(p2, p3, p) >= 0;\n            boolean checkSide3 = side(p3, p1, p) >= 0;\n            return checkSide1 && checkSide2 && checkSide3;\n        }\n\n        private double distanceSquarePointToSegment(Point p1, Point p2, Point p) {\n            double p1_p2_squareLength = (p2.getX() - p1.getX()) * (p2.getX() - p1.getX()) + (p2.getY() - p1.getY()) * (p2.getY() - p1.getY());\n            double dotProduct = ((p.getX() - p1.getX()) * (p2.getX() - p1.getX()) + (p.getY() - p1.getY()) * (p2.getY() - p1.getY())) / p1_p2_squareLength;\n            if (dotProduct < 0) {\n                return (p.getX() - p1.getX()) * (p.getX() - p1.getX()) + (p.getY() - p1.getY()) * (p.getY() - p1.getY());\n            }\n            if (dotProduct <= 1) {\n                double p_p1_squareLength = (p1.getX() - p.getX()) * (p1.getX() - p.getX()) + (p1.getY() - p.getY()) * (p1.getY() - p.getY());\n                return p_p1_squareLength - dotProduct * dotProduct * p1_p2_squareLength;\n            }\n            return (p.getX() - p2.getX()) * (p.getX() - p2.getX()) + (p.getY() - p2.getY()) * (p.getY() - p2.getY());\n        }\n\n        private boolean accuratePointInTriangle(Point p) {\n            if (!pointInTriangleBoundingBox(p)) {\n                return false;\n            }\n            if (nativePointInTriangle(p)) {\n                return true;\n            }\n            if (distanceSquarePointToSegment(p1, p2, p) <= EPS_SQUARE) {\n                return true;\n            }\n            if (distanceSquarePointToSegment(p2, p3, p) <= EPS_SQUARE) {\n                return true;\n            }\n            return distanceSquarePointToSegment(p3, p1, p) <= EPS_SQUARE;\n        }\n\n        public boolean within(Point p) {\n            Objects.requireNonNull(p);\n            return accuratePointInTriangle(p);\n        }\n\n        @Override\n        public String toString() {\n            return String.format(\"Triangle[%s, %s, %s]\", p1, p2, p3);\n        }\n    }\n\n    private static void test(Triangle t, Point p) {\n        System.out.println(t);\n        System.out.printf(\"Point %s is within triangle? %s\\n\", p, t.within(p));\n    }\n\n    public static void main(String[] args) {\n        var p1 = new Point(1.5, 2.4);\n        var p2 = new Point(5.1, -3.1);\n        var p3 = new Point(-3.8, 1.2);\n        var tri = new Triangle(p1, p2, p3);\n        test(tri, new Point(0, 0));\n        test(tri, new Point(0, 1));\n        test(tri, new Point(3, 1));\n        System.out.println();\n\n        p1 = new Point(1.0 / 10, 1.0 / 9);\n        p2 = new Point(100.0 / 8, 100.0 / 3);\n        p3 = new Point(100.0 / 4, 100.0 / 9);\n        tri = new Triangle(p1, p2, p3);\n        var pt = new Point(p1.getX() + (3.0 / 7) * (p2.getX() - p1.getX()), p1.getY() + (3.0 / 7) * (p2.getY() - p1.getY()));\n        test(tri, pt);\n        System.out.println();\n\n        p3 = new Point(-100.0 / 8, 100.0 / 6);\n        tri = new Triangle(p1, p2, p3);\n        test(tri, pt);\n    }\n}\n"}
{"id": 354240, "name": "Find if a point is within a triangle", "source": "Translate Ruby to Java: EPS = 0.001\nEPS_SQUARE = EPS * EPS\n\ndef side(x1, y1, x2, y2, x, y)\n    return (y2 - y1) * (x - x1) + (-x2 + x1) * (y - y1)\nend\n\ndef naivePointInTriangle(x1, y1, x2, y2, x3, y3, x, y)\n    checkSide1 = side(x1, y1, x2, y2, x, y) >= 0\n    checkSide2 = side(x2, y2, x3, y3, x, y) >= 0\n    checkSide3 = side(x3, y3, x1, y1, x, y) >= 0\n    return checkSide1 && checkSide2 && checkSide3\nend\n\ndef pointInTriangleBoundingBox(x1, y1, x2, y2, x3, y3, x, y)\n    xMin = [x1, x2, x3].min - EPS\n    xMax = [x1, x2, x3].max + EPS\n    yMin = [y1, y2, y3].min - EPS\n    yMax = [y1, y2, y3].max + EPS\n    return !(x < xMin || xMax < x || y < yMin || yMax < y)\nend\n\ndef distanceSquarePointToSegment(x1, y1, x2, y2, x, y)\n    p1_p2_squareLength = (x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1)\n    dotProduct = ((x - x1) * (x2 - x1) + (y - y1) * (y2 - y1)) / p1_p2_squareLength\n    if dotProduct < 0 then\n        return (x - x1) * (x - x1) + (y - y1) * (y - y1)\n    end\n    if dotProduct <= 1 then\n        p_p1_squareLength = (x1 - x) * (x1 - x) + (y1 - y) * (y1 - y)\n        return p_p1_squareLength - dotProduct * dotProduct * p1_p2_squareLength\n    end\n    return (x - x2) * (x - x2) + (y - y2) * (y - y2)\nend\n\ndef accuratePointInTriangle(x1, y1, x2, y2, x3, y3, x, y)\n    if !pointInTriangleBoundingBox(x1, y1, x2, y2, x3, y3, x, y) then\n        return false\n    end\n    if naivePointInTriangle(x1, y1, x2, y2, x3, y3, x, y) then\n        return true\n    end\n    if distanceSquarePointToSegment(x1, y1, x2, y2, x, y) <= EPS_SQUARE then\n        return true\n    end\n    if distanceSquarePointToSegment(x2, y2, x3, y3, x, y) <= EPS_SQUARE then\n        return true\n    end\n    if distanceSquarePointToSegment(x3, y3, x1, y1, x, y) <= EPS_SQUARE then\n        return true\n    end\n    return false\nend\n\ndef main\n    pts = [[0, 0], [0, 1], [3, 1]]\n    tri = [[1.5, 2.4], [5.1, -3.1], [-3.8, 1.2]]\n    print \"Triangle is \", tri, \"\\n\"\n    x1, y1 = tri[0][0], tri[0][1]\n    x2, y2 = tri[1][0], tri[1][1]\n    x3, y3 = tri[2][0], tri[2][1]\n    for pt in pts\n        x, y = pt[0], pt[1]\n        within = accuratePointInTriangle(x1, y1, x2, y2, x3, y3, x, y)\n        print \"Point \", pt, \" is within triangle? \", within, \"\\n\"\n    end\n    print \"\\n\"\n\n    tri = [[0.1, 1.0 / 9.0], [12.5, 100.0 / 3.0], [25.0, 100.0 / 9.0]]\n    print \"Triangle is \", tri, \"\\n\"\n    x1, y1 = tri[0][0], tri[0][1]\n    x2, y2 = tri[1][0], tri[1][1]\n    x3, y3 = tri[2][0], tri[2][1]\n    x = x1 + (3.0 / 7.0) * (x2 - x1)\n    y = y1 + (3.0 / 7.0) * (y2 - y1)\n    pt = [x, y]\n    within = accuratePointInTriangle(x1, y1, x2, y2, x3, y3, x, y)\n    print \"Point \", pt, \" is within triangle? \", within, \"\\n\"\n    print \"\\n\"\n\n    tri = [[0.1, 1.0 / 9.0], [12.5, 100.0 / 3.0], [-12.5, 100.0 / 6.0]]\n    print \"Triangle is \", tri, \"\\n\"\n    x3, y3 = tri[2][0], tri[2][1]\n    within = accuratePointInTriangle(x1, y1, x2, y2, x3, y3, x, y)\n    print \"Point \", pt, \" is within triangle? \", within, \"\\n\"\nend\n\nmain()\n", "target": "import java.util.Objects;\n\npublic class FindTriangle {\n    private static final double EPS = 0.001;\n    private static final double EPS_SQUARE = EPS * EPS;\n\n    public static class Point {\n        private final double x, y;\n\n        public Point(double x, double y) {\n            this.x = x;\n            this.y = y;\n        }\n\n        public double getX() {\n            return x;\n        }\n\n        public double getY() {\n            return y;\n        }\n\n        @Override\n        public String toString() {\n            return String.format(\"(%f, %f)\", x, y);\n        }\n    }\n\n    public static class Triangle {\n        private final Point p1, p2, p3;\n\n        public Triangle(Point p1, Point p2, Point p3) {\n            this.p1 = Objects.requireNonNull(p1);\n            this.p2 = Objects.requireNonNull(p2);\n            this.p3 = Objects.requireNonNull(p3);\n        }\n\n        public Point getP1() {\n            return p1;\n        }\n\n        public Point getP2() {\n            return p2;\n        }\n\n        public Point getP3() {\n            return p3;\n        }\n\n        private boolean pointInTriangleBoundingBox(Point p) {\n            var xMin = Math.min(p1.getX(), Math.min(p2.getX(), p3.getX())) - EPS;\n            var xMax = Math.max(p1.getX(), Math.max(p2.getX(), p3.getX())) + EPS;\n            var yMin = Math.min(p1.getY(), Math.min(p2.getY(), p3.getY())) - EPS;\n            var yMax = Math.max(p1.getY(), Math.max(p2.getY(), p3.getY())) + EPS;\n            return !(p.getX() < xMin || xMax < p.getX() || p.getY() < yMin || yMax < p.getY());\n        }\n\n        private static double side(Point p1, Point p2, Point p) {\n            return (p2.getY() - p1.getY()) * (p.getX() - p1.getX()) + (-p2.getX() + p1.getX()) * (p.getY() - p1.getY());\n        }\n\n        private boolean nativePointInTriangle(Point p) {\n            boolean checkSide1 = side(p1, p2, p) >= 0;\n            boolean checkSide2 = side(p2, p3, p) >= 0;\n            boolean checkSide3 = side(p3, p1, p) >= 0;\n            return checkSide1 && checkSide2 && checkSide3;\n        }\n\n        private double distanceSquarePointToSegment(Point p1, Point p2, Point p) {\n            double p1_p2_squareLength = (p2.getX() - p1.getX()) * (p2.getX() - p1.getX()) + (p2.getY() - p1.getY()) * (p2.getY() - p1.getY());\n            double dotProduct = ((p.getX() - p1.getX()) * (p2.getX() - p1.getX()) + (p.getY() - p1.getY()) * (p2.getY() - p1.getY())) / p1_p2_squareLength;\n            if (dotProduct < 0) {\n                return (p.getX() - p1.getX()) * (p.getX() - p1.getX()) + (p.getY() - p1.getY()) * (p.getY() - p1.getY());\n            }\n            if (dotProduct <= 1) {\n                double p_p1_squareLength = (p1.getX() - p.getX()) * (p1.getX() - p.getX()) + (p1.getY() - p.getY()) * (p1.getY() - p.getY());\n                return p_p1_squareLength - dotProduct * dotProduct * p1_p2_squareLength;\n            }\n            return (p.getX() - p2.getX()) * (p.getX() - p2.getX()) + (p.getY() - p2.getY()) * (p.getY() - p2.getY());\n        }\n\n        private boolean accuratePointInTriangle(Point p) {\n            if (!pointInTriangleBoundingBox(p)) {\n                return false;\n            }\n            if (nativePointInTriangle(p)) {\n                return true;\n            }\n            if (distanceSquarePointToSegment(p1, p2, p) <= EPS_SQUARE) {\n                return true;\n            }\n            if (distanceSquarePointToSegment(p2, p3, p) <= EPS_SQUARE) {\n                return true;\n            }\n            return distanceSquarePointToSegment(p3, p1, p) <= EPS_SQUARE;\n        }\n\n        public boolean within(Point p) {\n            Objects.requireNonNull(p);\n            return accuratePointInTriangle(p);\n        }\n\n        @Override\n        public String toString() {\n            return String.format(\"Triangle[%s, %s, %s]\", p1, p2, p3);\n        }\n    }\n\n    private static void test(Triangle t, Point p) {\n        System.out.println(t);\n        System.out.printf(\"Point %s is within triangle? %s\\n\", p, t.within(p));\n    }\n\n    public static void main(String[] args) {\n        var p1 = new Point(1.5, 2.4);\n        var p2 = new Point(5.1, -3.1);\n        var p3 = new Point(-3.8, 1.2);\n        var tri = new Triangle(p1, p2, p3);\n        test(tri, new Point(0, 0));\n        test(tri, new Point(0, 1));\n        test(tri, new Point(3, 1));\n        System.out.println();\n\n        p1 = new Point(1.0 / 10, 1.0 / 9);\n        p2 = new Point(100.0 / 8, 100.0 / 3);\n        p3 = new Point(100.0 / 4, 100.0 / 9);\n        tri = new Triangle(p1, p2, p3);\n        var pt = new Point(p1.getX() + (3.0 / 7) * (p2.getX() - p1.getX()), p1.getY() + (3.0 / 7) * (p2.getY() - p1.getY()));\n        test(tri, pt);\n        System.out.println();\n\n        p3 = new Point(-100.0 / 8, 100.0 / 6);\n        tri = new Triangle(p1, p2, p3);\n        test(tri, pt);\n    }\n}\n"}
{"id": 354241, "name": "Return multiple values", "source": "Translate Ruby to Java: def addsub(x, y)\n  [x + y, x - y]\nend\n", "target": "import java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.util.HashMap;\n\n\npublic class RReturnMultipleVals {\n  public static final String K_lipsum = \"Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua.\";\n  public static final Long   K_1024   = 1024L;\n  public static final String L        = \"L\";\n  public static final String R        = \"R\";\n\n  \n  public static void main(String[] args) throws NumberFormatException{\n    Long nv_;\n    String sv_;\n    switch (args.length) {\n      case 0:\n        nv_ = K_1024;\n        sv_ = K_lipsum;\n        break;\n      case 1:\n        nv_ = Long.parseLong(args[0]);\n        sv_ = K_lipsum;\n        break;\n      case 2:\n        nv_ = Long.parseLong(args[0]);\n        sv_ = args[1];\n        break;\n      default:\n        nv_ = Long.parseLong(args[0]);\n        sv_ = args[1];\n        for (int ix = 2; ix < args.length; ++ix) {\n          sv_ = sv_ + \" \" + args[ix];\n        }\n        break;\n    }\n\n    RReturnMultipleVals lcl = new RReturnMultipleVals();\n\n    Pair<Long, String> rvp = lcl.getPairFromPair(nv_, sv_); \n    System.out.println(\"Results extracted from a composite object:\");\n    System.out.printf(\"%s, %s%n%n\", rvp.getLeftVal(), rvp.getRightVal());\n\n    List<Object> rvl = lcl.getPairFromList(nv_, sv_); \n    System.out.println(\"Results extracted from a Java Colections \\\"List\\\" object:\");\n    System.out.printf(\"%s, %s%n%n\", rvl.get(0), rvl.get(1));\n\n    Map<String, Object> rvm = lcl.getPairFromMap(nv_, sv_); \n    System.out.println(\"Results extracted from a Java Colections \\\"Map\\\" object:\");\n    System.out.printf(\"%s, %s%n%n\", rvm.get(L), rvm.get(R));\n  }\n  \n  \n  \n  public <T, U> Pair<T, U> getPairFromPair(T vl_, U vr_) {\n    return new Pair<T, U>(vl_, vr_);\n  }\n  \n  \n  \n  public List<Object> getPairFromList(Object nv_, Object sv_) {\n    List<Object> rset = new ArrayList<Object>();\n    rset.add(nv_);\n    rset.add(sv_);\n    return rset;\n  }\n  \n  \n  \n  public Map<String, Object> getPairFromMap(Object nv_, Object sv_) {\n    Map<String, Object> rset = new HashMap<String, Object>();\n    rset.put(L, nv_);\n    rset.put(R, sv_);\n    return rset;\n  }\n\n  \n  private static class Pair<L, R> {\n    private L leftVal;\n    private R rightVal;\n\n    public Pair(L nv_, R sv_) {\n      setLeftVal(nv_);\n      setRightVal(sv_);\n    }\n    public void setLeftVal(L nv_) {\n      leftVal = nv_;\n    }\n    public L getLeftVal() {\n      return leftVal;\n    }\n    public void setRightVal(R sv_) {\n      rightVal = sv_;\n    }\n    public R getRightVal() {\n      return rightVal;\n    }\n  }\n}\n"}
{"id": 354242, "name": "Fractran", "source": "Translate Ruby to Java: ar = %w[17/91 78/85 19/51 23/38 29/33 77/29 95/23 77/19 1/17 11/13 13/11 15/14 15/2 55/1]\nFractalProgram = ar.map(&:to_r)                                \n\nRunner = Enumerator.new do |y|\n  num = 2\n  loop{ y << num *= FractalProgram.detect{|f| (num*f).denominator == 1} }\nend\n\nprime_generator = Enumerator.new do |y| \n  Runner.each do |num|\n    l = Math.log2(num)\n    y << l.to_i if l.floor == l\n  end\nend\n\n\np Runner.take(20).map(&:numerator)\np prime_generator.take(20)\n", "target": "import java.util.Vector;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\npublic class Fractran{\n\n   public static void main(String []args){ \n\n       new Fractran(\"17/91 78/85 19/51 23/38 29/33 77/29 95/23 77/19 1/17 11/13 13/11 15/14 15/2 55/1\", 2);\n   }\n   final int limit = 15;\n   \n\n   Vector<Integer> num = new Vector<>(); \n   Vector<Integer> den = new Vector<>(); \n   public Fractran(String prog, Integer val){\n      compile(prog);\n      dump();\n      exec(2);\n    }\n\n\n   void compile(String prog){\n      Pattern regexp = Pattern.compile(\"\\\\s*(\\\\d*)\\\\s*\\\\/\\\\s*(\\\\d*)\\\\s*(.*)\");\n      Matcher matcher = regexp.matcher(prog);\n      while(matcher.find()){\n         num.add(Integer.parseInt(matcher.group(1)));\n         den.add(Integer.parseInt(matcher.group(2)));\n         matcher = regexp.matcher(matcher.group(3));\n      }\n   }\n\n   void exec(Integer val){\n       int n = 0;\n       while(val != null && n<limit){\n           System.out.println(n+\": \"+val);\n           val = step(val);\n           n++;\n       }\n   }\n   Integer step(int val){\n       int i=0; \n       while(i<den.size() && val%den.get(i) != 0) i++;\n       if(i<den.size())\n           return num.get(i)*val/den.get(i);\n       return null;\n   }\n\n   void dump(){\n       for(int i=0; i<den.size(); i++)\n           System.out.print(num.get(i)+\"/\"+den.get(i)+\" \");\n       System.out.println();\n   }\n}\n"}
{"id": 354243, "name": "Substring_Top and tail", "source": "Translate Ruby to Java: puts \"knight\"[1..-1]   \nputs \"socks\"[0..-2]    \nputs \"socks\".chop      \nputs \"brooms\"[1..-2]   \nputs \"\u4e0e\u4eca\u4ee4\"[1..-2]    \n", "target": "String strOrig = 'brooms';\nString str1 = strOrig.substring(1, strOrig.length());\nsystem.debug(str1);\nString str2 = strOrig.substring(0, strOrig.length()-1);\nsystem.debug(str2);\nString str3 = strOrig.substring(1, strOrig.length()-1);\nsystem.debug(str3);\n\n\nString strOrig = 'brooms';\nString str1 = strOrig.replaceAll( '^.', '' );\nsystem.debug(str1);\nString str2 = strOrig.replaceAll( '.$', '' ) ;\nsystem.debug(str2);\nString str3 = strOrig.replaceAll( '^.|.$', '' );\nsystem.debug(str3);\n"}
{"id": 354244, "name": "Substring_Top and tail", "source": "Translate Ruby to Java: puts \"knight\"[1..-1]   \nputs \"socks\"[0..-2]    \nputs \"socks\".chop      \nputs \"brooms\"[1..-2]   \nputs \"\u4e0e\u4eca\u4ee4\"[1..-2]    \n", "target": "String strOrig = 'brooms';\nString str1 = strOrig.substring(1, strOrig.length());\nsystem.debug(str1);\nString str2 = strOrig.substring(0, strOrig.length()-1);\nsystem.debug(str2);\nString str3 = strOrig.substring(1, strOrig.length()-1);\nsystem.debug(str3);\n\n\nString strOrig = 'brooms';\nString str1 = strOrig.replaceAll( '^.', '' );\nsystem.debug(str1);\nString str2 = strOrig.replaceAll( '.$', '' ) ;\nsystem.debug(str2);\nString str3 = strOrig.replaceAll( '^.|.$', '' );\nsystem.debug(str3);\n"}
{"id": 354245, "name": "Boolean values", "source": "Translate Ruby to Java: if false\n  puts \"false\"\nelsif nil\n  puts \"nil\"\nelsif Pointer(Nil).new 0\n  puts \"null pointer\"\nelsif true && \"any other value\"\n  puts \"finally true!\"\nend\n", "target": "module GeorgeBoole\n    {\n    @Inject Console console;\n\n    void run()\n        {\n        Boolean f = False;\n        assert !f == True;\n\n        \n        \n        assert True.and(False) == True & False == False;\n        assert True.or(False)  == True | False == True;\n        assert True.xor(False) == True ^ False == True;\n        assert True.not() == ~True == False;\n\n        console.print($\"0==1 = {0==1}\");\n        console.print($\"!False = {!False}\");\n        }\n    }\n"}
{"id": 354246, "name": "Bitmap_Histogram", "source": "Translate Ruby to Java: class Pixmap\n  def histogram\n    histogram = Hash.new(0)\n    @height.times do |y|\n      @width.times do |x|\n        histogram[self[x,y].luminosity] += 1\n      end\n    end\n    histogram \n  end\n\n  def to_blackandwhite\n    hist = histogram\n\n    \n    median = nil\n    sum = 0\n    hist.keys.sort.each do |lum|\n      sum += hist[lum]\n      if sum > @height * @width / 2\n        median = lum\n        break\n      end\n    end\n\n    \n    bw = self.class.new(@width, @height)\n    @height.times do |y|\n      @width.times do |x|\n        bw[x,y] = self[x,y].luminosity < median ? RGBColour::BLACK : RGBColour::WHITE\n      end\n    end\n    bw\n  end\n\n  def save_as_blackandwhite(filename)\n    to_blackandwhite.save(filename)\n  end\nend\n\nPixmap.open('file.ppm').save_as_blackandwhite('file_bw.ppm')\n", "target": "import java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.io.IOException;\nimport javax.imageio.ImageIO;\n\npublic enum ImageProcessing {\n    ;\n\n    public static void main(String[] args) throws IOException {\n        BufferedImage img = ImageIO.read(new File(\"example.png\"));\n\n        BufferedImage bwimg = toBlackAndWhite(img);\n\n        ImageIO.write(bwimg, \"png\", new File(\"example-bw.png\"));\n    }\n\n    private static int luminance(int rgb) {\n        int r = (rgb >> 16) & 0xFF;\n        int g = (rgb >> 8) & 0xFF;\n        int b = rgb & 0xFF;\n        return (r + b + g) / 3;\n    }\n\n    private static BufferedImage toBlackAndWhite(BufferedImage img) {\n        int width = img.getWidth();\n        int height = img.getHeight();\n\n        int[] histo = computeHistogram(img);\n\n        int median = getMedian(width * height, histo);\n\n        BufferedImage bwimg = new BufferedImage(width, height, img.getType());\n        for (int y = 0; y < height; y++) {\n            for (int x = 0; x < width; x++) {\n                bwimg.setRGB(x, y, luminance(img.getRGB(x, y)) >= median ? 0xFFFFFFFF : 0xFF000000);\n            }\n        }\n        return bwimg;\n    }\n\n    private static int[] computeHistogram(BufferedImage img) {\n        int width = img.getWidth();\n        int height = img.getHeight();\n\n        int[] histo = new int[256];\n        for (int y = 0; y < height; y++) {\n            for (int x = 0; x < width; x++) {\n                histo[luminance(img.getRGB(x, y))]++;\n            }\n        }\n        return histo;\n    }\n\n    private static int getMedian(int total, int[] histo) {\n        int median = 0;\n        int sum = 0;\n        for (int i = 0; i < histo.length && sum + histo[i] < total / 2; i++) {\n            sum += histo[i];\n            median++;\n        }\n        return median;\n    }\n}\n"}
{"id": 354247, "name": "Plot coordinate pairs", "source": "Translate Ruby to Java: require 'gnuplot'\n\nx = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\ny = [2.7, 2.8, 31.4, 38.1, 58.0, 76.2, 100.5, 130.0, 149.3, 180.0]\nGnuplot.open do |gp|\n  Gnuplot::Plot.new( gp ) do |plot|\n    plot.data << Gnuplot::DataSet.new( [x, y] ) do |ds|\n      ds.with = \"linespoints\"\n      ds.notitle\n    end\n  end\nend\n", "target": "  import java.awt.*;\n  import java.awt.event.*;\n  import java.awt.geom.*;\n  import javax.swing.JApplet;\n  import javax.swing.JFrame;\n  public class Plot2d extends JApplet {\n    double[] xi;\n    double[] yi;\n    public Plot2d(double[] x, double[] y) {\n        this.xi = x;\n        this.yi = y;\n    }\n    public static double max(double[] t) {\n        double maximum = t[0];   \n        for (int i = 1; i < t.length; i++) {\n            if (t[i] > maximum) {\n                maximum = t[i];  \n            }\n        }\n        return maximum;\n    }\n    public static double min(double[] t) {\n        double minimum = t[0];\n        for (int i = 1; i < t.length; i++) {\n            if (t[i] < minimum) {\n                minimum = t[i];\n            }\n        }\n        return minimum;\n    }\n    public void init() {\n        setBackground(Color.white);\n        setForeground(Color.white);\n    }\n    public void paint(Graphics g) {\n        Graphics2D g2 = (Graphics2D) g;\n        g2.setRenderingHint(RenderingHints.KEY_ANTIALIASING,\n                RenderingHints.VALUE_ANTIALIAS_ON);\n        g2.setPaint(Color.black);\n        int x0 = 70;\n        int y0 = 10;\n        int xm = 670;\n        int ym = 410;\n        int xspan = xm - x0;\n        int yspan = ym - y0;\n        double xmax = max(xi);\n        double xmin = min(xi);\n        double ymax = max(yi);\n        double ymin = min(yi);\n        g2.draw(new Line2D.Double(x0, ym, xm, ym));\n        g2.draw(new Line2D.Double(x0, ym, x0, y0));\n        for (int j = 0; j < 5; j++) {\n            int interv = 4;\n            g2.drawString(\"\" + (j * (xmax - xmin) / interv + xmin), j * xspan / interv + x0 - 10, ym + 20);\n            g2.drawString(\"\" + (j * (ymax - ymin) / interv + ymin), x0 - 20 - (int) (9 * Math.log10(ymax)),\n ym - j * yspan / interv + y0 - 5);\n            g2.draw(new Line2D.Double(j * xspan / interv + x0, ym, j * xspan / interv + x0, ym + 5));\n            g2.draw(new Line2D.Double(x0 - 5, j * yspan / interv + y0, x0, j * yspan / interv + y0));\n        }\n        for (int i = 0; i < xi.length; i++) {\n            int f = (int) ((xi[i] - xmin) * xspan / (xmax - xmin));\n            int h = (int) (((ymax - ymin) - (yi[i] - ymin)) * yspan / (ymax - ymin));\n            g2.drawString(\"o\", x0 + f - 3, h + 14);\n        }\n        for (int i = 0; i < xi.length - 1; i++) {\n            int f = (int) ((xi[i] - xmin) * xspan / (xmax - xmin));\n            int f2 = (int) ((xi[i + 1] - xmin) * xspan / (xmax - xmin));\n            int h = (int) (((ymax - ymin) - (yi[i] - ymin)) * yspan / (ymax - ymin));\n            int h2 = (int) (((ymax - ymin) - (yi[i + 1] - ymin)) * yspan / (ymax - ymin));\n            g2.draw(new Line2D.Double(f + x0, h + y0, f2 + x0, h2 + y0));\n        }\n    }\n    public static void main(String args[]) {\n        JFrame f = new JFrame(\"ShapesDemo2D\");\n        f.addWindowListener(new WindowAdapter() {\n            public void windowClosing(WindowEvent e) {\n                System.exit(0);\n            }\n        });\n        double[] r = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};\n        double[] t = {2.7, 2.8, 31.4, 38.1, 58.0, 76.2, 100.5, 130.0, 149.3, 180.09};\n        JApplet applet = new Plot2d(r, t);\n        f.getContentPane().add(\"Center\", applet);\n        applet.init();\n        f.pack();\n        f.setSize(new Dimension(720, 480));\n        f.show();\n    }\n  }\n"}
{"id": 354248, "name": "Plot coordinate pairs", "source": "Translate Ruby to Java: require 'gnuplot'\n\nx = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\ny = [2.7, 2.8, 31.4, 38.1, 58.0, 76.2, 100.5, 130.0, 149.3, 180.0]\nGnuplot.open do |gp|\n  Gnuplot::Plot.new( gp ) do |plot|\n    plot.data << Gnuplot::DataSet.new( [x, y] ) do |ds|\n      ds.with = \"linespoints\"\n      ds.notitle\n    end\n  end\nend\n", "target": "  import java.awt.*;\n  import java.awt.event.*;\n  import java.awt.geom.*;\n  import javax.swing.JApplet;\n  import javax.swing.JFrame;\n  public class Plot2d extends JApplet {\n    double[] xi;\n    double[] yi;\n    public Plot2d(double[] x, double[] y) {\n        this.xi = x;\n        this.yi = y;\n    }\n    public static double max(double[] t) {\n        double maximum = t[0];   \n        for (int i = 1; i < t.length; i++) {\n            if (t[i] > maximum) {\n                maximum = t[i];  \n            }\n        }\n        return maximum;\n    }\n    public static double min(double[] t) {\n        double minimum = t[0];\n        for (int i = 1; i < t.length; i++) {\n            if (t[i] < minimum) {\n                minimum = t[i];\n            }\n        }\n        return minimum;\n    }\n    public void init() {\n        setBackground(Color.white);\n        setForeground(Color.white);\n    }\n    public void paint(Graphics g) {\n        Graphics2D g2 = (Graphics2D) g;\n        g2.setRenderingHint(RenderingHints.KEY_ANTIALIASING,\n                RenderingHints.VALUE_ANTIALIAS_ON);\n        g2.setPaint(Color.black);\n        int x0 = 70;\n        int y0 = 10;\n        int xm = 670;\n        int ym = 410;\n        int xspan = xm - x0;\n        int yspan = ym - y0;\n        double xmax = max(xi);\n        double xmin = min(xi);\n        double ymax = max(yi);\n        double ymin = min(yi);\n        g2.draw(new Line2D.Double(x0, ym, xm, ym));\n        g2.draw(new Line2D.Double(x0, ym, x0, y0));\n        for (int j = 0; j < 5; j++) {\n            int interv = 4;\n            g2.drawString(\"\" + (j * (xmax - xmin) / interv + xmin), j * xspan / interv + x0 - 10, ym + 20);\n            g2.drawString(\"\" + (j * (ymax - ymin) / interv + ymin), x0 - 20 - (int) (9 * Math.log10(ymax)),\n ym - j * yspan / interv + y0 - 5);\n            g2.draw(new Line2D.Double(j * xspan / interv + x0, ym, j * xspan / interv + x0, ym + 5));\n            g2.draw(new Line2D.Double(x0 - 5, j * yspan / interv + y0, x0, j * yspan / interv + y0));\n        }\n        for (int i = 0; i < xi.length; i++) {\n            int f = (int) ((xi[i] - xmin) * xspan / (xmax - xmin));\n            int h = (int) (((ymax - ymin) - (yi[i] - ymin)) * yspan / (ymax - ymin));\n            g2.drawString(\"o\", x0 + f - 3, h + 14);\n        }\n        for (int i = 0; i < xi.length - 1; i++) {\n            int f = (int) ((xi[i] - xmin) * xspan / (xmax - xmin));\n            int f2 = (int) ((xi[i + 1] - xmin) * xspan / (xmax - xmin));\n            int h = (int) (((ymax - ymin) - (yi[i] - ymin)) * yspan / (ymax - ymin));\n            int h2 = (int) (((ymax - ymin) - (yi[i + 1] - ymin)) * yspan / (ymax - ymin));\n            g2.draw(new Line2D.Double(f + x0, h + y0, f2 + x0, h2 + y0));\n        }\n    }\n    public static void main(String args[]) {\n        JFrame f = new JFrame(\"ShapesDemo2D\");\n        f.addWindowListener(new WindowAdapter() {\n            public void windowClosing(WindowEvent e) {\n                System.exit(0);\n            }\n        });\n        double[] r = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};\n        double[] t = {2.7, 2.8, 31.4, 38.1, 58.0, 76.2, 100.5, 130.0, 149.3, 180.09};\n        JApplet applet = new Plot2d(r, t);\n        f.getContentPane().add(\"Center\", applet);\n        applet.init();\n        f.pack();\n        f.setSize(new Dimension(720, 480));\n        f.show();\n    }\n  }\n"}
{"id": 354249, "name": "LZW compression", "source": "Translate Ruby to Java: \ndef compress(uncompressed)\n    \n    dict_size = 256\n    dictionary = Hash[ Array.new(dict_size) {|i| [i.chr, i.chr]} ]\n\n    w = \"\"\n    result = []\n    for c in uncompressed.split('')\n        wc = w + c\n        if dictionary.has_key?(wc)\n            w = wc\n        else\n            result << dictionary[w]\n            \n            dictionary[wc] = dict_size\n            dict_size += 1\n            w = c\n        end\n    end\n\n    \n    result << dictionary[w] unless w.empty?\n    result\nend\n\n\ndef decompress(compressed)\n    \n    dict_size = 256\n    dictionary = Hash[ Array.new(dict_size) {|i| [i.chr, i.chr]} ]\n\n    w = result = compressed.shift\n    for k in compressed\n        if dictionary.has_key?(k)\n            entry = dictionary[k]\n        elsif k == dict_size\n            entry = w + w[0,1]\n        else\n            raise 'Bad compressed k: %s' % k\n        end\n        result += entry\n\n        \n        dictionary[dict_size] = w + entry[0,1]\n        dict_size += 1\n\n        w = entry\n    end\n    result\nend\n\n\ncompressed = compress('TOBEORNOTTOBEORTOBEORNOT')\np compressed\ndecompressed = decompress(compressed)\nputs decompressed\n", "target": "import java.util.*;\n\npublic class LZW {\n    \n    public static List<Integer> compress(String uncompressed) {\n        \n        int dictSize = 256;\n        Map<String,Integer> dictionary = new HashMap<String,Integer>();\n        for (int i = 0; i < 256; i++)\n            dictionary.put(\"\" + (char)i, i);\n        \n        String w = \"\";\n        List<Integer> result = new ArrayList<Integer>();\n        for (char c : uncompressed.toCharArray()) {\n            String wc = w + c;\n            if (dictionary.containsKey(wc))\n                w = wc;\n            else {\n                result.add(dictionary.get(w));\n                \n                dictionary.put(wc, dictSize++);\n                w = \"\" + c;\n            }\n        }\n \n        \n        if (!w.equals(\"\"))\n            result.add(dictionary.get(w));\n        return result;\n    }\n    \n    \n    public static String decompress(List<Integer> compressed) {\n        \n        int dictSize = 256;\n        Map<Integer,String> dictionary = new HashMap<Integer,String>();\n        for (int i = 0; i < 256; i++)\n            dictionary.put(i, \"\" + (char)i);\n        \n        String w = \"\" + (char)(int)compressed.remove(0);\n        StringBuffer result = new StringBuffer(w);\n        for (int k : compressed) {\n            String entry;\n            if (dictionary.containsKey(k))\n                entry = dictionary.get(k);\n            else if (k == dictSize)\n                entry = w + w.charAt(0);\n            else\n                throw new IllegalArgumentException(\"Bad compressed k: \" + k);\n            \n            result.append(entry);\n            \n            \n            dictionary.put(dictSize++, w + entry.charAt(0));\n            \n            w = entry;\n        }\n        return result.toString();\n    }\n\n    public static void main(String[] args) {\n        List<Integer> compressed = compress(\"TOBEORNOTTOBEORTOBEORNOT\");\n        System.out.println(compressed);\n        String decompressed = decompress(compressed);\n        System.out.println(decompressed);\n    }\n}\n"}
{"id": 354250, "name": "Peano curve", "source": "Translate Ruby to Java: load_library :grammar\n\n\nclass Peano\n  include Processing::Proxy\n  attr_reader :draw_length, :vec, :theta, :axiom, :grammar\n  DELTA = 60 \n  def initialize(vec)\n    @axiom = 'XF' \n    rules = {\n      'X' => 'X+YF++YF-FX--FXFX-YF+', \n      'Y' => '-FX+YFYF++YF+FX--FX-Y'\n    }\n    @grammar = Grammar.new(axiom, rules)\n    @theta   = 0\n    @draw_length = 100\n    @vec = vec\n  end\n\n  def generate(gen)\n    @draw_length = draw_length * 0.6**gen\n    grammar.generate gen\n  end\n\n  def translate_rules(prod)\n    coss = ->(orig, alpha, len) { orig + len * DegLut.cos(alpha) }\n    sinn = ->(orig, alpha, len) { orig - len * DegLut.sin(alpha) }\n    [].tap do |pts| \n      prod.scan(/./) do |ch|\n        case ch\n        when 'F'\n          pts << vec.copy\n          @vec = Vec2D.new(\n            coss.call(vec.x, theta, draw_length),\n            sinn.call(vec.y, theta, draw_length)\n          )\n          pts << vec\n        when '+'\n          @theta += DELTA\n        when '-'\n          @theta -= DELTA\n        when 'X', 'Y'\n        else\n          puts(\"character \n        end\n      end\n    end\n  end\nend\n\nattr_reader :points\n\ndef setup\n  sketch_title 'Peano'\n  peano = Peano.new(Vec2D.new(width * 0.65, height * 0.9))\n  production = peano.generate 4 \n  @points = peano.translate_rules(production)\n  no_loop\nend\n\ndef draw\n  background(0)\n  render points\nend\n\ndef render(points)\n  no_fill\n  stroke 200.0\n  stroke_weight 3\n  begin_shape\n  points.each_slice(2) do |v0, v1|\n    v0.to_vertex(renderer)\n    v1.to_vertex(renderer)\n  end\n  end_shape\nend\n\ndef renderer\n  @renderer ||= GfxRender.new(g)\nend\n\ndef settings\n  size(800, 800)\nend\n", "target": "import java.io.*;\n\npublic class PeanoCurve {\n    public static void main(final String[] args) {\n        try (Writer writer = new BufferedWriter(new FileWriter(\"peano_curve.svg\"))) {\n            PeanoCurve s = new PeanoCurve(writer);\n            final int length = 8;\n            s.currentAngle = 90;\n            s.currentX = length;\n            s.currentY = length;\n            s.lineLength = length;\n            s.begin(656);\n            s.execute(rewrite(4));\n            s.end();\n        } catch (final Exception ex) {\n            ex.printStackTrace();\n        }\n    }\n\n    private PeanoCurve(final Writer writer) {\n        this.writer = writer;\n    }\n\n    private void begin(final int size) throws IOException {\n        write(\"<svg xmlns='http:\n        write(\"<rect width='100%%' height='100%%' fill='white'/>\\n\");\n        write(\"<path stroke-width='1' stroke='black' fill='none' d='\");\n    }\n\n    private void end() throws IOException {\n        write(\"'/>\\n</svg>\\n\");\n    }\n\n    private void execute(final String s) throws IOException {\n        write(\"M%g,%g\\n\", currentX, currentY);\n        for (int i = 0, n = s.length(); i < n; ++i) {\n            switch (s.charAt(i)) {\n                case 'F':\n                    line(lineLength);\n                    break;\n                case '+':\n                    turn(ANGLE);\n                    break;\n                case '-':\n                    turn(-ANGLE);\n                    break;\n            }\n        }\n    }\n\n    private void line(final double length) throws IOException {\n        final double theta = (Math.PI * currentAngle) / 180.0;\n        currentX += length * Math.cos(theta);\n        currentY += length * Math.sin(theta);\n        write(\"L%g,%g\\n\", currentX, currentY);\n    }\n\n    private void turn(final int angle) {\n        currentAngle = (currentAngle + angle) % 360;\n    }\n\n    private void write(final String format, final Object... args) throws IOException {\n        writer.write(String.format(format, args));\n    }\n\n    private static String rewrite(final int order) {\n        String s = \"L\";\n        for (int i = 0; i < order; ++i) {\n            final StringBuilder sb = new StringBuilder();\n            for (int j = 0, n = s.length(); j < n; ++j) {\n                final char ch = s.charAt(j);\n                if (ch == 'L')\n                    sb.append(\"LFRFL-F-RFLFR+F+LFRFL\");\n                else if (ch == 'R')\n                    sb.append(\"RFLFR+F+LFRFL-F-RFLFR\");\n                else\n                    sb.append(ch);\n            }\n            s = sb.toString();\n        }\n        return s;\n    }\n\n    private final Writer writer;\n    private double lineLength;\n    private double currentX;\n    private double currentY;\n    private int currentAngle;\n    private static final int ANGLE = 90;\n}\n"}
{"id": 354251, "name": "First 9 prime Fibonacci number", "source": "Translate Ruby to Java: require 'prime'\n\nprime_fibs = Enumerator.new do |y|\n  a, b = 1, 1\n  loop do\n    y << a if a.prime?\n    a, b = b, a + b\n  end\nend\nputs prime_fibs.take(9)\n", "target": "import java.math.BigInteger;\n\npublic class PrimeFibonacciGenerator {\n    private PrimeGenerator primeGen = new PrimeGenerator(10000, 200000);\n    private BigInteger f0 = BigInteger.ZERO;\n    private BigInteger f1 = BigInteger.ONE;\n    private int index = 0;\n\n    public static void main(String[] args) {\n        PrimeFibonacciGenerator gen = new PrimeFibonacciGenerator();\n        long start = System.currentTimeMillis();\n        for (int i = 1; i <= 26; ++i) {\n            BigInteger f = gen.next();\n            System.out.printf(\"%d: F(%d) = %s\\n\", i, gen.index - 1, toString(f));\n        }\n        long finish = System.currentTimeMillis();\n        System.out.printf(\"elapsed time: %g seconds\\n\", (finish - start)/1000.0);\n    }\n\n    private PrimeFibonacciGenerator() {\n        for (int i = 0; i < 2; ++i)\n            primeGen.nextPrime();\n    }\n\n    private BigInteger next() {\n        for (;;) {\n            if (index > 4) {\n                int p = primeGen.nextPrime();\n                for (; p > index; ++index)\n                    nextFibonacci();\n            }\n            ++index;\n            BigInteger f = nextFibonacci();\n            if (f.isProbablePrime(30))\n                return f;\n        }\n    }\n\n    private BigInteger nextFibonacci() {\n        BigInteger result = f0;\n        BigInteger f = f0.add(f1);\n        f0 = f1;\n        f1 = f;\n        return result;\n    }\n\n    private static String toString(BigInteger f) {\n        String str = f.toString();\n        if (str.length() > 40) {\n            StringBuilder s = new StringBuilder(str.substring(0, 20));\n            s.append(\"...\");\n            s.append(str.substring(str.length() - 20));\n            s.append(\" (\");\n            s.append(str.length());\n            s.append(\" digits)\");\n            str = s.toString();\n        }\n        return str;\n    }\n}\n"}
{"id": 354252, "name": "First 9 prime Fibonacci number", "source": "Translate Ruby to Java: require 'prime'\n\nprime_fibs = Enumerator.new do |y|\n  a, b = 1, 1\n  loop do\n    y << a if a.prime?\n    a, b = b, a + b\n  end\nend\nputs prime_fibs.take(9)\n", "target": "import java.math.BigInteger;\n\npublic class PrimeFibonacciGenerator {\n    private PrimeGenerator primeGen = new PrimeGenerator(10000, 200000);\n    private BigInteger f0 = BigInteger.ZERO;\n    private BigInteger f1 = BigInteger.ONE;\n    private int index = 0;\n\n    public static void main(String[] args) {\n        PrimeFibonacciGenerator gen = new PrimeFibonacciGenerator();\n        long start = System.currentTimeMillis();\n        for (int i = 1; i <= 26; ++i) {\n            BigInteger f = gen.next();\n            System.out.printf(\"%d: F(%d) = %s\\n\", i, gen.index - 1, toString(f));\n        }\n        long finish = System.currentTimeMillis();\n        System.out.printf(\"elapsed time: %g seconds\\n\", (finish - start)/1000.0);\n    }\n\n    private PrimeFibonacciGenerator() {\n        for (int i = 0; i < 2; ++i)\n            primeGen.nextPrime();\n    }\n\n    private BigInteger next() {\n        for (;;) {\n            if (index > 4) {\n                int p = primeGen.nextPrime();\n                for (; p > index; ++index)\n                    nextFibonacci();\n            }\n            ++index;\n            BigInteger f = nextFibonacci();\n            if (f.isProbablePrime(30))\n                return f;\n        }\n    }\n\n    private BigInteger nextFibonacci() {\n        BigInteger result = f0;\n        BigInteger f = f0.add(f1);\n        f0 = f1;\n        f1 = f;\n        return result;\n    }\n\n    private static String toString(BigInteger f) {\n        String str = f.toString();\n        if (str.length() > 40) {\n            StringBuilder s = new StringBuilder(str.substring(0, 20));\n            s.append(\"...\");\n            s.append(str.substring(str.length() - 20));\n            s.append(\" (\");\n            s.append(str.length());\n            s.append(\" digits)\");\n            str = s.toString();\n        }\n        return str;\n    }\n}\n"}
{"id": 354253, "name": "Bioinformatics_base count", "source": "Translate Ruby to Java: dna = <<DNA_STR\nCGTAAAAAATTACAACGTCCTTTGGCTATCTCTTAAACTCCTGCTAAATG\nCTCGTGCTTTCCAATTATGTAAGCGTTCCGAGACGGGGTGGTCGATTCTG\nAGGACAAAGGTCAAGATGGAGCGCATCGAACGCAATAAGGATCATTTGAT\nGGGACGTTTCGTCGACAAAGTCTTGTTTCGAGAGTAACGGCTACCGTCTT\nCGATTCTGCTTATAACACTATGTTCTTATGAAATGGATGTTCTGAGTTGG\nTCAGTCCCAATGTGCGGGGTTTCTTTTAGTACGTCGGGAGTGGTATTATA\nTTTAATTTTTCTATATAGCGATCTGTATTTAAGCAATTCATTTAGGTTAT\nCGCCGCGATGCTCGGTTCGGACCGCCAAGCATCTGGCTCCACTGCTAGTG\nTCCTAAATTTGAATGGCAAACACAAATAAGATTTAGCAATTCGTGTAGAC\nGACCGGGGACTTGCATGATGGGAGCAGCTTTGTTAAACTACGAACGTAAT\nDNA_STR\n\nchunk_size = 60\ndna        = dna.delete(\"\\n\")\nsize       = dna.size\n\n0.step(size, chunk_size) do |pos|\n  puts \"\nend\n\nputs dna.chars.tally.sort.map{|ar| ar.join(\"\u00a0: \") }\nputs \"Total\u00a0: \n", "target": "import java.util.HashMap;\nimport java.util.Map;\n\npublic class orderedSequence {\n    public static void main(String[] args) {\n        Sequence gene = new Sequence(\"CGTAAAAAATTACAACGTCCTTTGGCTATCTCTTAAACTCCTGCTAAATGCTCGTGCTTTCCAATTATGTAAGCGTTCCGAGACGGGGTGGTCGATTCTGAGGACAAAGGTCAAGATGGAGCGCATCGAACGCAATAAGGATCATTTGATGGGACGTTTCGTCGACAAAGTCTTGTTTCGAGAGTAACGGCTACCGTCTTCGATTCTGCTTATAACACTATGTTCTTATGAAATGGATGTTCTGAGTTGGTCAGTCCCAATGTGCGGGGTTTCTTTTAGTACGTCGGGAGTGGTATTATATTTAATTTTTCTATATAGCGATCTGTATTTAAGCAATTCATTTAGGTTATCGCCGCGATGCTCGGTTCGGACCGCCAAGCATCTGGCTCCACTGCTAGTGTCCTAAATTTGAATGGCAAACACAAATAAGATTTAGCAATTCGTGTAGACGACCGGGGACTTGCATGATGGGAGCAGCTTTGTTAAACTACGAACGTAAT\");\n        gene.runSequence();\n    }\n}\n\n\npublic class Sequence {\n    \n    private final String seq;\n    \n    public Sequence(String sq) {\n        this.seq = sq;\n    }\n    \n    \n    public void prettyPrint() {\n        System.out.println(\"Sequence:\");\n        int i = 0;\n        for ( ; i < seq.length() - 50 ; i += 50) {\n            System.out.printf(\"%5s\u00a0: %s\\n\", i + 50, seq.substring(i, i + 50));\n        }\n        System.out.printf(\"%5s\u00a0: %s\\n\", seq.length(), seq.substring(i));\n    }\n    \n    \n    public void displayCount() {\n        Map<Character, Integer> counter = new HashMap<>();\n        for (int i = 0 ; i < seq.length() ; ++i) {\n            counter.merge(seq.charAt(i), 1, Integer::sum);\n        }\n\n        System.out.println(\"Base vs. Count:\");\n        counter.forEach(\n            key, value -> System.out.printf(\"%5s\u00a0: %s\\n\", key, value));\n        System.out.printf(\"%5s: %s\\n\", \"SUM\", seq.length());\n    }\n    \n    public void runSequence() {\n        this.prettyPrint();\n        this.displayCount();\n    }\n}\n"}
{"id": 354254, "name": "Bioinformatics_base count", "source": "Translate Ruby to Java: dna = <<DNA_STR\nCGTAAAAAATTACAACGTCCTTTGGCTATCTCTTAAACTCCTGCTAAATG\nCTCGTGCTTTCCAATTATGTAAGCGTTCCGAGACGGGGTGGTCGATTCTG\nAGGACAAAGGTCAAGATGGAGCGCATCGAACGCAATAAGGATCATTTGAT\nGGGACGTTTCGTCGACAAAGTCTTGTTTCGAGAGTAACGGCTACCGTCTT\nCGATTCTGCTTATAACACTATGTTCTTATGAAATGGATGTTCTGAGTTGG\nTCAGTCCCAATGTGCGGGGTTTCTTTTAGTACGTCGGGAGTGGTATTATA\nTTTAATTTTTCTATATAGCGATCTGTATTTAAGCAATTCATTTAGGTTAT\nCGCCGCGATGCTCGGTTCGGACCGCCAAGCATCTGGCTCCACTGCTAGTG\nTCCTAAATTTGAATGGCAAACACAAATAAGATTTAGCAATTCGTGTAGAC\nGACCGGGGACTTGCATGATGGGAGCAGCTTTGTTAAACTACGAACGTAAT\nDNA_STR\n\nchunk_size = 60\ndna        = dna.delete(\"\\n\")\nsize       = dna.size\n\n0.step(size, chunk_size) do |pos|\n  puts \"\nend\n\nputs dna.chars.tally.sort.map{|ar| ar.join(\"\u00a0: \") }\nputs \"Total\u00a0: \n", "target": "import java.util.HashMap;\nimport java.util.Map;\n\npublic class orderedSequence {\n    public static void main(String[] args) {\n        Sequence gene = new Sequence(\"CGTAAAAAATTACAACGTCCTTTGGCTATCTCTTAAACTCCTGCTAAATGCTCGTGCTTTCCAATTATGTAAGCGTTCCGAGACGGGGTGGTCGATTCTGAGGACAAAGGTCAAGATGGAGCGCATCGAACGCAATAAGGATCATTTGATGGGACGTTTCGTCGACAAAGTCTTGTTTCGAGAGTAACGGCTACCGTCTTCGATTCTGCTTATAACACTATGTTCTTATGAAATGGATGTTCTGAGTTGGTCAGTCCCAATGTGCGGGGTTTCTTTTAGTACGTCGGGAGTGGTATTATATTTAATTTTTCTATATAGCGATCTGTATTTAAGCAATTCATTTAGGTTATCGCCGCGATGCTCGGTTCGGACCGCCAAGCATCTGGCTCCACTGCTAGTGTCCTAAATTTGAATGGCAAACACAAATAAGATTTAGCAATTCGTGTAGACGACCGGGGACTTGCATGATGGGAGCAGCTTTGTTAAACTACGAACGTAAT\");\n        gene.runSequence();\n    }\n}\n\n\npublic class Sequence {\n    \n    private final String seq;\n    \n    public Sequence(String sq) {\n        this.seq = sq;\n    }\n    \n    \n    public void prettyPrint() {\n        System.out.println(\"Sequence:\");\n        int i = 0;\n        for ( ; i < seq.length() - 50 ; i += 50) {\n            System.out.printf(\"%5s\u00a0: %s\\n\", i + 50, seq.substring(i, i + 50));\n        }\n        System.out.printf(\"%5s\u00a0: %s\\n\", seq.length(), seq.substring(i));\n    }\n    \n    \n    public void displayCount() {\n        Map<Character, Integer> counter = new HashMap<>();\n        for (int i = 0 ; i < seq.length() ; ++i) {\n            counter.merge(seq.charAt(i), 1, Integer::sum);\n        }\n\n        System.out.println(\"Base vs. Count:\");\n        counter.forEach(\n            key, value -> System.out.printf(\"%5s\u00a0: %s\\n\", key, value));\n        System.out.printf(\"%5s: %s\\n\", \"SUM\", seq.length());\n    }\n    \n    public void runSequence() {\n        this.prettyPrint();\n        this.displayCount();\n    }\n}\n"}
{"id": 354255, "name": "Ulam spiral (for primes)", "source": "Translate Ruby to Java: enum Direction\n  RIGHT\n  UP\n  LEFT\n  DOWN\nend\n\ndef generate(n : Int32, i : Int32, c : Int32 | String)\n  s = Array.new(n) { Array.new(n) { \"\" } }\n\n  dir = Direction::RIGHT\n  y = n // 2\n  x = n % 2 == 0 ? y - 1 : y\n\n  j = 1\n  while j <= n * n - 1 + i\n    s[y][x] = is_prime(j) ? j.to_s : c.to_s\n\n    \n\n    case dir\n    when Direction::RIGHT\n      dir = Direction::UP if x <= n - 1 && s[y - 1][x] == \"\" && j > i\n    when Direction::UP\n      dir = Direction::LEFT if s[y][x - 1] == \"\"\n    when Direction::LEFT\n      dir = Direction::DOWN if x == 0 || s[y + 1][x] == \"\"\n    when Direction::DOWN\n      dir = Direction::RIGHT if s[y][x + 1] == \"\"\n    end\n\n    case dir\n    when Direction::RIGHT\n      x += 1\n    when Direction::UP\n      y -= 1\n    when Direction::LEFT\n      x -= 1\n    when Direction::DOWN\n      y += 1\n    end\n\n    j += 1\n  end\n\n  s.map(&.join(\"\\t\")).join(\"\\n\")\nend\n\ndef is_prime(n : Int32) : Bool\n  return true if n == 2\n  return false if n % 2 == 0 || n < 1\n\n  i = 3\n  while i <= Math.sqrt(n)\n    return false if n % i == 0\n    i += 2\n  end\n\n  true\nend\n\nputs generate 7, 1, \"*\"\n", "target": "import java.util.Arrays;\n\npublic class Ulam{\n\tenum Direction{\n\t\tRIGHT, UP, LEFT, DOWN;\n\t}\n\t\n\tprivate static String[][] genUlam(int n){\n\t\treturn genUlam(n, 1);\n\t}\n\n\tprivate static String[][] genUlam(int n, int i){\n\t\tString[][] spiral = new String[n][n];\n\t\tDirection dir = Direction.RIGHT;\n\t\tint j = i;\n\t\tint y = n / 2;\n\t\tint x = (n % 2 == 0) ? y - 1 : y; \n\t\twhile(j <= ((n * n) - 1 + i)){\n\t\t\tspiral[y][x] = isPrime(j) ? String.format(\"%4d\", j) : \" ---\";\n\n\t\t\tswitch(dir){\n\t\t\tcase RIGHT:\n\t\t\t\tif(x <= (n - 1) && spiral[y - 1][x] == null && j > i) dir = Direction.UP; break;\n\t\t\tcase UP:\n\t\t\t\tif(spiral[y][x - 1] == null) dir = Direction.LEFT; break;\n\t\t\tcase LEFT:\n\t\t\t\tif(x == 0 || spiral[y + 1][x] == null) dir = Direction.DOWN; break;\n\t\t\tcase DOWN:\n\t\t\t\tif(spiral[y][x + 1] == null) dir = Direction.RIGHT; break;\n\t\t\t}\n\t\t\t\n\t\t\tswitch(dir){\n\t\t\t\tcase RIGHT:\tx++; break;\n\t\t\t\tcase UP: \ty--; break;\n\t\t\t\tcase LEFT:\tx--; break;\n\t\t\t\tcase DOWN:\ty++; break;\n\t\t\t}\n\t\t\tj++;\n\t\t}\n\t\treturn spiral;\n\t}\n\t\n\tpublic static boolean isPrime(int a){\n\t\t   if(a == 2) return true;\n\t\t   if(a <= 1 || a % 2 == 0) return false;\n\t\t   long max = (long)Math.sqrt(a);\n\t\t   for(long n = 3; n <= max; n += 2){\n\t\t      if(a % n == 0) return false;\n\t\t   }\n\t\t   return true;\n\t\t}\n\t\n\tpublic static void main(String[] args){\n\t\tString[][] ulam = genUlam(9);\n\t\tfor(String[] row : ulam){\n\t\t\tSystem.out.println(Arrays.toString(row).replaceAll(\",\", \"\"));\n\t\t}\n\t\tSystem.out.println();\n\t\t\n\t\tfor(String[] row : ulam){\n\t\t\tSystem.out.println(Arrays.toString(row).replaceAll(\"\\\\[\\\\s+\\\\d+\", \"[  * \").replaceAll(\"\\\\s+\\\\d+\", \"   * \").replaceAll(\",\", \"\"));\n\t\t}\n\t}\n}\n"}
{"id": 354256, "name": "Fibonacci word", "source": "Translate Ruby to Java: \n\ndef entropy(s)\n  counts = Hash.new(0.0)\n  s.each_char { |c| counts[c] += 1 }\n  leng = s.length\n  \n  counts.values.reduce(0) do |entropy, count|\n    freq = count / leng\n    entropy - freq * Math.log2(freq)\n  end\nend\n\nn_max = 37\nwords = ['1', '0']\n\nfor n in words.length ... n_max\n  words << words[-1] + words[-2]\nend\n\nputs '%3s %9s %15s  %s' % %w[N Length Entropy Fibword]\nwords.each.with_index(1) do |word, i|\n  puts '%3i %9i %15.12f  %s' % [i, word.length, entropy(word), word.length<60 ? word : '<too long>']\nend\n", "target": "import java.util.*;\n\npublic class FWord {\n    private  String fWord0 = \"\";\n    private  String fWord1 = \"\";\n\n    private String nextFWord () {\n        final String result;\n        \n        if ( \"\".equals ( fWord1 ) )      result = \"1\";\n        else if ( \"\".equals ( fWord0 ) ) result = \"0\";\n        else                             result = fWord1 + fWord0;\n\n        fWord0 = fWord1;\n        fWord1 = result;\n\n        return result;\n    }\n\n    public static double entropy ( final String source ) {\n        final int                        length = source.length ();\n        final Map < Character, Integer > counts = new HashMap < Character, Integer > ();\n         double                     result = 0.0;\n \n        for ( int i = 0; i < length; i++ ) {\n            final char c = source.charAt ( i );\n\n            if ( counts.containsKey ( c ) ) counts.put ( c, counts.get ( c ) + 1 );\n            else                            counts.put ( c, 1 );\n        }\n\n        for ( final int count : counts.values () ) {\n            final double proportion = ( double ) count / length;\n\n            result -= proportion * ( Math.log ( proportion ) / Math.log ( 2 ) );\n        }\n\n        return result;\n    }\n\n    public static void main ( final String [] args ) {\n        final FWord fWord = new FWord ();\n\n        for ( int i = 0; i < 37;  ) {\n            final String word = fWord.nextFWord ();\n\n            System.out.printf ( \"%3d %10d %s %n\", ++i, word.length (), entropy ( word ) );\n        }\n    }\n}\n"}
{"id": 354257, "name": "Fibonacci word", "source": "Translate Ruby to Java: \n\ndef entropy(s)\n  counts = Hash.new(0.0)\n  s.each_char { |c| counts[c] += 1 }\n  leng = s.length\n  \n  counts.values.reduce(0) do |entropy, count|\n    freq = count / leng\n    entropy - freq * Math.log2(freq)\n  end\nend\n\nn_max = 37\nwords = ['1', '0']\n\nfor n in words.length ... n_max\n  words << words[-1] + words[-2]\nend\n\nputs '%3s %9s %15s  %s' % %w[N Length Entropy Fibword]\nwords.each.with_index(1) do |word, i|\n  puts '%3i %9i %15.12f  %s' % [i, word.length, entropy(word), word.length<60 ? word : '<too long>']\nend\n", "target": "import java.util.*;\n\npublic class FWord {\n    private  String fWord0 = \"\";\n    private  String fWord1 = \"\";\n\n    private String nextFWord () {\n        final String result;\n        \n        if ( \"\".equals ( fWord1 ) )      result = \"1\";\n        else if ( \"\".equals ( fWord0 ) ) result = \"0\";\n        else                             result = fWord1 + fWord0;\n\n        fWord0 = fWord1;\n        fWord1 = result;\n\n        return result;\n    }\n\n    public static double entropy ( final String source ) {\n        final int                        length = source.length ();\n        final Map < Character, Integer > counts = new HashMap < Character, Integer > ();\n         double                     result = 0.0;\n \n        for ( int i = 0; i < length; i++ ) {\n            final char c = source.charAt ( i );\n\n            if ( counts.containsKey ( c ) ) counts.put ( c, counts.get ( c ) + 1 );\n            else                            counts.put ( c, 1 );\n        }\n\n        for ( final int count : counts.values () ) {\n            final double proportion = ( double ) count / length;\n\n            result -= proportion * ( Math.log ( proportion ) / Math.log ( 2 ) );\n        }\n\n        return result;\n    }\n\n    public static void main ( final String [] args ) {\n        final FWord fWord = new FWord ();\n\n        for ( int i = 0; i < 37;  ) {\n            final String word = fWord.nextFWord ();\n\n            System.out.printf ( \"%3d %10d %s %n\", ++i, word.length (), entropy ( word ) );\n        }\n    }\n}\n"}
{"id": 354258, "name": "Death Star", "source": "Translate Ruby to Java: func hitf(sph, x, y) {\n    x -= sph[0]\n    y -= sph[1]\n\n    var z = (sph[3]**2 - (x**2 + y**2))\n\n    z < 0 && return nil\n\n    z.sqrt!\n    [sph[2] - z, sph[2] + z]\n}\n\nfunc normalize(v) {\n    v / v.abs\n}\n\nfunc dot(x, y) {\n    max(0, x*y)\n}\n\nvar pos = [120, 120, 0, 120]\nvar neg = [-77, -33, -100, 190]\nvar light = normalize(Vector(-12, 13, -10))\n\nfunc draw(k, amb) {\n    STDOUT.binmode(':raw')\n    print (\"P5\\n\", pos[0]*2 + 3, \" \", pos[1]*2 + 3, \"\\n255\\n\")\n\n    for y in ((pos[1] - pos[3] - 1) .. (pos[1] + pos[3] + 1)) {\n        var row = []\n        for x in ((pos[0] - pos[3] - 1) .. (pos[0] + pos[3] + 1)) {\n\n            var hit = 0\n            var hs = []\n            var h = hitf(pos, x, y)\n\n            if    (!h)                      { hit = 0; h  = [0, 0] }\n            elsif (!(hs = hitf(neg, x, y))) { hit = 1; hs = [0, 0] }\n            elsif (hs[0] > h[0])            { hit = 1 }\n            elsif (hs[1] > h[0])            { hit = (hs[1] > h[1] ? 0 : 2) }\n            else                            { hit = 1 }\n\n            var (val, v)\n\n            given(hit) {\n                when (0) { val = 0}\n                when (1) { v = Vector(x-pos[0], y-pos[1], h[0]-pos[2]) }\n                default  { v = Vector(neg[0]-x, neg[1]-y, neg[2]-hs[1]) }\n            }\n\n            if (defined(v)) {\n                v = normalize(v)\n                val = int((dot(v, light)**k + amb) * 255)\n                val = (val > 255 ? 255 : (val < 0 ? 0 : val))\n            }\n            row.append(val)\n        }\n        print 'C*'.pack(row...)\n    }\n}\n\ndraw(2, 0.2)\n", "target": "import javafx.application.Application;\nimport javafx.event.EventHandler;\nimport javafx.geometry.Point3D;\nimport javafx.scene.Group;\nimport javafx.scene.Scene;\nimport javafx.scene.input.KeyCode;\nimport javafx.scene.input.KeyEvent;\nimport javafx.scene.shape.MeshView;\nimport javafx.scene.shape.TriangleMesh;\nimport javafx.scene.transform.Rotate;\nimport javafx.stage.Stage;\npublic class DeathStar extends Application {\n\n\tprivate static final int DIVISION = 200;\n\tfloat radius = 300;\n\n\t@Override\n\tpublic void start(Stage primaryStage) throws Exception {\n\t\tPoint3D otherSphere = new Point3D(-radius, 0, -radius * 1.5);\n\t\tfinal TriangleMesh triangleMesh = createMesh(DIVISION, radius, otherSphere);\n\t\tMeshView a = new MeshView(triangleMesh);\n\n\t\ta.setTranslateY(radius);\n\t\ta.setTranslateX(radius);\n\t\ta.setRotationAxis(Rotate.Y_AXIS);\n\t\tScene scene = new Scene(new Group(a));\n\n\t\t\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\t\tprimaryStage.setScene(scene);\n\t\tprimaryStage.show();\n\t}\n\n\tstatic TriangleMesh createMesh(final int division, final float radius, final Point3D centerOtherSphere) {\n\t\tRotate rotate = new Rotate(180, centerOtherSphere);\n\t\tfinal int div2 = division / 2;\n\n\t\tfinal int nPoints = division * (div2 - 1) + 2;\n\t\tfinal int nTPoints = (division + 1) * (div2 - 1) + division * 2;\n\t\tfinal int nFaces = division * (div2 - 2) * 2 + division * 2;\n\n\t\tfinal float rDiv = 1.f / division;\n\n\t\tfloat points[] = new float[nPoints * 3];\n\t\tfloat tPoints[] = new float[nTPoints * 2];\n\t\tint faces[] = new int[nFaces * 6];\n\n\t\tint pPos = 0, tPos = 0;\n\n\t\tfor (int y = 0; y < div2 - 1; ++y) {\n\t\t\tfloat va = rDiv * (y + 1 - div2 / 2) * 2 * (float) Math.PI;\n\t\t\tfloat sin_va = (float) Math.sin(va);\n\t\t\tfloat cos_va = (float) Math.cos(va);\n\n\t\t\tfloat ty = 0.5f + sin_va * 0.5f;\n\t\t\tfor (int i = 0; i < division; ++i) {\n\t\t\t\tdouble a = rDiv * i * 2 * (float) Math.PI;\n\t\t\t\tfloat hSin = (float) Math.sin(a);\n\t\t\t\tfloat hCos = (float) Math.cos(a);\n\t\t\t\tpoints[pPos + 0] = hSin * cos_va * radius;\n\t\t\t\tpoints[pPos + 2] = hCos * cos_va * radius;\n\t\t\t\tpoints[pPos + 1] = sin_va * radius;\n\n\t\t\t\tfinal Point3D point3D = new Point3D(points[pPos + 0], points[pPos + 1], points[pPos + 2]);\n\t\t\t\tdouble distance = centerOtherSphere.distance(point3D);\n\t\t\t\tif (distance <= radius) {\n\t\t\t\t\tPoint3D subtract = centerOtherSphere.subtract(point3D);\n\t\t\t\t\tPoint3D transform = rotate.transform(subtract);\n\t\t\t\t\tpoints[pPos + 0] = (float) transform.getX();\n\t\t\t\t\tpoints[pPos + 1] = (float) transform.getY();\n\t\t\t\t\tpoints[pPos + 2] = (float) transform.getZ();\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\ttPoints[tPos + 0] = 1 - rDiv * i;\n\t\t\t\ttPoints[tPos + 1] = ty;\n\t\t\t\tpPos += 3;\n\t\t\t\ttPos += 2;\n\t\t\t}\n\t\t\ttPoints[tPos + 0] = 0;\n\t\t\ttPoints[tPos + 1] = ty;\n\t\t\ttPos += 2;\n\t\t}\n\n\t\tpoints[pPos + 0] = 0;\n\t\tpoints[pPos + 1] = -radius;\n\t\tpoints[pPos + 2] = 0;\n\t\tpoints[pPos + 3] = 0;\n\t\tpoints[pPos + 4] = radius;\n\t\tpoints[pPos + 5] = 0;\n\t\tpPos += 6;\n\n\t\tint pS = (div2 - 1) * division;\n\n\t\tfloat textureDelta = 1.f / 256;\n\t\tfor (int i = 0; i < division; ++i) {\n\t\t\ttPoints[tPos + 0] = rDiv * (0.5f + i);\n\t\t\ttPoints[tPos + 1] = textureDelta;\n\t\t\ttPos += 2;\n\t\t}\n\n\t\tfor (int i = 0; i < division; ++i) {\n\t\t\ttPoints[tPos + 0] = rDiv * (0.5f + i);\n\t\t\ttPoints[tPos + 1] = 1 - textureDelta;\n\t\t\ttPos += 2;\n\t\t}\n\n\t\tint fIndex = 0;\n\t\tfor (int y = 0; y < div2 - 2; ++y) {\n\t\t\tfor (int x = 0; x < division; ++x) {\n\t\t\t\tint p0 = y * division + x;\n\t\t\t\tint p1 = p0 + 1;\n\t\t\t\tint p2 = p0 + division;\n\t\t\t\tint p3 = p1 + division;\n\n\t\t\t\tint t0 = p0 + y;\n\t\t\t\tint t1 = t0 + 1;\n\t\t\t\tint t2 = t0 + division + 1;\n\t\t\t\tint t3 = t1 + division + 1;\n\n\t\t\t\t\n\t\t\t\tfaces[fIndex + 0] = p0;\n\t\t\t\tfaces[fIndex + 1] = t0;\n\t\t\t\tfaces[fIndex + 2] = p1 % division == 0 ? p1 - division : p1;\n\t\t\t\tfaces[fIndex + 3] = t1;\n\t\t\t\tfaces[fIndex + 4] = p2;\n\t\t\t\tfaces[fIndex + 5] = t2;\n\t\t\t\tfIndex += 6;\n\n\t\t\t\t\n\t\t\t\tfaces[fIndex + 0] = p3 % division == 0 ? p3 - division : p3;\n\t\t\t\tfaces[fIndex + 1] = t3;\n\t\t\t\tfaces[fIndex + 2] = p2;\n\t\t\t\tfaces[fIndex + 3] = t2;\n\t\t\t\tfaces[fIndex + 4] = p1 % division == 0 ? p1 - division : p1;\n\t\t\t\tfaces[fIndex + 5] = t1;\n\t\t\t\tfIndex += 6;\n\t\t\t}\n\t\t}\n\n\t\tint p0 = pS;\n\t\tint tB = (div2 - 1) * (division + 1);\n\t\tfor (int x = 0; x < division; ++x) {\n\t\t\tint p2 = x, p1 = x + 1, t0 = tB + x;\n\t\t\tfaces[fIndex + 0] = p0;\n\t\t\tfaces[fIndex + 1] = t0;\n\t\t\tfaces[fIndex + 2] = p1 == division ? 0 : p1;\n\t\t\tfaces[fIndex + 3] = p1;\n\t\t\tfaces[fIndex + 4] = p2;\n\t\t\tfaces[fIndex + 5] = p2;\n\t\t\tfIndex += 6;\n\t\t}\n\n\t\tp0 = p0 + 1;\n\t\ttB = tB + division;\n\t\tint pB = (div2 - 2) * division;\n\n\t\tfor (int x = 0; x < division; ++x) {\n\t\t\tint p1 = pB + x, p2 = pB + x + 1, t0 = tB + x;\n\t\t\tint t1 = (div2 - 2) * (division + 1) + x, t2 = t1 + 1;\n\t\t\tfaces[fIndex + 0] = p0;\n\t\t\tfaces[fIndex + 1] = t0;\n\t\t\tfaces[fIndex + 2] = p1;\n\t\t\tfaces[fIndex + 3] = t1;\n\t\t\tfaces[fIndex + 4] = p2 % division == 0 ? p2 - division : p2;\n\t\t\tfaces[fIndex + 5] = t2;\n\t\t\tfIndex += 6;\n\t\t}\n\n\t\tTriangleMesh m = new TriangleMesh();\n\t\tm.getPoints().setAll(points);\n\t\tm.getTexCoords().setAll(tPoints);\n\t\tm.getFaces().setAll(faces);\n\n\t\treturn m;\n\t}\n\n\tpublic static void main(String[] args) {\n\n\t\tlaunch(args);\n\t}\n\n}\n"}
{"id": 354259, "name": "Colour pinstripe_Display", "source": "Translate Ruby to Java: require('GD')\n\nfunc pinstripes(width = 1280, height = 720) {\n\n    var im = %O<GD::Image>.new(width, height)\n    var colors = [0, 255].variations_with_repetition(3)\n\n    var paintcolors = colors.shuffle.map {|rgb|\n        im.colorAllocate(rgb...)\n    }\n\n    var starty     = 0\n    var barheight  = height//4\n\n    for barwidth in (1..4) {\n        for (\n            var(startx = 0, colorindex = 0);\n            startx + barwidth <= width;\n            startx += barwidth\n        ) {\n            im.filledRectangle(startx, starty, startx+barwidth,\n                starty + barheight - 1, paintcolors[colorindex++ % 8])\n        }\n        starty += barheight\n    }\n\n    return im\n}\n\nFile('pinstripes.png').write(pinstripes().png, :raw)\n", "target": "import java.awt.*;\nimport static java.awt.Color.*;\nimport javax.swing.*;\n\npublic class ColourPinstripeDisplay extends JPanel {\n    final static Color[] palette = {black, red, green, blue, magenta,cyan,\n        yellow, white};\n\n    final int bands = 4;\n\n    public ColourPinstripeDisplay() {\n        setPreferredSize(new Dimension(900, 600));\n    }\n\n    @Override\n    public void paintComponent(Graphics g) {\n        super.paintComponent(g);\n        int h = getHeight();\n        for (int b = 1; b <= bands; b++) {\n            for (int x = 0, colIndex = 0; x < getWidth(); x += b, colIndex++) {\n                g.setColor(palette[colIndex % palette.length]);\n                g.fillRect(x, (b - 1) * (h / bands), x + b, b * (h / bands));\n            }\n        }\n    }\n\n    public static void main(String[] args) {\n        SwingUtilities.invokeLater(() -> {\n            JFrame f = new JFrame();\n            f.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n            f.setTitle(\"ColourPinstripeDisplay\");\n            f.add(new ColourPinstripeDisplay(), BorderLayout.CENTER);\n            f.pack();\n            f.setLocationRelativeTo(null);\n            f.setVisible(true);\n        });\n    }\n}\n"}
{"id": 354260, "name": "Birthday problem", "source": "Translate Ruby to Java: def equalBirthdays(nSharers, groupSize, nRepetitions)\n    eq = 0\n\n    for i in 1 .. nRepetitions\n        group = [0] * 365\n        for j in 1 .. groupSize\n            group[rand(group.length)] += 1\n        end\n        eq += group.any? { |n| n >= nSharers } ? 1 : 0\n    end\n\n    return (eq * 100.0) / nRepetitions\nend\n\ndef main\n    groupEst = 2\n    for sharers in 2 .. 5\n        \n        groupSize = groupEst + 1\n        while equalBirthdays(sharers, groupSize, 100) < 50.0\n            groupSize += 1\n        end\n\n        \n        inf = (groupSize - (groupSize - groupEst) / 4.0).floor\n        for gs in inf .. groupSize + 999\n            eq = equalBirthdays(sharers, groupSize, 250)\n            if eq > 50.0 then\n                groupSize = gs\n                break\n            end\n        end\n\n        \n        for gs in groupSize - 1 .. groupSize + 999\n            eq = equalBirthdays(sharers, gs, 50000)\n            if eq > 50.0 then\n                groupEst = gs\n                print \"%d independant people in a group of %s share a common birthday. (%5.1f)\\n\" % [sharers, gs, eq]\n                break\n            end\n        end\n    end\nend\n\nmain()\n", "target": "import static java.util.Arrays.stream;\nimport java.util.Random;\n\npublic class Test {\n\n    static double equalBirthdays(int nSharers, int groupSize, int nRepetitions) {\n        Random rand = new Random(1);\n\n        int eq = 0;\n\n        for (int i = 0; i < nRepetitions; i++) {\n            int[] group = new int[365];\n            for (int j = 0; j < groupSize; j++)\n                group[rand.nextInt(group.length)]++;\n            eq += stream(group).anyMatch(c -> c >= nSharers) ? 1 : 0;\n        }\n\n        return (eq * 100.0) / nRepetitions;\n    }\n\n    public static void main(String[] a) {\n\n        int groupEst = 2;\n\n        for (int sharers = 2; sharers < 6; sharers++) {\n            \n            int groupSize = groupEst + 1;\n            while (equalBirthdays(sharers, groupSize, 100) < 50.0)\n                groupSize++;\n\n            \n            int inf = (int) (groupSize - (groupSize - groupEst) / 4.0);\n            for (int gs = inf; gs < groupSize + 999; gs++) {\n                double eq = equalBirthdays(sharers, groupSize, 250);\n                if (eq > 50.0) {\n                    groupSize = gs;\n                    break;\n                }\n            }\n\n            \n            for (int gs = groupSize - 1; gs < groupSize + 999; gs++) {\n                double eq = equalBirthdays(sharers, gs, 50_000);\n                if (eq > 50.0) {\n                    groupEst = gs;\n                    System.out.printf(\"%d independent people in a group of \"\n                            + \"%s share a common birthday. (%5.1f)%n\",\n                            sharers, gs, eq);\n                    break;\n                }\n            }\n        }\n    }\n}\n"}
{"id": 354261, "name": "Draw a sphere", "source": "Translate Ruby to Java: Shoes.app :width => 500, :height => 500, :resizable => false do\n  image 400, 470, :top => 30, :left => 50 do\n    nostroke\n    fill \"\n    image :top => 230, :left => 0 do\n      oval 70, 130, 260, 40\n      blur 30\n    end\n    oval 10, 10, 380, 380\n    image :top => 0, :left => 0 do\n      fill \"\n      oval 30, 30, 338, 338\n      blur 10\n    end\n    fill gradient(rgb(1.0, 1.0, 1.0, 0.7), rgb(1.0, 1.0, 1.0, 0.0))\n    oval 80, 14, 240, 176\n    image :top => 0, :left => 0 do\n      fill \"\n      oval 134, 134, 130, 130\n      blur 40\n    end\n    image :top => 150, :left => 40, :width => 320, :height => 260 do\n      fill gradient(rgb(0.7, 0.9, 1.0, 0.0), rgb(0.7, 0.9, 1.0, 0.6))\n      oval 60, 60, 200, 136\n      blur 20\n    end\n  end\nend\n", "target": "using System;\n\nnamespace Sphere {\n    internal class Program {\n        private const string Shades = \".:!*oe%&#@\";\n        private static readonly double[] Light = {30, 30, -50};\n\n        private static void Normalize(double[] v) {\n            double len = Math.Sqrt(v[0]*v[0] + v[1]*v[1] + v[2]*v[2]);\n            v[0] /= len;\n            v[1] /= len;\n            v[2] /= len;\n        }\n\n        private static double Dot(double[] x, double[] y) {\n            double d = x[0]*y[0] + x[1]*y[1] + x[2]*y[2];\n            return d < 0 ? -d : 0;\n        }\n\n        public static void DrawSphere(double r, double k, double ambient) {\n            var vec = new double[3];\n            for(var i = (int)Math.Floor(-r); i <= (int)Math.Ceiling(r); i++) {\n                double x = i + .5;\n                for(var j = (int)Math.Floor(-2*r); j <= (int)Math.Ceiling(2*r); j++) {\n                    double y = j/2.0 + .5;\n                    if(x*x + y*y <= r*r) {\n                        vec[0] = x;\n                        vec[1] = y;\n                        vec[2] = Math.Sqrt(r*r - x*x - y*y);\n                        Normalize(vec);\n                        double b = Math.Pow(Dot(Light, vec), k) + ambient;\n                        int intensity = (b <= 0)\n                                            ? Shades.Length - 2\n                                            : (int)Math.Max((1 - b)*(Shades.Length - 1), 0);\n                        Console.Write(Shades[intensity]);\n                    }\n                    else\n                        Console.Write(' ');\n                }\n                Console.WriteLine();\n            }\n        }\n\n        private static void Main() {\n            Normalize(Light);\n            DrawSphere(6, 4, .1);\n            DrawSphere(10, 2, .4);\n            Console.ReadKey();\n        }\n    }\n}\n"}
{"id": 354262, "name": "Draw a sphere", "source": "Translate Ruby to Java: Shoes.app :width => 500, :height => 500, :resizable => false do\n  image 400, 470, :top => 30, :left => 50 do\n    nostroke\n    fill \"\n    image :top => 230, :left => 0 do\n      oval 70, 130, 260, 40\n      blur 30\n    end\n    oval 10, 10, 380, 380\n    image :top => 0, :left => 0 do\n      fill \"\n      oval 30, 30, 338, 338\n      blur 10\n    end\n    fill gradient(rgb(1.0, 1.0, 1.0, 0.7), rgb(1.0, 1.0, 1.0, 0.0))\n    oval 80, 14, 240, 176\n    image :top => 0, :left => 0 do\n      fill \"\n      oval 134, 134, 130, 130\n      blur 40\n    end\n    image :top => 150, :left => 40, :width => 320, :height => 260 do\n      fill gradient(rgb(0.7, 0.9, 1.0, 0.0), rgb(0.7, 0.9, 1.0, 0.6))\n      oval 60, 60, 200, 136\n      blur 20\n    end\n  end\nend\n", "target": "using System;\n\nnamespace Sphere {\n    internal class Program {\n        private const string Shades = \".:!*oe%&#@\";\n        private static readonly double[] Light = {30, 30, -50};\n\n        private static void Normalize(double[] v) {\n            double len = Math.Sqrt(v[0]*v[0] + v[1]*v[1] + v[2]*v[2]);\n            v[0] /= len;\n            v[1] /= len;\n            v[2] /= len;\n        }\n\n        private static double Dot(double[] x, double[] y) {\n            double d = x[0]*y[0] + x[1]*y[1] + x[2]*y[2];\n            return d < 0 ? -d : 0;\n        }\n\n        public static void DrawSphere(double r, double k, double ambient) {\n            var vec = new double[3];\n            for(var i = (int)Math.Floor(-r); i <= (int)Math.Ceiling(r); i++) {\n                double x = i + .5;\n                for(var j = (int)Math.Floor(-2*r); j <= (int)Math.Ceiling(2*r); j++) {\n                    double y = j/2.0 + .5;\n                    if(x*x + y*y <= r*r) {\n                        vec[0] = x;\n                        vec[1] = y;\n                        vec[2] = Math.Sqrt(r*r - x*x - y*y);\n                        Normalize(vec);\n                        double b = Math.Pow(Dot(Light, vec), k) + ambient;\n                        int intensity = (b <= 0)\n                                            ? Shades.Length - 2\n                                            : (int)Math.Max((1 - b)*(Shades.Length - 1), 0);\n                        Console.Write(Shades[intensity]);\n                    }\n                    else\n                        Console.Write(' ');\n                }\n                Console.WriteLine();\n            }\n        }\n\n        private static void Main() {\n            Normalize(Light);\n            DrawSphere(6, 4, .1);\n            DrawSphere(10, 2, .4);\n            Console.ReadKey();\n        }\n    }\n}\n"}
{"id": 354263, "name": "Thiele's interpolation formula", "source": "Translate Ruby to Java: func thiele(x, y) {\n    var \u03c1 = {|i| [y[i]]*(y.len-i) }.map(^y)\n\u00a0\n    for i in ^(\u03c1.end) {\n        \u03c1[i][1] = ((x[i] - x[i+1]) / (\u03c1[i][0] - \u03c1[i+1][0]))\n    }\n    for i (2 .. \u03c1.end) {\n        for j (0 .. \u03c1.end-i) {\n            \u03c1[j][i] = (((x[j]-x[j+i]) / (\u03c1[j][i-1]-\u03c1[j+1][i-1])) + \u03c1[j+1][i-2])\n        }\n    }\n\u00a0\n    var \u03c10 = \u03c1[0]\n\u00a0\n    func t(xin) {\n        var a = 0\n        for i (\u03c10.len ^.. 2) {\n            a = ((xin - x[i-1]) / (\u03c10[i] - \u03c10[i-2] + a))\n        }\n        y[0] + ((xin-x[0]) / (\u03c10[1]+a))\n    }\n    return t\n}\n\u00a0\n\nvar xVal = {|k| k * 0.05 }.map(^32)\nvar tSin = xVal.map { .sin }\nvar tCos = xVal.map { .cos }\nvar tTan = xVal.map { .tan }\n\u00a0\n\nvar iSin = thiele(tSin, xVal)\nvar iCos = thiele(tCos, xVal)\nvar iTan = thiele(tTan, xVal)\n\u00a0\n\nsay 6*iSin(0.5)\nsay 3*iCos(0.5)\nsay 4*iTan(1)\n", "target": "import static java.lang.Math.*;\n\npublic class Test {\n    final static int N = 32;\n    final static int N2 = (N * (N - 1) / 2);\n    final static double STEP = 0.05;\n\n    static double[] xval = new double[N];\n    static double[] t_sin = new double[N];\n    static double[] t_cos = new double[N];\n    static double[] t_tan = new double[N];\n\n    static double[] r_sin = new double[N2];\n    static double[] r_cos = new double[N2];\n    static double[] r_tan = new double[N2];\n\n    static double rho(double[] x, double[] y, double[] r, int i, int n) {\n        if (n < 0)\n            return 0;\n\n        if (n == 0)\n            return y[i];\n\n        int idx = (N - 1 - n) * (N - n) / 2 + i;\n        if (r[idx] != r[idx])\n            r[idx] = (x[i] - x[i + n])\n                    / (rho(x, y, r, i, n - 1) - rho(x, y, r, i + 1, n - 1))\n                    + rho(x, y, r, i + 1, n - 2);\n\n        return r[idx];\n    }\n\n    static double thiele(double[] x, double[] y, double[] r, double xin, int n) {\n        if (n > N - 1)\n            return 1;\n        return rho(x, y, r, 0, n) - rho(x, y, r, 0, n - 2)\n                + (xin - x[n]) / thiele(x, y, r, xin, n + 1);\n    }\n\n    public static void main(String[] args) {\n        for (int i = 0; i < N; i++) {\n            xval[i] = i * STEP;\n            t_sin[i] = sin(xval[i]);\n            t_cos[i] = cos(xval[i]);\n            t_tan[i] = t_sin[i] / t_cos[i];\n        }\n\n        for (int i = 0; i < N2; i++)\n            r_sin[i] = r_cos[i] = r_tan[i] = Double.NaN;\n\n        System.out.printf(\"%16.14f%n\", 6 * thiele(t_sin, xval, r_sin, 0.5, 0));\n        System.out.printf(\"%16.14f%n\", 3 * thiele(t_cos, xval, r_cos, 0.5, 0));\n        System.out.printf(\"%16.14f%n\", 4 * thiele(t_tan, xval, r_tan, 1.0, 0));\n    }\n}\n"}
{"id": 354264, "name": "Longest string challenge", "source": "Translate Ruby to Java: \nBEGIN {\n   v = [ ]\n   m = 0\n}\n\nn = $_.length\nif n == m then\n   v <<= $_\nelsif n > m then\n   v = [$_]\n   m = n\nend\n\nEND {\n   v.each { |s| puts s }\n}\n", "target": "import java.io.File;\nimport java.util.Scanner;\n\npublic class LongestStringChallenge {\n\n    public static void main(String[] args) throws Exception {\n        String lines = \"\", longest = \"\";\n        try (Scanner sc = new Scanner(new File(\"lines.txt\"))) {\n            while(sc.hasNext()) {\n                String line = sc.nextLine();\n                if (longer(longest, line))\n                    lines = longest = line;\n                else if (!longer(line, longest))\n                    lines = lines.concat(\"\\n\").concat(line);\n            }\n        }\n        System.out.println(lines);\n    }\n\n    static boolean longer(String a, String b) {\n        try {\n            String dummy = a.substring(b.length());\n        } catch (StringIndexOutOfBoundsException e) {\n            return true;\n        }\n        return false;\n    }\n}\n"}
{"id": 354265, "name": "Sierpinski arrowhead curve", "source": "Translate Ruby to Java: load_libraries :grammar\nattr_reader :points\n\ndef setup\n  sketch_title 'Sierpinski Arrowhead'\n  sierpinski = SierpinskiArrowhead.new(Vec2D.new(width * 0.15, height * 0.7))\n  production = sierpinski.generate 6 \n  @points = sierpinski.translate_rules(production)\n  no_loop\nend\n  \ndef draw\n  background(0)\n  render points\nend\n\ndef render(points)\n  no_fill\n  stroke 200.0\n  stroke_weight 3\n  begin_shape\n  points.each_slice(2) do |v0, v1|\n    v0.to_vertex(renderer)\n    v1.to_vertex(renderer)\n  end\n  end_shape\nend\n\ndef renderer\n  @renderer ||= GfxRender.new(g)\nend \n\ndef settings  \n  size(800, 800)\nend\n\n\nclass SierpinskiArrowhead\n  include Processing::Proxy\n  attr_reader :draw_length, :pos, :theta, :axiom, :grammar\n  DELTA = PI / 3 \n  def initialize(pos)\n    @axiom = 'XF' \n    rules = {\n      'X' => 'YF+XF+Y',\n      'Y' => 'XF-YF-X'\n    }\n    @grammar = Grammar.new(axiom, rules)\n    @theta = 0\n    @draw_length = 200\n    @pos = pos\n  end\n\n  def generate(gen)\n    @draw_length = draw_length * 0.6**gen\n    grammar.generate gen\n  end\n\n  def forward(pos)\n    pos + Vec2D.from_angle(theta) * draw_length\n  end\n\n  def translate_rules(prod)\n    [].tap do |pts| \n      prod.scan(/./) do |ch|\n        case ch\n        when 'F'\n          new_pos = forward(pos)\n          pts << pos << new_pos\n          @pos = new_pos\n        when '+'\n          @theta += DELTA\n        when '-'\n          @theta -= DELTA\n        when 'X', 'Y'\n        else\n          puts(\"character \n        end\n      end\n    end\n  end\nend\n", "target": "final PVector t = new PVector(20, 30, 60);\n\nvoid setup() {\n  size(450, 400);\n  noLoop();\n  background(0, 0, 200);\n  stroke(-1);\n  sc(7, 400, -60, t);\n}\n\nPVector sc(int o, float l, final int a, final PVector s) {\n  if (o > 0) {\n    sc(--o, l *= .5, -a, s).z += a;\n    sc(o, l, a, s).z += a;\n    sc(o, l, -a, s);\n  } else line(s.x, s.y, \n    s.x += cos(radians(s.z)) * l, \n    s.y += sin(radians(s.z)) * l);\n  return s;\n}\n"}
{"id": 354266, "name": "Hello world_Line printer", "source": "Translate Ruby to Java: open(\"| lpr\", \"w\") { |f| f.puts \"Hello World!\" }\n", "target": "import java.io.FileWriter;\nimport java.io.IOException;\n \npublic class LinePrinter {\n  public static void main(String[] args) {\n    try {\n      FileWriter lp0 = new FileWriter(\"/dev/lp0\");\n      lp0.write(\"Hello World!\");\n      lp0.close();\n    } catch (IOException ioe) {\n      ioe.printStackTrace();\n    }\n  }\n}\n"}
{"id": 354267, "name": "Hello world_Line printer", "source": "Translate Ruby to Java: open(\"| lpr\", \"w\") { |f| f.puts \"Hello World!\" }\n", "target": "import java.io.FileWriter;\nimport java.io.IOException;\n \npublic class LinePrinter {\n  public static void main(String[] args) {\n    try {\n      FileWriter lp0 = new FileWriter(\"/dev/lp0\");\n      lp0.write(\"Hello World!\");\n      lp0.close();\n    } catch (IOException ioe) {\n      ioe.printStackTrace();\n    }\n  }\n}\n"}
{"id": 354268, "name": "Magic squares of odd order", "source": "Translate Ruby to Java: def odd_magic_square(n)\n  raise ArgumentError \"Need odd positive number\" if n.even? || n <= 0\n  n.times.map{|i| n.times.map{|j| n*((i+j+1+n/2)%n) + ((i+2*j-5)%n) + 1} }\nend\n\n[3, 5, 9].each do |n|\n  puts \"\\nSize \n  fmt = \"%\n  odd_magic_square(n).each{|row| puts fmt % row}\nend\n", "target": "public class MagicSquare {\n\n    public static void main(String[] args) {\n        int n = 5;\n        for (int[] row : magicSquareOdd(n)) {\n            for (int x : row)\n                System.out.format(\"%2s \", x);\n            System.out.println();\n        }\n        System.out.printf(\"\\nMagic constant: %d \", (n * n + 1) * n / 2);\n    }\n\n    public static int[][] magicSquareOdd(final int base) {\n        if (base % 2 == 0 || base < 3)\n            throw new IllegalArgumentException(\"base must be odd and > 2\");\n\n        int[][] grid = new int[base][base];\n        int r = 0, number = 0;\n        int size = base * base;\n\n        int c = base / 2;\n        while (number++ < size) {\n            grid[r][c] = number;\n            if (r == 0) {\n                if (c == base - 1) {\n                    r++;\n                } else {\n                    r = base - 1;\n                    c++;\n                }\n            } else {\n                if (c == base - 1) {\n                    r--;\n                    c = 0;\n                } else {\n                    if (grid[r - 1][c + 1] == 0) {\n                        r--;\n                        c++;\n                    } else {\n                        r++;\n                    }\n                }\n            }\n        }\n        return grid;\n    }\n}\n"}
{"id": 354269, "name": "Magic squares of odd order", "source": "Translate Ruby to Java: def odd_magic_square(n)\n  raise ArgumentError \"Need odd positive number\" if n.even? || n <= 0\n  n.times.map{|i| n.times.map{|j| n*((i+j+1+n/2)%n) + ((i+2*j-5)%n) + 1} }\nend\n\n[3, 5, 9].each do |n|\n  puts \"\\nSize \n  fmt = \"%\n  odd_magic_square(n).each{|row| puts fmt % row}\nend\n", "target": "public class MagicSquare {\n\n    public static void main(String[] args) {\n        int n = 5;\n        for (int[] row : magicSquareOdd(n)) {\n            for (int x : row)\n                System.out.format(\"%2s \", x);\n            System.out.println();\n        }\n        System.out.printf(\"\\nMagic constant: %d \", (n * n + 1) * n / 2);\n    }\n\n    public static int[][] magicSquareOdd(final int base) {\n        if (base % 2 == 0 || base < 3)\n            throw new IllegalArgumentException(\"base must be odd and > 2\");\n\n        int[][] grid = new int[base][base];\n        int r = 0, number = 0;\n        int size = base * base;\n\n        int c = base / 2;\n        while (number++ < size) {\n            grid[r][c] = number;\n            if (r == 0) {\n                if (c == base - 1) {\n                    r++;\n                } else {\n                    r = base - 1;\n                    c++;\n                }\n            } else {\n                if (c == base - 1) {\n                    r--;\n                    c = 0;\n                } else {\n                    if (grid[r - 1][c + 1] == 0) {\n                        r--;\n                        c++;\n                    } else {\n                        r++;\n                    }\n                }\n            }\n        }\n        return grid;\n    }\n}\n"}
{"id": 354270, "name": "Sorting algorithms_Pancake sort", "source": "Translate Ruby to Java: class Array\n  def pancake_sort!\n    num_flips = 0\n    (self.size-1).downto(1) do |end_idx|\n      max     = self[0..end_idx].max\n      max_idx = self[0..end_idx].index(max)\n      next if max_idx == end_idx\n      \n      if max_idx > 0\n        self[0..max_idx] = self[0..max_idx].reverse \n        p [num_flips += 1, self]  if $DEBUG\n      end\n      \n      self[0..end_idx] = self[0..end_idx].reverse \n      p [num_flips += 1, self]  if $DEBUG\n    end\n    self\n  end\nend\n\np a = (1..9).to_a.shuffle\np a.pancake_sort!\n", "target": "public class PancakeSort\n{\n   int[] heap;\n\n   public String toString() {\n      String info = \"\";\n      for (int x: heap)\n         info += x + \" \";\n      return info;\n   }\n    \n   public void flip(int n) {\n      for (int i = 0; i < (n+1) / 2; ++i) {\n         int tmp = heap[i];\n         heap[i] = heap[n-i];\n         heap[n-i] = tmp;\n      }      \n      System.out.println(\"flip(0..\" + n + \"): \" + toString());\n   }\n   \n   public int[] minmax(int n) {\n      int xm, xM;\n      xm = xM = heap[0];\n      int posm = 0, posM = 0;\n      \n      for (int i = 1; i < n; ++i) {\n         if (heap[i] < xm) {\n            xm = heap[i];\n            posm = i;\n         }\n         else if (heap[i] > xM) {\n            xM = heap[i];\n            posM = i;\n         }\n      }\n      return new int[] {posm, posM};\n   }\n   \n   public void sort(int n, int dir) {\n      if (n == 0) return;\n         \n      int[] mM = minmax(n);\n      int bestXPos = mM[dir];\n      int altXPos = mM[1-dir];\n      boolean flipped = false;\n      \n      if (bestXPos == n-1) {\n         --n;\n      }\n      else if (bestXPos == 0) {\n         flip(n-1);\n         --n;\n      }\n      else if (altXPos == n-1) {\n         dir = 1-dir;\n         --n;\n         flipped = true;\n      }\n      else {\n         flip(bestXPos);\n      }\n      sort(n, dir);\n\n      if (flipped) {\n         flip(n);\n      }\n   }\n   \n   PancakeSort(int[] numbers) {\n      heap = numbers;\n      sort(numbers.length, 1);\n   } \n \n   public static void main(String[] args) {\n      int[] numbers = new int[args.length];\n      for (int i = 0; i < args.length; ++i)\n         numbers[i] = Integer.valueOf(args[i]);\n\n      PancakeSort pancakes = new PancakeSort(numbers);\n      System.out.println(pancakes);\n   }\n}\n"}
{"id": 354271, "name": "Extract file extension", "source": "Translate Ruby to Java: names = \n%w(http://example.com/download.tar.gz\n   CharacterModel.3DS\n   .desktop\n   document\n   /etc/pam.d/login)\nnames.each{|name| p File.extname(name)}\n", "target": "public class Test {\n \n    public static void main(String[] args) {\n        String[] filenames = { \"http:\n                               \"CharacterModel.3DS\",\n                               \".desktop\",\n                               \"document\",\n                               \"document.txt_backup\",\n                               \"/etc/pam.d/login\"\n        };\n\n        for (String filename : filenames) {\n            String ext = \"null\";\n            int idx = filename.lastIndexOf('.');\n            if (idx != -1) {\n                String tmp = filename.substring(idx);\n                if (tmp.matches(\"\\\\.[a-zA-Z0-9]+\")) {\n                    ext = tmp;\n                }\n            }\n            System.out.println(filename + \" -> \" + ext);\n        }\n    }\n}\n"}
{"id": 354272, "name": "Extract file extension", "source": "Translate Ruby to Java: names = \n%w(http://example.com/download.tar.gz\n   CharacterModel.3DS\n   .desktop\n   document\n   /etc/pam.d/login)\nnames.each{|name| p File.extname(name)}\n", "target": "public class Test {\n \n    public static void main(String[] args) {\n        String[] filenames = { \"http:\n                               \"CharacterModel.3DS\",\n                               \".desktop\",\n                               \"document\",\n                               \"document.txt_backup\",\n                               \"/etc/pam.d/login\"\n        };\n\n        for (String filename : filenames) {\n            String ext = \"null\";\n            int idx = filename.lastIndexOf('.');\n            if (idx != -1) {\n                String tmp = filename.substring(idx);\n                if (tmp.matches(\"\\\\.[a-zA-Z0-9]+\")) {\n                    ext = tmp;\n                }\n            }\n            System.out.println(filename + \" -> \" + ext);\n        }\n    }\n}\n"}
{"id": 354273, "name": "Solve the no connection puzzle", "source": "Translate Ruby to Java: \n\n\n\nrequire 'HLPSolver'\nADJACENT = [[0,0]]\nA,B,C,D,E,F,G,H = [0,1],[0,2],[1,0],[1,1],[1,2],[1,3],[2,1],[2,2]\n\nboard1 = <<EOS\n  . 0 0 .\n  0 0 1 0 \n  . 0 0 .\n\nEOS\ng = HLPsolver.new(board1)\ng.board[A[0]][A[1]].adj = [B,G,H,F]            \ng.board[B[0]][B[1]].adj = [A,C,G,H]            \ng.board[C[0]][C[1]].adj = [B,E,F,H]          \ng.board[D[0]][D[1]].adj = [F]                \ng.board[E[0]][E[1]].adj = [C]                \ng.board[F[0]][F[1]].adj = [A,C,D,G]          \ng.board[G[0]][G[1]].adj = [A,B,F,H]            \ng.board[H[0]][H[1]].adj = [A,B,C,G]            \ng.solve\n", "target": "import static java.lang.Math.abs;\nimport java.util.*;\nimport static java.util.stream.Collectors.toList;\nimport static java.util.stream.IntStream.range;\n\npublic class NoConnection {\n\n    \n    static int[][] links = {\n        {2, 3, 4}, \n        {3, 4, 5}, \n        {2, 4},    \n        {5},       \n        {2, 3, 4}, \n        {3, 4, 5}, \n    };\n\n    static int[] pegs = new int[8];\n\n    public static void main(String[] args) {\n\n        List<Integer> vals = range(1, 9).mapToObj(i -> i).collect(toList());\n        do {\n            Collections.shuffle(vals);\n            for (int i = 0; i < pegs.length; i++)\n                pegs[i] = vals.get(i);\n\n        } while (!solved());\n\n        printResult();\n    }\n\n    static boolean solved() {\n        for (int i = 0; i < links.length; i++)\n            for (int peg : links[i])\n                if (abs(pegs[i] - peg) == 1)\n                    return false;\n        return true;\n    }\n\n    static void printResult() {\n        System.out.printf(\"  %s %s%n\", pegs[0], pegs[1]);\n        System.out.printf(\"%s %s %s %s%n\", pegs[2], pegs[3], pegs[4], pegs[5]);\n        System.out.printf(\"  %s %s%n\", pegs[6], pegs[7]);\n    }\n}\n"}
{"id": 354274, "name": "Permutation test", "source": "Translate Ruby to Java: def statistic(ab, a)\n  sumab, suma = ab.inject(:+).to_f, a.inject(:+).to_f\n  suma / a.size - (sumab - suma) / (ab.size - a.size)\nend\n\ndef permutationTest(a, b)\n  ab = a + b\n  tobs = statistic(ab, a)\n  under = count = 0\n  ab.combination(a.size) do |perm|\n    under += 1 if statistic(ab, perm) <= tobs\n    count += 1\n  end\n  under * 100.0 / count\nend\n\ntreatmentGroup = [85, 88, 75, 66, 25, 29, 83, 39, 97]\ncontrolGroup   = [68, 41, 10, 49, 16, 65, 32, 92, 28, 98]\nunder = permutationTest(treatmentGroup, controlGroup)\nputs \"under=%.2f%%, over=%.2f%%\" % [under, 100 - under]\n", "target": "public class PermutationTest {\n    private static final int[] data = new int[]{\n        85, 88, 75, 66, 25, 29, 83, 39, 97,\n        68, 41, 10, 49, 16, 65, 32, 92, 28, 98\n    };\n\n    private static int pick(int at, int remain, int accu, int treat) {\n        if (remain == 0) return (accu > treat) ? 1 : 0;\n        return pick(at - 1, remain - 1, accu + data[at - 1], treat)\n            + ((at > remain) ? pick(at - 1, remain, accu, treat) : 0);\n    }\n\n    public static void main(String[] args) {\n        int treat = 0;\n        double total = 1.0;\n        for (int i = 0; i <= 8; ++i) {\n            treat += data[i];\n        }\n        for (int i = 19; i >= 11; --i) {\n            total *= i;\n        }\n        for (int i = 9; i >= 1; --i) {\n            total /= i;\n        }\n        int gt = pick(19, 9, 0, treat);\n        int le = (int) (total - gt);\n        System.out.printf(\"<=\u00a0: %f%%  %d\\n\", 100.0 * le / total, le);\n        System.out.printf(\" >\u00a0: %f%%  %d\\n\", 100.0 * gt / total, gt);\n    }\n}\n"}
{"id": 354275, "name": "Image convolution", "source": "Translate Ruby to Java: class Pixmap\n  \n  def convolute(kernel)\n    newimg = Pixmap.new(@width, @height)\n    pb = ProgressBar.new(@width) if $DEBUG\n    @width.times do |x|\n      @height.times do |y|\n        apply_kernel(x, y, kernel, newimg)\n      end\n      pb.update(x) if $DEBUG\n    end\n    pb.close if $DEBUG\n    newimg\n  end\n\n  \n  def apply_kernel(x, y, kernel, newimg)\n    x0 = x==0 ? 0 : x-1\n    y0 = y==0 ? 0 : y-1\n    x1 = x\n    y1 = y\n    x2 = x+1==@width  ? x : x+1\n    y2 = y+1==@height ? y : y+1\n \n    r = g = b = 0.0\n    [x0, x1, x2].zip(kernel).each do |xx, kcol|\n      [y0, y1, y2].zip(kcol).each do |yy, k|\n        r += k * self[xx,yy].r\n        g += k * self[xx,yy].g\n        b += k * self[xx,yy].b\n      end\n    end\n    newimg[x,y] = RGBColour.new(luma(r), luma(g), luma(b))\n  end\n\n  \n  def luma(value)\n    if value < 0\n      0\n    elsif value > 255\n      255\n    else\n      value\n    end\n  end\nend\n\n \n\nteapot = Pixmap.open('teapot.ppm')\n[ ['Emboss',  [[-2.0, -1.0, 0.0],  [-1.0, 1.0, 1.0],  [0.0, 1.0, 2.0]]], \n  ['Sharpen', [[-1.0, -1.0, -1.0], [-1.0, 9.0, -1.0], [-1.0, -1.0, -1.0]]], \n  ['Blur',    [[0.1111,0.1111,0.1111],[0.1111,0.1111,0.1111],[0.1111,0.1111,0.1111]]],\n].each do |label, kernel|\n  savefile = 'teapot_' + label.downcase + '.ppm'\n  teapot.convolute(kernel).save(savefile)\nend\n", "target": "import java.awt.image.*;\nimport java.io.File;\nimport java.io.IOException;\nimport javax.imageio.*;\n\npublic class ImageConvolution\n{\n  public static class ArrayData\n  {\n    public final int[] dataArray;\n    public final int width;\n    public final int height;\n    \n    public ArrayData(int width, int height)\n    {\n      this(new int[width * height], width, height);\n    }\n    \n    public ArrayData(int[] dataArray, int width, int height)\n    {\n      this.dataArray = dataArray;\n      this.width = width;\n      this.height = height;\n    }\n    \n    public int get(int x, int y)\n    {  return dataArray[y * width + x];  }\n    \n    public void set(int x, int y, int value)\n    {  dataArray[y * width + x] = value;  }\n  }\n  \n  private static int bound(int value, int endIndex)\n  {\n    if (value < 0)\n      return 0;\n    if (value < endIndex)\n      return value;\n    return endIndex - 1;\n  }\n  \n  public static ArrayData convolute(ArrayData inputData, ArrayData kernel, int kernelDivisor)\n  {\n    int inputWidth = inputData.width;\n    int inputHeight = inputData.height;\n    int kernelWidth = kernel.width;\n    int kernelHeight = kernel.height;\n    if ((kernelWidth <= 0) || ((kernelWidth & 1) != 1))\n      throw new IllegalArgumentException(\"Kernel must have odd width\");\n    if ((kernelHeight <= 0) || ((kernelHeight & 1) != 1))\n      throw new IllegalArgumentException(\"Kernel must have odd height\");\n    int kernelWidthRadius = kernelWidth >>> 1;\n    int kernelHeightRadius = kernelHeight >>> 1;\n    \n    ArrayData outputData = new ArrayData(inputWidth, inputHeight);\n    for (int i = inputWidth - 1; i >= 0; i--)\n    {\n      for (int j = inputHeight - 1; j >= 0; j--)\n      {\n        double newValue = 0.0;\n        for (int kw = kernelWidth - 1; kw >= 0; kw--)\n          for (int kh = kernelHeight - 1; kh >= 0; kh--)\n            newValue += kernel.get(kw, kh) * inputData.get(\n                          bound(i + kw - kernelWidthRadius, inputWidth),\n                          bound(j + kh - kernelHeightRadius, inputHeight));\n        outputData.set(i, j, (int)Math.round(newValue / kernelDivisor));\n      }\n    }\n    return outputData;\n  }\n  \n  public static ArrayData[] getArrayDatasFromImage(String filename) throws IOException\n  {\n    BufferedImage inputImage = ImageIO.read(new File(filename));\n    int width = inputImage.getWidth();\n    int height = inputImage.getHeight();\n    int[] rgbData = inputImage.getRGB(0, 0, width, height, null, 0, width);\n    ArrayData reds = new ArrayData(width, height);\n    ArrayData greens = new ArrayData(width, height);\n    ArrayData blues = new ArrayData(width, height);\n    for (int y = 0; y < height; y++)\n    {\n      for (int x = 0; x < width; x++)\n      {\n        int rgbValue = rgbData[y * width + x];\n        reds.set(x, y, (rgbValue >>> 16) & 0xFF);\n        greens.set(x, y, (rgbValue >>> 8) & 0xFF);\n        blues.set(x, y, rgbValue & 0xFF);\n      }\n    }\n    return new ArrayData[] { reds, greens, blues };\n  }\n  \n  public static void writeOutputImage(String filename, ArrayData[] redGreenBlue) throws IOException\n  {\n    ArrayData reds = redGreenBlue[0];\n    ArrayData greens = redGreenBlue[1];\n    ArrayData blues = redGreenBlue[2];\n    BufferedImage outputImage = new BufferedImage(reds.width, reds.height,\n                                                  BufferedImage.TYPE_INT_ARGB);\n    for (int y = 0; y < reds.height; y++)\n    {\n      for (int x = 0; x < reds.width; x++)\n      {\n        int red = bound(reds.get(x, y), 256);\n        int green = bound(greens.get(x, y), 256);\n        int blue = bound(blues.get(x, y), 256);\n        outputImage.setRGB(x, y, (red << 16) | (green << 8) | blue | -0x01000000);\n      }\n    }\n    ImageIO.write(outputImage, \"PNG\", new File(filename));\n    return;\n  }\n  \n  public static void main(String[] args) throws IOException\n  {\n    int kernelWidth = Integer.parseInt(args[2]);\n    int kernelHeight = Integer.parseInt(args[3]);\n    int kernelDivisor = Integer.parseInt(args[4]);\n    System.out.println(\"Kernel size: \" + kernelWidth + \"x\" + kernelHeight +\n                       \", divisor=\" + kernelDivisor);\n    int y = 5;\n    ArrayData kernel = new ArrayData(kernelWidth, kernelHeight);\n    for (int i = 0; i < kernelHeight; i++)\n    {\n      System.out.print(\"[\");\n      for (int j = 0; j < kernelWidth; j++)\n      {\n        kernel.set(j, i, Integer.parseInt(args[y++]));\n        System.out.print(\" \" + kernel.get(j, i) + \" \");\n      }\n      System.out.println(\"]\");\n    }\n    \n    ArrayData[] dataArrays = getArrayDatasFromImage(args[0]);\n    for (int i = 0; i < dataArrays.length; i++)\n      dataArrays[i] = convolute(dataArrays[i], kernel, kernelDivisor);\n    writeOutputImage(args[1], dataArrays);\n    return;\n  }\n}\n"}
{"id": 354276, "name": "Copy a string", "source": "Translate Ruby to Java: original = \"hello\"\nreference = original          \ncopy1 = original.dup          \ncopy2 = String.new(original)  \n\noriginal << \" world!\"         \np reference                   \np copy1                       \np copy2                       \n", "target": "String src = \"Hello\";\nString newAlias = src;\nString strCopy = new String(src);\n\n\n\n\n"}
{"id": 354277, "name": "Abbreviations, simple", "source": "Translate Ruby to Java: str = \"add 1  alter 3  backup 2  bottom 1  Cappend 2  change 1  Schange  Cinsert 2  Clast 3 \n   compress 4 copy 2 count 3 Coverlay 3 cursor 3  delete 3 Cdelete 2  down 1  duplicate\n   3 xEdit 1 expand 3 extract 3  find 1 Nfind 2 Nfindup 6 NfUP 3 Cfind 2 findUP 3 fUP 2\n   forward 2  get  help 1 hexType 4  input 1 powerInput 3  join 1 split 2 spltJOIN load\n   locate 1 Clocate 2 lowerCase 3 upperCase 3 Lprefix 2  macro  merge 2 modify 3 move 2\n   msg  next 1 overlay 1 parse preserve 4 purge 3 put putD query 1 quit  read recover 3\n   refresh renum 3 repeat 3 replace 1 Creplace 2 reset 3 restore 4 rgtLEFT right 2 left\n   2  save  set  shift 2  si  sort  sos  stack 3 status 4 top  transfer 3  type 1  up 1\"\n\nRE = /(?<word1>[a-zA-Z]+)\\s+(?<word2>[a-zA-Z]+)/\nstr = str.upcase\n\n2.times{ str.gsub!(RE){ [  $~[:word1], $~[:word1].size, $~[:word2] ].join(\" \")} }\n\ntable = Hash[*str.split].transform_values(&:to_i)\n\ntest =  \"riG   rePEAT copies  put mo   rest    types   fup.    6       poweRin\"\nar = test.split.map do |w|\n  (res = table.detect{|k,v| k.start_with?(w.upcase) && w.size >= v}) ? res[0] : \"*error*\"\nend\n\nputs ar.join(\" \")\n", "target": "import java.util.*;\n\npublic class Abbreviations {\n    public static void main(String[] args) {\n        CommandList commands = new CommandList(commandTable);\n        String input = \"riG   rePEAT copies  put mo   rest    types   fup.    6       poweRin\";\n        System.out.println(\" input: \" + input);\n        System.out.println(\"output: \" + test(commands, input));\n    }\n\n    private static String test(CommandList commands, String input) {\n        StringBuilder output = new StringBuilder();\n        Scanner scanner = new Scanner(input);\n        while (scanner.hasNext()) {\n            String word = scanner.next();\n            if (output.length() > 0)\n                output.append(' ');\n            Command cmd = commands.findCommand(word);\n            if (cmd != null)\n                output.append(cmd.cmd);\n            else\n                output.append(\"*error*\");\n        }\n        return output.toString();\n    }\n\n    private static String commandTable =\n        \"add 1  alter 3  backup 2  bottom 1  Cappend 2  change 1  Schange  Cinsert 2  Clast 3 \" +\n        \"compress 4 copy 2 count 3 Coverlay 3 cursor 3  delete 3 Cdelete 2  down 1  duplicate \" +\n        \"3 xEdit 1 expand 3 extract 3  find 1 Nfind 2 Nfindup 6 NfUP 3 Cfind 2 findUP 3 fUP 2 \" +\n        \"forward 2  get  help 1 hexType 4  input 1 powerInput 3  join 1 split 2 spltJOIN load \" +\n        \"locate 1 Clocate 2 lowerCase 3 upperCase 3 Lprefix 2  macro  merge 2 modify 3 move 2 \" +\n        \"msg  next 1 overlay 1 parse preserve 4 purge 3 put putD query 1 quit  read recover 3 \" +\n        \"refresh renum 3 repeat 3 replace 1 Creplace 2 reset 3 restore 4 rgtLEFT right 2 left \" +\n        \"2  save  set  shift 2  si  sort  sos  stack 3 status 4 top  transfer 3  type 1  up 1\";\n\n    private static class Command {\n        private Command(String cmd, int minLength) {\n             this.cmd = cmd;\n             this.minLength = minLength;\n        }\n        private boolean match(String str) {\n            int olen = str.length();\n            return olen >= minLength && olen <= cmd.length()\n                && cmd.regionMatches(true, 0, str, 0, olen);\n        }\n        private String cmd;\n        private int minLength;\n    }\n\n    private static Integer parseInteger(String word) {\n        try {\n            return Integer.valueOf(word);\n        } catch (NumberFormatException ex) {\n            return null;\n        }\n    }\n\n    private static class CommandList {\n        private CommandList(String table) {\n            Scanner scanner = new Scanner(table);\n            List<String> words = new ArrayList<>();\n            while (scanner.hasNext()) {\n                String word = scanner.next();\n                words.add(word.toUpperCase());\n            }\n            for (int i = 0, n = words.size(); i < n; ++i) {\n                String word = words.get(i);\n                \n                \n                \n                int len = word.length();\n                if (i + 1 < n) {\n                    Integer number = parseInteger(words.get(i + 1));\n                    if (number != null) {\n                        len = number.intValue();\n                        ++i;\n                    }\n                }\n                commands.add(new Command(word, len));\n            }\n        }\n        private Command findCommand(String word) {\n            for (Command command : commands) {\n                if (command.match(word))\n                    return command;\n            }\n            return null;\n        }\n        private List<Command> commands = new ArrayList<>();\n    }\n}\n"}
{"id": 354278, "name": "Abbreviations, simple", "source": "Translate Ruby to Java: str = \"add 1  alter 3  backup 2  bottom 1  Cappend 2  change 1  Schange  Cinsert 2  Clast 3 \n   compress 4 copy 2 count 3 Coverlay 3 cursor 3  delete 3 Cdelete 2  down 1  duplicate\n   3 xEdit 1 expand 3 extract 3  find 1 Nfind 2 Nfindup 6 NfUP 3 Cfind 2 findUP 3 fUP 2\n   forward 2  get  help 1 hexType 4  input 1 powerInput 3  join 1 split 2 spltJOIN load\n   locate 1 Clocate 2 lowerCase 3 upperCase 3 Lprefix 2  macro  merge 2 modify 3 move 2\n   msg  next 1 overlay 1 parse preserve 4 purge 3 put putD query 1 quit  read recover 3\n   refresh renum 3 repeat 3 replace 1 Creplace 2 reset 3 restore 4 rgtLEFT right 2 left\n   2  save  set  shift 2  si  sort  sos  stack 3 status 4 top  transfer 3  type 1  up 1\"\n\nRE = /(?<word1>[a-zA-Z]+)\\s+(?<word2>[a-zA-Z]+)/\nstr = str.upcase\n\n2.times{ str.gsub!(RE){ [  $~[:word1], $~[:word1].size, $~[:word2] ].join(\" \")} }\n\ntable = Hash[*str.split].transform_values(&:to_i)\n\ntest =  \"riG   rePEAT copies  put mo   rest    types   fup.    6       poweRin\"\nar = test.split.map do |w|\n  (res = table.detect{|k,v| k.start_with?(w.upcase) && w.size >= v}) ? res[0] : \"*error*\"\nend\n\nputs ar.join(\" \")\n", "target": "import java.util.*;\n\npublic class Abbreviations {\n    public static void main(String[] args) {\n        CommandList commands = new CommandList(commandTable);\n        String input = \"riG   rePEAT copies  put mo   rest    types   fup.    6       poweRin\";\n        System.out.println(\" input: \" + input);\n        System.out.println(\"output: \" + test(commands, input));\n    }\n\n    private static String test(CommandList commands, String input) {\n        StringBuilder output = new StringBuilder();\n        Scanner scanner = new Scanner(input);\n        while (scanner.hasNext()) {\n            String word = scanner.next();\n            if (output.length() > 0)\n                output.append(' ');\n            Command cmd = commands.findCommand(word);\n            if (cmd != null)\n                output.append(cmd.cmd);\n            else\n                output.append(\"*error*\");\n        }\n        return output.toString();\n    }\n\n    private static String commandTable =\n        \"add 1  alter 3  backup 2  bottom 1  Cappend 2  change 1  Schange  Cinsert 2  Clast 3 \" +\n        \"compress 4 copy 2 count 3 Coverlay 3 cursor 3  delete 3 Cdelete 2  down 1  duplicate \" +\n        \"3 xEdit 1 expand 3 extract 3  find 1 Nfind 2 Nfindup 6 NfUP 3 Cfind 2 findUP 3 fUP 2 \" +\n        \"forward 2  get  help 1 hexType 4  input 1 powerInput 3  join 1 split 2 spltJOIN load \" +\n        \"locate 1 Clocate 2 lowerCase 3 upperCase 3 Lprefix 2  macro  merge 2 modify 3 move 2 \" +\n        \"msg  next 1 overlay 1 parse preserve 4 purge 3 put putD query 1 quit  read recover 3 \" +\n        \"refresh renum 3 repeat 3 replace 1 Creplace 2 reset 3 restore 4 rgtLEFT right 2 left \" +\n        \"2  save  set  shift 2  si  sort  sos  stack 3 status 4 top  transfer 3  type 1  up 1\";\n\n    private static class Command {\n        private Command(String cmd, int minLength) {\n             this.cmd = cmd;\n             this.minLength = minLength;\n        }\n        private boolean match(String str) {\n            int olen = str.length();\n            return olen >= minLength && olen <= cmd.length()\n                && cmd.regionMatches(true, 0, str, 0, olen);\n        }\n        private String cmd;\n        private int minLength;\n    }\n\n    private static Integer parseInteger(String word) {\n        try {\n            return Integer.valueOf(word);\n        } catch (NumberFormatException ex) {\n            return null;\n        }\n    }\n\n    private static class CommandList {\n        private CommandList(String table) {\n            Scanner scanner = new Scanner(table);\n            List<String> words = new ArrayList<>();\n            while (scanner.hasNext()) {\n                String word = scanner.next();\n                words.add(word.toUpperCase());\n            }\n            for (int i = 0, n = words.size(); i < n; ++i) {\n                String word = words.get(i);\n                \n                \n                \n                int len = word.length();\n                if (i + 1 < n) {\n                    Integer number = parseInteger(words.get(i + 1));\n                    if (number != null) {\n                        len = number.intValue();\n                        ++i;\n                    }\n                }\n                commands.add(new Command(word, len));\n            }\n        }\n        private Command findCommand(String word) {\n            for (Command command : commands) {\n                if (command.match(word))\n                    return command;\n            }\n            return null;\n        }\n        private List<Command> commands = new ArrayList<>();\n    }\n}\n"}
{"id": 354279, "name": "String comparison", "source": "Translate Ruby to Java: method_names = [:==,:!=, :>, :>=, :<, :<=, :<=>, :casecmp]\n[[\"YUP\", \"YUP\"], [\"YUP\", \"Yup\"], [\"bot\",\"bat\"], [\"aaa\", \"zz\"]].each do |str1, str2|\n  method_names.each{|m| puts \"%s %s %s\\t%s\" % [str1, m, str2, str1.send(m, str2)]}\n  puts\nend\n", "target": "public class Compare\n{\n\t\n    \n    public static void compare (String A, String B)\n    {\n        if (A.equals(B))\n            System.debug(A + ' and  ' + B + ' are lexically equal.');\n        else\n            System.debug(A + ' and  ' + B + ' are not lexically equal.');\n\n        if (A.equalsIgnoreCase(B))\n            System.debug(A + ' and  ' + B + ' are case-insensitive lexically equal.');\n        else\n            System.debug(A + ' and  ' + B + ' are not case-insensitive lexically equal.');\n \n        if (A.compareTo(B) < 0)\n            System.debug(A + ' is lexically before ' + B);\n        else if (A.compareTo(B) > 0)\n            System.debug(A + ' is lexically after ' + B);\n \n        if (A.compareTo(B) >= 0)\n            System.debug(A + ' is not lexically before ' + B);\n        if (A.compareTo(B) <= 0)\n            System.debug(A + ' is not lexically after ' + B);\n \n        System.debug('The lexical relationship is: ' + A.compareTo(B));\n    }\n}\n"}
{"id": 354280, "name": "Executable library", "source": "Translate Ruby to Java: \nmodule Hailstone\n  module_function\n  def hailstone n\n    seq = [n]\n    until n == 1\n      n = (n.even?) ? (n / 2) : (3 * n + 1)\n      seq << n\n    end\n    seq\n  end\nend\n\nif __FILE__ == $0\n  include Hailstone\n\n  \n  hs27 = hailstone 27\n  p [hs27.length, hs27[0..3], hs27[-4..-1]]\n\n  \n  n, len = (1 ... 100_000) .collect {|n|\n    [n, hailstone(n).length]} .max_by {|n, len| len}\n  puts \"\n  puts \"the largest number in that sequence is \nend\n", "target": "import java.util.ArrayList;\nimport java.util.List;\n\n\npublic class HailstoneSequence {\n\n    public static void main(String[] args) {\n        \n        int n = 27;\n        List<Long> sequence27 = hailstoneSequence(n);\n        System.out.printf(\"Hailstone sequence for %d has a length of %d:%nhailstone(%d) = %s%n\", n, sequence27.size(), n, sequence27);\n        \n        \n        int maxN = 0;\n        int maxLength = 0;\n        for ( int i = 1 ; i < 100_000 ; i++ ) {\n            int seqLength = hailstoneSequence(i).size();\n            if ( seqLength > maxLength ) {\n                maxLength = seqLength;\n                maxN = i;\n            }\n        }\n        System.out.printf(\"Longest hailstone sequence less than 100,000: hailstone(%d).length() = %d\", maxN, maxLength);\n    }\n    \n    public static List<Long> hailstoneSequence(long n) {\n        if ( n <= 0 ) {\n            throw new IllegalArgumentException(\"Must be grater than or equal to zero.\");\n        }\n        List<Long> sequence = new ArrayList<>();\n        sequence.add(n);\n        while ( n > 1 ) {\n            if ( (n & 1) == 0 ) {\n                n /= 2;\n            }\n            else {\n                n = 3 * n + 1;\n            }\n            sequence.add(n);\n        }\n        return sequence;\n    }\n    \n}\n"}
{"id": 354281, "name": "Executable library", "source": "Translate Ruby to Java: \nmodule Hailstone\n  module_function\n  def hailstone n\n    seq = [n]\n    until n == 1\n      n = (n.even?) ? (n / 2) : (3 * n + 1)\n      seq << n\n    end\n    seq\n  end\nend\n\nif __FILE__ == $0\n  include Hailstone\n\n  \n  hs27 = hailstone 27\n  p [hs27.length, hs27[0..3], hs27[-4..-1]]\n\n  \n  n, len = (1 ... 100_000) .collect {|n|\n    [n, hailstone(n).length]} .max_by {|n, len| len}\n  puts \"\n  puts \"the largest number in that sequence is \nend\n", "target": "import java.util.ArrayList;\nimport java.util.List;\n\n\npublic class HailstoneSequence {\n\n    public static void main(String[] args) {\n        \n        int n = 27;\n        List<Long> sequence27 = hailstoneSequence(n);\n        System.out.printf(\"Hailstone sequence for %d has a length of %d:%nhailstone(%d) = %s%n\", n, sequence27.size(), n, sequence27);\n        \n        \n        int maxN = 0;\n        int maxLength = 0;\n        for ( int i = 1 ; i < 100_000 ; i++ ) {\n            int seqLength = hailstoneSequence(i).size();\n            if ( seqLength > maxLength ) {\n                maxLength = seqLength;\n                maxN = i;\n            }\n        }\n        System.out.printf(\"Longest hailstone sequence less than 100,000: hailstone(%d).length() = %d\", maxN, maxLength);\n    }\n    \n    public static List<Long> hailstoneSequence(long n) {\n        if ( n <= 0 ) {\n            throw new IllegalArgumentException(\"Must be grater than or equal to zero.\");\n        }\n        List<Long> sequence = new ArrayList<>();\n        sequence.add(n);\n        while ( n > 1 ) {\n            if ( (n & 1) == 0 ) {\n                n /= 2;\n            }\n            else {\n                n = 3 * n + 1;\n            }\n            sequence.add(n);\n        }\n        return sequence;\n    }\n    \n}\n"}
{"id": 354282, "name": "Entropy_Narcissist", "source": "Translate Ruby to Java: def entropy(s)\n  counts = s.chars.each_with_object(Hash(Char, Float64).new(0.0)) { |c, h| h[c] += 1 }\n  counts.values.sum do |count|\n    freq = count / s.size\n    -freq * Math.log2(freq)\n  end\nend\n\nputs entropy File.read(__FILE__)\n", "target": "import java.io.BufferedReader;\nimport java.io.File;\nimport java.io.FileReader;\nimport java.io.IOException;\nimport java.util.HashMap;\nimport java.util.Map;\n\npublic class EntropyNarcissist {\n\n    private static final String FILE_NAME = \"src/EntropyNarcissist.java\";\n    \n    public static void main(String[] args) {\n        System.out.printf(\"Entropy of file \\\"%s\\\" =\u00a0%.12f.%n\", FILE_NAME, getEntropy(FILE_NAME));\n    }\n    \n    private static double getEntropy(String fileName) {\n        Map<Character,Integer> characterCount = new HashMap<>();\n        int length = 0;\n\n        try (BufferedReader reader = new BufferedReader(new FileReader(new File(fileName)));) {        \n            int c = 0;\n            while ( (c = reader.read()) != -1 ) {\n                characterCount.merge((char) c, 1, (v1, v2) -> v1 + v2);\n                length++;\n            }\n        }\n        catch ( IOException e ) {\n            throw new RuntimeException(e);\n        }\n        \n        double entropy = 0;\n        for ( char key : characterCount.keySet() ) {\n            double fraction = (double) characterCount.get(key) / length;\n            entropy -= fraction * Math.log(fraction);\n        }\n\n        return entropy / Math.log(2);\n    }\n\n}\n"}
{"id": 354283, "name": "Entropy_Narcissist", "source": "Translate Ruby to Java: def entropy(s)\n  counts = s.chars.each_with_object(Hash(Char, Float64).new(0.0)) { |c, h| h[c] += 1 }\n  counts.values.sum do |count|\n    freq = count / s.size\n    -freq * Math.log2(freq)\n  end\nend\n\nputs entropy File.read(__FILE__)\n", "target": "import java.io.BufferedReader;\nimport java.io.File;\nimport java.io.FileReader;\nimport java.io.IOException;\nimport java.util.HashMap;\nimport java.util.Map;\n\npublic class EntropyNarcissist {\n\n    private static final String FILE_NAME = \"src/EntropyNarcissist.java\";\n    \n    public static void main(String[] args) {\n        System.out.printf(\"Entropy of file \\\"%s\\\" =\u00a0%.12f.%n\", FILE_NAME, getEntropy(FILE_NAME));\n    }\n    \n    private static double getEntropy(String fileName) {\n        Map<Character,Integer> characterCount = new HashMap<>();\n        int length = 0;\n\n        try (BufferedReader reader = new BufferedReader(new FileReader(new File(fileName)));) {        \n            int c = 0;\n            while ( (c = reader.read()) != -1 ) {\n                characterCount.merge((char) c, 1, (v1, v2) -> v1 + v2);\n                length++;\n            }\n        }\n        catch ( IOException e ) {\n            throw new RuntimeException(e);\n        }\n        \n        double entropy = 0;\n        for ( char key : characterCount.keySet() ) {\n            double fraction = (double) characterCount.get(key) / length;\n            entropy -= fraction * Math.log(fraction);\n        }\n\n        return entropy / Math.log(2);\n    }\n\n}\n"}
{"id": 354284, "name": "Draw a pixel", "source": "Translate Ruby to Java: require 'gtk3'\n\nWidth, Height = 320, 240\nPosX, PosY = 100, 100\n\nwindow = Gtk::Window.new\nwindow.set_default_size(Width, Height)\nwindow.title = 'Draw a pixel'\n\nwindow.signal_connect(:draw) do |widget, context|\n  context.set_antialias(Cairo::Antialias::NONE)\n  \n  \n  \n  \n  context.set_source_rgb(1.0, 0.0, 0.0)\n  context.fill do\n    context.rectangle(PosX, PosY, 1, 1)\n  end\nend\n\nwindow.signal_connect(:destroy) { Gtk.main_quit }\n\nwindow.show\nGtk.main\n", "target": "import java.awt.Color;\nimport java.awt.Graphics;\nimport javax.swing.JFrame;\n\npublic class DrawAPixel extends JFrame{\n\tpublic DrawAPixel() {\n\t\tsuper(\"Red Pixel\");\n\t\tsetSize(320, 240);\n\t\tsetDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n\t\tsetVisible(true);\n\t}\n\t@Override\n\tpublic void paint(Graphics g) {\n\t\tg.setColor(new Color(255, 0, 0));\n\t\tg.drawRect(100, 100, 1, 1);\n\t}\n\tpublic static void main(String[] args) {\n\t\tnew DrawAPixel();\n\t}\n}\n"}
{"id": 354285, "name": "Verify distribution uniformity_Naive", "source": "Translate Ruby to Java: def distcheck(n, delta=1)\n  unless block_given?\n    raise ArgumentError, \"pass a block to this method\"\n  end\n  \n  h = Hash.new(0)\n  n.times {h[ yield ] += 1}\n  \n  target = 1.0 * n / h.length\n  h.each do |key, value| \n    if (value - target).abs > 0.01 * delta * n\n      raise StandardError,\n        \"distribution potentially skewed for '\n    end\n  end\n  \n  puts h.sort.map{|k, v| \"\nend\n\nif __FILE__ == $0\n  begin\n    distcheck(100_000) {rand(10)}\n    distcheck(100_000) {rand > 0.95} \n  rescue StandardError => e\n    p e\n  end\nend\n", "target": "import static java.lang.Math.abs;\nimport java.util.*;\nimport java.util.function.IntSupplier;\n\npublic class Test {\n\n    static void distCheck(IntSupplier f, int nRepeats, double delta) {\n        Map<Integer, Integer> counts = new HashMap<>();\n\n        for (int i = 0; i < nRepeats; i++)\n            counts.compute(f.getAsInt(), (k, v) -> v == null ? 1 : v + 1);\n\n        double target = nRepeats / (double) counts.size();\n        int deltaCount = (int) (delta / 100.0 * target);\n\n        counts.forEach((k, v) -> {\n            if (abs(target - v) >= deltaCount)\n                System.out.printf(\"distribution potentially skewed \"\n                        + \"for '%s': '%d'%n\", k, v);\n        });\n\n        counts.keySet().stream().sorted().forEach(k\n                -> System.out.printf(\"%d %d%n\", k, counts.get(k)));\n    }\n\n    public static void main(String[] a) {\n        distCheck(() -> (int) (Math.random() * 5) + 1, 1_000_000, 1);\n    }\n}\n"}
{"id": 354286, "name": "Use another language to call a function", "source": "Translate Ruby to Java: \nrequire 'fiddle'\n\n\n\nc_var = Fiddle.dlopen(nil)['QueryPointer']\n\nint = Fiddle::TYPE_INT\nvoidp = Fiddle::TYPE_VOIDP\nsz_voidp = Fiddle::SIZEOF_VOIDP\n\n\n\n\n\n\nQuery = Fiddle::Closure::BlockCaller\n          .new(int, [voidp, voidp]) do |datap, lengthp|\n  message = \"Here am I\"\n\n  \n  \n  length = lengthp[0, sz_voidp].unpack('J').first\n\n  \n  if length < message.bytesize\n    0  \n  else\n    length = message.bytesize\n    datap[0, length] = message  \n    lengthp[0, sz_voidp] = [length].pack('J')  \n    1  \n  end\nend\n\n\nFiddle::Pointer.new(c_var)[0, sz_voidp] = [Query.to_i].pack('J')\n", "target": "\npublic class Query {\n    public static boolean call(byte[] data, int[] length)\n\tthrows java.io.UnsupportedEncodingException\n    {\n\tString message = \"Here am I\";\n\tbyte[] mb = message.getBytes(\"utf-8\");\n\tif (length[0] < mb.length)\n\t    return false;\n\tlength[0] = mb.length;\n\tSystem.arraycopy(mb, 0, data, 0, mb.length);\n\treturn true;\n    }\n}\n"}
{"id": 354287, "name": "Find first and last set bit of a long integer", "source": "Translate Ruby to Java: def msb(x)\n  x.bit_length - 1\nend\n\ndef lsb(x)\n  msb(x & -x)\nend\n\n6.times do |i|\n  x = 42 ** i\n  puts \"%10d MSB: %2d LSB: %2d\" % [x, msb(x), lsb(x)]\nend\n\n6.times do |i|\n  x = 1302 ** i\n  puts \"%20d MSB: %2d LSB: %2d\" % [x, msb(x), lsb(x)]\nend\n", "target": "public class FirstAndLastBits {\n\n    public static long LSB(Long aNumber) {\n\t\tif ( aNumber <= 0 ) {\n\t\t\tthrow new IllegalArgumentException(\"Number must be positive\");\n\t\t}\t\t\n\t\treturn Long.numberOfTrailingZeros(aNumber);\n\t}\n\t\n\tpublic static long MSB(Long aNumber) {\n\t\tif ( aNumber <= 0 ) {\n\t\t\tthrow new IllegalArgumentException(\"Number must be positive\");\n\t\t}\t\t\n\t\treturn 63 - Long.numberOfLeadingZeros(aNumber);\n\t}\n\t\n\tpublic static long LSB(BigInteger aNumber) {\n\t\tif ( aNumber.signum() <= 0 ) {\n\t\t\tthrow new IllegalArgumentException(\"Number must be positive\");\n\t\t}\t\t\n\t\treturn aNumber.getLowestSetBit();\n\t}\n\t\n\tpublic static long MSB(BigInteger aNumber) {\n\t\tif ( aNumber.signum() <= 0 ) {\n\t\t\tthrow new IllegalArgumentException(\"Number must be positive\");\n\t\t}\t\t\n\t\treturn aNumber.bitLength() - 1;\n\t}\n\t\n\tpublic static void main(String[] aArgs) {\n\t\tLong powerOf42 = 1L;\t\t\n\t\tfor ( int i = 0; i <= 11; i++ ) {\n\t\t\tSystem.out.print(String.format(\"%-5s%-3s%s\", \"42 ^ \", i, \" = \")); \n\t\t\tSystem.out.print(String.format(\"%1$\" + 64 + \"s\", Long.toBinaryString(powerOf42)).replace(\" \", \"0\"));\n\t\t\tSystem.out.println(String.format(\"%s%-2s%s%-2s\", \" -> LSB: \", LSB(powerOf42), \", MSB: \", MSB(powerOf42)));\n\t\t\tpowerOf42 *= 42;\n\t\t}\n\t\tSystem.out.println();\n\t\t\n\t\tBigInteger bigInteger1302 = BigInteger.valueOf(1302);\n\t\tBigInteger powerOf1302 = BigInteger.ONE;\t\t\n\t\tfor ( int i = 0; i <= 6; i++ ) {\n\t\t\tSystem.out.print(String.format(\"%-7s%s%s\", \"1302 ^ \", i, \" = \")); \n\t\t\tSystem.out.print(String.format(\"%1$\" + 64 + \"s\", powerOf1302.toString(2)).replace(\" \", \"0\"));\n\t\t\tString line = String.format(\"%s%-2s%s%-2s\", \" -> LSB: \", LSB(powerOf1302), \", MSB: \", MSB(powerOf1302));\n\t\t\tSystem.out.println(line);\n\t\t\tpowerOf1302 = powerOf1302.multiply(bigInteger1302);\n\t\t}\n\t}\n\n}\n"}
{"id": 354288, "name": "Find first and last set bit of a long integer", "source": "Translate Ruby to Java: def msb(x)\n  x.bit_length - 1\nend\n\ndef lsb(x)\n  msb(x & -x)\nend\n\n6.times do |i|\n  x = 42 ** i\n  puts \"%10d MSB: %2d LSB: %2d\" % [x, msb(x), lsb(x)]\nend\n\n6.times do |i|\n  x = 1302 ** i\n  puts \"%20d MSB: %2d LSB: %2d\" % [x, msb(x), lsb(x)]\nend\n", "target": "public class FirstAndLastBits {\n\n    public static long LSB(Long aNumber) {\n\t\tif ( aNumber <= 0 ) {\n\t\t\tthrow new IllegalArgumentException(\"Number must be positive\");\n\t\t}\t\t\n\t\treturn Long.numberOfTrailingZeros(aNumber);\n\t}\n\t\n\tpublic static long MSB(Long aNumber) {\n\t\tif ( aNumber <= 0 ) {\n\t\t\tthrow new IllegalArgumentException(\"Number must be positive\");\n\t\t}\t\t\n\t\treturn 63 - Long.numberOfLeadingZeros(aNumber);\n\t}\n\t\n\tpublic static long LSB(BigInteger aNumber) {\n\t\tif ( aNumber.signum() <= 0 ) {\n\t\t\tthrow new IllegalArgumentException(\"Number must be positive\");\n\t\t}\t\t\n\t\treturn aNumber.getLowestSetBit();\n\t}\n\t\n\tpublic static long MSB(BigInteger aNumber) {\n\t\tif ( aNumber.signum() <= 0 ) {\n\t\t\tthrow new IllegalArgumentException(\"Number must be positive\");\n\t\t}\t\t\n\t\treturn aNumber.bitLength() - 1;\n\t}\n\t\n\tpublic static void main(String[] aArgs) {\n\t\tLong powerOf42 = 1L;\t\t\n\t\tfor ( int i = 0; i <= 11; i++ ) {\n\t\t\tSystem.out.print(String.format(\"%-5s%-3s%s\", \"42 ^ \", i, \" = \")); \n\t\t\tSystem.out.print(String.format(\"%1$\" + 64 + \"s\", Long.toBinaryString(powerOf42)).replace(\" \", \"0\"));\n\t\t\tSystem.out.println(String.format(\"%s%-2s%s%-2s\", \" -> LSB: \", LSB(powerOf42), \", MSB: \", MSB(powerOf42)));\n\t\t\tpowerOf42 *= 42;\n\t\t}\n\t\tSystem.out.println();\n\t\t\n\t\tBigInteger bigInteger1302 = BigInteger.valueOf(1302);\n\t\tBigInteger powerOf1302 = BigInteger.ONE;\t\t\n\t\tfor ( int i = 0; i <= 6; i++ ) {\n\t\t\tSystem.out.print(String.format(\"%-7s%s%s\", \"1302 ^ \", i, \" = \")); \n\t\t\tSystem.out.print(String.format(\"%1$\" + 64 + \"s\", powerOf1302.toString(2)).replace(\" \", \"0\"));\n\t\t\tString line = String.format(\"%s%-2s%s%-2s\", \" -> LSB: \", LSB(powerOf1302), \", MSB: \", MSB(powerOf1302));\n\t\t\tSystem.out.println(line);\n\t\t\tpowerOf1302 = powerOf1302.multiply(bigInteger1302);\n\t\t}\n\t}\n\n}\n"}
{"id": 354289, "name": "Bioinformatics_Sequence mutation", "source": "Translate Ruby to Java: class DNA_Seq\n  attr_accessor :seq\n  \n  def initialize(bases: %i[A C G T] , size: 0)\n    @bases = bases\n    @seq   = Array.new(size){ bases.sample }\n  end\n  \n  def mutate(n = 10)\n    n.times{|n| method([:s, :d, :i].sample).call}\n  end\n  \n  def to_s(n = 50)\n    just_size = @seq.size / n\n    (0...@seq.size).step(n).map{|from|  \"\n    \"\\nTotal \n  end\n\n  def s = @seq[rand_index]= @bases.sample  \n  def d = @seq.delete_at(rand_index)\n  def i = @seq.insert(rand_index, @bases.sample )\n  alias :swap   :s \n  alias :delete :d\n  alias :insert :i\n    \n  private\n  def rand_index = rand( @seq.size )\nend\n\nputs test = DNA_Seq.new(size: 200)\ntest.mutate\nputs test\ntest.delete\nputs test\n", "target": "import java.util.Arrays;\nimport java.util.Random;\n\npublic class SequenceMutation {\n    public static void main(String[] args) {\n        SequenceMutation sm = new SequenceMutation();\n        sm.setWeight(OP_CHANGE, 3);\n        String sequence = sm.generateSequence(250);\n        System.out.println(\"Initial sequence:\");\n        printSequence(sequence);\n        int count = 10;\n        for (int i = 0; i < count; ++i)\n            sequence = sm.mutateSequence(sequence);\n        System.out.println(\"After \" + count + \" mutations:\");\n        printSequence(sequence);\n    }\n\n    public SequenceMutation() {\n        totalWeight_ = OP_COUNT;\n        Arrays.fill(operationWeight_, 1);\n    }\n\n    public String generateSequence(int length) {\n        char[] ch = new char[length];\n        for (int i = 0; i < length; ++i)\n            ch[i] = getRandomBase();\n        return new String(ch);\n    }\n\n    public void setWeight(int operation, int weight) {\n        totalWeight_ -= operationWeight_[operation];\n        operationWeight_[operation] = weight;\n        totalWeight_ += weight;\n    }\n\n    public String mutateSequence(String sequence) {\n        char[] ch = sequence.toCharArray();\n        int pos = random_.nextInt(ch.length);\n        int operation = getRandomOperation();\n        if (operation == OP_CHANGE) {\n            char b = getRandomBase();\n            System.out.println(\"Change base at position \" + pos + \" from \"\n                               + ch[pos] + \" to \" + b);\n            ch[pos] = b;\n        } else if (operation == OP_ERASE) {\n            System.out.println(\"Erase base \" + ch[pos] + \" at position \" + pos);\n            char[] newCh = new char[ch.length - 1];\n            System.arraycopy(ch, 0, newCh, 0, pos);\n            System.arraycopy(ch, pos + 1, newCh, pos, ch.length - pos - 1);\n            ch = newCh;\n        } else if (operation == OP_INSERT) {\n            char b = getRandomBase();\n            System.out.println(\"Insert base \" + b + \" at position \" + pos);\n            char[] newCh = new char[ch.length + 1];\n            System.arraycopy(ch, 0, newCh, 0, pos);\n            System.arraycopy(ch, pos, newCh, pos + 1, ch.length - pos);\n            newCh[pos] = b;\n            ch = newCh;\n        }\n        return new String(ch);\n    }\n\n    public static void printSequence(String sequence) {\n        int[] count = new int[BASES.length];\n        for (int i = 0, n = sequence.length(); i < n; ++i) {\n            if (i % 50 == 0) {\n                if (i != 0)\n                    System.out.println();\n                System.out.printf(\"%3d: \", i);\n            }\n            char ch = sequence.charAt(i);\n            System.out.print(ch);\n            for (int j = 0; j < BASES.length; ++j) {\n                if (BASES[j] == ch) {\n                    ++count[j];\n                    break;\n                }\n            }\n        }\n        System.out.println();\n        System.out.println(\"Base counts:\");\n        int total = 0;\n        for (int j = 0; j < BASES.length; ++j) {\n            total += count[j];\n            System.out.print(BASES[j] + \": \" + count[j] + \", \");\n        }\n        System.out.println(\"Total: \" + total);\n    }\n\n    private char getRandomBase() {\n        return BASES[random_.nextInt(BASES.length)];\n    }\n\n    private int getRandomOperation() {\n        int n = random_.nextInt(totalWeight_), op = 0;\n        for (int weight = 0; op < OP_COUNT; ++op) {\n            weight += operationWeight_[op];\n            if (n < weight)\n                break;\n        }\n        return op;\n    }\n\n    private final Random random_ = new Random();\n    private int[] operationWeight_ = new int[OP_COUNT];\n    private int totalWeight_ = 0;\n\n    private static final int OP_CHANGE = 0;\n    private static final int OP_ERASE = 1;\n    private static final int OP_INSERT = 2;\n    private static final int OP_COUNT = 3;\n    private static final char[] BASES = {'A', 'C', 'G', 'T'};\n}\n"}
{"id": 354290, "name": "Bioinformatics_Sequence mutation", "source": "Translate Ruby to Java: class DNA_Seq\n  attr_accessor :seq\n  \n  def initialize(bases: %i[A C G T] , size: 0)\n    @bases = bases\n    @seq   = Array.new(size){ bases.sample }\n  end\n  \n  def mutate(n = 10)\n    n.times{|n| method([:s, :d, :i].sample).call}\n  end\n  \n  def to_s(n = 50)\n    just_size = @seq.size / n\n    (0...@seq.size).step(n).map{|from|  \"\n    \"\\nTotal \n  end\n\n  def s = @seq[rand_index]= @bases.sample  \n  def d = @seq.delete_at(rand_index)\n  def i = @seq.insert(rand_index, @bases.sample )\n  alias :swap   :s \n  alias :delete :d\n  alias :insert :i\n    \n  private\n  def rand_index = rand( @seq.size )\nend\n\nputs test = DNA_Seq.new(size: 200)\ntest.mutate\nputs test\ntest.delete\nputs test\n", "target": "import java.util.Arrays;\nimport java.util.Random;\n\npublic class SequenceMutation {\n    public static void main(String[] args) {\n        SequenceMutation sm = new SequenceMutation();\n        sm.setWeight(OP_CHANGE, 3);\n        String sequence = sm.generateSequence(250);\n        System.out.println(\"Initial sequence:\");\n        printSequence(sequence);\n        int count = 10;\n        for (int i = 0; i < count; ++i)\n            sequence = sm.mutateSequence(sequence);\n        System.out.println(\"After \" + count + \" mutations:\");\n        printSequence(sequence);\n    }\n\n    public SequenceMutation() {\n        totalWeight_ = OP_COUNT;\n        Arrays.fill(operationWeight_, 1);\n    }\n\n    public String generateSequence(int length) {\n        char[] ch = new char[length];\n        for (int i = 0; i < length; ++i)\n            ch[i] = getRandomBase();\n        return new String(ch);\n    }\n\n    public void setWeight(int operation, int weight) {\n        totalWeight_ -= operationWeight_[operation];\n        operationWeight_[operation] = weight;\n        totalWeight_ += weight;\n    }\n\n    public String mutateSequence(String sequence) {\n        char[] ch = sequence.toCharArray();\n        int pos = random_.nextInt(ch.length);\n        int operation = getRandomOperation();\n        if (operation == OP_CHANGE) {\n            char b = getRandomBase();\n            System.out.println(\"Change base at position \" + pos + \" from \"\n                               + ch[pos] + \" to \" + b);\n            ch[pos] = b;\n        } else if (operation == OP_ERASE) {\n            System.out.println(\"Erase base \" + ch[pos] + \" at position \" + pos);\n            char[] newCh = new char[ch.length - 1];\n            System.arraycopy(ch, 0, newCh, 0, pos);\n            System.arraycopy(ch, pos + 1, newCh, pos, ch.length - pos - 1);\n            ch = newCh;\n        } else if (operation == OP_INSERT) {\n            char b = getRandomBase();\n            System.out.println(\"Insert base \" + b + \" at position \" + pos);\n            char[] newCh = new char[ch.length + 1];\n            System.arraycopy(ch, 0, newCh, 0, pos);\n            System.arraycopy(ch, pos, newCh, pos + 1, ch.length - pos);\n            newCh[pos] = b;\n            ch = newCh;\n        }\n        return new String(ch);\n    }\n\n    public static void printSequence(String sequence) {\n        int[] count = new int[BASES.length];\n        for (int i = 0, n = sequence.length(); i < n; ++i) {\n            if (i % 50 == 0) {\n                if (i != 0)\n                    System.out.println();\n                System.out.printf(\"%3d: \", i);\n            }\n            char ch = sequence.charAt(i);\n            System.out.print(ch);\n            for (int j = 0; j < BASES.length; ++j) {\n                if (BASES[j] == ch) {\n                    ++count[j];\n                    break;\n                }\n            }\n        }\n        System.out.println();\n        System.out.println(\"Base counts:\");\n        int total = 0;\n        for (int j = 0; j < BASES.length; ++j) {\n            total += count[j];\n            System.out.print(BASES[j] + \": \" + count[j] + \", \");\n        }\n        System.out.println(\"Total: \" + total);\n    }\n\n    private char getRandomBase() {\n        return BASES[random_.nextInt(BASES.length)];\n    }\n\n    private int getRandomOperation() {\n        int n = random_.nextInt(totalWeight_), op = 0;\n        for (int weight = 0; op < OP_COUNT; ++op) {\n            weight += operationWeight_[op];\n            if (n < weight)\n                break;\n        }\n        return op;\n    }\n\n    private final Random random_ = new Random();\n    private int[] operationWeight_ = new int[OP_COUNT];\n    private int totalWeight_ = 0;\n\n    private static final int OP_CHANGE = 0;\n    private static final int OP_ERASE = 1;\n    private static final int OP_INSERT = 2;\n    private static final int OP_COUNT = 3;\n    private static final char[] BASES = {'A', 'C', 'G', 'T'};\n}\n"}
{"id": 354291, "name": "Colour bars_Display", "source": "Translate Ruby to Java: \nPALETTE = %w[\n\ndef settings\n  full_screen\nend\n\ndef setup\n  PALETTE.each_with_index do |col, idx|\n    fill color(col)\n    rect(idx * width / 8, 0, width / 8, height)\n  end\nend\n", "target": "import java.awt.Color;\nimport java.awt.Graphics;\n\nimport javax.swing.JFrame;\n\npublic class ColorFrame extends JFrame {\n\tpublic ColorFrame(int width, int height) {\n\t\tthis.setDefaultCloseOperation(EXIT_ON_CLOSE);\n\t\tthis.setSize(width, height);\n\t\tthis.setVisible(true);\n\t}\n\n\t@Override\n\tpublic void paint(Graphics g) {\n\t\tColor[] colors = { Color.black, Color.red, Color.green, Color.blue,\n\t\t\t\tColor.pink, Color.CYAN, Color.yellow, Color.white };\n\n\t\tfor (int i = 0; i < colors.length; i++) {\n\t\t\tg.setColor(colors[i]);\n\t\t\tg.fillRect(this.getWidth() / colors.length * i, 0, this.getWidth()\n\t\t\t\t\t/ colors.length, this.getHeight());\n\t\t}\n\t}\n\n\tpublic static void main(String args[]) {\n\t\tnew ColorFrame(200, 200);\n\t}\n}\n"}
{"id": 354292, "name": "Colour bars_Display", "source": "Translate Ruby to Java: \nPALETTE = %w[\n\ndef settings\n  full_screen\nend\n\ndef setup\n  PALETTE.each_with_index do |col, idx|\n    fill color(col)\n    rect(idx * width / 8, 0, width / 8, height)\n  end\nend\n", "target": "import java.awt.Color;\nimport java.awt.Graphics;\n\nimport javax.swing.JFrame;\n\npublic class ColorFrame extends JFrame {\n\tpublic ColorFrame(int width, int height) {\n\t\tthis.setDefaultCloseOperation(EXIT_ON_CLOSE);\n\t\tthis.setSize(width, height);\n\t\tthis.setVisible(true);\n\t}\n\n\t@Override\n\tpublic void paint(Graphics g) {\n\t\tColor[] colors = { Color.black, Color.red, Color.green, Color.blue,\n\t\t\t\tColor.pink, Color.CYAN, Color.yellow, Color.white };\n\n\t\tfor (int i = 0; i < colors.length; i++) {\n\t\t\tg.setColor(colors[i]);\n\t\t\tg.fillRect(this.getWidth() / colors.length * i, 0, this.getWidth()\n\t\t\t\t\t/ colors.length, this.getHeight());\n\t\t}\n\t}\n\n\tpublic static void main(String args[]) {\n\t\tnew ColorFrame(200, 200);\n\t}\n}\n"}
{"id": 354293, "name": "Dining philosophers", "source": "Translate Ruby to Java: require 'mutex_m'\n\nclass Philosopher\n  def initialize(name, left_fork, right_fork)\n    @name = name\n    @left_fork = left_fork\n    @right_fork = right_fork\n    @meals = 0\n  end\n\n  def go\n    while @meals < 5\n      think\n      dine\n    end\n    puts \"philosopher \n  end\n\n  def think\n    puts \"philosopher \n    sleep(rand())\n    puts \"philosopher \n  end\n\n  def dine\n    fork1, fork2 = @left_fork, @right_fork\n    while true\n      pickup(fork1, :wait => true)\n      puts \"philosopher \n      if pickup(fork2, :wait => false)\n        break\n      end\n      puts \"philosopher \n      release(fork1)\n      fork1, fork2 = fork2, fork1\n    end\n    puts \"philosopher \n\n    puts \"philosopher \n    sleep(rand())\n    puts \"philosopher \n    @meals += 1\n\n    release(@left_fork)\n    release(@right_fork)\n  end\n\n  def pickup(fork, opt)\n    puts \"philosopher \n    opt[:wait] ? fork.mutex.mu_lock : fork.mutex.mu_try_lock\n  end\n\n  def release(fork)\n    puts \"philosopher \n    fork.mutex.unlock\n  end\nend\n\nn = 5\n\nFork = Struct.new(:fork_id, :mutex)\nforks = Array.new(n) {|i| Fork.new(i, Object.new.extend(Mutex_m))}\n\nphilosophers = Array.new(n) do |i| \n                 Thread.new(i, forks[i], forks[(i+1)%n]) do |id, f1, f2|\n                   ph = Philosopher.new(id, f1, f2).go\n                 end\n               end\n  \nphilosophers.each {|thread| thread.join}\n", "target": "package diningphilosophers;\n\nimport java.util.ArrayList;\nimport java.util.Random;\nimport java.util.concurrent.atomic.AtomicBoolean;\nimport java.util.concurrent.atomic.AtomicInteger;\n\nenum PhilosopherState { Get, Eat, Pon }\n\nclass Fork {\n    public static final int ON_TABLE = -1;\n    static int instances = 0;\n    public int id;\n    public AtomicInteger holder = new AtomicInteger(ON_TABLE);\n\n    Fork() { id = instances++; }\n}\n\nclass Philosopher implements Runnable {\n    static final int maxWaitMs = 100;                          \n    static AtomicInteger token = new AtomicInteger(0);\n    static int instances = 0;\n    static Random rand = new Random();\n    AtomicBoolean end = new AtomicBoolean(false);\n    int id;\n    PhilosopherState state = PhilosopherState.Get;\n    Fork left;\n    Fork right;\n    int timesEaten = 0;\n\n    Philosopher() {\n        id = instances++;\n        left = Main.forks.get(id);\n        right = Main.forks.get((id+1)%Main.philosopherCount);\n    }\n\n    void sleep() { try { Thread.sleep(rand.nextInt(maxWaitMs)); }\n        catch (InterruptedException ex) {} }\n\n    void waitForFork(Fork fork) {\n        do {\n            if (fork.holder.get() == Fork.ON_TABLE) {\n                fork.holder.set(id);                \n                return;\n            } else {                                \n                sleep();                            \n            }\n        } while (true);\n    }\n\n    public void run() {\n        do {\n            if (state == PhilosopherState.Pon) {    \n                state = PhilosopherState.Get;       \n            } else { \n                if (token.get() == id) {            \n                    waitForFork(left);\n                    waitForFork(right);             \n                    token.set((id+2)% Main.philosopherCount);\n                    state = PhilosopherState.Eat;\n                    timesEaten++;\n                    sleep();                        \n                    left.holder.set(Fork.ON_TABLE);\n                    right.holder.set(Fork.ON_TABLE);\n                    state = PhilosopherState.Pon;   \n                    sleep();\n                } else {                    \n                    sleep();\n                }\n            }\n        } while (!end.get());\n    }\n}\n\npublic class Main {\n    static final int philosopherCount = 5; \n    static final int runSeconds = 15;\n    static ArrayList<Fork> forks = new ArrayList<Fork>();\n    static ArrayList<Philosopher> philosophers = new ArrayList<Philosopher>();\n\n    public static void main(String[] args) {\n        for (int i = 0 ; i < philosopherCount ; i++) forks.add(new Fork());\n        for (int i = 0 ; i < philosopherCount ; i++)\n            philosophers.add(new Philosopher());\n        for (Philosopher p : philosophers) new Thread(p).start();\n        long endTime = System.currentTimeMillis() + (runSeconds * 1000);\n\n        do {                                                    \n            StringBuilder sb = new StringBuilder(\"|\");\n\n            for (Philosopher p : philosophers) {\n                sb.append(p.state.toString());\n                sb.append(\"|\");            \n            }                              \n\n            sb.append(\"     |\");\n\n            for (Fork f : forks) {\n                int holder = f.holder.get();\n                sb.append(holder==-1?\"   \":String.format(\"P%02d\",holder));\n                sb.append(\"|\");\n            }\n            \n            System.out.println(sb.toString());\n            try {Thread.sleep(1000);} catch (Exception ex) {}\n        } while (System.currentTimeMillis() < endTime);\n\n        for (Philosopher p : philosophers) p.end.set(true);\n        for (Philosopher p : philosophers)\n            System.out.printf(\"P%02d: ate\u00a0%,d times,\u00a0%,d/sec\\n\",\n                p.id, p.timesEaten, p.timesEaten/runSeconds);\n    }\n}\n"}
{"id": 354294, "name": "24 game", "source": "Translate Ruby to Java: class Guess < String\n  def self.play\n    nums = Array.new(4){rand(1..9)}\n    loop do\n      result = get(nums).evaluate!\n      break if result == 24.0\n      puts \"Try again! That gives \n    end\n    puts \"You win!\"\n  end\n  \n  def self.get(nums)\n    loop do\n      print \"\\nEnter a guess using \n      input = gets.chomp\n      return new(input) if validate(input, nums)\n    end\n  end\n  \n  def self.validate(guess, nums)\n    name, error =\n      {\n        invalid_character:  ->(str){ !str.scan(%r{[^\\d\\s()+*/-]}).empty? },\n        wrong_number:       ->(str){ str.scan(/\\d/).map(&:to_i).sort != nums.sort },\n        multi_digit_number: ->(str){ str.match(/\\d\\d/) }\n      }\n        .find {|name, validator| validator[guess] }\n    \n    error ? puts(\"Invalid input of a(n) \n  end\n  \n  def evaluate!\n    as_rat = gsub(/(\\d)/, '\\1r')        \n    eval \"(\n  rescue SyntaxError\n    \"[syntax error]\"\n  end\nend\n\nGuess.play\n", "target": "import java.util.*;\n\npublic class Game24 {\n    static Random r = new Random();\n\n    public static void main(String[] args) {\n\n        int[] digits = randomDigits();\n        Scanner in = new Scanner(System.in);\n\n        System.out.print(\"Make 24 using these digits: \");\n        System.out.println(Arrays.toString(digits));\n        System.out.print(\"> \");\n\n        Stack<Float> s = new Stack<>();\n        long total = 0;\n        for (char c : in.nextLine().toCharArray()) {\n            if ('0' <= c && c <= '9') {\n                int d = c - '0';\n                total += (1 << (d * 5));\n                s.push((float) d);\n            } else if (\"+/-*\".indexOf(c) != -1) {\n                s.push(applyOperator(s.pop(), s.pop(), c));\n            }\n        }\n        if (tallyDigits(digits) != total)\n            System.out.print(\"Not the same digits. \");\n        else if (Math.abs(24 - s.peek()) < 0.001F)\n            System.out.println(\"Correct!\");\n        else\n            System.out.print(\"Not correct.\");\n    }\n\n    static float applyOperator(float a, float b, char c) {\n        switch (c) {\n            case '+':\n                return a + b;\n            case '-':\n                return b - a;\n            case '*':\n                return a * b;\n            case '/':\n                return b / a;\n            default:\n                return Float.NaN;\n        }\n    }\n\n    static long tallyDigits(int[] a) {\n        long total = 0;\n        for (int i = 0; i < 4; i++)\n            total += (1 << (a[i] * 5));\n        return total;\n    }\n\n    static int[] randomDigits() {        \n        int[] result = new int[4];\n        for (int i = 0; i < 4; i++)\n            result[i] = r.nextInt(9) + 1;\n        return result;\n    }\n}\n"}
{"id": 354295, "name": "24 game", "source": "Translate Ruby to Java: class Guess < String\n  def self.play\n    nums = Array.new(4){rand(1..9)}\n    loop do\n      result = get(nums).evaluate!\n      break if result == 24.0\n      puts \"Try again! That gives \n    end\n    puts \"You win!\"\n  end\n  \n  def self.get(nums)\n    loop do\n      print \"\\nEnter a guess using \n      input = gets.chomp\n      return new(input) if validate(input, nums)\n    end\n  end\n  \n  def self.validate(guess, nums)\n    name, error =\n      {\n        invalid_character:  ->(str){ !str.scan(%r{[^\\d\\s()+*/-]}).empty? },\n        wrong_number:       ->(str){ str.scan(/\\d/).map(&:to_i).sort != nums.sort },\n        multi_digit_number: ->(str){ str.match(/\\d\\d/) }\n      }\n        .find {|name, validator| validator[guess] }\n    \n    error ? puts(\"Invalid input of a(n) \n  end\n  \n  def evaluate!\n    as_rat = gsub(/(\\d)/, '\\1r')        \n    eval \"(\n  rescue SyntaxError\n    \"[syntax error]\"\n  end\nend\n\nGuess.play\n", "target": "import java.util.*;\n\npublic class Game24 {\n    static Random r = new Random();\n\n    public static void main(String[] args) {\n\n        int[] digits = randomDigits();\n        Scanner in = new Scanner(System.in);\n\n        System.out.print(\"Make 24 using these digits: \");\n        System.out.println(Arrays.toString(digits));\n        System.out.print(\"> \");\n\n        Stack<Float> s = new Stack<>();\n        long total = 0;\n        for (char c : in.nextLine().toCharArray()) {\n            if ('0' <= c && c <= '9') {\n                int d = c - '0';\n                total += (1 << (d * 5));\n                s.push((float) d);\n            } else if (\"+/-*\".indexOf(c) != -1) {\n                s.push(applyOperator(s.pop(), s.pop(), c));\n            }\n        }\n        if (tallyDigits(digits) != total)\n            System.out.print(\"Not the same digits. \");\n        else if (Math.abs(24 - s.peek()) < 0.001F)\n            System.out.println(\"Correct!\");\n        else\n            System.out.print(\"Not correct.\");\n    }\n\n    static float applyOperator(float a, float b, char c) {\n        switch (c) {\n            case '+':\n                return a + b;\n            case '-':\n                return b - a;\n            case '*':\n                return a * b;\n            case '/':\n                return b / a;\n            default:\n                return Float.NaN;\n        }\n    }\n\n    static long tallyDigits(int[] a) {\n        long total = 0;\n        for (int i = 0; i < 4; i++)\n            total += (1 << (a[i] * 5));\n        return total;\n    }\n\n    static int[] randomDigits() {        \n        int[] result = new int[4];\n        for (int i = 0; i < 4; i++)\n            result[i] = r.nextInt(9) + 1;\n        return result;\n    }\n}\n"}
{"id": 354296, "name": "Enforced immutability", "source": "Translate Ruby to Java: msg = \"Hello World\"\nmsg << \"!\"\nputs msg                \n\nputs msg.frozen?        \nmsg.freeze\nputs msg.frozen?        \nbegin\n  msg << \"!\"\nrescue => e\n  p e                   \nend\n\nputs msg                \nmsg2 = msg\n\n\nmsg = \"hello world\"     \n\nputs msg.frozen?        \nputs msg2.frozen?       \n", "target": "final int immutableInt = 4;\nint mutableInt = 4;\nmutableInt = 6; \nimmutableInt = 6; \n"}
{"id": 354297, "name": "Strange numbers", "source": "Translate Ruby to Java: def digits(n)\n    result = []\n    while n > 0\n        rem = n % 10\n        result.unshift(rem)\n        n = n / 10\n    end\n    return result\nend\n\ndef isStrange(n)\n    def test(a, b)\n        abs = (a - b).abs\n        return abs == 2 || abs == 3 || abs == 5 || abs == 7\n    end\n\n    xs = digits(n)\n    for i in 1 .. xs.length - 1\n        if !test(xs[i - 1], xs[i]) then\n            return false\n        end\n    end\n    return true\nend\n\nxs = []\nfor i in 100 .. 500\n    if isStrange(i) then\n        xs << i\n    end\nend\n\nprint \"Strange numbers in range [100 .. 500]\\n\"\nprint \"(Total: %d)\\n\\n\" % [xs.length]\n\nxs.each_slice(10) do |s|\n    print s, \"\\n\"\nend\n", "target": "import java.util.LinkedList;\nimport java.util.List;\nimport java.util.function.BiPredicate;\nimport java.util.stream.Collectors;\nimport java.util.stream.IntStream;\n\npublic class StrangeNumbers {\n    private static List<Integer> digits(int n) {\n        var result = new LinkedList<Integer>();\n        while (n > 0) {\n            var rem = n % 10;\n            result.addFirst(rem);\n            n /= 10;\n        }\n        return result;\n    }\n\n    private static boolean isStrange(int n) {\n        BiPredicate<Integer, Integer> test = (a, b) -> {\n            var abs = Math.abs(a - b);\n            return abs == 2 || abs == 3 || abs == 5 || abs == 7;\n        };\n\n        var xs = digits(n);\n        for (int i = 1; i < xs.size(); i++) {\n            if (test.negate().test(xs.get(i - 1), xs.get(i))) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    public static void main(String[] args) {\n        var xs = IntStream.rangeClosed(100, 500)\n            .filter(StrangeNumbers::isStrange)\n            .boxed()\n            .collect(Collectors.toList());\n\n        System.out.println(\"Strange numbers in range [100..500]\");\n        System.out.printf(\"(Total: %d)\\n\\n\", xs.size());\n\n        for (int i = 0; i < xs.size(); i++) {\n            Integer x = xs.get(i);\n            System.out.print(x);\n\n            if ((i + 1) % 10 == 0) {\n                System.out.println();\n            } else {\n                System.out.print(' ');\n            }\n        }\n    }\n}\n"}
{"id": 354298, "name": "Strange numbers", "source": "Translate Ruby to Java: def digits(n)\n    result = []\n    while n > 0\n        rem = n % 10\n        result.unshift(rem)\n        n = n / 10\n    end\n    return result\nend\n\ndef isStrange(n)\n    def test(a, b)\n        abs = (a - b).abs\n        return abs == 2 || abs == 3 || abs == 5 || abs == 7\n    end\n\n    xs = digits(n)\n    for i in 1 .. xs.length - 1\n        if !test(xs[i - 1], xs[i]) then\n            return false\n        end\n    end\n    return true\nend\n\nxs = []\nfor i in 100 .. 500\n    if isStrange(i) then\n        xs << i\n    end\nend\n\nprint \"Strange numbers in range [100 .. 500]\\n\"\nprint \"(Total: %d)\\n\\n\" % [xs.length]\n\nxs.each_slice(10) do |s|\n    print s, \"\\n\"\nend\n", "target": "import java.util.LinkedList;\nimport java.util.List;\nimport java.util.function.BiPredicate;\nimport java.util.stream.Collectors;\nimport java.util.stream.IntStream;\n\npublic class StrangeNumbers {\n    private static List<Integer> digits(int n) {\n        var result = new LinkedList<Integer>();\n        while (n > 0) {\n            var rem = n % 10;\n            result.addFirst(rem);\n            n /= 10;\n        }\n        return result;\n    }\n\n    private static boolean isStrange(int n) {\n        BiPredicate<Integer, Integer> test = (a, b) -> {\n            var abs = Math.abs(a - b);\n            return abs == 2 || abs == 3 || abs == 5 || abs == 7;\n        };\n\n        var xs = digits(n);\n        for (int i = 1; i < xs.size(); i++) {\n            if (test.negate().test(xs.get(i - 1), xs.get(i))) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    public static void main(String[] args) {\n        var xs = IntStream.rangeClosed(100, 500)\n            .filter(StrangeNumbers::isStrange)\n            .boxed()\n            .collect(Collectors.toList());\n\n        System.out.println(\"Strange numbers in range [100..500]\");\n        System.out.printf(\"(Total: %d)\\n\\n\", xs.size());\n\n        for (int i = 0; i < xs.size(); i++) {\n            Integer x = xs.get(i);\n            System.out.print(x);\n\n            if ((i + 1) % 10 == 0) {\n                System.out.println();\n            } else {\n                System.out.print(' ');\n            }\n        }\n    }\n}\n"}
{"id": 354299, "name": "Hofstadter Q sequence", "source": "Translate Ruby to Java: @cache = []\ndef Q(n)\n  if @cache[n].nil?\n    case n\n    when 1, 2 then @cache[n] = 1\n    else @cache[n] = Q(n - Q(n-1)) + Q(n - Q(n-2))\n    end\n  end\n  @cache[n]\nend\n\nputs \"first 10 numbers in the sequence: \nputs \"1000'th term: \n\nprev = Q(1)\ncount = 0\n2.upto(100_000) do |n| \n  q = Q(n)\n  count += 1 if q < prev \n  prev = q\nend\nputs \"number of times in the first 100,000 terms where Q(i)<Q(i-1): \n", "target": "import java.util.HashMap;\nimport java.util.Map;\n\npublic class HofQ {\n\tprivate static Map<Integer, Integer> q = new HashMap<Integer, Integer>(){{\n\t\tput(1, 1);\n\t\tput(2, 1);\n\t}};\n\t\n\tprivate static int[] nUses = new int[100001];\n\t\n\tpublic static int Q(int n){\n\t\tnUses[n]++;\n\t\tif(q.containsKey(n)){\n\t\t\treturn q.get(n);\n\t\t}\n\t\tint ans = Q(n - Q(n - 1)) + Q(n - Q(n - 2));\n\t\tq.put(n, ans);\n\t\treturn ans;\n\t}\n\t\n\tpublic static void main(String[] args){\n\t\tfor(int i = 1; i <= 10; i++){\n\t\t\tSystem.out.println(\"Q(\" + i + \") = \" + Q(i));\n\t\t}\n\t\tint last = 6;\n\t\tint count = 0;\n\t\tfor(int i = 11; i <= 100000; i++){\n\t\t\tint curr = Q(i);\n\t\t\tif(curr < last) count++;\n\t\t\tlast = curr;\n\t\t\tif(i == 1000) System.out.println(\"Q(1000) = \" + curr);\n\t\t}\n\t\tSystem.out.println(\"Q(i) is less than Q(i-1) for i <= 100000 \" + count + \" times\");\n\t\t\n\t\t\n\t\tint maxUses = 0, maxN = 0;\n\t\tfor(int i = 1; i<nUses.length;i++){\n\t\t\tif(nUses[i] > maxUses){\n\t\t\t\tmaxUses = nUses[i];\n\t\t\t\tmaxN = i;\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(\"Q(\" + maxN + \") was called the most with \" + maxUses + \" calls\");\n\t}\n}\n"}
{"id": 354300, "name": "Hofstadter Q sequence", "source": "Translate Ruby to Java: @cache = []\ndef Q(n)\n  if @cache[n].nil?\n    case n\n    when 1, 2 then @cache[n] = 1\n    else @cache[n] = Q(n - Q(n-1)) + Q(n - Q(n-2))\n    end\n  end\n  @cache[n]\nend\n\nputs \"first 10 numbers in the sequence: \nputs \"1000'th term: \n\nprev = Q(1)\ncount = 0\n2.upto(100_000) do |n| \n  q = Q(n)\n  count += 1 if q < prev \n  prev = q\nend\nputs \"number of times in the first 100,000 terms where Q(i)<Q(i-1): \n", "target": "import java.util.HashMap;\nimport java.util.Map;\n\npublic class HofQ {\n\tprivate static Map<Integer, Integer> q = new HashMap<Integer, Integer>(){{\n\t\tput(1, 1);\n\t\tput(2, 1);\n\t}};\n\t\n\tprivate static int[] nUses = new int[100001];\n\t\n\tpublic static int Q(int n){\n\t\tnUses[n]++;\n\t\tif(q.containsKey(n)){\n\t\t\treturn q.get(n);\n\t\t}\n\t\tint ans = Q(n - Q(n - 1)) + Q(n - Q(n - 2));\n\t\tq.put(n, ans);\n\t\treturn ans;\n\t}\n\t\n\tpublic static void main(String[] args){\n\t\tfor(int i = 1; i <= 10; i++){\n\t\t\tSystem.out.println(\"Q(\" + i + \") = \" + Q(i));\n\t\t}\n\t\tint last = 6;\n\t\tint count = 0;\n\t\tfor(int i = 11; i <= 100000; i++){\n\t\t\tint curr = Q(i);\n\t\t\tif(curr < last) count++;\n\t\t\tlast = curr;\n\t\t\tif(i == 1000) System.out.println(\"Q(1000) = \" + curr);\n\t\t}\n\t\tSystem.out.println(\"Q(i) is less than Q(i-1) for i <= 100000 \" + count + \" times\");\n\t\t\n\t\t\n\t\tint maxUses = 0, maxN = 0;\n\t\tfor(int i = 1; i<nUses.length;i++){\n\t\t\tif(nUses[i] > maxUses){\n\t\t\t\tmaxUses = nUses[i];\n\t\t\t\tmaxN = i;\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(\"Q(\" + maxN + \") was called the most with \" + maxUses + \" calls\");\n\t}\n}\n"}
{"id": 354301, "name": "Count occurrences of a substring", "source": "Translate Ruby to Java: def countSubstrings str, subStr\n  str.scan(subStr).length\nend\n\np countSubstrings \"the three truths\", \"th\"      \np countSubstrings \"ababababab\", \"abab\"          \n", "target": "public class CountSubstring {\n\tpublic static int countSubstring(String subStr, String str){\n\t\treturn (str.length() - str.replace(subStr, \"\").length()) / subStr.length();\n\t}\n\t\n\tpublic static void main(String[] args){\n\t\tSystem.out.println(countSubstring(\"th\", \"the three truths\"));\n\t\tSystem.out.println(countSubstring(\"abab\", \"ababababab\"));\n\t\tSystem.out.println(countSubstring(\"a*b\", \"abaabba*bbaba*bbab\"));\n\t}\n}\n"}
{"id": 354302, "name": "Logistic curve fitting in epidemiology", "source": "Translate Ruby to Java: K = 7.9e9\nN0 = 27\nACTUAL = [\n    27, 27, 27, 44, 44, 59, 59, 59, 59, 59, 59, 59, 59, 60, 60,\n    61, 61, 66, 83, 219, 239, 392, 534, 631, 897, 1350, 2023, 2820,\n    4587, 6067, 7823, 9826, 11946, 14554, 17372, 20615, 24522, 28273,\n    31491, 34933, 37552, 40540, 43105, 45177, 60328, 64543, 67103,\n    69265, 71332, 73327, 75191, 75723, 76719, 77804, 78812, 79339,\n    80132, 80995, 82101, 83365, 85203, 87024, 89068, 90664, 93077,\n    95316, 98172, 102133, 105824, 109695, 114232, 118610, 125497,\n    133852, 143227, 151367, 167418, 180096, 194836, 213150, 242364,\n    271106, 305117, 338133, 377918, 416845, 468049, 527767, 591704,\n    656866, 715353, 777796, 851308, 928436, 1000249, 1082054, 1174652\n]\n\ndef f(r)\n    sq = 0.0\n    len = ACTUAL.length\n    for i in 1 .. len\n        j = i - 1\n        eri = Math.exp(r * j)\n        guess = (N0 * eri) / (1 + N0 * (eri - 1.0) / K)\n        diff = guess - ACTUAL[j]\n        sq += diff * diff\n    end\n    return sq\nend\n\ndef solve(fn, guess=0.5, epsilon=0.0)\n    delta = guess ? guess : 1.0\n    f0 = send(fn, guess)\n    factor = 2.0\n    while delta > epsilon and guess != guess - delta\n        nf = send(fn, guess - delta)\n        if nf < f0 then\n            f0 = nf\n            guess -= delta\n        else\n            nf = send(fn, guess + delta)\n            if nf < f0 then\n                f0 = nf\n                guess += delta\n            else\n                factor = 0.5\n            end\n        end\n\n        delta *= factor\n    end\n    return guess\nend\n\ndef main\n    r = solve(:f)\n    r0 = Math.exp(12.0 * r)\n    print \"r = \", r, \", R0 = \", r0, \"\\n\"\nend\n\nmain()\n", "target": "import java.util.List;\nimport java.util.function.Function;\n\npublic class LogisticCurveFitting {\n    private static final double K = 7.8e9;\n    private static final int N0 = 27;\n\n    private static final List<Double> ACTUAL = List.of(\n        27.0, 27.0, 27.0, 44.0, 44.0, 59.0, 59.0, 59.0, 59.0, 59.0, 59.0, 59.0, 59.0, 60.0, 60.0,\n        61.0, 61.0, 66.0, 83.0, 219.0, 239.0, 392.0, 534.0, 631.0, 897.0, 1350.0, 2023.0, 2820.0,\n        4587.0, 6067.0, 7823.0, 9826.0, 11946.0, 14554.0, 17372.0, 20615.0, 24522.0, 28273.0,\n        31491.0, 34933.0, 37552.0, 40540.0, 43105.0, 45177.0, 60328.0, 64543.0, 67103.0,\n        69265.0, 71332.0, 73327.0, 75191.0, 75723.0, 76719.0, 77804.0, 78812.0, 79339.0,\n        80132.0, 80995.0, 82101.0, 83365.0, 85203.0, 87024.0, 89068.0, 90664.0, 93077.0,\n        95316.0, 98172.0, 102133.0, 105824.0, 109695.0, 114232.0, 118610.0, 125497.0,\n        133852.0, 143227.0, 151367.0, 167418.0, 180096.0, 194836.0, 213150.0, 242364.0,\n        271106.0, 305117.0, 338133.0, 377918.0, 416845.0, 468049.0, 527767.0, 591704.0,\n        656866.0, 715353.0, 777796.0, 851308.0, 928436.0, 1000249.0, 1082054.0, 1174652.0\n    );\n\n    private static double f(double r) {\n        var sq = 0.0;\n        var len = ACTUAL.size();\n        for (int i = 0; i < len; i++) {\n            var eri = Math.exp(r * i);\n            var guess = (N0 * eri) / (1.0 + N0 * (eri - 1.0) / K);\n            var diff = guess - ACTUAL.get(i);\n            sq += diff * diff;\n        }\n        return sq;\n    }\n\n    private static double solve(Function<Double, Double> fn) {\n        return solve(fn, 0.5, 0.0);\n    }\n\n    private static double solve(Function<Double, Double> fn, double guess, double epsilon) {\n        double delta;\n        if (guess != 0.0) {\n            delta = guess;\n        } else {\n            delta = 1.0;\n        }\n\n        var f0 = fn.apply(guess);\n        var factor = 2.0;\n\n        while (delta > epsilon && guess != guess - delta) {\n            var nf = fn.apply(guess - delta);\n            if (nf < f0) {\n                f0 = nf;\n                guess -= delta;\n            } else {\n                nf = fn.apply(guess + delta);\n                if (nf < f0) {\n                    f0 = nf;\n                    guess += delta;\n                } else {\n                    factor = 0.5;\n                }\n            }\n\n            delta *= factor;\n        }\n\n        return guess;\n    }\n\n    public static void main(String[] args) {\n        var r = solve(LogisticCurveFitting::f);\n        var r0 = Math.exp(12.0 * r);\n        System.out.printf(\"r =\u00a0%.16f, R0 =\u00a0%.16f\\n\", r, r0);\n    }\n}\n"}
{"id": 354303, "name": "User input_Graphical", "source": "Translate Ruby to Java: require 'tk'\n\ndef main\n  root = TkRoot.new\n  l1 = TkLabel.new(root, \"text\" => \"input a string\")\n  e1 = TkEntry.new(root)\n  l2 = TkLabel.new(root, \"text\" => \"input the number 75000\")\n  e2 = TkEntry.new(root) do\n    validate \"focusout\"\n    validatecommand lambda {e2.value.to_i == 75_000}\n    invalidcommand  lambda {focus_number_entry(e2)}\n  end\n  ok = TkButton.new(root) do\n    text \"OK\"\n    command lambda {validate_input(e1, e2)}\n  end\n  Tk.grid(l1, e1)\n  Tk.grid(l2, e2)\n  Tk.grid(\"x\",ok, \"sticky\" => \"w\")  \n  Tk.mainloop\nend\n\ndef validate_input(text_entry, number_entry)\n  if number_entry.value.to_i != 75_000\n    focus_number_entry(number_entry)\n  else\n    puts %Q{You entered: \"\n    root.destroy\n  end\nend\n\ndef focus_number_entry(widget)\n  widget \\\n    .configure(\"background\" => \"red\", \"foreground\" => \"white\") \\\n    .selection_range(0, \"end\") \\\n    .focus\nend\n\nmain\n", "target": "import javax.swing.*;\n\npublic class GetInputSwing {\n    public static void main(String[] args) throws Exception {\n        int number = Integer.parseInt(\n                JOptionPane.showInputDialog (\"Enter an Integer\"));\n        String string = JOptionPane.showInputDialog (\"Enter a String\");\n    }\n}\n"}
{"id": 354304, "name": "Pascal's triangle_Puzzle", "source": "Translate Ruby to Java: require 'rref'\n\npyramid = [\n           [ 151],\n          [nil,nil],\n        [40,nil,nil],\n      [nil,nil,nil,nil],\n    [\"x\", 11,\"y\", 4,\"z\"]\n]\npyramid.each{|row| p row}\n\nequations = [[1,-1,1,0]]   \n\ndef parse_equation(str)\n  eqn = [0] * 4\n  lhs, rhs = str.split(\"=\")\n  eqn[3] = rhs.to_i\n  for term in lhs.split(\"+\")\n    case term\n    when \"x\" then eqn[0] += 1\n    when \"y\" then eqn[1] += 1\n    when \"z\" then eqn[2] += 1\n    else          eqn[3] -= term.to_i\n    end\n  end\n  eqn \nend\n\n-2.downto(-5) do |row|\n  pyramid[row].each_index do |col|\n    val = pyramid[row][col]\n    sum = \"%s+%s\" % [pyramid[row+1][col], pyramid[row+1][col+1]]\n    if val.nil?\n      pyramid[row][col] = sum\n    else\n      equations << parse_equation(sum + \"=\n    end\n  end\nend\n\nreduced = convert_to(reduced_row_echelon_form(equations), :to_i)\n\nfor eqn in reduced\n  if eqn[0] + eqn[1] + eqn[2] != 1\n    fail \"no unique solution! \n  elsif eqn[0] == 1 then x = eqn[3]\n  elsif eqn[1] == 1 then y = eqn[3]\n  elsif eqn[2] == 1 then z = eqn[3]\n  end\nend\n\nputs\nputs \"x == \nputs \"y == \nputs \"z == \n\nanswer = []\nfor row in pyramid\n  answer << row.collect {|cell| eval cell.to_s}\nend\nputs\nanswer.each{|row| p row}\n", "target": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\n\npublic class PascalsTrianglePuzzle {\n\n    public static void main(String[] args) {\n        Matrix mat = new Matrix(Arrays.asList(1d, 0d, 0d, 0d, 0d, 0d, 0d, 0d, -1d, 0d, 0d), \n                                Arrays.asList(0d, 1d, 0d, 0d, 0d, 0d, 0d, 0d, 0d, -1d, 0d),\n                                Arrays.asList(0d, 0d, 0d, 0d, 0d, 0d, 0d, 0d, -1d, 1d, -1d),\n                                Arrays.asList(0d, 0d, 1d, 0d, 0d, 0d, 0d, 0d, 0d, -1d, 0d),\n                                Arrays.asList(0d, 0d, 0d, 1d, 0d, 0d, 0d, 0d, 0d, 0d, -1d),\n                                Arrays.asList(1d, 1d, 0d, 0d, 0d, 0d, 0d, 0d, 0d, 0d, 0d),\n                                Arrays.asList(0d, 1d, 1d, 0d, -1d, 0d, 0d, 0d, 0d, 0d, 0d),\n                                Arrays.asList(0d, 0d, 1d, 1d, 0d, -1d, 0d, 0d, 0d, 0d, 0d),\n                                Arrays.asList(0d, 0d, 0d, 0d, -1d, 0d, 1d, 0d, 0d, 0d, 0d),\n                                Arrays.asList(0d, 0d, 0d, 0d, 1d, 1d, 0d, -1d, 0d, 0d, 0d),\n                                Arrays.asList(0d, 0d, 0d, 0d, 0d, 0d, 1d, 1d, 0d, 0d, 0d));\n        List<Double> b = Arrays.asList(11d, 11d, 0d, 4d, 4d, 40d, 0d, 0d, 40d, 0d, 151d);\n        List<Double> solution = cramersRule(mat, b);\n        System.out.println(\"Solution = \" + cramersRule(mat, b));\n        System.out.printf(\"X =\u00a0%.2f%n\", solution.get(8));\n        System.out.printf(\"Y =\u00a0%.2f%n\", solution.get(9));\n        System.out.printf(\"Z =\u00a0%.2f%n\", solution.get(10));\n    }\n    \n    private static List<Double> cramersRule(Matrix matrix, List<Double> b) {\n        double denominator = matrix.determinant();\n        List<Double> result = new ArrayList<>();\n        for ( int i = 0 ; i < b.size() ; i++ ) {\n            result.add(matrix.replaceColumn(b, i).determinant() / denominator);\n        }\n        return result;\n    }\n        \n    private static class Matrix {\n        \n        private List<List<Double>> matrix;\n        \n        @Override\n        public String toString() {\n            return matrix.toString();\n        }\n        \n        @SafeVarargs\n        public Matrix(List<Double> ... lists) {\n            matrix = new ArrayList<>();\n            for ( List<Double> list : lists) {\n                matrix.add(list);\n            }\n        }\n        \n        public Matrix(List<List<Double>> mat) {\n            matrix = mat;\n        }\n        \n        public double determinant() {\n            if ( matrix.size() == 1 ) {\n                return get(0, 0);\n            }\n            if ( matrix.size() == 2 ) {\n                return get(0, 0) * get(1, 1) - get(0, 1) * get(1, 0);\n            }\n            double sum = 0;\n            double sign = 1;\n            for ( int i = 0 ; i < matrix.size() ; i++ ) {\n                sum += sign * get(0, i) * coFactor(0, i).determinant();\n                sign *= -1;\n            }\n            return sum;\n        }\n        \n        private Matrix coFactor(int row, int col) {\n            List<List<Double>> mat = new ArrayList<>();\n            for ( int i = 0 ; i < matrix.size() ; i++ ) {\n                if ( i == row ) {\n                    continue;\n                }\n                List<Double> list = new ArrayList<>();\n                for ( int j = 0 ; j < matrix.size() ; j++ ) {\n                    if ( j == col ) {\n                        continue;\n                    }\n                    list.add(get(i, j));\n                }\n                mat.add(list);\n            }\n            return new Matrix(mat);\n        }\n\n        private Matrix replaceColumn(List<Double> b, int column) {\n            List<List<Double>> mat = new ArrayList<>();\n            for ( int row = 0 ; row < matrix.size() ; row++ ) {\n                List<Double> list = new ArrayList<>();\n                for ( int col = 0 ; col < matrix.size() ; col++ ) {\n                    double value = get(row, col);\n                    if ( col == column ) {\n                        value = b.get(row);\n                    }\n                    list.add(value);\n                }\n                mat.add(list);\n            }\n            return new Matrix(mat);\n        }\n\n        private double get(int row, int col) {\n            return matrix.get(row).get(col);\n        }\n        \n    }\n\n}\n"}
{"id": 354305, "name": "Pascal's triangle_Puzzle", "source": "Translate Ruby to Java: require 'rref'\n\npyramid = [\n           [ 151],\n          [nil,nil],\n        [40,nil,nil],\n      [nil,nil,nil,nil],\n    [\"x\", 11,\"y\", 4,\"z\"]\n]\npyramid.each{|row| p row}\n\nequations = [[1,-1,1,0]]   \n\ndef parse_equation(str)\n  eqn = [0] * 4\n  lhs, rhs = str.split(\"=\")\n  eqn[3] = rhs.to_i\n  for term in lhs.split(\"+\")\n    case term\n    when \"x\" then eqn[0] += 1\n    when \"y\" then eqn[1] += 1\n    when \"z\" then eqn[2] += 1\n    else          eqn[3] -= term.to_i\n    end\n  end\n  eqn \nend\n\n-2.downto(-5) do |row|\n  pyramid[row].each_index do |col|\n    val = pyramid[row][col]\n    sum = \"%s+%s\" % [pyramid[row+1][col], pyramid[row+1][col+1]]\n    if val.nil?\n      pyramid[row][col] = sum\n    else\n      equations << parse_equation(sum + \"=\n    end\n  end\nend\n\nreduced = convert_to(reduced_row_echelon_form(equations), :to_i)\n\nfor eqn in reduced\n  if eqn[0] + eqn[1] + eqn[2] != 1\n    fail \"no unique solution! \n  elsif eqn[0] == 1 then x = eqn[3]\n  elsif eqn[1] == 1 then y = eqn[3]\n  elsif eqn[2] == 1 then z = eqn[3]\n  end\nend\n\nputs\nputs \"x == \nputs \"y == \nputs \"z == \n\nanswer = []\nfor row in pyramid\n  answer << row.collect {|cell| eval cell.to_s}\nend\nputs\nanswer.each{|row| p row}\n", "target": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\n\npublic class PascalsTrianglePuzzle {\n\n    public static void main(String[] args) {\n        Matrix mat = new Matrix(Arrays.asList(1d, 0d, 0d, 0d, 0d, 0d, 0d, 0d, -1d, 0d, 0d), \n                                Arrays.asList(0d, 1d, 0d, 0d, 0d, 0d, 0d, 0d, 0d, -1d, 0d),\n                                Arrays.asList(0d, 0d, 0d, 0d, 0d, 0d, 0d, 0d, -1d, 1d, -1d),\n                                Arrays.asList(0d, 0d, 1d, 0d, 0d, 0d, 0d, 0d, 0d, -1d, 0d),\n                                Arrays.asList(0d, 0d, 0d, 1d, 0d, 0d, 0d, 0d, 0d, 0d, -1d),\n                                Arrays.asList(1d, 1d, 0d, 0d, 0d, 0d, 0d, 0d, 0d, 0d, 0d),\n                                Arrays.asList(0d, 1d, 1d, 0d, -1d, 0d, 0d, 0d, 0d, 0d, 0d),\n                                Arrays.asList(0d, 0d, 1d, 1d, 0d, -1d, 0d, 0d, 0d, 0d, 0d),\n                                Arrays.asList(0d, 0d, 0d, 0d, -1d, 0d, 1d, 0d, 0d, 0d, 0d),\n                                Arrays.asList(0d, 0d, 0d, 0d, 1d, 1d, 0d, -1d, 0d, 0d, 0d),\n                                Arrays.asList(0d, 0d, 0d, 0d, 0d, 0d, 1d, 1d, 0d, 0d, 0d));\n        List<Double> b = Arrays.asList(11d, 11d, 0d, 4d, 4d, 40d, 0d, 0d, 40d, 0d, 151d);\n        List<Double> solution = cramersRule(mat, b);\n        System.out.println(\"Solution = \" + cramersRule(mat, b));\n        System.out.printf(\"X =\u00a0%.2f%n\", solution.get(8));\n        System.out.printf(\"Y =\u00a0%.2f%n\", solution.get(9));\n        System.out.printf(\"Z =\u00a0%.2f%n\", solution.get(10));\n    }\n    \n    private static List<Double> cramersRule(Matrix matrix, List<Double> b) {\n        double denominator = matrix.determinant();\n        List<Double> result = new ArrayList<>();\n        for ( int i = 0 ; i < b.size() ; i++ ) {\n            result.add(matrix.replaceColumn(b, i).determinant() / denominator);\n        }\n        return result;\n    }\n        \n    private static class Matrix {\n        \n        private List<List<Double>> matrix;\n        \n        @Override\n        public String toString() {\n            return matrix.toString();\n        }\n        \n        @SafeVarargs\n        public Matrix(List<Double> ... lists) {\n            matrix = new ArrayList<>();\n            for ( List<Double> list : lists) {\n                matrix.add(list);\n            }\n        }\n        \n        public Matrix(List<List<Double>> mat) {\n            matrix = mat;\n        }\n        \n        public double determinant() {\n            if ( matrix.size() == 1 ) {\n                return get(0, 0);\n            }\n            if ( matrix.size() == 2 ) {\n                return get(0, 0) * get(1, 1) - get(0, 1) * get(1, 0);\n            }\n            double sum = 0;\n            double sign = 1;\n            for ( int i = 0 ; i < matrix.size() ; i++ ) {\n                sum += sign * get(0, i) * coFactor(0, i).determinant();\n                sign *= -1;\n            }\n            return sum;\n        }\n        \n        private Matrix coFactor(int row, int col) {\n            List<List<Double>> mat = new ArrayList<>();\n            for ( int i = 0 ; i < matrix.size() ; i++ ) {\n                if ( i == row ) {\n                    continue;\n                }\n                List<Double> list = new ArrayList<>();\n                for ( int j = 0 ; j < matrix.size() ; j++ ) {\n                    if ( j == col ) {\n                        continue;\n                    }\n                    list.add(get(i, j));\n                }\n                mat.add(list);\n            }\n            return new Matrix(mat);\n        }\n\n        private Matrix replaceColumn(List<Double> b, int column) {\n            List<List<Double>> mat = new ArrayList<>();\n            for ( int row = 0 ; row < matrix.size() ; row++ ) {\n                List<Double> list = new ArrayList<>();\n                for ( int col = 0 ; col < matrix.size() ; col++ ) {\n                    double value = get(row, col);\n                    if ( col == column ) {\n                        value = b.get(row);\n                    }\n                    list.add(value);\n                }\n                mat.add(list);\n            }\n            return new Matrix(mat);\n        }\n\n        private double get(int row, int col) {\n            return matrix.get(row).get(col);\n        }\n        \n    }\n\n}\n"}
{"id": 354306, "name": "Fractal tree", "source": "Translate Ruby to Java: Shoes.app(:title => \"Fractal Tree\", :width => 600, :height => 600) do\n  background \"\n  stroke \"\n  @deg_to_rad = Math::PI / 180.0\n  \n  def drawTree(x1, y1, angle, depth)\n    if depth != 0\n      x2 = x1 + (Math.cos(angle * @deg_to_rad) * depth * 10.0).to_i\n      y2 = y1 + (Math.sin(angle * @deg_to_rad) * depth * 10.0).to_i\n      \n      line x1, y1, x2, y2\n      \n      drawTree(x2, y2, angle - 20, depth - 1)\n      drawTree(x2, y2, angle + 20, depth - 1)      \n    end\n  end\n  \n  drawTree(300,550,-90,9)\nend\n", "target": "import java.awt.Color;\nimport java.awt.Graphics;\nimport javax.swing.JFrame;\n\npublic class FractalTree extends JFrame {\n\n    public FractalTree() {\n        super(\"Fractal Tree\");\n        setBounds(100, 100, 800, 600);\n        setResizable(false);\n        setDefaultCloseOperation(EXIT_ON_CLOSE);\n    }\n\n    private void drawTree(Graphics g, int x1, int y1, double angle, int depth) {\n        if (depth == 0) return;\n        int x2 = x1 + (int) (Math.cos(Math.toRadians(angle)) * depth * 10.0);\n        int y2 = y1 + (int) (Math.sin(Math.toRadians(angle)) * depth * 10.0);\n        g.drawLine(x1, y1, x2, y2);\n        drawTree(g, x2, y2, angle - 20, depth - 1);\n        drawTree(g, x2, y2, angle + 20, depth - 1);\n    }\n\n    @Override\n    public void paint(Graphics g) {\n        g.setColor(Color.BLACK);\n        drawTree(g, 400, 500, -90, 9);\n    }\n\n    public static void main(String[] args) {\n        new FractalTree().setVisible(true);\n    }\n}\n"}
{"id": 354307, "name": "Rock-paper-scissors", "source": "Translate Ruby to Java: \nenum Choice\n  Rock\n  Paper\n  Scissors\nend\n\nBEATS = {\n  Choice::Rock     => [Choice::Paper],\n  Choice::Paper    => [Choice::Scissors],\n  Choice::Scissors => [Choice::Rock],\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nclass RPSAI\n  @stats = {} of Choice => Int32\n\n  def initialize\n    Choice.values.each do |c|\n      @stats[c] = 1\n    end\n  end\n\n  def choose\n    v = rand(@stats.values.sum)\n    @stats.each do |choice, rate|\n      v -= rate\n      return choice if v < 0\n    end\n    raise \"\"\n  end\n\n  def train(selected)\n    BEATS[selected].each do |c|\n      @stats[c] += 1\n    end\n  end\nend\n\nenum GameResult\n  HumanWin\n  ComputerWin\n  Draw\n\n  def to_s\n    case self\n    when .draw?\n      \"Draw\"\n    when .human_win?\n      \"You win!\"\n    when .computer_win?\n      \"I win!\"\n    end\n  end\nend\n\nclass RPSGame\n  @score = Hash(GameResult, Int32).new(0)\n  @ai = RPSAI.new\n\n  def check(player, computer)\n    return GameResult::ComputerWin if BEATS[player].includes? computer\n    return GameResult::HumanWin if BEATS[computer].includes? player\n    return GameResult::Draw\n  end\n\n  def round\n    puts \"\"\n    print \"Your choice (\n    s = gets.not_nil!.strip.downcase\n    return false if \"quit\".starts_with? s\n    player_turn = Choice.values.find { |choice| choice.to_s.downcase.starts_with? s }\n    unless player_turn\n      puts \"Invalid choice\"\n      return true\n    end\n    ai_turn = @ai.choose\n    result = check(player_turn, ai_turn)\n    puts \"H: \n    @score[result] += 1\n    puts \"score: human=%d, computer=%d, draw=%d\" % GameResult.values.map { |r| @score[r] }\n    @ai.train player_turn\n    true\n  end\nend\n\ngame = RPSGame.new\nloop do\n  break unless game.round\nend\n", "target": "import java.util.Arrays;\nimport java.util.EnumMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Scanner;\nimport java.util.Random;\n\npublic class RPS {\n\tpublic enum Item{\n\t\tROCK, PAPER, SCISSORS, ;\n\t\tpublic List<Item> losesToList;\n\t\tpublic boolean losesTo(Item other) {\n\t\t\treturn losesToList.contains(other);\n\t\t}\n\t\tstatic {\n\t\t\tSCISSORS.losesToList = Arrays.asList(ROCK);\n\t\t\tROCK.losesToList = Arrays.asList(PAPER);\n\t\t\tPAPER.losesToList = Arrays.asList(SCISSORS);\n\t\t\t\n                }\n\t}\n\t\n\tpublic final Map<Item, Integer> counts = new EnumMap<Item, Integer>(Item.class){{\n\t\tfor(Item item:Item.values())\n\t\t\tput(item, 1);\n\t}};\n\n\tprivate int totalThrows = Item.values().length;\n\n\tpublic static void main(String[] args){\n\t\tRPS rps = new RPS();\n\t\trps.run();\n\t}\n\n\tpublic void run() {\n\t\tScanner in = new Scanner(System.in);\n\t\tSystem.out.print(\"Make your choice: \");\n\t\twhile(in.hasNextLine()){\n\t\t\tItem aiChoice = getAIChoice();\n\t\t\tString input = in.nextLine();\n\t\t\tItem choice;\n\t\t\ttry{\n\t\t\t\tchoice = Item.valueOf(input.toUpperCase());\n\t\t\t}catch (IllegalArgumentException ex){\n\t\t\t\tSystem.out.println(\"Invalid choice\");\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tcounts.put(choice, counts.get(choice) + 1);\n\t\t\ttotalThrows++;\n\t\t\tSystem.out.println(\"Computer chose: \" + aiChoice);\n\t\t\tif(aiChoice == choice){\n\t\t\t\tSystem.out.println(\"Tie!\");\n\t\t\t}else if(aiChoice.losesTo(choice)){\n\t\t\t\tSystem.out.println(\"You chose...wisely. You win!\");\n\t\t\t}else{\n\t\t\t\tSystem.out.println(\"You chose...poorly. You lose!\");\n\t\t\t}\n\t\t\tSystem.out.print(\"Make your choice: \");\n\t\t}\n\t}\n\n\tprivate static final Random rng = new Random();\n\tprivate Item getAIChoice() {\n\t\tint rand = rng.nextInt(totalThrows);\n\t\tfor(Map.Entry<Item, Integer> entry:counts.entrySet()){\n\t\t\tItem item = entry.getKey();\n\t\t\tint count = entry.getValue();\n\t\t\tif(rand < count){\n\t\t\t\tList<Item> losesTo = item.losesToList;\n\t\t\t\treturn losesTo.get(rng.nextInt(losesTo.size()));\n\t\t\t}\n\t\t\trand -= count;\n\t\t}\n\t\treturn null;\n\t}\n}\n"}
{"id": 354308, "name": "Benford's law", "source": "Translate Ruby to Java: require \"big\"\n\nEXPECTED = (1..9).map{ |d| Math.log10(1 + 1.0 / d) }\n \ndef fib(n)\n  a, b = 0.to_big_i, 1.to_big_i\n  (0...n).map { ret, a, b = a, b, a + b; ret }\nend\n \n\ndef power_of_threes(n)\n  (0...n).map { |k| 3.to_big_i ** k }\nend\n \ndef heads(s)\n  s.map { |a| a.to_s[0].to_i }\nend\n\ndef show_dist(title, s)\n  s = heads(s)\n  c = Array.new(10, 0)\n  s.each{ |x| c[x] += 1 }\n  siz = s.size\n  res = (1..9).map{ |d| c[d] / siz }\n  puts \"\\n    %s Benfords deviation\" % title\n  res.zip(EXPECTED).each_with_index(1) do |(r, e), i|\n    puts \"%2d: %5.1f%%  %5.1f%%  %5.1f%%\" % [i, r*100, e*100, (r - e).abs*100]\n  end\nend\n\ndef random(n)\n  (0...n).map { |i| rand(1..n) }\nend\n \nshow_dist(\"fibbed\", fib(1000))\nshow_dist(\"threes\", power_of_threes(1000))\n \n\nshow_dist(\"random\", random(10000))\n", "target": "import java.math.BigInteger;\nimport java.util.Locale;\n\npublic class BenfordsLaw {\n\n    private static BigInteger[] generateFibonacci(int n) {\n        BigInteger[] fib = new BigInteger[n];\n        fib[0] = BigInteger.ONE;\n        fib[1] = BigInteger.ONE;\n        for (int i = 2; i < fib.length; i++) {\n            fib[i] = fib[i - 2].add(fib[i - 1]);\n        }\n        return fib;\n    }\n\n    public static void main(String[] args) {\n        BigInteger[] numbers = generateFibonacci(1000);\n\n        int[] firstDigits = new int[10];\n        for (BigInteger number : numbers) {\n            firstDigits[Integer.valueOf(number.toString().substring(0, 1))]++;\n        }\n\n        for (int i = 1; i < firstDigits.length; i++) {\n            System.out.printf(Locale.ROOT, \"%d %10.6f %10.6f%n\",\n                    i, (double) firstDigits[i] / numbers.length, Math.log10(1.0 + 1.0 / i));\n        }\n    }\n}\n"}
{"id": 354309, "name": "Benford's law", "source": "Translate Ruby to Java: require \"big\"\n\nEXPECTED = (1..9).map{ |d| Math.log10(1 + 1.0 / d) }\n \ndef fib(n)\n  a, b = 0.to_big_i, 1.to_big_i\n  (0...n).map { ret, a, b = a, b, a + b; ret }\nend\n \n\ndef power_of_threes(n)\n  (0...n).map { |k| 3.to_big_i ** k }\nend\n \ndef heads(s)\n  s.map { |a| a.to_s[0].to_i }\nend\n\ndef show_dist(title, s)\n  s = heads(s)\n  c = Array.new(10, 0)\n  s.each{ |x| c[x] += 1 }\n  siz = s.size\n  res = (1..9).map{ |d| c[d] / siz }\n  puts \"\\n    %s Benfords deviation\" % title\n  res.zip(EXPECTED).each_with_index(1) do |(r, e), i|\n    puts \"%2d: %5.1f%%  %5.1f%%  %5.1f%%\" % [i, r*100, e*100, (r - e).abs*100]\n  end\nend\n\ndef random(n)\n  (0...n).map { |i| rand(1..n) }\nend\n \nshow_dist(\"fibbed\", fib(1000))\nshow_dist(\"threes\", power_of_threes(1000))\n \n\nshow_dist(\"random\", random(10000))\n", "target": "import java.math.BigInteger;\nimport java.util.Locale;\n\npublic class BenfordsLaw {\n\n    private static BigInteger[] generateFibonacci(int n) {\n        BigInteger[] fib = new BigInteger[n];\n        fib[0] = BigInteger.ONE;\n        fib[1] = BigInteger.ONE;\n        for (int i = 2; i < fib.length; i++) {\n            fib[i] = fib[i - 2].add(fib[i - 1]);\n        }\n        return fib;\n    }\n\n    public static void main(String[] args) {\n        BigInteger[] numbers = generateFibonacci(1000);\n\n        int[] firstDigits = new int[10];\n        for (BigInteger number : numbers) {\n            firstDigits[Integer.valueOf(number.toString().substring(0, 1))]++;\n        }\n\n        for (int i = 1; i < firstDigits.length; i++) {\n            System.out.printf(Locale.ROOT, \"%d %10.6f %10.6f%n\",\n                    i, (double) firstDigits[i] / numbers.length, Math.log10(1.0 + 1.0 / i));\n        }\n    }\n}\n"}
{"id": 354310, "name": "Hickerson series of almost integers", "source": "Translate Ruby to Java: require \"big\"\n \nLN2 = Math.log(2).to_big_f\n\nFACTORIALS = Hash(Int32, Float64).new{|h,k| h[k] = k * h[k-1]}\nFACTORIALS[0] = 1\n \ndef hickerson(n)\n  FACTORIALS[n] / (2 * LN2 ** (n+1))\nend\n \ndef nearly_int?(n)\n  int = n.round\n  (int - 0.1..int + 0.1).includes? n\nend\n \n1.upto(17) do |n|\n  h = hickerson(n)\n  str = nearly_int?(h) ? \"nearly integer\" : \"NOT nearly integer\"\n  puts \"n:%3i h: %s\\t%s\" % [n, h, str]\nend\n", "target": "import java.math.*;\n\npublic class Hickerson {\n\n    final static String LN2 = \"0.693147180559945309417232121458\";\n\n    public static void main(String[] args) {\n        for (int n = 1; n <= 17; n++)\n            System.out.printf(\"%2s is almost integer: %s%n\", n, almostInteger(n));\n    }\n\n    static boolean almostInteger(int n) {\n        BigDecimal a = new BigDecimal(LN2);\n        a = a.pow(n + 1).multiply(BigDecimal.valueOf(2));\n\n        long f = n;\n        while (--n > 1)\n            f *= n;\n\n        BigDecimal b = new BigDecimal(f);\n        b = b.divide(a, MathContext.DECIMAL128);\n\n        BigInteger c = b.movePointRight(1).toBigInteger().mod(BigInteger.TEN);\n\n        return c.toString().matches(\"0|9\");\n    }\n}\n"}
{"id": 354311, "name": "Hickerson series of almost integers", "source": "Translate Ruby to Java: require \"big\"\n \nLN2 = Math.log(2).to_big_f\n\nFACTORIALS = Hash(Int32, Float64).new{|h,k| h[k] = k * h[k-1]}\nFACTORIALS[0] = 1\n \ndef hickerson(n)\n  FACTORIALS[n] / (2 * LN2 ** (n+1))\nend\n \ndef nearly_int?(n)\n  int = n.round\n  (int - 0.1..int + 0.1).includes? n\nend\n \n1.upto(17) do |n|\n  h = hickerson(n)\n  str = nearly_int?(h) ? \"nearly integer\" : \"NOT nearly integer\"\n  puts \"n:%3i h: %s\\t%s\" % [n, h, str]\nend\n", "target": "import java.math.*;\n\npublic class Hickerson {\n\n    final static String LN2 = \"0.693147180559945309417232121458\";\n\n    public static void main(String[] args) {\n        for (int n = 1; n <= 17; n++)\n            System.out.printf(\"%2s is almost integer: %s%n\", n, almostInteger(n));\n    }\n\n    static boolean almostInteger(int n) {\n        BigDecimal a = new BigDecimal(LN2);\n        a = a.pow(n + 1).multiply(BigDecimal.valueOf(2));\n\n        long f = n;\n        while (--n > 1)\n            f *= n;\n\n        BigDecimal b = new BigDecimal(f);\n        b = b.divide(a, MathContext.DECIMAL128);\n\n        BigInteger c = b.movePointRight(1).toBigInteger().mod(BigInteger.TEN);\n\n        return c.toString().matches(\"0|9\");\n    }\n}\n"}
{"id": 354312, "name": "Read a configuration file", "source": "Translate Ruby to Java: fullname = favouritefruit = \"\"\nneedspeeling = seedsremoved = false\notherfamily = []\n\nIO.foreach(\"config.file\") do |line|\n  line.chomp!\n  key, value = line.split(nil, 2)\n  case key\n  when /^([\n  when \"FULLNAME\"; fullname = value\n  when \"FAVOURITEFRUIT\"; favouritefruit = value\n  when \"NEEDSPEELING\"; needspeeling = true\n  when \"SEEDSREMOVED\"; seedsremoved = true\n  when \"OTHERFAMILY\"; otherfamily = value.split(\",\").map(&:strip)\n  when /^./; puts \"\n  end\nend\n\nputs \"fullname       = \nputs \"favouritefruit = \nputs \"needspeeling   = \nputs \"seedsremoved   = \notherfamily.each_with_index do |name, i|\n  puts \"otherfamily(\nend\n", "target": "import java.io.BufferedReader;\nimport java.io.FileReader;\nimport java.io.IOException;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\npublic class ConfigReader {\n    private static final Pattern             LINE_PATTERN = Pattern.compile( \"([^ =]+)[ =]?(.*)\" );\n    private static final Map<String, Object> DEFAULTS     = new HashMap<String, Object>() {{\n        put( \"needspeeling\", false );\n        put( \"seedsremoved\", false );\n    }};\n\n    public static void main( final String[] args ) {\n        System.out.println( parseFile( args[ 0 ] ) );\n    }\n\n    public static Map<String, Object> parseFile( final String fileName ) {\n        final Map<String, Object> result = new HashMap<String, Object>( DEFAULTS );\n         BufferedReader      reader = null;\n\n        try {\n            reader = new BufferedReader( new FileReader( fileName ) );\n            for ( String line; null != ( line = reader.readLine() );  ) {\n                parseLine( line, result );\n            }\n        } catch ( final IOException x ) {\n            throw new RuntimeException( \"Oops: \" + x, x );\n        } finally {\n            if ( null != reader ) try {\n                reader.close();\n            } catch ( final IOException x2 ) {\n                System.err.println( \"Could not close \" + fileName + \" - \" + x2 );\n            }\n        }\n\n        return result;\n    }\n\n    private static void parseLine( final String line, final Map<String, Object> map ) {\n        if ( \"\".equals( line.trim() ) || line.startsWith( \"#\" ) || line.startsWith( \";\" ) )\n            return;\n\n        final Matcher matcher = LINE_PATTERN.matcher( line );\n\n        if ( ! matcher.matches() ) {\n            System.err.println( \"Bad config line: \" + line );\n            return;\n        }\n\n        final String key   = matcher.group( 1 ).trim().toLowerCase();\n        final String value = matcher.group( 2 ).trim();\n\n        if ( \"\".equals( value ) ) {\n            map.put( key, true );\n        } else if ( -1 == value.indexOf( ',' ) ) {\n            map.put( key, value );\n        } else {\n            final String[] values = value.split( \",\" );\n\n            for ( int i = 0; i < values.length; i++ ) {\n                values[ i ] = values[ i ].trim();\n            }\n            map.put( key, Arrays.asList( values ) );\n        }\n    }\n}\n"}
{"id": 354313, "name": "Kronecker product based fractals", "source": "Translate Ruby to Java: func kronecker_product (a, b) { a ~X b -> map { _[0] ~X* _[1] } }\n\nfunc kronecker_fractal(pattern, order=4) {\n    var kronecker = pattern\n    { kronecker = kronecker_product(kronecker, pattern) } * order\n    return kronecker\n}\n\nvar vicsek = [[0,1,0], [1,1,1], [0,1,0]]\nvar carpet = [[1,1,1], [1,0,1], [1,1,1]]\nvar six    = [[0,1,1,1,0], [1,0,0,0,1], [1,0,0,0,0],\n              [1,1,1,1,0], [1,0,0,0,1], [1,0,0,0,1], [0,1,1,1,0]]\n\nrequire(\"Imager\")\n\nfor name,shape,order in [\n    [:vicsek, vicsek, 4],\n    [:carpet, carpet, 4],\n    [:six,    six,    3],\n] {\n    var pat = kronecker_fractal(shape, order)\n    var img = %O<Imager>.new(xsize => pat[0].len, ysize => pat.len)\n    for x,y in (^pat[0].len ~X ^pat.len) {\n        img.setpixel(x => x, y => y, color => (pat[y][x] ? <255 255 32> : <16 16 16>))\n    }\n    img.write(file => \"kronecker-\n}\n", "target": "package kronecker;\n\n\npublic class ProductFractals {\n  \n  public static int[][] product(final int[][] a, final int[][] b) {\n    \n    \n    final int[][] c = new int[a.length*b.length][];\n    \n    \n    for (int ix = 0; ix < c.length; ix++) {\n      final int num_cols = a[0].length*b[0].length;\n      c[ix] = new int[num_cols];\n    }\n    \n    \n    for (int ia = 0; ia < a.length; ia++) {\n      for (int ja = 0; ja < a[ia].length; ja++) {\n        \n        for (int ib = 0; ib < b.length; ib++) {\n          for (int jb = 0; jb < b[ib].length; jb++) {\n             c[b.length*ia+ib][b[ib].length*ja+jb] = a[ia][ja] * b[ib][jb];\n          }\n        }\n      }\n    }\n\n    \n    return c;\n  }\n\n  \n  public static void show_matrix(final int[][] m, final char nz, final char z) {\n    for (int im = 0; im < m.length; im++) {\n      for (int jm = 0; jm < m[im].length; jm++) {\n        System.out.print(m[im][jm] == 0 ? z : nz);\n      }\n      System.out.println();\n    }\n  }\n\n  \n  public static int[][] power(final int[][] m, final int n) {\n    \n    int[][] m_pow = m;\n    \n    \n    for (int ix = 1; ix < n; ix++) {\n      m_pow = product(m, m_pow);\n    }\n    return m_pow;\n  }\n\n  \n  private static void test(final int[][] m, final int n) {\n    System.out.println(\"Test matrix\");\n    show_matrix(m, '*', ' ');\n    final int[][] m_pow = power(m, n);\n    System.out.println(\"Matrix power \" + n);\n    show_matrix(m_pow, '*', ' ');\n  }\n\n  \n  private static void test1() {\n    \n    final int[][] m = {{0, 1, 0},\n                       {1, 1, 1},\n                       {0, 1, 0}};\n    \n    test(m, 4);\n  }\n\n  \n  private static void test2() {\n    \n    final int[][] m = {{1, 1, 1},\n                       {1, 0, 1},\n                       {1, 1, 1}};\n    \n    test(m, 4);\n  }\n\n  \n  private static void test3() {\n    \n    final int[][] m = {{1, 0, 1},\n                       {1, 0, 1},\n                       {0, 1, 0}};\n    \n    test(m, 4);\n  }\n\n  \n  public static void main(final String[] args) {\n    \n    test1();\n    test2();\n    test3();\n  }\n\n}\n"}
{"id": 354314, "name": "Additive primes", "source": "Translate Ruby to Java: \n\n\ndef prime?(n) \n  return false unless (n | 1 == 3 if n < 5) || (n % 6) | 4 == 5\n  sqrt_n = Math.isqrt(n)  \n  pc = typeof(n).new(5)\n  while pc <= sqrt_n\n    return false if n % pc == 0 || n % (pc + 2) == 0\n    pc += 6\n  end\n  true\nend\n\ndef additive_primes(n)\n  primes = [2, 3]\n  pc, inc = 5, 2\n  while pc < n\n    primes << pc if prime?(pc) && prime?(pc.digits.sum)\n    pc += inc; inc ^= 0b110  \n  end\n  primes \nend\n\nnn = 500\naddprimes = additive_primes(nn)\nmaxdigits = addprimes.last.digits.size\naddprimes.each_with_index { |n, idx| printf \"%*d \", maxdigits, n; print \"\\n\" if idx % 10 == 9 } \n\nputs \"\\n\n\nputs\n\nnn = 5000\naddprimes = additive_primes(nn)\nmaxdigits = addprimes.last.digits.size\naddprimes.each_with_index { |n, idx| printf \"%*d \", maxdigits, n; print \"\\n\" if idx % 10 == 9 } \nputs \"\\n\n", "target": "public class additivePrimes {\n\n    public static void main(String[] args) {\n        int additive_primes = 0;\n        for (int i = 2; i < 500; i++) {\n            if(isPrime(i) && isPrime(digitSum(i))){\n                additive_primes++;\n                System.out.print(i + \" \");\n            }\n        }\n        System.out.print(\"\\nFound \" + additive_primes + \" additive primes less than 500\");\n    }\n\n    static boolean isPrime(int n) {\n        int counter = 1;\n        if (n < 2 || (n != 2 && n % 2 == 0) || (n != 3 && n % 3 == 0)) {\n            return false;\n        }\n        while (counter * 6 - 1 <= Math.sqrt(n)) {\n            if (n % (counter * 6 - 1) == 0 || n % (counter * 6 + 1) == 0) {\n                return false;\n            } else {\n                counter++;\n            }\n        }\n        return true;\n    }\n\n    static int digitSum(int n) {\n        int sum = 0;\n        while (n > 0) {\n            sum += n % 10;\n            n /= 10;\n        }\n        return sum;\n    }\n}\n"}
{"id": 354315, "name": "Case-sensitivity of identifiers", "source": "Translate Ruby to Java: module FiveDogs\n  dog = \"Benjamin\"\n  dOg = \"Dogley\"\n  doG = \"Fido\"\n  Dog = \"Samba\"   \n  DOG = \"Bernie\"  \n\n  names = [dog, dOg, doG, Dog, DOG]\n  names.uniq!\n  puts \"There are %d dogs named %s.\" % [names.length, names.join(\", \")]\n  puts\n  puts \"The local variables are %s.\" % local_variables.join(\", \")\n  puts \"The constants are %s.\" % constants.join(\", \")\nend\n", "target": "String dog = \"Benjamin\"; \nString Dog = \"Samba\";    \nString DOG = \"Bernie\";   \n@Inject Console console;\nconsole.print($\"There are three dogs named {dog}, {Dog}, and {DOG}\");\n"}
{"id": 354316, "name": "Extra primes", "source": "Translate Ruby to Java: def nextPrimeDigitNumber(n)\n    if n == 0 then\n        return 2\n    end\n    if n % 10 == 2 then\n        return n + 1\n    end\n    if n % 10 == 3 or n % 10 == 5 then\n        return n + 2\n    end\n    return 2 + nextPrimeDigitNumber((n / 10).floor) * 10\nend\n\ndef isPrime(n)\n    if n < 2 then\n        return false\n    end\n    if n % 2 == 0 then\n        return n == 2\n    end\n    if n % 3 == 0 then\n        return n == 3\n    end\n    if n % 5 == 0 then\n        return n == 5\n    end\n\n    wheel = [4, 2, 4, 2, 4, 6, 2, 6]\n    p = 7\n    loop do\n        for w in wheel\n            if p * p > n then\n                return true\n            end\n            if n % p == 0 then\n                return false\n            end\n            p = p + w\n        end\n    end\nend\n\ndef digitSum(n)\n    sum = 0\n    while n > 0\n        sum = sum + n % 10\n        n = (n / 10).floor\n    end\n    return sum\nend\n\nLIMIT = 10000\np = 0\nn = 0\n\nprint \"Extra primes under %d:\\n\" % [LIMIT]\nwhile p < LIMIT\n    p = nextPrimeDigitNumber(p)\n    if isPrime(p) and isPrime(digitSum(p)) then\n        n = n + 1\n        print \"%2d: %d\\n\" % [n, p]\n    end\nend\nprint \"\\n\"\n", "target": "public class ExtraPrimes {\n    private static int nextPrimeDigitNumber(int n) {\n        if (n == 0) {\n            return 2;\n        }\n        switch (n % 10) {\n            case 2:\n                return n + 1;\n            case 3:\n            case 5:\n                return n + 2;\n            default:\n                return 2 + nextPrimeDigitNumber(n / 10) * 10;\n        }\n    }\n\n    private static boolean isPrime(int n) {\n        if (n < 2) {\n            return false;\n        }\n        if ((n & 1) == 0) {\n            return n == 2;\n        }\n        if (n % 3 == 0) {\n            return n == 3;\n        }\n        if (n % 5 == 0) {\n            return n == 5;\n        }\n\n        int[] wheel = new int[]{4, 2, 4, 2, 4, 6, 2, 6};\n        int p = 7;\n        while (true) {\n            for (int w : wheel) {\n                if (p * p > n) {\n                    return true;\n                }\n                if (n % p == 0) {\n                    return false;\n                }\n                p += w;\n            }\n        }\n    }\n\n    private static int digitSum(int n) {\n        int sum = 0;\n        for (; n > 0; n /= 10) {\n            sum += n % 10;\n        }\n        return sum;\n    }\n\n    public static void main(String[] args) {\n        final int limit = 10_000;\n        int p = 0, n = 0;\n\n        System.out.printf(\"Extra primes under %d:\\n\", limit);\n        while (p < limit) {\n            p = nextPrimeDigitNumber(p);\n            if (isPrime(p) && isPrime(digitSum(p))) {\n                n++;\n                System.out.printf(\"%2d: %d\\n\", n, p);\n            }\n        }\n        System.out.println();\n    }\n}\n"}
{"id": 354317, "name": "Extra primes", "source": "Translate Ruby to Java: def nextPrimeDigitNumber(n)\n    if n == 0 then\n        return 2\n    end\n    if n % 10 == 2 then\n        return n + 1\n    end\n    if n % 10 == 3 or n % 10 == 5 then\n        return n + 2\n    end\n    return 2 + nextPrimeDigitNumber((n / 10).floor) * 10\nend\n\ndef isPrime(n)\n    if n < 2 then\n        return false\n    end\n    if n % 2 == 0 then\n        return n == 2\n    end\n    if n % 3 == 0 then\n        return n == 3\n    end\n    if n % 5 == 0 then\n        return n == 5\n    end\n\n    wheel = [4, 2, 4, 2, 4, 6, 2, 6]\n    p = 7\n    loop do\n        for w in wheel\n            if p * p > n then\n                return true\n            end\n            if n % p == 0 then\n                return false\n            end\n            p = p + w\n        end\n    end\nend\n\ndef digitSum(n)\n    sum = 0\n    while n > 0\n        sum = sum + n % 10\n        n = (n / 10).floor\n    end\n    return sum\nend\n\nLIMIT = 10000\np = 0\nn = 0\n\nprint \"Extra primes under %d:\\n\" % [LIMIT]\nwhile p < LIMIT\n    p = nextPrimeDigitNumber(p)\n    if isPrime(p) and isPrime(digitSum(p)) then\n        n = n + 1\n        print \"%2d: %d\\n\" % [n, p]\n    end\nend\nprint \"\\n\"\n", "target": "public class ExtraPrimes {\n    private static int nextPrimeDigitNumber(int n) {\n        if (n == 0) {\n            return 2;\n        }\n        switch (n % 10) {\n            case 2:\n                return n + 1;\n            case 3:\n            case 5:\n                return n + 2;\n            default:\n                return 2 + nextPrimeDigitNumber(n / 10) * 10;\n        }\n    }\n\n    private static boolean isPrime(int n) {\n        if (n < 2) {\n            return false;\n        }\n        if ((n & 1) == 0) {\n            return n == 2;\n        }\n        if (n % 3 == 0) {\n            return n == 3;\n        }\n        if (n % 5 == 0) {\n            return n == 5;\n        }\n\n        int[] wheel = new int[]{4, 2, 4, 2, 4, 6, 2, 6};\n        int p = 7;\n        while (true) {\n            for (int w : wheel) {\n                if (p * p > n) {\n                    return true;\n                }\n                if (n % p == 0) {\n                    return false;\n                }\n                p += w;\n            }\n        }\n    }\n\n    private static int digitSum(int n) {\n        int sum = 0;\n        for (; n > 0; n /= 10) {\n            sum += n % 10;\n        }\n        return sum;\n    }\n\n    public static void main(String[] args) {\n        final int limit = 10_000;\n        int p = 0, n = 0;\n\n        System.out.printf(\"Extra primes under %d:\\n\", limit);\n        while (p < limit) {\n            p = nextPrimeDigitNumber(p);\n            if (isPrime(p) && isPrime(digitSum(p))) {\n                n++;\n                System.out.printf(\"%2d: %d\\n\", n, p);\n            }\n        }\n        System.out.println();\n    }\n}\n"}
{"id": 354318, "name": "Abbreviations, easy", "source": "Translate Ruby to Java: \n\ncmd_table = File.read(ARGV[0]).split\nuser_str = File.read(ARGV[1]).split\n\nuser_str.each do |abbr|\n  candidate = cmd_table.find do |cmd|\n    cmd.count('A-Z') <= abbr.length && abbr.casecmp(cmd[0...abbr.length]).zero?\n  end\n\n  print candidate.nil? ? '*error*' : candidate.upcase\n\n  print ' '\nend\n\nputs\n", "target": "import java.util.HashMap;\nimport java.util.Map;\nimport java.util.Scanner;\n\npublic class AbbreviationsEasy {\n    private static final Scanner input = new Scanner(System.in);\n    private static final String  COMMAND_TABLE\n            =       \"  Add ALTer  BAckup Bottom  CAppend Change SCHANGE  CInsert CLAst COMPress COpy\\n\" +\n                    \" COUnt COVerlay CURsor DELete CDelete Down DUPlicate Xedit EXPand EXTract Find\\n\" +\n                    \" NFind NFINDUp NFUp CFind FINdup FUp FOrward GET Help HEXType Input POWerinput\\n\" +\n                    \" Join SPlit SPLTJOIN  LOAD  Locate CLocate  LOWercase UPPercase  LPrefix MACRO\\n\" +\n                    \" MErge MODify MOve MSG Next Overlay PARSE PREServe PURge PUT PUTD  Query  QUIT\\n\" +\n                    \" READ  RECover REFRESH RENum REPeat  Replace CReplace  RESet  RESTore  RGTLEFT\\n\" +\n                    \" RIght LEft  SAVE  SET SHift SI  SORT  SOS  STAck STATus TOP TRAnsfer Type Up\";\n\n    public static void main(String[] args) {\n        String[]             cmdTableArr = COMMAND_TABLE.split(\"\\\\s+\");\n        Map<String, Integer> cmd_table   = new HashMap<String, Integer>();\n\n        for (String word : cmdTableArr) {  \n            cmd_table.put(word, countCaps(word));\n        }\n\n        System.out.print(\"Please enter your command to verify: \");\n        String   userInput  = input.nextLine();\n        String[] user_input = userInput.split(\"\\\\s+\");\n\n        for (String s : user_input) {\n            boolean match = false; \n            for (String cmd : cmd_table.keySet()) {\n                if (s.length() >= cmd_table.get(cmd) && s.length() <= cmd.length()) {\n                    String temp = cmd.toUpperCase();\n                    if (temp.startsWith(s.toUpperCase())) {\n                        System.out.print(temp + \" \");\n                        match = true;\n                    }\n                }\n            }\n            if (!match) { \n                System.out.print(\"*error* \");\n            }\n        }\n    }\n\n    private static int countCaps(String word) {\n        int numCaps = 0;\n        for (int i = 0; i < word.length(); i++) {\n            if (Character.isUpperCase(word.charAt(i))) {\n                numCaps++;\n            }\n        }\n        return numCaps;\n    }\n}\n"}
{"id": 354319, "name": "Abbreviations, easy", "source": "Translate Ruby to Java: \n\ncmd_table = File.read(ARGV[0]).split\nuser_str = File.read(ARGV[1]).split\n\nuser_str.each do |abbr|\n  candidate = cmd_table.find do |cmd|\n    cmd.count('A-Z') <= abbr.length && abbr.casecmp(cmd[0...abbr.length]).zero?\n  end\n\n  print candidate.nil? ? '*error*' : candidate.upcase\n\n  print ' '\nend\n\nputs\n", "target": "import java.util.HashMap;\nimport java.util.Map;\nimport java.util.Scanner;\n\npublic class AbbreviationsEasy {\n    private static final Scanner input = new Scanner(System.in);\n    private static final String  COMMAND_TABLE\n            =       \"  Add ALTer  BAckup Bottom  CAppend Change SCHANGE  CInsert CLAst COMPress COpy\\n\" +\n                    \" COUnt COVerlay CURsor DELete CDelete Down DUPlicate Xedit EXPand EXTract Find\\n\" +\n                    \" NFind NFINDUp NFUp CFind FINdup FUp FOrward GET Help HEXType Input POWerinput\\n\" +\n                    \" Join SPlit SPLTJOIN  LOAD  Locate CLocate  LOWercase UPPercase  LPrefix MACRO\\n\" +\n                    \" MErge MODify MOve MSG Next Overlay PARSE PREServe PURge PUT PUTD  Query  QUIT\\n\" +\n                    \" READ  RECover REFRESH RENum REPeat  Replace CReplace  RESet  RESTore  RGTLEFT\\n\" +\n                    \" RIght LEft  SAVE  SET SHift SI  SORT  SOS  STAck STATus TOP TRAnsfer Type Up\";\n\n    public static void main(String[] args) {\n        String[]             cmdTableArr = COMMAND_TABLE.split(\"\\\\s+\");\n        Map<String, Integer> cmd_table   = new HashMap<String, Integer>();\n\n        for (String word : cmdTableArr) {  \n            cmd_table.put(word, countCaps(word));\n        }\n\n        System.out.print(\"Please enter your command to verify: \");\n        String   userInput  = input.nextLine();\n        String[] user_input = userInput.split(\"\\\\s+\");\n\n        for (String s : user_input) {\n            boolean match = false; \n            for (String cmd : cmd_table.keySet()) {\n                if (s.length() >= cmd_table.get(cmd) && s.length() <= cmd.length()) {\n                    String temp = cmd.toUpperCase();\n                    if (temp.startsWith(s.toUpperCase())) {\n                        System.out.print(temp + \" \");\n                        match = true;\n                    }\n                }\n            }\n            if (!match) { \n                System.out.print(\"*error* \");\n            }\n        }\n    }\n\n    private static int countCaps(String word) {\n        int numCaps = 0;\n        for (int i = 0; i < word.length(); i++) {\n            if (Character.isUpperCase(word.charAt(i))) {\n                numCaps++;\n            }\n        }\n        return numCaps;\n    }\n}\n"}
{"id": 354320, "name": "Sorting algorithms_Stooge sort", "source": "Translate Ruby to Java: class Array\n  def stoogesort\n    self.dup.stoogesort!\n  end\n\n  def stoogesort!(i = 0, j = self.length-1)\n    if self[j] < self[i]\n      self[i], self[j] = self[j], self[i]\n    end\n    if j - i > 1\n      t = (j - i + 1)/3\n      stoogesort!(i, j-t)\n      stoogesort!(i+t, j)\n      stoogesort!(i, j-t)\n    end\n    self\n  end\nend\n\np [1,4,5,3,-6,3,7,10,-2,-5].stoogesort\n", "target": "import java.util.Arrays;\n\npublic class Stooge {\n    public static void main(String[] args) {\n        int[] nums = {1, 4, 5, 3, -6, 3, 7, 10, -2, -5};\n        stoogeSort(nums);\n        System.out.println(Arrays.toString(nums));\n    }\n\n    public static void stoogeSort(int[] L) {\n        stoogeSort(L, 0, L.length - 1);\n    }\n\n    public static void stoogeSort(int[] L, int i, int j) {\n        if (L[j] < L[i]) {\n            int tmp = L[i];\n            L[i] = L[j];\n            L[j] = tmp;\n        }\n        if (j - i > 1) {\n            int t = (j - i + 1) / 3;\n            stoogeSort(L, i, j - t);\n            stoogeSort(L, i + t, j);\n            stoogeSort(L, i, j - t);\n        }\n    }\n}\n"}
{"id": 354321, "name": "Truncate a file", "source": "Translate Ruby to Java: \nFile.open(\"file\", \"ab\") do |f|\n  f.truncate(1234)\n  f << \"Killroy was here\" \nend  \n\n\nFile.truncate(\"file\", 567)\n", "target": "import java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.nio.channels.FileChannel;\n\npublic class TruncFile {\n\tpublic static void main(String[] args) throws IOException{\n\t\tif(args.length < 2){\n\t\t\tSystem.out.println(\"Usage: java TruncFile fileName newSize\");\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tFileChannel outChan = new FileOutputStream(args[0], true).getChannel();\n\t\tlong newSize = Long.parseLong(args[1]);\n\t\toutChan.truncate(newSize);\n\t\toutChan.close();\n\t}\n}\n"}
{"id": 354322, "name": "Read a specific line from a file", "source": "Translate Ruby to Java:  seventh_line = open(\"/etc/passwd\").each_line.take(7).last\n", "target": "package linenbr7;\n\nimport java.io.*;\n\npublic class LineNbr7 {\n\n    public static void main(String[] args) throws Exception {\n        File f = new File(args[0]);\n        if (!f.isFile() || !f.canRead())\n            throw new IOException(\"can't read \" + args[0]);\n\n        BufferedReader br = new BufferedReader(new FileReader(f));\n        try (LineNumberReader lnr = new LineNumberReader(br)) {\n            String line = null;\n            int lnum = 0;\n            while ((line = lnr.readLine()) != null\n                    && (lnum = lnr.getLineNumber()) < 7) {\n            }\n\n            switch (lnum) {\n                case 0:\n                    System.out.println(\"the file has zero length\");\n                    break;\n                case 7:\n                    boolean empty = \"\".equals(line);\n                    System.out.println(\"line 7: \" + (empty ? \"empty\" : line));\n                    break;\n                default:\n                    System.out.println(\"the file has only \" + lnum + \" line(s)\");\n            }\n        }\n    }\n}\n"}
{"id": 354323, "name": "Read a specific line from a file", "source": "Translate Ruby to Java:  seventh_line = open(\"/etc/passwd\").each_line.take(7).last\n", "target": "package linenbr7;\n\nimport java.io.*;\n\npublic class LineNbr7 {\n\n    public static void main(String[] args) throws Exception {\n        File f = new File(args[0]);\n        if (!f.isFile() || !f.canRead())\n            throw new IOException(\"can't read \" + args[0]);\n\n        BufferedReader br = new BufferedReader(new FileReader(f));\n        try (LineNumberReader lnr = new LineNumberReader(br)) {\n            String line = null;\n            int lnum = 0;\n            while ((line = lnr.readLine()) != null\n                    && (lnum = lnr.getLineNumber()) < 7) {\n            }\n\n            switch (lnum) {\n                case 0:\n                    System.out.println(\"the file has zero length\");\n                    break;\n                case 7:\n                    boolean empty = \"\".equals(line);\n                    System.out.println(\"line 7: \" + (empty ? \"empty\" : line));\n                    break;\n                default:\n                    System.out.println(\"the file has only \" + lnum + \" line(s)\");\n            }\n        }\n    }\n}\n"}
{"id": 354324, "name": "URL encoding", "source": "Translate Ruby to Java: require 'cgi'\nputs CGI.escape(\"http://foo bar/\").gsub(\"+\", \"%20\")\n\n", "target": "import java.io.UnsupportedEncodingException;\nimport java.net.URLEncoder;\n\npublic class Main\n{\n    public static void main(String[] args) throws UnsupportedEncodingException\n    {\n        String normal = \"http:\n        String encoded = URLEncoder.encode(normal, \"utf-8\");\n        System.out.println(encoded);\n    }\n}\n"}
{"id": 354325, "name": "URL encoding", "source": "Translate Ruby to Java: require 'cgi'\nputs CGI.escape(\"http://foo bar/\").gsub(\"+\", \"%20\")\n\n", "target": "import java.io.UnsupportedEncodingException;\nimport java.net.URLEncoder;\n\npublic class Main\n{\n    public static void main(String[] args) throws UnsupportedEncodingException\n    {\n        String normal = \"http:\n        String encoded = URLEncoder.encode(normal, \"utf-8\");\n        System.out.println(encoded);\n    }\n}\n"}
{"id": 354326, "name": "LU decomposition", "source": "Translate Ruby to Java: require 'matrix'\n\nclass Matrix\n  def lu_decomposition\n    p = get_pivot\n    tmp = p * self\n    u = Matrix.zero(row_size).to_a\n    l = Matrix.identity(row_size).to_a\n    (0 ... row_size).each do |i|\n      (0 ... row_size).each do |j|\n        if j >= i\n          \n          u[i][j] = tmp[i,j] - (0 ... i).inject(0.0) {|sum, k| sum + u[k][j] * l[i][k]}\n        else\n          \n          l[i][j] = (tmp[i,j] - (0 ... j).inject(0.0) {|sum, k| sum + u[k][j] * l[i][k]}) / u[j][j]\n        end\n      end\n    end\n    [ Matrix[*l], Matrix[*u], p ]\n  end\n  \n  def get_pivot\n    raise ArgumentError, \"must be square\" unless square?\n    id = Matrix.identity(row_size).to_a\n    (0 ... row_size).each do |i|\n      max = self[i,i]\n      row = i\n      (i ... row_size).each do |j|\n        if self[j,i] > max\n          max = self[j,i]\n          row = j\n        end\n      end\n      id[i], id[row] = id[row], id[i]\n    end\n    Matrix[*id]\n  end\n  \n  def pretty_print(format, head=nil)\n    puts head if head\n    puts each_slice(column_size).map{|row| format*row_size % row}\n  end\nend\n\nputs \"Example 1:\"\na = Matrix[[1,  3,  5],\n           [2,  4,  7],\n           [1,  1,  0]]\na.pretty_print(\" %2d\", \"A\")\nl, u, p = a.lu_decomposition\nl.pretty_print(\" %8.5f\", \"L\")\nu.pretty_print(\" %8.5f\", \"U\")\np.pretty_print(\" %d\",    \"P\")\n\nputs \"\\nExample 2:\"\na = Matrix[[11, 9,24,2], \n           [ 1, 5, 2,6], \n           [ 3,17,18,1], \n           [ 2, 5, 7,1]]\na.pretty_print(\" %2d\", \"A\")\nl, u, p = a.lu_decomposition\nl.pretty_print(\" %8.5f\", \"L\")\nu.pretty_print(\" %8.5f\", \"U\")\np.pretty_print(\" %d\",    \"P\")\n", "target": "import static java.util.Arrays.stream;\nimport java.util.Locale;\nimport static java.util.stream.IntStream.range;\n\npublic class Test {\n\n    static double dotProduct(double[] a, double[] b) {\n        return range(0, a.length).mapToDouble(i -> a[i] * b[i]).sum();\n    }\n\n    static double[][] matrixMul(double[][] A, double[][] B) {\n        double[][] result = new double[A.length][B[0].length];\n        double[] aux = new double[B.length];\n\n        for (int j = 0; j < B[0].length; j++) {\n\n            for (int k = 0; k < B.length; k++)\n                aux[k] = B[k][j];\n\n            for (int i = 0; i < A.length; i++)\n                result[i][j] = dotProduct(A[i], aux);\n        }\n        return result;\n    }\n\n    static double[][] pivotize(double[][] m) {\n        int n = m.length;\n        double[][] id = range(0, n).mapToObj(j -> range(0, n)\n                .mapToDouble(i -> i == j ? 1 : 0).toArray())\n                .toArray(double[][]::new);\n\n        for (int i = 0; i < n; i++) {\n            double maxm = m[i][i];\n            int row = i;\n            for (int j = i; j < n; j++)\n                if (m[j][i] > maxm) {\n                    maxm = m[j][i];\n                    row = j;\n                }\n\n            if (i != row) {\n                double[] tmp = id[i];\n                id[i] = id[row];\n                id[row] = tmp;\n            }\n        }\n        return id;\n    }\n\n    static double[][][] lu(double[][] A) {\n        int n = A.length;\n        double[][] L = new double[n][n];\n        double[][] U = new double[n][n];\n        double[][] P = pivotize(A);\n        double[][] A2 = matrixMul(P, A);\n\n        for (int j = 0; j < n; j++) {\n            L[j][j] = 1;\n            for (int i = 0; i < j + 1; i++) {\n                double s1 = 0;\n                for (int k = 0; k < i; k++)\n                    s1 += U[k][j] * L[i][k];\n                U[i][j] = A2[i][j] - s1;\n            }\n            for (int i = j; i < n; i++) {\n                double s2 = 0;\n                for (int k = 0; k < j; k++)\n                    s2 += U[k][j] * L[i][k];\n                L[i][j] = (A2[i][j] - s2) / U[j][j];\n            }\n        }\n        return new double[][][]{L, U, P};\n    }\n\n    static void print(double[][] m) {\n        stream(m).forEach(a -> {\n            stream(a).forEach(n -> System.out.printf(Locale.US, \"%5.1f \", n));\n            System.out.println();\n        });\n        System.out.println();\n    }\n\n    public static void main(String[] args) {\n        double[][] a = {{1.0, 3, 5}, {2.0, 4, 7}, {1.0, 1, 0}};\n\n        double[][] b = {{11.0, 9, 24, 2}, {1.0, 5, 2, 6}, {3.0, 17, 18, 1},\n        {2.0, 5, 7, 1}};\n\n        for (double[][] m : lu(a))\n            print(m);\n\n        System.out.println();\n\n        for (double[][] m : lu(b))\n            print(m);\n    }\n}\n"}
{"id": 354327, "name": "Optional parameters", "source": "Translate Ruby to Java: def table_sort(table, ordering=:<=>, column=0, reverse=false)\n  \n", "target": "module OptionalParameters\n    {\n    typedef Type<String  >.Orderer as ColumnOrderer;\n    typedef Type<String[]>.Orderer as RowOrderer;\n\n    static String[][] sort(String[][]     table,\n                           ColumnOrderer? orderer = Null,\n                           Int            column  = 0,\n                           Boolean        reverse = False,\n                          )\n        {\n        \n        orderer ?:= (s1, s2) -> s1 <=> s2;\n\n        \n        ColumnOrderer byString = reverse\n                ? ((s1, s2) -> orderer(s1, s2).reversed)\n                : orderer;\n\n        \n        RowOrderer byColumn = (row1, row2) -> byString(row1[column], row2[column]);\n\n        return table.sorted(byColumn);\n        }\n\n    void run()\n        {\n        String[][] table =\n            [\n            [\"c\", \"x\", \"i\"],\n            [\"a\", \"y\", \"p\"],\n            [\"b\", \"z\", \"a\"],\n            ];\n\n        show(\"original input\", table);\n        show(\"by default sort on column 0\", sort(table));\n        show(\"by column 2\", sort(table, column=2));\n        show(\"by column 2 reversed\", sort(table, column=2, reverse=True));\n        }\n\n    void show(String title, String[][] table)\n        {\n        @Inject Console console;\n        console.print($\"{title}:\");\n        for (val row : table)\n            {\n            console.print($\"  {row}\");\n            }\n        console.print();\n        }\n    }\n"}
{"id": 354328, "name": "Numeric error propagation", "source": "Translate Ruby to Java: class NumberWithUncertainty\n  def initialize(number, error)\n    @num = number\n    @err = error.abs\n  end\n  attr_reader :num, :err\n\n  def +(other)\n    if other.kind_of?(self.class)\n      self.class.new(num + other.num, Math::hypot(err, other.err))\n    else\n      self.class.new(num + other, err)\n    end\n  end\n\n  def -(other)\n    if other.kind_of?(self.class)\n      self.class.new(num - other.num, Math::hypot(err, other.err))\n    else\n      self.class.new(num - other, err)\n    end\n  end\n\n  def *(other)\n    if other.kind_of?(self.class)\n      prod = num * other.num\n      e = Math::hypot((prod * err / num), (prod * other.err / other.num))\n      self.class.new(prod, e)\n    else\n      self.class.new(num * other, (err * other).abs)\n    end\n  end\n\n  def /(other)\n    if other.kind_of?(self.class)\n      quo = num / other.num\n      e = Math::hypot((quo * err / num), (quo * other.err / other.num))\n      self.class.new(quo, e)\n    else\n      self.class.new(num / other, (err * other).abs)\n    end\n  end\n\n  def **(exponent)\n    Float(exponent) rescue raise ArgumentError, \"not an number: \n    prod = num ** exponent\n    self.class.new(prod, (prod * exponent * err / num).abs)\n  end\n\n  def sqrt\n    self ** 0.5\n  end\n\n  def to_s\n    \"\n  end\nend\n\nx1 = NumberWithUncertainty.new(100, 1.1)\ny1 = NumberWithUncertainty.new( 50, 1.2)\nx2 = NumberWithUncertainty.new(200, 2.2)\ny2 = NumberWithUncertainty.new(100, 2.3)\n\nputs ((x1 - x2) ** 2 + (y1 - y2) ** 2).sqrt\n", "target": "public class Approx {\n    private double value;\n    private double error;\n    \n    public Approx(){this.value = this.error = 0;}\n    \n    public Approx(Approx b){\n        this.value = b.value;\n        this.error = b.error;\n    }\n    \n    public Approx(double value, double error){\n        this.value = value;\n        this.error = error;\n    }\n    \n    public Approx add(Approx b){\n        value+= b.value;\n        error = Math.sqrt(error * error + b.error * b.error);\n        return this;\n    }\n    \n    public Approx add(double b){\n        value+= b;\n        return this;\n    }\n    \n    public Approx sub(Approx b){\n        value-= b.value;\n        error = Math.sqrt(error * error + b.error * b.error);\n        return this;\n    }\n    \n    public Approx sub(double b){\n        value-= b;\n        return this;\n    }\n    \n    public Approx mult(Approx b){\n        double oldVal = value;\n        value*= b.value;\n        error = Math.sqrt(value * value * (error*error) / (oldVal*oldVal) +\n                                  (b.error*b.error) / (b.value*b.value));\n        return this;\n    }\n\n    public Approx mult(double b){\n        value*= b;\n        error = Math.abs(b * error);\n        return this;\n    }\n    \n    public Approx div(Approx b){\n        double oldVal = value;\n        value/= b.value;\n        error = Math.sqrt(value * value * (error*error) / (oldVal*oldVal) +\n                                  (b.error*b.error) / (b.value*b.value));\n        return this;\n    }\n\n    public Approx div(double b){\n        value/= b;\n        error = Math.abs(b * error);\n        return this;\n    }\n    \n    public Approx pow(double b){\n        double oldVal = value;\n        value = Math.pow(value, b);\n        error = Math.abs(value * b * (error / oldVal));\n        return this;\n    }\n    \n    @Override\n    public String toString(){return value+\"\u00b1\"+error;}\n    \n    public static void main(String[] args){\n        Approx x1 = new Approx(100, 1.1);\n        Approx y1 = new Approx(50, 1.2);\n        Approx x2 = new Approx(200, 2.2);\n        Approx y2 = new Approx(100, 2.3);\n        \n        x1.sub(x2).pow(2).add(y1.sub(y2).pow(2)).pow(0.5);\n        \n        System.out.println(x1);\n    }\n}\n"}
{"id": 354329, "name": "Trabb Pardo\u2013Knuth algorithm", "source": "Translate Ruby to Java: def f(x) x.abs ** 0.5 + 5 * x ** 3 end\n\nputs \"Please enter 11 numbers:\"\nnums = 11.times.map{ gets.to_f }\n\nnums.reverse_each do |n|\n  print \"f(\n  res = f(n)\n  puts res > 400 ? \"Overflow!\" : res\nend\n", "target": "\nimport java.util.*;\nimport java.io.*; \n\npublic class TPKA {\n\tpublic static void main(String... args) {\n\t\tdouble[] input = new double[11];\n\t\tdouble userInput = 0.0;\n\t\tScanner in = new Scanner(System.in);\n\t\tfor(int i = 0; i < 11; i++) {\n\t\t\tSystem.out.print(\"Please enter a number: \");\n\t\t\tString s = in.nextLine();\n\t\t\ttry {\n\t\t\t\tuserInput = Double.parseDouble(s);\n\t\t\t} catch (NumberFormatException e) { \n\t\t\t\tSystem.out.println(\"You entered invalid input, exiting\");\n\t\t\t\tSystem.exit(1);\n\t\t\t}\n\t\t\tinput[i] = userInput;\n\t\t}\n\t\tfor(int j = 10; j >= 0; j--) {\n\t\t\tdouble x = input[j]; double y = f(x);\n\t\t\tif( y < 400.0) {\n\t\t\t\tSystem.out.printf(\"f(\u00a0%.2f ) =\u00a0%.2f\\n\", x, y);\n\t\t\t} else {\n\t\t\t\tSystem.out.printf(\"f(\u00a0%.2f ) = %s\\n\", x, \"TOO LARGE\");\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate static double f(double x) {\n\t\treturn Math.pow(Math.abs(x), 0.5) + (5*(Math.pow(x, 3)));\n\t}\n}\n"}
{"id": 354330, "name": "Rate counter", "source": "Translate Ruby to Java: require \"benchmark\"\n\nstruct Document\n  property :id\n  def initialize(@id : Int32) end\nend\n\ndocuments_a = [] of Int32 | Document\ndocuments_h = {} of Int32 => Int32 | Document \n\n1.upto(10_000) do |n|\n  d = Document.new(n)\n  documents_a << d\n  documents_h[d.id] = d\nend\n\nsearchlist = Array.new(1000){ rand(10_000)+1 }\n \nBenchmark.bm do |x|\n  x.report(\"array\"){searchlist.each{ |el| documents_a.any?{ |d| d == el }} }\n  x.report(\"hash\") {searchlist.each{ |el| documents_h.has_key?(el) } }\nend\nputs\nBenchmark.ips do |x|\n  x.report(\"array\"){searchlist.each{ |el| documents_a.any?{ |d| d == el }} }\n  x.report(\"hash\") {searchlist.each{ |el| documents_h.has_key?(el) } }\nend\n", "target": "import java.util.function.Consumer;\n\npublic class RateCounter {\n\n    public static void main(String[] args) {\n        for (double d : benchmark(10, x -> System.out.print(\"\"), 10))\n            System.out.println(d);\n    }\n\n    static double[] benchmark(int n, Consumer<Integer> f, int arg) {\n        double[] timings = new double[n];\n        for (int i = 0; i < n; i++) {\n            long time = System.nanoTime();\n            f.accept(arg);\n            timings[i] = System.nanoTime() - time;\n        }\n        return timings;\n    }\n}\n"}
{"id": 354331, "name": "EKG sequence convergence", "source": "Translate Ruby to Java: class Seq(terms, callback) {\n    method next {\n        terms += callback(terms)\n    }\n\n    method nth(n) {\n        while (terms.len < n) {\n            self.next\n        }\n        terms[n-1]\n    }\n\n    method first(n) {\n        while (terms.len < n) {\n            self.next\n        }\n        terms.first(n)\n    }\n}\n\nfunc next_EKG (s) {\n    2..Inf -> first {|k|\n        !(s.contains(k) || s[-1].is_coprime(k))\n    }\n}\n\nfunc EKG (start) {\n    Seq([1, start], next_EKG)\n}\n\nfunc converge_at(ints) {\n    var ekgs = ints.map(EKG)\n\n    2..Inf -> first {|k|\n        (ekgs.map { .nth(k)        }.uniq.len == 1) &&\n        (ekgs.map { .first(k).sort }.uniq.len == 1)\n    }\n}\n\nfor k in [2, 5, 7, 9, 10] {\n    say \"EKG(\n}\n\nfor arr in [[5,7], [2, 5, 7, 9, 10]] {\n    var c = converge_at(arr)\n    say \"EKGs of \n}\n", "target": "import java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\n\npublic class EKGSequenceConvergence {\n\n    public static void main(String[] args) {\n        System.out.println(\"Calculate and show here the first 10 members of EKG[2], EKG[5], EKG[7], EKG[9] and EKG[10].\");\n        for ( int i : new int[] {2, 5, 7, 9, 10} ) {\n            System.out.printf(\"EKG[%d] = %s%n\", i, ekg(i, 10));\n        }\n        System.out.println(\"Calculate and show here at which term EKG[5] and EKG[7] converge.\");\n        List<Integer> ekg5 = ekg(5, 100);\n        List<Integer> ekg7 = ekg(7, 100);\n        for ( int i = 1 ; i < ekg5.size() ; i++ ) {\n            if ( ekg5.get(i) == ekg7.get(i) && sameSeq(ekg5, ekg7, i)) {\n                System.out.printf(\"EKG[%d](%d) = EKG[%d](%d) = %d, and are identical from this term on%n\", 5, i+1, 7, i+1, ekg5.get(i));\n                break;\n            }\n        }\n    }\n    \n    \n    private static boolean sameSeq(List<Integer> seq1, List<Integer> seq2, int n) {\n        List<Integer> list1 = new ArrayList<>(seq1.subList(0, n));\n        Collections.sort(list1);\n        List<Integer> list2 = new ArrayList<>(seq2.subList(0, n));\n        Collections.sort(list2);\n        for ( int i = 0 ; i < n ; i++ ) {\n            if ( list1.get(i) != list2.get(i) ) {\n                return false;\n            }\n        }\n        return true;\n    }\n    \n    \n    \n    \n    private static List<Integer> ekg(int two, int maxN) {\n        List<Integer> result = new ArrayList<>();\n        result.add(1);\n        result.add(two);\n        Map<Integer,Integer> seen = new HashMap<>();\n        seen.put(1, 1);\n        seen.put(two, 1);\n        int minUnseen = two == 2 ? 3 : 2;\n        int prev = two;\n        for ( int n = 3 ; n <= maxN ; n++ ) {\n            int test = minUnseen - 1;\n            while ( true ) {\n                test++;\n                if ( ! seen.containsKey(test) && gcd(test, prev) > 1 ) {\n                    \n                    result.add(test);\n                    seen.put(test, n);\n                    prev = test;\n                    if ( minUnseen == test ) {\n                        do {\n                            minUnseen++;\n                        } while ( seen.containsKey(minUnseen) );\n                    }\n                    break;\n                }\n            }\n        }\n        return result;\n    }\n\n    private static final int gcd(int a, int b) {\n        if ( b == 0 ) {\n            return a;\n        }\n        return gcd(b, a%b);\n    }\n        \n}\n"}
{"id": 354332, "name": "Dice game probabilities", "source": "Translate Ruby to Java: def roll_dice(n_dice, n_faces)\n  return [[0,1]] if n_dice.zero?\n  one  = [1] * n_faces\n  zero = [0] * (n_faces-1)\n  (1...n_dice).inject(one){|ary,_|\n    (zero + ary + zero).each_cons(n_faces).map{|a| a.inject(:+)}\n  }.map.with_index(n_dice){|n,sum| [sum,n]}  \nend\n\ndef game(dice1, faces1, dice2, faces2)\n  p1 = roll_dice(dice1, faces1)\n  p2 = roll_dice(dice2, faces2)\n  p1.product(p2).each_with_object([0,0,0]) do |((sum1, n1), (sum2, n2)), win|\n    win[sum1 <=> sum2] += n1 * n2        \n  end\nend\n\n[[9, 4, 6, 6], [5, 10, 6, 7]].each do |d1, f1, d2, f2|\n  puts \"player 1 has \n  puts \"player 2 has \n  win = game(d1, f1, d2, f2)\n  sum = win.inject(:+)\n  puts \"Probability for player 1 to win: \n       \"                              -> \nend\n", "target": "import java.util.Random;\n\npublic class Dice{\n\tprivate static int roll(int nDice, int nSides){\n\t\tint sum = 0;\n\t\tRandom rand = new Random();\n\t\tfor(int i = 0; i < nDice; i++){\n\t\t\tsum += rand.nextInt(nSides) + 1;\n\t\t}\n\t\treturn sum;\n\t}\n\t\n\tprivate static int diceGame(int p1Dice, int p1Sides, int p2Dice, int p2Sides, int rolls){\n\t\tint p1Wins = 0;\n\t\tfor(int i = 0; i < rolls; i++){\n\t\t\tint p1Roll = roll(p1Dice, p1Sides);\n\t\t\tint p2Roll = roll(p2Dice, p2Sides);\n\t\t\tif(p1Roll > p2Roll) p1Wins++;\n\t\t}\n\t\treturn p1Wins;\n\t}\n\t\n\tpublic static void main(String[] args){\n\t\tint p1Dice = 9; int p1Sides = 4;\n\t\tint p2Dice = 6; int p2Sides = 6;\n\t\tint rolls = 10000;\n\t\tint p1Wins = diceGame(p1Dice, p1Sides, p2Dice, p2Sides, rolls);\n\t\tSystem.out.println(rolls + \" rolls, p1 = \" + p1Dice + \"d\" + p1Sides + \", p2 = \" + p2Dice + \"d\" + p2Sides);\n\t\tSystem.out.println(\"p1 wins \" + (100.0 * p1Wins / rolls) + \"% of the time\");\n\t\t\n\t\tSystem.out.println();\n\t\t\n\t\tp1Dice = 5; p1Sides = 10;\n\t\tp2Dice = 6; p2Sides = 7;\n\t\trolls = 10000;\n\t\tp1Wins = diceGame(p1Dice, p1Sides, p2Dice, p2Sides, rolls);\n\t\tSystem.out.println(rolls + \" rolls, p1 = \" + p1Dice + \"d\" + p1Sides + \", p2 = \" + p2Dice + \"d\" + p2Sides);\n\t\tSystem.out.println(\"p1 wins \" + (100.0 * p1Wins / rolls) + \"% of the time\");\n\t\t\n\t\tSystem.out.println();\n\t\t\n\t\tp1Dice = 9; p1Sides = 4;\n\t\tp2Dice = 6; p2Sides = 6;\n\t\trolls = 1000000;\n\t\tp1Wins = diceGame(p1Dice, p1Sides, p2Dice, p2Sides, rolls);\n\t\tSystem.out.println(rolls + \" rolls, p1 = \" + p1Dice + \"d\" + p1Sides + \", p2 = \" + p2Dice + \"d\" + p2Sides);\n\t\tSystem.out.println(\"p1 wins \" + (100.0 * p1Wins / rolls) + \"% of the time\");\n\t\t\n\t\tSystem.out.println();\n\t\t\n\t\tp1Dice = 5; p1Sides = 10;\n\t\tp2Dice = 6; p2Sides = 7;\n\t\trolls = 1000000;\n\t\tp1Wins = diceGame(p1Dice, p1Sides, p2Dice, p2Sides, rolls);\n\t\tSystem.out.println(rolls + \" rolls, p1 = \" + p1Dice + \"d\" + p1Sides + \", p2 = \" + p2Dice + \"d\" + p2Sides);\n\t\tSystem.out.println(\"p1 wins \" + (100.0 * p1Wins / rolls) + \"% of the time\");\n\t}\n}\n"}
{"id": 354333, "name": "Metronome", "source": "Translate Ruby to Java: \n\nbpm = Integer(ARGV[0]) rescue 60 \nmsr = Integer(ARGV[1]) rescue 4 \ni = 0\n\nloop do\n  (msr-1).times do \n    puts \"\\a\"\n    sleep(60.0/bpm)\n  end\n  puts \"\\aAND \n  sleep(60.0/bpm)\nend\n", "target": "class Metronome{\n\tdouble bpm;\n\tint measure, counter;\n\tpublic Metronome(double bpm, int measure){\n\t\tthis.bpm = bpm;\n\t\tthis.measure = measure;\t\n\t}\n\tpublic void start(){\n\t\twhile(true){\n\t\t\ttry {\n\t\t\t\tThread.sleep((long)(1000*(60.0/bpm)));\n\t\t\t}catch(InterruptedException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t\tcounter++;\n\t\t\tif (counter%measure==0){\n\t\t\t\t System.out.println(\"TICK\");\n\t\t\t}else{\n\t\t\t\t System.out.println(\"TOCK\");\n\t\t\t}\n\t\t}\n\t}\n}\npublic class test {\n\tpublic static void main(String[] args) {\n\t\tMetronome metronome1 = new Metronome(120,4);\n\t\tmetronome1.start();\n\t}\n}\n"}
{"id": 354334, "name": "Sum of elements below main diagonal of matrix", "source": "Translate Ruby to Java: arr = [\n   [ 1,  3,  7,  8, 10],\n   [ 2,  4, 16, 14,  4],\n   [ 3,  1,  9, 18, 11],\n   [12, 14, 17, 18, 20],\n   [ 7,  1,  3,  9,  5]\n]\np  arr.each_with_index.sum {|row, x| row[0, x].sum}\n", "target": "public static void main(String[] args) {\n    int[][] matrix = {{1, 3, 7, 8, 10},\n                      {2, 4, 16, 14, 4},\n                      {3, 1, 9, 18, 11},\n                      {12, 14, 17, 18, 20},\n                      {7, 1, 3, 9, 5}};\n    int sum = 0;\n    for (int row = 1; row < matrix.length; row++) {\n        for (int col = 0; col < row; col++) {\n            sum += matrix[row][col];\n        }\n    }\n    System.out.println(sum);\n}\n"}
{"id": 354335, "name": "Pythagoras tree", "source": "Translate Ruby to Java: \n\ndef setup\n  sketch_title 'Pythagoras Tree'\n  background(255)\n  stroke(0, 255, 0)\n  tree(width / 2.3, height, width / 1.8, height, 10)\nend\n\ndef tree(x1, y1, x2, y2, depth)\n  return if depth <= 0\n\n  dx = (x2 - x1)\n  dy = (y1 - y2)\n\n  x3 = (x2 - dy)\n  y3 = (y2 - dx)\n  x4 = (x1 - dy)\n  y4 = (y1 - dx)\n  x5 = (x4 + 0.5 * (dx - dy))\n  y5 = (y4 - 0.5 * (dx + dy))\n  \n  begin_shape\n  fill(0.0, 255.0 / depth, 0.0)\n  vertex(x1, y1)\n  vertex(x2, y2)\n  vertex(x3, y3)\n  vertex(x4, y4)\n  vertex(x1, y1)\n  end_shape\n  \n  begin_shape\n  fill(0.0, 255.0 / depth, 0.0)\n  vertex(x3, y3)\n  vertex(x4, y4)\n  vertex(x5, y5)\n  vertex(x3, y3)\n  end_shape\n  tree(x4, y4, x5, y5, depth - 1)\n  tree(x5, y5, x3, y3, depth - 1)\nend\n\ndef settings\n  size(800, 400)\nend\n", "target": "import java.awt.*;\nimport java.awt.geom.Path2D;\nimport javax.swing.*;\n\npublic class PythagorasTree extends JPanel {\n    final int depthLimit = 7;\n    float hue = 0.15f;\n\n    public PythagorasTree() {\n        setPreferredSize(new Dimension(640, 640));\n        setBackground(Color.white);\n    }\n\n    private void drawTree(Graphics2D g, float x1, float y1, float x2, float y2,\n            int depth) {\n\n        if (depth == depthLimit)\n            return;\n\n        float dx = x2 - x1;\n        float dy = y1 - y2;\n\n        float x3 = x2 - dy;\n        float y3 = y2 - dx;\n        float x4 = x1 - dy;\n        float y4 = y1 - dx;\n        float x5 = x4 + 0.5F * (dx - dy);\n        float y5 = y4 - 0.5F * (dx + dy);\n\n        Path2D square = new Path2D.Float();\n        square.moveTo(x1, y1);\n        square.lineTo(x2, y2);\n        square.lineTo(x3, y3);\n        square.lineTo(x4, y4);\n        square.closePath();\n\n        g.setColor(Color.getHSBColor(hue + depth * 0.02f, 1, 1));\n        g.fill(square);\n        g.setColor(Color.lightGray);\n        g.draw(square);\n\n        Path2D triangle = new Path2D.Float();\n        triangle.moveTo(x3, y3);\n        triangle.lineTo(x4, y4);\n        triangle.lineTo(x5, y5);\n        triangle.closePath();\n\n        g.setColor(Color.getHSBColor(hue + depth * 0.035f, 1, 1));\n        g.fill(triangle);\n        g.setColor(Color.lightGray);\n        g.draw(triangle);\n\n        drawTree(g, x4, y4, x5, y5, depth + 1);\n        drawTree(g, x5, y5, x3, y3, depth + 1);\n    }\n\n    @Override\n    public void paintComponent(Graphics g) {\n        super.paintComponent(g);\n        drawTree((Graphics2D) g, 275, 500, 375, 500, 0);\n    }\n\n    public static void main(String[] args) {\n        SwingUtilities.invokeLater(() -> {\n            JFrame f = new JFrame();\n            f.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n            f.setTitle(\"Pythagoras Tree\");\n            f.setResizable(false);\n            f.add(new PythagorasTree(), BorderLayout.CENTER);\n            f.pack();\n            f.setLocationRelativeTo(null);\n            f.setVisible(true);\n        });\n    }\n}\n"}
{"id": 354336, "name": "Rep-string", "source": "Translate Ruby to Java: def rep(s : String) : Int32\n  x = s.size // 2\n\n  while x > 0\n    return x if s.starts_with? s[x..]\n    x -= 1\n  end\n\n  0\nend\n\ndef main\n  %w(\n    1001110011\n    1110111011\n    0010010010\n    1010101010\n    1111111111\n    0100101101\n    0100100\n    101\n    11\n    00\n    1\n  ).each do |s|\n    n = rep s\n    puts n > 0 ? \"\\\"\n  end\nend\n\nmain\n", "target": "public class RepString {\n\n    static final String[] input = {\"1001110011\", \"1110111011\", \"0010010010\",\n        \"1010101010\", \"1111111111\", \"0100101101\", \"0100100\", \"101\", \"11\",\n        \"00\", \"1\", \"0100101\"};\n\n    public static void main(String[] args) {\n        for (String s : input)\n            System.out.printf(\"%s\u00a0: %s%n\", s, repString(s));\n    }\n\n    static String repString(String s) {\n        int len = s.length();\n        outer:\n        for (int part = len / 2; part > 0; part--) {\n            int tail = len % part;\n            if (tail > 0 && !s.substring(0, tail).equals(s.substring(len - tail)))\n                continue;\n            for (int j = 0; j < len / part - 1; j++) {\n                int a = j * part;\n                int b = (j + 1) * part;\n                int c = (j + 2) * part;\n                if (!s.substring(a, b).equals(s.substring(b, c)))\n                    continue outer;\n            }\n            return s.substring(0, part);\n        }\n        return \"none\";\n    }\n}\n"}
{"id": 354337, "name": "Topswops", "source": "Translate Ruby to Java: def f1(a)\n  i = 0\n  while (a0 = a[0]) > 1\n    a[0...a0] = a[0...a0].reverse\n    i += 1\n  end\n  i\nend\n\ndef fannkuch(n)\n  [*1..n].permutation.map{|a| f1(a)}.max\nend\n\nfor n in 1..10\n  puts \"%2d\u00a0: %d\" % [n, fannkuch(n)]\nend\n", "target": "public class Topswops {\n    static final int maxBest = 32;\n    static int[] best;\n\n    static private void trySwaps(int[] deck, int f, int d, int n) {\n        if (d > best[n])\n            best[n] = d;\n\n        for (int i = n - 1; i >= 0; i--) {\n            if (deck[i] == -1 || deck[i] == i)\n                break;\n            if (d + best[i] <= best[n])\n                return;\n        }\n\n        int[] deck2 = deck.clone();\n        for (int i = 1; i < n; i++) {\n            final int k = 1 << i;\n            if (deck2[i] == -1) {\n                if ((f & k) != 0)\n                    continue;\n            } else if (deck2[i] != i)\n                continue;\n\n            deck2[0] = i;\n            for (int j = i - 1; j >= 0; j--)\n                deck2[i - j] = deck[j]; \n            trySwaps(deck2, f | k, d + 1, n);\n        }\n    }\n\n    static int topswops(int n) {\n        assert(n > 0 && n < maxBest);\n        best[n] = 0;\n        int[] deck0 = new int[n + 1];\n        for (int i = 1; i < n; i++)\n            deck0[i] = -1;\n        trySwaps(deck0, 1, 0, n);\n        return best[n];\n    }\n\n    public static void main(String[] args) {\n        best = new int[maxBest];\n        for (int i = 1; i < 11; i++)\n            System.out.println(i + \": \" + topswops(i));\n    }\n}\n"}
{"id": 354338, "name": "Sequence_ smallest number greater than previous term with exactly n divisors", "source": "Translate Ruby to Java: require 'prime'\n \ndef num_divisors(n)\n  n.prime_division.inject(1){|prod, (_p,n)| prod *= (n + 1) } \nend\n\nseq = Enumerator.new do |y|\n  cur = 0\n  (1..).each do |i|\n    if num_divisors(i) == cur + 1 then\n      y << i\n      cur += 1\n    end\n  end\nend\n\np seq.take(15)\n", "target": "public class AntiPrimesPlus {\n\n    static int count_divisors(int n) {\n        int count = 0;\n        for (int i = 1; i * i <= n; ++i) {\n            if (n % i == 0) {\n                if (i == n / i)\n                    count++;\n                else\n                    count += 2;\n            }\n        }\n        return count;\n    }\n\n    public static void main(String[] args) {\n        final int max = 15;\n        System.out.printf(\"The first %d terms of the sequence are:\\n\", max);\n        for (int i = 1, next = 1; next <= max; ++i) {\n            if (next == count_divisors(i)) {           \n                System.out.printf(\"%d \", i);\n                next++;\n            }\n        }\n        System.out.println();\n    }\n}\n"}
{"id": 354339, "name": "McNuggets problem", "source": "Translate Ruby to Java: def mcnugget(limit)\n  sv = (0..limit).to_a\n\n  (0..limit).step(6) do |s|\n    (0..limit).step(9) do |n|\n      (0..limit).step(20) do |t|\n        sv.delete(s + n + t)\n      end\n    end\n  end\n\n  sv.max\nend\n\nputs(mcnugget 100)\n", "target": "public class McNuggets {\n\n    public static void main(String... args) {\n        int[] SIZES = new int[] { 6, 9, 20 };\n        int MAX_TOTAL = 100;\n        \n        int numSizes = SIZES.length;\n        int[] counts = new int[numSizes];\n        int maxFound = MAX_TOTAL + 1;\n        boolean[] found = new boolean[maxFound];\n        int numFound = 0;\n        int total = 0;\n        boolean advancedState = false;\n        do {\n            if (!found[total]) {\n                found[total] = true;\n                numFound++;\n            }\n            \n            \n            advancedState = false;\n            for (int i = 0; i < numSizes; i++) {\n                int curSize = SIZES[i];\n                if ((total + curSize) > MAX_TOTAL) {\n                    \n                    total -= counts[i] * curSize;\n                    counts[i] = 0;\n                }\n                else {\n                    \n                    counts[i]++;\n                    total += curSize;\n                    advancedState = true;\n                    break;\n                }\n            }\n            \n        } while ((numFound < maxFound) && advancedState);\n        \n        if (numFound < maxFound) {\n            \n            for (int i = MAX_TOTAL; i >= 0; i--) {\n                if (!found[i]) {\n                    System.out.println(\"Largest non-McNugget number in the search space is \" + i);\n                    break;\n                }\n            }\n        }\n        else {\n            System.out.println(\"All numbers in the search space are McNugget numbers\");\n        }\n        \n        return;\n    }\n}\n"}
{"id": 354340, "name": "Idiomatically determine all the lowercase and uppercase letters", "source": "Translate Ruby to Java: puts \"Lowercase:\", [*\"a\"..\"z\"].join, \"Uppercase:\", [*\"A\"..\"Z\"].join\n", "target": "import java.util.stream.IntStream;\n\npublic class Letters {\n    public static void main(String[] args) throws Exception {\n        System.out.print(\"Upper case: \");\n        IntStream.rangeClosed(0, 0x10FFFF)\n                 .filter(Character::isUpperCase)\n                 .limit(72)\n                 .forEach(n -> System.out.printf(\"%c\", n));\n        System.out.println(\"...\");\n\n        System.out.print(\"Lower case: \");\n        IntStream.rangeClosed(0, 0x10FFFF)\n                 .filter(Character::isLowerCase)\n                 .limit(72)\n                 .forEach(n -> System.out.printf(\"%c\", n));\n        System.out.println(\"...\");\n    }\n}\n"}
{"id": 354341, "name": "Superellipse", "source": "Translate Ruby to Java: const (\n    a = 200,\n    b = 200,\n    n = 2.5,\n)\n\n\nfunc y(x) { b * (1 - abs(x/a)**n -> root(n)) -> int }\n\nfunc pline(q) {\n    <<-\"EOT\";\n    <polyline points=\"\n    style=\"fill:none; stroke:black; stroke-width:3\" transform=\"translate(\n    EOT\n}\n\n\nsay <<-\"EOT\"\n    <?xml version=\"1.0\" standalone=\"no\"?>\n    <!DOCTYPE svg PUBLIC \"-//W3C//DTD SVG 1.1//EN\" \"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd\">\n    <svg height=\"\n    EOT\n\n\nvar q = { |x| (x, y(x)) }.map(0..200 `by` 2)\n\n[\n    pline(q),\n    pline(q\u00a0\u00bb*\u00ab\u00a0[ 1,-1]), \n    pline(q\u00a0\u00bb*\u00ab\u00a0[-1,-1]), \n    pline(q\u00a0\u00bb*\u00ab\u00a0[-1, 1]), \n].each { .print }\n\u00a0\nsay '</svg>'\n", "target": "import java.awt.*;\nimport java.awt.geom.Path2D;\nimport static java.lang.Math.pow;\nimport java.util.Hashtable;\nimport javax.swing.*;\nimport javax.swing.event.*;\n\npublic class SuperEllipse extends JPanel implements ChangeListener {\n    private double exp = 2.5;\n\n    public SuperEllipse() {\n        setPreferredSize(new Dimension(650, 650));\n        setBackground(Color.white);\n        setFont(new Font(\"Serif\", Font.PLAIN, 18));\n    }\n\n    void drawGrid(Graphics2D g) {\n        g.setStroke(new BasicStroke(2));\n        g.setColor(new Color(0xEEEEEE));\n\n        int w = getWidth();\n        int h = getHeight();\n        int spacing = 25;\n\n        for (int i = 0; i < w / spacing; i++) {\n            g.drawLine(0, i * spacing, w, i * spacing);\n            g.drawLine(i * spacing, 0, i * spacing, w);\n        }\n        g.drawLine(0, h - 1, w, h - 1);\n\n        g.setColor(new Color(0xAAAAAA));\n        g.drawLine(0, w / 2, w, w / 2);\n        g.drawLine(w / 2, 0, w / 2, w);\n    }\n\n    void drawLegend(Graphics2D g) {\n        g.setColor(Color.black);\n        g.setFont(getFont());\n        g.drawString(\"n = \" + String.valueOf(exp), getWidth() - 150, 45);\n        g.drawString(\"a = b = 200\", getWidth() - 150, 75);\n    }\n\n    void drawEllipse(Graphics2D g) {\n\n        final int a = 200; \n        double[] points = new double[a + 1];\n\n        Path2D p = new Path2D.Double();\n        p.moveTo(a, 0);\n\n        \n        for (int x = a; x >= 0; x--) {\n            points[x] = pow(pow(a, exp) - pow(x, exp), 1 / exp); \n            p.lineTo(x, -points[x]);\n        }\n\n        \n        for (int x = 0; x <= a; x++)\n            p.lineTo(x, points[x]);\n\n        for (int x = a; x >= 0; x--)\n            p.lineTo(-x, points[x]);\n\n        for (int x = 0; x <= a; x++)\n            p.lineTo(-x, -points[x]);\n\n        g.translate(getWidth() / 2, getHeight() / 2);\n        g.setStroke(new BasicStroke(2));\n\n        g.setColor(new Color(0x25B0C4DE, true));\n        g.fill(p);\n\n        g.setColor(new Color(0xB0C4DE)); \n        g.draw(p);\n    }\n\n    @Override\n    public void paintComponent(Graphics gg) {\n        super.paintComponent(gg);\n        Graphics2D g = (Graphics2D) gg;\n        g.setRenderingHint(RenderingHints.KEY_ANTIALIASING,\n                RenderingHints.VALUE_ANTIALIAS_ON);\n        g.setRenderingHint(RenderingHints.KEY_TEXT_ANTIALIASING,\n                RenderingHints.VALUE_TEXT_ANTIALIAS_ON);\n\n        drawGrid(g);\n        drawLegend(g);\n        drawEllipse(g);\n    }\n\n    @Override\n    public void stateChanged(ChangeEvent e) {\n        JSlider source = (JSlider) e.getSource();\n        exp = source.getValue() / 2.0;\n        repaint();\n    }\n\n    public static void main(String[] args) {\n        SwingUtilities.invokeLater(() -> {\n            JFrame f = new JFrame();\n            f.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n            f.setTitle(\"Super Ellipse\");\n            f.setResizable(false);\n            SuperEllipse panel = new SuperEllipse();\n            f.add(panel, BorderLayout.CENTER);\n\n            JSlider exponent = new JSlider(JSlider.HORIZONTAL, 1, 9, 5);\n            exponent.addChangeListener(panel);\n            exponent.setMajorTickSpacing(1);\n            exponent.setPaintLabels(true);\n            exponent.setBackground(Color.white);\n            exponent.setBorder(BorderFactory.createEmptyBorder(20, 20, 20, 20));\n\n            Hashtable<Integer, JLabel> labelTable = new Hashtable<>();\n            for (int i = 1; i < 10; i++)\n                labelTable.put(i, new JLabel(String.valueOf(i * 0.5)));\n            exponent.setLabelTable(labelTable);\n\n            f.add(exponent, BorderLayout.SOUTH);\n\n            f.pack();\n            f.setLocationRelativeTo(null);\n            f.setVisible(true);\n        });\n    }\n}\n"}
{"id": 354342, "name": "Mutex", "source": "Translate Ruby to Java: require 'mutex_m'\n\nclass SomethingWithMutex\n  include Mutex_m\n  ...\nend\n", "target": "import java.util.concurrent.Semaphore;\n\npublic class VolatileClass{\n   public Semaphore mutex = new Semaphore(1); \n                                              \n   public void needsToBeSynched(){\n      \n   }\n   \n}\n"}
{"id": 354343, "name": "Jaro similarity", "source": "Translate Ruby to Java: def jaro(s, t)\n    return 1.0 if s == t\n \n    s_len = s.size\n    t_len = t.size\n    match_distance = ({s_len, t_len}.max // 2) - 1\n\n    s_matches = Array.new(s_len, false)\n    t_matches = Array.new(t_len, false)\n    matches = 0.0\n\n    s_len.times do |i|\n        j_start = {0, i - match_distance}.max\n        j_end = {i + match_distance, t_len - 1}.min\n\n        (j_start..j_end).each do |j|\n            t_matches[j] && next                \n            s[i] == t[j] || next                \n            s_matches[i] = true\n            t_matches[j] = true\n            matches += 1.0\n            break\n        end\n    end\n\n    return 0.0 if matches == 0.0\n \n    k = 0\n    transpositions = 0.0\n    s_len.times do |i|\n        s_matches[i] || next                    \n        while ! t_matches[k]; k += 1 end        \n        s[i] == t[k] || (transpositions += 1.0) \n        k += 1\n    end\n \n    ((matches / s_len) + (matches / t_len) +\n    ((matches - transpositions / 2.0) / matches)) / 3.0\nend\n\n%w( MARTHA    MARHTA\n    DIXON     DICKSONX\n    JELLYFISH SMELLYFISH\n  ).each_slice(2) { |(s ,t)| puts \"jaro(\n", "target": "public class JaroDistance {\n    public static double jaro(String s, String t) {\n        int s_len = s.length();\n        int t_len = t.length();\n\n        if (s_len == 0 && t_len == 0) return 1;\n\n        int match_distance = Integer.max(s_len, t_len) / 2 - 1;\n\n        boolean[] s_matches = new boolean[s_len];\n        boolean[] t_matches = new boolean[t_len];\n\n        int matches = 0;\n        int transpositions = 0;\n\n        for (int i = 0; i < s_len; i++) {\n            int start = Integer.max(0, i-match_distance);\n            int end = Integer.min(i+match_distance+1, t_len);\n\n            for (int j = start; j < end; j++) {\n                if (t_matches[j]) continue;\n                if (s.charAt(i) != t.charAt(j)) continue;\n                s_matches[i] = true;\n                t_matches[j] = true;\n                matches++;\n                break;\n            }\n        }\n\n        if (matches == 0) return 0;\n\n        int k = 0;\n        for (int i = 0; i < s_len; i++) {\n            if (!s_matches[i]) continue;\n            while (!t_matches[k]) k++;\n            if (s.charAt(i) != t.charAt(k)) transpositions++;\n            k++;\n        }\n\n        return (((double)matches / s_len) +\n                ((double)matches / t_len) +\n                (((double)matches - transpositions/2.0) / matches)) / 3.0;\n    }\n\n    public static void main(String[] args) {\n        System.out.println(jaro(   \"MARTHA\",      \"MARHTA\"));\n        System.out.println(jaro(    \"DIXON\",    \"DICKSONX\"));\n        System.out.println(jaro(\"JELLYFISH\",  \"SMELLYFISH\"));\n    }\n}\n"}
{"id": 354344, "name": "Odd word problem", "source": "Translate Ruby to Java: f, r = nil\nfwd = proc {|c|\n  c =~ /[[:alpha:]]/ ? [(print c), fwd[Fiber.yield f]][1] : c }\nrev = proc {|c|\n  c =~ /[[:alpha:]]/ ? [rev[Fiber.yield r], (print c)][0] : c }\n\n(f = Fiber.new { loop { print fwd[Fiber.yield r] }}).resume\n(r = Fiber.new { loop { print rev[Fiber.yield f] }}).resume\n\ncoro = f\nuntil $stdin.eof?\n  coro = coro.resume($stdin.getc)\nend\n", "target": "public class OddWord {\n    interface CharHandler {\n\tCharHandler handle(char c) throws Exception;\n    }\n    final CharHandler fwd = new CharHandler() {\n\tpublic CharHandler handle(char c) {\n\t    System.out.print(c);\n\t    return (Character.isLetter(c) ? fwd : rev);\n\t}\n    };\n    class Reverser extends Thread implements CharHandler {\n\tReverser() {\n\t    setDaemon(true);\n\t    start();\n\t}\n\tprivate Character ch; \n\tprivate char recur() throws Exception {\n\t    notify();\n\t    while (ch == null) wait();\n\t    char c = ch, ret = c;\n\t    ch = null;\n\t    if (Character.isLetter(c)) {\n\t\tret = recur();\n\t\tSystem.out.print(c);\n\t    }\n\t    return ret;\n\t}\n\tpublic synchronized void run() {\n\t    try {\n\t\twhile (true) {\n\t\t    System.out.print(recur());\n\t\t    notify();\n\t\t}\n\t    } catch (Exception e) {}\n\t}\n\tpublic synchronized CharHandler handle(char c) throws Exception {\n\t    while (ch != null) wait();\n\t    ch = c;\n\t    notify();\n\t    while (ch != null) wait();\n\t    return (Character.isLetter(c) ? rev : fwd);\n\t}\n    }\n    final CharHandler rev = new Reverser();\n\n    public void loop() throws Exception {\n\tCharHandler handler = fwd;\n\tint c;\n\twhile ((c = System.in.read()) >= 0) {\n\t    handler = handler.handle((char) c);\n\t}\n    }\n\n    public static void main(String[] args) throws Exception {\n\tnew OddWord().loop();\n    }\n}\n"}
{"id": 354345, "name": "Pseudo-random numbers_PCG32", "source": "Translate Ruby to Java: class PCG32\n  MASK64 = (1 << 64) - 1\n  MASK32 = (1 << 32) - 1\n  CONST  = 6364136223846793005\n\n  def seed(seed_state, seed_sequence)\n    @state = 0\n    @inc = ((seed_sequence << 1) | 1) & MASK64\n    next_int\n    @state = @state + seed_state\n    next_int\n  end\n  \n  def next_int\n    old = @state\n    @state = ((old * CONST) + @inc) & MASK64\n    xorshifted = (((old >> 18) ^ old) >> 27) & MASK32\n    rot = (old >> 59) & MASK32\n    answer = (xorshifted >> rot) | (xorshifted << ((-rot) & 31))\n    answer & MASK32\n  end\n  \n  def next_float\n    next_int.fdiv(1 << 32)\n  end\n  \nend\n\nrandom_gen = PCG32.new\nrandom_gen.seed(42, 54)\n5.times{puts random_gen.next_int}\n\nrandom_gen.seed(987654321, 1)\np 100_000.times.each{(random_gen.next_float * 5).floor}.tally.sort.to_h\n", "target": "public class PCG32 {\n    private static final long N = 6364136223846793005L;\n\n    private long state = 0x853c49e6748fea9bL;\n    private long inc = 0xda3e39cb94b95bdbL;\n\n    public void seed(long seedState, long seedSequence) {\n        state = 0;\n        inc = (seedSequence << 1) | 1;\n        nextInt();\n        state = state + seedState;\n        nextInt();\n    }\n\n    public int nextInt() {\n        long old = state;\n        state = old * N + inc;\n        int shifted = (int) (((old >>> 18) ^ old) >>> 27);\n        int rot = (int) (old >>> 59);\n        return (shifted >>> rot) | (shifted << ((~rot + 1) & 31));\n    }\n\n    public double nextFloat() {\n        var u = Integer.toUnsignedLong(nextInt());\n        return (double) u / (1L << 32);\n    }\n\n    public static void main(String[] args) {\n        var r = new PCG32();\n\n        r.seed(42, 54);\n        System.out.println(Integer.toUnsignedString(r.nextInt()));\n        System.out.println(Integer.toUnsignedString(r.nextInt()));\n        System.out.println(Integer.toUnsignedString(r.nextInt()));\n        System.out.println(Integer.toUnsignedString(r.nextInt()));\n        System.out.println(Integer.toUnsignedString(r.nextInt()));\n        System.out.println();\n\n        int[] counts = {0, 0, 0, 0, 0};\n        r.seed(987654321, 1);\n        for (int i = 0; i < 100_000; i++) {\n            int j = (int) Math.floor(r.nextFloat() * 5.0);\n            counts[j]++;\n        }\n\n        System.out.println(\"The counts for 100,000 repetitions are:\");\n        for (int i = 0; i < counts.length; i++) {\n            System.out.printf(\"  %d\u00a0: %d\\n\", i, counts[i]);\n        }\n    }\n}\n"}
{"id": 354346, "name": "Summarize and say sequence", "source": "Translate Ruby to Java: $cache = {}\ndef selfReferentialSequence_cached(n, seen = [])\n  return $cache[n] if $cache.include? n\n  return [] if seen.include? n\n\n  digit_count = Array.new(10, 0)\n  n.to_s.chars.collect {|char| digit_count[char.to_i] += 1}\n  term = ''\n  9.downto(0).each do |d|\n    if digit_count[d] > 0\n      term += digit_count[d].to_s + d.to_s\n    end\n  end\n  term = term.to_i\n  $cache[n] = [n] + selfReferentialSequence_cached(term, [n] + seen)\nend\n\nlimit = 1_000_000\nmax_len = 0\nmax_vals = []\n\n1.upto(limit - 1) do |n| \n  seq = selfReferentialSequence_cached(n)\n  if seq.length > max_len\n    max_len = seq.length\n    max_vals = [n]\n  elsif seq.length == max_len\n    max_vals << n\n  end\nend\n\nputs \"values: \nputs \"iterations: \nputs \"sequence:\"\nselfReferentialSequence_cached(max_vals[0]).each_with_index do |val, idx| \n  puts \"%2d %d\" % [idx + 1, val]\nend\n", "target": "import java.util.*;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.stream.IntStream;\n\npublic class SelfReferentialSequence {\n\n    static Map<String, Integer> cache = new ConcurrentHashMap<>(10_000);\n\n    public static void main(String[] args) {\n        Seeds res = IntStream.range(0, 1000_000)\n                .parallel()\n                .mapToObj(n -> summarize(n, false))\n                .collect(Seeds::new, Seeds::accept, Seeds::combine);\n\n        System.out.println(\"Seeds:\");\n        res.seeds.forEach(e -> System.out.println(Arrays.toString(e)));\n\n        System.out.println(\"\\nSequence:\");\n        summarize(res.seeds.get(0)[0], true);\n    }\n\n    static int[] summarize(int seed, boolean display) {\n        String n = String.valueOf(seed);\n\n        String k = Arrays.toString(n.chars().sorted().toArray());\n        if (!display && cache.get(k) != null)\n            return new int[]{seed, cache.get(k)};\n\n        Set<String> seen = new HashSet<>();\n        StringBuilder sb = new StringBuilder();\n\n        int[] freq = new int[10];\n\n        while (!seen.contains(n)) {\n            seen.add(n);\n\n            int len = n.length();\n            for (int i = 0; i < len; i++)\n                freq[n.charAt(i) - '0']++;\n\n            sb.setLength(0);\n            for (int i = 9; i >= 0; i--) {\n                if (freq[i] != 0) {\n                    sb.append(freq[i]).append(i);\n                    freq[i] = 0;\n                }\n            }\n            if (display)\n                System.out.println(n);\n            n = sb.toString();\n        }\n\n        cache.put(k, seen.size());\n\n        return new int[]{seed, seen.size()};\n    }\n\n    static class Seeds {\n        int largest = Integer.MIN_VALUE;\n        List<int[]> seeds = new ArrayList<>();\n\n        void accept(int[] s) {\n            int size = s[1];\n            if (size >= largest) {\n                if (size > largest) {\n                    largest = size;\n                    seeds.clear();\n                }\n                seeds.add(s);\n            }\n        }\n\n        void combine(Seeds acc) {\n            acc.seeds.forEach(this::accept);\n        }\n    }\n}\n"}
{"id": 354347, "name": "Koch curve", "source": "Translate Ruby to Java: attr_reader :koch\ndef settings\n  size 600, 600\nend\n\ndef setup\n  sketch_title '2D Koch'\n  @koch = KochSnowflake.new\n  koch.create_grammar 5\n  no_loop\nend\n\ndef draw\n  background 0\n  koch.render\nend\n\n\nclass Grammar\n  attr_reader :axiom, :rules\n  def initialize(axiom, rules)\n    @axiom = axiom\n    @rules = rules\n  end\n\n  def apply_rules(prod)\n    prod.gsub(/./) { |token| rules.fetch(token, token) }\n  end\n\n  def generate(gen)\n    return axiom if gen.zero?\n\n    prod = axiom\n    gen.times do\n      prod = apply_rules(prod)\n    end\n    prod\n  end\nend\n\nTurtle = Struct.new(:x, :y, :theta)\n\n\nclass KochSnowflake\n  include Processing::Proxy\n\n  attr_reader :grammar, :axiom, :draw_length, :production, :turtle\n  DELTA = 60.radians\n\n  def initialize\n    @axiom = 'F--F--F' \n    @grammar = Grammar.new(\n      axiom,\n      'F' => 'F+F--F+F'\n    )\n    @draw_length = 20\n    stroke 0, 255, 0\n    stroke_weight 2\n    @turtle = Turtle.new(width / 5, height * 0.7, 0)\n  end\n\n  def render\n    production.scan(/./) do |element|\n      case element\n      when 'F' \n        draw_line(turtle)\n      when '+'\n        turtle.theta += DELTA\n      when '-'\n        turtle.theta -= DELTA\n      when 'L', 'R'\n      else puts 'Grammar not recognized'\n      end\n    end\n  end\n\n  def draw_line(turtle)\n    x_temp = turtle.x\n    y_temp = turtle.y\n    @turtle.x += draw_length * Math.cos(turtle.theta)\n    @turtle.y += draw_length * Math.sin(turtle.theta)\n    line(x_temp, y_temp, turtle.x, turtle.y)\n  end\n\n  \n  \n  \n  \n\n  def create_grammar(gen)\n    @draw_length *= 0.6**gen\n    @production = @grammar.generate gen\n  end\nend\n", "target": "int l = 300;\n\nvoid setup() {\n  size(400, 400);\n  background(0, 0, 255);\n  stroke(255);\n  \n  translate(width/2.0, height/2.0);\n  \n  translate(-l/2.0, l*sqrt(3)/6.0);\n  for (int i = 1; i <= 3; i++) {\n    kcurve(0, l);\n    rotate(radians(120));\n    translate(-l, 0);\n  }\n}\n\nvoid kcurve(float x1, float x2) {\n  float s = (x2-x1)/3;\n  if (s < 5) {\n    pushMatrix();\n    translate(x1, 0);\n    line(0, 0, s, 0);\n    line(2*s, 0, 3*s, 0);\n    translate(s, 0);\n    rotate(radians(60));\n    line(0, 0, s, 0);\n    translate(s, 0);\n    rotate(radians(-120));\n    line(0, 0, s, 0);\n    popMatrix();\n    return;\n  }\n  pushMatrix();\n  translate(x1, 0);\n  kcurve(0, s);\n  kcurve(2*s, 3*s);\n  translate(s, 0);\n  rotate(radians(60));\n  kcurve(0, s);\n  translate(s, 0);\n  rotate(radians(-120));\n  kcurve(0, s);\n  popMatrix();\n}\n"}
{"id": 354348, "name": "Pseudo-random numbers_Xorshift star", "source": "Translate Ruby to Java: class Xorshift_star\n  MASK64 = (1 << 64) - 1\n  MASK32 = (1 << 32) - 1\n\n  def initialize(seed = 0) = @state = seed & MASK64\n\n  def next_int\n    x = @state\n    x =  x ^ (x >> 12) \n    x = (x ^ (x << 25)) & MASK64\n    x =  x ^ (x >> 27) \n    @state = x\n    (((x * 0x2545F4914F6CDD1D) & MASK64) >> 32) & MASK32\n  end\n  \n  def next_float = next_int.fdiv((1 << 32))\n\nend\n\nrandom_gen =  Xorshift_star.new(1234567)\n5.times{ puts random_gen.next_int}\n\nrandom_gen = Xorshift_star.new(987654321)\ntally      = Hash.new(0)\n100_000.times{ tally[(random_gen.next_float*5).floor] += 1 }\nputs tally.sort.map{|ar| ar.join(\": \") }\n", "target": "public class XorShiftStar {\n    private static final long MAGIC = Long.parseUnsignedLong(\"2545F4914F6CDD1D\", 16);\n    private long state;\n\n    public void seed(long num) {\n        state = num;\n    }\n\n    public int nextInt() {\n        long x;\n        int answer;\n\n        x = state;\n        x = x ^ (x >>> 12);\n        x = x ^ (x << 25);\n        x = x ^ (x >>> 27);\n        state = x;\n        answer = (int) ((x * MAGIC) >> 32);\n\n        return answer;\n    }\n\n    public float nextFloat() {\n        return (float) Integer.toUnsignedLong(nextInt()) / (1L << 32);\n    }\n\n    public static void main(String[] args) {\n        var rng = new XorShiftStar();\n        rng.seed(1234567);\n        System.out.println(Integer.toUnsignedString(rng.nextInt()));\n        System.out.println(Integer.toUnsignedString(rng.nextInt()));\n        System.out.println(Integer.toUnsignedString(rng.nextInt()));\n        System.out.println(Integer.toUnsignedString(rng.nextInt()));\n        System.out.println(Integer.toUnsignedString(rng.nextInt()));\n        System.out.println();\n\n        int[] counts = {0, 0, 0, 0, 0};\n        rng.seed(987654321);\n        for (int i = 0; i < 100_000; i++) {\n            int j = (int) Math.floor(rng.nextFloat() * 5.0);\n            counts[j]++;\n        }\n        for (int i = 0; i < counts.length; i++) {\n            System.out.printf(\"%d: %d\\n\", i, counts[i]);\n        }\n    }\n}\n"}
{"id": 354349, "name": "Numbers with equal rises and falls", "source": "Translate Ruby to Java: class Integer\n  def eq_rise_fall? = digits.each_cons(2).sum{|a,b| a <=> b} == 0\nend\n\nputs (1..).lazy.select(&:eq_rise_fall?).take(200).force.join(\" \")\n\nn = 10_000_000\nres = (1..).lazy.select(&:eq_rise_fall?).take(n).drop(n-1).first\nputs \"The \n", "target": "public class EqualRisesFalls {\n    public static void main(String[] args) {\n        final int limit1 = 200;\n        final int limit2 = 10000000;\n        System.out.printf(\"The first %d numbers in the sequence are:\\n\", limit1);\n        int n = 0;\n        for (int count = 0; count < limit2; ) {\n            if (equalRisesAndFalls(++n)) {\n                ++count;\n                if (count <= limit1)\n                    System.out.printf(\"%3d%c\", n, count % 20 == 0 ? '\\n' : ' ');\n            }\n        }\n        System.out.printf(\"\\nThe %dth number in the sequence is %d.\\n\", limit2, n);\n    }\n\n    private static boolean equalRisesAndFalls(int n) {\n        int total = 0;\n        for (int previousDigit = -1; n > 0; n /= 10) {\n            int digit = n % 10;\n            if (previousDigit > digit)\n                ++total;\n            else if (previousDigit >= 0 && previousDigit < digit)\n                --total;\n            previousDigit = digit;\n        }\n        return total == 0;\n    }\n}\n"}
{"id": 354350, "name": "Pseudo-random numbers_Combined recursive generator MRG32k3a", "source": "Translate Ruby to Java: def mod(x, y)\n    m = x % y\n    if m < 0 then\n        if y < 0 then\n            return m - y\n        else\n            return m + y\n        end\n    end\n    return m\nend\n\n\n\nA1 = [0, 1403580, -810728]\nA1.freeze\nM1 = (1 << 32) - 209\n\nA2 = [527612, 0, -1370589]\nA2.freeze\nM2 = (1 << 32) - 22853\n\nD = M1 + 1\n\n\n$x1 = [0, 0, 0]\n\n$x2 = [0, 0, 0]\n\ndef seed(seed_state)\n    $x1 = [seed_state, 0, 0]\n    $x2 = [seed_state, 0, 0]\nend\n\ndef next_int()\n    x1i = mod((A1[0] * $x1[0] + A1[1] * $x1[1] + A1[2] * $x1[2]), M1)\n    x2i = mod((A2[0] * $x2[0] + A2[1] * $x2[1] + A2[2] * $x2[2]), M2)\n    z = mod(x1i - x2i, M1)\n\n    $x1 = [x1i, $x1[0], $x1[1]]\n    $x2 = [x2i, $x2[0], $x2[1]]\n\n    return z + 1\nend\n\ndef next_float()\n    return 1.0 * next_int() / D\nend\n\n\n\nseed(1234567)\nprint next_int(), \"\\n\"\nprint next_int(), \"\\n\"\nprint next_int(), \"\\n\"\nprint next_int(), \"\\n\"\nprint next_int(), \"\\n\"\nprint \"\\n\"\n\ncounts = [0, 0, 0, 0, 0]\nseed(987654321)\nfor i in 1 .. 100000\n    value = (next_float() * 5.0).floor\n    counts[value] = counts[value] + 1\nend\ncounts.each_with_index { |v,i|\n    print i, \": \", v, \"\\n\"\n}\n", "target": "public class App {\n    private static long mod(long x, long y) {\n        long m = x % y;\n        if (m < 0) {\n            if (y < 0) {\n                return m - y;\n            } else {\n                return m + y;\n            }\n        }\n        return m;\n    }\n\n    public static class RNG {\n        \n        private final long[] a1 = {0, 1403580, -810728};\n        private static final long m1 = (1L << 32) - 209;\n        private long[] x1;\n        \n        private final long[] a2 = {527612, 0, -1370589};\n        private static final long m2 = (1L << 32) - 22853;\n        private long[] x2;\n        \n        private static final long d = m1 + 1;\n\n        public void seed(long state) {\n            x1 = new long[]{state, 0, 0};\n            x2 = new long[]{state, 0, 0};\n        }\n\n        public long nextInt() {\n            long x1i = mod(a1[0] * x1[0] + a1[1] * x1[1] + a1[2] * x1[2], m1);\n            long x2i = mod(a2[0] * x2[0] + a2[1] * x2[1] + a2[2] * x2[2], m2);\n            long z = mod(x1i - x2i, m1);\n\n            \n            x1 = new long[]{x1i, x1[0], x1[1]};\n            \n            x2 = new long[]{x2i, x2[0], x2[1]};\n\n            return z + 1;\n        }\n\n        public double nextFloat() {\n            return 1.0 * nextInt() / d;\n        }\n    }\n\n    public static void main(String[] args) {\n        RNG rng = new RNG();\n\n        rng.seed(1234567);\n        System.out.println(rng.nextInt());\n        System.out.println(rng.nextInt());\n        System.out.println(rng.nextInt());\n        System.out.println(rng.nextInt());\n        System.out.println(rng.nextInt());\n        System.out.println();\n\n        int[] counts = {0, 0, 0, 0, 0};\n        rng.seed(987654321);\n        for (int i = 0; i < 100_000; i++) {\n            int value = (int) Math.floor(rng.nextFloat() * 5.0);\n            counts[value]++;\n        }\n        for (int i = 0; i < counts.length; i++) {\n            System.out.printf(\"%d: %d%n\", i, counts[i]);\n        }\n    }\n}\n"}
{"id": 354351, "name": "Self-describing numbers", "source": "Translate Ruby to Java: def self_describing?(n)\n  digits = n.to_s.chars.map(&.to_i)         \n  digits.each_with_index.all? { |digit, idx| digits.count(idx) == digit }\nend\n\nt = Time.monotonic\n600_000_000.times { |n| (puts \"\n                        t = Time.monotonic) if self_describing?(n) }\n", "target": "public class SelfDescribingNumbers{\n    public static boolean isSelfDescribing(int a){\n        String s = Integer.toString(a);\n        for(int i = 0; i < s.length(); i++){\n            String s0 = s.charAt(i) + \"\";\n            int b = Integer.parseInt(s0); \n            int count = 0;\n            for(int j = 0; j < s.length(); j++){\n                int temp = Integer.parseInt(s.charAt(j) + \"\");\n                if(temp == i){\n                    count++;\n                }\n                if (count > b) return false;\n            }\n            if(count != b) return false;\n        }\n        return true;\n    }\n\n    public static void main(String[] args){\n        for(int i = 0; i < 100000000; i++){\n            if(isSelfDescribing(i)){\n                System.out.println(i);\n             }\n        }\n    }\n}\n"}
{"id": 354352, "name": "Changeable words", "source": "Translate Ruby to Java: words = File.open(\"unixdict.txt\").readlines.map(&:chomp).select{|w| w.size > 11 }\n\nsize_groups = words.group_by(&:size).sort.map(&:last)\nres =  size_groups.flat_map do |group|\n  group.combination(2).select{|word1, word2| word1.chars.zip(word2.chars).one?{|c1, c2| c1 != c2} }\nend\n\nputs \"Found \nres.each{|w1, w2|puts \"\n", "target": "import java.io.*;\nimport java.util.*;\n\npublic class ChangeableWords {\n    public static void main(String[] args) {\n        try {\n            final String fileName = \"unixdict.txt\";\n            List<String> dictionary = new ArrayList<>();\n            try (BufferedReader reader = new BufferedReader(new FileReader(fileName))) {\n                String line;\n                while ((line = reader.readLine()) != null) {\n                    if (line.length() > 11)\n                        dictionary.add(line);\n                }\n            }\n            System.out.printf(\"Changeable words in %s:\\n\", fileName);\n            int n = 1;\n            for (String word1 : dictionary) {\n                for (String word2 : dictionary) {\n                    if (word1 != word2 && hammingDistance(word1, word2) == 1)\n                        System.out.printf(\"%2d:\u00a0%-14s -> %s\\n\", n++, word1, word2);\n                }\n            }\n        } catch (Exception e)  {\n            e.printStackTtexture();\n        }\n    }\n\n    private static int hammingDistance(String str1, String str2) {\n        int len1 = str1.length();\n        int len2 = str2.length();\n        if (len1 != len2)\n            return 0;\n        int count = 0;\n        for (int i = 0; i < len1; ++i) {\n            if (str1.charAt(i) != str2.charAt(i))\n                ++count;\n            \n            if (count == 2)\n                break;\n        }\n        return count;\n    }\n}\n"}
{"id": 354353, "name": "Decision tables", "source": "Translate Ruby to Java: class DecisionTable\n  def initialize(conditions, actions)\n    @conditions = conditions\n    @actions = []\n    @rules = []\n    actions.each {|action, ruleset| @actions << action; @rules << ruleset} \n  end\n\n  def run\n    puts \"Conditions:\"\n    index = ask_conditions\n    puts \"Actions:\"\n    results = @rules.each_with_index.inject([]) do |sum, (ruleset, idx)| \n      sum << @actions[idx] if ruleset[index] == 1\n      sum\n    end\n    results << \"PC LOAD LETTER\" if results.empty?\n    results.each {|res| puts \"  \n    puts \"\"\n  end\n  \n  private\n  def ask_conditions\n    answers = @conditions.inject(\"\") {|sum, c| sum + get_response(c)}\n    answers.to_i(2)\n  end\n\n  def get_response(prompt)\n    loop do\n      print \"  \n      case STDIN.gets.strip.downcase\n      when /^y/ then return \"0\"\n      when /^n/ then return \"1\"\n      end\n    end\n  end\nend\n\ndt = DecisionTable.new(\n      [\n        \"Printer does not print\",              \n        \"A red light is flashing\",             \n        \"Printer is unrecognised\",             \n      ], \n      [\n        [\"Check the power cable\",                [0,0,1,0,0,0,0,0]],\n        [\"Check the printer-computer cable\",     [1,0,1,0,0,0,0,0]],\n        [\"Ensure printer software is installed\", [1,0,1,0,1,0,1,0]],\n        [\"Check/replace ink\",                    [1,1,0,0,1,1,0,0]],\n        [\"Check for paper jam\",                  [0,1,0,1,0,0,0,0]],\n      ]\n     )\nloop {dt.run}\n", "target": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.List;\nimport java.util.Objects;\n\npublic class DecisionTables {\n    private static class Pair<T, U> {\n        private final T t;\n        private final U u;\n\n        public static <T, U> Pair<T, U> of(T t, U u) {\n            return new Pair<>(t, u);\n        }\n\n        public Pair(T t, U u) {\n            this.t = t;\n            this.u = u;\n        }\n\n        public T getFirst() {\n            return t;\n        }\n\n        public U getSecond() {\n            return u;\n        }\n    }\n\n    private static final List<Pair<String, String>> conditions = List.of(\n        Pair.of(\"Printer prints\", \"NNNNYYYY\"),\n        Pair.of(\"A red light is flashing\", \"YYNNYYNN\"),\n        Pair.of(\"Printer is recognized by computer\", \"NYNYNYNY\")\n    );\n\n    private static final List<Pair<String, String>> actions = List.of(\n        Pair.of(\"Check the power cable\", \"NNYNNNNN\"),\n        Pair.of(\"Check the printer-computer cable\", \"YNYNNNNN\"),\n        Pair.of(\"Ensure printer software is installed\", \"YNYNYNYN\"),\n        Pair.of(\"Check/replace ink\", \"YYNNNYNN\"),\n        Pair.of(\"Check for paper jam\", \"NYNYNNNN\")\n    );\n\n    public static void main(String[] args) throws IOException {\n        final int nc = conditions.size();\n        final int na = actions.size();\n        final int nr = conditions.get(0).getSecond().length();\n        final int np = 7;\n\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\n        System.out.println(\"Please answer the following questions with a y or n:\");\n        final boolean[] answers = new boolean[nc];\n        for (int c = 0; c < nc; ++c) {\n            String input;\n            do {\n                System.out.printf(\"  %s\u00a0? \", conditions.get(c).getFirst());\n                input = br.readLine().toUpperCase();\n            } while (!Objects.equals(input, \"Y\") && !Objects.equals(input, \"N\"));\n            answers[c] = Objects.equals(input, \"Y\");\n        }\n        System.out.println(\"\\nRecommended action(s)\");\n\n        outer:\n        for (int r = 0; r < nr; ++r) {\n            for (int c = 0; c < nc; ++c) {\n                char yn = answers[c] ? 'Y' : 'N';\n                if (conditions.get(c).getSecond().charAt(r) != yn) {\n                    continue outer;\n                }\n            }\n            if (r == np) {\n                System.out.println(\"  None (no problem detected)\");\n            } else {\n                for (Pair<String, String> action : actions) {\n                    if (action.getSecond().charAt(r) == 'Y') {\n                        System.out.printf(\"  %s\\n\", action.getFirst());\n                    }\n                }\n            }\n            break;\n        }\n    }\n}\n"}
{"id": 354354, "name": "Mosaic matrix", "source": "Translate Ruby to Java: func mosaic_matrix(n) {\n    n.of {|k|\n        var(a,b) = (k.is_even ? (1,0) : (0,1))\n        n.of {|j| j.is_even ? a : b }\n    }\n}\n\nmosaic_matrix(5).each { .join(' ').say }; say ''\nmosaic_matrix(6).each { .join(' ').say }\n", "target": "\n\nsize(1000,1000);\n\ntextSize(50);\n\nfor(int i=0;i<10;i++){\n  for(int j=0;j<10;j++){\n    noFill();\n    square(i*100,j*100,100);\n    fill(#000000);\n    if((i+j)%2==0){\n      text(\"1\",i*100+50,j*100+50);\n    }\n    else{\n      text(\"0\",i*100+50,j*100+50);\n    } \n  }\n}\n"}
{"id": 354355, "name": "Input_Output for lines of text", "source": "Translate Ruby to Java: def do_stuff(line)\n  puts line\nend\n\nn = gets.to_i\nn.times do\n  line = gets\n  do_stuff(line)\nend\n", "target": "import java.util.Scanner;\n\npublic class Main {\n\tpublic static void doStuff(String word){\n\t   System.out.println(word);\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tScanner in = new Scanner(System.in);\n\t\tint n = Integer.parseInt(in.nextLine());  \n\t\tfor(int i=0; i<n; i++){\t\t\n\t\t\tString word = in.nextLine();\n\t\t\tdoStuff(word);\n\t\t}\n\t}\n}\n"}
{"id": 354356, "name": "Length of an arc between two angles", "source": "Translate Ruby to Java: def arc_length(radius, angle1, angle2)\n    return (360.0 - (angle2 - angle1).abs) * Math::PI / 180.0 * radius\nend\n\nprint \"%.7f\\n\" % [arc_length(10, 10, 120)]\n", "target": "public static double arcLength(double r, double a1, double a2){\n    return (360.0 - Math.abs(a2-a1))*Math.PI/180.0 * r;\n}\n"}
{"id": 354357, "name": "Shift list elements to left by 3", "source": "Translate Ruby to Java: list = [1,2,3,4,5,6,7,8,9]\np list.rotate(3)\n", "target": "import java.util.List;\nimport java.util.Arrays;\nimport java.util.Collections;\n\npublic class RotateLeft {\n    public static void main(String[] args) {\n        List<Integer> list = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9);\n        System.out.println(\"original: \" + list);\n        Collections.rotate(list, -3);\n        System.out.println(\"rotated: \" + list);\n    }\n}\n"}
{"id": 354358, "name": "Matrix with two diagonals", "source": "Translate Ruby to Java: require 'matrix'\n\nclass Matrix\n  def self.two_diagonals(n)\n    Matrix.build(n, n) do |row, col|\n      row == col || row == n-col-1 ? 1 : 0\n    end\n  end\nend\n\nMatrix.two_diagonals(5).row_vectors.each{|row| puts row.to_a.join(\" \") }\n", "target": "package example.diagdiag;\n\npublic class Program {\n\n    public static void main(String[] args) {\n        DiagonalDiagonalMatrix A = new DiagonalDiagonalMatrix(7);\n        System.out.println(A);\n    }\n\n}\n\nclass DiagonalDiagonalMatrix {\n\n    final int n;\n    private double[][] a = null;\n\n    public Matrix(int n) {\n        this.n = n;\n    }\n\n    public double get(int i, int j) {\n        if (a == null) {\n            return (i == j || i == n - j + 1) ? 1.0 : 0.0;\n        } else {\n            return a[i - 1][j - 1];\n        }\n    }\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    @Override\n    public String toString() {\n        StringBuilder sb = new StringBuilder();\n        for (int i = 1; i <= n; i++) {\n            for (int j = 1; j <= n; j++) {\n                sb.append('\\t');\n                sb.append(get(i, j));\n            }\n            sb.append('\\n');\n        }\n        return sb.toString();\n    }\n\n}\n"}
{"id": 354359, "name": "Four sides of square", "source": "Translate Ruby to Java: def square_sides(size = 9)\n  Array.new(size){|n| n==0 || n==size-1 ? [1]*size : [1]+[0]*(size-2)+[1]}\nend\n\nputs square_sides.map{|line| line.join (\" \") }\n", "target": "\n\nsize(1000,1000);\n\ntextSize(50);\n\nfor(int i=0;i<10;i++){\n  for(int j=0;j<10;j++){\n    noFill();\n    square(i*100,j*100,100);\n    fill(#000000);\n    if(i==0||i==9||j==0||j==9){\n      text(\"1\",i*100+50,j*100+50);\n    }\n    else{\n      text(\"0\",i*100+50,j*100+50);\n    } \n  }\n}\n"}
{"id": 354360, "name": "Longest common suffix", "source": "Translate Ruby to Java: tests = [[\"baabababc\", \"baabc\", \"bbbabc\"],\n [\"baabababc\", \"baabc\", \"bbbazc\"],\n [\"Sunday\", \"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\"],\n [\"longest\", \"common\", \"suffix\"],\n [\"suffix\"],\n [\"\"], \n]\ndef lcs(ar)\n  i = (0..ar.first.size).detect{|s| ar.all?{|word| word.end_with? ar.first[s..-1]} }\n  ar.first[i..-1]\nend\n\ntests.each{|test| p lcs(test) }\n", "target": "import java.util.List;\n\npublic class App {\n    private static String lcs(List<String> a) {\n        var le = a.size();\n        if (le == 0) {\n            return \"\";\n        }\n        if (le == 1) {\n            return a.get(0);\n        }\n        var le0 = a.get(0).length();\n        var minLen = le0;\n        for (int i = 1; i < le; i++) {\n            if (a.get(i).length() < minLen) {\n                minLen = a.get(i).length();\n            }\n        }\n        if (minLen == 0) {\n            return \"\";\n        }\n        var res = \"\";\n        var a1 = a.subList(1, a.size());\n        for (int i = 1; i < minLen; i++) {\n            var suffix = a.get(0).substring(le0 - i);\n            for (String e : a1) {\n                if (!e.endsWith(suffix)) {\n                    return res;\n                }\n            }\n            res = suffix;\n        }\n        return \"\";\n    }\n\n    public static void main(String[] args) {\n        var tests = List.of(\n            List.of(\"baabababc\", \"baabc\", \"bbbabc\"),\n            List.of(\"baabababc\", \"baabc\", \"bbbazc\"),\n            List.of(\"Sunday\", \"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\"),\n            List.of(\"longest\", \"common\", \"suffix\"),\n            List.of(\"suffix\"),\n            List.of(\"\")\n        );\n        for (List<String> test : tests) {\n            System.out.printf(\"%s -> `%s`\\n\", test, lcs(test));\n        }\n    }\n}\n"}
{"id": 354361, "name": "Hello world_Newbie", "source": "Translate Ruby to Java:   puts \"Hello World!!\"\n", "target": "public class HelloWorld {\n    public static void main(String[] args) {\n        \n        System.out.println(\"Hello world!\");\n    }\n}\n"}
{"id": 354362, "name": "AVL tree", "source": "Translate Ruby to Java: class AVLtree {\n\n    has root = nil\n\n    struct Node {\n        Number key,\n        Number balance = 0,\n        Node left = nil,\n        Node right = nil,\n        Node parent = nil,\n    }\n\n    method insert(key) {\n        if (root == nil) {\n            root = Node(key)\n            return true\n        }\n\n        var n = root\n        var parent = nil\n\n        loop {\n            if (n.key == key) {\n                return false\n            }\n            parent = n\n            var goLeft = (n.key > key)\n            n = (goLeft ? n.left : n.right)\n\n            if (n == nil) {\n                var tn = Node(key, parent: parent)\n                if (goLeft) {\n                    parent.left = tn\n                }\n                else {\n                    parent.right = tn\n                }\n                self.rebalance(parent)\n                break\n            }\n        }\n\n        return true\n    }\n\n    method delete_key(delKey) {\n        if (root == nil) { return nil }\n\n        var n = root\n        var parent = root\n        var delNode = nil\n        var child = root\n\n        while (child != nil) {\n            parent = n\n            n = child\n            child = (delKey >= n.key ? n.right : n.left)\n            if (delKey == n.key) {\n                delNode = n\n            }\n        }\n\n        if (delNode != nil) {\n            delNode.key = n.key\n            child = (n.left != nil ? n.left : n.right)\n\n            if (root.key == delKey) {\n                root = child\n            }\n            else {\n                if (parent.left == n) {\n                    parent.left = child\n                }\n                else {\n                    parent.right = child\n                }\n                self.rebalance(parent)\n            }\n        }\n    }\n\n    method rebalance(n) {\n        if (n == nil) { return nil }\n        self.setBalance(n)\n\n        given (n.balance) {\n            when (-2) {\n                if (self.height(n.left.left) >= self.height(n.left.right)) {\n                    n = self.rotate(n, :right)\n                }\n                else {\n                    n = self.rotate_twice(n, :left, :right)\n                }\n            }\n            when (2) {\n                if (self.height(n.right.right) >= self.height(n.right.left)) {\n                    n = self.rotate(n, :left)\n                }\n                else {\n                    n = self.rotate_twice(n, :right, :left)\n                }\n            }\n        }\n\n        if (n.parent != nil) {\n            self.rebalance(n.parent)\n        }\n        else {\n            root = n\n        }\n    }\n\n    method rotate(a, dir) {\n        var b = (dir == :left ? a.right : a.left)\n        b.parent = a.parent\n\n        (dir == :left) ? (a.right = b.left)\n                       : (a.left  = b.right)\n\n        if (a.right != nil) {\n            a.right.parent = a\n        }\n\n        b.$dir = a\n        a.parent = b\n\n        if (b.parent != nil) {\n            if (b.parent.right == a) {\n                b.parent.right = b\n            }\n            else {\n                b.parent.left = b\n            }\n        }\n\n        self.setBalance(a, b)\n        return b\n    }\n\n    method rotate_twice(n, dir1, dir2) {\n        n.left = self.rotate(n.left, dir1)\n        self.rotate(n, dir2)\n    }\n\n    method height(n) {\n        if (n == nil) { return -1 }\n        1 + Math.max(self.height(n.left), self.height(n.right))\n    }\n\n    method setBalance(*nodes) {\n        nodes.each { |n|\n            n.balance = (self.height(n.right) - self.height(n.left))\n        }\n    }\n\n    method printBalance {\n        self.printBalance(root)\n    }\n\n    method printBalance(n) {\n        if (n != nil) {\n            self.printBalance(n.left)\n            print(n.balance, ' ')\n            self.printBalance(n.right)\n        }\n    }\n}\n\nvar tree = AVLtree()\n\nsay \"Inserting values 1 to 10\"\n{|i| tree.insert(i) } << 1..10\nprint \"Printing balance: \"\ntree.printBalance\n", "target": "public class AVLtree {\n\n    private Node root;\n\n    private static class Node {\n        private int key;\n        private int balance;\n        private int height;\n        private Node left;\n        private Node right;\n        private Node parent;\n\n        Node(int key, Node parent) {\n            this.key = key;\n            this.parent = parent;\n        }\n    }\n\n    public boolean insert(int key) {\n        if (root == null) {\n            root = new Node(key, null);\n            return true;\n        }\n\n        Node n = root;\n        while (true) {\n            if (n.key == key)\n                return false;\n\n            Node parent = n;\n\n            boolean goLeft = n.key > key;\n            n = goLeft ? n.left : n.right;\n\n            if (n == null) {\n                if (goLeft) {\n                    parent.left = new Node(key, parent);\n                } else {\n                    parent.right = new Node(key, parent);\n                }\n                rebalance(parent);\n                break;\n            }\n        }\n        return true;\n    }\n\n    private void delete(Node node) {\n        if (node.left == null && node.right == null) {\n            if (node.parent == null) {\n                root = null;\n            } else {\n                Node parent = node.parent;\n                if (parent.left == node) {\n                    parent.left = null;\n                } else {\n                    parent.right = null;\n                }\n                rebalance(parent);\n            }\n            return;\n        }\n\n        if (node.left != null) {\n            Node child = node.left;\n            while (child.right != null) child = child.right;\n            node.key = child.key;\n            delete(child);\n        } else {\n            Node child = node.right;\n            while (child.left != null) child = child.left;\n            node.key = child.key;\n            delete(child);\n        }\n    }\n\n    public void delete(int delKey) {\n        if (root == null)\n            return;\n\n        Node child = root;\n        while (child != null) {\n            Node node = child;\n            child = delKey >= node.key ? node.right : node.left;\n            if (delKey == node.key) {\n                delete(node);\n                return;\n            }\n        }\n    }\n\n    private void rebalance(Node n) {\n        setBalance(n);\n\n        if (n.balance == -2) {\n            if (height(n.left.left) >= height(n.left.right))\n                n = rotateRight(n);\n            else\n                n = rotateLeftThenRight(n);\n\n        } else if (n.balance == 2) {\n            if (height(n.right.right) >= height(n.right.left))\n                n = rotateLeft(n);\n            else\n                n = rotateRightThenLeft(n);\n        }\n\n        if (n.parent != null) {\n            rebalance(n.parent);\n        } else {\n            root = n;\n        }\n    }\n\n    private Node rotateLeft(Node a) {\n\n        Node b = a.right;\n        b.parent = a.parent;\n\n        a.right = b.left;\n\n        if (a.right != null)\n            a.right.parent = a;\n\n        b.left = a;\n        a.parent = b;\n\n        if (b.parent != null) {\n            if (b.parent.right == a) {\n                b.parent.right = b;\n            } else {\n                b.parent.left = b;\n            }\n        }\n\n        setBalance(a, b);\n\n        return b;\n    }\n\n    private Node rotateRight(Node a) {\n\n        Node b = a.left;\n        b.parent = a.parent;\n\n        a.left = b.right;\n\n        if (a.left != null)\n            a.left.parent = a;\n\n        b.right = a;\n        a.parent = b;\n\n        if (b.parent != null) {\n            if (b.parent.right == a) {\n                b.parent.right = b;\n            } else {\n                b.parent.left = b;\n            }\n        }\n\n        setBalance(a, b);\n\n        return b;\n    }\n\n    private Node rotateLeftThenRight(Node n) {\n        n.left = rotateLeft(n.left);\n        return rotateRight(n);\n    }\n\n    private Node rotateRightThenLeft(Node n) {\n        n.right = rotateRight(n.right);\n        return rotateLeft(n);\n    }\n\n    private int height(Node n) {\n        if (n == null)\n            return -1;\n        return n.height;\n    }\n\n    private void setBalance(Node... nodes) {\n        for (Node n : nodes) {\n            reheight(n);\n            n.balance = height(n.right) - height(n.left);\n        }\n    }\n\n    public void printBalance() {\n        printBalance(root);\n    }\n\n    private void printBalance(Node n) {\n        if (n != null) {\n            printBalance(n.left);\n            System.out.printf(\"%s \", n.balance);\n            printBalance(n.right);\n        }\n    }\n\n    private void reheight(Node node) {\n        if (node != null) {\n            node.height = 1 + Math.max(height(node.left), height(node.right));\n        }\n    }\n\n    public static void main(String[] args) {\n        AVLtree tree = new AVLtree();\n\n        System.out.println(\"Inserting values 1 to 10\");\n        for (int i = 1; i < 10; i++)\n            tree.insert(i);\n\n        System.out.print(\"Printing balance: \");\n        tree.printBalance();\n    }\n}\n"}
{"id": 354363, "name": "AVL tree", "source": "Translate Ruby to Java: class AVLtree {\n\n    has root = nil\n\n    struct Node {\n        Number key,\n        Number balance = 0,\n        Node left = nil,\n        Node right = nil,\n        Node parent = nil,\n    }\n\n    method insert(key) {\n        if (root == nil) {\n            root = Node(key)\n            return true\n        }\n\n        var n = root\n        var parent = nil\n\n        loop {\n            if (n.key == key) {\n                return false\n            }\n            parent = n\n            var goLeft = (n.key > key)\n            n = (goLeft ? n.left : n.right)\n\n            if (n == nil) {\n                var tn = Node(key, parent: parent)\n                if (goLeft) {\n                    parent.left = tn\n                }\n                else {\n                    parent.right = tn\n                }\n                self.rebalance(parent)\n                break\n            }\n        }\n\n        return true\n    }\n\n    method delete_key(delKey) {\n        if (root == nil) { return nil }\n\n        var n = root\n        var parent = root\n        var delNode = nil\n        var child = root\n\n        while (child != nil) {\n            parent = n\n            n = child\n            child = (delKey >= n.key ? n.right : n.left)\n            if (delKey == n.key) {\n                delNode = n\n            }\n        }\n\n        if (delNode != nil) {\n            delNode.key = n.key\n            child = (n.left != nil ? n.left : n.right)\n\n            if (root.key == delKey) {\n                root = child\n            }\n            else {\n                if (parent.left == n) {\n                    parent.left = child\n                }\n                else {\n                    parent.right = child\n                }\n                self.rebalance(parent)\n            }\n        }\n    }\n\n    method rebalance(n) {\n        if (n == nil) { return nil }\n        self.setBalance(n)\n\n        given (n.balance) {\n            when (-2) {\n                if (self.height(n.left.left) >= self.height(n.left.right)) {\n                    n = self.rotate(n, :right)\n                }\n                else {\n                    n = self.rotate_twice(n, :left, :right)\n                }\n            }\n            when (2) {\n                if (self.height(n.right.right) >= self.height(n.right.left)) {\n                    n = self.rotate(n, :left)\n                }\n                else {\n                    n = self.rotate_twice(n, :right, :left)\n                }\n            }\n        }\n\n        if (n.parent != nil) {\n            self.rebalance(n.parent)\n        }\n        else {\n            root = n\n        }\n    }\n\n    method rotate(a, dir) {\n        var b = (dir == :left ? a.right : a.left)\n        b.parent = a.parent\n\n        (dir == :left) ? (a.right = b.left)\n                       : (a.left  = b.right)\n\n        if (a.right != nil) {\n            a.right.parent = a\n        }\n\n        b.$dir = a\n        a.parent = b\n\n        if (b.parent != nil) {\n            if (b.parent.right == a) {\n                b.parent.right = b\n            }\n            else {\n                b.parent.left = b\n            }\n        }\n\n        self.setBalance(a, b)\n        return b\n    }\n\n    method rotate_twice(n, dir1, dir2) {\n        n.left = self.rotate(n.left, dir1)\n        self.rotate(n, dir2)\n    }\n\n    method height(n) {\n        if (n == nil) { return -1 }\n        1 + Math.max(self.height(n.left), self.height(n.right))\n    }\n\n    method setBalance(*nodes) {\n        nodes.each { |n|\n            n.balance = (self.height(n.right) - self.height(n.left))\n        }\n    }\n\n    method printBalance {\n        self.printBalance(root)\n    }\n\n    method printBalance(n) {\n        if (n != nil) {\n            self.printBalance(n.left)\n            print(n.balance, ' ')\n            self.printBalance(n.right)\n        }\n    }\n}\n\nvar tree = AVLtree()\n\nsay \"Inserting values 1 to 10\"\n{|i| tree.insert(i) } << 1..10\nprint \"Printing balance: \"\ntree.printBalance\n", "target": "public class AVLtree {\n\n    private Node root;\n\n    private static class Node {\n        private int key;\n        private int balance;\n        private int height;\n        private Node left;\n        private Node right;\n        private Node parent;\n\n        Node(int key, Node parent) {\n            this.key = key;\n            this.parent = parent;\n        }\n    }\n\n    public boolean insert(int key) {\n        if (root == null) {\n            root = new Node(key, null);\n            return true;\n        }\n\n        Node n = root;\n        while (true) {\n            if (n.key == key)\n                return false;\n\n            Node parent = n;\n\n            boolean goLeft = n.key > key;\n            n = goLeft ? n.left : n.right;\n\n            if (n == null) {\n                if (goLeft) {\n                    parent.left = new Node(key, parent);\n                } else {\n                    parent.right = new Node(key, parent);\n                }\n                rebalance(parent);\n                break;\n            }\n        }\n        return true;\n    }\n\n    private void delete(Node node) {\n        if (node.left == null && node.right == null) {\n            if (node.parent == null) {\n                root = null;\n            } else {\n                Node parent = node.parent;\n                if (parent.left == node) {\n                    parent.left = null;\n                } else {\n                    parent.right = null;\n                }\n                rebalance(parent);\n            }\n            return;\n        }\n\n        if (node.left != null) {\n            Node child = node.left;\n            while (child.right != null) child = child.right;\n            node.key = child.key;\n            delete(child);\n        } else {\n            Node child = node.right;\n            while (child.left != null) child = child.left;\n            node.key = child.key;\n            delete(child);\n        }\n    }\n\n    public void delete(int delKey) {\n        if (root == null)\n            return;\n\n        Node child = root;\n        while (child != null) {\n            Node node = child;\n            child = delKey >= node.key ? node.right : node.left;\n            if (delKey == node.key) {\n                delete(node);\n                return;\n            }\n        }\n    }\n\n    private void rebalance(Node n) {\n        setBalance(n);\n\n        if (n.balance == -2) {\n            if (height(n.left.left) >= height(n.left.right))\n                n = rotateRight(n);\n            else\n                n = rotateLeftThenRight(n);\n\n        } else if (n.balance == 2) {\n            if (height(n.right.right) >= height(n.right.left))\n                n = rotateLeft(n);\n            else\n                n = rotateRightThenLeft(n);\n        }\n\n        if (n.parent != null) {\n            rebalance(n.parent);\n        } else {\n            root = n;\n        }\n    }\n\n    private Node rotateLeft(Node a) {\n\n        Node b = a.right;\n        b.parent = a.parent;\n\n        a.right = b.left;\n\n        if (a.right != null)\n            a.right.parent = a;\n\n        b.left = a;\n        a.parent = b;\n\n        if (b.parent != null) {\n            if (b.parent.right == a) {\n                b.parent.right = b;\n            } else {\n                b.parent.left = b;\n            }\n        }\n\n        setBalance(a, b);\n\n        return b;\n    }\n\n    private Node rotateRight(Node a) {\n\n        Node b = a.left;\n        b.parent = a.parent;\n\n        a.left = b.right;\n\n        if (a.left != null)\n            a.left.parent = a;\n\n        b.right = a;\n        a.parent = b;\n\n        if (b.parent != null) {\n            if (b.parent.right == a) {\n                b.parent.right = b;\n            } else {\n                b.parent.left = b;\n            }\n        }\n\n        setBalance(a, b);\n\n        return b;\n    }\n\n    private Node rotateLeftThenRight(Node n) {\n        n.left = rotateLeft(n.left);\n        return rotateRight(n);\n    }\n\n    private Node rotateRightThenLeft(Node n) {\n        n.right = rotateRight(n.right);\n        return rotateLeft(n);\n    }\n\n    private int height(Node n) {\n        if (n == null)\n            return -1;\n        return n.height;\n    }\n\n    private void setBalance(Node... nodes) {\n        for (Node n : nodes) {\n            reheight(n);\n            n.balance = height(n.right) - height(n.left);\n        }\n    }\n\n    public void printBalance() {\n        printBalance(root);\n    }\n\n    private void printBalance(Node n) {\n        if (n != null) {\n            printBalance(n.left);\n            System.out.printf(\"%s \", n.balance);\n            printBalance(n.right);\n        }\n    }\n\n    private void reheight(Node node) {\n        if (node != null) {\n            node.height = 1 + Math.max(height(node.left), height(node.right));\n        }\n    }\n\n    public static void main(String[] args) {\n        AVLtree tree = new AVLtree();\n\n        System.out.println(\"Inserting values 1 to 10\");\n        for (int i = 1; i < 10; i++)\n            tree.insert(i);\n\n        System.out.print(\"Printing balance: \");\n        tree.printBalance();\n    }\n}\n"}
{"id": 354364, "name": "Here document", "source": "Translate Ruby to Java: puts <<-DOC\nthis is a heredoc\n  it preserves indents and newlines\n  the DOC identifier is completely arbitrary\n  it can be lowercase, a keyword, or even a number (but not a float)\nDOC\n", "target": "package rosettacode.heredoc;\npublic class MainApp {\n\tpublic static void main(String[] args) {\n\t\tString hereDoc = \"\"\"\n\t\t\t\tThis is a multiline string.\n\t\t\t\tIt includes all of this text,\n\t\t\t\tbut on separate lines in the code.\n\t\t\t\t \"\"\";\n\t\tSystem.out.println(hereDoc);\n\t}\n}\n"}
{"id": 354365, "name": "Here document", "source": "Translate Ruby to Java: puts <<-DOC\nthis is a heredoc\n  it preserves indents and newlines\n  the DOC identifier is completely arbitrary\n  it can be lowercase, a keyword, or even a number (but not a float)\nDOC\n", "target": "package rosettacode.heredoc;\npublic class MainApp {\n\tpublic static void main(String[] args) {\n\t\tString hereDoc = \"\"\"\n\t\t\t\tThis is a multiline string.\n\t\t\t\tIt includes all of this text,\n\t\t\t\tbut on separate lines in the code.\n\t\t\t\t \"\"\";\n\t\tSystem.out.println(hereDoc);\n\t}\n}\n"}
{"id": 354366, "name": "Pig the dice game_Player", "source": "Translate Ruby to Java: def player1(sum,sm)\nfor i in 1..100\nputs \"player1 rolled\"\na=gets.chomp().to_i\nif (a>1 && a<7)\n\tsum+=a\n\tif sum>=100\n\tputs \"player1 wins\"\n\tbreak\n\tend\nelse\n\ngoto player2(sum,sm)\nend\ni+=1\nend\nend\n\ndef player2(sum,sm)\nfor j in 1..100\nputs \"player2 rolled\"\nb=gets.chomp().to_i\nif(b>1 && b<7)\n sm+=b\n\tif sm>=100\n\t puts \"player2 wins\"\n\tbreak\n\tend\nelse\n\nplayer1(sum,sm)\nend\nj+=1\nend\nend\ni=0\nj=0\nsum=0\nsm=0\nplayer1(sum,sm)\nreturn\n", "target": "import java.util.Scanner;\n\npublic class Pigdice {\n\n\tpublic static void main(String[] args) {\n\t\tScanner scan = new Scanner(System.in);\n\t\tint players = 0;\n\t\t\n\t\t\n\t\twhile(true) {\n\t\t\t\n\t\t\tSystem.out.println(\"Hello, welcome to Pig Dice the game! How many players? \");\n\t\t\tif(scan.hasNextInt()) {\n\t\t\t\t\n\t\t\t\t\n\t\t\t\tint nextInt = scan.nextInt();\n\t\t\t\tif(nextInt > 0) {\n\t\t\t\t\tplayers = nextInt;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tSystem.out.println(\"That wasn't an integer. Try again. \\n\");\n\t\t\t\tscan.next();\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(\"Alright, starting with \" + players + \" players. \\n\");\n\t\t\n\t\t\n\t\tplay(players, scan);\n\t\t\n\t\tscan.close();\n\t}\n\t\n\tpublic static void play(int group, Scanner scan) {\n\t\t\n\t\tfinal int STRATEGIES = 5;\n\t\t\n\t\t\n\t\tDice dice = new Dice();\n\t\t\n\t\t\n\t\tPlayer[] players = new Player[group];\n\t\tfor(int count = 0; count < group; count++) {\n\t\t\tplayers[count] = new Player(count);\n\t\t\tSystem.out.println(\"Player \" + players[count].getNumber() + \"  is alive! \");\n\t\t}\n\t\t\n\t\t\n\t\tSystem.out.println(\"Each strategy is numbered 0 - \" + (STRATEGIES - 1) + \". They are as follows: \");\n\t\tSystem.out.println(\">> Enter '0' for a human player. \");\n\t\tSystem.out.println(\">> Strategy 1 is a basic strategy where the AI rolls until 20+ points and holds unless the current max is 75+.\");\n\t\tSystem.out.println(\">> Strategy 2 is a basic strategy where the AI, after 3 successful rolls, will randomly decide to roll or hold. \");\n\t\tSystem.out.println(\">> Strategy 3 is similar to strategy 2, except it's a little gutsier and will attempt 5 successful rolls. \");\n\t\tSystem.out.println(\">> Strategy 4 is like a mix between strategies 1 and 3. After turn points are >= 20 and while max points are still less than 75, it will randomly hold or roll. \");\n\t\t\n\t\t\n\t\tfor(Player player : players) {\n\t\t\tSystem.out.println(\"\\nWhat strategy would you like player \" + player.getNumber() + \" to use? \");\n\n\t\t\t\n\t\t\twhile(true) {\n\t\t\t\tif(scan.hasNextInt()) {\n\t\t\t\t\tint nextInt = scan.nextInt();\n\t\t\t\t\tif (nextInt < Strategy.STRATEGIES.length) {\n\t\t\t\t\t\tplayer.setStrategy(Strategy.STRATEGIES[nextInt]);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tSystem.out.println(\"That wasn't an option. Try again. \");\n\t\t\t\t\tscan.next();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\t\n\t\tint max = 0;\n\t\twhile(max < 100) {\n\t\t\t\n\t\t\t\n\t\t\tfor(Player player : players) {\n\t\t\t\tSystem.out.println(\">> Beginning Player \" + player.getNumber() + \"'s turn. \");\n\t\t\t\t\n\t\t\t\t\n\t\t\t\tplayer.setTurnPoints(0);\n\t\t\t\t\n\t\t\t\t\n\t\t\t\tplayer.setMax(max);\n\t\t\t\twhile(true) {\n\t\t\t\t\tMove choice = player.choose();\n\t\t\t\t\tif(choice == Move.ROLL) {\n\t\t\t\t\t\tint roll = dice.roll();\n\t\t\t\t\t\tSystem.out.println(\"   A \" + roll + \" was rolled. \");\n\t\t\t\t\t\tplayer.setTurnPoints(player.getTurnPoints() + roll);\n\t\t\t\t\t\t\n\t\t\t\t\t\t\n\t\t\t\t\t\tplayer.incIter();\n\t\t\t\t\t\t\n\t\t\t\t\t\t\n\t\t\t\t\t\tif(roll == 1) {\n\t\t\t\t\t\t\tplayer.setTurnPoints(0);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\telse {\n\t\t\t\t\t\tSystem.out.println(\"   The player has held. \");\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t\n\t\t\t\tplayer.addPoints(player.getTurnPoints());\n\t\t\t\tSystem.out.println(\"   Player \" + player.getNumber() + \"'s turn is now over. Their total is \" + player.getPoints() + \". \\n\");\n\t\t\t\t\n\t\t\t\t\n\t\t\t\tplayer.resetIter();\n\t\t\t\t\n\t\t\t\t\n\t\t\t\tif(max < player.getPoints()) {\n\t\t\t\t\tmax = player.getPoints();\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t\n\t\t\t\tif(max >= 100) {\n\t\t\t\t\tSystem.out.println(\"Player \" + player.getNumber() + \" wins with \" + max + \" points! End scores: \");\n\t\t\t\t\t\n\t\t\t\t\t\n\t\t\t\t\tfor(Player p : players) {\n\t\t\t\t\t\tSystem.out.println(\"Player \" + p.getNumber() + \" had \" + p.getPoints() + \" points. \");\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t}\n\t\n}\n"}
{"id": 354367, "name": "Pig the dice game_Player", "source": "Translate Ruby to Java: def player1(sum,sm)\nfor i in 1..100\nputs \"player1 rolled\"\na=gets.chomp().to_i\nif (a>1 && a<7)\n\tsum+=a\n\tif sum>=100\n\tputs \"player1 wins\"\n\tbreak\n\tend\nelse\n\ngoto player2(sum,sm)\nend\ni+=1\nend\nend\n\ndef player2(sum,sm)\nfor j in 1..100\nputs \"player2 rolled\"\nb=gets.chomp().to_i\nif(b>1 && b<7)\n sm+=b\n\tif sm>=100\n\t puts \"player2 wins\"\n\tbreak\n\tend\nelse\n\nplayer1(sum,sm)\nend\nj+=1\nend\nend\ni=0\nj=0\nsum=0\nsm=0\nplayer1(sum,sm)\nreturn\n", "target": "import java.util.Scanner;\n\npublic class Pigdice {\n\n\tpublic static void main(String[] args) {\n\t\tScanner scan = new Scanner(System.in);\n\t\tint players = 0;\n\t\t\n\t\t\n\t\twhile(true) {\n\t\t\t\n\t\t\tSystem.out.println(\"Hello, welcome to Pig Dice the game! How many players? \");\n\t\t\tif(scan.hasNextInt()) {\n\t\t\t\t\n\t\t\t\t\n\t\t\t\tint nextInt = scan.nextInt();\n\t\t\t\tif(nextInt > 0) {\n\t\t\t\t\tplayers = nextInt;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tSystem.out.println(\"That wasn't an integer. Try again. \\n\");\n\t\t\t\tscan.next();\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(\"Alright, starting with \" + players + \" players. \\n\");\n\t\t\n\t\t\n\t\tplay(players, scan);\n\t\t\n\t\tscan.close();\n\t}\n\t\n\tpublic static void play(int group, Scanner scan) {\n\t\t\n\t\tfinal int STRATEGIES = 5;\n\t\t\n\t\t\n\t\tDice dice = new Dice();\n\t\t\n\t\t\n\t\tPlayer[] players = new Player[group];\n\t\tfor(int count = 0; count < group; count++) {\n\t\t\tplayers[count] = new Player(count);\n\t\t\tSystem.out.println(\"Player \" + players[count].getNumber() + \"  is alive! \");\n\t\t}\n\t\t\n\t\t\n\t\tSystem.out.println(\"Each strategy is numbered 0 - \" + (STRATEGIES - 1) + \". They are as follows: \");\n\t\tSystem.out.println(\">> Enter '0' for a human player. \");\n\t\tSystem.out.println(\">> Strategy 1 is a basic strategy where the AI rolls until 20+ points and holds unless the current max is 75+.\");\n\t\tSystem.out.println(\">> Strategy 2 is a basic strategy where the AI, after 3 successful rolls, will randomly decide to roll or hold. \");\n\t\tSystem.out.println(\">> Strategy 3 is similar to strategy 2, except it's a little gutsier and will attempt 5 successful rolls. \");\n\t\tSystem.out.println(\">> Strategy 4 is like a mix between strategies 1 and 3. After turn points are >= 20 and while max points are still less than 75, it will randomly hold or roll. \");\n\t\t\n\t\t\n\t\tfor(Player player : players) {\n\t\t\tSystem.out.println(\"\\nWhat strategy would you like player \" + player.getNumber() + \" to use? \");\n\n\t\t\t\n\t\t\twhile(true) {\n\t\t\t\tif(scan.hasNextInt()) {\n\t\t\t\t\tint nextInt = scan.nextInt();\n\t\t\t\t\tif (nextInt < Strategy.STRATEGIES.length) {\n\t\t\t\t\t\tplayer.setStrategy(Strategy.STRATEGIES[nextInt]);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tSystem.out.println(\"That wasn't an option. Try again. \");\n\t\t\t\t\tscan.next();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\t\n\t\tint max = 0;\n\t\twhile(max < 100) {\n\t\t\t\n\t\t\t\n\t\t\tfor(Player player : players) {\n\t\t\t\tSystem.out.println(\">> Beginning Player \" + player.getNumber() + \"'s turn. \");\n\t\t\t\t\n\t\t\t\t\n\t\t\t\tplayer.setTurnPoints(0);\n\t\t\t\t\n\t\t\t\t\n\t\t\t\tplayer.setMax(max);\n\t\t\t\twhile(true) {\n\t\t\t\t\tMove choice = player.choose();\n\t\t\t\t\tif(choice == Move.ROLL) {\n\t\t\t\t\t\tint roll = dice.roll();\n\t\t\t\t\t\tSystem.out.println(\"   A \" + roll + \" was rolled. \");\n\t\t\t\t\t\tplayer.setTurnPoints(player.getTurnPoints() + roll);\n\t\t\t\t\t\t\n\t\t\t\t\t\t\n\t\t\t\t\t\tplayer.incIter();\n\t\t\t\t\t\t\n\t\t\t\t\t\t\n\t\t\t\t\t\tif(roll == 1) {\n\t\t\t\t\t\t\tplayer.setTurnPoints(0);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\telse {\n\t\t\t\t\t\tSystem.out.println(\"   The player has held. \");\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t\n\t\t\t\tplayer.addPoints(player.getTurnPoints());\n\t\t\t\tSystem.out.println(\"   Player \" + player.getNumber() + \"'s turn is now over. Their total is \" + player.getPoints() + \". \\n\");\n\t\t\t\t\n\t\t\t\t\n\t\t\t\tplayer.resetIter();\n\t\t\t\t\n\t\t\t\t\n\t\t\t\tif(max < player.getPoints()) {\n\t\t\t\t\tmax = player.getPoints();\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t\n\t\t\t\tif(max >= 100) {\n\t\t\t\t\tSystem.out.println(\"Player \" + player.getNumber() + \" wins with \" + max + \" points! End scores: \");\n\t\t\t\t\t\n\t\t\t\t\t\n\t\t\t\t\tfor(Player p : players) {\n\t\t\t\t\t\tSystem.out.println(\"Player \" + p.getNumber() + \" had \" + p.getPoints() + \" points. \");\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t}\n\t\n}\n"}
{"id": 354368, "name": "Maze solving", "source": "Translate Ruby to Java: class Maze\n  \n  \n  \n  def solve\n    \n    \n    reset_visiting_state\n    \n    \n    @queue = []\n    enqueue_cell([], @start_x, @start_y)\n    \n    \n    \n    path = nil\n    until path || @queue.empty?\n      path = solve_visit_cell\n    end\n    \n    if path\n      \n      for x, y in path\n        @path[x][y] = true\n      end\n    else\n      puts \"No solution found?!\"\n    end\n  end\n  \n  private\n  \n  \n  def solve_visit_cell\n    \n    path = @queue.shift\n    \n    x, y = path.last\n    \n    \n    return path  if x == @end_x && y == @end_y\n    \n    \n    @visited[x][y] = true\n    \n    for dx, dy in DIRECTIONS\n      if dx.nonzero?\n        \n        new_x = x + dx\n        if move_valid?(new_x, y) && !@vertical_walls[ [x, new_x].min ][y]\n          enqueue_cell(path, new_x, y)\n        end\n      else\n        \n        new_y = y + dy\n        if move_valid?(x, new_y) && !@horizontal_walls[x][ [y, new_y].min ]\n          enqueue_cell(path, x, new_y)\n        end\n      end\n    end\n    \n    nil         \n  end\n  \n  \n  def enqueue_cell(path, x, y)\n    \n    @queue << path + [[x, y]]\n  end\nend\n\n\nmaze = Maze.new 20, 10\nmaze.solve\nmaze.print\n", "target": "import java.io.*;\nimport java.util.*;\n\npublic class MazeSolver\n{\n    \n    private static String[] readLines (InputStream f) throws IOException\n    {\n        BufferedReader r =\n            new BufferedReader (new InputStreamReader (f, \"US-ASCII\"));\n        ArrayList<String> lines = new ArrayList<String>();\n        String line;\n        while ((line = r.readLine()) != null)\n            lines.add (line);\n        return lines.toArray(new String[0]);\n    }\n\n    \n    private static char[][] decimateHorizontally (String[] lines)\n    {\n        final int width = (lines[0].length() + 1) / 2;\n        char[][] c = new char[lines.length][width];\n        for (int i = 0  ;  i < lines.length  ;  i++)\n            for (int j = 0  ;  j < width  ;  j++)\n                c[i][j] = lines[i].charAt (j * 2);\n        return c;\n    }\n\n    \n    private static boolean solveMazeRecursively (char[][] maze,\n                                                 int x, int y, int d)\n    {\n        boolean ok = false;\n        for (int i = 0  ;  i < 4  &&  !ok  ;  i++)\n            if (i != d)\n                switch (i)\n                    {\n                        \n                    case 0:\n                        if (maze[y-1][x] == ' ')\n                            ok = solveMazeRecursively (maze, x, y - 2, 2);\n                        break;\n                    case 1:\n                        if (maze[y][x+1] == ' ')\n                            ok = solveMazeRecursively (maze, x + 2, y, 3);\n                        break;\n                    case 2:\n                        if (maze[y+1][x] == ' ')\n                            ok = solveMazeRecursively (maze, x, y + 2, 0);\n                        break;\n                    case 3:\n                        if (maze[y][x-1] == ' ')\n                            ok = solveMazeRecursively (maze, x - 2, y, 1);\n                        break;\n                    }\n        \n        if (x == 1  &&  y == 1)\n            ok = true;\n        \n        if (ok)\n            {\n                maze[y][x] = '*';\n                switch (d)\n                    {\n                    case 0:\n                        maze[y-1][x] = '*';\n                        break;\n                    case 1:\n                        maze[y][x+1] = '*';\n                        break;\n                    case 2:\n                        maze[y+1][x] = '*';\n                        break;\n                    case 3:\n                        maze[y][x-1] = '*';\n                        break;\n                    }\n            }\n        return ok;\n    }\n\n    \n    private static void solveMaze (char[][] maze)\n    {\n        solveMazeRecursively (maze, maze[0].length - 2, maze.length - 2, -1);\n    }\n\n    \n    private static String[] expandHorizontally (char[][] maze)\n    {\n        char[] tmp = new char[3];\n        String[] lines = new String[maze.length];\n        for (int i = 0  ;  i < maze.length  ;  i++)\n            {\n                StringBuilder sb = new StringBuilder(maze[i].length * 2);\n                for (int j = 0  ;  j < maze[i].length  ;  j++)\n                    if (j % 2 == 0)\n                        sb.append (maze[i][j]);\n                    else\n                        {\n                            tmp[0] = tmp[1] = tmp[2] = maze[i][j];\n                            if (tmp[1] == '*')\n                                tmp[0] = tmp[2] = ' ';\n                            sb.append (tmp);\n                        }\n                lines[i] = sb.toString();\n            }\n        return lines;\n    }\n\n    \n    public static void main (String[] args) throws IOException\n    {\n        InputStream f = (args.length > 0\n                         ?  new FileInputStream (args[0])\n                         :  System.in);\n        String[] lines = readLines (f);\n        char[][] maze = decimateHorizontally (lines);\n        solveMaze (maze);\n        String[] solvedLines = expandHorizontally (maze);\n        for (int i = 0  ;  i < solvedLines.length  ;  i++)\n            System.out.println (solvedLines[i]);\n    }\n}\n"}
{"id": 354369, "name": "Deming's funnel", "source": "Translate Ruby to Java: def funnel(dxs, &rule)\n  x, rxs = 0, []\n  for dx in dxs\n    rxs << (x + dx)\n    x = rule[x, dx]\n  end\n  rxs\nend\n\ndef mean(xs) xs.inject(:+) / xs.size end\n\ndef stddev(xs)\n  m = mean(xs)\n  Math.sqrt(xs.inject(0.0){|sum,x| sum + (x-m)**2} / xs.size)\nend\n\ndef experiment(label, dxs, dys, &rule)\n  rxs, rys = funnel(dxs, &rule), funnel(dys, &rule)\n  puts label\n  puts 'Mean x, y   \u00a0: %7.4f, %7.4f' % [mean(rxs), mean(rys)]\n  puts 'Std dev x, y\u00a0: %7.4f, %7.4f' % [stddev(rxs), stddev(rys)]\n  puts\nend\n\ndxs = [ -0.533,  0.270,  0.859, -0.043, -0.205, -0.127, -0.071,  0.275,\n         1.251, -0.231, -0.401,  0.269,  0.491,  0.951,  1.150,  0.001,\n        -0.382,  0.161,  0.915,  2.080, -2.337,  0.034, -0.126,  0.014,\n         0.709,  0.129, -1.093, -0.483, -1.193,  0.020, -0.051,  0.047,\n        -0.095,  0.695,  0.340, -0.182,  0.287,  0.213, -0.423, -0.021,\n        -0.134,  1.798,  0.021, -1.099, -0.361,  1.636, -1.134,  1.315,\n         0.201,  0.034,  0.097, -0.170,  0.054, -0.553, -0.024, -0.181,\n        -0.700, -0.361, -0.789,  0.279, -0.174, -0.009, -0.323, -0.658,\n         0.348, -0.528,  0.881,  0.021, -0.853,  0.157,  0.648,  1.774,\n        -1.043,  0.051,  0.021,  0.247, -0.310,  0.171,  0.000,  0.106,\n         0.024, -0.386,  0.962,  0.765, -0.125, -0.289,  0.521,  0.017,\n         0.281, -0.749, -0.149, -2.436, -0.909,  0.394, -0.113, -0.598,\n         0.443, -0.521, -0.799,  0.087]\n\ndys = [  0.136,  0.717,  0.459, -0.225,  1.392,  0.385,  0.121, -0.395,\n         0.490, -0.682, -0.065,  0.242, -0.288,  0.658,  0.459,  0.000,\n         0.426,  0.205, -0.765, -2.188, -0.742, -0.010,  0.089,  0.208,\n         0.585,  0.633, -0.444, -0.351, -1.087,  0.199,  0.701,  0.096,\n        -0.025, -0.868,  1.051,  0.157,  0.216,  0.162,  0.249, -0.007,\n         0.009,  0.508, -0.790,  0.723,  0.881, -0.508,  0.393, -0.226,\n         0.710,  0.038, -0.217,  0.831,  0.480,  0.407,  0.447, -0.295,\n         1.126,  0.380,  0.549, -0.445, -0.046,  0.428, -0.074,  0.217,\n        -0.822,  0.491,  1.347, -0.141,  1.230, -0.044,  0.079,  0.219,\n         0.698,  0.275,  0.056,  0.031,  0.421,  0.064,  0.721,  0.104,\n        -0.729,  0.650, -1.103,  0.154, -1.720,  0.051, -0.385,  0.477,\n         1.537, -0.901,  0.939, -0.411,  0.341, -0.411,  0.106,  0.224,\n        -0.947, -1.424, -0.542, -1.032]\n\nexperiment('Rule 1:', dxs, dys) {|z, dz| 0}\nexperiment('Rule 2:', dxs, dys) {|z, dz| -dz}\nexperiment('Rule 3:', dxs, dys) {|z, dz| -(z+dz)}\nexperiment('Rule 4:', dxs, dys) {|z, dz| z+dz}\n", "target": "import static java.lang.Math.*;\nimport java.util.Arrays;\nimport java.util.function.BiFunction;\n\npublic class DemingsFunnel {\n\n    public static void main(String[] args) {\n        double[] dxs = {\n            -0.533, 0.270, 0.859, -0.043, -0.205, -0.127, -0.071, 0.275,\n            1.251, -0.231, -0.401, 0.269, 0.491, 0.951, 1.150, 0.001,\n            -0.382, 0.161, 0.915, 2.080, -2.337, 0.034, -0.126, 0.014,\n            0.709, 0.129, -1.093, -0.483, -1.193, 0.020, -0.051, 0.047,\n            -0.095, 0.695, 0.340, -0.182, 0.287, 0.213, -0.423, -0.021,\n            -0.134, 1.798, 0.021, -1.099, -0.361, 1.636, -1.134, 1.315,\n            0.201, 0.034, 0.097, -0.170, 0.054, -0.553, -0.024, -0.181,\n            -0.700, -0.361, -0.789, 0.279, -0.174, -0.009, -0.323, -0.658,\n            0.348, -0.528, 0.881, 0.021, -0.853, 0.157, 0.648, 1.774,\n            -1.043, 0.051, 0.021, 0.247, -0.310, 0.171, 0.000, 0.106,\n            0.024, -0.386, 0.962, 0.765, -0.125, -0.289, 0.521, 0.017,\n            0.281, -0.749, -0.149, -2.436, -0.909, 0.394, -0.113, -0.598,\n            0.443, -0.521, -0.799, 0.087};\n\n        double[] dys = {\n            0.136, 0.717, 0.459, -0.225, 1.392, 0.385, 0.121, -0.395,\n            0.490, -0.682, -0.065, 0.242, -0.288, 0.658, 0.459, 0.000,\n            0.426, 0.205, -0.765, -2.188, -0.742, -0.010, 0.089, 0.208,\n            0.585, 0.633, -0.444, -0.351, -1.087, 0.199, 0.701, 0.096,\n            -0.025, -0.868, 1.051, 0.157, 0.216, 0.162, 0.249, -0.007,\n            0.009, 0.508, -0.790, 0.723, 0.881, -0.508, 0.393, -0.226,\n            0.710, 0.038, -0.217, 0.831, 0.480, 0.407, 0.447, -0.295,\n            1.126, 0.380, 0.549, -0.445, -0.046, 0.428, -0.074, 0.217,\n            -0.822, 0.491, 1.347, -0.141, 1.230, -0.044, 0.079, 0.219,\n            0.698, 0.275, 0.056, 0.031, 0.421, 0.064, 0.721, 0.104,\n            -0.729, 0.650, -1.103, 0.154, -1.720, 0.051, -0.385, 0.477,\n            1.537, -0.901, 0.939, -0.411, 0.341, -0.411, 0.106, 0.224,\n            -0.947, -1.424, -0.542, -1.032};\n\n        experiment(\"Rule 1:\", dxs, dys, (z, dz) -> 0.0);\n        experiment(\"Rule 2:\", dxs, dys, (z, dz) -> -dz);\n        experiment(\"Rule 3:\", dxs, dys, (z, dz) -> -(z + dz));\n        experiment(\"Rule 4:\", dxs, dys, (z, dz) -> z + dz);\n    }\n\n    static void experiment(String label, double[] dxs, double[] dys,\n            BiFunction<Double, Double, Double> rule) {\n\n        double[] resx = funnel(dxs, rule);\n        double[] resy = funnel(dys, rule);\n        System.out.println(label);\n        System.out.printf(\"Mean x, y:   \u00a0%.4f,\u00a0%.4f%n\", mean(resx), mean(resy));\n        System.out.printf(\"Std dev x, y:\u00a0%.4f,\u00a0%.4f%n\", stdDev(resx), stdDev(resy));\n        System.out.println();\n    }\n\n    static double[] funnel(double[] input, BiFunction<Double, Double, Double> rule) {\n        double x = 0;\n        double[] result = new double[input.length];\n\n        for (int i = 0; i < input.length; i++) {\n            double rx = x + input[i];\n            x = rule.apply(x, input[i]);\n            result[i] = rx;\n        }\n        return result;\n    }\n\n    static double mean(double[] xs) {\n        return Arrays.stream(xs).sum() / xs.length;\n    }\n\n    static double stdDev(double[] xs) {\n        double m = mean(xs);\n        return sqrt(Arrays.stream(xs).map(x -> pow((x - m), 2)).sum() / xs.length);\n    }\n}\n"}
{"id": 354370, "name": "Deming's funnel", "source": "Translate Ruby to Java: def funnel(dxs, &rule)\n  x, rxs = 0, []\n  for dx in dxs\n    rxs << (x + dx)\n    x = rule[x, dx]\n  end\n  rxs\nend\n\ndef mean(xs) xs.inject(:+) / xs.size end\n\ndef stddev(xs)\n  m = mean(xs)\n  Math.sqrt(xs.inject(0.0){|sum,x| sum + (x-m)**2} / xs.size)\nend\n\ndef experiment(label, dxs, dys, &rule)\n  rxs, rys = funnel(dxs, &rule), funnel(dys, &rule)\n  puts label\n  puts 'Mean x, y   \u00a0: %7.4f, %7.4f' % [mean(rxs), mean(rys)]\n  puts 'Std dev x, y\u00a0: %7.4f, %7.4f' % [stddev(rxs), stddev(rys)]\n  puts\nend\n\ndxs = [ -0.533,  0.270,  0.859, -0.043, -0.205, -0.127, -0.071,  0.275,\n         1.251, -0.231, -0.401,  0.269,  0.491,  0.951,  1.150,  0.001,\n        -0.382,  0.161,  0.915,  2.080, -2.337,  0.034, -0.126,  0.014,\n         0.709,  0.129, -1.093, -0.483, -1.193,  0.020, -0.051,  0.047,\n        -0.095,  0.695,  0.340, -0.182,  0.287,  0.213, -0.423, -0.021,\n        -0.134,  1.798,  0.021, -1.099, -0.361,  1.636, -1.134,  1.315,\n         0.201,  0.034,  0.097, -0.170,  0.054, -0.553, -0.024, -0.181,\n        -0.700, -0.361, -0.789,  0.279, -0.174, -0.009, -0.323, -0.658,\n         0.348, -0.528,  0.881,  0.021, -0.853,  0.157,  0.648,  1.774,\n        -1.043,  0.051,  0.021,  0.247, -0.310,  0.171,  0.000,  0.106,\n         0.024, -0.386,  0.962,  0.765, -0.125, -0.289,  0.521,  0.017,\n         0.281, -0.749, -0.149, -2.436, -0.909,  0.394, -0.113, -0.598,\n         0.443, -0.521, -0.799,  0.087]\n\ndys = [  0.136,  0.717,  0.459, -0.225,  1.392,  0.385,  0.121, -0.395,\n         0.490, -0.682, -0.065,  0.242, -0.288,  0.658,  0.459,  0.000,\n         0.426,  0.205, -0.765, -2.188, -0.742, -0.010,  0.089,  0.208,\n         0.585,  0.633, -0.444, -0.351, -1.087,  0.199,  0.701,  0.096,\n        -0.025, -0.868,  1.051,  0.157,  0.216,  0.162,  0.249, -0.007,\n         0.009,  0.508, -0.790,  0.723,  0.881, -0.508,  0.393, -0.226,\n         0.710,  0.038, -0.217,  0.831,  0.480,  0.407,  0.447, -0.295,\n         1.126,  0.380,  0.549, -0.445, -0.046,  0.428, -0.074,  0.217,\n        -0.822,  0.491,  1.347, -0.141,  1.230, -0.044,  0.079,  0.219,\n         0.698,  0.275,  0.056,  0.031,  0.421,  0.064,  0.721,  0.104,\n        -0.729,  0.650, -1.103,  0.154, -1.720,  0.051, -0.385,  0.477,\n         1.537, -0.901,  0.939, -0.411,  0.341, -0.411,  0.106,  0.224,\n        -0.947, -1.424, -0.542, -1.032]\n\nexperiment('Rule 1:', dxs, dys) {|z, dz| 0}\nexperiment('Rule 2:', dxs, dys) {|z, dz| -dz}\nexperiment('Rule 3:', dxs, dys) {|z, dz| -(z+dz)}\nexperiment('Rule 4:', dxs, dys) {|z, dz| z+dz}\n", "target": "import static java.lang.Math.*;\nimport java.util.Arrays;\nimport java.util.function.BiFunction;\n\npublic class DemingsFunnel {\n\n    public static void main(String[] args) {\n        double[] dxs = {\n            -0.533, 0.270, 0.859, -0.043, -0.205, -0.127, -0.071, 0.275,\n            1.251, -0.231, -0.401, 0.269, 0.491, 0.951, 1.150, 0.001,\n            -0.382, 0.161, 0.915, 2.080, -2.337, 0.034, -0.126, 0.014,\n            0.709, 0.129, -1.093, -0.483, -1.193, 0.020, -0.051, 0.047,\n            -0.095, 0.695, 0.340, -0.182, 0.287, 0.213, -0.423, -0.021,\n            -0.134, 1.798, 0.021, -1.099, -0.361, 1.636, -1.134, 1.315,\n            0.201, 0.034, 0.097, -0.170, 0.054, -0.553, -0.024, -0.181,\n            -0.700, -0.361, -0.789, 0.279, -0.174, -0.009, -0.323, -0.658,\n            0.348, -0.528, 0.881, 0.021, -0.853, 0.157, 0.648, 1.774,\n            -1.043, 0.051, 0.021, 0.247, -0.310, 0.171, 0.000, 0.106,\n            0.024, -0.386, 0.962, 0.765, -0.125, -0.289, 0.521, 0.017,\n            0.281, -0.749, -0.149, -2.436, -0.909, 0.394, -0.113, -0.598,\n            0.443, -0.521, -0.799, 0.087};\n\n        double[] dys = {\n            0.136, 0.717, 0.459, -0.225, 1.392, 0.385, 0.121, -0.395,\n            0.490, -0.682, -0.065, 0.242, -0.288, 0.658, 0.459, 0.000,\n            0.426, 0.205, -0.765, -2.188, -0.742, -0.010, 0.089, 0.208,\n            0.585, 0.633, -0.444, -0.351, -1.087, 0.199, 0.701, 0.096,\n            -0.025, -0.868, 1.051, 0.157, 0.216, 0.162, 0.249, -0.007,\n            0.009, 0.508, -0.790, 0.723, 0.881, -0.508, 0.393, -0.226,\n            0.710, 0.038, -0.217, 0.831, 0.480, 0.407, 0.447, -0.295,\n            1.126, 0.380, 0.549, -0.445, -0.046, 0.428, -0.074, 0.217,\n            -0.822, 0.491, 1.347, -0.141, 1.230, -0.044, 0.079, 0.219,\n            0.698, 0.275, 0.056, 0.031, 0.421, 0.064, 0.721, 0.104,\n            -0.729, 0.650, -1.103, 0.154, -1.720, 0.051, -0.385, 0.477,\n            1.537, -0.901, 0.939, -0.411, 0.341, -0.411, 0.106, 0.224,\n            -0.947, -1.424, -0.542, -1.032};\n\n        experiment(\"Rule 1:\", dxs, dys, (z, dz) -> 0.0);\n        experiment(\"Rule 2:\", dxs, dys, (z, dz) -> -dz);\n        experiment(\"Rule 3:\", dxs, dys, (z, dz) -> -(z + dz));\n        experiment(\"Rule 4:\", dxs, dys, (z, dz) -> z + dz);\n    }\n\n    static void experiment(String label, double[] dxs, double[] dys,\n            BiFunction<Double, Double, Double> rule) {\n\n        double[] resx = funnel(dxs, rule);\n        double[] resy = funnel(dys, rule);\n        System.out.println(label);\n        System.out.printf(\"Mean x, y:   \u00a0%.4f,\u00a0%.4f%n\", mean(resx), mean(resy));\n        System.out.printf(\"Std dev x, y:\u00a0%.4f,\u00a0%.4f%n\", stdDev(resx), stdDev(resy));\n        System.out.println();\n    }\n\n    static double[] funnel(double[] input, BiFunction<Double, Double, Double> rule) {\n        double x = 0;\n        double[] result = new double[input.length];\n\n        for (int i = 0; i < input.length; i++) {\n            double rx = x + input[i];\n            x = rule.apply(x, input[i]);\n            result[i] = rx;\n        }\n        return result;\n    }\n\n    static double mean(double[] xs) {\n        return Arrays.stream(xs).sum() / xs.length;\n    }\n\n    static double stdDev(double[] xs) {\n        double m = mean(xs);\n        return sqrt(Arrays.stream(xs).map(x -> pow((x - m), 2)).sum() / xs.length);\n    }\n}\n"}
{"id": 354371, "name": "MD5_Implementation", "source": "Translate Ruby to Java: class MD5(String msg) {\n\n    method init {\n        msg = msg.bytes\n    }\n\n    const FGHI = [\n        {|a,b,c| (a & b) | (~a & c) },\n        {|a,b,c| (a & c) | (b & ~c) },\n        {|a,b,c| (a ^ b ^ c)        },\n        {|a,b,c| (b ^ (a | ~c))     },\n    ]\n\n    const S = [\n        [7, 12, 17, 22] * 4,\n        [5,  9, 14, 20] * 4,\n        [4, 11, 16, 23] * 4,\n        [6, 10, 15, 21] * 4,\n    ].flat\n\n    const T = 64.of {|i| floor(abs(sin(i+1)) * 1<<32) }\n\n    const K = [\n        ^16 -> map {|n|    n           },\n        ^16 -> map {|n| (5*n + 1) % 16 },\n        ^16 -> map {|n| (3*n + 5) % 16 },\n        ^16 -> map {|n| (7*n    ) % 16 },\n    ].flat\n\n    func radix(Number b, Array a) {\n        ^a -> sum {|i| b**i * a[i] }\n    }\n\n    func little_endian(Number w, Number n, Array v) {\n        var step1 = (^n \u00bb*\u00bb w)\n        var step2 = (v ~X>> step1)\n        step2 \u00bb%\u00bb (1 << w)\n    }\n\n    func block(Number a, Number b) { (a  + b) & 0xffffffff }\n    func srble(Number a, Number n) { (a << n) & 0xffffffff | (a >> (32-n)) }\n\n    func md5_pad(msg) {\n        var bits = 8*msg.len\n        var padded = [msg..., 128, [0] * (-(floor(bits / 8) + 1 + 8) % 64)].flat\n\n        gather {\n            padded.each_slice(4, {|*a|\n                take(radix(256, a))\n            })\n            take(little_endian(32, 2, [bits]))\n        }.flat\n    }\n\n    func md5_block(Array H, Array X) {\n        var (A, B, C, D) = H...\n\n        for i in ^64 {\n            (A, B, C, D) = (D,\n                block(B, srble(\n                    block(\n                        block(\n                            block(A, FGHI[floor(i / 16)](B, C, D)), T[i]\n                        ), X[K[i]]\n                    ), S[i])\n                ), B, C)\n        }\n\n        for k,v in ([A, B, C, D].kv) {\n            H[k] = block(H[k], v)\n        }\n\n        return H\n    }\n\n    method md5_hex {\n        self.md5.map {|n| '%02x' % n }.join\n    }\n\n    method md5 {\n        var M = md5_pad(msg)\n        var H = [0x67452301, 0xefcdab89, 0x98badcfe, 0x10325476]\n\n        for i in (range(0, M.end, 16)) {\n            md5_block(H, M.ft(i, i+15))\n        }\n\n        little_endian(8, 4, H)\n    }\n}\n\nvar tests = [\n    ['d41d8cd98f00b204e9800998ecf8427e', ''],\n    ['0cc175b9c0f1b6a831c399e269772661', 'a'],\n    ['900150983cd24fb0d6963f7d28e17f72', 'abc'],\n    ['f96b697d7cb7938d525a2f31aaf161d0', 'message digest'],\n    ['c3fcd3d76192e4007dfb496cca67e13b', 'abcdefghijklmnopqrstuvwxyz'],\n    ['d174ab98d277d9f5a5611c2c9f419d9f', 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789'],\n    ['57edf4a22be3c955ac49da2e2107b67a', '12345678901234567890123456789012345678901234567890123456789012345678901234567890'],\n]\n\nfor md5,msg in tests {\n    var hash = MD5(msg).md5_hex\n    say \"\n\n    if (hash != md5) {\n        say \"\\tHowever, that is incorrect (expected: \n    }\n}\n", "target": "class MD5\n{\n\n  private static final int INIT_A = 0x67452301;\n  private static final int INIT_B = (int)0xEFCDAB89L;\n  private static final int INIT_C = (int)0x98BADCFEL;\n  private static final int INIT_D = 0x10325476;\n  \n  private static final int[] SHIFT_AMTS = {\n    7, 12, 17, 22,\n    5,  9, 14, 20,\n    4, 11, 16, 23,\n    6, 10, 15, 21\n  };\n  \n  private static final int[] TABLE_T = new int[64];\n  static\n  {\n    for (int i = 0; i < 64; i++)\n      TABLE_T[i] = (int)(long)((1L << 32) * Math.abs(Math.sin(i + 1)));\n  }\n  \n  public static byte[] computeMD5(byte[] message)\n  {\n    int messageLenBytes = message.length;\n    int numBlocks = ((messageLenBytes + 8) >>> 6) + 1;\n    int totalLen = numBlocks << 6;\n    byte[] paddingBytes = new byte[totalLen - messageLenBytes];\n    paddingBytes[0] = (byte)0x80;\n    \n    long messageLenBits = (long)messageLenBytes << 3;\n    for (int i = 0; i < 8; i++)\n    {\n      paddingBytes[paddingBytes.length - 8 + i] = (byte)messageLenBits;\n      messageLenBits >>>= 8;\n    }\n    \n    int a = INIT_A;\n    int b = INIT_B;\n    int c = INIT_C;\n    int d = INIT_D;\n    int[] buffer = new int[16];\n    for (int i = 0; i < numBlocks; i ++)\n    {\n      int index = i << 6;\n      for (int j = 0; j < 64; j++, index++)\n        buffer[j >>> 2] = ((int)((index < messageLenBytes) ? message[index] : paddingBytes[index - messageLenBytes]) << 24) | (buffer[j >>> 2] >>> 8);\n      int originalA = a;\n      int originalB = b;\n      int originalC = c;\n      int originalD = d;\n      for (int j = 0; j < 64; j++)\n      {\n        int div16 = j >>> 4;\n        int f = 0;\n        int bufferIndex = j;\n        switch (div16)\n        {\n          case 0:\n            f = (b & c) | (~b & d);\n            break;\n            \n          case 1:\n            f = (b & d) | (c & ~d);\n            bufferIndex = (bufferIndex * 5 + 1) & 0x0F;\n            break;\n            \n          case 2:\n            f = b ^ c ^ d;\n            bufferIndex = (bufferIndex * 3 + 5) & 0x0F;\n            break;\n            \n          case 3:\n            f = c ^ (b | ~d);\n            bufferIndex = (bufferIndex * 7) & 0x0F;\n            break;\n        }\n        int temp = b + Integer.rotateLeft(a + f + buffer[bufferIndex] + TABLE_T[j], SHIFT_AMTS[(div16 << 2) | (j & 3)]);\n        a = d;\n        d = c;\n        c = b;\n        b = temp;\n      }\n      \n      a += originalA;\n      b += originalB;\n      c += originalC;\n      d += originalD;\n    }\n    \n    byte[] md5 = new byte[16];\n    int count = 0;\n    for (int i = 0; i < 4; i++)\n    {\n      int n = (i == 0) ? a : ((i == 1) ? b : ((i == 2) ? c : d));\n      for (int j = 0; j < 4; j++)\n      {\n        md5[count++] = (byte)n;\n        n >>>= 8;\n      }\n    }\n    return md5;\n  }\n  \n  public static String toHexString(byte[] b)\n  {\n    StringBuilder sb = new StringBuilder();\n    for (int i = 0; i < b.length; i++)\n    {\n      sb.append(String.format(\"%02X\", b[i] & 0xFF));\n    }\n    return sb.toString();\n  }\n\n  public static void main(String[] args)\n  {\n    String[] testStrings = { \"\", \"a\", \"abc\", \"message digest\", \"abcdefghijklmnopqrstuvwxyz\", \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789\", \"12345678901234567890123456789012345678901234567890123456789012345678901234567890\" };\n    for (String s : testStrings)\n      System.out.println(\"0x\" + toHexString(computeMD5(s.getBytes())) + \" <== \\\"\" + s + \"\\\"\");\n    return;\n  }\n  \n}\n"}
{"id": 354372, "name": "Assertions in design by contract", "source": "Translate Ruby to Java: require 'contracts'\ninclude Contracts\n\nContract Num => Num\ndef double(x)\n  x * 2\nend\n\nputs double(\"oops\")\n", "target": "(...)\nint feedForward(double[] inputs) {\n    assert inputs.length == weights.length : \"weights and input length mismatch\";\n\n    double sum = 0;\n    for (int i = 0; i < weights.length; i++) {\n        sum += inputs[i] * weights[i];\n    }\n    return activate(sum);\n}\n(...)\n"}
{"id": 354373, "name": "Assertions in design by contract", "source": "Translate Ruby to Java: require 'contracts'\ninclude Contracts\n\nContract Num => Num\ndef double(x)\n  x * 2\nend\n\nputs double(\"oops\")\n", "target": "(...)\nint feedForward(double[] inputs) {\n    assert inputs.length == weights.length : \"weights and input length mismatch\";\n\n    double sum = 0;\n    for (int i = 0; i < weights.length; i++) {\n        sum += inputs[i] * weights[i];\n    }\n    return activate(sum);\n}\n(...)\n"}
{"id": 354374, "name": "History variables", "source": "Translate Ruby to Java: foo_hist = []\ntrace_var(:$foo){|v| foo_hist.unshift(v)}\n\n$foo = \"apple\"\n$foo = \"pear\"\n$foo = \"banana\"\n\np foo_hist \n", "target": "public class HistoryVariable\n{\n    private Object value;\n\n    public HistoryVariable(Object v)\n    {\n        value = v;\n    }\n\n    public void update(Object v)\n    {\n        value = v;\n    }\n\n    public Object undo()\n    {\n        return value;\n    }\n\n    @Override\n    public String toString()\n    {\n        return value.toString();\n    }\n\n    public void dispose()\n    {\n    }\n}\n"}
{"id": 354375, "name": "Successive prime differences", "source": "Translate Ruby to Java: require 'prime'\nPRIMES = Prime.each(1_000_000).to_a\ndifs = [[2], [1], [2,2], [2,4], [4,2], [6,4,2]]\n\ndifs.each do |ar|\n  res = PRIMES.each_cons(ar.size+1).select do |slice|\n    slice.each_cons(2).zip(ar).all? {|(a,b), c| a+c == b}\n  end\n  puts \"\nend\n", "target": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\n\npublic class SuccessivePrimeDifferences {\n    private static Integer[] sieve(int limit) {\n        List<Integer> primes = new ArrayList<>();\n        primes.add(2);\n        boolean[] c = new boolean[limit + 1];\n        \n        int p = 3;\n        while (true) {\n            int p2 = p * p;\n            if (p2 > limit) {\n                break;\n            }\n            for (int i = p2; i <= limit; i += 2 * p) {\n                c[i] = true;\n            }\n            do {\n                p += 2;\n            } while (c[p]);\n        }\n        for (int i = 3; i <= limit; i += 2) {\n            if (!c[i]) {\n                primes.add(i);\n            }\n        }\n\n        return primes.toArray(new Integer[0]);\n    }\n\n    private static List<List<Integer>> successivePrimes(Integer[] primes, Integer[] diffs) {\n        List<List<Integer>> results = new ArrayList<>();\n        int dl = diffs.length;\n        outer:\n        for (int i = 0; i < primes.length - dl; i++) {\n            Integer[] group = new Integer[dl + 1];\n            group[0] = primes[i];\n            for (int j = i; j < i + dl; ++j) {\n                if (primes[j + 1] - primes[j] != diffs[j - i]) {\n                    continue outer;\n                }\n                group[j - i + 1] = primes[j + 1];\n            }\n            results.add(Arrays.asList(group));\n        }\n        return results;\n    }\n\n    public static void main(String[] args) {\n        Integer[] primes = sieve(999999);\n        Integer[][] diffsList = {{2}, {1}, {2, 2}, {2, 4}, {4, 2}, {6, 4, 2}};\n        System.out.println(\"For primes less than 1,000,000:-\\n\");\n        for (Integer[] diffs : diffsList) {\n            System.out.printf(\"  For differences of %s ->\\n\", Arrays.toString(diffs));\n            List<List<Integer>> sp = successivePrimes(primes, diffs);\n            if (sp.isEmpty()) {\n                System.out.println(\"    No groups found\");\n                continue;\n            }\n            System.out.printf(\"    First group   = %s\\n\", Arrays.toString(sp.get(0).toArray(new Integer[0])));\n            System.out.printf(\"    Last group    = %s\\n\", Arrays.toString(sp.get(sp.size() - 1).toArray(new Integer[0])));\n            System.out.printf(\"    Number found  = %d\\n\", sp.size());\n            System.out.println();\n        }\n    }\n}\n"}

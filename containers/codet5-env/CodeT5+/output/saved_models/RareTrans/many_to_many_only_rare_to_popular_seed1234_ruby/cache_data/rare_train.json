{"id": 220, "name": "Arithmetic_Integer", "source": "Translate Ruby to C#: puts 'Enter x and y'\nx = gets.to_i  \ny = gets.to_i\n\nputs \"Sum: \n     \"Difference: \n     \"Product: \n     \"Quotient: \n     \"Quotient: \n     \"Remainder: \n     \"Exponentiation: \n     \"Quotient: %d with Remainder: %d\" % x.divmod(y)\n", "target": "using System;\n\nclass Program\n{\n    static void Main(string[] args)\n    {\n        int a = Convert.ToInt32(args[0]);\n        int b = Convert.ToInt32(args[1]);\n\n        Console.WriteLine(\"{0} + {1} = {2}\", a, b, a + b);\n        Console.WriteLine(\"{0} - {1} = {2}\", a, b, a - b);\n        Console.WriteLine(\"{0} * {1} = {2}\", a, b, a * b);\n        Console.WriteLine(\"{0} / {1} = {2}\", a, b, a / b); \n        Console.WriteLine(\"{0}\u00a0% {1} = {2}\", a, b, a % b); \n        Console.WriteLine(\"{0} to the power of {1} = {2}\", a, b, Math.Pow(a, b));\n    }\n}\n"}
{"id": 222, "name": "Arithmetic_Integer", "source": "Translate Ruby to Java: puts 'Enter x and y'\nx = gets.to_i  \ny = gets.to_i\n\nputs \"Sum: \n     \"Difference: \n     \"Product: \n     \"Quotient: \n     \"Quotient: \n     \"Remainder: \n     \"Exponentiation: \n     \"Quotient: %d with Remainder: %d\" % x.divmod(y)\n", "target": "import java.util.Scanner;\n\npublic class IntegerArithmetic {\n    public static void main(String[] args) {\n        \n        Scanner sc = new Scanner(System.in);\n        int a = sc.nextInt();\n        int b = sc.nextInt();\n\n        int sum = a + b;        \n        int difference = a - b; \n        int product = a * b;    \n        int division = a / b;   \n        int remainder = a % b;  \n\n        System.out.println(\"a + b = \" + sum);\n        System.out.println(\"a - b = \" + difference);\n        System.out.println(\"a * b = \" + product);\n        System.out.println(\"quotient of a / b = \" + division);   \n        System.out.println(\"remainder of a / b = \" + remainder);   \n    }\n}\n"}
{"id": 223, "name": "Arithmetic_Integer", "source": "Translate Ruby to Python: puts 'Enter x and y'\nx = gets.to_i  \ny = gets.to_i\n\nputs \"Sum: \n     \"Difference: \n     \"Product: \n     \"Quotient: \n     \"Quotient: \n     \"Remainder: \n     \"Exponentiation: \n     \"Quotient: %d with Remainder: %d\" % x.divmod(y)\n", "target": "x = int(raw_input(\"Number 1: \"))\ny = int(raw_input(\"Number 2: \"))\n\nprint \"Sum: %d\" % (x + y)\nprint \"Difference: %d\" % (x - y)\nprint \"Product: %d\" % (x * y)\nprint \"Quotient: %d\" % (x / y)     \n                                   \nprint \"Remainder: %d\" % (x % y)    \nprint \"Quotient: %d with Remainder: %d\" % divmod(x, y)\nprint \"Power: %d\" % x**y\n\n\nraw_input( )\n"}
{"id": 460, "name": "Null object", "source": "Translate Ruby to C#: puts \"@object is nil\" if @object.nil?\t\t\n\nputs \"$object is nil\" if $object.nil?\t\t\n\n\nobject = 1  if false\nputs \"object is nil\" if object.nil?\n\n\nputs nil.class  \n", "target": "if (foo == null)\n    Console.WriteLine(\"foo is null\");\n"}
{"id": 462, "name": "Null object", "source": "Translate Ruby to Java: puts \"@object is nil\" if @object.nil?\t\t\n\nputs \"$object is nil\" if $object.nil?\t\t\n\n\nobject = 1  if false\nputs \"object is nil\" if object.nil?\n\n\nputs nil.class  \n", "target": "module NullObject\n    {\n    void run()\n        {\n        @Inject Console console;\n        console.print($\"Null value={Null}, Null.toString()={Null.toString()}\");\n\n     \n        String? s = Null;       \n        String s2 = \"test\";\n        console.print($\"s={s}, s2={s2}, (s==s2)={s==s2}\");\n\n     \n        Int len = s?.size : 0;\n        console.print($\"len={len}\");\n\n        if (String test ?= s)\n            {\n            \n            }\n        else\n            {\n            s = \"a non-null value\";\n            }\n\n     \n        s2 = s;                 \n        console.print($\"s={s}, s2={s2}, (s==s2)={s==s2}\");\n        }\n    }\n"}
{"id": 463, "name": "Null object", "source": "Translate Ruby to Python: puts \"@object is nil\" if @object.nil?\t\t\n\nputs \"$object is nil\" if $object.nil?\t\t\n\n\nobject = 1  if false\nputs \"object is nil\" if object.nil?\n\n\nputs nil.class  \n", "target": "x = None\nif x is None:\n  print \"x is None\"\nelse:\n  print \"x is not None\"\n"}
{"id": 577, "name": "Chat server", "source": "Translate Ruby to C#: require 'gserver'\n\nclass ChatServer < GServer\n  def initialize *args\n    super\n\n    \n    @chatters = []\n\n    \n    @mutex = Mutex.new \n  end\n\n  \n  def broadcast message, sender = nil\n    \n    message = message.strip << \"\\r\\n\"\n\n    \n    @mutex.synchronize do\n      @chatters.each do |chatter|\n        begin\n          chatter.print message unless chatter == sender\n        rescue\n          @chatters.delete chatter\n        end\n      end\n    end\n  end\n\n  \n  def serve io\n    io.print 'Name: '\n    name = io.gets\n\n    \n    return if name.nil?\n\n    name.strip!\n\n    broadcast \"--+ \n\n    \n    @mutex.synchronize do\n      @chatters << io\n    end\n\n    \n    loop do\n      message = io.gets\n\n      if message\n        broadcast \"\n      else\n        break\n      end\n    end\n\n    broadcast \"--+ \n  end\nend\n\n\n\n\n\n\nChatServer.new(7000, '0.0.0.0', 100, $stderr, true).start.join\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Net.Sockets;\nusing System.Text;\nusing System.Threading;\n\nnamespace ChatServer {\n    class State {\n        private TcpClient client;\n        private StringBuilder sb = new StringBuilder();\n\n        public string Name { get; }\n\n        public State(string name, TcpClient client) {\n            Name = name;\n            this.client = client;\n        }\n\n        public void Add(byte b) {\n            sb.Append((char)b);\n        }\n\n        public void Send(string text) {\n            var bytes = Encoding.ASCII.GetBytes(string.Format(\"{0}\\r\\n\", text));\n            client.GetStream().Write(bytes, 0, bytes.Length);\n        }\n    }\n\n    class Program {\n        static TcpListener listen;\n        static Thread serverthread;\n        static Dictionary<int, State> connections = new Dictionary<int, State>();\n\n        static void Main(string[] args) {\n            listen = new TcpListener(System.Net.IPAddress.Parse(\"127.0.0.1\"), 4004);\n            serverthread = new Thread(new ThreadStart(DoListen));\n            serverthread.Start();\n        }\n\n        private static void DoListen() {\n            \n            listen.Start();\n            Console.WriteLine(\"Server: Started server\");\n\n            while (true) {\n                Console.WriteLine(\"Server: Waiting...\");\n                TcpClient client = listen.AcceptTcpClient();\n                Console.WriteLine(\"Server: Waited\");\n\n                \n                Thread clientThread = new Thread(new ParameterizedThreadStart(DoClient));\n                clientThread.Start(client);\n            }\n        }\n\n        private static void DoClient(object client) {\n            \n            TcpClient tClient = (TcpClient)client;\n\n            Console.WriteLine(\"Client (Thread: {0}): Connected!\", Thread.CurrentThread.ManagedThreadId);\n            byte[] bytes = Encoding.ASCII.GetBytes(\"Enter name: \");\n            tClient.GetStream().Write(bytes, 0, bytes.Length);\n\n            string name = string.Empty;\n            bool done = false;\n            do {\n                if (!tClient.Connected) {\n                    Console.WriteLine(\"Client (Thread: {0}): Terminated!\", Thread.CurrentThread.ManagedThreadId);\n                    tClient.Close();\n                    Thread.CurrentThread.Abort();       \n                }\n\n                name = Receive(tClient);\n                done = true;\n\n                if (done) {\n                    foreach (var cl in connections) {\n                        var state = cl.Value;\n                        if (state.Name == name) {\n                            bytes = Encoding.ASCII.GetBytes(\"Name already registered. Please enter your name: \");\n                            tClient.GetStream().Write(bytes, 0, bytes.Length);\n                            done = false;\n                        }\n                    }\n                }\n            } while (!done);\n\n            connections.Add(Thread.CurrentThread.ManagedThreadId, new State(name, tClient));\n            Console.WriteLine(\"\\tTotal connections: {0}\", connections.Count);\n            Broadcast(string.Format(\"+++ {0} arrived +++\", name));\n\n            do {\n                string text = Receive(tClient);\n                if (text == \"/quit\") {\n                    Broadcast(string.Format(\"Connection from {0} closed.\", name));\n                    connections.Remove(Thread.CurrentThread.ManagedThreadId);\n                    Console.WriteLine(\"\\tTotal connections: {0}\", connections.Count);\n                    break;\n                }\n\n                if (!tClient.Connected) {\n                    break;\n                }\n                Broadcast(string.Format(\"{0}> {1}\", name, text));\n            } while (true);\n\n            Console.WriteLine(\"Client (Thread: {0}): Terminated!\", Thread.CurrentThread.ManagedThreadId);\n            tClient.Close();\n            Thread.CurrentThread.Abort();\n        }\n\n        private static string Receive(TcpClient client) {\n            StringBuilder sb = new StringBuilder();\n            do {\n                if (client.Available > 0) {\n                    while (client.Available > 0) {\n                        char ch = (char)client.GetStream().ReadByte();\n                        if (ch == '\\r') {\n                            \n                            continue;\n                        }\n                        if (ch == '\\n') {\n                            return sb.ToString();\n                        }\n                        sb.Append(ch);\n                    }\n                }\n\n                \n                Thread.Sleep(100);\n            } while (true);\n        }\n\n        private static void Broadcast(string text) {\n            Console.WriteLine(text);\n            foreach (var oClient in connections) {\n                if (oClient.Key != Thread.CurrentThread.ManagedThreadId) {\n                    State state = oClient.Value;\n                    state.Send(text);\n                }\n            }\n        }\n    }\n}\n"}
{"id": 578, "name": "Chat server", "source": "Translate Ruby to Java: require 'gserver'\n\nclass ChatServer < GServer\n  def initialize *args\n    super\n\n    \n    @chatters = []\n\n    \n    @mutex = Mutex.new \n  end\n\n  \n  def broadcast message, sender = nil\n    \n    message = message.strip << \"\\r\\n\"\n\n    \n    @mutex.synchronize do\n      @chatters.each do |chatter|\n        begin\n          chatter.print message unless chatter == sender\n        rescue\n          @chatters.delete chatter\n        end\n      end\n    end\n  end\n\n  \n  def serve io\n    io.print 'Name: '\n    name = io.gets\n\n    \n    return if name.nil?\n\n    name.strip!\n\n    broadcast \"--+ \n\n    \n    @mutex.synchronize do\n      @chatters << io\n    end\n\n    \n    loop do\n      message = io.gets\n\n      if message\n        broadcast \"\n      else\n        break\n      end\n    end\n\n    broadcast \"--+ \n  end\nend\n\n\n\n\n\n\nChatServer.new(7000, '0.0.0.0', 100, $stderr, true).start.join\n", "target": "import java.io.*;\nimport java.net.*;\nimport java.util.*;\n\npublic class ChatServer implements Runnable\n{\n  private int port = 0;\n  private List<Client> clients = new ArrayList<Client>();\n  \n  public ChatServer(int port)\n  {  this.port = port;  }\n  \n  public void run()\n  {\n    try\n    {\n      ServerSocket ss = new ServerSocket(port);\n      while (true)\n      {\n        Socket s = ss.accept();\n        new Thread(new Client(s)).start();\n      }\n    }\n    catch (Exception e)\n    {  e.printStackTrace();  }\n  }\n\n  private synchronized boolean registerClient(Client client)\n  {\n    for (Client otherClient : clients)\n      if (otherClient.clientName.equalsIgnoreCase(client.clientName))\n        return false;\n    clients.add(client);\n    return true;\n  }\n\n  private void deregisterClient(Client client)\n  {\n    boolean wasRegistered = false;\n    synchronized (this)\n    {  wasRegistered = clients.remove(client);  }\n    if (wasRegistered)\n      broadcast(client, \"--- \" + client.clientName + \" left ---\");\n  }\n  \n  private synchronized String getOnlineListCSV()\n  {\n    StringBuilder sb = new StringBuilder();\n    sb.append(clients.size()).append(\" user(s) online: \");\n    for (int i = 0; i < clients.size(); i++)\n      sb.append((i > 0) ? \", \" : \"\").append(clients.get(i).clientName);\n    return sb.toString();\n  }\n  \n  private void broadcast(Client fromClient, String msg)\n  {\n    \n    List<Client> clients = null;\n    synchronized (this)\n    {  clients = new ArrayList<Client>(this.clients);  }\n    for (Client client : clients)\n    {\n      if (client.equals(fromClient))\n        continue;\n      try\n      {  client.write(msg + \"\\r\\n\");  }\n      catch (Exception e)\n      {  }\n    }\n  }\n\n  public class Client implements Runnable\n  {\n    private Socket socket = null;\n    private Writer output = null;\n    private String clientName = null;\n    \n    public Client(Socket socket)\n    {\n      this.socket = socket;\n    }\n    \n    public void run()\n    {\n      try\n      {\n        socket.setSendBufferSize(16384);\n        socket.setTcpNoDelay(true);\n        BufferedReader input = new BufferedReader(new InputStreamReader(socket.getInputStream()));\n        output = new OutputStreamWriter(socket.getOutputStream());\n        write(\"Please enter your name: \");\n        String line = null;\n        while ((line = input.readLine()) != null)\n        {\n          if (clientName == null)\n          {\n            line = line.trim();\n            if (line.isEmpty())\n            {\n              write(\"A name is required. Please enter your name: \");\n              continue;\n            }\n            clientName = line;\n            if (!registerClient(this))\n            {\n              clientName = null;\n              write(\"Name already registered. Please enter your name: \");\n              continue;\n            }\n            write(getOnlineListCSV() + \"\\r\\n\");\n            broadcast(this, \"+++ \" + clientName + \" arrived +++\");\n            continue;\n          }\n          if (line.equalsIgnoreCase(\"/quit\"))\n            return;\n          broadcast(this, clientName + \"> \" + line);\n        }\n      }\n      catch (Exception e)\n      {  }\n      finally\n      {\n        deregisterClient(this);\n        output = null;\n        try\n        {  socket.close();  }\n        catch (Exception e)\n        {  }\n        socket = null;\n      }\n    }\n    \n    public void write(String msg) throws IOException\n    {\n      output.write(msg);\n      output.flush();\n    }\n    \n    public boolean equals(Client client)\n    {\n      return (client != null) && (client instanceof Client) && (clientName != null) && (client.clientName != null) && clientName.equals(client.clientName);\n    }\n  }\n  \n  public static void main(String[] args)\n  {\n    int port = 4004;\n    if (args.length > 0)\n      port = Integer.parseInt(args[0]);\n    new ChatServer(port).run();\n  }\n}\n"}
{"id": 579, "name": "Chat server", "source": "Translate Ruby to Python: require 'gserver'\n\nclass ChatServer < GServer\n  def initialize *args\n    super\n\n    \n    @chatters = []\n\n    \n    @mutex = Mutex.new \n  end\n\n  \n  def broadcast message, sender = nil\n    \n    message = message.strip << \"\\r\\n\"\n\n    \n    @mutex.synchronize do\n      @chatters.each do |chatter|\n        begin\n          chatter.print message unless chatter == sender\n        rescue\n          @chatters.delete chatter\n        end\n      end\n    end\n  end\n\n  \n  def serve io\n    io.print 'Name: '\n    name = io.gets\n\n    \n    return if name.nil?\n\n    name.strip!\n\n    broadcast \"--+ \n\n    \n    @mutex.synchronize do\n      @chatters << io\n    end\n\n    \n    loop do\n      message = io.gets\n\n      if message\n        broadcast \"\n      else\n        break\n      end\n    end\n\n    broadcast \"--+ \n  end\nend\n\n\n\n\n\n\nChatServer.new(7000, '0.0.0.0', 100, $stderr, true).start.join\n", "target": "\n\nimport socket\nimport thread\nimport time\n\nHOST = \"\"\nPORT = 4004\n\ndef accept(conn):\n    \n    def threaded():\n        while True:\n            conn.send(\"Please enter your name: \")\n            try:\n                name = conn.recv(1024).strip()\n            except socket.error:\n                continue\n            if name in users:\n                conn.send(\"Name entered is already in use.\\n\")\n            elif name:\n                conn.setblocking(False)\n                users[name] = conn\n                broadcast(name, \"+++ %s arrived +++\" % name)\n                break\n    thread.start_new_thread(threaded, ())\n\ndef broadcast(name, message):\n    \n    print message\n    for to_name, conn in users.items():\n        if to_name != name:\n            try:\n                conn.send(message + \"\\n\")\n            except socket.error:\n                pass\n\n\nserver = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\nserver.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)\nserver.setblocking(False)\nserver.bind((HOST, PORT))\nserver.listen(1)\nprint \"Listening on %s\" % (\"%s:%s\" % server.getsockname())\n\n\nusers = {}\nwhile True:\n    try:\n        \n        while True:\n            try:\n                conn, addr = server.accept()\n            except socket.error:\n                break\n            accept(conn)\n        \n        for name, conn in users.items():\n            try:\n                message = conn.recv(1024)\n            except socket.error:\n                continue\n            if not message:\n                \n                del users[name]\n                broadcast(name, \"--- %s leaves ---\" % name)\n            else:\n                broadcast(name, \"%s> %s\" % (name, message.strip()))\n        time.sleep(.1)\n    except (SystemExit, KeyboardInterrupt):\n        break\n"}
{"id": 714, "name": "Percentage difference between images", "source": "Translate Ruby to C#: require 'raster_graphics'\n\nclass RGBColour\n  \n  def -(a_colour)\n    (@red - a_colour.red).abs +\n    (@green - a_colour.green).abs +\n    (@blue - a_colour.blue).abs\n  end\nend\n\nclass Pixmap\n  \n  def -(a_pixmap)\n    if @width != a_pixmap.width or @height != a_pixmap.height\n      raise ArgumentError, \"can't compare images with different sizes\"\n    end\n    sum = 0\n    each_pixel {|x,y| sum += self[x,y] - a_pixmap[x,y]}\n    Float(sum) / (@width * @height * 255 * 3)\n  end\nend\n\nlenna50 = Pixmap.open_from_jpeg('Lenna50.jpg')\nlenna100 = Pixmap.open_from_jpeg('Lenna100.jpg')\n\nputs \"difference:\u00a0%.5f%%\" % (100.0 * (lenna50 - lenna100))\n", "target": "using System;\nusing System.Drawing;\n\nclass Program\n{\n    static void Main()\n    {\n        Bitmap img1 = new Bitmap(\"Lenna50.jpg\");\n        Bitmap img2 = new Bitmap(\"Lenna100.jpg\");\n\n        if (img1.Size != img2.Size)\n        {\n            Console.Error.WriteLine(\"Images are of different sizes\");\n            return;\n        }\n\n        float diff = 0;\n\n        for (int y = 0; y < img1.Height; y++)\n        {\n            for (int x = 0; x < img1.Width; x++)\n            {\n                Color pixel1 = img1.GetPixel(x, y);\n                Color pixel2 = img2.GetPixel(x, y);\n\n                diff += Math.Abs(pixel1.R - pixel2.R);\n                diff += Math.Abs(pixel1.G - pixel2.G);\n                diff += Math.Abs(pixel1.B - pixel2.B);\n            }\n        }\n\n        Console.WriteLine(\"diff: {0}\u00a0%\", 100 * (diff / 255) / (img1.Width * img1.Height * 3));\n    }\n}\n"}
{"id": 716, "name": "Percentage difference between images", "source": "Translate Ruby to Java: require 'raster_graphics'\n\nclass RGBColour\n  \n  def -(a_colour)\n    (@red - a_colour.red).abs +\n    (@green - a_colour.green).abs +\n    (@blue - a_colour.blue).abs\n  end\nend\n\nclass Pixmap\n  \n  def -(a_pixmap)\n    if @width != a_pixmap.width or @height != a_pixmap.height\n      raise ArgumentError, \"can't compare images with different sizes\"\n    end\n    sum = 0\n    each_pixel {|x,y| sum += self[x,y] - a_pixmap[x,y]}\n    Float(sum) / (@width * @height * 255 * 3)\n  end\nend\n\nlenna50 = Pixmap.open_from_jpeg('Lenna50.jpg')\nlenna100 = Pixmap.open_from_jpeg('Lenna100.jpg')\n\nputs \"difference:\u00a0%.5f%%\" % (100.0 * (lenna50 - lenna100))\n", "target": "import java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.io.IOException;\nimport javax.imageio.ImageIO;\n\npublic enum ImgDiffPercent {\n    ;\n\n    public static void main(String[] args) throws IOException {\n        \n        \n        BufferedImage img1 = ImageIO.read(new File(\"Lenna50.jpg\"));\n        BufferedImage img2 = ImageIO.read(new File(\"Lenna100.jpg\"));\n\n        double p = getDifferencePercent(img1, img2);\n        System.out.println(\"diff percent: \" + p);\n    }\n\n    private static double getDifferencePercent(BufferedImage img1, BufferedImage img2) {\n        int width = img1.getWidth();\n        int height = img1.getHeight();\n        int width2 = img2.getWidth();\n        int height2 = img2.getHeight();\n        if (width != width2 || height != height2) {\n            throw new IllegalArgumentException(String.format(\"Images must have the same dimensions: (%d,%d) vs. (%d,%d)\", width, height, width2, height2));\n        }\n\n        long diff = 0;\n        for (int y = 0; y < height; y++) {\n            for (int x = 0; x < width; x++) {\n                diff += pixelDiff(img1.getRGB(x, y), img2.getRGB(x, y));\n            }\n        }\n        long maxDiff = 3L * 255 * width * height;\n\n        return 100.0 * diff / maxDiff;\n    }\n\n    private static int pixelDiff(int rgb1, int rgb2) {\n        int r1 = (rgb1 >> 16) & 0xff;\n        int g1 = (rgb1 >>  8) & 0xff;\n        int b1 =  rgb1        & 0xff;\n        int r2 = (rgb2 >> 16) & 0xff;\n        int g2 = (rgb2 >>  8) & 0xff;\n        int b2 =  rgb2        & 0xff;\n        return Math.abs(r1 - r2) + Math.abs(g1 - g2) + Math.abs(b1 - b2);\n    }\n}\n"}
{"id": 717, "name": "Percentage difference between images", "source": "Translate Ruby to Python: require 'raster_graphics'\n\nclass RGBColour\n  \n  def -(a_colour)\n    (@red - a_colour.red).abs +\n    (@green - a_colour.green).abs +\n    (@blue - a_colour.blue).abs\n  end\nend\n\nclass Pixmap\n  \n  def -(a_pixmap)\n    if @width != a_pixmap.width or @height != a_pixmap.height\n      raise ArgumentError, \"can't compare images with different sizes\"\n    end\n    sum = 0\n    each_pixel {|x,y| sum += self[x,y] - a_pixmap[x,y]}\n    Float(sum) / (@width * @height * 255 * 3)\n  end\nend\n\nlenna50 = Pixmap.open_from_jpeg('Lenna50.jpg')\nlenna100 = Pixmap.open_from_jpeg('Lenna100.jpg')\n\nputs \"difference:\u00a0%.5f%%\" % (100.0 * (lenna50 - lenna100))\n", "target": "from PIL import Image\n\ni1 = Image.open(\"image1.jpg\")\ni2 = Image.open(\"image2.jpg\")\nassert i1.mode == i2.mode, \"Different kinds of images.\"\nassert i1.size == i2.size, \"Different sizes.\"\n\npairs = zip(i1.getdata(), i2.getdata())\nif len(i1.getbands()) == 1:\n    \n    dif = sum(abs(p1-p2) for p1,p2 in pairs)\nelse:\n    dif = sum(abs(c1-c2) for p1,p2 in pairs for c1,c2 in zip(p1,p2))\n\nncomponents = i1.size[0] * i1.size[1] * 3\nprint (\"Difference (percentage):\", (dif / 255.0 * 100) / ncomponents)\n"}
{"id": 952, "name": "Bitwise operations", "source": "Translate Ruby to C#: def bitwise(a, b)\n  form = \"%1$7s:%2$6d  %2$016b\"\n  puts form % [\"a\", a]\n  puts form % [\"b\", b]\n  puts form % [\"a and b\", a & b]\n  puts form % [\"a or b \", a | b]\n  puts form % [\"a xor b\", a ^ b]\n  puts form % [\"not a  \", ~a]\n  puts form % [\"a << b \", a << b]  \n  puts form % [\"a >> b \", a >> b]  \nend\n\nbitwise(14,3)\n", "target": "static void bitwise(int a, int b)\n        {\n            Console.WriteLine(\"a and b is {0}\", a & b);\n            Console.WriteLine(\"a or b is {0}\", a | b);\n            Console.WriteLine(\"a xor b is {0}\", a ^ b);\n            Console.WriteLine(\"not a is {0}\", ~a);\n            Console.WriteLine(\"a lshift b is {0}\", a << b);\n            Console.WriteLine(\"a arshift b is {0}\", a >> b); \n                                                             \n            uint c = (uint)a;\n            Console.WriteLine(\"c rshift b is {0}\", c >> b); \n                                                            \n            \n        }\n"}
{"id": 954, "name": "Bitwise operations", "source": "Translate Ruby to Java: def bitwise(a, b)\n  form = \"%1$7s:%2$6d  %2$016b\"\n  puts form % [\"a\", a]\n  puts form % [\"b\", b]\n  puts form % [\"a and b\", a & b]\n  puts form % [\"a or b \", a | b]\n  puts form % [\"a xor b\", a ^ b]\n  puts form % [\"not a  \", ~a]\n  puts form % [\"a << b \", a << b]  \n  puts form % [\"a >> b \", a >> b]  \nend\n\nbitwise(14,3)\n", "target": "module BitwiseOps\n    {\n    @Inject Console console;\n    void run()\n        {\n        for ((Int64 n1, Int64 n2) : [0=7, 1=5, 42=2, 0x123456789ABCDEF=0xFF])  \n            {\n            static String hex(Int64 n)   \n                {\n                \n                return n.toByteArray() [(n.leadingZeroCount / 8).minOf(7) ..< 8].toString();\n                }\n\n            console.print($|For values {n1} ({hex(n1)}) and {n2} ({hex(n2)}):\n                           |  {hex(n1)} AND {hex(n2)} = {hex(n1 & n2)}\n                           |  {hex(n1)} OR {hex(n2)} = {hex(n1 | n2)}\n                           |  {hex(n1)} XOR {hex(n2)} = {hex(n1 ^ n2)}\n                           |  NOT {hex(n1)} = {hex(~n1)}\n                           |  left shift {hex(n1)} by {n2} = {hex(n1 << n2)}\n                           |  right shift {hex(n1)} by {n2} = {hex(n1 >> n2)}\n                           |  right arithmetic shift {hex(n1)} by {n2} = {hex(n1 >>> n2)}\n                           |  left rotate {hex(n1)} by {n2} = {hex(n1.rotateLeft(n2))}\n                           |  right rotate {hex(n1)} by {n2} = {hex(n1.rotateRight(n2))}\n                           |  leftmost bit of {hex(n1)} = {hex(n1.leftmostBit)}\n                           |  rightmost bit of {hex(n1)} = {hex(n1.rightmostBit)}\n                           |  leading zero count of {hex(n1)} = {n1.leadingZeroCount}\n                           |  trailing zero count of {hex(n1)} = {n1.trailingZeroCount}\n                           |  bit count (aka \"population\") of {hex(n1)} = {n1.bitCount}\n                           |  reversed bits of {hex(n1)} = {hex(n1.reverseBits())}\n                           |  reverse bytes of {hex(n1)} = {hex(n1.reverseBytes())}\n                           |\n                         );\n            }\n        }\n    }\n"}
{"id": 955, "name": "Bitwise operations", "source": "Translate Ruby to Python: def bitwise(a, b)\n  form = \"%1$7s:%2$6d  %2$016b\"\n  puts form % [\"a\", a]\n  puts form % [\"b\", b]\n  puts form % [\"a and b\", a & b]\n  puts form % [\"a or b \", a | b]\n  puts form % [\"a xor b\", a ^ b]\n  puts form % [\"not a  \", ~a]\n  puts form % [\"a << b \", a << b]  \n  puts form % [\"a >> b \", a >> b]  \nend\n\nbitwise(14,3)\n", "target": "def bitwise_built_ins(width, a, b):\n    mask = (1 << width) - 1\n    print(f)\n\ndef rotr(width, a, n):\n    \"Rotate a, n times to the right\"\n    if n < 0:\n        return rotl(width, a, -n)\n    elif n == 0:\n        return a\n    else:\n        mask = (1 << width) - 1\n        a, n = a & mask, n % width\n        return ((a >> n)    \n                | ((a & ((1 << n) - 1))   \n                   << (width - n)))  \n\ndef rotl(width, a, n):\n    \"Rotate a, n times to the left\"\n    if n < 0:\n        return rotr(width, a, -n)\n    elif n == 0:\n        return a\n    else:\n        mask = (1 << width) - 1\n        a, n = a & mask, n % width\n        return (((a << n) & mask)      \n                | (a >> (width - n)))  \n    \ndef asr(width, a, n):\n    \"Arithmetic shift a, n times to the right. (sign preserving).\"\n    mask, top_bit_mask = ((1 << width) - 1), 1 << (width - 1)\n    if n < 0:\n        return  (a << -n) & mask\n    elif n == 0:\n        return a\n    elif n >= width:\n        return mask if a & top_bit_mask else 0\n    else:\n        a = a & mask\n        if a & top_bit_mask:    \n            signs = (1 << n) - 1\n            return a >> n | (signs << width - n)\n        else:\n            return a >> n\n    \n      \ndef helper_funcs(width, a):\n    mask, top_bit_mask = ((1 << width) - 1), 1 << (width - 1)\n    aa = a | top_bit_mask  \n    print(f)\n\nif __name__ == '__main__':\n    bitwise_built_ins(8, 27, 125)\n    helper_funcs(8, 27)\n"}
{"id": 1168, "name": "Stem-and-leaf plot", "source": "Translate Ruby to C#: class StemLeafPlot\n  def initialize(data, options = {})\n    opts = {:leaf_digits => 1}.merge(options)\n    @leaf_digits = opts[:leaf_digits]\n    @multiplier = 10 ** @leaf_digits\n    @plot = generate_structure(data)\n  end\n\n  private\n\n  def generate_structure(data)\n    plot = Hash.new {|h,k| h[k] = []}\n    data.sort.each do |value| \n      stem, leaf = parse(value)\n      plot[stem] << leaf\n    end\n    plot\n  end\n\n  def parse(value)\n    stem, leaf = value.abs.divmod(@multiplier)\n    [Stem.get(stem, value), leaf.round]\n  end\n\n  public\n\n  def print\n    stem_width = Math.log10(@plot.keys.max_by {|s| s.value}.value).ceil + 1\n    Stem.get_range(@plot.keys).each do |stem|\n      leaves = @plot[stem].inject(\"\") {|str,leaf| str << \"%*d \" % [@leaf_digits, leaf]}\n      puts \"%*s | %s\" % [stem_width, stem, leaves]\n    end\n\n    puts \"key: 5|4=\n    puts \"leaf unit: 1\"\n    puts \"stem unit: \n  end\nend\n\nclass Stem\n  @@cache = {}\n\n  def self.get(stem_value, datum)\n    sign = datum < 0 ? :- : :+\n    cache(stem_value, sign)\n  end\n  \n  private\n  \n  def self.cache(value, sign)\n    if @@cache[[value, sign]].nil?\n      @@cache[[value, sign]] = self.new(value, sign)\n    end\n    @@cache[[value, sign]] \n  end\n\n  def initialize(value, sign)\n    @value = value\n    @sign = sign\n  end\n  \n  public \n  \n  attr_accessor :value, :sign\n  \n  def negative?\n    @sign == :-\n  end\n\n  def <=>(other)\n    if self.negative?\n      if other.negative?\n        other.value <=> self.value\n      else\n        -1\n      end\n    else\n      if other.negative?\n        1\n      else\n        self.value <=> other.value\n      end\n    end\n  end\n\n  def to_s\n    \"%s%d\" % [(self.negative? ? '-' : ' '), @value]\n  end\n  \n  def self.get_range(array_of_stems)\n    min, max = array_of_stems.minmax\n    if min.negative?\n      if max.negative?\n        min.value.downto(max.value).collect {|n| cache(n, :-)}\n      else\n        min.value.downto(0).collect {|n| cache(n, :-)} + 0.upto(max.value).collect {|n| cache(n, :+)}\n      end\n    else\n      min.value.upto(max.value).collect {|n| cache(n, :+)}\n    end\n  end\n\nend\n\ndata = DATA.read.split.map {|s| Float(s)}\nStemLeafPlot.new(data).print\n\n__END__\n12 127 28 42 39 113 42 18 44 118 44 37 113 124 37 48 127 36 29 31 125 139 131\n115 105 132 104 123 35 113 122 42 117 119 58 109 23 105 63 27 44 105 99 41 128\n121 116 125 32 61 37 127 29 113 121 58 114 126 53 114 96 25 109 7 31 141 46 13\n27 43 117 116 27 7 68 40 31 115 124 42 128 52 71 118 117 38 27 106 33 117 116\n111 40 119 47 105 57 122 109 124 115 43 120 43 27 27 18 28 48 125 107 114 34\n133 45 120 30 127 31 116 146\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Threading.Tasks;\n\nclass Program\n{\n    static void Main()\n    {\n        const string data =\n        \"12 127 28 42 39 113 42 18 44 118 44 37 113 124 37 48 127 36 29 31 \" +\n        \"125 139 131 115 105 132 104 123 35 113 122 42 117 119 58 109 23 \" +\n        \"105 63 27 44 105 99 41 128 121 116 125 32 61 37 127 29 113 121 58 \" +\n        \"114 126 53 114 96 25 109 7 31 141 46 13 27 43 117 116 27 7 68 40 31 \" +\n        \"115 124 42 128 52 71 118 117 38 27 106 33 117 116 111 40 119 47 \" +\n        \"105 57 122 109 124 115 43 120 43 27 27 18 28 48 125 107 114 34 \" +\n        \"133 45 120 30 127 31 116 146\";\n\n        int[] ints = data.Split(' ').Select(int.Parse).ToArray();\n\n        StemAndLeafPlot(ints);\n\n        Console.ReadKey();\n    }\n\n    public static void StemAndLeafPlot(int[] arr)\n    {\n        int stemMax = arr.Max() / 10;\n        int stemMin = arr.Min() / 10;\n        Array.Sort(arr);\n\n        for (int i = stemMin; i <= stemMax; i++)\n        {\n            Console.Write(\"{0,3} | \", i);\n            foreach (var t in arr)\n            {\n                if (t < 10 * i)\n                    continue;\n                if (t >= 10 * (i + 1))\n                    break;\n                Console.Write(\"{0} \", t % 10);\n            }\n            Console.WriteLine(\"\");\n        }\n    }\n}\n"}
{"id": 1170, "name": "Stem-and-leaf plot", "source": "Translate Ruby to Java: class StemLeafPlot\n  def initialize(data, options = {})\n    opts = {:leaf_digits => 1}.merge(options)\n    @leaf_digits = opts[:leaf_digits]\n    @multiplier = 10 ** @leaf_digits\n    @plot = generate_structure(data)\n  end\n\n  private\n\n  def generate_structure(data)\n    plot = Hash.new {|h,k| h[k] = []}\n    data.sort.each do |value| \n      stem, leaf = parse(value)\n      plot[stem] << leaf\n    end\n    plot\n  end\n\n  def parse(value)\n    stem, leaf = value.abs.divmod(@multiplier)\n    [Stem.get(stem, value), leaf.round]\n  end\n\n  public\n\n  def print\n    stem_width = Math.log10(@plot.keys.max_by {|s| s.value}.value).ceil + 1\n    Stem.get_range(@plot.keys).each do |stem|\n      leaves = @plot[stem].inject(\"\") {|str,leaf| str << \"%*d \" % [@leaf_digits, leaf]}\n      puts \"%*s | %s\" % [stem_width, stem, leaves]\n    end\n\n    puts \"key: 5|4=\n    puts \"leaf unit: 1\"\n    puts \"stem unit: \n  end\nend\n\nclass Stem\n  @@cache = {}\n\n  def self.get(stem_value, datum)\n    sign = datum < 0 ? :- : :+\n    cache(stem_value, sign)\n  end\n  \n  private\n  \n  def self.cache(value, sign)\n    if @@cache[[value, sign]].nil?\n      @@cache[[value, sign]] = self.new(value, sign)\n    end\n    @@cache[[value, sign]] \n  end\n\n  def initialize(value, sign)\n    @value = value\n    @sign = sign\n  end\n  \n  public \n  \n  attr_accessor :value, :sign\n  \n  def negative?\n    @sign == :-\n  end\n\n  def <=>(other)\n    if self.negative?\n      if other.negative?\n        other.value <=> self.value\n      else\n        -1\n      end\n    else\n      if other.negative?\n        1\n      else\n        self.value <=> other.value\n      end\n    end\n  end\n\n  def to_s\n    \"%s%d\" % [(self.negative? ? '-' : ' '), @value]\n  end\n  \n  def self.get_range(array_of_stems)\n    min, max = array_of_stems.minmax\n    if min.negative?\n      if max.negative?\n        min.value.downto(max.value).collect {|n| cache(n, :-)}\n      else\n        min.value.downto(0).collect {|n| cache(n, :-)} + 0.upto(max.value).collect {|n| cache(n, :+)}\n      end\n    else\n      min.value.upto(max.value).collect {|n| cache(n, :+)}\n    end\n  end\n\nend\n\ndata = DATA.read.split.map {|s| Float(s)}\nStemLeafPlot.new(data).print\n\n__END__\n12 127 28 42 39 113 42 18 44 118 44 37 113 124 37 48 127 36 29 31 125 139 131\n115 105 132 104 123 35 113 122 42 117 119 58 109 23 105 63 27 44 105 99 41 128\n121 116 125 32 61 37 127 29 113 121 58 114 126 53 114 96 25 109 7 31 141 46 13\n27 43 117 116 27 7 68 40 31 115 124 42 128 52 71 118 117 38 27 106 33 117 116\n111 40 119 47 105 57 122 109 124 115 43 120 43 27 27 18 28 48 125 107 114 34\n133 45 120 30 127 31 116 146\n", "target": "import java.util.Collections;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.TreeMap;\n\npublic class StemAndLeaf {\n\tprivate static int[] data = { 12, 127, 28, 42, 39, 113, 42, 18, 44, 118,\n\t\t\t44, 37, 113, 124, 37, 48, 127, 36, 29, 31, 125, 139, 131, 115, 105,\n\t\t\t132, 104, 123, 35, 113, 122, 42, 117, 119, 58, 109, 23, 105, 63,\n\t\t\t27, 44, 105, 99, 41, 128, 121, 116, 125, 32, 61, 37, 127, 29, 113,\n\t\t\t121, 58, 114, 126, 53, 114, 96, 25, 109, 7, 31, 141, 46, 13, 27,\n\t\t\t43, 117, 116, 27, 7, 68, 40, 31, 115, 124, 42, 128, 52, 71, 118,\n\t\t\t117, 38, 27, 106, 33, 117, 116, 111, 40, 119, 47, 105, 57, 122,\n\t\t\t109, 124, 115, 43, 120, 43, 27, 27, 18, 28, 48, 125, 107, 114, 34,\n\t\t\t133, 45, 120, 30, 127, 31, 116, 146 };\n\t\n\tpublic static Map<Integer, List<Integer>> createPlot(int... data){\n\t\tMap<Integer, List<Integer>> plot = new TreeMap<Integer, List<Integer>>();\n\t\tint highestStem = -1; \n\t\tfor(int datum:data){\n\t\t\tint leaf = datum % 10;\n\t\t\tint stem = datum / 10; \n\t\t\tif(stem > highestStem){\n\t\t\t\thighestStem = stem;\n\t\t\t}\n\t\t\tif(plot.containsKey(stem)){\n\t\t\t\tplot.get(stem).add(leaf);\n\t\t\t}else{\n\t\t\t\tLinkedList<Integer> list = new LinkedList<Integer>();\n\t\t\t\tlist.add(leaf);\n\t\t\t\tplot.put(stem, list);\n\t\t\t}\n\t\t}\n\t\tif(plot.keySet().size() < highestStem + 1  ){\n\t\t\tfor(int i = 0; i <= highestStem; i++){\n\t\t\t\tif(!plot.containsKey(i)){\n\t\t\t\t\tLinkedList<Integer> list = new LinkedList<Integer>();\n\t\t\t\t\tplot.put(i, list);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn plot;\n\t}\n\t\n\tpublic static void printPlot(Map<Integer, List<Integer>> plot){\n\t\tfor(Map.Entry<Integer, List<Integer>> line : plot.entrySet()){\n\t\t\tCollections.sort(line.getValue());\n\t\t\tSystem.out.println(line.getKey() + \" | \" + line.getValue());\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args){\n\t\tMap<Integer, List<Integer>> plot = createPlot(data);\n\t\tprintPlot(plot);\n\t}\n}\n"}
{"id": 1171, "name": "Stem-and-leaf plot", "source": "Translate Ruby to Python: class StemLeafPlot\n  def initialize(data, options = {})\n    opts = {:leaf_digits => 1}.merge(options)\n    @leaf_digits = opts[:leaf_digits]\n    @multiplier = 10 ** @leaf_digits\n    @plot = generate_structure(data)\n  end\n\n  private\n\n  def generate_structure(data)\n    plot = Hash.new {|h,k| h[k] = []}\n    data.sort.each do |value| \n      stem, leaf = parse(value)\n      plot[stem] << leaf\n    end\n    plot\n  end\n\n  def parse(value)\n    stem, leaf = value.abs.divmod(@multiplier)\n    [Stem.get(stem, value), leaf.round]\n  end\n\n  public\n\n  def print\n    stem_width = Math.log10(@plot.keys.max_by {|s| s.value}.value).ceil + 1\n    Stem.get_range(@plot.keys).each do |stem|\n      leaves = @plot[stem].inject(\"\") {|str,leaf| str << \"%*d \" % [@leaf_digits, leaf]}\n      puts \"%*s | %s\" % [stem_width, stem, leaves]\n    end\n\n    puts \"key: 5|4=\n    puts \"leaf unit: 1\"\n    puts \"stem unit: \n  end\nend\n\nclass Stem\n  @@cache = {}\n\n  def self.get(stem_value, datum)\n    sign = datum < 0 ? :- : :+\n    cache(stem_value, sign)\n  end\n  \n  private\n  \n  def self.cache(value, sign)\n    if @@cache[[value, sign]].nil?\n      @@cache[[value, sign]] = self.new(value, sign)\n    end\n    @@cache[[value, sign]] \n  end\n\n  def initialize(value, sign)\n    @value = value\n    @sign = sign\n  end\n  \n  public \n  \n  attr_accessor :value, :sign\n  \n  def negative?\n    @sign == :-\n  end\n\n  def <=>(other)\n    if self.negative?\n      if other.negative?\n        other.value <=> self.value\n      else\n        -1\n      end\n    else\n      if other.negative?\n        1\n      else\n        self.value <=> other.value\n      end\n    end\n  end\n\n  def to_s\n    \"%s%d\" % [(self.negative? ? '-' : ' '), @value]\n  end\n  \n  def self.get_range(array_of_stems)\n    min, max = array_of_stems.minmax\n    if min.negative?\n      if max.negative?\n        min.value.downto(max.value).collect {|n| cache(n, :-)}\n      else\n        min.value.downto(0).collect {|n| cache(n, :-)} + 0.upto(max.value).collect {|n| cache(n, :+)}\n      end\n    else\n      min.value.upto(max.value).collect {|n| cache(n, :+)}\n    end\n  end\n\nend\n\ndata = DATA.read.split.map {|s| Float(s)}\nStemLeafPlot.new(data).print\n\n__END__\n12 127 28 42 39 113 42 18 44 118 44 37 113 124 37 48 127 36 29 31 125 139 131\n115 105 132 104 123 35 113 122 42 117 119 58 109 23 105 63 27 44 105 99 41 128\n121 116 125 32 61 37 127 29 113 121 58 114 126 53 114 96 25 109 7 31 141 46 13\n27 43 117 116 27 7 68 40 31 115 124 42 128 52 71 118 117 38 27 106 33 117 116\n111 40 119 47 105 57 122 109 124 115 43 120 43 27 27 18 28 48 125 107 114 34\n133 45 120 30 127 31 116 146\n", "target": "from collections import namedtuple\nfrom pprint import pprint as pp\nfrom math import floor\n\nStem = namedtuple('Stem', 'data, leafdigits')\n\ndata0 = Stem((12, 127, 28, 42, 39, 113, 42, 18, 44, 118, 44, 37, 113, 124, 37,\n              48, 127, 36, 29, 31, 125, 139, 131, 115, 105, 132, 104, 123, 35,\n              113, 122, 42, 117, 119, 58, 109, 23, 105, 63, 27, 44, 105, 99,\n              41, 128, 121, 116, 125, 32, 61, 37, 127, 29, 113, 121, 58, 114,\n              126, 53, 114, 96, 25, 109, 7, 31, 141, 46, 13, 27, 43, 117, 116,\n              27, 7, 68, 40, 31, 115, 124, 42, 128, 52, 71, 118, 117, 38, 27,\n              106, 33, 117, 116, 111, 40, 119, 47, 105, 57, 122, 109, 124, 115,\n              43, 120, 43, 27, 27, 18, 28, 48, 125, 107, 114, 34, 133, 45, 120,\n              30, 127, 31, 116, 146),\n             1.0)\n\ndef stemplot(stem):\n    d = []\n    interval = int(10**int(stem.leafdigits))\n    for data in sorted(stem.data):\n        data = int(floor(data))\n        stm, lf = divmod(data,interval)\n        d.append( (int(stm), int(lf)) )\n    stems, leafs = list(zip(*d))\n    stemwidth = max(len(str(x)) for x in stems)\n    leafwidth = max(len(str(x)) for x in leafs)\n    laststem, out = min(stems) - 1, []\n    for s,l in d:\n        while laststem < s:\n            laststem += 1\n            out.append('\\n%*i |' % ( stemwidth, laststem))\n        out.append(' %0*i' % (leafwidth, l))\n    out.append('\\n\\nKey:\\n Stem multiplier: %i\\n X | Y  =>  %i*X+Y\\n'\n               % (interval, interval))\n    return ''.join(out)\n\nif __name__ == '__main__':\n    print( stemplot(data0) )\n"}
{"id": 1536, "name": "Flatten a list", "source": "Translate Ruby to C#: [[1], 2, [[3, 4], 5], [[[] of Int32]], [[[6]]], 7, 8, [] of Int32].flatten()\n", "target": "using System;\nusing System.Collections;\nusing System.Linq;\n\nnamespace RosettaCodeTasks\n{\n\tstatic class FlattenList\n\t{\n\t\tpublic static ArrayList Flatten(this ArrayList List)\n\t\t{\n\t\t\tArrayList NewList = new ArrayList ( );\n\n\t\t\tNewList.AddRange ( List );\n\n\t\t\twhile ( NewList.OfType<ArrayList> ( ).Count ( ) > 0 )\n\t\t\t{\n\t\t\t\tint index = NewList.IndexOf ( NewList.OfType<ArrayList> ( ).ElementAt ( 0 ) );\n\t\t\t\tArrayList Temp = (ArrayList)NewList[index];\n\t\t\t\tNewList.RemoveAt ( index );\n\t\t\t\tNewList.InsertRange ( index, Temp );\n\t\t\t}\n\t\t\t\n\t\t\treturn NewList;\n\t\t}\n\t}\n}\n"}
{"id": 1537, "name": "Flatten a list", "source": "Translate Ruby to C#: [[1], 2, [[3, 4], 5], [[[] of Int32]], [[[6]]], 7, 8, [] of Int32].flatten()\n", "target": "using System;\nusing System.Collections;\nusing System.Linq;\n\nnamespace RosettaCodeTasks\n{\n\tstatic class FlattenList\n\t{\n\t\tpublic static ArrayList Flatten(this ArrayList List)\n\t\t{\n\t\t\tArrayList NewList = new ArrayList ( );\n\n\t\t\tNewList.AddRange ( List );\n\n\t\t\twhile ( NewList.OfType<ArrayList> ( ).Count ( ) > 0 )\n\t\t\t{\n\t\t\t\tint index = NewList.IndexOf ( NewList.OfType<ArrayList> ( ).ElementAt ( 0 ) );\n\t\t\t\tArrayList Temp = (ArrayList)NewList[index];\n\t\t\t\tNewList.RemoveAt ( index );\n\t\t\t\tNewList.InsertRange ( index, Temp );\n\t\t\t}\n\t\t\t\n\t\t\treturn NewList;\n\t\t}\n\t}\n}\n"}
{"id": 1540, "name": "Flatten a list", "source": "Translate Ruby to Java: [[1], 2, [[3, 4], 5], [[[] of Int32]], [[[6]]], 7, 8, [] of Int32].flatten()\n", "target": "import java.util.LinkedList;\nimport java.util.List;\n\n\npublic final class FlattenUtil {\n\n\tpublic static List<Object> flatten(List<?> list) {\n\t\tList<Object> retVal = new LinkedList<Object>();\n\t\tflatten(list, retVal);\n\t\treturn retVal;\n\t}\n\n\tpublic static void flatten(List<?> fromTreeList, List<Object> toFlatList) {\n\t\tfor (Object item : fromTreeList) {\n\t\t\tif (item instanceof List<?>) {\n\t\t\t\tflatten((List<?>) item, toFlatList);\n\t\t\t} else {\n\t\t\t\ttoFlatList.add(item);\n\t\t\t}\n\t\t}\n\t}\n}\n"}
{"id": 1541, "name": "Flatten a list", "source": "Translate Ruby to Java: [[1], 2, [[3, 4], 5], [[[] of Int32]], [[[6]]], 7, 8, [] of Int32].flatten()\n", "target": "import java.util.LinkedList;\nimport java.util.List;\n\n\npublic final class FlattenUtil {\n\n\tpublic static List<Object> flatten(List<?> list) {\n\t\tList<Object> retVal = new LinkedList<Object>();\n\t\tflatten(list, retVal);\n\t\treturn retVal;\n\t}\n\n\tpublic static void flatten(List<?> fromTreeList, List<Object> toFlatList) {\n\t\tfor (Object item : fromTreeList) {\n\t\t\tif (item instanceof List<?>) {\n\t\t\t\tflatten((List<?>) item, toFlatList);\n\t\t\t} else {\n\t\t\t\ttoFlatList.add(item);\n\t\t\t}\n\t\t}\n\t}\n}\n"}
{"id": 1542, "name": "Flatten a list", "source": "Translate Ruby to Python: [[1], 2, [[3, 4], 5], [[[] of Int32]], [[[6]]], 7, 8, [] of Int32].flatten()\n", "target": ">>> def flatten(lst):\n\treturn sum( ([x] if not isinstance(x, list) else flatten(x)\n\t\t     for x in lst), [] )\n\n>>> lst = [[1], 2, [[3,4], 5], [[[]]], [[[6]]], 7, 8, []]\n>>> flatten(lst)\n[1, 2, 3, 4, 5, 6, 7, 8]\n"}
{"id": 1543, "name": "Flatten a list", "source": "Translate Ruby to Python: [[1], 2, [[3, 4], 5], [[[] of Int32]], [[[6]]], 7, 8, [] of Int32].flatten()\n", "target": ">>> def flatten(lst):\n\treturn sum( ([x] if not isinstance(x, list) else flatten(x)\n\t\t     for x in lst), [] )\n\n>>> lst = [[1], 2, [[3,4], 5], [[[]]], [[[6]]], 7, 8, []]\n>>> flatten(lst)\n[1, 2, 3, 4, 5, 6, 7, 8]\n"}
{"id": 1828, "name": "Calendar", "source": "Translate Ruby to C#: require 'date'\n\n\n\ndef cal(year, columns)\n\n  \n  \n  \n  \n  \n  \n  date = Date.new(year, 1, 1, Date::ENGLAND)\n\n  \n  months = (1..12).collect do |month|\n    rows = [Date::MONTHNAMES[month].center(20), \"Su Mo Tu We Th Fr Sa\"]\n\n    \n    days = []\n    date.wday.times { days.push \"  \" }\n    while date.month == month\n      days.push(\"%2d\" % date.mday)\n      date += 1\n    end\n    (42 - days.length).times { days.push \"  \" }\n\n    days.each_slice(7) { |week| rows.push(week.join \" \") }\n    next rows\n  end\n\n  \n  \n  \n  \n  \n  \n  mpr = (columns + 2).div 22\n  mpr = 12.div((12 + mpr - 1).div mpr)\n\n  \n  width = mpr * 22 - 2\n\n  \n  rows = [\"[Snoopy]\".center(width), \"\n  months.each_slice(mpr) do |slice|\n    slice[0].each_index do |i|\n      rows.push(slice.map {|a| a[i]}.join \"  \")\n    end\n  end\n  return rows.join(\"\\n\")\nend\n\n\nARGV.length == 1 or abort \"usage: \n\n\n\n\n\n\ncolumns = begin Integer(ENV[\"COLUMNS\"] || \"\")\n          rescue\n            begin require 'io/console'; IO.console.winsize[1]\n            rescue LoadError\n              begin Integer(`tput cols`)\n              rescue\n                80; end; end; end\n\nputs cal(Integer(ARGV[0]), columns)\n", "target": "using System;\nusing System.Collections.Generic; \nusing System.Linq;\nusing System.Text;\n\nnamespace CalendarStuff\n{\n \n    class Program\n    {\n        static void Main(string[] args)\n        {\n            Console.WindowHeight = 46;\n            Console.Write(buildMonths(new DateTime(1969, 1, 1)));\n            Console.Read(); \n        }\n        private static string buildMonths(DateTime date)\n        {\n            StringBuilder sb = new StringBuilder();\n            sb.AppendLine(center(\"[Snoop]\", 24 * 3));\n            sb.AppendLine();\n            sb.AppendLine(center(date.Year.ToString(), 24 * 3));\n\n            List<DateTime> dts = new List<DateTime>();\n            while (true)\n            {\n                dts.Add(date);\n                if (date.Year != ((date = date.AddMonths(1)).Year))\n                {\n                    break;\n                }\n            }\n            var jd = dts.Select(a => buildMonth(a).GetEnumerator()).ToArray();\n            \n            int sCur=0;\n            while (sCur<dts.Count)\n            {\n                sb.AppendLine();\n                int curMonth=0; \n                var j = jd.Where(a => curMonth++ >= sCur && curMonth - 1 < sCur + 3).ToArray(); \n                sCur += j.Length; \n                bool breakOut = false;\n                while (!breakOut)\n                {\n                    int inj = 1;\n                    foreach (var cd in j)\n                    {\n                        if (cd.MoveNext())\n                        {\n                            sb.Append((cd.Current.Length == 21 ? cd.Current : cd.Current.PadRight(21, ' ')) + \"     \");\n                        }\n                        else\n                        {\n                            sb.Append(\"\".PadRight(21, ' ') + \"     \");\n                            breakOut = true;\n                        }\n                        if (inj++ % 3 == 0) sb.AppendLine();\n                    }\n                }\n\n            }\n            return sb.ToString();\n        }\n\n\n        private static IEnumerable<string> buildMonth(DateTime date)\n        {\n            yield return center(date.ToString(\"MMMM\"),7*3);\n            var j = DateTime.DaysInMonth(date.Year, date.Month);\n            yield return Enum.GetNames(typeof(DayOfWeek)).Aggregate(\"\", (current, result) => current + (result.Substring(0, 2).ToUpper() + \" \"));\n            string cur = \"\";\n            int total = 0;\n\n            foreach (var day in Enumerable.Range(-((int)date.DayOfWeek),j + (int)date.DayOfWeek))\n            {\n                cur += (day < 0 ? \"  \" : ((day < 9 ? \" \" : \"\") + (day + 1))) +\" \";\n                if (total++ > 0 && (total ) % 7 == 0)\n                {\n                    yield return cur;\n                    cur = \"\";\n                }\n            }\n            yield return cur;\n        }\n        private static string center(string s, int len)\n        {\n            return (s.PadLeft((len - s.Length) / 2 + s.Length, ' ').PadRight((len), ' '));\n        } \n    }\n}\n"}
{"id": 1830, "name": "Calendar", "source": "Translate Ruby to Java: require 'date'\n\n\n\ndef cal(year, columns)\n\n  \n  \n  \n  \n  \n  \n  date = Date.new(year, 1, 1, Date::ENGLAND)\n\n  \n  months = (1..12).collect do |month|\n    rows = [Date::MONTHNAMES[month].center(20), \"Su Mo Tu We Th Fr Sa\"]\n\n    \n    days = []\n    date.wday.times { days.push \"  \" }\n    while date.month == month\n      days.push(\"%2d\" % date.mday)\n      date += 1\n    end\n    (42 - days.length).times { days.push \"  \" }\n\n    days.each_slice(7) { |week| rows.push(week.join \" \") }\n    next rows\n  end\n\n  \n  \n  \n  \n  \n  \n  mpr = (columns + 2).div 22\n  mpr = 12.div((12 + mpr - 1).div mpr)\n\n  \n  width = mpr * 22 - 2\n\n  \n  rows = [\"[Snoopy]\".center(width), \"\n  months.each_slice(mpr) do |slice|\n    slice[0].each_index do |i|\n      rows.push(slice.map {|a| a[i]}.join \"  \")\n    end\n  end\n  return rows.join(\"\\n\")\nend\n\n\nARGV.length == 1 or abort \"usage: \n\n\n\n\n\n\ncolumns = begin Integer(ENV[\"COLUMNS\"] || \"\")\n          rescue\n            begin require 'io/console'; IO.console.winsize[1]\n            rescue LoadError\n              begin Integer(`tput cols`)\n              rescue\n                80; end; end; end\n\nputs cal(Integer(ARGV[0]), columns)\n", "target": "import java.text.*;\nimport java.util.*;\n\npublic class CalendarTask {\n\n    public static void main(String[] args) {\n        printCalendar(1969, 3);\n    }\n\n    static void printCalendar(int year, int nCols) {\n        if (nCols < 1 || nCols > 12)\n            throw new IllegalArgumentException(\"Illegal column width.\");\n\n        Calendar date = new GregorianCalendar(year, 0, 1);\n\n        int nRows = (int) Math.ceil(12.0 / nCols);\n        int offs = date.get(Calendar.DAY_OF_WEEK) - 1;\n        int w = nCols * 24;\n\n        String[] monthNames = new DateFormatSymbols(Locale.US).getMonths();\n\n        String[][] mons = new String[12][8];\n        for (int m = 0; m < 12; m++) {\n\n            String name = monthNames[m];\n            int len = 11 + name.length() / 2;\n            String format = MessageFormat.format(\"%{0}s%{1}s\", len, 21 - len);\n\n            mons[m][0] = String.format(format, name, \"\");\n            mons[m][1] = \" Su Mo Tu We Th Fr Sa\";\n            int dim = date.getActualMaximum(Calendar.DAY_OF_MONTH);\n\n            for (int d = 1; d < 43; d++) {\n                boolean isDay = d > offs && d <= offs + dim;\n                String entry = isDay ? String.format(\" %2s\", d - offs) : \"   \";\n                if (d % 7 == 1)\n                    mons[m][2 + (d - 1) / 7] = entry;\n                else\n                    mons[m][2 + (d - 1) / 7] += entry;\n            }\n            offs = (offs + dim) % 7;\n            date.add(Calendar.MONTH, 1);\n        }\n\n        System.out.printf(\"%\" + (w / 2 + 10) + \"s%n\", \"[Snoopy Picture]\");\n        System.out.printf(\"%\" + (w / 2 + 4) + \"s%n%n\", year);\n\n        for (int r = 0; r < nRows; r++) {\n            for (int i = 0; i < 8; i++) {\n                for (int c = r * nCols; c < (r + 1) * nCols && c < 12; c++)\n                    System.out.printf(\"   %s\", mons[c][i]);\n                System.out.println();\n            }\n            System.out.println();\n        }\n    }\n}\n"}
{"id": 1831, "name": "Calendar", "source": "Translate Ruby to Python: require 'date'\n\n\n\ndef cal(year, columns)\n\n  \n  \n  \n  \n  \n  \n  date = Date.new(year, 1, 1, Date::ENGLAND)\n\n  \n  months = (1..12).collect do |month|\n    rows = [Date::MONTHNAMES[month].center(20), \"Su Mo Tu We Th Fr Sa\"]\n\n    \n    days = []\n    date.wday.times { days.push \"  \" }\n    while date.month == month\n      days.push(\"%2d\" % date.mday)\n      date += 1\n    end\n    (42 - days.length).times { days.push \"  \" }\n\n    days.each_slice(7) { |week| rows.push(week.join \" \") }\n    next rows\n  end\n\n  \n  \n  \n  \n  \n  \n  mpr = (columns + 2).div 22\n  mpr = 12.div((12 + mpr - 1).div mpr)\n\n  \n  width = mpr * 22 - 2\n\n  \n  rows = [\"[Snoopy]\".center(width), \"\n  months.each_slice(mpr) do |slice|\n    slice[0].each_index do |i|\n      rows.push(slice.map {|a| a[i]}.join \"  \")\n    end\n  end\n  return rows.join(\"\\n\")\nend\n\n\nARGV.length == 1 or abort \"usage: \n\n\n\n\n\n\ncolumns = begin Integer(ENV[\"COLUMNS\"] || \"\")\n          rescue\n            begin require 'io/console'; IO.console.winsize[1]\n            rescue LoadError\n              begin Integer(`tput cols`)\n              rescue\n                80; end; end; end\n\nputs cal(Integer(ARGV[0]), columns)\n", "target": ">>> import calendar\n>>> help(calendar.prcal)\nHelp on method pryear in module calendar:\n\npryear(self, theyear, w=0, l=0, c=6, m=3) method of calendar.TextCalendar instance\n    Print a years calendar.\n\n>>> calendar.prcal(1969)\n                                  1969\n\n      January                   February                   March\nMo Tu We Th Fr Sa Su      Mo Tu We Th Fr Sa Su      Mo Tu We Th Fr Sa Su\n       1  2  3  4  5                      1  2                      1  2\n 6  7  8  9 10 11 12       3  4  5  6  7  8  9       3  4  5  6  7  8  9\n13 14 15 16 17 18 19      10 11 12 13 14 15 16      10 11 12 13 14 15 16\n20 21 22 23 24 25 26      17 18 19 20 21 22 23      17 18 19 20 21 22 23\n27 28 29 30 31            24 25 26 27 28            24 25 26 27 28 29 30\n                                                    31\n\n       April                      May                       June\nMo Tu We Th Fr Sa Su      Mo Tu We Th Fr Sa Su      Mo Tu We Th Fr Sa Su\n    1  2  3  4  5  6                1  2  3  4                         1\n 7  8  9 10 11 12 13       5  6  7  8  9 10 11       2  3  4  5  6  7  8\n14 15 16 17 18 19 20      12 13 14 15 16 17 18       9 10 11 12 13 14 15\n21 22 23 24 25 26 27      19 20 21 22 23 24 25      16 17 18 19 20 21 22\n28 29 30                  26 27 28 29 30 31         23 24 25 26 27 28 29\n                                                    30\n\n        July                     August                  September\nMo Tu We Th Fr Sa Su      Mo Tu We Th Fr Sa Su      Mo Tu We Th Fr Sa Su\n    1  2  3  4  5  6                   1  2  3       1  2  3  4  5  6  7\n 7  8  9 10 11 12 13       4  5  6  7  8  9 10       8  9 10 11 12 13 14\n14 15 16 17 18 19 20      11 12 13 14 15 16 17      15 16 17 18 19 20 21\n21 22 23 24 25 26 27      18 19 20 21 22 23 24      22 23 24 25 26 27 28\n28 29 30 31               25 26 27 28 29 30 31      29 30\n\n      October                   November                  December\nMo Tu We Th Fr Sa Su      Mo Tu We Th Fr Sa Su      Mo Tu We Th Fr Sa Su\n       1  2  3  4  5                      1  2       1  2  3  4  5  6  7\n 6  7  8  9 10 11 12       3  4  5  6  7  8  9       8  9 10 11 12 13 14\n13 14 15 16 17 18 19      10 11 12 13 14 15 16      15 16 17 18 19 20 21\n20 21 22 23 24 25 26      17 18 19 20 21 22 23      22 23 24 25 26 27 28\n27 28 29 30 31            24 25 26 27 28 29 30      29 30 31\n"}
{"id": 2043, "name": "Permutations_Derangements", "source": "Translate Ruby to C#: def derangements(n)\n  ary = (1 .. n).to_a\n  ary.permutation.select do |perm|\n    ary.zip(perm).all? {|a,b| a != b}\n  end\nend\n\ndef subfact(n)\n  case n\n  when 0 then 1\n  when 1 then 0\n  else (n-1)*(subfact(n-1) + subfact(n-2))\n  end\nend\n\nputs \"derangements for n = 4\"\nderangements(4).each{|d|p d}\n\nputs \"\\n n   derange  subfact\"\n(0..9).each do |n|\n  puts \"%2d\u00a0:%8d,%8d\" % [n, derangements(n).size, subfact(n)]\nend\n\nputs \"\\nNumber of derangements\"\n(10..20).each do |n|\n  puts \"\nend\n", "target": "using System;\nclass Derangements\n{\n  static int n = 4;\n  static int [] buf = new int [n];\n  static bool [] used = new bool [n];\n\n  static void Main()\n  {\n    for (int i = 0; i < n; i++) used [i] = false;\n    rec(0);\n  }\n\n  static void rec(int ind)\n  {\n    for (int i = 0; i < n; i++)\n    {\n      if (!used [i] && i != ind)\n      {\n        used [i] = true;\n        buf [ind] = i;\n\tif (ind + 1 < n) rec(ind + 1);\n        else Console.WriteLine(string.Join(\",\", buf));\n\tused [i] = false;\n      }\n    }\n  }\n}\n"}
{"id": 2044, "name": "Permutations_Derangements", "source": "Translate Ruby to C#: def derangements(n)\n  ary = (1 .. n).to_a\n  ary.permutation.select do |perm|\n    ary.zip(perm).all? {|a,b| a != b}\n  end\nend\n\ndef subfact(n)\n  case n\n  when 0 then 1\n  when 1 then 0\n  else (n-1)*(subfact(n-1) + subfact(n-2))\n  end\nend\n\nputs \"derangements for n = 4\"\nderangements(4).each{|d|p d}\n\nputs \"\\n n   derange  subfact\"\n(0..9).each do |n|\n  puts \"%2d\u00a0:%8d,%8d\" % [n, derangements(n).size, subfact(n)]\nend\n\nputs \"\\nNumber of derangements\"\n(10..20).each do |n|\n  puts \"\nend\n", "target": "using System;\nclass Derangements\n{\n  static int n = 4;\n  static int [] buf = new int [n];\n  static bool [] used = new bool [n];\n\n  static void Main()\n  {\n    for (int i = 0; i < n; i++) used [i] = false;\n    rec(0);\n  }\n\n  static void rec(int ind)\n  {\n    for (int i = 0; i < n; i++)\n    {\n      if (!used [i] && i != ind)\n      {\n        used [i] = true;\n        buf [ind] = i;\n\tif (ind + 1 < n) rec(ind + 1);\n        else Console.WriteLine(string.Join(\",\", buf));\n\tused [i] = false;\n      }\n    }\n  }\n}\n"}
{"id": 2045, "name": "Permutations_Derangements", "source": "Translate Ruby to Java: def derangements(n)\n  ary = (1 .. n).to_a\n  ary.permutation.select do |perm|\n    ary.zip(perm).all? {|a,b| a != b}\n  end\nend\n\ndef subfact(n)\n  case n\n  when 0 then 1\n  when 1 then 0\n  else (n-1)*(subfact(n-1) + subfact(n-2))\n  end\nend\n\nputs \"derangements for n = 4\"\nderangements(4).each{|d|p d}\n\nputs \"\\n n   derange  subfact\"\n(0..9).each do |n|\n  puts \"%2d\u00a0:%8d,%8d\" % [n, derangements(n).size, subfact(n)]\nend\n\nputs \"\\nNumber of derangements\"\n(10..20).each do |n|\n  puts \"\nend\n", "target": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\n\npublic class Derangement {\n\n    public static void main(String[] args) {\n        System.out.println(\"derangements for n = 4\\n\");\n        for (Object d  : (ArrayList)(derangements(4, false)[0])) {\n            System.out.println(Arrays.toString((int[])d));\n        }\n        \n        System.out.println(\"\\ntable of n vs counted vs calculated derangements\\n\");\n        for (int i = 0; i < 10; i++) {\n            int d = ((Integer)derangements(i, true)[1]).intValue();\n            System.out.printf(\"%d \u00a0%-7d\u00a0%-7d\\n\", i, d, subfact(i));\n        }\n        \n        System.out.printf (\"\\n!20 = %20d\\n\", subfact(20L));\n    }\n\n    static Object[] derangements(int n, boolean countOnly) {\n        int[] seq = iota(n);\n        int[] ori = Arrays.copyOf(seq, n);\n        long tot = fact(n);\n\n        List<int[]> all = new ArrayList<int[]>();\n        int cnt = n == 0 ? 1 : 0;\n\n        while (--tot > 0) {\n            int j = n - 2;\n            while (seq[j] > seq[j + 1]) {\n                j--;\n            }\n            int k = n - 1;\n            while (seq[j] > seq[k]) {\n                k--;\n            }\n            swap(seq, k, j);\n\n            int r = n - 1;\n            int s = j + 1;\n            while (r > s) {\n                swap(seq, s, r);\n                r--;\n                s++;\n            }\n\n            j = 0;\n            while (j < n && seq[j] != ori[j]) {\n                j++;\n            }\n            if (j == n) {\n                if (countOnly) {\n                    cnt++;\n                } else {\n                    all.add(Arrays.copyOf(seq, n));\n                }\n            }\n        }\n        return new Object[]{all, cnt};\n    }\n\n    static long fact(long n) {\n        long result = 1;\n        for (long i = 2; i <= n; i++) {\n            result *= i;\n        }\n        return result;\n    }\n\n    static long subfact(long n) {\n        if (0 <= n && n <= 2) {\n            return n != 1 ? 1 : 0;\n        }\n        return (n - 1) * (subfact(n - 1) + subfact(n - 2));\n    }\n\n    static void swap(int[] arr, int lhs, int rhs) {\n        int tmp = arr[lhs];\n        arr[lhs] = arr[rhs];\n        arr[rhs] = tmp;\n    }\n\n    static int[] iota(int n) {\n        if (n < 0) {\n            throw new IllegalArgumentException(\"iota cannot accept < 0\");\n        }\n        int[] r = new int[n];\n        for (int i = 0; i < n; i++) {\n            r[i] = i;\n        }\n        return r;\n    }\n}\n"}
{"id": 2046, "name": "Permutations_Derangements", "source": "Translate Ruby to Java: def derangements(n)\n  ary = (1 .. n).to_a\n  ary.permutation.select do |perm|\n    ary.zip(perm).all? {|a,b| a != b}\n  end\nend\n\ndef subfact(n)\n  case n\n  when 0 then 1\n  when 1 then 0\n  else (n-1)*(subfact(n-1) + subfact(n-2))\n  end\nend\n\nputs \"derangements for n = 4\"\nderangements(4).each{|d|p d}\n\nputs \"\\n n   derange  subfact\"\n(0..9).each do |n|\n  puts \"%2d\u00a0:%8d,%8d\" % [n, derangements(n).size, subfact(n)]\nend\n\nputs \"\\nNumber of derangements\"\n(10..20).each do |n|\n  puts \"\nend\n", "target": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\n\npublic class Derangement {\n\n    public static void main(String[] args) {\n        System.out.println(\"derangements for n = 4\\n\");\n        for (Object d  : (ArrayList)(derangements(4, false)[0])) {\n            System.out.println(Arrays.toString((int[])d));\n        }\n        \n        System.out.println(\"\\ntable of n vs counted vs calculated derangements\\n\");\n        for (int i = 0; i < 10; i++) {\n            int d = ((Integer)derangements(i, true)[1]).intValue();\n            System.out.printf(\"%d \u00a0%-7d\u00a0%-7d\\n\", i, d, subfact(i));\n        }\n        \n        System.out.printf (\"\\n!20 = %20d\\n\", subfact(20L));\n    }\n\n    static Object[] derangements(int n, boolean countOnly) {\n        int[] seq = iota(n);\n        int[] ori = Arrays.copyOf(seq, n);\n        long tot = fact(n);\n\n        List<int[]> all = new ArrayList<int[]>();\n        int cnt = n == 0 ? 1 : 0;\n\n        while (--tot > 0) {\n            int j = n - 2;\n            while (seq[j] > seq[j + 1]) {\n                j--;\n            }\n            int k = n - 1;\n            while (seq[j] > seq[k]) {\n                k--;\n            }\n            swap(seq, k, j);\n\n            int r = n - 1;\n            int s = j + 1;\n            while (r > s) {\n                swap(seq, s, r);\n                r--;\n                s++;\n            }\n\n            j = 0;\n            while (j < n && seq[j] != ori[j]) {\n                j++;\n            }\n            if (j == n) {\n                if (countOnly) {\n                    cnt++;\n                } else {\n                    all.add(Arrays.copyOf(seq, n));\n                }\n            }\n        }\n        return new Object[]{all, cnt};\n    }\n\n    static long fact(long n) {\n        long result = 1;\n        for (long i = 2; i <= n; i++) {\n            result *= i;\n        }\n        return result;\n    }\n\n    static long subfact(long n) {\n        if (0 <= n && n <= 2) {\n            return n != 1 ? 1 : 0;\n        }\n        return (n - 1) * (subfact(n - 1) + subfact(n - 2));\n    }\n\n    static void swap(int[] arr, int lhs, int rhs) {\n        int tmp = arr[lhs];\n        arr[lhs] = arr[rhs];\n        arr[rhs] = tmp;\n    }\n\n    static int[] iota(int n) {\n        if (n < 0) {\n            throw new IllegalArgumentException(\"iota cannot accept < 0\");\n        }\n        int[] r = new int[n];\n        for (int i = 0; i < n; i++) {\n            r[i] = i;\n        }\n        return r;\n    }\n}\n"}
{"id": 2047, "name": "Permutations_Derangements", "source": "Translate Ruby to Python: def derangements(n)\n  ary = (1 .. n).to_a\n  ary.permutation.select do |perm|\n    ary.zip(perm).all? {|a,b| a != b}\n  end\nend\n\ndef subfact(n)\n  case n\n  when 0 then 1\n  when 1 then 0\n  else (n-1)*(subfact(n-1) + subfact(n-2))\n  end\nend\n\nputs \"derangements for n = 4\"\nderangements(4).each{|d|p d}\n\nputs \"\\n n   derange  subfact\"\n(0..9).each do |n|\n  puts \"%2d\u00a0:%8d,%8d\" % [n, derangements(n).size, subfact(n)]\nend\n\nputs \"\\nNumber of derangements\"\n(10..20).each do |n|\n  puts \"\nend\n", "target": "from itertools import permutations\nimport math\n\n\ndef derangements(n):\n    'All deranged permutations of the integers 0..n-1 inclusive'\n    return ( perm for perm in permutations(range(n))\n             if all(indx != p for indx, p in enumerate(perm)) )\n\ndef subfact(n):\n    if n == 2 or n == 0:\n        return 1\n    elif n == 1:\n        return 0\n    elif  1 <= n <=18:\n        return round(math.factorial(n) / math.e)\n    elif n.imag == 0 and n.real == int(n.real) and n > 0:\n        return (n-1) * ( subfact(n - 1) + subfact(n - 2) )\n    else:\n        raise ValueError()\n\ndef _iterlen(iter):\n    'length of an iterator without taking much memory'\n    l = 0\n    for x in iter:\n        l += 1\n    return l\n\nif __name__ == '__main__':\n    n = 4\n    print(\"Derangements of %s\" % (tuple(range(n)),))\n    for d in derangements(n):\n        print(\"  %s\" % (d,))\n\n    print(\"\\nTable of n vs counted vs calculated derangements\")\n    for n in range(10):\n        print(\"%2i %-5i %-5i\" %\n              (n, _iterlen(derangements(n)), subfact(n)))\n\n    n = 20\n    print(\"\\n!%i = %i\" % (n, subfact(n)))\n"}
{"id": 2048, "name": "Permutations_Derangements", "source": "Translate Ruby to Python: def derangements(n)\n  ary = (1 .. n).to_a\n  ary.permutation.select do |perm|\n    ary.zip(perm).all? {|a,b| a != b}\n  end\nend\n\ndef subfact(n)\n  case n\n  when 0 then 1\n  when 1 then 0\n  else (n-1)*(subfact(n-1) + subfact(n-2))\n  end\nend\n\nputs \"derangements for n = 4\"\nderangements(4).each{|d|p d}\n\nputs \"\\n n   derange  subfact\"\n(0..9).each do |n|\n  puts \"%2d\u00a0:%8d,%8d\" % [n, derangements(n).size, subfact(n)]\nend\n\nputs \"\\nNumber of derangements\"\n(10..20).each do |n|\n  puts \"\nend\n", "target": "from itertools import permutations\nimport math\n\n\ndef derangements(n):\n    'All deranged permutations of the integers 0..n-1 inclusive'\n    return ( perm for perm in permutations(range(n))\n             if all(indx != p for indx, p in enumerate(perm)) )\n\ndef subfact(n):\n    if n == 2 or n == 0:\n        return 1\n    elif n == 1:\n        return 0\n    elif  1 <= n <=18:\n        return round(math.factorial(n) / math.e)\n    elif n.imag == 0 and n.real == int(n.real) and n > 0:\n        return (n-1) * ( subfact(n - 1) + subfact(n - 2) )\n    else:\n        raise ValueError()\n\ndef _iterlen(iter):\n    'length of an iterator without taking much memory'\n    l = 0\n    for x in iter:\n        l += 1\n    return l\n\nif __name__ == '__main__':\n    n = 4\n    print(\"Derangements of %s\" % (tuple(range(n)),))\n    for d in derangements(n):\n        print(\"  %s\" % (d,))\n\n    print(\"\\nTable of n vs counted vs calculated derangements\")\n    for n in range(10):\n        print(\"%2i %-5i %-5i\" %\n              (n, _iterlen(derangements(n)), subfact(n)))\n\n    n = 20\n    print(\"\\n!%i = %i\" % (n, subfact(n)))\n"}
{"id": 2254, "name": "String interpolation (included)", "source": "Translate Ruby to C#: irb(main):001:0> extra = 'little'\n=> \"little\"\nirb(main):002:0> \"Mary had a \n=> \"Mary had a little lamb.\"\nirb(main):003:0> \"Mary had a %s lamb.\" % extra\n=> \"Mary had a little lamb.\"\n", "target": "class Program\n{\n    static void Main()\n    {\n        string extra = \"little\";\n        string formatted = $\"Mary had a {extra} lamb.\";\n        System.Console.WriteLine(formatted);\n    }\n}\n"}
{"id": 2256, "name": "String interpolation (included)", "source": "Translate Ruby to Java: irb(main):001:0> extra = 'little'\n=> \"little\"\nirb(main):002:0> \"Mary had a \n=> \"Mary had a little lamb.\"\nirb(main):003:0> \"Mary had a %s lamb.\" % extra\n=> \"Mary had a little lamb.\"\n", "target": "String original = \"Mary had a X lamb\";\nString little = \"little\";\nString replaced = original.replace(\"X\", little); \nSystem.out.println(replaced);\n\nSystem.out.printf(\"Mary had a %s lamb.\", little);\n\nString formatted = String.format(\"Mary had a %s lamb.\", little);\nSystem.out.println(formatted);\n"}
{"id": 2257, "name": "String interpolation (included)", "source": "Translate Ruby to Python: irb(main):001:0> extra = 'little'\n=> \"little\"\nirb(main):002:0> \"Mary had a \n=> \"Mary had a little lamb.\"\nirb(main):003:0> \"Mary had a %s lamb.\" % extra\n=> \"Mary had a little lamb.\"\n", "target": ">>> original = 'Mary had a %s lamb.'\n>>> extra = 'little'\n>>> original % extra\n'Mary had a little lamb.'\n"}
{"id": 2711, "name": "Babbage problem", "source": "Translate Ruby to C#: n = 0\nn = n + 2 until (n*n).modulo(1000000) == 269696 \nprint n\n", "target": "namespace Babbage_Problem\n{\n    class iterateNumbers\n    {\n        public iterateNumbers()\n        {\n            long baseNumberSquared = 0; \n            long baseNumber = 0;  \n\n            do  \n            {\n                baseNumber += 1; \n                baseNumberSquared = baseNumber * baseNumber; \n            }\n            while (Right6Digits(baseNumberSquared) != 269696); \n\n            Console.WriteLine(\"The smallest integer whose square ends in 269,696 is \" + baseNumber);\n            Console.WriteLine(\"The square is \" + baseNumberSquared);\n\n        }\n\n        private long Right6Digits(long baseNumberSquared)\n        {\n\n            string numberAsString = baseNumberSquared.ToString(); \n\n            if (numberAsString.Length < 6) { return baseNumberSquared; }; \n\n            numberAsString = numberAsString.Substring(numberAsString.Length - 6);  \n\n            return long.Parse(numberAsString); \n\n        }\n    }\n}}\n"}
{"id": 2712, "name": "Babbage problem", "source": "Translate Ruby to C#: n = 0\nn = n + 2 until (n*n).modulo(1000000) == 269696 \nprint n\n", "target": "namespace Babbage_Problem\n{\n    class iterateNumbers\n    {\n        public iterateNumbers()\n        {\n            long baseNumberSquared = 0; \n            long baseNumber = 0;  \n\n            do  \n            {\n                baseNumber += 1; \n                baseNumberSquared = baseNumber * baseNumber; \n            }\n            while (Right6Digits(baseNumberSquared) != 269696); \n\n            Console.WriteLine(\"The smallest integer whose square ends in 269,696 is \" + baseNumber);\n            Console.WriteLine(\"The square is \" + baseNumberSquared);\n\n        }\n\n        private long Right6Digits(long baseNumberSquared)\n        {\n\n            string numberAsString = baseNumberSquared.ToString(); \n\n            if (numberAsString.Length < 6) { return baseNumberSquared; }; \n\n            numberAsString = numberAsString.Substring(numberAsString.Length - 6);  \n\n            return long.Parse(numberAsString); \n\n        }\n    }\n}}\n"}
{"id": 2715, "name": "Babbage problem", "source": "Translate Ruby to Java: n = 0\nn = n + 2 until (n*n).modulo(1000000) == 269696 \nprint n\n", "target": "public class Test {\n\n    public static void main(String[] args) {\n\n        \n        int n = 0;\n\n        \n        do {\n\n            \n            n++;\n\n        \n        } while (n * n % 1000_000 != 269696);\n\n        \n        System.out.println(n);\n    }\n}\n"}
{"id": 2716, "name": "Babbage problem", "source": "Translate Ruby to Java: n = 0\nn = n + 2 until (n*n).modulo(1000000) == 269696 \nprint n\n", "target": "public class Test {\n\n    public static void main(String[] args) {\n\n        \n        int n = 0;\n\n        \n        do {\n\n            \n            n++;\n\n        \n        } while (n * n % 1000_000 != 269696);\n\n        \n        System.out.println(n);\n    }\n}\n"}
{"id": 2717, "name": "Babbage problem", "source": "Translate Ruby to Python: n = 0\nn = n + 2 until (n*n).modulo(1000000) == 269696 \nprint n\n", "target": "\n\n\nn=0 \n\n\n\n\nwhile n**2 % 1000000 != 269696:\n\n    \n    \n    \n    \n    n += 1 \n\nprint(n) \n"}
{"id": 2718, "name": "Babbage problem", "source": "Translate Ruby to Python: n = 0\nn = n + 2 until (n*n).modulo(1000000) == 269696 \nprint n\n", "target": "\n\n\nn=0 \n\n\n\n\nwhile n**2 % 1000000 != 269696:\n\n    \n    \n    \n    \n    n += 1 \n\nprint(n) \n"}
{"id": 2983, "name": "Ternary logic", "source": "Translate Ruby to C#: \n\n\nrequire 'singleton'\n\n\n\n\n\n\n\n\n\n\n\n\n\nclass MaybeClass\n  include Singleton\n\n  \n  def to_s; \"maybe\"; end\nend\n\nMAYBE = MaybeClass.instance\n\nclass TrueClass\n  TritMagic = Object.new\n  class << TritMagic\n    def index; 0; end\n    def !; false; end\n    def & other; other; end\n    def | other; true; end\n    def ^ other; [false, MAYBE, true][other.trit.index]; end\n    def == other; other; end\n  end\n\n  \n  \n  \n  \n  \n  \n  def trit; TritMagic; end\nend\n\nclass MaybeClass\n  TritMagic = Object.new\n  class << TritMagic\n    def index; 1; end\n    def !; MAYBE; end\n    def & other; [MAYBE, MAYBE, false][other.trit.index]; end\n    def | other; [true, MAYBE, MAYBE][other.trit.index]; end\n    def ^ other; MAYBE; end\n    def == other; MAYBE; end\n  end\n\n  \n  \n  \n  \n  \n  \n  def trit; TritMagic; end\nend\n\nclass FalseClass\n  TritMagic = Object.new\n  class << TritMagic\n    def index; 2; end\n    def !; true; end\n    def & other; false; end\n    def | other; other; end\n    def ^ other; other; end\n    def == other; [false, MAYBE, true][other.trit.index]; end\n  end\n\n  \n  \n  \n  \n  \n  \n  def trit; TritMagic; end\nend\n", "target": "using System;\n\n\n\n\n\n\n\npublic static class NullableBoolExtension\n{\n    public static bool? Implies(this bool? left, bool? right)\n    {\n        return !left | right;\n    }\n\n    public static bool? IsEquivalentTo(this bool? left, bool? right)\n    {\n        return left.HasValue && right.HasValue ? left == right : default(bool?);\n    }\n\n    public static string Format(this bool? value)\n    {\n        return value.HasValue ? value.Value.ToString() : \"Maybe\";\n    }\n}\n\npublic class Program\n{\n    private static void Main()\n    {\n        var values = new[] { true, default(bool?), false };\n\n        foreach (var left in values)\n        {\n            Console.WriteLine(\"\u00ac{0} = {1}\", left.Format(), (!left).Format());\n            foreach (var right in values)\n            {\n                Console.WriteLine(\"{0} & {1} = {2}\", left.Format(), right.Format(), (left & right).Format());\n                Console.WriteLine(\"{0} | {1} = {2}\", left.Format(), right.Format(), (left | right).Format());\n                Console.WriteLine(\"{0} \u2192 {1} = {2}\", left.Format(), right.Format(), left.Implies(right).Format());\n                Console.WriteLine(\"{0} \u2261 {1} = {2}\", left.Format(), right.Format(), left.IsEquivalentTo(right).Format());\n            }\n        }\n    }\n}\n"}
{"id": 2985, "name": "Ternary logic", "source": "Translate Ruby to Java: \n\n\nrequire 'singleton'\n\n\n\n\n\n\n\n\n\n\n\n\n\nclass MaybeClass\n  include Singleton\n\n  \n  def to_s; \"maybe\"; end\nend\n\nMAYBE = MaybeClass.instance\n\nclass TrueClass\n  TritMagic = Object.new\n  class << TritMagic\n    def index; 0; end\n    def !; false; end\n    def & other; other; end\n    def | other; true; end\n    def ^ other; [false, MAYBE, true][other.trit.index]; end\n    def == other; other; end\n  end\n\n  \n  \n  \n  \n  \n  \n  def trit; TritMagic; end\nend\n\nclass MaybeClass\n  TritMagic = Object.new\n  class << TritMagic\n    def index; 1; end\n    def !; MAYBE; end\n    def & other; [MAYBE, MAYBE, false][other.trit.index]; end\n    def | other; [true, MAYBE, MAYBE][other.trit.index]; end\n    def ^ other; MAYBE; end\n    def == other; MAYBE; end\n  end\n\n  \n  \n  \n  \n  \n  \n  def trit; TritMagic; end\nend\n\nclass FalseClass\n  TritMagic = Object.new\n  class << TritMagic\n    def index; 2; end\n    def !; true; end\n    def & other; false; end\n    def | other; other; end\n    def ^ other; other; end\n    def == other; [false, MAYBE, true][other.trit.index]; end\n  end\n\n  \n  \n  \n  \n  \n  \n  def trit; TritMagic; end\nend\n", "target": "public class Logic{\n\tpublic static enum Trit{\n\t\tTRUE, MAYBE, FALSE;\n\t\t\n\t\tpublic Trit and(Trit other){\n\t\t\tif(this == TRUE){\n\t\t\t\treturn other;\n\t\t\t}else if(this == MAYBE){\n\t\t\t\treturn (other == FALSE) ? FALSE : MAYBE;\n\t\t\t}else{\n\t\t\t\treturn FALSE;\n\t\t\t}\n\t\t}\n\t\t\n\t\tpublic Trit or(Trit other){\n\t\t\tif(this == TRUE){\n\t\t\t\treturn TRUE;\n\t\t\t}else if(this == MAYBE){\n\t\t\t\treturn (other == TRUE) ? TRUE : MAYBE;\n\t\t\t}else{\n\t\t\t\treturn other;\n\t\t\t}\n\t\t}\n\t\t\n\t\tpublic Trit tIf(Trit other){\n\t\t\tif(this == TRUE){\n\t\t\t\treturn other;\n\t\t\t}else if(this == MAYBE){\n\t\t\t\treturn (other == TRUE) ? TRUE : MAYBE;\n\t\t\t}else{\n\t\t\t\treturn TRUE;\n\t\t\t}\n\t\t}\n\t\t\n\t\tpublic Trit not(){\n\t\t\tif(this == TRUE){\n\t\t\t\treturn FALSE;\n\t\t\t}else if(this == MAYBE){\n\t\t\t\treturn MAYBE;\n\t\t\t}else{\n\t\t\t\treturn TRUE;\n\t\t\t}\n\t\t}\n\t\t\n\t\tpublic Trit equals(Trit other){\n\t\t\tif(this == TRUE){\n\t\t\t\treturn other;\n\t\t\t}else if(this == MAYBE){\n\t\t\t\treturn MAYBE;\n\t\t\t}else{\n\t\t\t\treturn other.not();\n\t\t\t}\n\t\t}\n\t}\n\tpublic static void main(String[] args){\n\t\tfor(Trit a:Trit.values()){\n\t\t\tSystem.out.println(\"not \" + a + \": \" + a.not());\n\t\t}\n\t\tfor(Trit a:Trit.values()){\n\t\t\tfor(Trit b:Trit.values()){\n\t\t\t\tSystem.out.println(a+\" and \"+b+\": \"+a.and(b)+\n\t\t\t\t\t\t\"\\t \"+a+\" or \"+b+\": \"+a.or(b)+\n\t\t\t\t\t\t\"\\t \"+a+\" implies \"+b+\": \"+a.tIf(b)+\n\t\t\t\t\t\t\"\\t \"+a+\" = \"+b+\": \"+a.equals(b));\n\t\t\t}\n\t\t}\n\t}\n}\n"}
{"id": 2986, "name": "Ternary logic", "source": "Translate Ruby to Python: \n\n\nrequire 'singleton'\n\n\n\n\n\n\n\n\n\n\n\n\n\nclass MaybeClass\n  include Singleton\n\n  \n  def to_s; \"maybe\"; end\nend\n\nMAYBE = MaybeClass.instance\n\nclass TrueClass\n  TritMagic = Object.new\n  class << TritMagic\n    def index; 0; end\n    def !; false; end\n    def & other; other; end\n    def | other; true; end\n    def ^ other; [false, MAYBE, true][other.trit.index]; end\n    def == other; other; end\n  end\n\n  \n  \n  \n  \n  \n  \n  def trit; TritMagic; end\nend\n\nclass MaybeClass\n  TritMagic = Object.new\n  class << TritMagic\n    def index; 1; end\n    def !; MAYBE; end\n    def & other; [MAYBE, MAYBE, false][other.trit.index]; end\n    def | other; [true, MAYBE, MAYBE][other.trit.index]; end\n    def ^ other; MAYBE; end\n    def == other; MAYBE; end\n  end\n\n  \n  \n  \n  \n  \n  \n  def trit; TritMagic; end\nend\n\nclass FalseClass\n  TritMagic = Object.new\n  class << TritMagic\n    def index; 2; end\n    def !; true; end\n    def & other; false; end\n    def | other; other; end\n    def ^ other; other; end\n    def == other; [false, MAYBE, true][other.trit.index]; end\n  end\n\n  \n  \n  \n  \n  \n  \n  def trit; TritMagic; end\nend\n", "target": "class Trit(int):\n    def __new__(cls, value):\n        if value == 'TRUE':\n            value = 1\n        elif value == 'FALSE':\n            value = 0\n        elif value == 'MAYBE':\n            value = -1\n        return super(Trit, cls).__new__(cls, value // (abs(value) or 1)) \n\n    def __repr__(self):\n        if self > 0:\n            return 'TRUE'\n        elif self == 0:\n            return 'FALSE'\n        return 'MAYBE'\n\n    def __str__(self):\n        return repr(self)\n\n    def __bool__(self):\n        if self > 0:\n            return True\n        elif self == 0:\n            return False\n        else:\n            raise ValueError(\"invalid literal for bool(): '%s'\" % self)\n\n    def __or__(self, other):\n        if isinstance(other, Trit):\n            return _ttable[(self, other)][1]\n        else:\n            try:\n                return _ttable[(self, Trit(bool(other)))][1]\n            except:\n                return NotImplemented\n\n    def __ror__(self, other):\n        if isinstance(other, Trit):\n            return _ttable[(self, other)][1]\n        else:\n            try:\n                return _ttable[(self, Trit(bool(other)))][1]\n            except:\n                return NotImplemented\n\n    def __and__(self, other):\n        if isinstance(other, Trit):\n            return _ttable[(self, other)][0]\n        else:\n            try:\n                return _ttable[(self, Trit(bool(other)))][0]\n            except:\n                return NotImplemented\n\n    def __rand__(self, other):\n        if isinstance(other, Trit):\n            return _ttable[(self, other)][0]\n        else:\n            try:\n                return _ttable[(self, Trit(bool(other)))][0]\n            except:\n                return NotImplemented\n\n    def __xor__(self, other):\n        if isinstance(other, Trit):\n            return _ttable[(self, other)][2]\n        else:\n            try:\n                return _ttable[(self, Trit(bool(other)))][2]\n            except:\n                return NotImplemented\n\n    def __rxor__(self, other):\n        if isinstance(other, Trit):\n            return _ttable[(self, other)][2]\n        else:\n            try:\n                return _ttable[(self, Trit(bool(other)))][2]\n            except:\n                return NotImplemented\n\n    def __invert__(self):\n        return _ttable[self]\n    \n    def __getattr__(self, name):\n        if name in ('_n', 'flip'):\n            \n            \n            \n            return _ttable[self]\n        else:\n            raise AttributeError \n\n\n        \nTRUE, FALSE, MAYBE = Trit(1), Trit(0), Trit(-1)\n\n_ttable = {\n    \n         TRUE: FALSE,\n        FALSE:  TRUE,\n        MAYBE: MAYBE,\n    \n        (MAYBE, MAYBE): (MAYBE, MAYBE, MAYBE),\n        (MAYBE, FALSE): (FALSE, MAYBE, MAYBE),\n        (MAYBE,  TRUE): (MAYBE,  TRUE, MAYBE),\n        (FALSE, MAYBE): (FALSE, MAYBE, MAYBE),\n        (FALSE, FALSE): (FALSE, FALSE, FALSE),\n        (FALSE,  TRUE): (FALSE,  TRUE,  TRUE),\n        ( TRUE, MAYBE): (MAYBE,  TRUE, MAYBE),\n        ( TRUE, FALSE): (FALSE,  TRUE,  TRUE),\n        ( TRUE,  TRUE): ( TRUE,  TRUE, FALSE),\n    }\n\n\nvalues = ('FALSE', 'TRUE ', 'MAYBE')\n\nprint(\"\\nTrit logical inverse, '~'\")\nfor a in values:\n    expr = '~%s' % a\n    print('  %s = %s' % (expr, eval(expr)))\n\nfor op, ophelp in (('&', 'and'), ('|', 'or'), ('^', 'exclusive-or')):\n    print(\"\\nTrit logical %s, '%s'\" % (ophelp, op))\n    for a in values:\n        for b in values:\n            expr = '%s %s %s' % (a, op, b)\n            print('  %s = %s' % (expr, eval(expr)))\n"}
{"id": 3416, "name": "Find limit of recursion", "source": "Translate Ruby to C#: def recurse x\n  puts x\n  recurse(x+1)\nend\n\nrecurse(0)\n", "target": "using System;\nclass RecursionLimit\n{\n  static void Main(string[] args)\n  {\n    Recur(0);\n  }\n \n  private static void Recur(int i) \n  {\n    Console.WriteLine(i);\n    Recur(i + 1);\n  }\n}\n"}
{"id": 3417, "name": "Find limit of recursion", "source": "Translate Ruby to C#: def recurse x\n  puts x\n  recurse(x+1)\nend\n\nrecurse(0)\n", "target": "using System;\nclass RecursionLimit\n{\n  static void Main(string[] args)\n  {\n    Recur(0);\n  }\n \n  private static void Recur(int i) \n  {\n    Console.WriteLine(i);\n    Recur(i + 1);\n  }\n}\n"}
{"id": 3420, "name": "Find limit of recursion", "source": "Translate Ruby to Java: def recurse x\n  puts x\n  recurse(x+1)\nend\n\nrecurse(0)\n", "target": "public class RecursionTest {\n\t\n    private static void recurse(int i) {\n        try {\n\t    recurse(i+1);\n\t} catch (StackOverflowError e) {\n\t    System.out.print(\"Recursion depth on this system is \" + i + \".\");\n\t}\n    }\n\t\n    public static void main(String[] args) {\n        recurse(0);\n    }\n}\n"}
{"id": 3421, "name": "Find limit of recursion", "source": "Translate Ruby to Java: def recurse x\n  puts x\n  recurse(x+1)\nend\n\nrecurse(0)\n", "target": "public class RecursionTest {\n\t\n    private static void recurse(int i) {\n        try {\n\t    recurse(i+1);\n\t} catch (StackOverflowError e) {\n\t    System.out.print(\"Recursion depth on this system is \" + i + \".\");\n\t}\n    }\n\t\n    public static void main(String[] args) {\n        recurse(0);\n    }\n}\n"}
{"id": 3678, "name": "Stack traces", "source": "Translate Ruby to C#: def outer(a,b,c)\n  middle a+b, b+c\nend\n\ndef middle(d,e)\n  inner d+e\nend\n\ndef inner(f)\n  puts caller(0)\n  puts \"continuing... my arg is \nend\n\nouter 2,3,5\n", "target": "using System;\nusing System.Diagnostics;\n\nclass Program\n{\n    static void Inner()\n    {\n        Console.WriteLine(new StackTrace());\n    }\n\n    static void Middle()\n    {\n        Inner();\n    }\n\n    static void Outer()\n    {\n        Middle();\n    }\n\n    static void Main()\n    {\n        Outer();\n    }\n}\n"}
{"id": 3679, "name": "Stack traces", "source": "Translate Ruby to Python: def outer(a,b,c)\n  middle a+b, b+c\nend\n\ndef middle(d,e)\n  inner d+e\nend\n\ndef inner(f)\n  puts caller(0)\n  puts \"continuing... my arg is \nend\n\nouter 2,3,5\n", "target": "import traceback\n\ndef f(): return g()\ndef g(): traceback.print_stack()\n\nf()\n"}
{"id": 3884, "name": "Introspection", "source": "Translate Ruby to C#: exit if RUBY_VERSION < '1.8.6'\nputs bloop.abs if defined?(bloop) and bloop.respond_to?(:abs)\n", "target": "using System;\nusing System.Reflection;\n\nnamespace Rosetta_Introspection\n{\n\tstatic public class Program\n\t{\n\t\tstatic public int bloop = -10;\n\t\tstatic public int bloop2 = -20;\n\n\t\tpublic static void Main()\n\t\t{\n\t\t\tvar asm = Assembly.GetExecutingAssembly();\n\t\t\tvar version = int.Parse(asm.ImageRuntimeVersion.Split('.')[0].Substring(1));\n\t\t\tif (version < 4)\n\t\t\t{\n\t\t\t\tConsole.WriteLine(\"Get with the program!  I'm outta here!\");\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tFieldInfo bloopField = null;\n\n\t\t\tforeach (var type in asm.GetExportedTypes())\n\t\t\t{\n\t\t\t\tforeach (var field in type.GetFields())\n\t\t\t\t{\n\t\t\t\t\tif (field.Name != \"bloop\")\n\t\t\t\t\t{\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tbloopField = field;\n\t\t\t\t\tif (bloopField.FieldType != typeof(int))\n\t\t\t\t\t{\n\t\t\t\t\t\tthrow new InvalidProgramException(\"bloop should be an integer\");\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (bloopField != null)\n\t\t\t\t{\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (bloopField == null)\n\t\t\t{\n\t\t\t\tthrow new InvalidProgramException(\"No bloop exported value\");\n\t\t\t}\n\t\t\tforeach (var refAsm in AppDomain.CurrentDomain.GetAssemblies())\n\t\t\t{\n\t\t\t\tforeach (var type in refAsm.GetExportedTypes())\n\t\t\t\t{\n\t\t\t\t\tif (type.Name == \"Math\")\n\t\t\t\t\t{\n\t\t\t\t\t\tvar absMethod = type.GetMethod(\"Abs\", new Type[] { typeof(int) });\n\t\t\t\t\t\tif (absMethod != null)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tConsole.WriteLine(\"bloop's abs value = {0}\", absMethod.Invoke(null, new object[] { bloopField.GetValue(null) }));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tint intCount = 0;\n\t\t\tint total = 0;\n\n\t\t\tforeach (var type in asm.GetExportedTypes())\n\t\t\t{\n\t\t\t\tforeach (var field in type.GetFields())\n\t\t\t\t{\n\t\t\t\t\tif (field.FieldType == typeof(int))\n\t\t\t\t\t{\n\t\t\t\t\t\tintCount++;\n\t\t\t\t\t\ttotal += (int)field.GetValue(null);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tConsole.WriteLine(\"{0} exported ints which total to {1}\", intCount, total);\n\t\t\tConsole.ReadKey();\n\t\t}\n\t}\n}\n"}
{"id": 3886, "name": "Introspection", "source": "Translate Ruby to Java: exit if RUBY_VERSION < '1.8.6'\nputs bloop.abs if defined?(bloop) and bloop.respond_to?(:abs)\n", "target": "public class VersCheck {\n\tpublic static void main(String[] args) {\n\t\tString vers = System.getProperty(\"java.version\");\n\t\tvers = vers.substring(0,vers.indexOf('.')) + \".\" +  \n\t\t\tvers.substring(vers.indexOf('.')+1,vers.lastIndexOf('.'));\n\t\tif(Double.parseDouble(vers) >= 1.5){\n\t\t\tSystem.out.println(\"YAY!\");\n\t\t}else{\n\t\t\tSystem.err.println(\"Must use Java >=1.5\");\n\t\t}\n\t}\n}\n"}
{"id": 3887, "name": "Introspection", "source": "Translate Ruby to Python: exit if RUBY_VERSION < '1.8.6'\nputs bloop.abs if defined?(bloop) and bloop.respond_to?(:abs)\n", "target": "\n import sys\n major, minor, bugfix = sys.version_info[:3]\n if major < 2:\n     sys.exit('Python 2 is required')\n \n \n def defined(name): \n     return name in globals() or name in locals() or name in vars(__builtins__)\n\n def defined2(name): \n     try:\n          eval(name)\n          return True\n     except NameError:\n          return False\n\n if defined('bloop') and defined('abs') and callable(abs):\n     print abs(bloop)\n\n if defined2('bloop') and defined2('abs') and callable(abs):\n     print abs(bloop)\n"}
{"id": 4349, "name": "CSV data manipulation", "source": "Translate Ruby to C#: require 'csv'\n\nar = CSV.table(\"test.csv\").to_a \n\n\nar.first << \"SUM\"\nar[1..-1].each{|row| row << row.sum}\n\n\nCSV.open(\"out.csv\", 'w') do |csv|\n  ar.each{|line| csv << line}\nend\n", "target": "using System.IO;\nusing System.Linq;\n\nnamespace CSV_data_manipulation\n{\n    class Program\n    {\n        static void Main()\n        {\n            var input = File.ReadAllLines(\"test_in.csv\");\n            var output = input.Select((line, i) =>\n            {\n                if (i == 0)\n                    return line + \",SUM\";\n                var sum = line.Split(',').Select(int.Parse).Sum();\n                return line + \",\" + sum;\n            }).ToArray();\n            File.WriteAllLines(\"test_out.csv\", output);\n        }\n    }\n}\n"}
{"id": 4350, "name": "CSV data manipulation", "source": "Translate Ruby to C#: require 'csv'\n\nar = CSV.table(\"test.csv\").to_a \n\n\nar.first << \"SUM\"\nar[1..-1].each{|row| row << row.sum}\n\n\nCSV.open(\"out.csv\", 'w') do |csv|\n  ar.each{|line| csv << line}\nend\n", "target": "using System.IO;\nusing System.Linq;\n\nnamespace CSV_data_manipulation\n{\n    class Program\n    {\n        static void Main()\n        {\n            var input = File.ReadAllLines(\"test_in.csv\");\n            var output = input.Select((line, i) =>\n            {\n                if (i == 0)\n                    return line + \",SUM\";\n                var sum = line.Split(',').Select(int.Parse).Sum();\n                return line + \",\" + sum;\n            }).ToArray();\n            File.WriteAllLines(\"test_out.csv\", output);\n        }\n    }\n}\n"}
{"id": 4353, "name": "CSV data manipulation", "source": "Translate Ruby to Java: require 'csv'\n\nar = CSV.table(\"test.csv\").to_a \n\n\nar.first << \"SUM\"\nar[1..-1].each{|row| row << row.sum}\n\n\nCSV.open(\"out.csv\", 'w') do |csv|\n  ar.each{|line| csv << line}\nend\n", "target": "import java.io.*;\nimport java.awt.Point;\nimport java.util.HashMap;\nimport java.util.Scanner;\n\npublic class CSV {\n\n    private HashMap<Point, String> _map = new HashMap<Point, String>();\n    private int _cols;\n    private int _rows;\n\n    public void open(File file) throws FileNotFoundException, IOException {\n        open(file, ',');\n    }\n\n    public void open(File file, char delimiter)\n            throws FileNotFoundException, IOException {\n        Scanner scanner = new Scanner(file);\n        scanner.useDelimiter(Character.toString(delimiter));\n\n        clear();\n\n        while(scanner.hasNextLine()) {\n            String[] values = scanner.nextLine().split(Character.toString(delimiter));\n\n            int col = 0;\n            for ( String value: values ) {\n                _map.put(new Point(col, _rows), value);\n                _cols = Math.max(_cols, ++col);\n            }\n            _rows++;\n        }\n        scanner.close();\n    }\n\n    public void save(File file) throws IOException {\n        save(file, ',');\n    }\n\n    public void save(File file, char delimiter) throws IOException {\n        FileWriter fw = new FileWriter(file);\n        BufferedWriter bw = new BufferedWriter(fw);\n\n        for (int row = 0; row < _rows; row++) {\n            for (int col = 0; col < _cols; col++) {\n                Point key = new Point(col, row);\n                if (_map.containsKey(key)) {\n                    bw.write(_map.get(key));\n                }\n\n                if ((col + 1) < _cols) {\n                    bw.write(delimiter);\n                }\n            }\n            bw.newLine();\n        }\n        bw.flush();\n        bw.close();\n    }\n\n    public String get(int col, int row) {\n        String val = \"\";\n        Point key = new Point(col, row);\n        if (_map.containsKey(key)) {\n            val = _map.get(key);\n        }\n        return val;\n    }\n\n    public void put(int col, int row, String value) {\n        _map.put(new Point(col, row), value);\n        _cols = Math.max(_cols, col+1);\n        _rows = Math.max(_rows, row+1);\n    }\n\n    public void clear() {\n        _map.clear();\n        _cols = 0;\n        _rows = 0;\n    }\n\n    public int rows() {\n        return _rows;\n    }\n\n    public int cols() {\n        return _cols;\n    }\n\n    public static void main(String[] args) {\n        try {\n            CSV csv = new CSV();\n\n            csv.open(new File(\"test_in.csv\"));\n            csv.put(0, 0, \"Column0\");\n            csv.put(1, 1, \"100\");\n            csv.put(2, 2, \"200\");\n            csv.put(3, 3, \"300\");\n            csv.put(4, 4, \"400\");\n            csv.save(new File(\"test_out.csv\"));\n        } catch (Exception e) {\n        }\n    }\n}\n"}
{"id": 4354, "name": "CSV data manipulation", "source": "Translate Ruby to Java: require 'csv'\n\nar = CSV.table(\"test.csv\").to_a \n\n\nar.first << \"SUM\"\nar[1..-1].each{|row| row << row.sum}\n\n\nCSV.open(\"out.csv\", 'w') do |csv|\n  ar.each{|line| csv << line}\nend\n", "target": "import java.io.*;\nimport java.awt.Point;\nimport java.util.HashMap;\nimport java.util.Scanner;\n\npublic class CSV {\n\n    private HashMap<Point, String> _map = new HashMap<Point, String>();\n    private int _cols;\n    private int _rows;\n\n    public void open(File file) throws FileNotFoundException, IOException {\n        open(file, ',');\n    }\n\n    public void open(File file, char delimiter)\n            throws FileNotFoundException, IOException {\n        Scanner scanner = new Scanner(file);\n        scanner.useDelimiter(Character.toString(delimiter));\n\n        clear();\n\n        while(scanner.hasNextLine()) {\n            String[] values = scanner.nextLine().split(Character.toString(delimiter));\n\n            int col = 0;\n            for ( String value: values ) {\n                _map.put(new Point(col, _rows), value);\n                _cols = Math.max(_cols, ++col);\n            }\n            _rows++;\n        }\n        scanner.close();\n    }\n\n    public void save(File file) throws IOException {\n        save(file, ',');\n    }\n\n    public void save(File file, char delimiter) throws IOException {\n        FileWriter fw = new FileWriter(file);\n        BufferedWriter bw = new BufferedWriter(fw);\n\n        for (int row = 0; row < _rows; row++) {\n            for (int col = 0; col < _cols; col++) {\n                Point key = new Point(col, row);\n                if (_map.containsKey(key)) {\n                    bw.write(_map.get(key));\n                }\n\n                if ((col + 1) < _cols) {\n                    bw.write(delimiter);\n                }\n            }\n            bw.newLine();\n        }\n        bw.flush();\n        bw.close();\n    }\n\n    public String get(int col, int row) {\n        String val = \"\";\n        Point key = new Point(col, row);\n        if (_map.containsKey(key)) {\n            val = _map.get(key);\n        }\n        return val;\n    }\n\n    public void put(int col, int row, String value) {\n        _map.put(new Point(col, row), value);\n        _cols = Math.max(_cols, col+1);\n        _rows = Math.max(_rows, row+1);\n    }\n\n    public void clear() {\n        _map.clear();\n        _cols = 0;\n        _rows = 0;\n    }\n\n    public int rows() {\n        return _rows;\n    }\n\n    public int cols() {\n        return _cols;\n    }\n\n    public static void main(String[] args) {\n        try {\n            CSV csv = new CSV();\n\n            csv.open(new File(\"test_in.csv\"));\n            csv.put(0, 0, \"Column0\");\n            csv.put(1, 1, \"100\");\n            csv.put(2, 2, \"200\");\n            csv.put(3, 3, \"300\");\n            csv.put(4, 4, \"400\");\n            csv.save(new File(\"test_out.csv\"));\n        } catch (Exception e) {\n        }\n    }\n}\n"}
{"id": 4355, "name": "CSV data manipulation", "source": "Translate Ruby to Python: require 'csv'\n\nar = CSV.table(\"test.csv\").to_a \n\n\nar.first << \"SUM\"\nar[1..-1].each{|row| row << row.sum}\n\n\nCSV.open(\"out.csv\", 'w') do |csv|\n  ar.each{|line| csv << line}\nend\n", "target": "import fileinput\n\nchangerow, changecolumn, changevalue = 2, 4, '\"Spam\"'\n\nwith fileinput.input('csv_data_manipulation.csv', inplace=True) as f:\n    for line in f:\n        if fileinput.filelineno() == changerow:\n            fields = line.rstrip().split(',')\n            fields[changecolumn-1] = changevalue\n            line = ','.join(fields) + '\\n'\n        print(line, end='')\n"}
{"id": 4356, "name": "CSV data manipulation", "source": "Translate Ruby to Python: require 'csv'\n\nar = CSV.table(\"test.csv\").to_a \n\n\nar.first << \"SUM\"\nar[1..-1].each{|row| row << row.sum}\n\n\nCSV.open(\"out.csv\", 'w') do |csv|\n  ar.each{|line| csv << line}\nend\n", "target": "import fileinput\n\nchangerow, changecolumn, changevalue = 2, 4, '\"Spam\"'\n\nwith fileinput.input('csv_data_manipulation.csv', inplace=True) as f:\n    for line in f:\n        if fileinput.filelineno() == changerow:\n            fields = line.rstrip().split(',')\n            fields[changecolumn-1] = changevalue\n            line = ','.join(fields) + '\\n'\n        print(line, end='')\n"}
{"id": 4600, "name": "URL parser", "source": "Translate Ruby to C#: require 'uri'\n\ntest_cases = [\n  \"foo://example.com:8042/over/there?name=ferret\n  \"urn:example:animal:ferret:nose\",\n  \"jdbc:mysql://test_user:ouupppssss@localhost:3306/sakila?profileSQL=true\",\n  \"ftp://ftp.is.co.za/rfc/rfc1808.txt\",\n  \"http://www.ietf.org/rfc/rfc2396.txt\n  \"ldap://[2001:db8::7]/c=GB?objectClass=one&objectClass=two\",\n  \"mailto:John.Doe@example.com\",\n  \"news:comp.infosystems.www.servers.unix\",\n  \"tel:+1-816-555-1212\",\n  \"telnet://192.0.2.16:80/\",\n  \"urn:oasis:names:specification:docbook:dtd:xml:4.1.2\",\n  \"ssh://alice@example.com\",\n  \"https://bob:pass@example.com/place\",\n  \"http://example.com/?a=1&b=2+2&c=3&c=4&d=%65%6e%63%6F%64%65%64\"\n]\n\nclass URI::Generic; alias_method :domain, :host; end\n\ntest_cases.each do |test_case|\n  puts test_case\n  uri = URI.parse(test_case)\n  %w[ scheme domain port path query fragment user password ].each do |attr|\n    puts \"  \n  end\nend\n", "target": "using System;\n\nnamespace RosettaUrlParse\n{\n    class Program\n    {\n        static void ParseUrl(string url)\n        {\n            var u = new Uri(url);\n            Console.WriteLine(\"URL:         {0}\", u.AbsoluteUri);\n            Console.WriteLine(\"Scheme:      {0}\", u.Scheme);\n            Console.WriteLine(\"Host:        {0}\", u.DnsSafeHost);\n            Console.WriteLine(\"Port:        {0}\", u.Port);\n            Console.WriteLine(\"Path:        {0}\", u.LocalPath);\n            Console.WriteLine(\"Query:       {0}\", u.Query);\n            Console.WriteLine(\"Fragment:    {0}\", u.Fragment);\n            Console.WriteLine();\n        }\n        static void Main(string[] args)\n        {\n            ParseUrl(\"foo:\n            ParseUrl(\"urn:example:animal:ferret:nose\");\n            ParseUrl(\"jdbc:mysql:\n            ParseUrl(\"ftp:\n            ParseUrl(\"http:\n            ParseUrl(\"ldap:\n            ParseUrl(\"mailto:John.Doe@example.com\");\n            ParseUrl(\"news:comp.infosystems.www.servers.unix\");\n            ParseUrl(\"tel:+1-816-555-1212\");\n            ParseUrl(\"telnet:\n            ParseUrl(\"urn:oasis:names:specification:docbook:dtd:xml:4.1.2\");\n        }\n    }\n}\n"}
{"id": 4601, "name": "URL parser", "source": "Translate Ruby to C#: require 'uri'\n\ntest_cases = [\n  \"foo://example.com:8042/over/there?name=ferret\n  \"urn:example:animal:ferret:nose\",\n  \"jdbc:mysql://test_user:ouupppssss@localhost:3306/sakila?profileSQL=true\",\n  \"ftp://ftp.is.co.za/rfc/rfc1808.txt\",\n  \"http://www.ietf.org/rfc/rfc2396.txt\n  \"ldap://[2001:db8::7]/c=GB?objectClass=one&objectClass=two\",\n  \"mailto:John.Doe@example.com\",\n  \"news:comp.infosystems.www.servers.unix\",\n  \"tel:+1-816-555-1212\",\n  \"telnet://192.0.2.16:80/\",\n  \"urn:oasis:names:specification:docbook:dtd:xml:4.1.2\",\n  \"ssh://alice@example.com\",\n  \"https://bob:pass@example.com/place\",\n  \"http://example.com/?a=1&b=2+2&c=3&c=4&d=%65%6e%63%6F%64%65%64\"\n]\n\nclass URI::Generic; alias_method :domain, :host; end\n\ntest_cases.each do |test_case|\n  puts test_case\n  uri = URI.parse(test_case)\n  %w[ scheme domain port path query fragment user password ].each do |attr|\n    puts \"  \n  end\nend\n", "target": "using System;\n\nnamespace RosettaUrlParse\n{\n    class Program\n    {\n        static void ParseUrl(string url)\n        {\n            var u = new Uri(url);\n            Console.WriteLine(\"URL:         {0}\", u.AbsoluteUri);\n            Console.WriteLine(\"Scheme:      {0}\", u.Scheme);\n            Console.WriteLine(\"Host:        {0}\", u.DnsSafeHost);\n            Console.WriteLine(\"Port:        {0}\", u.Port);\n            Console.WriteLine(\"Path:        {0}\", u.LocalPath);\n            Console.WriteLine(\"Query:       {0}\", u.Query);\n            Console.WriteLine(\"Fragment:    {0}\", u.Fragment);\n            Console.WriteLine();\n        }\n        static void Main(string[] args)\n        {\n            ParseUrl(\"foo:\n            ParseUrl(\"urn:example:animal:ferret:nose\");\n            ParseUrl(\"jdbc:mysql:\n            ParseUrl(\"ftp:\n            ParseUrl(\"http:\n            ParseUrl(\"ldap:\n            ParseUrl(\"mailto:John.Doe@example.com\");\n            ParseUrl(\"news:comp.infosystems.www.servers.unix\");\n            ParseUrl(\"tel:+1-816-555-1212\");\n            ParseUrl(\"telnet:\n            ParseUrl(\"urn:oasis:names:specification:docbook:dtd:xml:4.1.2\");\n        }\n    }\n}\n"}
{"id": 4602, "name": "URL parser", "source": "Translate Ruby to Java: require 'uri'\n\ntest_cases = [\n  \"foo://example.com:8042/over/there?name=ferret\n  \"urn:example:animal:ferret:nose\",\n  \"jdbc:mysql://test_user:ouupppssss@localhost:3306/sakila?profileSQL=true\",\n  \"ftp://ftp.is.co.za/rfc/rfc1808.txt\",\n  \"http://www.ietf.org/rfc/rfc2396.txt\n  \"ldap://[2001:db8::7]/c=GB?objectClass=one&objectClass=two\",\n  \"mailto:John.Doe@example.com\",\n  \"news:comp.infosystems.www.servers.unix\",\n  \"tel:+1-816-555-1212\",\n  \"telnet://192.0.2.16:80/\",\n  \"urn:oasis:names:specification:docbook:dtd:xml:4.1.2\",\n  \"ssh://alice@example.com\",\n  \"https://bob:pass@example.com/place\",\n  \"http://example.com/?a=1&b=2+2&c=3&c=4&d=%65%6e%63%6F%64%65%64\"\n]\n\nclass URI::Generic; alias_method :domain, :host; end\n\ntest_cases.each do |test_case|\n  puts test_case\n  uri = URI.parse(test_case)\n  %w[ scheme domain port path query fragment user password ].each do |attr|\n    puts \"  \n  end\nend\n", "target": "import java.net.URI;\nimport java.net.URISyntaxException;\npublic class WebAddressParser{\n    public static void main(String[] args){\n        parseAddress(\"foo:\n        parseAddress(\"urn:example:animal:ferret:nose\");\n    }\n\n    static void parseAddress(String a){\n        System.out.println(\"Parsing \" + a);\n        try{\n\n            \n            URI u = new URI(a);\n\n            System.out.println(\"\\tscheme = \" + u.getScheme());\n            System.out.println(\"\\tdomain = \" + u.getHost());\n            System.out.println(\"\\tport = \" + (-1==u.getPort()?\"default\":u.getPort()));\n            System.out.println(\"\\tpath = \" + (null==u.getPath()?u.getSchemeSpecificPart():u.getPath()));\n            System.out.println(\"\\tquery = \" + u.getQuery());\n            System.out.println(\"\\tfragment = \" + u.getFragment());\n        }\n        catch (URISyntaxException x){\n            System.err.println(\"Oops: \" + x);\n        }\n    }\n}\n"}
{"id": 4603, "name": "URL parser", "source": "Translate Ruby to Java: require 'uri'\n\ntest_cases = [\n  \"foo://example.com:8042/over/there?name=ferret\n  \"urn:example:animal:ferret:nose\",\n  \"jdbc:mysql://test_user:ouupppssss@localhost:3306/sakila?profileSQL=true\",\n  \"ftp://ftp.is.co.za/rfc/rfc1808.txt\",\n  \"http://www.ietf.org/rfc/rfc2396.txt\n  \"ldap://[2001:db8::7]/c=GB?objectClass=one&objectClass=two\",\n  \"mailto:John.Doe@example.com\",\n  \"news:comp.infosystems.www.servers.unix\",\n  \"tel:+1-816-555-1212\",\n  \"telnet://192.0.2.16:80/\",\n  \"urn:oasis:names:specification:docbook:dtd:xml:4.1.2\",\n  \"ssh://alice@example.com\",\n  \"https://bob:pass@example.com/place\",\n  \"http://example.com/?a=1&b=2+2&c=3&c=4&d=%65%6e%63%6F%64%65%64\"\n]\n\nclass URI::Generic; alias_method :domain, :host; end\n\ntest_cases.each do |test_case|\n  puts test_case\n  uri = URI.parse(test_case)\n  %w[ scheme domain port path query fragment user password ].each do |attr|\n    puts \"  \n  end\nend\n", "target": "import java.net.URI;\nimport java.net.URISyntaxException;\npublic class WebAddressParser{\n    public static void main(String[] args){\n        parseAddress(\"foo:\n        parseAddress(\"urn:example:animal:ferret:nose\");\n    }\n\n    static void parseAddress(String a){\n        System.out.println(\"Parsing \" + a);\n        try{\n\n            \n            URI u = new URI(a);\n\n            System.out.println(\"\\tscheme = \" + u.getScheme());\n            System.out.println(\"\\tdomain = \" + u.getHost());\n            System.out.println(\"\\tport = \" + (-1==u.getPort()?\"default\":u.getPort()));\n            System.out.println(\"\\tpath = \" + (null==u.getPath()?u.getSchemeSpecificPart():u.getPath()));\n            System.out.println(\"\\tquery = \" + u.getQuery());\n            System.out.println(\"\\tfragment = \" + u.getFragment());\n        }\n        catch (URISyntaxException x){\n            System.err.println(\"Oops: \" + x);\n        }\n    }\n}\n"}
{"id": 4604, "name": "URL parser", "source": "Translate Ruby to Python: require 'uri'\n\ntest_cases = [\n  \"foo://example.com:8042/over/there?name=ferret\n  \"urn:example:animal:ferret:nose\",\n  \"jdbc:mysql://test_user:ouupppssss@localhost:3306/sakila?profileSQL=true\",\n  \"ftp://ftp.is.co.za/rfc/rfc1808.txt\",\n  \"http://www.ietf.org/rfc/rfc2396.txt\n  \"ldap://[2001:db8::7]/c=GB?objectClass=one&objectClass=two\",\n  \"mailto:John.Doe@example.com\",\n  \"news:comp.infosystems.www.servers.unix\",\n  \"tel:+1-816-555-1212\",\n  \"telnet://192.0.2.16:80/\",\n  \"urn:oasis:names:specification:docbook:dtd:xml:4.1.2\",\n  \"ssh://alice@example.com\",\n  \"https://bob:pass@example.com/place\",\n  \"http://example.com/?a=1&b=2+2&c=3&c=4&d=%65%6e%63%6F%64%65%64\"\n]\n\nclass URI::Generic; alias_method :domain, :host; end\n\ntest_cases.each do |test_case|\n  puts test_case\n  uri = URI.parse(test_case)\n  %w[ scheme domain port path query fragment user password ].each do |attr|\n    puts \"  \n  end\nend\n", "target": "import urllib.parse as up \n\nurl = up.urlparse('http://user:pass@example.com:8081/path/file.html;params?query1=1\n\nprint('url.scheme = ', url.scheme)\nprint('url.netloc = ', url.netloc)\nprint('url.hostname = ', url.hostname)\nprint('url.port = ', url.port)\nprint('url.path = ', url.path)\nprint('url.params = ', url.params)\nprint('url.query = ', url.query)\nprint('url.fragment = ', url.fragment)\nprint('url.username = ', url.username)\nprint('url.password = ', url.password)\n"}
{"id": 4605, "name": "URL parser", "source": "Translate Ruby to Python: require 'uri'\n\ntest_cases = [\n  \"foo://example.com:8042/over/there?name=ferret\n  \"urn:example:animal:ferret:nose\",\n  \"jdbc:mysql://test_user:ouupppssss@localhost:3306/sakila?profileSQL=true\",\n  \"ftp://ftp.is.co.za/rfc/rfc1808.txt\",\n  \"http://www.ietf.org/rfc/rfc2396.txt\n  \"ldap://[2001:db8::7]/c=GB?objectClass=one&objectClass=two\",\n  \"mailto:John.Doe@example.com\",\n  \"news:comp.infosystems.www.servers.unix\",\n  \"tel:+1-816-555-1212\",\n  \"telnet://192.0.2.16:80/\",\n  \"urn:oasis:names:specification:docbook:dtd:xml:4.1.2\",\n  \"ssh://alice@example.com\",\n  \"https://bob:pass@example.com/place\",\n  \"http://example.com/?a=1&b=2+2&c=3&c=4&d=%65%6e%63%6F%64%65%64\"\n]\n\nclass URI::Generic; alias_method :domain, :host; end\n\ntest_cases.each do |test_case|\n  puts test_case\n  uri = URI.parse(test_case)\n  %w[ scheme domain port path query fragment user password ].each do |attr|\n    puts \"  \n  end\nend\n", "target": "import urllib.parse as up \n\nurl = up.urlparse('http://user:pass@example.com:8081/path/file.html;params?query1=1\n\nprint('url.scheme = ', url.scheme)\nprint('url.netloc = ', url.netloc)\nprint('url.hostname = ', url.hostname)\nprint('url.port = ', url.port)\nprint('url.path = ', url.path)\nprint('url.params = ', url.params)\nprint('url.query = ', url.query)\nprint('url.fragment = ', url.fragment)\nprint('url.username = ', url.username)\nprint('url.password = ', url.password)\n"}
{"id": 4844, "name": "Window creation", "source": "Translate Ruby to C#:  require 'tk'\n \n window = TkRoot::new()\n window::mainloop()\n", "target": "using System;\nusing System.Windows.Forms;\n\npublic class Window {\n    [STAThread]\n    static void Main() {\n        Form form = new Form();\n        \n        form.Text = \"Window\";\n        form.Disposed += delegate { Application.Exit(); };\n\n        form.Show();\n        Application.Run();\n    }\n}\n"}
{"id": 4846, "name": "Window creation", "source": "Translate Ruby to Java:  require 'tk'\n \n window = TkRoot::new()\n window::mainloop()\n", "target": "import javax.swing.JFrame;\n\npublic class Main {\n     public static void main(String[] args) throws Exception {\n         JFrame w = new JFrame(\"Title\");\n         w.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n         w.setSize(800,600);\n         w.setVisible(true);\n     }\n}\n"}
{"id": 4847, "name": "Window creation", "source": "Translate Ruby to Python:  require 'tk'\n \n window = TkRoot::new()\n window::mainloop()\n", "target": "  import Tkinter\n  \n  w = Tkinter.Tk()\n  w.mainloop()\n"}
{"id": 5049, "name": "Read entire file", "source": "Translate Ruby to C#: content = File.read(\"input.txt\")\nputs content\n", "target": "using System.IO;\n\nclass Program\n{\n    static void Main(string[] args)\n    {\n        var fileContents = File.ReadAllText(\"c:\\\\autoexec.bat\");  \n        \n    }\n}\n"}
{"id": 5215, "name": "Undefined values", "source": "Translate Ruby to C#: \nputs \"var is undefined at first check\" unless defined? var\n\n\nvar = \"Chocolate\"\n\n\n\nputs \"var is undefined at second check\" unless defined? var\n\n\n\n\n\nputs \"Done\"\n", "target": "string foo = null;\n"}
{"id": 5217, "name": "Undefined values", "source": "Translate Ruby to Java: \nputs \"var is undefined at first check\" unless defined? var\n\n\nvar = \"Chocolate\"\n\n\n\nputs \"var is undefined at second check\" unless defined? var\n\n\n\n\n\nputs \"Done\"\n", "target": "String string = null;        \nSystem.out.println(string);           \nSystem.out.println(string.length());  \n"}
{"id": 5218, "name": "Undefined values", "source": "Translate Ruby to Python: \nputs \"var is undefined at first check\" unless defined? var\n\n\nvar = \"Chocolate\"\n\n\n\nputs \"var is undefined at second check\" unless defined? var\n\n\n\n\n\nputs \"Done\"\n", "target": "\ntry: name\nexcept NameError: print \"name is undefined at first check\"\n\n\nname = \"Chocolate\"\n\n\ntry: name\nexcept NameError: print \"name is undefined at second check\"\n\n\ndel name\n\n\ntry: name\nexcept NameError: print \"name is undefined at third check\"\n\n\nname = 42\n\n\ntry: name\nexcept NameError: print \"name is undefined at fourth check\"\n\n\n\nprint \"Done\"\n"}
{"id": 5514, "name": "Balanced ternary", "source": "Translate Ruby to C#: class BalancedTernary\n  include Comparable\n  def initialize(str = \"\")\n    if str =~ /[^-+0]+/\n      raise ArgumentError, \"invalid BalancedTernary number: \n    end\n    @digits = trim0(str)\n  end\n   \n  I2BT = {0 => [\"0\",0], 1 => [\"+\",0], 2 => [\"-\",1]}\n  def self.from_int(value)\n    n = value.to_i\n    digits = \"\"\n    while n != 0\n      quo, rem = n.divmod(3)\n      bt, carry = I2BT[rem]\n      digits = bt + digits\n      n = quo + carry\n    end\n    new(digits)\n  end\n  \n  BT2I = {\"-\" => -1, \"0\" => 0, \"+\" => 1}\n  def to_int\n    @digits.chars.inject(0) do |sum, char|\n      sum = 3 * sum + BT2I[char]\n    end\n  end\n  alias :to_i :to_int\n  \n  def to_s\n    @digits.dup                 \n  end\n  alias :inspect :to_s\n  \n  def <=>(other)\n    to_i <=> other.to_i\n  end\n  \n  ADDITION_TABLE = {\n    \"---\" => [\"-\",\"0\"], \"--0\" => [\"-\",\"+\"], \"--+\" => [\"0\",\"-\"],\n    \"-0-\" => [\"-\",\"+\"], \"-00\" => [\"0\",\"-\"], \"-0+\" => [\"0\",\"0\"],\n    \"-+-\" => [\"0\",\"-\"], \"-+0\" => [\"0\",\"0\"], \"-++\" => [\"0\",\"+\"],\n    \"0--\" => [\"-\",\"+\"], \"0-0\" => [\"0\",\"-\"], \"0-+\" => [\"0\",\"0\"],\n    \"00-\" => [\"0\",\"-\"], \"000\" => [\"0\",\"0\"], \"00+\" => [\"0\",\"+\"],\n    \"0+-\" => [\"0\",\"0\"], \"0+0\" => [\"0\",\"+\"], \"0++\" => [\"+\",\"-\"],\n    \"+--\" => [\"0\",\"-\"], \"+-0\" => [\"0\",\"0\"], \"+-+\" => [\"0\",\"+\"],\n    \"+0-\" => [\"0\",\"0\"], \"+00\" => [\"0\",\"+\"], \"+0+\" => [\"+\",\"-\"],\n    \"++-\" => [\"0\",\"+\"], \"++0\" => [\"+\",\"-\"], \"+++\" => [\"+\",\"0\"],\n  }\n  \n  def +(other)\n    maxl = [to_s.length, other.to_s.length].max\n    a = pad0_reverse(to_s, maxl)\n    b = pad0_reverse(other.to_s, maxl)\n    carry = \"0\"\n    sum = a.zip( b ).inject(\"\") do |sum, (c1, c2)|\n      carry, digit = ADDITION_TABLE[carry + c1 + c2]\n      sum = digit + sum\n    end\n    self.class.new(carry + sum)\n  end\n  \n  MULTIPLICATION_TABLE = {\n    \"-\" => \"+0-\",\n    \"0\" => \"000\",\n    \"+\" => \"-0+\",\n  }\n  \n  def *(other)\n    product = self.class.new\n    other.to_s.each_char do |bdigit|\n      row = to_s.tr(\"-0+\", MULTIPLICATION_TABLE[bdigit])\n      product += self.class.new(row)\n      product << 1\n    end\n    product >> 1\n  end\n  \n  \n  def -@()\n    self.class.new(@digits.tr('-+','+-'))\n  end\n \n  \n  def -(other)\n    self + (-other)\n  end\n  \n  \n  def <<(count)\n    @digits = trim0(@digits + \"0\"*count)\n    self\n  end\n  \n  \n  def >>(count)\n    @digits[-count..-1] = \"\" if count > 0\n    @digits = trim0(@digits)\n    self\n  end\n  \n  private\n  \n  def trim0(str)\n    str = str.sub(/^0+/, \"\")\n    str = \"0\" if str.empty?\n    str\n  end\n  \n  def pad0_reverse(str, len)\n    str.rjust(len, \"0\").reverse.chars\n  end\nend\n\na = BalancedTernary.new(\"+-0++0+\")\nb = BalancedTernary.from_int(-436)\nc = BalancedTernary.new(\"+-++-\")\n\n%w[a b c a*(b-c)].each do |exp|\n  val = eval(exp)\n  puts \"%8s\u00a0:%13s,%8d\" % [exp, val, val.to_i]\nend\n", "target": "using System;\nusing System.Text;\nusing System.Collections.Generic;\n\npublic class BalancedTernary\n{\n\tpublic static void Main()\n\t{\n\t\tBalancedTernary a = new BalancedTernary(\"+-0++0+\");\n\t\tSystem.Console.WriteLine(\"a: \" + a + \" = \" + a.ToLong());\n\t\tBalancedTernary b = new BalancedTernary(-436);\n\t\tSystem.Console.WriteLine(\"b: \" + b + \" = \" + b.ToLong());\n\t\tBalancedTernary c = new BalancedTernary(\"+-++-\");\n\t\tSystem.Console.WriteLine(\"c: \" + c + \" = \" + c.ToLong());\n\t\tBalancedTernary d = a * (b - c);\n\t\tSystem.Console.WriteLine(\"a * (b - c): \" + d + \" = \" + d.ToLong());\n\t}\n\n\tprivate enum BalancedTernaryDigit\n\t{\n\t\tMINUS = -1,\n\t\tZERO = 0,\n\t\tPLUS = 1\n\t}\n\n\tprivate BalancedTernaryDigit[] value;\n\n\t\n\tpublic BalancedTernary()\n\t{\n\t\tthis.value = new BalancedTernaryDigit[0];\n\t}\n\n\t\n\tpublic BalancedTernary(String str)\n\t{\n\t\tthis.value = new BalancedTernaryDigit[str.Length];\n\t\tfor (int i = 0; i < str.Length; ++i)\n\t\t{\n\t\t\tswitch (str[i])\n\t\t\t{\n\t\t\t\tcase '-':\n\t\t\t\t\tthis.value[i] = BalancedTernaryDigit.MINUS;\n\t\t\t\t\tbreak;\n\t\t\t\tcase '0':\n\t\t\t\t\tthis.value[i] = BalancedTernaryDigit.ZERO;\n\t\t\t\t\tbreak;\n\t\t\t\tcase '+':\n\t\t\t\t\tthis.value[i] = BalancedTernaryDigit.PLUS;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tthrow new ArgumentException(\"Unknown Digit: \" + str[i]);\n\t\t\t}\n\t\t}\n\t\tArray.Reverse(this.value);\n\t}\n\n\t\n\tpublic BalancedTernary(long l)\n\t{\n\t\tList<BalancedTernaryDigit> value = new List<BalancedTernaryDigit>();\n\t\tint sign = Math.Sign(l);\n\t\tl = Math.Abs(l);\n\t\t\n\t\twhile (l != 0)\n\t\t{\n\t\t\tbyte rem = (byte)(l % 3);\n\t\t\tswitch (rem)\n\t\t\t{\n\t\t\t\tcase 0:\n\t\t\t\tcase 1:\n\t\t\t\t\tvalue.Add((BalancedTernaryDigit)rem);\n\t\t\t\t\tl /= 3;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 2:\n\t\t\t\t\tvalue.Add(BalancedTernaryDigit.MINUS);\n\t\t\t\t\tl = (l + 1) / 3;\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tthis.value = value.ToArray();\n\t\tif (sign < 0)\n\t\t{\n\t\t\tthis.Invert();\n\t\t}\n\t}\n\n\t\n\tpublic BalancedTernary(BalancedTernary origin)\n\t{\n\t\tthis.value = new BalancedTernaryDigit[origin.value.Length];\n\t\tArray.Copy(origin.value, this.value, origin.value.Length);\n\t}\n\n\t\n\tprivate BalancedTernary(BalancedTernaryDigit[] value)\n\t{\n\t\tint end = value.Length - 1;\n\t\twhile (value[end] == BalancedTernaryDigit.ZERO)\n\t\t\t--end;\n\t\tthis.value = new BalancedTernaryDigit[end + 1];\n\t\tArray.Copy(value, this.value, end + 1);\n\t}\n\n\t\n\tprivate void Invert()\n\t{\n\t\tfor (int i=0; i < this.value.Length; ++i)\n\t\t{\n\t\t\tthis.value[i] = (BalancedTernaryDigit)(-(int)this.value[i]);\n\t\t}\n\t}\n\n\t\n\toverride public String ToString()\n\t{\n\t\tStringBuilder result = new StringBuilder();\n\t\tfor (int i = this.value.Length - 1; i >= 0; --i)\n\t\t{\n\t\t\tswitch (this.value[i])\n\t\t\t{\n\t\t\t\tcase BalancedTernaryDigit.MINUS:\n\t\t\t\t\tresult.Append('-');\n\t\t\t\t\tbreak;\n\t\t\t\tcase BalancedTernaryDigit.ZERO:\n\t\t\t\t\tresult.Append('0');\n\t\t\t\t\tbreak;\n\t\t\t\tcase BalancedTernaryDigit.PLUS:\n\t\t\t\t\tresult.Append('+');\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn result.ToString();\n\t}\n\n\t\n\tpublic long ToLong()\n\t{\n\t\tlong result = 0;\n\t\tint digit;\n\t\tfor (int i = 0; i < this.value.Length; ++i)\n\t\t{\n\t\t\tresult += (long)this.value[i] * (long)Math.Pow(3.0, (double)i);\n\t\t}\n\t\treturn result;\n\t}\n\n\t\n\tpublic static BalancedTernary operator -(BalancedTernary origin)\n\t{\n\t\tBalancedTernary result = new BalancedTernary(origin);\n\t\tresult.Invert();\n\t\treturn result;\n\t}\n\n\t\n\tprivate static BalancedTernaryDigit carry = BalancedTernaryDigit.ZERO;\n\tprivate static BalancedTernaryDigit Add(BalancedTernaryDigit a, BalancedTernaryDigit b)\n\t{\n\t\tif (a != b)\n\t\t{\n\t\t\tcarry = BalancedTernaryDigit.ZERO;\n\t\t\treturn (BalancedTernaryDigit)((int)a + (int)b);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tcarry = a;\n\t\t\treturn (BalancedTernaryDigit)(-(int)b);\n\t\t}\n\t}\n\n\t\n\tpublic static BalancedTernary operator +(BalancedTernary a, BalancedTernary b)\n\t{\n\t\tint maxLength = Math.Max(a.value.Length, b.value.Length);\n\t\tBalancedTernaryDigit[] resultValue = new BalancedTernaryDigit[maxLength + 1];\n\t\tfor (int i=0; i < maxLength; ++i)\n\t\t{\n\t\t\tif (i < a.value.Length)\n\t\t\t{\n\t\t\t\tresultValue[i] = Add(resultValue[i], a.value[i]);\n\t\t\t\tresultValue[i+1] = carry;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tcarry = BalancedTernaryDigit.ZERO;\n\t\t\t}\n\t\t\t\n\t\t\tif (i < b.value.Length)\n\t\t\t{\n\t\t\t\tresultValue[i] = Add(resultValue[i], b.value[i]);\n\t\t\t\tresultValue[i+1] = Add(resultValue[i+1], carry);\n\t\t\t}\n\t\t}\n\t\treturn new BalancedTernary(resultValue);\n\t}\n\n\t\n\tpublic static BalancedTernary operator -(BalancedTernary a, BalancedTernary b)\n\t{\n\t\treturn a + (-b);\n\t}\n\n\t\n\tpublic static BalancedTernary operator *(BalancedTernary a, BalancedTernary b)\n\t{\n\t\tBalancedTernaryDigit[] longValue = a.value;\n\t\tBalancedTernaryDigit[] shortValue = b.value;\n\t\tBalancedTernary result = new BalancedTernary();\n\t\tif (a.value.Length < b.value.Length)\n\t\t{\n\t\t\tlongValue = b.value;\n\t\t\tshortValue = a.value;\n\t\t}\n\n\t\tfor (int i = 0; i < shortValue.Length; ++i)\n\t\t{\n\t\t\tif (shortValue[i] != BalancedTernaryDigit.ZERO)\n\t\t\t{\n\t\t\t\tBalancedTernaryDigit[] temp = new BalancedTernaryDigit[i + longValue.Length];\n\t\t\t\tfor (int j = 0; j < longValue.Length; ++j)\n\t\t\t\t{\n\t\t\t\t\ttemp[i+j] = (BalancedTernaryDigit)((int)shortValue[i] * (int)longValue[j]);\n\t\t\t\t}\n\t\t\t\tresult = result + new BalancedTernary(temp);\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n}\n"}
{"id": 5515, "name": "Balanced ternary", "source": "Translate Ruby to C#: class BalancedTernary\n  include Comparable\n  def initialize(str = \"\")\n    if str =~ /[^-+0]+/\n      raise ArgumentError, \"invalid BalancedTernary number: \n    end\n    @digits = trim0(str)\n  end\n   \n  I2BT = {0 => [\"0\",0], 1 => [\"+\",0], 2 => [\"-\",1]}\n  def self.from_int(value)\n    n = value.to_i\n    digits = \"\"\n    while n != 0\n      quo, rem = n.divmod(3)\n      bt, carry = I2BT[rem]\n      digits = bt + digits\n      n = quo + carry\n    end\n    new(digits)\n  end\n  \n  BT2I = {\"-\" => -1, \"0\" => 0, \"+\" => 1}\n  def to_int\n    @digits.chars.inject(0) do |sum, char|\n      sum = 3 * sum + BT2I[char]\n    end\n  end\n  alias :to_i :to_int\n  \n  def to_s\n    @digits.dup                 \n  end\n  alias :inspect :to_s\n  \n  def <=>(other)\n    to_i <=> other.to_i\n  end\n  \n  ADDITION_TABLE = {\n    \"---\" => [\"-\",\"0\"], \"--0\" => [\"-\",\"+\"], \"--+\" => [\"0\",\"-\"],\n    \"-0-\" => [\"-\",\"+\"], \"-00\" => [\"0\",\"-\"], \"-0+\" => [\"0\",\"0\"],\n    \"-+-\" => [\"0\",\"-\"], \"-+0\" => [\"0\",\"0\"], \"-++\" => [\"0\",\"+\"],\n    \"0--\" => [\"-\",\"+\"], \"0-0\" => [\"0\",\"-\"], \"0-+\" => [\"0\",\"0\"],\n    \"00-\" => [\"0\",\"-\"], \"000\" => [\"0\",\"0\"], \"00+\" => [\"0\",\"+\"],\n    \"0+-\" => [\"0\",\"0\"], \"0+0\" => [\"0\",\"+\"], \"0++\" => [\"+\",\"-\"],\n    \"+--\" => [\"0\",\"-\"], \"+-0\" => [\"0\",\"0\"], \"+-+\" => [\"0\",\"+\"],\n    \"+0-\" => [\"0\",\"0\"], \"+00\" => [\"0\",\"+\"], \"+0+\" => [\"+\",\"-\"],\n    \"++-\" => [\"0\",\"+\"], \"++0\" => [\"+\",\"-\"], \"+++\" => [\"+\",\"0\"],\n  }\n  \n  def +(other)\n    maxl = [to_s.length, other.to_s.length].max\n    a = pad0_reverse(to_s, maxl)\n    b = pad0_reverse(other.to_s, maxl)\n    carry = \"0\"\n    sum = a.zip( b ).inject(\"\") do |sum, (c1, c2)|\n      carry, digit = ADDITION_TABLE[carry + c1 + c2]\n      sum = digit + sum\n    end\n    self.class.new(carry + sum)\n  end\n  \n  MULTIPLICATION_TABLE = {\n    \"-\" => \"+0-\",\n    \"0\" => \"000\",\n    \"+\" => \"-0+\",\n  }\n  \n  def *(other)\n    product = self.class.new\n    other.to_s.each_char do |bdigit|\n      row = to_s.tr(\"-0+\", MULTIPLICATION_TABLE[bdigit])\n      product += self.class.new(row)\n      product << 1\n    end\n    product >> 1\n  end\n  \n  \n  def -@()\n    self.class.new(@digits.tr('-+','+-'))\n  end\n \n  \n  def -(other)\n    self + (-other)\n  end\n  \n  \n  def <<(count)\n    @digits = trim0(@digits + \"0\"*count)\n    self\n  end\n  \n  \n  def >>(count)\n    @digits[-count..-1] = \"\" if count > 0\n    @digits = trim0(@digits)\n    self\n  end\n  \n  private\n  \n  def trim0(str)\n    str = str.sub(/^0+/, \"\")\n    str = \"0\" if str.empty?\n    str\n  end\n  \n  def pad0_reverse(str, len)\n    str.rjust(len, \"0\").reverse.chars\n  end\nend\n\na = BalancedTernary.new(\"+-0++0+\")\nb = BalancedTernary.from_int(-436)\nc = BalancedTernary.new(\"+-++-\")\n\n%w[a b c a*(b-c)].each do |exp|\n  val = eval(exp)\n  puts \"%8s\u00a0:%13s,%8d\" % [exp, val, val.to_i]\nend\n", "target": "using System;\nusing System.Text;\nusing System.Collections.Generic;\n\npublic class BalancedTernary\n{\n\tpublic static void Main()\n\t{\n\t\tBalancedTernary a = new BalancedTernary(\"+-0++0+\");\n\t\tSystem.Console.WriteLine(\"a: \" + a + \" = \" + a.ToLong());\n\t\tBalancedTernary b = new BalancedTernary(-436);\n\t\tSystem.Console.WriteLine(\"b: \" + b + \" = \" + b.ToLong());\n\t\tBalancedTernary c = new BalancedTernary(\"+-++-\");\n\t\tSystem.Console.WriteLine(\"c: \" + c + \" = \" + c.ToLong());\n\t\tBalancedTernary d = a * (b - c);\n\t\tSystem.Console.WriteLine(\"a * (b - c): \" + d + \" = \" + d.ToLong());\n\t}\n\n\tprivate enum BalancedTernaryDigit\n\t{\n\t\tMINUS = -1,\n\t\tZERO = 0,\n\t\tPLUS = 1\n\t}\n\n\tprivate BalancedTernaryDigit[] value;\n\n\t\n\tpublic BalancedTernary()\n\t{\n\t\tthis.value = new BalancedTernaryDigit[0];\n\t}\n\n\t\n\tpublic BalancedTernary(String str)\n\t{\n\t\tthis.value = new BalancedTernaryDigit[str.Length];\n\t\tfor (int i = 0; i < str.Length; ++i)\n\t\t{\n\t\t\tswitch (str[i])\n\t\t\t{\n\t\t\t\tcase '-':\n\t\t\t\t\tthis.value[i] = BalancedTernaryDigit.MINUS;\n\t\t\t\t\tbreak;\n\t\t\t\tcase '0':\n\t\t\t\t\tthis.value[i] = BalancedTernaryDigit.ZERO;\n\t\t\t\t\tbreak;\n\t\t\t\tcase '+':\n\t\t\t\t\tthis.value[i] = BalancedTernaryDigit.PLUS;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tthrow new ArgumentException(\"Unknown Digit: \" + str[i]);\n\t\t\t}\n\t\t}\n\t\tArray.Reverse(this.value);\n\t}\n\n\t\n\tpublic BalancedTernary(long l)\n\t{\n\t\tList<BalancedTernaryDigit> value = new List<BalancedTernaryDigit>();\n\t\tint sign = Math.Sign(l);\n\t\tl = Math.Abs(l);\n\t\t\n\t\twhile (l != 0)\n\t\t{\n\t\t\tbyte rem = (byte)(l % 3);\n\t\t\tswitch (rem)\n\t\t\t{\n\t\t\t\tcase 0:\n\t\t\t\tcase 1:\n\t\t\t\t\tvalue.Add((BalancedTernaryDigit)rem);\n\t\t\t\t\tl /= 3;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 2:\n\t\t\t\t\tvalue.Add(BalancedTernaryDigit.MINUS);\n\t\t\t\t\tl = (l + 1) / 3;\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tthis.value = value.ToArray();\n\t\tif (sign < 0)\n\t\t{\n\t\t\tthis.Invert();\n\t\t}\n\t}\n\n\t\n\tpublic BalancedTernary(BalancedTernary origin)\n\t{\n\t\tthis.value = new BalancedTernaryDigit[origin.value.Length];\n\t\tArray.Copy(origin.value, this.value, origin.value.Length);\n\t}\n\n\t\n\tprivate BalancedTernary(BalancedTernaryDigit[] value)\n\t{\n\t\tint end = value.Length - 1;\n\t\twhile (value[end] == BalancedTernaryDigit.ZERO)\n\t\t\t--end;\n\t\tthis.value = new BalancedTernaryDigit[end + 1];\n\t\tArray.Copy(value, this.value, end + 1);\n\t}\n\n\t\n\tprivate void Invert()\n\t{\n\t\tfor (int i=0; i < this.value.Length; ++i)\n\t\t{\n\t\t\tthis.value[i] = (BalancedTernaryDigit)(-(int)this.value[i]);\n\t\t}\n\t}\n\n\t\n\toverride public String ToString()\n\t{\n\t\tStringBuilder result = new StringBuilder();\n\t\tfor (int i = this.value.Length - 1; i >= 0; --i)\n\t\t{\n\t\t\tswitch (this.value[i])\n\t\t\t{\n\t\t\t\tcase BalancedTernaryDigit.MINUS:\n\t\t\t\t\tresult.Append('-');\n\t\t\t\t\tbreak;\n\t\t\t\tcase BalancedTernaryDigit.ZERO:\n\t\t\t\t\tresult.Append('0');\n\t\t\t\t\tbreak;\n\t\t\t\tcase BalancedTernaryDigit.PLUS:\n\t\t\t\t\tresult.Append('+');\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn result.ToString();\n\t}\n\n\t\n\tpublic long ToLong()\n\t{\n\t\tlong result = 0;\n\t\tint digit;\n\t\tfor (int i = 0; i < this.value.Length; ++i)\n\t\t{\n\t\t\tresult += (long)this.value[i] * (long)Math.Pow(3.0, (double)i);\n\t\t}\n\t\treturn result;\n\t}\n\n\t\n\tpublic static BalancedTernary operator -(BalancedTernary origin)\n\t{\n\t\tBalancedTernary result = new BalancedTernary(origin);\n\t\tresult.Invert();\n\t\treturn result;\n\t}\n\n\t\n\tprivate static BalancedTernaryDigit carry = BalancedTernaryDigit.ZERO;\n\tprivate static BalancedTernaryDigit Add(BalancedTernaryDigit a, BalancedTernaryDigit b)\n\t{\n\t\tif (a != b)\n\t\t{\n\t\t\tcarry = BalancedTernaryDigit.ZERO;\n\t\t\treturn (BalancedTernaryDigit)((int)a + (int)b);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tcarry = a;\n\t\t\treturn (BalancedTernaryDigit)(-(int)b);\n\t\t}\n\t}\n\n\t\n\tpublic static BalancedTernary operator +(BalancedTernary a, BalancedTernary b)\n\t{\n\t\tint maxLength = Math.Max(a.value.Length, b.value.Length);\n\t\tBalancedTernaryDigit[] resultValue = new BalancedTernaryDigit[maxLength + 1];\n\t\tfor (int i=0; i < maxLength; ++i)\n\t\t{\n\t\t\tif (i < a.value.Length)\n\t\t\t{\n\t\t\t\tresultValue[i] = Add(resultValue[i], a.value[i]);\n\t\t\t\tresultValue[i+1] = carry;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tcarry = BalancedTernaryDigit.ZERO;\n\t\t\t}\n\t\t\t\n\t\t\tif (i < b.value.Length)\n\t\t\t{\n\t\t\t\tresultValue[i] = Add(resultValue[i], b.value[i]);\n\t\t\t\tresultValue[i+1] = Add(resultValue[i+1], carry);\n\t\t\t}\n\t\t}\n\t\treturn new BalancedTernary(resultValue);\n\t}\n\n\t\n\tpublic static BalancedTernary operator -(BalancedTernary a, BalancedTernary b)\n\t{\n\t\treturn a + (-b);\n\t}\n\n\t\n\tpublic static BalancedTernary operator *(BalancedTernary a, BalancedTernary b)\n\t{\n\t\tBalancedTernaryDigit[] longValue = a.value;\n\t\tBalancedTernaryDigit[] shortValue = b.value;\n\t\tBalancedTernary result = new BalancedTernary();\n\t\tif (a.value.Length < b.value.Length)\n\t\t{\n\t\t\tlongValue = b.value;\n\t\t\tshortValue = a.value;\n\t\t}\n\n\t\tfor (int i = 0; i < shortValue.Length; ++i)\n\t\t{\n\t\t\tif (shortValue[i] != BalancedTernaryDigit.ZERO)\n\t\t\t{\n\t\t\t\tBalancedTernaryDigit[] temp = new BalancedTernaryDigit[i + longValue.Length];\n\t\t\t\tfor (int j = 0; j < longValue.Length; ++j)\n\t\t\t\t{\n\t\t\t\t\ttemp[i+j] = (BalancedTernaryDigit)((int)shortValue[i] * (int)longValue[j]);\n\t\t\t\t}\n\t\t\t\tresult = result + new BalancedTernary(temp);\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n}\n"}
{"id": 5518, "name": "Balanced ternary", "source": "Translate Ruby to Java: class BalancedTernary\n  include Comparable\n  def initialize(str = \"\")\n    if str =~ /[^-+0]+/\n      raise ArgumentError, \"invalid BalancedTernary number: \n    end\n    @digits = trim0(str)\n  end\n   \n  I2BT = {0 => [\"0\",0], 1 => [\"+\",0], 2 => [\"-\",1]}\n  def self.from_int(value)\n    n = value.to_i\n    digits = \"\"\n    while n != 0\n      quo, rem = n.divmod(3)\n      bt, carry = I2BT[rem]\n      digits = bt + digits\n      n = quo + carry\n    end\n    new(digits)\n  end\n  \n  BT2I = {\"-\" => -1, \"0\" => 0, \"+\" => 1}\n  def to_int\n    @digits.chars.inject(0) do |sum, char|\n      sum = 3 * sum + BT2I[char]\n    end\n  end\n  alias :to_i :to_int\n  \n  def to_s\n    @digits.dup                 \n  end\n  alias :inspect :to_s\n  \n  def <=>(other)\n    to_i <=> other.to_i\n  end\n  \n  ADDITION_TABLE = {\n    \"---\" => [\"-\",\"0\"], \"--0\" => [\"-\",\"+\"], \"--+\" => [\"0\",\"-\"],\n    \"-0-\" => [\"-\",\"+\"], \"-00\" => [\"0\",\"-\"], \"-0+\" => [\"0\",\"0\"],\n    \"-+-\" => [\"0\",\"-\"], \"-+0\" => [\"0\",\"0\"], \"-++\" => [\"0\",\"+\"],\n    \"0--\" => [\"-\",\"+\"], \"0-0\" => [\"0\",\"-\"], \"0-+\" => [\"0\",\"0\"],\n    \"00-\" => [\"0\",\"-\"], \"000\" => [\"0\",\"0\"], \"00+\" => [\"0\",\"+\"],\n    \"0+-\" => [\"0\",\"0\"], \"0+0\" => [\"0\",\"+\"], \"0++\" => [\"+\",\"-\"],\n    \"+--\" => [\"0\",\"-\"], \"+-0\" => [\"0\",\"0\"], \"+-+\" => [\"0\",\"+\"],\n    \"+0-\" => [\"0\",\"0\"], \"+00\" => [\"0\",\"+\"], \"+0+\" => [\"+\",\"-\"],\n    \"++-\" => [\"0\",\"+\"], \"++0\" => [\"+\",\"-\"], \"+++\" => [\"+\",\"0\"],\n  }\n  \n  def +(other)\n    maxl = [to_s.length, other.to_s.length].max\n    a = pad0_reverse(to_s, maxl)\n    b = pad0_reverse(other.to_s, maxl)\n    carry = \"0\"\n    sum = a.zip( b ).inject(\"\") do |sum, (c1, c2)|\n      carry, digit = ADDITION_TABLE[carry + c1 + c2]\n      sum = digit + sum\n    end\n    self.class.new(carry + sum)\n  end\n  \n  MULTIPLICATION_TABLE = {\n    \"-\" => \"+0-\",\n    \"0\" => \"000\",\n    \"+\" => \"-0+\",\n  }\n  \n  def *(other)\n    product = self.class.new\n    other.to_s.each_char do |bdigit|\n      row = to_s.tr(\"-0+\", MULTIPLICATION_TABLE[bdigit])\n      product += self.class.new(row)\n      product << 1\n    end\n    product >> 1\n  end\n  \n  \n  def -@()\n    self.class.new(@digits.tr('-+','+-'))\n  end\n \n  \n  def -(other)\n    self + (-other)\n  end\n  \n  \n  def <<(count)\n    @digits = trim0(@digits + \"0\"*count)\n    self\n  end\n  \n  \n  def >>(count)\n    @digits[-count..-1] = \"\" if count > 0\n    @digits = trim0(@digits)\n    self\n  end\n  \n  private\n  \n  def trim0(str)\n    str = str.sub(/^0+/, \"\")\n    str = \"0\" if str.empty?\n    str\n  end\n  \n  def pad0_reverse(str, len)\n    str.rjust(len, \"0\").reverse.chars\n  end\nend\n\na = BalancedTernary.new(\"+-0++0+\")\nb = BalancedTernary.from_int(-436)\nc = BalancedTernary.new(\"+-++-\")\n\n%w[a b c a*(b-c)].each do |exp|\n  val = eval(exp)\n  puts \"%8s\u00a0:%13s,%8d\" % [exp, val, val.to_i]\nend\n", "target": "\npublic class BalancedTernary \n{\n\tpublic static void main(String[] args)\n\t{\n \t\tBTernary a=new BTernary(\"+-0++0+\");\n\t\tBTernary b=new BTernary(-436);\n\t\tBTernary c=new BTernary(\"+-++-\");\n\t\t\n\t\tSystem.out.println(\"a=\"+a.intValue());\n\t\tSystem.out.println(\"b=\"+b.intValue());\n\t\tSystem.out.println(\"c=\"+c.intValue());\n\t\tSystem.out.println();\n\t\t\n\t\t\n\t\tBTernary result=a.mul(b.sub(c));\n\t\t\n\t\tSystem.out.println(\"result= \"+result+\" \"+result.intValue());\n\t}\n\t\n\t\n\tpublic static class BTernary\n\t{\n\t\tString value;\n\t\tpublic BTernary(String s)\n\t\t{\n\t\t\tint i=0;\n\t\t\twhile(s.charAt(i)=='0')\n\t\t\t\ti++;\n\t\t\tthis.value=s.substring(i);\n\t\t}\n\t\tpublic BTernary(int v)\n\t\t{\n\t\t\tthis.value=\"\";\n\t\t\tthis.value=convertToBT(v);\n\t\t}\n\t\t\n\t\tprivate String convertToBT(int v)\n\t\t{\n\t\t\tif(v<0)\n\t\t\t\treturn flip(convertToBT(-v));\n\t\t\tif(v==0)\n\t\t\t\treturn \"\";\n\t\t\tint rem=mod3(v);\n\t\t\tif(rem==0)\n\t\t\t\treturn convertToBT(v/3)+\"0\";\n\t\t\tif(rem==1)\n\t\t\t\treturn convertToBT(v/3)+\"+\";\n\t\t\tif(rem==2)\n\t\t\t\treturn convertToBT((v+1)/3)+\"-\";\n\t\t\treturn \"You can't see me\";\n\t\t}\n\t\tprivate String flip(String s)\n\t\t{\n\t\t\tString flip=\"\";\n\t\t\tfor(int i=0;i<s.length();i++)\n\t\t\t{\n\t\t\t\tif(s.charAt(i)=='+')\n\t\t\t\t\tflip+='-';\n\t\t\t\telse if(s.charAt(i)=='-')\n\t\t\t\t\tflip+='+';\n\t\t\t\telse\n\t\t\t\t\tflip+='0';\n\t\t\t}\n\t\t\treturn flip;\n\t\t}\n\t\tprivate int mod3(int v)\n\t\t{\n\t\t\tif(v>0)\n\t\t\t\treturn v%3;\n\t\t\tv=v%3;\n\t\t\treturn (v+3)%3;\n\t\t}\n\t\t\n\t\tpublic int intValue()\n\t\t{\n\t\t\tint sum=0;\n\t\t\tString s=this.value;\n\t\t\tfor(int i=0;i<s.length();i++)\n\t\t\t{\n\t\t\t\tchar c=s.charAt(s.length()-i-1);\n\t\t\t\tint dig=0;\n\t\t\t\tif(c=='+')\n\t\t\t\t\tdig=1;\n\t\t\t\telse if(c=='-')\n\t\t\t\t\tdig=-1;\n\t\t\t\tsum+=dig*Math.pow(3, i);\n\t\t\t}\n\t\t\treturn sum;\n\t\t}\n\t\t\n\t\t\n\t\tpublic BTernary add(BTernary that)\n\t\t{\n\t\t\tString a=this.value;\n\t\t\tString b=that.value;\n\t\t\t\n\t\t\tString longer=a.length()>b.length()?a:b;\n\t\t\tString shorter=a.length()>b.length()?b:a;\n\t\t\t\n\t\t\twhile(shorter.length()<longer.length())\n\t\t\t\tshorter=0+shorter;\n\t\t\t\n\t\t\ta=longer;\n\t\t\tb=shorter;\n\t\t\t\n\t\t\tchar carry='0';\n\t\t\tString sum=\"\";\n\t\t\tfor(int i=0;i<a.length();i++)\n\t\t\t{\n\t\t\t\tint place=a.length()-i-1;\n\t\t\t\tString digisum=addDigits(a.charAt(place),b.charAt(place),carry);\n\t\t\t\tif(digisum.length()!=1)\n\t\t\t\t\tcarry=digisum.charAt(0);\n\t\t\t\telse\n\t\t\t\t\tcarry='0';\n\t\t\t\tsum=digisum.charAt(digisum.length()-1)+sum;\n\t\t\t}\n\t\t\tsum=carry+sum;\n\t\t\t\n\t\t\treturn new BTernary(sum);\n\t\t}\n\t\tprivate String addDigits(char a,char b,char carry)\n\t\t{\n\t\t\tString sum1=addDigits(a,b);\n\t\t\tString sum2=addDigits(sum1.charAt(sum1.length()-1),carry);\n\t\t\t\n\t\t\tif(sum1.length()==1)\n\t\t\t\treturn sum2;\n\t\t\tif(sum2.length()==1)\n\t\t\t\treturn sum1.charAt(0)+sum2;\n\t\t\treturn sum1.charAt(0)+\"\";\n\t\t}\n\t\tprivate String addDigits(char a,char b)\n\t\t{\n\t\t\tString sum=\"\";\n\t\t\tif(a=='0')\n\t\t\t\tsum=b+\"\";\n\t\t\telse if (b=='0')\n\t\t\t\tsum=a+\"\";\n\t\t\telse if(a=='+')\n\t\t\t{\n\t\t\t\tif(b=='+')\n\t\t\t\t\tsum=\"+-\";\n\t\t\t\telse\n\t\t\t\t\tsum=\"0\";\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif(b=='+')\n\t\t\t\t\tsum=\"0\";\n\t\t\t\telse\n\t\t\t\t\tsum=\"-+\";\n\t\t\t}\n\t\t\treturn sum;\n\t\t}\n\t\t\n\t\tpublic BTernary neg()\n\t\t{\n\t\t\treturn new BTernary(flip(this.value));\n\t\t}\n\t\t\n\t\tpublic BTernary sub(BTernary that)\n\t\t{\n\t\t\treturn this.add(that.neg());\n\t\t}\n\t\t\n\t\tpublic BTernary mul(BTernary that)\n\t\t{\n\t\t\tBTernary one=new BTernary(1);\n\t\t\tBTernary zero=new BTernary(0);\n\t\t\tBTernary mul=new BTernary(0);\n\t\t\t\n\t\t\tint flipflag=0;\n\t\t\tif(that.compareTo(zero)==-1)\n\t\t\t{\n\t\t\t\tthat=that.neg();\n\t\t\t\tflipflag=1;\n\t\t\t}\n\t\t\tfor(BTernary i=new BTernary(1);i.compareTo(that)<1;i=i.add(one))\n\t\t\t\tmul=mul.add(this);\n\t\t\t\n\t\t\tif(flipflag==1)\n\t\t\t\tmul=mul.neg();\n\t\t\treturn mul;\n\t\t}\n\t\t\n\t\tpublic boolean equals(BTernary that)\n\t\t{\n\t\t\treturn this.value.equals(that.value);\n\t\t}\n\t\tpublic int compareTo(BTernary that)\n\t\t{\n\t\t\tif(this.intValue()>that.intValue())\n\t\t\t\treturn 1;\n\t\t\telse if(this.equals(that))\n\t\t\t\treturn 0;\n\t\t\t return -1;\n\t\t}\n\t\t\n\t\tpublic String toString()\n\t\t{\n\t\t\treturn value;\n\t\t}\n\t}\n}\n"}
{"id": 5519, "name": "Balanced ternary", "source": "Translate Ruby to Java: class BalancedTernary\n  include Comparable\n  def initialize(str = \"\")\n    if str =~ /[^-+0]+/\n      raise ArgumentError, \"invalid BalancedTernary number: \n    end\n    @digits = trim0(str)\n  end\n   \n  I2BT = {0 => [\"0\",0], 1 => [\"+\",0], 2 => [\"-\",1]}\n  def self.from_int(value)\n    n = value.to_i\n    digits = \"\"\n    while n != 0\n      quo, rem = n.divmod(3)\n      bt, carry = I2BT[rem]\n      digits = bt + digits\n      n = quo + carry\n    end\n    new(digits)\n  end\n  \n  BT2I = {\"-\" => -1, \"0\" => 0, \"+\" => 1}\n  def to_int\n    @digits.chars.inject(0) do |sum, char|\n      sum = 3 * sum + BT2I[char]\n    end\n  end\n  alias :to_i :to_int\n  \n  def to_s\n    @digits.dup                 \n  end\n  alias :inspect :to_s\n  \n  def <=>(other)\n    to_i <=> other.to_i\n  end\n  \n  ADDITION_TABLE = {\n    \"---\" => [\"-\",\"0\"], \"--0\" => [\"-\",\"+\"], \"--+\" => [\"0\",\"-\"],\n    \"-0-\" => [\"-\",\"+\"], \"-00\" => [\"0\",\"-\"], \"-0+\" => [\"0\",\"0\"],\n    \"-+-\" => [\"0\",\"-\"], \"-+0\" => [\"0\",\"0\"], \"-++\" => [\"0\",\"+\"],\n    \"0--\" => [\"-\",\"+\"], \"0-0\" => [\"0\",\"-\"], \"0-+\" => [\"0\",\"0\"],\n    \"00-\" => [\"0\",\"-\"], \"000\" => [\"0\",\"0\"], \"00+\" => [\"0\",\"+\"],\n    \"0+-\" => [\"0\",\"0\"], \"0+0\" => [\"0\",\"+\"], \"0++\" => [\"+\",\"-\"],\n    \"+--\" => [\"0\",\"-\"], \"+-0\" => [\"0\",\"0\"], \"+-+\" => [\"0\",\"+\"],\n    \"+0-\" => [\"0\",\"0\"], \"+00\" => [\"0\",\"+\"], \"+0+\" => [\"+\",\"-\"],\n    \"++-\" => [\"0\",\"+\"], \"++0\" => [\"+\",\"-\"], \"+++\" => [\"+\",\"0\"],\n  }\n  \n  def +(other)\n    maxl = [to_s.length, other.to_s.length].max\n    a = pad0_reverse(to_s, maxl)\n    b = pad0_reverse(other.to_s, maxl)\n    carry = \"0\"\n    sum = a.zip( b ).inject(\"\") do |sum, (c1, c2)|\n      carry, digit = ADDITION_TABLE[carry + c1 + c2]\n      sum = digit + sum\n    end\n    self.class.new(carry + sum)\n  end\n  \n  MULTIPLICATION_TABLE = {\n    \"-\" => \"+0-\",\n    \"0\" => \"000\",\n    \"+\" => \"-0+\",\n  }\n  \n  def *(other)\n    product = self.class.new\n    other.to_s.each_char do |bdigit|\n      row = to_s.tr(\"-0+\", MULTIPLICATION_TABLE[bdigit])\n      product += self.class.new(row)\n      product << 1\n    end\n    product >> 1\n  end\n  \n  \n  def -@()\n    self.class.new(@digits.tr('-+','+-'))\n  end\n \n  \n  def -(other)\n    self + (-other)\n  end\n  \n  \n  def <<(count)\n    @digits = trim0(@digits + \"0\"*count)\n    self\n  end\n  \n  \n  def >>(count)\n    @digits[-count..-1] = \"\" if count > 0\n    @digits = trim0(@digits)\n    self\n  end\n  \n  private\n  \n  def trim0(str)\n    str = str.sub(/^0+/, \"\")\n    str = \"0\" if str.empty?\n    str\n  end\n  \n  def pad0_reverse(str, len)\n    str.rjust(len, \"0\").reverse.chars\n  end\nend\n\na = BalancedTernary.new(\"+-0++0+\")\nb = BalancedTernary.from_int(-436)\nc = BalancedTernary.new(\"+-++-\")\n\n%w[a b c a*(b-c)].each do |exp|\n  val = eval(exp)\n  puts \"%8s\u00a0:%13s,%8d\" % [exp, val, val.to_i]\nend\n", "target": "\npublic class BalancedTernary \n{\n\tpublic static void main(String[] args)\n\t{\n \t\tBTernary a=new BTernary(\"+-0++0+\");\n\t\tBTernary b=new BTernary(-436);\n\t\tBTernary c=new BTernary(\"+-++-\");\n\t\t\n\t\tSystem.out.println(\"a=\"+a.intValue());\n\t\tSystem.out.println(\"b=\"+b.intValue());\n\t\tSystem.out.println(\"c=\"+c.intValue());\n\t\tSystem.out.println();\n\t\t\n\t\t\n\t\tBTernary result=a.mul(b.sub(c));\n\t\t\n\t\tSystem.out.println(\"result= \"+result+\" \"+result.intValue());\n\t}\n\t\n\t\n\tpublic static class BTernary\n\t{\n\t\tString value;\n\t\tpublic BTernary(String s)\n\t\t{\n\t\t\tint i=0;\n\t\t\twhile(s.charAt(i)=='0')\n\t\t\t\ti++;\n\t\t\tthis.value=s.substring(i);\n\t\t}\n\t\tpublic BTernary(int v)\n\t\t{\n\t\t\tthis.value=\"\";\n\t\t\tthis.value=convertToBT(v);\n\t\t}\n\t\t\n\t\tprivate String convertToBT(int v)\n\t\t{\n\t\t\tif(v<0)\n\t\t\t\treturn flip(convertToBT(-v));\n\t\t\tif(v==0)\n\t\t\t\treturn \"\";\n\t\t\tint rem=mod3(v);\n\t\t\tif(rem==0)\n\t\t\t\treturn convertToBT(v/3)+\"0\";\n\t\t\tif(rem==1)\n\t\t\t\treturn convertToBT(v/3)+\"+\";\n\t\t\tif(rem==2)\n\t\t\t\treturn convertToBT((v+1)/3)+\"-\";\n\t\t\treturn \"You can't see me\";\n\t\t}\n\t\tprivate String flip(String s)\n\t\t{\n\t\t\tString flip=\"\";\n\t\t\tfor(int i=0;i<s.length();i++)\n\t\t\t{\n\t\t\t\tif(s.charAt(i)=='+')\n\t\t\t\t\tflip+='-';\n\t\t\t\telse if(s.charAt(i)=='-')\n\t\t\t\t\tflip+='+';\n\t\t\t\telse\n\t\t\t\t\tflip+='0';\n\t\t\t}\n\t\t\treturn flip;\n\t\t}\n\t\tprivate int mod3(int v)\n\t\t{\n\t\t\tif(v>0)\n\t\t\t\treturn v%3;\n\t\t\tv=v%3;\n\t\t\treturn (v+3)%3;\n\t\t}\n\t\t\n\t\tpublic int intValue()\n\t\t{\n\t\t\tint sum=0;\n\t\t\tString s=this.value;\n\t\t\tfor(int i=0;i<s.length();i++)\n\t\t\t{\n\t\t\t\tchar c=s.charAt(s.length()-i-1);\n\t\t\t\tint dig=0;\n\t\t\t\tif(c=='+')\n\t\t\t\t\tdig=1;\n\t\t\t\telse if(c=='-')\n\t\t\t\t\tdig=-1;\n\t\t\t\tsum+=dig*Math.pow(3, i);\n\t\t\t}\n\t\t\treturn sum;\n\t\t}\n\t\t\n\t\t\n\t\tpublic BTernary add(BTernary that)\n\t\t{\n\t\t\tString a=this.value;\n\t\t\tString b=that.value;\n\t\t\t\n\t\t\tString longer=a.length()>b.length()?a:b;\n\t\t\tString shorter=a.length()>b.length()?b:a;\n\t\t\t\n\t\t\twhile(shorter.length()<longer.length())\n\t\t\t\tshorter=0+shorter;\n\t\t\t\n\t\t\ta=longer;\n\t\t\tb=shorter;\n\t\t\t\n\t\t\tchar carry='0';\n\t\t\tString sum=\"\";\n\t\t\tfor(int i=0;i<a.length();i++)\n\t\t\t{\n\t\t\t\tint place=a.length()-i-1;\n\t\t\t\tString digisum=addDigits(a.charAt(place),b.charAt(place),carry);\n\t\t\t\tif(digisum.length()!=1)\n\t\t\t\t\tcarry=digisum.charAt(0);\n\t\t\t\telse\n\t\t\t\t\tcarry='0';\n\t\t\t\tsum=digisum.charAt(digisum.length()-1)+sum;\n\t\t\t}\n\t\t\tsum=carry+sum;\n\t\t\t\n\t\t\treturn new BTernary(sum);\n\t\t}\n\t\tprivate String addDigits(char a,char b,char carry)\n\t\t{\n\t\t\tString sum1=addDigits(a,b);\n\t\t\tString sum2=addDigits(sum1.charAt(sum1.length()-1),carry);\n\t\t\t\n\t\t\tif(sum1.length()==1)\n\t\t\t\treturn sum2;\n\t\t\tif(sum2.length()==1)\n\t\t\t\treturn sum1.charAt(0)+sum2;\n\t\t\treturn sum1.charAt(0)+\"\";\n\t\t}\n\t\tprivate String addDigits(char a,char b)\n\t\t{\n\t\t\tString sum=\"\";\n\t\t\tif(a=='0')\n\t\t\t\tsum=b+\"\";\n\t\t\telse if (b=='0')\n\t\t\t\tsum=a+\"\";\n\t\t\telse if(a=='+')\n\t\t\t{\n\t\t\t\tif(b=='+')\n\t\t\t\t\tsum=\"+-\";\n\t\t\t\telse\n\t\t\t\t\tsum=\"0\";\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif(b=='+')\n\t\t\t\t\tsum=\"0\";\n\t\t\t\telse\n\t\t\t\t\tsum=\"-+\";\n\t\t\t}\n\t\t\treturn sum;\n\t\t}\n\t\t\n\t\tpublic BTernary neg()\n\t\t{\n\t\t\treturn new BTernary(flip(this.value));\n\t\t}\n\t\t\n\t\tpublic BTernary sub(BTernary that)\n\t\t{\n\t\t\treturn this.add(that.neg());\n\t\t}\n\t\t\n\t\tpublic BTernary mul(BTernary that)\n\t\t{\n\t\t\tBTernary one=new BTernary(1);\n\t\t\tBTernary zero=new BTernary(0);\n\t\t\tBTernary mul=new BTernary(0);\n\t\t\t\n\t\t\tint flipflag=0;\n\t\t\tif(that.compareTo(zero)==-1)\n\t\t\t{\n\t\t\t\tthat=that.neg();\n\t\t\t\tflipflag=1;\n\t\t\t}\n\t\t\tfor(BTernary i=new BTernary(1);i.compareTo(that)<1;i=i.add(one))\n\t\t\t\tmul=mul.add(this);\n\t\t\t\n\t\t\tif(flipflag==1)\n\t\t\t\tmul=mul.neg();\n\t\t\treturn mul;\n\t\t}\n\t\t\n\t\tpublic boolean equals(BTernary that)\n\t\t{\n\t\t\treturn this.value.equals(that.value);\n\t\t}\n\t\tpublic int compareTo(BTernary that)\n\t\t{\n\t\t\tif(this.intValue()>that.intValue())\n\t\t\t\treturn 1;\n\t\t\telse if(this.equals(that))\n\t\t\t\treturn 0;\n\t\t\t return -1;\n\t\t}\n\t\t\n\t\tpublic String toString()\n\t\t{\n\t\t\treturn value;\n\t\t}\n\t}\n}\n"}
{"id": 5520, "name": "Balanced ternary", "source": "Translate Ruby to Python: class BalancedTernary\n  include Comparable\n  def initialize(str = \"\")\n    if str =~ /[^-+0]+/\n      raise ArgumentError, \"invalid BalancedTernary number: \n    end\n    @digits = trim0(str)\n  end\n   \n  I2BT = {0 => [\"0\",0], 1 => [\"+\",0], 2 => [\"-\",1]}\n  def self.from_int(value)\n    n = value.to_i\n    digits = \"\"\n    while n != 0\n      quo, rem = n.divmod(3)\n      bt, carry = I2BT[rem]\n      digits = bt + digits\n      n = quo + carry\n    end\n    new(digits)\n  end\n  \n  BT2I = {\"-\" => -1, \"0\" => 0, \"+\" => 1}\n  def to_int\n    @digits.chars.inject(0) do |sum, char|\n      sum = 3 * sum + BT2I[char]\n    end\n  end\n  alias :to_i :to_int\n  \n  def to_s\n    @digits.dup                 \n  end\n  alias :inspect :to_s\n  \n  def <=>(other)\n    to_i <=> other.to_i\n  end\n  \n  ADDITION_TABLE = {\n    \"---\" => [\"-\",\"0\"], \"--0\" => [\"-\",\"+\"], \"--+\" => [\"0\",\"-\"],\n    \"-0-\" => [\"-\",\"+\"], \"-00\" => [\"0\",\"-\"], \"-0+\" => [\"0\",\"0\"],\n    \"-+-\" => [\"0\",\"-\"], \"-+0\" => [\"0\",\"0\"], \"-++\" => [\"0\",\"+\"],\n    \"0--\" => [\"-\",\"+\"], \"0-0\" => [\"0\",\"-\"], \"0-+\" => [\"0\",\"0\"],\n    \"00-\" => [\"0\",\"-\"], \"000\" => [\"0\",\"0\"], \"00+\" => [\"0\",\"+\"],\n    \"0+-\" => [\"0\",\"0\"], \"0+0\" => [\"0\",\"+\"], \"0++\" => [\"+\",\"-\"],\n    \"+--\" => [\"0\",\"-\"], \"+-0\" => [\"0\",\"0\"], \"+-+\" => [\"0\",\"+\"],\n    \"+0-\" => [\"0\",\"0\"], \"+00\" => [\"0\",\"+\"], \"+0+\" => [\"+\",\"-\"],\n    \"++-\" => [\"0\",\"+\"], \"++0\" => [\"+\",\"-\"], \"+++\" => [\"+\",\"0\"],\n  }\n  \n  def +(other)\n    maxl = [to_s.length, other.to_s.length].max\n    a = pad0_reverse(to_s, maxl)\n    b = pad0_reverse(other.to_s, maxl)\n    carry = \"0\"\n    sum = a.zip( b ).inject(\"\") do |sum, (c1, c2)|\n      carry, digit = ADDITION_TABLE[carry + c1 + c2]\n      sum = digit + sum\n    end\n    self.class.new(carry + sum)\n  end\n  \n  MULTIPLICATION_TABLE = {\n    \"-\" => \"+0-\",\n    \"0\" => \"000\",\n    \"+\" => \"-0+\",\n  }\n  \n  def *(other)\n    product = self.class.new\n    other.to_s.each_char do |bdigit|\n      row = to_s.tr(\"-0+\", MULTIPLICATION_TABLE[bdigit])\n      product += self.class.new(row)\n      product << 1\n    end\n    product >> 1\n  end\n  \n  \n  def -@()\n    self.class.new(@digits.tr('-+','+-'))\n  end\n \n  \n  def -(other)\n    self + (-other)\n  end\n  \n  \n  def <<(count)\n    @digits = trim0(@digits + \"0\"*count)\n    self\n  end\n  \n  \n  def >>(count)\n    @digits[-count..-1] = \"\" if count > 0\n    @digits = trim0(@digits)\n    self\n  end\n  \n  private\n  \n  def trim0(str)\n    str = str.sub(/^0+/, \"\")\n    str = \"0\" if str.empty?\n    str\n  end\n  \n  def pad0_reverse(str, len)\n    str.rjust(len, \"0\").reverse.chars\n  end\nend\n\na = BalancedTernary.new(\"+-0++0+\")\nb = BalancedTernary.from_int(-436)\nc = BalancedTernary.new(\"+-++-\")\n\n%w[a b c a*(b-c)].each do |exp|\n  val = eval(exp)\n  puts \"%8s\u00a0:%13s,%8d\" % [exp, val, val.to_i]\nend\n", "target": "class BalancedTernary:\n    \n\n    str2dig = {'+': 1, '-': -1, '0': 0} \n    dig2str = {1: '+', -1: '-', 0: '0'} \n    table = ((0, -1), (1, -1), (-1, 0), (0, 0), (1, 0), (-1, 1), (0, 1)) \n\n    def __init__(self, inp):\n        if isinstance(inp, str):\n            self.digits = [BalancedTernary.str2dig[c] for c in reversed(inp)]\n        elif isinstance(inp, int):\n            self.digits = self._int2ternary(inp)\n        elif isinstance(inp, BalancedTernary):\n            self.digits = list(inp.digits)\n        elif isinstance(inp, list):\n            if all(d in (0, 1, -1) for d in inp):\n                self.digits = list(inp)\n            else:\n                raise ValueError(\"BalancedTernary: Wrong input digits.\")\n        else:\n            raise TypeError(\"BalancedTernary: Wrong constructor input.\")\n\n    @staticmethod\n    def _int2ternary(n):\n        if n == 0: return []\n        if (n % 3) == 0: return [0] + BalancedTernary._int2ternary(n // 3)\n        if (n % 3) == 1: return [1] + BalancedTernary._int2ternary(n // 3)\n        if (n % 3) == 2: return [-1] + BalancedTernary._int2ternary((n + 1) // 3)\n\n    def to_int(self):\n        return reduce(lambda y,x: x + 3 * y, reversed(self.digits), 0)\n\n    def __repr__(self):\n        if not self.digits: return \"0\"\n        return \"\".join(BalancedTernary.dig2str[d] for d in reversed(self.digits))\n\n    @staticmethod\n    def _neg(digs):\n        return [-d for d in digs]\n\n    def __neg__(self):\n        return BalancedTernary(BalancedTernary._neg(self.digits))\n\n    @staticmethod\n    def _add(a, b, c=0):\n        if not (a and b):\n            if c == 0:\n                return a or b\n            else:\n                return BalancedTernary._add([c], a or b)\n        else:\n            (d, c) = BalancedTernary.table[3 + (a[0] if a else 0) + (b[0] if b else 0) + c]\n            res = BalancedTernary._add(a[1:], b[1:], c)\n            \n            if res or d != 0:\n                return [d] + res\n            else:\n                return res\n\n    def __add__(self, b):\n        return BalancedTernary(BalancedTernary._add(self.digits, b.digits))\n\n    def __sub__(self, b):\n        return self + (-b)\n\n    @staticmethod\n    def _mul(a, b):\n        if not (a and b):\n            return []\n        else:\n            if   a[0] == -1: x = BalancedTernary._neg(b)\n            elif a[0] ==  0: x = []\n            elif a[0] ==  1: x = b\n            else: assert False\n            y = [0] + BalancedTernary._mul(a[1:], b)\n            return BalancedTernary._add(x, y)\n\n    def __mul__(self, b):\n        return BalancedTernary(BalancedTernary._mul(self.digits, b.digits))\n\n\ndef main():\n    a = BalancedTernary(\"+-0++0+\")\n    print \"a:\", a.to_int(), a\n\n    b = BalancedTernary(-436)\n    print \"b:\", b.to_int(), b\n\n    c = BalancedTernary(\"+-++-\")\n    print \"c:\", c.to_int(), c\n\n    r = a * (b - c)\n    print \"a * (b - c):\", r.to_int(), r\n\nmain()\n"}
{"id": 5521, "name": "Balanced ternary", "source": "Translate Ruby to Python: class BalancedTernary\n  include Comparable\n  def initialize(str = \"\")\n    if str =~ /[^-+0]+/\n      raise ArgumentError, \"invalid BalancedTernary number: \n    end\n    @digits = trim0(str)\n  end\n   \n  I2BT = {0 => [\"0\",0], 1 => [\"+\",0], 2 => [\"-\",1]}\n  def self.from_int(value)\n    n = value.to_i\n    digits = \"\"\n    while n != 0\n      quo, rem = n.divmod(3)\n      bt, carry = I2BT[rem]\n      digits = bt + digits\n      n = quo + carry\n    end\n    new(digits)\n  end\n  \n  BT2I = {\"-\" => -1, \"0\" => 0, \"+\" => 1}\n  def to_int\n    @digits.chars.inject(0) do |sum, char|\n      sum = 3 * sum + BT2I[char]\n    end\n  end\n  alias :to_i :to_int\n  \n  def to_s\n    @digits.dup                 \n  end\n  alias :inspect :to_s\n  \n  def <=>(other)\n    to_i <=> other.to_i\n  end\n  \n  ADDITION_TABLE = {\n    \"---\" => [\"-\",\"0\"], \"--0\" => [\"-\",\"+\"], \"--+\" => [\"0\",\"-\"],\n    \"-0-\" => [\"-\",\"+\"], \"-00\" => [\"0\",\"-\"], \"-0+\" => [\"0\",\"0\"],\n    \"-+-\" => [\"0\",\"-\"], \"-+0\" => [\"0\",\"0\"], \"-++\" => [\"0\",\"+\"],\n    \"0--\" => [\"-\",\"+\"], \"0-0\" => [\"0\",\"-\"], \"0-+\" => [\"0\",\"0\"],\n    \"00-\" => [\"0\",\"-\"], \"000\" => [\"0\",\"0\"], \"00+\" => [\"0\",\"+\"],\n    \"0+-\" => [\"0\",\"0\"], \"0+0\" => [\"0\",\"+\"], \"0++\" => [\"+\",\"-\"],\n    \"+--\" => [\"0\",\"-\"], \"+-0\" => [\"0\",\"0\"], \"+-+\" => [\"0\",\"+\"],\n    \"+0-\" => [\"0\",\"0\"], \"+00\" => [\"0\",\"+\"], \"+0+\" => [\"+\",\"-\"],\n    \"++-\" => [\"0\",\"+\"], \"++0\" => [\"+\",\"-\"], \"+++\" => [\"+\",\"0\"],\n  }\n  \n  def +(other)\n    maxl = [to_s.length, other.to_s.length].max\n    a = pad0_reverse(to_s, maxl)\n    b = pad0_reverse(other.to_s, maxl)\n    carry = \"0\"\n    sum = a.zip( b ).inject(\"\") do |sum, (c1, c2)|\n      carry, digit = ADDITION_TABLE[carry + c1 + c2]\n      sum = digit + sum\n    end\n    self.class.new(carry + sum)\n  end\n  \n  MULTIPLICATION_TABLE = {\n    \"-\" => \"+0-\",\n    \"0\" => \"000\",\n    \"+\" => \"-0+\",\n  }\n  \n  def *(other)\n    product = self.class.new\n    other.to_s.each_char do |bdigit|\n      row = to_s.tr(\"-0+\", MULTIPLICATION_TABLE[bdigit])\n      product += self.class.new(row)\n      product << 1\n    end\n    product >> 1\n  end\n  \n  \n  def -@()\n    self.class.new(@digits.tr('-+','+-'))\n  end\n \n  \n  def -(other)\n    self + (-other)\n  end\n  \n  \n  def <<(count)\n    @digits = trim0(@digits + \"0\"*count)\n    self\n  end\n  \n  \n  def >>(count)\n    @digits[-count..-1] = \"\" if count > 0\n    @digits = trim0(@digits)\n    self\n  end\n  \n  private\n  \n  def trim0(str)\n    str = str.sub(/^0+/, \"\")\n    str = \"0\" if str.empty?\n    str\n  end\n  \n  def pad0_reverse(str, len)\n    str.rjust(len, \"0\").reverse.chars\n  end\nend\n\na = BalancedTernary.new(\"+-0++0+\")\nb = BalancedTernary.from_int(-436)\nc = BalancedTernary.new(\"+-++-\")\n\n%w[a b c a*(b-c)].each do |exp|\n  val = eval(exp)\n  puts \"%8s\u00a0:%13s,%8d\" % [exp, val, val.to_i]\nend\n", "target": "class BalancedTernary:\n    \n\n    str2dig = {'+': 1, '-': -1, '0': 0} \n    dig2str = {1: '+', -1: '-', 0: '0'} \n    table = ((0, -1), (1, -1), (-1, 0), (0, 0), (1, 0), (-1, 1), (0, 1)) \n\n    def __init__(self, inp):\n        if isinstance(inp, str):\n            self.digits = [BalancedTernary.str2dig[c] for c in reversed(inp)]\n        elif isinstance(inp, int):\n            self.digits = self._int2ternary(inp)\n        elif isinstance(inp, BalancedTernary):\n            self.digits = list(inp.digits)\n        elif isinstance(inp, list):\n            if all(d in (0, 1, -1) for d in inp):\n                self.digits = list(inp)\n            else:\n                raise ValueError(\"BalancedTernary: Wrong input digits.\")\n        else:\n            raise TypeError(\"BalancedTernary: Wrong constructor input.\")\n\n    @staticmethod\n    def _int2ternary(n):\n        if n == 0: return []\n        if (n % 3) == 0: return [0] + BalancedTernary._int2ternary(n // 3)\n        if (n % 3) == 1: return [1] + BalancedTernary._int2ternary(n // 3)\n        if (n % 3) == 2: return [-1] + BalancedTernary._int2ternary((n + 1) // 3)\n\n    def to_int(self):\n        return reduce(lambda y,x: x + 3 * y, reversed(self.digits), 0)\n\n    def __repr__(self):\n        if not self.digits: return \"0\"\n        return \"\".join(BalancedTernary.dig2str[d] for d in reversed(self.digits))\n\n    @staticmethod\n    def _neg(digs):\n        return [-d for d in digs]\n\n    def __neg__(self):\n        return BalancedTernary(BalancedTernary._neg(self.digits))\n\n    @staticmethod\n    def _add(a, b, c=0):\n        if not (a and b):\n            if c == 0:\n                return a or b\n            else:\n                return BalancedTernary._add([c], a or b)\n        else:\n            (d, c) = BalancedTernary.table[3 + (a[0] if a else 0) + (b[0] if b else 0) + c]\n            res = BalancedTernary._add(a[1:], b[1:], c)\n            \n            if res or d != 0:\n                return [d] + res\n            else:\n                return res\n\n    def __add__(self, b):\n        return BalancedTernary(BalancedTernary._add(self.digits, b.digits))\n\n    def __sub__(self, b):\n        return self + (-b)\n\n    @staticmethod\n    def _mul(a, b):\n        if not (a and b):\n            return []\n        else:\n            if   a[0] == -1: x = BalancedTernary._neg(b)\n            elif a[0] ==  0: x = []\n            elif a[0] ==  1: x = b\n            else: assert False\n            y = [0] + BalancedTernary._mul(a[1:], b)\n            return BalancedTernary._add(x, y)\n\n    def __mul__(self, b):\n        return BalancedTernary(BalancedTernary._mul(self.digits, b.digits))\n\n\ndef main():\n    a = BalancedTernary(\"+-0++0+\")\n    print \"a:\", a.to_int(), a\n\n    b = BalancedTernary(-436)\n    print \"b:\", b.to_int(), b\n\n    c = BalancedTernary(\"+-++-\")\n    print \"c:\", c.to_int(), c\n\n    r = a * (b - c)\n    print \"a * (b - c):\", r.to_int(), r\n\nmain()\n"}
{"id": 5779, "name": "SHA-1", "source": "Translate Ruby to C#: require \"openssl\"\nputs OpenSSL::Digest.new(\"sha1\").update(\"Rosetta Code\")\n", "target": "using System;\nusing System.Security.Cryptography;\nusing System.Text;\nusing Microsoft.VisualStudio.TestTools.UnitTesting;\n\nnamespace RosettaCode.SHA1\n{\n    [TestClass]\n    public class SHA1CryptoServiceProviderTest\n    {\n        [TestMethod]\n        public void TestComputeHash()\n        {\n            var input = new UTF8Encoding().GetBytes(\"Rosetta Code\");\n            var output = new SHA1CryptoServiceProvider().ComputeHash(input);\n            Assert.AreEqual(\n                \"48-C9-8F-7E-5A-6E-73-6D-79-0A-B7-40-DF-C3-F5-1A-61-AB-E2-B5\",\n                BitConverter.ToString(output));\n        }\n    }\n}\n"}
{"id": 5780, "name": "SHA-1", "source": "Translate Ruby to C#: require \"openssl\"\nputs OpenSSL::Digest.new(\"sha1\").update(\"Rosetta Code\")\n", "target": "using System;\nusing System.Security.Cryptography;\nusing System.Text;\nusing Microsoft.VisualStudio.TestTools.UnitTesting;\n\nnamespace RosettaCode.SHA1\n{\n    [TestClass]\n    public class SHA1CryptoServiceProviderTest\n    {\n        [TestMethod]\n        public void TestComputeHash()\n        {\n            var input = new UTF8Encoding().GetBytes(\"Rosetta Code\");\n            var output = new SHA1CryptoServiceProvider().ComputeHash(input);\n            Assert.AreEqual(\n                \"48-C9-8F-7E-5A-6E-73-6D-79-0A-B7-40-DF-C3-F5-1A-61-AB-E2-B5\",\n                BitConverter.ToString(output));\n        }\n    }\n}\n"}
{"id": 5783, "name": "SHA-1", "source": "Translate Ruby to Python: require \"openssl\"\nputs OpenSSL::Digest.new(\"sha1\").update(\"Rosetta Code\")\n", "target": "import crypto { sha1 }\nlet hash = sha1.hexdigest('Ars longa, vita brevis')\nprint hash\n"}
{"id": 5784, "name": "SHA-1", "source": "Translate Ruby to Python: require \"openssl\"\nputs OpenSSL::Digest.new(\"sha1\").update(\"Rosetta Code\")\n", "target": "import crypto { sha1 }\nlet hash = sha1.hexdigest('Ars longa, vita brevis')\nprint hash\n"}
{"id": 6007, "name": "Subset sum problem", "source": "Translate Ruby to C#: weights = {\n  'alliance'   =>-624, 'archbishop'=>-915, 'balm'       => 397, 'bonnet'   => 452,\n  'brute'      => 870, 'centipede' =>-658, 'cobol'      => 362, 'covariate'=> 590,\n  'departure'  => 952, 'deploy'    =>  44, 'diophantine'=> 645, 'efferent' =>  54,\n  'elysee'     =>-326, 'eradicate' => 376, 'escritoire' => 856, 'exorcism' =>-983,\n  'fiat'       => 170, 'filmy'     =>-874, 'flatworm'   => 503, 'gestapo'  => 915,\n  'infra'      =>-847, 'isis'      =>-982, 'lindholm'   => 999, 'markham'  => 475,\n  'mincemeat'  =>-880, 'moresby'   => 756, 'mycenae'    => 183, 'plugging' =>-266,\n  'smokescreen'=> 423, 'speakeasy' =>-745, 'vein'       => 813,\n}\n\nwords = weights.keys\n1.upto(words.length) do |n|\n  zerosum = words.combination(n).find do |subset|\n    subset.reduce(0) {|sum, word| sum + weights[word]} == 0\n  end\n  \n  if zerosum\n    puts \"a subset of length \n  else\n    puts \"no subsets of length \n  end\nend\n", "target": "using System;\nusing System.Collections.Generic;\n\nnamespace SubsetSum {\n    class Item {\n        public Item(string word, int weight) {\n            Word = word;\n            Weight = weight;\n        }\n\n        public string Word { get; set; }\n        public int Weight { get; set; }\n\n        public override string ToString() {\n            return string.Format(\"({0}, {1})\", Word, Weight);\n        }\n    }\n\n    class Program {\n        private static readonly List<Item> items = new List<Item>() {\n            new Item(\"alliance\", -624),\n            new Item(\"archbishop\", -915),\n            new Item(\"balm\", 397),\n            new Item(\"bonnet\", 452),\n            new Item(\"brute\", 870),\n            new Item(\"centipede\", -658),\n            new Item(\"cobol\", 362),\n            new Item(\"covariate\", 590),\n            new Item(\"departure\", 952),\n            new Item(\"deploy\", 44),\n            new Item(\"diophantine\", 645),\n            new Item(\"efferent\", 54),\n            new Item(\"elysee\", -326),\n            new Item(\"eradicate\", 376),\n            new Item(\"escritoire\", 856),\n            new Item(\"exorcism\", -983),\n            new Item(\"fiat\", 170),\n            new Item(\"filmy\", -874),\n            new Item(\"flatworm\", 503),\n            new Item(\"gestapo\", 915),\n            new Item(\"infra\", -847),\n            new Item(\"isis\", -982),\n            new Item(\"lindholm\", 999),\n            new Item(\"markham\", 475),\n            new Item(\"mincemeat\", -880),\n            new Item(\"moresby\", 756),\n            new Item(\"mycenae\", 183),\n            new Item(\"plugging\", -266),\n            new Item(\"smokescreen\", 423),\n            new Item(\"speakeasy\", -745),\n            new Item(\"vein\", 813),\n        };\n\n        private static readonly int n = items.Count;\n        private static readonly int LIMIT = 5;\n\n        private static int[] indices = new int[n];\n        private static int count = 0;\n\n        private static void ZeroSum(int i, int w) {\n            if (i != 0 && w == 0) {\n                for (int j = 0; j < i; j++) {\n                    Console.Write(\"{0} \", items[indices[j]]);\n                }\n                Console.WriteLine(\"\\n\");\n                if (count < LIMIT) count++;\n                else return;\n            }\n            int k = (i != 0) ? indices[i - 1] + 1 : 0;\n            for (int j = k; j < n; j++) {\n                indices[i] = j;\n                ZeroSum(i + 1, w + items[j].Weight);\n                if (count == LIMIT) return;\n            }\n        }\n\n        static void Main(string[] args) {\n            Console.WriteLine(\"The weights of the following {0} subsets add up to zero:\\n\", LIMIT);\n            ZeroSum(0, 0);\n        }\n    }\n}\n"}
{"id": 6008, "name": "Subset sum problem", "source": "Translate Ruby to C#: weights = {\n  'alliance'   =>-624, 'archbishop'=>-915, 'balm'       => 397, 'bonnet'   => 452,\n  'brute'      => 870, 'centipede' =>-658, 'cobol'      => 362, 'covariate'=> 590,\n  'departure'  => 952, 'deploy'    =>  44, 'diophantine'=> 645, 'efferent' =>  54,\n  'elysee'     =>-326, 'eradicate' => 376, 'escritoire' => 856, 'exorcism' =>-983,\n  'fiat'       => 170, 'filmy'     =>-874, 'flatworm'   => 503, 'gestapo'  => 915,\n  'infra'      =>-847, 'isis'      =>-982, 'lindholm'   => 999, 'markham'  => 475,\n  'mincemeat'  =>-880, 'moresby'   => 756, 'mycenae'    => 183, 'plugging' =>-266,\n  'smokescreen'=> 423, 'speakeasy' =>-745, 'vein'       => 813,\n}\n\nwords = weights.keys\n1.upto(words.length) do |n|\n  zerosum = words.combination(n).find do |subset|\n    subset.reduce(0) {|sum, word| sum + weights[word]} == 0\n  end\n  \n  if zerosum\n    puts \"a subset of length \n  else\n    puts \"no subsets of length \n  end\nend\n", "target": "using System;\nusing System.Collections.Generic;\n\nnamespace SubsetSum {\n    class Item {\n        public Item(string word, int weight) {\n            Word = word;\n            Weight = weight;\n        }\n\n        public string Word { get; set; }\n        public int Weight { get; set; }\n\n        public override string ToString() {\n            return string.Format(\"({0}, {1})\", Word, Weight);\n        }\n    }\n\n    class Program {\n        private static readonly List<Item> items = new List<Item>() {\n            new Item(\"alliance\", -624),\n            new Item(\"archbishop\", -915),\n            new Item(\"balm\", 397),\n            new Item(\"bonnet\", 452),\n            new Item(\"brute\", 870),\n            new Item(\"centipede\", -658),\n            new Item(\"cobol\", 362),\n            new Item(\"covariate\", 590),\n            new Item(\"departure\", 952),\n            new Item(\"deploy\", 44),\n            new Item(\"diophantine\", 645),\n            new Item(\"efferent\", 54),\n            new Item(\"elysee\", -326),\n            new Item(\"eradicate\", 376),\n            new Item(\"escritoire\", 856),\n            new Item(\"exorcism\", -983),\n            new Item(\"fiat\", 170),\n            new Item(\"filmy\", -874),\n            new Item(\"flatworm\", 503),\n            new Item(\"gestapo\", 915),\n            new Item(\"infra\", -847),\n            new Item(\"isis\", -982),\n            new Item(\"lindholm\", 999),\n            new Item(\"markham\", 475),\n            new Item(\"mincemeat\", -880),\n            new Item(\"moresby\", 756),\n            new Item(\"mycenae\", 183),\n            new Item(\"plugging\", -266),\n            new Item(\"smokescreen\", 423),\n            new Item(\"speakeasy\", -745),\n            new Item(\"vein\", 813),\n        };\n\n        private static readonly int n = items.Count;\n        private static readonly int LIMIT = 5;\n\n        private static int[] indices = new int[n];\n        private static int count = 0;\n\n        private static void ZeroSum(int i, int w) {\n            if (i != 0 && w == 0) {\n                for (int j = 0; j < i; j++) {\n                    Console.Write(\"{0} \", items[indices[j]]);\n                }\n                Console.WriteLine(\"\\n\");\n                if (count < LIMIT) count++;\n                else return;\n            }\n            int k = (i != 0) ? indices[i - 1] + 1 : 0;\n            for (int j = k; j < n; j++) {\n                indices[i] = j;\n                ZeroSum(i + 1, w + items[j].Weight);\n                if (count == LIMIT) return;\n            }\n        }\n\n        static void Main(string[] args) {\n            Console.WriteLine(\"The weights of the following {0} subsets add up to zero:\\n\", LIMIT);\n            ZeroSum(0, 0);\n        }\n    }\n}\n"}
{"id": 6011, "name": "Subset sum problem", "source": "Translate Ruby to Java: weights = {\n  'alliance'   =>-624, 'archbishop'=>-915, 'balm'       => 397, 'bonnet'   => 452,\n  'brute'      => 870, 'centipede' =>-658, 'cobol'      => 362, 'covariate'=> 590,\n  'departure'  => 952, 'deploy'    =>  44, 'diophantine'=> 645, 'efferent' =>  54,\n  'elysee'     =>-326, 'eradicate' => 376, 'escritoire' => 856, 'exorcism' =>-983,\n  'fiat'       => 170, 'filmy'     =>-874, 'flatworm'   => 503, 'gestapo'  => 915,\n  'infra'      =>-847, 'isis'      =>-982, 'lindholm'   => 999, 'markham'  => 475,\n  'mincemeat'  =>-880, 'moresby'   => 756, 'mycenae'    => 183, 'plugging' =>-266,\n  'smokescreen'=> 423, 'speakeasy' =>-745, 'vein'       => 813,\n}\n\nwords = weights.keys\n1.upto(words.length) do |n|\n  zerosum = words.combination(n).find do |subset|\n    subset.reduce(0) {|sum, word| sum + weights[word]} == 0\n  end\n  \n  if zerosum\n    puts \"a subset of length \n  else\n    puts \"no subsets of length \n  end\nend\n", "target": "public class SubsetSum {\n    private static class Item {\n        private String word;\n        private int weight;\n\n        public Item(String word, int weight) {\n            this.word = word;\n            this.weight = weight;\n        }\n\n        @Override\n        public String toString() {\n            return String.format(\"(%s, %d)\", word, weight);\n        }\n    }\n\n    private static Item[] items = new Item[]{\n        new Item(\"alliance\", -624),\n        new Item(\"archbishop\", -915),\n        new Item(\"balm\", 397),\n        new Item(\"bonnet\", 452),\n        new Item(\"brute\", 870),\n        new Item(\"centipede\", -658),\n        new Item(\"cobol\", 362),\n        new Item(\"covariate\", 590),\n        new Item(\"departure\", 952),\n        new Item(\"deploy\", 44),\n        new Item(\"diophantine\", 645),\n        new Item(\"efferent\", 54),\n        new Item(\"elysee\", -326),\n        new Item(\"eradicate\", 376),\n        new Item(\"escritoire\", 856),\n        new Item(\"exorcism\", -983),\n        new Item(\"fiat\", 170),\n        new Item(\"filmy\", -874),\n        new Item(\"flatworm\", 503),\n        new Item(\"gestapo\", 915),\n        new Item(\"infra\", -847),\n        new Item(\"isis\", -982),\n        new Item(\"lindholm\", 999),\n        new Item(\"markham\", 475),\n        new Item(\"mincemeat\", -880),\n        new Item(\"moresby\", 756),\n        new Item(\"mycenae\", 183),\n        new Item(\"plugging\", -266),\n        new Item(\"smokescreen\", 423),\n        new Item(\"speakeasy\", -745),\n        new Item(\"vein\", 813),\n    };\n\n    private static final int n = items.length;\n    private static final int[] indices = new int[n];\n    private static int count = 0;\n\n    private static final int LIMIT = 5;\n\n    private static void zeroSum(int i, int w) {\n        if (i != 0 && w == 0) {\n            for (int j = 0; j < i; ++j) {\n                System.out.printf(\"%s \", items[indices[j]]);\n            }\n            System.out.println(\"\\n\");\n            if (count < LIMIT) count++;\n            else return;\n        }\n        int k = (i != 0) ? indices[i - 1] + 1 : 0;\n        for (int j = k; j < n; ++j) {\n            indices[i] = j;\n            zeroSum(i + 1, w + items[j].weight);\n            if (count == LIMIT) return;\n        }\n    }\n\n    public static void main(String[] args) {\n        System.out.printf(\"The weights of the following %d subsets add up to zero:\\n\\n\", LIMIT);\n        zeroSum(0, 0);\n    }\n}\n"}
{"id": 6012, "name": "Subset sum problem", "source": "Translate Ruby to Java: weights = {\n  'alliance'   =>-624, 'archbishop'=>-915, 'balm'       => 397, 'bonnet'   => 452,\n  'brute'      => 870, 'centipede' =>-658, 'cobol'      => 362, 'covariate'=> 590,\n  'departure'  => 952, 'deploy'    =>  44, 'diophantine'=> 645, 'efferent' =>  54,\n  'elysee'     =>-326, 'eradicate' => 376, 'escritoire' => 856, 'exorcism' =>-983,\n  'fiat'       => 170, 'filmy'     =>-874, 'flatworm'   => 503, 'gestapo'  => 915,\n  'infra'      =>-847, 'isis'      =>-982, 'lindholm'   => 999, 'markham'  => 475,\n  'mincemeat'  =>-880, 'moresby'   => 756, 'mycenae'    => 183, 'plugging' =>-266,\n  'smokescreen'=> 423, 'speakeasy' =>-745, 'vein'       => 813,\n}\n\nwords = weights.keys\n1.upto(words.length) do |n|\n  zerosum = words.combination(n).find do |subset|\n    subset.reduce(0) {|sum, word| sum + weights[word]} == 0\n  end\n  \n  if zerosum\n    puts \"a subset of length \n  else\n    puts \"no subsets of length \n  end\nend\n", "target": "public class SubsetSum {\n    private static class Item {\n        private String word;\n        private int weight;\n\n        public Item(String word, int weight) {\n            this.word = word;\n            this.weight = weight;\n        }\n\n        @Override\n        public String toString() {\n            return String.format(\"(%s, %d)\", word, weight);\n        }\n    }\n\n    private static Item[] items = new Item[]{\n        new Item(\"alliance\", -624),\n        new Item(\"archbishop\", -915),\n        new Item(\"balm\", 397),\n        new Item(\"bonnet\", 452),\n        new Item(\"brute\", 870),\n        new Item(\"centipede\", -658),\n        new Item(\"cobol\", 362),\n        new Item(\"covariate\", 590),\n        new Item(\"departure\", 952),\n        new Item(\"deploy\", 44),\n        new Item(\"diophantine\", 645),\n        new Item(\"efferent\", 54),\n        new Item(\"elysee\", -326),\n        new Item(\"eradicate\", 376),\n        new Item(\"escritoire\", 856),\n        new Item(\"exorcism\", -983),\n        new Item(\"fiat\", 170),\n        new Item(\"filmy\", -874),\n        new Item(\"flatworm\", 503),\n        new Item(\"gestapo\", 915),\n        new Item(\"infra\", -847),\n        new Item(\"isis\", -982),\n        new Item(\"lindholm\", 999),\n        new Item(\"markham\", 475),\n        new Item(\"mincemeat\", -880),\n        new Item(\"moresby\", 756),\n        new Item(\"mycenae\", 183),\n        new Item(\"plugging\", -266),\n        new Item(\"smokescreen\", 423),\n        new Item(\"speakeasy\", -745),\n        new Item(\"vein\", 813),\n    };\n\n    private static final int n = items.length;\n    private static final int[] indices = new int[n];\n    private static int count = 0;\n\n    private static final int LIMIT = 5;\n\n    private static void zeroSum(int i, int w) {\n        if (i != 0 && w == 0) {\n            for (int j = 0; j < i; ++j) {\n                System.out.printf(\"%s \", items[indices[j]]);\n            }\n            System.out.println(\"\\n\");\n            if (count < LIMIT) count++;\n            else return;\n        }\n        int k = (i != 0) ? indices[i - 1] + 1 : 0;\n        for (int j = k; j < n; ++j) {\n            indices[i] = j;\n            zeroSum(i + 1, w + items[j].weight);\n            if (count == LIMIT) return;\n        }\n    }\n\n    public static void main(String[] args) {\n        System.out.printf(\"The weights of the following %d subsets add up to zero:\\n\\n\", LIMIT);\n        zeroSum(0, 0);\n    }\n}\n"}
{"id": 6013, "name": "Subset sum problem", "source": "Translate Ruby to Python: weights = {\n  'alliance'   =>-624, 'archbishop'=>-915, 'balm'       => 397, 'bonnet'   => 452,\n  'brute'      => 870, 'centipede' =>-658, 'cobol'      => 362, 'covariate'=> 590,\n  'departure'  => 952, 'deploy'    =>  44, 'diophantine'=> 645, 'efferent' =>  54,\n  'elysee'     =>-326, 'eradicate' => 376, 'escritoire' => 856, 'exorcism' =>-983,\n  'fiat'       => 170, 'filmy'     =>-874, 'flatworm'   => 503, 'gestapo'  => 915,\n  'infra'      =>-847, 'isis'      =>-982, 'lindholm'   => 999, 'markham'  => 475,\n  'mincemeat'  =>-880, 'moresby'   => 756, 'mycenae'    => 183, 'plugging' =>-266,\n  'smokescreen'=> 423, 'speakeasy' =>-745, 'vein'       => 813,\n}\n\nwords = weights.keys\n1.upto(words.length) do |n|\n  zerosum = words.combination(n).find do |subset|\n    subset.reduce(0) {|sum, word| sum + weights[word]} == 0\n  end\n  \n  if zerosum\n    puts \"a subset of length \n  else\n    puts \"no subsets of length \n  end\nend\n", "target": "words = { \n\t\"alliance\": -624,\t\"archbishop\": -925,\t\"balm\":\t397,\n\t\"bonnet\": 452,\t\t\"brute\": 870,\t\t\"centipede\": -658,\n\t\"cobol\": 362,\t\t\"covariate\": 590,\t\"departure\": 952,\n\t\"deploy\": 44,\t\t\"diophantine\": 645,\t\"efferent\": 54,\n\t\"elysee\": -326,\t\t\"eradicate\": 376,\t\"escritoire\": 856,\n\t\"exorcism\": -983,\t\"fiat\": 170,\t\t\"filmy\": -874,\n\t\"flatworm\": 503,\t\"gestapo\": 915,\t\t\"infra\": -847,\n\t\"isis\": -982,\t\t\"lindholm\": 999,\t\"markham\": 475,\n\t\"mincemeat\": -880,\t\"moresby\": 756,\t\t\"mycenae\": 183,\n\t\"plugging\": -266,\t\"smokescreen\": 423,\t\"speakeasy\": -745,\n\t\"vein\": 813\n}\n\nneg = 0\npos = 0\nfor (w,v) in words.iteritems():\n\tif v > 0: pos += v\n\telse:     neg += v\n\nsums = [0] * (pos - neg + 1)\n\nfor (w,v) in words.iteritems():\n\ts = sums[:]\n\tif not s[v - neg]: s[v - neg] = (w,)\n\n\tfor (i, w2) in enumerate(sums):\n\t\tif w2 and not s[i + v]:\n\t\t\ts[i + v] = w2 + (w,)\n\n\tsums = s\n\tif s[-neg]:\n\t\tfor x in s[-neg]:\n\t\t\tprint(x, words[x])\n\t\tbreak\n"}
{"id": 6014, "name": "Subset sum problem", "source": "Translate Ruby to Python: weights = {\n  'alliance'   =>-624, 'archbishop'=>-915, 'balm'       => 397, 'bonnet'   => 452,\n  'brute'      => 870, 'centipede' =>-658, 'cobol'      => 362, 'covariate'=> 590,\n  'departure'  => 952, 'deploy'    =>  44, 'diophantine'=> 645, 'efferent' =>  54,\n  'elysee'     =>-326, 'eradicate' => 376, 'escritoire' => 856, 'exorcism' =>-983,\n  'fiat'       => 170, 'filmy'     =>-874, 'flatworm'   => 503, 'gestapo'  => 915,\n  'infra'      =>-847, 'isis'      =>-982, 'lindholm'   => 999, 'markham'  => 475,\n  'mincemeat'  =>-880, 'moresby'   => 756, 'mycenae'    => 183, 'plugging' =>-266,\n  'smokescreen'=> 423, 'speakeasy' =>-745, 'vein'       => 813,\n}\n\nwords = weights.keys\n1.upto(words.length) do |n|\n  zerosum = words.combination(n).find do |subset|\n    subset.reduce(0) {|sum, word| sum + weights[word]} == 0\n  end\n  \n  if zerosum\n    puts \"a subset of length \n  else\n    puts \"no subsets of length \n  end\nend\n", "target": "words = { \n\t\"alliance\": -624,\t\"archbishop\": -925,\t\"balm\":\t397,\n\t\"bonnet\": 452,\t\t\"brute\": 870,\t\t\"centipede\": -658,\n\t\"cobol\": 362,\t\t\"covariate\": 590,\t\"departure\": 952,\n\t\"deploy\": 44,\t\t\"diophantine\": 645,\t\"efferent\": 54,\n\t\"elysee\": -326,\t\t\"eradicate\": 376,\t\"escritoire\": 856,\n\t\"exorcism\": -983,\t\"fiat\": 170,\t\t\"filmy\": -874,\n\t\"flatworm\": 503,\t\"gestapo\": 915,\t\t\"infra\": -847,\n\t\"isis\": -982,\t\t\"lindholm\": 999,\t\"markham\": 475,\n\t\"mincemeat\": -880,\t\"moresby\": 756,\t\t\"mycenae\": 183,\n\t\"plugging\": -266,\t\"smokescreen\": 423,\t\"speakeasy\": -745,\n\t\"vein\": 813\n}\n\nneg = 0\npos = 0\nfor (w,v) in words.iteritems():\n\tif v > 0: pos += v\n\telse:     neg += v\n\nsums = [0] * (pos - neg + 1)\n\nfor (w,v) in words.iteritems():\n\ts = sums[:]\n\tif not s[v - neg]: s[v - neg] = (w,)\n\n\tfor (i, w2) in enumerate(sums):\n\t\tif w2 and not s[i + v]:\n\t\t\ts[i + v] = w2 + (w,)\n\n\tsums = s\n\tif s[-neg]:\n\t\tfor x in s[-neg]:\n\t\t\tprint(x, words[x])\n\t\tbreak\n"}
{"id": 6174, "name": "Man or boy test", "source": "Translate Ruby to C#: def a(k, x1, x2, x3, x4, x5)\n  b = uninitialized -> typeof(k)\n  b = ->() { k -= 1; a(k, b, x1, x2, x3, x4) }\n  k <= 0 ? x4.call + x5.call : b.call\nend\n\nputs a(10, -> {1}, -> {-1}, -> {-1}, -> {1}, -> {0})\n", "target": "using System;\n \ndelegate T Func<T>();\n \nclass ManOrBoy\n{\n    static void Main()\n    {\n        Console.WriteLine(A(10, C(1), C(-1), C(-1), C(1), C(0)));\n    }\n \n    static Func<int> C(int i)\n    {\n        return delegate { return i; };\n    }\n \n    static int A(int k, Func<int> x1, Func<int> x2, Func<int> x3, Func<int> x4, Func<int> x5)\n    {\n        Func<int> b = null;\n        b = delegate { k--; return A(k, b, x1, x2, x3, x4); };\n        return k <= 0 ? x4() + x5() : b();\n    }\n}\n"}
{"id": 6176, "name": "Man or boy test", "source": "Translate Ruby to Python: def a(k, x1, x2, x3, x4, x5)\n  b = uninitialized -> typeof(k)\n  b = ->() { k -= 1; a(k, b, x1, x2, x3, x4) }\n  k <= 0 ? x4.call + x5.call : b.call\nend\n\nputs a(10, -> {1}, -> {-1}, -> {-1}, -> {1}, -> {0})\n", "target": "\nimport sys\nsys.setrecursionlimit(1025)\n\ndef a(in_k, x1, x2, x3, x4, x5):\n    k = [in_k]\n    def b():\n        k[0] -= 1\n        return a(k[0], b, x1, x2, x3, x4)\n    return x4() + x5() if k[0] <= 0 else b()\n\nx = lambda i: lambda: i\nprint(a(10, x(1), x(-1), x(-1), x(1), x(0)))\n"}
{"id": 6410, "name": "Assertions", "source": "Translate Ruby to C#: class AssertionError < Exception\nend\n\ndef assert(predicate : Bool, msg = \"The asserted condition was false\")\n  raise AssertionError.new(msg) unless predicate\nend\n\nassert(12 == 42, \"It appears that 12 doesn't equal 42\")\n", "target": "using System.Diagnostics; \n\nstatic class Program\n{\n    static void Main()\n    {\n        int a = 0;\n\n        Console.WriteLine(\"Before\");\n\n        \n        Trace.Assert(a == 42, \"Trace assertion failed\");\n\n        Console.WriteLine(\"After Trace.Assert\");\n\n        \n        Debug.Assert(a == 42, \"Debug assertion failed\");\n\n        Console.WriteLine(\"After Debug.Assert\");\n    }\n}\n"}
{"id": 6412, "name": "Assertions", "source": "Translate Ruby to Python: class AssertionError < Exception\nend\n\ndef assert(predicate : Bool, msg = \"The asserted condition was false\")\n  raise AssertionError.new(msg) unless predicate\nend\n\nassert(12 == 42, \"It appears that 12 doesn't equal 42\")\n", "target": "a = 5\n\nassert a == 42 \nassert a == 42, \"Error message\" \n       \n       \n"}
{"id": 6680, "name": "Collections", "source": "Translate Ruby to C#: \na = []              \na[0] = 1            \na[3] = \"abc\"        \na << 3.14           \n\n\na = Array.new               \na = Array.new(3)            \na = Array.new(3, 0)         \na = Array.new(3){|i| i*2}   \n", "target": "\nint[] intArray = new int[5] { 1, 2, 3, 4, 5 };\n\nint[] intArray = new int[]{ 1, 2, 3, 4, 5 };\n\nint[] intArray = { 1, 2, 3, 4, 5 };\n\n\nstring[] stringArr = new string[5];\nstringArr[0] = \"string\";\n"}
{"id": 6682, "name": "Collections", "source": "Translate Ruby to Java: \na = []              \na[0] = 1            \na[3] = \"abc\"        \na << 3.14           \n\n\na = Array.new               \na = Array.new(3)            \na = Array.new(3, 0)         \na = Array.new(3){|i| i*2}   \n", "target": "List arrayList = new ArrayList();\narrayList.add(new Integer(0));\n\narrayList.add(0); \n\n\n\nList<Integer> myarrlist = new ArrayList<Integer>();\n\n\nint sum;\nfor(int i = 0; i < 10; i++) {\n    myarrlist.add(i);\n}\n"}
{"id": 6683, "name": "Collections", "source": "Translate Ruby to Python: \na = []              \na[0] = 1            \na[3] = \"abc\"        \na << 3.14           \n\n\na = Array.new               \na = Array.new(3)            \na = Array.new(3, 0)         \na = Array.new(3){|i| i*2}   \n", "target": "collection = [0, '1']                 \nx = collection[0]                     \ncollection.append(2)                  \ncollection.insert(0, '-1')            \ny = collection[0]                     \ncollection.extend([2,'3'])            \ncollection += [2,'3']                 \ncollection[2:6]                       \nlen(collection)                       \ncollection = (0, 1)                   \ncollection[:]                         \ncollection[-4:-1]                     \ncollection[::2]                       \ncollection=\"some string\"              \nx = collection[::-1]                  \ncollection[::2] == \"some string\"[::2] \ncollection.__getitem__(slice(0,len(collection),2))  \ncollection = {0: \"zero\", 1: \"one\"}    \ncollection['zero'] = 2                \ncollection = set([0, '1'])            \n"}
{"id": 6843, "name": "Matrix-exponentiation operator", "source": "Translate Ruby to C#: class Array {\n    method ** (Number n { .>= 0 }) {\n        var tmp = self\n        var out = self.len.of {|i| self.len.of {|j| i == j ? 1 : 0 }}\n        loop {\n            out = (out `mmul` tmp) if n.is_odd\n            n >>= 1 || break\n            tmp = (tmp `mmul` tmp)\n        }\n        return out\n    }\n}\n\nvar m = [[1, 2, 0],\n         [0, 3, 1],\n         [1, 0, 0]]\n\nfor order in (0..5) {\n    say \"\n    var t = (m ** order)\n    say ('  ', t.join(\"\\n  \"))\n}\n", "target": "using System;\nusing System.Collections;\nusing System.Collections.Generic;\nusing static System.Linq.Enumerable;\n\npublic static class MatrixExponentation\n{\n    public static double[,] Identity(int size) {\n        double[,] matrix = new double[size, size];\n        for (int i = 0; i < size; i++) matrix[i, i] = 1;\n        return matrix;\n    }\n\n    public static double[,] Multiply(this double[,] left, double[,] right) {\n        if (left.ColumnCount() != right.RowCount()) throw new ArgumentException();\n        double[,] m = new double[left.RowCount(), right.ColumnCount()];\n        foreach (var (row, column) in from r in Range(0, m.RowCount()) from c in Range(0, m.ColumnCount()) select (r, c)) {\n            m[row, column] = Range(0, m.RowCount()).Sum(i => left[row, i] * right[i, column]);\n        }\n        return m;\n    }\n\n    public static double[,] Pow(this double[,] matrix, int exp) {\n        if (matrix.RowCount() != matrix.ColumnCount()) throw new ArgumentException(\"Matrix must be square.\");\n        double[,] accumulator = Identity(matrix.RowCount());\n        for (int i = 0; i < exp; i++) {\n            accumulator = accumulator.Multiply(matrix);\n        }\n        return accumulator;\n    }\n\n    private static int RowCount(this double[,] matrix) => matrix.GetLength(0);\n    private static int ColumnCount(this double[,] matrix) => matrix.GetLength(1);\n\n    private static void Print(this double[,] m) {\n        foreach (var row in Rows()) {\n            Console.WriteLine(\"[ \" + string.Join(\"   \", row) + \" ]\");\n        }\n        Console.WriteLine();\n\n        IEnumerable<IEnumerable<double>> Rows() =>\n            Range(0, m.RowCount()).Select(row => Range(0, m.ColumnCount()).Select(column => m[row, column]));\n    }\n\n    public static void Main() {\n        var matrix = new double[,] {\n            { 3, 2 },\n            { 2, 1 }\n        };\n        \n        matrix.Pow(0).Print();\n        matrix.Pow(1).Print();\n        matrix.Pow(2).Print();\n        matrix.Pow(3).Print();\n        matrix.Pow(4).Print();\n        matrix.Pow(50).Print();\n    }\n\n}\n"}
{"id": 6845, "name": "Matrix-exponentiation operator", "source": "Translate Ruby to Python: class Array {\n    method ** (Number n { .>= 0 }) {\n        var tmp = self\n        var out = self.len.of {|i| self.len.of {|j| i == j ? 1 : 0 }}\n        loop {\n            out = (out `mmul` tmp) if n.is_odd\n            n >>= 1 || break\n            tmp = (tmp `mmul` tmp)\n        }\n        return out\n    }\n}\n\nvar m = [[1, 2, 0],\n         [0, 3, 1],\n         [1, 0, 0]]\n\nfor order in (0..5) {\n    say \"\n    var t = (m ** order)\n    say ('  ', t.join(\"\\n  \"))\n}\n", "target": ">>> from operator import mul\n>>> def matrixMul(m1, m2):\n  return map(\n    lambda row:\n      map(\n        lambda *column:\n          sum(map(mul, row, column)),\n        *m2),\n    m1)\n\n>>> def identity(size):\n\tsize = range(size)\n\treturn [[(i==j)*1 for i in size] for j in size]\n\n>>> def matrixExp(m, pow):\n\tassert pow>=0 and int(pow)==pow, \"Only non-negative, integer powers allowed\"\n\taccumulator = identity(len(m))\n\tfor i in range(pow):\n\t\taccumulator = matrixMul(accumulator, m)\n\treturn accumulator\n\n>>> def printtable(data):\n\tfor row in data:\n\t\tprint ' '.join('%-5s' % ('%s' % cell) for cell in row)\n\n\t\t\n>>> m = [[3,2], [2,1]]\n>>> for i in range(5):\n\tprint '\\n%i:' % i\n\tprinttable( matrixExp(m, i) )\n\n\t\n\n0:\n1     0    \n0     1    \n\n1:\n3     2    \n2     1    \n\n2:\n13    8    \n8     5    \n\n3:\n55    34   \n34    21   \n\n4:\n233   144  \n144   89   \n>>> printtable( matrixExp(m, 10) )\n1346269 832040\n832040 514229\n>>>\n"}
{"id": 7040, "name": "Tree traversal", "source": "Translate Ruby to C#: BinaryTreeNode = Struct.new(:value, :left, :right) do\n  def self.from_array(nested_list)\n    value, left, right = nested_list\n    if value \n      self.new(value, self.from_array(left), self.from_array(right))\n    end\n  end\n \n  def walk_nodes(order, &block)\n    order.each do |node|\n      case node\n      when :left  then left && left.walk_nodes(order, &block)\n      when :self  then yield self\n      when :right then right && right.walk_nodes(order, &block)\n      end\n    end\n  end\n \n  def each_preorder(&b)  walk_nodes([:self, :left, :right], &b) end\n  def each_inorder(&b)   walk_nodes([:left, :self, :right], &b) end\n  def each_postorder(&b) walk_nodes([:left, :right, :self], &b) end\n \n  def each_levelorder\n    queue = [self]\n    until queue.empty?\n      node = queue.shift\n      yield node\n      queue << node.left if node.left\n      queue << node.right if node.right\n    end\n  end\nend\n\nroot = BinaryTreeNode.from_array [1, [2, [4, 7], [5]], [3, [6, [8], [9]]]] \n\nBinaryTreeNode.instance_methods.select{|m| m=~/.+order/}.each do |mthd|\n  printf \"%-11s \", mthd[5..-1] + ':'\n  root.send(mthd) {|node| print \"\n  puts\nend\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\nclass Node\n{\n    int Value;\n    Node Left;\n    Node Right;\n\n    Node(int value = default(int), Node left = default(Node), Node right = default(Node))\n    {\n        Value = value;\n        Left = left;\n        Right = right;\n    }\n\n    IEnumerable<int> Preorder()\n    {\n        yield return Value;\n        if (Left != null)\n            foreach (var value in Left.Preorder())\n                yield return value;\n        if (Right != null)\n            foreach (var value in Right.Preorder())\n                yield return value;\n    }\n\n    IEnumerable<int> Inorder()\n    {\n        if (Left != null)\n            foreach (var value in Left.Inorder())\n                yield return value;\n        yield return Value;\n        if (Right != null)\n            foreach (var value in Right.Inorder())\n                yield return value;\n    }\n\n    IEnumerable<int> Postorder()\n    {\n        if (Left != null)\n            foreach (var value in Left.Postorder())\n                yield return value;\n        if (Right != null)\n            foreach (var value in Right.Postorder())\n                yield return value;\n        yield return Value;\n    }\n\n    IEnumerable<int> LevelOrder()\n    {\n        var queue = new Queue<Node>();\n        queue.Enqueue(this);\n        while (queue.Any())\n        {\n            var node = queue.Dequeue();\n            yield return node.Value;\n            if (node.Left != null)\n                queue.Enqueue(node.Left);\n            if (node.Right != null)\n                queue.Enqueue(node.Right);\n        }\n    }\n\n    static void Main()\n    {\n        var tree = new Node(1, new Node(2, new Node(4, new Node(7)), new Node(5)), new Node(3, new Node(6, new Node(8), new Node(9))));\n        foreach (var traversal in new Func<IEnumerable<int>>[] { tree.Preorder, tree.Inorder, tree.Postorder, tree.LevelOrder })\n            Console.WriteLine(\"{0}:\\t{1}\", traversal.Method.Name, string.Join(\" \", traversal()));\n    }\n}\n"}
{"id": 7042, "name": "Tree traversal", "source": "Translate Ruby to Java: BinaryTreeNode = Struct.new(:value, :left, :right) do\n  def self.from_array(nested_list)\n    value, left, right = nested_list\n    if value \n      self.new(value, self.from_array(left), self.from_array(right))\n    end\n  end\n \n  def walk_nodes(order, &block)\n    order.each do |node|\n      case node\n      when :left  then left && left.walk_nodes(order, &block)\n      when :self  then yield self\n      when :right then right && right.walk_nodes(order, &block)\n      end\n    end\n  end\n \n  def each_preorder(&b)  walk_nodes([:self, :left, :right], &b) end\n  def each_inorder(&b)   walk_nodes([:left, :self, :right], &b) end\n  def each_postorder(&b) walk_nodes([:left, :right, :self], &b) end\n \n  def each_levelorder\n    queue = [self]\n    until queue.empty?\n      node = queue.shift\n      yield node\n      queue << node.left if node.left\n      queue << node.right if node.right\n    end\n  end\nend\n\nroot = BinaryTreeNode.from_array [1, [2, [4, 7], [5]], [3, [6, [8], [9]]]] \n\nBinaryTreeNode.instance_methods.select{|m| m=~/.+order/}.each do |mthd|\n  printf \"%-11s \", mthd[5..-1] + ':'\n  root.send(mthd) {|node| print \"\n  puts\nend\n", "target": "import java.util.*;\n\npublic class TreeTraversal {\n\n        static class Node<T> {\n\t\tT value;\n\t\tNode<T> left;\n\t\tNode<T> right;\n\n\t\tNode(T value) {\n\t\t\tthis.value = value;\n\t\t}\n\n\t\tvoid visit() {\n\t\t\tSystem.out.print(this.value + \" \");\n\t\t}\n\t}\n\n\tstatic enum ORDER {\n\t\tPREORDER, INORDER, POSTORDER, LEVEL\n\t}\n        \n        static <T> void traverse(Node<T> node, ORDER order) {\n\t\tif (node == null) {\n\t\t\treturn;\n\t\t}\n\t\tswitch (order) {\n\t\tcase PREORDER:\n\t\t\tnode.visit();\n\t\t\ttraverse(node.left, order);\n\t\t\ttraverse(node.right, order);\n\t\t\tbreak;\n\t\tcase INORDER:\n\t\t\ttraverse(node.left, order);\n\t\t\tnode.visit();\n\t\t\ttraverse(node.right, order);\n\t\t\tbreak;\n\t\tcase POSTORDER:\n\t\t\ttraverse(node.left, order);\n\t\t\ttraverse(node.right, order);\n\t\t\tnode.visit();\n\t\t\tbreak;\n\t\tcase LEVEL:\n\t\t\tQueue<Node<T>> queue = new LinkedList<>();\n\t\t\tqueue.add(node);\n\t\t\twhile(!queue.isEmpty()){\n\t\t\t\tNode<T> next = queue.remove();\n\t\t\t\tnext.visit();\n\t\t\t\tif(next.left!=null)\n\t\t\t\t\tqueue.add(next.left);\n\t\t\t\tif(next.right!=null)\n\t\t\t\t\tqueue.add(next.right);\n\t\t\t}\n\t\t}\n\t}\t\n\n\tpublic static void main(String[] args) {\n\n\t\tNode<Integer> one = new Node<Integer>(1);\n\t\tNode<Integer> two = new Node<Integer>(2);\n\t\tNode<Integer> three = new Node<Integer>(3);\n\t\tNode<Integer> four = new Node<Integer>(4);\n\t\tNode<Integer> five = new Node<Integer>(5);\n\t\tNode<Integer> six = new Node<Integer>(6);\n\t\tNode<Integer> seven = new Node<Integer>(7);\n\t\tNode<Integer> eight = new Node<Integer>(8);\n\t\tNode<Integer> nine = new Node<Integer>(9);\n\t\t\n\t\tone.left = two;\n\t\tone.right = three;\n\t\ttwo.left = four;\n\t\ttwo.right = five;\n\t\tthree.left = six;\n\t\tfour.left = seven;\n\t\tsix.left = eight;\n\t\tsix.right = nine;\n\n\t\ttraverse(one, ORDER.PREORDER);\n\t\tSystem.out.println(); \n\t\ttraverse(one, ORDER.INORDER);\n\t\tSystem.out.println();\n\t\ttraverse(one, ORDER.POSTORDER);\n\t\tSystem.out.println();\n\t\ttraverse(one, ORDER.LEVEL);\n\t\t\n\t}\n}\n"}
{"id": 7043, "name": "Tree traversal", "source": "Translate Ruby to Python: BinaryTreeNode = Struct.new(:value, :left, :right) do\n  def self.from_array(nested_list)\n    value, left, right = nested_list\n    if value \n      self.new(value, self.from_array(left), self.from_array(right))\n    end\n  end\n \n  def walk_nodes(order, &block)\n    order.each do |node|\n      case node\n      when :left  then left && left.walk_nodes(order, &block)\n      when :self  then yield self\n      when :right then right && right.walk_nodes(order, &block)\n      end\n    end\n  end\n \n  def each_preorder(&b)  walk_nodes([:self, :left, :right], &b) end\n  def each_inorder(&b)   walk_nodes([:left, :self, :right], &b) end\n  def each_postorder(&b) walk_nodes([:left, :right, :self], &b) end\n \n  def each_levelorder\n    queue = [self]\n    until queue.empty?\n      node = queue.shift\n      yield node\n      queue << node.left if node.left\n      queue << node.right if node.right\n    end\n  end\nend\n\nroot = BinaryTreeNode.from_array [1, [2, [4, 7], [5]], [3, [6, [8], [9]]]] \n\nBinaryTreeNode.instance_methods.select{|m| m=~/.+order/}.each do |mthd|\n  printf \"%-11s \", mthd[5..-1] + ':'\n  root.send(mthd) {|node| print \"\n  puts\nend\n", "target": "from collections import namedtuple\n \nNode = namedtuple('Node', 'data, left, right')\ntree = Node(1,\n            Node(2,\n                 Node(4,\n                      Node(7, None, None),\n                      None),\n                 Node(5, None, None)),\n            Node(3,\n                 Node(6,\n                      Node(8, None, None),\n                      Node(9, None, None)),\n                 None))\n \ndef printwithspace(i):\n    print(i, end=' ')\n\ndef dfs(order, node, visitor):\n    if node is not None:\n        for action in order:\n            if action == 'N':\n                visitor(node.data)\n            elif action == 'L':\n                dfs(order, node.left, visitor)\n            elif action == 'R':\n                dfs(order, node.right, visitor)\n                \ndef preorder(node, visitor = printwithspace):\n    dfs('NLR', node, visitor)\n \ndef inorder(node, visitor = printwithspace):\n    dfs('LNR', node, visitor)\n \ndef postorder(node, visitor = printwithspace):\n    dfs('LRN', node, visitor)\n \ndef ls(node, more, visitor, order='TB'):\n    \"Level-based Top-to-Bottom or Bottom-to-Top tree search\"\n    if node:\n        if more is None:\n            more = []\n        more += [node.left, node.right]\n    for action in order:\n        if action == 'B' and more:\n            ls(more[0], more[1:], visitor, order)\n        elif action == 'T' and node:\n            visitor(node.data)\n\ndef levelorder(node, more=None, visitor = printwithspace):\n    ls(node, more, visitor, 'TB') \n \n\ndef reverse_preorder(node, visitor = printwithspace):\n    dfs('RLN', node, visitor)\n    \ndef bottom_up_order(node, more=None, visitor = printwithspace, order='BT'):\n    ls(node, more, visitor, 'BT')\n\n\nif __name__ == '__main__':\n    w = 10\n    for traversal in [preorder, inorder, postorder, levelorder, \n                      reverse_preorder, bottom_up_order]:\n        if traversal == reverse_preorder:\n            w = 20\n            print('\\nThe generalisation of function dfs allows:')\n        if traversal == bottom_up_order:\n            print('The generalisation of function ls allows:')\n        print(f\"{traversal.__name__:>{w}}:\", end=' ')\n        traversal(tree)\n        print()\n"}
{"id": 7258, "name": "List comprehensions", "source": "Translate Ruby to C#: n = 20\n \n\nr = ((1..n).flat_map { |x|\n       (x..n).flat_map { |y|\n         (y..n).flat_map { |z|\n           [[x, y, z]].keep_if { x * x + y * y == z * z }}}})\n\np r \n", "target": "using System.Linq;\n\nstatic class Program\n{\n  static void Main()\n  {\n    var ts =\n      from a in Enumerable.Range(1, 20)\n      from b in Enumerable.Range(a, 21 - a)\n      from c in Enumerable.Range(b, 21 - b)\n      where a * a + b * b == c * c\n      select new { a, b, c };\n\n      foreach (var t in ts)\n        System.Console.WriteLine(\"{0}, {1}, {2}\", t.a, t.b, t.c);\n  }\n}\n"}
{"id": 7260, "name": "List comprehensions", "source": "Translate Ruby to Java: n = 20\n \n\nr = ((1..n).flat_map { |x|\n       (x..n).flat_map { |y|\n         (y..n).flat_map { |z|\n           [[x, y, z]].keep_if { x * x + y * y == z * z }}}})\n\np r \n", "target": "\nimport java.util.Arrays;\nimport java.util.List;\nimport static java.util.function.Function.identity;\nimport static java.util.stream.Collectors.toList;\nimport static java.util.stream.IntStream.range;\npublic interface PythagComp{\n    static void main(String... args){\n        System.out.println(run(20));\n    }\n\n    static List<List<Integer>> run(int n){\n        return\n            \n            \n            range(1, n).mapToObj(\n                x -> range(x, n).mapToObj(\n                    y -> range(y, n).mapToObj(\n                        z -> new Integer[]{x, y, z}\n                    )\n                )\n            )\n                .flatMap(identity())\n                .flatMap(identity())\n                \n                .filter(a -> a[0]*a[0] + a[1]*a[1] == a[2]*a[2])\n                \n                .map(Arrays::asList)\n                \n                .collect(toList())\n        ;\n    }\n}\n"}
{"id": 7261, "name": "List comprehensions", "source": "Translate Ruby to Python: n = 20\n \n\nr = ((1..n).flat_map { |x|\n       (x..n).flat_map { |y|\n         (y..n).flat_map { |z|\n           [[x, y, z]].keep_if { x * x + y * y == z * z }}}})\n\np r \n", "target": "[(x,y,z) for x in xrange(1,n+1) for y in xrange(x,n+1) for z in xrange(y,n+1) if x**2 + y**2 == z**2]\n"}
{"id": 7382, "name": "Literals_Floating point", "source": "Translate Ruby to C#: say 1.234;\nsay .1234;\nsay 1234e-5;\nsay 12.34e5;\n", "target": "double d = 1;\nd = 1d;\nd = 1D;\nd = 1.2; \nd = 1.2d; \nd = .2;\nd = 12e-12;\nd = 12E-12;\nd = 1_234e-1_2; \nfloat f = 1;\nf = 1f;\nf = 1F;\nf = 1.2f;\nf = .2f;\nf = 12e-12f;\nf = 12E-12f;\nf = 1_234e-1_2f;\ndecimal m = 1;\nm = 1m;\nm = 1m;\nm = 1.2m;\nm = .2m;\nm = 12e-12m;\nm = 12E-12m;\nm = 1_234e-1_2m;\n"}
{"id": 7384, "name": "Literals_Floating point", "source": "Translate Ruby to Java: say 1.234;\nsay .1234;\nsay 1234e-5;\nsay 12.34e5;\n", "target": "1. \n1.0 \n2432311.7567374 \n1.234E-10 \n1.234e-10 \n758832d \n728832f \n1.0f \n758832D \n728832F \n1.0F \n1 / 2. \n1 / 2 \n"}
{"id": 7385, "name": "Literals_Floating point", "source": "Translate Ruby to Python: say 1.234;\nsay .1234;\nsay 1234e-5;\nsay 12.34e5;\n", "target": "2.3    \n.3     \n.3e4   \n.3e+34 \n.3e-34 \n2.e34  \n"}
{"id": 7715, "name": "Abundant odd numbers", "source": "Translate Ruby to C#: require \"prime\"\n \nclass Integer\n  def proper_divisors\n    return [] if self == 1\n    primes = prime_division.flat_map{|prime, freq| [prime] * freq}\n    (1...primes.size).each_with_object([1]) do |n, res|\n      primes.combination(n).map{|combi| res << combi.inject(:*)}\n    end.flatten.uniq\n  end\nend\n\ndef generator_odd_abundants(from=1)\n  from += 1 if from.even?\n  Enumerator.new do |y|\n    from.step(nil, 2) do |n|\n      sum = n.proper_divisors.sum\n      y << [n, sum] if sum > n\n    end\n  end\nend\n\ngenerator_odd_abundants.take(25).each{|n, sum| puts \"\nputs \"\\n%d with sum\u00a0%\nputs \"\\n%d with sum\u00a0%\n", "target": "using static System.Console;\nusing System.Collections.Generic;\nusing System.Linq;\n\npublic static class AbundantOddNumbers\n{\n    public static void Main() {\n        WriteLine(\"First 25 abundant odd numbers:\");\n        foreach (var x in AbundantNumbers().Take(25)) WriteLine(x.Format());\n        WriteLine();\n        WriteLine($\"The 1000th abundant odd number: {AbundantNumbers().ElementAt(999).Format()}\");\n        WriteLine();\n        WriteLine($\"First abundant odd number > 1b: {AbundantNumbers(1_000_000_001).First().Format()}\");\n    }\n\n    static IEnumerable<(int n, int sum)> AbundantNumbers(int start = 3) =>\n        start.UpBy(2).Select(n => (n, sum: n.DivisorSum())).Where(x => x.sum > x.n);\n\n    static int DivisorSum(this int n) => 3.UpBy(2).TakeWhile(i => i * i <= n).Where(i => n % i == 0)\n        .Select(i => (a:i, b:n/i)).Sum(p => p.a == p.b ? p.a : p.a + p.b) + 1;\n\n    static IEnumerable<int> UpBy(this int n, int step) {\n        for (int i = n; ; i+=step) yield return i;\n    }\n\n    static string Format(this (int n, int sum) pair) => $\"{pair.n:N0} with sum {pair.sum:N0}\";\n}\n"}
{"id": 7716, "name": "Abundant odd numbers", "source": "Translate Ruby to C#: require \"prime\"\n \nclass Integer\n  def proper_divisors\n    return [] if self == 1\n    primes = prime_division.flat_map{|prime, freq| [prime] * freq}\n    (1...primes.size).each_with_object([1]) do |n, res|\n      primes.combination(n).map{|combi| res << combi.inject(:*)}\n    end.flatten.uniq\n  end\nend\n\ndef generator_odd_abundants(from=1)\n  from += 1 if from.even?\n  Enumerator.new do |y|\n    from.step(nil, 2) do |n|\n      sum = n.proper_divisors.sum\n      y << [n, sum] if sum > n\n    end\n  end\nend\n\ngenerator_odd_abundants.take(25).each{|n, sum| puts \"\nputs \"\\n%d with sum\u00a0%\nputs \"\\n%d with sum\u00a0%\n", "target": "using static System.Console;\nusing System.Collections.Generic;\nusing System.Linq;\n\npublic static class AbundantOddNumbers\n{\n    public static void Main() {\n        WriteLine(\"First 25 abundant odd numbers:\");\n        foreach (var x in AbundantNumbers().Take(25)) WriteLine(x.Format());\n        WriteLine();\n        WriteLine($\"The 1000th abundant odd number: {AbundantNumbers().ElementAt(999).Format()}\");\n        WriteLine();\n        WriteLine($\"First abundant odd number > 1b: {AbundantNumbers(1_000_000_001).First().Format()}\");\n    }\n\n    static IEnumerable<(int n, int sum)> AbundantNumbers(int start = 3) =>\n        start.UpBy(2).Select(n => (n, sum: n.DivisorSum())).Where(x => x.sum > x.n);\n\n    static int DivisorSum(this int n) => 3.UpBy(2).TakeWhile(i => i * i <= n).Where(i => n % i == 0)\n        .Select(i => (a:i, b:n/i)).Sum(p => p.a == p.b ? p.a : p.a + p.b) + 1;\n\n    static IEnumerable<int> UpBy(this int n, int step) {\n        for (int i = n; ; i+=step) yield return i;\n    }\n\n    static string Format(this (int n, int sum) pair) => $\"{pair.n:N0} with sum {pair.sum:N0}\";\n}\n"}
{"id": 7719, "name": "Abundant odd numbers", "source": "Translate Ruby to Java: require \"prime\"\n \nclass Integer\n  def proper_divisors\n    return [] if self == 1\n    primes = prime_division.flat_map{|prime, freq| [prime] * freq}\n    (1...primes.size).each_with_object([1]) do |n, res|\n      primes.combination(n).map{|combi| res << combi.inject(:*)}\n    end.flatten.uniq\n  end\nend\n\ndef generator_odd_abundants(from=1)\n  from += 1 if from.even?\n  Enumerator.new do |y|\n    from.step(nil, 2) do |n|\n      sum = n.proper_divisors.sum\n      y << [n, sum] if sum > n\n    end\n  end\nend\n\ngenerator_odd_abundants.take(25).each{|n, sum| puts \"\nputs \"\\n%d with sum\u00a0%\nputs \"\\n%d with sum\u00a0%\n", "target": "import java.util.ArrayList;\nimport java.util.List;\n\npublic class AbundantOddNumbers {\n    private static List<Integer> list = new ArrayList<>();\n    private static List<Integer> result = new ArrayList<>();\n\n    public static void main(String[] args) {\n        System.out.println(\"First 25: \");\n        abundantOdd(1,100000, 25, false);\n\n        System.out.println(\"\\n\\nThousandth: \");\n        abundantOdd(1,2500000, 1000, true);\n\n        System.out.println(\"\\n\\nFirst over 1bn:\"); \n        abundantOdd(1000000001, 2147483647, 1, false);\n    }\n    private static void abundantOdd(int start, int finish, int listSize, boolean printOne) {\n        for (int oddNum = start; oddNum < finish; oddNum += 2) {\n            list.clear();\n            for (int toDivide = 1; toDivide < oddNum; toDivide+=2) {\n                if (oddNum % toDivide == 0)\n                    list.add(toDivide);\n            }\n            if (sumList(list) > oddNum) {\n                if(!printOne)\n                    System.out.printf(\"%5d <= %5d \\n\",oddNum, sumList(list) );\n                result.add(oddNum);\n            }\n            if(printOne && result.size() >= listSize)\n                System.out.printf(\"%5d <= %5d \\n\",oddNum, sumList(list) );\n\n            if(result.size() >= listSize) break;\n        }\n    }\n    private static int sumList(List list) {\n        int sum = 0;\n        for (int i = 0; i < list.size(); i++) {\n            String temp = list.get(i).toString();\n            sum += Integer.parseInt(temp);\n        }\n        return sum;\n    }\n}\n"}
{"id": 7720, "name": "Abundant odd numbers", "source": "Translate Ruby to Java: require \"prime\"\n \nclass Integer\n  def proper_divisors\n    return [] if self == 1\n    primes = prime_division.flat_map{|prime, freq| [prime] * freq}\n    (1...primes.size).each_with_object([1]) do |n, res|\n      primes.combination(n).map{|combi| res << combi.inject(:*)}\n    end.flatten.uniq\n  end\nend\n\ndef generator_odd_abundants(from=1)\n  from += 1 if from.even?\n  Enumerator.new do |y|\n    from.step(nil, 2) do |n|\n      sum = n.proper_divisors.sum\n      y << [n, sum] if sum > n\n    end\n  end\nend\n\ngenerator_odd_abundants.take(25).each{|n, sum| puts \"\nputs \"\\n%d with sum\u00a0%\nputs \"\\n%d with sum\u00a0%\n", "target": "import java.util.ArrayList;\nimport java.util.List;\n\npublic class AbundantOddNumbers {\n    private static List<Integer> list = new ArrayList<>();\n    private static List<Integer> result = new ArrayList<>();\n\n    public static void main(String[] args) {\n        System.out.println(\"First 25: \");\n        abundantOdd(1,100000, 25, false);\n\n        System.out.println(\"\\n\\nThousandth: \");\n        abundantOdd(1,2500000, 1000, true);\n\n        System.out.println(\"\\n\\nFirst over 1bn:\"); \n        abundantOdd(1000000001, 2147483647, 1, false);\n    }\n    private static void abundantOdd(int start, int finish, int listSize, boolean printOne) {\n        for (int oddNum = start; oddNum < finish; oddNum += 2) {\n            list.clear();\n            for (int toDivide = 1; toDivide < oddNum; toDivide+=2) {\n                if (oddNum % toDivide == 0)\n                    list.add(toDivide);\n            }\n            if (sumList(list) > oddNum) {\n                if(!printOne)\n                    System.out.printf(\"%5d <= %5d \\n\",oddNum, sumList(list) );\n                result.add(oddNum);\n            }\n            if(printOne && result.size() >= listSize)\n                System.out.printf(\"%5d <= %5d \\n\",oddNum, sumList(list) );\n\n            if(result.size() >= listSize) break;\n        }\n    }\n    private static int sumList(List list) {\n        int sum = 0;\n        for (int i = 0; i < list.size(); i++) {\n            String temp = list.get(i).toString();\n            sum += Integer.parseInt(temp);\n        }\n        return sum;\n    }\n}\n"}
{"id": 7721, "name": "Abundant odd numbers", "source": "Translate Ruby to Python: require \"prime\"\n \nclass Integer\n  def proper_divisors\n    return [] if self == 1\n    primes = prime_division.flat_map{|prime, freq| [prime] * freq}\n    (1...primes.size).each_with_object([1]) do |n, res|\n      primes.combination(n).map{|combi| res << combi.inject(:*)}\n    end.flatten.uniq\n  end\nend\n\ndef generator_odd_abundants(from=1)\n  from += 1 if from.even?\n  Enumerator.new do |y|\n    from.step(nil, 2) do |n|\n      sum = n.proper_divisors.sum\n      y << [n, sum] if sum > n\n    end\n  end\nend\n\ngenerator_odd_abundants.take(25).each{|n, sum| puts \"\nputs \"\\n%d with sum\u00a0%\nputs \"\\n%d with sum\u00a0%\n", "target": "\n\n\noddNumber  = 1\naCount  = 0\ndSum  = 0\n \nfrom math import sqrt\n \ndef divisorSum(n):\n    sum = 1\n    i = int(sqrt(n)+1)\n \n    for d in range (2, i):\n        if n % d == 0:\n            sum += d\n            otherD = n // d\n            if otherD != d:\n                sum += otherD\n    return sum\n \nprint (\"The first 25 abundant odd numbers:\")\nwhile aCount  < 25:\n    dSum  = divisorSum(oddNumber )\n    if dSum  > oddNumber :\n        aCount  += 1\n        print(\"{0:5} proper divisor sum: {1}\". format(oddNumber ,dSum ))\n    oddNumber  += 2\n \nwhile aCount  < 1000:\n    dSum  = divisorSum(oddNumber )\n    if dSum  > oddNumber :\n        aCount  += 1\n    oddNumber  += 2\nprint (\"\\n1000th abundant odd number:\")\nprint (\"    \",(oddNumber - 2),\" proper divisor sum: \",dSum)\n \noddNumber  = 1000000001\nfound  = False\nwhile not found :\n    dSum  = divisorSum(oddNumber )\n    if dSum  > oddNumber :\n        found  = True\n        print (\"\\nFirst abundant odd number > 1 000 000 000:\")\n        print (\"    \",oddNumber,\" proper divisor sum: \",dSum)\n    oddNumber  += 2\n"}
{"id": 7722, "name": "Abundant odd numbers", "source": "Translate Ruby to Python: require \"prime\"\n \nclass Integer\n  def proper_divisors\n    return [] if self == 1\n    primes = prime_division.flat_map{|prime, freq| [prime] * freq}\n    (1...primes.size).each_with_object([1]) do |n, res|\n      primes.combination(n).map{|combi| res << combi.inject(:*)}\n    end.flatten.uniq\n  end\nend\n\ndef generator_odd_abundants(from=1)\n  from += 1 if from.even?\n  Enumerator.new do |y|\n    from.step(nil, 2) do |n|\n      sum = n.proper_divisors.sum\n      y << [n, sum] if sum > n\n    end\n  end\nend\n\ngenerator_odd_abundants.take(25).each{|n, sum| puts \"\nputs \"\\n%d with sum\u00a0%\nputs \"\\n%d with sum\u00a0%\n", "target": "\n\n\noddNumber  = 1\naCount  = 0\ndSum  = 0\n \nfrom math import sqrt\n \ndef divisorSum(n):\n    sum = 1\n    i = int(sqrt(n)+1)\n \n    for d in range (2, i):\n        if n % d == 0:\n            sum += d\n            otherD = n // d\n            if otherD != d:\n                sum += otherD\n    return sum\n \nprint (\"The first 25 abundant odd numbers:\")\nwhile aCount  < 25:\n    dSum  = divisorSum(oddNumber )\n    if dSum  > oddNumber :\n        aCount  += 1\n        print(\"{0:5} proper divisor sum: {1}\". format(oddNumber ,dSum ))\n    oddNumber  += 2\n \nwhile aCount  < 1000:\n    dSum  = divisorSum(oddNumber )\n    if dSum  > oddNumber :\n        aCount  += 1\n    oddNumber  += 2\nprint (\"\\n1000th abundant odd number:\")\nprint (\"    \",(oddNumber - 2),\" proper divisor sum: \",dSum)\n \noddNumber  = 1000000001\nfound  = False\nwhile not found :\n    dSum  = divisorSum(oddNumber )\n    if dSum  > oddNumber :\n        found  = True\n        print (\"\\nFirst abundant odd number > 1 000 000 000:\")\n        print (\"    \",oddNumber,\" proper divisor sum: \",dSum)\n    oddNumber  += 2\n"}
{"id": 7978, "name": "Jump anywhere", "source": "Translate Ruby to C#: require 'continuation' unless defined? Continuation\n\nif a = callcc { |c| [c, 1] }\n  c, i = a\n  c[nil] if i > 100\n\n  case 0\n  when i % 3\n    print \"Fizz\"\n    case 0\n    when i % 5\n      print \"Buzz\"\n    end\n  when i % 5\n    print \"Buzz\"\n  else\n    print i\n  end\n\n  puts\n  c[c, i + 1]\nend\n", "target": "if (x > 0) goto positive;\nelse goto negative;\n\npositive:\n    Console.WriteLine(\"pos\\n\"); goto both;\n\nnegative:\n    Console.WriteLine(\"neg\\n\");\n\nboth:\n    ...\n"}
{"id": 7979, "name": "Jump anywhere", "source": "Translate Ruby to C#: require 'continuation' unless defined? Continuation\n\nif a = callcc { |c| [c, 1] }\n  c, i = a\n  c[nil] if i > 100\n\n  case 0\n  when i % 3\n    print \"Fizz\"\n    case 0\n    when i % 5\n      print \"Buzz\"\n    end\n  when i % 5\n    print \"Buzz\"\n  else\n    print i\n  end\n\n  puts\n  c[c, i + 1]\nend\n", "target": "if (x > 0) goto positive;\nelse goto negative;\n\npositive:\n    Console.WriteLine(\"pos\\n\"); goto both;\n\nnegative:\n    Console.WriteLine(\"neg\\n\");\n\nboth:\n    ...\n"}
{"id": 7982, "name": "Jump anywhere", "source": "Translate Ruby to Java: require 'continuation' unless defined? Continuation\n\nif a = callcc { |c| [c, 1] }\n  c, i = a\n  c[nil] if i > 100\n\n  case 0\n  when i % 3\n    print \"Fizz\"\n    case 0\n    when i % 5\n      print \"Buzz\"\n    end\n  when i % 5\n    print \"Buzz\"\n  else\n    print i\n  end\n\n  puts\n  c[c, i + 1]\nend\n", "target": "loop1: while (x != 0) {\n    loop2: for (int i = 0; i < 10; i++) {\n        loop3: do {\n            \n            if () {\n                \n                continue loop1;\n            }\n            \n            if () {\n                \n                break loop2;\n            }\n        } while (y < 10);\n        \n    }\n    \n}\n"}
{"id": 7983, "name": "Jump anywhere", "source": "Translate Ruby to Java: require 'continuation' unless defined? Continuation\n\nif a = callcc { |c| [c, 1] }\n  c, i = a\n  c[nil] if i > 100\n\n  case 0\n  when i % 3\n    print \"Fizz\"\n    case 0\n    when i % 5\n      print \"Buzz\"\n    end\n  when i % 5\n    print \"Buzz\"\n  else\n    print i\n  end\n\n  puts\n  c[c, i + 1]\nend\n", "target": "loop1: while (x != 0) {\n    loop2: for (int i = 0; i < 10; i++) {\n        loop3: do {\n            \n            if () {\n                \n                continue loop1;\n            }\n            \n            if () {\n                \n                break loop2;\n            }\n        } while (y < 10);\n        \n    }\n    \n}\n"}
{"id": 7984, "name": "Jump anywhere", "source": "Translate Ruby to Python: require 'continuation' unless defined? Continuation\n\nif a = callcc { |c| [c, 1] }\n  c, i = a\n  c[nil] if i > 100\n\n  case 0\n  when i % 3\n    print \"Fizz\"\n    case 0\n    when i % 5\n      print \"Buzz\"\n    end\n  when i % 5\n    print \"Buzz\"\n  else\n    print i\n  end\n\n  puts\n  c[c, i + 1]\nend\n", "target": "\nfrom goto import goto, label\nlabel .start\nfor i in range(1, 4):\n    print i\n    if i == 2:\n        try:\n            output = message\n        except NameError:\n            print \"Oops - forgot to define 'message'!  Start again.\"\n            message = \"Hello world\"\n            goto .start\nprint output, \"\\n\"\n"}
{"id": 7985, "name": "Jump anywhere", "source": "Translate Ruby to Python: require 'continuation' unless defined? Continuation\n\nif a = callcc { |c| [c, 1] }\n  c, i = a\n  c[nil] if i > 100\n\n  case 0\n  when i % 3\n    print \"Fizz\"\n    case 0\n    when i % 5\n      print \"Buzz\"\n    end\n  when i % 5\n    print \"Buzz\"\n  else\n    print i\n  end\n\n  puts\n  c[c, i + 1]\nend\n", "target": "\nfrom goto import goto, label\nlabel .start\nfor i in range(1, 4):\n    print i\n    if i == 2:\n        try:\n            output = message\n        except NameError:\n            print \"Oops - forgot to define 'message'!  Start again.\"\n            message = \"Hello world\"\n            goto .start\nprint output, \"\\n\"\n"}
{"id": 8201, "name": "Combinations", "source": "Translate Ruby to C#: def comb(m, n)\n    (0...n).to_a.each_combination(m) { |p| puts(p) }\nend\n", "target": "using System;\nusing System.Collections.Generic;\n\npublic class Program\n{\n    public static IEnumerable<int[]> Combinations(int m, int n)\n    {\n            int[] result = new int[m];\n            Stack<int> stack = new Stack<int>();\n            stack.Push(0);\n\n            while (stack.Count > 0)\n           {\n                int index = stack.Count - 1;\n                int value = stack.Pop();\n\n                while (value < n) \n               {\n                    result[index++] = ++value;\n                    stack.Push(value);\n\n                    if (index == m) \n                    {\n                        yield return result;\n                        break;\n                    }\n                }\n            }\n    }\n\n    static void Main()\n    {\n        foreach (int[] c in Combinations(3, 5))\n        {\n            Console.WriteLine(string.Join(\",\", c));\n            Console.WriteLine();\n        }\n    }\n}\n"}
{"id": 8203, "name": "Combinations", "source": "Translate Ruby to Java: def comb(m, n)\n    (0...n).to_a.each_combination(m) { |p| puts(p) }\nend\n", "target": "import java.util.Collections;\nimport java.util.LinkedList;\n\npublic class Comb{\n\n        public static void main(String[] args){\n                System.out.println(comb(3,5));\n        }\n\n        public static String bitprint(int u){\n                String s= \"\";\n                for(int n= 0;u > 0;++n, u>>= 1)\n                        if((u & 1) > 0) s+= n + \" \";\n                return s;\n        }\n\n        public static int bitcount(int u){\n                int n;\n                for(n= 0;u > 0;++n, u&= (u - 1));\n                return n;\n        }\n\n        public static LinkedList<String> comb(int c, int n){\n                LinkedList<String> s= new LinkedList<String>();\n                for(int u= 0;u < 1 << n;u++)\n                        if(bitcount(u) == c) s.push(bitprint(u));\n                Collections.sort(s);\n                return s;\n        }\n}\n"}
{"id": 8204, "name": "Combinations", "source": "Translate Ruby to Python: def comb(m, n)\n    (0...n).to_a.each_combination(m) { |p| puts(p) }\nend\n", "target": ">>> from itertools import combinations\n>>> list(combinations(range(5),3))\n[(0, 1, 2), (0, 1, 3), (0, 1, 4), (0, 2, 3), (0, 2, 4), (0, 3, 4), (1, 2, 3), (1, 2, 4), (1, 3, 4), (2, 3, 4)]\n"}
{"id": 8413, "name": "Bin given limits", "source": "Translate Ruby to C#: Test = Struct.new(:limits, :data)\ntests = Test.new( [23, 37, 43, 53, 67, 83],\n                  [95,21,94,12,99,4,70,75,83,93,52,80,57,5,53,86,65,17,92,83,71,61,54,58,47,\n                   16, 8, 9,32,84,7,87,46,19,30,37,96,6,98,40,79,97,45,64,60,29,49,36,43,55]),\n        Test.new( [14, 18, 249, 312, 389, 392, 513, 591, 634, 720],\n                  [445,814,519,697,700,130,255,889,481,122,932, 77,323,525,570,219,367,523,442,933,\n                   416,589,930,373,202,253,775, 47,731,685,293,126,133,450,545,100,741,583,763,306,\n                   655,267,248,477,549,238, 62,678, 98,534,622,907,406,714,184,391,913, 42,560,247,\n                   346,860, 56,138,546, 38,985,948, 58,213,799,319,390,634,458,945,733,507,916,123,\n                   345,110,720,917,313,845,426,  9,457,628,410,723,354,895,881,953,677,137,397, 97,\n                   854,740, 83,216,421, 94,517,479,292,963,376,981,480, 39,257,272,157,  5,316,395,\n                   787,942,456,242,759,898,576, 67,298,425,894,435,831,241,989,614,987,770,384,692,\n                   698,765,331,487,251,600,879,342,982,527,736,795,585, 40, 54,901,408,359,577,237,\n                   605,847,353,968,832,205,838,427,876,959,686,646,835,127,621,892,443,198,988,791,\n                   466, 23,707,467, 33,670,921,180,991,396,160,436,717,918,  8,374,101,684,727,749])\n\ndef bin(limits, data)\n  data.map{|d| limits.bsearch{|limit| limit > d} }.tally\nend\n\ndef present_bins(limits, bins)\n  ranges = ([nil]+limits+[nil]).each_cons(2).map{|low, high| Range.new(low, high, true) }\n  ranges.each{|range| puts \"\nend\n\ntests.each do |test|\n  present_bins(test.limits, bin(test.limits, test.data))\n  puts\nend\n", "target": "using System;\n\npublic class Program\n{\n    static void Main()\n    {\n        PrintBins(new [] { 23, 37, 43, 53, 67, 83 },\n            95,21,94,12,99,4,70,75,83,93,52,80,57,5,53,86,65,17,92,83,71,61,54,58,47,\n            16, 8, 9,32,84,7,87,46,19,30,37,96,6,98,40,79,97,45,64,60,29,49,36,43,55\n        );\n        Console.WriteLine();\n\n        PrintBins(new [] { 14, 18, 249, 312, 389, 392, 513, 591, 634, 720 },\n            445,814,519,697,700,130,255,889,481,122,932, 77,323,525,570,219,367,523,442,933,416,589,930,373,202,\n            253,775, 47,731,685,293,126,133,450,545,100,741,583,763,306,655,267,248,477,549,238, 62,678, 98,534,\n            622,907,406,714,184,391,913, 42,560,247,346,860, 56,138,546, 38,985,948, 58,213,799,319,390,634,458,\n            945,733,507,916,123,345,110,720,917,313,845,426,  9,457,628,410,723,354,895,881,953,677,137,397, 97,\n            854,740, 83,216,421, 94,517,479,292,963,376,981,480, 39,257,272,157,  5,316,395,787,942,456,242,759,\n            898,576, 67,298,425,894,435,831,241,989,614,987,770,384,692,698,765,331,487,251,600,879,342,982,527,\n            736,795,585, 40, 54,901,408,359,577,237,605,847,353,968,832,205,838,427,876,959,686,646,835,127,621,\n            892,443,198,988,791,466, 23,707,467, 33,670,921,180,991,396,160,436,717,918,  8,374,101,684,727,749);\n    }\n\n    static void PrintBins(int[] limits, params int[] data)\n    {\n        int[] bins = Bins(limits, data);\n        Console.WriteLine($\"-\u221e .. {limits[0]} => {bins[0]}\");\n        for (int i = 0; i < limits.Length-1; i++) {\n            Console.WriteLine($\"{limits[i]} .. {limits[i+1]} => {bins[i+1]}\");\n        }\n        Console.WriteLine($\"{limits[^1]} .. \u221e => {bins[^1]}\");\n    }\n\n    static int[] Bins(int[] limits, params int[] data)\n    {\n        Array.Sort(limits);\n        int[] bins = new int[limits.Length + 1];\n        foreach (int n in data) {\n            int i = Array.BinarySearch(limits, n);\n            i = i < 0 ? ~i : i+1;\n            bins[i]++;\n        }\n        return bins;\n    }\n}\n"}
{"id": 8414, "name": "Bin given limits", "source": "Translate Ruby to C#: Test = Struct.new(:limits, :data)\ntests = Test.new( [23, 37, 43, 53, 67, 83],\n                  [95,21,94,12,99,4,70,75,83,93,52,80,57,5,53,86,65,17,92,83,71,61,54,58,47,\n                   16, 8, 9,32,84,7,87,46,19,30,37,96,6,98,40,79,97,45,64,60,29,49,36,43,55]),\n        Test.new( [14, 18, 249, 312, 389, 392, 513, 591, 634, 720],\n                  [445,814,519,697,700,130,255,889,481,122,932, 77,323,525,570,219,367,523,442,933,\n                   416,589,930,373,202,253,775, 47,731,685,293,126,133,450,545,100,741,583,763,306,\n                   655,267,248,477,549,238, 62,678, 98,534,622,907,406,714,184,391,913, 42,560,247,\n                   346,860, 56,138,546, 38,985,948, 58,213,799,319,390,634,458,945,733,507,916,123,\n                   345,110,720,917,313,845,426,  9,457,628,410,723,354,895,881,953,677,137,397, 97,\n                   854,740, 83,216,421, 94,517,479,292,963,376,981,480, 39,257,272,157,  5,316,395,\n                   787,942,456,242,759,898,576, 67,298,425,894,435,831,241,989,614,987,770,384,692,\n                   698,765,331,487,251,600,879,342,982,527,736,795,585, 40, 54,901,408,359,577,237,\n                   605,847,353,968,832,205,838,427,876,959,686,646,835,127,621,892,443,198,988,791,\n                   466, 23,707,467, 33,670,921,180,991,396,160,436,717,918,  8,374,101,684,727,749])\n\ndef bin(limits, data)\n  data.map{|d| limits.bsearch{|limit| limit > d} }.tally\nend\n\ndef present_bins(limits, bins)\n  ranges = ([nil]+limits+[nil]).each_cons(2).map{|low, high| Range.new(low, high, true) }\n  ranges.each{|range| puts \"\nend\n\ntests.each do |test|\n  present_bins(test.limits, bin(test.limits, test.data))\n  puts\nend\n", "target": "using System;\n\npublic class Program\n{\n    static void Main()\n    {\n        PrintBins(new [] { 23, 37, 43, 53, 67, 83 },\n            95,21,94,12,99,4,70,75,83,93,52,80,57,5,53,86,65,17,92,83,71,61,54,58,47,\n            16, 8, 9,32,84,7,87,46,19,30,37,96,6,98,40,79,97,45,64,60,29,49,36,43,55\n        );\n        Console.WriteLine();\n\n        PrintBins(new [] { 14, 18, 249, 312, 389, 392, 513, 591, 634, 720 },\n            445,814,519,697,700,130,255,889,481,122,932, 77,323,525,570,219,367,523,442,933,416,589,930,373,202,\n            253,775, 47,731,685,293,126,133,450,545,100,741,583,763,306,655,267,248,477,549,238, 62,678, 98,534,\n            622,907,406,714,184,391,913, 42,560,247,346,860, 56,138,546, 38,985,948, 58,213,799,319,390,634,458,\n            945,733,507,916,123,345,110,720,917,313,845,426,  9,457,628,410,723,354,895,881,953,677,137,397, 97,\n            854,740, 83,216,421, 94,517,479,292,963,376,981,480, 39,257,272,157,  5,316,395,787,942,456,242,759,\n            898,576, 67,298,425,894,435,831,241,989,614,987,770,384,692,698,765,331,487,251,600,879,342,982,527,\n            736,795,585, 40, 54,901,408,359,577,237,605,847,353,968,832,205,838,427,876,959,686,646,835,127,621,\n            892,443,198,988,791,466, 23,707,467, 33,670,921,180,991,396,160,436,717,918,  8,374,101,684,727,749);\n    }\n\n    static void PrintBins(int[] limits, params int[] data)\n    {\n        int[] bins = Bins(limits, data);\n        Console.WriteLine($\"-\u221e .. {limits[0]} => {bins[0]}\");\n        for (int i = 0; i < limits.Length-1; i++) {\n            Console.WriteLine($\"{limits[i]} .. {limits[i+1]} => {bins[i+1]}\");\n        }\n        Console.WriteLine($\"{limits[^1]} .. \u221e => {bins[^1]}\");\n    }\n\n    static int[] Bins(int[] limits, params int[] data)\n    {\n        Array.Sort(limits);\n        int[] bins = new int[limits.Length + 1];\n        foreach (int n in data) {\n            int i = Array.BinarySearch(limits, n);\n            i = i < 0 ? ~i : i+1;\n            bins[i]++;\n        }\n        return bins;\n    }\n}\n"}
{"id": 8417, "name": "Bin given limits", "source": "Translate Ruby to Java: Test = Struct.new(:limits, :data)\ntests = Test.new( [23, 37, 43, 53, 67, 83],\n                  [95,21,94,12,99,4,70,75,83,93,52,80,57,5,53,86,65,17,92,83,71,61,54,58,47,\n                   16, 8, 9,32,84,7,87,46,19,30,37,96,6,98,40,79,97,45,64,60,29,49,36,43,55]),\n        Test.new( [14, 18, 249, 312, 389, 392, 513, 591, 634, 720],\n                  [445,814,519,697,700,130,255,889,481,122,932, 77,323,525,570,219,367,523,442,933,\n                   416,589,930,373,202,253,775, 47,731,685,293,126,133,450,545,100,741,583,763,306,\n                   655,267,248,477,549,238, 62,678, 98,534,622,907,406,714,184,391,913, 42,560,247,\n                   346,860, 56,138,546, 38,985,948, 58,213,799,319,390,634,458,945,733,507,916,123,\n                   345,110,720,917,313,845,426,  9,457,628,410,723,354,895,881,953,677,137,397, 97,\n                   854,740, 83,216,421, 94,517,479,292,963,376,981,480, 39,257,272,157,  5,316,395,\n                   787,942,456,242,759,898,576, 67,298,425,894,435,831,241,989,614,987,770,384,692,\n                   698,765,331,487,251,600,879,342,982,527,736,795,585, 40, 54,901,408,359,577,237,\n                   605,847,353,968,832,205,838,427,876,959,686,646,835,127,621,892,443,198,988,791,\n                   466, 23,707,467, 33,670,921,180,991,396,160,436,717,918,  8,374,101,684,727,749])\n\ndef bin(limits, data)\n  data.map{|d| limits.bsearch{|limit| limit > d} }.tally\nend\n\ndef present_bins(limits, bins)\n  ranges = ([nil]+limits+[nil]).each_cons(2).map{|low, high| Range.new(low, high, true) }\n  ranges.each{|range| puts \"\nend\n\ntests.each do |test|\n  present_bins(test.limits, bin(test.limits, test.data))\n  puts\nend\n", "target": "import java.util.Arrays;\nimport java.util.Collections;\nimport java.util.List;\n\npublic class Bins {\n    public static <T extends Comparable<? super T>> int[] bins(\n            List<? extends T> limits, Iterable<? extends T> data) {\n        int[] result = new int[limits.size() + 1];\n        for (T n : data) {\n            int i = Collections.binarySearch(limits, n);\n            if (i >= 0) {\n                \n                i = i+1;\n            } else {\n                \n                i = ~i;\n            }\n            result[i]++;\n        }\n        return result;\n    }\n\n    public static void printBins(List<?> limits, int[] bins) {\n        int n = limits.size();\n        if (n == 0) {\n            return;\n        }\n        assert n+1 == bins.length;\n        System.out.printf(\"           < %3s: %2d\\n\", limits.get(0), bins[0]);\n        for (int i = 1; i < n; i++) {\n            System.out.printf(\">= %3s and < %3s: %2d\\n\", limits.get(i-1), limits.get(i), bins[i]);\n        }\n        System.out.printf(\">= %3s         \u00a0: %2d\\n\", limits.get(n-1), bins[n]);\n    }\n\n    public static void main(String[] args) {\n        List<Integer> limits = Arrays.asList(23, 37, 43, 53, 67, 83);\n        List<Integer> data = Arrays.asList(\n            95, 21, 94, 12, 99, 4,  70, 75, 83, 93, 52, 80, 57, 5,  53, 86, 65,\n            17, 92, 83, 71, 61, 54, 58, 47, 16, 8,  9,  32, 84, 7,  87, 46, 19,\n            30, 37, 96, 6,  98, 40, 79, 97, 45, 64, 60, 29, 49, 36, 43, 55);\n\n        System.out.println(\"Example 1:\");\n        printBins(limits, bins(limits, data));\n\n        limits = Arrays.asList(14,  18,  249, 312, 389,\n                               392, 513, 591, 634, 720);\n        data = Arrays.asList(\n            445, 814, 519, 697, 700, 130, 255, 889, 481, 122, 932, 77,  323, 525,\n            570, 219, 367, 523, 442, 933, 416, 589, 930, 373, 202, 253, 775, 47,\n            731, 685, 293, 126, 133, 450, 545, 100, 741, 583, 763, 306, 655, 267,\n            248, 477, 549, 238, 62,  678, 98,  534, 622, 907, 406, 714, 184, 391,\n            913, 42,  560, 247, 346, 860, 56,  138, 546, 38,  985, 948, 58,  213,\n            799, 319, 390, 634, 458, 945, 733, 507, 916, 123, 345, 110, 720, 917,\n            313, 845, 426, 9,   457, 628, 410, 723, 354, 895, 881, 953, 677, 137,\n            397, 97,  854, 740, 83,  216, 421, 94,  517, 479, 292, 963, 376, 981,\n            480, 39,  257, 272, 157, 5,   316, 395, 787, 942, 456, 242, 759, 898,\n            576, 67,  298, 425, 894, 435, 831, 241, 989, 614, 987, 770, 384, 692,\n            698, 765, 331, 487, 251, 600, 879, 342, 982, 527, 736, 795, 585, 40,\n            54,  901, 408, 359, 577, 237, 605, 847, 353, 968, 832, 205, 838, 427,\n            876, 959, 686, 646, 835, 127, 621, 892, 443, 198, 988, 791, 466, 23,\n            707, 467, 33,  670, 921, 180, 991, 396, 160, 436, 717, 918, 8,   374,\n            101, 684, 727, 749);\n\n        System.out.println();\n        System.out.println(\"Example 2:\");\n        printBins(limits, bins(limits, data));\n    }\n}\n"}
{"id": 8418, "name": "Bin given limits", "source": "Translate Ruby to Java: Test = Struct.new(:limits, :data)\ntests = Test.new( [23, 37, 43, 53, 67, 83],\n                  [95,21,94,12,99,4,70,75,83,93,52,80,57,5,53,86,65,17,92,83,71,61,54,58,47,\n                   16, 8, 9,32,84,7,87,46,19,30,37,96,6,98,40,79,97,45,64,60,29,49,36,43,55]),\n        Test.new( [14, 18, 249, 312, 389, 392, 513, 591, 634, 720],\n                  [445,814,519,697,700,130,255,889,481,122,932, 77,323,525,570,219,367,523,442,933,\n                   416,589,930,373,202,253,775, 47,731,685,293,126,133,450,545,100,741,583,763,306,\n                   655,267,248,477,549,238, 62,678, 98,534,622,907,406,714,184,391,913, 42,560,247,\n                   346,860, 56,138,546, 38,985,948, 58,213,799,319,390,634,458,945,733,507,916,123,\n                   345,110,720,917,313,845,426,  9,457,628,410,723,354,895,881,953,677,137,397, 97,\n                   854,740, 83,216,421, 94,517,479,292,963,376,981,480, 39,257,272,157,  5,316,395,\n                   787,942,456,242,759,898,576, 67,298,425,894,435,831,241,989,614,987,770,384,692,\n                   698,765,331,487,251,600,879,342,982,527,736,795,585, 40, 54,901,408,359,577,237,\n                   605,847,353,968,832,205,838,427,876,959,686,646,835,127,621,892,443,198,988,791,\n                   466, 23,707,467, 33,670,921,180,991,396,160,436,717,918,  8,374,101,684,727,749])\n\ndef bin(limits, data)\n  data.map{|d| limits.bsearch{|limit| limit > d} }.tally\nend\n\ndef present_bins(limits, bins)\n  ranges = ([nil]+limits+[nil]).each_cons(2).map{|low, high| Range.new(low, high, true) }\n  ranges.each{|range| puts \"\nend\n\ntests.each do |test|\n  present_bins(test.limits, bin(test.limits, test.data))\n  puts\nend\n", "target": "import java.util.Arrays;\nimport java.util.Collections;\nimport java.util.List;\n\npublic class Bins {\n    public static <T extends Comparable<? super T>> int[] bins(\n            List<? extends T> limits, Iterable<? extends T> data) {\n        int[] result = new int[limits.size() + 1];\n        for (T n : data) {\n            int i = Collections.binarySearch(limits, n);\n            if (i >= 0) {\n                \n                i = i+1;\n            } else {\n                \n                i = ~i;\n            }\n            result[i]++;\n        }\n        return result;\n    }\n\n    public static void printBins(List<?> limits, int[] bins) {\n        int n = limits.size();\n        if (n == 0) {\n            return;\n        }\n        assert n+1 == bins.length;\n        System.out.printf(\"           < %3s: %2d\\n\", limits.get(0), bins[0]);\n        for (int i = 1; i < n; i++) {\n            System.out.printf(\">= %3s and < %3s: %2d\\n\", limits.get(i-1), limits.get(i), bins[i]);\n        }\n        System.out.printf(\">= %3s         \u00a0: %2d\\n\", limits.get(n-1), bins[n]);\n    }\n\n    public static void main(String[] args) {\n        List<Integer> limits = Arrays.asList(23, 37, 43, 53, 67, 83);\n        List<Integer> data = Arrays.asList(\n            95, 21, 94, 12, 99, 4,  70, 75, 83, 93, 52, 80, 57, 5,  53, 86, 65,\n            17, 92, 83, 71, 61, 54, 58, 47, 16, 8,  9,  32, 84, 7,  87, 46, 19,\n            30, 37, 96, 6,  98, 40, 79, 97, 45, 64, 60, 29, 49, 36, 43, 55);\n\n        System.out.println(\"Example 1:\");\n        printBins(limits, bins(limits, data));\n\n        limits = Arrays.asList(14,  18,  249, 312, 389,\n                               392, 513, 591, 634, 720);\n        data = Arrays.asList(\n            445, 814, 519, 697, 700, 130, 255, 889, 481, 122, 932, 77,  323, 525,\n            570, 219, 367, 523, 442, 933, 416, 589, 930, 373, 202, 253, 775, 47,\n            731, 685, 293, 126, 133, 450, 545, 100, 741, 583, 763, 306, 655, 267,\n            248, 477, 549, 238, 62,  678, 98,  534, 622, 907, 406, 714, 184, 391,\n            913, 42,  560, 247, 346, 860, 56,  138, 546, 38,  985, 948, 58,  213,\n            799, 319, 390, 634, 458, 945, 733, 507, 916, 123, 345, 110, 720, 917,\n            313, 845, 426, 9,   457, 628, 410, 723, 354, 895, 881, 953, 677, 137,\n            397, 97,  854, 740, 83,  216, 421, 94,  517, 479, 292, 963, 376, 981,\n            480, 39,  257, 272, 157, 5,   316, 395, 787, 942, 456, 242, 759, 898,\n            576, 67,  298, 425, 894, 435, 831, 241, 989, 614, 987, 770, 384, 692,\n            698, 765, 331, 487, 251, 600, 879, 342, 982, 527, 736, 795, 585, 40,\n            54,  901, 408, 359, 577, 237, 605, 847, 353, 968, 832, 205, 838, 427,\n            876, 959, 686, 646, 835, 127, 621, 892, 443, 198, 988, 791, 466, 23,\n            707, 467, 33,  670, 921, 180, 991, 396, 160, 436, 717, 918, 8,   374,\n            101, 684, 727, 749);\n\n        System.out.println();\n        System.out.println(\"Example 2:\");\n        printBins(limits, bins(limits, data));\n    }\n}\n"}
{"id": 8419, "name": "Bin given limits", "source": "Translate Ruby to Python: Test = Struct.new(:limits, :data)\ntests = Test.new( [23, 37, 43, 53, 67, 83],\n                  [95,21,94,12,99,4,70,75,83,93,52,80,57,5,53,86,65,17,92,83,71,61,54,58,47,\n                   16, 8, 9,32,84,7,87,46,19,30,37,96,6,98,40,79,97,45,64,60,29,49,36,43,55]),\n        Test.new( [14, 18, 249, 312, 389, 392, 513, 591, 634, 720],\n                  [445,814,519,697,700,130,255,889,481,122,932, 77,323,525,570,219,367,523,442,933,\n                   416,589,930,373,202,253,775, 47,731,685,293,126,133,450,545,100,741,583,763,306,\n                   655,267,248,477,549,238, 62,678, 98,534,622,907,406,714,184,391,913, 42,560,247,\n                   346,860, 56,138,546, 38,985,948, 58,213,799,319,390,634,458,945,733,507,916,123,\n                   345,110,720,917,313,845,426,  9,457,628,410,723,354,895,881,953,677,137,397, 97,\n                   854,740, 83,216,421, 94,517,479,292,963,376,981,480, 39,257,272,157,  5,316,395,\n                   787,942,456,242,759,898,576, 67,298,425,894,435,831,241,989,614,987,770,384,692,\n                   698,765,331,487,251,600,879,342,982,527,736,795,585, 40, 54,901,408,359,577,237,\n                   605,847,353,968,832,205,838,427,876,959,686,646,835,127,621,892,443,198,988,791,\n                   466, 23,707,467, 33,670,921,180,991,396,160,436,717,918,  8,374,101,684,727,749])\n\ndef bin(limits, data)\n  data.map{|d| limits.bsearch{|limit| limit > d} }.tally\nend\n\ndef present_bins(limits, bins)\n  ranges = ([nil]+limits+[nil]).each_cons(2).map{|low, high| Range.new(low, high, true) }\n  ranges.each{|range| puts \"\nend\n\ntests.each do |test|\n  present_bins(test.limits, bin(test.limits, test.data))\n  puts\nend\n", "target": "from bisect import bisect_right\n\ndef bin_it(limits: list, data: list) -> list:\n    \"Bin data according to (ascending) limits.\"\n    bins = [0] * (len(limits) + 1)      \n    for d in data:\n        bins[bisect_right(limits, d)] += 1\n    return bins\n\ndef bin_print(limits: list, bins: list) -> list:\n    print(f\"          < {limits[0]:3}\u00a0:= {bins[0]:3}\")\n    for lo, hi, count in zip(limits, limits[1:], bins[1:]):\n        print(f\">= {lo:3} .. < {hi:3}\u00a0:= {count:3}\")\n    print(f\">= {limits[-1]:3}         \u00a0:= {bins[-1]:3}\")\n\n\nif __name__ == \"__main__\":\n    print(\"RC FIRST EXAMPLE\\n\")\n    limits  = [23, 37, 43, 53, 67, 83]\n    data = [95,21,94,12,99,4,70,75,83,93,52,80,57,5,53,86,65,17,92,83,71,61,54,58,47,\n            16, 8, 9,32,84,7,87,46,19,30,37,96,6,98,40,79,97,45,64,60,29,49,36,43,55]\n    bins = bin_it(limits, data)\n    bin_print(limits, bins)\n\n    print(\"\\nRC SECOND EXAMPLE\\n\")\n    limits = [14, 18, 249, 312, 389, 392, 513, 591, 634, 720]\n    data = [445,814,519,697,700,130,255,889,481,122,932, 77,323,525,570,219,367,523,442,933,\n            416,589,930,373,202,253,775, 47,731,685,293,126,133,450,545,100,741,583,763,306,\n            655,267,248,477,549,238, 62,678, 98,534,622,907,406,714,184,391,913, 42,560,247,\n            346,860, 56,138,546, 38,985,948, 58,213,799,319,390,634,458,945,733,507,916,123,\n            345,110,720,917,313,845,426,  9,457,628,410,723,354,895,881,953,677,137,397, 97,\n            854,740, 83,216,421, 94,517,479,292,963,376,981,480, 39,257,272,157,  5,316,395,\n            787,942,456,242,759,898,576, 67,298,425,894,435,831,241,989,614,987,770,384,692,\n            698,765,331,487,251,600,879,342,982,527,736,795,585, 40, 54,901,408,359,577,237,\n            605,847,353,968,832,205,838,427,876,959,686,646,835,127,621,892,443,198,988,791,\n            466, 23,707,467, 33,670,921,180,991,396,160,436,717,918,  8,374,101,684,727,749]\n    bins = bin_it(limits, data)\n    bin_print(limits, bins)\n"}
{"id": 8420, "name": "Bin given limits", "source": "Translate Ruby to Python: Test = Struct.new(:limits, :data)\ntests = Test.new( [23, 37, 43, 53, 67, 83],\n                  [95,21,94,12,99,4,70,75,83,93,52,80,57,5,53,86,65,17,92,83,71,61,54,58,47,\n                   16, 8, 9,32,84,7,87,46,19,30,37,96,6,98,40,79,97,45,64,60,29,49,36,43,55]),\n        Test.new( [14, 18, 249, 312, 389, 392, 513, 591, 634, 720],\n                  [445,814,519,697,700,130,255,889,481,122,932, 77,323,525,570,219,367,523,442,933,\n                   416,589,930,373,202,253,775, 47,731,685,293,126,133,450,545,100,741,583,763,306,\n                   655,267,248,477,549,238, 62,678, 98,534,622,907,406,714,184,391,913, 42,560,247,\n                   346,860, 56,138,546, 38,985,948, 58,213,799,319,390,634,458,945,733,507,916,123,\n                   345,110,720,917,313,845,426,  9,457,628,410,723,354,895,881,953,677,137,397, 97,\n                   854,740, 83,216,421, 94,517,479,292,963,376,981,480, 39,257,272,157,  5,316,395,\n                   787,942,456,242,759,898,576, 67,298,425,894,435,831,241,989,614,987,770,384,692,\n                   698,765,331,487,251,600,879,342,982,527,736,795,585, 40, 54,901,408,359,577,237,\n                   605,847,353,968,832,205,838,427,876,959,686,646,835,127,621,892,443,198,988,791,\n                   466, 23,707,467, 33,670,921,180,991,396,160,436,717,918,  8,374,101,684,727,749])\n\ndef bin(limits, data)\n  data.map{|d| limits.bsearch{|limit| limit > d} }.tally\nend\n\ndef present_bins(limits, bins)\n  ranges = ([nil]+limits+[nil]).each_cons(2).map{|low, high| Range.new(low, high, true) }\n  ranges.each{|range| puts \"\nend\n\ntests.each do |test|\n  present_bins(test.limits, bin(test.limits, test.data))\n  puts\nend\n", "target": "from bisect import bisect_right\n\ndef bin_it(limits: list, data: list) -> list:\n    \"Bin data according to (ascending) limits.\"\n    bins = [0] * (len(limits) + 1)      \n    for d in data:\n        bins[bisect_right(limits, d)] += 1\n    return bins\n\ndef bin_print(limits: list, bins: list) -> list:\n    print(f\"          < {limits[0]:3}\u00a0:= {bins[0]:3}\")\n    for lo, hi, count in zip(limits, limits[1:], bins[1:]):\n        print(f\">= {lo:3} .. < {hi:3}\u00a0:= {count:3}\")\n    print(f\">= {limits[-1]:3}         \u00a0:= {bins[-1]:3}\")\n\n\nif __name__ == \"__main__\":\n    print(\"RC FIRST EXAMPLE\\n\")\n    limits  = [23, 37, 43, 53, 67, 83]\n    data = [95,21,94,12,99,4,70,75,83,93,52,80,57,5,53,86,65,17,92,83,71,61,54,58,47,\n            16, 8, 9,32,84,7,87,46,19,30,37,96,6,98,40,79,97,45,64,60,29,49,36,43,55]\n    bins = bin_it(limits, data)\n    bin_print(limits, bins)\n\n    print(\"\\nRC SECOND EXAMPLE\\n\")\n    limits = [14, 18, 249, 312, 389, 392, 513, 591, 634, 720]\n    data = [445,814,519,697,700,130,255,889,481,122,932, 77,323,525,570,219,367,523,442,933,\n            416,589,930,373,202,253,775, 47,731,685,293,126,133,450,545,100,741,583,763,306,\n            655,267,248,477,549,238, 62,678, 98,534,622,907,406,714,184,391,913, 42,560,247,\n            346,860, 56,138,546, 38,985,948, 58,213,799,319,390,634,458,945,733,507,916,123,\n            345,110,720,917,313,845,426,  9,457,628,410,723,354,895,881,953,677,137,397, 97,\n            854,740, 83,216,421, 94,517,479,292,963,376,981,480, 39,257,272,157,  5,316,395,\n            787,942,456,242,759,898,576, 67,298,425,894,435,831,241,989,614,987,770,384,692,\n            698,765,331,487,251,600,879,342,982,527,736,795,585, 40, 54,901,408,359,577,237,\n            605,847,353,968,832,205,838,427,876,959,686,646,835,127,621,892,443,198,988,791,\n            466, 23,707,467, 33,670,921,180,991,396,160,436,717,918,  8,374,101,684,727,749]\n    bins = bin_it(limits, data)\n    bin_print(limits, bins)\n"}
{"id": 8810, "name": "Department numbers", "source": "Translate Ruby to C#: (1..7).to_a.permutation(3){|p| puts p.join if p.first.even? && p.sum == 12 }\n", "target": "using System;\npublic class Program\n{\n    public static void Main() {\n        for (int p = 2; p <= 7; p+=2) {\n            for (int s = 1; s <= 7; s++) {\n                int f = 12 - p - s;\n                if (s >= f) break;\n                if (f > 7) continue;\n                if (s == p || f == p) continue; \n                Console.WriteLine($\"Police:{p}, Sanitation:{s}, Fire:{f}\");\n                Console.WriteLine($\"Police:{p}, Sanitation:{f}, Fire:{s}\");\n            }\n        }\n    }\n}\n"}
{"id": 8811, "name": "Department numbers", "source": "Translate Ruby to C#: (1..7).to_a.permutation(3){|p| puts p.join if p.first.even? && p.sum == 12 }\n", "target": "using System;\npublic class Program\n{\n    public static void Main() {\n        for (int p = 2; p <= 7; p+=2) {\n            for (int s = 1; s <= 7; s++) {\n                int f = 12 - p - s;\n                if (s >= f) break;\n                if (f > 7) continue;\n                if (s == p || f == p) continue; \n                Console.WriteLine($\"Police:{p}, Sanitation:{s}, Fire:{f}\");\n                Console.WriteLine($\"Police:{p}, Sanitation:{f}, Fire:{s}\");\n            }\n        }\n    }\n}\n"}
{"id": 8814, "name": "Department numbers", "source": "Translate Ruby to Java: (1..7).to_a.permutation(3){|p| puts p.join if p.first.even? && p.sum == 12 }\n", "target": "public class DepartmentNumbers {\n    public static void main(String[] args) {\n        System.out.println(\"Police  Sanitation  Fire\");\n        System.out.println(\"------  ----------  ----\");\n        int count = 0;\n        for (int i = 2; i <= 6; i += 2) {\n            for (int j = 1; j <= 7; ++j) {\n                if (j == i) continue;\n                for (int k = 1; k <= 7; ++k) {\n                    if (k == i || k == j) continue;\n                    if (i + j + k != 12) continue;\n                    System.out.printf(\"  %d         %d         %d\\n\", i, j, k);\n                    count++;\n                }\n            }\n        }\n        System.out.printf(\"\\n%d valid combinations\", count);\n    }\n}\n"}
{"id": 8815, "name": "Department numbers", "source": "Translate Ruby to Java: (1..7).to_a.permutation(3){|p| puts p.join if p.first.even? && p.sum == 12 }\n", "target": "public class DepartmentNumbers {\n    public static void main(String[] args) {\n        System.out.println(\"Police  Sanitation  Fire\");\n        System.out.println(\"------  ----------  ----\");\n        int count = 0;\n        for (int i = 2; i <= 6; i += 2) {\n            for (int j = 1; j <= 7; ++j) {\n                if (j == i) continue;\n                for (int k = 1; k <= 7; ++k) {\n                    if (k == i || k == j) continue;\n                    if (i + j + k != 12) continue;\n                    System.out.printf(\"  %d         %d         %d\\n\", i, j, k);\n                    count++;\n                }\n            }\n        }\n        System.out.printf(\"\\n%d valid combinations\", count);\n    }\n}\n"}
{"id": 8816, "name": "Department numbers", "source": "Translate Ruby to Python: (1..7).to_a.permutation(3){|p| puts p.join if p.first.even? && p.sum == 12 }\n", "target": "from itertools import permutations\n \ndef solve():\n    c, p, f, s = \"\\\\,Police,Fire,Sanitation\".split(',')\n    print(f\"{c:>3}  {p:^6} {f:^4} {s:^10}\")\n    c = 1\n    for p, f, s in permutations(range(1, 8), r=3):\n        if p + s + f == 12 and p % 2 == 0:\n            print(f\"{c:>3}: {p:^6} {f:^4} {s:^10}\")\n            c += 1\n \nif __name__ == '__main__':\n    solve()\n"}
{"id": 8817, "name": "Department numbers", "source": "Translate Ruby to Python: (1..7).to_a.permutation(3){|p| puts p.join if p.first.even? && p.sum == 12 }\n", "target": "from itertools import permutations\n \ndef solve():\n    c, p, f, s = \"\\\\,Police,Fire,Sanitation\".split(',')\n    print(f\"{c:>3}  {p:^6} {f:^4} {s:^10}\")\n    c = 1\n    for p, f, s in permutations(range(1, 8), r=3):\n        if p + s + f == 12 and p % 2 == 0:\n            print(f\"{c:>3}: {p:^6} {f:^4} {s:^10}\")\n            c += 1\n \nif __name__ == '__main__':\n    solve()\n"}
{"id": 9222, "name": "Fusc sequence", "source": "Translate Ruby to C#: fusc = Enumerator.new do |y|\n  y << 0\n  y << 1\n  arr = [0,1]\n  2.step do |n|\n    res = n.even? ? arr[n/2] : arr[(n-1)/2] + arr[(n+1)/2]\n    y   << res\n    arr << res\n  end\nend\n\nfusc_max_digits = Enumerator.new do |y|\n   cur_max, cur_exp = 0, 0\n   0.step do |i|\n      f = fusc.next\n      if f >= cur_max\n        cur_exp += 1\n        cur_max = 10**cur_exp\n        y << [i, f]\n      end\n   end\nend\n\nputs fusc.take(61).join(\" \")\nfusc_max_digits.take(6).each{|pair| puts \"%15s\u00a0: %s\" % pair }\n", "target": "using System;\nusing System.Collections.Generic;\n\nstatic class program\n{\n    static int n = 61;\n    static List<int> l = new List<int>() { 0, 1 };\n\n    static int fusc(int n)\n    {\n        if (n < l.Count) return l[n];\n        int f = (n & 1) == 0 ? l[n >> 1] : l[(n - 1) >> 1] + l[(n + 1) >> 1];\n        l.Add(f); return f;\n    }\n\n    static void Main(string[] args)\n    {\n        bool lst = true; int w = -1, c = 0, t;\n        string fs = \"{0,11:n0}  {1,-9:n0}\", res = \"\";\n        Console.WriteLine(\"First {0} numbers in the fusc sequence:\", n);\n        for (int i = 0; i < int.MaxValue; i++)\n        {\n            int f = fusc(i); if (lst)\n            {\n                if (i < 61) Console.Write(\"{0} \", f);\n                else\n                {\n                    lst = false;\n                    Console.WriteLine();\n                    Console.WriteLine(\"Points in the sequence where an item has more digits than any previous items:\");\n                    Console.WriteLine(fs, \"Index\\\\\", \"/Value\"); Console.WriteLine(res); res = \"\";\n                }\n            }\n            if ((t = f.ToString().Length) > w)\n            {\n                w = t; res += (res == \"\" ? \"\" : \"\\n\") + string.Format(fs, i, f);\n                if (!lst) { Console.WriteLine(res); res = \"\"; } if (++c > 5) break;\n            }\n        }\n        l.Clear();\n    }\n}\n"}
{"id": 9223, "name": "Fusc sequence", "source": "Translate Ruby to C#: fusc = Enumerator.new do |y|\n  y << 0\n  y << 1\n  arr = [0,1]\n  2.step do |n|\n    res = n.even? ? arr[n/2] : arr[(n-1)/2] + arr[(n+1)/2]\n    y   << res\n    arr << res\n  end\nend\n\nfusc_max_digits = Enumerator.new do |y|\n   cur_max, cur_exp = 0, 0\n   0.step do |i|\n      f = fusc.next\n      if f >= cur_max\n        cur_exp += 1\n        cur_max = 10**cur_exp\n        y << [i, f]\n      end\n   end\nend\n\nputs fusc.take(61).join(\" \")\nfusc_max_digits.take(6).each{|pair| puts \"%15s\u00a0: %s\" % pair }\n", "target": "using System;\nusing System.Collections.Generic;\n\nstatic class program\n{\n    static int n = 61;\n    static List<int> l = new List<int>() { 0, 1 };\n\n    static int fusc(int n)\n    {\n        if (n < l.Count) return l[n];\n        int f = (n & 1) == 0 ? l[n >> 1] : l[(n - 1) >> 1] + l[(n + 1) >> 1];\n        l.Add(f); return f;\n    }\n\n    static void Main(string[] args)\n    {\n        bool lst = true; int w = -1, c = 0, t;\n        string fs = \"{0,11:n0}  {1,-9:n0}\", res = \"\";\n        Console.WriteLine(\"First {0} numbers in the fusc sequence:\", n);\n        for (int i = 0; i < int.MaxValue; i++)\n        {\n            int f = fusc(i); if (lst)\n            {\n                if (i < 61) Console.Write(\"{0} \", f);\n                else\n                {\n                    lst = false;\n                    Console.WriteLine();\n                    Console.WriteLine(\"Points in the sequence where an item has more digits than any previous items:\");\n                    Console.WriteLine(fs, \"Index\\\\\", \"/Value\"); Console.WriteLine(res); res = \"\";\n                }\n            }\n            if ((t = f.ToString().Length) > w)\n            {\n                w = t; res += (res == \"\" ? \"\" : \"\\n\") + string.Format(fs, i, f);\n                if (!lst) { Console.WriteLine(res); res = \"\"; } if (++c > 5) break;\n            }\n        }\n        l.Clear();\n    }\n}\n"}
{"id": 9226, "name": "Fusc sequence", "source": "Translate Ruby to Java: fusc = Enumerator.new do |y|\n  y << 0\n  y << 1\n  arr = [0,1]\n  2.step do |n|\n    res = n.even? ? arr[n/2] : arr[(n-1)/2] + arr[(n+1)/2]\n    y   << res\n    arr << res\n  end\nend\n\nfusc_max_digits = Enumerator.new do |y|\n   cur_max, cur_exp = 0, 0\n   0.step do |i|\n      f = fusc.next\n      if f >= cur_max\n        cur_exp += 1\n        cur_max = 10**cur_exp\n        y << [i, f]\n      end\n   end\nend\n\nputs fusc.take(61).join(\" \")\nfusc_max_digits.take(6).each{|pair| puts \"%15s\u00a0: %s\" % pair }\n", "target": "public class FuscSequence {\n\n    public static void main(String[] args) {\n        System.out.println(\"Show the first 61 fusc numbers (starting at zero) in a horizontal format\");\n        for ( int n = 0 ; n < 61 ; n++ ) {\n            System.out.printf(\"%,d \", fusc[n]);\n        }\n        \n        System.out.printf(\"%n%nShow the fusc number (and its index) whose length is greater than any previous fusc number length.%n\");\n        int start = 0;\n        for (int i = 0 ; i <= 5 ; i++ ) {\n            int val = i != 0 ? (int) Math.pow(10, i) : -1;\n            for ( int j = start ; j < FUSC_MAX ; j++ ) {\n                if ( fusc[j] > val ) {\n                    System.out.printf(\"fusc[%,d] =\u00a0%,d%n\", j, fusc[j] );\n                    start = j;\n                    break;\n                }\n            }\n        }\n    }\n    \n    private static final int FUSC_MAX = 30000000;\n    private static int[] fusc = new int[FUSC_MAX];\n\n    static {\n        fusc[0] = 0;\n        fusc[1] = 1;\n        for ( int n = 2 ; n < FUSC_MAX ; n++ ) {\n            fusc[n] = (n % 2 == 0 ? fusc[n/2] : fusc[(n-1)/2] + fusc[(n+1)/2]);\n        }\n    }\n}\n"}
{"id": 9227, "name": "Fusc sequence", "source": "Translate Ruby to Java: fusc = Enumerator.new do |y|\n  y << 0\n  y << 1\n  arr = [0,1]\n  2.step do |n|\n    res = n.even? ? arr[n/2] : arr[(n-1)/2] + arr[(n+1)/2]\n    y   << res\n    arr << res\n  end\nend\n\nfusc_max_digits = Enumerator.new do |y|\n   cur_max, cur_exp = 0, 0\n   0.step do |i|\n      f = fusc.next\n      if f >= cur_max\n        cur_exp += 1\n        cur_max = 10**cur_exp\n        y << [i, f]\n      end\n   end\nend\n\nputs fusc.take(61).join(\" \")\nfusc_max_digits.take(6).each{|pair| puts \"%15s\u00a0: %s\" % pair }\n", "target": "public class FuscSequence {\n\n    public static void main(String[] args) {\n        System.out.println(\"Show the first 61 fusc numbers (starting at zero) in a horizontal format\");\n        for ( int n = 0 ; n < 61 ; n++ ) {\n            System.out.printf(\"%,d \", fusc[n]);\n        }\n        \n        System.out.printf(\"%n%nShow the fusc number (and its index) whose length is greater than any previous fusc number length.%n\");\n        int start = 0;\n        for (int i = 0 ; i <= 5 ; i++ ) {\n            int val = i != 0 ? (int) Math.pow(10, i) : -1;\n            for ( int j = start ; j < FUSC_MAX ; j++ ) {\n                if ( fusc[j] > val ) {\n                    System.out.printf(\"fusc[%,d] =\u00a0%,d%n\", j, fusc[j] );\n                    start = j;\n                    break;\n                }\n            }\n        }\n    }\n    \n    private static final int FUSC_MAX = 30000000;\n    private static int[] fusc = new int[FUSC_MAX];\n\n    static {\n        fusc[0] = 0;\n        fusc[1] = 1;\n        for ( int n = 2 ; n < FUSC_MAX ; n++ ) {\n            fusc[n] = (n % 2 == 0 ? fusc[n/2] : fusc[(n-1)/2] + fusc[(n+1)/2]);\n        }\n    }\n}\n"}
{"id": 9228, "name": "Fusc sequence", "source": "Translate Ruby to Python: fusc = Enumerator.new do |y|\n  y << 0\n  y << 1\n  arr = [0,1]\n  2.step do |n|\n    res = n.even? ? arr[n/2] : arr[(n-1)/2] + arr[(n+1)/2]\n    y   << res\n    arr << res\n  end\nend\n\nfusc_max_digits = Enumerator.new do |y|\n   cur_max, cur_exp = 0, 0\n   0.step do |i|\n      f = fusc.next\n      if f >= cur_max\n        cur_exp += 1\n        cur_max = 10**cur_exp\n        y << [i, f]\n      end\n   end\nend\n\nputs fusc.take(61).join(\" \")\nfusc_max_digits.take(6).each{|pair| puts \"%15s\u00a0: %s\" % pair }\n", "target": "from collections import deque\nfrom itertools import islice, count\n\n\ndef fusc():\n    q = deque([1])\n    yield 0\n    yield 1\n\n    while True:\n        x = q.popleft()\n        q.append(x)\n        yield x\n\n        x += q[0]\n        q.append(x)\n        yield x\n\n\ndef longest_fusc():\n    sofar = 0\n    for i, f in zip(count(), fusc()):\n        if f >= sofar:\n            yield(i, f)\n            sofar = 10 * sofar or 10\n\n\nprint('First 61:')\nprint(list(islice(fusc(), 61)))\n\nprint('\\nLength records:')\nfor i, f in islice(longest_fusc(), 6):\n    print(f'fusc({i}) = {f}')\n"}
{"id": 9229, "name": "Fusc sequence", "source": "Translate Ruby to Python: fusc = Enumerator.new do |y|\n  y << 0\n  y << 1\n  arr = [0,1]\n  2.step do |n|\n    res = n.even? ? arr[n/2] : arr[(n-1)/2] + arr[(n+1)/2]\n    y   << res\n    arr << res\n  end\nend\n\nfusc_max_digits = Enumerator.new do |y|\n   cur_max, cur_exp = 0, 0\n   0.step do |i|\n      f = fusc.next\n      if f >= cur_max\n        cur_exp += 1\n        cur_max = 10**cur_exp\n        y << [i, f]\n      end\n   end\nend\n\nputs fusc.take(61).join(\" \")\nfusc_max_digits.take(6).each{|pair| puts \"%15s\u00a0: %s\" % pair }\n", "target": "from collections import deque\nfrom itertools import islice, count\n\n\ndef fusc():\n    q = deque([1])\n    yield 0\n    yield 1\n\n    while True:\n        x = q.popleft()\n        q.append(x)\n        yield x\n\n        x += q[0]\n        q.append(x)\n        yield x\n\n\ndef longest_fusc():\n    sofar = 0\n    for i, f in zip(count(), fusc()):\n        if f >= sofar:\n            yield(i, f)\n            sofar = 10 * sofar or 10\n\n\nprint('First 61:')\nprint(list(islice(fusc(), 61)))\n\nprint('\\nLength records:')\nfor i, f in islice(longest_fusc(), 6):\n    print(f'fusc({i}) = {f}')\n"}
{"id": 9426, "name": "Singly-linked list_Traversal", "source": "Translate Ruby to C#: head = ListNode.new(\"a\", ListNode.new(\"b\", ListNode.new(\"c\")))\nhead.insertAfter(\"b\", \"b+\")\n\n\nhead.each {|node| print node.value, \",\"}\nputs\n\n\ncurrent = head\nbegin\n  print current.value, \",\"\nend while current = current.succ\nputs\n", "target": "var current = [head of list to traverse]\nwhile(current != null)\n{\n    \n\n    current = current.Next;\n}\n"}
{"id": 9428, "name": "Singly-linked list_Traversal", "source": "Translate Ruby to Java: head = ListNode.new(\"a\", ListNode.new(\"b\", ListNode.new(\"c\")))\nhead.insertAfter(\"b\", \"b+\")\n\n\nhead.each {|node| print node.value, \",\"}\nputs\n\n\ncurrent = head\nbegin\n  print current.value, \",\"\nend while current = current.succ\nputs\n", "target": "LinkedList<Type> list = new LinkedList<Type>();\n\nfor(Type i: list){\n  \n  System.out.println(i);\n}\n"}
{"id": 9429, "name": "Singly-linked list_Traversal", "source": "Translate Ruby to Python: head = ListNode.new(\"a\", ListNode.new(\"b\", ListNode.new(\"c\")))\nhead.insertAfter(\"b\", \"b+\")\n\n\nhead.each {|node| print node.value, \",\"}\nputs\n\n\ncurrent = head\nbegin\n  print current.value, \",\"\nend while current = current.succ\nputs\n", "target": "for node in lst:\n    print node.value\n"}
{"id": 9886, "name": "Haversine formula", "source": "Translate Ruby to C#: include Math\n \ndef haversine(lat1, lon1, lat2, lon2)\n    r = 6372.8        \n    deg2rad = PI/180  \n \n    dLat = (lat2 - lat1) * deg2rad\n    dLon = (lon2 - lon1) * deg2rad\n    lat1 = lat1 * deg2rad\n    lat2 = lat2 * deg2rad\n \n    a = sin(dLat / 2)**2 + cos(lat1) * cos(lat2) * sin(dLon / 2)**2\n    c = 2 * asin(sqrt(a))\n    r * c\nend\n\nputs \"distance is \n", "target": "public static class Haversine {\n  public static double calculate(double lat1, double lon1, double lat2, double lon2) {\n    var R = 6372.8; \n    var dLat = toRadians(lat2 - lat1);\n    var dLon = toRadians(lon2 - lon1);\n    lat1 = toRadians(lat1);\n    lat2 = toRadians(lat2);\n   \n    var a = Math.Sin(dLat / 2) * Math.Sin(dLat / 2) + Math.Sin(dLon / 2) * Math.Sin(dLon / 2) * Math.Cos(lat1) * Math.Cos(lat2);\n    var c = 2 * Math.Asin(Math.Sqrt(a));\n    return R * 2 * Math.Asin(Math.Sqrt(a));\n  }\n  \n  public static double toRadians(double angle) {\n    return Math.PI * angle / 180.0;\n  }\n}\n\nvoid Main() {\n  Console.WriteLine(String.Format(\"The distance between coordinates {0},{1} and {2},{3} is: {4}\", 36.12, -86.67, 33.94, -118.40, Haversine.calculate(36.12, -86.67, 33.94, -118.40)));\n}\n\n\n"}
{"id": 9887, "name": "Haversine formula", "source": "Translate Ruby to C#: include Math\n \ndef haversine(lat1, lon1, lat2, lon2)\n    r = 6372.8        \n    deg2rad = PI/180  \n \n    dLat = (lat2 - lat1) * deg2rad\n    dLon = (lon2 - lon1) * deg2rad\n    lat1 = lat1 * deg2rad\n    lat2 = lat2 * deg2rad\n \n    a = sin(dLat / 2)**2 + cos(lat1) * cos(lat2) * sin(dLon / 2)**2\n    c = 2 * asin(sqrt(a))\n    r * c\nend\n\nputs \"distance is \n", "target": "public static class Haversine {\n  public static double calculate(double lat1, double lon1, double lat2, double lon2) {\n    var R = 6372.8; \n    var dLat = toRadians(lat2 - lat1);\n    var dLon = toRadians(lon2 - lon1);\n    lat1 = toRadians(lat1);\n    lat2 = toRadians(lat2);\n   \n    var a = Math.Sin(dLat / 2) * Math.Sin(dLat / 2) + Math.Sin(dLon / 2) * Math.Sin(dLon / 2) * Math.Cos(lat1) * Math.Cos(lat2);\n    var c = 2 * Math.Asin(Math.Sqrt(a));\n    return R * 2 * Math.Asin(Math.Sqrt(a));\n  }\n  \n  public static double toRadians(double angle) {\n    return Math.PI * angle / 180.0;\n  }\n}\n\nvoid Main() {\n  Console.WriteLine(String.Format(\"The distance between coordinates {0},{1} and {2},{3} is: {4}\", 36.12, -86.67, 33.94, -118.40, Haversine.calculate(36.12, -86.67, 33.94, -118.40)));\n}\n\n\n"}
{"id": 9890, "name": "Haversine formula", "source": "Translate Ruby to Java: include Math\n \ndef haversine(lat1, lon1, lat2, lon2)\n    r = 6372.8        \n    deg2rad = PI/180  \n \n    dLat = (lat2 - lat1) * deg2rad\n    dLon = (lon2 - lon1) * deg2rad\n    lat1 = lat1 * deg2rad\n    lat2 = lat2 * deg2rad\n \n    a = sin(dLat / 2)**2 + cos(lat1) * cos(lat2) * sin(dLon / 2)**2\n    c = 2 * asin(sqrt(a))\n    r * c\nend\n\nputs \"distance is \n", "target": "public class Haversine {\n    public static final double R = 6372.8; \n\n    public static double haversine(double lat1, double lon1, double lat2, double lon2) {\n        lat1 = Math.toRadians(lat1);\n        lat2 = Math.toRadians(lat2);\n        double dLat = lat2 - lat1;\n        double dLon = Math.toRadians(lon2 - lon1);\n\n        double a = Math.pow(Math.sin(dLat / 2), 2) + Math.pow(Math.sin(dLon / 2), 2) * Math.cos(lat1) * Math.cos(lat2);\n        double c = 2 * Math.asin(Math.sqrt(a));\n        return R * c;\n    }\n\n    public static void main(String[] args) {\n        System.out.println(haversine(36.12, -86.67, 33.94, -118.40));\n    }\n}\n"}
{"id": 9891, "name": "Haversine formula", "source": "Translate Ruby to Java: include Math\n \ndef haversine(lat1, lon1, lat2, lon2)\n    r = 6372.8        \n    deg2rad = PI/180  \n \n    dLat = (lat2 - lat1) * deg2rad\n    dLon = (lon2 - lon1) * deg2rad\n    lat1 = lat1 * deg2rad\n    lat2 = lat2 * deg2rad\n \n    a = sin(dLat / 2)**2 + cos(lat1) * cos(lat2) * sin(dLon / 2)**2\n    c = 2 * asin(sqrt(a))\n    r * c\nend\n\nputs \"distance is \n", "target": "public class Haversine {\n    public static final double R = 6372.8; \n\n    public static double haversine(double lat1, double lon1, double lat2, double lon2) {\n        lat1 = Math.toRadians(lat1);\n        lat2 = Math.toRadians(lat2);\n        double dLat = lat2 - lat1;\n        double dLon = Math.toRadians(lon2 - lon1);\n\n        double a = Math.pow(Math.sin(dLat / 2), 2) + Math.pow(Math.sin(dLon / 2), 2) * Math.cos(lat1) * Math.cos(lat2);\n        double c = 2 * Math.asin(Math.sqrt(a));\n        return R * c;\n    }\n\n    public static void main(String[] args) {\n        System.out.println(haversine(36.12, -86.67, 33.94, -118.40));\n    }\n}\n"}
{"id": 9892, "name": "Haversine formula", "source": "Translate Ruby to Python: include Math\n \ndef haversine(lat1, lon1, lat2, lon2)\n    r = 6372.8        \n    deg2rad = PI/180  \n \n    dLat = (lat2 - lat1) * deg2rad\n    dLon = (lon2 - lon1) * deg2rad\n    lat1 = lat1 * deg2rad\n    lat2 = lat2 * deg2rad\n \n    a = sin(dLat / 2)**2 + cos(lat1) * cos(lat2) * sin(dLon / 2)**2\n    c = 2 * asin(sqrt(a))\n    r * c\nend\n\nputs \"distance is \n", "target": "from math import radians, sin, cos, sqrt, asin\n\n\ndef haversine(lat1, lon1, lat2, lon2):\n    R = 6372.8  \n\n    dLat = radians(lat2 - lat1)\n    dLon = radians(lon2 - lon1)\n    lat1 = radians(lat1)\n    lat2 = radians(lat2)\n\n    a = sin(dLat / 2)**2 + cos(lat1) * cos(lat2) * sin(dLon / 2)**2\n    c = 2 * asin(sqrt(a))\n\n    return R * c\n\n>>> haversine(36.12, -86.67, 33.94, -118.40)\n2887.2599506071106\n>>>\n"}
{"id": 9893, "name": "Haversine formula", "source": "Translate Ruby to Python: include Math\n \ndef haversine(lat1, lon1, lat2, lon2)\n    r = 6372.8        \n    deg2rad = PI/180  \n \n    dLat = (lat2 - lat1) * deg2rad\n    dLon = (lon2 - lon1) * deg2rad\n    lat1 = lat1 * deg2rad\n    lat2 = lat2 * deg2rad\n \n    a = sin(dLat / 2)**2 + cos(lat1) * cos(lat2) * sin(dLon / 2)**2\n    c = 2 * asin(sqrt(a))\n    r * c\nend\n\nputs \"distance is \n", "target": "from math import radians, sin, cos, sqrt, asin\n\n\ndef haversine(lat1, lon1, lat2, lon2):\n    R = 6372.8  \n\n    dLat = radians(lat2 - lat1)\n    dLon = radians(lon2 - lon1)\n    lat1 = radians(lat1)\n    lat2 = radians(lat2)\n\n    a = sin(dLat / 2)**2 + cos(lat1) * cos(lat2) * sin(dLon / 2)**2\n    c = 2 * asin(sqrt(a))\n\n    return R * c\n\n>>> haversine(36.12, -86.67, 33.94, -118.40)\n2887.2599506071106\n>>>\n"}
{"id": 10279, "name": "Fivenum", "source": "Translate Ruby to C#: def fivenum(array)\n  sorted_arr = array.sort\n  n = array.size\n  n4 = (((n + 3).to_f / 2.to_f) / 2.to_f).floor\n  d = Array.[](1, n4, ((n.to_f + 1) / 2).to_i, n + 1 - n4, n)\n  sum_array = []\n  (0..4).each do |e| \n    index_floor = (d[e] - 1).floor\n    index_ceil  = (d[e] - 1).ceil\n    sum_array.push(0.5 * (sorted_arr[index_floor] + sorted_arr[index_ceil]))\n  end\n  sum_array\nend\n\ntest_array = [15, 6, 42, 41, 7, 36, 49, 40, 39, 47, 43]\ntukey_array = fivenum(test_array)\np tukey_array\ntest_array = [36, 40, 7, 39, 41, 15]\ntukey_array = fivenum(test_array)\np tukey_array\ntest_array = [0.14082834, 0.09748790, 1.73131507, 0.87636009, -1.95059594,\n              0.73438555, -0.03035726, 1.46675970, -0.74621349, -0.72588772,\n              0.63905160,  0.61501527, -0.98983780, -1.00447874, -0.62759469,\n              0.66206163,  1.04312009, -0.10305385, 0.75775634,  0.32566578]\ntukey_array = fivenum(test_array)\np tukey_array\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\nnamespace Fivenum {\n    public static class Helper {\n        public static string AsString<T>(this ICollection<T> c, string format = \"{0}\") {\n            StringBuilder sb = new StringBuilder(\"[\");\n            int count = 0;\n            foreach (var t in c) {\n                if (count++ > 0) {\n                    sb.Append(\", \");\n                }\n                sb.AppendFormat(format, t);\n            }\n            return sb.Append(\"]\").ToString();\n        }\n    }\n\n    class Program {\n        static double Median(double[] x, int start, int endInclusive) {\n            int size = endInclusive - start + 1;\n            if (size <= 0) throw new ArgumentException(\"Array slice cannot be empty\");\n            int m = start + size / 2;\n            return (size % 2 == 1) ? x[m] : (x[m - 1] + x[m]) / 2.0;\n        }\n\n        static double[] Fivenum(double[] x) {\n            foreach (var d in x) {\n                if (Double.IsNaN(d)) {\n                    throw new ArgumentException(\"Unable to deal with arrays containing NaN\");\n                }\n            }\n            double[] result = new double[5];\n            Array.Sort(x);\n            result[0] = x.First();\n            result[2] = Median(x, 0, x.Length - 1);\n            result[4] = x.Last();\n            int m = x.Length / 2;\n            int lowerEnd = (x.Length % 2 == 1) ? m : m - 1;\n            result[1] = Median(x, 0, lowerEnd);\n            result[3] = Median(x, m, x.Length - 1);\n            return result;\n        }\n\n        static void Main(string[] args) {\n            double[][] x1 = new double[][]{\n                new double[]{ 15.0, 6.0, 42.0, 41.0, 7.0, 36.0, 49.0, 40.0, 39.0, 47.0, 43.0},\n                new double[]{ 36.0, 40.0, 7.0, 39.0, 41.0, 15.0},\n                new double[]{\n                     0.14082834,  0.09748790,  1.73131507,  0.87636009, -1.95059594,  0.73438555,\n                    -0.03035726,  1.46675970, -0.74621349, -0.72588772,  0.63905160,  0.61501527,\n                    -0.98983780, -1.00447874, -0.62759469,  0.66206163,  1.04312009, -0.10305385,\n                     0.75775634,  0.32566578\n                },\n            };\n            foreach(var x in x1) {\n                var result = Fivenum(x);\n                Console.WriteLine(result.AsString(\"{0:F8}\"));\n            }\n        }\n    }\n}\n"}
{"id": 10280, "name": "Fivenum", "source": "Translate Ruby to C#: def fivenum(array)\n  sorted_arr = array.sort\n  n = array.size\n  n4 = (((n + 3).to_f / 2.to_f) / 2.to_f).floor\n  d = Array.[](1, n4, ((n.to_f + 1) / 2).to_i, n + 1 - n4, n)\n  sum_array = []\n  (0..4).each do |e| \n    index_floor = (d[e] - 1).floor\n    index_ceil  = (d[e] - 1).ceil\n    sum_array.push(0.5 * (sorted_arr[index_floor] + sorted_arr[index_ceil]))\n  end\n  sum_array\nend\n\ntest_array = [15, 6, 42, 41, 7, 36, 49, 40, 39, 47, 43]\ntukey_array = fivenum(test_array)\np tukey_array\ntest_array = [36, 40, 7, 39, 41, 15]\ntukey_array = fivenum(test_array)\np tukey_array\ntest_array = [0.14082834, 0.09748790, 1.73131507, 0.87636009, -1.95059594,\n              0.73438555, -0.03035726, 1.46675970, -0.74621349, -0.72588772,\n              0.63905160,  0.61501527, -0.98983780, -1.00447874, -0.62759469,\n              0.66206163,  1.04312009, -0.10305385, 0.75775634,  0.32566578]\ntukey_array = fivenum(test_array)\np tukey_array\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\nnamespace Fivenum {\n    public static class Helper {\n        public static string AsString<T>(this ICollection<T> c, string format = \"{0}\") {\n            StringBuilder sb = new StringBuilder(\"[\");\n            int count = 0;\n            foreach (var t in c) {\n                if (count++ > 0) {\n                    sb.Append(\", \");\n                }\n                sb.AppendFormat(format, t);\n            }\n            return sb.Append(\"]\").ToString();\n        }\n    }\n\n    class Program {\n        static double Median(double[] x, int start, int endInclusive) {\n            int size = endInclusive - start + 1;\n            if (size <= 0) throw new ArgumentException(\"Array slice cannot be empty\");\n            int m = start + size / 2;\n            return (size % 2 == 1) ? x[m] : (x[m - 1] + x[m]) / 2.0;\n        }\n\n        static double[] Fivenum(double[] x) {\n            foreach (var d in x) {\n                if (Double.IsNaN(d)) {\n                    throw new ArgumentException(\"Unable to deal with arrays containing NaN\");\n                }\n            }\n            double[] result = new double[5];\n            Array.Sort(x);\n            result[0] = x.First();\n            result[2] = Median(x, 0, x.Length - 1);\n            result[4] = x.Last();\n            int m = x.Length / 2;\n            int lowerEnd = (x.Length % 2 == 1) ? m : m - 1;\n            result[1] = Median(x, 0, lowerEnd);\n            result[3] = Median(x, m, x.Length - 1);\n            return result;\n        }\n\n        static void Main(string[] args) {\n            double[][] x1 = new double[][]{\n                new double[]{ 15.0, 6.0, 42.0, 41.0, 7.0, 36.0, 49.0, 40.0, 39.0, 47.0, 43.0},\n                new double[]{ 36.0, 40.0, 7.0, 39.0, 41.0, 15.0},\n                new double[]{\n                     0.14082834,  0.09748790,  1.73131507,  0.87636009, -1.95059594,  0.73438555,\n                    -0.03035726,  1.46675970, -0.74621349, -0.72588772,  0.63905160,  0.61501527,\n                    -0.98983780, -1.00447874, -0.62759469,  0.66206163,  1.04312009, -0.10305385,\n                     0.75775634,  0.32566578\n                },\n            };\n            foreach(var x in x1) {\n                var result = Fivenum(x);\n                Console.WriteLine(result.AsString(\"{0:F8}\"));\n            }\n        }\n    }\n}\n"}
{"id": 10283, "name": "Fivenum", "source": "Translate Ruby to Java: def fivenum(array)\n  sorted_arr = array.sort\n  n = array.size\n  n4 = (((n + 3).to_f / 2.to_f) / 2.to_f).floor\n  d = Array.[](1, n4, ((n.to_f + 1) / 2).to_i, n + 1 - n4, n)\n  sum_array = []\n  (0..4).each do |e| \n    index_floor = (d[e] - 1).floor\n    index_ceil  = (d[e] - 1).ceil\n    sum_array.push(0.5 * (sorted_arr[index_floor] + sorted_arr[index_ceil]))\n  end\n  sum_array\nend\n\ntest_array = [15, 6, 42, 41, 7, 36, 49, 40, 39, 47, 43]\ntukey_array = fivenum(test_array)\np tukey_array\ntest_array = [36, 40, 7, 39, 41, 15]\ntukey_array = fivenum(test_array)\np tukey_array\ntest_array = [0.14082834, 0.09748790, 1.73131507, 0.87636009, -1.95059594,\n              0.73438555, -0.03035726, 1.46675970, -0.74621349, -0.72588772,\n              0.63905160,  0.61501527, -0.98983780, -1.00447874, -0.62759469,\n              0.66206163,  1.04312009, -0.10305385, 0.75775634,  0.32566578]\ntukey_array = fivenum(test_array)\np tukey_array\n", "target": "import java.util.Arrays;\n\npublic class Fivenum {\n\n    static double median(double[] x, int start, int endInclusive) {\n        int size = endInclusive - start + 1;\n        if (size <= 0) throw new IllegalArgumentException(\"Array slice cannot be empty\");\n        int m = start + size / 2;\n        return (size % 2 == 1) ? x[m] : (x[m - 1] + x[m]) / 2.0;\n    }\n\n    static double[] fivenum(double[] x) {\n        for (Double d : x) {\n            if (d.isNaN())\n                throw new IllegalArgumentException(\"Unable to deal with arrays containing NaN\");\n        }\n        double[] result = new double[5];\n        Arrays.sort(x);\n        result[0] = x[0];\n        result[2] = median(x, 0, x.length - 1);\n        result[4] = x[x.length - 1];\n        int m = x.length / 2;\n        int lowerEnd = (x.length % 2 == 1) ? m : m - 1;\n        result[1] = median(x, 0, lowerEnd);\n        result[3] = median(x, m, x.length - 1);\n        return result;\n    }\n\n    public static void main(String[] args) {\n        double xl[][] = {\n            {15.0, 6.0, 42.0, 41.0, 7.0, 36.0, 49.0, 40.0, 39.0, 47.0, 43.0},\n            {36.0, 40.0, 7.0, 39.0, 41.0, 15.0},\n            {\n                 0.14082834,  0.09748790,  1.73131507,  0.87636009, -1.95059594,  0.73438555,\n                -0.03035726,  1.46675970, -0.74621349, -0.72588772,  0.63905160,  0.61501527,\n                -0.98983780, -1.00447874, -0.62759469,  0.66206163,  1.04312009, -0.10305385,\n                 0.75775634,  0.32566578\n            }\n        };\n        for (double[] x : xl) System.out.printf(\"%s\\n\\n\", Arrays.toString(fivenum(x)));\n    }\n}\n"}
{"id": 10284, "name": "Fivenum", "source": "Translate Ruby to Java: def fivenum(array)\n  sorted_arr = array.sort\n  n = array.size\n  n4 = (((n + 3).to_f / 2.to_f) / 2.to_f).floor\n  d = Array.[](1, n4, ((n.to_f + 1) / 2).to_i, n + 1 - n4, n)\n  sum_array = []\n  (0..4).each do |e| \n    index_floor = (d[e] - 1).floor\n    index_ceil  = (d[e] - 1).ceil\n    sum_array.push(0.5 * (sorted_arr[index_floor] + sorted_arr[index_ceil]))\n  end\n  sum_array\nend\n\ntest_array = [15, 6, 42, 41, 7, 36, 49, 40, 39, 47, 43]\ntukey_array = fivenum(test_array)\np tukey_array\ntest_array = [36, 40, 7, 39, 41, 15]\ntukey_array = fivenum(test_array)\np tukey_array\ntest_array = [0.14082834, 0.09748790, 1.73131507, 0.87636009, -1.95059594,\n              0.73438555, -0.03035726, 1.46675970, -0.74621349, -0.72588772,\n              0.63905160,  0.61501527, -0.98983780, -1.00447874, -0.62759469,\n              0.66206163,  1.04312009, -0.10305385, 0.75775634,  0.32566578]\ntukey_array = fivenum(test_array)\np tukey_array\n", "target": "import java.util.Arrays;\n\npublic class Fivenum {\n\n    static double median(double[] x, int start, int endInclusive) {\n        int size = endInclusive - start + 1;\n        if (size <= 0) throw new IllegalArgumentException(\"Array slice cannot be empty\");\n        int m = start + size / 2;\n        return (size % 2 == 1) ? x[m] : (x[m - 1] + x[m]) / 2.0;\n    }\n\n    static double[] fivenum(double[] x) {\n        for (Double d : x) {\n            if (d.isNaN())\n                throw new IllegalArgumentException(\"Unable to deal with arrays containing NaN\");\n        }\n        double[] result = new double[5];\n        Arrays.sort(x);\n        result[0] = x[0];\n        result[2] = median(x, 0, x.length - 1);\n        result[4] = x[x.length - 1];\n        int m = x.length / 2;\n        int lowerEnd = (x.length % 2 == 1) ? m : m - 1;\n        result[1] = median(x, 0, lowerEnd);\n        result[3] = median(x, m, x.length - 1);\n        return result;\n    }\n\n    public static void main(String[] args) {\n        double xl[][] = {\n            {15.0, 6.0, 42.0, 41.0, 7.0, 36.0, 49.0, 40.0, 39.0, 47.0, 43.0},\n            {36.0, 40.0, 7.0, 39.0, 41.0, 15.0},\n            {\n                 0.14082834,  0.09748790,  1.73131507,  0.87636009, -1.95059594,  0.73438555,\n                -0.03035726,  1.46675970, -0.74621349, -0.72588772,  0.63905160,  0.61501527,\n                -0.98983780, -1.00447874, -0.62759469,  0.66206163,  1.04312009, -0.10305385,\n                 0.75775634,  0.32566578\n            }\n        };\n        for (double[] x : xl) System.out.printf(\"%s\\n\\n\", Arrays.toString(fivenum(x)));\n    }\n}\n"}
{"id": 10285, "name": "Fivenum", "source": "Translate Ruby to Python: def fivenum(array)\n  sorted_arr = array.sort\n  n = array.size\n  n4 = (((n + 3).to_f / 2.to_f) / 2.to_f).floor\n  d = Array.[](1, n4, ((n.to_f + 1) / 2).to_i, n + 1 - n4, n)\n  sum_array = []\n  (0..4).each do |e| \n    index_floor = (d[e] - 1).floor\n    index_ceil  = (d[e] - 1).ceil\n    sum_array.push(0.5 * (sorted_arr[index_floor] + sorted_arr[index_ceil]))\n  end\n  sum_array\nend\n\ntest_array = [15, 6, 42, 41, 7, 36, 49, 40, 39, 47, 43]\ntukey_array = fivenum(test_array)\np tukey_array\ntest_array = [36, 40, 7, 39, 41, 15]\ntukey_array = fivenum(test_array)\np tukey_array\ntest_array = [0.14082834, 0.09748790, 1.73131507, 0.87636009, -1.95059594,\n              0.73438555, -0.03035726, 1.46675970, -0.74621349, -0.72588772,\n              0.63905160,  0.61501527, -0.98983780, -1.00447874, -0.62759469,\n              0.66206163,  1.04312009, -0.10305385, 0.75775634,  0.32566578]\ntukey_array = fivenum(test_array)\np tukey_array\n", "target": "from __future__ import division\nimport math\nimport sys\n\ndef fivenum(array):\n    n = len(array)\n    if n == 0:\n        print(\"you entered an empty array.\")\n        sys.exit()\n    x = sorted(array)\n    \n    n4 = math.floor((n+3.0)/2.0)/2.0\n    d = [1, n4, (n+1)/2, n+1-n4, n]\n    sum_array = []\n    \n    for e in range(5):\n        floor = int(math.floor(d[e] - 1))\n        ceil = int(math.ceil(d[e] - 1))\n        sum_array.append(0.5 * (x[floor] + x[ceil]))\n    \n    return sum_array\n\nx = [0.14082834, 0.09748790, 1.73131507, 0.87636009, -1.95059594, 0.73438555, -0.03035726, 1.46675970,\n-0.74621349, -0.72588772, 0.63905160, 0.61501527, -0.98983780, -1.00447874, -0.62759469, 0.66206163,\n1.04312009, -0.10305385, 0.75775634, 0.32566578]\n\ny = fivenum(x)\nprint(y)\n"}
{"id": 10286, "name": "Fivenum", "source": "Translate Ruby to Python: def fivenum(array)\n  sorted_arr = array.sort\n  n = array.size\n  n4 = (((n + 3).to_f / 2.to_f) / 2.to_f).floor\n  d = Array.[](1, n4, ((n.to_f + 1) / 2).to_i, n + 1 - n4, n)\n  sum_array = []\n  (0..4).each do |e| \n    index_floor = (d[e] - 1).floor\n    index_ceil  = (d[e] - 1).ceil\n    sum_array.push(0.5 * (sorted_arr[index_floor] + sorted_arr[index_ceil]))\n  end\n  sum_array\nend\n\ntest_array = [15, 6, 42, 41, 7, 36, 49, 40, 39, 47, 43]\ntukey_array = fivenum(test_array)\np tukey_array\ntest_array = [36, 40, 7, 39, 41, 15]\ntukey_array = fivenum(test_array)\np tukey_array\ntest_array = [0.14082834, 0.09748790, 1.73131507, 0.87636009, -1.95059594,\n              0.73438555, -0.03035726, 1.46675970, -0.74621349, -0.72588772,\n              0.63905160,  0.61501527, -0.98983780, -1.00447874, -0.62759469,\n              0.66206163,  1.04312009, -0.10305385, 0.75775634,  0.32566578]\ntukey_array = fivenum(test_array)\np tukey_array\n", "target": "from __future__ import division\nimport math\nimport sys\n\ndef fivenum(array):\n    n = len(array)\n    if n == 0:\n        print(\"you entered an empty array.\")\n        sys.exit()\n    x = sorted(array)\n    \n    n4 = math.floor((n+3.0)/2.0)/2.0\n    d = [1, n4, (n+1)/2, n+1-n4, n]\n    sum_array = []\n    \n    for e in range(5):\n        floor = int(math.floor(d[e] - 1))\n        ceil = int(math.ceil(d[e] - 1))\n        sum_array.append(0.5 * (x[floor] + x[ceil]))\n    \n    return sum_array\n\nx = [0.14082834, 0.09748790, 1.73131507, 0.87636009, -1.95059594, 0.73438555, -0.03035726, 1.46675970,\n-0.74621349, -0.72588772, 0.63905160, 0.61501527, -0.98983780, -1.00447874, -0.62759469, 0.66206163,\n1.04312009, -0.10305385, 0.75775634, 0.32566578]\n\ny = fivenum(x)\nprint(y)\n"}
{"id": 10537, "name": "Nth root", "source": "Translate Ruby to C#: def nthroot(n, a, precision = 1e-5)\n  x = Float(a)\n  begin\n    prev = x\n    x = ((n - 1) * prev + a / (prev ** (n - 1))) / n\n  end while (prev - x).abs > precision\n  x \nend\n\np nthroot(5,34)  \n", "target": "static void Main(string[] args)\n{\n\tConsole.WriteLine(NthRoot(81,2,.001));\n        Console.WriteLine(NthRoot(1000,3,.001));\n        Console.ReadLine();\n}\n\npublic static double NthRoot(double A,int n,  double p)\n{\n\tdouble _n= (double) n;\n\tdouble[] x = new double[2];\t\t\n\tx[0] = A;\n\tx[1] = A/_n;\n\twhile(Math.Abs(x[0] -x[1] ) > p)\n\t{\n\t\tx[1] = x[0];\n\t\tx[0] = (1/_n)*(((_n-1)*x[1]) + (A/Math.Pow(x[1],_n-1)));\n\t\t\t\n\t}\n\treturn x[0];\n}\n"}
{"id": 10539, "name": "Nth root", "source": "Translate Ruby to Java: def nthroot(n, a, precision = 1e-5)\n  x = Float(a)\n  begin\n    prev = x\n    x = ((n - 1) * prev + a / (prev ** (n - 1))) / n\n  end while (prev - x).abs > precision\n  x \nend\n\np nthroot(5,34)  \n", "target": "public static double nthroot(int n, double A) {\n\treturn nthroot(n, A, .001);\n}\npublic static double nthroot(int n, double A, double p) {\n\tif(A < 0) {\n\t\tSystem.err.println(\"A < 0\");\n\t\treturn -1;\n\t} else if(A == 0) {\n\t\treturn 0;\n\t}\n\tdouble x_prev = A;\n\tdouble x = A / n;  \n\twhile(Math.abs(x - x_prev) > p) {\n\t\tx_prev = x;\n\t\tx = ((n - 1.0) * x + A / Math.pow(x, n - 1.0)) / n;\n\t}\n\treturn x;\n}\n"}
{"id": 10540, "name": "Nth root", "source": "Translate Ruby to Python: def nthroot(n, a, precision = 1e-5)\n  x = Float(a)\n  begin\n    prev = x\n    x = ((n - 1) * prev + a / (prev ** (n - 1))) / n\n  end while (prev - x).abs > precision\n  x \nend\n\np nthroot(5,34)  \n", "target": "from decimal import Decimal, getcontext\n\ndef nthroot (n, A, precision):\n    getcontext().prec = precision\n    \n    n = Decimal(n)\n    x_0 = A / n \n    x_1 = 1     \n    while True:\n        \n        x_0, x_1 = x_1, (1 / n)*((n - 1)*x_0 + (A / (x_0 ** (n - 1))))\n        if x_0 == x_1:\n            return x_1\n"}
{"id": 10958, "name": "Priority queue", "source": "Translate Ruby to C#: class PriorityQueueNaive\n  def initialize(data=nil)\n    @q = Hash.new {|h, k| h[k] = []}\n    data.each {|priority, item| @q[priority] << item}  if data\n    @priorities = @q.keys.sort\n  end\n  \n  def push(priority, item)\n    @q[priority] << item\n    @priorities = @q.keys.sort\n  end\n  \n  def pop\n    p = @priorities[0]\n    item = @q[p].shift\n    if @q[p].empty?\n      @q.delete(p)\n      @priorities.shift\n    end\n    item\n  end\n  \n  def peek\n    unless empty?\n      @q[@priorities[0]][0]\n    end\n  end\n  \n  def empty?\n    @priorities.empty?\n  end\n  \n  def each\n    @q.each do |priority, items|\n      items.each {|item| yield priority, item}\n    end\n  end\n  \n  def dup\n    @q.each_with_object(self.class.new) do |(priority, items), obj|\n      items.each {|item| obj.push(priority, item)}\n    end\n  end\n  \n  def merge(other)\n    raise TypeError  unless self.class == other.class\n    pq = dup\n    other.each {|priority, item| pq.push(priority, item)}\n    pq                  \n  end\n  \n  def inspect\n    @q.inspect\n  end\nend\n\ntest = [\n  [6, \"drink tea\"],\n  [3, \"Clear drains\"],\n  [4, \"Feed cat\"],\n  [5, \"Make tea\"],\n  [6, \"eat biscuit\"],\n  [1, \"Solve RC tasks\"],\n  [2, \"Tax return\"],\n]\n\npq = PriorityQueueNaive.new\ntest.each {|pr, str| pq.push(pr, str) }\nuntil pq.empty? \n  puts pq.pop\nend\n\nputs\ntest2 = test.shift(3)\np pq1 = PriorityQueueNaive.new(test)\np pq2 = PriorityQueueNaive.new(test2)\np pq3 = pq1.merge(pq2)\nputs \"peek\u00a0: \nuntil pq3.empty?\n  puts pq3.pop\nend\nputs \"peek\u00a0: \n", "target": "using System;\nusing System.Collections.Generic;\n\nnamespace PriorityQueueExample\n{\n\tclass Program\n\t{\n\t\tstatic void Main(string[] args)\n\t\t{\n\t\t\t\n\t\t\tvar p = new PriorityQueue<string, int>();\n\t\t\tp.Enqueue(\"Clear drains\", 3);\n\t\t\tp.Enqueue(\"Feed cat\", 4);\n\t\t\tp.Enqueue(\"Make tea\", 5);\n\t\t\tp.Enqueue(\"Solve RC tasks\", 1);\n\t\t\tp.Enqueue(\"Tax return\", 2);\n\t\t\twhile (p.TryDequeue(out string task, out int priority))\n\t\t\t{\n\t\t\t\tConsole.WriteLine($\"{priority}\\t{task}\");\n\t\t\t}\n\t\t}\n\t}\n}\n\n\n"}
{"id": 10959, "name": "Priority queue", "source": "Translate Ruby to C#: class PriorityQueueNaive\n  def initialize(data=nil)\n    @q = Hash.new {|h, k| h[k] = []}\n    data.each {|priority, item| @q[priority] << item}  if data\n    @priorities = @q.keys.sort\n  end\n  \n  def push(priority, item)\n    @q[priority] << item\n    @priorities = @q.keys.sort\n  end\n  \n  def pop\n    p = @priorities[0]\n    item = @q[p].shift\n    if @q[p].empty?\n      @q.delete(p)\n      @priorities.shift\n    end\n    item\n  end\n  \n  def peek\n    unless empty?\n      @q[@priorities[0]][0]\n    end\n  end\n  \n  def empty?\n    @priorities.empty?\n  end\n  \n  def each\n    @q.each do |priority, items|\n      items.each {|item| yield priority, item}\n    end\n  end\n  \n  def dup\n    @q.each_with_object(self.class.new) do |(priority, items), obj|\n      items.each {|item| obj.push(priority, item)}\n    end\n  end\n  \n  def merge(other)\n    raise TypeError  unless self.class == other.class\n    pq = dup\n    other.each {|priority, item| pq.push(priority, item)}\n    pq                  \n  end\n  \n  def inspect\n    @q.inspect\n  end\nend\n\ntest = [\n  [6, \"drink tea\"],\n  [3, \"Clear drains\"],\n  [4, \"Feed cat\"],\n  [5, \"Make tea\"],\n  [6, \"eat biscuit\"],\n  [1, \"Solve RC tasks\"],\n  [2, \"Tax return\"],\n]\n\npq = PriorityQueueNaive.new\ntest.each {|pr, str| pq.push(pr, str) }\nuntil pq.empty? \n  puts pq.pop\nend\n\nputs\ntest2 = test.shift(3)\np pq1 = PriorityQueueNaive.new(test)\np pq2 = PriorityQueueNaive.new(test2)\np pq3 = pq1.merge(pq2)\nputs \"peek\u00a0: \nuntil pq3.empty?\n  puts pq3.pop\nend\nputs \"peek\u00a0: \n", "target": "using System;\nusing System.Collections.Generic;\n\nnamespace PriorityQueueExample\n{\n\tclass Program\n\t{\n\t\tstatic void Main(string[] args)\n\t\t{\n\t\t\t\n\t\t\tvar p = new PriorityQueue<string, int>();\n\t\t\tp.Enqueue(\"Clear drains\", 3);\n\t\t\tp.Enqueue(\"Feed cat\", 4);\n\t\t\tp.Enqueue(\"Make tea\", 5);\n\t\t\tp.Enqueue(\"Solve RC tasks\", 1);\n\t\t\tp.Enqueue(\"Tax return\", 2);\n\t\t\twhile (p.TryDequeue(out string task, out int priority))\n\t\t\t{\n\t\t\t\tConsole.WriteLine($\"{priority}\\t{task}\");\n\t\t\t}\n\t\t}\n\t}\n}\n\n\n"}
{"id": 10962, "name": "Priority queue", "source": "Translate Ruby to Java: class PriorityQueueNaive\n  def initialize(data=nil)\n    @q = Hash.new {|h, k| h[k] = []}\n    data.each {|priority, item| @q[priority] << item}  if data\n    @priorities = @q.keys.sort\n  end\n  \n  def push(priority, item)\n    @q[priority] << item\n    @priorities = @q.keys.sort\n  end\n  \n  def pop\n    p = @priorities[0]\n    item = @q[p].shift\n    if @q[p].empty?\n      @q.delete(p)\n      @priorities.shift\n    end\n    item\n  end\n  \n  def peek\n    unless empty?\n      @q[@priorities[0]][0]\n    end\n  end\n  \n  def empty?\n    @priorities.empty?\n  end\n  \n  def each\n    @q.each do |priority, items|\n      items.each {|item| yield priority, item}\n    end\n  end\n  \n  def dup\n    @q.each_with_object(self.class.new) do |(priority, items), obj|\n      items.each {|item| obj.push(priority, item)}\n    end\n  end\n  \n  def merge(other)\n    raise TypeError  unless self.class == other.class\n    pq = dup\n    other.each {|priority, item| pq.push(priority, item)}\n    pq                  \n  end\n  \n  def inspect\n    @q.inspect\n  end\nend\n\ntest = [\n  [6, \"drink tea\"],\n  [3, \"Clear drains\"],\n  [4, \"Feed cat\"],\n  [5, \"Make tea\"],\n  [6, \"eat biscuit\"],\n  [1, \"Solve RC tasks\"],\n  [2, \"Tax return\"],\n]\n\npq = PriorityQueueNaive.new\ntest.each {|pr, str| pq.push(pr, str) }\nuntil pq.empty? \n  puts pq.pop\nend\n\nputs\ntest2 = test.shift(3)\np pq1 = PriorityQueueNaive.new(test)\np pq2 = PriorityQueueNaive.new(test2)\np pq3 = pq1.merge(pq2)\nputs \"peek\u00a0: \nuntil pq3.empty?\n  puts pq3.pop\nend\nputs \"peek\u00a0: \n", "target": "import java.util.PriorityQueue;\n\nclass Task implements Comparable<Task> {\n    final int priority;\n    final String name;\n\n    public Task(int p, String n) {\n        priority = p;\n        name = n;\n    }\n\n    public String toString() {\n        return priority + \", \" + name;\n    }\n\n    public int compareTo(Task other) {\n        return priority < other.priority ? -1 : priority > other.priority ? 1 : 0;\n    }\n\n    public static void main(String[] args) {\n        PriorityQueue<Task> pq = new PriorityQueue<Task>();\n        pq.add(new Task(3, \"Clear drains\"));\n        pq.add(new Task(4, \"Feed cat\"));\n        pq.add(new Task(5, \"Make tea\"));\n        pq.add(new Task(1, \"Solve RC tasks\"));\n        pq.add(new Task(2, \"Tax return\"));\n\n        while (!pq.isEmpty())\n            System.out.println(pq.remove());\n    }\n}\n"}
{"id": 10963, "name": "Priority queue", "source": "Translate Ruby to Java: class PriorityQueueNaive\n  def initialize(data=nil)\n    @q = Hash.new {|h, k| h[k] = []}\n    data.each {|priority, item| @q[priority] << item}  if data\n    @priorities = @q.keys.sort\n  end\n  \n  def push(priority, item)\n    @q[priority] << item\n    @priorities = @q.keys.sort\n  end\n  \n  def pop\n    p = @priorities[0]\n    item = @q[p].shift\n    if @q[p].empty?\n      @q.delete(p)\n      @priorities.shift\n    end\n    item\n  end\n  \n  def peek\n    unless empty?\n      @q[@priorities[0]][0]\n    end\n  end\n  \n  def empty?\n    @priorities.empty?\n  end\n  \n  def each\n    @q.each do |priority, items|\n      items.each {|item| yield priority, item}\n    end\n  end\n  \n  def dup\n    @q.each_with_object(self.class.new) do |(priority, items), obj|\n      items.each {|item| obj.push(priority, item)}\n    end\n  end\n  \n  def merge(other)\n    raise TypeError  unless self.class == other.class\n    pq = dup\n    other.each {|priority, item| pq.push(priority, item)}\n    pq                  \n  end\n  \n  def inspect\n    @q.inspect\n  end\nend\n\ntest = [\n  [6, \"drink tea\"],\n  [3, \"Clear drains\"],\n  [4, \"Feed cat\"],\n  [5, \"Make tea\"],\n  [6, \"eat biscuit\"],\n  [1, \"Solve RC tasks\"],\n  [2, \"Tax return\"],\n]\n\npq = PriorityQueueNaive.new\ntest.each {|pr, str| pq.push(pr, str) }\nuntil pq.empty? \n  puts pq.pop\nend\n\nputs\ntest2 = test.shift(3)\np pq1 = PriorityQueueNaive.new(test)\np pq2 = PriorityQueueNaive.new(test2)\np pq3 = pq1.merge(pq2)\nputs \"peek\u00a0: \nuntil pq3.empty?\n  puts pq3.pop\nend\nputs \"peek\u00a0: \n", "target": "import java.util.PriorityQueue;\n\nclass Task implements Comparable<Task> {\n    final int priority;\n    final String name;\n\n    public Task(int p, String n) {\n        priority = p;\n        name = n;\n    }\n\n    public String toString() {\n        return priority + \", \" + name;\n    }\n\n    public int compareTo(Task other) {\n        return priority < other.priority ? -1 : priority > other.priority ? 1 : 0;\n    }\n\n    public static void main(String[] args) {\n        PriorityQueue<Task> pq = new PriorityQueue<Task>();\n        pq.add(new Task(3, \"Clear drains\"));\n        pq.add(new Task(4, \"Feed cat\"));\n        pq.add(new Task(5, \"Make tea\"));\n        pq.add(new Task(1, \"Solve RC tasks\"));\n        pq.add(new Task(2, \"Tax return\"));\n\n        while (!pq.isEmpty())\n            System.out.println(pq.remove());\n    }\n}\n"}
{"id": 10964, "name": "Priority queue", "source": "Translate Ruby to Python: class PriorityQueueNaive\n  def initialize(data=nil)\n    @q = Hash.new {|h, k| h[k] = []}\n    data.each {|priority, item| @q[priority] << item}  if data\n    @priorities = @q.keys.sort\n  end\n  \n  def push(priority, item)\n    @q[priority] << item\n    @priorities = @q.keys.sort\n  end\n  \n  def pop\n    p = @priorities[0]\n    item = @q[p].shift\n    if @q[p].empty?\n      @q.delete(p)\n      @priorities.shift\n    end\n    item\n  end\n  \n  def peek\n    unless empty?\n      @q[@priorities[0]][0]\n    end\n  end\n  \n  def empty?\n    @priorities.empty?\n  end\n  \n  def each\n    @q.each do |priority, items|\n      items.each {|item| yield priority, item}\n    end\n  end\n  \n  def dup\n    @q.each_with_object(self.class.new) do |(priority, items), obj|\n      items.each {|item| obj.push(priority, item)}\n    end\n  end\n  \n  def merge(other)\n    raise TypeError  unless self.class == other.class\n    pq = dup\n    other.each {|priority, item| pq.push(priority, item)}\n    pq                  \n  end\n  \n  def inspect\n    @q.inspect\n  end\nend\n\ntest = [\n  [6, \"drink tea\"],\n  [3, \"Clear drains\"],\n  [4, \"Feed cat\"],\n  [5, \"Make tea\"],\n  [6, \"eat biscuit\"],\n  [1, \"Solve RC tasks\"],\n  [2, \"Tax return\"],\n]\n\npq = PriorityQueueNaive.new\ntest.each {|pr, str| pq.push(pr, str) }\nuntil pq.empty? \n  puts pq.pop\nend\n\nputs\ntest2 = test.shift(3)\np pq1 = PriorityQueueNaive.new(test)\np pq2 = PriorityQueueNaive.new(test2)\np pq3 = pq1.merge(pq2)\nputs \"peek\u00a0: \nuntil pq3.empty?\n  puts pq3.pop\nend\nputs \"peek\u00a0: \n", "target": ">>> import queue\n>>> pq = queue.PriorityQueue()\n>>> for item in ((3, \"Clear drains\"), (4, \"Feed cat\"), (5, \"Make tea\"), (1, \"Solve RC tasks\"), (2, \"Tax return\")):\n  pq.put(item)\n\n  \n>>> while not pq.empty():\n  print(pq.get_nowait())\n\n  \n(1, 'Solve RC tasks')\n(2, 'Tax return')\n(3, 'Clear drains')\n(4, 'Feed cat')\n(5, 'Make tea')\n>>>\n"}
{"id": 10965, "name": "Priority queue", "source": "Translate Ruby to Python: class PriorityQueueNaive\n  def initialize(data=nil)\n    @q = Hash.new {|h, k| h[k] = []}\n    data.each {|priority, item| @q[priority] << item}  if data\n    @priorities = @q.keys.sort\n  end\n  \n  def push(priority, item)\n    @q[priority] << item\n    @priorities = @q.keys.sort\n  end\n  \n  def pop\n    p = @priorities[0]\n    item = @q[p].shift\n    if @q[p].empty?\n      @q.delete(p)\n      @priorities.shift\n    end\n    item\n  end\n  \n  def peek\n    unless empty?\n      @q[@priorities[0]][0]\n    end\n  end\n  \n  def empty?\n    @priorities.empty?\n  end\n  \n  def each\n    @q.each do |priority, items|\n      items.each {|item| yield priority, item}\n    end\n  end\n  \n  def dup\n    @q.each_with_object(self.class.new) do |(priority, items), obj|\n      items.each {|item| obj.push(priority, item)}\n    end\n  end\n  \n  def merge(other)\n    raise TypeError  unless self.class == other.class\n    pq = dup\n    other.each {|priority, item| pq.push(priority, item)}\n    pq                  \n  end\n  \n  def inspect\n    @q.inspect\n  end\nend\n\ntest = [\n  [6, \"drink tea\"],\n  [3, \"Clear drains\"],\n  [4, \"Feed cat\"],\n  [5, \"Make tea\"],\n  [6, \"eat biscuit\"],\n  [1, \"Solve RC tasks\"],\n  [2, \"Tax return\"],\n]\n\npq = PriorityQueueNaive.new\ntest.each {|pr, str| pq.push(pr, str) }\nuntil pq.empty? \n  puts pq.pop\nend\n\nputs\ntest2 = test.shift(3)\np pq1 = PriorityQueueNaive.new(test)\np pq2 = PriorityQueueNaive.new(test2)\np pq3 = pq1.merge(pq2)\nputs \"peek\u00a0: \nuntil pq3.empty?\n  puts pq3.pop\nend\nputs \"peek\u00a0: \n", "target": ">>> import queue\n>>> pq = queue.PriorityQueue()\n>>> for item in ((3, \"Clear drains\"), (4, \"Feed cat\"), (5, \"Make tea\"), (1, \"Solve RC tasks\"), (2, \"Tax return\")):\n  pq.put(item)\n\n  \n>>> while not pq.empty():\n  print(pq.get_nowait())\n\n  \n(1, 'Solve RC tasks')\n(2, 'Tax return')\n(3, 'Clear drains')\n(4, 'Feed cat')\n(5, 'Make tea')\n>>>\n"}
{"id": 11522, "name": "Hailstone sequence", "source": "Translate Ruby to C#: def hailstone(n)\n    seq = [n]\n    until n == 1\n        n = n.even? ? n // 2 : n * 3 + 1\n        seq << n\n    end\n    seq\nend\n\nmax_len = (1...100_000).max_by{|n| hailstone(n).size }\nmax = hailstone(max_len)\nputs ([max_len, max.size, max.max, max.first(4), max.last(4)])\n\n\ntwenty_seven = hailstone(27)\nputs ([twenty_seven.size, twenty_seven.first(4), max.last(4)])\n\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\nnamespace Hailstone\n{\n    class Program\n    {\n        public static List<int> hs(int n,List<int> seq)\n        {\n            List<int> sequence = seq;\n            sequence.Add(n);\n            if (n == 1)\n            {\n                return sequence;\n            }else{\n                int newn = (n % 2 == 0) ? n / 2 : (3 * n) + 1;\n                return hs(newn, sequence);\n            }                        \n        }\n\n        static void Main(string[] args)\n        {\n            int n = 27;\n            List<int> sequence = hs(n,new List<int>());\n            Console.WriteLine(sequence.Count + \" Elements\");\n            List<int> start = sequence.GetRange(0, 4);\n            List<int> end = sequence.GetRange(sequence.Count - 4, 4);\n            Console.WriteLine(\"Starting with\u00a0: \" + string.Join(\",\", start) + \" and ending with\u00a0: \" + string.Join(\",\", end));            \n            int number = 0, longest = 0;            \n            for (int i = 1; i < 100000; i++)\n            {\n                int count = (hs(i, new List<int>())).Count;\n                if (count > longest)\n                {\n                    longest = count;\n                    number = i;\n                }\n            }\n            Console.WriteLine(\"Number < 100000 with longest Hailstone seq.: \" + number + \" with length of \" + longest);\n       }\n    }\n}\n"}
{"id": 11523, "name": "Hailstone sequence", "source": "Translate Ruby to C#: def hailstone(n)\n    seq = [n]\n    until n == 1\n        n = n.even? ? n // 2 : n * 3 + 1\n        seq << n\n    end\n    seq\nend\n\nmax_len = (1...100_000).max_by{|n| hailstone(n).size }\nmax = hailstone(max_len)\nputs ([max_len, max.size, max.max, max.first(4), max.last(4)])\n\n\ntwenty_seven = hailstone(27)\nputs ([twenty_seven.size, twenty_seven.first(4), max.last(4)])\n\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\nnamespace Hailstone\n{\n    class Program\n    {\n        public static List<int> hs(int n,List<int> seq)\n        {\n            List<int> sequence = seq;\n            sequence.Add(n);\n            if (n == 1)\n            {\n                return sequence;\n            }else{\n                int newn = (n % 2 == 0) ? n / 2 : (3 * n) + 1;\n                return hs(newn, sequence);\n            }                        \n        }\n\n        static void Main(string[] args)\n        {\n            int n = 27;\n            List<int> sequence = hs(n,new List<int>());\n            Console.WriteLine(sequence.Count + \" Elements\");\n            List<int> start = sequence.GetRange(0, 4);\n            List<int> end = sequence.GetRange(sequence.Count - 4, 4);\n            Console.WriteLine(\"Starting with\u00a0: \" + string.Join(\",\", start) + \" and ending with\u00a0: \" + string.Join(\",\", end));            \n            int number = 0, longest = 0;            \n            for (int i = 1; i < 100000; i++)\n            {\n                int count = (hs(i, new List<int>())).Count;\n                if (count > longest)\n                {\n                    longest = count;\n                    number = i;\n                }\n            }\n            Console.WriteLine(\"Number < 100000 with longest Hailstone seq.: \" + number + \" with length of \" + longest);\n       }\n    }\n}\n"}
{"id": 11526, "name": "Hailstone sequence", "source": "Translate Ruby to Java: def hailstone(n)\n    seq = [n]\n    until n == 1\n        n = n.even? ? n // 2 : n * 3 + 1\n        seq << n\n    end\n    seq\nend\n\nmax_len = (1...100_000).max_by{|n| hailstone(n).size }\nmax = hailstone(max_len)\nputs ([max_len, max.size, max.max, max.first(4), max.last(4)])\n\n\ntwenty_seven = hailstone(27)\nputs ([twenty_seven.size, twenty_seven.first(4), max.last(4)])\n\n", "target": "import java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\n\nclass Hailstone {\n\n  public static List<Long> getHailstoneSequence(long n) {\n    if (n <= 0)\n      throw new IllegalArgumentException(\"Invalid starting sequence number\");\n    List<Long> list = new ArrayList<Long>();\n    list.add(Long.valueOf(n));\n    while (n != 1) {\n      if ((n & 1) == 0)\n        n = n / 2;\n      else\n        n = 3 * n + 1;\n      list.add(Long.valueOf(n));\n    }\n    return list;\n  }\n  \n  public static void main(String[] args) {\n    List<Long> sequence27 = getHailstoneSequence(27);\n    System.out.println(\"Sequence for 27 has \" + sequence27.size() + \" elements: \" + sequence27);\n    \n    long MAX = 100000;\n    \n    {\n      long highestNumber = 1;\n      int highestCount = 1;\n      for (long i = 2; i < MAX; i++) {\n        int count = getHailstoneSequence(i).size();\n        if (count > highestCount) {\n          highestCount = count;\n          highestNumber = i;\n        }\n      }\n      System.out.println(\"Method 1, number \" + highestNumber + \" has the longest sequence, with a length of \" + highestCount);\n    }\n    \n    \n    {\n      long highestNumber = 1;\n      int highestCount = 1;\n      for (long i = 2; i < MAX; i++) {\n        int count = 1;\n        long n = i;\n        while (n != 1) {\n          if ((n & 1) == 0)\n            n = n / 2;\n          else\n            n = 3 * n + 1;\n          count++;\n        }\n        if (count > highestCount) {\n          highestCount = count;\n          highestNumber = i;\n        }\n      }\n      System.out.println(\"Method 2, number \" + highestNumber + \" has the longest sequence, with a length of \" + highestCount);\n    }\n    \n    \n    {\n      long highestNumber = 1;\n      long highestCount = 1;\n      Map<Long, Integer> sequenceMap = new HashMap<Long, Integer>();\n      sequenceMap.put(Long.valueOf(1), Integer.valueOf(1));\n      \n      List<Long> currentList = new ArrayList<Long>();\n      for (long i = 2; i < MAX; i++) {\n        currentList.clear();\n        Long n = Long.valueOf(i);\n        Integer count = null;\n        while ((count = sequenceMap.get(n)) == null) {\n          currentList.add(n);\n          long nValue = n.longValue();\n          if ((nValue & 1) == 0)\n            n = Long.valueOf(nValue / 2);\n          else\n            n = Long.valueOf(3 * nValue + 1);\n        }\n        int curCount = count.intValue();\n        for (int j = currentList.size() - 1; j >= 0; j--)\n          sequenceMap.put(currentList.get(j), Integer.valueOf(++curCount));\n        if (curCount > highestCount) {\n          highestCount = curCount;\n          highestNumber = i;\n        }\n      }\n      System.out.println(\"Method 3, number \" + highestNumber + \" has the longest sequence, with a length of \" + highestCount);\n    }\n    return;\n  }\n}\n"}
{"id": 11527, "name": "Hailstone sequence", "source": "Translate Ruby to Java: def hailstone(n)\n    seq = [n]\n    until n == 1\n        n = n.even? ? n // 2 : n * 3 + 1\n        seq << n\n    end\n    seq\nend\n\nmax_len = (1...100_000).max_by{|n| hailstone(n).size }\nmax = hailstone(max_len)\nputs ([max_len, max.size, max.max, max.first(4), max.last(4)])\n\n\ntwenty_seven = hailstone(27)\nputs ([twenty_seven.size, twenty_seven.first(4), max.last(4)])\n\n", "target": "import java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\n\nclass Hailstone {\n\n  public static List<Long> getHailstoneSequence(long n) {\n    if (n <= 0)\n      throw new IllegalArgumentException(\"Invalid starting sequence number\");\n    List<Long> list = new ArrayList<Long>();\n    list.add(Long.valueOf(n));\n    while (n != 1) {\n      if ((n & 1) == 0)\n        n = n / 2;\n      else\n        n = 3 * n + 1;\n      list.add(Long.valueOf(n));\n    }\n    return list;\n  }\n  \n  public static void main(String[] args) {\n    List<Long> sequence27 = getHailstoneSequence(27);\n    System.out.println(\"Sequence for 27 has \" + sequence27.size() + \" elements: \" + sequence27);\n    \n    long MAX = 100000;\n    \n    {\n      long highestNumber = 1;\n      int highestCount = 1;\n      for (long i = 2; i < MAX; i++) {\n        int count = getHailstoneSequence(i).size();\n        if (count > highestCount) {\n          highestCount = count;\n          highestNumber = i;\n        }\n      }\n      System.out.println(\"Method 1, number \" + highestNumber + \" has the longest sequence, with a length of \" + highestCount);\n    }\n    \n    \n    {\n      long highestNumber = 1;\n      int highestCount = 1;\n      for (long i = 2; i < MAX; i++) {\n        int count = 1;\n        long n = i;\n        while (n != 1) {\n          if ((n & 1) == 0)\n            n = n / 2;\n          else\n            n = 3 * n + 1;\n          count++;\n        }\n        if (count > highestCount) {\n          highestCount = count;\n          highestNumber = i;\n        }\n      }\n      System.out.println(\"Method 2, number \" + highestNumber + \" has the longest sequence, with a length of \" + highestCount);\n    }\n    \n    \n    {\n      long highestNumber = 1;\n      long highestCount = 1;\n      Map<Long, Integer> sequenceMap = new HashMap<Long, Integer>();\n      sequenceMap.put(Long.valueOf(1), Integer.valueOf(1));\n      \n      List<Long> currentList = new ArrayList<Long>();\n      for (long i = 2; i < MAX; i++) {\n        currentList.clear();\n        Long n = Long.valueOf(i);\n        Integer count = null;\n        while ((count = sequenceMap.get(n)) == null) {\n          currentList.add(n);\n          long nValue = n.longValue();\n          if ((nValue & 1) == 0)\n            n = Long.valueOf(nValue / 2);\n          else\n            n = Long.valueOf(3 * nValue + 1);\n        }\n        int curCount = count.intValue();\n        for (int j = currentList.size() - 1; j >= 0; j--)\n          sequenceMap.put(currentList.get(j), Integer.valueOf(++curCount));\n        if (curCount > highestCount) {\n          highestCount = curCount;\n          highestNumber = i;\n        }\n      }\n      System.out.println(\"Method 3, number \" + highestNumber + \" has the longest sequence, with a length of \" + highestCount);\n    }\n    return;\n  }\n}\n"}
{"id": 11528, "name": "Hailstone sequence", "source": "Translate Ruby to Python: def hailstone(n)\n    seq = [n]\n    until n == 1\n        n = n.even? ? n // 2 : n * 3 + 1\n        seq << n\n    end\n    seq\nend\n\nmax_len = (1...100_000).max_by{|n| hailstone(n).size }\nmax = hailstone(max_len)\nputs ([max_len, max.size, max.max, max.first(4), max.last(4)])\n\n\ntwenty_seven = hailstone(27)\nputs ([twenty_seven.size, twenty_seven.first(4), max.last(4)])\n\n", "target": "def hailstone(n):\n    seq = [n]\n    while n > 1:\n        n = 3 * n + 1 if n & 1 else n // 2\n        seq.append(n)\n    return seq\n\n\nif __name__ == '__main__':\n    h = hailstone(27)\n    assert (len(h) == 112\n            and h[:4] == [27, 82, 41, 124]\n            and h[-4:] == [8, 4, 2, 1])\n    max_length, n = max((len(hailstone(i)), i) for i in range(1, 100_000))\n    print(f\"Maximum length {max_length} was found for hailstone({n}) \"\n          f\"for numbers <100,000\")\n"}
{"id": 11529, "name": "Hailstone sequence", "source": "Translate Ruby to Python: def hailstone(n)\n    seq = [n]\n    until n == 1\n        n = n.even? ? n // 2 : n * 3 + 1\n        seq << n\n    end\n    seq\nend\n\nmax_len = (1...100_000).max_by{|n| hailstone(n).size }\nmax = hailstone(max_len)\nputs ([max_len, max.size, max.max, max.first(4), max.last(4)])\n\n\ntwenty_seven = hailstone(27)\nputs ([twenty_seven.size, twenty_seven.first(4), max.last(4)])\n\n", "target": "def hailstone(n):\n    seq = [n]\n    while n > 1:\n        n = 3 * n + 1 if n & 1 else n // 2\n        seq.append(n)\n    return seq\n\n\nif __name__ == '__main__':\n    h = hailstone(27)\n    assert (len(h) == 112\n            and h[:4] == [27, 82, 41, 124]\n            and h[-4:] == [8, 4, 2, 1])\n    max_length, n = max((len(hailstone(i)), i) for i in range(1, 100_000))\n    print(f\"Maximum length {max_length} was found for hailstone({n}) \"\n          f\"for numbers <100,000\")\n"}
{"id": 11968, "name": "Multifactorial", "source": "Translate Ruby to C#: def multifact(n, d)\n  n.step(to: 1, by: -d).product\nend\n\n(1..5).each {|d| puts \"Degree \n", "target": "namespace RosettaCode.Multifactorial\n{\n    using System;\n    using System.Linq;\n\n    internal static class Program\n    {\n        private static void Main()\n        {\n            Console.WriteLine(string.Join(Environment.NewLine,\n                                          Enumerable.Range(1, 5)\n                                                    .Select(\n                                                        degree =>\n                                                        string.Join(\" \",\n                                                                    Enumerable.Range(1, 10)\n                                                                              .Select(\n                                                                                  number =>\n                                                                                  Multifactorial(number, degree))))));\n        }\n\n        private static int Multifactorial(int number, int degree)\n        {\n            if (degree < 1)\n            {\n                throw new ArgumentOutOfRangeException(\"degree\");\n            }\n\n            var count = 1 + (number - 1) / degree;\n            if (count < 1)\n            {\n                throw new ArgumentOutOfRangeException(\"number\");\n            }\n\n            return Enumerable.Range(0, count)\n                             .Aggregate(1, (accumulator, index) => accumulator * (number - degree * index));\n        }\n    }\n}\n"}
{"id": 11969, "name": "Multifactorial", "source": "Translate Ruby to C#: def multifact(n, d)\n  n.step(to: 1, by: -d).product\nend\n\n(1..5).each {|d| puts \"Degree \n", "target": "namespace RosettaCode.Multifactorial\n{\n    using System;\n    using System.Linq;\n\n    internal static class Program\n    {\n        private static void Main()\n        {\n            Console.WriteLine(string.Join(Environment.NewLine,\n                                          Enumerable.Range(1, 5)\n                                                    .Select(\n                                                        degree =>\n                                                        string.Join(\" \",\n                                                                    Enumerable.Range(1, 10)\n                                                                              .Select(\n                                                                                  number =>\n                                                                                  Multifactorial(number, degree))))));\n        }\n\n        private static int Multifactorial(int number, int degree)\n        {\n            if (degree < 1)\n            {\n                throw new ArgumentOutOfRangeException(\"degree\");\n            }\n\n            var count = 1 + (number - 1) / degree;\n            if (count < 1)\n            {\n                throw new ArgumentOutOfRangeException(\"number\");\n            }\n\n            return Enumerable.Range(0, count)\n                             .Aggregate(1, (accumulator, index) => accumulator * (number - degree * index));\n        }\n    }\n}\n"}
{"id": 11972, "name": "Multifactorial", "source": "Translate Ruby to Java: def multifact(n, d)\n  n.step(to: 1, by: -d).product\nend\n\n(1..5).each {|d| puts \"Degree \n", "target": "public class MultiFact {\n\tprivate static long multiFact(long n, int deg){\n\t\tlong ans = 1;\n\t\tfor(long i = n; i > 0; i -= deg){\n\t\t\tans *= i;\n\t\t}\n\t\treturn ans;\n\t}\n\t\n\tpublic static void main(String[] args){\n\t\tfor(int deg = 1; deg <= 5; deg++){\n\t\t\tSystem.out.print(\"degree \" + deg + \":\");\n\t\t\tfor(long n = 1; n <= 10; n++){\n\t\t\t\tSystem.out.print(\" \" + multiFact(n, deg));\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t}\n}\n"}
{"id": 11973, "name": "Multifactorial", "source": "Translate Ruby to Java: def multifact(n, d)\n  n.step(to: 1, by: -d).product\nend\n\n(1..5).each {|d| puts \"Degree \n", "target": "public class MultiFact {\n\tprivate static long multiFact(long n, int deg){\n\t\tlong ans = 1;\n\t\tfor(long i = n; i > 0; i -= deg){\n\t\t\tans *= i;\n\t\t}\n\t\treturn ans;\n\t}\n\t\n\tpublic static void main(String[] args){\n\t\tfor(int deg = 1; deg <= 5; deg++){\n\t\t\tSystem.out.print(\"degree \" + deg + \":\");\n\t\t\tfor(long n = 1; n <= 10; n++){\n\t\t\t\tSystem.out.print(\" \" + multiFact(n, deg));\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t}\n}\n"}
{"id": 11974, "name": "Multifactorial", "source": "Translate Ruby to Python: def multifact(n, d)\n  n.step(to: 1, by: -d).product\nend\n\n(1..5).each {|d| puts \"Degree \n", "target": ">>> from functools import reduce\n>>> from operator import mul\n>>> def mfac(n, m): return reduce(mul, range(n, 0, -m))\n\n>>> for m in range(1, 11): print(\"%2i: %r\" % (m, [mfac(n, m) for n in range(1, 11)]))\n\n 1: [1, 2, 6, 24, 120, 720, 5040, 40320, 362880, 3628800]\n 2: [1, 2, 3, 8, 15, 48, 105, 384, 945, 3840]\n 3: [1, 2, 3, 4, 10, 18, 28, 80, 162, 280]\n 4: [1, 2, 3, 4, 5, 12, 21, 32, 45, 120]\n 5: [1, 2, 3, 4, 5, 6, 14, 24, 36, 50]\n 6: [1, 2, 3, 4, 5, 6, 7, 16, 27, 40]\n 7: [1, 2, 3, 4, 5, 6, 7, 8, 18, 30]\n 8: [1, 2, 3, 4, 5, 6, 7, 8, 9, 20]\n 9: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n10: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n>>>\n"}
{"id": 11975, "name": "Multifactorial", "source": "Translate Ruby to Python: def multifact(n, d)\n  n.step(to: 1, by: -d).product\nend\n\n(1..5).each {|d| puts \"Degree \n", "target": ">>> from functools import reduce\n>>> from operator import mul\n>>> def mfac(n, m): return reduce(mul, range(n, 0, -m))\n\n>>> for m in range(1, 11): print(\"%2i: %r\" % (m, [mfac(n, m) for n in range(1, 11)]))\n\n 1: [1, 2, 6, 24, 120, 720, 5040, 40320, 362880, 3628800]\n 2: [1, 2, 3, 8, 15, 48, 105, 384, 945, 3840]\n 3: [1, 2, 3, 4, 10, 18, 28, 80, 162, 280]\n 4: [1, 2, 3, 4, 5, 12, 21, 32, 45, 120]\n 5: [1, 2, 3, 4, 5, 6, 14, 24, 36, 50]\n 6: [1, 2, 3, 4, 5, 6, 7, 16, 27, 40]\n 7: [1, 2, 3, 4, 5, 6, 7, 8, 18, 30]\n 8: [1, 2, 3, 4, 5, 6, 7, 8, 9, 20]\n 9: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n10: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n>>>\n"}
{"id": 12121, "name": "Doubly-linked list_Traversal", "source": "Translate Ruby to C#: class DListNode\n  def get_tail\n    \n    self.find {|node| node.succ.nil?}\n  end\n\n  def each_previous(&b)\n    yield self\n    self.prev.each_previous(&b) if self.prev\n  end\nend\n\nhead = DListNode.from_array([:a, :b, :c])\nhead.each {|node| p node.value}\nhead.get_tail.each_previous {|node| p node.value}\n", "target": "using System;\nusing System.Collections.Generic;\n\nnamespace RosettaCode.DoublyLinkedList\n{\n    internal static class Program\n    {\n        private static void Main()\n        {\n            var list = new LinkedList<char>(\"hello\");\n\n            var current = list.First;\n            do\n            {\n                Console.WriteLine(current.Value);\n            } while ((current = current.Next) != null);\n\n            Console.WriteLine();\n\n            current = list.Last;\n            do\n            {\n                Console.WriteLine(current.Value);\n            } while ((current = current.Previous) != null);\n        }\n    }\n}\n"}
{"id": 12123, "name": "Doubly-linked list_Traversal", "source": "Translate Ruby to Java: class DListNode\n  def get_tail\n    \n    self.find {|node| node.succ.nil?}\n  end\n\n  def each_previous(&b)\n    yield self\n    self.prev.each_previous(&b) if self.prev\n  end\nend\n\nhead = DListNode.from_array([:a, :b, :c])\nhead.each {|node| p node.value}\nhead.get_tail.each_previous {|node| p node.value}\n", "target": "package com.rosettacode;\n\nimport java.util.LinkedList;\nimport java.util.stream.Collectors;\nimport java.util.stream.IntStream;\n\npublic class DoubleLinkedListTraversing {\n\n  public static void main(String[] args) {\n\n    final LinkedList<String> doubleLinkedList =\n        IntStream.range(1, 10)\n            .mapToObj(String::valueOf)\n            .collect(Collectors.toCollection(LinkedList::new));\n\n    doubleLinkedList.iterator().forEachRemaining(System.out::print);\n    System.out.println();\n    doubleLinkedList.descendingIterator().forEachRemaining(System.out::print);\n  }\n}\n"}
{"id": 12124, "name": "Doubly-linked list_Traversal", "source": "Translate Ruby to Python: class DListNode\n  def get_tail\n    \n    self.find {|node| node.succ.nil?}\n  end\n\n  def each_previous(&b)\n    yield self\n    self.prev.each_previous(&b) if self.prev\n  end\nend\n\nhead = DListNode.from_array([:a, :b, :c])\nhead.each {|node| p node.value}\nhead.get_tail.each_previous {|node| p node.value}\n", "target": "class List:\n    def __init__(self, data, next=None, prev=None):\n        self.data = data\n        self.next = next\n        self.prev = prev\n\n    def append(self, data):\n        if self.next == None:\n            self.next = List(data, None, self)\n            return self.next\n        else:\n            return self.next.append(data)\n\n\ntail = head = List(10)\nfor i in [ 20, 30, 40 ]:\n    tail = tail.append(i)\n\n\nnode = head\nwhile node != None:\n    print(node.data)\n    node = node.next\n\n\nnode = tail\nwhile node != None:\n    print(node.data)\n    node = node.prev\n"}
{"id": 12346, "name": "Shoelace formula for polygonal area", "source": "Translate Ruby to C#: Point = Struct.new(:x,:y) do\n\n  def shoelace(other)\n    x * other.y - y * other.x\n  end\n\nend\n\nclass Polygon\n\n  def initialize(*coords)\n    @points = coords.map{|c| Point.new(*c) } \n  end\n\n  def area\n    points = @points + [@points.first]\n    points.each_cons(2).sum{|p1,p2| p1.shoelace(p2) }.abs.fdiv(2)\n  end\n\nend\n\nputs Polygon.new([3,4], [5,11], [12,8], [9,5], [5,6]).area  \n", "target": "using System;\nusing System.Collections.Generic;\n\nnamespace ShoelaceFormula {\n    using Point = Tuple<double, double>;\n\n    class Program {\n        static double ShoelaceArea(List<Point> v) {\n            int n = v.Count;\n            double a = 0.0;\n            for (int i = 0; i < n - 1; i++) {\n                a += v[i].Item1 * v[i + 1].Item2 - v[i + 1].Item1 * v[i].Item2;\n            }\n            return Math.Abs(a + v[n - 1].Item1 * v[0].Item2 - v[0].Item1 * v[n - 1].Item2) / 2.0;\n        }\n\n        static void Main(string[] args) {\n            List<Point> v = new List<Point>() {\n                new Point(3,4),\n                new Point(5,11),\n                new Point(12,8),\n                new Point(9,5),\n                new Point(5,6),\n            };\n            double area = ShoelaceArea(v);\n            Console.WriteLine(\"Given a polygon with vertices [{0}],\", string.Join(\", \", v));\n            Console.WriteLine(\"its area is {0}.\", area);\n        }\n    }\n}\n"}
{"id": 12347, "name": "Shoelace formula for polygonal area", "source": "Translate Ruby to C#: Point = Struct.new(:x,:y) do\n\n  def shoelace(other)\n    x * other.y - y * other.x\n  end\n\nend\n\nclass Polygon\n\n  def initialize(*coords)\n    @points = coords.map{|c| Point.new(*c) } \n  end\n\n  def area\n    points = @points + [@points.first]\n    points.each_cons(2).sum{|p1,p2| p1.shoelace(p2) }.abs.fdiv(2)\n  end\n\nend\n\nputs Polygon.new([3,4], [5,11], [12,8], [9,5], [5,6]).area  \n", "target": "using System;\nusing System.Collections.Generic;\n\nnamespace ShoelaceFormula {\n    using Point = Tuple<double, double>;\n\n    class Program {\n        static double ShoelaceArea(List<Point> v) {\n            int n = v.Count;\n            double a = 0.0;\n            for (int i = 0; i < n - 1; i++) {\n                a += v[i].Item1 * v[i + 1].Item2 - v[i + 1].Item1 * v[i].Item2;\n            }\n            return Math.Abs(a + v[n - 1].Item1 * v[0].Item2 - v[0].Item1 * v[n - 1].Item2) / 2.0;\n        }\n\n        static void Main(string[] args) {\n            List<Point> v = new List<Point>() {\n                new Point(3,4),\n                new Point(5,11),\n                new Point(12,8),\n                new Point(9,5),\n                new Point(5,6),\n            };\n            double area = ShoelaceArea(v);\n            Console.WriteLine(\"Given a polygon with vertices [{0}],\", string.Join(\", \", v));\n            Console.WriteLine(\"its area is {0}.\", area);\n        }\n    }\n}\n"}
{"id": 12350, "name": "Shoelace formula for polygonal area", "source": "Translate Ruby to Java: Point = Struct.new(:x,:y) do\n\n  def shoelace(other)\n    x * other.y - y * other.x\n  end\n\nend\n\nclass Polygon\n\n  def initialize(*coords)\n    @points = coords.map{|c| Point.new(*c) } \n  end\n\n  def area\n    points = @points + [@points.first]\n    points.each_cons(2).sum{|p1,p2| p1.shoelace(p2) }.abs.fdiv(2)\n  end\n\nend\n\nputs Polygon.new([3,4], [5,11], [12,8], [9,5], [5,6]).area  \n", "target": "import java.util.List;\n\npublic class ShoelaceFormula {\n    private static class Point {\n        int x, y;\n\n        Point(int x, int y) {\n            this.x = x;\n            this.y = y;\n        }\n\n        @Override\n        public String toString() {\n            return String.format(\"(%d, %d)\", x, y);\n        }\n    }\n\n    private static double shoelaceArea(List<Point> v) {\n        int n = v.size();\n        double a = 0.0;\n        for (int i = 0; i < n - 1; i++) {\n            a += v.get(i).x * v.get(i + 1).y - v.get(i + 1).x * v.get(i).y;\n        }\n        return Math.abs(a + v.get(n - 1).x * v.get(0).y - v.get(0).x * v.get(n - 1).y) / 2.0;\n    }\n\n    public static void main(String[] args) {\n        List<Point> v = List.of(\n            new Point(3, 4),\n            new Point(5, 11),\n            new Point(12, 8),\n            new Point(9, 5),\n            new Point(5, 6)\n        );\n        double area = shoelaceArea(v);\n        System.out.printf(\"Given a polygon with vertices %s,%n\", v);\n        System.out.printf(\"its area is %f,%n\", area);\n    }\n}\n"}
{"id": 12351, "name": "Shoelace formula for polygonal area", "source": "Translate Ruby to Python: Point = Struct.new(:x,:y) do\n\n  def shoelace(other)\n    x * other.y - y * other.x\n  end\n\nend\n\nclass Polygon\n\n  def initialize(*coords)\n    @points = coords.map{|c| Point.new(*c) } \n  end\n\n  def area\n    points = @points + [@points.first]\n    points.each_cons(2).sum{|p1,p2| p1.shoelace(p2) }.abs.fdiv(2)\n  end\n\nend\n\nputs Polygon.new([3,4], [5,11], [12,8], [9,5], [5,6]).area  \n", "target": ">>> def area_by_shoelace(x, y):\n    \"Assumes x,y points go around the polygon in one direction\"\n    return abs( sum(i * j for i, j in zip(x,             y[1:] + y[:1]))\n               -sum(i * j for i, j in zip(x[1:] + x[:1], y            ))) / 2\n\n>>> points = [(3,4), (5,11), (12,8), (9,5), (5,6)]\n>>> x, y = zip(*points)\n>>> area_by_shoelace(x, y)\n30.0\n>>>\n"}
{"id": 12352, "name": "Shoelace formula for polygonal area", "source": "Translate Ruby to Python: Point = Struct.new(:x,:y) do\n\n  def shoelace(other)\n    x * other.y - y * other.x\n  end\n\nend\n\nclass Polygon\n\n  def initialize(*coords)\n    @points = coords.map{|c| Point.new(*c) } \n  end\n\n  def area\n    points = @points + [@points.first]\n    points.each_cons(2).sum{|p1,p2| p1.shoelace(p2) }.abs.fdiv(2)\n  end\n\nend\n\nputs Polygon.new([3,4], [5,11], [12,8], [9,5], [5,6]).area  \n", "target": ">>> def area_by_shoelace(x, y):\n    \"Assumes x,y points go around the polygon in one direction\"\n    return abs( sum(i * j for i, j in zip(x,             y[1:] + y[:1]))\n               -sum(i * j for i, j in zip(x[1:] + x[:1], y            ))) / 2\n\n>>> points = [(3,4), (5,11), (12,8), (9,5), (5,6)]\n>>> x, y = zip(*points)\n>>> area_by_shoelace(x, y)\n30.0\n>>>\n"}
{"id": 12554, "name": "Determine if two triangles overlap", "source": "Translate Ruby to C#: require \"matrix\"\n\ndef det2D(p1, p2, p3)\n    return p1[0] * (p2[1] - p3[1]) + p2[0] * (p3[1] - p1[1]) + p3[0] * (p1[1] - p2[1])\nend\n\ndef checkTriWinding(p1, p2, p3, allowReversed)\n    detTri = det2D(p1, p2, p3)\n    if detTri < 0.0 then\n        if allowReversed then\n            p2[0], p3[0] = p3[0], p2[0]\n            p2[1], p3[1] = p3[1], p2[1]\n        else\n            raise \"Triangle has incorrect winding\"\n        end\n    end\nend\n\ndef boundaryCollideChk(p1, p2, p3, eps)\n    return det2D(p1, p2, p3) < eps\nend\n\ndef boundaryDoesntCollideChk(p1, p2, p3, eps)\n    return det2D(p1, p2, p3) <= eps\nend\n\ndef triTri2D(t1, t2, eps, allowReversed, onBoundary)\n    \n    checkTriWinding(t1[0], t1[1], t1[2], allowReversed)\n    checkTriWinding(t2[0], t2[1], t2[2], allowReversed)\n\n    if onBoundary then\n        \n        chkEdge = -> (p1, p2, p3, eps) { boundaryCollideChk(p1, p2, p3, eps) }\n    else\n        \n        chkEdge = -> (p1, p2, p3, eps) { boundaryDoesntCollideChk(p1, p2, p3, eps) }\n    end\n\n    \n    for i in 0..2 do\n        j = (i + 1) % 3\n\n        \n        \n        if chkEdge.(t1[i], t1[j], t2[0], eps) and chkEdge.(t1[i], t1[j], t2[1], eps) and chkEdge.(t1[i], t1[j], t2[2], eps) then\n            return false\n        end\n    end\n\n    \n    for i in 0..2 do\n        j = (i + 1) % 3\n\n        \n        \n        if chkEdge.(t2[i], t2[j], t1[0], eps) and chkEdge.(t2[i], t2[j], t1[1], eps) and chkEdge.(t2[i], t2[j], t1[2], eps) then\n            return false\n        end\n    end\n\n    \n    return true\nend\n\ndef main\n    t1 = [Vector[0,0], Vector[5,0], Vector[0,5]]\n    t2 = [Vector[0,0], Vector[5,0], Vector[0,6]]\n    print \"Triangle: \", t1, \"\\n\"\n    print \"Triangle: \", t2, \"\\n\"\n    print \"overlap: %s\\n\\n\" % [triTri2D(t1, t2, 0.0, false, true)]\n\n    t1 = [Vector[0,0], Vector[0,5], Vector[5,0]]\n    t2 = [Vector[0,0], Vector[0,5], Vector[5,0]]\n    print \"Triangle: \", t1, \"\\n\"\n    print \"Triangle: \", t2, \"\\n\"\n    print \"overlap: %s\\n\\n\" % [triTri2D(t1, t2, 0.0, true, true)]\n\n    t1 = [Vector[  0,0], Vector[ 5,0], Vector[ 0,5]]\n    t2 = [Vector[-10,0], Vector[-5,0], Vector[-1,6]]\n    print \"Triangle: \", t1, \"\\n\"\n    print \"Triangle: \", t2, \"\\n\"\n    print \"overlap: %s\\n\\n\" % [triTri2D(t1, t2, 0.0, false, true)]\n\n    t1 = [Vector[0,0], Vector[  5, 0], Vector[2.5,5]]\n    t2 = [Vector[0,4], Vector[2.5,-1], Vector[  5,4]]\n    print \"Triangle: \", t1, \"\\n\"\n    print \"Triangle: \", t2, \"\\n\"\n    print \"overlap: %s\\n\\n\" % [triTri2D(t1, t2, 0.0, false, true)]\n\n    t1 = [Vector[0,0], Vector[1,1], Vector[0,2]]\n    t2 = [Vector[2,1], Vector[3,0], Vector[3,2]]\n    print \"Triangle: \", t1, \"\\n\"\n    print \"Triangle: \", t2, \"\\n\"\n    print \"overlap: %s\\n\\n\" % [triTri2D(t1, t2, 0.0, false, true)]\n\n    t1 = [Vector[0,0], Vector[1, 1], Vector[0,2]]\n    t2 = [Vector[2,1], Vector[3,-2], Vector[3,4]]\n    print \"Triangle: \", t1, \"\\n\"\n    print \"Triangle: \", t2, \"\\n\"\n    print \"overlap: %s\\n\\n\" % [triTri2D(t1, t2, 0.0, false, true)]\n\n    \n    t1 = [Vector[0,0], Vector[1,0], Vector[0,1]]\n    t2 = [Vector[1,0], Vector[2,0], Vector[1,1]]\n    print \"Triangle: \", t1, \"\\n\"\n    print \"Triangle: \", t2, \"\\n\"\n    print \"overlap: %s\\n\\n\" % [triTri2D(t1, t2, 0.0, false, true)]\n\n    \n    t1 = [Vector[0,0], Vector[1,0], Vector[0,1]]\n    t2 = [Vector[1,0], Vector[2,0], Vector[1,1]]\n    print \"Triangle: \", t1, \"\\n\"\n    print \"Triangle: \", t2, \"\\n\"\n    print \"overlap: %s\\n\\n\" % [triTri2D(t1, t2, 0.0, false, false)]\nend\n\nmain()\n", "target": "using System;\nusing System.Collections.Generic;\n\nnamespace TriangleOverlap {\n    class Triangle {\n        public Tuple<double, double> P1 { get; set; }\n        public Tuple<double, double> P2 { get; set; }\n        public Tuple<double, double> P3 { get; set; }\n\n        public Triangle(Tuple<double, double> p1, Tuple<double, double> p2, Tuple<double, double> p3) {\n            P1 = p1;\n            P2 = p2;\n            P3 = p3;\n        }\n\n        public double Det2D() {\n            return P1.Item1 * (P2.Item2 - P3.Item2)\n                 + P2.Item1 * (P3.Item2 - P1.Item2)\n                 + P3.Item1 * (P3.Item1 - P2.Item2);\n        }\n\n        public void CheckTriWinding(bool allowReversed) {\n            var detTri = Det2D();\n            if (detTri < 0.0) {\n                if (allowReversed) {\n                    var a = P3;\n                    P3 = P2;\n                    P2 = a;\n                } else {\n                    throw new Exception(\"Triangle has wrong winding direction\");\n                }\n            }\n        }\n\n        public bool BoundaryCollideChk(double eps) {\n            return Det2D() < eps;\n        }\n\n        public bool BoundaryDoesntCollideChk(double eps) {\n            return Det2D() <= eps;\n        }\n\n        public override string ToString() {\n            return string.Format(\"Triangle: {0}, {1}, {2}\", P1, P2, P3);\n        }\n    }\n\n    class Program {\n        static bool BoundaryCollideChk(Triangle t, double eps) {\n            return t.BoundaryCollideChk(eps);\n        }\n\n        static bool BoundaryDoesntCollideChk(Triangle t, double eps) {\n            return t.BoundaryDoesntCollideChk(eps);\n        }\n\n        static bool TriTri2D(Triangle t1, Triangle t2, double eps = 0.0, bool allowReversed = false, bool onBoundary = true) {\n            \n            t1.CheckTriWinding(allowReversed);\n            t2.CheckTriWinding(allowReversed);\n            \n            var chkEdge = onBoundary\n                ? (Func<Triangle, double, bool>)BoundaryCollideChk\n                : BoundaryDoesntCollideChk;\n            List<Tuple<double, double>> lp1 = new List<Tuple<double, double>>() { t1.P1, t1.P2, t1.P3 };\n            List<Tuple<double, double>> lp2 = new List<Tuple<double, double>>() { t2.P1, t2.P2, t2.P3 };\n\n            \n            for (int i = 0; i < 3; i++) {\n                var j = (i + 1) % 3;\n                \n                \n                if (chkEdge(new Triangle(lp1[i], lp1[j], lp2[0]), eps) &&\n                    chkEdge(new Triangle(lp1[i], lp1[j], lp2[1]), eps) &&\n                    chkEdge(new Triangle(lp1[i], lp1[j], lp2[2]), eps)) {\n                    return false;\n                }\n            }\n\n            \n            for (int i = 0; i < 3; i++) {\n                var j = (i + 1) % 3;\n                \n                \n                if (chkEdge(new Triangle(lp2[i], lp2[j], lp1[0]), eps) &&\n                    chkEdge(new Triangle(lp2[i], lp2[j], lp1[1]), eps) &&\n                    chkEdge(new Triangle(lp2[i], lp2[j], lp1[2]), eps)) {\n                    return false;\n                }\n            }\n\n            \n            return true;\n        }\n\n        static void Overlap(Triangle t1, Triangle t2, double eps = 0.0, bool allowReversed = false, bool onBoundary = true) {\n            if (TriTri2D(t1, t2, eps, allowReversed, onBoundary)) {\n                Console.WriteLine(\"overlap\");\n            } else {\n                Console.WriteLine(\"do not overlap\");\n            }\n        }\n\n        static void Main(string[] args) {\n            var t1 = new Triangle(new Tuple<double, double>(0.0, 0.0), new Tuple<double, double>(5.0, 0.0), new Tuple<double, double>(0.0, 5.0));\n            var t2 = new Triangle(new Tuple<double, double>(0.0, 0.0), new Tuple<double, double>(5.0, 0.0), new Tuple<double, double>(0.0, 6.0));\n            Console.WriteLine(\"{0} and\\n{1}\", t1, t2);\n            Overlap(t1, t2);\n            Console.WriteLine();\n\n            \n            t1 = new Triangle(new Tuple<double, double>(0.0, 0.0), new Tuple<double, double>(0.0, 5.0), new Tuple<double, double>(5.0, 0.0));\n            t2 = t1;\n            Console.WriteLine(\"{0} and\\n{1}\", t1, t2);\n            Overlap(t1, t2, 0.0, true);\n            Console.WriteLine();\n\n            t1 = new Triangle(new Tuple<double, double>(0.0, 0.0), new Tuple<double, double>(5.0, 0.0), new Tuple<double, double>(0.0, 5.0));\n            t2 = new Triangle(new Tuple<double, double>(-10.0, 0.0), new Tuple<double, double>(-5.0, 0.0), new Tuple<double, double>(-1.0, 6.0));\n            Console.WriteLine(\"{0} and\\n{1}\", t1, t2);\n            Overlap(t1, t2);\n            Console.WriteLine();\n\n            t1.P3 = new Tuple<double, double>(2.5, 5.0);\n            t2 = new Triangle(new Tuple<double, double>(0.0, 4.0), new Tuple<double, double>(2.5, -1.0), new Tuple<double, double>(5.0, 4.0));\n            Console.WriteLine(\"{0} and\\n{1}\", t1, t2);\n            Overlap(t1, t2);\n            Console.WriteLine();\n\n            t1 = new Triangle(new Tuple<double, double>(0.0, 0.0), new Tuple<double, double>(1.0, 1.0), new Tuple<double, double>(0.0, 2.0));\n            t2 = new Triangle(new Tuple<double, double>(2.0, 1.0), new Tuple<double, double>(3.0, 0.0), new Tuple<double, double>(3.0, 2.0));\n            Console.WriteLine(\"{0} and\\n{1}\", t1, t2);\n            Overlap(t1, t2);\n            Console.WriteLine();\n\n            t2 = new Triangle(new Tuple<double, double>(2.0, 1.0), new Tuple<double, double>(3.0, -2.0), new Tuple<double, double>(3.0, 4.0));\n            Console.WriteLine(\"{0} and\\n{1}\", t1, t2);\n            Overlap(t1, t2);\n            Console.WriteLine();\n\n            t1 = new Triangle(new Tuple<double, double>(0.0, 0.0), new Tuple<double, double>(1.0, 0.0), new Tuple<double, double>(0.0, 1.0));\n            t2 = new Triangle(new Tuple<double, double>(1.0, 0.0), new Tuple<double, double>(2.0, 0.0), new Tuple<double, double>(1.0, 1.1));\n            Console.WriteLine(\"{0} and\\n{1}\", t1, t2);\n            Console.WriteLine(\"which have only a single corner in contact, if boundary points collide\");\n            Overlap(t1, t2);\n            Console.WriteLine();\n\n            Console.WriteLine(\"{0} and\\n{1}\", t1, t2);\n            Console.WriteLine(\"which have only a single corner in contact, if boundary points do not collide\");\n            Overlap(t1, t2, 0.0, false, false);\n        }\n    }\n}\n"}
{"id": 12555, "name": "Determine if two triangles overlap", "source": "Translate Ruby to C#: require \"matrix\"\n\ndef det2D(p1, p2, p3)\n    return p1[0] * (p2[1] - p3[1]) + p2[0] * (p3[1] - p1[1]) + p3[0] * (p1[1] - p2[1])\nend\n\ndef checkTriWinding(p1, p2, p3, allowReversed)\n    detTri = det2D(p1, p2, p3)\n    if detTri < 0.0 then\n        if allowReversed then\n            p2[0], p3[0] = p3[0], p2[0]\n            p2[1], p3[1] = p3[1], p2[1]\n        else\n            raise \"Triangle has incorrect winding\"\n        end\n    end\nend\n\ndef boundaryCollideChk(p1, p2, p3, eps)\n    return det2D(p1, p2, p3) < eps\nend\n\ndef boundaryDoesntCollideChk(p1, p2, p3, eps)\n    return det2D(p1, p2, p3) <= eps\nend\n\ndef triTri2D(t1, t2, eps, allowReversed, onBoundary)\n    \n    checkTriWinding(t1[0], t1[1], t1[2], allowReversed)\n    checkTriWinding(t2[0], t2[1], t2[2], allowReversed)\n\n    if onBoundary then\n        \n        chkEdge = -> (p1, p2, p3, eps) { boundaryCollideChk(p1, p2, p3, eps) }\n    else\n        \n        chkEdge = -> (p1, p2, p3, eps) { boundaryDoesntCollideChk(p1, p2, p3, eps) }\n    end\n\n    \n    for i in 0..2 do\n        j = (i + 1) % 3\n\n        \n        \n        if chkEdge.(t1[i], t1[j], t2[0], eps) and chkEdge.(t1[i], t1[j], t2[1], eps) and chkEdge.(t1[i], t1[j], t2[2], eps) then\n            return false\n        end\n    end\n\n    \n    for i in 0..2 do\n        j = (i + 1) % 3\n\n        \n        \n        if chkEdge.(t2[i], t2[j], t1[0], eps) and chkEdge.(t2[i], t2[j], t1[1], eps) and chkEdge.(t2[i], t2[j], t1[2], eps) then\n            return false\n        end\n    end\n\n    \n    return true\nend\n\ndef main\n    t1 = [Vector[0,0], Vector[5,0], Vector[0,5]]\n    t2 = [Vector[0,0], Vector[5,0], Vector[0,6]]\n    print \"Triangle: \", t1, \"\\n\"\n    print \"Triangle: \", t2, \"\\n\"\n    print \"overlap: %s\\n\\n\" % [triTri2D(t1, t2, 0.0, false, true)]\n\n    t1 = [Vector[0,0], Vector[0,5], Vector[5,0]]\n    t2 = [Vector[0,0], Vector[0,5], Vector[5,0]]\n    print \"Triangle: \", t1, \"\\n\"\n    print \"Triangle: \", t2, \"\\n\"\n    print \"overlap: %s\\n\\n\" % [triTri2D(t1, t2, 0.0, true, true)]\n\n    t1 = [Vector[  0,0], Vector[ 5,0], Vector[ 0,5]]\n    t2 = [Vector[-10,0], Vector[-5,0], Vector[-1,6]]\n    print \"Triangle: \", t1, \"\\n\"\n    print \"Triangle: \", t2, \"\\n\"\n    print \"overlap: %s\\n\\n\" % [triTri2D(t1, t2, 0.0, false, true)]\n\n    t1 = [Vector[0,0], Vector[  5, 0], Vector[2.5,5]]\n    t2 = [Vector[0,4], Vector[2.5,-1], Vector[  5,4]]\n    print \"Triangle: \", t1, \"\\n\"\n    print \"Triangle: \", t2, \"\\n\"\n    print \"overlap: %s\\n\\n\" % [triTri2D(t1, t2, 0.0, false, true)]\n\n    t1 = [Vector[0,0], Vector[1,1], Vector[0,2]]\n    t2 = [Vector[2,1], Vector[3,0], Vector[3,2]]\n    print \"Triangle: \", t1, \"\\n\"\n    print \"Triangle: \", t2, \"\\n\"\n    print \"overlap: %s\\n\\n\" % [triTri2D(t1, t2, 0.0, false, true)]\n\n    t1 = [Vector[0,0], Vector[1, 1], Vector[0,2]]\n    t2 = [Vector[2,1], Vector[3,-2], Vector[3,4]]\n    print \"Triangle: \", t1, \"\\n\"\n    print \"Triangle: \", t2, \"\\n\"\n    print \"overlap: %s\\n\\n\" % [triTri2D(t1, t2, 0.0, false, true)]\n\n    \n    t1 = [Vector[0,0], Vector[1,0], Vector[0,1]]\n    t2 = [Vector[1,0], Vector[2,0], Vector[1,1]]\n    print \"Triangle: \", t1, \"\\n\"\n    print \"Triangle: \", t2, \"\\n\"\n    print \"overlap: %s\\n\\n\" % [triTri2D(t1, t2, 0.0, false, true)]\n\n    \n    t1 = [Vector[0,0], Vector[1,0], Vector[0,1]]\n    t2 = [Vector[1,0], Vector[2,0], Vector[1,1]]\n    print \"Triangle: \", t1, \"\\n\"\n    print \"Triangle: \", t2, \"\\n\"\n    print \"overlap: %s\\n\\n\" % [triTri2D(t1, t2, 0.0, false, false)]\nend\n\nmain()\n", "target": "using System;\nusing System.Collections.Generic;\n\nnamespace TriangleOverlap {\n    class Triangle {\n        public Tuple<double, double> P1 { get; set; }\n        public Tuple<double, double> P2 { get; set; }\n        public Tuple<double, double> P3 { get; set; }\n\n        public Triangle(Tuple<double, double> p1, Tuple<double, double> p2, Tuple<double, double> p3) {\n            P1 = p1;\n            P2 = p2;\n            P3 = p3;\n        }\n\n        public double Det2D() {\n            return P1.Item1 * (P2.Item2 - P3.Item2)\n                 + P2.Item1 * (P3.Item2 - P1.Item2)\n                 + P3.Item1 * (P3.Item1 - P2.Item2);\n        }\n\n        public void CheckTriWinding(bool allowReversed) {\n            var detTri = Det2D();\n            if (detTri < 0.0) {\n                if (allowReversed) {\n                    var a = P3;\n                    P3 = P2;\n                    P2 = a;\n                } else {\n                    throw new Exception(\"Triangle has wrong winding direction\");\n                }\n            }\n        }\n\n        public bool BoundaryCollideChk(double eps) {\n            return Det2D() < eps;\n        }\n\n        public bool BoundaryDoesntCollideChk(double eps) {\n            return Det2D() <= eps;\n        }\n\n        public override string ToString() {\n            return string.Format(\"Triangle: {0}, {1}, {2}\", P1, P2, P3);\n        }\n    }\n\n    class Program {\n        static bool BoundaryCollideChk(Triangle t, double eps) {\n            return t.BoundaryCollideChk(eps);\n        }\n\n        static bool BoundaryDoesntCollideChk(Triangle t, double eps) {\n            return t.BoundaryDoesntCollideChk(eps);\n        }\n\n        static bool TriTri2D(Triangle t1, Triangle t2, double eps = 0.0, bool allowReversed = false, bool onBoundary = true) {\n            \n            t1.CheckTriWinding(allowReversed);\n            t2.CheckTriWinding(allowReversed);\n            \n            var chkEdge = onBoundary\n                ? (Func<Triangle, double, bool>)BoundaryCollideChk\n                : BoundaryDoesntCollideChk;\n            List<Tuple<double, double>> lp1 = new List<Tuple<double, double>>() { t1.P1, t1.P2, t1.P3 };\n            List<Tuple<double, double>> lp2 = new List<Tuple<double, double>>() { t2.P1, t2.P2, t2.P3 };\n\n            \n            for (int i = 0; i < 3; i++) {\n                var j = (i + 1) % 3;\n                \n                \n                if (chkEdge(new Triangle(lp1[i], lp1[j], lp2[0]), eps) &&\n                    chkEdge(new Triangle(lp1[i], lp1[j], lp2[1]), eps) &&\n                    chkEdge(new Triangle(lp1[i], lp1[j], lp2[2]), eps)) {\n                    return false;\n                }\n            }\n\n            \n            for (int i = 0; i < 3; i++) {\n                var j = (i + 1) % 3;\n                \n                \n                if (chkEdge(new Triangle(lp2[i], lp2[j], lp1[0]), eps) &&\n                    chkEdge(new Triangle(lp2[i], lp2[j], lp1[1]), eps) &&\n                    chkEdge(new Triangle(lp2[i], lp2[j], lp1[2]), eps)) {\n                    return false;\n                }\n            }\n\n            \n            return true;\n        }\n\n        static void Overlap(Triangle t1, Triangle t2, double eps = 0.0, bool allowReversed = false, bool onBoundary = true) {\n            if (TriTri2D(t1, t2, eps, allowReversed, onBoundary)) {\n                Console.WriteLine(\"overlap\");\n            } else {\n                Console.WriteLine(\"do not overlap\");\n            }\n        }\n\n        static void Main(string[] args) {\n            var t1 = new Triangle(new Tuple<double, double>(0.0, 0.0), new Tuple<double, double>(5.0, 0.0), new Tuple<double, double>(0.0, 5.0));\n            var t2 = new Triangle(new Tuple<double, double>(0.0, 0.0), new Tuple<double, double>(5.0, 0.0), new Tuple<double, double>(0.0, 6.0));\n            Console.WriteLine(\"{0} and\\n{1}\", t1, t2);\n            Overlap(t1, t2);\n            Console.WriteLine();\n\n            \n            t1 = new Triangle(new Tuple<double, double>(0.0, 0.0), new Tuple<double, double>(0.0, 5.0), new Tuple<double, double>(5.0, 0.0));\n            t2 = t1;\n            Console.WriteLine(\"{0} and\\n{1}\", t1, t2);\n            Overlap(t1, t2, 0.0, true);\n            Console.WriteLine();\n\n            t1 = new Triangle(new Tuple<double, double>(0.0, 0.0), new Tuple<double, double>(5.0, 0.0), new Tuple<double, double>(0.0, 5.0));\n            t2 = new Triangle(new Tuple<double, double>(-10.0, 0.0), new Tuple<double, double>(-5.0, 0.0), new Tuple<double, double>(-1.0, 6.0));\n            Console.WriteLine(\"{0} and\\n{1}\", t1, t2);\n            Overlap(t1, t2);\n            Console.WriteLine();\n\n            t1.P3 = new Tuple<double, double>(2.5, 5.0);\n            t2 = new Triangle(new Tuple<double, double>(0.0, 4.0), new Tuple<double, double>(2.5, -1.0), new Tuple<double, double>(5.0, 4.0));\n            Console.WriteLine(\"{0} and\\n{1}\", t1, t2);\n            Overlap(t1, t2);\n            Console.WriteLine();\n\n            t1 = new Triangle(new Tuple<double, double>(0.0, 0.0), new Tuple<double, double>(1.0, 1.0), new Tuple<double, double>(0.0, 2.0));\n            t2 = new Triangle(new Tuple<double, double>(2.0, 1.0), new Tuple<double, double>(3.0, 0.0), new Tuple<double, double>(3.0, 2.0));\n            Console.WriteLine(\"{0} and\\n{1}\", t1, t2);\n            Overlap(t1, t2);\n            Console.WriteLine();\n\n            t2 = new Triangle(new Tuple<double, double>(2.0, 1.0), new Tuple<double, double>(3.0, -2.0), new Tuple<double, double>(3.0, 4.0));\n            Console.WriteLine(\"{0} and\\n{1}\", t1, t2);\n            Overlap(t1, t2);\n            Console.WriteLine();\n\n            t1 = new Triangle(new Tuple<double, double>(0.0, 0.0), new Tuple<double, double>(1.0, 0.0), new Tuple<double, double>(0.0, 1.0));\n            t2 = new Triangle(new Tuple<double, double>(1.0, 0.0), new Tuple<double, double>(2.0, 0.0), new Tuple<double, double>(1.0, 1.1));\n            Console.WriteLine(\"{0} and\\n{1}\", t1, t2);\n            Console.WriteLine(\"which have only a single corner in contact, if boundary points collide\");\n            Overlap(t1, t2);\n            Console.WriteLine();\n\n            Console.WriteLine(\"{0} and\\n{1}\", t1, t2);\n            Console.WriteLine(\"which have only a single corner in contact, if boundary points do not collide\");\n            Overlap(t1, t2, 0.0, false, false);\n        }\n    }\n}\n"}
{"id": 12558, "name": "Determine if two triangles overlap", "source": "Translate Ruby to Java: require \"matrix\"\n\ndef det2D(p1, p2, p3)\n    return p1[0] * (p2[1] - p3[1]) + p2[0] * (p3[1] - p1[1]) + p3[0] * (p1[1] - p2[1])\nend\n\ndef checkTriWinding(p1, p2, p3, allowReversed)\n    detTri = det2D(p1, p2, p3)\n    if detTri < 0.0 then\n        if allowReversed then\n            p2[0], p3[0] = p3[0], p2[0]\n            p2[1], p3[1] = p3[1], p2[1]\n        else\n            raise \"Triangle has incorrect winding\"\n        end\n    end\nend\n\ndef boundaryCollideChk(p1, p2, p3, eps)\n    return det2D(p1, p2, p3) < eps\nend\n\ndef boundaryDoesntCollideChk(p1, p2, p3, eps)\n    return det2D(p1, p2, p3) <= eps\nend\n\ndef triTri2D(t1, t2, eps, allowReversed, onBoundary)\n    \n    checkTriWinding(t1[0], t1[1], t1[2], allowReversed)\n    checkTriWinding(t2[0], t2[1], t2[2], allowReversed)\n\n    if onBoundary then\n        \n        chkEdge = -> (p1, p2, p3, eps) { boundaryCollideChk(p1, p2, p3, eps) }\n    else\n        \n        chkEdge = -> (p1, p2, p3, eps) { boundaryDoesntCollideChk(p1, p2, p3, eps) }\n    end\n\n    \n    for i in 0..2 do\n        j = (i + 1) % 3\n\n        \n        \n        if chkEdge.(t1[i], t1[j], t2[0], eps) and chkEdge.(t1[i], t1[j], t2[1], eps) and chkEdge.(t1[i], t1[j], t2[2], eps) then\n            return false\n        end\n    end\n\n    \n    for i in 0..2 do\n        j = (i + 1) % 3\n\n        \n        \n        if chkEdge.(t2[i], t2[j], t1[0], eps) and chkEdge.(t2[i], t2[j], t1[1], eps) and chkEdge.(t2[i], t2[j], t1[2], eps) then\n            return false\n        end\n    end\n\n    \n    return true\nend\n\ndef main\n    t1 = [Vector[0,0], Vector[5,0], Vector[0,5]]\n    t2 = [Vector[0,0], Vector[5,0], Vector[0,6]]\n    print \"Triangle: \", t1, \"\\n\"\n    print \"Triangle: \", t2, \"\\n\"\n    print \"overlap: %s\\n\\n\" % [triTri2D(t1, t2, 0.0, false, true)]\n\n    t1 = [Vector[0,0], Vector[0,5], Vector[5,0]]\n    t2 = [Vector[0,0], Vector[0,5], Vector[5,0]]\n    print \"Triangle: \", t1, \"\\n\"\n    print \"Triangle: \", t2, \"\\n\"\n    print \"overlap: %s\\n\\n\" % [triTri2D(t1, t2, 0.0, true, true)]\n\n    t1 = [Vector[  0,0], Vector[ 5,0], Vector[ 0,5]]\n    t2 = [Vector[-10,0], Vector[-5,0], Vector[-1,6]]\n    print \"Triangle: \", t1, \"\\n\"\n    print \"Triangle: \", t2, \"\\n\"\n    print \"overlap: %s\\n\\n\" % [triTri2D(t1, t2, 0.0, false, true)]\n\n    t1 = [Vector[0,0], Vector[  5, 0], Vector[2.5,5]]\n    t2 = [Vector[0,4], Vector[2.5,-1], Vector[  5,4]]\n    print \"Triangle: \", t1, \"\\n\"\n    print \"Triangle: \", t2, \"\\n\"\n    print \"overlap: %s\\n\\n\" % [triTri2D(t1, t2, 0.0, false, true)]\n\n    t1 = [Vector[0,0], Vector[1,1], Vector[0,2]]\n    t2 = [Vector[2,1], Vector[3,0], Vector[3,2]]\n    print \"Triangle: \", t1, \"\\n\"\n    print \"Triangle: \", t2, \"\\n\"\n    print \"overlap: %s\\n\\n\" % [triTri2D(t1, t2, 0.0, false, true)]\n\n    t1 = [Vector[0,0], Vector[1, 1], Vector[0,2]]\n    t2 = [Vector[2,1], Vector[3,-2], Vector[3,4]]\n    print \"Triangle: \", t1, \"\\n\"\n    print \"Triangle: \", t2, \"\\n\"\n    print \"overlap: %s\\n\\n\" % [triTri2D(t1, t2, 0.0, false, true)]\n\n    \n    t1 = [Vector[0,0], Vector[1,0], Vector[0,1]]\n    t2 = [Vector[1,0], Vector[2,0], Vector[1,1]]\n    print \"Triangle: \", t1, \"\\n\"\n    print \"Triangle: \", t2, \"\\n\"\n    print \"overlap: %s\\n\\n\" % [triTri2D(t1, t2, 0.0, false, true)]\n\n    \n    t1 = [Vector[0,0], Vector[1,0], Vector[0,1]]\n    t2 = [Vector[1,0], Vector[2,0], Vector[1,1]]\n    print \"Triangle: \", t1, \"\\n\"\n    print \"Triangle: \", t2, \"\\n\"\n    print \"overlap: %s\\n\\n\" % [triTri2D(t1, t2, 0.0, false, false)]\nend\n\nmain()\n", "target": "import java.util.function.BiFunction;\n\npublic class TriangleOverlap {\n    private static class Pair {\n        double first;\n        double second;\n\n        Pair(double first, double second) {\n            this.first = first;\n            this.second = second;\n        }\n\n        @Override\n        public String toString() {\n            return String.format(\"(%s, %s)\", first, second);\n        }\n    }\n\n    private static class Triangle {\n        Pair p1, p2, p3;\n\n        Triangle(Pair p1, Pair p2, Pair p3) {\n            this.p1 = p1;\n            this.p2 = p2;\n            this.p3 = p3;\n        }\n\n        @Override\n        public String toString() {\n            return String.format(\"Triangle: %s, %s, %s\", p1, p2, p3);\n        }\n    }\n\n    private static double det2D(Triangle t) {\n        Pair p1 = t.p1;\n        Pair p2 = t.p2;\n        Pair p3 = t.p3;\n        return p1.first * (p2.second - p3.second)\n            + p2.first * (p3.second - p1.second)\n            + p3.first * (p1.second - p2.second);\n    }\n\n    private static void checkTriWinding(Triangle t, boolean allowReversed) {\n        double detTri = det2D(t);\n        if (detTri < 0.0) {\n            if (allowReversed) {\n                Pair a = t.p3;\n                t.p3 = t.p2;\n                t.p2 = a;\n            } else throw new RuntimeException(\"Triangle has wrong winding direction\");\n        }\n    }\n\n    private static boolean boundaryCollideChk(Triangle t, double eps) {\n        return det2D(t) < eps;\n    }\n\n    private static boolean boundaryDoesntCollideChk(Triangle t, double eps) {\n        return det2D(t) <= eps;\n    }\n\n    private static boolean triTri2D(Triangle t1, Triangle t2) {\n        return triTri2D(t1, t2, 0.0, false, true);\n    }\n\n    private static boolean triTri2D(Triangle t1, Triangle t2, double eps, boolean allowedReversed) {\n        return triTri2D(t1, t2, eps, allowedReversed, true);\n    }\n\n    private static boolean triTri2D(Triangle t1, Triangle t2, double eps, boolean allowedReversed, boolean onBoundary) {\n        \n        checkTriWinding(t1, allowedReversed);\n        checkTriWinding(t2, allowedReversed);\n        \n        BiFunction<Triangle, Double, Boolean> chkEdge = onBoundary ? TriangleOverlap::boundaryCollideChk : TriangleOverlap::boundaryDoesntCollideChk;\n        Pair[] lp1 = new Pair[]{t1.p1, t1.p2, t1.p3};\n        Pair[] lp2 = new Pair[]{t2.p1, t2.p2, t2.p3};\n\n        \n        for (int i = 0; i < 3; ++i) {\n            int j = (i + 1) % 3;\n            \n            \n            if (chkEdge.apply(new Triangle(lp1[i], lp1[j], lp2[0]), eps) &&\n                chkEdge.apply(new Triangle(lp1[i], lp1[j], lp2[1]), eps) &&\n                chkEdge.apply(new Triangle(lp1[i], lp1[j], lp2[2]), eps)) return false;\n        }\n\n        \n        for (int i = 0; i < 3; ++i) {\n            int j = (i + 1) % 3;\n            \n            \n            if (chkEdge.apply(new Triangle(lp2[i], lp2[j], lp1[0]), eps) &&\n                chkEdge.apply(new Triangle(lp2[i], lp2[j], lp1[1]), eps) &&\n                chkEdge.apply(new Triangle(lp2[i], lp2[j], lp1[2]), eps)) return false;\n        }\n\n        \n        return true;\n    }\n\n    public static void main(String[] args) {\n        Triangle t1 = new Triangle(new Pair(0.0, 0.0), new Pair(5.0, 0.0), new Pair(0.0, 5.0));\n        Triangle t2 = new Triangle(new Pair(0.0, 0.0), new Pair(5.0, 0.0), new Pair(0.0, 6.0));\n        System.out.printf(\"%s and\\n%s\\n\", t1, t2);\n        if (triTri2D(t1, t2)) {\n            System.out.println(\"overlap\");\n        } else {\n            System.out.println(\"do not overlap\");\n        }\n\n        \n        t1 = new Triangle(new Pair(0.0, 0.0), new Pair(0.0, 5.0), new Pair(5.0, 0.0));\n        t2 = t1;\n        System.out.printf(\"\\n%s and\\n%s\\n\", t1, t2);\n        if (triTri2D(t1, t2, 0.0, true)) {\n            System.out.println(\"overlap (reversed)\");\n        } else {\n            System.out.println(\"do not overlap\");\n        }\n\n        t1 = new Triangle(new Pair(0.0, 0.0), new Pair(5.0, 0.0), new Pair(0.0, 5.0));\n        t2 = new Triangle(new Pair(-10.0, 0.0), new Pair(-5.0, 0.0), new Pair(-1.0, 6.0));\n        System.out.printf(\"\\n%s and\\n%s\\n\", t1, t2);\n        if (triTri2D(t1, t2)) {\n            System.out.println(\"overlap\");\n        } else {\n            System.out.println(\"do not overlap\");\n        }\n\n        t1.p3 = new Pair(2.5, 5.0);\n        t2 = new Triangle(new Pair(0.0, 4.0), new Pair(2.5, -1.0), new Pair(5.0, 4.0));\n        System.out.printf(\"\\n%s and\\n%s\\n\", t1, t2);\n        if (triTri2D(t1, t2)) {\n            System.out.println(\"overlap\");\n        } else {\n            System.out.println(\"do not overlap\");\n        }\n\n        t1 = new Triangle(new Pair(0.0, 0.0), new Pair(1.0, 1.0), new Pair(0.0, 2.0));\n        t2 = new Triangle(new Pair(2.0, 1.0), new Pair(3.0, 0.0), new Pair(3.0, 2.0));\n        System.out.printf(\"\\n%s and\\n%s\\n\", t1, t2);\n        if (triTri2D(t1, t2)) {\n            System.out.println(\"overlap\");\n        } else {\n            System.out.println(\"do not overlap\");\n        }\n\n        t2 = new Triangle(new Pair(2.0, 1.0), new Pair(3.0, -2.0), new Pair(3.0, 4.0));\n        System.out.printf(\"\\n%s and\\n%s\\n\", t1, t2);\n        if (triTri2D(t1, t2)) {\n            System.out.println(\"overlap\");\n        } else {\n            System.out.println(\"do not overlap\");\n        }\n\n        t1 = new Triangle(new Pair(0.0, 0.0), new Pair(1.0, 0.0), new Pair(0.0, 1.0));\n        t2 = new Triangle(new Pair(1.0, 0.0), new Pair(2.0, 0.0), new Pair(1.0, 1.1));\n        System.out.printf(\"\\n%s and\\n%s\\n\", t1, t2);\n        System.out.println(\"which have only a single corner in contact, if boundary points collide\");\n        if (triTri2D(t1, t2)) {\n            System.out.println(\"overlap\");\n        } else {\n            System.out.println(\"do not overlap\");\n        }\n\n        System.out.printf(\"\\n%s and\\n%s\\n\", t1, t2);\n        System.out.println(\"which have only a single corner in contact, if boundary points do not collide\");\n        if (triTri2D(t1, t2, 0.0, false, false)) {\n            System.out.println(\"overlap\");\n        } else {\n            System.out.println(\"do not overlap\");\n        }\n    }\n}\n"}
{"id": 12559, "name": "Determine if two triangles overlap", "source": "Translate Ruby to Java: require \"matrix\"\n\ndef det2D(p1, p2, p3)\n    return p1[0] * (p2[1] - p3[1]) + p2[0] * (p3[1] - p1[1]) + p3[0] * (p1[1] - p2[1])\nend\n\ndef checkTriWinding(p1, p2, p3, allowReversed)\n    detTri = det2D(p1, p2, p3)\n    if detTri < 0.0 then\n        if allowReversed then\n            p2[0], p3[0] = p3[0], p2[0]\n            p2[1], p3[1] = p3[1], p2[1]\n        else\n            raise \"Triangle has incorrect winding\"\n        end\n    end\nend\n\ndef boundaryCollideChk(p1, p2, p3, eps)\n    return det2D(p1, p2, p3) < eps\nend\n\ndef boundaryDoesntCollideChk(p1, p2, p3, eps)\n    return det2D(p1, p2, p3) <= eps\nend\n\ndef triTri2D(t1, t2, eps, allowReversed, onBoundary)\n    \n    checkTriWinding(t1[0], t1[1], t1[2], allowReversed)\n    checkTriWinding(t2[0], t2[1], t2[2], allowReversed)\n\n    if onBoundary then\n        \n        chkEdge = -> (p1, p2, p3, eps) { boundaryCollideChk(p1, p2, p3, eps) }\n    else\n        \n        chkEdge = -> (p1, p2, p3, eps) { boundaryDoesntCollideChk(p1, p2, p3, eps) }\n    end\n\n    \n    for i in 0..2 do\n        j = (i + 1) % 3\n\n        \n        \n        if chkEdge.(t1[i], t1[j], t2[0], eps) and chkEdge.(t1[i], t1[j], t2[1], eps) and chkEdge.(t1[i], t1[j], t2[2], eps) then\n            return false\n        end\n    end\n\n    \n    for i in 0..2 do\n        j = (i + 1) % 3\n\n        \n        \n        if chkEdge.(t2[i], t2[j], t1[0], eps) and chkEdge.(t2[i], t2[j], t1[1], eps) and chkEdge.(t2[i], t2[j], t1[2], eps) then\n            return false\n        end\n    end\n\n    \n    return true\nend\n\ndef main\n    t1 = [Vector[0,0], Vector[5,0], Vector[0,5]]\n    t2 = [Vector[0,0], Vector[5,0], Vector[0,6]]\n    print \"Triangle: \", t1, \"\\n\"\n    print \"Triangle: \", t2, \"\\n\"\n    print \"overlap: %s\\n\\n\" % [triTri2D(t1, t2, 0.0, false, true)]\n\n    t1 = [Vector[0,0], Vector[0,5], Vector[5,0]]\n    t2 = [Vector[0,0], Vector[0,5], Vector[5,0]]\n    print \"Triangle: \", t1, \"\\n\"\n    print \"Triangle: \", t2, \"\\n\"\n    print \"overlap: %s\\n\\n\" % [triTri2D(t1, t2, 0.0, true, true)]\n\n    t1 = [Vector[  0,0], Vector[ 5,0], Vector[ 0,5]]\n    t2 = [Vector[-10,0], Vector[-5,0], Vector[-1,6]]\n    print \"Triangle: \", t1, \"\\n\"\n    print \"Triangle: \", t2, \"\\n\"\n    print \"overlap: %s\\n\\n\" % [triTri2D(t1, t2, 0.0, false, true)]\n\n    t1 = [Vector[0,0], Vector[  5, 0], Vector[2.5,5]]\n    t2 = [Vector[0,4], Vector[2.5,-1], Vector[  5,4]]\n    print \"Triangle: \", t1, \"\\n\"\n    print \"Triangle: \", t2, \"\\n\"\n    print \"overlap: %s\\n\\n\" % [triTri2D(t1, t2, 0.0, false, true)]\n\n    t1 = [Vector[0,0], Vector[1,1], Vector[0,2]]\n    t2 = [Vector[2,1], Vector[3,0], Vector[3,2]]\n    print \"Triangle: \", t1, \"\\n\"\n    print \"Triangle: \", t2, \"\\n\"\n    print \"overlap: %s\\n\\n\" % [triTri2D(t1, t2, 0.0, false, true)]\n\n    t1 = [Vector[0,0], Vector[1, 1], Vector[0,2]]\n    t2 = [Vector[2,1], Vector[3,-2], Vector[3,4]]\n    print \"Triangle: \", t1, \"\\n\"\n    print \"Triangle: \", t2, \"\\n\"\n    print \"overlap: %s\\n\\n\" % [triTri2D(t1, t2, 0.0, false, true)]\n\n    \n    t1 = [Vector[0,0], Vector[1,0], Vector[0,1]]\n    t2 = [Vector[1,0], Vector[2,0], Vector[1,1]]\n    print \"Triangle: \", t1, \"\\n\"\n    print \"Triangle: \", t2, \"\\n\"\n    print \"overlap: %s\\n\\n\" % [triTri2D(t1, t2, 0.0, false, true)]\n\n    \n    t1 = [Vector[0,0], Vector[1,0], Vector[0,1]]\n    t2 = [Vector[1,0], Vector[2,0], Vector[1,1]]\n    print \"Triangle: \", t1, \"\\n\"\n    print \"Triangle: \", t2, \"\\n\"\n    print \"overlap: %s\\n\\n\" % [triTri2D(t1, t2, 0.0, false, false)]\nend\n\nmain()\n", "target": "import java.util.function.BiFunction;\n\npublic class TriangleOverlap {\n    private static class Pair {\n        double first;\n        double second;\n\n        Pair(double first, double second) {\n            this.first = first;\n            this.second = second;\n        }\n\n        @Override\n        public String toString() {\n            return String.format(\"(%s, %s)\", first, second);\n        }\n    }\n\n    private static class Triangle {\n        Pair p1, p2, p3;\n\n        Triangle(Pair p1, Pair p2, Pair p3) {\n            this.p1 = p1;\n            this.p2 = p2;\n            this.p3 = p3;\n        }\n\n        @Override\n        public String toString() {\n            return String.format(\"Triangle: %s, %s, %s\", p1, p2, p3);\n        }\n    }\n\n    private static double det2D(Triangle t) {\n        Pair p1 = t.p1;\n        Pair p2 = t.p2;\n        Pair p3 = t.p3;\n        return p1.first * (p2.second - p3.second)\n            + p2.first * (p3.second - p1.second)\n            + p3.first * (p1.second - p2.second);\n    }\n\n    private static void checkTriWinding(Triangle t, boolean allowReversed) {\n        double detTri = det2D(t);\n        if (detTri < 0.0) {\n            if (allowReversed) {\n                Pair a = t.p3;\n                t.p3 = t.p2;\n                t.p2 = a;\n            } else throw new RuntimeException(\"Triangle has wrong winding direction\");\n        }\n    }\n\n    private static boolean boundaryCollideChk(Triangle t, double eps) {\n        return det2D(t) < eps;\n    }\n\n    private static boolean boundaryDoesntCollideChk(Triangle t, double eps) {\n        return det2D(t) <= eps;\n    }\n\n    private static boolean triTri2D(Triangle t1, Triangle t2) {\n        return triTri2D(t1, t2, 0.0, false, true);\n    }\n\n    private static boolean triTri2D(Triangle t1, Triangle t2, double eps, boolean allowedReversed) {\n        return triTri2D(t1, t2, eps, allowedReversed, true);\n    }\n\n    private static boolean triTri2D(Triangle t1, Triangle t2, double eps, boolean allowedReversed, boolean onBoundary) {\n        \n        checkTriWinding(t1, allowedReversed);\n        checkTriWinding(t2, allowedReversed);\n        \n        BiFunction<Triangle, Double, Boolean> chkEdge = onBoundary ? TriangleOverlap::boundaryCollideChk : TriangleOverlap::boundaryDoesntCollideChk;\n        Pair[] lp1 = new Pair[]{t1.p1, t1.p2, t1.p3};\n        Pair[] lp2 = new Pair[]{t2.p1, t2.p2, t2.p3};\n\n        \n        for (int i = 0; i < 3; ++i) {\n            int j = (i + 1) % 3;\n            \n            \n            if (chkEdge.apply(new Triangle(lp1[i], lp1[j], lp2[0]), eps) &&\n                chkEdge.apply(new Triangle(lp1[i], lp1[j], lp2[1]), eps) &&\n                chkEdge.apply(new Triangle(lp1[i], lp1[j], lp2[2]), eps)) return false;\n        }\n\n        \n        for (int i = 0; i < 3; ++i) {\n            int j = (i + 1) % 3;\n            \n            \n            if (chkEdge.apply(new Triangle(lp2[i], lp2[j], lp1[0]), eps) &&\n                chkEdge.apply(new Triangle(lp2[i], lp2[j], lp1[1]), eps) &&\n                chkEdge.apply(new Triangle(lp2[i], lp2[j], lp1[2]), eps)) return false;\n        }\n\n        \n        return true;\n    }\n\n    public static void main(String[] args) {\n        Triangle t1 = new Triangle(new Pair(0.0, 0.0), new Pair(5.0, 0.0), new Pair(0.0, 5.0));\n        Triangle t2 = new Triangle(new Pair(0.0, 0.0), new Pair(5.0, 0.0), new Pair(0.0, 6.0));\n        System.out.printf(\"%s and\\n%s\\n\", t1, t2);\n        if (triTri2D(t1, t2)) {\n            System.out.println(\"overlap\");\n        } else {\n            System.out.println(\"do not overlap\");\n        }\n\n        \n        t1 = new Triangle(new Pair(0.0, 0.0), new Pair(0.0, 5.0), new Pair(5.0, 0.0));\n        t2 = t1;\n        System.out.printf(\"\\n%s and\\n%s\\n\", t1, t2);\n        if (triTri2D(t1, t2, 0.0, true)) {\n            System.out.println(\"overlap (reversed)\");\n        } else {\n            System.out.println(\"do not overlap\");\n        }\n\n        t1 = new Triangle(new Pair(0.0, 0.0), new Pair(5.0, 0.0), new Pair(0.0, 5.0));\n        t2 = new Triangle(new Pair(-10.0, 0.0), new Pair(-5.0, 0.0), new Pair(-1.0, 6.0));\n        System.out.printf(\"\\n%s and\\n%s\\n\", t1, t2);\n        if (triTri2D(t1, t2)) {\n            System.out.println(\"overlap\");\n        } else {\n            System.out.println(\"do not overlap\");\n        }\n\n        t1.p3 = new Pair(2.5, 5.0);\n        t2 = new Triangle(new Pair(0.0, 4.0), new Pair(2.5, -1.0), new Pair(5.0, 4.0));\n        System.out.printf(\"\\n%s and\\n%s\\n\", t1, t2);\n        if (triTri2D(t1, t2)) {\n            System.out.println(\"overlap\");\n        } else {\n            System.out.println(\"do not overlap\");\n        }\n\n        t1 = new Triangle(new Pair(0.0, 0.0), new Pair(1.0, 1.0), new Pair(0.0, 2.0));\n        t2 = new Triangle(new Pair(2.0, 1.0), new Pair(3.0, 0.0), new Pair(3.0, 2.0));\n        System.out.printf(\"\\n%s and\\n%s\\n\", t1, t2);\n        if (triTri2D(t1, t2)) {\n            System.out.println(\"overlap\");\n        } else {\n            System.out.println(\"do not overlap\");\n        }\n\n        t2 = new Triangle(new Pair(2.0, 1.0), new Pair(3.0, -2.0), new Pair(3.0, 4.0));\n        System.out.printf(\"\\n%s and\\n%s\\n\", t1, t2);\n        if (triTri2D(t1, t2)) {\n            System.out.println(\"overlap\");\n        } else {\n            System.out.println(\"do not overlap\");\n        }\n\n        t1 = new Triangle(new Pair(0.0, 0.0), new Pair(1.0, 0.0), new Pair(0.0, 1.0));\n        t2 = new Triangle(new Pair(1.0, 0.0), new Pair(2.0, 0.0), new Pair(1.0, 1.1));\n        System.out.printf(\"\\n%s and\\n%s\\n\", t1, t2);\n        System.out.println(\"which have only a single corner in contact, if boundary points collide\");\n        if (triTri2D(t1, t2)) {\n            System.out.println(\"overlap\");\n        } else {\n            System.out.println(\"do not overlap\");\n        }\n\n        System.out.printf(\"\\n%s and\\n%s\\n\", t1, t2);\n        System.out.println(\"which have only a single corner in contact, if boundary points do not collide\");\n        if (triTri2D(t1, t2, 0.0, false, false)) {\n            System.out.println(\"overlap\");\n        } else {\n            System.out.println(\"do not overlap\");\n        }\n    }\n}\n"}
{"id": 12560, "name": "Determine if two triangles overlap", "source": "Translate Ruby to Python: require \"matrix\"\n\ndef det2D(p1, p2, p3)\n    return p1[0] * (p2[1] - p3[1]) + p2[0] * (p3[1] - p1[1]) + p3[0] * (p1[1] - p2[1])\nend\n\ndef checkTriWinding(p1, p2, p3, allowReversed)\n    detTri = det2D(p1, p2, p3)\n    if detTri < 0.0 then\n        if allowReversed then\n            p2[0], p3[0] = p3[0], p2[0]\n            p2[1], p3[1] = p3[1], p2[1]\n        else\n            raise \"Triangle has incorrect winding\"\n        end\n    end\nend\n\ndef boundaryCollideChk(p1, p2, p3, eps)\n    return det2D(p1, p2, p3) < eps\nend\n\ndef boundaryDoesntCollideChk(p1, p2, p3, eps)\n    return det2D(p1, p2, p3) <= eps\nend\n\ndef triTri2D(t1, t2, eps, allowReversed, onBoundary)\n    \n    checkTriWinding(t1[0], t1[1], t1[2], allowReversed)\n    checkTriWinding(t2[0], t2[1], t2[2], allowReversed)\n\n    if onBoundary then\n        \n        chkEdge = -> (p1, p2, p3, eps) { boundaryCollideChk(p1, p2, p3, eps) }\n    else\n        \n        chkEdge = -> (p1, p2, p3, eps) { boundaryDoesntCollideChk(p1, p2, p3, eps) }\n    end\n\n    \n    for i in 0..2 do\n        j = (i + 1) % 3\n\n        \n        \n        if chkEdge.(t1[i], t1[j], t2[0], eps) and chkEdge.(t1[i], t1[j], t2[1], eps) and chkEdge.(t1[i], t1[j], t2[2], eps) then\n            return false\n        end\n    end\n\n    \n    for i in 0..2 do\n        j = (i + 1) % 3\n\n        \n        \n        if chkEdge.(t2[i], t2[j], t1[0], eps) and chkEdge.(t2[i], t2[j], t1[1], eps) and chkEdge.(t2[i], t2[j], t1[2], eps) then\n            return false\n        end\n    end\n\n    \n    return true\nend\n\ndef main\n    t1 = [Vector[0,0], Vector[5,0], Vector[0,5]]\n    t2 = [Vector[0,0], Vector[5,0], Vector[0,6]]\n    print \"Triangle: \", t1, \"\\n\"\n    print \"Triangle: \", t2, \"\\n\"\n    print \"overlap: %s\\n\\n\" % [triTri2D(t1, t2, 0.0, false, true)]\n\n    t1 = [Vector[0,0], Vector[0,5], Vector[5,0]]\n    t2 = [Vector[0,0], Vector[0,5], Vector[5,0]]\n    print \"Triangle: \", t1, \"\\n\"\n    print \"Triangle: \", t2, \"\\n\"\n    print \"overlap: %s\\n\\n\" % [triTri2D(t1, t2, 0.0, true, true)]\n\n    t1 = [Vector[  0,0], Vector[ 5,0], Vector[ 0,5]]\n    t2 = [Vector[-10,0], Vector[-5,0], Vector[-1,6]]\n    print \"Triangle: \", t1, \"\\n\"\n    print \"Triangle: \", t2, \"\\n\"\n    print \"overlap: %s\\n\\n\" % [triTri2D(t1, t2, 0.0, false, true)]\n\n    t1 = [Vector[0,0], Vector[  5, 0], Vector[2.5,5]]\n    t2 = [Vector[0,4], Vector[2.5,-1], Vector[  5,4]]\n    print \"Triangle: \", t1, \"\\n\"\n    print \"Triangle: \", t2, \"\\n\"\n    print \"overlap: %s\\n\\n\" % [triTri2D(t1, t2, 0.0, false, true)]\n\n    t1 = [Vector[0,0], Vector[1,1], Vector[0,2]]\n    t2 = [Vector[2,1], Vector[3,0], Vector[3,2]]\n    print \"Triangle: \", t1, \"\\n\"\n    print \"Triangle: \", t2, \"\\n\"\n    print \"overlap: %s\\n\\n\" % [triTri2D(t1, t2, 0.0, false, true)]\n\n    t1 = [Vector[0,0], Vector[1, 1], Vector[0,2]]\n    t2 = [Vector[2,1], Vector[3,-2], Vector[3,4]]\n    print \"Triangle: \", t1, \"\\n\"\n    print \"Triangle: \", t2, \"\\n\"\n    print \"overlap: %s\\n\\n\" % [triTri2D(t1, t2, 0.0, false, true)]\n\n    \n    t1 = [Vector[0,0], Vector[1,0], Vector[0,1]]\n    t2 = [Vector[1,0], Vector[2,0], Vector[1,1]]\n    print \"Triangle: \", t1, \"\\n\"\n    print \"Triangle: \", t2, \"\\n\"\n    print \"overlap: %s\\n\\n\" % [triTri2D(t1, t2, 0.0, false, true)]\n\n    \n    t1 = [Vector[0,0], Vector[1,0], Vector[0,1]]\n    t2 = [Vector[1,0], Vector[2,0], Vector[1,1]]\n    print \"Triangle: \", t1, \"\\n\"\n    print \"Triangle: \", t2, \"\\n\"\n    print \"overlap: %s\\n\\n\" % [triTri2D(t1, t2, 0.0, false, false)]\nend\n\nmain()\n", "target": "from __future__ import print_function\nimport numpy as np\n\ndef CheckTriWinding(tri, allowReversed):\n\ttrisq = np.ones((3,3))\n\ttrisq[:,0:2] = np.array(tri)\n\tdetTri = np.linalg.det(trisq)\n\tif detTri < 0.0:\n\t\tif allowReversed:\n\t\t\ta = trisq[2,:].copy()\n\t\t\ttrisq[2,:] = trisq[1,:]\n\t\t\ttrisq[1,:] = a\n\t\telse: raise ValueError(\"triangle has wrong winding direction\")\n\treturn trisq\n\ndef TriTri2D(t1, t2, eps = 0.0, allowReversed = False, onBoundary = True):\n\t\n\tt1s = CheckTriWinding(t1, allowReversed)\n\tt2s = CheckTriWinding(t2, allowReversed)\n\n\tif onBoundary:\n\t\t\n\t\tchkEdge = lambda x: np.linalg.det(x) < eps\n\telse:\n\t\t\n\t\tchkEdge = lambda x: np.linalg.det(x) <= eps\n\n\t\n\tfor i in range(3):\n\t\tedge = np.roll(t1s, i, axis=0)[:2,:]\n\n\t\t\n\t\t\n\t\tif (chkEdge(np.vstack((edge, t2s[0]))) and\n\t\t\tchkEdge(np.vstack((edge, t2s[1]))) and  \n\t\t\tchkEdge(np.vstack((edge, t2s[2])))):\n\t\t\treturn False\n\n\t\n\tfor i in range(3):\n\t\tedge = np.roll(t2s, i, axis=0)[:2,:]\n\n\t\t\n\t\t\n\t\tif (chkEdge(np.vstack((edge, t1s[0]))) and\n\t\t\tchkEdge(np.vstack((edge, t1s[1]))) and  \n\t\t\tchkEdge(np.vstack((edge, t1s[2])))):\n\t\t\treturn False\n\n\t\n\treturn True\n\nif __name__==\"__main__\":\n\tt1 = [[0,0],[5,0],[0,5]]\n\tt2 = [[0,0],[5,0],[0,6]]\n\tprint (TriTri2D(t1, t2), True)\n\n\tt1 = [[0,0],[0,5],[5,0]]\n\tt2 = [[0,0],[0,6],[5,0]]\n\tprint (TriTri2D(t1, t2, allowReversed = True), True)\n\n\tt1 = [[0,0],[5,0],[0,5]]\n\tt2 = [[-10,0],[-5,0],[-1,6]]\n\tprint (TriTri2D(t1, t2), False)\n\n\tt1 = [[0,0],[5,0],[2.5,5]]\n\tt2 = [[0,4],[2.5,-1],[5,4]]\n\tprint (TriTri2D(t1, t2), True)\n\n\tt1 = [[0,0],[1,1],[0,2]]\n\tt2 = [[2,1],[3,0],[3,2]]\n\tprint (TriTri2D(t1, t2), False)\n\n\tt1 = [[0,0],[1,1],[0,2]]\n\tt2 = [[2,1],[3,-2],[3,4]]\n\tprint (TriTri2D(t1, t2), False)\n\n\t\n\tt1 = [[0,0],[1,0],[0,1]]\n\tt2 = [[1,0],[2,0],[1,1]]\n\tprint (TriTri2D(t1, t2, onBoundary = True), True)\n\n\t\n\tt1 = [[0,0],[1,0],[0,1]]\n\tt2 = [[1,0],[2,0],[1,1]]\n\tprint (TriTri2D(t1, t2, onBoundary = False), False)\n"}
{"id": 12561, "name": "Determine if two triangles overlap", "source": "Translate Ruby to Python: require \"matrix\"\n\ndef det2D(p1, p2, p3)\n    return p1[0] * (p2[1] - p3[1]) + p2[0] * (p3[1] - p1[1]) + p3[0] * (p1[1] - p2[1])\nend\n\ndef checkTriWinding(p1, p2, p3, allowReversed)\n    detTri = det2D(p1, p2, p3)\n    if detTri < 0.0 then\n        if allowReversed then\n            p2[0], p3[0] = p3[0], p2[0]\n            p2[1], p3[1] = p3[1], p2[1]\n        else\n            raise \"Triangle has incorrect winding\"\n        end\n    end\nend\n\ndef boundaryCollideChk(p1, p2, p3, eps)\n    return det2D(p1, p2, p3) < eps\nend\n\ndef boundaryDoesntCollideChk(p1, p2, p3, eps)\n    return det2D(p1, p2, p3) <= eps\nend\n\ndef triTri2D(t1, t2, eps, allowReversed, onBoundary)\n    \n    checkTriWinding(t1[0], t1[1], t1[2], allowReversed)\n    checkTriWinding(t2[0], t2[1], t2[2], allowReversed)\n\n    if onBoundary then\n        \n        chkEdge = -> (p1, p2, p3, eps) { boundaryCollideChk(p1, p2, p3, eps) }\n    else\n        \n        chkEdge = -> (p1, p2, p3, eps) { boundaryDoesntCollideChk(p1, p2, p3, eps) }\n    end\n\n    \n    for i in 0..2 do\n        j = (i + 1) % 3\n\n        \n        \n        if chkEdge.(t1[i], t1[j], t2[0], eps) and chkEdge.(t1[i], t1[j], t2[1], eps) and chkEdge.(t1[i], t1[j], t2[2], eps) then\n            return false\n        end\n    end\n\n    \n    for i in 0..2 do\n        j = (i + 1) % 3\n\n        \n        \n        if chkEdge.(t2[i], t2[j], t1[0], eps) and chkEdge.(t2[i], t2[j], t1[1], eps) and chkEdge.(t2[i], t2[j], t1[2], eps) then\n            return false\n        end\n    end\n\n    \n    return true\nend\n\ndef main\n    t1 = [Vector[0,0], Vector[5,0], Vector[0,5]]\n    t2 = [Vector[0,0], Vector[5,0], Vector[0,6]]\n    print \"Triangle: \", t1, \"\\n\"\n    print \"Triangle: \", t2, \"\\n\"\n    print \"overlap: %s\\n\\n\" % [triTri2D(t1, t2, 0.0, false, true)]\n\n    t1 = [Vector[0,0], Vector[0,5], Vector[5,0]]\n    t2 = [Vector[0,0], Vector[0,5], Vector[5,0]]\n    print \"Triangle: \", t1, \"\\n\"\n    print \"Triangle: \", t2, \"\\n\"\n    print \"overlap: %s\\n\\n\" % [triTri2D(t1, t2, 0.0, true, true)]\n\n    t1 = [Vector[  0,0], Vector[ 5,0], Vector[ 0,5]]\n    t2 = [Vector[-10,0], Vector[-5,0], Vector[-1,6]]\n    print \"Triangle: \", t1, \"\\n\"\n    print \"Triangle: \", t2, \"\\n\"\n    print \"overlap: %s\\n\\n\" % [triTri2D(t1, t2, 0.0, false, true)]\n\n    t1 = [Vector[0,0], Vector[  5, 0], Vector[2.5,5]]\n    t2 = [Vector[0,4], Vector[2.5,-1], Vector[  5,4]]\n    print \"Triangle: \", t1, \"\\n\"\n    print \"Triangle: \", t2, \"\\n\"\n    print \"overlap: %s\\n\\n\" % [triTri2D(t1, t2, 0.0, false, true)]\n\n    t1 = [Vector[0,0], Vector[1,1], Vector[0,2]]\n    t2 = [Vector[2,1], Vector[3,0], Vector[3,2]]\n    print \"Triangle: \", t1, \"\\n\"\n    print \"Triangle: \", t2, \"\\n\"\n    print \"overlap: %s\\n\\n\" % [triTri2D(t1, t2, 0.0, false, true)]\n\n    t1 = [Vector[0,0], Vector[1, 1], Vector[0,2]]\n    t2 = [Vector[2,1], Vector[3,-2], Vector[3,4]]\n    print \"Triangle: \", t1, \"\\n\"\n    print \"Triangle: \", t2, \"\\n\"\n    print \"overlap: %s\\n\\n\" % [triTri2D(t1, t2, 0.0, false, true)]\n\n    \n    t1 = [Vector[0,0], Vector[1,0], Vector[0,1]]\n    t2 = [Vector[1,0], Vector[2,0], Vector[1,1]]\n    print \"Triangle: \", t1, \"\\n\"\n    print \"Triangle: \", t2, \"\\n\"\n    print \"overlap: %s\\n\\n\" % [triTri2D(t1, t2, 0.0, false, true)]\n\n    \n    t1 = [Vector[0,0], Vector[1,0], Vector[0,1]]\n    t2 = [Vector[1,0], Vector[2,0], Vector[1,1]]\n    print \"Triangle: \", t1, \"\\n\"\n    print \"Triangle: \", t2, \"\\n\"\n    print \"overlap: %s\\n\\n\" % [triTri2D(t1, t2, 0.0, false, false)]\nend\n\nmain()\n", "target": "from __future__ import print_function\nimport numpy as np\n\ndef CheckTriWinding(tri, allowReversed):\n\ttrisq = np.ones((3,3))\n\ttrisq[:,0:2] = np.array(tri)\n\tdetTri = np.linalg.det(trisq)\n\tif detTri < 0.0:\n\t\tif allowReversed:\n\t\t\ta = trisq[2,:].copy()\n\t\t\ttrisq[2,:] = trisq[1,:]\n\t\t\ttrisq[1,:] = a\n\t\telse: raise ValueError(\"triangle has wrong winding direction\")\n\treturn trisq\n\ndef TriTri2D(t1, t2, eps = 0.0, allowReversed = False, onBoundary = True):\n\t\n\tt1s = CheckTriWinding(t1, allowReversed)\n\tt2s = CheckTriWinding(t2, allowReversed)\n\n\tif onBoundary:\n\t\t\n\t\tchkEdge = lambda x: np.linalg.det(x) < eps\n\telse:\n\t\t\n\t\tchkEdge = lambda x: np.linalg.det(x) <= eps\n\n\t\n\tfor i in range(3):\n\t\tedge = np.roll(t1s, i, axis=0)[:2,:]\n\n\t\t\n\t\t\n\t\tif (chkEdge(np.vstack((edge, t2s[0]))) and\n\t\t\tchkEdge(np.vstack((edge, t2s[1]))) and  \n\t\t\tchkEdge(np.vstack((edge, t2s[2])))):\n\t\t\treturn False\n\n\t\n\tfor i in range(3):\n\t\tedge = np.roll(t2s, i, axis=0)[:2,:]\n\n\t\t\n\t\t\n\t\tif (chkEdge(np.vstack((edge, t1s[0]))) and\n\t\t\tchkEdge(np.vstack((edge, t1s[1]))) and  \n\t\t\tchkEdge(np.vstack((edge, t1s[2])))):\n\t\t\treturn False\n\n\t\n\treturn True\n\nif __name__==\"__main__\":\n\tt1 = [[0,0],[5,0],[0,5]]\n\tt2 = [[0,0],[5,0],[0,6]]\n\tprint (TriTri2D(t1, t2), True)\n\n\tt1 = [[0,0],[0,5],[5,0]]\n\tt2 = [[0,0],[0,6],[5,0]]\n\tprint (TriTri2D(t1, t2, allowReversed = True), True)\n\n\tt1 = [[0,0],[5,0],[0,5]]\n\tt2 = [[-10,0],[-5,0],[-1,6]]\n\tprint (TriTri2D(t1, t2), False)\n\n\tt1 = [[0,0],[5,0],[2.5,5]]\n\tt2 = [[0,4],[2.5,-1],[5,4]]\n\tprint (TriTri2D(t1, t2), True)\n\n\tt1 = [[0,0],[1,1],[0,2]]\n\tt2 = [[2,1],[3,0],[3,2]]\n\tprint (TriTri2D(t1, t2), False)\n\n\tt1 = [[0,0],[1,1],[0,2]]\n\tt2 = [[2,1],[3,-2],[3,4]]\n\tprint (TriTri2D(t1, t2), False)\n\n\t\n\tt1 = [[0,0],[1,0],[0,1]]\n\tt2 = [[1,0],[2,0],[1,1]]\n\tprint (TriTri2D(t1, t2, onBoundary = True), True)\n\n\t\n\tt1 = [[0,0],[1,0],[0,1]]\n\tt2 = [[1,0],[2,0],[1,1]]\n\tprint (TriTri2D(t1, t2, onBoundary = False), False)\n"}
{"id": 12732, "name": "Sudoku", "source": "Translate Ruby to C#: GRID_SIZE = 9\n\ndef isNumberInRow(board, number, row)\n  board[row].includes?(number)\nend\ndef isNumberInColumn(board, number, column)\n  board.any?{|row| row[column] == number }\nend\ndef isNumberInBox(board, number, row, column)\n  localBoxRow = row - row % 3\n  localBoxColumn = column - column % 3\n  (localBoxRow...(localBoxRow+3)).each do |i|\n    (localBoxColumn...(localBoxColumn+3)).each do |j|\n      return true if board[i][j] == number\n    end\n  end\n  false\nend\n\ndef isValidPlacement(board, number, row, column)\n  return !isNumberInRow(board, number, row) &&\n  !isNumberInColumn(board, number, column) &&\n  !isNumberInBox(board, number, row, column)\nend\n\ndef solveBoard(board)\n  board.each_with_index do |row, i|\n    row.each_with_index do |cell, j|\n      if(cell == 0)\n        (1..GRID_SIZE).each do |n|\n          if(isValidPlacement(board,n,i,j))\n            board[i][j]=n\n            if(solveBoard(board))\n              return true\n            else\n              board[i][j]=0\n            end\n          end\n        end\n        return false\n      end\n    end\n  end\n  return true\nend\n\ndef printBoard(board)\n  board.each_with_index do |row, i|\n    row.each_with_index do |cell, j|\n      print cell\n      print '|' if j == 2 || j == 5\n      print '\\n' if j == 8\n    end\n    print \"-\"*11 + '\\n' if i == 2 || i == 5\n  end\n  print '\\n'\nend\n\nboard = [\n  [7, 0, 2, 0, 5, 0, 6, 0, 0],\n  [0, 0, 0, 0, 0, 3, 0, 0, 0],\n  [1, 0, 0, 0, 0, 9, 5, 0, 0],\n  [8, 0, 0, 0, 0, 0, 0, 9, 0],\n  [0, 4, 3, 0, 0, 0, 7, 5, 0],\n  [0, 9, 0, 0, 0, 0, 0, 0, 8],\n  [0, 0, 9, 7, 0, 0, 0, 0, 5],\n  [0, 0, 0, 2, 0, 0, 0, 0, 0],\n  [0, 0, 7, 0, 4, 0, 2, 0, 3]]\n\nprintBoard(board)\nif(solveBoard(board))\n  printBoard(board)\nend\n", "target": "using System;\n\nclass SudokuSolver\n{\n    private int[] grid;\n\n    public SudokuSolver(String s)\n    {\n        grid = new int[81];\n        for (int i = 0; i < s.Length; i++)\n        {\n            grid[i] = int.Parse(s[i].ToString());\n        }\n    }\n\n    public void solve()\n    {\n        try\n        {\n            placeNumber(0);\n            Console.WriteLine(\"Unsolvable!\");\n        }\n        catch (Exception ex)\n        {\n            Console.WriteLine(ex.Message);\n            Console.WriteLine(this);\n        }\n    }\n\n    public void placeNumber(int pos)\n    {\n        if (pos == 81)\n        {\n            throw new Exception(\"Finished!\");\n        }\n        if (grid[pos] > 0)\n        {\n            placeNumber(pos + 1);\n            return;\n        }\n        for (int n = 1; n <= 9; n++)\n        {\n            if (checkValidity(n, pos % 9, pos / 9))\n            {\n                grid[pos] = n;\n                placeNumber(pos + 1);\n                grid[pos] = 0;\n            }\n        }\n    }\n\n    public bool checkValidity(int val, int x, int y)\n    {\n        for (int i = 0; i < 9; i++)\n        {\n            if (grid[y * 9 + i] == val || grid[i * 9 + x] == val)\n                return false;\n        }\n        int startX = (x / 3) * 3;\n        int startY = (y / 3) * 3;\n        for (int i = startY; i < startY + 3; i++)\n        {\n            for (int j = startX; j < startX + 3; j++)\n            {\n                if (grid[i * 9 + j] == val)\n                    return false;\n            }\n        }\n        return true;\n    }\n\n    public override string ToString()\n    {\n        string sb = \"\";\n        for (int i = 0; i < 9; i++)\n        {\n            for (int j = 0; j < 9; j++)\n            {\n                sb += (grid[i * 9 + j] + \" \");\n                if (j == 2 || j == 5)\n                    sb += (\"| \");\n            }\n            sb += ('\\n');\n            if (i == 2 || i == 5)\n                sb += (\"------+-------+------\\n\");\n        }\n        return sb;\n    }\n\n    public static void Main(String[] args)\n    {\n        new SudokuSolver(\"850002400\" +\n                         \"720000009\" +\n                         \"004000000\" +\n                         \"000107002\" +\n                         \"305000900\" +\n                         \"040000000\" +\n                         \"000080070\" +\n                         \"017000000\" +\n                         \"000036040\").solve();\n        Console.Read();\n    }\n}\n"}
{"id": 12734, "name": "Sudoku", "source": "Translate Ruby to Java: GRID_SIZE = 9\n\ndef isNumberInRow(board, number, row)\n  board[row].includes?(number)\nend\ndef isNumberInColumn(board, number, column)\n  board.any?{|row| row[column] == number }\nend\ndef isNumberInBox(board, number, row, column)\n  localBoxRow = row - row % 3\n  localBoxColumn = column - column % 3\n  (localBoxRow...(localBoxRow+3)).each do |i|\n    (localBoxColumn...(localBoxColumn+3)).each do |j|\n      return true if board[i][j] == number\n    end\n  end\n  false\nend\n\ndef isValidPlacement(board, number, row, column)\n  return !isNumberInRow(board, number, row) &&\n  !isNumberInColumn(board, number, column) &&\n  !isNumberInBox(board, number, row, column)\nend\n\ndef solveBoard(board)\n  board.each_with_index do |row, i|\n    row.each_with_index do |cell, j|\n      if(cell == 0)\n        (1..GRID_SIZE).each do |n|\n          if(isValidPlacement(board,n,i,j))\n            board[i][j]=n\n            if(solveBoard(board))\n              return true\n            else\n              board[i][j]=0\n            end\n          end\n        end\n        return false\n      end\n    end\n  end\n  return true\nend\n\ndef printBoard(board)\n  board.each_with_index do |row, i|\n    row.each_with_index do |cell, j|\n      print cell\n      print '|' if j == 2 || j == 5\n      print '\\n' if j == 8\n    end\n    print \"-\"*11 + '\\n' if i == 2 || i == 5\n  end\n  print '\\n'\nend\n\nboard = [\n  [7, 0, 2, 0, 5, 0, 6, 0, 0],\n  [0, 0, 0, 0, 0, 3, 0, 0, 0],\n  [1, 0, 0, 0, 0, 9, 5, 0, 0],\n  [8, 0, 0, 0, 0, 0, 0, 9, 0],\n  [0, 4, 3, 0, 0, 0, 7, 5, 0],\n  [0, 9, 0, 0, 0, 0, 0, 0, 8],\n  [0, 0, 9, 7, 0, 0, 0, 0, 5],\n  [0, 0, 0, 2, 0, 0, 0, 0, 0],\n  [0, 0, 7, 0, 4, 0, 2, 0, 3]]\n\nprintBoard(board)\nif(solveBoard(board))\n  printBoard(board)\nend\n", "target": "public class Sudoku\n{\n    private int mBoard[][];\n    private int mBoardSize;\n    private int mBoxSize;\n    private boolean mRowSubset[][];\n    private boolean mColSubset[][];\n    private boolean mBoxSubset[][];\n \n    public Sudoku(int board[][]) {\n        mBoard = board;\n        mBoardSize = mBoard.length;\n        mBoxSize = (int)Math.sqrt(mBoardSize);\n        initSubsets();\n    }\n \n    public void initSubsets() {\n        mRowSubset = new boolean[mBoardSize][mBoardSize];\n        mColSubset = new boolean[mBoardSize][mBoardSize];\n        mBoxSubset = new boolean[mBoardSize][mBoardSize];\n        for(int i = 0; i < mBoard.length; i++) {\n            for(int j = 0; j < mBoard.length; j++) {\n                int value = mBoard[i][j];\n                if(value != 0) {\n                    setSubsetValue(i, j, value, true);\n                }\n            }\n        }\n    }\n \n    private void setSubsetValue(int i, int j, int value, boolean present) {\n        mRowSubset[i][value - 1] = present;\n        mColSubset[j][value - 1] = present;\n        mBoxSubset[computeBoxNo(i, j)][value - 1] = present;\n    }\n \n    public boolean solve() {\n        return solve(0, 0);\n    }\n \n    public boolean solve(int i, int j) {\n        if(i == mBoardSize) {\n            i = 0;\n            if(++j == mBoardSize) {\n                return true;\n            }\n        }\n        if(mBoard[i][j] != 0) {\n            return solve(i + 1, j);\n        }\n        for(int value = 1; value <= mBoardSize; value++) {\n            if(isValid(i, j, value)) {\n                mBoard[i][j] = value;\n                setSubsetValue(i, j, value, true);\n                if(solve(i + 1, j)) {\n                    return true;\n                }\n                setSubsetValue(i, j, value, false);\n            }\n        }\n \n        mBoard[i][j] = 0;\n        return false;\n    }\n \n    private boolean isValid(int i, int j, int val) {\n        val--;\n        boolean isPresent = mRowSubset[i][val] || mColSubset[j][val] || mBoxSubset[computeBoxNo(i, j)][val];\n        return !isPresent;\n    }\n \n    private int computeBoxNo(int i, int j) {\n        int boxRow = i / mBoxSize;\n        int boxCol = j / mBoxSize;\n        return boxRow * mBoxSize + boxCol;\n    }\n \n    public void print() {\n        for(int i = 0; i < mBoardSize; i++) {\n            if(i % mBoxSize == 0) {\n                System.out.println(\" -----------------------\");\n            }\n            for(int j = 0; j < mBoardSize; j++) {\n                if(j % mBoxSize == 0) {\n                    System.out.print(\"| \");\n                }\n                System.out.print(mBoard[i][j] != 0 ? ((Object) (Integer.valueOf(mBoard[i][j]))) : \"-\");\n                System.out.print(' ');\n            }\n \n            System.out.println(\"|\");\n        }\n \n        System.out.println(\" -----------------------\");\n    }\n\n    public static void main(String[] args) {\n        int[][] board = { \n            {8, 5, 0, 0, 0, 2, 4, 0, 0},\n            {7, 2, 0, 0, 0, 0, 0, 0, 9},\n            {0, 0, 4, 0, 0, 0, 0, 0, 0},\n            {0, 0, 0, 1, 0, 7, 0, 0, 2},\n            {3, 0, 5, 0, 0, 0, 9, 0, 0},\n            {0, 4, 0, 0, 0, 0, 0, 0, 0},\n            {0, 0, 0, 0, 8, 0, 0, 7, 0},\n            {0, 1, 7, 0, 0, 0, 0, 0, 0},\n            {0, 0, 0, 0, 3, 6, 0, 4, 0}\n        };\n        Sudoku s = new Sudoku(board);\n        System.out.print(\"Starting grid:\\n\");\n        s.print();        \n        if (s.solve()) {\n            System.out.print(\"\\nSolution:\\n\");\n            s.print();\n        } else {\n            System.out.println(\"\\nUnsolvable!\");\n        }\n    }\n}\n"}
{"id": 12735, "name": "Sudoku", "source": "Translate Ruby to Python: GRID_SIZE = 9\n\ndef isNumberInRow(board, number, row)\n  board[row].includes?(number)\nend\ndef isNumberInColumn(board, number, column)\n  board.any?{|row| row[column] == number }\nend\ndef isNumberInBox(board, number, row, column)\n  localBoxRow = row - row % 3\n  localBoxColumn = column - column % 3\n  (localBoxRow...(localBoxRow+3)).each do |i|\n    (localBoxColumn...(localBoxColumn+3)).each do |j|\n      return true if board[i][j] == number\n    end\n  end\n  false\nend\n\ndef isValidPlacement(board, number, row, column)\n  return !isNumberInRow(board, number, row) &&\n  !isNumberInColumn(board, number, column) &&\n  !isNumberInBox(board, number, row, column)\nend\n\ndef solveBoard(board)\n  board.each_with_index do |row, i|\n    row.each_with_index do |cell, j|\n      if(cell == 0)\n        (1..GRID_SIZE).each do |n|\n          if(isValidPlacement(board,n,i,j))\n            board[i][j]=n\n            if(solveBoard(board))\n              return true\n            else\n              board[i][j]=0\n            end\n          end\n        end\n        return false\n      end\n    end\n  end\n  return true\nend\n\ndef printBoard(board)\n  board.each_with_index do |row, i|\n    row.each_with_index do |cell, j|\n      print cell\n      print '|' if j == 2 || j == 5\n      print '\\n' if j == 8\n    end\n    print \"-\"*11 + '\\n' if i == 2 || i == 5\n  end\n  print '\\n'\nend\n\nboard = [\n  [7, 0, 2, 0, 5, 0, 6, 0, 0],\n  [0, 0, 0, 0, 0, 3, 0, 0, 0],\n  [1, 0, 0, 0, 0, 9, 5, 0, 0],\n  [8, 0, 0, 0, 0, 0, 0, 9, 0],\n  [0, 4, 3, 0, 0, 0, 7, 5, 0],\n  [0, 9, 0, 0, 0, 0, 0, 0, 8],\n  [0, 0, 9, 7, 0, 0, 0, 0, 5],\n  [0, 0, 0, 2, 0, 0, 0, 0, 0],\n  [0, 0, 7, 0, 4, 0, 2, 0, 3]]\n\nprintBoard(board)\nif(solveBoard(board))\n  printBoard(board)\nend\n", "target": "def initiate():\n    box.append([0, 1, 2, 9, 10, 11, 18, 19, 20])\n    box.append([3, 4, 5, 12, 13, 14, 21, 22, 23])\n    box.append([6, 7, 8, 15, 16, 17, 24, 25, 26])\n    box.append([27, 28, 29, 36, 37, 38, 45, 46, 47])\n    box.append([30, 31, 32, 39, 40, 41, 48, 49, 50])\n    box.append([33, 34, 35, 42, 43, 44, 51, 52, 53])\n    box.append([54, 55, 56, 63, 64, 65, 72, 73, 74])\n    box.append([57, 58, 59, 66, 67, 68, 75, 76, 77])\n    box.append([60, 61, 62, 69, 70, 71, 78, 79, 80])\n    for i in range(0, 81, 9):\n        row.append(range(i, i+9))\n    for i in range(9):\n        column.append(range(i, 80+i, 9))\n\ndef valid(n, pos):\n    current_row = pos/9\n    current_col = pos%9\n    current_box = (current_row/3)*3 + (current_col/3)\n    for i in row[current_row]:\n        if (grid[i] == n):\n            return False\n    for i in column[current_col]:\n        if (grid[i] == n):\n            return False\n    for i in box[current_box]:\n        if (grid[i] == n):\n            return False\n    return True\n\ndef solve():\n    i = 0\n    proceed = 1\n    while(i < 81):\n        if given[i]:\n            if proceed:\n                    i += 1\n            else:\n                i -= 1\n        else:\n            n = grid[i]\n            prev = grid[i]\n            while(n < 9):\n              if (n < 9):\n                  n += 1\n              if valid(n, i):\n                  grid[i] = n\n                  proceed = 1\n                  break\n            if (grid[i] == prev):\n               grid[i] = 0\n               proceed = 0\n            if proceed:\n               i += 1\n            else:\n               i -=1\n\ndef inputs():\n    nextt = 'T'\n    number = 0\n    pos = 0\n    while(not(nextt == 'N' or nextt == 'n')):\n        print \"Enter the position:\",\n        pos = int(raw_input())\n        given[pos - 1] = True\n        print \"Enter the numerical:\",\n        number = int(raw_input())\n        grid[pos - 1] = number\n        print \"Do you want to enter another given?(Y, for yes: N, for no)\"\n        nextt = raw_input()\n\n\ngrid = [0]*81\ngiven = [False]*81\nbox = []\nrow = []\ncolumn = []\ninitiate()\ninputs()\nsolve()\nfor i in range(9):\n    print grid[i*9:i*9+9]\nraw_input()\n"}
{"id": 12979, "name": "Hello world_Newline omission", "source": "Translate Ruby to C#: print \"Goodbye, World!\"\n", "target": "using System;\n\nclass Program\n{\n    static void Main(string[] args)\n    {\n        \n        Console.WriteLine(\"Goodbye, World!\");\n\n        \n        Console.Write(\"Goodbye, World!\");\n    }\n}\n"}
{"id": 12981, "name": "Hello world_Newline omission", "source": "Translate Ruby to Java: print \"Goodbye, World!\"\n", "target": "public class HelloWorld\n{\n public static void main(String[] args)\n {\n  System.out.print(\"Goodbye, World!\");\n }\n}\n"}
{"id": 13420, "name": "Vector products", "source": "Translate Ruby to C#: class Vector\n  property x, y, z\n  \n  def initialize(@x : Int64, @y : Int64, @z : Int64) end\n      \n  def dot_product(other : Vector)\n    (self.x * other.x) + (self.y * other.y) + (self.z * other.z)\n  end\n  \n  def cross_product(other : Vector)\n    Vector.new(self.y * other.z - self.z * other.y,\n               self.z * other.x - self.x * other.z,\n               self.x * other.y - self.y * other.x)\n  end\n \n  def scalar_triple_product(b : Vector, c : Vector)\n    self.dot_product(b.cross_product(c))\n  end                                                                \n \n  def vector_triple_product(b : Vector, c : Vector)\n    self.cross_product(b.cross_product(c))\n  end\n  \n  def to_s\n    \"(\n  end\nend\n\na = Vector.new(3, 4, 5)\nb = Vector.new(4, 3, 5)\nc = Vector.new(-5, -12, -13)\n \nputs \"a = \nputs \"b = \nputs \"c = \nputs \"a dot b = \nputs \"a cross b = \nputs \"a dot (b cross c) = \nputs \"a cross (b cross c) = \n", "target": "using System;\nusing System.Windows.Media.Media3D;\n\nclass VectorProducts\n{\n    static double ScalarTripleProduct(Vector3D a, Vector3D b, Vector3D c)\n    {\n        return Vector3D.DotProduct(a, Vector3D.CrossProduct(b, c));\n    }\n\n    static Vector3D VectorTripleProduct(Vector3D a, Vector3D b, Vector3D c)\n    {\n        return Vector3D.CrossProduct(a, Vector3D.CrossProduct(b, c));\n    }\n\n    static void Main()\n    {\n        var a = new Vector3D(3, 4, 5);\n        var b = new Vector3D(4, 3, 5);\n        var c = new Vector3D(-5, -12, -13);\n\n        Console.WriteLine(Vector3D.DotProduct(a, b));\n        Console.WriteLine(Vector3D.CrossProduct(a, b));\n        Console.WriteLine(ScalarTripleProduct(a, b, c));\n        Console.WriteLine(VectorTripleProduct(a, b, c));\n    }\n}\n"}
{"id": 13421, "name": "Vector products", "source": "Translate Ruby to C#: class Vector\n  property x, y, z\n  \n  def initialize(@x : Int64, @y : Int64, @z : Int64) end\n      \n  def dot_product(other : Vector)\n    (self.x * other.x) + (self.y * other.y) + (self.z * other.z)\n  end\n  \n  def cross_product(other : Vector)\n    Vector.new(self.y * other.z - self.z * other.y,\n               self.z * other.x - self.x * other.z,\n               self.x * other.y - self.y * other.x)\n  end\n \n  def scalar_triple_product(b : Vector, c : Vector)\n    self.dot_product(b.cross_product(c))\n  end                                                                \n \n  def vector_triple_product(b : Vector, c : Vector)\n    self.cross_product(b.cross_product(c))\n  end\n  \n  def to_s\n    \"(\n  end\nend\n\na = Vector.new(3, 4, 5)\nb = Vector.new(4, 3, 5)\nc = Vector.new(-5, -12, -13)\n \nputs \"a = \nputs \"b = \nputs \"c = \nputs \"a dot b = \nputs \"a cross b = \nputs \"a dot (b cross c) = \nputs \"a cross (b cross c) = \n", "target": "using System;\nusing System.Windows.Media.Media3D;\n\nclass VectorProducts\n{\n    static double ScalarTripleProduct(Vector3D a, Vector3D b, Vector3D c)\n    {\n        return Vector3D.DotProduct(a, Vector3D.CrossProduct(b, c));\n    }\n\n    static Vector3D VectorTripleProduct(Vector3D a, Vector3D b, Vector3D c)\n    {\n        return Vector3D.CrossProduct(a, Vector3D.CrossProduct(b, c));\n    }\n\n    static void Main()\n    {\n        var a = new Vector3D(3, 4, 5);\n        var b = new Vector3D(4, 3, 5);\n        var c = new Vector3D(-5, -12, -13);\n\n        Console.WriteLine(Vector3D.DotProduct(a, b));\n        Console.WriteLine(Vector3D.CrossProduct(a, b));\n        Console.WriteLine(ScalarTripleProduct(a, b, c));\n        Console.WriteLine(VectorTripleProduct(a, b, c));\n    }\n}\n"}
{"id": 13424, "name": "Vector products", "source": "Translate Ruby to Java: class Vector\n  property x, y, z\n  \n  def initialize(@x : Int64, @y : Int64, @z : Int64) end\n      \n  def dot_product(other : Vector)\n    (self.x * other.x) + (self.y * other.y) + (self.z * other.z)\n  end\n  \n  def cross_product(other : Vector)\n    Vector.new(self.y * other.z - self.z * other.y,\n               self.z * other.x - self.x * other.z,\n               self.x * other.y - self.y * other.x)\n  end\n \n  def scalar_triple_product(b : Vector, c : Vector)\n    self.dot_product(b.cross_product(c))\n  end                                                                \n \n  def vector_triple_product(b : Vector, c : Vector)\n    self.cross_product(b.cross_product(c))\n  end\n  \n  def to_s\n    \"(\n  end\nend\n\na = Vector.new(3, 4, 5)\nb = Vector.new(4, 3, 5)\nc = Vector.new(-5, -12, -13)\n \nputs \"a = \nputs \"b = \nputs \"c = \nputs \"a dot b = \nputs \"a cross b = \nputs \"a dot (b cross c) = \nputs \"a cross (b cross c) = \n", "target": "public class VectorProds{\n    public static class Vector3D<T extends Number>{\n        private T a, b, c;\n\n        public Vector3D(T a, T b, T c){\n            this.a = a;\n            this.b = b;\n            this.c = c;\n        }\n\n        public double dot(Vector3D<?> vec){\n            return (a.doubleValue() * vec.a.doubleValue() +\n                    b.doubleValue() * vec.b.doubleValue() +\n                    c.doubleValue() * vec.c.doubleValue());\n        }\n\n        public Vector3D<Double> cross(Vector3D<?> vec){\n            Double newA = b.doubleValue()*vec.c.doubleValue() - c.doubleValue()*vec.b.doubleValue();\n            Double newB = c.doubleValue()*vec.a.doubleValue() - a.doubleValue()*vec.c.doubleValue();\n            Double newC = a.doubleValue()*vec.b.doubleValue() - b.doubleValue()*vec.a.doubleValue();\n            return new Vector3D<Double>(newA, newB, newC);\n        }\n\n        public double scalTrip(Vector3D<?> vecB, Vector3D<?> vecC){\n            return this.dot(vecB.cross(vecC));\n        }\n\n        public Vector3D<Double> vecTrip(Vector3D<?> vecB, Vector3D<?> vecC){\n            return this.cross(vecB.cross(vecC));\n        }\n\n        @Override\n        public String toString(){\n            return \"<\" + a.toString() + \", \" + b.toString() + \", \" + c.toString() + \">\";\n        }\n    }\n\n    public static void main(String[] args){\n        Vector3D<Integer> a = new Vector3D<Integer>(3, 4, 5);\n        Vector3D<Integer> b = new Vector3D<Integer>(4, 3, 5);\n        Vector3D<Integer> c = new Vector3D<Integer>(-5, -12, -13);\n\n        System.out.println(a.dot(b));\n        System.out.println(a.cross(b));\n        System.out.println(a.scalTrip(b, c));\n        System.out.println(a.vecTrip(b, c));\n    }\n}\n"}
{"id": 13425, "name": "Vector products", "source": "Translate Ruby to Java: class Vector\n  property x, y, z\n  \n  def initialize(@x : Int64, @y : Int64, @z : Int64) end\n      \n  def dot_product(other : Vector)\n    (self.x * other.x) + (self.y * other.y) + (self.z * other.z)\n  end\n  \n  def cross_product(other : Vector)\n    Vector.new(self.y * other.z - self.z * other.y,\n               self.z * other.x - self.x * other.z,\n               self.x * other.y - self.y * other.x)\n  end\n \n  def scalar_triple_product(b : Vector, c : Vector)\n    self.dot_product(b.cross_product(c))\n  end                                                                \n \n  def vector_triple_product(b : Vector, c : Vector)\n    self.cross_product(b.cross_product(c))\n  end\n  \n  def to_s\n    \"(\n  end\nend\n\na = Vector.new(3, 4, 5)\nb = Vector.new(4, 3, 5)\nc = Vector.new(-5, -12, -13)\n \nputs \"a = \nputs \"b = \nputs \"c = \nputs \"a dot b = \nputs \"a cross b = \nputs \"a dot (b cross c) = \nputs \"a cross (b cross c) = \n", "target": "public class VectorProds{\n    public static class Vector3D<T extends Number>{\n        private T a, b, c;\n\n        public Vector3D(T a, T b, T c){\n            this.a = a;\n            this.b = b;\n            this.c = c;\n        }\n\n        public double dot(Vector3D<?> vec){\n            return (a.doubleValue() * vec.a.doubleValue() +\n                    b.doubleValue() * vec.b.doubleValue() +\n                    c.doubleValue() * vec.c.doubleValue());\n        }\n\n        public Vector3D<Double> cross(Vector3D<?> vec){\n            Double newA = b.doubleValue()*vec.c.doubleValue() - c.doubleValue()*vec.b.doubleValue();\n            Double newB = c.doubleValue()*vec.a.doubleValue() - a.doubleValue()*vec.c.doubleValue();\n            Double newC = a.doubleValue()*vec.b.doubleValue() - b.doubleValue()*vec.a.doubleValue();\n            return new Vector3D<Double>(newA, newB, newC);\n        }\n\n        public double scalTrip(Vector3D<?> vecB, Vector3D<?> vecC){\n            return this.dot(vecB.cross(vecC));\n        }\n\n        public Vector3D<Double> vecTrip(Vector3D<?> vecB, Vector3D<?> vecC){\n            return this.cross(vecB.cross(vecC));\n        }\n\n        @Override\n        public String toString(){\n            return \"<\" + a.toString() + \", \" + b.toString() + \", \" + c.toString() + \">\";\n        }\n    }\n\n    public static void main(String[] args){\n        Vector3D<Integer> a = new Vector3D<Integer>(3, 4, 5);\n        Vector3D<Integer> b = new Vector3D<Integer>(4, 3, 5);\n        Vector3D<Integer> c = new Vector3D<Integer>(-5, -12, -13);\n\n        System.out.println(a.dot(b));\n        System.out.println(a.cross(b));\n        System.out.println(a.scalTrip(b, c));\n        System.out.println(a.vecTrip(b, c));\n    }\n}\n"}
{"id": 13426, "name": "Vector products", "source": "Translate Ruby to Python: class Vector\n  property x, y, z\n  \n  def initialize(@x : Int64, @y : Int64, @z : Int64) end\n      \n  def dot_product(other : Vector)\n    (self.x * other.x) + (self.y * other.y) + (self.z * other.z)\n  end\n  \n  def cross_product(other : Vector)\n    Vector.new(self.y * other.z - self.z * other.y,\n               self.z * other.x - self.x * other.z,\n               self.x * other.y - self.y * other.x)\n  end\n \n  def scalar_triple_product(b : Vector, c : Vector)\n    self.dot_product(b.cross_product(c))\n  end                                                                \n \n  def vector_triple_product(b : Vector, c : Vector)\n    self.cross_product(b.cross_product(c))\n  end\n  \n  def to_s\n    \"(\n  end\nend\n\na = Vector.new(3, 4, 5)\nb = Vector.new(4, 3, 5)\nc = Vector.new(-5, -12, -13)\n \nputs \"a = \nputs \"b = \nputs \"c = \nputs \"a dot b = \nputs \"a cross b = \nputs \"a dot (b cross c) = \nputs \"a cross (b cross c) = \n", "target": "def crossp(a, b):\n    \n    assert len(a) == len(b) == 3, 'For 3D vectors only'\n    a1, a2, a3 = a\n    b1, b2, b3 = b\n    return (a2*b3 - a3*b2, a3*b1 - a1*b3, a1*b2 - a2*b1)\n \ndef dotp(a,b):\n    \n    assert len(a) == len(b), 'Vector sizes must match'\n    return sum(aterm * bterm for aterm,bterm in zip(a, b))\n \ndef scalartriplep(a, b, c):\n    \n    return dotp(a, crossp(b, c))\n \ndef vectortriplep(a, b, c):\n    \n    return crossp(a, crossp(b, c))\n \nif __name__ == '__main__':\n    a, b, c = (3, 4, 5), (4, 3, 5), (-5, -12, -13)\n    print(\"a = %r;  b = %r;  c = %r\" % (a, b, c))\n    print(\"a . b = %r\" % dotp(a,b))\n    print(\"a x b = %r\"  % (crossp(a,b),))\n    print(\"a . (b x c) = %r\" % scalartriplep(a, b, c))\n    print(\"a x (b x c) = %r\" % (vectortriplep(a, b, c),))\n"}
{"id": 13427, "name": "Vector products", "source": "Translate Ruby to Python: class Vector\n  property x, y, z\n  \n  def initialize(@x : Int64, @y : Int64, @z : Int64) end\n      \n  def dot_product(other : Vector)\n    (self.x * other.x) + (self.y * other.y) + (self.z * other.z)\n  end\n  \n  def cross_product(other : Vector)\n    Vector.new(self.y * other.z - self.z * other.y,\n               self.z * other.x - self.x * other.z,\n               self.x * other.y - self.y * other.x)\n  end\n \n  def scalar_triple_product(b : Vector, c : Vector)\n    self.dot_product(b.cross_product(c))\n  end                                                                \n \n  def vector_triple_product(b : Vector, c : Vector)\n    self.cross_product(b.cross_product(c))\n  end\n  \n  def to_s\n    \"(\n  end\nend\n\na = Vector.new(3, 4, 5)\nb = Vector.new(4, 3, 5)\nc = Vector.new(-5, -12, -13)\n \nputs \"a = \nputs \"b = \nputs \"c = \nputs \"a dot b = \nputs \"a cross b = \nputs \"a dot (b cross c) = \nputs \"a cross (b cross c) = \n", "target": "def crossp(a, b):\n    \n    assert len(a) == len(b) == 3, 'For 3D vectors only'\n    a1, a2, a3 = a\n    b1, b2, b3 = b\n    return (a2*b3 - a3*b2, a3*b1 - a1*b3, a1*b2 - a2*b1)\n \ndef dotp(a,b):\n    \n    assert len(a) == len(b), 'Vector sizes must match'\n    return sum(aterm * bterm for aterm,bterm in zip(a, b))\n \ndef scalartriplep(a, b, c):\n    \n    return dotp(a, crossp(b, c))\n \ndef vectortriplep(a, b, c):\n    \n    return crossp(a, crossp(b, c))\n \nif __name__ == '__main__':\n    a, b, c = (3, 4, 5), (4, 3, 5), (-5, -12, -13)\n    print(\"a = %r;  b = %r;  c = %r\" % (a, b, c))\n    print(\"a . b = %r\" % dotp(a,b))\n    print(\"a x b = %r\"  % (crossp(a,b),))\n    print(\"a . (b x c) = %r\" % scalartriplep(a, b, c))\n    print(\"a x (b x c) = %r\" % (vectortriplep(a, b, c),))\n"}
{"id": 13713, "name": "Hello world_Standard error", "source": "Translate Ruby to C#: STDERR.puts \"Goodbye, World!\"\n", "target": "static class StdErr\n{\n    static void Main(string[] args)\n    {\n        Console.Error.WriteLine(\"Goodbye, World!\");\n    }\n}\n"}
{"id": 13715, "name": "Hello world_Standard error", "source": "Translate Ruby to Java: STDERR.puts \"Goodbye, World!\"\n", "target": "public class Err{\n   public static void main(String[] args){\n      System.err.println(\"Goodbye, World!\");\n   }\n}\n"}
{"id": 13922, "name": "SEDOLs", "source": "Translate Ruby to C#: Sedol_char = \"0123456789BCDFGHJKLMNPQRSTVWXYZ\"\nSedolweight = [1,3,1,7,3,9]\n\ndef char2value(c)\n  raise ArgumentError, \"Invalid char \n  c.to_i(36)\nend\n \ndef checksum(sedol)\n  raise ArgumentError, \"Invalid length\" unless sedol.size == Sedolweight.size\n  sum = sedol.chars.zip(Sedolweight).sum{|ch, weight| char2value(ch) * weight }\n  ((10 - (sum % 10)) % 10).to_s\nend\n \ndata = %w(710889\n          B0YBKJ\n          406566\n          B0YBLH\n          228276\n          B0YBKL\n          557910\n          B0YBKR\n          585284\n          B0YBKT\n          B00030\n          C0000\n          1234567\n          00000A)\n \ndata.each do |sedol|\n  print \"%-8s \" % sedol\n  begin\n    puts sedol + checksum(sedol)\n  rescue => e\n    p e\n  end\nend\n", "target": "static int[] sedol_weights = { 1, 3, 1, 7, 3, 9 };\nstatic int sedolChecksum(string sedol)\n{\n    int len = sedol.Length;\n    int sum = 0;\n\n    if (len == 7) \n        return (int)sedol[6];\n\n    if ((len > 7) || (len < 6) || System.Text.RegularExpressions.Regex.IsMatch(sedol, \"[AEIOUaeiou]+\")) \n        return -1;\n\n    for (int i = 0; i < 6; i++)\n    {\n        if (Char.IsDigit(sedol[i]))\n            sum += (((int)sedol[i] - 48) * sedol_weights[i]);\n\n        else if (Char.IsLetter(sedol[i]))\n            sum += (((int)Char.ToUpper(sedol[i]) - 55) * sedol_weights[i]);\n\n        else\n            return -1;\n\n    }\n\n    return (10 - (sum % 10)) % 10;\n}\n"}
{"id": 13924, "name": "SEDOLs", "source": "Translate Ruby to Java: Sedol_char = \"0123456789BCDFGHJKLMNPQRSTVWXYZ\"\nSedolweight = [1,3,1,7,3,9]\n\ndef char2value(c)\n  raise ArgumentError, \"Invalid char \n  c.to_i(36)\nend\n \ndef checksum(sedol)\n  raise ArgumentError, \"Invalid length\" unless sedol.size == Sedolweight.size\n  sum = sedol.chars.zip(Sedolweight).sum{|ch, weight| char2value(ch) * weight }\n  ((10 - (sum % 10)) % 10).to_s\nend\n \ndata = %w(710889\n          B0YBKJ\n          406566\n          B0YBLH\n          228276\n          B0YBKL\n          557910\n          B0YBKR\n          585284\n          B0YBKT\n          B00030\n          C0000\n          1234567\n          00000A)\n \ndata.each do |sedol|\n  print \"%-8s \" % sedol\n  begin\n    puts sedol + checksum(sedol)\n  rescue => e\n    p e\n  end\nend\n", "target": "import java.util.Scanner;\n\npublic class SEDOL{\n\tpublic static void main(String[] args){\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(sc.hasNext()){\n\t\t\tString sedol = sc.next();\n\t\t\tSystem.out.println(sedol + getSedolCheckDigit(sedol));\n\t\t}\n\t}\n\t\n\tprivate static final int[] mult = {1, 3, 1, 7, 3, 9};\n\t\n\tpublic static int getSedolCheckDigit(String str){\n\t    if(!validateSedol(str)){\n\t    \tSystem.err.println(\"SEDOL strings must contain six characters with no vowels.\");\n\t    \treturn -1;\n\t    }\n\t    str = str.toUpperCase();\n\t    int total = 0;\n\t    for(int i = 0;i < 6; i++){\n\t        char s = str.charAt(i);\n\t        total += Character.digit(s, 36) * mult[i];\n\t    }\n\t    return (10 - (total % 10)) % 10;\n\t}\n\n\tpublic static boolean validateSedol(String str){\n\t\treturn (str.length() == 6) && !str.toUpperCase().matches(\".*?[AEIOU].*?\");\n\t}\n}\n"}
{"id": 13925, "name": "SEDOLs", "source": "Translate Ruby to Python: Sedol_char = \"0123456789BCDFGHJKLMNPQRSTVWXYZ\"\nSedolweight = [1,3,1,7,3,9]\n\ndef char2value(c)\n  raise ArgumentError, \"Invalid char \n  c.to_i(36)\nend\n \ndef checksum(sedol)\n  raise ArgumentError, \"Invalid length\" unless sedol.size == Sedolweight.size\n  sum = sedol.chars.zip(Sedolweight).sum{|ch, weight| char2value(ch) * weight }\n  ((10 - (sum % 10)) % 10).to_s\nend\n \ndata = %w(710889\n          B0YBKJ\n          406566\n          B0YBLH\n          228276\n          B0YBKL\n          557910\n          B0YBKR\n          585284\n          B0YBKT\n          B00030\n          C0000\n          1234567\n          00000A)\n \ndata.each do |sedol|\n  print \"%-8s \" % sedol\n  begin\n    puts sedol + checksum(sedol)\n  rescue => e\n    p e\n  end\nend\n", "target": "def char2value(c):\n  assert c not in 'AEIOU', \"No vowels\"\n  return int(c, 36)\n\nsedolweight = [1,3,1,7,3,9]\n\ndef checksum(sedol):\n    tmp = sum(map(lambda ch, weight: char2value(ch) * weight,\n                  sedol, sedolweight)\n               )\n    return str((10 - (tmp % 10)) % 10)\n\nfor sedol in .split():\n    print sedol + checksum(sedol)\n"}
{"id": 14273, "name": "Determine if a string is squeezable", "source": "Translate Ruby to C#: strings = [\"\",\n        '\"If I were two-faced, would I be wearing this one?\" --- Abraham Lincoln ',\n        \"..1111111111111111111111111111111111111111111111111111111111111117777888\",\n        \"I never give 'em hell, I just tell the truth, and they think it's hell. \",\n        \"                                                   ---  Harry S Truman  \",\n        \"\ud83d\ude0d\ud83d\ude00\ud83d\ude4c\ud83d\udc83\ud83d\ude0d\ud83d\ude0d\ud83d\ude0d\ud83d\ude4c\",]\nsqueeze_these = [\"\", \"-\", \"7\", \".\", \" -r\", \"\ud83d\ude0d\"]\n\nstrings.zip(squeeze_these).each do |str, st|\n  puts \"original:     \u00ab\u00ab\u00ab\n  st.chars.each do |c|\n    ssq = str.squeeze(c)\n    puts \"\n  end\n  puts\nend\n", "target": "using System;\nusing static System.Linq.Enumerable;\n\npublic class Program\n{\n    static void Main()\n    {\n        SqueezeAndPrint(\"\", ' ');\n        SqueezeAndPrint(\"\\\"If I were two-faced, would I be wearing this one?\\\" --- Abraham Lincoln \", '-');\n        SqueezeAndPrint(\"..1111111111111111111111111111111111111111111111111111111111111117777888\", '7');\n        SqueezeAndPrint(\"I never give 'em hell, I just tell the truth, and they think it's hell. \", '.');\n        string s = \"                                                    --- Harry S Truman  \";\n        SqueezeAndPrint(s, ' ');\n        SqueezeAndPrint(s, '-');\n        SqueezeAndPrint(s, 'r');\n    }\n\n    static void SqueezeAndPrint(string s, char c) {\n        Console.WriteLine($\"squeeze: '{c}'\");\n        Console.WriteLine($\"old: {s.Length} \u00ab\u00ab\u00ab{s}\u00bb\u00bb\u00bb\");\n        s = Squeeze(s, c);\n        Console.WriteLine($\"new: {s.Length} \u00ab\u00ab\u00ab{s}\u00bb\u00bb\u00bb\");\n    }\n\n    static string Squeeze(string s, char c) => string.IsNullOrEmpty(s) ? \"\" :\n        s[0] + new string(Range(1, s.Length - 1).Where(i => s[i] != c || s[i] != s[i - 1]).Select(i => s[i]).ToArray());\n}\n"}
{"id": 14274, "name": "Determine if a string is squeezable", "source": "Translate Ruby to C#: strings = [\"\",\n        '\"If I were two-faced, would I be wearing this one?\" --- Abraham Lincoln ',\n        \"..1111111111111111111111111111111111111111111111111111111111111117777888\",\n        \"I never give 'em hell, I just tell the truth, and they think it's hell. \",\n        \"                                                   ---  Harry S Truman  \",\n        \"\ud83d\ude0d\ud83d\ude00\ud83d\ude4c\ud83d\udc83\ud83d\ude0d\ud83d\ude0d\ud83d\ude0d\ud83d\ude4c\",]\nsqueeze_these = [\"\", \"-\", \"7\", \".\", \" -r\", \"\ud83d\ude0d\"]\n\nstrings.zip(squeeze_these).each do |str, st|\n  puts \"original:     \u00ab\u00ab\u00ab\n  st.chars.each do |c|\n    ssq = str.squeeze(c)\n    puts \"\n  end\n  puts\nend\n", "target": "using System;\nusing static System.Linq.Enumerable;\n\npublic class Program\n{\n    static void Main()\n    {\n        SqueezeAndPrint(\"\", ' ');\n        SqueezeAndPrint(\"\\\"If I were two-faced, would I be wearing this one?\\\" --- Abraham Lincoln \", '-');\n        SqueezeAndPrint(\"..1111111111111111111111111111111111111111111111111111111111111117777888\", '7');\n        SqueezeAndPrint(\"I never give 'em hell, I just tell the truth, and they think it's hell. \", '.');\n        string s = \"                                                    --- Harry S Truman  \";\n        SqueezeAndPrint(s, ' ');\n        SqueezeAndPrint(s, '-');\n        SqueezeAndPrint(s, 'r');\n    }\n\n    static void SqueezeAndPrint(string s, char c) {\n        Console.WriteLine($\"squeeze: '{c}'\");\n        Console.WriteLine($\"old: {s.Length} \u00ab\u00ab\u00ab{s}\u00bb\u00bb\u00bb\");\n        s = Squeeze(s, c);\n        Console.WriteLine($\"new: {s.Length} \u00ab\u00ab\u00ab{s}\u00bb\u00bb\u00bb\");\n    }\n\n    static string Squeeze(string s, char c) => string.IsNullOrEmpty(s) ? \"\" :\n        s[0] + new string(Range(1, s.Length - 1).Where(i => s[i] != c || s[i] != s[i - 1]).Select(i => s[i]).ToArray());\n}\n"}
{"id": 14277, "name": "Determine if a string is squeezable", "source": "Translate Ruby to Java: strings = [\"\",\n        '\"If I were two-faced, would I be wearing this one?\" --- Abraham Lincoln ',\n        \"..1111111111111111111111111111111111111111111111111111111111111117777888\",\n        \"I never give 'em hell, I just tell the truth, and they think it's hell. \",\n        \"                                                   ---  Harry S Truman  \",\n        \"\ud83d\ude0d\ud83d\ude00\ud83d\ude4c\ud83d\udc83\ud83d\ude0d\ud83d\ude0d\ud83d\ude0d\ud83d\ude4c\",]\nsqueeze_these = [\"\", \"-\", \"7\", \".\", \" -r\", \"\ud83d\ude0d\"]\n\nstrings.zip(squeeze_these).each do |str, st|\n  puts \"original:     \u00ab\u00ab\u00ab\n  st.chars.each do |c|\n    ssq = str.squeeze(c)\n    puts \"\n  end\n  puts\nend\n", "target": "\n\npublic class StringSqueezable {\n\n    public static void main(String[] args) {\n        String[] testStrings = new String[] {\n                \"\", \n                \"\\\"If I were two-faced, would I be wearing this one?\\\" --- Abraham Lincoln \", \n                \"..1111111111111111111111111111111111111111111111111111111111111117777888\", \n                \"I never give 'em hell, I just tell the truth, and they think it's hell. \", \n                \"                                                    --- Harry S Truman  \",\n                \"122333444455555666666777777788888888999999999\",\n                \"The better the 4-wheel drive, the further you'll be from help when ya get stuck!\",\n                \"headmistressship\"};\n\n        String[] testChar = new String[] {\n                \" \", \n                \"-\", \n                \"7\", \n                \".\", \n                \" -r\",\n                \"5\",\n                \"e\",\n                \"s\"};\n        for ( int testNum = 0 ; testNum < testStrings.length ; testNum++ ) {\n            String s = testStrings[testNum];\n            for ( char c : testChar[testNum].toCharArray() ) {\n                String result = squeeze(s, c);\n                System.out.printf(\"use: '%c'%nold:  %2d <<<%s>>>%nnew:  %2d <<<%s>>>%n%n\", c, s.length(), s, result.length(), result);\n            }\n        }\n    }\n    \n    private static String squeeze(String in, char include) {\n        StringBuilder sb = new StringBuilder();\n        for ( int i = 0 ; i < in.length() ; i++ ) {\n            if ( i == 0 || in.charAt(i-1) != in.charAt(i) || (in.charAt(i-1) == in.charAt(i) && in.charAt(i) != include)) {\n                sb.append(in.charAt(i));\n            }\n        }\n        return sb.toString();\n    }\n\n}\n"}
{"id": 14278, "name": "Determine if a string is squeezable", "source": "Translate Ruby to Java: strings = [\"\",\n        '\"If I were two-faced, would I be wearing this one?\" --- Abraham Lincoln ',\n        \"..1111111111111111111111111111111111111111111111111111111111111117777888\",\n        \"I never give 'em hell, I just tell the truth, and they think it's hell. \",\n        \"                                                   ---  Harry S Truman  \",\n        \"\ud83d\ude0d\ud83d\ude00\ud83d\ude4c\ud83d\udc83\ud83d\ude0d\ud83d\ude0d\ud83d\ude0d\ud83d\ude4c\",]\nsqueeze_these = [\"\", \"-\", \"7\", \".\", \" -r\", \"\ud83d\ude0d\"]\n\nstrings.zip(squeeze_these).each do |str, st|\n  puts \"original:     \u00ab\u00ab\u00ab\n  st.chars.each do |c|\n    ssq = str.squeeze(c)\n    puts \"\n  end\n  puts\nend\n", "target": "\n\npublic class StringSqueezable {\n\n    public static void main(String[] args) {\n        String[] testStrings = new String[] {\n                \"\", \n                \"\\\"If I were two-faced, would I be wearing this one?\\\" --- Abraham Lincoln \", \n                \"..1111111111111111111111111111111111111111111111111111111111111117777888\", \n                \"I never give 'em hell, I just tell the truth, and they think it's hell. \", \n                \"                                                    --- Harry S Truman  \",\n                \"122333444455555666666777777788888888999999999\",\n                \"The better the 4-wheel drive, the further you'll be from help when ya get stuck!\",\n                \"headmistressship\"};\n\n        String[] testChar = new String[] {\n                \" \", \n                \"-\", \n                \"7\", \n                \".\", \n                \" -r\",\n                \"5\",\n                \"e\",\n                \"s\"};\n        for ( int testNum = 0 ; testNum < testStrings.length ; testNum++ ) {\n            String s = testStrings[testNum];\n            for ( char c : testChar[testNum].toCharArray() ) {\n                String result = squeeze(s, c);\n                System.out.printf(\"use: '%c'%nold:  %2d <<<%s>>>%nnew:  %2d <<<%s>>>%n%n\", c, s.length(), s, result.length(), result);\n            }\n        }\n    }\n    \n    private static String squeeze(String in, char include) {\n        StringBuilder sb = new StringBuilder();\n        for ( int i = 0 ; i < in.length() ; i++ ) {\n            if ( i == 0 || in.charAt(i-1) != in.charAt(i) || (in.charAt(i-1) == in.charAt(i) && in.charAt(i) != include)) {\n                sb.append(in.charAt(i));\n            }\n        }\n        return sb.toString();\n    }\n\n}\n"}
{"id": 14279, "name": "Determine if a string is squeezable", "source": "Translate Ruby to Python: strings = [\"\",\n        '\"If I were two-faced, would I be wearing this one?\" --- Abraham Lincoln ',\n        \"..1111111111111111111111111111111111111111111111111111111111111117777888\",\n        \"I never give 'em hell, I just tell the truth, and they think it's hell. \",\n        \"                                                   ---  Harry S Truman  \",\n        \"\ud83d\ude0d\ud83d\ude00\ud83d\ude4c\ud83d\udc83\ud83d\ude0d\ud83d\ude0d\ud83d\ude0d\ud83d\ude4c\",]\nsqueeze_these = [\"\", \"-\", \"7\", \".\", \" -r\", \"\ud83d\ude0d\"]\n\nstrings.zip(squeeze_these).each do |str, st|\n  puts \"original:     \u00ab\u00ab\u00ab\n  st.chars.each do |c|\n    ssq = str.squeeze(c)\n    puts \"\n  end\n  puts\nend\n", "target": "from itertools import groupby\n\ndef squeezer(s, txt):\n    return ''.join(item if item == s else ''.join(grp)\n                   for item, grp in groupby(txt))\n\nif __name__ == '__main__':\n    strings = [\n            \"\",\n            '\"If I were two-faced, would I be wearing this one?\" --- Abraham Lincoln ',\n            \"..1111111111111111111111111111111111111111111111111111111111111117777888\",\n            \"I never give 'em hell, I just tell the truth, and they think it's hell. \",\n            \"                                                   ---  Harry S Truman  \",\n            \"The better the 4-wheel drive, the further you'll be from help when ya get stuck!\",\n            \"headmistressship\",\n            \"aardvark\",\n            \"\ud83d\ude0d\ud83d\ude00\ud83d\ude4c\ud83d\udc83\ud83d\ude0d\ud83d\ude0d\ud83d\ude0d\ud83d\ude4c\",\n            ]\n    squeezers = ' ,-,7,., -r,e,s,a,\ud83d\ude0d'.split(',')\n    for txt, chars in zip(strings, squeezers):\n        this = \"Original\"\n        print(f\"\\n{this:14} Size: {len(txt)} \u00ab\u00ab\u00ab{txt}\u00bb\u00bb\u00bb\" )\n        for ch in chars:\n            this = f\"Squeezer '{ch}'\"\n            sqz = squeezer(ch, txt)\n            print(f\"{this:>14} Size: {len(sqz)} \u00ab\u00ab\u00ab{sqz}\u00bb\u00bb\u00bb\" )\n"}
{"id": 14280, "name": "Determine if a string is squeezable", "source": "Translate Ruby to Python: strings = [\"\",\n        '\"If I were two-faced, would I be wearing this one?\" --- Abraham Lincoln ',\n        \"..1111111111111111111111111111111111111111111111111111111111111117777888\",\n        \"I never give 'em hell, I just tell the truth, and they think it's hell. \",\n        \"                                                   ---  Harry S Truman  \",\n        \"\ud83d\ude0d\ud83d\ude00\ud83d\ude4c\ud83d\udc83\ud83d\ude0d\ud83d\ude0d\ud83d\ude0d\ud83d\ude4c\",]\nsqueeze_these = [\"\", \"-\", \"7\", \".\", \" -r\", \"\ud83d\ude0d\"]\n\nstrings.zip(squeeze_these).each do |str, st|\n  puts \"original:     \u00ab\u00ab\u00ab\n  st.chars.each do |c|\n    ssq = str.squeeze(c)\n    puts \"\n  end\n  puts\nend\n", "target": "from itertools import groupby\n\ndef squeezer(s, txt):\n    return ''.join(item if item == s else ''.join(grp)\n                   for item, grp in groupby(txt))\n\nif __name__ == '__main__':\n    strings = [\n            \"\",\n            '\"If I were two-faced, would I be wearing this one?\" --- Abraham Lincoln ',\n            \"..1111111111111111111111111111111111111111111111111111111111111117777888\",\n            \"I never give 'em hell, I just tell the truth, and they think it's hell. \",\n            \"                                                   ---  Harry S Truman  \",\n            \"The better the 4-wheel drive, the further you'll be from help when ya get stuck!\",\n            \"headmistressship\",\n            \"aardvark\",\n            \"\ud83d\ude0d\ud83d\ude00\ud83d\ude4c\ud83d\udc83\ud83d\ude0d\ud83d\ude0d\ud83d\ude0d\ud83d\ude4c\",\n            ]\n    squeezers = ' ,-,7,., -r,e,s,a,\ud83d\ude0d'.split(',')\n    for txt, chars in zip(strings, squeezers):\n        this = \"Original\"\n        print(f\"\\n{this:14} Size: {len(txt)} \u00ab\u00ab\u00ab{txt}\u00bb\u00bb\u00bb\" )\n        for ch in chars:\n            this = f\"Squeezer '{ch}'\"\n            sqz = squeezer(ch, txt)\n            print(f\"{this:>14} Size: {len(sqz)} \u00ab\u00ab\u00ab{sqz}\u00bb\u00bb\u00bb\" )\n"}
{"id": 14580, "name": "Create a file", "source": "Translate Ruby to C#: File.write \"output.txt\", \"\"\nDir.mkdir \"docs\"\n\nFile.write \"/output.txt\", \"\"\nDir.mkdir \"/docs\"\n", "target": "using System;\nusing System.IO;\n\nclass Program {\n    static void Main(string[] args) {\n        File.Create(\"output.txt\");\n        File.Create(@\"\\output.txt\");\n\n        Directory.CreateDirectory(\"docs\");\n        Directory.CreateDirectory(@\"\\docs\");\n    }\n}\n"}
{"id": 14582, "name": "Create a file", "source": "Translate Ruby to Java: File.write \"output.txt\", \"\"\nDir.mkdir \"docs\"\n\nFile.write \"/output.txt\", \"\"\nDir.mkdir \"/docs\"\n", "target": "import java.io.*;\npublic class CreateFileTest {\n\tpublic static void main(String args[]) {\n\t\ttry {\n\t\t\tnew File(\"output.txt\").createNewFile();\n\t\t\tnew File(File.separator + \"output.txt\").createNewFile();\n\t\t\tnew File(\"docs\").mkdir();\n\t\t\tnew File(File.separator + \"docs\").mkdir();\n\t\t} catch (IOException e) {\n\t\t\tSystem.err.println(e.getMessage());\n\t\t}\n\t}\n}\n"}
{"id": 14583, "name": "Create a file", "source": "Translate Ruby to Python: File.write \"output.txt\", \"\"\nDir.mkdir \"docs\"\n\nFile.write \"/output.txt\", \"\"\nDir.mkdir \"/docs\"\n", "target": "import os\nfor directory in ['/', './']:\n  open(directory + 'output.txt', 'w').close()  \n  os.mkdir(directory + 'docs')                 \n"}
{"id": 14808, "name": "Cholesky decomposition", "source": "Translate Ruby to C#: require 'matrix'\n\nclass Matrix\n  def cholesky_factor\n    raise ArgumentError, \"must provide symmetric matrix\" unless symmetric?\n    l = Array.new(row_size) {Array.new(row_size, 0)}\n    (0 ... row_size).each do |k|\n      (0 ... row_size).each do |i|\n        if i == k\n          sum = (0 .. k-1).inject(0.0) {|sum, j| sum + l[k][j] ** 2}\n          val = Math.sqrt(self[k,k] - sum)\n          l[k][k] = val\n        elsif i > k\n          sum = (0 .. k-1).inject(0.0) {|sum, j| sum + l[i][j] * l[k][j]}\n          val = (self[k,i] - sum) / l[k][k]\n          l[i][k] = val\n        end\n      end\n    end\n    Matrix[*l]\n  end\nend\n\nputs Matrix[[25,15,-5],[15,18,0],[-5,0,11]].cholesky_factor\nputs Matrix[[18, 22,  54,  42],\n            [22, 70,  86,  62],\n            [54, 86, 174, 134],\n            [42, 62, 134, 106]].cholesky_factor\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\nnamespace Cholesky\n{\n    class Program\n    {\n        \n        \n        \n        \n        static void Main(string[] args)\n        {\n            double[,] test1 = new double[,]\n            {\n                {25, 15, -5},\n                {15, 18, 0},\n                {-5, 0, 11},\n            };\n\n            double[,] test2 = new double[,]\n            {\n                {18, 22, 54, 42},\n                {22, 70, 86, 62},\n                {54, 86, 174, 134},\n                {42, 62, 134, 106},\n            };\n\n            double[,] chol1 = Cholesky(test1);\n            double[,] chol2 = Cholesky(test2);\n\n            Console.WriteLine(\"Test 1: \");\n            Print(test1);\n            Console.WriteLine(\"\");\n            Console.WriteLine(\"Lower Cholesky 1: \");\n            Print(chol1);\n            Console.WriteLine(\"\");\n            Console.WriteLine(\"Test 2: \");\n            Print(test2);\n            Console.WriteLine(\"\");\n            Console.WriteLine(\"Lower Cholesky 2: \");\n            Print(chol2);\n\n        }\n\n        public static void Print(double[,] a)\n        {\n            int n = (int)Math.Sqrt(a.Length);\n\n            StringBuilder sb = new StringBuilder();\n            for (int r = 0; r < n; r++)\n            {\n                string s = \"\";\n                for (int c = 0; c < n; c++)\n                {\n                    s += a[r, c].ToString(\"f5\").PadLeft(9) + \",\";\n                }\n                sb.AppendLine(s);\n            }\n\n            Console.WriteLine(sb.ToString());\n        }\n\n        \n        \n        \n        \n        \n        \n        \n        \n        public static double[,] Cholesky(double[,] a)\n        {\n            int n = (int)Math.Sqrt(a.Length);\n\n            double[,] ret = new double[n, n];\n            for (int r = 0; r < n; r++)\n                for (int c = 0; c <= r; c++)\n                {\n                    if (c == r)\n                    {\n                        double sum = 0;\n                        for (int j = 0; j < c; j++)\n                        {\n                            sum += ret[c, j] * ret[c, j];\n                        }\n                        ret[c, c] = Math.Sqrt(a[c, c] - sum);\n                    }\n                    else\n                    {\n                        double sum = 0;\n                        for (int j = 0; j < c; j++)\n                            sum += ret[r, j] * ret[c, j];\n                        ret[r, c] = 1.0 / ret[c, c] * (a[r, c] - sum);\n                    }\n                }\n\n            return ret;\n        }\n    }\n}\n"}
{"id": 14810, "name": "Cholesky decomposition", "source": "Translate Ruby to Java: require 'matrix'\n\nclass Matrix\n  def cholesky_factor\n    raise ArgumentError, \"must provide symmetric matrix\" unless symmetric?\n    l = Array.new(row_size) {Array.new(row_size, 0)}\n    (0 ... row_size).each do |k|\n      (0 ... row_size).each do |i|\n        if i == k\n          sum = (0 .. k-1).inject(0.0) {|sum, j| sum + l[k][j] ** 2}\n          val = Math.sqrt(self[k,k] - sum)\n          l[k][k] = val\n        elsif i > k\n          sum = (0 .. k-1).inject(0.0) {|sum, j| sum + l[i][j] * l[k][j]}\n          val = (self[k,i] - sum) / l[k][k]\n          l[i][k] = val\n        end\n      end\n    end\n    Matrix[*l]\n  end\nend\n\nputs Matrix[[25,15,-5],[15,18,0],[-5,0,11]].cholesky_factor\nputs Matrix[[18, 22,  54,  42],\n            [22, 70,  86,  62],\n            [54, 86, 174, 134],\n            [42, 62, 134, 106]].cholesky_factor\n", "target": "import java.util.Arrays;\n\npublic class Cholesky {\n\tpublic static double[][] chol(double[][] a){\n\t\tint m = a.length;\n\t\tdouble[][] l = new double[m][m]; \n\t\tfor(int i = 0; i< m;i++){\n\t\t\tfor(int k = 0; k < (i+1); k++){\n\t\t\t\tdouble sum = 0;\n\t\t\t\tfor(int j = 0; j < k; j++){\n\t\t\t\t\tsum += l[i][j] * l[k][j];\n\t\t\t\t}\n\t\t\t\tl[i][k] = (i == k) ? Math.sqrt(a[i][i] - sum) :\n\t\t\t\t\t(1.0 / l[k][k] * (a[i][k] - sum));\n\t\t\t}\n\t\t}\n\t\treturn l;\n\t}\n\t\n\tpublic static void main(String[] args){\n\t\tdouble[][] test1 = {{25, 15, -5},\n\t\t\t\t\t\t\t{15, 18, 0},\n\t\t\t\t\t\t\t{-5, 0, 11}};\n\t\tSystem.out.println(Arrays.deepToString(chol(test1)));\n\t\tdouble[][] test2 = {{18, 22, 54, 42},\n\t\t\t\t\t\t\t{22, 70, 86, 62},\n\t\t\t\t\t\t\t{54, 86, 174, 134},\n\t\t\t\t\t\t\t{42, 62, 134, 106}};\n\t\tSystem.out.println(Arrays.deepToString(chol(test2)));\n\t}\n}\n"}
{"id": 14811, "name": "Cholesky decomposition", "source": "Translate Ruby to Python: require 'matrix'\n\nclass Matrix\n  def cholesky_factor\n    raise ArgumentError, \"must provide symmetric matrix\" unless symmetric?\n    l = Array.new(row_size) {Array.new(row_size, 0)}\n    (0 ... row_size).each do |k|\n      (0 ... row_size).each do |i|\n        if i == k\n          sum = (0 .. k-1).inject(0.0) {|sum, j| sum + l[k][j] ** 2}\n          val = Math.sqrt(self[k,k] - sum)\n          l[k][k] = val\n        elsif i > k\n          sum = (0 .. k-1).inject(0.0) {|sum, j| sum + l[i][j] * l[k][j]}\n          val = (self[k,i] - sum) / l[k][k]\n          l[i][k] = val\n        end\n      end\n    end\n    Matrix[*l]\n  end\nend\n\nputs Matrix[[25,15,-5],[15,18,0],[-5,0,11]].cholesky_factor\nputs Matrix[[18, 22,  54,  42],\n            [22, 70,  86,  62],\n            [54, 86, 174, 134],\n            [42, 62, 134, 106]].cholesky_factor\n", "target": "from __future__ import print_function\n\nfrom pprint import pprint\nfrom math import sqrt\n\n\ndef cholesky(A):\n    L = [[0.0] * len(A) for _ in xrange(len(A))]\n    for i in xrange(len(A)):\n        for j in xrange(i+1):\n            s = sum(L[i][k] * L[j][k] for k in xrange(j))\n            L[i][j] = sqrt(A[i][i] - s) if (i == j) else \\\n                      (1.0 / L[j][j] * (A[i][j] - s))\n    return L\n\nif __name__ == \"__main__\":\n    m1 = [[25, 15, -5],\n          [15, 18,  0],\n          [-5,  0, 11]]\n    pprint(cholesky(m1))\n    print()\n    \n    m2 = [[18, 22,  54,  42],\n          [22, 70,  86,  62],\n          [54, 86, 174, 134],\n          [42, 62, 134, 106]]\n    pprint(cholesky(m2), width=120)\n"}
{"id": 15017, "name": "Almost prime", "source": "Translate Ruby to C#: require 'prime'\n\ndef almost_primes(k=2)\n  return to_enum(:almost_primes, k) unless block_given?\n  1.step {|n| yield n if n.prime_division.sum( &:last ) == k }\nend\n\n(1..5).each{|k| puts almost_primes(k).take(10).join(\", \")}\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\nnamespace AlmostPrime\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            foreach (int k in Enumerable.Range(1, 5))\n            {\n                KPrime kprime = new KPrime() { K = k };\n                Console.WriteLine(\"k = {0}: {1}\",\n                    k, string.Join<int>(\" \", kprime.GetFirstN(10)));\n            }\n        }\n    }\n\n    class KPrime\n    {\n        public int K { get; set; }\n\n        public bool IsKPrime(int number)\n        {\n            int primes = 0;\n            for (int p = 2; p * p <= number && primes < K; ++p)\n            {\n                while (number % p == 0 && primes < K)\n                {\n                    number /= p;\n                    ++primes;\n                }\n            }\n            if (number > 1)\n            {\n                ++primes;\n            }\n            return primes == K;\n        }\n\n        public List<int> GetFirstN(int n)\n        {\n            List<int> result = new List<int>();\n            for (int number = 2; result.Count < n; ++number)\n            {\n                if (IsKPrime(number))\n                {\n                    result.Add(number);\n                }\n            }\n            return result;\n        }\n    }\n}\n"}
{"id": 15019, "name": "Almost prime", "source": "Translate Ruby to Java: require 'prime'\n\ndef almost_primes(k=2)\n  return to_enum(:almost_primes, k) unless block_given?\n  1.step {|n| yield n if n.prime_division.sum( &:last ) == k }\nend\n\n(1..5).each{|k| puts almost_primes(k).take(10).join(\", \")}\n", "target": "public class AlmostPrime {\n    public static void main(String[] args) {\n        for (int k = 1; k <= 5; k++) {\n            System.out.print(\"k = \" + k + \":\");\n\n            for (int i = 2, c = 0; c < 10; i++) {\n                if (kprime(i, k)) {\n                    System.out.print(\" \" + i);\n                    c++;\n                }\n            }\n\n            System.out.println(\"\");\n        }\n    }\n\n    public static boolean kprime(int n, int k) {\n        int f = 0;\n        for (int p = 2; f < k && p * p <= n; p++) {\n            while (n % p == 0) {\n                n /= p;\n                f++;\n            }\n        }\n        return f + ((n > 1) ? 1 : 0) == k;\n    }\n}\n"}
{"id": 15020, "name": "Almost prime", "source": "Translate Ruby to Python: require 'prime'\n\ndef almost_primes(k=2)\n  return to_enum(:almost_primes, k) unless block_given?\n  1.step {|n| yield n if n.prime_division.sum( &:last ) == k }\nend\n\n(1..5).each{|k| puts almost_primes(k).take(10).join(\", \")}\n", "target": "from prime_decomposition import decompose\nfrom itertools import islice, count\ntry: \n    from functools import reduce\nexcept: \n    pass\n\n\ndef almostprime(n, k=2):\n    d = decompose(n)\n    try:\n        terms = [next(d) for i in range(k)]\n        return reduce(int.__mul__, terms, 1) == n\n    except:\n        return False\n\nif __name__ == '__main__':\n    for k in range(1,6):\n        print('%i: %r' % (k, list(islice((n for n in count() if almostprime(n, k)), 10))))\n"}
{"id": 15297, "name": "Integer comparison", "source": "Translate Ruby to C#: a = (print \"enter a value for a: \"; gets).to_i\nb = (print \"enter a value for b: \"; gets).to_i\n\nputs \"\nputs \"\nputs \"\n", "target": "using System;\n\nclass Program\n{\n    static void Main()\n    {\n        int a = int.Parse(Console.ReadLine());\n        int b = int.Parse(Console.ReadLine());\n        if (a < b)\n            Console.WriteLine(\"{0} is less than {1}\", a, b);\n        if (a == b)\n            Console.WriteLine(\"{0} equals {1}\", a, b);\n        if (a > b)\n            Console.WriteLine(\"{0} is greater than {1}\", a, b);\n    }\n}\n"}
{"id": 15299, "name": "Integer comparison", "source": "Translate Ruby to Java: a = (print \"enter a value for a: \"; gets).to_i\nb = (print \"enter a value for b: \"; gets).to_i\n\nputs \"\nputs \"\nputs \"\n", "target": "import java.io.*;\n\npublic class compInt {\n   public static void main(String[] args) {\n       try {\n           BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n\n           int nbr1 = Integer.parseInt(in.readLine());\n           int nbr2 = Integer.parseInt(in.readLine());\n\n           if(nbr1<nbr2)\n               System.out.println(nbr1 + \" is less than \" + nbr2);\n\n           if(nbr1>nbr2)\n                System.out.println(nbr1 + \" is greater than \" + nbr2);\n\n           if(nbr1==nbr2)\n                System.out.println(nbr1 + \" is equal to \" + nbr2);\n       } catch(IOException e) { }\n   }\n}\n"}
{"id": 15300, "name": "Integer comparison", "source": "Translate Ruby to Python: a = (print \"enter a value for a: \"; gets).to_i\nb = (print \"enter a value for b: \"; gets).to_i\n\nputs \"\nputs \"\nputs \"\n", "target": "let a = input('Enter value of a: ')\nlet b = input('Enter value of b: ')\n\nif a < b:\n    print 'a is less than b'\nelif a > b:\n    print 'a is greater than b'\nelif a == b:\n    print 'a is equal to b'\n"}
{"id": 15513, "name": "Environment variables", "source": "Translate Ruby to C#: ENV['HOME']\n", "target": "using System;\n\nnamespace RosettaCode {\n    class Program {\n        static void Main() {\n            string temp = Environment.GetEnvironmentVariable(\"TEMP\");\n            Console.WriteLine(\"TEMP is \" + temp);\n        }\n    }\n}\n"}
{"id": 15760, "name": "Substring", "source": "Translate Ruby to C#: str = 'abcdefgh'\nn = 2\nm = 3\nputs str[n, m]                  \nputs str[n..m]                  \nputs str[n..-1]                 \nputs str[0..-2]                 \nputs str[str.index('d'), m]     \nputs str[str.index('de'), m]    \nputs str[/a.*d/]                \n", "target": "using System;\nnamespace SubString\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            string s = \"0123456789\";\n            const int n = 3;\n            const int m = 2;\n            const char c = '3';\n            const string z = \"345\";\n\n            \n            Console.WriteLine(s.Substring(n, m));\n            \n            Console.WriteLine(s.Substring(n, s.Length - n));\n            \n            Console.WriteLine(s.Substring(0, s.Length - 1));\n            \n            Console.WriteLine(s.Substring(s.IndexOf(c), m));\n            \n            Console.WriteLine(s.Substring(s.IndexOf(z), m));\n        }\n    }\n}\n"}
{"id": 15762, "name": "Substring", "source": "Translate Ruby to Java: str = 'abcdefgh'\nn = 2\nm = 3\nputs str[n, m]                  \nputs str[n..m]                  \nputs str[n..-1]                 \nputs str[0..-2]                 \nputs str[str.index('d'), m]     \nputs str[str.index('de'), m]    \nputs str[/a.*d/]                \n", "target": "public static String Substring(String str, int n, int m){\n    return str.substring(n, n+m);\n}\npublic static String Substring(String str, int n){\n    return str.substring(n);\n}\npublic static String Substring(String str){\n    return str.substring(0, str.length()-1);\n}\npublic static String Substring(String str, char c, int m){\n    return str.substring(str.indexOf(c), str.indexOf(c)+m+1);\n}\npublic static String Substring(String str, String sub, int m){\n    return str.substring(str.indexOf(sub), str.indexOf(sub)+m+1);\n}\n"}
{"id": 15763, "name": "Substring", "source": "Translate Ruby to Python: str = 'abcdefgh'\nn = 2\nm = 3\nputs str[n, m]                  \nputs str[n..m]                  \nputs str[n..-1]                 \nputs str[0..-2]                 \nputs str[str.index('d'), m]     \nputs str[str.index('de'), m]    \nputs str[/a.*d/]                \n", "target": ">>> s = 'abcdefgh'\n>>> n, m, char, chars = 2, 3, 'd', 'cd'\n>>> \n>>> s[n-1:n+m-1]\n'bcd'\n>>> \n>>> s[n-1:]\n'bcdefgh'\n>>> \n>>> s[:-1]\n'abcdefg'\n>>> \n>>> indx = s.index(char)\n>>> s[indx:indx+m]\n'def'\n>>> \n>>> indx = s.index(chars)\n>>> s[indx:indx+m]\n'cde'\n>>>\n"}
{"id": 16040, "name": "Evaluate binomial coefficients", "source": "Translate Ruby to C#: class Integer\n  \n  def choose(k)\n    \n    pTop = (self-k+1 .. self).inject(1, &:*) \n    \n    pBottom = (2 .. k).inject(1, &:*)\n    pTop / pBottom\n  end\nend\n\np 5.choose(3)\np 60.choose(30)\n", "target": "using System;\n\nnamespace BinomialCoefficients\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            ulong n = 1000000, k = 3;\n            ulong result = biCoefficient(n, k);\n            Console.WriteLine(\"The Binomial Coefficient of {0}, and {1}, is equal to: {2}\", n, k, result);\n            Console.ReadLine();\n        }\n\n        static int fact(int n)\n        {\n            if (n == 0) return 1;\n            else return n * fact(n - 1);\n        }\n\n        static ulong biCoefficient(ulong n, ulong k)\n        {\n            if (k > n - k)\n            {\n                k = n - k;\n            }\n\n            ulong c = 1;\n            for (uint i = 0; i < k; i++)\n            {\n                c = c * (n - i);\n                c = c / (i + 1);\n            }\n            return c;\n        }\n    }\n}\n"}
{"id": 16042, "name": "Evaluate binomial coefficients", "source": "Translate Ruby to Java: class Integer\n  \n  def choose(k)\n    \n    pTop = (self-k+1 .. self).inject(1, &:*) \n    \n    pBottom = (2 .. k).inject(1, &:*)\n    pTop / pBottom\n  end\nend\n\np 5.choose(3)\np 60.choose(30)\n", "target": "public class Binomial {\n\n    \n    private static long binomialInt(int n, int k) {\n        if (k > n - k)\n            k = n - k;\n\n        long binom = 1;\n        for (int i = 1; i <= k; i++)\n            binom = binom * (n + 1 - i) / i;\n        return binom;\n    }\n\n    \n    private static Object binomialIntReliable(int n, int k) {\n        if (k > n - k)\n            k = n - k;\n\n        long binom = 1;\n        for (int i = 1; i <= k; i++) {\n            try {\n                binom = Math.multiplyExact(binom, n + 1 - i) / i;\n            } catch (ArithmeticException e) {\n                return \"overflow\";\n            }\n        }\n        return binom;\n    }\n\n    \n    \n    private static double binomialFloat(int n, int k) {\n        if (k > n - k)\n            k = n - k;\n\n        double binom = 1.0;\n        for (int i = 1; i <= k; i++)\n            binom = binom * (n + 1 - i) / i;\n        return binom;\n    }\n\n    \n    private static BigInteger binomialBigInt(int n, int k) {\n        if (k > n - k)\n            k = n - k;\n\n        BigInteger binom = BigInteger.ONE;\n        for (int i = 1; i <= k; i++) {\n            binom = binom.multiply(BigInteger.valueOf(n + 1 - i));\n            binom = binom.divide(BigInteger.valueOf(i));\n        }\n        return binom;\n    }\n\n    private static void demo(int n, int k) {\n        List<Object> data = Arrays.asList(\n                n,\n                k,\n                binomialInt(n, k),\n                binomialIntReliable(n, k),\n                binomialFloat(n, k),\n                binomialBigInt(n, k));\n\n        System.out.println(data.stream().map(Object::toString).collect(Collectors.joining(\"\\t\")));\n    }\n\n    public static void main(String[] args) {\n        demo(5, 3);\n        demo(1000, 300);\n    }\n}\n"}
{"id": 16043, "name": "Evaluate binomial coefficients", "source": "Translate Ruby to Python: class Integer\n  \n  def choose(k)\n    \n    pTop = (self-k+1 .. self).inject(1, &:*) \n    \n    pBottom = (2 .. k).inject(1, &:*)\n    pTop / pBottom\n  end\nend\n\np 5.choose(3)\np 60.choose(30)\n", "target": "def binomialCoeff(n, k):\n    result = 1\n    for i in range(1, k+1):\n        result = result * (n-i+1) / i\n    return result\n\nif __name__ == \"__main__\":\n    print(binomialCoeff(5, 3))\n"}
{"id": 16255, "name": "Append a record to the end of a text file", "source": "Translate Ruby to C#: Gecos = Struct.new :fullname, :office, :extension, :homephone, :email \nclass Gecos\n  def to_s\n    \"%s,%s,%s,%s,%s\" % to_a\n  end\nend\n\n\nPasswd = Struct.new(:account, :password, :uid, :gid, :gecos, :directory, :shell) do\n  def to_s\n    to_a.join(':')\n  end\nend\n\njsmith = Passwd.new('jsmith','x',1001, 1000, Gecos.new('Joe Smith', 'Room 1007', '(234)555-8917', '(234)555-0077', 'jsmith@rosettacode.org'), '/home/jsmith', '/bin/bash')\njdoe = Passwd.new('jdoe','x',1002, 1000, Gecos.new('Jane Doe', 'Room 1004', '(234)555-8914', '(234)555-0044', 'jdoe@rosettacode.org'), '/home/jdoe', '/bin/bash')\nxyz = Passwd.new('xyz','x',1003, 1000, Gecos.new('X Yz', 'Room 1003', '(234)555-8913', '(234)555-0033', 'xyz@rosettacode.org'), '/home/xyz', '/bin/bash')\n\nfilename = 'append.records.test'\n\n\nFile.open(filename, 'w') do |io|\n  io.puts jsmith\n  io.puts jdoe\nend\n\nputs \"before appending:\"\nputs File.readlines(filename)\n\n\nFile.open(filename, 'a') do |io|\n  io.puts xyz\nend\n\nputs \"after appending:\"\nputs File.readlines(filename)\n", "target": "using System;\nusing System.IO;\n\nnamespace AppendPwdRosetta\n{\n    class PasswordRecord\n    {\n        public string account, password, fullname, office, extension, homephone, email, directory, shell;\n        public int UID, GID;\n        public PasswordRecord(string account, string password, int UID, int GID, string fullname, string office, string extension, string homephone, \n            string email, string directory, string shell)\n        {\n            this.account = account; this.password = password; this.UID = UID; this.GID = GID; this.fullname = fullname; this.office = office;\n            this.extension = extension; this.homephone = homephone; this.email = email; this.directory = directory; this.shell = shell;\n        }\n        public override string ToString()\n        {\n            var gecos = string.Join(\",\", new string[] { fullname, office, extension, homephone, email });\n            return string.Join(\":\", new string[] { account, password, UID.ToString(), GID.ToString(), gecos, directory, shell });\n        }\n    }\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            var jsmith = new PasswordRecord(\"jsmith\", \"x\", 1001, 1000, \"Joe Smith\", \"Room 1007\", \"(234)555-8917\", \"(234)555-0077\", \"jsmith@rosettacode.org\", \n                \"/home/jsmith\", \"/bin/bash\");\n            var jdoe = new PasswordRecord(\"jdoe\", \"x\", 1002, 1000, \"Jane Doe\", \"Room 1004\", \"(234)555-8914\", \"(234)555-0044\", \"jdoe@rosettacode.org\", \"/home/jdoe\", \n                \"/bin/bash\");\n            var xyz = new PasswordRecord(\"xyz\", \"x\", 1003, 1000, \"X Yz\", \"Room 1003\", \"(234)555-8913\", \"(234)555-0033\", \"xyz@rosettacode.org\", \"/home/xyz\", \"/bin/bash\");\n\n            \n            File.WriteAllLines(\"passwd.txt\", new string[] { jsmith.ToString(), jdoe.ToString() });\n\n            \n            File.AppendAllText(\"passwd.txt\", xyz.ToString());\n\n            \n            string[] lines = File.ReadAllLines(\"passwd.txt\");\n            Console.WriteLine(\"Appended record: \" + lines[2]);\n        }\n    }\n}\n"}
{"id": 16257, "name": "Append a record to the end of a text file", "source": "Translate Ruby to Java: Gecos = Struct.new :fullname, :office, :extension, :homephone, :email \nclass Gecos\n  def to_s\n    \"%s,%s,%s,%s,%s\" % to_a\n  end\nend\n\n\nPasswd = Struct.new(:account, :password, :uid, :gid, :gecos, :directory, :shell) do\n  def to_s\n    to_a.join(':')\n  end\nend\n\njsmith = Passwd.new('jsmith','x',1001, 1000, Gecos.new('Joe Smith', 'Room 1007', '(234)555-8917', '(234)555-0077', 'jsmith@rosettacode.org'), '/home/jsmith', '/bin/bash')\njdoe = Passwd.new('jdoe','x',1002, 1000, Gecos.new('Jane Doe', 'Room 1004', '(234)555-8914', '(234)555-0044', 'jdoe@rosettacode.org'), '/home/jdoe', '/bin/bash')\nxyz = Passwd.new('xyz','x',1003, 1000, Gecos.new('X Yz', 'Room 1003', '(234)555-8913', '(234)555-0033', 'xyz@rosettacode.org'), '/home/xyz', '/bin/bash')\n\nfilename = 'append.records.test'\n\n\nFile.open(filename, 'w') do |io|\n  io.puts jsmith\n  io.puts jdoe\nend\n\nputs \"before appending:\"\nputs File.readlines(filename)\n\n\nFile.open(filename, 'a') do |io|\n  io.puts xyz\nend\n\nputs \"after appending:\"\nputs File.readlines(filename)\n", "target": "import static java.util.Objects.requireNonNull;\n\nimport java.io.IOException;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.nio.file.Paths;\nimport java.nio.file.StandardOpenOption;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.stream.Collectors;\nimport java.util.stream.Stream;\n\npublic class RecordAppender {\n    static class Record {\n        private final String account;\n        private final String password;\n        private final int uid;\n        private final int gid;\n        private final List<String> gecos;\n        private final String directory;\n        private final String shell;\n\n        public Record(String account, String password, int uid, int gid, List<String> gecos, String directory, String shell) {\n            this.account = requireNonNull(account);\n            this.password = requireNonNull(password);\n            this.uid = uid;\n            this.gid = gid;\n            this.gecos = requireNonNull(gecos);\n            this.directory = requireNonNull(directory);\n            this.shell = requireNonNull(shell);\n        }\n\n        @Override\n        public String toString() {\n            return account + ':' + password + ':' + uid + ':' + gid + ':' + String.join(\",\", gecos) + ':' + directory + ':' + shell;\n        }\n\n        public static Record parse(String text) {\n            String[] tokens = text.split(\":\");\n            return new Record(\n                    tokens[0],\n                    tokens[1],\n                    Integer.parseInt(tokens[2]),\n                    Integer.parseInt(tokens[3]),\n                    Arrays.asList(tokens[4].split(\",\")),\n                    tokens[5],\n                    tokens[6]);\n        }\n    }\n\n    public static void main(String[] args) throws IOException {\n        List<String> rawData = Arrays.asList(\n                \"jsmith:x:1001:1000:Joe Smith,Room 1007,(234)555-8917,(234)555-0077,[email protected]:/home/jsmith:/bin/bash\",\n                \"jdoe:x:1002:1000:Jane Doe,Room 1004,(234)555-8914,(234)555-0044,[email protected]:/home/jdoe:/bin/bash\",\n                \"xyz:x:1003:1000:X Yz,Room 1003,(234)555-8913,(234)555-0033,[email protected]:/home/xyz:/bin/bash\"\n        );\n\n        List<Record> records = rawData.stream().map(Record::parse).collect(Collectors.toList());\n\n        Path tmp = Paths.get(\"_rosetta\", \".passwd\");\n        Files.createDirectories(tmp.getParent());\n        Files.write(tmp, (Iterable<String>) records.stream().limit(2).map(Record::toString)::iterator);\n\n        Files.write(tmp, Collections.singletonList(records.get(2).toString()), StandardOpenOption.APPEND);\n\n        try (Stream<String> lines = Files.lines(tmp)) {\n            lines.map(Record::parse).forEach(System.out::println);\n        }\n    }\n}\n"}
{"id": 16258, "name": "Append a record to the end of a text file", "source": "Translate Ruby to Python: Gecos = Struct.new :fullname, :office, :extension, :homephone, :email \nclass Gecos\n  def to_s\n    \"%s,%s,%s,%s,%s\" % to_a\n  end\nend\n\n\nPasswd = Struct.new(:account, :password, :uid, :gid, :gecos, :directory, :shell) do\n  def to_s\n    to_a.join(':')\n  end\nend\n\njsmith = Passwd.new('jsmith','x',1001, 1000, Gecos.new('Joe Smith', 'Room 1007', '(234)555-8917', '(234)555-0077', 'jsmith@rosettacode.org'), '/home/jsmith', '/bin/bash')\njdoe = Passwd.new('jdoe','x',1002, 1000, Gecos.new('Jane Doe', 'Room 1004', '(234)555-8914', '(234)555-0044', 'jdoe@rosettacode.org'), '/home/jdoe', '/bin/bash')\nxyz = Passwd.new('xyz','x',1003, 1000, Gecos.new('X Yz', 'Room 1003', '(234)555-8913', '(234)555-0033', 'xyz@rosettacode.org'), '/home/xyz', '/bin/bash')\n\nfilename = 'append.records.test'\n\n\nFile.open(filename, 'w') do |io|\n  io.puts jsmith\n  io.puts jdoe\nend\n\nputs \"before appending:\"\nputs File.readlines(filename)\n\n\nFile.open(filename, 'a') do |io|\n  io.puts xyz\nend\n\nputs \"after appending:\"\nputs File.readlines(filename)\n", "target": "\n\n\n\npasswd_list=[\n  dict(account='jsmith', password='x', UID=1001, GID=1000, \n       GECOS=dict(fullname='Joe Smith', office='Room 1007', extension='(234)555-8917',\n                  homephone='(234)555-0077', email='jsmith@rosettacode.org'),\n                  directory='/home/jsmith', shell='/bin/bash'),\n  dict(account='jdoe', password='x', UID=1002, GID=1000,\n       GECOS=dict(fullname='Jane Doe', office='Room 1004', extension='(234)555-8914',\n                  homephone='(234)555-0044', email='jdoe@rosettacode.org'),\n       directory='/home/jdoe', shell='/bin/bash')\n]\n\npasswd_fields=\"account password UID GID GECOS directory shell\".split()\nGECOS_fields=\"fullname office extension homephone email\".split()\n\ndef passwd_text_repr(passwd_rec):\n\n  passwd_rec[\"GECOS\"]=\",\".join([ passwd_rec[\"GECOS\"][field] for field in GECOS_fields])\n  for field in passwd_rec: \n    if not isinstance(passwd_rec[field], str):\n      passwd_rec[field]=`passwd_rec[field]`\n  return \":\".join([ passwd_rec[field] for field in passwd_fields ])\n\npasswd_text=open(\"passwd.txt\",\"w\")\nfor passwd_rec in passwd_list:\n  print >> passwd_text,passwd_text_repr(passwd_rec)\npasswd_text.close()\n\n\n\n\npasswd_text=open(\"passwd.txt\",\"a+\")\nnew_rec=dict(account='xyz', password='x', UID=1003, GID=1000,\n             GECOS=dict(fullname='X Yz', office='Room 1003', extension='(234)555-8913',\n                        homephone='(234)555-0033', email='xyz@rosettacode.org'),\n             directory='/home/xyz', shell='/bin/bash')\nprint >> passwd_text,  passwd_text_repr(new_rec)\npasswd_text.close()\n\n\n\n\npasswd_list=list(open(\"passwd.txt\",\"r\"))\nif \"xyz\" in passwd_list[-1]:\n  print \"Appended record:\",passwd_list[-1][:-1]\n"}
{"id": 16415, "name": "Digital root_Multiplicative digital root", "source": "Translate Ruby to C#: def mdroot(n)\n  mdr, persist = n, 0\n  until mdr < 10 do\n    mdr = mdr.digits.inject(:*)\n    persist += 1\n  end\n  [mdr, persist]\nend\n\nputs \"Number: MDR  MP\", \"======  ===  ==\"\n[123321, 7739, 893, 899998].each{|n| puts \"%6d:   %d  %2d\" % [n, *mdroot(n)]}\n\ncounter = Hash.new{|h,k| h[k]=[]}\n0.step do |i|\n  counter[mdroot(i).first] << i\n  break if counter.values.all?{|v| v.size >= 5 }\nend\nputs \"\", \"MDR: [n0..n4]\", \"===  ========\"\n10.times{|i| puts \"%3d: %p\" % [i, counter[i].first(5)]}\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\nclass Program\n{\n    static Tuple<int, int> DigitalRoot(long num)\n    {\n        int mp = 0;\n        while (num > 9)\n        {\n            num = num.ToString().ToCharArray().Select(x => x - '0').Aggregate((a, b) => a * b);\n            mp++;\n        }\n        return new Tuple<int, int>(mp, (int)num);\n    }\n    static void Main(string[] args)\n    {\n        foreach (long num in new long[] { 123321, 7739, 893, 899998 })\n        {\n            var t = DigitalRoot(num);\n            Console.WriteLine(\"{0} has multiplicative persistence {1} and multiplicative digital root {2}\", num, t.Item1, t.Item2);\n        }\n\n        const int twidth = 5;\n        List<long>[] table = new List<long>[10];\n        for (int i = 0; i < 10; i++)\n            table[i] = new List<long>();\n        long number = -1;\n        while (table.Any(x => x.Count < twidth)) \n        {\n            var t = DigitalRoot(++number);\n            if (table[t.Item2].Count < twidth)\n                table[t.Item2].Add(number);\n        }\n        for (int i = 0; i < 10; i++)\n            Console.WriteLine(\" {0}\u00a0: [{1}]\", i, string.Join(\", \", table[i]));\n    }\n}\n"}
{"id": 16417, "name": "Digital root_Multiplicative digital root", "source": "Translate Ruby to Java: def mdroot(n)\n  mdr, persist = n, 0\n  until mdr < 10 do\n    mdr = mdr.digits.inject(:*)\n    persist += 1\n  end\n  [mdr, persist]\nend\n\nputs \"Number: MDR  MP\", \"======  ===  ==\"\n[123321, 7739, 893, 899998].each{|n| puts \"%6d:   %d  %2d\" % [n, *mdroot(n)]}\n\ncounter = Hash.new{|h,k| h[k]=[]}\n0.step do |i|\n  counter[mdroot(i).first] << i\n  break if counter.values.all?{|v| v.size >= 5 }\nend\nputs \"\", \"MDR: [n0..n4]\", \"===  ========\"\n10.times{|i| puts \"%3d: %p\" % [i, counter[i].first(5)]}\n", "target": "import java.util.*;\n\npublic class MultiplicativeDigitalRoot {\n\n    public static void main(String[] args) {\n\n        System.out.println(\"NUMBER  MDR   MP\");\n        for (long n : new long[]{123321, 7739, 893, 899998}) {\n            long[] a = multiplicativeDigitalRoot(n);\n            System.out.printf(\"%6d %4d %4d%n\", a[0], a[1], a[2]);\n        }\n\n        System.out.println();\n\n        Map<Long, List<Long>> table = new HashMap<>();\n        for (long i = 0; i < 10; i++)\n            table.put(i, new ArrayList<>());\n\n        for (long cnt = 0, n = 0; cnt < 10;) {\n            long[] res = multiplicativeDigitalRoot(n++);\n            List<Long> list = table.get(res[1]);\n            if (list.size() < 5) {\n                list.add(res[0]);\n                cnt = list.size() == 5 ? cnt + 1 : cnt;\n            }\n        }\n\n        System.out.println(\"MDR: first five numbers with same MDR\");\n        table.forEach((key, lst) -> {\n            System.out.printf(\"%3d: \", key);\n            lst.forEach(e -> System.out.printf(\"%6s \", e));\n            System.out.println();\n        });\n    }\n\n    public static long[] multiplicativeDigitalRoot(long n) {\n        int mp = 0;\n        long mdr = n;\n        while (mdr > 9) {\n            long m = mdr;\n            long total = 1;\n            while (m > 0) {\n                total *= m % 10;\n                m /= 10;\n            }\n            mdr = total;\n            mp++;\n        }\n        return new long[]{n, mdr, mp};\n    }\n}\n"}
{"id": 16418, "name": "Digital root_Multiplicative digital root", "source": "Translate Ruby to Python: def mdroot(n)\n  mdr, persist = n, 0\n  until mdr < 10 do\n    mdr = mdr.digits.inject(:*)\n    persist += 1\n  end\n  [mdr, persist]\nend\n\nputs \"Number: MDR  MP\", \"======  ===  ==\"\n[123321, 7739, 893, 899998].each{|n| puts \"%6d:   %d  %2d\" % [n, *mdroot(n)]}\n\ncounter = Hash.new{|h,k| h[k]=[]}\n0.step do |i|\n  counter[mdroot(i).first] << i\n  break if counter.values.all?{|v| v.size >= 5 }\nend\nputs \"\", \"MDR: [n0..n4]\", \"===  ========\"\n10.times{|i| puts \"%3d: %p\" % [i, counter[i].first(5)]}\n", "target": "try:\n    from functools import reduce\nexcept:\n    pass\n\ndef mdroot(n):\n    'Multiplicative digital root'\n    mdr = [n]\n    while mdr[-1] > 9:\n        mdr.append(reduce(int.__mul__, (int(dig) for dig in str(mdr[-1])), 1))\n    return len(mdr) - 1, mdr[-1]\n\nif __name__ == '__main__':\n    print('Number: (MP, MDR)\\n======  =========')\n    for n in (123321, 7739, 893, 899998):\n        print('%6i: %r' % (n, mdroot(n)))\n        \n    table, n = {i: [] for i in range(10)}, 0\n    while min(len(row) for row in table.values()) < 5:\n        mpersistence, mdr = mdroot(n)\n        table[mdr].append(n)\n        n += 1\n    print('\\nMP: [n0..n4]\\n==  ========')\n    for mp, val in sorted(table.items()):\n        print('%2i: %r' % (mp, val[:5]))\n"}
{"id": 16649, "name": "Perfect numbers", "source": "Translate Ruby to C#: def perf(n)\n  sum = 0\n  for i in 1...n\n    sum += i  if n % i == 0\n  end\n  sum == n\nend\n", "target": "static void Main(string[] args)\n{\n\tConsole.WriteLine(\"Perfect numbers from 1 to 33550337:\");\n\n\tfor (int x = 0; x < 33550337; x++)\n\t{\n\t\tif (IsPerfect(x))\n\t\t\tConsole.WriteLine(x + \" is perfect.\");\n\t}\n\n\tConsole.ReadLine();\n}\n\nstatic bool IsPerfect(int num) \n{\n\tint sum = 0;\n\tfor (int i = 1; i < num; i++)\n\t{\n\t\tif (num % i == 0)\n\t\t\tsum += i;\n\t}\n\n\treturn sum == num ;\n}\n"}
{"id": 16650, "name": "Perfect numbers", "source": "Translate Ruby to Java: def perf(n)\n  sum = 0\n  for i in 1...n\n    sum += i  if n % i == 0\n  end\n  sum == n\nend\n", "target": "public static boolean perf(int n){\n\tint sum= 0;\n\tfor(int i= 1;i < n;i++){\n\t\tif(n % i == 0){\n\t\t\tsum+= i;\n\t\t}\n\t}\n\treturn sum == n;\n}\n"}
{"id": 16651, "name": "Perfect numbers", "source": "Translate Ruby to Python: def perf(n)\n  sum = 0\n  for i in 1...n\n    sum += i  if n % i == 0\n  end\n  sum == n\nend\n", "target": "def perf1(n):\n    sum = 0\n    for i in range(1, n):\n        if n % i == 0:\n            sum += i\n    return sum == n\n"}
{"id": 16988, "name": "Abbreviations, automatic", "source": "Translate Ruby to C#: require \"abbrev\" \n \nFile.read(\"daynames.txt\").each_line do |line|\n  next if line.strip.empty?\n  abbr = line.split.abbrev.invert\n  puts \"Minimum size: \nend\n", "target": "using System;\nusing System.Collections.Generic;\n\nnamespace Abbreviations {\n    class Program {\n        static void Main(string[] args) {\n            string[] lines = System.IO.File.ReadAllLines(\"days_of_week.txt\");\n            int i = 0;\n\n            foreach (string line in lines) {\n                i++;\n                if (line.Length > 0) {\n                    var days = line.Split();\n                    if (days.Length != 7) {\n                        throw new Exception(\"There aren't 7 days in line \" + i);\n                    }\n\n                    Dictionary<string, int> temp = new Dictionary<string, int>();\n                    foreach (string day in days) {\n                        if (temp.ContainsKey(day)) {\n                            Console.WriteLine(\" \u221e  {0}\", line);\n                            continue;\n                        }\n                        temp.Add(day, 1);\n                    }\n\n                    int len = 1;\n                    while (true) {\n                        temp.Clear();\n                        foreach(string day in days) {\n                            string key;\n                            if (len < day.Length) {\n                                key = day.Substring(0, len);\n                            } else {\n                                key = day;\n                            }\n                            if (temp.ContainsKey(key)) {\n                                break;\n                            }\n                            temp.Add(key, 1);\n                        }\n                        if (temp.Count == 7) {\n                            Console.WriteLine(\"{0,2:D}  {1}\", len, line);\n                            break;\n                        }\n                        len++;\n                    }\n                }\n            }\n        }\n    }\n}\n"}
{"id": 16989, "name": "Abbreviations, automatic", "source": "Translate Ruby to C#: require \"abbrev\" \n \nFile.read(\"daynames.txt\").each_line do |line|\n  next if line.strip.empty?\n  abbr = line.split.abbrev.invert\n  puts \"Minimum size: \nend\n", "target": "using System;\nusing System.Collections.Generic;\n\nnamespace Abbreviations {\n    class Program {\n        static void Main(string[] args) {\n            string[] lines = System.IO.File.ReadAllLines(\"days_of_week.txt\");\n            int i = 0;\n\n            foreach (string line in lines) {\n                i++;\n                if (line.Length > 0) {\n                    var days = line.Split();\n                    if (days.Length != 7) {\n                        throw new Exception(\"There aren't 7 days in line \" + i);\n                    }\n\n                    Dictionary<string, int> temp = new Dictionary<string, int>();\n                    foreach (string day in days) {\n                        if (temp.ContainsKey(day)) {\n                            Console.WriteLine(\" \u221e  {0}\", line);\n                            continue;\n                        }\n                        temp.Add(day, 1);\n                    }\n\n                    int len = 1;\n                    while (true) {\n                        temp.Clear();\n                        foreach(string day in days) {\n                            string key;\n                            if (len < day.Length) {\n                                key = day.Substring(0, len);\n                            } else {\n                                key = day;\n                            }\n                            if (temp.ContainsKey(key)) {\n                                break;\n                            }\n                            temp.Add(key, 1);\n                        }\n                        if (temp.Count == 7) {\n                            Console.WriteLine(\"{0,2:D}  {1}\", len, line);\n                            break;\n                        }\n                        len++;\n                    }\n                }\n            }\n        }\n    }\n}\n"}
{"id": 16992, "name": "Abbreviations, automatic", "source": "Translate Ruby to Java: require \"abbrev\" \n \nFile.read(\"daynames.txt\").each_line do |line|\n  next if line.strip.empty?\n  abbr = line.split.abbrev.invert\n  puts \"Minimum size: \nend\n", "target": "import java.io.IOException;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.nio.file.Paths;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\n\npublic class Abbreviations {\n    public static void main(String[] args) throws IOException {\n        Path path = Paths.get(\"days_of_week.txt\");\n        List<String> readAllLines = Files.readAllLines(path);\n        for (int i = 0; i < readAllLines.size(); i++) {\n            String line = readAllLines.get(i);\n            if (line.length() == 0) continue;\n\n            String[] days = line.split(\" \");\n            if (days.length != 7) throw new RuntimeException(\"There aren't 7 days on line \" + (i + 1));\n\n            Map<String, Integer> temp = new HashMap<>();\n            for (String day : days) {\n                Integer count = temp.getOrDefault(day, 0);\n                temp.put(day, count + 1);\n            }\n            if (temp.size() < 7) {\n                System.out.print(\" \u221e  \");\n                System.out.println(line);\n                continue;\n            }\n\n            int len = 1;\n            while (true) {\n                temp.clear();\n                for (String day : days) {\n                    String sd;\n                    if (len >= day.length()) {\n                        sd = day;\n                    } else {\n                        sd = day.substring(0, len);\n                    }\n                    Integer count = temp.getOrDefault(sd, 0);\n                    temp.put(sd, count + 1);\n                }\n                if (temp.size() == 7) {\n                    System.out.printf(\"%2d  %s\\n\", len, line);\n                    break;\n                }\n                len++;\n            }\n        }\n    }\n}\n"}
{"id": 16993, "name": "Abbreviations, automatic", "source": "Translate Ruby to Java: require \"abbrev\" \n \nFile.read(\"daynames.txt\").each_line do |line|\n  next if line.strip.empty?\n  abbr = line.split.abbrev.invert\n  puts \"Minimum size: \nend\n", "target": "import java.io.IOException;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.nio.file.Paths;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\n\npublic class Abbreviations {\n    public static void main(String[] args) throws IOException {\n        Path path = Paths.get(\"days_of_week.txt\");\n        List<String> readAllLines = Files.readAllLines(path);\n        for (int i = 0; i < readAllLines.size(); i++) {\n            String line = readAllLines.get(i);\n            if (line.length() == 0) continue;\n\n            String[] days = line.split(\" \");\n            if (days.length != 7) throw new RuntimeException(\"There aren't 7 days on line \" + (i + 1));\n\n            Map<String, Integer> temp = new HashMap<>();\n            for (String day : days) {\n                Integer count = temp.getOrDefault(day, 0);\n                temp.put(day, count + 1);\n            }\n            if (temp.size() < 7) {\n                System.out.print(\" \u221e  \");\n                System.out.println(line);\n                continue;\n            }\n\n            int len = 1;\n            while (true) {\n                temp.clear();\n                for (String day : days) {\n                    String sd;\n                    if (len >= day.length()) {\n                        sd = day;\n                    } else {\n                        sd = day.substring(0, len);\n                    }\n                    Integer count = temp.getOrDefault(sd, 0);\n                    temp.put(sd, count + 1);\n                }\n                if (temp.size() == 7) {\n                    System.out.printf(\"%2d  %s\\n\", len, line);\n                    break;\n                }\n                len++;\n            }\n        }\n    }\n}\n"}
{"id": 16994, "name": "Abbreviations, automatic", "source": "Translate Ruby to Python: require \"abbrev\" \n \nFile.read(\"daynames.txt\").each_line do |line|\n  next if line.strip.empty?\n  abbr = line.split.abbrev.invert\n  puts \"Minimum size: \nend\n", "target": "def shortest_abbreviation_length(line, list_size):\n    words = line.split()\n    word_count = len(words)\n    \n    if word_count != list_size:\n        raise ValueError(f'Not enough entries, expected {list_size} found {word_count}')\n\n    \n    abbreviation_length = 1\n    abbreviations = set()\n    while(True):\n        abbreviations = {word[:abbreviation_length] for word in words}\n        if len(abbreviations) == list_size:\n            return abbreviation_length\n        abbreviation_length += 1\n        abbreviations.clear()\n\ndef automatic_abbreviations(filename, words_per_line):\n    with open(filename) as file:\n        for line in file:\n            line = line.rstrip()\n            if len(line) > 0:\n                length = shortest_abbreviation_length(line, words_per_line)\n                print(f'{length:2} {line}')\n            else:\n                print()\n\nautomatic_abbreviations('daysOfWeek.txt', 7)\n"}
{"id": 16995, "name": "Abbreviations, automatic", "source": "Translate Ruby to Python: require \"abbrev\" \n \nFile.read(\"daynames.txt\").each_line do |line|\n  next if line.strip.empty?\n  abbr = line.split.abbrev.invert\n  puts \"Minimum size: \nend\n", "target": "def shortest_abbreviation_length(line, list_size):\n    words = line.split()\n    word_count = len(words)\n    \n    if word_count != list_size:\n        raise ValueError(f'Not enough entries, expected {list_size} found {word_count}')\n\n    \n    abbreviation_length = 1\n    abbreviations = set()\n    while(True):\n        abbreviations = {word[:abbreviation_length] for word in words}\n        if len(abbreviations) == list_size:\n            return abbreviation_length\n        abbreviation_length += 1\n        abbreviations.clear()\n\ndef automatic_abbreviations(filename, words_per_line):\n    with open(filename) as file:\n        for line in file:\n            line = line.rstrip()\n            if len(line) > 0:\n                length = shortest_abbreviation_length(line, words_per_line)\n                print(f'{length:2} {line}')\n            else:\n                print()\n\nautomatic_abbreviations('daysOfWeek.txt', 7)\n"}
{"id": 17322, "name": "Cantor set", "source": "Translate Ruby to C#: lines = 5\n\n(0..lines).each do |exp|\n  seg_size = 3**(lines-exp-1)\n  chars = (3**exp).times.map{ |n| n.digits(3).any?(1) ? \" \" : \"\u2588\"}\n  puts chars.map{ |c| c * seg_size }.join\nend\n", "target": "using System;\n\nnamespace CantorSet {\n    class Program {\n        const int WIDTH = 81;\n        const int HEIGHT = 5;\n        private static char[,] lines = new char[HEIGHT, WIDTH];\n\n        static Program() {\n            for (int i = 0; i < HEIGHT; i++) {\n                for (int j = 0; j < WIDTH; j++) {\n                    lines[i, j] = '*';\n                }\n            }\n        }\n\n        private static void Cantor(int start, int len, int index) {\n            int seg = len / 3;\n            if (seg == 0) return;\n            for (int i = index; i < HEIGHT; i++) {\n                for (int j = start + seg; j < start + seg * 2; j++) {\n                    lines[i, j] = ' ';\n                }\n            }\n            Cantor(start, seg, index + 1);\n            Cantor(start + seg * 2, seg, index + 1);\n        }\n\n        static void Main(string[] args) {\n            Cantor(0, WIDTH, 1);\n            for (int i = 0; i < HEIGHT; i++) {\n                for (int j = 0; j < WIDTH; j++) {\n                    Console.Write(lines[i,j]);\n                }\n                Console.WriteLine();\n            }\n        }\n    }\n}\n"}
{"id": 17323, "name": "Cantor set", "source": "Translate Ruby to C#: lines = 5\n\n(0..lines).each do |exp|\n  seg_size = 3**(lines-exp-1)\n  chars = (3**exp).times.map{ |n| n.digits(3).any?(1) ? \" \" : \"\u2588\"}\n  puts chars.map{ |c| c * seg_size }.join\nend\n", "target": "using System;\n\nnamespace CantorSet {\n    class Program {\n        const int WIDTH = 81;\n        const int HEIGHT = 5;\n        private static char[,] lines = new char[HEIGHT, WIDTH];\n\n        static Program() {\n            for (int i = 0; i < HEIGHT; i++) {\n                for (int j = 0; j < WIDTH; j++) {\n                    lines[i, j] = '*';\n                }\n            }\n        }\n\n        private static void Cantor(int start, int len, int index) {\n            int seg = len / 3;\n            if (seg == 0) return;\n            for (int i = index; i < HEIGHT; i++) {\n                for (int j = start + seg; j < start + seg * 2; j++) {\n                    lines[i, j] = ' ';\n                }\n            }\n            Cantor(start, seg, index + 1);\n            Cantor(start + seg * 2, seg, index + 1);\n        }\n\n        static void Main(string[] args) {\n            Cantor(0, WIDTH, 1);\n            for (int i = 0; i < HEIGHT; i++) {\n                for (int j = 0; j < WIDTH; j++) {\n                    Console.Write(lines[i,j]);\n                }\n                Console.WriteLine();\n            }\n        }\n    }\n}\n"}
{"id": 17326, "name": "Cantor set", "source": "Translate Ruby to Java: lines = 5\n\n(0..lines).each do |exp|\n  seg_size = 3**(lines-exp-1)\n  chars = (3**exp).times.map{ |n| n.digits(3).any?(1) ? \" \" : \"\u2588\"}\n  puts chars.map{ |c| c * seg_size }.join\nend\n", "target": "public class App {\n    private static final int WIDTH = 81;\n    private static final int HEIGHT = 5;\n\n    private static char[][] lines;\n    static {\n        lines = new char[HEIGHT][WIDTH];\n        for (int i = 0; i < HEIGHT; i++) {\n            for (int j = 0; j < WIDTH; j++) {\n                lines[i][j] = '*';\n            }\n        }\n    }\n\n    private static void cantor(int start, int len, int index) {\n        int seg = len / 3;\n        if (seg == 0) return;\n        for (int i = index; i < HEIGHT; i++) {\n            for (int j = start + seg; j < start + seg * 2; j++) {\n                lines[i][j] = ' ';\n            }\n        }\n        cantor(start, seg, index + 1);\n        cantor(start + seg * 2, seg, index + 1);\n    }\n\n    public static void main(String[] args) {\n        cantor(0, WIDTH, 1);\n        for (int i = 0; i < HEIGHT; i++) {\n            for (int j = 0; j < WIDTH; j++) {\n                System.out.print(lines[i][j]);\n            }\n            System.out.println();\n        }\n    }\n}\n"}
{"id": 17327, "name": "Cantor set", "source": "Translate Ruby to Java: lines = 5\n\n(0..lines).each do |exp|\n  seg_size = 3**(lines-exp-1)\n  chars = (3**exp).times.map{ |n| n.digits(3).any?(1) ? \" \" : \"\u2588\"}\n  puts chars.map{ |c| c * seg_size }.join\nend\n", "target": "public class App {\n    private static final int WIDTH = 81;\n    private static final int HEIGHT = 5;\n\n    private static char[][] lines;\n    static {\n        lines = new char[HEIGHT][WIDTH];\n        for (int i = 0; i < HEIGHT; i++) {\n            for (int j = 0; j < WIDTH; j++) {\n                lines[i][j] = '*';\n            }\n        }\n    }\n\n    private static void cantor(int start, int len, int index) {\n        int seg = len / 3;\n        if (seg == 0) return;\n        for (int i = index; i < HEIGHT; i++) {\n            for (int j = start + seg; j < start + seg * 2; j++) {\n                lines[i][j] = ' ';\n            }\n        }\n        cantor(start, seg, index + 1);\n        cantor(start + seg * 2, seg, index + 1);\n    }\n\n    public static void main(String[] args) {\n        cantor(0, WIDTH, 1);\n        for (int i = 0; i < HEIGHT; i++) {\n            for (int j = 0; j < WIDTH; j++) {\n                System.out.print(lines[i][j]);\n            }\n            System.out.println();\n        }\n    }\n}\n"}
{"id": 17328, "name": "Cantor set", "source": "Translate Ruby to Python: lines = 5\n\n(0..lines).each do |exp|\n  seg_size = 3**(lines-exp-1)\n  chars = (3**exp).times.map{ |n| n.digits(3).any?(1) ? \" \" : \"\u2588\"}\n  puts chars.map{ |c| c * seg_size }.join\nend\n", "target": "WIDTH = 81\nHEIGHT = 5\n\nlines=[]\ndef cantor(start, len, index):\n    seg = len / 3\n    if seg == 0:\n        return None\n    for it in xrange(HEIGHT-index):\n        i = index + it\n        for jt in xrange(seg):\n            j = start + seg + jt\n            pos = i * WIDTH + j\n            lines[pos] = ' '\n    cantor(start,           seg, index + 1)\n    cantor(start + seg * 2, seg, index + 1)\n    return None\n\nlines = ['*'] * (WIDTH*HEIGHT)\ncantor(0, WIDTH, 1)\n\nfor i in xrange(HEIGHT):\n    beg = WIDTH * i\n    print ''.join(lines[beg : beg+WIDTH])\n"}
{"id": 17329, "name": "Cantor set", "source": "Translate Ruby to Python: lines = 5\n\n(0..lines).each do |exp|\n  seg_size = 3**(lines-exp-1)\n  chars = (3**exp).times.map{ |n| n.digits(3).any?(1) ? \" \" : \"\u2588\"}\n  puts chars.map{ |c| c * seg_size }.join\nend\n", "target": "WIDTH = 81\nHEIGHT = 5\n\nlines=[]\ndef cantor(start, len, index):\n    seg = len / 3\n    if seg == 0:\n        return None\n    for it in xrange(HEIGHT-index):\n        i = index + it\n        for jt in xrange(seg):\n            j = start + seg + jt\n            pos = i * WIDTH + j\n            lines[pos] = ' '\n    cantor(start,           seg, index + 1)\n    cantor(start + seg * 2, seg, index + 1)\n    return None\n\nlines = ['*'] * (WIDTH*HEIGHT)\ncantor(0, WIDTH, 1)\n\nfor i in xrange(HEIGHT):\n    beg = WIDTH * i\n    print ''.join(lines[beg : beg+WIDTH])\n"}
{"id": 17509, "name": "Bitmap_Write a PPM file", "source": "Translate Ruby to C#: class RGBColour\n  def values\n    [@red, @green, @blue]\n  end\nend\n\nclass Pixmap\n  def save(filename)\n    File.open(filename, 'w') do |f|\n      f.puts \"P6\", \"\n      f.binmode\n      @height.times do |y|\n        @width.times do |x|\n          f.print @data[x][y].values.pack('C3')\n        end\n      end\n    end\n  end\n  alias_method :write, :save\nend\n", "target": "using System;\nusing System.IO;\nclass PPMWriter\n{\n    public static void WriteBitmapToPPM(string file, Bitmap bitmap)\n        {\n            \n            var writer = new StreamWriter(file);\n            writer.WriteLine(\"P6\");\n            writer.WriteLine($\"{bitmap.Width}  {bitmap.Height}\");\n            writer.WriteLine(\"255\");\n            writer.Close();\n            \n            var writerB = new BinaryWriter(new FileStream(file, FileMode.Append));\n            for (int x = 0; x < bitmap.Height; x++)\n                for (int y = 0; y < bitmap.Width; y++)\n                {\n                    Color color = bitmap.GetPixel(y, x);\n                    writerB.Write(color.R);\n                    writerB.Write(color.G);\n                    writerB.Write(color.B);\n                }\n            writerB.Close();\n        }\n}\n"}
{"id": 17511, "name": "Bitmap_Write a PPM file", "source": "Translate Ruby to Java: class RGBColour\n  def values\n    [@red, @green, @blue]\n  end\nend\n\nclass Pixmap\n  def save(filename)\n    File.open(filename, 'w') do |f|\n      f.puts \"P6\", \"\n      f.binmode\n      @height.times do |y|\n        @width.times do |x|\n          f.print @data[x][y].values.pack('C3')\n        end\n      end\n    end\n  end\n  alias_method :write, :save\nend\n", "target": "import java.io.BufferedOutputStream;\nimport java.io.File;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.nio.charset.StandardCharsets;\n\npublic class PPMWriter {\n\n    public void bitmapToPPM(File file, BasicBitmapStorage bitmap) throws IOException {\n        file.delete();\n\n        try (var os = new FileOutputStream(file, true);\n             var bw = new BufferedOutputStream(os)) {\n            var header = String.format(\"P6\\n%d %d\\n255\\n\",\n                    bitmap.getWidth(), bitmap.getHeight());\n\n            bw.write(header.getBytes(StandardCharsets.US_ASCII));\n\n            for (var y = 0; y < bitmap.getHeight(); y++) {\n                for (var x = 0; x < bitmap.getWidth(); x++) {\n                    var pixel = bitmap.getPixel(x, y);\n                    bw.write(pixel.getRed());\n                    bw.write(pixel.getGreen());\n                    bw.write(pixel.getBlue());\n                }\n            }\n        }\n    }\n}\n"}
{"id": 17512, "name": "Bitmap_Write a PPM file", "source": "Translate Ruby to Python: class RGBColour\n  def values\n    [@red, @green, @blue]\n  end\nend\n\nclass Pixmap\n  def save(filename)\n    File.open(filename, 'w') do |f|\n      f.puts \"P6\", \"\n      f.binmode\n      @height.times do |y|\n        @width.times do |x|\n          f.print @data[x][y].values.pack('C3')\n        end\n      end\n    end\n  end\n  alias_method :write, :save\nend\n", "target": "\nimport io\nppmfileout = io.StringIO('')\n\ndef writeppmp3(self, f):\n    self.writeppm(f, ppmformat='P3')\n        \ndef writeppm(self, f, ppmformat='P6'):\n    assert ppmformat in ['P3', 'P6'], 'Format wrong'\n    magic = ppmformat + '\\n'\n    comment = '\n    maxval = max(max(max(bit) for bit in row) for row in self.map)\n    assert ppmformat == 'P3' or 0 <= maxval < 256, 'R,G,B must fit in a byte'\n    if ppmformat == 'P6':\n        fwrite = lambda s: f.write(bytes(s, 'UTF-8'))\n        maxval = 255\n    else:\n        fwrite = f.write\n        numsize=len(str(maxval))\n    fwrite(magic)\n    fwrite(comment)\n    fwrite('%i %i\\n%i\\n' % (self.width, self.height, maxval))\n    for h in range(self.height-1, -1, -1):\n        for w in range(self.width):\n            r, g, b = self.get(w, h)\n            if ppmformat == 'P3':\n                fwrite('   %*i %*i %*i' % (numsize, r, numsize, g, numsize, b))\n            else:\n                fwrite('%c%c%c' % (r, g, b))\n        if ppmformat == 'P3':\n            fwrite('\\n')\n\nBitmap.writeppmp3 = writeppmp3\nBitmap.writeppm = writeppm\n\n\nbitmap = Bitmap(4, 4, black)\nbitmap.fillrect(1, 0, 1, 2, white)\nbitmap.set(3, 3, Colour(127, 0, 63))\n\nbitmap.writeppmp3(ppmfileout)\n\nprint(ppmfileout.getvalue())\n\n\n\n\nppmfileout = open('tmp.ppm', 'wb')\nbitmap.writeppm(ppmfileout)\nppmfileout.close()\n"}
{"id": 17777, "name": "Create a two-dimensional array at runtime", "source": "Translate Ruby to C#: require \"random\"\n\nfirst = gets.not_nil!.to_i32\nsecond = gets.not_nil!.to_i32\n\narr = Array(Array(Int32)).new(first, Array(Int32).new second, 0)\n\nrandom = Random.new\n\nfirst = random.rand 0..(first - 1)\nsecond = random.rand 0..(second - 1)\n\narr[first][second] = random.next_int\nputs arr[first][second]\n", "target": "class Program\n    {\n        static void Main(string[] args)\n        {\n            Console.WriteLine(\"Enter two integers. Space delimited please: \");\n            string s = Console.ReadLine();\n            \n            int[,] myArray=new int[(int)s[0],(int)s[2]];\n            myArray[0, 0] = 2;\n            Console.WriteLine(myArray[0, 0]);\n\n            Console.ReadLine();\n        }\n    }\n"}
{"id": 17779, "name": "Create a two-dimensional array at runtime", "source": "Translate Ruby to Java: require \"random\"\n\nfirst = gets.not_nil!.to_i32\nsecond = gets.not_nil!.to_i32\n\narr = Array(Array(Int32)).new(first, Array(Int32).new second, 0)\n\nrandom = Random.new\n\nfirst = random.rand 0..(first - 1)\nsecond = random.rand 0..(second - 1)\n\narr[first][second] = random.next_int\nputs arr[first][second]\n", "target": "import java.util.Scanner;\n\npublic class twoDimArray {\n  public static void main(String[] args) {\n        Scanner in = new Scanner(System.in);\n        \n        int nbr1 = in.nextInt();\n        int nbr2 = in.nextInt();\n        \n        double[][] array = new double[nbr1][nbr2];\n        array[0][0] = 42.0;\n        System.out.println(\"The number at place [0 0] is \" + array[0][0]);\n  }\n}\n"}
{"id": 17780, "name": "Create a two-dimensional array at runtime", "source": "Translate Ruby to Python: require \"random\"\n\nfirst = gets.not_nil!.to_i32\nsecond = gets.not_nil!.to_i32\n\narr = Array(Array(Int32)).new(first, Array(Int32).new second, 0)\n\nrandom = Random.new\n\nfirst = random.rand 0..(first - 1)\nsecond = random.rand 0..(second - 1)\n\narr[first][second] = random.next_int\nputs arr[first][second]\n", "target": "width = int(raw_input(\"Width of myarray: \"))\nheight = int(raw_input(\"Height of Array: \"))\nmyarray = [[0] * width for i in range(height)]\nmyarray[0][0] = 3.5\nprint (myarray[0][0])\n"}
{"id": 18125, "name": "Munchausen numbers", "source": "Translate Ruby to C#:   puts (1..5000).select{|n| n.digits.sum{|d| d**d} == n}\n", "target": "Func<char, int> toInt = c => c-'0';\n\nforeach (var i in Enumerable.Range(1,5000)\n\t.Where(n => n == n.ToString()\n\t\t.Sum(x => Math.Pow(toInt(x), toInt(x)))))\n\tConsole.WriteLine(i);\n"}
{"id": 18126, "name": "Munchausen numbers", "source": "Translate Ruby to C#:   puts (1..5000).select{|n| n.digits.sum{|d| d**d} == n}\n", "target": "Func<char, int> toInt = c => c-'0';\n\nforeach (var i in Enumerable.Range(1,5000)\n\t.Where(n => n == n.ToString()\n\t\t.Sum(x => Math.Pow(toInt(x), toInt(x)))))\n\tConsole.WriteLine(i);\n"}
{"id": 18129, "name": "Munchausen numbers", "source": "Translate Ruby to Java:   puts (1..5000).select{|n| n.digits.sum{|d| d**d} == n}\n", "target": "public class Main {\n    public static void main(String[] args) {\n        for(int i = 0 ; i <= 5000 ; i++ ){\n            int val = String.valueOf(i).chars().map(x -> (int) Math.pow( x-48 ,x-48)).sum();\n            if( i == val){\n                System.out.println( i + \" (munchausen)\");\n            }\n        }\n    }\n}\n"}
{"id": 18130, "name": "Munchausen numbers", "source": "Translate Ruby to Java:   puts (1..5000).select{|n| n.digits.sum{|d| d**d} == n}\n", "target": "public class Main {\n    public static void main(String[] args) {\n        for(int i = 0 ; i <= 5000 ; i++ ){\n            int val = String.valueOf(i).chars().map(x -> (int) Math.pow( x-48 ,x-48)).sum();\n            if( i == val){\n                System.out.println( i + \" (munchausen)\");\n            }\n        }\n    }\n}\n"}
{"id": 18131, "name": "Munchausen numbers", "source": "Translate Ruby to Python:   puts (1..5000).select{|n| n.digits.sum{|d| d**d} == n}\n", "target": "for i in range(5000):\n    if i == sum(int(x) ** int(x) for x in str(i)):\n        print(i)\n"}
{"id": 18132, "name": "Munchausen numbers", "source": "Translate Ruby to Python:   puts (1..5000).select{|n| n.digits.sum{|d| d**d} == n}\n", "target": "for i in range(5000):\n    if i == sum(int(x) ** int(x) for x in str(i)):\n        print(i)\n"}
{"id": 18388, "name": "Strip block comments", "source": "Translate Ruby to C#: def remove_comments!(str, comment_start='/*', comment_end='*/')\n  while start_idx = str.index(comment_start) \n    end_idx = str.index(comment_end, start_idx + comment_start.length) + comment_end.length - 1\n    str[start_idx .. end_idx] = \"\" \n  end\n  str\nend\n\ndef remove_comments(str, comment_start='/*', comment_end='*/')\n  remove_comments!(str.dup, comment_start, comment_end)\nend\n\nexample = <<END_OF_STRING\n  /**\n   * Some comments\n   * longer comments here that we can parse.\n   *\n   * Rahoo \n   */\n   function subroutine() {\n    a = /* inline comment */ b + c\u00a0;\n   }\n   /*/ <-- tricky comments */\n\n   /**\n    * Another comment.\n    */\n    function something() {\n    }\nEND_OF_STRING\n\nputs remove_comments example\n", "target": "using System;\n\n    class Program\n    {\n        private static string BlockCommentStrip(string commentStart, string commentEnd, string sampleText)\n        {\n            while (sampleText.IndexOf(commentStart) > -1 && sampleText.IndexOf(commentEnd, sampleText.IndexOf(commentStart) + commentStart.Length) > -1)\n            {\n                int start = sampleText.IndexOf(commentStart);\n                int end = sampleText.IndexOf(commentEnd, start + commentStart.Length);\n                sampleText = sampleText.Remove(\n                    start,\n                    (end + commentEnd.Length) - start\n                    );\n            }\n            return sampleText;\n        }\n    }\n"}
{"id": 18390, "name": "Strip block comments", "source": "Translate Ruby to Java: def remove_comments!(str, comment_start='/*', comment_end='*/')\n  while start_idx = str.index(comment_start) \n    end_idx = str.index(comment_end, start_idx + comment_start.length) + comment_end.length - 1\n    str[start_idx .. end_idx] = \"\" \n  end\n  str\nend\n\ndef remove_comments(str, comment_start='/*', comment_end='*/')\n  remove_comments!(str.dup, comment_start, comment_end)\nend\n\nexample = <<END_OF_STRING\n  /**\n   * Some comments\n   * longer comments here that we can parse.\n   *\n   * Rahoo \n   */\n   function subroutine() {\n    a = /* inline comment */ b + c\u00a0;\n   }\n   /*/ <-- tricky comments */\n\n   /**\n    * Another comment.\n    */\n    function something() {\n    }\nEND_OF_STRING\n\nputs remove_comments example\n", "target": "import java.io.*;\n\npublic class StripBlockComments{\n    public static String readFile(String filename) {\n\tBufferedReader reader = new BufferedReader(new FileReader(filename));\n\ttry {\n\t    StringBuilder fileContents = new StringBuilder();\n\t    char[] buffer = new char[4096];\n\t    while (reader.read(buffer, 0, 4096) > 0) {\n\t\tfileContents.append(buffer);\n\t    }\n\t    return fileContents.toString();\n\t} finally {\n\t    reader.close();\n\t}\n    }\n\n    public static String stripComments(String beginToken, String endToken,\n\t\t\t\t       String input) {\n\tStringBuilder output = new StringBuilder();\n\twhile (true) {\n\t    int begin = input.indexOf(beginToken);\n\t    int end = input.indexOf(endToken, begin+beginToken.length());\n\t    if (begin == -1 || end == -1) {\n\t\toutput.append(input);\n\t\treturn output.toString();\n\t    }\n\t    output.append(input.substring(0, begin));\n\t    input = input.substring(end + endToken.length());\n\t}\n    }\n\n    public static void main(String[] args) {\n\tif (args.length < 3) {\n\t    System.out.println(\"Usage: BeginToken EndToken FileToProcess\");\n\t    System.exit(1);\n\t}\n\n\tString begin = args[0];\n\tString end = args[1];\n\tString input = args[2];\n\n\ttry {\n\t    System.out.println(stripComments(begin, end, readFile(input)));\n\t} catch (Exception e) {\n\t    e.printStackTrace();\n\t    System.exit(1);\n\t}\n    }\n}\n"}
{"id": 18391, "name": "Strip block comments", "source": "Translate Ruby to Python: def remove_comments!(str, comment_start='/*', comment_end='*/')\n  while start_idx = str.index(comment_start) \n    end_idx = str.index(comment_end, start_idx + comment_start.length) + comment_end.length - 1\n    str[start_idx .. end_idx] = \"\" \n  end\n  str\nend\n\ndef remove_comments(str, comment_start='/*', comment_end='*/')\n  remove_comments!(str.dup, comment_start, comment_end)\nend\n\nexample = <<END_OF_STRING\n  /**\n   * Some comments\n   * longer comments here that we can parse.\n   *\n   * Rahoo \n   */\n   function subroutine() {\n    a = /* inline comment */ b + c\u00a0;\n   }\n   /*/ <-- tricky comments */\n\n   /**\n    * Another comment.\n    */\n    function something() {\n    }\nEND_OF_STRING\n\nputs remove_comments example\n", "target": "def _commentstripper(txt, delim):\n    'Strips first nest of block comments'\n    \n    deliml, delimr = delim\n    out = ''\n    if deliml in txt:\n        indx = txt.index(deliml)\n        out += txt[:indx]\n        txt = txt[indx+len(deliml):]\n        txt = _commentstripper(txt, delim)\n        assert delimr in txt, 'Cannot find closing comment delimiter in ' + txt\n        indx = txt.index(delimr)\n        out += txt[(indx+len(delimr)):]\n    else:\n        out = txt\n    return out\n\ndef commentstripper(txt, delim=('/*', '*/')):\n    'Strips nests of block comments'\n    \n    deliml, delimr = delim\n    while deliml in txt:\n        txt = _commentstripper(txt, delim)\n    return txt\n"}
{"id": 18508, "name": "Checkpoint synchronization", "source": "Translate Ruby to C#: require 'socket'\n\n\n\n\n\n\n\n\n\n\n\n\n\nclass Workshop\n  \n  def initialize\n    @sockets = {}\n  end\n\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  def add\n    child, parent = UNIXSocket.pair\n\n    wid = fork do\n      \n      child.close\n      @sockets.each_value { |sibling| sibling.close }\n\n      \n      \n      Signal.trap(\"INT\") { exit! }\n\n      loop do\n        \n        begin\n          command, args = Marshal.load(parent)\n        rescue EOFError\n          \n          break\n        end\n\n        case command\n        when :work\n          \n          result = yield *args\n          Marshal.dump(result, parent)\n        when :remove\n          break\n        else\n          fail \"bad command from workshop\"\n        end\n      end\n    end\n\n    \n    parent.close\n    @sockets[wid] = child\n    wid\n  end\n\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  def work(*args)\n    message = [:work, args]\n    @sockets.each_pair do |wid, child|\n      Marshal.dump(message, child)\n    end\n\n    \n    result = {}\n    @sockets.each_pair do |wid, child|\n      begin\n        \n        result[wid] = Marshal.load(child)\n      rescue EOFError\n        fail \"Worker \n      end\n    end\n    result\n  end\n\n  \n  \n  \n  \n  def remove(wid)\n    unless child = @sockets.delete(wid)\n      raise ArgumentError, \"No worker \n    else\n      Marshal.dump([:remove, nil], child)\n      child.close\n      Process.wait(wid)\n    end\n  end\nend\n\n\n\n\nrequire 'pp'\nshop = Workshop.new\nwids = []\n\n\n@fixed_rand = false\ndef fix_rand\n  unless @fixed_rand; srand; @fixed_rand = true; end\nend\n\n\n6.times do\n  wids << shop.add do |i|\n    \n    fix_rand\n    f = proc { |n| if n < 2 then n else f[n - 1] + f[n - 2] end }\n    [i, f[25 + rand(10)]]\n  end\nend\n\n6.times do |i|\n  \n  pp shop.work(i)\n\n  \n  victim = rand(wids.length)\n  shop.remove wids[victim]\n  wids.slice! victim\n\n  \n  wids << shop.add do |j|\n    \n    \n    fix_rand\n    f = proc { |n| if n < 3 then n else f[n - 1] + f[n - 2] + f[n - 3] end }\n    [j, i, f[20 + rand(10)]]\n  end\nend\n\n\nwids.each { |wid| shop.remove wid }\npp shop.work(6)\n", "target": "using System;\nusing System.Linq;\nusing System.Threading;\nusing System.Threading.Tasks;\n\nnamespace Rosetta.CheckPointSync;\n\npublic class Program\n{\n    public async Task Main()\n    {\n        RobotBuilder robotBuilder = new RobotBuilder();\n        Task work = robotBuilder.BuildRobots(\n            \"Optimus Prime\", \"R. Giskard Reventlov\", \"Data\", \"Marvin\",\n            \"Bender\", \"Number Six\", \"C3-PO\", \"Dolores\");\n        await work;\n    }\n\n    public class RobotBuilder\n    {\n        static readonly string[] parts = { \"Head\", \"Torso\", \"Left arm\", \"Right arm\", \"Left leg\", \"Right leg\" };\n        static readonly Random rng = new Random();\n        static readonly object key = new object();\n\n        public Task BuildRobots(params string[] robots)\n        {\n            int r = 0;\n            Barrier checkpoint = new Barrier(parts.Length, b => {\n                Console.WriteLine($\"{robots[r]} assembled. Hello, {robots[r]}!\");\n                Console.WriteLine();\n                r++;\n            });\n            var tasks = parts.Select(part => BuildPart(checkpoint, part, robots)).ToArray();\n            return Task.WhenAll(tasks);\n        }\n\n        private static int GetTime()\n        {\n            \n            \n            lock (key) {\n                return rng.Next(100, 1000);\n            }\n        }\n\n        private async Task BuildPart(Barrier barrier, string part, string[] robots)\n        {\n            foreach (var robot in robots) {\n                int time = GetTime();\n                Console.WriteLine($\"Constructing {part} for {robot}. This will take {time}ms.\");\n                await Task.Delay(time);\n                Console.WriteLine($\"{part} for {robot} finished.\");\n                barrier.SignalAndWait();\n            }\n        }\n\n    }\n    \n}\n"}
{"id": 18510, "name": "Checkpoint synchronization", "source": "Translate Ruby to Java: require 'socket'\n\n\n\n\n\n\n\n\n\n\n\n\n\nclass Workshop\n  \n  def initialize\n    @sockets = {}\n  end\n\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  def add\n    child, parent = UNIXSocket.pair\n\n    wid = fork do\n      \n      child.close\n      @sockets.each_value { |sibling| sibling.close }\n\n      \n      \n      Signal.trap(\"INT\") { exit! }\n\n      loop do\n        \n        begin\n          command, args = Marshal.load(parent)\n        rescue EOFError\n          \n          break\n        end\n\n        case command\n        when :work\n          \n          result = yield *args\n          Marshal.dump(result, parent)\n        when :remove\n          break\n        else\n          fail \"bad command from workshop\"\n        end\n      end\n    end\n\n    \n    parent.close\n    @sockets[wid] = child\n    wid\n  end\n\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  def work(*args)\n    message = [:work, args]\n    @sockets.each_pair do |wid, child|\n      Marshal.dump(message, child)\n    end\n\n    \n    result = {}\n    @sockets.each_pair do |wid, child|\n      begin\n        \n        result[wid] = Marshal.load(child)\n      rescue EOFError\n        fail \"Worker \n      end\n    end\n    result\n  end\n\n  \n  \n  \n  \n  def remove(wid)\n    unless child = @sockets.delete(wid)\n      raise ArgumentError, \"No worker \n    else\n      Marshal.dump([:remove, nil], child)\n      child.close\n      Process.wait(wid)\n    end\n  end\nend\n\n\n\n\nrequire 'pp'\nshop = Workshop.new\nwids = []\n\n\n@fixed_rand = false\ndef fix_rand\n  unless @fixed_rand; srand; @fixed_rand = true; end\nend\n\n\n6.times do\n  wids << shop.add do |i|\n    \n    fix_rand\n    f = proc { |n| if n < 2 then n else f[n - 1] + f[n - 2] end }\n    [i, f[25 + rand(10)]]\n  end\nend\n\n6.times do |i|\n  \n  pp shop.work(i)\n\n  \n  victim = rand(wids.length)\n  shop.remove wids[victim]\n  wids.slice! victim\n\n  \n  wids << shop.add do |j|\n    \n    \n    fix_rand\n    f = proc { |n| if n < 3 then n else f[n - 1] + f[n - 2] + f[n - 3] end }\n    [j, i, f[20 + rand(10)]]\n  end\nend\n\n\nwids.each { |wid| shop.remove wid }\npp shop.work(6)\n", "target": "import java.util.Scanner;\nimport java.util.Random;\n\npublic class CheckpointSync{\n\tpublic static void main(String[] args){\n\t\tSystem.out.print(\"Enter number of workers to use: \");\n\t\tScanner in = new Scanner(System.in);\n\t\tWorker.nWorkers = in.nextInt();\n\t\tSystem.out.print(\"Enter number of tasks to complete:\");\n\t\trunTasks(in.nextInt());\n\t}\n\t\n\t\n\tprivate static void runTasks(int nTasks){\n\t\tfor(int i = 0; i < nTasks; i++){\n\t\t\tSystem.out.println(\"Starting task number \" + (i+1) + \".\");\n\t\t\trunThreads();\n\t\t\tWorker.checkpoint();\n\t\t}\n\t}\n\t\n\t\n\tprivate static void runThreads(){\n\t\tfor(int i = 0; i < Worker.nWorkers; i ++){\n\t\t\tnew Thread(new Worker(i+1)).start();\n\t\t}\n\t}\n\t\n\t\n\tpublic static class Worker implements Runnable{\n\t\tpublic Worker(int threadID){\n\t\t\tthis.threadID = threadID;\n\t\t}\n\t\tpublic void run(){\n\t\t\twork();\n\t\t}\n\t\t\n\t\t\n\t\tprivate synchronized void work(){\n\t\t\ttry {\n\t\t\t\tint workTime = rgen.nextInt(900) + 100;\n\t\t\t\tSystem.out.println(\"Worker \" + threadID + \" will work for \" + workTime + \" msec.\");\n\t\t\t\tThread.sleep(workTime); \n\t\t\t\tnFinished++; \n\t\t\t\tSystem.out.println(\"Worker \" + threadID + \" is ready\");\n\t\t\t} catch (InterruptedException e) {\n\t\t\t\tSystem.err.println(\"Error: thread execution interrupted\");\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t}\n\t\t\n\t\t\n\t\tpublic static synchronized void checkpoint(){\n\t\t\twhile(nFinished != nWorkers){\n\t\t\t\ttry {\n\t\t\t\t\tThread.sleep(10);\n\t\t\t\t} catch (InterruptedException e) {\n\t\t\t\t\tSystem.err.println(\"Error: thread execution interrupted\");\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t}\n\t\t\t}\n\t\t\tnFinished = 0;\n\t\t}\n\t\n\t\t\n\t\tprivate int threadID;\n\t\t\n\t\t\n\t\tprivate static Random rgen = new Random();\n\t\tprivate static int nFinished = 0;\n\t\tpublic static int nWorkers = 0;\n\t}\n}\n"}
{"id": 18511, "name": "Checkpoint synchronization", "source": "Translate Ruby to Python: require 'socket'\n\n\n\n\n\n\n\n\n\n\n\n\n\nclass Workshop\n  \n  def initialize\n    @sockets = {}\n  end\n\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  def add\n    child, parent = UNIXSocket.pair\n\n    wid = fork do\n      \n      child.close\n      @sockets.each_value { |sibling| sibling.close }\n\n      \n      \n      Signal.trap(\"INT\") { exit! }\n\n      loop do\n        \n        begin\n          command, args = Marshal.load(parent)\n        rescue EOFError\n          \n          break\n        end\n\n        case command\n        when :work\n          \n          result = yield *args\n          Marshal.dump(result, parent)\n        when :remove\n          break\n        else\n          fail \"bad command from workshop\"\n        end\n      end\n    end\n\n    \n    parent.close\n    @sockets[wid] = child\n    wid\n  end\n\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  def work(*args)\n    message = [:work, args]\n    @sockets.each_pair do |wid, child|\n      Marshal.dump(message, child)\n    end\n\n    \n    result = {}\n    @sockets.each_pair do |wid, child|\n      begin\n        \n        result[wid] = Marshal.load(child)\n      rescue EOFError\n        fail \"Worker \n      end\n    end\n    result\n  end\n\n  \n  \n  \n  \n  def remove(wid)\n    unless child = @sockets.delete(wid)\n      raise ArgumentError, \"No worker \n    else\n      Marshal.dump([:remove, nil], child)\n      child.close\n      Process.wait(wid)\n    end\n  end\nend\n\n\n\n\nrequire 'pp'\nshop = Workshop.new\nwids = []\n\n\n@fixed_rand = false\ndef fix_rand\n  unless @fixed_rand; srand; @fixed_rand = true; end\nend\n\n\n6.times do\n  wids << shop.add do |i|\n    \n    fix_rand\n    f = proc { |n| if n < 2 then n else f[n - 1] + f[n - 2] end }\n    [i, f[25 + rand(10)]]\n  end\nend\n\n6.times do |i|\n  \n  pp shop.work(i)\n\n  \n  victim = rand(wids.length)\n  shop.remove wids[victim]\n  wids.slice! victim\n\n  \n  wids << shop.add do |j|\n    \n    \n    fix_rand\n    f = proc { |n| if n < 3 then n else f[n - 1] + f[n - 2] + f[n - 3] end }\n    [j, i, f[20 + rand(10)]]\n  end\nend\n\n\nwids.each { |wid| shop.remove wid }\npp shop.work(6)\n", "target": "\n\nimport threading\nimport time\nimport random\n\n\ndef worker(workernum, barrier):\n    \n    sleeptime = random.random()\n    print('Starting worker '+str(workernum)+\" task 1, sleeptime=\"+str(sleeptime))\n    time.sleep(sleeptime)\n    print('Exiting worker'+str(workernum))\n    barrier.wait()\n    \n    sleeptime = random.random()\n    print('Starting worker '+str(workernum)+\" task 2, sleeptime=\"+str(sleeptime))\n    time.sleep(sleeptime)\n    print('Exiting worker'+str(workernum))\n\nbarrier = threading.Barrier(3)\n\nw1 = threading.Thread(target=worker, args=((1,barrier)))\nw2 = threading.Thread(target=worker, args=((2,barrier)))\nw3 = threading.Thread(target=worker, args=((3,barrier)))\n\nw1.start()\nw2.start()\nw3.start()\n"}
{"id": 18717, "name": "Arithmetic_Complex", "source": "Translate Ruby to C#: \na = Complex(1, 1)       \ni = Complex::I          \nb = 3.14159 + 1.25 * i\nc = '1/2+3/4i'.to_c     \nc =  1.0/2+3/4i         \n\n\nputs a + b              \nputs a * b              \nputs -a                 \nputs 1.quo a            \nputs a.conjugate        \nputs a.conj             \n", "target": "namespace RosettaCode.Arithmetic.Complex\n{\n    using System;\n    using System.Numerics;\n\n    internal static class Program\n    {\n        private static void Main()\n        {\n            var number = Complex.ImaginaryOne;\n            foreach (var result in new[] { number + number, number * number, -number, 1 / number, Complex.Conjugate(number) })\n            {\n                Console.WriteLine(result);\n            }\n        }\n    }\n}\n"}
{"id": 18719, "name": "Arithmetic_Complex", "source": "Translate Ruby to Java: \na = Complex(1, 1)       \ni = Complex::I          \nb = 3.14159 + 1.25 * i\nc = '1/2+3/4i'.to_c     \nc =  1.0/2+3/4i         \n\n\nputs a + b              \nputs a * b              \nputs -a                 \nputs 1.quo a            \nputs a.conjugate        \nputs a.conj             \n", "target": "public class Complex {\n    public final double real;\n    public final double imag;\n\n    public Complex() {\n        this(0, 0);\n    }\n\n    public Complex(double r, double i) {\n        real = r;\n        imag = i;\n    }\n\n    public Complex add(Complex b) {\n        return new Complex(this.real + b.real, this.imag + b.imag);\n    }\n\n    public Complex mult(Complex b) {\n        \n        return new Complex(this.real * b.real - this.imag * b.imag,\n                this.real * b.imag + this.imag * b.real);\n    }\n\n    public Complex inv() {\n        \n        double denom = real * real + imag * imag;\n        return new Complex(real / denom, -imag / denom);\n    }\n\n    public Complex neg() {\n        return new Complex(-real, -imag);\n    }\n\n    public Complex conj() {\n        return new Complex(real, -imag);\n    }\n\n    @Override\n    public String toString() {\n        return real + \" + \" + imag + \" * i\";\n    }\n\n    public static void main(String[] args) {\n        Complex a = new Complex(Math.PI, -5); \n        Complex b = new Complex(-1, 2.5);\n        System.out.println(a.neg());\n        System.out.println(a.add(b));\n        System.out.println(a.inv());\n        System.out.println(a.mult(b));\n        System.out.println(a.conj());\n    }\n}\n"}
{"id": 18720, "name": "Arithmetic_Complex", "source": "Translate Ruby to Python: \na = Complex(1, 1)       \ni = Complex::I          \nb = 3.14159 + 1.25 * i\nc = '1/2+3/4i'.to_c     \nc =  1.0/2+3/4i         \n\n\nputs a + b              \nputs a * b              \nputs -a                 \nputs 1.quo a            \nputs a.conjugate        \nputs a.conj             \n", "target": ">>> z1 = 1.5 + 3j\n>>> z2 = 1.5 + 1.5j\n>>> z1 + z2\n(3+4.5j)\n>>> z1 - z2\n1.5j\n>>> z1 * z2\n(-2.25+6.75j)\n>>> z1 / z2\n(1.5+0.5j)\n>>> - z1\n(-1.5-3j)\n>>> z1.conjugate()\n(1.5-3j)\n>>> abs(z1)\n3.3541019662496847\n>>> z1 ** z2\n(-1.1024829553277784-0.38306415117199333j)\n>>> z1.real\n1.5\n>>> z1.imag\n3.0\n>>>\n"}
{"id": 18935, "name": "Walk a directory_Recursively", "source": "Translate Ruby to C#: require 'find'\n\nFind.find('/your/path') do |f|\n   \n   puts f if f.match(/\\.mp3\\Z/)\nend\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.IO;\nusing System.Linq;\n\nnamespace RosettaRecursiveDirectory\n{\n    class Program\n    {\n        static IEnumerable<FileInfo> TraverseDirectory(string rootPath, Func<FileInfo, bool> Pattern)\n        {\n            var directoryStack = new Stack<DirectoryInfo>();\n            directoryStack.Push(new DirectoryInfo(rootPath));\n            while (directoryStack.Count > 0)\n            {\n                var dir = directoryStack.Pop();\n                try\n                {\n                    foreach (var i in dir.GetDirectories())\n                        directoryStack.Push(i);\n                }\n                catch (UnauthorizedAccessException) {\n                    continue; \n                }\n                foreach (var f in dir.GetFiles().Where(Pattern)) \n                    yield return f;\n            }\n        }\n        static void Main(string[] args)\n        {\n            \n            foreach (var file in TraverseDirectory(@\"C:\\Windows\", f => f.Extension == \".wmv\"))\n                Console.WriteLine(file.FullName);\n            Console.WriteLine(\"Done.\");\n        }\n    }\n}\n"}
{"id": 18937, "name": "Walk a directory_Recursively", "source": "Translate Ruby to Java: require 'find'\n\nFind.find('/your/path') do |f|\n   \n   puts f if f.match(/\\.mp3\\Z/)\nend\n", "target": "import java.io.File;\n\npublic class MainEntry {\n    public static void main(String[] args) {\n        walkin(new File(\"/home/user\")); \n    }\n    \n    \n    public static void walkin(File dir) {\n        String pattern = \".mp3\";\n        \n        File listFile[] = dir.listFiles();\n        if (listFile != null) {\n            for (int i=0; i<listFile.length; i++) {\n                if (listFile[i].isDirectory()) {\n                    walkin(listFile[i]);\n                } else {\n                    if (listFile[i].getName().endsWith(pattern)) {\n                        System.out.println(listFile[i].getPath());\n                    }\n                }\n            }\n        }\n    }\n}\n"}
{"id": 18938, "name": "Walk a directory_Recursively", "source": "Translate Ruby to Python: require 'find'\n\nFind.find('/your/path') do |f|\n   \n   puts f if f.match(/\\.mp3\\Z/)\nend\n", "target": "from pathlib import Path\n\nfor path in Path('.').rglob('*.*'):\n    print(path)\n"}
{"id": 19102, "name": "Keyboard input_Keypress check", "source": "Translate Ruby to C#: begin\n  check = STDIN.read_nonblock(1)\nrescue IO::WaitReadable\n  check = false\nend\n\nputs check if check\n", "target": "string chr = string.Empty;\nif(Console.KeyAvailable)\n  chr = Console.ReadKey().Key.ToString();\n"}
{"id": 19103, "name": "Keyboard input_Keypress check", "source": "Translate Ruby to Java: begin\n  check = STDIN.read_nonblock(1)\nrescue IO::WaitReadable\n  check = false\nend\n\nputs check if check\n", "target": "import java.awt.event.*;\nimport javax.swing.*;\n\npublic class Test extends JFrame {\n\n    Test() {\n        addKeyListener(new KeyAdapter() {\n            @Override\n            public void keyPressed(KeyEvent e) {\n                int keyCode = e.getKeyCode();\n                System.out.println(keyCode);\n            }\n        });\n    }\n\n    public static void main(String[] args) {\n        SwingUtilities.invokeLater(() -> {\n            Test f = new Test();\n            f.setFocusable(true);\n            f.setVisible(true);\n        });\n    }\n}\n"}
{"id": 19104, "name": "Keyboard input_Keypress check", "source": "Translate Ruby to Python: begin\n  check = STDIN.read_nonblock(1)\nrescue IO::WaitReadable\n  check = false\nend\n\nputs check if check\n", "target": "\n\nfrom __future__ import absolute_import, division, unicode_literals, print_function\n\nimport tty, termios\nimport sys\nif sys.version_info.major < 3:\n    import thread as _thread\nelse:\n    import _thread\nimport time\n\n\ntry:\n    from msvcrt import getch  \nexcept ImportError:\n    def getch():   \n        fd = sys.stdin.fileno()\n        old_settings = termios.tcgetattr(fd)\n        try:\n            tty.setraw(sys.stdin.fileno())\n            ch = sys.stdin.read(1)\n        finally:\n            termios.tcsetattr(fd, termios.TCSADRAIN, old_settings)\n        return ch\n\ndef keypress():\n    global char\n    char = getch()\n\ndef main():\n    global char\n    char = None\n    _thread.start_new_thread(keypress, ())\n\n    while True:\n        if char is not None:\n            try:\n                print(\"Key pressed is \" + char.decode('utf-8'))\n            except UnicodeDecodeError:\n                print(\"character can not be decoded, sorry!\")\n                char = None\n            _thread.start_new_thread(keypress, ())\n            if char == 'q' or char == '\\x1b':  \n                exit()\n            char = None\n        print(\"Program is running\")\n        time.sleep(1)\n\nif __name__ == \"__main__\":\n    main()\n"}
{"id": 19262, "name": "Deal cards for FreeCell", "source": "Translate Ruby to C#: \n\nbegin\n  games = ARGV.map {|s| Integer(s)}\nrescue => err\n  $stderr.puts err.inspect\n  $stderr.puts \"Usage: \n  abort\nend\ngames.empty? and games = [rand(32000)]\n\n\norig_deck = %w{A 2 3 4 5 6 7 8 9 T J Q K}.product(%w{C D H S}).map(&:join)\n\ngames.each do |seed|\n  deck = orig_deck.dup\n  \n  \n  \n  state = seed\n  52.downto(2) do |len|\n    state = ((214013 * state) + 2531011) & 0x7fff_ffff\n    index = (state >> 16) % len\n    last = len - 1\n    deck[index], deck[last] = deck[last], deck[index]\n  end\n  \n  deck.reverse!  \n  \n  \n  puts \"Game \n  deck.each_slice(8) {|row| puts \" \" + row.join(\" \")}\n  puts\nend\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Text;\n\nnamespace FreeCellDeals\n{\n    public class RNG\n    {\n        private int _state;\n\n        public RNG()\n        {\n            _state = (int)DateTime.Now.Ticks;\n        }\n\n        public RNG(int n)\n        {\n            _state = n;\n        }\n        public int Next()\n        {\n            return ((_state = 214013 * _state + 2531011) & int.MaxValue) >> 16;\n        }\n    }\n\n    public enum Rank\n    {\n        Ace,\n        One,\n        Two,\n        Three,\n        Four,\n        Five,\n        Six,\n        Seven,\n        Eight,\n        Nine,\n        Ten,\n        Jack,\n        Queen,\n        King\n    }\n\n    public enum Suit\n    {\n        Clubs,\n        Diamonds,\n        Hearts,\n        Spades\n    }\n\n    public class Card\n    {\n        private const string Ranks = \"A23456789TJQK\";\n        private const string Suits = \"CDHS\";\n\n        private Rank _rank;\n        public Rank Rank\n        {\n            get\n            {\n                return _rank;\n            }\n            set\n            {\n                if ((int)value < 0 || (int)value > 12)\n                {\n                    throw new InvalidOperationException(\"Setting card rank out of range\");\n                }\n                _rank = value;\n            }\n        }\n\n        private Suit _suit;\n        public Suit Suit\n        {\n            get\n            {\n                return _suit;\n            }\n            set\n            {\n                if ((int)value < 0 || (int)value > 3)\n                {\n                    throw new InvalidOperationException(\"Setting card rank out of range\");\n                }\n                _suit = value;\n            }\n        }\n\n        public Card(Rank rank, Suit suit)\n        {\n            Rank = rank;\n            Suit = suit;\n        }\n\n        public int NRank()\n        {\n            return (int) Rank;\n        }\n\n        public int NSuit()\n        {\n            return (int) Suit;\n        }\n\n        public override string ToString()\n        {\n            return new string(new[] {Ranks[NRank()], Suits[NSuit()]});\n        }\n    }\n\n    public class FreeCellDeal\n    {\n        public List<Card> Deck { get; private set; }\n\n        public FreeCellDeal(int iDeal)\n        {\n            RNG rng = new RNG(iDeal);\n\n            List<Card> rDeck = new List<Card>();\n            Deck = new List<Card>();\n\n            for (int rank = 0; rank < 13; rank++)\n            {\n                for (int suit = 0; suit < 4; suit++)\n                {\n                    rDeck.Add(new Card((Rank)rank, (Suit)suit));\n                }\n            }\n\n            \n            \n            for (int iCard = 51; iCard >= 0; iCard--)\n            {\n                int iSwap = rng.Next() % (iCard + 1);\n                Deck.Add(rDeck[iSwap]);\n                rDeck[iSwap] = rDeck[iCard];\n            }\n        }\n\n        public override string ToString()\n        {\n            StringBuilder sb = new StringBuilder();\n            for (int iRow = 0; iRow < 6; iRow++ )\n            {\n                for (int iCol = 0; iCol < 8; iCol++)\n                {\n                    sb.AppendFormat(\"{0} \", Deck[iRow * 8 + iCol]);\n                }\n                sb.Append(\"\\n\");\n            }\n            for (int iCard = 48; iCard < 52; iCard++)\n            {\n                sb.AppendFormat(\"{0} \", Deck[iCard]);\n            }\n            return sb.ToString();\n        }\n    }\n\n    class Program\n    {\n        static void Main()\n        {\n            Console.WriteLine(new FreeCellDeal(1));\n            Console.WriteLine();\n            Console.WriteLine(new FreeCellDeal(617));\n        }\n    }\n}\n"}
{"id": 19264, "name": "Deal cards for FreeCell", "source": "Translate Ruby to Java: \n\nbegin\n  games = ARGV.map {|s| Integer(s)}\nrescue => err\n  $stderr.puts err.inspect\n  $stderr.puts \"Usage: \n  abort\nend\ngames.empty? and games = [rand(32000)]\n\n\norig_deck = %w{A 2 3 4 5 6 7 8 9 T J Q K}.product(%w{C D H S}).map(&:join)\n\ngames.each do |seed|\n  deck = orig_deck.dup\n  \n  \n  \n  state = seed\n  52.downto(2) do |len|\n    state = ((214013 * state) + 2531011) & 0x7fff_ffff\n    index = (state >> 16) % len\n    last = len - 1\n    deck[index], deck[last] = deck[last], deck[index]\n  end\n  \n  deck.reverse!  \n  \n  \n  puts \"Game \n  deck.each_slice(8) {|row| puts \" \" + row.join(\" \")}\n  puts\nend\n", "target": "import java.util.Arrays;\n\npublic class Shuffler {\n\t\n\tprivate int seed;\n\t\n\tprivate String[] deck = {\n\t\t\t\"AC\", \"AD\", \"AH\", \"AS\",\n\t\t\t\"2C\", \"2D\", \"2H\", \"2S\",\n\t\t\t\"3C\", \"3D\", \"3H\", \"3S\",\n\t\t\t\"4C\", \"4D\", \"4H\", \"4S\",\n\t\t\t\"5C\", \"5D\", \"5H\", \"5S\",\n\t\t\t\"6C\", \"6D\", \"6H\", \"6S\",\n\t\t\t\"7C\", \"7D\", \"7H\", \"7S\",\n\t\t\t\"8C\", \"8D\", \"8H\", \"8S\",\n\t\t\t\"9C\", \"9D\", \"9H\", \"9S\",\n\t\t\t\"TC\", \"TD\", \"TH\", \"TS\",\n\t\t\t\"JC\", \"JD\", \"JH\", \"JS\",\n\t\t\t\"QC\", \"QD\", \"QH\", \"QS\",\n\t\t\t\"KC\", \"KD\", \"KH\", \"KS\",\n\t};\n\t\n\tprivate int random() {\n\t\tseed = (214013 * seed + 2531011) & Integer.MAX_VALUE;\n\t\treturn seed >> 16;\n\t}\n\t\n\t\n\tprivate String[] getShuffledDeck() {\n\t\tString[] deck = Arrays.copyOf(this.deck, this.deck.length);\n\t\tfor(int i = deck.length - 1; i > 0; i--) {\n\t\t\tint r = random() % (i + 1);\n\t\t\tString card = deck[r];\n\t\t\tdeck[r] = deck[i];\n\t\t\tdeck[i] = card;\n\t\t}\n\t\treturn deck;\n\t}\n\t\n\t\n\tpublic void dealGame(int seed) {\n\t\tthis.seed = seed;\n\t\tString[] shuffledDeck = getShuffledDeck();\n\t\tfor(int count = 1, i = shuffledDeck.length - 1; i >= 0; count++, i--) {\n\t\t\tSystem.out.print(shuffledDeck[i]);\n\t\t\tif(count % 8 == 0) {\n\t\t\t\tSystem.out.println();\n\t\t\t} else {\n\t\t\t\tSystem.out.print(\" \");\n\t\t\t}\n\t\t}\n\t\tSystem.out.println();\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tShuffler s = new Shuffler();\n\t\ts.dealGame(1);\n\t\tSystem.out.println();\n\t\ts.dealGame(617);\n\t}\n\t\n}\n"}
{"id": 19265, "name": "Deal cards for FreeCell", "source": "Translate Ruby to Python: \n\nbegin\n  games = ARGV.map {|s| Integer(s)}\nrescue => err\n  $stderr.puts err.inspect\n  $stderr.puts \"Usage: \n  abort\nend\ngames.empty? and games = [rand(32000)]\n\n\norig_deck = %w{A 2 3 4 5 6 7 8 9 T J Q K}.product(%w{C D H S}).map(&:join)\n\ngames.each do |seed|\n  deck = orig_deck.dup\n  \n  \n  \n  state = seed\n  52.downto(2) do |len|\n    state = ((214013 * state) + 2531011) & 0x7fff_ffff\n    index = (state >> 16) % len\n    last = len - 1\n    deck[index], deck[last] = deck[last], deck[index]\n  end\n  \n  deck.reverse!  \n  \n  \n  puts \"Game \n  deck.each_slice(8) {|row| puts \" \" + row.join(\" \")}\n  puts\nend\n", "target": "def randomGenerator(seed=1):\n    max_int32 = (1 << 31) - 1\n    seed = seed & max_int32\n\n    while True:\n        seed = (seed * 214013 + 2531011) & max_int32\n        yield seed >> 16\n\ndef deal(seed):\n    nc = 52\n    cards = list(range(nc - 1, -1, -1))\n    rnd = randomGenerator(seed)\n    for i, r in zip(range(nc), rnd):\n        j = (nc - 1) - r % (nc - i)\n        cards[i], cards[j] = cards[j], cards[i]\n    return cards\n\ndef show(cards):\n    l = [\"A23456789TJQK\"[int(c/4)] + \"CDHS\"[c%4] for c in cards]\n    for i in range(0, len(cards), 8):\n        print(\" \".join(l[i : i+8]))\n\nif __name__ == '__main__':\n    from sys import argv\n    seed = int(argv[1]) if len(argv) == 2 else 11982\n    print(\"Hand {}\".format(seed))\n    deck = deal(seed)\n    show(deck)\n"}
{"id": 19460, "name": "Handle a signal", "source": "Translate Ruby to C#: start = Time.utc\nch = Channel(Int32 | Symbol).new\n\nspawn do\n  i = 0\n  loop do\n    sleep 1\n    ch.send(i += 1)\n  end\nend\n\nSignal::INT.trap do\n  Signal::INT.reset\n  ch.send(:kill)\nend\n\nloop do\n  x = ch.receive\n  break if x == :kill\n  puts x\nend\n\nelapsed = Time.utc - start\nputs \"Program has run for %5.3f seconds.\" % elapsed.total_seconds\n", "target": "using System; \nclass Program\n{\n    static DateTime start;\n    static void Main(string[] args)\n    {\n        start = DateTime.Now;\n        \n        Console.CancelKeyPress += new ConsoleCancelEventHandler(Console_CancelKeyPress);\n        int counter = 0;\n        while (true)\n        {\n            Console.WriteLine(++counter);\n            System.Threading.Thread.Sleep(500);\n        }\n    }\n    static void Console_CancelKeyPress(object sender, ConsoleCancelEventArgs e)\n    {\n        var end = DateTime.Now;\n        Console.WriteLine(\"This program ran for {0:000.000} seconds.\", (end - start).TotalMilliseconds / 1000);\n        Environment.Exit(0);\n    }\n}\n"}
{"id": 19462, "name": "Handle a signal", "source": "Translate Ruby to Java: start = Time.utc\nch = Channel(Int32 | Symbol).new\n\nspawn do\n  i = 0\n  loop do\n    sleep 1\n    ch.send(i += 1)\n  end\nend\n\nSignal::INT.trap do\n  Signal::INT.reset\n  ch.send(:kill)\nend\n\nloop do\n  x = ch.receive\n  break if x == :kill\n  puts x\nend\n\nelapsed = Time.utc - start\nputs \"Program has run for %5.3f seconds.\" % elapsed.total_seconds\n", "target": "import sun.misc.Signal;\nimport sun.misc.SignalHandler;\n\npublic class ExampleSignalHandler {\n    public static void main(String... args) throws InterruptedException {\n        final long start = System.nanoTime();\n        Signal.handle(new Signal(\"INT\"), new SignalHandler() {\n            public void handle(Signal sig) {\n                System.out.format(\"\\nProgram execution took %f seconds\\n\", (System.nanoTime() - start) / 1e9f);\n                System.exit(0);\n            }\n        });\n        int counter = 0;\n        while(true) {\n            System.out.println(counter++);\n            Thread.sleep(500);\n        }\n    }\n}\n"}
{"id": 19463, "name": "Handle a signal", "source": "Translate Ruby to Python: start = Time.utc\nch = Channel(Int32 | Symbol).new\n\nspawn do\n  i = 0\n  loop do\n    sleep 1\n    ch.send(i += 1)\n  end\nend\n\nSignal::INT.trap do\n  Signal::INT.reset\n  ch.send(:kill)\nend\n\nloop do\n  x = ch.receive\n  break if x == :kill\n  puts x\nend\n\nelapsed = Time.utc - start\nputs \"Program has run for %5.3f seconds.\" % elapsed.total_seconds\n", "target": "import time\n\ndef counter():\n    n = 0\n    t1 = time.time()\n    while True:\n        try:\n            time.sleep(0.5)\n            n += 1\n            print n\n        except KeyboardInterrupt, e:\n            print 'Program has run for %5.3f seconds.' % (time.time() - t1)\n            break\n\ncounter()\n"}
{"id": 19676, "name": "Non-decimal radices_Output", "source": "Translate Ruby to C#: for n in 0..33\n  puts \" %6b %3o %2d %2X\" % [n, n, n, n]\nend\nputs\n[2,8,10,16,36].each {|i| puts \" 100.to_s(\n", "target": "using System;\n\nnamespace NonDecimalRadicesOutput\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            for (int i = 0; i < 42; i++)\n            {\n                string binary = Convert.ToString(i, 2);\n                string octal = Convert.ToString(i, 8);\n                string hexadecimal = Convert.ToString(i, 16);\n                Console.WriteLine(string.Format(\"Decimal: {0}, Binary: {1}, Octal: {2}, Hexadecimal: {3}\", i, binary, octal, hexadecimal));\n            }\n\n            Console.ReadKey();\n        }\n    }\n}\n"}
{"id": 19678, "name": "Non-decimal radices_Output", "source": "Translate Ruby to Java: for n in 0..33\n  puts \" %6b %3o %2d %2X\" % [n, n, n, n]\nend\nputs\n[2,8,10,16,36].each {|i| puts \" 100.to_s(\n", "target": "public static void main(String args[]){\n   for(int a= 0;a < 33;a++){\n      System.out.println(Integer.toBinaryString(a));\n      System.out.println(Integer.toOctalString(a));\n      System.out.println(Integer.toHexString(a));\n      \n      \n\n      System.out.printf(\"%3o %2d %2x\\n\",a ,a ,a); \n   }\n}\n"}
{"id": 19679, "name": "Non-decimal radices_Output", "source": "Translate Ruby to Python: for n in 0..33\n  puts \" %6b %3o %2d %2X\" % [n, n, n, n]\nend\nputs\n[2,8,10,16,36].each {|i| puts \" 100.to_s(\n", "target": ">>> for n in range(34):\n  print \" {0:6b} {1:3o} {2:2d} {3:2X}\".format(n, n, n, n)\n  \n  \n  \n\n  \n      0   0  0  0\n      1   1  1  1\n     10   2  2  2\n     11   3  3  3\n    100   4  4  4\n    101   5  5  5\n    110   6  6  6\n    111   7  7  7\n   1000  10  8  8\n   1001  11  9  9\n   1010  12 10  A\n   1011  13 11  B\n   1100  14 12  C\n   1101  15 13  D\n   1110  16 14  E\n   1111  17 15  F\n  10000  20 16 10\n  10001  21 17 11\n  10010  22 18 12\n  10011  23 19 13\n  10100  24 20 14\n  10101  25 21 15\n  10110  26 22 16\n  10111  27 23 17\n  11000  30 24 18\n  11001  31 25 19\n  11010  32 26 1A\n  11011  33 27 1B\n  11100  34 28 1C\n  11101  35 29 1D\n  11110  36 30 1E\n  11111  37 31 1F\n 100000  40 32 20\n 100001  41 33 21\n>>>\n"}
{"id": 19869, "name": "Morse code", "source": "Translate Ruby to C#: require 'win32/sound'\n\nclass MorseCode\n  MORSE = {\n      \"!\" => \"---.\", \"\\\"\" => \".-..-.\", \"$\" => \"...-..-\", \"'\" => \".----.\",\n      \"(\" => \"-.--.\", \")\" => \"-.--.-\", \"+\" => \".-.-.\", \",\" => \"--..--\",\n      \"-\" => \"-....-\", \".\" => \".-.-.-\", \"/\" => \"-..-.\", \"0\" => \"-----\",\n      \"1\" => \".----\", \"2\" => \"..---\", \"3\" => \"...--\", \"4\" => \"....-\", \"5\" => \".....\",\n      \"6\" => \"-....\", \"7\" => \"--...\", \"8\" => \"---..\", \"9\" => \"----.\", \":\" => \"---...\",\n      \";\" => \"-.-.-.\", \"=\" => \"-...-\", \"?\" => \"..--..\", \"@\" => \".--.-.\", \"A\" => \".-\",\n      \"B\" => \"-...\", \"C\" => \"-.-.\", \"D\" => \"-..\", \"E\" => \".\", \"F\" => \"..-.\",\n      \"G\" => \"--.\", \"H\" => \"....\", \"I\" => \"..\", \"J\" => \".---\", \"K\" => \"-.-\",\n      \"L\" => \".-..\", \"M\" => \"--\", \"N\" => \"-.\", \"O\" => \"---\", \"P\" => \".--.\",\n      \"Q\" => \"--.-\", \"R\" => \".-.\", \"S\" => \"...\", \"T\" => \"-\", \"U\" => \"..-\",\n      \"V\" => \"...-\", \"W\" => \".--\", \"X\" => \"-..-\", \"Y\" => \"-.--\", \"Z\" => \"--..\",\n      \"[\" => \"-.--.\", \"]\" => \"-.--.-\", \"_\" => \"..--.-\",\n  }\n\n  T_UNIT = 75 \n  FREQ = 700\n  DIT = 1 * T_UNIT\n  DAH = 3 * T_UNIT\n  CHARGAP = 1 * T_UNIT\n  WORDGAP = 7 * T_UNIT\n\n  def initialize(string)\n    @message = string\n    puts \"your message is \n  end\n\n  def send\n    @message.strip.upcase.split.each do |word|\n      word.each_char do |char|\n        send_char char\n        pause CHARGAP\n        print \" \"\n      end\n      pause WORDGAP\n      puts \"\"\n    end\n  end\n\n  private\n  def send_char(char)\n    MORSE[char].each_char do |code|\n      case code\n      when '.' then beep DIT\n      when '-' then beep DAH\n      end\n      pause CHARGAP\n      print code\n    end\n  end\n\n  def beep(ms)\n    ::Win32::Sound.beep(FREQ, ms)\n  end\n\n  def pause(ms)\n    sleep(ms.to_f/1000.0)\n  end\nend\n\nMorseCode.new('sos').send\nMorseCode.new('this is a test.').send\n", "target": "using System;\nusing System.Collections.Generic;\n\nnamespace Morse\n{\n    class Morse\n    {\n        static void Main(string[] args)\n        {\n            string word = \"sos\";\n            Dictionary<string, string> Codes = new Dictionary<string, string>\n            {\n                {\"a\", \".-   \"}, {\"b\", \"-... \"}, {\"c\", \"-.-. \"}, {\"d\", \"-..  \"}, \n                {\"e\", \".    \"}, {\"f\", \"..-. \"}, {\"g\", \"--.  \"}, {\"h\", \".... \"},\n                {\"i\", \"..   \"}, {\"j\", \".--- \"}, {\"k\", \"-.-  \"}, {\"l\", \".-.. \"},\n                {\"m\", \"--   \"}, {\"n\", \"-.   \"}, {\"o\", \"---  \"}, {\"p\", \".--. \"}, \n                {\"q\", \"--.- \"}, {\"r\", \".-.  \"}, {\"s\", \"...  \"}, {\"t\", \"-    \"}, \n                {\"u\", \"..-  \"}, {\"v\", \"...- \"}, {\"w\", \".--  \"}, {\"x\", \"-..- \"}, \n                {\"y\", \"-.-- \"}, {\"z\", \"--.. \"}, {\"0\", \"-----\"}, {\"1\", \".----\"}, \n                {\"2\", \"..---\"}, {\"3\", \"...--\"}, {\"4\", \"....-\"}, {\"5\", \".....\"}, \n                {\"6\", \"-....\"}, {\"7\", \"--...\"}, {\"8\", \"---..\"}, {\"9\", \"----.\"}    \n            };\n\n            foreach (char c in word.ToCharArray())\n            {\n                string rslt = Codes[c.ToString()].Trim();\n                foreach (char c2 in rslt.ToCharArray())\n                {\n                    if (c2 == '.')\n                        Console.Beep(1000, 250);\n                    else\n                        Console.Beep(1000, 750);\n                }\n                System.Threading.Thread.Sleep(50);\n            }\n        }\n    }\n}\n"}
{"id": 19870, "name": "Morse code", "source": "Translate Ruby to Python: require 'win32/sound'\n\nclass MorseCode\n  MORSE = {\n      \"!\" => \"---.\", \"\\\"\" => \".-..-.\", \"$\" => \"...-..-\", \"'\" => \".----.\",\n      \"(\" => \"-.--.\", \")\" => \"-.--.-\", \"+\" => \".-.-.\", \",\" => \"--..--\",\n      \"-\" => \"-....-\", \".\" => \".-.-.-\", \"/\" => \"-..-.\", \"0\" => \"-----\",\n      \"1\" => \".----\", \"2\" => \"..---\", \"3\" => \"...--\", \"4\" => \"....-\", \"5\" => \".....\",\n      \"6\" => \"-....\", \"7\" => \"--...\", \"8\" => \"---..\", \"9\" => \"----.\", \":\" => \"---...\",\n      \";\" => \"-.-.-.\", \"=\" => \"-...-\", \"?\" => \"..--..\", \"@\" => \".--.-.\", \"A\" => \".-\",\n      \"B\" => \"-...\", \"C\" => \"-.-.\", \"D\" => \"-..\", \"E\" => \".\", \"F\" => \"..-.\",\n      \"G\" => \"--.\", \"H\" => \"....\", \"I\" => \"..\", \"J\" => \".---\", \"K\" => \"-.-\",\n      \"L\" => \".-..\", \"M\" => \"--\", \"N\" => \"-.\", \"O\" => \"---\", \"P\" => \".--.\",\n      \"Q\" => \"--.-\", \"R\" => \".-.\", \"S\" => \"...\", \"T\" => \"-\", \"U\" => \"..-\",\n      \"V\" => \"...-\", \"W\" => \".--\", \"X\" => \"-..-\", \"Y\" => \"-.--\", \"Z\" => \"--..\",\n      \"[\" => \"-.--.\", \"]\" => \"-.--.-\", \"_\" => \"..--.-\",\n  }\n\n  T_UNIT = 75 \n  FREQ = 700\n  DIT = 1 * T_UNIT\n  DAH = 3 * T_UNIT\n  CHARGAP = 1 * T_UNIT\n  WORDGAP = 7 * T_UNIT\n\n  def initialize(string)\n    @message = string\n    puts \"your message is \n  end\n\n  def send\n    @message.strip.upcase.split.each do |word|\n      word.each_char do |char|\n        send_char char\n        pause CHARGAP\n        print \" \"\n      end\n      pause WORDGAP\n      puts \"\"\n    end\n  end\n\n  private\n  def send_char(char)\n    MORSE[char].each_char do |code|\n      case code\n      when '.' then beep DIT\n      when '-' then beep DAH\n      end\n      pause CHARGAP\n      print code\n    end\n  end\n\n  def beep(ms)\n    ::Win32::Sound.beep(FREQ, ms)\n  end\n\n  def pause(ms)\n    sleep(ms.to_f/1000.0)\n  end\nend\n\nMorseCode.new('sos').send\nMorseCode.new('this is a test.').send\n", "target": "import time, winsound \n\nchar2morse = {          \n          \"!\": \"---.\",      \"\\\"\": \".-..-.\",     \"$\": \"...-..-\",    \"'\": \".----.\",  \n          \"(\": \"-.--.\",      \")\": \"-.--.-\",     \"+\": \".-.-.\",      \",\": \"--..--\", \n          \"-\": \"-....-\",     \".\": \".-.-.-\",     \"/\": \"-..-.\", \n          \"0\": \"-----\",      \"1\": \".----\",      \"2\": \"..---\",      \"3\": \"...--\", \n          \"4\": \"....-\",      \"5\": \".....\",      \"6\": \"-....\",      \"7\": \"--...\", \n          \"8\": \"---..\",      \"9\": \"----.\", \n          \":\": \"---...\",     \";\": \"-.-.-.\",     \"=\": \"-...-\",      \"?\": \"..--..\", \n          \"@\": \".--.-.\", \n          \"A\": \".-\",         \"B\": \"-...\",       \"C\": \"-.-.\",       \"D\": \"-..\", \n          \"E\": \".\",          \"F\": \"..-.\",       \"G\": \"--.\",        \"H\": \"....\", \n          \"I\": \"..\",         \"J\": \".---\",       \"K\": \"-.-\",        \"L\": \".-..\", \n          \"M\": \"--\",         \"N\": \"-.\",         \"O\": \"---\",        \"P\": \".--.\", \n          \"Q\": \"--.-\",       \"R\": \".-.\",        \"S\": \"...\",        \"T\": \"-\", \n          \"U\": \"..-\",        \"V\": \"...-\",       \"W\": \".--\",        \"X\": \"-..-\", \n          \"Y\": \"-.--\",       \"Z\": \"--..\", \n          \"[\": \"-.--.\",      \"]\": \"-.--.-\",     \"_\": \"..--.-\",\n }\n\ne = 50      \nf = 1280    \nchargap = 1 \nwordgap = 7 \n\ndef gap(n=1):\n    time.sleep(n * e / 1000)\noff = gap\n\ndef on(n=1):\n    winsound.Beep(f, n * e)\n\ndef dit():\n    on(); off()\n\ndef dah():\n    on(3); off()\n\ndef bloop(n=3):\n    winsound.Beep(f//2, n * e)\n\ndef windowsmorse(text):\n    for word in text.strip().upper().split():\n        for char in word:\n            for element in char2morse.get(char, '?'):\n                if element == '-':\n                    dah()\n                elif element == '.':\n                    dit()\n                else:\n                    bloop()\n            gap(chargap)\n        gap(wordgap)\n\n\n\n\n    \nwhile True:\n    windowsmorse(input('A string to change into morse: '))\n"}
{"id": 20022, "name": "Huffman coding", "source": "Translate Ruby to C#: require 'priority_queue'\n\ndef huffman_encoding(str)\n  char_count = Hash.new(0)\n  str.each_char {|c| char_count[c] += 1}\n  \n  pq = CPriorityQueue.new\n  \n  char_count.each {|char, count| pq.push(char, count)}\n  \n  while pq.length > 1\n    key1, prio1 = pq.delete_min\n    key2, prio2 = pq.delete_min\n    pq.push([key1, key2], prio1 + prio2)\n  end\n  \n  Hash[*generate_encoding(pq.min_key)]\nend\n\ndef generate_encoding(ary, prefix=\"\")\n  case ary\n  when Array\n    generate_encoding(ary[0], \"\n  else\n    [ary, prefix]\n  end\nend\n\ndef encode(str, encoding)\n  str.each_char.collect {|char| encoding[char]}.join\nend\n\ndef decode(encoded, encoding)\n  rev_enc = encoding.invert\n  decoded = \"\"\n  pos = 0\n  while pos < encoded.length\n    key = \"\"\n    while rev_enc[key].nil?\n      key << encoded[pos]\n      pos += 1\n    end\n    decoded << rev_enc[key]\n  end\n  decoded\nend\n\nstr = \"this is an example for huffman encoding\"\nencoding = huffman_encoding(str)\nencoding.to_a.sort.each {|x| p x}\n\nenc = encode(str, encoding)\ndec = decode(enc, encoding)\nputs \"success!\" if str == dec\n", "target": "using System;\nusing System.Collections.Generic;\n\nnamespace Huffman_Encoding\n{\n    public class PriorityQueue<T> where T : IComparable\n    {\n        protected List<T> LstHeap = new List<T>();\n\n        public virtual int Count\n        {\n            get { return LstHeap.Count; }\n        }\n\n        public virtual void Add(T val)\n        {\n            LstHeap.Add(val);\n            SetAt(LstHeap.Count - 1, val);\n            UpHeap(LstHeap.Count - 1);\n        }\n\n        public virtual T Peek()\n        {\n            if (LstHeap.Count == 0)\n            {\n                throw new IndexOutOfRangeException(\"Peeking at an empty priority queue\");\n            }\n\n            return LstHeap[0];\n        }\n\n        public virtual T Pop()\n        {\n            if (LstHeap.Count == 0)\n            {\n                throw new IndexOutOfRangeException(\"Popping an empty priority queue\");\n            }\n\n            T valRet = LstHeap[0];\n\n            SetAt(0, LstHeap[LstHeap.Count - 1]);\n            LstHeap.RemoveAt(LstHeap.Count - 1);\n            DownHeap(0);\n            return valRet;\n        }\n\n        protected virtual void SetAt(int i, T val)\n        {\n            LstHeap[i] = val;\n        }\n\n        protected bool RightSonExists(int i)\n        {\n            return RightChildIndex(i) < LstHeap.Count;\n        }\n\n        protected bool LeftSonExists(int i)\n        {\n            return LeftChildIndex(i) < LstHeap.Count;\n        }\n\n        protected int ParentIndex(int i)\n        {\n            return (i - 1) / 2;\n        }\n\n        protected int LeftChildIndex(int i)\n        {\n            return 2 * i + 1;\n        }\n\n        protected int RightChildIndex(int i)\n        {\n            return 2 * (i + 1);\n        }\n\n        protected T ArrayVal(int i)\n        {\n            return LstHeap[i];\n        }\n\n        protected T Parent(int i)\n        {\n            return LstHeap[ParentIndex(i)];\n        }\n\n        protected T Left(int i)\n        {\n            return LstHeap[LeftChildIndex(i)];\n        }\n\n        protected T Right(int i)\n        {\n            return LstHeap[RightChildIndex(i)];\n        }\n\n        protected void Swap(int i, int j)\n        {\n            T valHold = ArrayVal(i);\n            SetAt(i, LstHeap[j]);\n            SetAt(j, valHold);\n        }\n\n        protected void UpHeap(int i)\n        {\n            while (i > 0 && ArrayVal(i).CompareTo(Parent(i)) > 0)\n            {\n                Swap(i, ParentIndex(i));\n                i = ParentIndex(i);\n            }\n        }\n\n        protected void DownHeap(int i)\n        {\n            while (i >= 0)\n            {\n                int iContinue = -1;\n\n                if (RightSonExists(i) && Right(i).CompareTo(ArrayVal(i)) > 0)\n                {\n                    iContinue = Left(i).CompareTo(Right(i)) < 0 ? RightChildIndex(i) : LeftChildIndex(i);\n                }\n                else if (LeftSonExists(i) && Left(i).CompareTo(ArrayVal(i)) > 0)\n                {\n                    iContinue = LeftChildIndex(i);\n                }\n\n                if (iContinue >= 0 && iContinue < LstHeap.Count)\n                {\n                    Swap(i, iContinue);\n                }\n\n                i = iContinue;\n            }\n        }\n    }\n\n    internal class HuffmanNode<T> : IComparable\n    {\n        internal HuffmanNode(double probability, T value)\n        {\n            Probability = probability;\n            LeftSon = RightSon = Parent = null;\n            Value = value;\n            IsLeaf = true;\n        }\n\n        internal HuffmanNode(HuffmanNode<T> leftSon, HuffmanNode<T> rightSon)\n        {\n            LeftSon = leftSon;\n            RightSon = rightSon;\n            Probability = leftSon.Probability + rightSon.Probability;\n            leftSon.IsZero = true;\n            rightSon.IsZero = false;\n            leftSon.Parent = rightSon.Parent = this;\n            IsLeaf = false;\n        }\n\n        internal HuffmanNode<T> LeftSon { get; set; }\n        internal HuffmanNode<T> RightSon { get; set; }\n        internal HuffmanNode<T> Parent { get; set; }\n        internal T Value { get; set; }\n        internal bool IsLeaf { get; set; }\n\n        internal bool IsZero { get; set; }\n\n        internal int Bit\n        {\n            get { return IsZero ? 0 : 1; }\n        }\n\n        internal bool IsRoot\n        {\n            get { return Parent == null; }\n        }\n\n        internal double Probability { get; set; }\n\n        public int CompareTo(object obj)\n        {\n            return -Probability.CompareTo(((HuffmanNode<T>) obj).Probability);\n        }\n    }\n\n    public class Huffman<T> where T : IComparable\n    {\n        private readonly Dictionary<T, HuffmanNode<T>> _leafDictionary = new Dictionary<T, HuffmanNode<T>>();\n        private readonly HuffmanNode<T> _root;\n\n        public Huffman(IEnumerable<T> values)\n        {\n            var counts = new Dictionary<T, int>();\n            var priorityQueue = new PriorityQueue<HuffmanNode<T>>();\n            int valueCount = 0;\n\n            foreach (T value in values)\n            {\n                if (!counts.ContainsKey(value))\n                {\n                    counts[value] = 0;\n                }\n                counts[value]++;\n                valueCount++;\n            }\n\n            foreach (T value in counts.Keys)\n            {\n                var node = new HuffmanNode<T>((double) counts[value] / valueCount, value);\n                priorityQueue.Add(node);\n                _leafDictionary[value] = node;\n            }\n\n            while (priorityQueue.Count > 1)\n            {\n                HuffmanNode<T> leftSon = priorityQueue.Pop();\n                HuffmanNode<T> rightSon = priorityQueue.Pop();\n                var parent = new HuffmanNode<T>(leftSon, rightSon);\n                priorityQueue.Add(parent);\n            }\n\n            _root = priorityQueue.Pop();\n            _root.IsZero = false;\n        }\n\n        public List<int> Encode(T value)\n        {\n            var returnValue = new List<int>();\n            Encode(value, returnValue);\n            return returnValue;\n        }\n\n        public void Encode(T value, List<int> encoding)\n        {\n            if (!_leafDictionary.ContainsKey(value))\n            {\n                throw new ArgumentException(\"Invalid value in Encode\");\n            }\n            HuffmanNode<T> nodeCur = _leafDictionary[value];\n            var reverseEncoding = new List<int>();\n            while (!nodeCur.IsRoot)\n            {\n                reverseEncoding.Add(nodeCur.Bit);\n                nodeCur = nodeCur.Parent;\n            }\n\n            reverseEncoding.Reverse();\n            encoding.AddRange(reverseEncoding);\n        }\n\n        public List<int> Encode(IEnumerable<T> values)\n        {\n            var returnValue = new List<int>();\n\n            foreach (T value in values)\n            {\n                Encode(value, returnValue);\n            }\n            return returnValue;\n        }\n\n        public T Decode(List<int> bitString, ref int position)\n        {\n            HuffmanNode<T> nodeCur = _root;\n            while (!nodeCur.IsLeaf)\n            {\n                if (position > bitString.Count)\n                {\n                    throw new ArgumentException(\"Invalid bitstring in Decode\");\n                }\n                nodeCur = bitString[position++] == 0 ? nodeCur.LeftSon : nodeCur.RightSon;\n            }\n            return nodeCur.Value;\n        }\n\n        public List<T> Decode(List<int> bitString)\n        {\n            int position = 0;\n            var returnValue = new List<T>();\n\n            while (position != bitString.Count)\n            {\n                returnValue.Add(Decode(bitString, ref position));\n            }\n            return returnValue;\n        }\n    }\n\n    internal class Program\n    {\n        private const string Example = \"this is an example for huffman encoding\";\n\n        private static void Main()\n        {\n            var huffman = new Huffman<char>(Example);\n            List<int> encoding = huffman.Encode(Example);\n            List<char> decoding = huffman.Decode(encoding);\n            var outString = new string(decoding.ToArray());\n            Console.WriteLine(outString == Example ? \"Encoding/decoding worked\" : \"Encoding/Decoding failed\");\n\n            var chars = new HashSet<char>(Example);\n            foreach (char c in chars)\n            {\n                encoding = huffman.Encode(c);\n                Console.Write(\"{0}:  \", c);\n                foreach (int bit in encoding)\n                {\n                    Console.Write(\"{0}\", bit);\n                }\n                Console.WriteLine();\n            }\n            Console.ReadKey();\n        }\n    }\n}\n"}
{"id": 20024, "name": "Huffman coding", "source": "Translate Ruby to Java: require 'priority_queue'\n\ndef huffman_encoding(str)\n  char_count = Hash.new(0)\n  str.each_char {|c| char_count[c] += 1}\n  \n  pq = CPriorityQueue.new\n  \n  char_count.each {|char, count| pq.push(char, count)}\n  \n  while pq.length > 1\n    key1, prio1 = pq.delete_min\n    key2, prio2 = pq.delete_min\n    pq.push([key1, key2], prio1 + prio2)\n  end\n  \n  Hash[*generate_encoding(pq.min_key)]\nend\n\ndef generate_encoding(ary, prefix=\"\")\n  case ary\n  when Array\n    generate_encoding(ary[0], \"\n  else\n    [ary, prefix]\n  end\nend\n\ndef encode(str, encoding)\n  str.each_char.collect {|char| encoding[char]}.join\nend\n\ndef decode(encoded, encoding)\n  rev_enc = encoding.invert\n  decoded = \"\"\n  pos = 0\n  while pos < encoded.length\n    key = \"\"\n    while rev_enc[key].nil?\n      key << encoded[pos]\n      pos += 1\n    end\n    decoded << rev_enc[key]\n  end\n  decoded\nend\n\nstr = \"this is an example for huffman encoding\"\nencoding = huffman_encoding(str)\nencoding.to_a.sort.each {|x| p x}\n\nenc = encode(str, encoding)\ndec = decode(enc, encoding)\nputs \"success!\" if str == dec\n", "target": "import java.util.*;\n\nabstract class HuffmanTree implements Comparable<HuffmanTree> {\n    public final int frequency; \n    public HuffmanTree(int freq) { frequency = freq; }\n\n    \n    public int compareTo(HuffmanTree tree) {\n        return frequency - tree.frequency;\n    }\n}\n\nclass HuffmanLeaf extends HuffmanTree {\n    public final char value; \n   \n    public HuffmanLeaf(int freq, char val) {\n        super(freq);\n        value = val;\n    }\n}\n\nclass HuffmanNode extends HuffmanTree {\n    public final HuffmanTree left, right; \n   \n    public HuffmanNode(HuffmanTree l, HuffmanTree r) {\n        super(l.frequency + r.frequency);\n        left = l;\n        right = r;\n    }\n}\n\npublic class HuffmanCode {\n    \n    public static HuffmanTree buildTree(int[] charFreqs) {\n        PriorityQueue<HuffmanTree> trees = new PriorityQueue<HuffmanTree>();\n        \n        \n        for (int i = 0; i < charFreqs.length; i++)\n            if (charFreqs[i] > 0)\n                trees.offer(new HuffmanLeaf(charFreqs[i], (char)i));\n\n        assert trees.size() > 0;\n        \n        while (trees.size() > 1) {\n            \n            HuffmanTree a = trees.poll();\n            HuffmanTree b = trees.poll();\n\n            \n            trees.offer(new HuffmanNode(a, b));\n        }\n        return trees.poll();\n    }\n\n    public static void printCodes(HuffmanTree tree, StringBuffer prefix) {\n        assert tree != null;\n        if (tree instanceof HuffmanLeaf) {\n            HuffmanLeaf leaf = (HuffmanLeaf)tree;\n\n            \n            System.out.println(leaf.value + \"\\t\" + leaf.frequency + \"\\t\" + prefix);\n\n        } else if (tree instanceof HuffmanNode) {\n            HuffmanNode node = (HuffmanNode)tree;\n\n            \n            prefix.append('0');\n            printCodes(node.left, prefix);\n            prefix.deleteCharAt(prefix.length()-1);\n\n            \n            prefix.append('1');\n            printCodes(node.right, prefix);\n            prefix.deleteCharAt(prefix.length()-1);\n        }\n    }\n\n    public static void main(String[] args) {\n        String test = \"this is an example for huffman encoding\";\n\n        \n        \n        int[] charFreqs = new int[256];\n        \n        for (char c : test.toCharArray())\n            charFreqs[c]++;\n\n        \n        HuffmanTree tree = buildTree(charFreqs);\n\n        \n        System.out.println(\"SYMBOL\\tWEIGHT\\tHUFFMAN CODE\");\n        printCodes(tree, new StringBuffer());\n    }\n}\n"}
{"id": 20025, "name": "Huffman coding", "source": "Translate Ruby to Python: require 'priority_queue'\n\ndef huffman_encoding(str)\n  char_count = Hash.new(0)\n  str.each_char {|c| char_count[c] += 1}\n  \n  pq = CPriorityQueue.new\n  \n  char_count.each {|char, count| pq.push(char, count)}\n  \n  while pq.length > 1\n    key1, prio1 = pq.delete_min\n    key2, prio2 = pq.delete_min\n    pq.push([key1, key2], prio1 + prio2)\n  end\n  \n  Hash[*generate_encoding(pq.min_key)]\nend\n\ndef generate_encoding(ary, prefix=\"\")\n  case ary\n  when Array\n    generate_encoding(ary[0], \"\n  else\n    [ary, prefix]\n  end\nend\n\ndef encode(str, encoding)\n  str.each_char.collect {|char| encoding[char]}.join\nend\n\ndef decode(encoded, encoding)\n  rev_enc = encoding.invert\n  decoded = \"\"\n  pos = 0\n  while pos < encoded.length\n    key = \"\"\n    while rev_enc[key].nil?\n      key << encoded[pos]\n      pos += 1\n    end\n    decoded << rev_enc[key]\n  end\n  decoded\nend\n\nstr = \"this is an example for huffman encoding\"\nencoding = huffman_encoding(str)\nencoding.to_a.sort.each {|x| p x}\n\nenc = encode(str, encoding)\ndec = decode(enc, encoding)\nputs \"success!\" if str == dec\n", "target": "from heapq import heappush, heappop, heapify\nfrom collections import defaultdict\n\ndef encode(symb2freq):\n    \n    heap = [[wt, [sym, \"\"]] for sym, wt in symb2freq.items()]\n    heapify(heap)\n    while len(heap) > 1:\n        lo = heappop(heap)\n        hi = heappop(heap)\n        for pair in lo[1:]:\n            pair[1] = '0' + pair[1]\n        for pair in hi[1:]:\n            pair[1] = '1' + pair[1]\n        heappush(heap, [lo[0] + hi[0]] + lo[1:] + hi[1:])\n    return sorted(heappop(heap)[1:], key=lambda p: (len(p[-1]), p))\n\ntxt = \"this is an example for huffman encoding\"\nsymb2freq = defaultdict(int)\nfor ch in txt:\n    symb2freq[ch] += 1\n\n\nhuff = encode(symb2freq)\nprint \"Symbol\\tWeight\\tHuffman Code\"\nfor p in huff:\n    print \"%s\\t%s\\t%s\" % (p[0], symb2freq[p[0]], p[1])\n"}
{"id": 20186, "name": "Primality by Wilson's theorem", "source": "Translate Ruby to C#: def w_prime?(i)\n  return false if i < 2\n  ((1..i-1).inject(&:*) + 1) % i == 0\nend\n\np (1..100).select{|n| w_prime?(n) }\n", "target": "using System;\nusing System.Linq;\nusing System.Collections;\nusing static System.Console;\nusing System.Collections.Generic;\nusing BI = System.Numerics.BigInteger;\n\nclass Program {\n\n  \n    const int fst = 120, skp = 1000, max = 1015; static double et1, et2; static DateTime st;\n    static string ms1 = \"Wilson's theorem method\", ms2 = \"Sieve of Eratosthenes method\", \n       fmt = \"--- {0} ---\\n\\nThe first {1} primes are:\", fm2 = \"{0} prime thru the {1} prime:\";\n    static List<int> lst = new List<int>();\n\n  \n    static void Dump(int s, int t, string f) {\n        foreach (var item in lst.Skip(s).Take(t)) Write(f, item); WriteLine(\"\\n\"); }\n\n  \n    static string Ord(int x, string fmt = \"{0:n0}\") {\n      var y = x % 10; if ((x % 100) / 10 == 10 || y > 3) y = 0;\n      return string.Format(fmt, x) + \"thstndrd\".Substring(y << 1, 2); }\n\n  \n    static void ShowOne(string title, ref double et) {\n        WriteLine(fmt, title, fst); Dump(0, fst, \"{0,-3} \");\n        WriteLine(fm2, Ord(skp), Ord(max)); Dump(skp - 1, max - skp + 1, \"{0,4} \");\n        WriteLine(\"Time taken: {0}ms\\n\", et = (DateTime.Now - st).TotalMilliseconds); }\n\n  \n    static BI factorial(int n) { BI res = 1; if (n < 2) return res;\n        while (n > 0) res *= n--; return res; }\n\n    static bool WTisPrimeSA(int n) { return ((factorial(n - 1) + 1) % n) == 0; }\n\n    static BI[] facts;\n\n    static void initFacts(int n) {\n        facts = new BI[n]; facts[0] = facts[1] = 1;\n        for (int i = 1, j = 2; j < n; i = j++)\n            facts[j] = facts[i] * j; }\n\n    static bool WTisPrime(int n) { return ((facts[n - 1] + 1) % n) == 0; }\n  \n\n    static void Main(string[] args) { st = DateTime.Now;\n        BI f = 1; for (int n = 2; lst.Count < max; f *= n++) if ((f + 1) % n == 0) lst.Add(n);\n        ShowOne(ms1, ref et1);\n        st = DateTime.Now; int lmt = lst.Last(); lst.Clear(); BitArray flags = new BitArray(lmt + 1);\n        for (int n = 2; n <= lmt; n+=n==2?1:2) if (!flags[n]) {\n                lst.Add(n); for (int k = n * n, n2=n<<1; k <= lmt; k += n2) flags[k] = true; }\n        ShowOne(ms2, ref et2);\n        WriteLine(\"{0} was {1:0.0} times slower than the {2}.\", ms1, et1 / et2, ms2);\n\n      \n        WriteLine(\"\\n\" + ms1 + \" stand-alone computation:\");\n        WriteLine(\"factorial computed for each item\");\n        st = DateTime.Now;\n        for (int x = lst[skp - 1]; x <= lst[max - 1]; x++) if (WTisPrimeSA(x)) Write(\"{0,4} \", x);\n        WriteLine(); WriteLine(\"\\nTime taken: {0}ms\\n\", (DateTime.Now - st).TotalMilliseconds);\n\n        WriteLine(\"factorials precomputed up to highest item\");\n        st = DateTime.Now; initFacts(lst[max - 1]);\n        for (int x = lst[skp - 1]; x <= lst[max - 1]; x++) if (WTisPrime(x)) Write(\"{0,4} \", x);\n        WriteLine(); WriteLine(\"\\nTime taken: {0}ms\\n\", (DateTime.Now - st).TotalMilliseconds);\n    }\n}\n"}
{"id": 20188, "name": "Primality by Wilson's theorem", "source": "Translate Ruby to Java: def w_prime?(i)\n  return false if i < 2\n  ((1..i-1).inject(&:*) + 1) % i == 0\nend\n\np (1..100).select{|n| w_prime?(n) }\n", "target": "import java.math.BigInteger;\n\npublic class PrimaltyByWilsonsTheorem {\n\n    public static void main(String[] args) {\n        System.out.printf(\"Primes less than 100 testing by Wilson's Theorem%n\");\n        for ( int i = 0 ; i <= 100 ; i++ ) {\n            if ( isPrime(i) ) {\n                System.out.printf(\"%d \", i);\n            }\n        }\n    }\n    \n    \n    private static boolean isPrime(long p) {\n        if ( p <= 1) {\n            return false;\n        }\n        return fact(p-1).add(BigInteger.ONE).mod(BigInteger.valueOf(p)).compareTo(BigInteger.ZERO) == 0;\n    }\n    \n    private static BigInteger fact(long n) {\n        BigInteger fact = BigInteger.ONE;\n        for ( int i = 2 ; i <= n ; i++ ) {\n            fact = fact.multiply(BigInteger.valueOf(i));\n        }\n        return fact;\n    }\n\n}\n"}
{"id": 20189, "name": "Primality by Wilson's theorem", "source": "Translate Ruby to Python: def w_prime?(i)\n  return false if i < 2\n  ((1..i-1).inject(&:*) + 1) % i == 0\nend\n\np (1..100).select{|n| w_prime?(n) }\n", "target": "from math import factorial\n\ndef is_wprime(n):\n    return n == 2 or (\n        n > 1\n        and n % 2 != 0\n        and (factorial(n - 1) + 1) % n == 0\n    )\n\nif __name__ == '__main__':\n    c = int(input('Enter upper limit: '))\n    print(f'Primes under {c}:')\n    print([n for n in range(c) if is_wprime(n)])\n"}
{"id": 20294, "name": "Fraction reduction", "source": "Translate Ruby to C#: def indexOf(haystack, needle)\n    idx = 0\n    for straw in haystack\n        if straw == needle then\n            return idx\n        else\n            idx = idx + 1\n        end\n    end\n    return -1\nend\n\ndef getDigits(n, le, digits)\n    while n > 0\n        r = n % 10\n        if r == 0 or indexOf(digits, r) >= 0 then\n            return false\n        end\n        le = le - 1\n        digits[le] = r\n        n = (n / 10).floor\n    end\n    return true\nend\n\nPOWS = [1, 10, 100, 1000, 10000]\ndef removeDigit(digits, le, idx)\n    sum = 0\n    pow = POWS[le - 2]\n    i = 0\n    while i < le\n        if i == idx then\n            i = i + 1\n            next\n        end\n        sum = sum + digits[i] * pow\n        pow = (pow / 10).floor\n        i = i + 1\n    end\n    return sum\nend\n\ndef main\n    lims = [ [ 12, 97 ], [ 123, 986 ], [ 1234, 9875 ], [ 12345, 98764 ] ]\n    count = Array.new(5, 0)\n    omitted = Array.new(5) { Array.new(10, 0) }\n\n    i = 0\n    for lim in lims\n        n = lim[0]\n        while n < lim[1]\n            nDigits = [0] * (i + 2)\n            nOk = getDigits(n, i + 2, nDigits)\n            if not nOk then\n                n = n + 1\n                next\n            end\n            d = n + 1\n            while d <= lim[1] + 1\n                dDigits = [0] * (i + 2)\n                dOk = getDigits(d, i + 2, dDigits)\n                if not dOk then\n                    d = d + 1\n                    next\n                end\n                nix = 0\n                while nix < nDigits.length\n                    digit = nDigits[nix]\n                    dix = indexOf(dDigits, digit)\n                    if dix >= 0 then\n                        rn = removeDigit(nDigits, i + 2, nix)\n                        rd = removeDigit(dDigits, i + 2, dix)\n                        if (1.0 * n / d) == (1.0 * rn / rd) then\n                            count[i] = count[i] + 1\n                            omitted[i][digit] = omitted[i][digit] + 1\n                            if count[i] <= 12 then\n                                print \"%d/%d = %d/%d by omitting %d's\\n\" % [n, d, rn, rd, digit]\n                            end\n                        end\n                    end\n                    nix = nix + 1\n                end\n                d = d + 1\n            end\n            n = n + 1\n        end\n        print \"\\n\"\n        i = i + 1\n    end\n\n    i = 2\n    while i <= 5\n        print \"There are %d %d-digit fractions of which:\\n\" % [count[i - 2], i]\n        j = 1\n        while j <= 9\n            if omitted[i - 2][j] == 0 then\n                j = j + 1\n                next\n            end\n            print \"%6s have %d's omitted\\n\" % [omitted[i - 2][j], j]\n            j = j + 1\n        end\n        print \"\\n\"\n        i = i + 1\n    end\nend\n\nmain()\n", "target": "using System;\n\nnamespace FractionReduction {\n    class Program {\n        static int IndexOf(int n, int[] s) {\n            for (int i = 0; i < s.Length; i++) {\n                if (s[i] == n) {\n                    return i;\n                }\n            }\n            return -1;\n        }\n\n        static bool GetDigits(int n, int le, int[] digits) {\n            while (n > 0) {\n                var r = n % 10;\n                if (r == 0 || IndexOf(r, digits) >= 0) {\n                    return false;\n                }\n                le--;\n                digits[le] = r;\n                n /= 10;\n            }\n            return true;\n        }\n\n        static int RemoveDigit(int[] digits, int le, int idx) {\n            int[] pows = { 1, 10, 100, 1000, 10000 };\n\n            var sum = 0;\n            var pow = pows[le - 2];\n            for (int i = 0; i < le; i++) {\n                if (i == idx) continue;\n                sum += digits[i] * pow;\n                pow /= 10;\n\n            }\n            return sum;\n        }\n\n        static void Main() {\n            var lims = new int[,] { { 12, 97 }, { 123, 986 }, { 1234, 9875 }, { 12345, 98764 } };\n            var count = new int[5];\n            var omitted = new int[5, 10];\n            var upperBound = lims.GetLength(0);\n            for (int i = 0; i < upperBound; i++) {\n                var nDigits = new int[i + 2];\n                var dDigits = new int[i + 2];\n                var blank = new int[i + 2];\n                for (int n = lims[i, 0]; n <= lims[i, 1]; n++) {\n                    blank.CopyTo(nDigits, 0);\n                    var nOk = GetDigits(n, i + 2, nDigits);\n                    if (!nOk) {\n                        continue;\n                    }\n                    for (int d = n + 1; d <= lims[i, 1] + 1; d++) {\n                        blank.CopyTo(dDigits, 0);\n                        var dOk = GetDigits(d, i + 2, dDigits);\n                        if (!dOk) {\n                            continue;\n                        }\n                        for (int nix = 0; nix < nDigits.Length; nix++) {\n                            var digit = nDigits[nix];\n                            var dix = IndexOf(digit, dDigits);\n                            if (dix >= 0) {\n                                var rn = RemoveDigit(nDigits, i + 2, nix);\n                                var rd = RemoveDigit(dDigits, i + 2, dix);\n                                if ((double)n / d == (double)rn / rd) {\n                                    count[i]++;\n                                    omitted[i, digit]++;\n                                    if (count[i] <= 12) {\n                                        Console.WriteLine(\"{0}/{1} = {2}/{3} by omitting {4}'s\", n, d, rn, rd, digit);\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n                Console.WriteLine();\n            }\n\n            for (int i = 2; i <= 5; i++) {\n                Console.WriteLine(\"There are {0} {1}-digit fractions of which:\", count[i - 2], i);\n                for (int j = 1; j <= 9; j++) {\n                    if (omitted[i - 2, j] == 0) {\n                        continue;\n                    }\n                    Console.WriteLine(\"{0,6} have {1}'s omitted\", omitted[i - 2, j], j);\n                }\n                Console.WriteLine();\n            }\n        }\n    }\n}\n"}
{"id": 20296, "name": "Fraction reduction", "source": "Translate Ruby to Java: def indexOf(haystack, needle)\n    idx = 0\n    for straw in haystack\n        if straw == needle then\n            return idx\n        else\n            idx = idx + 1\n        end\n    end\n    return -1\nend\n\ndef getDigits(n, le, digits)\n    while n > 0\n        r = n % 10\n        if r == 0 or indexOf(digits, r) >= 0 then\n            return false\n        end\n        le = le - 1\n        digits[le] = r\n        n = (n / 10).floor\n    end\n    return true\nend\n\nPOWS = [1, 10, 100, 1000, 10000]\ndef removeDigit(digits, le, idx)\n    sum = 0\n    pow = POWS[le - 2]\n    i = 0\n    while i < le\n        if i == idx then\n            i = i + 1\n            next\n        end\n        sum = sum + digits[i] * pow\n        pow = (pow / 10).floor\n        i = i + 1\n    end\n    return sum\nend\n\ndef main\n    lims = [ [ 12, 97 ], [ 123, 986 ], [ 1234, 9875 ], [ 12345, 98764 ] ]\n    count = Array.new(5, 0)\n    omitted = Array.new(5) { Array.new(10, 0) }\n\n    i = 0\n    for lim in lims\n        n = lim[0]\n        while n < lim[1]\n            nDigits = [0] * (i + 2)\n            nOk = getDigits(n, i + 2, nDigits)\n            if not nOk then\n                n = n + 1\n                next\n            end\n            d = n + 1\n            while d <= lim[1] + 1\n                dDigits = [0] * (i + 2)\n                dOk = getDigits(d, i + 2, dDigits)\n                if not dOk then\n                    d = d + 1\n                    next\n                end\n                nix = 0\n                while nix < nDigits.length\n                    digit = nDigits[nix]\n                    dix = indexOf(dDigits, digit)\n                    if dix >= 0 then\n                        rn = removeDigit(nDigits, i + 2, nix)\n                        rd = removeDigit(dDigits, i + 2, dix)\n                        if (1.0 * n / d) == (1.0 * rn / rd) then\n                            count[i] = count[i] + 1\n                            omitted[i][digit] = omitted[i][digit] + 1\n                            if count[i] <= 12 then\n                                print \"%d/%d = %d/%d by omitting %d's\\n\" % [n, d, rn, rd, digit]\n                            end\n                        end\n                    end\n                    nix = nix + 1\n                end\n                d = d + 1\n            end\n            n = n + 1\n        end\n        print \"\\n\"\n        i = i + 1\n    end\n\n    i = 2\n    while i <= 5\n        print \"There are %d %d-digit fractions of which:\\n\" % [count[i - 2], i]\n        j = 1\n        while j <= 9\n            if omitted[i - 2][j] == 0 then\n                j = j + 1\n                next\n            end\n            print \"%6s have %d's omitted\\n\" % [omitted[i - 2][j], j]\n            j = j + 1\n        end\n        print \"\\n\"\n        i = i + 1\n    end\nend\n\nmain()\n", "target": "import java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\n\npublic class FractionReduction {\n\n    public static void main(String[] args) {\n        for ( int size = 2 ; size <= 5 ; size++ ) {\n            reduce(size);\n        }\n    }\n    \n    private static void reduce(int numDigits) {\n        System.out.printf(\"Fractions with digits of length %d where cancellation is valid.  Examples:%n\", numDigits);\n        \n        \n        int min = (int) Math.pow(10, numDigits-1);\n        int max = (int) Math.pow(10, numDigits) - 1;\n        List<Integer> values = new ArrayList<>();\n        for ( int number = min ; number <= max ; number++ ) {\n            if ( isValid(number) ) {\n                values.add(number);\n            }\n        }\n        \n        Map<Integer,Integer> cancelCount = new HashMap<>(); \n        int size = values.size();\n        int solutions = 0;\n        for ( int nIndex = 0 ; nIndex < size - 1 ; nIndex++ ) {\n            int numerator = values.get(nIndex);\n            \n            for ( int dIndex = nIndex + 1 ; dIndex < size ; dIndex++ ) {\n                int denominator = values.get(dIndex);\n                for ( int commonDigit : digitsInCommon(numerator, denominator) ) {\n                    int numRemoved = removeDigit(numerator, commonDigit);\n                    int denRemoved = removeDigit(denominator, commonDigit);\n                    if ( numerator * denRemoved == denominator * numRemoved ) {\n                        solutions++;\n                        cancelCount.merge(commonDigit, 1, (v1, v2) -> v1 + v2);\n                        if ( solutions <= 12 ) {\n                            System.out.printf(\"    When %d is removed, %d/%d = %d/%d%n\", commonDigit, numerator, denominator, numRemoved, denRemoved);\n                        }\n                    }\n                }\n            }\n        }\n        System.out.printf(\"Number of fractions where cancellation is valid = %d.%n\", solutions);\n        List<Integer> sorted = new ArrayList<>(cancelCount.keySet());\n        Collections.sort(sorted);\n        for ( int removed : sorted ) {\n            System.out.printf(\"    The digit %d was removed %d times.%n\", removed, cancelCount.get(removed));\n        }\n        System.out.println();\n    }\n    \n    private static int[] powers = new int[] {1, 10, 100, 1000, 10000, 100000};\n    \n    \n    private static int removeDigit(int n, int removed) {\n        int m = 0;\n        int pow = 0;\n        while ( n > 0 ) {\n            int r = n % 10;\n            if ( r != removed ) {\n                m = m + r*powers[pow];\n                pow++;\n            }\n            n /= 10;\n        }\n        return m;\n    }\n        \n    \n    private static List<Integer> digitsInCommon(int n1, int n2) {\n        int[] count = new int[10];\n        List<Integer> common = new ArrayList<>();\n        while ( n1 > 0 ) {\n            int r = n1 % 10;\n            count[r] += 1;\n            n1 /= 10;\n        }\n        while ( n2 > 0 ) {\n            int r = n2 % 10;\n            if ( count[r] > 0 ) {\n                common.add(r);\n            }\n            n2 /= 10;\n        }\n        return common;\n    }\n    \n    \n    private static boolean isValid(int num) {\n        int[] count = new int[10];\n        while ( num > 0 ) {\n            int r = num % 10;\n            if ( r == 0 || count[r] == 1 ) {\n                return false;\n            }\n            count[r] = 1;\n            num /= 10;\n        }\n        return true;\n    }\n\n}\n"}
{"id": 20297, "name": "Fraction reduction", "source": "Translate Ruby to Python: def indexOf(haystack, needle)\n    idx = 0\n    for straw in haystack\n        if straw == needle then\n            return idx\n        else\n            idx = idx + 1\n        end\n    end\n    return -1\nend\n\ndef getDigits(n, le, digits)\n    while n > 0\n        r = n % 10\n        if r == 0 or indexOf(digits, r) >= 0 then\n            return false\n        end\n        le = le - 1\n        digits[le] = r\n        n = (n / 10).floor\n    end\n    return true\nend\n\nPOWS = [1, 10, 100, 1000, 10000]\ndef removeDigit(digits, le, idx)\n    sum = 0\n    pow = POWS[le - 2]\n    i = 0\n    while i < le\n        if i == idx then\n            i = i + 1\n            next\n        end\n        sum = sum + digits[i] * pow\n        pow = (pow / 10).floor\n        i = i + 1\n    end\n    return sum\nend\n\ndef main\n    lims = [ [ 12, 97 ], [ 123, 986 ], [ 1234, 9875 ], [ 12345, 98764 ] ]\n    count = Array.new(5, 0)\n    omitted = Array.new(5) { Array.new(10, 0) }\n\n    i = 0\n    for lim in lims\n        n = lim[0]\n        while n < lim[1]\n            nDigits = [0] * (i + 2)\n            nOk = getDigits(n, i + 2, nDigits)\n            if not nOk then\n                n = n + 1\n                next\n            end\n            d = n + 1\n            while d <= lim[1] + 1\n                dDigits = [0] * (i + 2)\n                dOk = getDigits(d, i + 2, dDigits)\n                if not dOk then\n                    d = d + 1\n                    next\n                end\n                nix = 0\n                while nix < nDigits.length\n                    digit = nDigits[nix]\n                    dix = indexOf(dDigits, digit)\n                    if dix >= 0 then\n                        rn = removeDigit(nDigits, i + 2, nix)\n                        rd = removeDigit(dDigits, i + 2, dix)\n                        if (1.0 * n / d) == (1.0 * rn / rd) then\n                            count[i] = count[i] + 1\n                            omitted[i][digit] = omitted[i][digit] + 1\n                            if count[i] <= 12 then\n                                print \"%d/%d = %d/%d by omitting %d's\\n\" % [n, d, rn, rd, digit]\n                            end\n                        end\n                    end\n                    nix = nix + 1\n                end\n                d = d + 1\n            end\n            n = n + 1\n        end\n        print \"\\n\"\n        i = i + 1\n    end\n\n    i = 2\n    while i <= 5\n        print \"There are %d %d-digit fractions of which:\\n\" % [count[i - 2], i]\n        j = 1\n        while j <= 9\n            if omitted[i - 2][j] == 0 then\n                j = j + 1\n                next\n            end\n            print \"%6s have %d's omitted\\n\" % [omitted[i - 2][j], j]\n            j = j + 1\n        end\n        print \"\\n\"\n        i = i + 1\n    end\nend\n\nmain()\n", "target": "def indexOf(haystack, needle):\n    idx = 0\n    for straw in haystack:\n        if straw == needle:\n            return idx\n        else:\n            idx += 1\n    return -1\n\ndef getDigits(n, le, digits):\n    while n > 0:\n        r = n % 10\n        if r == 0 or indexOf(digits, r) >= 0:\n            return False\n        le -= 1\n        digits[le] = r\n        n = int(n / 10)\n    return True\n\ndef removeDigit(digits, le, idx):\n    pows = [1, 10, 100, 1000, 10000]\n    sum = 0\n    pow = pows[le - 2]\n    i = 0\n    while i < le:\n        if i == idx:\n            i += 1\n            continue\n        sum = sum + digits[i] * pow\n        pow = int(pow / 10)\n        i += 1\n    return sum\n\ndef main():\n    lims = [ [ 12, 97 ], [ 123, 986 ], [ 1234, 9875 ], [ 12345, 98764 ] ]\n    count = [0 for i in range(5)]\n    omitted = [[0 for i in range(10)] for j in range(5)]\n\n    i = 0\n    while i < len(lims):\n        n = lims[i][0]\n        while n < lims[i][1]:\n            nDigits = [0 for k in range(i + 2)]\n            nOk = getDigits(n, i + 2, nDigits)\n            if not nOk:\n                n += 1\n                continue\n            d = n + 1\n            while d <= lims[i][1] + 1:\n                dDigits = [0 for k in range(i + 2)]\n                dOk = getDigits(d, i + 2, dDigits)\n                if not dOk:\n                    d += 1\n                    continue\n                nix = 0\n                while nix < len(nDigits):\n                    digit = nDigits[nix]\n                    dix = indexOf(dDigits, digit)\n                    if dix >= 0:\n                        rn = removeDigit(nDigits, i + 2, nix)\n                        rd = removeDigit(dDigits, i + 2, dix)\n                        if (1.0 * n / d) == (1.0 * rn / rd):\n                            count[i] += 1\n                            omitted[i][digit] += 1\n                            if count[i] <= 12:\n                                print \"%d/%d = %d/%d by omitting %d's\" % (n, d, rn, rd, digit)\n                    nix += 1\n                d += 1\n            n += 1\n        print\n        i += 1\n\n    i = 2\n    while i <= 5:\n        print \"There are %d %d-digit fractions of which:\" % (count[i - 2], i)\n        j = 1\n        while j <= 9:\n            if omitted[i - 2][j] == 0:\n                j += 1\n                continue\n            print \"%6s have %d's omitted\" % (omitted[i - 2][j], j)\n            j += 1\n        print\n        i += 1\n    return None\n\nmain()\n"}
{"id": 20422, "name": "Solve a Holy Knight's tour", "source": "Translate Ruby to C#: require 'HLPsolver'\n\nADJACENT = [[-1,-2],[-2,-1],[-2,1],[-1,2],[1,2],[2,1],[2,-1],[1,-2]]\n\nboardy = <<EOS\n. . 0 0 0\n. . 0 . 0 0\n. 0 0 0 0 0 0 0\n0 0 0 . . 0 . 0\n0 . 0 . . 0 0 0\n1 0 0 0 0 0 0\n. . 0 0 . 0\n. . . 0 0 0\nEOS\nt0 = Time.now\nHLPsolver.new(boardy).solve\nputs \" \n", "target": "using System.Collections;\nusing System.Collections.Generic;\nusing static System.Console;\nusing static System.Math;\nusing static System.Linq.Enumerable;\n\npublic class Solver\n{\n    private static readonly (int dx, int dy)[]\n        \n        knightMoves = {(1,-2),(2,-1),(2,1),(1,2),(-1,2),(-2,1),(-2,-1),(-1,-2)};\n\n    private (int dx, int dy)[] moves;\n        \n    public static void Main()\n    {\n        var knightSolver = new Solver(knightMoves);\n        Print(knightSolver.Solve(true,\n            \".000....\",\n            \".0.00...\",\n            \".0000000\",\n            \"000..0.0\",\n            \"0.0..000\",\n            \"1000000.\",\n            \"..00.0..\",\n            \"...000..\"));\n\n        Print(knightSolver.Solve(true,\n            \".....0.0.....\",\n            \".....0.0.....\",\n            \"....00000....\",\n            \".....000.....\",\n            \"..0..0.0..0..\",\n            \"00000...00000\",\n            \"..00.....00..\",\n            \"00000...00000\",\n            \"..0..0.0..0..\",\n            \".....000.....\",\n            \"....00000....\",\n            \".....0.0.....\",\n            \".....0.0.....\" \n        ));\n    }\n\n    public Solver(params (int dx, int dy)[] moves) => this.moves = moves;\n\n    public int[,] Solve(bool circular, params string[] puzzle)\n    {\n        var (board, given, count) = Parse(puzzle);\n        return Solve(board, given, count, circular);\n    }\n\n    public int[,] Solve(bool circular, int[,] puzzle)\n    {\n        var (board, given, count) = Parse(puzzle);\n        return Solve(board, given, count, circular);\n    }\n\n    private int[,] Solve(int[,] board, BitArray given, int count, bool circular)\n    {\n        var (height, width) = (board.GetLength(0), board.GetLength(1));\n        bool solved = false;\n        for (int x = 0; x < height && !solved; x++) {\n            solved = Range(0, width).Any(y => Solve(board, given, circular, (height, width), (x, y), count, (x, y), 1));\n            if (solved) return board;\n        }\n        return null;\n    }\n\n    private bool Solve(int[,] board, BitArray given, bool circular,\n        (int h, int w) size, (int x, int y) start, int last, (int x, int y) current, int n)\n    {\n        var (x, y) = current;\n        if (x < 0 || x >= size.h || y < 0 || y >= size.w) return false;\n        if (board[x, y] < 0) return false;\n        if (given[n - 1]) {\n            if (board[x, y] != n) return false;\n        } else if (board[x, y] > 0) return false;\n        board[x, y] = n;\n        if (n == last) {\n            if (!circular || AreNeighbors(start, current)) return true;\n        }\n        for (int i = 0; i < moves.Length; i++) {\n            var move = moves[i];\n            if (Solve(board, given, circular, size, start, last, (x + move.dx, y + move.dy), n + 1)) return true;\n        }\n        if (!given[n - 1]) board[x, y] = 0;\n        return false;\n\n        bool AreNeighbors((int x, int y) p1, (int x, int y) p2) => moves.Any(m => (p2.x + m.dx, p2.y + m.dy).Equals(p1));\n    }\n\n    private static (int[,] board, BitArray given, int count) Parse(string[] input)\n    {\n        (int height, int width) = (input.Length, input[0].Length);\n        int[,] board = new int[height, width];\n        int count = 0;\n        for (int x = 0; x < height; x++) {\n            string line = input[x];\n            for (int y = 0; y < width; y++) {\n                board[x, y] = y < line.Length && char.IsDigit(line[y]) ? line[y] - '0' : -1;\n                if (board[x, y] >= 0) count++;\n            }\n        }\n        BitArray given = Scan(board, count, height, width);\n        return (board, given, count);\n    }\n\n    private static (int[,] board, BitArray given, int count) Parse(int[,] input)\n    {\n        (int height, int width) = (input.GetLength(0), input.GetLength(1));\n        int[,] board = new int[height, width];\n        int count = 0;\n        for (int x = 0; x < height; x++)\n            for (int y = 0; y < width; y++)\n                if ((board[x, y] = input[x, y]) >= 0) count++;\n        BitArray given = Scan(board, count, height, width);\n        return (board, given, count);\n    }\n\n    private static BitArray Scan(int[,] board, int count, int height, int width)\n    {\n        var given = new BitArray(count + 1);\n        for (int x = 0; x < height; x++)\n            for (int y = 0; y < width; y++)\n                if (board[x, y] > 0) given[board[x, y] - 1] = true;\n        return given;\n    }\n\n    private static void Print(int[,] board)\n    {\n        if (board == null) {\n            WriteLine(\"No solution\");\n        } else {\n            int w = board.Cast<int>().Where(i => i > 0).Max(i => (int?)Ceiling(Log10(i+1))) ?? 1;\n            string e = new string('-', w);\n            foreach (int x in Range(0, board.GetLength(0)))\n                WriteLine(string.Join(\" \", Range(0, board.GetLength(1))\n                    .Select(y => board[x, y] < 0 ? e : board[x, y].ToString().PadLeft(w, ' '))));\n        }\n        WriteLine();\n    }\n\n}\n"}
{"id": 20423, "name": "Solve a Holy Knight's tour", "source": "Translate Ruby to C#: require 'HLPsolver'\n\nADJACENT = [[-1,-2],[-2,-1],[-2,1],[-1,2],[1,2],[2,1],[2,-1],[1,-2]]\n\nboardy = <<EOS\n. . 0 0 0\n. . 0 . 0 0\n. 0 0 0 0 0 0 0\n0 0 0 . . 0 . 0\n0 . 0 . . 0 0 0\n1 0 0 0 0 0 0\n. . 0 0 . 0\n. . . 0 0 0\nEOS\nt0 = Time.now\nHLPsolver.new(boardy).solve\nputs \" \n", "target": "using System.Collections;\nusing System.Collections.Generic;\nusing static System.Console;\nusing static System.Math;\nusing static System.Linq.Enumerable;\n\npublic class Solver\n{\n    private static readonly (int dx, int dy)[]\n        \n        knightMoves = {(1,-2),(2,-1),(2,1),(1,2),(-1,2),(-2,1),(-2,-1),(-1,-2)};\n\n    private (int dx, int dy)[] moves;\n        \n    public static void Main()\n    {\n        var knightSolver = new Solver(knightMoves);\n        Print(knightSolver.Solve(true,\n            \".000....\",\n            \".0.00...\",\n            \".0000000\",\n            \"000..0.0\",\n            \"0.0..000\",\n            \"1000000.\",\n            \"..00.0..\",\n            \"...000..\"));\n\n        Print(knightSolver.Solve(true,\n            \".....0.0.....\",\n            \".....0.0.....\",\n            \"....00000....\",\n            \".....000.....\",\n            \"..0..0.0..0..\",\n            \"00000...00000\",\n            \"..00.....00..\",\n            \"00000...00000\",\n            \"..0..0.0..0..\",\n            \".....000.....\",\n            \"....00000....\",\n            \".....0.0.....\",\n            \".....0.0.....\" \n        ));\n    }\n\n    public Solver(params (int dx, int dy)[] moves) => this.moves = moves;\n\n    public int[,] Solve(bool circular, params string[] puzzle)\n    {\n        var (board, given, count) = Parse(puzzle);\n        return Solve(board, given, count, circular);\n    }\n\n    public int[,] Solve(bool circular, int[,] puzzle)\n    {\n        var (board, given, count) = Parse(puzzle);\n        return Solve(board, given, count, circular);\n    }\n\n    private int[,] Solve(int[,] board, BitArray given, int count, bool circular)\n    {\n        var (height, width) = (board.GetLength(0), board.GetLength(1));\n        bool solved = false;\n        for (int x = 0; x < height && !solved; x++) {\n            solved = Range(0, width).Any(y => Solve(board, given, circular, (height, width), (x, y), count, (x, y), 1));\n            if (solved) return board;\n        }\n        return null;\n    }\n\n    private bool Solve(int[,] board, BitArray given, bool circular,\n        (int h, int w) size, (int x, int y) start, int last, (int x, int y) current, int n)\n    {\n        var (x, y) = current;\n        if (x < 0 || x >= size.h || y < 0 || y >= size.w) return false;\n        if (board[x, y] < 0) return false;\n        if (given[n - 1]) {\n            if (board[x, y] != n) return false;\n        } else if (board[x, y] > 0) return false;\n        board[x, y] = n;\n        if (n == last) {\n            if (!circular || AreNeighbors(start, current)) return true;\n        }\n        for (int i = 0; i < moves.Length; i++) {\n            var move = moves[i];\n            if (Solve(board, given, circular, size, start, last, (x + move.dx, y + move.dy), n + 1)) return true;\n        }\n        if (!given[n - 1]) board[x, y] = 0;\n        return false;\n\n        bool AreNeighbors((int x, int y) p1, (int x, int y) p2) => moves.Any(m => (p2.x + m.dx, p2.y + m.dy).Equals(p1));\n    }\n\n    private static (int[,] board, BitArray given, int count) Parse(string[] input)\n    {\n        (int height, int width) = (input.Length, input[0].Length);\n        int[,] board = new int[height, width];\n        int count = 0;\n        for (int x = 0; x < height; x++) {\n            string line = input[x];\n            for (int y = 0; y < width; y++) {\n                board[x, y] = y < line.Length && char.IsDigit(line[y]) ? line[y] - '0' : -1;\n                if (board[x, y] >= 0) count++;\n            }\n        }\n        BitArray given = Scan(board, count, height, width);\n        return (board, given, count);\n    }\n\n    private static (int[,] board, BitArray given, int count) Parse(int[,] input)\n    {\n        (int height, int width) = (input.GetLength(0), input.GetLength(1));\n        int[,] board = new int[height, width];\n        int count = 0;\n        for (int x = 0; x < height; x++)\n            for (int y = 0; y < width; y++)\n                if ((board[x, y] = input[x, y]) >= 0) count++;\n        BitArray given = Scan(board, count, height, width);\n        return (board, given, count);\n    }\n\n    private static BitArray Scan(int[,] board, int count, int height, int width)\n    {\n        var given = new BitArray(count + 1);\n        for (int x = 0; x < height; x++)\n            for (int y = 0; y < width; y++)\n                if (board[x, y] > 0) given[board[x, y] - 1] = true;\n        return given;\n    }\n\n    private static void Print(int[,] board)\n    {\n        if (board == null) {\n            WriteLine(\"No solution\");\n        } else {\n            int w = board.Cast<int>().Where(i => i > 0).Max(i => (int?)Ceiling(Log10(i+1))) ?? 1;\n            string e = new string('-', w);\n            foreach (int x in Range(0, board.GetLength(0)))\n                WriteLine(string.Join(\" \", Range(0, board.GetLength(1))\n                    .Select(y => board[x, y] < 0 ? e : board[x, y].ToString().PadLeft(w, ' '))));\n        }\n        WriteLine();\n    }\n\n}\n"}
{"id": 20426, "name": "Solve a Holy Knight's tour", "source": "Translate Ruby to Java: require 'HLPsolver'\n\nADJACENT = [[-1,-2],[-2,-1],[-2,1],[-1,2],[1,2],[2,1],[2,-1],[1,-2]]\n\nboardy = <<EOS\n. . 0 0 0\n. . 0 . 0 0\n. 0 0 0 0 0 0 0\n0 0 0 . . 0 . 0\n0 . 0 . . 0 0 0\n1 0 0 0 0 0 0\n. . 0 0 . 0\n. . . 0 0 0\nEOS\nt0 = Time.now\nHLPsolver.new(boardy).solve\nputs \" \n", "target": "import java.util.*;\n\npublic class HolyKnightsTour {\n\n    final static String[] board = {\n        \" xxx    \",\n        \" x xx   \",\n        \" xxxxxxx\",\n        \"xxx  x x\",\n        \"x x  xxx\",\n        \"1xxxxxx \",\n        \"  xx x  \",\n        \"   xxx  \"};\n\n    private final static int base = 12;\n    private final static int[][] moves = {{1, -2}, {2, -1}, {2, 1}, {1, 2},\n    {-1, 2}, {-2, 1}, {-2, -1}, {-1, -2}};\n    private static int[][] grid;\n    private static int total = 2;\n\n    public static void main(String[] args) {\n        int row = 0, col = 0;\n\n        grid = new int[base][base];\n\n        for (int r = 0; r < base; r++) {\n            Arrays.fill(grid[r], -1);\n            for (int c = 2; c < base - 2; c++) {\n                if (r >= 2 && r < base - 2) {\n                    if (board[r - 2].charAt(c - 2) == 'x') {\n                        grid[r][c] = 0;\n                        total++;\n                    }\n                    if (board[r - 2].charAt(c - 2) == '1') {\n                        row = r;\n                        col = c;\n                    }\n                }\n            }\n        }\n\n        grid[row][col] = 1;\n\n        if (solve(row, col, 2))\n            printResult();\n    }\n\n    private static boolean solve(int r, int c, int count) {\n        if (count == total)\n            return true;\n\n        List<int[]> nbrs = neighbors(r, c);\n\n        if (nbrs.isEmpty() && count != total)\n            return false;\n\n        Collections.sort(nbrs, (a, b) -> a[2] - b[2]);\n\n        for (int[] nb : nbrs) {\n            r = nb[0];\n            c = nb[1];\n            grid[r][c] = count;\n            if (solve(r, c, count + 1))\n                return true;\n            grid[r][c] = 0;\n        }\n\n        return false;\n    }\n\n    private static List<int[]> neighbors(int r, int c) {\n        List<int[]> nbrs = new ArrayList<>();\n\n        for (int[] m : moves) {\n            int x = m[0];\n            int y = m[1];\n            if (grid[r + y][c + x] == 0) {\n                int num = countNeighbors(r + y, c + x) - 1;\n                nbrs.add(new int[]{r + y, c + x, num});\n            }\n        }\n        return nbrs;\n    }\n\n    private static int countNeighbors(int r, int c) {\n        int num = 0;\n        for (int[] m : moves)\n            if (grid[r + m[1]][c + m[0]] == 0)\n                num++;\n        return num;\n    }\n\n    private static void printResult() {\n        for (int[] row : grid) {\n            for (int i : row) {\n                if (i == -1)\n                    System.out.printf(\"%2s \", ' ');\n                else\n                    System.out.printf(\"%2d \", i);\n            }\n            System.out.println();\n        }\n    }\n}\n"}
{"id": 20427, "name": "Solve a Holy Knight's tour", "source": "Translate Ruby to Java: require 'HLPsolver'\n\nADJACENT = [[-1,-2],[-2,-1],[-2,1],[-1,2],[1,2],[2,1],[2,-1],[1,-2]]\n\nboardy = <<EOS\n. . 0 0 0\n. . 0 . 0 0\n. 0 0 0 0 0 0 0\n0 0 0 . . 0 . 0\n0 . 0 . . 0 0 0\n1 0 0 0 0 0 0\n. . 0 0 . 0\n. . . 0 0 0\nEOS\nt0 = Time.now\nHLPsolver.new(boardy).solve\nputs \" \n", "target": "import java.util.*;\n\npublic class HolyKnightsTour {\n\n    final static String[] board = {\n        \" xxx    \",\n        \" x xx   \",\n        \" xxxxxxx\",\n        \"xxx  x x\",\n        \"x x  xxx\",\n        \"1xxxxxx \",\n        \"  xx x  \",\n        \"   xxx  \"};\n\n    private final static int base = 12;\n    private final static int[][] moves = {{1, -2}, {2, -1}, {2, 1}, {1, 2},\n    {-1, 2}, {-2, 1}, {-2, -1}, {-1, -2}};\n    private static int[][] grid;\n    private static int total = 2;\n\n    public static void main(String[] args) {\n        int row = 0, col = 0;\n\n        grid = new int[base][base];\n\n        for (int r = 0; r < base; r++) {\n            Arrays.fill(grid[r], -1);\n            for (int c = 2; c < base - 2; c++) {\n                if (r >= 2 && r < base - 2) {\n                    if (board[r - 2].charAt(c - 2) == 'x') {\n                        grid[r][c] = 0;\n                        total++;\n                    }\n                    if (board[r - 2].charAt(c - 2) == '1') {\n                        row = r;\n                        col = c;\n                    }\n                }\n            }\n        }\n\n        grid[row][col] = 1;\n\n        if (solve(row, col, 2))\n            printResult();\n    }\n\n    private static boolean solve(int r, int c, int count) {\n        if (count == total)\n            return true;\n\n        List<int[]> nbrs = neighbors(r, c);\n\n        if (nbrs.isEmpty() && count != total)\n            return false;\n\n        Collections.sort(nbrs, (a, b) -> a[2] - b[2]);\n\n        for (int[] nb : nbrs) {\n            r = nb[0];\n            c = nb[1];\n            grid[r][c] = count;\n            if (solve(r, c, count + 1))\n                return true;\n            grid[r][c] = 0;\n        }\n\n        return false;\n    }\n\n    private static List<int[]> neighbors(int r, int c) {\n        List<int[]> nbrs = new ArrayList<>();\n\n        for (int[] m : moves) {\n            int x = m[0];\n            int y = m[1];\n            if (grid[r + y][c + x] == 0) {\n                int num = countNeighbors(r + y, c + x) - 1;\n                nbrs.add(new int[]{r + y, c + x, num});\n            }\n        }\n        return nbrs;\n    }\n\n    private static int countNeighbors(int r, int c) {\n        int num = 0;\n        for (int[] m : moves)\n            if (grid[r + m[1]][c + m[0]] == 0)\n                num++;\n        return num;\n    }\n\n    private static void printResult() {\n        for (int[] row : grid) {\n            for (int i : row) {\n                if (i == -1)\n                    System.out.printf(\"%2s \", ' ');\n                else\n                    System.out.printf(\"%2d \", i);\n            }\n            System.out.println();\n        }\n    }\n}\n"}
{"id": 20428, "name": "Solve a Holy Knight's tour", "source": "Translate Ruby to Python: require 'HLPsolver'\n\nADJACENT = [[-1,-2],[-2,-1],[-2,1],[-1,2],[1,2],[2,1],[2,-1],[1,-2]]\n\nboardy = <<EOS\n. . 0 0 0\n. . 0 . 0 0\n. 0 0 0 0 0 0 0\n0 0 0 . . 0 . 0\n0 . 0 . . 0 0 0\n1 0 0 0 0 0 0\n. . 0 0 . 0\n. . . 0 0 0\nEOS\nt0 = Time.now\nHLPsolver.new(boardy).solve\nputs \" \n", "target": "from sys import stdout\nmoves = [\n    [-1, -2], [1, -2], [-1, 2], [1, 2],\n    [-2, -1], [-2, 1], [2, -1], [2, 1]\n]\n\n\ndef solve(pz, sz, sx, sy, idx, cnt):\n    if idx > cnt:\n        return 1\n\n    for i in range(len(moves)):\n        x = sx + moves[i][0]\n        y = sy + moves[i][1]\n        if sz > x > -1 and sz > y > -1 and pz[x][y] == 0:\n            pz[x][y] = idx\n            if 1 == solve(pz, sz, x, y, idx + 1, cnt):\n                return 1\n            pz[x][y] = 0\n\n    return 0\n\n\ndef find_solution(pz, sz):\n    p = [[-1 for j in range(sz)] for i in range(sz)]\n    idx = x = y = cnt = 0\n    for j in range(sz):\n        for i in range(sz):\n            if pz[idx] == \"x\":\n                p[i][j] = 0\n                cnt += 1\n            elif pz[idx] == \"s\":\n                p[i][j] = 1\n                cnt += 1\n                x = i\n                y = j\n            idx += 1\n\n    if 1 == solve(p, sz, x, y, 2, cnt):\n        for j in range(sz):\n            for i in range(sz):\n                if p[i][j] != -1:\n                    stdout.write(\" {:0{}d}\".format(p[i][j], 2))\n                else:\n                    stdout.write(\"   \")\n            print()\n    else:\n        print(\"Cannot solve this puzzle!\")\n\n\n\nfind_solution(\".xxx.....x.xx....xxxxxxxxxx..x.xx.x..xxxsxxxxxx...xx.x.....xxx..\", 8)\nprint()\nfind_solution(\".....s.x..........x.x.........xxxxx.........xxx.......x..x.x..x..xxxxx...xxxxx..xx.....xx..xxxxx...xxxxx..x..x.x..x.......xxx.........xxxxx.........x.x..........x.x.....\", 13)\n"}
{"id": 20429, "name": "Solve a Holy Knight's tour", "source": "Translate Ruby to Python: require 'HLPsolver'\n\nADJACENT = [[-1,-2],[-2,-1],[-2,1],[-1,2],[1,2],[2,1],[2,-1],[1,-2]]\n\nboardy = <<EOS\n. . 0 0 0\n. . 0 . 0 0\n. 0 0 0 0 0 0 0\n0 0 0 . . 0 . 0\n0 . 0 . . 0 0 0\n1 0 0 0 0 0 0\n. . 0 0 . 0\n. . . 0 0 0\nEOS\nt0 = Time.now\nHLPsolver.new(boardy).solve\nputs \" \n", "target": "from sys import stdout\nmoves = [\n    [-1, -2], [1, -2], [-1, 2], [1, 2],\n    [-2, -1], [-2, 1], [2, -1], [2, 1]\n]\n\n\ndef solve(pz, sz, sx, sy, idx, cnt):\n    if idx > cnt:\n        return 1\n\n    for i in range(len(moves)):\n        x = sx + moves[i][0]\n        y = sy + moves[i][1]\n        if sz > x > -1 and sz > y > -1 and pz[x][y] == 0:\n            pz[x][y] = idx\n            if 1 == solve(pz, sz, x, y, idx + 1, cnt):\n                return 1\n            pz[x][y] = 0\n\n    return 0\n\n\ndef find_solution(pz, sz):\n    p = [[-1 for j in range(sz)] for i in range(sz)]\n    idx = x = y = cnt = 0\n    for j in range(sz):\n        for i in range(sz):\n            if pz[idx] == \"x\":\n                p[i][j] = 0\n                cnt += 1\n            elif pz[idx] == \"s\":\n                p[i][j] = 1\n                cnt += 1\n                x = i\n                y = j\n            idx += 1\n\n    if 1 == solve(p, sz, x, y, 2, cnt):\n        for j in range(sz):\n            for i in range(sz):\n                if p[i][j] != -1:\n                    stdout.write(\" {:0{}d}\".format(p[i][j], 2))\n                else:\n                    stdout.write(\"   \")\n            print()\n    else:\n        print(\"Cannot solve this puzzle!\")\n\n\n\nfind_solution(\".xxx.....x.xx....xxxxxxxxxx..x.xx.x..xxxsxxxxxx...xx.x.....xxx..\", 8)\nprint()\nfind_solution(\".....s.x..........x.x.........xxxxx.........xxx.......x..x.x..x..xxxxx...xxxxx..xx.....xx..xxxxx...xxxxx..x..x.x..x.......xxx.........xxxxx.........x.x..........x.x.....\", 13)\n"}
{"id": 20553, "name": "Parallel calculations", "source": "Translate Ruby to C#: var nums = [1275792312878611, 12345678915808973,\n            1578070919762253, 14700694496703910,];\n\nvar factors = nums.map {|n| prime_factors.ffork(n) }.map { .wait }\nsay ((nums ~Z factors)->max_by {|m| m[1][0] })\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\nclass Program\n{\n    public static List<int> PrimeFactors(int number)\n    {\n        var primes = new List<int>();\n        for (int div = 2; div <= number; div++)\n        {\n            while (number % div == 0)\n            {\n                primes.Add(div);\n                number = number / div;\n            }\n        }\n        return primes;\n    }\n\n    static void Main(string[] args)\n    {\n        int[] n = { 12757923, 12878611, 12757923, 15808973, 15780709, 197622519 };\n        \n        var factors = n.AsParallel().Select(PrimeFactors).ToList();\n        \n        var smallestFactors = factors.Select(thisNumbersFactors => thisNumbersFactors.Min()).ToList();\n        \n        int biggestFactor = smallestFactors.Max();\n        int whatIndexIsThat = smallestFactors.IndexOf(biggestFactor);\n        Console.WriteLine(\"{0} has the largest minimum prime factor: {1}\", n[whatIndexIsThat], biggestFactor);\n        Console.WriteLine(string.Join(\" \", factors[whatIndexIsThat]));\n    }\n}\n"}
{"id": 20555, "name": "Parallel calculations", "source": "Translate Ruby to Java: var nums = [1275792312878611, 12345678915808973,\n            1578070919762253, 14700694496703910,];\n\nvar factors = nums.map {|n| prime_factors.ffork(n) }.map { .wait }\nsay ((nums ~Z factors)->max_by {|m| m[1][0] })\n", "target": "import static java.lang.System.out; \nimport static java.util.Arrays.stream;\nimport static java.util.Comparator.comparing;\n \npublic interface ParallelCalculations {\n    public static final long[] NUMBERS = {\n      12757923,\n      12878611,\n      12878893,\n      12757923,\n      15808973,\n      15780709,\n      197622519\n    };\n \n    public static void main(String... arguments) {\n      stream(NUMBERS)\n        .unordered()\n        .parallel()\n        .mapToObj(ParallelCalculations::minimalPrimeFactor)\n        .max(comparing(a -> a[0]))\n        .ifPresent(res -> out.printf(\n          \"%d has the largest minimum prime factor: %d%n\",\n          res[1],\n          res[0]\n        ));\n    }\n \n    public static long[] minimalPrimeFactor(long n) {\n      for (long i = 2; n >= i * i; i++) {\n        if (n % i == 0) {\n          return new long[]{i, n};\n        }\n      }\n      return new long[]{n, n};\n    }\n}\n"}
{"id": 20556, "name": "Parallel calculations", "source": "Translate Ruby to Python: var nums = [1275792312878611, 12345678915808973,\n            1578070919762253, 14700694496703910,];\n\nvar factors = nums.map {|n| prime_factors.ffork(n) }.map { .wait }\nsay ((nums ~Z factors)->max_by {|m| m[1][0] })\n", "target": "from concurrent import futures\nfrom math import floor, sqrt\n \nNUMBERS = [\n    112272537195293,\n    112582718962171,\n    112272537095293,\n    115280098190773,\n    115797840077099,\n    1099726829285419]\n\n \ndef lowest_factor(n, _start=3):\n    if n % 2 == 0:\n        return 2\n    search_max = int(floor(sqrt(n))) + 1\n    for i in range(_start, search_max, 2):\n        if n % i == 0:\n            return i\n    return n\n\ndef prime_factors(n, lowest):\n    pf = []\n    while n > 1:\n        pf.append(lowest)\n        n //= lowest\n        lowest = lowest_factor(n, max(lowest, 3))\n    return pf\n\ndef prime_factors_of_number_with_lowest_prime_factor(NUMBERS):\n    with futures.ProcessPoolExecutor() as executor:\n        low_factor, number = max( (l, f) for l, f in zip(executor.map(lowest_factor, NUMBERS), NUMBERS) )\n        all_factors = prime_factors(number, low_factor)\n        return number, all_factors\n\n \ndef main():\n    print('For these numbers:')\n    print('\\n  '.join(str(p) for p in NUMBERS))\n    number, all_factors = prime_factors_of_number_with_lowest_prime_factor(NUMBERS)\n    print('    The one with the largest minimum prime factor is {}:'.format(number))\n    print('      All its prime factors in order are: {}'.format(all_factors))\n \nif __name__ == '__main__':\n    main()\n"}
{"id": 20701, "name": "Call a function in a shared library", "source": "Translate Ruby to C#: libm = LibC.dlopen(\"libm.so.6\", LibC::RTLD_LAZY)\nsqrtptr = LibC.dlsym(libm, \"sqrt\") unless libm.null?\n\nif sqrtptr\n  sqrtproc = Proc(Float64, Float64).new sqrtptr, Pointer(Void).null\n  at_exit { LibC.dlclose(libm) }\nelse\n  sqrtproc = ->Math.sqrt(Float64)\nend\n\nputs \"the sqrt of 4 is \n", "target": "using System.Runtime.InteropServices;\n\nclass Program {\n    [DllImport(\"fakelib.dll\")]\n    public static extern int fakefunction(int args);\n\n    static void Main(string[] args) {\n        int r = fakefunction(10);\n    }\n}\n"}
{"id": 20702, "name": "Call a function in a shared library", "source": "Translate Ruby to Java: libm = LibC.dlopen(\"libm.so.6\", LibC::RTLD_LAZY)\nsqrtptr = LibC.dlsym(libm, \"sqrt\") unless libm.null?\n\nif sqrtptr\n  sqrtproc = Proc(Float64, Float64).new sqrtptr, Pointer(Void).null\n  at_exit { LibC.dlclose(libm) }\nelse\n  sqrtproc = ->Math.sqrt(Float64)\nend\n\nputs \"the sqrt of 4 is \n", "target": "\n\nimport java.util.Collections;\nimport java.util.Random;\n\npublic class TrySort {\n    static boolean useC;\n    static {\n\ttry {\n\t    System.loadLibrary(\"TrySort\");\n\t    useC = true;\n\t} catch(UnsatisfiedLinkError e) {\n\t    useC = false;\n\t}\n    }\n    \n    static native void sortInC(int[] ary);\n    \n    static class IntList extends java.util.AbstractList<Integer> {\n\tint[] ary;\n\tIntList(int[] ary) { this.ary = ary; }\n\tpublic Integer get(int i) { return ary[i]; }\n\tpublic Integer set(int i, Integer j) {\n\t    Integer o = ary[i]; ary[i] = j; return o;\n\t}\n\tpublic int size() { return ary.length; }\n    }\n\n    static class ReverseAbsCmp\n\timplements java.util.Comparator<Integer>\n    {\n\tpublic int compare(Integer pa, Integer pb) {\n\t    \n\t    int a = pa > 0 ? -pa : pa;\n\t    int b = pb > 0 ? -pb : pb;\n\t    return a < b ? -1 : a > b ? 1 : 0;\n\t}\n    }\n    \n    static void sortInJava(int[] ary) {\n\tCollections.sort(new IntList(ary), new ReverseAbsCmp());\n    }\n\n    public static void main(String[] args) {\n\t\n\tint[] ary = new int[1000000];\n\tRandom rng = new Random();\n\tfor (int i = 0; i < ary.length; i++)\n\t    ary[i] = rng.nextInt();\n\n\t\n\tif (useC) {\n\t    System.out.print(\"Sorting in C...  \");\n\t    sortInC(ary);\n\t} else {\n\t    System.out.print\n\t\t(\"Missing library for C!  Sorting in Java...  \");\n\t    sortInJava(ary);\n\t}\n\n\tfor (int i = 0; i < ary.length - 1; i++) {\n\t    int a = ary[i];\n\t    int b = ary[i + 1];\n\t    if ((a > 0 ? -a : a) > (b > 0 ? -b : b)) {\n\t\tSystem.out.println(\"*BUG IN SORT*\");\n\t\tSystem.exit(1);\n\t    }\n\t}\n\tSystem.out.println(\"ok\");\n    }\n}\n"}
{"id": 20703, "name": "Call a function in a shared library", "source": "Translate Ruby to Python: libm = LibC.dlopen(\"libm.so.6\", LibC::RTLD_LAZY)\nsqrtptr = LibC.dlsym(libm, \"sqrt\") unless libm.null?\n\nif sqrtptr\n  sqrtproc = Proc(Float64, Float64).new sqrtptr, Pointer(Void).null\n  at_exit { LibC.dlclose(libm) }\nelse\n  sqrtproc = ->Math.sqrt(Float64)\nend\n\nputs \"the sqrt of 4 is \n", "target": "import ctypes\n  \nuser32_dll = ctypes.cdll.LoadLibrary('User32.dll')\nprint user32_dll.GetDoubleClickTime()\n"}
{"id": 20851, "name": "Reduced row echelon form", "source": "Translate Ruby to C#: \ndef reduced_row_echelon_form(ary)\n  lead = 0\n  rows = ary.size\n  cols = ary[0].size\n  rary = convert_to(ary, :to_r)  \n  catch :done  do\n    rows.times do |r|\n      throw :done  if cols <= lead\n      i = r\n      while rary[i][lead] == 0\n        i += 1\n        if rows == i\n          i = r\n          lead += 1\n          throw :done  if cols == lead\n        end\n      end\n      \n      rary[i], rary[r] = rary[r], rary[i]\n      \n      v = rary[r][lead]\n      rary[r].collect! {|x| x / v}\n      \n      rows.times do |i|\n        next if i == r\n        v = rary[i][lead]\n        rary[i].each_index {|j| rary[i][j] -= v * rary[r][j]}\n      end\n      lead += 1\n    end\n  end\n  rary\nend\n\n\ndef convert_to(ary, type)\n  ary.each_with_object([]) do |row, new|\n    new << row.collect {|elem| elem.send(type)}\n  end\nend\n\nclass Rational\n  alias _to_s to_s\n  def to_s\n    denominator==1 ? numerator.to_s : _to_s\n  end\nend\n\ndef print_matrix(m)\n  max = m[0].collect {-1}\n  m.each {|row| row.each_index {|i| max[i] = [max[i], row[i].to_s.length].max}}\n  m.each {|row| row.each_index {|i| print \"%\nend\n\nmtx = [\n  [ 1, 2, -1, -4],\n  [ 2, 3, -1,-11],\n  [-2, 0, -3, 22]\n]\nprint_matrix reduced_row_echelon_form(mtx)\nputs\n\nmtx = [\n  [ 1, 2, 3, 7],\n  [-4, 7,-2, 7],\n  [ 3, 3, 0, 7]\n]\nreduced = reduced_row_echelon_form(mtx)\nprint_matrix reduced\nprint_matrix convert_to(reduced, :to_f)\n", "target": "using System;\n\nnamespace rref\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            int[,] matrix = new int[3, 4]{\n                {  1, 2, -1,  -4 },\n                {  2, 3, -1, -11 },\n                { -2, 0, -3,  22 }\n            };\n            matrix = rref(matrix);   \n        }\n\n        private static int[,] rref(int[,] matrix)\n        {            \n            int lead = 0, rowCount = matrix.GetLength(0), columnCount = matrix.GetLength(1);\n            for (int r = 0; r < rowCount; r++)\n            {\n                if (columnCount <= lead) break;\n                int i = r;\n                while (matrix[i, lead] == 0)\n                {\n                    i++;\n                    if (i == rowCount)\n                    {\n                        i = r;\n                        lead++;\n                        if (columnCount == lead)\n                        {\n                        lead--;\n                        break;\n                        }\n                    }\n                }\n                for (int j = 0; j < columnCount; j++)\n                {\n                    int temp = matrix[r, j];\n                    matrix[r, j] = matrix[i, j];\n                    matrix[i, j] = temp;\n                }\n                int div = matrix[r, lead];\n                if(div != 0)\n                    for (int j = 0; j < columnCount; j++) matrix[r, j] /= div;                \n                for (int j = 0; j < rowCount; j++)\n                {\n                    if (j != r)\n                    {\n                        int sub = matrix[j, lead];\n                        for (int k = 0; k < columnCount; k++) matrix[j, k] -= (sub * matrix[r, k]);\n                    }\n                }\n                lead++;\n            }\n            return matrix;\n        }\n    }\n}\n"}
{"id": 20853, "name": "Reduced row echelon form", "source": "Translate Ruby to Java: \ndef reduced_row_echelon_form(ary)\n  lead = 0\n  rows = ary.size\n  cols = ary[0].size\n  rary = convert_to(ary, :to_r)  \n  catch :done  do\n    rows.times do |r|\n      throw :done  if cols <= lead\n      i = r\n      while rary[i][lead] == 0\n        i += 1\n        if rows == i\n          i = r\n          lead += 1\n          throw :done  if cols == lead\n        end\n      end\n      \n      rary[i], rary[r] = rary[r], rary[i]\n      \n      v = rary[r][lead]\n      rary[r].collect! {|x| x / v}\n      \n      rows.times do |i|\n        next if i == r\n        v = rary[i][lead]\n        rary[i].each_index {|j| rary[i][j] -= v * rary[r][j]}\n      end\n      lead += 1\n    end\n  end\n  rary\nend\n\n\ndef convert_to(ary, type)\n  ary.each_with_object([]) do |row, new|\n    new << row.collect {|elem| elem.send(type)}\n  end\nend\n\nclass Rational\n  alias _to_s to_s\n  def to_s\n    denominator==1 ? numerator.to_s : _to_s\n  end\nend\n\ndef print_matrix(m)\n  max = m[0].collect {-1}\n  m.each {|row| row.each_index {|i| max[i] = [max[i], row[i].to_s.length].max}}\n  m.each {|row| row.each_index {|i| print \"%\nend\n\nmtx = [\n  [ 1, 2, -1, -4],\n  [ 2, 3, -1,-11],\n  [-2, 0, -3, 22]\n]\nprint_matrix reduced_row_echelon_form(mtx)\nputs\n\nmtx = [\n  [ 1, 2, 3, 7],\n  [-4, 7,-2, 7],\n  [ 3, 3, 0, 7]\n]\nreduced = reduced_row_echelon_form(mtx)\nprint_matrix reduced\nprint_matrix convert_to(reduced, :to_f)\n", "target": "import java.util.*;\nimport java.lang.Math;\nimport org.apache.commons.math.fraction.Fraction;\nimport org.apache.commons.math.fraction.FractionConversionException;\n\n\nclass Matrix {\n\tLinkedList<LinkedList<Fraction>> matrix;\n\tint numRows;\n\tint numCols;\t\n\t\n\tstatic class Coordinate {\n\t\tint row;\n\t\tint col;\n\n\t\tCoordinate(int r, int c) {\n\t\t\trow = r;\n\t\t\tcol = c;\n\t\t}\n\n\t\tpublic String toString() {\n\t\t\treturn \"(\" + row + \", \" + col + \")\";\n\t\t}\n\t}\n\n\tMatrix(double [][] m) {\n\t\tnumRows = m.length;\t\n\t\tnumCols = m[0].length;\n\n\t\tmatrix = new LinkedList<LinkedList<Fraction>>();\n\n\t\tfor (int i = 0; i < numRows; i++) {\n\t\t\tmatrix.add(new LinkedList<Fraction>());\n\t\t\tfor (int j = 0; j < numCols; j++) {\n\t\t\t\ttry {\n\t\t\t\t\tmatrix.get(i).add(new Fraction(m[i][j]));\n\t\t\t\t} catch (FractionConversionException e) {\n\t\t\t\t\tSystem.err.println(\"Fraction could not be converted from double by apache commons . . .\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic void Interchange(Coordinate a, Coordinate b) {\n\t\tLinkedList<Fraction> temp = matrix.get(a.row);\n\t\tmatrix.set(a.row, matrix.get(b.row));\t\t\n\t\tmatrix.set(b.row, temp);\n\n\t\tint t = a.row;\n\t\ta.row = b.row;\n\t\tb.row = t;\n\t} \n\n\tpublic void Scale(Coordinate x, Fraction d) {\n\t\tLinkedList<Fraction> row = matrix.get(x.row);\n\t\tfor (int i = 0; i < numCols; i++) {\n\t\t\trow.set(i, row.get(i).multiply(d));\n\t\t}\n\t}\n\n\tpublic void MultiplyAndAdd(Coordinate to, Coordinate from, Fraction scalar) {\n\t\tLinkedList<Fraction> row = matrix.get(to.row);\n\t\tLinkedList<Fraction> rowMultiplied = matrix.get(from.row);\n\n\t\tfor (int i = 0; i < numCols; i++) {\n\t\t\trow.set(i, row.get(i).add((rowMultiplied.get(i).multiply(scalar))));\n\t\t}\n\t}\n\n\tpublic void RREF() {\n\t\tCoordinate pivot = new Coordinate(0,0);\n\n\t\tint submatrix = 0;\n\t\tfor (int x = 0; x < numCols; x++) {\n\t\t\tpivot = new Coordinate(pivot.row, x);\n\t\t\t\n\t\t\t\t\n\t\t\t\tfor (int i = x; i < numCols; i++) {\n\t\t\t\t\tif (isColumnZeroes(pivot) == false) {\n\t\t\t\t\t\tbreak;\t\n\t\t\t\t\t} else {\n\t\t\t\t\t\tpivot.col = i;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\n\t\t\t\t\n\t\t\t\tpivot = findPivot(pivot);\n\t\t\t\n\t\t\t\tif (getCoordinate(pivot).doubleValue() == 0.0) {\n\t\t\t\t\tpivot.row++;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\t\n\t\t\t\t\n\t\t\t\tif (pivot.row != submatrix) {\n\t\t\t\t\tInterchange(new Coordinate(submatrix, pivot.col), pivot);\n\t\t\t\t}\n\t\t\n\t\t\t\t\n\t\t\t\tif (getCoordinate(pivot).doubleValue() != 1) {\n\t\t\t\t\t\n\t\t\t\t\tFraction scalar = getCoordinate(pivot).reciprocal();\n\t\t\t\t\tScale(pivot, scalar);\n\t\t\t\t}\n\t\t\t\n\t\t\t\t\n\t\t\t\t\n\t\t\t\tfor (int i = pivot.row; i < numRows; i++) {\n\t\t\t\t\tif (i == pivot.row) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tCoordinate belowPivot = new Coordinate(i, pivot.col);\n\t\t\t\t\tFraction complement = (getCoordinate(belowPivot).negate().divide(getCoordinate(pivot)));\n\t\t\t\t\tMultiplyAndAdd(belowPivot, pivot, complement);\n\t\t\t\t}\n\t\t\t\n\t\t\t\t\n\t\t\t\t\n\t\t\t\t\t\n\t\t\t\tfor (int i = pivot.row; i >= 0; i--) {\n\t\t\t\t\tif (i == pivot.row) {\n\t\t\t\t\t\tif (getCoordinate(pivot).doubleValue() != 1.0) {\n\t\t\t\t\t\t\tScale(pivot, getCoordinate(pivot).reciprocal());\t\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif (i == pivot.row) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\n\t\t\t\t\tCoordinate abovePivot = new Coordinate(i, pivot.col);\n\t\t\t\t\tFraction complement = (getCoordinate(abovePivot).negate().divide(getCoordinate(pivot)));\n\t\t\t\t\tMultiplyAndAdd(abovePivot, pivot, complement);\n\t\t\t\t}\n\t\t\t\n\t\t\t\t\n\t\t\t\t\n\t\t\t\tif ((pivot.row + 1) >= numRows || isRowZeroes(new Coordinate(pivot.row+1, pivot.col))) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tsubmatrix++;\n\t\t\t\tpivot.row++;\n\t\t}\n\t}\n\t\n\tpublic boolean isColumnZeroes(Coordinate a) {\n\t\tfor (int i = 0; i < numRows; i++) {\n\t\t\tif (matrix.get(i).get(a.col).doubleValue() != 0.0) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\treturn true;\n\t}\n\n\tpublic boolean isRowZeroes(Coordinate a) {\n\t\tfor (int i = 0; i < numCols; i++) {\n\t\t\tif (matrix.get(a.row).get(i).doubleValue() != 0.0) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\treturn true;\n\t}\n\n\tpublic Coordinate findPivot(Coordinate a) {\n\t\tint first_row = a.row;\n\t\tCoordinate pivot = new Coordinate(a.row, a.col);\n\t\tCoordinate current = new Coordinate(a.row, a.col);\t\n\n\t\tfor (int i = a.row; i < (numRows - first_row); i++) {\n\t\t\tcurrent.row = i;\n\t\t\tif (getCoordinate(current).doubleValue() == 1.0) {\n\t\t\t\tInterchange(current, a);\n\t\t\t}\n\t\t}\n\n\t\tcurrent.row = a.row;\n\t\tfor (int i = current.row; i < (numRows - first_row); i++) {\n\t\t\tcurrent.row = i;\n\t\t\tif (getCoordinate(current).doubleValue() != 0) {\n\t\t\t\tpivot.row = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\n\t\t\n\t\treturn pivot;\t\n\t}\t\n\n\tpublic Fraction getCoordinate(Coordinate a) {\n\t\treturn matrix.get(a.row).get(a.col);\n\t}\n\n\tpublic String toString() {\n\t\treturn matrix.toString().replace(\"], \", \"]\\n\");\n\t}\n\n\tpublic static void main (String[] args) {\n        \tdouble[][] matrix_1 = {\n\t\t\t{1, 2, -1, -4},\n\t\t\t{2, 3, -1, -11},\n\t\t\t{-2, 0, -3, 22}\n\t\t};\n\n\t\tMatrix x = new Matrix(matrix_1);\n\t\tSystem.out.println(\"before\\n\" + x.toString() + \"\\n\");\n\t\tx.RREF();\n\t\tSystem.out.println(\"after\\n\" + x.toString() + \"\\n\");\n\n\t\tdouble matrix_2 [][] = {\n\t\t\t{2, 0, -1, 0, 0},\n\t\t\t{1, 0, 0, -1, 0},\n\t\t\t{3, 0, 0, -2, -1},\n\t\t\t{0, 1, 0, 0, -2},\n\t\t\t{0, 1, -1, 0, 0}\n\t\t};\n\t\n\t\tMatrix y = new Matrix(matrix_2);\n\t\tSystem.out.println(\"before\\n\" + y.toString() + \"\\n\");\n\t\ty.RREF();\n\t\tSystem.out.println(\"after\\n\" + y.toString() + \"\\n\");\n\n\t\tdouble matrix_3 [][] = {\n\t\t\t{1, 2, 3, 4, 3, 1},\n\t\t\t{2, 4, 6, 2, 6, 2},\n\t\t\t{3, 6, 18, 9, 9, -6},\n\t\t\t{4, 8, 12, 10, 12, 4},\n\t\t\t{5, 10, 24, 11, 15, -4}\n\t\t};\n\n\t\tMatrix z = new Matrix(matrix_3);\n\t\tSystem.out.println(\"before\\n\" + z.toString() + \"\\n\");\n\t\tz.RREF();\n\t\tSystem.out.println(\"after\\n\" + z.toString() + \"\\n\");\n\n\t\tdouble matrix_4 [][] = {\n\t\t\t{0, 1},\n\t\t\t{1, 2},\n\t\t\t{0,5}\n\t\t};\n\n\t\tMatrix a = new Matrix(matrix_4);\n\t\tSystem.out.println(\"before\\n\" + a.toString() + \"\\n\");\n\t\ta.RREF();\n\t\tSystem.out.println(\"after\\n\" + a.toString() + \"\\n\");\n\t}\t\n}\n"}
{"id": 20854, "name": "Reduced row echelon form", "source": "Translate Ruby to Python: \ndef reduced_row_echelon_form(ary)\n  lead = 0\n  rows = ary.size\n  cols = ary[0].size\n  rary = convert_to(ary, :to_r)  \n  catch :done  do\n    rows.times do |r|\n      throw :done  if cols <= lead\n      i = r\n      while rary[i][lead] == 0\n        i += 1\n        if rows == i\n          i = r\n          lead += 1\n          throw :done  if cols == lead\n        end\n      end\n      \n      rary[i], rary[r] = rary[r], rary[i]\n      \n      v = rary[r][lead]\n      rary[r].collect! {|x| x / v}\n      \n      rows.times do |i|\n        next if i == r\n        v = rary[i][lead]\n        rary[i].each_index {|j| rary[i][j] -= v * rary[r][j]}\n      end\n      lead += 1\n    end\n  end\n  rary\nend\n\n\ndef convert_to(ary, type)\n  ary.each_with_object([]) do |row, new|\n    new << row.collect {|elem| elem.send(type)}\n  end\nend\n\nclass Rational\n  alias _to_s to_s\n  def to_s\n    denominator==1 ? numerator.to_s : _to_s\n  end\nend\n\ndef print_matrix(m)\n  max = m[0].collect {-1}\n  m.each {|row| row.each_index {|i| max[i] = [max[i], row[i].to_s.length].max}}\n  m.each {|row| row.each_index {|i| print \"%\nend\n\nmtx = [\n  [ 1, 2, -1, -4],\n  [ 2, 3, -1,-11],\n  [-2, 0, -3, 22]\n]\nprint_matrix reduced_row_echelon_form(mtx)\nputs\n\nmtx = [\n  [ 1, 2, 3, 7],\n  [-4, 7,-2, 7],\n  [ 3, 3, 0, 7]\n]\nreduced = reduced_row_echelon_form(mtx)\nprint_matrix reduced\nprint_matrix convert_to(reduced, :to_f)\n", "target": "def ToReducedRowEchelonForm( M):\n    if not M: return\n    lead = 0\n    rowCount = len(M)\n    columnCount = len(M[0])\n    for r in range(rowCount):\n        if lead >= columnCount:\n            return\n        i = r\n        while M[i][lead] == 0:\n            i += 1\n            if i == rowCount:\n                i = r\n                lead += 1\n                if columnCount == lead:\n                    return\n        M[i],M[r] = M[r],M[i]\n        lv = M[r][lead]\n        M[r] = [ mrx / float(lv) for mrx in M[r]]\n        for i in range(rowCount):\n            if i != r:\n                lv = M[i][lead]\n                M[i] = [ iv - lv*rv for rv,iv in zip(M[r],M[i])]\n        lead += 1\n\n\nmtx = [\n   [ 1, 2, -1, -4],\n   [ 2, 3, -1, -11],\n   [-2, 0, -3, 22],]\n\nToReducedRowEchelonForm( mtx )\n\nfor rw in mtx:\n  print ', '.join( (str(rv) for rv in rw) )\n"}
{"id": 21111, "name": "Power set", "source": "Translate Ruby to C#: \n\n\nclass Array\n  \n  def power_set\n    \n    \n    \n    \n    inject([[]]) do |acc, you|\n      ret = []             \n      acc.each do |i|      \n        ret << i           \n        ret << i + [you]   \n      end\n      ret       \n    end\n    \n  end\n  \n  \n  def func_power_set\n    inject([[]]) { |ps,item|    \n      ps +                      \n      ps.map { |e| e + [item] } \n    }\n  end\nend\n\n\nrequire 'set'\nclass Set\n  def powerset \n    inject(Set[Set[]]) do |ps, item| \n      ps.union ps.map {|e| e.union (Set.new [item])}\n    end\n  end\nend\n\np [1,2,3,4].power_set\np %w(one two three).func_power_set\n\np Set[1,2,3].powerset\n", "target": "public IEnumerable<IEnumerable<T>> GetPowerSet<T>(List<T> list)\n{\n    return from m in Enumerable.Range(0, 1 << list.Count)\n                  select\n                      from i in Enumerable.Range(0, list.Count)\n                      where (m & (1 << i)) != 0\n                      select list[i];\n}\n\npublic void PowerSetofColors()\n{\n    var colors = new List<KnownColor> { KnownColor.Red, KnownColor.Green, \n        KnownColor.Blue, KnownColor.Yellow };\n    \n    var result = GetPowerSet(colors);\n    \n    Console.Write( string.Join( Environment.NewLine, \n        result.Select(subset => \n            string.Join(\",\", subset.Select(clr => clr.ToString()).ToArray())).ToArray()));\n}\n"}
{"id": 21113, "name": "Power set", "source": "Translate Ruby to Java: \n\n\nclass Array\n  \n  def power_set\n    \n    \n    \n    \n    inject([[]]) do |acc, you|\n      ret = []             \n      acc.each do |i|      \n        ret << i           \n        ret << i + [you]   \n      end\n      ret       \n    end\n    \n  end\n  \n  \n  def func_power_set\n    inject([[]]) { |ps,item|    \n      ps +                      \n      ps.map { |e| e + [item] } \n    }\n  end\nend\n\n\nrequire 'set'\nclass Set\n  def powerset \n    inject(Set[Set[]]) do |ps, item| \n      ps.union ps.map {|e| e.union (Set.new [item])}\n    end\n  end\nend\n\np [1,2,3,4].power_set\np %w(one two three).func_power_set\n\np Set[1,2,3].powerset\n", "target": "public static ArrayList<String> getpowerset(int a[],int n,ArrayList<String> ps)\n    {\n        if(n<0)\n        {\n            return null;\n        }\n        if(n==0)\n        {\n            if(ps==null)\n                ps=new ArrayList<String>();\n            ps.add(\" \");\n            return ps;\n        }\n        ps=getpowerset(a, n-1, ps);\n        ArrayList<String> tmp=new ArrayList<String>();\n        for(String s:ps)\n        {\n            if(s.equals(\" \"))\n                tmp.add(\"\"+a[n-1]);\n            else\n                tmp.add(s+a[n-1]);\n        }\n        ps.addAll(tmp);\n        return ps;\n    }\n"}
{"id": 21114, "name": "Power set", "source": "Translate Ruby to Python: \n\n\nclass Array\n  \n  def power_set\n    \n    \n    \n    \n    inject([[]]) do |acc, you|\n      ret = []             \n      acc.each do |i|      \n        ret << i           \n        ret << i + [you]   \n      end\n      ret       \n    end\n    \n  end\n  \n  \n  def func_power_set\n    inject([[]]) { |ps,item|    \n      ps +                      \n      ps.map { |e| e + [item] } \n    }\n  end\nend\n\n\nrequire 'set'\nclass Set\n  def powerset \n    inject(Set[Set[]]) do |ps, item| \n      ps.union ps.map {|e| e.union (Set.new [item])}\n    end\n  end\nend\n\np [1,2,3,4].power_set\np %w(one two three).func_power_set\n\np Set[1,2,3].powerset\n", "target": "def list_powerset(lst):\n    \n    result = [[]]\n    for x in lst:\n        \n        \n        \n        \n        \n        \n        result.extend([subset + [x] for subset in result])\n    return result\n\n\ndef list_powerset2(lst):\n    return reduce(lambda result, x: result + [subset + [x] for subset in result],\n                  lst, [[]])\n\ndef powerset(s):\n    return frozenset(map(frozenset, list_powerset(list(s))))\n"}
{"id": 21366, "name": "Hamming numbers", "source": "Translate Ruby to C#: require \"big\"\n\ndef hamming(limit)\n  h = Array.new(limit, 1.to_big_i)     \n  x2, x3, x5 = 2.to_big_i, 3.to_big_i, 5.to_big_i\n  i, j, k = 0, 0, 0\n  (1...limit).each do |n|              \n    h[n] = Math.min(x2, Math.min(x3, x5))\n    x2 = 2 * h[i += 1] if x2 == h[n]\n    x3 = 3 * h[j += 1] if x3 == h[n]\n    x5 = 5 * h[k += 1] if x5 == h[n]\n  end\n  h[limit - 1]\nend\n\nstart = Time.monotonic\nprint \"Hamming Number (1..20): \"; (1..20).each { |i| print \"\nputs\nputs \"Hamming Number 1691: \nputs \"Hamming Number 1,000,000: \nputs \"Elasped Time: \n", "target": "using System;\nusing System.Numerics;\nusing System.Linq;\n\nnamespace Hamming {\n\n    class MainClass {\n\n        public static BigInteger Hamming(int n) {\n            BigInteger two = 2, three = 3, five = 5;\n            var h = new BigInteger[n];\n            h[0] = 1;\n            BigInteger x2 = 2, x3 = 3, x5 = 5;\n            int i = 0, j = 0, k = 0;\n            \n            for (int index = 1; index < n; index++) {\n                h[index] = BigInteger.Min(x2, BigInteger.Min(x3, x5));\n                if (h[index] == x2) x2 = two * h[++i];\n                if (h[index] == x3) x3 = three * h[++j];\n                if (h[index] == x5) x5 = five * h[++k];\n            }\n            return h[n - 1];\n        }\n\n        public static void Main(string[] args) {\n            Console.WriteLine(string.Join(\" \", Enumerable.Range(1, 20).ToList().Select(x => Hamming(x))));\n            Console.WriteLine(Hamming(1691));\n            Console.WriteLine(Hamming(1000000));\n        }\n    }\n}\n"}
{"id": 21368, "name": "Hamming numbers", "source": "Translate Ruby to Java: require \"big\"\n\ndef hamming(limit)\n  h = Array.new(limit, 1.to_big_i)     \n  x2, x3, x5 = 2.to_big_i, 3.to_big_i, 5.to_big_i\n  i, j, k = 0, 0, 0\n  (1...limit).each do |n|              \n    h[n] = Math.min(x2, Math.min(x3, x5))\n    x2 = 2 * h[i += 1] if x2 == h[n]\n    x3 = 3 * h[j += 1] if x3 == h[n]\n    x5 = 5 * h[k += 1] if x5 == h[n]\n  end\n  h[limit - 1]\nend\n\nstart = Time.monotonic\nprint \"Hamming Number (1..20): \"; (1..20).each { |i| print \"\nputs\nputs \"Hamming Number 1691: \nputs \"Hamming Number 1,000,000: \nputs \"Elasped Time: \n", "target": "import java.math.BigInteger;\nimport java.util.PriorityQueue;\n\nfinal class Hamming {\n    private static BigInteger THREE = BigInteger.valueOf(3);\n    private static BigInteger FIVE = BigInteger.valueOf(5);\n\n    private static void updateFrontier(BigInteger x,\n                                       PriorityQueue<BigInteger> pq) {\n        pq.offer(x.shiftLeft(1));\n        pq.offer(x.multiply(THREE));\n        pq.offer(x.multiply(FIVE));\n    }\n\n    public static BigInteger hamming(int n) {\n        if (n <= 0)\n            throw new IllegalArgumentException(\"Invalid parameter\");\n        PriorityQueue<BigInteger> frontier = new PriorityQueue<BigInteger>();\n        updateFrontier(BigInteger.ONE, frontier);\n        BigInteger lowest = BigInteger.ONE;\n        for (int i = 1; i < n; i++) {\n            lowest = frontier.poll();\n            while (frontier.peek().equals(lowest))\n                frontier.poll();\n            updateFrontier(lowest, frontier);\n        }\n        return lowest;\n    }\n\n    public static void main(String[] args) {\n        System.out.print(\"Hamming(1 .. 20) =\");\n        for (int i = 1; i < 21; i++)\n             System.out.print(\" \" + hamming(i));\n        System.out.println(\"\\nHamming(1691) = \" + hamming(1691));\n        System.out.println(\"Hamming(1000000) = \" + hamming(1000000));\n    }\n}\n"}
{"id": 21369, "name": "Hamming numbers", "source": "Translate Ruby to Python: require \"big\"\n\ndef hamming(limit)\n  h = Array.new(limit, 1.to_big_i)     \n  x2, x3, x5 = 2.to_big_i, 3.to_big_i, 5.to_big_i\n  i, j, k = 0, 0, 0\n  (1...limit).each do |n|              \n    h[n] = Math.min(x2, Math.min(x3, x5))\n    x2 = 2 * h[i += 1] if x2 == h[n]\n    x3 = 3 * h[j += 1] if x3 == h[n]\n    x5 = 5 * h[k += 1] if x5 == h[n]\n  end\n  h[limit - 1]\nend\n\nstart = Time.monotonic\nprint \"Hamming Number (1..20): \"; (1..20).each { |i| print \"\nputs\nputs \"Hamming Number 1691: \nputs \"Hamming Number 1,000,000: \nputs \"Elasped Time: \n", "target": "from itertools import islice\n\ndef hamming2():\n    \n    h = 1\n    _h=[h]    \n    multipliers  = (2, 3, 5)\n    multindeces  = [0 for i in multipliers] \n    multvalues   = [x * _h[i] for x,i in zip(multipliers, multindeces)]\n    yield h\n    while True:\n        h = min(multvalues)\n        _h.append(h)\n        for (n,(v,x,i)) in enumerate(zip(multvalues, multipliers, multindeces)):\n            if v == h:\n                i += 1\n                multindeces[n] = i\n                multvalues[n]  = x * _h[i]\n        \n        mini = min(multindeces)\n        if mini >= 1000:\n            del _h[:mini]\n            multindeces = [i - mini for i in multindeces]\n        \n        yield h\n"}
{"id": 21538, "name": "Topological sort", "source": "Translate Ruby to C#: require 'tsort'\nclass Hash\n  include TSort\n  alias tsort_each_node each_key\n  def tsort_each_child(node, &block)\n    fetch(node).each(&block)\n  end\nend\n\ndepends = {}\nDATA.each do |line|\n  key, *libs = line.split\n  depends[key] = libs\n  libs.each {|lib| depends[lib] ||= []}\nend\n\nbegin\n  p depends.tsort\n  depends[\"dw01\"] << \"dw04\"\n  p depends.tsort\nrescue TSort::Cyclic => e\n  puts \"\\ncycle detected: \nend\n\n__END__\ndes_system_lib   std synopsys std_cell_lib des_system_lib dw02 dw01 ramlib ieee\ndw01             ieee dw01 dware gtech\ndw02             ieee dw02 dware\ndw03             std synopsys dware dw03 dw02 dw01 ieee gtech\ndw04             dw04 ieee dw01 dware gtech\ndw05             dw05 ieee dware\ndw06             dw06 ieee dware\ndw07             ieee dware\ndware            ieee dware\ngtech            ieee gtech\nramlib           std ieee\nstd_cell_lib     ieee std_cell_lib\nsynopsys\n", "target": "namespace Algorithms\n{\n    using System;\n    using System.Collections.Generic;\n    using System.Linq;\n\n    public class TopologicalSorter<ValueType>\n    {\n        private class Relations\n        {\n            public int Dependencies = 0;\n            public HashSet<ValueType> Dependents = new HashSet<ValueType>();\n        }\n\n        private Dictionary<ValueType, Relations> _map = new Dictionary<ValueType, Relations>();\n\n        public void Add(ValueType obj)\n        {\n            if (!_map.ContainsKey(obj)) _map.Add(obj, new Relations());\n        }\n\n        public void Add(ValueType obj, ValueType dependency)\n        {\n            if (dependency.Equals(obj)) return;\n\n            if (!_map.ContainsKey(dependency)) _map.Add(dependency, new Relations());\n\n            var dependents = _map[dependency].Dependents;\n\n            if (!dependents.Contains(obj))\n            {\n                dependents.Add(obj);\n\n                if (!_map.ContainsKey(obj)) _map.Add(obj, new Relations());\n\n                ++_map[obj].Dependencies;\n            }\n        }\n\n        public void Add(ValueType obj, IEnumerable<ValueType> dependencies)\n        {\n            foreach (var dependency in dependencies) Add(obj, dependency);\n        }\n\n        public void Add(ValueType obj, params ValueType[] dependencies)\n        {\n            Add(obj, dependencies as IEnumerable<ValueType>);\n        }\n\n        public Tuple<IEnumerable<ValueType>, IEnumerable<ValueType>> Sort()\n        {\n            List<ValueType> sorted = new List<ValueType>(), cycled = new List<ValueType>();\n            var map = _map.ToDictionary(kvp => kvp.Key, kvp => kvp.Value);\n\n            sorted.AddRange(map.Where(kvp => kvp.Value.Dependencies == 0).Select(kvp => kvp.Key));\n\n            for (int idx = 0; idx < sorted.Count; ++idx) sorted.AddRange(map[sorted[idx]].Dependents.Where(k => --map[k].Dependencies == 0));\n\n            cycled.AddRange(map.Where(kvp => kvp.Value.Dependencies != 0).Select(kvp => kvp.Key));\n\n            return new Tuple<IEnumerable<ValueType>, IEnumerable<ValueType>>(sorted, cycled);\n        }\n\n        public void Clear()\n        {\n            _map.Clear();\n        }\n    }\n\n}\n\n\n\nnamespace ExampleApplication\n{\n    using Algorithms;\n    using System;\n    using System.Collections.Generic;\n    using System.Linq;\n\n    public class Task\n    {\n        public string Message;\n    }\n\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            List<Task> tasks = new List<Task>\n            {\n                new Task{ Message = \"A - depends on B and C\" },    \n                new Task{ Message = \"B - depends on none\" },       \n                new Task{ Message = \"C - depends on D and E\" },    \n                new Task{ Message = \"D - depends on none\" },       \n                new Task{ Message = \"E - depends on F, G and H\" }, \n                new Task{ Message = \"F - depends on I\" },          \n                new Task{ Message = \"G - depends on none\" },       \n                new Task{ Message = \"H - depends on none\" },       \n                new Task{ Message = \"I - depends on none\" },       \n            };\n\n            TopologicalSorter<Task> resolver = new TopologicalSorter<Task>();\n\n            \n            resolver.Add(tasks[0], new[] { tasks[1], tasks[2] });\n            \n            resolver.Add(tasks[2], new[] { tasks[3], tasks[4] });\n            \n            resolver.Add(tasks[4], tasks[5], tasks[6], tasks[7]);\n            resolver.Add(tasks[5], tasks[8]);\n            \n            \n\n            \n\n            var result = resolver.Sort();\n            var sorted = result.Item1;\n            var cycled = result.Item2;\n\n            if (!cycled.Any())\n            {\n                foreach (var d in sorted) Console.WriteLine(d.Message);\n            }\n            else\n            {\n                Console.Write(\"Cycled dependencies detected: \");\n\n                foreach (var d in cycled) Console.Write($\"{d.Message[0]} \");\n\n                Console.WriteLine();\n            }\n\n            Console.WriteLine(\"exiting...\");\n        }\n    }\n}\n"}
{"id": 21540, "name": "Topological sort", "source": "Translate Ruby to Java: require 'tsort'\nclass Hash\n  include TSort\n  alias tsort_each_node each_key\n  def tsort_each_child(node, &block)\n    fetch(node).each(&block)\n  end\nend\n\ndepends = {}\nDATA.each do |line|\n  key, *libs = line.split\n  depends[key] = libs\n  libs.each {|lib| depends[lib] ||= []}\nend\n\nbegin\n  p depends.tsort\n  depends[\"dw01\"] << \"dw04\"\n  p depends.tsort\nrescue TSort::Cyclic => e\n  puts \"\\ncycle detected: \nend\n\n__END__\ndes_system_lib   std synopsys std_cell_lib des_system_lib dw02 dw01 ramlib ieee\ndw01             ieee dw01 dware gtech\ndw02             ieee dw02 dware\ndw03             std synopsys dware dw03 dw02 dw01 ieee gtech\ndw04             dw04 ieee dw01 dware gtech\ndw05             dw05 ieee dware\ndw06             dw06 ieee dware\ndw07             ieee dware\ndware            ieee dware\ngtech            ieee gtech\nramlib           std ieee\nstd_cell_lib     ieee std_cell_lib\nsynopsys\n", "target": "import java.util.*;\n\npublic class TopologicalSort {\n\n    public static void main(String[] args) {\n        String s = \"std, ieee, des_system_lib, dw01, dw02, dw03, dw04, dw05,\"\n                + \"dw06, dw07, dware, gtech, ramlib, std_cell_lib, synopsys\";\n\n        Graph g = new Graph(s, new int[][]{\n            {2, 0}, {2, 14}, {2, 13}, {2, 4}, {2, 3}, {2, 12}, {2, 1},\n            {3, 1}, {3, 10}, {3, 11},\n            {4, 1}, {4, 10},\n            {5, 0}, {5, 14}, {5, 10}, {5, 4}, {5, 3}, {5, 1}, {5, 11},\n            {6, 1}, {6, 3}, {6, 10}, {6, 11},\n            {7, 1}, {7, 10},\n            {8, 1}, {8, 10},\n            {9, 1}, {9, 10},\n            {10, 1},\n            {11, 1},\n            {12, 0}, {12, 1},\n            {13, 1}\n        });\n\n        System.out.println(\"Topologically sorted order: \");\n        System.out.println(g.topoSort());\n    }\n}\n\nclass Graph {\n    String[] vertices;\n    boolean[][] adjacency;\n    int numVertices;\n\n    public Graph(String s, int[][] edges) {\n        vertices = s.split(\",\");\n        numVertices = vertices.length;\n        adjacency = new boolean[numVertices][numVertices];\n\n        for (int[] edge : edges)\n            adjacency[edge[0]][edge[1]] = true;\n    }\n\n    List<String> topoSort() {\n        List<String> result = new ArrayList<>();\n        List<Integer> todo = new LinkedList<>();\n\n        for (int i = 0; i < numVertices; i++)\n            todo.add(i);\n\n        try {\n            outer:\n            while (!todo.isEmpty()) {\n                for (Integer r : todo) {\n                    if (!hasDependency(r, todo)) {\n                        todo.remove(r);\n                        result.add(vertices[r]);\n                         \n                        continue outer;\n                    }\n                }\n                throw new Exception(\"Graph has cycles\");\n            }\n        } catch (Exception e) {\n            System.out.println(e);\n            return null;\n        }\n        return result;\n    }\n\n    boolean hasDependency(Integer r, List<Integer> todo) {\n        for (Integer c : todo) {\n            if (adjacency[r][c])\n                return true;\n        }\n        return false;\n    }\n}\n"}
{"id": 21541, "name": "Topological sort", "source": "Translate Ruby to Python: require 'tsort'\nclass Hash\n  include TSort\n  alias tsort_each_node each_key\n  def tsort_each_child(node, &block)\n    fetch(node).each(&block)\n  end\nend\n\ndepends = {}\nDATA.each do |line|\n  key, *libs = line.split\n  depends[key] = libs\n  libs.each {|lib| depends[lib] ||= []}\nend\n\nbegin\n  p depends.tsort\n  depends[\"dw01\"] << \"dw04\"\n  p depends.tsort\nrescue TSort::Cyclic => e\n  puts \"\\ncycle detected: \nend\n\n__END__\ndes_system_lib   std synopsys std_cell_lib des_system_lib dw02 dw01 ramlib ieee\ndw01             ieee dw01 dware gtech\ndw02             ieee dw02 dware\ndw03             std synopsys dware dw03 dw02 dw01 ieee gtech\ndw04             dw04 ieee dw01 dware gtech\ndw05             dw05 ieee dware\ndw06             dw06 ieee dware\ndw07             ieee dware\ndware            ieee dware\ngtech            ieee gtech\nramlib           std ieee\nstd_cell_lib     ieee std_cell_lib\nsynopsys\n", "target": "try:\n    from functools import reduce\nexcept:\n    pass\n\ndata = {\n    'des_system_lib':   set('std synopsys std_cell_lib des_system_lib dw02 dw01 ramlib ieee'.split()),\n    'dw01':             set('ieee dw01 dware gtech'.split()),\n    'dw02':             set('ieee dw02 dware'.split()),\n    'dw03':             set('std synopsys dware dw03 dw02 dw01 ieee gtech'.split()),\n    'dw04':             set('dw04 ieee dw01 dware gtech'.split()),\n    'dw05':             set('dw05 ieee dware'.split()),\n    'dw06':             set('dw06 ieee dware'.split()),\n    'dw07':             set('ieee dware'.split()),\n    'dware':            set('ieee dware'.split()),\n    'gtech':            set('ieee gtech'.split()),\n    'ramlib':           set('std ieee'.split()),\n    'std_cell_lib':     set('ieee std_cell_lib'.split()),\n    'synopsys':         set(),\n    }\n\ndef toposort2(data):\n    for k, v in data.items():\n        v.discard(k) \n    extra_items_in_deps = reduce(set.union, data.values()) - set(data.keys())\n    data.update({item:set() for item in extra_items_in_deps})\n    while True:\n        ordered = set(item for item,dep in data.items() if not dep)\n        if not ordered:\n            break\n        yield ' '.join(sorted(ordered))\n        data = {item: (dep - ordered) for item,dep in data.items()\n                if item not in ordered}\n    assert not data, \"A cyclic dependency exists amongst %r\" % data\n\nprint ('\\n'.join( toposort2(data) ))\n"}
{"id": 21771, "name": "Formatted numeric output", "source": "Translate Ruby to C#: r = 7.125\nprintf \" %9.3f\\n\",   r          \nprintf \" %09.3f\\n\",  r          \nprintf \" %09.3f\\n\", -r          \nprintf \"\u00a0%+09.3f\\n\", r          \nputs \" %9.3f\"  %  r             \nputs \" %09.3f\" %  r             \nputs \" %09.3f\" % -r             \nputs \"\u00a0%+09.3f\" % r             \n", "target": "class Program\n    {\n\n\n        static void Main(string[] args)\n        {\n\n            float myNumbers = 7.125F;\n            \n            string strnumber = Convert.ToString(myNumbers);\n                       \n            Console.WriteLine(strnumber.PadLeft(9, '0'));\n           \n            Console.ReadLine();\n        }\n        \n\n             \n       \n    }\n"}
{"id": 21773, "name": "Formatted numeric output", "source": "Translate Ruby to Java: r = 7.125\nprintf \" %9.3f\\n\",   r          \nprintf \" %09.3f\\n\",  r          \nprintf \" %09.3f\\n\", -r          \nprintf \"\u00a0%+09.3f\\n\", r          \nputs \" %9.3f\"  %  r             \nputs \" %09.3f\" %  r             \nputs \" %09.3f\" % -r             \nputs \"\u00a0%+09.3f\" % r             \n", "target": "public class Printing{\n\tpublic static void main(String[] args){\n\t\tdouble value = 7.125;\n\t\tSystem.out.printf(\"%09.3f\",value); \n\t\tSystem.out.println(String.format(\"%09.3f\",value));\n\t}\n}\n"}
{"id": 21774, "name": "Formatted numeric output", "source": "Translate Ruby to Python: r = 7.125\nprintf \" %9.3f\\n\",   r          \nprintf \" %09.3f\\n\",  r          \nprintf \" %09.3f\\n\", -r          \nprintf \"\u00a0%+09.3f\\n\", r          \nputs \" %9.3f\"  %  r             \nputs \" %09.3f\" %  r             \nputs \" %09.3f\" % -r             \nputs \"\u00a0%+09.3f\" % r             \n", "target": "from math import pi, exp\nr = exp(pi)-pi\nprint r\nprint \"e=%e f=%f g=%g G=%G s=%s r=%r!\"%(r,r,r,r,r,r)\nprint \"e=%9.4e f=%9.4f g=%9.4g!\"%(-r,-r,-r)\nprint \"e=%9.4e f=%9.4f g=%9.4g!\"%(r,r,r)\nprint \"e=%-9.4e f=%-9.4f g=%-9.4g!\"%(r,r,r)\nprint \"e=%09.4e f=%09.4f g=%09.4g!\"%(-r,-r,-r)\nprint \"e=%09.4e f=%09.4f g=%09.4g!\"%(r,r,r)\nprint \"e=%-09.4e f=%-09.4f g=%-09.4g!\"%(r,r,r)\n"}
{"id": 21956, "name": "Doubly-linked list_Element definition", "source": "Translate Ruby to C#: class DListNode < ListNode\n  attr_accessor :prev\n  \n\n  def initialize(value, prev=nil, succ=nil)\n    @value = value\n    @prev = prev\n    @prev.succ = self if prev\n    @succ = succ\n    @succ.prev = self if succ\n  end\n\n  def self.from_values(*ary)\n    ary << (f = ary.pop)\n    ary.map! {|i| new i }\n    ary.inject(f) {|p, c| p.succ = c; c.prev = p; c }\n  end\nend\n\nlist = DListNode.from_values 1,2,3,4\n", "target": "class Link\n{\n    public int Item { get; set; }\n    public Link Prev { get; set; }\n    public Link Next { get; set; }\n\n    \n    public Link(int item, Link prev = null, Link next = null) {\n        Item = item;\n        Prev = prev;\n        Next = next;\n    }\n}\n"}
{"id": 21958, "name": "Doubly-linked list_Element definition", "source": "Translate Ruby to Java: class DListNode < ListNode\n  attr_accessor :prev\n  \n\n  def initialize(value, prev=nil, succ=nil)\n    @value = value\n    @prev = prev\n    @prev.succ = self if prev\n    @succ = succ\n    @succ.prev = self if succ\n  end\n\n  def self.from_values(*ary)\n    ary << (f = ary.pop)\n    ary.map! {|i| new i }\n    ary.inject(f) {|p, c| p.succ = c; c.prev = p; c }\n  end\nend\n\nlist = DListNode.from_values 1,2,3,4\n", "target": "public class Node<T> {\n   private T element;\n   private Node<T> next, prev;\n\n   public Node<T>(){\n      next = prev = element = null;\n   }\n\n   public Node<T>(Node<T> n, Node<T> p, T elem){\n      next = n;\n      prev = p;\n      element = elem;\n   }\n\n   public void setNext(Node<T> n){\n      next = n;\n   }\n\n   public Node<T> getNext(){\n      return next;\n   }\n\n   public void setElem(T elem){\n      element = elem;\n   }\n\n   public T getElem(){\n      return element;\n   }\n\n   public void setNext(Node<T> n){\n      next = n;\n   }\n\n   public Node<T> setPrev(Node<T> p){\n      prev = p;\n   }\n\n   public getPrev(){\n      return prev;\n   }\n}\n"}
{"id": 21959, "name": "Doubly-linked list_Element definition", "source": "Translate Ruby to Python: class DListNode < ListNode\n  attr_accessor :prev\n  \n\n  def initialize(value, prev=nil, succ=nil)\n    @value = value\n    @prev = prev\n    @prev.succ = self if prev\n    @succ = succ\n    @succ.prev = self if succ\n  end\n\n  def self.from_values(*ary)\n    ary << (f = ary.pop)\n    ary.map! {|i| new i }\n    ary.inject(f) {|p, c| p.succ = c; c.prev = p; c }\n  end\nend\n\nlist = DListNode.from_values 1,2,3,4\n", "target": "class Node(object):\n     def __init__(self, data = None, prev = None, next = None):\n         self.prev = prev\n         self.next = next\n         self.data = data\n     def __str__(self):\n         return str(self.data)\n     def __repr__(self):\n         return repr(self.data)\n     def iter_forward(self):\n         c = self\n         while c != None:\n             yield c\n             c = c.next\n     def iter_backward(self):\n         c = self\n         while c != None:\n             yield c\n             c = c.prev\n"}
{"id": 22408, "name": "Dot product", "source": "Translate Ruby to C#: class Vector\n  property x, y, z\n  \n  def initialize(@x : Int64, @y : Int64, @z : Int64) end\n      \n  def dot_product(other : Vector)\n    (self.x * other.x) + (self.y * other.y) + (self.z * other.z)\n  end\nend\n\nputs Vector.new(1, 3, -5).dot_product Vector.new(4, -2, -1) \n\nclass Array\n  def dot_product(other)\n    raise \"not the same size!\" if self.size != other.size\n    self.zip(other).sum { |(a, b)| a * b }\n  end\nend\n\np [8, 13, -5].dot_product [4, -7, -11]   \n", "target": "static void Main(string[] args)\n{\n\tConsole.WriteLine(DotProduct(new decimal[] { 1, 3, -5 }, new decimal[] { 4, -2, -1 }));\n\tConsole.Read();\n}\n\nprivate static decimal DotProduct(decimal[] vec1, decimal[] vec2) \n{\n\tif (vec1 == null)\n\t\treturn 0;\n\n\tif (vec2 == null)\n\t\treturn 0;\n\n\tif (vec1.Length != vec2.Length)\n\t\treturn 0;\n\n\tdecimal tVal = 0;\n\tfor (int x = 0; x < vec1.Length; x++)\n\t{\n\t\ttVal += vec1[x] * vec2[x];\n\t}\n\n\treturn tVal;\n}\n"}
{"id": 22409, "name": "Dot product", "source": "Translate Ruby to C#: class Vector\n  property x, y, z\n  \n  def initialize(@x : Int64, @y : Int64, @z : Int64) end\n      \n  def dot_product(other : Vector)\n    (self.x * other.x) + (self.y * other.y) + (self.z * other.z)\n  end\nend\n\nputs Vector.new(1, 3, -5).dot_product Vector.new(4, -2, -1) \n\nclass Array\n  def dot_product(other)\n    raise \"not the same size!\" if self.size != other.size\n    self.zip(other).sum { |(a, b)| a * b }\n  end\nend\n\np [8, 13, -5].dot_product [4, -7, -11]   \n", "target": "static void Main(string[] args)\n{\n\tConsole.WriteLine(DotProduct(new decimal[] { 1, 3, -5 }, new decimal[] { 4, -2, -1 }));\n\tConsole.Read();\n}\n\nprivate static decimal DotProduct(decimal[] vec1, decimal[] vec2) \n{\n\tif (vec1 == null)\n\t\treturn 0;\n\n\tif (vec2 == null)\n\t\treturn 0;\n\n\tif (vec1.Length != vec2.Length)\n\t\treturn 0;\n\n\tdecimal tVal = 0;\n\tfor (int x = 0; x < vec1.Length; x++)\n\t{\n\t\ttVal += vec1[x] * vec2[x];\n\t}\n\n\treturn tVal;\n}\n"}
{"id": 22412, "name": "Dot product", "source": "Translate Ruby to Java: class Vector\n  property x, y, z\n  \n  def initialize(@x : Int64, @y : Int64, @z : Int64) end\n      \n  def dot_product(other : Vector)\n    (self.x * other.x) + (self.y * other.y) + (self.z * other.z)\n  end\nend\n\nputs Vector.new(1, 3, -5).dot_product Vector.new(4, -2, -1) \n\nclass Array\n  def dot_product(other)\n    raise \"not the same size!\" if self.size != other.size\n    self.zip(other).sum { |(a, b)| a * b }\n  end\nend\n\np [8, 13, -5].dot_product [4, -7, -11]   \n", "target": "public class DotProduct {\n\t\n\tpublic static void main(String[] args) {\n\t\tdouble[] a = {1, 3, -5};\n\t\tdouble[] b = {4, -2, -1};\n\t\t\n\t\tSystem.out.println(dotProd(a,b));\n\t}\n\t\n\tpublic static double dotProd(double[] a, double[] b){\n\t\tif(a.length != b.length){\n\t\t\tthrow new IllegalArgumentException(\"The dimensions have to be equal!\");\n\t\t}\n\t\tdouble sum = 0;\n\t\tfor(int i = 0; i < a.length; i++){\n\t\t\tsum += a[i] * b[i];\n\t\t}\n\t\treturn sum;\n\t}\n}\n"}
{"id": 22413, "name": "Dot product", "source": "Translate Ruby to Java: class Vector\n  property x, y, z\n  \n  def initialize(@x : Int64, @y : Int64, @z : Int64) end\n      \n  def dot_product(other : Vector)\n    (self.x * other.x) + (self.y * other.y) + (self.z * other.z)\n  end\nend\n\nputs Vector.new(1, 3, -5).dot_product Vector.new(4, -2, -1) \n\nclass Array\n  def dot_product(other)\n    raise \"not the same size!\" if self.size != other.size\n    self.zip(other).sum { |(a, b)| a * b }\n  end\nend\n\np [8, 13, -5].dot_product [4, -7, -11]   \n", "target": "public class DotProduct {\n\t\n\tpublic static void main(String[] args) {\n\t\tdouble[] a = {1, 3, -5};\n\t\tdouble[] b = {4, -2, -1};\n\t\t\n\t\tSystem.out.println(dotProd(a,b));\n\t}\n\t\n\tpublic static double dotProd(double[] a, double[] b){\n\t\tif(a.length != b.length){\n\t\t\tthrow new IllegalArgumentException(\"The dimensions have to be equal!\");\n\t\t}\n\t\tdouble sum = 0;\n\t\tfor(int i = 0; i < a.length; i++){\n\t\t\tsum += a[i] * b[i];\n\t\t}\n\t\treturn sum;\n\t}\n}\n"}
{"id": 22414, "name": "Dot product", "source": "Translate Ruby to Python: class Vector\n  property x, y, z\n  \n  def initialize(@x : Int64, @y : Int64, @z : Int64) end\n      \n  def dot_product(other : Vector)\n    (self.x * other.x) + (self.y * other.y) + (self.z * other.z)\n  end\nend\n\nputs Vector.new(1, 3, -5).dot_product Vector.new(4, -2, -1) \n\nclass Array\n  def dot_product(other)\n    raise \"not the same size!\" if self.size != other.size\n    self.zip(other).sum { |(a, b)| a * b }\n  end\nend\n\np [8, 13, -5].dot_product [4, -7, -11]   \n", "target": "def dotp(a,b):\n    assert len(a) == len(b), 'Vector sizes must match'\n    return sum(aterm * bterm for aterm,bterm in zip(a, b))\n\nif __name__ == '__main__':\n    a, b = [1, 3, -5], [4, -2, -1]\n    assert dotp(a,b) == 3\n"}
{"id": 22415, "name": "Dot product", "source": "Translate Ruby to Python: class Vector\n  property x, y, z\n  \n  def initialize(@x : Int64, @y : Int64, @z : Int64) end\n      \n  def dot_product(other : Vector)\n    (self.x * other.x) + (self.y * other.y) + (self.z * other.z)\n  end\nend\n\nputs Vector.new(1, 3, -5).dot_product Vector.new(4, -2, -1) \n\nclass Array\n  def dot_product(other)\n    raise \"not the same size!\" if self.size != other.size\n    self.zip(other).sum { |(a, b)| a * b }\n  end\nend\n\np [8, 13, -5].dot_product [4, -7, -11]   \n", "target": "def dotp(a,b):\n    assert len(a) == len(b), 'Vector sizes must match'\n    return sum(aterm * bterm for aterm,bterm in zip(a, b))\n\nif __name__ == '__main__':\n    a, b = [1, 3, -5], [4, -2, -1]\n    assert dotp(a,b) == 3\n"}
{"id": 22742, "name": "Count in factors", "source": "Translate Ruby to C#: require 'optparse'\nrequire 'prime'\n\nmaximum = 10\nOptionParser.new do |o|\n  o.banner = \"Usage: \n  o.on(\"-m MAXIMUM\", Integer,\n       \"Count up to MAXIMUM [\n  o.parse! rescue ($stderr.puts $!, o; exit 1)\n  ($stderr.puts o; exit 1) unless ARGV.size == 0\nend\n\n\nputs \"1 is 1\" unless maximum < 1\n\n2.upto(maximum) do |i|\n  \n  f = i.prime_division.map! do |factor, exponent|\n    \n    ([factor] * exponent).join \" x \"\n  end.join \" x \"\n  puts \"\nend\n", "target": "using System;\nusing System.Collections.Generic;\n\nnamespace prog\n{\n\tclass MainClass\n\t{\n\t\tpublic static void Main (string[] args)\n\t\t{\n\t\t\tfor( int i=1; i<=22; i++ )\n\t\t\t{\t\t\t\t\n\t\t\t\tList<int> f = Factorize(i);\n\t\t\t\tConsole.Write( i + \":  \" + f[0] );\n\t\t\t\tfor( int j=1; j<f.Count; j++ )\n\t\t\t\t{\n\t\t\t\t\tConsole.Write( \" * \" + f[j] );\n\t\t\t\t}\n\t\t\t\tConsole.WriteLine();\n\t\t\t}\n\t\t}\n\t\t\n\t\tpublic static List<int> Factorize( int n )\n\t\t{\n\t\t\tList<int> l = new List<int>();\n\t\t    \n\t\t\tif ( n == 1 )\n\t\t\t{\n\t\t\t\tl.Add(1);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tint k = 2;\n\t\t\t\twhile( n > 1 ) \n\t\t\t\t{\n\t\t\t\t\twhile( n % k == 0 )\n\t\t\t\t\t{\n\t\t\t\t\t\tl.Add( k );\n\t\t\t\t\t\tn /= k;\n\t\t\t\t\t}\n\t\t\t\t\tk++;\n\t\t\t\t}\n\t\t\t}\t\t\t\n\t\t\treturn l;\n\t\t}\t\n\t}\n}\n"}
{"id": 22744, "name": "Count in factors", "source": "Translate Ruby to Java: require 'optparse'\nrequire 'prime'\n\nmaximum = 10\nOptionParser.new do |o|\n  o.banner = \"Usage: \n  o.on(\"-m MAXIMUM\", Integer,\n       \"Count up to MAXIMUM [\n  o.parse! rescue ($stderr.puts $!, o; exit 1)\n  ($stderr.puts o; exit 1) unless ARGV.size == 0\nend\n\n\nputs \"1 is 1\" unless maximum < 1\n\n2.upto(maximum) do |i|\n  \n  f = i.prime_division.map! do |factor, exponent|\n    \n    ([factor] * exponent).join \" x \"\n  end.join \" x \"\n  puts \"\nend\n", "target": "public class CountingInFactors{ \n    public static void main(String[] args){\n        for(int i = 1; i<= 10; i++){\n            System.out.println(i + \" = \"+ countInFactors(i));\n        }\n \n        for(int i = 9991; i <= 10000; i++){\n        \tSystem.out.println(i + \" = \"+ countInFactors(i));\n        }\n    }\n \n    private static String countInFactors(int n){\n        if(n == 1) return \"1\";\n \n        StringBuilder sb = new StringBuilder();\n \n        n = checkFactor(2, n, sb);\n        if(n == 1) return sb.toString();\n \n        n = checkFactor(3, n, sb);\n        if(n == 1) return sb.toString();\n \n        for(int i = 5; i <= n; i+= 2){\n            if(i % 3 == 0)continue;\n \n            n = checkFactor(i, n, sb);\n            if(n == 1)break;\n        }\n \n        return sb.toString();\n    }\n \n    private static int checkFactor(int mult, int n, StringBuilder sb){\n        while(n % mult == 0 ){\n            if(sb.length() > 0) sb.append(\" x \");\n            sb.append(mult);\n            n /= mult;\n        }\n        return n;\n    }\n}\n"}
{"id": 22745, "name": "Count in factors", "source": "Translate Ruby to Python: require 'optparse'\nrequire 'prime'\n\nmaximum = 10\nOptionParser.new do |o|\n  o.banner = \"Usage: \n  o.on(\"-m MAXIMUM\", Integer,\n       \"Count up to MAXIMUM [\n  o.parse! rescue ($stderr.puts $!, o; exit 1)\n  ($stderr.puts o; exit 1) unless ARGV.size == 0\nend\n\n\nputs \"1 is 1\" unless maximum < 1\n\n2.upto(maximum) do |i|\n  \n  f = i.prime_division.map! do |factor, exponent|\n    \n    ([factor] * exponent).join \" x \"\n  end.join \" x \"\n  puts \"\nend\n", "target": "from functools import lru_cache\n\nprimes = [2, 3, 5, 7, 11, 13, 17]    \n\n@lru_cache(maxsize=2000)\ndef pfactor(n):\n    if n == 1:\n        return [1]\n    n2 = n // 2 + 1\n    for p in primes:\n        if p <= n2:\n            d, m = divmod(n, p)\n            if m == 0:\n                if d > 1:\n                    return [p] + pfactor(d)\n                else:\n                    return [p]\n        else:\n            if n > primes[-1]:\n                primes.append(n)\n            return [n]\n        \nif __name__ == '__main__':\n    mx = 5000\n    for n in range(1, mx + 1):\n        factors = pfactor(n)\n        if n <= 10 or n >= mx - 20:\n            print( '%4i %5s %s' % (n,\n                                   '' if factors != [n] or n == 1 else 'prime',\n                                   'x'.join(str(i) for i in factors)) )\n        if n == 11:\n            print('...')\n            \n    print('\\nNumber of primes gathered up to', n, 'is', len(primes))\n    print(pfactor.cache_info())\n"}
{"id": 22978, "name": "Queue_Definition", "source": "Translate Ruby to C#: require 'forwardable'\n\n\n\n\nclass FIFO\n  extend Forwardable\n\n  \n  def self.[](*objects)\n    new.push(*objects)\n  end\n\n  \n  def initialize; @ary = []; end\n\n  \n  def push(*objects)\n    @ary.push(*objects)\n    self\n  end\n  alias << push\n  alias enqueue push\n\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  def_delegator :@ary, :shift, :pop\n  alias shift pop\n  alias dequeue shift\n\n  \n  \n  \n  def_delegator :@ary, :empty?\n\n  \n  \n  \n  def_delegator :@ary, :size\n  alias length size\n\n  \n  def to_s\n    \"FIFO\n  end\n  alias inspect to_s\nend\n", "target": "public class FIFO<T>\n{\n  class Node\n  {\n    public T Item { get; set; }\n    public Node Next { get; set; }\n  }\n  Node first = null;\n  Node last = null;\n  public void push(T item)\n  {\n    if (empty())\n    {\n      \n      first = new Node() { Item = item, Next = null };\n      last = first;\n    }\n    else\n    {\n      last.Next = new Node() { Item = item, Next = null };\n      last = last.Next;\n    }\n  }\n  public T pop()\n  {\n    if (first == null)\n      throw new System.Exception(\"No elements\"); \n    if (last == first)\n      last = null;\n    T temp = first.Item;\n    first = first.Next;\n    return temp;\n  }\n  public bool empty()\n  {\n    return first == null;\n  }\n}\n"}
{"id": 22980, "name": "Queue_Definition", "source": "Translate Ruby to Java: require 'forwardable'\n\n\n\n\nclass FIFO\n  extend Forwardable\n\n  \n  def self.[](*objects)\n    new.push(*objects)\n  end\n\n  \n  def initialize; @ary = []; end\n\n  \n  def push(*objects)\n    @ary.push(*objects)\n    self\n  end\n  alias << push\n  alias enqueue push\n\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  def_delegator :@ary, :shift, :pop\n  alias shift pop\n  alias dequeue shift\n\n  \n  \n  \n  def_delegator :@ary, :empty?\n\n  \n  \n  \n  def_delegator :@ary, :size\n  alias length size\n\n  \n  def to_s\n    \"FIFO\n  end\n  alias inspect to_s\nend\n", "target": "public class Queue<E>{\n    Node<E> head = null, tail = null;\n\n    static class Node<E>{\n        E value;\n        Node<E> next;\n\n        Node(E value, Node<E> next){\n            this.value= value;\n            this.next= next;\n        }\n\n    }\n\n    public Queue(){\n    }\n\n    public void enqueue(E value){ \n        Node<E> newNode= new Node<E>(value, null);\n        if(empty()){\n            head= newNode;\n        }else{\n            tail.next = newNode;\n        }\n        tail= newNode;\n    }\n\n    public E dequeue() throws java.util.NoSuchElementException{\n        if(empty()){\n            throw new java.util.NoSuchElementException(\"No more elements.\");\n        }\n        E retVal= head.value;\n        head= head.next;\n        return retVal;\n    } \n\n    public boolean empty(){\n        return head == null;\n    }\n}\n"}
{"id": 22981, "name": "Queue_Definition", "source": "Translate Ruby to Python: require 'forwardable'\n\n\n\n\nclass FIFO\n  extend Forwardable\n\n  \n  def self.[](*objects)\n    new.push(*objects)\n  end\n\n  \n  def initialize; @ary = []; end\n\n  \n  def push(*objects)\n    @ary.push(*objects)\n    self\n  end\n  alias << push\n  alias enqueue push\n\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  def_delegator :@ary, :shift, :pop\n  alias shift pop\n  alias dequeue shift\n\n  \n  \n  \n  def_delegator :@ary, :empty?\n\n  \n  \n  \n  def_delegator :@ary, :size\n  alias length size\n\n  \n  def to_s\n    \"FIFO\n  end\n  alias inspect to_s\nend\n", "target": "   class FIFO(object):\n       def __init__(self, *args):\n           self.contents = list(args)\n       def __call__(self):\n           return self.pop()\n       def __len__(self):\n           return len(self.contents)\n       def pop(self):\n           return self.contents.pop(0)\n       def push(self, item):\n           self.contents.append(item)\n       def extend(self,*itemlist):\n           self.contents += itemlist\n       def empty(self):\n           return bool(self.contents)\n       def __iter__(self):\n           return self\n       def next(self):\n           if self.empty():\n               raise StopIteration\n           return self.pop()\n\nif __name__ == \"__main__\":\n    \n    f = FIFO()\n    f.push(3)\n    f.push(2)\n    f.push(1)\n    while not f.empty():\n        print f.pop(),\n    \n    \n    f = FIFO(3,2,1)\n    while not f.empty():\n        print f(),\n    \n    \n    \n    f = FIFO(3,2,1)\n    while f:\n        print f(),\n    \n    f = FIFO(3,2,1)\n    for i in f:\n        print i,\n"}
{"id": 23373, "name": "Remove lines from a file", "source": "Translate Ruby to C#: require 'tempfile'\n\ndef remove_lines(filename, start, num)\n  tmp = Tempfile.open(filename) do |fp|\n    File.foreach(filename) do |line|\n      if $. >= start and num > 0\n        num -= 1\n      else\n        fp.puts line\n      end\n    end\n    fp\n  end\n  puts \"Warning: End of file encountered before all lines removed\" if num > 0\n  FileUtils.copy(tmp.path, filename)\n  tmp.unlink\nend\n\n\ndef setup(filename, start, remove)\n  puts \"remove \n  File.open(filename, \"w\") {|fh| (1..5).each {|i| fh.puts \" \"*i + i.to_s}}\n  puts \"before:\", File.read(filename)\nend\n\ndef teardown(filename)\n  puts \"after:\", File.read(filename)\n  puts\n  File.unlink(filename)\nend\n\nfilename = \"foobar.txt\"\nstart = 2\n[2, 6].each do |remove|\n  setup(filename, start, remove)\n  remove_lines(filename, start, remove)\n  teardown(filename)\nend\n", "target": "using System;\nusing System.IO;\nusing System.Linq;\n\npublic class Rosetta\n{\n    public static void Main() => RemoveLines(\"foobar.txt\", start: 1, count: 2);\n\n    static void RemoveLines(string filename, int start, int count = 1) =>\n        File.WriteAllLines(filename, File.ReadAllLines(filename)\n            .Where((line, index) => index < start - 1 || index >= start + count - 1));\n}\n"}
{"id": 23374, "name": "Remove lines from a file", "source": "Translate Ruby to C#: require 'tempfile'\n\ndef remove_lines(filename, start, num)\n  tmp = Tempfile.open(filename) do |fp|\n    File.foreach(filename) do |line|\n      if $. >= start and num > 0\n        num -= 1\n      else\n        fp.puts line\n      end\n    end\n    fp\n  end\n  puts \"Warning: End of file encountered before all lines removed\" if num > 0\n  FileUtils.copy(tmp.path, filename)\n  tmp.unlink\nend\n\n\ndef setup(filename, start, remove)\n  puts \"remove \n  File.open(filename, \"w\") {|fh| (1..5).each {|i| fh.puts \" \"*i + i.to_s}}\n  puts \"before:\", File.read(filename)\nend\n\ndef teardown(filename)\n  puts \"after:\", File.read(filename)\n  puts\n  File.unlink(filename)\nend\n\nfilename = \"foobar.txt\"\nstart = 2\n[2, 6].each do |remove|\n  setup(filename, start, remove)\n  remove_lines(filename, start, remove)\n  teardown(filename)\nend\n", "target": "using System;\nusing System.IO;\nusing System.Linq;\n\npublic class Rosetta\n{\n    public static void Main() => RemoveLines(\"foobar.txt\", start: 1, count: 2);\n\n    static void RemoveLines(string filename, int start, int count = 1) =>\n        File.WriteAllLines(filename, File.ReadAllLines(filename)\n            .Where((line, index) => index < start - 1 || index >= start + count - 1));\n}\n"}
{"id": 23377, "name": "Remove lines from a file", "source": "Translate Ruby to Java: require 'tempfile'\n\ndef remove_lines(filename, start, num)\n  tmp = Tempfile.open(filename) do |fp|\n    File.foreach(filename) do |line|\n      if $. >= start and num > 0\n        num -= 1\n      else\n        fp.puts line\n      end\n    end\n    fp\n  end\n  puts \"Warning: End of file encountered before all lines removed\" if num > 0\n  FileUtils.copy(tmp.path, filename)\n  tmp.unlink\nend\n\n\ndef setup(filename, start, remove)\n  puts \"remove \n  File.open(filename, \"w\") {|fh| (1..5).each {|i| fh.puts \" \"*i + i.to_s}}\n  puts \"before:\", File.read(filename)\nend\n\ndef teardown(filename)\n  puts \"after:\", File.read(filename)\n  puts\n  File.unlink(filename)\nend\n\nfilename = \"foobar.txt\"\nstart = 2\n[2, 6].each do |remove|\n  setup(filename, start, remove)\n  remove_lines(filename, start, remove)\n  teardown(filename)\nend\n", "target": "import java.io.BufferedReader;\nimport java.io.File;\nimport java.io.FileReader;\nimport java.io.FileWriter;\n\npublic class RemoveLines\n{\n\tpublic static void main(String[] args)\n\t{\n\t\t\n\t\tString filename=\"foobar.txt\";\n\t\t\n\t\tint startline=1;\n\t\t\n\t\tint numlines=2;\n\t\t\n\t\tRemoveLines now=new RemoveLines();\n\t\tnow.delete(filename,startline,numlines);\n\t}\n\tvoid delete(String filename, int startline, int numlines)\n\t{\n\t\ttry\n\t\t{\n\t\t\tBufferedReader br=new BufferedReader(new FileReader(filename));\n\t\t\t\n\t\t\t\n\t\t\tStringBuffer sb=new StringBuffer(\"\");\n\t\t\t\n\t\t\t\n\t\t\tint linenumber=1;\n\t\t\tString line;\n\t\t\t\n\t\t\twhile((line=br.readLine())!=null)\n\t\t\t{\n\t\t\t\t\n\t\t\t\tif(linenumber<startline||linenumber>=startline+numlines)\n\t\t\t\t\tsb.append(line+\"\\n\");\n\t\t\t\tlinenumber++;\n\t\t\t}\n\t\t\tif(startline+numlines>linenumber)\n\t\t\t\tSystem.out.println(\"End of file reached.\");\n\t\t\tbr.close();\n\t\t\t\n\t\t\tFileWriter fw=new FileWriter(new File(filename));\n\t\t\t\n\t\t\tfw.write(sb.toString());\n\t\t\tfw.close();\n\t\t}\n\t\tcatch (Exception e)\n\t\t{\n\t\t\tSystem.out.println(\"Something went horribly wrong: \"+e.getMessage());\n\t\t}\n\t}\n}\n"}
{"id": 23378, "name": "Remove lines from a file", "source": "Translate Ruby to Python: require 'tempfile'\n\ndef remove_lines(filename, start, num)\n  tmp = Tempfile.open(filename) do |fp|\n    File.foreach(filename) do |line|\n      if $. >= start and num > 0\n        num -= 1\n      else\n        fp.puts line\n      end\n    end\n    fp\n  end\n  puts \"Warning: End of file encountered before all lines removed\" if num > 0\n  FileUtils.copy(tmp.path, filename)\n  tmp.unlink\nend\n\n\ndef setup(filename, start, remove)\n  puts \"remove \n  File.open(filename, \"w\") {|fh| (1..5).each {|i| fh.puts \" \"*i + i.to_s}}\n  puts \"before:\", File.read(filename)\nend\n\ndef teardown(filename)\n  puts \"after:\", File.read(filename)\n  puts\n  File.unlink(filename)\nend\n\nfilename = \"foobar.txt\"\nstart = 2\n[2, 6].each do |remove|\n  setup(filename, start, remove)\n  remove_lines(filename, start, remove)\n  teardown(filename)\nend\n", "target": "\n\nimport fileinput, sys\n\nfname, start, count = sys.argv[1:4]\nstart, count = int(start), int(count)\n\nfor line in fileinput.input(fname, inplace=1, backup='.orig'):\n    if start <= fileinput.lineno() < start + count:\n        pass\n    else:\n        print line.rstrip(\"\\n\")\nfileinput.close()\n"}
{"id": 23379, "name": "Remove lines from a file", "source": "Translate Ruby to Python: require 'tempfile'\n\ndef remove_lines(filename, start, num)\n  tmp = Tempfile.open(filename) do |fp|\n    File.foreach(filename) do |line|\n      if $. >= start and num > 0\n        num -= 1\n      else\n        fp.puts line\n      end\n    end\n    fp\n  end\n  puts \"Warning: End of file encountered before all lines removed\" if num > 0\n  FileUtils.copy(tmp.path, filename)\n  tmp.unlink\nend\n\n\ndef setup(filename, start, remove)\n  puts \"remove \n  File.open(filename, \"w\") {|fh| (1..5).each {|i| fh.puts \" \"*i + i.to_s}}\n  puts \"before:\", File.read(filename)\nend\n\ndef teardown(filename)\n  puts \"after:\", File.read(filename)\n  puts\n  File.unlink(filename)\nend\n\nfilename = \"foobar.txt\"\nstart = 2\n[2, 6].each do |remove|\n  setup(filename, start, remove)\n  remove_lines(filename, start, remove)\n  teardown(filename)\nend\n", "target": "\n\nimport fileinput, sys\n\nfname, start, count = sys.argv[1:4]\nstart, count = int(start), int(count)\n\nfor line in fileinput.input(fname, inplace=1, backup='.orig'):\n    if start <= fileinput.lineno() < start + count:\n        pass\n    else:\n        print line.rstrip(\"\\n\")\nfileinput.close()\n"}
{"id": 23634, "name": "String case", "source": "Translate Ruby to C#: \"alphaBETA\".downcase \n\"alphaBETA\".upcase \n\n\"alphaBETA\".swapcase \n\"alphaBETA\".capitalize \n", "target": "using System;\n\nnamespace StringCase\n{\n  class Program\n  {\n    public static void Main()\n    {\n      String input = scope .(\"alphaBETA\");\n      input.ToUpper();\n      Console.WriteLine(input);\n      input.ToLower();\n      Console.WriteLine(input);\n    }\n  }\n}\n"}
{"id": 23636, "name": "String case", "source": "Translate Ruby to Python: \"alphaBETA\".downcase \n\"alphaBETA\".upcase \n\n\"alphaBETA\".swapcase \n\"alphaBETA\".capitalize \n", "target": "s = \"alphaBETA\"\nprint s.upper() \nprint s.lower() \n\nprint s.swapcase() \n\nprint \"fOo bAR\".capitalize() \nprint \"fOo bAR\".title() \n\nimport string\nprint string.capwords(\"fOo bAR\") \n"}
{"id": 23807, "name": "Cramer's rule", "source": "Translate Ruby to C#: require 'matrix'\n \ndef cramers_rule(a, terms)\n  raise ArgumentError, \" Matrix not square\"  unless a.square?\n  cols = a.to_a.transpose\n  cols.each_index.map do |i|\n    c = cols.dup\n    c[i] = terms\n    Matrix.columns(c).det / a.det\n  end\nend\n\nmatrix = Matrix[\n    [2, -1,  5,  1],\n    [3,  2,  2, -6],\n    [1,  3,  3, -1],\n    [5, -2, -3,  3],\n]\n\nvector = [-3, -32, -47, 49]\nputs cramers_rule(matrix, vector)\n", "target": "using System;\nusing System.Collections.Generic;\nusing static System.Linq.Enumerable;\n\npublic static class CramersRule\n{\n    public static void Main() {\n        var equations = new [] {\n            new [] { 2, -1,  5,  1,  -3 },\n            new [] { 3,  2,  2, -6, -32 },\n            new [] { 1,  3,  3, -1, -47 },\n            new [] { 5, -2, -3,  3,  49 }\n        };\n        var solution = SolveCramer(equations);\n        Console.WriteLine(solution.DelimitWith(\", \"));\n    }\n\n    public static int[] SolveCramer(int[][] equations) {\n        int size = equations.Length;\n        if (equations.Any(eq => eq.Length != size + 1)) throw new ArgumentException($\"Each equation must have {size+1} terms.\");\n        int[,] matrix = new int[size, size];\n        int[] column = new int[size];\n        for (int r = 0; r < size; r++) {\n            column[r] = equations[r][size];\n            for (int c = 0; c < size; c++) {\n                matrix[r, c] = equations[r][c];\n            }\n        }\n        return Solve(new SubMatrix(matrix, column));\n    }\n\n    private static int[] Solve(SubMatrix matrix) {\n        int det = matrix.Det();\n        if (det == 0) throw new ArgumentException(\"The determinant is zero.\");\n\n        int[] answer = new int[matrix.Size];\n        for (int i = 0; i < matrix.Size; i++) {\n            matrix.ColumnIndex = i;\n            answer[i] = matrix.Det() / det;\n        }\n        return answer;\n    }\n\n    \n    static string DelimitWith<T>(this IEnumerable<T> source, string separator = \" \") =>\n        string.Join(separator ?? \" \", source ?? Empty<T>());\n\n    private class SubMatrix\n    {\n        private int[,] source;\n        private SubMatrix prev;\n        private int[] replaceColumn;\n\n        public SubMatrix(int[,] source, int[] replaceColumn) {\n            this.source = source;\n            this.replaceColumn = replaceColumn;\n            this.prev = null;\n            this.ColumnIndex = -1;\n            Size = replaceColumn.Length;\n        }\n\n        private SubMatrix(SubMatrix prev, int deletedColumnIndex = -1) {\n            this.source = null;\n            this.prev = prev;\n            this.ColumnIndex = deletedColumnIndex;\n            Size = prev.Size - 1;\n        }\n\n        public int ColumnIndex { get; set; }\n        public int Size { get; }\n\n        public int this[int row, int column] {\n            get {\n                if (source != null) return column == ColumnIndex ? replaceColumn[row] : source[row, column];\n                return prev[row + 1, column < ColumnIndex ? column : column + 1];\n            }\n        }\n\n        public int Det() {\n            if (Size == 1) return this[0, 0];\n            if (Size == 2) return this[0, 0] * this[1, 1] - this[0, 1] * this[1, 0];\n            SubMatrix m = new SubMatrix(this);\n            int det = 0;\n            int sign = 1;\n            for (int c = 0; c < Size; c++) {\n                m.ColumnIndex = c;\n                int d = m.Det();\n                det += this[0, c] * d * sign;\n                sign = -sign;\n            }\n            return det;\n        }\n\n        public void Print() {\n            for (int r = 0; r < Size; r++) {\n                Console.WriteLine(Range(0, Size).Select(c => this[r, c]).DelimitWith(\", \"));\n            }\n            Console.WriteLine();\n        }\n    }\n\n}\n"}
{"id": 23809, "name": "Cramer's rule", "source": "Translate Ruby to Java: require 'matrix'\n \ndef cramers_rule(a, terms)\n  raise ArgumentError, \" Matrix not square\"  unless a.square?\n  cols = a.to_a.transpose\n  cols.each_index.map do |i|\n    c = cols.dup\n    c[i] = terms\n    Matrix.columns(c).det / a.det\n  end\nend\n\nmatrix = Matrix[\n    [2, -1,  5,  1],\n    [3,  2,  2, -6],\n    [1,  3,  3, -1],\n    [5, -2, -3,  3],\n]\n\nvector = [-3, -32, -47, 49]\nputs cramers_rule(matrix, vector)\n", "target": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\n\npublic class CramersRule {\n\n    public static void main(String[] args) {\n        Matrix mat = new Matrix(Arrays.asList(2d, -1d, 5d, 1d), \n                                Arrays.asList(3d, 2d, 2d, -6d), \n                                Arrays.asList(1d, 3d, 3d, -1d),\n                                Arrays.asList(5d, -2d, -3d, 3d));\n        List<Double> b = Arrays.asList(-3d, -32d, -47d, 49d);\n        System.out.println(\"Solution = \" + cramersRule(mat, b));\n    }\n    \n    private static List<Double> cramersRule(Matrix matrix, List<Double> b) {\n        double denominator = matrix.determinant();\n        List<Double> result = new ArrayList<>();\n        for ( int i = 0 ; i < b.size() ; i++ ) {\n            result.add(matrix.replaceColumn(b, i).determinant() / denominator);\n        }\n        return result;\n    }\n        \n    private static class Matrix {\n        \n        private List<List<Double>> matrix;\n        \n        @Override\n        public String toString() {\n            return matrix.toString();\n        }\n        \n        @SafeVarargs\n        public Matrix(List<Double> ... lists) {\n            matrix = new ArrayList<>();\n            for ( List<Double> list : lists) {\n                matrix.add(list);\n            }\n        }\n        \n        public Matrix(List<List<Double>> mat) {\n            matrix = mat;\n        }\n        \n        public double determinant() {\n            if ( matrix.size() == 1 ) {\n                return get(0, 0);\n            }\n            if ( matrix.size() == 2 ) {\n                return get(0, 0) * get(1, 1) - get(0, 1) * get(1, 0);\n            }\n            double sum = 0;\n            double sign = 1;\n            for ( int i = 0 ; i < matrix.size() ; i++ ) {\n                sum += sign * get(0, i) * coFactor(0, i).determinant();\n                sign *= -1;\n            }\n            return sum;\n        }\n        \n        private Matrix coFactor(int row, int col) {\n            List<List<Double>> mat = new ArrayList<>();\n            for ( int i = 0 ; i < matrix.size() ; i++ ) {\n                if ( i == row ) {\n                    continue;\n                }\n                List<Double> list = new ArrayList<>();\n                for ( int j = 0 ; j < matrix.size() ; j++ ) {\n                    if ( j == col ) {\n                        continue;\n                    }\n                    list.add(get(i, j));\n                }\n                mat.add(list);\n            }\n            return new Matrix(mat);\n        }\n\n        private Matrix replaceColumn(List<Double> b, int column) {\n            List<List<Double>> mat = new ArrayList<>();\n            for ( int row = 0 ; row < matrix.size() ; row++ ) {\n                List<Double> list = new ArrayList<>();\n                for ( int col = 0 ; col < matrix.size() ; col++ ) {\n                    double value = get(row, col);\n                    if ( col == column ) {\n                        value = b.get(row);\n                    }\n                    list.add(value);\n                }\n                mat.add(list);\n            }\n            return new Matrix(mat);\n        }\n\n        private double get(int row, int col) {\n            return matrix.get(row).get(col);\n        }\n        \n    }\n\n}\n"}
{"id": 23810, "name": "Cramer's rule", "source": "Translate Ruby to Python: require 'matrix'\n \ndef cramers_rule(a, terms)\n  raise ArgumentError, \" Matrix not square\"  unless a.square?\n  cols = a.to_a.transpose\n  cols.each_index.map do |i|\n    c = cols.dup\n    c[i] = terms\n    Matrix.columns(c).det / a.det\n  end\nend\n\nmatrix = Matrix[\n    [2, -1,  5,  1],\n    [3,  2,  2, -6],\n    [1,  3,  3, -1],\n    [5, -2, -3,  3],\n]\n\nvector = [-3, -32, -47, 49]\nputs cramers_rule(matrix, vector)\n", "target": "def det(m,n):\n if n==1: return m[0][0]\n z=0\n for r in range(n):\n  k=m[:]\n  del k[r]\n  z+=m[r][0]*(-1)**r*det([p[1:]for p in k],n-1)\n return z\nw=len(t)\nd=det(h,w)\nif d==0:r=[]\nelse:r=[det([r[0:i]+[s]+r[i+1:]for r,s in zip(h,t)],w)/d for i in range(w)]\nprint(r)\n"}
{"id": 24050, "name": "Euler's identity", "source": "Translate Ruby to C#: include Math\n\nE ** (PI * 1i) + 1\n\n", "target": "using System;\nusing System.Numerics;\n\npublic class Program\n{\n    static void Main() {\n        Complex e = Math.E;\n        Complex i = Complex.ImaginaryOne;\n        Complex \u03c0 = Math.PI;\n        Console.WriteLine(Complex.Pow(e, i * \u03c0) + 1);\n    }\n}\n"}
{"id": 24051, "name": "Euler's identity", "source": "Translate Ruby to C#: include Math\n\nE ** (PI * 1i) + 1\n\n", "target": "using System;\nusing System.Numerics;\n\npublic class Program\n{\n    static void Main() {\n        Complex e = Math.E;\n        Complex i = Complex.ImaginaryOne;\n        Complex \u03c0 = Math.PI;\n        Console.WriteLine(Complex.Pow(e, i * \u03c0) + 1);\n    }\n}\n"}
{"id": 24054, "name": "Euler's identity", "source": "Translate Ruby to Java: include Math\n\nE ** (PI * 1i) + 1\n\n", "target": "public class EulerIdentity {\n\n    public static void main(String[] args) {\n        System.out.println(\"e ^ (i*Pi) + 1 = \" + (new Complex(0, Math.PI).exp()).add(new Complex(1, 0)));\n    }\n\n    public static class Complex {\n\n        private double x, y;\n        \n        public Complex(double re, double im) {\n            x = re;\n            y = im;\n        }\n        \n        public Complex exp() {\n            double exp = Math.exp(x);\n            return new Complex(exp * Math.cos(y), exp * Math.sin(y));\n        }\n        \n        public Complex add(Complex a) {\n            return new Complex(x + a.x, y + a.y);\n        }\n        \n        @Override\n        public String toString() {\n            return x + \" + \" + y + \"i\";\n        }\n    }\n}\n"}
{"id": 24055, "name": "Euler's identity", "source": "Translate Ruby to Python: include Math\n\nE ** (PI * 1i) + 1\n\n", "target": ">>> import math\n>>> math.e ** (math.pi * 1j) + 1\n1.2246467991473532e-16j\n"}
{"id": 24056, "name": "Euler's identity", "source": "Translate Ruby to Python: include Math\n\nE ** (PI * 1i) + 1\n\n", "target": ">>> import math\n>>> math.e ** (math.pi * 1j) + 1\n1.2246467991473532e-16j\n"}
{"id": 24488, "name": "Arithmetic-geometric mean", "source": "Translate Ruby to C#: \n\n\n\nrequire 'flt'\ninclude Flt\n\nBinNum.Context.precision = 512  \n\ndef agm(a,g)\n  new_a = BinNum a\n  new_g = BinNum g\n  while new_a - new_g > new_a.class.Context.epsilon do\n    old_g = new_g\n    new_g = (new_a * new_g).sqrt\n    new_a = (old_g + new_a) * 0.5\n  end\n  new_g\nend\n\nputs agm(1, 1 / BinNum(2).sqrt)\n", "target": "namespace RosettaCode.ArithmeticGeometricMean\n{\n    using System;\n    using System.Collections.Generic;\n    using System.Globalization;\n\n    internal static class Program\n    {\n        private static double ArithmeticGeometricMean(double number,\n                                                      double otherNumber,\n                                                      IEqualityComparer<double>\n                                                          comparer)\n        {\n            return comparer.Equals(number, otherNumber)\n                       ? number\n                       : ArithmeticGeometricMean(\n                           ArithmeticMean(number, otherNumber),\n                           GeometricMean(number, otherNumber), comparer);\n        }\n\n        private static double ArithmeticMean(double number, double otherNumber)\n        {\n            return 0.5 * (number + otherNumber);\n        }\n\n        private static double GeometricMean(double number, double otherNumber)\n        {\n            return Math.Sqrt(number * otherNumber);\n        }\n\n        private static void Main()\n        {\n            Console.WriteLine(\n                ArithmeticGeometricMean(1, 0.5 * Math.Sqrt(2),\n                                        new RelativeDifferenceComparer(1e-5)).\n                    ToString(CultureInfo.InvariantCulture));\n        }\n\n        private class RelativeDifferenceComparer : IEqualityComparer<double>\n        {\n            private readonly double _maximumRelativeDifference;\n\n            internal RelativeDifferenceComparer(double maximumRelativeDifference)\n            {\n                _maximumRelativeDifference = maximumRelativeDifference;\n            }\n\n            public bool Equals(double number, double otherNumber)\n            {\n                return RelativeDifference(number, otherNumber) <=\n                       _maximumRelativeDifference;\n            }\n\n            public int GetHashCode(double number)\n            {\n                return number.GetHashCode();\n            }\n\n            private static double RelativeDifference(double number,\n                                                     double otherNumber)\n            {\n                return AbsoluteDifference(number, otherNumber) /\n                       Norm(number, otherNumber);\n            }\n\n            private static double AbsoluteDifference(double number,\n                                                     double otherNumber)\n            {\n                return Math.Abs(number - otherNumber);\n            }\n\n            private static double Norm(double number, double otherNumber)\n            {\n                return 0.5 * (Math.Abs(number) + Math.Abs(otherNumber));\n            }\n        }\n    }\n}\n"}
{"id": 24489, "name": "Arithmetic-geometric mean", "source": "Translate Ruby to C#: \n\n\n\nrequire 'flt'\ninclude Flt\n\nBinNum.Context.precision = 512  \n\ndef agm(a,g)\n  new_a = BinNum a\n  new_g = BinNum g\n  while new_a - new_g > new_a.class.Context.epsilon do\n    old_g = new_g\n    new_g = (new_a * new_g).sqrt\n    new_a = (old_g + new_a) * 0.5\n  end\n  new_g\nend\n\nputs agm(1, 1 / BinNum(2).sqrt)\n", "target": "namespace RosettaCode.ArithmeticGeometricMean\n{\n    using System;\n    using System.Collections.Generic;\n    using System.Globalization;\n\n    internal static class Program\n    {\n        private static double ArithmeticGeometricMean(double number,\n                                                      double otherNumber,\n                                                      IEqualityComparer<double>\n                                                          comparer)\n        {\n            return comparer.Equals(number, otherNumber)\n                       ? number\n                       : ArithmeticGeometricMean(\n                           ArithmeticMean(number, otherNumber),\n                           GeometricMean(number, otherNumber), comparer);\n        }\n\n        private static double ArithmeticMean(double number, double otherNumber)\n        {\n            return 0.5 * (number + otherNumber);\n        }\n\n        private static double GeometricMean(double number, double otherNumber)\n        {\n            return Math.Sqrt(number * otherNumber);\n        }\n\n        private static void Main()\n        {\n            Console.WriteLine(\n                ArithmeticGeometricMean(1, 0.5 * Math.Sqrt(2),\n                                        new RelativeDifferenceComparer(1e-5)).\n                    ToString(CultureInfo.InvariantCulture));\n        }\n\n        private class RelativeDifferenceComparer : IEqualityComparer<double>\n        {\n            private readonly double _maximumRelativeDifference;\n\n            internal RelativeDifferenceComparer(double maximumRelativeDifference)\n            {\n                _maximumRelativeDifference = maximumRelativeDifference;\n            }\n\n            public bool Equals(double number, double otherNumber)\n            {\n                return RelativeDifference(number, otherNumber) <=\n                       _maximumRelativeDifference;\n            }\n\n            public int GetHashCode(double number)\n            {\n                return number.GetHashCode();\n            }\n\n            private static double RelativeDifference(double number,\n                                                     double otherNumber)\n            {\n                return AbsoluteDifference(number, otherNumber) /\n                       Norm(number, otherNumber);\n            }\n\n            private static double AbsoluteDifference(double number,\n                                                     double otherNumber)\n            {\n                return Math.Abs(number - otherNumber);\n            }\n\n            private static double Norm(double number, double otherNumber)\n            {\n                return 0.5 * (Math.Abs(number) + Math.Abs(otherNumber));\n            }\n        }\n    }\n}\n"}
{"id": 24492, "name": "Arithmetic-geometric mean", "source": "Translate Ruby to Java: \n\n\n\nrequire 'flt'\ninclude Flt\n\nBinNum.Context.precision = 512  \n\ndef agm(a,g)\n  new_a = BinNum a\n  new_g = BinNum g\n  while new_a - new_g > new_a.class.Context.epsilon do\n    old_g = new_g\n    new_g = (new_a * new_g).sqrt\n    new_a = (old_g + new_a) * 0.5\n  end\n  new_g\nend\n\nputs agm(1, 1 / BinNum(2).sqrt)\n", "target": "\npublic class ArithmeticGeometricMean {\n\n    public static double agm(double a, double g) {\n        double a1 = a;\n        double g1 = g;\n        while (Math.abs(a1 - g1) >= 1.0e-14) {\n            double arith = (a1 + g1) / 2.0;\n            double geom = Math.sqrt(a1 * g1);\n            a1 = arith;\n            g1 = geom;\n        }\n        return a1;\n    }\n\n    public static void main(String[] args) {\n        System.out.println(agm(1.0, 1.0 / Math.sqrt(2.0)));\n    }\n}\n"}
{"id": 24493, "name": "Arithmetic-geometric mean", "source": "Translate Ruby to Java: \n\n\n\nrequire 'flt'\ninclude Flt\n\nBinNum.Context.precision = 512  \n\ndef agm(a,g)\n  new_a = BinNum a\n  new_g = BinNum g\n  while new_a - new_g > new_a.class.Context.epsilon do\n    old_g = new_g\n    new_g = (new_a * new_g).sqrt\n    new_a = (old_g + new_a) * 0.5\n  end\n  new_g\nend\n\nputs agm(1, 1 / BinNum(2).sqrt)\n", "target": "\npublic class ArithmeticGeometricMean {\n\n    public static double agm(double a, double g) {\n        double a1 = a;\n        double g1 = g;\n        while (Math.abs(a1 - g1) >= 1.0e-14) {\n            double arith = (a1 + g1) / 2.0;\n            double geom = Math.sqrt(a1 * g1);\n            a1 = arith;\n            g1 = geom;\n        }\n        return a1;\n    }\n\n    public static void main(String[] args) {\n        System.out.println(agm(1.0, 1.0 / Math.sqrt(2.0)));\n    }\n}\n"}
{"id": 24494, "name": "Arithmetic-geometric mean", "source": "Translate Ruby to Python: \n\n\n\nrequire 'flt'\ninclude Flt\n\nBinNum.Context.precision = 512  \n\ndef agm(a,g)\n  new_a = BinNum a\n  new_g = BinNum g\n  while new_a - new_g > new_a.class.Context.epsilon do\n    old_g = new_g\n    new_g = (new_a * new_g).sqrt\n    new_a = (old_g + new_a) * 0.5\n  end\n  new_g\nend\n\nputs agm(1, 1 / BinNum(2).sqrt)\n", "target": "from math import sqrt\n\ndef agm(a0, g0, tolerance=1e-10):\n    \n    an, gn = (a0 + g0) / 2.0, sqrt(a0 * g0)\n    while abs(an - gn) > tolerance:\n        an, gn = (an + gn) / 2.0, sqrt(an * gn)\n    return an\n\nprint agm(1, 1 / sqrt(2))\n"}
{"id": 24495, "name": "Arithmetic-geometric mean", "source": "Translate Ruby to Python: \n\n\n\nrequire 'flt'\ninclude Flt\n\nBinNum.Context.precision = 512  \n\ndef agm(a,g)\n  new_a = BinNum a\n  new_g = BinNum g\n  while new_a - new_g > new_a.class.Context.epsilon do\n    old_g = new_g\n    new_g = (new_a * new_g).sqrt\n    new_a = (old_g + new_a) * 0.5\n  end\n  new_g\nend\n\nputs agm(1, 1 / BinNum(2).sqrt)\n", "target": "from math import sqrt\n\ndef agm(a0, g0, tolerance=1e-10):\n    \n    an, gn = (a0 + g0) / 2.0, sqrt(a0 * g0)\n    while abs(an - gn) > tolerance:\n        an, gn = (an + gn) / 2.0, sqrt(an * gn)\n    return an\n\nprint agm(1, 1 / sqrt(2))\n"}
{"id": 24956, "name": "Chinese remainder theorem", "source": "Translate Ruby to C#: def chinese_remainder(mods, remainders)\n  max = mods.inject( :* )                            \n  series = remainders.zip( mods ).map{|r,m| r.step( max, m ).to_a } \n  series.inject( :& ).first \nend\n\np chinese_remainder([3,5,7], [2,3,2])     \np chinese_remainder([10,4,9], [11,22,19]) \n", "target": "using System;\nusing System.Linq;\n\nnamespace ChineseRemainderTheorem\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            int[] n = { 3, 5, 7 };\n            int[] a = { 2, 3, 2 };\n\n            int result = ChineseRemainderTheorem.Solve(n, a);\n\n            int counter = 0;\n            int maxCount = n.Length - 1;\n            while (counter <= maxCount)\n            {\n                Console.WriteLine($\"{result} \u2261 {a[counter]} (mod {n[counter]})\");\n                counter++;\n            }\n        }\n    }\n\n    public static class ChineseRemainderTheorem\n    {\n        public static int Solve(int[] n, int[] a)\n        {\n            int prod = n.Aggregate(1, (i, j) => i * j);\n            int p;\n            int sm = 0;\n            for (int i = 0; i < n.Length; i++)\n            {\n                p = prod / n[i];\n                sm += a[i] * ModularMultiplicativeInverse(p, n[i]) * p;\n            }\n            return sm % prod;\n        }\n\n        private static int ModularMultiplicativeInverse(int a, int mod)\n        {\n            int b = a % mod;\n            for (int x = 1; x < mod; x++)\n            {\n                if ((b * x) % mod == 1)\n                {\n                    return x;\n                }\n            }\n            return 1;\n        }\n    }\n}\n"}
{"id": 24957, "name": "Chinese remainder theorem", "source": "Translate Ruby to C#: def chinese_remainder(mods, remainders)\n  max = mods.inject( :* )                            \n  series = remainders.zip( mods ).map{|r,m| r.step( max, m ).to_a } \n  series.inject( :& ).first \nend\n\np chinese_remainder([3,5,7], [2,3,2])     \np chinese_remainder([10,4,9], [11,22,19]) \n", "target": "using System;\nusing System.Linq;\n\nnamespace ChineseRemainderTheorem\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            int[] n = { 3, 5, 7 };\n            int[] a = { 2, 3, 2 };\n\n            int result = ChineseRemainderTheorem.Solve(n, a);\n\n            int counter = 0;\n            int maxCount = n.Length - 1;\n            while (counter <= maxCount)\n            {\n                Console.WriteLine($\"{result} \u2261 {a[counter]} (mod {n[counter]})\");\n                counter++;\n            }\n        }\n    }\n\n    public static class ChineseRemainderTheorem\n    {\n        public static int Solve(int[] n, int[] a)\n        {\n            int prod = n.Aggregate(1, (i, j) => i * j);\n            int p;\n            int sm = 0;\n            for (int i = 0; i < n.Length; i++)\n            {\n                p = prod / n[i];\n                sm += a[i] * ModularMultiplicativeInverse(p, n[i]) * p;\n            }\n            return sm % prod;\n        }\n\n        private static int ModularMultiplicativeInverse(int a, int mod)\n        {\n            int b = a % mod;\n            for (int x = 1; x < mod; x++)\n            {\n                if ((b * x) % mod == 1)\n                {\n                    return x;\n                }\n            }\n            return 1;\n        }\n    }\n}\n"}
{"id": 24960, "name": "Chinese remainder theorem", "source": "Translate Ruby to Java: def chinese_remainder(mods, remainders)\n  max = mods.inject( :* )                            \n  series = remainders.zip( mods ).map{|r,m| r.step( max, m ).to_a } \n  series.inject( :& ).first \nend\n\np chinese_remainder([3,5,7], [2,3,2])     \np chinese_remainder([10,4,9], [11,22,19]) \n", "target": "import static java.util.Arrays.stream;\n\npublic class ChineseRemainderTheorem {\n\n    public static int chineseRemainder(int[] n, int[] a) {\n\n        int prod = stream(n).reduce(1, (i, j) -> i * j);\n\n        int p, sm = 0;\n        for (int i = 0; i < n.length; i++) {\n            p = prod / n[i];\n            sm += a[i] * mulInv(p, n[i]) * p;\n        }\n        return sm % prod;\n    }\n\n    private static int mulInv(int a, int b) {\n        int b0 = b;\n        int x0 = 0;\n        int x1 = 1;\n\n        if (b == 1)\n            return 1;\n\n        while (a > 1) {\n            int q = a / b;\n            int amb = a % b;\n            a = b;\n            b = amb;\n            int xqx = x1 - q * x0;\n            x1 = x0;\n            x0 = xqx;\n        }\n\n        if (x1 < 0)\n            x1 += b0;\n\n        return x1;\n    }\n\n    public static void main(String[] args) {\n        int[] n = {3, 5, 7};\n        int[] a = {2, 3, 2};\n        System.out.println(chineseRemainder(n, a));\n    }\n}\n"}
{"id": 24961, "name": "Chinese remainder theorem", "source": "Translate Ruby to Python: def chinese_remainder(mods, remainders)\n  max = mods.inject( :* )                            \n  series = remainders.zip( mods ).map{|r,m| r.step( max, m ).to_a } \n  series.inject( :& ).first \nend\n\np chinese_remainder([3,5,7], [2,3,2])     \np chinese_remainder([10,4,9], [11,22,19]) \n", "target": "\ndef chinese_remainder(n, a):\n    sum = 0\n    prod = reduce(lambda a, b: a*b, n)\n\n    for n_i, a_i in zip(n, a):\n        p = prod / n_i\n        sum += a_i * mul_inv(p, n_i) * p\n    return sum % prod\n\n\ndef mul_inv(a, b):\n    b0 = b\n    x0, x1 = 0, 1\n    if b == 1: return 1\n    while a > 1:\n        q = a / b\n        a, b = b, a%b\n        x0, x1 = x1 - q * x0, x0\n    if x1 < 0: x1 += b0\n    return x1\n\nif __name__ == '__main__':\n    n = [3, 5, 7]\n    a = [2, 3, 2]\n    print chinese_remainder(n, a)\n"}
{"id": 24962, "name": "Chinese remainder theorem", "source": "Translate Ruby to Python: def chinese_remainder(mods, remainders)\n  max = mods.inject( :* )                            \n  series = remainders.zip( mods ).map{|r,m| r.step( max, m ).to_a } \n  series.inject( :& ).first \nend\n\np chinese_remainder([3,5,7], [2,3,2])     \np chinese_remainder([10,4,9], [11,22,19]) \n", "target": "\ndef chinese_remainder(n, a):\n    sum = 0\n    prod = reduce(lambda a, b: a*b, n)\n\n    for n_i, a_i in zip(n, a):\n        p = prod / n_i\n        sum += a_i * mul_inv(p, n_i) * p\n    return sum % prod\n\n\ndef mul_inv(a, b):\n    b0 = b\n    x0, x1 = 0, 1\n    if b == 1: return 1\n    while a > 1:\n        q = a / b\n        a, b = b, a%b\n        x0, x1 = x1 - q * x0, x0\n    if x1 < 0: x1 += b0\n    return x1\n\nif __name__ == '__main__':\n    n = [3, 5, 7]\n    a = [2, 3, 2]\n    print chinese_remainder(n, a)\n"}
{"id": 25150, "name": "Rosetta Code_Rank languages by popularity", "source": "Translate Ruby to C#: require 'rosettacode'\n\nlangs = []\nRosettaCode.category_members(\"Programming Languages\") {|lang| langs << lang}\n\n\n\nlangcount = {}\nlangs.each_slice(20) do |sublist|\n  url = RosettaCode.get_api_url({\n    \"action\" => \"query\",\n    \"prop\" => \"categoryinfo\",\n    \"format\" => \"xml\",\n    \"titles\" => sublist.join(\"|\"),\n  })\n\n  doc = REXML::Document.new open(url)\n  REXML::XPath.each(doc, \"//page\") do |page|\n    lang = page.attribute(\"title\").value\n    info = REXML::XPath.first(page, \"categoryinfo\")\n    langcount[lang] = info.nil? ? 0 : info.attribute(\"pages\").value.to_i\n  end\nend\n\nputs Time.now\nputs \"There are \nputs \"the top 25:\"\nlangcount.sort_by {|key,val| val}.reverse[0,25].each_with_index do |(lang, count), i|\n  puts \"\nend\n", "target": "using System;\nusing System.Collections;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Net;\nusing System.Text.RegularExpressions;\n\nclass Program\n{\n    static void Main(string[] args)\n    {\n        string get1 = new WebClient().DownloadString(\"http:\n        string get2 = new WebClient().DownloadString(\"http:\n\n        ArrayList langs = new ArrayList();\n        Dictionary<string, int> qtdmbr = new Dictionary<string, int>();\n\n        MatchCollection match1 = new Regex(\"\\\"title\\\":\\\"Category:(.+?)\\\"\").Matches(get1);\n        MatchCollection match2 = new Regex(\"title=\\\"Category:(.+?)\\\">.+?</a>[^(]*\\\\((\\\\d+) members\\\\)\").Matches(get2);\n\n        foreach (Match lang in match1) langs.Add(lang.Groups[1].Value);\n\n        foreach (Match match in match2)\n        {\n            if (langs.Contains(match.Groups[1].Value))\n            {\n                qtdmbr.Add(match.Groups[1].Value, Int32.Parse(match.Groups[2].Value));\n            }\n        }\n\n        string[] test = qtdmbr.OrderByDescending(x => x.Value).Select(x => String.Format(\"{0,3} - {1}\", x.Value, x.Key)).ToArray();\n\n        int count = 1;\n\n        foreach (string i in test)\n        {\n            Console.WriteLine(\"{0,3}. {1}\", count, i);\n            count++;\n        }\n    }\n}\n"}
{"id": 25152, "name": "Rosetta Code_Rank languages by popularity", "source": "Translate Ruby to Python: require 'rosettacode'\n\nlangs = []\nRosettaCode.category_members(\"Programming Languages\") {|lang| langs << lang}\n\n\n\nlangcount = {}\nlangs.each_slice(20) do |sublist|\n  url = RosettaCode.get_api_url({\n    \"action\" => \"query\",\n    \"prop\" => \"categoryinfo\",\n    \"format\" => \"xml\",\n    \"titles\" => sublist.join(\"|\"),\n  })\n\n  doc = REXML::Document.new open(url)\n  REXML::XPath.each(doc, \"//page\") do |page|\n    lang = page.attribute(\"title\").value\n    info = REXML::XPath.first(page, \"categoryinfo\")\n    langcount[lang] = info.nil? ? 0 : info.attribute(\"pages\").value.to_i\n  end\nend\n\nputs Time.now\nputs \"There are \nputs \"the top 25:\"\nlangcount.sort_by {|key,val| val}.reverse[0,25].each_with_index do |(lang, count), i|\n  puts \"\nend\n", "target": "import requests\nimport re\n\nresponse = requests.get(\"http://rosettacode.org/wiki/Category:Programming_Languages\").text\nlanguages = re.findall('title=\"Category:(.*?)\">',response)[:-3] \n\nresponse = requests.get(\"http://rosettacode.org/mw/index.php?title=Special:Categories&limit=5000\").text\nresponse = re.sub('(\\d+),(\\d+)',r'\\1'+r'\\2',response)           \nmembers  = re.findall('<li><a[^>]+>([^<]+)</a>[^(]*[(](\\\\d+) member[s]*[)]</li>',response) \n\nfor cnt, (language, members) in enumerate(sorted(members, key=lambda x: -int(x[1]))[:15]): \n    if language in languages:\n        print(\"{:4d} {:4d} - {}\".format(cnt+1, int(members), language))\n"}
{"id": 25266, "name": "Stable marriage problem", "source": "Translate Ruby to C#: class Person\n  def initialize(name)\n    @name = name\n    @fiance = nil\n    @preferences = []\n    @proposals = []\n  end\n  attr_reader :name, :proposals\n  attr_accessor :fiance, :preferences\n\n  def to_s\n    @name\n  end\n\n  def free\n    @fiance = nil\n  end\n\n  def single?\n    @fiance == nil\n  end\n\n  def engage(person)\n    self.fiance = person\n    person.fiance = self\n  end\n\n  def better_choice?(person)\n    @preferences.index(person) < @preferences.index(@fiance)\n  end\n\n  def propose_to(person)\n    puts \"\n    @proposals << person\n    person.respond_to_proposal_from(self)\n  end\n\n  def respond_to_proposal_from(person)\n    if single?\n      puts \"\n      engage(person)\n    elsif better_choice?(person)\n      puts \"\n      @fiance.free\n      engage(person)\n    else\n      puts \"\n    end\n  end\nend\n\n\n\n\nprefs = {\n  'abe'  => %w[abi eve cath ivy jan dee fay bea hope gay],\n  'bob'  => %w[cath hope abi dee eve fay bea jan ivy gay],\n  'col'  => %w[hope eve abi dee bea fay ivy gay cath jan],\n  'dan'  => %w[ivy fay dee gay hope eve jan bea cath abi],\n  'ed'   => %w[jan dee bea cath fay eve abi ivy hope gay],\n  'fred' => %w[bea abi dee gay eve ivy cath jan hope fay],\n  'gav'  => %w[gay eve ivy bea cath abi dee hope jan fay],\n  'hal'  => %w[abi eve hope fay ivy cath jan bea gay dee],\n  'ian'  => %w[hope cath dee gay bea abi fay ivy jan eve],\n  'jon'  => %w[abi fay jan gay eve bea dee cath ivy hope],\n  'abi'  => %w[bob fred jon gav ian abe dan ed col hal],\n  'bea'  => %w[bob abe col fred gav dan ian ed jon hal],\n  'cath' => %w[fred bob ed gav hal col ian abe dan jon],\n  'dee'  => %w[fred jon col abe ian hal gav dan bob ed],\n  'eve'  => %w[jon hal fred dan abe gav col ed ian bob],\n  'fay'  => %w[bob abe ed ian jon dan fred gav col hal],\n  'gay'  => %w[jon gav hal fred bob abe col ed dan ian],\n  'hope' => %w[gav jon bob abe ian dan hal ed col fred],\n  'ivy'  => %w[ian col hal gav fred bob abe ed jon dan],\n  'jan'  => %w[ed hal gav abe bob jon col ian fred dan],\n}\n\n@men = Hash[\n  %w[abe bob col dan ed fred gav hal ian jon].collect do |name|\n    [name, Person.new(name)]\n  end\n]\n\n@women = Hash[\n  %w[abi bea cath dee eve fay gay hope ivy jan].collect do |name|\n    [name, Person.new(name)]\n  end\n]\n\n@men.each {|name, man| man.preferences = @women.values_at(*prefs[name])}\n@women.each {|name, woman| woman.preferences = @men.values_at(*prefs[name])}\n\n\n\n\ndef match_couples(men, women)\n  men.each_value {|man| man.free}\n  women.each_value {|woman| woman.free}\n\n  while m = men.values.find {|man| man.single?} do\n    puts \"considering single man \n    w = m.preferences.find {|woman| not m.proposals.include?(woman)}\n    m.propose_to(w)\n  end\nend\n\nmatch_couples @men, @women\n\n@men.each_value.collect {|man| puts \"\n\n\n\n\nclass Person\n  def more_preferable_people\n    ( @preferences.partition {|p| better_choice?(p)} ).first\n  end\nend\n\nrequire 'set'\n\ndef stability(men)\n  unstable = Set.new\n  men.each_value do |man|\n    woman = man.fiance\n    puts \"considering \n\n    man.more_preferable_people.each do |other_woman|\n      if other_woman.more_preferable_people.include?(man)\n        puts \"an unstable pairing: \n        unstable << [man, other_woman]\n      end\n    end\n    woman.more_preferable_people.each do |other_man|\n      if other_man.more_preferable_people.include?(woman)\n        puts \"an unstable pairing: \n        unstable << [other_man, woman]\n      end\n    end\n  end\n\n  if unstable.empty?\n    puts \"these couples are stable\"\n  else\n    puts \"uh oh\"\n    unstable.each do |a,b|\n      puts \"\n    end\n  end\nend\n\nstability @men\n\n\n\n\nputs \"\\nwhat if abe and bob swap...\"\n\ndef swap(m1, m2)\n  w1 = m1.fiance\n  w2 = m2.fiance\n  m1.fiance = w2\n  w1.fiance = m2\n  m2.fiance = w1\n  w2.fiance = m1\nend\n\nswap *@men.values_at('abe','bob')\n\n@men.each_value.collect {|man| puts \"\nstability @men\n", "target": "using System;\nusing System.Collections.Generic;\n\nnamespace StableMarriage\n{\n    class Person\n    {\n        private int _candidateIndex;\n        public string Name { get; set; }\n        public List<Person> Prefs { get; set; }\n        public Person Fiance { get; set; }\n        \n        public Person(string name) {\n            Name = name;\n            Prefs = null;\n            Fiance = null;\n            _candidateIndex = 0;\n        }\n        public bool Prefers(Person p) {\n            return Prefs.FindIndex(o => o == p) < Prefs.FindIndex(o => o == Fiance);\n        }\n        public Person NextCandidateNotYetProposedTo() {\n            if (_candidateIndex >= Prefs.Count) return null;\n            return Prefs[_candidateIndex++];\n        }\n        public void EngageTo(Person p) {\n            if (p.Fiance != null) p.Fiance.Fiance = null;\n            p.Fiance = this;\n            if (Fiance != null) Fiance.Fiance = null;\n            Fiance = p;\n        }\n    }\n    \n    static class MainClass\n    {\n        static public bool IsStable(List<Person> men) {\n            List<Person> women = men[0].Prefs;\n            foreach (Person guy in men) {\n                foreach (Person gal in women) {\n                    if (guy.Prefers(gal) && gal.Prefers(guy))\n                        return false;\n                }\n            }\n            return true;\n        }\n        \n        static void DoMarriage() {\n            Person abe  = new Person(\"abe\");\n            Person bob  = new Person(\"bob\");\n            Person col  = new Person(\"col\");\n            Person dan  = new Person(\"dan\");\n            Person ed   = new Person(\"ed\");\n            Person fred = new Person(\"fred\");\n            Person gav  = new Person(\"gav\");\n            Person hal  = new Person(\"hal\");\n            Person ian  = new Person(\"ian\");\n            Person jon  = new Person(\"jon\");\n            Person abi  = new Person(\"abi\");\n            Person bea  = new Person(\"bea\");\n            Person cath = new Person(\"cath\");\n            Person dee  = new Person(\"dee\");\n            Person eve  = new Person(\"eve\");\n            Person fay  = new Person(\"fay\");\n            Person gay  = new Person(\"gay\");\n            Person hope = new Person(\"hope\");\n            Person ivy  = new Person(\"ivy\");\n            Person jan  = new Person(\"jan\");\n            \n            abe.Prefs  = new List<Person>() {abi, eve, cath, ivy, jan, dee, fay, bea, hope, gay};\n            bob.Prefs  = new List<Person>() {cath, hope, abi, dee, eve, fay, bea, jan, ivy, gay};\n            col.Prefs  = new List<Person>() {hope, eve, abi, dee, bea, fay, ivy, gay, cath, jan};\n            dan.Prefs  = new List<Person>() {ivy, fay, dee, gay, hope, eve, jan, bea, cath, abi};\n            ed.Prefs   = new List<Person>() {jan, dee, bea, cath, fay, eve, abi, ivy, hope, gay};\n            fred.Prefs = new List<Person>() {bea, abi, dee, gay, eve, ivy, cath, jan, hope, fay};\n            gav.Prefs  = new List<Person>() {gay, eve, ivy, bea, cath, abi, dee, hope, jan, fay};\n            hal.Prefs  = new List<Person>() {abi, eve, hope, fay, ivy, cath, jan, bea, gay, dee};\n            ian.Prefs  = new List<Person>() {hope, cath, dee, gay, bea, abi, fay, ivy, jan, eve};\n            jon.Prefs  = new List<Person>() {abi, fay, jan, gay, eve, bea, dee, cath, ivy, hope};\n            abi.Prefs  = new List<Person>() {bob, fred, jon, gav, ian, abe, dan, ed, col, hal};\n            bea.Prefs  = new List<Person>() {bob, abe, col, fred, gav, dan, ian, ed, jon, hal};\n            cath.Prefs = new List<Person>() {fred, bob, ed, gav, hal, col, ian, abe, dan, jon};\n            dee.Prefs  = new List<Person>() {fred, jon, col, abe, ian, hal, gav, dan, bob, ed};\n            eve.Prefs  = new List<Person>() {jon, hal, fred, dan, abe, gav, col, ed, ian, bob};\n            fay.Prefs  = new List<Person>() {bob, abe, ed, ian, jon, dan, fred, gav, col, hal};\n            gay.Prefs  = new List<Person>() {jon, gav, hal, fred, bob, abe, col, ed, dan, ian};\n            hope.Prefs = new List<Person>() {gav, jon, bob, abe, ian, dan, hal, ed, col, fred};\n            ivy.Prefs  = new List<Person>() {ian, col, hal, gav, fred, bob, abe, ed, jon, dan};\n            jan.Prefs  = new List<Person>() {ed, hal, gav, abe, bob, jon, col, ian, fred, dan};\n            \n            List<Person> men = new List<Person>(abi.Prefs);\n            \n            int freeMenCount = men.Count;\n            while (freeMenCount > 0) {\n                foreach (Person guy in men) {\n                    if (guy.Fiance == null) {\n                        Person gal = guy.NextCandidateNotYetProposedTo();\n                        if (gal.Fiance == null) {\n                            guy.EngageTo(gal);\n                            freeMenCount--;\n                        } else if (gal.Prefers(guy)) {\n                            guy.EngageTo(gal);\n                        }\n                    }\n                }\n            }\n            \n            foreach (Person guy in men) {\n                Console.WriteLine(\"{0} is engaged to {1}\", guy.Name, guy.Fiance.Name);\n            }\n            Console.WriteLine(\"Stable = {0}\", IsStable(men));\n            \n            Console.WriteLine(\"\\nSwitching fred & jon's partners\");\n            Person jonsFiance = jon.Fiance;\n            Person fredsFiance = fred.Fiance;\n            fred.EngageTo(jonsFiance);\n            jon.EngageTo(fredsFiance);\n            Console.WriteLine(\"Stable = {0}\", IsStable(men));\n        }\n        \n        public static void Main(string[] args)\n        {\n            DoMarriage();\n        }\n    }\n}\n"}
{"id": 25268, "name": "Stable marriage problem", "source": "Translate Ruby to Python: class Person\n  def initialize(name)\n    @name = name\n    @fiance = nil\n    @preferences = []\n    @proposals = []\n  end\n  attr_reader :name, :proposals\n  attr_accessor :fiance, :preferences\n\n  def to_s\n    @name\n  end\n\n  def free\n    @fiance = nil\n  end\n\n  def single?\n    @fiance == nil\n  end\n\n  def engage(person)\n    self.fiance = person\n    person.fiance = self\n  end\n\n  def better_choice?(person)\n    @preferences.index(person) < @preferences.index(@fiance)\n  end\n\n  def propose_to(person)\n    puts \"\n    @proposals << person\n    person.respond_to_proposal_from(self)\n  end\n\n  def respond_to_proposal_from(person)\n    if single?\n      puts \"\n      engage(person)\n    elsif better_choice?(person)\n      puts \"\n      @fiance.free\n      engage(person)\n    else\n      puts \"\n    end\n  end\nend\n\n\n\n\nprefs = {\n  'abe'  => %w[abi eve cath ivy jan dee fay bea hope gay],\n  'bob'  => %w[cath hope abi dee eve fay bea jan ivy gay],\n  'col'  => %w[hope eve abi dee bea fay ivy gay cath jan],\n  'dan'  => %w[ivy fay dee gay hope eve jan bea cath abi],\n  'ed'   => %w[jan dee bea cath fay eve abi ivy hope gay],\n  'fred' => %w[bea abi dee gay eve ivy cath jan hope fay],\n  'gav'  => %w[gay eve ivy bea cath abi dee hope jan fay],\n  'hal'  => %w[abi eve hope fay ivy cath jan bea gay dee],\n  'ian'  => %w[hope cath dee gay bea abi fay ivy jan eve],\n  'jon'  => %w[abi fay jan gay eve bea dee cath ivy hope],\n  'abi'  => %w[bob fred jon gav ian abe dan ed col hal],\n  'bea'  => %w[bob abe col fred gav dan ian ed jon hal],\n  'cath' => %w[fred bob ed gav hal col ian abe dan jon],\n  'dee'  => %w[fred jon col abe ian hal gav dan bob ed],\n  'eve'  => %w[jon hal fred dan abe gav col ed ian bob],\n  'fay'  => %w[bob abe ed ian jon dan fred gav col hal],\n  'gay'  => %w[jon gav hal fred bob abe col ed dan ian],\n  'hope' => %w[gav jon bob abe ian dan hal ed col fred],\n  'ivy'  => %w[ian col hal gav fred bob abe ed jon dan],\n  'jan'  => %w[ed hal gav abe bob jon col ian fred dan],\n}\n\n@men = Hash[\n  %w[abe bob col dan ed fred gav hal ian jon].collect do |name|\n    [name, Person.new(name)]\n  end\n]\n\n@women = Hash[\n  %w[abi bea cath dee eve fay gay hope ivy jan].collect do |name|\n    [name, Person.new(name)]\n  end\n]\n\n@men.each {|name, man| man.preferences = @women.values_at(*prefs[name])}\n@women.each {|name, woman| woman.preferences = @men.values_at(*prefs[name])}\n\n\n\n\ndef match_couples(men, women)\n  men.each_value {|man| man.free}\n  women.each_value {|woman| woman.free}\n\n  while m = men.values.find {|man| man.single?} do\n    puts \"considering single man \n    w = m.preferences.find {|woman| not m.proposals.include?(woman)}\n    m.propose_to(w)\n  end\nend\n\nmatch_couples @men, @women\n\n@men.each_value.collect {|man| puts \"\n\n\n\n\nclass Person\n  def more_preferable_people\n    ( @preferences.partition {|p| better_choice?(p)} ).first\n  end\nend\n\nrequire 'set'\n\ndef stability(men)\n  unstable = Set.new\n  men.each_value do |man|\n    woman = man.fiance\n    puts \"considering \n\n    man.more_preferable_people.each do |other_woman|\n      if other_woman.more_preferable_people.include?(man)\n        puts \"an unstable pairing: \n        unstable << [man, other_woman]\n      end\n    end\n    woman.more_preferable_people.each do |other_man|\n      if other_man.more_preferable_people.include?(woman)\n        puts \"an unstable pairing: \n        unstable << [other_man, woman]\n      end\n    end\n  end\n\n  if unstable.empty?\n    puts \"these couples are stable\"\n  else\n    puts \"uh oh\"\n    unstable.each do |a,b|\n      puts \"\n    end\n  end\nend\n\nstability @men\n\n\n\n\nputs \"\\nwhat if abe and bob swap...\"\n\ndef swap(m1, m2)\n  w1 = m1.fiance\n  w2 = m2.fiance\n  m1.fiance = w2\n  w1.fiance = m2\n  m2.fiance = w1\n  w2.fiance = m1\nend\n\nswap *@men.values_at('abe','bob')\n\n@men.each_value.collect {|man| puts \"\nstability @men\n", "target": "import copy\n\nguyprefers = {\n 'abe':  ['abi', 'eve', 'cath', 'ivy', 'jan', 'dee', 'fay', 'bea', 'hope', 'gay'],\n 'bob':  ['cath', 'hope', 'abi', 'dee', 'eve', 'fay', 'bea', 'jan', 'ivy', 'gay'],\n 'col':  ['hope', 'eve', 'abi', 'dee', 'bea', 'fay', 'ivy', 'gay', 'cath', 'jan'],\n 'dan':  ['ivy', 'fay', 'dee', 'gay', 'hope', 'eve', 'jan', 'bea', 'cath', 'abi'],\n 'ed':   ['jan', 'dee', 'bea', 'cath', 'fay', 'eve', 'abi', 'ivy', 'hope', 'gay'],\n 'fred': ['bea', 'abi', 'dee', 'gay', 'eve', 'ivy', 'cath', 'jan', 'hope', 'fay'],\n 'gav':  ['gay', 'eve', 'ivy', 'bea', 'cath', 'abi', 'dee', 'hope', 'jan', 'fay'],\n 'hal':  ['abi', 'eve', 'hope', 'fay', 'ivy', 'cath', 'jan', 'bea', 'gay', 'dee'],\n 'ian':  ['hope', 'cath', 'dee', 'gay', 'bea', 'abi', 'fay', 'ivy', 'jan', 'eve'],\n 'jon':  ['abi', 'fay', 'jan', 'gay', 'eve', 'bea', 'dee', 'cath', 'ivy', 'hope']}\ngalprefers = {\n 'abi':  ['bob', 'fred', 'jon', 'gav', 'ian', 'abe', 'dan', 'ed', 'col', 'hal'],\n 'bea':  ['bob', 'abe', 'col', 'fred', 'gav', 'dan', 'ian', 'ed', 'jon', 'hal'],\n 'cath': ['fred', 'bob', 'ed', 'gav', 'hal', 'col', 'ian', 'abe', 'dan', 'jon'],\n 'dee':  ['fred', 'jon', 'col', 'abe', 'ian', 'hal', 'gav', 'dan', 'bob', 'ed'],\n 'eve':  ['jon', 'hal', 'fred', 'dan', 'abe', 'gav', 'col', 'ed', 'ian', 'bob'],\n 'fay':  ['bob', 'abe', 'ed', 'ian', 'jon', 'dan', 'fred', 'gav', 'col', 'hal'],\n 'gay':  ['jon', 'gav', 'hal', 'fred', 'bob', 'abe', 'col', 'ed', 'dan', 'ian'],\n 'hope': ['gav', 'jon', 'bob', 'abe', 'ian', 'dan', 'hal', 'ed', 'col', 'fred'],\n 'ivy':  ['ian', 'col', 'hal', 'gav', 'fred', 'bob', 'abe', 'ed', 'jon', 'dan'],\n 'jan':  ['ed', 'hal', 'gav', 'abe', 'bob', 'jon', 'col', 'ian', 'fred', 'dan']}\n\nguys = sorted(guyprefers.keys())\ngals = sorted(galprefers.keys())\n\n\ndef check(engaged):\n    inverseengaged = dict((v,k) for k,v in engaged.items())\n    for she, he in engaged.items():\n        shelikes = galprefers[she]\n        shelikesbetter = shelikes[:shelikes.index(he)]\n        helikes = guyprefers[he]\n        helikesbetter = helikes[:helikes.index(she)]\n        for guy in shelikesbetter:\n            guysgirl = inverseengaged[guy]\n            guylikes = guyprefers[guy]\n            if guylikes.index(guysgirl) > guylikes.index(she):\n                print(\"%s and %s like each other better than \"\n                      \"their present partners: %s and %s, respectively\"\n                      % (she, guy, he, guysgirl))\n                return False\n        for gal in helikesbetter:\n            girlsguy = engaged[gal]\n            gallikes = galprefers[gal]\n            if gallikes.index(girlsguy) > gallikes.index(he):\n                print(\"%s and %s like each other better than \"\n                      \"their present partners: %s and %s, respectively\"\n                      % (he, gal, she, girlsguy))\n                return False\n    return True\n\ndef matchmaker():\n    guysfree = guys[:]\n    engaged  = {}\n    guyprefers2 = copy.deepcopy(guyprefers)\n    galprefers2 = copy.deepcopy(galprefers)\n    while guysfree:\n        guy = guysfree.pop(0)\n        guyslist = guyprefers2[guy]\n        gal = guyslist.pop(0)\n        fiance = engaged.get(gal)\n        if not fiance:\n            \n            engaged[gal] = guy\n            print(\"  %s and %s\" % (guy, gal))\n        else:\n            \n            galslist = galprefers2[gal]\n            if galslist.index(fiance) > galslist.index(guy):\n                \n                engaged[gal] = guy\n                print(\"  %s dumped %s for %s\" % (gal, fiance, guy))\n                if guyprefers2[fiance]:\n                    \n                    guysfree.append(fiance)\n            else:\n                \n                if guyslist:\n                    \n                    guysfree.append(guy)\n    return engaged\n\n\nprint('\\nEngagements:')\nengaged = matchmaker()\n\nprint('\\nCouples:')\nprint('  ' + ',\\n  '.join('%s is engaged to %s' % couple\n                          for couple in sorted(engaged.items())))\nprint()\nprint('Engagement stability check PASSED'\n      if check(engaged) else 'Engagement stability check FAILED')\n\nprint('\\n\\nSwapping two fiances to introduce an error')\nengaged[gals[0]], engaged[gals[1]] = engaged[gals[1]], engaged[gals[0]]\nfor gal in gals[:2]:\n    print('  %s is now engaged to %s' % (gal, engaged[gal]))\nprint()\nprint('Engagement stability check PASSED'\n      if check(engaged) else 'Engagement stability check FAILED')\n"}
{"id": 25401, "name": "Loops_With multiple ranges", "source": "Translate Ruby to C#: x, y, z, one, three, seven = 5, -5, -2, 1, 3, 7\n\nenums = (-three).step(3**3, three) +\n        (-seven).step(seven, x) +\n        555     .step(550-y, -1) +\n        22      .step(-28, -three) +\n        (1927..1939) +                \n        x       .step(y, z) +\n        (11**x) .step(11**x + one)\n\n\n\nputs \"Sum of absolute numbers:  \nprod = enums.inject(1){|prod, j| ((prod.abs < 2**27) && j!=0) ? prod*j : prod}\nputs \"Product (but not really): \n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\npublic static class LoopsWithMultipleRanges\n{\n    public static void Main() {\n        int prod = 1;\n        int sum = 0;\n        int x = 5;\n        int y = -5;\n        int z = -2;\n        int one = 1;\n        int three = 3;\n        int seven = 7; \n\n        foreach (int j in Concat(\n            For(-three, 3.Pow(3), three),\n            For(-seven, seven, x),\n            For(555, 550 - y),\n            For(22, -28, -three),\n            For(1927, 1939),\n            For(x, y, z),\n            For(11.Pow(x), 11.Pow(x) + one)\n        )) {\n            sum += Math.Abs(j);\n            if (Math.Abs(prod) < (1 << 27) && j != 0) prod *= j;\n        }\n        Console.WriteLine($\" sum = {sum:N0}\");\n        Console.WriteLine($\"prod = {prod:N0}\");\n    }\n\n    static IEnumerable<int> For(int start, int end, int by = 1) {\n        for (int i = start; by > 0 ? (i <= end) : (i >= end); i += by) yield return i;\n    }\n\n    static IEnumerable<int> Concat(params IEnumerable<int>[] ranges) => ranges.Aggregate((acc, r) => acc.Concat(r));\n    static int Pow(this int b, int e) => (int)Math.Pow(b, e);\n}\n"}
{"id": 25403, "name": "Loops_With multiple ranges", "source": "Translate Ruby to Java: x, y, z, one, three, seven = 5, -5, -2, 1, 3, 7\n\nenums = (-three).step(3**3, three) +\n        (-seven).step(seven, x) +\n        555     .step(550-y, -1) +\n        22      .step(-28, -three) +\n        (1927..1939) +                \n        x       .step(y, z) +\n        (11**x) .step(11**x + one)\n\n\n\nputs \"Sum of absolute numbers:  \nprod = enums.inject(1){|prod, j| ((prod.abs < 2**27) && j!=0) ? prod*j : prod}\nputs \"Product (but not really): \n", "target": "import java.util.ArrayList;\nimport java.util.List;\n\npublic class LoopsWithMultipleRanges {\n\n    private static long sum = 0;\n    private static long prod = 1;\n    \n    public static void main(String[] args) {\n        long x = 5;\n        long y = -5;\n        long z = -2;\n        long one = 1;\n        long three = 3;\n        long seven = 7;\n        \n        List<Long> jList = new ArrayList<>();\n        for ( long j = -three     ; j <= pow(3, 3)        ; j += three )  jList.add(j);\n        for ( long j = -seven     ; j <= seven            ; j += x )      jList.add(j);\n        for ( long j = 555        ; j <= 550-y            ; j += 1 )      jList.add(j);\n        for ( long j = 22         ; j >= -28              ; j += -three ) jList.add(j);\n        for ( long j = 1927       ; j <= 1939             ; j += 1 )      jList.add(j);\n        for ( long j = x          ; j >= y                ; j += z )      jList.add(j);\n        for ( long j = pow(11, x) ; j <= pow(11, x) + one ; j += 1 )      jList.add(j);\n\n        List<Long> prodList = new ArrayList<>();\n        for ( long j : jList ) {\n            sum += Math.abs(j);\n            if ( Math.abs(prod) < pow(2, 27) && j != 0 ) {\n                prodList.add(j);\n                prod *= j;\n            }            \n        }\n        \n        System.out.printf(\" sum        =\u00a0%,d%n\", sum);\n        System.out.printf(\"prod        =\u00a0%,d%n\", prod);\n        System.out.printf(\"j values    = %s%n\", jList);\n        System.out.printf(\"prod values = %s%n\", prodList);\n    }\n    \n    private static long pow(long base, long exponent) {\n        return (long) Math.pow(base, exponent);\n    }\n    \n}\n"}
{"id": 25404, "name": "Loops_With multiple ranges", "source": "Translate Ruby to Python: x, y, z, one, three, seven = 5, -5, -2, 1, 3, 7\n\nenums = (-three).step(3**3, three) +\n        (-seven).step(seven, x) +\n        555     .step(550-y, -1) +\n        22      .step(-28, -three) +\n        (1927..1939) +                \n        x       .step(y, z) +\n        (11**x) .step(11**x + one)\n\n\n\nputs \"Sum of absolute numbers:  \nprod = enums.inject(1){|prod, j| ((prod.abs < 2**27) && j!=0) ? prod*j : prod}\nputs \"Product (but not really): \n", "target": "from itertools import chain\n\nprod, sum_, x, y, z, one,three,seven = 1, 0, 5, -5, -2, 1, 3, 7\n\ndef _range(x, y, z=1):\n    return range(x, y + (1 if z > 0 else -1), z)\n\nprint(f'list(_range(x, y, z)) = {list(_range(x, y, z))}')\nprint(f'list(_range(-seven, seven, x)) = {list(_range(-seven, seven, x))}')\n\nfor j in chain(_range(-three, 3**3, three), _range(-seven, seven, x), \n               _range(555, 550 - y), _range(22, -28, -three),\n               _range(1927, 1939), _range(x, y, z),\n               _range(11**x, 11**x + 1)):\n    sum_ += abs(j)\n    if abs(prod) < 2**27 and (j != 0):\n        prod *= j\nprint(f' sum= {sum_}\\nprod= {prod}')\n"}
{"id": 25636, "name": "Day of the week", "source": "Translate Ruby to C#: require 'date'\n\n(2008..2121).each {|year| puts \"25 Dec \n", "target": "using System;\n\nclass Program\n{\n    static void Main(string[] args)\n    {\n        for (int i = 2008; i <= 2121; i++)\n        {\n            DateTime date = new DateTime(i, 12, 25);\n            if (date.DayOfWeek == DayOfWeek.Sunday)\n            {\n                Console.WriteLine(date.ToString(\"dd MMM yyyy\"));\n            }\n        }\n    }\n}\n"}
{"id": 25638, "name": "Day of the week", "source": "Translate Ruby to Java: require 'date'\n\n(2008..2121).each {|year| puts \"25 Dec \n", "target": "import java.util.Calendar;\nimport java.util.Date;\nimport java.util.GregorianCalendar;\n\npublic class Yuletide{\n\tpublic static void main(String[] args) {\n\t\tfor(int i = 2008;i<=2121;i++){\n\t\t\tCalendar cal = new GregorianCalendar(i, Calendar.DECEMBER,\n\t\t\t\t\t25);\n\t\t\tif(cal.get(Calendar.DAY_OF_WEEK)==Calendar.SUNDAY){\n\t\t\t\tSystem.out.println(cal.getTime());\n\t\t\t}\n\t\t}\n\t}\n}\n"}
{"id": 25639, "name": "Day of the week", "source": "Translate Ruby to Python: require 'date'\n\n(2008..2121).each {|year| puts \"25 Dec \n", "target": "from calendar import weekday, SUNDAY\n\n[year for year in range(2008, 2122) if weekday(year, 12, 25) == SUNDAY]\n"}
{"id": 25915, "name": "The Name Game", "source": "Translate Ruby to C#: \n\ndef print_verse(name)\n  first_letter_and_consonants_re = /^.[^aeiyou]*/i\n\n  full_name = name.capitalize \n  suffixed  = case full_name[0] \n              when 'A','E','I','O','U'\n                name.downcase\n              else\n                full_name.sub(first_letter_and_consonants_re, '')\n              end\n\n  b_name = \"b\n  f_name = \"f\n  m_name = \"m\n\n  case full_name[0]\n  when 'B'\n    b_name = suffixed\n  when 'F'\n    f_name = suffixed\n  when 'M'\n    m_name = suffixed\n  end\n\n  puts <<~END_VERSE\n    \n    Banana-fana fo-\n    Fee-fi-mo-\n    \n\n  END_VERSE\nend\n\n%w[Gary Earl Billy Felix Mary Steve Chris Byron].each do |name|\n    print_verse name\nend\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Text;\n\nnamespace TheNameGame {\n    class Program {\n        static void PrintVerse(string name) {\n            StringBuilder sb = new StringBuilder(name.ToLower());\n            sb[0] = Char.ToUpper(sb[0]);\n            string x = sb.ToString();\n            string y = \"AEIOU\".IndexOf(x[0]) > -1 ? x.ToLower() : x.Substring(1);\n            string b = \"b\" + y;\n            string f = \"f\" + y;\n            string m = \"m\" + y;\n            switch (x[0]) {\n                case 'B':\n                    b = y;\n                    break;\n                case 'F':\n                    f = y;\n                    break;\n                case 'M':\n                    m = y;\n                    break;\n            }\n            Console.WriteLine(\"{0}, {0}, bo-{1}\", x, b);\n            Console.WriteLine(\"Banana-fana fo-{0}\", f);\n            Console.WriteLine(\"Fee-fi-mo-{0}\", m);\n            Console.WriteLine(\"{0}!\", x);\n            Console.WriteLine();\n        }\n\n        static void Main(string[] args) {\n            List<string> nameList = new List<string>() { \"Gary\", \"Earl\", \"Billy\", \"Felix\", \"Mary\", \"Steve\" };\n            nameList.ForEach(PrintVerse);\n        }\n    }\n}\n"}
{"id": 25916, "name": "The Name Game", "source": "Translate Ruby to C#: \n\ndef print_verse(name)\n  first_letter_and_consonants_re = /^.[^aeiyou]*/i\n\n  full_name = name.capitalize \n  suffixed  = case full_name[0] \n              when 'A','E','I','O','U'\n                name.downcase\n              else\n                full_name.sub(first_letter_and_consonants_re, '')\n              end\n\n  b_name = \"b\n  f_name = \"f\n  m_name = \"m\n\n  case full_name[0]\n  when 'B'\n    b_name = suffixed\n  when 'F'\n    f_name = suffixed\n  when 'M'\n    m_name = suffixed\n  end\n\n  puts <<~END_VERSE\n    \n    Banana-fana fo-\n    Fee-fi-mo-\n    \n\n  END_VERSE\nend\n\n%w[Gary Earl Billy Felix Mary Steve Chris Byron].each do |name|\n    print_verse name\nend\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Text;\n\nnamespace TheNameGame {\n    class Program {\n        static void PrintVerse(string name) {\n            StringBuilder sb = new StringBuilder(name.ToLower());\n            sb[0] = Char.ToUpper(sb[0]);\n            string x = sb.ToString();\n            string y = \"AEIOU\".IndexOf(x[0]) > -1 ? x.ToLower() : x.Substring(1);\n            string b = \"b\" + y;\n            string f = \"f\" + y;\n            string m = \"m\" + y;\n            switch (x[0]) {\n                case 'B':\n                    b = y;\n                    break;\n                case 'F':\n                    f = y;\n                    break;\n                case 'M':\n                    m = y;\n                    break;\n            }\n            Console.WriteLine(\"{0}, {0}, bo-{1}\", x, b);\n            Console.WriteLine(\"Banana-fana fo-{0}\", f);\n            Console.WriteLine(\"Fee-fi-mo-{0}\", m);\n            Console.WriteLine(\"{0}!\", x);\n            Console.WriteLine();\n        }\n\n        static void Main(string[] args) {\n            List<string> nameList = new List<string>() { \"Gary\", \"Earl\", \"Billy\", \"Felix\", \"Mary\", \"Steve\" };\n            nameList.ForEach(PrintVerse);\n        }\n    }\n}\n"}
{"id": 25919, "name": "The Name Game", "source": "Translate Ruby to Java: \n\ndef print_verse(name)\n  first_letter_and_consonants_re = /^.[^aeiyou]*/i\n\n  full_name = name.capitalize \n  suffixed  = case full_name[0] \n              when 'A','E','I','O','U'\n                name.downcase\n              else\n                full_name.sub(first_letter_and_consonants_re, '')\n              end\n\n  b_name = \"b\n  f_name = \"f\n  m_name = \"m\n\n  case full_name[0]\n  when 'B'\n    b_name = suffixed\n  when 'F'\n    f_name = suffixed\n  when 'M'\n    m_name = suffixed\n  end\n\n  puts <<~END_VERSE\n    \n    Banana-fana fo-\n    Fee-fi-mo-\n    \n\n  END_VERSE\nend\n\n%w[Gary Earl Billy Felix Mary Steve Chris Byron].each do |name|\n    print_verse name\nend\n", "target": "import java.util.stream.Stream;\n\npublic class NameGame {\n    private static void printVerse(String name) {\n        StringBuilder sb = new StringBuilder(name.toLowerCase());\n        sb.setCharAt(0, Character.toUpperCase(sb.charAt(0)));\n        String x = sb.toString();\n        String y = \"AEIOU\".indexOf(x.charAt(0)) > -1 ? x.toLowerCase() : x.substring(1);\n        String b = \"b\" + y;\n        String f = \"f\" + y;\n        String m = \"m\" + y;\n        switch (x.charAt(0)) {\n            case 'B':\n                b = y;\n                break;\n            case 'F':\n                f = y;\n                break;\n            case 'M':\n                m = y;\n                break;\n            default:\n                \n                break;\n        }\n        System.out.printf(\"%s, %s, bo-%s\\n\", x, x, b);\n        System.out.printf(\"Banana-fana fo-%s\\n\", f);\n        System.out.printf(\"Fee-fi-mo-%s\\n\", m);\n        System.out.printf(\"%s!\\n\\n\", x);\n    }\n\n    public static void main(String[] args) {\n        Stream.of(\"Gary\", \"Earl\", \"Billy\", \"Felix\", \"Mary\", \"Steve\").forEach(NameGame::printVerse);\n    }\n}\n"}
{"id": 25920, "name": "The Name Game", "source": "Translate Ruby to Java: \n\ndef print_verse(name)\n  first_letter_and_consonants_re = /^.[^aeiyou]*/i\n\n  full_name = name.capitalize \n  suffixed  = case full_name[0] \n              when 'A','E','I','O','U'\n                name.downcase\n              else\n                full_name.sub(first_letter_and_consonants_re, '')\n              end\n\n  b_name = \"b\n  f_name = \"f\n  m_name = \"m\n\n  case full_name[0]\n  when 'B'\n    b_name = suffixed\n  when 'F'\n    f_name = suffixed\n  when 'M'\n    m_name = suffixed\n  end\n\n  puts <<~END_VERSE\n    \n    Banana-fana fo-\n    Fee-fi-mo-\n    \n\n  END_VERSE\nend\n\n%w[Gary Earl Billy Felix Mary Steve Chris Byron].each do |name|\n    print_verse name\nend\n", "target": "import java.util.stream.Stream;\n\npublic class NameGame {\n    private static void printVerse(String name) {\n        StringBuilder sb = new StringBuilder(name.toLowerCase());\n        sb.setCharAt(0, Character.toUpperCase(sb.charAt(0)));\n        String x = sb.toString();\n        String y = \"AEIOU\".indexOf(x.charAt(0)) > -1 ? x.toLowerCase() : x.substring(1);\n        String b = \"b\" + y;\n        String f = \"f\" + y;\n        String m = \"m\" + y;\n        switch (x.charAt(0)) {\n            case 'B':\n                b = y;\n                break;\n            case 'F':\n                f = y;\n                break;\n            case 'M':\n                m = y;\n                break;\n            default:\n                \n                break;\n        }\n        System.out.printf(\"%s, %s, bo-%s\\n\", x, x, b);\n        System.out.printf(\"Banana-fana fo-%s\\n\", f);\n        System.out.printf(\"Fee-fi-mo-%s\\n\", m);\n        System.out.printf(\"%s!\\n\\n\", x);\n    }\n\n    public static void main(String[] args) {\n        Stream.of(\"Gary\", \"Earl\", \"Billy\", \"Felix\", \"Mary\", \"Steve\").forEach(NameGame::printVerse);\n    }\n}\n"}
{"id": 25921, "name": "The Name Game", "source": "Translate Ruby to Python: \n\ndef print_verse(name)\n  first_letter_and_consonants_re = /^.[^aeiyou]*/i\n\n  full_name = name.capitalize \n  suffixed  = case full_name[0] \n              when 'A','E','I','O','U'\n                name.downcase\n              else\n                full_name.sub(first_letter_and_consonants_re, '')\n              end\n\n  b_name = \"b\n  f_name = \"f\n  m_name = \"m\n\n  case full_name[0]\n  when 'B'\n    b_name = suffixed\n  when 'F'\n    f_name = suffixed\n  when 'M'\n    m_name = suffixed\n  end\n\n  puts <<~END_VERSE\n    \n    Banana-fana fo-\n    Fee-fi-mo-\n    \n\n  END_VERSE\nend\n\n%w[Gary Earl Billy Felix Mary Steve Chris Byron].each do |name|\n    print_verse name\nend\n", "target": "def print_verse(n):\n    l = ['b', 'f', 'm']\n    s = n[1:]\n    if str.lower(n[0]) in l:\n        l[l.index(str.lower(n[0]))] = ''\n    elif n[0] in ['A', 'E', 'I', 'O', 'U']:\n        s = str.lower(n)\n    print('{0}, {0}, bo-{2}{1}\\nBanana-fana fo-{3}{1}\\nFee-fi-mo-{4}{1}\\n{0}!\\n'.format(n, s, *l))\n\n\nfor n in ['Gary', 'Earl', 'Billy', 'Felix', 'Mary']:\n    print_verse(n)\n"}
{"id": 25922, "name": "The Name Game", "source": "Translate Ruby to Python: \n\ndef print_verse(name)\n  first_letter_and_consonants_re = /^.[^aeiyou]*/i\n\n  full_name = name.capitalize \n  suffixed  = case full_name[0] \n              when 'A','E','I','O','U'\n                name.downcase\n              else\n                full_name.sub(first_letter_and_consonants_re, '')\n              end\n\n  b_name = \"b\n  f_name = \"f\n  m_name = \"m\n\n  case full_name[0]\n  when 'B'\n    b_name = suffixed\n  when 'F'\n    f_name = suffixed\n  when 'M'\n    m_name = suffixed\n  end\n\n  puts <<~END_VERSE\n    \n    Banana-fana fo-\n    Fee-fi-mo-\n    \n\n  END_VERSE\nend\n\n%w[Gary Earl Billy Felix Mary Steve Chris Byron].each do |name|\n    print_verse name\nend\n", "target": "def print_verse(n):\n    l = ['b', 'f', 'm']\n    s = n[1:]\n    if str.lower(n[0]) in l:\n        l[l.index(str.lower(n[0]))] = ''\n    elif n[0] in ['A', 'E', 'I', 'O', 'U']:\n        s = str.lower(n)\n    print('{0}, {0}, bo-{2}{1}\\nBanana-fana fo-{3}{1}\\nFee-fi-mo-{4}{1}\\n{0}!\\n'.format(n, s, *l))\n\n\nfor n in ['Gary', 'Earl', 'Billy', 'Felix', 'Mary']:\n    print_verse(n)\n"}
{"id": 26089, "name": "DNS query", "source": "Translate Ruby to C#: require \"socket\"\n\nSocket::Addrinfo.resolve(\n\t\"www.kame.net\",\n\t80,\n\ttype: Socket::Type::STREAM\n).each { |a|\n\tputs a.ip_address.address\n}\n", "target": "        private string LookupDns(string s)\n        {\n            try\n            {\n                System.Net.IPHostEntry ip = System.Net.Dns.GetHostEntry(s);\n\n                string result = ip.AddressList[0].ToString();\n\n                for (int i = 1; i < ip.AddressList.Length; ++i)\n                    result += \", \" + ip.AddressList[i].ToString();\n\n                return result;\n            }\n            catch (System.Net.Sockets.SocketException se)\n            {\n                return se.Message;\n            }\n        }\n"}
{"id": 26091, "name": "DNS query", "source": "Translate Ruby to Python: require \"socket\"\n\nSocket::Addrinfo.resolve(\n\t\"www.kame.net\",\n\t80,\n\ttype: Socket::Type::STREAM\n).each { |a|\n\tputs a.ip_address.address\n}\n", "target": ">>> import socket\n>>> ips = set(i[4][0] for i in socket.getaddrinfo('www.kame.net', 80))\n>>> for ip in ips: print ip\n...\n2001:200:dff:fff1:216:3eff:feb1:44d7\n203.178.141.194\n"}
{"id": 26350, "name": "Short-circuit evaluation", "source": "Translate Ruby to C#: def a( bool )\n  puts \"a( \n  bool\nend\n\ndef b( bool )\n  puts \"b( \n  bool\nend\n\n [true, false].each do |a_val|\n   [true, false].each do |b_val|\n     puts \"a( \n     puts\n     puts \"a( \n     puts\n   end\n end\n", "target": "using System;\n\nclass Program\n{\n    static bool a(bool value)\n    {\n        Console.WriteLine(\"a\");\n        return value;\n    }\n\n    static bool b(bool value)\n    {\n        Console.WriteLine(\"b\");\n        return value;\n    }\n\n    static void Main()\n    {\n        foreach (var i in new[] { false, true })\n        {\n            foreach (var j in new[] { false, true })\n            {\n                Console.WriteLine(\"{0} and {1} = {2}\", i, j, a(i) && b(j));\n                Console.WriteLine();\n                Console.WriteLine(\"{0} or {1} = {2}\", i, j, a(i) || b(j));\n                Console.WriteLine();\n            }\n        }\n    }\n}\n"}
{"id": 26352, "name": "Short-circuit evaluation", "source": "Translate Ruby to Java: def a( bool )\n  puts \"a( \n  bool\nend\n\ndef b( bool )\n  puts \"b( \n  bool\nend\n\n [true, false].each do |a_val|\n   [true, false].each do |b_val|\n     puts \"a( \n     puts\n     puts \"a( \n     puts\n   end\n end\n", "target": "module test\n    {\n    @Inject Console console;\n\n    static Boolean show(String name, Boolean value)\n        {\n        console.print($\"{name}()={value}\");\n        return value;\n        }\n\n    void run()\n        {\n        val a = show(\"a\", _);\n        val b = show(\"b\", _);\n\n        for (Boolean v1 : False..True)\n            {\n            for (Boolean v2 : False..True)\n                {\n                console.print($\"a({v1}) && b({v2}) == {a(v1) && b(v2)}\");\n                console.print();\n                console.print($\"a({v1}) || b({v2}) == {a(v1) || b(v2)}\");\n                console.print();\n                }\n            }\n        }\n    }\n"}
{"id": 26353, "name": "Short-circuit evaluation", "source": "Translate Ruby to Python: def a( bool )\n  puts \"a( \n  bool\nend\n\ndef b( bool )\n  puts \"b( \n  bool\nend\n\n [true, false].each do |a_val|\n   [true, false].each do |b_val|\n     puts \"a( \n     puts\n     puts \"a( \n     puts\n   end\n end\n", "target": ">>> def a(answer):\n\tprint(\"  \n\treturn answer\n\n>>> def b(answer):\n\tprint(\"  \n\treturn answer\n\n>>> for i in (False, True):\n\tfor j in (False, True):\n\t\tprint (\"\\nCalculating: x = a(i) and b(j)\")\n\t\tx = a(i) and b(j)\n\t\tprint (\"Calculating: y = a(i) or  b(j)\")\n\t\ty = a(i) or  b(j)\n\n\t\t\n\nCalculating: x = a(i) and b(j)\n  \nCalculating: y = a(i) or  b(j)\n  \n  \n\nCalculating: x = a(i) and b(j)\n  \nCalculating: y = a(i) or  b(j)\n  \n  \n\nCalculating: x = a(i) and b(j)\n  \n  \nCalculating: y = a(i) or  b(j)\n  \n\nCalculating: x = a(i) and b(j)\n  \n  \nCalculating: y = a(i) or  b(j)\n  \n"}
{"id": 26429, "name": "Distributed programming", "source": "Translate Ruby to C#: require 'drb/drb'\n\n\nURI=\"druby://localhost:8787\"\n\nclass TimeServer\n\n  def get_current_time\n    return Time.now\n  end\n\nend\n\n\nFRONT_OBJECT = TimeServer.new\n\n$SAFE = 1   \n\nDRb.start_service(URI, FRONT_OBJECT)\n\nDRb.thread.join\n", "target": "using System;\nusing System.IO;\nusing System.Net;\nusing System.Net.Sockets;\nusing System.Runtime.Serialization.Formatters.Binary;\nusing System.Threading.Tasks;\n\nusing static System.Console;\n\nclass DistributedProgramming\n{\n    const int Port = 555;\n\n    async static Task RunClient()\n    {\n        WriteLine(\"Connecting\");\n        var client = new TcpClient();\n        await client.ConnectAsync(\"localhost\", Port);\n\n        using (var stream = client.GetStream())\n        {\n            WriteLine(\"Sending loot\");\n            var data = Serialize(new SampleData());\n            await stream.WriteAsync(data, 0, data.Length);\n\n            WriteLine(\"Receiving thanks\");\n            var buffer = new byte[80000];\n            var bytesRead = await stream.ReadAsync(buffer, 0, buffer.Length);\n            var thanks = (string)Deserialize(buffer, bytesRead);\n            WriteLine(thanks);\n        }\n\n        client.Close();\n    }\n\n    async static Task RunServer()\n    {\n        WriteLine(\"Listening\");\n        var listener = new TcpListener(IPAddress.Any, Port);\n        listener.Start();\n        var client = await listener.AcceptTcpClientAsync();\n\n        using (var stream = client.GetStream())\n        {\n            WriteLine(\"Receiving loot\");\n            var buffer = new byte[80000];\n            var bytesRead = await stream.ReadAsync(buffer, 0, buffer.Length);\n            var data = (SampleData)Deserialize(buffer, bytesRead);\n            WriteLine($\"{data.Loot} at {data.Latitude}, {data.Longitude}\");\n\n            WriteLine(\"Sending thanks\");\n            var thanks = Serialize(\"Thanks!\");\n            await stream.WriteAsync(thanks, 0, thanks.Length);\n        }\n\n        client.Close();\n        listener.Stop();\n        Write(\"Press a key\");\n        ReadKey();\n    }\n\n    static byte[] Serialize(object data)\n    {\n        using (var mem = new MemoryStream())\n        {\n            new BinaryFormatter().Serialize(mem, data);\n            return mem.ToArray();\n        }\n    }\n\n    static object Deserialize(byte[] data, int length)\n    {\n        using (var mem = new MemoryStream(data, 0, length))\n        {\n            return new BinaryFormatter().Deserialize(mem);\n        }\n    }\n\n    static void Main(string[] args)\n    {\n        if (args.Length == 0) return;\n\n        switch (args[0])\n        {\n            case \"client\": RunClient().Wait(); break;\n            case \"server\": RunServer().Wait(); break;\n        }\n    }\n}\n\n[Serializable]\nclass SampleData\n{\n    public decimal Latitude = 44.33190m;\n    public decimal Longitude = 114.84129m;\n    public string Loot = \"140 tonnes of jade\";\n}\n"}
{"id": 26430, "name": "Distributed programming", "source": "Translate Ruby to Python: require 'drb/drb'\n\n\nURI=\"druby://localhost:8787\"\n\nclass TimeServer\n\n  def get_current_time\n    return Time.now\n  end\n\nend\n\n\nFRONT_OBJECT = TimeServer.new\n\n$SAFE = 1   \n\nDRb.start_service(URI, FRONT_OBJECT)\n\nDRb.thread.join\n", "target": "\n\n\nimport SimpleXMLRPCServer\n\nclass MyHandlerInstance:\n    def echo(self, data):\n        \n        return 'Server responded: %s' % data\n\n    def div(self, num1, num2):\n        \n        return num1/num2\n\ndef foo_function():\n    \n    return True\n\nHOST = \"localhost\"\nPORT = 8000\n\nserver = SimpleXMLRPCServer.SimpleXMLRPCServer((HOST, PORT))\n\n\nserver.register_introspection_functions()\n\n\nserver.register_instance(MyHandlerInstance())\n\n\nserver.register_function(foo_function)\n\ntry:\n    \n    server.serve_forever()\nexcept KeyboardInterrupt:\n    print 'Exiting...'\n    server.server_close()\n"}
{"id": 26730, "name": "ISBN13 check digit", "source": "Translate Ruby to C#: def validISBN13?(str)\n  cleaned = str.delete(\"^0-9\").chars\n  return false unless cleaned.size == 13\n  cleaned.each_slice(2).sum{|d1, d2| d1.to_i + 3*d2.to_i }.remainder(10) == 0\nend\n\nisbns = [\"978-1734314502\", \"978-1734314509\", \"978-1788399081\", \"978-1788399083\"]\nisbns.each{|isbn| puts \"\n", "target": "using System;\nusing System.Linq;\n\npublic class Program\n{\n    public static void Main() {\n        Console.WriteLine(CheckISBN13(\"978-1734314502\"));\n        Console.WriteLine(CheckISBN13(\"978-1734314509\"));\n        Console.WriteLine(CheckISBN13(\"978-1788399081\"));\n        Console.WriteLine(CheckISBN13(\"978-1788399083\"));\n\n        static bool CheckISBN13(string code) {\n            code = code.Replace(\"-\", \"\").Replace(\" \", \"\");\n            if (code.Length != 13) return false;\n            int sum = 0;\n            foreach (var (index, digit) in code.Select((digit, index) => (index, digit))) {\n                if (char.IsDigit(digit)) sum += (digit - '0') * (index % 2 == 0 ? 1 : 3);\n                else return false;\n            }\n            return sum % 10 == 0;\n        }\n    }\n}\n"}
{"id": 26731, "name": "ISBN13 check digit", "source": "Translate Ruby to C#: def validISBN13?(str)\n  cleaned = str.delete(\"^0-9\").chars\n  return false unless cleaned.size == 13\n  cleaned.each_slice(2).sum{|d1, d2| d1.to_i + 3*d2.to_i }.remainder(10) == 0\nend\n\nisbns = [\"978-1734314502\", \"978-1734314509\", \"978-1788399081\", \"978-1788399083\"]\nisbns.each{|isbn| puts \"\n", "target": "using System;\nusing System.Linq;\n\npublic class Program\n{\n    public static void Main() {\n        Console.WriteLine(CheckISBN13(\"978-1734314502\"));\n        Console.WriteLine(CheckISBN13(\"978-1734314509\"));\n        Console.WriteLine(CheckISBN13(\"978-1788399081\"));\n        Console.WriteLine(CheckISBN13(\"978-1788399083\"));\n\n        static bool CheckISBN13(string code) {\n            code = code.Replace(\"-\", \"\").Replace(\" \", \"\");\n            if (code.Length != 13) return false;\n            int sum = 0;\n            foreach (var (index, digit) in code.Select((digit, index) => (index, digit))) {\n                if (char.IsDigit(digit)) sum += (digit - '0') * (index % 2 == 0 ? 1 : 3);\n                else return false;\n            }\n            return sum % 10 == 0;\n        }\n    }\n}\n"}
{"id": 26734, "name": "ISBN13 check digit", "source": "Translate Ruby to Java: def validISBN13?(str)\n  cleaned = str.delete(\"^0-9\").chars\n  return false unless cleaned.size == 13\n  cleaned.each_slice(2).sum{|d1, d2| d1.to_i + 3*d2.to_i }.remainder(10) == 0\nend\n\nisbns = [\"978-1734314502\", \"978-1734314509\", \"978-1788399081\", \"978-1788399083\"]\nisbns.each{|isbn| puts \"\n", "target": "public static void main(){\n        System.out.println(isISBN13(\"978-1734314502\"));\n        System.out.println(isISBN13(\"978-1734314509\"));\n        System.out.println(isISBN13(\"978-1788399081\"));\n        System.out.println(isISBN13(\"978-1788399083\"));\n    }\npublic static boolean isISBN13(String in){\n        int pre = Integer.parseInt(in.substring(0,3));\n        if (pre!=978)return false;\n        String postStr = in.substring(4);\n        if (postStr.length()!=10)return false;\n        int post = Integer.parseInt(postStr);\n        int sum = 38;\n        for(int x = 0; x<10;x+=2)\n        sum += (postStr.charAt(x)-48)*3 + ((postStr.charAt(x+1)-48));\n        if(sum%10==0) return true;\n        return false;\n    }\n"}
{"id": 26735, "name": "ISBN13 check digit", "source": "Translate Ruby to Java: def validISBN13?(str)\n  cleaned = str.delete(\"^0-9\").chars\n  return false unless cleaned.size == 13\n  cleaned.each_slice(2).sum{|d1, d2| d1.to_i + 3*d2.to_i }.remainder(10) == 0\nend\n\nisbns = [\"978-1734314502\", \"978-1734314509\", \"978-1788399081\", \"978-1788399083\"]\nisbns.each{|isbn| puts \"\n", "target": "public static void main(){\n        System.out.println(isISBN13(\"978-1734314502\"));\n        System.out.println(isISBN13(\"978-1734314509\"));\n        System.out.println(isISBN13(\"978-1788399081\"));\n        System.out.println(isISBN13(\"978-1788399083\"));\n    }\npublic static boolean isISBN13(String in){\n        int pre = Integer.parseInt(in.substring(0,3));\n        if (pre!=978)return false;\n        String postStr = in.substring(4);\n        if (postStr.length()!=10)return false;\n        int post = Integer.parseInt(postStr);\n        int sum = 38;\n        for(int x = 0; x<10;x+=2)\n        sum += (postStr.charAt(x)-48)*3 + ((postStr.charAt(x+1)-48));\n        if(sum%10==0) return true;\n        return false;\n    }\n"}
{"id": 26736, "name": "ISBN13 check digit", "source": "Translate Ruby to Python: def validISBN13?(str)\n  cleaned = str.delete(\"^0-9\").chars\n  return false unless cleaned.size == 13\n  cleaned.each_slice(2).sum{|d1, d2| d1.to_i + 3*d2.to_i }.remainder(10) == 0\nend\n\nisbns = [\"978-1734314502\", \"978-1734314509\", \"978-1788399081\", \"978-1788399083\"]\nisbns.each{|isbn| puts \"\n", "target": "def is_isbn13(n):\n    n = n.replace('-','').replace(' ', '')\n    if len(n) != 13:\n        return False\n    product = (sum(int(ch) for ch in n[::2]) \n               + sum(int(ch) * 3 for ch in n[1::2]))\n    return product % 10 == 0\n\nif __name__ == '__main__':\n    tests = .strip().split()\n    for t in tests:\n        print(f\"ISBN13 {t} validates {is_isbn13(t)}\")\n"}
{"id": 26737, "name": "ISBN13 check digit", "source": "Translate Ruby to Python: def validISBN13?(str)\n  cleaned = str.delete(\"^0-9\").chars\n  return false unless cleaned.size == 13\n  cleaned.each_slice(2).sum{|d1, d2| d1.to_i + 3*d2.to_i }.remainder(10) == 0\nend\n\nisbns = [\"978-1734314502\", \"978-1734314509\", \"978-1788399081\", \"978-1788399083\"]\nisbns.each{|isbn| puts \"\n", "target": "def is_isbn13(n):\n    n = n.replace('-','').replace(' ', '')\n    if len(n) != 13:\n        return False\n    product = (sum(int(ch) for ch in n[::2]) \n               + sum(int(ch) * 3 for ch in n[1::2]))\n    return product % 10 == 0\n\nif __name__ == '__main__':\n    tests = .strip().split()\n    for t in tests:\n        print(f\"ISBN13 {t} validates {is_isbn13(t)}\")\n"}
{"id": 27024, "name": "Days between dates", "source": "Translate Ruby to C#: require \"date\"\n\nd1, d2 = Date.parse(\"2019-1-1\"), Date.parse(\"2019-10-19\")\n\np (d1 - d2).to_i  \np (d2 - d1).to_i  \n", "target": "using System;\nusing System.Globalization;\n\npublic class Program\n{\n    public static void Main() => WriteLine(DateDiff(\"1970-01-01\", \"2019-10-18\"));\n\n    public static int DateDiff(string d1, string d2) {\n        var a = DateTime.ParseExact(d1, \"yyyy-MM-dd\", CultureInfo.InvariantCulture);\n        var b = DateTime.ParseExact(d2, \"yyyy-MM-dd\", CultureInfo.InvariantCulture);\n        return (int)(b - a).TotalDays;\n    }\n}\n"}
{"id": 27025, "name": "Days between dates", "source": "Translate Ruby to C#: require \"date\"\n\nd1, d2 = Date.parse(\"2019-1-1\"), Date.parse(\"2019-10-19\")\n\np (d1 - d2).to_i  \np (d2 - d1).to_i  \n", "target": "using System;\nusing System.Globalization;\n\npublic class Program\n{\n    public static void Main() => WriteLine(DateDiff(\"1970-01-01\", \"2019-10-18\"));\n\n    public static int DateDiff(string d1, string d2) {\n        var a = DateTime.ParseExact(d1, \"yyyy-MM-dd\", CultureInfo.InvariantCulture);\n        var b = DateTime.ParseExact(d2, \"yyyy-MM-dd\", CultureInfo.InvariantCulture);\n        return (int)(b - a).TotalDays;\n    }\n}\n"}
{"id": 27028, "name": "Days between dates", "source": "Translate Ruby to Java: require \"date\"\n\nd1, d2 = Date.parse(\"2019-1-1\"), Date.parse(\"2019-10-19\")\n\np (d1 - d2).to_i  \np (d2 - d1).to_i  \n", "target": "import java.time.LocalDate;\nimport java.time.temporal.ChronoUnit;\n\npublic class DaysBetweenDates {\n    public static void main(String[] args) {\n        LocalDate fromDate = LocalDate.parse(\"2019-01-01\");\n        LocalDate toDate = LocalDate.parse(\"2019-10-19\");\n        long diff = ChronoUnit.DAYS.between(fromDate, toDate);\n        System.out.printf(\"Number of days between %s and %s: %d\\n\", fromDate, toDate, diff);\n    }\n}\n"}
{"id": 27029, "name": "Days between dates", "source": "Translate Ruby to Java: require \"date\"\n\nd1, d2 = Date.parse(\"2019-1-1\"), Date.parse(\"2019-10-19\")\n\np (d1 - d2).to_i  \np (d2 - d1).to_i  \n", "target": "import java.time.LocalDate;\nimport java.time.temporal.ChronoUnit;\n\npublic class DaysBetweenDates {\n    public static void main(String[] args) {\n        LocalDate fromDate = LocalDate.parse(\"2019-01-01\");\n        LocalDate toDate = LocalDate.parse(\"2019-10-19\");\n        long diff = ChronoUnit.DAYS.between(fromDate, toDate);\n        System.out.printf(\"Number of days between %s and %s: %d\\n\", fromDate, toDate, diff);\n    }\n}\n"}
{"id": 27030, "name": "Days between dates", "source": "Translate Ruby to Python: require \"date\"\n\nd1, d2 = Date.parse(\"2019-1-1\"), Date.parse(\"2019-10-19\")\n\np (d1 - d2).to_i  \np (d2 - d1).to_i  \n", "target": "\nimport sys\n\n\n\ndef days( y,m,d ):\n  \n  m = (m + 9) % 12 \n  y = y - m/10\n\n  \n  result = 365*y + y/4 - y/100 + y/400 + (m*306 + 5)/10 + ( d - 1 )\n  return result\n\ndef diff(one,two):\n  [y1,m1,d1] = one.split('-')\n  [y2,m2,d2] = two.split('-')\n  \n  year2 = days( int(y2),int(m2),int(d2))\n  year1 = days( int(y1), int(m1), int(d1) )\n  return year2 - year1\n\nif __name__ == \"__main__\":\n  one = sys.argv[1]\n  two = sys.argv[2]\n  print diff(one,two)\n"}
{"id": 27031, "name": "Days between dates", "source": "Translate Ruby to Python: require \"date\"\n\nd1, d2 = Date.parse(\"2019-1-1\"), Date.parse(\"2019-10-19\")\n\np (d1 - d2).to_i  \np (d2 - d1).to_i  \n", "target": "\nimport sys\n\n\n\ndef days( y,m,d ):\n  \n  m = (m + 9) % 12 \n  y = y - m/10\n\n  \n  result = 365*y + y/4 - y/100 + y/400 + (m*306 + 5)/10 + ( d - 1 )\n  return result\n\ndef diff(one,two):\n  [y1,m1,d1] = one.split('-')\n  [y2,m2,d2] = two.split('-')\n  \n  year2 = days( int(y2),int(m2),int(d2))\n  year1 = days( int(y1), int(m1), int(d1) )\n  return year2 - year1\n\nif __name__ == \"__main__\":\n  one = sys.argv[1]\n  two = sys.argv[2]\n  print diff(one,two)\n"}
{"id": 27283, "name": "Look-and-say sequence", "source": "Translate Ruby to C#: class String\n  def lookandsay\n    gsub(/(.)\\1*/){ |s| s.size.to_s + s[0] }\n  end\nend\n \nss = '1'\n12.times { puts ss; ss = ss.to_s.lookandsay }\n", "target": "using System;\nusing System.Text;\nusing System.Linq;\n\nclass Program\n{\n    static string lookandsay(string number)\n    {\n        StringBuilder result = new StringBuilder();\n\n        char repeat = number[0];\n        number = number.Substring(1, number.Length-1)+\" \";\n        int times = 1;\n      \n        foreach (char actual in number)\n        {\n            if (actual != repeat)\n            {\n                result.Append(Convert.ToString(times)+repeat);\n                times = 1;\n                repeat = actual;\n            }\n            else\n            {\n                times += 1;\n            }\n        }\n        return result.ToString();\n    }\n\n    static void Main(string[] args)\n    {\n        string num = \"1\"; \n\n        foreach (int i in Enumerable.Range(1, 10)) {\n             Console.WriteLine(num);\n             num = lookandsay(num);             \n        }\n    }\n}\n"}
{"id": 27285, "name": "Look-and-say sequence", "source": "Translate Ruby to Java: class String\n  def lookandsay\n    gsub(/(.)\\1*/){ |s| s.size.to_s + s[0] }\n  end\nend\n \nss = '1'\n12.times { puts ss; ss = ss.to_s.lookandsay }\n", "target": "public static String lookandsay(String number){\n\tStringBuilder result= new StringBuilder();\n\n\tchar repeat= number.charAt(0);\n\tnumber= number.substring(1) + \" \";\n\tint times= 1;\n\n\tfor(char actual: number.toCharArray()){\n\t\tif(actual != repeat){\n\t\t\tresult.append(times + \"\" + repeat);\n\t\t\ttimes= 1;\n\t\t\trepeat= actual;\n\t\t}else{\n\t\t\ttimes+= 1;\n\t\t}\n\t}\n\treturn result.toString();\n}\n"}
{"id": 27286, "name": "Look-and-say sequence", "source": "Translate Ruby to Python: class String\n  def lookandsay\n    gsub(/(.)\\1*/){ |s| s.size.to_s + s[0] }\n  end\nend\n \nss = '1'\n12.times { puts ss; ss = ss.to_s.lookandsay }\n", "target": "def lookandsay(number):\n    result = \"\"\n\n    repeat = number[0]\n    number = number[1:]+\" \"\n    times = 1\n\n    for actual in number:\n        if actual != repeat:\n            result += str(times)+repeat\n            times = 1\n            repeat = actual\n        else:\n            times += 1\n\n    return result\n\nnum = \"1\"\n\nfor i in range(10):\n    print num\n    num = lookandsay(num)\n"}
{"id": 27628, "name": "Closures_Value capture", "source": "Translate Ruby to C#: procs = Array.new(10){|i| ->{i*i} } \np procs[7].call \n", "target": "using System;\nusing System.Linq;\n\nclass Program\n{\n    static void Main()\n    {\n        var captor = (Func<int, Func<int>>)(number => () => number * number);\n        var functions = Enumerable.Range(0, 10).Select(captor);\n        foreach (var function in functions.Take(9))\n        {\n            Console.WriteLine(function());\n        }\n    }\n}\n"}
{"id": 27629, "name": "Closures_Value capture", "source": "Translate Ruby to C#: procs = Array.new(10){|i| ->{i*i} } \np procs[7].call \n", "target": "using System;\nusing System.Linq;\n\nclass Program\n{\n    static void Main()\n    {\n        var captor = (Func<int, Func<int>>)(number => () => number * number);\n        var functions = Enumerable.Range(0, 10).Select(captor);\n        foreach (var function in functions.Take(9))\n        {\n            Console.WriteLine(function());\n        }\n    }\n}\n"}
{"id": 27632, "name": "Closures_Value capture", "source": "Translate Ruby to Java: procs = Array.new(10){|i| ->{i*i} } \np procs[7].call \n", "target": "import java.util.function.Supplier;\nimport java.util.ArrayList;\n\npublic class ValueCapture {\n    public static void main(String[] args) {\n\tArrayList<Supplier<Integer>> funcs = new ArrayList<>();\n\tfor (int i = 0; i < 10; i++) {\n\t    int j = i;\n\t    funcs.add(() -> j * j);\n\t}\n\n\tSupplier<Integer> foo = funcs.get(3);\n\tSystem.out.println(foo.get()); \n    }\n}\n"}
{"id": 27633, "name": "Closures_Value capture", "source": "Translate Ruby to Java: procs = Array.new(10){|i| ->{i*i} } \np procs[7].call \n", "target": "import java.util.function.Supplier;\nimport java.util.ArrayList;\n\npublic class ValueCapture {\n    public static void main(String[] args) {\n\tArrayList<Supplier<Integer>> funcs = new ArrayList<>();\n\tfor (int i = 0; i < 10; i++) {\n\t    int j = i;\n\t    funcs.add(() -> j * j);\n\t}\n\n\tSupplier<Integer> foo = funcs.get(3);\n\tSystem.out.println(foo.get()); \n    }\n}\n"}
{"id": 27634, "name": "Closures_Value capture", "source": "Translate Ruby to Python: procs = Array.new(10){|i| ->{i*i} } \np procs[7].call \n", "target": "funcs = []\nfor i in range(10):\n    funcs.append(lambda: i * i)\nprint funcs[3]() \n"}
{"id": 27635, "name": "Closures_Value capture", "source": "Translate Ruby to Python: procs = Array.new(10){|i| ->{i*i} } \np procs[7].call \n", "target": "funcs = []\nfor i in range(10):\n    funcs.append(lambda: i * i)\nprint funcs[3]() \n"}
{"id": 27890, "name": "Send email", "source": "Translate Ruby to C#: require 'base64'\nrequire 'net/smtp'\nrequire 'tmail'\nrequire 'mime/types'\n\nclass Email\n  def initialize(from, to, subject, body, options={})\n    @opts = {:attachments => [], :server => 'localhost'}.update(options)\n    @msg = TMail::Mail.new\n    @msg.from    = from\n    @msg.to      = to\n    @msg.subject = subject\n    @msg.cc      = @opts[:cc]  if @opts[:cc]\n    @msg.bcc     = @opts[:bcc] if @opts[:bcc]\n\n    if @opts[:attachments].empty?\n      \n      @msg.body = body\n    else\n      \n      @msg.body = \"This is a multi-part message in MIME format.\\n\"\n\n      msg_body = TMail::Mail.new\n      msg_body.body = body\n      msg_body.set_content_type(\"text\",\"plain\", {:charset => \"ISO-8859-1\"})\n      @msg.parts << msg_body\n\n      octet_stream = MIME::Types['application/octet-stream'].first\n\n      @opts[:attachments].select {|file| File.readable?(file)}.each do |file|\n        mime_type = MIME::Types.type_for(file).first || octet_stream\n        @msg.parts << create_attachment(file, mime_type)\n      end\n    end\n  end\n  attr_reader :msg\n\n  def create_attachment(file, mime_type)\n    attach = TMail::Mail.new\n    if mime_type.binary?\n      attach.body = Base64.encode64(File.read(file))\n      attach.transfer_encoding = 'base64'\n    else\n      attach.body = File.read(file)\n    end\n    attach.set_disposition(\"attachment\", {:filename => file})\n    attach.set_content_type(mime_type.media_type, mime_type.sub_type, {:name=>file})\n    attach\n  end\n\n  \n  def send\n    args = @opts.values_at(:server, :port, :helo, :username, :password, :authtype)\n    Net::SMTP.start(*args) do |smtp|\n      smtp.send_message(@msg.to_s, @msg.from[0], @msg.to)\n    end\n  end\n\n  \n  def self.send(*args)\n    self.new(*args).send\n  end\nend\n\nEmail.send(\n  'sender@sender.invalid',\n  %w{ recip1@recipient.invalid recip2@example.com },\n  'the subject',\n  \"the body\\nhas lines\",\n  {\n    :attachments => %w{ file1 file2 file3 },\n    :server => 'mail.example.com',\n    :helo => 'sender.invalid',\n    :username => 'user',\n    :password => 'secret'\n  }\n)\n", "target": "static void Main(string[] args)\n{\n    \n\n    SmtpClient SMTP = new SmtpClient(\"smtp.gmail.com\", 587); \n    SMTP.EnableSsl = true; \n    SMTP.DeliveryMethod = SmtpDeliveryMethod.Network;\n    SMTP.Credentials = new NetworkCredential(\"YourUserName\", \"YourPassword\");\n    MailMessage Mail = new MailMessage(\"yourEmail@address.com\", \"theirEmail@address.com\");\n\n\n    \n\n    Mail.Subject = \"Important Message\";\n    Mail.Body = \"Hello over there\"; \n    \n\n    \n\n    SMTP.Send(Mail);\n\n    Console.WriteLine(\"Message Sent\");\n}\n"}
{"id": 27892, "name": "Send email", "source": "Translate Ruby to Java: require 'base64'\nrequire 'net/smtp'\nrequire 'tmail'\nrequire 'mime/types'\n\nclass Email\n  def initialize(from, to, subject, body, options={})\n    @opts = {:attachments => [], :server => 'localhost'}.update(options)\n    @msg = TMail::Mail.new\n    @msg.from    = from\n    @msg.to      = to\n    @msg.subject = subject\n    @msg.cc      = @opts[:cc]  if @opts[:cc]\n    @msg.bcc     = @opts[:bcc] if @opts[:bcc]\n\n    if @opts[:attachments].empty?\n      \n      @msg.body = body\n    else\n      \n      @msg.body = \"This is a multi-part message in MIME format.\\n\"\n\n      msg_body = TMail::Mail.new\n      msg_body.body = body\n      msg_body.set_content_type(\"text\",\"plain\", {:charset => \"ISO-8859-1\"})\n      @msg.parts << msg_body\n\n      octet_stream = MIME::Types['application/octet-stream'].first\n\n      @opts[:attachments].select {|file| File.readable?(file)}.each do |file|\n        mime_type = MIME::Types.type_for(file).first || octet_stream\n        @msg.parts << create_attachment(file, mime_type)\n      end\n    end\n  end\n  attr_reader :msg\n\n  def create_attachment(file, mime_type)\n    attach = TMail::Mail.new\n    if mime_type.binary?\n      attach.body = Base64.encode64(File.read(file))\n      attach.transfer_encoding = 'base64'\n    else\n      attach.body = File.read(file)\n    end\n    attach.set_disposition(\"attachment\", {:filename => file})\n    attach.set_content_type(mime_type.media_type, mime_type.sub_type, {:name=>file})\n    attach\n  end\n\n  \n  def send\n    args = @opts.values_at(:server, :port, :helo, :username, :password, :authtype)\n    Net::SMTP.start(*args) do |smtp|\n      smtp.send_message(@msg.to_s, @msg.from[0], @msg.to)\n    end\n  end\n\n  \n  def self.send(*args)\n    self.new(*args).send\n  end\nend\n\nEmail.send(\n  'sender@sender.invalid',\n  %w{ recip1@recipient.invalid recip2@example.com },\n  'the subject',\n  \"the body\\nhas lines\",\n  {\n    :attachments => %w{ file1 file2 file3 },\n    :server => 'mail.example.com',\n    :helo => 'sender.invalid',\n    :username => 'user',\n    :password => 'secret'\n  }\n)\n", "target": "import java.util.Properties;\n\nimport javax.mail.MessagingException;\nimport javax.mail.Session;\nimport javax.mail.Transport;\nimport javax.mail.Message.RecipientType;\nimport javax.mail.internet.InternetAddress;\nimport javax.mail.internet.MimeMessage;\n\n\npublic class Mail\n{\n \n protected Session session;\n\n \n public Mail(String host)\n {\n  Properties properties = new Properties();\n  properties.put(\"mail.smtp.host\", host);\n  session = Session.getDefaultInstance(properties);\n }\n\n \n public void send(String from, String tos[], String ccs[], String subject,\n        String text)\n        throws MessagingException\n {\n  MimeMessage message = new MimeMessage(session);\n  message.setFrom(new InternetAddress(from));\n  for (String to : tos)\n   message.addRecipient(RecipientType.TO, new InternetAddress(to));\n  for (String cc : ccs)\n   message.addRecipient(RecipientType.TO, new InternetAddress(cc));\n  message.setSubject(subject);\n  message.setText(text);\n  Transport.send(message);\n }\n}\n"}
{"id": 27893, "name": "Send email", "source": "Translate Ruby to Python: require 'base64'\nrequire 'net/smtp'\nrequire 'tmail'\nrequire 'mime/types'\n\nclass Email\n  def initialize(from, to, subject, body, options={})\n    @opts = {:attachments => [], :server => 'localhost'}.update(options)\n    @msg = TMail::Mail.new\n    @msg.from    = from\n    @msg.to      = to\n    @msg.subject = subject\n    @msg.cc      = @opts[:cc]  if @opts[:cc]\n    @msg.bcc     = @opts[:bcc] if @opts[:bcc]\n\n    if @opts[:attachments].empty?\n      \n      @msg.body = body\n    else\n      \n      @msg.body = \"This is a multi-part message in MIME format.\\n\"\n\n      msg_body = TMail::Mail.new\n      msg_body.body = body\n      msg_body.set_content_type(\"text\",\"plain\", {:charset => \"ISO-8859-1\"})\n      @msg.parts << msg_body\n\n      octet_stream = MIME::Types['application/octet-stream'].first\n\n      @opts[:attachments].select {|file| File.readable?(file)}.each do |file|\n        mime_type = MIME::Types.type_for(file).first || octet_stream\n        @msg.parts << create_attachment(file, mime_type)\n      end\n    end\n  end\n  attr_reader :msg\n\n  def create_attachment(file, mime_type)\n    attach = TMail::Mail.new\n    if mime_type.binary?\n      attach.body = Base64.encode64(File.read(file))\n      attach.transfer_encoding = 'base64'\n    else\n      attach.body = File.read(file)\n    end\n    attach.set_disposition(\"attachment\", {:filename => file})\n    attach.set_content_type(mime_type.media_type, mime_type.sub_type, {:name=>file})\n    attach\n  end\n\n  \n  def send\n    args = @opts.values_at(:server, :port, :helo, :username, :password, :authtype)\n    Net::SMTP.start(*args) do |smtp|\n      smtp.send_message(@msg.to_s, @msg.from[0], @msg.to)\n    end\n  end\n\n  \n  def self.send(*args)\n    self.new(*args).send\n  end\nend\n\nEmail.send(\n  'sender@sender.invalid',\n  %w{ recip1@recipient.invalid recip2@example.com },\n  'the subject',\n  \"the body\\nhas lines\",\n  {\n    :attachments => %w{ file1 file2 file3 },\n    :server => 'mail.example.com',\n    :helo => 'sender.invalid',\n    :username => 'user',\n    :password => 'secret'\n  }\n)\n", "target": "import smtplib\n\ndef sendemail(from_addr, to_addr_list, cc_addr_list,\n              subject, message,\n              login, password,\n              smtpserver='smtp.gmail.com:587'):\n    header  = 'From: %s\\n' % from_addr\n    header += 'To: %s\\n' % ','.join(to_addr_list)\n    header += 'Cc: %s\\n' % ','.join(cc_addr_list)\n    header += 'Subject: %s\\n\\n' % subject\n    message = header + message\n    \n    server = smtplib.SMTP(smtpserver)\n    server.starttls()\n    server.login(login,password)\n    problems = server.sendmail(from_addr, to_addr_list, message)\n    server.quit()\n    return problems\n"}
{"id": 28107, "name": "Sockets", "source": "Translate Ruby to C#: require 'socket'\nsock = TCPSocket.open(\"localhost\", 256)\nsock.write(\"hello socket world\")\nsock.close\n", "target": "using System;\nusing System.IO;\nusing System.Net.Sockets;\n\nclass Program {\n    static void Main(string[] args) {\n        TcpClient tcp = new TcpClient(\"localhost\", 256);\n        StreamWriter writer = new StreamWriter(tcp.GetStream());\n\n        writer.Write(\"hello socket world\");\n        writer.Flush();\n\n        tcp.Close();\n    }\n}\n"}
{"id": 28109, "name": "Sockets", "source": "Translate Ruby to Java: require 'socket'\nsock = TCPSocket.open(\"localhost\", 256)\nsock.write(\"hello socket world\")\nsock.close\n", "target": "import java.io.IOException;\nimport java.net.*;\npublic class SocketSend {\n  public static void main(String args[]) throws IOException {\n    sendData(\"localhost\", \"hello socket world\");\n  }\n\n  public static void sendData(String host, String msg) throws IOException {\n    Socket sock = new Socket( host, 256 );\n    sock.getOutputStream().write(msg.getBytes());\n    sock.getOutputStream().flush();\n    sock.close();\n  }\n}\n"}
{"id": 28110, "name": "Sockets", "source": "Translate Ruby to Python: require 'socket'\nsock = TCPSocket.open(\"localhost\", 256)\nsock.write(\"hello socket world\")\nsock.close\n", "target": "import socket\nsock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\nsock.connect((\"localhost\", 256))\nsock.sendall(\"hello socket world\") \nsock.close()\n"}
{"id": 28380, "name": "Caesar cipher", "source": "Translate Ruby to C#: class String\n  ALFABET = (\"A\"..\"Z\").to_a\n\n  def caesar_cipher(num)\n    self.tr(ALFABET.join, ALFABET.rotate(num).join)\n  end\n\nend\n\n\nencypted  = \"THEYBROKEOURCIPHEREVERYONECANREADTHIS\".caesar_cipher(3)\ndecrypted = encypted.caesar_cipher(-3)\n", "target": "using System;\nusing System.Linq;\n\nnamespace CaesarCypher\n{\n    class Program\n    {\n        static char Encrypt(char ch, int code)\n        {\n            if (!char.IsLetter(ch)) return ch;\n\n            char offset = char.IsUpper(ch) ? 'A' : 'a';\n            return (char)((ch + code - offset) % 26 + offset);\n        }\n\n        static string Encrypt(string input, int code)\n        {\n            return new string(input.Select(ch => Encrypt(ch, code)).ToArray());\n        }\n\n        static string Decrypt(string input, int code)\n        {\n            return Encrypt(input, 26 - code);\n        }\n\n        const string TestCase = \"Pack my box with five dozen liquor jugs.\";\n\n        static void Main()\n        {\n            string str = TestCase;\n\n            Console.WriteLine(str);\n            str = Encrypt(str, 5);\n            Console.WriteLine(\"Encrypted: \" + str);\n            str = Decrypt(str, 5);\n            Console.WriteLine(\"Decrypted: \" + str);\n            Console.ReadKey();\n        }\n    }\n}\n"}
{"id": 28382, "name": "Caesar cipher", "source": "Translate Ruby to Python: class String\n  ALFABET = (\"A\"..\"Z\").to_a\n\n  def caesar_cipher(num)\n    self.tr(ALFABET.join, ALFABET.rotate(num).join)\n  end\n\nend\n\n\nencypted  = \"THEYBROKEOURCIPHEREVERYONECANREADTHIS\".caesar_cipher(3)\ndecrypted = encypted.caesar_cipher(-3)\n", "target": "fun caesar(s, k, decode: false):\n    if decode:\n        k = 26 - k\n    result = ''\n    for i in s.uppercase() where 65 <= ord(i) <= 90:\n        result.push! char(ord(i) - 65 + k) mod 26 + 65\n    return result\n\nlet message = \"The quick brown fox jumped over the lazy dogs\"\nlet encrypted = caesar(msg, 11)\nlet decrypted = caesar(enc, 11, decode: true)\n\nprint(message, encrypted, decrypted, sep: '\\n')\n"}
{"id": 28524, "name": "Ordered partitions", "source": "Translate Ruby to C#: def partition(mask)\n  return [[]] if mask.empty?\n  [*1..mask.inject(:+)].permutation.map {|perm|\n    mask.map {|num_elts| perm.shift(num_elts).sort }\n  }.uniq\nend\n", "target": "using System;\nusing System.Linq;\nusing System.Collections.Generic;\n\npublic static class OrderedPartitions\n{\n    public static void Main() {\n        var input = new [] { new[] { 0, 0, 0, 0, 0 }, new[] { 2, 0, 2 }, new[] { 1, 1, 1 } };\n        foreach (int[] sizes in input) {\n            foreach (var partition in Partitions(sizes)) {\n                Console.WriteLine(partition.Select(set => set.Delimit(\", \").Encase('{','}')).Delimit(\", \").Encase('(', ')'));\n            }\n            Console.WriteLine();\n        }\n    }\n\n    static IEnumerable<IEnumerable<int[]>> Partitions(params int[] sizes) {\n        var enumerators = new IEnumerator<int[]>[sizes.Length];\n        var unused = Enumerable.Range(1, sizes.Sum()).ToSortedSet();\n        var arrays = sizes.Select(size => new int[size]).ToArray();\n\n        for (int s = 0; s >= 0; ) {\n            if (s == sizes.Length) {\n                yield return arrays;\n                s--;\n            }\n            if (enumerators[s] == null) {\n                enumerators[s] = Combinations(sizes[s], unused.ToArray()).GetEnumerator();\n            } else {\n                unused.UnionWith(arrays[s]);\n            }\n            if (enumerators[s].MoveNext()) {\n                enumerators[s].Current.CopyTo(arrays[s], 0);\n                unused.ExceptWith(arrays[s]);\n                s++;\n            } else {\n                enumerators[s] = null;\n                s--;\n            }\n        }\n    }\n\n    static IEnumerable<T[]> Combinations<T>(int count, params T[] array) {\n        T[] result = new T[count];\n        foreach (int pattern in BitPatterns(array.Length - count, array.Length)) {\n            for (int b = 1 << (array.Length - 1), i = 0, r = 0; b > 0; b >>= 1, i++) {\n                if ((pattern & b) == 0) result[r++] = array[i];\n            }\n            yield return result;\n        }\n    }\n\n    static IEnumerable<int> BitPatterns(int ones, int length) {\n        int initial = (1 << ones) - 1;\n        int blockMask = (1 << length) - 1;\n        for (int v = initial; v >= initial; ) {\n            yield return v;\n            if (v == 0) break;\n\n            int w = (v | (v - 1)) + 1;\n            w |= (((w & -w) / (v & -v)) >> 1) - 1;\n            v = w & blockMask;\n        }\n    }\n\n    static string Delimit<T>(this IEnumerable<T> source, string separator) => string.Join(separator, source);\n    static string Encase(this string s, char start, char end) => start + s + end;\n}\n"}
{"id": 28526, "name": "Ordered partitions", "source": "Translate Ruby to Python: def partition(mask)\n  return [[]] if mask.empty?\n  [*1..mask.inject(:+)].permutation.map {|perm|\n    mask.map {|num_elts| perm.shift(num_elts).sort }\n  }.uniq\nend\n", "target": "from itertools import combinations\n\ndef partitions(*args):\n    def p(s, *args):\n        if not args: return [[]]\n        res = []\n        for c in combinations(s, args[0]):\n            s0 = [x for x in s if x not in c]\n            for r in p(s0, *args[1:]):\n                res.append([c] + r)\n        return res\n    s = range(sum(args))\n    return p(s, *args)\n\nprint partitions(2, 0, 2)\n"}
{"id": 28711, "name": "Lucas-Lehmer test", "source": "Translate Ruby to C#: require \"big\"\n\ndef is_prime(n)                           \n  return n | 1 == 3 if n < 5              \n  return false if n.gcd(6) != 1           \n  pc1, pc2 = -1, 1                        \n  until (pc1 += 6) > Math.sqrt(n).to_i    \n    return false if n % pc1 == 0 || n % (pc2 += 6) == 0  \n  end\n  true\nend\n \ndef is_mersenne_prime(p)\n  return true  if p == 2\n  m_p = (1.to_big_i << p) - 1\n  s = 4\n  (p - 2).times { s = (s**2 - 2) % m_p }\n  s == 0\nend\n \nprecision = 20000   \nlong_bits_width = precision / Math.log(2) * Math.log(10)\nupb_prime = (long_bits_width - 1).to_i // 2    \nupb_count = 45      \n \nputs \"Finding Mersenne primes in M[2..%d]:\" % upb_prime\n \ncount = 0\n(2..upb_prime).each do |p|\n  if is_prime(p) && is_mersenne_prime(p)\n    print \"M%d \" % p\n    count += 1\n  end\n  break  if count >= upb_count\nend\nputs\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Numerics;\nusing System.Threading.Tasks;\n\nnamespace LucasLehmerTestForRosettaCode\n{\n    public class LucasLehmerTest\n    {\n        static BigInteger ZERO = new BigInteger(0);\n        static BigInteger ONE = new BigInteger(1);\n        static BigInteger TWO = new BigInteger(2);\n        static BigInteger FOUR = new BigInteger(4);\n\n        private static bool isMersennePrime(int p) \n        {\n            if (p % 2 == 0) return (p == 2);\n            else {\n                for (int i = 3; i <= (int)Math.Sqrt(p); i += 2)\n                    if (p % i == 0) return false; \n                BigInteger m_p = BigInteger.Pow(TWO, p) - ONE;\n                BigInteger s = FOUR;\n                for (int i = 3; i <= p; i++)\n                    s = (s * s - TWO) % m_p;\n                return s == ZERO;\n            } \n        }\n\n        public static int[] GetMersennePrimeNumbers(int upTo)\n        {\n            List<int> response = new List<int>();\n            Parallel.For(2, upTo + 1, i => {\n                if (isMersennePrime(i)) response.Add(i);\n            });\n            response.Sort();\n            return response.ToArray();\n        }\n\n        static void Main(string[] args)\n        {\n            int[] mersennePrimes = LucasLehmerTest.GetMersennePrimeNumbers(11213);\n            foreach (int mp in mersennePrimes)\n                Console.Write(\"M\" + mp+\" \");\n            Console.ReadLine();\n        }\n    }\n}\n"}
{"id": 28713, "name": "Lucas-Lehmer test", "source": "Translate Ruby to Java: require \"big\"\n\ndef is_prime(n)                           \n  return n | 1 == 3 if n < 5              \n  return false if n.gcd(6) != 1           \n  pc1, pc2 = -1, 1                        \n  until (pc1 += 6) > Math.sqrt(n).to_i    \n    return false if n % pc1 == 0 || n % (pc2 += 6) == 0  \n  end\n  true\nend\n \ndef is_mersenne_prime(p)\n  return true  if p == 2\n  m_p = (1.to_big_i << p) - 1\n  s = 4\n  (p - 2).times { s = (s**2 - 2) % m_p }\n  s == 0\nend\n \nprecision = 20000   \nlong_bits_width = precision / Math.log(2) * Math.log(10)\nupb_prime = (long_bits_width - 1).to_i // 2    \nupb_count = 45      \n \nputs \"Finding Mersenne primes in M[2..%d]:\" % upb_prime\n \ncount = 0\n(2..upb_prime).each do |p|\n  if is_prime(p) && is_mersenne_prime(p)\n    print \"M%d \" % p\n    count += 1\n  end\n  break  if count >= upb_count\nend\nputs\n", "target": "import java.math.BigInteger;\npublic class Mersenne\n{\n\n    public static boolean isPrime(int p) {\n        if (p == 2)\n            return true;\n        else if (p <= 1 || p % 2 == 0)\n            return false;\n        else {\n            int to = (int)Math.sqrt(p);\n            for (int i = 3; i <= to; i += 2)\n                if (p % i == 0)\n                    return false;\n            return true;\n        }\n    }\n\n    public static boolean isMersennePrime(int p) {\n        if (p == 2)\n            return true;\n        else {\n            BigInteger m_p = BigInteger.ONE.shiftLeft(p).subtract(BigInteger.ONE);\n            BigInteger s = BigInteger.valueOf(4);\n            for (int i = 3; i <= p; i++)\n                s = s.multiply(s).subtract(BigInteger.valueOf(2)).mod(m_p);\n            return s.equals(BigInteger.ZERO);\n        }\n    }\n\n    \n    public static void main(String[] args) {\n        int upb;\n        if (args.length == 0)\n            upb = 500;\n        else\n            upb = Integer.parseInt(args[0]);\n\n        System.out.print(\" Finding Mersenne primes in M[2..\" + upb + \"]:\\nM2 \");\n        for (int p = 3; p <= upb; p += 2)\n            if (isPrime(p) && isMersennePrime(p))\n                System.out.print(\" M\" + p);\n        System.out.println();\n    }\n}\n"}
{"id": 28714, "name": "Lucas-Lehmer test", "source": "Translate Ruby to Python: require \"big\"\n\ndef is_prime(n)                           \n  return n | 1 == 3 if n < 5              \n  return false if n.gcd(6) != 1           \n  pc1, pc2 = -1, 1                        \n  until (pc1 += 6) > Math.sqrt(n).to_i    \n    return false if n % pc1 == 0 || n % (pc2 += 6) == 0  \n  end\n  true\nend\n \ndef is_mersenne_prime(p)\n  return true  if p == 2\n  m_p = (1.to_big_i << p) - 1\n  s = 4\n  (p - 2).times { s = (s**2 - 2) % m_p }\n  s == 0\nend\n \nprecision = 20000   \nlong_bits_width = precision / Math.log(2) * Math.log(10)\nupb_prime = (long_bits_width - 1).to_i // 2    \nupb_count = 45      \n \nputs \"Finding Mersenne primes in M[2..%d]:\" % upb_prime\n \ncount = 0\n(2..upb_prime).each do |p|\n  if is_prime(p) && is_mersenne_prime(p)\n    print \"M%d \" % p\n    count += 1\n  end\n  break  if count >= upb_count\nend\nputs\n", "target": "from sys import stdout\nfrom math import sqrt, log\n\ndef is_prime ( p ):\n  if p == 2: return True \n  elif p <= 1 or p % 2 == 0: return False\n  else:\n    for i in range(3, int(sqrt(p))+1, 2 ): \n      if p % i == 0: return False\n    return True\n\ndef is_mersenne_prime ( p ):\n  if p == 2:\n    return True\n  else:\n    m_p = ( 1 << p ) - 1\n    s = 4\n    for i in range(3, p+1): \n      s = (s ** 2 - 2) % m_p\n    return s == 0\n\nprecision = 20000   \nlong_bits_width = precision * log(10, 2)\nupb_prime = int( long_bits_width - 1 ) / 2    \nupb_count = 45      \n\nprint (\" Finding Mersenne primes in M[2..%d]:\"%upb_prime)\n\ncount=0\nfor p in range(2, int(upb_prime+1)): \n  if is_prime(p) and is_mersenne_prime(p):\n    print(\"M%d\"%p),\n    stdout.flush()\n    count += 1\n  if count >= upb_count: break\nprint\n"}
{"id": 28949, "name": "FizzBuzz", "source": "Translate Ruby to C#: 1.upto(100) do |v|\n  p fizz_buzz(v)\nend\n\ndef fizz_buzz(value)\n  word = \"\"\n  word += \"fizz\" if value % 3 == 0\n  word += \"buzz\" if value % 5 == 0\n  word += value.to_s if word.empty?\n  word\nend\n", "target": "class Program\n{\n    public void FizzBuzzGo()\n    {\n        Boolean Fizz = false;\n        Boolean Buzz = false;\n        for (int count = 1; count <= 100; count ++)\n        {\n            Fizz = count % 3 == 0;\n            Buzz = count % 5 == 0;\n            if (Fizz && Buzz)\n            {\n                Console.WriteLine(\"Fizz Buzz\");\n                listBox1.Items.Add(\"Fizz Buzz\");\n            }\n            else if (Fizz)\n            {\n                Console.WriteLine(\"Fizz\");\n                listBox1.Items.Add(\"Fizz\");\n            }\n            else if (Buzz)\n            {\n                Console.WriteLine(\"Buzz\");\n                listBox1.Items.Add(\"Buzz\");\n            }\n            else\n            {\n                Console.WriteLine(count);\n                listBox1.Items.Add(count);\n            }\n        }\n    }\n}\n"}
{"id": 28951, "name": "FizzBuzz", "source": "Translate Ruby to Java: 1.upto(100) do |v|\n  p fizz_buzz(v)\nend\n\ndef fizz_buzz(value)\n  word = \"\"\n  word += \"fizz\" if value % 3 == 0\n  word += \"buzz\" if value % 5 == 0\n  word += value.to_s if word.empty?\n  word\nend\n", "target": "module FizzBuzz\n    {\n    void run()\n        {\n        @Inject Console console;\n        for (Int x : 1..100)\n            {\n            console.print(switch (x % 3, x % 5)\n                {\n                case (0, 0): \"FizzBuzz\";\n                case (0, _): \"Fizz\";\n                case (_, 0): \"Buzz\";\n                case (_, _): x.toString();\n                });\n            }\n        }\n    }\n"}
{"id": 28952, "name": "FizzBuzz", "source": "Translate Ruby to Python: 1.upto(100) do |v|\n  p fizz_buzz(v)\nend\n\ndef fizz_buzz(value)\n  word = \"\"\n  word += \"fizz\" if value % 3 == 0\n  word += \"buzz\" if value % 5 == 0\n  word += value.to_s if word.empty?\n  word\nend\n", "target": "for i in xrange(1, 101):\n    if i % 15 == 0:\n        print \"FizzBuzz\"\n    elif i % 3 == 0:\n        print \"Fizz\"\n    elif i % 5 == 0:\n        print \"Buzz\"\n    else:\n        print i\n"}
{"id": 29185, "name": "Monty Hall problem", "source": "Translate Ruby to C#: n = 10_000                  \n\nstay = switch = 0           \n\nn.times do                  \n  \n  \n  doors = [ :goat, :goat, :car ].shuffle\n  \n  \n  guess = rand(3)\n  \n  \n  begin shown = rand(3) end while shown == guess || doors[shown] == :car\n  \n  if doors[guess] == :car\n    \n    stay += 1\n  else\n    \n    switch += 1\n  end\n  \nend\n\nputs \"Staying wins\u00a0%.2f%% of the time.\"   % (100.0 * stay   / n)\nputs \"Switching wins\u00a0%.2f%% of the time.\" % (100.0 * switch / n)\n", "target": "using System;\n\nclass Program\n{\n    static void Main(string[] args)\n    {\n        int switchWins = 0;\n        int stayWins = 0;\n\n        Random gen = new Random();\n\t\t    \n        for(int plays = 0; plays < 1000000; plays++ )\n        {\n            int[] doors = {0,0,0};\n\n            var winner = gen.Next(3);\n            doors[winner] = 1; \n                \n\t    int choice = gen.Next(3); \n\t    int shown; \n\t    do\n            {\n\t        shown = gen.Next(3);\n\t    }\n            while (doors[shown] == 1 || shown == choice); \n     \n\t    stayWins += doors[choice]; \n     \n            \n            switchWins += doors[3 - choice - shown];\n        }\n\n        Console.Out.WriteLine(\"Staying wins \" + stayWins + \" times.\");\n        Console.Out.WriteLine(\"Switching wins \" + switchWins + \" times.\");\n    }\n}\n"}
{"id": 29187, "name": "Monty Hall problem", "source": "Translate Ruby to Java: n = 10_000                  \n\nstay = switch = 0           \n\nn.times do                  \n  \n  \n  doors = [ :goat, :goat, :car ].shuffle\n  \n  \n  guess = rand(3)\n  \n  \n  begin shown = rand(3) end while shown == guess || doors[shown] == :car\n  \n  if doors[guess] == :car\n    \n    stay += 1\n  else\n    \n    switch += 1\n  end\n  \nend\n\nputs \"Staying wins\u00a0%.2f%% of the time.\"   % (100.0 * stay   / n)\nputs \"Switching wins\u00a0%.2f%% of the time.\" % (100.0 * switch / n)\n", "target": "import java.util.Random;\npublic class Monty{\n\tpublic static void main(String[] args){\n\t\tint switchWins = 0;\n\t\tint stayWins = 0;\n\t\tRandom gen = new Random();\n\t\tfor(int plays = 0;plays < 32768;plays++ ){\n\t\t\tint[] doors = {0,0,0};\n\t\t\tdoors[gen.nextInt(3)] = 1;\n\t\t\tint choice = gen.nextInt(3); \n\t\t\tint shown; \n\t\t\tdo{\n\t\t\t\tshown = gen.nextInt(3);\n\t\t\t\n\t\t\t}while(doors[shown] == 1 || shown == choice);\n\t\t\t\n\t\t\tstayWins += doors[choice];\n\t\t\t\n\t\t\t\n\t\t\tswitchWins += doors[3 - choice - shown];\n\t\t}\n\t\tSystem.out.println(\"Switching wins \" + switchWins + \" times.\");\n\t\tSystem.out.println(\"Staying wins \" + stayWins + \" times.\");\n\t}\n}\n"}
{"id": 29188, "name": "Monty Hall problem", "source": "Translate Ruby to Python: n = 10_000                  \n\nstay = switch = 0           \n\nn.times do                  \n  \n  \n  doors = [ :goat, :goat, :car ].shuffle\n  \n  \n  guess = rand(3)\n  \n  \n  begin shown = rand(3) end while shown == guess || doors[shown] == :car\n  \n  if doors[guess] == :car\n    \n    stay += 1\n  else\n    \n    switch += 1\n  end\n  \nend\n\nputs \"Staying wins\u00a0%.2f%% of the time.\"   % (100.0 * stay   / n)\nputs \"Switching wins\u00a0%.2f%% of the time.\" % (100.0 * switch / n)\n", "target": "\nfrom random import randrange\n\ndoors, iterations = 3,100000  \n\ndef monty_hall(choice, switch=False, doorCount=doors):\n  \n  door = [False]*doorCount\n  \n  door[randrange(doorCount)] = True\n\n  chosen = door[choice]\n\n  unpicked = door\n  del unpicked[choice]\n\n  \n  \n  \n  alternative = True in unpicked\n\n  if switch:\n    return alternative\n  else:\n    return chosen\n\nprint \"\\nMonty Hall problem simulation:\"\nprint doors, \"doors,\", iterations, \"iterations.\\n\"\n\nprint \"Not switching allows you to win\",\nprint sum(monty_hall(randrange(3), switch=False)\n          for x in range(iterations)),\nprint \"out of\", iterations, \"times.\"\nprint \"Switching allows you to win\",\nprint sum(monty_hall(randrange(3), switch=True)\n          for x in range(iterations)),\nprint \"out of\", iterations, \"times.\\n\"\n"}
{"id": 29349, "name": "Polymorphic copy", "source": "Translate Ruby to C#: class T\n  def name\n    \"T\"\n  end\nend\n\nclass S\n  def name\n    \"S\"\n  end\nend\n\nobj1 = T.new\nobj2 = S.new\nputs obj1.dup.name \nputs obj2.dup.name \n", "target": "using System;\n\nclass T\n{\n    public virtual string Name()\n    {\n        return \"T\";\n    }\n\n    public virtual T Clone()\n    {\n        return new T();\n    }\n}\n\nclass S : T\n{\n    public override string Name()\n    {\n        return \"S\";\n    }\n\n    public override T Clone()\n    {\n        return new S();\n    }\n}\n\nclass Program\n{\n    static void Main()\n    {\n        T original = new S();\n        T clone = original.Clone();\n\n        Console.WriteLine(original.Name());\n        Console.WriteLine(clone.Name());\n    }\n}\n"}
{"id": 29351, "name": "Polymorphic copy", "source": "Translate Ruby to Python: class T\n  def name\n    \"T\"\n  end\nend\n\nclass S\n  def name\n    \"S\"\n  end\nend\n\nobj1 = T.new\nobj2 = S.new\nputs obj1.dup.name \nputs obj2.dup.name \n", "target": "import copy\n\nclass T:\n   def classname(self): \n      return self.__class__.__name__\n\n   def __init__(self):\n      self.myValue = \"I'm a T.\"\n\n   def speak(self):\n      print self.classname(), 'Hello', self.myValue\n\n   def clone(self):\n      return copy.copy(self)\n\nclass S1(T):\n   def speak(self):\n      print self.classname(),\"Meow\", self.myValue\n\nclass S2(T):\n   def speak(self):\n      print self.classname(),\"Woof\", self.myValue\n\n\nprint \"creating initial objects of types S1, S2, and T\"\na = S1()\na.myValue = 'Green'\na.speak()\n\nb = S2()\nb.myValue = 'Blue'\nb.speak()\n\nu = T()\nu.myValue = 'Purple'\nu.speak()\n\nprint \"Making copy of a as u, colors and types should match\"\nu = a.clone()\nu.speak()\na.speak()\nprint \"Assigning new color to u, A's color should be unchanged.\"\nu.myValue = \"Orange\"\nu.speak()\na.speak()\n\nprint \"Assigning u to reference same object as b, colors and types should match\"\nu = b\nu.speak()\nb.speak()\nprint \"Assigning new color to u. Since u,b references same object b's color changes as well\"\nu.myValue = \"Yellow\"\nu.speak()\nb.speak()\n"}
{"id": 29602, "name": "User input_Text", "source": "Translate Ruby to C#: puts \"You entered: \n\nbegin\n  puts \"You entered: \nrescue ex\n  puts ex\nend\n", "target": "using System;\n\nnamespace C_Sharp_Console {\n\n    class example {\n\n        static void Main() {\n            string word;\n            int num;\n            \n            Console.Write(\"Enter an integer: \");\n            num = Console.Read();\n            Console.Write(\"Enter a String: \");\n            word = Console.ReadLine();\n        }\n    }\n}\n"}
{"id": 29604, "name": "User input_Text", "source": "Translate Ruby to Java: puts \"You entered: \n\nbegin\n  puts \"You entered: \nrescue ex\n  puts ex\nend\n", "target": "import java.util.Scanner;\n\npublic class GetInput {\n    public static void main(String[] args) throws Exception {\n        Scanner s = new Scanner(System.in);\n        System.out.print(\"Enter a string: \");\n        String str = s.nextLine();\n        System.out.print(\"Enter an integer: \");\n        int i = Integer.parseInt(s.next());\n    }\n}\n"}
{"id": 29605, "name": "User input_Text", "source": "Translate Ruby to Python: puts \"You entered: \n\nbegin\n  puts \"You entered: \nrescue ex\n  puts ex\nend\n", "target": "   string = raw_input(\"Input a string: \")\n"}
{"id": 30022, "name": "Show the epoch", "source": "Translate Ruby to C#: irb(main):001:0> Time.at(0).utc\n=> 1970-01-01 00:00:00 UTC\n", "target": "using System;\n\nclass Program\n{\n    static void Main()\n    {\n        Console.WriteLine(new DateTime());\n    }\n}\n"}
{"id": 30023, "name": "Show the epoch", "source": "Translate Ruby to C#: irb(main):001:0> Time.at(0).utc\n=> 1970-01-01 00:00:00 UTC\n", "target": "using System;\n\nclass Program\n{\n    static void Main()\n    {\n        Console.WriteLine(new DateTime());\n    }\n}\n"}
{"id": 30026, "name": "Show the epoch", "source": "Translate Ruby to Java: irb(main):001:0> Time.at(0).utc\n=> 1970-01-01 00:00:00 UTC\n", "target": "import java.text.DateFormat;\nimport java.util.Date;\nimport java.util.TimeZone;\n\npublic class DateTest{\n    public static void main(String[] args) {\n        Date date = new Date(0);\n        DateFormat format = DateFormat.getDateTimeInstance();\n        format.setTimeZone(TimeZone.getTimeZone(\"UTC\"));\n        System.out.println(format.format(date));\n    }\n}\n"}
{"id": 30027, "name": "Show the epoch", "source": "Translate Ruby to Java: irb(main):001:0> Time.at(0).utc\n=> 1970-01-01 00:00:00 UTC\n", "target": "import java.text.DateFormat;\nimport java.util.Date;\nimport java.util.TimeZone;\n\npublic class DateTest{\n    public static void main(String[] args) {\n        Date date = new Date(0);\n        DateFormat format = DateFormat.getDateTimeInstance();\n        format.setTimeZone(TimeZone.getTimeZone(\"UTC\"));\n        System.out.println(format.format(date));\n    }\n}\n"}
{"id": 30028, "name": "Show the epoch", "source": "Translate Ruby to Python: irb(main):001:0> Time.at(0).utc\n=> 1970-01-01 00:00:00 UTC\n", "target": ">>> import time\n>>> time.asctime(time.gmtime(0))\n'Thu Jan  1 00:00:00 1970'\n>>>\n"}
{"id": 30029, "name": "Show the epoch", "source": "Translate Ruby to Python: irb(main):001:0> Time.at(0).utc\n=> 1970-01-01 00:00:00 UTC\n", "target": ">>> import time\n>>> time.asctime(time.gmtime(0))\n'Thu Jan  1 00:00:00 1970'\n>>>\n"}
{"id": 30331, "name": "File size", "source": "Translate Ruby to C#: size = File.size('input.txt')\nsize = File.size('/input.txt')\n", "target": "using System;\nusing System.IO;\n\nclass Program\n{\n    static void Main(string[] args)\n    {\n        Console.WriteLine(new FileInfo(\"/input.txt\").Length);\n        Console.WriteLine(new FileInfo(\"input.txt\").Length);\n    }\n}\n"}
{"id": 30333, "name": "File size", "source": "Translate Ruby to Java: size = File.size('input.txt')\nsize = File.size('/input.txt')\n", "target": "import java.io.File;\n\npublic class FileSize\n{\n    public static void main ( String[] args )\n    {\n        System.out.println(\"input.txt \u00a0: \" + new File(\"input.txt\").length() + \" bytes\");\n        System.out.println(\"/input.txt\u00a0: \" + new File(\"/input.txt\").length() + \" bytes\");\n    }\n}\n"}
{"id": 30334, "name": "File size", "source": "Translate Ruby to Python: size = File.size('input.txt')\nsize = File.size('/input.txt')\n", "target": "import os\n\nsize = os.path.getsize('input.txt')\nsize = os.path.getsize('/input.txt')\n"}
{"id": 30463, "name": "Rosetta Code_Find unimplemented tasks", "source": "Translate Ruby to C#: require 'rosettacode'\nrequire 'time'\n\nmodule RosettaCode\n  def self.get_unimplemented(lang)\n    programming_tasks = []\n    category_members(\"Programming_Tasks\") {|task| programming_tasks << task}\n\n    lang_tasks = []\n    category_members(lang) {|task| lang_tasks << task}\n\n    lang_tasks_omit = []\n    category_members(\"\n\n    [programming_tasks - lang_tasks, lang_tasks_omit]\n  end\n\n  def self.created_time(title)\n    url = get_api_url({\n      \"action\" => \"query\",\n      \"titles\" => title,\n      \"format\" => \"xml\",\n      \"rvlimit\" => 500,\n      \"prop\" => \"revisions\",\n      \"rvprop\" => \"timestamp\"\n    })\n    doc = REXML::Document.new open(url)\n    REXML::XPath.each(doc, \"//rev\").collect do |node| \n      Time.parse( node.attribute(\"timestamp\").value )\n    end.min \n  end\n\nend\n\nputs Time.now\nlang = ARGV[0] || \"Ruby\"\nunimplemented, omitted = RosettaCode.get_unimplemented(lang)\nunimplemented.collect {|title| [title, RosettaCode.created_time(title)]} .\n              sort_by {|e| e[1]} .\n              each do |title, date|\n                puts \"%s %6s %s\" % [\n                  date.strftime(\"%Y-%m-%d\"), \n                  omitted.include?(title) ? \"[omit]\" : \"\" ,\n                  title\n                ]\n              end\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text.RegularExpressions;\nusing System.Net;\n\nclass Program {\n    static List<string> GetTitlesFromCategory(string category) {\n        string searchQueryFormat = \"http:\n        List<string> results = new List<string>();\n        string cmcontinue = string.Empty;\n\n        do {\n            string cmContinueKeyValue;\n\n            \n            if (cmcontinue.Length > 0)\n                cmContinueKeyValue = String.Format(\"&cmcontinue={0}\", cmcontinue);\n            else\n                cmContinueKeyValue = String.Empty;\n\n            \n            string query = String.Format(searchQueryFormat, category, cmContinueKeyValue);\n            string content = new WebClient().DownloadString(query);\n\n            results.AddRange(new Regex(\"\\\"title\\\":\\\"(.+?)\\\"\").Matches(content).Cast<Match>().Select(x => x.Groups[1].Value));\n\n            \n            cmcontinue = Regex.Match(content, @\"{\"\"cmcontinue\"\":\"\"([^\"\"]+)\"\"}\", RegexOptions.IgnoreCase).Groups[\"1\"].Value;                \n        } while (cmcontinue.Length > 0);\n\n        return results;\n    }\n\n    static string[] GetUnimplementedTasksFromLanguage(string language) {\n        List<string> alltasks = GetTitlesFromCategory(\"Programming_Tasks\");\n        List<string> lang = GetTitlesFromCategory(language);\n\n        return alltasks.Where(x => !lang.Contains(x)).ToArray();\n    }\n\n    static void Main(string[] args) {\n        string[] unimpl = GetUnimplementedTasksFromLanguage(args[0]);\n\n        foreach (string i in unimpl) Console.WriteLine(i);\n    }\n}\n"}
{"id": 30464, "name": "Rosetta Code_Find unimplemented tasks", "source": "Translate Ruby to Python: require 'rosettacode'\nrequire 'time'\n\nmodule RosettaCode\n  def self.get_unimplemented(lang)\n    programming_tasks = []\n    category_members(\"Programming_Tasks\") {|task| programming_tasks << task}\n\n    lang_tasks = []\n    category_members(lang) {|task| lang_tasks << task}\n\n    lang_tasks_omit = []\n    category_members(\"\n\n    [programming_tasks - lang_tasks, lang_tasks_omit]\n  end\n\n  def self.created_time(title)\n    url = get_api_url({\n      \"action\" => \"query\",\n      \"titles\" => title,\n      \"format\" => \"xml\",\n      \"rvlimit\" => 500,\n      \"prop\" => \"revisions\",\n      \"rvprop\" => \"timestamp\"\n    })\n    doc = REXML::Document.new open(url)\n    REXML::XPath.each(doc, \"//rev\").collect do |node| \n      Time.parse( node.attribute(\"timestamp\").value )\n    end.min \n  end\n\nend\n\nputs Time.now\nlang = ARGV[0] || \"Ruby\"\nunimplemented, omitted = RosettaCode.get_unimplemented(lang)\nunimplemented.collect {|title| [title, RosettaCode.created_time(title)]} .\n              sort_by {|e| e[1]} .\n              each do |title, date|\n                puts \"%s %6s %s\" % [\n                  date.strftime(\"%Y-%m-%d\"), \n                  omitted.include?(title) ? \"[omit]\" : \"\" ,\n                  title\n                ]\n              end\n", "target": "\nfrom operator import attrgetter\nfrom typing import Iterator\n\nimport mwclient\n\nURL = 'www.rosettacode.org'\nAPI_PATH = '/mw/'\n\n\ndef unimplemented_tasks(language: str,\n                        *,\n                        url: str,\n                        api_path: str) -> Iterator[str]:\n    \n    site = mwclient.Site(url, path=api_path)\n    all_tasks = site.categories['Programming Tasks']\n    language_tasks = site.categories[language]\n    name = attrgetter('name')\n    all_tasks_names = map(name, all_tasks)\n    language_tasks_names = set(map(name, language_tasks))\n    for task in all_tasks_names:\n        if task not in language_tasks_names:\n            yield task\n\n\nif __name__ == '__main__':\n    tasks = unimplemented_tasks('Python', url=URL, api_path=API_PATH)\n    print(*tasks, sep='\\n')\n"}
{"id": 30644, "name": "Sorting algorithms_Sleep sort", "source": "Translate Ruby to C#: require 'thread'\n\nnums = ARGV.collect(&:to_i)\nsorted = []\nmutex = Mutex.new\n\nthreads = nums.collect do |n|\n  Thread.new do\n    sleep 0.01 * n\n    mutex.synchronize {sorted << n}\n  end\nend\nthreads.each {|t| t.join}\n\np sorted\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Threading;\n\nclass Program\n{\n    static void ThreadStart(object item)\n    {\n        Thread.Sleep(1000 * (int)item);\n        Console.WriteLine(item);\n    }\n\n    static void SleepSort(IEnumerable<int> items)\n    {\n        foreach (var item in items)\n        {\n            new Thread(ThreadStart).Start(item);\n        }\n    }\n\n    static void Main(string[] arguments)\n    {\n        SleepSort(arguments.Select(int.Parse));\n    }\n}\n"}
{"id": 30646, "name": "Sorting algorithms_Sleep sort", "source": "Translate Ruby to Java: require 'thread'\n\nnums = ARGV.collect(&:to_i)\nsorted = []\nmutex = Mutex.new\n\nthreads = nums.collect do |n|\n  Thread.new do\n    sleep 0.01 * n\n    mutex.synchronize {sorted << n}\n  end\nend\nthreads.each {|t| t.join}\n\np sorted\n", "target": "import java.util.concurrent.CountDownLatch;\n\npublic class SleepSort {\n\tpublic static void sleepSortAndPrint(int[] nums) {\n\t\tfinal CountDownLatch doneSignal = new CountDownLatch(nums.length);\n\t\tfor (final int num : nums) {\n\t\t\tnew Thread(new Runnable() {\n\t\t\t\tpublic void run() {\n\t\t\t\t\tdoneSignal.countDown();\n\t\t\t\t\ttry {\n\t\t\t\t\t\tdoneSignal.await();\n\n\t\t\t\t\t\t\n\t\t\t\t\t\t\n\t\t\t\t\t\t\n\t\t\t\t\t\tThread.sleep(num * 1000);\n\t\t\t\t\t\tSystem.out.println(num);\n\t\t\t\t\t} catch (InterruptedException e) {\n\t\t\t\t\t\te.printStackTrace();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}).start();\n\t\t}\n\t}\n\tpublic static void main(String[] args) {\n\t\tint[] nums = new int[args.length];\n\t\tfor (int i = 0; i < args.length; i++)\n\t\t\tnums[i] = Integer.parseInt(args[i]);\n\t\tsleepSortAndPrint(nums);\n\t}\n}\n"}
{"id": 30647, "name": "Sorting algorithms_Sleep sort", "source": "Translate Ruby to Python: require 'thread'\n\nnums = ARGV.collect(&:to_i)\nsorted = []\nmutex = Mutex.new\n\nthreads = nums.collect do |n|\n  Thread.new do\n    sleep 0.01 * n\n    mutex.synchronize {sorted << n}\n  end\nend\nthreads.each {|t| t.join}\n\np sorted\n", "target": "from time import sleep\nfrom threading import Timer\n\ndef sleepsort(values):\n    sleepsort.result = []\n    def add1(x):\n        sleepsort.result.append(x)\n    mx = values[0]\n    for v in values:\n        if mx < v: mx = v\n        Timer(v, add1, [v]).start()\n    sleep(mx+1)\n    return sleepsort.result\n\nif __name__ == '__main__':\n    x = [3,2,4,7,3,6,9,1]\n    if sleepsort(x) == sorted(x):\n        print('sleep sort worked for:',x)\n    else:\n        print('sleep sort FAILED for:',x)\n"}
{"id": 30942, "name": "Random number generator (device)", "source": "Translate Ruby to C#: require 'securerandom'\nSecureRandom.random_number(1 << 32)\n\n\np (1..10).to_a.sample(3, random: SecureRandom) \n", "target": "using System;\nusing System.Security.Cryptography;\n\nprivate static int GetRandomInt()\n{\n  int result = 0;\n  var rng = new RNGCryptoServiceProvider();\n  var buffer = new byte[4];\n\n  rng.GetBytes(buffer);\n  result = BitConverter.ToInt32(buffer, 0);\n\n  return result;\n}\n"}
{"id": 30943, "name": "Random number generator (device)", "source": "Translate Ruby to C#: require 'securerandom'\nSecureRandom.random_number(1 << 32)\n\n\np (1..10).to_a.sample(3, random: SecureRandom) \n", "target": "using System;\nusing System.Security.Cryptography;\n\nprivate static int GetRandomInt()\n{\n  int result = 0;\n  var rng = new RNGCryptoServiceProvider();\n  var buffer = new byte[4];\n\n  rng.GetBytes(buffer);\n  result = BitConverter.ToInt32(buffer, 0);\n\n  return result;\n}\n"}
{"id": 30946, "name": "Random number generator (device)", "source": "Translate Ruby to Java: require 'securerandom'\nSecureRandom.random_number(1 << 32)\n\n\np (1..10).to_a.sample(3, random: SecureRandom) \n", "target": "import java.security.SecureRandom;\n\npublic class RandomExample {\n  public static void main(String[] args) {\n    SecureRandom rng = new SecureRandom();\n\n    \n    System.out.println(rng.nextInt());\n  }\n}\n"}
{"id": 30947, "name": "Random number generator (device)", "source": "Translate Ruby to Java: require 'securerandom'\nSecureRandom.random_number(1 << 32)\n\n\np (1..10).to_a.sample(3, random: SecureRandom) \n", "target": "import java.security.SecureRandom;\n\npublic class RandomExample {\n  public static void main(String[] args) {\n    SecureRandom rng = new SecureRandom();\n\n    \n    System.out.println(rng.nextInt());\n  }\n}\n"}
{"id": 30948, "name": "Random number generator (device)", "source": "Translate Ruby to Python: require 'securerandom'\nSecureRandom.random_number(1 << 32)\n\n\np (1..10).to_a.sample(3, random: SecureRandom) \n", "target": "import random\nrand = random.SystemRandom()\nrand.randint(1,10)\n"}
{"id": 30949, "name": "Random number generator (device)", "source": "Translate Ruby to Python: require 'securerandom'\nSecureRandom.random_number(1 << 32)\n\n\np (1..10).to_a.sample(3, random: SecureRandom) \n", "target": "import random\nrand = random.SystemRandom()\nrand.randint(1,10)\n"}
{"id": 31072, "name": "RSA code", "source": "Translate Ruby to C#: \n\nrequire 'openssl' \nrequire 'prime'\n\ndef rsa_encode blocks, e, n\n  blocks.map{|b| b.to_bn.mod_exp(e, n).to_i}\nend\n\ndef rsa_decode ciphers, d, n\n  rsa_encode ciphers, d, n\nend\n\n\n\ndef text_to_blocks text, blocksize=64 \n  text.each_byte.reduce(\"\"){|acc,b| acc << b.to_s(16).rjust(2, \"0\")} \n      .each_char.each_slice(blocksize).to_a                          \n      .map{|a| a.join(\"\").to_i(16)}                                  \nend\n\ndef blocks_to_text blocks\n  blocks.map{|d| d.to_s(16)}.join(\"\")                                \n        .each_char.each_slice(2).to_a                                \n\t.map{|s| s.join(\"\").to_i(16)}                                \n\t.flatten.pack(\"C*\")                                          \n\t.force_encoding(Encoding::default_external)                  \nend\n\ndef generate_keys p1, p2\n  n = p1 * p2\n  t = (p1 - 1) * (p2 - 1)\n  e = 2.step.each do |i|\n    break i if i.gcd(t) == 1\n  end\n  d = 1.step.each do |i|\n    break i if (i * e) % t == 1\n  end\n  return e, d, n\nend\n\np1, p2 = Prime.take(100).last(2)\npublic_key, private_key, modulus =\n  generate_keys p1, p2\n\nprint \"Message: \"\nmessage = gets\nblocks = text_to_blocks message, 4 \nprint \"Numbers: \"; p blocks\nencoded = rsa_encode(blocks, public_key, modulus)\nprint \"Encrypted as: \"; p encoded\ndecoded = rsa_decode(encoded, private_key, modulus)\nprint \"Decrypted to: \"; p decoded\nfinal = blocks_to_text(decoded)\nprint \"Decrypted Message: \"; puts final\n", "target": "using System;\nusing System.Numerics;\nusing System.Text;\n\nclass Program\n{\n    static void Main(string[] args)\n    {\n        BigInteger n = BigInteger.Parse(\"9516311845790656153499716760847001433441357\");\n        BigInteger e = 65537;\n        BigInteger d = BigInteger.Parse(\"5617843187844953170308463622230283376298685\");\n\n        const string plaintextstring = \"Hello, Rosetta!\";\n        byte[] plaintext = ASCIIEncoding.ASCII.GetBytes(plaintextstring);\n        BigInteger pt = new BigInteger(plaintext);\n        if (pt > n)\n            throw new Exception();\n\n        BigInteger ct = BigInteger.ModPow(pt, e, n);\n        Console.WriteLine(\"Encoded:  \" + ct);\n\n        BigInteger dc = BigInteger.ModPow(ct, d, n);\n        Console.WriteLine(\"Decoded:  \" + dc);\n\n        string decoded = ASCIIEncoding.ASCII.GetString(dc.ToByteArray());\n        Console.WriteLine(\"As ASCII: \" + decoded);\n    }\n}\n"}
{"id": 31073, "name": "RSA code", "source": "Translate Ruby to Java: \n\nrequire 'openssl' \nrequire 'prime'\n\ndef rsa_encode blocks, e, n\n  blocks.map{|b| b.to_bn.mod_exp(e, n).to_i}\nend\n\ndef rsa_decode ciphers, d, n\n  rsa_encode ciphers, d, n\nend\n\n\n\ndef text_to_blocks text, blocksize=64 \n  text.each_byte.reduce(\"\"){|acc,b| acc << b.to_s(16).rjust(2, \"0\")} \n      .each_char.each_slice(blocksize).to_a                          \n      .map{|a| a.join(\"\").to_i(16)}                                  \nend\n\ndef blocks_to_text blocks\n  blocks.map{|d| d.to_s(16)}.join(\"\")                                \n        .each_char.each_slice(2).to_a                                \n\t.map{|s| s.join(\"\").to_i(16)}                                \n\t.flatten.pack(\"C*\")                                          \n\t.force_encoding(Encoding::default_external)                  \nend\n\ndef generate_keys p1, p2\n  n = p1 * p2\n  t = (p1 - 1) * (p2 - 1)\n  e = 2.step.each do |i|\n    break i if i.gcd(t) == 1\n  end\n  d = 1.step.each do |i|\n    break i if (i * e) % t == 1\n  end\n  return e, d, n\nend\n\np1, p2 = Prime.take(100).last(2)\npublic_key, private_key, modulus =\n  generate_keys p1, p2\n\nprint \"Message: \"\nmessage = gets\nblocks = text_to_blocks message, 4 \nprint \"Numbers: \"; p blocks\nencoded = rsa_encode(blocks, public_key, modulus)\nprint \"Encrypted as: \"; p encoded\ndecoded = rsa_decode(encoded, private_key, modulus)\nprint \"Decrypted to: \"; p decoded\nfinal = blocks_to_text(decoded)\nprint \"Decrypted Message: \"; puts final\n", "target": "public static void main(String[] args) {\n    \n    BigInteger n = new BigInteger(\"9516311845790656153499716760847001433441357\");\n    BigInteger e = new BigInteger(\"65537\");\n    BigInteger d = new BigInteger(\"5617843187844953170308463622230283376298685\");\n    Charset c = Charsets.UTF_8;\n    String plainText = \"Rosetta Code\";\n    System.out.println(\"PlainText\u00a0: \" + plainText);\n    byte[] bytes = plainText.getBytes();\n    BigInteger plainNum = new BigInteger(bytes);\n    System.out.println(\"As number\u00a0: \" + plainNum);\n    BigInteger Bytes = new BigInteger(bytes);\n    if (Bytes.compareTo(n) == 1) {\n        System.out.println(\"Plaintext is too long\");\n        return;\n    }\n    BigInteger enc = plainNum.modPow(e, n);\n    System.out.println(\"Encoded: \" + enc);\n    BigInteger dec = enc.modPow(d, n);\n    System.out.println(\"Decoded: \" + dec);\n    String decText = new String(dec.toByteArray(), c);\n    System.out.println(\"As text: \" + decText);\n}\n"}
{"id": 31074, "name": "RSA code", "source": "Translate Ruby to Python: \n\nrequire 'openssl' \nrequire 'prime'\n\ndef rsa_encode blocks, e, n\n  blocks.map{|b| b.to_bn.mod_exp(e, n).to_i}\nend\n\ndef rsa_decode ciphers, d, n\n  rsa_encode ciphers, d, n\nend\n\n\n\ndef text_to_blocks text, blocksize=64 \n  text.each_byte.reduce(\"\"){|acc,b| acc << b.to_s(16).rjust(2, \"0\")} \n      .each_char.each_slice(blocksize).to_a                          \n      .map{|a| a.join(\"\").to_i(16)}                                  \nend\n\ndef blocks_to_text blocks\n  blocks.map{|d| d.to_s(16)}.join(\"\")                                \n        .each_char.each_slice(2).to_a                                \n\t.map{|s| s.join(\"\").to_i(16)}                                \n\t.flatten.pack(\"C*\")                                          \n\t.force_encoding(Encoding::default_external)                  \nend\n\ndef generate_keys p1, p2\n  n = p1 * p2\n  t = (p1 - 1) * (p2 - 1)\n  e = 2.step.each do |i|\n    break i if i.gcd(t) == 1\n  end\n  d = 1.step.each do |i|\n    break i if (i * e) % t == 1\n  end\n  return e, d, n\nend\n\np1, p2 = Prime.take(100).last(2)\npublic_key, private_key, modulus =\n  generate_keys p1, p2\n\nprint \"Message: \"\nmessage = gets\nblocks = text_to_blocks message, 4 \nprint \"Numbers: \"; p blocks\nencoded = rsa_encode(blocks, public_key, modulus)\nprint \"Encrypted as: \"; p encoded\ndecoded = rsa_decode(encoded, private_key, modulus)\nprint \"Decrypted to: \"; p decoded\nfinal = blocks_to_text(decoded)\nprint \"Decrypted Message: \"; puts final\n", "target": "import binascii\n\nn = 9516311845790656153499716760847001433441357    \ne = 65537\nd = 5617843187844953170308463622230283376298685\n\nmessage='Rosetta Code!'\nprint('message                 ', message)\n\nhex_data   = binascii.hexlify(message.encode())\nprint('hex data                ', hex_data)\n\nplain_text = int(hex_data, 16)\nprint('plain text integer      ', plain_text)\n\nif plain_text > n:\n  raise Exception('plain text too large for key')\n\nencrypted_text = pow(plain_text,     e, n)\nprint('encrypted text integer  ', encrypted_text)\n\ndecrypted_text = pow(encrypted_text, d, n)\nprint('decrypted text integer  ', decrypted_text)\n\nprint('message                 ', binascii.unhexlify(hex(decrypted_text)[2:]).decode())     \n"}
{"id": 31219, "name": "Sort numbers lexicographically", "source": "Translate Ruby to C#: n = 13\np (1..n).sort_by(&:to_s)\n", "target": "using static System.Console;\nusing static System.Linq.Enumerable;\n\npublic class Program\n{\n    public static void Main() {\n        foreach (int n in new [] { 0, 5, 13, 21, -22 }) WriteLine($\"{n}: {string.Join(\", \", LexOrder(n))}\");\n    }\n\n    public static IEnumerable<int> LexOrder(int n) => (n < 1 ? Range(n, 2 - n) : Range(1, n)).OrderBy(i => i.ToString());\n}\n"}
{"id": 31221, "name": "Sort numbers lexicographically", "source": "Translate Ruby to Java: n = 13\np (1..n).sort_by(&:to_s)\n", "target": "import java.util.List;\nimport java.util.stream.*;\n\npublic class LexicographicalNumbers {\n\n    static List<Integer> lexOrder(int n) {\n        int first = 1, last = n;\n        if (n < 1) {\n            first = n;\n            last = 1;\n        }\n        return IntStream.rangeClosed(first, last)\n                        .mapToObj(Integer::toString)\n                        .sorted()\n                        .map(Integer::valueOf)\n                        .collect(Collectors.toList());\n    }\n\n    public static void main(String[] args) {\n        System.out.println(\"In lexicographical order:\\n\");\n        int[] ints = {0, 5, 13, 21, -22};\n        for (int n : ints) {\n           System.out.printf(\"%3d: %s\\n\", n, lexOrder(n));\n        }\n    }\n}\n"}
{"id": 31222, "name": "Sort numbers lexicographically", "source": "Translate Ruby to Python: n = 13\np (1..n).sort_by(&:to_s)\n", "target": "n=13\nprint(sorted(range(1,n+1), key=str))\n"}
{"id": 31539, "name": "Remove vowels from a string", "source": "Translate Ruby to C#: p \"Remove vowels from a string\".delete(\"aeiouAEIOU\") \n", "target": "static string remove_vowels(string value)\n{\n    var stripped = from c in value.ToCharArray()\n                   where !\"aeiouAEIOU\".Contains(c)\n                   select c;\n\n    return new string(stripped.ToArray());\n}\n\nstatic void test(string value)\n{\n    Console.WriteLine(\"Input:  \" + value);\n    Console.WriteLine(\"Output: \" + remove_vowels(value));\n}\n\nstatic void Main(string[] args)\n{\n    test(\"CSharp Programming Language\");\n}\n"}
{"id": 31540, "name": "Remove vowels from a string", "source": "Translate Ruby to C#: p \"Remove vowels from a string\".delete(\"aeiouAEIOU\") \n", "target": "static string remove_vowels(string value)\n{\n    var stripped = from c in value.ToCharArray()\n                   where !\"aeiouAEIOU\".Contains(c)\n                   select c;\n\n    return new string(stripped.ToArray());\n}\n\nstatic void test(string value)\n{\n    Console.WriteLine(\"Input:  \" + value);\n    Console.WriteLine(\"Output: \" + remove_vowels(value));\n}\n\nstatic void Main(string[] args)\n{\n    test(\"CSharp Programming Language\");\n}\n"}
{"id": 31542, "name": "Remove vowels from a string", "source": "Translate Ruby to Java: p \"Remove vowels from a string\".delete(\"aeiouAEIOU\") \n", "target": "public static String removeVowelse(String str){\n    String re = \"\";\n    char c;\n    for(int x = 0; x<str.length(); x++){\n        c = str.charAt(x);\n        if(!(c=='a'||c=='e'||c=='i'||c=='o'||c=='u'))\n        re+=c;\n    }\n    return re;\n}\n"}
{"id": 31543, "name": "Remove vowels from a string", "source": "Translate Ruby to Java: p \"Remove vowels from a string\".delete(\"aeiouAEIOU\") \n", "target": "public static String removeVowelse(String str){\n    String re = \"\";\n    char c;\n    for(int x = 0; x<str.length(); x++){\n        c = str.charAt(x);\n        if(!(c=='a'||c=='e'||c=='i'||c=='o'||c=='u'))\n        re+=c;\n    }\n    return re;\n}\n"}
{"id": 31544, "name": "Remove vowels from a string", "source": "Translate Ruby to Python: p \"Remove vowels from a string\".delete(\"aeiouAEIOU\") \n", "target": "\n\n\n\ndef exceptGlyphs(exclusions):\n    \n    def go(s):\n        return ''.join(\n            c for c in s if c not in exclusions\n        )\n    return go\n\n\n\n\ndef main():\n    \n\n    txt = \n\n    print(\n        exceptGlyphs('eau')(txt)\n    )\n\n\n\nif __name__ == '__main__':\n    main()\n"}
{"id": 31545, "name": "Remove vowels from a string", "source": "Translate Ruby to Python: p \"Remove vowels from a string\".delete(\"aeiouAEIOU\") \n", "target": "\n\n\n\ndef exceptGlyphs(exclusions):\n    \n    def go(s):\n        return ''.join(\n            c for c in s if c not in exclusions\n        )\n    return go\n\n\n\n\ndef main():\n    \n\n    txt = \n\n    print(\n        exceptGlyphs('eau')(txt)\n    )\n\n\n\nif __name__ == '__main__':\n    main()\n"}
{"id": 31787, "name": "Forward difference", "source": "Translate Ruby to C#: def dif(s)\n  s.each_cons(2).collect { |x, y| y - x }\nend\n\ndef difn(s, n)\n  n.times.inject(s) { |s, | dif(s) }\nend\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\nclass Program\n{\n    static IEnumerable<int> ForwardDifference(IEnumerable<int> sequence, uint order = 1u)\n    {\n        switch (order)\n        {\n            case 0u:\n                return sequence;\n            case 1u:\n                return sequence.Skip(1).Zip(sequence, (next, current) => next - current);\n            default:\n                return ForwardDifference(ForwardDifference(sequence), order - 1u);\n        }\n    }\n\n    static void Main()\n    {\n        IEnumerable<int> sequence = new[] { 90, 47, 58, 29, 22, 32, 55, 5, 55, 73 };\n        do\n        {\n            Console.WriteLine(string.Join(\", \", sequence));\n        } while ((sequence = ForwardDifference(sequence)).Any());\n    }\n}\n"}
{"id": 31789, "name": "Forward difference", "source": "Translate Ruby to Java: def dif(s)\n  s.each_cons(2).collect { |x, y| y - x }\nend\n\ndef difn(s, n)\n  n.times.inject(s) { |s, | dif(s) }\nend\n", "target": "import java.util.Arrays;\npublic class FD {\n    public static void main(String args[]) {\n        double[] a = {90, 47, 58, 29, 22, 32, 55, 5, 55, 73};\n        System.out.println(Arrays.toString(dif(a, 1)));\n        System.out.println(Arrays.toString(dif(a, 2)));\n        System.out.println(Arrays.toString(dif(a, 9)));\n        System.out.println(Arrays.toString(dif(a, 10)));      \n        System.out.println(Arrays.toString(dif(a, 11)));\n        System.out.println(Arrays.toString(dif(a, -1)));\n        System.out.println(Arrays.toString(dif(a, 0)));\n    }\n\n    public static double[] dif(double[] a, int n) {\n        if (n < 0)\n            return null; \n\n        for (int i = 0; i < n && a.length > 0; i++) {\n            double[] b = new double[a.length - 1];\n            for (int j = 0; j < b.length; j++){\n                b[j] = a[j+1] - a[j];\n            }\n            a = b; \n        }\n        return a;\n    }\n}\n"}
{"id": 31790, "name": "Forward difference", "source": "Translate Ruby to Python: def dif(s)\n  s.each_cons(2).collect { |x, y| y - x }\nend\n\ndef difn(s, n)\n  n.times.inject(s) { |s, | dif(s) }\nend\n", "target": ">>> dif = lambda s: [x-s[i] for i,x in enumerate(s[1:])]\n>>> \n>>> difn = lambda s, n: difn(dif(s), n-1) if n else s\n\n>>> s = [90, 47, 58, 29, 22, 32, 55, 5, 55, 73]\n>>> difn(s, 0)\n[90, 47, 58, 29, 22, 32, 55, 5, 55, 73]\n>>> difn(s, 1)\n[-43, 11, -29, -7, 10, 23, -50, 50, 18]\n>>> difn(s, 2)\n[54, -40, 22, 17, 13, -73, 100, -32]\n\n>>> from pprint import pprint\n>>> pprint( [difn(s, i) for i in xrange(10)] )\n[[90, 47, 58, 29, 22, 32, 55, 5, 55, 73],\n [-43, 11, -29, -7, 10, 23, -50, 50, 18],\n [54, -40, 22, 17, 13, -73, 100, -32],\n [-94, 62, -5, -4, -86, 173, -132],\n [156, -67, 1, -82, 259, -305],\n [-223, 68, -83, 341, -564],\n [291, -151, 424, -905],\n [-442, 575, -1329],\n [1017, -1904],\n [-2921]]\n"}
{"id": 32050, "name": "Guess the number_With feedback", "source": "Translate Ruby to C#: number = rand(1..10)\n\nputs \"Guess the number between 1 and 10\"\n\nloop do\n  begin\n    user_number = gets.to_s.to_i\n    if user_number == number\n      puts \"You guessed it.\"\n      break\n    elsif user_number > number  \n      puts \"Too high.\"\n    else\n      puts \"Too low.\"\n    end\n  rescue ArgumentError\n    puts \"Please enter an integer.\"\n  end\nend\n", "target": "using System;\n\nclass Program\n{\n    static void Main(string[] args)\n    {\n        const int from = 1;\n        const int to = 10;\n\n        int randomNumber = new Random().Next(from, to);\n        int guessedNumber;\n\n        Console.Write(\"The number is between {0} and {1}. \", from, to);\n        while (true)\n        {\n            Console.Write(\"Make a guess: \");\n            if (int.TryParse(Console.ReadLine(), out guessedNumber))\n            {\n                if (guessedNumber == randomNumber)\n                {\n                    Console.WriteLine(\"You guessed the right number!\");\n                    break;\n                }\n                else\n                {\n                    Console.WriteLine(\"Your guess was too {0}.\", (guessedNumber > randomNumber) ? \"high\" : \"low\");\n                }\n            }\n            else\n            {\n                Console.WriteLine(\"Input was not an integer.\");\n            }\n        }\n\n        Console.WriteLine();\n        Console.WriteLine(\"Press any key to exit.\");\n        Console.ReadKey();\n    }\n}\n"}
{"id": 32052, "name": "Guess the number_With feedback", "source": "Translate Ruby to Java: number = rand(1..10)\n\nputs \"Guess the number between 1 and 10\"\n\nloop do\n  begin\n    user_number = gets.to_s.to_i\n    if user_number == number\n      puts \"You guessed it.\"\n      break\n    elsif user_number > number  \n      puts \"Too high.\"\n    else\n      puts \"Too low.\"\n    end\n  rescue ArgumentError\n    puts \"Please enter an integer.\"\n  end\nend\n", "target": "import java.util.Random;\nimport java.util.Scanner;\npublic class Main\n{\n    public static void main(String[] args)\n    {\n        Scanner scan = new Scanner(System.in);\n        Random random = new Random();\n        long from = 1;\n        long to = 100;\n        int randomNumber = random.nextInt(to - from + 1) + from;\n        int guessedNumber = 0;\n\n        System.out.printf(\"The number is between %d and %d.\\n\", from, to);\n\n        do\n        {\n            System.out.print(\"Guess what the number is: \");\n            guessedNumber = scan.nextInt();\n            if (guessedNumber > randomNumber)\n                System.out.println(\"Your guess is too high!\");\n            else if (guessedNumber < randomNumber)\n                System.out.println(\"Your guess is too low!\");\n            else\n                System.out.println(\"You got it!\");\n        } while (guessedNumber != randomNumber);\n    }\n}\n"}
{"id": 32053, "name": "Guess the number_With feedback", "source": "Translate Ruby to Python: number = rand(1..10)\n\nputs \"Guess the number between 1 and 10\"\n\nloop do\n  begin\n    user_number = gets.to_s.to_i\n    if user_number == number\n      puts \"You guessed it.\"\n      break\n    elsif user_number > number  \n      puts \"Too high.\"\n    else\n      puts \"Too low.\"\n    end\n  rescue ArgumentError\n    puts \"Please enter an integer.\"\n  end\nend\n", "target": "import random\n\ninclusive_range = (1, 100)\n\nprint(\"Guess my target number that is between %i and %i (inclusive).\\n\"\n      % inclusive_range)\ntarget = random.randint(*inclusive_range)\nanswer, i = None, 0\nwhile answer != target:\n    i += 1\n    txt = input(\"Your guess(%i): \" % i)\n    try:\n        answer = int(txt)\n    except ValueError:\n        print(\"  I don't understand your input of '%s'\u00a0?\" % txt)\n        continue\n    if answer < inclusive_range[0] or answer > inclusive_range[1]:\n        print(\"  Out of range!\")\n        continue\n    if answer == target:\n        print(\"  Ye-Haw!!\")\n        break\n    if answer < target: print(\"  Too low.\")\n    if answer > target: print(\"  Too high.\")\n\nprint(\"\\nThanks for playing.\")\n"}
{"id": 32292, "name": "Compound data type", "source": "Translate Ruby to C#: struct Point(T)\n  getter x : T\n  getter y : T\n  def initialize(@x, @y)\n  end \nend\n\nputs Point(Int32).new 13, 12  \n", "target": "struct Point\n{\n  public int x, y;\n  public Point(int x, int y) {\n    this.x = x;\n    this.y = y;\n  }\n}\n"}
{"id": 32294, "name": "Compound data type", "source": "Translate Ruby to Java: struct Point(T)\n  getter x : T\n  getter y : T\n  def initialize(@x, @y)\n  end \nend\n\nputs Point(Int32).new 13, 12  \n", "target": "public class Point\n{\n  public int x, y;\n  public Point() { this(0); }\n  public Point(int x0) { this(x0,0); }\n  public Point(int x0, int y0) { x = x0; y = y0; }\n\n  public static void main(String args[])\n  {\n    Point point = new Point(1,2);\n    System.out.println(\"x = \" + point.x );\n    System.out.println(\"y = \" + point.y );\n  }\n}\n"}
{"id": 32295, "name": "Compound data type", "source": "Translate Ruby to Python: struct Point(T)\n  getter x : T\n  getter y : T\n  def initialize(@x, @y)\n  end \nend\n\nputs Point(Int32).new 13, 12  \n", "target": "X, Y = 0, 1\np = (3, 4)\np = [3, 4]\n\nprint p[X]\n"}
{"id": 32559, "name": "Sorting algorithms_Bogosort", "source": "Translate Ruby to C#: def shuffle(l)\n    l.sort_by { rand }\nend\n\ndef bogosort(l)\n    l = shuffle(l) until in_order(l)\n    l\nend\n\ndef in_order(l)\n    (0..l.length-2).all? {|i| l[i] <= l[i+1] }\nend\n", "target": "using System;\nusing System.Collections.Generic;\n\nnamespace RosettaCode.BogoSort\n{\n    public static class BogoSorter\n    {\n        public static void Sort<T>(List<T> list) where T:IComparable\n        {\n            while (!list.isSorted())\n            {\n                list.Shuffle();\n            }\n        }\n\n        private static bool isSorted<T>(this IList<T> list) where T:IComparable\n        {\n            if(list.Count<=1)\n                return true;\n            for (int i = 1 ; i < list.Count; i++)\n                if(list[i].CompareTo(list[i-1])<0) return false;\n            return true;\n        }\n\n        private static void Shuffle<T>(this IList<T> list)\n        {\n            Random rand = new Random();\n            for (int i = 0; i < list.Count; i++)\n            {\n                int swapIndex = rand.Next(list.Count);\n                T temp = list[swapIndex];\n                list[swapIndex] = list[i];\n                list[i] = temp;\n            }\n        }\n    }\n\n    class TestProgram\n    {\n        static void Main()\n        {\n            List<int> testList = new List<int> { 3, 4, 1, 8, 7, 4, -2 };\n            BogoSorter.Sort(testList);\n            foreach (int i in testList) Console.Write(i + \" \");\n        }\n\n    }\n}\n"}
{"id": 32561, "name": "Sorting algorithms_Bogosort", "source": "Translate Ruby to Java: def shuffle(l)\n    l.sort_by { rand }\nend\n\ndef bogosort(l)\n    l = shuffle(l) until in_order(l)\n    l\nend\n\ndef in_order(l)\n    (0..l.length-2).all? {|i| l[i] <= l[i+1] }\nend\n", "target": "public class BogoSort \n{\n\tpublic static void main(String[] args)\n\t{\n\t\t\n\t\tint[] arr={4,5,6,0,7,8,9,1,2,3};\n\t\t\n\t\tBogoSort now=new BogoSort();\n\t\tSystem.out.print(\"Unsorted: \");\n\t\tnow.display1D(arr);\n\t\t\n\t\tnow.bogo(arr);\n\t\t\n\t\tSystem.out.print(\"Sorted: \");\n\t\tnow.display1D(arr);\n\t}\n\tvoid bogo(int[] arr)\n\t{\n\t\t\n\t\tint shuffle=1;\n\t\tfor(;!isSorted(arr);shuffle++)\n\t\t\tshuffle(arr);\n\t\t\n\t\tSystem.out.println(\"This took \"+shuffle+\" shuffles.\");\n\t}\n\tvoid shuffle(int[] arr)\n\t{\n\t\t\n\t\tint i=arr.length-1;\n\t\twhile(i>0)\n\t\t\tswap(arr,i--,(int)(Math.random()*i));\n\t}\n\tvoid swap(int[] arr,int i,int j)\n\t{\n\t\tint temp=arr[i];\n\t\tarr[i]=arr[j];\n\t\tarr[j]=temp;\n\t}\n\tboolean isSorted(int[] arr)\n\t{\n\n\t\tfor(int i=1;i<arr.length;i++)\n\t\t\tif(arr[i]<arr[i-1])\n\t\t\t\treturn false;\n\t\treturn true;\n\t}\n\tvoid display1D(int[] arr)\n\t{\n\t\tfor(int i=0;i<arr.length;i++)\n\t\t\tSystem.out.print(arr[i]+\" \");\n\t\tSystem.out.println();\n\t}\n\n}\n"}
{"id": 32562, "name": "Sorting algorithms_Bogosort", "source": "Translate Ruby to Python: def shuffle(l)\n    l.sort_by { rand }\nend\n\ndef bogosort(l)\n    l = shuffle(l) until in_order(l)\n    l\nend\n\ndef in_order(l)\n    (0..l.length-2).all? {|i| l[i] <= l[i+1] }\nend\n", "target": "import random\n\ndef bogosort(l):\n    while not in_order(l):\n        random.shuffle(l)\n    return l\n\ndef in_order(l):\n    if not l:\n        return True\n    last = l[0]\n    for x in l[1:]:\n        if x < last:\n            return False\n        last = x\n    return True\n"}
{"id": 32829, "name": "Cumulative standard deviation", "source": "Translate Ruby to C#: class StdDevAccumulator\n  def initialize\n    @n, @sum, @sum2 = 0, 0.0, 0.0\n  end\n  \n  def <<(num)\n    @n += 1\n    @sum += num\n    @sum2 += num**2\n    Math.sqrt (@sum2 * @n - @sum**2) / @n**2\n  end\nend\n   \nsd = StdDevAccumulator.new\ni = 0\n[2,4,4,4,5,5,7,9].each { |n| puts \"adding \n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\nnamespace standardDeviation\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            List<double> nums = new List<double> { 2, 4, 4, 4, 5, 5, 7, 9 };\n            for (int i = 1; i <= nums.Count; i++)            \n                Console.WriteLine(sdev(nums.GetRange(0, i)));\n        }\n\n        static double sdev(List<double> nums)\n        {\n            List<double> store = new List<double>();\n            foreach (double n in nums)\n                store.Add((n - nums.Average()) * (n - nums.Average()));           \n\n            return Math.Sqrt(store.Sum() / store.Count);\n        }\n    }\n}\n"}
{"id": 32831, "name": "Cumulative standard deviation", "source": "Translate Ruby to Java: class StdDevAccumulator\n  def initialize\n    @n, @sum, @sum2 = 0, 0.0, 0.0\n  end\n  \n  def <<(num)\n    @n += 1\n    @sum += num\n    @sum2 += num**2\n    Math.sqrt (@sum2 * @n - @sum**2) / @n**2\n  end\nend\n   \nsd = StdDevAccumulator.new\ni = 0\n[2,4,4,4,5,5,7,9].each { |n| puts \"adding \n", "target": "public class StdDev {\n    int n = 0;\n    double sum = 0;\n    double sum2 = 0;\n\n    public double sd(double x) {\n\tn++;\n\tsum += x;\n\tsum2 += x*x;\n\n\treturn Math.sqrt(sum2/n - sum*sum/n/n);\n    }\n\n    public static void main(String[] args) {\n        double[] testData = {2,4,4,4,5,5,7,9};\n        StdDev sd = new StdDev();\n\n        for (double x : testData) {\n            System.out.println(sd.sd(x));\n        }\n    }\n}\n"}
{"id": 32832, "name": "Cumulative standard deviation", "source": "Translate Ruby to Python: class StdDevAccumulator\n  def initialize\n    @n, @sum, @sum2 = 0, 0.0, 0.0\n  end\n  \n  def <<(num)\n    @n += 1\n    @sum += num\n    @sum2 += num**2\n    Math.sqrt (@sum2 * @n - @sum**2) / @n**2\n  end\nend\n   \nsd = StdDevAccumulator.new\ni = 0\n[2,4,4,4,5,5,7,9].each { |n| puts \"adding \n", "target": ">>> from math import sqrt\n>>> def sd(x):\n    sd.sum  += x\n    sd.sum2 += x*x\n    sd.n    += 1.0\n    sum, sum2, n = sd.sum, sd.sum2, sd.n\n    return sqrt(sum2/n - sum*sum/n/n)\n\n>>> sd.sum = sd.sum2 = sd.n = 0\n>>> for value in (2,4,4,4,5,5,7,9):\n    print (value, sd(value))\n\n    \n(2, 0.0)\n(4, 1.0)\n(4, 0.94280904158206258)\n(4, 0.8660254037844386)\n(5, 0.97979589711327075)\n(5, 1.0)\n(7, 1.3997084244475311)\n(9, 2.0)\n>>>\n"}
{"id": 33110, "name": "Palindrome detection", "source": "Translate Ruby to C#: def palindrome(s)\n  s == s.reverse\nend\n", "target": "using System;\n\nclass Program\n{\n    static string Reverse(string value)\n    {\n        char[] chars = value.ToCharArray();\n        Array.Reverse(chars);\n        return new string(chars);\n    }\n\n    static bool IsPalindrome(string value)\n    {\n        return value == Reverse(value);\n    }\n\n    static void Main(string[] args)\n    {\n        Console.WriteLine(IsPalindrome(\"ingirumimusnocteetconsumimurigni\"));\n    }\n}\n"}
{"id": 33112, "name": "Palindrome detection", "source": "Translate Ruby to Java: def palindrome(s)\n  s == s.reverse\nend\n", "target": "public static boolean pali(String testMe){\n\tStringBuilder sb = new StringBuilder(testMe);\n\treturn testMe.equals(sb.reverse().toString());\n}\n"}
{"id": 33388, "name": "Loop over multiple arrays simultaneously", "source": "Translate Ruby to C#: ['a','b','c'].zip(['A','B','C'], [1,2,3]) {|i,j,k| puts \"\n", "target": "class Program\n{\n    static void Main(string[] args)\n    {\n        char[] a = { 'a', 'b', 'c' };\n        char[] b = { 'A', 'B', 'C' };\n        int[] c = { 1, 2, 3 };\n        int min = Math.Min(a.Length, b.Length);\n        min = Math.Min(min, c.Length);\n        for (int i = 0; i < min; i++)\n            Console.WriteLine(\"{0}{1}{2}\", a[i], b[i], c[i]);\n    }             \n}\n"}
{"id": 33390, "name": "Loop over multiple arrays simultaneously", "source": "Translate Ruby to Java: ['a','b','c'].zip(['A','B','C'], [1,2,3]) {|i,j,k| puts \"\n", "target": "module LoopOverMultipleArrays\n    {\n    @Inject Console console;\n\n    void run()\n        {\n        Char[]   chars   = ['a', 'b', 'c'];\n        String[] strings = [\"A\", \"B\", \"C\"];\n        Int[]    ints    = [ 1,   2,   3 ];\n\n        console.print(\"Using array indexing:\");\n        for (Int i = 0, Int longest = chars.size.maxOf(strings.size.maxOf(ints.size)); i < longest; ++i)\n            {\n            console.print($|{i < chars.size   ? chars[i].toString() : \"\"}\\\n                           |{i < strings.size ? strings[i]          : \"\"}\\\n                           |{i < ints.size    ? ints[i].toString()  : \"\"}\n                         );\n            }\n\n        console.print(\"\\nUsing array iterators:\");\n        val charIter   = chars.iterator();\n        val stringIter = strings.iterator();\n        val intIter    = ints.iterator();\n        while (True)\n            {\n            StringBuffer buf = new StringBuffer();\n            if (Char ch := charIter.next())\n                {\n                buf.add(ch);\n                }\n            if (String s := stringIter.next())\n                {\n                s.appendTo(buf);\n                }\n            if (Int n := intIter.next())\n                {\n                n.appendTo(buf);\n                }\n            if (buf.size == 0)\n                {\n                break;\n                }\n            console.print(buf);\n            }\n        }\n    }\n"}
{"id": 33391, "name": "Loop over multiple arrays simultaneously", "source": "Translate Ruby to Python: ['a','b','c'].zip(['A','B','C'], [1,2,3]) {|i,j,k| puts \"\n", "target": ">>> print ( '\\n'.join(''.join(x) for x in \nzip('abc', 'ABC', '123')) )\naA1\nbB2\ncC3\n>>>\n"}
{"id": 33639, "name": "Sorting algorithms_Cocktail sort", "source": "Translate Ruby to C#: class Array\n  def cocktailsort!\n    begin\n      swapped = false\n      0.upto(length - 2) do |i|\n        if self[i] > self[i + 1]\n          self[i], self[i + 1] = self[i + 1], self[i]\n          swapped = true\n        end\n      end\n      break unless swapped\n      \n      swapped = false\n      (length - 2).downto(0) do |i|\n        if self[i] > self[i + 1]\n          self[i], self[i + 1] = self[i + 1], self[i]\n          swapped = true\n        end\n      end\n    end while swapped\n    self\n  end\nend\n", "target": "public static void cocktailSort(int[] A)\n    {\n        bool swapped;\n        do\n        {\n            swapped = false;\n            for (int i = 0; i <= A.Length - 2; i++)\n            {\n                if (A[i] > A[i + 1])\n                {\n                    \n                    int temp = A[i];\n                    A[i] = A[i + 1];\n                    A[i + 1] = temp;\n                    swapped = true;\n                }\n            }\n            if (!swapped)\n            {\n                \n                break;\n            }\n            swapped = false;\n            for (int i = A.Length - 2; i >= 0; i--)\n            {\n                if (A[i] > A[i + 1])\n                {\n                    int temp = A[i];\n                    A[i] = A[i + 1];\n                    A[i + 1] = temp;\n                    swapped = true;\n                }\n            }\n            \n        } while (swapped);\n    }\n"}
{"id": 33641, "name": "Sorting algorithms_Cocktail sort", "source": "Translate Ruby to Java: class Array\n  def cocktailsort!\n    begin\n      swapped = false\n      0.upto(length - 2) do |i|\n        if self[i] > self[i + 1]\n          self[i], self[i + 1] = self[i + 1], self[i]\n          swapped = true\n        end\n      end\n      break unless swapped\n      \n      swapped = false\n      (length - 2).downto(0) do |i|\n        if self[i] > self[i + 1]\n          self[i], self[i + 1] = self[i + 1], self[i]\n          swapped = true\n        end\n      end\n    end while swapped\n    self\n  end\nend\n", "target": "public static void cocktailSort( int[] A ){\n\tboolean swapped;\n\tdo {\n\t\tswapped = false;\n\t\tfor (int i =0; i<=  A.length  - 2;i++) {\n\t\t\tif (A[ i ] > A[ i + 1 ]) {\n\t\t\t\t\n\t\t\t\tint temp = A[i];\n\t\t\t\tA[i] = A[i+1];\n\t\t\t\tA[i+1]=temp;\n\t\t\t\tswapped = true;\n\t\t\t}\n\t\t}\n\t\tif (!swapped) {\n\t\t\t\n\t\t\tbreak;\n\t\t}\n\t\tswapped = false;\n\t\tfor (int i= A.length - 2;i>=0;i--) {\n\t\t\tif (A[ i ] > A[ i + 1 ]) {\n\t\t\t\tint temp = A[i];\n\t\t\t\tA[i] = A[i+1];\n\t\t\t\tA[i+1]=temp;\n\t\t\t\tswapped = true;\n\t\t\t}\n\t\t}\n\t\t\n\t} while (swapped);\n}\n"}
{"id": 33642, "name": "Sorting algorithms_Cocktail sort", "source": "Translate Ruby to Python: class Array\n  def cocktailsort!\n    begin\n      swapped = false\n      0.upto(length - 2) do |i|\n        if self[i] > self[i + 1]\n          self[i], self[i + 1] = self[i + 1], self[i]\n          swapped = true\n        end\n      end\n      break unless swapped\n      \n      swapped = false\n      (length - 2).downto(0) do |i|\n        if self[i] > self[i + 1]\n          self[i], self[i + 1] = self[i + 1], self[i]\n          swapped = true\n        end\n      end\n    end while swapped\n    self\n  end\nend\n", "target": "def cocktailSort(A):\n    up = range(len(A)-1)\n    while True:\n        for indices in (up, reversed(up)):\n            swapped = False\n            for i in indices:\n                if A[i] > A[i+1]:  \n                    A[i], A[i+1] =  A[i+1], A[i]\n                    swapped = True\n            if not swapped:\n                return\n"}
{"id": 33850, "name": "Animate a pendulum", "source": "Translate Ruby to C#: require 'tk'\n\n$root = TkRoot.new(\"title\" => \"Pendulum Animation\")\n$canvas = TkCanvas.new($root) do\n  width 320\n  height 200\n  create TkcLine, 0,25,320,25,   'tags' => 'plate', 'width' => 2, 'fill' => 'grey50'\n  create TkcOval, 155,20,165,30, 'tags' => 'pivot', 'outline' => \"\", 'fill' => 'grey50'\n  create TkcLine, 1,1,1,1, 'tags' => 'rod', 'width' => 3, 'fill' => 'black'\n  create TkcOval, 1,1,2,2, 'tags' => 'bob', 'outline' => 'black', 'fill' => 'yellow'\nend\n$canvas.raise('pivot')\n$canvas.pack('fill' => 'both', 'expand' => true)\n\n$Theta = 45.0\n$dTheta = 0.0\n$length = 150\n$homeX = 160\n$homeY = 25\n\ndef show_pendulum\n  angle = $Theta * Math::PI / 180\n  x = $homeX + $length * Math.sin(angle)\n  y = $homeY + $length * Math.cos(angle)\n  $canvas.coords('rod', $homeX, $homeY, x, y)\n  $canvas.coords('bob', x-15, y-15, x+15, y+15)\nend\n\ndef recompute_angle\n  scaling = 3000.0 / ($length ** 2)\n  \n  firstDDTheta = -Math.sin($Theta * Math::PI / 180) * scaling\n  midDTheta = $dTheta + firstDDTheta\n  midTheta = $Theta + ($dTheta + midDTheta)/2\n  \n  midDDTheta = -Math.sin(midTheta * Math::PI / 180) * scaling\n  midDTheta = $dTheta + (firstDDTheta + midDDTheta)/2\n  midTheta = $Theta + ($dTheta + midDTheta)/2\n  \n  midDDTheta = -Math.sin(midTheta * Math::PI / 180) * scaling\n  lastDTheta = midDTheta + midDDTheta\n  lastTheta = midTheta + (midDTheta + lastDTheta)/2\n  \n  lastDDTheta = -Math.sin(lastTheta * Math::PI/180) * scaling\n  lastDTheta = midDTheta + (midDDTheta + lastDDTheta)/2\n  lastTheta = midTheta + (midDTheta + lastDTheta)/2\n  \n  $dTheta  = lastDTheta\n  $Theta = lastTheta\nend\n\ndef animate\n  recompute_angle\n  show_pendulum\n  $after_id = $root.after(15) {animate}\nend\n\nshow_pendulum\n$after_id = $root.after(500) {animate}\n\n$canvas.bind('<Destroy>') {$root.after_cancel($after_id)}\n\nTk.mainloop\n", "target": "using System;\nusing System.Drawing;\nusing System.Windows.Forms;\n\nclass CSharpPendulum\n{\n    Form _form;\n    Timer _timer;\n    \n    double _angle = Math.PI / 2, \n           _angleAccel, \n           _angleVelocity = 0, \n           _dt = 0.1;\n    \n    int _length = 50;\n\n    [STAThread]\n    static void Main()\n    {\n        var p = new CSharpPendulum();\n    }\n\n    public CSharpPendulum()\n    {\n        _form = new Form() { Text = \"Pendulum\", Width = 200, Height = 200 };\n        _timer = new Timer() { Interval = 30 };\n\n        _timer.Tick += delegate(object sender, EventArgs e)\n        {\n            int anchorX = (_form.Width / 2) - 12,\n                anchorY = _form.Height / 4,\n                ballX = anchorX + (int)(Math.Sin(_angle) * _length),\n                ballY = anchorY + (int)(Math.Cos(_angle) * _length);\n\n            _angleAccel = -9.81 / _length * Math.Sin(_angle);\n            _angleVelocity += _angleAccel * _dt;\n            _angle += _angleVelocity * _dt;\n          \n            Bitmap dblBuffer = new Bitmap(_form.Width, _form.Height);\n            Graphics g = Graphics.FromImage(dblBuffer);\n            Graphics f = Graphics.FromHwnd(_form.Handle);\n\n            g.DrawLine(Pens.Black, new Point(anchorX, anchorY), new Point(ballX, ballY));\n            g.FillEllipse(Brushes.Black, anchorX - 3, anchorY - 4, 7, 7);\n            g.FillEllipse(Brushes.DarkGoldenrod, ballX - 7, ballY - 7, 14, 14);\n            \n            f.Clear(Color.White);\n            f.DrawImage(dblBuffer, new Point(0, 0));    \n        };\n\n        _timer.Start();\n        Application.Run(_form);\n    }     \n}\n"}
{"id": 33852, "name": "Animate a pendulum", "source": "Translate Ruby to Java: require 'tk'\n\n$root = TkRoot.new(\"title\" => \"Pendulum Animation\")\n$canvas = TkCanvas.new($root) do\n  width 320\n  height 200\n  create TkcLine, 0,25,320,25,   'tags' => 'plate', 'width' => 2, 'fill' => 'grey50'\n  create TkcOval, 155,20,165,30, 'tags' => 'pivot', 'outline' => \"\", 'fill' => 'grey50'\n  create TkcLine, 1,1,1,1, 'tags' => 'rod', 'width' => 3, 'fill' => 'black'\n  create TkcOval, 1,1,2,2, 'tags' => 'bob', 'outline' => 'black', 'fill' => 'yellow'\nend\n$canvas.raise('pivot')\n$canvas.pack('fill' => 'both', 'expand' => true)\n\n$Theta = 45.0\n$dTheta = 0.0\n$length = 150\n$homeX = 160\n$homeY = 25\n\ndef show_pendulum\n  angle = $Theta * Math::PI / 180\n  x = $homeX + $length * Math.sin(angle)\n  y = $homeY + $length * Math.cos(angle)\n  $canvas.coords('rod', $homeX, $homeY, x, y)\n  $canvas.coords('bob', x-15, y-15, x+15, y+15)\nend\n\ndef recompute_angle\n  scaling = 3000.0 / ($length ** 2)\n  \n  firstDDTheta = -Math.sin($Theta * Math::PI / 180) * scaling\n  midDTheta = $dTheta + firstDDTheta\n  midTheta = $Theta + ($dTheta + midDTheta)/2\n  \n  midDDTheta = -Math.sin(midTheta * Math::PI / 180) * scaling\n  midDTheta = $dTheta + (firstDDTheta + midDDTheta)/2\n  midTheta = $Theta + ($dTheta + midDTheta)/2\n  \n  midDDTheta = -Math.sin(midTheta * Math::PI / 180) * scaling\n  lastDTheta = midDTheta + midDDTheta\n  lastTheta = midTheta + (midDTheta + lastDTheta)/2\n  \n  lastDDTheta = -Math.sin(lastTheta * Math::PI/180) * scaling\n  lastDTheta = midDTheta + (midDDTheta + lastDDTheta)/2\n  lastTheta = midTheta + (midDTheta + lastDTheta)/2\n  \n  $dTheta  = lastDTheta\n  $Theta = lastTheta\nend\n\ndef animate\n  recompute_angle\n  show_pendulum\n  $after_id = $root.after(15) {animate}\nend\n\nshow_pendulum\n$after_id = $root.after(500) {animate}\n\n$canvas.bind('<Destroy>') {$root.after_cancel($after_id)}\n\nTk.mainloop\n", "target": "import java.awt.*;\nimport javax.swing.*;\n\npublic class Pendulum extends JPanel implements Runnable {\n\n    private double angle = Math.PI / 2;\n    private int length;\n\n    public Pendulum(int length) {\n        this.length = length;\n        setDoubleBuffered(true);\n    }\n\n    @Override\n    public void paint(Graphics g) {\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, getWidth(), getHeight());\n        g.setColor(Color.BLACK);\n        int anchorX = getWidth() / 2, anchorY = getHeight() / 4;\n        int ballX = anchorX + (int) (Math.sin(angle) * length);\n        int ballY = anchorY + (int) (Math.cos(angle) * length);\n        g.drawLine(anchorX, anchorY, ballX, ballY);\n        g.fillOval(anchorX - 3, anchorY - 4, 7, 7);\n        g.fillOval(ballX - 7, ballY - 7, 14, 14);\n    }\n\n    public void run() {\n        double angleAccel, angleVelocity = 0, dt = 0.1;\n        while (true) {\n            angleAccel = -9.81 / length * Math.sin(angle);\n            angleVelocity += angleAccel * dt;\n            angle += angleVelocity * dt;\n            repaint();\n            try { Thread.sleep(15); } catch (InterruptedException ex) {}\n        }\n    }\n\n    @Override\n    public Dimension getPreferredSize() {\n        return new Dimension(2 * length + 50, length / 2 * 3);\n    }\n\n    public static void main(String[] args) {\n        JFrame f = new JFrame(\"Pendulum\");\n        Pendulum p = new Pendulum(200);\n        f.add(p);\n        f.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n        f.pack();\n        f.setVisible(true);\n        new Thread(p).start();\n    }\n}\n"}
{"id": 33853, "name": "Animate a pendulum", "source": "Translate Ruby to Python: require 'tk'\n\n$root = TkRoot.new(\"title\" => \"Pendulum Animation\")\n$canvas = TkCanvas.new($root) do\n  width 320\n  height 200\n  create TkcLine, 0,25,320,25,   'tags' => 'plate', 'width' => 2, 'fill' => 'grey50'\n  create TkcOval, 155,20,165,30, 'tags' => 'pivot', 'outline' => \"\", 'fill' => 'grey50'\n  create TkcLine, 1,1,1,1, 'tags' => 'rod', 'width' => 3, 'fill' => 'black'\n  create TkcOval, 1,1,2,2, 'tags' => 'bob', 'outline' => 'black', 'fill' => 'yellow'\nend\n$canvas.raise('pivot')\n$canvas.pack('fill' => 'both', 'expand' => true)\n\n$Theta = 45.0\n$dTheta = 0.0\n$length = 150\n$homeX = 160\n$homeY = 25\n\ndef show_pendulum\n  angle = $Theta * Math::PI / 180\n  x = $homeX + $length * Math.sin(angle)\n  y = $homeY + $length * Math.cos(angle)\n  $canvas.coords('rod', $homeX, $homeY, x, y)\n  $canvas.coords('bob', x-15, y-15, x+15, y+15)\nend\n\ndef recompute_angle\n  scaling = 3000.0 / ($length ** 2)\n  \n  firstDDTheta = -Math.sin($Theta * Math::PI / 180) * scaling\n  midDTheta = $dTheta + firstDDTheta\n  midTheta = $Theta + ($dTheta + midDTheta)/2\n  \n  midDDTheta = -Math.sin(midTheta * Math::PI / 180) * scaling\n  midDTheta = $dTheta + (firstDDTheta + midDDTheta)/2\n  midTheta = $Theta + ($dTheta + midDTheta)/2\n  \n  midDDTheta = -Math.sin(midTheta * Math::PI / 180) * scaling\n  lastDTheta = midDTheta + midDDTheta\n  lastTheta = midTheta + (midDTheta + lastDTheta)/2\n  \n  lastDDTheta = -Math.sin(lastTheta * Math::PI/180) * scaling\n  lastDTheta = midDTheta + (midDDTheta + lastDDTheta)/2\n  lastTheta = midTheta + (midDTheta + lastDTheta)/2\n  \n  $dTheta  = lastDTheta\n  $Theta = lastTheta\nend\n\ndef animate\n  recompute_angle\n  show_pendulum\n  $after_id = $root.after(15) {animate}\nend\n\nshow_pendulum\n$after_id = $root.after(500) {animate}\n\n$canvas.bind('<Destroy>') {$root.after_cancel($after_id)}\n\nTk.mainloop\n", "target": "import pygame, sys\nfrom pygame.locals import *\nfrom math import sin, cos, radians\n\npygame.init()\n\nWINDOWSIZE = 250\nTIMETICK = 100\nBOBSIZE = 15\n\nwindow = pygame.display.set_mode((WINDOWSIZE, WINDOWSIZE))\npygame.display.set_caption(\"Pendulum\")\n\nscreen = pygame.display.get_surface()\nscreen.fill((255,255,255))\n\nPIVOT = (WINDOWSIZE/2, WINDOWSIZE/10)\nSWINGLENGTH = PIVOT[1]*4\n\nclass BobMass(pygame.sprite.Sprite):\n    def __init__(self):\n        pygame.sprite.Sprite.__init__(self)\n        self.theta = 45\n        self.dtheta = 0\n        self.rect = pygame.Rect(PIVOT[0]-SWINGLENGTH*cos(radians(self.theta)),\n                                PIVOT[1]+SWINGLENGTH*sin(radians(self.theta)),\n                                1,1)\n        self.draw()\n\n    def recomputeAngle(self):\n        scaling = 3000.0/(SWINGLENGTH**2)\n\n        firstDDtheta = -sin(radians(self.theta))*scaling\n        midDtheta = self.dtheta + firstDDtheta\n        midtheta = self.theta + (self.dtheta + midDtheta)/2.0\n\n        midDDtheta = -sin(radians(midtheta))*scaling\n        midDtheta = self.dtheta + (firstDDtheta + midDDtheta)/2\n        midtheta = self.theta + (self.dtheta + midDtheta)/2\n\n        midDDtheta = -sin(radians(midtheta)) * scaling\n        lastDtheta = midDtheta + midDDtheta\n        lasttheta = midtheta + (midDtheta + lastDtheta)/2.0\n        \n        lastDDtheta = -sin(radians(lasttheta)) * scaling\n        lastDtheta = midDtheta + (midDDtheta + lastDDtheta)/2.0\n        lasttheta = midtheta + (midDtheta + lastDtheta)/2.0\n\n        self.dtheta = lastDtheta\n        self.theta = lasttheta\n        self.rect = pygame.Rect(PIVOT[0]-\n                                SWINGLENGTH*sin(radians(self.theta)), \n                                PIVOT[1]+\n                                SWINGLENGTH*cos(radians(self.theta)),1,1)\n\n\n    def draw(self):\n        pygame.draw.circle(screen, (0,0,0), PIVOT, 5, 0)\n        pygame.draw.circle(screen, (0,0,0), self.rect.center, BOBSIZE, 0)\n        pygame.draw.aaline(screen, (0,0,0), PIVOT, self.rect.center)\n        pygame.draw.line(screen, (0,0,0), (0, PIVOT[1]), (WINDOWSIZE, PIVOT[1]))\n\n    def update(self):\n        self.recomputeAngle()\n        screen.fill((255,255,255))\n        self.draw()\n\nbob = BobMass()\n\nTICK = USEREVENT + 2\npygame.time.set_timer(TICK, TIMETICK)\n\ndef input(events):\n    for event in events:\n        if event.type == QUIT:\n            sys.exit(0)\n        elif event.type == TICK:\n            bob.update()\n\nwhile True:\n    input(pygame.event.get())\n    pygame.display.flip()\n"}
{"id": 34025, "name": "Non-decimal radices_Input", "source": "Translate Ruby to C#: dec1 = \"0123459\"\nhex2 = \"abcf123\"\noct3 = \"7651\"\nbin4 = \"101011001\"\n\np dec1.to_i   \np hex2.hex    \np oct3.oct    \n\n", "target": "using System;\n\nclass Program\n{\n    static void Main()\n    {\n        var value = \"100\";\n        var fromBases = new[] { 2, 8, 10, 16 };\n        var toBase = 10;\n        foreach (var fromBase in fromBases)\n        {\n            Console.WriteLine(\"{0} in base {1} is {2} in base {3}\",\n                value, fromBase, Convert.ToInt32(value, fromBase), toBase);\n        }\n    }\n}\n"}
{"id": 34027, "name": "Non-decimal radices_Input", "source": "Translate Ruby to Python: dec1 = \"0123459\"\nhex2 = \"abcf123\"\noct3 = \"7651\"\nbin4 = \"101011001\"\n\np dec1.to_i   \np hex2.hex    \np oct3.oct    \n\n", "target": ">>> text = '100'\n>>> for base in range(2,21):\n    print (\"String '%s' in base %i is  %i in base 10\" \n           % (text, base, int(text, base)))\n\n  \nString '100' in base 2 is  4 in base 10\nString '100' in base 3 is  9 in base 10\nString '100' in base 4 is  16 in base 10\nString '100' in base 5 is  25 in base 10\nString '100' in base 6 is  36 in base 10\nString '100' in base 7 is  49 in base 10\nString '100' in base 8 is  64 in base 10\nString '100' in base 9 is  81 in base 10\nString '100' in base 10 is  100 in base 10\nString '100' in base 11 is  121 in base 10\nString '100' in base 12 is  144 in base 10\nString '100' in base 13 is  169 in base 10\nString '100' in base 14 is  196 in base 10\nString '100' in base 15 is  225 in base 10\nString '100' in base 16 is  256 in base 10\nString '100' in base 17 is  289 in base 10\nString '100' in base 18 is  324 in base 10\nString '100' in base 19 is  361 in base 10\nString '100' in base 20 is  400 in base 10\n"}
{"id": 34249, "name": "Seven-sided dice from five-sided dice", "source": "Translate Ruby to C#: require './distcheck.rb'\n\ndef d5\n  1 + rand(5)\nend\n\ndef d7\n  loop do\n    d55 = 5*d5 + d5 - 6\n    return (d55 % 7 + 1) if d55 < 21\n  end\nend\n\ndistcheck(1_000_000) {d5}\ndistcheck(1_000_000) {d7}\n", "target": "using System;\n\npublic class SevenSidedDice\n{\n    Random random = new Random();\n\t\t\n        static void Main(string[] args)\n\t\t{\n\t\t\tSevenSidedDice sevenDice = new SevenSidedDice();\n\t\t\tConsole.WriteLine(\"Random number from 1 to 7: \"+ sevenDice.seven());\n            Console.Read();\n\t\t}\n\t\t\n\t\tint seven()\n\t\t{\n\t\t\tint v=21;\n\t\t\twhile(v>20)\n\t\t\t\tv=five()+five()*5-6;\n\t\t\treturn 1+v%7;\n\t\t}\n\t\t\n\t\tint five()\n\t\t{\n        return 1 + random.Next(5);\n\t\t}\n}\n"}
{"id": 34251, "name": "Seven-sided dice from five-sided dice", "source": "Translate Ruby to Java: require './distcheck.rb'\n\ndef d5\n  1 + rand(5)\nend\n\ndef d7\n  loop do\n    d55 = 5*d5 + d5 - 6\n    return (d55 % 7 + 1) if d55 < 21\n  end\nend\n\ndistcheck(1_000_000) {d5}\ndistcheck(1_000_000) {d7}\n", "target": "import java.util.Random;\npublic class SevenSidedDice \n{\n\tprivate static final Random rnd = new Random();\n\tpublic static void main(String[] args)\n\t{\n\t\tSevenSidedDice now=new SevenSidedDice();\n\t\tSystem.out.println(\"Random number from 1 to 7: \"+now.seven());\n\t}\n\tint seven()\n\t{\n\t\tint v=21;\n\t\twhile(v>20)\n\t\t\tv=five()+five()*5-6;\n\t\treturn 1+v%7;\n\t}\n\tint five()\n\t{\n\t\treturn 1+rnd.nextInt(5);\n\t}\n}\n"}
{"id": 34252, "name": "Seven-sided dice from five-sided dice", "source": "Translate Ruby to Python: require './distcheck.rb'\n\ndef d5\n  1 + rand(5)\nend\n\ndef d7\n  loop do\n    d55 = 5*d5 + d5 - 6\n    return (d55 % 7 + 1) if d55 < 21\n  end\nend\n\ndistcheck(1_000_000) {d5}\ndistcheck(1_000_000) {d7}\n", "target": "from random import randint\n\ndef dice5():\n    return randint(1, 5)\n\ndef dice7():\n    r = dice5() + dice5() * 5 - 6\n    return (r % 7) + 1 if r < 21 else dice7()\n"}
{"id": 34506, "name": "Heronian triangles", "source": "Translate Ruby to C#: class Triangle\n  def self.valid?(a,b,c)      \n    short, middle, long = [a, b, c].sort\n    short + middle > long\n  end\n  \n  attr_reader :sides, :perimeter, :area\n  \n  def initialize(a,b,c)\n    @sides = [a, b, c].sort\n    @perimeter = a + b + c\n    s = @perimeter / 2.0\n    @area = Math.sqrt(s * (s - a) * (s - b) * (s - c))\n  end\n  \n  def heronian?\n    area == area.to_i\n  end\n  \n  def <=>(other)\n    [area, perimeter, sides] <=> [other.area, other.perimeter, other.sides]\n  end\n  \n  def to_s\n    \"%-11s%6d%8.1f\" % [sides.join('x'), perimeter, area]\n  end\nend\n\nmax, area = 200, 210\nprim_triangles = []\n1.upto(max) do |a|\n  a.upto(max) do |b|\n    b.upto(max) do |c|\n      next if a.gcd(b).gcd(c) > 1\n      prim_triangles << Triangle.new(a, b, c) if Triangle.valid?(a, b, c)\n    end\n  end\nend\n\nsorted = prim_triangles.select(&:heronian?).sort\n\nputs \"Primitive heronian triangles with sides upto \nputs \"\\nsides       perim.   area\"\nputs sorted.first(10).map(&:to_s)\nputs \"\\nTriangles with an area of: \nsorted.each{|tr| puts tr if tr.area == area}\n", "target": "using System;\nusing System.Collections.Generic;\n\nnamespace heron\n{\n    class Program{\n        static void Main(string[] args){           \n            List<int[]> list = new List<int[]>();\n            for (int c = 1; c <= 200; c++)\n                for (int b = 1; b <= c; b++)\n                    for (int a = 1; a <= b; a++)\n                        if (gcd(a, gcd(b, c)) == 1 && isHeron(heronArea(a, b, c)))\n                            list.Add(new int[] { a, b, c, a + b + c, (int)heronArea(a, b, c)});\n            sort(list);\n            Console.WriteLine(\"Number of primitive Heronian triangles with sides up to 200: \" + list.Count + \"\\n\\nFirst ten when ordered by increasing area, then perimeter,then maximum sides:\\nSides\\t\\t\\tPerimeter\\tArea\");\n            for(int i = 0; i < 10; i++)\n                Console.WriteLine(list[i][0] + \"\\t\" + list[i][1] + \"\\t\" + list[i][2] + \"\\t\" + list[i][3] + \"\\t\\t\" + list[i][4]);\n            Console.WriteLine(\"\\nPerimeter = 210\\nSides\\t\\t\\tPerimeter\\tArea\");\n            foreach (int[] i in list)\n                if (i[4] == 210)\n                    Console.WriteLine(i[0] + \"\\t\" + i[1] + \"\\t\" + i[2] + \"\\t\" + i[3] + \"\\t\\t\" + i[4]);     \n        }\n        static bool isHeron(double heronArea){\n            return heronArea % 1 == 0 && heronArea != 0;\n        }\n        static double heronArea(int a, int b, int c){\n            double s = (a + b + c) / 2d;\n            return Math.Sqrt(s * (s - a) * (s - b) * (s - c));\n        }\n        static int gcd(int a, int b){\n            int remainder = 1, dividend, divisor;\n            dividend = a > b ? a : b;\n            divisor = a > b ? b : a;\n            while (remainder != 0){\n                remainder = dividend % divisor;\n                if (remainder != 0){\n                    dividend = divisor;\n                    divisor = remainder;\n                }\n            }\n            return divisor;\n        }\n        static void sort(List<int[]> list){\n            int[] temp = new int[5];\n            bool changed = true;\n            while(changed){\n                changed = false;\n                for (int i = 1; i < list.Count; i++)\n                    if (list[i][4] < list[i - 1][4] || list[i][4] == list[i - 1][4] && list[i][3] < list[i - 1][3]){\n                        temp = list[i];\n                        list[i] = list[i - 1];\n                        list[i - 1] = temp;\n                        changed = true;\n                    }                \n            }\n        }\n    }\n}\n"}
{"id": 34507, "name": "Heronian triangles", "source": "Translate Ruby to C#: class Triangle\n  def self.valid?(a,b,c)      \n    short, middle, long = [a, b, c].sort\n    short + middle > long\n  end\n  \n  attr_reader :sides, :perimeter, :area\n  \n  def initialize(a,b,c)\n    @sides = [a, b, c].sort\n    @perimeter = a + b + c\n    s = @perimeter / 2.0\n    @area = Math.sqrt(s * (s - a) * (s - b) * (s - c))\n  end\n  \n  def heronian?\n    area == area.to_i\n  end\n  \n  def <=>(other)\n    [area, perimeter, sides] <=> [other.area, other.perimeter, other.sides]\n  end\n  \n  def to_s\n    \"%-11s%6d%8.1f\" % [sides.join('x'), perimeter, area]\n  end\nend\n\nmax, area = 200, 210\nprim_triangles = []\n1.upto(max) do |a|\n  a.upto(max) do |b|\n    b.upto(max) do |c|\n      next if a.gcd(b).gcd(c) > 1\n      prim_triangles << Triangle.new(a, b, c) if Triangle.valid?(a, b, c)\n    end\n  end\nend\n\nsorted = prim_triangles.select(&:heronian?).sort\n\nputs \"Primitive heronian triangles with sides upto \nputs \"\\nsides       perim.   area\"\nputs sorted.first(10).map(&:to_s)\nputs \"\\nTriangles with an area of: \nsorted.each{|tr| puts tr if tr.area == area}\n", "target": "using System;\nusing System.Collections.Generic;\n\nnamespace heron\n{\n    class Program{\n        static void Main(string[] args){           \n            List<int[]> list = new List<int[]>();\n            for (int c = 1; c <= 200; c++)\n                for (int b = 1; b <= c; b++)\n                    for (int a = 1; a <= b; a++)\n                        if (gcd(a, gcd(b, c)) == 1 && isHeron(heronArea(a, b, c)))\n                            list.Add(new int[] { a, b, c, a + b + c, (int)heronArea(a, b, c)});\n            sort(list);\n            Console.WriteLine(\"Number of primitive Heronian triangles with sides up to 200: \" + list.Count + \"\\n\\nFirst ten when ordered by increasing area, then perimeter,then maximum sides:\\nSides\\t\\t\\tPerimeter\\tArea\");\n            for(int i = 0; i < 10; i++)\n                Console.WriteLine(list[i][0] + \"\\t\" + list[i][1] + \"\\t\" + list[i][2] + \"\\t\" + list[i][3] + \"\\t\\t\" + list[i][4]);\n            Console.WriteLine(\"\\nPerimeter = 210\\nSides\\t\\t\\tPerimeter\\tArea\");\n            foreach (int[] i in list)\n                if (i[4] == 210)\n                    Console.WriteLine(i[0] + \"\\t\" + i[1] + \"\\t\" + i[2] + \"\\t\" + i[3] + \"\\t\\t\" + i[4]);     \n        }\n        static bool isHeron(double heronArea){\n            return heronArea % 1 == 0 && heronArea != 0;\n        }\n        static double heronArea(int a, int b, int c){\n            double s = (a + b + c) / 2d;\n            return Math.Sqrt(s * (s - a) * (s - b) * (s - c));\n        }\n        static int gcd(int a, int b){\n            int remainder = 1, dividend, divisor;\n            dividend = a > b ? a : b;\n            divisor = a > b ? b : a;\n            while (remainder != 0){\n                remainder = dividend % divisor;\n                if (remainder != 0){\n                    dividend = divisor;\n                    divisor = remainder;\n                }\n            }\n            return divisor;\n        }\n        static void sort(List<int[]> list){\n            int[] temp = new int[5];\n            bool changed = true;\n            while(changed){\n                changed = false;\n                for (int i = 1; i < list.Count; i++)\n                    if (list[i][4] < list[i - 1][4] || list[i][4] == list[i - 1][4] && list[i][3] < list[i - 1][3]){\n                        temp = list[i];\n                        list[i] = list[i - 1];\n                        list[i - 1] = temp;\n                        changed = true;\n                    }                \n            }\n        }\n    }\n}\n"}
{"id": 34510, "name": "Heronian triangles", "source": "Translate Ruby to Java: class Triangle\n  def self.valid?(a,b,c)      \n    short, middle, long = [a, b, c].sort\n    short + middle > long\n  end\n  \n  attr_reader :sides, :perimeter, :area\n  \n  def initialize(a,b,c)\n    @sides = [a, b, c].sort\n    @perimeter = a + b + c\n    s = @perimeter / 2.0\n    @area = Math.sqrt(s * (s - a) * (s - b) * (s - c))\n  end\n  \n  def heronian?\n    area == area.to_i\n  end\n  \n  def <=>(other)\n    [area, perimeter, sides] <=> [other.area, other.perimeter, other.sides]\n  end\n  \n  def to_s\n    \"%-11s%6d%8.1f\" % [sides.join('x'), perimeter, area]\n  end\nend\n\nmax, area = 200, 210\nprim_triangles = []\n1.upto(max) do |a|\n  a.upto(max) do |b|\n    b.upto(max) do |c|\n      next if a.gcd(b).gcd(c) > 1\n      prim_triangles << Triangle.new(a, b, c) if Triangle.valid?(a, b, c)\n    end\n  end\nend\n\nsorted = prim_triangles.select(&:heronian?).sort\n\nputs \"Primitive heronian triangles with sides upto \nputs \"\\nsides       perim.   area\"\nputs sorted.first(10).map(&:to_s)\nputs \"\\nTriangles with an area of: \nsorted.each{|tr| puts tr if tr.area == area}\n", "target": "import java.util.ArrayList;\n\npublic class Heron {\n    public static void main(String[] args) {\n        ArrayList<int[]> list = new ArrayList<>();\n\n        for (int c = 1; c <= 200; c++) {\n            for (int b = 1; b <= c; b++) {\n                for (int a = 1; a <= b; a++) {\n\n                    if (gcd(gcd(a, b), c) == 1 && isHeron(heronArea(a, b, c))){\n                        int area = (int) heronArea(a, b, c);\n                        list.add(new int[]{a, b, c, a + b + c, area});\n                    }\n                }\n            }\n        }\n        sort(list);\n\n        System.out.printf(\"Number of primitive Heronian triangles with sides up \"\n                + \"to 200: %d\\n\\nFirst ten when ordered by increasing area, then\"\n                + \" perimeter:\\nSides       Perimeter   Area\", list.size());\n\n        for (int i = 0; i < 10; i++) {\n            System.out.printf(\"\\n%d x %d x %d   %d      %d\",\n                    list.get(i)[0], list.get(i)[1], list.get(i)[2],\n                    list.get(i)[3], list.get(i)[4]);\n        }\n\n        System.out.printf(\"\\n\\nArea = 210\\nSides        Perimeter   Area\");\n        for (int i = 0; i < list.size(); i++) {\n            if (list.get(i)[4] == 210)\n                System.out.printf(\"\\n%d x %d x %d   %d      %d\",\n                        list.get(i)[0], list.get(i)[1], list.get(i)[2],\n                        list.get(i)[3], list.get(i)[4]);\n        }\n    }\n\n    public static double heronArea(int a, int b, int c) {\n        double s = (a + b + c) / 2f;\n        return Math.sqrt(s * (s - a) * (s - b) * (s - c));\n    }\n\n    public static boolean isHeron(double h) {\n        return h % 1 == 0 && h > 0;\n    }\n\n    public static int gcd(int a, int b) {\n        int leftover = 1, dividend = a > b ? a : b, divisor = a > b ? b : a;\n        while (leftover != 0) {\n            leftover = dividend % divisor;\n            if (leftover > 0) {\n                dividend = divisor;\n                divisor = leftover;\n            }\n        }\n        return divisor;\n    }\n\n    public static void sort(ArrayList<int[]> list) {\n        boolean swapped = true;\n        int[] temp;\n        while (swapped) {\n            swapped = false;\n            for (int i = 1; i < list.size(); i++) {\n                if (list.get(i)[4] < list.get(i - 1)[4] ||\n                        list.get(i)[4] == list.get(i - 1)[4] &&\n                        list.get(i)[3] < list.get(i - 1)[3]) {\n                    temp = list.get(i);\n                    list.set(i, list.get(i - 1));\n                    list.set(i - 1, temp);\n                    swapped = true;\n                }\n            }\n        }\n    }\n}\n"}
{"id": 34511, "name": "Heronian triangles", "source": "Translate Ruby to Java: class Triangle\n  def self.valid?(a,b,c)      \n    short, middle, long = [a, b, c].sort\n    short + middle > long\n  end\n  \n  attr_reader :sides, :perimeter, :area\n  \n  def initialize(a,b,c)\n    @sides = [a, b, c].sort\n    @perimeter = a + b + c\n    s = @perimeter / 2.0\n    @area = Math.sqrt(s * (s - a) * (s - b) * (s - c))\n  end\n  \n  def heronian?\n    area == area.to_i\n  end\n  \n  def <=>(other)\n    [area, perimeter, sides] <=> [other.area, other.perimeter, other.sides]\n  end\n  \n  def to_s\n    \"%-11s%6d%8.1f\" % [sides.join('x'), perimeter, area]\n  end\nend\n\nmax, area = 200, 210\nprim_triangles = []\n1.upto(max) do |a|\n  a.upto(max) do |b|\n    b.upto(max) do |c|\n      next if a.gcd(b).gcd(c) > 1\n      prim_triangles << Triangle.new(a, b, c) if Triangle.valid?(a, b, c)\n    end\n  end\nend\n\nsorted = prim_triangles.select(&:heronian?).sort\n\nputs \"Primitive heronian triangles with sides upto \nputs \"\\nsides       perim.   area\"\nputs sorted.first(10).map(&:to_s)\nputs \"\\nTriangles with an area of: \nsorted.each{|tr| puts tr if tr.area == area}\n", "target": "import java.util.ArrayList;\n\npublic class Heron {\n    public static void main(String[] args) {\n        ArrayList<int[]> list = new ArrayList<>();\n\n        for (int c = 1; c <= 200; c++) {\n            for (int b = 1; b <= c; b++) {\n                for (int a = 1; a <= b; a++) {\n\n                    if (gcd(gcd(a, b), c) == 1 && isHeron(heronArea(a, b, c))){\n                        int area = (int) heronArea(a, b, c);\n                        list.add(new int[]{a, b, c, a + b + c, area});\n                    }\n                }\n            }\n        }\n        sort(list);\n\n        System.out.printf(\"Number of primitive Heronian triangles with sides up \"\n                + \"to 200: %d\\n\\nFirst ten when ordered by increasing area, then\"\n                + \" perimeter:\\nSides       Perimeter   Area\", list.size());\n\n        for (int i = 0; i < 10; i++) {\n            System.out.printf(\"\\n%d x %d x %d   %d      %d\",\n                    list.get(i)[0], list.get(i)[1], list.get(i)[2],\n                    list.get(i)[3], list.get(i)[4]);\n        }\n\n        System.out.printf(\"\\n\\nArea = 210\\nSides        Perimeter   Area\");\n        for (int i = 0; i < list.size(); i++) {\n            if (list.get(i)[4] == 210)\n                System.out.printf(\"\\n%d x %d x %d   %d      %d\",\n                        list.get(i)[0], list.get(i)[1], list.get(i)[2],\n                        list.get(i)[3], list.get(i)[4]);\n        }\n    }\n\n    public static double heronArea(int a, int b, int c) {\n        double s = (a + b + c) / 2f;\n        return Math.sqrt(s * (s - a) * (s - b) * (s - c));\n    }\n\n    public static boolean isHeron(double h) {\n        return h % 1 == 0 && h > 0;\n    }\n\n    public static int gcd(int a, int b) {\n        int leftover = 1, dividend = a > b ? a : b, divisor = a > b ? b : a;\n        while (leftover != 0) {\n            leftover = dividend % divisor;\n            if (leftover > 0) {\n                dividend = divisor;\n                divisor = leftover;\n            }\n        }\n        return divisor;\n    }\n\n    public static void sort(ArrayList<int[]> list) {\n        boolean swapped = true;\n        int[] temp;\n        while (swapped) {\n            swapped = false;\n            for (int i = 1; i < list.size(); i++) {\n                if (list.get(i)[4] < list.get(i - 1)[4] ||\n                        list.get(i)[4] == list.get(i - 1)[4] &&\n                        list.get(i)[3] < list.get(i - 1)[3]) {\n                    temp = list.get(i);\n                    list.set(i, list.get(i - 1));\n                    list.set(i - 1, temp);\n                    swapped = true;\n                }\n            }\n        }\n    }\n}\n"}
{"id": 34512, "name": "Heronian triangles", "source": "Translate Ruby to Python: class Triangle\n  def self.valid?(a,b,c)      \n    short, middle, long = [a, b, c].sort\n    short + middle > long\n  end\n  \n  attr_reader :sides, :perimeter, :area\n  \n  def initialize(a,b,c)\n    @sides = [a, b, c].sort\n    @perimeter = a + b + c\n    s = @perimeter / 2.0\n    @area = Math.sqrt(s * (s - a) * (s - b) * (s - c))\n  end\n  \n  def heronian?\n    area == area.to_i\n  end\n  \n  def <=>(other)\n    [area, perimeter, sides] <=> [other.area, other.perimeter, other.sides]\n  end\n  \n  def to_s\n    \"%-11s%6d%8.1f\" % [sides.join('x'), perimeter, area]\n  end\nend\n\nmax, area = 200, 210\nprim_triangles = []\n1.upto(max) do |a|\n  a.upto(max) do |b|\n    b.upto(max) do |c|\n      next if a.gcd(b).gcd(c) > 1\n      prim_triangles << Triangle.new(a, b, c) if Triangle.valid?(a, b, c)\n    end\n  end\nend\n\nsorted = prim_triangles.select(&:heronian?).sort\n\nputs \"Primitive heronian triangles with sides upto \nputs \"\\nsides       perim.   area\"\nputs sorted.first(10).map(&:to_s)\nputs \"\\nTriangles with an area of: \nsorted.each{|tr| puts tr if tr.area == area}\n", "target": "from __future__ import division, print_function\nfrom math import gcd, sqrt\n\n\ndef hero(a, b, c):\n    s = (a + b + c) / 2\n    a2 = s * (s - a) * (s - b) * (s - c)\n    return sqrt(a2) if a2 > 0 else 0\n\n\ndef is_heronian(a, b, c):\n    a = hero(a, b, c)\n    return a > 0 and a.is_integer()\n\n\ndef gcd3(x, y, z):\n    return gcd(gcd(x, y), z)\n\n\nif __name__ == '__main__':\n    MAXSIDE = 200\n\n    N = 1 + MAXSIDE\n    h = [(x, y, z)\n         for x in range(1, N)\n         for y in range(x, N)\n         for z in range(y, N) if (x + y > z) and\n         1 == gcd3(x, y, z) and\n         is_heronian(x, y, z)]\n\n    \n    h.sort(key=lambda x: (hero(*x), sum(x), x[::-1]))\n\n    print(\n        'Primitive Heronian triangles with sides up to %i:' % MAXSIDE, len(h)\n    )\n    print('\\nFirst ten when ordered by increasing area, then perimeter,',\n          'then maximum sides:')\n    print('\\n'.join('  %14r perim: %3i area: %i'\n                    % (sides, sum(sides), hero(*sides)) for sides in h[:10]))\n    print('\\nAll with area 210 subject to the previous ordering:')\n    print('\\n'.join('  %14r perim: %3i area: %i'\n                    % (sides, sum(sides), hero(*sides)) for sides in h\n                    if hero(*sides) == 210))\n"}
{"id": 34513, "name": "Heronian triangles", "source": "Translate Ruby to Python: class Triangle\n  def self.valid?(a,b,c)      \n    short, middle, long = [a, b, c].sort\n    short + middle > long\n  end\n  \n  attr_reader :sides, :perimeter, :area\n  \n  def initialize(a,b,c)\n    @sides = [a, b, c].sort\n    @perimeter = a + b + c\n    s = @perimeter / 2.0\n    @area = Math.sqrt(s * (s - a) * (s - b) * (s - c))\n  end\n  \n  def heronian?\n    area == area.to_i\n  end\n  \n  def <=>(other)\n    [area, perimeter, sides] <=> [other.area, other.perimeter, other.sides]\n  end\n  \n  def to_s\n    \"%-11s%6d%8.1f\" % [sides.join('x'), perimeter, area]\n  end\nend\n\nmax, area = 200, 210\nprim_triangles = []\n1.upto(max) do |a|\n  a.upto(max) do |b|\n    b.upto(max) do |c|\n      next if a.gcd(b).gcd(c) > 1\n      prim_triangles << Triangle.new(a, b, c) if Triangle.valid?(a, b, c)\n    end\n  end\nend\n\nsorted = prim_triangles.select(&:heronian?).sort\n\nputs \"Primitive heronian triangles with sides upto \nputs \"\\nsides       perim.   area\"\nputs sorted.first(10).map(&:to_s)\nputs \"\\nTriangles with an area of: \nsorted.each{|tr| puts tr if tr.area == area}\n", "target": "from __future__ import division, print_function\nfrom math import gcd, sqrt\n\n\ndef hero(a, b, c):\n    s = (a + b + c) / 2\n    a2 = s * (s - a) * (s - b) * (s - c)\n    return sqrt(a2) if a2 > 0 else 0\n\n\ndef is_heronian(a, b, c):\n    a = hero(a, b, c)\n    return a > 0 and a.is_integer()\n\n\ndef gcd3(x, y, z):\n    return gcd(gcd(x, y), z)\n\n\nif __name__ == '__main__':\n    MAXSIDE = 200\n\n    N = 1 + MAXSIDE\n    h = [(x, y, z)\n         for x in range(1, N)\n         for y in range(x, N)\n         for z in range(y, N) if (x + y > z) and\n         1 == gcd3(x, y, z) and\n         is_heronian(x, y, z)]\n\n    \n    h.sort(key=lambda x: (hero(*x), sum(x), x[::-1]))\n\n    print(\n        'Primitive Heronian triangles with sides up to %i:' % MAXSIDE, len(h)\n    )\n    print('\\nFirst ten when ordered by increasing area, then perimeter,',\n          'then maximum sides:')\n    print('\\n'.join('  %14r perim: %3i area: %i'\n                    % (sides, sum(sides), hero(*sides)) for sides in h[:10]))\n    print('\\nAll with area 210 subject to the previous ordering:')\n    print('\\n'.join('  %14r perim: %3i area: %i'\n                    % (sides, sum(sides), hero(*sides)) for sides in h\n                    if hero(*sides) == 210))\n"}
{"id": 34730, "name": "Check output device is a terminal", "source": "Translate Ruby to C#: File.new(\"testfile\").tty?   \nFile.new(\"/dev/tty\").tty?   \nSTDOUT.tty?  \n", "target": "using System;\n\nnamespace CheckTerminal {\n    class Program {\n        static void Main(string[] args) {\n            Console.WriteLine(\"Stdout is tty: {0}\", Console.IsOutputRedirected);\n        }\n    }\n}\n"}
{"id": 34731, "name": "Check output device is a terminal", "source": "Translate Ruby to C#: File.new(\"testfile\").tty?   \nFile.new(\"/dev/tty\").tty?   \nSTDOUT.tty?  \n", "target": "using System;\n\nnamespace CheckTerminal {\n    class Program {\n        static void Main(string[] args) {\n            Console.WriteLine(\"Stdout is tty: {0}\", Console.IsOutputRedirected);\n        }\n    }\n}\n"}
{"id": 34734, "name": "Check output device is a terminal", "source": "Translate Ruby to Python: File.new(\"testfile\").tty?   \nFile.new(\"/dev/tty\").tty?   \nSTDOUT.tty?  \n", "target": "from sys import stdout\nif stdout.isatty():\n    print 'The output device is a teletype. Or something like a teletype.'\nelse:\n    print 'The output device isn\\'t like a teletype.'\n"}
{"id": 34735, "name": "Check output device is a terminal", "source": "Translate Ruby to Python: File.new(\"testfile\").tty?   \nFile.new(\"/dev/tty\").tty?   \nSTDOUT.tty?  \n", "target": "from sys import stdout\nif stdout.isatty():\n    print 'The output device is a teletype. Or something like a teletype.'\nelse:\n    print 'The output device isn\\'t like a teletype.'\n"}
{"id": 35015, "name": "Averages_Median", "source": "Translate Ruby to C#: def median(ary)\n  srtd = ary.sort\n  alen = srtd.size\n  0.5*(srtd[(alen-1)//2] + srtd[alen//2])\nend\n\na = [4.1, 5.6, 7.2, 1.7, 9.3, 4.4, 3.2]\nputs median a\n\na = [4.1, 5.6, 7.2, 1.7, 9.3, 4.4, 3.2, 5.0]\nputs median a\n\na = [5.0]\nputs median a\n", "target": "using System;\nusing System.Linq;\n\nnamespace Test\n{\n    class Program\n    {\n        static void Main()\n        {\n            double[] myArr = new double[] { 1, 5, 3, 6, 4, 2 };\n\n            myArr = myArr.OrderBy(i => i).ToArray();\n            \n\n            int mid = myArr.Length / 2;\n            double median;\n\n            if (myArr.Length % 2 == 0)\n            {\n                \n                median = (myArr[mid] + myArr[mid - 1]) / 2.0;\n            }\n            else\n            {\n                \n                median = myArr[mid];\n            }\n\n            Console.WriteLine(median);\n            Console.ReadLine();\n        }\n    }\n}\n"}
{"id": 35017, "name": "Averages_Median", "source": "Translate Ruby to Java: def median(ary)\n  srtd = ary.sort\n  alen = srtd.size\n  0.5*(srtd[(alen-1)//2] + srtd[alen//2])\nend\n\na = [4.1, 5.6, 7.2, 1.7, 9.3, 4.4, 3.2]\nputs median a\n\na = [4.1, 5.6, 7.2, 1.7, 9.3, 4.4, 3.2, 5.0]\nputs median a\n\na = [5.0]\nputs median a\n", "target": "\npublic static double median(List<Double> list) {\n    Collections.sort(list);\n    return (list.get(list.size() / 2) + list.get((list.size() - 1) / 2)) / 2;\n}\n"}
{"id": 35018, "name": "Averages_Median", "source": "Translate Ruby to Python: def median(ary)\n  srtd = ary.sort\n  alen = srtd.size\n  0.5*(srtd[(alen-1)//2] + srtd[alen//2])\nend\n\na = [4.1, 5.6, 7.2, 1.7, 9.3, 4.4, 3.2]\nputs median a\n\na = [4.1, 5.6, 7.2, 1.7, 9.3, 4.4, 3.2, 5.0]\nputs median a\n\na = [5.0]\nputs median a\n", "target": "def median(aray):\n    srtd = sorted(aray)\n    alen = len(srtd)\n    return 0.5*( srtd[(alen-1)//2] + srtd[alen//2])\n\na = (4.1, 5.6, 7.2, 1.7, 9.3, 4.4, 3.2)\nprint a, median(a)\na = (4.1, 7.2, 1.7, 9.3, 4.4, 3.2)\nprint a, median(a)\n"}
{"id": 35175, "name": "Pointers and references", "source": "Translate Ruby to C#: func assign2ref(ref, value) {\n    *ref = value;\n}\n\nvar x = 10;\nassign2ref(\\x, 20);\nsay x;      \n", "target": "static void Main(string[] args)\n{\n\tint p;\n\n\tp = 1;\n\tConsole.WriteLine(\"Ref Before: \" + p);\n\tValue(ref p);\n\tConsole.WriteLine(\"Ref After\u00a0: \" + p);\n\n\tp = 1;\n\tConsole.WriteLine(\"Val Before: \" + p);\n\tValue(p);\n\tConsole.WriteLine(\"Val After\u00a0: \" + p);\n\n\tConsole.ReadLine();\n}\n\nprivate static void Value(ref int Value)\n{\n\tValue += 1;\n}\nprivate static void Value(int Value)\n{\n\tValue += 1;\n}\n"}
{"id": 35177, "name": "Pointers and references", "source": "Translate Ruby to Java: func assign2ref(ref, value) {\n    *ref = value;\n}\n\nvar x = 10;\nassign2ref(\\x, 20);\nsay x;      \n", "target": " public class Foo { public int x = 0; }\n\n void somefunction() {\n     Foo a; \n     a = new Foo(); \n     Foo b = a; \n     a.x = 5; \n     System.out.println(b.x); \n }\n"}
{"id": 35178, "name": "Pointers and references", "source": "Translate Ruby to Python: func assign2ref(ref, value) {\n    *ref = value;\n}\n\nvar x = 10;\nassign2ref(\\x, 20);\nsay x;      \n", "target": " \n a = \"foo\"\n \n b = []\n \n class Foo(object):\n     pass\n c = Foo()\n \n class Bar(object):\n     def __init__(self, initializer = None)\n         \n         if initializer is not None:\n            self.value = initializer\n d = Bar(10)\n print d.value\n \n if a is b: pass\n \n if id(a) == id(b): pass\n \n def a(fmt, *args):\n     if fmt is None:\n         fmt = \"%s\"\n      print fmt % (args)\n \n b.append(a)\n \n del(a)\n \n b[0](\"foo\")  \n              \n"}
{"id": 35436, "name": "Sierpinski triangle", "source": "Translate Ruby to C#: ruby -le'16.times{|y|print\" \"*(15-y),*(0..y).map{|x|~y&x>0?\"  \":\" *\"}}'\n", "target": "using System;\nusing System.Collections;\n\nnamespace RosettaCode {\n    class SierpinskiTriangle {\n        int len;\n        BitArray b;\n\n        public SierpinskiTriangle(int n) {\n            if (n < 1) {\n                throw new ArgumentOutOfRangeException(\"Order must be greater than zero\");\n            }\n            len = 1 << (n+1);\n            b = new BitArray(len+1, false);\n            b[len>>1] = true;\n        }\n\n        public void Display() {\n            for (int j = 0; j < len / 2; j++) {\n                for (int i = 0; i < b.Count; i++) {\n                    Console.Write(\"{0}\", b[i] ? \"*\" : \" \");\n                }\n                Console.WriteLine();\n                NextGen();\n            }\n        }\n\n        private void NextGen() {\n            BitArray next = new BitArray(b.Count, false);\n            for (int i = 0; i < b.Count; i++) {\n                if (b[i]) {\n                    next[i - 1] = next[i - 1] ^ true;\n                    next[i + 1] = next[i + 1] ^ true;\n                }\n            }\n            b = next;\n        }\n    }\n}\n"}
{"id": 35438, "name": "Sierpinski triangle", "source": "Translate Ruby to Java: ruby -le'16.times{|y|print\" \"*(15-y),*(0..y).map{|x|~y&x>0?\"  \":\" *\"}}'\n", "target": "public class SierpinskiTriangle {\n\n    public static void main(String[] args) {\n        System.out.println(getSierpinskiTriangle(4));\n    }\n    \n    private static final String getSierpinskiTriangle(int n) {\n        if ( n == 0 ) {\n            return \"*\";\n        }\n\n        String s = getSierpinskiTriangle(n-1);\n        String [] split = s.split(\"\\n\");\n        int length = split.length;\n\n        \n        StringBuilder sb = new StringBuilder();\n        String top = buildSpace((int)Math.pow(2, n-1));\n        for ( int i = 0 ; i < length ;i++ ) {\n            sb.append(top);\n            sb.append(split[i]);\n            sb.append(\"\\n\");\n        }\n        \n        \n        for ( int i = 0 ; i < length ;i++ ) {\n            sb.append(split[i]);\n            sb.append(buildSpace(length-i));\n            sb.append(split[i]);\n            sb.append(\"\\n\");\n        }\n        return sb.toString();\n    }\n    \n    private static String buildSpace(int n) {\n        StringBuilder sb = new StringBuilder();\n        while ( n > 0 ) {\n            sb.append(\" \");\n            n--;\n        }\n        return sb.toString();\n    }\n    \n}\n"}
{"id": 35439, "name": "Sierpinski triangle", "source": "Translate Ruby to Python: ruby -le'16.times{|y|print\" \"*(15-y),*(0..y).map{|x|~y&x>0?\"  \":\" *\"}}'\n", "target": "def sierpinski(n):\n    d = [\"*\"]\n    for i in xrange(n):\n        sp = \" \" * (2 ** i)\n        d = [sp+x+sp for x in d] + [x+\" \"+x for x in d]\n    return d\n\nprint \"\\n\".join(sierpinski(4))\n"}
{"id": 35774, "name": "Globally replace text in several files", "source": "Translate Ruby to C#: var names = %w(\n                a.txt\n                b.txt\n                c.txt\n              )\n\u00a0\nnames.map{ File(_) }.each { |file|\n    say file.edit { |line|\n        line.gsub(\"Goodbye London!\", \"Hello New York!\")\n    }\n}\n", "target": "using System.Collections.Generic;\nusing System.IO;\n\nclass Program {\n    static void Main() {\n        var files = new List<string> {\n            \"test1.txt\",\n            \"test2.txt\"\n        };\n        foreach (string file in files) {\n            File.WriteAllText(file, File.ReadAllText(file).Replace(\"Goodbye London!\", \"Hello New York!\"));\n        }\n    }\n}\n"}
{"id": 35775, "name": "Globally replace text in several files", "source": "Translate Ruby to C#: var names = %w(\n                a.txt\n                b.txt\n                c.txt\n              )\n\u00a0\nnames.map{ File(_) }.each { |file|\n    say file.edit { |line|\n        line.gsub(\"Goodbye London!\", \"Hello New York!\")\n    }\n}\n", "target": "using System.Collections.Generic;\nusing System.IO;\n\nclass Program {\n    static void Main() {\n        var files = new List<string> {\n            \"test1.txt\",\n            \"test2.txt\"\n        };\n        foreach (string file in files) {\n            File.WriteAllText(file, File.ReadAllText(file).Replace(\"Goodbye London!\", \"Hello New York!\"));\n        }\n    }\n}\n"}
{"id": 35778, "name": "Globally replace text in several files", "source": "Translate Ruby to Java: var names = %w(\n                a.txt\n                b.txt\n                c.txt\n              )\n\u00a0\nnames.map{ File(_) }.each { |file|\n    say file.edit { |line|\n        line.gsub(\"Goodbye London!\", \"Hello New York!\")\n    }\n}\n", "target": "import java.io.*;\nimport java.nio.file.*;\n\npublic class GloballyReplaceText {\n\n    public static void main(String[] args) throws IOException {\n\n        for (String fn : new String[]{\"test1.txt\", \"test2.txt\"}) {\n            String s = new String(Files.readAllBytes(Paths.get(fn)));\n            s = s.replace(\"Goodbye London!\", \"Hello New York!\");\n            try (FileWriter fw = new FileWriter(fn)) {\n                fw.write(s);\n            }\n        }\n    }\n}\n"}
{"id": 35779, "name": "Globally replace text in several files", "source": "Translate Ruby to Java: var names = %w(\n                a.txt\n                b.txt\n                c.txt\n              )\n\u00a0\nnames.map{ File(_) }.each { |file|\n    say file.edit { |line|\n        line.gsub(\"Goodbye London!\", \"Hello New York!\")\n    }\n}\n", "target": "import java.io.*;\nimport java.nio.file.*;\n\npublic class GloballyReplaceText {\n\n    public static void main(String[] args) throws IOException {\n\n        for (String fn : new String[]{\"test1.txt\", \"test2.txt\"}) {\n            String s = new String(Files.readAllBytes(Paths.get(fn)));\n            s = s.replace(\"Goodbye London!\", \"Hello New York!\");\n            try (FileWriter fw = new FileWriter(fn)) {\n                fw.write(s);\n            }\n        }\n    }\n}\n"}
{"id": 35780, "name": "Globally replace text in several files", "source": "Translate Ruby to Python: var names = %w(\n                a.txt\n                b.txt\n                c.txt\n              )\n\u00a0\nnames.map{ File(_) }.each { |file|\n    say file.edit { |line|\n        line.gsub(\"Goodbye London!\", \"Hello New York!\")\n    }\n}\n", "target": "import fileinput\n\nfor line in fileinput.input(inplace=True):\n    print(line.replace('Goodbye London!', 'Hello New York!'), end='')\n"}
{"id": 35781, "name": "Globally replace text in several files", "source": "Translate Ruby to Python: var names = %w(\n                a.txt\n                b.txt\n                c.txt\n              )\n\u00a0\nnames.map{ File(_) }.each { |file|\n    say file.edit { |line|\n        line.gsub(\"Goodbye London!\", \"Hello New York!\")\n    }\n}\n", "target": "import fileinput\n\nfor line in fileinput.input(inplace=True):\n    print(line.replace('Goodbye London!', 'Hello New York!'), end='')\n"}
{"id": 36182, "name": "Continued fraction", "source": "Translate Ruby to C#: require 'bigdecimal'\n\n\nsqrt2 = Object.new\ndef sqrt2.a(n); n == 1 ? 1 : 2; end\ndef sqrt2.b(n); 1; end\n\n\nnapier = Object.new\ndef napier.a(n); n == 1 ? 2 : n - 1; end\ndef napier.b(n); n == 1 ? 1 : n - 1; end\n\npi = Object.new\ndef pi.a(n); n == 1 ? 3 : 6; end\ndef pi.b(n); (2*n - 1)**2; end\n\n\n\n\ndef estimate(cfrac, prec)\n  last_result = nil\n  terms = prec\n\n  loop do\n    \n    result = cfrac.a(terms)\n    (terms - 1).downto(1) do |n|\n      a = BigDecimal cfrac.a(n)\n      b = BigDecimal cfrac.b(n)\n      digits = [b.div(result, 1).exponent + prec, 1].max\n      result = a + b.div(result, digits)\n    end\n    result = result.round(prec)\n\n    if result == last_result\n      return result\n    else\n      \n      last_result = result\n      terms *= 2\n    end\n  end\nend\n\nputs estimate(sqrt2, 50).to_s('F')\nputs estimate(napier, 50).to_s('F')\nputs estimate(pi, 10).to_s('F')\n", "target": "using System;\nusing System.Collections.Generic;\n\nnamespace ContinuedFraction {\n    class Program {\n        static double Calc(Func<int, int[]> f, int n) {\n            double temp = 0.0;\n            for (int ni = n; ni >= 1; ni--) {\n                int[] p = f(ni);\n                temp = p[1] / (p[0] + temp);\n            }\n            return f(0)[0] + temp;\n        }\n\n        static void Main(string[] args) {\n            List<Func<int, int[]>> fList = new List<Func<int, int[]>>();\n            fList.Add(n => new int[] { n > 0 ? 2 : 1, 1 });\n            fList.Add(n => new int[] { n > 0 ? n : 2, n > 1 ? (n - 1) : 1 });\n            fList.Add(n => new int[] { n > 0 ? 6 : 3, (int) Math.Pow(2 * n - 1, 2) });\n\n            foreach (var f in fList) {\n                Console.WriteLine(Calc(f, 200));\n            }\n        }\n    }\n}\n"}
{"id": 36183, "name": "Continued fraction", "source": "Translate Ruby to C#: require 'bigdecimal'\n\n\nsqrt2 = Object.new\ndef sqrt2.a(n); n == 1 ? 1 : 2; end\ndef sqrt2.b(n); 1; end\n\n\nnapier = Object.new\ndef napier.a(n); n == 1 ? 2 : n - 1; end\ndef napier.b(n); n == 1 ? 1 : n - 1; end\n\npi = Object.new\ndef pi.a(n); n == 1 ? 3 : 6; end\ndef pi.b(n); (2*n - 1)**2; end\n\n\n\n\ndef estimate(cfrac, prec)\n  last_result = nil\n  terms = prec\n\n  loop do\n    \n    result = cfrac.a(terms)\n    (terms - 1).downto(1) do |n|\n      a = BigDecimal cfrac.a(n)\n      b = BigDecimal cfrac.b(n)\n      digits = [b.div(result, 1).exponent + prec, 1].max\n      result = a + b.div(result, digits)\n    end\n    result = result.round(prec)\n\n    if result == last_result\n      return result\n    else\n      \n      last_result = result\n      terms *= 2\n    end\n  end\nend\n\nputs estimate(sqrt2, 50).to_s('F')\nputs estimate(napier, 50).to_s('F')\nputs estimate(pi, 10).to_s('F')\n", "target": "using System;\nusing System.Collections.Generic;\n\nnamespace ContinuedFraction {\n    class Program {\n        static double Calc(Func<int, int[]> f, int n) {\n            double temp = 0.0;\n            for (int ni = n; ni >= 1; ni--) {\n                int[] p = f(ni);\n                temp = p[1] / (p[0] + temp);\n            }\n            return f(0)[0] + temp;\n        }\n\n        static void Main(string[] args) {\n            List<Func<int, int[]>> fList = new List<Func<int, int[]>>();\n            fList.Add(n => new int[] { n > 0 ? 2 : 1, 1 });\n            fList.Add(n => new int[] { n > 0 ? n : 2, n > 1 ? (n - 1) : 1 });\n            fList.Add(n => new int[] { n > 0 ? 6 : 3, (int) Math.Pow(2 * n - 1, 2) });\n\n            foreach (var f in fList) {\n                Console.WriteLine(Calc(f, 200));\n            }\n        }\n    }\n}\n"}
{"id": 36186, "name": "Continued fraction", "source": "Translate Ruby to Java: require 'bigdecimal'\n\n\nsqrt2 = Object.new\ndef sqrt2.a(n); n == 1 ? 1 : 2; end\ndef sqrt2.b(n); 1; end\n\n\nnapier = Object.new\ndef napier.a(n); n == 1 ? 2 : n - 1; end\ndef napier.b(n); n == 1 ? 1 : n - 1; end\n\npi = Object.new\ndef pi.a(n); n == 1 ? 3 : 6; end\ndef pi.b(n); (2*n - 1)**2; end\n\n\n\n\ndef estimate(cfrac, prec)\n  last_result = nil\n  terms = prec\n\n  loop do\n    \n    result = cfrac.a(terms)\n    (terms - 1).downto(1) do |n|\n      a = BigDecimal cfrac.a(n)\n      b = BigDecimal cfrac.b(n)\n      digits = [b.div(result, 1).exponent + prec, 1].max\n      result = a + b.div(result, digits)\n    end\n    result = result.round(prec)\n\n    if result == last_result\n      return result\n    else\n      \n      last_result = result\n      terms *= 2\n    end\n  end\nend\n\nputs estimate(sqrt2, 50).to_s('F')\nputs estimate(napier, 50).to_s('F')\nputs estimate(pi, 10).to_s('F')\n", "target": "import static java.lang.Math.pow;\nimport java.util.*;\nimport java.util.function.Function;\n\npublic class Test {\n    static double calc(Function<Integer, Integer[]> f, int n) {\n        double temp = 0;\n\n        for (int ni = n; ni >= 1; ni--) {\n            Integer[] p = f.apply(ni);\n            temp = p[1] / (double) (p[0] + temp);\n        }\n        return f.apply(0)[0] + temp;\n    }\n\n    public static void main(String[] args) {\n        List<Function<Integer, Integer[]>> fList = new ArrayList<>();\n        fList.add(n -> new Integer[]{n > 0 ? 2 : 1, 1});\n        fList.add(n -> new Integer[]{n > 0 ? n : 2, n > 1 ? (n - 1) : 1});\n        fList.add(n -> new Integer[]{n > 0 ? 6 : 3, (int) pow(2 * n - 1, 2)});\n\n        for (Function<Integer, Integer[]> f : fList)\n            System.out.println(calc(f, 200));\n    }\n}\n"}
{"id": 36187, "name": "Continued fraction", "source": "Translate Ruby to Java: require 'bigdecimal'\n\n\nsqrt2 = Object.new\ndef sqrt2.a(n); n == 1 ? 1 : 2; end\ndef sqrt2.b(n); 1; end\n\n\nnapier = Object.new\ndef napier.a(n); n == 1 ? 2 : n - 1; end\ndef napier.b(n); n == 1 ? 1 : n - 1; end\n\npi = Object.new\ndef pi.a(n); n == 1 ? 3 : 6; end\ndef pi.b(n); (2*n - 1)**2; end\n\n\n\n\ndef estimate(cfrac, prec)\n  last_result = nil\n  terms = prec\n\n  loop do\n    \n    result = cfrac.a(terms)\n    (terms - 1).downto(1) do |n|\n      a = BigDecimal cfrac.a(n)\n      b = BigDecimal cfrac.b(n)\n      digits = [b.div(result, 1).exponent + prec, 1].max\n      result = a + b.div(result, digits)\n    end\n    result = result.round(prec)\n\n    if result == last_result\n      return result\n    else\n      \n      last_result = result\n      terms *= 2\n    end\n  end\nend\n\nputs estimate(sqrt2, 50).to_s('F')\nputs estimate(napier, 50).to_s('F')\nputs estimate(pi, 10).to_s('F')\n", "target": "import static java.lang.Math.pow;\nimport java.util.*;\nimport java.util.function.Function;\n\npublic class Test {\n    static double calc(Function<Integer, Integer[]> f, int n) {\n        double temp = 0;\n\n        for (int ni = n; ni >= 1; ni--) {\n            Integer[] p = f.apply(ni);\n            temp = p[1] / (double) (p[0] + temp);\n        }\n        return f.apply(0)[0] + temp;\n    }\n\n    public static void main(String[] args) {\n        List<Function<Integer, Integer[]>> fList = new ArrayList<>();\n        fList.add(n -> new Integer[]{n > 0 ? 2 : 1, 1});\n        fList.add(n -> new Integer[]{n > 0 ? n : 2, n > 1 ? (n - 1) : 1});\n        fList.add(n -> new Integer[]{n > 0 ? 6 : 3, (int) pow(2 * n - 1, 2)});\n\n        for (Function<Integer, Integer[]> f : fList)\n            System.out.println(calc(f, 200));\n    }\n}\n"}
{"id": 36188, "name": "Continued fraction", "source": "Translate Ruby to Python: require 'bigdecimal'\n\n\nsqrt2 = Object.new\ndef sqrt2.a(n); n == 1 ? 1 : 2; end\ndef sqrt2.b(n); 1; end\n\n\nnapier = Object.new\ndef napier.a(n); n == 1 ? 2 : n - 1; end\ndef napier.b(n); n == 1 ? 1 : n - 1; end\n\npi = Object.new\ndef pi.a(n); n == 1 ? 3 : 6; end\ndef pi.b(n); (2*n - 1)**2; end\n\n\n\n\ndef estimate(cfrac, prec)\n  last_result = nil\n  terms = prec\n\n  loop do\n    \n    result = cfrac.a(terms)\n    (terms - 1).downto(1) do |n|\n      a = BigDecimal cfrac.a(n)\n      b = BigDecimal cfrac.b(n)\n      digits = [b.div(result, 1).exponent + prec, 1].max\n      result = a + b.div(result, digits)\n    end\n    result = result.round(prec)\n\n    if result == last_result\n      return result\n    else\n      \n      last_result = result\n      terms *= 2\n    end\n  end\nend\n\nputs estimate(sqrt2, 50).to_s('F')\nputs estimate(napier, 50).to_s('F')\nputs estimate(pi, 10).to_s('F')\n", "target": "from fractions import Fraction\nimport itertools\ntry: zip = itertools.izip\nexcept: pass\n \n\ndef CF(a, b, t):\n  terms = list(itertools.islice(zip(a, b), t))\n  z = Fraction(1,1)\n  for a, b in reversed(terms):\n    z = a + b / z\n  return z\n \n\ndef pRes(x, d):\n  q, x = divmod(x, 1)\n  res = str(q)\n  res += \".\"\n  for i in range(d):\n    x *= 10\n    q, x = divmod(x, 1)\n    res += str(q)\n  return res\n \n\ndef sqrt2_a():\n  yield 1\n  for x in itertools.repeat(2):\n    yield x\n \ndef sqrt2_b():\n  for x in itertools.repeat(1):\n    yield x\n \ncf = CF(sqrt2_a(), sqrt2_b(), 950)\nprint(pRes(cf, 200))\n\n \n \n\ndef Napier_a():\n  yield 2\n  for x in itertools.count(1):\n    yield x\n \ndef Napier_b():\n  yield 1\n  for x in itertools.count(1):\n    yield x\n \ncf = CF(Napier_a(), Napier_b(), 950)\nprint(pRes(cf, 200))\n\n \n\ndef Pi_a():\n  yield 3\n  for x in itertools.repeat(6):\n    yield x\n \ndef Pi_b():\n  for x in itertools.count(1,2):\n    yield x*x\n \ncf = CF(Pi_a(), Pi_b(), 950)\nprint(pRes(cf, 10))\n\n"}
{"id": 36189, "name": "Continued fraction", "source": "Translate Ruby to Python: require 'bigdecimal'\n\n\nsqrt2 = Object.new\ndef sqrt2.a(n); n == 1 ? 1 : 2; end\ndef sqrt2.b(n); 1; end\n\n\nnapier = Object.new\ndef napier.a(n); n == 1 ? 2 : n - 1; end\ndef napier.b(n); n == 1 ? 1 : n - 1; end\n\npi = Object.new\ndef pi.a(n); n == 1 ? 3 : 6; end\ndef pi.b(n); (2*n - 1)**2; end\n\n\n\n\ndef estimate(cfrac, prec)\n  last_result = nil\n  terms = prec\n\n  loop do\n    \n    result = cfrac.a(terms)\n    (terms - 1).downto(1) do |n|\n      a = BigDecimal cfrac.a(n)\n      b = BigDecimal cfrac.b(n)\n      digits = [b.div(result, 1).exponent + prec, 1].max\n      result = a + b.div(result, digits)\n    end\n    result = result.round(prec)\n\n    if result == last_result\n      return result\n    else\n      \n      last_result = result\n      terms *= 2\n    end\n  end\nend\n\nputs estimate(sqrt2, 50).to_s('F')\nputs estimate(napier, 50).to_s('F')\nputs estimate(pi, 10).to_s('F')\n", "target": "from fractions import Fraction\nimport itertools\ntry: zip = itertools.izip\nexcept: pass\n \n\ndef CF(a, b, t):\n  terms = list(itertools.islice(zip(a, b), t))\n  z = Fraction(1,1)\n  for a, b in reversed(terms):\n    z = a + b / z\n  return z\n \n\ndef pRes(x, d):\n  q, x = divmod(x, 1)\n  res = str(q)\n  res += \".\"\n  for i in range(d):\n    x *= 10\n    q, x = divmod(x, 1)\n    res += str(q)\n  return res\n \n\ndef sqrt2_a():\n  yield 1\n  for x in itertools.repeat(2):\n    yield x\n \ndef sqrt2_b():\n  for x in itertools.repeat(1):\n    yield x\n \ncf = CF(sqrt2_a(), sqrt2_b(), 950)\nprint(pRes(cf, 200))\n\n \n \n\ndef Napier_a():\n  yield 2\n  for x in itertools.count(1):\n    yield x\n \ndef Napier_b():\n  yield 1\n  for x in itertools.count(1):\n    yield x\n \ncf = CF(Napier_a(), Napier_b(), 950)\nprint(pRes(cf, 200))\n\n \n\ndef Pi_a():\n  yield 3\n  for x in itertools.repeat(6):\n    yield x\n \ndef Pi_b():\n  for x in itertools.count(1,2):\n    yield x*x\n \ncf = CF(Pi_a(), Pi_b(), 950)\nprint(pRes(cf, 10))\n\n"}
{"id": 36672, "name": "Quine", "source": "Translate Ruby to C#: _=\"_=%p;puts _%%_\";puts _%_\n", "target": "class Program { static void Main() { var s = \"class Program {{ static void Main() {{ var s = {0}{1}{0}; System.Console.WriteLine(s, (char)34, s); }} }}\"; System.Console.WriteLine(s, (char)34, s); } }\n"}
{"id": 36673, "name": "Quine", "source": "Translate Ruby to C#: _=\"_=%p;puts _%%_\";puts _%_\n", "target": "class Program { static void Main() { var s = \"class Program {{ static void Main() {{ var s = {0}{1}{0}; System.Console.WriteLine(s, (char)34, s); }} }}\"; System.Console.WriteLine(s, (char)34, s); } }\n"}
{"id": 36676, "name": "Quine", "source": "Translate Ruby to Java: _=\"_=%p;puts _%%_\";puts _%_\n", "target": "module test\n    {\n    @Inject Console console;\n    void run()\n        {\n        console.print($./test.x);\n        }\n    }\n"}
{"id": 36677, "name": "Quine", "source": "Translate Ruby to Java: _=\"_=%p;puts _%%_\";puts _%_\n", "target": "module test\n    {\n    @Inject Console console;\n    void run()\n        {\n        console.print($./test.x);\n        }\n    }\n"}
{"id": 36678, "name": "Quine", "source": "Translate Ruby to Python: _=\"_=%p;puts _%%_\";puts _%_\n", "target": "w = \"print('w = ' + chr(34) + w + chr(34) + chr(10) + w)\"\nprint('w = ' + chr(34) + w + chr(34) + chr(10) + w)\n"}
{"id": 36679, "name": "Quine", "source": "Translate Ruby to Python: _=\"_=%p;puts _%%_\";puts _%_\n", "target": "w = \"print('w = ' + chr(34) + w + chr(34) + chr(10) + w)\"\nprint('w = ' + chr(34) + w + chr(34) + chr(10) + w)\n"}
{"id": 36937, "name": "Munching squares", "source": "Translate Ruby to C#: load 'raster_graphics.rb'\n\nclass Pixmap\n  def self.xor_pattern(width, height, rgb1, rgb2)\n    \n    size = 256\n    colours = Array.new(size) do |i|\n      RGBColour.new(\n        (rgb1.red + (rgb2.red - rgb1.red) * i / size), \n        (rgb1.green + (rgb2.green - rgb1.green) * i / size), \n        (rgb1.blue + (rgb2.blue - rgb1.blue) * i / size), \n      )\n    end\n\n    \n    pixmap = new(width, height)\n    pixmap.each_pixel do |x, y|\n      pixmap[x,y] = colours[(x^y)%size]\n    end\n    pixmap\n  end\nend\n\nimg = Pixmap.xor_pattern(384, 384, RGBColour::RED, RGBColour::YELLOW)\nimg.save_as_png('xorpattern.png')\n", "target": "using System.Drawing;\nusing System.Drawing.Imaging;\nusing System.Linq;\n\nclass XORPattern\n{\n    static void Main()\n    {\n        var size = 0x100;\n        var black = Color.Black.ToArgb();\n        var palette = Enumerable.Range(black, size).Select(Color.FromArgb).ToArray();\n        using (var image = new Bitmap(size, size))\n        {\n            for (var x = 0; x < size; x++)\n            {\n                for (var y = 0; y < size; y++)\n                {\n                    image.SetPixel(x, y, palette[x ^ y]);\n                }\n            }\n            image.Save(\"XORPatternCSharp.png\", ImageFormat.Png);\n        }\n    }\n}\n"}
{"id": 36939, "name": "Munching squares", "source": "Translate Ruby to Java: load 'raster_graphics.rb'\n\nclass Pixmap\n  def self.xor_pattern(width, height, rgb1, rgb2)\n    \n    size = 256\n    colours = Array.new(size) do |i|\n      RGBColour.new(\n        (rgb1.red + (rgb2.red - rgb1.red) * i / size), \n        (rgb1.green + (rgb2.green - rgb1.green) * i / size), \n        (rgb1.blue + (rgb2.blue - rgb1.blue) * i / size), \n      )\n    end\n\n    \n    pixmap = new(width, height)\n    pixmap.each_pixel do |x, y|\n      pixmap[x,y] = colours[(x^y)%size]\n    end\n    pixmap\n  end\nend\n\nimg = Pixmap.xor_pattern(384, 384, RGBColour::RED, RGBColour::YELLOW)\nimg.save_as_png('xorpattern.png')\n", "target": "import java.awt.Color;\nimport java.awt.Graphics;\n\nimport javax.swing.JFrame;\nimport javax.swing.JPanel;\n\npublic class XorPattern extends JFrame{\n    private JPanel xorPanel;\n\n    public XorPattern(){\n        xorPanel = new JPanel(){\n            @Override\n            public void paint(Graphics g) {\n                for(int y = 0; y < getHeight();y++){\n                    for(int x = 0; x < getWidth();x++){\n                        g.setColor(new Color(0, (x ^ y) % 256, 0));\n                        g.drawLine(x, y, x, y);\n                    }\n                }\n            }\n        };\n        add(xorPanel);\n        setSize(300, 300);\n        setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n        setVisible(true);\n    }\n\n    public static void main(String[] args){\n        new XorPattern();\n    }\n}\n"}
{"id": 36940, "name": "Munching squares", "source": "Translate Ruby to Python: load 'raster_graphics.rb'\n\nclass Pixmap\n  def self.xor_pattern(width, height, rgb1, rgb2)\n    \n    size = 256\n    colours = Array.new(size) do |i|\n      RGBColour.new(\n        (rgb1.red + (rgb2.red - rgb1.red) * i / size), \n        (rgb1.green + (rgb2.green - rgb1.green) * i / size), \n        (rgb1.blue + (rgb2.blue - rgb1.blue) * i / size), \n      )\n    end\n\n    \n    pixmap = new(width, height)\n    pixmap.each_pixel do |x, y|\n      pixmap[x,y] = colours[(x^y)%size]\n    end\n    pixmap\n  end\nend\n\nimg = Pixmap.xor_pattern(384, 384, RGBColour::RED, RGBColour::YELLOW)\nimg.save_as_png('xorpattern.png')\n", "target": "import Image, ImageDraw\n\nimage = Image.new(\"RGB\", (256, 256))\ndrawingTool = ImageDraw.Draw(image)\n\nfor x in range(256):\n    for y in range(256):\n        drawingTool.point((x, y), (0, x^y, 0))\n\ndel drawingTool\nimage.save(\"xorpic.png\", \"PNG\")\n"}
{"id": 37081, "name": "Problem of Apollonius", "source": "Translate Ruby to C#: class Circle\n  def initialize(x, y, r)\n    @x, @y, @r = [x, y, r].map(&:to_f)\n  end\n  attr_reader :x, :y, :r\n  \n  def self.apollonius(c1, c2, c3, s1=1, s2=1, s3=1)\n    x1, y1, r1 = c1.x, c1.y, c1.r\n    x2, y2, r2 = c2.x, c2.y, c2.r\n    x3, y3, r3 = c3.x, c3.y, c3.r\n    \n    v11 = 2*x2 - 2*x1\n    v12 = 2*y2 - 2*y1\n    v13 = x1**2 - x2**2 + y1**2 - y2**2 - r1**2 + r2**2\n    v14 = 2*s2*r2 - 2*s1*r1\n    \n    v21 = 2*x3 - 2*x2\n    v22 = 2*y3 - 2*y2\n    v23 = x2**2 - x3**2 + y2**2 - y3**2 - r2**2 + r3**2\n    v24 = 2*s3*r3 - 2*s2*r2\n    \n    w12 = v12/v11\n    w13 = v13/v11\n    w14 = v14/v11\n    \n    w22 = v22/v21 - w12\n    w23 = v23/v21 - w13\n    w24 = v24/v21 - w14\n    \n    p = -w23/w22\n    q = w24/w22\n    m = -w12*p - w13\n    n = w14 - w12*q\n    \n    a = n**2 + q**2 - 1\n    b = 2*m*n - 2*n*x1 + 2*p*q - 2*q*y1 + 2*s1*r1\n    c = x1**2 + m**2 - 2*m*x1 + p**2 + y1**2 - 2*p*y1 - r1**2\n    \n    d = b**2 - 4*a*c\n    rs = (-b - Math.sqrt(d)) / (2*a)\n    xs = m + n*rs\n    ys = p + q*rs\n    \n    self.new(xs, ys, rs)\n  end\n  \n  def to_s\n    \"Circle: x=\n  end\nend\n\nputs c1 = Circle.new(0, 0, 1)\nputs c2 = Circle.new(2, 4, 2)\nputs c3 = Circle.new(4, 0, 1)\n\nputs Circle.apollonius(c1, c2, c3)\nputs Circle.apollonius(c1, c2, c3, -1, -1, -1)\n", "target": "using System;\n\nnamespace ApolloniusProblemCalc\n{\n    class Program\n    {\n        static float rs = 0;\n        static float xs = 0;\n        static float ys = 0;\n\n        public static void Main(string[] args)\n        {\n            float gx1;\n            float gy1;\n            float gr1;\n            float gx2;\n            float gy2;\n            float gr2;\n            float gx3;\n            float gy3;\n            float gr3;\n\n            \n            gx1 = 0;\n            gy1 = 0;\n            gr1 = 1;\n            gx2 = 4;\n            gy2 = 0;\n            gr2 = 1;\n            gx3 = 2;\n            gy3 = 4;\n            gr3 = 2;\n            \n\n            for (int i = 1; i <= 8; i++)\n            {\n                SolveTheApollonius(i, gx1, gy1, gr1, gx2, gy2, gr2, gx3, gy3, gr3);\n\n\n                if (i == 1)\n                {\n                    Console.WriteLine(\"X of point of the \" + i + \"st solution: \" + xs.ToString());\n                    Console.WriteLine(\"Y of point of the \" + i + \"st solution: \" + ys.ToString());\n                    Console.WriteLine(i + \"st Solution circle's radius: \" + rs.ToString());\n                }\n                else if (i == 2)\n                {\n                    Console.WriteLine(\"X of point of the \" + i + \"ed solution: \" + xs.ToString());\n                    Console.WriteLine(\"Y of point of the \" + i + \"ed solution: \" + ys.ToString());\n                    Console.WriteLine(i + \"ed Solution circle's radius: \" + rs.ToString());\n                }\n                else if(i == 3)\n                {\n                    Console.WriteLine(\"X of point of the \" + i + \"rd solution: \" + xs.ToString());\n                    Console.WriteLine(\"Y of point of the \" + i + \"rd solution: \" + ys.ToString());\n                    Console.WriteLine(i + \"rd Solution circle's radius: \" + rs.ToString());\n                }\n                else\n                {\n                    Console.WriteLine(\"X of point of the \" + i + \"th solution: \" + xs.ToString());\n                    Console.WriteLine(\"Y of point of the \" + i + \"th solution: \" + ys.ToString());\n                    Console.WriteLine(i + \"th Solution circle's radius: \" + rs.ToString());\n                }\n\n                Console.WriteLine();\n            }\n\n\n            Console.ReadKey(true);\n        }\n\n        private static void SolveTheApollonius(int calcCounter, float x1, float y1, float r1, float x2, float y2, float r2, float x3, float y3, float r3)\n        {\n            float s1 = 1;\n            float s2 = 1;\n            float s3 = 1;\n\n            if (calcCounter == 2)\n            {\n                s1 = -1;\n                s2 = -1;\n                s3 = -1;\n            }\n            else if (calcCounter == 3)\n            {\n                s1 = 1;\n                s2 = -1;\n                s3 = -1;\n            }\n            else if (calcCounter == 4)\n            {\n                s1 = -1;\n                s2 = 1;\n                s3 = -1;\n            }\n            else if (calcCounter == 5)\n            {\n                s1 = -1;\n                s2 = -1;\n                s3 = 1;\n            }\n            else if (calcCounter == 6)\n            {\n                s1 = 1;\n                s2 = 1;\n                s3 = -1;\n            }\n            else if (calcCounter == 7)\n            {\n                s1 = -1;\n                s2 = 1;\n                s3 = 1;\n            }\n            else if (calcCounter == 8)\n            {\n                s1 = 1;\n                s2 = -1;\n                s3 = 1;\n            }\n\n            \n            float v11 = 2 * x2 - 2 * x1;\n            float v12 = 2 * y2 - 2 * y1;\n            float v13 = x1 * x1 - x2 * x2 + y1 * y1 - y2 * y2 - r1 * r1 + r2 * r2;\n            float v14 = 2 * s2 * r2 - 2 * s1 * r1;\n\n            float v21 = 2 * x3 - 2 * x2;\n            float v22 = 2 * y3 - 2 * y2;\n            float v23 = x2 * x2 - x3 * x3 + y2 * y2 - y3 * y3 - r2 * r2 + r3 * r3;\n            float v24 = 2 * s3 * r3 - 2 * s2 * r2;\n\n            float w12 = v12 / v11;\n            float w13 = v13 / v11;\n            float w14 = v14 / v11;\n\n            float w22 = v22 / v21 - w12;\n            float w23 = v23 / v21 - w13;\n            float w24 = v24 / v21 - w14;\n\n            float P = -w23 / w22;\n            float Q = w24 / w22;\n            float M = -w12 * P - w13;\n            float N = w14 - w12 * Q;\n\n            float a = N * N + Q * Q - 1;\n            float b = 2 * M * N - 2 * N * x1 + 2 * P * Q - 2 * Q * y1 + 2 * s1 * r1;\n            float c = x1 * x1 + M * M - 2 * M * x1 + P * P + y1 * y1 - 2 * P * y1 - r1 * r1;\n\n            float D = b * b - 4 * a * c;\n\n            rs = (-b - float.Parse(Math.Sqrt(D).ToString())) / (2 * float.Parse(a.ToString()));\n            xs = M + N * rs;\n            ys = P + Q * rs;\n        }\n    }\n}\n"}
{"id": 37082, "name": "Problem of Apollonius", "source": "Translate Ruby to Java: class Circle\n  def initialize(x, y, r)\n    @x, @y, @r = [x, y, r].map(&:to_f)\n  end\n  attr_reader :x, :y, :r\n  \n  def self.apollonius(c1, c2, c3, s1=1, s2=1, s3=1)\n    x1, y1, r1 = c1.x, c1.y, c1.r\n    x2, y2, r2 = c2.x, c2.y, c2.r\n    x3, y3, r3 = c3.x, c3.y, c3.r\n    \n    v11 = 2*x2 - 2*x1\n    v12 = 2*y2 - 2*y1\n    v13 = x1**2 - x2**2 + y1**2 - y2**2 - r1**2 + r2**2\n    v14 = 2*s2*r2 - 2*s1*r1\n    \n    v21 = 2*x3 - 2*x2\n    v22 = 2*y3 - 2*y2\n    v23 = x2**2 - x3**2 + y2**2 - y3**2 - r2**2 + r3**2\n    v24 = 2*s3*r3 - 2*s2*r2\n    \n    w12 = v12/v11\n    w13 = v13/v11\n    w14 = v14/v11\n    \n    w22 = v22/v21 - w12\n    w23 = v23/v21 - w13\n    w24 = v24/v21 - w14\n    \n    p = -w23/w22\n    q = w24/w22\n    m = -w12*p - w13\n    n = w14 - w12*q\n    \n    a = n**2 + q**2 - 1\n    b = 2*m*n - 2*n*x1 + 2*p*q - 2*q*y1 + 2*s1*r1\n    c = x1**2 + m**2 - 2*m*x1 + p**2 + y1**2 - 2*p*y1 - r1**2\n    \n    d = b**2 - 4*a*c\n    rs = (-b - Math.sqrt(d)) / (2*a)\n    xs = m + n*rs\n    ys = p + q*rs\n    \n    self.new(xs, ys, rs)\n  end\n  \n  def to_s\n    \"Circle: x=\n  end\nend\n\nputs c1 = Circle.new(0, 0, 1)\nputs c2 = Circle.new(2, 4, 2)\nputs c3 = Circle.new(4, 0, 1)\n\nputs Circle.apollonius(c1, c2, c3)\nputs Circle.apollonius(c1, c2, c3, -1, -1, -1)\n", "target": "public class Circle\n{\n public double[] center;\n public double radius;\n public Circle(double[] center, double radius)\n {\n  this.center = center;\n  this.radius = radius;\n }\n public String toString()\n {\n  return String.format(\"Circle[x=%.2f,y=%.2f,r=%.2f]\",center[0],center[1],\n\t\t       radius);\n }\n}\n\npublic class ApolloniusSolver\n{\n\n public static Circle solveApollonius(Circle c1, Circle c2, Circle c3, int s1,\n\t\t\t\t      int s2, int s3)\n {\n  float x1 = c1.center[0];\n  float y1 = c1.center[1];\n  float r1 = c1.radius;\n  float x2 = c2.center[0];\n  float y2 = c2.center[1];\n  float r2 = c2.radius;\n  float x3 = c3.center[0];\n  float y3 = c3.center[1];\n  float r3 = c3.radius;\n\n  \n  \n  float v11 = 2*x2 - 2*x1;\n  float v12 = 2*y2 - 2*y1;\n  float v13 = x1*x1 - x2*x2 + y1*y1 - y2*y2 - r1*r1 + r2*r2;\n  float v14 = 2*s2*r2 - 2*s1*r1;\n\n  float v21 = 2*x3 - 2*x2;\n  float v22 = 2*y3 - 2*y2;\n  float v23 = x2*x2 - x3*x3 + y2*y2 - y3*y3 - r2*r2 + r3*r3;\n  float v24 = 2*s3*r3 - 2*s2*r2;\n\n  float w12 = v12/v11;\n  float w13 = v13/v11;\n  float w14 = v14/v11;\n\n  float w22 = v22/v21-w12;\n  float w23 = v23/v21-w13;\n  float w24 = v24/v21-w14;\n\n  float P = -w23/w22;\n  float Q = w24/w22;\n  float M = -w12*P-w13;\n  float N = w14 - w12*Q;\n\n  float a = N*N + Q*Q - 1;\n  float b = 2*M*N - 2*N*x1 + 2*P*Q - 2*Q*y1 + 2*s1*r1;\n  float c = x1*x1 + M*M - 2*M*x1 + P*P + y1*y1 - 2*P*y1 - r1*r1;\n\n  \n  \n  float D = b*b-4*a*c;\n  float rs = (-b-Math.sqrt(D))/(2*a);\n  float xs = M + N * rs;\n  float ys = P + Q * rs;\n  return new Circle(new double[]{xs,ys}, rs);\n }\n public static void main(final String[] args)\n {\n  Circle c1 = new Circle(new double[]{0,0}, 1);\n  Circle c2 = new Circle(new double[]{4,0}, 1);\n  Circle c3 = new Circle(new double[]{2,4}, 2);\n  \n  System.out.println(solveApollonius(c1,c2,c3,1,1,1));\n  \n  System.out.println(solveApollonius(c1,c2,c3,-1,-1,-1));\n }\n}\n"}
{"id": 37083, "name": "Problem of Apollonius", "source": "Translate Ruby to Python: class Circle\n  def initialize(x, y, r)\n    @x, @y, @r = [x, y, r].map(&:to_f)\n  end\n  attr_reader :x, :y, :r\n  \n  def self.apollonius(c1, c2, c3, s1=1, s2=1, s3=1)\n    x1, y1, r1 = c1.x, c1.y, c1.r\n    x2, y2, r2 = c2.x, c2.y, c2.r\n    x3, y3, r3 = c3.x, c3.y, c3.r\n    \n    v11 = 2*x2 - 2*x1\n    v12 = 2*y2 - 2*y1\n    v13 = x1**2 - x2**2 + y1**2 - y2**2 - r1**2 + r2**2\n    v14 = 2*s2*r2 - 2*s1*r1\n    \n    v21 = 2*x3 - 2*x2\n    v22 = 2*y3 - 2*y2\n    v23 = x2**2 - x3**2 + y2**2 - y3**2 - r2**2 + r3**2\n    v24 = 2*s3*r3 - 2*s2*r2\n    \n    w12 = v12/v11\n    w13 = v13/v11\n    w14 = v14/v11\n    \n    w22 = v22/v21 - w12\n    w23 = v23/v21 - w13\n    w24 = v24/v21 - w14\n    \n    p = -w23/w22\n    q = w24/w22\n    m = -w12*p - w13\n    n = w14 - w12*q\n    \n    a = n**2 + q**2 - 1\n    b = 2*m*n - 2*n*x1 + 2*p*q - 2*q*y1 + 2*s1*r1\n    c = x1**2 + m**2 - 2*m*x1 + p**2 + y1**2 - 2*p*y1 - r1**2\n    \n    d = b**2 - 4*a*c\n    rs = (-b - Math.sqrt(d)) / (2*a)\n    xs = m + n*rs\n    ys = p + q*rs\n    \n    self.new(xs, ys, rs)\n  end\n  \n  def to_s\n    \"Circle: x=\n  end\nend\n\nputs c1 = Circle.new(0, 0, 1)\nputs c2 = Circle.new(2, 4, 2)\nputs c3 = Circle.new(4, 0, 1)\n\nputs Circle.apollonius(c1, c2, c3)\nputs Circle.apollonius(c1, c2, c3, -1, -1, -1)\n", "target": "from collections import namedtuple\nimport math\n\nCircle = namedtuple('Circle', 'x, y, r')\n \ndef solveApollonius(c1, c2, c3, s1, s2, s3):\n    \n    x1, y1, r1 = c1\n    x2, y2, r2 = c2\n    x3, y3, r3 = c3\n\n    v11 = 2*x2 - 2*x1\n    v12 = 2*y2 - 2*y1\n    v13 = x1*x1 - x2*x2 + y1*y1 - y2*y2 - r1*r1 + r2*r2\n    v14 = 2*s2*r2 - 2*s1*r1\n \n    v21 = 2*x3 - 2*x2\n    v22 = 2*y3 - 2*y2\n    v23 = x2*x2 - x3*x3 + y2*y2 - y3*y3 - r2*r2 + r3*r3\n    v24 = 2*s3*r3 - 2*s2*r2\n \n    w12 = v12/v11\n    w13 = v13/v11\n    w14 = v14/v11\n \n    w22 = v22/v21-w12\n    w23 = v23/v21-w13\n    w24 = v24/v21-w14\n \n    P = -w23/w22\n    Q = w24/w22\n    M = -w12*P-w13\n    N = w14 - w12*Q\n \n    a = N*N + Q*Q - 1\n    b = 2*M*N - 2*N*x1 + 2*P*Q - 2*Q*y1 + 2*s1*r1\n    c = x1*x1 + M*M - 2*M*x1 + P*P + y1*y1 - 2*P*y1 - r1*r1\n \n    \n    D = b*b-4*a*c\n    rs = (-b-math.sqrt(D))/(2*a)\n \n    xs = M+N*rs\n    ys = P+Q*rs\n \n    return Circle(xs, ys, rs)\n\nif __name__ == '__main__':\n    c1, c2, c3 = Circle(0, 0, 1), Circle(4, 0, 1), Circle(2, 4, 2)\n    print(solveApollonius(c1, c2, c3, 1, 1, 1))    \n    print(solveApollonius(c1, c2, c3, -1, -1, -1)) \n"}
{"id": 37324, "name": "Sequence of non-squares", "source": "Translate Ruby to C#: def f(n)\n  n + (0.5 + Math.sqrt(n)).floor\nend\n\n(1..22).each { |n| puts \"\n\nnon_squares = (1..1_000_000).map { |n| f(n) }\nsquares = (1..1001).map { |n| n**2 } \n(squares & non_squares).each do |n|\n  puts \"Oops, found a square f(\nend\n", "target": "using System;\nusing System.Diagnostics;\n\nnamespace sons\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            for (int i = 1; i < 23; i++)            \n                Console.WriteLine(nonsqr(i));            \n\n            for (int i = 1; i < 1000000; i++)\n            {\n                double j = Math.Sqrt(nonsqr(i));\n                Debug.Assert(j != Math.Floor(j),\"Square\");\n            }            \n        }\n\n        static int nonsqr(int i)\n        {\n            return (int)(i + Math.Floor(0.5 + Math.Sqrt(i)));\n        }\n    }\n}\n"}
{"id": 37326, "name": "Sequence of non-squares", "source": "Translate Ruby to Java: def f(n)\n  n + (0.5 + Math.sqrt(n)).floor\nend\n\n(1..22).each { |n| puts \"\n\nnon_squares = (1..1_000_000).map { |n| f(n) }\nsquares = (1..1001).map { |n| n**2 } \n(squares & non_squares).each do |n|\n  puts \"Oops, found a square f(\nend\n", "target": "public class SeqNonSquares {\n    public static int nonsqr(int n) {\n        return n + (int)Math.round(Math.sqrt(n));\n    }\n    \n    public static void main(String[] args) {\n        \n        for (int i = 1; i < 23; i++)\n            System.out.print(nonsqr(i) + \" \");\n        System.out.println();\n        \n        \n        for (int i = 1; i < 1000000; i++) {\n            double j = Math.sqrt(nonsqr(i));\n            assert j != Math.floor(j);\n        }\n    }\n}\n"}
{"id": 37327, "name": "Sequence of non-squares", "source": "Translate Ruby to Python: def f(n)\n  n + (0.5 + Math.sqrt(n)).floor\nend\n\n(1..22).each { |n| puts \"\n\nnon_squares = (1..1_000_000).map { |n| f(n) }\nsquares = (1..1001).map { |n| n**2 } \n(squares & non_squares).each do |n|\n  puts \"Oops, found a square f(\nend\n", "target": ">>> from math import floor, sqrt\n>>> def non_square(n):\n        return n + floor(1/2 + sqrt(n))\n\n>>> \n>>> print(*map(non_square, range(1, 23)))\n2 3 5 6 7 8 10 11 12 13 14 15 17 18 19 20 21 22 23 24 26 27\n\n>>> \n>>> def is_square(n):\n        return sqrt(n).is_integer()\n\n>>> non_squares = map(non_square, range(1, 10 ** 6))\n>>> next(filter(is_square, non_squares))\nStopIteration                             Traceback (most recent call last)\n<ipython-input-45-f32645fc1c0a> in <module>()\n      1 non_squares = map(non_square, range(1, 10 ** 6))\n----> 2 next(filter(is_square, non_squares))\n\nStopIteration:\n"}
{"id": 37690, "name": "Quaternion type", "source": "Translate Ruby to C#: class Quaternion\n  property a, b, c, d\n\n  def initialize(@a : Int64, @b : Int64, @c : Int64, @d : Int64) end\n\n  def norm; Math.sqrt(a**2 + b**2 + c**2 + d**2) end\n  def conj; Quaternion.new(a, -b, -c, -d)        end\n  def +(n)  Quaternion.new(a + n, b, c, d)       end\n  def -(n)  Quaternion.new(a - n, b, c, d)       end\n  def -()   Quaternion.new(-a, -b, -c, -d)       end\n  def *(n)  Quaternion.new(a * n, b * n, c * n, d * n) end\n  def ==(rhs : Quaternion) self.to_s == rhs.to_s end\n  def +(rhs : Quaternion)\n    Quaternion.new(a + rhs.a, b + rhs.b, c + rhs.c, d + rhs.d)\n  end\n\n  def -(rhs : Quaternion)\n    Quaternion.new(a - rhs.a, b - rhs.b, c - rhs.c, d - rhs.d)\n  end\n\n  def *(rhs : Quaternion)\n    Quaternion.new(\n      a * rhs.a - b * rhs.b - c * rhs.c - d * rhs.d,\n      a * rhs.b + b * rhs.a + c * rhs.d - d * rhs.c,\n      a * rhs.c - b * rhs.d + c * rhs.a + d * rhs.b,\n      a * rhs.d + b * rhs.c - c * rhs.b + d * rhs.a)\n  end\n\n  def to_s(io : IO) io << \"(\n  private def sgn(n)  n.sign|1 == 1 ? \"+ \nend\n\nstruct Number\n  def +(rhs : Quaternion)\n    Quaternion.new(rhs.a + self, rhs.b, rhs.c, rhs.d)\n  end\n\n  def -(rhs : Quaternion)\n    Quaternion.new(-rhs.a + self, -rhs.b, -rhs.c, -rhs.d)\n  end\n\n  def *(rhs : Quaternion)\n    Quaternion.new(rhs.a * self, rhs.b * self, rhs.c * self, rhs.d * self)\n  end\nend\n\nq0 = Quaternion.new(a: 1, b: 2, c: 3, d: 4)\nq1 = Quaternion.new(2, 3, 4, 5)\nq2 = Quaternion.new(3, 4, 5, 6)\nr  = 7\n\nputs \"q0 = \nputs \"q1 = \nputs \"q2 = \nputs \"r  = \nputs\nputs \"normal of q0 = \nputs \"-q0 = \nputs \"conjugate of q0 = \nputs \"q0 * (conjugate of q0) = \nputs \"(conjugate of q0) * q0 = \nputs\nputs \"r + q0 = \nputs \"q0 + r = \nputs\nputs \" q0 - r = \nputs \"-q0 - r = \nputs \" r - q0 = \nputs \"-q0 + r = \nputs\nputs \"r * q0 = \nputs \"q0 * r = \nputs\nputs \"q0 + q1 = \nputs \"q0 - q1 = \nputs \"q0 * q1 = \nputs\nputs \" q0 + q1 * q2  = \nputs \"(q0 + q1) * q2 = \nputs\nputs \" q0 *  q1  * q2 = \nputs \"(q0 *  q1) * q2 = \nputs \" q0 * (q1 * q2) = \nputs\nputs \"q1 * q2 = \nputs \"q2 * q1 = \nputs\nputs \"q1 * q2\u00a0!= q2 * q1 => \nputs \"q1 * q2 == q2 * q1 => \n", "target": "using System;\n\nstruct Quaternion : IEquatable<Quaternion>\n{\n    public readonly double A, B, C, D;\n\n    public Quaternion(double a, double b, double c, double d)\n    {\n        this.A = a;\n        this.B = b;\n        this.C = c;\n        this.D = d;\n    }\n\n    public double Norm()\n    {\n        return Math.Sqrt(A * A + B * B + C * C + D * D);\n    }\n\n    public static Quaternion operator -(Quaternion q)\n    {\n        return new Quaternion(-q.A, -q.B, -q.C, -q.D);\n    }\n\n    public Quaternion Conjugate()\n    {\n        return new Quaternion(A, -B, -C, -D);\n    }\n\n    \n    public static implicit operator Quaternion(double d)\n    {\n        return new Quaternion(d, 0, 0, 0);\n    }\n\n    public static Quaternion operator +(Quaternion q1, Quaternion q2)\n    {\n        return new Quaternion(q1.A + q2.A, q1.B + q2.B, q1.C + q2.C, q1.D + q2.D);\n    }\n\n    public static Quaternion operator *(Quaternion q1, Quaternion q2)\n    {\n        return new Quaternion(\n            q1.A * q2.A - q1.B * q2.B - q1.C * q2.C - q1.D * q2.D,\n            q1.A * q2.B + q1.B * q2.A + q1.C * q2.D - q1.D * q2.C,\n            q1.A * q2.C - q1.B * q2.D + q1.C * q2.A + q1.D * q2.B,\n            q1.A * q2.D + q1.B * q2.C - q1.C * q2.B + q1.D * q2.A);\n    }\n\n    public static bool operator ==(Quaternion q1, Quaternion q2)\n    {\n        return q1.A == q2.A && q1.B == q2.B && q1.C == q2.C && q1.D == q2.D;\n    }\n\n    public static bool operator !=(Quaternion q1, Quaternion q2)\n    {\n        return !(q1 == q2);\n    }\n\n    #region Object Members\n\n    public override bool Equals(object obj)\n    {\n        if (obj is Quaternion)\n            return Equals((Quaternion)obj);\n\n        return false;\n    }\n\n    public override int GetHashCode()\n    {\n        return A.GetHashCode() ^ B.GetHashCode() ^ C.GetHashCode() ^ D.GetHashCode();\n    }\n\n    public override string ToString()\n    {\n        return string.Format(\"Q({0}, {1}, {2}, {3})\", A, B, C, D);\n    }\n\n    #endregion\n\n    #region IEquatable<Quaternion> Members\n\n    public bool Equals(Quaternion other)\n    {\n        return other == this;\n    }\n\n    #endregion\n}\n"}
{"id": 37691, "name": "Quaternion type", "source": "Translate Ruby to C#: class Quaternion\n  property a, b, c, d\n\n  def initialize(@a : Int64, @b : Int64, @c : Int64, @d : Int64) end\n\n  def norm; Math.sqrt(a**2 + b**2 + c**2 + d**2) end\n  def conj; Quaternion.new(a, -b, -c, -d)        end\n  def +(n)  Quaternion.new(a + n, b, c, d)       end\n  def -(n)  Quaternion.new(a - n, b, c, d)       end\n  def -()   Quaternion.new(-a, -b, -c, -d)       end\n  def *(n)  Quaternion.new(a * n, b * n, c * n, d * n) end\n  def ==(rhs : Quaternion) self.to_s == rhs.to_s end\n  def +(rhs : Quaternion)\n    Quaternion.new(a + rhs.a, b + rhs.b, c + rhs.c, d + rhs.d)\n  end\n\n  def -(rhs : Quaternion)\n    Quaternion.new(a - rhs.a, b - rhs.b, c - rhs.c, d - rhs.d)\n  end\n\n  def *(rhs : Quaternion)\n    Quaternion.new(\n      a * rhs.a - b * rhs.b - c * rhs.c - d * rhs.d,\n      a * rhs.b + b * rhs.a + c * rhs.d - d * rhs.c,\n      a * rhs.c - b * rhs.d + c * rhs.a + d * rhs.b,\n      a * rhs.d + b * rhs.c - c * rhs.b + d * rhs.a)\n  end\n\n  def to_s(io : IO) io << \"(\n  private def sgn(n)  n.sign|1 == 1 ? \"+ \nend\n\nstruct Number\n  def +(rhs : Quaternion)\n    Quaternion.new(rhs.a + self, rhs.b, rhs.c, rhs.d)\n  end\n\n  def -(rhs : Quaternion)\n    Quaternion.new(-rhs.a + self, -rhs.b, -rhs.c, -rhs.d)\n  end\n\n  def *(rhs : Quaternion)\n    Quaternion.new(rhs.a * self, rhs.b * self, rhs.c * self, rhs.d * self)\n  end\nend\n\nq0 = Quaternion.new(a: 1, b: 2, c: 3, d: 4)\nq1 = Quaternion.new(2, 3, 4, 5)\nq2 = Quaternion.new(3, 4, 5, 6)\nr  = 7\n\nputs \"q0 = \nputs \"q1 = \nputs \"q2 = \nputs \"r  = \nputs\nputs \"normal of q0 = \nputs \"-q0 = \nputs \"conjugate of q0 = \nputs \"q0 * (conjugate of q0) = \nputs \"(conjugate of q0) * q0 = \nputs\nputs \"r + q0 = \nputs \"q0 + r = \nputs\nputs \" q0 - r = \nputs \"-q0 - r = \nputs \" r - q0 = \nputs \"-q0 + r = \nputs\nputs \"r * q0 = \nputs \"q0 * r = \nputs\nputs \"q0 + q1 = \nputs \"q0 - q1 = \nputs \"q0 * q1 = \nputs\nputs \" q0 + q1 * q2  = \nputs \"(q0 + q1) * q2 = \nputs\nputs \" q0 *  q1  * q2 = \nputs \"(q0 *  q1) * q2 = \nputs \" q0 * (q1 * q2) = \nputs\nputs \"q1 * q2 = \nputs \"q2 * q1 = \nputs\nputs \"q1 * q2\u00a0!= q2 * q1 => \nputs \"q1 * q2 == q2 * q1 => \n", "target": "using System;\n\nstruct Quaternion : IEquatable<Quaternion>\n{\n    public readonly double A, B, C, D;\n\n    public Quaternion(double a, double b, double c, double d)\n    {\n        this.A = a;\n        this.B = b;\n        this.C = c;\n        this.D = d;\n    }\n\n    public double Norm()\n    {\n        return Math.Sqrt(A * A + B * B + C * C + D * D);\n    }\n\n    public static Quaternion operator -(Quaternion q)\n    {\n        return new Quaternion(-q.A, -q.B, -q.C, -q.D);\n    }\n\n    public Quaternion Conjugate()\n    {\n        return new Quaternion(A, -B, -C, -D);\n    }\n\n    \n    public static implicit operator Quaternion(double d)\n    {\n        return new Quaternion(d, 0, 0, 0);\n    }\n\n    public static Quaternion operator +(Quaternion q1, Quaternion q2)\n    {\n        return new Quaternion(q1.A + q2.A, q1.B + q2.B, q1.C + q2.C, q1.D + q2.D);\n    }\n\n    public static Quaternion operator *(Quaternion q1, Quaternion q2)\n    {\n        return new Quaternion(\n            q1.A * q2.A - q1.B * q2.B - q1.C * q2.C - q1.D * q2.D,\n            q1.A * q2.B + q1.B * q2.A + q1.C * q2.D - q1.D * q2.C,\n            q1.A * q2.C - q1.B * q2.D + q1.C * q2.A + q1.D * q2.B,\n            q1.A * q2.D + q1.B * q2.C - q1.C * q2.B + q1.D * q2.A);\n    }\n\n    public static bool operator ==(Quaternion q1, Quaternion q2)\n    {\n        return q1.A == q2.A && q1.B == q2.B && q1.C == q2.C && q1.D == q2.D;\n    }\n\n    public static bool operator !=(Quaternion q1, Quaternion q2)\n    {\n        return !(q1 == q2);\n    }\n\n    #region Object Members\n\n    public override bool Equals(object obj)\n    {\n        if (obj is Quaternion)\n            return Equals((Quaternion)obj);\n\n        return false;\n    }\n\n    public override int GetHashCode()\n    {\n        return A.GetHashCode() ^ B.GetHashCode() ^ C.GetHashCode() ^ D.GetHashCode();\n    }\n\n    public override string ToString()\n    {\n        return string.Format(\"Q({0}, {1}, {2}, {3})\", A, B, C, D);\n    }\n\n    #endregion\n\n    #region IEquatable<Quaternion> Members\n\n    public bool Equals(Quaternion other)\n    {\n        return other == this;\n    }\n\n    #endregion\n}\n"}
{"id": 37694, "name": "Quaternion type", "source": "Translate Ruby to Java: class Quaternion\n  property a, b, c, d\n\n  def initialize(@a : Int64, @b : Int64, @c : Int64, @d : Int64) end\n\n  def norm; Math.sqrt(a**2 + b**2 + c**2 + d**2) end\n  def conj; Quaternion.new(a, -b, -c, -d)        end\n  def +(n)  Quaternion.new(a + n, b, c, d)       end\n  def -(n)  Quaternion.new(a - n, b, c, d)       end\n  def -()   Quaternion.new(-a, -b, -c, -d)       end\n  def *(n)  Quaternion.new(a * n, b * n, c * n, d * n) end\n  def ==(rhs : Quaternion) self.to_s == rhs.to_s end\n  def +(rhs : Quaternion)\n    Quaternion.new(a + rhs.a, b + rhs.b, c + rhs.c, d + rhs.d)\n  end\n\n  def -(rhs : Quaternion)\n    Quaternion.new(a - rhs.a, b - rhs.b, c - rhs.c, d - rhs.d)\n  end\n\n  def *(rhs : Quaternion)\n    Quaternion.new(\n      a * rhs.a - b * rhs.b - c * rhs.c - d * rhs.d,\n      a * rhs.b + b * rhs.a + c * rhs.d - d * rhs.c,\n      a * rhs.c - b * rhs.d + c * rhs.a + d * rhs.b,\n      a * rhs.d + b * rhs.c - c * rhs.b + d * rhs.a)\n  end\n\n  def to_s(io : IO) io << \"(\n  private def sgn(n)  n.sign|1 == 1 ? \"+ \nend\n\nstruct Number\n  def +(rhs : Quaternion)\n    Quaternion.new(rhs.a + self, rhs.b, rhs.c, rhs.d)\n  end\n\n  def -(rhs : Quaternion)\n    Quaternion.new(-rhs.a + self, -rhs.b, -rhs.c, -rhs.d)\n  end\n\n  def *(rhs : Quaternion)\n    Quaternion.new(rhs.a * self, rhs.b * self, rhs.c * self, rhs.d * self)\n  end\nend\n\nq0 = Quaternion.new(a: 1, b: 2, c: 3, d: 4)\nq1 = Quaternion.new(2, 3, 4, 5)\nq2 = Quaternion.new(3, 4, 5, 6)\nr  = 7\n\nputs \"q0 = \nputs \"q1 = \nputs \"q2 = \nputs \"r  = \nputs\nputs \"normal of q0 = \nputs \"-q0 = \nputs \"conjugate of q0 = \nputs \"q0 * (conjugate of q0) = \nputs \"(conjugate of q0) * q0 = \nputs\nputs \"r + q0 = \nputs \"q0 + r = \nputs\nputs \" q0 - r = \nputs \"-q0 - r = \nputs \" r - q0 = \nputs \"-q0 + r = \nputs\nputs \"r * q0 = \nputs \"q0 * r = \nputs\nputs \"q0 + q1 = \nputs \"q0 - q1 = \nputs \"q0 * q1 = \nputs\nputs \" q0 + q1 * q2  = \nputs \"(q0 + q1) * q2 = \nputs\nputs \" q0 *  q1  * q2 = \nputs \"(q0 *  q1) * q2 = \nputs \" q0 * (q1 * q2) = \nputs\nputs \"q1 * q2 = \nputs \"q2 * q1 = \nputs\nputs \"q1 * q2\u00a0!= q2 * q1 => \nputs \"q1 * q2 == q2 * q1 => \n", "target": "public class Quaternion {\n    private final double a, b, c, d;\n\n    public Quaternion(double a, double b, double c, double d) {\n        this.a = a;\n        this.b = b;\n        this.c = c;\n        this.d = d;\n    }\n    public Quaternion(double r) {\n        this(r, 0.0, 0.0, 0.0);\n    }\n\n    public double norm() {\n        return Math.sqrt(a * a + b * b + c * c + d * d);\n    }\n\n    public Quaternion negative() {\n        return new Quaternion(-a, -b, -c, -d);\n    }\n\n    public Quaternion conjugate() {\n        return new Quaternion(a, -b, -c, -d);\n    }\n\n    public Quaternion add(double r) {\n        return new Quaternion(a + r, b, c, d);\n    }\n    public static Quaternion add(Quaternion q, double r) {\n        return q.add(r);\n    }\n    public static Quaternion add(double r, Quaternion q) {\n        return q.add(r);\n    }\n    public Quaternion add(Quaternion q) {\n        return new Quaternion(a + q.a, b + q.b, c + q.c, d + q.d);\n    }\n    public static Quaternion add(Quaternion q1, Quaternion q2) {\n        return q1.add(q2);\n    }\n\n    public Quaternion times(double r) {\n        return new Quaternion(a * r, b * r, c * r, d * r);\n    }\n    public static Quaternion times(Quaternion q, double r) {\n        return q.times(r);\n    }\n    public static Quaternion times(double r, Quaternion q) {\n        return q.times(r);\n    }\n    public Quaternion times(Quaternion q) {\n        return new Quaternion(\n            a * q.a - b * q.b - c * q.c - d * q.d,\n            a * q.b + b * q.a + c * q.d - d * q.c,\n            a * q.c - b * q.d + c * q.a + d * q.b,\n            a * q.d + b * q.c - c * q.b + d * q.a\n        );\n    }\n    public static Quaternion times(Quaternion q1, Quaternion q2) {\n        return q1.times(q2);\n    }\n\n    @Override\n    public boolean equals(Object obj) {\n        if (!(obj instanceof Quaternion)) return false;\n        final Quaternion other = (Quaternion) obj;\n        if (Double.doubleToLongBits(this.a) != Double.doubleToLongBits(other.a)) return false;\n        if (Double.doubleToLongBits(this.b) != Double.doubleToLongBits(other.b)) return false;\n        if (Double.doubleToLongBits(this.c) != Double.doubleToLongBits(other.c)) return false;\n        if (Double.doubleToLongBits(this.d) != Double.doubleToLongBits(other.d)) return false;\n        return true;\n    }\n    @Override\n    public String toString() {\n        return String.format(\"%.2f +\u00a0%.2fi +\u00a0%.2fj +\u00a0%.2fk\", a, b, c, d).replaceAll(\"\\\\+ -\", \"- \");\n    }\n\n    public String toQuadruple() {\n        return String.format(\"(%.2f,\u00a0%.2f,\u00a0%.2f,\u00a0%.2f)\", a, b, c, d);\n    }\n\n    public static void main(String[] args) {\n        Quaternion q = new Quaternion(1.0, 2.0, 3.0, 4.0);\n        Quaternion q1 = new Quaternion(2.0, 3.0, 4.0, 5.0);\n        Quaternion q2 = new Quaternion(3.0, 4.0, 5.0, 6.0);\n        double r = 7.0;\n        System.out.format(\"q       = %s%n\", q);\n        System.out.format(\"q1      = %s%n\", q1);\n        System.out.format(\"q2      = %s%n\", q2);\n        System.out.format(\"r       =\u00a0%.2f%n%n\", r);\n        System.out.format(\"\\u2016q\\u2016     =\u00a0%.2f%n\", q.norm());\n        System.out.format(\"-q      = %s%n\", q.negative());\n        System.out.format(\"q*      = %s%n\", q.conjugate());\n        System.out.format(\"q + r   = %s%n\", q.add(r));\n        System.out.format(\"q1 + q2 = %s%n\", q1.add(q2));\n        System.out.format(\"q \\u00d7 r   = %s%n\", q.times(r));\n        Quaternion q1q2 = q1.times(q2);\n        Quaternion q2q1 = q2.times(q1);\n        System.out.format(\"q1 \\u00d7 q2 = %s%n\", q1q2);\n        System.out.format(\"q2 \\u00d7 q1 = %s%n\", q2q1);\n        System.out.format(\"q1 \\u00d7 q2 %s q2 \\u00d7 q1%n\", (q1q2.equals(q2q1) ? \"=\" : \"\\u2260\"));\n    }\n}\n"}
{"id": 37695, "name": "Quaternion type", "source": "Translate Ruby to Java: class Quaternion\n  property a, b, c, d\n\n  def initialize(@a : Int64, @b : Int64, @c : Int64, @d : Int64) end\n\n  def norm; Math.sqrt(a**2 + b**2 + c**2 + d**2) end\n  def conj; Quaternion.new(a, -b, -c, -d)        end\n  def +(n)  Quaternion.new(a + n, b, c, d)       end\n  def -(n)  Quaternion.new(a - n, b, c, d)       end\n  def -()   Quaternion.new(-a, -b, -c, -d)       end\n  def *(n)  Quaternion.new(a * n, b * n, c * n, d * n) end\n  def ==(rhs : Quaternion) self.to_s == rhs.to_s end\n  def +(rhs : Quaternion)\n    Quaternion.new(a + rhs.a, b + rhs.b, c + rhs.c, d + rhs.d)\n  end\n\n  def -(rhs : Quaternion)\n    Quaternion.new(a - rhs.a, b - rhs.b, c - rhs.c, d - rhs.d)\n  end\n\n  def *(rhs : Quaternion)\n    Quaternion.new(\n      a * rhs.a - b * rhs.b - c * rhs.c - d * rhs.d,\n      a * rhs.b + b * rhs.a + c * rhs.d - d * rhs.c,\n      a * rhs.c - b * rhs.d + c * rhs.a + d * rhs.b,\n      a * rhs.d + b * rhs.c - c * rhs.b + d * rhs.a)\n  end\n\n  def to_s(io : IO) io << \"(\n  private def sgn(n)  n.sign|1 == 1 ? \"+ \nend\n\nstruct Number\n  def +(rhs : Quaternion)\n    Quaternion.new(rhs.a + self, rhs.b, rhs.c, rhs.d)\n  end\n\n  def -(rhs : Quaternion)\n    Quaternion.new(-rhs.a + self, -rhs.b, -rhs.c, -rhs.d)\n  end\n\n  def *(rhs : Quaternion)\n    Quaternion.new(rhs.a * self, rhs.b * self, rhs.c * self, rhs.d * self)\n  end\nend\n\nq0 = Quaternion.new(a: 1, b: 2, c: 3, d: 4)\nq1 = Quaternion.new(2, 3, 4, 5)\nq2 = Quaternion.new(3, 4, 5, 6)\nr  = 7\n\nputs \"q0 = \nputs \"q1 = \nputs \"q2 = \nputs \"r  = \nputs\nputs \"normal of q0 = \nputs \"-q0 = \nputs \"conjugate of q0 = \nputs \"q0 * (conjugate of q0) = \nputs \"(conjugate of q0) * q0 = \nputs\nputs \"r + q0 = \nputs \"q0 + r = \nputs\nputs \" q0 - r = \nputs \"-q0 - r = \nputs \" r - q0 = \nputs \"-q0 + r = \nputs\nputs \"r * q0 = \nputs \"q0 * r = \nputs\nputs \"q0 + q1 = \nputs \"q0 - q1 = \nputs \"q0 * q1 = \nputs\nputs \" q0 + q1 * q2  = \nputs \"(q0 + q1) * q2 = \nputs\nputs \" q0 *  q1  * q2 = \nputs \"(q0 *  q1) * q2 = \nputs \" q0 * (q1 * q2) = \nputs\nputs \"q1 * q2 = \nputs \"q2 * q1 = \nputs\nputs \"q1 * q2\u00a0!= q2 * q1 => \nputs \"q1 * q2 == q2 * q1 => \n", "target": "public class Quaternion {\n    private final double a, b, c, d;\n\n    public Quaternion(double a, double b, double c, double d) {\n        this.a = a;\n        this.b = b;\n        this.c = c;\n        this.d = d;\n    }\n    public Quaternion(double r) {\n        this(r, 0.0, 0.0, 0.0);\n    }\n\n    public double norm() {\n        return Math.sqrt(a * a + b * b + c * c + d * d);\n    }\n\n    public Quaternion negative() {\n        return new Quaternion(-a, -b, -c, -d);\n    }\n\n    public Quaternion conjugate() {\n        return new Quaternion(a, -b, -c, -d);\n    }\n\n    public Quaternion add(double r) {\n        return new Quaternion(a + r, b, c, d);\n    }\n    public static Quaternion add(Quaternion q, double r) {\n        return q.add(r);\n    }\n    public static Quaternion add(double r, Quaternion q) {\n        return q.add(r);\n    }\n    public Quaternion add(Quaternion q) {\n        return new Quaternion(a + q.a, b + q.b, c + q.c, d + q.d);\n    }\n    public static Quaternion add(Quaternion q1, Quaternion q2) {\n        return q1.add(q2);\n    }\n\n    public Quaternion times(double r) {\n        return new Quaternion(a * r, b * r, c * r, d * r);\n    }\n    public static Quaternion times(Quaternion q, double r) {\n        return q.times(r);\n    }\n    public static Quaternion times(double r, Quaternion q) {\n        return q.times(r);\n    }\n    public Quaternion times(Quaternion q) {\n        return new Quaternion(\n            a * q.a - b * q.b - c * q.c - d * q.d,\n            a * q.b + b * q.a + c * q.d - d * q.c,\n            a * q.c - b * q.d + c * q.a + d * q.b,\n            a * q.d + b * q.c - c * q.b + d * q.a\n        );\n    }\n    public static Quaternion times(Quaternion q1, Quaternion q2) {\n        return q1.times(q2);\n    }\n\n    @Override\n    public boolean equals(Object obj) {\n        if (!(obj instanceof Quaternion)) return false;\n        final Quaternion other = (Quaternion) obj;\n        if (Double.doubleToLongBits(this.a) != Double.doubleToLongBits(other.a)) return false;\n        if (Double.doubleToLongBits(this.b) != Double.doubleToLongBits(other.b)) return false;\n        if (Double.doubleToLongBits(this.c) != Double.doubleToLongBits(other.c)) return false;\n        if (Double.doubleToLongBits(this.d) != Double.doubleToLongBits(other.d)) return false;\n        return true;\n    }\n    @Override\n    public String toString() {\n        return String.format(\"%.2f +\u00a0%.2fi +\u00a0%.2fj +\u00a0%.2fk\", a, b, c, d).replaceAll(\"\\\\+ -\", \"- \");\n    }\n\n    public String toQuadruple() {\n        return String.format(\"(%.2f,\u00a0%.2f,\u00a0%.2f,\u00a0%.2f)\", a, b, c, d);\n    }\n\n    public static void main(String[] args) {\n        Quaternion q = new Quaternion(1.0, 2.0, 3.0, 4.0);\n        Quaternion q1 = new Quaternion(2.0, 3.0, 4.0, 5.0);\n        Quaternion q2 = new Quaternion(3.0, 4.0, 5.0, 6.0);\n        double r = 7.0;\n        System.out.format(\"q       = %s%n\", q);\n        System.out.format(\"q1      = %s%n\", q1);\n        System.out.format(\"q2      = %s%n\", q2);\n        System.out.format(\"r       =\u00a0%.2f%n%n\", r);\n        System.out.format(\"\\u2016q\\u2016     =\u00a0%.2f%n\", q.norm());\n        System.out.format(\"-q      = %s%n\", q.negative());\n        System.out.format(\"q*      = %s%n\", q.conjugate());\n        System.out.format(\"q + r   = %s%n\", q.add(r));\n        System.out.format(\"q1 + q2 = %s%n\", q1.add(q2));\n        System.out.format(\"q \\u00d7 r   = %s%n\", q.times(r));\n        Quaternion q1q2 = q1.times(q2);\n        Quaternion q2q1 = q2.times(q1);\n        System.out.format(\"q1 \\u00d7 q2 = %s%n\", q1q2);\n        System.out.format(\"q2 \\u00d7 q1 = %s%n\", q2q1);\n        System.out.format(\"q1 \\u00d7 q2 %s q2 \\u00d7 q1%n\", (q1q2.equals(q2q1) ? \"=\" : \"\\u2260\"));\n    }\n}\n"}
{"id": 37696, "name": "Quaternion type", "source": "Translate Ruby to Python: class Quaternion\n  property a, b, c, d\n\n  def initialize(@a : Int64, @b : Int64, @c : Int64, @d : Int64) end\n\n  def norm; Math.sqrt(a**2 + b**2 + c**2 + d**2) end\n  def conj; Quaternion.new(a, -b, -c, -d)        end\n  def +(n)  Quaternion.new(a + n, b, c, d)       end\n  def -(n)  Quaternion.new(a - n, b, c, d)       end\n  def -()   Quaternion.new(-a, -b, -c, -d)       end\n  def *(n)  Quaternion.new(a * n, b * n, c * n, d * n) end\n  def ==(rhs : Quaternion) self.to_s == rhs.to_s end\n  def +(rhs : Quaternion)\n    Quaternion.new(a + rhs.a, b + rhs.b, c + rhs.c, d + rhs.d)\n  end\n\n  def -(rhs : Quaternion)\n    Quaternion.new(a - rhs.a, b - rhs.b, c - rhs.c, d - rhs.d)\n  end\n\n  def *(rhs : Quaternion)\n    Quaternion.new(\n      a * rhs.a - b * rhs.b - c * rhs.c - d * rhs.d,\n      a * rhs.b + b * rhs.a + c * rhs.d - d * rhs.c,\n      a * rhs.c - b * rhs.d + c * rhs.a + d * rhs.b,\n      a * rhs.d + b * rhs.c - c * rhs.b + d * rhs.a)\n  end\n\n  def to_s(io : IO) io << \"(\n  private def sgn(n)  n.sign|1 == 1 ? \"+ \nend\n\nstruct Number\n  def +(rhs : Quaternion)\n    Quaternion.new(rhs.a + self, rhs.b, rhs.c, rhs.d)\n  end\n\n  def -(rhs : Quaternion)\n    Quaternion.new(-rhs.a + self, -rhs.b, -rhs.c, -rhs.d)\n  end\n\n  def *(rhs : Quaternion)\n    Quaternion.new(rhs.a * self, rhs.b * self, rhs.c * self, rhs.d * self)\n  end\nend\n\nq0 = Quaternion.new(a: 1, b: 2, c: 3, d: 4)\nq1 = Quaternion.new(2, 3, 4, 5)\nq2 = Quaternion.new(3, 4, 5, 6)\nr  = 7\n\nputs \"q0 = \nputs \"q1 = \nputs \"q2 = \nputs \"r  = \nputs\nputs \"normal of q0 = \nputs \"-q0 = \nputs \"conjugate of q0 = \nputs \"q0 * (conjugate of q0) = \nputs \"(conjugate of q0) * q0 = \nputs\nputs \"r + q0 = \nputs \"q0 + r = \nputs\nputs \" q0 - r = \nputs \"-q0 - r = \nputs \" r - q0 = \nputs \"-q0 + r = \nputs\nputs \"r * q0 = \nputs \"q0 * r = \nputs\nputs \"q0 + q1 = \nputs \"q0 - q1 = \nputs \"q0 * q1 = \nputs\nputs \" q0 + q1 * q2  = \nputs \"(q0 + q1) * q2 = \nputs\nputs \" q0 *  q1  * q2 = \nputs \"(q0 *  q1) * q2 = \nputs \" q0 * (q1 * q2) = \nputs\nputs \"q1 * q2 = \nputs \"q2 * q1 = \nputs\nputs \"q1 * q2\u00a0!= q2 * q1 => \nputs \"q1 * q2 == q2 * q1 => \n", "target": "from collections import namedtuple\nimport math\n\nclass Q(namedtuple('Quaternion', 'real, i, j, k')):\n    'Quaternion type: Q(real=0.0, i=0.0, j=0.0, k=0.0)' \n\n    __slots__ = () \n\n    def __new__(_cls, real=0.0, i=0.0, j=0.0, k=0.0):\n        'Defaults all parts of quaternion to zero'\n        return super().__new__(_cls, float(real), float(i), float(j), float(k))\n\n    def conjugate(self):\n        return Q(self.real, -self.i, -self.j, -self.k)\n\n    def _norm2(self):\n        return sum( x*x for x in self)\n\n    def norm(self):\n        return math.sqrt(self._norm2())\n\n    def reciprocal(self):\n        n2 = self._norm2()\n        return Q(*(x / n2 for x in self.conjugate())) \n\n    def __str__(self):\n        'Shorter form of Quaternion as string'\n        return 'Q(%g, %g, %g, %g)' % self\n\n    def __neg__(self):\n        return Q(-self.real, -self.i, -self.j, -self.k)\n\n    def __add__(self, other):\n        if type(other) == Q:\n            return Q( *(s+o for s,o in zip(self, other)) )\n        try:\n            f = float(other)\n        except:\n            return NotImplemented\n        return Q(self.real + f, self.i, self.j, self.k)\n\n    def __radd__(self, other):\n        return Q.__add__(self, other)\n\n    def __mul__(self, other):\n        if type(other) == Q:\n            a1,b1,c1,d1 = self\n            a2,b2,c2,d2 = other\n            return Q(\n                 a1*a2 - b1*b2 - c1*c2 - d1*d2,\n                 a1*b2 + b1*a2 + c1*d2 - d1*c2,\n                 a1*c2 - b1*d2 + c1*a2 + d1*b2,\n                 a1*d2 + b1*c2 - c1*b2 + d1*a2 )\n        try:\n            f = float(other)\n        except:\n            return NotImplemented\n        return Q(self.real * f, self.i * f, self.j * f, self.k * f)\n\n    def __rmul__(self, other):\n        return Q.__mul__(self, other)\n\n    def __truediv__(self, other):\n        if type(other) == Q:\n            return self.__mul__(other.reciprocal())\n        try:\n            f = float(other)\n        except:\n            return NotImplemented\n        return Q(self.real / f, self.i / f, self.j / f, self.k / f)\n\n    def __rtruediv__(self, other):\n        return other * self.reciprocal()\n\n    __div__, __rdiv__ = __truediv__, __rtruediv__\n\nQuaternion = Q       \n\nq  = Q(1, 2, 3, 4)\nq1 = Q(2, 3, 4, 5)\nq2 = Q(3, 4, 5, 6)\nr  = 7\n"}
{"id": 37697, "name": "Quaternion type", "source": "Translate Ruby to Python: class Quaternion\n  property a, b, c, d\n\n  def initialize(@a : Int64, @b : Int64, @c : Int64, @d : Int64) end\n\n  def norm; Math.sqrt(a**2 + b**2 + c**2 + d**2) end\n  def conj; Quaternion.new(a, -b, -c, -d)        end\n  def +(n)  Quaternion.new(a + n, b, c, d)       end\n  def -(n)  Quaternion.new(a - n, b, c, d)       end\n  def -()   Quaternion.new(-a, -b, -c, -d)       end\n  def *(n)  Quaternion.new(a * n, b * n, c * n, d * n) end\n  def ==(rhs : Quaternion) self.to_s == rhs.to_s end\n  def +(rhs : Quaternion)\n    Quaternion.new(a + rhs.a, b + rhs.b, c + rhs.c, d + rhs.d)\n  end\n\n  def -(rhs : Quaternion)\n    Quaternion.new(a - rhs.a, b - rhs.b, c - rhs.c, d - rhs.d)\n  end\n\n  def *(rhs : Quaternion)\n    Quaternion.new(\n      a * rhs.a - b * rhs.b - c * rhs.c - d * rhs.d,\n      a * rhs.b + b * rhs.a + c * rhs.d - d * rhs.c,\n      a * rhs.c - b * rhs.d + c * rhs.a + d * rhs.b,\n      a * rhs.d + b * rhs.c - c * rhs.b + d * rhs.a)\n  end\n\n  def to_s(io : IO) io << \"(\n  private def sgn(n)  n.sign|1 == 1 ? \"+ \nend\n\nstruct Number\n  def +(rhs : Quaternion)\n    Quaternion.new(rhs.a + self, rhs.b, rhs.c, rhs.d)\n  end\n\n  def -(rhs : Quaternion)\n    Quaternion.new(-rhs.a + self, -rhs.b, -rhs.c, -rhs.d)\n  end\n\n  def *(rhs : Quaternion)\n    Quaternion.new(rhs.a * self, rhs.b * self, rhs.c * self, rhs.d * self)\n  end\nend\n\nq0 = Quaternion.new(a: 1, b: 2, c: 3, d: 4)\nq1 = Quaternion.new(2, 3, 4, 5)\nq2 = Quaternion.new(3, 4, 5, 6)\nr  = 7\n\nputs \"q0 = \nputs \"q1 = \nputs \"q2 = \nputs \"r  = \nputs\nputs \"normal of q0 = \nputs \"-q0 = \nputs \"conjugate of q0 = \nputs \"q0 * (conjugate of q0) = \nputs \"(conjugate of q0) * q0 = \nputs\nputs \"r + q0 = \nputs \"q0 + r = \nputs\nputs \" q0 - r = \nputs \"-q0 - r = \nputs \" r - q0 = \nputs \"-q0 + r = \nputs\nputs \"r * q0 = \nputs \"q0 * r = \nputs\nputs \"q0 + q1 = \nputs \"q0 - q1 = \nputs \"q0 * q1 = \nputs\nputs \" q0 + q1 * q2  = \nputs \"(q0 + q1) * q2 = \nputs\nputs \" q0 *  q1  * q2 = \nputs \"(q0 *  q1) * q2 = \nputs \" q0 * (q1 * q2) = \nputs\nputs \"q1 * q2 = \nputs \"q2 * q1 = \nputs\nputs \"q1 * q2\u00a0!= q2 * q1 => \nputs \"q1 * q2 == q2 * q1 => \n", "target": "from collections import namedtuple\nimport math\n\nclass Q(namedtuple('Quaternion', 'real, i, j, k')):\n    'Quaternion type: Q(real=0.0, i=0.0, j=0.0, k=0.0)' \n\n    __slots__ = () \n\n    def __new__(_cls, real=0.0, i=0.0, j=0.0, k=0.0):\n        'Defaults all parts of quaternion to zero'\n        return super().__new__(_cls, float(real), float(i), float(j), float(k))\n\n    def conjugate(self):\n        return Q(self.real, -self.i, -self.j, -self.k)\n\n    def _norm2(self):\n        return sum( x*x for x in self)\n\n    def norm(self):\n        return math.sqrt(self._norm2())\n\n    def reciprocal(self):\n        n2 = self._norm2()\n        return Q(*(x / n2 for x in self.conjugate())) \n\n    def __str__(self):\n        'Shorter form of Quaternion as string'\n        return 'Q(%g, %g, %g, %g)' % self\n\n    def __neg__(self):\n        return Q(-self.real, -self.i, -self.j, -self.k)\n\n    def __add__(self, other):\n        if type(other) == Q:\n            return Q( *(s+o for s,o in zip(self, other)) )\n        try:\n            f = float(other)\n        except:\n            return NotImplemented\n        return Q(self.real + f, self.i, self.j, self.k)\n\n    def __radd__(self, other):\n        return Q.__add__(self, other)\n\n    def __mul__(self, other):\n        if type(other) == Q:\n            a1,b1,c1,d1 = self\n            a2,b2,c2,d2 = other\n            return Q(\n                 a1*a2 - b1*b2 - c1*c2 - d1*d2,\n                 a1*b2 + b1*a2 + c1*d2 - d1*c2,\n                 a1*c2 - b1*d2 + c1*a2 + d1*b2,\n                 a1*d2 + b1*c2 - c1*b2 + d1*a2 )\n        try:\n            f = float(other)\n        except:\n            return NotImplemented\n        return Q(self.real * f, self.i * f, self.j * f, self.k * f)\n\n    def __rmul__(self, other):\n        return Q.__mul__(self, other)\n\n    def __truediv__(self, other):\n        if type(other) == Q:\n            return self.__mul__(other.reciprocal())\n        try:\n            f = float(other)\n        except:\n            return NotImplemented\n        return Q(self.real / f, self.i / f, self.j / f, self.k / f)\n\n    def __rtruediv__(self, other):\n        return other * self.reciprocal()\n\n    __div__, __rdiv__ = __truediv__, __rtruediv__\n\nQuaternion = Q       \n\nq  = Q(1, 2, 3, 4)\nq1 = Q(2, 3, 4, 5)\nq2 = Q(3, 4, 5, 6)\nr  = 7\n"}
{"id": 38083, "name": "Character codes", "source": "Translate Ruby to C#: > \"a\".ord\n=> 97\n> 97.chr\n=> \"a\"\n", "target": "using System;\n\nnamespace RosettaCode.CharacterCode\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            Console.WriteLine((int) 'a');   \n            Console.WriteLine((char) 97);   \n        }\n    }\n}\n"}
{"id": 38085, "name": "Character codes", "source": "Translate Ruby to Java: > \"a\".ord\n=> 97\n> 97.chr\n=> \"a\"\n", "target": "module CharacterCodes\n    {\n    @Inject Console console;\n    void run()\n        {\n        for (Char char : ['\\0', '\\d', 'A', '$', '\u00a2', '~', '\u02dc'])\n            {\n            \n            UInt32 codepoint = char.codepoint;\n\n            \n            Char fromCodePoint = codepoint.toChar();   \n\n            console.print($|Character {char.quoted()}:\\\n                           | Unicode codepoint={char.codepoint},\\\n                           | ASCII={char.ascii},\\\n                           | UTF8 bytes={char.utf8()},\\\n                           | char from codepoint={fromCodePoint.quoted()}\n                         );\n            }\n        }\n    }\n"}
{"id": 38246, "name": "GUI component interaction", "source": "Translate Ruby to C#: Shoes.app(title: \"GUI component interaction\") do\n  stack do\n    textbox = edit_line\n    \n    textbox.change do\n      textbox.text = textbox.text.gsub(/[^\\d]/, '') and alert \"Input must be a number!\" if textbox.text !~ /^\\d*$/\n    end\n    \n    flow do\n      button \"Increment\" do\n        textbox.text = textbox.text.to_i + 1\n      end\n      \n      button \"Random\" do\n        textbox.text = rand 5000 if confirm \"Do you want a random number?\"\n      end\n    end\n  end\nend\n", "target": "using System; \nusing System.ComponentModel; \nusing System.Windows.Forms; \n\nclass RosettaInteractionForm : Form\n{    \n    \n    \n    class NumberModel: INotifyPropertyChanged\n    {\n\n        Random rnd = new Random();\n\n        \n        public event PropertyChangedEventHandler PropertyChanged = delegate {};\n\n        int _value;\n        public int Value\n        {\n            get { return _value; }\n            set \n            { \n                _value = value;\n                \n                PropertyChanged(this, new PropertyChangedEventArgs(\"Value\"));\n            }\n        }\n\n        public void ResetToRandom(){\n            Value = rnd.Next(5000);\n        }\n    }\n\n    NumberModel model = new NumberModel{ Value = 0};\n    \n    RosettaInteractionForm()    \n    {\n        \n        var tbNumber = new MaskedTextBox\n                        { \n                            Mask=\"0000\",            \n                            ResetOnSpace = false,   \n                            Dock = DockStyle.Top    \n                        };\n        \n        tbNumber.DataBindings.Add(\"Text\", model, \"Value\");\n\n        var btIncrement = new Button{Text = \"Increment\", Dock = DockStyle.Bottom};\n        btIncrement.Click += delegate\n                        {\n                            model.Value++;\n                        };\n        var btDecrement = new Button{Text = \"Decrement\", Dock = DockStyle.Bottom};\n        btDecrement.Click += delegate\n                        {\n                            model.Value--;\n                        };\n        var btRandom = new Button{ Text=\"Reset to Random\", Dock = DockStyle.Bottom };\n        btRandom.Click += delegate\n                        {\n                            if (MessageBox.Show(\"Are you sure?\", \"Are you sure?\", MessageBoxButtons.YesNo) == DialogResult.Yes)\n                                model.ResetToRandom();\n                        };\n        Controls.Add(tbNumber);\n        Controls.Add(btIncrement);\n        Controls.Add(btDecrement);\n        Controls.Add(btRandom);\n    }\n    static void Main()\n    {\n        Application.Run(new RosettaInteractionForm());\n    }\n}\n"}
{"id": 38248, "name": "GUI component interaction", "source": "Translate Ruby to Java: Shoes.app(title: \"GUI component interaction\") do\n  stack do\n    textbox = edit_line\n    \n    textbox.change do\n      textbox.text = textbox.text.gsub(/[^\\d]/, '') and alert \"Input must be a number!\" if textbox.text !~ /^\\d*$/\n    end\n    \n    flow do\n      button \"Increment\" do\n        textbox.text = textbox.text.to_i + 1\n      end\n      \n      button \"Random\" do\n        textbox.text = rand 5000 if confirm \"Do you want a random number?\"\n      end\n    end\n  end\nend\n", "target": "import java.awt.GridLayout;\nimport java.awt.event.ActionEvent;\nimport java.awt.event.ActionListener;\nimport java.awt.event.KeyEvent;\nimport java.awt.event.KeyListener;\n\nimport javax.swing.JButton;\nimport javax.swing.JFrame;\nimport javax.swing.JOptionPane;\nimport javax.swing.JPanel;\nimport javax.swing.JTextField;\n\npublic class Interact extends JFrame{\n\tfinal JTextField numberField;\n\tfinal JButton incButton, randButton;\n\t\n\tpublic Interact(){\n\t\t\n\t\tsetDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); \n\t\t\n\t\tnumberField = new JTextField();\n\t\tincButton = new JButton(\"Increment\");\n\t\trandButton = new JButton(\"Random\");\n\t\t\n\t\tnumberField.setText(\"0\");\n\t\t\n\t\t\n\t\tnumberField.addKeyListener(new KeyListener(){\n\t\t\t@Override\n\t\t\tpublic void keyTyped(KeyEvent e) {\n\t\t\t\t\n\t\t\t\tif(!Character.isDigit(e.getKeyChar())){\n\t\t\t\t\t\n\t\t\t\t\te.consume();\n\t\t\t\t}\n\t\t\t}\n\t\t\t@Override\n\t\t\tpublic void keyReleased(KeyEvent e){}\n\t\t\t@Override\n\t\t\tpublic void keyPressed(KeyEvent e){}\n\t\t});\n\t\t\n\t\t\n\t\tincButton.addActionListener(new ActionListener(){\n\t\t\t@Override\n\t\t\tpublic void actionPerformed(ActionEvent e) {\n\t\t\t\tString text = numberField.getText();\n\t\t\t\tif(text.isEmpty()){\n\t\t\t\t\tnumberField.setText(\"1\");\n\t\t\t\t}else{\n\t\t\t\t\tnumberField.setText((Long.valueOf(text) + 1) + \"\");\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t\t\n\t\t\n\t\trandButton.addActionListener(new ActionListener(){\n\t\t\t@Override\n\t\t\tpublic void actionPerformed(ActionEvent e) {\n\t\t\t\t\n\t\t\t\tif(JOptionPane.showConfirmDialog(null, \"Are you sure?\") ==\n\t\t\t\t\tJOptionPane.YES_OPTION){\n\t\t\t\t\t\n\t\t\t\t\tnumberField.setText(Long.toString((long)(Math.random() \n\t\t\t\t\t\t\t* Long.MAX_VALUE)));\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t\t\n\t\t\n\t\tsetLayout(new GridLayout(2, 1));\n\t\t\n\t\t\n\t\tJPanel buttonPanel = new JPanel();\n\t\t\n\t\t\n\t\tbuttonPanel.setLayout(new GridLayout(1, 2));\n\t\t\n\t\tbuttonPanel.add(incButton);\n\t\tbuttonPanel.add(randButton);\n\t\t\n\t\t\n\t\tadd(numberField);\n\t\tadd(buttonPanel);\n\t\t\n\t\tpack();\n\t\t\n\t}\n\n\tpublic static void main(String[] args){\n\t\tnew Interact().setVisible(true);\n\t}\n}\n"}
{"id": 38249, "name": "GUI component interaction", "source": "Translate Ruby to Python: Shoes.app(title: \"GUI component interaction\") do\n  stack do\n    textbox = edit_line\n    \n    textbox.change do\n      textbox.text = textbox.text.gsub(/[^\\d]/, '') and alert \"Input must be a number!\" if textbox.text !~ /^\\d*$/\n    end\n    \n    flow do\n      button \"Increment\" do\n        textbox.text = textbox.text.to_i + 1\n      end\n      \n      button \"Random\" do\n        textbox.text = rand 5000 if confirm \"Do you want a random number?\"\n      end\n    end\n  end\nend\n", "target": "import random, tkMessageBox\nfrom Tkinter import *\nwindow = Tk()\nwindow.geometry(\"300x50+100+100\")\noptions = { \"padx\":5, \"pady\":5}\ns=StringVar()\ns.set(1)\ndef increase():\n    s.set(int(s.get())+1)\ndef rand():\n    if tkMessageBox.askyesno(\"Confirmation\", \"Reset to random value\u00a0?\"):\n        s.set(random.randrange(0,5000))\ndef update(e):\n    if not e.char.isdigit():\n        tkMessageBox.showerror('Error', 'Invalid input\u00a0!') \n        return \"break\"\ne = Entry(text=s)\ne.grid(column=0, row=0, **options)\ne.bind('<Key>', update)\nb1 = Button(text=\"Increase\", command=increase, **options )\nb1.grid(column=1, row=0, **options)\nb2 = Button(text=\"Random\", command=rand, **options)\nb2.grid(column=2, row=0, **options)\nmainloop()\n"}
{"id": 38605, "name": "Fibonacci n-step number sequences", "source": "Translate Ruby to C#: def anynacci(start_sequence, count)\n  n      = start_sequence.length    \n  result = start_sequence.dup       \n  (count-n).times do                \n    result << result.last(n).sum    \n  end\n  result                       \nend\n \nnaccis = { lucas:      [2,1],\n           fibonacci:  [1,1],\n           tribonacci: [1,1,2],\n           tetranacci: [1,1,2,4],\n           pentanacci: [1,1,2,4,8],\n           hexanacci:  [1,1,2,4,8,16],\n           heptanacci: [1,1,2,4,8,16,32],\n           octonacci:  [1,1,2,4,8,16,32,64],\n           nonanacci:  [1,1,2,4,8,16,32,64,128],\n           decanacci:  [1,1,2,4,8,16,32,64,128,256] }\n\nnaccis.each {|name, seq| puts \"%12s\u00a0: %p\" % [name, anynacci(seq, 15)]}\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\nnamespace Fibonacci\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            PrintNumberSequence(\"Fibonacci\", GetNnacciNumbers(2, 10));\n            PrintNumberSequence(\"Lucas\", GetLucasNumbers(10));\n            PrintNumberSequence(\"Tribonacci\", GetNnacciNumbers(3, 10));\n            PrintNumberSequence(\"Tetranacci\", GetNnacciNumbers(4, 10));\n            Console.ReadKey();\n        }\n\n        private static IList<ulong> GetLucasNumbers(int length)\n        {\n            IList<ulong> seedSequence = new List<ulong>() { 2, 1 };\n            return GetFibLikeSequence(seedSequence, length);\n        }\n\n        private static IList<ulong> GetNnacciNumbers(int seedLength, int length)\n        {\n            return GetFibLikeSequence(GetNacciSeed(seedLength), length);\n        }\n\n        private static IList<ulong> GetNacciSeed(int seedLength)\n        {\n            IList<ulong> seedSquence = new List<ulong>() { 1 };\n\n            for (uint i = 0; i < seedLength - 1; i++)\n            {\n                seedSquence.Add((ulong)Math.Pow(2, i));\n            }\n\n            return seedSquence;\n        }\n\n        private static IList<ulong> GetFibLikeSequence(IList<ulong> seedSequence, int length)\n        {\n            IList<ulong> sequence = new List<ulong>();\n\n            int count = seedSequence.Count();\n\n            if (length <= count)\n            {\n                sequence = seedSequence.Take((int)length).ToList();\n            }\n            else\n            {\n                sequence = seedSequence;\n\n                for (int i = count; i < length; i++)\n                {\n                    ulong num = 0;\n\n                    for (int j = 0; j < count; j++)\n                    {\n                        num += sequence[sequence.Count - 1 - j];\n                    }\n\n                    sequence.Add(num);\n                }\n            }\n\n            return sequence;\n        }\n\n        private static void PrintNumberSequence(string Title, IList<ulong> numbersequence)\n        {\n            StringBuilder output = new StringBuilder(Title).Append(\"   \");\n\n            foreach (long item in numbersequence)\n            {\n                output.AppendFormat(\"{0}, \", item);\n            }\n\n            Console.WriteLine(output.ToString());\n        }\n    }\n}\n"}
{"id": 38606, "name": "Fibonacci n-step number sequences", "source": "Translate Ruby to C#: def anynacci(start_sequence, count)\n  n      = start_sequence.length    \n  result = start_sequence.dup       \n  (count-n).times do                \n    result << result.last(n).sum    \n  end\n  result                       \nend\n \nnaccis = { lucas:      [2,1],\n           fibonacci:  [1,1],\n           tribonacci: [1,1,2],\n           tetranacci: [1,1,2,4],\n           pentanacci: [1,1,2,4,8],\n           hexanacci:  [1,1,2,4,8,16],\n           heptanacci: [1,1,2,4,8,16,32],\n           octonacci:  [1,1,2,4,8,16,32,64],\n           nonanacci:  [1,1,2,4,8,16,32,64,128],\n           decanacci:  [1,1,2,4,8,16,32,64,128,256] }\n\nnaccis.each {|name, seq| puts \"%12s\u00a0: %p\" % [name, anynacci(seq, 15)]}\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\nnamespace Fibonacci\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            PrintNumberSequence(\"Fibonacci\", GetNnacciNumbers(2, 10));\n            PrintNumberSequence(\"Lucas\", GetLucasNumbers(10));\n            PrintNumberSequence(\"Tribonacci\", GetNnacciNumbers(3, 10));\n            PrintNumberSequence(\"Tetranacci\", GetNnacciNumbers(4, 10));\n            Console.ReadKey();\n        }\n\n        private static IList<ulong> GetLucasNumbers(int length)\n        {\n            IList<ulong> seedSequence = new List<ulong>() { 2, 1 };\n            return GetFibLikeSequence(seedSequence, length);\n        }\n\n        private static IList<ulong> GetNnacciNumbers(int seedLength, int length)\n        {\n            return GetFibLikeSequence(GetNacciSeed(seedLength), length);\n        }\n\n        private static IList<ulong> GetNacciSeed(int seedLength)\n        {\n            IList<ulong> seedSquence = new List<ulong>() { 1 };\n\n            for (uint i = 0; i < seedLength - 1; i++)\n            {\n                seedSquence.Add((ulong)Math.Pow(2, i));\n            }\n\n            return seedSquence;\n        }\n\n        private static IList<ulong> GetFibLikeSequence(IList<ulong> seedSequence, int length)\n        {\n            IList<ulong> sequence = new List<ulong>();\n\n            int count = seedSequence.Count();\n\n            if (length <= count)\n            {\n                sequence = seedSequence.Take((int)length).ToList();\n            }\n            else\n            {\n                sequence = seedSequence;\n\n                for (int i = count; i < length; i++)\n                {\n                    ulong num = 0;\n\n                    for (int j = 0; j < count; j++)\n                    {\n                        num += sequence[sequence.Count - 1 - j];\n                    }\n\n                    sequence.Add(num);\n                }\n            }\n\n            return sequence;\n        }\n\n        private static void PrintNumberSequence(string Title, IList<ulong> numbersequence)\n        {\n            StringBuilder output = new StringBuilder(Title).Append(\"   \");\n\n            foreach (long item in numbersequence)\n            {\n                output.AppendFormat(\"{0}, \", item);\n            }\n\n            Console.WriteLine(output.ToString());\n        }\n    }\n}\n"}
{"id": 38609, "name": "Fibonacci n-step number sequences", "source": "Translate Ruby to Java: def anynacci(start_sequence, count)\n  n      = start_sequence.length    \n  result = start_sequence.dup       \n  (count-n).times do                \n    result << result.last(n).sum    \n  end\n  result                       \nend\n \nnaccis = { lucas:      [2,1],\n           fibonacci:  [1,1],\n           tribonacci: [1,1,2],\n           tetranacci: [1,1,2,4],\n           pentanacci: [1,1,2,4,8],\n           hexanacci:  [1,1,2,4,8,16],\n           heptanacci: [1,1,2,4,8,16,32],\n           octonacci:  [1,1,2,4,8,16,32,64],\n           nonanacci:  [1,1,2,4,8,16,32,64,128],\n           decanacci:  [1,1,2,4,8,16,32,64,128,256] }\n\nnaccis.each {|name, seq| puts \"%12s\u00a0: %p\" % [name, anynacci(seq, 15)]}\n", "target": "class Fibonacci\n{\n  public static int[] lucas(int n, int numRequested)\n  {\n    if (n < 2)\n      throw new IllegalArgumentException(\"Fibonacci value must be at least 2\");\n    return fibonacci((n == 2) ? new int[] { 2, 1 } : lucas(n - 1, n), numRequested);\n  }\n  \n  public static int[] fibonacci(int n, int numRequested)\n  {\n    if (n < 2)\n      throw new IllegalArgumentException(\"Fibonacci value must be at least 2\");\n    return fibonacci((n == 2) ? new int[] { 1, 1 } : fibonacci(n - 1, n), numRequested);\n  }\n  \n  public static int[] fibonacci(int[] startingValues, int numRequested)\n  {\n    int[] output = new int[numRequested];\n    int n = startingValues.length;\n    System.arraycopy(startingValues, 0, output, 0, n);\n    for (int i = n; i < numRequested; i++)\n      for (int j = 1; j <= n; j++)\n        output[i] += output[i - j];\n    return output;\n  }\n  \n  public static void main(String[] args)\n  {\n    for (int n = 2; n <= 10; n++)\n    {\n      System.out.print(\"nacci(\" + n + \"):\");\n      for (int value : fibonacci(n, 15))\n        System.out.print(\" \" + value);\n      System.out.println();\n    }\n    for (int n = 2; n <= 10; n++)\n    {\n      System.out.print(\"lucas(\" + n + \"):\");\n      for (int value : lucas(n, 15))\n        System.out.print(\" \" + value);\n      System.out.println();\n    }\n  }\n}\n"}
{"id": 38610, "name": "Fibonacci n-step number sequences", "source": "Translate Ruby to Java: def anynacci(start_sequence, count)\n  n      = start_sequence.length    \n  result = start_sequence.dup       \n  (count-n).times do                \n    result << result.last(n).sum    \n  end\n  result                       \nend\n \nnaccis = { lucas:      [2,1],\n           fibonacci:  [1,1],\n           tribonacci: [1,1,2],\n           tetranacci: [1,1,2,4],\n           pentanacci: [1,1,2,4,8],\n           hexanacci:  [1,1,2,4,8,16],\n           heptanacci: [1,1,2,4,8,16,32],\n           octonacci:  [1,1,2,4,8,16,32,64],\n           nonanacci:  [1,1,2,4,8,16,32,64,128],\n           decanacci:  [1,1,2,4,8,16,32,64,128,256] }\n\nnaccis.each {|name, seq| puts \"%12s\u00a0: %p\" % [name, anynacci(seq, 15)]}\n", "target": "class Fibonacci\n{\n  public static int[] lucas(int n, int numRequested)\n  {\n    if (n < 2)\n      throw new IllegalArgumentException(\"Fibonacci value must be at least 2\");\n    return fibonacci((n == 2) ? new int[] { 2, 1 } : lucas(n - 1, n), numRequested);\n  }\n  \n  public static int[] fibonacci(int n, int numRequested)\n  {\n    if (n < 2)\n      throw new IllegalArgumentException(\"Fibonacci value must be at least 2\");\n    return fibonacci((n == 2) ? new int[] { 1, 1 } : fibonacci(n - 1, n), numRequested);\n  }\n  \n  public static int[] fibonacci(int[] startingValues, int numRequested)\n  {\n    int[] output = new int[numRequested];\n    int n = startingValues.length;\n    System.arraycopy(startingValues, 0, output, 0, n);\n    for (int i = n; i < numRequested; i++)\n      for (int j = 1; j <= n; j++)\n        output[i] += output[i - j];\n    return output;\n  }\n  \n  public static void main(String[] args)\n  {\n    for (int n = 2; n <= 10; n++)\n    {\n      System.out.print(\"nacci(\" + n + \"):\");\n      for (int value : fibonacci(n, 15))\n        System.out.print(\" \" + value);\n      System.out.println();\n    }\n    for (int n = 2; n <= 10; n++)\n    {\n      System.out.print(\"lucas(\" + n + \"):\");\n      for (int value : lucas(n, 15))\n        System.out.print(\" \" + value);\n      System.out.println();\n    }\n  }\n}\n"}
{"id": 38611, "name": "Fibonacci n-step number sequences", "source": "Translate Ruby to Python: def anynacci(start_sequence, count)\n  n      = start_sequence.length    \n  result = start_sequence.dup       \n  (count-n).times do                \n    result << result.last(n).sum    \n  end\n  result                       \nend\n \nnaccis = { lucas:      [2,1],\n           fibonacci:  [1,1],\n           tribonacci: [1,1,2],\n           tetranacci: [1,1,2,4],\n           pentanacci: [1,1,2,4,8],\n           hexanacci:  [1,1,2,4,8,16],\n           heptanacci: [1,1,2,4,8,16,32],\n           octonacci:  [1,1,2,4,8,16,32,64],\n           nonanacci:  [1,1,2,4,8,16,32,64,128],\n           decanacci:  [1,1,2,4,8,16,32,64,128,256] }\n\nnaccis.each {|name, seq| puts \"%12s\u00a0: %p\" % [name, anynacci(seq, 15)]}\n", "target": ">>> def fiblike(start):\n\taddnum = len(start)\n\tmemo = start[:]\n\tdef fibber(n):\n\t\ttry:\n\t\t\treturn memo[n]\n\t\texcept IndexError:\n\t\t\tans = sum(fibber(i) for i in range(n-addnum, n))\n\t\t\tmemo.append(ans)\n\t\t\treturn ans\n\treturn fibber\n\n>>> fibo = fiblike([1,1])\n>>> [fibo(i) for i in range(10)]\n[1, 1, 2, 3, 5, 8, 13, 21, 34, 55]\n>>> lucas = fiblike([2,1])\n>>> [lucas(i) for i in range(10)]\n[2, 1, 3, 4, 7, 11, 18, 29, 47, 76]\n>>> for n, name in zip(range(2,11), 'fibo tribo tetra penta hexa hepta octo nona deca'.split()) :\n\tfibber = fiblike([1] + [2**i for i in range(n-1)])\n\tprint('n=%2i, %5snacci -> %s ...' % (n, name, ' '.join(str(fibber(i)) for i in range(15))))\n\n\t\nn= 2,  fibonacci -> 1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 ...\nn= 3, tribonacci -> 1 1 2 4 7 13 24 44 81 149 274 504 927 1705 3136 ...\nn= 4, tetranacci -> 1 1 2 4 8 15 29 56 108 208 401 773 1490 2872 5536 ...\nn= 5, pentanacci -> 1 1 2 4 8 16 31 61 120 236 464 912 1793 3525 6930 ...\nn= 6,  hexanacci -> 1 1 2 4 8 16 32 63 125 248 492 976 1936 3840 7617 ...\nn= 7, heptanacci -> 1 1 2 4 8 16 32 64 127 253 504 1004 2000 3984 7936 ...\nn= 8,  octonacci -> 1 1 2 4 8 16 32 64 128 255 509 1016 2028 4048 8080 ...\nn= 9,  nonanacci -> 1 1 2 4 8 16 32 64 128 256 511 1021 2040 4076 8144 ...\nn=10,  decanacci -> 1 1 2 4 8 16 32 64 128 256 512 1023 2045 4088 8172 ...\n>>>\n"}
{"id": 38612, "name": "Fibonacci n-step number sequences", "source": "Translate Ruby to Python: def anynacci(start_sequence, count)\n  n      = start_sequence.length    \n  result = start_sequence.dup       \n  (count-n).times do                \n    result << result.last(n).sum    \n  end\n  result                       \nend\n \nnaccis = { lucas:      [2,1],\n           fibonacci:  [1,1],\n           tribonacci: [1,1,2],\n           tetranacci: [1,1,2,4],\n           pentanacci: [1,1,2,4,8],\n           hexanacci:  [1,1,2,4,8,16],\n           heptanacci: [1,1,2,4,8,16,32],\n           octonacci:  [1,1,2,4,8,16,32,64],\n           nonanacci:  [1,1,2,4,8,16,32,64,128],\n           decanacci:  [1,1,2,4,8,16,32,64,128,256] }\n\nnaccis.each {|name, seq| puts \"%12s\u00a0: %p\" % [name, anynacci(seq, 15)]}\n", "target": ">>> def fiblike(start):\n\taddnum = len(start)\n\tmemo = start[:]\n\tdef fibber(n):\n\t\ttry:\n\t\t\treturn memo[n]\n\t\texcept IndexError:\n\t\t\tans = sum(fibber(i) for i in range(n-addnum, n))\n\t\t\tmemo.append(ans)\n\t\t\treturn ans\n\treturn fibber\n\n>>> fibo = fiblike([1,1])\n>>> [fibo(i) for i in range(10)]\n[1, 1, 2, 3, 5, 8, 13, 21, 34, 55]\n>>> lucas = fiblike([2,1])\n>>> [lucas(i) for i in range(10)]\n[2, 1, 3, 4, 7, 11, 18, 29, 47, 76]\n>>> for n, name in zip(range(2,11), 'fibo tribo tetra penta hexa hepta octo nona deca'.split()) :\n\tfibber = fiblike([1] + [2**i for i in range(n-1)])\n\tprint('n=%2i, %5snacci -> %s ...' % (n, name, ' '.join(str(fibber(i)) for i in range(15))))\n\n\t\nn= 2,  fibonacci -> 1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 ...\nn= 3, tribonacci -> 1 1 2 4 7 13 24 44 81 149 274 504 927 1705 3136 ...\nn= 4, tetranacci -> 1 1 2 4 8 15 29 56 108 208 401 773 1490 2872 5536 ...\nn= 5, pentanacci -> 1 1 2 4 8 16 31 61 120 236 464 912 1793 3525 6930 ...\nn= 6,  hexanacci -> 1 1 2 4 8 16 32 63 125 248 492 976 1936 3840 7617 ...\nn= 7, heptanacci -> 1 1 2 4 8 16 32 64 127 253 504 1004 2000 3984 7936 ...\nn= 8,  octonacci -> 1 1 2 4 8 16 32 64 128 255 509 1016 2028 4048 8080 ...\nn= 9,  nonanacci -> 1 1 2 4 8 16 32 64 128 256 511 1021 2040 4076 8144 ...\nn=10,  decanacci -> 1 1 2 4 8 16 32 64 128 256 512 1023 2045 4088 8172 ...\n>>>\n"}
{"id": 38906, "name": "Generic swap", "source": "Translate Ruby to C#: a, b = b, a\n", "target": "static void Swap<T>(ref T a, ref T b)\n{\n    T temp = a;\n    a = b;\n    b = temp;\n}\n"}
{"id": 38908, "name": "Generic swap", "source": "Translate Ruby to Java: a, b = b, a\n", "target": "class Pair<T> {\n    T first;\n    T second;\n}\npublic static <T> void swap(Pair<T> p) {\n   T temp = p.first;\n   p.first = p.second;\n   p.second = temp;\n}\n"}
{"id": 39171, "name": "Elementary cellular automaton", "source": "Translate Ruby to C#: class ElemCellAutomat\n  include Enumerable\n  \n  def initialize (start_str, rule, disp=false)\n    @cur = start_str\n    @patterns = Hash[8.times.map{|i|[\"%03b\"%i, \"01\"[rule[i]]]}]\n    puts \"Rule (\n  end\n  \n  def each\n    return to_enum unless block_given?\n    loop do\n      yield @cur\n      str = @cur[-1] + @cur + @cur[0]\n      @cur = @cur.size.times.map {|i| @patterns[str[i,3]]}.join\n    end\n  end\n  \nend\n\neca = ElemCellAutomat.new('1'.center(39, \"0\"), 18, true)\neca.take(30).each{|line| puts line.tr(\"01\", \".\n", "target": "using System;\nusing System.Collections;\nnamespace ElementaryCellularAutomaton\n{\n    class Automata\n    {\n        BitArray cells, ncells;\n        const int MAX_CELLS = 19;\n\n        public void run()\n        {\n            cells = new BitArray(MAX_CELLS);\n            ncells = new BitArray(MAX_CELLS);\n            while (true)\n            {\n                Console.Clear();\n                Console.WriteLine(\"What Rule do you want to visualize\");\n                doRule(int.Parse(Console.ReadLine()));\n                Console.WriteLine(\"Press any key to continue...\");\n                Console.ReadKey();\n            }\n        }\n\n        private byte getCells(int index)\n        {\n            byte b;\n            int i1 = index - 1,\n                i2 = index,\n                i3 = index + 1;\n\n            if (i1 < 0) i1 = MAX_CELLS - 1;\n            if (i3 >= MAX_CELLS) i3 -= MAX_CELLS;\n\n            b = Convert.ToByte(\n                4 * Convert.ToByte(cells.Get(i1)) +\n                2 * Convert.ToByte(cells.Get(i2)) +\n                Convert.ToByte(cells.Get(i3)));\n            return b;\n        }\n\n        private string getBase2(int i)\n        {\n            string s = Convert.ToString(i, 2);\n            while (s.Length < 8)\n            { s = \"0\" + s; }\n            return s;\n        }\n\n        private void doRule(int rule)\n        {\n            Console.Clear();\n            string rl = getBase2(rule);\n            cells.SetAll(false);\n            ncells.SetAll(false);\n            cells.Set(MAX_CELLS / 2, true);\n\n            Console.WriteLine(\"Rule: \" + rule + \"\\n----------\\n\");\n\n            for (int gen = 0; gen < 51; gen++)\n            {\n                Console.Write(\"{0, 4}\", gen + \": \");\n\n                foreach (bool b in cells)\n                    Console.Write(b ? \"#\" : \".\");\n\n                Console.WriteLine(\"\");\n\n                int i = 0;\n                while (true)\n                {\n                    byte b = getCells(i);\n                    ncells[i] = '1' == rl[7 - b] ? true : false;\n                    if (++i == MAX_CELLS) break;\n                }\n\n                i = 0;\n                foreach (bool b in ncells)\n                    cells[i++] = b;\n            }\n            Console.WriteLine(\"\");\n        }\n\n    };\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            Automata t = new Automata();\n            t.run();\n        }\n    }\n}\n"}
{"id": 39172, "name": "Elementary cellular automaton", "source": "Translate Ruby to C#: class ElemCellAutomat\n  include Enumerable\n  \n  def initialize (start_str, rule, disp=false)\n    @cur = start_str\n    @patterns = Hash[8.times.map{|i|[\"%03b\"%i, \"01\"[rule[i]]]}]\n    puts \"Rule (\n  end\n  \n  def each\n    return to_enum unless block_given?\n    loop do\n      yield @cur\n      str = @cur[-1] + @cur + @cur[0]\n      @cur = @cur.size.times.map {|i| @patterns[str[i,3]]}.join\n    end\n  end\n  \nend\n\neca = ElemCellAutomat.new('1'.center(39, \"0\"), 18, true)\neca.take(30).each{|line| puts line.tr(\"01\", \".\n", "target": "using System;\nusing System.Collections;\nnamespace ElementaryCellularAutomaton\n{\n    class Automata\n    {\n        BitArray cells, ncells;\n        const int MAX_CELLS = 19;\n\n        public void run()\n        {\n            cells = new BitArray(MAX_CELLS);\n            ncells = new BitArray(MAX_CELLS);\n            while (true)\n            {\n                Console.Clear();\n                Console.WriteLine(\"What Rule do you want to visualize\");\n                doRule(int.Parse(Console.ReadLine()));\n                Console.WriteLine(\"Press any key to continue...\");\n                Console.ReadKey();\n            }\n        }\n\n        private byte getCells(int index)\n        {\n            byte b;\n            int i1 = index - 1,\n                i2 = index,\n                i3 = index + 1;\n\n            if (i1 < 0) i1 = MAX_CELLS - 1;\n            if (i3 >= MAX_CELLS) i3 -= MAX_CELLS;\n\n            b = Convert.ToByte(\n                4 * Convert.ToByte(cells.Get(i1)) +\n                2 * Convert.ToByte(cells.Get(i2)) +\n                Convert.ToByte(cells.Get(i3)));\n            return b;\n        }\n\n        private string getBase2(int i)\n        {\n            string s = Convert.ToString(i, 2);\n            while (s.Length < 8)\n            { s = \"0\" + s; }\n            return s;\n        }\n\n        private void doRule(int rule)\n        {\n            Console.Clear();\n            string rl = getBase2(rule);\n            cells.SetAll(false);\n            ncells.SetAll(false);\n            cells.Set(MAX_CELLS / 2, true);\n\n            Console.WriteLine(\"Rule: \" + rule + \"\\n----------\\n\");\n\n            for (int gen = 0; gen < 51; gen++)\n            {\n                Console.Write(\"{0, 4}\", gen + \": \");\n\n                foreach (bool b in cells)\n                    Console.Write(b ? \"#\" : \".\");\n\n                Console.WriteLine(\"\");\n\n                int i = 0;\n                while (true)\n                {\n                    byte b = getCells(i);\n                    ncells[i] = '1' == rl[7 - b] ? true : false;\n                    if (++i == MAX_CELLS) break;\n                }\n\n                i = 0;\n                foreach (bool b in ncells)\n                    cells[i++] = b;\n            }\n            Console.WriteLine(\"\");\n        }\n\n    };\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            Automata t = new Automata();\n            t.run();\n        }\n    }\n}\n"}
{"id": 39175, "name": "Elementary cellular automaton", "source": "Translate Ruby to Java: class ElemCellAutomat\n  include Enumerable\n  \n  def initialize (start_str, rule, disp=false)\n    @cur = start_str\n    @patterns = Hash[8.times.map{|i|[\"%03b\"%i, \"01\"[rule[i]]]}]\n    puts \"Rule (\n  end\n  \n  def each\n    return to_enum unless block_given?\n    loop do\n      yield @cur\n      str = @cur[-1] + @cur + @cur[0]\n      @cur = @cur.size.times.map {|i| @patterns[str[i,3]]}.join\n    end\n  end\n  \nend\n\neca = ElemCellAutomat.new('1'.center(39, \"0\"), 18, true)\neca.take(30).each{|line| puts line.tr(\"01\", \".\n", "target": "import java.awt.*;\nimport java.awt.event.ActionEvent;\nimport javax.swing.*;\nimport javax.swing.Timer;\n\npublic class WolframCA extends JPanel {\n    final int[] ruleSet = {30, 45, 50, 57, 62, 70, 73, 75, 86, 89, 90, 99,\n        101, 105, 109, 110, 124, 129, 133, 135, 137, 139, 141, 164,170, 232};\n    byte[][] cells;\n    int rule = 0;\n\n    public WolframCA() {\n        Dimension dim = new Dimension(900, 450);\n        setPreferredSize(dim);\n        setBackground(Color.white);\n        setFont(new Font(\"SansSerif\", Font.BOLD, 28));\n\n        cells = new byte[dim.height][dim.width];\n        cells[0][dim.width / 2] = 1;\n\n        new Timer(5000, (ActionEvent e) -> {\n            rule++;\n            if (rule == ruleSet.length)\n                rule = 0;\n            repaint();\n        }).start();\n    }\n\n    private byte rules(int lhs, int mid, int rhs) {\n        int idx = (lhs << 2 | mid << 1 | rhs);\n        return (byte) (ruleSet[rule] >> idx & 1);\n    }\n\n    void drawCa(Graphics2D g) {\n        g.setColor(Color.black);\n        for (int r = 0; r < cells.length - 1; r++) {\n            for (int c = 1; c < cells[r].length - 1; c++) {\n                byte lhs = cells[r][c - 1];\n                byte mid = cells[r][c];\n                byte rhs = cells[r][c + 1];\n                cells[r + 1][c] = rules(lhs, mid, rhs); \n                if (cells[r][c] == 1) {\n                    g.fillRect(c, r, 1, 1);\n                }\n            }\n        }\n    }\n\n    void drawLegend(Graphics2D g) {\n        String s = String.valueOf(ruleSet[rule]);\n        int sw = g.getFontMetrics().stringWidth(s);\n\n        g.setColor(Color.white);\n        g.fillRect(16, 5, 55, 30);\n\n        g.setColor(Color.darkGray);\n        g.drawString(s, 16 + (55 - sw) / 2, 30);\n    }\n\n    @Override\n    public void paintComponent(Graphics gg) {\n        super.paintComponent(gg);\n        Graphics2D g = (Graphics2D) gg;\n        g.setRenderingHint(RenderingHints.KEY_ANTIALIASING,\n                RenderingHints.VALUE_ANTIALIAS_ON);\n\n        drawCa(g);\n        drawLegend(g);\n    }\n\n    public static void main(String[] args) {\n        SwingUtilities.invokeLater(() -> {\n            JFrame f = new JFrame();\n            f.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n            f.setTitle(\"Wolfram CA\");\n            f.setResizable(false);\n            f.add(new WolframCA(), BorderLayout.CENTER);\n            f.pack();\n            f.setLocationRelativeTo(null);\n            f.setVisible(true);\n        });\n    }\n}\n"}
{"id": 39176, "name": "Elementary cellular automaton", "source": "Translate Ruby to Java: class ElemCellAutomat\n  include Enumerable\n  \n  def initialize (start_str, rule, disp=false)\n    @cur = start_str\n    @patterns = Hash[8.times.map{|i|[\"%03b\"%i, \"01\"[rule[i]]]}]\n    puts \"Rule (\n  end\n  \n  def each\n    return to_enum unless block_given?\n    loop do\n      yield @cur\n      str = @cur[-1] + @cur + @cur[0]\n      @cur = @cur.size.times.map {|i| @patterns[str[i,3]]}.join\n    end\n  end\n  \nend\n\neca = ElemCellAutomat.new('1'.center(39, \"0\"), 18, true)\neca.take(30).each{|line| puts line.tr(\"01\", \".\n", "target": "import java.awt.*;\nimport java.awt.event.ActionEvent;\nimport javax.swing.*;\nimport javax.swing.Timer;\n\npublic class WolframCA extends JPanel {\n    final int[] ruleSet = {30, 45, 50, 57, 62, 70, 73, 75, 86, 89, 90, 99,\n        101, 105, 109, 110, 124, 129, 133, 135, 137, 139, 141, 164,170, 232};\n    byte[][] cells;\n    int rule = 0;\n\n    public WolframCA() {\n        Dimension dim = new Dimension(900, 450);\n        setPreferredSize(dim);\n        setBackground(Color.white);\n        setFont(new Font(\"SansSerif\", Font.BOLD, 28));\n\n        cells = new byte[dim.height][dim.width];\n        cells[0][dim.width / 2] = 1;\n\n        new Timer(5000, (ActionEvent e) -> {\n            rule++;\n            if (rule == ruleSet.length)\n                rule = 0;\n            repaint();\n        }).start();\n    }\n\n    private byte rules(int lhs, int mid, int rhs) {\n        int idx = (lhs << 2 | mid << 1 | rhs);\n        return (byte) (ruleSet[rule] >> idx & 1);\n    }\n\n    void drawCa(Graphics2D g) {\n        g.setColor(Color.black);\n        for (int r = 0; r < cells.length - 1; r++) {\n            for (int c = 1; c < cells[r].length - 1; c++) {\n                byte lhs = cells[r][c - 1];\n                byte mid = cells[r][c];\n                byte rhs = cells[r][c + 1];\n                cells[r + 1][c] = rules(lhs, mid, rhs); \n                if (cells[r][c] == 1) {\n                    g.fillRect(c, r, 1, 1);\n                }\n            }\n        }\n    }\n\n    void drawLegend(Graphics2D g) {\n        String s = String.valueOf(ruleSet[rule]);\n        int sw = g.getFontMetrics().stringWidth(s);\n\n        g.setColor(Color.white);\n        g.fillRect(16, 5, 55, 30);\n\n        g.setColor(Color.darkGray);\n        g.drawString(s, 16 + (55 - sw) / 2, 30);\n    }\n\n    @Override\n    public void paintComponent(Graphics gg) {\n        super.paintComponent(gg);\n        Graphics2D g = (Graphics2D) gg;\n        g.setRenderingHint(RenderingHints.KEY_ANTIALIASING,\n                RenderingHints.VALUE_ANTIALIAS_ON);\n\n        drawCa(g);\n        drawLegend(g);\n    }\n\n    public static void main(String[] args) {\n        SwingUtilities.invokeLater(() -> {\n            JFrame f = new JFrame();\n            f.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n            f.setTitle(\"Wolfram CA\");\n            f.setResizable(false);\n            f.add(new WolframCA(), BorderLayout.CENTER);\n            f.pack();\n            f.setLocationRelativeTo(null);\n            f.setVisible(true);\n        });\n    }\n}\n"}
{"id": 39177, "name": "Elementary cellular automaton", "source": "Translate Ruby to Python: class ElemCellAutomat\n  include Enumerable\n  \n  def initialize (start_str, rule, disp=false)\n    @cur = start_str\n    @patterns = Hash[8.times.map{|i|[\"%03b\"%i, \"01\"[rule[i]]]}]\n    puts \"Rule (\n  end\n  \n  def each\n    return to_enum unless block_given?\n    loop do\n      yield @cur\n      str = @cur[-1] + @cur + @cur[0]\n      @cur = @cur.size.times.map {|i| @patterns[str[i,3]]}.join\n    end\n  end\n  \nend\n\neca = ElemCellAutomat.new('1'.center(39, \"0\"), 18, true)\neca.take(30).each{|line| puts line.tr(\"01\", \".\n", "target": "def eca(cells, rule):\n    lencells = len(cells)\n    c = \"0\" + cells + \"0\"    \n    rulebits = '{0:08b}'.format(rule)\n    neighbours2next = {'{0:03b}'.format(n):rulebits[::-1][n] for n in range(8)}\n    yield c[1:-1]\n    while True:\n        c = ''.join(['0',\n                     ''.join(neighbours2next[c[i-1:i+2]]\n                             for i in range(1,lencells+1)),\n                     '0'])\n        yield c[1:-1]\n\nif __name__ == '__main__':\n    lines, start, rules = 50, '0000000001000000000', (90, 30, 122)\n    zipped = [range(lines)] + [eca(start, rule) for rule in rules]\n    print('\\n   Rules: %r' % (rules,))\n    for data in zip(*zipped):\n        i = data[0]\n        cells = data[1:]\n        print('%2i: %s' % (i, '    '.join(cells).replace('0', '.').replace('1', '\n"}
{"id": 39178, "name": "Elementary cellular automaton", "source": "Translate Ruby to Python: class ElemCellAutomat\n  include Enumerable\n  \n  def initialize (start_str, rule, disp=false)\n    @cur = start_str\n    @patterns = Hash[8.times.map{|i|[\"%03b\"%i, \"01\"[rule[i]]]}]\n    puts \"Rule (\n  end\n  \n  def each\n    return to_enum unless block_given?\n    loop do\n      yield @cur\n      str = @cur[-1] + @cur + @cur[0]\n      @cur = @cur.size.times.map {|i| @patterns[str[i,3]]}.join\n    end\n  end\n  \nend\n\neca = ElemCellAutomat.new('1'.center(39, \"0\"), 18, true)\neca.take(30).each{|line| puts line.tr(\"01\", \".\n", "target": "def eca(cells, rule):\n    lencells = len(cells)\n    c = \"0\" + cells + \"0\"    \n    rulebits = '{0:08b}'.format(rule)\n    neighbours2next = {'{0:03b}'.format(n):rulebits[::-1][n] for n in range(8)}\n    yield c[1:-1]\n    while True:\n        c = ''.join(['0',\n                     ''.join(neighbours2next[c[i-1:i+2]]\n                             for i in range(1,lencells+1)),\n                     '0'])\n        yield c[1:-1]\n\nif __name__ == '__main__':\n    lines, start, rules = 50, '0000000001000000000', (90, 30, 122)\n    zipped = [range(lines)] + [eca(start, rule) for rule in rules]\n    print('\\n   Rules: %r' % (rules,))\n    for data in zip(*zipped):\n        i = data[0]\n        cells = data[1:]\n        print('%2i: %s' % (i, '    '.join(cells).replace('0', '.').replace('1', '\n"}
{"id": 39400, "name": "Modular arithmetic", "source": "Translate Ruby to C#: \n\nclass Modulo\n  include Comparable\n\n  def initialize(n = 0, m = 13)\n    @n, @m = n % m, m\n  end\n\n  def to_i\n    @n\n  end\n \n  def <=>(other_n)\n    @n <=> other_n.to_i\n  end\n\n  [:+, :-, :*, :**].each do |meth|\n    define_method(meth) { |other_n| Modulo.new(@n.send(meth, other_n.to_i), @m) }\n  end\n\n  def coerce(numeric)\n    [numeric, @n]\n  end\n\nend\n\n\nx, y = Modulo.new(10), Modulo.new(20)\n\np x > y          \np x == y         \np [x,y].sort     \np x + y          \np 2 + y          \np y + 2          \n\np x**100 + x +1  \n", "target": "using System;\n\nnamespace ModularArithmetic {\n    interface IAddition<T> {\n        T Add(T rhs);\n    }\n    interface IMultiplication<T> {\n        T Multiply(T rhs);\n    }\n    interface IPower<T> {\n        T Power(int pow);\n    }\n    interface IOne<T> {\n        T One();\n    }\n\n    class ModInt : IAddition<ModInt>, IMultiplication<ModInt>, IPower<ModInt>, IOne<ModInt> {\n        private int modulo;\n\n        public ModInt(int value, int modulo) {\n            Value = value;\n            this.modulo = modulo;\n        }\n\n        public int Value { get; }\n\n        public ModInt One() {\n            return new ModInt(1, modulo);\n        }\n\n        public ModInt Add(ModInt rhs) {\n            return this + rhs;\n        }\n\n        public ModInt Multiply(ModInt rhs) {\n            return this * rhs;\n        }\n\n        public ModInt Power(int pow) {\n            return Pow(this, pow);\n        }\n\n        public override string ToString() {\n            return string.Format(\"ModInt({0}, {1})\", Value, modulo);\n        }\n\n        public static ModInt operator +(ModInt lhs, ModInt rhs) {\n            if (lhs.modulo != rhs.modulo) {\n                throw new ArgumentException(\"Cannot add rings with different modulus\");\n            }\n            return new ModInt((lhs.Value + rhs.Value) % lhs.modulo, lhs.modulo);\n        }\n\n        public static ModInt operator *(ModInt lhs, ModInt rhs) {\n            if (lhs.modulo != rhs.modulo) {\n                throw new ArgumentException(\"Cannot add rings with different modulus\");\n            }\n            return new ModInt((lhs.Value * rhs.Value) % lhs.modulo, lhs.modulo);\n        }\n\n        public static ModInt Pow(ModInt self, int p) {\n            if (p < 0) {\n                throw new ArgumentException(\"p must be zero or greater\");\n            }\n\n            int pp = p;\n            ModInt pwr = self.One();\n            while (pp-- > 0) {\n                pwr *= self;\n            }\n            return pwr;\n        }\n    }\n\n    class Program {\n        static T F<T>(T x) where T : IAddition<T>, IMultiplication<T>, IPower<T>, IOne<T> {\n            return x.Power(100).Add(x).Add(x.One());\n        }\n\n        static void Main(string[] args) {\n            ModInt x = new ModInt(10, 13);\n            ModInt y = F(x);\n            Console.WriteLine(\"x ^ 100 + x + 1 for x = {0} is {1}\", x, y);\n        }\n    }\n}\n"}
{"id": 39401, "name": "Modular arithmetic", "source": "Translate Ruby to C#: \n\nclass Modulo\n  include Comparable\n\n  def initialize(n = 0, m = 13)\n    @n, @m = n % m, m\n  end\n\n  def to_i\n    @n\n  end\n \n  def <=>(other_n)\n    @n <=> other_n.to_i\n  end\n\n  [:+, :-, :*, :**].each do |meth|\n    define_method(meth) { |other_n| Modulo.new(@n.send(meth, other_n.to_i), @m) }\n  end\n\n  def coerce(numeric)\n    [numeric, @n]\n  end\n\nend\n\n\nx, y = Modulo.new(10), Modulo.new(20)\n\np x > y          \np x == y         \np [x,y].sort     \np x + y          \np 2 + y          \np y + 2          \n\np x**100 + x +1  \n", "target": "using System;\n\nnamespace ModularArithmetic {\n    interface IAddition<T> {\n        T Add(T rhs);\n    }\n    interface IMultiplication<T> {\n        T Multiply(T rhs);\n    }\n    interface IPower<T> {\n        T Power(int pow);\n    }\n    interface IOne<T> {\n        T One();\n    }\n\n    class ModInt : IAddition<ModInt>, IMultiplication<ModInt>, IPower<ModInt>, IOne<ModInt> {\n        private int modulo;\n\n        public ModInt(int value, int modulo) {\n            Value = value;\n            this.modulo = modulo;\n        }\n\n        public int Value { get; }\n\n        public ModInt One() {\n            return new ModInt(1, modulo);\n        }\n\n        public ModInt Add(ModInt rhs) {\n            return this + rhs;\n        }\n\n        public ModInt Multiply(ModInt rhs) {\n            return this * rhs;\n        }\n\n        public ModInt Power(int pow) {\n            return Pow(this, pow);\n        }\n\n        public override string ToString() {\n            return string.Format(\"ModInt({0}, {1})\", Value, modulo);\n        }\n\n        public static ModInt operator +(ModInt lhs, ModInt rhs) {\n            if (lhs.modulo != rhs.modulo) {\n                throw new ArgumentException(\"Cannot add rings with different modulus\");\n            }\n            return new ModInt((lhs.Value + rhs.Value) % lhs.modulo, lhs.modulo);\n        }\n\n        public static ModInt operator *(ModInt lhs, ModInt rhs) {\n            if (lhs.modulo != rhs.modulo) {\n                throw new ArgumentException(\"Cannot add rings with different modulus\");\n            }\n            return new ModInt((lhs.Value * rhs.Value) % lhs.modulo, lhs.modulo);\n        }\n\n        public static ModInt Pow(ModInt self, int p) {\n            if (p < 0) {\n                throw new ArgumentException(\"p must be zero or greater\");\n            }\n\n            int pp = p;\n            ModInt pwr = self.One();\n            while (pp-- > 0) {\n                pwr *= self;\n            }\n            return pwr;\n        }\n    }\n\n    class Program {\n        static T F<T>(T x) where T : IAddition<T>, IMultiplication<T>, IPower<T>, IOne<T> {\n            return x.Power(100).Add(x).Add(x.One());\n        }\n\n        static void Main(string[] args) {\n            ModInt x = new ModInt(10, 13);\n            ModInt y = F(x);\n            Console.WriteLine(\"x ^ 100 + x + 1 for x = {0} is {1}\", x, y);\n        }\n    }\n}\n"}
{"id": 39404, "name": "Modular arithmetic", "source": "Translate Ruby to Java: \n\nclass Modulo\n  include Comparable\n\n  def initialize(n = 0, m = 13)\n    @n, @m = n % m, m\n  end\n\n  def to_i\n    @n\n  end\n \n  def <=>(other_n)\n    @n <=> other_n.to_i\n  end\n\n  [:+, :-, :*, :**].each do |meth|\n    define_method(meth) { |other_n| Modulo.new(@n.send(meth, other_n.to_i), @m) }\n  end\n\n  def coerce(numeric)\n    [numeric, @n]\n  end\n\nend\n\n\nx, y = Modulo.new(10), Modulo.new(20)\n\np x > y          \np x == y         \np [x,y].sort     \np x + y          \np 2 + y          \np y + 2          \n\np x**100 + x +1  \n", "target": "public class ModularArithmetic {\n    private interface Ring<T> {\n        Ring<T> plus(Ring<T> rhs);\n\n        Ring<T> times(Ring<T> rhs);\n\n        int value();\n\n        Ring<T> one();\n\n        default Ring<T> pow(int p) {\n            if (p < 0) {\n                throw new IllegalArgumentException(\"p must be zero or greater\");\n            }\n\n            int pp = p;\n            Ring<T> pwr = this.one();\n            while (pp-- > 0) {\n                pwr = pwr.times(this);\n            }\n            return pwr;\n        }\n    }\n\n    private static class ModInt implements Ring<ModInt> {\n        private int value;\n        private int modulo;\n\n        private ModInt(int value, int modulo) {\n            this.value = value;\n            this.modulo = modulo;\n        }\n\n        @Override\n        public Ring<ModInt> plus(Ring<ModInt> other) {\n            if (!(other instanceof ModInt)) {\n                throw new IllegalArgumentException(\"Cannot add an unknown ring.\");\n            }\n            ModInt rhs = (ModInt) other;\n            if (modulo != rhs.modulo) {\n                throw new IllegalArgumentException(\"Cannot add rings with different modulus\");\n            }\n            return new ModInt((value + rhs.value) % modulo, modulo);\n        }\n\n        @Override\n        public Ring<ModInt> times(Ring<ModInt> other) {\n            if (!(other instanceof ModInt)) {\n                throw new IllegalArgumentException(\"Cannot multiple an unknown ring.\");\n            }\n            ModInt rhs = (ModInt) other;\n            if (modulo != rhs.modulo) {\n                throw new IllegalArgumentException(\"Cannot multiply rings with different modulus\");\n            }\n            return new ModInt((value * rhs.value) % modulo, modulo);\n        }\n\n        @Override\n        public int value() {\n            return value;\n        }\n\n        @Override\n        public Ring<ModInt> one() {\n            return new ModInt(1, modulo);\n        }\n\n        @Override\n        public String toString() {\n            return String.format(\"ModInt(%d, %d)\", value, modulo);\n        }\n    }\n\n    private static <T> Ring<T> f(Ring<T> x) {\n        return x.pow(100).plus(x).plus(x.one());\n    }\n\n    public static void main(String[] args) {\n        ModInt x = new ModInt(10, 13);\n        Ring<ModInt> y = f(x);\n        System.out.print(\"x ^ 100 + x + 1 for x = ModInt(10, 13) is \");\n        System.out.println(y);\n        System.out.flush();\n    }\n}\n"}
{"id": 39405, "name": "Modular arithmetic", "source": "Translate Ruby to Java: \n\nclass Modulo\n  include Comparable\n\n  def initialize(n = 0, m = 13)\n    @n, @m = n % m, m\n  end\n\n  def to_i\n    @n\n  end\n \n  def <=>(other_n)\n    @n <=> other_n.to_i\n  end\n\n  [:+, :-, :*, :**].each do |meth|\n    define_method(meth) { |other_n| Modulo.new(@n.send(meth, other_n.to_i), @m) }\n  end\n\n  def coerce(numeric)\n    [numeric, @n]\n  end\n\nend\n\n\nx, y = Modulo.new(10), Modulo.new(20)\n\np x > y          \np x == y         \np [x,y].sort     \np x + y          \np 2 + y          \np y + 2          \n\np x**100 + x +1  \n", "target": "public class ModularArithmetic {\n    private interface Ring<T> {\n        Ring<T> plus(Ring<T> rhs);\n\n        Ring<T> times(Ring<T> rhs);\n\n        int value();\n\n        Ring<T> one();\n\n        default Ring<T> pow(int p) {\n            if (p < 0) {\n                throw new IllegalArgumentException(\"p must be zero or greater\");\n            }\n\n            int pp = p;\n            Ring<T> pwr = this.one();\n            while (pp-- > 0) {\n                pwr = pwr.times(this);\n            }\n            return pwr;\n        }\n    }\n\n    private static class ModInt implements Ring<ModInt> {\n        private int value;\n        private int modulo;\n\n        private ModInt(int value, int modulo) {\n            this.value = value;\n            this.modulo = modulo;\n        }\n\n        @Override\n        public Ring<ModInt> plus(Ring<ModInt> other) {\n            if (!(other instanceof ModInt)) {\n                throw new IllegalArgumentException(\"Cannot add an unknown ring.\");\n            }\n            ModInt rhs = (ModInt) other;\n            if (modulo != rhs.modulo) {\n                throw new IllegalArgumentException(\"Cannot add rings with different modulus\");\n            }\n            return new ModInt((value + rhs.value) % modulo, modulo);\n        }\n\n        @Override\n        public Ring<ModInt> times(Ring<ModInt> other) {\n            if (!(other instanceof ModInt)) {\n                throw new IllegalArgumentException(\"Cannot multiple an unknown ring.\");\n            }\n            ModInt rhs = (ModInt) other;\n            if (modulo != rhs.modulo) {\n                throw new IllegalArgumentException(\"Cannot multiply rings with different modulus\");\n            }\n            return new ModInt((value * rhs.value) % modulo, modulo);\n        }\n\n        @Override\n        public int value() {\n            return value;\n        }\n\n        @Override\n        public Ring<ModInt> one() {\n            return new ModInt(1, modulo);\n        }\n\n        @Override\n        public String toString() {\n            return String.format(\"ModInt(%d, %d)\", value, modulo);\n        }\n    }\n\n    private static <T> Ring<T> f(Ring<T> x) {\n        return x.pow(100).plus(x).plus(x.one());\n    }\n\n    public static void main(String[] args) {\n        ModInt x = new ModInt(10, 13);\n        Ring<ModInt> y = f(x);\n        System.out.print(\"x ^ 100 + x + 1 for x = ModInt(10, 13) is \");\n        System.out.println(y);\n        System.out.flush();\n    }\n}\n"}
{"id": 39406, "name": "Modular arithmetic", "source": "Translate Ruby to Python: \n\nclass Modulo\n  include Comparable\n\n  def initialize(n = 0, m = 13)\n    @n, @m = n % m, m\n  end\n\n  def to_i\n    @n\n  end\n \n  def <=>(other_n)\n    @n <=> other_n.to_i\n  end\n\n  [:+, :-, :*, :**].each do |meth|\n    define_method(meth) { |other_n| Modulo.new(@n.send(meth, other_n.to_i), @m) }\n  end\n\n  def coerce(numeric)\n    [numeric, @n]\n  end\n\nend\n\n\nx, y = Modulo.new(10), Modulo.new(20)\n\np x > y          \np x == y         \np [x,y].sort     \np x + y          \np 2 + y          \np y + 2          \n\np x**100 + x +1  \n", "target": "import operator\nimport functools\n\n@functools.total_ordering\nclass Mod:\n    __slots__ = ['val','mod']\n\n    def __init__(self, val, mod):\n        if not isinstance(val, int):\n            raise ValueError('Value must be integer')\n        if not isinstance(mod, int) or mod<=0:\n            raise ValueError('Modulo must be positive integer')\n        self.val = val % mod\n        self.mod = mod\n\n    def __repr__(self):\n        return 'Mod({}, {})'.format(self.val, self.mod)\n\n    def __int__(self):\n        return self.val\n\n    def __eq__(self, other):\n        if isinstance(other, Mod):\n            if self.mod == other.mod:\n                return self.val==other.val\n            else:\n                return NotImplemented\n        elif isinstance(other, int):\n            return self.val == other\n        else:\n            return NotImplemented\n\n    def __lt__(self, other):\n        if isinstance(other, Mod):\n            if self.mod == other.mod:\n                return self.val<other.val\n            else:\n                return NotImplemented\n        elif isinstance(other, int):\n            return self.val < other\n        else:\n            return NotImplemented\n\n    def _check_operand(self, other):\n        if not isinstance(other, (int, Mod)):\n            raise TypeError('Only integer and Mod operands are supported')\n        if isinstance(other, Mod) and self.mod != other.mod:\n            raise ValueError('Inconsistent modulus: {} vs. {}'.format(self.mod, other.mod))\n\n    def __pow__(self, other):\n        self._check_operand(other)\n        \n        return Mod(pow(self.val, int(other), self.mod), self.mod)\n\n    def __neg__(self):\n        return Mod(self.mod - self.val, self.mod)\n\n    def __pos__(self):\n        return self \n\n    def __abs__(self):\n        return self \n\n\n\ndef _make_op(opname):\n    op_fun = getattr(operator, opname)  \n    def op(self, other):\n        self._check_operand(other)\n        return Mod(op_fun(self.val, int(other)) % self.mod, self.mod)\n    return op\n\ndef _make_reflected_op(opname):\n    op_fun = getattr(operator, opname)\n    def op(self, other):\n        self._check_operand(other)\n        return Mod(op_fun(int(other), self.val) % self.mod, self.mod)\n    return op\n\n\nfor opname, reflected_opname in [('__add__', '__radd__'), ('__sub__', '__rsub__'), ('__mul__', '__rmul__')]:\n    setattr(Mod, opname, _make_op(opname))\n    setattr(Mod, reflected_opname, _make_reflected_op(opname))\n\ndef f(x):\n    return x**100+x+1\n\nprint(f(Mod(10,13)))\n\n"}
{"id": 39407, "name": "Modular arithmetic", "source": "Translate Ruby to Python: \n\nclass Modulo\n  include Comparable\n\n  def initialize(n = 0, m = 13)\n    @n, @m = n % m, m\n  end\n\n  def to_i\n    @n\n  end\n \n  def <=>(other_n)\n    @n <=> other_n.to_i\n  end\n\n  [:+, :-, :*, :**].each do |meth|\n    define_method(meth) { |other_n| Modulo.new(@n.send(meth, other_n.to_i), @m) }\n  end\n\n  def coerce(numeric)\n    [numeric, @n]\n  end\n\nend\n\n\nx, y = Modulo.new(10), Modulo.new(20)\n\np x > y          \np x == y         \np [x,y].sort     \np x + y          \np 2 + y          \np y + 2          \n\np x**100 + x +1  \n", "target": "import operator\nimport functools\n\n@functools.total_ordering\nclass Mod:\n    __slots__ = ['val','mod']\n\n    def __init__(self, val, mod):\n        if not isinstance(val, int):\n            raise ValueError('Value must be integer')\n        if not isinstance(mod, int) or mod<=0:\n            raise ValueError('Modulo must be positive integer')\n        self.val = val % mod\n        self.mod = mod\n\n    def __repr__(self):\n        return 'Mod({}, {})'.format(self.val, self.mod)\n\n    def __int__(self):\n        return self.val\n\n    def __eq__(self, other):\n        if isinstance(other, Mod):\n            if self.mod == other.mod:\n                return self.val==other.val\n            else:\n                return NotImplemented\n        elif isinstance(other, int):\n            return self.val == other\n        else:\n            return NotImplemented\n\n    def __lt__(self, other):\n        if isinstance(other, Mod):\n            if self.mod == other.mod:\n                return self.val<other.val\n            else:\n                return NotImplemented\n        elif isinstance(other, int):\n            return self.val < other\n        else:\n            return NotImplemented\n\n    def _check_operand(self, other):\n        if not isinstance(other, (int, Mod)):\n            raise TypeError('Only integer and Mod operands are supported')\n        if isinstance(other, Mod) and self.mod != other.mod:\n            raise ValueError('Inconsistent modulus: {} vs. {}'.format(self.mod, other.mod))\n\n    def __pow__(self, other):\n        self._check_operand(other)\n        \n        return Mod(pow(self.val, int(other), self.mod), self.mod)\n\n    def __neg__(self):\n        return Mod(self.mod - self.val, self.mod)\n\n    def __pos__(self):\n        return self \n\n    def __abs__(self):\n        return self \n\n\n\ndef _make_op(opname):\n    op_fun = getattr(operator, opname)  \n    def op(self, other):\n        self._check_operand(other)\n        return Mod(op_fun(self.val, int(other)) % self.mod, self.mod)\n    return op\n\ndef _make_reflected_op(opname):\n    op_fun = getattr(operator, opname)\n    def op(self, other):\n        self._check_operand(other)\n        return Mod(op_fun(int(other), self.val) % self.mod, self.mod)\n    return op\n\n\nfor opname, reflected_opname in [('__add__', '__radd__'), ('__sub__', '__rsub__'), ('__mul__', '__rmul__')]:\n    setattr(Mod, opname, _make_op(opname))\n    setattr(Mod, reflected_opname, _make_reflected_op(opname))\n\ndef f(x):\n    return x**100+x+1\n\nprint(f(Mod(10,13)))\n\n"}
{"id": 39628, "name": "String append", "source": "Translate Ruby to C#: s = \"Hello wo\"\ns += \"rld\" \ns << \"!\"   \nputs s\n", "target": "class Program\n{\n    static void Main(string[] args)\n    {\n        string x = \"foo\";\n        x += \"bar\";\n        System.Console.WriteLine(x);\n    }\n}\n"}
{"id": 39630, "name": "String append", "source": "Translate Ruby to Java: s = \"Hello wo\"\ns += \"rld\" \ns << \"!\"   \nputs s\n", "target": "String sa = \"Hello\";\nsa += \", World!\";\nSystem.out.println(sa);\n\nStringBuilder ba = new StringBuilder();\nba.append(\"Hello\");\nba.append(\", World!\");\nSystem.out.println(ba.toString());\n"}
{"id": 39631, "name": "String append", "source": "Translate Ruby to Python: s = \"Hello wo\"\ns += \"rld\" \ns << \"!\"   \nputs s\n", "target": "\n\n\nstr = \"12345678\";\nstr += \"9!\";\nprint(str)\n"}
{"id": 39861, "name": "Count in octal", "source": "Translate Ruby to C#: \n\n \n(0_u8..255_u8).each { |i| puts i.to_s(8) }\n", "target": "using System;\n\nclass Program\n{\n    static void Main()\n    {\n        var number = 0;\n        do\n        {\n            Console.WriteLine(Convert.ToString(number, 8));\n        } while (++number > 0);\n    }\n}\n"}
{"id": 39863, "name": "Count in octal", "source": "Translate Ruby to Java: \n\n \n(0_u8..255_u8).each { |i| puts i.to_s(8) }\n", "target": "public class Count{\n    public static void main(String[] args){\n        for(int i = 0;i >= 0;i++){\n            System.out.println(Integer.toOctalString(i)); \n        }\n    }\n}\n"}
{"id": 39864, "name": "Count in octal", "source": "Translate Ruby to Python: \n\n \n(0_u8..255_u8).each { |i| puts i.to_s(8) }\n", "target": "import sys\nfor n in xrange(sys.maxint):\n    print oct(n)\n"}
{"id": 40132, "name": "Delete a file", "source": "Translate Ruby to C#: File.delete(\"output.txt\", \"/output.txt\")\nDir.delete(\"docs\")\nDir.delete(\"/docs\")\n", "target": "using System;\nusing System.IO;\n\nnamespace DeleteFile {\n  class Program {\n    static void Main() {\n      File.Delete(\"input.txt\");\n      Directory.Delete(\"docs\");\n      File.Delete(\"/input.txt\");\n      Directory.Delete(\"/docs\");\n    }\n  }\n}\n"}
{"id": 40134, "name": "Delete a file", "source": "Translate Ruby to Java: File.delete(\"output.txt\", \"/output.txt\")\nDir.delete(\"docs\")\nDir.delete(\"/docs\")\n", "target": "import java.io.File;\n\npublic class FileDeleteTest {\n    public static boolean deleteFile(String filename) {\n        boolean exists = new File(filename).delete();\n        return exists;\n    }\n    \n    public static void test(String type, String filename) {\n        System.out.println(\"The following \" + type + \" called \" + filename + \n            (deleteFile(filename) ? \" was deleted.\" : \" could not be deleted.\")\n        );\n    }\n\n    public static void main(String args[]) {\n        test(\"file\", \"input.txt\");\n        test(\"file\", File.seperator + \"input.txt\");\n        test(\"directory\", \"docs\");\n        test(\"directory\", File.seperator + \"docs\" + File.seperator);\n    }\n}\n"}
{"id": 40135, "name": "Delete a file", "source": "Translate Ruby to Python: File.delete(\"output.txt\", \"/output.txt\")\nDir.delete(\"docs\")\nDir.delete(\"/docs\")\n", "target": "import os\n\nos.remove(\"output.txt\")\nos.rmdir(\"docs\")\n\nos.remove(\"/output.txt\")\nos.rmdir(\"/docs\")\n"}
{"id": 40414, "name": "Sum of a series", "source": "Translate Ruby to C#: puts (1..1000).sum{ |x| 1.0 / x ** 2 }\nputs (1..5000).sum{ |x| 1.0 / x ** 2 }\nputs (1..9999).sum{ |x| 1.0 / x ** 2 }\nputs Math::PI ** 2 / 6\n", "target": "class Program\n{\n    static void Main(string[] args)\n    {\n        \n\n        List<double> myList = new List<double>();\n        for (double i = 1; i < 1001; i++)\n        {\n            myList.Add(i);\n        }\n        \n\n        var sum = myList.Sum(x => 1/(x*x));\n\n        Console.WriteLine(sum);\n        Console.ReadLine();\n    }\n}\n"}
{"id": 40416, "name": "Sum of a series", "source": "Translate Ruby to Java: puts (1..1000).sum{ |x| 1.0 / x ** 2 }\nputs (1..5000).sum{ |x| 1.0 / x ** 2 }\nputs (1..9999).sum{ |x| 1.0 / x ** 2 }\nputs Math::PI ** 2 / 6\n", "target": "public class Sum{\n    public static double f(double x){\n       return 1/(x*x);\n    }\n \n    public static void main(String[] args){\n       double start = 1;\n       double end = 1000;\n       double sum = 0;\n \n       for(double x = start;x <= end;x++) sum += f(x);\n \n       System.out.println(\"Sum of f(x) from \" + start + \" to \" + end +\" is \" + sum);\n    }\n}\n"}
{"id": 40417, "name": "Sum of a series", "source": "Translate Ruby to Python: puts (1..1000).sum{ |x| 1.0 / x ** 2 }\nputs (1..5000).sum{ |x| 1.0 / x ** 2 }\nputs (1..9999).sum{ |x| 1.0 / x ** 2 }\nputs Math::PI ** 2 / 6\n", "target": "print ( sum(1.0 / (x * x) for x in range(1, 1001)) )\n"}
{"id": 40701, "name": "Sierpinski carpet", "source": "Translate Ruby to C#: def sierpinski_carpet(n)\n  carpet = [\"\n  n.times do\n    carpet = carpet.map { |x| x + x + x } +\n             carpet.map { |x| x + x.tr(\"\n             carpet.map { |x| x + x + x }\n  end\n  carpet\nend\n\n5.times{ |i| puts \"\\nN=\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\nclass Program\n{\n    static List<string> NextCarpet(List<string> carpet)\n    {\n        return carpet.Select(x => x + x + x)\n                     .Concat(carpet.Select(x => x + x.Replace('#', ' ') + x))\n                     .Concat(carpet.Select(x => x + x + x)).ToList();\n    }\n\n    static List<string> SierpinskiCarpet(int n)\n    {\n        return Enumerable.Range(1, n).Aggregate(new List<string> { \"#\" }, (carpet, _) => NextCarpet(carpet));\n    }\n\n    static void Main(string[] args)\n    {\n        foreach (string s in SierpinskiCarpet(3))\n            Console.WriteLine(s);\n    }\n}\n"}
{"id": 40703, "name": "Sierpinski carpet", "source": "Translate Ruby to Java: def sierpinski_carpet(n)\n  carpet = [\"\n  n.times do\n    carpet = carpet.map { |x| x + x + x } +\n             carpet.map { |x| x + x.tr(\"\n             carpet.map { |x| x + x + x }\n  end\n  carpet\nend\n\n5.times{ |i| puts \"\\nN=\n", "target": "public static boolean inCarpet(long x, long y) {\n    while (x!=0 && y!=0) {\n        if (x % 3 == 1 && y % 3 == 1)\n            return false;\n        x /= 3;\n        y /= 3;\n    }\n    return true;\n}\n \npublic static void carpet(final int n) {\n    final double power = Math.pow(3,n);\n    for(long i = 0; i < power; i++) {\n        for(long j = 0; j < power; j++) {\n            System.out.print(inCarpet(i, j) ? \"*\" : \" \");\n        }\n        System.out.println();\n    }\n}\n"}
{"id": 40704, "name": "Sierpinski carpet", "source": "Translate Ruby to Python: def sierpinski_carpet(n)\n  carpet = [\"\n  n.times do\n    carpet = carpet.map { |x| x + x + x } +\n             carpet.map { |x| x + x.tr(\"\n             carpet.map { |x| x + x + x }\n  end\n  carpet\nend\n\n5.times{ |i| puts \"\\nN=\n", "target": "def setup():\n    size(729, 729)\n    fill(0)\n    background(255)\n    noStroke()\n    rect(width / 3, height / 3, width / 3, width / 3)\n    rectangles(width / 3, height / 3, width / 3)\n\ndef rectangles(x, y, s):\n    if s < 1: return\n    xc, yc = x - s, y - s\n    for row in range(3):\n        for col in range(3):\n            if not (row == 1 and col == 1):\n                xx, yy = xc + row * s, yc + col * s\n                delta = s / 3\n                rect(xx + delta, yy + delta, delta, delta)\n                rectangles(xx + s / 3, yy + s / 3, s / 3)\n"}
{"id": 40860, "name": "Rosetta Code_Count examples", "source": "Translate Ruby to C#: require 'open-uri'\nrequire 'rexml/document'\n\nmodule RosettaCode\n\n  URL_ROOT = \"http://rosettacode.org/mw\"\n\n  def self.get_url(page, query)\n    begin\n      \n      pstr = URI.encode_www_form_component(page)\n      qstr = URI.encode_www_form(query)\n    rescue NoMethodError\n      require 'cgi'\n      pstr = CGI.escape(page)\n      qstr = query.map {|k,v|\n        \"%s=%s\" % [CGI.escape(k.to_s), CGI.escape(v.to_s)]}.join(\"&\")\n    end\n    url = \"\n    p url if $DEBUG\n    url\n  end\n\n  def self.get_api_url(query)\n    get_url \"api.php\", query\n  end\n\n  def self.category_members(category)\n    query = {\n      \"action\" => \"query\",\n      \"list\" => \"categorymembers\",\n      \"cmtitle\" => \"Category:\n      \"format\" => \"xml\",\n      \"cmlimit\" => 500,\n    }\n    while true\n      url = get_api_url query\n      doc = REXML::Document.new open(url)\n\n      REXML::XPath.each(doc, \"//cm\") do |task|\n        yield task.attribute(\"title\").value\n      end\n\n      continue = REXML::XPath.first(doc, \"//query-continue\")\n      break if continue.nil?\n      cm = REXML::XPath.first(continue, \"categorymembers\")\n      query[\"cmcontinue\"] = cm.attribute(\"cmcontinue\").value\n    end\n  end\n\nend\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text.RegularExpressions;\nusing System.Net;\n\nclass Task {\n    private string _task;\n    private int _examples;\n\n    public Task(string task, int examples) {\n        _task = task;\n        _examples = examples;\n    }\n\n    public string Name {\n        get { return _task; }\n    }\n\n    public int Examples {\n        get { return _examples; }\n    }\n\n    public override string ToString() {\n        return String.Format(\"{0}: {1} examples.\", this._task, this._examples);\n    }\n}\n\nclass Program {\n    static List<string> GetTitlesFromCategory(string category, WebClient wc) {\n        string content = wc.DownloadString(\n            String.Format(\"http:\n        );\n\n        return new Regex(\"\\\"title\\\":\\\"(.+?)\\\"\").Matches(content).Cast<Match>().Select(x => x.Groups[1].Value.Replace(\"\\\\/\", \"/\")).ToList();\n    }\n\n    static string GetSourceCodeFromPage(string page, WebClient wc) {\n        return wc.DownloadString(\n            String.Format(\"http:\n        );\n    }\n\n    static void Main(string[] args) {\n        WebClient wc = new WebClient();\n        List<Task> tasks = new List<Task>();\n        List<string> tasknames = GetTitlesFromCategory(\"Programming_Tasks\", wc);\n\n        foreach (string task in tasknames) {\n            try {\n                string content = GetSourceCodeFromPage(WebUtility.UrlEncode(task), wc);\n                int count = new Regex(\"=={{header\", RegexOptions.IgnoreCase).Matches(content).Count;\n                Task t = new Task(task, count);\n\n                Console.WriteLine(t);\n                tasks.Add(t);\n            }\n            catch (Exception ex) {\n                Console.WriteLine(\"****            Unable to get task \\\"\" + task + \"\\\": \" + ex.Message);\n            }\n        }\n\n        Console.WriteLine(\"\\nTotal: {0} examples.\", tasks.Select(x => x.Examples).Sum());\n    }\n}\n"}
{"id": 40861, "name": "Rosetta Code_Count examples", "source": "Translate Ruby to Java: require 'open-uri'\nrequire 'rexml/document'\n\nmodule RosettaCode\n\n  URL_ROOT = \"http://rosettacode.org/mw\"\n\n  def self.get_url(page, query)\n    begin\n      \n      pstr = URI.encode_www_form_component(page)\n      qstr = URI.encode_www_form(query)\n    rescue NoMethodError\n      require 'cgi'\n      pstr = CGI.escape(page)\n      qstr = query.map {|k,v|\n        \"%s=%s\" % [CGI.escape(k.to_s), CGI.escape(v.to_s)]}.join(\"&\")\n    end\n    url = \"\n    p url if $DEBUG\n    url\n  end\n\n  def self.get_api_url(query)\n    get_url \"api.php\", query\n  end\n\n  def self.category_members(category)\n    query = {\n      \"action\" => \"query\",\n      \"list\" => \"categorymembers\",\n      \"cmtitle\" => \"Category:\n      \"format\" => \"xml\",\n      \"cmlimit\" => 500,\n    }\n    while true\n      url = get_api_url query\n      doc = REXML::Document.new open(url)\n\n      REXML::XPath.each(doc, \"//cm\") do |task|\n        yield task.attribute(\"title\").value\n      end\n\n      continue = REXML::XPath.first(doc, \"//query-continue\")\n      break if continue.nil?\n      cm = REXML::XPath.first(continue, \"categorymembers\")\n      query[\"cmcontinue\"] = cm.attribute(\"cmcontinue\").value\n    end\n  end\n\nend\n", "target": "import java.util.ArrayList;\nimport ScreenScrape;\n\npublic class CountProgramExamples {\n    private static final String baseURL = \"http:\n    private static final String rootURL = \"http:\n        + \"api.php?action=query&list=categorymembers\"\n        + \"&cmtitle=Category:Programming_Tasks&cmlimit=500&format=xml\";\n    private static final String taskBegin = \"title=\\\"\";\n    private static final String taskEnd = \"\\\"\";\n    private static final String exmplBegin = \"<span class=\\\"tocnumber\\\">\";\n    private static final String exmplEnd = \"</span>\";\n    private static final String editBegin = \"<span class=\\\"editsection\\\">\";\n\n    \n    public static void main(String[] args) {\n        int exTotal = 0;\n        try {\n            \n            ArrayList<String> tasks = new ArrayList<String>();\n            ScreenScrape ss = new ScreenScrape();\n            String rootPage = ss.read(rootURL);\n            while (rootPage.contains(taskBegin)) {\n                rootPage = rootPage.substring(rootPage.indexOf(taskBegin)\n                    + taskBegin.length());\n                String title = rootPage.substring(0, rootPage.indexOf(taskEnd));\n                if (!title.contains(\"Category:\")) {\n                    tasks.add(title);\n                }\n                rootPage = rootPage.substring(rootPage.indexOf(taskEnd));\n            }\n            \n            for (String task : tasks) {\n                String title = task.replaceAll(\"&#039;\", \"'\");\n                String taskPage = ss.read(baseURL + title.replaceAll(\" \", \"_\"));\n                int exSubTot;\n                if (taskPage.contains(exmplBegin)) {\n                    int startPos = taskPage.lastIndexOf(exmplBegin)\n                        + exmplBegin.length();\n                    String countStr = taskPage.substring(startPos,\n                        taskPage.indexOf(exmplEnd, startPos));\n                    exSubTot = Integer\n                        .parseInt(countStr.contains(\".\") ? countStr\n                            .substring(0, countStr.indexOf(\".\"))\n                            : countStr);\n                } else {\n                    exSubTot = 0;\n                    while (taskPage.contains(editBegin)) {\n                        taskPage = taskPage.substring(taskPage\n                            .indexOf(editBegin) + editBegin.length());\n                        exSubTot++;\n                    }\n                }\n                exTotal += exSubTot;\n                System.out.println(title + \": \" + exSubTot + \" examples.\");\n            }\n            \n            System.out.println(\"\\nTotal: \" + exTotal + \" examples.\");\n        } catch (Exception e) {\n            System.out.println(title);\n            System.out.println(startPos + \":\"\n                + taskPage.indexOf(exmplEnd, startPos));\n            System.out.println(taskPage);\n            e.printStackTrace(System.out);\n        }\n    }\n}\n"}
{"id": 40862, "name": "Rosetta Code_Count examples", "source": "Translate Ruby to Python: require 'open-uri'\nrequire 'rexml/document'\n\nmodule RosettaCode\n\n  URL_ROOT = \"http://rosettacode.org/mw\"\n\n  def self.get_url(page, query)\n    begin\n      \n      pstr = URI.encode_www_form_component(page)\n      qstr = URI.encode_www_form(query)\n    rescue NoMethodError\n      require 'cgi'\n      pstr = CGI.escape(page)\n      qstr = query.map {|k,v|\n        \"%s=%s\" % [CGI.escape(k.to_s), CGI.escape(v.to_s)]}.join(\"&\")\n    end\n    url = \"\n    p url if $DEBUG\n    url\n  end\n\n  def self.get_api_url(query)\n    get_url \"api.php\", query\n  end\n\n  def self.category_members(category)\n    query = {\n      \"action\" => \"query\",\n      \"list\" => \"categorymembers\",\n      \"cmtitle\" => \"Category:\n      \"format\" => \"xml\",\n      \"cmlimit\" => 500,\n    }\n    while true\n      url = get_api_url query\n      doc = REXML::Document.new open(url)\n\n      REXML::XPath.each(doc, \"//cm\") do |task|\n        yield task.attribute(\"title\").value\n      end\n\n      continue = REXML::XPath.first(doc, \"//query-continue\")\n      break if continue.nil?\n      cm = REXML::XPath.first(continue, \"categorymembers\")\n      query[\"cmcontinue\"] = cm.attribute(\"cmcontinue\").value\n    end\n  end\n\nend\n", "target": "from urllib.request import urlopen, Request\nimport xml.dom.minidom\n\nr = Request(\n 'https://www.rosettacode.org/mw/api.php?action=query&list=categorymembers&cmtitle=Category:Programming_Tasks&cmlimit=500&format=xml',\n headers={'User-Agent': 'Mozilla/5.0'})\nx = urlopen(r)\n\ntasks = []\nfor i in xml.dom.minidom.parseString(x.read()).getElementsByTagName('cm'):\n    t = i.getAttribute('title').replace(' ', '_')\n    r = Request(f'https://www.rosettacode.org/mw/index.php?title={t}&action=raw',\n         headers={'User-Agent': 'Mozilla/5.0'})\n    y = urlopen(r)\n    tasks.append( y.read().lower().count(b'{{header|') )\n    print(t.replace('_', ' ') + f': {tasks[-1]} examples.')\n\nprint(f'\\nTotal: {sum(tasks)} examples.')\n"}
{"id": 41040, "name": "Associative array_Creation", "source": "Translate Ruby to C#: hash1 = {\"foo\" => \"bar\"}\n\n\n\nhash2 : Hash(String, String|Int32) = {\"foo\" => \"bar\"} of String => String|Int32\n", "target": "System.Collections.HashTable map = new System.Collections.HashTable();\nmap[\"key1\"] = \"foo\";\n"}
{"id": 41042, "name": "Associative array_Creation", "source": "Translate Ruby to Java: hash1 = {\"foo\" => \"bar\"}\n\n\n\nhash2 : Hash(String, String|Int32) = {\"foo\" => \"bar\"} of String => String|Int32\n", "target": "Map<String, Int> map = new HashMap();\nmap[\"foo\"] = 5;      \nmap[\"bar\"] = 10;\nmap[\"baz\"] = 15;\nmap[\"foo\"] = 6;      \n"}
{"id": 41043, "name": "Associative array_Creation", "source": "Translate Ruby to Python: hash1 = {\"foo\" => \"bar\"}\n\n\n\nhash2 : Hash(String, String|Int32) = {\"foo\" => \"bar\"} of String => String|Int32\n", "target": "hash = dict()  \nhash = dict(red=\"FF0000\", green=\"00FF00\", blue=\"0000FF\")\nhash = { 'key1':1, 'key2':2, }\nvalue = hash[key]\n"}
{"id": 41317, "name": "Read a file line by line", "source": "Translate Ruby to C#: IO.foreach \"foobar.txt\" do |line|\n  \n  puts line\nend\n", "target": "foreach (string readLine in File.ReadLines(\"FileName\"))\n  DoSomething(readLine);\n"}
{"id": 41319, "name": "Read a file line by line", "source": "Translate Ruby to Java: IO.foreach \"foobar.txt\" do |line|\n  \n  puts line\nend\n", "target": "import java.io.BufferedReader;\nimport java.io.FileReader;\n\n\npublic class ReadFileByLines {\n    private static void processLine(int lineNo, String line) {\n        \n    }\n\n    public static void main(String[] args) {\n        for (String filename : args) {\n            BufferedReader br = null;\n            FileReader fr = null;\n            try {\n                fr = new FileReader(filename);\n                br = new BufferedReader(fr);\n                String line;\n                int lineNo = 0;\n                while ((line = br.readLine()) != null) {\n                    processLine(++lineNo, line);\n                }\n            }\n            catch (Exception x) {\n                x.printStackTrace();\n            }\n            finally {\n                if (fr != null) {\n                    try {br.close();} catch (Exception ignoreMe) {}\n                    try {fr.close();} catch (Exception ignoreMe) {}\n                }\n            }\n        }\n    }\n}\n"}
{"id": 41555, "name": "Write entire file", "source": "Translate Ruby to C#: open(fname, 'w'){|f| f.write(str) }\n", "target": "System.IO.File.WriteAllText(\"filename.txt\", \"This file contains a string.\");\n"}
{"id": 41557, "name": "Write entire file", "source": "Translate Ruby to Java: open(fname, 'w'){|f| f.write(str) }\n", "target": "import java.io.*;\n\npublic class Test {\n\n    public static void main(String[] args) throws IOException {\n        try (BufferedWriter bw = new BufferedWriter(new FileWriter(\"test.txt\"))) {\n            bw.write(\"abc\");\n        }\n    }\n}\n"}
{"id": 41558, "name": "Write entire file", "source": "Translate Ruby to Python: open(fname, 'w'){|f| f.write(str) }\n", "target": "with open(filename, 'w') as f:\n    f.write(data)\n"}
{"id": 41907, "name": "4-rings or 4-squares puzzle", "source": "Translate Ruby to C#: def check(list)\n  a, b, c, d, e, f, g = list\n  first = a + b\n  {b + c + d, d + e + f, f + g}.all? &.==(first)\nend\n\ndef four_squares(low, high, unique = true, show = unique)\n  solutions = [] of Array(Int32)\n  if unique\n    uniq = \"unique\"\n    (low..high).to_a.each_permutation(7, true) { |ary| solutions << ary.clone if check(ary) }\n  else\n    uniq = \"non-unique\"\n    (low..high).to_a.each_repeated_permutation(7, true) { |ary| solutions << ary.clone if check(ary) }\n  end\n  if show\n    puts \" \" + (\"a\"..\"g\").join(\"  \")\n    solutions.each { |ary| p ary }\n  end\n  puts \"\n  puts\nend\n\n{ {1, 7}, {3, 9} }.each do |(low, high)|\n  four_squares(low, high)\nend\nfour_squares(0, 9, false)\n", "target": "using System;\nusing System.Linq;\n\nnamespace Four_Squares_Puzzle {\n    class Program {\n        static void Main(string[] args) {\n            fourSquare(1, 7, true, true);\n            fourSquare(3, 9, true, true);\n            fourSquare(0, 9, false, false);\n        }\n\n        private static void fourSquare(int low, int high, bool unique, bool print) {\n            int count = 0;\n\n            if (print) {\n                Console.WriteLine(\"a b c d e f g\");\n            }\n            for (int a = low; a <= high; ++a) {\n                for (int b = low; b <= high; ++b) {\n                    if (notValid(unique, b, a)) continue;\n\n                    int fp = a + b;\n                    for (int c = low; c <= high; ++c) {\n                        if (notValid(unique, c, b, a)) continue;\n                        for (int d = low; d <= high; ++d) {\n                            if (notValid(unique, d, c, b, a)) continue;\n                            if (fp != b + c + d) continue;\n\n                            for (int e = low; e <= high; ++e) {\n                                if (notValid(unique, e, d, c, b, a)) continue;\n                                for (int f = low; f <= high; ++f) {\n                                    if (notValid(unique, f, e, d, c, b, a)) continue;\n                                    if (fp != d + e + f) continue;\n\n                                    for (int g = low; g <= high; ++g) {\n                                        if (notValid(unique, g, f, e, d, c, b, a)) continue;\n                                        if (fp != f + g) continue;\n\n                                        ++count;\n                                        if (print) {\n                                            Console.WriteLine(\"{0} {1} {2} {3} {4} {5} {6}\", a, b, c, d, e, f, g);\n                                        }\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n            if (unique) {\n                Console.WriteLine(\"There are {0} unique solutions in [{1}, {2}]\", count, low, high);\n            }\n            else {\n                Console.WriteLine(\"There are {0} non-unique solutions in [{1}, {2}]\", count, low, high);\n            }\n        }\n\n        private static bool notValid(bool unique, int needle, params int[] haystack) {\n            return unique && haystack.Any(p => p == needle);\n        }\n    }\n}\n"}
{"id": 41908, "name": "4-rings or 4-squares puzzle", "source": "Translate Ruby to C#: def check(list)\n  a, b, c, d, e, f, g = list\n  first = a + b\n  {b + c + d, d + e + f, f + g}.all? &.==(first)\nend\n\ndef four_squares(low, high, unique = true, show = unique)\n  solutions = [] of Array(Int32)\n  if unique\n    uniq = \"unique\"\n    (low..high).to_a.each_permutation(7, true) { |ary| solutions << ary.clone if check(ary) }\n  else\n    uniq = \"non-unique\"\n    (low..high).to_a.each_repeated_permutation(7, true) { |ary| solutions << ary.clone if check(ary) }\n  end\n  if show\n    puts \" \" + (\"a\"..\"g\").join(\"  \")\n    solutions.each { |ary| p ary }\n  end\n  puts \"\n  puts\nend\n\n{ {1, 7}, {3, 9} }.each do |(low, high)|\n  four_squares(low, high)\nend\nfour_squares(0, 9, false)\n", "target": "using System;\nusing System.Linq;\n\nnamespace Four_Squares_Puzzle {\n    class Program {\n        static void Main(string[] args) {\n            fourSquare(1, 7, true, true);\n            fourSquare(3, 9, true, true);\n            fourSquare(0, 9, false, false);\n        }\n\n        private static void fourSquare(int low, int high, bool unique, bool print) {\n            int count = 0;\n\n            if (print) {\n                Console.WriteLine(\"a b c d e f g\");\n            }\n            for (int a = low; a <= high; ++a) {\n                for (int b = low; b <= high; ++b) {\n                    if (notValid(unique, b, a)) continue;\n\n                    int fp = a + b;\n                    for (int c = low; c <= high; ++c) {\n                        if (notValid(unique, c, b, a)) continue;\n                        for (int d = low; d <= high; ++d) {\n                            if (notValid(unique, d, c, b, a)) continue;\n                            if (fp != b + c + d) continue;\n\n                            for (int e = low; e <= high; ++e) {\n                                if (notValid(unique, e, d, c, b, a)) continue;\n                                for (int f = low; f <= high; ++f) {\n                                    if (notValid(unique, f, e, d, c, b, a)) continue;\n                                    if (fp != d + e + f) continue;\n\n                                    for (int g = low; g <= high; ++g) {\n                                        if (notValid(unique, g, f, e, d, c, b, a)) continue;\n                                        if (fp != f + g) continue;\n\n                                        ++count;\n                                        if (print) {\n                                            Console.WriteLine(\"{0} {1} {2} {3} {4} {5} {6}\", a, b, c, d, e, f, g);\n                                        }\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n            if (unique) {\n                Console.WriteLine(\"There are {0} unique solutions in [{1}, {2}]\", count, low, high);\n            }\n            else {\n                Console.WriteLine(\"There are {0} non-unique solutions in [{1}, {2}]\", count, low, high);\n            }\n        }\n\n        private static bool notValid(bool unique, int needle, params int[] haystack) {\n            return unique && haystack.Any(p => p == needle);\n        }\n    }\n}\n"}
{"id": 41911, "name": "4-rings or 4-squares puzzle", "source": "Translate Ruby to Java: def check(list)\n  a, b, c, d, e, f, g = list\n  first = a + b\n  {b + c + d, d + e + f, f + g}.all? &.==(first)\nend\n\ndef four_squares(low, high, unique = true, show = unique)\n  solutions = [] of Array(Int32)\n  if unique\n    uniq = \"unique\"\n    (low..high).to_a.each_permutation(7, true) { |ary| solutions << ary.clone if check(ary) }\n  else\n    uniq = \"non-unique\"\n    (low..high).to_a.each_repeated_permutation(7, true) { |ary| solutions << ary.clone if check(ary) }\n  end\n  if show\n    puts \" \" + (\"a\"..\"g\").join(\"  \")\n    solutions.each { |ary| p ary }\n  end\n  puts \"\n  puts\nend\n\n{ {1, 7}, {3, 9} }.each do |(low, high)|\n  four_squares(low, high)\nend\nfour_squares(0, 9, false)\n", "target": "import java.util.Arrays;\n\npublic class FourSquares {\n    public static void main(String[] args) {\n        fourSquare(1, 7, true, true);\n        fourSquare(3, 9, true, true);\n        fourSquare(0, 9, false, false);\n    }\n\n    private static void fourSquare(int low, int high, boolean unique, boolean print) {\n        int count = 0;\n\n        if (print) {\n            System.out.println(\"a b c d e f g\");\n        }\n        for (int a = low; a <= high; ++a) {\n            for (int b = low; b <= high; ++b) {\n                if (notValid(unique, a, b)) continue;\n\n                int fp = a + b;\n                for (int c = low; c <= high; ++c) {\n                    if (notValid(unique, c, a, b)) continue;\n                    for (int d = low; d <= high; ++d) {\n                        if (notValid(unique, d, a, b, c)) continue;\n                        if (fp != b + c + d) continue;\n\n                        for (int e = low; e <= high; ++e) {\n                            if (notValid(unique, e, a, b, c, d)) continue;\n                            for (int f = low; f <= high; ++f) {\n                                if (notValid(unique, f, a, b, c, d, e)) continue;\n                                if (fp != d + e + f) continue;\n\n                                for (int g = low; g <= high; ++g) {\n                                    if (notValid(unique, g, a, b, c, d, e, f)) continue;\n                                    if (fp != f + g) continue;\n\n                                    ++count;\n                                    if (print) {\n                                        System.out.printf(\"%d %d %d %d %d %d %d%n\", a, b, c, d, e, f, g);\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        if (unique) {\n            System.out.printf(\"There are %d unique solutions in [%d, %d]%n\", count, low, high);\n        } else {\n            System.out.printf(\"There are %d non-unique solutions in [%d, %d]%n\", count, low, high);\n        }\n    }\n\n    private static boolean notValid(boolean unique, int needle, int... haystack) {\n        return unique && Arrays.stream(haystack).anyMatch(p -> p == needle);\n    }\n}\n"}
{"id": 41912, "name": "4-rings or 4-squares puzzle", "source": "Translate Ruby to Java: def check(list)\n  a, b, c, d, e, f, g = list\n  first = a + b\n  {b + c + d, d + e + f, f + g}.all? &.==(first)\nend\n\ndef four_squares(low, high, unique = true, show = unique)\n  solutions = [] of Array(Int32)\n  if unique\n    uniq = \"unique\"\n    (low..high).to_a.each_permutation(7, true) { |ary| solutions << ary.clone if check(ary) }\n  else\n    uniq = \"non-unique\"\n    (low..high).to_a.each_repeated_permutation(7, true) { |ary| solutions << ary.clone if check(ary) }\n  end\n  if show\n    puts \" \" + (\"a\"..\"g\").join(\"  \")\n    solutions.each { |ary| p ary }\n  end\n  puts \"\n  puts\nend\n\n{ {1, 7}, {3, 9} }.each do |(low, high)|\n  four_squares(low, high)\nend\nfour_squares(0, 9, false)\n", "target": "import java.util.Arrays;\n\npublic class FourSquares {\n    public static void main(String[] args) {\n        fourSquare(1, 7, true, true);\n        fourSquare(3, 9, true, true);\n        fourSquare(0, 9, false, false);\n    }\n\n    private static void fourSquare(int low, int high, boolean unique, boolean print) {\n        int count = 0;\n\n        if (print) {\n            System.out.println(\"a b c d e f g\");\n        }\n        for (int a = low; a <= high; ++a) {\n            for (int b = low; b <= high; ++b) {\n                if (notValid(unique, a, b)) continue;\n\n                int fp = a + b;\n                for (int c = low; c <= high; ++c) {\n                    if (notValid(unique, c, a, b)) continue;\n                    for (int d = low; d <= high; ++d) {\n                        if (notValid(unique, d, a, b, c)) continue;\n                        if (fp != b + c + d) continue;\n\n                        for (int e = low; e <= high; ++e) {\n                            if (notValid(unique, e, a, b, c, d)) continue;\n                            for (int f = low; f <= high; ++f) {\n                                if (notValid(unique, f, a, b, c, d, e)) continue;\n                                if (fp != d + e + f) continue;\n\n                                for (int g = low; g <= high; ++g) {\n                                    if (notValid(unique, g, a, b, c, d, e, f)) continue;\n                                    if (fp != f + g) continue;\n\n                                    ++count;\n                                    if (print) {\n                                        System.out.printf(\"%d %d %d %d %d %d %d%n\", a, b, c, d, e, f, g);\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        if (unique) {\n            System.out.printf(\"There are %d unique solutions in [%d, %d]%n\", count, low, high);\n        } else {\n            System.out.printf(\"There are %d non-unique solutions in [%d, %d]%n\", count, low, high);\n        }\n    }\n\n    private static boolean notValid(boolean unique, int needle, int... haystack) {\n        return unique && Arrays.stream(haystack).anyMatch(p -> p == needle);\n    }\n}\n"}
{"id": 41913, "name": "4-rings or 4-squares puzzle", "source": "Translate Ruby to Python: def check(list)\n  a, b, c, d, e, f, g = list\n  first = a + b\n  {b + c + d, d + e + f, f + g}.all? &.==(first)\nend\n\ndef four_squares(low, high, unique = true, show = unique)\n  solutions = [] of Array(Int32)\n  if unique\n    uniq = \"unique\"\n    (low..high).to_a.each_permutation(7, true) { |ary| solutions << ary.clone if check(ary) }\n  else\n    uniq = \"non-unique\"\n    (low..high).to_a.each_repeated_permutation(7, true) { |ary| solutions << ary.clone if check(ary) }\n  end\n  if show\n    puts \" \" + (\"a\"..\"g\").join(\"  \")\n    solutions.each { |ary| p ary }\n  end\n  puts \"\n  puts\nend\n\n{ {1, 7}, {3, 9} }.each do |(low, high)|\n  four_squares(low, high)\nend\nfour_squares(0, 9, false)\n", "target": "import itertools\n\ndef all_equal(a,b,c,d,e,f,g):\n    return a+b == b+c+d == d+e+f == f+g\n\ndef foursquares(lo,hi,unique,show):\n    solutions = 0\n    if unique:\n        uorn = \"unique\"\n        citer = itertools.combinations(range(lo,hi+1),7)\n    else:\n        uorn = \"non-unique\"\n        citer =  itertools.combinations_with_replacement(range(lo,hi+1),7)\n                    \n    for c in citer:\n            for p in set(itertools.permutations(c)):\n                if all_equal(*p):\n                    solutions += 1\n                    if show:\n                        print str(p)[1:-1]\n\n    print str(solutions)+\" \"+uorn+\" solutions in \"+str(lo)+\" to \"+str(hi)\n    print\n"}
{"id": 41914, "name": "4-rings or 4-squares puzzle", "source": "Translate Ruby to Python: def check(list)\n  a, b, c, d, e, f, g = list\n  first = a + b\n  {b + c + d, d + e + f, f + g}.all? &.==(first)\nend\n\ndef four_squares(low, high, unique = true, show = unique)\n  solutions = [] of Array(Int32)\n  if unique\n    uniq = \"unique\"\n    (low..high).to_a.each_permutation(7, true) { |ary| solutions << ary.clone if check(ary) }\n  else\n    uniq = \"non-unique\"\n    (low..high).to_a.each_repeated_permutation(7, true) { |ary| solutions << ary.clone if check(ary) }\n  end\n  if show\n    puts \" \" + (\"a\"..\"g\").join(\"  \")\n    solutions.each { |ary| p ary }\n  end\n  puts \"\n  puts\nend\n\n{ {1, 7}, {3, 9} }.each do |(low, high)|\n  four_squares(low, high)\nend\nfour_squares(0, 9, false)\n", "target": "import itertools\n\ndef all_equal(a,b,c,d,e,f,g):\n    return a+b == b+c+d == d+e+f == f+g\n\ndef foursquares(lo,hi,unique,show):\n    solutions = 0\n    if unique:\n        uorn = \"unique\"\n        citer = itertools.combinations(range(lo,hi+1),7)\n    else:\n        uorn = \"non-unique\"\n        citer =  itertools.combinations_with_replacement(range(lo,hi+1),7)\n                    \n    for c in citer:\n            for p in set(itertools.permutations(c)):\n                if all_equal(*p):\n                    solutions += 1\n                    if show:\n                        print str(p)[1:-1]\n\n    print str(solutions)+\" \"+uorn+\" solutions in \"+str(lo)+\" to \"+str(hi)\n    print\n"}
{"id": 42163, "name": "Mutual recursion", "source": "Translate Ruby to C#: def F(n)\n  n == 0 ? 1 : n - M(F(n-1))\nend\ndef M(n)\n  n == 0 ? 0 : n - F(M(n-1))\nend\n\np (Array.new(20) {|n| F(n) })\np (Array.new(20) {|n| M(n) })\n", "target": "namespace RosettaCode {\n    class Hofstadter {\n        static public int F(int n) {\n            int result = 1;\n            if (n > 0) {\n                result = n - M(F(n-1));\n            }\n\n            return result;\n        }\n\n        static public int M(int n) {\n            int result = 0;\n            if (n > 0) {\n                result = n - F(M(n - 1));\n            }\n\n            return result;\n        }\n    }\n}\n"}
{"id": 42165, "name": "Mutual recursion", "source": "Translate Ruby to Java: def F(n)\n  n == 0 ? 1 : n - M(F(n-1))\nend\ndef M(n)\n  n == 0 ? 0 : n - F(M(n-1))\nend\n\np (Array.new(20) {|n| F(n) })\np (Array.new(20) {|n| M(n) })\n", "target": "import java.util.HashMap;\nimport java.util.Map;\n\npublic class MutualRecursion {\n\n    public static void main(final String args[]) {\n        int max = 20;\n        System.out.printf(\"First %d values of the Female sequence:  %n\", max);\n        for (int i = 0; i < max; i++) {\n            System.out.printf(\"  f(%d) = %d%n\", i, f(i));\n        }\n        System.out.printf(\"First %d values of the Male sequence:  %n\", max);\n        for (int i = 0; i < 20; i++) {\n            System.out.printf(\"  m(%d) = %d%n\", i, m(i));\n        }\n    }\n\n    private static Map<Integer,Integer> F_MAP = new HashMap<>();\n\n    private static int f(final int n) {\n        if ( F_MAP.containsKey(n) ) {\n            return F_MAP.get(n);\n        }\n        int fn = n == 0 ? 1 : n - m(f(n - 1));\n        F_MAP.put(n, fn);\n        return fn;\n    }\n\n    private static Map<Integer,Integer> M_MAP = new HashMap<>();\n\n    private static int m(final int n) {\n        if ( M_MAP.containsKey(n) ) {\n            return M_MAP.get(n);\n        }\n        int mn = n == 0 ? 0 : n - f(m(n - 1));\n        M_MAP.put(n, mn);\n        return mn;\n    }\n     \n\n}\n"}
{"id": 42166, "name": "Mutual recursion", "source": "Translate Ruby to Python: def F(n)\n  n == 0 ? 1 : n - M(F(n-1))\nend\ndef M(n)\n  n == 0 ? 0 : n - F(M(n-1))\nend\n\np (Array.new(20) {|n| F(n) })\np (Array.new(20) {|n| M(n) })\n", "target": "def F(n): return 1 if n == 0 else n - M(F(n-1))\ndef M(n): return 0 if n == 0 else n - F(M(n-1))\n\nprint ([ F(n) for n in range(20) ])\nprint ([ M(n) for n in range(20) ])\n"}
{"id": 42566, "name": "Narcissistic decimal number", "source": "Translate Ruby to C#: class Integer\n  def narcissistic?\n    return false if negative?\n    digs = self.digits    \n    m    = digs.size\n    digs.map{|d| d**m}.sum == self\n  end\nend\n\nputs 0.step.lazy.select(&:narcissistic?).first(25)\n", "target": "using System;\n\nnamespace Narcissistic\n{\n    class Narcissistic\n    {\n        public bool isNarcissistic(int z)\n        {\n            if (z < 0) return false;\n            string n = z.ToString();\n            int t = 0, l = n.Length;\n            foreach (char c in n)\n                t += Convert.ToInt32(Math.Pow(Convert.ToDouble(c - 48), l));\n\n            return t == z;\n        }\n    }\n\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            Narcissistic n = new Narcissistic();\n            int c = 0, x = 0;\n            while (c < 25)\n            {\n                if (n.isNarcissistic(x))\n                {\n                    if (c % 5 == 0) Console.WriteLine();\n                    Console.Write(\"{0,7} \", x);\n                    c++;\n                }\n                x++;\n            }\n            Console.WriteLine(\"\\n\\nPress any key to continue...\");\n            Console.ReadKey();\n        }\n    }\n}\n"}
{"id": 42567, "name": "Narcissistic decimal number", "source": "Translate Ruby to C#: class Integer\n  def narcissistic?\n    return false if negative?\n    digs = self.digits    \n    m    = digs.size\n    digs.map{|d| d**m}.sum == self\n  end\nend\n\nputs 0.step.lazy.select(&:narcissistic?).first(25)\n", "target": "using System;\n\nnamespace Narcissistic\n{\n    class Narcissistic\n    {\n        public bool isNarcissistic(int z)\n        {\n            if (z < 0) return false;\n            string n = z.ToString();\n            int t = 0, l = n.Length;\n            foreach (char c in n)\n                t += Convert.ToInt32(Math.Pow(Convert.ToDouble(c - 48), l));\n\n            return t == z;\n        }\n    }\n\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            Narcissistic n = new Narcissistic();\n            int c = 0, x = 0;\n            while (c < 25)\n            {\n                if (n.isNarcissistic(x))\n                {\n                    if (c % 5 == 0) Console.WriteLine();\n                    Console.Write(\"{0,7} \", x);\n                    c++;\n                }\n                x++;\n            }\n            Console.WriteLine(\"\\n\\nPress any key to continue...\");\n            Console.ReadKey();\n        }\n    }\n}\n"}
{"id": 42570, "name": "Narcissistic decimal number", "source": "Translate Ruby to Java: class Integer\n  def narcissistic?\n    return false if negative?\n    digs = self.digits    \n    m    = digs.size\n    digs.map{|d| d**m}.sum == self\n  end\nend\n\nputs 0.step.lazy.select(&:narcissistic?).first(25)\n", "target": "public class Narc{\n\tpublic static boolean isNarc(long x){\n\t\tif(x < 0) return false;\n\t\t\n\t\tString xStr = Long.toString(x);\n\t\tint m = xStr.length();\n\t\tlong sum = 0;\n\t\t\n\t\tfor(char c : xStr.toCharArray()){\n\t\t\tsum += Math.pow(Character.digit(c, 10), m);\n\t\t}\n\t\treturn sum == x;\n\t}\n\n\tpublic static void main(String[] args){\n\t\tfor(long x = 0, count = 0; count < 25; x++){\n\t\t\tif(isNarc(x)){\n\t\t\t\tSystem.out.print(x + \" \");\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t}\n}\n"}
{"id": 42571, "name": "Narcissistic decimal number", "source": "Translate Ruby to Java: class Integer\n  def narcissistic?\n    return false if negative?\n    digs = self.digits    \n    m    = digs.size\n    digs.map{|d| d**m}.sum == self\n  end\nend\n\nputs 0.step.lazy.select(&:narcissistic?).first(25)\n", "target": "public class Narc{\n\tpublic static boolean isNarc(long x){\n\t\tif(x < 0) return false;\n\t\t\n\t\tString xStr = Long.toString(x);\n\t\tint m = xStr.length();\n\t\tlong sum = 0;\n\t\t\n\t\tfor(char c : xStr.toCharArray()){\n\t\t\tsum += Math.pow(Character.digit(c, 10), m);\n\t\t}\n\t\treturn sum == x;\n\t}\n\n\tpublic static void main(String[] args){\n\t\tfor(long x = 0, count = 0; count < 25; x++){\n\t\t\tif(isNarc(x)){\n\t\t\t\tSystem.out.print(x + \" \");\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t}\n}\n"}
{"id": 42572, "name": "Narcissistic decimal number", "source": "Translate Ruby to Python: class Integer\n  def narcissistic?\n    return false if negative?\n    digs = self.digits    \n    m    = digs.size\n    digs.map{|d| d**m}.sum == self\n  end\nend\n\nputs 0.step.lazy.select(&:narcissistic?).first(25)\n", "target": "from __future__ import print_function\nfrom itertools import count, islice\n\ndef narcissists():\n    for digits in count(0):\n        digitpowers = [i**digits for i in range(10)]\n        for n in range(int(10**(digits-1)), 10**digits):\n            div, digitpsum = n, 0\n            while div:\n                div, mod = divmod(div, 10)\n                digitpsum += digitpowers[mod]\n            if n == digitpsum:\n                yield n\n\nfor i, n in enumerate(islice(narcissists(), 25), 1):\n    print(n, end=' ')\n    if i % 5 == 0: print() \nprint()\n"}
{"id": 42573, "name": "Narcissistic decimal number", "source": "Translate Ruby to Python: class Integer\n  def narcissistic?\n    return false if negative?\n    digs = self.digits    \n    m    = digs.size\n    digs.map{|d| d**m}.sum == self\n  end\nend\n\nputs 0.step.lazy.select(&:narcissistic?).first(25)\n", "target": "from __future__ import print_function\nfrom itertools import count, islice\n\ndef narcissists():\n    for digits in count(0):\n        digitpowers = [i**digits for i in range(10)]\n        for n in range(int(10**(digits-1)), 10**digits):\n            div, digitpsum = n, 0\n            while div:\n                div, mod = divmod(div, 10)\n                digitpsum += digitpowers[mod]\n            if n == digitpsum:\n                yield n\n\nfor i, n in enumerate(islice(narcissists(), 25), 1):\n    print(n, end=' ')\n    if i % 5 == 0: print() \nprint()\n"}
{"id": 42836, "name": "Strip whitespace from a string_Top and tail", "source": "Translate Ruby to C#: def strip_whitepace(s)\n    puts s.lstrip()\n    puts s.rstrip()\n    puts s.strip()\nend\n\nstrip_whitepace(\"\\t hello \\t\")\n\n\n\n", "target": "using System;\n\npublic class TrimExample\n{\n    public static void Main(String[] args)\n    {\n        const string toTrim = \" Trim me \";\n        Console.WriteLine(Wrap(toTrim.TrimStart()));\n        Console.WriteLine(Wrap(toTrim.TrimEnd()));\n        Console.WriteLine(Wrap(toTrim.Trim()));\n    }\n\n    private static string Wrap(string s)\n    {\n        return \"'\" + s + \"'\";\n    }\n}\n"}
{"id": 42838, "name": "Strip whitespace from a string_Top and tail", "source": "Translate Ruby to Java: def strip_whitepace(s)\n    puts s.lstrip()\n    puts s.rstrip()\n    puts s.strip()\nend\n\nstrip_whitepace(\"\\t hello \\t\")\n\n\n\n", "target": "public class Trims{\n    public static String ltrim(String s) {\n        int i = 0;\n        while (i < s.length() && Character.isWhitespace(s.charAt(i))) {\n            i++;\n        }\n        return s.substring(i);\n    }\n\n    public static String rtrim(String s) {\n        int i = s.length() - 1;\n        while (i > 0 && Character.isWhitespace(s.charAt(i))) {\n            i--;\n        }\n        return s.substring(0, i + 1);\n    }\n\n    public static String trim(String s) {\n    \treturn rtrim(ltrim(s));\n    }\n\n    public static void main(String[] args) {\n        String s = \" \\t \\r \\n String with spaces \\u2009 \\t  \\r  \\n  \";\n        System.out.printf(\"[%s]\\n\", ltrim(s));\n        System.out.printf(\"[%s]\\n\", rtrim(s));\n        System.out.printf(\"[%s]\\n\", trim(s));\n    }\n}\n"}
{"id": 42839, "name": "Strip whitespace from a string_Top and tail", "source": "Translate Ruby to Python: def strip_whitepace(s)\n    puts s.lstrip()\n    puts s.rstrip()\n    puts s.strip()\nend\n\nstrip_whitepace(\"\\t hello \\t\")\n\n\n\n", "target": ">>> s = ' \\t \\r \\n String with spaces  \\t  \\r  \\n  '\n>>> s\n' \\t \\r \\n String with spaces  \\t  \\r  \\n  '\n>>> s.lstrip()\n'String with spaces  \\t  \\r  \\n  '\n>>> s.rstrip()\n' \\t \\r \\n String with spaces'\n>>> s.strip()\n'String with spaces'\n>>>\n"}
{"id": 43092, "name": "Strip comments from a string", "source": "Translate Ruby to C#: class String\n  def strip_comment( markers = ['\n    re = Regexp.union( markers ) \n    if index = (self =~ re)\n      self[0, index].rstrip      \n    else\n      rstrip\n    end\n  end\nend\n\np 'apples, pears \nstr = 'apples, pears\u00a0; and bananas'\np str.strip_comment\nstr = 'apples, pears and bananas '\np str.strip_comment\np str.strip_comment('and')\np \" \\t \\n\u00a0;\".strip_comment\np \"\".strip_comment\n", "target": "using System.Text.RegularExpressions;\n\nstring RemoveComments(string str, string delimiter)\n        {\n            \n            \n            \n            return Regex.Replace(str, delimiter + \".+\", string.Empty).Trim();\n        }\n"}
{"id": 43094, "name": "Strip comments from a string", "source": "Translate Ruby to Java: class String\n  def strip_comment( markers = ['\n    re = Regexp.union( markers ) \n    if index = (self =~ re)\n      self[0, index].rstrip      \n    else\n      rstrip\n    end\n  end\nend\n\np 'apples, pears \nstr = 'apples, pears\u00a0; and bananas'\np str.strip_comment\nstr = 'apples, pears and bananas '\np str.strip_comment\np str.strip_comment('and')\np \" \\t \\n\u00a0;\".strip_comment\np \"\".strip_comment\n", "target": "import java.io.*;\n\npublic class StripLineComments{\n    public static void main( String[] args ){\n\tif( args.length < 1 ){\n\t    System.out.println(\"Usage: java StripLineComments StringToProcess\");\n\t}\n\telse{\n\t    String inputFile = args[0];\n\t    String input = \"\";\n\t    try{\n\t\tBufferedReader reader = new BufferedReader( new FileReader( inputFile ) );\n\t\tString line = \"\";\n\t\twhile((line = reader.readLine()) != null){\n\t\t    System.out.println( line.split(\"[#;]\")[0] );\n\t\t}\n\t    }\n\t    catch( Exception e ){\n\t\te.printStackTrace();\n\t    }\n\t}\n    }\n}\n"}
{"id": 43095, "name": "Strip comments from a string", "source": "Translate Ruby to Python: class String\n  def strip_comment( markers = ['\n    re = Regexp.union( markers ) \n    if index = (self =~ re)\n      self[0, index].rstrip      \n    else\n      rstrip\n    end\n  end\nend\n\np 'apples, pears \nstr = 'apples, pears\u00a0; and bananas'\np str.strip_comment\nstr = 'apples, pears and bananas '\np str.strip_comment\np str.strip_comment('and')\np \" \\t \\n\u00a0;\".strip_comment\np \"\".strip_comment\n", "target": "def remove_comments(line, sep):\n    for s in sep:\n        i = line.find(s)\n        if i >= 0:\n            line = line[:i]\n    return line.strip()\n\n\nprint remove_comments('apples\u00a0; pears \nprint remove_comments('apples\u00a0; pears \n"}
{"id": 43269, "name": "First-class functions", "source": "Translate Ruby to C#: cube = proc{|x| x ** 3}\ncroot = proc{|x| x ** (1.quo 3)}\ncompose = proc {|f,g| proc {|x| f[g[x]]}}\nfunclist = [Math.method(:sin), Math.method(:cos), cube]\ninvlist = [Math.method(:asin), Math.method(:acos), croot]\n\nputs funclist.zip(invlist).map {|f, invf| compose[invf, f][0.5]}\n", "target": "using System;\n\nclass Program\n{\n    static void Main(string[] args)\n    {\n        var cube = new Func<double, double>(x => Math.Pow(x, 3.0));\n        var croot = new Func<double, double>(x => Math.Pow(x, 1 / 3.0));\n\n        var functionTuples = new[]\n        {\n            (forward: Math.Sin, backward: Math.Asin),\n            (forward: Math.Cos, backward: Math.Acos),\n            (forward: cube,     backward: croot)\n        };\n\n        foreach (var ft in functionTuples)\n        {\n            Console.WriteLine(ft.backward(ft.forward(0.5)));\n        }\n    }\n}\n"}
{"id": 43271, "name": "First-class functions", "source": "Translate Ruby to Java: cube = proc{|x| x ** 3}\ncroot = proc{|x| x ** (1.quo 3)}\ncompose = proc {|f,g| proc {|x| f[g[x]]}}\nfunclist = [Math.method(:sin), Math.method(:cos), cube]\ninvlist = [Math.method(:asin), Math.method(:acos), croot]\n\nputs funclist.zip(invlist).map {|f, invf| compose[invf, f][0.5]}\n", "target": "import java.util.ArrayList;\n\npublic class FirstClass{\n\t\n\tpublic interface Function<A,B>{\n\t\tB apply(A x);\n\t}\n\t\n\tpublic static <A,B,C> Function<A, C> compose(\n\t\t\tfinal Function<B, C> f, final Function<A, B> g) {\n\t\treturn new Function<A, C>() {\n\t\t\t@Override public C apply(A x) {\n\t\t\t\treturn f.apply(g.apply(x));\n\t\t\t}\n\t\t};\n\t}\n\t \n\tpublic static void main(String[] args){\n\t\tArrayList<Function<Double, Double>> functions =\n\t\t\tnew ArrayList<Function<Double,Double>>();\n\t\t\n\t\tfunctions.add(\n\t\t\t\tnew Function<Double, Double>(){\n\t\t\t\t\t@Override public Double apply(Double x){\n\t\t\t\t\t\treturn Math.cos(x);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\tfunctions.add(\n\t\t\t\tnew Function<Double, Double>(){\n\t\t\t\t\t@Override public Double apply(Double x){\n\t\t\t\t\t\treturn Math.tan(x);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\tfunctions.add(\n\t\t\t\tnew Function<Double, Double>(){\n\t\t\t\t\t@Override public Double apply(Double x){\n\t\t\t\t\t\treturn x * x;\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\n\t\tArrayList<Function<Double, Double>> inverse = new ArrayList<Function<Double,Double>>();\n\t\t\n\t\tinverse.add(\n\t\t\t\tnew Function<Double, Double>(){\n\t\t\t\t\t@Override public Double apply(Double x){\n\t\t\t\t\t\treturn Math.acos(x);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\tinverse.add(\n\t\t\t\tnew Function<Double, Double>(){\n\t\t\t\t\t@Override public Double apply(Double x){\n\t\t\t\t\t\treturn Math.atan(x);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\tinverse.add(\n\t\t\t\tnew Function<Double, Double>(){\n\t\t\t\t\t@Override public Double apply(Double x){\n\t\t\t\t\t\treturn Math.sqrt(x);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\tSystem.out.println(\"Compositions:\");\n\t\tfor(int i = 0; i < functions.size(); i++){\n\t\t\tSystem.out.println(compose(functions.get(i), inverse.get(i)).apply(0.5));\n\t\t}\n\t\tSystem.out.println(\"Hard-coded compositions:\");\n\t\tSystem.out.println(Math.cos(Math.acos(0.5)));\n\t\tSystem.out.println(Math.tan(Math.atan(0.5)));\n\t\tSystem.out.println(Math.pow(Math.sqrt(0.5), 2));\n\t}\n}\n"}
{"id": 43272, "name": "First-class functions", "source": "Translate Ruby to Python: cube = proc{|x| x ** 3}\ncroot = proc{|x| x ** (1.quo 3)}\ncompose = proc {|f,g| proc {|x| f[g[x]]}}\nfunclist = [Math.method(:sin), Math.method(:cos), cube]\ninvlist = [Math.method(:asin), Math.method(:acos), croot]\n\nputs funclist.zip(invlist).map {|f, invf| compose[invf, f][0.5]}\n", "target": ">>> \n>>> from math import sin, cos, acos, asin\n>>> \n>>> cube = lambda x: x * x * x\n>>> croot = lambda x: x ** (1/3.0)\n>>> \n>>> \n>>> compose = lambda f1, f2: ( lambda x: f1(f2(x)) )\n>>> \n>>> funclist = [sin, cos, cube]\n>>> funclisti = [asin, acos, croot]\n>>> \n>>> [compose(inversef, f)(.5) for f, inversef in zip(funclist, funclisti)]\n[0.5, 0.4999999999999999, 0.5]\n>>>\n"}
{"id": 43592, "name": "Test a function", "source": "Translate Ruby to C#: require \"spec\"\n\ndescribe \"palindrome\" do\n  it \"returns true for a word that's palindromic\" do\n    palindrome(\"racecar\").should be_true\n  end\n\n  it \"returns false for a word that's not palindromic\" do\n    palindrome(\"goodbye\").should be_false\n  end\nend\n\ndef palindrome(s)\n  s == s.reverse\nend\n", "target": "using Microsoft.VisualStudio.TestTools.UnitTesting;\nusing PalindromeDetector.ConsoleApp;\n\nnamespace PalindromeDetector.VisualStudioTests\n{\n    [TestClass]\n    public class VSTests\n    {\n        [TestMethod]\n        public void PalindromeDetectorCanUnderstandPalindrome()\n        {\n            \n            bool expected = true;\n            bool actual;\n            actual = Program.IsPalindrome(\"1\");\n            Assert.AreEqual(expected, actual);\n            actual = Program.IsPalindromeNonRecursive(\"1\");\n            Assert.AreEqual(expected, actual);\n            actual = Program.IsPalindrome(\"ingirumimusnocteetconsumimurigni\");\n            Assert.AreEqual(expected, actual);\n            actual = Program.IsPalindromeNonRecursive(\"ingirumimusnocteetconsumimurigni\");\n            Assert.AreEqual(expected, actual);\n        }\n        [TestMethod]\n        public void PalindromeDetecotryCanUnderstandNonPalindrome()\n        {\n            bool notExpected = true;\n            bool actual = Program.IsPalindrome(\"ThisIsNotAPalindrome\");\n            Assert.AreNotEqual(notExpected, actual);\n            actual = Program.IsPalindromeNonRecursive(\"ThisIsNotAPalindrome\");\n            Assert.AreNotEqual(notExpected, actual);\n        }\n    }\n}\n"}
{"id": 43594, "name": "Test a function", "source": "Translate Ruby to Java: require \"spec\"\n\ndescribe \"palindrome\" do\n  it \"returns true for a word that's palindromic\" do\n    palindrome(\"racecar\").should be_true\n  end\n\n  it \"returns false for a word that's not palindromic\" do\n    palindrome(\"goodbye\").should be_false\n  end\nend\n\ndef palindrome(s)\n  s == s.reverse\nend\n", "target": "import static ExampleClass.pali; \nimport static ExampleClass.rPali; \nimport org.junit.*;\npublic class PalindromeTest extends junit.framework.TestCase {\n    @Before\n    public void setUp(){\n        \n        \n    }\n    @After\n    public void tearDown(){\n        \n        \n    }\n\n    \n    @Test\n    public void testNonrecursivePali() throws Exception {\n        assertTrue(pali(\"abcba\"));\n        assertTrue(pali(\"aa\"));\n        assertTrue(pali(\"a\"));\n        assertTrue(pali(\"\"));\n        assertFalse(pali(\"ab\"));\n        assertFalse(pali(\"abcdba\"));\n    }\n    \n    @Test\n    public void testRecursivePali() throws Exception {\n        assertTrue(rPali(\"abcba\"));\n        assertTrue(rPali(\"aa\"));\n        assertTrue(rPali(\"a\"));\n        assertTrue(rPali(\"\"));\n        assertFalse(rPali(\"ab\"));\n        assertFalse(rPali(\"abcdba\"));\n    }\n\n    \n    @Test(expected=WhateverException.class)\n    public void except(){\n        \n    }\n}\n"}
{"id": 43595, "name": "Test a function", "source": "Translate Ruby to Python: require \"spec\"\n\ndescribe \"palindrome\" do\n  it \"returns true for a word that's palindromic\" do\n    palindrome(\"racecar\").should be_true\n  end\n\n  it \"returns false for a word that's not palindromic\" do\n    palindrome(\"goodbye\").should be_false\n  end\nend\n\ndef palindrome(s)\n  s == s.reverse\nend\n", "target": "def is_palindrome(s):\n    \n    return s == s[::-1]\n\ndef _test():\n    import doctest\n    doctest.testmod()\n    \n\nif __name__ == \"__main__\":\n    _test()\n"}
{"id": 43737, "name": "Totient function", "source": "Translate Ruby to C#: require \"prime\"\n\ndef \ud835\udf11(n)\n  n.prime_division.inject(1) {|res, (pr, exp)| res *= (pr-1) * pr**(exp-1) } \nend\n\n1.upto 25 do |n|\n  tot = \ud835\udf11(n)\n  puts \"\nend\n\n[100, 1_000, 10_000, 100_000].each do |u|\n  puts \"Number of primes up to \nend\n", "target": "using static System.Console;\nusing static System.Linq.Enumerable;\n\npublic class Program\n{\n    static void Main()\n    {\n        for (int i = 1; i <= 25; i++) {\n            int t = Totient(i);\n            WriteLine(i + \"\\t\" + t + (t == i - 1 ? \"\\tprime\" : \"\"));\n        }\n        WriteLine();\n        for (int i = 100; i <= 100_000; i *= 10) {\n            WriteLine($\"{Range(1, i).Count(x => Totient(x) + 1 == x):n0} primes below {i:n0}\");\n        }\n    }\n\n    static int Totient(int n) {\n        if (n < 3) return 1;\n        if (n == 3) return 2;\n\n        int totient = n;\n\n        if ((n & 1) == 0) {\n            totient >>= 1;\n            while (((n >>= 1) & 1) == 0) ;\n        }\n\n        for (int i = 3; i * i <= n; i += 2) {\n            if (n % i == 0) {\n                totient -= totient / i;\n                while ((n /= i) % i == 0) ;\n            }\n        }\n        if (n > 1) totient -= totient / n;\n        return totient;\n    }\n}\n"}
{"id": 43739, "name": "Totient function", "source": "Translate Ruby to Java: require \"prime\"\n\ndef \ud835\udf11(n)\n  n.prime_division.inject(1) {|res, (pr, exp)| res *= (pr-1) * pr**(exp-1) } \nend\n\n1.upto 25 do |n|\n  tot = \ud835\udf11(n)\n  puts \"\nend\n\n[100, 1_000, 10_000, 100_000].each do |u|\n  puts \"Number of primes up to \nend\n", "target": "public class TotientFunction {\n\n    public static void main(String[] args) {\n        computePhi();\n        System.out.println(\"Compute and display phi for the first 25 integers.\");\n        System.out.printf(\"n  Phi  IsPrime%n\");\n        for ( int n = 1 ; n <= 25 ; n++ ) {\n            System.out.printf(\"%2d  %2d  %b%n\", n, phi[n], (phi[n] == n-1));\n        }\n        for ( int i = 2 ; i < 8 ; i++ ) {\n            int max = (int) Math.pow(10, i);\n            System.out.printf(\"The count of the primes up to\u00a0%,10d = %d%n\", max, countPrimes(1, max));\n        }\n    }\n    \n    private static int countPrimes(int min, int max) {\n        int count = 0;\n        for ( int i = min ; i <= max ; i++ ) {\n            if ( phi[i] == i-1 ) {\n                count++;\n            }\n        }\n        return count;\n    }\n\n    private static final int max = 10000000;\n    private static final int[] phi = new int[max+1];\n\n    private static final void computePhi() {\n        for ( int i = 1 ; i <= max ; i++ ) {\n            phi[i] = i;\n        }\n        for ( int i = 2 ; i <= max ; i++ ) {\n            if (phi[i] < i) continue;\n            for ( int j = i ; j <= max ; j += i ) {\n                phi[j] -= phi[j] / i;\n            }\n        }\n    }\n\n}\n"}
{"id": 43740, "name": "Totient function", "source": "Translate Ruby to Python: require \"prime\"\n\ndef \ud835\udf11(n)\n  n.prime_division.inject(1) {|res, (pr, exp)| res *= (pr-1) * pr**(exp-1) } \nend\n\n1.upto 25 do |n|\n  tot = \ud835\udf11(n)\n  puts \"\nend\n\n[100, 1_000, 10_000, 100_000].each do |u|\n  puts \"Number of primes up to \nend\n", "target": "from math import gcd\n\ndef  \u03c6(n):\n    return sum(1 for k in range(1, n + 1) if gcd(n, k) == 1)\n\nif __name__ == '__main__':\n    def is_prime(n):\n        return \u03c6(n) == n - 1\n    \n    for n in range(1, 26):\n        print(f\" \u03c6({n}) == {\u03c6(n)}{', is prime' if is_prime(n)  else ''}\")\n    count = 0\n    for n in range(1, 10_000 + 1):\n        count += is_prime(n)\n        if n in {100, 1000, 10_000}:\n            print(f\"Primes up to {n}: {count}\")\n"}
{"id": 43979, "name": "Determine if a string is numeric", "source": "Translate Ruby to C#: def is_numeric?(s)\n  begin\n    Float(s)\n  rescue\n    false \n  else\n    true \n  end\nend\n", "target": "public static bool IsNumeric(string s)\n{\n    double Result;\n    return double.TryParse(s, out Result);  \n}        \n\nstring value = \"123\";\nif (IsNumeric(value)) \n{\n  \n}\n"}
{"id": 43981, "name": "Determine if a string is numeric", "source": "Translate Ruby to Java: def is_numeric?(s)\n  begin\n    Float(s)\n  rescue\n    false \n  else\n    true \n  end\nend\n", "target": "public boolean isNumeric(String input) {\n  try {\n    Integer.parseInt(input);\n    return true;\n  }\n  catch (NumberFormatException e) {\n    \n    return false;\n  }\n}\n"}
{"id": 43982, "name": "Determine if a string is numeric", "source": "Translate Ruby to Python: def is_numeric?(s)\n  begin\n    Float(s)\n  rescue\n    false \n  else\n    true \n  end\nend\n", "target": "def is_numeric(s):\n    try:\n        float(s)\n        return True\n    except (ValueError, TypeError):\n        return False\n\nis_numeric('123.0')\n"}
{"id": 44230, "name": "One-dimensional cellular automata", "source": "Translate Ruby to C#: def evolve(ary)\n  ([0]+ary+[0]).each_cons(3).map{|a,b,c| a+b+c == 2 ? 1 : 0}\nend\n\ndef printit(ary)\n  puts ary.join.tr(\"01\",\".\nend\n\nary = [0,1,1,1,0,1,1,0,1,0,1,0,1,0,1,0,0,1,0,0]\nprintit ary\nuntil ary == (new = evolve(ary))\n  printit ary = new\nend\n", "target": "using System;\nusing System.Collections.Generic;\n\nnamespace prog\n{\n\tclass MainClass\n\t{\t\n\t\tconst int n_iter = 10;\n\t\tstatic int[] f = { 0, 1, 1, 1, 0, 1, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0, 1, 0, 0 };\n\t\t\n\t\tpublic static void Main (string[] args)\n\t\t{\n\t\t\tfor( int i=0; i<f.Length; i++ )\n\t\t\t\tConsole.Write( f[i]==0 ? \"-\" : \"#\" );\n\t\t\tConsole.WriteLine(\"\");\t\t\t\n\t\t\t\n\t\t\tint[] g = new int[f.Length];\n\t\t\tfor( int n=n_iter; n!=0; n-- )\n\t\t\t{\n\t\t\t\tfor( int i=1; i<f.Length-1; i++ )\n\t\t\t\t{\n\t\t\t\t\tif ( (f[i-1] ^ f[i+1]) == 1 ) g[i] = f[i];\n\t\t\t\t\telse if ( f[i] == 0 && (f[i-1] & f[i+1]) == 1 ) g[i] = 1;\n\t\t\t\t\telse g[i] = 0;\n\t\t\t\t}\n\t\t\t\tg[0] = ( (f[0] & f[1]) == 1 ) ? 1 : 0;\n\t\t\t\tg[g.Length-1] = ( (f[f.Length-1] & f[f.Length-2]) == 1 ) ? 1 : 0;\n\t\t\t\t\n\t\t\t\tint[] tmp = f;\n\t\t\t\tf = g;\n\t\t\t\tg = tmp;\n\t\t\t\t\n\t\t\t\tfor( int i=0; i<f.Length; i++ )\n\t\t\t\t\tConsole.Write( f[i]==0 ? \"-\" : \"#\" );\n\t\t\t\tConsole.WriteLine(\"\");\n\t\t\t}\t\t\t\n\t\t}\n\t}\n}\n"}
{"id": 44232, "name": "One-dimensional cellular automata", "source": "Translate Ruby to Java: def evolve(ary)\n  ([0]+ary+[0]).each_cons(3).map{|a,b,c| a+b+c == 2 ? 1 : 0}\nend\n\ndef printit(ary)\n  puts ary.join.tr(\"01\",\".\nend\n\nary = [0,1,1,1,0,1,1,0,1,0,1,0,1,0,1,0,0,1,0,0]\nprintit ary\nuntil ary == (new = evolve(ary))\n  printit ary = new\nend\n", "target": "public class Life{\n\tpublic static void main(String[] args) throws Exception{\n\t\tString start= \"_###_##_#_#_#_#__#__\";\n\t\tint numGens = 10;\n\t\tfor(int i= 0; i < numGens; i++){\n\t\t\tSystem.out.println(\"Generation \" + i + \": \" + start);\n\t\t\tstart= life(start);\n\t\t}\n\t}\n\n\tpublic static String life(String lastGen){\n\t\tString newGen= \"\";\n\t\tfor(int i= 0; i < lastGen.length(); i++){\n\t\t\tint neighbors= 0;\n\t\t\tif (i == 0){\n\t\t\t\tneighbors= lastGen.charAt(1) == '#' ? 1 : 0;\n\t\t\t} else if (i == lastGen.length() - 1){\n\t\t\t\tneighbors= lastGen.charAt(i - 1) == '#' ? 1 : 0;\n\t\t\t} else{\n\t\t\t\tneighbors= getNeighbors(lastGen.substring(i - 1, i + 2));\n\t\t\t}\n\n\t\t\tif (neighbors == 0){\n\t\t\t\tnewGen+= \"_\";\n\t\t\t}\n\t\t\tif (neighbors == 1){\n\t\t\t\tnewGen+= lastGen.charAt(i);\n\t\t\t}\n\t\t\tif (neighbors == 2){\n\t\t\t\tnewGen+= lastGen.charAt(i) == '#' ? \"_\" : \"#\";\n\t\t\t}\n\t\t}\n\t\treturn newGen;\n\t}\n\n\tpublic static int getNeighbors(String group){\n\t\tint ans= 0;\n\t\tif (group.charAt(0) == '#') ans++;\n\t\tif (group.charAt(2) == '#') ans++;\n\t\treturn ans;\n\t}\n}\n"}
{"id": 44233, "name": "One-dimensional cellular automata", "source": "Translate Ruby to Python: def evolve(ary)\n  ([0]+ary+[0]).each_cons(3).map{|a,b,c| a+b+c == 2 ? 1 : 0}\nend\n\ndef printit(ary)\n  puts ary.join.tr(\"01\",\".\nend\n\nary = [0,1,1,1,0,1,1,0,1,0,1,0,1,0,1,0,0,1,0,0]\nprintit ary\nuntil ary == (new = evolve(ary))\n  printit ary = new\nend\n", "target": "import random\n\nprintdead, printlive = '_\nmaxgenerations = 10\ncellcount = 20\noffendvalue = '0'\n\nuniverse = ''.join(random.choice('01') for i in range(cellcount))\n\nneighbours2newstate = {\n '000': '0',\n '001': '0',\n '010': '0',\n '011': '1',\n '100': '0',\n '101': '1',\n '110': '1',\n '111': '0',\n }\n\nfor i in range(maxgenerations):\n    print \"Generation %3i:  %s\" % ( i,\n          universe.replace('0', printdead).replace('1', printlive) )\n    universe = offendvalue + universe + offendvalue\n    universe = ''.join(neighbours2newstate[universe[i:i+3]] for i in range(cellcount))\n"}
{"id": 44534, "name": "Determine if a string is collapsible", "source": "Translate Ruby to C#: strings = [\"\",\n        '\"If I were two-faced, would I be wearing this one?\" --- Abraham Lincoln ',\n        \"..1111111111111111111111111111111111111111111111111111111111111117777888\",\n        \"I never give 'em hell, I just tell the truth, and they think it's hell. \",\n        \"                                                   ---  Harry S Truman  \",\n        \"The better the 4-wheel drive, the further you'll be from help when ya get stuck!\",\n        \"headmistressship\",\n        \"aardvark\",\n        \"\ud83d\ude0d\ud83d\ude00\ud83d\ude4c\ud83d\udc83\ud83d\ude0d\ud83d\ude0d\ud83d\ude0d\ud83d\ude4c\",]\n\nstrings.each do |str|\n  puts \"\u00ab\u00ab\u00ab\n  ssq = str.squeeze\n  puts \"\u00ab\u00ab\u00ab\n  puts\nend\n", "target": "using System;\nusing static System.Linq.Enumerable;\n\npublic class Program\n{\n    static void Main()\n    {\n        string[] input = {\n            \"\",\n            \"The better the 4-wheel drive, the further you'll be from help when ya get stuck!\",\n            \"headmistressship\",\n            \"\\\"If I were two-faced, would I be wearing this one?\\\" --- Abraham Lincoln \",\n            \"..1111111111111111111111111111111111111111111111111111111111111117777888\",\n            \"I never give 'em hell, I just tell the truth, and they think it's hell. \",\n            \"                                                    --- Harry S Truman  \"\n        };\n        foreach (string s in input) {\n            Console.WriteLine($\"old: {s.Length} \u00ab\u00ab\u00ab{s}\u00bb\u00bb\u00bb\");\n            string c = Collapse(s);\n            Console.WriteLine($\"new: {c.Length} \u00ab\u00ab\u00ab{c}\u00bb\u00bb\u00bb\");\n        }\n    }\n\n    static string Collapse(string s) => string.IsNullOrEmpty(s) ? \"\" :\n        s[0] + new string(Range(1, s.Length - 1).Where(i => s[i] != s[i - 1]).Select(i => s[i]).ToArray());\n}\n"}
{"id": 44535, "name": "Determine if a string is collapsible", "source": "Translate Ruby to C#: strings = [\"\",\n        '\"If I were two-faced, would I be wearing this one?\" --- Abraham Lincoln ',\n        \"..1111111111111111111111111111111111111111111111111111111111111117777888\",\n        \"I never give 'em hell, I just tell the truth, and they think it's hell. \",\n        \"                                                   ---  Harry S Truman  \",\n        \"The better the 4-wheel drive, the further you'll be from help when ya get stuck!\",\n        \"headmistressship\",\n        \"aardvark\",\n        \"\ud83d\ude0d\ud83d\ude00\ud83d\ude4c\ud83d\udc83\ud83d\ude0d\ud83d\ude0d\ud83d\ude0d\ud83d\ude4c\",]\n\nstrings.each do |str|\n  puts \"\u00ab\u00ab\u00ab\n  ssq = str.squeeze\n  puts \"\u00ab\u00ab\u00ab\n  puts\nend\n", "target": "using System;\nusing static System.Linq.Enumerable;\n\npublic class Program\n{\n    static void Main()\n    {\n        string[] input = {\n            \"\",\n            \"The better the 4-wheel drive, the further you'll be from help when ya get stuck!\",\n            \"headmistressship\",\n            \"\\\"If I were two-faced, would I be wearing this one?\\\" --- Abraham Lincoln \",\n            \"..1111111111111111111111111111111111111111111111111111111111111117777888\",\n            \"I never give 'em hell, I just tell the truth, and they think it's hell. \",\n            \"                                                    --- Harry S Truman  \"\n        };\n        foreach (string s in input) {\n            Console.WriteLine($\"old: {s.Length} \u00ab\u00ab\u00ab{s}\u00bb\u00bb\u00bb\");\n            string c = Collapse(s);\n            Console.WriteLine($\"new: {c.Length} \u00ab\u00ab\u00ab{c}\u00bb\u00bb\u00bb\");\n        }\n    }\n\n    static string Collapse(string s) => string.IsNullOrEmpty(s) ? \"\" :\n        s[0] + new string(Range(1, s.Length - 1).Where(i => s[i] != s[i - 1]).Select(i => s[i]).ToArray());\n}\n"}
{"id": 44538, "name": "Determine if a string is collapsible", "source": "Translate Ruby to Java: strings = [\"\",\n        '\"If I were two-faced, would I be wearing this one?\" --- Abraham Lincoln ',\n        \"..1111111111111111111111111111111111111111111111111111111111111117777888\",\n        \"I never give 'em hell, I just tell the truth, and they think it's hell. \",\n        \"                                                   ---  Harry S Truman  \",\n        \"The better the 4-wheel drive, the further you'll be from help when ya get stuck!\",\n        \"headmistressship\",\n        \"aardvark\",\n        \"\ud83d\ude0d\ud83d\ude00\ud83d\ude4c\ud83d\udc83\ud83d\ude0d\ud83d\ude0d\ud83d\ude0d\ud83d\ude4c\",]\n\nstrings.each do |str|\n  puts \"\u00ab\u00ab\u00ab\n  ssq = str.squeeze\n  puts \"\u00ab\u00ab\u00ab\n  puts\nend\n", "target": "\n\npublic class StringCollapsible {\n\n    public static void main(String[] args) {\n        for ( String s : new String[] {\n              \"\", \n              \"\\\"If I were two-faced, would I be wearing this one?\\\" --- Abraham Lincoln \", \n              \"..1111111111111111111111111111111111111111111111111111111111111117777888\", \n              \"I never give 'em hell, I just tell the truth, and they think it's hell. \", \n              \"                                                    --- Harry S Truman  \",\n              \"122333444455555666666777777788888888999999999\",\n              \"The better the 4-wheel drive, the further you'll be from help when ya get stuck!\",\n              \"headmistressship\"}) {\n            String result = collapse(s);\n            System.out.printf(\"old:  %2d <<<%s>>>%nnew:  %2d <<<%s>>>%n%n\", s.length(), s, result.length(), result);\n        }\n    }\n    \n    private static String collapse(String in) {\n        StringBuilder sb = new StringBuilder();\n        for ( int i = 0 ; i < in.length() ; i++ ) {\n            if ( i == 0 || in.charAt(i-1) != in.charAt(i) ) {\n                sb.append(in.charAt(i));\n            }\n        }\n        return sb.toString();\n    }\n\n}\n"}
{"id": 44539, "name": "Determine if a string is collapsible", "source": "Translate Ruby to Java: strings = [\"\",\n        '\"If I were two-faced, would I be wearing this one?\" --- Abraham Lincoln ',\n        \"..1111111111111111111111111111111111111111111111111111111111111117777888\",\n        \"I never give 'em hell, I just tell the truth, and they think it's hell. \",\n        \"                                                   ---  Harry S Truman  \",\n        \"The better the 4-wheel drive, the further you'll be from help when ya get stuck!\",\n        \"headmistressship\",\n        \"aardvark\",\n        \"\ud83d\ude0d\ud83d\ude00\ud83d\ude4c\ud83d\udc83\ud83d\ude0d\ud83d\ude0d\ud83d\ude0d\ud83d\ude4c\",]\n\nstrings.each do |str|\n  puts \"\u00ab\u00ab\u00ab\n  ssq = str.squeeze\n  puts \"\u00ab\u00ab\u00ab\n  puts\nend\n", "target": "\n\npublic class StringCollapsible {\n\n    public static void main(String[] args) {\n        for ( String s : new String[] {\n              \"\", \n              \"\\\"If I were two-faced, would I be wearing this one?\\\" --- Abraham Lincoln \", \n              \"..1111111111111111111111111111111111111111111111111111111111111117777888\", \n              \"I never give 'em hell, I just tell the truth, and they think it's hell. \", \n              \"                                                    --- Harry S Truman  \",\n              \"122333444455555666666777777788888888999999999\",\n              \"The better the 4-wheel drive, the further you'll be from help when ya get stuck!\",\n              \"headmistressship\"}) {\n            String result = collapse(s);\n            System.out.printf(\"old:  %2d <<<%s>>>%nnew:  %2d <<<%s>>>%n%n\", s.length(), s, result.length(), result);\n        }\n    }\n    \n    private static String collapse(String in) {\n        StringBuilder sb = new StringBuilder();\n        for ( int i = 0 ; i < in.length() ; i++ ) {\n            if ( i == 0 || in.charAt(i-1) != in.charAt(i) ) {\n                sb.append(in.charAt(i));\n            }\n        }\n        return sb.toString();\n    }\n\n}\n"}
{"id": 44540, "name": "Determine if a string is collapsible", "source": "Translate Ruby to Python: strings = [\"\",\n        '\"If I were two-faced, would I be wearing this one?\" --- Abraham Lincoln ',\n        \"..1111111111111111111111111111111111111111111111111111111111111117777888\",\n        \"I never give 'em hell, I just tell the truth, and they think it's hell. \",\n        \"                                                   ---  Harry S Truman  \",\n        \"The better the 4-wheel drive, the further you'll be from help when ya get stuck!\",\n        \"headmistressship\",\n        \"aardvark\",\n        \"\ud83d\ude0d\ud83d\ude00\ud83d\ude4c\ud83d\udc83\ud83d\ude0d\ud83d\ude0d\ud83d\ude0d\ud83d\ude4c\",]\n\nstrings.each do |str|\n  puts \"\u00ab\u00ab\u00ab\n  ssq = str.squeeze\n  puts \"\u00ab\u00ab\u00ab\n  puts\nend\n", "target": "from itertools import groupby\n\ndef collapser(txt):\n    return ''.join(item for item, grp in groupby(txt))\n\nif __name__ == '__main__':\n    strings = [\n            \"\",\n            '\"If I were two-faced, would I be wearing this one?\" --- Abraham Lincoln ',\n            \"..1111111111111111111111111111111111111111111111111111111111111117777888\",\n            \"I never give 'em hell, I just tell the truth, and they think it's hell. \",\n            \"                                                   ---  Harry S Truman  \",\n            \"The better the 4-wheel drive, the further you'll be from help when ya get stuck!\",\n            \"headmistressship\",\n            \"aardvark\",\n            \"\ud83d\ude0d\ud83d\ude00\ud83d\ude4c\ud83d\udc83\ud83d\ude0d\ud83d\ude0d\ud83d\ude0d\ud83d\ude4c\",\n            ]\n    for txt in strings:\n        this = \"Original\"\n        print(f\"\\n{this:14} Size: {len(txt)} \u00ab\u00ab\u00ab{txt}\u00bb\u00bb\u00bb\" )\n        this = \"Collapsed\"\n        sqz = collapser(txt)\n        print(f\"{this:>14} Size: {len(sqz)} \u00ab\u00ab\u00ab{sqz}\u00bb\u00bb\u00bb\" )\n"}
{"id": 44541, "name": "Determine if a string is collapsible", "source": "Translate Ruby to Python: strings = [\"\",\n        '\"If I were two-faced, would I be wearing this one?\" --- Abraham Lincoln ',\n        \"..1111111111111111111111111111111111111111111111111111111111111117777888\",\n        \"I never give 'em hell, I just tell the truth, and they think it's hell. \",\n        \"                                                   ---  Harry S Truman  \",\n        \"The better the 4-wheel drive, the further you'll be from help when ya get stuck!\",\n        \"headmistressship\",\n        \"aardvark\",\n        \"\ud83d\ude0d\ud83d\ude00\ud83d\ude4c\ud83d\udc83\ud83d\ude0d\ud83d\ude0d\ud83d\ude0d\ud83d\ude4c\",]\n\nstrings.each do |str|\n  puts \"\u00ab\u00ab\u00ab\n  ssq = str.squeeze\n  puts \"\u00ab\u00ab\u00ab\n  puts\nend\n", "target": "from itertools import groupby\n\ndef collapser(txt):\n    return ''.join(item for item, grp in groupby(txt))\n\nif __name__ == '__main__':\n    strings = [\n            \"\",\n            '\"If I were two-faced, would I be wearing this one?\" --- Abraham Lincoln ',\n            \"..1111111111111111111111111111111111111111111111111111111111111117777888\",\n            \"I never give 'em hell, I just tell the truth, and they think it's hell. \",\n            \"                                                   ---  Harry S Truman  \",\n            \"The better the 4-wheel drive, the further you'll be from help when ya get stuck!\",\n            \"headmistressship\",\n            \"aardvark\",\n            \"\ud83d\ude0d\ud83d\ude00\ud83d\ude4c\ud83d\udc83\ud83d\ude0d\ud83d\ude0d\ud83d\ude0d\ud83d\ude4c\",\n            ]\n    for txt in strings:\n        this = \"Original\"\n        print(f\"\\n{this:14} Size: {len(txt)} \u00ab\u00ab\u00ab{txt}\u00bb\u00bb\u00bb\" )\n        this = \"Collapsed\"\n        sqz = collapser(txt)\n        print(f\"{this:>14} Size: {len(sqz)} \u00ab\u00ab\u00ab{sqz}\u00bb\u00bb\u00bb\" )\n"}
{"id": 44763, "name": "Inheritance_Multiple", "source": "Translate Ruby to C#: module Camera\n  \nend\nclass MobilePhone\n  \nend\nclass CameraPhone < MobilePhone\n  include Camera\n  \nend\n", "target": "interface ICamera {\n    \n}\n\nclass MobilePhone {\n    \n}\n\nclass CameraPhone: ICamera, MobilePhone {\n    \n}\n"}
{"id": 44765, "name": "Inheritance_Multiple", "source": "Translate Ruby to Java: module Camera\n  \nend\nclass MobilePhone\n  \nend\nclass CameraPhone < MobilePhone\n  include Camera\n  \nend\n", "target": "public interface Camera{\n   \n   \n   \n}\n"}
{"id": 45105, "name": "Zero to the zero power", "source": "Translate Ruby to C#: require 'bigdecimal'\n\n[0, 0.0, Complex(0), Rational(0), BigDecimal(\"0\")].each do |n|\n  printf \"%10s: ** -> %s\\n\" % [n.class, n**n]\nend\n", "target": "using System;\n\nnamespace ZeroToTheZeroeth\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            double k = Math.Pow(0, 0);\n            Console.Write(\"0^0 is {0}\", k);           \n        }\n    }\n}\n"}
{"id": 45106, "name": "Zero to the zero power", "source": "Translate Ruby to C#: require 'bigdecimal'\n\n[0, 0.0, Complex(0), Rational(0), BigDecimal(\"0\")].each do |n|\n  printf \"%10s: ** -> %s\\n\" % [n.class, n**n]\nend\n", "target": "using System;\n\nnamespace ZeroToTheZeroeth\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            double k = Math.Pow(0, 0);\n            Console.Write(\"0^0 is {0}\", k);           \n        }\n    }\n}\n"}
{"id": 45109, "name": "Zero to the zero power", "source": "Translate Ruby to Java: require 'bigdecimal'\n\n[0, 0.0, Complex(0), Rational(0), BigDecimal(\"0\")].each do |n|\n  printf \"%10s: ** -> %s\\n\" % [n.class, n**n]\nend\n", "target": "System.out.println(Math.pow(0, 0));\n"}
{"id": 45110, "name": "Zero to the zero power", "source": "Translate Ruby to Java: require 'bigdecimal'\n\n[0, 0.0, Complex(0), Rational(0), BigDecimal(\"0\")].each do |n|\n  printf \"%10s: ** -> %s\\n\" % [n.class, n**n]\nend\n", "target": "System.out.println(Math.pow(0, 0));\n"}
{"id": 45111, "name": "Zero to the zero power", "source": "Translate Ruby to Python: require 'bigdecimal'\n\n[0, 0.0, Complex(0), Rational(0), BigDecimal(\"0\")].each do |n|\n  printf \"%10s: ** -> %s\\n\" % [n.class, n**n]\nend\n", "target": "from decimal import Decimal\nfrom fractions import Fraction\nfrom itertools import product\n\nzeroes = [0, 0.0, 0j, Decimal(0), Fraction(0, 1), -0.0, -0.0j, Decimal(-0.0)]\nfor i, j in product(zeroes, repeat=2):\n    try:\n        ans = i**j\n    except:\n        ans = '<Exception raised>'\n    print(f'{i!r:>15} ** {j!r:<15} = {ans!r}')\n"}
{"id": 45112, "name": "Zero to the zero power", "source": "Translate Ruby to Python: require 'bigdecimal'\n\n[0, 0.0, Complex(0), Rational(0), BigDecimal(\"0\")].each do |n|\n  printf \"%10s: ** -> %s\\n\" % [n.class, n**n]\nend\n", "target": "from decimal import Decimal\nfrom fractions import Fraction\nfrom itertools import product\n\nzeroes = [0, 0.0, 0j, Decimal(0), Fraction(0, 1), -0.0, -0.0j, Decimal(-0.0)]\nfor i, j in product(zeroes, repeat=2):\n    try:\n        ans = i**j\n    except:\n        ans = '<Exception raised>'\n    print(f'{i!r:>15} ** {j!r:<15} = {ans!r}')\n"}
{"id": 45473, "name": "Runge-Kutta method", "source": "Translate Ruby to C#: y, t = 1, 0\nwhile t <= 10\n   k1\t=  t         * Math.sqrt(y)\n   k2\t= (t + 0.05) * Math.sqrt(y + 0.05 * k1)\n   k3\t= (t + 0.05) * Math.sqrt(y + 0.05 * k2)\n   k4\t= (t + 0.1)  * Math.sqrt(y + 0.1  * k3)\n \n   printf(\"y(%4.1f)\\t= %12.6f \\t error: %12.6e\\n\", t, y, (((t**2 + 4)**2 / 16) - y )) if (t.round - t).abs < 1.0e-5\n   y += 0.1 * (k1 + 2 * (k2 + k3) + k4) / 6\n   t += 0.1\nend\n", "target": "using System;\n\nnamespace RungeKutta\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            \n            double t = 0.0;\n            double T = 10.0;\n            double dt = 0.1;\n\n            \n            int n = (int)(((T - t) / dt)) + 1;\n\n            \n            double[] y = new double[n];\n            double[] s = new double[n];\n\n            \n            double dy1;\n            double dy2;\n            double dy3;\n            double dy4;\n\n            \n            int i = 0;\n            s[i] = 0.0;\n            y[i] = 1.0;\n\n            Console.WriteLine(\" ===================================== \");\n            Console.WriteLine(\" Beging 4th Order Runge Kutta Method \");\n            Console.WriteLine(\" ===================================== \");\n\n            Console.WriteLine();\n            Console.WriteLine(\" Given the example Differential equation: \\n\");\n            Console.WriteLine(\"     y' = t*sqrt(y) \\n\");\n            Console.WriteLine(\" With the initial conditions: \\n\");\n            Console.WriteLine(\"     t0 = 0\" + \", y(0) = 1.0 \\n\");\n            Console.WriteLine(\" Whose exact solution is known to be: \\n\");\n            Console.WriteLine(\"     y(t) = 1/16*(t^2 + 4)^2 \\n\");\n            Console.WriteLine(\" Solve the given equations over the range t = 0...10 with a step value dt = 0.1 \\n\");\n            Console.WriteLine(\" Print the calculated values of y at whole numbered t's (0.0,1.0,...10.0) along with the error \\n\");\n            Console.WriteLine();\n\n            Console.WriteLine(\" y(t) \" +\"RK4\" + \" \".PadRight(18) + \"Absolute Error\");\n            Console.WriteLine(\" -------------------------------------------------\");\n            Console.WriteLine(\" y(0) \" + y[i] + \" \".PadRight(20) + (y[i] - solution(s[i])));\n\n            \n            while (i < y.Length - 1)\n            {\n\n                dy1 = dt * equation(s[i], y[i]);\n                dy2 = dt * equation(s[i] + dt / 2, y[i] + dy1 / 2);\n                dy3 = dt * equation(s[i] + dt / 2, y[i] + dy2 / 2);\n                dy4 = dt * equation(s[i] + dt, y[i] + dy3);\n\n                s[i + 1] = s[i] + dt;\n                y[i + 1] = y[i] + (dy1 + 2 * dy2 + 2 * dy3 + dy4) / 6;\n\n                double error = Math.Abs(y[i + 1] - solution(s[i + 1]));\n                double t_rounded = Math.Round(t + dt, 2);\n\n                if (t_rounded % 1 == 0)\n                {\n                    Console.WriteLine(\" y(\" + t_rounded + \")\" + \" \" + y[i + 1] + \" \".PadRight(5) + (error));\n                }\n\n                i++;\n                t += dt;\n\n            };\n\n            Console.ReadLine();\n        }\n\n        \n        public static double equation(double t, double y)\n        {\n            double y_prime;\n            return y_prime = t*Math.Sqrt(y);\n        }\n\n        \n        public static double solution(double t)\n        {\n            double actual;\n            actual = Math.Pow((Math.Pow(t, 2) + 4), 2)/16;\n            return actual;\n        }\n    }\n}\n"}
{"id": 45474, "name": "Runge-Kutta method", "source": "Translate Ruby to C#: y, t = 1, 0\nwhile t <= 10\n   k1\t=  t         * Math.sqrt(y)\n   k2\t= (t + 0.05) * Math.sqrt(y + 0.05 * k1)\n   k3\t= (t + 0.05) * Math.sqrt(y + 0.05 * k2)\n   k4\t= (t + 0.1)  * Math.sqrt(y + 0.1  * k3)\n \n   printf(\"y(%4.1f)\\t= %12.6f \\t error: %12.6e\\n\", t, y, (((t**2 + 4)**2 / 16) - y )) if (t.round - t).abs < 1.0e-5\n   y += 0.1 * (k1 + 2 * (k2 + k3) + k4) / 6\n   t += 0.1\nend\n", "target": "using System;\n\nnamespace RungeKutta\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            \n            double t = 0.0;\n            double T = 10.0;\n            double dt = 0.1;\n\n            \n            int n = (int)(((T - t) / dt)) + 1;\n\n            \n            double[] y = new double[n];\n            double[] s = new double[n];\n\n            \n            double dy1;\n            double dy2;\n            double dy3;\n            double dy4;\n\n            \n            int i = 0;\n            s[i] = 0.0;\n            y[i] = 1.0;\n\n            Console.WriteLine(\" ===================================== \");\n            Console.WriteLine(\" Beging 4th Order Runge Kutta Method \");\n            Console.WriteLine(\" ===================================== \");\n\n            Console.WriteLine();\n            Console.WriteLine(\" Given the example Differential equation: \\n\");\n            Console.WriteLine(\"     y' = t*sqrt(y) \\n\");\n            Console.WriteLine(\" With the initial conditions: \\n\");\n            Console.WriteLine(\"     t0 = 0\" + \", y(0) = 1.0 \\n\");\n            Console.WriteLine(\" Whose exact solution is known to be: \\n\");\n            Console.WriteLine(\"     y(t) = 1/16*(t^2 + 4)^2 \\n\");\n            Console.WriteLine(\" Solve the given equations over the range t = 0...10 with a step value dt = 0.1 \\n\");\n            Console.WriteLine(\" Print the calculated values of y at whole numbered t's (0.0,1.0,...10.0) along with the error \\n\");\n            Console.WriteLine();\n\n            Console.WriteLine(\" y(t) \" +\"RK4\" + \" \".PadRight(18) + \"Absolute Error\");\n            Console.WriteLine(\" -------------------------------------------------\");\n            Console.WriteLine(\" y(0) \" + y[i] + \" \".PadRight(20) + (y[i] - solution(s[i])));\n\n            \n            while (i < y.Length - 1)\n            {\n\n                dy1 = dt * equation(s[i], y[i]);\n                dy2 = dt * equation(s[i] + dt / 2, y[i] + dy1 / 2);\n                dy3 = dt * equation(s[i] + dt / 2, y[i] + dy2 / 2);\n                dy4 = dt * equation(s[i] + dt, y[i] + dy3);\n\n                s[i + 1] = s[i] + dt;\n                y[i + 1] = y[i] + (dy1 + 2 * dy2 + 2 * dy3 + dy4) / 6;\n\n                double error = Math.Abs(y[i + 1] - solution(s[i + 1]));\n                double t_rounded = Math.Round(t + dt, 2);\n\n                if (t_rounded % 1 == 0)\n                {\n                    Console.WriteLine(\" y(\" + t_rounded + \")\" + \" \" + y[i + 1] + \" \".PadRight(5) + (error));\n                }\n\n                i++;\n                t += dt;\n\n            };\n\n            Console.ReadLine();\n        }\n\n        \n        public static double equation(double t, double y)\n        {\n            double y_prime;\n            return y_prime = t*Math.Sqrt(y);\n        }\n\n        \n        public static double solution(double t)\n        {\n            double actual;\n            actual = Math.Pow((Math.Pow(t, 2) + 4), 2)/16;\n            return actual;\n        }\n    }\n}\n"}
{"id": 45477, "name": "Runge-Kutta method", "source": "Translate Ruby to Java: y, t = 1, 0\nwhile t <= 10\n   k1\t=  t         * Math.sqrt(y)\n   k2\t= (t + 0.05) * Math.sqrt(y + 0.05 * k1)\n   k3\t= (t + 0.05) * Math.sqrt(y + 0.05 * k2)\n   k4\t= (t + 0.1)  * Math.sqrt(y + 0.1  * k3)\n \n   printf(\"y(%4.1f)\\t= %12.6f \\t error: %12.6e\\n\", t, y, (((t**2 + 4)**2 / 16) - y )) if (t.round - t).abs < 1.0e-5\n   y += 0.1 * (k1 + 2 * (k2 + k3) + k4) / 6\n   t += 0.1\nend\n", "target": "import static java.lang.Math.*;\nimport java.util.function.BiFunction;\n\npublic class RungeKutta {\n\n    static void runge(BiFunction<Double, Double, Double> yp_func, double[] t,\n            double[] y, double dt) {\n\n        for (int n = 0; n < t.length - 1; n++) {\n            double dy1 = dt * yp_func.apply(t[n], y[n]);\n            double dy2 = dt * yp_func.apply(t[n] + dt / 2.0, y[n] + dy1 / 2.0);\n            double dy3 = dt * yp_func.apply(t[n] + dt / 2.0, y[n] + dy2 / 2.0);\n            double dy4 = dt * yp_func.apply(t[n] + dt, y[n] + dy3);\n            t[n + 1] = t[n] + dt;\n            y[n + 1] = y[n] + (dy1 + 2.0 * (dy2 + dy3) + dy4) / 6.0;\n        }\n    }\n\n    static double calc_err(double t, double calc) {\n        double actual = pow(pow(t, 2.0) + 4.0, 2) / 16.0;\n        return abs(actual - calc);\n    }\n\n    public static void main(String[] args) {\n        double dt = 0.10;\n        double[] t_arr = new double[101];\n        double[] y_arr = new double[101];\n        y_arr[0] = 1.0;\n\n        runge((t, y) -> t * sqrt(y), t_arr, y_arr, dt);\n\n        for (int i = 0; i < t_arr.length; i++)\n            if (i % 10 == 0)\n                System.out.printf(\"y(%.1f) =\u00a0%.8f Error:\u00a0%.6f%n\",\n                        t_arr[i], y_arr[i],\n                        calc_err(t_arr[i], y_arr[i]));\n    }\n}\n"}
{"id": 45478, "name": "Runge-Kutta method", "source": "Translate Ruby to Java: y, t = 1, 0\nwhile t <= 10\n   k1\t=  t         * Math.sqrt(y)\n   k2\t= (t + 0.05) * Math.sqrt(y + 0.05 * k1)\n   k3\t= (t + 0.05) * Math.sqrt(y + 0.05 * k2)\n   k4\t= (t + 0.1)  * Math.sqrt(y + 0.1  * k3)\n \n   printf(\"y(%4.1f)\\t= %12.6f \\t error: %12.6e\\n\", t, y, (((t**2 + 4)**2 / 16) - y )) if (t.round - t).abs < 1.0e-5\n   y += 0.1 * (k1 + 2 * (k2 + k3) + k4) / 6\n   t += 0.1\nend\n", "target": "import static java.lang.Math.*;\nimport java.util.function.BiFunction;\n\npublic class RungeKutta {\n\n    static void runge(BiFunction<Double, Double, Double> yp_func, double[] t,\n            double[] y, double dt) {\n\n        for (int n = 0; n < t.length - 1; n++) {\n            double dy1 = dt * yp_func.apply(t[n], y[n]);\n            double dy2 = dt * yp_func.apply(t[n] + dt / 2.0, y[n] + dy1 / 2.0);\n            double dy3 = dt * yp_func.apply(t[n] + dt / 2.0, y[n] + dy2 / 2.0);\n            double dy4 = dt * yp_func.apply(t[n] + dt, y[n] + dy3);\n            t[n + 1] = t[n] + dt;\n            y[n + 1] = y[n] + (dy1 + 2.0 * (dy2 + dy3) + dy4) / 6.0;\n        }\n    }\n\n    static double calc_err(double t, double calc) {\n        double actual = pow(pow(t, 2.0) + 4.0, 2) / 16.0;\n        return abs(actual - calc);\n    }\n\n    public static void main(String[] args) {\n        double dt = 0.10;\n        double[] t_arr = new double[101];\n        double[] y_arr = new double[101];\n        y_arr[0] = 1.0;\n\n        runge((t, y) -> t * sqrt(y), t_arr, y_arr, dt);\n\n        for (int i = 0; i < t_arr.length; i++)\n            if (i % 10 == 0)\n                System.out.printf(\"y(%.1f) =\u00a0%.8f Error:\u00a0%.6f%n\",\n                        t_arr[i], y_arr[i],\n                        calc_err(t_arr[i], y_arr[i]));\n    }\n}\n"}
{"id": 45479, "name": "Runge-Kutta method", "source": "Translate Ruby to Python: y, t = 1, 0\nwhile t <= 10\n   k1\t=  t         * Math.sqrt(y)\n   k2\t= (t + 0.05) * Math.sqrt(y + 0.05 * k1)\n   k3\t= (t + 0.05) * Math.sqrt(y + 0.05 * k2)\n   k4\t= (t + 0.1)  * Math.sqrt(y + 0.1  * k3)\n \n   printf(\"y(%4.1f)\\t= %12.6f \\t error: %12.6e\\n\", t, y, (((t**2 + 4)**2 / 16) - y )) if (t.round - t).abs < 1.0e-5\n   y += 0.1 * (k1 + 2 * (k2 + k3) + k4) / 6\n   t += 0.1\nend\n", "target": "from math import sqrt\n \ndef rk4(f, x0, y0, x1, n):\n    vx = [0] * (n + 1)\n    vy = [0] * (n + 1)\n    h = (x1 - x0) / float(n)\n    vx[0] = x = x0\n    vy[0] = y = y0\n    for i in range(1, n + 1):\n        k1 = h * f(x, y)\n        k2 = h * f(x + 0.5 * h, y + 0.5 * k1)\n        k3 = h * f(x + 0.5 * h, y + 0.5 * k2)\n        k4 = h * f(x + h, y + k3)\n        vx[i] = x = x0 + i * h\n        vy[i] = y = y + (k1 + k2 + k2 + k3 + k3 + k4) / 6\n    return vx, vy\n \ndef f(x, y):\n    return x * sqrt(y)\n \nvx, vy = rk4(f, 0, 1, 10, 100)\nfor x, y in list(zip(vx, vy))[::10]:\n    print(\"%4.1f %10.5f %+12.4e\" % (x, y, y - (4 + x * x)**2 / 16))\n\n 0.0    1.00000  +0.0000e+00\n 1.0    1.56250  -1.4572e-07\n 2.0    4.00000  -9.1948e-07\n 3.0   10.56250  -2.9096e-06\n 4.0   24.99999  -6.2349e-06\n 5.0   52.56249  -1.0820e-05\n 6.0   99.99998  -1.6595e-05\n 7.0  175.56248  -2.3518e-05\n 8.0  288.99997  -3.1565e-05\n 9.0  451.56246  -4.0723e-05\n10.0  675.99995  -5.0983e-05\n"}
{"id": 45480, "name": "Runge-Kutta method", "source": "Translate Ruby to Python: y, t = 1, 0\nwhile t <= 10\n   k1\t=  t         * Math.sqrt(y)\n   k2\t= (t + 0.05) * Math.sqrt(y + 0.05 * k1)\n   k3\t= (t + 0.05) * Math.sqrt(y + 0.05 * k2)\n   k4\t= (t + 0.1)  * Math.sqrt(y + 0.1  * k3)\n \n   printf(\"y(%4.1f)\\t= %12.6f \\t error: %12.6e\\n\", t, y, (((t**2 + 4)**2 / 16) - y )) if (t.round - t).abs < 1.0e-5\n   y += 0.1 * (k1 + 2 * (k2 + k3) + k4) / 6\n   t += 0.1\nend\n", "target": "from math import sqrt\n \ndef rk4(f, x0, y0, x1, n):\n    vx = [0] * (n + 1)\n    vy = [0] * (n + 1)\n    h = (x1 - x0) / float(n)\n    vx[0] = x = x0\n    vy[0] = y = y0\n    for i in range(1, n + 1):\n        k1 = h * f(x, y)\n        k2 = h * f(x + 0.5 * h, y + 0.5 * k1)\n        k3 = h * f(x + 0.5 * h, y + 0.5 * k2)\n        k4 = h * f(x + h, y + k3)\n        vx[i] = x = x0 + i * h\n        vy[i] = y = y + (k1 + k2 + k2 + k3 + k3 + k4) / 6\n    return vx, vy\n \ndef f(x, y):\n    return x * sqrt(y)\n \nvx, vy = rk4(f, 0, 1, 10, 100)\nfor x, y in list(zip(vx, vy))[::10]:\n    print(\"%4.1f %10.5f %+12.4e\" % (x, y, y - (4 + x * x)**2 / 16))\n\n 0.0    1.00000  +0.0000e+00\n 1.0    1.56250  -1.4572e-07\n 2.0    4.00000  -9.1948e-07\n 3.0   10.56250  -2.9096e-06\n 4.0   24.99999  -6.2349e-06\n 5.0   52.56249  -1.0820e-05\n 6.0   99.99998  -1.6595e-05\n 7.0  175.56248  -2.3518e-05\n 8.0  288.99997  -3.1565e-05\n 9.0  451.56246  -4.0723e-05\n10.0  675.99995  -5.0983e-05\n"}
{"id": 45740, "name": "Multiplication tables", "source": "Translate Ruby to C#: def multiplication_table(n)\n  puts \"    |\" + (\" %3d\" * n) % [*1..n]\n  puts \"----+\" + \"----\" * n\n  1.upto(n) do |x|\n    print \"%3d |\" % x\n    1.upto(x-1) {|y| print \"    \"}\n    x.upto(n)   {|y| print \" %3d\" % (x*y)}\n    puts\n  end\nend\n\nmultiplication_table 12\n", "target": "using System;\n\nnamespace multtbl\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            Console.Write(\" X\".PadRight(4));\n            for (int i = 1; i <= 12; i++)\n                Console.Write(i.ToString(\"####\").PadLeft(4));\n\n            Console.WriteLine();\n            Console.Write(\" ___\");\n\n            for (int i = 1; i <= 12; i++)\n                Console.Write(\" ___\");\n\n            Console.WriteLine();\n            for (int row = 1; row <= 12; row++)\n            {\n                Console.Write(row.ToString(\"###\").PadLeft(3).PadRight(4));\n                for (int col = 1; col <= 12; col++)\n                {\n                    if (row <= col)\n                        Console.Write((row * col).ToString(\"###\").PadLeft(4));\n                    else\n                        Console.Write(\"\".PadLeft(4));\n                }\n\n                Console.WriteLine();\n            }\n\n            Console.WriteLine();\n            Console.ReadLine();\n        }\n    }\n}\n"}
{"id": 45742, "name": "Multiplication tables", "source": "Translate Ruby to Java: def multiplication_table(n)\n  puts \"    |\" + (\" %3d\" * n) % [*1..n]\n  puts \"----+\" + \"----\" * n\n  1.upto(n) do |x|\n    print \"%3d |\" % x\n    1.upto(x-1) {|y| print \"    \"}\n    x.upto(n)   {|y| print \" %3d\" % (x*y)}\n    puts\n  end\nend\n\nmultiplication_table 12\n", "target": "public class MultiplicationTable {\n    public static void main(String[] args) {\n        for (int i = 1; i <= 12; i++)\n            System.out.print(\"\\t\" + i);\n        \n        System.out.println();\n        for (int i = 0; i < 100; i++)\n            System.out.print(\"-\");\n        System.out.println();\n        for (int i = 1; i <= 12; i++) {\n            System.out.print(i + \"|\");\n            for(int j = 1; j <= 12; j++) {\n                System.out.print(\"\\t\");\n                if (j >= i)\n                    System.out.print(\"\\t\" + i * j);\n            }\n            System.out.println();\n        }\n    }\n}\n"}
{"id": 45743, "name": "Multiplication tables", "source": "Translate Ruby to Python: def multiplication_table(n)\n  puts \"    |\" + (\" %3d\" * n) % [*1..n]\n  puts \"----+\" + \"----\" * n\n  1.upto(n) do |x|\n    print \"%3d |\" % x\n    1.upto(x-1) {|y| print \"    \"}\n    x.upto(n)   {|y| print \" %3d\" % (x*y)}\n    puts\n  end\nend\n\nmultiplication_table 12\n", "target": ">>> size = 12\n>>> width = len(str(size**2))\n>>> for row in range(-1,size+1):\n\tif row==0:\n\t\tprint(\"\u2500\"*width + \"\u253c\"+\"\u2500\"*((width+1)*size-1))\n\telse:\n\t\tprint(\"\".join(\"%*s%1s\" % ((width,) + ((\"x\",\"\u2502\")      if row==-1 and col==0\n\t\t\t\t\t              else (row,\"\u2502\") if row>0   and col==0\n\t\t\t\t\t              else (col,\"\")  if row==-1\n\t\t\t\t\t              else (\"\",\"\")   if row>col\n\t\t\t\t\t              else (row*col,\"\")))\n\t\t\t       for col in range(size+1)))\n\n\t\t\n  x\u2502  1   2   3   4   5   6   7   8   9  10  11  12 \n\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n  1\u2502  1   2   3   4   5   6   7   8   9  10  11  12 \n  2\u2502      4   6   8  10  12  14  16  18  20  22  24 \n  3\u2502          9  12  15  18  21  24  27  30  33  36 \n  4\u2502             16  20  24  28  32  36  40  44  48 \n  5\u2502                 25  30  35  40  45  50  55  60 \n  6\u2502                     36  42  48  54  60  66  72 \n  7\u2502                         49  56  63  70  77  84 \n  8\u2502                             64  72  80  88  96 \n  9\u2502                                 81  90  99 108 \n 10\u2502                                    100 110 120 \n 11\u2502                                        121 132 \n 12\u2502                                            144 \n>>>\n"}
{"id": 46137, "name": "Comma quibbling", "source": "Translate Ruby to C#: def comma_quibbling(a)\n  %w<{ }>.join(a.length < 2 ? a.first :\n               \"\nend\n\n[[], %w<ABC>, %w<ABC DEF>, %w<ABC DEF G H>].each do |a|\n  puts comma_quibbling(a)\nend\n", "target": "using System;\nusing System.Linq;\n\nnamespace CommaQuibbling\n{\n    internal static class Program\n    {\n        #region Static Members\n\tprivate static string Quibble(string[] input)\n\t{\n            return\n                String.Format(\"{{{0}}}\",\n                    String.Join(\"\",\n                        input.Reverse().Zip(\n                            new [] { \"\", \" and \" }.Concat(Enumerable.Repeat(\", \", int.MaxValue)),\n                            (x, y) => x + y).Reverse()));\n\t}\n\n\n        private static void Main()\n        {\n            Console.WriteLine( Quibble( new string[] {} ) );\n            Console.WriteLine( Quibble( new[] {\"ABC\"} ) );\n            Console.WriteLine( Quibble( new[] {\"ABC\", \"DEF\"} ) );\n            Console.WriteLine( Quibble( new[] {\"ABC\", \"DEF\", \"G\", \"H\"} ) );\n\n            Console.WriteLine( \"< Press Any Key >\" );\n            Console.ReadKey();\n        }\n\n        #endregion\n    }\n}\n"}
{"id": 46138, "name": "Comma quibbling", "source": "Translate Ruby to C#: def comma_quibbling(a)\n  %w<{ }>.join(a.length < 2 ? a.first :\n               \"\nend\n\n[[], %w<ABC>, %w<ABC DEF>, %w<ABC DEF G H>].each do |a|\n  puts comma_quibbling(a)\nend\n", "target": "using System;\nusing System.Linq;\n\nnamespace CommaQuibbling\n{\n    internal static class Program\n    {\n        #region Static Members\n\tprivate static string Quibble(string[] input)\n\t{\n            return\n                String.Format(\"{{{0}}}\",\n                    String.Join(\"\",\n                        input.Reverse().Zip(\n                            new [] { \"\", \" and \" }.Concat(Enumerable.Repeat(\", \", int.MaxValue)),\n                            (x, y) => x + y).Reverse()));\n\t}\n\n\n        private static void Main()\n        {\n            Console.WriteLine( Quibble( new string[] {} ) );\n            Console.WriteLine( Quibble( new[] {\"ABC\"} ) );\n            Console.WriteLine( Quibble( new[] {\"ABC\", \"DEF\"} ) );\n            Console.WriteLine( Quibble( new[] {\"ABC\", \"DEF\", \"G\", \"H\"} ) );\n\n            Console.WriteLine( \"< Press Any Key >\" );\n            Console.ReadKey();\n        }\n\n        #endregion\n    }\n}\n"}
{"id": 46141, "name": "Comma quibbling", "source": "Translate Ruby to Java: def comma_quibbling(a)\n  %w<{ }>.join(a.length < 2 ? a.first :\n               \"\nend\n\n[[], %w<ABC>, %w<ABC DEF>, %w<ABC DEF G H>].each do |a|\n  puts comma_quibbling(a)\nend\n", "target": "public class Quibbler {\n\n\tpublic static String quibble(String[] words) {\n\t\tString qText = \"{\";\n\t\tfor(int wIndex = 0; wIndex < words.length; wIndex++) {\n\t\t\tqText += words[wIndex] + (wIndex == words.length-1 ? \"\" : \n\t\t\t\t\t\t  wIndex == words.length-2 ? \" and \" :\n\t\t\t\t\t\t  \", \";\n\t\t}\n\t\tqText += \"}\";\n\t\treturn qText;\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tSystem.out.println(quibble(new String[]{}));\n\t\tSystem.out.println(quibble(new String[]{\"ABC\"}));\n\t\tSystem.out.println(quibble(new String[]{\"ABC\", \"DEF\"}));\n\t\tSystem.out.println(quibble(new String[]{\"ABC\", \"DEF\", \"G\"}));\n\t\tSystem.out.println(quibble(new String[]{\"ABC\", \"DEF\", \"G\", \"H\"}));\n\t}\n}\n"}
{"id": 46142, "name": "Comma quibbling", "source": "Translate Ruby to Java: def comma_quibbling(a)\n  %w<{ }>.join(a.length < 2 ? a.first :\n               \"\nend\n\n[[], %w<ABC>, %w<ABC DEF>, %w<ABC DEF G H>].each do |a|\n  puts comma_quibbling(a)\nend\n", "target": "public class Quibbler {\n\n\tpublic static String quibble(String[] words) {\n\t\tString qText = \"{\";\n\t\tfor(int wIndex = 0; wIndex < words.length; wIndex++) {\n\t\t\tqText += words[wIndex] + (wIndex == words.length-1 ? \"\" : \n\t\t\t\t\t\t  wIndex == words.length-2 ? \" and \" :\n\t\t\t\t\t\t  \", \";\n\t\t}\n\t\tqText += \"}\";\n\t\treturn qText;\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tSystem.out.println(quibble(new String[]{}));\n\t\tSystem.out.println(quibble(new String[]{\"ABC\"}));\n\t\tSystem.out.println(quibble(new String[]{\"ABC\", \"DEF\"}));\n\t\tSystem.out.println(quibble(new String[]{\"ABC\", \"DEF\", \"G\"}));\n\t\tSystem.out.println(quibble(new String[]{\"ABC\", \"DEF\", \"G\", \"H\"}));\n\t}\n}\n"}
{"id": 46143, "name": "Comma quibbling", "source": "Translate Ruby to Python: def comma_quibbling(a)\n  %w<{ }>.join(a.length < 2 ? a.first :\n               \"\nend\n\n[[], %w<ABC>, %w<ABC DEF>, %w<ABC DEF G H>].each do |a|\n  puts comma_quibbling(a)\nend\n", "target": "fun quibble(s):\n    let result = s.join(' and ').replace(|| and ||, \", \", length(s) - 1)\n    return \"{ $result }\"\n\nlet s = [\n    []\n    [\"ABC\"]\n    [\"ABC\", \"DEF\"]\n    [\"ABC\", \"DEF\", \"G\", \"H\"]\n]\n\nfor i in s:\n    print(quibble i)\n"}
{"id": 46144, "name": "Comma quibbling", "source": "Translate Ruby to Python: def comma_quibbling(a)\n  %w<{ }>.join(a.length < 2 ? a.first :\n               \"\nend\n\n[[], %w<ABC>, %w<ABC DEF>, %w<ABC DEF G H>].each do |a|\n  puts comma_quibbling(a)\nend\n", "target": "fun quibble(s):\n    let result = s.join(' and ').replace(|| and ||, \", \", length(s) - 1)\n    return \"{ $result }\"\n\nlet s = [\n    []\n    [\"ABC\"]\n    [\"ABC\", \"DEF\"]\n    [\"ABC\", \"DEF\", \"G\", \"H\"]\n]\n\nfor i in s:\n    print(quibble i)\n"}
{"id": 46631, "name": "Count the coins", "source": "Translate Ruby to C#: def make_change(amount, coins)\n  @cache = Array.new(amount+1){|i| Array.new(coins.size, i.zero? ? 1 : nil)}\n  @coins = coins\n  do_count(amount, @coins.length - 1)\nend\n\ndef do_count(n, m)\n  if n < 0 || m < 0\n    0\n  elsif @cache[n][m]\n    @cache[n][m]\n  else\n    @cache[n][m] = do_count(n-@coins[m], m) + do_count(n, m-1)\n  end\nend\n\np make_change(   1_00, [1,5,10,25])\np make_change(1000_00, [1,5,10,25,50,100])\n", "target": "    \n    class Program\n    {\n        static long Count(int[] C, int m, int n)\n        {\n            var table = new long[n + 1];\n            table[0] = 1;\n            for (int i = 0; i < m; i++)\n                for (int j = C[i]; j <= n; j++)\n                    table[j] += table[j - C[i]];\n            return table[n];\n        }\n        static void Main(string[] args)\n        {\n            var C = new int[] { 1, 5, 10, 25 };\n            int m = C.Length;\n            int n = 100;\n            Console.WriteLine(Count(C, m, n));  \n            Console.ReadLine();\n        }\n    }\n"}
{"id": 46632, "name": "Count the coins", "source": "Translate Ruby to C#: def make_change(amount, coins)\n  @cache = Array.new(amount+1){|i| Array.new(coins.size, i.zero? ? 1 : nil)}\n  @coins = coins\n  do_count(amount, @coins.length - 1)\nend\n\ndef do_count(n, m)\n  if n < 0 || m < 0\n    0\n  elsif @cache[n][m]\n    @cache[n][m]\n  else\n    @cache[n][m] = do_count(n-@coins[m], m) + do_count(n, m-1)\n  end\nend\n\np make_change(   1_00, [1,5,10,25])\np make_change(1000_00, [1,5,10,25,50,100])\n", "target": "    \n    class Program\n    {\n        static long Count(int[] C, int m, int n)\n        {\n            var table = new long[n + 1];\n            table[0] = 1;\n            for (int i = 0; i < m; i++)\n                for (int j = C[i]; j <= n; j++)\n                    table[j] += table[j - C[i]];\n            return table[n];\n        }\n        static void Main(string[] args)\n        {\n            var C = new int[] { 1, 5, 10, 25 };\n            int m = C.Length;\n            int n = 100;\n            Console.WriteLine(Count(C, m, n));  \n            Console.ReadLine();\n        }\n    }\n"}
{"id": 46635, "name": "Count the coins", "source": "Translate Ruby to Java: def make_change(amount, coins)\n  @cache = Array.new(amount+1){|i| Array.new(coins.size, i.zero? ? 1 : nil)}\n  @coins = coins\n  do_count(amount, @coins.length - 1)\nend\n\ndef do_count(n, m)\n  if n < 0 || m < 0\n    0\n  elsif @cache[n][m]\n    @cache[n][m]\n  else\n    @cache[n][m] = do_count(n-@coins[m], m) + do_count(n, m-1)\n  end\nend\n\np make_change(   1_00, [1,5,10,25])\np make_change(1000_00, [1,5,10,25,50,100])\n", "target": "import java.util.Arrays;\nimport java.math.BigInteger;\n\nclass CountTheCoins {\n    private static BigInteger countChanges(int amount, int[] coins){\n        final int n = coins.length;\n        int cycle = 0;\n        for (int c : coins)\n            if (c <= amount && c >= cycle)\n                cycle = c + 1;\n        cycle *= n;\n        BigInteger[] table = new BigInteger[cycle];\n        Arrays.fill(table, 0, n, BigInteger.ONE);\n        Arrays.fill(table, n, cycle, BigInteger.ZERO);\n\n        int pos = n;\n        for (int s = 1; s <= amount; s++) {\n            for (int i = 0; i < n; i++) {\n                if (i == 0 && pos >= cycle)\n                    pos = 0;\n                if (coins[i] <= s) {\n                    final int q = pos - (coins[i] * n);\n                    table[pos] = (q >= 0) ? table[q] : table[q + cycle];\n                }\n                if (i != 0)\n                    table[pos] = table[pos].add(table[pos - 1]);\n                pos++;\n            }\n        }\n\n        return table[pos - 1];\n    }\n\n    public static void main(String[] args) {\n        final int[][] coinsUsEu = {{100, 50, 25, 10, 5, 1},\n                                   {200, 100, 50, 20, 10, 5, 2, 1}};\n\n        for (int[] coins : coinsUsEu) {\n            System.out.println(countChanges(     100,\n                Arrays.copyOfRange(coins, 2, coins.length)));\n            System.out.println(countChanges(  100000, coins));\n            System.out.println(countChanges( 1000000, coins));\n            System.out.println(countChanges(10000000, coins) + \"\\n\");\n        }\n    }\n}\n"}
{"id": 46636, "name": "Count the coins", "source": "Translate Ruby to Java: def make_change(amount, coins)\n  @cache = Array.new(amount+1){|i| Array.new(coins.size, i.zero? ? 1 : nil)}\n  @coins = coins\n  do_count(amount, @coins.length - 1)\nend\n\ndef do_count(n, m)\n  if n < 0 || m < 0\n    0\n  elsif @cache[n][m]\n    @cache[n][m]\n  else\n    @cache[n][m] = do_count(n-@coins[m], m) + do_count(n, m-1)\n  end\nend\n\np make_change(   1_00, [1,5,10,25])\np make_change(1000_00, [1,5,10,25,50,100])\n", "target": "import java.util.Arrays;\nimport java.math.BigInteger;\n\nclass CountTheCoins {\n    private static BigInteger countChanges(int amount, int[] coins){\n        final int n = coins.length;\n        int cycle = 0;\n        for (int c : coins)\n            if (c <= amount && c >= cycle)\n                cycle = c + 1;\n        cycle *= n;\n        BigInteger[] table = new BigInteger[cycle];\n        Arrays.fill(table, 0, n, BigInteger.ONE);\n        Arrays.fill(table, n, cycle, BigInteger.ZERO);\n\n        int pos = n;\n        for (int s = 1; s <= amount; s++) {\n            for (int i = 0; i < n; i++) {\n                if (i == 0 && pos >= cycle)\n                    pos = 0;\n                if (coins[i] <= s) {\n                    final int q = pos - (coins[i] * n);\n                    table[pos] = (q >= 0) ? table[q] : table[q + cycle];\n                }\n                if (i != 0)\n                    table[pos] = table[pos].add(table[pos - 1]);\n                pos++;\n            }\n        }\n\n        return table[pos - 1];\n    }\n\n    public static void main(String[] args) {\n        final int[][] coinsUsEu = {{100, 50, 25, 10, 5, 1},\n                                   {200, 100, 50, 20, 10, 5, 2, 1}};\n\n        for (int[] coins : coinsUsEu) {\n            System.out.println(countChanges(     100,\n                Arrays.copyOfRange(coins, 2, coins.length)));\n            System.out.println(countChanges(  100000, coins));\n            System.out.println(countChanges( 1000000, coins));\n            System.out.println(countChanges(10000000, coins) + \"\\n\");\n        }\n    }\n}\n"}
{"id": 46637, "name": "Count the coins", "source": "Translate Ruby to Python: def make_change(amount, coins)\n  @cache = Array.new(amount+1){|i| Array.new(coins.size, i.zero? ? 1 : nil)}\n  @coins = coins\n  do_count(amount, @coins.length - 1)\nend\n\ndef do_count(n, m)\n  if n < 0 || m < 0\n    0\n  elsif @cache[n][m]\n    @cache[n][m]\n  else\n    @cache[n][m] = do_count(n-@coins[m], m) + do_count(n, m-1)\n  end\nend\n\np make_change(   1_00, [1,5,10,25])\np make_change(1000_00, [1,5,10,25,50,100])\n", "target": "def changes(amount, coins):\n    ways = [0] * (amount + 1)\n    ways[0] = 1\n    for coin in coins:\n        for j in xrange(coin, amount + 1):\n            ways[j] += ways[j - coin]\n    return ways[amount]\n\nprint changes(100, [1, 5, 10, 25])\nprint changes(100000, [1, 5, 10, 25, 50, 100])\n"}
{"id": 46638, "name": "Count the coins", "source": "Translate Ruby to Python: def make_change(amount, coins)\n  @cache = Array.new(amount+1){|i| Array.new(coins.size, i.zero? ? 1 : nil)}\n  @coins = coins\n  do_count(amount, @coins.length - 1)\nend\n\ndef do_count(n, m)\n  if n < 0 || m < 0\n    0\n  elsif @cache[n][m]\n    @cache[n][m]\n  else\n    @cache[n][m] = do_count(n-@coins[m], m) + do_count(n, m-1)\n  end\nend\n\np make_change(   1_00, [1,5,10,25])\np make_change(1000_00, [1,5,10,25,50,100])\n", "target": "def changes(amount, coins):\n    ways = [0] * (amount + 1)\n    ways[0] = 1\n    for coin in coins:\n        for j in xrange(coin, amount + 1):\n            ways[j] += ways[j - coin]\n    return ways[amount]\n\nprint changes(100, [1, 5, 10, 25])\nprint changes(100000, [1, 5, 10, 25, 50, 100])\n"}
{"id": 46865, "name": "First-class functions_Use numbers analogously", "source": "Translate Ruby to C#: multiplier = proc {|n1, n2| proc {|m| n1 * n2 * m}}\nnumlist = [x=2, y=4, x+y]\ninvlist = [0.5, 0.25, 1.0/(x+y)]\np numlist.zip(invlist).map {|n, invn| multiplier[invn, n][0.5]}\n\n", "target": "using System;\nusing System.Linq;\n\nclass Program\n{\n    static void Main(string[] args)\n    {\n        double x, xi, y, yi, z, zi;\n        x = 2.0;\n        xi = 0.5;\n        y = 4.0;\n        yi = 0.25;\n        z = x + y;\n        zi = 1.0 / (x + y);\n\n        var numlist = new[] { x, y, z };\n        var numlisti = new[] { xi, yi, zi };\n        var multiplied = numlist.Zip(numlisti, (n1, n2) =>\n                       {\n                           Func<double, double> multiplier = m => n1 * n2 * m;\n                           return multiplier;\n                       });\n\n        foreach (var multiplier in multiplied)\n            Console.WriteLine(multiplier(0.5));\n    }\n}\n"}
{"id": 46866, "name": "First-class functions_Use numbers analogously", "source": "Translate Ruby to C#: multiplier = proc {|n1, n2| proc {|m| n1 * n2 * m}}\nnumlist = [x=2, y=4, x+y]\ninvlist = [0.5, 0.25, 1.0/(x+y)]\np numlist.zip(invlist).map {|n, invn| multiplier[invn, n][0.5]}\n\n", "target": "using System;\nusing System.Linq;\n\nclass Program\n{\n    static void Main(string[] args)\n    {\n        double x, xi, y, yi, z, zi;\n        x = 2.0;\n        xi = 0.5;\n        y = 4.0;\n        yi = 0.25;\n        z = x + y;\n        zi = 1.0 / (x + y);\n\n        var numlist = new[] { x, y, z };\n        var numlisti = new[] { xi, yi, zi };\n        var multiplied = numlist.Zip(numlisti, (n1, n2) =>\n                       {\n                           Func<double, double> multiplier = m => n1 * n2 * m;\n                           return multiplier;\n                       });\n\n        foreach (var multiplier in multiplied)\n            Console.WriteLine(multiplier(0.5));\n    }\n}\n"}
{"id": 46869, "name": "First-class functions_Use numbers analogously", "source": "Translate Ruby to Python: multiplier = proc {|n1, n2| proc {|m| n1 * n2 * m}}\nnumlist = [x=2, y=4, x+y]\ninvlist = [0.5, 0.25, 1.0/(x+y)]\np numlist.zip(invlist).map {|n, invn| multiplier[invn, n][0.5]}\n\n", "target": "IDLE 2.6.1      \n>>> \n>>> x,xi, y,yi = 2.0,0.5, 4.0,0.25\n>>> \n>>> z  = x + y\n>>> zi = 1.0 / (x + y)\n>>> \n>>> multiplier = lambda n1, n2: (lambda m: n1 * n2 * m)\n>>> \n>>> numlist = [x, y, z]\n>>> numlisti = [xi, yi, zi]\n>>> \n>>> [multiplier(inversen, n)(.5) for n, inversen in zip(numlist, numlisti)]\n[0.5, 0.5, 0.5]\n>>>\n"}
{"id": 46870, "name": "First-class functions_Use numbers analogously", "source": "Translate Ruby to Python: multiplier = proc {|n1, n2| proc {|m| n1 * n2 * m}}\nnumlist = [x=2, y=4, x+y]\ninvlist = [0.5, 0.25, 1.0/(x+y)]\np numlist.zip(invlist).map {|n, invn| multiplier[invn, n][0.5]}\n\n", "target": "IDLE 2.6.1      \n>>> \n>>> x,xi, y,yi = 2.0,0.5, 4.0,0.25\n>>> \n>>> z  = x + y\n>>> zi = 1.0 / (x + y)\n>>> \n>>> multiplier = lambda n1, n2: (lambda m: n1 * n2 * m)\n>>> \n>>> numlist = [x, y, z]\n>>> numlisti = [xi, yi, zi]\n>>> \n>>> [multiplier(inversen, n)(.5) for n, inversen in zip(numlist, numlisti)]\n[0.5, 0.5, 0.5]\n>>>\n"}
{"id": 47122, "name": "Ackermann function", "source": "Translate Ruby to C#: def ack(m, n)\n  if m == 0\n    n + 1\n  elsif n == 0\n    ack(m-1, 1)\n  else\n    ack(m-1, ack(m, n-1))\n  end\nend\n\n\n(0..3).each do |m|\n  puts (0..6).map { |n| ack(m, n) }.join(' ')\nend\n", "target": "using System;\nclass Program\n{\n    public static long Ackermann(long m, long n)\n    {\n        if(m > 0)\n        {\n            if (n > 0)\n                return Ackermann(m - 1, Ackermann(m, n - 1));\n            else if (n == 0)\n                return Ackermann(m - 1, 1);\n        }\n        else if(m == 0)\n        {\n            if(n >= 0) \n                return n + 1;\n        }\n\n        throw new System.ArgumentOutOfRangeException();\n    }\n    \n    static void Main()\n    {\n        for (long m = 0; m <= 3; ++m)\n        {\n            for (long n = 0; n <= 4; ++n)\n            {\n                Console.WriteLine(\"Ackermann({0}, {1}) = {2}\", m, n, Ackermann(m, n));\n            }\n        }\n    }\n}\n"}
{"id": 47124, "name": "Ackermann function", "source": "Translate Ruby to Java: def ack(m, n)\n  if m == 0\n    n + 1\n  elsif n == 0\n    ack(m-1, 1)\n  else\n    ack(m-1, ack(m, n-1))\n  end\nend\n\n\n(0..3).each do |m|\n  puts (0..6).map { |n| ack(m, n) }.join(' ')\nend\n", "target": "import java.math.BigInteger;\n\npublic static BigInteger ack(BigInteger m, BigInteger n) {\n    return m.equals(BigInteger.ZERO)\n            ? n.add(BigInteger.ONE)\n            : ack(m.subtract(BigInteger.ONE),\n                        n.equals(BigInteger.ZERO) ? BigInteger.ONE : ack(m, n.subtract(BigInteger.ONE)));\n}\n"}
{"id": 47125, "name": "Ackermann function", "source": "Translate Ruby to Python: def ack(m, n)\n  if m == 0\n    n + 1\n  elsif n == 0\n    ack(m-1, 1)\n  else\n    ack(m-1, ack(m, n-1))\n  end\nend\n\n\n(0..3).each do |m|\n  puts (0..6).map { |n| ack(m, n) }.join(' ')\nend\n", "target": "from __future__ import print_function\n\ndef setup():\n    for m in range(4):\n        for n in range(7):\n            print(\"{} \".format(ackermann(m, n)), end = \"\")\n        print()\n    \n\ndef ackermann(m, n):\n    if m == 0:\n        return n + 1\n    elif m > 0 and n == 0:\n        return ackermann(m - 1, 1)\n    else:\n        return ackermann(m - 1, ackermann(m, n - 1))\n"}
{"id": 47390, "name": "Enumerations", "source": "Translate Ruby to C#: module Fruits\n  APPLE  = 0\n  BANANA = 1\n  CHERRY = 2\nend\n\n\n\nFRUITS = [:apple, :banana, :cherry]\nval = :banana\nFRUITS.include?(val)      \n", "target": "enum fruits { apple, banana, cherry }\n\nenum fruits { apple = 0, banana = 1, cherry = 2 }\n\nenum fruits : int { apple = 0, banana = 1, cherry = 2 }\n\n[FlagsAttribute]\nenum Colors { Red = 1, Green = 2, Blue = 4, Yellow = 8 }\n"}
{"id": 47392, "name": "Enumerations", "source": "Translate Ruby to Java: module Fruits\n  APPLE  = 0\n  BANANA = 1\n  CHERRY = 2\nend\n\n\n\nFRUITS = [:apple, :banana, :cherry]\nval = :banana\nFRUITS.include?(val)      \n", "target": "enum Fruits{\n   APPLE, BANANA, CHERRY\n}\n"}
{"id": 47393, "name": "Enumerations", "source": "Translate Ruby to Python: module Fruits\n  APPLE  = 0\n  BANANA = 1\n  CHERRY = 2\nend\n\n\n\nFRUITS = [:apple, :banana, :cherry]\nval = :banana\nFRUITS.include?(val)      \n", "target": ">>> from enum import Enum\n>>> Contact = Enum('Contact', 'FIRST_NAME, LAST_NAME, PHONE')\n>>> Contact.__members__\nmappingproxy(OrderedDict([('FIRST_NAME', <Contact.FIRST_NAME: 1>), ('LAST_NAME', <Contact.LAST_NAME: 2>), ('PHONE', <Contact.PHONE: 3>)]))\n>>> \n>>> \n>>> class Contact2(Enum):\n\tFIRST_NAME = 1\n\tLAST_NAME = 2\n\tPHONE = 3\n\n\t\n>>> Contact2.__members__\nmappingproxy(OrderedDict([('FIRST_NAME', <Contact2.FIRST_NAME: 1>), ('LAST_NAME', <Contact2.LAST_NAME: 2>), ('PHONE', <Contact2.PHONE: 3>)]))\n>>>\n"}
{"id": 47766, "name": "Catalan numbers_Pascal's triangle", "source": "Translate Ruby to C#: func catalan(num) {\n  var t = [0, 1]\n  (1..num).map { |i|\n    flip(^i    ).each {|j| t[j+1] += t[j] }\n    t[i+1] = t[i]\n    flip(^i.inc).each {|j| t[j+1] += t[j] }\n    t[i+1] - t[i]\n  }\n}\n\nsay catalan(15).join(' ')\n", "target": "int n = 15;\nList<int> t = new List<int>() { 0, 1 };\nfor (int i = 1; i <= n; i++)\n{\n    for (var j = i; j > 1; j--) t[j] += t[j - 1];\n    t.Add(t[i]);\n    for (var j = i + 1; j > 1; j--) t[j] += t[j - 1];\n    Console.Write(((i == 1) ? \"\" : \", \") + (t[i + 1] - t[i]));\n}\n"}
{"id": 47767, "name": "Catalan numbers_Pascal's triangle", "source": "Translate Ruby to C#: func catalan(num) {\n  var t = [0, 1]\n  (1..num).map { |i|\n    flip(^i    ).each {|j| t[j+1] += t[j] }\n    t[i+1] = t[i]\n    flip(^i.inc).each {|j| t[j+1] += t[j] }\n    t[i+1] - t[i]\n  }\n}\n\nsay catalan(15).join(' ')\n", "target": "int n = 15;\nList<int> t = new List<int>() { 0, 1 };\nfor (int i = 1; i <= n; i++)\n{\n    for (var j = i; j > 1; j--) t[j] += t[j - 1];\n    t.Add(t[i]);\n    for (var j = i + 1; j > 1; j--) t[j] += t[j - 1];\n    Console.Write(((i == 1) ? \"\" : \", \") + (t[i + 1] - t[i]));\n}\n"}
{"id": 47770, "name": "Catalan numbers_Pascal's triangle", "source": "Translate Ruby to Java: func catalan(num) {\n  var t = [0, 1]\n  (1..num).map { |i|\n    flip(^i    ).each {|j| t[j+1] += t[j] }\n    t[i+1] = t[i]\n    flip(^i.inc).each {|j| t[j+1] += t[j] }\n    t[i+1] - t[i]\n  }\n}\n\nsay catalan(15).join(' ')\n", "target": "public class Test {\n    public static void main(String[] args) {\n        int N = 15;\n        int[] t = new int[N + 2];\n        t[1] = 1;\n\n        for (int i = 1; i <= N; i++) {\n\n            for (int j = i; j > 1; j--)\n                t[j] = t[j] + t[j - 1];\n\n            t[i + 1] = t[i];\n\n            for (int j = i + 1; j > 1; j--)\n                t[j] = t[j] + t[j - 1];\n\n            System.out.printf(\"%d \", t[i + 1] - t[i]);\n        }\n    }\n}\n"}
{"id": 47771, "name": "Catalan numbers_Pascal's triangle", "source": "Translate Ruby to Java: func catalan(num) {\n  var t = [0, 1]\n  (1..num).map { |i|\n    flip(^i    ).each {|j| t[j+1] += t[j] }\n    t[i+1] = t[i]\n    flip(^i.inc).each {|j| t[j+1] += t[j] }\n    t[i+1] - t[i]\n  }\n}\n\nsay catalan(15).join(' ')\n", "target": "public class Test {\n    public static void main(String[] args) {\n        int N = 15;\n        int[] t = new int[N + 2];\n        t[1] = 1;\n\n        for (int i = 1; i <= N; i++) {\n\n            for (int j = i; j > 1; j--)\n                t[j] = t[j] + t[j - 1];\n\n            t[i + 1] = t[i];\n\n            for (int j = i + 1; j > 1; j--)\n                t[j] = t[j] + t[j - 1];\n\n            System.out.printf(\"%d \", t[i + 1] - t[i]);\n        }\n    }\n}\n"}
{"id": 47772, "name": "Catalan numbers_Pascal's triangle", "source": "Translate Ruby to Python: func catalan(num) {\n  var t = [0, 1]\n  (1..num).map { |i|\n    flip(^i    ).each {|j| t[j+1] += t[j] }\n    t[i+1] = t[i]\n    flip(^i.inc).each {|j| t[j+1] += t[j] }\n    t[i+1] - t[i]\n  }\n}\n\nsay catalan(15).join(' ')\n", "target": ">>> n = 15\n>>> t = [0] * (n + 2)\n>>> t[1] = 1\n>>> for i in range(1, n + 1):\n\tfor j in range(i, 1, -1): t[j] += t[j - 1]\n\tt[i + 1] = t[i]\n\tfor j in range(i + 1, 1, -1): t[j] += t[j - 1]\n\tprint(t[i+1] - t[i], end=' ')\n\n\t\n1 2 5 14 42 132 429 1430 4862 16796 58786 208012 742900 2674440 9694845 \n>>>\n"}
{"id": 47773, "name": "Catalan numbers_Pascal's triangle", "source": "Translate Ruby to Python: func catalan(num) {\n  var t = [0, 1]\n  (1..num).map { |i|\n    flip(^i    ).each {|j| t[j+1] += t[j] }\n    t[i+1] = t[i]\n    flip(^i.inc).each {|j| t[j+1] += t[j] }\n    t[i+1] - t[i]\n  }\n}\n\nsay catalan(15).join(' ')\n", "target": ">>> n = 15\n>>> t = [0] * (n + 2)\n>>> t[1] = 1\n>>> for i in range(1, n + 1):\n\tfor j in range(i, 1, -1): t[j] += t[j - 1]\n\tt[i + 1] = t[i]\n\tfor j in range(i + 1, 1, -1): t[j] += t[j - 1]\n\tprint(t[i+1] - t[i], end=' ')\n\n\t\n1 2 5 14 42 132 429 1430 4862 16796 58786 208012 742900 2674440 9694845 \n>>>\n"}
{"id": 47934, "name": "Hello world_Text", "source": "Translate Ruby to C#: puts \"Hello world!\"\n", "target": "Using System;\nnamespace HelloWorld {\n  class Program\n  {\n    static void Main()\n    {\n      Console.Writeln(\"Hello World!\");\n    }\n  }\n}\n"}
{"id": 47936, "name": "Hello world_Text", "source": "Translate Ruby to Java: puts \"Hello world!\"\n", "target": "module HelloWorld\n    {\n    void run()\n        {\n        @Inject Console console;\n        console.print(\"Hello World!\");\n        }\n    }\n"}
{"id": 48147, "name": "Hash from two arrays", "source": "Translate Ruby to C#: keys = ('a'..'z').to_a\t\nvals = (1..26).to_a\t\n\nhash = Hash.zip(keys, vals)\np hash\n", "target": "static class Program\n{\n    static void Main()\n    {\n        System.Collections.Hashtable h = new System.Collections.Hashtable();\n\n        string[] keys = { \"foo\", \"bar\", \"val\" };\n        string[] values = { \"little\", \"miss\", \"muffet\" };\n\n        System.Diagnostics.Trace.Assert(keys.Length == values.Length, \"Arrays are not same length.\");\n\n        for (int i = 0; i < keys.Length; i++)\n        {\n            h.Add(keys[i], values[i]);\n        }\n    }\n}\n"}
{"id": 48149, "name": "Hash from two arrays", "source": "Translate Ruby to Java: keys = ('a'..'z').to_a\t\nvals = (1..26).to_a\t\n\nhash = Hash.zip(keys, vals)\np hash\n", "target": "import java.util.HashMap;\npublic static void main(String[] args){\n\tString[] keys= {\"a\", \"b\", \"c\"};\n\tint[] vals= {1, 2, 3};\n\tHashMap<String, Integer> hash= new HashMap<String, Integer>();\n\n\tfor(int i= 0; i < keys.length; i++){\n\t   hash.put(keys[i], vals[i]);\n\t}\n}\n"}
{"id": 48150, "name": "Hash from two arrays", "source": "Translate Ruby to Python: keys = ('a'..'z').to_a\t\nvals = (1..26).to_a\t\n\nhash = Hash.zip(keys, vals)\np hash\n", "target": "keys = ['a', 'b', 'c']\nvalues = [1, 2, 3]\nhash = {key: value for key, value in zip(keys, values)}\n"}
{"id": 48509, "name": "Unbias a random generator", "source": "Translate Ruby to C#: def rand_n(bias)\n  rand(bias) == 0 ? 1 : 0\nend\n\ndef unbiased(bias)\n  a, b = rand_n(bias), rand_n(bias) until a != b \n  a\nend\n\nruns = 1_000_000\nkeys = %i(bias biased unbiased) \nputs keys.join(\"\\t\")\n\n(3..6).each do |bias|\n  counter = Hash.new(0) \n  runs.times do\n    counter[:biased] += 1 if rand_n(bias) == 1 \n    counter[:unbiased] += 1 if unbiased(bias) == 1\n  end\n  counter[:bias] = bias\n  puts counter.values_at(*keys).join(\"\\t\")\nend\n", "target": "using System;\n\nnamespace Unbias\n{\n    internal class Program\n    {\n        private static void Main(string[] args)\n        {\n            \n            for (int n = 3; n <= 6; n++)\n            {\n                int biasedZero = 0, biasedOne = 0, unbiasedZero = 0, unbiasedOne = 0;\n                for (int i = 0; i < 100000; i++)\n                {\n                    if (randN(n))\n                        biasedOne++;\n                    else\n                        biasedZero++;\n                    if (Unbiased(n))\n                        unbiasedOne++;\n                    else\n                        unbiasedZero++;\n                }\n\n                Console.WriteLine(\"(N = {0}):\".PadRight(17) + \"# of 0\\t# of 1\\t% of 0\\t% of 1\", n);\n                Console.WriteLine(\"Biased:\".PadRight(15) + \"{0}\\t{1}\\t{2}\\t{3}\",\n                                  biasedZero, biasedOne,\n                                  biasedZero/1000, biasedOne/1000);\n                Console.WriteLine(\"Unbiased:\".PadRight(15) + \"{0}\\t{1}\\t{2}\\t{3}\",\n                                  unbiasedZero, unbiasedOne,\n                                  unbiasedZero/1000, unbiasedOne/1000);\n            }\n        }\n\n        private static bool Unbiased(int n)\n        {\n            bool flip1, flip2;\n\n            \n\n            do\n            {\n                flip1 = randN(n);\n                flip2 = randN(n);\n            } while (flip1 == flip2);\n\n            return flip1;\n        }\n\n        private static readonly Random random = new Random();\n\n        private static bool randN(int n)\n        {\n            \n            return random.Next(0, n) == 0;\n        }\n    }\n}\n"}
{"id": 48510, "name": "Unbias a random generator", "source": "Translate Ruby to C#: def rand_n(bias)\n  rand(bias) == 0 ? 1 : 0\nend\n\ndef unbiased(bias)\n  a, b = rand_n(bias), rand_n(bias) until a != b \n  a\nend\n\nruns = 1_000_000\nkeys = %i(bias biased unbiased) \nputs keys.join(\"\\t\")\n\n(3..6).each do |bias|\n  counter = Hash.new(0) \n  runs.times do\n    counter[:biased] += 1 if rand_n(bias) == 1 \n    counter[:unbiased] += 1 if unbiased(bias) == 1\n  end\n  counter[:bias] = bias\n  puts counter.values_at(*keys).join(\"\\t\")\nend\n", "target": "using System;\n\nnamespace Unbias\n{\n    internal class Program\n    {\n        private static void Main(string[] args)\n        {\n            \n            for (int n = 3; n <= 6; n++)\n            {\n                int biasedZero = 0, biasedOne = 0, unbiasedZero = 0, unbiasedOne = 0;\n                for (int i = 0; i < 100000; i++)\n                {\n                    if (randN(n))\n                        biasedOne++;\n                    else\n                        biasedZero++;\n                    if (Unbiased(n))\n                        unbiasedOne++;\n                    else\n                        unbiasedZero++;\n                }\n\n                Console.WriteLine(\"(N = {0}):\".PadRight(17) + \"# of 0\\t# of 1\\t% of 0\\t% of 1\", n);\n                Console.WriteLine(\"Biased:\".PadRight(15) + \"{0}\\t{1}\\t{2}\\t{3}\",\n                                  biasedZero, biasedOne,\n                                  biasedZero/1000, biasedOne/1000);\n                Console.WriteLine(\"Unbiased:\".PadRight(15) + \"{0}\\t{1}\\t{2}\\t{3}\",\n                                  unbiasedZero, unbiasedOne,\n                                  unbiasedZero/1000, unbiasedOne/1000);\n            }\n        }\n\n        private static bool Unbiased(int n)\n        {\n            bool flip1, flip2;\n\n            \n\n            do\n            {\n                flip1 = randN(n);\n                flip2 = randN(n);\n            } while (flip1 == flip2);\n\n            return flip1;\n        }\n\n        private static readonly Random random = new Random();\n\n        private static bool randN(int n)\n        {\n            \n            return random.Next(0, n) == 0;\n        }\n    }\n}\n"}
{"id": 48513, "name": "Unbias a random generator", "source": "Translate Ruby to Java: def rand_n(bias)\n  rand(bias) == 0 ? 1 : 0\nend\n\ndef unbiased(bias)\n  a, b = rand_n(bias), rand_n(bias) until a != b \n  a\nend\n\nruns = 1_000_000\nkeys = %i(bias biased unbiased) \nputs keys.join(\"\\t\")\n\n(3..6).each do |bias|\n  counter = Hash.new(0) \n  runs.times do\n    counter[:biased] += 1 if rand_n(bias) == 1 \n    counter[:unbiased] += 1 if unbiased(bias) == 1\n  end\n  counter[:bias] = bias\n  puts counter.values_at(*keys).join(\"\\t\")\nend\n", "target": "public class Bias {\n    public static boolean biased(int n) {\n        return Math.random() < 1.0 / n;\n    }\n\n    public static boolean unbiased(int n) {\n        boolean a, b;\n        do {\n            a = biased(n);\n            b = biased(n);\n        } while (a == b);\n        return a;\n    }\n\n    public static void main(String[] args) {\n        final int M = 50000;\n        for (int n = 3; n < 7; n++) {\n            int c1 = 0, c2 = 0;\n            for (int i = 0; i < M; i++) {\n                c1 += biased(n) ? 1 : 0;\n                c2 += unbiased(n) ? 1 : 0;\n            }\n            System.out.format(\"%d: %2.2f%%  %2.2f%%\\n\",\n                              n, 100.0*c1/M, 100.0*c2/M);\n        }\n    }\n}\n"}
{"id": 48514, "name": "Unbias a random generator", "source": "Translate Ruby to Java: def rand_n(bias)\n  rand(bias) == 0 ? 1 : 0\nend\n\ndef unbiased(bias)\n  a, b = rand_n(bias), rand_n(bias) until a != b \n  a\nend\n\nruns = 1_000_000\nkeys = %i(bias biased unbiased) \nputs keys.join(\"\\t\")\n\n(3..6).each do |bias|\n  counter = Hash.new(0) \n  runs.times do\n    counter[:biased] += 1 if rand_n(bias) == 1 \n    counter[:unbiased] += 1 if unbiased(bias) == 1\n  end\n  counter[:bias] = bias\n  puts counter.values_at(*keys).join(\"\\t\")\nend\n", "target": "public class Bias {\n    public static boolean biased(int n) {\n        return Math.random() < 1.0 / n;\n    }\n\n    public static boolean unbiased(int n) {\n        boolean a, b;\n        do {\n            a = biased(n);\n            b = biased(n);\n        } while (a == b);\n        return a;\n    }\n\n    public static void main(String[] args) {\n        final int M = 50000;\n        for (int n = 3; n < 7; n++) {\n            int c1 = 0, c2 = 0;\n            for (int i = 0; i < M; i++) {\n                c1 += biased(n) ? 1 : 0;\n                c2 += unbiased(n) ? 1 : 0;\n            }\n            System.out.format(\"%d: %2.2f%%  %2.2f%%\\n\",\n                              n, 100.0*c1/M, 100.0*c2/M);\n        }\n    }\n}\n"}
{"id": 48515, "name": "Unbias a random generator", "source": "Translate Ruby to Python: def rand_n(bias)\n  rand(bias) == 0 ? 1 : 0\nend\n\ndef unbiased(bias)\n  a, b = rand_n(bias), rand_n(bias) until a != b \n  a\nend\n\nruns = 1_000_000\nkeys = %i(bias biased unbiased) \nputs keys.join(\"\\t\")\n\n(3..6).each do |bias|\n  counter = Hash.new(0) \n  runs.times do\n    counter[:biased] += 1 if rand_n(bias) == 1 \n    counter[:unbiased] += 1 if unbiased(bias) == 1\n  end\n  counter[:bias] = bias\n  puts counter.values_at(*keys).join(\"\\t\")\nend\n", "target": "from __future__ import print_function\nimport random\n\ndef randN(N):\n    \" 1,0 random generator factory with 1 appearing 1/N'th of the time\"\n    return lambda: random.randrange(N) == 0\n\ndef unbiased(biased):\n    'uses a biased() generator of 1 or 0, to create an unbiased one'\n    this, that = biased(), biased()\n    while this == that: \n        this, that = biased(), biased()\n    return this         \n\nif __name__ == '__main__':\n    from collections import namedtuple\n\n    Stats = namedtuple('Stats', 'count1 count0 percent')\n\n    for N in range(3, 7):\n        biased = randN(N)\n        v = [biased() for x in range(1000000)]\n        v1, v0 = v.count(1), v.count(0)\n        print ( \"Biased(%i)  = %r\" % (N, Stats(v1, v0, 100. * v1/(v1 + v0))) )\n\n        v = [unbiased(biased) for x in range(1000000)]\n        v1, v0 = v.count(1), v.count(0)\n        print ( \"  Unbiased = %r\" % (Stats(v1, v0, 100. * v1/(v1 + v0)), ) )\n"}
{"id": 48516, "name": "Unbias a random generator", "source": "Translate Ruby to Python: def rand_n(bias)\n  rand(bias) == 0 ? 1 : 0\nend\n\ndef unbiased(bias)\n  a, b = rand_n(bias), rand_n(bias) until a != b \n  a\nend\n\nruns = 1_000_000\nkeys = %i(bias biased unbiased) \nputs keys.join(\"\\t\")\n\n(3..6).each do |bias|\n  counter = Hash.new(0) \n  runs.times do\n    counter[:biased] += 1 if rand_n(bias) == 1 \n    counter[:unbiased] += 1 if unbiased(bias) == 1\n  end\n  counter[:bias] = bias\n  puts counter.values_at(*keys).join(\"\\t\")\nend\n", "target": "from __future__ import print_function\nimport random\n\ndef randN(N):\n    \" 1,0 random generator factory with 1 appearing 1/N'th of the time\"\n    return lambda: random.randrange(N) == 0\n\ndef unbiased(biased):\n    'uses a biased() generator of 1 or 0, to create an unbiased one'\n    this, that = biased(), biased()\n    while this == that: \n        this, that = biased(), biased()\n    return this         \n\nif __name__ == '__main__':\n    from collections import namedtuple\n\n    Stats = namedtuple('Stats', 'count1 count0 percent')\n\n    for N in range(3, 7):\n        biased = randN(N)\n        v = [biased() for x in range(1000000)]\n        v1, v0 = v.count(1), v.count(0)\n        print ( \"Biased(%i)  = %r\" % (N, Stats(v1, v0, 100. * v1/(v1 + v0))) )\n\n        v = [unbiased(biased) for x in range(1000000)]\n        v1, v0 = v.count(1), v.count(0)\n        print ( \"  Unbiased = %r\" % (Stats(v1, v0, 100. * v1/(v1 + v0)), ) )\n"}
{"id": 48646, "name": "Zebra puzzle", "source": "Translate Ruby to C#: CONTENT = {House:       [\"\"],\n           Nationality: %i[English Swedish Danish Norwegian German],\n           Colour:      %i[Red Green White Blue Yellow],\n           Pet:         %i[Dog Birds Cats Horse Zebra],\n           Drink:       %i[Tea Coffee Milk Beer Water],\n           Smoke:       %i[PallMall Dunhill BlueMaster Prince Blend]}\n\ndef adjacent?(n, i, g, e)\n  (0..3).any? { |x| (n[x] == i && g[x + 1] == e) || (n[x + 1] == i && g[x] == e) }\nend\n\ndef leftof?(n, i, g, e)\n  (0..3).any? { |x| n[x] == i && g[x + 1] == e }\nend\n\ndef coincident?(n, i, g, e)\n  n.each_index.any? { |x| n[x] == i && g[x] == e }\nend\n\ndef solve_zebra_puzzle\n  CONTENT[:Nationality].each_permutation { |nation|\n    next unless nation.first == :Norwegian \n    CONTENT[:Colour].each_permutation { |colour|\n      next unless leftof?(colour, :Green, colour, :White)      \n      next unless coincident?(nation, :English, colour, :Red)  \n      next unless adjacent?(nation, :Norwegian, colour, :Blue) \n      CONTENT[:Pet].each_permutation { |pet|\n        next unless coincident?(nation, :Swedish, pet, :Dog) \n        CONTENT[:Drink].each_permutation { |drink|\n          next unless drink[2] == :Milk                           \n          next unless coincident?(nation, :Danish, drink, :Tea)   \n          next unless coincident?(colour, :Green, drink, :Coffee) \n          CONTENT[:Smoke].each_permutation { |smoke|\n            next unless coincident?(smoke, :PallMall, pet, :Birds)    \n            next unless coincident?(smoke, :Dunhill, colour, :Yellow) \n            next unless coincident?(smoke, :BlueMaster, drink, :Beer) \n            next unless coincident?(smoke, :Prince, nation, :German)  \n            next unless adjacent?(smoke, :Blend, pet, :Cats)          \n            next unless adjacent?(smoke, :Blend, drink, :Water)       \n            next unless adjacent?(smoke, :Dunhill, pet, :Horse)       \n            print_out(nation, colour, pet, drink, smoke)\n          }\n        }\n      }\n    }\n  }\nend\n\ndef print_out(nation, colour, pet, drink, smoke)\n  width = CONTENT.map { |k, v| {k.to_s.size, v.max_of { |y| y.to_s.size }}.max }\n  fmt = width.map { |w| \"%-\n  national = nation[pet.index(:Zebra).not_nil!]\n  puts \"The Zebra is owned by the man who is \n  puts fmt % CONTENT.keys, fmt % width.map { |w| \"-\" * w }\n  [nation, colour, pet, drink, smoke].transpose.each.with_index(1) { |x, n| puts fmt % ([n] + x) }\nend\n\nsolve_zebra_puzzle\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing static System.Console;\n\npublic enum Colour { Red, Green, White, Yellow, Blue }\npublic enum Nationality { Englishman, Swede, Dane, Norwegian,German }\npublic enum Pet { Dog, Birds, Cats, Horse, Zebra }\npublic enum Drink { Coffee, Tea, Milk, Beer, Water }\npublic enum Smoke { PallMall, Dunhill, Blend, BlueMaster, Prince}\n\npublic static class ZebraPuzzle\n{\n    private static (Colour[] colours, Drink[] drinks, Smoke[] smokes, Pet[] pets, Nationality[] nations) _solved;\n\n    static ZebraPuzzle()\n    {\n        var solve = from colours in Permute<Colour>()  \n                    where (colours,Colour.White).IsRightOf(colours, Colour.Green) \n                    from nations in Permute<Nationality>()\n                    where nations[0] == Nationality.Norwegian \n                    where (nations, Nationality.Englishman).IsSameIndex(colours, Colour.Red) \n                    where (nations,Nationality.Norwegian).IsNextTo(colours,Colour.Blue) \n                    from drinks in Permute<Drink>()\n                    where drinks[2] == Drink.Milk \n                    where (drinks, Drink.Coffee).IsSameIndex(colours, Colour.Green) \n                    where (drinks, Drink.Tea).IsSameIndex(nations, Nationality.Dane) \n                    from pets in Permute<Pet>()\n                    where (pets, Pet.Dog).IsSameIndex(nations, Nationality.Swede) \n                    from smokes in Permute<Smoke>()\n                    where (smokes, Smoke.PallMall).IsSameIndex(pets, Pet.Birds) \n                    where (smokes, Smoke.Dunhill).IsSameIndex(colours, Colour.Yellow) \n                    where (smokes, Smoke.Blend).IsNextTo(pets, Pet.Cats) \n                    where (smokes, Smoke.Dunhill).IsNextTo(pets, Pet.Horse) \n                    where (smokes, Smoke.BlueMaster).IsSameIndex(drinks, Drink.Beer) \n                    where (smokes, Smoke.Prince).IsSameIndex(nations, Nationality.German) \n                    where (drinks,Drink.Water).IsNextTo(smokes,Smoke.Blend) \n                    select (colours, drinks, smokes, pets, nations);\n\n        _solved = solve.First();\n    }\n    \n    private static int IndexOf<T>(this T[] arr, T obj) => Array.IndexOf(arr, obj);\n\n    private static bool IsRightOf<T, U>(this (T[] a, T v) right, U[] a, U v) => right.a.IndexOf(right.v) == a.IndexOf(v) + 1;\n\n    private static bool IsSameIndex<T, U>(this (T[] a, T v)x, U[] a, U v) => x.a.IndexOf(x.v) == a.IndexOf(v);\n\n    private static bool IsNextTo<T, U>(this (T[] a, T v)x, U[] a,  U v) => (x.a,x.v).IsRightOf(a, v) || (a,v).IsRightOf(x.a,x.v);\n\n    \n    public static IEnumerable<IEnumerable<T>> Permutations<T>(this IEnumerable<T> values)\n    {\n        if (values.Count() == 1)\n            return values.ToSingleton();\n\n        return values.SelectMany(v => Permutations(values.Except(v.ToSingleton())),(v, p) => p.Prepend(v));\n    }\n\n    public static IEnumerable<T[]> Permute<T>() => ToEnumerable<T>().Permutations().Select(p=>p.ToArray());\n\n    private static IEnumerable<T> ToSingleton<T>(this T item){ yield return item; }\n\n    private static IEnumerable<T> ToEnumerable<T>() => Enum.GetValues(typeof(T)).Cast<T>();\n\n    public static new String ToString()\n    {\n        var sb = new StringBuilder();\n        sb.AppendLine(\"House Colour Drink    Nationality Smokes     Pet\");\n        sb.AppendLine(\"\u2500\u2500\u2500\u2500\u2500 \u2500\u2500\u2500\u2500\u2500\u2500 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2500\u2500\u2500\u2500\u2500\");\n        var (colours, drinks, smokes, pets, nations) = _solved;\n        for (var i = 0; i < 5; i++)\n            sb.AppendLine($\"{i+1,5} {colours[i],-6} {drinks[i],-8} {nations[i],-11} {smokes[i],-10} {pets[i],-10}\");\n        return sb.ToString();\n    }\n\n    public static void Main(string[] arguments)\n    {\n        var owner = _solved.nations[_solved.pets.IndexOf(Pet.Zebra)];\n        WriteLine($\"The zebra owner is {owner}\");\n        Write(ToString());\n        Read();\n    }\n}\n"}
{"id": 48648, "name": "Zebra puzzle", "source": "Translate Ruby to Python: CONTENT = {House:       [\"\"],\n           Nationality: %i[English Swedish Danish Norwegian German],\n           Colour:      %i[Red Green White Blue Yellow],\n           Pet:         %i[Dog Birds Cats Horse Zebra],\n           Drink:       %i[Tea Coffee Milk Beer Water],\n           Smoke:       %i[PallMall Dunhill BlueMaster Prince Blend]}\n\ndef adjacent?(n, i, g, e)\n  (0..3).any? { |x| (n[x] == i && g[x + 1] == e) || (n[x + 1] == i && g[x] == e) }\nend\n\ndef leftof?(n, i, g, e)\n  (0..3).any? { |x| n[x] == i && g[x + 1] == e }\nend\n\ndef coincident?(n, i, g, e)\n  n.each_index.any? { |x| n[x] == i && g[x] == e }\nend\n\ndef solve_zebra_puzzle\n  CONTENT[:Nationality].each_permutation { |nation|\n    next unless nation.first == :Norwegian \n    CONTENT[:Colour].each_permutation { |colour|\n      next unless leftof?(colour, :Green, colour, :White)      \n      next unless coincident?(nation, :English, colour, :Red)  \n      next unless adjacent?(nation, :Norwegian, colour, :Blue) \n      CONTENT[:Pet].each_permutation { |pet|\n        next unless coincident?(nation, :Swedish, pet, :Dog) \n        CONTENT[:Drink].each_permutation { |drink|\n          next unless drink[2] == :Milk                           \n          next unless coincident?(nation, :Danish, drink, :Tea)   \n          next unless coincident?(colour, :Green, drink, :Coffee) \n          CONTENT[:Smoke].each_permutation { |smoke|\n            next unless coincident?(smoke, :PallMall, pet, :Birds)    \n            next unless coincident?(smoke, :Dunhill, colour, :Yellow) \n            next unless coincident?(smoke, :BlueMaster, drink, :Beer) \n            next unless coincident?(smoke, :Prince, nation, :German)  \n            next unless adjacent?(smoke, :Blend, pet, :Cats)          \n            next unless adjacent?(smoke, :Blend, drink, :Water)       \n            next unless adjacent?(smoke, :Dunhill, pet, :Horse)       \n            print_out(nation, colour, pet, drink, smoke)\n          }\n        }\n      }\n    }\n  }\nend\n\ndef print_out(nation, colour, pet, drink, smoke)\n  width = CONTENT.map { |k, v| {k.to_s.size, v.max_of { |y| y.to_s.size }}.max }\n  fmt = width.map { |w| \"%-\n  national = nation[pet.index(:Zebra).not_nil!]\n  puts \"The Zebra is owned by the man who is \n  puts fmt % CONTENT.keys, fmt % width.map { |w| \"-\" * w }\n  [nation, colour, pet, drink, smoke].transpose.each.with_index(1) { |x, n| puts fmt % ([n] + x) }\nend\n\nsolve_zebra_puzzle\n", "target": "from logpy import *\nfrom logpy.core import lall\nimport time\n\ndef lefto(q, p, list):\n\t\n\t\n\t\n\treturn membero((q,p), zip(list, list[1:]))\n\ndef nexto(q, p, list):\n\t\n\t\n\t\n\treturn conde([lefto(q, p, list)], [lefto(p, q, list)])\n\nhouses = var()\n\nzebraRules = lall(\n\t\n\t(eq, \t\t(var(), var(), var(), var(), var()), houses),\n\t\n\t(membero,\t('Englishman', var(), var(), var(), 'red'), houses),\n\t\n\t(membero,\t('Swede', var(), var(), 'dog', var()), houses),\n\t\n\t(membero,\t('Dane', var(), 'tea', var(), var()), houses),\n\t\n\t(lefto,\t\t(var(), var(), var(), var(), 'green'),\n\t\t\t\t(var(), var(), var(), var(), 'white'), houses),\n\t\n\t(membero,\t(var(), var(), 'coffee', var(), 'green'), houses),\n\t\n\t(membero,\t(var(), 'Pall Mall', var(), 'birds', var()), houses),\n\t\n\t(membero,\t(var(), 'Dunhill', var(), var(), 'yellow'), houses),\n\t\n\t(eq,\t\t(var(), var(), (var(), var(), 'milk', var(), var()), var(), var()), houses),\n\t\n\t(eq,\t\t(('Norwegian', var(), var(), var(), var()), var(), var(), var(), var()), houses),\n\t\n\t(nexto,\t\t(var(), 'Blend', var(), var(), var()),\n\t\t\t\t(var(), var(), var(), 'cats', var()), houses),\n\t\n\t(nexto,\t\t(var(), 'Dunhill', var(), var(), var()),\n\t\t\t\t(var(), var(), var(), 'horse', var()), houses),\n\t\n\t(membero,\t(var(), 'Blue Master', 'beer', var(), var()), houses),\n\t\n\t(membero,\t('German', 'Prince', var(), var(), var()), houses),\n\t\n\t(nexto,\t\t('Norwegian', var(), var(), var(), var()),\n\t\t\t\t(var(), var(), var(), var(), 'blue'), houses),\n\t\n\t(nexto,\t\t(var(), 'Blend', var(), var(), var()),\n\t\t\t\t(var(), var(), 'water', var(), var()), houses),\n\t\n\t(membero,\t(var(), var(), var(), 'zebra', var()), houses)\n)\n\nt0 = time.time()\nsolutions = run(0, houses, zebraRules)\nt1 = time.time()\ndur = t1-t0\n\ncount = len(solutions)\nzebraOwner = [house for house in solutions[0] if 'zebra' in house][0][0]\n\nprint \"%i solutions in %.2f seconds\" % (count, dur)\nprint \"The %s is the owner of the zebra\" % zebraOwner\nprint \"Here are all the houses:\"\nfor line in solutions[0]:\n\tprint str(line)\n"}
{"id": 49068, "name": "Digital root", "source": "Translate Ruby to C#: def digital_root(n : Int, base = 10) : Int\n  max_single_digit = base - 1\n  n = n.abs\n  if n > max_single_digit\n    n = 1 + (n - 1) % max_single_digit\n  end\n  n\nend\n\nputs digital_root 627615\nputs digital_root 39390\nputs digital_root 588225\nputs digital_root 7, base: 3\n", "target": "using System;\nusing System.Linq;\n\nclass Program\n{\n    static Tuple<int, int> DigitalRoot(long num)\n    {\n        int additivepersistence = 0;\n        while (num > 9)\n        {\n            num = num.ToString().ToCharArray().Sum(x => x - '0');\n            additivepersistence++;\n        }\n        return new Tuple<int, int>(additivepersistence, (int)num);\n    }\n    static void Main(string[] args)\n    {\n        foreach (long num in new long[] { 627615, 39390, 588225, 393900588225 })\n        {\n            var t = DigitalRoot(num);\n            Console.WriteLine(\"{0} has additive persistence {1} and digital root {2}\", num, t.Item1, t.Item2);\n        }\n    }\n}\n"}
{"id": 49069, "name": "Digital root", "source": "Translate Ruby to C#: def digital_root(n : Int, base = 10) : Int\n  max_single_digit = base - 1\n  n = n.abs\n  if n > max_single_digit\n    n = 1 + (n - 1) % max_single_digit\n  end\n  n\nend\n\nputs digital_root 627615\nputs digital_root 39390\nputs digital_root 588225\nputs digital_root 7, base: 3\n", "target": "using System;\nusing System.Linq;\n\nclass Program\n{\n    static Tuple<int, int> DigitalRoot(long num)\n    {\n        int additivepersistence = 0;\n        while (num > 9)\n        {\n            num = num.ToString().ToCharArray().Sum(x => x - '0');\n            additivepersistence++;\n        }\n        return new Tuple<int, int>(additivepersistence, (int)num);\n    }\n    static void Main(string[] args)\n    {\n        foreach (long num in new long[] { 627615, 39390, 588225, 393900588225 })\n        {\n            var t = DigitalRoot(num);\n            Console.WriteLine(\"{0} has additive persistence {1} and digital root {2}\", num, t.Item1, t.Item2);\n        }\n    }\n}\n"}
{"id": 49072, "name": "Digital root", "source": "Translate Ruby to Java: def digital_root(n : Int, base = 10) : Int\n  max_single_digit = base - 1\n  n = n.abs\n  if n > max_single_digit\n    n = 1 + (n - 1) % max_single_digit\n  end\n  n\nend\n\nputs digital_root 627615\nputs digital_root 39390\nputs digital_root 588225\nputs digital_root 7, base: 3\n", "target": "import java.math.BigInteger;\n\nclass DigitalRoot\n{\n  public static int[] calcDigitalRoot(String number, int base)\n  {\n    BigInteger bi = new BigInteger(number, base);\n    int additivePersistence = 0;\n    if (bi.signum() < 0)\n      bi = bi.negate();\n    BigInteger biBase = BigInteger.valueOf(base);\n    while (bi.compareTo(biBase) >= 0)\n    {\n      number = bi.toString(base);\n      bi = BigInteger.ZERO;\n      for (int i = 0; i < number.length(); i++)\n        bi = bi.add(new BigInteger(number.substring(i, i + 1), base));\n      additivePersistence++;\n    }\n    return new int[] { additivePersistence, bi.intValue() };\n  }\n\n  public static void main(String[] args)\n  {\n    for (String arg : args)\n    {\n      int[] results = calcDigitalRoot(arg, 10);\n      System.out.println(arg + \" has additive persistence \" + results[0] + \" and digital root of \" + results[1]);\n    }\n  }\n}\n"}
{"id": 49073, "name": "Digital root", "source": "Translate Ruby to Java: def digital_root(n : Int, base = 10) : Int\n  max_single_digit = base - 1\n  n = n.abs\n  if n > max_single_digit\n    n = 1 + (n - 1) % max_single_digit\n  end\n  n\nend\n\nputs digital_root 627615\nputs digital_root 39390\nputs digital_root 588225\nputs digital_root 7, base: 3\n", "target": "import java.math.BigInteger;\n\nclass DigitalRoot\n{\n  public static int[] calcDigitalRoot(String number, int base)\n  {\n    BigInteger bi = new BigInteger(number, base);\n    int additivePersistence = 0;\n    if (bi.signum() < 0)\n      bi = bi.negate();\n    BigInteger biBase = BigInteger.valueOf(base);\n    while (bi.compareTo(biBase) >= 0)\n    {\n      number = bi.toString(base);\n      bi = BigInteger.ZERO;\n      for (int i = 0; i < number.length(); i++)\n        bi = bi.add(new BigInteger(number.substring(i, i + 1), base));\n      additivePersistence++;\n    }\n    return new int[] { additivePersistence, bi.intValue() };\n  }\n\n  public static void main(String[] args)\n  {\n    for (String arg : args)\n    {\n      int[] results = calcDigitalRoot(arg, 10);\n      System.out.println(arg + \" has additive persistence \" + results[0] + \" and digital root of \" + results[1]);\n    }\n  }\n}\n"}
{"id": 49074, "name": "Digital root", "source": "Translate Ruby to Python: def digital_root(n : Int, base = 10) : Int\n  max_single_digit = base - 1\n  n = n.abs\n  if n > max_single_digit\n    n = 1 + (n - 1) % max_single_digit\n  end\n  n\nend\n\nputs digital_root 627615\nputs digital_root 39390\nputs digital_root 588225\nputs digital_root 7, base: 3\n", "target": "def digital_root (n):\n    ap = 0\n    n = abs(int(n))\n    while n >= 10:\n        n = sum(int(digit) for digit in str(n))\n        ap += 1\n    return ap, n\n\nif __name__ == '__main__':\n    for n in [627615, 39390, 588225, 393900588225, 55]:\n        persistance, root = digital_root(n)\n        print(\"%12i has additive persistance %2i and digital root %i.\" \n              % (n, persistance, root))\n"}
{"id": 49075, "name": "Digital root", "source": "Translate Ruby to Python: def digital_root(n : Int, base = 10) : Int\n  max_single_digit = base - 1\n  n = n.abs\n  if n > max_single_digit\n    n = 1 + (n - 1) % max_single_digit\n  end\n  n\nend\n\nputs digital_root 627615\nputs digital_root 39390\nputs digital_root 588225\nputs digital_root 7, base: 3\n", "target": "def digital_root (n):\n    ap = 0\n    n = abs(int(n))\n    while n >= 10:\n        n = sum(int(digit) for digit in str(n))\n        ap += 1\n    return ap, n\n\nif __name__ == '__main__':\n    for n in [627615, 39390, 588225, 393900588225, 55]:\n        persistance, root = digital_root(n)\n        print(\"%12i has additive persistance %2i and digital root %i.\" \n              % (n, persistance, root))\n"}
{"id": 49404, "name": "Loops_Continue", "source": "Translate Ruby to C#: for i in 1..10 do\n   print i\n   if i % 5 == 0 then\n      puts\n      next\n   end\n   print ', '\nend\n", "target": "using System;\n\nclass Program {\n    static void Main(string[] args) {\n        for (int i = 1; i <= 10; i++) {\n            Console.Write(i);\n\n            if (i % 5 == 0) {\n                Console.WriteLine();\n                continue;\n            }\n\n            Console.Write(\", \");\n        }\n    }\n}\n"}
{"id": 49406, "name": "Loops_Continue", "source": "Translate Ruby to Java: for i in 1..10 do\n   print i\n   if i % 5 == 0 then\n      puts\n      next\n   end\n   print ', '\nend\n", "target": "for(int i = 1;i <= 10; i++){\n   System.out.print(i);\n   if(i % 5 == 0){\n      System.out.println();\n      continue;\n   }\n   System.out.print(\", \");\n}\n"}
{"id": 49407, "name": "Loops_Continue", "source": "Translate Ruby to Python: for i in 1..10 do\n   print i\n   if i % 5 == 0 then\n      puts\n      next\n   end\n   print ', '\nend\n", "target": "for i in range(1, 11):\n    if i % 5 == 0:\n        print(i)\n        continue\n    print(i, end=', ')\n"}
{"id": 49690, "name": "Filter", "source": "Translate Ruby to C#: \nary = [1, 2, 3, 4, 5, 6]\neven_ary = ary.select {|elem| elem.even?}\np even_ary \n\n\nrange = 1..6\neven_ary = range.select {|elem| elem.even?}\np even_ary \n", "target": "ArrayList array = new ArrayList( new int[] { 1, 2, 3, 4, 5 } );\nArrayList evens = new ArrayList();\nforeach( int i in array )\n{\n        if( (i%2) == 0 )\n                evens.Add( i );\n}\nforeach( int i in evens )\n       System.Console.WriteLine( i.ToString() );\n"}
{"id": 49692, "name": "Filter", "source": "Translate Ruby to Java: \nary = [1, 2, 3, 4, 5, 6]\neven_ary = ary.select {|elem| elem.even?}\np even_ary \n\n\nrange = 1..6\neven_ary = range.select {|elem| elem.even?}\np even_ary \n", "target": "int[] array = {1, 2, 3, 4, 5 };\nList<Integer> evensList = new ArrayList<Integer>();\nfor (int  i: array) {\n    if (i % 2 == 0) evensList.add(i);\n}\nint[] evens = evensList.toArray(new int[0]);\n"}
{"id": 49693, "name": "Filter", "source": "Translate Ruby to Python: \nary = [1, 2, 3, 4, 5, 6]\neven_ary = ary.select {|elem| elem.even?}\np even_ary \n\n\nrange = 1..6\neven_ary = range.select {|elem| elem.even?}\np even_ary \n", "target": "values = range(10)\nevens = [x for x in values if not x & 1]\nievens = (x for x in values if not x & 1) \n\nevens = filter(lambda x: not x & 1, values)\n"}
{"id": 49906, "name": "Ludic numbers", "source": "Translate Ruby to C#: def ludic(nmax=100000)\n  Enumerator.new do |y|\n    y << 1\n    ary = *2..nmax\n    until ary.empty?\n      y << (n = ary.first)\n      (0...ary.size).step(n){|i| ary[i] = nil}\n      ary.compact!\n    end\n  end\nend\n\nputs \"First 25 Ludic numbers:\", ludic.first(25).to_s\n\nputs \"Ludics below 1000:\", ludic(1000).count\n\nputs \"Ludic numbers 2000 to 2005:\", ludic.first(2005).last(6).to_s\n\nludics = ludic(250).to_a\nputs \"Ludic triples below 250:\",\n     ludics.select{|x| ludics.include?(x+2) and ludics.include?(x+6)}.map{|x| [x, x+2, x+6]}.to_s\n", "target": "using System;\nusing System.Linq;\nusing System.Collections.Generic;\n\npublic class Program\n{\n    public static void Main()\n    {\n        Console.WriteLine(\"First 25 ludic numbers:\");\n        Console.WriteLine(string.Join(\", \", LudicNumbers(150).Take(25)));\n        Console.WriteLine();\n        \n        Console.WriteLine($\"There are {LudicNumbers(1001).Count()} ludic numbers below 1000\");\n        Console.WriteLine();\n        \n        foreach (var ludic in LudicNumbers(22000).Skip(1999).Take(6)\n                .Select((n, i) => $\"#{i+2000} = {n}\")) {\n            Console.WriteLine(ludic);\n        }\n        Console.WriteLine();\n        \n        Console.WriteLine(\"Triplets below 250:\");\n        var queue = new Queue<int>(5);\n        foreach (int x in LudicNumbers(255)) {\n            if (queue.Count == 5) queue.Dequeue();\n            queue.Enqueue(x);\n            if (x - 6 < 250 && queue.Contains(x - 6) && queue.Contains(x - 4)) {\n                Console.WriteLine($\"{x-6}, {x-4}, {x}\");\n            }\n        }\n    }\n    \n    public static IEnumerable<int> LudicNumbers(int limit) {\n        yield return 1;\n        \n        \n        \n        Entry[] values = Enumerable.Range(0, limit + 1).Select(n => new Entry(n)).ToArray();\n        for (int i = 2; i < limit; i = values[i].Next) {\n            yield return values[i].N;\n            int start = i;\n            while (start < limit) {\n                Unlink(values, start);\n                for (int step = 0; step < i && start < limit; step++)\n                    start = values[start].Next;\n            }\n        }\n    }\n    \n    static void Unlink(Entry[] values, int index) {\n        values[values[index].Prev].Next = values[index].Next;\n        values[values[index].Next].Prev = values[index].Prev;\n    }\n    \n}\n\nstruct Entry\n{\n    public Entry(int n) : this() {\n        N = n;\n        Prev = n - 1;\n        Next = n + 1;\n    }\n    \n    public int N { get; }\n    public int Prev { get; set; }\n    public int Next { get; set; }\n}\n"}
{"id": 49908, "name": "Ludic numbers", "source": "Translate Ruby to Python: def ludic(nmax=100000)\n  Enumerator.new do |y|\n    y << 1\n    ary = *2..nmax\n    until ary.empty?\n      y << (n = ary.first)\n      (0...ary.size).step(n){|i| ary[i] = nil}\n      ary.compact!\n    end\n  end\nend\n\nputs \"First 25 Ludic numbers:\", ludic.first(25).to_s\n\nputs \"Ludics below 1000:\", ludic(1000).count\n\nputs \"Ludic numbers 2000 to 2005:\", ludic.first(2005).last(6).to_s\n\nludics = ludic(250).to_a\nputs \"Ludic triples below 250:\",\n     ludics.select{|x| ludics.include?(x+2) and ludics.include?(x+6)}.map{|x| [x, x+2, x+6]}.to_s\n", "target": "def ludic(nmax=100000):\n    yield 1\n    lst = list(range(2, nmax + 1))\n    while lst:\n        yield lst[0]\n        del lst[::lst[0]]\n\nludics = [l for l in ludic()]\n\nprint('First 25 ludic primes:')\nprint(ludics[:25])\nprint(\"\\nThere are %i ludic numbers <= 1000\"\n      % sum(1 for l in ludics if l <= 1000)) \nprint(\"\\n2000'th..2005'th ludic primes:\")\nprint(ludics[2000-1: 2005])\n\nn = 250\ntriplets = [(x, x+2, x+6)\n            for x in ludics\n            if x+6 < n and x+2 in ludics and x+6 in ludics]\nprint('\\nThere are %i triplets less than %i:\\n  %r'\n      % (len(triplets), n, triplets))\n"}
{"id": 50148, "name": "Sieve of Eratosthenes", "source": "Translate Ruby to C#: \n\nrequire \"bit_array\"\n\nalias Prime = UInt64\n\nclass SoE\n  include Iterator(Prime)\n  @bits : BitArray; @bitndx : Int32 = 2\n\n  def initialize(range : Prime)\n    if range < 2\n      @bits = BitArray.new 0\n    else\n      @bits = BitArray.new((range + 1).to_i32)\n    end\n    ba = @bits; ndx = 2\n    while true\n      wi = ndx * ndx\n      break if wi >= ba.size\n      if ba[ndx]\n        ndx += 1; next\n      end\n      while wi < ba.size\n        ba[wi] = true; wi += ndx\n      end\n      ndx += 1\n    end\n  end\n\n  def next\n    while @bitndx < @bits.size\n      if @bits[@bitndx]\n        @bitndx += 1; next\n      end\n      rslt = @bitndx.to_u64; @bitndx += 1; return rslt\n    end\n    stop\n  end\nend\n\nprint \"Primes up to a hundred:  \"\nSoE.new(100).each { |p| print \" \", p }; puts\nprint \"Number of primes to a million:  \"\nputs SoE.new(1_000_000).each.size\nprint \"Number of primes to a billion:  \"\nstart_time = Time.monotonic\nprint SoE.new(1_000_000_000).each.size\nelpsd = (Time.monotonic - start_time).total_milliseconds\nputs \" in \n", "target": "using System;\nusing System.Collections;\nusing System.Collections.Generic;\n\nnamespace SieveOfEratosthenes\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            int maxprime = int.Parse(args[0]);\n            var primelist = GetAllPrimesLessThan(maxprime);\n            foreach (int prime in primelist)\n            {\n                Console.WriteLine(prime);\n            }\n            Console.WriteLine(\"Count = \" + primelist.Count);\n            Console.ReadLine();\n        }\n\n        private static List<int> GetAllPrimesLessThan(int maxPrime)\n        {\n            var primes = new List<int>();\n            var maxSquareRoot = (int)Math.Sqrt(maxPrime);\n            var eliminated = new BitArray(maxPrime + 1);\n\n            for (int i = 2; i <= maxPrime; ++i)\n            {\n                if (!eliminated[i])\n                {\n                    primes.Add(i);\n                    if (i <= maxSquareRoot)\n                    {\n                        for (int j = i * i; j <= maxPrime; j += i)\n                        {\n                            eliminated[j] = true;\n                        }\n                    }\n                }\n            }\n            return primes;\n        }\n    }\n}\n"}
{"id": 50150, "name": "Sieve of Eratosthenes", "source": "Translate Ruby to Java: \n\nrequire \"bit_array\"\n\nalias Prime = UInt64\n\nclass SoE\n  include Iterator(Prime)\n  @bits : BitArray; @bitndx : Int32 = 2\n\n  def initialize(range : Prime)\n    if range < 2\n      @bits = BitArray.new 0\n    else\n      @bits = BitArray.new((range + 1).to_i32)\n    end\n    ba = @bits; ndx = 2\n    while true\n      wi = ndx * ndx\n      break if wi >= ba.size\n      if ba[ndx]\n        ndx += 1; next\n      end\n      while wi < ba.size\n        ba[wi] = true; wi += ndx\n      end\n      ndx += 1\n    end\n  end\n\n  def next\n    while @bitndx < @bits.size\n      if @bits[@bitndx]\n        @bitndx += 1; next\n      end\n      rslt = @bitndx.to_u64; @bitndx += 1; return rslt\n    end\n    stop\n  end\nend\n\nprint \"Primes up to a hundred:  \"\nSoE.new(100).each { |p| print \" \", p }; puts\nprint \"Number of primes to a million:  \"\nputs SoE.new(1_000_000).each.size\nprint \"Number of primes to a billion:  \"\nstart_time = Time.monotonic\nprint SoE.new(1_000_000_000).each.size\nelpsd = (Time.monotonic - start_time).total_milliseconds\nputs \" in \n", "target": "import java.util.LinkedList;\n\npublic class Sieve{\n       public static LinkedList<Integer> sieve(int n){\n               if(n < 2) return new LinkedList<Integer>();\n               LinkedList<Integer> primes = new LinkedList<Integer>();\n               LinkedList<Integer> nums = new LinkedList<Integer>();\n\n               for(int i = 2;i <= n;i++){ \n                       nums.add(i);\n               }\n\n               while(nums.size() > 0){\n                       int nextPrime = nums.remove();\n                       for(int i = nextPrime * nextPrime;i <= n;i += nextPrime){\n                               nums.removeFirstOccurrence(i);\n                       }\n                       primes.add(nextPrime);\n               }\n               return primes;\n       }\n}\n"}
{"id": 50151, "name": "Sieve of Eratosthenes", "source": "Translate Ruby to Python: \n\nrequire \"bit_array\"\n\nalias Prime = UInt64\n\nclass SoE\n  include Iterator(Prime)\n  @bits : BitArray; @bitndx : Int32 = 2\n\n  def initialize(range : Prime)\n    if range < 2\n      @bits = BitArray.new 0\n    else\n      @bits = BitArray.new((range + 1).to_i32)\n    end\n    ba = @bits; ndx = 2\n    while true\n      wi = ndx * ndx\n      break if wi >= ba.size\n      if ba[ndx]\n        ndx += 1; next\n      end\n      while wi < ba.size\n        ba[wi] = true; wi += ndx\n      end\n      ndx += 1\n    end\n  end\n\n  def next\n    while @bitndx < @bits.size\n      if @bits[@bitndx]\n        @bitndx += 1; next\n      end\n      rslt = @bitndx.to_u64; @bitndx += 1; return rslt\n    end\n    stop\n  end\nend\n\nprint \"Primes up to a hundred:  \"\nSoE.new(100).each { |p| print \" \", p }; puts\nprint \"Number of primes to a million:  \"\nputs SoE.new(1_000_000).each.size\nprint \"Number of primes to a billion:  \"\nstart_time = Time.monotonic\nprint SoE.new(1_000_000_000).each.size\nelpsd = (Time.monotonic - start_time).total_milliseconds\nputs \" in \n", "target": "from __future__ import print_function\n\ni = 2\n\ndef setup():\n    size(1000, 1000)\n    \n    global maxx, maxy, max_num, sieve\n    maxx = width\n    maxy = height\n    max_num = width * height\n    sieve = [False] * (max_num + 1)\n\n    sieve[1] = False\n    plot(0, False)\n    plot(1, False)\n    for i in range(2, max_num + 1):\n        sieve[i] = True\n        plot(i, True)\n\n\ndef draw():\n    global i\n    if not sieve[i]:\n        while (i * i < max_num and not sieve[i]):\n            i += 1\n\n    if sieve[i]:\n        print(\"{} \".format(i), end = '')\n        for j in range(i * i, max_num + 1, i):\n            if sieve[j]:\n                sieve[j] = False\n                plot(j, False)\n\n    if i * i < max_num:\n        i += 1\n    else:\n        noLoop()\n        println(\"finished\")\n\n\ndef plot(pos, active):\n    set(pos % maxx, pos / maxx, color(0) if active else color(255))\n"}
{"id": 50350, "name": "Image noise", "source": "Translate Ruby to C#: require 'rubygems'\nrequire 'gl'\nrequire 'glut'\n\nW, H = 320, 240\nSIZE = W * H\n\nGlut.glutInit ARGV\nGlut.glutInitWindowSize W, H\n\nGlut.glutIdleFunc lambda {\n  i = Time.now\n  noise = (1..SIZE).map { rand > 0.5 ? 0xFFFFFFFF : 0xFF000000 }.pack(\"I*\")\n\n  Gl.glClear Gl::GL_COLOR_BUFFER_BIT\n  Gl.glDrawPixels W, H, Gl::GL_RGBA, Gl::GL_UNSIGNED_BYTE, noise\n  Gl.glFlush\n\n  puts 1.0 / (Time.now - i)\n}\n\nGlut.glutCreateWindow \"noise\"\nGlut.glutMainLoop\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.ComponentModel;\nusing System.Drawing;\nusing System.Drawing.Imaging;\nusing System.Linq;\nusing System.Runtime.InteropServices;\nusing System.Windows.Forms;\n\nclass Program\n{\n    static Size size = new Size(320, 240);\n    static Rectangle rectsize = new Rectangle(new Point(0, 0), size);\n    static int numpixels = size.Width * size.Height;\n    static int numbytes = numpixels * 3;\n\n    static PictureBox pb;\n    static BackgroundWorker worker;\n\n    static double time = 0;\n    static double frames = 0;\n    static Random rand = new Random();\n\n    static byte tmp;\n    static byte white = 255;\n    static byte black = 0;\n    static int halfmax = int.MaxValue / 2; \n\n    static IEnumerable<byte> YieldVodoo()\n    {\n        \n\n        for (int i = 0; i < numpixels; i++)\n        {\n            tmp = rand.Next() < halfmax ? black : white; \n\n            \n            yield return tmp;\n            yield return tmp;\n            yield return tmp;\n        }\n    }\n\n    static Image Randimg()\n    {\n        \n        var bitmap = new Bitmap(size.Width, size.Height);\n        var data = bitmap.LockBits(rectsize, ImageLockMode.WriteOnly, PixelFormat.Format24bppRgb);\n\n        Marshal.Copy(\n            YieldVodoo().ToArray<byte>(),\n            0, \n            data.Scan0, \n            numbytes); \n\n        bitmap.UnlockBits(data);\n        return bitmap;\n    }\n\n    [STAThread]\n    static void Main()\n    {\n        var form = new Form();\n\n        form.AutoSize = true;\n        form.Size = new Size(0, 0);\n        form.Text = \"Test\";\n\n        form.FormClosed += delegate\n        {\n            Application.Exit();\n        };\n\n        worker = new BackgroundWorker();\n\n        worker.DoWork += delegate\n        {\n            System.Threading.Thread.Sleep(500); \n\n            while (true)\n            {\n                var a = DateTime.Now;\n                pb.Image = Randimg();\n                var b = DateTime.Now;\n\n                time += (b - a).TotalSeconds;\n                frames += 1;\n\n                if (frames == 30)\n                {\n                    Console.WriteLine(\"{0} frames in {1:0.000} seconds. ({2:0} FPS)\", frames, time, frames / time);\n\n                    time = 0;\n                    frames = 0;\n                }\n            }\n        };\n\n        worker.RunWorkerAsync();\n\n        FlowLayoutPanel flp = new FlowLayoutPanel();\n        form.Controls.Add(flp);\n\n        pb = new PictureBox();\n        pb.Size = size;\n\n        flp.AutoSize = true;\n        flp.Controls.Add(pb);\n\n        form.Show();\n        Application.Run();\n    }\n}\n"}
{"id": 50352, "name": "Image noise", "source": "Translate Ruby to Java: require 'rubygems'\nrequire 'gl'\nrequire 'glut'\n\nW, H = 320, 240\nSIZE = W * H\n\nGlut.glutInit ARGV\nGlut.glutInitWindowSize W, H\n\nGlut.glutIdleFunc lambda {\n  i = Time.now\n  noise = (1..SIZE).map { rand > 0.5 ? 0xFFFFFFFF : 0xFF000000 }.pack(\"I*\")\n\n  Gl.glClear Gl::GL_COLOR_BUFFER_BIT\n  Gl.glDrawPixels W, H, Gl::GL_RGBA, Gl::GL_UNSIGNED_BYTE, noise\n  Gl.glFlush\n\n  puts 1.0 / (Time.now - i)\n}\n\nGlut.glutCreateWindow \"noise\"\nGlut.glutMainLoop\n", "target": "import java.awt.*;\nimport java.awt.event.*;\nimport java.awt.image.*;\nimport java.util.Arrays;\nimport java.util.Random;\nimport javax.swing.*;\n\npublic class ImageNoise {\n    int framecount = 0;\n    int fps = 0;\n    BufferedImage image;\n    Kernel kernel;\n    ConvolveOp cop;\n    JFrame frame = new JFrame(\"Java Image Noise\");\n\n    JPanel panel = new JPanel() {\n        private int show_fps = 0; \n        private MouseAdapter ma = new MouseAdapter() {\n            @Override\n            public void mouseClicked(MouseEvent e) {\n                show_fps = (show_fps + 1) % 3;\n            }\n        };\n        {addMouseListener(ma);}\n\n        @Override\n        public Dimension getPreferredSize() {\n            return new Dimension(320, 240);\n        }\n\n        @Override\n        @SuppressWarnings(\"fallthrough\")\n        public void paintComponent(Graphics g1) {\n            Graphics2D g = (Graphics2D) g1;\n            drawNoise();\n            g.drawImage(image, 0, 0, null);\n\n            switch (show_fps) {\n            case 0: \n                \n                int xblur = getWidth() - 130, yblur = getHeight() - 32;\n                BufferedImage bc = image.getSubimage(xblur, yblur, 115, 32);\n                BufferedImage bs = new BufferedImage(bc.getWidth(), bc.getHeight(),\n                                                     BufferedImage.TYPE_BYTE_GRAY);\n                cop.filter(bc, bs);\n                g.drawImage(bs, xblur, yblur , null);\n            case 1: \n                \n                g.setColor(Color.RED);\n                g.setFont(new Font(\"Monospaced\", Font.BOLD, 20));\n                g.drawString(\"FPS: \" + fps, getWidth() - 120, getHeight() - 10);\n            }\n            framecount++;\n        }\n    };\n    \n    \n    Timer repainter = new Timer(1, new ActionListener() {\n        @Override\n        public void actionPerformed(ActionEvent e) {\n            panel.repaint();\n        }\n    });\n    \n    \n    Timer framerateChecker = new Timer(1000, new ActionListener() {\n        @Override\n        public void actionPerformed(ActionEvent e) {\n            fps = framecount;\n            framecount = 0;\n        }\n    });\n    \n    public ImageNoise() {\n        \n        float[] vals = new float[121];\n        Arrays.fill(vals, 1/121f);\n        kernel = new Kernel(11, 11, vals);\n        cop = new ConvolveOp(kernel, ConvolveOp.EDGE_NO_OP, null);\n        \n        \n        frame.add(panel);\n        frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n        frame.pack();\n        frame.setVisible(true);\n        repainter.start();\n        framerateChecker.start();\n    }\n\n    void drawNoise() {\n        int w = panel.getWidth(), h = panel.getHeight();\n        \n        \n        if (null == image || image.getWidth() != w || image.getHeight() != h) {\n            image = new BufferedImage(w, h, BufferedImage.TYPE_BYTE_GRAY);\n        }\n        Random rand = new Random();\n        int[] data = new int[w * h];\n        \n        for (int x = 0; x < w * h / 32; x++) {\n            int r = rand.nextInt();\n            for (int i = 0; i < 32; i++) {\n                data[x * 32 + i] = (r & 1) * Integer.MAX_VALUE;\n                r >>>= 1;\n            }\n        }\n        \n        image.getRaster().setPixels(0, 0, w, h, data);\n    }\n    \n    public static void main(String[] args) {\n        \n        SwingUtilities.invokeLater(new Runnable() {\n            @Override\n            public void run() {\n                ImageNoise i = new ImageNoise();\n            }\n        });\n    }\n}\n"}
{"id": 50353, "name": "Image noise", "source": "Translate Ruby to Python: require 'rubygems'\nrequire 'gl'\nrequire 'glut'\n\nW, H = 320, 240\nSIZE = W * H\n\nGlut.glutInit ARGV\nGlut.glutInitWindowSize W, H\n\nGlut.glutIdleFunc lambda {\n  i = Time.now\n  noise = (1..SIZE).map { rand > 0.5 ? 0xFFFFFFFF : 0xFF000000 }.pack(\"I*\")\n\n  Gl.glClear Gl::GL_COLOR_BUFFER_BIT\n  Gl.glDrawPixels W, H, Gl::GL_RGBA, Gl::GL_UNSIGNED_BYTE, noise\n  Gl.glFlush\n\n  puts 1.0 / (Time.now - i)\n}\n\nGlut.glutCreateWindow \"noise\"\nGlut.glutMainLoop\n", "target": "black = color(0)\nwhite = color(255)\n\ndef setup():\n    size(320, 240)\n    \n\n\ndef draw():\n    loadPixels()\n    for i in range(len(pixels)):\n        if random(1) < 0.5:\n            pixels[i] = black\n        else:\n            pixels[i] = white\n\n    updatePixels()\n    fill(0, 128)\n    rect(0, 0, 60, 20)\n    fill(255)\n    text(frameRate, 5, 15)\n"}
{"id": 50531, "name": "Sort disjoint sublist", "source": "Translate Ruby to C#: def sort_disjoint_sublist!(ar, indices)\n  values = ar.values_at(*indices).sort\n  indices.sort.zip(values).each{ |i,v| ar[i] = v }\n  ar\nend\n\nvalues = [7, 6, 5, 4, 3, 2, 1, 0]\nindices = [6, 1, 7]\np sort_disjoint_sublist!(values, indices)\n", "target": "using System;\nusing System.Linq;\nusing System.Collections.Generic;\n     \npublic class Test\n{\n    public static void Main()\n    {\n        var list = new List<int>{ 7, 6, 5, 4, 3, 2, 1, 0 };\n        list.SortSublist(6, 1, 7);\n        Console.WriteLine(string.Join(\", \", list));\n    }\n}\n     \npublic static class Extensions\n{\n    public static void SortSublist<T>(this List<T> list, params int[] indices)\n        where T : IComparable<T>\n    {\n        var sublist = indices.OrderBy(i => i)\n            .Zip(indices.Select(i => list[i]).OrderBy(v => v),\n                (Index, Value) => new { Index, Value });\n     \n        foreach (var entry in sublist) {\n            list[entry.Index] = entry.Value;\n        }\n    }\n     \n}\n"}
{"id": 50533, "name": "Sort disjoint sublist", "source": "Translate Ruby to Java: def sort_disjoint_sublist!(ar, indices)\n  values = ar.values_at(*indices).sort\n  indices.sort.zip(values).each{ |i,v| ar[i] = v }\n  ar\nend\n\nvalues = [7, 6, 5, 4, 3, 2, 1, 0]\nindices = [6, 1, 7]\np sort_disjoint_sublist!(values, indices)\n", "target": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.List;\n\npublic class Disjoint {\n    public static <T extends Comparable<? super T>> void sortDisjoint(\n            List<T> array, int[] idxs) {\n        Arrays.sort(idxs);\n        List<T> disjoint = new ArrayList<T>();\n        for (int idx : idxs) {\n            disjoint.add(array.get(idx));\n        }\n        Collections.sort(disjoint);\n        int i = 0;\n        for (int idx : idxs) {\n            array.set(idx, disjoint.get(i++));\n        }\n    }\n\n    public static void main(String[] args) {\n        List<Integer> list = Arrays.asList(7, 6, 5, 4, 3, 2, 1, 0);\n        int[] indices = {6, 1, 7};\n        System.out.println(list);\n        sortDisjoint(list, indices);\n        System.out.println(list);\n    }\n}\n"}
{"id": 50534, "name": "Sort disjoint sublist", "source": "Translate Ruby to Python: def sort_disjoint_sublist!(ar, indices)\n  values = ar.values_at(*indices).sort\n  indices.sort.zip(values).each{ |i,v| ar[i] = v }\n  ar\nend\n\nvalues = [7, 6, 5, 4, 3, 2, 1, 0]\nindices = [6, 1, 7]\np sort_disjoint_sublist!(values, indices)\n", "target": ">>> def sort_disjoint_sublist(data, indices):\n\tindices = sorted(indices)\n\tvalues  = sorted(data[i] for i in indices)\n\tfor index, value in zip(indices, values):\n\t\tdata[index] = value\n\n\t\t\n>>> d = [7, 6, 5, 4, 3, 2, 1, 0]\n>>> i = set([6, 1, 7])\n>>> sort_disjoint_sublist(d, i)\n>>> d\n[7, 0, 5, 4, 3, 2, 1, 6]\n>>> \n>>> def sort_disjoint_sublist(data, indices):\n\tfor index, value in zip(sorted(indices), sorted(data[i] for i in indices)): data[index] = value\n\n\t\n>>>\n"}
{"id": 50677, "name": "Kronecker product", "source": "Translate Ruby to C#: func kronecker_product(a, b) {\n    a ~X b -> map { _[0] ~X* _[1] }\n}\n\nkronecker_product([[1, 2], [3, 4]],\n                  [[0, 5], [6, 7]]).each { .say }\n\nsay ''\nkronecker_product([[0,1,0],  [1,1,1],   [0,1,0]],\n                  [[1,1,1,1],[1,0,0,1], [1,1,1,1]]).each { .say }\n", "target": "using System;\nusing System.Collections;\nusing System.Collections.Generic;\nusing static System.Linq.Enumerable;\n\npublic static class KroneckerProduct\n{\n    public static void Main() {\n        int[,] left = { {1, 2}, {3, 4} };\n        int[,] right = { {0, 5}, {6, 7} };\n        Print(Multiply(left, right));\n\n        left = new [,] { {0, 1, 0}, {1, 1, 1}, {0, 1, 0} };\n        right = new [,] { {1, 1, 1, 1}, {1, 0, 0, 1}, {1, 1, 1, 1} };\n        Print(Multiply(left, right));\n    }\n\n    static int[,] Multiply(int[,] left, int[,] right) {\n        (int lRows, int lColumns) = (left.GetLength(0), left.GetLength(1));\n        (int rRows, int rColumns) = (right.GetLength(0), right.GetLength(1));\n        int[,] result = new int[lRows * rRows, lColumns * rColumns];\n\n        foreach (var (r, c) in from r in Range(0, lRows) from c in Range(0, lColumns) select (r, c)) {\n            Copy(r * rRows, c * rColumns, left[r, c]);\n        }\n        return result;\n        \n        void Copy(int startRow, int startColumn, int multiplier) {\n            foreach (var (r, c) in from r in Range(0, rRows) from c in Range(0, rColumns) select (r, c)) {\n                result[startRow + r, startColumn + c] = right[r, c] * multiplier;\n            }\n        }\n    }\n\n    static void Print(int[,] matrix) {\n        (int rows, int columns) = (matrix.GetLength(0), matrix.GetLength(1));\n        int width = matrix.Cast<int>().Select(LengthOf).Max();\n        for (int row = 0; row < rows; row++) {\n            Console.WriteLine(\"| \" + string.Join(\" \", Range(0, columns).Select(column => (matrix[row, column] + \"\").PadLeft(width, ' '))) + \" |\");\n        }\n        Console.WriteLine();\n    }\n\n    private static int LengthOf(int i) {\n        if (i < 0) return LengthOf(-i) + 1;\n        int length = 0;\n        while (i > 0) {\n            length++;\n            i /= 10;\n        }\n        return length;\n    }\n\n}\n"}
{"id": 50679, "name": "Kronecker product", "source": "Translate Ruby to Java: func kronecker_product(a, b) {\n    a ~X b -> map { _[0] ~X* _[1] }\n}\n\nkronecker_product([[1, 2], [3, 4]],\n                  [[0, 5], [6, 7]]).each { .say }\n\nsay ''\nkronecker_product([[0,1,0],  [1,1,1],   [0,1,0]],\n                  [[1,1,1,1],[1,0,0,1], [1,1,1,1]]).each { .say }\n", "target": "package kronecker;\n\n\npublic class Product {\n  \n  public static int[][] product(final int[][] a, final int[][] b) {\n    \n    \n    final int[][] c = new int[a.length*b.length][];\n    \n    \n    for (int ix = 0; ix < c.length; ix++) {\n      final int num_cols = a[0].length*b[0].length;\n      c[ix] = new int[num_cols];\n    }\n    \n    \n    for (int ia = 0; ia < a.length; ia++) {\n      for (int ja = 0; ja < a[ia].length; ja++) {\n        \n        for (int ib = 0; ib < b.length; ib++) {\n          for (int jb = 0; jb < b[ib].length; jb++) {\n             c[b.length*ia+ib][b[ib].length*ja+jb] = a[ia][ja] * b[ib][jb];\n          }\n        }\n      }\n    }\n\n    \n    return c;\n  }\n\n  \n  public static void print_matrix(final int[][] m) {\n    \n    \n    \n    \n    final String[][] sts = new String[m.length][];\n    int max_length = 0;  \n    for (int im = 0; im < m.length; im++) {\n      sts[im] = new String[m[im].length];\n      for (int jm = 0; jm < m[im].length; jm++) {\n        final String st = String.valueOf(m[im][jm]);\n        if (st.length() > max_length) {\n          max_length = st.length();\n        }\n        sts[im][jm] = st;\n      }\n    }\n\n    \n    \n    \n    final String format = String.format(\"%%%ds\", max_length);\n    for (int im = 0; im < m.length; im++) {\n      System.out.print(\"|\");\n      \n      for (int jm = 0; jm < m[im].length - 1; jm++) {\n        System.out.format(format, m[im][jm]);\n        System.out.print(\" \");\n      }\n      System.out.format(format, m[im][m[im].length - 1]);\n      System.out.println(\"|\");\n    }\n  }\n\n  \n  private static void test(final int[][] a, final int[][] b) {\n    \n    System.out.println(\"Testing Kronecker product\");\n    System.out.println(\"Size of matrix a: \" + a.length + \" by \" + a[0].length);\n    System.out.println(\"Matrix a:\");\n    print_matrix(a);\n    System.out.println(\"Size of matrix b: \" + b.length + \" by \" + b[0].length);\n    System.out.println(\"Matrix b:\");\n    print_matrix(b);\n    System.out.println(\"Calculating matrix c as Kronecker product\");\n    final int[][] c = product(a, b);\n    System.out.println(\"Size of matrix c: \" + c.length + \" by \" + c[0].length);\n    System.out.println(\"Matrix c:\");\n    print_matrix(c);\n  }\n\n  \n  private static void test1() {\n    \n    final int[][] a = new int[2][];  \n    a[0] = new int[]{1, 2};\n    a[1] = new int[]{3, 4};\n    final int[][] b = new int[2][];  \n    b[0] = new int[]{0, 5};\n    b[1] = new int[]{6, 7};\n    \n    test(a, b);\n  }\n\n  \n  private static void test2() {\n    \n    final int[][] a = new int[3][];  \n    a[0] = new int[]{0, 1, 0};\n    a[1] = new int[]{1, 1, 1};\n    a[2] = new int[]{0, 1, 0};\n    final int[][] b = new int[3][];  \n    b[0] = new int[]{1, 1, 1, 1};\n    b[1] = new int[]{1, 0, 0, 1};\n    b[2] = new int[]{1, 1, 1, 1};\n    \n    test(a, b);\n  }\n\n  \n  public static void main(final String[] args) {\n    \n    test1();\n    test2();\n  }\n\n}\n"}
{"id": 50680, "name": "Kronecker product", "source": "Translate Ruby to Python: func kronecker_product(a, b) {\n    a ~X b -> map { _[0] ~X* _[1] }\n}\n\nkronecker_product([[1, 2], [3, 4]],\n                  [[0, 5], [6, 7]]).each { .say }\n\nsay ''\nkronecker_product([[0,1,0],  [1,1,1],   [0,1,0]],\n                  [[1,1,1,1],[1,0,0,1], [1,1,1,1]]).each { .say }\n", "target": "\n\n\na1 = [[1, 2], [3, 4]]\nb1 = [[0, 5], [6, 7]]\n\n\na2 = [[0, 1, 0], [1, 1, 1], [0, 1, 0]]\nb2 = [[1, 1, 1, 1], [1, 0, 0, 1], [1, 1, 1, 1]]\n\ndef kronecker(matrix1, matrix2):\n    final_list = []\n    sub_list = []\n\n    count = len(matrix2)\n\n    for elem1 in matrix1:\n        counter = 0\n        check = 0\n        while check < count:\n            for num1 in elem1:\n                for num2 in matrix2[counter]:\n                    sub_list.append(num1 * num2)\n            counter += 1\n            final_list.append(sub_list)\n            sub_list = []\n            check +=1\n            \n    return final_list\n\n\nresult1 = kronecker(a1, b1)\nfor elem in result1:\n    print(elem)\n\nprint(\"\")\n\n\nresult2 = kronecker(a2, b2)\nfor elem in result2:\n    print(elem)\n"}
{"id": 51060, "name": "Split a character string based on change of character", "source": "Translate Ruby to C#: def split(str)\n  puts \" input string: \n  s = str.chars.chunk(&:itself).map{|_,a| a.join}.join(\", \")\n  puts \"output string: \n  s\nend\n\nsplit(\"gHHH5YY++///\\\\\")\n", "target": "using System;\nusing System.Linq;\nusing System.Collections.Generic;\n\npublic class Program\n{\n    string s = @\"gHHH5YY++\n    Console.WriteLine(s.RunLengthSplit().Delimit(\", \"));\n}\n\npublic static class Extensions\n{\n    public static IEnumerable<string> RunLengthSplit(this string source) {\n        using (var enumerator = source.GetEnumerator()) {\n            if (!enumerator.MoveNext()) yield break;\n            char previous = enumerator.Current;\n            int count = 1;\n            while (enumerator.MoveNext()) {\n                if (previous == enumerator.Current) {\n                    count++;\n                } else {\n                    yield return new string(Enumerable.Repeat(previous, count).ToArray());\n                    previous = enumerator.Current;\n                    count = 1;\n                }\n            }\n            yield return new string(Enumerable.Repeat(previous, count).ToArray());\n        }\n    }\n\n    public static string Delimit<T>(this IEnumerable<T> source, string separator = \"\") => string.Join(separator ?? \"\", source);\n}\n"}
{"id": 51061, "name": "Split a character string based on change of character", "source": "Translate Ruby to C#: def split(str)\n  puts \" input string: \n  s = str.chars.chunk(&:itself).map{|_,a| a.join}.join(\", \")\n  puts \"output string: \n  s\nend\n\nsplit(\"gHHH5YY++///\\\\\")\n", "target": "using System;\nusing System.Linq;\nusing System.Collections.Generic;\n\npublic class Program\n{\n    string s = @\"gHHH5YY++\n    Console.WriteLine(s.RunLengthSplit().Delimit(\", \"));\n}\n\npublic static class Extensions\n{\n    public static IEnumerable<string> RunLengthSplit(this string source) {\n        using (var enumerator = source.GetEnumerator()) {\n            if (!enumerator.MoveNext()) yield break;\n            char previous = enumerator.Current;\n            int count = 1;\n            while (enumerator.MoveNext()) {\n                if (previous == enumerator.Current) {\n                    count++;\n                } else {\n                    yield return new string(Enumerable.Repeat(previous, count).ToArray());\n                    previous = enumerator.Current;\n                    count = 1;\n                }\n            }\n            yield return new string(Enumerable.Repeat(previous, count).ToArray());\n        }\n    }\n\n    public static string Delimit<T>(this IEnumerable<T> source, string separator = \"\") => string.Join(separator ?? \"\", source);\n}\n"}
{"id": 51064, "name": "Split a character string based on change of character", "source": "Translate Ruby to Java: def split(str)\n  puts \" input string: \n  s = str.chars.chunk(&:itself).map{|_,a| a.join}.join(\", \")\n  puts \"output string: \n  s\nend\n\nsplit(\"gHHH5YY++///\\\\\")\n", "target": "package org.rosettacode;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\n\n\npublic class SplitStringByCharacterChange {\n    \n    public static void main(String... args){\n        for (String string : args){\n            \n            List<String> resultStrings = splitStringByCharacter(string);\n            String output = formatList(resultStrings);\n            System.out.println(output);\n        }\n    }\n    \n    \n    public static List<String> splitStringByCharacter(String string){\n        \n        List<String> resultStrings = new ArrayList<>();\n        StringBuilder currentString = new StringBuilder();\n        \n        for (int pointer = 0; pointer < string.length(); pointer++){\n            \n            currentString.append(string.charAt(pointer));\n            \n            if (pointer == string.length() - 1 \n                    || currentString.charAt(0) != string.charAt(pointer + 1)) {\n                resultStrings.add(currentString.toString());\n                currentString = new StringBuilder();\n            }\n        }\n        \n        return resultStrings;\n    }\n    \n    \n    public static String formatList(List<String> list){\n        \n        StringBuilder output = new StringBuilder();\n        \n        for (int pointer = 0; pointer < list.size(); pointer++){\n            output.append(list.get(pointer));\n            \n            if (pointer != list.size() - 1){\n                output.append(\", \");\n            }\n        }\n        \n        return output.toString();\n    }\n}\n"}
{"id": 51065, "name": "Split a character string based on change of character", "source": "Translate Ruby to Java: def split(str)\n  puts \" input string: \n  s = str.chars.chunk(&:itself).map{|_,a| a.join}.join(\", \")\n  puts \"output string: \n  s\nend\n\nsplit(\"gHHH5YY++///\\\\\")\n", "target": "package org.rosettacode;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\n\n\npublic class SplitStringByCharacterChange {\n    \n    public static void main(String... args){\n        for (String string : args){\n            \n            List<String> resultStrings = splitStringByCharacter(string);\n            String output = formatList(resultStrings);\n            System.out.println(output);\n        }\n    }\n    \n    \n    public static List<String> splitStringByCharacter(String string){\n        \n        List<String> resultStrings = new ArrayList<>();\n        StringBuilder currentString = new StringBuilder();\n        \n        for (int pointer = 0; pointer < string.length(); pointer++){\n            \n            currentString.append(string.charAt(pointer));\n            \n            if (pointer == string.length() - 1 \n                    || currentString.charAt(0) != string.charAt(pointer + 1)) {\n                resultStrings.add(currentString.toString());\n                currentString = new StringBuilder();\n            }\n        }\n        \n        return resultStrings;\n    }\n    \n    \n    public static String formatList(List<String> list){\n        \n        StringBuilder output = new StringBuilder();\n        \n        for (int pointer = 0; pointer < list.size(); pointer++){\n            output.append(list.get(pointer));\n            \n            if (pointer != list.size() - 1){\n                output.append(\", \");\n            }\n        }\n        \n        return output.toString();\n    }\n}\n"}
{"id": 51066, "name": "Split a character string based on change of character", "source": "Translate Ruby to Python: def split(str)\n  puts \" input string: \n  s = str.chars.chunk(&:itself).map{|_,a| a.join}.join(\", \")\n  puts \"output string: \n  s\nend\n\nsplit(\"gHHH5YY++///\\\\\")\n", "target": "from itertools import groupby\n\ndef splitter(text):\n    return ', '.join(''.join(group) for key, group in groupby(text))\n\nif __name__ == '__main__':\n    txt = 'gHHH5YY++///\\\\'      \n    print(f'Input: {txt}\\nSplit: {splitter(txt)}')\n"}
{"id": 51067, "name": "Split a character string based on change of character", "source": "Translate Ruby to Python: def split(str)\n  puts \" input string: \n  s = str.chars.chunk(&:itself).map{|_,a| a.join}.join(\", \")\n  puts \"output string: \n  s\nend\n\nsplit(\"gHHH5YY++///\\\\\")\n", "target": "from itertools import groupby\n\ndef splitter(text):\n    return ', '.join(''.join(group) for key, group in groupby(text))\n\nif __name__ == '__main__':\n    txt = 'gHHH5YY++///\\\\'      \n    print(f'Input: {txt}\\nSplit: {splitter(txt)}')\n"}
{"id": 51283, "name": "Truncatable primes", "source": "Translate Ruby to C#: def left_truncatable?(n)\n  truncatable?(n) {|i| i.to_s[1..-1].to_i}\nend\n\n\ndef right_truncatable?(n)\n  truncatable?(n) {|i| i/10}\nend\n\ndef truncatable?(n, &trunc_func)\n  return false if n.to_s.include? \"0\"\n  loop do\n    n = trunc_func.call(n)\n    return true if n.zero?\n    return false unless Prime.prime?(n)\n  end\nend\n\nrequire 'prime'\nprimes = Prime.each(1_000_000).to_a.reverse\n\np primes.detect {|p| left_truncatable? p}\np primes.detect {|p| right_truncatable? p}\n", "target": "using System;  \nusing System.Collections.Generic;\nclass truncatable_primes\n{\n    static void Main()\n    {\n        uint m = 1000000;\n        Console.Write(\"L \" + L(m) + \" R \" + R(m) + \"  \");\n        var sw = System.Diagnostics.Stopwatch.StartNew();\n        for (int i = 1000; i > 0; i--) { L(m); R(m); }\n        Console.Write(sw.Elapsed); Console.Read();\n    }\n\n    static uint L(uint n)\n    {\n        n -= n & 1; n--;\n        for (uint d, d1 = 100; ; n -= 2)\n        {\n            while (n % 3 == 0 || n % 5 == 0 || n % 7 == 0) n -= 2;\n            if ((d = n % 10) == 3 || d == 7)\n            {\n                while (d1 < n && d < (d = n % d1) && isP(d)) d1 *= 10;\n                if (d1 > n && isP(n)) return n; d1 = 100;\n            }\n        }\n    }\n\n    static uint R(uint m)\n    {\n        var p = new List<uint>() { 2, 3, 5, 7 }; uint n = 20, np;\n        for (int i = 1; i < p.Count; n = 10 * p[i++])\n        {\n            if ((np = n + 1) >= m) break; if (isP(np)) p.Add(np);\n            if ((np = n + 3) >= m) break; if (isP(np)) p.Add(np);\n            if ((np = n + 7) >= m) break; if (isP(np)) p.Add(np);\n            if ((np = n + 9) >= m) break; if (isP(np)) p.Add(np);\n        }\n        return p[p.Count - 1];\n    }\n\n    static bool isP(uint n)\n    {\n        if (n < 7) return n == 2 || n == 3 || n == 5;\n        if ((n & 1) == 0 || n % 3 == 0 || n % 5 == 0) return false;\n        for (uint r = (uint)Math.Sqrt(n), d = 7; d <= r; d += 30)\n            if (n % (d + 00) == 0 || n % (d + 04) == 0 ||\n                n % (d + 06) == 0 || n % (d + 10) == 0 ||\n                n % (d + 12) == 0 || n % (d + 16) == 0 ||\n                n % (d + 22) == 0 || n % (d + 24) == 0) return false;\n        return true;\n    }\n}\n"}
{"id": 51285, "name": "Truncatable primes", "source": "Translate Ruby to Java: def left_truncatable?(n)\n  truncatable?(n) {|i| i.to_s[1..-1].to_i}\nend\n\n\ndef right_truncatable?(n)\n  truncatable?(n) {|i| i/10}\nend\n\ndef truncatable?(n, &trunc_func)\n  return false if n.to_s.include? \"0\"\n  loop do\n    n = trunc_func.call(n)\n    return true if n.zero?\n    return false unless Prime.prime?(n)\n  end\nend\n\nrequire 'prime'\nprimes = Prime.each(1_000_000).to_a.reverse\n\np primes.detect {|p| left_truncatable? p}\np primes.detect {|p| right_truncatable? p}\n", "target": "import java.util.BitSet;\n\npublic class Main {\n\n\tpublic static void main(String[] args){\n\n\t\tfinal int MAX = 1000000;\n\n\t\t\n\t\tBitSet primeList = new BitSet(MAX>>1); \n\t\tprimeList.set(0,primeList.size(),true); \n\n\t\tint sqroot = (int) Math.sqrt(MAX); \n\t\tprimeList.clear(0); \n\t\tfor(int num = 3; num <= sqroot; num+=2) \n\t\t{ \n\t\t\tif( primeList.get(num >> 1) ) \n\t\t\t{ \n\t\t\t\tint inc = num << 1;\n\t\t\t\tfor(int factor = num * num; factor < MAX; factor += inc) \n\t\t\t\t{ \n\t\t\t\t\t\n\t\t\t\t\t\n\t\t\t\t\tprimeList.clear(factor >> 1); \n\t\t\t\t\t\n\t\t\t\t} \n\t\t\t} \n\t\t}\n\t\t\n\n\t\t\n\t\tint rightTrunc = -1, leftTrunc = -1;\n\t\tfor(int prime = (MAX - 1) | 1; prime >= 3; prime -= 2)\n\t\t{\n\t\t\tif(primeList.get(prime>>1))\n\t\t\t{\n\t\t\t\t\n\t\t\t\tif(rightTrunc == -1)\n\t\t\t\t{\n\t\t\t\t\tint right = prime;\n\t\t\t\t\twhile(right > 0 && right % 2 != 0 && primeList.get(right >> 1)) right /= 10;\n\t\t\t\t\tif(right == 0) rightTrunc = prime;\n\t\t\t\t}\n\n\t\t\t\t\n\t\t\t\tif(leftTrunc == -1 )\n\t\t\t\t{\n\t\t\t\t\t\n\t\t\t\t\tString left = Integer.toString(prime);\n\t\t\t\t\tif(!left.contains(\"0\"))\n\t\t\t\t\t{\n\t\t\t\t\t\twhile( left.length() > 0 ){\n\t\t\t\t\t\t\tint iLeft = Integer.parseInt(left);\n\t\t\t\t\t\t\tif(!primeList.get( iLeft >> 1)) break;\n\t\t\t\t\t\t\tleft = left.substring(1);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(left.length() == 0) leftTrunc = prime;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(leftTrunc != -1 && rightTrunc != -1) \n\t\t\t\t{\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(\"Left  Truncatable\u00a0: \" + leftTrunc);\n\t\tSystem.out.println(\"Right Truncatable\u00a0: \" + rightTrunc);\n\t}\n}\n"}
{"id": 51286, "name": "Truncatable primes", "source": "Translate Ruby to Python: def left_truncatable?(n)\n  truncatable?(n) {|i| i.to_s[1..-1].to_i}\nend\n\n\ndef right_truncatable?(n)\n  truncatable?(n) {|i| i/10}\nend\n\ndef truncatable?(n, &trunc_func)\n  return false if n.to_s.include? \"0\"\n  loop do\n    n = trunc_func.call(n)\n    return true if n.zero?\n    return false unless Prime.prime?(n)\n  end\nend\n\nrequire 'prime'\nprimes = Prime.each(1_000_000).to_a.reverse\n\np primes.detect {|p| left_truncatable? p}\np primes.detect {|p| right_truncatable? p}\n", "target": "maxprime = 1000000\n\ndef primes(n):\n    multiples = set()\n    prime = []\n    for i in range(2, n+1):\n        if i not in multiples:\n            prime.append(i)\n            multiples.update(set(range(i*i, n+1, i)))\n    return prime\n\ndef truncatableprime(n):\n    'Return a longest left and right truncatable primes below n'\n    primelist = [str(x) for x in primes(n)[::-1]]\n    primeset = set(primelist)\n    for n in primelist:\n        \n        alltruncs = set(n[i:] for i in range(len(n)))\n        if alltruncs.issubset(primeset):\n            truncateleft = int(n)\n            break\n    for n in primelist:\n        \n        alltruncs = set([n[:i+1] for i in range(len(n))])\n        if alltruncs.issubset(primeset):\n            truncateright = int(n)\n            break\n    return truncateleft, truncateright\n\nprint(truncatableprime(maxprime))\n"}
{"id": 51402, "name": "Singleton", "source": "Translate Ruby to C#: require 'singleton'\nclass MySingleton\n   include Singleton\n   \nend\n\na = MySingleton.instance \nb = MySingleton.instance\nputs a.equal?(b) \n", "target": "public sealed class Singleton1 \n{\n    private static Singleton1 instance;\n    private static readonly object lockObj = new object();\n    \n    public static Singleton1 Instance {\n        get {\n            lock(lockObj) {\n                if (instance == null) {\n                    instance = new Singleton1();\n                }\n            }\n            return instance;\n        }\n    }\n}\n"}
{"id": 51404, "name": "Singleton", "source": "Translate Ruby to Java: require 'singleton'\nclass MySingleton\n   include Singleton\n   \nend\n\na = MySingleton.instance \nb = MySingleton.instance\nputs a.equal?(b) \n", "target": "class Singleton\n{\n    private static Singleton myInstance;\n    public static Singleton getInstance()\n    {\n        if (myInstance == null)\n        {\n            synchronized(Singleton.class)\n            {\n                if (myInstance == null)\n                {\n                    myInstance = new Singleton();\n                }\n            }\n        }\n\n        return myInstance;\n    }\n\n    protected Singleton()\n    {\n        \n    }\n\n    \n}\n"}
{"id": 51405, "name": "Singleton", "source": "Translate Ruby to Python: require 'singleton'\nclass MySingleton\n   include Singleton\n   \nend\n\na = MySingleton.instance \nb = MySingleton.instance\nputs a.equal?(b) \n", "target": ">>> class Borg(object):\n\t__state = {}\n\tdef __init__(self):\n\t\tself.__dict__ = self.__state\n\t\n\n\t\n>>> b1 = Borg()\n>>> b2 = Borg()\n>>> b1 is b2\nFalse\n>>> b1.datum = range(5)\n>>> b1.datum\n[0, 1, 2, 3, 4]\n>>> b2.datum\n[0, 1, 2, 3, 4]\n>>> b1.datum is b2.datum\nTrue\n>>> \n"}
{"id": 51711, "name": "Nested function", "source": "Translate Ruby to C#: def makeList(separator)\n  counter = 1\n\n  makeItem = lambda {|item|\n    result = \"\n    counter += 1\n    result\n  }\n\n  makeItem[\"first\"] + makeItem[\"second\"] + makeItem[\"third\"]\nend\n\nprint makeList(\". \")\n", "target": "string MakeList(string separator)\n{\n    int counter = 1;\n\n    Func<string, string> makeItem = item => counter++ + separator + item + \"\\n\";\n\n    return makeItem(\"first\") + makeItem(\"second\") + makeItem(\"third\");\n}\n\nConsole.WriteLine(MakeList(\". \"));\n"}
{"id": 51712, "name": "Nested function", "source": "Translate Ruby to C#: def makeList(separator)\n  counter = 1\n\n  makeItem = lambda {|item|\n    result = \"\n    counter += 1\n    result\n  }\n\n  makeItem[\"first\"] + makeItem[\"second\"] + makeItem[\"third\"]\nend\n\nprint makeList(\". \")\n", "target": "string MakeList(string separator)\n{\n    int counter = 1;\n\n    Func<string, string> makeItem = item => counter++ + separator + item + \"\\n\";\n\n    return makeItem(\"first\") + makeItem(\"second\") + makeItem(\"third\");\n}\n\nConsole.WriteLine(MakeList(\". \"));\n"}
{"id": 51715, "name": "Nested function", "source": "Translate Ruby to Java: def makeList(separator)\n  counter = 1\n\n  makeItem = lambda {|item|\n    result = \"\n    counter += 1\n    result\n  }\n\n  makeItem[\"first\"] + makeItem[\"second\"] + makeItem[\"third\"]\nend\n\nprint makeList(\". \")\n", "target": "module NestedFunction\n    {\n    static String makeList(String separator)\n        {\n        Int counter = 1;\n\n        function String(String) makeItem = item -> $\"{counter++}{separator}{item}\\n\";\n\n        return makeItem(\"first\")\n             + makeItem(\"second\")\n             + makeItem(\"third\");\n        }\n\n    void run()\n        {\n        @Inject Console console;\n        console.print(makeList(\". \"));\n        }\n    }\n"}
{"id": 51716, "name": "Nested function", "source": "Translate Ruby to Java: def makeList(separator)\n  counter = 1\n\n  makeItem = lambda {|item|\n    result = \"\n    counter += 1\n    result\n  }\n\n  makeItem[\"first\"] + makeItem[\"second\"] + makeItem[\"third\"]\nend\n\nprint makeList(\". \")\n", "target": "module NestedFunction\n    {\n    static String makeList(String separator)\n        {\n        Int counter = 1;\n\n        function String(String) makeItem = item -> $\"{counter++}{separator}{item}\\n\";\n\n        return makeItem(\"first\")\n             + makeItem(\"second\")\n             + makeItem(\"third\");\n        }\n\n    void run()\n        {\n        @Inject Console console;\n        console.print(makeList(\". \"));\n        }\n    }\n"}
{"id": 51717, "name": "Nested function", "source": "Translate Ruby to Python: def makeList(separator)\n  counter = 1\n\n  makeItem = lambda {|item|\n    result = \"\n    counter += 1\n    result\n  }\n\n  makeItem[\"first\"] + makeItem[\"second\"] + makeItem[\"third\"]\nend\n\nprint makeList(\". \")\n", "target": "def makeList(separator):\n    counter = 1\n\n    def makeItem(item):\n        nonlocal counter\n        result = str(counter) + separator + item + \"\\n\"\n        counter += 1\n        return result\n\n    return makeItem(\"first\") + makeItem(\"second\") + makeItem(\"third\")\n\nprint(makeList(\". \"))\n"}
{"id": 51718, "name": "Nested function", "source": "Translate Ruby to Python: def makeList(separator)\n  counter = 1\n\n  makeItem = lambda {|item|\n    result = \"\n    counter += 1\n    result\n  }\n\n  makeItem[\"first\"] + makeItem[\"second\"] + makeItem[\"third\"]\nend\n\nprint makeList(\". \")\n", "target": "def makeList(separator):\n    counter = 1\n\n    def makeItem(item):\n        nonlocal counter\n        result = str(counter) + separator + item + \"\\n\"\n        counter += 1\n        return result\n\n    return makeItem(\"first\") + makeItem(\"second\") + makeItem(\"third\")\n\nprint(makeList(\". \"))\n"}
{"id": 51995, "name": "Sorting algorithms_Merge sort", "source": "Translate Ruby to C#: def merge_sort(a : Array(Int32)) : Array(Int32)\n  return a if a.size <= 1\n  m = a.size // 2\n  lt = merge_sort(a[0 ... m])\n  rt = merge_sort(a[m .. -1])\n  return merge(lt, rt)\nend\n \ndef merge(lt : Array(Int32), rt : Array(Int32)) : Array(Int32)\n  result = Array(Int32).new\n  until lt.empty? || rt.empty?\n    result << (lt.first < rt.first ? lt.shift : rt.shift)\n  end\n  return result + lt + rt\nend\n \na = [7, 6, 5, 9, 8, 4, 3, 1, 2, 0]\nputs merge_sort(a) \n", "target": "namespace RosettaCode {\n  using System;\n\n  public class MergeSort<T> where T : IComparable {\n    #region Constants\n    public const UInt32 INSERTION_LIMIT_DEFAULT = 12;\n    public const Int32 MERGES_DEFAULT = 6;\n    #endregion\n\n    #region Properties\n    public UInt32 InsertionLimit { get; }\n    protected UInt32[] Positions { get; set; }\n\n    private Int32 merges;\n    public Int32 Merges {\n      get { return merges; }\n      set {\n        \n        if (value > 1)\n          merges = value;\n        else\n          throw new ArgumentOutOfRangeException($\"value = {value} must be greater than one\", nameof(Merges));\n\n        if (Positions == null || Positions.Length != merges)\n          Positions = new UInt32[merges];\n      }\n    }\n    #endregion\n\n    #region Constructors\n    public MergeSort(UInt32 insertionLimit, Int32 merges) {\n      InsertionLimit = insertionLimit;\n      Merges = merges;\n    }\n\n    public MergeSort()\n      : this(INSERTION_LIMIT_DEFAULT, MERGES_DEFAULT) {\n    }\n    #endregion\n\n    #region Sort Methods\n    public void Sort(T[] entries) {\n      \n      var entries2 = new T[entries.Length];\n      Sort(entries, entries2, 0, entries.Length - 1);\n    }\n\n    \n    public void Sort(T[] entries1, T[] entries2, Int32 first, Int32 last) {\n      var length = last + 1 - first;\n      if (length < 2) return;      \n      if (length < Merges || length < InsertionLimit) {\n        InsertionSort<T>.Sort(entries1, first, last);\n        return;\n      }\n\n      var left = first;\n      var size = ceiling(length, Merges);\n      for (var remaining = length; remaining > 0; remaining -= size, left += size) {\n        var right = left + Math.Min(remaining, size) - 1;\n        Sort(entries1, entries2, left, right);\n      }\n\n      Merge(entries1, entries2, first, last);\n      Array.Copy(entries2, first, entries1, first, length);\n    }\n    #endregion\n\n    #region Merge Methods\n    public void Merge(T[] entries1, T[] entries2, Int32 first, Int32 last) {\n      Array.Clear(Positions, 0, Merges);\n      \n      for (var index = first; index <= last; index++)\n        entries2[index] = remove(entries1, first, last);\n    }\n\n    private T remove(T[] entries, Int32 first, Int32 last) {\n      T entry = default;\n      Int32? found = default;\n      var length = last + 1 - first;\n\n      var index = 0;\n      var left = first;\n      var size = ceiling(length, Merges);\n      for (var remaining = length; remaining > 0; remaining -= size, left += size, index++) {\n        var position = Positions[index];\n        if (position < Math.Min(remaining, size)) {\n          var next = entries[left + position];\n          if (!found.HasValue || entry.CompareTo(next) > 0) {\n            found = index;\n            entry = next;\n          }\n        }\n      }\n\n      \n      Positions[found.Value]++;\n      return entry;\n    }\n    #endregion\n\n    #region Math Methods\n    private static Int32 ceiling(Int32 numerator, Int32 denominator) {\n      return (numerator + denominator - 1) / denominator;\n    }\n    #endregion\n  }\n\n  #region Insertion Sort\n  static class InsertionSort<T> where T : IComparable {\n    public static void Sort(T[] entries, Int32 first, Int32 last) {\n      for (var next = first + 1; next <= last; next++)\n        insert(entries, first, next);\n    }\n\n    \n    private static void insert(T[] entries, Int32 first, Int32 next) {\n      var entry = entries[next];\n      while (next > first && entries[next - 1].CompareTo(entry) > 0)\n        entries[next] = entries[--next];\n      entries[next] = entry;\n    }\n  }\n  #endregion\n}\n"}
{"id": 51997, "name": "Sorting algorithms_Merge sort", "source": "Translate Ruby to Java: def merge_sort(a : Array(Int32)) : Array(Int32)\n  return a if a.size <= 1\n  m = a.size // 2\n  lt = merge_sort(a[0 ... m])\n  rt = merge_sort(a[m .. -1])\n  return merge(lt, rt)\nend\n \ndef merge(lt : Array(Int32), rt : Array(Int32)) : Array(Int32)\n  result = Array(Int32).new\n  until lt.empty? || rt.empty?\n    result << (lt.first < rt.first ? lt.shift : rt.shift)\n  end\n  return result + lt + rt\nend\n \na = [7, 6, 5, 9, 8, 4, 3, 1, 2, 0]\nputs merge_sort(a) \n", "target": "import java.util.List;\nimport java.util.ArrayList;\nimport java.util.Iterator;\n\npublic class Merge{\n    public static <E extends Comparable<? super E>> List<E> mergeSort(List<E> m){\n        if(m.size() <= 1) return m;\n\n        int middle = m.size() / 2;\n        List<E> left = m.subList(0, middle);\n        List<E> right = m.subList(middle, m.size());\n\n        right = mergeSort(right);\n        left = mergeSort(left);\n        List<E> result = merge(left, right);\n\n        return result;\n    }\n\n    public static <E extends Comparable<? super E>> List<E> merge(List<E> left, List<E> right){\n        List<E> result = new ArrayList<E>();\n        Iterator<E> it1 = left.iterator();\n        Iterator<E> it2 = right.iterator();\n\n\tE x = it1.next();\n\tE y = it2.next();\n        while (true){\n            \n            if(x.compareTo(y) <= 0){\n\t\tresult.add(x);\n\t\tif(it1.hasNext()){\n\t\t    x = it1.next();\n\t\t}else{\n\t\t    result.add(y);\n\t\t    while(it2.hasNext()){\n\t\t\tresult.add(it2.next());\n\t\t    }\n\t\t    break;\n\t\t}\n\t    }else{\n\t\tresult.add(y);\n\t\tif(it2.hasNext()){\n\t\t    y = it2.next();\n\t\t}else{\n\t\t    result.add(x);\n\t\t    while (it1.hasNext()){\n\t\t\tresult.add(it1.next());\n\t\t    }\n\t\t    break;\n\t\t}\n\t    }\n        }\n        return result;\n    }\n}\n"}
{"id": 51998, "name": "Sorting algorithms_Merge sort", "source": "Translate Ruby to Python: def merge_sort(a : Array(Int32)) : Array(Int32)\n  return a if a.size <= 1\n  m = a.size // 2\n  lt = merge_sort(a[0 ... m])\n  rt = merge_sort(a[m .. -1])\n  return merge(lt, rt)\nend\n \ndef merge(lt : Array(Int32), rt : Array(Int32)) : Array(Int32)\n  result = Array(Int32).new\n  until lt.empty? || rt.empty?\n    result << (lt.first < rt.first ? lt.shift : rt.shift)\n  end\n  return result + lt + rt\nend\n \na = [7, 6, 5, 9, 8, 4, 3, 1, 2, 0]\nputs merge_sort(a) \n", "target": "fun mergesort(m):\n    if m.lenght <= 1: return m\n    let middle = floor m.lenght / 2\n    let left = merge(m[:middle])\n    let right = merge(m[middle-1:]);\n\nfun merge(left, right):\n    let result = []\n    while not (left.isempty or right.isempty):\n        if left[1] <= right[1]:\n            result.push! left.shift!()\n        else:\n            result.push! right.shift!()\n    result.push! left.push! right\n\nlet arr = [7, 6, 5, 9, 8, 4, 3, 1, 2, 0]\nprint mergesort arr\n"}
{"id": 52324, "name": "Average loop length", "source": "Translate Ruby to C#: class Integer\n  def factorial\n    self == 0 ? 1 : (1..self).inject(:*)\n  end\nend\n\ndef rand_until_rep(n)\n  rands = {}\n  loop do\n    r = rand(1..n)\n    return rands.size if rands[r]\n    rands[r] = true\n  end\nend\n\nruns = 1_000_000\n\nputs \" N    average    exp.        diff   \",\n     \"===  ========  ========  ===========\"\n(1..20).each do |n|\n  sum_of_runs = runs.times.inject(0){|sum, _| sum += rand_until_rep(n)}\n  avg = sum_of_runs / runs.to_f\n  analytical = (1..n).inject(0){|sum, i| sum += (n.factorial / (n**i).to_f / (n-i).factorial)}\n  puts \"%3d  %8.4f  %8.4f  (%8.4f%%)\" % [n, avg, analytical, (avg/analytical - 1)*100]\nend\n", "target": "public class AverageLoopLength {\n\tprivate static int N = 100000;\n\t\n\tprivate static double analytical(int n) {\n\t\tdouble[] factorial = new double[n + 1];\n\t\tdouble[] powers = new double[n + 1];\n\t\tpowers[0] = 1.0;\n\t\tfactorial[0] = 1.0;\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tfactorial[i] = factorial[i - 1] * i;\n\t\t\tpowers[i] = powers[i - 1] * n;\n\t\t}\n\t\tdouble sum = 0;\n\t\t\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tsum += factorial[n] / factorial[n - i] / powers[i];\n\t\t}\n\t\treturn sum;\n\t}\n\n\tprivate static double average(int n) {\n\t\tRandom rnd = new Random();\n\t\tdouble sum = 0.0;\n\t\tfor (int a = 0; a < N; a++) {\n\t\t\tint[] random = new int[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\trandom[i] = rnd.Next(n);\n\t\t\t}\n\t\t\tvar seen = new HashSet<double>(n);\n\t\t\tint current = 0;\n\t\t\tint length = 0;\n\t\t\twhile (seen.Add(current)) {\n\t\t\t\tlength++;\n\t\t\t\tcurrent = random[current];\n\t\t\t}\n\t\t\tsum += length;\n\t\t}\n\t\treturn sum / N;\n\t}\n\t\n\tpublic static void Main(string[] args) {\n\tConsole.WriteLine(\" N    average    analytical    (error)\");\n\tConsole.WriteLine(\"===  =========  ============  =========\");\n\t\tfor (int i = 1; i <= 20; i++) {\n\t\t\tvar average = AverageLoopLength.average(i);\n\t\t\tvar analytical = AverageLoopLength.analytical(i);\n\t\t\tConsole.WriteLine(\"{0,3} {1,10:N4} {2,13:N4}  {3,8:N2}%\", i, average, analytical, (analytical - average) / analytical * 100);\n\t\t}\n\t}\n}\n"}
{"id": 52325, "name": "Average loop length", "source": "Translate Ruby to C#: class Integer\n  def factorial\n    self == 0 ? 1 : (1..self).inject(:*)\n  end\nend\n\ndef rand_until_rep(n)\n  rands = {}\n  loop do\n    r = rand(1..n)\n    return rands.size if rands[r]\n    rands[r] = true\n  end\nend\n\nruns = 1_000_000\n\nputs \" N    average    exp.        diff   \",\n     \"===  ========  ========  ===========\"\n(1..20).each do |n|\n  sum_of_runs = runs.times.inject(0){|sum, _| sum += rand_until_rep(n)}\n  avg = sum_of_runs / runs.to_f\n  analytical = (1..n).inject(0){|sum, i| sum += (n.factorial / (n**i).to_f / (n-i).factorial)}\n  puts \"%3d  %8.4f  %8.4f  (%8.4f%%)\" % [n, avg, analytical, (avg/analytical - 1)*100]\nend\n", "target": "public class AverageLoopLength {\n\tprivate static int N = 100000;\n\t\n\tprivate static double analytical(int n) {\n\t\tdouble[] factorial = new double[n + 1];\n\t\tdouble[] powers = new double[n + 1];\n\t\tpowers[0] = 1.0;\n\t\tfactorial[0] = 1.0;\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tfactorial[i] = factorial[i - 1] * i;\n\t\t\tpowers[i] = powers[i - 1] * n;\n\t\t}\n\t\tdouble sum = 0;\n\t\t\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tsum += factorial[n] / factorial[n - i] / powers[i];\n\t\t}\n\t\treturn sum;\n\t}\n\n\tprivate static double average(int n) {\n\t\tRandom rnd = new Random();\n\t\tdouble sum = 0.0;\n\t\tfor (int a = 0; a < N; a++) {\n\t\t\tint[] random = new int[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\trandom[i] = rnd.Next(n);\n\t\t\t}\n\t\t\tvar seen = new HashSet<double>(n);\n\t\t\tint current = 0;\n\t\t\tint length = 0;\n\t\t\twhile (seen.Add(current)) {\n\t\t\t\tlength++;\n\t\t\t\tcurrent = random[current];\n\t\t\t}\n\t\t\tsum += length;\n\t\t}\n\t\treturn sum / N;\n\t}\n\t\n\tpublic static void Main(string[] args) {\n\tConsole.WriteLine(\" N    average    analytical    (error)\");\n\tConsole.WriteLine(\"===  =========  ============  =========\");\n\t\tfor (int i = 1; i <= 20; i++) {\n\t\t\tvar average = AverageLoopLength.average(i);\n\t\t\tvar analytical = AverageLoopLength.analytical(i);\n\t\t\tConsole.WriteLine(\"{0,3} {1,10:N4} {2,13:N4}  {3,8:N2}%\", i, average, analytical, (analytical - average) / analytical * 100);\n\t\t}\n\t}\n}\n"}
{"id": 52328, "name": "Average loop length", "source": "Translate Ruby to Java: class Integer\n  def factorial\n    self == 0 ? 1 : (1..self).inject(:*)\n  end\nend\n\ndef rand_until_rep(n)\n  rands = {}\n  loop do\n    r = rand(1..n)\n    return rands.size if rands[r]\n    rands[r] = true\n  end\nend\n\nruns = 1_000_000\n\nputs \" N    average    exp.        diff   \",\n     \"===  ========  ========  ===========\"\n(1..20).each do |n|\n  sum_of_runs = runs.times.inject(0){|sum, _| sum += rand_until_rep(n)}\n  avg = sum_of_runs / runs.to_f\n  analytical = (1..n).inject(0){|sum, i| sum += (n.factorial / (n**i).to_f / (n-i).factorial)}\n  puts \"%3d  %8.4f  %8.4f  (%8.4f%%)\" % [n, avg, analytical, (avg/analytical - 1)*100]\nend\n", "target": "import java.util.HashSet;\nimport java.util.Random;\nimport java.util.Set;\n\npublic class AverageLoopLength {\n\n    private static final int N = 100000;\n\n    \n    private static double analytical(int n) {\n        double[] factorial = new double[n + 1];\n        double[] powers = new double[n + 1];\n        powers[0] = 1.0;\n        factorial[0] = 1.0;\n        for (int i = 1; i <= n; i++) {\n            factorial[i] = factorial[i - 1] * i;\n            powers[i] = powers[i - 1] * n;\n        }\n        double sum = 0;\n        \n        for (int i = 1; i <= n; i++) {\n            sum += factorial[n] / factorial[n - i] / powers[i];\n        }\n        return sum;\n    }\n\n    private static double average(int n) {\n        Random rnd = new Random();\n        double sum = 0.0;\n        for (int a = 0; a < N; a++) {\n            int[] random = new int[n];\n            for (int i = 0; i < n; i++) {\n                random[i] = rnd.nextInt(n);\n            }\n            Set<Integer> seen = new HashSet<>(n);\n            int current = 0;\n            int length = 0;\n            while (seen.add(current)) {\n                length++;\n                current = random[current];\n            }\n            sum += length;\n        }\n        return sum / N;\n    }\n\n    public static void main(String[] args) {\n        System.out.println(\" N    average    analytical    (error)\");\n        System.out.println(\"===  =========  ============  =========\");\n        for (int i = 1; i <= 20; i++) {\n            double avg = average(i);\n            double ana = analytical(i);\n            System.out.println(String.format(\"%3d  %9.4f  %12.4f  (%6.2f%%)\", i, avg, ana, ((ana - avg) / ana * 100)));\n        }\n    }\n}\n"}
{"id": 52329, "name": "Average loop length", "source": "Translate Ruby to Java: class Integer\n  def factorial\n    self == 0 ? 1 : (1..self).inject(:*)\n  end\nend\n\ndef rand_until_rep(n)\n  rands = {}\n  loop do\n    r = rand(1..n)\n    return rands.size if rands[r]\n    rands[r] = true\n  end\nend\n\nruns = 1_000_000\n\nputs \" N    average    exp.        diff   \",\n     \"===  ========  ========  ===========\"\n(1..20).each do |n|\n  sum_of_runs = runs.times.inject(0){|sum, _| sum += rand_until_rep(n)}\n  avg = sum_of_runs / runs.to_f\n  analytical = (1..n).inject(0){|sum, i| sum += (n.factorial / (n**i).to_f / (n-i).factorial)}\n  puts \"%3d  %8.4f  %8.4f  (%8.4f%%)\" % [n, avg, analytical, (avg/analytical - 1)*100]\nend\n", "target": "import java.util.HashSet;\nimport java.util.Random;\nimport java.util.Set;\n\npublic class AverageLoopLength {\n\n    private static final int N = 100000;\n\n    \n    private static double analytical(int n) {\n        double[] factorial = new double[n + 1];\n        double[] powers = new double[n + 1];\n        powers[0] = 1.0;\n        factorial[0] = 1.0;\n        for (int i = 1; i <= n; i++) {\n            factorial[i] = factorial[i - 1] * i;\n            powers[i] = powers[i - 1] * n;\n        }\n        double sum = 0;\n        \n        for (int i = 1; i <= n; i++) {\n            sum += factorial[n] / factorial[n - i] / powers[i];\n        }\n        return sum;\n    }\n\n    private static double average(int n) {\n        Random rnd = new Random();\n        double sum = 0.0;\n        for (int a = 0; a < N; a++) {\n            int[] random = new int[n];\n            for (int i = 0; i < n; i++) {\n                random[i] = rnd.nextInt(n);\n            }\n            Set<Integer> seen = new HashSet<>(n);\n            int current = 0;\n            int length = 0;\n            while (seen.add(current)) {\n                length++;\n                current = random[current];\n            }\n            sum += length;\n        }\n        return sum / N;\n    }\n\n    public static void main(String[] args) {\n        System.out.println(\" N    average    analytical    (error)\");\n        System.out.println(\"===  =========  ============  =========\");\n        for (int i = 1; i <= 20; i++) {\n            double avg = average(i);\n            double ana = analytical(i);\n            System.out.println(String.format(\"%3d  %9.4f  %12.4f  (%6.2f%%)\", i, avg, ana, ((ana - avg) / ana * 100)));\n        }\n    }\n}\n"}
{"id": 52330, "name": "Average loop length", "source": "Translate Ruby to Python: class Integer\n  def factorial\n    self == 0 ? 1 : (1..self).inject(:*)\n  end\nend\n\ndef rand_until_rep(n)\n  rands = {}\n  loop do\n    r = rand(1..n)\n    return rands.size if rands[r]\n    rands[r] = true\n  end\nend\n\nruns = 1_000_000\n\nputs \" N    average    exp.        diff   \",\n     \"===  ========  ========  ===========\"\n(1..20).each do |n|\n  sum_of_runs = runs.times.inject(0){|sum, _| sum += rand_until_rep(n)}\n  avg = sum_of_runs / runs.to_f\n  analytical = (1..n).inject(0){|sum, i| sum += (n.factorial / (n**i).to_f / (n-i).factorial)}\n  puts \"%3d  %8.4f  %8.4f  (%8.4f%%)\" % [n, avg, analytical, (avg/analytical - 1)*100]\nend\n", "target": "from __future__ import division \nfrom math import factorial\nfrom random import randrange\n\nMAX_N = 20\nTIMES = 1000000\n\ndef analytical(n):\n\treturn sum(factorial(n) / pow(n, i) / factorial(n -i) for i in range(1, n+1))\n\ndef test(n, times):\n    count = 0\n    for i in range(times):\n        x, bits = 1, 0\n        while not (bits & x):\n            count += 1\n            bits |= x\n            x = 1 << randrange(n)\n    return count / times\n\nif __name__ == '__main__':\n    print(\" n\\tavg\\texp.\\tdiff\\n-------------------------------\")\n    for n in range(1, MAX_N+1):\n        avg = test(n, TIMES)\n        theory = analytical(n)\n        diff = (avg / theory - 1) * 100\n        print(\"%2d %8.4f %8.4f %6.3f%%\" % (n, avg, theory, diff))\n"}
{"id": 52331, "name": "Average loop length", "source": "Translate Ruby to Python: class Integer\n  def factorial\n    self == 0 ? 1 : (1..self).inject(:*)\n  end\nend\n\ndef rand_until_rep(n)\n  rands = {}\n  loop do\n    r = rand(1..n)\n    return rands.size if rands[r]\n    rands[r] = true\n  end\nend\n\nruns = 1_000_000\n\nputs \" N    average    exp.        diff   \",\n     \"===  ========  ========  ===========\"\n(1..20).each do |n|\n  sum_of_runs = runs.times.inject(0){|sum, _| sum += rand_until_rep(n)}\n  avg = sum_of_runs / runs.to_f\n  analytical = (1..n).inject(0){|sum, i| sum += (n.factorial / (n**i).to_f / (n-i).factorial)}\n  puts \"%3d  %8.4f  %8.4f  (%8.4f%%)\" % [n, avg, analytical, (avg/analytical - 1)*100]\nend\n", "target": "from __future__ import division \nfrom math import factorial\nfrom random import randrange\n\nMAX_N = 20\nTIMES = 1000000\n\ndef analytical(n):\n\treturn sum(factorial(n) / pow(n, i) / factorial(n -i) for i in range(1, n+1))\n\ndef test(n, times):\n    count = 0\n    for i in range(times):\n        x, bits = 1, 0\n        while not (bits & x):\n            count += 1\n            bits |= x\n            x = 1 << randrange(n)\n    return count / times\n\nif __name__ == '__main__':\n    print(\" n\\tavg\\texp.\\tdiff\\n-------------------------------\")\n    for n in range(1, MAX_N+1):\n        avg = test(n, TIMES)\n        theory = analytical(n)\n        diff = (avg / theory - 1) * 100\n        print(\"%2d %8.4f %8.4f %6.3f%%\" % (n, avg, theory, diff))\n"}
{"id": 52699, "name": "Word frequency", "source": "Translate Ruby to C#: require \"http/client\"\nrequire \"regex\"\n\n\nresponse = HTTP::Client.get \"https://www.gutenberg.org/files/135/135-0.txt\"\ntext = response.body\n\ntext\n  .downcase\n  .scan(/[a-zA-Z\u00e1\u00e9\u00ed\u00f3\u00fa\u00c1\u00c9\u00cd\u00d3\u00da\u00e2\u00ea\u00f4\u00e4\u00fc\u00f6\u00e0\u00e8\u00ec\u00f2\u00f9\u00f1']+/)\n  .reduce({} of String => Int32) { |hash, match|\n    word = match[0]\n    hash[word] = hash.fetch(word, 0) + 1 \n    hash\n  }\n  .to_a                                        \n  .sort { |a, b| b[1] <=> a[1] }[0..9]         \n  .each_with_index(1) { |(word, n), i| puts \"\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.IO;\nusing System.Linq;\nusing System.Text.RegularExpressions;\n\nnamespace WordCount {\n    class Program {\n        static void Main(string[] args) {\n            var text = File.ReadAllText(\"135-0.txt\").ToLower();\n\n            var match = Regex.Match(text, \"\\\\w+\");\n            Dictionary<string, int> freq = new Dictionary<string, int>();\n            while (match.Success) {\n                string word = match.Value;\n                if (freq.ContainsKey(word)) {\n                    freq[word]++;\n                } else {\n                    freq.Add(word, 1);\n                }\n\n                match = match.NextMatch();\n            }\n\n            Console.WriteLine(\"Rank  Word  Frequency\");\n            Console.WriteLine(\"====  ====  =========\");\n            int rank = 1;\n            foreach (var elem in freq.OrderByDescending(a => a.Value).Take(10)) {\n                Console.WriteLine(\"{0,2}    {1,-4}    {2,5}\", rank++, elem.Key, elem.Value);\n            }\n        }\n    }\n}\n"}
{"id": 52700, "name": "Word frequency", "source": "Translate Ruby to C#: require \"http/client\"\nrequire \"regex\"\n\n\nresponse = HTTP::Client.get \"https://www.gutenberg.org/files/135/135-0.txt\"\ntext = response.body\n\ntext\n  .downcase\n  .scan(/[a-zA-Z\u00e1\u00e9\u00ed\u00f3\u00fa\u00c1\u00c9\u00cd\u00d3\u00da\u00e2\u00ea\u00f4\u00e4\u00fc\u00f6\u00e0\u00e8\u00ec\u00f2\u00f9\u00f1']+/)\n  .reduce({} of String => Int32) { |hash, match|\n    word = match[0]\n    hash[word] = hash.fetch(word, 0) + 1 \n    hash\n  }\n  .to_a                                        \n  .sort { |a, b| b[1] <=> a[1] }[0..9]         \n  .each_with_index(1) { |(word, n), i| puts \"\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.IO;\nusing System.Linq;\nusing System.Text.RegularExpressions;\n\nnamespace WordCount {\n    class Program {\n        static void Main(string[] args) {\n            var text = File.ReadAllText(\"135-0.txt\").ToLower();\n\n            var match = Regex.Match(text, \"\\\\w+\");\n            Dictionary<string, int> freq = new Dictionary<string, int>();\n            while (match.Success) {\n                string word = match.Value;\n                if (freq.ContainsKey(word)) {\n                    freq[word]++;\n                } else {\n                    freq.Add(word, 1);\n                }\n\n                match = match.NextMatch();\n            }\n\n            Console.WriteLine(\"Rank  Word  Frequency\");\n            Console.WriteLine(\"====  ====  =========\");\n            int rank = 1;\n            foreach (var elem in freq.OrderByDescending(a => a.Value).Take(10)) {\n                Console.WriteLine(\"{0,2}    {1,-4}    {2,5}\", rank++, elem.Key, elem.Value);\n            }\n        }\n    }\n}\n"}
{"id": 52703, "name": "Word frequency", "source": "Translate Ruby to Java: require \"http/client\"\nrequire \"regex\"\n\n\nresponse = HTTP::Client.get \"https://www.gutenberg.org/files/135/135-0.txt\"\ntext = response.body\n\ntext\n  .downcase\n  .scan(/[a-zA-Z\u00e1\u00e9\u00ed\u00f3\u00fa\u00c1\u00c9\u00cd\u00d3\u00da\u00e2\u00ea\u00f4\u00e4\u00fc\u00f6\u00e0\u00e8\u00ec\u00f2\u00f9\u00f1']+/)\n  .reduce({} of String => Int32) { |hash, match|\n    word = match[0]\n    hash[word] = hash.fetch(word, 0) + 1 \n    hash\n  }\n  .to_a                                        \n  .sort { |a, b| b[1] <=> a[1] }[0..9]         \n  .each_with_index(1) { |(word, n), i| puts \"\n", "target": "import java.io.IOException;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.nio.file.Paths;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\nimport java.util.stream.Collectors;\n\npublic class WordCount {\n    public static void main(String[] args) throws IOException {\n        Path path = Paths.get(\"135-0.txt\");\n        byte[] bytes = Files.readAllBytes(path);\n        String text = new String(bytes);\n        text = text.toLowerCase();\n\n        Pattern r = Pattern.compile(\"\\\\p{javaLowerCase}+\");\n        Matcher matcher = r.matcher(text);\n        Map<String, Integer> freq = new HashMap<>();\n        while (matcher.find()) {\n            String word = matcher.group();\n            Integer current = freq.getOrDefault(word, 0);\n            freq.put(word, current + 1);\n        }\n\n        List<Map.Entry<String, Integer>> entries = freq.entrySet()\n            .stream()\n            .sorted((i1, i2) -> Integer.compare(i2.getValue(), i1.getValue()))\n            .limit(10)\n            .collect(Collectors.toList());\n\n        System.out.println(\"Rank  Word  Frequency\");\n        System.out.println(\"====  ====  =========\");\n        int rank = 1;\n        for (Map.Entry<String, Integer> entry : entries) {\n            String word = entry.getKey();\n            Integer count = entry.getValue();\n            System.out.printf(\"%2d   \u00a0%-4s    %5d\\n\", rank++, word, count);\n        }\n    }\n}\n"}
{"id": 52704, "name": "Word frequency", "source": "Translate Ruby to Java: require \"http/client\"\nrequire \"regex\"\n\n\nresponse = HTTP::Client.get \"https://www.gutenberg.org/files/135/135-0.txt\"\ntext = response.body\n\ntext\n  .downcase\n  .scan(/[a-zA-Z\u00e1\u00e9\u00ed\u00f3\u00fa\u00c1\u00c9\u00cd\u00d3\u00da\u00e2\u00ea\u00f4\u00e4\u00fc\u00f6\u00e0\u00e8\u00ec\u00f2\u00f9\u00f1']+/)\n  .reduce({} of String => Int32) { |hash, match|\n    word = match[0]\n    hash[word] = hash.fetch(word, 0) + 1 \n    hash\n  }\n  .to_a                                        \n  .sort { |a, b| b[1] <=> a[1] }[0..9]         \n  .each_with_index(1) { |(word, n), i| puts \"\n", "target": "import java.io.IOException;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.nio.file.Paths;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\nimport java.util.stream.Collectors;\n\npublic class WordCount {\n    public static void main(String[] args) throws IOException {\n        Path path = Paths.get(\"135-0.txt\");\n        byte[] bytes = Files.readAllBytes(path);\n        String text = new String(bytes);\n        text = text.toLowerCase();\n\n        Pattern r = Pattern.compile(\"\\\\p{javaLowerCase}+\");\n        Matcher matcher = r.matcher(text);\n        Map<String, Integer> freq = new HashMap<>();\n        while (matcher.find()) {\n            String word = matcher.group();\n            Integer current = freq.getOrDefault(word, 0);\n            freq.put(word, current + 1);\n        }\n\n        List<Map.Entry<String, Integer>> entries = freq.entrySet()\n            .stream()\n            .sorted((i1, i2) -> Integer.compare(i2.getValue(), i1.getValue()))\n            .limit(10)\n            .collect(Collectors.toList());\n\n        System.out.println(\"Rank  Word  Frequency\");\n        System.out.println(\"====  ====  =========\");\n        int rank = 1;\n        for (Map.Entry<String, Integer> entry : entries) {\n            String word = entry.getKey();\n            Integer count = entry.getValue();\n            System.out.printf(\"%2d   \u00a0%-4s    %5d\\n\", rank++, word, count);\n        }\n    }\n}\n"}
{"id": 52705, "name": "Word frequency", "source": "Translate Ruby to Python: require \"http/client\"\nrequire \"regex\"\n\n\nresponse = HTTP::Client.get \"https://www.gutenberg.org/files/135/135-0.txt\"\ntext = response.body\n\ntext\n  .downcase\n  .scan(/[a-zA-Z\u00e1\u00e9\u00ed\u00f3\u00fa\u00c1\u00c9\u00cd\u00d3\u00da\u00e2\u00ea\u00f4\u00e4\u00fc\u00f6\u00e0\u00e8\u00ec\u00f2\u00f9\u00f1']+/)\n  .reduce({} of String => Int32) { |hash, match|\n    word = match[0]\n    hash[word] = hash.fetch(word, 0) + 1 \n    hash\n  }\n  .to_a                                        \n  .sort { |a, b| b[1] <=> a[1] }[0..9]         \n  .each_with_index(1) { |(word, n), i| puts \"\n", "target": "import collections\nimport re\nimport string\nimport sys\n\ndef main():\n  counter = collections.Counter(re.findall(r\"\\w+\",open(sys.argv[1]).read().lower()))\n  print counter.most_common(int(sys.argv[2]))\n\nif __name__ == \"__main__\":\n  main()\n"}
{"id": 52706, "name": "Word frequency", "source": "Translate Ruby to Python: require \"http/client\"\nrequire \"regex\"\n\n\nresponse = HTTP::Client.get \"https://www.gutenberg.org/files/135/135-0.txt\"\ntext = response.body\n\ntext\n  .downcase\n  .scan(/[a-zA-Z\u00e1\u00e9\u00ed\u00f3\u00fa\u00c1\u00c9\u00cd\u00d3\u00da\u00e2\u00ea\u00f4\u00e4\u00fc\u00f6\u00e0\u00e8\u00ec\u00f2\u00f9\u00f1']+/)\n  .reduce({} of String => Int32) { |hash, match|\n    word = match[0]\n    hash[word] = hash.fetch(word, 0) + 1 \n    hash\n  }\n  .to_a                                        \n  .sort { |a, b| b[1] <=> a[1] }[0..9]         \n  .each_with_index(1) { |(word, n), i| puts \"\n", "target": "import collections\nimport re\nimport string\nimport sys\n\ndef main():\n  counter = collections.Counter(re.findall(r\"\\w+\",open(sys.argv[1]).read().lower()))\n  print counter.most_common(int(sys.argv[2]))\n\nif __name__ == \"__main__\":\n  main()\n"}
{"id": 53051, "name": "Ascending primes", "source": "Translate Ruby to C#: require 'prime'\n\ndigits = [9,8,7,6,5,4,3,2,1]\nres = 1.upto(digits.size).flat_map do |n|\n   digits.combination(n).filter_map do |set|\n      candidate = set.join.to_i\n      candidate if candidate.prime?\n   end.reverse\n end\n\n puts res.join(\",\")\n", "target": "using System;\nusing System.Collections.Generic;\n\nnamespace ascendingprimes\n{\n    class Program\n    {\n        static bool isPrime(uint n)\n        {\n            if (n == 2)\n                return true;\n            if (n == 1 || n % 2 = 0)\n                return false;\n            uint root = (uint)Math.Sqrt(n);\n            for (uint k = 3; k <= root; k += 2)\n                if (n % k == 0)\n                    return false;\n            return true;\n        }\n        static void Main(string[] args)\n        {\n            var queue = new Queue<uint>();\n            var primes = new List<uint>();\n\n            for (uint k = 1; k <= 9; k++)\n                queue.Enqueue(k);\n            while(queue.Count > 0)\n            {\n                uint n = queue.Dequeue();\n                if (isPrime(n))\n                    primes.Add(n);\n                for (uint k = n % 10 + 1; k <= 9; k++)\n                    queue.Enqueue(n * 10 + k);\n            }\n\n            foreach (uint p in primes)\n            {\n                Console.Write(p);\n                Console.Write(\" \");\n            }\n            Console.WriteLine();\n        }\n    }\n}\n"}
{"id": 53052, "name": "Ascending primes", "source": "Translate Ruby to C#: require 'prime'\n\ndigits = [9,8,7,6,5,4,3,2,1]\nres = 1.upto(digits.size).flat_map do |n|\n   digits.combination(n).filter_map do |set|\n      candidate = set.join.to_i\n      candidate if candidate.prime?\n   end.reverse\n end\n\n puts res.join(\",\")\n", "target": "using System;\nusing System.Collections.Generic;\n\nnamespace ascendingprimes\n{\n    class Program\n    {\n        static bool isPrime(uint n)\n        {\n            if (n == 2)\n                return true;\n            if (n == 1 || n % 2 = 0)\n                return false;\n            uint root = (uint)Math.Sqrt(n);\n            for (uint k = 3; k <= root; k += 2)\n                if (n % k == 0)\n                    return false;\n            return true;\n        }\n        static void Main(string[] args)\n        {\n            var queue = new Queue<uint>();\n            var primes = new List<uint>();\n\n            for (uint k = 1; k <= 9; k++)\n                queue.Enqueue(k);\n            while(queue.Count > 0)\n            {\n                uint n = queue.Dequeue();\n                if (isPrime(n))\n                    primes.Add(n);\n                for (uint k = n % 10 + 1; k <= 9; k++)\n                    queue.Enqueue(n * 10 + k);\n            }\n\n            foreach (uint p in primes)\n            {\n                Console.Write(p);\n                Console.Write(\" \");\n            }\n            Console.WriteLine();\n        }\n    }\n}\n"}
{"id": 53055, "name": "Ascending primes", "source": "Translate Ruby to Java: require 'prime'\n\ndigits = [9,8,7,6,5,4,3,2,1]\nres = 1.upto(digits.size).flat_map do |n|\n   digits.combination(n).filter_map do |set|\n      candidate = set.join.to_i\n      candidate if candidate.prime?\n   end.reverse\n end\n\n puts res.join(\",\")\n", "target": "\n\npackage example.rossetacode.ascendingprimes;\n\nimport java.util.Arrays;\n\npublic class Program implements Runnable {\n\n    public static void main(String[] args) {\n        long t1 = System.nanoTime();\n        new Program().run();\n        long t2 = System.nanoTime();\n        System.out.println(\n                \"total time consumed = \" + (t2 - t1) * 1E-6 + \" milliseconds\");\n    }\n\n    public void run() {\n\n        final int MAX_SIZE = 1000;\n        final int[] queue = new int[MAX_SIZE];\n        int begin = 0;\n        int end = 0;\n\n        for (int k = 1; k <= 9; k++) {\n            queue[end++] = k;\n        }\n\n        while (begin < end) {\n            int n = queue[begin++];\n            for (int k = n % 10 + 1; k <= 9; k++) {\n                queue[end++] = n * 10 + k;\n            }\n        }\n\n        \n        \n        \n        System.out.println(Arrays.stream(queue).filter(this::isPrime).boxed().toList());\n    }\n\n    private boolean isPrime(int n) {\n        if (n == 2) {\n            return true;\n        }\n        if (n == 1 || n % 2 == 0) {\n            return false;\n        }\n        int root = (int) Math.sqrt(n);\n        for (int k = 3; k <= root; k += 2) {\n            if (n % k == 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\n"}
{"id": 53056, "name": "Ascending primes", "source": "Translate Ruby to Java: require 'prime'\n\ndigits = [9,8,7,6,5,4,3,2,1]\nres = 1.upto(digits.size).flat_map do |n|\n   digits.combination(n).filter_map do |set|\n      candidate = set.join.to_i\n      candidate if candidate.prime?\n   end.reverse\n end\n\n puts res.join(\",\")\n", "target": "\n\npackage example.rossetacode.ascendingprimes;\n\nimport java.util.Arrays;\n\npublic class Program implements Runnable {\n\n    public static void main(String[] args) {\n        long t1 = System.nanoTime();\n        new Program().run();\n        long t2 = System.nanoTime();\n        System.out.println(\n                \"total time consumed = \" + (t2 - t1) * 1E-6 + \" milliseconds\");\n    }\n\n    public void run() {\n\n        final int MAX_SIZE = 1000;\n        final int[] queue = new int[MAX_SIZE];\n        int begin = 0;\n        int end = 0;\n\n        for (int k = 1; k <= 9; k++) {\n            queue[end++] = k;\n        }\n\n        while (begin < end) {\n            int n = queue[begin++];\n            for (int k = n % 10 + 1; k <= 9; k++) {\n                queue[end++] = n * 10 + k;\n            }\n        }\n\n        \n        \n        \n        System.out.println(Arrays.stream(queue).filter(this::isPrime).boxed().toList());\n    }\n\n    private boolean isPrime(int n) {\n        if (n == 2) {\n            return true;\n        }\n        if (n == 1 || n % 2 == 0) {\n            return false;\n        }\n        int root = (int) Math.sqrt(n);\n        for (int k = 3; k <= root; k += 2) {\n            if (n % k == 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\n"}
{"id": 53057, "name": "Ascending primes", "source": "Translate Ruby to Python: require 'prime'\n\ndigits = [9,8,7,6,5,4,3,2,1]\nres = 1.upto(digits.size).flat_map do |n|\n   digits.combination(n).filter_map do |set|\n      candidate = set.join.to_i\n      candidate if candidate.prime?\n   end.reverse\n end\n\n puts res.join(\",\")\n", "target": "from sympy import isprime\n\ndef ascending(x=0):\n    for y in range(x*10 + (x%10) + 1, x*10 + 10):\n        yield from ascending(y)\n        yield(y)\n\nprint(sorted(x for x in ascending() if isprime(x)))\n"}
{"id": 53058, "name": "Ascending primes", "source": "Translate Ruby to Python: require 'prime'\n\ndigits = [9,8,7,6,5,4,3,2,1]\nres = 1.upto(digits.size).flat_map do |n|\n   digits.combination(n).filter_map do |set|\n      candidate = set.join.to_i\n      candidate if candidate.prime?\n   end.reverse\n end\n\n puts res.join(\",\")\n", "target": "from sympy import isprime\n\ndef ascending(x=0):\n    for y in range(x*10 + (x%10) + 1, x*10 + 10):\n        yield from ascending(y)\n        yield(y)\n\nprint(sorted(x for x in ascending() if isprime(x)))\n"}
{"id": 53230, "name": "Tic-tac-toe", "source": "Translate Ruby to C#: module TicTacToe\n  LINES = [[1,2,3],[4,5,6],[7,8,9],[1,4,7],[2,5,8],[3,6,9],[1,5,9],[3,5,7]]\n  \n  class Game\n    def initialize(player_1_class, player_2_class)\n      @board = Array.new(10) \n      \n      @current_player_id = 0\n      @players = [player_1_class.new(self, \"X\"), player_2_class.new(self, \"O\")]\n      puts \"\n    end\n    attr_reader :board, :current_player_id\n    \n    def play\n      loop do\n        place_player_marker(current_player)\n        \n        if player_has_won?(current_player)\n          puts \"\n          print_board\n          return\n        elsif board_full?\n          puts \"It's a draw.\"\n          print_board\n          return\n        end\n        \n        switch_players!\n      end\n    end\n    \n    def free_positions\n      (1..9).select {|position| @board[position].nil?}\n    end\n    \n    def place_player_marker(player)\n      position = player.select_position!\n      puts \"\n      @board[position] = player.marker\n    end\n    \n    def player_has_won?(player)\n      LINES.any? do |line|\n        line.all? {|position| @board[position] == player.marker}\n      end\n    end\n    \n    def board_full?\n      free_positions.empty?\n    end\n    \n    def other_player_id\n      1 - @current_player_id\n    end\n    \n    def switch_players!\n      @current_player_id = other_player_id\n    end\n    \n    def current_player\n      @players[current_player_id]\n    end\n    \n    def opponent\n      @players[other_player_id]\n    end\n    \n    def turn_num\n      10 - free_positions.size\n    end\n    \n    def print_board\n      col_separator, row_separator = \" | \", \"--+---+--\"\n      label_for_position = lambda{|position| @board[position] ? @board[position] : position}\n      \n      row_for_display = lambda{|row| row.map(&label_for_position).join(col_separator)}\n      row_positions = [[1,2,3], [4,5,6], [7,8,9]]\n      rows_for_display = row_positions.map(&row_for_display)\n      puts rows_for_display.join(\"\\n\" + row_separator + \"\\n\")\n    end\n  end\n  \n  class Player\n    def initialize(game, marker)\n      @game = game\n      @marker = marker\n    end\n    attr_reader :marker\n  end\n  \n  class HumanPlayer < Player\n    def select_position!\n      @game.print_board\n      loop do\n        print \"Select your \n        selection = gets.to_i\n        return selection if @game.free_positions.include?(selection)\n        puts \"Position \n      end\n    end\n    \n    def to_s\n      \"Human\"\n    end\n  end\n  \n  class ComputerPlayer < Player\n    DEBUG = false \n    \n    def group_positions_by_markers(line)\n      markers = line.group_by {|position| @game.board[position]}\n      markers.default = []\n      markers\n    end\n    \n    def select_position!\n      opponent_marker = @game.opponent.marker\n      \n      winning_or_blocking_position = look_for_winning_or_blocking_position(opponent_marker)\n      return winning_or_blocking_position if winning_or_blocking_position\n      \n      if corner_trap_defense_needed?\n        return corner_trap_defense_position(opponent_marker)\n      end\n      \n      \n      \n      return random_prioritized_position\n    end\n    \n    def look_for_winning_or_blocking_position(opponent_marker)\n      for line in LINES\n        markers = group_positions_by_markers(line)\n        next if markers[nil].length != 1\n        if markers[self.marker].length == 2\n          log_debug \"winning on line \n          return markers[nil].first\n        elsif markers[opponent_marker].length == 2\n          log_debug \"could block on line \n          blocking_position = markers[nil].first\n        end\n      end\n      if blocking_position\n        log_debug \"blocking at \n        return blocking_position\n      end\n    end\n    \n    def corner_trap_defense_needed?\n      corner_positions = [1, 3, 7, 9]\n      opponent_chose_a_corner = corner_positions.any?{|pos| @game.board[pos] != nil}\n      return @game.turn_num == 2 && opponent_chose_a_corner\n    end\n    \n    def corner_trap_defense_position(opponent_marker)\n      \n      log_debug \"defending against corner start by playing adjacent\"\n      \n      opponent_position = @game.board.find_index {|marker| marker == opponent_marker}\n      safe_responses = {1=>[2,4], 3=>[2,6], 7=>[4,8], 9=>[6,8]}\n      return safe_responses[opponent_position].sample\n    end\n    \n    def random_prioritized_position\n      log_debug \"picking random position, favoring center and then corners\"\n      ([5] + [1,3,7,9].shuffle + [2,4,6,8].shuffle).find do |pos|\n        @game.free_positions.include?(pos)\n      end\n    end\n    \n    def log_debug(message)\n      puts \"\n    end\n    \n    def to_s\n      \"Computer\n    end\n  end\nend\n \ninclude TicTacToe\n\nGame.new(ComputerPlayer, ComputerPlayer).play\nputs\nplayers_with_human = [HumanPlayer, ComputerPlayer].shuffle\nGame.new(*players_with_human).play\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\nnamespace RosettaTicTacToe\n{\n  class Program\n  {\n\n    \n    static string[][] Players = new string[][] { \n      new string[] { \"COMPUTER\", \"X\" }, \n      new string[] { \"HUMAN\", \"O\" }     \n    };\n\n    const int Unplayed = -1;\n    const int Computer = 0;\n    const int Human = 1;\n\n    \n    static int[] GameBoard = new int[9];\n\n    static int[] corners = new int[] { 0, 2, 6, 8 };\n\n    static int[][] wins = new int[][] { \n      new int[] { 0, 1, 2 }, new int[] { 3, 4, 5 }, new int[] { 6, 7, 8 }, \n      new int[] { 0, 3, 6 }, new int[] { 1, 4, 7 }, new int[] { 2, 5, 8 }, \n      new int[] { 0, 4, 8 }, new int[] { 2, 4, 6 } };\n\n\n    \n    static void Main(string[] args)\n    {\n      while (true)\n      {\n        Console.Clear();\n        Console.WriteLine(\"Welcome to Rosetta Code Tic-Tac-Toe for C#.\");\n        initializeGameBoard();\n        displayGameBoard();\n        int currentPlayer = rnd.Next(0, 2);  \n        Console.WriteLine(\"The first move goes to {0} who is playing {1}s.\\n\", playerName(currentPlayer), playerToken(currentPlayer));\n        while (true)\n        {\n          int thisMove = getMoveFor(currentPlayer);\n          if (thisMove == Unplayed)\n          {\n            Console.WriteLine(\"{0}, you've quit the game ... am I that good?\", playerName(currentPlayer));\n            break;\n          }\n          playMove(thisMove, currentPlayer);\n          displayGameBoard();\n          if (isGameWon())\n          {\n            Console.WriteLine(\"{0} has won the game!\", playerName(currentPlayer));\n            break;\n          }\n          else if (isGameTied())\n          {\n            Console.WriteLine(\"Cat game ... we have a tie.\");\n            break;\n          }\n          currentPlayer = getNextPlayer(currentPlayer);\n        }\n        if (!playAgain())\n          return;\n      }\n    }\n\n    \n    static int getMoveFor(int player)\n    {\n      if (player == Human)\n        return getManualMove(player);\n      else\n      {\n        \n        \n        int selectedMove = getSemiRandomMove(player);\n        \n        Console.WriteLine(\"{0} selects position {1}.\", playerName(player), selectedMove + 1);\n        return selectedMove;\n      }\n    }\n\n    static int getManualMove(int player)\n    {\n      while (true)\n      {\n        Console.Write(\"{0}, enter you move (number): \", playerName(player));\n        ConsoleKeyInfo keyInfo = Console.ReadKey();\n        Console.WriteLine();  \n        if (keyInfo.Key == ConsoleKey.Escape)\n          return Unplayed;\n        if (keyInfo.Key >= ConsoleKey.D1 && keyInfo.Key <= ConsoleKey.D9)\n        {\n          int move = keyInfo.KeyChar - '1';  \n          if (GameBoard[move] == Unplayed)\n            return move;\n          else\n            Console.WriteLine(\"Spot {0} is already taken, please select again.\", move + 1);\n        }\n        else\n          Console.WriteLine(\"Illegal move, please select again.\\n\");\n      }\n    }\n\n    static int getRandomMove(int player)\n    {\n      int movesLeft = GameBoard.Count(position => position == Unplayed);\n      int x = rnd.Next(0, movesLeft);\n      for (int i = 0; i < GameBoard.Length; i++)  \n      {\n        if (GameBoard[i] == Unplayed && x < 0)    \n          return i;\n        x--;\n      }\n      return Unplayed;\n    }\n\n    \n    static int getSemiRandomMove(int player)\n    {\n      int posToPlay;\n      if (checkForWinningMove(player, out posToPlay))\n        return posToPlay;\n      if (checkForBlockingMove(player, out posToPlay))\n        return posToPlay;\n      return getRandomMove(player);\n    }\n\n    \n    static int getBestMove(int player)\n    {\n      return -1;\n    }\n\n    static bool checkForWinningMove(int player, out int posToPlay)\n    {\n      posToPlay = Unplayed;\n      foreach (var line in wins)\n        if (twoOfThreeMatchPlayer(player, line, out posToPlay))\n          return true;\n      return false;\n    }\n\n    static bool checkForBlockingMove(int player, out int posToPlay)\n    {\n      posToPlay = Unplayed;\n      foreach (var line in wins)\n        if (twoOfThreeMatchPlayer(getNextPlayer(player), line, out posToPlay))\n          return true;\n      return false;\n    }\n\n    static bool twoOfThreeMatchPlayer(int player, int[] line, out int posToPlay)\n    {\n      int cnt = 0;\n      posToPlay = int.MinValue;\n      foreach (int pos in line)\n      {\n        if (GameBoard[pos] == player)\n          cnt++;\n        else if (GameBoard[pos] == Unplayed)\n          posToPlay = pos;\n      }\n      return cnt == 2 && posToPlay >= 0;\n    }\n\n    static void playMove(int boardPosition, int player)\n    {\n      GameBoard[boardPosition] = player;\n    }\n\n    static bool isGameWon()\n    {\n      return wins.Any(line => takenBySamePlayer(line[0], line[1], line[2]));\n    }\n\n    static bool takenBySamePlayer(int a, int b, int c)\n    {\n      return GameBoard[a] != Unplayed && GameBoard[a] == GameBoard[b] && GameBoard[a] == GameBoard[c];\n    }\n\n    static bool isGameTied()\n    {\n      return !GameBoard.Any(spot => spot == Unplayed);\n    }\n\n    \n    static Random rnd = new Random();\n\n    static void initializeGameBoard()\n    {\n      for (int i = 0; i < GameBoard.Length; i++)\n        GameBoard[i] = Unplayed;\n    }\n\n    static string playerName(int player)\n    {\n      return Players[player][0];\n    }\n\n    static string playerToken(int player)\n    {\n      return Players[player][1];\n    }\n\n    static int getNextPlayer(int player)\n    {\n      return (player + 1) % 2;\n    }\n\n    static void displayGameBoard()\n    {\n      Console.WriteLine(\" {0} | {1} | {2}\", pieceAt(0), pieceAt(1), pieceAt(2));\n      Console.WriteLine(\"---|---|---\");\n      Console.WriteLine(\" {0} | {1} | {2}\", pieceAt(3), pieceAt(4), pieceAt(5));\n      Console.WriteLine(\"---|---|---\");\n      Console.WriteLine(\" {0} | {1} | {2}\", pieceAt(6), pieceAt(7), pieceAt(8));\n      Console.WriteLine();\n    }\n\n    static string pieceAt(int boardPosition)\n    {\n      if (GameBoard[boardPosition] == Unplayed)\n        return (boardPosition + 1).ToString();  \n      return playerToken(GameBoard[boardPosition]);\n    }\n\n    private static bool playAgain()\n    {\n      Console.WriteLine(\"\\nDo you want to play again?\");\n      return Console.ReadKey(false).Key == ConsoleKey.Y;\n    }\n  }\n\n}\n"}
{"id": 53232, "name": "Tic-tac-toe", "source": "Translate Ruby to Python: module TicTacToe\n  LINES = [[1,2,3],[4,5,6],[7,8,9],[1,4,7],[2,5,8],[3,6,9],[1,5,9],[3,5,7]]\n  \n  class Game\n    def initialize(player_1_class, player_2_class)\n      @board = Array.new(10) \n      \n      @current_player_id = 0\n      @players = [player_1_class.new(self, \"X\"), player_2_class.new(self, \"O\")]\n      puts \"\n    end\n    attr_reader :board, :current_player_id\n    \n    def play\n      loop do\n        place_player_marker(current_player)\n        \n        if player_has_won?(current_player)\n          puts \"\n          print_board\n          return\n        elsif board_full?\n          puts \"It's a draw.\"\n          print_board\n          return\n        end\n        \n        switch_players!\n      end\n    end\n    \n    def free_positions\n      (1..9).select {|position| @board[position].nil?}\n    end\n    \n    def place_player_marker(player)\n      position = player.select_position!\n      puts \"\n      @board[position] = player.marker\n    end\n    \n    def player_has_won?(player)\n      LINES.any? do |line|\n        line.all? {|position| @board[position] == player.marker}\n      end\n    end\n    \n    def board_full?\n      free_positions.empty?\n    end\n    \n    def other_player_id\n      1 - @current_player_id\n    end\n    \n    def switch_players!\n      @current_player_id = other_player_id\n    end\n    \n    def current_player\n      @players[current_player_id]\n    end\n    \n    def opponent\n      @players[other_player_id]\n    end\n    \n    def turn_num\n      10 - free_positions.size\n    end\n    \n    def print_board\n      col_separator, row_separator = \" | \", \"--+---+--\"\n      label_for_position = lambda{|position| @board[position] ? @board[position] : position}\n      \n      row_for_display = lambda{|row| row.map(&label_for_position).join(col_separator)}\n      row_positions = [[1,2,3], [4,5,6], [7,8,9]]\n      rows_for_display = row_positions.map(&row_for_display)\n      puts rows_for_display.join(\"\\n\" + row_separator + \"\\n\")\n    end\n  end\n  \n  class Player\n    def initialize(game, marker)\n      @game = game\n      @marker = marker\n    end\n    attr_reader :marker\n  end\n  \n  class HumanPlayer < Player\n    def select_position!\n      @game.print_board\n      loop do\n        print \"Select your \n        selection = gets.to_i\n        return selection if @game.free_positions.include?(selection)\n        puts \"Position \n      end\n    end\n    \n    def to_s\n      \"Human\"\n    end\n  end\n  \n  class ComputerPlayer < Player\n    DEBUG = false \n    \n    def group_positions_by_markers(line)\n      markers = line.group_by {|position| @game.board[position]}\n      markers.default = []\n      markers\n    end\n    \n    def select_position!\n      opponent_marker = @game.opponent.marker\n      \n      winning_or_blocking_position = look_for_winning_or_blocking_position(opponent_marker)\n      return winning_or_blocking_position if winning_or_blocking_position\n      \n      if corner_trap_defense_needed?\n        return corner_trap_defense_position(opponent_marker)\n      end\n      \n      \n      \n      return random_prioritized_position\n    end\n    \n    def look_for_winning_or_blocking_position(opponent_marker)\n      for line in LINES\n        markers = group_positions_by_markers(line)\n        next if markers[nil].length != 1\n        if markers[self.marker].length == 2\n          log_debug \"winning on line \n          return markers[nil].first\n        elsif markers[opponent_marker].length == 2\n          log_debug \"could block on line \n          blocking_position = markers[nil].first\n        end\n      end\n      if blocking_position\n        log_debug \"blocking at \n        return blocking_position\n      end\n    end\n    \n    def corner_trap_defense_needed?\n      corner_positions = [1, 3, 7, 9]\n      opponent_chose_a_corner = corner_positions.any?{|pos| @game.board[pos] != nil}\n      return @game.turn_num == 2 && opponent_chose_a_corner\n    end\n    \n    def corner_trap_defense_position(opponent_marker)\n      \n      log_debug \"defending against corner start by playing adjacent\"\n      \n      opponent_position = @game.board.find_index {|marker| marker == opponent_marker}\n      safe_responses = {1=>[2,4], 3=>[2,6], 7=>[4,8], 9=>[6,8]}\n      return safe_responses[opponent_position].sample\n    end\n    \n    def random_prioritized_position\n      log_debug \"picking random position, favoring center and then corners\"\n      ([5] + [1,3,7,9].shuffle + [2,4,6,8].shuffle).find do |pos|\n        @game.free_positions.include?(pos)\n      end\n    end\n    \n    def log_debug(message)\n      puts \"\n    end\n    \n    def to_s\n      \"Computer\n    end\n  end\nend\n \ninclude TicTacToe\n\nGame.new(ComputerPlayer, ComputerPlayer).play\nputs\nplayers_with_human = [HumanPlayer, ComputerPlayer].shuffle\nGame.new(*players_with_human).play\n", "target": "\n\nimport random\n\nboard = list('123456789')\nwins = ((0,1,2), (3,4,5), (6,7,8),\n        (0,3,6), (1,4,7), (2,5,8),\n        (0,4,8), (2,4,6))\n\ndef printboard():\n    print('\\n'.join(' '.join(board[x:x+3]) for x in(0,3,6)))\n\ndef score():\n    for w in wins:\n        b = board[w[0]]\n        if b in 'XO' and all (board[i] == b for i in w):\n            return b, [i+1 for i in w]\n    return None, None\n\ndef finished():\n    return all (b in 'XO' for b in board)\n\ndef space():\n    return [ b for b in board if b not in 'XO']\n\ndef my_turn(xo):\n    options = space()\n    choice = random.choice(options)\n    board[int(choice)-1] = xo\n    return choice\n\ndef your_turn(xo):\n    options = space()\n    while True:\n        choice = input(\" Put your %s in any of these positions: %s \"\n                       % (xo, ''.join(options))).strip()\n        if choice in options:\n            break\n        print( \"Whoops I don't understand the input\" )\n    board[int(choice)-1] = xo\n    return choice\n\ndef me(xo='X'):\n    printboard()\n    print('I go at', my_turn(xo))\n    return score()\n    assert not s[0], \"\\n%s wins across %s\" % s\n\ndef you(xo='O'):\n    printboard()\n    \n    print('You went at', your_turn(xo))\n    return score()\n    assert not s[0], \"\\n%s wins across %s\" % s\n\n\nprint(__doc__)\nwhile not finished():\n    s = me('X')\n    if s[0]:\n        printboard()\n        print(\"\\n%s wins across %s\" % s)\n        break\n    if not finished():\n        s = you('O')\n        if s[0]:\n            printboard()\n            print(\"\\n%s wins across %s\" % s)\n            break\nelse:\n    print('\\nA draw')\n"}
{"id": 53486, "name": "Pick random element", "source": "Translate Ruby to C#: puts [1, 2, 3, 4, 5].sample(1)\n", "target": "using System;\nusing System.Collections.Generic;\n\nclass RandomElementPicker {\n  static void Main() {\n    var list = new List<int>(new[]{0, 1, 2, 3, 4, 5, 6, 7, 8, 9});\n    var rng = new Random();\n    var randomElement = list[rng.Next(list.Count)];\n    Console.WriteLine(\"I picked element {0}\", randomElement);\n  }\n}\n"}
{"id": 53488, "name": "Pick random element", "source": "Translate Ruby to Java: puts [1, 2, 3, 4, 5].sample(1)\n", "target": "import java.util.Random;\n...\nint[] array = {1,2,3};\nreturn array[new Random().nextInt(array.length)]; \n"}
{"id": 53489, "name": "Pick random element", "source": "Translate Ruby to Python: puts [1, 2, 3, 4, 5].sample(1)\n", "target": ">>> import random\n>>> random.choice(['foo', 'bar', 'baz'])\n'baz'\n"}
{"id": 53742, "name": "Jensen's Device", "source": "Translate Ruby to C#: def sum(var, lo, hi, term, context)\n  sum = 0.0\n  lo.upto(hi) do |n|\n    sum += eval \"\n  end\n  sum\nend\np sum \"i\", 1, 100, \"1.0 / i\", binding   \n", "target": "using System;\n\nclass JensensDevice\n{    \n    public static double Sum(ref int i, int lo, int hi, Func<double> term)\n    {\n        double temp = 0.0;\n        for (i = lo; i <= hi; i++)\n        {\n            temp += term();\n        }\n        return temp;\n    }\n\n    static void Main()\n    {\n        int i = 0;\n        Console.WriteLine(Sum(ref i, 1, 100, () => 1.0 / i));\n    }\n}\n"}
{"id": 53744, "name": "Jensen's Device", "source": "Translate Ruby to Java: def sum(var, lo, hi, term, context)\n  sum = 0.0\n  lo.upto(hi) do |n|\n    sum += eval \"\n  end\n  sum\nend\np sum \"i\", 1, 100, \"1.0 / i\", binding   \n", "target": "import java.util.function.*;\nimport java.util.stream.*;\n\npublic class Jensen {\n    static double sum(int lo, int hi, IntToDoubleFunction f) {\n        return IntStream.rangeClosed(lo, hi).mapToDouble(f).sum();\n    }\n        \n    public static void main(String args[]) {\n        System.out.println(sum(1, 100, (i -> 1.0/i)));\n    }\n}\n"}
{"id": 53745, "name": "Jensen's Device", "source": "Translate Ruby to Python: def sum(var, lo, hi, term, context)\n  sum = 0.0\n  lo.upto(hi) do |n|\n    sum += eval \"\n  end\n  sum\nend\np sum \"i\", 1, 100, \"1.0 / i\", binding   \n", "target": "class Ref(object):\n    def __init__(self, value=None):\n        self.value = value\n\ndef harmonic_sum(i, lo, hi, term):\n    \n    temp = 0\n    i.value = lo\n    while i.value <= hi:  \n        temp += term() \n        i.value += 1   \n    return temp\n\ni = Ref()\n\n\n\nprint harmonic_sum(i, 1, 100, lambda: 1.0/i.value)\n"}
{"id": 54018, "name": "Greatest element of a list", "source": "Translate Ruby to C#: values.max\n", "target": "int[] values = new int[] {1,2,3,4,5,6,7,8,9,10};\n\nint max = values.Max();\n"}
{"id": 54020, "name": "Greatest element of a list", "source": "Translate Ruby to Java: values.max\n", "target": "public static float max(float[] values) throws NoSuchElementException {\n    if (values.length == 0)\n        throw new NoSuchElementException();\n    float themax = values[0];\n    for (int idx = 1; idx < values.length; ++idx) {\n        if (values[idx] > themax)\n            themax = values[idx];\n    }\n    return themax;\n}\n"}
{"id": 54125, "name": "Safe addition", "source": "Translate Ruby to C#: require 'bigdecimal'\nrequire 'bigdecimal/util'  \n\ndef safe_add(a, b, prec)\n  a, b = a.to_d, b.to_d\n  rm = BigDecimal::ROUND_MODE\n  orig = BigDecimal.mode(rm)\n\n  BigDecimal.mode(rm, BigDecimal::ROUND_FLOOR)\n  low = a.add(b, prec)\n\n  BigDecimal.mode(rm, BigDecimal::ROUND_CEILING)\n  high = a.add(b, prec)\n\n  BigDecimal.mode(rm, orig)\n  low..high\nend\n\n[[\"1\", \"2\"],\n [\"0.1\", \"0.2\"],\n [\"0.1\", \"0.00002\"],\n [\"0.1\", \"-0.00002\"],\n].each { |a, b| puts \"\n", "target": "using System;\n\nnamespace SafeAddition {\n    class Program {\n        static float NextUp(float d) {\n            if (d == 0.0) return float.Epsilon;\n            if (float.IsNaN(d) || float.IsNegativeInfinity(d) || float.IsPositiveInfinity(d)) return d;\n\n            byte[] bytes = BitConverter.GetBytes(d);\n            int dl = BitConverter.ToInt32(bytes, 0);\n            dl++;\n            bytes = BitConverter.GetBytes(dl);\n\n            return BitConverter.ToSingle(bytes, 0);\n        }\n\n        static float NextDown(float d) {\n            if (d == 0.0) return -float.Epsilon;\n            if (float.IsNaN(d) || float.IsNegativeInfinity(d) || float.IsPositiveInfinity(d)) return d;\n\n            byte[] bytes = BitConverter.GetBytes(d);\n            int dl = BitConverter.ToInt32(bytes, 0);\n            dl--;\n            bytes = BitConverter.GetBytes(dl);\n\n            return BitConverter.ToSingle(bytes, 0);\n        }\n\n        static Tuple<float, float> SafeAdd(float a, float b) {\n            return new Tuple<float, float>(NextDown(a + b), NextUp(a + b));\n        }\n\n        static void Main(string[] args) {\n            float a = 1.20f;\n            float b = 0.03f;\n\n            Console.WriteLine(\"({0} + {1}) is in the range {2}\", a, b, SafeAdd(a, b));\n        }\n    }\n}\n"}
{"id": 54127, "name": "Safe addition", "source": "Translate Ruby to Java: require 'bigdecimal'\nrequire 'bigdecimal/util'  \n\ndef safe_add(a, b, prec)\n  a, b = a.to_d, b.to_d\n  rm = BigDecimal::ROUND_MODE\n  orig = BigDecimal.mode(rm)\n\n  BigDecimal.mode(rm, BigDecimal::ROUND_FLOOR)\n  low = a.add(b, prec)\n\n  BigDecimal.mode(rm, BigDecimal::ROUND_CEILING)\n  high = a.add(b, prec)\n\n  BigDecimal.mode(rm, orig)\n  low..high\nend\n\n[[\"1\", \"2\"],\n [\"0.1\", \"0.2\"],\n [\"0.1\", \"0.00002\"],\n [\"0.1\", \"-0.00002\"],\n].each { |a, b| puts \"\n", "target": "public class SafeAddition {\n    private static double stepDown(double d) {\n        return Math.nextAfter(d, Double.NEGATIVE_INFINITY);\n    }\n\n    private static double stepUp(double d) {\n        return Math.nextUp(d);\n    }\n\n    private static double[] safeAdd(double a, double b) {\n        return new double[]{stepDown(a + b), stepUp(a + b)};\n    }\n\n    public static void main(String[] args) {\n        double a = 1.2;\n        double b = 0.03;\n        double[] result = safeAdd(a, b);\n        System.out.printf(\"(%.2f +\u00a0%.2f) is in the range\u00a0%.16f..%.16f\", a, b, result[0], result[1]);\n    }\n}\n"}
{"id": 54128, "name": "Safe addition", "source": "Translate Ruby to Python: require 'bigdecimal'\nrequire 'bigdecimal/util'  \n\ndef safe_add(a, b, prec)\n  a, b = a.to_d, b.to_d\n  rm = BigDecimal::ROUND_MODE\n  orig = BigDecimal.mode(rm)\n\n  BigDecimal.mode(rm, BigDecimal::ROUND_FLOOR)\n  low = a.add(b, prec)\n\n  BigDecimal.mode(rm, BigDecimal::ROUND_CEILING)\n  high = a.add(b, prec)\n\n  BigDecimal.mode(rm, orig)\n  low..high\nend\n\n[[\"1\", \"2\"],\n [\"0.1\", \"0.2\"],\n [\"0.1\", \"0.00002\"],\n [\"0.1\", \"-0.00002\"],\n].each { |a, b| puts \"\n", "target": ">>> sum([.1, .1, .1, .1, .1, .1, .1, .1, .1, .1])\n0.9999999999999999\n>>> from math import fsum\n>>> fsum([.1, .1, .1, .1, .1, .1, .1, .1, .1, .1])\n1.0\n"}
{"id": 54262, "name": "Discordian date", "source": "Translate Ruby to C#: require 'date'\n\nclass DiscordianDate\n  SEASON_NAMES = [\"Chaos\",\"Discord\",\"Confusion\",\"Bureaucracy\",\"The Aftermath\"]\n  DAY_NAMES = [\"Sweetmorn\",\"Boomtime\",\"Pungenday\",\"Prickle-Prickle\",\"Setting Orange\"]\n  YEAR_OFFSET = 1166\n  DAYS_PER_SEASON = 73\n  DAYS_PER_WEEK = 5\n  ST_TIBS_DAY_OF_YEAR = 60\n\n  def initialize(year, month, day)\n    gregorian_date = Date.new(year, month, day)\n    @day_of_year = gregorian_date.yday\n\n    @st_tibs = false\n    if gregorian_date.leap?\n      if @day_of_year == ST_TIBS_DAY_OF_YEAR\n        @st_tibs = true\n      elsif @day_of_year > ST_TIBS_DAY_OF_YEAR\n        @day_of_year -= 1\n      end\n    end\n\n    @season, @day = (@day_of_year-1).divmod(DAYS_PER_SEASON)\n    @day += 1     \n    @year = gregorian_date.year + YEAR_OFFSET\n  end\n  attr_reader :year, :day\n\n  def season\n    SEASON_NAMES[@season]\n  end\n\n  def weekday\n    if @st_tibs\n      \"St. Tib's Day\"\n    else\n      DAY_NAMES[(@day_of_year - 1) % DAYS_PER_WEEK]\n    end\n  end\n\n  def to_s\n    %Q{\n  end\nend\n", "target": "using System;\n\npublic static class DiscordianDate\n{\n    static readonly string[] seasons = { \"Chaos\", \"Discord\", \"Confusion\", \"Bureaucracy\", \"The Aftermath\" };\n    static readonly string[] weekdays = { \"Sweetmorn\", \"Boomtime\", \"Pungenday\", \"Prickle-Prickle\", \"Setting Orange\" };\n    static readonly string[] apostles = { \"Mungday\", \"Mojoday\", \"Syaday\", \"Zaraday\", \"Maladay\" };\n    static readonly string[] holidays = { \"Chaoflux\", \"Discoflux\", \"Confuflux\", \"Bureflux\", \"Afflux\" };\n    \n    public static string Discordian(this DateTime date) {\n        string yold = $\" in the YOLD {date.Year + 1166}.\";\n        int dayOfYear = date.DayOfYear;\n\n        if (DateTime.IsLeapYear(date.Year)) {\n            if (dayOfYear == 60) return \"St. Tib's day\" + yold;\n            else if (dayOfYear > 60) dayOfYear--;\n        }\n        dayOfYear--;\n\n        int seasonDay = dayOfYear % 73 + 1;\n        int seasonNr = dayOfYear / 73;\n        int weekdayNr = dayOfYear % 5;\n        string holyday = \"\";\n\n        if (seasonDay == 5)       holyday = $\" Celebrate {apostles[seasonNr]}!\";\n        else if (seasonDay == 50) holyday = $\" Celebrate {holidays[seasonNr]}!\";\n        return $\"{weekdays[weekdayNr]}, day {seasonDay} of {seasons[seasonNr]}{yold}{holyday}\";\n    }\n\n    public static void Main() {\n        foreach (var (day, month, year) in new [] {\n            (1, 1, 2010),\n            (5, 1, 2010),\n            (19, 2, 2011),\n            (28, 2, 2012),\n            (29, 2, 2012),\n            (1, 3, 2012),\n            (19, 3, 2013),\n            (3, 5, 2014),\n            (31, 5, 2015),\n            (22, 6, 2016),\n            (15, 7, 2016),\n            (12, 8, 2017),\n            (19, 9, 2018),\n            (26, 9, 2018),\n            (24, 10, 2019),\n            (8, 12, 2020),\n            (31, 12, 2020)\n        })\n        {\n            Console.WriteLine($\"{day:00}-{month:00}-{year:00} = {new DateTime(year, month, day).Discordian()}\");\n        }\n    }\n\n}\n"}
{"id": 54264, "name": "Discordian date", "source": "Translate Ruby to Java: require 'date'\n\nclass DiscordianDate\n  SEASON_NAMES = [\"Chaos\",\"Discord\",\"Confusion\",\"Bureaucracy\",\"The Aftermath\"]\n  DAY_NAMES = [\"Sweetmorn\",\"Boomtime\",\"Pungenday\",\"Prickle-Prickle\",\"Setting Orange\"]\n  YEAR_OFFSET = 1166\n  DAYS_PER_SEASON = 73\n  DAYS_PER_WEEK = 5\n  ST_TIBS_DAY_OF_YEAR = 60\n\n  def initialize(year, month, day)\n    gregorian_date = Date.new(year, month, day)\n    @day_of_year = gregorian_date.yday\n\n    @st_tibs = false\n    if gregorian_date.leap?\n      if @day_of_year == ST_TIBS_DAY_OF_YEAR\n        @st_tibs = true\n      elsif @day_of_year > ST_TIBS_DAY_OF_YEAR\n        @day_of_year -= 1\n      end\n    end\n\n    @season, @day = (@day_of_year-1).divmod(DAYS_PER_SEASON)\n    @day += 1     \n    @year = gregorian_date.year + YEAR_OFFSET\n  end\n  attr_reader :year, :day\n\n  def season\n    SEASON_NAMES[@season]\n  end\n\n  def weekday\n    if @st_tibs\n      \"St. Tib's Day\"\n    else\n      DAY_NAMES[(@day_of_year - 1) % DAYS_PER_WEEK]\n    end\n  end\n\n  def to_s\n    %Q{\n  end\nend\n", "target": "import java.util.Calendar;\nimport java.util.GregorianCalendar;\n\npublic class DiscordianDate {\n    final static String[] seasons = {\"Chaos\", \"Discord\", \"Confusion\",\n        \"Bureaucracy\", \"The Aftermath\"};\n\n    final static String[] weekday = {\"Sweetmorn\", \"Boomtime\", \"Pungenday\",\n        \"Prickle-Prickle\", \"Setting Orange\"};\n\n    final static String[] apostle = {\"Mungday\", \"Mojoday\", \"Syaday\",\n        \"Zaraday\", \"Maladay\"};\n\n    final static String[] holiday = {\"Chaoflux\", \"Discoflux\", \"Confuflux\",\n        \"Bureflux\", \"Afflux\"};\n\n    public static String discordianDate(final GregorianCalendar date) {\n        int y = date.get(Calendar.YEAR);\n        int yold = y + 1166;\n        int dayOfYear = date.get(Calendar.DAY_OF_YEAR);\n\n        if (date.isLeapYear(y)) {\n            if (dayOfYear == 60)\n                return \"St. Tib's Day, in the YOLD \" + yold;\n            else if (dayOfYear > 60)\n                dayOfYear--;\n        }\n\n        dayOfYear--;\n\n        int seasonDay = dayOfYear % 73 + 1;\n        if (seasonDay == 5)\n            return apostle[dayOfYear / 73] + \", in the YOLD \" + yold;\n        if (seasonDay == 50)\n            return holiday[dayOfYear / 73] + \", in the YOLD \" + yold;\n\n        String season = seasons[dayOfYear / 73];\n        String dayOfWeek = weekday[dayOfYear % 5];\n\n        return String.format(\"%s, day %s of %s in the YOLD %s\",\n                dayOfWeek, seasonDay, season, yold);\n    }\n\n    public static void main(String[] args) {\n\n        System.out.println(discordianDate(new GregorianCalendar()));\n\n        test(2010, 6, 22, \"Pungenday, day 57 of Confusion in the YOLD 3176\");\n        test(2012, 1, 28, \"Prickle-Prickle, day 59 of Chaos in the YOLD 3178\");\n        test(2012, 1, 29, \"St. Tib's Day, in the YOLD 3178\");\n        test(2012, 2, 1, \"Setting Orange, day 60 of Chaos in the YOLD 3178\");\n        test(2010, 0, 5, \"Mungday, in the YOLD 3176\");\n        test(2011, 4, 3, \"Discoflux, in the YOLD 3177\");\n        test(2015, 9, 19, \"Boomtime, day 73 of Bureaucracy in the YOLD 3181\");\n    }\n\n    private static void test(int y, int m, int d, final String result) {\n        assert (discordianDate(new GregorianCalendar(y, m, d)).equals(result));\n    }\n}\n"}
{"id": 54265, "name": "Discordian date", "source": "Translate Ruby to Python: require 'date'\n\nclass DiscordianDate\n  SEASON_NAMES = [\"Chaos\",\"Discord\",\"Confusion\",\"Bureaucracy\",\"The Aftermath\"]\n  DAY_NAMES = [\"Sweetmorn\",\"Boomtime\",\"Pungenday\",\"Prickle-Prickle\",\"Setting Orange\"]\n  YEAR_OFFSET = 1166\n  DAYS_PER_SEASON = 73\n  DAYS_PER_WEEK = 5\n  ST_TIBS_DAY_OF_YEAR = 60\n\n  def initialize(year, month, day)\n    gregorian_date = Date.new(year, month, day)\n    @day_of_year = gregorian_date.yday\n\n    @st_tibs = false\n    if gregorian_date.leap?\n      if @day_of_year == ST_TIBS_DAY_OF_YEAR\n        @st_tibs = true\n      elsif @day_of_year > ST_TIBS_DAY_OF_YEAR\n        @day_of_year -= 1\n      end\n    end\n\n    @season, @day = (@day_of_year-1).divmod(DAYS_PER_SEASON)\n    @day += 1     \n    @year = gregorian_date.year + YEAR_OFFSET\n  end\n  attr_reader :year, :day\n\n  def season\n    SEASON_NAMES[@season]\n  end\n\n  def weekday\n    if @st_tibs\n      \"St. Tib's Day\"\n    else\n      DAY_NAMES[(@day_of_year - 1) % DAYS_PER_WEEK]\n    end\n  end\n\n  def to_s\n    %Q{\n  end\nend\n", "target": "import datetime, calendar\n\nDISCORDIAN_SEASONS = [\"Chaos\", \"Discord\", \"Confusion\", \"Bureaucracy\", \"The Aftermath\"]\n\ndef ddate(year, month, day):\n    today = datetime.date(year, month, day)\n    is_leap_year = calendar.isleap(year)\n    if is_leap_year and month == 2 and day == 29:\n        return \"St. Tib's Day, YOLD \" + (year + 1166)\n    \n    day_of_year = today.timetuple().tm_yday - 1\n    \n    if is_leap_year and day_of_year >= 60:\n        day_of_year -= 1 \n    \n    season, dday = divmod(day_of_year, 73)\n    return \"%s %d, YOLD %d\" % (DISCORDIAN_SEASONS[season], dday + 1, year + 1166)\n"}
{"id": 54449, "name": "Non-continuous subsequences", "source": "Translate Ruby to C#: class Array\n  def func_power_set\n    inject([[]]) { |ps,item|    \n      ps +                      \n      ps.map { |e| e + [item] } \n    }\n  end\n  \n  def non_continuous_subsequences\n    func_power_set.reject {|seq| continuous?(seq)}\n  end\n  \n  def continuous?(seq)\n    seq.each_cons(2) {|a, b| return false if a.succ != b}\n    true\n  end\nend\n\np (1..3).to_a.non_continuous_subsequences\np (1..4).to_a.non_continuous_subsequences\np (1..5).to_a.non_continuous_subsequences\np (\"a\"..\"d\").to_a.non_continuous_subsequences\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\nclass Program\n{\n    public static void Main() {\n        var sequence = new[] { \"A\", \"B\", \"C\", \"D\" };\n        foreach (var subset in Subsets(sequence.Length).Where(s => !IsContinuous(s))) {\n            Console.WriteLine(string.Join(\" \", subset.Select(i => sequence[i])));\n        }\n    }\n    \n    static IEnumerable<List<int>> Subsets(int length) {\n        int[] values = Enumerable.Range(0, length).ToArray();\n        var stack = new Stack<int>(length);\n        for (int i = 0; stack.Count > 0 || i < length; ) {\n            if (i < length) {\n                stack.Push(i++);\n                yield return (from index in stack.Reverse() select values[index]).ToList();\n            } else {\n                i = stack.Pop() + 1;\n                if (stack.Count > 0) i = stack.Pop() + 1;\n            }\n        }\n    }\n\n    static bool IsContinuous(List<int> list) => list[list.Count - 1] - list[0] + 1 == list.Count;\n\n}\n"}
{"id": 54451, "name": "Non-continuous subsequences", "source": "Translate Ruby to Java: class Array\n  def func_power_set\n    inject([[]]) { |ps,item|    \n      ps +                      \n      ps.map { |e| e + [item] } \n    }\n  end\n  \n  def non_continuous_subsequences\n    func_power_set.reject {|seq| continuous?(seq)}\n  end\n  \n  def continuous?(seq)\n    seq.each_cons(2) {|a, b| return false if a.succ != b}\n    true\n  end\nend\n\np (1..3).to_a.non_continuous_subsequences\np (1..4).to_a.non_continuous_subsequences\np (1..5).to_a.non_continuous_subsequences\np (\"a\"..\"d\").to_a.non_continuous_subsequences\n", "target": "public class NonContinuousSubsequences {\n\n    public static void main(String args[]) {\n        seqR(\"1234\", \"\", 0, 0);\n    }\n\n    private static void seqR(String s, String c, int i, int added) {\n        if (i == s.length()) {\n            if (c.trim().length() > added)\n                System.out.println(c);\n        } else {\n            seqR(s, c + s.charAt(i), i + 1, added + 1);\n            seqR(s, c + ' ', i + 1, added);\n        }\n    }\n}\n"}
{"id": 54452, "name": "Non-continuous subsequences", "source": "Translate Ruby to Python: class Array\n  def func_power_set\n    inject([[]]) { |ps,item|    \n      ps +                      \n      ps.map { |e| e + [item] } \n    }\n  end\n  \n  def non_continuous_subsequences\n    func_power_set.reject {|seq| continuous?(seq)}\n  end\n  \n  def continuous?(seq)\n    seq.each_cons(2) {|a, b| return false if a.succ != b}\n    true\n  end\nend\n\np (1..3).to_a.non_continuous_subsequences\np (1..4).to_a.non_continuous_subsequences\np (1..5).to_a.non_continuous_subsequences\np (\"a\"..\"d\").to_a.non_continuous_subsequences\n", "target": "def ncsub(seq, s=0):\n    if seq:\n        x = seq[:1]\n        xs = seq[1:]\n        p2 = s % 2\n        p1 = not p2\n        return [x + ys for ys in ncsub(xs, s + p1)] + ncsub(xs, s + p2)\n    else:\n        return [[]] if s >= 3 else []\n"}
{"id": 54685, "name": "Binary digits", "source": "Translate Ruby to C#: [5,50,9000].each do |n|\n  puts \"%b\" % n\nend\n", "target": "using System;\n\nclass Program\n{\n    static void Main()\n    {\n        foreach (var number in new[] { 5, 50, 9000 })\n        {\n            Console.WriteLine(Convert.ToString(number, 2));\n        }\n    }\n}\n"}
{"id": 54687, "name": "Binary digits", "source": "Translate Ruby to Java: [5,50,9000].each do |n|\n  puts \"%b\" % n\nend\n", "target": "module BinaryDigits\n    {\n    @Inject Console console;\n    void run()\n        {\n        Int[] tests = [0, 1, 5, 50, 9000];\n\n        Int longestInt = tests.map(n -> n.estimateStringLength()).reduce(0, (max, len) -> max.maxOf(len));\n        Int longestBin = tests.map(n -> (64-n.leadingZeroCount).maxOf(1)).reduce(0, (max, len) -> max.maxOf(len));\n\n        function String(Int) num = n ->\n            {\n            Int indent = longestInt - n.estimateStringLength();\n            return $\"{' ' * indent}{n}\";\n            };\n\n        function String(Int) bin = n ->\n            {\n            Int index  = n.leadingZeroCount.minOf(63);\n            Int indent = index - (64 - longestBin);\n            val bits   = n.toBitArray()[index ..< 64];\n            return $\"{' ' * indent}{bits.toString().substring(2)}\";\n            };\n\n        for (Int test : tests)\n            {\n            console.print($\"The decimal value {num(test)} should produce an output of {bin(test)}\");\n            }\n        }\n    }\n"}
{"id": 54688, "name": "Binary digits", "source": "Translate Ruby to Python: [5,50,9000].each do |n|\n  puts \"%b\" % n\nend\n", "target": ">>> for i in range(16): print('{0:b}'.format(i))\n\n0\n1\n10\n11\n100\n101\n110\n111\n1000\n1001\n1010\n1011\n1100\n1101\n1110\n1111\n"}
{"id": 54873, "name": "Dijkstra's algorithm", "source": "Translate Ruby to C#: class Graph\n  Vertex = Struct.new(:name, :neighbours, :dist, :prev)\n \n  def initialize(graph)\n    @vertices = Hash.new{|h,k| h[k]=Vertex.new(k,[],Float::INFINITY)}\n    @edges = {}\n    graph.each do |(v1, v2, dist)|\n      @vertices[v1].neighbours << v2\n      @vertices[v2].neighbours << v1\n      @edges[[v1, v2]] = @edges[[v2, v1]] = dist\n    end\n    @dijkstra_source = nil\n  end\n \n  def dijkstra(source)\n    return  if @dijkstra_source == source\n    q = @vertices.values\n    q.each do |v|\n      v.dist = Float::INFINITY\n      v.prev = nil\n    end\n    @vertices[source].dist = 0\n    until q.empty?\n      u = q.min_by {|vertex| vertex.dist}\n      break if u.dist == Float::INFINITY\n      q.delete(u)\n      u.neighbours.each do |v|\n        vv = @vertices[v]\n        if q.include?(vv)\n          alt = u.dist + @edges[[u.name, v]]\n          if alt < vv.dist\n            vv.dist = alt\n            vv.prev = u.name\n          end\n        end\n      end\n    end\n    @dijkstra_source = source\n  end\n \n  def shortest_path(source, target)\n    dijkstra(source)\n    path = []\n    u = target\n    while u\n      path.unshift(u)\n      u = @vertices[u].prev\n    end\n    return path, @vertices[target].dist\n  end\n \n  def to_s\n    \"\n  end\nend\n\ng = Graph.new([ [:a, :b, 7],\n                [:a, :c, 9],\n                [:a, :f, 14],\n                [:b, :c, 10],\n                [:b, :d, 15],\n                [:c, :d, 11],\n                [:c, :f, 2],\n                [:d, :e, 6],\n                [:e, :f, 9],\n              ])\n\nstart, stop = :a, :e\npath, dist = g.shortest_path(start, stop)\nputs \"shortest path from \nputs path.join(\" -> \")\n", "target": "using static System.Linq.Enumerable;\nusing static System.String;\nusing static System.Console;\nusing System.Collections.Generic;\nusing System;\nusing EdgeList = System.Collections.Generic.List<(int node, double weight)>;\n\npublic static class Dijkstra\n{\n    public static void Main() {\n        Graph graph = new Graph(6);\n        Func<char, int> id = c => c - 'a';\n        Func<int , char> name = i => (char)(i + 'a');\n        foreach (var (start, end, cost) in new [] {\n            ('a', 'b', 7),\n            ('a', 'c', 9),\n            ('a', 'f', 14),\n            ('b', 'c', 10),\n            ('b', 'd', 15),\n            ('c', 'd', 11),\n            ('c', 'f', 2),\n            ('d', 'e', 6),\n            ('e', 'f', 9),\n        }) {\n            graph.AddEdge(id(start), id(end), cost);\n        }\n\n        var path = graph.FindPath(id('a'));\n        for (int d = id('b'); d <= id('f'); d++) {\n            WriteLine(Join(\" -> \", Path(id('a'), d).Select(p => $\"{name(p.node)}({p.distance})\").Reverse()));\n        }\n        \n        IEnumerable<(double distance, int node)> Path(int start, int destination) {\n            yield return (path[destination].distance, destination);\n            for (int i = destination; i != start; i = path[i].prev) {\n                yield return (path[path[i].prev].distance, path[i].prev);\n            }\n        }\n    }\n\n}\n\nsealed class Graph\n{\n    private readonly List<EdgeList> adjacency;\n\n    public Graph(int vertexCount) => adjacency = Range(0, vertexCount).Select(v => new EdgeList()).ToList();\n\n    public int Count => adjacency.Count;\n    public bool HasEdge(int s, int e) => adjacency[s].Any(p => p.node == e);\n    public bool RemoveEdge(int s, int e) => adjacency[s].RemoveAll(p => p.node == e) > 0;\n\n    public bool AddEdge(int s, int e, double weight) {\n        if (HasEdge(s, e)) return false;\n        adjacency[s].Add((e, weight));\n        return true;\n    }\n\n    public (double distance, int prev)[] FindPath(int start) {\n        var info = Range(0, adjacency.Count).Select(i => (distance: double.PositiveInfinity, prev: i)).ToArray();\n        info[start].distance = 0;\n        var visited = new System.Collections.BitArray(adjacency.Count);\n\n        var heap = new Heap<(int node, double distance)>((a, b) => a.distance.CompareTo(b.distance));\n        heap.Push((start, 0));\n        while (heap.Count > 0) {\n            var current = heap.Pop();\n            if (visited[current.node]) continue;\n            var edges = adjacency[current.node];\n            for (int n = 0; n < edges.Count; n++) {\n                int v = edges[n].node;\n                if (visited[v]) continue;\n                double alt = info[current.node].distance + edges[n].weight;\n                if (alt < info[v].distance) {\n                    info[v] = (alt, current.node);\n                    heap.Push((v, alt));\n                }\n            }\n            visited[current.node] = true;\n        }\n        return info;\n    }\n\n}\n\nsealed class Heap<T>\n{\n    private readonly IComparer<T> comparer;\n    private readonly List<T> list = new List<T> { default };\n\n    public Heap() : this(default(IComparer<T>)) { }\n\n    public Heap(IComparer<T> comparer) {\n        this.comparer = comparer ?? Comparer<T>.Default;\n    }\n\n    public Heap(Comparison<T> comparison) : this(Comparer<T>.Create(comparison)) { }\n\n    public int Count => list.Count - 1;\n\n    public void Push(T element) {\n        list.Add(element);\n        SiftUp(list.Count - 1);\n    }\n\n    public T Pop() {\n        T result = list[1];\n        list[1] = list[list.Count - 1];\n        list.RemoveAt(list.Count - 1);\n        SiftDown(1);\n        return result;\n    }\n\n    private static int Parent(int i) => i / 2;\n    private static int Left(int i) => i * 2;\n    private static int Right(int i) => i * 2 + 1;\n\n    private void SiftUp(int i) {\n        while (i > 1) {\n            int parent = Parent(i);\n            if (comparer.Compare(list[i], list[parent]) > 0) return;\n            (list[parent], list[i]) = (list[i], list[parent]);\n            i = parent;\n        }\n    }\n\n    private void SiftDown(int i) {\n        for (int left = Left(i); left < list.Count; left = Left(i)) {\n            int smallest = comparer.Compare(list[left], list[i]) <= 0 ? left : i;\n            int right = Right(i);\n            if (right < list.Count && comparer.Compare(list[right], list[smallest]) <= 0) smallest = right;\n            if (smallest == i) return;\n            (list[i], list[smallest]) = (list[smallest], list[i]);\n            i = smallest;\n        }\n    }\n\n}\n"}
{"id": 54875, "name": "Dijkstra's algorithm", "source": "Translate Ruby to Java: class Graph\n  Vertex = Struct.new(:name, :neighbours, :dist, :prev)\n \n  def initialize(graph)\n    @vertices = Hash.new{|h,k| h[k]=Vertex.new(k,[],Float::INFINITY)}\n    @edges = {}\n    graph.each do |(v1, v2, dist)|\n      @vertices[v1].neighbours << v2\n      @vertices[v2].neighbours << v1\n      @edges[[v1, v2]] = @edges[[v2, v1]] = dist\n    end\n    @dijkstra_source = nil\n  end\n \n  def dijkstra(source)\n    return  if @dijkstra_source == source\n    q = @vertices.values\n    q.each do |v|\n      v.dist = Float::INFINITY\n      v.prev = nil\n    end\n    @vertices[source].dist = 0\n    until q.empty?\n      u = q.min_by {|vertex| vertex.dist}\n      break if u.dist == Float::INFINITY\n      q.delete(u)\n      u.neighbours.each do |v|\n        vv = @vertices[v]\n        if q.include?(vv)\n          alt = u.dist + @edges[[u.name, v]]\n          if alt < vv.dist\n            vv.dist = alt\n            vv.prev = u.name\n          end\n        end\n      end\n    end\n    @dijkstra_source = source\n  end\n \n  def shortest_path(source, target)\n    dijkstra(source)\n    path = []\n    u = target\n    while u\n      path.unshift(u)\n      u = @vertices[u].prev\n    end\n    return path, @vertices[target].dist\n  end\n \n  def to_s\n    \"\n  end\nend\n\ng = Graph.new([ [:a, :b, 7],\n                [:a, :c, 9],\n                [:a, :f, 14],\n                [:b, :c, 10],\n                [:b, :d, 15],\n                [:c, :d, 11],\n                [:c, :f, 2],\n                [:d, :e, 6],\n                [:e, :f, 9],\n              ])\n\nstart, stop = :a, :e\npath, dist = g.shortest_path(start, stop)\nputs \"shortest path from \nputs path.join(\" -> \")\n", "target": "import java.io.*;\nimport java.util.*;\n\npublic class Dijkstra {\n   private static final Graph.Edge[] GRAPH = {\n      new Graph.Edge(\"a\", \"b\", 7),\n      new Graph.Edge(\"a\", \"c\", 9),\n      new Graph.Edge(\"a\", \"f\", 14),\n      new Graph.Edge(\"b\", \"c\", 10),\n      new Graph.Edge(\"b\", \"d\", 15),\n      new Graph.Edge(\"c\", \"d\", 11),\n      new Graph.Edge(\"c\", \"f\", 2),\n      new Graph.Edge(\"d\", \"e\", 6),\n      new Graph.Edge(\"e\", \"f\", 9),\n   };\n   private static final String START = \"a\";\n   private static final String END = \"e\";\n   \n   public static void main(String[] args) {\n      Graph g = new Graph(GRAPH);\n      g.dijkstra(START);\n      g.printPath(END);\n      \n   }\n}\n\nclass Graph {\n   private final Map<String, Vertex> graph; \n   \n   \n   public static class Edge {\n      public final String v1, v2;\n      public final int dist;\n      public Edge(String v1, String v2, int dist) {\n         this.v1 = v1;\n         this.v2 = v2;\n         this.dist = dist;\n      }\n   }\n   \n   \n  public static class Vertex implements Comparable<Vertex>{\n\tpublic final String name;\n\tpublic int dist = Integer.MAX_VALUE; \n\tpublic Vertex previous = null;\n\tpublic final Map<Vertex, Integer> neighbours = new HashMap<>();\n\n\tpublic Vertex(String name)\n\t{\n\t\tthis.name = name;\n\t}\n\n\tprivate void printPath()\n\t{\n\t\tif (this == this.previous)\n\t\t{\n\t\t\tSystem.out.printf(\"%s\", this.name);\n\t\t}\n\t\telse if (this.previous == null)\n\t\t{\n\t\t\tSystem.out.printf(\"%s(unreached)\", this.name);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tthis.previous.printPath();\n\t\t\tSystem.out.printf(\" -> %s(%d)\", this.name, this.dist);\n\t\t}\n\t}\n\n\tpublic int compareTo(Vertex other)\n\t{\n\t\tif (dist == other.dist)\n\t\t\treturn name.compareTo(other.name);\n\n\t\treturn Integer.compare(dist, other.dist);\n\t}\n\n\t@Override public String toString()\n\t{\n\t\treturn \"(\" + name + \", \" + dist + \")\";\n\t}\n}\n   \n   \n   public Graph(Edge[] edges) {\n      graph = new HashMap<>(edges.length);\n      \n      \n      for (Edge e : edges) {\n         if (!graph.containsKey(e.v1)) graph.put(e.v1, new Vertex(e.v1));\n         if (!graph.containsKey(e.v2)) graph.put(e.v2, new Vertex(e.v2));\n      }\n      \n      \n      for (Edge e : edges) {\n         graph.get(e.v1).neighbours.put(graph.get(e.v2), e.dist);\n         \n      }\n   }\n   \n    \n   public void dijkstra(String startName) {\n      if (!graph.containsKey(startName)) {\n         System.err.printf(\"Graph doesn't contain start vertex \\\"%s\\\"\\n\", startName);\n         return;\n      }\n      final Vertex source = graph.get(startName);\n      NavigableSet<Vertex> q = new TreeSet<>();\n      \n      \n      for (Vertex v : graph.values()) {\n         v.previous = v == source ? source : null;\n         v.dist = v == source ? 0 : Integer.MAX_VALUE;\n         q.add(v);\n      }\n      \n      dijkstra(q);\n   }\n   \n   \n   private void dijkstra(final NavigableSet<Vertex> q) {      \n      Vertex u, v;\n      while (!q.isEmpty()) {\n         \n         u = q.pollFirst(); \n         if (u.dist == Integer.MAX_VALUE) break; \n         \n         \n         for (Map.Entry<Vertex, Integer> a : u.neighbours.entrySet()) {\n            v = a.getKey(); \n            \n            final int alternateDist = u.dist + a.getValue();\n            if (alternateDist < v.dist) { \n               q.remove(v);\n               v.dist = alternateDist;\n               v.previous = u;\n               q.add(v);\n            } \n         }\n      }\n   }\n   \n   \n   public void printPath(String endName) {\n      if (!graph.containsKey(endName)) {\n         System.err.printf(\"Graph doesn't contain end vertex \\\"%s\\\"\\n\", endName);\n         return;\n      }\n      \n      graph.get(endName).printPath();\n      System.out.println();\n   }\n   \n   public void printAllPaths() {\n      for (Vertex v : graph.values()) {\n         v.printPath();\n         System.out.println();\n      }\n   }\n}\n"}
{"id": 54876, "name": "Dijkstra's algorithm", "source": "Translate Ruby to Python: class Graph\n  Vertex = Struct.new(:name, :neighbours, :dist, :prev)\n \n  def initialize(graph)\n    @vertices = Hash.new{|h,k| h[k]=Vertex.new(k,[],Float::INFINITY)}\n    @edges = {}\n    graph.each do |(v1, v2, dist)|\n      @vertices[v1].neighbours << v2\n      @vertices[v2].neighbours << v1\n      @edges[[v1, v2]] = @edges[[v2, v1]] = dist\n    end\n    @dijkstra_source = nil\n  end\n \n  def dijkstra(source)\n    return  if @dijkstra_source == source\n    q = @vertices.values\n    q.each do |v|\n      v.dist = Float::INFINITY\n      v.prev = nil\n    end\n    @vertices[source].dist = 0\n    until q.empty?\n      u = q.min_by {|vertex| vertex.dist}\n      break if u.dist == Float::INFINITY\n      q.delete(u)\n      u.neighbours.each do |v|\n        vv = @vertices[v]\n        if q.include?(vv)\n          alt = u.dist + @edges[[u.name, v]]\n          if alt < vv.dist\n            vv.dist = alt\n            vv.prev = u.name\n          end\n        end\n      end\n    end\n    @dijkstra_source = source\n  end\n \n  def shortest_path(source, target)\n    dijkstra(source)\n    path = []\n    u = target\n    while u\n      path.unshift(u)\n      u = @vertices[u].prev\n    end\n    return path, @vertices[target].dist\n  end\n \n  def to_s\n    \"\n  end\nend\n\ng = Graph.new([ [:a, :b, 7],\n                [:a, :c, 9],\n                [:a, :f, 14],\n                [:b, :c, 10],\n                [:b, :d, 15],\n                [:c, :d, 11],\n                [:c, :f, 2],\n                [:d, :e, 6],\n                [:e, :f, 9],\n              ])\n\nstart, stop = :a, :e\npath, dist = g.shortest_path(start, stop)\nputs \"shortest path from \nputs path.join(\" -> \")\n", "target": "from collections import namedtuple, deque\nfrom pprint import pprint as pp\n \n \ninf = float('inf')\nEdge = namedtuple('Edge', ['start', 'end', 'cost'])\n \nclass Graph():\n    def __init__(self, edges):\n        self.edges = [Edge(*edge) for edge in edges]\n        \n        self.vertices = {e.start for e in self.edges} | {e.end for e in self.edges}\n \n    def dijkstra(self, source, dest):\n        assert source in self.vertices\n        dist = {vertex: inf for vertex in self.vertices}\n        previous = {vertex: None for vertex in self.vertices}\n        dist[source] = 0\n        q = self.vertices.copy()\n        neighbours = {vertex: set() for vertex in self.vertices}\n        for start, end, cost in self.edges:\n            neighbours[start].add((end, cost))\n            neighbours[end].add((start, cost))\n\n        \n \n        while q:\n            \n            u = min(q, key=lambda vertex: dist[vertex])\n            q.remove(u)\n            if dist[u] == inf or u == dest:\n                break\n            for v, cost in neighbours[u]:\n                alt = dist[u] + cost\n                if alt < dist[v]:                                  \n                    dist[v] = alt\n                    previous[v] = u\n        \n        s, u = deque(), dest\n        while previous[u]:\n            s.appendleft(u)\n            u = previous[u]\n        s.appendleft(u)\n        return s\n \n \ngraph = Graph([(\"a\", \"b\", 7),  (\"a\", \"c\", 9),  (\"a\", \"f\", 14), (\"b\", \"c\", 10),\n               (\"b\", \"d\", 15), (\"c\", \"d\", 11), (\"c\", \"f\", 2),  (\"d\", \"e\", 6),\n               (\"e\", \"f\", 9)])\npp(graph.dijkstra(\"a\", \"e\"))\n"}
{"id": 55320, "name": "Create an HTML table", "source": "Translate Ruby to C#: def r\n  rand(10000)\nend\n\nSTDOUT << \"\".tap do |html|\n  html << \"<table>\"\n  [\n    ['X', 'Y', 'Z'],\n    [r ,r ,r],\n    [r ,r ,r],\n    [r ,r ,r],\n    [r ,r ,r]\n\n  ].each_with_index do |row, index|\n    html << \"<tr>\"\n    html << \"<td>\n    html << row.map { |e| \"<td>\n    html << \"</tr>\"\n  end\n\n  html << \"</table>\"\nend\n", "target": "using System;\nusing System.Text;\n\nnamespace prog\n{\n\tclass MainClass\n\t{\t\t\n\t\tpublic static void Main (string[] args)\n\t\t{\n\t\t\tStringBuilder s = new StringBuilder();\n\t\t\tRandom rnd = new Random();\n\t\t\t\n\t\t\ts.AppendLine(\"<table>\");\n\t\t\ts.AppendLine(\"<thead align = \\\"right\\\">\");\n\t\t\ts.Append(\"<tr><th></th>\");\n\t\t\tfor(int i=0; i<3; i++)\n\t\t\t\ts.Append(\"<td>\" + \"XYZ\"[i] + \"</td>\");\n\t\t\ts.AppendLine(\"</tr>\");\n\t\t\ts.AppendLine(\"</thead>\");\n\t\t\ts.AppendLine(\"<tbody align = \\\"right\\\">\");\n\t\t\tfor( int i=0; i<3; i++ )\n\t\t\t{\n\t\t\t\ts.Append(\"<tr><td>\"+i+\"</td>\");\n\t\t\t\tfor( int j=0; j<3; j++ )\n\t\t\t\t\ts.Append(\"<td>\"+rnd.Next(10000)+\"</td>\");\t\t\t\t\n\t\t\t\ts.AppendLine(\"</tr>\");\n\t\t\t}\n\t\t\ts.AppendLine(\"</tbody>\");\n\t\t\ts.AppendLine(\"</table>\");\n\t\t\t\n\t\t\tConsole.WriteLine( s );\n\t\t}\n\t}\n}\n"}
{"id": 55321, "name": "Create an HTML table", "source": "Translate Ruby to C#: def r\n  rand(10000)\nend\n\nSTDOUT << \"\".tap do |html|\n  html << \"<table>\"\n  [\n    ['X', 'Y', 'Z'],\n    [r ,r ,r],\n    [r ,r ,r],\n    [r ,r ,r],\n    [r ,r ,r]\n\n  ].each_with_index do |row, index|\n    html << \"<tr>\"\n    html << \"<td>\n    html << row.map { |e| \"<td>\n    html << \"</tr>\"\n  end\n\n  html << \"</table>\"\nend\n", "target": "using System;\nusing System.Text;\n\nnamespace prog\n{\n\tclass MainClass\n\t{\t\t\n\t\tpublic static void Main (string[] args)\n\t\t{\n\t\t\tStringBuilder s = new StringBuilder();\n\t\t\tRandom rnd = new Random();\n\t\t\t\n\t\t\ts.AppendLine(\"<table>\");\n\t\t\ts.AppendLine(\"<thead align = \\\"right\\\">\");\n\t\t\ts.Append(\"<tr><th></th>\");\n\t\t\tfor(int i=0; i<3; i++)\n\t\t\t\ts.Append(\"<td>\" + \"XYZ\"[i] + \"</td>\");\n\t\t\ts.AppendLine(\"</tr>\");\n\t\t\ts.AppendLine(\"</thead>\");\n\t\t\ts.AppendLine(\"<tbody align = \\\"right\\\">\");\n\t\t\tfor( int i=0; i<3; i++ )\n\t\t\t{\n\t\t\t\ts.Append(\"<tr><td>\"+i+\"</td>\");\n\t\t\t\tfor( int j=0; j<3; j++ )\n\t\t\t\t\ts.Append(\"<td>\"+rnd.Next(10000)+\"</td>\");\t\t\t\t\n\t\t\t\ts.AppendLine(\"</tr>\");\n\t\t\t}\n\t\t\ts.AppendLine(\"</tbody>\");\n\t\t\ts.AppendLine(\"</table>\");\n\t\t\t\n\t\t\tConsole.WriteLine( s );\n\t\t}\n\t}\n}\n"}
{"id": 55324, "name": "Create an HTML table", "source": "Translate Ruby to Java: def r\n  rand(10000)\nend\n\nSTDOUT << \"\".tap do |html|\n  html << \"<table>\"\n  [\n    ['X', 'Y', 'Z'],\n    [r ,r ,r],\n    [r ,r ,r],\n    [r ,r ,r],\n    [r ,r ,r]\n\n  ].each_with_index do |row, index|\n    html << \"<tr>\"\n    html << \"<td>\n    html << row.map { |e| \"<td>\n    html << \"</tr>\"\n  end\n\n  html << \"</table>\"\nend\n", "target": "public class HTML {\n\n\tpublic static String array2HTML(Object[][] array){\n\t\tStringBuilder html = new StringBuilder(\n\t\t\t\t\"<table>\");\n\t\tfor(Object elem:array[0]){\n\t\t\thtml.append(\"<th>\" + elem.toString() + \"</th>\");\n\t\t}\n\t\tfor(int i = 1; i < array.length; i++){\n\t\t\tObject[] row = array[i];\n\t\t\thtml.append(\"<tr>\");\n\t\t\tfor(Object elem:row){\n\t\t\t\thtml.append(\"<td>\" + elem.toString() + \"</td>\");\n\t\t\t}\n\t\t\thtml.append(\"</tr>\");\n\t\t}\n\t\thtml.append(\"</table>\");\n\t\treturn html.toString();\n\t}\n\t\n\tpublic static void main(String[] args){\n\t\tObject[][] ints = {{\"\",\"X\",\"Y\",\"Z\"},{1,1,2,3},{2,4,5,6},{3,7,8,9},{4,10,11,12}};\n\t\tSystem.out.println(array2HTML(ints));\n\t}\n}\n"}
{"id": 55325, "name": "Create an HTML table", "source": "Translate Ruby to Java: def r\n  rand(10000)\nend\n\nSTDOUT << \"\".tap do |html|\n  html << \"<table>\"\n  [\n    ['X', 'Y', 'Z'],\n    [r ,r ,r],\n    [r ,r ,r],\n    [r ,r ,r],\n    [r ,r ,r]\n\n  ].each_with_index do |row, index|\n    html << \"<tr>\"\n    html << \"<td>\n    html << row.map { |e| \"<td>\n    html << \"</tr>\"\n  end\n\n  html << \"</table>\"\nend\n", "target": "public class HTML {\n\n\tpublic static String array2HTML(Object[][] array){\n\t\tStringBuilder html = new StringBuilder(\n\t\t\t\t\"<table>\");\n\t\tfor(Object elem:array[0]){\n\t\t\thtml.append(\"<th>\" + elem.toString() + \"</th>\");\n\t\t}\n\t\tfor(int i = 1; i < array.length; i++){\n\t\t\tObject[] row = array[i];\n\t\t\thtml.append(\"<tr>\");\n\t\t\tfor(Object elem:row){\n\t\t\t\thtml.append(\"<td>\" + elem.toString() + \"</td>\");\n\t\t\t}\n\t\t\thtml.append(\"</tr>\");\n\t\t}\n\t\thtml.append(\"</table>\");\n\t\treturn html.toString();\n\t}\n\t\n\tpublic static void main(String[] args){\n\t\tObject[][] ints = {{\"\",\"X\",\"Y\",\"Z\"},{1,1,2,3},{2,4,5,6},{3,7,8,9},{4,10,11,12}};\n\t\tSystem.out.println(array2HTML(ints));\n\t}\n}\n"}
{"id": 55326, "name": "Create an HTML table", "source": "Translate Ruby to Python: def r\n  rand(10000)\nend\n\nSTDOUT << \"\".tap do |html|\n  html << \"<table>\"\n  [\n    ['X', 'Y', 'Z'],\n    [r ,r ,r],\n    [r ,r ,r],\n    [r ,r ,r],\n    [r ,r ,r]\n\n  ].each_with_index do |row, index|\n    html << \"<tr>\"\n    html << \"<td>\n    html << row.map { |e| \"<td>\n    html << \"</tr>\"\n  end\n\n  html << \"</table>\"\nend\n", "target": "import random\n\ndef rand9999():\n    return random.randint(1000, 9999)\n\ndef tag(attr='', **kwargs):\n    for tag, txt in kwargs.items():\n        return '<{tag}{attr}>{txt}</{tag}>'.format(**locals())\n\nif __name__ == '__main__':\n    header = tag(tr=''.join(tag(th=txt) for txt in ',X,Y,Z'.split(','))) + '\\n'\n    rows = '\\n'.join(tag(tr=tag(' style=\"font-weight: bold;\"', td=i)\n                                    + ''.join(tag(td=rand9999())\n                                              for j in range(3)))\n                     for i in range(1, 6))\n    table = tag(table='\\n' + header + rows + '\\n')\n    print(table)\n"}
{"id": 55327, "name": "Create an HTML table", "source": "Translate Ruby to Python: def r\n  rand(10000)\nend\n\nSTDOUT << \"\".tap do |html|\n  html << \"<table>\"\n  [\n    ['X', 'Y', 'Z'],\n    [r ,r ,r],\n    [r ,r ,r],\n    [r ,r ,r],\n    [r ,r ,r]\n\n  ].each_with_index do |row, index|\n    html << \"<tr>\"\n    html << \"<td>\n    html << row.map { |e| \"<td>\n    html << \"</tr>\"\n  end\n\n  html << \"</table>\"\nend\n", "target": "import random\n\ndef rand9999():\n    return random.randint(1000, 9999)\n\ndef tag(attr='', **kwargs):\n    for tag, txt in kwargs.items():\n        return '<{tag}{attr}>{txt}</{tag}>'.format(**locals())\n\nif __name__ == '__main__':\n    header = tag(tr=''.join(tag(th=txt) for txt in ',X,Y,Z'.split(','))) + '\\n'\n    rows = '\\n'.join(tag(tr=tag(' style=\"font-weight: bold;\"', td=i)\n                                    + ''.join(tag(td=rand9999())\n                                              for j in range(3)))\n                     for i in range(1, 6))\n    table = tag(table='\\n' + header + rows + '\\n')\n    print(table)\n"}
{"id": 55731, "name": "Find the intersection of two lines", "source": "Translate Ruby to C#: Point = Struct.new(:x, :y)\n\nclass Line\n  attr_reader :a, :b\n\n  def initialize(point1, point2)\n    @a = (point1.y - point2.y).fdiv(point1.x - point2.x)\n    @b = point1.y - @a*point1.x\n  end\n\n  def intersect(other)\n    return nil if @a == other.a\n    x = (other.b - @b).fdiv(@a - other.a)\n    y = @a*x + @b\n    Point.new(x,y)\n  end\n\n  def to_s\n    \"y = \n  end\n\nend\n\nl1 = Line.new(Point.new(4, 0), Point.new(6, 10))\nl2 = Line.new(Point.new(0, 3), Point.new(10, 7))\n\nputs \"Line \n", "target": "using System;\nusing System.Drawing;\npublic class Program\n{\n    static PointF FindIntersection(PointF s1, PointF e1, PointF s2, PointF e2) {\n        float a1 = e1.Y - s1.Y;\n        float b1 = s1.X - e1.X;\n        float c1 = a1 * s1.X + b1 * s1.Y;\n\n        float a2 = e2.Y - s2.Y;\n        float b2 = s2.X - e2.X;\n        float c2 = a2 * s2.X + b2 * s2.Y;\n\n        float delta = a1 * b2 - a2 * b1;\n        \n        return delta == 0 ? new PointF(float.NaN, float.NaN)\n            : new PointF((b2 * c1 - b1 * c2) / delta, (a1 * c2 - a2 * c1) / delta);\n    }\n\n    static void Main() {\n        Func<float, float, PointF> p = (x, y) => new PointF(x, y);\n        Console.WriteLine(FindIntersection(p(4f, 0f), p(6f, 10f), p(0f, 3f), p(10f, 7f)));\n        Console.WriteLine(FindIntersection(p(0f, 0f), p(1f, 1f), p(1f, 2f), p(4f, 5f)));\n    }\n}\n"}
{"id": 55732, "name": "Find the intersection of two lines", "source": "Translate Ruby to C#: Point = Struct.new(:x, :y)\n\nclass Line\n  attr_reader :a, :b\n\n  def initialize(point1, point2)\n    @a = (point1.y - point2.y).fdiv(point1.x - point2.x)\n    @b = point1.y - @a*point1.x\n  end\n\n  def intersect(other)\n    return nil if @a == other.a\n    x = (other.b - @b).fdiv(@a - other.a)\n    y = @a*x + @b\n    Point.new(x,y)\n  end\n\n  def to_s\n    \"y = \n  end\n\nend\n\nl1 = Line.new(Point.new(4, 0), Point.new(6, 10))\nl2 = Line.new(Point.new(0, 3), Point.new(10, 7))\n\nputs \"Line \n", "target": "using System;\nusing System.Drawing;\npublic class Program\n{\n    static PointF FindIntersection(PointF s1, PointF e1, PointF s2, PointF e2) {\n        float a1 = e1.Y - s1.Y;\n        float b1 = s1.X - e1.X;\n        float c1 = a1 * s1.X + b1 * s1.Y;\n\n        float a2 = e2.Y - s2.Y;\n        float b2 = s2.X - e2.X;\n        float c2 = a2 * s2.X + b2 * s2.Y;\n\n        float delta = a1 * b2 - a2 * b1;\n        \n        return delta == 0 ? new PointF(float.NaN, float.NaN)\n            : new PointF((b2 * c1 - b1 * c2) / delta, (a1 * c2 - a2 * c1) / delta);\n    }\n\n    static void Main() {\n        Func<float, float, PointF> p = (x, y) => new PointF(x, y);\n        Console.WriteLine(FindIntersection(p(4f, 0f), p(6f, 10f), p(0f, 3f), p(10f, 7f)));\n        Console.WriteLine(FindIntersection(p(0f, 0f), p(1f, 1f), p(1f, 2f), p(4f, 5f)));\n    }\n}\n"}
{"id": 55735, "name": "Find the intersection of two lines", "source": "Translate Ruby to Java: Point = Struct.new(:x, :y)\n\nclass Line\n  attr_reader :a, :b\n\n  def initialize(point1, point2)\n    @a = (point1.y - point2.y).fdiv(point1.x - point2.x)\n    @b = point1.y - @a*point1.x\n  end\n\n  def intersect(other)\n    return nil if @a == other.a\n    x = (other.b - @b).fdiv(@a - other.a)\n    y = @a*x + @b\n    Point.new(x,y)\n  end\n\n  def to_s\n    \"y = \n  end\n\nend\n\nl1 = Line.new(Point.new(4, 0), Point.new(6, 10))\nl2 = Line.new(Point.new(0, 3), Point.new(10, 7))\n\nputs \"Line \n", "target": "public class Intersection {\n    private static class Point {\n        double x, y;\n\n        Point(double x, double y) {\n            this.x = x;\n            this.y = y;\n        }\n\n        @Override\n        public String toString() {\n            return String.format(\"{%f, %f}\", x, y);\n        }\n    }\n\n    private static class Line {\n        Point s, e;\n\n        Line(Point s, Point e) {\n            this.s = s;\n            this.e = e;\n        }\n    }\n\n    private static Point findIntersection(Line l1, Line l2) {\n        double a1 = l1.e.y - l1.s.y;\n        double b1 = l1.s.x - l1.e.x;\n        double c1 = a1 * l1.s.x + b1 * l1.s.y;\n\n        double a2 = l2.e.y - l2.s.y;\n        double b2 = l2.s.x - l2.e.x;\n        double c2 = a2 * l2.s.x + b2 * l2.s.y;\n\n        double delta = a1 * b2 - a2 * b1;\n        return new Point((b2 * c1 - b1 * c2) / delta, (a1 * c2 - a2 * c1) / delta);\n    }\n\n    public static void main(String[] args) {\n        Line l1 = new Line(new Point(4, 0), new Point(6, 10));\n        Line l2 = new Line(new Point(0, 3), new Point(10, 7));\n        System.out.println(findIntersection(l1, l2));\n\n        l1 = new Line(new Point(0, 0), new Point(1, 1));\n        l2 = new Line(new Point(1, 2), new Point(4, 5));\n        System.out.println(findIntersection(l1, l2));\n    }\n}\n"}
{"id": 55736, "name": "Find the intersection of two lines", "source": "Translate Ruby to Java: Point = Struct.new(:x, :y)\n\nclass Line\n  attr_reader :a, :b\n\n  def initialize(point1, point2)\n    @a = (point1.y - point2.y).fdiv(point1.x - point2.x)\n    @b = point1.y - @a*point1.x\n  end\n\n  def intersect(other)\n    return nil if @a == other.a\n    x = (other.b - @b).fdiv(@a - other.a)\n    y = @a*x + @b\n    Point.new(x,y)\n  end\n\n  def to_s\n    \"y = \n  end\n\nend\n\nl1 = Line.new(Point.new(4, 0), Point.new(6, 10))\nl2 = Line.new(Point.new(0, 3), Point.new(10, 7))\n\nputs \"Line \n", "target": "public class Intersection {\n    private static class Point {\n        double x, y;\n\n        Point(double x, double y) {\n            this.x = x;\n            this.y = y;\n        }\n\n        @Override\n        public String toString() {\n            return String.format(\"{%f, %f}\", x, y);\n        }\n    }\n\n    private static class Line {\n        Point s, e;\n\n        Line(Point s, Point e) {\n            this.s = s;\n            this.e = e;\n        }\n    }\n\n    private static Point findIntersection(Line l1, Line l2) {\n        double a1 = l1.e.y - l1.s.y;\n        double b1 = l1.s.x - l1.e.x;\n        double c1 = a1 * l1.s.x + b1 * l1.s.y;\n\n        double a2 = l2.e.y - l2.s.y;\n        double b2 = l2.s.x - l2.e.x;\n        double c2 = a2 * l2.s.x + b2 * l2.s.y;\n\n        double delta = a1 * b2 - a2 * b1;\n        return new Point((b2 * c1 - b1 * c2) / delta, (a1 * c2 - a2 * c1) / delta);\n    }\n\n    public static void main(String[] args) {\n        Line l1 = new Line(new Point(4, 0), new Point(6, 10));\n        Line l2 = new Line(new Point(0, 3), new Point(10, 7));\n        System.out.println(findIntersection(l1, l2));\n\n        l1 = new Line(new Point(0, 0), new Point(1, 1));\n        l2 = new Line(new Point(1, 2), new Point(4, 5));\n        System.out.println(findIntersection(l1, l2));\n    }\n}\n"}
{"id": 55737, "name": "Find the intersection of two lines", "source": "Translate Ruby to Python: Point = Struct.new(:x, :y)\n\nclass Line\n  attr_reader :a, :b\n\n  def initialize(point1, point2)\n    @a = (point1.y - point2.y).fdiv(point1.x - point2.x)\n    @b = point1.y - @a*point1.x\n  end\n\n  def intersect(other)\n    return nil if @a == other.a\n    x = (other.b - @b).fdiv(@a - other.a)\n    y = @a*x + @b\n    Point.new(x,y)\n  end\n\n  def to_s\n    \"y = \n  end\n\nend\n\nl1 = Line.new(Point.new(4, 0), Point.new(6, 10))\nl2 = Line.new(Point.new(0, 3), Point.new(10, 7))\n\nputs \"Line \n", "target": "from __future__ import division\n\ndef setup():\n    \n    (a, b), (c, d) = (4, 0), (6, 10)  \n    (e, f), (g, h) = (0, 3), (10, 7)  \n    pt = line_instersect(a, b, c, d, e, f, g, h)\n    scale(9)\n    line(a, b, c, d)\n    line(e, f, g, h)\n    if pt:\n        x, y = pt\n        stroke(255)\n        point(x, y)\n    println(pt)  \n\ndef line_instersect(Ax1, Ay1, Ax2, Ay2, Bx1, By1, Bx2, By2):\n    \n    d = (By2 - By1) * (Ax2 - Ax1) - (Bx2 - Bx1) * (Ay2 - Ay1)\n    if d:\n        uA = ((Bx2 - Bx1) * (Ay1 - By1) - (By2 - By1) * (Ax1 - Bx1)) / d\n        uB = ((Ax2 - Ax1) * (Ay1 - By1) - (Ay2 - Ay1) * (Ax1 - Bx1)) / d\n    else:\n        return\n    if not(0 <= uA <= 1 and 0 <= uB <= 1):\n        return\n    x = Ax1 + uA * (Ax2 - Ax1)\n    y = Ay1 + uA * (Ay2 - Ay1)\n    return x, y\n"}
{"id": 55738, "name": "Find the intersection of two lines", "source": "Translate Ruby to Python: Point = Struct.new(:x, :y)\n\nclass Line\n  attr_reader :a, :b\n\n  def initialize(point1, point2)\n    @a = (point1.y - point2.y).fdiv(point1.x - point2.x)\n    @b = point1.y - @a*point1.x\n  end\n\n  def intersect(other)\n    return nil if @a == other.a\n    x = (other.b - @b).fdiv(@a - other.a)\n    y = @a*x + @b\n    Point.new(x,y)\n  end\n\n  def to_s\n    \"y = \n  end\n\nend\n\nl1 = Line.new(Point.new(4, 0), Point.new(6, 10))\nl2 = Line.new(Point.new(0, 3), Point.new(10, 7))\n\nputs \"Line \n", "target": "from __future__ import division\n\ndef setup():\n    \n    (a, b), (c, d) = (4, 0), (6, 10)  \n    (e, f), (g, h) = (0, 3), (10, 7)  \n    pt = line_instersect(a, b, c, d, e, f, g, h)\n    scale(9)\n    line(a, b, c, d)\n    line(e, f, g, h)\n    if pt:\n        x, y = pt\n        stroke(255)\n        point(x, y)\n    println(pt)  \n\ndef line_instersect(Ax1, Ay1, Ax2, Ay2, Bx1, By1, Bx2, By2):\n    \n    d = (By2 - By1) * (Ax2 - Ax1) - (Bx2 - Bx1) * (Ay2 - Ay1)\n    if d:\n        uA = ((Bx2 - Bx1) * (Ay1 - By1) - (By2 - By1) * (Ax1 - Bx1)) / d\n        uB = ((Ax2 - Ax1) * (Ay1 - By1) - (Ay2 - Ay1) * (Ax1 - Bx1)) / d\n    else:\n        return\n    if not(0 <= uA <= 1 and 0 <= uB <= 1):\n        return\n    x = Ax1 + uA * (Ax2 - Ax1)\n    y = Ay1 + uA * (Ay2 - Ay1)\n    return x, y\n"}
{"id": 56165, "name": "Align columns", "source": "Translate Ruby to C#: J2justifier = {Left: :ljust, Right: :rjust, Center: :center}\n\n\ndef aligner(infile, justification = :Left)\n  fieldsbyrow = infile.map {|line| line.strip.split('$')}\n  \n  maxfields = fieldsbyrow.map(&:length).max\n  fieldsbyrow.map! {|row| row + ['']*(maxfields - row.length)}\n  \n  colwidths = fieldsbyrow.transpose.map {|column|\n    column.map(&:length).max\n  }\n  \n  justifier = J2justifier[justification]\n  fieldsbyrow.map {|row|\n    row.zip(colwidths).map {|field, width|\n      field.send(justifier, width)\n    }.join(\" \")\n  }.join(\"\\n\")\nend\n\nrequire 'stringio'\n\ntextinfile = <<END\nGiven$a$text$file$of$many$lines,$where$fields$within$a$line$\nare$delineated$by$a$single$'dollar'$character,$write$a$program\nthat$aligns$each$column$of$fields$by$ensuring$that$words$in$each$\ncolumn$are$separated$by$at$least$one$space.\nFurther,$allow$for$each$word$in$a$column$to$be$either$left$\njustified,$right$justified,$or$center$justified$within$its$column.\nEND\n\nfor align in [:Left, :Right, :Center]\n  infile = StringIO.new(textinfile)\n  puts \"\\n\n  puts aligner(infile, align)\nend\n", "target": "using System;\nclass ColumnAlignerProgram\n{\n    delegate string Justification(string s, int width);\n\n    static string[] AlignColumns(string[] lines, Justification justification)\n    {\n        const char Separator = '$';\n        \n        string[][] table = new string[lines.Length][];\n        int columns = 0;\n        for (int i = 0; i < lines.Length; i++)\n        {\n            string[] row = lines[i].TrimEnd(Separator).Split(Separator);\n            if (columns < row.Length) columns = row.Length;\n            table[i] = row;\n        }\n        \n        string[][] formattedTable = new string[table.Length][];\n        for (int i = 0; i < formattedTable.Length; i++)\n        {\n            formattedTable[i] = new string[columns];\n        }\n        for (int j = 0; j < columns; j++)\n        {\n            \n            int columnWidth = 0;\n            for (int i = 0; i < table.Length; i++)\n            {\n                if (j < table[i].Length && columnWidth < table[i][j].Length)\n                    columnWidth = table[i][j].Length;\n            }\n            \n            for (int i = 0; i < formattedTable.Length; i++)\n            {\n                if (j < table[i].Length)\n                    formattedTable[i][j] = justification(table[i][j], columnWidth);\n                else \n                    formattedTable[i][j] = new String(' ', columnWidth);\n            }\n        }\n        \n        string[] result = new string[formattedTable.Length];\n        for (int i = 0; i < result.Length; i++)\n        {\n            result[i] = String.Join(\" \", formattedTable[i]);\n        }\n        return result;\n    }\n\n    static string JustifyLeft(string s, int width) { return s.PadRight(width); }\n    static string JustifyRight(string s, int width) { return s.PadLeft(width); }\n    static string JustifyCenter(string s, int width) \n    { \n        return s.PadLeft((width + s.Length) / 2).PadRight(width); \n    }\n\n    static void Main()\n    {\n        string[] input = {    \n            \"Given$a$text$file$of$many$lines,$where$fields$within$a$line$\",\n            \"are$delineated$by$a$single$'dollar'$character,$write$a$program\",\n            \"that$aligns$each$column$of$fields$by$ensuring$that$words$in$each$\",\n            \"column$are$separated$by$at$least$one$space.\",\n            \"Further,$allow$for$each$word$in$a$column$to$be$either$left$\",\n            \"justified,$right$justified,$or$center$justified$within$its$column.\",\n        };\n\n        foreach (string line in AlignColumns(input, JustifyCenter))\n        {\n            Console.WriteLine(line);\n        }\n    }\n}\n"}
{"id": 56166, "name": "Align columns", "source": "Translate Ruby to Java: J2justifier = {Left: :ljust, Right: :rjust, Center: :center}\n\n\ndef aligner(infile, justification = :Left)\n  fieldsbyrow = infile.map {|line| line.strip.split('$')}\n  \n  maxfields = fieldsbyrow.map(&:length).max\n  fieldsbyrow.map! {|row| row + ['']*(maxfields - row.length)}\n  \n  colwidths = fieldsbyrow.transpose.map {|column|\n    column.map(&:length).max\n  }\n  \n  justifier = J2justifier[justification]\n  fieldsbyrow.map {|row|\n    row.zip(colwidths).map {|field, width|\n      field.send(justifier, width)\n    }.join(\" \")\n  }.join(\"\\n\")\nend\n\nrequire 'stringio'\n\ntextinfile = <<END\nGiven$a$text$file$of$many$lines,$where$fields$within$a$line$\nare$delineated$by$a$single$'dollar'$character,$write$a$program\nthat$aligns$each$column$of$fields$by$ensuring$that$words$in$each$\ncolumn$are$separated$by$at$least$one$space.\nFurther,$allow$for$each$word$in$a$column$to$be$either$left$\njustified,$right$justified,$or$center$justified$within$its$column.\nEND\n\nfor align in [:Left, :Right, :Center]\n  infile = StringIO.new(textinfile)\n  puts \"\\n\n  puts aligner(infile, align)\nend\n", "target": "import java.io.IOException;\nimport java.nio.charset.StandardCharsets;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.StringUtils;\n\n\npublic class ColumnAligner {\n    private List<String[]> words = new ArrayList<>();\n    private int columns = 0;\n    private List<Integer> columnWidths = new ArrayList<>();\n\n    \n    public ColumnAligner(String s) {\n        String[] lines = s.split(\"\\\\n\");\n        for (String line : lines) {\n            processInputLine(line);\n        }\n    }\n\n    \n    public ColumnAligner(List<String> lines) {\n        for (String line : lines) {\n            processInputLine(line);\n        }\n    }\n\n    private void processInputLine(String line) {\n        String[] lineWords = line.split(\"\\\\$\");\n        words.add(lineWords);\n        columns = Math.max(columns, lineWords.length);\n        for (int i = 0; i < lineWords.length; i++) {\n            String word = lineWords[i];\n            if (i >= columnWidths.size()) {\n                columnWidths.add(word.length());\n            } else {\n                columnWidths.set(i, Math.max(columnWidths.get(i), word.length()));\n            }\n        }\n    }\n\n    interface AlignFunction {\n        String align(String s, int length);\n    }\n\n    \n    public String alignLeft() {\n        return align(new AlignFunction() {\n            @Override\n            public String align(String s, int length) {\n                return StringUtils.rightPad(s, length);\n            }\n        });\n    }\n\n    \n    public String alignRight() {\n        return align(new AlignFunction() {\n            @Override\n            public String align(String s, int length) {\n                return StringUtils.leftPad(s, length);\n            }\n        });\n    }\n\n    \n    public String alignCenter() {\n        return align(new AlignFunction() {\n            @Override\n            public String align(String s, int length) {\n                return StringUtils.center(s, length);\n            }\n        });\n    }\n\n    private String align(AlignFunction a) {\n        StringBuilder result = new StringBuilder();\n        for (String[] lineWords : words) {\n            for (int i = 0; i < lineWords.length; i++) {\n                String word = lineWords[i];\n                if (i == 0) {\n                    result.append(\"|\");\n                }\n                result.append(a.align(word, columnWidths.get(i)) + \"|\");\n            }\n            result.append(\"\\n\");\n        }\n        return result.toString();\n    }\n\n    public static void main(String args[]) throws IOException {\n        if (args.length < 1) {\n            System.out.println(\"Usage: ColumnAligner file [left|right|center]\");\n            return;\n        }\n        String filePath = args[0];\n        String alignment = \"left\";\n        if (args.length >= 2) {\n            alignment = args[1];\n        }\n        ColumnAligner ca = new ColumnAligner(Files.readAllLines(Paths.get(filePath), StandardCharsets.UTF_8));\n        switch (alignment) {\n        case \"left\":\n            System.out.print(ca.alignLeft());\n            break;\n        case \"right\":\n            System.out.print(ca.alignRight());\n            break;\n        case \"center\":\n            System.out.print(ca.alignCenter());\n            break;\n        default:\n            System.err.println(String.format(\"Error! Unknown alignment: '%s'\", alignment));\n            break;\n        }\n    }\n}\n"}
{"id": 56167, "name": "Align columns", "source": "Translate Ruby to Python: J2justifier = {Left: :ljust, Right: :rjust, Center: :center}\n\n\ndef aligner(infile, justification = :Left)\n  fieldsbyrow = infile.map {|line| line.strip.split('$')}\n  \n  maxfields = fieldsbyrow.map(&:length).max\n  fieldsbyrow.map! {|row| row + ['']*(maxfields - row.length)}\n  \n  colwidths = fieldsbyrow.transpose.map {|column|\n    column.map(&:length).max\n  }\n  \n  justifier = J2justifier[justification]\n  fieldsbyrow.map {|row|\n    row.zip(colwidths).map {|field, width|\n      field.send(justifier, width)\n    }.join(\" \")\n  }.join(\"\\n\")\nend\n\nrequire 'stringio'\n\ntextinfile = <<END\nGiven$a$text$file$of$many$lines,$where$fields$within$a$line$\nare$delineated$by$a$single$'dollar'$character,$write$a$program\nthat$aligns$each$column$of$fields$by$ensuring$that$words$in$each$\ncolumn$are$separated$by$at$least$one$space.\nFurther,$allow$for$each$word$in$a$column$to$be$either$left$\njustified,$right$justified,$or$center$justified$within$its$column.\nEND\n\nfor align in [:Left, :Right, :Center]\n  infile = StringIO.new(textinfile)\n  puts \"\\n\n  puts aligner(infile, align)\nend\n", "target": "from itertools import zip_longest\n\ntxt = \n \nparts = [line.rstrip(\"$\").split(\"$\") for line in txt.splitlines()]\nwidths = [max(len(word) for word in col) \n          for col in zip_longest(*parts, fillvalue='')]\n \nfor justify in \"<_Left ^_Center >_Right\".split():\n    j, jtext = justify.split('_')\n    print(f\"{jtext} column-aligned output:\\n\")\n    for line in parts:\n        print(' '.join(f\"{wrd:{j}{wdth}}\" for wdth, wrd in zip(widths, line)))\n    print(\"- \" * 52)\n"}
{"id": 56491, "name": "Longest common prefix", "source": "Translate Ruby to C#: def lcp(*strs)\n  return \"\" if strs.empty?\n  min, max = strs.minmax\n  idx = min.size.times{|i| break i if min[i] != max[i]}\n  min[0...idx]\nend\n\ndata = [\n  [\"interspecies\",\"interstellar\",\"interstate\"],\n  [\"throne\",\"throne\"],\n  [\"throne\",\"dungeon\"],\n  [\"throne\",\"\",\"throne\"],\n  [\"cheese\"],\n  [\"\"],\n  [],\n  [\"prefix\",\"suffix\"],\n  [\"foo\",\"foobar\"]\n]\n\ndata.each do |set|\n  puts \"lcp(\nend\n", "target": "using System;\n\nnamespace LCP {\n    class Program {\n        public static string LongestCommonPrefix(params string[] sa) {\n            if (null == sa) return \"\"; \n            string ret = \"\";\n            int idx = 0;\n\n            while (true) {\n                char thisLetter = '\\0';\n                foreach (var word in sa) {\n                    if (idx == word.Length) {\n                        \n                        return ret;\n                    }\n                    if (thisLetter == '\\0') {\n                        \n                        thisLetter = word[idx];\n                    }\n                    if (thisLetter != word[idx]) {\n                        return ret;\n                    }\n                }\n\n                \n                ret += thisLetter;\n                idx++;\n            }\n        }\n\n        static void Main(string[] args) {\n            Console.WriteLine(LongestCommonPrefix(\"interspecies\", \"interstellar\", \"interstate\"));\n            Console.WriteLine(LongestCommonPrefix(\"throne\", \"throne\"));\n            Console.WriteLine(LongestCommonPrefix(\"throne\", \"dungeon\"));\n            Console.WriteLine(LongestCommonPrefix(\"throne\", \"\", \"throne\"));\n            Console.WriteLine(LongestCommonPrefix(\"cheese\"));\n            Console.WriteLine(LongestCommonPrefix(\"\"));\n            Console.WriteLine(LongestCommonPrefix(null));\n            Console.WriteLine(LongestCommonPrefix(\"prefix\", \"suffix\"));\n            Console.WriteLine(LongestCommonPrefix(\"foo\", \"foobar\"));\n        }\n    }\n}\n"}
{"id": 56492, "name": "Longest common prefix", "source": "Translate Ruby to C#: def lcp(*strs)\n  return \"\" if strs.empty?\n  min, max = strs.minmax\n  idx = min.size.times{|i| break i if min[i] != max[i]}\n  min[0...idx]\nend\n\ndata = [\n  [\"interspecies\",\"interstellar\",\"interstate\"],\n  [\"throne\",\"throne\"],\n  [\"throne\",\"dungeon\"],\n  [\"throne\",\"\",\"throne\"],\n  [\"cheese\"],\n  [\"\"],\n  [],\n  [\"prefix\",\"suffix\"],\n  [\"foo\",\"foobar\"]\n]\n\ndata.each do |set|\n  puts \"lcp(\nend\n", "target": "using System;\n\nnamespace LCP {\n    class Program {\n        public static string LongestCommonPrefix(params string[] sa) {\n            if (null == sa) return \"\"; \n            string ret = \"\";\n            int idx = 0;\n\n            while (true) {\n                char thisLetter = '\\0';\n                foreach (var word in sa) {\n                    if (idx == word.Length) {\n                        \n                        return ret;\n                    }\n                    if (thisLetter == '\\0') {\n                        \n                        thisLetter = word[idx];\n                    }\n                    if (thisLetter != word[idx]) {\n                        return ret;\n                    }\n                }\n\n                \n                ret += thisLetter;\n                idx++;\n            }\n        }\n\n        static void Main(string[] args) {\n            Console.WriteLine(LongestCommonPrefix(\"interspecies\", \"interstellar\", \"interstate\"));\n            Console.WriteLine(LongestCommonPrefix(\"throne\", \"throne\"));\n            Console.WriteLine(LongestCommonPrefix(\"throne\", \"dungeon\"));\n            Console.WriteLine(LongestCommonPrefix(\"throne\", \"\", \"throne\"));\n            Console.WriteLine(LongestCommonPrefix(\"cheese\"));\n            Console.WriteLine(LongestCommonPrefix(\"\"));\n            Console.WriteLine(LongestCommonPrefix(null));\n            Console.WriteLine(LongestCommonPrefix(\"prefix\", \"suffix\"));\n            Console.WriteLine(LongestCommonPrefix(\"foo\", \"foobar\"));\n        }\n    }\n}\n"}
{"id": 56494, "name": "Longest common prefix", "source": "Translate Ruby to Java: def lcp(*strs)\n  return \"\" if strs.empty?\n  min, max = strs.minmax\n  idx = min.size.times{|i| break i if min[i] != max[i]}\n  min[0...idx]\nend\n\ndata = [\n  [\"interspecies\",\"interstellar\",\"interstate\"],\n  [\"throne\",\"throne\"],\n  [\"throne\",\"dungeon\"],\n  [\"throne\",\"\",\"throne\"],\n  [\"cheese\"],\n  [\"\"],\n  [],\n  [\"prefix\",\"suffix\"],\n  [\"foo\",\"foobar\"]\n]\n\ndata.each do |set|\n  puts \"lcp(\nend\n", "target": "public class LCP {\n    public static String lcp(String... list){\n        if(list == null) return \"\";\n        String ret = \"\";\n        int idx = 0;\n\n        while(true){\n            char thisLetter = 0;\n            for(String word : list){\n                if(idx == word.length()){ \n                    return ret;\n                }\n                if(thisLetter == 0){ \n                    thisLetter = word.charAt(idx);\n                }\n                if(thisLetter != word.charAt(idx)){ \n                    return ret;\n                }\n            }\n            ret += thisLetter;\n            idx++;\n        }\n    }\n    \n    public static void main(String[] args){\n        System.out.println(lcp(\"interspecies\",\"interstellar\",\"interstate\"));\n        System.out.println(lcp(\"throne\",\"throne\"));\n        System.out.println(lcp(\"throne\",\"dungeon\"));\n        System.out.println(lcp(\"throne\",\"\",\"throne\"));\n        System.out.println(lcp(\"cheese\"));\n        System.out.println(lcp(\"\"));\n        System.out.println(lcp(null));\n        System.out.println(lcp(\"prefix\",\"suffix\"));\n        System.out.println(lcp(\"foo\",\"foobar\"));\n    }\n}\n"}
{"id": 56495, "name": "Longest common prefix", "source": "Translate Ruby to Java: def lcp(*strs)\n  return \"\" if strs.empty?\n  min, max = strs.minmax\n  idx = min.size.times{|i| break i if min[i] != max[i]}\n  min[0...idx]\nend\n\ndata = [\n  [\"interspecies\",\"interstellar\",\"interstate\"],\n  [\"throne\",\"throne\"],\n  [\"throne\",\"dungeon\"],\n  [\"throne\",\"\",\"throne\"],\n  [\"cheese\"],\n  [\"\"],\n  [],\n  [\"prefix\",\"suffix\"],\n  [\"foo\",\"foobar\"]\n]\n\ndata.each do |set|\n  puts \"lcp(\nend\n", "target": "public class LCP {\n    public static String lcp(String... list){\n        if(list == null) return \"\";\n        String ret = \"\";\n        int idx = 0;\n\n        while(true){\n            char thisLetter = 0;\n            for(String word : list){\n                if(idx == word.length()){ \n                    return ret;\n                }\n                if(thisLetter == 0){ \n                    thisLetter = word.charAt(idx);\n                }\n                if(thisLetter != word.charAt(idx)){ \n                    return ret;\n                }\n            }\n            ret += thisLetter;\n            idx++;\n        }\n    }\n    \n    public static void main(String[] args){\n        System.out.println(lcp(\"interspecies\",\"interstellar\",\"interstate\"));\n        System.out.println(lcp(\"throne\",\"throne\"));\n        System.out.println(lcp(\"throne\",\"dungeon\"));\n        System.out.println(lcp(\"throne\",\"\",\"throne\"));\n        System.out.println(lcp(\"cheese\"));\n        System.out.println(lcp(\"\"));\n        System.out.println(lcp(null));\n        System.out.println(lcp(\"prefix\",\"suffix\"));\n        System.out.println(lcp(\"foo\",\"foobar\"));\n    }\n}\n"}
{"id": 56496, "name": "Longest common prefix", "source": "Translate Ruby to Python: def lcp(*strs)\n  return \"\" if strs.empty?\n  min, max = strs.minmax\n  idx = min.size.times{|i| break i if min[i] != max[i]}\n  min[0...idx]\nend\n\ndata = [\n  [\"interspecies\",\"interstellar\",\"interstate\"],\n  [\"throne\",\"throne\"],\n  [\"throne\",\"dungeon\"],\n  [\"throne\",\"\",\"throne\"],\n  [\"cheese\"],\n  [\"\"],\n  [],\n  [\"prefix\",\"suffix\"],\n  [\"foo\",\"foobar\"]\n]\n\ndata.each do |set|\n  puts \"lcp(\nend\n", "target": "import os.path\n\ndef lcp(*s):\n    return os.path.commonprefix(s)\n\nassert lcp(\"interspecies\",\"interstellar\",\"interstate\") == \"inters\"\nassert lcp(\"throne\",\"throne\") == \"throne\"\nassert lcp(\"throne\",\"dungeon\") == \"\"\nassert lcp(\"cheese\") == \"cheese\"\nassert lcp(\"\") == \"\"\nassert lcp(\"prefix\",\"suffix\") == \"\"\nassert lcp(\"foo\",\"foobar\") == \"foo\"\n"}
{"id": 56497, "name": "Longest common prefix", "source": "Translate Ruby to Python: def lcp(*strs)\n  return \"\" if strs.empty?\n  min, max = strs.minmax\n  idx = min.size.times{|i| break i if min[i] != max[i]}\n  min[0...idx]\nend\n\ndata = [\n  [\"interspecies\",\"interstellar\",\"interstate\"],\n  [\"throne\",\"throne\"],\n  [\"throne\",\"dungeon\"],\n  [\"throne\",\"\",\"throne\"],\n  [\"cheese\"],\n  [\"\"],\n  [],\n  [\"prefix\",\"suffix\"],\n  [\"foo\",\"foobar\"]\n]\n\ndata.each do |set|\n  puts \"lcp(\nend\n", "target": "import os.path\n\ndef lcp(*s):\n    return os.path.commonprefix(s)\n\nassert lcp(\"interspecies\",\"interstellar\",\"interstate\") == \"inters\"\nassert lcp(\"throne\",\"throne\") == \"throne\"\nassert lcp(\"throne\",\"dungeon\") == \"\"\nassert lcp(\"cheese\") == \"cheese\"\nassert lcp(\"\") == \"\"\nassert lcp(\"prefix\",\"suffix\") == \"\"\nassert lcp(\"foo\",\"foobar\") == \"foo\"\n"}
{"id": 56761, "name": "String matching", "source": "Translate Ruby to C#: p 'abcd'.start_with?('ab')  \np 'abcd'.end_with?('ab')    \np 'abab'.include?('bb')     \np 'abab'.include?('ab')     \np 'abab'['bb']              \np 'abab'['ab']              \np 'abab'.index('bb')        \np 'abab'.index('ab')        \np 'abab'.index('ab', 1)     \np 'abab'.rindex('ab')       \n", "target": "class Program\n{\n\tpublic static void Main (string[] args)\n\t{\n\t\tvar value = \"abcd\".StartsWith(\"ab\");\n\t\tvalue = \"abcd\".EndsWith(\"zn\"); \n\t\tvalue = \"abab\".Contains(\"bb\"); \n\t\tvalue = \"abab\".Contains(\"ab\"); \n\t\tint loc = \"abab\".IndexOf(\"bb\"); \n\t\tloc = \"abab\".IndexOf(\"ab\"); \n\t\tloc = \"abab\".IndexOf(\"ab\",loc+1); \n\t}\n}\n"}
{"id": 56763, "name": "String matching", "source": "Translate Ruby to Java: p 'abcd'.start_with?('ab')  \np 'abcd'.end_with?('ab')    \np 'abab'.include?('bb')     \np 'abab'.include?('ab')     \np 'abab'['bb']              \np 'abab'['ab']              \np 'abab'.index('bb')        \np 'abab'.index('ab')        \np 'abab'.index('ab', 1)     \np 'abab'.rindex('ab')       \n", "target": "\"abcd\".startsWith(\"ab\") \n\"abcd\".endsWith(\"zn\") \n\"abab\".contains(\"bb\") \n\"abab\".contains(\"ab\") \nint loc = \"abab\".indexOf(\"bb\") \nloc = \"abab\".indexOf(\"ab\") \nloc = \"abab\".indexOf(\"ab\",loc+1) \n"}
{"id": 56764, "name": "String matching", "source": "Translate Ruby to Python: p 'abcd'.start_with?('ab')  \np 'abcd'.end_with?('ab')    \np 'abab'.include?('bb')     \np 'abab'.include?('ab')     \np 'abab'['bb']              \np 'abab'['ab']              \np 'abab'.index('bb')        \np 'abab'.index('ab')        \np 'abab'.index('ab', 1)     \np 'abab'.rindex('ab')       \n", "target": "\"abcd\".startswith(\"ab\") \n\"abcd\".endswith(\"zn\") \n\"bb\" in \"abab\" \n\"ab\" in \"abab\" \nloc = \"abab\".find(\"bb\") \nloc = \"abab\".find(\"ab\") \nloc = \"abab\".find(\"ab\",loc+1) \n"}
{"id": 57043, "name": "Real constants and functions", "source": "Translate Ruby to C#: x = 3.25\ny = 4\n\nputs x.abs       \nputs x.floor     \nputs x.ceil      \nputs x ** y      \nputs\n\ninclude Math     \n\nputs E           \nputs PI          \nputs TAU         \nputs sqrt(x)     \nputs log(x)      \nputs log10(x)    \nputs log(x, y)   \nputs exp(x)      \nputs E**x        \n", "target": "using System;\n\nclass Program {\n    static void Main(string[] args) {        \n        Console.WriteLine(Math.E); \n        Console.WriteLine(Math.PI); \n        Console.WriteLine(Math.Sqrt(10)); \n        Console.WriteLine(Math.Log(10)); \n        Console.WriteLine(Math.Log10(10)); \n        Console.WriteLine(Math.Exp(10)); \n        Console.WriteLine(Math.Abs(10)); \n        Console.WriteLine(Math.Floor(10.0)); \n        Console.WriteLine(Math.Ceiling(10.0)); \n        Console.WriteLine(Math.Pow(2, 5)); \n    }\n}\n"}
{"id": 57045, "name": "Real constants and functions", "source": "Translate Ruby to Java: x = 3.25\ny = 4\n\nputs x.abs       \nputs x.floor     \nputs x.ceil      \nputs x ** y      \nputs\n\ninclude Math     \n\nputs E           \nputs PI          \nputs TAU         \nputs sqrt(x)     \nputs log(x)      \nputs log10(x)    \nputs log(x, y)   \nputs exp(x)      \nputs E**x        \n", "target": "Math.E; \nMath.PI; \nMath.sqrt(x); \nMath.log(x); \nMath.exp(x); \nMath.abs(x); \nMath.floor(x); \nMath.ceil(x); \nMath.pow(x,y); \n"}
{"id": 57046, "name": "Real constants and functions", "source": "Translate Ruby to Python: x = 3.25\ny = 4\n\nputs x.abs       \nputs x.floor     \nputs x.ceil      \nputs x ** y      \nputs\n\ninclude Math     \n\nputs E           \nputs PI          \nputs TAU         \nputs sqrt(x)     \nputs log(x)      \nputs log10(x)    \nputs log(x, y)   \nputs exp(x)      \nputs E**x        \n", "target": "import math\n\nmath.e          \nmath.pi         \nmath.sqrt(x)    \nmath.log(x)     \nmath.log10(x)   \nmath.exp(x)     \nabs(x)          \nmath.floor(x)   \nmath.ceil(x)    \nx ** y          \npow(x, y[, n])  \n\n\n\n"}
{"id": 57223, "name": "Singly-linked list_Element definition", "source": "Translate Ruby to C#: class ListNode\n  attr_accessor :value, :succ\n\n  def initialize(value, succ=nil)\n    self.value = value\n    self.succ = succ\n  end\n\n  def each(&b)\n    yield self\n    succ.each(&b) if succ\n  end\n\n  include Enumerable\n\n  def self.from_array(ary)\n    head = self.new(ary[0], nil)\n    prev = head\n    ary[1..-1].each do |val|\n      node = self.new(val, nil)\n      prev.succ = node\n      prev = node\n    end\n    head\n  end\nend\n\nlist = ListNode.from_array([1,2,3,4])\n", "target": "class LinkedListNode\n{\n    public int Value { get; set; }\n    public LinkedListNode Next { get; set; }\n\n    \n    public Link(int value, LinkedListNode next = null)\n    {\n        Item = value;\n        Next = next;\n    }\n}\n"}
{"id": 57225, "name": "Singly-linked list_Element definition", "source": "Translate Ruby to Java: class ListNode\n  attr_accessor :value, :succ\n\n  def initialize(value, succ=nil)\n    self.value = value\n    self.succ = succ\n  end\n\n  def each(&b)\n    yield self\n    succ.each(&b) if succ\n  end\n\n  include Enumerable\n\n  def self.from_array(ary)\n    head = self.new(ary[0], nil)\n    prev = head\n    ary[1..-1].each do |val|\n      node = self.new(val, nil)\n      prev.succ = node\n      prev = node\n    end\n    head\n  end\nend\n\nlist = ListNode.from_array([1,2,3,4])\n", "target": "class Link\n{\n    Link next;\n    int data;\n}\n"}
{"id": 57226, "name": "Singly-linked list_Element definition", "source": "Translate Ruby to Python: class ListNode\n  attr_accessor :value, :succ\n\n  def initialize(value, succ=nil)\n    self.value = value\n    self.succ = succ\n  end\n\n  def each(&b)\n    yield self\n    succ.each(&b) if succ\n  end\n\n  include Enumerable\n\n  def self.from_array(ary)\n    head = self.new(ary[0], nil)\n    prev = head\n    ary[1..-1].each do |val|\n      node = self.new(val, nil)\n      prev.succ = node\n      prev = node\n    end\n    head\n  end\nend\n\nlist = ListNode.from_array([1,2,3,4])\n", "target": "class LinkedList(object):\n     \n\tclass Node(object):\n\t\tdef __init__(self, item):\n\t\t\tself.value  = item\n\t\t\tself.next = None\n\tdef __init__(self, item=None):\n\t\tif item is not None:\n\t\t\tself.head = Node(item); self.tail = self.head\n\t\telse:\n\t\t\tself.head = None; self.tail = None\n\tdef append(self, item):\n\t\tif not self.head:\n\t\t\tself.head = Node(item)\n\t\t\tself.tail = self.head\n\t\telif self.tail:\n\t\t\tself.tail.next = Node(item)\n\t\t\tself.tail = self.tail.next\n\t\telse:\n\t\t\tself.tail = Node(item)\n\tdef __iter__(self):\n\t\tcursor = self.head\n\t\twhile cursor:\n\t\t\tyield cursor.value\n\t\t\tcursor = cursor.next\n"}
{"id": 57343, "name": "Pell's equation", "source": "Translate Ruby to C#: def solve_pell(n)\n  x = Integer.sqrt(n)\n  y = x\n  z = 1\n  r = 2*x\n  e1, e2 = 1, 0\n  f1, f2 = 0, 1\n\n  loop do\n    y = r*z - y\n    z = (n - y*y) / z\n    r = (x + y) / z\n    e1, e2 = e2, r*e2 + e1\n    f1, f2 = f2, r*f2 + f1\n    a,  b  = e2 + x*f2, f2\n    break a, b if a*a - n*b*b == 1\n  end\nend\n\n[61, 109, 181, 277].each {|n| puts \"x*x - %3s*y*y = 1 for x =\u00a0%-21s and y = %s\" % [n, *solve_pell(n)]}\n", "target": "using System;\nusing System.Numerics;\n\nstatic class Program\n{\n    static void Fun(ref BigInteger a, ref BigInteger b, int c)\n    {\n        BigInteger t = a; a = b; b = b * c + t;\n    }\n\n    static void SolvePell(int n, ref BigInteger a, ref BigInteger b)\n    {\n        int x = (int)Math.Sqrt(n), y = x, z = 1, r = x << 1;\n        BigInteger e1 = 1, e2 = 0, f1 = 0, f2 = 1;\n        while (true)\n        {\n            y = r * z - y; z = (n - y * y) / z; r = (x + y) / z;\n            Fun(ref e1, ref e2, r); Fun(ref f1, ref f2, r); a = f2; b = e2; Fun(ref b, ref a, x);\n            if (a * a - n * b * b == 1) return;\n        }\n    }\n\n    static void Main()\n    {\n        BigInteger x, y; foreach (int n in new[] { 61, 109, 181, 277 })\n        {\n            SolvePell(n, ref x, ref y);\n            Console.WriteLine(\"x^2 - {0,3} * y^2 = 1 for x = {1,27:n0} and y = {2,25:n0}\", n, x, y);\n        }\n    }\n}\n"}
{"id": 57345, "name": "Pell's equation", "source": "Translate Ruby to Java: def solve_pell(n)\n  x = Integer.sqrt(n)\n  y = x\n  z = 1\n  r = 2*x\n  e1, e2 = 1, 0\n  f1, f2 = 0, 1\n\n  loop do\n    y = r*z - y\n    z = (n - y*y) / z\n    r = (x + y) / z\n    e1, e2 = e2, r*e2 + e1\n    f1, f2 = f2, r*f2 + f1\n    a,  b  = e2 + x*f2, f2\n    break a, b if a*a - n*b*b == 1\n  end\nend\n\n[61, 109, 181, 277].each {|n| puts \"x*x - %3s*y*y = 1 for x =\u00a0%-21s and y = %s\" % [n, *solve_pell(n)]}\n", "target": "import java.math.BigInteger;\nimport java.text.NumberFormat;\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class PellsEquation {\n\n    public static void main(String[] args) {\n        NumberFormat format = NumberFormat.getInstance();\n        for ( int n : new int[] {61, 109, 181, 277, 8941} ) {\n            BigInteger[] pell = pellsEquation(n);\n            System.out.printf(\"x^2 - %3d * y^2 = 1 for:%n    x = %s%n    y = %s%n%n\", n,  format.format(pell[0]),  format.format(pell[1]));\n        }\n    }\n\n    private static final BigInteger[] pellsEquation(int n) {\n        int a0 = (int) Math.sqrt(n);\n        if ( a0*a0 == n ) {\n            throw new IllegalArgumentException(\"ERROR 102:  Invalid n = \" + n);\n        }\n        List<Integer> continuedFrac = continuedFraction(n);\n        int count = 0;\n        BigInteger ajm2 = BigInteger.ONE;\n        BigInteger ajm1 = new BigInteger(a0 + \"\");\n        BigInteger bjm2 = BigInteger.ZERO;\n        BigInteger bjm1 = BigInteger.ONE;\n        boolean stop = (continuedFrac.size() % 2 == 1);\n        if ( continuedFrac.size() == 2 ) {\n            stop = true;\n        }\n        while ( true ) {\n            count++;\n            BigInteger bn = new BigInteger(continuedFrac.get(count) + \"\");\n            BigInteger aj = bn.multiply(ajm1).add(ajm2);\n            BigInteger bj = bn.multiply(bjm1).add(bjm2);\n            if ( stop && (count == continuedFrac.size()-2 || continuedFrac.size() == 2) ) {\n                return new BigInteger[] {aj, bj};\n            }\n            else if (continuedFrac.size() % 2 == 0 && count == continuedFrac.size()-2 ) {\n                stop = true;\n            }\n            if ( count == continuedFrac.size()-1 ) {\n                count = 0;\n            }\n            ajm2 = ajm1;\n            ajm1 = aj;\n            bjm2 = bjm1;\n            bjm1 = bj;\n        }\n    }\n\n    private static final List<Integer> continuedFraction(int n) {\n        List<Integer> answer = new ArrayList<Integer>();\n        int a0 = (int) Math.sqrt(n);\n        answer.add(a0);\n        int a = -a0;\n        int aStart = a;\n        int b = 1;\n        int bStart = b;\n\n        while ( true ) {\n            \n            int[] values = iterateFrac(n, a, b);\n            answer.add(values[0]);\n            a = values[1];\n            b = values[2];\n            if (a == aStart && b == bStart) break;\n        }\n        return answer;\n    }\n    \n    \n    \n    \n    private static final int[] iterateFrac(int n, int a, int b) {\n        int x = (int) Math.floor((b * Math.sqrt(n) - b * a)/(n - a * a));\n        int[] answer = new int[3];\n        answer[0] = x;\n        answer[1] = -(b * a + x *(n - a * a)) / b;\n        answer[2] = (n - a * a) / b;\n        return answer;\n    }\n\n\n}\n"}
{"id": 57346, "name": "Pell's equation", "source": "Translate Ruby to Python: def solve_pell(n)\n  x = Integer.sqrt(n)\n  y = x\n  z = 1\n  r = 2*x\n  e1, e2 = 1, 0\n  f1, f2 = 0, 1\n\n  loop do\n    y = r*z - y\n    z = (n - y*y) / z\n    r = (x + y) / z\n    e1, e2 = e2, r*e2 + e1\n    f1, f2 = f2, r*f2 + f1\n    a,  b  = e2 + x*f2, f2\n    break a, b if a*a - n*b*b == 1\n  end\nend\n\n[61, 109, 181, 277].each {|n| puts \"x*x - %3s*y*y = 1 for x =\u00a0%-21s and y = %s\" % [n, *solve_pell(n)]}\n", "target": "import math\n\ndef solvePell(n):\n    x = int(math.sqrt(n))\n    y, z, r = x, 1, x << 1\n    e1, e2 = 1, 0\n    f1, f2 = 0, 1\n    while True:\n        y = r * z - y\n        z = (n - y * y) // z\n        r = (x + y) // z\n\n        e1, e2 = e2, e1 + e2 * r\n        f1, f2 = f2, f1 + f2 * r\n\n        a, b = f2 * x + e2, f2\n        if a * a - n * b * b == 1:\n            return a, b\n\nfor n in [61, 109, 181, 277]:\n    x, y = solvePell(n)\n    print(\"x^2 - %3d * y^2 = 1 for x = %27d and y = %25d\" % (n, x, y))\n"}
{"id": 57527, "name": "System time", "source": "Translate Ruby to Java: \nTime.local\n\n\nTime.utc\n\n\nTime.monotonic\n", "target": "public class SystemTime{\n    public static void main(String[] args){\n        System.out.format(\"%tc%n\", System.currentTimeMillis());\n    }\n}\n"}
{"id": 57698, "name": "Roots of a quadratic function", "source": "Translate Ruby to C#: require 'cmath'\n\ndef quadratic(a, b, c)\n  sqrt_discriminant = CMath.sqrt(b**2 - 4*a*c)\n  [(-b + sqrt_discriminant) / (2.0*a), (-b - sqrt_discriminant) / (2.0*a)]\nend\n\np quadratic(3, 4, 4/3.0)  \np quadratic(3, 2, -1)     \np quadratic(3, 2,  1)     \np quadratic(1, 0,  1)     \np quadratic(1, -1e6, 1)   \np quadratic(-2,  7, 15)   \np quadratic(1, -2,  1)    \np quadratic(1,  3,  3)    \n", "target": "using System;\nusing System.Numerics;\n\nclass QuadraticRoots\n{\n    static Tuple<Complex, Complex> Solve(double a, double b, double c)\n    {\n        var q = -(b + Math.Sign(b) * Complex.Sqrt(b * b - 4 * a * c)) / 2;\n        return Tuple.Create(q / a, c / q);\n    }\n\n    static void Main()\n    {\n        Console.WriteLine(Solve(1, -1E20, 1));\n    }\n}\n"}
{"id": 57700, "name": "Roots of a quadratic function", "source": "Translate Ruby to Java: require 'cmath'\n\ndef quadratic(a, b, c)\n  sqrt_discriminant = CMath.sqrt(b**2 - 4*a*c)\n  [(-b + sqrt_discriminant) / (2.0*a), (-b - sqrt_discriminant) / (2.0*a)]\nend\n\np quadratic(3, 4, 4/3.0)  \np quadratic(3, 2, -1)     \np quadratic(3, 2,  1)     \np quadratic(1, 0,  1)     \np quadratic(1, -1e6, 1)   \np quadratic(-2,  7, 15)   \np quadratic(1, -2,  1)    \np quadratic(1,  3,  3)    \n", "target": "public class QuadraticRoots {\n    private static class Complex {\n        double re, im;\n\n        public Complex(double re, double im) {\n            this.re = re;\n            this.im = im;\n        }\n\n        @Override\n        public boolean equals(Object obj) {\n            if (obj == this) {return true;}\n            if (!(obj instanceof Complex)) {return false;}\n            Complex other = (Complex) obj;\n            return (re == other.re) && (im == other.im);\n        }\n\n        @Override\n        public String toString() {\n            if (im == 0.0) {return String.format(\"%g\", re);}\n            if (re == 0.0) {return String.format(\"%gi\", im);}\n            return String.format(\"%g %c %gi\", re,\n                (im < 0.0 ? '-' : '+'), Math.abs(im));\n        }\n    }\n\n    private static Complex[] quadraticRoots(double a, double b, double c) {\n        Complex[] roots = new Complex[2];\n        double d = b * b - 4.0 * a * c;  \n        double aa = a + a;\n\n        if (d < 0.0) {\n            double re = -b / aa;\n            double im = Math.sqrt(-d) / aa;\n            roots[0] = new Complex(re, im);\n            roots[1] = new Complex(re, -im);\n        } else if (b < 0.0) {\n            \n            \n            double re = (-b + Math.sqrt(d)) / aa;\n            roots[0] = new Complex(re, 0.0);\n            roots[1] = new Complex(c / (a * re), 0.0);\n        } else {\n            \n            double re = (-b - Math.sqrt(d)) / aa;\n            roots[1] = new Complex(re, 0.0);\n            roots[0] = new Complex(c / (a * re), 0.0);\n        }\n        return roots;\n    }\n\n    public static void main(String[] args) {\n        double[][] equations = {\n            {1.0, 22.0, -1323.0},   \n            {6.0, -23.0, 20.0},     \n            {1.0, -1.0e9, 1.0},     \n            {1.0, 2.0, 1.0},        \n            {1.0, 0.0, 1.0},        \n            {1.0, 1.0, 1.0}         \n        };\n        for (int i = 0; i < equations.length; i++) {\n            Complex[] roots = quadraticRoots(\n                equations[i][0], equations[i][1], equations[i][2]);\n            System.out.format(\"%na = %g   b = %g   c = %g%n\",\n                equations[i][0], equations[i][1], equations[i][2]);\n            if (roots[0].equals(roots[1])) {\n                System.out.format(\"X1,2 = %s%n\", roots[0]);\n            } else {\n                System.out.format(\"X1 = %s%n\", roots[0]);\n                System.out.format(\"X2 = %s%n\", roots[1]);\n            }\n        }\n    }\n}\n"}
{"id": 57701, "name": "Roots of a quadratic function", "source": "Translate Ruby to Python: require 'cmath'\n\ndef quadratic(a, b, c)\n  sqrt_discriminant = CMath.sqrt(b**2 - 4*a*c)\n  [(-b + sqrt_discriminant) / (2.0*a), (-b - sqrt_discriminant) / (2.0*a)]\nend\n\np quadratic(3, 4, 4/3.0)  \np quadratic(3, 2, -1)     \np quadratic(3, 2,  1)     \np quadratic(1, 0,  1)     \np quadratic(1, -1e6, 1)   \np quadratic(-2,  7, 15)   \np quadratic(1, -2,  1)    \np quadratic(1,  3,  3)    \n", "target": "\n\nimport math\nimport cmath\nimport numpy\n\ndef quad_discriminating_roots(a,b,c, entier = 1e-5):\n    \n    discriminant = b*b - 4*a*c\n    a,b,c,d =complex(a), complex(b), complex(c), complex(discriminant)\n    root1 = (-b + cmath.sqrt(d))/2./a\n    root2 = (-b - cmath.sqrt(d))/2./a\n    if abs(discriminant) < entier:\n        return \"real and equal\", abs(root1), abs(root1)\n    if discriminant > 0:\n        return \"real\", root1.real, root2.real\n    return \"complex\", root1, root2\n\ndef middlebrook(a, b, c):\n    try:\n        q = math.sqrt(a*c)/b\n        f = .5+ math.sqrt(1-4*q*q)/2\n    except ValueError:\n        q = cmath.sqrt(a*c)/b\n        f = .5+ cmath.sqrt(1-4*q*q)/2\n    return (-b/a)*f, -c/(b*f)\n\ndef whatevery(a, b, c):\n    try:\n        d = math.sqrt(b*b-4*a*c)\n    except ValueError:\n        d = cmath.sqrt(b*b-4*a*c)\n    if b > 0:\n        return div(2*c, (-b-d)), div((-b-d), 2*a)\n    else:\n        return div((-b+d), 2*a), div(2*c, (-b+d))\n\ndef div(n, d):\n    \n    try:\n        return n/d\n    except ZeroDivisionError:\n        if n:\n            return n*float('inf')\n        return float('nan')\n\ntestcases = [\n    (3, 4, 4/3),    \n    (3, 2, -1),     \n    (3, 2, 1),      \n    (1, -1e9, 1),   \n    (1, -1e100, 1),\n    (1, -1e200, 1),\n    (1, -1e300, 1),\n]\n\nprint('Naive:')\nfor c in testcases:\n    print(\"{} {:.5} {:.5}\".format(*quad_discriminating_roots(*c)))\n\nprint('\\nMiddlebrook:')\nfor c in testcases:\n    print((\"{:.5} \"*2).format(*middlebrook(*c)))\n\nprint('\\nWhat Every...')\nfor c in testcases:\n    print((\"{:.5} \"*2).format(*whatevery(*c)))\n\nprint('\\nNumpy:')\nfor c in testcases:\n    print((\"{:.5} \"*2).format(*numpy.roots(c)))\n"}
{"id": 57896, "name": "Find palindromic numbers in both binary and ternary bases", "source": "Translate Ruby to C#: pal23 = Enumerator.new do |y|\n  y << 0\n  y << 1\n  for i in 1 .. 1.0/0.0                 \n    n3 = i.to_s(3)\n    n = (n3 + \"1\" + n3.reverse).to_i(3)\n    n2 = n.to_s(2)\n    y << n  if n2.size.odd? and n2 == n2.reverse\n  end\nend\n\nputs \"         decimal          ternary                          binary\"\n6.times do |i|\n  n = pal23.next\n  puts \"%2d: %12d %s %s\" % [i, n, n.to_s(3).center(25), n.to_s(2).center(39)]\nend\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\npublic class FindPalindromicNumbers\n{\n    static void Main(string[] args)\n    {\n        var query =\n            PalindromicTernaries()\n            .Where(IsPalindromicBinary)\n            .Take(6);\n        foreach (var x in query) {\n            Console.WriteLine(\"Decimal: \" + x);\n            Console.WriteLine(\"Ternary: \" + ToTernary(x));\n            Console.WriteLine(\"Binary: \" + Convert.ToString(x, 2));\n            Console.WriteLine();\n        }\n    }\n\n    public static IEnumerable<long> PalindromicTernaries() {\n        yield return 0;\n        yield return 1;\n        yield return 13;\n        yield return 23;\n\n        var f = new List<long> {0};\n        long fMiddle = 9;\n        while (true) {\n            for (long edge = 1; edge < 3; edge++) {\n                int i;\n                do {\n                    \n                    long result = fMiddle;\n                    long fLeft = fMiddle * 3;\n                    long fRight = fMiddle / 3;\n                    for (int j = f.Count - 1; j >= 0; j--) {\n                        result += (fLeft + fRight) * f[j];\n                        fLeft *= 3;\n                        fRight /= 3;\n                    }\n                    result += (fLeft + fRight) * edge;\n                    yield return result;\n\n                    \n                    for (i = f.Count - 1; i >= 0; i--) {\n                        if (f[i] == 2) {\n                            f[i] = 0;\n                        } else {\n                            f[i]++;\n                            break;\n                        }\n                    }\n                } while (i >= 0);\n            }\n            f.Add(0);\n            fMiddle *= 3;\n        }\n    }\n\n    public static bool IsPalindromicBinary(long number) {\n        long n = number;\n        long reverse = 0;\n        while (n != 0) {\n            reverse <<= 1;\n            if ((n & 1) == 1) reverse++;\n            n >>= 1;\n        }\n        return reverse == number;\n    }\n\n    public static string ToTernary(long n)\n    {\n        if (n == 0) return \"0\";\n        string result = \"\";\n        while (n > 0) {        {\n            result = (n % 3) + result;\n            n /= 3;\n        }\n        return result;\n    }\n\n}\n"}
{"id": 57897, "name": "Find palindromic numbers in both binary and ternary bases", "source": "Translate Ruby to C#: pal23 = Enumerator.new do |y|\n  y << 0\n  y << 1\n  for i in 1 .. 1.0/0.0                 \n    n3 = i.to_s(3)\n    n = (n3 + \"1\" + n3.reverse).to_i(3)\n    n2 = n.to_s(2)\n    y << n  if n2.size.odd? and n2 == n2.reverse\n  end\nend\n\nputs \"         decimal          ternary                          binary\"\n6.times do |i|\n  n = pal23.next\n  puts \"%2d: %12d %s %s\" % [i, n, n.to_s(3).center(25), n.to_s(2).center(39)]\nend\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\npublic class FindPalindromicNumbers\n{\n    static void Main(string[] args)\n    {\n        var query =\n            PalindromicTernaries()\n            .Where(IsPalindromicBinary)\n            .Take(6);\n        foreach (var x in query) {\n            Console.WriteLine(\"Decimal: \" + x);\n            Console.WriteLine(\"Ternary: \" + ToTernary(x));\n            Console.WriteLine(\"Binary: \" + Convert.ToString(x, 2));\n            Console.WriteLine();\n        }\n    }\n\n    public static IEnumerable<long> PalindromicTernaries() {\n        yield return 0;\n        yield return 1;\n        yield return 13;\n        yield return 23;\n\n        var f = new List<long> {0};\n        long fMiddle = 9;\n        while (true) {\n            for (long edge = 1; edge < 3; edge++) {\n                int i;\n                do {\n                    \n                    long result = fMiddle;\n                    long fLeft = fMiddle * 3;\n                    long fRight = fMiddle / 3;\n                    for (int j = f.Count - 1; j >= 0; j--) {\n                        result += (fLeft + fRight) * f[j];\n                        fLeft *= 3;\n                        fRight /= 3;\n                    }\n                    result += (fLeft + fRight) * edge;\n                    yield return result;\n\n                    \n                    for (i = f.Count - 1; i >= 0; i--) {\n                        if (f[i] == 2) {\n                            f[i] = 0;\n                        } else {\n                            f[i]++;\n                            break;\n                        }\n                    }\n                } while (i >= 0);\n            }\n            f.Add(0);\n            fMiddle *= 3;\n        }\n    }\n\n    public static bool IsPalindromicBinary(long number) {\n        long n = number;\n        long reverse = 0;\n        while (n != 0) {\n            reverse <<= 1;\n            if ((n & 1) == 1) reverse++;\n            n >>= 1;\n        }\n        return reverse == number;\n    }\n\n    public static string ToTernary(long n)\n    {\n        if (n == 0) return \"0\";\n        string result = \"\";\n        while (n > 0) {        {\n            result = (n % 3) + result;\n            n /= 3;\n        }\n        return result;\n    }\n\n}\n"}
{"id": 57898, "name": "Find palindromic numbers in both binary and ternary bases", "source": "Translate Ruby to Java: pal23 = Enumerator.new do |y|\n  y << 0\n  y << 1\n  for i in 1 .. 1.0/0.0                 \n    n3 = i.to_s(3)\n    n = (n3 + \"1\" + n3.reverse).to_i(3)\n    n2 = n.to_s(2)\n    y << n  if n2.size.odd? and n2 == n2.reverse\n  end\nend\n\nputs \"         decimal          ternary                          binary\"\n6.times do |i|\n  n = pal23.next\n  puts \"%2d: %12d %s %s\" % [i, n, n.to_s(3).center(25), n.to_s(2).center(39)]\nend\n", "target": "public class Pali23 {\n\tpublic static boolean isPali(String x){\n\t\treturn x.equals(new StringBuilder(x).reverse().toString());\n\t}\n\t\n\tpublic static void main(String[] args){\n\t\t\n\t\tfor(long i = 0, count = 0; count < 6;i++){\n\t\t\tif((i & 1) == 0 && (i != 0)) continue; \n\t\t\t\n\t\t\t\n\t\t\tif(isPali(Long.toBinaryString(i)) && isPali(Long.toString(i, 3))){\n\t\t\t\tSystem.out.println(i + \", \" + Long.toBinaryString(i) + \", \" + Long.toString(i, 3));\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t}\n}\n"}
{"id": 57899, "name": "Find palindromic numbers in both binary and ternary bases", "source": "Translate Ruby to Java: pal23 = Enumerator.new do |y|\n  y << 0\n  y << 1\n  for i in 1 .. 1.0/0.0                 \n    n3 = i.to_s(3)\n    n = (n3 + \"1\" + n3.reverse).to_i(3)\n    n2 = n.to_s(2)\n    y << n  if n2.size.odd? and n2 == n2.reverse\n  end\nend\n\nputs \"         decimal          ternary                          binary\"\n6.times do |i|\n  n = pal23.next\n  puts \"%2d: %12d %s %s\" % [i, n, n.to_s(3).center(25), n.to_s(2).center(39)]\nend\n", "target": "public class Pali23 {\n\tpublic static boolean isPali(String x){\n\t\treturn x.equals(new StringBuilder(x).reverse().toString());\n\t}\n\t\n\tpublic static void main(String[] args){\n\t\t\n\t\tfor(long i = 0, count = 0; count < 6;i++){\n\t\t\tif((i & 1) == 0 && (i != 0)) continue; \n\t\t\t\n\t\t\t\n\t\t\tif(isPali(Long.toBinaryString(i)) && isPali(Long.toString(i, 3))){\n\t\t\t\tSystem.out.println(i + \", \" + Long.toBinaryString(i) + \", \" + Long.toString(i, 3));\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t}\n}\n"}
{"id": 57900, "name": "Find palindromic numbers in both binary and ternary bases", "source": "Translate Ruby to Python: pal23 = Enumerator.new do |y|\n  y << 0\n  y << 1\n  for i in 1 .. 1.0/0.0                 \n    n3 = i.to_s(3)\n    n = (n3 + \"1\" + n3.reverse).to_i(3)\n    n2 = n.to_s(2)\n    y << n  if n2.size.odd? and n2 == n2.reverse\n  end\nend\n\nputs \"         decimal          ternary                          binary\"\n6.times do |i|\n  n = pal23.next\n  puts \"%2d: %12d %s %s\" % [i, n, n.to_s(3).center(25), n.to_s(2).center(39)]\nend\n", "target": "from itertools import islice\n\ndigits = \"0123456789abcdefghijklmnopqrstuvwxyz\"\n\ndef baseN(num,b):\n  if num == 0: return \"0\"\n  result = \"\"\n  while num != 0:\n    num, d = divmod(num, b)\n    result += digits[d]\n  return result[::-1] \n\ndef pal2(num):\n    if num == 0 or num == 1: return True\n    based = bin(num)[2:]\n    return based == based[::-1]\n\ndef pal_23():\n    yield 0\n    yield 1\n    n = 1\n    while True:\n        n += 1\n        b = baseN(n, 3)\n        revb = b[::-1]\n        \n        for trial in ('{0}{1}'.format(b, revb), '{0}0{1}'.format(b, revb),\n                      '{0}1{1}'.format(b, revb), '{0}2{1}'.format(b, revb)):\n            t = int(trial, 3)\n            if pal2(t):\n                yield t\n\nfor pal23 in islice(pal_23(), 6):\n    print(pal23, baseN(pal23, 3), baseN(pal23, 2))\n"}
{"id": 57901, "name": "Find palindromic numbers in both binary and ternary bases", "source": "Translate Ruby to Python: pal23 = Enumerator.new do |y|\n  y << 0\n  y << 1\n  for i in 1 .. 1.0/0.0                 \n    n3 = i.to_s(3)\n    n = (n3 + \"1\" + n3.reverse).to_i(3)\n    n2 = n.to_s(2)\n    y << n  if n2.size.odd? and n2 == n2.reverse\n  end\nend\n\nputs \"         decimal          ternary                          binary\"\n6.times do |i|\n  n = pal23.next\n  puts \"%2d: %12d %s %s\" % [i, n, n.to_s(3).center(25), n.to_s(2).center(39)]\nend\n", "target": "from itertools import islice\n\ndigits = \"0123456789abcdefghijklmnopqrstuvwxyz\"\n\ndef baseN(num,b):\n  if num == 0: return \"0\"\n  result = \"\"\n  while num != 0:\n    num, d = divmod(num, b)\n    result += digits[d]\n  return result[::-1] \n\ndef pal2(num):\n    if num == 0 or num == 1: return True\n    based = bin(num)[2:]\n    return based == based[::-1]\n\ndef pal_23():\n    yield 0\n    yield 1\n    n = 1\n    while True:\n        n += 1\n        b = baseN(n, 3)\n        revb = b[::-1]\n        \n        for trial in ('{0}{1}'.format(b, revb), '{0}0{1}'.format(b, revb),\n                      '{0}1{1}'.format(b, revb), '{0}2{1}'.format(b, revb)):\n            t = int(trial, 3)\n            if pal2(t):\n                yield t\n\nfor pal23 in islice(pal_23(), 6):\n    print(pal23, baseN(pal23, 3), baseN(pal23, 2))\n"}
{"id": 58039, "name": "Secure temporary file", "source": "Translate Ruby to C#: require 'tempfile'\n\nf = Tempfile.new('foo')\nf.path  \nf.close\nf.unlink \n", "target": "using System;\nusing System.IO;\n\nConsole.WriteLine(Path.GetTempFileName());\n"}
{"id": 58040, "name": "Secure temporary file", "source": "Translate Ruby to Java: require 'tempfile'\n\nf = Tempfile.new('foo')\nf.path  \nf.close\nf.unlink \n", "target": "import java.io.File;\nimport java.io.IOException;\n\npublic class CreateTempFile {\n    public static void main(String[] args)  {\n        try {\n            \n            File temp = File.createTempFile(\"temp-file-name\", \".tmp\");\n            System.out.println(\"Temp file\u00a0: \" + temp.getAbsolutePath());\n        }\n        catch(IOException e) {\n            e.printStackTrace();\n    \t}\n    }\n}\n"}
{"id": 58041, "name": "Secure temporary file", "source": "Translate Ruby to Python: require 'tempfile'\n\nf = Tempfile.new('foo')\nf.path  \nf.close\nf.unlink \n", "target": ">>> import tempfile\n>>> invisible = tempfile.TemporaryFile()\n>>> invisible.name\n'<fdopen>'\n>>> visible = tempfile.NamedTemporaryFile()\n>>> visible.name\n'/tmp/tmpZNfc_s'\n>>> visible.close()\n>>> invisible.close()\n"}
{"id": 58334, "name": "Hofstadter Figure-Figure sequences", "source": "Translate Ruby to C#: $r = [nil, 1]\n$s = [nil, 2]\n\ndef buildSeq(n)\n  current = [ $r[-1], $s[-1] ].max\n  while $r.length <= n || $s.length <= n\n    idx = [ $r.length, $s.length ].min - 1\n    current += 1\n    if current == $r[idx] + $s[idx]\n      $r << current\n    else\n      $s << current\n    end\n  end\nend\n\ndef ffr(n)\n  buildSeq(n)\n  $r[n]\nend\n\ndef ffs(n)\n  buildSeq(n)\n  $s[n]\nend\n\nrequire 'set'\nrequire 'test/unit'\n\nclass TestHofstadterFigureFigure < Test::Unit::TestCase\n  def test_first_ten_R_values\n    r10 = 1.upto(10).map {|n| ffr(n)}\n    assert_equal(r10, [1, 3, 7, 12, 18, 26, 35, 45, 56, 69])\n  end\n\n  def test_40_R_and_960_S_are_1_to_1000\n    rs_values = Set.new\n    rs_values.merge( 1.upto(40).collect  {|n| ffr(n)} )\n    rs_values.merge( 1.upto(960).collect {|n| ffs(n)} )\n    assert_equal(rs_values, Set.new( 1..1000 ))\n  end\nend\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\nnamespace HofstadterFigureFigure\n{\n\tclass HofstadterFigureFigure\n\t{\n\t\treadonly List<int> _r = new List<int>() {1};\n\t\treadonly List<int> _s = new List<int>();\n\n\t\tpublic IEnumerable<int> R()\n\t\t{\n\t\t\tint iR = 0;\n\t\t\twhile (true)\n\t\t\t{\n\t\t\t\tif (iR >= _r.Count)\n\t\t\t\t{\n\t\t\t\t\tAdvance();\n\t\t\t\t}\n\t\t\t\tyield return _r[iR++];\n\t\t\t}\n\t\t}\n\n\t\tpublic IEnumerable<int> S()\n\t\t{\n\t\t\tint iS = 0;\n\t\t\twhile (true)\n\t\t\t{\n\t\t\t\tif (iS >= _s.Count)\n\t\t\t\t{\n\t\t\t\t\tAdvance();\n\t\t\t\t}\n\t\t\t\tyield return _s[iS++];\n\t\t\t}\n\t\t}\n\n\t\tprivate void Advance()\n\t\t{\n\t\t\tint rCount = _r.Count;\n\t\t\tint oldR = _r[rCount - 1];\n\t\t\tint sVal;\n\t\t\t\n\t\t\t\n\t\t\tswitch (rCount)\n\t\t\t{\n\t\t\t\tcase 1:\n\t\t\t\t\tsVal = 2;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 2:\n\t\t\t\t\tsVal = 4;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tsVal = _s[rCount - 1];\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\t_r.Add(_r[rCount - 1] + sVal);\n\t\t\tint newR = _r[rCount];\n\t\t\tfor (int iS = oldR + 1; iS < newR; iS++)\n\t\t\t{\n\t\t\t\t_s.Add(iS);\n\t\t\t}\n\t\t}\n\t}\n\n\tclass Program\n\t{\n\t\tstatic void Main()\n\t\t{\n\t\t\tvar hff = new HofstadterFigureFigure();\n\t\t\tvar rs = hff.R();\n\t\t\tvar arr = rs.Take(40).ToList();\n\n\t\t\tforeach(var v in arr.Take(10))\n\t\t\t{\n\t\t\t\tConsole.WriteLine(\"{0}\", v);\n\t\t\t}\n\n\t\t\tvar hs = new HashSet<int>(arr);\n\t\t\ths.UnionWith(hff.S().Take(960));\n\t\t\tConsole.WriteLine(hs.Count == 1000 ? \"Verified\" : \"Oops!  Something's wrong!\");\n\t\t}\n\t}\n}\n"}
{"id": 58335, "name": "Hofstadter Figure-Figure sequences", "source": "Translate Ruby to C#: $r = [nil, 1]\n$s = [nil, 2]\n\ndef buildSeq(n)\n  current = [ $r[-1], $s[-1] ].max\n  while $r.length <= n || $s.length <= n\n    idx = [ $r.length, $s.length ].min - 1\n    current += 1\n    if current == $r[idx] + $s[idx]\n      $r << current\n    else\n      $s << current\n    end\n  end\nend\n\ndef ffr(n)\n  buildSeq(n)\n  $r[n]\nend\n\ndef ffs(n)\n  buildSeq(n)\n  $s[n]\nend\n\nrequire 'set'\nrequire 'test/unit'\n\nclass TestHofstadterFigureFigure < Test::Unit::TestCase\n  def test_first_ten_R_values\n    r10 = 1.upto(10).map {|n| ffr(n)}\n    assert_equal(r10, [1, 3, 7, 12, 18, 26, 35, 45, 56, 69])\n  end\n\n  def test_40_R_and_960_S_are_1_to_1000\n    rs_values = Set.new\n    rs_values.merge( 1.upto(40).collect  {|n| ffr(n)} )\n    rs_values.merge( 1.upto(960).collect {|n| ffs(n)} )\n    assert_equal(rs_values, Set.new( 1..1000 ))\n  end\nend\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\nnamespace HofstadterFigureFigure\n{\n\tclass HofstadterFigureFigure\n\t{\n\t\treadonly List<int> _r = new List<int>() {1};\n\t\treadonly List<int> _s = new List<int>();\n\n\t\tpublic IEnumerable<int> R()\n\t\t{\n\t\t\tint iR = 0;\n\t\t\twhile (true)\n\t\t\t{\n\t\t\t\tif (iR >= _r.Count)\n\t\t\t\t{\n\t\t\t\t\tAdvance();\n\t\t\t\t}\n\t\t\t\tyield return _r[iR++];\n\t\t\t}\n\t\t}\n\n\t\tpublic IEnumerable<int> S()\n\t\t{\n\t\t\tint iS = 0;\n\t\t\twhile (true)\n\t\t\t{\n\t\t\t\tif (iS >= _s.Count)\n\t\t\t\t{\n\t\t\t\t\tAdvance();\n\t\t\t\t}\n\t\t\t\tyield return _s[iS++];\n\t\t\t}\n\t\t}\n\n\t\tprivate void Advance()\n\t\t{\n\t\t\tint rCount = _r.Count;\n\t\t\tint oldR = _r[rCount - 1];\n\t\t\tint sVal;\n\t\t\t\n\t\t\t\n\t\t\tswitch (rCount)\n\t\t\t{\n\t\t\t\tcase 1:\n\t\t\t\t\tsVal = 2;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 2:\n\t\t\t\t\tsVal = 4;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tsVal = _s[rCount - 1];\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\t_r.Add(_r[rCount - 1] + sVal);\n\t\t\tint newR = _r[rCount];\n\t\t\tfor (int iS = oldR + 1; iS < newR; iS++)\n\t\t\t{\n\t\t\t\t_s.Add(iS);\n\t\t\t}\n\t\t}\n\t}\n\n\tclass Program\n\t{\n\t\tstatic void Main()\n\t\t{\n\t\t\tvar hff = new HofstadterFigureFigure();\n\t\t\tvar rs = hff.R();\n\t\t\tvar arr = rs.Take(40).ToList();\n\n\t\t\tforeach(var v in arr.Take(10))\n\t\t\t{\n\t\t\t\tConsole.WriteLine(\"{0}\", v);\n\t\t\t}\n\n\t\t\tvar hs = new HashSet<int>(arr);\n\t\t\ths.UnionWith(hff.S().Take(960));\n\t\t\tConsole.WriteLine(hs.Count == 1000 ? \"Verified\" : \"Oops!  Something's wrong!\");\n\t\t}\n\t}\n}\n"}
{"id": 58338, "name": "Hofstadter Figure-Figure sequences", "source": "Translate Ruby to Java: $r = [nil, 1]\n$s = [nil, 2]\n\ndef buildSeq(n)\n  current = [ $r[-1], $s[-1] ].max\n  while $r.length <= n || $s.length <= n\n    idx = [ $r.length, $s.length ].min - 1\n    current += 1\n    if current == $r[idx] + $s[idx]\n      $r << current\n    else\n      $s << current\n    end\n  end\nend\n\ndef ffr(n)\n  buildSeq(n)\n  $r[n]\nend\n\ndef ffs(n)\n  buildSeq(n)\n  $s[n]\nend\n\nrequire 'set'\nrequire 'test/unit'\n\nclass TestHofstadterFigureFigure < Test::Unit::TestCase\n  def test_first_ten_R_values\n    r10 = 1.upto(10).map {|n| ffr(n)}\n    assert_equal(r10, [1, 3, 7, 12, 18, 26, 35, 45, 56, 69])\n  end\n\n  def test_40_R_and_960_S_are_1_to_1000\n    rs_values = Set.new\n    rs_values.merge( 1.upto(40).collect  {|n| ffr(n)} )\n    rs_values.merge( 1.upto(960).collect {|n| ffs(n)} )\n    assert_equal(rs_values, Set.new( 1..1000 ))\n  end\nend\n", "target": "import java.util.*;\n\nclass Hofstadter\n{\n  private static List<Integer> getSequence(int rlistSize, int slistSize)\n  {\n    List<Integer> rlist = new ArrayList<Integer>();\n    List<Integer> slist = new ArrayList<Integer>();\n    Collections.addAll(rlist, 1, 3, 7);\n    Collections.addAll(slist, 2, 4, 5, 6);\n    List<Integer> list = (rlistSize > 0) ? rlist : slist;\n    int targetSize = (rlistSize > 0) ? rlistSize : slistSize;\n    while (list.size() > targetSize)\n      list.remove(list.size() - 1);\n    while (list.size() < targetSize)\n    {\n      int lastIndex = rlist.size() - 1;\n      int lastr = rlist.get(lastIndex).intValue();\n      int r = lastr + slist.get(lastIndex).intValue();\n      rlist.add(Integer.valueOf(r));\n      for (int s = lastr + 1; (s < r) && (list.size() < targetSize); s++)\n        slist.add(Integer.valueOf(s));\n    }\n    return list;\n  }\n  \n  public static int ffr(int n)\n  {  return getSequence(n, 0).get(n - 1).intValue();  }\n  \n  public static int ffs(int n)\n  {  return getSequence(0, n).get(n - 1).intValue();  }\n  \n  public static void main(String[] args)\n  {\n    System.out.print(\"R():\");\n    for (int n = 1; n <= 10; n++)\n      System.out.print(\" \" + ffr(n));\n    System.out.println();\n    \n    Set<Integer> first40R = new HashSet<Integer>();\n    for (int n = 1; n <= 40; n++)\n      first40R.add(Integer.valueOf(ffr(n)));\n      \n    Set<Integer> first960S = new HashSet<Integer>();\n    for (int n = 1; n <= 960; n++)\n      first960S.add(Integer.valueOf(ffs(n)));\n    \n    for (int i = 1; i <= 1000; i++)\n    {\n      Integer n = Integer.valueOf(i);\n      if (first40R.contains(n) == first960S.contains(n))\n        System.out.println(\"Integer \" + i + \" either in both or neither set\");\n    }\n    System.out.println(\"Done\");\n  }\n}\n"}
{"id": 58339, "name": "Hofstadter Figure-Figure sequences", "source": "Translate Ruby to Python: $r = [nil, 1]\n$s = [nil, 2]\n\ndef buildSeq(n)\n  current = [ $r[-1], $s[-1] ].max\n  while $r.length <= n || $s.length <= n\n    idx = [ $r.length, $s.length ].min - 1\n    current += 1\n    if current == $r[idx] + $s[idx]\n      $r << current\n    else\n      $s << current\n    end\n  end\nend\n\ndef ffr(n)\n  buildSeq(n)\n  $r[n]\nend\n\ndef ffs(n)\n  buildSeq(n)\n  $s[n]\nend\n\nrequire 'set'\nrequire 'test/unit'\n\nclass TestHofstadterFigureFigure < Test::Unit::TestCase\n  def test_first_ten_R_values\n    r10 = 1.upto(10).map {|n| ffr(n)}\n    assert_equal(r10, [1, 3, 7, 12, 18, 26, 35, 45, 56, 69])\n  end\n\n  def test_40_R_and_960_S_are_1_to_1000\n    rs_values = Set.new\n    rs_values.merge( 1.upto(40).collect  {|n| ffr(n)} )\n    rs_values.merge( 1.upto(960).collect {|n| ffs(n)} )\n    assert_equal(rs_values, Set.new( 1..1000 ))\n  end\nend\n", "target": "def ffr(n):\n    if n < 1 or type(n) != int: raise ValueError(\"n must be an int >= 1\")\n    try:\n        return ffr.r[n]\n    except IndexError:\n        r, s = ffr.r, ffs.s\n        ffr_n_1 = ffr(n-1)\n        lastr = r[-1]\n        \n        s += list(range(s[-1] + 1, lastr))\n        if s[-1] < lastr: s += [lastr + 1]\n        \n        len_s = len(s)\n        ffs_n_1 = s[n-1] if len_s > n else (n - len_s) + s[-1]\n        ans = ffr_n_1 + ffs_n_1\n        r.append(ans)\n        return ans\nffr.r = [None, 1]\n\ndef ffs(n):\n    if n < 1 or type(n) != int: raise ValueError(\"n must be an int >= 1\")\n    try:\n        return ffs.s[n]\n    except IndexError:\n        r, s = ffr.r, ffs.s\n        for i in range(len(r), n+2):\n            ffr(i)\n            if len(s) > n:\n                return s[n]\n        raise Exception(\"Whoops!\")\nffs.s = [None, 2]\n\nif __name__ == '__main__':\n    first10 = [ffr(i) for i in range(1,11)]\n    assert first10 == [1, 3, 7, 12, 18, 26, 35, 45, 56, 69], \"ffr() value error(s)\"\n    print(\"ffr(n) for n = [1..10] is\", first10)\n    \n    bin = [None] + [0]*1000\n    for i in range(40, 0, -1):\n        bin[ffr(i)] += 1\n    for i in range(960, 0, -1):\n        bin[ffs(i)] += 1\n    if all(b == 1 for b in bin[1:1000]):\n        print(\"All Integers 1..1000 found OK\")\n    else:\n        print(\"All Integers 1..1000 NOT found only once: ERROR\")\n"}
{"id": 58340, "name": "Hofstadter Figure-Figure sequences", "source": "Translate Ruby to Python: $r = [nil, 1]\n$s = [nil, 2]\n\ndef buildSeq(n)\n  current = [ $r[-1], $s[-1] ].max\n  while $r.length <= n || $s.length <= n\n    idx = [ $r.length, $s.length ].min - 1\n    current += 1\n    if current == $r[idx] + $s[idx]\n      $r << current\n    else\n      $s << current\n    end\n  end\nend\n\ndef ffr(n)\n  buildSeq(n)\n  $r[n]\nend\n\ndef ffs(n)\n  buildSeq(n)\n  $s[n]\nend\n\nrequire 'set'\nrequire 'test/unit'\n\nclass TestHofstadterFigureFigure < Test::Unit::TestCase\n  def test_first_ten_R_values\n    r10 = 1.upto(10).map {|n| ffr(n)}\n    assert_equal(r10, [1, 3, 7, 12, 18, 26, 35, 45, 56, 69])\n  end\n\n  def test_40_R_and_960_S_are_1_to_1000\n    rs_values = Set.new\n    rs_values.merge( 1.upto(40).collect  {|n| ffr(n)} )\n    rs_values.merge( 1.upto(960).collect {|n| ffs(n)} )\n    assert_equal(rs_values, Set.new( 1..1000 ))\n  end\nend\n", "target": "def ffr(n):\n    if n < 1 or type(n) != int: raise ValueError(\"n must be an int >= 1\")\n    try:\n        return ffr.r[n]\n    except IndexError:\n        r, s = ffr.r, ffs.s\n        ffr_n_1 = ffr(n-1)\n        lastr = r[-1]\n        \n        s += list(range(s[-1] + 1, lastr))\n        if s[-1] < lastr: s += [lastr + 1]\n        \n        len_s = len(s)\n        ffs_n_1 = s[n-1] if len_s > n else (n - len_s) + s[-1]\n        ans = ffr_n_1 + ffs_n_1\n        r.append(ans)\n        return ans\nffr.r = [None, 1]\n\ndef ffs(n):\n    if n < 1 or type(n) != int: raise ValueError(\"n must be an int >= 1\")\n    try:\n        return ffs.s[n]\n    except IndexError:\n        r, s = ffr.r, ffs.s\n        for i in range(len(r), n+2):\n            ffr(i)\n            if len(s) > n:\n                return s[n]\n        raise Exception(\"Whoops!\")\nffs.s = [None, 2]\n\nif __name__ == '__main__':\n    first10 = [ffr(i) for i in range(1,11)]\n    assert first10 == [1, 3, 7, 12, 18, 26, 35, 45, 56, 69], \"ffr() value error(s)\"\n    print(\"ffr(n) for n = [1..10] is\", first10)\n    \n    bin = [None] + [0]*1000\n    for i in range(40, 0, -1):\n        bin[ffr(i)] += 1\n    for i in range(960, 0, -1):\n        bin[ffs(i)] += 1\n    if all(b == 1 for b in bin[1:1000]):\n        print(\"All Integers 1..1000 found OK\")\n    else:\n        print(\"All Integers 1..1000 NOT found only once: ERROR\")\n"}
{"id": 58504, "name": "Triplet of three numbers", "source": "Translate Ruby to C#: require 'prime'\n\nprimes = Prime.each(6000)\np primes.each_cons(3).filter_map{|p1, p2, p3| p1 + 1 if p1+4 == p2 && p1+6 == p3}\n", "target": "using System; using System.Collections.Generic; using System.Linq;\nusing T3 = System.Tuple<int, int, int>; using static System.Console;\nclass Program { static void Main() {\n   WriteLine(\" \\\"N\\\":  Prime Triplet    Adjacent (to previous)\\n\" +\n             \" ---- ----------------- -----------------------\");\n   foreach(var lmt in new double[]{6e3, 1e5, 1e6, 1e7, 1e8}) {\n    var pr = PG.Primes((int)lmt); int l = 0, c = 0; bool a;\n    foreach (var t in pr) { c += (a = l == t.Item1) ? 1 : 0;\n      if (lmt < 1e5) WriteLine(\"{0,4}: {1,-18} {2}\",\n        t.Item1 + 1, t, a ? \" *\" : \"\"); l = t.Item3; }\n    Console.WriteLine (\"Up to {0:n0} there are {1:n0} prime triples, \" +\n      \"of which {2:n0} were found to be adjacent.\", lmt, pr.Count(), c); } } }\n\nclass PG { static bool[] f; static bool isPrT(int x, int y, int z) {\n  if (x < 7) return false; return !f[x] && !f[y] && !f[z]; }\n  public static IEnumerable<T3> Primes(int l) { f = new bool[l += 6];\n  int j, lj, llj, lllj; j = lj = llj = lllj = 3;\n  for (int d = 8, s = 9; s < l; lllj = llj, llj = lj, lj = j, j += 2, s += d += 8)\n    if (!f[j]) { if (isPrT(lllj, lj, j)) yield return new T3(lllj, lj, j);\n      for (int k = s, i = j << 1; k < l; k += i) f[k] = true; }\n  for (; j < l; lllj = llj, llj = lj, lj = j, j += 2)\n   if (isPrT(lllj, lj, j)) yield return new T3(lllj, lj, j); } }\n"}
{"id": 58505, "name": "Triplet of three numbers", "source": "Translate Ruby to C#: require 'prime'\n\nprimes = Prime.each(6000)\np primes.each_cons(3).filter_map{|p1, p2, p3| p1 + 1 if p1+4 == p2 && p1+6 == p3}\n", "target": "using System; using System.Collections.Generic; using System.Linq;\nusing T3 = System.Tuple<int, int, int>; using static System.Console;\nclass Program { static void Main() {\n   WriteLine(\" \\\"N\\\":  Prime Triplet    Adjacent (to previous)\\n\" +\n             \" ---- ----------------- -----------------------\");\n   foreach(var lmt in new double[]{6e3, 1e5, 1e6, 1e7, 1e8}) {\n    var pr = PG.Primes((int)lmt); int l = 0, c = 0; bool a;\n    foreach (var t in pr) { c += (a = l == t.Item1) ? 1 : 0;\n      if (lmt < 1e5) WriteLine(\"{0,4}: {1,-18} {2}\",\n        t.Item1 + 1, t, a ? \" *\" : \"\"); l = t.Item3; }\n    Console.WriteLine (\"Up to {0:n0} there are {1:n0} prime triples, \" +\n      \"of which {2:n0} were found to be adjacent.\", lmt, pr.Count(), c); } } }\n\nclass PG { static bool[] f; static bool isPrT(int x, int y, int z) {\n  if (x < 7) return false; return !f[x] && !f[y] && !f[z]; }\n  public static IEnumerable<T3> Primes(int l) { f = new bool[l += 6];\n  int j, lj, llj, lllj; j = lj = llj = lllj = 3;\n  for (int d = 8, s = 9; s < l; lllj = llj, llj = lj, lj = j, j += 2, s += d += 8)\n    if (!f[j]) { if (isPrT(lllj, lj, j)) yield return new T3(lllj, lj, j);\n      for (int k = s, i = j << 1; k < l; k += i) f[k] = true; }\n  for (; j < l; lllj = llj, llj = lj, lj = j, j += 2)\n   if (isPrT(lllj, lj, j)) yield return new T3(lllj, lj, j); } }\n"}
{"id": 58508, "name": "Triplet of three numbers", "source": "Translate Ruby to Python: require 'prime'\n\nprimes = Prime.each(6000)\np primes.each_cons(3).filter_map{|p1, p2, p3| p1 + 1 if p1+4 == p2 && p1+6 == p3}\n", "target": "\n\nN = 6000\np = [None] * 6000  \n\nfor i in range(2, round(pow(N,0.5))):\n    if not p[i]:\n        for j in range(i*2, N, i):\n            p[j] = 1\n\n\nfor i in range(3, N):\n    if (p[i-1] or p[i+3] or p[i+5]):\n        continue\n    else:\n        print(i, ': ', i-1,  ' ', i+3,  ' ', i+5)\n"}
{"id": 58509, "name": "Triplet of three numbers", "source": "Translate Ruby to Python: require 'prime'\n\nprimes = Prime.each(6000)\np primes.each_cons(3).filter_map{|p1, p2, p3| p1 + 1 if p1+4 == p2 && p1+6 == p3}\n", "target": "\n\nN = 6000\np = [None] * 6000  \n\nfor i in range(2, round(pow(N,0.5))):\n    if not p[i]:\n        for j in range(i*2, N, i):\n            p[j] = 1\n\n\nfor i in range(3, N):\n    if (p[i-1] or p[i+3] or p[i+5]):\n        continue\n    else:\n        print(i, ': ', i-1,  ' ', i+3,  ' ', i+5)\n"}
{"id": 58890, "name": "Box the compass", "source": "Translate Ruby to C#: Headings = %w(north east south west north).each_cons(2).flat_map do |a, b|\n  [a,\n  \"\n  \"\n  \"\n  \"\n  \"\n  \"\n  \"\nend\nHeadings.prepend nil\n\ndef heading(degrees)\n  i = degrees.quo(360).*(32).round.%(32).+(1)\n  [i, Headings[i]]\nend\n\n\nangles = (0..32).map { |i| i * 11.25 + [0, 5.62, -5.62][i % 3] }\n\nangles.each do |degrees|\n  index, name = heading degrees\n  printf \"%2d %20s %6.2f\\n\", index, name.center(20), degrees\nend\n", "target": "using System;\nusing System.Collections.Generic;\n\nnamespace BoxTheCompass\n{\n    class Compass\n    {\n        string[] cp = new string[] {\"North\", \"North by east\", \"North-northeast\", \"Northeast by north\", \"Northeast\",\"Northeast by east\", \n\t    \"East-northeast\", \"East by north\", \"East\", \"East by south\", \"East-southeast\", \"Southeast by east\", \"Southeast\", \n            \"Southeast by south\", \"South-southeast\", \"South by east\", \"South\", \"South by west\", \"South-southwest\", \"Southwest by south\", \n            \"Southwest\", \"Southwest by west\", \"West-southwest\", \"West by south\", \"West\", \"West by north\", \"West-northwest\", \n            \"Northwest by west\", \"Northwest\", \"Northwest by north\", \"North-northwest\", \"North by west\", \"North\"};\n\n        public void compassHeading(float a)\n        {\n            int h = Convert.ToInt32(Math.Floor(a / 11.25f + .5f)) % 32;\n            Console.WriteLine( \"{0,2}: {1,-22}\u00a0: {2,6:N}\",h + 1, cp[h], a );\n        }\n    };\n    class Program\n    {\n        static void Main(string[] args)\n       {\n            Compass c = new Compass();\n            float[] degs = new float[] {0.0f, 16.87f, 16.88f, 33.75f, 50.62f, 50.63f, 67.5f, 84.37f, 84.38f, 101.25f, \n                118.12f, 118.13f, 135.0f, 151.87f, 151.88f, 168.75f, 185.62f, 185.63f, 202.5f, 219.37f, 219.38f, 236.25f, \n                253.12f, 253.13f, 270.0f, 286.87f, 286.88f, 303.75f, 320.62f, 320.63f, 337.5f, 354.37f, 354.38f};\n\n            foreach (float d in degs)\n                c.compassHeading(d);\n\n            Console.WriteLine(\"\\nPress any key to continue...\");\n            Console.ReadKey();\n        }\n    }\n}\n"}
{"id": 58891, "name": "Box the compass", "source": "Translate Ruby to C#: Headings = %w(north east south west north).each_cons(2).flat_map do |a, b|\n  [a,\n  \"\n  \"\n  \"\n  \"\n  \"\n  \"\n  \"\nend\nHeadings.prepend nil\n\ndef heading(degrees)\n  i = degrees.quo(360).*(32).round.%(32).+(1)\n  [i, Headings[i]]\nend\n\n\nangles = (0..32).map { |i| i * 11.25 + [0, 5.62, -5.62][i % 3] }\n\nangles.each do |degrees|\n  index, name = heading degrees\n  printf \"%2d %20s %6.2f\\n\", index, name.center(20), degrees\nend\n", "target": "using System;\nusing System.Collections.Generic;\n\nnamespace BoxTheCompass\n{\n    class Compass\n    {\n        string[] cp = new string[] {\"North\", \"North by east\", \"North-northeast\", \"Northeast by north\", \"Northeast\",\"Northeast by east\", \n\t    \"East-northeast\", \"East by north\", \"East\", \"East by south\", \"East-southeast\", \"Southeast by east\", \"Southeast\", \n            \"Southeast by south\", \"South-southeast\", \"South by east\", \"South\", \"South by west\", \"South-southwest\", \"Southwest by south\", \n            \"Southwest\", \"Southwest by west\", \"West-southwest\", \"West by south\", \"West\", \"West by north\", \"West-northwest\", \n            \"Northwest by west\", \"Northwest\", \"Northwest by north\", \"North-northwest\", \"North by west\", \"North\"};\n\n        public void compassHeading(float a)\n        {\n            int h = Convert.ToInt32(Math.Floor(a / 11.25f + .5f)) % 32;\n            Console.WriteLine( \"{0,2}: {1,-22}\u00a0: {2,6:N}\",h + 1, cp[h], a );\n        }\n    };\n    class Program\n    {\n        static void Main(string[] args)\n       {\n            Compass c = new Compass();\n            float[] degs = new float[] {0.0f, 16.87f, 16.88f, 33.75f, 50.62f, 50.63f, 67.5f, 84.37f, 84.38f, 101.25f, \n                118.12f, 118.13f, 135.0f, 151.87f, 151.88f, 168.75f, 185.62f, 185.63f, 202.5f, 219.37f, 219.38f, 236.25f, \n                253.12f, 253.13f, 270.0f, 286.87f, 286.88f, 303.75f, 320.62f, 320.63f, 337.5f, 354.37f, 354.38f};\n\n            foreach (float d in degs)\n                c.compassHeading(d);\n\n            Console.WriteLine(\"\\nPress any key to continue...\");\n            Console.ReadKey();\n        }\n    }\n}\n"}
{"id": 58894, "name": "Box the compass", "source": "Translate Ruby to Java: Headings = %w(north east south west north).each_cons(2).flat_map do |a, b|\n  [a,\n  \"\n  \"\n  \"\n  \"\n  \"\n  \"\n  \"\nend\nHeadings.prepend nil\n\ndef heading(degrees)\n  i = degrees.quo(360).*(32).round.%(32).+(1)\n  [i, Headings[i]]\nend\n\n\nangles = (0..32).map { |i| i * 11.25 + [0, 5.62, -5.62][i % 3] }\n\nangles.each do |degrees|\n  index, name = heading degrees\n  printf \"%2d %20s %6.2f\\n\", index, name.center(20), degrees\nend\n", "target": "public class BoxingTheCompass{\n    private static String[] points = new String[32];\n \n    public static void main(String[] args){\n        buildPoints();\n \n        double heading = 0;\n \n        for(int i = 0; i<= 32;i++){\n            heading = i * 11.25;\n            switch(i % 3){\n                case 1:\n                    heading += 5.62;\n                    break;\n                case 2:\n                    heading -= 5.62;\n                    break;\n                default:\n            }\n \n            System.out.printf(\"%s\\t%18s\\t%s\u00b0\\n\",(i % 32) + 1, initialUpper(getPoint(heading)), heading);\n        }\n    }\n \n    private static void buildPoints(){\n        String[] cardinal = {\"north\", \"east\", \"south\", \"west\"};\n        String[] pointDesc = {\"1\", \"1 by 2\", \"1-C\", \"C by 1\", \"C\", \"C by 2\", \"2-C\", \"2 by 1\"};\n \n        String str1, str2, strC;\n \n        for(int i = 0;i <= 3;i++){\n            str1 = cardinal[i];\n            str2 = cardinal[(i + 1) % 4];\n            strC = (str1.equals(\"north\") || str1.equals(\"south\")) ? (str1 + str2): (str2 + str1);\n            for(int j = 0;j <= 7;j++){\n                points[i * 8 + j] = pointDesc[j].replace(\"1\", str1).replace(\"2\", str2).replace(\"C\", strC);\n            }\n        }\n    }\n \n    private static String initialUpper(String s){\n        return s.substring(0, 1).toUpperCase() + s.substring(1);\n    }\n \n    private static String getPoint(double degrees){\n        double testD = (degrees / 11.25) + 0.5;\n        return points[(int)Math.floor(testD % 32)];\n    }\n}\n"}
{"id": 58895, "name": "Box the compass", "source": "Translate Ruby to Python: Headings = %w(north east south west north).each_cons(2).flat_map do |a, b|\n  [a,\n  \"\n  \"\n  \"\n  \"\n  \"\n  \"\n  \"\nend\nHeadings.prepend nil\n\ndef heading(degrees)\n  i = degrees.quo(360).*(32).round.%(32).+(1)\n  [i, Headings[i]]\nend\n\n\nangles = (0..32).map { |i| i * 11.25 + [0, 5.62, -5.62][i % 3] }\n\nangles.each do |degrees|\n  index, name = heading degrees\n  printf \"%2d %20s %6.2f\\n\", index, name.center(20), degrees\nend\n", "target": "majors   = 'north east south west'.split()\nmajors   *= 2 \nquarter1 = 'N,N by E,N-NE,NE by N,NE,NE by E,E-NE,E by N'.split(',')\nquarter2 = [p.replace('NE','EN') for p in quarter1]\n\ndef degrees2compasspoint(d):\n    d = (d % 360) + 360/64\n    majorindex, minor = divmod(d, 90.)\n    majorindex = int(majorindex)\n    minorindex  = int( (minor*4) // 45 )\n    p1, p2 = majors[majorindex: majorindex+2]\n    if p1 in {'north', 'south'}:\n        q = quarter1\n    else:\n        q = quarter2\n    return q[minorindex].replace('N', p1).replace('E', p2).capitalize()\n\nif __name__ == '__main__':\n    for i in range(33):\n        d = i * 11.25\n        m = i % 3\n        if   m == 1: d += 5.62\n        elif m == 2: d -= 5.62\n        n = i % 32 + 1\n        print( '%2i %-18s %7.2f\u00b0' % (n, degrees2compasspoint(d), d) )\n"}
{"id": 58896, "name": "Box the compass", "source": "Translate Ruby to Python: Headings = %w(north east south west north).each_cons(2).flat_map do |a, b|\n  [a,\n  \"\n  \"\n  \"\n  \"\n  \"\n  \"\n  \"\nend\nHeadings.prepend nil\n\ndef heading(degrees)\n  i = degrees.quo(360).*(32).round.%(32).+(1)\n  [i, Headings[i]]\nend\n\n\nangles = (0..32).map { |i| i * 11.25 + [0, 5.62, -5.62][i % 3] }\n\nangles.each do |degrees|\n  index, name = heading degrees\n  printf \"%2d %20s %6.2f\\n\", index, name.center(20), degrees\nend\n", "target": "majors   = 'north east south west'.split()\nmajors   *= 2 \nquarter1 = 'N,N by E,N-NE,NE by N,NE,NE by E,E-NE,E by N'.split(',')\nquarter2 = [p.replace('NE','EN') for p in quarter1]\n\ndef degrees2compasspoint(d):\n    d = (d % 360) + 360/64\n    majorindex, minor = divmod(d, 90.)\n    majorindex = int(majorindex)\n    minorindex  = int( (minor*4) // 45 )\n    p1, p2 = majors[majorindex: majorindex+2]\n    if p1 in {'north', 'south'}:\n        q = quarter1\n    else:\n        q = quarter2\n    return q[minorindex].replace('N', p1).replace('E', p2).capitalize()\n\nif __name__ == '__main__':\n    for i in range(33):\n        d = i * 11.25\n        m = i % 3\n        if   m == 1: d += 5.62\n        elif m == 2: d -= 5.62\n        n = i % 32 + 1\n        print( '%2i %-18s %7.2f\u00b0' % (n, degrees2compasspoint(d), d) )\n"}
{"id": 59281, "name": "URL decoding", "source": "Translate Ruby to C#: require 'cgi'\nputs CGI.unescape(\"http%3A%2F%2Ffoo%20bar%2F\")\n\n", "target": "using System;\n\nnamespace URLEncode\n{\n    internal class Program\n    {\n        private static void Main(string[] args)\n        {\n            Console.WriteLine(Decode(\"http%3A%2F%2Ffoo%20bar%2F\"));\n        }\n\n        private static string Decode(string uri)\n        {\n            return Uri.UnescapeDataString(uri);\n        }\n    }\n}\n"}
{"id": 59282, "name": "URL decoding", "source": "Translate Ruby to C#: require 'cgi'\nputs CGI.unescape(\"http%3A%2F%2Ffoo%20bar%2F\")\n\n", "target": "using System;\n\nnamespace URLEncode\n{\n    internal class Program\n    {\n        private static void Main(string[] args)\n        {\n            Console.WriteLine(Decode(\"http%3A%2F%2Ffoo%20bar%2F\"));\n        }\n\n        private static string Decode(string uri)\n        {\n            return Uri.UnescapeDataString(uri);\n        }\n    }\n}\n"}
{"id": 59285, "name": "URL decoding", "source": "Translate Ruby to Java: require 'cgi'\nputs CGI.unescape(\"http%3A%2F%2Ffoo%20bar%2F\")\n\n", "target": "import java.io.UnsupportedEncodingException;\nimport java.net.URLDecoder;\n\npublic class Main\n{\n    public static void main(String[] args) throws UnsupportedEncodingException\n    {\n        String encoded = \"http%3A%2F%2Ffoo%20bar%2F\";\n        String normal = URLDecoder.decode(encoded, \"utf-8\");\n        System.out.println(normal);\n    }\n}\n"}
{"id": 59286, "name": "URL decoding", "source": "Translate Ruby to Java: require 'cgi'\nputs CGI.unescape(\"http%3A%2F%2Ffoo%20bar%2F\")\n\n", "target": "import java.io.UnsupportedEncodingException;\nimport java.net.URLDecoder;\n\npublic class Main\n{\n    public static void main(String[] args) throws UnsupportedEncodingException\n    {\n        String encoded = \"http%3A%2F%2Ffoo%20bar%2F\";\n        String normal = URLDecoder.decode(encoded, \"utf-8\");\n        System.out.println(normal);\n    }\n}\n"}
{"id": 59287, "name": "URL decoding", "source": "Translate Ruby to Python: require 'cgi'\nputs CGI.unescape(\"http%3A%2F%2Ffoo%20bar%2F\")\n\n", "target": "\nimport urllib\nprint urllib.unquote(\"http%3A%2F%2Ffoo%20bar%2F\")\n\nfrom urllib.parse import unquote\nprint(unquote('http%3A%2F%2Ffoo%20bar%2F'))\n"}
{"id": 59288, "name": "URL decoding", "source": "Translate Ruby to Python: require 'cgi'\nputs CGI.unescape(\"http%3A%2F%2Ffoo%20bar%2F\")\n\n", "target": "\nimport urllib\nprint urllib.unquote(\"http%3A%2F%2Ffoo%20bar%2F\")\n\nfrom urllib.parse import unquote\nprint(unquote('http%3A%2F%2Ffoo%20bar%2F'))\n"}
{"id": 59536, "name": "Closest-pair problem", "source": "Translate Ruby to C#: Point = Struct.new(:x, :y)\n\ndef distance(p1, p2)\n  Math.hypot(p1.x - p2.x, p1.y - p2.y)\nend\n\ndef closest_bruteforce(points)\n  mindist, minpts = Float::MAX, []\n  points.combination(2) do |pi,pj|\n    dist = distance(pi, pj)\n    if dist < mindist\n      mindist = dist\n      minpts = [pi, pj]\n    end\n  end\n  [mindist, minpts]\nend\n\ndef closest_recursive(points)\n  return closest_bruteforce(points) if points.length <= 3\n  xP = points.sort_by(&:x)\n  mid = points.length / 2\n  xm = xP[mid].x\n  dL, pairL = closest_recursive(xP[0,mid])\n  dR, pairR = closest_recursive(xP[mid..-1])\n  dmin, dpair = dL<dR ? [dL, pairL] : [dR, pairR]\n  yP = xP.find_all {|p| (xm - p.x).abs < dmin}.sort_by(&:y)\n  closest, closestPair = dmin, dpair\n  0.upto(yP.length - 2) do |i|\n    (i+1).upto(yP.length - 1) do |k|\n      break if (yP[k].y - yP[i].y) >= dmin\n      dist = distance(yP[i], yP[k])\n      if dist < closest\n        closest = dist\n        closestPair = [yP[i], yP[k]]\n      end\n    end\n  end\n  [closest, closestPair]\nend\n\npoints = Array.new(100) {Point.new(rand, rand)}\np ans1 = closest_bruteforce(points)\np ans2 = closest_recursive(points)\nfail \"bogus!\" if ans1[0] != ans2[0]\n\nrequire 'benchmark'\n\npoints = Array.new(10000) {Point.new(rand, rand)}\nBenchmark.bm(12) do |x|\n  x.report(\"bruteforce\") {ans1 = closest_bruteforce(points)}\n  x.report(\"recursive\")  {ans2 = closest_recursive(points)}\nend\n", "target": "class Segment\n{\n    public Segment(PointF p1, PointF p2)\n    {\n        P1 = p1;\n        P2 = p2;\n    }\n\n    public readonly PointF P1;\n    public readonly PointF P2;\n\n    public float Length()\n    {\n        return (float)Math.Sqrt(LengthSquared());\n    }\n\n    public float LengthSquared()\n    {\n        return (P1.X - P2.X) * (P1.X - P2.X)\n            + (P1.Y - P2.Y) * (P1.Y - P2.Y);\n    }\n}\n"}
{"id": 59538, "name": "Closest-pair problem", "source": "Translate Ruby to Java: Point = Struct.new(:x, :y)\n\ndef distance(p1, p2)\n  Math.hypot(p1.x - p2.x, p1.y - p2.y)\nend\n\ndef closest_bruteforce(points)\n  mindist, minpts = Float::MAX, []\n  points.combination(2) do |pi,pj|\n    dist = distance(pi, pj)\n    if dist < mindist\n      mindist = dist\n      minpts = [pi, pj]\n    end\n  end\n  [mindist, minpts]\nend\n\ndef closest_recursive(points)\n  return closest_bruteforce(points) if points.length <= 3\n  xP = points.sort_by(&:x)\n  mid = points.length / 2\n  xm = xP[mid].x\n  dL, pairL = closest_recursive(xP[0,mid])\n  dR, pairR = closest_recursive(xP[mid..-1])\n  dmin, dpair = dL<dR ? [dL, pairL] : [dR, pairR]\n  yP = xP.find_all {|p| (xm - p.x).abs < dmin}.sort_by(&:y)\n  closest, closestPair = dmin, dpair\n  0.upto(yP.length - 2) do |i|\n    (i+1).upto(yP.length - 1) do |k|\n      break if (yP[k].y - yP[i].y) >= dmin\n      dist = distance(yP[i], yP[k])\n      if dist < closest\n        closest = dist\n        closestPair = [yP[i], yP[k]]\n      end\n    end\n  end\n  [closest, closestPair]\nend\n\npoints = Array.new(100) {Point.new(rand, rand)}\np ans1 = closest_bruteforce(points)\np ans2 = closest_recursive(points)\nfail \"bogus!\" if ans1[0] != ans2[0]\n\nrequire 'benchmark'\n\npoints = Array.new(10000) {Point.new(rand, rand)}\nBenchmark.bm(12) do |x|\n  x.report(\"bruteforce\") {ans1 = closest_bruteforce(points)}\n  x.report(\"recursive\")  {ans2 = closest_recursive(points)}\nend\n", "target": "import java.util.*;\n\npublic class ClosestPair\n{\n  public static class Point\n  {\n    public final double x;\n    public final double y;\n    \n    public Point(double x, double y)\n    {\n      this.x = x;\n      this.y = y;\n    }\n    \n    public String toString()\n    {  return \"(\" + x + \", \" + y + \")\";  }\n  }\n  \n  public static class Pair\n  {\n    public Point point1 = null;\n    public Point point2 = null;\n    public double distance = 0.0;\n    \n    public Pair()\n    {  }\n    \n    public Pair(Point point1, Point point2)\n    {\n      this.point1 = point1;\n      this.point2 = point2;\n      calcDistance();\n    }\n    \n    public void update(Point point1, Point point2, double distance)\n    {\n      this.point1 = point1;\n      this.point2 = point2;\n      this.distance = distance;\n    }\n    \n    public void calcDistance()\n    {  this.distance = distance(point1, point2);  }\n    \n    public String toString()\n    {  return point1 + \"-\" + point2 + \"\u00a0: \" + distance;  }\n  }\n  \n  public static double distance(Point p1, Point p2)\n  {\n    double xdist = p2.x - p1.x;\n    double ydist = p2.y - p1.y;\n    return Math.hypot(xdist, ydist);\n  }\n  \n  public static Pair bruteForce(List<? extends Point> points)\n  {\n    int numPoints = points.size();\n    if (numPoints < 2)\n      return null;\n    Pair pair = new Pair(points.get(0), points.get(1));\n    if (numPoints > 2)\n    {\n      for (int i = 0; i < numPoints - 1; i++)\n      {\n        Point point1 = points.get(i);\n        for (int j = i + 1; j < numPoints; j++)\n        {\n          Point point2 = points.get(j);\n          double distance = distance(point1, point2);\n          if (distance < pair.distance)\n            pair.update(point1, point2, distance);\n        }\n      }\n    }\n    return pair;\n  }\n  \n  public static void sortByX(List<? extends Point> points)\n  {\n    Collections.sort(points, new Comparator<Point>() {\n        public int compare(Point point1, Point point2)\n        {\n          if (point1.x < point2.x)\n            return -1;\n          if (point1.x > point2.x)\n            return 1;\n          return 0;\n        }\n      }\n    );\n  }\n  \n  public static void sortByY(List<? extends Point> points)\n  {\n    Collections.sort(points, new Comparator<Point>() {\n        public int compare(Point point1, Point point2)\n        {\n          if (point1.y < point2.y)\n            return -1;\n          if (point1.y > point2.y)\n            return 1;\n          return 0;\n        }\n      }\n    );\n  }\n  \n  public static Pair divideAndConquer(List<? extends Point> points)\n  {\n    List<Point> pointsSortedByX = new ArrayList<Point>(points);\n    sortByX(pointsSortedByX);\n    List<Point> pointsSortedByY = new ArrayList<Point>(points);\n    sortByY(pointsSortedByY);\n    return divideAndConquer(pointsSortedByX, pointsSortedByY);\n  }\n  \n  private static Pair divideAndConquer(List<? extends Point> pointsSortedByX, List<? extends Point> pointsSortedByY)\n  {\n    int numPoints = pointsSortedByX.size();\n    if (numPoints <= 3)\n      return bruteForce(pointsSortedByX);\n    \n    int dividingIndex = numPoints >>> 1;\n    List<? extends Point> leftOfCenter = pointsSortedByX.subList(0, dividingIndex);\n    List<? extends Point> rightOfCenter = pointsSortedByX.subList(dividingIndex, numPoints);\n    \n    List<Point> tempList = new ArrayList<Point>(leftOfCenter);\n    sortByY(tempList);\n    Pair closestPair = divideAndConquer(leftOfCenter, tempList);\n    \n    tempList.clear();\n    tempList.addAll(rightOfCenter);\n    sortByY(tempList);\n    Pair closestPairRight = divideAndConquer(rightOfCenter, tempList);\n    \n    if (closestPairRight.distance < closestPair.distance)\n      closestPair = closestPairRight;\n    \n    tempList.clear();\n    double shortestDistance =closestPair.distance;\n    double centerX = rightOfCenter.get(0).x;\n    for (Point point : pointsSortedByY)\n      if (Math.abs(centerX - point.x) < shortestDistance)\n        tempList.add(point);\n    \n    for (int i = 0; i < tempList.size() - 1; i++)\n    {\n      Point point1 = tempList.get(i);\n      for (int j = i + 1; j < tempList.size(); j++)\n      {\n        Point point2 = tempList.get(j);\n        if ((point2.y - point1.y) >= shortestDistance)\n          break;\n        double distance = distance(point1, point2);\n        if (distance < closestPair.distance)\n        {\n          closestPair.update(point1, point2, distance);\n          shortestDistance = distance;\n        }\n      }\n    }\n    return closestPair;\n  }\n  \n  public static void main(String[] args)\n  {\n    int numPoints = (args.length == 0) ? 1000 : Integer.parseInt(args[0]);\n    List<Point> points = new ArrayList<Point>();\n    Random r = new Random();\n    for (int i = 0; i < numPoints; i++)\n      points.add(new Point(r.nextDouble(), r.nextDouble()));\n    System.out.println(\"Generated \" + numPoints + \" random points\");\n    long startTime = System.currentTimeMillis();\n    Pair bruteForceClosestPair = bruteForce(points);\n    long elapsedTime = System.currentTimeMillis() - startTime;\n    System.out.println(\"Brute force (\" + elapsedTime + \" ms): \" + bruteForceClosestPair);\n    startTime = System.currentTimeMillis();\n    Pair dqClosestPair = divideAndConquer(points);\n    elapsedTime = System.currentTimeMillis() - startTime;\n    System.out.println(\"Divide and conquer (\" + elapsedTime + \" ms): \" + dqClosestPair);\n    if (bruteForceClosestPair.distance != dqClosestPair.distance)\n      System.out.println(\"MISMATCH\");\n  }\n}\n"}
{"id": 59539, "name": "Closest-pair problem", "source": "Translate Ruby to Python: Point = Struct.new(:x, :y)\n\ndef distance(p1, p2)\n  Math.hypot(p1.x - p2.x, p1.y - p2.y)\nend\n\ndef closest_bruteforce(points)\n  mindist, minpts = Float::MAX, []\n  points.combination(2) do |pi,pj|\n    dist = distance(pi, pj)\n    if dist < mindist\n      mindist = dist\n      minpts = [pi, pj]\n    end\n  end\n  [mindist, minpts]\nend\n\ndef closest_recursive(points)\n  return closest_bruteforce(points) if points.length <= 3\n  xP = points.sort_by(&:x)\n  mid = points.length / 2\n  xm = xP[mid].x\n  dL, pairL = closest_recursive(xP[0,mid])\n  dR, pairR = closest_recursive(xP[mid..-1])\n  dmin, dpair = dL<dR ? [dL, pairL] : [dR, pairR]\n  yP = xP.find_all {|p| (xm - p.x).abs < dmin}.sort_by(&:y)\n  closest, closestPair = dmin, dpair\n  0.upto(yP.length - 2) do |i|\n    (i+1).upto(yP.length - 1) do |k|\n      break if (yP[k].y - yP[i].y) >= dmin\n      dist = distance(yP[i], yP[k])\n      if dist < closest\n        closest = dist\n        closestPair = [yP[i], yP[k]]\n      end\n    end\n  end\n  [closest, closestPair]\nend\n\npoints = Array.new(100) {Point.new(rand, rand)}\np ans1 = closest_bruteforce(points)\np ans2 = closest_recursive(points)\nfail \"bogus!\" if ans1[0] != ans2[0]\n\nrequire 'benchmark'\n\npoints = Array.new(10000) {Point.new(rand, rand)}\nBenchmark.bm(12) do |x|\n  x.report(\"bruteforce\") {ans1 = closest_bruteforce(points)}\n  x.report(\"recursive\")  {ans2 = closest_recursive(points)}\nend\n", "target": "\n\nfrom random import randint, randrange\nfrom operator import itemgetter, attrgetter\n\ninfinity = float('inf')\n\n\n\ndef bruteForceClosestPair(point):\n    numPoints = len(point)\n    if numPoints < 2:\n        return infinity, (None, None)\n    return min( ((abs(point[i] - point[j]), (point[i], point[j]))\n                 for i in range(numPoints-1)\n                 for j in range(i+1,numPoints)),\n                key=itemgetter(0))\n\ndef closestPair(point):\n    xP = sorted(point, key= attrgetter('real'))\n    yP = sorted(point, key= attrgetter('imag'))\n    return _closestPair(xP, yP)\n\ndef _closestPair(xP, yP):\n    numPoints = len(xP)\n    if numPoints <= 3:\n        return bruteForceClosestPair(xP)\n    Pl = xP[:numPoints/2]\n    Pr = xP[numPoints/2:]\n    Yl, Yr = [], []\n    xDivider = Pl[-1].real\n    for p in yP:\n        if p.real <= xDivider:\n            Yl.append(p)\n        else:\n            Yr.append(p)\n    dl, pairl = _closestPair(Pl, Yl)\n    dr, pairr = _closestPair(Pr, Yr)\n    dm, pairm = (dl, pairl) if dl < dr else (dr, pairr)\n    \n    closeY = [p for p in yP  if abs(p.real - xDivider) < dm]\n    numCloseY = len(closeY)\n    if numCloseY > 1:\n        \n        closestY = min( ((abs(closeY[i] - closeY[j]), (closeY[i], closeY[j]))\n                         for i in range(numCloseY-1)\n                         for j in range(i+1,min(i+8, numCloseY))),\n                        key=itemgetter(0))\n        return (dm, pairm) if dm <= closestY[0] else closestY\n    else:\n        return dm, pairm\n    \ndef times():\n    \n    import timeit\n\n    functions = [bruteForceClosestPair, closestPair]\n    for f in functions:\n        print 'Time for', f.__name__, timeit.Timer(\n            '%s(pointList)' % f.__name__,\n            'from closestpair import %s, pointList' % f.__name__).timeit(number=1)\n    \n\n\npointList = [randint(0,1000)+1j*randint(0,1000) for i in range(2000)]\n\nif __name__ == '__main__':\n    pointList = [(5+9j), (9+3j), (2+0j), (8+4j), (7+4j), (9+10j), (1+9j), (8+2j), 10j, (9+6j)]\n    print pointList\n    print '  bruteForceClosestPair:', bruteForceClosestPair(pointList)\n    print '            closestPair:', closestPair(pointList)\n    for i in range(10):\n        pointList = [randrange(11)+1j*randrange(11) for i in range(10)]\n        print '\\n', pointList\n        print ' bruteForceClosestPair:', bruteForceClosestPair(pointList)\n        print '           closestPair:', closestPair(pointList)\n    print '\\n'\n    times()\n    times()\n    times()\n"}
{"id": 59946, "name": "99 bottles of beer", "source": "Translate Ruby to C#: plural = 's'\n99.downto(1) do |i|\n  puts \"\n  puts \"\n  puts \"Take one down, pass it around!\"\n  plural = '' if i - 1 == 1\n  if i > 1\n    puts \"\n    puts\n  else\n    puts \"No more bottles of beer on the wall!\"\n  end\nend\n", "target": "using System;\n\nclass Program\n{\n    static void Main(string[] args)\n    {\n        for (int i = 99; i > -1; i--)\n        {\n            if (i == 0)\n            {\n                Console.WriteLine(\"No more bottles of beer on the wall, no more bottles of beer.\");\n                Console.WriteLine(\"Go to the store and buy some more, 99 bottles of beer on the wall.\");\n                break;\n            }\n            if (i == 1)\n            {\n                Console.WriteLine(\"1 bottle of beer on the wall, 1 bottle of beer.\");\n                Console.WriteLine(\"Take one down and pass it around, no more bottles of beer on the wall.\");\n                Console.WriteLine();\n            }\n            else\n            {\n                Console.WriteLine(\"{0} bottles of beer on the wall, {0} bottles of beer.\", i);\n                Console.WriteLine(\"Take one down and pass it around, {0} bottles of beer on the wall.\", i - 1);\n                Console.WriteLine();\n            }\n        }\n    }\n}\n"}
{"id": 59947, "name": "99 bottles of beer", "source": "Translate Ruby to C#: plural = 's'\n99.downto(1) do |i|\n  puts \"\n  puts \"\n  puts \"Take one down, pass it around!\"\n  plural = '' if i - 1 == 1\n  if i > 1\n    puts \"\n    puts\n  else\n    puts \"No more bottles of beer on the wall!\"\n  end\nend\n", "target": "using System;\n\nclass Program\n{\n    static void Main(string[] args)\n    {\n        for (int i = 99; i > -1; i--)\n        {\n            if (i == 0)\n            {\n                Console.WriteLine(\"No more bottles of beer on the wall, no more bottles of beer.\");\n                Console.WriteLine(\"Go to the store and buy some more, 99 bottles of beer on the wall.\");\n                break;\n            }\n            if (i == 1)\n            {\n                Console.WriteLine(\"1 bottle of beer on the wall, 1 bottle of beer.\");\n                Console.WriteLine(\"Take one down and pass it around, no more bottles of beer on the wall.\");\n                Console.WriteLine();\n            }\n            else\n            {\n                Console.WriteLine(\"{0} bottles of beer on the wall, {0} bottles of beer.\", i);\n                Console.WriteLine(\"Take one down and pass it around, {0} bottles of beer on the wall.\", i - 1);\n                Console.WriteLine();\n            }\n        }\n    }\n}\n"}
{"id": 59950, "name": "99 bottles of beer", "source": "Translate Ruby to Java: plural = 's'\n99.downto(1) do |i|\n  puts \"\n  puts \"\n  puts \"Take one down, pass it around!\"\n  plural = '' if i - 1 == 1\n  if i > 1\n    puts \"\n    puts\n  else\n    puts \"No more bottles of beer on the wall!\"\n  end\nend\n", "target": "module Bottles\n    {\n    @Inject Console console;\n    void run()\n        {\n        function String(Int) num     = i -> i==0 ? \"No\" : i.toString();\n        function String(Int) bottles = i -> i==1 ? \"bottle\" : \"bottles\";\n\n        for (Int remain : 99..1)\n            {\n            console.print($|{num(remain)} {bottles(remain)} of beer on the wall\n                           |{num(remain)} {bottles(remain)} of beer\n                           |Take one down, pass it around\n                           |{num(remain-1)} {bottles(remain-1)} of beer on the wall\n                           |\n                         );\n            }\n        }\n    }\n"}
{"id": 59951, "name": "99 bottles of beer", "source": "Translate Ruby to Java: plural = 's'\n99.downto(1) do |i|\n  puts \"\n  puts \"\n  puts \"Take one down, pass it around!\"\n  plural = '' if i - 1 == 1\n  if i > 1\n    puts \"\n    puts\n  else\n    puts \"No more bottles of beer on the wall!\"\n  end\nend\n", "target": "module Bottles\n    {\n    @Inject Console console;\n    void run()\n        {\n        function String(Int) num     = i -> i==0 ? \"No\" : i.toString();\n        function String(Int) bottles = i -> i==1 ? \"bottle\" : \"bottles\";\n\n        for (Int remain : 99..1)\n            {\n            console.print($|{num(remain)} {bottles(remain)} of beer on the wall\n                           |{num(remain)} {bottles(remain)} of beer\n                           |Take one down, pass it around\n                           |{num(remain-1)} {bottles(remain-1)} of beer on the wall\n                           |\n                         );\n            }\n        }\n    }\n"}
{"id": 59952, "name": "99 bottles of beer", "source": "Translate Ruby to Python: plural = 's'\n99.downto(1) do |i|\n  puts \"\n  puts \"\n  puts \"Take one down, pass it around!\"\n  plural = '' if i - 1 == 1\n  if i > 1\n    puts \"\n    puts\n  else\n    puts \"No more bottles of beer on the wall!\"\n  end\nend\n", "target": "fun bottles(n): match __args__:\n    (0) => \"No more bottles\"\n    (1) => \"1 bottle\"\n    (_) => \"$n bottles\"\n\nfor n in 99..-1..1:\n    print @format\n"}
{"id": 59953, "name": "99 bottles of beer", "source": "Translate Ruby to Python: plural = 's'\n99.downto(1) do |i|\n  puts \"\n  puts \"\n  puts \"Take one down, pass it around!\"\n  plural = '' if i - 1 == 1\n  if i > 1\n    puts \"\n    puts\n  else\n    puts \"No more bottles of beer on the wall!\"\n  end\nend\n", "target": "fun bottles(n): match __args__:\n    (0) => \"No more bottles\"\n    (1) => \"1 bottle\"\n    (_) => \"$n bottles\"\n\nfor n in 99..-1..1:\n    print @format\n"}
{"id": 60236, "name": "Concurrent computing", "source": "Translate Ruby to C#: require \"channel\"\nrequire \"fiber\"\nrequire \"random\"\n\ndone = Channel(Nil).new\n\n\"Enjoy Rosetta Code\".split.map do |x|\n  spawn do\n    sleep Random.new.rand(0..500).milliseconds\n    puts x\n    done.send nil\n  end\nend\n\n3.times do\n  done.receive\nend\n", "target": "static Random tRand = new Random();\n\nstatic void Main(string[] args)\n{\n\tThread t = new Thread(new ParameterizedThreadStart(WriteText));\n\tt.Start(\"Enjoy\");\n\n\tt = new Thread(new ParameterizedThreadStart(WriteText));\n\tt.Start(\"Rosetta\");\n\n\tt = new Thread(new ParameterizedThreadStart(WriteText));\n\tt.Start(\"Code\");\n\n\tConsole.ReadLine();\n}\n\nprivate static void WriteText(object p)\n{\n\tThread.Sleep(tRand.Next(1000, 4000));\n\tConsole.WriteLine(p);\n}\n"}
{"id": 60238, "name": "Concurrent computing", "source": "Translate Ruby to Java: require \"channel\"\nrequire \"fiber\"\nrequire \"random\"\n\ndone = Channel(Nil).new\n\n\"Enjoy Rosetta Code\".split.map do |x|\n  spawn do\n    sleep Random.new.rand(0..500).milliseconds\n    puts x\n    done.send nil\n  end\nend\n\n3.times do\n  done.receive\nend\n", "target": "import java.util.concurrent.CyclicBarrier;\n\npublic class Threads\n{\n  public static class DelayedMessagePrinter implements Runnable\n  {\n    private CyclicBarrier barrier;\n    private String msg;\n    \n    public DelayedMessagePrinter(CyclicBarrier barrier, String msg)\n    {\n      this.barrier = barrier;\n      this.msg = msg;\n    }\n    \n    public void run()\n    {\n      try\n      {  barrier.await();  }\n      catch (Exception e)\n      {  }\n      System.out.println(msg);\n    }\n  }\n  \n  public static void main(String[] args)\n  {\n    CyclicBarrier barrier = new CyclicBarrier(3);\n    new Thread(new DelayedMessagePrinter(barrier, \"Enjoy\")).start();\n    new Thread(new DelayedMessagePrinter(barrier, \"Rosetta\")).start();\n    new Thread(new DelayedMessagePrinter(barrier, \"Code\")).start();\n  }\n}\n"}
{"id": 60239, "name": "Concurrent computing", "source": "Translate Ruby to Python: require \"channel\"\nrequire \"fiber\"\nrequire \"random\"\n\ndone = Channel(Nil).new\n\n\"Enjoy Rosetta Code\".split.map do |x|\n  spawn do\n    sleep Random.new.rand(0..500).milliseconds\n    puts x\n    done.send nil\n  end\nend\n\n3.times do\n  done.receive\nend\n", "target": "let words = [\"Enjoy\", \"Rosetta\", \"Code\"]\n\nfor word in words:\n    (word) |> async (w) =>\n        sleep(random())\n        print(w)\n"}
{"id": 60466, "name": "Strip a set of characters from a string", "source": "Translate Ruby to C#: \"She was a soul stripper. She took my heart!\".delete(\"aei\")  \n", "target": "using System;\n\npublic static string RemoveCharactersFromString(string testString, string removeChars)\n{\n    char[] charAry = removeChars.ToCharArray();\n    string returnString = testString;\n    foreach (char c in charAry)\n    {\n        while (returnString.IndexOf(c) > -1)\n        {\n            returnString = returnString.Remove(returnString.IndexOf(c), 1);\n        }\n    }\n    return returnString;\n}\n"}
{"id": 60468, "name": "Strip a set of characters from a string", "source": "Translate Ruby to Java: \"She was a soul stripper. She took my heart!\".delete(\"aei\")  \n", "target": "class StripChars {\n    public static String stripChars(String inString, String toStrip) {\n        return inString.replaceAll(\"[\" + toStrip + \"]\", \"\");\n    }\n\n    public static void main(String[] args) {\n        String sentence = \"She was a soul stripper. She took my heart!\";\n        String chars = \"aei\";\n        System.out.println(\"sentence: \" + sentence);\n        System.out.println(\"to strip: \" + chars);\n        System.out.println(\"stripped: \" + stripChars(sentence, chars));\n    }\n}\n"}
{"id": 60469, "name": "Strip a set of characters from a string", "source": "Translate Ruby to Python: \"She was a soul stripper. She took my heart!\".delete(\"aei\")  \n", "target": ">>> def stripchars(s, chars):\n...     return s.translate(None, chars)\n... \n>>> stripchars(\"She was a soul stripper. She took my heart!\", \"aei\")\n'Sh ws  soul strppr. Sh took my hrt!'\n"}
{"id": 60827, "name": "Isqrt (integer square root) of X", "source": "Translate Ruby to C#: module Commatize\n  refine Integer do\n    def commatize\n      self.to_s.gsub( /(\\d)(?=\\d{3}+(?:\\.|$))(\\d{3}\\..*)?/, \"\\\\1,\\\\2\")\n    end\n  end\nend\n\nusing Commatize\ndef isqrt(x)\n    q, r = 1, 0\n    while (q <= x) do q <<= 2 end\n    while (q > 1) do\n        q >>= 2; t = x-r-q; r >>= 1\n        if (t >= 0) then x, r = t, r+q end\n    end\n    r\nend\n\nputs (0..65).map{|n| isqrt(n) }.join(\" \")\n\n1.step(73, 2) do |n|\n  print \"\n  puts isqrt(7**n).commatize\nend\n", "target": "using System;\nusing static System.Console;\nusing BI = System.Numerics.BigInteger;\n\u00a0\nclass Program {\n\u00a0\n    static BI isqrt(BI x) { BI q = 1, r = 0, t; while (q <= x) q <<= 2; while (q > 1) {\n        q >>= 2; t = x - r - q; r >>= 1; if (t >= 0) { x = t; r += q; } } return r; }\n\u00a0\n    static void Main() { const int max = 73, smax = 65;\n        int power_width = ((BI.Pow(7, max).ToString().Length / 3) << 2) + 3,\n            isqrt_width = (power_width + 1) >> 1;\n        WriteLine(\"Integer square root for numbers 0 to {0}:\", smax);\n        for (int n = 0; n <= smax; ++n) Write(\"{0} \", \n            (n / 10).ToString().Replace(\"0\", \" \")); WriteLine();\n        for (int n = 0; n <= smax; ++n) Write(\"{0} \", n % 10); WriteLine();\n        WriteLine(new String('-', (smax << 1) + 1));\n        for (int n = 0; n <= smax; ++n) Write(\"{0} \", isqrt(n));\n        WriteLine(\"\\n\\nInteger square roots of odd powers of 7 from 1 to {0}:\", max);\n        string s = string.Format(\"[0,2] |[1,{0}:n0] |[2,{1}:n0]\",\n            power_width, isqrt_width).Replace(\"[\", \"{\").Replace(\"]\", \"}\");\n        WriteLine(s, \"n\", \"7 ^ n\", \"isqrt(7 ^ n)\");\n        WriteLine(new String('-', power_width + isqrt_width + 6));\n        BI p = 7; for (int n = 1; n <= max; n += 2, p *= 49)\n            WriteLine (s, n, p, isqrt(p)); }\n}\n"}
{"id": 60828, "name": "Isqrt (integer square root) of X", "source": "Translate Ruby to C#: module Commatize\n  refine Integer do\n    def commatize\n      self.to_s.gsub( /(\\d)(?=\\d{3}+(?:\\.|$))(\\d{3}\\..*)?/, \"\\\\1,\\\\2\")\n    end\n  end\nend\n\nusing Commatize\ndef isqrt(x)\n    q, r = 1, 0\n    while (q <= x) do q <<= 2 end\n    while (q > 1) do\n        q >>= 2; t = x-r-q; r >>= 1\n        if (t >= 0) then x, r = t, r+q end\n    end\n    r\nend\n\nputs (0..65).map{|n| isqrt(n) }.join(\" \")\n\n1.step(73, 2) do |n|\n  print \"\n  puts isqrt(7**n).commatize\nend\n", "target": "using System;\nusing static System.Console;\nusing BI = System.Numerics.BigInteger;\n\u00a0\nclass Program {\n\u00a0\n    static BI isqrt(BI x) { BI q = 1, r = 0, t; while (q <= x) q <<= 2; while (q > 1) {\n        q >>= 2; t = x - r - q; r >>= 1; if (t >= 0) { x = t; r += q; } } return r; }\n\u00a0\n    static void Main() { const int max = 73, smax = 65;\n        int power_width = ((BI.Pow(7, max).ToString().Length / 3) << 2) + 3,\n            isqrt_width = (power_width + 1) >> 1;\n        WriteLine(\"Integer square root for numbers 0 to {0}:\", smax);\n        for (int n = 0; n <= smax; ++n) Write(\"{0} \", \n            (n / 10).ToString().Replace(\"0\", \" \")); WriteLine();\n        for (int n = 0; n <= smax; ++n) Write(\"{0} \", n % 10); WriteLine();\n        WriteLine(new String('-', (smax << 1) + 1));\n        for (int n = 0; n <= smax; ++n) Write(\"{0} \", isqrt(n));\n        WriteLine(\"\\n\\nInteger square roots of odd powers of 7 from 1 to {0}:\", max);\n        string s = string.Format(\"[0,2] |[1,{0}:n0] |[2,{1}:n0]\",\n            power_width, isqrt_width).Replace(\"[\", \"{\").Replace(\"]\", \"}\");\n        WriteLine(s, \"n\", \"7 ^ n\", \"isqrt(7 ^ n)\");\n        WriteLine(new String('-', power_width + isqrt_width + 6));\n        BI p = 7; for (int n = 1; n <= max; n += 2, p *= 49)\n            WriteLine (s, n, p, isqrt(p)); }\n}\n"}
{"id": 60831, "name": "Isqrt (integer square root) of X", "source": "Translate Ruby to Java: module Commatize\n  refine Integer do\n    def commatize\n      self.to_s.gsub( /(\\d)(?=\\d{3}+(?:\\.|$))(\\d{3}\\..*)?/, \"\\\\1,\\\\2\")\n    end\n  end\nend\n\nusing Commatize\ndef isqrt(x)\n    q, r = 1, 0\n    while (q <= x) do q <<= 2 end\n    while (q > 1) do\n        q >>= 2; t = x-r-q; r >>= 1\n        if (t >= 0) then x, r = t, r+q end\n    end\n    r\nend\n\nputs (0..65).map{|n| isqrt(n) }.join(\" \")\n\n1.step(73, 2) do |n|\n  print \"\n  puts isqrt(7**n).commatize\nend\n", "target": "import java.math.BigInteger;\n\npublic class Isqrt {\n    private static BigInteger isqrt(BigInteger x) {\n        if (x.compareTo(BigInteger.ZERO) < 0) {\n            throw new IllegalArgumentException(\"Argument cannot be negative\");\n        }\n        var q = BigInteger.ONE;\n        while (q.compareTo(x) <= 0) {\n            q = q.shiftLeft(2);\n        }\n        var z = x;\n        var r = BigInteger.ZERO;\n        while (q.compareTo(BigInteger.ONE) > 0) {\n            q = q.shiftRight(2);\n            var t = z;\n            t = t.subtract(r);\n            t = t.subtract(q);\n            r = r.shiftRight(1);\n            if (t.compareTo(BigInteger.ZERO) >= 0) {\n                z = t;\n                r = r.add(q);\n            }\n        }\n        return r;\n    }\n\n    public static void main(String[] args) {\n        System.out.println(\"The integer square root of integers from 0 to 65 are:\");\n        for (int i = 0; i <= 65; i++) {\n            System.out.printf(\"%s \", isqrt(BigInteger.valueOf(i)));\n        }\n        System.out.println();\n\n        System.out.println(\"The integer square roots of powers of 7 from 7^1 up to 7^73 are:\");\n        System.out.println(\"power                                    7 ^ power                                                 integer square root\");\n        System.out.println(\"----- --------------------------------------------------------------------------------- -----------------------------------------\");\n        var pow7 = BigInteger.valueOf(7);\n        var bi49 = BigInteger.valueOf(49);\n        for (int i = 1; i < 74; i += 2) {\n            System.out.printf(\"%2d\u00a0%,84d\u00a0%,41d\\n\", i, pow7, isqrt(pow7));\n            pow7 = pow7.multiply(bi49);\n        }\n    }\n}\n"}
{"id": 60832, "name": "Isqrt (integer square root) of X", "source": "Translate Ruby to Java: module Commatize\n  refine Integer do\n    def commatize\n      self.to_s.gsub( /(\\d)(?=\\d{3}+(?:\\.|$))(\\d{3}\\..*)?/, \"\\\\1,\\\\2\")\n    end\n  end\nend\n\nusing Commatize\ndef isqrt(x)\n    q, r = 1, 0\n    while (q <= x) do q <<= 2 end\n    while (q > 1) do\n        q >>= 2; t = x-r-q; r >>= 1\n        if (t >= 0) then x, r = t, r+q end\n    end\n    r\nend\n\nputs (0..65).map{|n| isqrt(n) }.join(\" \")\n\n1.step(73, 2) do |n|\n  print \"\n  puts isqrt(7**n).commatize\nend\n", "target": "import java.math.BigInteger;\n\npublic class Isqrt {\n    private static BigInteger isqrt(BigInteger x) {\n        if (x.compareTo(BigInteger.ZERO) < 0) {\n            throw new IllegalArgumentException(\"Argument cannot be negative\");\n        }\n        var q = BigInteger.ONE;\n        while (q.compareTo(x) <= 0) {\n            q = q.shiftLeft(2);\n        }\n        var z = x;\n        var r = BigInteger.ZERO;\n        while (q.compareTo(BigInteger.ONE) > 0) {\n            q = q.shiftRight(2);\n            var t = z;\n            t = t.subtract(r);\n            t = t.subtract(q);\n            r = r.shiftRight(1);\n            if (t.compareTo(BigInteger.ZERO) >= 0) {\n                z = t;\n                r = r.add(q);\n            }\n        }\n        return r;\n    }\n\n    public static void main(String[] args) {\n        System.out.println(\"The integer square root of integers from 0 to 65 are:\");\n        for (int i = 0; i <= 65; i++) {\n            System.out.printf(\"%s \", isqrt(BigInteger.valueOf(i)));\n        }\n        System.out.println();\n\n        System.out.println(\"The integer square roots of powers of 7 from 7^1 up to 7^73 are:\");\n        System.out.println(\"power                                    7 ^ power                                                 integer square root\");\n        System.out.println(\"----- --------------------------------------------------------------------------------- -----------------------------------------\");\n        var pow7 = BigInteger.valueOf(7);\n        var bi49 = BigInteger.valueOf(49);\n        for (int i = 1; i < 74; i += 2) {\n            System.out.printf(\"%2d\u00a0%,84d\u00a0%,41d\\n\", i, pow7, isqrt(pow7));\n            pow7 = pow7.multiply(bi49);\n        }\n    }\n}\n"}
{"id": 60833, "name": "Isqrt (integer square root) of X", "source": "Translate Ruby to Python: module Commatize\n  refine Integer do\n    def commatize\n      self.to_s.gsub( /(\\d)(?=\\d{3}+(?:\\.|$))(\\d{3}\\..*)?/, \"\\\\1,\\\\2\")\n    end\n  end\nend\n\nusing Commatize\ndef isqrt(x)\n    q, r = 1, 0\n    while (q <= x) do q <<= 2 end\n    while (q > 1) do\n        q >>= 2; t = x-r-q; r >>= 1\n        if (t >= 0) then x, r = t, r+q end\n    end\n    r\nend\n\nputs (0..65).map{|n| isqrt(n) }.join(\" \")\n\n1.step(73, 2) do |n|\n  print \"\n  puts isqrt(7**n).commatize\nend\n", "target": "def isqrt ( x ):\n    q = 1\n    while q <= x : \n        q *= 4\n    z,r = x,0\n    while q > 1 :\n        q  /= 4\n        t,r = z-r-q,r/2\n        if t >= 0 :\n            z,r = t,r+q\n    return r \n\nprint ' '.join( '%d'%isqrt( n ) for n in xrange( 66 ))\nprint '\\n'.join( '{0:114,} = isqrt( 7^{1:3} )'.format( isqrt( 7**n ),n ) for n in range( 1,204,2 ))\n"}
{"id": 60834, "name": "Isqrt (integer square root) of X", "source": "Translate Ruby to Python: module Commatize\n  refine Integer do\n    def commatize\n      self.to_s.gsub( /(\\d)(?=\\d{3}+(?:\\.|$))(\\d{3}\\..*)?/, \"\\\\1,\\\\2\")\n    end\n  end\nend\n\nusing Commatize\ndef isqrt(x)\n    q, r = 1, 0\n    while (q <= x) do q <<= 2 end\n    while (q > 1) do\n        q >>= 2; t = x-r-q; r >>= 1\n        if (t >= 0) then x, r = t, r+q end\n    end\n    r\nend\n\nputs (0..65).map{|n| isqrt(n) }.join(\" \")\n\n1.step(73, 2) do |n|\n  print \"\n  puts isqrt(7**n).commatize\nend\n", "target": "def isqrt ( x ):\n    q = 1\n    while q <= x : \n        q *= 4\n    z,r = x,0\n    while q > 1 :\n        q  /= 4\n        t,r = z-r-q,r/2\n        if t >= 0 :\n            z,r = t,r+q\n    return r \n\nprint ' '.join( '%d'%isqrt( n ) for n in xrange( 66 ))\nprint '\\n'.join( '{0:114,} = isqrt( 7^{1:3} )'.format( isqrt( 7**n ),n ) for n in range( 1,204,2 ))\n"}
{"id": 61147, "name": "Jewels and stones", "source": "Translate Ruby to C#: stones, jewels = \"aAAbbbb\", \"aA\"\nstones.count(jewels) \n\n\nstones, jewels = \"aA^Bb\", \"^b\"\nstones.count(jewels) \n\n\n\nstones.count { |c| jewels.chars.includes?(c) } \n", "target": "using System;\nusing System.Linq;\n\npublic class Program\n{\n    public static void Main() {\n        Console.WriteLine(Count(\"aAAbbbb\", \"Aa\"));\n        Console.WriteLine(Count(\"ZZ\", \"z\"));\n    }\n\n    private static int Count(string stones, string jewels) {\n        var bag = jewels.ToHashSet();\n        return stones.Count(bag.Contains);\n    }\n}\n"}
{"id": 61148, "name": "Jewels and stones", "source": "Translate Ruby to C#: stones, jewels = \"aAAbbbb\", \"aA\"\nstones.count(jewels) \n\n\nstones, jewels = \"aA^Bb\", \"^b\"\nstones.count(jewels) \n\n\n\nstones.count { |c| jewels.chars.includes?(c) } \n", "target": "using System;\nusing System.Linq;\n\npublic class Program\n{\n    public static void Main() {\n        Console.WriteLine(Count(\"aAAbbbb\", \"Aa\"));\n        Console.WriteLine(Count(\"ZZ\", \"z\"));\n    }\n\n    private static int Count(string stones, string jewels) {\n        var bag = jewels.ToHashSet();\n        return stones.Count(bag.Contains);\n    }\n}\n"}
{"id": 61151, "name": "Jewels and stones", "source": "Translate Ruby to Java: stones, jewels = \"aAAbbbb\", \"aA\"\nstones.count(jewels) \n\n\nstones, jewels = \"aA^Bb\", \"^b\"\nstones.count(jewels) \n\n\n\nstones.count { |c| jewels.chars.includes?(c) } \n", "target": "import java.util.HashSet;\nimport java.util.Set;\n\npublic class App {\n    private static int countJewels(String stones, String jewels) {\n        Set<Character> bag = new HashSet<>();\n        for (char c : jewels.toCharArray()) {\n            bag.add(c);\n        }\n\n        int count = 0;\n        for (char c : stones.toCharArray()) {\n            if (bag.contains(c)) {\n                count++;\n            }\n        }\n\n        return count;\n    }\n\n    public static void main(String[] args) {\n        System.out.println(countJewels(\"aAAbbbb\", \"aA\"));\n        System.out.println(countJewels(\"ZZ\", \"z\"));\n    }\n}\n"}
{"id": 61152, "name": "Jewels and stones", "source": "Translate Ruby to Java: stones, jewels = \"aAAbbbb\", \"aA\"\nstones.count(jewels) \n\n\nstones, jewels = \"aA^Bb\", \"^b\"\nstones.count(jewels) \n\n\n\nstones.count { |c| jewels.chars.includes?(c) } \n", "target": "import java.util.HashSet;\nimport java.util.Set;\n\npublic class App {\n    private static int countJewels(String stones, String jewels) {\n        Set<Character> bag = new HashSet<>();\n        for (char c : jewels.toCharArray()) {\n            bag.add(c);\n        }\n\n        int count = 0;\n        for (char c : stones.toCharArray()) {\n            if (bag.contains(c)) {\n                count++;\n            }\n        }\n\n        return count;\n    }\n\n    public static void main(String[] args) {\n        System.out.println(countJewels(\"aAAbbbb\", \"aA\"));\n        System.out.println(countJewels(\"ZZ\", \"z\"));\n    }\n}\n"}
{"id": 61153, "name": "Jewels and stones", "source": "Translate Ruby to Python: stones, jewels = \"aAAbbbb\", \"aA\"\nstones.count(jewels) \n\n\nstones, jewels = \"aA^Bb\", \"^b\"\nstones.count(jewels) \n\n\n\nstones.count { |c| jewels.chars.includes?(c) } \n", "target": "def countJewels(s, j):\n    return sum(x in j for x in s)\n\nprint countJewels(\"aAAbbbb\", \"aA\")\nprint countJewels(\"ZZ\", \"z\")\n"}
{"id": 61154, "name": "Jewels and stones", "source": "Translate Ruby to Python: stones, jewels = \"aAAbbbb\", \"aA\"\nstones.count(jewels) \n\n\nstones, jewels = \"aA^Bb\", \"^b\"\nstones.count(jewels) \n\n\n\nstones.count { |c| jewels.chars.includes?(c) } \n", "target": "def countJewels(s, j):\n    return sum(x in j for x in s)\n\nprint countJewels(\"aAAbbbb\", \"aA\")\nprint countJewels(\"ZZ\", \"z\")\n"}
{"id": 61426, "name": "Factorial", "source": "Translate Ruby to C#: \ndef factorial_recursive(n)\n  n.zero? ? 1 : n * factorial_recursive(n - 1)\nend\n\n\ndef factorial_tail_recursive(n, prod = 1)\n  n.zero? ? prod : factorial_tail_recursive(n - 1, prod * n)\nend\n\n\ndef factorial_iterative(n)\n  (2...n).each { |i| n *= i }\n  n.zero? ? 1 : n\nend\n\n\ndef factorial_inject(n)\n  (1..n).inject(1){ |prod, i| prod * i }\nend\n\n\ndef factorial_reduce(n)\n  (2..n).reduce(1, :*)\nend\n\n\nrequire 'benchmark'\n\nn = 400\nm = 10000\n\nBenchmark.bm(16) do |b|\n  b.report('recursive:')       {m.times {factorial_recursive(n)}}\n  b.report('tail recursive:')  {m.times {factorial_tail_recursive(n)}}\n  b.report('iterative:')       {m.times {factorial_iterative(n)}}\n  b.report('inject:')          {m.times {factorial_inject(n)}}\n  b.report('reduce:')          {m.times {factorial_reduce(n)}}\nend\n", "target": "using System;\n\nclass Program\n{\n    static int Factorial(int number)\n    {\n        if(number < 0) \n            throw new ArgumentOutOfRangeException(nameof(number), number, \"Must be zero or a positive number.\");\n\n        var accumulator = 1;\n        for (var factor = 1; factor <= number; factor++)\n        {\n            accumulator *= factor;\n        }\n        return accumulator;\n    }\n\n    static void Main()\n    {\n        Console.WriteLine(Factorial(10));\n    }\n}\n"}
{"id": 61428, "name": "Factorial", "source": "Translate Ruby to Java: \ndef factorial_recursive(n)\n  n.zero? ? 1 : n * factorial_recursive(n - 1)\nend\n\n\ndef factorial_tail_recursive(n, prod = 1)\n  n.zero? ? prod : factorial_tail_recursive(n - 1, prod * n)\nend\n\n\ndef factorial_iterative(n)\n  (2...n).each { |i| n *= i }\n  n.zero? ? 1 : n\nend\n\n\ndef factorial_inject(n)\n  (1..n).inject(1){ |prod, i| prod * i }\nend\n\n\ndef factorial_reduce(n)\n  (2..n).reduce(1, :*)\nend\n\n\nrequire 'benchmark'\n\nn = 400\nm = 10000\n\nBenchmark.bm(16) do |b|\n  b.report('recursive:')       {m.times {factorial_recursive(n)}}\n  b.report('tail recursive:')  {m.times {factorial_tail_recursive(n)}}\n  b.report('iterative:')       {m.times {factorial_iterative(n)}}\n  b.report('inject:')          {m.times {factorial_inject(n)}}\n  b.report('reduce:')          {m.times {factorial_reduce(n)}}\nend\n", "target": "module ShowFactorials\n    {\n    static <Value extends IntNumber> Value factorial(Value n)\n        {\n        assert:arg n >= Value.zero();\n        return n <= Value.one() ? n : n * factorial(n-Value.one());\n        }\n\n    @Inject Console console;\n    void run()\n        {\n        \n        UInt128 bigNum = 34;\n        console.print($\"factorial({bigNum})={factorial(bigNum)}\");\n\n        \n        for (Int i : 10..-1)\n            {\n            console.print($\"factorial({i})={factorial(i)}\");\n            }\n        }\n    }\n"}
{"id": 61429, "name": "Factorial", "source": "Translate Ruby to Python: \ndef factorial_recursive(n)\n  n.zero? ? 1 : n * factorial_recursive(n - 1)\nend\n\n\ndef factorial_tail_recursive(n, prod = 1)\n  n.zero? ? prod : factorial_tail_recursive(n - 1, prod * n)\nend\n\n\ndef factorial_iterative(n)\n  (2...n).each { |i| n *= i }\n  n.zero? ? 1 : n\nend\n\n\ndef factorial_inject(n)\n  (1..n).inject(1){ |prod, i| prod * i }\nend\n\n\ndef factorial_reduce(n)\n  (2..n).reduce(1, :*)\nend\n\n\nrequire 'benchmark'\n\nn = 400\nm = 10000\n\nBenchmark.bm(16) do |b|\n  b.report('recursive:')       {m.times {factorial_recursive(n)}}\n  b.report('tail recursive:')  {m.times {factorial_tail_recursive(n)}}\n  b.report('iterative:')       {m.times {factorial_iterative(n)}}\n  b.report('inject:')          {m.times {factorial_inject(n)}}\n  b.report('reduce:')          {m.times {factorial_reduce(n)}}\nend\n", "target": "import math\nmath.factorial(n)\n"}
{"id": 61634, "name": "Polynomial regression", "source": "Translate Ruby to C#: require 'matrix'\n\ndef regress x, y, degree\n  x_data = x.map { |xi| (0..degree).map { |pow| (xi**pow).to_r } }\n\n  mx = Matrix[*x_data]\n  my = Matrix.column_vector(y)\n\n  ((mx.t * mx).inv * mx.t * my).transpose.to_a[0].map(&:to_f)\nend\n", "target": "        public static double[] Polyfit(double[] x, double[] y, int degree)\n        {\n            \n            var v = new DenseMatrix(x.Length, degree + 1);\n            for (int i = 0; i < v.RowCount; i++)\n                for (int j = 0; j <= degree; j++) v[i, j] = Math.Pow(x[i], j);\n            var yv = new DenseVector(y).ToColumnMatrix();\n            QR<double> qr = v.QR();\n            \n            \n            var r = qr.R.SubMatrix(0, degree + 1, 0, degree + 1);\n            var q = v.Multiply(r.Inverse());\n            var p = r.Inverse().Multiply(q.TransposeThisAndMultiply(yv));\n            return p.Column(0).ToArray();\n        }\n"}
{"id": 61636, "name": "Polynomial regression", "source": "Translate Ruby to Java: require 'matrix'\n\ndef regress x, y, degree\n  x_data = x.map { |xi| (0..degree).map { |pow| (xi**pow).to_r } }\n\n  mx = Matrix[*x_data]\n  my = Matrix.column_vector(y)\n\n  ((mx.t * mx).inv * mx.t * my).transpose.to_a[0].map(&:to_f)\nend\n", "target": "import java.util.Arrays;\nimport java.util.function.IntToDoubleFunction;\nimport java.util.stream.IntStream;\n\npublic class PolynomialRegression {\n    private static void polyRegression(int[] x, int[] y) {\n        int n = x.length;\n        double xm = Arrays.stream(x).average().orElse(Double.NaN);\n        double ym = Arrays.stream(y).average().orElse(Double.NaN);\n        double x2m = Arrays.stream(x).map(a -> a * a).average().orElse(Double.NaN);\n        double x3m = Arrays.stream(x).map(a -> a * a * a).average().orElse(Double.NaN);\n        double x4m = Arrays.stream(x).map(a -> a * a * a * a).average().orElse(Double.NaN);\n        double xym = 0.0;\n        for (int i = 0; i < x.length && i < y.length; ++i) {\n            xym += x[i] * y[i];\n        }\n        xym /= Math.min(x.length, y.length);\n        double x2ym = 0.0;\n        for (int i = 0; i < x.length && i < y.length; ++i) {\n            x2ym += x[i] * x[i] * y[i];\n        }\n        x2ym /= Math.min(x.length, y.length);\n\n        double sxx = x2m - xm * xm;\n        double sxy = xym - xm * ym;\n        double sxx2 = x3m - xm * x2m;\n        double sx2x2 = x4m - x2m * x2m;\n        double sx2y = x2ym - x2m * ym;\n\n        double b = (sxy * sx2x2 - sx2y * sxx2) / (sxx * sx2x2 - sxx2 * sxx2);\n        double c = (sx2y * sxx - sxy * sxx2) / (sxx * sx2x2 - sxx2 * sxx2);\n        double a = ym - b * xm - c * x2m;\n\n        IntToDoubleFunction abc = (int xx) -> a + b * xx + c * xx * xx;\n\n        System.out.println(\"y = \" + a + \" + \" + b + \"x + \" + c + \"x^2\");\n        System.out.println(\" Input  Approximation\");\n        System.out.println(\" x   y     y1\");\n        for (int i = 0; i < n; ++i) {\n            System.out.printf(\"%2d %3d  %5.1f\\n\", x[i], y[i], abc.applyAsDouble(x[i]));\n        }\n    }\n\n    public static void main(String[] args) {\n        int[] x = IntStream.range(0, 11).toArray();\n        int[] y = new int[]{1, 6, 17, 34, 57, 86, 121, 162, 209, 262, 321};\n        polyRegression(x, y);\n    }\n}\n"}
{"id": 61637, "name": "Polynomial regression", "source": "Translate Ruby to Python: require 'matrix'\n\ndef regress x, y, degree\n  x_data = x.map { |xi| (0..degree).map { |pow| (xi**pow).to_r } }\n\n  mx = Matrix[*x_data]\n  my = Matrix.column_vector(y)\n\n  ((mx.t * mx).inv * mx.t * my).transpose.to_a[0].map(&:to_f)\nend\n", "target": ">>> x = [0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10]\n>>> y = [1,   6,  17,  34,  57,  86, 121, 162, 209, 262, 321]\n>>> coeffs = numpy.polyfit(x,y,deg=2)\n>>> coeffs\narray([ 3.,  2.,  1.])\n"}
{"id": 61870, "name": "Menu", "source": "Translate Ruby to C#: def select(prompt, items = [])\n  if items.empty?\n    ''\n  else\n    answer = -1\n    until (0...items.length).cover?(answer)\n      items.each_with_index {|i,j| puts \"\n      print \"\n      begin\n        answer = Integer(gets)\n      rescue ArgumentError\n        redo\n      end\n    end\n    items[answer]\n  end\nend\n \n\nresponse = select('Which is empty')\nputs \"empty list returns: >\n \n\nitems = ['fee fie', 'huff and puff', 'mirror mirror', 'tick tock']\nresponse = select('Which is from the three pigs', items)\nputs \"you chose: >\n", "target": "using System;\nusing System.Collections.Generic;\n\npublic class Menu\n{\n        static void Main(string[] args)\n        {\n            List<string> menu_items = new List<string>() { \"fee fie\", \"huff and puff\", \"mirror mirror\", \"tick tock\" };\n            \n            Console.WriteLine(PrintMenu(menu_items));\n            Console.ReadLine();\n        }\n        private static string PrintMenu(List<string> items)\n        {\n            if (items.Count == 0)\n                return \"\";\n\n            string input = \"\";\n            int i = -1;\n            do\n            {\n                for (int j = 0; j < items.Count; j++)\n                    Console.WriteLine(\"{0}) {1}\", j, items[j]);\n\n                Console.WriteLine(\"What number?\");\n                input = Console.ReadLine();\n\n            } while (!int.TryParse(input, out i) || i >= items.Count || i < 0);\n            return items[i];\n        }\n}\n"}
{"id": 61872, "name": "Menu", "source": "Translate Ruby to Java: def select(prompt, items = [])\n  if items.empty?\n    ''\n  else\n    answer = -1\n    until (0...items.length).cover?(answer)\n      items.each_with_index {|i,j| puts \"\n      print \"\n      begin\n        answer = Integer(gets)\n      rescue ArgumentError\n        redo\n      end\n    end\n    items[answer]\n  end\nend\n \n\nresponse = select('Which is empty')\nputs \"empty list returns: >\n \n\nitems = ['fee fie', 'huff and puff', 'mirror mirror', 'tick tock']\nresponse = select('Which is from the three pigs', items)\nputs \"you chose: >\n", "target": "public static String select(List<String> list, String prompt){\n    if(list.size() == 0) return \"\";\n    Scanner sc = new Scanner(System.in);\n    String ret = null;\n    do{\n        for(int i=0;i<list.size();i++){\n            System.out.println(i + \": \"+list.get(i));\n        }\n        System.out.print(prompt);\n        int index = sc.nextInt();\n        if(index >= 0 && index < list.size()){\n            ret = list.get(index);\n        }\n    }while(ret == null);\n    return ret;\n}\n"}
{"id": 61873, "name": "Menu", "source": "Translate Ruby to Python: def select(prompt, items = [])\n  if items.empty?\n    ''\n  else\n    answer = -1\n    until (0...items.length).cover?(answer)\n      items.each_with_index {|i,j| puts \"\n      print \"\n      begin\n        answer = Integer(gets)\n      rescue ArgumentError\n        redo\n      end\n    end\n    items[answer]\n  end\nend\n \n\nresponse = select('Which is empty')\nputs \"empty list returns: >\n \n\nitems = ['fee fie', 'huff and puff', 'mirror mirror', 'tick tock']\nresponse = select('Which is from the three pigs', items)\nputs \"you chose: >\n", "target": "def _menu(items):\n    for indexitem in enumerate(items):\n        print (\"  %2i) %s\" % indexitem)\n\ndef _ok(reply, itemcount):\n    try:\n        n = int(reply)\n        return 0 <= n < itemcount\n    except:\n        return False\n    \ndef selector(items, prompt):\n    'Prompt to select an item from the items'\n    if not items: return ''\n    reply = -1\n    itemcount = len(items)\n    while not _ok(reply, itemcount):\n        _menu(items)\n        \n        reply = raw_input(prompt).strip()\n    return items[int(reply)]\n\nif __name__ == '__main__':\n    items = ['fee fie', 'huff and puff', 'mirror mirror', 'tick tock']\n    item = selector(items, 'Which is from the three pigs: ')\n    print (\"You chose: \" + item)\n"}
{"id": 62261, "name": "Greatest subsequential sum", "source": "Translate Ruby to C#: def subarray_sum(arr)\n  max, slice = 0, [] of Int32\n  arr.each_index do |i|\n    (i...arr.size).each do |j|\n      sum = arr[i..j].sum\n      max, slice = sum, arr[i..j] if sum > max\n    end\n  end\n  [max, slice]\nend\n", "target": "using System;\n\nnamespace Tests_With_Framework_4\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            int[] integers = { -1, -2, 3, 5, 6, -2, -1, 4, -4, 2, -1 }; int length = integers.Length;\n            int maxsum, beginmax, endmax, sum; maxsum = beginmax = sum = 0; endmax = -1;\n\n            for (int i = 0; i < length; i++)\n            {\n                sum = 0;\n                for (int k = i; k < length; k++)\n                {\n                    sum += integers[k];\n                    if (sum > maxsum)\n                    {\n                        maxsum = sum;\n                        beginmax = i;\n                        endmax = k;\n                    }\n                }\n            }\n\n            for (int i = beginmax; i <= endmax; i++)\n                Console.WriteLine(integers[i]);\n\n            Console.ReadKey();\n        }\n    }\n}\n"}
{"id": 62262, "name": "Greatest subsequential sum", "source": "Translate Ruby to C#: def subarray_sum(arr)\n  max, slice = 0, [] of Int32\n  arr.each_index do |i|\n    (i...arr.size).each do |j|\n      sum = arr[i..j].sum\n      max, slice = sum, arr[i..j] if sum > max\n    end\n  end\n  [max, slice]\nend\n", "target": "using System;\n\nnamespace Tests_With_Framework_4\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            int[] integers = { -1, -2, 3, 5, 6, -2, -1, 4, -4, 2, -1 }; int length = integers.Length;\n            int maxsum, beginmax, endmax, sum; maxsum = beginmax = sum = 0; endmax = -1;\n\n            for (int i = 0; i < length; i++)\n            {\n                sum = 0;\n                for (int k = i; k < length; k++)\n                {\n                    sum += integers[k];\n                    if (sum > maxsum)\n                    {\n                        maxsum = sum;\n                        beginmax = i;\n                        endmax = k;\n                    }\n                }\n            }\n\n            for (int i = beginmax; i <= endmax; i++)\n                Console.WriteLine(integers[i]);\n\n            Console.ReadKey();\n        }\n    }\n}\n"}
{"id": 62265, "name": "Greatest subsequential sum", "source": "Translate Ruby to Java: def subarray_sum(arr)\n  max, slice = 0, [] of Int32\n  arr.each_index do |i|\n    (i...arr.size).each do |j|\n      sum = arr[i..j].sum\n      max, slice = sum, arr[i..j] if sum > max\n    end\n  end\n  [max, slice]\nend\n", "target": "import java.util.Scanner;\nimport java.util.ArrayList;\n\npublic class Sub{\n    private static int[] indices;\n\n    public static void main(String[] args){\n        ArrayList<Long> array= new ArrayList<Long>(); \n        Scanner in = new Scanner(System.in);\n        while(in.hasNextLong()) array.add(in.nextLong());\n        long highSum= Long.MIN_VALUE;\n        ArrayList<Long> highSet= new ArrayList<Long>();\n        \n        for(int subSize= 0;subSize<= array.size();subSize++){\n            indices= new int[subSize];\n            for(int i= 0;i< subSize;i++) indices[i]= i;\n            do{\n                long sum= 0;\n                ArrayList<Long> temp= new ArrayList<Long>();\n                \n                for(long index:indices) {sum+= array.get(index); temp.add(array.get(index));}\n                if(sum > highSum){\n                    highSet= temp;    \n                    highSum= sum;\n                }\n            }while(nextIndices(array));\n        }\n        System.out.println(\"Sum: \" + highSum + \"\\nSet: \" + \n        \t\thighSet);\n    }\n    \n\n    private static boolean nextIndices(ArrayList<Long> a) {\n        for(int i= indices.length-1;i >= 0;--i){\n            indices[i]++;\n            for(int j=i+1;j < indices.length;++j){\n                indices[j]= indices[j - 1] + 1;\n            }\n            if(indices[indices.length - 1] < a.size()){\n                return true;\n            }\n        }\n        return false;\n    }\n}\n"}
{"id": 62266, "name": "Greatest subsequential sum", "source": "Translate Ruby to Python: def subarray_sum(arr)\n  max, slice = 0, [] of Int32\n  arr.each_index do |i|\n    (i...arr.size).each do |j|\n      sum = arr[i..j].sum\n      max, slice = sum, arr[i..j] if sum > max\n    end\n  end\n  [max, slice]\nend\n", "target": "def maxsubseq(seq):\n  return max((seq[begin:end] for begin in xrange(len(seq)+1)\n                             for end in xrange(begin, len(seq)+1)),\n             key=sum)\n"}
{"id": 62267, "name": "Greatest subsequential sum", "source": "Translate Ruby to Python: def subarray_sum(arr)\n  max, slice = 0, [] of Int32\n  arr.each_index do |i|\n    (i...arr.size).each do |j|\n      sum = arr[i..j].sum\n      max, slice = sum, arr[i..j] if sum > max\n    end\n  end\n  [max, slice]\nend\n", "target": "def maxsubseq(seq):\n  return max((seq[begin:end] for begin in xrange(len(seq)+1)\n                             for end in xrange(begin, len(seq)+1)),\n             key=sum)\n"}
{"id": 62798, "name": "Integer sequence", "source": "Translate Ruby to C#: require \"big\"\n\n(1.to_big_i ..).each { |i| puts i }\n", "target": "using System;\nusing System.Numerics;\n\nclass Program\n{\n    static void Main()\n    {\n        BigInteger i = 1;\n        while (true)\n        {\n            Console.WriteLine(i++);\n        }\n    }\n}\n"}
{"id": 62799, "name": "Integer sequence", "source": "Translate Ruby to C#: require \"big\"\n\n(1.to_big_i ..).each { |i| puts i }\n", "target": "using System;\nusing System.Numerics;\n\nclass Program\n{\n    static void Main()\n    {\n        BigInteger i = 1;\n        while (true)\n        {\n            Console.WriteLine(i++);\n        }\n    }\n}\n"}
{"id": 62802, "name": "Integer sequence", "source": "Translate Ruby to Java: require \"big\"\n\n(1.to_big_i ..).each { |i| puts i }\n", "target": "public class Count{\n    public static void main(String[] args){\n        for(long i = 1; ;i++) System.out.println(i);\n    }\n}\n"}
{"id": 62803, "name": "Integer sequence", "source": "Translate Ruby to Python: require \"big\"\n\n(1.to_big_i ..).each { |i| puts i }\n", "target": "i=1\nwhile i:\n    print(i)\n    i += 1\n"}
{"id": 62804, "name": "Integer sequence", "source": "Translate Ruby to Python: require \"big\"\n\n(1.to_big_i ..).each { |i| puts i }\n", "target": "i=1\nwhile i:\n    print(i)\n    i += 1\n"}
{"id": 63075, "name": "Fibonacci sequence", "source": "Translate Ruby to C#: def fib(n)\n  n < 2 ? n : fib(n - 1) + fib(n - 2)\nend\n", "target": "public static ulong Fib(uint n) {\n    return (n < 2)? n : Fib(n - 1) + Fib(n - 2);\n}\n"}
{"id": 63077, "name": "Fibonacci sequence", "source": "Translate Ruby to Python: def fib(n)\n  n < 2 ? n : fib(n - 1) + fib(n - 2)\nend\n", "target": "from math import *\n\ndef analytic_fibonacci(n):\n  sqrt_5 = sqrt(5);\n  p = (1 + sqrt_5) / 2;\n  q = 1/p;\n  return int( (p**n + q**n) / sqrt_5 + 0.5 )\n\nfor i in range(1,31):\n  print analytic_fibonacci(i),\n"}
{"id": 63355, "name": "Averages_Arithmetic mean", "source": "Translate Ruby to C#: \ndef mean(arr) : Float64\n  arr.sum / arr.size.to_f\nend\n", "target": "using System;\nusing System.Linq;\n\nclass Program\n{\n    static void Main()\n    {\n        Console.WriteLine(new[] { 1, 2, 3 }.Average());\n    }\n}\n"}
{"id": 63357, "name": "Averages_Arithmetic mean", "source": "Translate Ruby to Java: \ndef mean(arr) : Float64\n  arr.sum / arr.size.to_f\nend\n", "target": "public static double avg(double... arr) {\n    double sum = 0.0;\n    for (double x : arr) {\n        sum += x;\n    }\n    return sum / arr.length;\n}\n"}
{"id": 63358, "name": "Averages_Arithmetic mean", "source": "Translate Ruby to Python: \ndef mean(arr) : Float64\n  arr.sum / arr.size.to_f\nend\n", "target": "from math import fsum\ndef average(x):\n    return fsum(x)/float(len(x)) if x else 0\nprint (average([0,0,3,1,4,1,5,9,0,0]))\nprint (average([1e20,-1e-20,3,1,4,1,5,9,-1e20,1e-20]))\n"}
{"id": 63610, "name": "Spiral matrix", "source": "Translate Ruby to C#: def spiral(n)\n  spiral = Array.new(n) {Array.new(n, nil)}     \n  runs = n.downto(0).each_cons(2).to_a.flatten  \n  delta = [[1,0], [0,1], [-1,0], [0,-1]].cycle\n  x, y, value = -1, 0, -1\n  for run in runs\n    dx, dy = delta.next\n    run.times { spiral[y+=dy][x+=dx] = (value+=1) }\n  end\n  spiral\nend\n\ndef print_matrix(m)\n  width = m.flatten.map{|x| x.to_s.size}.max\n  m.each {|row| puts row.map {|x| \"%\nend\n\nprint_matrix spiral(5)\n", "target": "public int[,] Spiral(int n) {\n    int[,] result = new int[n, n];\n\n    int pos = 0;\n    int count = n;\n    int value = -n;\n    int sum = -1;\n\n    do {\n        value = -1 * value / n;\n        for (int i = 0; i < count; i++) {\n            sum += value;\n            result[sum / n, sum % n] = pos++;\n        }\n        value *= n;\n        count--;\n        for (int i = 0; i < count; i++) {\n            sum += value;\n            result[sum / n, sum % n] = pos++;\n        }\n    } while (count > 0);\n\n    return result;\n}\n\n\n\npublic void PrintArray(int[,] array) {\n    int n = (array.GetLength(0) * array.GetLength(1) - 1).ToString().Length + 1;\n\n    for (int i = 0; i < array.GetLength(0); i++) {\n        for (int j = 0; j < array.GetLength(1); j++) {\n            Console.Write(array[i, j].ToString().PadLeft(n, ' '));\n        }\n        Console.WriteLine();\n    }\n}\n"}
{"id": 63612, "name": "Spiral matrix", "source": "Translate Ruby to Java: def spiral(n)\n  spiral = Array.new(n) {Array.new(n, nil)}     \n  runs = n.downto(0).each_cons(2).to_a.flatten  \n  delta = [[1,0], [0,1], [-1,0], [0,-1]].cycle\n  x, y, value = -1, 0, -1\n  for run in runs\n    dx, dy = delta.next\n    run.times { spiral[y+=dy][x+=dx] = (value+=1) }\n  end\n  spiral\nend\n\ndef print_matrix(m)\n  width = m.flatten.map{|x| x.to_s.size}.max\n  m.each {|row| puts row.map {|x| \"%\nend\n\nprint_matrix spiral(5)\n", "target": "public class Blah {\n\n  public static void main(String[] args) {\n    print2dArray(getSpiralArray(5));\n  }\n\n  public static int[][] getSpiralArray(int dimension) {\n    int[][] spiralArray = new int[dimension][dimension];\n\n    int numConcentricSquares = (int) Math.ceil((dimension) / 2.0);\n\n    int j;\n    int sideLen = dimension;\n    int currNum = 0;\n\n    for (int i = 0; i < numConcentricSquares; i++) {\n      \n      for (j = 0; j < sideLen; j++) {\n        spiralArray[i][i + j] = currNum++;\n      }\n\n      \n      for (j = 1; j < sideLen; j++) {\n        spiralArray[i + j][dimension - 1 - i] = currNum++;\n      }\n\n      \n      for (j = sideLen - 2; j > -1; j--) {\n        spiralArray[dimension - 1 - i][i + j] = currNum++;\n      }\n\n      \n      for (j = sideLen - 2; j > 0; j--) {\n        spiralArray[i + j][i] = currNum++;\n      }\n\n      sideLen -= 2;\n    }\n\n    return spiralArray;\n  }\n\n  public static void print2dArray(int[][] array) {\n    for (int[] row : array) {\n      for (int elem : row) {\n        System.out.printf(\"%3d\", elem);\n      }\n      System.out.println();\n    }\n  }\n}\n"}
{"id": 63613, "name": "Spiral matrix", "source": "Translate Ruby to Python: def spiral(n)\n  spiral = Array.new(n) {Array.new(n, nil)}     \n  runs = n.downto(0).each_cons(2).to_a.flatten  \n  delta = [[1,0], [0,1], [-1,0], [0,-1]].cycle\n  x, y, value = -1, 0, -1\n  for run in runs\n    dx, dy = delta.next\n    run.times { spiral[y+=dy][x+=dx] = (value+=1) }\n  end\n  spiral\nend\n\ndef print_matrix(m)\n  width = m.flatten.map{|x| x.to_s.size}.max\n  m.each {|row| puts row.map {|x| \"%\nend\n\nprint_matrix spiral(5)\n", "target": "def spiral(n):\n    dx,dy = 1,0            \n    x,y = 0,0              \n    myarray = [[None]* n for j in range(n)]\n    for i in xrange(n**2):\n        myarray[x][y] = i\n        nx,ny = x+dx, y+dy\n        if 0<=nx<n and 0<=ny<n and myarray[nx][ny] == None:\n            x,y = nx,ny\n        else:\n            dx,dy = -dy,dx\n            x,y = x+dx, y+dy\n    return myarray\n\ndef printspiral(myarray):\n    n = range(len(myarray))\n    for y in n:\n        for x in n:\n            print \"%2i\" % myarray[x][y],\n        print\n\nprintspiral(spiral(5))\n"}
{"id": 63799, "name": "Sort an array of composite structures", "source": "Translate Ruby to C#: Person = Struct.new(:name,:value) do\n  def to_s; \"name:\nend\n\nlist = [Person.new(\"Joe\",3),\n        Person.new(\"Bill\",4),\n        Person.new(\"Alice\",20),\n        Person.new(\"Harry\",3)]\nputs list.sort_by{|x|x.name}\nputs\nputs list.sort_by(&:value)\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\nclass Program\n{        \n    struct Entry\n    {\n        public Entry(string name, double value) { Name = name; Value = value; }\n        public string Name;\n        public double Value;\n    }\n\n    static void Main(string[] args)\n    {\n        var Elements = new List<Entry>\n        {\n            new Entry(\"Krypton\", 83.798), new Entry(\"Beryllium\", 9.012182), new Entry(\"Silicon\", 28.0855),\n            new Entry(\"Cobalt\", 58.933195), new Entry(\"Selenium\", 78.96), new Entry(\"Germanium\", 72.64)\n        };\n\n        var sortedElements = Elements.OrderBy(e => e.Name);\n\n        foreach (Entry e in sortedElements)\n            Console.WriteLine(\"{0,-11}{1}\", e.Name, e.Value);\n    }\n}\n"}
{"id": 63801, "name": "Sort an array of composite structures", "source": "Translate Ruby to Java: Person = Struct.new(:name,:value) do\n  def to_s; \"name:\nend\n\nlist = [Person.new(\"Joe\",3),\n        Person.new(\"Bill\",4),\n        Person.new(\"Alice\",20),\n        Person.new(\"Harry\",3)]\nputs list.sort_by{|x|x.name}\nputs\nputs list.sort_by(&:value)\n", "target": "import java.util.Arrays;\nimport java.util.Comparator;\n\npublic class SortComp {\n    public static class Pair {\n        public String name;\n        public String value;\n        public Pair(String n, String v) {\n            name = n;\n            value = v;\n        }\n    }\n\n    public static void main(String[] args) {\n        Pair[] pairs = {new Pair(\"06-07\", \"Ducks\"), new Pair(\"00-01\", \"Avalanche\"),\n            new Pair(\"02-03\", \"Devils\"), new Pair(\"01-02\", \"Red Wings\"),\n            new Pair(\"03-04\", \"Lightning\"), new Pair(\"04-05\", \"lockout\"),\n            new Pair(\"05-06\", \"Hurricanes\"), new Pair(\"99-00\", \"Devils\"),\n            new Pair(\"07-08\", \"Red Wings\"), new Pair(\"08-09\", \"Penguins\")};\n\n        sortByName(pairs);\n        for (Pair p : pairs) {\n            System.out.println(p.name + \" \" + p.value);\n        }\n    }\n\n    public static void sortByName(Pair[] pairs) {\n        Arrays.sort(pairs, new Comparator<Pair>() {\n            public int compare(Pair p1, Pair p2) {\n                return p1.name.compareTo(p2.name);\n            }\n        });\n    }\n}\n"}
{"id": 63802, "name": "Sort an array of composite structures", "source": "Translate Ruby to Python: Person = Struct.new(:name,:value) do\n  def to_s; \"name:\nend\n\nlist = [Person.new(\"Joe\",3),\n        Person.new(\"Bill\",4),\n        Person.new(\"Alice\",20),\n        Person.new(\"Harry\",3)]\nputs list.sort_by{|x|x.name}\nputs\nputs list.sort_by(&:value)\n", "target": "people = [('joe', 120), ('foo', 31), ('bar', 51)]\nsorted(people)\n"}
{"id": 63933, "name": "Terminal control_Display an extended character", "source": "Translate Ruby to Java: \nputs \"\u00a3\"\n", "target": "import java.io.PrintStream;\nimport java.io.UnsupportedEncodingException;\n\npublic class Main\n{\n    public static void main(String[] args) throws UnsupportedEncodingException\n    {\n        PrintStream writer = new PrintStream(System.out, true, \"UTF-8\");\n        writer.println(\"\u00a3\");\n        writer.println(\"\u672d\u5e4c\");\n    }\n}\n"}
{"id": 64182, "name": "Julia set", "source": "Translate Ruby to C#: require \"complex\"\n\ndef julia(c_real, c_imag)\n  puts Complex.new(c_real, c_imag)\n  -1.0.step(to: 1.0, by: 0.04) do |v|\n    puts -1.4.step(to: 1.4, by: 0.02).map{|h| judge(c_real, c_imag, h, v)}.join\n  end\nend\n \ndef judge(c_real, c_imag, x, y)\n  50.times do\n    z_real = (x * x - y * y) + c_real\n    z_imag = x * y * 2 + c_imag\n    return \" \"  if z_real**2 > 10000\n    x, y = z_real, z_imag\n  end\n  \"\nend\n \njulia(-0.8, 0.156)\n", "target": "using System.Drawing;\n\n\n\nusing System.Linq;\n\nnamespace RosettaJuliaSet\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            const int w = 800;\n            const int h = 600;\n            const int zoom = 1;\n            const int maxiter = 255;\n            const int moveX = 0;\n            const int moveY = 0;\n            const double cX = -0.7;\n            const double cY = 0.27015;\n            double zx, zy, tmp;\n            int i;\n\n            var colors = (from c in Enumerable.Range(0, 256)\n                          select Color.FromArgb((c >> 5) * 36, (c >> 3 & 7) * 36, (c & 3) * 85)).ToArray();\n\n            var bitmap = new Bitmap(w, h);\n            for (int x = 0; x < w; x++)\n            {\n                for (int y = 0; y < h; y++)\n                {\n                    zx = 1.5 * (x - w / 2) / (0.5 * zoom * w) + moveX;\n                    zy = 1.0 * (y - h / 2) / (0.5 * zoom * h) + moveY;\n                    i = maxiter;\n                    while (zx * zx + zy * zy < 4 && i > 1)\n                    {\n                        tmp = zx * zx - zy * zy + cX;\n                        zy = 2.0 * zx * zy + cY;\n                        zx = tmp;\n                        i -= 1;\n                    }\n                    bitmap.SetPixel(x, y, colors[i]);\n                }\n            }\n            bitmap.Save(\"julia-set.png\");\n        }\n    }\n}\n"}
{"id": 64183, "name": "Julia set", "source": "Translate Ruby to C#: require \"complex\"\n\ndef julia(c_real, c_imag)\n  puts Complex.new(c_real, c_imag)\n  -1.0.step(to: 1.0, by: 0.04) do |v|\n    puts -1.4.step(to: 1.4, by: 0.02).map{|h| judge(c_real, c_imag, h, v)}.join\n  end\nend\n \ndef judge(c_real, c_imag, x, y)\n  50.times do\n    z_real = (x * x - y * y) + c_real\n    z_imag = x * y * 2 + c_imag\n    return \" \"  if z_real**2 > 10000\n    x, y = z_real, z_imag\n  end\n  \"\nend\n \njulia(-0.8, 0.156)\n", "target": "using System.Drawing;\n\n\n\nusing System.Linq;\n\nnamespace RosettaJuliaSet\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            const int w = 800;\n            const int h = 600;\n            const int zoom = 1;\n            const int maxiter = 255;\n            const int moveX = 0;\n            const int moveY = 0;\n            const double cX = -0.7;\n            const double cY = 0.27015;\n            double zx, zy, tmp;\n            int i;\n\n            var colors = (from c in Enumerable.Range(0, 256)\n                          select Color.FromArgb((c >> 5) * 36, (c >> 3 & 7) * 36, (c & 3) * 85)).ToArray();\n\n            var bitmap = new Bitmap(w, h);\n            for (int x = 0; x < w; x++)\n            {\n                for (int y = 0; y < h; y++)\n                {\n                    zx = 1.5 * (x - w / 2) / (0.5 * zoom * w) + moveX;\n                    zy = 1.0 * (y - h / 2) / (0.5 * zoom * h) + moveY;\n                    i = maxiter;\n                    while (zx * zx + zy * zy < 4 && i > 1)\n                    {\n                        tmp = zx * zx - zy * zy + cX;\n                        zy = 2.0 * zx * zy + cY;\n                        zx = tmp;\n                        i -= 1;\n                    }\n                    bitmap.SetPixel(x, y, colors[i]);\n                }\n            }\n            bitmap.Save(\"julia-set.png\");\n        }\n    }\n}\n"}
{"id": 64186, "name": "Julia set", "source": "Translate Ruby to Java: require \"complex\"\n\ndef julia(c_real, c_imag)\n  puts Complex.new(c_real, c_imag)\n  -1.0.step(to: 1.0, by: 0.04) do |v|\n    puts -1.4.step(to: 1.4, by: 0.02).map{|h| judge(c_real, c_imag, h, v)}.join\n  end\nend\n \ndef judge(c_real, c_imag, x, y)\n  50.times do\n    z_real = (x * x - y * y) + c_real\n    z_imag = x * y * 2 + c_imag\n    return \" \"  if z_real**2 > 10000\n    x, y = z_real, z_imag\n  end\n  \"\nend\n \njulia(-0.8, 0.156)\n", "target": "import javax.swing.*;\nimport java.awt.*;\nimport java.awt.image.BufferedImage;\n\npublic class JuliaSet extends JPanel {\n    private static final int MAX_ITERATIONS = 300;\n    private static final double ZOOM = 1;\n    private static final double CX = -0.7;\n    private static final double CY = 0.27015;\n    private static final double MOVE_X = 0;\n    private static final double MOVE_Y = 0;\n\n    public JuliaSet() {\n        setPreferredSize(new Dimension(800, 600));\n        setBackground(Color.white);\n    }\n\n    void drawJuliaSet(Graphics2D g) {\n        int w = getWidth();\n        int h = getHeight();\n        BufferedImage image = new BufferedImage(w, h, BufferedImage.TYPE_INT_RGB);\n\n        for (int x = 0; x < w; x++) {\n            for (int y = 0; y < h; y++) {\n                double zx = 1.5 * (x - w / 2) / (0.5 * ZOOM * w) + MOVE_X;\n                double zy = (y - h / 2) / (0.5 * ZOOM * h) + MOVE_Y;\n                float i = MAX_ITERATIONS;\n                while (zx * zx + zy * zy < 4 && i > 0) {\n                    double tmp = zx * zx - zy * zy + CX;\n                    zy = 2.0 * zx * zy + CY;\n                    zx = tmp;\n                    i--;\n                }\n                int c = Color.HSBtoRGB((MAX_ITERATIONS / i) % 1, 1, i > 0 ? 1 : 0);\n                image.setRGB(x, y, c);\n            }\n        }\n        g.drawImage(image, 0, 0, null);\n    }\n\n    @Override\n    public void paintComponent(Graphics gg) {\n        super.paintComponent(gg);\n        Graphics2D g = (Graphics2D) gg;\n        g.setRenderingHint(RenderingHints.KEY_ANTIALIASING,\n                RenderingHints.VALUE_ANTIALIAS_ON);\n        drawJuliaSet(g);\n    }\n\n    public static void main(String[] args) {\n        SwingUtilities.invokeLater(() -> {\n            JFrame f = new JFrame();\n            f.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n            f.setTitle(\"Julia Set\");\n            f.setResizable(false);\n            f.add(new JuliaSet(), BorderLayout.CENTER);\n            f.pack();\n            f.setLocationRelativeTo(null);\n            f.setVisible(true);\n        });\n    }\n}\n"}
{"id": 64187, "name": "Julia set", "source": "Translate Ruby to Java: require \"complex\"\n\ndef julia(c_real, c_imag)\n  puts Complex.new(c_real, c_imag)\n  -1.0.step(to: 1.0, by: 0.04) do |v|\n    puts -1.4.step(to: 1.4, by: 0.02).map{|h| judge(c_real, c_imag, h, v)}.join\n  end\nend\n \ndef judge(c_real, c_imag, x, y)\n  50.times do\n    z_real = (x * x - y * y) + c_real\n    z_imag = x * y * 2 + c_imag\n    return \" \"  if z_real**2 > 10000\n    x, y = z_real, z_imag\n  end\n  \"\nend\n \njulia(-0.8, 0.156)\n", "target": "import javax.swing.*;\nimport java.awt.*;\nimport java.awt.image.BufferedImage;\n\npublic class JuliaSet extends JPanel {\n    private static final int MAX_ITERATIONS = 300;\n    private static final double ZOOM = 1;\n    private static final double CX = -0.7;\n    private static final double CY = 0.27015;\n    private static final double MOVE_X = 0;\n    private static final double MOVE_Y = 0;\n\n    public JuliaSet() {\n        setPreferredSize(new Dimension(800, 600));\n        setBackground(Color.white);\n    }\n\n    void drawJuliaSet(Graphics2D g) {\n        int w = getWidth();\n        int h = getHeight();\n        BufferedImage image = new BufferedImage(w, h, BufferedImage.TYPE_INT_RGB);\n\n        for (int x = 0; x < w; x++) {\n            for (int y = 0; y < h; y++) {\n                double zx = 1.5 * (x - w / 2) / (0.5 * ZOOM * w) + MOVE_X;\n                double zy = (y - h / 2) / (0.5 * ZOOM * h) + MOVE_Y;\n                float i = MAX_ITERATIONS;\n                while (zx * zx + zy * zy < 4 && i > 0) {\n                    double tmp = zx * zx - zy * zy + CX;\n                    zy = 2.0 * zx * zy + CY;\n                    zx = tmp;\n                    i--;\n                }\n                int c = Color.HSBtoRGB((MAX_ITERATIONS / i) % 1, 1, i > 0 ? 1 : 0);\n                image.setRGB(x, y, c);\n            }\n        }\n        g.drawImage(image, 0, 0, null);\n    }\n\n    @Override\n    public void paintComponent(Graphics gg) {\n        super.paintComponent(gg);\n        Graphics2D g = (Graphics2D) gg;\n        g.setRenderingHint(RenderingHints.KEY_ANTIALIASING,\n                RenderingHints.VALUE_ANTIALIAS_ON);\n        drawJuliaSet(g);\n    }\n\n    public static void main(String[] args) {\n        SwingUtilities.invokeLater(() -> {\n            JFrame f = new JFrame();\n            f.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n            f.setTitle(\"Julia Set\");\n            f.setResizable(false);\n            f.add(new JuliaSet(), BorderLayout.CENTER);\n            f.pack();\n            f.setLocationRelativeTo(null);\n            f.setVisible(true);\n        });\n    }\n}\n"}
{"id": 64188, "name": "Julia set", "source": "Translate Ruby to Python: require \"complex\"\n\ndef julia(c_real, c_imag)\n  puts Complex.new(c_real, c_imag)\n  -1.0.step(to: 1.0, by: 0.04) do |v|\n    puts -1.4.step(to: 1.4, by: 0.02).map{|h| judge(c_real, c_imag, h, v)}.join\n  end\nend\n \ndef judge(c_real, c_imag, x, y)\n  50.times do\n    z_real = (x * x - y * y) + c_real\n    z_imag = x * y * 2 + c_imag\n    return \" \"  if z_real**2 > 10000\n    x, y = z_real, z_imag\n  end\n  \"\nend\n \njulia(-0.8, 0.156)\n", "target": "from __future__ import division\n\ncX = -0.7\ncY = 0.27015\nmaxIter = 300\n\ndef setup():\n    size(640, 480)\n\ndef draw():\n    for x in range(width):\n        for y in range(height):\n            zx = 1.5 * (x - width / 2) / (0.5 * width)\n            zy = (y - height / 2) / (0.5 * height)\n            i = maxIter\n            while zx * zx + zy * zy < 4 and i > 0:\n                tmp = zx * zx - zy * zy + cX\n                zy = 2.0 * zx * zy + cY\n                zx = tmp\n                i -= 1\n            colorMode(HSB)\n            c = color(i / maxIter * 255, 255, 255 if i > 1 else 0)\n            set(x, y, c)\n"}
{"id": 64189, "name": "Julia set", "source": "Translate Ruby to Python: require \"complex\"\n\ndef julia(c_real, c_imag)\n  puts Complex.new(c_real, c_imag)\n  -1.0.step(to: 1.0, by: 0.04) do |v|\n    puts -1.4.step(to: 1.4, by: 0.02).map{|h| judge(c_real, c_imag, h, v)}.join\n  end\nend\n \ndef judge(c_real, c_imag, x, y)\n  50.times do\n    z_real = (x * x - y * y) + c_real\n    z_imag = x * y * 2 + c_imag\n    return \" \"  if z_real**2 > 10000\n    x, y = z_real, z_imag\n  end\n  \"\nend\n \njulia(-0.8, 0.156)\n", "target": "from __future__ import division\n\ncX = -0.7\ncY = 0.27015\nmaxIter = 300\n\ndef setup():\n    size(640, 480)\n\ndef draw():\n    for x in range(width):\n        for y in range(height):\n            zx = 1.5 * (x - width / 2) / (0.5 * width)\n            zy = (y - height / 2) / (0.5 * height)\n            i = maxIter\n            while zx * zx + zy * zy < 4 and i > 0:\n                tmp = zx * zx - zy * zy + cX\n                zy = 2.0 * zx * zy + cY\n                zx = tmp\n                i -= 1\n            colorMode(HSB)\n            c = color(i / maxIter * 255, 255, 255 if i > 1 else 0)\n            set(x, y, c)\n"}
{"id": 64624, "name": "Calculating the value of e", "source": "Translate Ruby to C#: fact = 1\ne = 2\ne0 = 0\nn = 2\n\nuntil (e - e0).abs < Float::EPSILON do\n  e0 = e\n  fact *= n\n  n += 1\n  e += 1.0 / fact\nend\n\nputs e\n", "target": "using System;\n\nnamespace CalculateE {\n    class Program {\n        public const double EPSILON = 1.0e-15;\n\n        static void Main(string[] args) {\n            ulong fact = 1;\n            double e = 2.0;\n            double e0;\n            uint n = 2;\n            do {\n                e0 = e;\n                fact *= n++;\n                e += 1.0 / fact;\n            } while (Math.Abs(e - e0) >= EPSILON);\n            Console.WriteLine(\"e = {0:F15}\", e);\n        }\n    }\n}\n"}
{"id": 64625, "name": "Calculating the value of e", "source": "Translate Ruby to C#: fact = 1\ne = 2\ne0 = 0\nn = 2\n\nuntil (e - e0).abs < Float::EPSILON do\n  e0 = e\n  fact *= n\n  n += 1\n  e += 1.0 / fact\nend\n\nputs e\n", "target": "using System;\n\nnamespace CalculateE {\n    class Program {\n        public const double EPSILON = 1.0e-15;\n\n        static void Main(string[] args) {\n            ulong fact = 1;\n            double e = 2.0;\n            double e0;\n            uint n = 2;\n            do {\n                e0 = e;\n                fact *= n++;\n                e += 1.0 / fact;\n            } while (Math.Abs(e - e0) >= EPSILON);\n            Console.WriteLine(\"e = {0:F15}\", e);\n        }\n    }\n}\n"}
{"id": 64628, "name": "Calculating the value of e", "source": "Translate Ruby to Java: fact = 1\ne = 2\ne0 = 0\nn = 2\n\nuntil (e - e0).abs < Float::EPSILON do\n  e0 = e\n  fact *= n\n  n += 1\n  e += 1.0 / fact\nend\n\nputs e\n", "target": "public class CalculateE {\n    public static final double EPSILON = 1.0e-15;\n\n    public static void main(String[] args) {\n        long fact = 1;\n        double e = 2.0;\n        int n = 2;\n        double e0;\n        do {\n            e0 = e;\n            fact *= n++;\n            e += 1.0 / fact;\n        } while (Math.abs(e - e0) >= EPSILON);\n        System.out.printf(\"e =\u00a0%.15f\\n\", e);\n    }\n}\n"}
{"id": 64629, "name": "Calculating the value of e", "source": "Translate Ruby to Python: fact = 1\ne = 2\ne0 = 0\nn = 2\n\nuntil (e - e0).abs < Float::EPSILON do\n  e0 = e\n  fact *= n\n  n += 1\n  e += 1.0 / fact\nend\n\nputs e\n", "target": "import math\n\ne0 = 0\ne = 2\nn = 0\nfact = 1\nwhile(e-e0 > 1e-15):\n\te0 = e\n\tn += 1\n\tfact *= 2*n*(2*n+1)\n\te += (2.*n+2)/fact\n\nprint \"Computed e = \"+str(e)\nprint \"Real e = \"+str(math.e)\nprint \"Error = \"+str(math.e-e)\nprint \"Number of iterations = \"+str(n)\n"}
{"id": 64630, "name": "Calculating the value of e", "source": "Translate Ruby to Python: fact = 1\ne = 2\ne0 = 0\nn = 2\n\nuntil (e - e0).abs < Float::EPSILON do\n  e0 = e\n  fact *= n\n  n += 1\n  e += 1.0 / fact\nend\n\nputs e\n", "target": "import math\n\ne0 = 0\ne = 2\nn = 0\nfact = 1\nwhile(e-e0 > 1e-15):\n\te0 = e\n\tn += 1\n\tfact *= 2*n*(2*n+1)\n\te += (2.*n+2)/fact\n\nprint \"Computed e = \"+str(e)\nprint \"Real e = \"+str(math.e)\nprint \"Error = \"+str(math.e-e)\nprint \"Number of iterations = \"+str(n)\n"}
{"id": 64845, "name": "Exceptions_Catch an exception thrown in a nested call", "source": "Translate Ruby to C#: class U0 < Exception\nend\n\nclass U1 < Exception\nend\n\ndef foo\n  2.times do |i|\n    begin\n      bar(i)\n    rescue e : U0\n      puts \"rescued \n    end\n  end\nend\n\ndef bar(i : Int32)\n    baz(i)\nend\n\ndef baz(i : Int32)\n  raise U0.new(\"this is u0\") if i == 0\n    raise U1.new(\"this is u1\") if i == 1\nend\n\nfoo\n", "target": "using System; \nclass Exceptions\n{\n  class U0 : Exception { }\n  class U1 : Exception { }\n  static int i;\n  static void foo()\n  {\n    for (i = 0; i < 2; i++)\n      try\n      {\n        bar();\n      }\n      catch (U0) {\n        Console.WriteLine(\"U0 Caught\");\n      }\n  }\n  static void bar()\n  {\n    baz();\n  }\n  static void baz(){\n    if (i == 0)\n      throw new U0();\n    throw new U1();\n  }\n\n  public static void Main()\n  {\n    foo();\n  }\n}\n"}
{"id": 64847, "name": "Exceptions_Catch an exception thrown in a nested call", "source": "Translate Ruby to Java: class U0 < Exception\nend\n\nclass U1 < Exception\nend\n\ndef foo\n  2.times do |i|\n    begin\n      bar(i)\n    rescue e : U0\n      puts \"rescued \n    end\n  end\nend\n\ndef bar(i : Int32)\n    baz(i)\nend\n\ndef baz(i : Int32)\n  raise U0.new(\"this is u0\") if i == 0\n    raise U1.new(\"this is u1\") if i == 1\nend\n\nfoo\n", "target": "class U0 extends Exception { }\nclass U1 extends Exception { }\n\npublic class ExceptionsTest {\n    public static void foo() throws U1 {\n        for (int i = 0; i <= 1; i++) {\n            try {\n                bar(i);\n            } catch (U0 e) {\n                System.out.println(\"Function foo caught exception U0\");\n            }\n        }\n    }\n\n    public static void bar(int i) throws U0, U1 {\n        baz(i); \n    }\n\n    public static void baz(int i) throws U0, U1 {\n        if (i == 0)\n            throw new U0();\n        else\n            throw new U1();\n    }\n\n    public static void main(String[] args) throws U1 {\n        foo();\n    }\n}\n"}
{"id": 64848, "name": "Exceptions_Catch an exception thrown in a nested call", "source": "Translate Ruby to Python: class U0 < Exception\nend\n\nclass U1 < Exception\nend\n\ndef foo\n  2.times do |i|\n    begin\n      bar(i)\n    rescue e : U0\n      puts \"rescued \n    end\n  end\nend\n\ndef bar(i : Int32)\n    baz(i)\nend\n\ndef baz(i : Int32)\n  raise U0.new(\"this is u0\") if i == 0\n    raise U1.new(\"this is u1\") if i == 1\nend\n\nfoo\n", "target": "class U0(Exception): pass\nclass U1(Exception): pass\n\ndef foo():\n    for i in range(2):\n        try:\n            bar(i)\n        except U0:\n            print(\"Function foo caught exception U0\")\n\ndef bar(i):\n    baz(i) \n\ndef baz(i):\n    raise U1 if i else U0\n\nfoo()\n"}
{"id": 65064, "name": "Symmetric difference", "source": "Translate Ruby to C#: a = [\"John\", \"Serena\", \"Bob\", \"Mary\", \"Serena\"]\nb = [\"Jim\", \"Mary\", \"John\", \"Jim\", \"Bob\"]\n\np sym_diff = (a | b)-(a & b)  \n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\nnamespace RosettaCode.SymmetricDifference\n{\n    public static class IEnumerableExtension\n    {\n        public static IEnumerable<T> SymmetricDifference<T>(this IEnumerable<T> @this, IEnumerable<T> that)\n        {\n            return @this.Except(that).Concat(that.Except(@this));\n        }\n    }\n\n    class Program\n    {\n        static void Main()\n        {\n            var a = new[] { \"John\", \"Bob\", \"Mary\", \"Serena\" };\n            var b = new[] { \"Jim\", \"Mary\", \"John\", \"Bob\" };\n\n            foreach (var element in a.SymmetricDifference(b))\n            {\n                Console.WriteLine(element);\n            }\n        }\n    }\n}\n"}
{"id": 65066, "name": "Symmetric difference", "source": "Translate Ruby to Java: a = [\"John\", \"Serena\", \"Bob\", \"Mary\", \"Serena\"]\nb = [\"Jim\", \"Mary\", \"John\", \"Jim\", \"Bob\"]\n\np sym_diff = (a | b)-(a & b)  \n", "target": "Set<String> setA = new Set<String>{'John', 'Bob', 'Mary', 'Serena'};\nSet<String> setB = new Set<String>{'Jim', 'Mary', 'John', 'Bob'};\n\n\nSet<String> notInSetA = setB.clone();\nnotInSetA.removeAll(setA);\n\nSet<String> notInSetB = setA.clone();\nnotInSetB.removeAll(setB);\n\nSet<String> symmetricDifference = new Set<String>();\nsymmetricDifference.addAll(notInSetA);\nsymmetricDifference.addAll(notInSetB);\n\n\nSet<String> union = setA.clone();\nunion.addAll(setB);\n\nSet<String> intersection = setA.clone();\nintersection.retainAll(setB);\n\nSet<String> symmetricDifference2 = union.clone();\nsymmetricDifference2.removeAll(intersection);\n\nSystem.debug('Not in set A: ' + notInSetA);\nSystem.debug('Not in set B: ' + notInSetB);\nSystem.debug('Symmetric Difference: ' + symmetricDifference);\nSystem.debug('Symmetric Difference 2: ' + symmetricDifference2);\n"}
{"id": 65067, "name": "Symmetric difference", "source": "Translate Ruby to Python: a = [\"John\", \"Serena\", \"Bob\", \"Mary\", \"Serena\"]\nb = [\"Jim\", \"Mary\", \"John\", \"Jim\", \"Bob\"]\n\np sym_diff = (a | b)-(a & b)  \n", "target": ">>> setA = {\"John\", \"Bob\", \"Mary\", \"Serena\"}\n>>> setB = {\"Jim\", \"Mary\", \"John\", \"Bob\"}\n>>> setA ^ setB \n{'Jim', 'Serena'}\n>>> setA - setB \n{'Serena'}\n>>> setB - setA \n{'Jim'}\n>>> setA | setB \n{'John', 'Bob', 'Jim', 'Serena', 'Mary'}\n>>> setA & setB \n{'Bob', 'John', 'Mary'}\n"}
{"id": 65275, "name": "Inheritance_Single", "source": "Translate Ruby to C#: class Animal\n  \n  def self.inherited(subclass)\n    puts \"new subclass of \n  end\nend\n\nclass Dog < Animal\n  \nend\n\nclass Cat < Animal\n  \nend\n\nclass Lab < Dog\n  \nend\n\nclass Collie < Dog\n  \nend\n", "target": "class Animal\n{ \n   \n  \n}\n\nclass Dog : Animal\n{ \n   \n  \n}\n\nclass Lab : Dog\n{ \n   \n  \n}\n\nclass Collie : Dog\n{ \n  \n  \n}\n\nclass Cat : Animal\n{ \n  \n  \n}\n"}
{"id": 65277, "name": "Inheritance_Single", "source": "Translate Ruby to Java: class Animal\n  \n  def self.inherited(subclass)\n    puts \"new subclass of \n  end\nend\n\nclass Dog < Animal\n  \nend\n\nclass Cat < Animal\n  \nend\n\nclass Lab < Dog\n  \nend\n\nclass Collie < Dog\n  \nend\n", "target": "public class Animal{\n   \n}\n"}
{"id": 65278, "name": "Inheritance_Single", "source": "Translate Ruby to Python: class Animal\n  \n  def self.inherited(subclass)\n    puts \"new subclass of \n  end\nend\n\nclass Dog < Animal\n  \nend\n\nclass Cat < Animal\n  \nend\n\nclass Lab < Dog\n  \nend\n\nclass Collie < Dog\n  \nend\n", "target": "class Animal:\n  pass \n\nclass Dog(Animal):\n  pass \n\nclass Cat(Animal):\n  pass \n\nclass Lab(Dog):\n  pass \n\nclass Collie(Dog):\n  pass \n"}
{"id": 65537, "name": "Averages_Mode", "source": "Translate Ruby to C#: def mode(ary)\n  seen = Hash.new(0)\n  ary.each {|value| seen[value] += 1}\n  max = seen.values.max\n  seen.find_all {|key,value| value == max}.map {|key,value| key}\nend\n\ndef mode_one_pass(ary)\n  seen = Hash.new(0)\n  max = 0\n  max_elems = []\n  ary.each do |value|\n    seen[value] += 1\n    if seen[value] > max\n      max = seen[value]\n      max_elems = [value]\n    elsif seen[value] == max\n      max_elems << value\n    end\n  end\n  max_elems\nend\n\np mode([1, 3, 6, 6, 6, 6, 7, 7, 12, 12, 17])  \np mode([1, 1, 2, 4, 4]) \np mode_one_pass([1, 3, 6, 6, 6, 6, 7, 7, 12, 12, 17])  \np mode_one_pass([1, 1, 2, 4, 4]) \n", "target": "using System;\nusing System.Collections;\nusing System.Collections.Generic;\nusing System.Linq;\n\nnamespace Test\n{\n    class Program\n    {\n     \n        static void Main(string[] args)\n        {\n            \n            List<int> myList = new List<int>() { 1, 1, 2, 4, 4 }; \n\n            var query =     from numbers in myList \n                            group numbers by numbers \n                            into groupedNumbers\n                            select new { Number = groupedNumbers.Key, Count = groupedNumbers.Count() }; \n            \n            int max = query.Max(g => g.Count);\n            IEnumerable<int> modes = query.Where(x => x.Count == max).Select(x => x.Number);\n            foreach (var item in modes)\n            {\n                Console.WriteLine(item);\n            }\n            \n            Console.ReadLine();\n        }\n\n             \n       \n    }\n     \n    \n}\n"}
{"id": 65539, "name": "Averages_Mode", "source": "Translate Ruby to Java: def mode(ary)\n  seen = Hash.new(0)\n  ary.each {|value| seen[value] += 1}\n  max = seen.values.max\n  seen.find_all {|key,value| value == max}.map {|key,value| key}\nend\n\ndef mode_one_pass(ary)\n  seen = Hash.new(0)\n  max = 0\n  max_elems = []\n  ary.each do |value|\n    seen[value] += 1\n    if seen[value] > max\n      max = seen[value]\n      max_elems = [value]\n    elsif seen[value] == max\n      max_elems << value\n    end\n  end\n  max_elems\nend\n\np mode([1, 3, 6, 6, 6, 6, 7, 7, 12, 12, 17])  \np mode([1, 1, 2, 4, 4]) \np mode_one_pass([1, 3, 6, 6, 6, 6, 7, 7, 12, 12, 17])  \np mode_one_pass([1, 1, 2, 4, 4]) \n", "target": "import java.util.*;\n\npublic class Mode {\n    public static <T> List<T> mode(List<? extends T> coll) {\n        Map<T, Integer> seen = new HashMap<T, Integer>();\n        int max = 0;\n        List<T> maxElems = new ArrayList<T>();\n        for (T value : coll) {\n            if (seen.containsKey(value))\n                seen.put(value, seen.get(value) + 1);\n            else\n                seen.put(value, 1);\n            if (seen.get(value) > max) {\n                max = seen.get(value);\n                maxElems.clear();\n                maxElems.add(value);\n            } else if (seen.get(value) == max) {\n                maxElems.add(value);\n            }\n        }\n        return maxElems;\n    }\n\n    public static void main(String[] args) {\n        System.out.println(mode(Arrays.asList(1, 3, 6, 6, 6, 6, 7, 7, 12, 12, 17))); \n        System.out.println(mode(Arrays.asList(1, 1, 2, 4, 4))); \n    }\n}\n"}
{"id": 65540, "name": "Averages_Mode", "source": "Translate Ruby to Python: def mode(ary)\n  seen = Hash.new(0)\n  ary.each {|value| seen[value] += 1}\n  max = seen.values.max\n  seen.find_all {|key,value| value == max}.map {|key,value| key}\nend\n\ndef mode_one_pass(ary)\n  seen = Hash.new(0)\n  max = 0\n  max_elems = []\n  ary.each do |value|\n    seen[value] += 1\n    if seen[value] > max\n      max = seen[value]\n      max_elems = [value]\n    elsif seen[value] == max\n      max_elems << value\n    end\n  end\n  max_elems\nend\n\np mode([1, 3, 6, 6, 6, 6, 7, 7, 12, 12, 17])  \np mode([1, 1, 2, 4, 4]) \np mode_one_pass([1, 3, 6, 6, 6, 6, 7, 7, 12, 12, 17])  \np mode_one_pass([1, 1, 2, 4, 4]) \n", "target": ">>> from collections import defaultdict\n>>> def modes(values):\n\tcount = defaultdict(int)\n\tfor v in values:\n\t\tcount[v] +=1\n\tbest = max(count.values())\n\treturn [k for k,v in count.items() if v == best]\n\n>>> modes([1,3,6,6,6,6,7,7,12,12,17])\n[6]\n>>> modes((1,1,2,4,4))\n[1, 4]\n"}
{"id": 65768, "name": "Monte Carlo methods", "source": "Translate Ruby to C#: def approx_pi(throws)\n  times_inside = throws.times.count {Math.hypot(rand, rand) <= 1.0}\n  4.0 * times_inside / throws\nend\n \n[1000, 10_000, 100_000, 1_000_000, 10_000_000].each do |n| \n   puts \"%8d samples: PI = %s\" % [n, approx_pi(n)]\nend\n", "target": "using System;\n\nclass Program {\n    static double MonteCarloPi(int n) {\n        int inside = 0;\n        Random r = new Random();\n\n        for (int i = 0; i < n; i++) {\n            if (Math.Pow(r.NextDouble(), 2)+ Math.Pow(r.NextDouble(), 2) <= 1) {\n                inside++;\n            }\n        }\n\n        return 4.0 * inside / n;\n    }\n\n    static void Main(string[] args) {\n        int value = 1000;\n        for (int n = 0; n < 5; n++) {\n            value *= 10;\n            Console.WriteLine(\"{0}:{1}\", value.ToString(\"#,###\").PadLeft(11, ' '), MonteCarloPi(value));\n        }\n    }\n}\n"}
{"id": 65770, "name": "Monte Carlo methods", "source": "Translate Ruby to Java: def approx_pi(throws)\n  times_inside = throws.times.count {Math.hypot(rand, rand) <= 1.0}\n  4.0 * times_inside / throws\nend\n \n[1000, 10_000, 100_000, 1_000_000, 10_000_000].each do |n| \n   puts \"%8d samples: PI = %s\" % [n, approx_pi(n)]\nend\n", "target": "public class MC {\n\tpublic static void main(String[] args) {\n\t\tSystem.out.println(getPi(10000));\n\t\tSystem.out.println(getPi(100000));\n\t\tSystem.out.println(getPi(1000000));\n\t\tSystem.out.println(getPi(10000000));\n\t\tSystem.out.println(getPi(100000000));\n\t\t\n\t}\n\tpublic static double getPi(int numThrows){\n\t\tint inCircle= 0;\n\t\tfor(int i= 0;i < numThrows;i++){\n\t\t\t\n\t\t\t\n\t\t\tdouble randX= (Math.random() * 2) - 1;\n\t\t\tdouble randY= (Math.random() * 2) - 1;\n\t\t\t\n\t\t\tdouble dist= Math.sqrt(randX * randX + randY * randY);\n\t\t\t\n\t\t\tif(dist < 1){\n\t\t\t\tinCircle++;\n\t\t\t}\n\t\t}\n\t\treturn 4.0 * inCircle / numThrows;\n\t}\n}\n"}
{"id": 65771, "name": "Monte Carlo methods", "source": "Translate Ruby to Python: def approx_pi(throws)\n  times_inside = throws.times.count {Math.hypot(rand, rand) <= 1.0}\n  4.0 * times_inside / throws\nend\n \n[1000, 10_000, 100_000, 1_000_000, 10_000_000].each do |n| \n   puts \"%8d samples: PI = %s\" % [n, approx_pi(n)]\nend\n", "target": ">>> import random, math\n>>> throws = 1000\n>>> 4.0 * sum(math.hypot(*[random.random()*2-1\n\t                 for q in [0,1]]) < 1\n              for p in xrange(throws)) / float(throws)\n3.1520000000000001\n>>> throws = 1000000\n>>> 4.0 * sum(math.hypot(*[random.random()*2-1\n\t                 for q in [0,1]]) < 1\n              for p in xrange(throws)) / float(throws)\n3.1396359999999999\n>>> throws = 100000000\n>>> 4.0 * sum(math.hypot(*[random.random()*2-1\n\t                 for q in [0,1]]) < 1\n              for p in xrange(throws)) / float(throws)\n3.1415666400000002\n"}
{"id": 65908, "name": "Metered concurrency", "source": "Translate Ruby to C#: require 'thread'\n\n\nclass Semaphore\n  def initialize(size = 1)\n    @queue = SizedQueue.new(size)\n    size.times { acquire }\n  end\n\n  def acquire\n    tap { @queue.push(nil) }\n  end\n\n  def release\n    tap { @queue.pop }\n  end\n\n  \n  def count\n    @queue.length\n  end\n\n  def synchronize\n    release\n    yield\n  ensure\n    acquire\n  end\nend\n\ndef foo(id, sem)\n  sem.synchronize do\n    puts \"Thread \n    sleep(2)\n  end\nend\n\nthreads = []\nn = 5\ns = Semaphore.new(3)\nn.times do |i|\n  threads << Thread.new { foo i, s }\nend\nthreads.each(&:join)\n", "target": "using System;\nusing System.Threading;\nusing System.Threading.Tasks;\n\nnamespace RosettaCode\n{\n  internal sealed class Program\n  {\n    private static void Worker(object arg, int id)\n    {\n      var sem = arg as SemaphoreSlim;\n      sem.Wait();\n      Console.WriteLine(\"Thread {0} has a semaphore & is now working.\", id);\n      Thread.Sleep(2*1000);\n      Console.WriteLine(\"#{0} done.\", id);\n      sem.Release();\n    }\n\n    private static void Main()\n    {\n      var semaphore = new SemaphoreSlim(Environment.ProcessorCount*2, int.MaxValue);\n\n      Console.WriteLine(\"You have {0} processors availiabe\", Environment.ProcessorCount);\n      Console.WriteLine(\"This program will use {0} semaphores.\\n\", semaphore.CurrentCount);\n\n      Parallel.For(0, Environment.ProcessorCount*3, y => Worker(semaphore, y));\n    }\n  }\n}\n"}
{"id": 65910, "name": "Metered concurrency", "source": "Translate Ruby to Java: require 'thread'\n\n\nclass Semaphore\n  def initialize(size = 1)\n    @queue = SizedQueue.new(size)\n    size.times { acquire }\n  end\n\n  def acquire\n    tap { @queue.push(nil) }\n  end\n\n  def release\n    tap { @queue.pop }\n  end\n\n  \n  def count\n    @queue.length\n  end\n\n  def synchronize\n    release\n    yield\n  ensure\n    acquire\n  end\nend\n\ndef foo(id, sem)\n  sem.synchronize do\n    puts \"Thread \n    sleep(2)\n  end\nend\n\nthreads = []\nn = 5\ns = Semaphore.new(3)\nn.times do |i|\n  threads << Thread.new { foo i, s }\nend\nthreads.each(&:join)\n", "target": "public class CountingSemaphore{\n   private int lockCount = 0;\n   private int maxCount;\n\n   CountingSemaphore(int Max){\n      maxCount = Max;\n   }\n  \n   public synchronized void acquire() throws InterruptedException{\n      while( lockCount >= maxCount){\n         wait();\n      }\n      lockCount++;\n   }\n   public synchronized void release(){\n      if (lockCount > 0)\n      {\n         lockCount--;\n         notifyAll();\n      }\n   }\n   public synchronized int getCount(){\n      return lockCount;\n   }\n}\n\npublic class Worker extends Thread{\n   private CountingSemaphore lock;\n   private int id;\n\n   Worker(CountingSemaphore coordinator, int num){\n      lock = coordinator;\n      id = num;\n   }\n   Worker(){\n   }\n   public void run(){\n      try{\n         lock.acquire();\n         System.out.println(\"Worker \" + id + \" has acquired the lock.\");\n         sleep(2000);\n      }\n      catch (InterruptedException e){\n      }\n      finally{\n         lock.release();\n      }\n   }\n   public static void main(String[] args){\n      CountingSemaphore lock = new CountingSemaphore(3);\n      Worker crew[];\n      crew = new Worker[5];\n      for (int i = 0; i < 5; i++){\n         crew[i] = new Worker(lock, i);\n         crew[i].start();\n      }\n\n   }\n}\n"}
{"id": 65911, "name": "Metered concurrency", "source": "Translate Ruby to Python: require 'thread'\n\n\nclass Semaphore\n  def initialize(size = 1)\n    @queue = SizedQueue.new(size)\n    size.times { acquire }\n  end\n\n  def acquire\n    tap { @queue.push(nil) }\n  end\n\n  def release\n    tap { @queue.pop }\n  end\n\n  \n  def count\n    @queue.length\n  end\n\n  def synchronize\n    release\n    yield\n  ensure\n    acquire\n  end\nend\n\ndef foo(id, sem)\n  sem.synchronize do\n    puts \"Thread \n    sleep(2)\n  end\nend\n\nthreads = []\nn = 5\ns = Semaphore.new(3)\nn.times do |i|\n  threads << Thread.new { foo i, s }\nend\nthreads.each(&:join)\n", "target": "import time\nimport threading\n\n\nsem = threading.Semaphore(4)\n\nworkers = []\nrunning = 1\n\n\ndef worker():\n    me = threading.currentThread()\n    while 1:\n        sem.acquire()\n        try:\n            if not running:\n                break\n            print '%s acquired semaphore' % me.getName()\n            time.sleep(2.0)\n        finally:\n            sem.release()\n        time.sleep(0.01) \n\n\nfor i in range(10):\n    t = threading.Thread(name=str(i), target=worker)\n    workers.append(t)\n    t.start()\n\n\ntry:\n    while 1:\n        time.sleep(0.1)\nexcept KeyboardInterrupt:\n    running = 0\n    for t in workers:\n        t.join()\n"}
{"id": 66124, "name": "N'th", "source": "Translate Ruby to C#: struct Int\n  def ordinalize\n    num = self.abs\n    ordinal = if (11..13).includes?(num % 100)\n      \"th\"\n    else\n      case num % 10\n        when 1; \"st\"\n        when 2; \"nd\"\n        when 3; \"rd\"\n        else    \"th\"\n      end\n    end\n    \"\n  end\nend\n \n[(0..25),(250..265),(1000..1025)].each{|r| puts r.map{ |n| n.ordinalize }.join(\", \"); puts}\n", "target": "using System;\nusing System.Linq;\n\nclass Program\n{\n    private static string Ordinalize(int i)\n    {\n        i = Math.Abs(i);\n\n        if (new[] {11, 12, 13}.Contains(i%100))\n            return i + \"th\";\n\n        switch (i%10)\n        {\n            case 1:\n                return i + \"st\";\n            case 2:\n                return i + \"nd\";\n            case 3:\n                return i + \"rd\";\n            default:\n                return i + \"th\";\n        }\n    }\n\n    static void Main()\n    {\n        Console.WriteLine(string.Join(\" \", Enumerable.Range(0, 26).Select(Ordinalize)));\n        Console.WriteLine(string.Join(\" \", Enumerable.Range(250, 16).Select(Ordinalize)));\n        Console.WriteLine(string.Join(\" \", Enumerable.Range(1000, 26).Select(Ordinalize)));\n    }\n}\n"}
{"id": 66126, "name": "N'th", "source": "Translate Ruby to Java: struct Int\n  def ordinalize\n    num = self.abs\n    ordinal = if (11..13).includes?(num % 100)\n      \"th\"\n    else\n      case num % 10\n        when 1; \"st\"\n        when 2; \"nd\"\n        when 3; \"rd\"\n        else    \"th\"\n      end\n    end\n    \"\n  end\nend\n \n[(0..25),(250..265),(1000..1025)].each{|r| puts r.map{ |n| n.ordinalize }.join(\", \"); puts}\n", "target": "public class Nth {\n\tpublic static String ordinalAbbrev(int n){\n\t\tString ans = \"th\"; \n\t\tif(n % 100 / 10 == 1) return ans; \n\t\tswitch(n % 10){\n\t\t\tcase 1: ans = \"st\"; break;\n\t\t\tcase 2: ans = \"nd\"; break;\n\t\t\tcase 3: ans = \"rd\"; break;\n\t\t}\n\t\treturn ans;\n\t}\n\t\n\tpublic static void main(String[] args){\n\t\tfor(int i = 0; i <= 25;i++){\n\t\t\tSystem.out.print(i + ordinalAbbrev(i) + \" \");\n\t\t}\n\t\tSystem.out.println();\n\t\tfor(int i = 250; i <= 265;i++){\n\t\t\tSystem.out.print(i + ordinalAbbrev(i) + \" \");\n\t\t}\n\t\tSystem.out.println();\n\t\tfor(int i = 1000; i <= 1025;i++){\n\t\t\tSystem.out.print(i + ordinalAbbrev(i) + \" \");\n\t\t}\n\t}\n}\n"}
{"id": 66127, "name": "N'th", "source": "Translate Ruby to Python: struct Int\n  def ordinalize\n    num = self.abs\n    ordinal = if (11..13).includes?(num % 100)\n      \"th\"\n    else\n      case num % 10\n        when 1; \"st\"\n        when 2; \"nd\"\n        when 3; \"rd\"\n        else    \"th\"\n      end\n    end\n    \"\n  end\nend\n \n[(0..25),(250..265),(1000..1025)].each{|r| puts r.map{ |n| n.ordinalize }.join(\", \"); puts}\n", "target": "_suffix = ['th', 'st', 'nd', 'rd', 'th', 'th', 'th', 'th', 'th', 'th']\n\ndef nth(n):\n    return \"%i'%s\" % (n, _suffix[n%10] if n % 100 <= 10 or n % 100 > 20 else 'th')\n\nif __name__ == '__main__':\n    for j in range(0,1001, 250):\n        print(' '.join(nth(i) for i in list(range(j, j+25))))\n"}
{"id": 66595, "name": "Levenshtein distance", "source": "Translate Ruby to C#: require \"levenshtein\"\nputs Levenshtein.distance(\"kitten\", \"sitting\")\nputs Levenshtein.distance(\"rosettacode\", \"raisethysword\")\n", "target": "using System;\n\nnamespace LevenshteinDistance\n{\n    class Program\n    {\n        static int LevenshteinDistance(string s, string t)\n        {\n            int n = s.Length;\n            int m = t.Length;\n            int[,] d = new int[n + 1, m + 1];\n\t\t\n\t    if (n == 0)\n\t    {\n\t\treturn m;\n\t    }\n\t\n\t    if (m == 0)\n\t    {\n\t\treturn n;\n\t    }\n\n            for (int i = 0; i <= n; i++)\n                d[i, 0] = i;\n            for (int j = 0; j <= m; j++)\n                d[0, j] = j;\n\t\t\t\n            for (int j = 1; j <= m; j++)\n                for (int i = 1; i <= n; i++)\n                    if (s[i - 1] == t[j - 1])\n                        d[i, j] = d[i - 1, j - 1];  \n                    else\n                        d[i, j] = Math.Min(Math.Min(\n                            d[i - 1, j] + 1,    \n                            d[i, j - 1] + 1),   \n                            d[i - 1, j - 1] + 1 \n                            );\n            return d[n, m];\n        }\n\n        static void Main(string[] args)\n        {\n            if (args.Length == 2)\n                Console.WriteLine(\"{0} -> {1} = {2}\",\n                    args[0], args[1], LevenshteinDistance(args[0], args[1]));\n            else\n                Console.WriteLine(\"Usage:-\\n\\nLevenshteinDistance <string1> <string2>\");\n        }\n    }\n}\n"}
{"id": 66596, "name": "Levenshtein distance", "source": "Translate Ruby to C#: require \"levenshtein\"\nputs Levenshtein.distance(\"kitten\", \"sitting\")\nputs Levenshtein.distance(\"rosettacode\", \"raisethysword\")\n", "target": "using System;\n\nnamespace LevenshteinDistance\n{\n    class Program\n    {\n        static int LevenshteinDistance(string s, string t)\n        {\n            int n = s.Length;\n            int m = t.Length;\n            int[,] d = new int[n + 1, m + 1];\n\t\t\n\t    if (n == 0)\n\t    {\n\t\treturn m;\n\t    }\n\t\n\t    if (m == 0)\n\t    {\n\t\treturn n;\n\t    }\n\n            for (int i = 0; i <= n; i++)\n                d[i, 0] = i;\n            for (int j = 0; j <= m; j++)\n                d[0, j] = j;\n\t\t\t\n            for (int j = 1; j <= m; j++)\n                for (int i = 1; i <= n; i++)\n                    if (s[i - 1] == t[j - 1])\n                        d[i, j] = d[i - 1, j - 1];  \n                    else\n                        d[i, j] = Math.Min(Math.Min(\n                            d[i - 1, j] + 1,    \n                            d[i, j - 1] + 1),   \n                            d[i - 1, j - 1] + 1 \n                            );\n            return d[n, m];\n        }\n\n        static void Main(string[] args)\n        {\n            if (args.Length == 2)\n                Console.WriteLine(\"{0} -> {1} = {2}\",\n                    args[0], args[1], LevenshteinDistance(args[0], args[1]));\n            else\n                Console.WriteLine(\"Usage:-\\n\\nLevenshteinDistance <string1> <string2>\");\n        }\n    }\n}\n"}
{"id": 66599, "name": "Levenshtein distance", "source": "Translate Ruby to Java: require \"levenshtein\"\nputs Levenshtein.distance(\"kitten\", \"sitting\")\nputs Levenshtein.distance(\"rosettacode\", \"raisethysword\")\n", "target": "public class Levenshtein {\n\n    public static int distance(String a, String b) {\n        a = a.toLowerCase();\n        b = b.toLowerCase();\n        \n        int [] costs = new int [b.length() + 1];\n        for (int j = 0; j < costs.length; j++)\n            costs[j] = j;\n        for (int i = 1; i <= a.length(); i++) {\n            \n            costs[0] = i;\n            int nw = i - 1;\n            for (int j = 1; j <= b.length(); j++) {\n                int cj = Math.min(1 + Math.min(costs[j], costs[j - 1]), a.charAt(i - 1) == b.charAt(j - 1) ? nw : nw + 1);\n                nw = costs[j];\n                costs[j] = cj;\n            }\n        }\n        return costs[b.length()];\n    }\n\n    public static void main(String [] args) {\n        String [] data = { \"kitten\", \"sitting\", \"saturday\", \"sunday\", \"rosettacode\", \"raisethysword\" };\n        for (int i = 0; i < data.length; i += 2)\n            System.out.println(\"distance(\" + data[i] + \", \" + data[i+1] + \") = \" + distance(data[i], data[i+1]));\n    }\n}\n"}
{"id": 66600, "name": "Levenshtein distance", "source": "Translate Ruby to Java: require \"levenshtein\"\nputs Levenshtein.distance(\"kitten\", \"sitting\")\nputs Levenshtein.distance(\"rosettacode\", \"raisethysword\")\n", "target": "public class Levenshtein {\n\n    public static int distance(String a, String b) {\n        a = a.toLowerCase();\n        b = b.toLowerCase();\n        \n        int [] costs = new int [b.length() + 1];\n        for (int j = 0; j < costs.length; j++)\n            costs[j] = j;\n        for (int i = 1; i <= a.length(); i++) {\n            \n            costs[0] = i;\n            int nw = i - 1;\n            for (int j = 1; j <= b.length(); j++) {\n                int cj = Math.min(1 + Math.min(costs[j], costs[j - 1]), a.charAt(i - 1) == b.charAt(j - 1) ? nw : nw + 1);\n                nw = costs[j];\n                costs[j] = cj;\n            }\n        }\n        return costs[b.length()];\n    }\n\n    public static void main(String [] args) {\n        String [] data = { \"kitten\", \"sitting\", \"saturday\", \"sunday\", \"rosettacode\", \"raisethysword\" };\n        for (int i = 0; i < data.length; i += 2)\n            System.out.println(\"distance(\" + data[i] + \", \" + data[i+1] + \") = \" + distance(data[i], data[i+1]));\n    }\n}\n"}
{"id": 66601, "name": "Levenshtein distance", "source": "Translate Ruby to Python: require \"levenshtein\"\nputs Levenshtein.distance(\"kitten\", \"sitting\")\nputs Levenshtein.distance(\"rosettacode\", \"raisethysword\")\n", "target": "def setup():\n    println(distance(\"kitten\", \"sitting\"))\n\ndef distance(a, b):\n    costs = []\n    for j in range(len(b) + 1):\n        costs.append(j)\n    for i in range(1, len(a) + 1):\n        costs[0] = i\n        nw = i - 1\n        for j in range(1, len(b) + 1):\n            cj = min(1 + min(costs[j], costs[j - 1]),\n                     nw if a[i - 1] == b[j - 1] else nw + 1)\n            nw = costs[j]\n            costs[j] = cj\n\n    return costs[len(b)]\n"}
{"id": 66602, "name": "Levenshtein distance", "source": "Translate Ruby to Python: require \"levenshtein\"\nputs Levenshtein.distance(\"kitten\", \"sitting\")\nputs Levenshtein.distance(\"rosettacode\", \"raisethysword\")\n", "target": "def setup():\n    println(distance(\"kitten\", \"sitting\"))\n\ndef distance(a, b):\n    costs = []\n    for j in range(len(b) + 1):\n        costs.append(j)\n    for i in range(1, len(a) + 1):\n        costs[0] = i\n        nw = i - 1\n        for j in range(1, len(b) + 1):\n            cj = min(1 + min(costs[j], costs[j - 1]),\n                     nw if a[i - 1] == b[j - 1] else nw + 1)\n            nw = costs[j]\n            costs[j] = cj\n\n    return costs[len(b)]\n"}
{"id": 67049, "name": "15 puzzle game", "source": "Translate Ruby to C#: require 'io/console'\n\nclass Board\n  SIZE = 4\n  RANGE = 0...SIZE\n  \n  def initialize\n    width = (SIZE*SIZE-1).to_s.size\n    @frame = (\"+\" + \"-\"*(width+2)) * SIZE + \"+\"\n    @form = \"|\u00a0%\n    @step = 0\n    @orign = [*0...SIZE*SIZE].rotate.each_slice(SIZE).to_a.freeze\n    @board = @orign.map{|row | row.dup}\n    randomize\n    draw\n    message\n    play\n  end\n  \n  private\n  \n  def randomize\n    @board[0][0], @board[SIZE-1][SIZE-1] = 0, 1\n    @board[SIZE-1][0], @board[0][SIZE-1] = @board[0][SIZE-1], @board[SIZE-1][0]\n    x, y, dx, dy = 0, 0, 1, 0\n    50.times do\n      nx,ny = [[x+dx,y+dy], [x+dy,y-dx], [x-dy,y+dx]]\n                .select{|nx,ny| RANGE.include?(nx) and RANGE.include?(ny)}\n                .sample\n      @board[nx][ny], @board[x][y] = 0, @board[nx][ny]\n      x, y, dx, dy = nx, ny, nx-x, ny-y\n    end\n    @x, @y = x, y \n  end\n  \n  def draw\n    puts \"\\e[H\\e[2J\"\n    @board.each do |row|\n      puts @frame\n      puts (@form % row).sub(\" 0 \", \"   \")\n    end\n    puts @frame\n    puts \"Step: \n  end\n  \n  DIR = {up: [-1,0], down: [1,0], left: [0,-1], right: [0,1]}\n  def move(direction)\n    dx, dy = DIR[direction]\n    nx, ny = @x + dx, @y + dy\n    if RANGE.include?(nx) and RANGE.include?(ny)\n      @board[nx][ny], @board[@x][@y] = 0, @board[nx][ny]\n      @x, @y = nx, ny\n      @step += 1\n      draw\n    end\n  end\n  \n  def play\n    until @board == @orign\n      case  key_in\n      when \"\\e[A\", \"w\" then move(:up)\n      when \"\\e[B\", \"s\" then move(:down)\n      when \"\\e[C\", \"d\" then move(:right)\n      when \"\\e[D\", \"a\" then move(:left)\n      \n      when \"q\",\"\\u0003\",\"\\u0004\"  then exit\n      when \"h\"  then message\n      end\n    end\n    \n    puts \"Congratulations, you have won!\"\n  end\n  \n  def key_in\n    input = STDIN.getch\n    if input == \"\\e\" \n      2.times {input << STDIN.getch}\n    end\n    input\n  end\n  \n  def message\n    puts <<~EOM\n      Use the arrow-keys or WASD on your keyboard to push board in the given direction.   \n      PRESS q TO QUIT (or Ctrl-C or Ctrl-D)\n    EOM\n  end\nend\n\nBoard.new\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Drawing;\nusing System.Windows.Forms;\n\npublic class FifteenPuzzle\n{\n    const int GridSize = 4; \n    const int BlockCount = 16;\n\n    static readonly Random R = new Random();\n\n    private List<Button> Puzzles = new List<Button>();\n    private int Moves = 0;\n    private DateTime Start;\n\n    public class Puzzle\n    {\n        private int mOrderedNumer;\n\n        public int CurrentNumber;\n\n        public int X;\n        public int Y;\n\n        public int InvX\n        {\n            get { return (GridSize - 1) - X; }\n        }\n        public int InvY\n        {\n            get { return (GridSize - 1) - Y; }\n        }\n\n        public Puzzle(int OrderedNumer)\n        {\n            mOrderedNumer = OrderedNumer;\n\n            CurrentNumber = OrderedNumer;\n\n            X = OrderedNumer % GridSize;\n            Y = OrderedNumer / GridSize;\n        }\n        public Puzzle(int OrderedNumer, int CurrentNumber)\n            : this(OrderedNumer)\n        {\n            this.CurrentNumber = CurrentNumber;\n        }\n\n        public bool IsEmptyPuzzle\n        {\n            get { return CurrentNumber >= (BlockCount - 1); }\n        }\n        public bool IsTruePlace\n        {\n            get { return (CurrentNumber == mOrderedNumer); }\n        }\n        public bool NearestWith(Puzzle OtherPz)\n        {\n            int dx = (X - OtherPz.X);\n            int dy = (Y - OtherPz.Y);\n\n            if ((dx == 0) && (dy <= 1) && (dy >= -1)) return true;\n            if ((dy == 0) && (dx <= 1) && (dx >= -1)) return true;\n\n            return false;\n        }\n\n        public override string ToString()\n        {\n            return (CurrentNumber + 1).ToString();\n        }\n    }\n\n    public static void Main(string[] args)\n    {\n        FifteenPuzzle Game = new FifteenPuzzle();\n        Application.Run(Game.CreateForm());\n    }\n\n    private Form CreateForm()\n    {\n        int ButtonSize = 50;\n        int ButtonMargin = 3;\n        int FormEdge = 9;\n\n        Font ButtonFont = new Font(\"Arial\", 15.75F, FontStyle.Regular);\n\n        Button StartButton = new Button();\n        StartButton.Location = new Point(FormEdge, (GridSize * (ButtonMargin + ButtonSize)) + FormEdge);\n        StartButton.Size = new Size(86, 23);\n        StartButton.Font = new Font(\"Arial\", 9.75F, FontStyle.Regular);\n        StartButton.Text = \"New Game\";\n        StartButton.UseVisualStyleBackColor = true;\n        StartButton.TabStop = false;\n\n        StartButton.Click += new EventHandler(NewGame);\n\n        int FormWidth = (GridSize * ButtonSize) + ((GridSize - 1) * ButtonMargin) + (FormEdge * 2);\n        int FormHeigth = FormWidth + StartButton.Height;\n\n        Form Form = new Form();\n        Form.Text = \"Fifteen\";\n        Form.ClientSize = new Size(FormWidth, FormHeigth);\n        Form.FormBorderStyle = FormBorderStyle.FixedSingle;\n        Form.MaximizeBox = false;\n        Form.SuspendLayout();\n\n        for (int i = 0; i < BlockCount; i++)\n        {\n            Button Bt = new Button();\n            Puzzle Pz = new Puzzle(i);\n\n            int PosX = FormEdge + (Pz.X) * (ButtonSize + ButtonMargin);\n            int PosY = FormEdge + (Pz.Y) * (ButtonSize + ButtonMargin);\n            Bt.Location = new Point(PosX, PosY);\n\n            Bt.Size = new Size(ButtonSize, ButtonSize);\n            Bt.Font = ButtonFont;\n\n            Bt.Text = Pz.ToString();\n            Bt.Tag = Pz;\n            Bt.UseVisualStyleBackColor = true;\n            Bt.TabStop = false;\n\n            Bt.Enabled = false;\n            if (Pz.IsEmptyPuzzle) Bt.Visible = false;\n\n            Bt.Click += new EventHandler(MovePuzzle);\n\n            Puzzles.Add(Bt);\n            Form.Controls.Add(Bt);\n        }\n\n        Form.Controls.Add(StartButton);\n        Form.ResumeLayout();\n\n        return Form;\n    }\n\n    private void NewGame(object Sender, EventArgs E)\n    {\n        do\n        {\n            for (int i = 0; i < Puzzles.Count; i++)\n            {\n                Button Bt1 = Puzzles[R.Next(i, Puzzles.Count)];\n                Button Bt2 = Puzzles[i];\n                Swap(Bt1, Bt2);\n            }\n        }\n        while (!IsSolvable());\n\n        for (int i = 0; i < Puzzles.Count; i++)\n        {\n            Puzzles[i].Enabled = true;\n        }\n\n        Moves = 0;\n        Start = DateTime.Now;\n    }\n\n    private void MovePuzzle(object Sender, EventArgs E)\n    {\n        Button Bt1 = (Button)Sender;\n        Puzzle Pz1 = (Puzzle)Bt1.Tag;\n\n        Button Bt2 = Puzzles.Find(Bt => ((Puzzle)Bt.Tag).IsEmptyPuzzle);\n        Puzzle Pz2 = (Puzzle)Bt2.Tag;\n\n        if (Pz1.NearestWith(Pz2))\n        {\n            Swap(Bt1, Bt2);\n            Moves++;\n        }\n\n        CheckWin();\n    }\n\n    private void CheckWin()\n    {\n        Button WrongPuzzle = Puzzles.Find(Bt => !((Puzzle)Bt.Tag).IsTruePlace);\n        bool UWin = (WrongPuzzle == null);\n\n        if (UWin)\n        {\n            for (int i = 0; i < Puzzles.Count; i++)\n            {\n                Puzzles[i].Enabled = false;\n            }\n\n            TimeSpan Elapsed = DateTime.Now - Start;\n            Elapsed = TimeSpan.FromSeconds(Math.Round(Elapsed.TotalSeconds, 0));\n            MessageBox.Show(String.Format(\"Solved in {0} moves. Time: {1}\", Moves, Elapsed));\n        }\n    }\n\n    private void Swap(Button Bt1, Button Bt2)\n    {\n        if (Bt1 == Bt2) return;\n\n        Puzzle Pz1 = (Puzzle)Bt1.Tag;\n        Puzzle Pz2 = (Puzzle)Bt2.Tag;\n\n        int g = Pz1.CurrentNumber;\n        Pz1.CurrentNumber = Pz2.CurrentNumber;\n        Pz2.CurrentNumber = g;\n\n        Bt1.Visible = true;\n        Bt1.Text = Pz1.ToString();\n        if (Pz1.IsEmptyPuzzle) Bt1.Visible = false;\n\n        Bt2.Visible = true;\n        Bt2.Text = Pz2.ToString();\n        if (Pz2.IsEmptyPuzzle) Bt2.Visible = false;\n    }\n\n    private bool IsSolvable()\n    {\n        \n        \n\n        int InvCount = 0;\n        for (int i = 0; i < Puzzles.Count - 1; i++)\n        {\n            for (int j = i + 1; j < Puzzles.Count; j++)\n            {\n                Puzzle Pz1 = (Puzzle)Puzzles[i].Tag;\n                if (Pz1.IsEmptyPuzzle) continue;\n\n                Puzzle Pz2 = (Puzzle)Puzzles[j].Tag;\n                if (Pz2.IsEmptyPuzzle) continue;\n\n                if (Pz1.CurrentNumber > Pz2.CurrentNumber) InvCount++;\n            }\n        }\n\n        Button EmptyBt = Puzzles.Find(Bt => ((Puzzle)Bt.Tag).IsEmptyPuzzle);\n        Puzzle EmptyPz = (Puzzle)EmptyBt.Tag;\n\n        bool Result = false;\n        if ((EmptyPz.InvY + 1) % 2 == 0) \n        {\n            \n            if (InvCount % 2 != 0) Result = true;\n        }\n        else \n        {\n            \n            if (InvCount % 2 == 0) Result = true;\n        }\n        return Result;\n    }\n}\n"}
{"id": 67050, "name": "15 puzzle game", "source": "Translate Ruby to C#: require 'io/console'\n\nclass Board\n  SIZE = 4\n  RANGE = 0...SIZE\n  \n  def initialize\n    width = (SIZE*SIZE-1).to_s.size\n    @frame = (\"+\" + \"-\"*(width+2)) * SIZE + \"+\"\n    @form = \"|\u00a0%\n    @step = 0\n    @orign = [*0...SIZE*SIZE].rotate.each_slice(SIZE).to_a.freeze\n    @board = @orign.map{|row | row.dup}\n    randomize\n    draw\n    message\n    play\n  end\n  \n  private\n  \n  def randomize\n    @board[0][0], @board[SIZE-1][SIZE-1] = 0, 1\n    @board[SIZE-1][0], @board[0][SIZE-1] = @board[0][SIZE-1], @board[SIZE-1][0]\n    x, y, dx, dy = 0, 0, 1, 0\n    50.times do\n      nx,ny = [[x+dx,y+dy], [x+dy,y-dx], [x-dy,y+dx]]\n                .select{|nx,ny| RANGE.include?(nx) and RANGE.include?(ny)}\n                .sample\n      @board[nx][ny], @board[x][y] = 0, @board[nx][ny]\n      x, y, dx, dy = nx, ny, nx-x, ny-y\n    end\n    @x, @y = x, y \n  end\n  \n  def draw\n    puts \"\\e[H\\e[2J\"\n    @board.each do |row|\n      puts @frame\n      puts (@form % row).sub(\" 0 \", \"   \")\n    end\n    puts @frame\n    puts \"Step: \n  end\n  \n  DIR = {up: [-1,0], down: [1,0], left: [0,-1], right: [0,1]}\n  def move(direction)\n    dx, dy = DIR[direction]\n    nx, ny = @x + dx, @y + dy\n    if RANGE.include?(nx) and RANGE.include?(ny)\n      @board[nx][ny], @board[@x][@y] = 0, @board[nx][ny]\n      @x, @y = nx, ny\n      @step += 1\n      draw\n    end\n  end\n  \n  def play\n    until @board == @orign\n      case  key_in\n      when \"\\e[A\", \"w\" then move(:up)\n      when \"\\e[B\", \"s\" then move(:down)\n      when \"\\e[C\", \"d\" then move(:right)\n      when \"\\e[D\", \"a\" then move(:left)\n      \n      when \"q\",\"\\u0003\",\"\\u0004\"  then exit\n      when \"h\"  then message\n      end\n    end\n    \n    puts \"Congratulations, you have won!\"\n  end\n  \n  def key_in\n    input = STDIN.getch\n    if input == \"\\e\" \n      2.times {input << STDIN.getch}\n    end\n    input\n  end\n  \n  def message\n    puts <<~EOM\n      Use the arrow-keys or WASD on your keyboard to push board in the given direction.   \n      PRESS q TO QUIT (or Ctrl-C or Ctrl-D)\n    EOM\n  end\nend\n\nBoard.new\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Drawing;\nusing System.Windows.Forms;\n\npublic class FifteenPuzzle\n{\n    const int GridSize = 4; \n    const int BlockCount = 16;\n\n    static readonly Random R = new Random();\n\n    private List<Button> Puzzles = new List<Button>();\n    private int Moves = 0;\n    private DateTime Start;\n\n    public class Puzzle\n    {\n        private int mOrderedNumer;\n\n        public int CurrentNumber;\n\n        public int X;\n        public int Y;\n\n        public int InvX\n        {\n            get { return (GridSize - 1) - X; }\n        }\n        public int InvY\n        {\n            get { return (GridSize - 1) - Y; }\n        }\n\n        public Puzzle(int OrderedNumer)\n        {\n            mOrderedNumer = OrderedNumer;\n\n            CurrentNumber = OrderedNumer;\n\n            X = OrderedNumer % GridSize;\n            Y = OrderedNumer / GridSize;\n        }\n        public Puzzle(int OrderedNumer, int CurrentNumber)\n            : this(OrderedNumer)\n        {\n            this.CurrentNumber = CurrentNumber;\n        }\n\n        public bool IsEmptyPuzzle\n        {\n            get { return CurrentNumber >= (BlockCount - 1); }\n        }\n        public bool IsTruePlace\n        {\n            get { return (CurrentNumber == mOrderedNumer); }\n        }\n        public bool NearestWith(Puzzle OtherPz)\n        {\n            int dx = (X - OtherPz.X);\n            int dy = (Y - OtherPz.Y);\n\n            if ((dx == 0) && (dy <= 1) && (dy >= -1)) return true;\n            if ((dy == 0) && (dx <= 1) && (dx >= -1)) return true;\n\n            return false;\n        }\n\n        public override string ToString()\n        {\n            return (CurrentNumber + 1).ToString();\n        }\n    }\n\n    public static void Main(string[] args)\n    {\n        FifteenPuzzle Game = new FifteenPuzzle();\n        Application.Run(Game.CreateForm());\n    }\n\n    private Form CreateForm()\n    {\n        int ButtonSize = 50;\n        int ButtonMargin = 3;\n        int FormEdge = 9;\n\n        Font ButtonFont = new Font(\"Arial\", 15.75F, FontStyle.Regular);\n\n        Button StartButton = new Button();\n        StartButton.Location = new Point(FormEdge, (GridSize * (ButtonMargin + ButtonSize)) + FormEdge);\n        StartButton.Size = new Size(86, 23);\n        StartButton.Font = new Font(\"Arial\", 9.75F, FontStyle.Regular);\n        StartButton.Text = \"New Game\";\n        StartButton.UseVisualStyleBackColor = true;\n        StartButton.TabStop = false;\n\n        StartButton.Click += new EventHandler(NewGame);\n\n        int FormWidth = (GridSize * ButtonSize) + ((GridSize - 1) * ButtonMargin) + (FormEdge * 2);\n        int FormHeigth = FormWidth + StartButton.Height;\n\n        Form Form = new Form();\n        Form.Text = \"Fifteen\";\n        Form.ClientSize = new Size(FormWidth, FormHeigth);\n        Form.FormBorderStyle = FormBorderStyle.FixedSingle;\n        Form.MaximizeBox = false;\n        Form.SuspendLayout();\n\n        for (int i = 0; i < BlockCount; i++)\n        {\n            Button Bt = new Button();\n            Puzzle Pz = new Puzzle(i);\n\n            int PosX = FormEdge + (Pz.X) * (ButtonSize + ButtonMargin);\n            int PosY = FormEdge + (Pz.Y) * (ButtonSize + ButtonMargin);\n            Bt.Location = new Point(PosX, PosY);\n\n            Bt.Size = new Size(ButtonSize, ButtonSize);\n            Bt.Font = ButtonFont;\n\n            Bt.Text = Pz.ToString();\n            Bt.Tag = Pz;\n            Bt.UseVisualStyleBackColor = true;\n            Bt.TabStop = false;\n\n            Bt.Enabled = false;\n            if (Pz.IsEmptyPuzzle) Bt.Visible = false;\n\n            Bt.Click += new EventHandler(MovePuzzle);\n\n            Puzzles.Add(Bt);\n            Form.Controls.Add(Bt);\n        }\n\n        Form.Controls.Add(StartButton);\n        Form.ResumeLayout();\n\n        return Form;\n    }\n\n    private void NewGame(object Sender, EventArgs E)\n    {\n        do\n        {\n            for (int i = 0; i < Puzzles.Count; i++)\n            {\n                Button Bt1 = Puzzles[R.Next(i, Puzzles.Count)];\n                Button Bt2 = Puzzles[i];\n                Swap(Bt1, Bt2);\n            }\n        }\n        while (!IsSolvable());\n\n        for (int i = 0; i < Puzzles.Count; i++)\n        {\n            Puzzles[i].Enabled = true;\n        }\n\n        Moves = 0;\n        Start = DateTime.Now;\n    }\n\n    private void MovePuzzle(object Sender, EventArgs E)\n    {\n        Button Bt1 = (Button)Sender;\n        Puzzle Pz1 = (Puzzle)Bt1.Tag;\n\n        Button Bt2 = Puzzles.Find(Bt => ((Puzzle)Bt.Tag).IsEmptyPuzzle);\n        Puzzle Pz2 = (Puzzle)Bt2.Tag;\n\n        if (Pz1.NearestWith(Pz2))\n        {\n            Swap(Bt1, Bt2);\n            Moves++;\n        }\n\n        CheckWin();\n    }\n\n    private void CheckWin()\n    {\n        Button WrongPuzzle = Puzzles.Find(Bt => !((Puzzle)Bt.Tag).IsTruePlace);\n        bool UWin = (WrongPuzzle == null);\n\n        if (UWin)\n        {\n            for (int i = 0; i < Puzzles.Count; i++)\n            {\n                Puzzles[i].Enabled = false;\n            }\n\n            TimeSpan Elapsed = DateTime.Now - Start;\n            Elapsed = TimeSpan.FromSeconds(Math.Round(Elapsed.TotalSeconds, 0));\n            MessageBox.Show(String.Format(\"Solved in {0} moves. Time: {1}\", Moves, Elapsed));\n        }\n    }\n\n    private void Swap(Button Bt1, Button Bt2)\n    {\n        if (Bt1 == Bt2) return;\n\n        Puzzle Pz1 = (Puzzle)Bt1.Tag;\n        Puzzle Pz2 = (Puzzle)Bt2.Tag;\n\n        int g = Pz1.CurrentNumber;\n        Pz1.CurrentNumber = Pz2.CurrentNumber;\n        Pz2.CurrentNumber = g;\n\n        Bt1.Visible = true;\n        Bt1.Text = Pz1.ToString();\n        if (Pz1.IsEmptyPuzzle) Bt1.Visible = false;\n\n        Bt2.Visible = true;\n        Bt2.Text = Pz2.ToString();\n        if (Pz2.IsEmptyPuzzle) Bt2.Visible = false;\n    }\n\n    private bool IsSolvable()\n    {\n        \n        \n\n        int InvCount = 0;\n        for (int i = 0; i < Puzzles.Count - 1; i++)\n        {\n            for (int j = i + 1; j < Puzzles.Count; j++)\n            {\n                Puzzle Pz1 = (Puzzle)Puzzles[i].Tag;\n                if (Pz1.IsEmptyPuzzle) continue;\n\n                Puzzle Pz2 = (Puzzle)Puzzles[j].Tag;\n                if (Pz2.IsEmptyPuzzle) continue;\n\n                if (Pz1.CurrentNumber > Pz2.CurrentNumber) InvCount++;\n            }\n        }\n\n        Button EmptyBt = Puzzles.Find(Bt => ((Puzzle)Bt.Tag).IsEmptyPuzzle);\n        Puzzle EmptyPz = (Puzzle)EmptyBt.Tag;\n\n        bool Result = false;\n        if ((EmptyPz.InvY + 1) % 2 == 0) \n        {\n            \n            if (InvCount % 2 != 0) Result = true;\n        }\n        else \n        {\n            \n            if (InvCount % 2 == 0) Result = true;\n        }\n        return Result;\n    }\n}\n"}
{"id": 67053, "name": "15 puzzle game", "source": "Translate Ruby to Java: require 'io/console'\n\nclass Board\n  SIZE = 4\n  RANGE = 0...SIZE\n  \n  def initialize\n    width = (SIZE*SIZE-1).to_s.size\n    @frame = (\"+\" + \"-\"*(width+2)) * SIZE + \"+\"\n    @form = \"|\u00a0%\n    @step = 0\n    @orign = [*0...SIZE*SIZE].rotate.each_slice(SIZE).to_a.freeze\n    @board = @orign.map{|row | row.dup}\n    randomize\n    draw\n    message\n    play\n  end\n  \n  private\n  \n  def randomize\n    @board[0][0], @board[SIZE-1][SIZE-1] = 0, 1\n    @board[SIZE-1][0], @board[0][SIZE-1] = @board[0][SIZE-1], @board[SIZE-1][0]\n    x, y, dx, dy = 0, 0, 1, 0\n    50.times do\n      nx,ny = [[x+dx,y+dy], [x+dy,y-dx], [x-dy,y+dx]]\n                .select{|nx,ny| RANGE.include?(nx) and RANGE.include?(ny)}\n                .sample\n      @board[nx][ny], @board[x][y] = 0, @board[nx][ny]\n      x, y, dx, dy = nx, ny, nx-x, ny-y\n    end\n    @x, @y = x, y \n  end\n  \n  def draw\n    puts \"\\e[H\\e[2J\"\n    @board.each do |row|\n      puts @frame\n      puts (@form % row).sub(\" 0 \", \"   \")\n    end\n    puts @frame\n    puts \"Step: \n  end\n  \n  DIR = {up: [-1,0], down: [1,0], left: [0,-1], right: [0,1]}\n  def move(direction)\n    dx, dy = DIR[direction]\n    nx, ny = @x + dx, @y + dy\n    if RANGE.include?(nx) and RANGE.include?(ny)\n      @board[nx][ny], @board[@x][@y] = 0, @board[nx][ny]\n      @x, @y = nx, ny\n      @step += 1\n      draw\n    end\n  end\n  \n  def play\n    until @board == @orign\n      case  key_in\n      when \"\\e[A\", \"w\" then move(:up)\n      when \"\\e[B\", \"s\" then move(:down)\n      when \"\\e[C\", \"d\" then move(:right)\n      when \"\\e[D\", \"a\" then move(:left)\n      \n      when \"q\",\"\\u0003\",\"\\u0004\"  then exit\n      when \"h\"  then message\n      end\n    end\n    \n    puts \"Congratulations, you have won!\"\n  end\n  \n  def key_in\n    input = STDIN.getch\n    if input == \"\\e\" \n      2.times {input << STDIN.getch}\n    end\n    input\n  end\n  \n  def message\n    puts <<~EOM\n      Use the arrow-keys or WASD on your keyboard to push board in the given direction.   \n      PRESS q TO QUIT (or Ctrl-C or Ctrl-D)\n    EOM\n  end\nend\n\nBoard.new\n", "target": "package fifteenpuzzle;\n\nimport java.awt.*;\nimport java.awt.event.*;\nimport java.util.Random;\nimport javax.swing.*;\n\nclass FifteenPuzzle extends JPanel {\n\n    private final int side = 4;\n    private final int numTiles = side * side - 1;\n\n    private final Random rand = new Random();\n    private final int[] tiles = new int[numTiles + 1];\n    private final int tileSize;\n    private int blankPos;\n    private final int margin;\n    private final int gridSize;\n    private boolean gameOver;\n\n    private FifteenPuzzle() {\n        final int dim = 640;\n\n        margin = 80;\n        tileSize = (dim - 2 * margin) / side;\n        gridSize = tileSize * side;\n\n        setPreferredSize(new Dimension(dim, dim + margin));\n        setBackground(Color.WHITE);\n        setForeground(new Color(0x6495ED)); \n        setFont(new Font(\"SansSerif\", Font.BOLD, 60));\n\n        gameOver = true;\n\n        addMouseListener(new MouseAdapter() {\n            @Override\n            public void mousePressed(MouseEvent e) {\n                if (gameOver) {\n                    newGame();\n\n                } else {\n\n                    int ex = e.getX() - margin;\n                    int ey = e.getY() - margin;\n\n                    if (ex < 0 || ex > gridSize || ey < 0 || ey > gridSize) {\n                        return;\n                    }\n\n                    int c1 = ex / tileSize;\n                    int r1 = ey / tileSize;\n                    int c2 = blankPos % side;\n                    int r2 = blankPos / side;\n\n                    int clickPos = r1 * side + c1;\n\n                    int dir = 0;\n                    if (c1 == c2 && Math.abs(r1 - r2) > 0) {\n                        dir = (r1 - r2) > 0 ? 4 : -4;\n                        \n                    } else if (r1 == r2 && Math.abs(c1 - c2) > 0) {\n                        dir = (c1 - c2) > 0 ? 1 : -1;\n                    }\n\n                    if (dir != 0) {\n                        do {\n                            int newBlankPos = blankPos + dir;\n                            tiles[blankPos] = tiles[newBlankPos];\n                            blankPos = newBlankPos;\n                        } while (blankPos != clickPos);\n                        tiles[blankPos] = 0;\n                    }\n                    \n                    gameOver = isSolved();\n                }\n                repaint();\n            }\n        });\n\n        newGame();\n    }\n\n    private void newGame() {\n        do {\n            reset();\n            shuffle();\n        } while (!isSolvable());\n        gameOver = false;\n    }\n\n    private void reset() {\n        for (int i = 0; i < tiles.length; i++) {\n            tiles[i] = (i + 1) % tiles.length;\n        }\n        blankPos = tiles.length - 1;\n    }\n\n    private void shuffle() {\n        \n        \n        int n = numTiles;\n        while (n > 1) {\n            int r = rand.nextInt(n--);\n            int tmp = tiles[r];\n            tiles[r] = tiles[n];\n            tiles[n] = tmp;\n        }\n    }\n\n    \n    private boolean isSolvable() {\n        int countInversions = 0;\n        for (int i = 0; i < numTiles; i++) {\n            for (int j = 0; j < i; j++) {\n                if (tiles[j] > tiles[i]) {\n                    countInversions++;\n                }\n            }\n        }\n        return countInversions % 2 == 0;\n    }\n\n    private boolean isSolved() {\n        if (tiles[tiles.length - 1] != 0) {\n            return false;\n        }\n        for (int i = numTiles - 1; i >= 0; i--) {\n            if (tiles[i] != i + 1) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    private void drawGrid(Graphics2D g) {\n        for (int i = 0; i < tiles.length; i++) {\n            int r = i / side;\n            int c = i % side;\n            int x = margin + c * tileSize;\n            int y = margin + r * tileSize;\n\n            if (tiles[i] == 0) {\n                if (gameOver) {\n                    g.setColor(Color.GREEN);\n                    drawCenteredString(g, \"\\u2713\", x, y);\n                }\n                continue;\n            }\n\n            g.setColor(getForeground());\n            g.fillRoundRect(x, y, tileSize, tileSize, 25, 25);\n            g.setColor(Color.blue.darker());\n            g.drawRoundRect(x, y, tileSize, tileSize, 25, 25);\n            g.setColor(Color.WHITE);\n\n            drawCenteredString(g, String.valueOf(tiles[i]), x, y);\n        }\n    }\n\n    private void drawStartMessage(Graphics2D g) {\n        if (gameOver) {\n            g.setFont(getFont().deriveFont(Font.BOLD, 18));\n            g.setColor(getForeground());\n            String s = \"click to start a new game\";\n            int x = (getWidth() - g.getFontMetrics().stringWidth(s)) / 2;\n            int y = getHeight() - margin;\n            g.drawString(s, x, y);\n        }\n    }\n\n    private void drawCenteredString(Graphics2D g, String s, int x, int y) {\n        FontMetrics fm = g.getFontMetrics();\n        int asc = fm.getAscent();\n        int des = fm.getDescent();\n\n        x = x + (tileSize - fm.stringWidth(s)) / 2;\n        y = y + (asc + (tileSize - (asc + des)) / 2);\n\n        g.drawString(s, x, y);\n    }\n\n    @Override\n    public void paintComponent(Graphics gg) {\n        super.paintComponent(gg);\n        Graphics2D g = (Graphics2D) gg;\n        g.setRenderingHint(RenderingHints.KEY_ANTIALIASING,\n                RenderingHints.VALUE_ANTIALIAS_ON);\n\n        drawGrid(g);\n        drawStartMessage(g);\n    }\n\n    public static void main(String[] args) {\n        SwingUtilities.invokeLater(() -> {\n            JFrame f = new JFrame();\n            f.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n            f.setTitle(\"Fifteen Puzzle\");\n            f.setResizable(false);\n            f.add(new FifteenPuzzle(), BorderLayout.CENTER);\n            f.pack();\n            f.setLocationRelativeTo(null);\n            f.setVisible(true);\n        });\n    }\n}\n"}
{"id": 67054, "name": "15 puzzle game", "source": "Translate Ruby to Java: require 'io/console'\n\nclass Board\n  SIZE = 4\n  RANGE = 0...SIZE\n  \n  def initialize\n    width = (SIZE*SIZE-1).to_s.size\n    @frame = (\"+\" + \"-\"*(width+2)) * SIZE + \"+\"\n    @form = \"|\u00a0%\n    @step = 0\n    @orign = [*0...SIZE*SIZE].rotate.each_slice(SIZE).to_a.freeze\n    @board = @orign.map{|row | row.dup}\n    randomize\n    draw\n    message\n    play\n  end\n  \n  private\n  \n  def randomize\n    @board[0][0], @board[SIZE-1][SIZE-1] = 0, 1\n    @board[SIZE-1][0], @board[0][SIZE-1] = @board[0][SIZE-1], @board[SIZE-1][0]\n    x, y, dx, dy = 0, 0, 1, 0\n    50.times do\n      nx,ny = [[x+dx,y+dy], [x+dy,y-dx], [x-dy,y+dx]]\n                .select{|nx,ny| RANGE.include?(nx) and RANGE.include?(ny)}\n                .sample\n      @board[nx][ny], @board[x][y] = 0, @board[nx][ny]\n      x, y, dx, dy = nx, ny, nx-x, ny-y\n    end\n    @x, @y = x, y \n  end\n  \n  def draw\n    puts \"\\e[H\\e[2J\"\n    @board.each do |row|\n      puts @frame\n      puts (@form % row).sub(\" 0 \", \"   \")\n    end\n    puts @frame\n    puts \"Step: \n  end\n  \n  DIR = {up: [-1,0], down: [1,0], left: [0,-1], right: [0,1]}\n  def move(direction)\n    dx, dy = DIR[direction]\n    nx, ny = @x + dx, @y + dy\n    if RANGE.include?(nx) and RANGE.include?(ny)\n      @board[nx][ny], @board[@x][@y] = 0, @board[nx][ny]\n      @x, @y = nx, ny\n      @step += 1\n      draw\n    end\n  end\n  \n  def play\n    until @board == @orign\n      case  key_in\n      when \"\\e[A\", \"w\" then move(:up)\n      when \"\\e[B\", \"s\" then move(:down)\n      when \"\\e[C\", \"d\" then move(:right)\n      when \"\\e[D\", \"a\" then move(:left)\n      \n      when \"q\",\"\\u0003\",\"\\u0004\"  then exit\n      when \"h\"  then message\n      end\n    end\n    \n    puts \"Congratulations, you have won!\"\n  end\n  \n  def key_in\n    input = STDIN.getch\n    if input == \"\\e\" \n      2.times {input << STDIN.getch}\n    end\n    input\n  end\n  \n  def message\n    puts <<~EOM\n      Use the arrow-keys or WASD on your keyboard to push board in the given direction.   \n      PRESS q TO QUIT (or Ctrl-C or Ctrl-D)\n    EOM\n  end\nend\n\nBoard.new\n", "target": "package fifteenpuzzle;\n\nimport java.awt.*;\nimport java.awt.event.*;\nimport java.util.Random;\nimport javax.swing.*;\n\nclass FifteenPuzzle extends JPanel {\n\n    private final int side = 4;\n    private final int numTiles = side * side - 1;\n\n    private final Random rand = new Random();\n    private final int[] tiles = new int[numTiles + 1];\n    private final int tileSize;\n    private int blankPos;\n    private final int margin;\n    private final int gridSize;\n    private boolean gameOver;\n\n    private FifteenPuzzle() {\n        final int dim = 640;\n\n        margin = 80;\n        tileSize = (dim - 2 * margin) / side;\n        gridSize = tileSize * side;\n\n        setPreferredSize(new Dimension(dim, dim + margin));\n        setBackground(Color.WHITE);\n        setForeground(new Color(0x6495ED)); \n        setFont(new Font(\"SansSerif\", Font.BOLD, 60));\n\n        gameOver = true;\n\n        addMouseListener(new MouseAdapter() {\n            @Override\n            public void mousePressed(MouseEvent e) {\n                if (gameOver) {\n                    newGame();\n\n                } else {\n\n                    int ex = e.getX() - margin;\n                    int ey = e.getY() - margin;\n\n                    if (ex < 0 || ex > gridSize || ey < 0 || ey > gridSize) {\n                        return;\n                    }\n\n                    int c1 = ex / tileSize;\n                    int r1 = ey / tileSize;\n                    int c2 = blankPos % side;\n                    int r2 = blankPos / side;\n\n                    int clickPos = r1 * side + c1;\n\n                    int dir = 0;\n                    if (c1 == c2 && Math.abs(r1 - r2) > 0) {\n                        dir = (r1 - r2) > 0 ? 4 : -4;\n                        \n                    } else if (r1 == r2 && Math.abs(c1 - c2) > 0) {\n                        dir = (c1 - c2) > 0 ? 1 : -1;\n                    }\n\n                    if (dir != 0) {\n                        do {\n                            int newBlankPos = blankPos + dir;\n                            tiles[blankPos] = tiles[newBlankPos];\n                            blankPos = newBlankPos;\n                        } while (blankPos != clickPos);\n                        tiles[blankPos] = 0;\n                    }\n                    \n                    gameOver = isSolved();\n                }\n                repaint();\n            }\n        });\n\n        newGame();\n    }\n\n    private void newGame() {\n        do {\n            reset();\n            shuffle();\n        } while (!isSolvable());\n        gameOver = false;\n    }\n\n    private void reset() {\n        for (int i = 0; i < tiles.length; i++) {\n            tiles[i] = (i + 1) % tiles.length;\n        }\n        blankPos = tiles.length - 1;\n    }\n\n    private void shuffle() {\n        \n        \n        int n = numTiles;\n        while (n > 1) {\n            int r = rand.nextInt(n--);\n            int tmp = tiles[r];\n            tiles[r] = tiles[n];\n            tiles[n] = tmp;\n        }\n    }\n\n    \n    private boolean isSolvable() {\n        int countInversions = 0;\n        for (int i = 0; i < numTiles; i++) {\n            for (int j = 0; j < i; j++) {\n                if (tiles[j] > tiles[i]) {\n                    countInversions++;\n                }\n            }\n        }\n        return countInversions % 2 == 0;\n    }\n\n    private boolean isSolved() {\n        if (tiles[tiles.length - 1] != 0) {\n            return false;\n        }\n        for (int i = numTiles - 1; i >= 0; i--) {\n            if (tiles[i] != i + 1) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    private void drawGrid(Graphics2D g) {\n        for (int i = 0; i < tiles.length; i++) {\n            int r = i / side;\n            int c = i % side;\n            int x = margin + c * tileSize;\n            int y = margin + r * tileSize;\n\n            if (tiles[i] == 0) {\n                if (gameOver) {\n                    g.setColor(Color.GREEN);\n                    drawCenteredString(g, \"\\u2713\", x, y);\n                }\n                continue;\n            }\n\n            g.setColor(getForeground());\n            g.fillRoundRect(x, y, tileSize, tileSize, 25, 25);\n            g.setColor(Color.blue.darker());\n            g.drawRoundRect(x, y, tileSize, tileSize, 25, 25);\n            g.setColor(Color.WHITE);\n\n            drawCenteredString(g, String.valueOf(tiles[i]), x, y);\n        }\n    }\n\n    private void drawStartMessage(Graphics2D g) {\n        if (gameOver) {\n            g.setFont(getFont().deriveFont(Font.BOLD, 18));\n            g.setColor(getForeground());\n            String s = \"click to start a new game\";\n            int x = (getWidth() - g.getFontMetrics().stringWidth(s)) / 2;\n            int y = getHeight() - margin;\n            g.drawString(s, x, y);\n        }\n    }\n\n    private void drawCenteredString(Graphics2D g, String s, int x, int y) {\n        FontMetrics fm = g.getFontMetrics();\n        int asc = fm.getAscent();\n        int des = fm.getDescent();\n\n        x = x + (tileSize - fm.stringWidth(s)) / 2;\n        y = y + (asc + (tileSize - (asc + des)) / 2);\n\n        g.drawString(s, x, y);\n    }\n\n    @Override\n    public void paintComponent(Graphics gg) {\n        super.paintComponent(gg);\n        Graphics2D g = (Graphics2D) gg;\n        g.setRenderingHint(RenderingHints.KEY_ANTIALIASING,\n                RenderingHints.VALUE_ANTIALIAS_ON);\n\n        drawGrid(g);\n        drawStartMessage(g);\n    }\n\n    public static void main(String[] args) {\n        SwingUtilities.invokeLater(() -> {\n            JFrame f = new JFrame();\n            f.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n            f.setTitle(\"Fifteen Puzzle\");\n            f.setResizable(false);\n            f.add(new FifteenPuzzle(), BorderLayout.CENTER);\n            f.pack();\n            f.setLocationRelativeTo(null);\n            f.setVisible(true);\n        });\n    }\n}\n"}
{"id": 67055, "name": "15 puzzle game", "source": "Translate Ruby to Python: require 'io/console'\n\nclass Board\n  SIZE = 4\n  RANGE = 0...SIZE\n  \n  def initialize\n    width = (SIZE*SIZE-1).to_s.size\n    @frame = (\"+\" + \"-\"*(width+2)) * SIZE + \"+\"\n    @form = \"|\u00a0%\n    @step = 0\n    @orign = [*0...SIZE*SIZE].rotate.each_slice(SIZE).to_a.freeze\n    @board = @orign.map{|row | row.dup}\n    randomize\n    draw\n    message\n    play\n  end\n  \n  private\n  \n  def randomize\n    @board[0][0], @board[SIZE-1][SIZE-1] = 0, 1\n    @board[SIZE-1][0], @board[0][SIZE-1] = @board[0][SIZE-1], @board[SIZE-1][0]\n    x, y, dx, dy = 0, 0, 1, 0\n    50.times do\n      nx,ny = [[x+dx,y+dy], [x+dy,y-dx], [x-dy,y+dx]]\n                .select{|nx,ny| RANGE.include?(nx) and RANGE.include?(ny)}\n                .sample\n      @board[nx][ny], @board[x][y] = 0, @board[nx][ny]\n      x, y, dx, dy = nx, ny, nx-x, ny-y\n    end\n    @x, @y = x, y \n  end\n  \n  def draw\n    puts \"\\e[H\\e[2J\"\n    @board.each do |row|\n      puts @frame\n      puts (@form % row).sub(\" 0 \", \"   \")\n    end\n    puts @frame\n    puts \"Step: \n  end\n  \n  DIR = {up: [-1,0], down: [1,0], left: [0,-1], right: [0,1]}\n  def move(direction)\n    dx, dy = DIR[direction]\n    nx, ny = @x + dx, @y + dy\n    if RANGE.include?(nx) and RANGE.include?(ny)\n      @board[nx][ny], @board[@x][@y] = 0, @board[nx][ny]\n      @x, @y = nx, ny\n      @step += 1\n      draw\n    end\n  end\n  \n  def play\n    until @board == @orign\n      case  key_in\n      when \"\\e[A\", \"w\" then move(:up)\n      when \"\\e[B\", \"s\" then move(:down)\n      when \"\\e[C\", \"d\" then move(:right)\n      when \"\\e[D\", \"a\" then move(:left)\n      \n      when \"q\",\"\\u0003\",\"\\u0004\"  then exit\n      when \"h\"  then message\n      end\n    end\n    \n    puts \"Congratulations, you have won!\"\n  end\n  \n  def key_in\n    input = STDIN.getch\n    if input == \"\\e\" \n      2.times {input << STDIN.getch}\n    end\n    input\n  end\n  \n  def message\n    puts <<~EOM\n      Use the arrow-keys or WASD on your keyboard to push board in the given direction.   \n      PRESS q TO QUIT (or Ctrl-C or Ctrl-D)\n    EOM\n  end\nend\n\nBoard.new\n", "target": "type Puzzle(var items: {}, var position: -1)\n\nfun mainframe(puz):\n    let d = puz.items\n    print('+-----+-----+-----+-----+')\n    print(d[1], d[2], d[3], d[4], first: '|', sep: '|', last: '|')\n    print('+-----+-----+-----+-----+')\n    print(d[5], d[6], d[7], d[8], first: '|', sep: '|', last: '|')\n    print('+-----+-----+-----+-----+')\n    print(d[9], d[10], d[11], d[12], first: '|', sep: '|', last: '|')\n    print('+-----+-----+-----+-----+')\n    print(d[13], d[14], d[15], d[16], first: '|', sep: '|', last: '|')\n    print('+-----+-----+-----+-----+')\n\nfun format(puz, ch):\n    match ch.trim().length:\n        1 => '  $ch  '\n        2 => '  $ch '\n        0 => '     '\n\nfun change(puz, to):\n    let fro = puz.position\n    for a, b in puz.items where b == puz.format(str i):\n        to = a\n        break\n\n    swap(puz.items[fro], :[to])\n    puz.position = to;\n\nfun buildboard(puz, difficulty):\n    for i in 1..16:\n        puz.items[i] = puz.format(str i)\n\n    var tmp = a\n    for a, b in puz.items where b == '  16 ':\n        puz.items[a] = '     '\n            tmp = a\n            break\n\n    puz.position = tmp\n    let diff = match difficulty:\n        0 => 10\n        1 => 50\n        _ => 100\n\n    for i in 1..diff:\n        let lst = puz.validmoves()\n        let lst1 = []\n        for j in lst:\n            lst1.push! j.trim().int()\n        puz.change(lst1[random(1, lst1.length - 1)])\n\nfun validmoves(puz):\n    match puz.position:\n        6 | 7 | 10 | 11 =>\n            puz.items[pos - 4], :[pos - 1], :[pos + 1], :[pos + 4]\n        5 | 9 =>\n            puz.items[pos - 4], :[pos + 4], :[pos + 1]\n        8 | 12 =>\n            puz.items[pos - 4], :[pos + 4], :[pos - 1]\n        2 | 3 =>\n            puz.items[pos - 1], :[pos + 1], :[pos + 4]\n        14 | 15 =>\n            puz.items[pos - 1], :[pos + 1], :[pos - 4]\n        1 =>\n            puz.items[pos + 1], :[pos + 4]\n        4 =>\n            puz.items[pos - 1], :[pos + 4]\n        13 =>\n            puz.items[pos + 1], :[pos - 4]\n        16 =>\n            puz.items[pos - 1], :[pos - 4]\n\nfun mainframe(puz):\n    var flag = false\n    for a, b in puz.items:\n        if b == '     ':\n            pass\n        else:\n            flag = (a == b.trim().int())\n    ..\n    return flag\n\nlet game = Puzzle()\ngame.buildboard(\n    int(input('Enter the difficulty\u00a0: 0 1 2\\n2 => highest 0=> lowest\\n'))\n)\ngame.mainframe()\n\nprint 'Enter 0 to exit'\n\nloop:\n    print 'Hello user:\\nTo change the position just enter the no. near it'\n\n    var lst = game.validmoves()\n    var lst1 = []\n    for i in lst:\n        lst1.push! i.trim().int()\n        print(i.strip(), '\\t', last: '')\n\n    print()\n\n    let value = int(input())\n    if value == 0:\n        break\n    elif x not in lst1:\n        print('Wrong move')\n    else:\n        game.change(x)\n\n    game.mainframe()\n    if g.gameover():\n        print 'You WON'\n        break\n"}
{"id": 67056, "name": "15 puzzle game", "source": "Translate Ruby to Python: require 'io/console'\n\nclass Board\n  SIZE = 4\n  RANGE = 0...SIZE\n  \n  def initialize\n    width = (SIZE*SIZE-1).to_s.size\n    @frame = (\"+\" + \"-\"*(width+2)) * SIZE + \"+\"\n    @form = \"|\u00a0%\n    @step = 0\n    @orign = [*0...SIZE*SIZE].rotate.each_slice(SIZE).to_a.freeze\n    @board = @orign.map{|row | row.dup}\n    randomize\n    draw\n    message\n    play\n  end\n  \n  private\n  \n  def randomize\n    @board[0][0], @board[SIZE-1][SIZE-1] = 0, 1\n    @board[SIZE-1][0], @board[0][SIZE-1] = @board[0][SIZE-1], @board[SIZE-1][0]\n    x, y, dx, dy = 0, 0, 1, 0\n    50.times do\n      nx,ny = [[x+dx,y+dy], [x+dy,y-dx], [x-dy,y+dx]]\n                .select{|nx,ny| RANGE.include?(nx) and RANGE.include?(ny)}\n                .sample\n      @board[nx][ny], @board[x][y] = 0, @board[nx][ny]\n      x, y, dx, dy = nx, ny, nx-x, ny-y\n    end\n    @x, @y = x, y \n  end\n  \n  def draw\n    puts \"\\e[H\\e[2J\"\n    @board.each do |row|\n      puts @frame\n      puts (@form % row).sub(\" 0 \", \"   \")\n    end\n    puts @frame\n    puts \"Step: \n  end\n  \n  DIR = {up: [-1,0], down: [1,0], left: [0,-1], right: [0,1]}\n  def move(direction)\n    dx, dy = DIR[direction]\n    nx, ny = @x + dx, @y + dy\n    if RANGE.include?(nx) and RANGE.include?(ny)\n      @board[nx][ny], @board[@x][@y] = 0, @board[nx][ny]\n      @x, @y = nx, ny\n      @step += 1\n      draw\n    end\n  end\n  \n  def play\n    until @board == @orign\n      case  key_in\n      when \"\\e[A\", \"w\" then move(:up)\n      when \"\\e[B\", \"s\" then move(:down)\n      when \"\\e[C\", \"d\" then move(:right)\n      when \"\\e[D\", \"a\" then move(:left)\n      \n      when \"q\",\"\\u0003\",\"\\u0004\"  then exit\n      when \"h\"  then message\n      end\n    end\n    \n    puts \"Congratulations, you have won!\"\n  end\n  \n  def key_in\n    input = STDIN.getch\n    if input == \"\\e\" \n      2.times {input << STDIN.getch}\n    end\n    input\n  end\n  \n  def message\n    puts <<~EOM\n      Use the arrow-keys or WASD on your keyboard to push board in the given direction.   \n      PRESS q TO QUIT (or Ctrl-C or Ctrl-D)\n    EOM\n  end\nend\n\nBoard.new\n", "target": "type Puzzle(var items: {}, var position: -1)\n\nfun mainframe(puz):\n    let d = puz.items\n    print('+-----+-----+-----+-----+')\n    print(d[1], d[2], d[3], d[4], first: '|', sep: '|', last: '|')\n    print('+-----+-----+-----+-----+')\n    print(d[5], d[6], d[7], d[8], first: '|', sep: '|', last: '|')\n    print('+-----+-----+-----+-----+')\n    print(d[9], d[10], d[11], d[12], first: '|', sep: '|', last: '|')\n    print('+-----+-----+-----+-----+')\n    print(d[13], d[14], d[15], d[16], first: '|', sep: '|', last: '|')\n    print('+-----+-----+-----+-----+')\n\nfun format(puz, ch):\n    match ch.trim().length:\n        1 => '  $ch  '\n        2 => '  $ch '\n        0 => '     '\n\nfun change(puz, to):\n    let fro = puz.position\n    for a, b in puz.items where b == puz.format(str i):\n        to = a\n        break\n\n    swap(puz.items[fro], :[to])\n    puz.position = to;\n\nfun buildboard(puz, difficulty):\n    for i in 1..16:\n        puz.items[i] = puz.format(str i)\n\n    var tmp = a\n    for a, b in puz.items where b == '  16 ':\n        puz.items[a] = '     '\n            tmp = a\n            break\n\n    puz.position = tmp\n    let diff = match difficulty:\n        0 => 10\n        1 => 50\n        _ => 100\n\n    for i in 1..diff:\n        let lst = puz.validmoves()\n        let lst1 = []\n        for j in lst:\n            lst1.push! j.trim().int()\n        puz.change(lst1[random(1, lst1.length - 1)])\n\nfun validmoves(puz):\n    match puz.position:\n        6 | 7 | 10 | 11 =>\n            puz.items[pos - 4], :[pos - 1], :[pos + 1], :[pos + 4]\n        5 | 9 =>\n            puz.items[pos - 4], :[pos + 4], :[pos + 1]\n        8 | 12 =>\n            puz.items[pos - 4], :[pos + 4], :[pos - 1]\n        2 | 3 =>\n            puz.items[pos - 1], :[pos + 1], :[pos + 4]\n        14 | 15 =>\n            puz.items[pos - 1], :[pos + 1], :[pos - 4]\n        1 =>\n            puz.items[pos + 1], :[pos + 4]\n        4 =>\n            puz.items[pos - 1], :[pos + 4]\n        13 =>\n            puz.items[pos + 1], :[pos - 4]\n        16 =>\n            puz.items[pos - 1], :[pos - 4]\n\nfun mainframe(puz):\n    var flag = false\n    for a, b in puz.items:\n        if b == '     ':\n            pass\n        else:\n            flag = (a == b.trim().int())\n    ..\n    return flag\n\nlet game = Puzzle()\ngame.buildboard(\n    int(input('Enter the difficulty\u00a0: 0 1 2\\n2 => highest 0=> lowest\\n'))\n)\ngame.mainframe()\n\nprint 'Enter 0 to exit'\n\nloop:\n    print 'Hello user:\\nTo change the position just enter the no. near it'\n\n    var lst = game.validmoves()\n    var lst1 = []\n    for i in lst:\n        lst1.push! i.trim().int()\n        print(i.strip(), '\\t', last: '')\n\n    print()\n\n    let value = int(input())\n    if value == 0:\n        break\n    elif x not in lst1:\n        print('Wrong move')\n    else:\n        game.change(x)\n\n    game.mainframe()\n    if g.gameover():\n        print 'You WON'\n        break\n"}
{"id": 67322, "name": "Sorting algorithms_Counting sort", "source": "Translate Ruby to C#: class Array\n  def counting_sort!\n    replace counting_sort\n  end\n  \n  def counting_sort\n    min, max = minmax\n    count = Array.new(max - min + 1, 0)\n    each {|number| count[number - min] += 1}\n    (min..max).each_with_object([]) {|i, ary| ary.concat([i] * count[i - min])}\n  end\nend\n\nary = [9,7,10,2,9,7,4,3,10,2,7,10,2,1,3,8,7,3,9,5,8,5,1,6,3,7,5,4,6,9,9,6,6,10,2,4,5,2,8,2,2,5,2,9,3,3,5,7,8,4]\np ary.counting_sort.join(\",\")\n\n\np ary = Array.new(20){rand(-10..10)}\n\np ary.counting_sort\n\n", "target": "using System;\nusing System.Linq;\n\nnamespace CountingSort\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            Random rand = new Random();                                   \n            int[] arr = new int[100];                                     \n            for (int i = 0; i < 100; i++) { arr[i] = rand.Next(0, 100); } \n\n            int[] newarr = countingSort(arr, arr.Min(), arr.Max());\n        }\n\n        private static int[] countingSort(int[] arr, int min, int max)\n        {\n            int[] count = new int[max - min + 1];\n            int z = 0;\n\n            for (int i = 0; i < count.Length; i++) { count[i] = 0; }\n            for (int i = 0; i < arr.Length; i++) { count[arr[i] - min]++; }           \n\n            for (int i = min; i <= max; i++)\n            {\n                while (count[i - min]-- > 0)\n                {\n                    arr[z] = i;\n                    z++;                    \n                }\n            }\n            return arr;\n        }\n    }\n}\n"}
{"id": 67324, "name": "Sorting algorithms_Counting sort", "source": "Translate Ruby to Java: class Array\n  def counting_sort!\n    replace counting_sort\n  end\n  \n  def counting_sort\n    min, max = minmax\n    count = Array.new(max - min + 1, 0)\n    each {|number| count[number - min] += 1}\n    (min..max).each_with_object([]) {|i, ary| ary.concat([i] * count[i - min])}\n  end\nend\n\nary = [9,7,10,2,9,7,4,3,10,2,7,10,2,1,3,8,7,3,9,5,8,5,1,6,3,7,5,4,6,9,9,6,6,10,2,4,5,2,8,2,2,5,2,9,3,3,5,7,8,4]\np ary.counting_sort.join(\",\")\n\n\np ary = Array.new(20){rand(-10..10)}\n\np ary.counting_sort\n\n", "target": "public static void countingSort(int[] array, int min, int max){\n\tint[] count= new int[max - min + 1];\n\tfor(int number : array){\n\t\tcount[number - min]++;\n\t}\n\tint z= 0;\n\tfor(int i= min;i <= max;i++){\n\t\twhile(count[i - min] > 0){\n\t\t\tarray[z]= i;\n\t\t\tz++;\n\t\t\tcount[i - min]--;\n\t\t}\n\t}\n}\n"}
{"id": 67325, "name": "Sorting algorithms_Counting sort", "source": "Translate Ruby to Python: class Array\n  def counting_sort!\n    replace counting_sort\n  end\n  \n  def counting_sort\n    min, max = minmax\n    count = Array.new(max - min + 1, 0)\n    each {|number| count[number - min] += 1}\n    (min..max).each_with_object([]) {|i, ary| ary.concat([i] * count[i - min])}\n  end\nend\n\nary = [9,7,10,2,9,7,4,3,10,2,7,10,2,1,3,8,7,3,9,5,8,5,1,6,3,7,5,4,6,9,9,6,6,10,2,4,5,2,8,2,2,5,2,9,3,3,5,7,8,4]\np ary.counting_sort.join(\",\")\n\n\np ary = Array.new(20){rand(-10..10)}\n\np ary.counting_sort\n\n", "target": ">>> from collections import defaultdict\n>>> def countingSort(array, mn, mx):\n\tcount = defaultdict(int)\n\tfor i in array:\n\t\tcount[i] += 1\n\tresult = []\n\tfor j in range(mn,mx+1):\n\t\tresult += [j]* count[j]\n\treturn result\n\n>>> data = [9, 7, 10, 2, 9, 7, 4, 3, 10, 2, 7, 10, 2, 1, 3, 8, 7, 3, 9, 5, 8, 5, 1, 6, 3, 7, 5, 4, 6, 9, 9, 6, 6, 10, 2, 4, 5, 2, 8, 2, 2, 5, 2, 9, 3, 3, 5, 7, 8, 4]\n>>> mini,maxi = 1,10\n>>> countingSort(data, mini, maxi) == sorted(data)\nTrue\n"}
{"id": 67784, "name": "Array length", "source": "Translate Ruby to C#: puts [\"apple\", \"orange\"].size\n", "target": "using System;\n\nnamespace ArrayLength\n{\n  class Program\n  {\n    public static void Main()\n    {\n      var array = new String[](\"apple\", \"orange\");\n      Console.WriteLine(array.Count);\n      delete(array);\n    }\n  }\n}\n"}
{"id": 67785, "name": "Array length", "source": "Translate Ruby to C#: puts [\"apple\", \"orange\"].size\n", "target": "using System;\n\nnamespace ArrayLength\n{\n  class Program\n  {\n    public static void Main()\n    {\n      var array = new String[](\"apple\", \"orange\");\n      Console.WriteLine(array.Count);\n      delete(array);\n    }\n  }\n}\n"}
{"id": 68095, "name": "Bulls and cows", "source": "Translate Ruby to C#: size = 4\nsecret = ('1'..'9').to_a.sample(size)\nguess = [] of Char\n\ni = 0\nloop do\n  i += 1\n  loop do\n    print \"Guess \n    guess = gets.not_nil!.chomp.chars\n    exit if guess.empty?\n\n    break if guess.size == size &&\n             guess.all? { |x| ('1'..'9').includes? x } &&\n             guess.uniq.size == size\n\n    puts \"Problem, try again. You need to enter \n  end\n\n  if guess == secret\n    puts \"Congratulations you guessed correctly in \n    break\n  end\n\n  bulls = cows = 0\n  size.times do |j|\n    if guess[j] == secret[j]\n      bulls += 1\n    elsif secret.includes? guess[j]\n      cows += 1\n    end\n  end\n\n  puts \"Bulls: \nend\n", "target": "using System;\n\nnamespace BullsnCows\n{\n    class Program\n    {\n        \n        static void Main(string[] args)\n        {\n            int[] nums = new int[] { 1, 2, 3, 4, 5, 6, 7, 8, 9 };\n            KnuthShuffle<int>(ref nums);\n            int[] chosenNum = new int[4];\n            Array.Copy(nums, chosenNum, 4);\n\n            Console.WriteLine(\"Your Guess\u00a0?\");\n            while (!game(Console.ReadLine(), chosenNum))\n            {\n                Console.WriteLine(\"Your next Guess\u00a0?\");\n            }\n            \n            Console.ReadKey();\n        }\n\n        public static void KnuthShuffle<T>(ref T[] array)\n        {\n            System.Random random = new System.Random();\n            for (int i = 0; i < array.Length; i++)\n            {\n                int j = random.Next(array.Length);\n                T temp = array[i]; array[i] = array[j]; array[j] = temp;\n            }\n        }\n\n        public static bool game(string guess, int[] num)\n        {\n            char[] guessed = guess.ToCharArray();\n            int bullsCount = 0, cowsCount = 0;\n\n            if (guessed.Length != 4)\n            {\n                Console.WriteLine(\"Not a valid guess.\");\n                return false;\n            }\n\n            for (int i = 0; i < 4; i++)\n            {\n                int curguess = (int) char.GetNumericValue(guessed[i]);\n                if (curguess < 1 || curguess > 9)\n                {\n                    Console.WriteLine(\"Digit must be ge greater 0 and lower 10.\");\n                    return false;\n                }\n                if (curguess == num[i])\n                {\n                    bullsCount++;\n                }\n                else\n                {\n                    for (int j = 0; j < 4; j++)\n                    {\n                        if (curguess == num[j])\n                            cowsCount++;\n                    }\n                }\n            }\n\n            if (bullsCount == 4)\n            {\n                Console.WriteLine(\"Congratulations! You have won!\");\n                return true;\n            }\n            else\n            {\n                Console.WriteLine(\"Your Score is {0} bulls and {1} cows\", bullsCount, cowsCount);\n                return false;\n            }\n        }\n    }\n}\n"}
{"id": 68097, "name": "Bulls and cows", "source": "Translate Ruby to Python: size = 4\nsecret = ('1'..'9').to_a.sample(size)\nguess = [] of Char\n\ni = 0\nloop do\n  i += 1\n  loop do\n    print \"Guess \n    guess = gets.not_nil!.chomp.chars\n    exit if guess.empty?\n\n    break if guess.size == size &&\n             guess.all? { |x| ('1'..'9').includes? x } &&\n             guess.uniq.size == size\n\n    puts \"Problem, try again. You need to enter \n  end\n\n  if guess == secret\n    puts \"Congratulations you guessed correctly in \n    break\n  end\n\n  bulls = cows = 0\n  size.times do |j|\n    if guess[j] == secret[j]\n      bulls += 1\n    elsif secret.includes? guess[j]\n      cows += 1\n    end\n  end\n\n  puts \"Bulls: \nend\n", "target": "\n\nimport random\n\ndigits = '123456789'\nsize = 4\nchosen = ''.join(random.sample(digits,size))\n\nprint  % (size, size)\nguesses = 0\nwhile True:\n    guesses += 1\n    while True:\n        \n        guess = raw_input('\\nNext guess [%i]: ' % guesses).strip()\n        if len(guess) == size and \\\n           all(char in digits for char in guess) \\\n           and len(set(guess)) == size:\n            break\n        print \"Problem, try again. You need to enter %i unique digits from 1 to 9\" % size\n    if guess == chosen:\n        print '\\nCongratulations you guessed correctly in',guesses,'attempts'\n        break\n    bulls = cows = 0\n    for i in range(size):\n        if guess[i] == chosen[i]:\n            bulls += 1\n        elif guess[i] in chosen:\n            cows += 1\n    print '  %i Bulls\\n  %i Cows' % (bulls, cows)\n"}
{"id": 68273, "name": "Chowla numbers", "source": "Translate Ruby to C#: def chowla(n)\n    sum = 0\n    i = 2\n    while i * i <= n do\n        if n % i == 0 then\n            sum = sum + i\n            j = n / i\n            if i != j then\n                sum = sum + j\n            end\n        end\n        i = i + 1\n    end\n    return sum\nend\n\ndef main\n    for n in 1 .. 37 do\n        puts \"chowla(%d) = %d\" % [n, chowla(n)]\n    end\n\n    count = 0\n    power = 100\n    for n in 2 .. 10000000 do\n        if chowla(n) == 0 then\n            count = count + 1\n        end\n        if n % power == 0 then\n            puts \"There are %d primes < %d\" % [count, power]\n            power = power * 10\n        end\n    end\n\n    count = 0\n    limit = 350000000\n    k = 2\n    kk = 3\n    loop do\n        p = k * kk\n        if p > limit then\n            break\n        end\n        if chowla(p) == p - 1 then\n            puts \"%d is a perfect number\" % [p]\n            count = count + 1\n        end\n        k = kk + 1\n        kk = kk + k\n    end\n    puts \"There are %d perfect numbers < %d\" % [count, limit]\nend\n\nmain()\n", "target": "using System;\n\nnamespace chowla_cs\n{\n    class Program\n    {\n        static int chowla(int n)\n        {\n            int sum = 0;\n            for (int i = 2, j; i * i <= n; i++)\n                if (n % i == 0) sum += i + (i == (j = n / i) ? 0 : j);\n            return sum;\n        }\n\n        static bool[] sieve(int limit)\n        {\n            \n            \n            bool[] c = new bool[limit];\n            for (int i = 3; i * 3 < limit; i += 2)\n                if (!c[i] && (chowla(i) == 0))\n                    for (int j = 3 * i; j < limit; j += 2 * i)\n                        c[j] = true;\n            return c;\n        }\n\n        static void Main(string[] args)\n        {\n            for (int i = 1; i <= 37; i++)\n                Console.WriteLine(\"chowla({0}) = {1}\", i, chowla(i));\n            int count = 1, limit = (int)(1e7), power = 100;\n            bool[] c = sieve(limit);\n            for (int i = 3; i < limit; i += 2)\n            {\n                if (!c[i]) count++;\n                if (i == power - 1)\n                {\n                    Console.WriteLine(\"Count of primes up to {0,10:n0} = {1:n0}\", power, count);\n                    power *= 10;\n                }\n            }\n\n            count = 0; limit = 35000000;\n            int k = 2, kk = 3, p;\n            for (int i = 2; ; i++)\n            {\n                if ((p = k * kk) > limit) break;\n                if (chowla(p) == p - 1)\n                {\n                    Console.WriteLine(\"{0,10:n0} is a number that is perfect\", p);\n                    count++;\n                }\n                k = kk + 1; kk += k;\n            }\n            Console.WriteLine(\"There are {0} perfect numbers <= 35,000,000\", count);\n            if (System.Diagnostics.Debugger.IsAttached) Console.ReadKey();\n        }\n    }\n}\n"}
{"id": 68275, "name": "Chowla numbers", "source": "Translate Ruby to Java: def chowla(n)\n    sum = 0\n    i = 2\n    while i * i <= n do\n        if n % i == 0 then\n            sum = sum + i\n            j = n / i\n            if i != j then\n                sum = sum + j\n            end\n        end\n        i = i + 1\n    end\n    return sum\nend\n\ndef main\n    for n in 1 .. 37 do\n        puts \"chowla(%d) = %d\" % [n, chowla(n)]\n    end\n\n    count = 0\n    power = 100\n    for n in 2 .. 10000000 do\n        if chowla(n) == 0 then\n            count = count + 1\n        end\n        if n % power == 0 then\n            puts \"There are %d primes < %d\" % [count, power]\n            power = power * 10\n        end\n    end\n\n    count = 0\n    limit = 350000000\n    k = 2\n    kk = 3\n    loop do\n        p = k * kk\n        if p > limit then\n            break\n        end\n        if chowla(p) == p - 1 then\n            puts \"%d is a perfect number\" % [p]\n            count = count + 1\n        end\n        k = kk + 1\n        kk = kk + k\n    end\n    puts \"There are %d perfect numbers < %d\" % [count, limit]\nend\n\nmain()\n", "target": "public class Chowla {\n\n    public static void main(String[] args) {\n        int[] chowlaNumbers = findChowlaNumbers(37);\n        for (int i = 0; i < chowlaNumbers.length; i++) {\n            System.out.printf(\"chowla(%d) = %d%n\", (i+1), chowlaNumbers[i]);\n        }\n        System.out.println();\n\n        int[][] primes = countPrimes(100, 10_000_000);\n        for (int i = 0; i < primes.length; i++) {\n            System.out.printf(Locale.US, \"There is\u00a0%,d primes up to\u00a0%,d%n\", primes[i][1], primes[i][0]);\n        }\n        System.out.println();\n\n        int[] perfectNumbers = findPerfectNumbers(35_000_000);\n        for (int i = 0; i < perfectNumbers.length; i++) {\n            System.out.printf(\"%d is a perfect number%n\", perfectNumbers[i]);\n        }\n        System.out.printf(Locale.US, \"There are %d perfect numbers <\u00a0%,d%n\", perfectNumbers.length, 35_000_000);\n    }\n\n    public static int chowla(int n) {\n        if (n < 0) throw new IllegalArgumentException(\"n is not positive\");\n        int sum = 0;\n        for (int i = 2, j; i * i <= n; i++)\n            if (n % i == 0) sum += i + (i == (j = n / i) ? 0 : j);\n        return sum;\n    }\n\n    protected static int[][] countPrimes(int power, int limit) {\n        int count = 0;\n        int[][] num = new int[countMultiplicity(limit, power)][2];\n        for (int n = 2, i=0;  n <= limit; n++) {\n            if (chowla(n) == 0) count++;\n            if (n % power == 0) {\n                num[i][0] = power;\n                num[i][1] = count;\n                i++;\n                power *= 10;\n            }\n        }\n        return num;\n    }\n\n    protected static int countMultiplicity(int limit, int start) {\n        int count = 0;\n        int cur = limit;\n        while(cur >= start) {\n            count++;\n            cur = cur/10;\n        }\n        return count;\n    }\n\n    protected static int[] findChowlaNumbers(int limit) {\n        int[] num = new int[limit];\n        for (int i = 0; i < limit; i++) {\n            num[i] = chowla(i+1);\n        }\n        return num;\n    }\n\n    protected static int[] findPerfectNumbers(int limit) {\n        int count = 0;\n        int[] num = new int[count];\n\n        int k = 2, kk = 3, p;\n        while ((p = k * kk) < limit) {\n            if (chowla(p) == p - 1) {\n                num = increaseArr(num);\n                num[count++] = p;\n            }\n            k = kk + 1;\n            kk += k;\n        }\n        return num;\n    }\n\n    private static int[] increaseArr(int[] arr) {\n        int[] tmp = new int[arr.length + 1];\n        System.arraycopy(arr, 0, tmp, 0, arr.length);\n        return tmp;\n    }\n}\n"}
{"id": 68276, "name": "Chowla numbers", "source": "Translate Ruby to Python: def chowla(n)\n    sum = 0\n    i = 2\n    while i * i <= n do\n        if n % i == 0 then\n            sum = sum + i\n            j = n / i\n            if i != j then\n                sum = sum + j\n            end\n        end\n        i = i + 1\n    end\n    return sum\nend\n\ndef main\n    for n in 1 .. 37 do\n        puts \"chowla(%d) = %d\" % [n, chowla(n)]\n    end\n\n    count = 0\n    power = 100\n    for n in 2 .. 10000000 do\n        if chowla(n) == 0 then\n            count = count + 1\n        end\n        if n % power == 0 then\n            puts \"There are %d primes < %d\" % [count, power]\n            power = power * 10\n        end\n    end\n\n    count = 0\n    limit = 350000000\n    k = 2\n    kk = 3\n    loop do\n        p = k * kk\n        if p > limit then\n            break\n        end\n        if chowla(p) == p - 1 then\n            puts \"%d is a perfect number\" % [p]\n            count = count + 1\n        end\n        k = kk + 1\n        kk = kk + k\n    end\n    puts \"There are %d perfect numbers < %d\" % [count, limit]\nend\n\nmain()\n", "target": "\nfrom sympy import divisors\n\ndef chowla(n):\n    return 0 if n < 2 else sum(divisors(n, generator=True)) - 1 -n\n\ndef is_prime(n):\n    return chowla(n) == 0\n\ndef primes_to(n):\n    return sum(chowla(i) == 0 for i in range(2, n))\n\ndef perfect_between(n, m):\n    c = 0\n    print(f\"\\nPerfect numbers between [{n:_}, {m:_})\")\n    for i in range(n, m):\n        if i > 1 and chowla(i) == i - 1:\n            print(f\"  {i:_}\")\n            c += 1\n    print(f\"Found {c} Perfect numbers between [{n:_}, {m:_})\")\n    \n\nif __name__ == '__main__':\n    for i in range(1, 38):\n        print(f\"chowla({i:2}) == {chowla(i)}\")\n    for i in range(2, 6):\n        print(f\"primes_to({10**i:_}) == {primes_to(10**i):_}\")\n    perfect_between(1, 1_000_000)\n    print()\n    for i in range(6, 8):\n        print(f\"primes_to({10**i:_}) == {primes_to(10**i):_}\")\n    perfect_between(1_000_000, 35_000_000)\n"}
{"id": 68658, "name": "Accumulator factory", "source": "Translate Ruby to C#: def accumulator(sum)\n  lambda {|n| sum += n}\nend\n\n\nx = accumulator(1)\nx.call(5)\naccumulator(3)\nputs x.call(2.3)  \n", "target": "using System;\n\nclass Program\n{\n    static Func<dynamic, dynamic> Foo(dynamic n)\n    {\n        return i => n += i;\n    }\n\n    static void Main(string[] args)\n    {\n        var x = Foo(1);\n        x(5);\n        Foo(3);\n        Console.WriteLine(x(2.3));\n    }\n}\n"}
{"id": 68659, "name": "Accumulator factory", "source": "Translate Ruby to C#: def accumulator(sum)\n  lambda {|n| sum += n}\nend\n\n\nx = accumulator(1)\nx.call(5)\naccumulator(3)\nputs x.call(2.3)  \n", "target": "using System;\n\nclass Program\n{\n    static Func<dynamic, dynamic> Foo(dynamic n)\n    {\n        return i => n += i;\n    }\n\n    static void Main(string[] args)\n    {\n        var x = Foo(1);\n        x(5);\n        Foo(3);\n        Console.WriteLine(x(2.3));\n    }\n}\n"}
{"id": 68662, "name": "Accumulator factory", "source": "Translate Ruby to Java: def accumulator(sum)\n  lambda {|n| sum += n}\nend\n\n\nx = accumulator(1)\nx.call(5)\naccumulator(3)\nputs x.call(2.3)  \n", "target": "public class Accumulator\n    \n{\n    private Number sum;\n\n    public Accumulator(Number sum0) {\n\tsum = sum0;\n    }\n\n    public Number apply(Number n) {\n\t\n\t\n\treturn (longable(sum) && longable(n)) ?\n\t    (sum = sum.longValue() + n.longValue()) :\n\t    (sum = sum.doubleValue() + n.doubleValue());\n    }\n\n    private static boolean longable(Number n) {\n\treturn n instanceof Byte || n instanceof Short ||\n\t    n instanceof Integer || n instanceof Long;\n    }\n\n    public static void main(String[] args) {\n\tAccumulator x = new Accumulator(1);\n\tx.apply(5);\n\tnew Accumulator(3);\n\tSystem.out.println(x.apply(2.3));\n    }\n}\n"}
{"id": 68663, "name": "Accumulator factory", "source": "Translate Ruby to Java: def accumulator(sum)\n  lambda {|n| sum += n}\nend\n\n\nx = accumulator(1)\nx.call(5)\naccumulator(3)\nputs x.call(2.3)  \n", "target": "public class Accumulator\n    \n{\n    private Number sum;\n\n    public Accumulator(Number sum0) {\n\tsum = sum0;\n    }\n\n    public Number apply(Number n) {\n\t\n\t\n\treturn (longable(sum) && longable(n)) ?\n\t    (sum = sum.longValue() + n.longValue()) :\n\t    (sum = sum.doubleValue() + n.doubleValue());\n    }\n\n    private static boolean longable(Number n) {\n\treturn n instanceof Byte || n instanceof Short ||\n\t    n instanceof Integer || n instanceof Long;\n    }\n\n    public static void main(String[] args) {\n\tAccumulator x = new Accumulator(1);\n\tx.apply(5);\n\tnew Accumulator(3);\n\tSystem.out.println(x.apply(2.3));\n    }\n}\n"}
{"id": 68664, "name": "Accumulator factory", "source": "Translate Ruby to Python: def accumulator(sum)\n  lambda {|n| sum += n}\nend\n\n\nx = accumulator(1)\nx.call(5)\naccumulator(3)\nputs x.call(2.3)  \n", "target": "fun accumulator(var sum): :: Real -> _\n    n => sum += n\n\nlet f = accumulator!(5)\nprint f(5)   \nprint f(10)  \nprint f(2.4) \n"}
{"id": 68665, "name": "Accumulator factory", "source": "Translate Ruby to Python: def accumulator(sum)\n  lambda {|n| sum += n}\nend\n\n\nx = accumulator(1)\nx.call(5)\naccumulator(3)\nputs x.call(2.3)  \n", "target": "fun accumulator(var sum): :: Real -> _\n    n => sum += n\n\nlet f = accumulator!(5)\nprint f(5)   \nprint f(10)  \nprint f(2.4) \n"}
{"id": 68908, "name": "XML_DOM serialization", "source": "Translate Ruby to C#: require(\"rexml/document\")\ninclude REXML\n(doc = Document.new) << XMLDecl.new\nroot = doc.add_element('root')\nelement = root.add_element('element')\nelement.add_text('Some text here')\n\n\n\nserialized = String.new\ndoc.write(serialized, 4)\nputs serialized\n", "target": "using System.Xml;\nusing System.Xml.Serialization;\n[XmlRoot(\"root\")]\npublic class ExampleXML\n{\n    [XmlElement(\"element\")]\n    public string element = \"Some text here\";\n    static void Main(string[] args)\n    {\n        var xmlnamespace = new XmlSerializerNamespaces();\n        xmlnamespace.Add(\"\", \"\"); \n        var writer = XmlWriter.Create(\"output.xml\");\n        new XmlSerializer(typeof(ExampleXML)).Serialize(writer, new ExampleXML(), xmlnamespace);\n    }\n    \n}\n"}
{"id": 68910, "name": "XML_DOM serialization", "source": "Translate Ruby to Java: require(\"rexml/document\")\ninclude REXML\n(doc = Document.new) << XMLDecl.new\nroot = doc.add_element('root')\nelement = root.add_element('element')\nelement.add_text('Some text here')\n\n\n\nserialized = String.new\ndoc.write(serialized, 4)\nputs serialized\n", "target": "import java.io.StringWriter;\n\nimport javax.xml.parsers.DocumentBuilder;\nimport javax.xml.parsers.DocumentBuilderFactory;\nimport javax.xml.parsers.ParserConfigurationException;\nimport javax.xml.transform.OutputKeys;\nimport javax.xml.transform.Transformer;\nimport javax.xml.transform.TransformerConfigurationException;\nimport javax.xml.transform.TransformerException;\nimport javax.xml.transform.TransformerFactory;\nimport javax.xml.transform.TransformerFactoryConfigurationError;\nimport javax.xml.transform.dom.DOMSource;\nimport javax.xml.transform.stream.StreamResult;\n\nimport org.w3c.dom.DOMImplementation;\nimport org.w3c.dom.Document;\nimport org.w3c.dom.Element;\n\npublic class RDOMSerialization {\n\n  private Document domDoc;\n\n  public RDOMSerialization() {\n    return;\n  }\n\n  protected void buildDOMDocument() {\n\n    DocumentBuilderFactory factory;\n    DocumentBuilder builder;\n    DOMImplementation impl;\n    Element elmt1;\n    Element elmt2;\n\n    try {\n      factory = DocumentBuilderFactory.newInstance();\n      builder = factory.newDocumentBuilder();\n      impl = builder.getDOMImplementation();\n      domDoc = impl.createDocument(null, null, null);\n      elmt1 = domDoc.createElement(\"root\");\n      elmt2 = domDoc.createElement(\"element\");\n      elmt2.setTextContent(\"Some text here\");\n\n      domDoc.appendChild(elmt1);\n      elmt1.appendChild(elmt2);\n    }\n    catch (ParserConfigurationException ex) {\n      ex.printStackTrace();\n    }\n\n    return;\n  }\n\n  protected void serializeXML() {\n\n    DOMSource domSrc;\n    Transformer txformer;\n    StringWriter sw;\n    StreamResult sr;\n\n    try {\n      domSrc = new DOMSource(domDoc);\n\n      txformer = TransformerFactory.newInstance().newTransformer();\n      txformer.setOutputProperty(OutputKeys.OMIT_XML_DECLARATION, \"no\");\n      txformer.setOutputProperty(OutputKeys.METHOD, \"xml\");\n      txformer.setOutputProperty(OutputKeys.ENCODING, \"UTF-8\");\n      txformer.setOutputProperty(OutputKeys.INDENT, \"yes\");\n      txformer.setOutputProperty(OutputKeys.STANDALONE, \"yes\");\n      txformer.setOutputProperty(\"{http:\n\n      sw = new StringWriter();\n      sr = new StreamResult(sw);\n\n      txformer.transform(domSrc, sr);\n\n      System.out.println(sw.toString());\n    }\n    catch (TransformerConfigurationException ex) {\n      ex.printStackTrace();\n    }\n    catch (TransformerFactoryConfigurationError ex) {\n      ex.printStackTrace();\n    }\n    catch (TransformerException ex) {\n      ex.printStackTrace();\n    }\n\n    return;\n  }\n\n  public static void serializationDriver(String[] args) {\n\n    RDOMSerialization lcl = new RDOMSerialization();\n    lcl.buildDOMDocument();\n    lcl.serializeXML();\n\n    return;\n  }\n\n  public static void main(String[] args) {\n    serializationDriver(args);\n    return;\n  }\n}\n"}
{"id": 68911, "name": "XML_DOM serialization", "source": "Translate Ruby to Python: require(\"rexml/document\")\ninclude REXML\n(doc = Document.new) << XMLDecl.new\nroot = doc.add_element('root')\nelement = root.add_element('element')\nelement.add_text('Some text here')\n\n\n\nserialized = String.new\ndoc.write(serialized, 4)\nputs serialized\n", "target": "from xml.dom.minidom import getDOMImplementation\n\ndom = getDOMImplementation()\ndocument = dom.createDocument(None, \"root\", None)\n\ntopElement = document.documentElement\nfirstElement = document.createElement(\"element\")\ntopElement.appendChild(firstElement)\ntextNode = document.createTextNode(\"Some text here\")\nfirstElement.appendChild(textNode)\n\nxmlString = document.toprettyxml(\" \" * 4)\n"}
{"id": 69356, "name": "Averages_Root mean square", "source": "Translate Ruby to C#: def rms(seq)\n  Math.sqrt(seq.sum { |x| x*x } / seq.size)\nend\n\nputs rms (1..10).to_a\n", "target": "using System;\n\nnamespace rms\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            int[] x = new int[] { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };\n            Console.WriteLine(rootMeanSquare(x));\n        }\n\n        private static double rootMeanSquare(int[] x)\n        {            \n            double sum = 0;\n            for (int i = 0; i < x.Length; i++)\n            {\n                sum += (x[i]*x[i]);\n            }\n            return Math.Sqrt(sum / x.Length);\n        }\n    }\n}\n"}
{"id": 69357, "name": "Averages_Root mean square", "source": "Translate Ruby to C#: def rms(seq)\n  Math.sqrt(seq.sum { |x| x*x } / seq.size)\nend\n\nputs rms (1..10).to_a\n", "target": "using System;\n\nnamespace rms\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            int[] x = new int[] { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };\n            Console.WriteLine(rootMeanSquare(x));\n        }\n\n        private static double rootMeanSquare(int[] x)\n        {            \n            double sum = 0;\n            for (int i = 0; i < x.Length; i++)\n            {\n                sum += (x[i]*x[i]);\n            }\n            return Math.Sqrt(sum / x.Length);\n        }\n    }\n}\n"}
{"id": 69360, "name": "Averages_Root mean square", "source": "Translate Ruby to Java: def rms(seq)\n  Math.sqrt(seq.sum { |x| x*x } / seq.size)\nend\n\nputs rms (1..10).to_a\n", "target": "public class RootMeanSquare {\n\n    public static double rootMeanSquare(double... nums) {\n        double sum = 0.0;\n        for (double num : nums)\n            sum += num * num;\n        return Math.sqrt(sum / nums.length);\n    }\n\n    public static void main(String[] args) {\n        double[] nums = {1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0};\n        System.out.println(\"The RMS of the numbers from 1 to 10 is \" + rootMeanSquare(nums));\n    }\n}\n"}
{"id": 69361, "name": "Averages_Root mean square", "source": "Translate Ruby to Java: def rms(seq)\n  Math.sqrt(seq.sum { |x| x*x } / seq.size)\nend\n\nputs rms (1..10).to_a\n", "target": "public class RootMeanSquare {\n\n    public static double rootMeanSquare(double... nums) {\n        double sum = 0.0;\n        for (double num : nums)\n            sum += num * num;\n        return Math.sqrt(sum / nums.length);\n    }\n\n    public static void main(String[] args) {\n        double[] nums = {1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0};\n        System.out.println(\"The RMS of the numbers from 1 to 10 is \" + rootMeanSquare(nums));\n    }\n}\n"}
{"id": 69362, "name": "Averages_Root mean square", "source": "Translate Ruby to Python: def rms(seq)\n  Math.sqrt(seq.sum { |x| x*x } / seq.size)\nend\n\nputs rms (1..10).to_a\n", "target": "sqrt(mean(x\u00b2))\n"}
{"id": 69363, "name": "Averages_Root mean square", "source": "Translate Ruby to Python: def rms(seq)\n  Math.sqrt(seq.sum { |x| x*x } / seq.size)\nend\n\nputs rms (1..10).to_a\n", "target": "sqrt(mean(x\u00b2))\n"}
{"id": 69562, "name": "Scope modifiers", "source": "Translate Ruby to C#: class Demo\n  \n  \n  protected\n  \n\n  private\n  \nend\n", "target": "public \nprotected \ninternal \nprotected internal \nprivate \n\nprivate protected \n\n\n\n\n\n\n\n\n\n\n\n"}
{"id": 69563, "name": "Scope modifiers", "source": "Translate Ruby to Java: class Demo\n  \n  \n  protected\n  \n\n  private\n  \nend\n", "target": "public \n\nprotected \n\n\nprivate \n\nstatic \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\npublic void function(int x){\n   \n   int y;\n   \n   {\n      int z;\n      \n   }\n   \n}\n"}
{"id": 69564, "name": "Scope modifiers", "source": "Translate Ruby to Python: class Demo\n  \n  \n  protected\n  \n\n  private\n  \nend\n", "target": ">>> x=\"From global scope\"\n>>> def outerfunc():\n    x = \"From scope at outerfunc\"\n\n    def scoped_local():\n        x = \"scope local\"\n        return \"scoped_local scope gives x = \" + x\n    print(scoped_local())\n\n    def scoped_nonlocal():\n        nonlocal x\n        return \"scoped_nonlocal scope gives x = \" + x\n    print(scoped_nonlocal())\n\n    def scoped_global():\n        global x\n        return \"scoped_global scope gives x = \" + x\n    print(scoped_global())\n\n    def scoped_notdefinedlocally():\n        return \"scoped_notdefinedlocally scope gives x = \" + x\n    print(scoped_notdefinedlocally())\n\n    \n>>> outerfunc()\nscoped_local scope gives x = scope local\nscoped_nonlocal scope gives x = From scope at outerfunc\nscoped_global scope gives x = From global scope\nscoped_notdefinedlocally scope gives x = From global scope\n>>>\n"}
{"id": 69760, "name": "Pi", "source": "Translate Ruby to C#: require \"big\"\n\ndef pi\n  q, r, t, k, n, l = [1, 0, 1, 1, 3, 3].map { |n| BigInt.new(n) }\n  dot_written = false\n  loop do\n    if 4*q + r - t < n*t\n      yield n\n      unless dot_written\n        yield '.'\n        dot_written = true\n      end\n      nr = 10*(r - n*t)\n      n = ((10*(3*q + r)) / t) - 10*n\n      q *= 10\n      r = nr\n    else\n      nr = (2*q + r) * l\n      nn = (q*(7*k + 2) + r*l) / (t*l)\n      q *= k\n      t *= l\n      l += 2\n      k += 1\n      n = nn\n      r = nr\n    end\n  end\nend\n\npi { |digit_or_dot| print digit_or_dot; STDOUT.flush }\n", "target": "using System;\nusing System.Numerics;\n\nnamespace PiCalc {\n    internal class Program {\n        private readonly BigInteger FOUR = new BigInteger(4);\n        private readonly BigInteger SEVEN = new BigInteger(7);\n        private readonly BigInteger TEN = new BigInteger(10);\n        private readonly BigInteger THREE = new BigInteger(3);\n        private readonly BigInteger TWO = new BigInteger(2);\n\n        private BigInteger k = BigInteger.One;\n        private BigInteger l = new BigInteger(3);\n        private BigInteger n = new BigInteger(3);\n        private BigInteger q = BigInteger.One;\n        private BigInteger r = BigInteger.Zero;\n        private BigInteger t = BigInteger.One;\n\n        public void CalcPiDigits() {\n            BigInteger nn, nr;\n            bool first = true;\n            while (true) {\n                if ((FOUR*q + r - t).CompareTo(n*t) == -1) {\n                    Console.Write(n);\n                    if (first) {\n                        Console.Write(\".\");\n                        first = false;\n                    }\n                    nr = TEN*(r - (n*t));\n                    n = TEN*(THREE*q + r)/t - (TEN*n);\n                    q *= TEN;\n                    r = nr;\n                } else {\n                    nr = (TWO*q + r)*l;\n                    nn = (q*(SEVEN*k) + TWO + r*l)/(t*l);\n                    q *= k;\n                    t *= l;\n                    l += TWO;\n                    k += BigInteger.One;\n                    n = nn;\n                    r = nr;\n                }\n            }\n        }\n\n        private static void Main(string[] args) {\n            new Program().CalcPiDigits();\n        }\n    }\n}\n"}
{"id": 69762, "name": "Pi", "source": "Translate Ruby to Java: require \"big\"\n\ndef pi\n  q, r, t, k, n, l = [1, 0, 1, 1, 3, 3].map { |n| BigInt.new(n) }\n  dot_written = false\n  loop do\n    if 4*q + r - t < n*t\n      yield n\n      unless dot_written\n        yield '.'\n        dot_written = true\n      end\n      nr = 10*(r - n*t)\n      n = ((10*(3*q + r)) / t) - 10*n\n      q *= 10\n      r = nr\n    else\n      nr = (2*q + r) * l\n      nn = (q*(7*k + 2) + r*l) / (t*l)\n      q *= k\n      t *= l\n      l += 2\n      k += 1\n      n = nn\n      r = nr\n    end\n  end\nend\n\npi { |digit_or_dot| print digit_or_dot; STDOUT.flush }\n", "target": "import java.math.BigInteger ;\n\npublic class Pi {\n  final BigInteger TWO = BigInteger.valueOf(2) ;\n  final BigInteger THREE = BigInteger.valueOf(3) ;\n  final BigInteger FOUR = BigInteger.valueOf(4) ;\n  final BigInteger SEVEN = BigInteger.valueOf(7) ;\n\n  BigInteger q = BigInteger.ONE ;\n  BigInteger r = BigInteger.ZERO ;\n  BigInteger t = BigInteger.ONE ;\n  BigInteger k = BigInteger.ONE ;\n  BigInteger n = BigInteger.valueOf(3) ;\n  BigInteger l = BigInteger.valueOf(3) ;\n\n  public void calcPiDigits(){\n    BigInteger nn, nr ;\n    boolean first = true ;\n    while(true){\n        if(FOUR.multiply(q).add(r).subtract(t).compareTo(n.multiply(t)) == -1){\n          System.out.print(n) ;\n          if(first){System.out.print(\".\") ; first = false ;}\n          nr = BigInteger.TEN.multiply(r.subtract(n.multiply(t))) ;\n          n = BigInteger.TEN.multiply(THREE.multiply(q).add(r)).divide(t).subtract(BigInteger.TEN.multiply(n)) ;\n          q = q.multiply(BigInteger.TEN) ;\n          r = nr ;\n          System.out.flush() ;\n        }else{\n          nr = TWO.multiply(q).add(r).multiply(l) ;\n          nn = q.multiply((SEVEN.multiply(k))).add(TWO).add(r.multiply(l)).divide(t.multiply(l)) ;\n          q = q.multiply(k) ;\n          t = t.multiply(l) ;\n          l = l.add(TWO) ;\n          k = k.add(BigInteger.ONE) ;\n          n = nn ;\n          r = nr ;\n        }\n    }\n  }\n\n  public static void main(String[] args) {\n    Pi p = new Pi() ;\n    p.calcPiDigits() ;\n  }\n}\n"}
{"id": 69763, "name": "Pi", "source": "Translate Ruby to Python: require \"big\"\n\ndef pi\n  q, r, t, k, n, l = [1, 0, 1, 1, 3, 3].map { |n| BigInt.new(n) }\n  dot_written = false\n  loop do\n    if 4*q + r - t < n*t\n      yield n\n      unless dot_written\n        yield '.'\n        dot_written = true\n      end\n      nr = 10*(r - n*t)\n      n = ((10*(3*q + r)) / t) - 10*n\n      q *= 10\n      r = nr\n    else\n      nr = (2*q + r) * l\n      nn = (q*(7*k + 2) + r*l) / (t*l)\n      q *= k\n      t *= l\n      l += 2\n      k += 1\n      n = nn\n      r = nr\n    end\n  end\nend\n\npi { |digit_or_dot| print digit_or_dot; STDOUT.flush }\n", "target": "def calcPi():\n    q, r, t, k, n, l = 1, 0, 1, 1, 3, 3\n    while True:\n        if 4*q+r-t < n*t:\n            yield n\n            nr = 10*(r-n*t)\n            n  = ((10*(3*q+r))//t)-10*n\n            q  *= 10\n            r  = nr\n        else:\n            nr = (2*q+r)*l\n            nn = (q*(7*k)+2+(r*l))//(t*l)\n            q  *= k\n            t  *= l\n            l  += 2\n            k += 1\n            n  = nn\n            r  = nr\n\nimport sys\npi_digits = calcPi()\ni = 0\nfor d in pi_digits:\n    sys.stdout.write(str(d))\n    i += 1\n    if i == 40: print(\"\"); i = 0\n"}
{"id": 70091, "name": "Terminal control_Coloured text", "source": "Translate Ruby to C#: \nrequire 'rubygems'\nrequire 'colored'\n\nprint 'Colors are'.bold\nprint ' black'.black\nprint ' blue'.blue\nprint ' cyan'.cyan\nprint ' green'.green\nprint ' magenta'.magenta\nprint ' red'.red\nprint ' white '.white\nprint 'and'.underline, ' yellow'.yellow, \"\\n\"\nputs 'black on blue'.black_on_blue\nputs 'black on cyan'.black_on_cyan\nputs 'black on green'.black_on_green\nputs 'black on magenta'.black_on_magenta\nputs 'black on red'.black_on_red\nputs 'white on black'.white_on_black\nputs 'white on blue'.white_on_blue\nputs 'white on cyan'.white_on_cyan\nputs 'white on green'.white_on_green\nputs 'white on magenta'.white_on_magenta\nputs 'white on red'.white_on_red\n", "target": "static void Main(string[] args)\n{\n    Console.ForegroundColor = ConsoleColor.Red;\n    Console.BackgroundColor = ConsoleColor.Yellow;\n    Console.WriteLine(\"Red on Yellow\");\n    Console.ForegroundColor = ConsoleColor.White;\n    Console.BackgroundColor = ConsoleColor.Black;\n    Console.WriteLine(\"White on black\");\n    Console.ResetColor();\n    Console.WriteLine(\"Back to normal\");\n    Console.ReadKey();\n}\n"}
{"id": 70092, "name": "Terminal control_Coloured text", "source": "Translate Ruby to C#: \nrequire 'rubygems'\nrequire 'colored'\n\nprint 'Colors are'.bold\nprint ' black'.black\nprint ' blue'.blue\nprint ' cyan'.cyan\nprint ' green'.green\nprint ' magenta'.magenta\nprint ' red'.red\nprint ' white '.white\nprint 'and'.underline, ' yellow'.yellow, \"\\n\"\nputs 'black on blue'.black_on_blue\nputs 'black on cyan'.black_on_cyan\nputs 'black on green'.black_on_green\nputs 'black on magenta'.black_on_magenta\nputs 'black on red'.black_on_red\nputs 'white on black'.white_on_black\nputs 'white on blue'.white_on_blue\nputs 'white on cyan'.white_on_cyan\nputs 'white on green'.white_on_green\nputs 'white on magenta'.white_on_magenta\nputs 'white on red'.white_on_red\n", "target": "static void Main(string[] args)\n{\n    Console.ForegroundColor = ConsoleColor.Red;\n    Console.BackgroundColor = ConsoleColor.Yellow;\n    Console.WriteLine(\"Red on Yellow\");\n    Console.ForegroundColor = ConsoleColor.White;\n    Console.BackgroundColor = ConsoleColor.Black;\n    Console.WriteLine(\"White on black\");\n    Console.ResetColor();\n    Console.WriteLine(\"Back to normal\");\n    Console.ReadKey();\n}\n"}
{"id": 70093, "name": "Terminal control_Coloured text", "source": "Translate Ruby to Python: \nrequire 'rubygems'\nrequire 'colored'\n\nprint 'Colors are'.bold\nprint ' black'.black\nprint ' blue'.blue\nprint ' cyan'.cyan\nprint ' green'.green\nprint ' magenta'.magenta\nprint ' red'.red\nprint ' white '.white\nprint 'and'.underline, ' yellow'.yellow, \"\\n\"\nputs 'black on blue'.black_on_blue\nputs 'black on cyan'.black_on_cyan\nputs 'black on green'.black_on_green\nputs 'black on magenta'.black_on_magenta\nputs 'black on red'.black_on_red\nputs 'white on black'.white_on_black\nputs 'white on blue'.white_on_blue\nputs 'white on cyan'.white_on_cyan\nputs 'white on green'.white_on_green\nputs 'white on magenta'.white_on_magenta\nputs 'white on red'.white_on_red\n", "target": "from colorama import init, Fore, Back, Style\ninit(autoreset=True)\n\nprint Fore.RED + \"FATAL ERROR! Cannot write to /boot/vmlinuz-3.2.0-33-generic\"\nprint Back.BLUE + Fore.YELLOW + \"What a cute console!\"\nprint \"This is an %simportant%s word\" % (Style.BRIGHT, Style.NORMAL)\nprint Fore.YELLOW  + \"Rosetta Code!\"\nprint Fore.CYAN    + \"Rosetta Code!\"\nprint Fore.GREEN   + \"Rosetta Code!\"\nprint Fore.MAGENTA + \"Rosetta Code!\"\nprint Back.YELLOW + Fore.BLUE + Style.BRIGHT + \" \" * 40 + \" == Good Bye!\"\n"}
{"id": 70094, "name": "Terminal control_Coloured text", "source": "Translate Ruby to Python: \nrequire 'rubygems'\nrequire 'colored'\n\nprint 'Colors are'.bold\nprint ' black'.black\nprint ' blue'.blue\nprint ' cyan'.cyan\nprint ' green'.green\nprint ' magenta'.magenta\nprint ' red'.red\nprint ' white '.white\nprint 'and'.underline, ' yellow'.yellow, \"\\n\"\nputs 'black on blue'.black_on_blue\nputs 'black on cyan'.black_on_cyan\nputs 'black on green'.black_on_green\nputs 'black on magenta'.black_on_magenta\nputs 'black on red'.black_on_red\nputs 'white on black'.white_on_black\nputs 'white on blue'.white_on_blue\nputs 'white on cyan'.white_on_cyan\nputs 'white on green'.white_on_green\nputs 'white on magenta'.white_on_magenta\nputs 'white on red'.white_on_red\n", "target": "from colorama import init, Fore, Back, Style\ninit(autoreset=True)\n\nprint Fore.RED + \"FATAL ERROR! Cannot write to /boot/vmlinuz-3.2.0-33-generic\"\nprint Back.BLUE + Fore.YELLOW + \"What a cute console!\"\nprint \"This is an %simportant%s word\" % (Style.BRIGHT, Style.NORMAL)\nprint Fore.YELLOW  + \"Rosetta Code!\"\nprint Fore.CYAN    + \"Rosetta Code!\"\nprint Fore.GREEN   + \"Rosetta Code!\"\nprint Fore.MAGENTA + \"Rosetta Code!\"\nprint Back.YELLOW + Fore.BLUE + Style.BRIGHT + \" \" * 40 + \" == Good Bye!\"\n"}
{"id": 70326, "name": "Loops_Foreach", "source": "Translate Ruby to C#: for i in collection do\n  puts i\nend\n", "target": "string[] things = {\"Apple\", \"Banana\", \"Coconut\"};\n\nforeach (string thing in things)\n{\n    Console.WriteLine(thing);\n}\n"}
{"id": 70328, "name": "Loops_Foreach", "source": "Translate Ruby to Java: for i in collection do\n  puts i\nend\n", "target": "module LoopForEach\n    {\n    @Inject Console console;\n    void run()\n        {\n        val vals = [10, 20, 30, 40];\n        console.print(\"Array of values:\");\n        Loop: for (val val : vals)\n            {\n            console.print($\"  value #{Loop.count + 1}: {val}\");\n            }\n\n        Map<String, Int> pairs = [\"x\"=42, \"y\"=69];\n        console.print(\"\\nKeys and values:\");\n        for ((String key, Int val) : pairs)\n            {\n            console.print($\"  {key}={val}\");\n            }\n        console.print(\"\\nJust the keys:\");\n        Loop: for (String key : pairs)\n            {\n            console.print($\"  key #{Loop.count + 1}: {key}\");\n            }\n\n        console.print(\"\\nValues from a range:\");\n        for (Int n : 1..5)\n            {\n            console.print($\"  {n}\");\n            }\n        }\n    }\n"}
{"id": 70525, "name": "Brownian tree", "source": "Translate Ruby to C#: require 'rubygems'\nrequire 'RMagick'\n\nNUM_PARTICLES = 1000\nSIZE          = 800\n\ndef draw_brownian_tree world\n  \n  world[rand SIZE][rand SIZE] = 1\n\n  NUM_PARTICLES.times do\n    \n    px = rand SIZE\n    py = rand SIZE\n\n    loop do\n      \n      dx = rand(3) - 1\n      dy = rand(3) - 1\n\n      if dx + px < 0 or dx + px >= SIZE or dy + py < 0 or dy + py >= SIZE\n        \n        px = rand SIZE\n        py = rand SIZE\n      elsif world[py + dy][px + dx] != 0\n        \n        world[py][px] = 1\n        break\n      else\n        py += dy\n        px += dx\n      end\n    end\n  end\nend\n\nworld = Array.new(SIZE) { Array.new(SIZE, 0) }\nsrand Time.now.to_i\n\ndraw_brownian_tree world\n\nimg = Magick::Image.new(SIZE, SIZE) do \n  self.background_color = \"black\"\nend\n\ndraw = Magick::Draw.new\ndraw.fill \"white\"\n\nworld.each_with_index do |row, y|\n  row.each_with_index do |colour, x|\n    draw.point x, y if colour != 0\n  end\nend\n\ndraw.draw img\nimg.write \"brownian_tree.bmp\"\n", "target": "using System;\nusing System.Drawing;\n\nnamespace BrownianTree\n{\n    class Program\n    {\n        static Bitmap BrownianTree(int size, int numparticles)\n        {\n            Bitmap bmp = new Bitmap(size, size);\n            Rectangle bounds = new Rectangle { X = 0, Y = 0, Size = bmp.Size };\n            using (Graphics g = Graphics.FromImage(bmp))\n            {\n                g.Clear(Color.Black);\n            }\n            Random rnd = new Random();\n            bmp.SetPixel(rnd.Next(size), rnd.Next(size), Color.White);\n            Point pt = new Point(), newpt = new Point();\n            for (int i = 0; i < numparticles; i++)\n            {\n                pt.X = rnd.Next(size);\n                pt.Y = rnd.Next(size);\n                do\n                {\n                    newpt.X = pt.X + rnd.Next(-1, 2);\n                    newpt.Y = pt.Y + rnd.Next(-1, 2);\n                    if (!bounds.Contains(newpt))\n                    {\n                        pt.X = rnd.Next(size);\n                        pt.Y = rnd.Next(size);\n                    }\n                    else if (bmp.GetPixel(newpt.X, newpt.Y).R > 0)\n                    {\n                        bmp.SetPixel(pt.X, pt.Y, Color.White);\n                        break;\n                    }\n                    else\n                    {\n                        pt = newpt;\n                    }\n                } while (true);\n            }\n            return bmp;\n        }\n\n        static void Main(string[] args)\n        {\n            BrownianTree(300, 3000).Save(\"browniantree.png\");\n        }\n    }\n}\n"}
{"id": 70527, "name": "Brownian tree", "source": "Translate Ruby to Java: require 'rubygems'\nrequire 'RMagick'\n\nNUM_PARTICLES = 1000\nSIZE          = 800\n\ndef draw_brownian_tree world\n  \n  world[rand SIZE][rand SIZE] = 1\n\n  NUM_PARTICLES.times do\n    \n    px = rand SIZE\n    py = rand SIZE\n\n    loop do\n      \n      dx = rand(3) - 1\n      dy = rand(3) - 1\n\n      if dx + px < 0 or dx + px >= SIZE or dy + py < 0 or dy + py >= SIZE\n        \n        px = rand SIZE\n        py = rand SIZE\n      elsif world[py + dy][px + dx] != 0\n        \n        world[py][px] = 1\n        break\n      else\n        py += dy\n        px += dx\n      end\n    end\n  end\nend\n\nworld = Array.new(SIZE) { Array.new(SIZE, 0) }\nsrand Time.now.to_i\n\ndraw_brownian_tree world\n\nimg = Magick::Image.new(SIZE, SIZE) do \n  self.background_color = \"black\"\nend\n\ndraw = Magick::Draw.new\ndraw.fill \"white\"\n\nworld.each_with_index do |row, y|\n  row.each_with_index do |colour, x|\n    draw.point x, y if colour != 0\n  end\nend\n\ndraw.draw img\nimg.write \"brownian_tree.bmp\"\n", "target": "import java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.util.*;\nimport javax.swing.JFrame;\n\npublic class BrownianTree extends JFrame implements Runnable {\n\n    BufferedImage I;\n    private List<Particle> particles;\n    static Random rand = new Random();\n\n    public BrownianTree() {\n        super(\"Brownian Tree\");\n        setBounds(100, 100, 400, 300);\n        setDefaultCloseOperation(EXIT_ON_CLOSE);\n        I = new BufferedImage(getWidth(), getHeight(), BufferedImage.TYPE_INT_RGB);\n        I.setRGB(I.getWidth() / 2, I.getHeight() / 2, 0xff00);\n        particles = new LinkedList<Particle>();\n    }\n\n    @Override\n    public void paint(Graphics g) {\n        g.drawImage(I, 0, 0, this);\n    }\n\n    public void run() {\n        for (int i = 0; i < 20000; i++) {\n            particles.add(new Particle());\n        }\n        while (!particles.isEmpty()) {\n            for (Iterator<Particle> it = particles.iterator(); it.hasNext();) {\n                if (it.next().move()) {\n                    it.remove();\n                }\n            }\n            repaint();\n        }\n    }\n\n    public static void main(String[] args) {\n        BrownianTree b = new BrownianTree();\n        b.setVisible(true);\n        new Thread(b).start();\n    }\n\n    private class Particle {\n\n        private int x, y;\n\n        private Particle() {\n            x = rand.nextInt(I.getWidth());\n            y = rand.nextInt(I.getHeight());\n        }\n\n        \n        private boolean move() {\n            int dx = rand.nextInt(3) - 1;\n            int dy = rand.nextInt(3) - 1;\n            if ((x + dx < 0) || (y + dy < 0)\n                    || (y + dy >= I.getHeight()) || (x + dx >= I.getWidth())) {\n                return true;\n            }\n            x += dx;\n            y += dy;\n            if ((I.getRGB(x, y) & 0xff00) == 0xff00) {\n                I.setRGB(x - dx, y - dy, 0xff00);\n                return true;\n            }\n            return false;\n        }\n    }\n}\n"}
{"id": 70528, "name": "Brownian tree", "source": "Translate Ruby to Python: require 'rubygems'\nrequire 'RMagick'\n\nNUM_PARTICLES = 1000\nSIZE          = 800\n\ndef draw_brownian_tree world\n  \n  world[rand SIZE][rand SIZE] = 1\n\n  NUM_PARTICLES.times do\n    \n    px = rand SIZE\n    py = rand SIZE\n\n    loop do\n      \n      dx = rand(3) - 1\n      dy = rand(3) - 1\n\n      if dx + px < 0 or dx + px >= SIZE or dy + py < 0 or dy + py >= SIZE\n        \n        px = rand SIZE\n        py = rand SIZE\n      elsif world[py + dy][px + dx] != 0\n        \n        world[py][px] = 1\n        break\n      else\n        py += dy\n        px += dx\n      end\n    end\n  end\nend\n\nworld = Array.new(SIZE) { Array.new(SIZE, 0) }\nsrand Time.now.to_i\n\ndraw_brownian_tree world\n\nimg = Magick::Image.new(SIZE, SIZE) do \n  self.background_color = \"black\"\nend\n\ndraw = Magick::Draw.new\ndraw.fill \"white\"\n\nworld.each_with_index do |row, y|\n  row.each_with_index do |colour, x|\n    draw.point x, y if colour != 0\n  end\nend\n\ndraw.draw img\nimg.write \"brownian_tree.bmp\"\n", "target": "SIDESTICK = False\n\ndef setup() :\n    global is_taken\n    size(512, 512)\n    background(0)\n    is_taken = [[False] * height for _ in range(width)]\n    is_taken[width/2][height/2] = True\n\n\ndef draw() :\n    x = floor(random(width))\n    y = floor(random(height))\n    if is_taken[x][y]: \n        return\n    while True:\n        xp = x + floor(random(-1, 2))\n        yp = y + floor(random(-1, 2))\n        is_contained = 0 <= xp < width and 0 <= yp < height\n        if is_contained and not is_taken[xp][yp]:\n            x = xp\n            y = yp\n            continue\n        else:\n            if SIDESTICK or (is_contained and is_taken[xp][yp]):\n                is_taken[x][y] = True\n                set(x, y, color(255))            \n            break\n        \n    if frameCount > width * height:\n        noLoop()\n"}
{"id": 70683, "name": "Guess the number_With feedback (player)", "source": "Translate Ruby to C#: def play(low, high, turns=1)\n  num = (low + high) / 2\n  print \"guessing \n  case is_it?(num)\n  when 1\n    puts \"too high\"\n    play(low, num - 1, turns + 1)\n  when -1\n    puts \"too low\"\n    play(num + 1, high, turns + 1)\n  else\n    puts \"found the number in \n  end\nend\n\ndef is_it?(num)\n  num <=> $number\nend\n\nlow, high = 1, 100\n$number = rand(low .. high)\n\nputs \"guess a number between \nplay(low, high)\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Threading; \n\nnamespace ConsoleApplication1\n{\n    class RealisticGuess \n    {\n        private int max;\n        private int min;\n        private int guess;\n\n        public void Start()\n        {\n            Console.Clear();\n            string input;\n\n            try\n            {\n                Console.WriteLine(\"Please enter the lower boundary\");\n                input = Console.ReadLine();\n                min = Convert.ToInt32(input);\n                Console.WriteLine(\"Please enter the upper boundary\");\n                input = Console.ReadLine();\n                max = Convert.ToInt32(input);\n            }\n            catch (FormatException)\n            {\n                Console.WriteLine(\"The entry you have made is invalid. Please make sure your entry is an integer and try again.\");\n                Console.ReadKey(true);\n                Start();\n            }\n            Console.WriteLine(\"Think of a number between {0} and {1}.\", min, max);\n            Thread.Sleep(2500);\n            Console.WriteLine(\"Ready?\");\n            Console.WriteLine(\"Press any key to begin.\");\n            Console.ReadKey(true);\n            Guess(min, max);\n        }\n        public void Guess(int min, int max)\n        {\n            int counter = 1;\n            string userAnswer;\n            bool correct = false;\n            Random rand = new Random();\n\n            while (correct == false)\n            {\n                guess = rand.Next(min, max);\n                Console.Clear();\n                Console.WriteLine(\"{0}\", guess);\n                Console.WriteLine(\"Is this number correct? {Y/N}\");\n                userAnswer = Console.ReadLine();\n                if (userAnswer != \"y\" && userAnswer != \"Y\" && userAnswer != \"n\" && userAnswer != \"N\")\n                {\n                    Console.WriteLine(\"Your entry is invalid. Please enter either 'Y' or 'N'\");\n                    Console.WriteLine(\"Is the number correct? {Y/N}\");\n                    userAnswer = Console.ReadLine();\n                }\n                if (userAnswer == \"y\" || userAnswer == \"Y\")\n                {\n                    correct = true;\n                }\n                if (userAnswer == \"n\" || userAnswer == \"N\")\n                {\n                    counter++;\n                    if (max == min)\n                    {\n                        Console.WriteLine(\"Error: Range Intersect. Press enter to restart the game.\");  \n                        Console.ReadKey(true);                                                          \n                        Guess(1, 101);                                                                  \n                    }\n                    Console.WriteLine(\"Is the number you're thinking of lower or higher? {L/H}\");\n                    userAnswer = Console.ReadLine();\n                    if (userAnswer != \"l\" && userAnswer != \"L\" && userAnswer != \"h\" && userAnswer != \"H\")\n                    {\n                        Console.WriteLine(\"Your entry is invalid. Please enter either 'L' or 'H'\");\n                        Console.WriteLine(\"Is the number you're thinking of lower or higher? {L/H}\");\n                        userAnswer = Console.ReadLine();\n                    }\n                    if (userAnswer == \"l\" || userAnswer == \"L\")\n                    {\n                        max = guess;\n                    }\n                    if (userAnswer == \"h\" || userAnswer == \"H\")\n                    {\n                        min = guess;\n                    }\n                }\n            }\n            if (correct == true)\n            {\n                EndAndLoop(counter);\n            }\n        }\n\n        public void EndAndLoop(int iterations)\n        {\n            string userChoice;\n            bool loop = false;\n            Console.WriteLine(\"Game over. It took {0} guesses to find the number.\", iterations);\n            while (loop == false)\n            {\n                Console.WriteLine(\"Would you like to play again? {Y/N}\");\n                userChoice = Console.ReadLine();\n                if (userChoice != \"Y\" && userChoice != \"y\" && userChoice != \"N\" && userChoice != \"n\")\n                {\n                    Console.WriteLine(\"Sorry, your input is invalid. Please answer 'Y' to play again, or 'N' to quit.\");\n                }\n                if (userChoice == \"Y\" || userChoice == \"y\")\n                {\n                    Start();\n                }\n                if (userChoice == \"N\" || userChoice == \"n\")\n                {\n                    Environment.Exit(1);\n                }\n            }\n        }\n    }\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            Console.Title = \"Random Number\";\n            RealisticGuess game = new RealisticGuess();\n            game.Start();\n        }\n    }\n}\n"}
{"id": 70685, "name": "Guess the number_With feedback (player)", "source": "Translate Ruby to Java: def play(low, high, turns=1)\n  num = (low + high) / 2\n  print \"guessing \n  case is_it?(num)\n  when 1\n    puts \"too high\"\n    play(low, num - 1, turns + 1)\n  when -1\n    puts \"too low\"\n    play(num + 1, high, turns + 1)\n  else\n    puts \"found the number in \n  end\nend\n\ndef is_it?(num)\n  num <=> $number\nend\n\nlow, high = 1, 100\n$number = rand(low .. high)\n\nputs \"guess a number between \nplay(low, high)\n", "target": "import java.util.AbstractList;\nimport java.util.Collections;\nimport java.util.Scanner;\n\npublic class GuessNumber {\n    public static final int LOWER = 0, UPPER = 100;\n    public static void main(String[] args) {\n\tSystem.out.printf(\"Instructions:\\n\" +\n\t\t\t  \"Think of integer number from %d (inclusive) to %d (exclusive) and\\n\" +\n\t\t\t  \"I will guess it. After each guess, you respond with L, H, or C depending\\n\" +\n\t\t\t  \"on if my guess was too low, too high, or correct.\\n\",\n\t\t\t  LOWER, UPPER);\n\tint result = Collections.binarySearch(new AbstractList<Integer>() {\n\t\tprivate final Scanner in = new Scanner(System.in);\n\t\tpublic int size() { return UPPER - LOWER; }\n\t\tpublic Integer get(int i) {\n\t\t    System.out.printf(\"My guess is: %d. Is it too high, too low, or correct? (H/L/C) \", LOWER+i);\n\t\t    String s = in.nextLine();\n\t\t    assert s.length() > 0;\n\t\t    switch (Character.toLowerCase(s.charAt(0))) {\n\t\t    case 'l':\n\t\t\treturn -1;\n\t\t    case 'h':\n\t\t\treturn 1;\n\t\t    case 'c':\n\t\t\treturn 0;\n\t\t    }\n\t\t    return -1;\n\t\t}\n\t    }, 0);\n\tif (result < 0)\n\t    System.out.println(\"That is impossible.\");\n\telse\n\t    System.out.printf(\"Your number is %d.\\n\", result);\n    }\n}\n"}
{"id": 70686, "name": "Guess the number_With feedback (player)", "source": "Translate Ruby to Python: def play(low, high, turns=1)\n  num = (low + high) / 2\n  print \"guessing \n  case is_it?(num)\n  when 1\n    puts \"too high\"\n    play(low, num - 1, turns + 1)\n  when -1\n    puts \"too low\"\n    play(num + 1, high, turns + 1)\n  else\n    puts \"found the number in \n  end\nend\n\ndef is_it?(num)\n  num <=> $number\nend\n\nlow, high = 1, 100\n$number = rand(low .. high)\n\nputs \"guess a number between \nplay(low, high)\n", "target": "inclusive_range = mn, mx = (1, 10)\n\nprint( % inclusive_range)\n\ni = 0\nwhile True:\n    i += 1\n    guess = (mn+mx)//2\n    txt = input(\"Guess %2i is: %2i. The score for which is (h,l,=): \"\n                % (i, guess)).strip().lower()[0]\n    if txt not in 'hl=':\n        print(\"  I don't understand your input of '%s'\u00a0?\" % txt)\n        continue\n    if txt == 'h':\n        mx = guess-1\n    if txt == 'l':\n        mn = guess+1\n    if txt == '=':\n        print(\"  Ye-Haw!!\")\n        break\n    if (mn > mx) or (mn < inclusive_range[0]) or (mx > inclusive_range[1]):\n        print(\"Please check your scoring as I cannot find the value\")\n        break\n        \nprint(\"\\nThanks for keeping score.\")\n"}
{"id": 70958, "name": "Find the intersection of a line with a plane", "source": "Translate Ruby to C#: require \"matrix\"\n\ndef intersectPoint(rayVector, rayPoint, planeNormal, planePoint)\n    diff = rayPoint - planePoint\n    prod1 = diff.dot planeNormal\n    prod2 = rayVector.dot planeNormal\n    prod3 = prod1 / prod2\n    return rayPoint - rayVector * prod3\nend\n\ndef main\n    rv = Vector[0.0, -1.0, -1.0]\n    rp = Vector[0.0, 0.0, 10.0]\n    pn = Vector[0.0, 0.0, 1.0]\n    pp = Vector[0.0, 0.0, 5.0]\n    ip = intersectPoint(rv, rp, pn, pp)\n    puts \"The ray intersects the plane at %s\" % [ip]\nend\n\nmain()\n", "target": "using System;\n\nnamespace FindIntersection {\n    class Vector3D {\n        private double x, y, z;\n\n        public Vector3D(double x, double y, double z) {\n            this.x = x;\n            this.y = y;\n            this.z = z;\n        }\n\n        public static Vector3D operator +(Vector3D lhs, Vector3D rhs) {\n            return new Vector3D(lhs.x + rhs.x, lhs.y + rhs.y, lhs.z + rhs.z);\n        }\n\n        public static Vector3D operator -(Vector3D lhs, Vector3D rhs) {\n            return new Vector3D(lhs.x - rhs.x, lhs.y - rhs.y, lhs.z - rhs.z);\n        }\n\n        public static Vector3D operator *(Vector3D lhs, double rhs) {\n            return new Vector3D(lhs.x * rhs, lhs.y * rhs, lhs.z * rhs);\n        }\n\n        public double Dot(Vector3D rhs) {\n            return x * rhs.x + y * rhs.y + z * rhs.z;\n        }\n\n        public override string ToString() {\n            return string.Format(\"({0:F}, {1:F}, {2:F})\", x, y, z);\n        }\n    }\n\n    class Program {\n        static Vector3D IntersectPoint(Vector3D rayVector, Vector3D rayPoint, Vector3D planeNormal, Vector3D planePoint) {\n            var diff = rayPoint - planePoint;\n            var prod1 = diff.Dot(planeNormal);\n            var prod2 = rayVector.Dot(planeNormal);\n            var prod3 = prod1 / prod2;\n            return rayPoint - rayVector * prod3;\n        }\n\n        static void Main(string[] args) {\n            var rv = new Vector3D(0.0, -1.0, -1.0);\n            var rp = new Vector3D(0.0, 0.0, 10.0);\n            var pn = new Vector3D(0.0, 0.0, 1.0);\n            var pp = new Vector3D(0.0, 0.0, 5.0);\n            var ip = IntersectPoint(rv, rp, pn, pp);\n            Console.WriteLine(\"The ray intersects the plane at {0}\", ip);\n        }\n    }\n}\n"}
{"id": 70959, "name": "Find the intersection of a line with a plane", "source": "Translate Ruby to C#: require \"matrix\"\n\ndef intersectPoint(rayVector, rayPoint, planeNormal, planePoint)\n    diff = rayPoint - planePoint\n    prod1 = diff.dot planeNormal\n    prod2 = rayVector.dot planeNormal\n    prod3 = prod1 / prod2\n    return rayPoint - rayVector * prod3\nend\n\ndef main\n    rv = Vector[0.0, -1.0, -1.0]\n    rp = Vector[0.0, 0.0, 10.0]\n    pn = Vector[0.0, 0.0, 1.0]\n    pp = Vector[0.0, 0.0, 5.0]\n    ip = intersectPoint(rv, rp, pn, pp)\n    puts \"The ray intersects the plane at %s\" % [ip]\nend\n\nmain()\n", "target": "using System;\n\nnamespace FindIntersection {\n    class Vector3D {\n        private double x, y, z;\n\n        public Vector3D(double x, double y, double z) {\n            this.x = x;\n            this.y = y;\n            this.z = z;\n        }\n\n        public static Vector3D operator +(Vector3D lhs, Vector3D rhs) {\n            return new Vector3D(lhs.x + rhs.x, lhs.y + rhs.y, lhs.z + rhs.z);\n        }\n\n        public static Vector3D operator -(Vector3D lhs, Vector3D rhs) {\n            return new Vector3D(lhs.x - rhs.x, lhs.y - rhs.y, lhs.z - rhs.z);\n        }\n\n        public static Vector3D operator *(Vector3D lhs, double rhs) {\n            return new Vector3D(lhs.x * rhs, lhs.y * rhs, lhs.z * rhs);\n        }\n\n        public double Dot(Vector3D rhs) {\n            return x * rhs.x + y * rhs.y + z * rhs.z;\n        }\n\n        public override string ToString() {\n            return string.Format(\"({0:F}, {1:F}, {2:F})\", x, y, z);\n        }\n    }\n\n    class Program {\n        static Vector3D IntersectPoint(Vector3D rayVector, Vector3D rayPoint, Vector3D planeNormal, Vector3D planePoint) {\n            var diff = rayPoint - planePoint;\n            var prod1 = diff.Dot(planeNormal);\n            var prod2 = rayVector.Dot(planeNormal);\n            var prod3 = prod1 / prod2;\n            return rayPoint - rayVector * prod3;\n        }\n\n        static void Main(string[] args) {\n            var rv = new Vector3D(0.0, -1.0, -1.0);\n            var rp = new Vector3D(0.0, 0.0, 10.0);\n            var pn = new Vector3D(0.0, 0.0, 1.0);\n            var pp = new Vector3D(0.0, 0.0, 5.0);\n            var ip = IntersectPoint(rv, rp, pn, pp);\n            Console.WriteLine(\"The ray intersects the plane at {0}\", ip);\n        }\n    }\n}\n"}
{"id": 70962, "name": "Find the intersection of a line with a plane", "source": "Translate Ruby to Java: require \"matrix\"\n\ndef intersectPoint(rayVector, rayPoint, planeNormal, planePoint)\n    diff = rayPoint - planePoint\n    prod1 = diff.dot planeNormal\n    prod2 = rayVector.dot planeNormal\n    prod3 = prod1 / prod2\n    return rayPoint - rayVector * prod3\nend\n\ndef main\n    rv = Vector[0.0, -1.0, -1.0]\n    rp = Vector[0.0, 0.0, 10.0]\n    pn = Vector[0.0, 0.0, 1.0]\n    pp = Vector[0.0, 0.0, 5.0]\n    ip = intersectPoint(rv, rp, pn, pp)\n    puts \"The ray intersects the plane at %s\" % [ip]\nend\n\nmain()\n", "target": "public class LinePlaneIntersection {\n    private static class Vector3D {\n        private double x, y, z;\n\n        Vector3D(double x, double y, double z) {\n            this.x = x;\n            this.y = y;\n            this.z = z;\n        }\n\n        Vector3D plus(Vector3D v) {\n            return new Vector3D(x + v.x, y + v.y, z + v.z);\n        }\n\n        Vector3D minus(Vector3D v) {\n            return new Vector3D(x - v.x, y - v.y, z - v.z);\n        }\n\n        Vector3D times(double s) {\n            return new Vector3D(s * x, s * y, s * z);\n        }\n\n        double dot(Vector3D v) {\n            return x * v.x + y * v.y + z * v.z;\n        }\n\n        @Override\n        public String toString() {\n            return String.format(\"(%f, %f, %f)\", x, y, z);\n        }\n    }\n\n    private static Vector3D intersectPoint(Vector3D rayVector, Vector3D rayPoint, Vector3D planeNormal, Vector3D planePoint) {\n        Vector3D diff = rayPoint.minus(planePoint);\n        double prod1 = diff.dot(planeNormal);\n        double prod2 = rayVector.dot(planeNormal);\n        double prod3 = prod1 / prod2;\n        return rayPoint.minus(rayVector.times(prod3));\n    }\n\n    public static void main(String[] args) {\n        Vector3D rv = new Vector3D(0.0, -1.0, -1.0);\n        Vector3D rp = new Vector3D(0.0, 0.0, 10.0);\n        Vector3D pn = new Vector3D(0.0, 0.0, 1.0);\n        Vector3D pp = new Vector3D(0.0, 0.0, 5.0);\n        Vector3D ip = intersectPoint(rv, rp, pn, pp);\n        System.out.println(\"The ray intersects the plane at \" + ip);\n    }\n}\n"}
{"id": 70963, "name": "Find the intersection of a line with a plane", "source": "Translate Ruby to Python: require \"matrix\"\n\ndef intersectPoint(rayVector, rayPoint, planeNormal, planePoint)\n    diff = rayPoint - planePoint\n    prod1 = diff.dot planeNormal\n    prod2 = rayVector.dot planeNormal\n    prod3 = prod1 / prod2\n    return rayPoint - rayVector * prod3\nend\n\ndef main\n    rv = Vector[0.0, -1.0, -1.0]\n    rp = Vector[0.0, 0.0, 10.0]\n    pn = Vector[0.0, 0.0, 1.0]\n    pp = Vector[0.0, 0.0, 5.0]\n    ip = intersectPoint(rv, rp, pn, pp)\n    puts \"The ray intersects the plane at %s\" % [ip]\nend\n\nmain()\n", "target": "\nfrom __future__ import print_function\nimport numpy as np\n\ndef LinePlaneCollision(planeNormal, planePoint, rayDirection, rayPoint, epsilon=1e-6):\n\n\tndotu = planeNormal.dot(rayDirection)\n\tif abs(ndotu) < epsilon:\n\t\traise RuntimeError(\"no intersection or line is within plane\")\n\n\tw = rayPoint - planePoint\n\tsi = -planeNormal.dot(w) / ndotu\n\tPsi = w + si * rayDirection + planePoint\n\treturn Psi\n\n\nif __name__==\"__main__\":\n\t\n\tplaneNormal = np.array([0, 0, 1])\n\tplanePoint = np.array([0, 0, 5]) \n\n\t\n\trayDirection = np.array([0, -1, -1])\n\trayPoint = np.array([0, 0, 10]) \n\n\tPsi = LinePlaneCollision(planeNormal, planePoint, rayDirection, rayPoint)\n\tprint (\"intersection at\", Psi)\n"}
{"id": 70964, "name": "Find the intersection of a line with a plane", "source": "Translate Ruby to Python: require \"matrix\"\n\ndef intersectPoint(rayVector, rayPoint, planeNormal, planePoint)\n    diff = rayPoint - planePoint\n    prod1 = diff.dot planeNormal\n    prod2 = rayVector.dot planeNormal\n    prod3 = prod1 / prod2\n    return rayPoint - rayVector * prod3\nend\n\ndef main\n    rv = Vector[0.0, -1.0, -1.0]\n    rp = Vector[0.0, 0.0, 10.0]\n    pn = Vector[0.0, 0.0, 1.0]\n    pp = Vector[0.0, 0.0, 5.0]\n    ip = intersectPoint(rv, rp, pn, pp)\n    puts \"The ray intersects the plane at %s\" % [ip]\nend\n\nmain()\n", "target": "\nfrom __future__ import print_function\nimport numpy as np\n\ndef LinePlaneCollision(planeNormal, planePoint, rayDirection, rayPoint, epsilon=1e-6):\n\n\tndotu = planeNormal.dot(rayDirection)\n\tif abs(ndotu) < epsilon:\n\t\traise RuntimeError(\"no intersection or line is within plane\")\n\n\tw = rayPoint - planePoint\n\tsi = -planeNormal.dot(w) / ndotu\n\tPsi = w + si * rayDirection + planePoint\n\treturn Psi\n\n\nif __name__==\"__main__\":\n\t\n\tplaneNormal = np.array([0, 0, 1])\n\tplanePoint = np.array([0, 0, 5]) \n\n\t\n\trayDirection = np.array([0, -1, -1])\n\trayPoint = np.array([0, 0, 10]) \n\n\tPsi = LinePlaneCollision(planeNormal, planePoint, rayDirection, rayPoint)\n\tprint (\"intersection at\", Psi)\n"}
{"id": 71335, "name": "Order two numerical lists", "source": "Translate Ruby to C#: >> ([1,2,1,3,2] <=> [1,2,0,4,4,0,0,0]) < 0\n=> false\n", "target": "namespace RosettaCode.OrderTwoNumericalLists\n{\n    using System;\n    using System.Collections.Generic;\n\n    internal static class Program\n    {\n        private static bool IsLessThan(this IEnumerable<int> enumerable,\n            IEnumerable<int> otherEnumerable)\n        {\n            using (\n                IEnumerator<int> enumerator = enumerable.GetEnumerator(),\n                    otherEnumerator = otherEnumerable.GetEnumerator())\n            {\n                while (true)\n                {\n                    if (!otherEnumerator.MoveNext())\n                    {\n                        return false;\n                    }\n\n                    if (!enumerator.MoveNext())\n                    {\n                        return true;\n                    }\n\n                    if (enumerator.Current == otherEnumerator.Current)\n                    {\n                        continue;\n                    }\n\n                    return enumerator.Current < otherEnumerator.Current;\n                }\n            }\n        }\n\n        private static void Main()\n        {\n            Console.WriteLine(\n                new[] {1, 2, 1, 3, 2}.IsLessThan(new[] {1, 2, 0, 4, 4, 0, 0, 0}));\n        }\n    }\n}\n"}
{"id": 71336, "name": "Order two numerical lists", "source": "Translate Ruby to C#: >> ([1,2,1,3,2] <=> [1,2,0,4,4,0,0,0]) < 0\n=> false\n", "target": "namespace RosettaCode.OrderTwoNumericalLists\n{\n    using System;\n    using System.Collections.Generic;\n\n    internal static class Program\n    {\n        private static bool IsLessThan(this IEnumerable<int> enumerable,\n            IEnumerable<int> otherEnumerable)\n        {\n            using (\n                IEnumerator<int> enumerator = enumerable.GetEnumerator(),\n                    otherEnumerator = otherEnumerable.GetEnumerator())\n            {\n                while (true)\n                {\n                    if (!otherEnumerator.MoveNext())\n                    {\n                        return false;\n                    }\n\n                    if (!enumerator.MoveNext())\n                    {\n                        return true;\n                    }\n\n                    if (enumerator.Current == otherEnumerator.Current)\n                    {\n                        continue;\n                    }\n\n                    return enumerator.Current < otherEnumerator.Current;\n                }\n            }\n        }\n\n        private static void Main()\n        {\n            Console.WriteLine(\n                new[] {1, 2, 1, 3, 2}.IsLessThan(new[] {1, 2, 0, 4, 4, 0, 0, 0}));\n        }\n    }\n}\n"}
{"id": 71339, "name": "Order two numerical lists", "source": "Translate Ruby to Java: >> ([1,2,1,3,2] <=> [1,2,0,4,4,0,0,0]) < 0\n=> false\n", "target": "import java.util.Arrays;\nimport java.util.List;\n\npublic class ListOrder{\n\tpublic static boolean ordered(double[] first, double[] second){\n\t\tif(first.length == 0) return true;\n\t\tif(second.length == 0) return false;\n\t\tif(first[0] == second[0])\n\t\t\treturn ordered(Arrays.copyOfRange(first, 1, first.length),\n\t\t\t\t\tArrays.copyOfRange(second, 1, second.length));\n\t\treturn first[0] < second[0];\n\t}\n\t\n\tpublic static <T extends Comparable<? super T>> boolean ordered(List<T> first, List<T> second){\n\t\tint i = 0;\n\t\tfor(; i < first.size() && i < second.size();i++){\n\t\t\tint cmp = first.get(i).compareTo(second.get(i));\n\t\t\tif(cmp == 0) continue;\n\t\t\tif(cmp < 0) return true;\n\t\t\treturn false;\n\t\t}\n\t\treturn i == first.size();\n\t}\n\t\n\tpublic static boolean ordered2(double[] first, double[] second){\n\t\tint i = 0;\n\t\tfor(; i < first.length && i < second.length;i++){\n\t\t\tif(first[i] == second[i]) continue;\n\t\t\tif(first[i] < second[i]) return true;\n\t\t\treturn false;\n\t\t}\n\t\treturn i == first.length;\n\t}\n}\n"}
{"id": 71340, "name": "Order two numerical lists", "source": "Translate Ruby to Java: >> ([1,2,1,3,2] <=> [1,2,0,4,4,0,0,0]) < 0\n=> false\n", "target": "import java.util.Arrays;\nimport java.util.List;\n\npublic class ListOrder{\n\tpublic static boolean ordered(double[] first, double[] second){\n\t\tif(first.length == 0) return true;\n\t\tif(second.length == 0) return false;\n\t\tif(first[0] == second[0])\n\t\t\treturn ordered(Arrays.copyOfRange(first, 1, first.length),\n\t\t\t\t\tArrays.copyOfRange(second, 1, second.length));\n\t\treturn first[0] < second[0];\n\t}\n\t\n\tpublic static <T extends Comparable<? super T>> boolean ordered(List<T> first, List<T> second){\n\t\tint i = 0;\n\t\tfor(; i < first.size() && i < second.size();i++){\n\t\t\tint cmp = first.get(i).compareTo(second.get(i));\n\t\t\tif(cmp == 0) continue;\n\t\t\tif(cmp < 0) return true;\n\t\t\treturn false;\n\t\t}\n\t\treturn i == first.size();\n\t}\n\t\n\tpublic static boolean ordered2(double[] first, double[] second){\n\t\tint i = 0;\n\t\tfor(; i < first.length && i < second.length;i++){\n\t\t\tif(first[i] == second[i]) continue;\n\t\t\tif(first[i] < second[i]) return true;\n\t\t\treturn false;\n\t\t}\n\t\treturn i == first.length;\n\t}\n}\n"}
{"id": 71341, "name": "Order two numerical lists", "source": "Translate Ruby to Python: >> ([1,2,1,3,2] <=> [1,2,0,4,4,0,0,0]) < 0\n=> false\n", "target": ">>> [1,2,1,3,2] < [1,2,0,4,4,0,0,0]\nFalse\n"}
{"id": 71342, "name": "Order two numerical lists", "source": "Translate Ruby to Python: >> ([1,2,1,3,2] <=> [1,2,0,4,4,0,0,0]) < 0\n=> false\n", "target": ">>> [1,2,1,3,2] < [1,2,0,4,4,0,0,0]\nFalse\n"}
{"id": 71722, "name": "Determine if a string has all unique characters", "source": "Translate Ruby to C#: strings = [\"\",\n        \".\",\n        \"abcABC\",\n        \"XYZ ZYX\",\n        \"1234567890ABCDEFGHIJKLMN0PQRSTUVWXYZ\",\n        \"01234567890ABCDEFGHIJKLMN0PQRSTUVWXYZ0X\",\n        \"h\u00e9t\u00e9rog\u00e9n\u00e9it\u00e9\",\n        \"\ud83c\udf86\ud83c\udf83\ud83c\udf87\ud83c\udf88\",\n        \"\ud83d\ude0d\ud83d\ude00\ud83d\ude4c\ud83d\udc83\ud83d\ude0d\ud83d\ude4c\",\n        \"\ud83d\udc20\ud83d\udc1f\ud83d\udc21\ud83e\udd88\ud83d\udc2c\ud83d\udc33\ud83d\udc0b\ud83d\udc21\",]\n\nstrings.each do |str|\n  seen = {}\n  print \"\n  res = \"has no duplicates.\" \n  str.chars.each_with_index do |c,i|\n    if seen[c].nil? \n      seen[c] = i\n    else\n      res =  \"has duplicate char \n      break\n    end\n  end\n  puts res\nend\n", "target": "using System;\nusing System.Linq;\n\npublic class Program\n{\n    static void Main\n    {\n        string[] input = {\"\", \".\", \"abcABC\", \"XYZ ZYX\", \"1234567890ABCDEFGHIJKLMN0PQRSTUVWXYZ\"};\n        foreach (string s in input) {\n            Console.WriteLine($\"\\\"{s}\\\" (Length {s.Length}) \" +\n                string.Join(\", \",\n                    s.Select((c, i) => (c, i))\n                    .GroupBy(t => t.c).Where(g => g.Count() > 1)\n                    .Select(g => $\"'{g.Key}' (0X{(int)g.Key:X})[{string.Join(\", \", g.Select(t => t.i))}]\")\n                    .DefaultIfEmpty(\"All characters are unique.\")\n                )\n            );\n        }\n    }\n}\n"}
{"id": 71723, "name": "Determine if a string has all unique characters", "source": "Translate Ruby to C#: strings = [\"\",\n        \".\",\n        \"abcABC\",\n        \"XYZ ZYX\",\n        \"1234567890ABCDEFGHIJKLMN0PQRSTUVWXYZ\",\n        \"01234567890ABCDEFGHIJKLMN0PQRSTUVWXYZ0X\",\n        \"h\u00e9t\u00e9rog\u00e9n\u00e9it\u00e9\",\n        \"\ud83c\udf86\ud83c\udf83\ud83c\udf87\ud83c\udf88\",\n        \"\ud83d\ude0d\ud83d\ude00\ud83d\ude4c\ud83d\udc83\ud83d\ude0d\ud83d\ude4c\",\n        \"\ud83d\udc20\ud83d\udc1f\ud83d\udc21\ud83e\udd88\ud83d\udc2c\ud83d\udc33\ud83d\udc0b\ud83d\udc21\",]\n\nstrings.each do |str|\n  seen = {}\n  print \"\n  res = \"has no duplicates.\" \n  str.chars.each_with_index do |c,i|\n    if seen[c].nil? \n      seen[c] = i\n    else\n      res =  \"has duplicate char \n      break\n    end\n  end\n  puts res\nend\n", "target": "using System;\nusing System.Linq;\n\npublic class Program\n{\n    static void Main\n    {\n        string[] input = {\"\", \".\", \"abcABC\", \"XYZ ZYX\", \"1234567890ABCDEFGHIJKLMN0PQRSTUVWXYZ\"};\n        foreach (string s in input) {\n            Console.WriteLine($\"\\\"{s}\\\" (Length {s.Length}) \" +\n                string.Join(\", \",\n                    s.Select((c, i) => (c, i))\n                    .GroupBy(t => t.c).Where(g => g.Count() > 1)\n                    .Select(g => $\"'{g.Key}' (0X{(int)g.Key:X})[{string.Join(\", \", g.Select(t => t.i))}]\")\n                    .DefaultIfEmpty(\"All characters are unique.\")\n                )\n            );\n        }\n    }\n}\n"}
{"id": 71726, "name": "Determine if a string has all unique characters", "source": "Translate Ruby to Java: strings = [\"\",\n        \".\",\n        \"abcABC\",\n        \"XYZ ZYX\",\n        \"1234567890ABCDEFGHIJKLMN0PQRSTUVWXYZ\",\n        \"01234567890ABCDEFGHIJKLMN0PQRSTUVWXYZ0X\",\n        \"h\u00e9t\u00e9rog\u00e9n\u00e9it\u00e9\",\n        \"\ud83c\udf86\ud83c\udf83\ud83c\udf87\ud83c\udf88\",\n        \"\ud83d\ude0d\ud83d\ude00\ud83d\ude4c\ud83d\udc83\ud83d\ude0d\ud83d\ude4c\",\n        \"\ud83d\udc20\ud83d\udc1f\ud83d\udc21\ud83e\udd88\ud83d\udc2c\ud83d\udc33\ud83d\udc0b\ud83d\udc21\",]\n\nstrings.each do |str|\n  seen = {}\n  print \"\n  res = \"has no duplicates.\" \n  str.chars.each_with_index do |c,i|\n    if seen[c].nil? \n      seen[c] = i\n    else\n      res =  \"has duplicate char \n      break\n    end\n  end\n  puts res\nend\n", "target": "import java.util.HashMap;\nimport java.util.Map;\n\n\n\npublic class StringUniqueCharacters {\n\n    public static void main(String[] args) {\n        System.out.printf(\"%-40s  %2s  %10s  %8s  %s  %s%n\", \"String\", \"Length\", \"All Unique\", \"1st Diff\", \"Hex\", \"Positions\");\n        System.out.printf(\"%-40s  %2s  %10s  %8s  %s  %s%n\", \"------------------------\", \"------\", \"----------\", \"--------\", \"---\", \"---------\");\n        for ( String s : new String[] {\"\", \".\", \"abcABC\", \"XYZ ZYX\", \"1234567890ABCDEFGHIJKLMN0PQRSTUVWXYZ\"} ) {\n            processString(s);\n        }\n    }\n    \n    \n    \n    private static void processString(String input) {\n        Map<Character,Integer> charMap = new HashMap<>(); \n        char dup = 0;\n        int index = 0;\n        int pos1 = -1;\n        int pos2 = -1;\n        for ( char key : input.toCharArray() ) {\n            index++;\n            if ( charMap.containsKey(key) ) {\n                dup = key;\n                pos1 = charMap.get(key);\n                pos2 = index;\n                break;\n            }\n            charMap.put(key, index);\n        }\n        String unique = dup == 0 ? \"yes\" : \"no\";\n        String diff = dup == 0 ? \"\" : \"'\" + dup + \"'\";\n        String hex = dup == 0 ? \"\" : Integer.toHexString(dup).toUpperCase();\n        String position = dup == 0 ? \"\" : pos1 + \" \" + pos2;\n        System.out.printf(\"%-40s \u00a0%-6d \u00a0%-10s \u00a0%-8s \u00a0%-3s \u00a0%-5s%n\", input, input.length(), unique, diff, hex, position);\n    }\n\n}\n"}
{"id": 71727, "name": "Determine if a string has all unique characters", "source": "Translate Ruby to Java: strings = [\"\",\n        \".\",\n        \"abcABC\",\n        \"XYZ ZYX\",\n        \"1234567890ABCDEFGHIJKLMN0PQRSTUVWXYZ\",\n        \"01234567890ABCDEFGHIJKLMN0PQRSTUVWXYZ0X\",\n        \"h\u00e9t\u00e9rog\u00e9n\u00e9it\u00e9\",\n        \"\ud83c\udf86\ud83c\udf83\ud83c\udf87\ud83c\udf88\",\n        \"\ud83d\ude0d\ud83d\ude00\ud83d\ude4c\ud83d\udc83\ud83d\ude0d\ud83d\ude4c\",\n        \"\ud83d\udc20\ud83d\udc1f\ud83d\udc21\ud83e\udd88\ud83d\udc2c\ud83d\udc33\ud83d\udc0b\ud83d\udc21\",]\n\nstrings.each do |str|\n  seen = {}\n  print \"\n  res = \"has no duplicates.\" \n  str.chars.each_with_index do |c,i|\n    if seen[c].nil? \n      seen[c] = i\n    else\n      res =  \"has duplicate char \n      break\n    end\n  end\n  puts res\nend\n", "target": "import java.util.HashMap;\nimport java.util.Map;\n\n\n\npublic class StringUniqueCharacters {\n\n    public static void main(String[] args) {\n        System.out.printf(\"%-40s  %2s  %10s  %8s  %s  %s%n\", \"String\", \"Length\", \"All Unique\", \"1st Diff\", \"Hex\", \"Positions\");\n        System.out.printf(\"%-40s  %2s  %10s  %8s  %s  %s%n\", \"------------------------\", \"------\", \"----------\", \"--------\", \"---\", \"---------\");\n        for ( String s : new String[] {\"\", \".\", \"abcABC\", \"XYZ ZYX\", \"1234567890ABCDEFGHIJKLMN0PQRSTUVWXYZ\"} ) {\n            processString(s);\n        }\n    }\n    \n    \n    \n    private static void processString(String input) {\n        Map<Character,Integer> charMap = new HashMap<>(); \n        char dup = 0;\n        int index = 0;\n        int pos1 = -1;\n        int pos2 = -1;\n        for ( char key : input.toCharArray() ) {\n            index++;\n            if ( charMap.containsKey(key) ) {\n                dup = key;\n                pos1 = charMap.get(key);\n                pos2 = index;\n                break;\n            }\n            charMap.put(key, index);\n        }\n        String unique = dup == 0 ? \"yes\" : \"no\";\n        String diff = dup == 0 ? \"\" : \"'\" + dup + \"'\";\n        String hex = dup == 0 ? \"\" : Integer.toHexString(dup).toUpperCase();\n        String position = dup == 0 ? \"\" : pos1 + \" \" + pos2;\n        System.out.printf(\"%-40s \u00a0%-6d \u00a0%-10s \u00a0%-8s \u00a0%-3s \u00a0%-5s%n\", input, input.length(), unique, diff, hex, position);\n    }\n\n}\n"}
{"id": 71728, "name": "Determine if a string has all unique characters", "source": "Translate Ruby to Python: strings = [\"\",\n        \".\",\n        \"abcABC\",\n        \"XYZ ZYX\",\n        \"1234567890ABCDEFGHIJKLMN0PQRSTUVWXYZ\",\n        \"01234567890ABCDEFGHIJKLMN0PQRSTUVWXYZ0X\",\n        \"h\u00e9t\u00e9rog\u00e9n\u00e9it\u00e9\",\n        \"\ud83c\udf86\ud83c\udf83\ud83c\udf87\ud83c\udf88\",\n        \"\ud83d\ude0d\ud83d\ude00\ud83d\ude4c\ud83d\udc83\ud83d\ude0d\ud83d\ude4c\",\n        \"\ud83d\udc20\ud83d\udc1f\ud83d\udc21\ud83e\udd88\ud83d\udc2c\ud83d\udc33\ud83d\udc0b\ud83d\udc21\",]\n\nstrings.each do |str|\n  seen = {}\n  print \"\n  res = \"has no duplicates.\" \n  str.chars.each_with_index do |c,i|\n    if seen[c].nil? \n      seen[c] = i\n    else\n      res =  \"has duplicate char \n      break\n    end\n  end\n  puts res\nend\n", "target": "\n\nfrom itertools import groupby\n\n\n\ndef duplicatedCharIndices(s):\n    \n    def go(xs):\n        if 1 < len(xs):\n            duplicates = list(filter(lambda kv: 1 < len(kv[1]), [\n                (k, list(v)) for k, v in groupby(\n                    sorted(xs, key=swap),\n                    key=snd\n                )\n            ]))\n            return Just(second(fmap(fst))(\n                sorted(\n                    duplicates,\n                    key=lambda kv: kv[1][0]\n                )[0]\n            )) if duplicates else Nothing()\n        else:\n            return Nothing()\n    return go(list(enumerate(s)))\n\n\n\n\ndef main():\n    \n\n    def showSample(s):\n        return repr(s) + ' (' + str(len(s)) + ')'\n\n    def showDuplicate(cix):\n        c, ix = cix\n        return repr(c) + (\n            ' (' + hex(ord(c)) + ') at ' + repr(ix)\n        )\n\n    print(\n        fTable('First duplicated character, if any:')(\n            showSample\n        )(maybe('None')(showDuplicate))(duplicatedCharIndices)([\n            '', '.', 'abcABC', 'XYZ ZYX',\n            '1234567890ABCDEFGHIJKLMN0PQRSTUVWXYZ'\n        ])\n    )\n\n\n\n\n\n\ndef fTable(s):\n    \n    def go(xShow, fxShow, f, xs):\n        ys = [xShow(x) for x in xs]\n        w = max(map(len, ys))\n        return s + '\\n' + '\\n'.join(map(\n            lambda x, y: y.rjust(w, ' ') + ' -> ' + fxShow(f(x)),\n            xs, ys\n        ))\n    return lambda xShow: lambda fxShow: lambda f: lambda xs: go(\n        xShow, fxShow, f, xs\n    )\n\n\n\n\n\ndef Just(x):\n    \n    return {'type': 'Maybe', 'Nothing': False, 'Just': x}\n\n\n\ndef Nothing():\n    \n    return {'type': 'Maybe', 'Nothing': True}\n\n\n\ndef fmap(f):\n    \n    return lambda xs: [f(x) for x in xs]\n\n\n\ndef fst(tpl):\n    \n    return tpl[0]\n\n\n\ndef head(xs):\n    \n    return xs[0] if isinstance(xs, list) else next(xs)\n\n\n\ndef maybe(v):\n    \n    return lambda f: lambda m: v if (\n        None is m or m.get('Nothing')\n    ) else f(m.get('Just'))\n\n\n\ndef second(f):\n    \n    return lambda xy: (xy[0], f(xy[1]))\n\n\n\ndef snd(tpl):\n    \n    return tpl[1]\n\n\n\ndef swap(tpl):\n    \n    return (tpl[1], tpl[0])\n\n\n\nif __name__ == '__main__':\n    main()\n"}
{"id": 71729, "name": "Determine if a string has all unique characters", "source": "Translate Ruby to Python: strings = [\"\",\n        \".\",\n        \"abcABC\",\n        \"XYZ ZYX\",\n        \"1234567890ABCDEFGHIJKLMN0PQRSTUVWXYZ\",\n        \"01234567890ABCDEFGHIJKLMN0PQRSTUVWXYZ0X\",\n        \"h\u00e9t\u00e9rog\u00e9n\u00e9it\u00e9\",\n        \"\ud83c\udf86\ud83c\udf83\ud83c\udf87\ud83c\udf88\",\n        \"\ud83d\ude0d\ud83d\ude00\ud83d\ude4c\ud83d\udc83\ud83d\ude0d\ud83d\ude4c\",\n        \"\ud83d\udc20\ud83d\udc1f\ud83d\udc21\ud83e\udd88\ud83d\udc2c\ud83d\udc33\ud83d\udc0b\ud83d\udc21\",]\n\nstrings.each do |str|\n  seen = {}\n  print \"\n  res = \"has no duplicates.\" \n  str.chars.each_with_index do |c,i|\n    if seen[c].nil? \n      seen[c] = i\n    else\n      res =  \"has duplicate char \n      break\n    end\n  end\n  puts res\nend\n", "target": "\n\nfrom itertools import groupby\n\n\n\ndef duplicatedCharIndices(s):\n    \n    def go(xs):\n        if 1 < len(xs):\n            duplicates = list(filter(lambda kv: 1 < len(kv[1]), [\n                (k, list(v)) for k, v in groupby(\n                    sorted(xs, key=swap),\n                    key=snd\n                )\n            ]))\n            return Just(second(fmap(fst))(\n                sorted(\n                    duplicates,\n                    key=lambda kv: kv[1][0]\n                )[0]\n            )) if duplicates else Nothing()\n        else:\n            return Nothing()\n    return go(list(enumerate(s)))\n\n\n\n\ndef main():\n    \n\n    def showSample(s):\n        return repr(s) + ' (' + str(len(s)) + ')'\n\n    def showDuplicate(cix):\n        c, ix = cix\n        return repr(c) + (\n            ' (' + hex(ord(c)) + ') at ' + repr(ix)\n        )\n\n    print(\n        fTable('First duplicated character, if any:')(\n            showSample\n        )(maybe('None')(showDuplicate))(duplicatedCharIndices)([\n            '', '.', 'abcABC', 'XYZ ZYX',\n            '1234567890ABCDEFGHIJKLMN0PQRSTUVWXYZ'\n        ])\n    )\n\n\n\n\n\n\ndef fTable(s):\n    \n    def go(xShow, fxShow, f, xs):\n        ys = [xShow(x) for x in xs]\n        w = max(map(len, ys))\n        return s + '\\n' + '\\n'.join(map(\n            lambda x, y: y.rjust(w, ' ') + ' -> ' + fxShow(f(x)),\n            xs, ys\n        ))\n    return lambda xShow: lambda fxShow: lambda f: lambda xs: go(\n        xShow, fxShow, f, xs\n    )\n\n\n\n\n\ndef Just(x):\n    \n    return {'type': 'Maybe', 'Nothing': False, 'Just': x}\n\n\n\ndef Nothing():\n    \n    return {'type': 'Maybe', 'Nothing': True}\n\n\n\ndef fmap(f):\n    \n    return lambda xs: [f(x) for x in xs]\n\n\n\ndef fst(tpl):\n    \n    return tpl[0]\n\n\n\ndef head(xs):\n    \n    return xs[0] if isinstance(xs, list) else next(xs)\n\n\n\ndef maybe(v):\n    \n    return lambda f: lambda m: v if (\n        None is m or m.get('Nothing')\n    ) else f(m.get('Just'))\n\n\n\ndef second(f):\n    \n    return lambda xy: (xy[0], f(xy[1]))\n\n\n\ndef snd(tpl):\n    \n    return tpl[1]\n\n\n\ndef swap(tpl):\n    \n    return (tpl[1], tpl[0])\n\n\n\nif __name__ == '__main__':\n    main()\n"}
{"id": 71936, "name": "Combinations with repetitions", "source": "Translate Ruby to C#: possible_doughnuts = [\"iced\", \"jam\", \"plain\"].repeated_combinations(2)\nputs \"There are \npossible_doughnuts.each{|doughnut_combi| puts doughnut_combi.join(\" and \")}\n \n\npossible_doughnuts = (1..10).to_a.repeated_combinations(3)\n\nputs \"\", \"\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\npublic static class MultiCombinations\n{\n    private static void Main()\n    {\n        var set = new List<string> { \"iced\", \"jam\", \"plain\" };\n        var combinations = GenerateCombinations(set, 2);\n\n        foreach (var combination in combinations)\n        {\n            string combinationStr = string.Join(\" \", combination);\n            Console.WriteLine(combinationStr);\n        }\n\n        var donuts = Enumerable.Range(1, 10).ToList();\n\n        int donutsCombinationsNumber = GenerateCombinations(donuts, 3).Count;\n\n        Console.WriteLine(\"{0} ways to order 3 donuts given 10 types\", donutsCombinationsNumber);\n    }\n    \n    private static List<List<T>> GenerateCombinations<T>(List<T> combinationList, int k)\n    {\n        var combinations = new List<List<T>>();\n\n        if (k == 0)\n        {\n            var emptyCombination = new List<T>();\n            combinations.Add(emptyCombination);\n\n            return combinations;\n        }\n\n        if (combinationList.Count == 0)\n        {\n            return combinations;\n        }\n\n        T head = combinationList[0];\n        var copiedCombinationList = new List<T>(combinationList);\n        \n        List<List<T>> subcombinations = GenerateCombinations(copiedCombinationList, k - 1);\n\n        foreach (var subcombination in subcombinations)\n        {\n            subcombination.Insert(0, head);\n            combinations.Add(subcombination);\n        }\n\n        combinationList.RemoveAt(0);\n        combinations.AddRange(GenerateCombinations(combinationList, k));\n\n        return combinations;\n    }\n}\n"}
{"id": 71938, "name": "Combinations with repetitions", "source": "Translate Ruby to Java: possible_doughnuts = [\"iced\", \"jam\", \"plain\"].repeated_combinations(2)\nputs \"There are \npossible_doughnuts.each{|doughnut_combi| puts doughnut_combi.join(\" and \")}\n \n\npossible_doughnuts = (1..10).to_a.repeated_combinations(3)\n\nputs \"\", \"\n", "target": "import com.objectwave.utility.*;\n\npublic class MultiCombinationsTester {\n\n    public MultiCombinationsTester() throws CombinatoricException {\n        Object[] objects = {\"iced\", \"jam\", \"plain\"};\n        \n        \n        \n        MultiCombinations mc = new MultiCombinations(objects, 2);\n        while (mc.hasMoreElements()) {\n            for (int i = 0; i < mc.nextElement().length; i++) {\n                System.out.print(mc.nextElement()[i].toString() + \" \");\n            }\n            System.out.println();\n        }\n\n        \n        System.out.println(\"----------\");\n        System.out.println(\"The ways to choose 3 items from 10 with replacement = \" + MultiCombinations.c(10, 3));\n    } \n\n    public static void main(String[] args) throws CombinatoricException {\n        new MultiCombinationsTester();\n    }\n} \n"}
{"id": 71939, "name": "Combinations with repetitions", "source": "Translate Ruby to Python: possible_doughnuts = [\"iced\", \"jam\", \"plain\"].repeated_combinations(2)\nputs \"There are \npossible_doughnuts.each{|doughnut_combi| puts doughnut_combi.join(\" and \")}\n \n\npossible_doughnuts = (1..10).to_a.repeated_combinations(3)\n\nputs \"\", \"\n", "target": ">>> from itertools import combinations_with_replacement\n>>> n, k = 'iced jam plain'.split(), 2\n>>> list(combinations_with_replacement(n,k))\n[('iced', 'iced'), ('iced', 'jam'), ('iced', 'plain'), ('jam', 'jam'), ('jam', 'plain'), ('plain', 'plain')]\n>>> \n>>> len(list(combinations_with_replacement(range(10), 3)))\n220\n>>>\n"}
{"id": 72285, "name": "Multiple distinct objects", "source": "Translate Ruby to C#: [Foo.new] * n         \nArray.new(n, Foo.new)\n", "target": "using System;\nusing System.Linq;\nusing System.Collections.Generic;\n\nList<Foo> foos = Enumerable.Range(1, n).Select(x => new Foo()).ToList();\n"}
{"id": 72286, "name": "Multiple distinct objects", "source": "Translate Ruby to C#: [Foo.new] * n         \nArray.new(n, Foo.new)\n", "target": "using System;\nusing System.Linq;\nusing System.Collections.Generic;\n\nList<Foo> foos = Enumerable.Range(1, n).Select(x => new Foo()).ToList();\n"}
{"id": 72289, "name": "Multiple distinct objects", "source": "Translate Ruby to Java: [Foo.new] * n         \nArray.new(n, Foo.new)\n", "target": "Foo[] foos = new Foo[n]; \nfor (int i = 0; i < foos.length; i++)\n    foos[i] = new Foo();\n\n\nFoo[] foos_WRONG = new Foo[n];\nArrays.fill(foos, new Foo());  \n"}
{"id": 72290, "name": "Multiple distinct objects", "source": "Translate Ruby to Java: [Foo.new] * n         \nArray.new(n, Foo.new)\n", "target": "Foo[] foos = new Foo[n]; \nfor (int i = 0; i < foos.length; i++)\n    foos[i] = new Foo();\n\n\nFoo[] foos_WRONG = new Foo[n];\nArrays.fill(foos, new Foo());  \n"}
{"id": 72536, "name": "Five weekends", "source": "Translate Ruby to C#: require 'date'\n\n\n\nLONG_MONTHS = [1,3,5,7,8,10,12]\nYEARS       = (1900..2100).to_a\n\ndates    = YEARS.product(LONG_MONTHS).map{|y, m| Date.new(y,m,31)}.select(&:sunday?)\nyears_4w = YEARS - dates.map(&:year)\n\nputs \"There are \nputs dates.first(5).map {|d| d.strftime(\"%b %Y\") }, \"...\"\nputs dates.last(5).map {|d| d.strftime(\"%b %Y\") }\nputs \"There are \nputs years_4w.join(\", \")\n", "target": "using System;\n\nnamespace _5_Weekends\n{\n    class Program\n    {\n        const int FIRST_YEAR = 1900;\n        const int LAST_YEAR = 2100;\n        static int[] _31_MONTHS = { 1, 3, 5, 7, 8, 10, 12 }; \n\n        static void Main(string[] args)\n        {\n            int totalNum = 0;\n            int totalNo5Weekends = 0;\n\n            for (int year = FIRST_YEAR; year <= LAST_YEAR; year++)\n            {\n                bool has5Weekends = false;\n\n                foreach (int month in _31_MONTHS)\n                {\n                    DateTime firstDay = new DateTime(year, month, 1);\n                    if (firstDay.DayOfWeek == DayOfWeek.Friday)\n                    {\n                        totalNum++;\n                        has5Weekends = true;\n                        Console.WriteLine(firstDay.ToString(\"yyyy - MMMM\"));\n                    }\n                }\n\n                if (!has5Weekends) totalNo5Weekends++;\n            }\n            Console.WriteLine(\"Total 5-weekend months between {0} and {1}: {2}\", FIRST_YEAR, LAST_YEAR, totalNum);\n            Console.WriteLine(\"Total number of years with no 5-weekend months {0}\", totalNo5Weekends);\n        }\n    }\n}\n"}
{"id": 72538, "name": "Five weekends", "source": "Translate Ruby to Java: require 'date'\n\n\n\nLONG_MONTHS = [1,3,5,7,8,10,12]\nYEARS       = (1900..2100).to_a\n\ndates    = YEARS.product(LONG_MONTHS).map{|y, m| Date.new(y,m,31)}.select(&:sunday?)\nyears_4w = YEARS - dates.map(&:year)\n\nputs \"There are \nputs dates.first(5).map {|d| d.strftime(\"%b %Y\") }, \"...\"\nputs dates.last(5).map {|d| d.strftime(\"%b %Y\") }\nputs \"There are \nputs years_4w.join(\", \")\n", "target": "import java.util.Calendar;\nimport java.util.GregorianCalendar;\n\npublic class FiveFSS {\n    private static boolean[] years = new boolean[201];\n    private static int[] month31 = {Calendar.JANUARY, Calendar.MARCH, Calendar.MAY,\n        Calendar.JULY, Calendar.AUGUST, Calendar.OCTOBER, Calendar.DECEMBER};\n\n    public static void main(String[] args) {\n        StringBuilder months = new StringBuilder();\n        int numMonths = 0;\n        for (int year = 1900; year <= 2100; year++) {\n            for (int month : month31) {\n                Calendar date = new GregorianCalendar(year, month, 1);\n                if (date.get(Calendar.DAY_OF_WEEK) == Calendar.FRIDAY) {\n                    years[year - 1900] = true;\n                    numMonths++;\n                    \n                    months.append((date.get(Calendar.MONTH) + 1) + \"-\" + year +\"\\n\");\n                }\n            }\n        }\n        System.out.println(\"There are \"+numMonths+\" months with five weekends from 1900 through 2100:\");\n        System.out.println(months);\n        System.out.println(\"Years with no five-weekend months:\");\n        for (int year = 1900; year <= 2100; year++) {\n            if(!years[year - 1900]){\n                System.out.println(year);\n            }\n        }\n    }\n}\n"}
{"id": 72539, "name": "Five weekends", "source": "Translate Ruby to Python: require 'date'\n\n\n\nLONG_MONTHS = [1,3,5,7,8,10,12]\nYEARS       = (1900..2100).to_a\n\ndates    = YEARS.product(LONG_MONTHS).map{|y, m| Date.new(y,m,31)}.select(&:sunday?)\nyears_4w = YEARS - dates.map(&:year)\n\nputs \"There are \nputs dates.first(5).map {|d| d.strftime(\"%b %Y\") }, \"...\"\nputs dates.last(5).map {|d| d.strftime(\"%b %Y\") }\nputs \"There are \nputs years_4w.join(\", \")\n", "target": "from datetime import (date,\n                      timedelta)\n\nDAY = timedelta(days=1)\nSTART, STOP = date(1900, 1, 1), date(2101, 1, 1)\nWEEKEND = {6, 5, 4}  \nFMT = '%Y %m(%B)'\n\n\ndef five_weekends_per_month(start: date = START,\n                            stop: date = STOP) -> list[date]:\n    \n    current_date = start\n    last_month = weekend_days = 0\n    five_weekends = []\n    while current_date < stop:\n        if current_date.month != last_month:\n            if weekend_days >= 15:\n                five_weekends.append(current_date - DAY)\n            weekend_days = 0\n            last_month = current_date.month\n        if current_date.weekday() in WEEKEND:\n            weekend_days += 1\n        current_date += DAY\n    return five_weekends\n\n\ndates = five_weekends_per_month()\nindent = '  '\nprint(f\"There are {len(dates)} months of which the first and last five are:\")\nprint(indent + ('\\n' + indent).join(d.strftime(FMT) for d in dates[:5]))\nprint(indent + '...')\nprint(indent + ('\\n' + indent).join(d.strftime(FMT) for d in dates[-5:]))\n\nyears_without_five_weekends_months = (STOP.year - START.year\n                                      - len({d.year for d in dates}))\nprint(f\"\\nThere are {years_without_five_weekends_months} years in the \"\n      f\"range that do not have months with five weekends\")\n"}
{"id": 72830, "name": "Bell numbers", "source": "Translate Ruby to C#: def bellTriangle(n)\n    tri = Array.new(n)\n    for i in 0 .. n - 1 do\n        tri[i] = Array.new(i)\n        for j in 0 .. i - 1 do\n            tri[i][j] = 0\n        end\n    end\n    tri[1][0] = 1\n    for i in 2 .. n - 1 do\n        tri[i][0] = tri[i - 1][i - 2]\n        for j in 1 .. i - 1 do\n            tri[i][j] = tri[i][j - 1] + tri[i - 1][j - 1]\n        end\n    end\n    return tri\nend\n\ndef main\n    bt = bellTriangle(51)\n    puts \"First fifteen and fiftieth Bell numbers:\"\n    for i in 1 .. 15 do\n        puts \"%2d: %d\" % [i, bt[i][0]]\n    end\n    puts \"50: %d\" % [bt[50][0]]\n    puts\n\n    puts \"The first ten rows of Bell's triangle:\"\n    for i in 1 .. 10 do\n        puts bt[i].inspect\n    end\nend\n\nmain()\n", "target": "using System;\nusing System.Numerics;\n\nnamespace BellNumbers {\n    public static class Utility {\n        public static void Init<T>(this T[] array, T value) {\n            if (null == array) return;\n            for (int i = 0; i < array.Length; ++i) {\n                array[i] = value;\n            }\n        }\n    }\n\n    class Program {\n        static BigInteger[][] BellTriangle(int n) {\n            BigInteger[][] tri = new BigInteger[n][];\n            for (int i = 0; i < n; ++i) {\n                tri[i] = new BigInteger[i];\n                tri[i].Init(BigInteger.Zero);\n            }\n            tri[1][0] = 1;\n            for (int i = 2; i < n; ++i) {\n                tri[i][0] = tri[i - 1][i - 2];\n                for (int j = 1; j < i; ++j) {\n                    tri[i][j] = tri[i][j - 1] + tri[i - 1][j - 1];\n                }\n            }\n            return tri;\n        }\n\n        static void Main(string[] args) {\n            var bt = BellTriangle(51);\n            Console.WriteLine(\"First fifteen and fiftieth Bell numbers:\");\n            for (int i = 1; i < 16; ++i) {\n                Console.WriteLine(\"{0,2}: {1}\", i, bt[i][0]);\n            }\n            Console.WriteLine(\"50: {0}\", bt[50][0]);\n            Console.WriteLine();\n            Console.WriteLine(\"The first ten rows of Bell's triangle:\");\n            for (int i = 1; i < 11; ++i) {\n                \n                var it = bt[i].GetEnumerator();\n                Console.Write(\"[\");\n                if (it.MoveNext()) {\n                    Console.Write(it.Current);\n                }\n                while (it.MoveNext()) {\n                    Console.Write(\", \");\n                    Console.Write(it.Current);\n                }\n                Console.WriteLine(\"]\");\n            }\n        }\n    }\n}\n"}
{"id": 72831, "name": "Bell numbers", "source": "Translate Ruby to C#: def bellTriangle(n)\n    tri = Array.new(n)\n    for i in 0 .. n - 1 do\n        tri[i] = Array.new(i)\n        for j in 0 .. i - 1 do\n            tri[i][j] = 0\n        end\n    end\n    tri[1][0] = 1\n    for i in 2 .. n - 1 do\n        tri[i][0] = tri[i - 1][i - 2]\n        for j in 1 .. i - 1 do\n            tri[i][j] = tri[i][j - 1] + tri[i - 1][j - 1]\n        end\n    end\n    return tri\nend\n\ndef main\n    bt = bellTriangle(51)\n    puts \"First fifteen and fiftieth Bell numbers:\"\n    for i in 1 .. 15 do\n        puts \"%2d: %d\" % [i, bt[i][0]]\n    end\n    puts \"50: %d\" % [bt[50][0]]\n    puts\n\n    puts \"The first ten rows of Bell's triangle:\"\n    for i in 1 .. 10 do\n        puts bt[i].inspect\n    end\nend\n\nmain()\n", "target": "using System;\nusing System.Numerics;\n\nnamespace BellNumbers {\n    public static class Utility {\n        public static void Init<T>(this T[] array, T value) {\n            if (null == array) return;\n            for (int i = 0; i < array.Length; ++i) {\n                array[i] = value;\n            }\n        }\n    }\n\n    class Program {\n        static BigInteger[][] BellTriangle(int n) {\n            BigInteger[][] tri = new BigInteger[n][];\n            for (int i = 0; i < n; ++i) {\n                tri[i] = new BigInteger[i];\n                tri[i].Init(BigInteger.Zero);\n            }\n            tri[1][0] = 1;\n            for (int i = 2; i < n; ++i) {\n                tri[i][0] = tri[i - 1][i - 2];\n                for (int j = 1; j < i; ++j) {\n                    tri[i][j] = tri[i][j - 1] + tri[i - 1][j - 1];\n                }\n            }\n            return tri;\n        }\n\n        static void Main(string[] args) {\n            var bt = BellTriangle(51);\n            Console.WriteLine(\"First fifteen and fiftieth Bell numbers:\");\n            for (int i = 1; i < 16; ++i) {\n                Console.WriteLine(\"{0,2}: {1}\", i, bt[i][0]);\n            }\n            Console.WriteLine(\"50: {0}\", bt[50][0]);\n            Console.WriteLine();\n            Console.WriteLine(\"The first ten rows of Bell's triangle:\");\n            for (int i = 1; i < 11; ++i) {\n                \n                var it = bt[i].GetEnumerator();\n                Console.Write(\"[\");\n                if (it.MoveNext()) {\n                    Console.Write(it.Current);\n                }\n                while (it.MoveNext()) {\n                    Console.Write(\", \");\n                    Console.Write(it.Current);\n                }\n                Console.WriteLine(\"]\");\n            }\n        }\n    }\n}\n"}
{"id": 72834, "name": "Bell numbers", "source": "Translate Ruby to Java: def bellTriangle(n)\n    tri = Array.new(n)\n    for i in 0 .. n - 1 do\n        tri[i] = Array.new(i)\n        for j in 0 .. i - 1 do\n            tri[i][j] = 0\n        end\n    end\n    tri[1][0] = 1\n    for i in 2 .. n - 1 do\n        tri[i][0] = tri[i - 1][i - 2]\n        for j in 1 .. i - 1 do\n            tri[i][j] = tri[i][j - 1] + tri[i - 1][j - 1]\n        end\n    end\n    return tri\nend\n\ndef main\n    bt = bellTriangle(51)\n    puts \"First fifteen and fiftieth Bell numbers:\"\n    for i in 1 .. 15 do\n        puts \"%2d: %d\" % [i, bt[i][0]]\n    end\n    puts \"50: %d\" % [bt[50][0]]\n    puts\n\n    puts \"The first ten rows of Bell's triangle:\"\n    for i in 1 .. 10 do\n        puts bt[i].inspect\n    end\nend\n\nmain()\n", "target": "import java.util.ArrayList;\nimport java.util.List;\n\npublic class Bell {\n    private static class BellTriangle {\n        private List<Integer> arr;\n\n        BellTriangle(int n) {\n            int length = n * (n + 1) / 2;\n            arr = new ArrayList<>(length);\n            for (int i = 0; i < length; ++i) {\n                arr.add(0);\n            }\n\n            set(1, 0, 1);\n            for (int i = 2; i <= n; ++i) {\n                set(i, 0, get(i - 1, i - 2));\n                for (int j = 1; j < i; ++j) {\n                    int value = get(i, j - 1) + get(i - 1, j - 1);\n                    set(i, j, value);\n                }\n            }\n        }\n\n        private int index(int row, int col) {\n            if (row > 0 && col >= 0 && col < row) {\n                return row * (row - 1) / 2 + col;\n            } else {\n                throw new IllegalArgumentException();\n            }\n        }\n\n        public int get(int row, int col) {\n            int i = index(row, col);\n            return arr.get(i);\n        }\n\n        public void set(int row, int col, int value) {\n            int i = index(row, col);\n            arr.set(i, value);\n        }\n    }\n\n    public static void main(String[] args) {\n        final int rows = 15;\n        BellTriangle bt = new BellTriangle(rows);\n\n        System.out.println(\"First fifteen Bell numbers:\");\n        for (int i = 0; i < rows; ++i) {\n            System.out.printf(\"%2d: %d\\n\", i + 1, bt.get(i + 1, 0));\n        }\n\n        for (int i = 1; i <= 10; ++i) {\n            System.out.print(bt.get(i, 0));\n            for (int j = 1; j < i; ++j) {\n                System.out.printf(\", %d\", bt.get(i, j));\n            }\n            System.out.println();\n        }\n    }\n}\n"}
{"id": 72835, "name": "Bell numbers", "source": "Translate Ruby to Java: def bellTriangle(n)\n    tri = Array.new(n)\n    for i in 0 .. n - 1 do\n        tri[i] = Array.new(i)\n        for j in 0 .. i - 1 do\n            tri[i][j] = 0\n        end\n    end\n    tri[1][0] = 1\n    for i in 2 .. n - 1 do\n        tri[i][0] = tri[i - 1][i - 2]\n        for j in 1 .. i - 1 do\n            tri[i][j] = tri[i][j - 1] + tri[i - 1][j - 1]\n        end\n    end\n    return tri\nend\n\ndef main\n    bt = bellTriangle(51)\n    puts \"First fifteen and fiftieth Bell numbers:\"\n    for i in 1 .. 15 do\n        puts \"%2d: %d\" % [i, bt[i][0]]\n    end\n    puts \"50: %d\" % [bt[50][0]]\n    puts\n\n    puts \"The first ten rows of Bell's triangle:\"\n    for i in 1 .. 10 do\n        puts bt[i].inspect\n    end\nend\n\nmain()\n", "target": "import java.util.ArrayList;\nimport java.util.List;\n\npublic class Bell {\n    private static class BellTriangle {\n        private List<Integer> arr;\n\n        BellTriangle(int n) {\n            int length = n * (n + 1) / 2;\n            arr = new ArrayList<>(length);\n            for (int i = 0; i < length; ++i) {\n                arr.add(0);\n            }\n\n            set(1, 0, 1);\n            for (int i = 2; i <= n; ++i) {\n                set(i, 0, get(i - 1, i - 2));\n                for (int j = 1; j < i; ++j) {\n                    int value = get(i, j - 1) + get(i - 1, j - 1);\n                    set(i, j, value);\n                }\n            }\n        }\n\n        private int index(int row, int col) {\n            if (row > 0 && col >= 0 && col < row) {\n                return row * (row - 1) / 2 + col;\n            } else {\n                throw new IllegalArgumentException();\n            }\n        }\n\n        public int get(int row, int col) {\n            int i = index(row, col);\n            return arr.get(i);\n        }\n\n        public void set(int row, int col, int value) {\n            int i = index(row, col);\n            arr.set(i, value);\n        }\n    }\n\n    public static void main(String[] args) {\n        final int rows = 15;\n        BellTriangle bt = new BellTriangle(rows);\n\n        System.out.println(\"First fifteen Bell numbers:\");\n        for (int i = 0; i < rows; ++i) {\n            System.out.printf(\"%2d: %d\\n\", i + 1, bt.get(i + 1, 0));\n        }\n\n        for (int i = 1; i <= 10; ++i) {\n            System.out.print(bt.get(i, 0));\n            for (int j = 1; j < i; ++j) {\n                System.out.printf(\", %d\", bt.get(i, j));\n            }\n            System.out.println();\n        }\n    }\n}\n"}
{"id": 72836, "name": "Bell numbers", "source": "Translate Ruby to Python: def bellTriangle(n)\n    tri = Array.new(n)\n    for i in 0 .. n - 1 do\n        tri[i] = Array.new(i)\n        for j in 0 .. i - 1 do\n            tri[i][j] = 0\n        end\n    end\n    tri[1][0] = 1\n    for i in 2 .. n - 1 do\n        tri[i][0] = tri[i - 1][i - 2]\n        for j in 1 .. i - 1 do\n            tri[i][j] = tri[i][j - 1] + tri[i - 1][j - 1]\n        end\n    end\n    return tri\nend\n\ndef main\n    bt = bellTriangle(51)\n    puts \"First fifteen and fiftieth Bell numbers:\"\n    for i in 1 .. 15 do\n        puts \"%2d: %d\" % [i, bt[i][0]]\n    end\n    puts \"50: %d\" % [bt[50][0]]\n    puts\n\n    puts \"The first ten rows of Bell's triangle:\"\n    for i in 1 .. 10 do\n        puts bt[i].inspect\n    end\nend\n\nmain()\n", "target": "def bellTriangle(n):\n    tri = [None] * n\n    for i in xrange(n):\n        tri[i] = [0] * i\n    tri[1][0] = 1\n    for i in xrange(2, n):\n        tri[i][0] = tri[i - 1][i - 2]\n        for j in xrange(1, i):\n            tri[i][j] = tri[i][j - 1] + tri[i - 1][j - 1]\n    return tri\n\ndef main():\n    bt = bellTriangle(51)\n    print \"First fifteen and fiftieth Bell numbers:\"\n    for i in xrange(1, 16):\n        print \"%2d: %d\" % (i, bt[i][0])\n    print \"50:\", bt[50][0]\n    print\n    print \"The first ten rows of Bell's triangle:\"\n    for i in xrange(1, 11):\n        print bt[i]\n\nmain()\n"}
{"id": 72837, "name": "Bell numbers", "source": "Translate Ruby to Python: def bellTriangle(n)\n    tri = Array.new(n)\n    for i in 0 .. n - 1 do\n        tri[i] = Array.new(i)\n        for j in 0 .. i - 1 do\n            tri[i][j] = 0\n        end\n    end\n    tri[1][0] = 1\n    for i in 2 .. n - 1 do\n        tri[i][0] = tri[i - 1][i - 2]\n        for j in 1 .. i - 1 do\n            tri[i][j] = tri[i][j - 1] + tri[i - 1][j - 1]\n        end\n    end\n    return tri\nend\n\ndef main\n    bt = bellTriangle(51)\n    puts \"First fifteen and fiftieth Bell numbers:\"\n    for i in 1 .. 15 do\n        puts \"%2d: %d\" % [i, bt[i][0]]\n    end\n    puts \"50: %d\" % [bt[50][0]]\n    puts\n\n    puts \"The first ten rows of Bell's triangle:\"\n    for i in 1 .. 10 do\n        puts bt[i].inspect\n    end\nend\n\nmain()\n", "target": "def bellTriangle(n):\n    tri = [None] * n\n    for i in xrange(n):\n        tri[i] = [0] * i\n    tri[1][0] = 1\n    for i in xrange(2, n):\n        tri[i][0] = tri[i - 1][i - 2]\n        for j in xrange(1, i):\n            tri[i][j] = tri[i][j - 1] + tri[i - 1][j - 1]\n    return tri\n\ndef main():\n    bt = bellTriangle(51)\n    print \"First fifteen and fiftieth Bell numbers:\"\n    for i in xrange(1, 16):\n        print \"%2d: %d\" % (i, bt[i][0])\n    print \"50:\", bt[50][0]\n    print\n    print \"The first ten rows of Bell's triangle:\"\n    for i in xrange(1, 11):\n        print bt[i]\n\nmain()\n"}
{"id": 73222, "name": "Modular exponentiation", "source": "Translate Ruby to C#: require \"big\"\n\nmodule Integer \n  module Powmod\n\n    \n    def powmod(e, m)\n      r, b = 1, self.to_big_i\n      while e > 0\n        r = (b * r) % m if e.odd?\n        b = (b * b) % m\n        e >>= 1\n      end\n      r\n    end\n  end\nend\n\nstruct Int; include Integer::Powmod end\n\na = \"2988348162058574136915891421498819466320163312926952423791023078876139\".to_big_i\nb = \"2351399303373464486466122544523690094744975233415544072992656881240319\".to_big_i\nm = 10.to_big_i ** 40\n\nputs a.powmod(b, m)\n", "target": "using System;\nusing System.Numerics;\n\nclass Program\n{\n    static void Main() {\n        var a = BigInteger.Parse(\"2988348162058574136915891421498819466320163312926952423791023078876139\");\n        var b = BigInteger.Parse(\"2351399303373464486466122544523690094744975233415544072992656881240319\");\n        var m = BigInteger.Pow(10, 40);\n        Console.WriteLine(BigInteger.ModPow(a, b, m));\n    }\n}\n"}
{"id": 73223, "name": "Modular exponentiation", "source": "Translate Ruby to C#: require \"big\"\n\nmodule Integer \n  module Powmod\n\n    \n    def powmod(e, m)\n      r, b = 1, self.to_big_i\n      while e > 0\n        r = (b * r) % m if e.odd?\n        b = (b * b) % m\n        e >>= 1\n      end\n      r\n    end\n  end\nend\n\nstruct Int; include Integer::Powmod end\n\na = \"2988348162058574136915891421498819466320163312926952423791023078876139\".to_big_i\nb = \"2351399303373464486466122544523690094744975233415544072992656881240319\".to_big_i\nm = 10.to_big_i ** 40\n\nputs a.powmod(b, m)\n", "target": "using System;\nusing System.Numerics;\n\nclass Program\n{\n    static void Main() {\n        var a = BigInteger.Parse(\"2988348162058574136915891421498819466320163312926952423791023078876139\");\n        var b = BigInteger.Parse(\"2351399303373464486466122544523690094744975233415544072992656881240319\");\n        var m = BigInteger.Pow(10, 40);\n        Console.WriteLine(BigInteger.ModPow(a, b, m));\n    }\n}\n"}
{"id": 73226, "name": "Modular exponentiation", "source": "Translate Ruby to Java: require \"big\"\n\nmodule Integer \n  module Powmod\n\n    \n    def powmod(e, m)\n      r, b = 1, self.to_big_i\n      while e > 0\n        r = (b * r) % m if e.odd?\n        b = (b * b) % m\n        e >>= 1\n      end\n      r\n    end\n  end\nend\n\nstruct Int; include Integer::Powmod end\n\na = \"2988348162058574136915891421498819466320163312926952423791023078876139\".to_big_i\nb = \"2351399303373464486466122544523690094744975233415544072992656881240319\".to_big_i\nm = 10.to_big_i ** 40\n\nputs a.powmod(b, m)\n", "target": "import java.math.BigInteger;\n\npublic class PowMod {\n    public static void main(String[] args){\n        BigInteger a = new BigInteger(\n      \"2988348162058574136915891421498819466320163312926952423791023078876139\");\n        BigInteger b = new BigInteger(\n      \"2351399303373464486466122544523690094744975233415544072992656881240319\");\n        BigInteger m = new BigInteger(\"10000000000000000000000000000000000000000\");\n        \n        System.out.println(a.modPow(b, m));\n    }\n}\n"}
{"id": 73227, "name": "Modular exponentiation", "source": "Translate Ruby to Java: require \"big\"\n\nmodule Integer \n  module Powmod\n\n    \n    def powmod(e, m)\n      r, b = 1, self.to_big_i\n      while e > 0\n        r = (b * r) % m if e.odd?\n        b = (b * b) % m\n        e >>= 1\n      end\n      r\n    end\n  end\nend\n\nstruct Int; include Integer::Powmod end\n\na = \"2988348162058574136915891421498819466320163312926952423791023078876139\".to_big_i\nb = \"2351399303373464486466122544523690094744975233415544072992656881240319\".to_big_i\nm = 10.to_big_i ** 40\n\nputs a.powmod(b, m)\n", "target": "import java.math.BigInteger;\n\npublic class PowMod {\n    public static void main(String[] args){\n        BigInteger a = new BigInteger(\n      \"2988348162058574136915891421498819466320163312926952423791023078876139\");\n        BigInteger b = new BigInteger(\n      \"2351399303373464486466122544523690094744975233415544072992656881240319\");\n        BigInteger m = new BigInteger(\"10000000000000000000000000000000000000000\");\n        \n        System.out.println(a.modPow(b, m));\n    }\n}\n"}
{"id": 73228, "name": "Modular exponentiation", "source": "Translate Ruby to Python: require \"big\"\n\nmodule Integer \n  module Powmod\n\n    \n    def powmod(e, m)\n      r, b = 1, self.to_big_i\n      while e > 0\n        r = (b * r) % m if e.odd?\n        b = (b * b) % m\n        e >>= 1\n      end\n      r\n    end\n  end\nend\n\nstruct Int; include Integer::Powmod end\n\na = \"2988348162058574136915891421498819466320163312926952423791023078876139\".to_big_i\nb = \"2351399303373464486466122544523690094744975233415544072992656881240319\".to_big_i\nm = 10.to_big_i ** 40\n\nputs a.powmod(b, m)\n", "target": "a = 2988348162058574136915891421498819466320163312926952423791023078876139\nb = 2351399303373464486466122544523690094744975233415544072992656881240319\nm = 10 ** 40\nprint(pow(a, b, m))\n"}
{"id": 73229, "name": "Modular exponentiation", "source": "Translate Ruby to Python: require \"big\"\n\nmodule Integer \n  module Powmod\n\n    \n    def powmod(e, m)\n      r, b = 1, self.to_big_i\n      while e > 0\n        r = (b * r) % m if e.odd?\n        b = (b * b) % m\n        e >>= 1\n      end\n      r\n    end\n  end\nend\n\nstruct Int; include Integer::Powmod end\n\na = \"2988348162058574136915891421498819466320163312926952423791023078876139\".to_big_i\nb = \"2351399303373464486466122544523690094744975233415544072992656881240319\".to_big_i\nm = 10.to_big_i ** 40\n\nputs a.powmod(b, m)\n", "target": "a = 2988348162058574136915891421498819466320163312926952423791023078876139\nb = 2351399303373464486466122544523690094744975233415544072992656881240319\nm = 10 ** 40\nprint(pow(a, b, m))\n"}
{"id": 73516, "name": "Josephus problem", "source": "Translate Ruby to C#: n = ARGV.fetch(0, 41).to_i  \nk = ARGV.fetch(1,  3).to_i  \n\nprisoners = (0...n).to_a\nwhile prisoners.size > 1; prisoners.rotate!(k-1).shift end\nputs \"From \n", "target": "namespace Josephus\n{\n    using System;\n    using System.Collections;\n    using System.Collections.Generic;\n\n    public class Program\n    {\n        public static int[] JosephusProblem(int n, int m)\n        {\n            var circle = new List<int>();\n            var order = new int[n];\n\n            for (var i = 0; i < n; ++i)\n            {\n                circle.Add(i);\n            }\n\n            var l = 0;\n            var j = 0;\n            var k = 0;\n\n            while (circle.Count != 0)\n            {\n                j++;\n                if (j == m)\n                {\n                    order[k] = circle[l];\n                    circle.RemoveAt(l);\n\n                    k++;\n                    l--;\n                    j = 0;\n                }\n\n                if (k == n - 1)\n                {\n                    order[k] = circle[0];\n                    circle.RemoveAt(0);\n                }\n\n                if (l == circle.Count - 1)\n                {\n                    l = 0;\n                }\n                else\n                {\n                    l++;\n                }\n            }\n\n            return order;\n        }\n\n        static void Main(string[] args)\n        {\n            try\n            {\n                var n = 7;\n                var m = 2;\n\n                var result = JosephusProblem(n, m);\n\n               for (var i = 0; i < result.Length; i++)\n               {\n                   Console.WriteLine(result[i]);\n               }\n            }\n            catch (Exception e)\n            {\n                Console.WriteLine(e);\n            }\n            finally\n            {\n                Console.ReadLine();\n            }\n        }\n\n    }\n}\n"}
{"id": 73518, "name": "Josephus problem", "source": "Translate Ruby to Java: n = ARGV.fetch(0, 41).to_i  \nk = ARGV.fetch(1,  3).to_i  \n\nprisoners = (0...n).to_a\nwhile prisoners.size > 1; prisoners.rotate!(k-1).shift end\nputs \"From \n", "target": "import java.util.ArrayList;\n\npublic class Josephus {\n    public static int execute(int n, int k){\n        int killIdx = 0;\n        ArrayList<Integer> prisoners = new ArrayList<Integer>(n);\n        for(int i = 0;i < n;i++){\n            prisoners.add(i);\n        }\n        System.out.println(\"Prisoners executed in order:\");\n        while(prisoners.size() > 1){\n            killIdx = (killIdx + k - 1) % prisoners.size();\n            System.out.print(prisoners.get(killIdx) + \" \");\n            prisoners.remove(killIdx);\n        }\n        System.out.println();\n        return prisoners.get(0);\n    }\n    \n    public static ArrayList<Integer> executeAllButM(int n, int k, int m){\n        int killIdx = 0;\n        ArrayList<Integer> prisoners = new ArrayList<Integer>(n);\n        for(int i = 0;i < n;i++){\n            prisoners.add(i);\n        }\n        System.out.println(\"Prisoners executed in order:\");\n        while(prisoners.size() > m){\n            killIdx = (killIdx + k - 1) % prisoners.size();\n            System.out.print(prisoners.get(killIdx) + \" \");\n            prisoners.remove(killIdx);\n        }\n        System.out.println();\n        return prisoners;\n    }\n    \n    public static void main(String[] args){\n        System.out.println(\"Survivor: \" + execute(41, 3));\n        System.out.println(\"Survivors: \" + executeAllButM(41, 3, 3));\n    }\n}\n"}
{"id": 73519, "name": "Josephus problem", "source": "Translate Ruby to Python: n = ARGV.fetch(0, 41).to_i  \nk = ARGV.fetch(1,  3).to_i  \n\nprisoners = (0...n).to_a\nwhile prisoners.size > 1; prisoners.rotate!(k-1).shift end\nputs \"From \n", "target": ">>> def j(n, k):\n\tp, i, seq = list(range(n)), 0, []\n\twhile p:\n\t\ti = (i+k-1) % len(p)\n\t\tseq.append(p.pop(i))\n\treturn 'Prisoner killing order: %s.\\nSurvivor: %i' % (', '.join(str(i) for i in seq[:-1]), seq[-1])\n\n>>> print(j(5, 2))\nPrisoner killing order: 1, 3, 0, 4.\nSurvivor: 2\n>>> print(j(41, 3))\nPrisoner killing order: 2, 5, 8, 11, 14, 17, 20, 23, 26, 29, 32, 35, 38, 0, 4, 9, 13, 18, 22, 27, 31, 36, 40, 6, 12, 19, 25, 33, 39, 7, 16, 28, 37, 10, 24, 1, 21, 3, 34, 15.\nSurvivor: 30\n>>>\n"}
{"id": 73736, "name": "Pathological floating point problems", "source": "Translate Ruby to C#: require \"big\"\n\nar = [0.to_big_d, 2.to_big_d, -4.to_big_d]\n\n100.times { ar << 111 - 1130.to_big_d.div(ar[-1], 132) + 3000.to_big_d.div((ar[-1] * ar[-2]), 132) }\n\n[3, 4, 5, 6, 7, 8, 20, 30, 50, 100].each do |n|\n  puts \"%3d -> %0.16f\" % [n, ar[n]]\nend\n", "target": "#define USE_BIGRATIONAL\n#define BANDED_ROWS\n#define INCREASED_LIMITS\n\nusing System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\nusing System.Globalization;\nusing System.Linq;\nusing System.Numerics;\nusing Numerics;\n\nusing static Common;\nusing static Task1;\nusing static Task2;\nusing static Task3;\n\n#if !USE_BIGRATIONAL\n\nstruct BigRational\n{\n    public override string ToString() => \"NOT USING BIGRATIONAL\";\n    public static explicit operator decimal(BigRational value) => -1;\n}\n#endif\n\nstatic class Common\n{\n    public const string FMT_STR = \"{0,4}   {1,-15:G9}   {2,-24:G17}   {3,-32}   {4,-32}\";\n    public static string Headings { get; } =\n        string.Format(\n            CultureInfo.InvariantCulture,\n            FMT_STR,\n            new[] { \"N\", \"Single\", \"Double\", \"Decimal\", \"BigRational (rounded as Decimal)\" });\n\n    [Conditional(\"BANDED_ROWS\")]\n    static void SetConsoleFormat(int n)\n    {\n        if (n % 2 == 0)\n        {\n            Console.BackgroundColor = ConsoleColor.Black;\n            Console.ForegroundColor = ConsoleColor.White;\n        }\n        else\n        {\n            Console.BackgroundColor = ConsoleColor.White;\n            Console.ForegroundColor = ConsoleColor.Black;\n        }\n    }\n\n    public static string FormatOutput(int n, (float sn, double db, decimal dm, BigRational br) x)\n    {\n        SetConsoleFormat(n);\n        return string.Format(CultureInfo.CurrentCulture, FMT_STR, n, x.sn, x.db, x.dm, (decimal)x.br);\n    }\n\n    static void Main()\n    {\n        WrongConvergence();\n\n        Console.WriteLine();\n        ChaoticBankSociety();\n\n        Console.WriteLine();\n        SiegfriedRump();\n\n        SetConsoleFormat(0);\n    }\n}\n"}
{"id": 73737, "name": "Pathological floating point problems", "source": "Translate Ruby to C#: require \"big\"\n\nar = [0.to_big_d, 2.to_big_d, -4.to_big_d]\n\n100.times { ar << 111 - 1130.to_big_d.div(ar[-1], 132) + 3000.to_big_d.div((ar[-1] * ar[-2]), 132) }\n\n[3, 4, 5, 6, 7, 8, 20, 30, 50, 100].each do |n|\n  puts \"%3d -> %0.16f\" % [n, ar[n]]\nend\n", "target": "#define USE_BIGRATIONAL\n#define BANDED_ROWS\n#define INCREASED_LIMITS\n\nusing System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\nusing System.Globalization;\nusing System.Linq;\nusing System.Numerics;\nusing Numerics;\n\nusing static Common;\nusing static Task1;\nusing static Task2;\nusing static Task3;\n\n#if !USE_BIGRATIONAL\n\nstruct BigRational\n{\n    public override string ToString() => \"NOT USING BIGRATIONAL\";\n    public static explicit operator decimal(BigRational value) => -1;\n}\n#endif\n\nstatic class Common\n{\n    public const string FMT_STR = \"{0,4}   {1,-15:G9}   {2,-24:G17}   {3,-32}   {4,-32}\";\n    public static string Headings { get; } =\n        string.Format(\n            CultureInfo.InvariantCulture,\n            FMT_STR,\n            new[] { \"N\", \"Single\", \"Double\", \"Decimal\", \"BigRational (rounded as Decimal)\" });\n\n    [Conditional(\"BANDED_ROWS\")]\n    static void SetConsoleFormat(int n)\n    {\n        if (n % 2 == 0)\n        {\n            Console.BackgroundColor = ConsoleColor.Black;\n            Console.ForegroundColor = ConsoleColor.White;\n        }\n        else\n        {\n            Console.BackgroundColor = ConsoleColor.White;\n            Console.ForegroundColor = ConsoleColor.Black;\n        }\n    }\n\n    public static string FormatOutput(int n, (float sn, double db, decimal dm, BigRational br) x)\n    {\n        SetConsoleFormat(n);\n        return string.Format(CultureInfo.CurrentCulture, FMT_STR, n, x.sn, x.db, x.dm, (decimal)x.br);\n    }\n\n    static void Main()\n    {\n        WrongConvergence();\n\n        Console.WriteLine();\n        ChaoticBankSociety();\n\n        Console.WriteLine();\n        SiegfriedRump();\n\n        SetConsoleFormat(0);\n    }\n}\n"}
{"id": 73738, "name": "Pathological floating point problems", "source": "Translate Ruby to Java: require \"big\"\n\nar = [0.to_big_d, 2.to_big_d, -4.to_big_d]\n\n100.times { ar << 111 - 1130.to_big_d.div(ar[-1], 132) + 3000.to_big_d.div((ar[-1] * ar[-2]), 132) }\n\n[3, 4, 5, 6, 7, 8, 20, 30, 50, 100].each do |n|\n  puts \"%3d -> %0.16f\" % [n, ar[n]]\nend\n", "target": "import java.math.BigDecimal;\nimport java.math.RoundingMode;\n\npublic class FPProblems {\n    public static void wrongConvergence() {\n        int[] INDEXES = new int[] { 3, 4, 5, 6, 7, 8, 20, 30, 50, 100 };\n        \n        \n        double[] fpValues = new double[100];\n        fpValues[0] = 2.0;\n        fpValues[1] = -4.0;\n        for (int i = 2; i < fpValues.length; i++) {\n            fpValues[i] = 111.0 - 1130.0 / fpValues[i - 1] + 3000.0 / (fpValues[i - 1] * fpValues[i - 2]);\n        }\n        \n        \n        BigRational[] brValues = new BigRational[100];\n        brValues[0] = BigRational.valueOf(2);\n        brValues[1] = BigRational.valueOf(-4);\n        for (int i = 2; i < brValues.length; i++) {\n            \n            BigRational clause2 = BigRational.valueOf(1130).divide(brValues[i - 1]);\n            BigRational clause3 = BigRational.valueOf(3000).divide(brValues[i - 1].multiply(brValues[i - 2]));\n            brValues[i] = BigRational.valueOf(111).subtract(clause2).add(clause3);\n        }\n        \n        System.out.println(\"Wrong Convergence Sequence\");\n        for (int n : INDEXES) {\n            BigDecimal value = brValues[n - 1].toBigDecimal(16, RoundingMode.HALF_UP);\n            System.out.println(\"  For index \" + n + \", FP value is \" + fpValues[n - 1] + \", and rounded BigRational value is \" + value.toPlainString());\n        }\n        \n        return;\n    }\n    \n    public static void chaoticBankSociety() {\n        System.out.println(\"Chaotic Bank Society\");\n        double balance = Math.E - 1.0;\n        \n        \n        BigRational e = BigRational.ONE;\n        BigRational d = BigRational.ONE;\n        for (int i = 1; i < 1000; i++) {\n            d = d.multiply(BigRational.valueOf(i));\n            e = e.add(d.reciprocal());\n        }\n        System.out.println(\"DEBUG: e=\" + e.toBigDecimal(100, RoundingMode.HALF_UP).toPlainString());\n        \n        \n        \n        \n        BigRational brBalance = e.subtract(BigRational.ONE);\n        for (int year = 1; year <= 25; year++) {\n            balance = (balance * year) - 1.0;\n            brBalance = brBalance.multiply(BigRational.valueOf(year)).subtract(BigRational.ONE);\n            BigDecimal bdValue = brBalance.toBigDecimal(16, RoundingMode.HALF_UP);\n            System.out.println(\"  Year=\" + year + \", FP balance=\" + balance + \", BigRational balance=\" + bdValue.toPlainString());\n        }\n    }\n    \n    public static void siegfriedRump() {\n        System.out.println(\"Siegfried Rump formula\");\n        double fpValue;\n        {\n            double a = 77617.0;\n            double b = 33096.0;\n            fpValue = 333.75 * Math.pow(b, 6) + a * a * (11.0 * a * a * b * b - Math.pow(b, 6) - 121.0 * Math.pow(b, 4) - 2.0) + 5.5 * Math.pow(b, 8) + a / (2.0 * b);\n        }\n        \n        BigRational brValue;\n        {\n            BigRational a = BigRational.valueOf(77617);\n            BigRational b = BigRational.valueOf(33096);\n            BigRational clause1 = BigRational.valueOf(333.75).multiply(b.pow(6));\n            BigRational clause2a = BigRational.valueOf(11).multiply(a).multiply(a).multiply(b).multiply(b);\n            BigRational clause2b = b.pow(6).add(BigRational.valueOf(121).multiply(b.pow(4))).add(BigRational.valueOf(2));\n            BigRational clause2 = a.multiply(a).multiply(clause2a.subtract(clause2b));\n            BigRational clause3 = BigRational.valueOf(5.5).multiply(b.pow(8));\n            BigRational clause4 = a.divide(b.multiply(BigRational.valueOf(2)));\n            brValue = clause1.add(clause2).add(clause3).add(clause4);\n        }\n        \n        System.out.println(\"  FP value is \" + fpValue);\n        System.out.println(\"  BigRational rounded value is \" + brValue.toBigDecimal(64, RoundingMode.HALF_UP).toPlainString());\n        System.out.println(\"  BigRational full value is \" + brValue.toString());\n    }\n    \n    public static void main(String... args) {\n        wrongConvergence();\n        \n        System.out.println();\n        chaoticBankSociety();\n\n        System.out.println();\n        siegfriedRump();\n    }\n}\n"}
{"id": 73739, "name": "Pathological floating point problems", "source": "Translate Ruby to Java: require \"big\"\n\nar = [0.to_big_d, 2.to_big_d, -4.to_big_d]\n\n100.times { ar << 111 - 1130.to_big_d.div(ar[-1], 132) + 3000.to_big_d.div((ar[-1] * ar[-2]), 132) }\n\n[3, 4, 5, 6, 7, 8, 20, 30, 50, 100].each do |n|\n  puts \"%3d -> %0.16f\" % [n, ar[n]]\nend\n", "target": "import java.math.BigDecimal;\nimport java.math.RoundingMode;\n\npublic class FPProblems {\n    public static void wrongConvergence() {\n        int[] INDEXES = new int[] { 3, 4, 5, 6, 7, 8, 20, 30, 50, 100 };\n        \n        \n        double[] fpValues = new double[100];\n        fpValues[0] = 2.0;\n        fpValues[1] = -4.0;\n        for (int i = 2; i < fpValues.length; i++) {\n            fpValues[i] = 111.0 - 1130.0 / fpValues[i - 1] + 3000.0 / (fpValues[i - 1] * fpValues[i - 2]);\n        }\n        \n        \n        BigRational[] brValues = new BigRational[100];\n        brValues[0] = BigRational.valueOf(2);\n        brValues[1] = BigRational.valueOf(-4);\n        for (int i = 2; i < brValues.length; i++) {\n            \n            BigRational clause2 = BigRational.valueOf(1130).divide(brValues[i - 1]);\n            BigRational clause3 = BigRational.valueOf(3000).divide(brValues[i - 1].multiply(brValues[i - 2]));\n            brValues[i] = BigRational.valueOf(111).subtract(clause2).add(clause3);\n        }\n        \n        System.out.println(\"Wrong Convergence Sequence\");\n        for (int n : INDEXES) {\n            BigDecimal value = brValues[n - 1].toBigDecimal(16, RoundingMode.HALF_UP);\n            System.out.println(\"  For index \" + n + \", FP value is \" + fpValues[n - 1] + \", and rounded BigRational value is \" + value.toPlainString());\n        }\n        \n        return;\n    }\n    \n    public static void chaoticBankSociety() {\n        System.out.println(\"Chaotic Bank Society\");\n        double balance = Math.E - 1.0;\n        \n        \n        BigRational e = BigRational.ONE;\n        BigRational d = BigRational.ONE;\n        for (int i = 1; i < 1000; i++) {\n            d = d.multiply(BigRational.valueOf(i));\n            e = e.add(d.reciprocal());\n        }\n        System.out.println(\"DEBUG: e=\" + e.toBigDecimal(100, RoundingMode.HALF_UP).toPlainString());\n        \n        \n        \n        \n        BigRational brBalance = e.subtract(BigRational.ONE);\n        for (int year = 1; year <= 25; year++) {\n            balance = (balance * year) - 1.0;\n            brBalance = brBalance.multiply(BigRational.valueOf(year)).subtract(BigRational.ONE);\n            BigDecimal bdValue = brBalance.toBigDecimal(16, RoundingMode.HALF_UP);\n            System.out.println(\"  Year=\" + year + \", FP balance=\" + balance + \", BigRational balance=\" + bdValue.toPlainString());\n        }\n    }\n    \n    public static void siegfriedRump() {\n        System.out.println(\"Siegfried Rump formula\");\n        double fpValue;\n        {\n            double a = 77617.0;\n            double b = 33096.0;\n            fpValue = 333.75 * Math.pow(b, 6) + a * a * (11.0 * a * a * b * b - Math.pow(b, 6) - 121.0 * Math.pow(b, 4) - 2.0) + 5.5 * Math.pow(b, 8) + a / (2.0 * b);\n        }\n        \n        BigRational brValue;\n        {\n            BigRational a = BigRational.valueOf(77617);\n            BigRational b = BigRational.valueOf(33096);\n            BigRational clause1 = BigRational.valueOf(333.75).multiply(b.pow(6));\n            BigRational clause2a = BigRational.valueOf(11).multiply(a).multiply(a).multiply(b).multiply(b);\n            BigRational clause2b = b.pow(6).add(BigRational.valueOf(121).multiply(b.pow(4))).add(BigRational.valueOf(2));\n            BigRational clause2 = a.multiply(a).multiply(clause2a.subtract(clause2b));\n            BigRational clause3 = BigRational.valueOf(5.5).multiply(b.pow(8));\n            BigRational clause4 = a.divide(b.multiply(BigRational.valueOf(2)));\n            brValue = clause1.add(clause2).add(clause3).add(clause4);\n        }\n        \n        System.out.println(\"  FP value is \" + fpValue);\n        System.out.println(\"  BigRational rounded value is \" + brValue.toBigDecimal(64, RoundingMode.HALF_UP).toPlainString());\n        System.out.println(\"  BigRational full value is \" + brValue.toString());\n    }\n    \n    public static void main(String... args) {\n        wrongConvergence();\n        \n        System.out.println();\n        chaoticBankSociety();\n\n        System.out.println();\n        siegfriedRump();\n    }\n}\n"}
{"id": 73740, "name": "Pathological floating point problems", "source": "Translate Ruby to Python: require \"big\"\n\nar = [0.to_big_d, 2.to_big_d, -4.to_big_d]\n\n100.times { ar << 111 - 1130.to_big_d.div(ar[-1], 132) + 3000.to_big_d.div((ar[-1] * ar[-2]), 132) }\n\n[3, 4, 5, 6, 7, 8, 20, 30, 50, 100].each do |n|\n  puts \"%3d -> %0.16f\" % [n, ar[n]]\nend\n", "target": "from fractions import Fraction\n\ndef muller_seq(n:int) -> float:\n    seq = [Fraction(0), Fraction(2), Fraction(-4)]\n    for i in range(3, n+1):\n        next_value = (111 - 1130/seq[i-1]\n            + 3000/(seq[i-1]*seq[i-2]))\n        seq.append(next_value)\n    return float(seq[n])\n\nfor n in [3, 4, 5, 6, 7, 8, 20, 30, 50, 100]:\n    print(\"{:4d} -> {}\".format(n, muller_seq(n)))\n"}
{"id": 73741, "name": "Pathological floating point problems", "source": "Translate Ruby to Python: require \"big\"\n\nar = [0.to_big_d, 2.to_big_d, -4.to_big_d]\n\n100.times { ar << 111 - 1130.to_big_d.div(ar[-1], 132) + 3000.to_big_d.div((ar[-1] * ar[-2]), 132) }\n\n[3, 4, 5, 6, 7, 8, 20, 30, 50, 100].each do |n|\n  puts \"%3d -> %0.16f\" % [n, ar[n]]\nend\n", "target": "from fractions import Fraction\n\ndef muller_seq(n:int) -> float:\n    seq = [Fraction(0), Fraction(2), Fraction(-4)]\n    for i in range(3, n+1):\n        next_value = (111 - 1130/seq[i-1]\n            + 3000/(seq[i-1]*seq[i-2]))\n        seq.append(next_value)\n    return float(seq[n])\n\nfor n in [3, 4, 5, 6, 7, 8, 20, 30, 50, 100]:\n    print(\"{:4d} -> {}\".format(n, muller_seq(n)))\n"}
{"id": 73877, "name": "Echo server", "source": "Translate Ruby to C#: require 'socket'\nserver = TCPServer.new(12321)\n\nwhile (connection = server.accept)\n  Thread.new(connection) do |conn|\n    port, host = conn.peeraddr[1,2]\n    client = \"\n    puts \"\n    begin\n      loop do\n        line = conn.readline\n        puts \"\n        conn.puts(line)\n      end\n    rescue EOFError\n      conn.close\n      puts \"\n    end\n  end\nend\n", "target": "using System.Net.Sockets;\nusing System.Threading;\n\nnamespace ConsoleApplication1\n{\n    class Program\n    {\n        static TcpListener listen;\n        static Thread serverthread;\n\n        static void Main(string[] args)\n        {\n            listen = new TcpListener(System.Net.IPAddress.Parse(\"127.0.0.1\"), 12321);\n            serverthread = new Thread(new ThreadStart(DoListen));\n            serverthread.Start();\n        }\n\n        private static void DoListen()\n        {\n            \n            listen.Start();\n            Console.WriteLine(\"Server: Started server\");\n\n            while (true)\n            {\n                Console.WriteLine(\"Server: Waiting...\");\n                TcpClient client = listen.AcceptTcpClient();\n                Console.WriteLine(\"Server: Waited\");\n\n                \n                Thread clientThread = new Thread(new ParameterizedThreadStart(DoClient));\n                clientThread.Start(client);\n            }\n        }\n\n        private static void DoClient(object client)\n        {\n            \n            TcpClient tClient = (TcpClient)client;\n\n            Console.WriteLine(\"Client (Thread: {0}): Connected!\", Thread.CurrentThread.ManagedThreadId);\n            do\n            {\n                if (!tClient.Connected)\n                { \n                    tClient.Close();\n                    Thread.CurrentThread.Abort();       \n                }\n\n                if (tClient.Available > 0)\n                {\n                    \n                    byte pByte = (byte)tClient.GetStream().ReadByte();\n                    Console.WriteLine(\"Client (Thread: {0}): Data {1}\", Thread.CurrentThread.ManagedThreadId, pByte);\n                    tClient.GetStream().WriteByte(pByte);\n                }\n\n                \n                Thread.Sleep(100);\n            } while (true);\n        }\n    }\n}\n"}
{"id": 73878, "name": "Echo server", "source": "Translate Ruby to Java: require 'socket'\nserver = TCPServer.new(12321)\n\nwhile (connection = server.accept)\n  Thread.new(connection) do |conn|\n    port, host = conn.peeraddr[1,2]\n    client = \"\n    puts \"\n    begin\n      loop do\n        line = conn.readline\n        puts \"\n        conn.puts(line)\n      end\n    rescue EOFError\n      conn.close\n      puts \"\n    end\n  end\nend\n", "target": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.OutputStreamWriter;\nimport java.io.PrintWriter;\nimport java.net.ServerSocket;\nimport java.net.Socket;\nimport java.nio.charset.Charset;\nimport java.nio.charset.StandardCharsets;\n\npublic class EchoServer {\n\n    public static void main(String[] args) throws IOException {\n        try (ServerSocket listener = new ServerSocket(12321)) {\n            while (true) {\n                Socket conn = listener.accept();\n                Thread clientThread = new Thread(() -> handleClient(conn));\n                clientThread.start();\n            }\n        }\n    }\n\n    private static void handleClient(Socket connArg) {\n        Charset utf8 = StandardCharsets.UTF_8;\n\n        try (Socket conn = connArg) {\n            BufferedReader in = new BufferedReader(\n                    new InputStreamReader(conn.getInputStream(), utf8));\n\n            PrintWriter out = new PrintWriter(\n                    new OutputStreamWriter(conn.getOutputStream(), utf8),\n                    true);\n\n            String line;\n            while ((line = in.readLine()) != null) {\n                out.println(line);\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}\n"}
{"id": 73879, "name": "Echo server", "source": "Translate Ruby to Python: require 'socket'\nserver = TCPServer.new(12321)\n\nwhile (connection = server.accept)\n  Thread.new(connection) do |conn|\n    port, host = conn.peeraddr[1,2]\n    client = \"\n    puts \"\n    begin\n      loop do\n        line = conn.readline\n        puts \"\n        conn.puts(line)\n      end\n    rescue EOFError\n      conn.close\n      puts \"\n    end\n  end\nend\n", "target": "import SocketServer\n\nHOST = \"localhost\"\nPORT = 12321\n\n\n\n\nclass EchoServer(SocketServer.ThreadingMixIn, SocketServer.TCPServer):\n    \n    pass\n\nclass EchoRequestHandler(SocketServer.StreamRequestHandler):\n    \n    def handle(self):\n        print \"connection from %s\" % self.client_address[0]\n        while True:\n            line = self.rfile.readline()\n            if not line: break\n            print \"%s wrote: %s\" % (self.client_address[0], line.rstrip())\n            self.wfile.write(line)\n        print \"%s disconnected\" % self.client_address[0]\n\n\n\nserver = EchoServer((HOST, PORT), EchoRequestHandler)\n\n\n\nprint \"server listening on %s:%s\" % server.server_address\nserver.serve_forever()\n"}
{"id": 74187, "name": "Sum to 100", "source": "Translate Ruby to C#: digits = (\"1\"..\"9\").to_a\n\nar = [\"+\", \"-\", \"\"].repeated_permutation(digits.size).filter_map do |op_perm|\n  str = op_perm.zip(digits).join\n  str unless str.start_with?(\"+\")\nend\nres = ar.group_by{|str| eval(str)}\n\nputs res[100] , \"\"\n\nsum, solutions = res.max_by{|k,v| v.size}\nputs \"\n\nno_solution = (1..).find{|n| res[n] == nil}\nputs \"\n\nputs res.max(10).map{|pair| pair.join(\": \")}\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\nclass Program\n{\n    static void Main(string[] args)\n    {\n        \n        var expressionsPlus = Enumerable.Range(0, (int)Math.Pow(3, 8)).AsParallel().Select(i => new Expression(i, 1));\n        \n        var expressionsMinus = Enumerable.Range(0, (int)Math.Pow(3, 8)).AsParallel().Select(i => new Expression(i, -1));\n        var expressions = expressionsPlus.Concat(expressionsMinus);\n        var results = new Dictionary<int, List<Expression>>();\n        foreach (var e in expressions)\n        {\n            if (results.Keys.Contains(e.Value))\n                results[e.Value].Add(e);\n            else\n                results[e.Value] = new List<Expression>() { e };\n        }\n        Console.WriteLine(\"Show all solutions that sum to 100\");\n        foreach (Expression e in results[100])\n            Console.WriteLine(\"  \" + e);\n        Console.WriteLine(\"Show the sum that has the maximum number of solutions (from zero to infinity)\");\n        var summary = results.Keys.Select(k => new Tuple<int, int>(k, results[k].Count));\n        var maxSols = summary.Aggregate((a, b) => a.Item2 > b.Item2 ? a : b);\n        Console.WriteLine(\"  The sum \" + maxSols.Item1 + \" has \" + maxSols.Item2 + \" solutions.\");\n        Console.WriteLine(\"Show the lowest positive sum that can't be expressed (has no solutions), using the rules for this task\");\n        var lowestPositive = Enumerable.Range(1, int.MaxValue).First(x => !results.Keys.Contains(x));\n        Console.WriteLine(\"  \" + lowestPositive);\n        Console.WriteLine(\"Show the ten highest numbers that can be expressed using the rules for this task (extra credit)\");\n        var highest = from k in results.Keys\n                      orderby k descending\n                      select k;\n        foreach (var x in highest.Take(10))\n            Console.WriteLine(\"  \" + x);\n    }\n}\npublic enum Operations { Plus, Minus, Join };\npublic class Expression\n{\n    protected Operations[] Gaps;\n    \n    \n    public int Value; \n    protected int _one;\n    \n    public Expression(int serial, int one)\n    {\n        _one = one;\n        Gaps = new Operations[8];\n        \n        int divisor = 2187; \n        int times;\n        for (int i = 0; i < 8; i++)\n        {\n            times = Math.DivRem(serial, divisor, out serial);\n            divisor /= 3;\n            if (times == 0)\n                Gaps[i] = Operations.Join;\n            else if (times == 1)\n                Gaps[i] = Operations.Minus;\n            else\n                Gaps[i] = Operations.Plus;\n        }\n        \n        \n        Value = Evaluate();\n    }\n    public override string ToString()\n    {\n        string ret = _one.ToString();\n        for (int i = 0; i < 8; i++)\n        {\n            switch (Gaps[i])\n            {\n                case Operations.Plus:\n                    ret += \"+\";\n                    break;\n                case Operations.Minus:\n                    ret += \"-\";\n                    break;\n            }\n            ret += (i + 2);\n        }\n        return ret;\n    }\n    private int Evaluate()\n        \n    {\n        var numbers = new int[9];\n        int nc = 0;\n        var operations = new List<Operations>();\n        int a = 1;\n        for (int i = 0; i < 8; i++)\n        {\n            if (Gaps[i] == Operations.Join)\n                a = a * 10 + (i + 2);\n            else\n            {\n                if (a > 0)\n                {\n                    if (nc == 0)\n                        a *= _one;\n                    numbers[nc++] = a;\n                    a = i + 2;\n                }\n                operations.Add(Gaps[i]);\n            }\n        }\n        if (nc == 0)\n            a *= _one;\n        numbers[nc++] = a;\n        int ni = 0;\n        int left = numbers[ni++];\n        foreach (var operation in operations)\n        {\n            int right = numbers[ni++];\n            if (operation == Operations.Plus)\n                left = left + right;\n            else\n                left = left - right;\n        }\n        return left;\n    }\n}\n"}
{"id": 74188, "name": "Sum to 100", "source": "Translate Ruby to C#: digits = (\"1\"..\"9\").to_a\n\nar = [\"+\", \"-\", \"\"].repeated_permutation(digits.size).filter_map do |op_perm|\n  str = op_perm.zip(digits).join\n  str unless str.start_with?(\"+\")\nend\nres = ar.group_by{|str| eval(str)}\n\nputs res[100] , \"\"\n\nsum, solutions = res.max_by{|k,v| v.size}\nputs \"\n\nno_solution = (1..).find{|n| res[n] == nil}\nputs \"\n\nputs res.max(10).map{|pair| pair.join(\": \")}\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\nclass Program\n{\n    static void Main(string[] args)\n    {\n        \n        var expressionsPlus = Enumerable.Range(0, (int)Math.Pow(3, 8)).AsParallel().Select(i => new Expression(i, 1));\n        \n        var expressionsMinus = Enumerable.Range(0, (int)Math.Pow(3, 8)).AsParallel().Select(i => new Expression(i, -1));\n        var expressions = expressionsPlus.Concat(expressionsMinus);\n        var results = new Dictionary<int, List<Expression>>();\n        foreach (var e in expressions)\n        {\n            if (results.Keys.Contains(e.Value))\n                results[e.Value].Add(e);\n            else\n                results[e.Value] = new List<Expression>() { e };\n        }\n        Console.WriteLine(\"Show all solutions that sum to 100\");\n        foreach (Expression e in results[100])\n            Console.WriteLine(\"  \" + e);\n        Console.WriteLine(\"Show the sum that has the maximum number of solutions (from zero to infinity)\");\n        var summary = results.Keys.Select(k => new Tuple<int, int>(k, results[k].Count));\n        var maxSols = summary.Aggregate((a, b) => a.Item2 > b.Item2 ? a : b);\n        Console.WriteLine(\"  The sum \" + maxSols.Item1 + \" has \" + maxSols.Item2 + \" solutions.\");\n        Console.WriteLine(\"Show the lowest positive sum that can't be expressed (has no solutions), using the rules for this task\");\n        var lowestPositive = Enumerable.Range(1, int.MaxValue).First(x => !results.Keys.Contains(x));\n        Console.WriteLine(\"  \" + lowestPositive);\n        Console.WriteLine(\"Show the ten highest numbers that can be expressed using the rules for this task (extra credit)\");\n        var highest = from k in results.Keys\n                      orderby k descending\n                      select k;\n        foreach (var x in highest.Take(10))\n            Console.WriteLine(\"  \" + x);\n    }\n}\npublic enum Operations { Plus, Minus, Join };\npublic class Expression\n{\n    protected Operations[] Gaps;\n    \n    \n    public int Value; \n    protected int _one;\n    \n    public Expression(int serial, int one)\n    {\n        _one = one;\n        Gaps = new Operations[8];\n        \n        int divisor = 2187; \n        int times;\n        for (int i = 0; i < 8; i++)\n        {\n            times = Math.DivRem(serial, divisor, out serial);\n            divisor /= 3;\n            if (times == 0)\n                Gaps[i] = Operations.Join;\n            else if (times == 1)\n                Gaps[i] = Operations.Minus;\n            else\n                Gaps[i] = Operations.Plus;\n        }\n        \n        \n        Value = Evaluate();\n    }\n    public override string ToString()\n    {\n        string ret = _one.ToString();\n        for (int i = 0; i < 8; i++)\n        {\n            switch (Gaps[i])\n            {\n                case Operations.Plus:\n                    ret += \"+\";\n                    break;\n                case Operations.Minus:\n                    ret += \"-\";\n                    break;\n            }\n            ret += (i + 2);\n        }\n        return ret;\n    }\n    private int Evaluate()\n        \n    {\n        var numbers = new int[9];\n        int nc = 0;\n        var operations = new List<Operations>();\n        int a = 1;\n        for (int i = 0; i < 8; i++)\n        {\n            if (Gaps[i] == Operations.Join)\n                a = a * 10 + (i + 2);\n            else\n            {\n                if (a > 0)\n                {\n                    if (nc == 0)\n                        a *= _one;\n                    numbers[nc++] = a;\n                    a = i + 2;\n                }\n                operations.Add(Gaps[i]);\n            }\n        }\n        if (nc == 0)\n            a *= _one;\n        numbers[nc++] = a;\n        int ni = 0;\n        int left = numbers[ni++];\n        foreach (var operation in operations)\n        {\n            int right = numbers[ni++];\n            if (operation == Operations.Plus)\n                left = left + right;\n            else\n                left = left - right;\n        }\n        return left;\n    }\n}\n"}
{"id": 74191, "name": "Sum to 100", "source": "Translate Ruby to Java: digits = (\"1\"..\"9\").to_a\n\nar = [\"+\", \"-\", \"\"].repeated_permutation(digits.size).filter_map do |op_perm|\n  str = op_perm.zip(digits).join\n  str unless str.start_with?(\"+\")\nend\nres = ar.group_by{|str| eval(str)}\n\nputs res[100] , \"\"\n\nsum, solutions = res.max_by{|k,v| v.size}\nputs \"\n\nno_solution = (1..).find{|n| res[n] == nil}\nputs \"\n\nputs res.max(10).map{|pair| pair.join(\": \")}\n", "target": "\npackage rosettacode;\n\nimport java.io.PrintStream;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.Map;\nimport java.util.Set;\n\npublic class SumTo100 implements Runnable {\n\n    public static void main(String[] args) {\n        new SumTo100().run();\n    }\n\n    void print(int givenSum) {\n        Expression expression = new Expression();\n        for (int i = 0; i < Expression.NUMBER_OF_EXPRESSIONS; i++, expression.next()) {\n            if (expression.toInt() == givenSum) {\n                expression.print();\n            }\n        }\n    }\n\n    void comment(String commentString) {\n        System.out.println();\n        System.out.println(commentString);\n        System.out.println();\n    }\n\n    @Override\n    public void run() {\n        final Stat stat = new Stat();\n\n        comment(\"Show all solutions that sum to 100\");\n        final int givenSum = 100;\n        print(givenSum);\n\n        comment(\"Show the sum that has the maximum number of solutions\");\n        final int maxCount = Collections.max(stat.sumCount.keySet());\n        int maxSum;\n        Iterator<Integer> it = stat.sumCount.get(maxCount).iterator();\n        do {\n            maxSum = it.next();\n        } while (maxSum < 0);\n        System.out.println(maxSum + \" has \" + maxCount + \" solutions\");\n\n        comment(\"Show the lowest positive number that can't be expressed\");\n        int value = 0;\n        while (stat.countSum.containsKey(value)) {\n            value++;\n        }\n        System.out.println(value);\n\n        comment(\"Show the ten highest numbers that can be expressed\");\n        final int n = stat.countSum.keySet().size();\n        final Integer[] sums = stat.countSum.keySet().toArray(new Integer[n]);\n        Arrays.sort(sums);\n        for (int i = n - 1; i >= n - 10; i--) {\n            print(sums[i]);\n        }\n    }\n\n    private static class Expression {\n\n        private final static int NUMBER_OF_DIGITS = 9;\n        private final static byte ADD = 0;\n        private final static byte SUB = 1;\n        private final static byte JOIN = 2;\n\n        final byte[] code = new byte[NUMBER_OF_DIGITS];\n        final static int NUMBER_OF_EXPRESSIONS = 2 * 3 * 3 * 3 * 3 * 3 * 3 * 3 * 3;\n\n        Expression next() {\n            for (int i = 0; i < NUMBER_OF_DIGITS; i++) {\n                if (++code[i] > JOIN) {\n                    code[i] = ADD;\n                } else {\n                    break;\n                }\n            }\n            return this;\n        }\n\n        int toInt() {\n            int value = 0;\n            int number = 0;\n            int sign = (+1);\n            for (int digit = 1; digit <= 9; digit++) {\n                switch (code[NUMBER_OF_DIGITS - digit]) {\n                    case ADD:\n                        value += sign * number;\n                        number = digit;\n                        sign = (+1);\n                        break;\n                    case SUB:\n                        value += sign * number;\n                        number = digit;\n                        sign = (-1);\n                        break;\n                    case JOIN:\n                        number = 10 * number + digit;\n                        break;\n                }\n            }\n            return value + sign * number;\n        }\n\n        @Override\n        public String toString() {\n            StringBuilder s = new StringBuilder(2 * NUMBER_OF_DIGITS + 1);\n            for (int digit = 1; digit <= NUMBER_OF_DIGITS; digit++) {\n                switch (code[NUMBER_OF_DIGITS - digit]) {\n                    case ADD:\n                        if (digit > 1) {\n                            s.append('+');\n                        }\n                        break;\n                    case SUB:\n                        s.append('-');\n                        break;\n                }\n                s.append(digit);\n            }\n            return s.toString();\n        }\n\n        void print() {\n            print(System.out);\n        }\n\n        void print(PrintStream printStream) {\n            printStream.format(\"%9d\", this.toInt());\n            printStream.println(\" = \" + this);\n        }\n    }\n\n    private static class Stat {\n\n        final Map<Integer, Integer> countSum = new HashMap<>();\n        final Map<Integer, Set<Integer>> sumCount = new HashMap<>();\n\n        Stat() {\n            Expression expression = new Expression();\n            for (int i = 0; i < Expression.NUMBER_OF_EXPRESSIONS; i++, expression.next()) {\n                int sum = expression.toInt();\n                countSum.put(sum, countSum.getOrDefault(sum, 0) + 1);\n            }\n            for (Map.Entry<Integer, Integer> entry : countSum.entrySet()) {\n                Set<Integer> set;\n                if (sumCount.containsKey(entry.getValue())) {\n                    set = sumCount.get(entry.getValue());\n                } else {\n                    set = new HashSet<>();\n                }\n                set.add(entry.getKey());\n                sumCount.put(entry.getValue(), set);\n            }\n        }\n    }\n}\n"}
{"id": 74192, "name": "Sum to 100", "source": "Translate Ruby to Python: digits = (\"1\"..\"9\").to_a\n\nar = [\"+\", \"-\", \"\"].repeated_permutation(digits.size).filter_map do |op_perm|\n  str = op_perm.zip(digits).join\n  str unless str.start_with?(\"+\")\nend\nres = ar.group_by{|str| eval(str)}\n\nputs res[100] , \"\"\n\nsum, solutions = res.max_by{|k,v| v.size}\nputs \"\n\nno_solution = (1..).find{|n| res[n] == nil}\nputs \"\n\nputs res.max(10).map{|pair| pair.join(\": \")}\n", "target": "from itertools import product, islice\n\n\ndef expr(p):\n    return \"{}1{}2{}3{}4{}5{}6{}7{}8{}9\".format(*p)\n\n\ndef gen_expr():\n    op = ['+', '-', '']\n    return [expr(p) for p in product(op, repeat=9) if p[0] != '+']\n\n\ndef all_exprs():\n    values = {}\n    for expr in gen_expr():\n        val = eval(expr)\n        if val not in values:\n            values[val] = 1\n        else:\n            values[val] += 1\n    return values\n\n\ndef sum_to(val):\n    for s in filter(lambda x: x[0] == val, map(lambda x: (eval(x), x), gen_expr())):\n        print(s)\n\n\ndef max_solve():\n    print(\"Sum {} has the maximum number of solutions: {}\".\n          format(*max(all_exprs().items(), key=lambda x: x[1])))\n\n\ndef min_solve():\n    values = all_exprs()\n    for i in range(123456789):\n        if i not in values:\n            print(\"Lowest positive sum that can't be expressed: {}\".format(i))\n            return\n\n\ndef highest_sums(n=10):\n    sums = map(lambda x: x[0],\n               islice(sorted(all_exprs().items(), key=lambda x: x[0], reverse=True), n))\n    print(\"Highest Sums: {}\".format(list(sums)))\n\n\nsum_to(100)\nmax_solve()\nmin_solve()\nhighest_sums()\n"}
{"id": 74193, "name": "Sum to 100", "source": "Translate Ruby to Python: digits = (\"1\"..\"9\").to_a\n\nar = [\"+\", \"-\", \"\"].repeated_permutation(digits.size).filter_map do |op_perm|\n  str = op_perm.zip(digits).join\n  str unless str.start_with?(\"+\")\nend\nres = ar.group_by{|str| eval(str)}\n\nputs res[100] , \"\"\n\nsum, solutions = res.max_by{|k,v| v.size}\nputs \"\n\nno_solution = (1..).find{|n| res[n] == nil}\nputs \"\n\nputs res.max(10).map{|pair| pair.join(\": \")}\n", "target": "from itertools import product, islice\n\n\ndef expr(p):\n    return \"{}1{}2{}3{}4{}5{}6{}7{}8{}9\".format(*p)\n\n\ndef gen_expr():\n    op = ['+', '-', '']\n    return [expr(p) for p in product(op, repeat=9) if p[0] != '+']\n\n\ndef all_exprs():\n    values = {}\n    for expr in gen_expr():\n        val = eval(expr)\n        if val not in values:\n            values[val] = 1\n        else:\n            values[val] += 1\n    return values\n\n\ndef sum_to(val):\n    for s in filter(lambda x: x[0] == val, map(lambda x: (eval(x), x), gen_expr())):\n        print(s)\n\n\ndef max_solve():\n    print(\"Sum {} has the maximum number of solutions: {}\".\n          format(*max(all_exprs().items(), key=lambda x: x[1])))\n\n\ndef min_solve():\n    values = all_exprs()\n    for i in range(123456789):\n        if i not in values:\n            print(\"Lowest positive sum that can't be expressed: {}\".format(i))\n            return\n\n\ndef highest_sums(n=10):\n    sums = map(lambda x: x[0],\n               islice(sorted(all_exprs().items(), key=lambda x: x[0], reverse=True), n))\n    print(\"Highest Sums: {}\".format(list(sums)))\n\n\nsum_to(100)\nmax_solve()\nmin_solve()\nhighest_sums()\n"}
{"id": 74451, "name": "Array concatenation", "source": "Translate Ruby to C#: arr1 = [1, 2, 3]\narr2 = [\"foo\", \"bar\", \"baz\"]\narr1 + arr2  \n", "target": "using System;\n\nnamespace RosettaCode\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            int[] a = { 1, 2, 3 };\n            int[] b = { 4, 5, 6 };\n\n            int[] c = new int[a.Length + b.Length];\n            a.CopyTo(c, 0);\n            b.CopyTo(c, a.Length);\n\n            foreach(int n in c)\n            {\n                Console.WriteLine(n.ToString());\n            }\n        }\n    }\n}\n"}
{"id": 74453, "name": "Array concatenation", "source": "Translate Ruby to Java: arr1 = [1, 2, 3]\narr2 = [\"foo\", \"bar\", \"baz\"]\narr1 + arr2  \n", "target": "String[] fruits = [\"apples\", \"oranges\"];\nString[] grains = [\"wheat\", \"corn\"];\nString[] all    = fruits + grains;\n"}
{"id": 74454, "name": "Array concatenation", "source": "Translate Ruby to Python: arr1 = [1, 2, 3]\narr2 = [\"foo\", \"bar\", \"baz\"]\narr1 + arr2  \n", "target": "arr1 = [1, 2, 3]\narr2 = [4, 5, 6]\narr3 = [7, 8, 9]\narr4 = arr1 + arr2\nassert arr4 == [1, 2, 3, 4, 5, 6]\narr4.extend(arr3)\nassert arr4 == [1, 2, 3, 4, 5, 6, 7, 8, 9]\n"}
{"id": 74718, "name": "Abundant, deficient and perfect number classifications", "source": "Translate Ruby to C#: res = (1 .. 20_000).map{|n| n.proper_divisors.sum <=> n }.tally\nputs \"Deficient: \n", "target": "using System;\nusing System.Linq;\n\npublic class Program\n{\n    public static void Main()\n    {\n        int abundant, deficient, perfect;\n        var sw = System.Diagnostics.Stopwatch.StartNew();\n        ClassifyNumbers.UsingSieve(20000, out abundant, out deficient, out perfect); sw.Stop();\n        Console.WriteLine($\"Abundant: {abundant}, Deficient: {deficient}, Perfect: {perfect}  {sw.Elapsed.TotalMilliseconds} ms\");\n        sw.Restart();\n        ClassifyNumbers.UsingOptiDivision(20000, out abundant, out deficient, out perfect);\n        Console.WriteLine($\"Abundant: {abundant}, Deficient: {deficient}, Perfect: {perfect}  {sw.Elapsed.TotalMilliseconds} ms\");\n        sw.Restart();\n        ClassifyNumbers.UsingDivision(20000, out abundant, out deficient, out perfect);\n        Console.WriteLine($\"Abundant: {abundant}, Deficient: {deficient}, Perfect: {perfect}  {sw.Elapsed.TotalMilliseconds} ms\");\n    }\n}\n\npublic static class ClassifyNumbers\n{\n    \n    public static void UsingSieve(int bound, out int abundant, out int deficient, out int perfect) {\n        abundant = perfect = 0;\n        \n        int[] sum = new int[bound + 1];\n        for (int divisor = 1; divisor <= bound >> 1; divisor++)\n            for (int i = divisor << 1; i <= bound; i += divisor)\n                sum[i] += divisor;\n        for (int i = 1; i <= bound; i++) {\n            if (sum[i] > i) abundant++;\n            else if (sum[i] == i) perfect++;\n        }\n        deficient = bound - abundant - perfect;\n    }\n\n    \n    public static void UsingOptiDivision(int bound, out int abundant, out int deficient, out int perfect) {\n        abundant = perfect = 0; int sum = 0;\n        for (int i = 2, d, r = 1; i <= bound; i++) {\n            if ((d = r * r - i) < 0) r++;\n            for (int x = 2; x < r; x++) if (i % x == 0) sum += x + i / x;\n            if (d == 0) sum += r;\n            switch (sum.CompareTo(i)) { case 0: perfect++; break; case 1: abundant++; break; }\n            sum = 1;\n        }\n        deficient = bound - abundant - perfect;\n    }\n\n    \n    public static void UsingDivision(int bound, out int abundant, out int deficient, out int perfect) {\n        abundant = perfect = 0;\n        for (int i = 2; i <= bound; i++) {\n            int sum = Enumerable.Range(1, (i + 1) / 2)\n                .Where(div => i % div == 0).Sum();\n            switch (sum.CompareTo(i)) {\n                case 0: perfect++; break;\n                case 1: abundant++; break;\n            }\n        }\n        deficient = bound - abundant - perfect;\n    }\n}\n"}
{"id": 74720, "name": "Abundant, deficient and perfect number classifications", "source": "Translate Ruby to Java: res = (1 .. 20_000).map{|n| n.proper_divisors.sum <=> n }.tally\nputs \"Deficient: \n", "target": "import java.util.stream.LongStream;\n\npublic class NumberClassifications {\n \n    public static void main(String[] args) {\n        int deficient = 0;\n        int perfect = 0;\n        int abundant = 0;\n \n        for (long i = 1; i <= 20_000; i++) {\n            long sum = properDivsSum(i);\n            if (sum < i)\n                deficient++;\n            else if (sum == i)\n                perfect++;\n            else\n                abundant++;\n        }\n        System.out.println(\"Deficient: \" + deficient);\n        System.out.println(\"Perfect: \" + perfect);\n        System.out.println(\"Abundant: \" + abundant);\n    }\n \n    public static long properDivsSum(long n) {\n        return LongStream.rangeClosed(1, (n + 1) / 2).filter(i -> n != i && n % i == 0).sum();\n    }\n}\n"}
{"id": 74721, "name": "Abundant, deficient and perfect number classifications", "source": "Translate Ruby to Python: res = (1 .. 20_000).map{|n| n.proper_divisors.sum <=> n }.tally\nputs \"Deficient: \n", "target": ">>> from proper_divisors import proper_divs\n>>> from collections import Counter\n>>> \n>>> rangemax = 20000\n>>> \n>>> def pdsum(n):\n...     return sum(proper_divs(n))\n... \n>>> def classify(n, p):\n...     return 'perfect' if n == p else 'abundant' if p > n else 'deficient'\n... \n>>> classes = Counter(classify(n, pdsum(n)) for n in range(1, 1 + rangemax))\n>>> classes.most_common()\n[('deficient', 15043), ('abundant', 4953), ('perfect', 4)]\n>>>\n"}
{"id": 74882, "name": "Leonardo numbers", "source": "Translate Ruby to C#: def leonardo(l_zero, l_one, add, amount)\n    terms = [l_zero, l_one]\n    while terms.size < amount\n        new = terms[-1] + terms[-2]\n        new += add\n        terms << new\n    end\n    terms\nend\n\nputs \"First 25 Leonardo numbers: \\n\nputs \"Leonardo numbers with fibonacci parameters:\\n\n", "target": "using System;\nusing System.Linq;\n\npublic class Program\n{\n    public static void Main() {\n        Console.WriteLine(string.Join(\" \", Leonardo().Take(25)));\n        Console.WriteLine(string.Join(\" \", Leonardo(L0: 0, L1: 1, add: 0).Take(25)));\n    }\n\n    public static IEnumerable<int> Leonardo(int L0 = 1, int L1 = 1, int add = 1) {\n        while (true) {\n            yield return L0;\n            (L0, L1) = (L1, L0 + L1 + add);\n        }\n    }\n}\n"}
{"id": 74884, "name": "Leonardo numbers", "source": "Translate Ruby to Java: def leonardo(l_zero, l_one, add, amount)\n    terms = [l_zero, l_one]\n    while terms.size < amount\n        new = terms[-1] + terms[-2]\n        new += add\n        terms << new\n    end\n    terms\nend\n\nputs \"First 25 Leonardo numbers: \\n\nputs \"Leonardo numbers with fibonacci parameters:\\n\n", "target": "import java.util.Arrays;\nimport java.util.List;\n\n@SuppressWarnings(\"SameParameterValue\")\npublic class LeonardoNumbers {\n    private static List<Integer> leonardo(int n) {\n        return leonardo(n, 1, 1, 1);\n    }\n\n    private static List<Integer> leonardo(int n, int l0, int l1, int add) {\n        Integer[] leo = new Integer[n];\n        leo[0] = l0;\n        leo[1] = l1;\n        for (int i = 2; i < n; i++) {\n            leo[i] = leo[i - 1] + leo[i - 2] + add;\n        }\n        return Arrays.asList(leo);\n    }\n\n    public static void main(String[] args) {\n        System.out.println(\"The first 25 Leonardo numbers with L[0] = 1, L[1] = 1 and add number = 1 are:\");\n        System.out.println(leonardo(25));\n        System.out.println(\"\\nThe first 25 Leonardo numbers with L[0] = 0, L[1] = 1 and add number = 0 are:\");\n        System.out.println(leonardo(25, 0, 1, 0));\n    }\n}\n"}
{"id": 74885, "name": "Leonardo numbers", "source": "Translate Ruby to Python: def leonardo(l_zero, l_one, add, amount)\n    terms = [l_zero, l_one]\n    while terms.size < amount\n        new = terms[-1] + terms[-2]\n        new += add\n        terms << new\n    end\n    terms\nend\n\nputs \"First 25 Leonardo numbers: \\n\nputs \"Leonardo numbers with fibonacci parameters:\\n\n", "target": "def Leonardo(L_Zero, L_One, Add, Amount):\n    terms = [L_Zero,L_One]\n    while len(terms) < Amount:\n        new = terms[-1] + terms[-2]\n        new += Add\n        terms.append(new)\n    return terms\n\nout = \"\"\nprint \"First 25 Leonardo numbers:\"\nfor term in Leonardo(1,1,1,25):\n    out += str(term) + \" \"\nprint out\n\nout = \"\"\nprint \"Leonardo numbers with fibonacci parameters:\"\nfor term in Leonardo(0,1,0,25):\n    out += str(term) + \" \"\nprint out\n"}
{"id": 75091, "name": "Variadic function", "source": "Translate Ruby to C#: def print_all(*things)\n  puts things\nend\n", "target": "using System;\n\nclass Program {\n    static void Main(string[] args) {\n        PrintAll(\"test\", \"rosetta code\", 123, 5.6);\n    }\n\n    static void PrintAll(params object[] varargs) {\n        foreach (var i in varargs) {\n            Console.WriteLine(i);\n        }\n    }\n}\n"}
{"id": 75093, "name": "Variadic function", "source": "Translate Ruby to Java: def print_all(*things)\n  puts things\nend\n", "target": "module VariadicFunction\n    {\n    void show(String[] strings)\n        {\n        @Inject Console console;\n        strings.forEach(s -> console.print(s));\n        }\n\n    void run()\n        {\n        show([\"hello\", \"world\"]);\n\n        String s1 = \"not\";\n        String s2 = \"a\";\n        String s3 = \"constant\";\n        String s4 = \"literal\";\n        show([s1, s2, s3, s4]);\n        }\n    }\n"}
{"id": 75528, "name": "Write language name in 3D ASCII", "source": "Translate Ruby to C#: text = <<EOS\n\n\n\n\n\n\n\n                 \n                \nEOS\n\ndef banner3D_1(text, shift=-1)\n  txt = text.each_line.map{|line| line.gsub('\n  offset = Array.new(txt.size){|i| \" \" * shift.abs * i}\n  offset.reverse! if shift < 0\n  puts offset.zip(txt).map(&:join)\nend\nbanner3D_1(text)\n\nputs\n\ndef banner3D_2(text, shift=-2)\n  txt = text.each_line.map{|line| line.chomp + ' '}\n  offset = txt.each_index.map{|i| \" \" * shift.abs * i}\n  offset.reverse! if shift < 0\n  txt.each_with_index do |line,i|\n    line2 = offset[i] + line.gsub(' ','   ').gsub('\n    puts line2, line2.tr('/\\\\\\\\','\\\\\\\\/')\n  end\nend\nbanner3D_2(text)\n\nputs\n\ndef banner3D_3(text)\n  txt = text.each_line.map(&:rstrip)\n  offset = [*0...txt.size].reverse\n  area = Hash.new(' ')\n  box = [%w(/ / / \\\\), %w(\\\\ \\\\ \\\\ /)]\n  txt.each_with_index do |line,i|\n    line.each_char.with_index do |c,j|\n      next if c==' '\n      x = offset[i] + 2*j\n      box[0].each_with_index{|c,k| area[[x+k,i  ]] = c}\n      box[1].each_with_index{|c,k| area[[x+k,i+1]] = c}\n    end\n  end\n  (xmin, xmax), (ymin, ymax) = area.keys.transpose.map(&:minmax)\n  puts (ymin..ymax).map{|y| (xmin..xmax).map{|x| area[[x,y]]}.join}\nend\n\nbanner3D_3 <<EOS\n\n\n\n\n\n\n\n\n\n                    \n                   \nEOS\n", "target": "using System;\nusing System.Text;\n\nnamespace Language_name_in_3D_ascii\n{\n    public class F5\n    {\n        char[] z = { ' ', ' ', '_', '/', };\n        long[,] f ={\n            {87381,87381,87381,87381,87381,87381,87381,},\n            {349525,375733,742837,742837,375733,349525,349525,},\n            {742741,768853,742837,742837,768853,349525,349525,},\n            {349525,375733,742741,742741,375733,349525,349525,},\n            {349621,375733,742837,742837,375733,349525,349525,},\n            {349525,375637,768949,742741,375733,349525,349525,},\n            {351157,374101,768949,374101,374101,349525,349525,},\n            {349525,375733,742837,742837,375733,349621,351157,},\n            {742741,768853,742837,742837,742837,349525,349525,},\n            {181,85,181,181,181,85,85,},\n            {1461,1365,1461,1461,1461,1461,2901,},\n            {742741,744277,767317,744277,742837,349525,349525,},\n            {181,181,181,181,181,85,85,},\n            {1431655765,3149249365L,3042661813L,3042661813L,3042661813L,1431655765,1431655765,},\n            {349525,768853,742837,742837,742837,349525,349525,},\n            {349525,375637,742837,742837,375637,349525,349525,},\n            {349525,768853,742837,742837,768853,742741,742741,},\n            {349525,375733,742837,742837,375733,349621,349621,},\n            {349525,744373,767317,742741,742741,349525,349525,},\n            {349525,375733,767317,351157,768853,349525,349525,},\n            {374101,768949,374101,374101,351157,349525,349525,},\n            {349525,742837,742837,742837,375733,349525,349525,},\n            {5592405,11883957,11883957,5987157,5616981,5592405,5592405,},\n            {366503875925L,778827027893L,778827027893L,392374737749L,368114513237L,366503875925L,366503875925L,},\n            {349525,742837,375637,742837,742837,349525,349525,},\n            {349525,742837,742837,742837,375733,349621,375637,},\n            {349525,768949,351061,374101,768949,349525,349525,},\n            {375637,742837,768949,742837,742837,349525,349525,},\n            {768853,742837,768853,742837,768853,349525,349525,},\n            {375733,742741,742741,742741,375733,349525,349525,},\n            {192213,185709,185709,185709,192213,87381,87381,},\n            {1817525,1791317,1817429,1791317,1817525,1398101,1398101,},\n            {768949,742741,768853,742741,742741,349525,349525,},\n            {375733,742741,744373,742837,375733,349525,349525,},\n            {742837,742837,768949,742837,742837,349525,349525,},\n            {48053,23381,23381,23381,48053,21845,21845,},\n            {349621,349621,349621,742837,375637,349525,349525,},\n            {742837,744277,767317,744277,742837,349525,349525,},\n            {742741,742741,742741,742741,768949,349525,349525,},\n            {11883957,12278709,11908533,11883957,11883957,5592405,5592405,},\n            {11883957,12277173,11908533,11885493,11883957,5592405,5592405,},\n            {375637,742837,742837,742837,375637,349525,349525,},\n            {768853,742837,768853,742741,742741,349525,349525,},\n            {6010197,11885397,11909973,11885397,6010293,5592405,5592405,},\n            {768853,742837,768853,742837,742837,349525,349525,},\n            {375733,742741,375637,349621,768853,349525,349525,},\n            {12303285,5616981,5616981,5616981,5616981,5592405,5592405,},\n            {742837,742837,742837,742837,375637,349525,349525,},\n            {11883957,11883957,11883957,5987157,5616981,5592405,5592405,},\n            {3042268597L,3042268597L,3042661813L,1532713813,1437971797,1431655765,1431655765,},\n            {11883957,5987157,5616981,5987157,11883957,5592405,5592405,},\n            {11883957,5987157,5616981,5616981,5616981,5592405,5592405,},\n            {12303285,5593941,5616981,5985621,12303285,5592405,5592405,}\n            };\n\n        private F5(string s)\n        {\n            StringBuilder[] o = new StringBuilder[7];\n            for (int i = 0; i < 7; i++) o[i] = new StringBuilder();\n            for (int i = 0, l = s.Length; i < l; i++)\n            {\n                int c = s[i];\n                if (65 <= c && c <= 90) c -= 39;\n                else if (97 <= c && c <= 122) c -= 97;\n                else c = -1;\n                long[] d = new long[7];\n                Buffer.BlockCopy(f, (++c * sizeof(long) * 7), d, 0, 7 * sizeof(long));\n                for (int j = 0; j < 7; j++)\n                {\n                    StringBuilder b = new StringBuilder();\n                    long v = d[j];\n                    while (v > 0)\n                    {\n                        b.Append(z[(int)(v & 3)]);\n                        v >>= 2;\n                    }\n                    char[] charArray = b.ToString().ToCharArray();\n                    Array.Reverse(charArray);\n                    o[j].Append(new string(charArray));\n                }\n            }\n            for (int i = 0; i < 7; i++)\n            {\n                for (int j = 0; j < 7 - i; j++)\n                    System.Console.Write(' ');\n                System.Console.WriteLine(o[i]);\n            }\n        }\n\n        public static void Main(string[] args)\n        {\n            new F5(args.Length > 0 ? args[0] : \"C sharp\");\n        }\n    }\n}\n"}
{"id": 75529, "name": "Write language name in 3D ASCII", "source": "Translate Ruby to C#: text = <<EOS\n\n\n\n\n\n\n\n                 \n                \nEOS\n\ndef banner3D_1(text, shift=-1)\n  txt = text.each_line.map{|line| line.gsub('\n  offset = Array.new(txt.size){|i| \" \" * shift.abs * i}\n  offset.reverse! if shift < 0\n  puts offset.zip(txt).map(&:join)\nend\nbanner3D_1(text)\n\nputs\n\ndef banner3D_2(text, shift=-2)\n  txt = text.each_line.map{|line| line.chomp + ' '}\n  offset = txt.each_index.map{|i| \" \" * shift.abs * i}\n  offset.reverse! if shift < 0\n  txt.each_with_index do |line,i|\n    line2 = offset[i] + line.gsub(' ','   ').gsub('\n    puts line2, line2.tr('/\\\\\\\\','\\\\\\\\/')\n  end\nend\nbanner3D_2(text)\n\nputs\n\ndef banner3D_3(text)\n  txt = text.each_line.map(&:rstrip)\n  offset = [*0...txt.size].reverse\n  area = Hash.new(' ')\n  box = [%w(/ / / \\\\), %w(\\\\ \\\\ \\\\ /)]\n  txt.each_with_index do |line,i|\n    line.each_char.with_index do |c,j|\n      next if c==' '\n      x = offset[i] + 2*j\n      box[0].each_with_index{|c,k| area[[x+k,i  ]] = c}\n      box[1].each_with_index{|c,k| area[[x+k,i+1]] = c}\n    end\n  end\n  (xmin, xmax), (ymin, ymax) = area.keys.transpose.map(&:minmax)\n  puts (ymin..ymax).map{|y| (xmin..xmax).map{|x| area[[x,y]]}.join}\nend\n\nbanner3D_3 <<EOS\n\n\n\n\n\n\n\n\n\n                    \n                   \nEOS\n", "target": "using System;\nusing System.Text;\n\nnamespace Language_name_in_3D_ascii\n{\n    public class F5\n    {\n        char[] z = { ' ', ' ', '_', '/', };\n        long[,] f ={\n            {87381,87381,87381,87381,87381,87381,87381,},\n            {349525,375733,742837,742837,375733,349525,349525,},\n            {742741,768853,742837,742837,768853,349525,349525,},\n            {349525,375733,742741,742741,375733,349525,349525,},\n            {349621,375733,742837,742837,375733,349525,349525,},\n            {349525,375637,768949,742741,375733,349525,349525,},\n            {351157,374101,768949,374101,374101,349525,349525,},\n            {349525,375733,742837,742837,375733,349621,351157,},\n            {742741,768853,742837,742837,742837,349525,349525,},\n            {181,85,181,181,181,85,85,},\n            {1461,1365,1461,1461,1461,1461,2901,},\n            {742741,744277,767317,744277,742837,349525,349525,},\n            {181,181,181,181,181,85,85,},\n            {1431655765,3149249365L,3042661813L,3042661813L,3042661813L,1431655765,1431655765,},\n            {349525,768853,742837,742837,742837,349525,349525,},\n            {349525,375637,742837,742837,375637,349525,349525,},\n            {349525,768853,742837,742837,768853,742741,742741,},\n            {349525,375733,742837,742837,375733,349621,349621,},\n            {349525,744373,767317,742741,742741,349525,349525,},\n            {349525,375733,767317,351157,768853,349525,349525,},\n            {374101,768949,374101,374101,351157,349525,349525,},\n            {349525,742837,742837,742837,375733,349525,349525,},\n            {5592405,11883957,11883957,5987157,5616981,5592405,5592405,},\n            {366503875925L,778827027893L,778827027893L,392374737749L,368114513237L,366503875925L,366503875925L,},\n            {349525,742837,375637,742837,742837,349525,349525,},\n            {349525,742837,742837,742837,375733,349621,375637,},\n            {349525,768949,351061,374101,768949,349525,349525,},\n            {375637,742837,768949,742837,742837,349525,349525,},\n            {768853,742837,768853,742837,768853,349525,349525,},\n            {375733,742741,742741,742741,375733,349525,349525,},\n            {192213,185709,185709,185709,192213,87381,87381,},\n            {1817525,1791317,1817429,1791317,1817525,1398101,1398101,},\n            {768949,742741,768853,742741,742741,349525,349525,},\n            {375733,742741,744373,742837,375733,349525,349525,},\n            {742837,742837,768949,742837,742837,349525,349525,},\n            {48053,23381,23381,23381,48053,21845,21845,},\n            {349621,349621,349621,742837,375637,349525,349525,},\n            {742837,744277,767317,744277,742837,349525,349525,},\n            {742741,742741,742741,742741,768949,349525,349525,},\n            {11883957,12278709,11908533,11883957,11883957,5592405,5592405,},\n            {11883957,12277173,11908533,11885493,11883957,5592405,5592405,},\n            {375637,742837,742837,742837,375637,349525,349525,},\n            {768853,742837,768853,742741,742741,349525,349525,},\n            {6010197,11885397,11909973,11885397,6010293,5592405,5592405,},\n            {768853,742837,768853,742837,742837,349525,349525,},\n            {375733,742741,375637,349621,768853,349525,349525,},\n            {12303285,5616981,5616981,5616981,5616981,5592405,5592405,},\n            {742837,742837,742837,742837,375637,349525,349525,},\n            {11883957,11883957,11883957,5987157,5616981,5592405,5592405,},\n            {3042268597L,3042268597L,3042661813L,1532713813,1437971797,1431655765,1431655765,},\n            {11883957,5987157,5616981,5987157,11883957,5592405,5592405,},\n            {11883957,5987157,5616981,5616981,5616981,5592405,5592405,},\n            {12303285,5593941,5616981,5985621,12303285,5592405,5592405,}\n            };\n\n        private F5(string s)\n        {\n            StringBuilder[] o = new StringBuilder[7];\n            for (int i = 0; i < 7; i++) o[i] = new StringBuilder();\n            for (int i = 0, l = s.Length; i < l; i++)\n            {\n                int c = s[i];\n                if (65 <= c && c <= 90) c -= 39;\n                else if (97 <= c && c <= 122) c -= 97;\n                else c = -1;\n                long[] d = new long[7];\n                Buffer.BlockCopy(f, (++c * sizeof(long) * 7), d, 0, 7 * sizeof(long));\n                for (int j = 0; j < 7; j++)\n                {\n                    StringBuilder b = new StringBuilder();\n                    long v = d[j];\n                    while (v > 0)\n                    {\n                        b.Append(z[(int)(v & 3)]);\n                        v >>= 2;\n                    }\n                    char[] charArray = b.ToString().ToCharArray();\n                    Array.Reverse(charArray);\n                    o[j].Append(new string(charArray));\n                }\n            }\n            for (int i = 0; i < 7; i++)\n            {\n                for (int j = 0; j < 7 - i; j++)\n                    System.Console.Write(' ');\n                System.Console.WriteLine(o[i]);\n            }\n        }\n\n        public static void Main(string[] args)\n        {\n            new F5(args.Length > 0 ? args[0] : \"C sharp\");\n        }\n    }\n}\n"}
{"id": 75532, "name": "Write language name in 3D ASCII", "source": "Translate Ruby to Java: text = <<EOS\n\n\n\n\n\n\n\n                 \n                \nEOS\n\ndef banner3D_1(text, shift=-1)\n  txt = text.each_line.map{|line| line.gsub('\n  offset = Array.new(txt.size){|i| \" \" * shift.abs * i}\n  offset.reverse! if shift < 0\n  puts offset.zip(txt).map(&:join)\nend\nbanner3D_1(text)\n\nputs\n\ndef banner3D_2(text, shift=-2)\n  txt = text.each_line.map{|line| line.chomp + ' '}\n  offset = txt.each_index.map{|i| \" \" * shift.abs * i}\n  offset.reverse! if shift < 0\n  txt.each_with_index do |line,i|\n    line2 = offset[i] + line.gsub(' ','   ').gsub('\n    puts line2, line2.tr('/\\\\\\\\','\\\\\\\\/')\n  end\nend\nbanner3D_2(text)\n\nputs\n\ndef banner3D_3(text)\n  txt = text.each_line.map(&:rstrip)\n  offset = [*0...txt.size].reverse\n  area = Hash.new(' ')\n  box = [%w(/ / / \\\\), %w(\\\\ \\\\ \\\\ /)]\n  txt.each_with_index do |line,i|\n    line.each_char.with_index do |c,j|\n      next if c==' '\n      x = offset[i] + 2*j\n      box[0].each_with_index{|c,k| area[[x+k,i  ]] = c}\n      box[1].each_with_index{|c,k| area[[x+k,i+1]] = c}\n    end\n  end\n  (xmin, xmax), (ymin, ymax) = area.keys.transpose.map(&:minmax)\n  puts (ymin..ymax).map{|y| (xmin..xmax).map{|x| area[[x,y]]}.join}\nend\n\nbanner3D_3 <<EOS\n\n\n\n\n\n\n\n\n\n                    \n                   \nEOS\n", "target": "public class F5{\n    char[]z={' ',' ','_','/',};\n    long[][]f={\n        {87381,87381,87381,87381,87381,87381,87381,},\n        {349525,375733,742837,742837,375733,349525,349525,},\n        {742741,768853,742837,742837,768853,349525,349525,},\n        {349525,375733,742741,742741,375733,349525,349525,},\n        {349621,375733,742837,742837,375733,349525,349525,},\n        {349525,375637,768949,742741,375733,349525,349525,},\n        {351157,374101,768949,374101,374101,349525,349525,},\n        {349525,375733,742837,742837,375733,349621,351157,},\n        {742741,768853,742837,742837,742837,349525,349525,},\n        {181,85,181,181,181,85,85,},\n        {1461,1365,1461,1461,1461,1461,2901,},\n        {742741,744277,767317,744277,742837,349525,349525,},\n        {181,181,181,181,181,85,85,},\n        {1431655765,3149249365L,3042661813L,3042661813L,3042661813L,1431655765,1431655765,},\n        {349525,768853,742837,742837,742837,349525,349525,},\n        {349525,375637,742837,742837,375637,349525,349525,},\n        {349525,768853,742837,742837,768853,742741,742741,},\n        {349525,375733,742837,742837,375733,349621,349621,},\n        {349525,744373,767317,742741,742741,349525,349525,},\n        {349525,375733,767317,351157,768853,349525,349525,},\n        {374101,768949,374101,374101,351157,349525,349525,},\n        {349525,742837,742837,742837,375733,349525,349525,},\n        {5592405,11883957,11883957,5987157,5616981,5592405,5592405,},\n        {366503875925L,778827027893L,778827027893L,392374737749L,368114513237L,366503875925L,366503875925L,},\n        {349525,742837,375637,742837,742837,349525,349525,},\n        {349525,742837,742837,742837,375733,349621,375637,},\n        {349525,768949,351061,374101,768949,349525,349525,},\n        {375637,742837,768949,742837,742837,349525,349525,},\n        {768853,742837,768853,742837,768853,349525,349525,},\n        {375733,742741,742741,742741,375733,349525,349525,},\n        {192213,185709,185709,185709,192213,87381,87381,},\n        {1817525,1791317,1817429,1791317,1817525,1398101,1398101,},\n        {768949,742741,768853,742741,742741,349525,349525,},\n        {375733,742741,744373,742837,375733,349525,349525,},\n        {742837,742837,768949,742837,742837,349525,349525,},\n        {48053,23381,23381,23381,48053,21845,21845,},\n        {349621,349621,349621,742837,375637,349525,349525,},\n        {742837,744277,767317,744277,742837,349525,349525,},\n        {742741,742741,742741,742741,768949,349525,349525,},\n        {11883957,12278709,11908533,11883957,11883957,5592405,5592405,},\n        {11883957,12277173,11908533,11885493,11883957,5592405,5592405,},\n        {375637,742837,742837,742837,375637,349525,349525,},\n        {768853,742837,768853,742741,742741,349525,349525,},\n        {6010197,11885397,11909973,11885397,6010293,5592405,5592405,},\n        {768853,742837,768853,742837,742837,349525,349525,},\n        {375733,742741,375637,349621,768853,349525,349525,},\n        {12303285,5616981,5616981,5616981,5616981,5592405,5592405,},\n        {742837,742837,742837,742837,375637,349525,349525,},\n        {11883957,11883957,11883957,5987157,5616981,5592405,5592405,},\n        {3042268597L,3042268597L,3042661813L,1532713813,1437971797,1431655765,1431655765,},\n        {11883957,5987157,5616981,5987157,11883957,5592405,5592405,},\n        {11883957,5987157,5616981,5616981,5616981,5592405,5592405,},\n        {12303285,5593941,5616981,5985621,12303285,5592405,5592405,},};\n    public static void main(String[]a){\n        new F5(a.length>0?a[0]:\"Java\");}\n    private F5(String s){\n        StringBuilder[]o=new StringBuilder[7];\n        for(int i=0;i<7;i++)o[i]=new StringBuilder();\n        for(int i=0,l=s.length();i<l;i++){\n            int c=s.charAt(i);\n            if(65<=c&&c<=90)c-=39;\n            else if(97<=c&&c<=122)c-=97;\n            else c=-1;\n            long[]d=f[++c];\n            for(int j=0;j<7;j++){\n                StringBuilder b=new StringBuilder();\n                long v=d[j];\n                while(v>0){\n                    b.append(z[(int)(v&3)]);\n                    v>>=2;}\n                o[j].append(b.reverse().toString());}}\n        for(int i=0;i<7;i++){\n            for(int j=0;j<7-i;j++)\n                System.out.print(' ');\n            System.out.println(o[i]);}}}\n"}
{"id": 75533, "name": "Write language name in 3D ASCII", "source": "Translate Ruby to Java: text = <<EOS\n\n\n\n\n\n\n\n                 \n                \nEOS\n\ndef banner3D_1(text, shift=-1)\n  txt = text.each_line.map{|line| line.gsub('\n  offset = Array.new(txt.size){|i| \" \" * shift.abs * i}\n  offset.reverse! if shift < 0\n  puts offset.zip(txt).map(&:join)\nend\nbanner3D_1(text)\n\nputs\n\ndef banner3D_2(text, shift=-2)\n  txt = text.each_line.map{|line| line.chomp + ' '}\n  offset = txt.each_index.map{|i| \" \" * shift.abs * i}\n  offset.reverse! if shift < 0\n  txt.each_with_index do |line,i|\n    line2 = offset[i] + line.gsub(' ','   ').gsub('\n    puts line2, line2.tr('/\\\\\\\\','\\\\\\\\/')\n  end\nend\nbanner3D_2(text)\n\nputs\n\ndef banner3D_3(text)\n  txt = text.each_line.map(&:rstrip)\n  offset = [*0...txt.size].reverse\n  area = Hash.new(' ')\n  box = [%w(/ / / \\\\), %w(\\\\ \\\\ \\\\ /)]\n  txt.each_with_index do |line,i|\n    line.each_char.with_index do |c,j|\n      next if c==' '\n      x = offset[i] + 2*j\n      box[0].each_with_index{|c,k| area[[x+k,i  ]] = c}\n      box[1].each_with_index{|c,k| area[[x+k,i+1]] = c}\n    end\n  end\n  (xmin, xmax), (ymin, ymax) = area.keys.transpose.map(&:minmax)\n  puts (ymin..ymax).map{|y| (xmin..xmax).map{|x| area[[x,y]]}.join}\nend\n\nbanner3D_3 <<EOS\n\n\n\n\n\n\n\n\n\n                    \n                   \nEOS\n", "target": "public class F5{\n    char[]z={' ',' ','_','/',};\n    long[][]f={\n        {87381,87381,87381,87381,87381,87381,87381,},\n        {349525,375733,742837,742837,375733,349525,349525,},\n        {742741,768853,742837,742837,768853,349525,349525,},\n        {349525,375733,742741,742741,375733,349525,349525,},\n        {349621,375733,742837,742837,375733,349525,349525,},\n        {349525,375637,768949,742741,375733,349525,349525,},\n        {351157,374101,768949,374101,374101,349525,349525,},\n        {349525,375733,742837,742837,375733,349621,351157,},\n        {742741,768853,742837,742837,742837,349525,349525,},\n        {181,85,181,181,181,85,85,},\n        {1461,1365,1461,1461,1461,1461,2901,},\n        {742741,744277,767317,744277,742837,349525,349525,},\n        {181,181,181,181,181,85,85,},\n        {1431655765,3149249365L,3042661813L,3042661813L,3042661813L,1431655765,1431655765,},\n        {349525,768853,742837,742837,742837,349525,349525,},\n        {349525,375637,742837,742837,375637,349525,349525,},\n        {349525,768853,742837,742837,768853,742741,742741,},\n        {349525,375733,742837,742837,375733,349621,349621,},\n        {349525,744373,767317,742741,742741,349525,349525,},\n        {349525,375733,767317,351157,768853,349525,349525,},\n        {374101,768949,374101,374101,351157,349525,349525,},\n        {349525,742837,742837,742837,375733,349525,349525,},\n        {5592405,11883957,11883957,5987157,5616981,5592405,5592405,},\n        {366503875925L,778827027893L,778827027893L,392374737749L,368114513237L,366503875925L,366503875925L,},\n        {349525,742837,375637,742837,742837,349525,349525,},\n        {349525,742837,742837,742837,375733,349621,375637,},\n        {349525,768949,351061,374101,768949,349525,349525,},\n        {375637,742837,768949,742837,742837,349525,349525,},\n        {768853,742837,768853,742837,768853,349525,349525,},\n        {375733,742741,742741,742741,375733,349525,349525,},\n        {192213,185709,185709,185709,192213,87381,87381,},\n        {1817525,1791317,1817429,1791317,1817525,1398101,1398101,},\n        {768949,742741,768853,742741,742741,349525,349525,},\n        {375733,742741,744373,742837,375733,349525,349525,},\n        {742837,742837,768949,742837,742837,349525,349525,},\n        {48053,23381,23381,23381,48053,21845,21845,},\n        {349621,349621,349621,742837,375637,349525,349525,},\n        {742837,744277,767317,744277,742837,349525,349525,},\n        {742741,742741,742741,742741,768949,349525,349525,},\n        {11883957,12278709,11908533,11883957,11883957,5592405,5592405,},\n        {11883957,12277173,11908533,11885493,11883957,5592405,5592405,},\n        {375637,742837,742837,742837,375637,349525,349525,},\n        {768853,742837,768853,742741,742741,349525,349525,},\n        {6010197,11885397,11909973,11885397,6010293,5592405,5592405,},\n        {768853,742837,768853,742837,742837,349525,349525,},\n        {375733,742741,375637,349621,768853,349525,349525,},\n        {12303285,5616981,5616981,5616981,5616981,5592405,5592405,},\n        {742837,742837,742837,742837,375637,349525,349525,},\n        {11883957,11883957,11883957,5987157,5616981,5592405,5592405,},\n        {3042268597L,3042268597L,3042661813L,1532713813,1437971797,1431655765,1431655765,},\n        {11883957,5987157,5616981,5987157,11883957,5592405,5592405,},\n        {11883957,5987157,5616981,5616981,5616981,5592405,5592405,},\n        {12303285,5593941,5616981,5985621,12303285,5592405,5592405,},};\n    public static void main(String[]a){\n        new F5(a.length>0?a[0]:\"Java\");}\n    private F5(String s){\n        StringBuilder[]o=new StringBuilder[7];\n        for(int i=0;i<7;i++)o[i]=new StringBuilder();\n        for(int i=0,l=s.length();i<l;i++){\n            int c=s.charAt(i);\n            if(65<=c&&c<=90)c-=39;\n            else if(97<=c&&c<=122)c-=97;\n            else c=-1;\n            long[]d=f[++c];\n            for(int j=0;j<7;j++){\n                StringBuilder b=new StringBuilder();\n                long v=d[j];\n                while(v>0){\n                    b.append(z[(int)(v&3)]);\n                    v>>=2;}\n                o[j].append(b.reverse().toString());}}\n        for(int i=0;i<7;i++){\n            for(int j=0;j<7-i;j++)\n                System.out.print(' ');\n            System.out.println(o[i]);}}}\n"}
{"id": 75534, "name": "Write language name in 3D ASCII", "source": "Translate Ruby to Python: text = <<EOS\n\n\n\n\n\n\n\n                 \n                \nEOS\n\ndef banner3D_1(text, shift=-1)\n  txt = text.each_line.map{|line| line.gsub('\n  offset = Array.new(txt.size){|i| \" \" * shift.abs * i}\n  offset.reverse! if shift < 0\n  puts offset.zip(txt).map(&:join)\nend\nbanner3D_1(text)\n\nputs\n\ndef banner3D_2(text, shift=-2)\n  txt = text.each_line.map{|line| line.chomp + ' '}\n  offset = txt.each_index.map{|i| \" \" * shift.abs * i}\n  offset.reverse! if shift < 0\n  txt.each_with_index do |line,i|\n    line2 = offset[i] + line.gsub(' ','   ').gsub('\n    puts line2, line2.tr('/\\\\\\\\','\\\\\\\\/')\n  end\nend\nbanner3D_2(text)\n\nputs\n\ndef banner3D_3(text)\n  txt = text.each_line.map(&:rstrip)\n  offset = [*0...txt.size].reverse\n  area = Hash.new(' ')\n  box = [%w(/ / / \\\\), %w(\\\\ \\\\ \\\\ /)]\n  txt.each_with_index do |line,i|\n    line.each_char.with_index do |c,j|\n      next if c==' '\n      x = offset[i] + 2*j\n      box[0].each_with_index{|c,k| area[[x+k,i  ]] = c}\n      box[1].each_with_index{|c,k| area[[x+k,i+1]] = c}\n    end\n  end\n  (xmin, xmax), (ymin, ymax) = area.keys.transpose.map(&:minmax)\n  puts (ymin..ymax).map{|y| (xmin..xmax).map{|x| area[[x,y]]}.join}\nend\n\nbanner3D_3 <<EOS\n\n\n\n\n\n\n\n\n\n                    \n                   \nEOS\n", "target": "py = '''\\\n \n \n \n \n \n\nlines = py.replace('\n        .replace('X', '   ').replace('\\n', ' Y') \\\n        .replace('< ', '<>').split('Y')\n\nfor i, l in enumerate(lines): \n    print('  ' * (len(lines) - i) + l)\n"}
{"id": 75535, "name": "Write language name in 3D ASCII", "source": "Translate Ruby to Python: text = <<EOS\n\n\n\n\n\n\n\n                 \n                \nEOS\n\ndef banner3D_1(text, shift=-1)\n  txt = text.each_line.map{|line| line.gsub('\n  offset = Array.new(txt.size){|i| \" \" * shift.abs * i}\n  offset.reverse! if shift < 0\n  puts offset.zip(txt).map(&:join)\nend\nbanner3D_1(text)\n\nputs\n\ndef banner3D_2(text, shift=-2)\n  txt = text.each_line.map{|line| line.chomp + ' '}\n  offset = txt.each_index.map{|i| \" \" * shift.abs * i}\n  offset.reverse! if shift < 0\n  txt.each_with_index do |line,i|\n    line2 = offset[i] + line.gsub(' ','   ').gsub('\n    puts line2, line2.tr('/\\\\\\\\','\\\\\\\\/')\n  end\nend\nbanner3D_2(text)\n\nputs\n\ndef banner3D_3(text)\n  txt = text.each_line.map(&:rstrip)\n  offset = [*0...txt.size].reverse\n  area = Hash.new(' ')\n  box = [%w(/ / / \\\\), %w(\\\\ \\\\ \\\\ /)]\n  txt.each_with_index do |line,i|\n    line.each_char.with_index do |c,j|\n      next if c==' '\n      x = offset[i] + 2*j\n      box[0].each_with_index{|c,k| area[[x+k,i  ]] = c}\n      box[1].each_with_index{|c,k| area[[x+k,i+1]] = c}\n    end\n  end\n  (xmin, xmax), (ymin, ymax) = area.keys.transpose.map(&:minmax)\n  puts (ymin..ymax).map{|y| (xmin..xmax).map{|x| area[[x,y]]}.join}\nend\n\nbanner3D_3 <<EOS\n\n\n\n\n\n\n\n\n\n                    \n                   \nEOS\n", "target": "py = '''\\\n \n \n \n \n \n\nlines = py.replace('\n        .replace('X', '   ').replace('\\n', ' Y') \\\n        .replace('< ', '<>').split('Y')\n\nfor i, l in enumerate(lines): \n    print('  ' * (len(lines) - i) + l)\n"}
{"id": 75767, "name": "Exponentiation operator", "source": "Translate Ruby to C#: class Numeric\n  def pow(m)\n    raise TypeError, \"exponent must be an integer: \n    puts \"pow!!\"\n    Array.new(m, self).reduce(1, :*)\n  end\nend\n\np 5.pow(3)\np 5.5.pow(3)\np 5.pow(3.1)\n", "target": "static void Main(string[] args)\n{\n\tConsole.WriteLine(\"5^5 = \" + Expon(5, 5));\n\tConsole.WriteLine(\"5.5^5 = \" + Expon(5.5, 5));\n\tConsole.ReadLine();\n}\n\nstatic double Expon(int Val, int Pow) \n{\n\treturn Math.Pow(Val, Pow);\n}\nstatic double Expon(double Val, int Pow)\n{\n\treturn Math.Pow(Val, Pow);\n}\n"}
{"id": 75769, "name": "Exponentiation operator", "source": "Translate Ruby to Java: class Numeric\n  def pow(m)\n    raise TypeError, \"exponent must be an integer: \n    puts \"pow!!\"\n    Array.new(m, self).reduce(1, :*)\n  end\nend\n\np 5.pow(3)\np 5.5.pow(3)\np 5.pow(3.1)\n", "target": "public class Exp{\n   public static void main(String[] args){\n      System.out.println(pow(2,30));\n      System.out.println(pow(2.0,30)); \n      System.out.println(pow(2.0,-2));\n   }\n\n   public static double pow(double base, int exp){\n      if(exp < 0) return 1 / pow(base, -exp);\n      double ans = 1.0;\n      for(;exp > 0;--exp) ans *= base;\n      return ans;\n   }\n}\n"}
{"id": 75770, "name": "Exponentiation operator", "source": "Translate Ruby to Python: class Numeric\n  def pow(m)\n    raise TypeError, \"exponent must be an integer: \n    puts \"pow!!\"\n    Array.new(m, self).reduce(1, :*)\n  end\nend\n\np 5.pow(3)\np 5.5.pow(3)\np 5.pow(3.1)\n", "target": "MULTIPLY = lambda x, y: x*y\n\nclass num(float):\n    \n    \n    def __pow__(self, b):\n        return reduce(MULTIPLY, [self]*b, 1)\n\n\nprint num(2).__pow__(3)\nprint num(2) ** 3\n\n\nprint num(2.3).__pow__(8)\nprint num(2.3) ** 8\n"}
{"id": 76017, "name": "Sorting algorithms_Bubble sort", "source": "Translate Ruby to C#: class Array\n  def bubblesort1!\n    length.times do |j|\n      for i in 1...(length - j)\n        if self[i] < self[i - 1]\n          self[i], self[i - 1] = self[i - 1], self[i]\n        end\n      end\n    end\n    self\n  end\n   def bubblesort2!\n    each_index do |index|\n      (length - 1).downto( index ) do |i|\n        self[i-1], self[i] = self[i], self[i-1] if self[i-1] < self[i]\n      end\n    end\n    self\n  end\nend\nary = [3, 78, 4, 23, 6, 8, 6]\nary.bubblesort1!\np ary\n\n", "target": "using System;\nusing System.Collections.Generic;\n\nnamespace RosettaCode.BubbleSort\n{\n    public static class BubbleSortMethods\n    {\n        \n        \n        \n        public static void BubbleSort<T>(this List<T> list) where T : IComparable\n        {\n            bool madeChanges;\n            int itemCount = list.Count;\n            do\n            {\n                madeChanges = false;\n                itemCount--;\n                for (int i = 0; i < itemCount; i++)\n                {\n                    if (list[i].CompareTo(list[i + 1]) > 0)\n                    {\n                        T temp = list[i + 1];\n                        list[i + 1] = list[i];\n                        list[i] = temp;\n                        madeChanges = true;\n                    }\n                }\n            } while (madeChanges);\n        }\n    }\n\n    \n    \n    class Program\n    {\n        static void Main()\n        {\n            List<int> testList = new List<int> { 3, 7, 3, 2, 1, -4, 10, 12, 4 };\n            testList.BubbleSort();\n            foreach (var t in testList) Console.Write(t + \" \");\n        }\n    }\n}\n"}
{"id": 76019, "name": "Sorting algorithms_Bubble sort", "source": "Translate Ruby to Java: class Array\n  def bubblesort1!\n    length.times do |j|\n      for i in 1...(length - j)\n        if self[i] < self[i - 1]\n          self[i], self[i - 1] = self[i - 1], self[i]\n        end\n      end\n    end\n    self\n  end\n   def bubblesort2!\n    each_index do |index|\n      (length - 1).downto( index ) do |i|\n        self[i-1], self[i] = self[i], self[i-1] if self[i-1] < self[i]\n      end\n    end\n    self\n  end\nend\nary = [3, 78, 4, 23, 6, 8, 6]\nary.bubblesort1!\np ary\n\n", "target": "public static <E extends Comparable<? super E>> void bubbleSort(E[] comparable) {\n    boolean changed = false;\n    do {\n        changed = false;\n        for (int a = 0; a < comparable.length - 1; a++) {\n            if (comparable[a].compareTo(comparable[a + 1]) > 0) {\n                E tmp = comparable[a];\n                comparable[a] = comparable[a + 1];\n                comparable[a + 1] = tmp;\n                changed = true;\n            }\n        }\n    } while (changed);\n}\n"}
{"id": 76020, "name": "Sorting algorithms_Bubble sort", "source": "Translate Ruby to Python: class Array\n  def bubblesort1!\n    length.times do |j|\n      for i in 1...(length - j)\n        if self[i] < self[i - 1]\n          self[i], self[i - 1] = self[i - 1], self[i]\n        end\n      end\n    end\n    self\n  end\n   def bubblesort2!\n    each_index do |index|\n      (length - 1).downto( index ) do |i|\n        self[i-1], self[i] = self[i], self[i-1] if self[i-1] < self[i]\n      end\n    end\n    self\n  end\nend\nary = [3, 78, 4, 23, 6, 8, 6]\nary.bubblesort1!\np ary\n\n", "target": "def bubble_sort(seq):\n    \n    changed = True\n    while changed:\n        changed = False\n        for i in range(len(seq) - 1):\n            if seq[i] > seq[i+1]:\n                seq[i], seq[i+1] = seq[i+1], seq[i]\n                changed = True\n    return seq\n\nif __name__ == \"__main__\":\n   \n\n   from random import shuffle\n\n   testset = [_ for _ in range(100)]\n   testcase = testset.copy() \n   shuffle(testcase)\n   assert testcase != testset  \n   bubble_sort(testcase)\n   assert testcase == testset  \n"}
{"id": 76480, "name": "Find the missing permutation", "source": "Translate Ruby to C#: given = %w{\n  ABCD CABD ACDB DACB BCDA ACBD ADCB CDAB DABC BCAD CADB CDBA\n  CBAD ABDC ADBC BDCA DCBA BACD BADC BDAC CBDA DBCA DCAB\n}\n \nall = given[0].chars.permutation.collect(&:join)\n \nputs \"missing: \n", "target": "using System;\nusing System.Collections.Generic;\n\nnamespace MissingPermutation\n{\n    class Program\n    {\n        static void Main()\n        {\n            string[] given = new string[] { \"ABCD\", \"CABD\", \"ACDB\", \"DACB\", \n                                            \"BCDA\", \"ACBD\", \"ADCB\", \"CDAB\", \n                                            \"DABC\", \"BCAD\", \"CADB\", \"CDBA\", \n                                            \"CBAD\", \"ABDC\", \"ADBC\", \"BDCA\", \n                                            \"DCBA\", \"BACD\", \"BADC\", \"BDAC\", \n                                            \"CBDA\", \"DBCA\", \"DCAB\" };\n            \n            List<string> result = new List<string>();\n            permuteString(ref result, \"\", \"ABCD\");\n            \n            foreach (string a in result)            \n                if (Array.IndexOf(given, a) == -1)\n                    Console.WriteLine(a + \" is a missing Permutation\");\n        }\n\n        public static void permuteString(ref List<string> result, string beginningString, string endingString)\n        {\n            if (endingString.Length <= 1)\n            {                 \n                result.Add(beginningString + endingString);\n            }\n            else\n            {\n                for (int i = 0; i < endingString.Length; i++)\n                {                     \n                    string newString = endingString.Substring(0, i) + endingString.Substring(i + 1);\n                    permuteString(ref result, beginningString + (endingString.ToCharArray())[i], newString);                    \n                }\n            }\n        }\n    }\n}\n"}
{"id": 76481, "name": "Find the missing permutation", "source": "Translate Ruby to C#: given = %w{\n  ABCD CABD ACDB DACB BCDA ACBD ADCB CDAB DABC BCAD CADB CDBA\n  CBAD ABDC ADBC BDCA DCBA BACD BADC BDAC CBDA DBCA DCAB\n}\n \nall = given[0].chars.permutation.collect(&:join)\n \nputs \"missing: \n", "target": "using System;\nusing System.Collections.Generic;\n\nnamespace MissingPermutation\n{\n    class Program\n    {\n        static void Main()\n        {\n            string[] given = new string[] { \"ABCD\", \"CABD\", \"ACDB\", \"DACB\", \n                                            \"BCDA\", \"ACBD\", \"ADCB\", \"CDAB\", \n                                            \"DABC\", \"BCAD\", \"CADB\", \"CDBA\", \n                                            \"CBAD\", \"ABDC\", \"ADBC\", \"BDCA\", \n                                            \"DCBA\", \"BACD\", \"BADC\", \"BDAC\", \n                                            \"CBDA\", \"DBCA\", \"DCAB\" };\n            \n            List<string> result = new List<string>();\n            permuteString(ref result, \"\", \"ABCD\");\n            \n            foreach (string a in result)            \n                if (Array.IndexOf(given, a) == -1)\n                    Console.WriteLine(a + \" is a missing Permutation\");\n        }\n\n        public static void permuteString(ref List<string> result, string beginningString, string endingString)\n        {\n            if (endingString.Length <= 1)\n            {                 \n                result.Add(beginningString + endingString);\n            }\n            else\n            {\n                for (int i = 0; i < endingString.Length; i++)\n                {                     \n                    string newString = endingString.Substring(0, i) + endingString.Substring(i + 1);\n                    permuteString(ref result, beginningString + (endingString.ToCharArray())[i], newString);                    \n                }\n            }\n        }\n    }\n}\n"}
{"id": 76484, "name": "Find the missing permutation", "source": "Translate Ruby to Java: given = %w{\n  ABCD CABD ACDB DACB BCDA ACBD ADCB CDAB DABC BCAD CADB CDBA\n  CBAD ABDC ADBC BDCA DCBA BACD BADC BDAC CBDA DBCA DCAB\n}\n \nall = given[0].chars.permutation.collect(&:join)\n \nputs \"missing: \n", "target": "import java.util.ArrayList;\n\nimport com.google.common.base.Joiner;\nimport com.google.common.collect.ImmutableSet;\nimport com.google.common.collect.Lists;\n\npublic class FindMissingPermutation {\n\tpublic static void main(String[] args) {\n\t\tJoiner joiner = Joiner.on(\"\").skipNulls();\n\t\tImmutableSet<String> s = ImmutableSet.of(\"ABCD\", \"CABD\", \"ACDB\",\n\t\t\t\t\"DACB\", \"BCDA\", \"ACBD\", \"ADCB\", \"CDAB\", \"DABC\", \"BCAD\", \"CADB\",\n\t\t\t\t\"CDBA\", \"CBAD\", \"ABDC\", \"ADBC\", \"BDCA\", \"DCBA\", \"BACD\", \"BADC\",\n\t\t\t\t\"BDAC\", \"CBDA\", \"DBCA\", \"DCAB\");\n\n\t\tfor (ArrayList<Character> cs : Utils.Permutations(Lists.newArrayList(\n\t\t\t\t'A', 'B', 'C', 'D')))\n\t\t\tif (!s.contains(joiner.join(cs)))\n\t\t\t\tSystem.out.println(joiner.join(cs));\n\t}\n}\n"}
{"id": 76485, "name": "Find the missing permutation", "source": "Translate Ruby to Java: given = %w{\n  ABCD CABD ACDB DACB BCDA ACBD ADCB CDAB DABC BCAD CADB CDBA\n  CBAD ABDC ADBC BDCA DCBA BACD BADC BDAC CBDA DBCA DCAB\n}\n \nall = given[0].chars.permutation.collect(&:join)\n \nputs \"missing: \n", "target": "import java.util.ArrayList;\n\nimport com.google.common.base.Joiner;\nimport com.google.common.collect.ImmutableSet;\nimport com.google.common.collect.Lists;\n\npublic class FindMissingPermutation {\n\tpublic static void main(String[] args) {\n\t\tJoiner joiner = Joiner.on(\"\").skipNulls();\n\t\tImmutableSet<String> s = ImmutableSet.of(\"ABCD\", \"CABD\", \"ACDB\",\n\t\t\t\t\"DACB\", \"BCDA\", \"ACBD\", \"ADCB\", \"CDAB\", \"DABC\", \"BCAD\", \"CADB\",\n\t\t\t\t\"CDBA\", \"CBAD\", \"ABDC\", \"ADBC\", \"BDCA\", \"DCBA\", \"BACD\", \"BADC\",\n\t\t\t\t\"BDAC\", \"CBDA\", \"DBCA\", \"DCAB\");\n\n\t\tfor (ArrayList<Character> cs : Utils.Permutations(Lists.newArrayList(\n\t\t\t\t'A', 'B', 'C', 'D')))\n\t\t\tif (!s.contains(joiner.join(cs)))\n\t\t\t\tSystem.out.println(joiner.join(cs));\n\t}\n}\n"}
{"id": 76486, "name": "Find the missing permutation", "source": "Translate Ruby to Python: given = %w{\n  ABCD CABD ACDB DACB BCDA ACBD ADCB CDAB DABC BCAD CADB CDBA\n  CBAD ABDC ADBC BDCA DCBA BACD BADC BDAC CBDA DBCA DCAB\n}\n \nall = given[0].chars.permutation.collect(&:join)\n \nputs \"missing: \n", "target": "from itertools import permutations\n\ngiven = .split()\n\nallPerms = [''.join(x) for x in permutations(given[0])]\n\nmissing = list(set(allPerms) - set(given)) \n"}
{"id": 76487, "name": "Find the missing permutation", "source": "Translate Ruby to Python: given = %w{\n  ABCD CABD ACDB DACB BCDA ACBD ADCB CDAB DABC BCAD CADB CDBA\n  CBAD ABDC ADBC BDCA DCBA BACD BADC BDAC CBDA DBCA DCAB\n}\n \nall = given[0].chars.permutation.collect(&:join)\n \nputs \"missing: \n", "target": "from itertools import permutations\n\ngiven = .split()\n\nallPerms = [''.join(x) for x in permutations(given[0])]\n\nmissing = list(set(allPerms) - set(given)) \n"}
{"id": 76861, "name": "Approximate equality", "source": "Translate Ruby to C#: require \"bigdecimal\"\n\ntestvalues = [[100000000000000.01,           100000000000000.011],\n              [100.01,                       100.011],\n              [10000000000000.001 / 10000.0, 1000000000.0000001000],\n              [0.001,                        0.0010000001],\n              [0.000000000000000000000101,   0.0],\n              [(2**0.5) * (2**0.5),            2.0],\n              [-(2**0.5) * (2**0.5),          -2.0],\n              [BigDecimal(\"3.14159265358979323846\"),       3.14159265358979324],\n              [Float::NAN, Float::NAN,],\n              [Float::INFINITY, Float::INFINITY],\n               ]\n\nclass  Numeric\n  def close_to?(num, tol = Float::EPSILON)\n    return true  if self == num\n    return false if (self.to_f.nan? or num.to_f.nan?)        \n    return false if [self, num].count( Float::INFINITY) == 1 \n    return false if [self, num].count(-Float::INFINITY) == 1\n    (self-num).abs <= tol * ([self.abs, num.abs].max)\n  end\nend\n\ntestvalues.each do |a,b|\n  puts \"\nend\n", "target": "using System;\n\npublic static class Program\n{\n    public static void Main() {\n        Test(100000000000000.01, 100000000000000.011);\n        Test(100.01, 100.011);\n        Test(10000000000000.001 / 10000.0, 1000000000.0000001000);\n        Test(0.001, 0.0010000001);\n        Test(0.000000000000000000000101, 0.0);\n        Test(Math.Sqrt(2) * Math.Sqrt(2), 2.0);\n        Test(-Math.Sqrt(2) * Math.Sqrt(2), -2.0);\n        Test(3.14159265358979323846, 3.14159265358979324);\n\n        void Test(double a, double b) {\n            const double epsilon = 1e-18;\n            WriteLine($\"{a}, {b} => {a.ApproxEquals(b, epsilon)}\");\n        }\n    }\n\n    public static bool ApproxEquals(this double value, double other, double epsilon) => Math.Abs(value - other) < epsilon;\n}\n"}
{"id": 76862, "name": "Approximate equality", "source": "Translate Ruby to C#: require \"bigdecimal\"\n\ntestvalues = [[100000000000000.01,           100000000000000.011],\n              [100.01,                       100.011],\n              [10000000000000.001 / 10000.0, 1000000000.0000001000],\n              [0.001,                        0.0010000001],\n              [0.000000000000000000000101,   0.0],\n              [(2**0.5) * (2**0.5),            2.0],\n              [-(2**0.5) * (2**0.5),          -2.0],\n              [BigDecimal(\"3.14159265358979323846\"),       3.14159265358979324],\n              [Float::NAN, Float::NAN,],\n              [Float::INFINITY, Float::INFINITY],\n               ]\n\nclass  Numeric\n  def close_to?(num, tol = Float::EPSILON)\n    return true  if self == num\n    return false if (self.to_f.nan? or num.to_f.nan?)        \n    return false if [self, num].count( Float::INFINITY) == 1 \n    return false if [self, num].count(-Float::INFINITY) == 1\n    (self-num).abs <= tol * ([self.abs, num.abs].max)\n  end\nend\n\ntestvalues.each do |a,b|\n  puts \"\nend\n", "target": "using System;\n\npublic static class Program\n{\n    public static void Main() {\n        Test(100000000000000.01, 100000000000000.011);\n        Test(100.01, 100.011);\n        Test(10000000000000.001 / 10000.0, 1000000000.0000001000);\n        Test(0.001, 0.0010000001);\n        Test(0.000000000000000000000101, 0.0);\n        Test(Math.Sqrt(2) * Math.Sqrt(2), 2.0);\n        Test(-Math.Sqrt(2) * Math.Sqrt(2), -2.0);\n        Test(3.14159265358979323846, 3.14159265358979324);\n\n        void Test(double a, double b) {\n            const double epsilon = 1e-18;\n            WriteLine($\"{a}, {b} => {a.ApproxEquals(b, epsilon)}\");\n        }\n    }\n\n    public static bool ApproxEquals(this double value, double other, double epsilon) => Math.Abs(value - other) < epsilon;\n}\n"}
{"id": 76865, "name": "Approximate equality", "source": "Translate Ruby to Java: require \"bigdecimal\"\n\ntestvalues = [[100000000000000.01,           100000000000000.011],\n              [100.01,                       100.011],\n              [10000000000000.001 / 10000.0, 1000000000.0000001000],\n              [0.001,                        0.0010000001],\n              [0.000000000000000000000101,   0.0],\n              [(2**0.5) * (2**0.5),            2.0],\n              [-(2**0.5) * (2**0.5),          -2.0],\n              [BigDecimal(\"3.14159265358979323846\"),       3.14159265358979324],\n              [Float::NAN, Float::NAN,],\n              [Float::INFINITY, Float::INFINITY],\n               ]\n\nclass  Numeric\n  def close_to?(num, tol = Float::EPSILON)\n    return true  if self == num\n    return false if (self.to_f.nan? or num.to_f.nan?)        \n    return false if [self, num].count( Float::INFINITY) == 1 \n    return false if [self, num].count(-Float::INFINITY) == 1\n    (self-num).abs <= tol * ([self.abs, num.abs].max)\n  end\nend\n\ntestvalues.each do |a,b|\n  puts \"\nend\n", "target": "public class Approximate {\n    private static boolean approxEquals(double value, double other, double epsilon) {\n        return Math.abs(value - other) < epsilon;\n    }\n\n    private static void test(double a, double b) {\n        double epsilon = 1e-18;\n        System.out.printf(\"%f, %f => %s\\n\", a, b, approxEquals(a, b, epsilon));\n    }\n\n    public static void main(String[] args) {\n        test(100000000000000.01, 100000000000000.011);\n        test(100.01, 100.011);\n        test(10000000000000.001 / 10000.0, 1000000000.0000001000);\n        test(0.001, 0.0010000001);\n        test(0.000000000000000000000101, 0.0);\n        test(Math.sqrt(2.0) * Math.sqrt(2.0), 2.0);\n        test(-Math.sqrt(2.0) * Math.sqrt(2.0), -2.0);\n        test(3.14159265358979323846, 3.14159265358979324);\n    }\n}\n"}
{"id": 76866, "name": "Approximate equality", "source": "Translate Ruby to Java: require \"bigdecimal\"\n\ntestvalues = [[100000000000000.01,           100000000000000.011],\n              [100.01,                       100.011],\n              [10000000000000.001 / 10000.0, 1000000000.0000001000],\n              [0.001,                        0.0010000001],\n              [0.000000000000000000000101,   0.0],\n              [(2**0.5) * (2**0.5),            2.0],\n              [-(2**0.5) * (2**0.5),          -2.0],\n              [BigDecimal(\"3.14159265358979323846\"),       3.14159265358979324],\n              [Float::NAN, Float::NAN,],\n              [Float::INFINITY, Float::INFINITY],\n               ]\n\nclass  Numeric\n  def close_to?(num, tol = Float::EPSILON)\n    return true  if self == num\n    return false if (self.to_f.nan? or num.to_f.nan?)        \n    return false if [self, num].count( Float::INFINITY) == 1 \n    return false if [self, num].count(-Float::INFINITY) == 1\n    (self-num).abs <= tol * ([self.abs, num.abs].max)\n  end\nend\n\ntestvalues.each do |a,b|\n  puts \"\nend\n", "target": "public class Approximate {\n    private static boolean approxEquals(double value, double other, double epsilon) {\n        return Math.abs(value - other) < epsilon;\n    }\n\n    private static void test(double a, double b) {\n        double epsilon = 1e-18;\n        System.out.printf(\"%f, %f => %s\\n\", a, b, approxEquals(a, b, epsilon));\n    }\n\n    public static void main(String[] args) {\n        test(100000000000000.01, 100000000000000.011);\n        test(100.01, 100.011);\n        test(10000000000000.001 / 10000.0, 1000000000.0000001000);\n        test(0.001, 0.0010000001);\n        test(0.000000000000000000000101, 0.0);\n        test(Math.sqrt(2.0) * Math.sqrt(2.0), 2.0);\n        test(-Math.sqrt(2.0) * Math.sqrt(2.0), -2.0);\n        test(3.14159265358979323846, 3.14159265358979324);\n    }\n}\n"}
{"id": 76867, "name": "Approximate equality", "source": "Translate Ruby to Python: require \"bigdecimal\"\n\ntestvalues = [[100000000000000.01,           100000000000000.011],\n              [100.01,                       100.011],\n              [10000000000000.001 / 10000.0, 1000000000.0000001000],\n              [0.001,                        0.0010000001],\n              [0.000000000000000000000101,   0.0],\n              [(2**0.5) * (2**0.5),            2.0],\n              [-(2**0.5) * (2**0.5),          -2.0],\n              [BigDecimal(\"3.14159265358979323846\"),       3.14159265358979324],\n              [Float::NAN, Float::NAN,],\n              [Float::INFINITY, Float::INFINITY],\n               ]\n\nclass  Numeric\n  def close_to?(num, tol = Float::EPSILON)\n    return true  if self == num\n    return false if (self.to_f.nan? or num.to_f.nan?)        \n    return false if [self, num].count( Float::INFINITY) == 1 \n    return false if [self, num].count(-Float::INFINITY) == 1\n    (self-num).abs <= tol * ([self.abs, num.abs].max)\n  end\nend\n\ntestvalues.each do |a,b|\n  puts \"\nend\n", "target": "from numpy import sqrt\nfrom math import isclose\n\ntestvalues = [[100000000000000.01,           100000000000000.011],\n              [100.01,                       100.011],\n              [10000000000000.001 / 10000.0, 1000000000.0000001000],\n              [0.001,                        0.0010000001],\n              [0.000000000000000000000101,   0.0],\n              [sqrt(2) * sqrt(2),            2.0],\n              [-sqrt(2) * sqrt(2),          -2.0],\n              [3.14159265358979323846,       3.14159265358979324]]\n\nfor (x, y) in testvalues:\n    maybenot = \"is\" if isclose(x, y) else \"is NOT\"\n    print(x, maybenot, \"approximately equal to \", y)\n"}
{"id": 76868, "name": "Approximate equality", "source": "Translate Ruby to Python: require \"bigdecimal\"\n\ntestvalues = [[100000000000000.01,           100000000000000.011],\n              [100.01,                       100.011],\n              [10000000000000.001 / 10000.0, 1000000000.0000001000],\n              [0.001,                        0.0010000001],\n              [0.000000000000000000000101,   0.0],\n              [(2**0.5) * (2**0.5),            2.0],\n              [-(2**0.5) * (2**0.5),          -2.0],\n              [BigDecimal(\"3.14159265358979323846\"),       3.14159265358979324],\n              [Float::NAN, Float::NAN,],\n              [Float::INFINITY, Float::INFINITY],\n               ]\n\nclass  Numeric\n  def close_to?(num, tol = Float::EPSILON)\n    return true  if self == num\n    return false if (self.to_f.nan? or num.to_f.nan?)        \n    return false if [self, num].count( Float::INFINITY) == 1 \n    return false if [self, num].count(-Float::INFINITY) == 1\n    (self-num).abs <= tol * ([self.abs, num.abs].max)\n  end\nend\n\ntestvalues.each do |a,b|\n  puts \"\nend\n", "target": "from numpy import sqrt\nfrom math import isclose\n\ntestvalues = [[100000000000000.01,           100000000000000.011],\n              [100.01,                       100.011],\n              [10000000000000.001 / 10000.0, 1000000000.0000001000],\n              [0.001,                        0.0010000001],\n              [0.000000000000000000000101,   0.0],\n              [sqrt(2) * sqrt(2),            2.0],\n              [-sqrt(2) * sqrt(2),          -2.0],\n              [3.14159265358979323846,       3.14159265358979324]]\n\nfor (x, y) in testvalues:\n    maybenot = \"is\" if isclose(x, y) else \"is NOT\"\n    print(x, maybenot, \"approximately equal to \", y)\n"}
{"id": 77139, "name": "Greatest common divisor", "source": "Translate Ruby to C#: 40902.gcd(24140)  \n", "target": "static void Main()\n{\n\tConsole.WriteLine(\"GCD of {0} and {1} is {2}\", 1, 1, gcd(1, 1));\n\tConsole.WriteLine(\"GCD of {0} and {1} is {2}\", 1, 10, gcd(1, 10));\n\tConsole.WriteLine(\"GCD of {0} and {1} is {2}\", 10, 100, gcd(10, 100));\n\tConsole.WriteLine(\"GCD of {0} and {1} is {2}\", 5, 50, gcd(5, 50));\n\tConsole.WriteLine(\"GCD of {0} and {1} is {2}\", 8, 24, gcd(8, 24));\n\tConsole.WriteLine(\"GCD of {0} and {1} is {2}\", 36, 17, gcd(36, 17));\n\tConsole.WriteLine(\"GCD of {0} and {1} is {2}\", 36, 18, gcd(36, 18));\n\tConsole.WriteLine(\"GCD of {0} and {1} is {2}\", 36, 19, gcd(36, 19));\n\tfor (int x = 1; x < 36; x++)\n\t{\n\t\tConsole.WriteLine(\"GCD of {0} and {1} is {2}\", 36, x, gcd(36, x));\n\t}\n\tConsole.Read();\n}\n \n\n\n\nstatic int gcd(int a, int b)\n{\n    while (b != 0) b = a % (a = b);\n    return a;\n}\n"}
{"id": 77141, "name": "Greatest common divisor", "source": "Translate Ruby to Java: 40902.gcd(24140)  \n", "target": "public static long gcd(long a, long b){\n   long factor= Math.min(a, b);\n   for(long loop= factor;loop > 1;loop--){\n      if(a % loop == 0 && b % loop == 0){\n         return loop;\n      }\n   }\n   return 1;\n}\n"}
{"id": 77417, "name": "Luhn test of credit card numbers", "source": "Translate Ruby to C#: def luhn_valid?(n)  \n  d2sum = [0, 2, 4, 6, 8, 1, 3, 5, 7, 9]\n  sum, n = 0, n.to_u64\n  while n > 0; sum += n%10; n //= 10; sum += d2sum[n%10]; n //= 10 end\n  sum % 10 == 0\nend\n\ncards = [49927398716, \"49927398717\", 1234567812345678, \"1234567812345670\"]\ncards.each{ |i| puts \"\n", "target": "    public static class Luhn\n    {\n        public static bool LuhnCheck(this string cardNumber)\n        {\n            return LuhnCheck(cardNumber.Select(c => c - '0').ToArray());\n        }\n\n        private static bool LuhnCheck(this int[] digits)\n        {\n            return GetCheckValue(digits) == 0;\n        }\n\n        private static int GetCheckValue(int[] digits)\n        {\n            return digits.Select((d, i) => i % 2 == digits.Length % 2 ? ((2 * d) % 10) + d / 5 : d).Sum() % 10;\n        }\n    }\n\n    public static class TestProgram\n    {\n        public static void Main()\n        {\n            long[] testNumbers = {49927398716, 49927398717, 1234567812345678, 1234567812345670};\n            foreach (var testNumber in testNumbers)\n                Console.WriteLine(\"{0} is {1}valid\", testNumber, testNumber.ToString().LuhnCheck() ? \"\" : \"not \");\n        }\n    }\n"}
{"id": 77419, "name": "Luhn test of credit card numbers", "source": "Translate Ruby to Java: def luhn_valid?(n)  \n  d2sum = [0, 2, 4, 6, 8, 1, 3, 5, 7, 9]\n  sum, n = 0, n.to_u64\n  while n > 0; sum += n%10; n //= 10; sum += d2sum[n%10]; n //= 10 end\n  sum % 10 == 0\nend\n\ncards = [49927398716, \"49927398717\", 1234567812345678, \"1234567812345670\"]\ncards.each{ |i| puts \"\n", "target": "public class Luhn {\n    public static void main(String[] args) {\n        System.out.println(luhnTest(\"49927398716\"));\n        System.out.println(luhnTest(\"49927398717\"));\n        System.out.println(luhnTest(\"1234567812345678\"));\n        System.out.println(luhnTest(\"1234567812345670\"));\n    }\n    \n    public static boolean luhnTest(String number){\n        int s1 = 0, s2 = 0;\n        String reverse = new StringBuffer(number).reverse().toString();\n        for(int i = 0 ;i < reverse.length();i++){\n            int digit = Character.digit(reverse.charAt(i), 10);\n            if(i % 2 == 0){\n                s1 += digit;\n            }else{\n                s2 += 2 * digit;\n                if(digit >= 5){\n                    s2 -= 9;\n                }\n            }\n        }\n        return (s1 + s2) % 10 == 0;\n    }\n}\n"}
{"id": 77420, "name": "Luhn test of credit card numbers", "source": "Translate Ruby to Python: def luhn_valid?(n)  \n  d2sum = [0, 2, 4, 6, 8, 1, 3, 5, 7, 9]\n  sum, n = 0, n.to_u64\n  while n > 0; sum += n%10; n //= 10; sum += d2sum[n%10]; n //= 10 end\n  sum % 10 == 0\nend\n\ncards = [49927398716, \"49927398717\", 1234567812345678, \"1234567812345670\"]\ncards.each{ |i| puts \"\n", "target": ">>> def luhn(n):\n\tr = [int(ch) for ch in str(n)][::-1]\n\treturn (sum(r[0::2]) + sum(sum(divmod(d*2,10)) for d in r[1::2])) % 10 == 0\n\n>>> for n in (49927398716, 49927398717, 1234567812345678, 1234567812345670):\n\tprint(n, luhn(n))\n"}
{"id": 77698, "name": "Sorting algorithms_Quicksort", "source": "Translate Ruby to C#: def quick_sort(a : Array(Int32)) : Array(Int32)\n  return a if a.size <= 1\n  p = a[0]\n  lt, rt = a[1 .. -1].partition { |x| x < p }\n  return quick_sort(lt) + [p] + quick_sort(rt)\nend\n\na = [7, 6, 5, 9, 8, 4, 3, 1, 2, 0]\nputs quick_sort(a) \n", "target": "\n\n\n\n\n#define Tripartite\n\nnamespace RosettaCode {\n  using System;\n  using System.Diagnostics;\n\n  public class QuickSort<T> where T : IComparable {\n    #region Constants\n    public const UInt32 INSERTION_LIMIT_DEFAULT = 12;\n    private const Int32 SAMPLES_MAX = 19;\n    #endregion\n\n    #region Properties\n    public UInt32 InsertionLimit { get; }\n    private T[] Samples { get; }\n    private Int32 Left { get; set; }\n    private Int32 Right { get; set; }\n    private Int32 LeftMedian { get; set; }\n    private Int32 RightMedian { get; set; }\n    #endregion\n\n    #region Constructors\n    public QuickSort(UInt32 insertionLimit = INSERTION_LIMIT_DEFAULT) {\n      this.InsertionLimit = insertionLimit;\n      this.Samples = new T[SAMPLES_MAX];\n    }\n    #endregion\n\n    #region Sort Methods\n    public void Sort(T[] entries) {\n      Sort(entries, 0, entries.Length - 1);\n    }\n\n    public void Sort(T[] entries, Int32 first, Int32 last) {\n      var length = last + 1 - first;\n      while (length > 1) {\n        if (length < InsertionLimit) {\n          InsertionSort<T>.Sort(entries, first, last);\n          return;\n        }\n\n        Left = first;\n        Right = last;\n        var median = pivot(entries);\n        partition(median, entries);\n        \n\n        var leftLength = Right + 1 - first;\n        var rightLength = last + 1 - Left;\n\n        \n        \n        \n        \n        if (leftLength < rightLength) {\n          Sort(entries, first, Right);\n          first = Left;\n          length = rightLength;\n        }\n        else {\n          Sort(entries, Left, last);\n          last = Right;\n          length = leftLength;\n        }\n      }\n    }\n\n    \n    private static Int32 sampleSize(Int32 length, Int32 max = SAMPLES_MAX) {\n      var logLen = (Int32)Math.Log10(length);\n      var samples = Math.Min(2 * logLen + 1, max);\n      return Math.Min(samples, length);\n    }\n\n    \n    \n    private T pivot(T[] entries) {\n      var length = Right + 1 - Left;\n      var samples = sampleSize(length);\n      \n      for (var sample = 0; sample < samples; sample++) {\n        \n        var index = (Int64)length * sample / samples + Left;\n        Samples[sample] = entries[index];\n      }\n\n      InsertionSort<T>.Sort(Samples, 0, samples - 1);\n      return Samples[samples / 2];\n    }\n\n    private void partition(T median, T[] entries) {\n      var first = Left;\n      var last = Right;\n#if Tripartite\n      LeftMedian = first;\n      RightMedian = last;\n#endif\n      while (true) {\n        \n        \n        \n        while (median.CompareTo(entries[Left]) > 0) Left++;\n        while (median.CompareTo(entries[Right]) < 0) Right--;\n\n        \n        if (Right <= Left) break;\n\n        Swap(entries, Left, Right);\n        swapOut(median, entries);\n        Left++;\n        Right--;\n        \n      }\n\n      if (Left == Right) {\n        Left++;\n        Right--;\n      }\n      \n      swapIn(entries, first, last);\n\n      \n      \n    }\n    #endregion\n\n    #region Swap Methods\n    [Conditional(\"Tripartite\")]\n    private void swapOut(T median, T[] entries) {\n      if (median.CompareTo(entries[Left]) == 0) Swap(entries, LeftMedian++, Left);\n      if (median.CompareTo(entries[Right]) == 0) Swap(entries, Right, RightMedian--);\n    }\n\n    [Conditional(\"Tripartite\")]\n    private void swapIn(T[] entries, Int32 first, Int32 last) {\n      \n      while (first < LeftMedian) Swap(entries, first++, Right--);\n      while (RightMedian < last) Swap(entries, Left++, last--);\n    }\n\n    \n    public void Swap(T[] entries, Int32 left, Int32 right) {\n      Swap(ref entries[left], ref entries[right]);\n    }\n\n    \n    public static void Swap(ref T e1, ref T e2) {\n      var e = e1;\n      e1 = e2;\n      e2 = e;\n    }\n    #endregion\n  }\n\n  #region Insertion Sort\n  static class InsertionSort<T> where T : IComparable {\n    public static void Sort(T[] entries, Int32 first, Int32 last) {\n      for (var next = first + 1; next <= last; next++)\n        insert(entries, first, next);\n    }\n\n    \n    private static void insert(T[] entries, Int32 first, Int32 next) {\n      var entry = entries[next];\n      while (next > first && entries[next - 1].CompareTo(entry) > 0)\n        entries[next] = entries[--next];\n      entries[next] = entry;\n    }\n  }\n  #endregion\n}\n"}
{"id": 77700, "name": "Sorting algorithms_Quicksort", "source": "Translate Ruby to Java: def quick_sort(a : Array(Int32)) : Array(Int32)\n  return a if a.size <= 1\n  p = a[0]\n  lt, rt = a[1 .. -1].partition { |x| x < p }\n  return quick_sort(lt) + [p] + quick_sort(rt)\nend\n\na = [7, 6, 5, 9, 8, 4, 3, 1, 2, 0]\nputs quick_sort(a) \n", "target": "public static <E extends Comparable<? super E>> List<E> quickSort(List<E> arr) {\n    if (arr.isEmpty())\n        return arr;\n    else {\n        E pivot = arr.get(0);\n\n        List<E> less = new LinkedList<E>();\n        List<E> pivotList = new LinkedList<E>();\n        List<E> more = new LinkedList<E>();\n\n        \n        for (E i: arr) {\n            if (i.compareTo(pivot) < 0)\n                less.add(i);\n            else if (i.compareTo(pivot) > 0)\n                more.add(i);\n            else\n                pivotList.add(i);\n        }\n\n        \n        less = quickSort(less);\n        more = quickSort(more);\n\n        \n        less.addAll(pivotList);\n        less.addAll(more);\n        return less;\n    }\n}\n"}
{"id": 77701, "name": "Sorting algorithms_Quicksort", "source": "Translate Ruby to Python: def quick_sort(a : Array(Int32)) : Array(Int32)\n  return a if a.size <= 1\n  p = a[0]\n  lt, rt = a[1 .. -1].partition { |x| x < p }\n  return quick_sort(lt) + [p] + quick_sort(rt)\nend\n\na = [7, 6, 5, 9, 8, 4, 3, 1, 2, 0]\nputs quick_sort(a) \n", "target": "def quickSort(arr):\n    less = []\n    pivotList = []\n    more = []\n    if len(arr) <= 1:\n        return arr\n    else:\n        pivot = arr[0]\n        for i in arr:\n            if i < pivot:\n                less.append(i)\n            elif i > pivot:\n                more.append(i)\n            else:\n                pivotList.append(i)\n        less = quickSort(less)\n        more = quickSort(more)\n        return less + pivotList + more\n\na = [4, 65, 2, -31, 0, 99, 83, 782, 1]\na = quickSort(a)\n"}
{"id": 77918, "name": "Date manipulation", "source": "Translate Ruby to C#: time = Time.parse(\"March 7 2009 7:30pm EST\", \"%B\u00a0%-d %Y %l:%M%p\", Time::Location.load(\"EST\"))\n\ntime += 12.hours\nputs time                                          \nputs time.in(Time::Location.load(\"Europe/Berlin\")) \n", "target": "class Program\n{\n    static void Main(string[] args)\n    {\n        CultureInfo ci=CultureInfo.CreateSpecificCulture(\"en-US\");\n        string dateString = \"March 7 2009 7:30pm EST\";\n        string format = \"MMMM d yyyy h:mmtt z\";\n        DateTime myDateTime = DateTime.ParseExact(dateString.Replace(\"EST\",\"+6\"),format,ci) ;\n        DateTime newDateTime = myDateTime.AddHours(12).AddDays(1) ;\n        Console.WriteLine(newDateTime.ToString(format).Replace(\"-5\",\"EST\")); \n\n        Console.ReadLine();\n    }\n}\n"}
{"id": 77920, "name": "Date manipulation", "source": "Translate Ruby to Java: time = Time.parse(\"March 7 2009 7:30pm EST\", \"%B\u00a0%-d %Y %l:%M%p\", Time::Location.load(\"EST\"))\n\ntime += 12.hours\nputs time                                          \nputs time.in(Time::Location.load(\"Europe/Berlin\")) \n", "target": "import java.time.*;\nimport java.time.format.*;\n\nclass Main {  \n  public static void main(String args[]) { \n    String dateStr = \"March 7 2009 7:30pm EST\";\n\n    DateTimeFormatter df = new DateTimeFormatterBuilder()\n\t\t\t\t.parseCaseInsensitive()\n\t\t\t\t.appendPattern(\"MMMM d yyyy h:mma zzz\")\n\t\t\t\t.toFormatter();\n\t\t\n    ZonedDateTime after12Hours = ZonedDateTime.parse(dateStr, df).plusHours(12);\n  \n    System.out.println(\"Date: \" + dateStr);\n    System.out.println(\"+12h: \" + after12Hours.format(df));\n\n    ZonedDateTime after12HoursInCentralEuropeTime = after12Hours.withZoneSameInstant(ZoneId.of(\"CET\"));\n    System.out.println(\"+12h (in Central Europe): \" + after12HoursInCentralEuropeTime.format(df));\n  }\n}\n"}
{"id": 77921, "name": "Date manipulation", "source": "Translate Ruby to Python: time = Time.parse(\"March 7 2009 7:30pm EST\", \"%B\u00a0%-d %Y %l:%M%p\", Time::Location.load(\"EST\"))\n\ntime += 12.hours\nputs time                                          \nputs time.in(Time::Location.load(\"Europe/Berlin\")) \n", "target": "import datetime\n\ndef mt():\n\tdatime1=\"March 7 2009 7:30pm EST\"\n\tformatting = \"%B %d %Y %I:%M%p \"\n\tdatime2 = datime1[:-3]  \n\ttdelta = datetime.timedelta(hours=12)\t\t\n\ts3 = datetime.datetime.strptime(datime2, formatting)\n\tdatime2 = s3+tdelta\n\tprint datime2.strftime(\"%B %d %Y %I:%M%p %Z\") + datime1[-3:]\n\nmt()\n"}
{"id": 78202, "name": "Rot-13", "source": "Translate Ruby to C#: \ndef rot13(s)\n  s.tr('A-Za-z', 'N-ZA-Mn-za-m')\nend\n\n\nwhile line = ARGF.gets\n  print rot13(line)\nend\n", "target": "using System;\nusing System.IO;\nusing System.Linq;\nusing System.Text;\n\nclass Program\n{\n    static char Rot13(char c)\n    {\n        if ('a' <= c && c <= 'm' || 'A' <= c && c <= 'M')\n        {\n            return (char)(c + 13);\n        }\n        if ('n' <= c && c <= 'z' || 'N' <= c && c <= 'Z')\n        {\n            return (char)(c - 13);\n        }\n        return c;\n    }\n\n    static string Rot13(string s)\n    {\n        return new string(s.Select(Rot13).ToArray());\n    }\n\n\n    static void Main(string[] args)\n    {\n        foreach (var file in args.Where(file => File.Exists(file)))\n        {\n            Console.WriteLine(Rot13(File.ReadAllText(file)));\n        }\n        if (!args.Any())\n        {\n            Console.WriteLine(Rot13(Console.In.ReadToEnd()));\n        }\n    }\n}\n"}
{"id": 78204, "name": "Rot-13", "source": "Translate Ruby to Java: \ndef rot13(s)\n  s.tr('A-Za-z', 'N-ZA-Mn-za-m')\nend\n\n\nwhile line = ARGF.gets\n  print rot13(line)\nend\n", "target": "import java.io.*;\n\npublic class Rot13 {\n\n    public static void main(String[] args) throws IOException {\n        if (args.length >= 1) {\n            for (String file : args) {\n                try (InputStream in = new BufferedInputStream(new FileInputStream(file))) {\n                    rot13(in, System.out);\n                }\n            }\n        } else {\n            rot13(System.in, System.out);\n        }\n    }\n\n    private static void rot13(InputStream in, OutputStream out) throws IOException {\n        int ch;\n        while ((ch = in.read()) != -1) {\n            out.write(rot13((char) ch));\n        }\n    }\n\n    private static char rot13(char ch) {\n        if (ch >= 'A' && ch <= 'Z') {\n            return (char) (((ch - 'A') + 13) % 26 + 'A');\n        }\n        if (ch >= 'a' && ch <= 'z') {\n            return (char) (((ch - 'a') + 13) % 26 + 'a');\n        }\n        return ch;\n    }\n}\n"}
{"id": 78205, "name": "Rot-13", "source": "Translate Ruby to Python: \ndef rot13(s)\n  s.tr('A-Za-z', 'N-ZA-Mn-za-m')\nend\n\n\nwhile line = ARGF.gets\n  print rot13(line)\nend\n", "target": ">>> u'foo'.encode('rot13')\n'sbb'\n>>> 'sbb'.decode('rot13')\nu'foo'\n"}
{"id": 78726, "name": "Write float arrays to a text file", "source": "Translate Ruby to C#: \nx = [1, 2, 3, 1e11]\ny = x.collect { |xx| Math.sqrt xx }\nxprecision = 3\nyprecision = 5\n\n\nopen('sqrt.dat', 'w') do |f|\n  x.zip(y) { |xx, yy| f.printf(\"%.*g\\t%.*g\\n\", xprecision, xx, yprecision, yy) }\nend\n\n\nopen('sqrt.dat', 'r') { |f| puts f.read }\n", "target": "using System.IO;\n\nclass Program\n{\n    static void Main(string[] args)\n    {\n        var x = new double[] { 1, 2, 3, 1e11 };\n        var y = new double[] { 1, 1.4142135623730951, 1.7320508075688772, 316227.76601683791 };\n\n        int xprecision = 3;\n        int yprecision = 5;\n\n        string formatString = \"{0:G\" + xprecision + \"}\\t{1:G\" + yprecision + \"}\";\n\n        using (var outf = new StreamWriter(\"FloatArrayColumns.txt\"))\n            for (int i = 0; i < x.Length; i++)\n                outf.WriteLine(formatString, x[i], y[i]);\n    }\n}\n"}
{"id": 78727, "name": "Write float arrays to a text file", "source": "Translate Ruby to C#: \nx = [1, 2, 3, 1e11]\ny = x.collect { |xx| Math.sqrt xx }\nxprecision = 3\nyprecision = 5\n\n\nopen('sqrt.dat', 'w') do |f|\n  x.zip(y) { |xx, yy| f.printf(\"%.*g\\t%.*g\\n\", xprecision, xx, yprecision, yy) }\nend\n\n\nopen('sqrt.dat', 'r') { |f| puts f.read }\n", "target": "using System.IO;\n\nclass Program\n{\n    static void Main(string[] args)\n    {\n        var x = new double[] { 1, 2, 3, 1e11 };\n        var y = new double[] { 1, 1.4142135623730951, 1.7320508075688772, 316227.76601683791 };\n\n        int xprecision = 3;\n        int yprecision = 5;\n\n        string formatString = \"{0:G\" + xprecision + \"}\\t{1:G\" + yprecision + \"}\";\n\n        using (var outf = new StreamWriter(\"FloatArrayColumns.txt\"))\n            for (int i = 0; i < x.Length; i++)\n                outf.WriteLine(formatString, x[i], y[i]);\n    }\n}\n"}
{"id": 78730, "name": "Write float arrays to a text file", "source": "Translate Ruby to Java: \nx = [1, 2, 3, 1e11]\ny = x.collect { |xx| Math.sqrt xx }\nxprecision = 3\nyprecision = 5\n\n\nopen('sqrt.dat', 'w') do |f|\n  x.zip(y) { |xx, yy| f.printf(\"%.*g\\t%.*g\\n\", xprecision, xx, yprecision, yy) }\nend\n\n\nopen('sqrt.dat', 'r') { |f| puts f.read }\n", "target": "import java.io.*;\n\npublic class FloatArray {\n    public static void writeDat(String filename, double[] x, double[] y,\n                                int xprecision, int yprecision)\n        throws IOException {\n        assert x.length == y.length;\n        PrintWriter out = new PrintWriter(filename);\n        for (int i = 0; i < x.length; i++)\n            out.printf(\"%.\"+xprecision+\"g\\t%.\"+yprecision+\"g\\n\", x[i], y[i]);\n        out.close();\n    }\n\n    public static void main(String[] args) {\n        double[] x = {1, 2, 3, 1e11};\n        double[] y = new double[x.length];\n        for (int i = 0; i < x.length; i++)\n            y[i] = Math.sqrt(x[i]);\n        \n        try {\n            writeDat(\"sqrt.dat\", x, y, 3, 5);\n        } catch (IOException e) {\n            System.err.println(\"writeDat: exception: \"+e);\n        }\n\n        try {\n            BufferedReader br = new BufferedReader(new FileReader(\"sqrt.dat\"));\n            String line;\n            while ((line = br.readLine()) != null)\n                System.out.println(line);\n        } catch (IOException e) { }\n    }\n}\n"}
{"id": 78731, "name": "Write float arrays to a text file", "source": "Translate Ruby to Java: \nx = [1, 2, 3, 1e11]\ny = x.collect { |xx| Math.sqrt xx }\nxprecision = 3\nyprecision = 5\n\n\nopen('sqrt.dat', 'w') do |f|\n  x.zip(y) { |xx, yy| f.printf(\"%.*g\\t%.*g\\n\", xprecision, xx, yprecision, yy) }\nend\n\n\nopen('sqrt.dat', 'r') { |f| puts f.read }\n", "target": "import java.io.*;\n\npublic class FloatArray {\n    public static void writeDat(String filename, double[] x, double[] y,\n                                int xprecision, int yprecision)\n        throws IOException {\n        assert x.length == y.length;\n        PrintWriter out = new PrintWriter(filename);\n        for (int i = 0; i < x.length; i++)\n            out.printf(\"%.\"+xprecision+\"g\\t%.\"+yprecision+\"g\\n\", x[i], y[i]);\n        out.close();\n    }\n\n    public static void main(String[] args) {\n        double[] x = {1, 2, 3, 1e11};\n        double[] y = new double[x.length];\n        for (int i = 0; i < x.length; i++)\n            y[i] = Math.sqrt(x[i]);\n        \n        try {\n            writeDat(\"sqrt.dat\", x, y, 3, 5);\n        } catch (IOException e) {\n            System.err.println(\"writeDat: exception: \"+e);\n        }\n\n        try {\n            BufferedReader br = new BufferedReader(new FileReader(\"sqrt.dat\"));\n            String line;\n            while ((line = br.readLine()) != null)\n                System.out.println(line);\n        } catch (IOException e) { }\n    }\n}\n"}
{"id": 78732, "name": "Write float arrays to a text file", "source": "Translate Ruby to Python: \nx = [1, 2, 3, 1e11]\ny = x.collect { |xx| Math.sqrt xx }\nxprecision = 3\nyprecision = 5\n\n\nopen('sqrt.dat', 'w') do |f|\n  x.zip(y) { |xx, yy| f.printf(\"%.*g\\t%.*g\\n\", xprecision, xx, yprecision, yy) }\nend\n\n\nopen('sqrt.dat', 'r') { |f| puts f.read }\n", "target": "import itertools\ndef writedat(filename, x, y, xprecision=3, yprecision=5):\n    with open(filename,'w') as f:\n        for a, b in itertools.izip(x, y):\n            print >> f, \"%.*g\\t%.*g\" % (xprecision, a, yprecision, b)\n"}
{"id": 78733, "name": "Write float arrays to a text file", "source": "Translate Ruby to Python: \nx = [1, 2, 3, 1e11]\ny = x.collect { |xx| Math.sqrt xx }\nxprecision = 3\nyprecision = 5\n\n\nopen('sqrt.dat', 'w') do |f|\n  x.zip(y) { |xx, yy| f.printf(\"%.*g\\t%.*g\\n\", xprecision, xx, yprecision, yy) }\nend\n\n\nopen('sqrt.dat', 'r') { |f| puts f.read }\n", "target": "import itertools\ndef writedat(filename, x, y, xprecision=3, yprecision=5):\n    with open(filename,'w') as f:\n        for a, b in itertools.izip(x, y):\n            print >> f, \"%.*g\\t%.*g\" % (xprecision, a, yprecision, b)\n"}
{"id": 79017, "name": "21 game", "source": "Translate Ruby to C#: \n\nGOAL = 21\nMIN_MOVE = 1\nMAX_MOVE = 3\n\nDESCRIPTION = \"\n*** Welcome to the 21 Game! ***\n21 is a two player game.\nEach player chooses to add 1, 2 or 3 to a running total.\nThe player whose turn it is when the total reaches 21 will win the game.\nThe running total starts at zero.\n\nThe players start the game in turn.\nEnter q to quit at any time.\n\"\n\n\n\n\ndef best_move(total)\n  move = rand(1..3)\n  MIN_MOVE.upto(MAX_MOVE) do |i|\n    move = i if (total + i - 1) % (MAX_MOVE + 1) == 0\n  end\n  MIN_MOVE.upto(MAX_MOVE) do |i|\n    move = i if total + i == GOAL\n  end\n  move\nend\n\n\n\n\ndef get_move\n  print \"Your choice between \n  answer = gets\n  move = answer.to_i\n  until move.between?(MIN_MOVE, MAX_MOVE)\n    exit if answer.chomp == 'q'\n    print 'Invalid choice. Try again: '\n    answer = gets\n    move = answer.to_i\n  end\n  move\nend\n\n\n\n\ndef restart?\n  print 'Do you want to restart (y/n)? '\n  restart = gets.chomp\n  until ['y', 'n'].include?(restart)\n    print 'Your answer is not a valid choice. Try again: '\n    restart = gets.chomp\n  end\n  restart == 'y'\nend\n\n\n\n\n\n\ndef game(player)\n  total = round = 0\n  while total < GOAL\n    round += 1\n    puts \"--- ROUND \n    player = (player + 1) % 2\n    if player == 0\n      move = best_move(total)\n      puts \"The computer chooses \n    else\n      move = get_move\n    end\n    total += move\n    puts \"Running total is now \n  end\n  if player == 0\n    puts 'Sorry, the computer has won!'\n    return false\n  end\n  puts 'Well done, you have won!'\n  true\nend\n\n\nputs DESCRIPTION\nrun = true\ncomputer_wins = human_wins = 0\ngames_counter = player = 1\nwhile run\n  puts \"\\n=== START GAME \n  player = (player + 1) % 2\n  if game(player)\n    human_wins += 1\n  else\n    computer_wins += 1\n  end\n  puts \"\\nComputer wins \n  games_counter += 1\n  run = restart?\nend\nputs 'Good bye!'\n", "target": "\n\nusing System;\n\nnamespace _21Game\n{\n    public class Program\n    {\n        private const string computerPlayer = \"Computer\";\n        private const string humanPlayer = \"Player 1\";\n\n        public static string SwapPlayer(string currentPlayer)\n        {\n            if (currentPlayer == computerPlayer)\n            {\n                currentPlayer = humanPlayer;\n            }\n            else\n            {\n                currentPlayer = computerPlayer;\n            }\n\n            return currentPlayer;\n        }\n\n        public static void PlayGame()\n        {\n            bool playAnother = true;\n            int total = 0;\n            int final = 21;\n            int roundChoice = 0;\n            string currentPlayer = RandomPLayerSelect();\n            int compWins = 0;\n            int humanWins = 0;\n\n            while (playAnother)\n            {\n                Console.WriteLine($\"Now playing: {currentPlayer}\");\n                try\n                {\n                    if (currentPlayer == computerPlayer)\n                    {\n                       roundChoice =  CompMove(total);\n                    }\n                    else\n                    {\n                        roundChoice = int.Parse(Console.ReadLine());\n                    }\n                    \n\n                    if (roundChoice != 1 && roundChoice != 2 && roundChoice != 3)\n                    {\n                        throw new Exception();\n                    }\n\n                    total += roundChoice;\n                }\n                catch (Exception)\n                {\n                    Console.WriteLine(\"Invalid choice! Choose from numbers: 1, 2, 3.\");\n                    continue;\n                }\n\n                Console.WriteLine(total);\n\n                if (total == final)\n                {\n                    if (currentPlayer == computerPlayer)\n                    {\n                        compWins++;\n                    }\n                    if (currentPlayer == humanPlayer)\n                    {\n                        humanWins++;\n                    }\n                    Console.WriteLine($\"Winner: {currentPlayer}\");\n                    Console.WriteLine($\"Comp wins: {compWins}. Human wins: {humanWins}\");\n                    Console.WriteLine($\"do you wan to play another round? y/n\");\n                    var choice = Console.ReadLine();\n                    if (choice == \"y\")\n                    {\n                        total = 0;\n                    }\n                    else if (choice == \"n\")\n                    {\n                        break;\n                    }\n                    else\n                    {\n                        Console.WriteLine(\"Invalid choice! Choose from y or n\");\n                        continue;\n                    }\n                }\n\n                else if (total > 21)\n                {\n                    Console.WriteLine(\"Not the right time to play this game\u00a0:)\");\n                    break;\n                }\n\n                currentPlayer = SwapPlayer(currentPlayer);\n            }\n        }\n\n        public static bool CheckIfCanWin(int total)\n        {\n            bool result = false;\n            if (total == 18)\n            {\n                result = true;\n            }\n            return result;\n        }\n\n        public static int CompMove(int total)\n        {\n            int choice = 0;\n\n            if (CheckIfCanWin(total))\n            {\n                choice = 21 - total;\n            }\n            else\n            {\n                choice = new Random().Next(1,4);\n            }\n\n            return choice;\n        }\n\n        public static string RandomPLayerSelect()\n        {\n            string[] players = new string[] { computerPlayer, humanPlayer };\n            var random = new Random().Next(0,2);\n            return players[random];\n        }\n\n        public static void Main(string[] args)\n        {\n            \n            Console.WriteLine(\"Welcome to 21 game \\n\");\n            Console.WriteLine(@\"21 is a two player game. \nThe game is played by choosing a number.\n1, 2, or 3 to be added a total sum. \\n\nThe game is won by the player reaches exactly 21. \\n\" );            \n            Console.WriteLine(\"Choose your number: (1, 2 or 3)\");\n\n            PlayGame();\n        }\n    }\n}\n"}
{"id": 79018, "name": "21 game", "source": "Translate Ruby to C#: \n\nGOAL = 21\nMIN_MOVE = 1\nMAX_MOVE = 3\n\nDESCRIPTION = \"\n*** Welcome to the 21 Game! ***\n21 is a two player game.\nEach player chooses to add 1, 2 or 3 to a running total.\nThe player whose turn it is when the total reaches 21 will win the game.\nThe running total starts at zero.\n\nThe players start the game in turn.\nEnter q to quit at any time.\n\"\n\n\n\n\ndef best_move(total)\n  move = rand(1..3)\n  MIN_MOVE.upto(MAX_MOVE) do |i|\n    move = i if (total + i - 1) % (MAX_MOVE + 1) == 0\n  end\n  MIN_MOVE.upto(MAX_MOVE) do |i|\n    move = i if total + i == GOAL\n  end\n  move\nend\n\n\n\n\ndef get_move\n  print \"Your choice between \n  answer = gets\n  move = answer.to_i\n  until move.between?(MIN_MOVE, MAX_MOVE)\n    exit if answer.chomp == 'q'\n    print 'Invalid choice. Try again: '\n    answer = gets\n    move = answer.to_i\n  end\n  move\nend\n\n\n\n\ndef restart?\n  print 'Do you want to restart (y/n)? '\n  restart = gets.chomp\n  until ['y', 'n'].include?(restart)\n    print 'Your answer is not a valid choice. Try again: '\n    restart = gets.chomp\n  end\n  restart == 'y'\nend\n\n\n\n\n\n\ndef game(player)\n  total = round = 0\n  while total < GOAL\n    round += 1\n    puts \"--- ROUND \n    player = (player + 1) % 2\n    if player == 0\n      move = best_move(total)\n      puts \"The computer chooses \n    else\n      move = get_move\n    end\n    total += move\n    puts \"Running total is now \n  end\n  if player == 0\n    puts 'Sorry, the computer has won!'\n    return false\n  end\n  puts 'Well done, you have won!'\n  true\nend\n\n\nputs DESCRIPTION\nrun = true\ncomputer_wins = human_wins = 0\ngames_counter = player = 1\nwhile run\n  puts \"\\n=== START GAME \n  player = (player + 1) % 2\n  if game(player)\n    human_wins += 1\n  else\n    computer_wins += 1\n  end\n  puts \"\\nComputer wins \n  games_counter += 1\n  run = restart?\nend\nputs 'Good bye!'\n", "target": "\n\nusing System;\n\nnamespace _21Game\n{\n    public class Program\n    {\n        private const string computerPlayer = \"Computer\";\n        private const string humanPlayer = \"Player 1\";\n\n        public static string SwapPlayer(string currentPlayer)\n        {\n            if (currentPlayer == computerPlayer)\n            {\n                currentPlayer = humanPlayer;\n            }\n            else\n            {\n                currentPlayer = computerPlayer;\n            }\n\n            return currentPlayer;\n        }\n\n        public static void PlayGame()\n        {\n            bool playAnother = true;\n            int total = 0;\n            int final = 21;\n            int roundChoice = 0;\n            string currentPlayer = RandomPLayerSelect();\n            int compWins = 0;\n            int humanWins = 0;\n\n            while (playAnother)\n            {\n                Console.WriteLine($\"Now playing: {currentPlayer}\");\n                try\n                {\n                    if (currentPlayer == computerPlayer)\n                    {\n                       roundChoice =  CompMove(total);\n                    }\n                    else\n                    {\n                        roundChoice = int.Parse(Console.ReadLine());\n                    }\n                    \n\n                    if (roundChoice != 1 && roundChoice != 2 && roundChoice != 3)\n                    {\n                        throw new Exception();\n                    }\n\n                    total += roundChoice;\n                }\n                catch (Exception)\n                {\n                    Console.WriteLine(\"Invalid choice! Choose from numbers: 1, 2, 3.\");\n                    continue;\n                }\n\n                Console.WriteLine(total);\n\n                if (total == final)\n                {\n                    if (currentPlayer == computerPlayer)\n                    {\n                        compWins++;\n                    }\n                    if (currentPlayer == humanPlayer)\n                    {\n                        humanWins++;\n                    }\n                    Console.WriteLine($\"Winner: {currentPlayer}\");\n                    Console.WriteLine($\"Comp wins: {compWins}. Human wins: {humanWins}\");\n                    Console.WriteLine($\"do you wan to play another round? y/n\");\n                    var choice = Console.ReadLine();\n                    if (choice == \"y\")\n                    {\n                        total = 0;\n                    }\n                    else if (choice == \"n\")\n                    {\n                        break;\n                    }\n                    else\n                    {\n                        Console.WriteLine(\"Invalid choice! Choose from y or n\");\n                        continue;\n                    }\n                }\n\n                else if (total > 21)\n                {\n                    Console.WriteLine(\"Not the right time to play this game\u00a0:)\");\n                    break;\n                }\n\n                currentPlayer = SwapPlayer(currentPlayer);\n            }\n        }\n\n        public static bool CheckIfCanWin(int total)\n        {\n            bool result = false;\n            if (total == 18)\n            {\n                result = true;\n            }\n            return result;\n        }\n\n        public static int CompMove(int total)\n        {\n            int choice = 0;\n\n            if (CheckIfCanWin(total))\n            {\n                choice = 21 - total;\n            }\n            else\n            {\n                choice = new Random().Next(1,4);\n            }\n\n            return choice;\n        }\n\n        public static string RandomPLayerSelect()\n        {\n            string[] players = new string[] { computerPlayer, humanPlayer };\n            var random = new Random().Next(0,2);\n            return players[random];\n        }\n\n        public static void Main(string[] args)\n        {\n            \n            Console.WriteLine(\"Welcome to 21 game \\n\");\n            Console.WriteLine(@\"21 is a two player game. \nThe game is played by choosing a number.\n1, 2, or 3 to be added a total sum. \\n\nThe game is won by the player reaches exactly 21. \\n\" );            \n            Console.WriteLine(\"Choose your number: (1, 2 or 3)\");\n\n            PlayGame();\n        }\n    }\n}\n"}
{"id": 79021, "name": "21 game", "source": "Translate Ruby to Java: \n\nGOAL = 21\nMIN_MOVE = 1\nMAX_MOVE = 3\n\nDESCRIPTION = \"\n*** Welcome to the 21 Game! ***\n21 is a two player game.\nEach player chooses to add 1, 2 or 3 to a running total.\nThe player whose turn it is when the total reaches 21 will win the game.\nThe running total starts at zero.\n\nThe players start the game in turn.\nEnter q to quit at any time.\n\"\n\n\n\n\ndef best_move(total)\n  move = rand(1..3)\n  MIN_MOVE.upto(MAX_MOVE) do |i|\n    move = i if (total + i - 1) % (MAX_MOVE + 1) == 0\n  end\n  MIN_MOVE.upto(MAX_MOVE) do |i|\n    move = i if total + i == GOAL\n  end\n  move\nend\n\n\n\n\ndef get_move\n  print \"Your choice between \n  answer = gets\n  move = answer.to_i\n  until move.between?(MIN_MOVE, MAX_MOVE)\n    exit if answer.chomp == 'q'\n    print 'Invalid choice. Try again: '\n    answer = gets\n    move = answer.to_i\n  end\n  move\nend\n\n\n\n\ndef restart?\n  print 'Do you want to restart (y/n)? '\n  restart = gets.chomp\n  until ['y', 'n'].include?(restart)\n    print 'Your answer is not a valid choice. Try again: '\n    restart = gets.chomp\n  end\n  restart == 'y'\nend\n\n\n\n\n\n\ndef game(player)\n  total = round = 0\n  while total < GOAL\n    round += 1\n    puts \"--- ROUND \n    player = (player + 1) % 2\n    if player == 0\n      move = best_move(total)\n      puts \"The computer chooses \n    else\n      move = get_move\n    end\n    total += move\n    puts \"Running total is now \n  end\n  if player == 0\n    puts 'Sorry, the computer has won!'\n    return false\n  end\n  puts 'Well done, you have won!'\n  true\nend\n\n\nputs DESCRIPTION\nrun = true\ncomputer_wins = human_wins = 0\ngames_counter = player = 1\nwhile run\n  puts \"\\n=== START GAME \n  player = (player + 1) % 2\n  if game(player)\n    human_wins += 1\n  else\n    computer_wins += 1\n  end\n  puts \"\\nComputer wins \n  games_counter += 1\n  run = restart?\nend\nputs 'Good bye!'\n", "target": "import java.util.Random;\nimport java.util.Scanner;\n\npublic class TwentyOneGame {\n\n    public static void main(String[] args) {\n        new TwentyOneGame().run(true, 21, new int[] {1, 2, 3});\n    }\n    \n    public void run(boolean computerPlay, int max, int[] valid) {\n        String comma = \"\";\n        for ( int i = 0 ; i < valid.length ; i++ ) {\n            comma += valid[i];\n            if ( i < valid.length - 2 && valid.length >= 3 ) {\n                comma += \", \";\n            }\n            if ( i == valid.length - 2 ) {\n                comma += \" or \";\n            }\n        }\n        System.out.printf(\"The %d game.%nEach player chooses to add %s to a running total.%n\" + \n                \"The player whose turn it is when the total reaches %d will win the game.%n\" + \n                \"Winner of the game starts the next game.  Enter q to quit.%n%n\", max, comma, max);\n        int cGames = 0;\n        int hGames = 0;\n        boolean anotherGame = true;\n        try (Scanner scanner = new Scanner(System.in);) {\n            while ( anotherGame ) {\n                Random r = new Random();\n                int round = 0;\n                int total = 0;\n                System.out.printf(\"Start game %d%n\", hGames + cGames + 1);\n                DONE:\n                    while ( true ) {\n                        round++;\n                        System.out.printf(\"ROUND %d:%n%n\", round);\n                        for ( int play = 0 ; play < 2 ; play++ ) {\n                            if ( computerPlay ) {\n                                int guess = 0;\n                                \n                                for ( int test : valid ) {\n                                    if ( total + test == max ) {\n                                        guess = test;\n                                        break;\n                                    }\n                                }\n                                \n                                if ( guess == 0 ) {\n                                    for ( int test : valid ) {\n                                        if ( total + test >= max ) {\n                                            guess = test;\n                                            break;\n                                        }\n                                    }\n                                }\n                                if ( guess == 0 ) {\n                                    guess = valid[r.nextInt(valid.length)];\n                                }\n                                total += guess;\n                                System.out.printf(\"The computer chooses %d%n\", guess);\n                                System.out.printf(\"Running total is now %d%n%n\", total);\n                                if ( total >= max ) {\n                                    break DONE;\n                                }\n                            }\n                            else {\n                                while ( true ) {\n                                    System.out.printf(\"Your choice among %s: \", comma);\n                                    String line = scanner.nextLine();\n                                    if ( line.matches(\"^[qQ].*\") ) {\n                                        System.out.printf(\"Computer wins %d game%s, human wins %d game%s.  One game incomplete.%nQuitting.%n\", cGames, cGames == 1 ? \"\" : \"s\", hGames, hGames == 1 ? \"\" : \"s\");\n                                        return;\n                                    }\n                                    try {\n                                        int input = Integer.parseInt(line);\n                                        boolean inputOk = false;\n                                        for ( int test : valid ) {\n                                            if ( input == test ) {\n                                                inputOk = true;\n                                                break;\n                                            }\n                                        }\n                                        if ( inputOk ) {\n                                            total += input;\n                                            System.out.printf(\"Running total is now %d%n%n\", total);\n                                            if ( total >= max ) {\n                                                break DONE;\n                                            }\n                                            break;\n                                        }\n                                        else {\n                                            System.out.printf(\"Invalid input - must be a number among %s.  Try again.%n\", comma);\n                                        }\n                                    }\n                                    catch (NumberFormatException e) {\n                                        System.out.printf(\"Invalid input - must be a number among %s.  Try again.%n\", comma);\n                                    }\n                                }\n                            }\n                            computerPlay = !computerPlay;\n                        }\n                    }\n                String win;\n                if ( computerPlay ) {\n                    win = \"Computer wins!!\";\n                    cGames++;\n                }\n                else {\n                    win = \"You win and probably had help from another computer!!\";\n                    hGames++;\n                }\n                System.out.printf(\"%s%n\", win);\n                System.out.printf(\"Computer wins %d game%s, human wins %d game%s%n%n\", cGames, cGames == 1 ? \"\" : \"s\", hGames, hGames == 1 ? \"\" : \"s\");\n                while ( true ) {\n                    System.out.printf(\"Another game (y/n)? \");\n                    String line = scanner.nextLine();\n                    if ( line.matches(\"^[yY]$\") ) {\n                        \n                        System.out.printf(\"%n\");\n                        break;\n                    }\n                    else if ( line.matches(\"^[nN]$\") ) {\n                        anotherGame = false;\n                        System.out.printf(\"Quitting.%n\");\n                        break;\n                    }\n                    else {\n                        System.out.printf(\"Invalid input - must be a y or n.  Try again.%n\");\n                    }\n                }\n            }\n        }\n    }\n\n}\n"}
{"id": 79022, "name": "21 game", "source": "Translate Ruby to Java: \n\nGOAL = 21\nMIN_MOVE = 1\nMAX_MOVE = 3\n\nDESCRIPTION = \"\n*** Welcome to the 21 Game! ***\n21 is a two player game.\nEach player chooses to add 1, 2 or 3 to a running total.\nThe player whose turn it is when the total reaches 21 will win the game.\nThe running total starts at zero.\n\nThe players start the game in turn.\nEnter q to quit at any time.\n\"\n\n\n\n\ndef best_move(total)\n  move = rand(1..3)\n  MIN_MOVE.upto(MAX_MOVE) do |i|\n    move = i if (total + i - 1) % (MAX_MOVE + 1) == 0\n  end\n  MIN_MOVE.upto(MAX_MOVE) do |i|\n    move = i if total + i == GOAL\n  end\n  move\nend\n\n\n\n\ndef get_move\n  print \"Your choice between \n  answer = gets\n  move = answer.to_i\n  until move.between?(MIN_MOVE, MAX_MOVE)\n    exit if answer.chomp == 'q'\n    print 'Invalid choice. Try again: '\n    answer = gets\n    move = answer.to_i\n  end\n  move\nend\n\n\n\n\ndef restart?\n  print 'Do you want to restart (y/n)? '\n  restart = gets.chomp\n  until ['y', 'n'].include?(restart)\n    print 'Your answer is not a valid choice. Try again: '\n    restart = gets.chomp\n  end\n  restart == 'y'\nend\n\n\n\n\n\n\ndef game(player)\n  total = round = 0\n  while total < GOAL\n    round += 1\n    puts \"--- ROUND \n    player = (player + 1) % 2\n    if player == 0\n      move = best_move(total)\n      puts \"The computer chooses \n    else\n      move = get_move\n    end\n    total += move\n    puts \"Running total is now \n  end\n  if player == 0\n    puts 'Sorry, the computer has won!'\n    return false\n  end\n  puts 'Well done, you have won!'\n  true\nend\n\n\nputs DESCRIPTION\nrun = true\ncomputer_wins = human_wins = 0\ngames_counter = player = 1\nwhile run\n  puts \"\\n=== START GAME \n  player = (player + 1) % 2\n  if game(player)\n    human_wins += 1\n  else\n    computer_wins += 1\n  end\n  puts \"\\nComputer wins \n  games_counter += 1\n  run = restart?\nend\nputs 'Good bye!'\n", "target": "import java.util.Random;\nimport java.util.Scanner;\n\npublic class TwentyOneGame {\n\n    public static void main(String[] args) {\n        new TwentyOneGame().run(true, 21, new int[] {1, 2, 3});\n    }\n    \n    public void run(boolean computerPlay, int max, int[] valid) {\n        String comma = \"\";\n        for ( int i = 0 ; i < valid.length ; i++ ) {\n            comma += valid[i];\n            if ( i < valid.length - 2 && valid.length >= 3 ) {\n                comma += \", \";\n            }\n            if ( i == valid.length - 2 ) {\n                comma += \" or \";\n            }\n        }\n        System.out.printf(\"The %d game.%nEach player chooses to add %s to a running total.%n\" + \n                \"The player whose turn it is when the total reaches %d will win the game.%n\" + \n                \"Winner of the game starts the next game.  Enter q to quit.%n%n\", max, comma, max);\n        int cGames = 0;\n        int hGames = 0;\n        boolean anotherGame = true;\n        try (Scanner scanner = new Scanner(System.in);) {\n            while ( anotherGame ) {\n                Random r = new Random();\n                int round = 0;\n                int total = 0;\n                System.out.printf(\"Start game %d%n\", hGames + cGames + 1);\n                DONE:\n                    while ( true ) {\n                        round++;\n                        System.out.printf(\"ROUND %d:%n%n\", round);\n                        for ( int play = 0 ; play < 2 ; play++ ) {\n                            if ( computerPlay ) {\n                                int guess = 0;\n                                \n                                for ( int test : valid ) {\n                                    if ( total + test == max ) {\n                                        guess = test;\n                                        break;\n                                    }\n                                }\n                                \n                                if ( guess == 0 ) {\n                                    for ( int test : valid ) {\n                                        if ( total + test >= max ) {\n                                            guess = test;\n                                            break;\n                                        }\n                                    }\n                                }\n                                if ( guess == 0 ) {\n                                    guess = valid[r.nextInt(valid.length)];\n                                }\n                                total += guess;\n                                System.out.printf(\"The computer chooses %d%n\", guess);\n                                System.out.printf(\"Running total is now %d%n%n\", total);\n                                if ( total >= max ) {\n                                    break DONE;\n                                }\n                            }\n                            else {\n                                while ( true ) {\n                                    System.out.printf(\"Your choice among %s: \", comma);\n                                    String line = scanner.nextLine();\n                                    if ( line.matches(\"^[qQ].*\") ) {\n                                        System.out.printf(\"Computer wins %d game%s, human wins %d game%s.  One game incomplete.%nQuitting.%n\", cGames, cGames == 1 ? \"\" : \"s\", hGames, hGames == 1 ? \"\" : \"s\");\n                                        return;\n                                    }\n                                    try {\n                                        int input = Integer.parseInt(line);\n                                        boolean inputOk = false;\n                                        for ( int test : valid ) {\n                                            if ( input == test ) {\n                                                inputOk = true;\n                                                break;\n                                            }\n                                        }\n                                        if ( inputOk ) {\n                                            total += input;\n                                            System.out.printf(\"Running total is now %d%n%n\", total);\n                                            if ( total >= max ) {\n                                                break DONE;\n                                            }\n                                            break;\n                                        }\n                                        else {\n                                            System.out.printf(\"Invalid input - must be a number among %s.  Try again.%n\", comma);\n                                        }\n                                    }\n                                    catch (NumberFormatException e) {\n                                        System.out.printf(\"Invalid input - must be a number among %s.  Try again.%n\", comma);\n                                    }\n                                }\n                            }\n                            computerPlay = !computerPlay;\n                        }\n                    }\n                String win;\n                if ( computerPlay ) {\n                    win = \"Computer wins!!\";\n                    cGames++;\n                }\n                else {\n                    win = \"You win and probably had help from another computer!!\";\n                    hGames++;\n                }\n                System.out.printf(\"%s%n\", win);\n                System.out.printf(\"Computer wins %d game%s, human wins %d game%s%n%n\", cGames, cGames == 1 ? \"\" : \"s\", hGames, hGames == 1 ? \"\" : \"s\");\n                while ( true ) {\n                    System.out.printf(\"Another game (y/n)? \");\n                    String line = scanner.nextLine();\n                    if ( line.matches(\"^[yY]$\") ) {\n                        \n                        System.out.printf(\"%n\");\n                        break;\n                    }\n                    else if ( line.matches(\"^[nN]$\") ) {\n                        anotherGame = false;\n                        System.out.printf(\"Quitting.%n\");\n                        break;\n                    }\n                    else {\n                        System.out.printf(\"Invalid input - must be a y or n.  Try again.%n\");\n                    }\n                }\n            }\n        }\n    }\n\n}\n"}
{"id": 79023, "name": "21 game", "source": "Translate Ruby to Python: \n\nGOAL = 21\nMIN_MOVE = 1\nMAX_MOVE = 3\n\nDESCRIPTION = \"\n*** Welcome to the 21 Game! ***\n21 is a two player game.\nEach player chooses to add 1, 2 or 3 to a running total.\nThe player whose turn it is when the total reaches 21 will win the game.\nThe running total starts at zero.\n\nThe players start the game in turn.\nEnter q to quit at any time.\n\"\n\n\n\n\ndef best_move(total)\n  move = rand(1..3)\n  MIN_MOVE.upto(MAX_MOVE) do |i|\n    move = i if (total + i - 1) % (MAX_MOVE + 1) == 0\n  end\n  MIN_MOVE.upto(MAX_MOVE) do |i|\n    move = i if total + i == GOAL\n  end\n  move\nend\n\n\n\n\ndef get_move\n  print \"Your choice between \n  answer = gets\n  move = answer.to_i\n  until move.between?(MIN_MOVE, MAX_MOVE)\n    exit if answer.chomp == 'q'\n    print 'Invalid choice. Try again: '\n    answer = gets\n    move = answer.to_i\n  end\n  move\nend\n\n\n\n\ndef restart?\n  print 'Do you want to restart (y/n)? '\n  restart = gets.chomp\n  until ['y', 'n'].include?(restart)\n    print 'Your answer is not a valid choice. Try again: '\n    restart = gets.chomp\n  end\n  restart == 'y'\nend\n\n\n\n\n\n\ndef game(player)\n  total = round = 0\n  while total < GOAL\n    round += 1\n    puts \"--- ROUND \n    player = (player + 1) % 2\n    if player == 0\n      move = best_move(total)\n      puts \"The computer chooses \n    else\n      move = get_move\n    end\n    total += move\n    puts \"Running total is now \n  end\n  if player == 0\n    puts 'Sorry, the computer has won!'\n    return false\n  end\n  puts 'Well done, you have won!'\n  true\nend\n\n\nputs DESCRIPTION\nrun = true\ncomputer_wins = human_wins = 0\ngames_counter = player = 1\nwhile run\n  puts \"\\n=== START GAME \n  player = (player + 1) % 2\n  if game(player)\n    human_wins += 1\n  else\n    computer_wins += 1\n  end\n  puts \"\\nComputer wins \n  games_counter += 1\n  run = restart?\nend\nputs 'Good bye!'\n", "target": "from random import randint\ndef start():\n\tgame_count=0\n\tprint(\"Enter q to quit at any time.\\nThe computer will choose first.\\nRunning total is now {}\".format(game_count))\n\troundno=1\n\twhile game_count<21:\n\t\tprint(\"\\nROUND {}: \\n\".format(roundno))\n\t\tt = select_count(game_count)\n\t\tgame_count = game_count+t\n\t\tprint(\"Running total is now {}\\n\".format(game_count))\n\t\tif game_count>=21:\n\t\t\tprint(\"So, commiserations, the computer has won!\")\n\t\t\treturn 0\n\t\tt = request_count()\n\t\tif not t:\n\t\t\tprint('OK,quitting the game')\n\t\t\treturn -1\n\t\tgame_count = game_count+t\n\t\tprint(\"Running total is now {}\\n\".format(game_count))\n\t\tif game_count>=21:\n\t\t\tprint(\"So, congratulations, you've won!\")\n\t\t\treturn 1\n\t\troundno+=1\n\ndef select_count(game_count):\n\t\n\tif game_count<18:\n\t\tt= randint(1,3)\n\telse:\n\t\tt = 21-game_count\n\tprint(\"The computer chooses {}\".format(t))\n\treturn t\n\ndef request_count():\n\t\n\tt=\"\"\n\twhile True:\n\t\ttry:\n\t\t\tt = raw_input('Your choice 1 to 3\u00a0:')\n\t\t\tif int(t) in [1,2,3]:\n\t\t\t\treturn int(t)\n\t\t\telse:\n\t\t\t\tprint(\"Out of range, try again\")\n\t\texcept:\n\t\t\tif t==\"q\":\n\t\t\t\treturn None\n\t\t\telse:\n\t\t\t\tprint(\"Invalid Entry, try again\")\n\nc=0\nm=0\nr=True\nwhile r:\n\to = start()\n\tif o==-1:\n\t\tbreak\n\telse:\n\t\tc+=1 if o==0 else 0\n\t\tm+=1 if o==1 else 0\n\tprint(\"Computer wins {0} game, human wins {1} games\".format(c,m))\n\tt = raw_input(\"Another game?(press y to continue):\")\n\tr = (t==\"y\")\n"}
{"id": 79024, "name": "21 game", "source": "Translate Ruby to Python: \n\nGOAL = 21\nMIN_MOVE = 1\nMAX_MOVE = 3\n\nDESCRIPTION = \"\n*** Welcome to the 21 Game! ***\n21 is a two player game.\nEach player chooses to add 1, 2 or 3 to a running total.\nThe player whose turn it is when the total reaches 21 will win the game.\nThe running total starts at zero.\n\nThe players start the game in turn.\nEnter q to quit at any time.\n\"\n\n\n\n\ndef best_move(total)\n  move = rand(1..3)\n  MIN_MOVE.upto(MAX_MOVE) do |i|\n    move = i if (total + i - 1) % (MAX_MOVE + 1) == 0\n  end\n  MIN_MOVE.upto(MAX_MOVE) do |i|\n    move = i if total + i == GOAL\n  end\n  move\nend\n\n\n\n\ndef get_move\n  print \"Your choice between \n  answer = gets\n  move = answer.to_i\n  until move.between?(MIN_MOVE, MAX_MOVE)\n    exit if answer.chomp == 'q'\n    print 'Invalid choice. Try again: '\n    answer = gets\n    move = answer.to_i\n  end\n  move\nend\n\n\n\n\ndef restart?\n  print 'Do you want to restart (y/n)? '\n  restart = gets.chomp\n  until ['y', 'n'].include?(restart)\n    print 'Your answer is not a valid choice. Try again: '\n    restart = gets.chomp\n  end\n  restart == 'y'\nend\n\n\n\n\n\n\ndef game(player)\n  total = round = 0\n  while total < GOAL\n    round += 1\n    puts \"--- ROUND \n    player = (player + 1) % 2\n    if player == 0\n      move = best_move(total)\n      puts \"The computer chooses \n    else\n      move = get_move\n    end\n    total += move\n    puts \"Running total is now \n  end\n  if player == 0\n    puts 'Sorry, the computer has won!'\n    return false\n  end\n  puts 'Well done, you have won!'\n  true\nend\n\n\nputs DESCRIPTION\nrun = true\ncomputer_wins = human_wins = 0\ngames_counter = player = 1\nwhile run\n  puts \"\\n=== START GAME \n  player = (player + 1) % 2\n  if game(player)\n    human_wins += 1\n  else\n    computer_wins += 1\n  end\n  puts \"\\nComputer wins \n  games_counter += 1\n  run = restart?\nend\nputs 'Good bye!'\n", "target": "from random import randint\ndef start():\n\tgame_count=0\n\tprint(\"Enter q to quit at any time.\\nThe computer will choose first.\\nRunning total is now {}\".format(game_count))\n\troundno=1\n\twhile game_count<21:\n\t\tprint(\"\\nROUND {}: \\n\".format(roundno))\n\t\tt = select_count(game_count)\n\t\tgame_count = game_count+t\n\t\tprint(\"Running total is now {}\\n\".format(game_count))\n\t\tif game_count>=21:\n\t\t\tprint(\"So, commiserations, the computer has won!\")\n\t\t\treturn 0\n\t\tt = request_count()\n\t\tif not t:\n\t\t\tprint('OK,quitting the game')\n\t\t\treturn -1\n\t\tgame_count = game_count+t\n\t\tprint(\"Running total is now {}\\n\".format(game_count))\n\t\tif game_count>=21:\n\t\t\tprint(\"So, congratulations, you've won!\")\n\t\t\treturn 1\n\t\troundno+=1\n\ndef select_count(game_count):\n\t\n\tif game_count<18:\n\t\tt= randint(1,3)\n\telse:\n\t\tt = 21-game_count\n\tprint(\"The computer chooses {}\".format(t))\n\treturn t\n\ndef request_count():\n\t\n\tt=\"\"\n\twhile True:\n\t\ttry:\n\t\t\tt = raw_input('Your choice 1 to 3\u00a0:')\n\t\t\tif int(t) in [1,2,3]:\n\t\t\t\treturn int(t)\n\t\t\telse:\n\t\t\t\tprint(\"Out of range, try again\")\n\t\texcept:\n\t\t\tif t==\"q\":\n\t\t\t\treturn None\n\t\t\telse:\n\t\t\t\tprint(\"Invalid Entry, try again\")\n\nc=0\nm=0\nr=True\nwhile r:\n\to = start()\n\tif o==-1:\n\t\tbreak\n\telse:\n\t\tc+=1 if o==0 else 0\n\t\tm+=1 if o==1 else 0\n\tprint(\"Computer wins {0} game, human wins {1} games\".format(c,m))\n\tt = raw_input(\"Another game?(press y to continue):\")\n\tr = (t==\"y\")\n"}
{"id": 79505, "name": "Sum multiples of 3 and 5", "source": "Translate Ruby to C#: def sum_3_5_multiples(n)\n  (0...n).select { |i| i % 3 == 0 || i % 5 == 0 }.sum\nend\n\nputs sum_3_5_multiples(1000)\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Numerics;\n\nnamespace RosettaCode\n{\n    class Program\n    {\n        static void Main()\n        {\n            List<BigInteger> candidates = new List<BigInteger>(new BigInteger[] { 1000, 100000, 10000000, 10000000000, 1000000000000000 });\n            candidates.Add(BigInteger.Parse(\"100000000000000000000\"));\n\n            foreach (BigInteger candidate in candidates)\n            {\n                BigInteger c = candidate - 1;\n                BigInteger answer3 = GetSumOfNumbersDivisibleByN(c, 3);\n                BigInteger answer5 = GetSumOfNumbersDivisibleByN(c, 5);\n                BigInteger answer15 = GetSumOfNumbersDivisibleByN(c, 15);\n\n                Console.WriteLine(\"The sum of numbers divisible by 3 or 5 between 1 and {0} is {1}\", c, answer3 + answer5 - answer15);\n            }\n\n            Console.ReadKey(true);\n        }\n\n        private static BigInteger GetSumOfNumbersDivisibleByN(BigInteger candidate, uint n)\n        {\n            BigInteger largest = candidate;\n            while (largest % n > 0)\n                largest--;\n            BigInteger totalCount = (largest / n);\n            BigInteger pairCount = totalCount / 2;\n            bool unpairedNumberOnFoldLine = (totalCount % 2 == 1);\n            BigInteger pairSum = largest + n;\n            return pairCount * pairSum + (unpairedNumberOnFoldLine ? pairSum / 2 : 0);\n        }\n\n    }\n}\n"}
{"id": 79506, "name": "Sum multiples of 3 and 5", "source": "Translate Ruby to C#: def sum_3_5_multiples(n)\n  (0...n).select { |i| i % 3 == 0 || i % 5 == 0 }.sum\nend\n\nputs sum_3_5_multiples(1000)\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Numerics;\n\nnamespace RosettaCode\n{\n    class Program\n    {\n        static void Main()\n        {\n            List<BigInteger> candidates = new List<BigInteger>(new BigInteger[] { 1000, 100000, 10000000, 10000000000, 1000000000000000 });\n            candidates.Add(BigInteger.Parse(\"100000000000000000000\"));\n\n            foreach (BigInteger candidate in candidates)\n            {\n                BigInteger c = candidate - 1;\n                BigInteger answer3 = GetSumOfNumbersDivisibleByN(c, 3);\n                BigInteger answer5 = GetSumOfNumbersDivisibleByN(c, 5);\n                BigInteger answer15 = GetSumOfNumbersDivisibleByN(c, 15);\n\n                Console.WriteLine(\"The sum of numbers divisible by 3 or 5 between 1 and {0} is {1}\", c, answer3 + answer5 - answer15);\n            }\n\n            Console.ReadKey(true);\n        }\n\n        private static BigInteger GetSumOfNumbersDivisibleByN(BigInteger candidate, uint n)\n        {\n            BigInteger largest = candidate;\n            while (largest % n > 0)\n                largest--;\n            BigInteger totalCount = (largest / n);\n            BigInteger pairCount = totalCount / 2;\n            bool unpairedNumberOnFoldLine = (totalCount % 2 == 1);\n            BigInteger pairSum = largest + n;\n            return pairCount * pairSum + (unpairedNumberOnFoldLine ? pairSum / 2 : 0);\n        }\n\n    }\n}\n"}
{"id": 79509, "name": "Sum multiples of 3 and 5", "source": "Translate Ruby to Java: def sum_3_5_multiples(n)\n  (0...n).select { |i| i % 3 == 0 || i % 5 == 0 }.sum\nend\n\nputs sum_3_5_multiples(1000)\n", "target": "class SumMultiples {\n\tpublic static long getSum(long n) {\n\t\tlong sum = 0;\n\t\tfor (int i = 3; i < n; i++) {\n\t\t\tif (i % 3 == 0 || i % 5 == 0) sum += i;\n\t\t}\n\t\treturn sum;\n\t}\n\tpublic static void main(String[] args) {\n\t\tSystem.out.println(getSum(1000));\n\t}\n}\n"}
{"id": 79510, "name": "Sum multiples of 3 and 5", "source": "Translate Ruby to Java: def sum_3_5_multiples(n)\n  (0...n).select { |i| i % 3 == 0 || i % 5 == 0 }.sum\nend\n\nputs sum_3_5_multiples(1000)\n", "target": "class SumMultiples {\n\tpublic static long getSum(long n) {\n\t\tlong sum = 0;\n\t\tfor (int i = 3; i < n; i++) {\n\t\t\tif (i % 3 == 0 || i % 5 == 0) sum += i;\n\t\t}\n\t\treturn sum;\n\t}\n\tpublic static void main(String[] args) {\n\t\tSystem.out.println(getSum(1000));\n\t}\n}\n"}
{"id": 79511, "name": "Sum multiples of 3 and 5", "source": "Translate Ruby to Python: def sum_3_5_multiples(n)\n  (0...n).select { |i| i % 3 == 0 || i % 5 == 0 }.sum\nend\n\nputs sum_3_5_multiples(1000)\n", "target": "def sum35a(n):\n    'Direct count'\n    \n    return sum(x for x in range(n) if x%3==0 or x%5==0)\n\ndef sum35b(n): \n    \"Count all the 3's; all the 5's; minus double-counted 3*5's\"\n    \n    return sum(range(3, n, 3)) + sum(range(5, n, 5)) - sum(range(15, n, 15))\n    \ndef sum35c(n):\n    'Sum the arithmetic progressions: sum3 + sum5 - sum15'\n    consts = (3, 5, 15)\n    \n    divs = [(n-1) // c for c in consts]\n    sums = [d*c*(1+d)/2 for d,c in zip(divs, consts)]\n    return sums[0] + sums[1] - sums[2]\n\n\nfor n in range(1001):\n    sa, sb, sc = sum35a(n), sum35b(n), sum35c(n)\n    assert sa == sb == sc  \n\nprint('For n = %7i -> %i\\n' % (n, sc))\n\n\nfor p in range(7):\n    print('For n = %7i -> %i' % (10**p, sum35c(10**p)))\n\n\np = 20\nprint('\\nFor n = %20i -> %i' % (10**p, sum35c(10**p)))\n"}
{"id": 79512, "name": "Sum multiples of 3 and 5", "source": "Translate Ruby to Python: def sum_3_5_multiples(n)\n  (0...n).select { |i| i % 3 == 0 || i % 5 == 0 }.sum\nend\n\nputs sum_3_5_multiples(1000)\n", "target": "def sum35a(n):\n    'Direct count'\n    \n    return sum(x for x in range(n) if x%3==0 or x%5==0)\n\ndef sum35b(n): \n    \"Count all the 3's; all the 5's; minus double-counted 3*5's\"\n    \n    return sum(range(3, n, 3)) + sum(range(5, n, 5)) - sum(range(15, n, 15))\n    \ndef sum35c(n):\n    'Sum the arithmetic progressions: sum3 + sum5 - sum15'\n    consts = (3, 5, 15)\n    \n    divs = [(n-1) // c for c in consts]\n    sums = [d*c*(1+d)/2 for d,c in zip(divs, consts)]\n    return sums[0] + sums[1] - sums[2]\n\n\nfor n in range(1001):\n    sa, sb, sc = sum35a(n), sum35b(n), sum35c(n)\n    assert sa == sb == sc  \n\nprint('For n = %7i -> %i\\n' % (n, sc))\n\n\nfor p in range(7):\n    print('For n = %7i -> %i' % (10**p, sum35c(10**p)))\n\n\np = 20\nprint('\\nFor n = %20i -> %i' % (10**p, sum35c(10**p)))\n"}
{"id": 79851, "name": "Pascal's triangle", "source": "Translate Ruby to C#: def pascal(n)\n  raise ArgumentError, \"must be positive.\" if n < 1\n  yield ar = [1]\n  (n-1).times do\n    ar.unshift(0).push(0) \n    yield ar = ar.each_cons(2).map(&:sum)\n  end\nend\n \npascal(8){|row| puts row.join(\" \").center(20)}\n", "target": "using System;\n\nnamespace RosettaCode {\n\n    class PascalsTriangle {\n\n        public static void CreateTriangle(int n) {\n            if (n > 0) {\n                for (int i = 0; i < n; i++) {\n                    int c = 1;\n                    Console.Write(\" \".PadLeft(2 * (n - 1 - i)));\n                    for (int k = 0; k <= i; k++) {\n                        Console.Write(\"{0}\", c.ToString().PadLeft(3));\n                        c = c * (i - k) / (k + 1);\n                    }\n                    Console.WriteLine();\n                }\n            }\n        }\n\n        public static void Main() {\n            CreateTriangle(8);\n        }\n    }\n}\n"}
{"id": 79853, "name": "Pascal's triangle", "source": "Translate Ruby to Java: def pascal(n)\n  raise ArgumentError, \"must be positive.\" if n < 1\n  yield ar = [1]\n  (n-1).times do\n    ar.unshift(0).push(0) \n    yield ar = ar.each_cons(2).map(&:sum)\n  end\nend\n \npascal(8){|row| puts row.join(\" \").center(20)}\n", "target": "import java.util.ArrayList;\n...\npublic static void genPyrN(int rows){\n\tif(rows < 0) return;\n\t\n\tArrayList<Integer> last = new ArrayList<Integer>();\n\tlast.add(1);\n\tSystem.out.println(last);\n\tfor(int i= 1;i <= rows;++i){\n\t\t\n\t\tArrayList<Integer> thisRow= new ArrayList<Integer>();\n\t\tthisRow.add(last.get(0)); \n\t\tfor(int j= 1;j < i;++j){\n\t\t\t\n\t\t\tthisRow.add(last.get(j - 1) + last.get(j));\n\t\t}\n\t\tthisRow.add(last.get(0)); \n\t\tlast= thisRow;\n\t\tSystem.out.println(thisRow);\n\t}\n}\n"}
{"id": 79854, "name": "Pascal's triangle", "source": "Translate Ruby to Python: def pascal(n)\n  raise ArgumentError, \"must be positive.\" if n < 1\n  yield ar = [1]\n  (n-1).times do\n    ar.unshift(0).push(0) \n    yield ar = ar.each_cons(2).map(&:sum)\n  end\nend\n \npascal(8){|row| puts row.join(\" \").center(20)}\n", "target": "def pascal(n):\n   \n   row = [1]\n   k = [0]\n   for x in range(max(n,0)):\n      print row\n      row=[l+r for l,r in zip(row+k,k+row)]\n   return n>=1\n"}
{"id": 80135, "name": "Logical operations", "source": "Translate Ruby to C#: def logic(a, b)\n  print 'a and b: ', a && b, \"\\n\"\n  print 'a or b: ' , a || b, \"\\n\"\n  print 'not a: '  , !a    , \"\\n\"\n  print 'a xor b: ' , a ^ b, \"\\n\"\nend\n", "target": "using System;\n\nnamespace LogicalOperations\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            bool a = true, b = false;\n            Console.WriteLine(\"a and b is {0}\", a && b);\n            Console.WriteLine(\"a or b is {0}\", a || b);\n            Console.WriteLine(\"Not a is {0}\", !a);\n            Console.WriteLine(\"a exclusive-or b is {0}\", a ^ b);\n        }\n    }\n}\n"}
{"id": 80137, "name": "Logical operations", "source": "Translate Ruby to Java: def logic(a, b)\n  print 'a and b: ', a && b, \"\\n\"\n  print 'a or b: ' , a || b, \"\\n\"\n  print 'not a: '  , !a    , \"\\n\"\n  print 'a xor b: ' , a ^ b, \"\\n\"\nend\n", "target": "boolean a = true;\nboolean b = false;\nSystem.Debug('a AND b: ' + (a && b));\nSystem.Debug('a OR b: ' + (a || b));\nSystem.Debug('NOT a: ' + (!a));\nSystem.Debug('a XOR b: ' + (a ^ b));\n"}
{"id": 80138, "name": "Logical operations", "source": "Translate Ruby to Python: def logic(a, b)\n  print 'a and b: ', a && b, \"\\n\"\n  print 'a or b: ' , a || b, \"\\n\"\n  print 'not a: '  , !a    , \"\\n\"\n  print 'a xor b: ' , a ^ b, \"\\n\"\nend\n", "target": "def logic(a, b):\n    print('a and b:', a and b)\n    print('a or b:', a or b)\n    print('not a:', not a)\n"}
{"id": 80498, "name": "Perfect shuffle", "source": "Translate Ruby to C#: def perfect_shuffle(deck_size = 52)\n  deck     = (1..deck_size).to_a\n  original = deck.dup\n  half     = deck_size / 2\n  1.step do |i|\n    deck = deck.first(half).zip(deck.last(half)).flatten\n    return i if deck == original \n  end\nend\n\n[8, 24, 52, 100, 1020, 1024, 10000].each {|i| puts \"Perfect shuffles required for deck size \n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\npublic static class PerfectShuffle\n{\n    static void Main()\n    {\n        foreach (int input in new [] {8, 24, 52, 100, 1020, 1024, 10000}) {\n            int[] numbers = Enumerable.Range(1, input).ToArray();\n            Console.WriteLine($\"{input} cards: {ShuffleThrough(numbers).Count()}\");\n        }\n\n        IEnumerable<T[]> ShuffleThrough<T>(T[] original) {\n            T[] copy = (T[])original.Clone();\n            do {\n                yield return copy = Shuffle(copy);\n            } while (!Enumerable.SequenceEqual(original, copy));\n        }\n    }\n\n    public static T[] Shuffle<T>(T[] array) {\n        if (array.Length % 2 != 0) throw new ArgumentException(\"Length must be even.\");\n        int half = array.Length / 2;\n        T[] result = new T[array.Length];\n        for (int t = 0, l = 0, r = half; l < half; t+=2, l++, r++) {\n            result[t] = array[l];\n            result[t+1] = array[r];\n        }\n        return result;\n    }\n    \n}\n"}
{"id": 80499, "name": "Perfect shuffle", "source": "Translate Ruby to C#: def perfect_shuffle(deck_size = 52)\n  deck     = (1..deck_size).to_a\n  original = deck.dup\n  half     = deck_size / 2\n  1.step do |i|\n    deck = deck.first(half).zip(deck.last(half)).flatten\n    return i if deck == original \n  end\nend\n\n[8, 24, 52, 100, 1020, 1024, 10000].each {|i| puts \"Perfect shuffles required for deck size \n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\npublic static class PerfectShuffle\n{\n    static void Main()\n    {\n        foreach (int input in new [] {8, 24, 52, 100, 1020, 1024, 10000}) {\n            int[] numbers = Enumerable.Range(1, input).ToArray();\n            Console.WriteLine($\"{input} cards: {ShuffleThrough(numbers).Count()}\");\n        }\n\n        IEnumerable<T[]> ShuffleThrough<T>(T[] original) {\n            T[] copy = (T[])original.Clone();\n            do {\n                yield return copy = Shuffle(copy);\n            } while (!Enumerable.SequenceEqual(original, copy));\n        }\n    }\n\n    public static T[] Shuffle<T>(T[] array) {\n        if (array.Length % 2 != 0) throw new ArgumentException(\"Length must be even.\");\n        int half = array.Length / 2;\n        T[] result = new T[array.Length];\n        for (int t = 0, l = 0, r = half; l < half; t+=2, l++, r++) {\n            result[t] = array[l];\n            result[t+1] = array[r];\n        }\n        return result;\n    }\n    \n}\n"}
{"id": 80502, "name": "Perfect shuffle", "source": "Translate Ruby to Java: def perfect_shuffle(deck_size = 52)\n  deck     = (1..deck_size).to_a\n  original = deck.dup\n  half     = deck_size / 2\n  1.step do |i|\n    deck = deck.first(half).zip(deck.last(half)).flatten\n    return i if deck == original \n  end\nend\n\n[8, 24, 52, 100, 1020, 1024, 10000].each {|i| puts \"Perfect shuffles required for deck size \n", "target": "import java.util.Arrays;\nimport java.util.stream.IntStream;\n\npublic class PerfectShuffle {\n\n    public static void main(String[] args) {\n        int[] sizes = {8, 24, 52, 100, 1020, 1024, 10_000};\n        for (int size : sizes)\n            System.out.printf(\"%5d\u00a0: %5d%n\", size, perfectShuffle(size));\n    }\n\n    static int perfectShuffle(int size) {\n        if (size % 2 != 0)\n            throw new IllegalArgumentException(\"size must be even\");\n\n        int half = size / 2;\n        int[] a = IntStream.range(0, size).toArray();\n        int[] original = a.clone();\n        int[] aa = new int[size];\n\n        for (int count = 1; true; count++) {\n            System.arraycopy(a, 0, aa, 0, size);\n\n            for (int i = 0; i < half; i++) {\n                a[2 * i] = aa[i];\n                a[2 * i + 1] = aa[i + half];\n            }\n\n            if (Arrays.equals(a, original))\n                return count;\n        }\n    }\n}\n"}
{"id": 80503, "name": "Perfect shuffle", "source": "Translate Ruby to Java: def perfect_shuffle(deck_size = 52)\n  deck     = (1..deck_size).to_a\n  original = deck.dup\n  half     = deck_size / 2\n  1.step do |i|\n    deck = deck.first(half).zip(deck.last(half)).flatten\n    return i if deck == original \n  end\nend\n\n[8, 24, 52, 100, 1020, 1024, 10000].each {|i| puts \"Perfect shuffles required for deck size \n", "target": "import java.util.Arrays;\nimport java.util.stream.IntStream;\n\npublic class PerfectShuffle {\n\n    public static void main(String[] args) {\n        int[] sizes = {8, 24, 52, 100, 1020, 1024, 10_000};\n        for (int size : sizes)\n            System.out.printf(\"%5d\u00a0: %5d%n\", size, perfectShuffle(size));\n    }\n\n    static int perfectShuffle(int size) {\n        if (size % 2 != 0)\n            throw new IllegalArgumentException(\"size must be even\");\n\n        int half = size / 2;\n        int[] a = IntStream.range(0, size).toArray();\n        int[] original = a.clone();\n        int[] aa = new int[size];\n\n        for (int count = 1; true; count++) {\n            System.arraycopy(a, 0, aa, 0, size);\n\n            for (int i = 0; i < half; i++) {\n                a[2 * i] = aa[i];\n                a[2 * i + 1] = aa[i + half];\n            }\n\n            if (Arrays.equals(a, original))\n                return count;\n        }\n    }\n}\n"}
{"id": 80504, "name": "Perfect shuffle", "source": "Translate Ruby to Python: def perfect_shuffle(deck_size = 52)\n  deck     = (1..deck_size).to_a\n  original = deck.dup\n  half     = deck_size / 2\n  1.step do |i|\n    deck = deck.first(half).zip(deck.last(half)).flatten\n    return i if deck == original \n  end\nend\n\n[8, 24, 52, 100, 1020, 1024, 10000].each {|i| puts \"Perfect shuffles required for deck size \n", "target": "import doctest\nimport random\n\n\ndef flatten(lst):\n    \n    return [i for sublst in lst for i in sublst]\n\ndef magic_shuffle(deck):\n    \n    half = len(deck) // 2 \n    return flatten(zip(deck[:half], deck[half:]))\n\ndef after_how_many_is_equal(shuffle_type,start,end):\n    \n\n    start = shuffle_type(start)\n    counter = 1\n    while start != end:\n        start = shuffle_type(start)\n        counter += 1\n    return counter\n\ndef main():\n    doctest.testmod()\n\n    print(\"Length of the deck of cards | Perfect shuffles needed to obtain the same deck back\")\n    for length in (8, 24, 52, 100, 1020, 1024, 10000):\n        deck = list(range(length))\n        shuffles_needed = after_how_many_is_equal(magic_shuffle,deck,deck)\n        print(\"{} | {}\".format(length,shuffles_needed))\n\n\nif __name__ == \"__main__\":\n    main()\n"}
{"id": 80505, "name": "Perfect shuffle", "source": "Translate Ruby to Python: def perfect_shuffle(deck_size = 52)\n  deck     = (1..deck_size).to_a\n  original = deck.dup\n  half     = deck_size / 2\n  1.step do |i|\n    deck = deck.first(half).zip(deck.last(half)).flatten\n    return i if deck == original \n  end\nend\n\n[8, 24, 52, 100, 1020, 1024, 10000].each {|i| puts \"Perfect shuffles required for deck size \n", "target": "import doctest\nimport random\n\n\ndef flatten(lst):\n    \n    return [i for sublst in lst for i in sublst]\n\ndef magic_shuffle(deck):\n    \n    half = len(deck) // 2 \n    return flatten(zip(deck[:half], deck[half:]))\n\ndef after_how_many_is_equal(shuffle_type,start,end):\n    \n\n    start = shuffle_type(start)\n    counter = 1\n    while start != end:\n        start = shuffle_type(start)\n        counter += 1\n    return counter\n\ndef main():\n    doctest.testmod()\n\n    print(\"Length of the deck of cards | Perfect shuffles needed to obtain the same deck back\")\n    for length in (8, 24, 52, 100, 1020, 1024, 10000):\n        deck = list(range(length))\n        shuffles_needed = after_how_many_is_equal(magic_shuffle,deck,deck)\n        print(\"{} | {}\".format(length,shuffles_needed))\n\n\nif __name__ == \"__main__\":\n    main()\n"}
{"id": 80727, "name": "Abstract type", "source": "Translate Ruby to C#: abstract class Animal \n  abstract def move\n  abstract def think\n\n  \n  def initialize(@name : String)\n  end\n\n  def process\n    think\n    move\n  end\nend\n\n\nabstract class WalkingAnimal < Animal\n  def move\n    puts \"\n  end\nend\n\nclass Human < WalkingAnimal\n  property in_car = false\n\n  def move\n    if in_car\n      puts \"\n    else\n      super\n    end\n  end\n\n  def think\n    puts \"\n  end\nend\n\n\nhe = Human.new(\"Andrew\") \nhe.process\n", "target": "abstract class Class1\n{\n   public abstract void method1();\n\n   public int method2()\n   {\n      return 0;\n   }\n}\n"}
{"id": 80729, "name": "Abstract type", "source": "Translate Ruby to Java: abstract class Animal \n  abstract def move\n  abstract def think\n\n  \n  def initialize(@name : String)\n  end\n\n  def process\n    think\n    move\n  end\nend\n\n\nabstract class WalkingAnimal < Animal\n  def move\n    puts \"\n  end\nend\n\nclass Human < WalkingAnimal\n  property in_car = false\n\n  def move\n    if in_car\n      puts \"\n    else\n      super\n    end\n  end\n\n  def think\n    puts \"\n  end\nend\n\n\nhe = Human.new(\"Andrew\") \nhe.process\n", "target": "public abstract class Abs {\n    public abstract int method1(double value);\n    protected abstract int method2(String name);\n    int add(int a, int b) {\n        return a + b;\n    }\n}\n"}
{"id": 80730, "name": "Abstract type", "source": "Translate Ruby to Python: abstract class Animal \n  abstract def move\n  abstract def think\n\n  \n  def initialize(@name : String)\n  end\n\n  def process\n    think\n    move\n  end\nend\n\n\nabstract class WalkingAnimal < Animal\n  def move\n    puts \"\n  end\nend\n\nclass Human < WalkingAnimal\n  property in_car = false\n\n  def move\n    if in_car\n      puts \"\n    else\n      super\n    end\n  end\n\n  def think\n    puts \"\n  end\nend\n\n\nhe = Human.new(\"Andrew\") \nhe.process\n", "target": "class BaseQueue(object):\n    \n    def __init__(self):\n        self.contents = list()\n        raise NotImplementedError\n    def Enqueue(self, item):\n        raise NotImplementedError\n    def Dequeue(self):\n        raise NotImplementedError\n    def Print_Contents(self):\n        for i in self.contents:\n            print i,\n"}
{"id": 80971, "name": "Conway's Game of Life", "source": "Translate Ruby to C#: def game_of_life(name, size, generations, initial_life=nil)\n  board = new_board size\n  seed board, size, initial_life\n  print_board board, name, 0\n  reason = generations.times do |gen|\n    new = evolve board, size\n    print_board new, name, gen+1\n    break :all_dead if barren? new, size\n    break :static   if board == new\n    board = new\n  end\n  if    reason == :all_dead then puts \"no more life.\"\n  elsif reason == :static   then puts \"no movement\"\n  else                           puts \"specified lifetime ended\"\n  end\n  puts\nend\n\ndef new_board(n)\n  Array.new(n) {Array.new(n, 0)}\nend\n\ndef seed(board, n, points=nil)\n  if points.nil?\n    \n    indices = []\n    n.times {|x| n.times {|y| indices << [x,y] }}\n    indices.shuffle[0,10].each {|x,y| board[y][x] = 1}\n  else\n    points.each {|x, y| board[y][x] = 1}\n  end\nend\n\ndef evolve(board, n)\n  new = new_board n\n  n.times {|i| n.times {|j| new[i][j] = fate board, i, j, n}}\n  new\nend\n\ndef fate(board, i, j, n)\n  i1 = [0, i-1].max; i2 = [i+1, n-1].min\n  j1 = [0, j-1].max; j2 = [j+1, n-1].min\n  sum = 0\n  for ii in (i1..i2)\n    for jj in (j1..j2)\n      sum += board[ii][jj] if not (ii == i and jj == j)\n    end\n  end\n  (sum == 3 or (sum == 2 and board[i][j] == 1)) ? 1 : 0\nend\n\ndef barren?(board, n)\n  n.times {|i| n.times {|j| return false if board[i][j] == 1}}\n  true\nend\n\ndef print_board(m, name, generation)\n  puts \"\n  m.each {|row| row.each {|val| print \"\nend\n\ngame_of_life \"blinker\", 3, 2, [[1,0],[1,1],[1,2]]\ngame_of_life \"glider\", 4, 4, [[1,0],[2,1],[0,2],[1,2],[2,2]]\ngame_of_life \"random\", 5, 10\n", "target": "using System;\nusing System.Text;\nusing System.Threading;\n \nnamespace ConwaysGameOfLife\n{\n    \n    class Program\n    {\n        \n        private const int DELAY = 50;\n \n        \n        private const ConsoleColor DEAD_COLOR = ConsoleColor.White;\n        private const ConsoleColor LIVE_COLOR = ConsoleColor.Black;\n \n        \n        private const ConsoleColor EXTRA_COLOR = ConsoleColor.Gray;\n \n        private const char EMPTY_BLOCK_CHAR = ' ';\n        private const char FULL_BLOCK_CHAR = '\\u2588';\n \n        \n        private static bool[,] board;\n \n        \n        private static int width = 32;\n        private static int height = 32;\n \n        \n        private static bool loopEdges = true;\n \n \n        static void Main(string[] args)\n        {\n            \n            initializeDemoBoard();\n \n            initializeConsole();\n \n            \n            while (!Console.KeyAvailable || Console.ReadKey(true).Key != ConsoleKey.Escape) {\n                Program.drawBoard();\n                Program.updateBoard();\n \n                \n                Thread.Sleep(DELAY);\n            }\n        }\n \n        \n        private static void initializeConsole()\n        {\n            Console.BackgroundColor = EXTRA_COLOR;\n            Console.Clear();\n \n            Console.CursorVisible = false;\n \n            \n            \n            int width = Math.Max(Program.width, 8) * 2 + 1;\n            int height = Math.Max(Program.height, 8) + 1;\n            Console.SetWindowSize(width, height);\n            Console.SetBufferSize(width, height);\n \n            Console.BackgroundColor = DEAD_COLOR;\n            Console.ForegroundColor = LIVE_COLOR;\n        }\n \n        \n        private static void initializeRandomBoard()\n        {\n            var random = new Random();\n \n            Program.board = new bool[Program.width, Program.height];\n            for (var y = 0; y < Program.height; y++) {\n                for (var x = 0; x < Program.width; x++) {\n                    \n                    Program.board[x, y] = random.Next(2) == 0;\n                }\n            }\n        }\n \n        \n        private static void initializeDemoBoard()\n        {\n            Program.width = 3;\n            Program.height = 3;\n \n            Program.loopEdges = false;\n \n            Program.board = new bool[3, 3];\n            Program.board[1, 0] = true;\n            Program.board[1, 1] = true;\n            Program.board[1, 2] = true;\n        }\n \n        \n        private static void drawBoard()\n        {\n            \n            var builder = new StringBuilder();\n \n            for (var y = 0; y < Program.height; y++) {\n                for (var x = 0; x < Program.width; x++) {\n                    char c = Program.board[x, y] ? FULL_BLOCK_CHAR : EMPTY_BLOCK_CHAR;\n \n                    \n                    builder.Append(c);\n                    builder.Append(c);\n                }\n                builder.Append('\\n');\n            }\n \n            \n            Console.SetCursorPosition(0, 0);\n            Console.Write (builder.ToString());\n        }\n \n        \n        private static void updateBoard()\n        {\n            \n            bool[,] newBoard = new bool[Program.width, Program.height];\n \n            for (var y = 0; y < Program.height; y++) {\n                for (var x = 0; x < Program.width; x++) {\n                    var n = countLiveNeighbors(x, y);\n                    var c = Program.board[x, y];\n \n                    \n                    \n                    newBoard[x, y] = c && (n == 2 || n == 3) || !c && n == 3;\n                }\n            }\n \n            \n            Program.board = newBoard;\n        }\n \n        \n        private static int countLiveNeighbors(int x, int y)\n        {\n            \n            int value = 0;\n \n            \n            for (var j = -1; j <= 1; j++) {\n                \n                if (!Program.loopEdges && y + j < 0 || y + j >= Program.height) {\n                    continue;\n                }\n \n                \n                int k = (y + j + Program.height) % Program.height;\n \n                for (var i = -1; i <= 1; i++) {\n                    \n                    if (!Program.loopEdges && x + i < 0 || x + i >= Program.width) {\n                        continue;\n                    }\n \n                    \n                    int h = (x + i + Program.width) % Program.width;\n \n                    \n                    value += Program.board[h, k] ? 1 : 0;\n                }\n            }\n \n            \n            return value - (Program.board[x, y] ? 1 : 0);\n        }\n    }\n}\n"}
{"id": 80973, "name": "Conway's Game of Life", "source": "Translate Ruby to Python: def game_of_life(name, size, generations, initial_life=nil)\n  board = new_board size\n  seed board, size, initial_life\n  print_board board, name, 0\n  reason = generations.times do |gen|\n    new = evolve board, size\n    print_board new, name, gen+1\n    break :all_dead if barren? new, size\n    break :static   if board == new\n    board = new\n  end\n  if    reason == :all_dead then puts \"no more life.\"\n  elsif reason == :static   then puts \"no movement\"\n  else                           puts \"specified lifetime ended\"\n  end\n  puts\nend\n\ndef new_board(n)\n  Array.new(n) {Array.new(n, 0)}\nend\n\ndef seed(board, n, points=nil)\n  if points.nil?\n    \n    indices = []\n    n.times {|x| n.times {|y| indices << [x,y] }}\n    indices.shuffle[0,10].each {|x,y| board[y][x] = 1}\n  else\n    points.each {|x, y| board[y][x] = 1}\n  end\nend\n\ndef evolve(board, n)\n  new = new_board n\n  n.times {|i| n.times {|j| new[i][j] = fate board, i, j, n}}\n  new\nend\n\ndef fate(board, i, j, n)\n  i1 = [0, i-1].max; i2 = [i+1, n-1].min\n  j1 = [0, j-1].max; j2 = [j+1, n-1].min\n  sum = 0\n  for ii in (i1..i2)\n    for jj in (j1..j2)\n      sum += board[ii][jj] if not (ii == i and jj == j)\n    end\n  end\n  (sum == 3 or (sum == 2 and board[i][j] == 1)) ? 1 : 0\nend\n\ndef barren?(board, n)\n  n.times {|i| n.times {|j| return false if board[i][j] == 1}}\n  true\nend\n\ndef print_board(m, name, generation)\n  puts \"\n  m.each {|row| row.each {|val| print \"\nend\n\ngame_of_life \"blinker\", 3, 2, [[1,0],[1,1],[1,2]]\ngame_of_life \"glider\", 4, 4, [[1,0],[2,1],[0,2],[1,2],[2,2]]\ngame_of_life \"random\", 5, 10\n", "target": "cell_size = 10\nsample = 10 \nplay = False   \nlast_cell = 0\n\ndef setup():\n    global grid, next_grid, rows, cols\n    size(800, 500)\n\n    rows = height / cell_size\n    cols = width / cell_size\n    grid = empty_grid()\n    next_grid = empty_grid()\n    randomize_grid()\n\n    println(\"Press 'space' to start/stop\")\n    println(\"'e' to clear all cells\")\n    println(\"'b' demonstrate 'blinker'\")\n    println(\"'g' demonstrate glider\")\n    println(\"'r' to randomize grid\")\n    println(\"'+' and '-' to change speed\")\n\ndef draw():\n    background(0)\n    for i in range(cols):\n        x = i * cell_size\n        for j in range(rows):\n            y = j * cell_size\n            current_state = grid[i][j]\n            fill(255)\n            noStroke()\n            if current_state:\n                rect(x, y, cell_size, cell_size)\n            if play:\n                ngbs_alive = calc_ngbs_alive(i, j)\n                result = rule(current_state, ngbs_alive)\n                next_grid[i][j] = result\n                \n    if play and frameCount % sample == 0 and not mousePressed:\n        step()\n\ndef rule(current, ngbs):\n    \n    if ngbs < 2 or ngbs > 3:\n        return 0  \n    elif ngbs == 3:\n        return 1  \n    else:\n        return current  \n\ndef calc_ngbs_alive(i, j):\n    NEIGHBOURS = ((-1, 00), (01, 00),  \n                  (-1, -1), (00, -1),\n                  (01, -1), (-1, 01),\n                  (00, 01), (01, 01))\n    alive = 0\n    for iv, jv in NEIGHBOURS:\n        alive += grid[(i + iv) % cols][(j + jv) % rows]\n    return alive\n\ndef empty_grid():\n    grid = []\n    for _ in range(cols):\n        grid.append([0] * rows)\n    return grid\n\ndef randomize_grid():\n    from random import choice\n    for i in range(cols):\n        for j in range(rows):\n            grid[i][j] = choice((0, 1))\n\ndef step():\n    global grid, next_grid\n    grid = next_grid\n    next_grid = empty_grid()\n\ndef keyReleased():\n    global grid, play, sample\n    if key == \"e\":\n        grid = empty_grid()\n    if key == \"r\":\n        randomize_grid()\n    if key == \"g\":\n         grid[10][10:13] = [0, 1, 0]       \n         grid[11][10:13] = [0, 0, 1]       \n         grid[12][10:13] = [1, 1, 1]       \n    if key == \"b\":\n         grid[10][10:13] = [0, 1, 0]       \n         grid[11][10:13] = [0, 1, 0]       \n         grid[12][10:13] = [0, 1, 0]               \n    if key == \" \":\n        play = not play \n    if  str(key) in '+=':\n        sample = max(sample - 1, 1);\n    if key == '-':\n        sample += 1\n\ndef mousePressed():\n    paint()\n    \ndef mouseDragged():\n    paint()\n\ndef paint():\n    global last_cell\n    i, j = mouseX // cell_size, mouseY // cell_size\n    p = j * cols + i\n    if p != last_cell:\n        last_cell = p\n        grid[i][j] = (1, 0)[grid[i][j]]\n"}
{"id": 81339, "name": "Best shuffle", "source": "Translate Ruby to C#: def best_shuffle(s)\n  \n  \n  pos = [] of Int32\n  \n  g = s.size.times.group_by { |i| s[i] }\n\n  \n  \n  \n  k = g.to_a.sort_by { |h| h[1].size }.map { |h| h[0] }       \n\n  until g.empty?\n    k.each do |letter|\n      g.has_key?(letter) || next          \n      pos << g[letter].pop\n      g[letter].empty? && g.delete letter \n    end\n  end\n  \n  \n  \n  \n  letters = s.dup\n  new = \"?\" * s.size\n\n  until letters.empty?\n    i, p = 0, pos.pop\n    while letters[i] == s[p] && i < (letters.size - 1); i += 1 end\n    \n    new = new.sub(p, letters[i]); letters = letters.sub(i, \"\")\n  end\n  score = new.chars.zip(s.chars).count { |c, d| c == d }\n  {new, score}\nend\n\n%w(abracadabra seesaw elk grrrrrr up a).each do |word|\n  \n  new, score = best_shuffle(word)\n  puts \"%s, %s, (%d)\" % [word, new, score]\nend\n", "target": "ShuffledString[] array = {\"cat\", \"dog\", \"mouse\"};\n"}
{"id": 81340, "name": "Best shuffle", "source": "Translate Ruby to C#: def best_shuffle(s)\n  \n  \n  pos = [] of Int32\n  \n  g = s.size.times.group_by { |i| s[i] }\n\n  \n  \n  \n  k = g.to_a.sort_by { |h| h[1].size }.map { |h| h[0] }       \n\n  until g.empty?\n    k.each do |letter|\n      g.has_key?(letter) || next          \n      pos << g[letter].pop\n      g[letter].empty? && g.delete letter \n    end\n  end\n  \n  \n  \n  \n  letters = s.dup\n  new = \"?\" * s.size\n\n  until letters.empty?\n    i, p = 0, pos.pop\n    while letters[i] == s[p] && i < (letters.size - 1); i += 1 end\n    \n    new = new.sub(p, letters[i]); letters = letters.sub(i, \"\")\n  end\n  score = new.chars.zip(s.chars).count { |c, d| c == d }\n  {new, score}\nend\n\n%w(abracadabra seesaw elk grrrrrr up a).each do |word|\n  \n  new, score = best_shuffle(word)\n  puts \"%s, %s, (%d)\" % [word, new, score]\nend\n", "target": "ShuffledString[] array = {\"cat\", \"dog\", \"mouse\"};\n"}
{"id": 81343, "name": "Best shuffle", "source": "Translate Ruby to Java: def best_shuffle(s)\n  \n  \n  pos = [] of Int32\n  \n  g = s.size.times.group_by { |i| s[i] }\n\n  \n  \n  \n  k = g.to_a.sort_by { |h| h[1].size }.map { |h| h[0] }       \n\n  until g.empty?\n    k.each do |letter|\n      g.has_key?(letter) || next          \n      pos << g[letter].pop\n      g[letter].empty? && g.delete letter \n    end\n  end\n  \n  \n  \n  \n  letters = s.dup\n  new = \"?\" * s.size\n\n  until letters.empty?\n    i, p = 0, pos.pop\n    while letters[i] == s[p] && i < (letters.size - 1); i += 1 end\n    \n    new = new.sub(p, letters[i]); letters = letters.sub(i, \"\")\n  end\n  score = new.chars.zip(s.chars).count { |c, d| c == d }\n  {new, score}\nend\n\n%w(abracadabra seesaw elk grrrrrr up a).each do |word|\n  \n  new, score = best_shuffle(word)\n  puts \"%s, %s, (%d)\" % [word, new, score]\nend\n", "target": "import java.util.Random;\n\npublic class BestShuffle {\n    private final static Random rand = new Random();\n\n    public static void main(String[] args) {\n        String[] words = {\"abracadabra\", \"seesaw\", \"grrrrrr\", \"pop\", \"up\", \"a\"};\n        for (String w : words)\n            System.out.println(bestShuffle(w));\n    }\n\n    public static String bestShuffle(final String s1) {\n        char[] s2 = s1.toCharArray();\n        shuffle(s2);\n        for (int i = 0; i < s2.length; i++) {\n            if (s2[i] != s1.charAt(i))\n                continue;\n            for (int j = 0; j < s2.length; j++) {\n                if (s2[i] != s2[j] && s2[i] != s1.charAt(j) && s2[j] != s1.charAt(i)) {\n                    char tmp = s2[i];\n                    s2[i] = s2[j];\n                    s2[j] = tmp;\n                    break;\n                }\n            }\n        }\n        return s1 + \" \" + new String(s2) + \" (\" + count(s1, s2) + \")\";\n    }\n\n    public static void shuffle(char[] text) {\n        for (int i = text.length - 1; i > 0; i--) {\n            int r = rand.nextInt(i + 1);\n            char tmp = text[i];\n            text[i] = text[r];\n            text[r] = tmp;\n        }\n    }\n\n    private static int count(final String s1, final char[] s2) {\n        int count = 0;\n        for (int i = 0; i < s2.length; i++)\n            if (s1.charAt(i) == s2[i])\n                count++;\n        return count;\n    }\n}\n"}
{"id": 81344, "name": "Best shuffle", "source": "Translate Ruby to Java: def best_shuffle(s)\n  \n  \n  pos = [] of Int32\n  \n  g = s.size.times.group_by { |i| s[i] }\n\n  \n  \n  \n  k = g.to_a.sort_by { |h| h[1].size }.map { |h| h[0] }       \n\n  until g.empty?\n    k.each do |letter|\n      g.has_key?(letter) || next          \n      pos << g[letter].pop\n      g[letter].empty? && g.delete letter \n    end\n  end\n  \n  \n  \n  \n  letters = s.dup\n  new = \"?\" * s.size\n\n  until letters.empty?\n    i, p = 0, pos.pop\n    while letters[i] == s[p] && i < (letters.size - 1); i += 1 end\n    \n    new = new.sub(p, letters[i]); letters = letters.sub(i, \"\")\n  end\n  score = new.chars.zip(s.chars).count { |c, d| c == d }\n  {new, score}\nend\n\n%w(abracadabra seesaw elk grrrrrr up a).each do |word|\n  \n  new, score = best_shuffle(word)\n  puts \"%s, %s, (%d)\" % [word, new, score]\nend\n", "target": "import java.util.Random;\n\npublic class BestShuffle {\n    private final static Random rand = new Random();\n\n    public static void main(String[] args) {\n        String[] words = {\"abracadabra\", \"seesaw\", \"grrrrrr\", \"pop\", \"up\", \"a\"};\n        for (String w : words)\n            System.out.println(bestShuffle(w));\n    }\n\n    public static String bestShuffle(final String s1) {\n        char[] s2 = s1.toCharArray();\n        shuffle(s2);\n        for (int i = 0; i < s2.length; i++) {\n            if (s2[i] != s1.charAt(i))\n                continue;\n            for (int j = 0; j < s2.length; j++) {\n                if (s2[i] != s2[j] && s2[i] != s1.charAt(j) && s2[j] != s1.charAt(i)) {\n                    char tmp = s2[i];\n                    s2[i] = s2[j];\n                    s2[j] = tmp;\n                    break;\n                }\n            }\n        }\n        return s1 + \" \" + new String(s2) + \" (\" + count(s1, s2) + \")\";\n    }\n\n    public static void shuffle(char[] text) {\n        for (int i = text.length - 1; i > 0; i--) {\n            int r = rand.nextInt(i + 1);\n            char tmp = text[i];\n            text[i] = text[r];\n            text[r] = tmp;\n        }\n    }\n\n    private static int count(final String s1, final char[] s2) {\n        int count = 0;\n        for (int i = 0; i < s2.length; i++)\n            if (s1.charAt(i) == s2[i])\n                count++;\n        return count;\n    }\n}\n"}
{"id": 81345, "name": "Best shuffle", "source": "Translate Ruby to Python: def best_shuffle(s)\n  \n  \n  pos = [] of Int32\n  \n  g = s.size.times.group_by { |i| s[i] }\n\n  \n  \n  \n  k = g.to_a.sort_by { |h| h[1].size }.map { |h| h[0] }       \n\n  until g.empty?\n    k.each do |letter|\n      g.has_key?(letter) || next          \n      pos << g[letter].pop\n      g[letter].empty? && g.delete letter \n    end\n  end\n  \n  \n  \n  \n  letters = s.dup\n  new = \"?\" * s.size\n\n  until letters.empty?\n    i, p = 0, pos.pop\n    while letters[i] == s[p] && i < (letters.size - 1); i += 1 end\n    \n    new = new.sub(p, letters[i]); letters = letters.sub(i, \"\")\n  end\n  score = new.chars.zip(s.chars).count { |c, d| c == d }\n  {new, score}\nend\n\n%w(abracadabra seesaw elk grrrrrr up a).each do |word|\n  \n  new, score = best_shuffle(word)\n  puts \"%s, %s, (%d)\" % [word, new, score]\nend\n", "target": "import random\n\ndef count(w1,wnew):\n    return sum(c1==c2 for c1,c2 in zip(w1, wnew))\n\ndef best_shuffle(w):\n    wnew = list(w)\n    n = len(w)\n    rangelists = (list(range(n)), list(range(n)))\n    for r in rangelists:\n        random.shuffle(r)\n    rangei, rangej = rangelists\n    for i in rangei:\n        for j in rangej:\n            if i != j and wnew[j] != wnew[i] and w[i] != wnew[j] and w[j] != wnew[i]:\n                wnew[j], wnew[i] = wnew[i], wnew[j]\n                break\n    wnew = ''.join(wnew)\n    return wnew, count(w, wnew)\n\n\nif __name__ == '__main__':\n    test_words = ('tree abracadabra seesaw elk grrrrrr up a ' \n                  + 'antidisestablishmentarianism hounddogs').split()\n    test_words += ['aardvarks are ant eaters', 'immediately', 'abba']\n    for w in test_words:\n        wnew, c = best_shuffle(w)\n        print(\"%29s, %-29s ,(%i)\" % (w, wnew, c))\n"}
{"id": 81346, "name": "Best shuffle", "source": "Translate Ruby to Python: def best_shuffle(s)\n  \n  \n  pos = [] of Int32\n  \n  g = s.size.times.group_by { |i| s[i] }\n\n  \n  \n  \n  k = g.to_a.sort_by { |h| h[1].size }.map { |h| h[0] }       \n\n  until g.empty?\n    k.each do |letter|\n      g.has_key?(letter) || next          \n      pos << g[letter].pop\n      g[letter].empty? && g.delete letter \n    end\n  end\n  \n  \n  \n  \n  letters = s.dup\n  new = \"?\" * s.size\n\n  until letters.empty?\n    i, p = 0, pos.pop\n    while letters[i] == s[p] && i < (letters.size - 1); i += 1 end\n    \n    new = new.sub(p, letters[i]); letters = letters.sub(i, \"\")\n  end\n  score = new.chars.zip(s.chars).count { |c, d| c == d }\n  {new, score}\nend\n\n%w(abracadabra seesaw elk grrrrrr up a).each do |word|\n  \n  new, score = best_shuffle(word)\n  puts \"%s, %s, (%d)\" % [word, new, score]\nend\n", "target": "import random\n\ndef count(w1,wnew):\n    return sum(c1==c2 for c1,c2 in zip(w1, wnew))\n\ndef best_shuffle(w):\n    wnew = list(w)\n    n = len(w)\n    rangelists = (list(range(n)), list(range(n)))\n    for r in rangelists:\n        random.shuffle(r)\n    rangei, rangej = rangelists\n    for i in rangei:\n        for j in rangej:\n            if i != j and wnew[j] != wnew[i] and w[i] != wnew[j] and w[j] != wnew[i]:\n                wnew[j], wnew[i] = wnew[i], wnew[j]\n                break\n    wnew = ''.join(wnew)\n    return wnew, count(w, wnew)\n\n\nif __name__ == '__main__':\n    test_words = ('tree abracadabra seesaw elk grrrrrr up a ' \n                  + 'antidisestablishmentarianism hounddogs').split()\n    test_words += ['aardvarks are ant eaters', 'immediately', 'abba']\n    for w in test_words:\n        wnew, c = best_shuffle(w)\n        print(\"%29s, %-29s ,(%i)\" % (w, wnew, c))\n"}
{"id": 81649, "name": "Compile-time calculation", "source": "Translate Ruby to C#: define n = (10!);\nsay n;\n", "target": "using System;\n\npublic static class Program\n{\n    public const int FACTORIAL_10 = 10 * 9 * 8 * 7 * 6 * 5 * 4 * 3 * 2 * 1;\n    static void Main()\n    {\n        Console.WriteLine(FACTORIAL_10);\n    }\n}\n"}
{"id": 81650, "name": "Compile-time calculation", "source": "Translate Ruby to C#: define n = (10!);\nsay n;\n", "target": "using System;\n\npublic static class Program\n{\n    public const int FACTORIAL_10 = 10 * 9 * 8 * 7 * 6 * 5 * 4 * 3 * 2 * 1;\n    static void Main()\n    {\n        Console.WriteLine(FACTORIAL_10);\n    }\n}\n"}
{"id": 81834, "name": "Draw a cuboid", "source": "Translate Ruby to C#: X, Y, Z = 6, 2, 3\nDIR = {\"-\" => [1,0], \"|\" => [0,1], \"/\" => [1,1]}\n\ndef cuboid(nx, ny, nz)\n  puts \"cuboid %d %d %d:\" % [nx, ny, nz]\n  x, y, z = X*nx, Y*ny, Z*nz\n  area = Array.new(y+z+1){\" \" * (x+y+1)}\n  draw_line = lambda do |n, sx, sy, c|\n    dx, dy = DIR[c]\n    (n+1).times do |i|\n      xi, yi = sx+i*dx, sy+i*dy\n      area[yi][xi] = (area[yi][xi]==\" \" ? c : \"+\")\n    end\n  end\n  nz    .times {|i| draw_line[x,     0,   Z*i, \"-\"]}\n  (ny+1).times {|i| draw_line[x,   Y*i, z+Y*i, \"-\"]}\n  nx    .times {|i| draw_line[z,   X*i,     0, \"|\"]}\n  (ny+1).times {|i| draw_line[z, x+Y*i,   Y*i, \"|\"]}\n  nz    .times {|i| draw_line[y,     x,   Z*i, \"/\"]}\n  (nx+1).times {|i| draw_line[y,   X*i,     z, \"/\"]}\n  puts area.reverse\nend\n\ncuboid(2, 3, 4)\ncuboid(1, 1, 1)\ncuboid(6, 2, 1)\ncuboid(2, 4, 1)\n", "target": "using System;\nusing System.Drawing;\nusing System.Drawing.Drawing2D;\nusing System.Windows.Forms;\n\nnamespace Cuboid\n{\n    public partial class Form1 : Form\n    {\n        double[][] nodes = {\n            new double[] {-1, -1, -1}, new double[] {-1, -1, 1}, new double[] {-1, 1, -1},\n            new double[] {-1, 1, 1}, new double[] {1, -1, -1}, new double[] {1, -1, 1},\n            new double[] {1, 1, -1}, new double[] {1, 1, 1} };\n\n        int[][] edges = {\n            new int[] {0, 1}, new int[] {1, 3}, new int[] {3, 2}, new int[] {2, 0}, new int[] {4, 5},\n            new int[] {5, 7}, new int[] {7, 6}, new int[] {6, 4}, new int[] {0, 4}, new int[] {1, 5},\n            new int[] {2, 6}, new int[] {3, 7}};\n\n        private int mouseX;\n        private int prevMouseX;\n        private int prevMouseY;\n        private int mouseY;\n\n        public Form1()\n        {\n            Width = Height = 640;\n            StartPosition = FormStartPosition.CenterScreen;\n            SetStyle(\n                ControlStyles.AllPaintingInWmPaint |\n                ControlStyles.UserPaint |\n                ControlStyles.DoubleBuffer,\n                true);\n\n            MouseMove += (s, e) =>\n            {\n                prevMouseX = mouseX;\n                prevMouseY = mouseY;\n                mouseX = e.X;\n                mouseY = e.Y;\n\n                double incrX = (mouseX - prevMouseX) * 0.01;\n                double incrY = (mouseY - prevMouseY) * 0.01;\n\n                RotateCuboid(incrX, incrY);\n                Refresh();\n            };\n\n            MouseDown += (s, e) =>\n            {\n                mouseX = e.X;\n                mouseY = e.Y;\n            };\n\n            Scale(80, 120, 160);\n            RotateCuboid(Math.PI / 5, Math.PI / 9);\n        }\n\n        private void RotateCuboid(double angleX, double angleY)\n        {\n            double sinX = Math.Sin(angleX);\n            double cosX = Math.Cos(angleX);\n\n            double sinY = Math.Sin(angleY);\n            double cosY = Math.Cos(angleY);\n\n            foreach (var node in nodes)\n            {\n                double x = node[0];\n                double y = node[1];\n                double z = node[2];\n\n                node[0] = x * cosX - z * sinX;\n                node[2] = z * cosX + x * sinX;\n\n                z = node[2];\n\n                node[1] = y * cosY - z * sinY;\n                node[2] = z * cosY + y * sinY;\n            }\n        }\n\n        private void Scale(int v1, int v2, int v3)\n        {\n            foreach (var item in nodes)\n            {\n                item[0] *= v1;\n                item[1] *= v2;\n                item[2] *= v3;\n            }\n        }\n\n        protected override void OnPaint(PaintEventArgs args)\n        {\n            var g = args.Graphics;\n            g.SmoothingMode = SmoothingMode.HighQuality;\n            g.Clear(Color.White);\n\n            g.TranslateTransform(Width / 2, Height / 2);\n\n            foreach (var edge in edges)\n            {\n                double[] xy1 = nodes[edge[0]];\n                double[] xy2 = nodes[edge[1]];\n                g.DrawLine(Pens.Black, (int)Math.Round(xy1[0]), (int)Math.Round(xy1[1]),\n                        (int)Math.Round(xy2[0]), (int)Math.Round(xy2[1]));\n            }\n\n            foreach (var node in nodes)\n            {\n                g.FillEllipse(Brushes.Black, (int)Math.Round(node[0]) - 4,\n                    (int)Math.Round(node[1]) - 4, 8, 8);\n            }\n        }\n    }\n}\n"}
{"id": 81836, "name": "Draw a cuboid", "source": "Translate Ruby to Java: X, Y, Z = 6, 2, 3\nDIR = {\"-\" => [1,0], \"|\" => [0,1], \"/\" => [1,1]}\n\ndef cuboid(nx, ny, nz)\n  puts \"cuboid %d %d %d:\" % [nx, ny, nz]\n  x, y, z = X*nx, Y*ny, Z*nz\n  area = Array.new(y+z+1){\" \" * (x+y+1)}\n  draw_line = lambda do |n, sx, sy, c|\n    dx, dy = DIR[c]\n    (n+1).times do |i|\n      xi, yi = sx+i*dx, sy+i*dy\n      area[yi][xi] = (area[yi][xi]==\" \" ? c : \"+\")\n    end\n  end\n  nz    .times {|i| draw_line[x,     0,   Z*i, \"-\"]}\n  (ny+1).times {|i| draw_line[x,   Y*i, z+Y*i, \"-\"]}\n  nx    .times {|i| draw_line[z,   X*i,     0, \"|\"]}\n  (ny+1).times {|i| draw_line[z, x+Y*i,   Y*i, \"|\"]}\n  nz    .times {|i| draw_line[y,     x,   Z*i, \"/\"]}\n  (nx+1).times {|i| draw_line[y,   X*i,     z, \"/\"]}\n  puts area.reverse\nend\n\ncuboid(2, 3, 4)\ncuboid(1, 1, 1)\ncuboid(6, 2, 1)\ncuboid(2, 4, 1)\n", "target": "import java.awt.*;\nimport java.awt.event.*;\nimport static java.lang.Math.*;\nimport javax.swing.*;\n\npublic class Cuboid extends JPanel {\n    double[][] nodes = {{-1, -1, -1}, {-1, -1, 1}, {-1, 1, -1}, {-1, 1, 1},\n    {1, -1, -1}, {1, -1, 1}, {1, 1, -1}, {1, 1, 1}};\n\n    int[][] edges = {{0, 1}, {1, 3}, {3, 2}, {2, 0}, {4, 5}, {5, 7}, {7, 6},\n    {6, 4}, {0, 4}, {1, 5}, {2, 6}, {3, 7}};\n\n    int mouseX, prevMouseX, mouseY, prevMouseY;\n\n    public Cuboid() {\n        setPreferredSize(new Dimension(640, 640));\n        setBackground(Color.white);\n\n        scale(80, 120, 160);\n        rotateCube(PI / 5, PI / 9);\n\n        addMouseListener(new MouseAdapter() {\n            @Override\n            public void mousePressed(MouseEvent e) {\n                mouseX = e.getX();\n                mouseY = e.getY();\n            }\n        });\n\n        addMouseMotionListener(new MouseAdapter() {\n            @Override\n            public void mouseDragged(MouseEvent e) {\n                prevMouseX = mouseX;\n                prevMouseY = mouseY;\n                mouseX = e.getX();\n                mouseY = e.getY();\n\n                double incrX = (mouseX - prevMouseX) * 0.01;\n                double incrY = (mouseY - prevMouseY) * 0.01;\n\n                rotateCube(incrX, incrY);\n                repaint();\n            }\n        });\n    }\n\n    private void scale(double sx, double sy, double sz) {\n        for (double[] node : nodes) {\n            node[0] *= sx;\n            node[1] *= sy;\n            node[2] *= sz;\n        }\n    }\n\n    private void rotateCube(double angleX, double angleY) {\n        double sinX = sin(angleX);\n        double cosX = cos(angleX);\n\n        double sinY = sin(angleY);\n        double cosY = cos(angleY);\n\n        for (double[] node : nodes) {\n            double x = node[0];\n            double y = node[1];\n            double z = node[2];\n\n            node[0] = x * cosX - z * sinX;\n            node[2] = z * cosX + x * sinX;\n\n            z = node[2];\n\n            node[1] = y * cosY - z * sinY;\n            node[2] = z * cosY + y * sinY;\n        }\n    }\n\n    void drawCube(Graphics2D g) {\n        g.translate(getWidth() / 2, getHeight() / 2);\n\n        for (int[] edge : edges) {\n            double[] xy1 = nodes[edge[0]];\n            double[] xy2 = nodes[edge[1]];\n            g.drawLine((int) round(xy1[0]), (int) round(xy1[1]),\n                    (int) round(xy2[0]), (int) round(xy2[1]));\n        }\n\n        for (double[] node : nodes) {\n            g.fillOval((int) round(node[0]) - 4, (int) round(node[1]) - 4, 8, 8);\n        }\n    }\n\n    @Override\n    public void paintComponent(Graphics gg) {\n        super.paintComponent(gg);\n        Graphics2D g = (Graphics2D) gg;\n        g.setRenderingHint(RenderingHints.KEY_ANTIALIASING,\n                RenderingHints.VALUE_ANTIALIAS_ON);\n\n        drawCube(g);\n    }\n\n    public static void main(String[] args) {\n        SwingUtilities.invokeLater(() -> {\n            JFrame f = new JFrame();\n            f.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n            f.setTitle(\"Cuboid\");\n            f.setResizable(false);\n            f.add(new Cuboid(), BorderLayout.CENTER);\n            f.pack();\n            f.setLocationRelativeTo(null);\n            f.setVisible(true);\n        });\n    }\n}\n"}
{"id": 81837, "name": "Draw a cuboid", "source": "Translate Ruby to Python: X, Y, Z = 6, 2, 3\nDIR = {\"-\" => [1,0], \"|\" => [0,1], \"/\" => [1,1]}\n\ndef cuboid(nx, ny, nz)\n  puts \"cuboid %d %d %d:\" % [nx, ny, nz]\n  x, y, z = X*nx, Y*ny, Z*nz\n  area = Array.new(y+z+1){\" \" * (x+y+1)}\n  draw_line = lambda do |n, sx, sy, c|\n    dx, dy = DIR[c]\n    (n+1).times do |i|\n      xi, yi = sx+i*dx, sy+i*dy\n      area[yi][xi] = (area[yi][xi]==\" \" ? c : \"+\")\n    end\n  end\n  nz    .times {|i| draw_line[x,     0,   Z*i, \"-\"]}\n  (ny+1).times {|i| draw_line[x,   Y*i, z+Y*i, \"-\"]}\n  nx    .times {|i| draw_line[z,   X*i,     0, \"|\"]}\n  (ny+1).times {|i| draw_line[z, x+Y*i,   Y*i, \"|\"]}\n  nz    .times {|i| draw_line[y,     x,   Z*i, \"/\"]}\n  (nx+1).times {|i| draw_line[y,   X*i,     z, \"/\"]}\n  puts area.reverse\nend\n\ncuboid(2, 3, 4)\ncuboid(1, 1, 1)\ncuboid(6, 2, 1)\ncuboid(2, 4, 1)\n", "target": "def _pr(t, x, y, z):\n    txt = '\\n'.join(''.join(t[(n,m)] for n in range(3+x+z)).rstrip()\n                    for m in reversed(range(3+y+z)))\n    return txt\n\t\t\ndef cuboid(x,y,z):\n    t = {(n,m):' ' for n in range(3+x+z) for m in range(3+y+z)}\n    xrow = ['+'] + ['%i' % (i % 10) for i in range(x)] + ['+']\n    for i,ch in enumerate(xrow):\n        t[(i,0)] = t[(i,1+y)] = t[(1+z+i,2+y+z)] = ch\n    if _debug: print(_pr(t, x, y, z))\n    ycol = ['+'] + ['%i' % (j % 10) for j in range(y)] + ['+']\n    for j,ch in enumerate(ycol):\n        t[(0,j)] = t[(x+1,j)] = t[(2+x+z,1+z+j)] = ch\n    zdepth = ['+'] + ['%i' % (k % 10) for k in range(z)] + ['+']\n    if _debug: print(_pr(t, x, y, z))\n    for k,ch in enumerate(zdepth):\n        t[(k,1+y+k)] = t[(1+x+k,1+y+k)] = t[(1+x+k,k)] = ch\n\t\n    return _pr(t, x, y, z)\n\n\n_debug = False\nif __name__ == '__main__':\n    for dim in ((2,3,4), (3,4,2), (4,2,3)):\n        print(\"CUBOID%r\" % (dim,), cuboid(*dim), sep='\\n')\n"}
{"id": 82093, "name": "Gaussian elimination", "source": "Translate Ruby to C#: require 'bigdecimal/ludcmp'\ninclude LUSolve\n\nBigDecimal::limit(30)\n\na = [1.00, 0.00, 0.00, 0.00, 0.00, 0.00,\n     1.00, 0.63, 0.39, 0.25, 0.16, 0.10,\n     1.00, 1.26, 1.58, 1.98, 2.49, 3.13,\n     1.00, 1.88, 3.55, 6.70, 12.62, 23.80,\n     1.00, 2.51, 6.32, 15.88, 39.90, 100.28,\n     1.00, 3.14, 9.87, 31.01, 97.41, 306.02].map{|i|BigDecimal(i,16)}\nb = [-0.01, 0.61, 0.91, 0.99, 0.60, 0.02].map{|i|BigDecimal(i,16)}\n\nn = 6\nzero = BigDecimal(\"0.0\")\none  = BigDecimal(\"1.0\")\n\nlusolve(a, b, ludecomp(a, n, zero,one), zero).each{|v| puts v.to_s('F')[0..20]}\n", "target": "using System;\n\nnamespace Rosetta\n{\n    internal class Vector\n    {\n        private double[] b;\n        internal readonly int rows;\n\n        internal Vector(int rows)\n        {\n            this.rows = rows;\n            b = new double[rows];\n        }\n\n        internal Vector(double[] initArray)\n        {\n            b = (double[])initArray.Clone();\n            rows = b.Length;\n        }\n\n        internal Vector Clone()\n        {\n            Vector v = new Vector(b);\n            return v;\n        }\n\n        internal double this[int row]\n        {\n            get { return b[row]; }\n            set { b[row] = value; }\n        }\n\n        internal void SwapRows(int r1, int r2)\n        {\n            if (r1 == r2) return;\n            double tmp = b[r1];\n            b[r1] = b[r2];\n            b[r2] = tmp;\n        }\n\n        internal double norm(double[] weights)\n        {\n            double sum = 0;\n            for (int i = 0; i < rows; i++)\n            {\n                double d = b[i] * weights[i];\n                sum +=  d*d;\n            }\n            return Math.Sqrt(sum);\n        }\n\n        internal void print()\n        {\n            for (int i = 0; i < rows; i++)\n                Console.WriteLine(b[i]);\n            Console.WriteLine();\n        }\n\n        public static Vector operator-(Vector lhs, Vector rhs)\n        {\n            Vector v = new Vector(lhs.rows);\n            for (int i = 0; i < lhs.rows; i++)\n                v[i] = lhs[i] - rhs[i];\n            return v;\n        }\n    }\n\n    class Matrix\n    {\n        private double[] b;\n        internal readonly int rows, cols;\n\n        internal Matrix(int rows, int cols)\n        {\n            this.rows = rows;\n            this.cols = cols;\n            b = new double[rows * cols];            \n        }\n\n        internal Matrix(int size)\n        {\n            this.rows = size;\n            this.cols = size;\n            b = new double[rows * cols];\n            for (int i = 0; i < size; i++)\n                this[i, i] = 1;\n        }\n\n        internal Matrix(int rows, int cols, double[] initArray)\n        {\n            this.rows = rows;\n            this.cols = cols;\n            b = (double[])initArray.Clone();\n            if (b.Length != rows * cols) throw new Exception(\"bad init array\");\n        }\n\n        internal double this[int row, int col]\n        {\n            get { return b[row * cols + col]; }\n            set { b[row * cols + col] = value; }\n        }        \n        \n        public static Vector operator*(Matrix lhs, Vector rhs)\n        {\n            if (lhs.cols != rhs.rows) throw new Exception(\"I can't multiply matrix by vector\");\n            Vector v = new Vector(lhs.rows);\n            for (int i = 0; i < lhs.rows; i++)\n            {\n                double sum = 0;\n                for (int j = 0; j < rhs.rows; j++)\n                    sum += lhs[i,j]*rhs[j];\n                v[i] = sum;\n            }\n            return v;\n        }\n\n        internal void SwapRows(int r1, int r2)\n        {\n            if (r1 == r2) return;\n            int firstR1 = r1 * cols;\n            int firstR2 = r2 * cols;\n            for (int i = 0; i < cols; i++)\n            {\n                double tmp = b[firstR1 + i];\n                b[firstR1 + i] = b[firstR2 + i];\n                b[firstR2 + i] = tmp;\n            }\n        }\n\n        \n        internal void ElimPartial(Vector B)\n        {\n            for (int diag = 0; diag < rows; diag++)\n            {\n                int max_row = diag;\n                double max_val = Math.Abs(this[diag, diag]);\n                double d;\n                for (int row = diag + 1; row < rows; row++)\n                    if ((d = Math.Abs(this[row, diag])) > max_val)\n                    {\n                        max_row = row;\n                        max_val = d;\n                    }\n                SwapRows(diag, max_row);\n                B.SwapRows(diag, max_row);\n                double invd = 1 / this[diag, diag];\n                for (int col = diag; col < cols; col++)\n                    this[diag, col] *= invd;\n                B[diag] *= invd;\n                for (int row = 0; row < rows; row++)\n                {\n                    d = this[row, diag];\n                    if (row != diag)\n                    {\n                        for (int col = diag; col < cols; col++)\n                            this[row, col] -= d * this[diag, col];\n                        B[row] -= d * B[diag];\n                    }\n                }\n            }\n        }\n        \n        internal void print()\n        {\n            for (int i = 0; i < rows; i++)\n            {\n                for (int j = 0; j < cols; j++)\n                    Console.Write(this[i,j].ToString()+\"  \");\n                Console.WriteLine();\n            }\n        }\n    }\n}\n"}
{"id": 82094, "name": "Gaussian elimination", "source": "Translate Ruby to C#: require 'bigdecimal/ludcmp'\ninclude LUSolve\n\nBigDecimal::limit(30)\n\na = [1.00, 0.00, 0.00, 0.00, 0.00, 0.00,\n     1.00, 0.63, 0.39, 0.25, 0.16, 0.10,\n     1.00, 1.26, 1.58, 1.98, 2.49, 3.13,\n     1.00, 1.88, 3.55, 6.70, 12.62, 23.80,\n     1.00, 2.51, 6.32, 15.88, 39.90, 100.28,\n     1.00, 3.14, 9.87, 31.01, 97.41, 306.02].map{|i|BigDecimal(i,16)}\nb = [-0.01, 0.61, 0.91, 0.99, 0.60, 0.02].map{|i|BigDecimal(i,16)}\n\nn = 6\nzero = BigDecimal(\"0.0\")\none  = BigDecimal(\"1.0\")\n\nlusolve(a, b, ludecomp(a, n, zero,one), zero).each{|v| puts v.to_s('F')[0..20]}\n", "target": "using System;\n\nnamespace Rosetta\n{\n    internal class Vector\n    {\n        private double[] b;\n        internal readonly int rows;\n\n        internal Vector(int rows)\n        {\n            this.rows = rows;\n            b = new double[rows];\n        }\n\n        internal Vector(double[] initArray)\n        {\n            b = (double[])initArray.Clone();\n            rows = b.Length;\n        }\n\n        internal Vector Clone()\n        {\n            Vector v = new Vector(b);\n            return v;\n        }\n\n        internal double this[int row]\n        {\n            get { return b[row]; }\n            set { b[row] = value; }\n        }\n\n        internal void SwapRows(int r1, int r2)\n        {\n            if (r1 == r2) return;\n            double tmp = b[r1];\n            b[r1] = b[r2];\n            b[r2] = tmp;\n        }\n\n        internal double norm(double[] weights)\n        {\n            double sum = 0;\n            for (int i = 0; i < rows; i++)\n            {\n                double d = b[i] * weights[i];\n                sum +=  d*d;\n            }\n            return Math.Sqrt(sum);\n        }\n\n        internal void print()\n        {\n            for (int i = 0; i < rows; i++)\n                Console.WriteLine(b[i]);\n            Console.WriteLine();\n        }\n\n        public static Vector operator-(Vector lhs, Vector rhs)\n        {\n            Vector v = new Vector(lhs.rows);\n            for (int i = 0; i < lhs.rows; i++)\n                v[i] = lhs[i] - rhs[i];\n            return v;\n        }\n    }\n\n    class Matrix\n    {\n        private double[] b;\n        internal readonly int rows, cols;\n\n        internal Matrix(int rows, int cols)\n        {\n            this.rows = rows;\n            this.cols = cols;\n            b = new double[rows * cols];            \n        }\n\n        internal Matrix(int size)\n        {\n            this.rows = size;\n            this.cols = size;\n            b = new double[rows * cols];\n            for (int i = 0; i < size; i++)\n                this[i, i] = 1;\n        }\n\n        internal Matrix(int rows, int cols, double[] initArray)\n        {\n            this.rows = rows;\n            this.cols = cols;\n            b = (double[])initArray.Clone();\n            if (b.Length != rows * cols) throw new Exception(\"bad init array\");\n        }\n\n        internal double this[int row, int col]\n        {\n            get { return b[row * cols + col]; }\n            set { b[row * cols + col] = value; }\n        }        \n        \n        public static Vector operator*(Matrix lhs, Vector rhs)\n        {\n            if (lhs.cols != rhs.rows) throw new Exception(\"I can't multiply matrix by vector\");\n            Vector v = new Vector(lhs.rows);\n            for (int i = 0; i < lhs.rows; i++)\n            {\n                double sum = 0;\n                for (int j = 0; j < rhs.rows; j++)\n                    sum += lhs[i,j]*rhs[j];\n                v[i] = sum;\n            }\n            return v;\n        }\n\n        internal void SwapRows(int r1, int r2)\n        {\n            if (r1 == r2) return;\n            int firstR1 = r1 * cols;\n            int firstR2 = r2 * cols;\n            for (int i = 0; i < cols; i++)\n            {\n                double tmp = b[firstR1 + i];\n                b[firstR1 + i] = b[firstR2 + i];\n                b[firstR2 + i] = tmp;\n            }\n        }\n\n        \n        internal void ElimPartial(Vector B)\n        {\n            for (int diag = 0; diag < rows; diag++)\n            {\n                int max_row = diag;\n                double max_val = Math.Abs(this[diag, diag]);\n                double d;\n                for (int row = diag + 1; row < rows; row++)\n                    if ((d = Math.Abs(this[row, diag])) > max_val)\n                    {\n                        max_row = row;\n                        max_val = d;\n                    }\n                SwapRows(diag, max_row);\n                B.SwapRows(diag, max_row);\n                double invd = 1 / this[diag, diag];\n                for (int col = diag; col < cols; col++)\n                    this[diag, col] *= invd;\n                B[diag] *= invd;\n                for (int row = 0; row < rows; row++)\n                {\n                    d = this[row, diag];\n                    if (row != diag)\n                    {\n                        for (int col = diag; col < cols; col++)\n                            this[row, col] -= d * this[diag, col];\n                        B[row] -= d * B[diag];\n                    }\n                }\n            }\n        }\n        \n        internal void print()\n        {\n            for (int i = 0; i < rows; i++)\n            {\n                for (int j = 0; j < cols; j++)\n                    Console.Write(this[i,j].ToString()+\"  \");\n                Console.WriteLine();\n            }\n        }\n    }\n}\n"}
{"id": 82097, "name": "Gaussian elimination", "source": "Translate Ruby to Java: require 'bigdecimal/ludcmp'\ninclude LUSolve\n\nBigDecimal::limit(30)\n\na = [1.00, 0.00, 0.00, 0.00, 0.00, 0.00,\n     1.00, 0.63, 0.39, 0.25, 0.16, 0.10,\n     1.00, 1.26, 1.58, 1.98, 2.49, 3.13,\n     1.00, 1.88, 3.55, 6.70, 12.62, 23.80,\n     1.00, 2.51, 6.32, 15.88, 39.90, 100.28,\n     1.00, 3.14, 9.87, 31.01, 97.41, 306.02].map{|i|BigDecimal(i,16)}\nb = [-0.01, 0.61, 0.91, 0.99, 0.60, 0.02].map{|i|BigDecimal(i,16)}\n\nn = 6\nzero = BigDecimal(\"0.0\")\none  = BigDecimal(\"1.0\")\n\nlusolve(a, b, ludecomp(a, n, zero,one), zero).each{|v| puts v.to_s('F')[0..20]}\n", "target": "import java.util.Locale;\n\npublic class GaussianElimination {\n    public static double solve(double[][] a, double[][] b) {\n        if (a == null || b == null || a.length == 0 || b.length == 0) {\n            throw new IllegalArgumentException(\"Invalid dimensions\");\n        }\n        \n        int n = b.length, p = b[0].length;\n        if (a.length != n || a[0].length != n) {\n            throw new IllegalArgumentException(\"Invalid dimensions\");\n        }\n\n        double det = 1.0;\n        \n        for (int i = 0; i < n - 1; i++) {\n            int k = i;\n            for (int j = i + 1; j < n; j++) {\n                if (Math.abs(a[j][i]) > Math.abs(a[k][i])) {\n                    k = j;\n                }\n            }\n            \n            if (k != i) {\n                det = -det;\n                \n                for (int j = i; j < n; j++) {\n                    double s = a[i][j];\n                    a[i][j] = a[k][j];\n                    a[k][j] = s;\n                }\n\n                for (int j = 0; j < p; j++) {\n                    double s = b[i][j];\n                    b[i][j] = b[k][j];\n                    b[k][j] = s;\n                }\n            }\n            \n            for (int j = i + 1; j < n; j++) {\n                double s = a[j][i] / a[i][i];\n                for (k = i + 1; k < n; k++) {\n                    a[j][k] -= s * a[i][k];\n                }\n                \n                for (k = 0; k < p; k++) {\n                    b[j][k] -= s * b[i][k];\n                }\n            }\n        }\n        \n        for (int i = n - 1; i >= 0; i--) {\n            for (int j = i + 1; j < n; j++) {\n                double s = a[i][j];\n                for (int k = 0; k < p; k++) {\n                    b[i][k] -= s * b[j][k];\n                }\n            }\n            double s = a[i][i];\n            det *= s;\n            for (int k = 0; k < p; k++) {\n                b[i][k] /= s;\n            }\n        }\n        \n        return det;\n    }\n    \n    public static void main(String[] args) {\n        double[][] a = new double[][] {{4.0, 1.0, 0.0, 0.0, 0.0},\n                                       {1.0, 4.0, 1.0, 0.0, 0.0},\n                                       {0.0, 1.0, 4.0, 1.0, 0.0},\n                                       {0.0, 0.0, 1.0, 4.0, 1.0},\n                                       {0.0, 0.0, 0.0, 1.0, 4.0}};\n\n        double[][] b = new double[][] {{1.0 / 2.0},\n                                       {2.0 / 3.0},\n                                       {3.0 / 4.0},\n                                       {4.0 / 5.0},\n                                       {5.0 / 6.0}};\n                                       \n        double[] x = {39.0 / 400.0,\n                      11.0 / 100.0,\n                      31.0 / 240.0,\n                      37.0 / 300.0,\n                      71.0 / 400.0};\n                                       \n        System.out.println(\"det: \" + solve(a, b));\n        \n\n        for (int i = 0; i < 5; i++) {\n            System.out.printf(Locale.US, \"%12.8f %12.4e\\n\", b[i][0], b[i][0] - x[i]);\n        }\n    }\n}\n"}
{"id": 82098, "name": "Gaussian elimination", "source": "Translate Ruby to Java: require 'bigdecimal/ludcmp'\ninclude LUSolve\n\nBigDecimal::limit(30)\n\na = [1.00, 0.00, 0.00, 0.00, 0.00, 0.00,\n     1.00, 0.63, 0.39, 0.25, 0.16, 0.10,\n     1.00, 1.26, 1.58, 1.98, 2.49, 3.13,\n     1.00, 1.88, 3.55, 6.70, 12.62, 23.80,\n     1.00, 2.51, 6.32, 15.88, 39.90, 100.28,\n     1.00, 3.14, 9.87, 31.01, 97.41, 306.02].map{|i|BigDecimal(i,16)}\nb = [-0.01, 0.61, 0.91, 0.99, 0.60, 0.02].map{|i|BigDecimal(i,16)}\n\nn = 6\nzero = BigDecimal(\"0.0\")\none  = BigDecimal(\"1.0\")\n\nlusolve(a, b, ludecomp(a, n, zero,one), zero).each{|v| puts v.to_s('F')[0..20]}\n", "target": "import java.util.Locale;\n\npublic class GaussianElimination {\n    public static double solve(double[][] a, double[][] b) {\n        if (a == null || b == null || a.length == 0 || b.length == 0) {\n            throw new IllegalArgumentException(\"Invalid dimensions\");\n        }\n        \n        int n = b.length, p = b[0].length;\n        if (a.length != n || a[0].length != n) {\n            throw new IllegalArgumentException(\"Invalid dimensions\");\n        }\n\n        double det = 1.0;\n        \n        for (int i = 0; i < n - 1; i++) {\n            int k = i;\n            for (int j = i + 1; j < n; j++) {\n                if (Math.abs(a[j][i]) > Math.abs(a[k][i])) {\n                    k = j;\n                }\n            }\n            \n            if (k != i) {\n                det = -det;\n                \n                for (int j = i; j < n; j++) {\n                    double s = a[i][j];\n                    a[i][j] = a[k][j];\n                    a[k][j] = s;\n                }\n\n                for (int j = 0; j < p; j++) {\n                    double s = b[i][j];\n                    b[i][j] = b[k][j];\n                    b[k][j] = s;\n                }\n            }\n            \n            for (int j = i + 1; j < n; j++) {\n                double s = a[j][i] / a[i][i];\n                for (k = i + 1; k < n; k++) {\n                    a[j][k] -= s * a[i][k];\n                }\n                \n                for (k = 0; k < p; k++) {\n                    b[j][k] -= s * b[i][k];\n                }\n            }\n        }\n        \n        for (int i = n - 1; i >= 0; i--) {\n            for (int j = i + 1; j < n; j++) {\n                double s = a[i][j];\n                for (int k = 0; k < p; k++) {\n                    b[i][k] -= s * b[j][k];\n                }\n            }\n            double s = a[i][i];\n            det *= s;\n            for (int k = 0; k < p; k++) {\n                b[i][k] /= s;\n            }\n        }\n        \n        return det;\n    }\n    \n    public static void main(String[] args) {\n        double[][] a = new double[][] {{4.0, 1.0, 0.0, 0.0, 0.0},\n                                       {1.0, 4.0, 1.0, 0.0, 0.0},\n                                       {0.0, 1.0, 4.0, 1.0, 0.0},\n                                       {0.0, 0.0, 1.0, 4.0, 1.0},\n                                       {0.0, 0.0, 0.0, 1.0, 4.0}};\n\n        double[][] b = new double[][] {{1.0 / 2.0},\n                                       {2.0 / 3.0},\n                                       {3.0 / 4.0},\n                                       {4.0 / 5.0},\n                                       {5.0 / 6.0}};\n                                       \n        double[] x = {39.0 / 400.0,\n                      11.0 / 100.0,\n                      31.0 / 240.0,\n                      37.0 / 300.0,\n                      71.0 / 400.0};\n                                       \n        System.out.println(\"det: \" + solve(a, b));\n        \n\n        for (int i = 0; i < 5; i++) {\n            System.out.printf(Locale.US, \"%12.8f %12.4e\\n\", b[i][0], b[i][0] - x[i]);\n        }\n    }\n}\n"}
{"id": 82099, "name": "Gaussian elimination", "source": "Translate Ruby to Python: require 'bigdecimal/ludcmp'\ninclude LUSolve\n\nBigDecimal::limit(30)\n\na = [1.00, 0.00, 0.00, 0.00, 0.00, 0.00,\n     1.00, 0.63, 0.39, 0.25, 0.16, 0.10,\n     1.00, 1.26, 1.58, 1.98, 2.49, 3.13,\n     1.00, 1.88, 3.55, 6.70, 12.62, 23.80,\n     1.00, 2.51, 6.32, 15.88, 39.90, 100.28,\n     1.00, 3.14, 9.87, 31.01, 97.41, 306.02].map{|i|BigDecimal(i,16)}\nb = [-0.01, 0.61, 0.91, 0.99, 0.60, 0.02].map{|i|BigDecimal(i,16)}\n\nn = 6\nzero = BigDecimal(\"0.0\")\none  = BigDecimal(\"1.0\")\n\nlusolve(a, b, ludecomp(a, n, zero,one), zero).each{|v| puts v.to_s('F')[0..20]}\n", "target": "\n\n\nimport copy\nfrom fractions import Fraction\n\ndef gauss(a, b):\n    a = copy.deepcopy(a)\n    b = copy.deepcopy(b)\n    n = len(a)\n    p = len(b[0])\n    det = 1\n    for i in range(n - 1):\n        k = i\n        for j in range(i + 1, n):\n            if abs(a[j][i]) > abs(a[k][i]):\n                k = j\n        if k != i:\n            a[i], a[k] = a[k], a[i]\n            b[i], b[k] = b[k], b[i]\n            det = -det\n            \n        for j in range(i + 1, n):\n            t = a[j][i]/a[i][i]\n            for k in range(i + 1, n):\n                a[j][k] -= t*a[i][k]\n            for k in range(p):\n                b[j][k] -= t*b[i][k]\n                \n    for i in range(n - 1, -1, -1):\n        for j in range(i + 1, n):\n            t = a[i][j]\n            for k in range(p):\n                b[i][k] -= t*b[j][k]\n        t = 1/a[i][i]\n        det *= a[i][i]\n        for j in range(p):\n            b[i][j] *= t\n    return det, b\n\ndef zeromat(p, q):\n    return [[0]*q for i in range(p)]\n\ndef matmul(a, b):\n    n, p = len(a), len(a[0])\n    p1, q = len(b), len(b[0])\n    if p != p1:\n        raise ValueError(\"Incompatible dimensions\")\n    c = zeromat(n, q)\n    for i in range(n):\n        for j in range(q):\n                c[i][j] = sum(a[i][k]*b[k][j] for k in range(p))\n    return c\n\n\ndef mapmat(f, a):\n    return [list(map(f, v)) for v in a]\n\ndef ratmat(a):\n    return mapmat(Fraction, a)\n\n\n\na = [[2, 9, 4], [7, 5, 3], [6, 1, 8]]\nb = [[1, 0, 0], [0, 1, 0], [0, 0, 1]]\ndet, c = gauss(a, b)\n\ndet\n-360.0\n\nc\n[[-0.10277777777777776, 0.18888888888888888, -0.019444444444444438],\n[0.10555555555555554, 0.02222222222222223, -0.061111111111111116],\n[0.0638888888888889, -0.14444444444444446, 0.14722222222222223]]\n\n\nmatmul(a, c)\n[[1.0, 0.0, 0.0], [5.551115123125783e-17, 1.0, 0.0],\n[1.1102230246251565e-16, -2.220446049250313e-16, 1.0]]\n\n\n\ndet, c = gauss(ratmat(a), ratmat(b))\n\ndet\nFraction(-360, 1)\n\nc\n[[Fraction(-37, 360), Fraction(17, 90), Fraction(-7, 360)],\n[Fraction(19, 180), Fraction(1, 45), Fraction(-11, 180)],\n[Fraction(23, 360), Fraction(-13, 90), Fraction(53, 360)]]\n\nmatmul(a, c)\n[[Fraction(1, 1), Fraction(0, 1), Fraction(0, 1)],\n[Fraction(0, 1), Fraction(1, 1), Fraction(0, 1)],\n[Fraction(0, 1), Fraction(0, 1), Fraction(1, 1)]]\n"}
{"id": 82100, "name": "Gaussian elimination", "source": "Translate Ruby to Python: require 'bigdecimal/ludcmp'\ninclude LUSolve\n\nBigDecimal::limit(30)\n\na = [1.00, 0.00, 0.00, 0.00, 0.00, 0.00,\n     1.00, 0.63, 0.39, 0.25, 0.16, 0.10,\n     1.00, 1.26, 1.58, 1.98, 2.49, 3.13,\n     1.00, 1.88, 3.55, 6.70, 12.62, 23.80,\n     1.00, 2.51, 6.32, 15.88, 39.90, 100.28,\n     1.00, 3.14, 9.87, 31.01, 97.41, 306.02].map{|i|BigDecimal(i,16)}\nb = [-0.01, 0.61, 0.91, 0.99, 0.60, 0.02].map{|i|BigDecimal(i,16)}\n\nn = 6\nzero = BigDecimal(\"0.0\")\none  = BigDecimal(\"1.0\")\n\nlusolve(a, b, ludecomp(a, n, zero,one), zero).each{|v| puts v.to_s('F')[0..20]}\n", "target": "\n\n\nimport copy\nfrom fractions import Fraction\n\ndef gauss(a, b):\n    a = copy.deepcopy(a)\n    b = copy.deepcopy(b)\n    n = len(a)\n    p = len(b[0])\n    det = 1\n    for i in range(n - 1):\n        k = i\n        for j in range(i + 1, n):\n            if abs(a[j][i]) > abs(a[k][i]):\n                k = j\n        if k != i:\n            a[i], a[k] = a[k], a[i]\n            b[i], b[k] = b[k], b[i]\n            det = -det\n            \n        for j in range(i + 1, n):\n            t = a[j][i]/a[i][i]\n            for k in range(i + 1, n):\n                a[j][k] -= t*a[i][k]\n            for k in range(p):\n                b[j][k] -= t*b[i][k]\n                \n    for i in range(n - 1, -1, -1):\n        for j in range(i + 1, n):\n            t = a[i][j]\n            for k in range(p):\n                b[i][k] -= t*b[j][k]\n        t = 1/a[i][i]\n        det *= a[i][i]\n        for j in range(p):\n            b[i][j] *= t\n    return det, b\n\ndef zeromat(p, q):\n    return [[0]*q for i in range(p)]\n\ndef matmul(a, b):\n    n, p = len(a), len(a[0])\n    p1, q = len(b), len(b[0])\n    if p != p1:\n        raise ValueError(\"Incompatible dimensions\")\n    c = zeromat(n, q)\n    for i in range(n):\n        for j in range(q):\n                c[i][j] = sum(a[i][k]*b[k][j] for k in range(p))\n    return c\n\n\ndef mapmat(f, a):\n    return [list(map(f, v)) for v in a]\n\ndef ratmat(a):\n    return mapmat(Fraction, a)\n\n\n\na = [[2, 9, 4], [7, 5, 3], [6, 1, 8]]\nb = [[1, 0, 0], [0, 1, 0], [0, 0, 1]]\ndet, c = gauss(a, b)\n\ndet\n-360.0\n\nc\n[[-0.10277777777777776, 0.18888888888888888, -0.019444444444444438],\n[0.10555555555555554, 0.02222222222222223, -0.061111111111111116],\n[0.0638888888888889, -0.14444444444444446, 0.14722222222222223]]\n\n\nmatmul(a, c)\n[[1.0, 0.0, 0.0], [5.551115123125783e-17, 1.0, 0.0],\n[1.1102230246251565e-16, -2.220446049250313e-16, 1.0]]\n\n\n\ndet, c = gauss(ratmat(a), ratmat(b))\n\ndet\nFraction(-360, 1)\n\nc\n[[Fraction(-37, 360), Fraction(17, 90), Fraction(-7, 360)],\n[Fraction(19, 180), Fraction(1, 45), Fraction(-11, 180)],\n[Fraction(23, 360), Fraction(-13, 90), Fraction(53, 360)]]\n\nmatmul(a, c)\n[[Fraction(1, 1), Fraction(0, 1), Fraction(0, 1)],\n[Fraction(0, 1), Fraction(1, 1), Fraction(0, 1)],\n[Fraction(0, 1), Fraction(0, 1), Fraction(1, 1)]]\n"}
{"id": 82371, "name": "General FizzBuzz", "source": "Translate Ruby to C#: def general_fizzbuzz(text)\n  num, *nword = text.split\n  num = num.to_i\n  dict = nword.each_slice(2).map{|n,word| [n.to_i,word]}\n  (1..num).each do |i|\n    str = dict.map{|n,word| word if i%n==0}.join\n    puts str.empty? ? i : str\n  end\nend\n\ntext = <<EOS\n20\n3 Fizz\n5 Buzz\n7 Baxx\nEOS\n\ngeneral_fizzbuzz(text)\n", "target": "using System;\n\npublic class GeneralFizzBuzz\n{\n    public static void Main() \n    {\n        int i;\n        int j;\n        int k;\n        \n        int limit;\n        \n        string iString;\n        string jString;\n        string kString;\n\n        Console.WriteLine(\"First integer:\");\n        i = Convert.ToInt32(Console.ReadLine());\n        Console.WriteLine(\"First string:\");\n        iString = Console.ReadLine();\n\n        Console.WriteLine(\"Second integer:\");\n        j = Convert.ToInt32(Console.ReadLine());\n        Console.WriteLine(\"Second string:\");\n        jString = Console.ReadLine();\n\n        Console.WriteLine(\"Third integer:\");\n        k = Convert.ToInt32(Console.ReadLine());\n        Console.WriteLine(\"Third string:\");\n        kString = Console.ReadLine();\n\n        Console.WriteLine(\"Limit (inclusive):\");\n        limit = Convert.ToInt32(Console.ReadLine());\n\n        for(int n = 1; n<= limit; n++)\n        {\n            bool flag = true;\n            if(n%i == 0)\n            {\n                Console.Write(iString);\n                flag = false;\n            }\n\n            if(n%j == 0)\n            {\n                Console.Write(jString);\n                flag = false;\n            }\n\n            if(n%k == 0)\n            {\n                Console.Write(kString);\n                flag = false;\n            }\n            if(flag)\n                Console.Write(n);\n            Console.WriteLine();\n        }\n    }\n}\n"}
{"id": 82373, "name": "General FizzBuzz", "source": "Translate Ruby to Java: def general_fizzbuzz(text)\n  num, *nword = text.split\n  num = num.to_i\n  dict = nword.each_slice(2).map{|n,word| [n.to_i,word]}\n  (1..num).each do |i|\n    str = dict.map{|n,word| word if i%n==0}.join\n    puts str.empty? ? i : str\n  end\nend\n\ntext = <<EOS\n20\n3 Fizz\n5 Buzz\n7 Baxx\nEOS\n\ngeneral_fizzbuzz(text)\n", "target": "public class FizzBuzz {\n\n    public static void main(String[] args) {\n        Sound[] sounds = {new Sound(3, \"Fizz\"), new Sound(5, \"Buzz\"),  new Sound(7, \"Baxx\")};\n        for (int i = 1; i <= 20; i++) {\n            StringBuilder sb = new StringBuilder();\n            for (Sound sound : sounds) {\n                sb.append(sound.generate(i));\n            }\n            System.out.println(sb.length() == 0 ? i : sb.toString());\n        }\n    }\n\n    private static class Sound {\n        private final int trigger;\n        private final String onomatopoeia;\n\n        public Sound(int trigger, String onomatopoeia) {\n            this.trigger = trigger;\n            this.onomatopoeia = onomatopoeia;\n        }\n\n        public String generate(int i) {\n            return i % trigger == 0 ? onomatopoeia : \"\";\n        }\n\n    }\n\n}\n"}
{"id": 82374, "name": "General FizzBuzz", "source": "Translate Ruby to Python: def general_fizzbuzz(text)\n  num, *nword = text.split\n  num = num.to_i\n  dict = nword.each_slice(2).map{|n,word| [n.to_i,word]}\n  (1..num).each do |i|\n    str = dict.map{|n,word| word if i%n==0}.join\n    puts str.empty? ? i : str\n  end\nend\n\ntext = <<EOS\n20\n3 Fizz\n5 Buzz\n7 Baxx\nEOS\n\ngeneral_fizzbuzz(text)\n", "target": "def genfizzbuzz(factorwords, numbers):\n    \n    factorwords.sort(key=lambda factor_and_word: factor_and_word[0])\n    lines = []\n    for num in numbers:\n        words = ''.join(word for factor, word in factorwords if (num % factor) == 0)\n        lines.append(words if words else str(num))\n    return '\\n'.join(lines)\n\nif __name__ == '__main__':\n    print(genfizzbuzz([(5, 'Buzz'), (3, 'Fizz'), (7, 'Baxx')], range(1, 21)))\n"}
{"id": 82843, "name": "Averages_Pythagorean means", "source": "Translate Ruby to C#: class Array\n  def arithmetic_mean\n    inject(0.0, :+) / length\n  end\n  \n  def geometric_mean\n    inject(:*) ** (1.0 / length)\n  end\n  \n  def harmonic_mean\n    length / inject(0.0) {|s, m| s + 1.0/m}\n  end\nend\n\nclass Range\n  def method_missing(m, *args)\n    case m\n    when /_mean$/ then to_a.send(m)\n    else super\n    end\n  end\nend\n\np a = (1..10).arithmetic_mean\np g = (1..10).geometric_mean\np h = (1..10).harmonic_mean\n\np g.between?(h, a)\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\nusing System.Linq;\n\nnamespace PythMean\n{\n    static class Program\n    {\n        static void Main(string[] args) {\n            var nums = from n in Enumerable.Range(1, 10) select (double)n;\n\n            var a = nums.Average();\n            var g = nums.Gmean();\n            var h = nums.Hmean();\n\n            Console.WriteLine(\"Arithmetic mean {0}\", a);\n            Console.WriteLine(\"Geometric mean  {0}\", g);\n            Console.WriteLine(\"Harmonic mean   {0}\", h);\n\n            Debug.Assert(a >= g && g >= h);\n        }\n\n        \n        static double Gmean(this IEnumerable<double> n) {\n            return Math.Pow(n.Aggregate((s, i) => s * i), 1.0 / n.Count());\n        }\n\n        \n        static double Hmean(this IEnumerable<double> n) {\n            return n.Count() / n.Sum(i => 1.0 / i);\n        }\n    }\n}\n"}
{"id": 82844, "name": "Averages_Pythagorean means", "source": "Translate Ruby to C#: class Array\n  def arithmetic_mean\n    inject(0.0, :+) / length\n  end\n  \n  def geometric_mean\n    inject(:*) ** (1.0 / length)\n  end\n  \n  def harmonic_mean\n    length / inject(0.0) {|s, m| s + 1.0/m}\n  end\nend\n\nclass Range\n  def method_missing(m, *args)\n    case m\n    when /_mean$/ then to_a.send(m)\n    else super\n    end\n  end\nend\n\np a = (1..10).arithmetic_mean\np g = (1..10).geometric_mean\np h = (1..10).harmonic_mean\n\np g.between?(h, a)\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\nusing System.Linq;\n\nnamespace PythMean\n{\n    static class Program\n    {\n        static void Main(string[] args) {\n            var nums = from n in Enumerable.Range(1, 10) select (double)n;\n\n            var a = nums.Average();\n            var g = nums.Gmean();\n            var h = nums.Hmean();\n\n            Console.WriteLine(\"Arithmetic mean {0}\", a);\n            Console.WriteLine(\"Geometric mean  {0}\", g);\n            Console.WriteLine(\"Harmonic mean   {0}\", h);\n\n            Debug.Assert(a >= g && g >= h);\n        }\n\n        \n        static double Gmean(this IEnumerable<double> n) {\n            return Math.Pow(n.Aggregate((s, i) => s * i), 1.0 / n.Count());\n        }\n\n        \n        static double Hmean(this IEnumerable<double> n) {\n            return n.Count() / n.Sum(i => 1.0 / i);\n        }\n    }\n}\n"}
{"id": 82847, "name": "Averages_Pythagorean means", "source": "Translate Ruby to Java: class Array\n  def arithmetic_mean\n    inject(0.0, :+) / length\n  end\n  \n  def geometric_mean\n    inject(:*) ** (1.0 / length)\n  end\n  \n  def harmonic_mean\n    length / inject(0.0) {|s, m| s + 1.0/m}\n  end\nend\n\nclass Range\n  def method_missing(m, *args)\n    case m\n    when /_mean$/ then to_a.send(m)\n    else super\n    end\n  end\nend\n\np a = (1..10).arithmetic_mean\np g = (1..10).geometric_mean\np h = (1..10).harmonic_mean\n\np g.between?(h, a)\n", "target": "import java.util.Arrays;\nimport java.util.List;\n\npublic class PythagoreanMeans {\n    public static double arithmeticMean(List<Double> numbers) {\n        if (numbers.isEmpty()) return Double.NaN;\n        double mean = 0.0;\n        for (Double number : numbers) {\n            mean += number;\n        }\n        return mean / numbers.size();\n    }\n\n    public static double geometricMean(List<Double> numbers) {\n        if (numbers.isEmpty()) return Double.NaN;\n        double mean = 1.0;\n        for (Double number : numbers) {\n            mean *= number;\n        }\n        return Math.pow(mean, 1.0 / numbers.size());\n    }\n\n    public static double harmonicMean(List<Double> numbers) {\n        if (numbers.isEmpty() || numbers.contains(0.0)) return Double.NaN;\n        double mean = 0.0;\n        for (Double number : numbers) {\n            mean += (1.0 / number);\n        }\n        return numbers.size() / mean;\n    }\n\n    public static void main(String[] args) {\n        Double[] array = {1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0};\n        List<Double> list = Arrays.asList(array);\n        double arithmetic = arithmeticMean(list);\n        double geometric = geometricMean(list);\n        double harmonic = harmonicMean(list);\n        System.out.format(\"A = %f  G = %f  H = %f%n\", arithmetic, geometric, harmonic);\n        System.out.format(\"A >= G is %b, G >= H is %b%n\", (arithmetic >= geometric), (geometric >= harmonic));\n    }\n}\n"}
{"id": 82848, "name": "Averages_Pythagorean means", "source": "Translate Ruby to Java: class Array\n  def arithmetic_mean\n    inject(0.0, :+) / length\n  end\n  \n  def geometric_mean\n    inject(:*) ** (1.0 / length)\n  end\n  \n  def harmonic_mean\n    length / inject(0.0) {|s, m| s + 1.0/m}\n  end\nend\n\nclass Range\n  def method_missing(m, *args)\n    case m\n    when /_mean$/ then to_a.send(m)\n    else super\n    end\n  end\nend\n\np a = (1..10).arithmetic_mean\np g = (1..10).geometric_mean\np h = (1..10).harmonic_mean\n\np g.between?(h, a)\n", "target": "import java.util.Arrays;\nimport java.util.List;\n\npublic class PythagoreanMeans {\n    public static double arithmeticMean(List<Double> numbers) {\n        if (numbers.isEmpty()) return Double.NaN;\n        double mean = 0.0;\n        for (Double number : numbers) {\n            mean += number;\n        }\n        return mean / numbers.size();\n    }\n\n    public static double geometricMean(List<Double> numbers) {\n        if (numbers.isEmpty()) return Double.NaN;\n        double mean = 1.0;\n        for (Double number : numbers) {\n            mean *= number;\n        }\n        return Math.pow(mean, 1.0 / numbers.size());\n    }\n\n    public static double harmonicMean(List<Double> numbers) {\n        if (numbers.isEmpty() || numbers.contains(0.0)) return Double.NaN;\n        double mean = 0.0;\n        for (Double number : numbers) {\n            mean += (1.0 / number);\n        }\n        return numbers.size() / mean;\n    }\n\n    public static void main(String[] args) {\n        Double[] array = {1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0};\n        List<Double> list = Arrays.asList(array);\n        double arithmetic = arithmeticMean(list);\n        double geometric = geometricMean(list);\n        double harmonic = harmonicMean(list);\n        System.out.format(\"A = %f  G = %f  H = %f%n\", arithmetic, geometric, harmonic);\n        System.out.format(\"A >= G is %b, G >= H is %b%n\", (arithmetic >= geometric), (geometric >= harmonic));\n    }\n}\n"}
{"id": 82849, "name": "Averages_Pythagorean means", "source": "Translate Ruby to Python: class Array\n  def arithmetic_mean\n    inject(0.0, :+) / length\n  end\n  \n  def geometric_mean\n    inject(:*) ** (1.0 / length)\n  end\n  \n  def harmonic_mean\n    length / inject(0.0) {|s, m| s + 1.0/m}\n  end\nend\n\nclass Range\n  def method_missing(m, *args)\n    case m\n    when /_mean$/ then to_a.send(m)\n    else super\n    end\n  end\nend\n\np a = (1..10).arithmetic_mean\np g = (1..10).geometric_mean\np h = (1..10).harmonic_mean\n\np g.between?(h, a)\n", "target": "from operator import mul\nfrom functools import reduce\n\n\ndef amean(num):\n    return sum(num) / len(num)\n\n\ndef gmean(num):\n    return reduce(mul, num, 1)**(1 / len(num))\n\n\ndef hmean(num):\n    return len(num) / sum(1 / n for n in num)\n\n\nnumbers = range(1, 11)  \na, g, h = amean(numbers), gmean(numbers), hmean(numbers)\nprint(a, g, h)\nassert a >= g >= h\n"}
{"id": 82850, "name": "Averages_Pythagorean means", "source": "Translate Ruby to Python: class Array\n  def arithmetic_mean\n    inject(0.0, :+) / length\n  end\n  \n  def geometric_mean\n    inject(:*) ** (1.0 / length)\n  end\n  \n  def harmonic_mean\n    length / inject(0.0) {|s, m| s + 1.0/m}\n  end\nend\n\nclass Range\n  def method_missing(m, *args)\n    case m\n    when /_mean$/ then to_a.send(m)\n    else super\n    end\n  end\nend\n\np a = (1..10).arithmetic_mean\np g = (1..10).geometric_mean\np h = (1..10).harmonic_mean\n\np g.between?(h, a)\n", "target": "from operator import mul\nfrom functools import reduce\n\n\ndef amean(num):\n    return sum(num) / len(num)\n\n\ndef gmean(num):\n    return reduce(mul, num, 1)**(1 / len(num))\n\n\ndef hmean(num):\n    return len(num) / sum(1 / n for n in num)\n\n\nnumbers = range(1, 11)  \na, g, h = amean(numbers), gmean(numbers), hmean(numbers)\nprint(a, g, h)\nassert a >= g >= h\n"}
{"id": 83049, "name": "Wieferich primes", "source": "Translate Ruby to C#: require \"prime\"\n\nputs Prime.each(5000).select{|p| 2.pow(p-1 ,p*p) == 1 }\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\nnamespace WieferichPrimes {\n    class Program {\n        static long ModPow(long @base, long exp, long mod) {\n            if (mod == 1) {\n                return 0;\n            }\n\n            long result = 1;\n            @base %= mod;\n            for (; exp > 0; exp >>= 1) {\n                if ((exp & 1) == 1) {\n                    result = (result * @base) % mod;\n                }\n                @base = (@base * @base) % mod;\n            }\n            return result;\n        }\n\n        static bool[] PrimeSieve(int limit) {\n            bool[] sieve = Enumerable.Repeat(true, limit).ToArray();\n\n            if (limit > 0) {\n                sieve[0] = false;\n            }\n            if (limit > 1) {\n                sieve[1] = false;\n            }\n\n            for (int i = 4; i < limit; i += 2) {\n                sieve[i] = false;\n            }\n\n            for (int p = 3; ; p += 2) {\n                int q = p * p;\n                if (q >= limit) {\n                    break;\n                }\n                if (sieve[p]) {\n                    int inc = 2 * p;\n                    for (; q < limit; q += inc) {\n                        sieve[q] = false;\n                    }\n                }\n            }\n\n            return sieve;\n        }\n\n        static List<int> WiefreichPrimes(int limit) {\n            bool[] sieve = PrimeSieve(limit);\n            List<int> result = new List<int>();\n            for (int p = 2; p < limit; p++) {\n                if (sieve[p] && ModPow(2, p - 1, p * p) == 1) {\n                    result.Add(p);\n                }\n            }\n            return result;\n        }\n\n        static void Main() {\n            const int limit = 5000;\n            Console.WriteLine(\"Wieferich primes less that {0}:\", limit);\n            foreach (int p in WiefreichPrimes(limit)) {\n                Console.WriteLine(p);\n            }\n        }\n    }\n}\n"}
{"id": 83051, "name": "Wieferich primes", "source": "Translate Ruby to Java: require \"prime\"\n\nputs Prime.each(5000).select{|p| 2.pow(p-1 ,p*p) == 1 }\n", "target": "import java.util.*;\n\npublic class WieferichPrimes {\n    public static void main(String[] args) {\n        final int limit = 5000;\n        System.out.printf(\"Wieferich primes less than %d:\\n\", limit);\n        for (Integer p : wieferichPrimes(limit))\n            System.out.println(p);\n    }    \n\n    private static boolean[] primeSieve(int limit) {\n        boolean[] sieve = new boolean[limit];\n        Arrays.fill(sieve, true);\n        if (limit > 0)\n            sieve[0] = false;\n        if (limit > 1)\n            sieve[1] = false;\n        for (int i = 4; i < limit; i += 2)\n            sieve[i] = false;\n        for (int p = 3; ; p += 2) {\n            int q = p * p;\n            if (q >= limit)\n                break;\n            if (sieve[p]) {\n                int inc = 2 * p;\n                for (; q < limit; q += inc)\n                    sieve[q] = false;\n            }\n        }\n        return sieve;\n    }\n\n    private static long modpow(long base, long exp, long mod) {\n        if (mod == 1)\n            return 0;\n        long result = 1;\n        base %= mod;\n        for (; exp > 0; exp >>= 1) {\n            if ((exp & 1) == 1)\n                result = (result * base) % mod;\n            base = (base * base) % mod;\n        }\n        return result;\n    }\n\n    private static List<Integer> wieferichPrimes(int limit) {\n        boolean[] sieve = primeSieve(limit);\n        List<Integer> result = new ArrayList<>();\n        for (int p = 2; p < limit; ++p) {\n            if (sieve[p] && modpow(2, p - 1, p * p) == 1)\n                result.add(p);\n        }\n        return result;\n    }\n}\n"}
{"id": 83052, "name": "Wieferich primes", "source": "Translate Ruby to Python: require \"prime\"\n\nputs Prime.each(5000).select{|p| 2.pow(p-1 ,p*p) == 1 }\n", "target": "\n\ndef isPrime(n):\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return False        \n    return True\n\ndef isWeiferich(p):\n    if not isPrime(p):\n        return False\n    q = 1\n    p2 = p ** 2\n    while p > 1:\n        q = (2 * q) % p2\n        p -= 1\n    if q == 1:\n        return True\n    else:\n        return False\n\n\nif __name__ == '__main__':\n    print(\"Wieferich primes less than 5000: \")\n    for i in range(2, 5001):\n        if isWeiferich(i):\n            print(i)\n"}
{"id": 83220, "name": "AKS test for primes", "source": "Translate Ruby to C#: def x_minus_1_to_the(p)\n  p.times.reduce([1]) do |ex, _|\n    ([0_i64] + ex).zip(ex + [0]).map { |x, y| x - y }\n  end\nend\n \ndef prime?(p)\n  return false if p < 2\n  coeff = x_minus_1_to_the(p)[1..p//2] \n  coeff.all?{ |n| n%p == 0 }\nend\n\n8.times do |n|\n  puts \"(x-1)^\n  x_minus_1_to_the(n).map_with_index{ |c, p|\n    p.zero? ? c.to_s : (c < 0 ? \" - \" : \" + \") + (c.abs == 1 ? \"x\" : \"\n  }.join\nend\n\nputs \"\\nPrimes below 50:\", 50.times.select { |n| prime? n }.join(',')\n", "target": "using System;\n    public class AksTest\n    {\n        static long[] c = new long[100];\n\n        static void Main(string[] args)\n        {\n        for (int n = 0; n < 10; n++) {\n\t\tcoef(n);\n\t\tConsole.Write(\"(x-1)^\" + n + \" = \");\n\t\tshow(n);\n\t\tConsole.WriteLine(\"\");\n\t}\t \n\t   Console.Write(\"Primes:\");\n\t  for (int n = 1; n <= 63; n++)\n\t     if (is_prime(n))\n\t       Console.Write(n + \" \");\n\t \n\t    Console.WriteLine('\\n');\n            Console.ReadLine();\n        }\n\n        static void coef(int n)\n        {\n            int i, j;\n\n            if (n < 0 || n > 63) System.Environment.Exit(0);\n\n            for (c[i = 0] = 1L; i < n; c[0] = -c[0], i++)\n                for (c[1 + (j = i)] = 1L; j > 0; j--)\n                    c[j] = c[j - 1] - c[j];\n        }\n\n        static bool is_prime(int n)\n        {\n            int i;\n\n            coef(n);\n            c[0] += 1;\n            c[i = n] -= 1;\n\n            while (i-- != 0 && (c[i] % n) == 0) ;\n\n            return i < 0;\n        }\n\n        static void show(int n)\n\t    {\n\t\t    do {\n                Console.Write(\"+\" + c[n] + \"x^\" + n);\n\t\t    }while (n-- != 0);\n\t    }\n    }\n"}
{"id": 83222, "name": "AKS test for primes", "source": "Translate Ruby to Java: def x_minus_1_to_the(p)\n  p.times.reduce([1]) do |ex, _|\n    ([0_i64] + ex).zip(ex + [0]).map { |x, y| x - y }\n  end\nend\n \ndef prime?(p)\n  return false if p < 2\n  coeff = x_minus_1_to_the(p)[1..p//2] \n  coeff.all?{ |n| n%p == 0 }\nend\n\n8.times do |n|\n  puts \"(x-1)^\n  x_minus_1_to_the(n).map_with_index{ |c, p|\n    p.zero? ? c.to_s : (c < 0 ? \" - \" : \" + \") + (c.abs == 1 ? \"x\" : \"\n  }.join\nend\n\nputs \"\\nPrimes below 50:\", 50.times.select { |n| prime? n }.join(',')\n", "target": "public class AksTest {\n    private static final long[] c = new long[64];\n\n    public static void main(String[] args) {\n        for (int n = 0; n < 10; n++) {\n            coeff(n);\n            show(n);\n        }\n\n        System.out.print(\"Primes:\");\n        for (int n = 1; n < c.length; n++)\n            if (isPrime(n))\n                System.out.printf(\" %d\", n);\n\n        System.out.println();\n    }\n\n    static void coeff(int n) {\n        c[0] = 1;\n        for (int i = 0; i < n; c[0] = -c[0], i++) {\n            c[1 + i] = 1;\n            for (int j = i; j > 0; j--)\n                c[j] = c[j - 1] - c[j];\n        }\n    }\n\n    static boolean isPrime(int n) {\n        coeff(n);\n        c[0]++;\n        c[n]--;\n\n        int i = n;\n        while (i-- != 0 && c[i] % n == 0)\n            continue;\n        return i < 0;\n    }\n\n    static void show(int n) {\n        System.out.print(\"(x-1)^\" + n + \" =\");\n        for (int i = n; i >= 0; i--) {\n            System.out.print(\" + \" + c[i] + \"x^\" + i);\n        }\n        System.out.println();\n    }\n}\n"}
{"id": 83223, "name": "AKS test for primes", "source": "Translate Ruby to Python: def x_minus_1_to_the(p)\n  p.times.reduce([1]) do |ex, _|\n    ([0_i64] + ex).zip(ex + [0]).map { |x, y| x - y }\n  end\nend\n \ndef prime?(p)\n  return false if p < 2\n  coeff = x_minus_1_to_the(p)[1..p//2] \n  coeff.all?{ |n| n%p == 0 }\nend\n\n8.times do |n|\n  puts \"(x-1)^\n  x_minus_1_to_the(n).map_with_index{ |c, p|\n    p.zero? ? c.to_s : (c < 0 ? \" - \" : \" + \") + (c.abs == 1 ? \"x\" : \"\n  }.join\nend\n\nputs \"\\nPrimes below 50:\", 50.times.select { |n| prime? n }.join(',')\n", "target": "def expand_x_1(n): \n\n    c =1\n    for i in range(n//2+1):\n        c = c*(n-i)//(i+1)\n        yield c\n        \ndef aks(p):\n    if p==2:\n        return True\n\n    for i in expand_x_1(p):\n        if i % p:\n\n            return False\n    return True\n"}
{"id": 83483, "name": "Amb", "source": "Translate Ruby to C#: require \"continuation\"\n\nclass Amb\n  class ExhaustedError < RuntimeError; end\n\n  def initialize\n    @fail = proc { fail ExhaustedError, \"amb tree exhausted\" }\n  end\n\n  def choose(*choices)\n    prev_fail = @fail\n    callcc { |sk|\n      choices.each { |choice|\n\tcallcc { |fk|\n\t  @fail = proc {\n\t    @fail = prev_fail\n\t    fk.call(:fail)\n\t  }\n\t  if choice.respond_to? :call\n\t    sk.call(choice.call)\n\t  else\n\t    sk.call(choice)\n\t  end\n\t}\n      }\n      @fail.call\n    }\n  end\n\n  def failure\n    choose\n  end\n\n  def assert(cond)\n    failure unless cond\n  end\nend\n\nA = Amb.new\nw1 = A.choose(\"the\", \"that\", \"a\")\nw2 = A.choose(\"frog\", \"elephant\", \"thing\")\nw3 = A.choose(\"walked\", \"treaded\", \"grows\")\nw4 = A.choose(\"slowly\", \"quickly\")\n\nA.choose() unless w1[-1] == w2[0]\nA.choose() unless w2[-1] == w3[0]\nA.choose() unless w3[-1] == w4[0]\n\nputs w1, w2, w3, w4\n", "target": "using System;\nusing System.Collections.Generic;\n\npublic class Amb : IDisposable\n{\n    List<IValueSet> streams = new List<IValueSet>();\n    List<IAssertOrAction> assertsOrActions = new List<IAssertOrAction>();\n    volatile bool stopped = false;\n\n    public IAmbValue<T> DefineValues<T>(params T[] values)\n    {\n        return DefineValueSet(values);\n    }\n\n    public IAmbValue<T> DefineValueSet<T>(IEnumerable<T> values)\n    {\n        ValueSet<T> stream = new ValueSet<T>();\n        stream.Enumerable = values;\n        streams.Add(stream);\n        return stream;\n    }\n\n    public Amb Assert(Func<bool> function)\n    {\n        assertsOrActions.Add(new AmbAssert()\n        {\n            Level = streams.Count,\n            IsValidFunction = function\n        });\n        return this;\n    }\n\n    public Amb Perform(Action action)\n    {\n        assertsOrActions.Add(new AmbAction()\n        {\n            Level = streams.Count,\n            Action = action\n        });\n        return this;\n    }\n\n    public void Stop()\n    {\n        stopped = true;\n    }\n\n    public void Dispose()\n    {\n        RunLevel(0, 0);\n        if (!stopped)\n        {\n            throw new AmbException();\n        }\n    }\n\n    void RunLevel(int level, int actionIndex)\n    {\n        while (actionIndex < assertsOrActions.Count && assertsOrActions[actionIndex].Level <= level)\n        {\n            if (!assertsOrActions[actionIndex].Invoke() || stopped)\n                return;\n            actionIndex++;\n        }\n        if (level < streams.Count)\n        {\n            using (IValueSetIterator iterator = streams[level].CreateIterator())\n            {\n                while (iterator.MoveNext())\n                {\n                    RunLevel(level + 1, actionIndex);\n                }\n            }\n        }\n    }\n\n    interface IValueSet\n    {\n        IValueSetIterator CreateIterator();\n    }\n\n    interface IValueSetIterator : IDisposable\n    {\n        bool MoveNext();\n    }\n\n    interface IAssertOrAction\n    {\n        int Level { get; }\n        bool Invoke();\n    }\n\n    class AmbAssert : IAssertOrAction\n    {\n        internal int Level;\n        internal Func<bool> IsValidFunction;\n\n        int IAssertOrAction.Level { get { return Level; } }\n\n        bool IAssertOrAction.Invoke()\n        {\n            return IsValidFunction();\n        }\n    }\n\n    class AmbAction : IAssertOrAction\n    {\n        internal int Level;\n        internal Action Action;\n\n        int IAssertOrAction.Level { get { return Level; } }\n\n        bool IAssertOrAction.Invoke()\n        {\n            Action(); return true;\n        }\n    }\n\n    class ValueSet<T> : IValueSet, IAmbValue<T>, IValueSetIterator\n    {\n        internal IEnumerable<T> Enumerable;\n        private IEnumerator<T> enumerator;\n\n        public T Value { get { return enumerator.Current; } }\n\n        public IValueSetIterator CreateIterator()\n        {\n            enumerator = Enumerable.GetEnumerator();\n            return this;\n        }\n\n        public bool MoveNext()\n        {\n            return enumerator.MoveNext();\n        }\n\n        public void Dispose()\n        {\n            enumerator.Dispose();\n        }\n    }\n}\n\npublic interface IAmbValue<T>\n{\n    T Value { get; }\n}\n\npublic class AmbException : Exception\n{\n    public AmbException() : base(\"AMB is angry\") { }\n}\n"}
{"id": 83484, "name": "Amb", "source": "Translate Ruby to C#: require \"continuation\"\n\nclass Amb\n  class ExhaustedError < RuntimeError; end\n\n  def initialize\n    @fail = proc { fail ExhaustedError, \"amb tree exhausted\" }\n  end\n\n  def choose(*choices)\n    prev_fail = @fail\n    callcc { |sk|\n      choices.each { |choice|\n\tcallcc { |fk|\n\t  @fail = proc {\n\t    @fail = prev_fail\n\t    fk.call(:fail)\n\t  }\n\t  if choice.respond_to? :call\n\t    sk.call(choice.call)\n\t  else\n\t    sk.call(choice)\n\t  end\n\t}\n      }\n      @fail.call\n    }\n  end\n\n  def failure\n    choose\n  end\n\n  def assert(cond)\n    failure unless cond\n  end\nend\n\nA = Amb.new\nw1 = A.choose(\"the\", \"that\", \"a\")\nw2 = A.choose(\"frog\", \"elephant\", \"thing\")\nw3 = A.choose(\"walked\", \"treaded\", \"grows\")\nw4 = A.choose(\"slowly\", \"quickly\")\n\nA.choose() unless w1[-1] == w2[0]\nA.choose() unless w2[-1] == w3[0]\nA.choose() unless w3[-1] == w4[0]\n\nputs w1, w2, w3, w4\n", "target": "using System;\nusing System.Collections.Generic;\n\npublic class Amb : IDisposable\n{\n    List<IValueSet> streams = new List<IValueSet>();\n    List<IAssertOrAction> assertsOrActions = new List<IAssertOrAction>();\n    volatile bool stopped = false;\n\n    public IAmbValue<T> DefineValues<T>(params T[] values)\n    {\n        return DefineValueSet(values);\n    }\n\n    public IAmbValue<T> DefineValueSet<T>(IEnumerable<T> values)\n    {\n        ValueSet<T> stream = new ValueSet<T>();\n        stream.Enumerable = values;\n        streams.Add(stream);\n        return stream;\n    }\n\n    public Amb Assert(Func<bool> function)\n    {\n        assertsOrActions.Add(new AmbAssert()\n        {\n            Level = streams.Count,\n            IsValidFunction = function\n        });\n        return this;\n    }\n\n    public Amb Perform(Action action)\n    {\n        assertsOrActions.Add(new AmbAction()\n        {\n            Level = streams.Count,\n            Action = action\n        });\n        return this;\n    }\n\n    public void Stop()\n    {\n        stopped = true;\n    }\n\n    public void Dispose()\n    {\n        RunLevel(0, 0);\n        if (!stopped)\n        {\n            throw new AmbException();\n        }\n    }\n\n    void RunLevel(int level, int actionIndex)\n    {\n        while (actionIndex < assertsOrActions.Count && assertsOrActions[actionIndex].Level <= level)\n        {\n            if (!assertsOrActions[actionIndex].Invoke() || stopped)\n                return;\n            actionIndex++;\n        }\n        if (level < streams.Count)\n        {\n            using (IValueSetIterator iterator = streams[level].CreateIterator())\n            {\n                while (iterator.MoveNext())\n                {\n                    RunLevel(level + 1, actionIndex);\n                }\n            }\n        }\n    }\n\n    interface IValueSet\n    {\n        IValueSetIterator CreateIterator();\n    }\n\n    interface IValueSetIterator : IDisposable\n    {\n        bool MoveNext();\n    }\n\n    interface IAssertOrAction\n    {\n        int Level { get; }\n        bool Invoke();\n    }\n\n    class AmbAssert : IAssertOrAction\n    {\n        internal int Level;\n        internal Func<bool> IsValidFunction;\n\n        int IAssertOrAction.Level { get { return Level; } }\n\n        bool IAssertOrAction.Invoke()\n        {\n            return IsValidFunction();\n        }\n    }\n\n    class AmbAction : IAssertOrAction\n    {\n        internal int Level;\n        internal Action Action;\n\n        int IAssertOrAction.Level { get { return Level; } }\n\n        bool IAssertOrAction.Invoke()\n        {\n            Action(); return true;\n        }\n    }\n\n    class ValueSet<T> : IValueSet, IAmbValue<T>, IValueSetIterator\n    {\n        internal IEnumerable<T> Enumerable;\n        private IEnumerator<T> enumerator;\n\n        public T Value { get { return enumerator.Current; } }\n\n        public IValueSetIterator CreateIterator()\n        {\n            enumerator = Enumerable.GetEnumerator();\n            return this;\n        }\n\n        public bool MoveNext()\n        {\n            return enumerator.MoveNext();\n        }\n\n        public void Dispose()\n        {\n            enumerator.Dispose();\n        }\n    }\n}\n\npublic interface IAmbValue<T>\n{\n    T Value { get; }\n}\n\npublic class AmbException : Exception\n{\n    public AmbException() : base(\"AMB is angry\") { }\n}\n"}
{"id": 83487, "name": "Amb", "source": "Translate Ruby to Python: require \"continuation\"\n\nclass Amb\n  class ExhaustedError < RuntimeError; end\n\n  def initialize\n    @fail = proc { fail ExhaustedError, \"amb tree exhausted\" }\n  end\n\n  def choose(*choices)\n    prev_fail = @fail\n    callcc { |sk|\n      choices.each { |choice|\n\tcallcc { |fk|\n\t  @fail = proc {\n\t    @fail = prev_fail\n\t    fk.call(:fail)\n\t  }\n\t  if choice.respond_to? :call\n\t    sk.call(choice.call)\n\t  else\n\t    sk.call(choice)\n\t  end\n\t}\n      }\n      @fail.call\n    }\n  end\n\n  def failure\n    choose\n  end\n\n  def assert(cond)\n    failure unless cond\n  end\nend\n\nA = Amb.new\nw1 = A.choose(\"the\", \"that\", \"a\")\nw2 = A.choose(\"frog\", \"elephant\", \"thing\")\nw3 = A.choose(\"walked\", \"treaded\", \"grows\")\nw4 = A.choose(\"slowly\", \"quickly\")\n\nA.choose() unless w1[-1] == w2[0]\nA.choose() unless w2[-1] == w3[0]\nA.choose() unless w3[-1] == w4[0]\n\nputs w1, w2, w3, w4\n", "target": "import itertools as _itertools\n \nclass Amb(object):\n    def __init__(self):\n        self._names2values   = {}       \n        self._func           = None     \n        self._valueiterator  = None     \n        self._funcargnames   = None     \n \n    def __call__(self, arg=None):\n        if hasattr(arg, '__code__'):                \n            \n            \n            \n            globls = arg.__globals__ if hasattr(arg, '__globals__') else arg.func_globals\n            \n            argv = arg.__code__.co_varnames[:arg.__code__.co_argcount]\n            for name in argv:\n                if name not in self._names2values:\n                    assert name in globls, \\\n                           \"Global name %s not found in function globals\" % name\n                    self._names2values[name] = globls[name]\n            \n            valuesets = [self._names2values[name] for name in argv]\n            self._valueiterator = _itertools.product(*valuesets)\n            self._func = arg\n            self._funcargnames = argv\n            return self\n        elif arg is not None:\n            \n            \n            \n            arg = frozenset(arg)\n            return arg\n        else:\n            \n            \n            \n            return self._nextinsearch()\n \n    def _nextinsearch(self):\n        arg = self._func\n        globls = arg.__globals__\n        argv = self._funcargnames\n        found = False\n        for values in self._valueiterator:\n            if arg(*values):\n                \n                found = True\n                for n, v in zip(argv, values):\n                    globls[n] = v\n                break\n        if not found: raise StopIteration\n        return values\n \n    def __iter__(self):\n        return self\n \n    def __next__(self):\n        return self()\n    next = __next__ \n \nif __name__ == '__main__':\n    if True:\n        amb = Amb()\n \n        print(\"\\nSmall Pythagorean triples problem:\")\n        x = amb(range(1,11))\n        y = amb(range(1,11))\n        z = amb(range(1,11))\n \n        for _dummy in amb( lambda x, y, z: x*x + y*y == z*z ):\n            print ('%s %s %s' % (x, y, z))\n \n \n    if True:\n        amb = Amb()\n \n        print(\"\\nRosetta Code Amb problem:\")\n        w1 = amb([\"the\", \"that\", \"a\"])\n        w2 = amb([\"frog\", \"elephant\", \"thing\"])\n        w3 = amb([\"walked\", \"treaded\", \"grows\"])\n        w4 = amb([\"slowly\", \"quickly\"])\n \n        for _dummy in amb( lambda w1, w2, w3, w4: \\\n                             w1[-1] == w2[0] and \\\n                             w2[-1] == w3[0] and \\\n                             w3[-1] == w4[0] ):\n            print ('%s %s %s %s' % (w1, w2, w3, w4))\n \n    if True:\n        amb = Amb()\n \n        print(\"\\nAmb problem from \"\n            \"http://www.randomhacks.net/articles/2005/10/11/amb-operator:\")\n        x = amb([1, 2, 3])\n        y = amb([4, 5, 6])\n \n        for _dummy in amb( lambda x, y: x * y != 8 ):\n            print ('%s %s' % (x, y))\n"}
{"id": 83488, "name": "Amb", "source": "Translate Ruby to Python: require \"continuation\"\n\nclass Amb\n  class ExhaustedError < RuntimeError; end\n\n  def initialize\n    @fail = proc { fail ExhaustedError, \"amb tree exhausted\" }\n  end\n\n  def choose(*choices)\n    prev_fail = @fail\n    callcc { |sk|\n      choices.each { |choice|\n\tcallcc { |fk|\n\t  @fail = proc {\n\t    @fail = prev_fail\n\t    fk.call(:fail)\n\t  }\n\t  if choice.respond_to? :call\n\t    sk.call(choice.call)\n\t  else\n\t    sk.call(choice)\n\t  end\n\t}\n      }\n      @fail.call\n    }\n  end\n\n  def failure\n    choose\n  end\n\n  def assert(cond)\n    failure unless cond\n  end\nend\n\nA = Amb.new\nw1 = A.choose(\"the\", \"that\", \"a\")\nw2 = A.choose(\"frog\", \"elephant\", \"thing\")\nw3 = A.choose(\"walked\", \"treaded\", \"grows\")\nw4 = A.choose(\"slowly\", \"quickly\")\n\nA.choose() unless w1[-1] == w2[0]\nA.choose() unless w2[-1] == w3[0]\nA.choose() unless w3[-1] == w4[0]\n\nputs w1, w2, w3, w4\n", "target": "import itertools as _itertools\n \nclass Amb(object):\n    def __init__(self):\n        self._names2values   = {}       \n        self._func           = None     \n        self._valueiterator  = None     \n        self._funcargnames   = None     \n \n    def __call__(self, arg=None):\n        if hasattr(arg, '__code__'):                \n            \n            \n            \n            globls = arg.__globals__ if hasattr(arg, '__globals__') else arg.func_globals\n            \n            argv = arg.__code__.co_varnames[:arg.__code__.co_argcount]\n            for name in argv:\n                if name not in self._names2values:\n                    assert name in globls, \\\n                           \"Global name %s not found in function globals\" % name\n                    self._names2values[name] = globls[name]\n            \n            valuesets = [self._names2values[name] for name in argv]\n            self._valueiterator = _itertools.product(*valuesets)\n            self._func = arg\n            self._funcargnames = argv\n            return self\n        elif arg is not None:\n            \n            \n            \n            arg = frozenset(arg)\n            return arg\n        else:\n            \n            \n            \n            return self._nextinsearch()\n \n    def _nextinsearch(self):\n        arg = self._func\n        globls = arg.__globals__\n        argv = self._funcargnames\n        found = False\n        for values in self._valueiterator:\n            if arg(*values):\n                \n                found = True\n                for n, v in zip(argv, values):\n                    globls[n] = v\n                break\n        if not found: raise StopIteration\n        return values\n \n    def __iter__(self):\n        return self\n \n    def __next__(self):\n        return self()\n    next = __next__ \n \nif __name__ == '__main__':\n    if True:\n        amb = Amb()\n \n        print(\"\\nSmall Pythagorean triples problem:\")\n        x = amb(range(1,11))\n        y = amb(range(1,11))\n        z = amb(range(1,11))\n \n        for _dummy in amb( lambda x, y, z: x*x + y*y == z*z ):\n            print ('%s %s %s' % (x, y, z))\n \n \n    if True:\n        amb = Amb()\n \n        print(\"\\nRosetta Code Amb problem:\")\n        w1 = amb([\"the\", \"that\", \"a\"])\n        w2 = amb([\"frog\", \"elephant\", \"thing\"])\n        w3 = amb([\"walked\", \"treaded\", \"grows\"])\n        w4 = amb([\"slowly\", \"quickly\"])\n \n        for _dummy in amb( lambda w1, w2, w3, w4: \\\n                             w1[-1] == w2[0] and \\\n                             w2[-1] == w3[0] and \\\n                             w3[-1] == w4[0] ):\n            print ('%s %s %s %s' % (w1, w2, w3, w4))\n \n    if True:\n        amb = Amb()\n \n        print(\"\\nAmb problem from \"\n            \"http://www.randomhacks.net/articles/2005/10/11/amb-operator:\")\n        x = amb([1, 2, 3])\n        y = amb([4, 5, 6])\n \n        for _dummy in amb( lambda x, y: x * y != 8 ):\n            print ('%s %s' % (x, y))\n"}
{"id": 83656, "name": "Show the (decimal) value of a number of 1s appended with a 3, then squared", "source": "Translate Ruby to C#: m = 8\n(0..m).each do |n| \n  ones3 = \"1\"*n +\"3\"\n  puts ones3.ljust(m+2) + ( ones3.to_i**2).to_s\nend\n", "target": "using System; using BI = System.Numerics.BigInteger;\nclass Program { static void Main(string[] args) {\n    for (BI x = 3; BI.Log10(x) < 22; x = (x - 2) * 10 + 3)\n      Console.WriteLine(\"{1,43} {0,-20}\", x, x * x); } }\n"}
{"id": 83657, "name": "Show the (decimal) value of a number of 1s appended with a 3, then squared", "source": "Translate Ruby to C#: m = 8\n(0..m).each do |n| \n  ones3 = \"1\"*n +\"3\"\n  puts ones3.ljust(m+2) + ( ones3.to_i**2).to_s\nend\n", "target": "using System; using BI = System.Numerics.BigInteger;\nclass Program { static void Main(string[] args) {\n    for (BI x = 3; BI.Log10(x) < 22; x = (x - 2) * 10 + 3)\n      Console.WriteLine(\"{1,43} {0,-20}\", x, x * x); } }\n"}
{"id": 83658, "name": "Show the (decimal) value of a number of 1s appended with a 3, then squared", "source": "Translate Ruby to Python: m = 8\n(0..m).each do |n| \n  ones3 = \"1\"*n +\"3\"\n  puts ones3.ljust(m+2) + ( ones3.to_i**2).to_s\nend\n", "target": "[print(\"( \" + \"1\"*i + \"3 ) ^ 2 = \" + str(int(\"1\"*i + \"3\")**2)) for i in range(0,8)]\n"}
{"id": 83659, "name": "Show the (decimal) value of a number of 1s appended with a 3, then squared", "source": "Translate Ruby to Python: m = 8\n(0..m).each do |n| \n  ones3 = \"1\"*n +\"3\"\n  puts ones3.ljust(m+2) + ( ones3.to_i**2).to_s\nend\n", "target": "[print(\"( \" + \"1\"*i + \"3 ) ^ 2 = \" + str(int(\"1\"*i + \"3\")**2)) for i in range(0,8)]\n"}
{"id": 83892, "name": "Loops_N plus one half", "source": "Translate Ruby to C#: (1..10).each do |i|\n  print i\n  break if i == 10\n  print \", \"\nend\nputs\n", "target": "using System;\n\nclass Program\n{\n    static void Main(string[] args)\n    {\n        for (int i = 1; ; i++)\n        {\n            Console.Write(i);\n            if (i == 10) break;\n            Console.Write(\", \");\n        }\n        Console.WriteLine();\n    }\n}\n"}
{"id": 83894, "name": "Loops_N plus one half", "source": "Translate Ruby to Java: (1..10).each do |i|\n  print i\n  break if i == 10\n  print \", \"\nend\nputs\n", "target": "var out = System.out\nfor(i in 1..10) {\n  if(i > 1) out.print(\", \")\n  out.print(i)\n}\n"}
{"id": 83895, "name": "Loops_N plus one half", "source": "Translate Ruby to Python: (1..10).each do |i|\n  print i\n  break if i == 10\n  print \", \"\nend\nputs\n", "target": "print ( ', '.join(str(i+1) for i in range(10)) )\n"}
{"id": 84288, "name": "Euler's sum of powers conjecture", "source": "Translate Ruby to C#: power5 = (1..250).each_with_object({}){|i,h| h[i**5]=i}\nresult = power5.keys.repeated_combination(4).select{|a| power5[a.inject(:+)]}\nputs result.map{|a| a.map{|i| \"\n", "target": "using System;\n\nnamespace EulerSumOfPowers {\n    class Program {\n        const int MAX_NUMBER = 250;\n\n        static void Main(string[] args) {\n            bool found = false;\n            long[] fifth = new long[MAX_NUMBER];\n\n            for (int i = 1; i <= MAX_NUMBER; i++) {\n                long i2 = i * i;\n                fifth[i - 1] = i2 * i2 * i;\n            }\n\n            for (int a = 0; a < MAX_NUMBER && !found; a++) {\n                for (int b = a; b < MAX_NUMBER && !found; b++) {\n                    for (int c = b; c < MAX_NUMBER && !found; c++) {\n                        for (int d = c; d < MAX_NUMBER && !found; d++) {\n                            long sum = fifth[a] + fifth[b] + fifth[c] + fifth[d];\n                            int e = Array.BinarySearch(fifth, sum);\n                            found = e >= 0;\n                            if (found) {\n                                Console.WriteLine(\"{0}^5 + {1}^5 + {2}^5 + {3}^5 = {4}^5\", a + 1, b + 1, c + 1, d + 1, e + 1);\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n}\n"}
{"id": 84289, "name": "Euler's sum of powers conjecture", "source": "Translate Ruby to C#: power5 = (1..250).each_with_object({}){|i,h| h[i**5]=i}\nresult = power5.keys.repeated_combination(4).select{|a| power5[a.inject(:+)]}\nputs result.map{|a| a.map{|i| \"\n", "target": "using System;\n\nnamespace EulerSumOfPowers {\n    class Program {\n        const int MAX_NUMBER = 250;\n\n        static void Main(string[] args) {\n            bool found = false;\n            long[] fifth = new long[MAX_NUMBER];\n\n            for (int i = 1; i <= MAX_NUMBER; i++) {\n                long i2 = i * i;\n                fifth[i - 1] = i2 * i2 * i;\n            }\n\n            for (int a = 0; a < MAX_NUMBER && !found; a++) {\n                for (int b = a; b < MAX_NUMBER && !found; b++) {\n                    for (int c = b; c < MAX_NUMBER && !found; c++) {\n                        for (int d = c; d < MAX_NUMBER && !found; d++) {\n                            long sum = fifth[a] + fifth[b] + fifth[c] + fifth[d];\n                            int e = Array.BinarySearch(fifth, sum);\n                            found = e >= 0;\n                            if (found) {\n                                Console.WriteLine(\"{0}^5 + {1}^5 + {2}^5 + {3}^5 = {4}^5\", a + 1, b + 1, c + 1, d + 1, e + 1);\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n}\n"}
{"id": 84292, "name": "Euler's sum of powers conjecture", "source": "Translate Ruby to Java: power5 = (1..250).each_with_object({}){|i,h| h[i**5]=i}\nresult = power5.keys.repeated_combination(4).select{|a| power5[a.inject(:+)]}\nputs result.map{|a| a.map{|i| \"\n", "target": "public class eulerSopConjecture\n{\n\n    static final int    MAX_NUMBER = 250;\n\n    public static void main( String[] args )\n    {\n        boolean found = false;\n        long[]  fifth = new long[ MAX_NUMBER ];\n\n        for( int i = 1; i <= MAX_NUMBER; i ++ )\n        {\n            long i2 =  i * i;\n            fifth[ i - 1 ] = i2 * i2 * i;\n        } \n\n        for( int a = 0; a < MAX_NUMBER && ! found ; a ++ )\n        {\n            for( int b = a; b < MAX_NUMBER && ! found ; b ++ )\n            {\n                for( int c = b; c < MAX_NUMBER && ! found ; c ++ )\n                {\n                    for( int d = c; d < MAX_NUMBER && ! found ; d ++ )\n                    {\n                        long sum  = fifth[a] + fifth[b] + fifth[c] + fifth[d];\n                        int  e = java.util.Arrays.binarySearch( fifth, sum );\n                        found  = ( e >= 0 );\n                        if( found )\n                        {\n                            \n                            System.out.print( (a+1) + \"^5 + \"\n                                            + (b+1) + \"^5 + \"\n                                            + (c+1) + \"^5 + \"\n                                            + (d+1) + \"^5 = \"\n                                            + (e+1) + \"^5\"\n                                            );\n                        } \n                    } \n                } \n            } \n        } \n    } \n\n} \n"}
{"id": 84293, "name": "Euler's sum of powers conjecture", "source": "Translate Ruby to Java: power5 = (1..250).each_with_object({}){|i,h| h[i**5]=i}\nresult = power5.keys.repeated_combination(4).select{|a| power5[a.inject(:+)]}\nputs result.map{|a| a.map{|i| \"\n", "target": "public class eulerSopConjecture\n{\n\n    static final int    MAX_NUMBER = 250;\n\n    public static void main( String[] args )\n    {\n        boolean found = false;\n        long[]  fifth = new long[ MAX_NUMBER ];\n\n        for( int i = 1; i <= MAX_NUMBER; i ++ )\n        {\n            long i2 =  i * i;\n            fifth[ i - 1 ] = i2 * i2 * i;\n        } \n\n        for( int a = 0; a < MAX_NUMBER && ! found ; a ++ )\n        {\n            for( int b = a; b < MAX_NUMBER && ! found ; b ++ )\n            {\n                for( int c = b; c < MAX_NUMBER && ! found ; c ++ )\n                {\n                    for( int d = c; d < MAX_NUMBER && ! found ; d ++ )\n                    {\n                        long sum  = fifth[a] + fifth[b] + fifth[c] + fifth[d];\n                        int  e = java.util.Arrays.binarySearch( fifth, sum );\n                        found  = ( e >= 0 );\n                        if( found )\n                        {\n                            \n                            System.out.print( (a+1) + \"^5 + \"\n                                            + (b+1) + \"^5 + \"\n                                            + (c+1) + \"^5 + \"\n                                            + (d+1) + \"^5 = \"\n                                            + (e+1) + \"^5\"\n                                            );\n                        } \n                    } \n                } \n            } \n        } \n    } \n\n} \n"}
{"id": 84294, "name": "Euler's sum of powers conjecture", "source": "Translate Ruby to Python: power5 = (1..250).each_with_object({}){|i,h| h[i**5]=i}\nresult = power5.keys.repeated_combination(4).select{|a| power5[a.inject(:+)]}\nputs result.map{|a| a.map{|i| \"\n", "target": "def eulers_sum_of_powers():\n    max_n = 250\n    pow_5 = [n**5 for n in range(max_n)]\n    pow5_to_n = {n**5: n for n in range(max_n)}\n    for x0 in range(1, max_n):\n        for x1 in range(1, x0):\n            for x2 in range(1, x1):\n                for x3 in range(1, x2):\n                    pow_5_sum = sum(pow_5[i] for i in (x0, x1, x2, x3))\n                    if pow_5_sum in pow5_to_n:\n                        y = pow5_to_n[pow_5_sum]\n                        return (x0, x1, x2, x3, y)\n\nprint(\"%i**5 + %i**5 + %i**5 + %i**5 == %i**5\" % eulers_sum_of_powers())\n"}
{"id": 84295, "name": "Euler's sum of powers conjecture", "source": "Translate Ruby to Python: power5 = (1..250).each_with_object({}){|i,h| h[i**5]=i}\nresult = power5.keys.repeated_combination(4).select{|a| power5[a.inject(:+)]}\nputs result.map{|a| a.map{|i| \"\n", "target": "def eulers_sum_of_powers():\n    max_n = 250\n    pow_5 = [n**5 for n in range(max_n)]\n    pow5_to_n = {n**5: n for n in range(max_n)}\n    for x0 in range(1, max_n):\n        for x1 in range(1, x0):\n            for x2 in range(1, x1):\n                for x3 in range(1, x2):\n                    pow_5_sum = sum(pow_5[i] for i in (x0, x1, x2, x3))\n                    if pow_5_sum in pow5_to_n:\n                        y = pow5_to_n[pow_5_sum]\n                        return (x0, x1, x2, x3, y)\n\nprint(\"%i**5 + %i**5 + %i**5 + %i**5 == %i**5\" % eulers_sum_of_powers())\n"}
{"id": 84761, "name": "Strip control codes and extended characters from a string", "source": "Translate Ruby to C#: class String\n  def strip_control_characters()\n    chars.each_with_object(\"\") do |char, str|\n      str << char unless char.ascii_only? and (char.ord < 32 or char.ord == 127)\n    end\n  end\n  \n  def strip_control_and_extended_characters()\n    chars.each_with_object(\"\") do |char, str|\n      str << char if char.ascii_only? and char.ord.between?(32,126)\n    end\n  end\nend\n\np s = \"\\ba\\x00b\\n\\rc\\fd\\xc3\\x7ffoo\"\np s.strip_control_characters\np s.strip_control_and_extended_characters\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Threading.Tasks;\n\nnamespace RosettaCode\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            string test = \"string of \u263a\u263b\u2665\u2666\u2302, may include control characters and other ilk.\u266b\u263c\u00a7\u25ba\u2194\u25c4\";\n            Console.WriteLine(\"Original: {0}\", test);\n            Console.WriteLine(\"Stripped of control codes: {0}\", StripControlChars(test));\n            Console.WriteLine(\"Stripped of extended: {0}\", StripExtended(test));\n        }\n\n        static string StripControlChars(string arg)\n        {\n            char[] arrForm = arg.ToCharArray();\n            StringBuilder buffer = new StringBuilder(arg.Length);\n            \n            foreach(char ch in arrForm)\n                if (!Char.IsControl(ch)) buffer.Append(ch);\n\n            return buffer.ToString();\n        }\n\n        static string StripExtended(string arg)\n        {\n            StringBuilder buffer = new StringBuilder(arg.Length); \n            foreach(char ch in arg)\n            {\n                UInt16 num = Convert.ToUInt16(ch);\n                \n                if((num >= 32u) && (num <= 126u)) buffer.Append(ch);\n            }\n            return buffer.ToString();\n        }\n    }\n}\n"}
{"id": 84762, "name": "Strip control codes and extended characters from a string", "source": "Translate Ruby to C#: class String\n  def strip_control_characters()\n    chars.each_with_object(\"\") do |char, str|\n      str << char unless char.ascii_only? and (char.ord < 32 or char.ord == 127)\n    end\n  end\n  \n  def strip_control_and_extended_characters()\n    chars.each_with_object(\"\") do |char, str|\n      str << char if char.ascii_only? and char.ord.between?(32,126)\n    end\n  end\nend\n\np s = \"\\ba\\x00b\\n\\rc\\fd\\xc3\\x7ffoo\"\np s.strip_control_characters\np s.strip_control_and_extended_characters\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Threading.Tasks;\n\nnamespace RosettaCode\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            string test = \"string of \u263a\u263b\u2665\u2666\u2302, may include control characters and other ilk.\u266b\u263c\u00a7\u25ba\u2194\u25c4\";\n            Console.WriteLine(\"Original: {0}\", test);\n            Console.WriteLine(\"Stripped of control codes: {0}\", StripControlChars(test));\n            Console.WriteLine(\"Stripped of extended: {0}\", StripExtended(test));\n        }\n\n        static string StripControlChars(string arg)\n        {\n            char[] arrForm = arg.ToCharArray();\n            StringBuilder buffer = new StringBuilder(arg.Length);\n            \n            foreach(char ch in arrForm)\n                if (!Char.IsControl(ch)) buffer.Append(ch);\n\n            return buffer.ToString();\n        }\n\n        static string StripExtended(string arg)\n        {\n            StringBuilder buffer = new StringBuilder(arg.Length); \n            foreach(char ch in arg)\n            {\n                UInt16 num = Convert.ToUInt16(ch);\n                \n                if((num >= 32u) && (num <= 126u)) buffer.Append(ch);\n            }\n            return buffer.ToString();\n        }\n    }\n}\n"}
{"id": 84765, "name": "Strip control codes and extended characters from a string", "source": "Translate Ruby to Java: class String\n  def strip_control_characters()\n    chars.each_with_object(\"\") do |char, str|\n      str << char unless char.ascii_only? and (char.ord < 32 or char.ord == 127)\n    end\n  end\n  \n  def strip_control_and_extended_characters()\n    chars.each_with_object(\"\") do |char, str|\n      str << char if char.ascii_only? and char.ord.between?(32,126)\n    end\n  end\nend\n\np s = \"\\ba\\x00b\\n\\rc\\fd\\xc3\\x7ffoo\"\np s.strip_control_characters\np s.strip_control_and_extended_characters\n", "target": "import java.util.function.IntPredicate;\n\npublic class StripControlCodes {\n\n    public static void main(String[] args) {\n        String s = \"\\u0000\\n abc\\u00E9def\\u007F\";\n        System.out.println(stripChars(s, c -> c > '\\u001F' && c != '\\u007F'));\n        System.out.println(stripChars(s, c -> c > '\\u001F' && c < '\\u007F'));\n    }\n\n    static String stripChars(String s, IntPredicate include) {\n        return s.codePoints().filter(include::test).collect(StringBuilder::new,\n                StringBuilder::appendCodePoint, StringBuilder::append).toString();\n    }\n}\n"}
{"id": 84766, "name": "Strip control codes and extended characters from a string", "source": "Translate Ruby to Java: class String\n  def strip_control_characters()\n    chars.each_with_object(\"\") do |char, str|\n      str << char unless char.ascii_only? and (char.ord < 32 or char.ord == 127)\n    end\n  end\n  \n  def strip_control_and_extended_characters()\n    chars.each_with_object(\"\") do |char, str|\n      str << char if char.ascii_only? and char.ord.between?(32,126)\n    end\n  end\nend\n\np s = \"\\ba\\x00b\\n\\rc\\fd\\xc3\\x7ffoo\"\np s.strip_control_characters\np s.strip_control_and_extended_characters\n", "target": "import java.util.function.IntPredicate;\n\npublic class StripControlCodes {\n\n    public static void main(String[] args) {\n        String s = \"\\u0000\\n abc\\u00E9def\\u007F\";\n        System.out.println(stripChars(s, c -> c > '\\u001F' && c != '\\u007F'));\n        System.out.println(stripChars(s, c -> c > '\\u001F' && c < '\\u007F'));\n    }\n\n    static String stripChars(String s, IntPredicate include) {\n        return s.codePoints().filter(include::test).collect(StringBuilder::new,\n                StringBuilder::appendCodePoint, StringBuilder::append).toString();\n    }\n}\n"}
{"id": 84767, "name": "Strip control codes and extended characters from a string", "source": "Translate Ruby to Python: class String\n  def strip_control_characters()\n    chars.each_with_object(\"\") do |char, str|\n      str << char unless char.ascii_only? and (char.ord < 32 or char.ord == 127)\n    end\n  end\n  \n  def strip_control_and_extended_characters()\n    chars.each_with_object(\"\") do |char, str|\n      str << char if char.ascii_only? and char.ord.between?(32,126)\n    end\n  end\nend\n\np s = \"\\ba\\x00b\\n\\rc\\fd\\xc3\\x7ffoo\"\np s.strip_control_characters\np s.strip_control_and_extended_characters\n", "target": "stripped = lambda s: \"\".join(i for i in s if 31 < ord(i) < 127)\n\nprint(stripped(\"\\ba\\x00b\\n\\rc\\fd\\xc3\"))\n"}
{"id": 84768, "name": "Strip control codes and extended characters from a string", "source": "Translate Ruby to Python: class String\n  def strip_control_characters()\n    chars.each_with_object(\"\") do |char, str|\n      str << char unless char.ascii_only? and (char.ord < 32 or char.ord == 127)\n    end\n  end\n  \n  def strip_control_and_extended_characters()\n    chars.each_with_object(\"\") do |char, str|\n      str << char if char.ascii_only? and char.ord.between?(32,126)\n    end\n  end\nend\n\np s = \"\\ba\\x00b\\n\\rc\\fd\\xc3\\x7ffoo\"\np s.strip_control_characters\np s.strip_control_and_extended_characters\n", "target": "stripped = lambda s: \"\".join(i for i in s if 31 < ord(i) < 127)\n\nprint(stripped(\"\\ba\\x00b\\n\\rc\\fd\\xc3\"))\n"}
{"id": 85019, "name": "Primality by trial division", "source": "Translate Ruby to C#: require \"big\"\nrequire \"benchmark\"\n\n\n\n\ndef primep3?(n)                           \n  \n  n = n.to_big_i\n  return n | 1 == 3 if n < 5              \n  return false if n.gcd(6) != 1           \n  p = typeof(n).new(5)                    \n  until p > isqrt(n)\n    return false if n % p == 0 || n % (p + 2) == 0  \n    p += 6      \n  end\n  true\nend\n\n\n\n\ndef primep5?(n)                          \n  \n  n = n.to_big_i\n  return [2, 3, 5].includes?(n) if n < 7 \n  return false if n.gcd(30) != 1         \n  p = typeof(n).new(7)                   \n  until p > isqrt(n)\n    return false if                      \n      n % (p)    == 0 || n % (p+4)  == 0 || n % (p+6)  == 0 || n % (p+10) == 0 ||\n      n % (p+12) == 0 || n % (p+16) == 0 || n % (p+22) == 0 || n % (p+24) == 0\n      p += 30  \n  end\n  true\nend\n\n\n\n\ndef primep7?(n)\n  \n  \n  \n  n = n.to_big_i\n  return [2, 3, 5, 7].includes?(n) if n < 11  \n  return false if n.gcd(210) != 1         \n  p = typeof(n).new(11)                   \n  until p > isqrt(n)\n    return false if\n      n % (p)     == 0 || n % (p+2)   == 0 || n % (p+6)   == 0 || n % (p+8)   == 0 ||\n      n % (p+12)  == 0 || n % (p+18)  == 0 || n % (p+20)  == 0 || n % (p+26)  == 0 ||\n      n % (p+30)  == 0 || n % (p+32)  == 0 || n % (p+36)  == 0 || n % (p+42)  == 0 ||\n      n % (p+48)  == 0 || n % (p+50)  == 0 || n % (p+56)  == 0 || n % (p+60)  == 0 ||\n      n % (p+62)  == 0 || n % (p+68)  == 0 || n % (p+72)  == 0 || n % (p+78)  == 0 ||\n      n % (p+86)  == 0 || n % (p+90)  == 0 || n % (p+92)  == 0 || n % (p+96)  == 0 ||\n      n % (p+98)  == 0 || n % (p+102) == 0 || n % (p+110) == 0 || n % (p+116) == 0 ||\n      n % (p+120) == 0 || n % (p+126) == 0 || n % (p+128) == 0 || n % (p+132) == 0 ||\n      n % (p+138) == 0 || n % (p+140) == 0 || n % (p+146) == 0 || n % (p+152) == 0 ||\n      n % (p+156) == 0 || n % (p+158) == 0 || n % (p+162) == 0 || n % (p+168) == 0 ||\n      n % (p+170) == 0 || n % (p+176) == 0 || n % (p+180) == 0 || n % (p+182) == 0 ||\n      n % (p+186) == 0 || n % (p+188) == 0 || n % (p+198) == 0 || n % (p+200) == 0\n    p += 210    \n  end\n  true\nend\n\n\ndef isqrt(n)\n  raise ArgumentError.new \"Input must be non-negative integer\" if n < 0\n  return n if n < 2\n  bits = n.bit_length\n  one = typeof(n).new(1)  \n  x = one << ((bits - 1) >> 1) | n >> ((bits >> 1) + 1)\n  while (t = n // x) < x; x = (x + t) >> 1 end\n  x   \nend\n\n\n\np = 541\nBenchmark.ips do |b|\n    print \"\\np = \n    b.report(\"primep3?\") { primep3?(p) }\n    b.report(\"primep5?\") { primep5?(p) }\n    b.report(\"primep7?\") { primep7?(p) }\n    puts\nend\n\np = 1000003      \nBenchmark.ips do |b|\n    print \"\\np = \n    b.report(\"primep3?\") { primep3?(p) }\n    b.report(\"primep5?\") { primep5?(p) }\n    b.report(\"primep7?\") { primep7?(p) }\n    puts\nend\n\np = 2147483647i32     \nBenchmark.ips do |b|\n    print \"\\np = \n    b.report(\"primep3?\") { primep3?(p) }\n    b.report(\"primep5?\") { primep5?(p) }\n    b.report(\"primep7?\") { primep7?(p) }\n    puts\nend\n\np = 4294967291u32     \nBenchmark.ips do |b|\n    print \"\\np = \n    b.report(\"primep3?\") { primep3?(p) }\n    b.report(\"primep5?\") { primep5?(p) }\n    b.report(\"primep7?\") { primep7?(p) }\n    puts\nend\n\np = 4294967311      \nBenchmark.ips do |b|\n    print \"\\np = \n    b.report(\"primep3?\") { primep3?(p) }\n    b.report(\"primep5?\") { primep5?(p) }\n    b.report(\"primep7?\") { primep7?(p) }\n    puts\nend\n", "target": "static bool isPrime(int n)\n        {\n            if (n <= 1) return false;\n            for (int i = 2; i * i <= n; i++)            \n                if (n % i == 0) return false;            \n            return true;\n        }\n"}
{"id": 85021, "name": "Primality by trial division", "source": "Translate Ruby to Java: require \"big\"\nrequire \"benchmark\"\n\n\n\n\ndef primep3?(n)                           \n  \n  n = n.to_big_i\n  return n | 1 == 3 if n < 5              \n  return false if n.gcd(6) != 1           \n  p = typeof(n).new(5)                    \n  until p > isqrt(n)\n    return false if n % p == 0 || n % (p + 2) == 0  \n    p += 6      \n  end\n  true\nend\n\n\n\n\ndef primep5?(n)                          \n  \n  n = n.to_big_i\n  return [2, 3, 5].includes?(n) if n < 7 \n  return false if n.gcd(30) != 1         \n  p = typeof(n).new(7)                   \n  until p > isqrt(n)\n    return false if                      \n      n % (p)    == 0 || n % (p+4)  == 0 || n % (p+6)  == 0 || n % (p+10) == 0 ||\n      n % (p+12) == 0 || n % (p+16) == 0 || n % (p+22) == 0 || n % (p+24) == 0\n      p += 30  \n  end\n  true\nend\n\n\n\n\ndef primep7?(n)\n  \n  \n  \n  n = n.to_big_i\n  return [2, 3, 5, 7].includes?(n) if n < 11  \n  return false if n.gcd(210) != 1         \n  p = typeof(n).new(11)                   \n  until p > isqrt(n)\n    return false if\n      n % (p)     == 0 || n % (p+2)   == 0 || n % (p+6)   == 0 || n % (p+8)   == 0 ||\n      n % (p+12)  == 0 || n % (p+18)  == 0 || n % (p+20)  == 0 || n % (p+26)  == 0 ||\n      n % (p+30)  == 0 || n % (p+32)  == 0 || n % (p+36)  == 0 || n % (p+42)  == 0 ||\n      n % (p+48)  == 0 || n % (p+50)  == 0 || n % (p+56)  == 0 || n % (p+60)  == 0 ||\n      n % (p+62)  == 0 || n % (p+68)  == 0 || n % (p+72)  == 0 || n % (p+78)  == 0 ||\n      n % (p+86)  == 0 || n % (p+90)  == 0 || n % (p+92)  == 0 || n % (p+96)  == 0 ||\n      n % (p+98)  == 0 || n % (p+102) == 0 || n % (p+110) == 0 || n % (p+116) == 0 ||\n      n % (p+120) == 0 || n % (p+126) == 0 || n % (p+128) == 0 || n % (p+132) == 0 ||\n      n % (p+138) == 0 || n % (p+140) == 0 || n % (p+146) == 0 || n % (p+152) == 0 ||\n      n % (p+156) == 0 || n % (p+158) == 0 || n % (p+162) == 0 || n % (p+168) == 0 ||\n      n % (p+170) == 0 || n % (p+176) == 0 || n % (p+180) == 0 || n % (p+182) == 0 ||\n      n % (p+186) == 0 || n % (p+188) == 0 || n % (p+198) == 0 || n % (p+200) == 0\n    p += 210    \n  end\n  true\nend\n\n\ndef isqrt(n)\n  raise ArgumentError.new \"Input must be non-negative integer\" if n < 0\n  return n if n < 2\n  bits = n.bit_length\n  one = typeof(n).new(1)  \n  x = one << ((bits - 1) >> 1) | n >> ((bits >> 1) + 1)\n  while (t = n // x) < x; x = (x + t) >> 1 end\n  x   \nend\n\n\n\np = 541\nBenchmark.ips do |b|\n    print \"\\np = \n    b.report(\"primep3?\") { primep3?(p) }\n    b.report(\"primep5?\") { primep5?(p) }\n    b.report(\"primep7?\") { primep7?(p) }\n    puts\nend\n\np = 1000003      \nBenchmark.ips do |b|\n    print \"\\np = \n    b.report(\"primep3?\") { primep3?(p) }\n    b.report(\"primep5?\") { primep5?(p) }\n    b.report(\"primep7?\") { primep7?(p) }\n    puts\nend\n\np = 2147483647i32     \nBenchmark.ips do |b|\n    print \"\\np = \n    b.report(\"primep3?\") { primep3?(p) }\n    b.report(\"primep5?\") { primep5?(p) }\n    b.report(\"primep7?\") { primep7?(p) }\n    puts\nend\n\np = 4294967291u32     \nBenchmark.ips do |b|\n    print \"\\np = \n    b.report(\"primep3?\") { primep3?(p) }\n    b.report(\"primep5?\") { primep5?(p) }\n    b.report(\"primep7?\") { primep7?(p) }\n    puts\nend\n\np = 4294967311      \nBenchmark.ips do |b|\n    print \"\\np = \n    b.report(\"primep3?\") { primep3?(p) }\n    b.report(\"primep5?\") { primep5?(p) }\n    b.report(\"primep7?\") { primep7?(p) }\n    puts\nend\n", "target": "public static boolean prime(long a){\n   if(a == 2){\n      return true;\n   }else if(a <= 1 || a % 2 == 0){\n      return false;\n   }\n   long max = (long)Math.sqrt(a);\n   for(long n= 3; n <= max; n+= 2){\n      if(a % n == 0){ return false; }\n   }\n   return true;\n}\n"}
{"id": 85022, "name": "Primality by trial division", "source": "Translate Ruby to Python: require \"big\"\nrequire \"benchmark\"\n\n\n\n\ndef primep3?(n)                           \n  \n  n = n.to_big_i\n  return n | 1 == 3 if n < 5              \n  return false if n.gcd(6) != 1           \n  p = typeof(n).new(5)                    \n  until p > isqrt(n)\n    return false if n % p == 0 || n % (p + 2) == 0  \n    p += 6      \n  end\n  true\nend\n\n\n\n\ndef primep5?(n)                          \n  \n  n = n.to_big_i\n  return [2, 3, 5].includes?(n) if n < 7 \n  return false if n.gcd(30) != 1         \n  p = typeof(n).new(7)                   \n  until p > isqrt(n)\n    return false if                      \n      n % (p)    == 0 || n % (p+4)  == 0 || n % (p+6)  == 0 || n % (p+10) == 0 ||\n      n % (p+12) == 0 || n % (p+16) == 0 || n % (p+22) == 0 || n % (p+24) == 0\n      p += 30  \n  end\n  true\nend\n\n\n\n\ndef primep7?(n)\n  \n  \n  \n  n = n.to_big_i\n  return [2, 3, 5, 7].includes?(n) if n < 11  \n  return false if n.gcd(210) != 1         \n  p = typeof(n).new(11)                   \n  until p > isqrt(n)\n    return false if\n      n % (p)     == 0 || n % (p+2)   == 0 || n % (p+6)   == 0 || n % (p+8)   == 0 ||\n      n % (p+12)  == 0 || n % (p+18)  == 0 || n % (p+20)  == 0 || n % (p+26)  == 0 ||\n      n % (p+30)  == 0 || n % (p+32)  == 0 || n % (p+36)  == 0 || n % (p+42)  == 0 ||\n      n % (p+48)  == 0 || n % (p+50)  == 0 || n % (p+56)  == 0 || n % (p+60)  == 0 ||\n      n % (p+62)  == 0 || n % (p+68)  == 0 || n % (p+72)  == 0 || n % (p+78)  == 0 ||\n      n % (p+86)  == 0 || n % (p+90)  == 0 || n % (p+92)  == 0 || n % (p+96)  == 0 ||\n      n % (p+98)  == 0 || n % (p+102) == 0 || n % (p+110) == 0 || n % (p+116) == 0 ||\n      n % (p+120) == 0 || n % (p+126) == 0 || n % (p+128) == 0 || n % (p+132) == 0 ||\n      n % (p+138) == 0 || n % (p+140) == 0 || n % (p+146) == 0 || n % (p+152) == 0 ||\n      n % (p+156) == 0 || n % (p+158) == 0 || n % (p+162) == 0 || n % (p+168) == 0 ||\n      n % (p+170) == 0 || n % (p+176) == 0 || n % (p+180) == 0 || n % (p+182) == 0 ||\n      n % (p+186) == 0 || n % (p+188) == 0 || n % (p+198) == 0 || n % (p+200) == 0\n    p += 210    \n  end\n  true\nend\n\n\ndef isqrt(n)\n  raise ArgumentError.new \"Input must be non-negative integer\" if n < 0\n  return n if n < 2\n  bits = n.bit_length\n  one = typeof(n).new(1)  \n  x = one << ((bits - 1) >> 1) | n >> ((bits >> 1) + 1)\n  while (t = n // x) < x; x = (x + t) >> 1 end\n  x   \nend\n\n\n\np = 541\nBenchmark.ips do |b|\n    print \"\\np = \n    b.report(\"primep3?\") { primep3?(p) }\n    b.report(\"primep5?\") { primep5?(p) }\n    b.report(\"primep7?\") { primep7?(p) }\n    puts\nend\n\np = 1000003      \nBenchmark.ips do |b|\n    print \"\\np = \n    b.report(\"primep3?\") { primep3?(p) }\n    b.report(\"primep5?\") { primep5?(p) }\n    b.report(\"primep7?\") { primep7?(p) }\n    puts\nend\n\np = 2147483647i32     \nBenchmark.ips do |b|\n    print \"\\np = \n    b.report(\"primep3?\") { primep3?(p) }\n    b.report(\"primep5?\") { primep5?(p) }\n    b.report(\"primep7?\") { primep7?(p) }\n    puts\nend\n\np = 4294967291u32     \nBenchmark.ips do |b|\n    print \"\\np = \n    b.report(\"primep3?\") { primep3?(p) }\n    b.report(\"primep5?\") { primep5?(p) }\n    b.report(\"primep7?\") { primep7?(p) }\n    puts\nend\n\np = 4294967311      \nBenchmark.ips do |b|\n    print \"\\np = \n    b.report(\"primep3?\") { primep3?(p) }\n    b.report(\"primep5?\") { primep5?(p) }\n    b.report(\"primep7?\") { primep7?(p) }\n    puts\nend\n", "target": "def prime(a):\n    return not (a < 2 or any(a % x == 0 for x in xrange(2, int(a**0.5) + 1)))\n"}
{"id": 85278, "name": "MD5", "source": "Translate Ruby to C#: require \"digest/md5\"\n\nputs Digest::MD5.hexdigest(\"The quick brown fox jumped over the lazy dog's back\")\n", "target": "using System.Text;\nusing System.Security.Cryptography;\n\nbyte[] data = Encoding.ASCII.GetBytes(\"The quick brown fox jumped over the lazy dog's back\");\nbyte[] hash = MD5.Create().ComputeHash(data);\nConsole.WriteLine(BitConverter.ToString(hash).Replace(\"-\", \"\").ToLower());\n"}
{"id": 85280, "name": "MD5", "source": "Translate Ruby to Java: require \"digest/md5\"\n\nputs Digest::MD5.hexdigest(\"The quick brown fox jumped over the lazy dog's back\")\n", "target": "import java.nio.charset.StandardCharsets;\nimport java.security.MessageDigest;\nimport java.security.NoSuchAlgorithmException;\n\npublic class Digester {\n\n    public static void main(String[] args) {\n        System.out.println(hexDigest(\"Rosetta code\", \"MD5\"));\n    }\n\n    static String hexDigest(String str, String digestName) {\n        try {\n            MessageDigest md = MessageDigest.getInstance(digestName);\n            byte[] digest = md.digest(str.getBytes(StandardCharsets.UTF_8));\n            char[] hex = new char[digest.length * 2];\n            for (int i = 0; i < digest.length; i++) {\n                hex[2 * i] = \"0123456789abcdef\".charAt((digest[i] & 0xf0) >> 4);\n                hex[2 * i + 1] = \"0123456789abcdef\".charAt(digest[i] & 0x0f);\n            }\n            return new String(hex);\n        } catch (NoSuchAlgorithmException e) {\n            throw new IllegalStateException(e);\n        }\n    }\n}\n"}
{"id": 85281, "name": "MD5", "source": "Translate Ruby to Python: require \"digest/md5\"\n\nputs Digest::MD5.hexdigest(\"The quick brown fox jumped over the lazy dog's back\")\n", "target": ">>> import hashlib\n>>> \n>>> tests = (\n  (b\"\", 'd41d8cd98f00b204e9800998ecf8427e'),\n  (b\"a\", '0cc175b9c0f1b6a831c399e269772661'),\n  (b\"abc\", '900150983cd24fb0d6963f7d28e17f72'),\n  (b\"message digest\", 'f96b697d7cb7938d525a2f31aaf161d0'),\n  (b\"abcdefghijklmnopqrstuvwxyz\", 'c3fcd3d76192e4007dfb496cca67e13b'),\n  (b\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789\", 'd174ab98d277d9f5a5611c2c9f419d9f'),\n  (b\"12345678901234567890123456789012345678901234567890123456789012345678901234567890\", '57edf4a22be3c955ac49da2e2107b67a') )\n>>> for text, golden in tests: assert hashlib.md5(text).hexdigest() == golden\n\n>>>\n"}
{"id": 85469, "name": "Yin and yang", "source": "Translate Ruby to C#: Shoes.app(:width => 470, :height => 380) do\n  PI = Shoes::TWO_PI/2\n\n  strokewidth 1\n\n  def yin_yang(x, y, radius)\n    fill black; stroke black\n    arc x, y, radius, radius, -PI/2, PI/2\n\n    fill white; stroke white\n    arc x, y, radius, radius, PI/2, -PI/2\n    oval x-radius/4, y-radius/2, radius/2-1\n\n    fill black; stroke black\n    oval x-radius/4, y, radius/2-1\n    oval x-radius/12, y-radius/4-radius/12, radius/6-1\n\n    fill white; stroke white\n    oval x-radius/12, y+radius/4-radius/12, radius/6-1\n\n    nofill\n    stroke black\n    oval x-radius/2, y-radius/2, radius\n  end\n\n  yin_yang 190, 190, 360\n  yin_yang 410, 90, 90\nend\n", "target": "    public partial class Form1 : Form\n    {\n        public Form1()\n        {\n            InitializeComponent();\n            Paint += Form1_Paint;\n        }\n\n        private void Form1_Paint(object sender, PaintEventArgs e)\n        {\n            Graphics g = e.Graphics;\n            g.SmoothingMode = System.Drawing.Drawing2D.SmoothingMode.AntiAlias;\n\n            DrawTaijitu(g, new Point(50, 50), 200, true);\n            DrawTaijitu(g, new Point(10, 10), 60, true);\n        }\n\n        private void DrawTaijitu(Graphics g, Point pt, int width, bool hasOutline)\n        {\n            g.FillPie(Brushes.Black, pt.X, pt.Y, width, width, 90, 180);\n            g.FillPie(Brushes.White, pt.X, pt.Y, width, width, 270, 180);\n            float headSize = Convert.ToSingle(width * 0.5);\n            float headXPosition = Convert.ToSingle(pt.X + (width * 0.25));\n            g.FillEllipse(Brushes.Black, headXPosition, Convert.ToSingle(pt.Y), headSize, headSize);\n            g.FillEllipse(Brushes.White, headXPosition, Convert.ToSingle(pt.Y + (width * 0.5)), headSize, headSize);\n            float headBlobSize = Convert.ToSingle(width * 0.125);\n            float headBlobXPosition = Convert.ToSingle(pt.X + (width * 0.4375));\n            g.FillEllipse(Brushes.White, headBlobXPosition, Convert.ToSingle(pt.Y + (width * 0.1875)), headBlobSize, headBlobSize);\n            g.FillEllipse(Brushes.Black, headBlobXPosition, Convert.ToSingle(pt.Y + (width * 0.6875)), headBlobSize, headBlobSize);\n            if (hasOutline) g.DrawEllipse(Pens.Black, pt.X, pt.Y, width, width);\n        }\n    }\n"}
{"id": 85471, "name": "Yin and yang", "source": "Translate Ruby to Java: Shoes.app(:width => 470, :height => 380) do\n  PI = Shoes::TWO_PI/2\n\n  strokewidth 1\n\n  def yin_yang(x, y, radius)\n    fill black; stroke black\n    arc x, y, radius, radius, -PI/2, PI/2\n\n    fill white; stroke white\n    arc x, y, radius, radius, PI/2, -PI/2\n    oval x-radius/4, y-radius/2, radius/2-1\n\n    fill black; stroke black\n    oval x-radius/4, y, radius/2-1\n    oval x-radius/12, y-radius/4-radius/12, radius/6-1\n\n    fill white; stroke white\n    oval x-radius/12, y+radius/4-radius/12, radius/6-1\n\n    nofill\n    stroke black\n    oval x-radius/2, y-radius/2, radius\n  end\n\n  yin_yang 190, 190, 360\n  yin_yang 410, 90, 90\nend\n", "target": "package org.rosettacode.yinandyang;\n\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.Image;\nimport java.awt.image.BufferedImage;\nimport javax.swing.ImageIcon;\nimport javax.swing.JFrame;\nimport javax.swing.JLabel;\n\npublic class YinYangGenerator\n{\n    private final int size;\n\n    public YinYangGenerator(final int size)\n    {\n        this.size = size;\n    }\n\n    \n    public void drawYinYang(final Graphics graphics)\n    {\n        \n        final Color colorSave = graphics.getColor();\n\n        graphics.setColor(Color.WHITE);\n        \n        graphics.fillOval(0, 0, size-1, size-1);\n        \n        graphics.setColor(Color.BLACK);\n        \n        graphics.fillArc(0, 0, size-1, size-1, 270, 180);\n        graphics.fillOval(size/4, size/2, size/2, size/2);\n        \n        graphics.setColor(Color.WHITE);\n        graphics.fillOval(size/4, 0, size/2, size/2);\n        graphics.fillOval(7*size/16, 11*size/16, size/8, size/8);\n\n        graphics.setColor(Color.BLACK);\n        graphics.fillOval(7*size/16, 3*size/16, size/8, size/8);\n        \n        graphics.drawOval(0, 0, size-1, size-1);\n        \n        \n        graphics.setColor(colorSave);\n    }\n\n    \n    public Image createImage(final Color bg)\n    {\n        \n        final BufferedImage image = new BufferedImage(size, size, BufferedImage.TYPE_INT_RGB);\n        \n        \n        \n        final Graphics graphics = image.getGraphics();\n        \n        graphics.setColor(bg);\n        graphics.fillRect(0,0,size,size);\n        drawYinYang(graphics);\n        return image;\n    }\n\n    public static void main(final String args[])\n    {\n        final int size = Integer.parseInt(args[0]);\n        final YinYangGenerator generator = new YinYangGenerator(size);\n\n        final JFrame frame = new JFrame(\"Yin Yang Generator\");\n        frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n        final Image yinYang = generator.createImage(frame.getBackground());\n        \n        frame.add(new JLabel(new ImageIcon(yinYang)));\n        frame.pack();\n        frame.setVisible(true);\n    }\n}\n"}
{"id": 85472, "name": "Yin and yang", "source": "Translate Ruby to Python: Shoes.app(:width => 470, :height => 380) do\n  PI = Shoes::TWO_PI/2\n\n  strokewidth 1\n\n  def yin_yang(x, y, radius)\n    fill black; stroke black\n    arc x, y, radius, radius, -PI/2, PI/2\n\n    fill white; stroke white\n    arc x, y, radius, radius, PI/2, -PI/2\n    oval x-radius/4, y-radius/2, radius/2-1\n\n    fill black; stroke black\n    oval x-radius/4, y, radius/2-1\n    oval x-radius/12, y-radius/4-radius/12, radius/6-1\n\n    fill white; stroke white\n    oval x-radius/12, y+radius/4-radius/12, radius/6-1\n\n    nofill\n    stroke black\n    oval x-radius/2, y-radius/2, radius\n  end\n\n  yin_yang 190, 190, 360\n  yin_yang 410, 90, 90\nend\n", "target": "import math\ndef yinyang(n=3):\n\tradii   = [i * n for i in (1, 3, 6)]\n\tranges  = [list(range(-r, r+1)) for r in radii]\n\tsquares = [[ (x,y) for x in rnge for y in rnge]\n\t\t   for rnge in ranges]\n\tcircles = [[ (x,y) for x,y in sqrpoints\n\t\t     if math.hypot(x,y) <= radius ]\n\t\t   for sqrpoints, radius in zip(squares, radii)]\n\tm = {(x,y):' ' for x,y in squares[-1]}\n\tfor x,y in circles[-1]:\n\t\tm[x,y] = '*'\n\tfor x,y in circles[-1]:\n\t\tif x>0: m[(x,y)] = '\u00b7'\n\tfor x,y in circles[-2]:\n\t\tm[(x,y+3*n)] = '*'\n\t\tm[(x,y-3*n)] = '\u00b7'\n\tfor x,y in circles[-3]:\n\t\tm[(x,y+3*n)] = '\u00b7'\n\t\tm[(x,y-3*n)] = '*'\n\treturn '\\n'.join(''.join(m[(x,y)] for x in reversed(ranges[-1])) for y in ranges[-1])\n"}
{"id": 85685, "name": "Time a function", "source": "Translate Ruby to C#: require 'benchmark'\n\nBenchmark.bm(8) do |x|\n  x.report(\"nothing:\")  {  }\n  x.report(\"sum:\")  { (1..1_000_000).inject(4) {|sum, x| sum + x} }\nend\n", "target": "using System;\nusing System.Linq;\nusing System.Threading;\nusing System.Diagnostics;\n\nclass Program {\n    static void Main(string[] args) {\n        Stopwatch sw = new Stopwatch();\n\n        sw.Start();\n        DoSomething();\n        sw.Stop();\n\n        Console.WriteLine(\"DoSomething() took {0}ms.\", sw.Elapsed.TotalMilliseconds);\n    }\n\n    static void DoSomething() {\n        Thread.Sleep(1000);\n\n        Enumerable.Range(1, 10000).Where(x => x % 2 == 0).Sum();  \n    }\n}\n"}
{"id": 85687, "name": "Time a function", "source": "Translate Ruby to Java: require 'benchmark'\n\nBenchmark.bm(8) do |x|\n  x.report(\"nothing:\")  {  }\n  x.report(\"sum:\")  { (1..1_000_000).inject(4) {|sum, x| sum + x} }\nend\n", "target": "import java.lang.management.ManagementFactory;\nimport java.lang.management.ThreadMXBean;\n\npublic class TimeIt {\n\tpublic static void main(String[] args) {\n\t\tfinal ThreadMXBean threadMX = ManagementFactory.getThreadMXBean();\n\t\tassert threadMX.isCurrentThreadCpuTimeSupported();\n\t\tthreadMX.setThreadCpuTimeEnabled(true);\n\t\t\n\t\tlong start, end;\n\t\tstart = threadMX.getCurrentThreadCpuTime();\n\t\tcountTo(100000000);\n\t\tend = threadMX.getCurrentThreadCpuTime();\n\t\tSystem.out.println(\"Counting to 100000000 takes \"+(end-start)/1000000+\"ms\");\n\t\tstart = threadMX.getCurrentThreadCpuTime();\n\t\tcountTo(1000000000L);\n\t\tend = threadMX.getCurrentThreadCpuTime();\n\t\tSystem.out.println(\"Counting to 1000000000 takes \"+(end-start)/1000000+\"ms\");\n \n\t}\n \n\tpublic static void countTo(long x){\n\t\tSystem.out.println(\"Counting...\");\n\t\tfor(long i=0;i<x;i++);\n\t\tSystem.out.println(\"Done!\");\n\t}\n}\n"}
{"id": 85688, "name": "Time a function", "source": "Translate Ruby to Python: require 'benchmark'\n\nBenchmark.bm(8) do |x|\n  x.report(\"nothing:\")  {  }\n  x.report(\"sum:\")  { (1..1_000_000).inject(4) {|sum, x| sum + x} }\nend\n", "target": "import sys, timeit\ndef usec(function, arguments):\n    modname, funcname = __name__, function.__name__\n    timer = timeit.Timer(stmt='%(funcname)s(*args)' % vars(),\n                         setup='from %(modname)s import %(funcname)s; args=%(arguments)r' % vars())\n    try:\n        t, N = 0, 1\n        while t < 0.2:            \n            t = min(timer.repeat(repeat=3, number=N))            \n            N *= 10\n        microseconds = round(10000000 * t / N, 1) \n        return microseconds \n    except:\n        timer.print_exc(file=sys.stderr)\n        raise\n\nfrom math import pow\ndef nothing(): pass\ndef identity(x): return x\n"}
{"id": 85937, "name": "Binary search", "source": "Translate Ruby to C#: class Array\n  def binary_search(val, low = 0, high = (size - 1))\n    return nil if high < low\n    \n    mid = low + ((high - low) >> 1)\n    case val <=> self[mid]\n      when -1\n        binary_search(val, low, mid - 1)\n      when 1\n        binary_search(val, mid + 1, high)\n      else mid\n    end\n  end\nend\n\nary = [0,1,4,5,6,7,8,9,12,26,45,67,78,90,98,123,211,234,456,769,865,2345,3215,14345,24324]\n\n[0, 42, 45, 24324, 99999].each do |val|\n  i = ary.binary_search(val)\n  if i\n    puts \"found \n  else\n    puts \"\n  end\nend\n", "target": "namespace Search {\n  using System;\n\n  public static partial class Extensions {\n    \n    \n    \n    \n    \n    \n    public static int RecursiveBinarySearchForGLB<T>(this T[] entries, T value)\n      where T : IComparable {\n      return entries.RecursiveBinarySearchForGLB(value, 0, entries.Length - 1);\n    }\n\n    \n    \n    \n    \n    \n    \n    \n    \n    public static int RecursiveBinarySearchForGLB<T>(this T[] entries, T value, int left, int right)\n      where T : IComparable {\n      if (left <= right) {\n        var middle = left + (right - left) / 2;\n        return entries[middle].CompareTo(value) < 0 ?\n          entries.RecursiveBinarySearchForGLB(value, middle + 1, right) :\n          entries.RecursiveBinarySearchForGLB(value, left, middle - 1);\n      }\n\n      \n      \n      return right;\n    }\n\n    \n    \n    \n    \n    \n    \n    public static int RecursiveBinarySearchForLUB<T>(this T[] entries, T value)\n      where T : IComparable {\n      return entries.RecursiveBinarySearchForLUB(value, 0, entries.Length - 1);\n    }\n\n    \n    \n    \n    \n    \n    \n    \n    \n    public static int RecursiveBinarySearchForLUB<T>(this T[] entries, T value, int left, int right)\n      where T : IComparable {\n      if (left <= right) {\n        var middle = left + (right - left) / 2;\n        return entries[middle].CompareTo(value) <= 0 ?\n          entries.RecursiveBinarySearchForLUB(value, middle + 1, right) :\n          entries.RecursiveBinarySearchForLUB(value, left, middle - 1);\n      }\n\n      \n      \n      return left;\n    }\n  }\n}\n"}
{"id": 85939, "name": "Binary search", "source": "Translate Ruby to Java: class Array\n  def binary_search(val, low = 0, high = (size - 1))\n    return nil if high < low\n    \n    mid = low + ((high - low) >> 1)\n    case val <=> self[mid]\n      when -1\n        binary_search(val, low, mid - 1)\n      when 1\n        binary_search(val, mid + 1, high)\n      else mid\n    end\n  end\nend\n\nary = [0,1,4,5,6,7,8,9,12,26,45,67,78,90,98,123,211,234,456,769,865,2345,3215,14345,24324]\n\n[0, 42, 45, 24324, 99999].each do |val|\n  i = ary.binary_search(val)\n  if i\n    puts \"found \n  else\n    puts \"\n  end\nend\n", "target": "public class BinarySearchIterative {\n\n    public static int binarySearch(int[] nums, int check) {\n        int hi = nums.length - 1;\n        int lo = 0;\n        while (hi >= lo) {\n            int guess = (lo + hi) >>> 1;  \n            if (nums[guess] > check) {\n                hi = guess - 1;\n            } else if (nums[guess] < check) {\n                lo = guess + 1;\n            } else {\n                return guess;\n            }\n        }\n        return -1;\n    }\n\n    public static void main(String[] args) {\n        int[] haystack = {1, 5, 6, 7, 8, 11};\n        int needle = 5;\n        int index = binarySearch(haystack, needle);\n        if (index == -1) {\n            System.out.println(needle + \" is not in the array\");\n        } else {\n            System.out.println(needle + \" is at index \" + index);\n        }\n    }\n}\n"}
{"id": 85940, "name": "Binary search", "source": "Translate Ruby to Python: class Array\n  def binary_search(val, low = 0, high = (size - 1))\n    return nil if high < low\n    \n    mid = low + ((high - low) >> 1)\n    case val <=> self[mid]\n      when -1\n        binary_search(val, low, mid - 1)\n      when 1\n        binary_search(val, mid + 1, high)\n      else mid\n    end\n  end\nend\n\nary = [0,1,4,5,6,7,8,9,12,26,45,67,78,90,98,123,211,234,456,769,865,2345,3215,14345,24324]\n\n[0, 42, 45, 24324, 99999].each do |val|\n  i = ary.binary_search(val)\n  if i\n    puts \"found \n  else\n    puts \"\n  end\nend\n", "target": "def binary_search(l, value):\n    low = 0\n    high = len(l)-1\n    while low <= high: \n        mid = (low+high)//2\n        if l[mid] > value: high = mid-1\n        elif l[mid] < value: low = mid+1\n        else: return mid\n    return -1\n"}
{"id": 86105, "name": "Documentation", "source": "Translate Ruby to C#: \n\nmodule Documentation\n\n  \n  class Foo\n\n    \n\n    \n    def initialize\n    end\n  end\nend\n", "target": "\n\n\npublic static class XMLSystem\n{\n    static XMLSystem()\n    {\n        \n    }\n\n    \n    \n    \n    \n    \n    public static XmlDocument GetXML(string name) \n    {\n        return null;\n    }\n}\n"}
{"id": 86106, "name": "Documentation", "source": "Translate Ruby to Java: \n\nmodule Documentation\n\n  \n  class Foo\n\n    \n\n    \n    def initialize\n    end\n  end\nend\n", "target": "\npublic class Doc{\n   \n   private String field;\n\n   \n   public int method(long num) throws BadException{\n      \n   }\n}\n"}
{"id": 86107, "name": "Documentation", "source": "Translate Ruby to Python: \n\nmodule Documentation\n\n  \n  class Foo\n\n    \n\n    \n    def initialize\n    end\n  end\nend\n", "target": "class Doc(object):\n   \n   def method(self, num):\n      \n      pass\n"}
{"id": 86331, "name": "Rename a file", "source": "Translate Ruby to C#: File.rename('input.txt', 'output.txt')\nFile.rename('/input.txt', '/output.txt')\nFile.rename('docs', 'mydocs')\nFile.rename('/docs', '/mydocs')\n", "target": "using System;\nusing System.IO;\n\nclass Program {\n    static void Main(string[] args) {\n        File.Move(\"input.txt\",\"output.txt\");\n        File.Move(@\"\\input.txt\",@\"\\output.txt\");\n\n        Directory.Move(\"docs\",\"mydocs\");\n        Directory.Move(@\"\\docs\",@\"\\mydocs\");\n    }\n}\n"}
{"id": 86333, "name": "Rename a file", "source": "Translate Ruby to Java: File.rename('input.txt', 'output.txt')\nFile.rename('/input.txt', '/output.txt')\nFile.rename('docs', 'mydocs')\nFile.rename('/docs', '/mydocs')\n", "target": "import java.io.File;\npublic class FileRenameTest {\n   public static boolean renameFile(String oldname, String newname) {\n       \n       File file = new File(oldname);\n   \n       \n       File file2 = new File(newname);\n   \n       \n       boolean success = file.renameTo(file2);\n       return success;\n   }\n   public static void test(String type, String oldname, String newname) {\n       System.out.println(\"The following \" + type + \" called \" + oldname +\n           ( renameFile(oldname, newname) ? \" was renamed as \" : \" could not be renamed into \")\n           + newname + \".\"\n       );\n   }\n   public static void main(String args[]) {\n        test(\"file\", \"input.txt\", \"output.txt\");\n        test(\"file\", File.separator + \"input.txt\", File.separator + \"output.txt\");\n        test(\"directory\", \"docs\", \"mydocs\");\n        test(\"directory\", File.separator + \"docs\" + File.separator, File.separator + \"mydocs\" + File.separator);\n   }\n}\n"}
{"id": 86334, "name": "Rename a file", "source": "Translate Ruby to Python: File.rename('input.txt', 'output.txt')\nFile.rename('/input.txt', '/output.txt')\nFile.rename('docs', 'mydocs')\nFile.rename('/docs', '/mydocs')\n", "target": "from java.io import File\n\ndef setup():\n    \n    sketchfile = rename(sketchPath(\"input.txt\"), sketchPath(\"output.txt\"))\n    \n    sketchfold = rename(sketchPath(\"docs\"), sketchPath(\"mydocs\"))\n    \n    rootfile = rename(\"input.txt\", \"output.txt\")\n    \n    rootfold = rename(\"docs\", \"mydocs\")\n\n    \n    println(str(sketchfile) + ' ' +\n            str(sketchfold) + ' ' +\n            str(rootfile) +  ' ' +\n            str(rootfold)) \n    \n    \n\n\ndef rename(oldname, newname):\n    \n    file = File(oldname)\n    \n    file2 = File(newname)\n    \n    success = file.renameTo(file2)\n    return success\n"}
{"id": 86565, "name": "Vigen\u00e8re cipher", "source": "Translate Ruby to C#: module VigenereCipher\n  \n  BASE = 'A'.ord\n  SIZE = 'Z'.ord - BASE + 1\n  \n  def encrypt(text, key)\n    crypt(text, key, :+)\n  end\n  \n  def decrypt(text, key)\n    crypt(text, key, :-)\n  end\n  \n  def crypt(text, key, dir)\n    text = text.upcase.gsub(/[^A-Z]/, '')\n    key_iterator = key.upcase.gsub(/[^A-Z]/, '').chars.map{|c| c.ord - BASE}.cycle\n    text.each_char.inject('') do |ciphertext, char|\n      offset = key_iterator.next\n      ciphertext << ((char.ord - BASE).send(dir, offset) % SIZE + BASE).chr\n    end\n  end\n  \nend\n", "target": "using System;\n\nnamespace VigenereCipher\n{\n    class VCipher\n    {\n        public string encrypt(string txt, string pw, int d)\n        {\n            int pwi = 0, tmp;\n            string ns = \"\";\n            txt = txt.ToUpper();\n            pw = pw.ToUpper();\n            foreach (char t in txt)\n            {\n                if (t < 65) continue;\n                tmp = t - 65 + d * (pw[pwi] - 65);\n                if (tmp < 0) tmp += 26;\n                ns += Convert.ToChar(65 + ( tmp % 26) );\n                if (++pwi == pw.Length) pwi = 0;\n            }\n\n            return ns;\n        }\n    };\n\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            VCipher v = new VCipher();\n\n            string s0 = \"Beware the Jabberwock, my son! The jaws that bite, the claws that catch!\",\n                   pw = \"VIGENERECIPHER\";\n\n            Console.WriteLine(s0 + \"\\n\" + pw + \"\\n\");\n            string s1 = v.encrypt(s0, pw, 1);\n            Console.WriteLine(\"Encrypted: \" + s1);\n            s1 = v.encrypt(s1, \"VIGENERECIPHER\", -1);\n            Console.WriteLine(\"Decrypted: \" + s1);\n            Console.WriteLine(\"\\nPress any key to continue...\");\n            Console.ReadKey();\n        }\n    }\n}\n"}
{"id": 86567, "name": "Vigen\u00e8re cipher", "source": "Translate Ruby to Java: module VigenereCipher\n  \n  BASE = 'A'.ord\n  SIZE = 'Z'.ord - BASE + 1\n  \n  def encrypt(text, key)\n    crypt(text, key, :+)\n  end\n  \n  def decrypt(text, key)\n    crypt(text, key, :-)\n  end\n  \n  def crypt(text, key, dir)\n    text = text.upcase.gsub(/[^A-Z]/, '')\n    key_iterator = key.upcase.gsub(/[^A-Z]/, '').chars.map{|c| c.ord - BASE}.cycle\n    text.each_char.inject('') do |ciphertext, char|\n      offset = key_iterator.next\n      ciphertext << ((char.ord - BASE).send(dir, offset) % SIZE + BASE).chr\n    end\n  end\n  \nend\n", "target": "public class VigenereCipher {\n    public static void main(String[] args) {\n        String key = \"VIGENERECIPHER\";\n        String ori = \"Beware the Jabberwock, my son! The jaws that bite, the claws that catch!\";\n        String enc = encrypt(ori, key);\n        System.out.println(enc);\n        System.out.println(decrypt(enc, key));\n    }\n\n    static String encrypt(String text, final String key) {\n        String res = \"\";\n        text = text.toUpperCase();\n        for (int i = 0, j = 0; i < text.length(); i++) {\n            char c = text.charAt(i);\n            if (c < 'A' || c > 'Z') continue;\n            res += (char)((c + key.charAt(j) - 2 * 'A') % 26 + 'A');\n            j = ++j % key.length();\n        }\n        return res;\n    }\n\n    static String decrypt(String text, final String key) {\n        String res = \"\";\n        text = text.toUpperCase();\n        for (int i = 0, j = 0; i < text.length(); i++) {\n            char c = text.charAt(i);\n            if (c < 'A' || c > 'Z') continue;\n            res += (char)((c - key.charAt(j) + 26) % 26 + 'A');\n            j = ++j % key.length();\n        }\n        return res;\n    }\n}\n"}
{"id": 86568, "name": "Vigen\u00e8re cipher", "source": "Translate Ruby to Python: module VigenereCipher\n  \n  BASE = 'A'.ord\n  SIZE = 'Z'.ord - BASE + 1\n  \n  def encrypt(text, key)\n    crypt(text, key, :+)\n  end\n  \n  def decrypt(text, key)\n    crypt(text, key, :-)\n  end\n  \n  def crypt(text, key, dir)\n    text = text.upcase.gsub(/[^A-Z]/, '')\n    key_iterator = key.upcase.gsub(/[^A-Z]/, '').chars.map{|c| c.ord - BASE}.cycle\n    text.each_char.inject('') do |ciphertext, char|\n      offset = key_iterator.next\n      ciphertext << ((char.ord - BASE).send(dir, offset) % SIZE + BASE).chr\n    end\n  end\n  \nend\n", "target": "\n\nfrom itertools import starmap, cycle\n\n\ndef encrypt(message, key):\n    \n\n    \n    \n    message = filter(str.isalpha, message.upper())\n\n    def enc(c, k):\n        \n\n        return chr(((ord(k) + ord(c) - 2 * ord('A')) % 26) + ord('A'))\n\n    return ''.join(starmap(enc, zip(message, cycle(key))))\n\n\ndef decrypt(message, key):\n    \n\n    def dec(c, k):\n        \n\n        return chr(((ord(c) - ord(k) - 2 * ord('A')) % 26) + ord('A'))\n\n    return ''.join(starmap(dec, zip(message, cycle(key))))\n\n\ndef main():\n    \n\n    text = 'Beware the Jabberwock, my son! The jaws that bite, ' + (\n           'the claws that catch!'\n    )\n    key = 'VIGENERECIPHER'\n\n    encr = encrypt(text, key)\n    decr = decrypt(encr, key)\n\n    print(text)\n    print(encr)\n    print(decr)\n\n\nif __name__ == '__main__':\n    main()\n"}
{"id": 86924, "name": "Chinese zodiac", "source": "Translate Ruby to C#: \npinyin = {\n  '\u7532' => 'ji\u0103',\n  '\u4e59' => 'y\u012d',\n  '\u4e19' => 'b\u012dng',\n  '\u4e01' => 'd\u012bng',\n  '\u620a' => 'w\u00f9',\n  '\u5df1' => 'j\u012d',\n  '\u5e9a' => 'g\u0113ng',\n  '\u8f9b' => 'x\u012bn',\n  '\u58ec' => 'r\u00e9n',\n  '\u7678' => 'g\u016di',\n\n  '\u5b50' => 'z\u012d',\n  '\u4e11' => 'ch\u014fu',\n  '\u5bc5' => 'y\u00edn',\n  '\u536f' => 'm\u0103o',\n  '\u8fb0' => 'ch\u00e9n',\n  '\u5df3' => 's\u00ec',\n  '\u5348' => 'w\u016d',\n  '\u672a' => 'w\u00e8i',\n  '\u7533' => 'sh\u0113n',\n  '\u9149' => 'y\u014fu',\n  '\u620c' => 'x\u016b',\n  '\u4ea5' => 'h\u00e0i'\n}\ncelestial     = %w(\u7532 \u4e59 \u4e19 \u4e01 \u620a \u5df1 \u5e9a \u8f9b \u58ec \u7678)\nterrestrial   = %w(\u5b50 \u4e11 \u5bc5 \u536f \u8fb0 \u5df3 \u5348 \u672a \u7533 \u9149 \u620c \u4ea5)\nanimals       = %w(Rat   Ox   Tiger  Rabbit  Dragon Snake\n                   Horse Goat Monkey Rooster Dog    Pig)\nelements      = %w(Wood Fire Earth Metal Water)\naspects       = %w(yang yin)\n\nBASE = 4\n\nargs = if !ARGV.empty?\n         ARGV\n       else\n         [Time.new.year]\n       end\n\nargs.each do |arg|\n  ce_year = Integer(arg)\n  print \"\n  cycle_year     = ce_year - BASE\n\n  stem_number    = cycle_year % 10\n  stem_han       = celestial[stem_number]\n  stem_pinyin    = pinyin[stem_han]\n\n  element_number = stem_number / 2\n  element        = elements[element_number]\n\n  branch_number  = cycle_year % 12\n  branch_han     = terrestrial[branch_number]\n  branch_pinyin  = pinyin[branch_han]\n  animal         = animals[branch_number]\n\n  aspect_number = cycle_year % 2\n  aspect        = aspects[aspect_number]\n\n  index         = cycle_year % 60 + 1\n\n  print stem_han, branch_han\n  puts \" (\nend\n", "target": "using System;\n\nnamespace ChineseZodiac {\n    class Program {\n        static string[] animals = { \"Rat\", \"Ox\", \"Tiger\", \"Rabbit\", \"Dragon\", \"Snake\", \"Horse\", \"Goat\", \"Monkey\", \"Rooster\", \"Dog\", \"Pig\" };\n        static string[] elements = { \"Wood\", \"Fire\", \"Earth\", \"Metal\", \"Water\" };\n        static string[] animalChars = { \"\u5b50\", \"\u4e11\", \"\u5bc5\", \"\u536f\", \"\u8fb0\", \"\u5df3\", \"\u5348\", \"\u672a\", \"\u7533\", \"\u9149\", \"\u620c\", \"\u4ea5\" };\n        static string[,] elementChars = { { \"\u7532\", \"\u4e19\", \"\u620a\", \"\u5e9a\", \"\u58ec\" }, { \"\u4e59\", \"\u4e01\", \"\u5df1\", \"\u8f9b\", \"\u7678\" } };\n\n        static string getYY(int year) {\n            if (year % 2 == 0) {\n                return \"yang\";\n            }\n            return \"yin\";\n        }\n\n        static void Main(string[] args) {\n            Console.OutputEncoding = System.Text.Encoding.UTF8;\n            int[] years = { 1935, 1938, 1968, 1972, 1976, 1984, 1985, 2017 };\n            for (int i = 0; i < years.Length; i++) {\n                int ei = (int)Math.Floor((years[i] - 4.0) % 10 / 2);\n                int ai = (years[i] - 4) % 12;\n                Console.WriteLine(\"{0} is the year of the {1} {2} ({3}). {4}{5}\", years[i], elements[ei], animals[ai], getYY(years[i]), elementChars[years[i] % 2, ei], animalChars[(years[i] - 4) % 12]);\n            }\n        }\n    }\n}\n"}
{"id": 86925, "name": "Chinese zodiac", "source": "Translate Ruby to C#: \npinyin = {\n  '\u7532' => 'ji\u0103',\n  '\u4e59' => 'y\u012d',\n  '\u4e19' => 'b\u012dng',\n  '\u4e01' => 'd\u012bng',\n  '\u620a' => 'w\u00f9',\n  '\u5df1' => 'j\u012d',\n  '\u5e9a' => 'g\u0113ng',\n  '\u8f9b' => 'x\u012bn',\n  '\u58ec' => 'r\u00e9n',\n  '\u7678' => 'g\u016di',\n\n  '\u5b50' => 'z\u012d',\n  '\u4e11' => 'ch\u014fu',\n  '\u5bc5' => 'y\u00edn',\n  '\u536f' => 'm\u0103o',\n  '\u8fb0' => 'ch\u00e9n',\n  '\u5df3' => 's\u00ec',\n  '\u5348' => 'w\u016d',\n  '\u672a' => 'w\u00e8i',\n  '\u7533' => 'sh\u0113n',\n  '\u9149' => 'y\u014fu',\n  '\u620c' => 'x\u016b',\n  '\u4ea5' => 'h\u00e0i'\n}\ncelestial     = %w(\u7532 \u4e59 \u4e19 \u4e01 \u620a \u5df1 \u5e9a \u8f9b \u58ec \u7678)\nterrestrial   = %w(\u5b50 \u4e11 \u5bc5 \u536f \u8fb0 \u5df3 \u5348 \u672a \u7533 \u9149 \u620c \u4ea5)\nanimals       = %w(Rat   Ox   Tiger  Rabbit  Dragon Snake\n                   Horse Goat Monkey Rooster Dog    Pig)\nelements      = %w(Wood Fire Earth Metal Water)\naspects       = %w(yang yin)\n\nBASE = 4\n\nargs = if !ARGV.empty?\n         ARGV\n       else\n         [Time.new.year]\n       end\n\nargs.each do |arg|\n  ce_year = Integer(arg)\n  print \"\n  cycle_year     = ce_year - BASE\n\n  stem_number    = cycle_year % 10\n  stem_han       = celestial[stem_number]\n  stem_pinyin    = pinyin[stem_han]\n\n  element_number = stem_number / 2\n  element        = elements[element_number]\n\n  branch_number  = cycle_year % 12\n  branch_han     = terrestrial[branch_number]\n  branch_pinyin  = pinyin[branch_han]\n  animal         = animals[branch_number]\n\n  aspect_number = cycle_year % 2\n  aspect        = aspects[aspect_number]\n\n  index         = cycle_year % 60 + 1\n\n  print stem_han, branch_han\n  puts \" (\nend\n", "target": "using System;\n\nnamespace ChineseZodiac {\n    class Program {\n        static string[] animals = { \"Rat\", \"Ox\", \"Tiger\", \"Rabbit\", \"Dragon\", \"Snake\", \"Horse\", \"Goat\", \"Monkey\", \"Rooster\", \"Dog\", \"Pig\" };\n        static string[] elements = { \"Wood\", \"Fire\", \"Earth\", \"Metal\", \"Water\" };\n        static string[] animalChars = { \"\u5b50\", \"\u4e11\", \"\u5bc5\", \"\u536f\", \"\u8fb0\", \"\u5df3\", \"\u5348\", \"\u672a\", \"\u7533\", \"\u9149\", \"\u620c\", \"\u4ea5\" };\n        static string[,] elementChars = { { \"\u7532\", \"\u4e19\", \"\u620a\", \"\u5e9a\", \"\u58ec\" }, { \"\u4e59\", \"\u4e01\", \"\u5df1\", \"\u8f9b\", \"\u7678\" } };\n\n        static string getYY(int year) {\n            if (year % 2 == 0) {\n                return \"yang\";\n            }\n            return \"yin\";\n        }\n\n        static void Main(string[] args) {\n            Console.OutputEncoding = System.Text.Encoding.UTF8;\n            int[] years = { 1935, 1938, 1968, 1972, 1976, 1984, 1985, 2017 };\n            for (int i = 0; i < years.Length; i++) {\n                int ei = (int)Math.Floor((years[i] - 4.0) % 10 / 2);\n                int ai = (years[i] - 4) % 12;\n                Console.WriteLine(\"{0} is the year of the {1} {2} ({3}). {4}{5}\", years[i], elements[ei], animals[ai], getYY(years[i]), elementChars[years[i] % 2, ei], animalChars[(years[i] - 4) % 12]);\n            }\n        }\n    }\n}\n"}
{"id": 86928, "name": "Chinese zodiac", "source": "Translate Ruby to Java: \npinyin = {\n  '\u7532' => 'ji\u0103',\n  '\u4e59' => 'y\u012d',\n  '\u4e19' => 'b\u012dng',\n  '\u4e01' => 'd\u012bng',\n  '\u620a' => 'w\u00f9',\n  '\u5df1' => 'j\u012d',\n  '\u5e9a' => 'g\u0113ng',\n  '\u8f9b' => 'x\u012bn',\n  '\u58ec' => 'r\u00e9n',\n  '\u7678' => 'g\u016di',\n\n  '\u5b50' => 'z\u012d',\n  '\u4e11' => 'ch\u014fu',\n  '\u5bc5' => 'y\u00edn',\n  '\u536f' => 'm\u0103o',\n  '\u8fb0' => 'ch\u00e9n',\n  '\u5df3' => 's\u00ec',\n  '\u5348' => 'w\u016d',\n  '\u672a' => 'w\u00e8i',\n  '\u7533' => 'sh\u0113n',\n  '\u9149' => 'y\u014fu',\n  '\u620c' => 'x\u016b',\n  '\u4ea5' => 'h\u00e0i'\n}\ncelestial     = %w(\u7532 \u4e59 \u4e19 \u4e01 \u620a \u5df1 \u5e9a \u8f9b \u58ec \u7678)\nterrestrial   = %w(\u5b50 \u4e11 \u5bc5 \u536f \u8fb0 \u5df3 \u5348 \u672a \u7533 \u9149 \u620c \u4ea5)\nanimals       = %w(Rat   Ox   Tiger  Rabbit  Dragon Snake\n                   Horse Goat Monkey Rooster Dog    Pig)\nelements      = %w(Wood Fire Earth Metal Water)\naspects       = %w(yang yin)\n\nBASE = 4\n\nargs = if !ARGV.empty?\n         ARGV\n       else\n         [Time.new.year]\n       end\n\nargs.each do |arg|\n  ce_year = Integer(arg)\n  print \"\n  cycle_year     = ce_year - BASE\n\n  stem_number    = cycle_year % 10\n  stem_han       = celestial[stem_number]\n  stem_pinyin    = pinyin[stem_han]\n\n  element_number = stem_number / 2\n  element        = elements[element_number]\n\n  branch_number  = cycle_year % 12\n  branch_han     = terrestrial[branch_number]\n  branch_pinyin  = pinyin[branch_han]\n  animal         = animals[branch_number]\n\n  aspect_number = cycle_year % 2\n  aspect        = aspects[aspect_number]\n\n  index         = cycle_year % 60 + 1\n\n  print stem_han, branch_han\n  puts \" (\nend\n", "target": "public class Zodiac {\n\n\tfinal static String animals[]={\"Rat\",\"Ox\",\"Tiger\",\"Rabbit\",\"Dragon\",\"Snake\",\"Horse\",\"Goat\",\"Monkey\",\"Rooster\",\"Dog\",\"Pig\"};\n\tfinal static String elements[]={\"Wood\",\"Fire\",\"Earth\",\"Metal\",\"Water\"};\n\tfinal static String animalChars[]={\"\u5b50\",\"\u4e11\",\"\u5bc5\",\"\u536f\",\"\u8fb0\",\"\u5df3\",\"\u5348\",\"\u672a\",\"\u7533\",\"\u9149\",\"\u620c\",\"\u4ea5\"};\n\tstatic String elementChars[][]={{\"\u7532\",\"\u4e19\",\"\u620a\",\"\u5e9a\",\"\u58ec\"},{\"\u4e59\",\"\u4e01\",\"\u5df1\",\"\u8f9b\",\"\u7678\"}};\n\n\tstatic String getYY(int year)\n\t{\n\t    if(year%2==0)\n\t    {\n\t        return \"yang\";\n\t    }\n\t    else\n\t    {\n\t        return \"yin\";\n\t    }\n\t}\n\n\tpublic static void main(String[] args)\n\t{\n\t\tint years[]={1935,1938,1968,1972,1976,1984,1985,2017};\n\t\tfor(int i=0;i<years.length;i++)\n\t\t{\n\t\t\tSystem.out.println(years[i]+\" is the year of the \"+elements[(int) Math.floor((years[i]-4)%10/2)]+\" \"+animals[(years[i]-4)%12]+\" (\"+getYY(years[i])+\"). \"+elementChars[years[i]%2][(int) Math.floor((years[i]-4)%10/2)]+animalChars[(years[i]-4)%12]);\n\t\t}\n\t}\n}\n"}
{"id": 86929, "name": "Chinese zodiac", "source": "Translate Ruby to Java: \npinyin = {\n  '\u7532' => 'ji\u0103',\n  '\u4e59' => 'y\u012d',\n  '\u4e19' => 'b\u012dng',\n  '\u4e01' => 'd\u012bng',\n  '\u620a' => 'w\u00f9',\n  '\u5df1' => 'j\u012d',\n  '\u5e9a' => 'g\u0113ng',\n  '\u8f9b' => 'x\u012bn',\n  '\u58ec' => 'r\u00e9n',\n  '\u7678' => 'g\u016di',\n\n  '\u5b50' => 'z\u012d',\n  '\u4e11' => 'ch\u014fu',\n  '\u5bc5' => 'y\u00edn',\n  '\u536f' => 'm\u0103o',\n  '\u8fb0' => 'ch\u00e9n',\n  '\u5df3' => 's\u00ec',\n  '\u5348' => 'w\u016d',\n  '\u672a' => 'w\u00e8i',\n  '\u7533' => 'sh\u0113n',\n  '\u9149' => 'y\u014fu',\n  '\u620c' => 'x\u016b',\n  '\u4ea5' => 'h\u00e0i'\n}\ncelestial     = %w(\u7532 \u4e59 \u4e19 \u4e01 \u620a \u5df1 \u5e9a \u8f9b \u58ec \u7678)\nterrestrial   = %w(\u5b50 \u4e11 \u5bc5 \u536f \u8fb0 \u5df3 \u5348 \u672a \u7533 \u9149 \u620c \u4ea5)\nanimals       = %w(Rat   Ox   Tiger  Rabbit  Dragon Snake\n                   Horse Goat Monkey Rooster Dog    Pig)\nelements      = %w(Wood Fire Earth Metal Water)\naspects       = %w(yang yin)\n\nBASE = 4\n\nargs = if !ARGV.empty?\n         ARGV\n       else\n         [Time.new.year]\n       end\n\nargs.each do |arg|\n  ce_year = Integer(arg)\n  print \"\n  cycle_year     = ce_year - BASE\n\n  stem_number    = cycle_year % 10\n  stem_han       = celestial[stem_number]\n  stem_pinyin    = pinyin[stem_han]\n\n  element_number = stem_number / 2\n  element        = elements[element_number]\n\n  branch_number  = cycle_year % 12\n  branch_han     = terrestrial[branch_number]\n  branch_pinyin  = pinyin[branch_han]\n  animal         = animals[branch_number]\n\n  aspect_number = cycle_year % 2\n  aspect        = aspects[aspect_number]\n\n  index         = cycle_year % 60 + 1\n\n  print stem_han, branch_han\n  puts \" (\nend\n", "target": "public class Zodiac {\n\n\tfinal static String animals[]={\"Rat\",\"Ox\",\"Tiger\",\"Rabbit\",\"Dragon\",\"Snake\",\"Horse\",\"Goat\",\"Monkey\",\"Rooster\",\"Dog\",\"Pig\"};\n\tfinal static String elements[]={\"Wood\",\"Fire\",\"Earth\",\"Metal\",\"Water\"};\n\tfinal static String animalChars[]={\"\u5b50\",\"\u4e11\",\"\u5bc5\",\"\u536f\",\"\u8fb0\",\"\u5df3\",\"\u5348\",\"\u672a\",\"\u7533\",\"\u9149\",\"\u620c\",\"\u4ea5\"};\n\tstatic String elementChars[][]={{\"\u7532\",\"\u4e19\",\"\u620a\",\"\u5e9a\",\"\u58ec\"},{\"\u4e59\",\"\u4e01\",\"\u5df1\",\"\u8f9b\",\"\u7678\"}};\n\n\tstatic String getYY(int year)\n\t{\n\t    if(year%2==0)\n\t    {\n\t        return \"yang\";\n\t    }\n\t    else\n\t    {\n\t        return \"yin\";\n\t    }\n\t}\n\n\tpublic static void main(String[] args)\n\t{\n\t\tint years[]={1935,1938,1968,1972,1976,1984,1985,2017};\n\t\tfor(int i=0;i<years.length;i++)\n\t\t{\n\t\t\tSystem.out.println(years[i]+\" is the year of the \"+elements[(int) Math.floor((years[i]-4)%10/2)]+\" \"+animals[(years[i]-4)%12]+\" (\"+getYY(years[i])+\"). \"+elementChars[years[i]%2][(int) Math.floor((years[i]-4)%10/2)]+animalChars[(years[i]-4)%12]);\n\t\t}\n\t}\n}\n"}
{"id": 86930, "name": "Chinese zodiac", "source": "Translate Ruby to Python: \npinyin = {\n  '\u7532' => 'ji\u0103',\n  '\u4e59' => 'y\u012d',\n  '\u4e19' => 'b\u012dng',\n  '\u4e01' => 'd\u012bng',\n  '\u620a' => 'w\u00f9',\n  '\u5df1' => 'j\u012d',\n  '\u5e9a' => 'g\u0113ng',\n  '\u8f9b' => 'x\u012bn',\n  '\u58ec' => 'r\u00e9n',\n  '\u7678' => 'g\u016di',\n\n  '\u5b50' => 'z\u012d',\n  '\u4e11' => 'ch\u014fu',\n  '\u5bc5' => 'y\u00edn',\n  '\u536f' => 'm\u0103o',\n  '\u8fb0' => 'ch\u00e9n',\n  '\u5df3' => 's\u00ec',\n  '\u5348' => 'w\u016d',\n  '\u672a' => 'w\u00e8i',\n  '\u7533' => 'sh\u0113n',\n  '\u9149' => 'y\u014fu',\n  '\u620c' => 'x\u016b',\n  '\u4ea5' => 'h\u00e0i'\n}\ncelestial     = %w(\u7532 \u4e59 \u4e19 \u4e01 \u620a \u5df1 \u5e9a \u8f9b \u58ec \u7678)\nterrestrial   = %w(\u5b50 \u4e11 \u5bc5 \u536f \u8fb0 \u5df3 \u5348 \u672a \u7533 \u9149 \u620c \u4ea5)\nanimals       = %w(Rat   Ox   Tiger  Rabbit  Dragon Snake\n                   Horse Goat Monkey Rooster Dog    Pig)\nelements      = %w(Wood Fire Earth Metal Water)\naspects       = %w(yang yin)\n\nBASE = 4\n\nargs = if !ARGV.empty?\n         ARGV\n       else\n         [Time.new.year]\n       end\n\nargs.each do |arg|\n  ce_year = Integer(arg)\n  print \"\n  cycle_year     = ce_year - BASE\n\n  stem_number    = cycle_year % 10\n  stem_han       = celestial[stem_number]\n  stem_pinyin    = pinyin[stem_han]\n\n  element_number = stem_number / 2\n  element        = elements[element_number]\n\n  branch_number  = cycle_year % 12\n  branch_han     = terrestrial[branch_number]\n  branch_pinyin  = pinyin[branch_han]\n  animal         = animals[branch_number]\n\n  aspect_number = cycle_year % 2\n  aspect        = aspects[aspect_number]\n\n  index         = cycle_year % 60 + 1\n\n  print stem_han, branch_han\n  puts \" (\nend\n", "target": "\n\nfrom __future__ import print_function\nfrom datetime import datetime\n\npinyin = {\n  '\u7532': 'ji\u0103',\n  '\u4e59': 'y\u012d',\n  '\u4e19': 'b\u012dng',\n  '\u4e01': 'd\u012bng',\n  '\u620a': 'w\u00f9',\n  '\u5df1': 'j\u012d',\n  '\u5e9a': 'g\u0113ng',\n  '\u8f9b': 'x\u012bn',\n  '\u58ec': 'r\u00e9n',\n  '\u7678': 'g\u016di',\n\n  '\u5b50': 'z\u012d',\n  '\u4e11': 'ch\u014fu',\n  '\u5bc5': 'y\u00edn',\n  '\u536f': 'm\u0103o',\n  '\u8fb0': 'ch\u00e9n',\n  '\u5df3': 's\u00ec',\n  '\u5348': 'w\u016d',\n  '\u672a': 'w\u00e8i',\n  '\u7533': 'sh\u0113n',\n  '\u9149': 'y\u014fu',\n  '\u620c': 'x\u016b',\n  '\u4ea5': 'h\u00e0i'\n}\n\nanimals = ['Rat', 'Ox', 'Tiger', 'Rabbit', 'Dragon', 'Snake',\n           'Horse', 'Goat', 'Monkey', 'Rooster', 'Dog', 'Pig']\nelements = ['Wood', 'Fire', 'Earth', 'Metal', 'Water']\n\ncelestial = ['\u7532', '\u4e59', '\u4e19', '\u4e01', '\u620a', '\u5df1', '\u5e9a', '\u8f9b', '\u58ec', '\u7678']\nterrestrial = ['\u5b50', '\u4e11', '\u5bc5', '\u536f', '\u8fb0', '\u5df3', '\u5348', '\u672a', '\u7533', '\u9149', '\u620c', '\u4ea5']\naspects = ['yang', 'yin']\n\n\ndef calculate(year):\n    BASE = 4\n    year = int(year)\n    cycle_year = year - BASE\n    stem_number = cycle_year % 10\n    stem_han = celestial[stem_number]\n    stem_pinyin = pinyin[stem_han]\n    element_number = stem_number // 2\n    element = elements[element_number]\n    branch_number = cycle_year % 12\n    branch_han = terrestrial[branch_number]\n    branch_pinyin = pinyin[branch_han]\n    animal = animals[branch_number]\n    aspect_number = cycle_year % 2\n    aspect = aspects[aspect_number]\n    index = cycle_year % 60 + 1\n    print(\"{}: {}{} ({}-{}, {} {}; {} - year {} of the cycle)\"\n          .format(year, stem_han, branch_han,\n                  stem_pinyin, branch_pinyin, element, animal, aspect, index))\n\n\ncurrent_year = datetime.now().year\nyears = [1935, 1938, 1968, 1972, 1976, current_year]\nfor year in years:\n    calculate(year)\n"}
{"id": 86931, "name": "Chinese zodiac", "source": "Translate Ruby to Python: \npinyin = {\n  '\u7532' => 'ji\u0103',\n  '\u4e59' => 'y\u012d',\n  '\u4e19' => 'b\u012dng',\n  '\u4e01' => 'd\u012bng',\n  '\u620a' => 'w\u00f9',\n  '\u5df1' => 'j\u012d',\n  '\u5e9a' => 'g\u0113ng',\n  '\u8f9b' => 'x\u012bn',\n  '\u58ec' => 'r\u00e9n',\n  '\u7678' => 'g\u016di',\n\n  '\u5b50' => 'z\u012d',\n  '\u4e11' => 'ch\u014fu',\n  '\u5bc5' => 'y\u00edn',\n  '\u536f' => 'm\u0103o',\n  '\u8fb0' => 'ch\u00e9n',\n  '\u5df3' => 's\u00ec',\n  '\u5348' => 'w\u016d',\n  '\u672a' => 'w\u00e8i',\n  '\u7533' => 'sh\u0113n',\n  '\u9149' => 'y\u014fu',\n  '\u620c' => 'x\u016b',\n  '\u4ea5' => 'h\u00e0i'\n}\ncelestial     = %w(\u7532 \u4e59 \u4e19 \u4e01 \u620a \u5df1 \u5e9a \u8f9b \u58ec \u7678)\nterrestrial   = %w(\u5b50 \u4e11 \u5bc5 \u536f \u8fb0 \u5df3 \u5348 \u672a \u7533 \u9149 \u620c \u4ea5)\nanimals       = %w(Rat   Ox   Tiger  Rabbit  Dragon Snake\n                   Horse Goat Monkey Rooster Dog    Pig)\nelements      = %w(Wood Fire Earth Metal Water)\naspects       = %w(yang yin)\n\nBASE = 4\n\nargs = if !ARGV.empty?\n         ARGV\n       else\n         [Time.new.year]\n       end\n\nargs.each do |arg|\n  ce_year = Integer(arg)\n  print \"\n  cycle_year     = ce_year - BASE\n\n  stem_number    = cycle_year % 10\n  stem_han       = celestial[stem_number]\n  stem_pinyin    = pinyin[stem_han]\n\n  element_number = stem_number / 2\n  element        = elements[element_number]\n\n  branch_number  = cycle_year % 12\n  branch_han     = terrestrial[branch_number]\n  branch_pinyin  = pinyin[branch_han]\n  animal         = animals[branch_number]\n\n  aspect_number = cycle_year % 2\n  aspect        = aspects[aspect_number]\n\n  index         = cycle_year % 60 + 1\n\n  print stem_han, branch_han\n  puts \" (\nend\n", "target": "\n\nfrom __future__ import print_function\nfrom datetime import datetime\n\npinyin = {\n  '\u7532': 'ji\u0103',\n  '\u4e59': 'y\u012d',\n  '\u4e19': 'b\u012dng',\n  '\u4e01': 'd\u012bng',\n  '\u620a': 'w\u00f9',\n  '\u5df1': 'j\u012d',\n  '\u5e9a': 'g\u0113ng',\n  '\u8f9b': 'x\u012bn',\n  '\u58ec': 'r\u00e9n',\n  '\u7678': 'g\u016di',\n\n  '\u5b50': 'z\u012d',\n  '\u4e11': 'ch\u014fu',\n  '\u5bc5': 'y\u00edn',\n  '\u536f': 'm\u0103o',\n  '\u8fb0': 'ch\u00e9n',\n  '\u5df3': 's\u00ec',\n  '\u5348': 'w\u016d',\n  '\u672a': 'w\u00e8i',\n  '\u7533': 'sh\u0113n',\n  '\u9149': 'y\u014fu',\n  '\u620c': 'x\u016b',\n  '\u4ea5': 'h\u00e0i'\n}\n\nanimals = ['Rat', 'Ox', 'Tiger', 'Rabbit', 'Dragon', 'Snake',\n           'Horse', 'Goat', 'Monkey', 'Rooster', 'Dog', 'Pig']\nelements = ['Wood', 'Fire', 'Earth', 'Metal', 'Water']\n\ncelestial = ['\u7532', '\u4e59', '\u4e19', '\u4e01', '\u620a', '\u5df1', '\u5e9a', '\u8f9b', '\u58ec', '\u7678']\nterrestrial = ['\u5b50', '\u4e11', '\u5bc5', '\u536f', '\u8fb0', '\u5df3', '\u5348', '\u672a', '\u7533', '\u9149', '\u620c', '\u4ea5']\naspects = ['yang', 'yin']\n\n\ndef calculate(year):\n    BASE = 4\n    year = int(year)\n    cycle_year = year - BASE\n    stem_number = cycle_year % 10\n    stem_han = celestial[stem_number]\n    stem_pinyin = pinyin[stem_han]\n    element_number = stem_number // 2\n    element = elements[element_number]\n    branch_number = cycle_year % 12\n    branch_han = terrestrial[branch_number]\n    branch_pinyin = pinyin[branch_han]\n    animal = animals[branch_number]\n    aspect_number = cycle_year % 2\n    aspect = aspects[aspect_number]\n    index = cycle_year % 60 + 1\n    print(\"{}: {}{} ({}-{}, {} {}; {} - year {} of the cycle)\"\n          .format(year, stem_han, branch_han,\n                  stem_pinyin, branch_pinyin, element, animal, aspect, index))\n\n\ncurrent_year = datetime.now().year\nyears = [1935, 1938, 1968, 1972, 1976, current_year]\nfor year in years:\n    calculate(year)\n"}
{"id": 87180, "name": "Higher-order functions", "source": "Translate Ruby to C#: succ = proc{|x| x+1}\ndef to2(&f)\n  f[2]\nend\n\nto2(&succ) \nto2{|x| x+1} \n", "target": "using System;\n\n\ndelegate int Func2(int a, int b);\n\nclass Program\n{\n    static int Add(int a, int b)\n    {\n        return a + b;\n    }\n    \n    static int Mul(int a, int b)\n    {\n        return a * b;\n    }\n    \n    static int Div(int a, int b)\n    {\n        return a / b;\n    }\n    \n    static int Call(Func2 f, int a, int b)\n    {\n        \n        return f(a, b);\n    }\n\n    static void Main()\n    {\n        int a = 6;\n        int b = 2;\n\n        \n        Func2 add = new Func2(Add);\n        Func2 mul = new Func2(Mul);\n        Func2 div = new Func2(Div);\n        \n        Console.WriteLine(\"f=Add, f({0}, {1}) = {2}\", a, b, Call(add, a, b));\n        Console.WriteLine(\"f=Mul, f({0}, {1}) = {2}\", a, b, Call(mul, a, b));\n        Console.WriteLine(\"f=Div, f({0}, {1}) = {2}\", a, b, Call(div, a, b));\n    }\n}\n"}
{"id": 87182, "name": "Higher-order functions", "source": "Translate Ruby to Java: succ = proc{|x| x+1}\ndef to2(&f)\n  f[2]\nend\n\nto2(&succ) \nto2{|x| x+1} \n", "target": "public class NewClass {\n   \n   public NewClass() {\n       first(new AnEventOrCallback() {\n           public void call() {\n               second();\n           }\n       });\n   }\n   \n   public void first(AnEventOrCallback obj) {\n       obj.call();\n   }\n   \n   public void second() {\n       System.out.println(\"Second\");\n   }\n   \n   public static void main(String[] args) {\n       new NewClass();\n   }\n}\n\ninterface AnEventOrCallback {\n   public void call();\n}\n"}
{"id": 87183, "name": "Higher-order functions", "source": "Translate Ruby to Python: succ = proc{|x| x+1}\ndef to2(&f)\n  f[2]\nend\n\nto2(&succ) \nto2{|x| x+1} \n", "target": "def first(function):\n    return function()\n\ndef second():\n    return \"second\"\n\nresult = first(second)\n"}
{"id": 87405, "name": "CUSIP", "source": "Translate Ruby to C#: \n\ndef check_cusip(cusip)\n  abort('CUSIP must be 9 characters') if cusip.size != 9\n\n  sum = 0\n  cusip.split('').each_with_index do |char, i|\n    next if i == cusip.size - 1\n    case\n    when char.scan(/\\D/).empty?\n      v = char.to_i\n    when char.scan(/\\D/).any?\n      pos = char.upcase.ord - 'A'.ord + 1\n      v = pos + 9\n    when char == '*'\n      v = 36\n    when char == '@'\n      v = 37\n    when char == '\n      v = 38\n    end\n\n    v *= 2 unless (i % 2).zero?\n    sum += (v/10).to_i + (v % 10)\n  end\n\n  check = (10 - (sum % 10)) % 10\n  return 'VALID' if check.to_s == cusip.split('').last\n  'INVALID'\nend\n\nCUSIPs = %w[\n  037833100 17275R102 38259P508 594918104 68389X106 68389X105\n]\n\nCUSIPs.each do |cusip|\n  puts \"\nend\n", "target": "using System;\nusing System.Collections.Generic;\n\nnamespace CUSIP {\n    class Program {\n        static bool IsCusip(string s) {\n            if (s.Length != 9) return false;\n            int sum = 0;\n            for (int i = 0; i <= 7; i++) {\n                char c = s[i];\n\n                int v;\n                if (c >= '0' && c <= '9') {\n                    v = c - 48;\n                }\n                else if (c >= 'A' && c <= 'Z') {\n                    v = c - 55;  \n                }\n                else if (c == '*') {\n                    v = 36;\n                }\n                else if (c == '#') {\n                    v = 38;\n                }\n                else {\n                    return false;\n                }\n                if (i % 2 == 1) v *= 2;  \n                sum += v / 10 + v % 10;\n            }\n            return s[8] - 48 == (10 - (sum % 10)) % 10;\n        }\n\n        static void Main(string[] args) {\n            List<string> candidates = new List<string>() {\n                \"037833100\",\n                \"17275R102\",\n                \"38259P508\",\n                \"594918104\",\n                \"68389X106\",\n                \"68389X105\"\n            };\n            foreach (var candidate in candidates) {\n                Console.WriteLine(\"{0} -> {1}\", candidate, IsCusip(candidate) ? \"correct\" : \"incorrect\");\n            }\n        }\n    }\n}\n"}
{"id": 87407, "name": "CUSIP", "source": "Translate Ruby to Java: \n\ndef check_cusip(cusip)\n  abort('CUSIP must be 9 characters') if cusip.size != 9\n\n  sum = 0\n  cusip.split('').each_with_index do |char, i|\n    next if i == cusip.size - 1\n    case\n    when char.scan(/\\D/).empty?\n      v = char.to_i\n    when char.scan(/\\D/).any?\n      pos = char.upcase.ord - 'A'.ord + 1\n      v = pos + 9\n    when char == '*'\n      v = 36\n    when char == '@'\n      v = 37\n    when char == '\n      v = 38\n    end\n\n    v *= 2 unless (i % 2).zero?\n    sum += (v/10).to_i + (v % 10)\n  end\n\n  check = (10 - (sum % 10)) % 10\n  return 'VALID' if check.to_s == cusip.split('').last\n  'INVALID'\nend\n\nCUSIPs = %w[\n  037833100 17275R102 38259P508 594918104 68389X106 68389X105\n]\n\nCUSIPs.each do |cusip|\n  puts \"\nend\n", "target": "import java.util.List;\n\npublic class Cusip {\n    private static Boolean isCusip(String s) {\n        if (s.length() != 9) return false;\n        int sum = 0;\n        for (int i = 0; i <= 7; i++) {\n            char c = s.charAt(i);\n\n            int v;\n            if (c >= '0' && c <= '9') {\n                v = c - 48;\n            } else if (c >= 'A' && c <= 'Z') {\n                v = c - 55;  \n            } else if (c == '*') {\n                v = 36;\n            } else if (c == '@') {\n                v = 37;\n            } else if (c == '#') {\n                v = 38;\n            } else {\n                return false;\n            }\n            if (i % 2 == 1) v *= 2;  \n            sum += v / 10 + v % 10;\n        }\n        return s.charAt(8) - 48 == (10 - (sum % 10)) % 10;\n    }\n\n    public static void main(String[] args) {\n        List<String> candidates = List.of(\n                \"037833100\", \"17275R102\", \"38259P508\", \"594918104\", \"68389X106\", \"68389X105\", \"EXTRACRD8\",\n                \"EXTRACRD9\", \"BADCUSIP!\", \"683&9X106\", \"68389x105\", \"683$9X106\", \"68389}105\", \"87264ABE4\"\n        );\n        for (String candidate : candidates) {\n            System.out.printf(\"%s -> %s%n\", candidate, isCusip(candidate) ? \"correct\" : \"incorrect\");\n        }\n    }\n}\n"}
{"id": 87408, "name": "CUSIP", "source": "Translate Ruby to Python: \n\ndef check_cusip(cusip)\n  abort('CUSIP must be 9 characters') if cusip.size != 9\n\n  sum = 0\n  cusip.split('').each_with_index do |char, i|\n    next if i == cusip.size - 1\n    case\n    when char.scan(/\\D/).empty?\n      v = char.to_i\n    when char.scan(/\\D/).any?\n      pos = char.upcase.ord - 'A'.ord + 1\n      v = pos + 9\n    when char == '*'\n      v = 36\n    when char == '@'\n      v = 37\n    when char == '\n      v = 38\n    end\n\n    v *= 2 unless (i % 2).zero?\n    sum += (v/10).to_i + (v % 10)\n  end\n\n  check = (10 - (sum % 10)) % 10\n  return 'VALID' if check.to_s == cusip.split('').last\n  'INVALID'\nend\n\nCUSIPs = %w[\n  037833100 17275R102 38259P508 594918104 68389X106 68389X105\n]\n\nCUSIPs.each do |cusip|\n  puts \"\nend\n", "target": "\n\nimport math\n\ndef cusip_check(cusip):\n    if len(cusip) != 9:\n        raise ValueError('CUSIP must be 9 characters')\n\n    cusip = cusip.upper()\n    total = 0\n    for i in range(8):\n        c = cusip[i]\n        if c.isdigit():\n            v = int(c)\n        elif c.isalpha():\n            p = ord(c) - ord('A') + 1\n            v = p + 9\n        elif c == '*':\n            v = 36\n        elif c == '@':\n            v = 37\n        elif c == '\n            v = 38\n\n        if i % 2 != 0:\n            v *= 2\n\n        total += int(v / 10) + v % 10\n    check = (10 - (total % 10)) % 10\n    return str(check) == cusip[-1]\n\nif __name__ == '__main__':\n    codes = [\n            '037833100',\n            '17275R102',\n            '38259P508',\n            '594918104',\n            '68389X106',\n            '68389X105'\n            ]\n    for code in codes:\n        print(f'{code} -> {cusip_check(code)}')\n"}
{"id": 87552, "name": "Multiplicative order", "source": "Translate Ruby to C#: require 'prime'\n\ndef powerMod(b, p, m)\n  p.to_s(2).each_char.inject(1) do |result, bit|\n    result = (result * result) % m\n    bit=='1' ? (result * b) % m : result\n  end\nend\n\ndef multOrder_(a, p, k)\n  pk = p ** k\n  t = (p - 1) * p ** (k - 1)\n  r = 1\n  for q, e in t.prime_division\n    x = powerMod(a, t / q**e, pk)\n    while x != 1\n      r *= q\n      x = powerMod(x, q, pk)\n    end\n  end      \n  r\nend\n\ndef multOrder(a, m)\n  m.prime_division.inject(1) do |result, f|\n    result.lcm(multOrder_(a, *f))\n  end\nend\n\nputs multOrder(37, 1000)\nb = 10**20-1\nputs multOrder(2, b)\nputs multOrder(17,b)\nb = 100001\nputs multOrder(54,b)\nputs powerMod(54, multOrder(54,b), b)\nif (1...multOrder(54,b)).any? {|r| powerMod(54, r, b) == 1}\n  puts 'Exists a power r < 9090 where powerMod(54,r,b)==1'\nelse\n  puts 'Everything checks.'\nend\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Numerics;\nusing System.Threading;\n\nnamespace MultiplicativeOrder {\n    \n    public static class PrimeExtensions {\n        \n        private static ThreadLocal<Random> s_Gen = new ThreadLocal<Random>(\n          () => {\n              return new Random();\n          }\n        );\n\n        \n        private static Random Gen {\n            get {\n                return s_Gen.Value;\n            }\n        }\n\n        public static bool IsProbablyPrime(this BigInteger value, int witnesses = 10) {\n            if (value <= 1)\n                return false;\n\n            if (witnesses <= 0)\n                witnesses = 10;\n\n            BigInteger d = value - 1;\n            int s = 0;\n\n            while (d % 2 == 0) {\n                d /= 2;\n                s += 1;\n            }\n\n            byte[] bytes = new byte[value.ToByteArray().LongLength];\n            BigInteger a;\n\n            for (int i = 0; i < witnesses; i++) {\n                do {\n                    Gen.NextBytes(bytes);\n\n                    a = new BigInteger(bytes);\n                }\n                while (a < 2 || a >= value - 2);\n\n                BigInteger x = BigInteger.ModPow(a, d, value);\n                if (x == 1 || x == value - 1)\n                    continue;\n\n                for (int r = 1; r < s; r++) {\n                    x = BigInteger.ModPow(x, 2, value);\n\n                    if (x == 1)\n                        return false;\n                    if (x == value - 1)\n                        break;\n                }\n\n                if (x != value - 1)\n                    return false;\n            }\n\n            return true;\n        }\n    }\n\n    static class Helper {\n        public static BigInteger Sqrt(this BigInteger self) {\n            BigInteger b = self;\n            while (true) {\n                BigInteger a = b;\n                b = self / a + a >> 1;\n                if (b >= a) return a;\n            }\n        }\n\n        public static long BitLength(this BigInteger self) {\n            BigInteger bi = self;\n            long bitlength = 0;\n            while (bi != 0) {\n                bitlength++;\n                bi >>= 1;\n            }\n            return bitlength;\n        }\n\n        public static bool BitTest(this BigInteger self, int pos) {\n            byte[] arr = self.ToByteArray();\n            int idx = pos / 8;\n            int mod = pos % 8;\n            if (idx >= arr.Length) {\n                return false;\n            }\n            return (arr[idx] & (1 << mod)) > 0;\n        }\n    }\n\n    class PExp {\n        public PExp(BigInteger prime, int exp) {\n            Prime = prime;\n            Exp = exp;\n        }\n\n        public BigInteger Prime { get; }\n\n        public int Exp { get; }\n    }\n\n    class Program {\n        static void MoTest(BigInteger a, BigInteger n) {\n            if (!n.IsProbablyPrime(20)) {\n                Console.WriteLine(\"Not computed. Modulus must be prime for this algorithm.\");\n                return;\n            }\n            if (a.BitLength() < 100) {\n                Console.Write(\"ord({0})\", a);\n            } else {\n                Console.Write(\"ord([big])\");\n            }\n            if (n.BitLength() < 100) {\n                Console.Write(\" mod {0} \", n);\n            } else {\n                Console.Write(\" mod [big] \");\n            }\n            BigInteger mob = MoBachShallit58(a, n, Factor(n - 1));\n            Console.WriteLine(\"= {0}\", mob);\n        }\n\n        static BigInteger MoBachShallit58(BigInteger a, BigInteger n, List<PExp> pf) {\n            BigInteger n1 = n - 1;\n            BigInteger mo = 1;\n            foreach (PExp pe in pf) {\n                BigInteger y = n1 / BigInteger.Pow(pe.Prime, pe.Exp);\n                int o = 0;\n                BigInteger x = BigInteger.ModPow(a, y, BigInteger.Abs(n));\n                while (x > 1) {\n                    x = BigInteger.ModPow(x, pe.Prime, BigInteger.Abs(n));\n                    o++;\n                }\n                BigInteger o1 = BigInteger.Pow(pe.Prime, o);\n                o1 = o1 / BigInteger.GreatestCommonDivisor(mo, o1);\n                mo = mo * o1;\n            }\n            return mo;\n        }\n\n        static List<PExp> Factor(BigInteger n) {\n            List<PExp> pf = new List<PExp>();\n            BigInteger nn = n;\n            int e = 0;\n            while (!nn.BitTest(e)) e++;\n            if (e > 0) {\n                nn = nn >> e;\n                pf.Add(new PExp(2, e));\n            }\n            BigInteger s = nn.Sqrt();\n            BigInteger d = 3;\n            while (nn > 1) {\n                if (d > s) d = nn;\n                e = 0;\n                while (true) {\n                    BigInteger div = BigInteger.DivRem(nn, d, out BigInteger rem);\n                    if (rem.BitLength() > 0) break;\n                    nn = div;\n                    e++;\n                }\n                if (e > 0) {\n                    pf.Add(new PExp(d, e));\n                    s = nn.Sqrt();\n                }\n                d = d + 2;\n            }\n\n            return pf;\n        }\n\n        static void Main(string[] args) {\n            MoTest(37, 3343);\n            MoTest(BigInteger.Pow(10, 100) + 1, 7919);\n            MoTest(BigInteger.Pow(10, 1000) + 1, 15485863);\n            MoTest(BigInteger.Pow(10, 10000) - 1, 22801763489);\n            MoTest(1511678068, 7379191741);\n            MoTest(3047753288, 2257683301);\n        }\n    }\n}\n"}
{"id": 87554, "name": "Multiplicative order", "source": "Translate Ruby to Java: require 'prime'\n\ndef powerMod(b, p, m)\n  p.to_s(2).each_char.inject(1) do |result, bit|\n    result = (result * result) % m\n    bit=='1' ? (result * b) % m : result\n  end\nend\n\ndef multOrder_(a, p, k)\n  pk = p ** k\n  t = (p - 1) * p ** (k - 1)\n  r = 1\n  for q, e in t.prime_division\n    x = powerMod(a, t / q**e, pk)\n    while x != 1\n      r *= q\n      x = powerMod(x, q, pk)\n    end\n  end      \n  r\nend\n\ndef multOrder(a, m)\n  m.prime_division.inject(1) do |result, f|\n    result.lcm(multOrder_(a, *f))\n  end\nend\n\nputs multOrder(37, 1000)\nb = 10**20-1\nputs multOrder(2, b)\nputs multOrder(17,b)\nb = 100001\nputs multOrder(54,b)\nputs powerMod(54, multOrder(54,b), b)\nif (1...multOrder(54,b)).any? {|r| powerMod(54, r, b) == 1}\n  puts 'Exists a power r < 9090 where powerMod(54,r,b)==1'\nelse\n  puts 'Everything checks.'\nend\n", "target": "import java.math.BigInteger;\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class MultiplicativeOrder {\n    private static final BigInteger ONE = BigInteger.ONE;\n    private static final BigInteger TWO = BigInteger.valueOf(2);\n    private static final BigInteger THREE = BigInteger.valueOf(3);\n    private static final BigInteger TEN = BigInteger.TEN;\n\n    private static class PExp {\n        BigInteger prime;\n        long exp;\n\n        PExp(BigInteger prime, long exp) {\n            this.prime = prime;\n            this.exp = exp;\n        }\n    }\n\n    private static void moTest(BigInteger a, BigInteger n) {\n        if (!n.isProbablePrime(20)) {\n            System.out.println(\"Not computed. Modulus must be prime for this algorithm.\");\n            return;\n        }\n        if (a.bitLength() < 100) System.out.printf(\"ord(%s)\", a);\n        else System.out.print(\"ord([big])\");\n        if (n.bitLength() < 100) System.out.printf(\" mod %s \", n);\n        else System.out.print(\" mod [big] \");\n        BigInteger mob = moBachShallit58(a, n, factor(n.subtract(ONE)));\n        System.out.println(\"= \" + mob);\n    }\n\n    private static BigInteger moBachShallit58(BigInteger a, BigInteger n, List<PExp> pf) {\n        BigInteger n1 = n.subtract(ONE);\n        BigInteger mo = ONE;\n        for (PExp pe : pf) {\n            BigInteger y = n1.divide(pe.prime.pow((int) pe.exp));\n            long o = 0;\n            BigInteger x = a.modPow(y, n.abs());\n            while (x.compareTo(ONE) > 0) {\n                x = x.modPow(pe.prime, n.abs());\n                o++;\n            }\n            BigInteger o1 = BigInteger.valueOf(o);\n            o1 = pe.prime.pow(o1.intValue());\n            o1 = o1.divide(mo.gcd(o1));\n            mo = mo.multiply(o1);\n        }\n        return mo;\n    }\n\n    private static List<PExp> factor(BigInteger n) {\n        List<PExp> pf = new ArrayList<>();\n        BigInteger nn = n;\n        Long e = 0L;\n        while (!nn.testBit(e.intValue())) e++;\n        if (e > 0L) {\n            nn = nn.shiftRight(e.intValue());\n            pf.add(new PExp(TWO, e));\n        }\n        BigInteger s = sqrt(nn);\n        BigInteger d = THREE;\n        while (nn.compareTo(ONE) > 0) {\n            if (d.compareTo(s) > 0) d = nn;\n            e = 0L;\n            while (true) {\n                BigInteger[] qr = nn.divideAndRemainder(d);\n                if (qr[1].bitLength() > 0) break;\n                nn = qr[0];\n                e++;\n            }\n            if (e > 0L) {\n                pf.add(new PExp(d, e));\n                s = sqrt(nn);\n            }\n            d = d.add(TWO);\n        }\n        return pf;\n    }\n\n    private static BigInteger sqrt(BigInteger n) {\n        BigInteger b = n;\n        while (true) {\n            BigInteger a = b;\n            b = n.divide(a).add(a).shiftRight(1);\n            if (b.compareTo(a) >= 0) return a;\n        }\n    }\n\n    public static void main(String[] args) {\n        moTest(BigInteger.valueOf(37), BigInteger.valueOf(3343));\n\n        BigInteger b = TEN.pow(100).add(ONE);\n        moTest(b, BigInteger.valueOf(7919));\n\n        b = TEN.pow(1000).add(ONE);\n        moTest(b, BigInteger.valueOf(15485863));\n\n        b = TEN.pow(10000).subtract(ONE);\n        moTest(b, BigInteger.valueOf(22801763489L));\n\n        moTest(BigInteger.valueOf(1511678068), BigInteger.valueOf(7379191741L));\n        moTest(BigInteger.valueOf(3047753288L), BigInteger.valueOf(2257683301L));\n    }\n}\n"}
{"id": 87555, "name": "Multiplicative order", "source": "Translate Ruby to Python: require 'prime'\n\ndef powerMod(b, p, m)\n  p.to_s(2).each_char.inject(1) do |result, bit|\n    result = (result * result) % m\n    bit=='1' ? (result * b) % m : result\n  end\nend\n\ndef multOrder_(a, p, k)\n  pk = p ** k\n  t = (p - 1) * p ** (k - 1)\n  r = 1\n  for q, e in t.prime_division\n    x = powerMod(a, t / q**e, pk)\n    while x != 1\n      r *= q\n      x = powerMod(x, q, pk)\n    end\n  end      \n  r\nend\n\ndef multOrder(a, m)\n  m.prime_division.inject(1) do |result, f|\n    result.lcm(multOrder_(a, *f))\n  end\nend\n\nputs multOrder(37, 1000)\nb = 10**20-1\nputs multOrder(2, b)\nputs multOrder(17,b)\nb = 100001\nputs multOrder(54,b)\nputs powerMod(54, multOrder(54,b), b)\nif (1...multOrder(54,b)).any? {|r| powerMod(54, r, b) == 1}\n  puts 'Exists a power r < 9090 where powerMod(54,r,b)==1'\nelse\n  puts 'Everything checks.'\nend\n", "target": "def gcd(a, b):\n    while b != 0:\n        a, b = b, a % b\n    return a\n \ndef lcm(a, b):\n    return (a*b) / gcd(a, b)\n \ndef isPrime(p):\n    return (p > 1) and all(f == p for f,e in factored(p))\n\nprimeList = [2,3,5,7]\ndef primes():\n    for p in primeList:\n        yield p\n    while 1:\n        p += 2\n        while not isPrime(p):\n            p += 2\n        primeList.append(p)\n        yield p\n\ndef factored( a):\n    for p in primes():\n        j = 0\n        while a%p == 0:\n            a /= p\n            j += 1\n        if j > 0:\n            yield (p,j)\n        if a < p*p: break\n    if a > 1:\n        yield (a,1)\n        \n\ndef multOrdr1(a,(p,e) ):\n    m = p**e\n    t = (p-1)*(p**(e-1)) \n    qs = [1,]\n    for f in factored(t):\n        qs = [ q * f[0]**j for j in range(1+f[1]) for q in qs ]\n    qs.sort()\n\n    for q in qs:\n        if pow( a, q, m )==1: break\n    return q\n\n     \ndef multOrder(a,m):\n    assert gcd(a,m) == 1\n    mofs = (multOrdr1(a,r) for r in factored(m))\n    return reduce(lcm, mofs, 1)\n\n\nif __name__ == \"__main__\":\n    print multOrder(37, 1000)        \n    b = 10**20-1\n    print multOrder(2, b) \n    print multOrder(17,b) \n    b = 100001\n    print multOrder(54,b)\n    print pow( 54, multOrder(54,b),b)\n    if any( (1==pow(54,r, b)) for r in range(1,multOrder(54,b))):\n        print 'Exists a power r < 9090 where pow(54,r,b)==1'\n    else:\n        print 'Everything checks.'\n"}
{"id": 87742, "name": "String length", "source": "Translate Ruby to Java: \"J\u0332o\u0332s\u0332\u00e9\u0332\".bytesize\n", "target": "String s = \"Hello, world!\"; \nint byteCountUTF16 = s.getBytes(\"UTF-16\").length; \nint byteCountUTF16LE = s.getBytes(\"UTF-16LE\").length; \nint byteCountUTF8  = s.getBytes(\"UTF-8\").length; \n"}
{"id": 87928, "name": "Floyd-Warshall algorithm", "source": "Translate Ruby to C#: def floyd_warshall(n, edge)\n  dist = Array.new(n){|i| Array.new(n){|j| i==j ? 0 : Float::INFINITY}}\n  nxt = Array.new(n){Array.new(n)}\n  edge.each do |u,v,w|\n    dist[u-1][v-1] = w\n    nxt[u-1][v-1] = v-1\n  end\n  \n  n.times do |k|\n    n.times do |i|\n      n.times do |j|\n        if dist[i][j] > dist[i][k] + dist[k][j]\n          dist[i][j] = dist[i][k] + dist[k][j]\n          nxt[i][j] = nxt[i][k]\n        end\n      end\n    end\n  end\n  \n  puts \"pair     dist    path\"\n  n.times do |i|\n    n.times do |j|\n      next  if i==j\n      u = i\n      path = [u]\n      path << (u = nxt[u][j])  while u != j\n      path = path.map{|u| u+1}.join(\" -> \")\n      puts \"%d -> %d  %4d     %s\" % [i+1, j+1, dist[i][j], path]\n    end\n  end\nend\n\nn = 4\nedge = [[1, 3, -2], [2, 1, 4], [2, 3, 3], [3, 4, 2], [4, 2, -1]]\nfloyd_warshall(n, edge)\n", "target": "using System;\n\nnamespace FloydWarshallAlgorithm {\n    class Program {\n        static void FloydWarshall(int[,] weights, int numVerticies) {\n            double[,] dist = new double[numVerticies, numVerticies];\n            for (int i = 0; i < numVerticies; i++) {\n                for (int j = 0; j < numVerticies; j++) {\n                    dist[i, j] = double.PositiveInfinity;\n                }\n            }\n\n            for (int i = 0; i < weights.GetLength(0); i++) {\n                dist[weights[i, 0] - 1, weights[i, 1] - 1] = weights[i, 2];\n            }\n\n            int[,] next = new int[numVerticies, numVerticies];\n            for (int i = 0; i < numVerticies; i++) {\n                for (int j = 0; j < numVerticies; j++) {\n                    if (i != j) {\n                        next[i, j] = j + 1;\n                    }\n                }\n            }\n\n            for (int k = 0; k < numVerticies; k++) {\n                for (int i = 0; i < numVerticies; i++) {\n                    for (int j = 0; j < numVerticies; j++) {\n                        if (dist[i, k] + dist[k, j] < dist[i, j]) {\n                            dist[i, j] = dist[i, k] + dist[k, j];\n                            next[i, j] = next[i, k];\n                        }\n                    }\n                }\n            }\n\n            PrintResult(dist, next);\n        }\n\n        static void PrintResult(double[,] dist, int[,] next) {\n            Console.WriteLine(\"pair     dist    path\");\n            for (int i = 0; i < next.GetLength(0); i++) {\n                for (int j = 0; j < next.GetLength(1); j++) {\n                    if (i != j) {\n                        int u = i + 1;\n                        int v = j + 1;\n                        string path = string.Format(\"{0} -> {1}    {2,2:G}     {3}\", u, v, dist[i, j], u);\n                        do {\n                            u = next[u - 1, v - 1];\n                            path += \" -> \" + u;\n                        } while (u != v);\n                        Console.WriteLine(path);\n                    }\n                }\n            }\n        }\n\n        static void Main(string[] args) {\n            int[,] weights = { { 1, 3, -2 }, { 2, 1, 4 }, { 2, 3, 3 }, { 3, 4, 2 }, { 4, 2, -1 } };\n            int numVerticies = 4;\n\n            FloydWarshall(weights, numVerticies);\n        }\n    }\n}\n"}
{"id": 87930, "name": "Floyd-Warshall algorithm", "source": "Translate Ruby to Java: def floyd_warshall(n, edge)\n  dist = Array.new(n){|i| Array.new(n){|j| i==j ? 0 : Float::INFINITY}}\n  nxt = Array.new(n){Array.new(n)}\n  edge.each do |u,v,w|\n    dist[u-1][v-1] = w\n    nxt[u-1][v-1] = v-1\n  end\n  \n  n.times do |k|\n    n.times do |i|\n      n.times do |j|\n        if dist[i][j] > dist[i][k] + dist[k][j]\n          dist[i][j] = dist[i][k] + dist[k][j]\n          nxt[i][j] = nxt[i][k]\n        end\n      end\n    end\n  end\n  \n  puts \"pair     dist    path\"\n  n.times do |i|\n    n.times do |j|\n      next  if i==j\n      u = i\n      path = [u]\n      path << (u = nxt[u][j])  while u != j\n      path = path.map{|u| u+1}.join(\" -> \")\n      puts \"%d -> %d  %4d     %s\" % [i+1, j+1, dist[i][j], path]\n    end\n  end\nend\n\nn = 4\nedge = [[1, 3, -2], [2, 1, 4], [2, 3, 3], [3, 4, 2], [4, 2, -1]]\nfloyd_warshall(n, edge)\n", "target": "import static java.lang.String.format;\nimport java.util.Arrays;\n\npublic class FloydWarshall {\n\n    public static void main(String[] args) {\n        int[][] weights = {{1, 3, -2}, {2, 1, 4}, {2, 3, 3}, {3, 4, 2}, {4, 2, -1}};\n        int numVertices = 4;\n\n        floydWarshall(weights, numVertices);\n    }\n\n    static void floydWarshall(int[][] weights, int numVertices) {\n\n        double[][] dist = new double[numVertices][numVertices];\n        for (double[] row : dist)\n            Arrays.fill(row, Double.POSITIVE_INFINITY);\n\n        for (int[] w : weights)\n            dist[w[0] - 1][w[1] - 1] = w[2];\n\n        int[][] next = new int[numVertices][numVertices];\n        for (int i = 0; i < next.length; i++) {\n            for (int j = 0; j < next.length; j++)\n                if (i != j)\n                    next[i][j] = j + 1;\n        }\n\n        for (int k = 0; k < numVertices; k++)\n            for (int i = 0; i < numVertices; i++)\n                for (int j = 0; j < numVertices; j++)\n                    if (dist[i][k] + dist[k][j] < dist[i][j]) {\n                        dist[i][j] = dist[i][k] + dist[k][j];\n                        next[i][j] = next[i][k];\n                    }\n\n        printResult(dist, next);\n    }\n\n    static void printResult(double[][] dist, int[][] next) {\n        System.out.println(\"pair     dist    path\");\n        for (int i = 0; i < next.length; i++) {\n            for (int j = 0; j < next.length; j++) {\n                if (i != j) {\n                    int u = i + 1;\n                    int v = j + 1;\n                    String path = format(\"%d -> %d    %2d     %s\", u, v,\n                            (int) dist[i][j], u);\n                    do {\n                        u = next[u - 1][v - 1];\n                        path += \" -> \" + u;\n                    } while (u != v);\n                    System.out.println(path);\n                }\n            }\n        }\n    }\n}\n"}
{"id": 87931, "name": "Floyd-Warshall algorithm", "source": "Translate Ruby to Python: def floyd_warshall(n, edge)\n  dist = Array.new(n){|i| Array.new(n){|j| i==j ? 0 : Float::INFINITY}}\n  nxt = Array.new(n){Array.new(n)}\n  edge.each do |u,v,w|\n    dist[u-1][v-1] = w\n    nxt[u-1][v-1] = v-1\n  end\n  \n  n.times do |k|\n    n.times do |i|\n      n.times do |j|\n        if dist[i][j] > dist[i][k] + dist[k][j]\n          dist[i][j] = dist[i][k] + dist[k][j]\n          nxt[i][j] = nxt[i][k]\n        end\n      end\n    end\n  end\n  \n  puts \"pair     dist    path\"\n  n.times do |i|\n    n.times do |j|\n      next  if i==j\n      u = i\n      path = [u]\n      path << (u = nxt[u][j])  while u != j\n      path = path.map{|u| u+1}.join(\" -> \")\n      puts \"%d -> %d  %4d     %s\" % [i+1, j+1, dist[i][j], path]\n    end\n  end\nend\n\nn = 4\nedge = [[1, 3, -2], [2, 1, 4], [2, 3, 3], [3, 4, 2], [4, 2, -1]]\nfloyd_warshall(n, edge)\n", "target": "from math import inf\nfrom itertools import product\n\ndef floyd_warshall(n, edge):\n    rn = range(n)\n    dist = [[inf] * n for i in rn]\n    nxt  = [[0]   * n for i in rn]\n    for i in rn:\n        dist[i][i] = 0\n    for u, v, w in edge:\n        dist[u-1][v-1] = w\n        nxt[u-1][v-1] = v-1\n    for k, i, j in product(rn, repeat=3):\n        sum_ik_kj = dist[i][k] + dist[k][j]\n        if dist[i][j] > sum_ik_kj:\n            dist[i][j] = sum_ik_kj\n            nxt[i][j]  = nxt[i][k]\n    print(\"pair     dist    path\")\n    for i, j in product(rn, repeat=2):\n        if i != j:\n            path = [i]\n            while path[-1] != j:\n                path.append(nxt[path[-1]][j])\n            print(\"%d \u2192 %d  %4d       %s\" \n                  % (i + 1, j + 1, dist[i][j], \n                     ' \u2192 '.join(str(p + 1) for p in path)))\n\nif __name__ == '__main__':\n    floyd_warshall(4, [[1, 3, -2], [2, 1, 4], [2, 3, 3], [3, 4, 2], [4, 2, -1]])\n"}
{"id": 88157, "name": "Roots of unity", "source": "Translate Ruby to C#: require \"complex\"\n\ndef roots_of_unity(n)\n  (0...n).map { |k| Math.exp((2 * Math::PI * k / n).i) }\nend\n \np roots_of_unity(3)\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Numerics;\n\nclass Program\n{\n    static IEnumerable<Complex> RootsOfUnity(int degree)\n    {\n        return Enumerable\n            .Range(0, degree)\n            .Select(element => Complex.FromPolarCoordinates(1, 2 * Math.PI * element / degree));\n    }\n\n    static void Main()\n    {\n        var degree = 3;\n        foreach (var root in RootsOfUnity(degree))\n        {\n            Console.WriteLine(root);\n        }\n    }\n}\n"}
{"id": 88158, "name": "Roots of unity", "source": "Translate Ruby to Java: require \"complex\"\n\ndef roots_of_unity(n)\n  (0...n).map { |k| Math.exp((2 * Math::PI * k / n).i) }\nend\n \np roots_of_unity(3)\n", "target": "import java.util.Locale;\n\npublic class Test {\n\n    public static void main(String[] a) {\n        for (int n = 2; n < 6; n++)\n            unity(n);\n    }\n\n    public static void unity(int n) {\n        System.out.printf(\"%n%d: \", n);\n\n        \n        for (double angle = 0; angle < 2 * Math.PI; angle += (2 * Math.PI) / n) {\n\n            double real = Math.cos(angle); \n\n            if (Math.abs(real) < 1.0E-3)\n                real = 0.0; \n\n            double imag = Math.sin(angle); \n\n            if (Math.abs(imag) < 1.0E-3)\n                imag = 0.0;\n\n            System.out.printf(Locale.US, \"(%9f,%9f) \", real, imag);\n        }\n    }\n}\n"}
{"id": 88159, "name": "Roots of unity", "source": "Translate Ruby to Python: require \"complex\"\n\ndef roots_of_unity(n)\n  (0...n).map { |k| Math.exp((2 * Math::PI * k / n).i) }\nend\n \np roots_of_unity(3)\n", "target": "import cmath\n\n\nclass Complex(complex):\n    def __repr__(self):\n        rp = '%7.5f' % self.real if not self.pureImag() else ''\n        ip = '%7.5fj' % self.imag if not self.pureReal() else ''\n        conj = '' if (\n            self.pureImag() or self.pureReal() or self.imag < 0.0\n        ) else '+'\n        return '0.0' if (\n            self.pureImag() and self.pureReal()\n        ) else rp + conj + ip\n\n    def pureImag(self):\n        return abs(self.real) < 0.000005\n\n    def pureReal(self):\n        return abs(self.imag) < 0.000005\n\n\ndef croots(n):\n    if n <= 0:\n        return None\n    return (Complex(cmath.rect(1, 2 * k * cmath.pi / n)) for k in range(n))\n    \n    \n\n\nfor nr in range(2, 11):\n    print(nr, list(croots(nr)))\n"}
{"id": 88312, "name": "HTTPS", "source": "Translate Ruby to C#: require 'net/https'\nrequire 'uri'\nrequire 'pp'\n\nuri = URI.parse('https://sourceforge.net')\nhttp = Net::HTTP.new(uri.host,uri.port)\nhttp.use_ssl = true\nhttp.verify_mode = OpenSSL::SSL::VERIFY_NONE\n\nhttp.start do\n  content = http.get(uri)\n  p [content.code, content.message]\n  pp content.to_hash\n  puts content.body\nend\n", "target": "using System;\nusing System.Net;\n\nclass Program\n{\n    static void Main(string[] args)\n    {\n        var client = new WebClient();\n        var data = client.DownloadString(\"https:\n\n        Console.WriteLine(data);\n    }\n}\n"}
{"id": 88313, "name": "HTTPS", "source": "Translate Ruby to Java: require 'net/https'\nrequire 'uri'\nrequire 'pp'\n\nuri = URI.parse('https://sourceforge.net')\nhttp = Net::HTTP.new(uri.host,uri.port)\nhttp.use_ssl = true\nhttp.verify_mode = OpenSSL::SSL::VERIFY_NONE\n\nhttp.start do\n  content = http.get(uri)\n  p [content.code, content.message]\n  pp content.to_hash\n  puts content.body\nend\n", "target": "URL url = new URL(\"https:\nHttpsURLConnection connection = (HttpsURLConnection) url.openConnection();\nScanner scanner = new Scanner(connection.getInputStream());\n\nwhile (scanner.hasNext()) {\n    System.out.println(scanner.next());\n}\n"}
{"id": 88314, "name": "HTTPS", "source": "Translate Ruby to Python: require 'net/https'\nrequire 'uri'\nrequire 'pp'\n\nuri = URI.parse('https://sourceforge.net')\nhttp = Net::HTTP.new(uri.host,uri.port)\nhttp.use_ssl = true\nhttp.verify_mode = OpenSSL::SSL::VERIFY_NONE\n\nhttp.start do\n  content = http.get(uri)\n  p [content.code, content.message]\n  pp content.to_hash\n  puts content.body\nend\n", "target": "import urllib.request\nprint(urllib.request.urlopen(\"https://sourceforge.net/\").read())\n"}
{"id": 88588, "name": "Sorting algorithms_Insertion sort", "source": "Translate Ruby to C#: class Array\n  def insertionsort!\n    1.upto(length - 1) do |i|\n      value = self[i]\n      j = i - 1\n      while j >= 0 and self[j] > value\n        self[j+1] = self[j]\n        j -= 1\n      end\n      self[j+1] = value\n    end\n    self\n  end\nend\nary = [7,6,5,9,8,4,3,1,2,0]\np ary.insertionsort!\n\n", "target": "namespace Sort {\n  using System;\n\n  static class InsertionSort<T> where T : IComparable {\n    public static void Sort(T[] entries) {\n      Sort(entries, 0, entries.Length - 1);\n    }\n\n    public static void Sort(T[] entries, Int32 first, Int32 last) {\n      for (var i = first + 1; i <= last; i++) {\n        var entry = entries[i];\n        var j = i;\n\n        while (j > first && entries[j - 1].CompareTo(entry) > 0)\n          entries[j] = entries[--j];\n\n        entries[j] = entry;\n      }\n    }\n  }\n}\n"}
{"id": 88590, "name": "Sorting algorithms_Insertion sort", "source": "Translate Ruby to Java: class Array\n  def insertionsort!\n    1.upto(length - 1) do |i|\n      value = self[i]\n      j = i - 1\n      while j >= 0 and self[j] > value\n        self[j+1] = self[j]\n        j -= 1\n      end\n      self[j+1] = value\n    end\n    self\n  end\nend\nary = [7,6,5,9,8,4,3,1,2,0]\np ary.insertionsort!\n\n", "target": "public static void insertSort(int[] A){\n  for(int i = 1; i < A.length; i++){\n    int value = A[i];\n    int j = i - 1;\n    while(j >= 0 && A[j] > value){\n      A[j + 1] = A[j];\n      j = j - 1;\n    }\n    A[j + 1] = value;\n  }\n}\n"}
{"id": 88591, "name": "Sorting algorithms_Insertion sort", "source": "Translate Ruby to Python: class Array\n  def insertionsort!\n    1.upto(length - 1) do |i|\n      value = self[i]\n      j = i - 1\n      while j >= 0 and self[j] > value\n        self[j+1] = self[j]\n        j -= 1\n      end\n      self[j+1] = value\n    end\n    self\n  end\nend\nary = [7,6,5,9,8,4,3,1,2,0]\np ary.insertionsort!\n\n", "target": "def insertion_sort(L):\n    for i in xrange(1, len(L)):\n        j = i-1 \n        key = L[i]\n        while j >= 0 and L[j] > key:\n           L[j+1] = L[j]\n           j -= 1\n        L[j+1] = key\n"}
{"id": 89023, "name": "Angle difference between two bearings", "source": "Translate Ruby to C#: def getDifference(b1, b2)\n\tr = (b2 - b1) % 360.0\n\t\n\t\n\tif r >= 180.0\n\t\tr -= 360.0\n\tend\n\treturn r\nend\n\nif __FILE__ == $PROGRAM_NAME\n\tputs \"Input in -180 to +180 range\"\n\tputs getDifference(20.0, 45.0)\n\tputs getDifference(-45.0, 45.0)\n\tputs getDifference(-85.0, 90.0)\n\tputs getDifference(-95.0, 90.0)\n\tputs getDifference(-45.0, 125.0)\n\tputs getDifference(-45.0, 145.0)\n\tputs getDifference(-45.0, 125.0)\n\tputs getDifference(-45.0, 145.0)\n\tputs getDifference(29.4803, -88.6381)\n\tputs getDifference(-78.3251, -159.036)\n \n\tputs \"Input in wider range\"\n\tputs getDifference(-70099.74233810938, 29840.67437876723)\n\tputs getDifference(-165313.6666297357, 33693.9894517456)\n\tputs getDifference(1174.8380510598456, -154146.66490124757)\n\tputs getDifference(60175.77306795546, 42213.07192354373)\nend\n", "target": "using System;\n\nnamespace Angle_difference_between_two_bearings\n{\n\tclass Program\n\t{\n\t\tpublic static void Main(string[] args)\n\t\t{\n\t\t\tConsole.WriteLine();\n\t\t\tConsole.WriteLine(\"Hello World!\");\n\t\t\tConsole.WriteLine();\n\t\t\t\n\t\t\t\n\t\t\tConsole.WriteLine(Delta_Bearing( 20M,45));\n\t\t\tConsole.WriteLine(Delta_Bearing(-45M,45M));\n\t\t\tConsole.WriteLine(Delta_Bearing(-85M,90M));\n\t\t\tConsole.WriteLine(Delta_Bearing(-95M,90M));\n\t\t\tConsole.WriteLine(Delta_Bearing(-45M,125M));\n\t\t\tConsole.WriteLine(Delta_Bearing(-45M,145M));\n\t\t\tConsole.WriteLine(Delta_Bearing( 29.4803M,-88.6381M));\n\t\t\tConsole.WriteLine(Delta_Bearing(-78.3251M, -159.036M));\n\t\t\t\n\t\t\t\n\t\t\tConsole.WriteLine(Delta_Bearing(-70099.74233810938M,   29840.67437876723M));\n\t\t\tConsole.WriteLine(Delta_Bearing(-165313.6666297357M,   33693.9894517456M));\n\t\t\tConsole.WriteLine(Delta_Bearing( 1174.8380510598456M, -154146.66490124757M));\n\t\t\tConsole.WriteLine(Delta_Bearing( 60175.77306795546M,   42213.07192354373M));\n\t\t\t\n\t\t\tConsole.WriteLine();\n\t\t\tConsole.Write(\"Press any key to continue . . . \");\n\t\t\tConsole.ReadKey(true);\n\t\t}\n\t\t\n\t\tstatic decimal Delta_Bearing(decimal b1, decimal b2)\n\t\t{\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t\tdecimal d = 0;\n\t\t\t\n\t\t\t\n\t\t\tif(b1<0)\n\t\t\t\tb1 += 360;\n\t\t\tif(b2<0)\n\t\t\t\tb2 += 360;\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t\td = (b2 - b1)%360;\n\t\t\t\n\t\t\tif(d>180)\n\t\t\t\td -= 360;\n\t\t\telse if(d<-180)\n\t\t\t\td += 360;\n\t\t\t\n\t\t\treturn d;\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t}\n\t}\n}\n"}
{"id": 89024, "name": "Angle difference between two bearings", "source": "Translate Ruby to C#: def getDifference(b1, b2)\n\tr = (b2 - b1) % 360.0\n\t\n\t\n\tif r >= 180.0\n\t\tr -= 360.0\n\tend\n\treturn r\nend\n\nif __FILE__ == $PROGRAM_NAME\n\tputs \"Input in -180 to +180 range\"\n\tputs getDifference(20.0, 45.0)\n\tputs getDifference(-45.0, 45.0)\n\tputs getDifference(-85.0, 90.0)\n\tputs getDifference(-95.0, 90.0)\n\tputs getDifference(-45.0, 125.0)\n\tputs getDifference(-45.0, 145.0)\n\tputs getDifference(-45.0, 125.0)\n\tputs getDifference(-45.0, 145.0)\n\tputs getDifference(29.4803, -88.6381)\n\tputs getDifference(-78.3251, -159.036)\n \n\tputs \"Input in wider range\"\n\tputs getDifference(-70099.74233810938, 29840.67437876723)\n\tputs getDifference(-165313.6666297357, 33693.9894517456)\n\tputs getDifference(1174.8380510598456, -154146.66490124757)\n\tputs getDifference(60175.77306795546, 42213.07192354373)\nend\n", "target": "using System;\n\nnamespace Angle_difference_between_two_bearings\n{\n\tclass Program\n\t{\n\t\tpublic static void Main(string[] args)\n\t\t{\n\t\t\tConsole.WriteLine();\n\t\t\tConsole.WriteLine(\"Hello World!\");\n\t\t\tConsole.WriteLine();\n\t\t\t\n\t\t\t\n\t\t\tConsole.WriteLine(Delta_Bearing( 20M,45));\n\t\t\tConsole.WriteLine(Delta_Bearing(-45M,45M));\n\t\t\tConsole.WriteLine(Delta_Bearing(-85M,90M));\n\t\t\tConsole.WriteLine(Delta_Bearing(-95M,90M));\n\t\t\tConsole.WriteLine(Delta_Bearing(-45M,125M));\n\t\t\tConsole.WriteLine(Delta_Bearing(-45M,145M));\n\t\t\tConsole.WriteLine(Delta_Bearing( 29.4803M,-88.6381M));\n\t\t\tConsole.WriteLine(Delta_Bearing(-78.3251M, -159.036M));\n\t\t\t\n\t\t\t\n\t\t\tConsole.WriteLine(Delta_Bearing(-70099.74233810938M,   29840.67437876723M));\n\t\t\tConsole.WriteLine(Delta_Bearing(-165313.6666297357M,   33693.9894517456M));\n\t\t\tConsole.WriteLine(Delta_Bearing( 1174.8380510598456M, -154146.66490124757M));\n\t\t\tConsole.WriteLine(Delta_Bearing( 60175.77306795546M,   42213.07192354373M));\n\t\t\t\n\t\t\tConsole.WriteLine();\n\t\t\tConsole.Write(\"Press any key to continue . . . \");\n\t\t\tConsole.ReadKey(true);\n\t\t}\n\t\t\n\t\tstatic decimal Delta_Bearing(decimal b1, decimal b2)\n\t\t{\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t\tdecimal d = 0;\n\t\t\t\n\t\t\t\n\t\t\tif(b1<0)\n\t\t\t\tb1 += 360;\n\t\t\tif(b2<0)\n\t\t\t\tb2 += 360;\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t\td = (b2 - b1)%360;\n\t\t\t\n\t\t\tif(d>180)\n\t\t\t\td -= 360;\n\t\t\telse if(d<-180)\n\t\t\t\td += 360;\n\t\t\t\n\t\t\treturn d;\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t}\n\t}\n}\n"}
{"id": 89027, "name": "Angle difference between two bearings", "source": "Translate Ruby to Java: def getDifference(b1, b2)\n\tr = (b2 - b1) % 360.0\n\t\n\t\n\tif r >= 180.0\n\t\tr -= 360.0\n\tend\n\treturn r\nend\n\nif __FILE__ == $PROGRAM_NAME\n\tputs \"Input in -180 to +180 range\"\n\tputs getDifference(20.0, 45.0)\n\tputs getDifference(-45.0, 45.0)\n\tputs getDifference(-85.0, 90.0)\n\tputs getDifference(-95.0, 90.0)\n\tputs getDifference(-45.0, 125.0)\n\tputs getDifference(-45.0, 145.0)\n\tputs getDifference(-45.0, 125.0)\n\tputs getDifference(-45.0, 145.0)\n\tputs getDifference(29.4803, -88.6381)\n\tputs getDifference(-78.3251, -159.036)\n \n\tputs \"Input in wider range\"\n\tputs getDifference(-70099.74233810938, 29840.67437876723)\n\tputs getDifference(-165313.6666297357, 33693.9894517456)\n\tputs getDifference(1174.8380510598456, -154146.66490124757)\n\tputs getDifference(60175.77306795546, 42213.07192354373)\nend\n", "target": "public class AngleDifference {\n\n    public static double getDifference(double b1, double b2) {\n        double r = (b2 - b1) % 360.0;\n        if (r < -180.0)\n            r += 360.0;\n        if (r >= 180.0)\n            r -= 360.0;\n        return r;\n    }\n\n    public static void main(String[] args) {\n        System.out.println(\"Input in -180 to +180 range\");\n        System.out.println(getDifference(20.0, 45.0));\n        System.out.println(getDifference(-45.0, 45.0));\n        System.out.println(getDifference(-85.0, 90.0));\n        System.out.println(getDifference(-95.0, 90.0));\n        System.out.println(getDifference(-45.0, 125.0));\n        System.out.println(getDifference(-45.0, 145.0));\n        System.out.println(getDifference(-45.0, 125.0));\n        System.out.println(getDifference(-45.0, 145.0));\n        System.out.println(getDifference(29.4803, -88.6381));\n        System.out.println(getDifference(-78.3251, -159.036));\n\n        System.out.println(\"Input in wider range\");\n        System.out.println(getDifference(-70099.74233810938, 29840.67437876723));\n        System.out.println(getDifference(-165313.6666297357, 33693.9894517456));\n        System.out.println(getDifference(1174.8380510598456, -154146.66490124757));\n        System.out.println(getDifference(60175.77306795546, 42213.07192354373));\n    }\n}\n"}
{"id": 89028, "name": "Angle difference between two bearings", "source": "Translate Ruby to Java: def getDifference(b1, b2)\n\tr = (b2 - b1) % 360.0\n\t\n\t\n\tif r >= 180.0\n\t\tr -= 360.0\n\tend\n\treturn r\nend\n\nif __FILE__ == $PROGRAM_NAME\n\tputs \"Input in -180 to +180 range\"\n\tputs getDifference(20.0, 45.0)\n\tputs getDifference(-45.0, 45.0)\n\tputs getDifference(-85.0, 90.0)\n\tputs getDifference(-95.0, 90.0)\n\tputs getDifference(-45.0, 125.0)\n\tputs getDifference(-45.0, 145.0)\n\tputs getDifference(-45.0, 125.0)\n\tputs getDifference(-45.0, 145.0)\n\tputs getDifference(29.4803, -88.6381)\n\tputs getDifference(-78.3251, -159.036)\n \n\tputs \"Input in wider range\"\n\tputs getDifference(-70099.74233810938, 29840.67437876723)\n\tputs getDifference(-165313.6666297357, 33693.9894517456)\n\tputs getDifference(1174.8380510598456, -154146.66490124757)\n\tputs getDifference(60175.77306795546, 42213.07192354373)\nend\n", "target": "public class AngleDifference {\n\n    public static double getDifference(double b1, double b2) {\n        double r = (b2 - b1) % 360.0;\n        if (r < -180.0)\n            r += 360.0;\n        if (r >= 180.0)\n            r -= 360.0;\n        return r;\n    }\n\n    public static void main(String[] args) {\n        System.out.println(\"Input in -180 to +180 range\");\n        System.out.println(getDifference(20.0, 45.0));\n        System.out.println(getDifference(-45.0, 45.0));\n        System.out.println(getDifference(-85.0, 90.0));\n        System.out.println(getDifference(-95.0, 90.0));\n        System.out.println(getDifference(-45.0, 125.0));\n        System.out.println(getDifference(-45.0, 145.0));\n        System.out.println(getDifference(-45.0, 125.0));\n        System.out.println(getDifference(-45.0, 145.0));\n        System.out.println(getDifference(29.4803, -88.6381));\n        System.out.println(getDifference(-78.3251, -159.036));\n\n        System.out.println(\"Input in wider range\");\n        System.out.println(getDifference(-70099.74233810938, 29840.67437876723));\n        System.out.println(getDifference(-165313.6666297357, 33693.9894517456));\n        System.out.println(getDifference(1174.8380510598456, -154146.66490124757));\n        System.out.println(getDifference(60175.77306795546, 42213.07192354373));\n    }\n}\n"}
{"id": 89029, "name": "Angle difference between two bearings", "source": "Translate Ruby to Python: def getDifference(b1, b2)\n\tr = (b2 - b1) % 360.0\n\t\n\t\n\tif r >= 180.0\n\t\tr -= 360.0\n\tend\n\treturn r\nend\n\nif __FILE__ == $PROGRAM_NAME\n\tputs \"Input in -180 to +180 range\"\n\tputs getDifference(20.0, 45.0)\n\tputs getDifference(-45.0, 45.0)\n\tputs getDifference(-85.0, 90.0)\n\tputs getDifference(-95.0, 90.0)\n\tputs getDifference(-45.0, 125.0)\n\tputs getDifference(-45.0, 145.0)\n\tputs getDifference(-45.0, 125.0)\n\tputs getDifference(-45.0, 145.0)\n\tputs getDifference(29.4803, -88.6381)\n\tputs getDifference(-78.3251, -159.036)\n \n\tputs \"Input in wider range\"\n\tputs getDifference(-70099.74233810938, 29840.67437876723)\n\tputs getDifference(-165313.6666297357, 33693.9894517456)\n\tputs getDifference(1174.8380510598456, -154146.66490124757)\n\tputs getDifference(60175.77306795546, 42213.07192354373)\nend\n", "target": "from __future__ import print_function\n \ndef getDifference(b1, b2):\n\tr = (b2 - b1) % 360.0\n\t\n\t\n\tif r >= 180.0:\n\t\tr -= 360.0\n\treturn r\n \nif __name__ == \"__main__\":\n\tprint (\"Input in -180 to +180 range\")\n\tprint (getDifference(20.0, 45.0))\n\tprint (getDifference(-45.0, 45.0))\n\tprint (getDifference(-85.0, 90.0))\n\tprint (getDifference(-95.0, 90.0))\n\tprint (getDifference(-45.0, 125.0))\n\tprint (getDifference(-45.0, 145.0))\n\tprint (getDifference(-45.0, 125.0))\n\tprint (getDifference(-45.0, 145.0))\n\tprint (getDifference(29.4803, -88.6381))\n\tprint (getDifference(-78.3251, -159.036))\n \n\tprint (\"Input in wider range\")\n\tprint (getDifference(-70099.74233810938, 29840.67437876723))\n\tprint (getDifference(-165313.6666297357, 33693.9894517456))\n\tprint (getDifference(1174.8380510598456, -154146.66490124757))\n\tprint (getDifference(60175.77306795546, 42213.07192354373))\n"}
{"id": 89030, "name": "Angle difference between two bearings", "source": "Translate Ruby to Python: def getDifference(b1, b2)\n\tr = (b2 - b1) % 360.0\n\t\n\t\n\tif r >= 180.0\n\t\tr -= 360.0\n\tend\n\treturn r\nend\n\nif __FILE__ == $PROGRAM_NAME\n\tputs \"Input in -180 to +180 range\"\n\tputs getDifference(20.0, 45.0)\n\tputs getDifference(-45.0, 45.0)\n\tputs getDifference(-85.0, 90.0)\n\tputs getDifference(-95.0, 90.0)\n\tputs getDifference(-45.0, 125.0)\n\tputs getDifference(-45.0, 145.0)\n\tputs getDifference(-45.0, 125.0)\n\tputs getDifference(-45.0, 145.0)\n\tputs getDifference(29.4803, -88.6381)\n\tputs getDifference(-78.3251, -159.036)\n \n\tputs \"Input in wider range\"\n\tputs getDifference(-70099.74233810938, 29840.67437876723)\n\tputs getDifference(-165313.6666297357, 33693.9894517456)\n\tputs getDifference(1174.8380510598456, -154146.66490124757)\n\tputs getDifference(60175.77306795546, 42213.07192354373)\nend\n", "target": "from __future__ import print_function\n \ndef getDifference(b1, b2):\n\tr = (b2 - b1) % 360.0\n\t\n\t\n\tif r >= 180.0:\n\t\tr -= 360.0\n\treturn r\n \nif __name__ == \"__main__\":\n\tprint (\"Input in -180 to +180 range\")\n\tprint (getDifference(20.0, 45.0))\n\tprint (getDifference(-45.0, 45.0))\n\tprint (getDifference(-85.0, 90.0))\n\tprint (getDifference(-95.0, 90.0))\n\tprint (getDifference(-45.0, 125.0))\n\tprint (getDifference(-45.0, 145.0))\n\tprint (getDifference(-45.0, 125.0))\n\tprint (getDifference(-45.0, 145.0))\n\tprint (getDifference(29.4803, -88.6381))\n\tprint (getDifference(-78.3251, -159.036))\n \n\tprint (\"Input in wider range\")\n\tprint (getDifference(-70099.74233810938, 29840.67437876723))\n\tprint (getDifference(-165313.6666297357, 33693.9894517456))\n\tprint (getDifference(1174.8380510598456, -154146.66490124757))\n\tprint (getDifference(60175.77306795546, 42213.07192354373))\n"}
{"id": 89329, "name": "Archimedean spiral", "source": "Translate Ruby to C#: INCR = 0.1\nattr_reader :x, :theta\n\ndef setup\n  sketch_title 'Archimedian Spiral'\n  @theta = 0\n  @x = 0\n  background(255)\n  translate(width / 2.0, height / 2.0)\n  begin_shape\n  (0..50*PI).step(INCR) do |theta|\n    @x = theta * cos(theta / PI)\n    curve_vertex(x, theta * sin(theta / PI))\n  end\n  end_shape\nend\n\ndef settings\n  size(300, 300)\nend\n", "target": "using System;\nusing System.Linq;\nusing System.Drawing;\nusing System.Diagnostics;\nusing System.Drawing.Drawing2D;\n\nclass Program\n{\n    const int width = 380;\n    const int height = 380;\n    static PointF archimedeanPoint(int degrees)\n    {\n        const double a = 1;\n        const double b = 9;\n        double t = degrees * Math.PI / 180;\n        double r = a + b * t;\n        return new PointF { X = (float)(width / 2 + r * Math.Cos(t)), Y = (float)(height / 2 + r * Math.Sin(t)) };\n    }\n\n    static void Main(string[] args)\n    {\n        var bm = new Bitmap(width, height);\n        var g = Graphics.FromImage(bm);\n        g.SmoothingMode = SmoothingMode.AntiAlias;\n        g.FillRectangle(new SolidBrush(Color.White), new Rectangle { X = 0, Y = 0, Width = width, Height = height });\n        var pen = new Pen(Color.OrangeRed, 1.5f);\n\n        var spiral = Enumerable.Range(0, 360 * 3).AsParallel().AsOrdered().Select(archimedeanPoint);\n        var p0 = new PointF(width / 2, height / 2);\n        foreach (var p1 in spiral)\n        {\n            g.DrawLine(pen, p0, p1);\n            p0 = p1;\n        }\n        g.Save(); \n        bm.Save(\"archimedes-csharp.png\");\n        Process.Start(\"archimedes-csharp.png\"); \n    }\n}\n"}
{"id": 89330, "name": "Archimedean spiral", "source": "Translate Ruby to C#: INCR = 0.1\nattr_reader :x, :theta\n\ndef setup\n  sketch_title 'Archimedian Spiral'\n  @theta = 0\n  @x = 0\n  background(255)\n  translate(width / 2.0, height / 2.0)\n  begin_shape\n  (0..50*PI).step(INCR) do |theta|\n    @x = theta * cos(theta / PI)\n    curve_vertex(x, theta * sin(theta / PI))\n  end\n  end_shape\nend\n\ndef settings\n  size(300, 300)\nend\n", "target": "using System;\nusing System.Linq;\nusing System.Drawing;\nusing System.Diagnostics;\nusing System.Drawing.Drawing2D;\n\nclass Program\n{\n    const int width = 380;\n    const int height = 380;\n    static PointF archimedeanPoint(int degrees)\n    {\n        const double a = 1;\n        const double b = 9;\n        double t = degrees * Math.PI / 180;\n        double r = a + b * t;\n        return new PointF { X = (float)(width / 2 + r * Math.Cos(t)), Y = (float)(height / 2 + r * Math.Sin(t)) };\n    }\n\n    static void Main(string[] args)\n    {\n        var bm = new Bitmap(width, height);\n        var g = Graphics.FromImage(bm);\n        g.SmoothingMode = SmoothingMode.AntiAlias;\n        g.FillRectangle(new SolidBrush(Color.White), new Rectangle { X = 0, Y = 0, Width = width, Height = height });\n        var pen = new Pen(Color.OrangeRed, 1.5f);\n\n        var spiral = Enumerable.Range(0, 360 * 3).AsParallel().AsOrdered().Select(archimedeanPoint);\n        var p0 = new PointF(width / 2, height / 2);\n        foreach (var p1 in spiral)\n        {\n            g.DrawLine(pen, p0, p1);\n            p0 = p1;\n        }\n        g.Save(); \n        bm.Save(\"archimedes-csharp.png\");\n        Process.Start(\"archimedes-csharp.png\"); \n    }\n}\n"}
{"id": 89333, "name": "Archimedean spiral", "source": "Translate Ruby to Java: INCR = 0.1\nattr_reader :x, :theta\n\ndef setup\n  sketch_title 'Archimedian Spiral'\n  @theta = 0\n  @x = 0\n  background(255)\n  translate(width / 2.0, height / 2.0)\n  begin_shape\n  (0..50*PI).step(INCR) do |theta|\n    @x = theta * cos(theta / PI)\n    curve_vertex(x, theta * sin(theta / PI))\n  end\n  end_shape\nend\n\ndef settings\n  size(300, 300)\nend\n", "target": "import java.awt.*;\nimport static java.lang.Math.*;\nimport javax.swing.*;\n\npublic class ArchimedeanSpiral extends JPanel {\n\n    public ArchimedeanSpiral() {\n        setPreferredSize(new Dimension(640, 640));\n        setBackground(Color.white);\n    }\n\n    void drawGrid(Graphics2D g) {\n        g.setColor(new Color(0xEEEEEE));\n        g.setStroke(new BasicStroke(2));\n\n        double angle = toRadians(45);\n\n        int w = getWidth();\n        int center = w / 2;\n        int margin = 10;\n        int numRings = 8;\n\n        int spacing = (w - 2 * margin) / (numRings * 2);\n\n        for (int i = 0; i < numRings; i++) {\n            int pos = margin + i * spacing;\n            int size = w - (2 * margin + i * 2 * spacing);\n            g.drawOval(pos, pos, size, size);\n\n            double ia = i * angle;\n            int x2 = center + (int) (cos(ia) * (w - 2 * margin) / 2);\n            int y2 = center - (int) (sin(ia) * (w - 2 * margin) / 2);\n\n            g.drawLine(center, center, x2, y2);\n        }\n    }\n\n    void drawSpiral(Graphics2D g) {\n        g.setStroke(new BasicStroke(2));\n        g.setColor(Color.orange);\n\n        double degrees = toRadians(0.1);\n        double center = getWidth() / 2;\n        double end = 360 * 2 * 10 * degrees;\n        double a = 0;\n        double b = 20;\n        double c = 1;\n\n        for (double theta = 0; theta < end; theta += degrees) {\n            double r = a + b * pow(theta, 1 / c);\n            double x = r * cos(theta);\n            double y = r * sin(theta);\n            plot(g, (int) (center + x), (int) (center - y));\n        }\n    }\n\n    void plot(Graphics2D g, int x, int y) {\n        g.drawOval(x, y, 1, 1);\n    }\n\n    @Override\n    public void paintComponent(Graphics gg) {\n        super.paintComponent(gg);\n        Graphics2D g = (Graphics2D) gg;\n        g.setRenderingHint(RenderingHints.KEY_ANTIALIASING,\n                RenderingHints.VALUE_ANTIALIAS_ON);\n\n        drawGrid(g);\n        drawSpiral(g);\n    }\n\n    public static void main(String[] args) {\n        SwingUtilities.invokeLater(() -> {\n            JFrame f = new JFrame();\n            f.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n            f.setTitle(\"Archimedean Spiral\");\n            f.setResizable(false);\n            f.add(new ArchimedeanSpiral(), BorderLayout.CENTER);\n            f.pack();\n            f.setLocationRelativeTo(null);\n            f.setVisible(true);\n        });\n    }\n}\n"}
{"id": 89334, "name": "Archimedean spiral", "source": "Translate Ruby to Python: INCR = 0.1\nattr_reader :x, :theta\n\ndef setup\n  sketch_title 'Archimedian Spiral'\n  @theta = 0\n  @x = 0\n  background(255)\n  translate(width / 2.0, height / 2.0)\n  begin_shape\n  (0..50*PI).step(INCR) do |theta|\n    @x = theta * cos(theta / PI)\n    curve_vertex(x, theta * sin(theta / PI))\n  end\n  end_shape\nend\n\ndef settings\n  size(300, 300)\nend\n", "target": "theta = 0\nrotation = 0.1\n\ndef setup():\n    size(300, 300)\n    background(255)\n\ndef draw():\n    global theta\n    translate(width / 2.0, height / 2.0)\n    x = theta * cos(theta / PI)\n    y = theta * sin(theta / PI)\n    point(x, y)\n    theta = theta + rotation\n    \n    if x > width / 2.0:\n        background(255)\n        theta = 0\n"}
{"id": 89335, "name": "Archimedean spiral", "source": "Translate Ruby to Python: INCR = 0.1\nattr_reader :x, :theta\n\ndef setup\n  sketch_title 'Archimedian Spiral'\n  @theta = 0\n  @x = 0\n  background(255)\n  translate(width / 2.0, height / 2.0)\n  begin_shape\n  (0..50*PI).step(INCR) do |theta|\n    @x = theta * cos(theta / PI)\n    curve_vertex(x, theta * sin(theta / PI))\n  end\n  end_shape\nend\n\ndef settings\n  size(300, 300)\nend\n", "target": "theta = 0\nrotation = 0.1\n\ndef setup():\n    size(300, 300)\n    background(255)\n\ndef draw():\n    global theta\n    translate(width / 2.0, height / 2.0)\n    x = theta * cos(theta / PI)\n    y = theta * sin(theta / PI)\n    point(x, y)\n    theta = theta + rotation\n    \n    if x > width / 2.0:\n        background(255)\n        theta = 0\n"}
{"id": 89559, "name": "Named parameters", "source": "Translate Ruby to C#: def example(foo: 0, bar: 1, grill: \"pork chops\")\n  puts \"foo is \nend\n\n\nexample(grill: \"lamb kebab\", bar: 3.14)\n", "target": "using System;\n\nnamespace NamedParams\n{\n    class Program\n    {\n        static void AddWidget(string parent, float x = 0, float y = 0, string text = \"Default\")\n        {\n            Console.WriteLine(\"parent = {0}, x = {1}, y = {2}, text = {3}\", parent, x, y, text);\n        }\n\n        static void Main(string[] args)\n        {\n            AddWidget(\"root\", 320, 240, \"First\");\n            AddWidget(\"root\", text: \"Origin\");\n            AddWidget(\"root\", 500);\n            AddWidget(\"root\", text: \"Footer\", y: 400);\n        }\n    }\n}\n"}
{"id": 89561, "name": "Named parameters", "source": "Translate Ruby to Java: def example(foo: 0, bar: 1, grill: \"pork chops\")\n  puts \"foo is \nend\n\n\nexample(grill: \"lamb kebab\", bar: 3.14)\n", "target": "module NamedParams\n    {\n    const Point(Int x, Int y)\n        {\n        Point with(Int? x=Null, Int? y=Null)\n            {\n            return new Point(x ?: this.x, y ?: this.y);\n            }\n        }\n\n    @Inject Console console;\n\n    void run()\n        {\n        Point origin = new Point(0, 0);\n        console.print($\"origin={origin}\");\n        Point moveRight = origin.with(x=5);\n        console.print($\"moveRight(x=5)={moveRight}\");\n        Point moveUp    = moveRight.with(y=3);\n        console.print($\"moveUp(y=3)={moveUp}\");\n        }\n    }\n"}
{"id": 89562, "name": "Named parameters", "source": "Translate Ruby to Python: def example(foo: 0, bar: 1, grill: \"pork chops\")\n  puts \"foo is \nend\n\n\nexample(grill: \"lamb kebab\", bar: 3.14)\n", "target": "def subtract(x, y):\n    return x - y\n\nsubtract(5, 3)         \nsubtract(y = 3, x = 5) \n"}
{"id": 89816, "name": "Catalan numbers", "source": "Translate Ruby to C#: require \"big\"\nrequire \"benchmark\"\n\ndef factorial(n : BigInt) : BigInt\n  (1..n).product(1.to_big_i)\nend\n\ndef factorial(n : Int32 | Int64)\n  factorial n.to_big_i\nend\n\n\n\ndef catalan_direct(n)\n  factorial(2*n) / (factorial(n + 1) * factorial(n))\nend\n\n\n\ndef catalan_rec1(n)\n  return 1 if n == 0\n  (0...n).reduce(0) do |sum, i|\n    sum + catalan_rec1(i) * catalan_rec1(n - 1 - i)\n  end\nend\n\ndef catalan_rec2(n)\n  return 1 if n == 0\n  2*(2*n - 1) * catalan_rec2(n - 1) / (n + 1)\nend\n\n\n\nBenchmark.bm do |b|\n  b.report(\"catalan_direct\") { 16.times { |n| catalan_direct(n) } }\n  b.report(\"catalan_rec1\") { 16.times { |n| catalan_rec1(n) } }\n  b.report(\"catalan_rec2\") { 16.times { |n| catalan_rec2(n) } }\nend\n\nputs \"\\n       direct     rec1     rec2\"\n16.times { |n| puts \"%2d\u00a0:%9d%9d%9d\" % [n, catalan_direct(n), catalan_rec1(n), catalan_rec2(n)] }\n", "target": "namespace CatalanNumbers\n{\n    \n    \n    \n    public class CatalanNumberGenerator\n    {\n        private static double Factorial(double n)\n        {\n            if (n == 0)\n                return 1;\n\n            return n * Factorial(n - 1);\n        }\n\n        public double FirstOption(double n)\n        {\n            const double topMultiplier = 2;\n            return Factorial(topMultiplier * n) / (Factorial(n + 1) * Factorial(n));\n        }\n\n        public double SecondOption(double n)\n        {\n            if (n == 0)\n            {\n                return 1;\n            }\n            double sum = 0;\n            double i = 0;\n            for (; i <= (n - 1); i++)\n            {\n                sum += SecondOption(i) * SecondOption((n - 1) - i);\n            }\n            return sum;\n        }\n\n        public double ThirdOption(double n)\n        {\n            if (n == 0)\n            {\n                return 1;\n            }\n            return ((2 * (2 * n - 1)) / (n + 1)) * ThirdOption(n - 1);\n        }\n    }\n}\n\n\n\nusing System;\nusing System.Configuration;\n\n\n\n\n\n\n\n\n\n\nnamespace CatalanNumbers\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            CatalanNumberGenerator generator = new CatalanNumberGenerator();\n            int i = 0;\n            DateTime initial;\n            DateTime final;\n            TimeSpan ts;\n\n            try\n            {\n                initial = DateTime.Now;\n                for (; i <= Convert.ToInt32(ConfigurationManager.AppSettings[\"MaxCatalanNumber\"]); i++)\n                {\n                    Console.WriteLine(\"CatalanNumber({0}):{1}\", i, generator.FirstOption(i));\n                }\n                final = DateTime.Now;\n                ts = final - initial;\n                Console.WriteLine(\"It took {0}.{1} to execute\\n\", ts.Seconds, ts.Milliseconds);\n\n                i = 0;\n                initial = DateTime.Now;\n                for (; i <= Convert.ToInt32(ConfigurationManager.AppSettings[\"MaxCatalanNumber\"]); i++)\n                {\n                    Console.WriteLine(\"CatalanNumber({0}):{1}\", i, generator.SecondOption(i));\n                }\n                final = DateTime.Now;\n                ts = final - initial;\n                Console.WriteLine(\"It took {0}.{1} to execute\\n\", ts.Seconds, ts.Milliseconds);   \n\n                i = 0;\n                initial = DateTime.Now;\n                for (; i <= Convert.ToInt32(ConfigurationManager.AppSettings[\"MaxCatalanNumber\"]); i++)\n                {\n                    Console.WriteLine(\"CatalanNumber({0}):{1}\", i, generator.ThirdOption(i));\n                }\n                final = DateTime.Now;\n                ts = final - initial;\n                Console.WriteLine(\"It took {0}.{1} to execute\", ts.Seconds, ts.Milliseconds, ts.TotalMilliseconds);\n                Console.ReadLine();\n            }\n            catch (Exception ex)\n            {\n                Console.WriteLine(\"Stopped at index {0}:\", i);\n                Console.WriteLine(ex.Message);\n                Console.ReadLine();\n            }\n        }\n    }\n}\n"}
{"id": 89818, "name": "Catalan numbers", "source": "Translate Ruby to Java: require \"big\"\nrequire \"benchmark\"\n\ndef factorial(n : BigInt) : BigInt\n  (1..n).product(1.to_big_i)\nend\n\ndef factorial(n : Int32 | Int64)\n  factorial n.to_big_i\nend\n\n\n\ndef catalan_direct(n)\n  factorial(2*n) / (factorial(n + 1) * factorial(n))\nend\n\n\n\ndef catalan_rec1(n)\n  return 1 if n == 0\n  (0...n).reduce(0) do |sum, i|\n    sum + catalan_rec1(i) * catalan_rec1(n - 1 - i)\n  end\nend\n\ndef catalan_rec2(n)\n  return 1 if n == 0\n  2*(2*n - 1) * catalan_rec2(n - 1) / (n + 1)\nend\n\n\n\nBenchmark.bm do |b|\n  b.report(\"catalan_direct\") { 16.times { |n| catalan_direct(n) } }\n  b.report(\"catalan_rec1\") { 16.times { |n| catalan_rec1(n) } }\n  b.report(\"catalan_rec2\") { 16.times { |n| catalan_rec2(n) } }\nend\n\nputs \"\\n       direct     rec1     rec2\"\n16.times { |n| puts \"%2d\u00a0:%9d%9d%9d\" % [n, catalan_direct(n), catalan_rec1(n), catalan_rec2(n)] }\n", "target": "import java.math.BigInteger;\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\n\npublic class CatlanNumbers {\n\n    public static void main(String[] args) {\n        Catlan f1 = new Catlan1();\n        Catlan f2 = new Catlan2();\n        Catlan f3 = new Catlan3();\n        System.out.printf(\"           Formula 1     Formula 2     Formula 3%n\");\n        for ( int n = 0 ; n <= 15 ; n++ ) {\n             System.out.printf(\"C(%2d) =\u00a0%,12d \u00a0%,12d \u00a0%,12d%n\", n, f1.catlin(n), f2.catlin(n), f3.catlin(n));\n        }\n    }\n    \n    private static interface Catlan {\n        public BigInteger catlin(long n);\n    }\n    \n    private static class Catlan1 implements Catlan {\n\n        \n        @Override\n        public BigInteger catlin(long n) {\n            List<Long> numerator = new ArrayList<>();\n            for ( long k = n+2 ; k <= 2*n ; k++ ) {\n                numerator.add(k);\n            }\n            \n            List<Long> denominator = new ArrayList<>();\n            for ( long k = 2 ; k <= n ; k++ ) {\n                denominator.add(k);\n            }\n            \n            for ( int i = numerator.size()-1 ; i >= 0  ; i-- ) {\n                for ( int j = denominator.size()-1 ; j >= 0  ; j-- ) {\n                    if ( denominator.get(j) == 1 ) {\n                        continue;\n                    }\n                    if ( numerator.get(i) % denominator.get(j) == 0 ) {\n                        long val = numerator.get(i) / denominator.get(j);\n                        numerator.set(i, val);\n                        denominator.remove(denominator.get(j));\n                        if ( val == 1 ) {\n                            break;\n                        }\n                    }\n                }\n            }\n\n            BigInteger catlin = BigInteger.ONE;\n            for ( int i = 0 ; i < numerator.size() ; i++ ) {\n                catlin = catlin.multiply(BigInteger.valueOf(numerator.get(i)));\n            }\n            for ( int i = 0 ; i < denominator.size() ; i++ ) {\n                catlin = catlin.divide(BigInteger.valueOf(denominator.get(i)));\n            }\n            return catlin;\n        }        \n    }\n    \n    private static class Catlan2 implements Catlan {\n\n        private static Map<Long,BigInteger> CACHE = new HashMap<>();\n        static {\n            CACHE.put(0L, BigInteger.ONE);\n        }\n        \n        \n        @Override\n        public BigInteger catlin(long n) {\n            if ( CACHE.containsKey(n) ) {\n                return CACHE.get(n);\n            }\n            BigInteger catlin = BigInteger.ZERO;\n            n--;\n            for ( int i = 0 ; i <= n ; i++ ) {\n                \n                catlin = catlin.add(catlin(i).multiply(catlin(n-i)));\n            }\n            CACHE.put(n+1, catlin);\n            return catlin;\n        }\n    }\n    \n    private static class Catlan3 implements Catlan {\n\n        private static Map<Long,BigInteger> CACHE = new HashMap<>();\n        static {\n            CACHE.put(0L, BigInteger.ONE);\n        }\n        \n        \n        @Override\n        public BigInteger catlin(long n) {\n            if ( CACHE.containsKey(n) ) {\n                return CACHE.get(n);\n            }\n            BigInteger catlin = BigInteger.valueOf(2).multiply(BigInteger.valueOf(2*n-1)).multiply(catlin(n-1)).divide(BigInteger.valueOf(n+1));\n            CACHE.put(n, catlin);\n            return catlin;\n        }\n    }\n\n}\n"}
{"id": 89819, "name": "Catalan numbers", "source": "Translate Ruby to Python: require \"big\"\nrequire \"benchmark\"\n\ndef factorial(n : BigInt) : BigInt\n  (1..n).product(1.to_big_i)\nend\n\ndef factorial(n : Int32 | Int64)\n  factorial n.to_big_i\nend\n\n\n\ndef catalan_direct(n)\n  factorial(2*n) / (factorial(n + 1) * factorial(n))\nend\n\n\n\ndef catalan_rec1(n)\n  return 1 if n == 0\n  (0...n).reduce(0) do |sum, i|\n    sum + catalan_rec1(i) * catalan_rec1(n - 1 - i)\n  end\nend\n\ndef catalan_rec2(n)\n  return 1 if n == 0\n  2*(2*n - 1) * catalan_rec2(n - 1) / (n + 1)\nend\n\n\n\nBenchmark.bm do |b|\n  b.report(\"catalan_direct\") { 16.times { |n| catalan_direct(n) } }\n  b.report(\"catalan_rec1\") { 16.times { |n| catalan_rec1(n) } }\n  b.report(\"catalan_rec2\") { 16.times { |n| catalan_rec2(n) } }\nend\n\nputs \"\\n       direct     rec1     rec2\"\n16.times { |n| puts \"%2d\u00a0:%9d%9d%9d\" % [n, catalan_direct(n), catalan_rec1(n), catalan_rec2(n)] }\n", "target": "from math import factorial\nimport functools\n\n\ndef memoize(func):\n    cache = {}\n\n    def memoized(key):\n        \n        if key not in cache:\n            cache[key] = func(key)\n        return cache[key]\n    return functools.update_wrapper(memoized, func)\n\n\n@memoize\ndef fact(n):\n    return factorial(n)\n\n\ndef cat_direct(n):\n    return fact(2 * n) // fact(n + 1) // fact(n)\n\n\n@memoize\ndef catR1(n):\n    return 1 if n == 0 else (\n        sum(catR1(i) * catR1(n - 1 - i) for i in range(n))\n    )\n\n\n@memoize\ndef catR2(n):\n    return 1 if n == 0 else (\n        ((4 * n - 2) * catR2(n - 1)) // (n + 1)\n    )\n\n\nif __name__ == '__main__':\n    def pr(results):\n        fmt = '%-10s %-10s %-10s'\n        print((fmt % tuple(c.__name__ for c in defs)).upper())\n        print(fmt % (('=' * 10,) * 3))\n        for r in zip(*results):\n            print(fmt % r)\n\n    defs = (cat_direct, catR1, catR2)\n    results = [tuple(c(i) for i in range(15)) for c in defs]\n    pr(results)\n"}
{"id": 90085, "name": "Reverse a string", "source": "Translate Ruby to C#: \n\nstrings = [\"asdf\", \"as\u20dddf\u0305\"]\nstrings.each do |s|\n  puts \"\nend\n", "target": "using System;\n\nnamespace System\n{\n\textension String\n\t{\n\t\tpublic void Reverse()\n\t\t{\n\t\t\tint i = 0;\n\t\t\tint j = mLength - 1;\n\t\t\twhile (i < j)\n\t\t\t{\n\t\t\t\tSwap!(Ptr[i++], Ptr[j--]);\n\t\t\t}\n\t\t}\n\t}\n}\n\nnamespace StringReverse\n{\n\tclass Program\n\t{\n\t\tstatic void Main()\n\t\t{\n\t\t\tString s = scope .(\"abcdef\");\n\t\t\ts.Reverse();\n\t\t\tConsole.WriteLine(s);\n\t\t}\n\t}\n}\n"}
{"id": 90087, "name": "Reverse a string", "source": "Translate Ruby to Java: \n\nstrings = [\"asdf\", \"as\u20dddf\u0305\"]\nstrings.each do |s|\n  puts \"\nend\n", "target": "String str = 'Hello World!';\nstr = str.reverse();\nsystem.debug(str);\n"}
{"id": 90088, "name": "Reverse a string", "source": "Translate Ruby to Python: \n\nstrings = [\"asdf\", \"as\u20dddf\u0305\"]\nstrings.each do |s|\n  puts \"\nend\n", "target": "input()[::-1]\n"}
{"id": 90400, "name": "Barnsley fern", "source": "Translate Ruby to C#: MAX_ITERATIONS = 200_000\n\ndef setup\n  sketch_title 'Barnsley Fern'\n  no_loop\n  puts 'Be patient. This takes about 10 seconds to render.'\nend\n\ndef draw\n  background 0\n  load_pixels\n  x0 = 0.0\n  y0 = 0.0\n  x = 0.0\n  y = 0.0\n  MAX_ITERATIONS.times do\n    r = rand(100)\n    if r < 85\n      x = 0.85 * x0 + 0.04 * y0\n      y = -0.04 * x0 + 0.85 * y0 + 1.6\n    elsif r < 92\n      x = 0.2 * x0 - 0.26 * y0\n      y = 0.23 * x0 + 0.22 * y0 + 1.6\n    elsif r < 99\n      x = -0.15 * x0 + 0.28 * y0\n      y = 0.26 * x0 + 0.24 * y0 + 0.44\n    else\n      x = 0\n      y = 0.16 * y\n    end\n    i = height - (y * 48).to_i\n    j = width / 2 + (x * 48).to_i\n    pixels[i * height + j] += 2_560\n    x0 = x\n    y0 = y\n  end\n  update_pixels\nend\n\ndef settings\n  size 500, 500\nend\n", "target": "using System;\nusing System.Diagnostics;\nusing System.Drawing;\n\nnamespace RosettaBarnsleyFern\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            const int w = 600;\n            const int h = 600;\n            var bm = new Bitmap(w, h);\n            var r = new Random();\n            double x = 0;\n            double y = 0;\n            for (int count = 0; count < 100000; count++)\n            {\n                bm.SetPixel((int)(300 + 58 * x), (int)(58 * y), Color.ForestGreen);\n                int roll = r.Next(100);\n                double xp = x;\n                if (roll < 1)\n                {\n                    x = 0;\n                    y = 0.16 * y;\n                } else if (roll < 86)\n                {\n                    x = 0.85 * x + 0.04 * y;\n                    y = -0.04 * xp + 0.85 * y + 1.6;\n                } else if (roll < 93)\n                {\n                    x = 0.2 * x - 0.26 * y;\n                    y = 0.23 * xp + 0.22 * y + 1.6;\n                } else\n                {\n                    x = -0.15 * x + 0.28 * y;\n                    y = 0.26 * xp + 0.24 * y + 0.44;\n                }\n            }\n            const string filename = \"Fern.png\";\n            bm.Save(filename);\n            Process.Start(filename);\n        }\n    }\n}\n"}
{"id": 90401, "name": "Barnsley fern", "source": "Translate Ruby to C#: MAX_ITERATIONS = 200_000\n\ndef setup\n  sketch_title 'Barnsley Fern'\n  no_loop\n  puts 'Be patient. This takes about 10 seconds to render.'\nend\n\ndef draw\n  background 0\n  load_pixels\n  x0 = 0.0\n  y0 = 0.0\n  x = 0.0\n  y = 0.0\n  MAX_ITERATIONS.times do\n    r = rand(100)\n    if r < 85\n      x = 0.85 * x0 + 0.04 * y0\n      y = -0.04 * x0 + 0.85 * y0 + 1.6\n    elsif r < 92\n      x = 0.2 * x0 - 0.26 * y0\n      y = 0.23 * x0 + 0.22 * y0 + 1.6\n    elsif r < 99\n      x = -0.15 * x0 + 0.28 * y0\n      y = 0.26 * x0 + 0.24 * y0 + 0.44\n    else\n      x = 0\n      y = 0.16 * y\n    end\n    i = height - (y * 48).to_i\n    j = width / 2 + (x * 48).to_i\n    pixels[i * height + j] += 2_560\n    x0 = x\n    y0 = y\n  end\n  update_pixels\nend\n\ndef settings\n  size 500, 500\nend\n", "target": "using System;\nusing System.Diagnostics;\nusing System.Drawing;\n\nnamespace RosettaBarnsleyFern\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            const int w = 600;\n            const int h = 600;\n            var bm = new Bitmap(w, h);\n            var r = new Random();\n            double x = 0;\n            double y = 0;\n            for (int count = 0; count < 100000; count++)\n            {\n                bm.SetPixel((int)(300 + 58 * x), (int)(58 * y), Color.ForestGreen);\n                int roll = r.Next(100);\n                double xp = x;\n                if (roll < 1)\n                {\n                    x = 0;\n                    y = 0.16 * y;\n                } else if (roll < 86)\n                {\n                    x = 0.85 * x + 0.04 * y;\n                    y = -0.04 * xp + 0.85 * y + 1.6;\n                } else if (roll < 93)\n                {\n                    x = 0.2 * x - 0.26 * y;\n                    y = 0.23 * xp + 0.22 * y + 1.6;\n                } else\n                {\n                    x = -0.15 * x + 0.28 * y;\n                    y = 0.26 * xp + 0.24 * y + 0.44;\n                }\n            }\n            const string filename = \"Fern.png\";\n            bm.Save(filename);\n            Process.Start(filename);\n        }\n    }\n}\n"}
{"id": 90404, "name": "Barnsley fern", "source": "Translate Ruby to Java: MAX_ITERATIONS = 200_000\n\ndef setup\n  sketch_title 'Barnsley Fern'\n  no_loop\n  puts 'Be patient. This takes about 10 seconds to render.'\nend\n\ndef draw\n  background 0\n  load_pixels\n  x0 = 0.0\n  y0 = 0.0\n  x = 0.0\n  y = 0.0\n  MAX_ITERATIONS.times do\n    r = rand(100)\n    if r < 85\n      x = 0.85 * x0 + 0.04 * y0\n      y = -0.04 * x0 + 0.85 * y0 + 1.6\n    elsif r < 92\n      x = 0.2 * x0 - 0.26 * y0\n      y = 0.23 * x0 + 0.22 * y0 + 1.6\n    elsif r < 99\n      x = -0.15 * x0 + 0.28 * y0\n      y = 0.26 * x0 + 0.24 * y0 + 0.44\n    else\n      x = 0\n      y = 0.16 * y\n    end\n    i = height - (y * 48).to_i\n    j = width / 2 + (x * 48).to_i\n    pixels[i * height + j] += 2_560\n    x0 = x\n    y0 = y\n  end\n  update_pixels\nend\n\ndef settings\n  size 500, 500\nend\n", "target": "import java.awt.*;\nimport java.awt.image.BufferedImage;\nimport javax.swing.*;\n\npublic class BarnsleyFern extends JPanel {\n\n    BufferedImage img;\n\n    public BarnsleyFern() {\n        final int dim = 640;\n        setPreferredSize(new Dimension(dim, dim));\n        setBackground(Color.white);\n        img = new BufferedImage(dim, dim, BufferedImage.TYPE_INT_ARGB);\n        createFern(dim, dim);\n    }\n\n    void createFern(int w, int h) {\n        double x = 0;\n        double y = 0;\n\n        for (int i = 0; i < 200_000; i++) {\n            double tmpx, tmpy;\n            double r = Math.random();\n\n            if (r <= 0.01) {\n                tmpx = 0;\n                tmpy = 0.16 * y;\n            } else if (r <= 0.08) {\n                tmpx = 0.2 * x - 0.26 * y;\n                tmpy = 0.23 * x + 0.22 * y + 1.6;\n            } else if (r <= 0.15) {\n                tmpx = -0.15 * x + 0.28 * y;\n                tmpy = 0.26 * x + 0.24 * y + 0.44;\n            } else {\n                tmpx = 0.85 * x + 0.04 * y;\n                tmpy = -0.04 * x + 0.85 * y + 1.6;\n            }\n            x = tmpx;\n            y = tmpy;\n\n            img.setRGB((int) Math.round(w / 2 + x * w / 11),\n                    (int) Math.round(h - y * h / 11), 0xFF32CD32);\n        }\n    }\n\n    @Override\n    public void paintComponent(Graphics gg) {\n        super.paintComponent(gg);\n        Graphics2D g = (Graphics2D) gg;\n        g.setRenderingHint(RenderingHints.KEY_ANTIALIASING,\n                RenderingHints.VALUE_ANTIALIAS_ON);\n\n        g.drawImage(img, 0, 0, null);\n    }\n\n    public static void main(String[] args) {\n        SwingUtilities.invokeLater(() -> {\n            JFrame f = new JFrame();\n            f.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n            f.setTitle(\"Barnsley Fern\");\n            f.setResizable(false);\n            f.add(new BarnsleyFern(), BorderLayout.CENTER);\n            f.pack();\n            f.setLocationRelativeTo(null);\n            f.setVisible(true);\n        });\n    }\n}\n"}
{"id": 90405, "name": "Barnsley fern", "source": "Translate Ruby to Java: MAX_ITERATIONS = 200_000\n\ndef setup\n  sketch_title 'Barnsley Fern'\n  no_loop\n  puts 'Be patient. This takes about 10 seconds to render.'\nend\n\ndef draw\n  background 0\n  load_pixels\n  x0 = 0.0\n  y0 = 0.0\n  x = 0.0\n  y = 0.0\n  MAX_ITERATIONS.times do\n    r = rand(100)\n    if r < 85\n      x = 0.85 * x0 + 0.04 * y0\n      y = -0.04 * x0 + 0.85 * y0 + 1.6\n    elsif r < 92\n      x = 0.2 * x0 - 0.26 * y0\n      y = 0.23 * x0 + 0.22 * y0 + 1.6\n    elsif r < 99\n      x = -0.15 * x0 + 0.28 * y0\n      y = 0.26 * x0 + 0.24 * y0 + 0.44\n    else\n      x = 0\n      y = 0.16 * y\n    end\n    i = height - (y * 48).to_i\n    j = width / 2 + (x * 48).to_i\n    pixels[i * height + j] += 2_560\n    x0 = x\n    y0 = y\n  end\n  update_pixels\nend\n\ndef settings\n  size 500, 500\nend\n", "target": "import java.awt.*;\nimport java.awt.image.BufferedImage;\nimport javax.swing.*;\n\npublic class BarnsleyFern extends JPanel {\n\n    BufferedImage img;\n\n    public BarnsleyFern() {\n        final int dim = 640;\n        setPreferredSize(new Dimension(dim, dim));\n        setBackground(Color.white);\n        img = new BufferedImage(dim, dim, BufferedImage.TYPE_INT_ARGB);\n        createFern(dim, dim);\n    }\n\n    void createFern(int w, int h) {\n        double x = 0;\n        double y = 0;\n\n        for (int i = 0; i < 200_000; i++) {\n            double tmpx, tmpy;\n            double r = Math.random();\n\n            if (r <= 0.01) {\n                tmpx = 0;\n                tmpy = 0.16 * y;\n            } else if (r <= 0.08) {\n                tmpx = 0.2 * x - 0.26 * y;\n                tmpy = 0.23 * x + 0.22 * y + 1.6;\n            } else if (r <= 0.15) {\n                tmpx = -0.15 * x + 0.28 * y;\n                tmpy = 0.26 * x + 0.24 * y + 0.44;\n            } else {\n                tmpx = 0.85 * x + 0.04 * y;\n                tmpy = -0.04 * x + 0.85 * y + 1.6;\n            }\n            x = tmpx;\n            y = tmpy;\n\n            img.setRGB((int) Math.round(w / 2 + x * w / 11),\n                    (int) Math.round(h - y * h / 11), 0xFF32CD32);\n        }\n    }\n\n    @Override\n    public void paintComponent(Graphics gg) {\n        super.paintComponent(gg);\n        Graphics2D g = (Graphics2D) gg;\n        g.setRenderingHint(RenderingHints.KEY_ANTIALIASING,\n                RenderingHints.VALUE_ANTIALIAS_ON);\n\n        g.drawImage(img, 0, 0, null);\n    }\n\n    public static void main(String[] args) {\n        SwingUtilities.invokeLater(() -> {\n            JFrame f = new JFrame();\n            f.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n            f.setTitle(\"Barnsley Fern\");\n            f.setResizable(false);\n            f.add(new BarnsleyFern(), BorderLayout.CENTER);\n            f.pack();\n            f.setLocationRelativeTo(null);\n            f.setVisible(true);\n        });\n    }\n}\n"}
{"id": 90406, "name": "Barnsley fern", "source": "Translate Ruby to Python: MAX_ITERATIONS = 200_000\n\ndef setup\n  sketch_title 'Barnsley Fern'\n  no_loop\n  puts 'Be patient. This takes about 10 seconds to render.'\nend\n\ndef draw\n  background 0\n  load_pixels\n  x0 = 0.0\n  y0 = 0.0\n  x = 0.0\n  y = 0.0\n  MAX_ITERATIONS.times do\n    r = rand(100)\n    if r < 85\n      x = 0.85 * x0 + 0.04 * y0\n      y = -0.04 * x0 + 0.85 * y0 + 1.6\n    elsif r < 92\n      x = 0.2 * x0 - 0.26 * y0\n      y = 0.23 * x0 + 0.22 * y0 + 1.6\n    elsif r < 99\n      x = -0.15 * x0 + 0.28 * y0\n      y = 0.26 * x0 + 0.24 * y0 + 0.44\n    else\n      x = 0\n      y = 0.16 * y\n    end\n    i = height - (y * 48).to_i\n    j = width / 2 + (x * 48).to_i\n    pixels[i * height + j] += 2_560\n    x0 = x\n    y0 = y\n  end\n  update_pixels\nend\n\ndef settings\n  size 500, 500\nend\n", "target": "size(640, 640)\nbackground(0)\n\nx = 0\ny = 0\n\nfor _ in range(100000):\n    xt = 0\n    yt = 0\n    r = random(100)\n\n    if r <= 1:\n        xt = 0\n        yt = 0.16 * y\n    elif r <= 8:\n        xt = 0.20 * x - 0.26 * y\n        yt = 0.23 * x + 0.22 * y + 1.60\n    elif r <= 15:\n        xt = -0.15 * x + 0.28 * y\n        yt = +0.26 * x + 0.24 * y + 0.44\n    else:\n        xt = +0.85 * x + 0.04 * y\n        yt = -0.04 * x + 0.85 * y + 1.60\nsize(640, 640)\nbackground(0)\n\nx = 0\ny = 0\n\nfor _ in range(100000):\n    xt = 0\n    yt = 0\n    r = random(100)\n    \n    if r <= 1:\n        xt = 0\n        yt = 0.16*y\n    elif r <= 8:\n        xt = 0.20*x - 0.26*y\n        yt = 0.23*x + 0.22*y + 1.60\n    elif r <= 15:\n        xt = -0.15*x + 0.28*y\n        yt =    0.26*x + 0.24*y + 0.44\n    else:\n        xt =    0.85*x + 0.04*y\n        yt = -0.04*x + 0.85*y + 1.60\n    \n    x = xt\n    y = yt\n\n    m = round(width/2 + 60*x)\n    n = height-round(60*y)\n\n    set(m, n, \"\n    x = xt\n    y = yt\n\n    m = round(width / 2 + 60 * x)\n    n = height - round(60 * y)\n\n    set(m, n, \"\n"}
{"id": 90407, "name": "Barnsley fern", "source": "Translate Ruby to Python: MAX_ITERATIONS = 200_000\n\ndef setup\n  sketch_title 'Barnsley Fern'\n  no_loop\n  puts 'Be patient. This takes about 10 seconds to render.'\nend\n\ndef draw\n  background 0\n  load_pixels\n  x0 = 0.0\n  y0 = 0.0\n  x = 0.0\n  y = 0.0\n  MAX_ITERATIONS.times do\n    r = rand(100)\n    if r < 85\n      x = 0.85 * x0 + 0.04 * y0\n      y = -0.04 * x0 + 0.85 * y0 + 1.6\n    elsif r < 92\n      x = 0.2 * x0 - 0.26 * y0\n      y = 0.23 * x0 + 0.22 * y0 + 1.6\n    elsif r < 99\n      x = -0.15 * x0 + 0.28 * y0\n      y = 0.26 * x0 + 0.24 * y0 + 0.44\n    else\n      x = 0\n      y = 0.16 * y\n    end\n    i = height - (y * 48).to_i\n    j = width / 2 + (x * 48).to_i\n    pixels[i * height + j] += 2_560\n    x0 = x\n    y0 = y\n  end\n  update_pixels\nend\n\ndef settings\n  size 500, 500\nend\n", "target": "size(640, 640)\nbackground(0)\n\nx = 0\ny = 0\n\nfor _ in range(100000):\n    xt = 0\n    yt = 0\n    r = random(100)\n\n    if r <= 1:\n        xt = 0\n        yt = 0.16 * y\n    elif r <= 8:\n        xt = 0.20 * x - 0.26 * y\n        yt = 0.23 * x + 0.22 * y + 1.60\n    elif r <= 15:\n        xt = -0.15 * x + 0.28 * y\n        yt = +0.26 * x + 0.24 * y + 0.44\n    else:\n        xt = +0.85 * x + 0.04 * y\n        yt = -0.04 * x + 0.85 * y + 1.60\nsize(640, 640)\nbackground(0)\n\nx = 0\ny = 0\n\nfor _ in range(100000):\n    xt = 0\n    yt = 0\n    r = random(100)\n    \n    if r <= 1:\n        xt = 0\n        yt = 0.16*y\n    elif r <= 8:\n        xt = 0.20*x - 0.26*y\n        yt = 0.23*x + 0.22*y + 1.60\n    elif r <= 15:\n        xt = -0.15*x + 0.28*y\n        yt =    0.26*x + 0.24*y + 0.44\n    else:\n        xt =    0.85*x + 0.04*y\n        yt = -0.04*x + 0.85*y + 1.60\n    \n    x = xt\n    y = yt\n\n    m = round(width/2 + 60*x)\n    n = height-round(60*y)\n\n    set(m, n, \"\n    x = xt\n    y = yt\n\n    m = round(width / 2 + 60 * x)\n    n = height - round(60 * y)\n\n    set(m, n, \"\n"}
{"id": 90850, "name": "Command-line arguments", "source": "Translate Ruby to C#: \np ARGV\n", "target": "using System;\n\nnamespace RosettaCode {\n    class Program {\n        static void Main(string[] args) {\n            for (int i = 0; i < args.Length; i++)\n                Console.WriteLine(String.Format(\"Argument {0} is '{1}'\", i, args[i]));\n        }\n    }\n}\n"}
{"id": 90851, "name": "Command-line arguments", "source": "Translate Ruby to C#: \np ARGV\n", "target": "using System;\n\nnamespace RosettaCode {\n    class Program {\n        static void Main(string[] args) {\n            for (int i = 0; i < args.Length; i++)\n                Console.WriteLine(String.Format(\"Argument {0} is '{1}'\", i, args[i]));\n        }\n    }\n}\n"}
{"id": 90854, "name": "Command-line arguments", "source": "Translate Ruby to Java: \np ARGV\n", "target": "public class Arguments {\n  public static void main(String[] args) {\n     System.out.println(\"There are \" + args.length + \" arguments given.\");\n     for(int i = 0; i < args.length; i++) \n        System.out.println(\"The argument #\" + (i+1) + \" is \" + args[i] + \" and is at index \" + i);\n  }\n}\n"}
{"id": 90855, "name": "Command-line arguments", "source": "Translate Ruby to Java: \np ARGV\n", "target": "public class Arguments {\n  public static void main(String[] args) {\n     System.out.println(\"There are \" + args.length + \" arguments given.\");\n     for(int i = 0; i < args.length; i++) \n        System.out.println(\"The argument #\" + (i+1) + \" is \" + args[i] + \" and is at index \" + i);\n  }\n}\n"}
{"id": 91372, "name": "Tokenize a string", "source": "Translate Ruby to C#: puts \"Hello,How,Are,You,Today\".split(',').join('.')\n", "target": "string str = \"Hello,How,Are,You,Today\"; \n\n\nstring[] strings = str.Split(',');\nConsole.WriteLine(String.Join(\".\", strings));\n"}
{"id": 91374, "name": "Tokenize a string", "source": "Translate Ruby to Java: puts \"Hello,How,Are,You,Today\".split(',').join('.')\n", "target": "String toTokenize = \"Hello,How,Are,You,Today\";\nSystem.out.println(String.join(\".\", toTokenize.split(\",\")));\n"}
{"id": 91375, "name": "Tokenize a string", "source": "Translate Ruby to Python: puts \"Hello,How,Are,You,Today\".split(',').join('.')\n", "target": "let text = 'Hello,How,Are,You,Today'\nlet tokens = text.split(||,||)\nprint tokens.join(with: '.')\n"}
{"id": 91567, "name": "Holidays related to Easter", "source": "Translate Ruby to C#: require 'date'\n\ndef easter_date(year)\n  \n  \n  \n  a    = year % 19\n  b, c = year.divmod(100)\n  d, e = b.divmod(4)\n  f    = (b + 8) / 25\n  g    = (b - f + 1) / 3\n  h    = (19*a + b - d - g + 15) % 30\n  i, k = c.divmod(4)\n  l    = (32 + 2*e + 2*i - h - k) % 7\n  m    = (a + 11*h + 22*l) / 451\n  numerator = h + l - 7*m + 114\n  month = numerator / 31\n  day = (numerator % 31) + 1\n  Date.new(year, month, day)\nend\n\nOFFSETS = [\n  [:easter,     0],\n  [:ascension, 39],\n  [:pentecost, 49],\n  [:trinity,   56],\n  [:corpus,    60],\n]\n\ndef emit_dates(year)\n  e = easter_date year\n  dates = OFFSETS.collect {|item, offset| (e + offset).strftime(\"  %e %b\")}\n  puts \"%4s: %s\" % [year, dates.join(',  ')]\nend\n\nputs \"year:\" + OFFSETS.collect{|item, offset| \"%9s\" % item}.join(', ')\n400.step(2100, 100).each {|year| emit_dates year}\nputs\n(2010 .. 2020).each {|year| emit_dates year}\n", "target": "using System;\nusing System.Collections;\nusing System.Collections.Specialized;\nusing System.Linq;\n\ninternal class Program\n{\n    private static readonly OrderedDictionary _holidayOffsets = new OrderedDictionary\n                                                                    {\n                                                                        {\"Easter\", 0},\n                                                                        {\"Ascension\", 39},\n                                                                        {\"Pentecost\", 49},\n                                                                        {\"Trinity\", 56},\n                                                                        {\"Corpus\", 60},\n                                                                    };\n\n    static void Main(string[] args)\n    {\n        Console.WriteLine(\"Christian holidays, related to Easter, for each centennial from 400 to 2100 CE:\");\n        for (int year = 400; year <= 2100; year += 100)\n            OutputHolidays(year);\n\n        Console.WriteLine();\n        Console.WriteLine(\"Christian holidays, related to Easter, for years from 2010 to 2020 CE:\");\n        for (int year = 2010; year <= 2020; year += 1)\n            OutputHolidays(year);\n    }\n\n    static void OutputHolidays(int year)\n    {\n        var easter = CalculateEaster(year);\n        var holidays = from kp in _holidayOffsets.OfType<DictionaryEntry>()\n                       let holiday = easter.AddDays(Convert.ToInt32(kp.Value))\n                       select kp.Key + \": \" + string.Format(\"{0,2:ddd} {0,2:%d} {0:MMM}\", holiday);\n        Console.WriteLine(\"{0,4} {1}\", year, string.Join(\", \", holidays.ToArray()));\n    }\n\n    static DateTime CalculateEaster(int year)\n    {\n        var a = year % 19;\n        var b = year / 100;\n        var c = year %100;\n        var d = b / 4;\n        var e = b % 4;\n        var f = (b + 8) / 25;\n        var g = (b - f + 1) / 3;\n        var h = (19 * a + b - d - g + 15) % 30;\n        var i = c / 4;\n        var k = c % 4;\n        var l = (32 + 2 * e + 2 * i - h - k) % 7;\n        var m = (a + 11 * h + 22 * l) / 451;\n        var numerator = h + l - 7 * m + 114;\n        var month = numerator / 31;\n        var day = (numerator % 31) + 1;\n        return new DateTime(year, month, day);\n    }\n}\n"}
{"id": 91568, "name": "Holidays related to Easter", "source": "Translate Ruby to Java: require 'date'\n\ndef easter_date(year)\n  \n  \n  \n  a    = year % 19\n  b, c = year.divmod(100)\n  d, e = b.divmod(4)\n  f    = (b + 8) / 25\n  g    = (b - f + 1) / 3\n  h    = (19*a + b - d - g + 15) % 30\n  i, k = c.divmod(4)\n  l    = (32 + 2*e + 2*i - h - k) % 7\n  m    = (a + 11*h + 22*l) / 451\n  numerator = h + l - 7*m + 114\n  month = numerator / 31\n  day = (numerator % 31) + 1\n  Date.new(year, month, day)\nend\n\nOFFSETS = [\n  [:easter,     0],\n  [:ascension, 39],\n  [:pentecost, 49],\n  [:trinity,   56],\n  [:corpus,    60],\n]\n\ndef emit_dates(year)\n  e = easter_date year\n  dates = OFFSETS.collect {|item, offset| (e + offset).strftime(\"  %e %b\")}\n  puts \"%4s: %s\" % [year, dates.join(',  ')]\nend\n\nputs \"year:\" + OFFSETS.collect{|item, offset| \"%9s\" % item}.join(', ')\n400.step(2100, 100).each {|year| emit_dates year}\nputs\n(2010 .. 2020).each {|year| emit_dates year}\n", "target": "import java.text.DateFormatSymbols;\nimport java.util.*;\n\npublic class EasterRelatedHolidays {\n\n    final static Map<String, Integer> holidayOffsets;\n\n    static {\n        holidayOffsets = new LinkedHashMap<>();\n        holidayOffsets.put(\"Easter\", 0);\n        holidayOffsets.put(\"Ascension\", 39);\n        holidayOffsets.put(\"Pentecost\", 10);\n        holidayOffsets.put(\"Trinity\", 7);\n        holidayOffsets.put(\"Corpus\", 4);\n    }\n\n    public static void main(String[] args) {\n        System.out.println(\"Christian holidays, related to Easter,\"\n                + \" for each centennial from 400 to 2100 CE:\");\n\n        for (int y = 400; y <= 2100; y += 100)\n            printEasterRelatedHolidays(y);\n\n        System.out.println(\"\\nChristian holidays, related to Easter,\"\n                + \" for years from 2010 to 2020 CE:\");\n        for (int y = 2010; y < 2021; y++)\n            printEasterRelatedHolidays(y);\n    }\n\n    static void printEasterRelatedHolidays(int year) {\n        final int a = year % 19;\n        final int b = year / 100;\n        final int c = year % 100;\n        final int d = b / 4;\n        final int e = b % 4;\n        final int f = (b + 8) / 25;\n        final int g = (b - f + 1) / 3;\n        final int h = (19 * a + b - d - g + 15) % 30;\n        final int i = c / 4;\n        final int k = c % 4;\n        final int l = (32 + 2 * e + 2 * i - h - k) % 7;\n        final int m = (a + 11 * h + 22 * l) / 451;\n        final int n = h + l - 7 * m + 114;\n        final int month = n / 31 - 1;\n        final int day = (n % 31) + 1;\n\n        Calendar date = new GregorianCalendar(year, month, day);\n        String[] months = new DateFormatSymbols(Locale.US).getShortMonths();\n\n        System.out.printf(\"%4d \", year);\n        for (String hd : holidayOffsets.keySet()) {\n            date.add(Calendar.DATE, holidayOffsets.get(hd));\n            System.out.printf(\"%s: %2d %s  \", hd,\n                    date.get(Calendar.DAY_OF_MONTH),\n                    months[date.get(Calendar.MONTH)]);\n        }\n        System.out.println();\n    }\n}\n"}
{"id": 91569, "name": "Holidays related to Easter", "source": "Translate Ruby to Python: require 'date'\n\ndef easter_date(year)\n  \n  \n  \n  a    = year % 19\n  b, c = year.divmod(100)\n  d, e = b.divmod(4)\n  f    = (b + 8) / 25\n  g    = (b - f + 1) / 3\n  h    = (19*a + b - d - g + 15) % 30\n  i, k = c.divmod(4)\n  l    = (32 + 2*e + 2*i - h - k) % 7\n  m    = (a + 11*h + 22*l) / 451\n  numerator = h + l - 7*m + 114\n  month = numerator / 31\n  day = (numerator % 31) + 1\n  Date.new(year, month, day)\nend\n\nOFFSETS = [\n  [:easter,     0],\n  [:ascension, 39],\n  [:pentecost, 49],\n  [:trinity,   56],\n  [:corpus,    60],\n]\n\ndef emit_dates(year)\n  e = easter_date year\n  dates = OFFSETS.collect {|item, offset| (e + offset).strftime(\"  %e %b\")}\n  puts \"%4s: %s\" % [year, dates.join(',  ')]\nend\n\nputs \"year:\" + OFFSETS.collect{|item, offset| \"%9s\" % item}.join(', ')\n400.step(2100, 100).each {|year| emit_dates year}\nputs\n(2010 .. 2020).each {|year| emit_dates year}\n", "target": "from dateutil.easter import *\nimport datetime, calendar\n\nclass Holiday(object):\n    def __init__(self, date, offset=0):\n        self.holiday = date + datetime.timedelta(days=offset)\n\n    def __str__(self):\n        dayofweek = calendar.day_name[self.holiday.weekday()][0:3]\n        month = calendar.month_name[self.holiday.month][0:3]\n        return '{0} {1:2d} {2}'.format(dayofweek, self.holiday.day, month)\n\ndef get_holiday_values(year):\n    holidays = {'year': year}\n    easterDate = easter(year)\n    holidays['easter'] = Holiday(easterDate) \n    holidays['ascension'] = Holiday(easterDate, 39)\n    holidays['pentecost'] = Holiday(easterDate, 49)\n    holidays['trinity'] = Holiday(easterDate, 56)\n    holidays['corpus'] = Holiday(easterDate, 60)\n    return holidays\n    \ndef print_holidays(holidays):\n    print '{year:4d} Easter: {easter}, Ascension: {ascension}, Pentecost: {pentecost}, Trinity: {trinity}, Corpus: {corpus}'.format(**holidays)\n    \nif __name__ == \"__main__\":\n    print \"Christian holidays, related to Easter, for each centennial from 400 to 2100 CE:\"\n    for year in range(400, 2200, 100):\n        print_holidays(get_holiday_values(year))\n\n    print ''\n    print \"Christian holidays, related to Easter, for years from 2010 to 2020 CE:\"\n    for year in range(2010, 2021):\n        print_holidays(get_holiday_values(year))\n"}
{"id": 91799, "name": "Stack", "source": "Translate Ruby to C#: stack = [] of Int32\n(1..10).each do |x|\n  stack.push x\nend\n\n10.times do\n  puts stack.pop\nend\n", "target": "\nSystem.Collections.Stack stack = new System.Collections.Stack();\nstack.Push( obj );\nbool isEmpty = stack.Count == 0;\nobject top = stack.Peek(); \ntop = stack.Pop();\n\n\nSystem.Collections.Generic.Stack<Foo> stack = new System.Collections.Generic.Stack<Foo>();\nstack.Push(new Foo());\nbool isEmpty = stack.Count == 0;\nFoo top = stack.Peek(); \ntop = stack.Pop();\n"}
{"id": 91801, "name": "Stack", "source": "Translate Ruby to Java: stack = [] of Int32\n(1..10).each do |x|\n  stack.push x\nend\n\n10.times do\n  puts stack.pop\nend\n", "target": "import java.util.Stack;\n\npublic class StackTest {\n    public static void main( final String[] args ) {\n        final Stack<String> stack = new Stack<String>();\n\n        System.out.println( \"New stack empty? \" + stack.empty() );\n\n        stack.push( \"There can be only one\" );\n        System.out.println( \"Pushed stack empty? \" + stack.empty() );\n        System.out.println( \"Popped single entry: \" + stack.pop() );\n\n        stack.push( \"First\" );\n        stack.push( \"Second\" );\n        System.out.println( \"Popped entry should be second: \" + stack.pop() );\n\n        \n        stack.pop();\n        stack.pop();\n    }\n}\n"}
{"id": 91802, "name": "Stack", "source": "Translate Ruby to Python: stack = [] of Int32\n(1..10).each do |x|\n  stack.push x\nend\n\n10.times do\n  puts stack.pop\nend\n", "target": "from collections import deque\nstack = deque()\nstack.append(value) \nvalue = stack.pop()\nnot stack \n"}
{"id": 92043, "name": "CRC-32", "source": "Translate Ruby to C#: require 'zlib'\nprintf \"0x%08x\\n\", Zlib.crc32('The quick brown fox jumps over the lazy dog')\n\n", "target": "    \n    \n    \n    public class Crc32\n    {\n        #region Constants\n        \n        \n        \n        private const UInt32 s_generator = 0xEDB88320;\n        #endregion\n\n        #region Constructors\n        \n        \n        \n        public Crc32()\n        {\n            \n            m_checksumTable = Enumerable.Range(0, 256).Select(i =>\n            {\n                var tableEntry = (uint)i;\n                for (var j = 0; j < 8; ++j)\n                {\n                    tableEntry = ((tableEntry & 1) != 0)\n                        ? (s_generator ^ (tableEntry >> 1)) \n                        : (tableEntry >> 1);\n                }\n                return tableEntry;\n            }).ToArray();\n        }\n        #endregion\n\n        #region Methods\n        \n        \n        \n        \n        \n        public UInt32 Get<T>(IEnumerable<T> byteStream)\n        {\n            try\n            {\n                \n                return ~byteStream.Aggregate(0xFFFFFFFF, (checksumRegister, currentByte) => \n                          (m_checksumTable[(checksumRegister & 0xFF) ^ Convert.ToByte(currentByte)] ^ (checksumRegister >> 8)));\n            }\n            catch (FormatException e)\n            {\n                throw new CrcException(\"Could not read the stream out as bytes.\", e);\n            }\n            catch (InvalidCastException e)\n            {\n                throw new CrcException(\"Could not read the stream out as bytes.\", e);\n            }\n            catch (OverflowException e)\n            {\n                throw new CrcException(\"Could not read the stream out as bytes.\", e);\n            }\n        }\n        #endregion\n\n        #region Fields\n        \n        \n        \n        private readonly UInt32[] m_checksumTable;\n\n        #endregion\n    }\n"}
{"id": 92045, "name": "CRC-32", "source": "Translate Ruby to Java: require 'zlib'\nprintf \"0x%08x\\n\", Zlib.crc32('The quick brown fox jumps over the lazy dog')\n\n", "target": "import java.util.zip.* ;\n\npublic class CRCMaker {\n   public static void main( String[ ] args ) {\n      String toBeEncoded = new String( \"The quick brown fox jumps over the lazy dog\" ) ;\n      CRC32 myCRC = new CRC32( ) ;\n      myCRC.update( toBeEncoded.getBytes( ) ) ;\n      System.out.println( \"The CRC-32 value is\u00a0: \" + Long.toHexString( myCRC.getValue( ) ) + \"\u00a0!\" ) ;\n   }\n}\n"}
{"id": 92046, "name": "CRC-32", "source": "Translate Ruby to Python: require 'zlib'\nprintf \"0x%08x\\n\", Zlib.crc32('The quick brown fox jumps over the lazy dog')\n\n", "target": ">>> s = 'The quick brown fox jumps over the lazy dog'\n>>> import zlib\n>>> hex(zlib.crc32(s))\n'0x414fa339'\n\n>>> import binascii\n>>> hex(binascii.crc32(s))\n'0x414fa339'\n"}
{"id": 92203, "name": "Determine if only one instance is running", "source": "Translate Ruby to C#: def main\n  puts \"first instance\"\n  sleep 20\n  puts :done\nend\n\nif $0 == __FILE__\n  if File.new(__FILE__).flock(File::LOCK_EX | File::LOCK_NB)\n    main\n  else\n    raise \"another instance of this program is running\"\n  end\nend\n\n__END__\n", "target": "using System;\nusing System.Net;\nusing System.Net.Sockets;\n\nclass Program {        \n    static void Main(string[] args) {        \n        try {\n            TcpListener server = new TcpListener(IPAddress.Any, 12345);\n            server.Start();\n        } \n       \n        catch (SocketException e) {\n            if (e.SocketErrorCode == SocketError.AddressAlreadyInUse) {\n                Console.Error.WriteLine(\"Already running.\");\n            }\n        }\n    }\n}\n"}
{"id": 92205, "name": "Determine if only one instance is running", "source": "Translate Ruby to Java: def main\n  puts \"first instance\"\n  sleep 20\n  puts :done\nend\n\nif $0 == __FILE__\n  if File.new(__FILE__).flock(File::LOCK_EX | File::LOCK_NB)\n    main\n  else\n    raise \"another instance of this program is running\"\n  end\nend\n\n__END__\n", "target": "import java.io.IOException;\nimport java.net.InetAddress;\nimport java.net.ServerSocket;\nimport java.net.UnknownHostException;\n \npublic class SingletonApp\n{\n    private static final int PORT = 65000;  \n    private static ServerSocket s;\n\n    \n    static {\n        try {\n            s = new ServerSocket(PORT, 10, InetAddress.getLocalHost());\n        } catch (UnknownHostException e) {\n            \n        } catch (IOException e) {\n            \n            System.out.print(\"Application is already running,\");\n            System.out.println(\" so terminating this instance.\");\n            System.exit(0);\n        }\n    }\n\n    public static void main(String[] args) {\n        System.out.print(\"OK, only this instance is running\");\n        System.out.println(\" but will terminate in 10 seconds.\");\n        try {\n            Thread.sleep(10000);\n            if (s != null && !s.isClosed()) s.close();\n        } catch (Exception e) {\n            System.err.println(e);\n        }\n    }\n}\n"}
{"id": 92206, "name": "Determine if only one instance is running", "source": "Translate Ruby to Python: def main\n  puts \"first instance\"\n  sleep 20\n  puts :done\nend\n\nif $0 == __FILE__\n  if File.new(__FILE__).flock(File::LOCK_EX | File::LOCK_NB)\n    main\n  else\n    raise \"another instance of this program is running\"\n  end\nend\n\n__END__\n", "target": "import __main__, os\n\ndef isOnlyInstance():\n    \n    \n    return os.system(\"(( $(ps -ef | grep python | grep '[\" +\n                     __main__.__file__[0] + \"]\" + __main__.__file__[1:] +\n                     \"' | wc -l) > 1 ))\") != 0\n"}
{"id": 92572, "name": "Van der Corput sequence", "source": "Translate Ruby to C#: def vdc(n, base=2)\n  str = n.to_s(base).reverse\n  str.to_i(base).quo(base ** str.length)\nend\n\n(2..5).each do |base|\n  puts \"Base \nend\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\nnamespace VanDerCorput\n{\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    public class VanDerCorputSequence: IEnumerable<Tuple<long,long>>\n    {\n        \n        \n        \n        public int Base { get; private set; }\n\n        \n        \n        \n        public long Count { get; private set; }\n\n        \n        \n        \n        \n        \n        public VanDerCorputSequence(int iBase, long count = long.MaxValue) {\n            if (iBase < 2)\n                throw new ArgumentOutOfRangeException(\"iBase\", \"must be two or greater, not the given value of \" + iBase);\n            Base = iBase;\n            Count = count;\n        }\n\n        \n        \n        \n        \n        \n        \n        public Tuple<long,long> Compute(long n)\n        {\n            long p = 0, q = 1;\n            long numerator, denominator;\n            while (n != 0)\n            {\n                p = p * Base + (n % Base);\n                q *= Base;\n                n /= Base;\n            }\n            numerator = p;\n            denominator = q;\n            while (p != 0) \n            { \n                n = p; \n                p = q % p; \n                q = n; \n            }\n            numerator /= q;\n            denominator /= q;\n            return new Tuple<long,long>(numerator, denominator);\n        }\n\n        \n        \n        \n        \n        \n        \n        public static Tuple<long, long> Compute(int iBase, long n)\n        {\n            var seq = new VanDerCorputSequence(iBase);\n            return seq.Compute(n);\n        }\n\n        \n        \n        \n        \n        \n        public IEnumerator<Tuple<long, long>> GetEnumerator()\n        {\n            long iSequenceIndex = 0L;\n            while (iSequenceIndex < Count)\n            {\n                yield return Compute(iSequenceIndex);\n                iSequenceIndex++;\n            }\n        }\n\n        System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()\n        {\n            return GetEnumerator();\n        }\n    }\n\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            TestBasesTwoThroughFive();\n\n            Console.WriteLine(\"Type return to continue...\");\n            Console.ReadLine();\n        }\n\n        static void TestBasesTwoThroughFive()\n        {\n            foreach (var seq in Enumerable.Range(2, 5).Select(x => new VanDerCorputSequence(x, 10))) \n            {\n                Console.Write(\"base \" + seq.Base + \":\");\n                foreach(var vc in seq) \n                    Console.Write(\" \" + vc.Item1 + \"/\" + vc.Item2);\n                Console.WriteLine();\n            }\n        }\n    }\n}\n"}
{"id": 92573, "name": "Van der Corput sequence", "source": "Translate Ruby to C#: def vdc(n, base=2)\n  str = n.to_s(base).reverse\n  str.to_i(base).quo(base ** str.length)\nend\n\n(2..5).each do |base|\n  puts \"Base \nend\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\nnamespace VanDerCorput\n{\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    public class VanDerCorputSequence: IEnumerable<Tuple<long,long>>\n    {\n        \n        \n        \n        public int Base { get; private set; }\n\n        \n        \n        \n        public long Count { get; private set; }\n\n        \n        \n        \n        \n        \n        public VanDerCorputSequence(int iBase, long count = long.MaxValue) {\n            if (iBase < 2)\n                throw new ArgumentOutOfRangeException(\"iBase\", \"must be two or greater, not the given value of \" + iBase);\n            Base = iBase;\n            Count = count;\n        }\n\n        \n        \n        \n        \n        \n        \n        public Tuple<long,long> Compute(long n)\n        {\n            long p = 0, q = 1;\n            long numerator, denominator;\n            while (n != 0)\n            {\n                p = p * Base + (n % Base);\n                q *= Base;\n                n /= Base;\n            }\n            numerator = p;\n            denominator = q;\n            while (p != 0) \n            { \n                n = p; \n                p = q % p; \n                q = n; \n            }\n            numerator /= q;\n            denominator /= q;\n            return new Tuple<long,long>(numerator, denominator);\n        }\n\n        \n        \n        \n        \n        \n        \n        public static Tuple<long, long> Compute(int iBase, long n)\n        {\n            var seq = new VanDerCorputSequence(iBase);\n            return seq.Compute(n);\n        }\n\n        \n        \n        \n        \n        \n        public IEnumerator<Tuple<long, long>> GetEnumerator()\n        {\n            long iSequenceIndex = 0L;\n            while (iSequenceIndex < Count)\n            {\n                yield return Compute(iSequenceIndex);\n                iSequenceIndex++;\n            }\n        }\n\n        System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()\n        {\n            return GetEnumerator();\n        }\n    }\n\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            TestBasesTwoThroughFive();\n\n            Console.WriteLine(\"Type return to continue...\");\n            Console.ReadLine();\n        }\n\n        static void TestBasesTwoThroughFive()\n        {\n            foreach (var seq in Enumerable.Range(2, 5).Select(x => new VanDerCorputSequence(x, 10))) \n            {\n                Console.Write(\"base \" + seq.Base + \":\");\n                foreach(var vc in seq) \n                    Console.Write(\" \" + vc.Item1 + \"/\" + vc.Item2);\n                Console.WriteLine();\n            }\n        }\n    }\n}\n"}
{"id": 92576, "name": "Van der Corput sequence", "source": "Translate Ruby to Java: def vdc(n, base=2)\n  str = n.to_s(base).reverse\n  str.to_i(base).quo(base ** str.length)\nend\n\n(2..5).each do |base|\n  puts \"Base \nend\n", "target": "public class VanDerCorput{\n\tpublic static double vdc(int n){\n\t\tdouble vdc = 0;\n\t\tint denom = 1;\n\t\twhile(n != 0){\n\t\t\tvdc += n % 2.0 / (denom *= 2);\n\t\t\tn /= 2;\n\t\t}\n\t\treturn vdc;\n\t}\n\t\n\tpublic static void main(String[] args){\n\t\tfor(int i = 0; i <= 10; i++){\n\t\t\tSystem.out.println(vdc(i));\n\t\t}\n\t}\n}\n"}
{"id": 92577, "name": "Van der Corput sequence", "source": "Translate Ruby to Java: def vdc(n, base=2)\n  str = n.to_s(base).reverse\n  str.to_i(base).quo(base ** str.length)\nend\n\n(2..5).each do |base|\n  puts \"Base \nend\n", "target": "public class VanDerCorput{\n\tpublic static double vdc(int n){\n\t\tdouble vdc = 0;\n\t\tint denom = 1;\n\t\twhile(n != 0){\n\t\t\tvdc += n % 2.0 / (denom *= 2);\n\t\t\tn /= 2;\n\t\t}\n\t\treturn vdc;\n\t}\n\t\n\tpublic static void main(String[] args){\n\t\tfor(int i = 0; i <= 10; i++){\n\t\t\tSystem.out.println(vdc(i));\n\t\t}\n\t}\n}\n"}
{"id": 92578, "name": "Van der Corput sequence", "source": "Translate Ruby to Python: def vdc(n, base=2)\n  str = n.to_s(base).reverse\n  str.to_i(base).quo(base ** str.length)\nend\n\n(2..5).each do |base|\n  puts \"Base \nend\n", "target": ">>> def base10change(n, base):\n\tdigits = []\n\twhile n:\n\t\tn,remainder = divmod(n, base)\n\t\tdigits.insert(0, remainder)\n\treturn digits\n\n>>> base10change(11, 2)\n[1, 0, 1, 1]\n"}
{"id": 92579, "name": "Van der Corput sequence", "source": "Translate Ruby to Python: def vdc(n, base=2)\n  str = n.to_s(base).reverse\n  str.to_i(base).quo(base ** str.length)\nend\n\n(2..5).each do |base|\n  puts \"Base \nend\n", "target": ">>> def base10change(n, base):\n\tdigits = []\n\twhile n:\n\t\tn,remainder = divmod(n, base)\n\t\tdigits.insert(0, remainder)\n\treturn digits\n\n>>> base10change(11, 2)\n[1, 0, 1, 1]\n"}
{"id": 92858, "name": "Loops_Nested", "source": "Translate Ruby to C#: ary = (1..20).to_a.shuffle.each_slice(4).to_a\np ary\n\ncatch :found_it do\n  for row in ary\n    for element in row\n      print \"%2d \" % element\n      throw :found_it if element == 20\n    end\n    puts \",\"\n  end\nend\n\nputs \"done\"\n", "target": "using System;\n\nclass Program {\n    static void Main(string[] args) {\n        int[,] a = new int[10, 10];\n        Random r = new Random();\n\n        for (int i = 0; i < 10; i++) {\n            for (int j = 0; j < 10; j++) {\n                a[i, j] = r.Next(0, 21) + 1;\n            }\n        }\n        \n        for (int i = 0; i < 10; i++) {\n            for (int j = 0; j < 10; j++) {\n                Console.Write(\" {0}\", a[i, j]);\n                if (a[i, j] == 20) {\n                    goto Done;\n                }\n            }\n            Console.WriteLine();\n        }\n    Done:\n        Console.WriteLine();\n    }\n}\n"}
{"id": 92860, "name": "Loops_Nested", "source": "Translate Ruby to Python: ary = (1..20).to_a.shuffle.each_slice(4).to_a\np ary\n\ncatch :found_it do\n  for row in ary\n    for element in row\n      print \"%2d \" % element\n      throw :found_it if element == 20\n    end\n    puts \",\"\n  end\nend\n\nputs \"done\"\n", "target": "from random import randint\n\ndef do_scan(mat):\n    for row in mat:\n        for item in row:\n            print item,\n            if item == 20:\n                print\n                return\n        print\n    print\n\nmat = [[randint(1, 20) for x in xrange(10)] for y in xrange(10)]\ndo_scan(mat)\n"}
{"id": 93127, "name": "File input_output", "source": "Translate Ruby to C#: str = File.open('input.txt', 'rb') {|f| f.read}\nFile.open('output.txt', 'wb') {|f| f.write str}\n", "target": "using System;\nusing System.IO;\n\nnamespace FileIO\n{\n  class Program\n  {\n    static void Main()\n    {\n      String s = scope .();\n      File.ReadAllText(\"input.txt\", s);\n      File.WriteAllText(\"output.txt\", s);\n    }\n  }\n}\n"}
{"id": 93129, "name": "File input_output", "source": "Translate Ruby to Java: str = File.open('input.txt', 'rb') {|f| f.read}\nFile.open('output.txt', 'wb') {|f| f.write str}\n", "target": "import java.io.*;\n\npublic class FileIODemo {\n  public static void main(String[] args) {\n    try {\n      FileInputStream in = new FileInputStream(\"input.txt\");\n      FileOutputStream out = new FileOutputStream(\"ouput.txt\");\n      int c;\n      while ((c = in.read()) != -1) {\n        out.write(c);\n      }\n    } catch (FileNotFoundException e) {\n      e.printStackTrace();\n    } catch (IOException e){\n      e.printStackTrace();\n    }\n  }\n}\n"}
{"id": 93130, "name": "File input_output", "source": "Translate Ruby to Python: str = File.open('input.txt', 'rb') {|f| f.read}\nFile.open('output.txt', 'wb') {|f| f.write str}\n", "target": "import shutil\nshutil.copyfile('input.txt', 'output.txt')\n"}
{"id": 93338, "name": "Sorting algorithms_Heapsort", "source": "Translate Ruby to C#: class Array\n  def heapsort\n    self.dup.heapsort!\n  end\n\n  def heapsort!\n    \n    ((length - 2) / 2).downto(0) {|start| siftdown(start, length - 1)}\n\n    \n    (length - 1).downto(1) do |end_|\n      self[end_], self[0] = self[0], self[end_]\n      siftdown(0, end_ - 1)\n    end\n    self\n  end\n\n  def siftdown(start, end_)\n    root = start\n    loop do\n      child = root * 2 + 1\n      break if child > end_\n      if child + 1 <= end_ and self[child] < self[child + 1]\n        child += 1\n      end\n      if self[root] < self[child]\n        self[root], self[child] = self[child], self[root]\n        root = child\n      else\n        break\n      end\n    end\n  end\nend\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Text;\n\npublic class HeapSortClass\n{\n    public static void HeapSort<T>(T[] array)\n    {\n        HeapSort<T>(array, 0, array.Length, Comparer<T>.Default);\n    }\n\n    public static void HeapSort<T>(T[] array, int offset, int length, IComparer<T> comparer)\n    {\n        HeapSort<T>(array, offset, length, comparer.Compare);\n    }\n\n    public static void HeapSort<T>(T[] array, int offset, int length, Comparison<T> comparison)\n    {\n        \n        for (int i = 0; i < length; i++)\n        {\n            int index = i;\n            T item = array[offset + i]; \n\n            \n            while (index > 0 &&\n                comparison(array[offset + (index - 1) / 2], item) < 0)\n            {\n                int top = (index - 1) / 2;\n                array[offset + index] = array[offset + top];\n                index = top;\n            }\n            array[offset + index] = item;\n        }\n\n        for (int i = length - 1; i > 0; i--)\n        {\n            \n            T last = array[offset + i];\n            array[offset + i] = array[offset];\n\n            int index = 0;\n            \n            while (index * 2 + 1 < i)\n            {\n                int left = index * 2 + 1, right = left + 1;\n\n                if (right < i && comparison(array[offset + left], array[offset + right]) < 0)\n                {\n                    if (comparison(last, array[offset + right]) > 0) break;\n\n                    array[offset + index] = array[offset + right];\n                    index = right;\n                }\n                else\n                {\n                    if (comparison(last, array[offset + left]) > 0) break;\n\n                    array[offset + index] = array[offset + left];\n                    index = left;\n                }\n            }\n            array[offset + index] = last;\n        }\n    }\n\n    static void Main()\n    {\n        \n        byte[] r = {5, 4, 1, 2};\n        HeapSort(r);\n\n        string[] s = { \"-\", \"D\", \"a\", \"33\" };\n        HeapSort(s, 0, s.Length, StringComparer.CurrentCultureIgnoreCase);\n    }\n}\n"}
{"id": 93340, "name": "Sorting algorithms_Heapsort", "source": "Translate Ruby to Java: class Array\n  def heapsort\n    self.dup.heapsort!\n  end\n\n  def heapsort!\n    \n    ((length - 2) / 2).downto(0) {|start| siftdown(start, length - 1)}\n\n    \n    (length - 1).downto(1) do |end_|\n      self[end_], self[0] = self[0], self[end_]\n      siftdown(0, end_ - 1)\n    end\n    self\n  end\n\n  def siftdown(start, end_)\n    root = start\n    loop do\n      child = root * 2 + 1\n      break if child > end_\n      if child + 1 <= end_ and self[child] < self[child + 1]\n        child += 1\n      end\n      if self[root] < self[child]\n        self[root], self[child] = self[child], self[root]\n        root = child\n      else\n        break\n      end\n    end\n  end\nend\n", "target": "public static void heapSort(int[] a){\n\tint count = a.length;\n\n\t\n\theapify(a, count);\n\n\tint end = count - 1;\n\twhile(end > 0){\n\t\t\n\t\t\n\t\tint tmp = a[end];\n\t\ta[end] = a[0];\n\t\ta[0] = tmp;\n\t\t\n\t\tsiftDown(a, 0, end - 1);\n\t\t\n\t\t\n\t\tend--;\n\t}\n}\n\npublic static void heapify(int[] a, int count){\n\t\n\tint start = (count - 2) / 2; \n\n\twhile(start >= 0){\n\t\t\n\t\t\n\t\t\n\t\tsiftDown(a, start, count - 1);\n\t\tstart--;\n\t}\n\t\n}\n\npublic static void siftDown(int[] a, int start, int end){\n\t\n\tint root = start;\n\n\twhile((root * 2 + 1) <= end){      \n\t\tint child = root * 2 + 1;           \n\t\t\n\t\tif(child + 1 <= end && a[child] < a[child + 1])\n\t\t\tchild = child + 1;           \n\t\tif(a[root] < a[child]){     \n\t\t\tint tmp = a[root];\n\t\t\ta[root] = a[child];\n\t\t\ta[child] = tmp;\n\t\t\troot = child;                \n\t\t}else\n\t\t\treturn;\n\t}\n}\n"}
{"id": 93341, "name": "Sorting algorithms_Heapsort", "source": "Translate Ruby to Python: class Array\n  def heapsort\n    self.dup.heapsort!\n  end\n\n  def heapsort!\n    \n    ((length - 2) / 2).downto(0) {|start| siftdown(start, length - 1)}\n\n    \n    (length - 1).downto(1) do |end_|\n      self[end_], self[0] = self[0], self[end_]\n      siftdown(0, end_ - 1)\n    end\n    self\n  end\n\n  def siftdown(start, end_)\n    root = start\n    loop do\n      child = root * 2 + 1\n      break if child > end_\n      if child + 1 <= end_ and self[child] < self[child + 1]\n        child += 1\n      end\n      if self[root] < self[child]\n        self[root], self[child] = self[child], self[root]\n        root = child\n      else\n        break\n      end\n    end\n  end\nend\n", "target": "def heapsort(lst):\n  \n\n  \n  for start in range((len(lst)-2)/2, -1, -1):\n    siftdown(lst, start, len(lst)-1)\n\n  for end in range(len(lst)-1, 0, -1):\n    lst[end], lst[0] = lst[0], lst[end]\n    siftdown(lst, 0, end - 1)\n  return lst\n\ndef siftdown(lst, start, end):\n  root = start\n  while True:\n    child = root * 2 + 1\n    if child > end: break\n    if child + 1 <= end and lst[child] < lst[child + 1]:\n      child += 1\n    if lst[root] < lst[child]:\n      lst[root], lst[child] = lst[child], lst[root]\n      root = child\n    else:\n      break\n"}
{"id": 93631, "name": "Nim game", "source": "Translate Ruby to C#: tokens = 12\n\nuntil tokens <= 0\n    puts \"There are \n    until (input = (gets || \"\").to_i?) && (1..3).includes? input\n        puts \"Enter an integer between 1 and 3.\"\n    end\n    puts \"Player takes \n    tokens -= 4\nend\n\nputs \"Computer wins.\"\n", "target": "using System;\n\nnamespace nimGame\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            Console.WriteLine(\"There are twelve tokens.\\n\" +\n                    \"You can take 1, 2, or 3 on your turn.\\n\" +\n                    \"Whoever takes the last token wins.\\n\");\n\n            int tokens = 12;\n\n            while (tokens > 0)\n            {\n                Console.WriteLine(\"There are \" + tokens + \" remaining.\");\n                Console.WriteLine(\"How many do you take?\");\n                int playertake = Convert.ToInt32(Console.ReadLine());\n\n                if (playertake < 1 | playertake > 3)\n                {\n                    Console.WriteLine(\"1, 2, or 3 only.\");\n                }\n                else\n                {\n                    tokens -= playertake;\n                    Console.WriteLine(\"I take \" + (4 - playertake) + \".\");\n                    tokens -= (4 - playertake);\n                }\n            }\n            Console.WriteLine(\"I win again.\");\n            Console.ReadLine();\n        }\n\n    }\n}\n"}
{"id": 93632, "name": "Nim game", "source": "Translate Ruby to C#: tokens = 12\n\nuntil tokens <= 0\n    puts \"There are \n    until (input = (gets || \"\").to_i?) && (1..3).includes? input\n        puts \"Enter an integer between 1 and 3.\"\n    end\n    puts \"Player takes \n    tokens -= 4\nend\n\nputs \"Computer wins.\"\n", "target": "using System;\n\nnamespace nimGame\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            Console.WriteLine(\"There are twelve tokens.\\n\" +\n                    \"You can take 1, 2, or 3 on your turn.\\n\" +\n                    \"Whoever takes the last token wins.\\n\");\n\n            int tokens = 12;\n\n            while (tokens > 0)\n            {\n                Console.WriteLine(\"There are \" + tokens + \" remaining.\");\n                Console.WriteLine(\"How many do you take?\");\n                int playertake = Convert.ToInt32(Console.ReadLine());\n\n                if (playertake < 1 | playertake > 3)\n                {\n                    Console.WriteLine(\"1, 2, or 3 only.\");\n                }\n                else\n                {\n                    tokens -= playertake;\n                    Console.WriteLine(\"I take \" + (4 - playertake) + \".\");\n                    tokens -= (4 - playertake);\n                }\n            }\n            Console.WriteLine(\"I win again.\");\n            Console.ReadLine();\n        }\n\n    }\n}\n"}
{"id": 93635, "name": "Nim game", "source": "Translate Ruby to Java: tokens = 12\n\nuntil tokens <= 0\n    puts \"There are \n    until (input = (gets || \"\").to_i?) && (1..3).includes? input\n        puts \"Enter an integer between 1 and 3.\"\n    end\n    puts \"Player takes \n    tokens -= 4\nend\n\nputs \"Computer wins.\"\n", "target": "import java.util.Scanner;\n\npublic class NimGame {\n\n    public static void main(String[] args) {\n        runGame(12);\n    }\n    \n    private static void runGame(int tokens) {\n        System.out.printf(\"Nim game.%n%n\");\n\n        Scanner in = new Scanner(System.in);;\n        \n        do {            \n            boolean humanInputOk = false;\n            int humanTokens = 0;\n            while ( ! humanInputOk ) {\n                System.out.printf(\"Human takes how many tokens?  \");\n                String input = in.next();\n                try {\n                    humanTokens = Integer.parseInt(input);\n                    if ( humanTokens >= 1 && humanTokens <= 3 ) {\n                        humanInputOk = true;\n                    }\n                    else {\n                        System.out.printf(\"Try a number between 1 and 3.%n\");\n                    }\n                }\n                catch (NumberFormatException e) {\n                    System.out.printf(\"Invalid input.  Try a number between 1 and 3.%n\");\n                }\n            }\n            \n            tokens -= humanTokens;\n            \n            System.out.printf(\"You take %d token%s.%n%d token%s remaining.%n%n\", humanTokens, humanTokens > 1 ? \"s\" : \"\", tokens, tokens != 1 ? \"s\" : \"\");\n            if ( tokens == 0 ) {\n                System.out.printf(\"You win!!.%n%n\");\n                break;\n            }\n            int computerTokens = 4 - humanTokens;\n            tokens -= computerTokens;\n            \n            System.out.printf(\"Computer takes %d token%s.%n%d token%s remaining.%n%n\", computerTokens, computerTokens != 1 ? \"s\" : \"\", tokens, tokens != 1 ? \"s\" : \"\");\n            if ( tokens == 0 ) {\n                System.out.printf(\"Computer wins!!.%n%n\");\n            }\n\n        } while (tokens > 0);\n\n        in.close();\n    }\n\n}\n"}
{"id": 93636, "name": "Nim game", "source": "Translate Ruby to Java: tokens = 12\n\nuntil tokens <= 0\n    puts \"There are \n    until (input = (gets || \"\").to_i?) && (1..3).includes? input\n        puts \"Enter an integer between 1 and 3.\"\n    end\n    puts \"Player takes \n    tokens -= 4\nend\n\nputs \"Computer wins.\"\n", "target": "import java.util.Scanner;\n\npublic class NimGame {\n\n    public static void main(String[] args) {\n        runGame(12);\n    }\n    \n    private static void runGame(int tokens) {\n        System.out.printf(\"Nim game.%n%n\");\n\n        Scanner in = new Scanner(System.in);;\n        \n        do {            \n            boolean humanInputOk = false;\n            int humanTokens = 0;\n            while ( ! humanInputOk ) {\n                System.out.printf(\"Human takes how many tokens?  \");\n                String input = in.next();\n                try {\n                    humanTokens = Integer.parseInt(input);\n                    if ( humanTokens >= 1 && humanTokens <= 3 ) {\n                        humanInputOk = true;\n                    }\n                    else {\n                        System.out.printf(\"Try a number between 1 and 3.%n\");\n                    }\n                }\n                catch (NumberFormatException e) {\n                    System.out.printf(\"Invalid input.  Try a number between 1 and 3.%n\");\n                }\n            }\n            \n            tokens -= humanTokens;\n            \n            System.out.printf(\"You take %d token%s.%n%d token%s remaining.%n%n\", humanTokens, humanTokens > 1 ? \"s\" : \"\", tokens, tokens != 1 ? \"s\" : \"\");\n            if ( tokens == 0 ) {\n                System.out.printf(\"You win!!.%n%n\");\n                break;\n            }\n            int computerTokens = 4 - humanTokens;\n            tokens -= computerTokens;\n            \n            System.out.printf(\"Computer takes %d token%s.%n%d token%s remaining.%n%n\", computerTokens, computerTokens != 1 ? \"s\" : \"\", tokens, tokens != 1 ? \"s\" : \"\");\n            if ( tokens == 0 ) {\n                System.out.printf(\"Computer wins!!.%n%n\");\n            }\n\n        } while (tokens > 0);\n\n        in.close();\n    }\n\n}\n"}
{"id": 93637, "name": "Nim game", "source": "Translate Ruby to Python: tokens = 12\n\nuntil tokens <= 0\n    puts \"There are \n    until (input = (gets || \"\").to_i?) && (1..3).includes? input\n        puts \"Enter an integer between 1 and 3.\"\n    end\n    puts \"Player takes \n    tokens -= 4\nend\n\nputs \"Computer wins.\"\n", "target": "print(\"Py Nim\\n\")\n\ndef getTokens(curTokens):\n\tglobal tokens\n\t\n\tprint(\"How many tokens would you like to take? \", end='')\n\ttake = int(input())\n\t\n\tif (take < 1 or take > 3):\n\t\tprint(\"Number must be between 1 and 3.\\n\")\n\t\tgetTokens(curTokens)\n\t\treturn\n\t\n\ttokens = curTokens - take\n\tprint(f'You take {take} tokens.')\n\tprint(f'{tokens} tokens remaining.\\n')\n\ndef compTurn(curTokens):\n\tglobal tokens\n\t\n\ttake = curTokens % 4\n\ttokens = curTokens - take\n\tprint (f'Computer takes {take} tokens.')\n\tprint (f'{tokens} tokens remaining.\\n')\n\t\n\ntokens = 12\nwhile (tokens > 0):\n\tgetTokens(tokens)\n\tcompTurn(tokens)\n\nprint(\"Computer wins!\")\n"}
{"id": 93638, "name": "Nim game", "source": "Translate Ruby to Python: tokens = 12\n\nuntil tokens <= 0\n    puts \"There are \n    until (input = (gets || \"\").to_i?) && (1..3).includes? input\n        puts \"Enter an integer between 1 and 3.\"\n    end\n    puts \"Player takes \n    tokens -= 4\nend\n\nputs \"Computer wins.\"\n", "target": "print(\"Py Nim\\n\")\n\ndef getTokens(curTokens):\n\tglobal tokens\n\t\n\tprint(\"How many tokens would you like to take? \", end='')\n\ttake = int(input())\n\t\n\tif (take < 1 or take > 3):\n\t\tprint(\"Number must be between 1 and 3.\\n\")\n\t\tgetTokens(curTokens)\n\t\treturn\n\t\n\ttokens = curTokens - take\n\tprint(f'You take {take} tokens.')\n\tprint(f'{tokens} tokens remaining.\\n')\n\ndef compTurn(curTokens):\n\tglobal tokens\n\t\n\ttake = curTokens % 4\n\ttokens = curTokens - take\n\tprint (f'Computer takes {take} tokens.')\n\tprint (f'{tokens} tokens remaining.\\n')\n\t\n\ntokens = 12\nwhile (tokens > 0):\n\tgetTokens(tokens)\n\tcompTurn(tokens)\n\nprint(\"Computer wins!\")\n"}
{"id": 93838, "name": "XML_Output", "source": "Translate Ruby to C#: require 'rexml/document'\ninclude REXML\n\nremarks = {\n  %q(April)         => %q(Bubbly: I'm > Tam and <= Emily),\n  %q(Tam O'Shanter) => %q(Burns: \"When chapman billies leave the street ...\"),\n  %q(Emily)         => %q(Short & shrift),\n}\n\ndoc = Document.new\nroot = doc.add_element(\"CharacterRemarks\")\n\nremarks.each do |name, remark|\n  root.add_element(\"Character\", {'Name' => name}).add_text(remark)\nend\n\n\ndoc.write($stdout, 2)\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Xml.Linq;\n\nclass Program\n{\n    static string CreateXML(Dictionary<string, string> characterRemarks)\n    {\n        var remarks = characterRemarks.Select(r => new XElement(\"Character\", r.Value, new XAttribute(\"Name\", r.Key)));\n        var xml = new XElement(\"CharacterRemarks\", remarks);\n        return xml.ToString();\n    }\n\n    static void Main(string[] args)\n    {\n        var characterRemarks = new Dictionary<string, string>\n        {\n            { \"April\", \"Bubbly: I'm > Tam and <= Emily\" },\n            { \"Tam O'Shanter\", \"Burns: \\\"When chapman billies leave the street ...\\\"\" },\n            { \"Emily\", \"Short & shrift\" }\n        };\n\n        string xml = CreateXML(characterRemarks);\n        Console.WriteLine(xml);\n    }\n}\n"}
{"id": 93840, "name": "XML_Output", "source": "Translate Ruby to Java: require 'rexml/document'\ninclude REXML\n\nremarks = {\n  %q(April)         => %q(Bubbly: I'm > Tam and <= Emily),\n  %q(Tam O'Shanter) => %q(Burns: \"When chapman billies leave the street ...\"),\n  %q(Emily)         => %q(Short & shrift),\n}\n\ndoc = Document.new\nroot = doc.add_element(\"CharacterRemarks\")\n\nremarks.each do |name, remark|\n  root.add_element(\"Character\", {'Name' => name}).add_text(remark)\nend\n\n\ndoc.write($stdout, 2)\n", "target": "import java.io.StringWriter;\n\nimport javax.xml.parsers.DocumentBuilderFactory;\nimport javax.xml.transform.Result;\nimport javax.xml.transform.Source;\nimport javax.xml.transform.Transformer;\nimport javax.xml.transform.TransformerFactory;\nimport javax.xml.transform.dom.DOMSource;\nimport javax.xml.transform.stream.StreamResult;\n\nimport org.w3c.dom.Document;\nimport org.w3c.dom.Element;\n\npublic class XmlCreation {\n\n  private static final String[] names = {\"April\", \"Tam O'Shanter\", \"Emily\"};\n  private static final String[] remarks = {\"Bubbly: I'm > Tam and <= Emily\",\n    \"Burns: \\\"When chapman billies leave the street ...\\\"\",\n      \"Short & shrift\"};\n  \n  public static void main(String[] args) {\n    try {\n      \n      final Document doc = DocumentBuilderFactory.newInstance().newDocumentBuilder().newDocument();\n      \n      \n      final Element root = doc.createElement(\"CharacterRemarks\");\n      doc.appendChild(root);\n      \n      \n      for(int i = 0; i < names.length; i++) {\n        final Element character = doc.createElement(\"Character\");\n        root.appendChild(character);\n        character.setAttribute(\"name\", names[i]);\n        character.appendChild(doc.createTextNode(remarks[i]));\n      }\n      \n      \n      \n      final Source source = new DOMSource(doc);\n      \n      \n      final StringWriter buffer = new StringWriter();\n      \n      \n      final Result result = new StreamResult(buffer);\n      \n      \n      final Transformer transformer = TransformerFactory.newInstance().newTransformer();\n      transformer.setOutputProperty(\"indent\", \"yes\");\n      transformer.transform(source, result);\n      \n      \n      \n      System.out.println(buffer.toString());\n    } catch (Exception e) {\n      e.printStackTrace();\n    }\n  }\n  \n}\n"}
{"id": 93841, "name": "XML_Output", "source": "Translate Ruby to Python: require 'rexml/document'\ninclude REXML\n\nremarks = {\n  %q(April)         => %q(Bubbly: I'm > Tam and <= Emily),\n  %q(Tam O'Shanter) => %q(Burns: \"When chapman billies leave the street ...\"),\n  %q(Emily)         => %q(Short & shrift),\n}\n\ndoc = Document.new\nroot = doc.add_element(\"CharacterRemarks\")\n\nremarks.each do |name, remark|\n  root.add_element(\"Character\", {'Name' => name}).add_text(remark)\nend\n\n\ndoc.write($stdout, 2)\n", "target": ">>> from xml.etree import ElementTree as ET\n>>> from itertools import izip\n>>> def characterstoxml(names, remarks):\n\troot = ET.Element(\"CharacterRemarks\")\n\tfor name, remark in izip(names, remarks):\n\t\tc = ET.SubElement(root, \"Character\", {'name': name})\n\t\tc.text = remark\n\treturn ET.tostring(root)\n\n>>> print characterstoxml(\n\tnames = [\"April\", \"Tam O'Shanter\", \"Emily\"],\n\tremarks = [ \"Bubbly: I'm > Tam and <= Emily\",\n\t\t    'Burns: \"When chapman billies leave the street ...\"',\n\t\t    'Short & shrift' ] ).replace('><','>\\n<')\n"}
{"id": 94082, "name": "Sum and product of an array", "source": "Translate Ruby to C#: def sum_product(a)\n    { a.sum(), a.product() }\nend\n", "target": "int sum = 0, prod = 1;\nint[] arg = { 1, 2, 3, 4, 5 };\nforeach (int value in arg) {\n  sum += value;\n  prod *= value;\n}\n"}
{"id": 94084, "name": "Sum and product of an array", "source": "Translate Ruby to Java: def sum_product(a)\n    { a.sum(), a.product() }\nend\n", "target": "public class SumProd\n{\n public static void main(final String[] args)\n {\n  int sum = 0;\n  int prod = 1;\n  int[] arg = {1,2,3,4,5};\n  for (int i : arg)\n  {\n   sum += i;\n   prod *= i;\n  }\n }\n}\n"}
{"id": 94085, "name": "Sum and product of an array", "source": "Translate Ruby to Python: def sum_product(a)\n    { a.sum(), a.product() }\nend\n", "target": "numbers = [1, 2, 3]\ntotal = sum(numbers)\n\nproduct = 1\nfor i in numbers:\n    product *= i\n"}
{"id": 94600, "name": "100 doors", "source": "Translate Ruby to C#: doors = Array.new(100, false)\n\n1.upto(100) do |i|\n  i.step(by: i, to: 100) do |j|\n    doors[j - 1] = !doors[j - 1]\n  end\nend\n\ndoors.each_with_index do |open, i|\n  puts \"Door \nend\n", "target": "namespace ConsoleApplication1\n{\n    using System;\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            bool[] doors = new bool[100];\n\n            \n            for (int d = 0; d < 100; d++) doors[d] = false;\n\n            \n            for (int p = 0; p < 100; p++)\n            {\n                \n                for (int d = 0; d < 100; d++)\n                {\n                    if ((d + 1) % (p + 1) == 0)\n                    {\n                        doors[d] = !doors[d];\n                    }\n                }\n            }\n\n            \n            Console.WriteLine(\"Passes Completed!!!  Here are the results: \\r\\n\");\n            for (int d = 0; d < 100; d++)\n            {\n                if (doors[d])\n                {\n                    Console.WriteLine(String.Format(\"Door #{0}: Open\", d + 1));\n                }\n                else\n                {\n                    Console.WriteLine(String.Format(\"Door #{0}: Closed\", d + 1));\n                }\n            }\n            Console.ReadKey(true);\n        }\n    }\n}\n"}
{"id": 94601, "name": "100 doors", "source": "Translate Ruby to C#: doors = Array.new(100, false)\n\n1.upto(100) do |i|\n  i.step(by: i, to: 100) do |j|\n    doors[j - 1] = !doors[j - 1]\n  end\nend\n\ndoors.each_with_index do |open, i|\n  puts \"Door \nend\n", "target": "namespace ConsoleApplication1\n{\n    using System;\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            bool[] doors = new bool[100];\n\n            \n            for (int d = 0; d < 100; d++) doors[d] = false;\n\n            \n            for (int p = 0; p < 100; p++)\n            {\n                \n                for (int d = 0; d < 100; d++)\n                {\n                    if ((d + 1) % (p + 1) == 0)\n                    {\n                        doors[d] = !doors[d];\n                    }\n                }\n            }\n\n            \n            Console.WriteLine(\"Passes Completed!!!  Here are the results: \\r\\n\");\n            for (int d = 0; d < 100; d++)\n            {\n                if (doors[d])\n                {\n                    Console.WriteLine(String.Format(\"Door #{0}: Open\", d + 1));\n                }\n                else\n                {\n                    Console.WriteLine(String.Format(\"Door #{0}: Closed\", d + 1));\n                }\n            }\n            Console.ReadKey(true);\n        }\n    }\n}\n"}
{"id": 94604, "name": "100 doors", "source": "Translate Ruby to Java: doors = Array.new(100, false)\n\n1.upto(100) do |i|\n  i.step(by: i, to: 100) do |j|\n    doors[j - 1] = !doors[j - 1]\n  end\nend\n\ndoors.each_with_index do |open, i|\n  puts \"Door \nend\n", "target": "module OneHundredDoors\n    {\n    @Inject Console console;\n\n    void run()\n        {\n        Boolean[] doors = new Boolean[100];\n        for (Int pass : 0 ..< 100)\n            {\n            for (Int door = pass; door < 100; door += 1+pass)\n                {\n                doors[door] = !doors[door];\n                }\n            }\n\n        console.print($\"open doors: {doors.mapIndexed((d, i) -> d\u00a0? i+1\u00a0: 0).filter(i -> i > 0)}\");\n        }\n    }\n"}
{"id": 94605, "name": "100 doors", "source": "Translate Ruby to Java: doors = Array.new(100, false)\n\n1.upto(100) do |i|\n  i.step(by: i, to: 100) do |j|\n    doors[j - 1] = !doors[j - 1]\n  end\nend\n\ndoors.each_with_index do |open, i|\n  puts \"Door \nend\n", "target": "module OneHundredDoors\n    {\n    @Inject Console console;\n\n    void run()\n        {\n        Boolean[] doors = new Boolean[100];\n        for (Int pass : 0 ..< 100)\n            {\n            for (Int door = pass; door < 100; door += 1+pass)\n                {\n                doors[door] = !doors[door];\n                }\n            }\n\n        console.print($\"open doors: {doors.mapIndexed((d, i) -> d\u00a0? i+1\u00a0: 0).filter(i -> i > 0)}\");\n        }\n    }\n"}
{"id": 94606, "name": "100 doors", "source": "Translate Ruby to Python: doors = Array.new(100, false)\n\n1.upto(100) do |i|\n  i.step(by: i, to: 100) do |j|\n    doors[j - 1] = !doors[j - 1]\n  end\nend\n\ndoors.each_with_index do |open, i|\n  puts \"Door \nend\n", "target": "var doors = falses(100)\n\nfor a in 1..100: for b in a..a..100:\n    doors[b] = not doors[b]\n\nfor a in 1..100:\n    print \"Door $a is ${(doors[a])\u00a0? 'open.': 'closed.'}\"\n"}
{"id": 94607, "name": "100 doors", "source": "Translate Ruby to Python: doors = Array.new(100, false)\n\n1.upto(100) do |i|\n  i.step(by: i, to: 100) do |j|\n    doors[j - 1] = !doors[j - 1]\n  end\nend\n\ndoors.each_with_index do |open, i|\n  puts \"Door \nend\n", "target": "var doors = falses(100)\n\nfor a in 1..100: for b in a..a..100:\n    doors[b] = not doors[b]\n\nfor a in 1..100:\n    print \"Door $a is ${(doors[a])\u00a0? 'open.': 'closed.'}\"\n"}
{"id": 95075, "name": "Anti-primes", "source": "Translate Ruby to C#: def count_divisors(n : Int64) : Int64\n  return 1_i64 if n < 2\n  count = 2_i64\n\n  i = 2\n  while i <= n // 2\n    count += 1 if n % i == 0\n    i += 1\n  end\n\n  count\nend\n\nmax_div = 0_i64\ncount = 0_i64\n\nprint \"The first 20 anti-primes are: \"\n\nn = 1_i64\nwhile count < 20\n  d = count_divisors n\n\n  if d > max_div\n    print \"\n    max_div = d\n    count += 1\n  end\n\n  n += 1\nend\n\nputs \"\"\n", "target": "using System;\nusing System.Linq;\nusing System.Collections.Generic;\n\t\t\t\t\t\npublic static class Program\n{\n    public static void Main() =>\n        Console.WriteLine(string.Join(\" \", FindAntiPrimes().Take(20)));\n\t\n    static IEnumerable<int> FindAntiPrimes() {\n        int max = 0;\n        for (int i = 1; ; i++) {\n            int divisors = CountDivisors(i);\n            if (divisors > max) {\n                max = divisors;\n                yield return i;\n            }\n        }\n\t\n        int CountDivisors(int n) => Enumerable.Range(1, n / 2).Count(i => n % i == 0) + 1;\n    }\n}\n"}
{"id": 95076, "name": "Anti-primes", "source": "Translate Ruby to C#: def count_divisors(n : Int64) : Int64\n  return 1_i64 if n < 2\n  count = 2_i64\n\n  i = 2\n  while i <= n // 2\n    count += 1 if n % i == 0\n    i += 1\n  end\n\n  count\nend\n\nmax_div = 0_i64\ncount = 0_i64\n\nprint \"The first 20 anti-primes are: \"\n\nn = 1_i64\nwhile count < 20\n  d = count_divisors n\n\n  if d > max_div\n    print \"\n    max_div = d\n    count += 1\n  end\n\n  n += 1\nend\n\nputs \"\"\n", "target": "using System;\nusing System.Linq;\nusing System.Collections.Generic;\n\t\t\t\t\t\npublic static class Program\n{\n    public static void Main() =>\n        Console.WriteLine(string.Join(\" \", FindAntiPrimes().Take(20)));\n\t\n    static IEnumerable<int> FindAntiPrimes() {\n        int max = 0;\n        for (int i = 1; ; i++) {\n            int divisors = CountDivisors(i);\n            if (divisors > max) {\n                max = divisors;\n                yield return i;\n            }\n        }\n\t\n        int CountDivisors(int n) => Enumerable.Range(1, n / 2).Count(i => n % i == 0) + 1;\n    }\n}\n"}
{"id": 95079, "name": "Anti-primes", "source": "Translate Ruby to Java: def count_divisors(n : Int64) : Int64\n  return 1_i64 if n < 2\n  count = 2_i64\n\n  i = 2\n  while i <= n // 2\n    count += 1 if n % i == 0\n    i += 1\n  end\n\n  count\nend\n\nmax_div = 0_i64\ncount = 0_i64\n\nprint \"The first 20 anti-primes are: \"\n\nn = 1_i64\nwhile count < 20\n  d = count_divisors n\n\n  if d > max_div\n    print \"\n    max_div = d\n    count += 1\n  end\n\n  n += 1\nend\n\nputs \"\"\n", "target": "public class Antiprime {\n\n    static int countDivisors(int n) {\n        if (n < 2) return 1;\n        int count = 2; \n        for (int i = 2; i <= n/2; ++i) {\n            if (n%i == 0) ++count;\n        }\n        return count;\n    }\n\n    public static void main(String[] args) {\n        int maxDiv = 0, count = 0;\n        System.out.println(\"The first 20 anti-primes are:\");\n        for (int n = 1; count < 20; ++n) {\n            int d = countDivisors(n);\n            if (d > maxDiv) {\n                System.out.printf(\"%d \", n);\n                maxDiv = d;\n                count++;\n            }\n        }\n        System.out.println();\n    }\n}\n"}
{"id": 95080, "name": "Anti-primes", "source": "Translate Ruby to Python: def count_divisors(n : Int64) : Int64\n  return 1_i64 if n < 2\n  count = 2_i64\n\n  i = 2\n  while i <= n // 2\n    count += 1 if n % i == 0\n    i += 1\n  end\n\n  count\nend\n\nmax_div = 0_i64\ncount = 0_i64\n\nprint \"The first 20 anti-primes are: \"\n\nn = 1_i64\nwhile count < 20\n  d = count_divisors n\n\n  if d > max_div\n    print \"\n    max_div = d\n    count += 1\n  end\n\n  n += 1\nend\n\nputs \"\"\n", "target": "from itertools import chain, count, cycle, islice, accumulate\n \ndef factors(n):\n    def prime_powers(n):\n        for c in accumulate(chain([2, 1, 2], cycle([2,4]))):\n            if c*c > n: break\n            if n%c: continue\n            d,p = (), c\n            while not n%c:\n                n,p,d = n//c, p*c, d+(p,)\n            yield d\n        if n > 1: yield n,\n \n    r = [1]\n    for e in prime_powers(n):\n        r += [a*b for a in r for b in e]\n    return r\n    \ndef antiprimes():\n    mx = 0\n    yield 1\n    for c in count(2,2):\n        if c >= 58: break\n        ln = len(factors(c))\n        if ln > mx:\n            yield c\n            mx = ln\n    for c in count(60,30):\n        ln = len(factors(c))\n        if ln > mx:\n            yield c\n            mx = ln  \n\nif __name__ == '__main__':\n    print(*islice(antiprimes(), 40)))\n"}
{"id": 95081, "name": "Anti-primes", "source": "Translate Ruby to Python: def count_divisors(n : Int64) : Int64\n  return 1_i64 if n < 2\n  count = 2_i64\n\n  i = 2\n  while i <= n // 2\n    count += 1 if n % i == 0\n    i += 1\n  end\n\n  count\nend\n\nmax_div = 0_i64\ncount = 0_i64\n\nprint \"The first 20 anti-primes are: \"\n\nn = 1_i64\nwhile count < 20\n  d = count_divisors n\n\n  if d > max_div\n    print \"\n    max_div = d\n    count += 1\n  end\n\n  n += 1\nend\n\nputs \"\"\n", "target": "from itertools import chain, count, cycle, islice, accumulate\n \ndef factors(n):\n    def prime_powers(n):\n        for c in accumulate(chain([2, 1, 2], cycle([2,4]))):\n            if c*c > n: break\n            if n%c: continue\n            d,p = (), c\n            while not n%c:\n                n,p,d = n//c, p*c, d+(p,)\n            yield d\n        if n > 1: yield n,\n \n    r = [1]\n    for e in prime_powers(n):\n        r += [a*b for a in r for b in e]\n    return r\n    \ndef antiprimes():\n    mx = 0\n    yield 1\n    for c in count(2,2):\n        if c >= 58: break\n        ln = len(factors(c))\n        if ln > mx:\n            yield c\n            mx = ln\n    for c in count(60,30):\n        ln = len(factors(c))\n        if ln > mx:\n            yield c\n            mx = ln  \n\nif __name__ == '__main__':\n    print(*islice(antiprimes(), 40)))\n"}
{"id": 95303, "name": "Bitmap_Bresenham's line algorithm", "source": "Translate Ruby to C#: Pixel = Struct.new(:x, :y)\n\nclass Pixmap\n  \n  def draw_line(p1, p2, colour)\n    validate_pixel(p1.x, p2.y)\n    validate_pixel(p2.x, p2.y)\n\n    x1, y1 = p1.x, p1.y\n    x2, y2 = p2.x, p2.y\n \n    steep = (y2 - y1).abs > (x2 - x1).abs\n    \n    if steep\n      x1, y1 = y1, x1\n      x2, y2 = y2, x2\n    end\n    \n    if x1 > x2\n      x1, x2 = x2, x1\n      y1, y2 = y2, y1\n    end\n\n    deltax = x2 - x1\n    deltay = (y2 - y1).abs\n    error = deltax / 2\n    ystep = y1 < y2 ? 1 : -1\n \n    y = y1\n    x1.upto(x2) do |x|\n      pixel = steep ? [y,x] : [x,y]\n      self[*pixel] = colour\n      error -= deltay\n      if error < 0\n        y += ystep\n        error += deltax\n      end\n    end\n  end\nend\n\nbitmap = Pixmap.new(500, 500)\nbitmap.fill(RGBColour::BLUE)\n10.step(430, 60) do |a|\n  bitmap.draw_line(Pixel[10, 10], Pixel[490,a], RGBColour::YELLOW)\n  bitmap.draw_line(Pixel[10, 10], Pixel[a,490], RGBColour::YELLOW)\nend\nbitmap.draw_line(Pixel[10, 10], Pixel[490,490], RGBColour::YELLOW)\n", "target": "using System;\nusing System.Drawing;\nusing System.Drawing.Imaging;\nstatic class Program\n{\n    static void Main()\n    {\n        new Bitmap(200, 200)\n            .DrawLine(0, 0, 199, 199, Color.Black).DrawLine(199,0,0,199,Color.Black)\n            .DrawLine(50, 75, 150, 125, Color.Blue).DrawLine(150, 75, 50, 125, Color.Blue)\n            .Save(\"line.png\", ImageFormat.Png);\n    }\n    static Bitmap DrawLine(this Bitmap bitmap, int x0, int y0, int x1, int y1, Color color)\n    {\n        int dx = Math.Abs(x1 - x0), sx = x0 < x1 ? 1 : -1;\n        int dy = Math.Abs(y1 - y0), sy = y0 < y1 ? 1 : -1;\n        int err = (dx > dy ? dx : -dy) / 2, e2;\n        for(;;) {\n            bitmap.SetPixel(x0, y0, color);\n            if (x0 == x1 && y0 == y1) break;\n            e2 = err;\n            if (e2 > -dx) { err -= dy; x0 += sx; }\n            if (e2 < dy) { err += dx; y0 += sy; }\n        }\n        return bitmap;\n    }\n}\n"}
{"id": 95305, "name": "Bitmap_Bresenham's line algorithm", "source": "Translate Ruby to Java: Pixel = Struct.new(:x, :y)\n\nclass Pixmap\n  \n  def draw_line(p1, p2, colour)\n    validate_pixel(p1.x, p2.y)\n    validate_pixel(p2.x, p2.y)\n\n    x1, y1 = p1.x, p1.y\n    x2, y2 = p2.x, p2.y\n \n    steep = (y2 - y1).abs > (x2 - x1).abs\n    \n    if steep\n      x1, y1 = y1, x1\n      x2, y2 = y2, x2\n    end\n    \n    if x1 > x2\n      x1, x2 = x2, x1\n      y1, y2 = y2, y1\n    end\n\n    deltax = x2 - x1\n    deltay = (y2 - y1).abs\n    error = deltax / 2\n    ystep = y1 < y2 ? 1 : -1\n \n    y = y1\n    x1.upto(x2) do |x|\n      pixel = steep ? [y,x] : [x,y]\n      self[*pixel] = colour\n      error -= deltay\n      if error < 0\n        y += ystep\n        error += deltax\n      end\n    end\n  end\nend\n\nbitmap = Pixmap.new(500, 500)\nbitmap.fill(RGBColour::BLUE)\n10.step(430, 60) do |a|\n  bitmap.draw_line(Pixel[10, 10], Pixel[490,a], RGBColour::YELLOW)\n  bitmap.draw_line(Pixel[10, 10], Pixel[a,490], RGBColour::YELLOW)\nend\nbitmap.draw_line(Pixel[10, 10], Pixel[490,490], RGBColour::YELLOW)\n", "target": "import java.awt.Color;\nimport java.awt.Dimension;\nimport java.awt.Graphics;\nimport javax.swing.JFrame;\nimport javax.swing.JPanel;\nimport javax.swing.SwingUtilities;\nimport javax.swing.WindowConstants;\n\npublic class Bresenham {\n\n    public static void main(String[] args) {\n        SwingUtilities.invokeLater(Bresenham::run);\n    }\n\n    private static void run() {\n        JFrame f = new JFrame();\n        f.setDefaultCloseOperation(WindowConstants.DISPOSE_ON_CLOSE);\n        f.setTitle(\"Bresenham\");\n\n        f.getContentPane().add(new BresenhamPanel());\n        f.pack();\n\n        f.setLocationRelativeTo(null);\n        f.setVisible(true);\n    }\n}\n\nclass BresenhamPanel extends JPanel {\n\n    private final int pixelSize = 10;\n\n    BresenhamPanel() {\n        setPreferredSize(new Dimension(600, 500));\n        setBackground(Color.WHITE);\n    }\n\n    @Override\n    public void paintComponent(Graphics g) {\n        super.paintComponent(g);\n\n        int w = (getWidth() - 1) / pixelSize;\n        int h = (getHeight() - 1) / pixelSize;\n        int maxX = (w - 1) / 2;\n        int maxY = (h - 1) / 2;\n        int x1 = -maxX, x2 = maxX * -2 / 3, x3 = maxX * 2 / 3, x4 = maxX;\n        int y1 = -maxY, y2 = maxY * -2 / 3, y3 = maxY * 2 / 3, y4 = maxY;\n\n        drawLine(g, 0, 0, x3, y1); \n        drawLine(g, 0, 0, x4, y2); \n        drawLine(g, 0, 0, x4, y3); \n        drawLine(g, 0, 0, x3, y4); \n        drawLine(g, 0, 0, x2, y4); \n        drawLine(g, 0, 0, x1, y3); \n        drawLine(g, 0, 0, x1, y2); \n        drawLine(g, 0, 0, x2, y1); \n    }\n\n    private void plot(Graphics g, int x, int y) {\n        int w = (getWidth() - 1) / pixelSize;\n        int h = (getHeight() - 1) / pixelSize;\n        int maxX = (w - 1) / 2;\n        int maxY = (h - 1) / 2;\n\n        int borderX = getWidth() - ((2 * maxX + 1) * pixelSize + 1);\n        int borderY = getHeight() - ((2 * maxY + 1) * pixelSize + 1);\n        int left = (x + maxX) * pixelSize + borderX / 2;\n        int top = (y + maxY) * pixelSize + borderY / 2;\n\n        g.setColor(Color.black);\n        g.drawOval(left, top, pixelSize, pixelSize);\n    }\n\n    private void drawLine(Graphics g, int x1, int y1, int x2, int y2) {\n        \n        int d = 0;\n\n        int dx = Math.abs(x2 - x1);\n        int dy = Math.abs(y2 - y1);\n\n        int dx2 = 2 * dx; \n        int dy2 = 2 * dy; \n\n        int ix = x1 < x2 ? 1 : -1; \n        int iy = y1 < y2 ? 1 : -1;\n\n        int x = x1;\n        int y = y1;\n\n        if (dx >= dy) {\n            while (true) {\n                plot(g, x, y);\n                if (x == x2)\n                    break;\n                x += ix;\n                d += dy2;\n                if (d > dx) {\n                    y += iy;\n                    d -= dx2;\n                }\n            }\n        } else {\n            while (true) {\n                plot(g, x, y);\n                if (y == y2)\n                    break;\n                y += iy;\n                d += dx2;\n                if (d > dy) {\n                    x += ix;\n                    d -= dy2;\n                }\n            }\n        }\n    }\n}\n"}
{"id": 95306, "name": "Bitmap_Bresenham's line algorithm", "source": "Translate Ruby to Python: Pixel = Struct.new(:x, :y)\n\nclass Pixmap\n  \n  def draw_line(p1, p2, colour)\n    validate_pixel(p1.x, p2.y)\n    validate_pixel(p2.x, p2.y)\n\n    x1, y1 = p1.x, p1.y\n    x2, y2 = p2.x, p2.y\n \n    steep = (y2 - y1).abs > (x2 - x1).abs\n    \n    if steep\n      x1, y1 = y1, x1\n      x2, y2 = y2, x2\n    end\n    \n    if x1 > x2\n      x1, x2 = x2, x1\n      y1, y2 = y2, y1\n    end\n\n    deltax = x2 - x1\n    deltay = (y2 - y1).abs\n    error = deltax / 2\n    ystep = y1 < y2 ? 1 : -1\n \n    y = y1\n    x1.upto(x2) do |x|\n      pixel = steep ? [y,x] : [x,y]\n      self[*pixel] = colour\n      error -= deltay\n      if error < 0\n        y += ystep\n        error += deltax\n      end\n    end\n  end\nend\n\nbitmap = Pixmap.new(500, 500)\nbitmap.fill(RGBColour::BLUE)\n10.step(430, 60) do |a|\n  bitmap.draw_line(Pixel[10, 10], Pixel[490,a], RGBColour::YELLOW)\n  bitmap.draw_line(Pixel[10, 10], Pixel[a,490], RGBColour::YELLOW)\nend\nbitmap.draw_line(Pixel[10, 10], Pixel[490,490], RGBColour::YELLOW)\n", "target": "def line(self, x0, y0, x1, y1):\n    \"Bresenham's line algorithm\"\n    dx = abs(x1 - x0)\n    dy = abs(y1 - y0)\n    x, y = x0, y0\n    sx = -1 if x0 > x1 else 1\n    sy = -1 if y0 > y1 else 1\n    if dx > dy:\n        err = dx / 2.0\n        while x != x1:\n            self.set(x, y)\n            err -= dy\n            if err < 0:\n                y += sy\n                err += dx\n            x += sx\n    else:\n        err = dy / 2.0\n        while y != y1:\n            self.set(x, y)\n            err -= dx\n            if err < 0:\n                x += sx\n                err += dy\n            y += sy        \n    self.set(x, y)\nBitmap.line = line\n\nbitmap = Bitmap(17,17)\nfor points in ((1,8,8,16),(8,16,16,8),(16,8,8,1),(8,1,1,8)):\n    bitmap.line(*points)\nbitmap.chardisplay()\n\n\n"}
{"id": 95457, "name": "Hello world_Web server", "source": "Translate Ruby to C#: require 'webrick'\nserver = WEBrick::HTTPServer.new(:Port => 8080)\nserver.mount_proc('/') {|request, response| response.body = \"Goodbye, World!\"}\ntrap(\"INT\") {server.shutdown}\nserver.start\n", "target": "using System.Text;\nusing System.Net.Sockets;\nusing System.Net;\n\nnamespace WebServer\n{\n    class GoodByeWorld\n    {        \n        static void Main(string[] args)\n        {\n            const string msg = \"<html>\\n<body>\\nGoodbye, world!\\n</body>\\n</html>\\n\";        \n            const int port = 8080;\n            bool serverRunning = true;\n\n            TcpListener tcpListener = new TcpListener(IPAddress.Any, port);\n            tcpListener.Start();\n\n            while (serverRunning)\n            {\n                Socket socketConnection = tcpListener.AcceptSocket();\n                byte[] bMsg = Encoding.ASCII.GetBytes(msg.ToCharArray(), 0, (int)msg.Length);\n                socketConnection.Send(bMsg);\n                socketConnection.Disconnect(true);\n            }\n        }\n    }\n}\n"}
{"id": 95458, "name": "Hello world_Web server", "source": "Translate Ruby to Java: require 'webrick'\nserver = WEBrick::HTTPServer.new(:Port => 8080)\nserver.mount_proc('/') {|request, response| response.body = \"Goodbye, World!\"}\ntrap(\"INT\") {server.shutdown}\nserver.start\n", "target": "import java.io.IOException;\nimport java.io.PrintWriter;\nimport java.net.ServerSocket;\nimport java.net.Socket;\n\npublic class HelloWorld{\n  public static void main(String[] args) throws IOException{\n    ServerSocket listener = new ServerSocket(8080);\n    while(true){\n      Socket sock = listener.accept();\n      new PrintWriter(sock.getOutputStream(), true).\n                println(\"Goodbye, World!\");\n      sock.close();\n    }\n  }\n}\n"}
{"id": 95459, "name": "Hello world_Web server", "source": "Translate Ruby to Python: require 'webrick'\nserver = WEBrick::HTTPServer.new(:Port => 8080)\nserver.mount_proc('/') {|request, response| response.body = \"Goodbye, World!\"}\ntrap(\"INT\") {server.shutdown}\nserver.start\n", "target": "from wsgiref.simple_server import make_server\n\ndef app(environ, start_response):\n    start_response('200 OK', [('Content-Type','text/html')])\n    yield b\"<h1>Goodbye, World!</h1>\"\n\nserver = make_server('127.0.0.1', 8080, app)\nserver.serve_forever()\n"}
{"id": 95709, "name": "Knuth shuffle", "source": "Translate Ruby to C#: class Array\n  def knuth_shuffle!\n    j = length\n    i = 0\n    while j > 1\n      r = i + rand(j)\n      self[i], self[r] = self[r], self[i]\n      i += 1\n      j -= 1\n    end\n    self\n  end\nend\n\nr = Hash.new(0)\n100_000.times do |i|\n  a = [1,2,3].knuth_shuffle!\n  r[a] += 1\nend\n\nr.keys.sort.each {|a| puts \"\n", "target": "public static void KnuthShuffle<T>(T[] array)\n{\n    System.Random random = new System.Random();\n    for (int i = 0; i < array.Length; i++)\n    {\n        int j = random.Next(i, array.Length); \n        T temp = array[i]; array[i] = array[j]; array[j] = temp;\n    }\n}\n"}
{"id": 95711, "name": "Knuth shuffle", "source": "Translate Ruby to Java: class Array\n  def knuth_shuffle!\n    j = length\n    i = 0\n    while j > 1\n      r = i + rand(j)\n      self[i], self[r] = self[r], self[i]\n      i += 1\n      j -= 1\n    end\n    self\n  end\nend\n\nr = Hash.new(0)\n100_000.times do |i|\n  a = [1,2,3].knuth_shuffle!\n  r[a] += 1\nend\n\nr.keys.sort.each {|a| puts \"\n", "target": "import java.util.Random;\n\npublic static final Random gen = new Random();\n\n\npublic static void shuffle (int[] array) {\n    int n = array.length;\n    while (n > 1) {\n        int k = gen.nextInt(n--); \n        int temp = array[n];\n        array[n] = array[k];\n        array[k] = temp;\n    }\n}\n\npublic static void shuffle (Object[] array) {\n    int n = array.length;\n    while (n > 1) {\n        int k = gen.nextInt(n--); \n        Object temp = array[n];\n        array[n] = array[k];\n        array[k] = temp;\n    }\n}\n"}
{"id": 95712, "name": "Knuth shuffle", "source": "Translate Ruby to Python: class Array\n  def knuth_shuffle!\n    j = length\n    i = 0\n    while j > 1\n      r = i + rand(j)\n      self[i], self[r] = self[r], self[i]\n      i += 1\n      j -= 1\n    end\n    self\n  end\nend\n\nr = Hash.new(0)\n100_000.times do |i|\n  a = [1,2,3].knuth_shuffle!\n  r[a] += 1\nend\n\nr.keys.sort.each {|a| puts \"\n", "target": "from random import randrange\n\ndef knuth_shuffle(x):\n    for i in range(len(x)-1, 0, -1):\n        j = randrange(i + 1)\n        x[i], x[j] = x[j], x[i]\n\nx = list(range(10))\nknuth_shuffle(x)\nprint(\"shuffled:\", x)\n"}
{"id": 95902, "name": "Synchronous concurrency", "source": "Translate Ruby to C#: File.write(\"input.txt\", \"a\\nb\\nc\")\n \nlines = Channel(String).new\n \nspawn do\n  File.each_line(\"input.txt\") do |line|\n    lines.send(line)\n  end\n  lines.close\nend\n \nwhile line = lines.receive?\n  puts line\nend\n\nFile.delete(\"input.txt\")\n", "target": "using System;\nusing System.Threading.Tasks;\nusing System.Collections.Concurrent;\nusing System.IO;\n\nnamespace SynchronousConcurrency\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            BlockingCollection<string> toWriterTask = new BlockingCollection<string>();\n            BlockingCollection<int> fromWriterTask = new BlockingCollection<int>();\n            Task writer = Task.Factory.StartNew(() => ConsoleWriter(toWriterTask, fromWriterTask));\n            Task reader = Task.Factory.StartNew(() => FileReader(fromWriterTask, toWriterTask));\n            Task.WaitAll(writer, reader);\n        }\n        static void ConsoleWriter(BlockingCollection<string> input, BlockingCollection<int> output)\n        {\n            int nLines = 0;\n            string line;\n            while ((line = input.Take()) != null)\n            {\n                Console.WriteLine(line);\n                ++nLines;\n            }\n            output.Add(nLines);\n        }\n        static void FileReader(BlockingCollection<int> input, BlockingCollection<string> output)\n        {\n            StreamReader file = new StreamReader(\"input.txt\"); \n            string line;\n            while ((line = file.ReadLine()) != null)\n            {\n                output.Add(line);\n\n            }\n            output.Add(null); \n            Console.WriteLine(\"line count: \" + input.Take());\n        }\n    }\n}\n"}
{"id": 95904, "name": "Synchronous concurrency", "source": "Translate Ruby to Java: File.write(\"input.txt\", \"a\\nb\\nc\")\n \nlines = Channel(String).new\n \nspawn do\n  File.each_line(\"input.txt\") do |line|\n    lines.send(line)\n  end\n  lines.close\nend\n \nwhile line = lines.receive?\n  puts line\nend\n\nFile.delete(\"input.txt\")\n", "target": "import java.io.BufferedReader;\nimport java.io.FileReader;\nimport java.util.concurrent.atomic.AtomicBoolean;\nimport java.util.concurrent.atomic.AtomicLong;\nimport java.util.concurrent.BlockingQueue;\nimport java.util.concurrent.LinkedBlockingQueue;\n\nclass SynchronousConcurrency\n{\n  public static void main(String[] args) throws Exception\n  {\n    final AtomicLong lineCount = new AtomicLong(0);\n    final BlockingQueue<String> queue = new LinkedBlockingQueue<String>();\n    final String EOF = new String();\n    \n    final Thread writerThread = new Thread(new Runnable() {\n        public void run()\n        {\n          long linesWrote = 0;\n          while (true)\n          {\n            try\n            {\n              String line = queue.take();\n              \n              if (line == EOF)\n                break;\n              System.out.println(line);\n              linesWrote++;\n            }\n            catch (InterruptedException ie)\n            {  }\n          }\n          lineCount.set(linesWrote);\n        }\n      }\n    );\n    writerThread.start();\n    \n    \n    BufferedReader br = new BufferedReader(new FileReader(\"input.txt\"));\n    String line;\n    while ((line = br.readLine()) != null)\n      queue.put(line);\n    br.close();\n    queue.put(EOF);\n    writerThread.join();\n    \n    System.out.println(\"Line count: \" + lineCount.get());\n    return;\n  }\n}\n"}
{"id": 95905, "name": "Synchronous concurrency", "source": "Translate Ruby to Python: File.write(\"input.txt\", \"a\\nb\\nc\")\n \nlines = Channel(String).new\n \nspawn do\n  File.each_line(\"input.txt\") do |line|\n    lines.send(line)\n  end\n  lines.close\nend\n \nwhile line = lines.receive?\n  puts line\nend\n\nFile.delete(\"input.txt\")\n", "target": "import sys\nfrom Queue import Queue\nfrom threading import Thread\n\nlines = Queue(1)\ncount = Queue(1)\n\ndef read(file):\n    try:\n        for line in file:\n            lines.put(line)\n    finally:\n        lines.put(None)\n    print count.get()\n\ndef write(file):\n    n = 0\n    while 1:\n        line = lines.get()\n        if line is None:\n            break\n        file.write(line)\n        n += 1\n    count.put(n)\n\nreader = Thread(target=read, args=(open('input.txt'),))\nwriter = Thread(target=write, args=(sys.stdout,))\nreader.start()\nwriter.start()\nreader.join()\nwriter.join()\n"}
{"id": 96076, "name": "Knapsack problem_Continuous", "source": "Translate Ruby to C#: items = [ [:beef   , 3.8, 36],\n          [:pork   , 5.4, 43],\n          [:ham    , 3.6, 90],\n          [:greaves, 2.4, 45],\n          [:flitch , 4.0, 30],\n          [:brawn  , 2.5, 56],\n          [:welt   , 3.7, 67],\n          [:salami , 3.0, 95],\n          [:sausage, 5.9, 98] ].sort_by{|item, weight, price| -price / weight}\nmaxW, value = 15.0, 0\nitems.each do |item, weight, price|\n  if (maxW -= weight) > 0\n    puts \"Take all \n    value += price\n  else\n    puts \"Take %gkg of %s\" % [t=weight+maxW, item], \"\",\n         \"Total value of swag is %g\" % (value+(price/weight)*t)\n    break\n  end\nend\n", "target": "using System;  \nclass Program\n{\n    static void Main()\n    {\n        Console.WriteLine(knapSack(15) + \"\\n\");\n        var sw = System.Diagnostics.Stopwatch.StartNew();\n        for (int i = 1000; i > 0; i--) knapSack(15);\n        Console.Write(sw.Elapsed); Console.Read();    \n    }\n\n    static string knapSack(double w1)\n    {\n        int k = w.Length; var q = new double[k];\n        for (int i = 0; i < k; ) q[i] = v[i] / w[i++];\n        var c = new double[k];\n        Array.Copy(q, c, k); Array.Sort(c, w);\n        Array.Copy(q, c, k); Array.Sort(c, v);\n        Array.Sort(q, items);\n        string str = \"\";\n        for (k--; k >= 0; k--)\n            if (w1 - w[k] > 0) { w1 -= w[k]; str += items[k] + \"\\n\"; }\n            else break;\n        return w1 > 0 && k >= 0 ? str + items[k] : str;\n    }\n\n    static double[] w = { 3.8, 5.4, 3.6, 2.4, 4.0, 2.5, 3.7, 3.0, 5.9 },\n\n                    v = { 36, 43, 90, 45, 30, 56, 67, 95, 98 };\n\n    static string[] items = {\"beef\",\"pork\",\"ham\",\"greaves\",\"flitch\",\n                             \"brawn\",\"welt\",\"salami\",\"sausage\"};\n}\n"}
{"id": 96078, "name": "Knapsack problem_Continuous", "source": "Translate Ruby to Python: items = [ [:beef   , 3.8, 36],\n          [:pork   , 5.4, 43],\n          [:ham    , 3.6, 90],\n          [:greaves, 2.4, 45],\n          [:flitch , 4.0, 30],\n          [:brawn  , 2.5, 56],\n          [:welt   , 3.7, 67],\n          [:salami , 3.0, 95],\n          [:sausage, 5.9, 98] ].sort_by{|item, weight, price| -price / weight}\nmaxW, value = 15.0, 0\nitems.each do |item, weight, price|\n  if (maxW -= weight) > 0\n    puts \"Take all \n    value += price\n  else\n    puts \"Take %gkg of %s\" % [t=weight+maxW, item], \"\",\n         \"Total value of swag is %g\" % (value+(price/weight)*t)\n    break\n  end\nend\n", "target": "\nitems = [(\"beef\",    3.8, 36.0),\n         (\"pork\",    5.4, 43.0),\n         (\"ham\",     3.6, 90.0),\n         (\"greaves\", 2.4, 45.0),\n         (\"flitch\",  4.0, 30.0),\n         (\"brawn\",   2.5, 56.0),\n         (\"welt\",    3.7, 67.0),\n         (\"salami\",  3.0, 95.0),\n         (\"sausage\", 5.9, 98.0)]\n\nMAXWT = 15.0\n\nsorted_items = sorted(((value/amount, amount, name)\n                       for name, amount, value in items),\n                      reverse = True)\nwt = val = 0\nbagged = []\nfor unit_value, amount, name in sorted_items:\n    portion = min(MAXWT - wt, amount)\n    wt     += portion\n    addval  = portion * unit_value\n    val    += addval\n    bagged += [(name, portion, addval)]\n    if wt >= MAXWT:\n        break\n\nprint(\"    ITEM   PORTION VALUE\")\nprint(\"\\n\".join(\"%10s %6.2f %6.2f\" % item for item in bagged))\nprint(\"\\nTOTAL WEIGHT: %5.2f\\nTOTAL VALUE: %5.2f\" % (wt, val))\n"}
{"id": 96473, "name": "Map range", "source": "Translate Ruby to C#: def map_range(a, b, s)\n  af, al, bf, bl = a.first, a.last, b.first, b.last\n  bf + (s - af)*(bl - bf).quo(al - af)\nend\n\n(0..10).each{|s| puts \"%s maps to %g\" % [s, map_range(0..10, -1..0, s)]}\n", "target": "using System;\nusing System.Linq;\n\npublic class MapRange\n{\n    public static void Main() {\n        foreach (int i in Enumerable.Range(0, 11))\n            Console.WriteLine($\"{i} maps to {Map(0, 10, -1, 0, i)}\");\n    }\n    \n    static double Map(double a1, double a2, double b1, double b2, double s) => b1 + (s - a1) * (b2 - b1) / (a2 - a1);\n}\n"}
{"id": 96474, "name": "Map range", "source": "Translate Ruby to C#: def map_range(a, b, s)\n  af, al, bf, bl = a.first, a.last, b.first, b.last\n  bf + (s - af)*(bl - bf).quo(al - af)\nend\n\n(0..10).each{|s| puts \"%s maps to %g\" % [s, map_range(0..10, -1..0, s)]}\n", "target": "using System;\nusing System.Linq;\n\npublic class MapRange\n{\n    public static void Main() {\n        foreach (int i in Enumerable.Range(0, 11))\n            Console.WriteLine($\"{i} maps to {Map(0, 10, -1, 0, i)}\");\n    }\n    \n    static double Map(double a1, double a2, double b1, double b2, double s) => b1 + (s - a1) * (b2 - b1) / (a2 - a1);\n}\n"}
{"id": 96477, "name": "Map range", "source": "Translate Ruby to Java: def map_range(a, b, s)\n  af, al, bf, bl = a.first, a.last, b.first, b.last\n  bf + (s - af)*(bl - bf).quo(al - af)\nend\n\n(0..10).each{|s| puts \"%s maps to %g\" % [s, map_range(0..10, -1..0, s)]}\n", "target": "public class Range {\n\tpublic static void main(String[] args){\n\t\tfor(float s = 0;s <= 10; s++){\n\t\t\tSystem.out.println(s + \" in [0, 10] maps to \"+ \n\t\t\t\t\tmapRange(0, 10, -1, 0, s)+\" in [-1, 0].\");\n\t\t}\n\t}\n\t\n\tpublic static double mapRange(double a1, double a2, double b1, double b2, double s){\n\t\treturn b1 + ((s - a1)*(b2 - b1))/(a2 - a1);\n\t}\n}\n"}
{"id": 96478, "name": "Map range", "source": "Translate Ruby to Java: def map_range(a, b, s)\n  af, al, bf, bl = a.first, a.last, b.first, b.last\n  bf + (s - af)*(bl - bf).quo(al - af)\nend\n\n(0..10).each{|s| puts \"%s maps to %g\" % [s, map_range(0..10, -1..0, s)]}\n", "target": "public class Range {\n\tpublic static void main(String[] args){\n\t\tfor(float s = 0;s <= 10; s++){\n\t\t\tSystem.out.println(s + \" in [0, 10] maps to \"+ \n\t\t\t\t\tmapRange(0, 10, -1, 0, s)+\" in [-1, 0].\");\n\t\t}\n\t}\n\t\n\tpublic static double mapRange(double a1, double a2, double b1, double b2, double s){\n\t\treturn b1 + ((s - a1)*(b2 - b1))/(a2 - a1);\n\t}\n}\n"}
{"id": 96479, "name": "Map range", "source": "Translate Ruby to Python: def map_range(a, b, s)\n  af, al, bf, bl = a.first, a.last, b.first, b.last\n  bf + (s - af)*(bl - bf).quo(al - af)\nend\n\n(0..10).each{|s| puts \"%s maps to %g\" % [s, map_range(0..10, -1..0, s)]}\n", "target": ">>> def maprange( a, b, s):\n\t(a1, a2), (b1, b2) = a, b\n\treturn  b1 + ((s - a1) * (b2 - b1) / (a2 - a1))\n\n>>> for s in range(11):\n\tprint(\"%2g maps to %g\" % (s, maprange( (0, 10), (-1, 0), s)))\n\n\t\n 0 maps to -1\n 1 maps to -0.9\n 2 maps to -0.8\n 3 maps to -0.7\n 4 maps to -0.6\n 5 maps to -0.5\n 6 maps to -0.4\n 7 maps to -0.3\n 8 maps to -0.2\n 9 maps to -0.1\n10 maps to 0\n"}
{"id": 96480, "name": "Map range", "source": "Translate Ruby to Python: def map_range(a, b, s)\n  af, al, bf, bl = a.first, a.last, b.first, b.last\n  bf + (s - af)*(bl - bf).quo(al - af)\nend\n\n(0..10).each{|s| puts \"%s maps to %g\" % [s, map_range(0..10, -1..0, s)]}\n", "target": ">>> def maprange( a, b, s):\n\t(a1, a2), (b1, b2) = a, b\n\treturn  b1 + ((s - a1) * (b2 - b1) / (a2 - a1))\n\n>>> for s in range(11):\n\tprint(\"%2g maps to %g\" % (s, maprange( (0, 10), (-1, 0), s)))\n\n\t\n 0 maps to -1\n 1 maps to -0.9\n 2 maps to -0.8\n 3 maps to -0.7\n 4 maps to -0.6\n 5 maps to -0.5\n 6 maps to -0.4\n 7 maps to -0.3\n 8 maps to -0.2\n 9 maps to -0.1\n10 maps to 0\n"}
{"id": 96724, "name": "Function composition", "source": "Translate Ruby to C#: require \"math\"\n\ndef compose(f : Proc(T, _), g : Proc(_, _)) forall T\n  return ->(x : T) { f.call(g.call(x)) }\nend\n\ncompose(->Math.sin(Float64), ->Math.asin(Float64)).call(0.5)  \n", "target": "using System;\nclass Program\n{\n    static void Main(string[] args)\n    {\n        Func<int, int> outfunc = Composer<int, int, int>.Compose(functA, functB);\n        Console.WriteLine(outfunc(5)); \n    }\n    static int functA(int i) { return i * 10; }\n    static int functB(int i) { return i + 5; }\n    class Composer<A, B, C>\n    {\n        public static Func<C, A> Compose(Func<B, A> a, Func<C, B> b)\n        {\n            return delegate(C i) { return a(b(i)); };\n        }\n    }\n}\n"}
{"id": 96726, "name": "Function composition", "source": "Translate Ruby to Java: require \"math\"\n\ndef compose(f : Proc(T, _), g : Proc(_, _)) forall T\n  return ->(x : T) { f.call(g.call(x)) }\nend\n\ncompose(->Math.sin(Float64), ->Math.asin(Float64)).call(0.5)  \n", "target": "public class Compose {\n\n    \n    \n    public interface Fun<A,B> {\n        B call(A x);\n    }\n\n    public static <A,B,C> Fun<A,C> compose(final Fun<B,C> f, final Fun<A,B> g) {\n        return new Fun<A,C>() {\n            public C call(A x) {\n                return f.call(g.call(x));\n            }\n        };\n    }\n\n    public static void main(String[] args) {\n        Fun<Double,Double> sin = new Fun<Double,Double>() {\n            public Double call(Double x) {\n                return Math.sin(x);\n            }\n        };\n        Fun<Double,Double> asin = new Fun<Double,Double>() {\n            public Double call(Double x) {\n                return Math.asin(x);\n            }\n        };\n\n        Fun<Double,Double> sin_asin = compose(sin, asin);\n\n        System.out.println(sin_asin.call(0.5)); \n    }\n}\n"}
{"id": 96727, "name": "Function composition", "source": "Translate Ruby to Python: require \"math\"\n\ndef compose(f : Proc(T, _), g : Proc(_, _)) forall T\n  return ->(x : T) { f.call(g.call(x)) }\nend\n\ncompose(->Math.sin(Float64), ->Math.asin(Float64)).call(0.5)  \n", "target": "compose = lambda f, g: lambda x: f( g(x) )\n"}
{"id": 96999, "name": "HTTP", "source": "Translate Ruby to C#: require 'open-uri'\n\nprint open(\"http://rosettacode.org\") {|f| f.read}\n", "target": "using System;\nusing System.Text;\nusing System.Net;\n\nclass Program\n{\n    static void Main(string[] args)\n    {\n        WebClient wc = new WebClient();\n        string content = wc.DownloadString(\"http:\n        Console.WriteLine(content);\n    }\n}\n"}
{"id": 97001, "name": "HTTP", "source": "Translate Ruby to Java: require 'open-uri'\n\nprint open(\"http://rosettacode.org\") {|f| f.read}\n", "target": "import java.net.URI;\nimport java.net.http.HttpClient;\nimport java.net.http.HttpRequest;\nimport java.net.http.HttpResponse;\nimport java.nio.charset.Charset;\n\npublic class Main {\n    public static void main(String[] args) {\n        var request = HttpRequest.newBuilder(URI.create(\"https:\n                .GET()\n                .build();\n\n        HttpClient.newHttpClient()\n                .sendAsync(request, HttpResponse.BodyHandlers.ofString(Charset.defaultCharset()))\n                .thenApply(HttpResponse::body)\n                .thenAccept(System.out::println)\n                .join();\n    }\n}\n"}
{"id": 97002, "name": "HTTP", "source": "Translate Ruby to Python: require 'open-uri'\n\nprint open(\"http://rosettacode.org\") {|f| f.read}\n", "target": "import urllib.request\nprint(urllib.request.urlopen(\"http://rosettacode.org\").read())\n"}
{"id": 97279, "name": "Smith numbers", "source": "Translate Ruby to C#: require \"prime\"\n \nclass Integer\n \n  def smith?\n    return false if prime?\n    digits.sum == prime_division.map{|pr,n| pr.digits.sum * n}.sum\n  end\n \nend\n \nn   = 10_000\nres = 1.upto(n).select(&:smith?)\n \nputs \"\n\n", "target": "using System;\nusing System.Collections.Generic;\n\nnamespace SmithNumbers {\n    class Program {\n        static int SumDigits(int n) {\n            int sum = 0;\n            while (n > 0) {\n                n = Math.DivRem(n, 10, out int rem);\n                sum += rem;\n            }\n            return sum;\n        }\n\n        static List<int> PrimeFactors(int n) {\n            List<int> result = new List<int>();\n\n            for (int i = 2; n % i == 0; n /= i) {\n                result.Add(i);\n            }\n\n            for (int i = 3; i * i < n; i += 2) {\n                while (n % i == 0) {\n                    result.Add(i);\n                    n /= i;\n                }\n            }\n\n            if (n != 1) {\n                result.Add(n);\n            }\n\n            return result;\n        }\n\n        static void Main(string[] args) {\n            const int SIZE = 8;\n            int count = 0;\n            for (int n = 1; n < 10_000; n++) {\n                var factors = PrimeFactors(n);\n                if (factors.Count > 1) {\n                    int sum = SumDigits(n);\n                    foreach (var f in factors) {\n                        sum -= SumDigits(f);\n                    }\n                    if (sum == 0) {\n                        Console.Write(\"{0,5}\", n);\n                        if (count == SIZE - 1) {\n                            Console.WriteLine();\n                        }\n                        count = (count + 1) % SIZE;\n                    }\n                }\n            }\n        }\n    }\n}\n"}
{"id": 97280, "name": "Smith numbers", "source": "Translate Ruby to C#: require \"prime\"\n \nclass Integer\n \n  def smith?\n    return false if prime?\n    digits.sum == prime_division.map{|pr,n| pr.digits.sum * n}.sum\n  end\n \nend\n \nn   = 10_000\nres = 1.upto(n).select(&:smith?)\n \nputs \"\n\n", "target": "using System;\nusing System.Collections.Generic;\n\nnamespace SmithNumbers {\n    class Program {\n        static int SumDigits(int n) {\n            int sum = 0;\n            while (n > 0) {\n                n = Math.DivRem(n, 10, out int rem);\n                sum += rem;\n            }\n            return sum;\n        }\n\n        static List<int> PrimeFactors(int n) {\n            List<int> result = new List<int>();\n\n            for (int i = 2; n % i == 0; n /= i) {\n                result.Add(i);\n            }\n\n            for (int i = 3; i * i < n; i += 2) {\n                while (n % i == 0) {\n                    result.Add(i);\n                    n /= i;\n                }\n            }\n\n            if (n != 1) {\n                result.Add(n);\n            }\n\n            return result;\n        }\n\n        static void Main(string[] args) {\n            const int SIZE = 8;\n            int count = 0;\n            for (int n = 1; n < 10_000; n++) {\n                var factors = PrimeFactors(n);\n                if (factors.Count > 1) {\n                    int sum = SumDigits(n);\n                    foreach (var f in factors) {\n                        sum -= SumDigits(f);\n                    }\n                    if (sum == 0) {\n                        Console.Write(\"{0,5}\", n);\n                        if (count == SIZE - 1) {\n                            Console.WriteLine();\n                        }\n                        count = (count + 1) % SIZE;\n                    }\n                }\n            }\n        }\n    }\n}\n"}
{"id": 97283, "name": "Smith numbers", "source": "Translate Ruby to Java: require \"prime\"\n \nclass Integer\n \n  def smith?\n    return false if prime?\n    digits.sum == prime_division.map{|pr,n| pr.digits.sum * n}.sum\n  end\n \nend\n \nn   = 10_000\nres = 1.upto(n).select(&:smith?)\n \nputs \"\n\n", "target": "import java.util.*;\n\npublic class SmithNumbers {\n\n    public static void main(String[] args) {\n        for (int n = 1; n < 10_000; n++) {\n            List<Integer> factors = primeFactors(n);\n            if (factors.size() > 1) {\n                int sum = sumDigits(n);\n                for (int f : factors)\n                    sum -= sumDigits(f);\n                if (sum == 0)\n                    System.out.println(n);\n            }\n        }\n    }\n\n    static List<Integer> primeFactors(int n) {\n        List<Integer> result = new ArrayList<>();\n\n        for (int i = 2; n % i == 0; n /= i)\n            result.add(i);\n\n        for (int i = 3; i * i <= n; i += 2) {\n            while (n % i == 0) {\n                result.add(i);\n                n /= i;\n            }\n        }\n\n        if (n != 1)\n            result.add(n);\n\n        return result;\n    }\n\n    static int sumDigits(int n) {\n        int sum = 0;\n        while (n > 0) {\n            sum += (n % 10);\n            n /= 10;\n        }\n        return sum;\n    }\n}\n"}
{"id": 97284, "name": "Smith numbers", "source": "Translate Ruby to Java: require \"prime\"\n \nclass Integer\n \n  def smith?\n    return false if prime?\n    digits.sum == prime_division.map{|pr,n| pr.digits.sum * n}.sum\n  end\n \nend\n \nn   = 10_000\nres = 1.upto(n).select(&:smith?)\n \nputs \"\n\n", "target": "import java.util.*;\n\npublic class SmithNumbers {\n\n    public static void main(String[] args) {\n        for (int n = 1; n < 10_000; n++) {\n            List<Integer> factors = primeFactors(n);\n            if (factors.size() > 1) {\n                int sum = sumDigits(n);\n                for (int f : factors)\n                    sum -= sumDigits(f);\n                if (sum == 0)\n                    System.out.println(n);\n            }\n        }\n    }\n\n    static List<Integer> primeFactors(int n) {\n        List<Integer> result = new ArrayList<>();\n\n        for (int i = 2; n % i == 0; n /= i)\n            result.add(i);\n\n        for (int i = 3; i * i <= n; i += 2) {\n            while (n % i == 0) {\n                result.add(i);\n                n /= i;\n            }\n        }\n\n        if (n != 1)\n            result.add(n);\n\n        return result;\n    }\n\n    static int sumDigits(int n) {\n        int sum = 0;\n        while (n > 0) {\n            sum += (n % 10);\n            n /= 10;\n        }\n        return sum;\n    }\n}\n"}
{"id": 97285, "name": "Smith numbers", "source": "Translate Ruby to Python: require \"prime\"\n \nclass Integer\n \n  def smith?\n    return false if prime?\n    digits.sum == prime_division.map{|pr,n| pr.digits.sum * n}.sum\n  end\n \nend\n \nn   = 10_000\nres = 1.upto(n).select(&:smith?)\n \nputs \"\n\n", "target": "from sys import stdout\n\n\ndef factors(n):\n    rt = []\n    f = 2\n    if n == 1:\n        rt.append(1);\n    else:\n        while 1:\n            if 0 == ( n % f ):\n                rt.append(f);\n                n //= f\n                if n == 1:\n                    return rt\n            else:\n                f += 1\n    return rt\n\n\ndef sum_digits(n):\n    sum = 0\n    while n > 0:\n        m = n % 10\n        sum += m\n        n -= m\n        n //= 10\n\n    return sum\n\n\ndef add_all_digits(lst):\n    sum = 0\n    for i in range (len(lst)):\n        sum += sum_digits(lst[i])\n\n    return sum\n\n\ndef list_smith_numbers(cnt):\n    for i in range(4, cnt):\n        fac = factors(i)\n        if len(fac) > 1:\n            if sum_digits(i) == add_all_digits(fac):\n                stdout.write(\"{0} \".format(i) )\n\n\nlist_smith_numbers(10_000)\n"}
{"id": 97286, "name": "Smith numbers", "source": "Translate Ruby to Python: require \"prime\"\n \nclass Integer\n \n  def smith?\n    return false if prime?\n    digits.sum == prime_division.map{|pr,n| pr.digits.sum * n}.sum\n  end\n \nend\n \nn   = 10_000\nres = 1.upto(n).select(&:smith?)\n \nputs \"\n\n", "target": "from sys import stdout\n\n\ndef factors(n):\n    rt = []\n    f = 2\n    if n == 1:\n        rt.append(1);\n    else:\n        while 1:\n            if 0 == ( n % f ):\n                rt.append(f);\n                n //= f\n                if n == 1:\n                    return rt\n            else:\n                f += 1\n    return rt\n\n\ndef sum_digits(n):\n    sum = 0\n    while n > 0:\n        m = n % 10\n        sum += m\n        n -= m\n        n //= 10\n\n    return sum\n\n\ndef add_all_digits(lst):\n    sum = 0\n    for i in range (len(lst)):\n        sum += sum_digits(lst[i])\n\n    return sum\n\n\ndef list_smith_numbers(cnt):\n    for i in range(4, cnt):\n        fac = factors(i)\n        if len(fac) > 1:\n            if sum_digits(i) == add_all_digits(fac):\n                stdout.write(\"{0} \".format(i) )\n\n\nlist_smith_numbers(10_000)\n"}
{"id": 97524, "name": "Web scraping", "source": "Translate Ruby to C#: require \"open-uri\"\n\nopen('http://tycho.usno.navy.mil/cgi-bin/timer.pl') do |p|\n  p.each_line do |line|\n    if line =~ /UTC/\n      puts line.match(/ (\\d{1,2}:\\d{1,2}:\\d{1,2}) /)\n      break\n    end\n  end\nend\n", "target": "class Program\n    {\n        static void Main(string[] args)\n        {\n            WebClient wc = new WebClient();\n            Stream myStream = wc.OpenRead(\"http:\n            string html = \"\";\n            using (StreamReader sr = new StreamReader(myStream))\n            {\n                while (sr.Peek() >= 0)\n                {\n                    html = sr.ReadLine();\n                    if (html.Contains(\"UTC\"))\n                    {\n                        break;\n                    }\n                }\n                \n            }\n            Console.WriteLine(html.Remove(0, 4));\n\n            Console.ReadLine();\n        }\n    }\n"}
{"id": 97526, "name": "Web scraping", "source": "Translate Ruby to Java: require \"open-uri\"\n\nopen('http://tycho.usno.navy.mil/cgi-bin/timer.pl') do |p|\n  p.each_line do |line|\n    if line =~ /UTC/\n      puts line.match(/ (\\d{1,2}:\\d{1,2}:\\d{1,2}) /)\n      break\n    end\n  end\nend\n", "target": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.net.URL;\nimport java.net.URLConnection;\n\n\npublic class WebTime{\n  public static void main(String[] args){\n    try{\n      URL address = new URL(\n          \"http:\n      URLConnection conn = address.openConnection();\n      BufferedReader in = new BufferedReader(\n          new InputStreamReader(conn.getInputStream()));\n      String line;\n      while(!(line = in.readLine()).contains(\"UTC\"));\n      System.out.println(line.substring(4));\n    }catch(IOException e){\n      System.err.println(\"error connecting to server.\");\n      e.printStackTrace();\n    }\n  }\n}\n"}
{"id": 97527, "name": "Web scraping", "source": "Translate Ruby to Python: require \"open-uri\"\n\nopen('http://tycho.usno.navy.mil/cgi-bin/timer.pl') do |p|\n  p.each_line do |line|\n    if line =~ /UTC/\n      puts line.match(/ (\\d{1,2}:\\d{1,2}:\\d{1,2}) /)\n      break\n    end\n  end\nend\n", "target": "import urllib\npage = urllib.urlopen('http://tycho.usno.navy.mil/cgi-bin/timer.pl')\nfor line in page:\n    if ' UTC' in line:\n        print line.strip()[4:]\n        break\npage.close()\n"}
{"id": 97680, "name": "Multiple regression", "source": "Translate Ruby to C#: require 'matrix'\n\ndef regression_coefficients y, x\n  y = Matrix.column_vector y.map { |i| i.to_f }\n  x = Matrix.columns x.map { |xi| xi.map { |i| i.to_f }}\n\n  (x.t * x).inverse * x.t * y\nend\n", "target": "using System;\nusing MathNet.Numerics.LinearRegression;\nusing MathNet.Numerics.LinearAlgebra;\nusing MathNet.Numerics.LinearAlgebra.Double;\n\nclass Program\n{\n    static void Main(string[] args)\n    {\n        var col = DenseVector.OfArray(new double[] { 1.47, 1.50, 1.52, 1.55, 1.57, 1.60, 1.63, 1.65,\n            1.68, 1.70, 1.73, 1.75, 1.78, 1.80, 1.83 });\n        var X = DenseMatrix.OfColumns(new Vector<double>[] { col.PointwisePower(0), col, col.PointwisePower(2) });\n        var y = DenseVector.OfArray(new double[] { 52.21, 53.12, 54.48, 55.84, 57.20, 58.57, 59.93,\n            61.29, 63.11, 64.47, 66.28, 68.10, 69.92, 72.19, 74.46 });\n        var \u03b2 = MultipleRegression.QR(X, y);\n        Console.WriteLine(\u03b2);\n    }\n}\n"}
{"id": 97682, "name": "Multiple regression", "source": "Translate Ruby to Java: require 'matrix'\n\ndef regression_coefficients y, x\n  y = Matrix.column_vector y.map { |i| i.to_f }\n  x = Matrix.columns x.map { |xi| xi.map { |i| i.to_f }}\n\n  (x.t * x).inverse * x.t * y\nend\n", "target": "import java.util.Arrays;\nimport java.util.Objects;\n\npublic class MultipleRegression {\n    public static void require(boolean condition, String message) {\n        if (condition) {\n            return;\n        }\n        throw new IllegalArgumentException(message);\n    }\n\n    public static class Matrix {\n        private final double[][] data;\n        private final int rowCount;\n        private final int colCount;\n\n        public Matrix(int rows, int cols) {\n            require(rows > 0, \"Need at least one row\");\n            this.rowCount = rows;\n\n            require(cols > 0, \"Need at least one column\");\n            this.colCount = cols;\n\n            this.data = new double[rows][cols];\n            for (double[] row : this.data) {\n                Arrays.fill(row, 0.0);\n            }\n        }\n\n        public Matrix(double[][] source) {\n            require(source.length > 0, \"Need at least one row\");\n            this.rowCount = source.length;\n\n            require(source[0].length > 0, \"Need at least one column\");\n            this.colCount = source[0].length;\n\n            this.data = new double[this.rowCount][this.colCount];\n            for (int i = 0; i < this.rowCount; i++) {\n                set(i, source[i]);\n            }\n        }\n\n        public double[] get(int row) {\n            Objects.checkIndex(row, this.rowCount);\n            return this.data[row];\n        }\n\n        public void set(int row, double[] data) {\n            Objects.checkIndex(row, this.rowCount);\n            require(data.length == this.colCount, \"The column in the row must match the number of columns in the matrix\");\n            System.arraycopy(data, 0, this.data[row], 0, this.colCount);\n        }\n\n        public double get(int row, int col) {\n            Objects.checkIndex(row, this.rowCount);\n            Objects.checkIndex(col, this.colCount);\n            return this.data[row][col];\n        }\n\n        public void set(int row, int col, double value) {\n            Objects.checkIndex(row, this.rowCount);\n            Objects.checkIndex(col, this.colCount);\n            this.data[row][col] = value;\n        }\n\n        @SuppressWarnings(\"UnnecessaryLocalVariable\")\n        public Matrix times(Matrix that) {\n            var rc1 = this.rowCount;\n            var cc1 = this.colCount;\n            var rc2 = that.rowCount;\n            var cc2 = that.colCount;\n            require(cc1 == rc2, \"Cannot multiply if the first columns does not equal the second rows\");\n            var result = new Matrix(rc1, cc2);\n            for (int i = 0; i < rc1; i++) {\n                for (int j = 0; j < cc2; j++) {\n                    for (int k = 0; k < rc2; k++) {\n                        var prod = get(i, k) * that.get(k, j);\n                        result.set(i, j, result.get(i, j) + prod);\n                    }\n                }\n            }\n            return result;\n        }\n\n        public Matrix transpose() {\n            var rc = this.rowCount;\n            var cc = this.colCount;\n            var trans = new Matrix(cc, rc);\n            for (int i = 0; i < cc; i++) {\n                for (int j = 0; j < rc; j++) {\n                    trans.set(i, j, get(j, i));\n                }\n            }\n            return trans;\n        }\n\n        public void toReducedRowEchelonForm() {\n            int lead = 0;\n            var rc = this.rowCount;\n            var cc = this.colCount;\n            for (int r = 0; r < rc; r++) {\n                if (cc <= lead) {\n                    return;\n                }\n                var i = r;\n\n                while (get(i, lead) == 0.0) {\n                    i++;\n                    if (rc == i) {\n                        i = r;\n                        lead++;\n                        if (cc == lead) {\n                            return;\n                        }\n                    }\n                }\n\n                var temp = get(i);\n                set(i, get(r));\n                set(r, temp);\n\n                if (get(r, lead) != 0.0) {\n                    var div = get(r, lead);\n                    for (int j = 0; j < cc; j++) {\n                        set(r, j, get(r, j) / div);\n                    }\n                }\n\n                for (int k = 0; k < rc; k++) {\n                    if (k != r) {\n                        var mult = get(k, lead);\n                        for (int j = 0; j < cc; j++) {\n                            var prod = get(r, j) * mult;\n                            set(k, j, get(k, j) - prod);\n                        }\n                    }\n                }\n\n                lead++;\n            }\n        }\n\n        public Matrix inverse() {\n            require(this.rowCount == this.colCount, \"Not a square matrix\");\n            var len = this.rowCount;\n            var aug = new Matrix(len, 2 * len);\n            for (int i = 0; i < len; i++) {\n                for (int j = 0; j < len; j++) {\n                    aug.set(i, j, get(i, j));\n                }\n                \n                aug.set(i, i + len, 1.0);\n            }\n            aug.toReducedRowEchelonForm();\n            var inv = new Matrix(len, len);\n            \n            for (int i = 0; i < len; i++) {\n                for (int j = len; j < 2 * len; j++) {\n                    inv.set(i, j - len, aug.get(i, j));\n                }\n            }\n            return inv;\n        }\n    }\n\n    public static double[] multipleRegression(double[] y, Matrix x) {\n        var tm = new Matrix(new double[][]{y});\n        var cy = tm.transpose();\n        var cx = x.transpose();\n        return x.times(cx).inverse().times(x).times(cy).transpose().get(0);\n    }\n\n    public static void printVector(double[] v) {\n        System.out.println(Arrays.toString(v));\n        System.out.println();\n    }\n\n    public static double[] repeat(int size, double value) {\n        var a = new double[size];\n        Arrays.fill(a, value);\n        return a;\n    }\n\n    public static void main(String[] args) {\n        double[] y = new double[]{1.0, 2.0, 3.0, 4.0, 5.0};\n        var x = new Matrix(new double[][]{{2.0, 1.0, 3.0, 4.0, 5.0}});\n        var v = multipleRegression(y, x);\n        printVector(v);\n\n        y = new double[]{3.0, 4.0, 5.0};\n        x = new Matrix(new double[][]{\n            {1.0, 2.0, 1.0},\n            {1.0, 1.0, 2.0}\n        });\n        v = multipleRegression(y, x);\n        printVector(v);\n\n        y = new double[]{52.21, 53.12, 54.48, 55.84, 57.20, 58.57, 59.93, 61.29, 63.11, 64.47, 66.28, 68.10, 69.92, 72.19, 74.46};\n        var a = new double[]{1.47, 1.50, 1.52, 1.55, 1.57, 1.60, 1.63, 1.65, 1.68, 1.70, 1.73, 1.75, 1.78, 1.80, 1.83};\n        x = new Matrix(new double[][]{\n            repeat(a.length, 1.0),\n            a,\n            Arrays.stream(a).map(it -> it * it).toArray()\n        });\n\n        v = multipleRegression(y, x);\n        printVector(v);\n    }\n}\n"}
{"id": 97683, "name": "Multiple regression", "source": "Translate Ruby to Python: require 'matrix'\n\ndef regression_coefficients y, x\n  y = Matrix.column_vector y.map { |i| i.to_f }\n  x = Matrix.columns x.map { |xi| xi.map { |i| i.to_f }}\n\n  (x.t * x).inverse * x.t * y\nend\n", "target": "import numpy as np\n\nheight = [1.47, 1.50, 1.52, 1.55, 1.57, 1.60, 1.63,\n    1.65, 1.68, 1.70, 1.73, 1.75, 1.78, 1.80, 1.83]\nweight = [52.21, 53.12, 54.48, 55.84, 57.20, 58.57, 59.93,\n    61.29, 63.11, 64.47, 66.28, 68.10, 69.92, 72.19, 74.46]\n\nX = np.mat(height**np.arange(3)[:, None])\ny = np.mat(weight)\n\nprint(y * X.T * (X*X.T).I)\n"}
{"id": 97809, "name": "Bitmap_Flood fill", "source": "Translate Ruby to C#: \n\nrequire_relative 'raster_graphics'\n\nclass RGBColour\n  def ==(other)\n    values == other.values\n  end\nend\n\nclass Pixmap\n  def flood_fill(pixel, new_colour)\n    current_colour = self[pixel.x, pixel.y]\n    queue = Queue.new\n    queue.enq(pixel)\n    until queue.empty?\n      p = queue.pop\n      next unless self[p.x, p.y] == current_colour\n\n      west = find_border(p, current_colour, :west)\n      east = find_border(p, current_colour, :east)\n      draw_line(west, east, new_colour)\n      q = west\n      while q.x <= east.x\n        %i[north south].each do |direction|\n          n = neighbour(q, direction)\n          queue.enq(n) if self[n.x, n.y] == current_colour\n        end\n        q = neighbour(q, :east)\n      end\n    end\n  end\n\n  def neighbour(pixel, direction)\n    case direction\n    when :north then Pixel[pixel.x, pixel.y - 1]\n    when :south then Pixel[pixel.x, pixel.y + 1]\n    when :east  then Pixel[pixel.x + 1, pixel.y]\n    when :west  then Pixel[pixel.x - 1, pixel.y]\n    end\n  end\n\n  def find_border(pixel, colour, direction)\n    nextp = neighbour(pixel, direction)\n    while self[nextp.x, nextp.y] == colour\n      pixel = nextp\n      nextp = neighbour(pixel, direction)\n    end\n    pixel\n  end\nend\n\nbitmap = Pixmap.new(300, 300)\nbitmap.draw_circle(Pixel[149, 149], 120, RGBColour::BLACK)\nbitmap.draw_circle(Pixel[200, 100], 40, RGBColour::BLACK)\nbitmap.flood_fill(Pixel[140, 160], RGBColour::BLUE)\nbitmap.save_as_png('flood_fill.png')\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Drawing;\n\nnamespace FloodFill\n{\n    class Program\n    {\n        private static bool ColorMatch(Color a, Color b)\n        {\n            return (a.ToArgb() & 0xffffff) == (b.ToArgb() & 0xffffff);\n        }\n\n        static void FloodFill(Bitmap bmp, Point pt, Color targetColor, Color replacementColor)\n        {\n            Queue<Point> q = new Queue<Point>();\n            q.Enqueue(pt);\n            while (q.Count > 0)\n            {\n                Point n = q.Dequeue();\n                if (!ColorMatch(bmp.GetPixel(n.X, n.Y),targetColor))\n                    continue;\n                Point w = n, e = new Point(n.X + 1, n.Y);\n                while ((w.X >= 0) && ColorMatch(bmp.GetPixel(w.X, w.Y),targetColor))\n                {\n                    bmp.SetPixel(w.X, w.Y, replacementColor);\n                    if ((w.Y > 0) && ColorMatch(bmp.GetPixel(w.X, w.Y - 1),targetColor))\n                        q.Enqueue(new Point(w.X, w.Y - 1));\n                    if ((w.Y < bmp.Height - 1) && ColorMatch(bmp.GetPixel(w.X, w.Y + 1),targetColor))\n                        q.Enqueue(new Point(w.X, w.Y + 1));\n                    w.X--;\n                }\n                while ((e.X <= bmp.Width - 1) && ColorMatch(bmp.GetPixel(e.X, e.Y),targetColor))\n                {\n                    bmp.SetPixel(e.X, e.Y, replacementColor);\n                    if ((e.Y > 0) && ColorMatch(bmp.GetPixel(e.X, e.Y - 1), targetColor))\n                        q.Enqueue(new Point(e.X, e.Y - 1));\n                    if ((e.Y < bmp.Height - 1) && ColorMatch(bmp.GetPixel(e.X, e.Y + 1), targetColor))\n                        q.Enqueue(new Point(e.X, e.Y + 1));\n                    e.X++;\n                }\n            }\n        }\n\n        static void Main(string[] args)\n        {\n            Bitmap bmp = new Bitmap(\"Unfilledcirc.bmp\");\n            FloodFill(bmp, new Point(200, 200), Color.White, Color.Red);\n            FloodFill(bmp, new Point(100, 100), Color.Black, Color.Blue);\n            bmp.Save(\"Filledcirc.bmp\");\n        }\n    }\n}\n"}
{"id": 97811, "name": "Bitmap_Flood fill", "source": "Translate Ruby to Java: \n\nrequire_relative 'raster_graphics'\n\nclass RGBColour\n  def ==(other)\n    values == other.values\n  end\nend\n\nclass Pixmap\n  def flood_fill(pixel, new_colour)\n    current_colour = self[pixel.x, pixel.y]\n    queue = Queue.new\n    queue.enq(pixel)\n    until queue.empty?\n      p = queue.pop\n      next unless self[p.x, p.y] == current_colour\n\n      west = find_border(p, current_colour, :west)\n      east = find_border(p, current_colour, :east)\n      draw_line(west, east, new_colour)\n      q = west\n      while q.x <= east.x\n        %i[north south].each do |direction|\n          n = neighbour(q, direction)\n          queue.enq(n) if self[n.x, n.y] == current_colour\n        end\n        q = neighbour(q, :east)\n      end\n    end\n  end\n\n  def neighbour(pixel, direction)\n    case direction\n    when :north then Pixel[pixel.x, pixel.y - 1]\n    when :south then Pixel[pixel.x, pixel.y + 1]\n    when :east  then Pixel[pixel.x + 1, pixel.y]\n    when :west  then Pixel[pixel.x - 1, pixel.y]\n    end\n  end\n\n  def find_border(pixel, colour, direction)\n    nextp = neighbour(pixel, direction)\n    while self[nextp.x, nextp.y] == colour\n      pixel = nextp\n      nextp = neighbour(pixel, direction)\n    end\n    pixel\n  end\nend\n\nbitmap = Pixmap.new(300, 300)\nbitmap.draw_circle(Pixel[149, 149], 120, RGBColour::BLACK)\nbitmap.draw_circle(Pixel[200, 100], 40, RGBColour::BLACK)\nbitmap.flood_fill(Pixel[140, 160], RGBColour::BLUE)\nbitmap.save_as_png('flood_fill.png')\n", "target": "import java.awt.Color;\nimport java.awt.Point;\nimport java.awt.image.BufferedImage;\nimport java.util.Deque;\nimport java.util.LinkedList;\n\npublic class FloodFill {\n  public void floodFill(BufferedImage image, Point node, Color targetColor, Color replacementColor) {\n    int width = image.getWidth();\n    int height = image.getHeight();\n    int target = targetColor.getRGB();\n    int replacement = replacementColor.getRGB();\n    if (target != replacement) {\n      Deque<Point> queue = new LinkedList<Point>();\n      do {\n        int x = node.x;\n        int y = node.y;\n        while (x > 0 && image.getRGB(x - 1, y) == target) {\n          x--;\n        }\n        boolean spanUp = false;\n        boolean spanDown = false;\n        while (x < width && image.getRGB(x, y) == target) {\n          image.setRGB(x, y, replacement);\n          if (!spanUp && y > 0 && image.getRGB(x, y - 1) == target) {\n            queue.add(new Point(x, y - 1));\n            spanUp = true;\n          } else if (spanUp && y > 0 && image.getRGB(x, y - 1) != target) {\n            spanUp = false;\n          }\n          if (!spanDown && y < height - 1 && image.getRGB(x, y + 1) == target) {\n            queue.add(new Point(x, y + 1));\n            spanDown = true;\n          } else if (spanDown && y < height - 1 && image.getRGB(x, y + 1) != target) {\n            spanDown = false;\n          }\n          x++;\n        }\n      } while ((node = queue.pollFirst()) != null);\n    }\n  }\n}\n"}
{"id": 97812, "name": "Bitmap_Flood fill", "source": "Translate Ruby to Python: \n\nrequire_relative 'raster_graphics'\n\nclass RGBColour\n  def ==(other)\n    values == other.values\n  end\nend\n\nclass Pixmap\n  def flood_fill(pixel, new_colour)\n    current_colour = self[pixel.x, pixel.y]\n    queue = Queue.new\n    queue.enq(pixel)\n    until queue.empty?\n      p = queue.pop\n      next unless self[p.x, p.y] == current_colour\n\n      west = find_border(p, current_colour, :west)\n      east = find_border(p, current_colour, :east)\n      draw_line(west, east, new_colour)\n      q = west\n      while q.x <= east.x\n        %i[north south].each do |direction|\n          n = neighbour(q, direction)\n          queue.enq(n) if self[n.x, n.y] == current_colour\n        end\n        q = neighbour(q, :east)\n      end\n    end\n  end\n\n  def neighbour(pixel, direction)\n    case direction\n    when :north then Pixel[pixel.x, pixel.y - 1]\n    when :south then Pixel[pixel.x, pixel.y + 1]\n    when :east  then Pixel[pixel.x + 1, pixel.y]\n    when :west  then Pixel[pixel.x - 1, pixel.y]\n    end\n  end\n\n  def find_border(pixel, colour, direction)\n    nextp = neighbour(pixel, direction)\n    while self[nextp.x, nextp.y] == colour\n      pixel = nextp\n      nextp = neighbour(pixel, direction)\n    end\n    pixel\n  end\nend\n\nbitmap = Pixmap.new(300, 300)\nbitmap.draw_circle(Pixel[149, 149], 120, RGBColour::BLACK)\nbitmap.draw_circle(Pixel[200, 100], 40, RGBColour::BLACK)\nbitmap.flood_fill(Pixel[140, 160], RGBColour::BLUE)\nbitmap.save_as_png('flood_fill.png')\n", "target": "from collections import deque\n\nimage_file = \"image.png\"\nfill_color = color(250, 0, 0)\ntolerance = 15\nallowed = False\n\ndef setup():\n    global img\n    size(600, 400)\n    img = loadImage(image_file)\n    fill(0, 0, 100)\n    textSize(18)\n    show()\n    \ndef show():\n    image(img, 0, 0, width, height)\n    text(\"Tolerance = {}    (Use mouse wheel to change)\".format(tolerance),\n         100, height - 30)\n    text(\"Right click to reset\", 100, height - 10)\n \ndef draw():\n    global allowed\n    if allowed:\n        show()\n        allowed = False\n\ndef mousePressed():\n    global allowed, img\n    if mouseButton == RIGHT:\n        img = loadImage(image_file)\n    else:\n        img.loadPixels()\n        flood(mouseX, mouseY)\n        img.updatePixels()\n    allowed = True    \n\ndef mouseWheel(event):\n    global allowed, tolerance\n    e = event.getCount()\n    tolerance += 2 * e\n    if tolerance > 128:\n        tolerance = 128\n    if tolerance < 0:\n        tolerance = 0\n    allowed = True\n\ndef flood(x, y):\n    target_color = img.pixels[pixel_position(mouseX, mouseY)]\n    if target_color != fill_color:\n        queue = deque()\n        queue.append((x, y))\n        while len(queue) > 0:\n            p_x, p_y = queue.popleft()\n            if (check(p_x, p_y, target_color)):\n                queue.append((p_x, p_y - 1))\n                queue.append((p_x, p_y + 1))\n                queue.append((p_x - 1, p_y))\n                queue.append((p_x + 1, p_y))\n\ndef pixel_position(x, y):\n    return x + (y * img.width)\n\ndef check(x, y, target_color):\n    if x < 0 or y < 0 or y >= img.height or x >= img.width:\n        return False\n    pp = img.pixels[pixel_position(x, y)]\n    test_tolerance = (abs(green(target_color) - green(pp)) < tolerance\n                      and abs(red(target_color) - red(pp)) < tolerance\n                      and abs(blue(target_color) - blue(pp)) < tolerance)\n    if not test_tolerance:\n        return False\n    img.pixels[pixel_position(x, y)] = fill_color\n    return True\n"}
{"id": 98140, "name": "Dutch national flag problem", "source": "Translate Ruby to C#: class Ball\n  FLAG = {red: 1, white: 2, blue: 3}\n \n  def initialize\n    @color = FLAG.keys.sample\n  end\n\n  def color\n    @color\n  end\n\n  def <=>(other)  \n    FLAG[self.color] <=> FLAG[other.color]\n  end\n\n  def inspect\n    @color\n  end\nend\n\nballs = [] \nballs = Array.new(8){Ball.new} while balls == balls.sort\n\nputs \"Random: \nputs \"Sorted: \n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\nnamespace RosettaCode\n{\n    class Program\n    {\n        static void QuickSort(IComparable[] elements, int left, int right)\n        {\n            int i = left, j = right;\n            IComparable pivot = elements[left + (right - left) / 2];\n\n            while (i <= j)\n            {\n                while (elements[i].CompareTo(pivot) < 0) i++;\n                while (elements[j].CompareTo(pivot) > 0) j--;\n\n                if (i <= j)\n                {\n                    \n                    IComparable tmp = elements[i];\n                    elements[i] = elements[j];\n                    elements[j] = tmp;\n                    i++;\n                    j--;\n                }\n            }\n\n            \n            if (left < j) QuickSort(elements, left, j);\n            if (i < right) QuickSort(elements, i, right);\n        }\n        const int NUMBALLS = 5;\n        static void Main(string[] args)\n        {\n            Func<string[], bool> IsSorted = (ballList) =>\n                {\n                    int state = 0;\n                    for (int i = 0; i < NUMBALLS; i++)\n                    {\n                        if (int.Parse(ballList[i]) < state)\n                            return false;\n                        if (int.Parse(ballList[i]) > state)\n                            state = int.Parse(ballList[i]);\n                    }\n                    return true;\n                };\n            Func<string[], string> PrintOut = (ballList2) =>\n                {\n                    StringBuilder str = new StringBuilder();\n                    for (int i = 0; i < NUMBALLS; i++)\n                        str.Append(int.Parse(ballList2[i]) == 0 ? \"r\" : int.Parse(ballList2[i]) == 1 ? \"w\" : \"b\");\n                    return str.ToString();\n                };\n            bool continueLoop = true;\n            string[] balls = new string[NUMBALLS]; \n            Random numberGenerator = new Random();\n            do \n            {\n                \n                for (int i = 0; i < NUMBALLS; i++)\n                    balls[i] = numberGenerator.Next(3).ToString();\n\n                continueLoop = IsSorted(balls);\n                if (continueLoop)\n                    Console.WriteLine(\"Accidentally still sorted: {0}\", PrintOut(balls));\n            } while (continueLoop);\n            Console.WriteLine(\"Non-sorted: {0}\", PrintOut(balls));\n            QuickSort(balls, 0, NUMBALLS - 1); \n            Console.WriteLine(\"{0}: {1}\", IsSorted(balls) ? \"Sorted\" : \"Sort failed\", PrintOut(balls));\n        }\n    }\n}\n"}
{"id": 98141, "name": "Dutch national flag problem", "source": "Translate Ruby to C#: class Ball\n  FLAG = {red: 1, white: 2, blue: 3}\n \n  def initialize\n    @color = FLAG.keys.sample\n  end\n\n  def color\n    @color\n  end\n\n  def <=>(other)  \n    FLAG[self.color] <=> FLAG[other.color]\n  end\n\n  def inspect\n    @color\n  end\nend\n\nballs = [] \nballs = Array.new(8){Ball.new} while balls == balls.sort\n\nputs \"Random: \nputs \"Sorted: \n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\nnamespace RosettaCode\n{\n    class Program\n    {\n        static void QuickSort(IComparable[] elements, int left, int right)\n        {\n            int i = left, j = right;\n            IComparable pivot = elements[left + (right - left) / 2];\n\n            while (i <= j)\n            {\n                while (elements[i].CompareTo(pivot) < 0) i++;\n                while (elements[j].CompareTo(pivot) > 0) j--;\n\n                if (i <= j)\n                {\n                    \n                    IComparable tmp = elements[i];\n                    elements[i] = elements[j];\n                    elements[j] = tmp;\n                    i++;\n                    j--;\n                }\n            }\n\n            \n            if (left < j) QuickSort(elements, left, j);\n            if (i < right) QuickSort(elements, i, right);\n        }\n        const int NUMBALLS = 5;\n        static void Main(string[] args)\n        {\n            Func<string[], bool> IsSorted = (ballList) =>\n                {\n                    int state = 0;\n                    for (int i = 0; i < NUMBALLS; i++)\n                    {\n                        if (int.Parse(ballList[i]) < state)\n                            return false;\n                        if (int.Parse(ballList[i]) > state)\n                            state = int.Parse(ballList[i]);\n                    }\n                    return true;\n                };\n            Func<string[], string> PrintOut = (ballList2) =>\n                {\n                    StringBuilder str = new StringBuilder();\n                    for (int i = 0; i < NUMBALLS; i++)\n                        str.Append(int.Parse(ballList2[i]) == 0 ? \"r\" : int.Parse(ballList2[i]) == 1 ? \"w\" : \"b\");\n                    return str.ToString();\n                };\n            bool continueLoop = true;\n            string[] balls = new string[NUMBALLS]; \n            Random numberGenerator = new Random();\n            do \n            {\n                \n                for (int i = 0; i < NUMBALLS; i++)\n                    balls[i] = numberGenerator.Next(3).ToString();\n\n                continueLoop = IsSorted(balls);\n                if (continueLoop)\n                    Console.WriteLine(\"Accidentally still sorted: {0}\", PrintOut(balls));\n            } while (continueLoop);\n            Console.WriteLine(\"Non-sorted: {0}\", PrintOut(balls));\n            QuickSort(balls, 0, NUMBALLS - 1); \n            Console.WriteLine(\"{0}: {1}\", IsSorted(balls) ? \"Sorted\" : \"Sort failed\", PrintOut(balls));\n        }\n    }\n}\n"}
{"id": 98144, "name": "Dutch national flag problem", "source": "Translate Ruby to Java: class Ball\n  FLAG = {red: 1, white: 2, blue: 3}\n \n  def initialize\n    @color = FLAG.keys.sample\n  end\n\n  def color\n    @color\n  end\n\n  def <=>(other)  \n    FLAG[self.color] <=> FLAG[other.color]\n  end\n\n  def inspect\n    @color\n  end\nend\n\nballs = [] \nballs = Array.new(8){Ball.new} while balls == balls.sort\n\nputs \"Random: \nputs \"Sorted: \n", "target": "import java.util.Arrays;\nimport java.util.Random;\n\npublic class DutchNationalFlag {\n    enum DutchColors {\n        RED, WHITE, BLUE\n    }\n\n    public static void main(String[] args){\n        DutchColors[] balls = new DutchColors[12];\n        DutchColors[] values = DutchColors.values();\n        Random rand = new Random();\n\n        for (int i = 0; i < balls.length; i++)\n            balls[i]=values[rand.nextInt(values.length)];\n        System.out.println(\"Before: \" + Arrays.toString(balls));\n\n        Arrays.sort(balls);\n        System.out.println(\"After:  \" + Arrays.toString(balls));\n\n        boolean sorted = true;\n        for (int i = 1; i < balls.length; i++ ){\n            if (balls[i-1].compareTo(balls[i]) > 0){\n                sorted=false;\n                break;\n            }\n        }\n        System.out.println(\"Correctly sorted: \" + sorted);\n    }\n}\n"}
{"id": 98145, "name": "Dutch national flag problem", "source": "Translate Ruby to Java: class Ball\n  FLAG = {red: 1, white: 2, blue: 3}\n \n  def initialize\n    @color = FLAG.keys.sample\n  end\n\n  def color\n    @color\n  end\n\n  def <=>(other)  \n    FLAG[self.color] <=> FLAG[other.color]\n  end\n\n  def inspect\n    @color\n  end\nend\n\nballs = [] \nballs = Array.new(8){Ball.new} while balls == balls.sort\n\nputs \"Random: \nputs \"Sorted: \n", "target": "import java.util.Arrays;\nimport java.util.Random;\n\npublic class DutchNationalFlag {\n    enum DutchColors {\n        RED, WHITE, BLUE\n    }\n\n    public static void main(String[] args){\n        DutchColors[] balls = new DutchColors[12];\n        DutchColors[] values = DutchColors.values();\n        Random rand = new Random();\n\n        for (int i = 0; i < balls.length; i++)\n            balls[i]=values[rand.nextInt(values.length)];\n        System.out.println(\"Before: \" + Arrays.toString(balls));\n\n        Arrays.sort(balls);\n        System.out.println(\"After:  \" + Arrays.toString(balls));\n\n        boolean sorted = true;\n        for (int i = 1; i < balls.length; i++ ){\n            if (balls[i-1].compareTo(balls[i]) > 0){\n                sorted=false;\n                break;\n            }\n        }\n        System.out.println(\"Correctly sorted: \" + sorted);\n    }\n}\n"}
{"id": 98146, "name": "Dutch national flag problem", "source": "Translate Ruby to Python: class Ball\n  FLAG = {red: 1, white: 2, blue: 3}\n \n  def initialize\n    @color = FLAG.keys.sample\n  end\n\n  def color\n    @color\n  end\n\n  def <=>(other)  \n    FLAG[self.color] <=> FLAG[other.color]\n  end\n\n  def inspect\n    @color\n  end\nend\n\nballs = [] \nballs = Array.new(8){Ball.new} while balls == balls.sort\n\nputs \"Random: \nputs \"Sorted: \n", "target": "import random\n\ncolours_in_order = 'Red White Blue'.split()\n\ndef dutch_flag_sort(items, order=colours_in_order):\n    'return sort of items using the given order'\n    reverse_index = dict((x,i) for i,x in enumerate(order))\n    return sorted(items, key=lambda x: reverse_index[x])\n\ndef dutch_flag_check(items, order=colours_in_order):\n    'Return True if each item of items is in the given order'\n    reverse_index = dict((x,i) for i,x in enumerate(order))\n    order_of_items = [reverse_index[item] for item in items]\n    return all(x <= y for x, y in zip(order_of_items, order_of_items[1:]))\n\ndef random_balls(mx=5):\n    'Select from 1 to mx balls of each colour, randomly'\n    balls = sum([[colour] * random.randint(1, mx)\n                 for colour in colours_in_order], [])\n    random.shuffle(balls)\n    return balls\n\ndef main():\n    \n    while True:\n        balls = random_balls()\n        if not dutch_flag_check(balls):\n            break\n    print(\"Original Ball order:\", balls)\n    sorted_balls = dutch_flag_sort(balls)\n    print(\"Sorted Ball Order:\", sorted_balls)\n    assert dutch_flag_check(sorted_balls), 'Whoops. Not sorted!'\n\nif __name__ == '__main__':\n    main()\n"}
{"id": 98147, "name": "Dutch national flag problem", "source": "Translate Ruby to Python: class Ball\n  FLAG = {red: 1, white: 2, blue: 3}\n \n  def initialize\n    @color = FLAG.keys.sample\n  end\n\n  def color\n    @color\n  end\n\n  def <=>(other)  \n    FLAG[self.color] <=> FLAG[other.color]\n  end\n\n  def inspect\n    @color\n  end\nend\n\nballs = [] \nballs = Array.new(8){Ball.new} while balls == balls.sort\n\nputs \"Random: \nputs \"Sorted: \n", "target": "import random\n\ncolours_in_order = 'Red White Blue'.split()\n\ndef dutch_flag_sort(items, order=colours_in_order):\n    'return sort of items using the given order'\n    reverse_index = dict((x,i) for i,x in enumerate(order))\n    return sorted(items, key=lambda x: reverse_index[x])\n\ndef dutch_flag_check(items, order=colours_in_order):\n    'Return True if each item of items is in the given order'\n    reverse_index = dict((x,i) for i,x in enumerate(order))\n    order_of_items = [reverse_index[item] for item in items]\n    return all(x <= y for x, y in zip(order_of_items, order_of_items[1:]))\n\ndef random_balls(mx=5):\n    'Select from 1 to mx balls of each colour, randomly'\n    balls = sum([[colour] * random.randint(1, mx)\n                 for colour in colours_in_order], [])\n    random.shuffle(balls)\n    return balls\n\ndef main():\n    \n    while True:\n        balls = random_balls()\n        if not dutch_flag_check(balls):\n            break\n    print(\"Original Ball order:\", balls)\n    sorted_balls = dutch_flag_sort(balls)\n    print(\"Sorted Ball Order:\", sorted_balls)\n    assert dutch_flag_check(sorted_balls), 'Whoops. Not sorted!'\n\nif __name__ == '__main__':\n    main()\n"}
{"id": 98544, "name": "Determine if a string has all the same characters", "source": "Translate Ruby to C#: strings = [\"\", \"   \", \"2\", \"333\", \".55\", \"tttTTT\", \"4444   444k\", \"p\u00e9p\u00e9\", \"\ud83d\udc36\ud83d\udc36\ud83d\udc3a\ud83d\udc36\", \"\ud83c\udf84\ud83c\udf84\ud83c\udf84\ud83c\udf84\"]\n\nstrings.each do |str|\n  pos = str.empty? ? nil : str =~ /[^\n  print \"\n  puts pos ? \"first different char \nend\n", "target": "using System;\n\nnamespace AllSame {\n    class Program {\n        static void Analyze(string s) {\n            Console.WriteLine(\"Examining [{0}] which has a length of {1}:\", s, s.Length);\n            if (s.Length > 1) {\n                var b = s[0];\n                for (int i = 1; i < s.Length; i++) {\n                    var c = s[i];\n                    if (c != b) {\n                        Console.WriteLine(\"    Not all characters in the string are the same.\");\n                        Console.WriteLine(\"    '{0}' (0x{1:X02}) is different at position {2}\", c, (int)c, i);\n                        return;\n                    }\n                }\n\n            }\n            Console.WriteLine(\"    All characters in the string are the same.\");\n        }\n\n        static void Main() {\n            var strs = new string[] { \"\", \"   \", \"2\", \"333\", \".55\", \"tttTTT\", \"4444 444k\" };\n            foreach (var str in strs) {\n                Analyze(str);\n            }\n        }\n    }\n}\n"}
{"id": 98545, "name": "Determine if a string has all the same characters", "source": "Translate Ruby to C#: strings = [\"\", \"   \", \"2\", \"333\", \".55\", \"tttTTT\", \"4444   444k\", \"p\u00e9p\u00e9\", \"\ud83d\udc36\ud83d\udc36\ud83d\udc3a\ud83d\udc36\", \"\ud83c\udf84\ud83c\udf84\ud83c\udf84\ud83c\udf84\"]\n\nstrings.each do |str|\n  pos = str.empty? ? nil : str =~ /[^\n  print \"\n  puts pos ? \"first different char \nend\n", "target": "using System;\n\nnamespace AllSame {\n    class Program {\n        static void Analyze(string s) {\n            Console.WriteLine(\"Examining [{0}] which has a length of {1}:\", s, s.Length);\n            if (s.Length > 1) {\n                var b = s[0];\n                for (int i = 1; i < s.Length; i++) {\n                    var c = s[i];\n                    if (c != b) {\n                        Console.WriteLine(\"    Not all characters in the string are the same.\");\n                        Console.WriteLine(\"    '{0}' (0x{1:X02}) is different at position {2}\", c, (int)c, i);\n                        return;\n                    }\n                }\n\n            }\n            Console.WriteLine(\"    All characters in the string are the same.\");\n        }\n\n        static void Main() {\n            var strs = new string[] { \"\", \"   \", \"2\", \"333\", \".55\", \"tttTTT\", \"4444 444k\" };\n            foreach (var str in strs) {\n                Analyze(str);\n            }\n        }\n    }\n}\n"}
{"id": 98548, "name": "Determine if a string has all the same characters", "source": "Translate Ruby to Java: strings = [\"\", \"   \", \"2\", \"333\", \".55\", \"tttTTT\", \"4444   444k\", \"p\u00e9p\u00e9\", \"\ud83d\udc36\ud83d\udc36\ud83d\udc3a\ud83d\udc36\", \"\ud83c\udf84\ud83c\udf84\ud83c\udf84\ud83c\udf84\"]\n\nstrings.each do |str|\n  pos = str.empty? ? nil : str =~ /[^\n  print \"\n  puts pos ? \"first different char \nend\n", "target": "public class Main{\n\tpublic static void main(String[] args){\n\t\tString[] tests = {\"\", \"   \", \"2\", \"333\", \".55\", \"tttTTT\", \"4444 444k\"};\n\t\tfor(String s:tests)\n\t\t\tanalyze(s);\n\t}\n\n\tpublic static void analyze(String s){\n\t\tSystem.out.printf(\"Examining [%s] which has a length of %d:\\n\", s, s.length());\n\t\tif(s.length() > 1){\n\t\t\tchar firstChar = s.charAt(0);\n\t\t\tint lastIndex = s.lastIndexOf(firstChar);\n\t\t\tif(lastIndex != 0){\n\t\t\t\tSystem.out.println(\"\\tNot all characters in the string are the same.\");\n\t\t\t\tSystem.out.printf(\"\\t'%c' (0x%x) is different at position %d\\n\", firstChar, (int) firstChar, lastIndex);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(\"\\tAll characters in the string are the same.\");\n\t}\n}\n"}
{"id": 98549, "name": "Determine if a string has all the same characters", "source": "Translate Ruby to Java: strings = [\"\", \"   \", \"2\", \"333\", \".55\", \"tttTTT\", \"4444   444k\", \"p\u00e9p\u00e9\", \"\ud83d\udc36\ud83d\udc36\ud83d\udc3a\ud83d\udc36\", \"\ud83c\udf84\ud83c\udf84\ud83c\udf84\ud83c\udf84\"]\n\nstrings.each do |str|\n  pos = str.empty? ? nil : str =~ /[^\n  print \"\n  puts pos ? \"first different char \nend\n", "target": "public class Main{\n\tpublic static void main(String[] args){\n\t\tString[] tests = {\"\", \"   \", \"2\", \"333\", \".55\", \"tttTTT\", \"4444 444k\"};\n\t\tfor(String s:tests)\n\t\t\tanalyze(s);\n\t}\n\n\tpublic static void analyze(String s){\n\t\tSystem.out.printf(\"Examining [%s] which has a length of %d:\\n\", s, s.length());\n\t\tif(s.length() > 1){\n\t\t\tchar firstChar = s.charAt(0);\n\t\t\tint lastIndex = s.lastIndexOf(firstChar);\n\t\t\tif(lastIndex != 0){\n\t\t\t\tSystem.out.println(\"\\tNot all characters in the string are the same.\");\n\t\t\t\tSystem.out.printf(\"\\t'%c' (0x%x) is different at position %d\\n\", firstChar, (int) firstChar, lastIndex);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(\"\\tAll characters in the string are the same.\");\n\t}\n}\n"}
{"id": 98550, "name": "Determine if a string has all the same characters", "source": "Translate Ruby to Python: strings = [\"\", \"   \", \"2\", \"333\", \".55\", \"tttTTT\", \"4444   444k\", \"p\u00e9p\u00e9\", \"\ud83d\udc36\ud83d\udc36\ud83d\udc3a\ud83d\udc36\", \"\ud83c\udf84\ud83c\udf84\ud83c\udf84\ud83c\udf84\"]\n\nstrings.each do |str|\n  pos = str.empty? ? nil : str =~ /[^\n  print \"\n  puts pos ? \"first different char \nend\n", "target": "\n\nfrom itertools import groupby\n\n\n\ndef firstDifferingCharLR(s):\n    \n    def details(xs):\n        c = xs[1][0]\n        return {\n            'char': repr(c),\n            'hex': hex(ord(c)),\n            'index': s.index(c),\n            'total': len(s)\n        }\n    xs = list(groupby(s))\n    return Right(details(xs)) if 1 < len(xs) else (\n        Left('Total length ' + str(len(s)) + ' - No character changes.')\n    )\n\n\n\n\ndef main():\n    \n\n    print(fTable('First, if any, points of difference:\\n')(repr)(\n        either(identity)(\n            lambda dct: dct['char'] + ' (' + dct['hex'] +\n            ') at character ' + str(1 + dct['index']) +\n            ' of ' + str(dct['total']) + '.'\n        )\n    )(firstDifferingCharLR)([\n        '',\n        '   ',\n        '2',\n        '333',\n        '.55',\n        'tttTTT',\n        '4444 444'\n    ]))\n\n\n\n\n\ndef either(fl):\n    \n    return lambda fr: lambda e: fl(e['Left']) if (\n        None is e['Right']\n    ) else fr(e['Right'])\n\n\n\ndef identity(x):\n    \n    return x\n\n\n\n\ndef fTable(s):\n    \n    def go(xShow, fxShow, f, xs):\n        ys = [xShow(x) for x in xs]\n        w = max(map(len, ys))\n        return s + '\\n' + '\\n'.join(map(\n            lambda x, y: y.rjust(w, ' ') + ' -> ' + fxShow(f(x)),\n            xs, ys\n        ))\n    return lambda xShow: lambda fxShow: lambda f: lambda xs: go(\n        xShow, fxShow, f, xs\n    )\n\n\n\ndef Left(x):\n    \n    return {'type': 'Either', 'Right': None, 'Left': x}\n\n\n\ndef Right(x):\n    \n    return {'type': 'Either', 'Left': None, 'Right': x}\n\n\n\nif __name__ == '__main__':\n    main()\n"}
{"id": 98551, "name": "Determine if a string has all the same characters", "source": "Translate Ruby to Python: strings = [\"\", \"   \", \"2\", \"333\", \".55\", \"tttTTT\", \"4444   444k\", \"p\u00e9p\u00e9\", \"\ud83d\udc36\ud83d\udc36\ud83d\udc3a\ud83d\udc36\", \"\ud83c\udf84\ud83c\udf84\ud83c\udf84\ud83c\udf84\"]\n\nstrings.each do |str|\n  pos = str.empty? ? nil : str =~ /[^\n  print \"\n  puts pos ? \"first different char \nend\n", "target": "\n\nfrom itertools import groupby\n\n\n\ndef firstDifferingCharLR(s):\n    \n    def details(xs):\n        c = xs[1][0]\n        return {\n            'char': repr(c),\n            'hex': hex(ord(c)),\n            'index': s.index(c),\n            'total': len(s)\n        }\n    xs = list(groupby(s))\n    return Right(details(xs)) if 1 < len(xs) else (\n        Left('Total length ' + str(len(s)) + ' - No character changes.')\n    )\n\n\n\n\ndef main():\n    \n\n    print(fTable('First, if any, points of difference:\\n')(repr)(\n        either(identity)(\n            lambda dct: dct['char'] + ' (' + dct['hex'] +\n            ') at character ' + str(1 + dct['index']) +\n            ' of ' + str(dct['total']) + '.'\n        )\n    )(firstDifferingCharLR)([\n        '',\n        '   ',\n        '2',\n        '333',\n        '.55',\n        'tttTTT',\n        '4444 444'\n    ]))\n\n\n\n\n\ndef either(fl):\n    \n    return lambda fr: lambda e: fl(e['Left']) if (\n        None is e['Right']\n    ) else fr(e['Right'])\n\n\n\ndef identity(x):\n    \n    return x\n\n\n\n\ndef fTable(s):\n    \n    def go(xShow, fxShow, f, xs):\n        ys = [xShow(x) for x in xs]\n        w = max(map(len, ys))\n        return s + '\\n' + '\\n'.join(map(\n            lambda x, y: y.rjust(w, ' ') + ' -> ' + fxShow(f(x)),\n            xs, ys\n        ))\n    return lambda xShow: lambda fxShow: lambda f: lambda xs: go(\n        xShow, fxShow, f, xs\n    )\n\n\n\ndef Left(x):\n    \n    return {'type': 'Either', 'Right': None, 'Left': x}\n\n\n\ndef Right(x):\n    \n    return {'type': 'Either', 'Left': None, 'Right': x}\n\n\n\nif __name__ == '__main__':\n    main()\n"}
{"id": 98944, "name": "Catamorphism", "source": "Translate Ruby to C#: \np (1..10).inject(:+)\n\np (1..20).inject(:lcm) \n", "target": "var nums = Enumerable.Range(1, 10);\n\nint summation = nums.Aggregate((a, b) => a + b);\n\nint product = nums.Aggregate((a, b) => a * b);\n\nstring concatenation = nums.Aggregate(String.Empty, (a, b) => a.ToString() + b.ToString());\n\nConsole.WriteLine(\"{0} {1} {2}\", summation, product, concatenation);\n"}
{"id": 98945, "name": "Catamorphism", "source": "Translate Ruby to C#: \np (1..10).inject(:+)\n\np (1..20).inject(:lcm) \n", "target": "var nums = Enumerable.Range(1, 10);\n\nint summation = nums.Aggregate((a, b) => a + b);\n\nint product = nums.Aggregate((a, b) => a * b);\n\nstring concatenation = nums.Aggregate(String.Empty, (a, b) => a.ToString() + b.ToString());\n\nConsole.WriteLine(\"{0} {1} {2}\", summation, product, concatenation);\n"}
{"id": 98948, "name": "Catamorphism", "source": "Translate Ruby to Java: \np (1..10).inject(:+)\n\np (1..20).inject(:lcm) \n", "target": "import java.util.stream.Stream;\n\npublic class ReduceTask {\n\n    public static void main(String[] args) {\n        System.out.println(Stream.of(1, 2, 3, 4, 5).mapToInt(i -> i).sum());\n        System.out.println(Stream.of(1, 2, 3, 4, 5).reduce(1, (a, b) -> a * b));\n    }\n}\n"}
{"id": 98949, "name": "Catamorphism", "source": "Translate Ruby to Java: \np (1..10).inject(:+)\n\np (1..20).inject(:lcm) \n", "target": "import java.util.stream.Stream;\n\npublic class ReduceTask {\n\n    public static void main(String[] args) {\n        System.out.println(Stream.of(1, 2, 3, 4, 5).mapToInt(i -> i).sum());\n        System.out.println(Stream.of(1, 2, 3, 4, 5).reduce(1, (a, b) -> a * b));\n    }\n}\n"}
{"id": 98950, "name": "Catamorphism", "source": "Translate Ruby to Python: \np (1..10).inject(:+)\n\np (1..20).inject(:lcm) \n", "target": ">>> \n>>> from operator import add\n>>> listoflists = [['the', 'cat'], ['sat', 'on'], ['the', 'mat']]\n>>> help(reduce)\nHelp on built-in function reduce in module __builtin__:\n\nreduce(...)\n    reduce(function, sequence[, initial]) -> value\n    \n    Apply a function of two arguments cumulatively to the items of a sequence,\n    from left to right, so as to reduce the sequence to a single value.\n    For example, reduce(lambda x, y: x+y, [1, 2, 3, 4, 5]) calculates\n    ((((1+2)+3)+4)+5).  If initial is present, it is placed before the items\n    of the sequence in the calculation, and serves as a default when the\n    sequence is empty.\n\n>>> reduce(add, listoflists, [])\n['the', 'cat', 'sat', 'on', 'the', 'mat']\n>>>\n"}
{"id": 98951, "name": "Catamorphism", "source": "Translate Ruby to Python: \np (1..10).inject(:+)\n\np (1..20).inject(:lcm) \n", "target": ">>> \n>>> from operator import add\n>>> listoflists = [['the', 'cat'], ['sat', 'on'], ['the', 'mat']]\n>>> help(reduce)\nHelp on built-in function reduce in module __builtin__:\n\nreduce(...)\n    reduce(function, sequence[, initial]) -> value\n    \n    Apply a function of two arguments cumulatively to the items of a sequence,\n    from left to right, so as to reduce the sequence to a single value.\n    For example, reduce(lambda x, y: x+y, [1, 2, 3, 4, 5]) calculates\n    ((((1+2)+3)+4)+5).  If initial is present, it is placed before the items\n    of the sequence in the calculation, and serves as a default when the\n    sequence is empty.\n\n>>> reduce(add, listoflists, [])\n['the', 'cat', 'sat', 'on', 'the', 'mat']\n>>>\n"}
{"id": 99229, "name": "Sleep", "source": "Translate Ruby to C#: seconds = gets.to_f\nputs \"Sleeping...\"\nsleep(seconds) \n\nputs \"Awake!\"\n", "target": "using System;\nusing System.Threading;\n\nclass Program\n{\n    static void Main(string[] args)\n    {\n        int sleep = Convert.ToInt32(Console.ReadLine());\n        Console.WriteLine(\"Sleeping...\");\n        Thread.Sleep(sleep); \n        Console.WriteLine(\"Awake!\");\n    }\n}\n"}
{"id": 99231, "name": "Sleep", "source": "Translate Ruby to Java: seconds = gets.to_f\nputs \"Sleeping...\"\nsleep(seconds) \n\nputs \"Awake!\"\n", "target": "import java.util.InputMismatchException;\nimport java.util.Scanner;\n\npublic class Sleep {\n    public static void main(final String[] args) throws InterruptedException {\n        try {\n            int ms = new Scanner(System.in).nextInt(); \n            System.out.println(\"Sleeping...\");\n            Thread.sleep(ms);\n            System.out.println(\"Awake!\");\n        } catch (InputMismatchException inputMismatchException) {\n            System.err.println(\"Exception: \" + inputMismatchException);\n        }\n    }\n}\n"}
{"id": 99232, "name": "Sleep", "source": "Translate Ruby to Python: seconds = gets.to_f\nputs \"Sleeping...\"\nsleep(seconds) \n\nputs \"Awake!\"\n", "target": "import time\n\nseconds = float(raw_input())\nprint \"Sleeping...\"\ntime.sleep(seconds) \nprint \"Awake!\"\n"}
{"id": 99408, "name": "Polymorphism", "source": "Translate Ruby to C#: class Point\n  attr_accessor :x,:y\n  def initialize(x=0, y=0)\n    self.x = x\n    self.y = y\n  end\n  def to_s\n    \"Point at \n  end\nend\n\n\nclass Circle < Point\n  attr_accessor :r\n  def initialize(x=0, y=0, r=0)\n    self.x = x\n    self.y = y\n    self.r = r\n  end\n  def to_s\n    \"Circle at \n  end\nend\n", "target": "using System;\nclass Point\n{\n  protected int x, y;\n  public Point() : this(0) {}\n  public Point(int x) : this(x,0) {}\n  public Point(int x, int y) { this.x = x; this.y = y; }\n  public int X { get { return x; } set { x = value; } }\n  public int Y { get { return y; } set { y = value; } }\n  public virtual void print() { System.Console.WriteLine(\"Point\"); }\n}\n\npublic class Circle : Point\n{\n  private int r;\n  public Circle(Point p) : this(p,0) { }\n  public Circle(Point p, int r) : base(p) { this.r = r; }\n  public Circle() : this(0) { }\n  public Circle(int x) : this(x,0) { }\n  public Circle(int x, int y) : this(x,y,0) { }\n  public Circle(int x, int y, int r) : base(x,y) { this.r = r; }\n  public int R { get { return r; } set { r = value; } }\n  public override void print() { System.Console.WriteLine(\"Circle\"); }\n \n  public static void main(String args[])\n  {\n    Point p = new Point();\n    Point c = new Circle();\n    p.print();\n    c.print();\n  }\n}\n"}
{"id": 99410, "name": "Polymorphism", "source": "Translate Ruby to Java: class Point\n  attr_accessor :x,:y\n  def initialize(x=0, y=0)\n    self.x = x\n    self.y = y\n  end\n  def to_s\n    \"Point at \n  end\nend\n\n\nclass Circle < Point\n  attr_accessor :r\n  def initialize(x=0, y=0, r=0)\n    self.x = x\n    self.y = y\n    self.r = r\n  end\n  def to_s\n    \"Circle at \n  end\nend\n", "target": "class Point {\n   protected int x, y;\n   public Point() { this(0); }\n   public Point(int x) { this(x, 0); }\n   public Point(int x, int y) { this.x = x; this.y = y; }\n   public Point(Point p) { this(p.x, p.y); }\n   public int getX() { return this.x; }\n   public int getY() { return this.y; }\n   public void setX(int x) { this.x = x; }\n   public void setY(int y) { this.y = y; }\n   public void print() { System.out.println(\"Point x: \" + this.x + \" y: \" + this.y); }\n}\n\nclass Circle extends Point {\n   private int r;\n   public Circle(Point p) { this(p, 0); }\n   public Circle(Point p, int r) { super(p); this.r = r; }\n   public Circle() { this(0); }\n   public Circle(int x) { this(x, 0); }\n   public Circle(int x, int y) { this(x, y, 0); }\n   public Circle(int x, int y, int r) { super(x, y); this.r = r; }\n   public Circle(Circle c) { this(c.x, c.y, c.r); }\n   public int getR() { return this.r; }\n   public void setR(int r) { this.r = r; }\n   public void print() { System.out.println(\"Circle x: \" + this.x + \" y: \" + this.y + \" r: \" + this.r); }\n}\n\npublic class test {\n  public static void main(String args[]) {\n    Point p = new Point();\n    Point c = new Circle();\n    p.print();\n    c.print();     \n  }\n}\n"}
{"id": 99411, "name": "Polymorphism", "source": "Translate Ruby to Python: class Point\n  attr_accessor :x,:y\n  def initialize(x=0, y=0)\n    self.x = x\n    self.y = y\n  end\n  def to_s\n    \"Point at \n  end\nend\n\n\nclass Circle < Point\n  attr_accessor :r\n  def initialize(x=0, y=0, r=0)\n    self.x = x\n    self.y = y\n    self.r = r\n  end\n  def to_s\n    \"Circle at \n  end\nend\n", "target": "class Point(object):\n    def __init__(self, x=0.0, y=0.0):\n        self.x = x\n        self.y = y\n    def __repr__(self):\n        return '<Point 0x%x x: %f y: %f>' % (id(self), self.x, self.y)\n\nclass Circle(object):\n    def __init__(self, center=None, radius=1.0):\n        self.center = center or Point()\n        self.radius = radius\n    def __repr__(self):\n        return '<Circle 0x%x x: %f y: %f radius: %f>' % (\n            id(self), self.center.x, self.center.y, self.radius)\n"}
{"id": 99601, "name": "Semiprime", "source": "Translate Ruby to C#: def semiprime(n)\n  nf = 0\n  (2..n).each do |i|\n    while n % i == 0\n      return false if nf == 2\n      nf += 1\n      n  /= i\n    end\n  end\n  nf == 2\nend\n\n(1675..1681).each { |n| puts \"\n", "target": "static void Main(string[] args)\n{\n    \n    for (int i = 0; i < 50; i++)\n    {\n        Console.WriteLine(\"{0}\\t{1} \", i,isSemiPrime(i));\n    }\n    Console.ReadLine();\n}\n\n\nprivate static bool isSemiPrime(int c)\n{\n    int a = 2, b = 0;\n    while (b < 3 && c != 1)\n    {\n        if ((c % a) == 0)\n        {\n            c /= a;\n            b++;\n        }\n        else\n        {\n            a++;\n        };\n    }\n    return b == 2;\n}\n"}
{"id": 99603, "name": "Semiprime", "source": "Translate Ruby to Java: def semiprime(n)\n  nf = 0\n  (2..n).each do |i|\n    while n % i == 0\n      return false if nf == 2\n      nf += 1\n      n  /= i\n    end\n  end\n  nf == 2\nend\n\n(1675..1681).each { |n| puts \"\n", "target": "import java.math.BigInteger;\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class SemiPrime{\n\tprivate static final BigInteger TWO = BigInteger.valueOf(2);\n\t \n\tpublic static List<BigInteger> primeDecomp(BigInteger a){\n\t    \n\t    if(a.compareTo(TWO) < 0){\n\t        return null; \n\t    }\n\t \n\t    \n\t    List<BigInteger> result = new ArrayList<BigInteger>();\n\t    while(a.and(BigInteger.ONE).equals(BigInteger.ZERO)){\n\t        a = a.shiftRight(1);\n\t        result.add(TWO);\n\t    }\n\t \n\t    \n\t    if(!a.equals(BigInteger.ONE)){\n\t        BigInteger b = BigInteger.valueOf(3);\n\t        while(b.compareTo(a) < 0){\n\t            if(b.isProbablePrime(10)){\n\t                BigInteger[] dr = a.divideAndRemainder(b);\n\t                if(dr[1].equals(BigInteger.ZERO)){\n\t                    result.add(b);\n\t                    a = dr[0];\n\t                }\n\t            }\n\t            b = b.add(TWO);\n\t        }\n\t        result.add(b); \n\t    }\n\t    return result;\n\t}\n\t\n\tpublic static boolean isSemi(BigInteger x){\n\t\tList<BigInteger> decomp = primeDecomp(x);\n\t\treturn decomp != null && decomp.size() == 2;\n\t}\n\t\n\tpublic static void main(String[] args){\n\t\tfor(int i = 2; i <= 100; i++){\n\t\t\tif(isSemi(BigInteger.valueOf(i))){\n\t\t\t\tSystem.out.print(i + \" \");\n\t\t\t}\n\t\t}\n\t\tSystem.out.println();\n\t\tfor(int i = 1675; i <= 1680; i++){\n\t\t\tif(isSemi(BigInteger.valueOf(i))){\n\t\t\t\tSystem.out.print(i + \" \");\n\t\t\t}\n\t\t}\n\t}\n}\n"}
{"id": 99604, "name": "Semiprime", "source": "Translate Ruby to Python: def semiprime(n)\n  nf = 0\n  (2..n).each do |i|\n    while n % i == 0\n      return false if nf == 2\n      nf += 1\n      n  /= i\n    end\n  end\n  nf == 2\nend\n\n(1675..1681).each { |n| puts \"\n", "target": "from prime_decomposition import decompose\n\ndef semiprime(n):\n    d = decompose(n)\n    try:\n        return next(d) * next(d) == n\n    except StopIteration:\n        return False\n"}
{"id": 99884, "name": "Generate lower case ASCII alphabet", "source": "Translate Ruby to C#: p ('a' .. 'z').to_a\np [*'a' .. 'z']\n", "target": "using System;\nusing System.Linq;\n\ninternal class Program\n{\n    private static void Main()\n    {\n        Console.WriteLine(String.Concat(Enumerable.Range('a', 26).Select(c => (char)c)));\n    }\n}\n"}
{"id": 99886, "name": "Generate lower case ASCII alphabet", "source": "Translate Ruby to Java: p ('a' .. 'z').to_a\np [*'a' .. 'z']\n", "target": "public class LowerAscii {\n\n    public static void main(String[] args) {\n        StringBuilder sb = new StringBuilder(26);\n        for (char ch = 'a'; ch <= 'z'; ch++)\n            sb.append(ch);\n        System.out.printf(\"lower ascii: %s, length: %s\", sb, sb.length());\n    }\n}\n"}
{"id": 99887, "name": "Generate lower case ASCII alphabet", "source": "Translate Ruby to Python: p ('a' .. 'z').to_a\np [*'a' .. 'z']\n", "target": "\nfrom string import ascii_lowercase\n\n\nlower = [chr(i) for i in range(ord('a'), ord('z') + 1)]\n"}
{"id": 99993, "name": "Constrained genericity", "source": "Translate Ruby to C#: class Apple\n  def eat\n  end\nend\n\nclass Carrot\n  def eat\n  end\nend\n\nclass FoodBox(T)\n  def initialize(@data : Array(T))\n    {% if T.union? %}\n    {% raise \"All items should be eatable\" unless T.union_types.all? &.has_method?(:eat)\u00a0%}\n    {% else %}\n    {% raise \"Items should be eatable\" unless T.has_method?(:eat)\u00a0%}\n    {% end %}\n  end\nend\n\nFoodBox.new([Apple.new, Apple.new])\nFoodBox.new([Apple.new, Carrot.new])\nFoodBox.new([Apple.new, Carrot.new, 123])\n", "target": "interface IEatable\n{\n    void Eat();\n}\n"}
{"id": 99995, "name": "Constrained genericity", "source": "Translate Ruby to Java: class Apple\n  def eat\n  end\nend\n\nclass Carrot\n  def eat\n  end\nend\n\nclass FoodBox(T)\n  def initialize(@data : Array(T))\n    {% if T.union? %}\n    {% raise \"All items should be eatable\" unless T.union_types.all? &.has_method?(:eat)\u00a0%}\n    {% else %}\n    {% raise \"Items should be eatable\" unless T.has_method?(:eat)\u00a0%}\n    {% end %}\n  end\nend\n\nFoodBox.new([Apple.new, Apple.new])\nFoodBox.new([Apple.new, Carrot.new])\nFoodBox.new([Apple.new, Carrot.new, 123])\n", "target": "interface Eatable\n{\n    void eat();\n}\n"}
{"id": 100382, "name": "Compare a list of strings", "source": "Translate Ruby to C#: strings.uniq.one?                 \nstrings == strings.uniq.sort      \n", "target": "public static (bool lexicallyEqual, bool strictlyAscending) CompareAListOfStrings(List<string> strings) =>\n    strings.Count < 2 ? (true, true) :\n    (\n        strings.Distinct().Count() < 2,\n        Enumerable.Range(1, strings.Count - 1).All(i => string.Compare(strings[i-1], strings[i]) < 0)\n    );\n"}
{"id": 100383, "name": "Compare a list of strings", "source": "Translate Ruby to C#: strings.uniq.one?                 \nstrings == strings.uniq.sort      \n", "target": "public static (bool lexicallyEqual, bool strictlyAscending) CompareAListOfStrings(List<string> strings) =>\n    strings.Count < 2 ? (true, true) :\n    (\n        strings.Distinct().Count() < 2,\n        Enumerable.Range(1, strings.Count - 1).All(i => string.Compare(strings[i-1], strings[i]) < 0)\n    );\n"}
{"id": 100386, "name": "Compare a list of strings", "source": "Translate Ruby to Java: strings.uniq.one?                 \nstrings == strings.uniq.sort      \n", "target": "import java.util.Arrays;\n\npublic class CompareListOfStrings {\n\n    public static void main(String[] args) {\n        String[][] arr = {{\"AA\", \"AA\", \"AA\", \"AA\"}, {\"AA\", \"ACB\", \"BB\", \"CC\"}};\n        for (String[] a : arr) {\n            System.out.println(Arrays.toString(a));\n            System.out.println(Arrays.stream(a).distinct().count() < 2);\n            System.out.println(Arrays.equals(Arrays.stream(a).distinct().sorted().toArray(), a));\n        }\n    }\n}\n"}
{"id": 100387, "name": "Compare a list of strings", "source": "Translate Ruby to Java: strings.uniq.one?                 \nstrings == strings.uniq.sort      \n", "target": "import java.util.Arrays;\n\npublic class CompareListOfStrings {\n\n    public static void main(String[] args) {\n        String[][] arr = {{\"AA\", \"AA\", \"AA\", \"AA\"}, {\"AA\", \"ACB\", \"BB\", \"CC\"}};\n        for (String[] a : arr) {\n            System.out.println(Arrays.toString(a));\n            System.out.println(Arrays.stream(a).distinct().count() < 2);\n            System.out.println(Arrays.equals(Arrays.stream(a).distinct().sorted().toArray(), a));\n        }\n    }\n}\n"}
{"id": 100388, "name": "Compare a list of strings", "source": "Translate Ruby to Python: strings.uniq.one?                 \nstrings == strings.uniq.sort      \n", "target": "all(a == nexta for a, nexta in zip(strings, strings[1:])) \nall(a < nexta for a, nexta in zip(strings, strings[1:])) \n\nlen(set(strings)) == 1  \nsorted(strings, reverse=True) == strings  \n"}
{"id": 100389, "name": "Compare a list of strings", "source": "Translate Ruby to Python: strings.uniq.one?                 \nstrings == strings.uniq.sort      \n", "target": "all(a == nexta for a, nexta in zip(strings, strings[1:])) \nall(a < nexta for a, nexta in zip(strings, strings[1:])) \n\nlen(set(strings)) == 1  \nsorted(strings, reverse=True) == strings  \n"}
{"id": 100858, "name": "Roman numerals_Decode", "source": "Translate Ruby to C#: def fromRoman(roman)\n  r = roman.upcase\n  n = 0\n  until r.empty? do\n    case\n    when r.start_with?('M')  then v = 1000; len = 1\n    when r.start_with?('CM') then v = 900;  len = 2\n    when r.start_with?('D')  then v = 500;  len = 1\n    when r.start_with?('CD') then v = 400;  len = 2\n    when r.start_with?('C')  then v = 100;  len = 1\n    when r.start_with?('XC') then v = 90;   len = 2\n    when r.start_with?('L')  then v = 50;   len = 1\n    when r.start_with?('XL') then v = 40;   len = 2\n    when r.start_with?('X')  then v = 10;   len = 1\n    when r.start_with?('IX') then v = 9;    len = 2\n    when r.start_with?('V')  then v = 5;    len = 1\n    when r.start_with?('IV') then v = 4;    len = 2\n    when r.start_with?('I')  then v = 1;    len = 1\n    else\n      raise ArgumentError.new(\"invalid roman numerals: \" + roman)\n    end\n    n += v\n    r.slice!(0,len)\n  end\n  n\nend\n\n[ \"MCMXC\", \"MMVIII\", \"MDCLXVI\" ].each {|r| p r => fromRoman(r)}\n", "target": "using System;\nusing System.Collections.Generic;\n\nnamespace Roman\n{\n    internal class Program\n    {\n        private static void Main(string[] args)\n        {\n            \n            Console.WriteLine(\"{0}: {1}\", \"MCMXC\", Decode(\"MCMXC\"));\n            Console.WriteLine(\"{0}: {1}\", \"MMVIII\", Decode(\"MMVIII\"));\n            Console.WriteLine(\"{0}: {1}\", \"MDCLXVI\", Decode(\"MDCLXVI\"));\n        }\n\n        \n        private static readonly Dictionary<char, int> RomanDictionary = new Dictionary<char, int>\n                                                                            {\n                                                                                {'I', 1},\n                                                                                {'V', 5},\n                                                                                {'X', 10},\n                                                                                {'L', 50},\n                                                                                {'C', 100},\n                                                                                {'D', 500},\n                                                                                {'M', 1000}\n                                                                            };\n\n        private static int Decode(string roman)\n        {\n            \n            roman = roman.ToUpper();\n\n            \n            int total = 0, minus = 0;\n\n            for (int i = 0; i < roman.Length; i++) \n            {\n                \n                int thisNumeral = RomanDictionary[roman[i]] - minus;\n\n                \n                if (i >= roman.Length - 1 ||\n                    thisNumeral + minus >= RomanDictionary[roman[i + 1]])\n                {\n                    total += thisNumeral;\n                    minus = 0;\n                }\n                else\n                {\n                    minus = thisNumeral;\n                }\n            }\n\n            return total; \n        }\n    }\n}\n"}
{"id": 100859, "name": "Roman numerals_Decode", "source": "Translate Ruby to C#: def fromRoman(roman)\n  r = roman.upcase\n  n = 0\n  until r.empty? do\n    case\n    when r.start_with?('M')  then v = 1000; len = 1\n    when r.start_with?('CM') then v = 900;  len = 2\n    when r.start_with?('D')  then v = 500;  len = 1\n    when r.start_with?('CD') then v = 400;  len = 2\n    when r.start_with?('C')  then v = 100;  len = 1\n    when r.start_with?('XC') then v = 90;   len = 2\n    when r.start_with?('L')  then v = 50;   len = 1\n    when r.start_with?('XL') then v = 40;   len = 2\n    when r.start_with?('X')  then v = 10;   len = 1\n    when r.start_with?('IX') then v = 9;    len = 2\n    when r.start_with?('V')  then v = 5;    len = 1\n    when r.start_with?('IV') then v = 4;    len = 2\n    when r.start_with?('I')  then v = 1;    len = 1\n    else\n      raise ArgumentError.new(\"invalid roman numerals: \" + roman)\n    end\n    n += v\n    r.slice!(0,len)\n  end\n  n\nend\n\n[ \"MCMXC\", \"MMVIII\", \"MDCLXVI\" ].each {|r| p r => fromRoman(r)}\n", "target": "using System;\nusing System.Collections.Generic;\n\nnamespace Roman\n{\n    internal class Program\n    {\n        private static void Main(string[] args)\n        {\n            \n            Console.WriteLine(\"{0}: {1}\", \"MCMXC\", Decode(\"MCMXC\"));\n            Console.WriteLine(\"{0}: {1}\", \"MMVIII\", Decode(\"MMVIII\"));\n            Console.WriteLine(\"{0}: {1}\", \"MDCLXVI\", Decode(\"MDCLXVI\"));\n        }\n\n        \n        private static readonly Dictionary<char, int> RomanDictionary = new Dictionary<char, int>\n                                                                            {\n                                                                                {'I', 1},\n                                                                                {'V', 5},\n                                                                                {'X', 10},\n                                                                                {'L', 50},\n                                                                                {'C', 100},\n                                                                                {'D', 500},\n                                                                                {'M', 1000}\n                                                                            };\n\n        private static int Decode(string roman)\n        {\n            \n            roman = roman.ToUpper();\n\n            \n            int total = 0, minus = 0;\n\n            for (int i = 0; i < roman.Length; i++) \n            {\n                \n                int thisNumeral = RomanDictionary[roman[i]] - minus;\n\n                \n                if (i >= roman.Length - 1 ||\n                    thisNumeral + minus >= RomanDictionary[roman[i + 1]])\n                {\n                    total += thisNumeral;\n                    minus = 0;\n                }\n                else\n                {\n                    minus = thisNumeral;\n                }\n            }\n\n            return total; \n        }\n    }\n}\n"}
{"id": 100862, "name": "Roman numerals_Decode", "source": "Translate Ruby to Java: def fromRoman(roman)\n  r = roman.upcase\n  n = 0\n  until r.empty? do\n    case\n    when r.start_with?('M')  then v = 1000; len = 1\n    when r.start_with?('CM') then v = 900;  len = 2\n    when r.start_with?('D')  then v = 500;  len = 1\n    when r.start_with?('CD') then v = 400;  len = 2\n    when r.start_with?('C')  then v = 100;  len = 1\n    when r.start_with?('XC') then v = 90;   len = 2\n    when r.start_with?('L')  then v = 50;   len = 1\n    when r.start_with?('XL') then v = 40;   len = 2\n    when r.start_with?('X')  then v = 10;   len = 1\n    when r.start_with?('IX') then v = 9;    len = 2\n    when r.start_with?('V')  then v = 5;    len = 1\n    when r.start_with?('IV') then v = 4;    len = 2\n    when r.start_with?('I')  then v = 1;    len = 1\n    else\n      raise ArgumentError.new(\"invalid roman numerals: \" + roman)\n    end\n    n += v\n    r.slice!(0,len)\n  end\n  n\nend\n\n[ \"MCMXC\", \"MMVIII\", \"MDCLXVI\" ].each {|r| p r => fromRoman(r)}\n", "target": "\ngrammar ParseRN ;\n\noptions {\n\tlanguage = Java;\n}\n@members {\nint rnValue;\nint ONE;\n}\n\nparseRN:\t({rnValue = 0;} rn NEWLINE {System.out.println($rn.text + \" = \" + rnValue);})*\n\t;\n\t\nrn\t:\t(Thousand {rnValue += 1000;})* hundreds? tens? units?;\n\nhundreds:\t{ONE = 0;} (h9 | h5) {if (ONE > 3) System.out.println (\"Too many hundreds\");};\nh9\t:\tHundred {ONE += 1;} (FiveHund {rnValue += 400;}| Thousand {rnValue += 900;}|{rnValue += 100;} (Hundred {rnValue += 100; ONE += 1;})*);\nh5\t:\tFiveHund {rnValue += 500;} (Hundred {rnValue += 100; ONE += 1;})*;\n\ntens\t:\t{ONE = 0;} (t9 | t5) {if (ONE > 3) System.out.println (\"Too many tens\");};\nt9\t:\tTen {ONE += 1;} (Fifty {rnValue += 40;}| Hundred {rnValue += 90;}|{rnValue += 10;} (Ten {rnValue += 10; ONE += 1;})*);\nt5\t:\tFifty {rnValue += 50;} (Ten {rnValue += 10; ONE += 1;})*;\n\t\nunits\t:\t{ONE = 0;} (u9 | u5) {if (ONE > 3) System.out.println (\"Too many ones\");};\nu9\t:\tOne {ONE += 1;} (Five {rnValue += 4;}| Ten {rnValue += 9;}|{rnValue += 1;} (One {rnValue += 1; ONE += 1;})*);\nu5\t:\tFive {rnValue += 5;} (One {rnValue += 1; ONE += 1;})*;\n\t\nOne\t:\t'I';\nFive\t:\t'V';\nTen\t:\t'X';\nFifty\t:\t'L';\nHundred:\t'C';\nFiveHund:\t'D';\nThousand:\t'M' ;\nNEWLINE:\t'\\r'? '\\n' ;\n"}
{"id": 100863, "name": "Roman numerals_Decode", "source": "Translate Ruby to Java: def fromRoman(roman)\n  r = roman.upcase\n  n = 0\n  until r.empty? do\n    case\n    when r.start_with?('M')  then v = 1000; len = 1\n    when r.start_with?('CM') then v = 900;  len = 2\n    when r.start_with?('D')  then v = 500;  len = 1\n    when r.start_with?('CD') then v = 400;  len = 2\n    when r.start_with?('C')  then v = 100;  len = 1\n    when r.start_with?('XC') then v = 90;   len = 2\n    when r.start_with?('L')  then v = 50;   len = 1\n    when r.start_with?('XL') then v = 40;   len = 2\n    when r.start_with?('X')  then v = 10;   len = 1\n    when r.start_with?('IX') then v = 9;    len = 2\n    when r.start_with?('V')  then v = 5;    len = 1\n    when r.start_with?('IV') then v = 4;    len = 2\n    when r.start_with?('I')  then v = 1;    len = 1\n    else\n      raise ArgumentError.new(\"invalid roman numerals: \" + roman)\n    end\n    n += v\n    r.slice!(0,len)\n  end\n  n\nend\n\n[ \"MCMXC\", \"MMVIII\", \"MDCLXVI\" ].each {|r| p r => fromRoman(r)}\n", "target": "\ngrammar ParseRN ;\n\noptions {\n\tlanguage = Java;\n}\n@members {\nint rnValue;\nint ONE;\n}\n\nparseRN:\t({rnValue = 0;} rn NEWLINE {System.out.println($rn.text + \" = \" + rnValue);})*\n\t;\n\t\nrn\t:\t(Thousand {rnValue += 1000;})* hundreds? tens? units?;\n\nhundreds:\t{ONE = 0;} (h9 | h5) {if (ONE > 3) System.out.println (\"Too many hundreds\");};\nh9\t:\tHundred {ONE += 1;} (FiveHund {rnValue += 400;}| Thousand {rnValue += 900;}|{rnValue += 100;} (Hundred {rnValue += 100; ONE += 1;})*);\nh5\t:\tFiveHund {rnValue += 500;} (Hundred {rnValue += 100; ONE += 1;})*;\n\ntens\t:\t{ONE = 0;} (t9 | t5) {if (ONE > 3) System.out.println (\"Too many tens\");};\nt9\t:\tTen {ONE += 1;} (Fifty {rnValue += 40;}| Hundred {rnValue += 90;}|{rnValue += 10;} (Ten {rnValue += 10; ONE += 1;})*);\nt5\t:\tFifty {rnValue += 50;} (Ten {rnValue += 10; ONE += 1;})*;\n\t\nunits\t:\t{ONE = 0;} (u9 | u5) {if (ONE > 3) System.out.println (\"Too many ones\");};\nu9\t:\tOne {ONE += 1;} (Five {rnValue += 4;}| Ten {rnValue += 9;}|{rnValue += 1;} (One {rnValue += 1; ONE += 1;})*);\nu5\t:\tFive {rnValue += 5;} (One {rnValue += 1; ONE += 1;})*;\n\t\nOne\t:\t'I';\nFive\t:\t'V';\nTen\t:\t'X';\nFifty\t:\t'L';\nHundred:\t'C';\nFiveHund:\t'D';\nThousand:\t'M' ;\nNEWLINE:\t'\\r'? '\\n' ;\n"}
{"id": 100864, "name": "Roman numerals_Decode", "source": "Translate Ruby to Python: def fromRoman(roman)\n  r = roman.upcase\n  n = 0\n  until r.empty? do\n    case\n    when r.start_with?('M')  then v = 1000; len = 1\n    when r.start_with?('CM') then v = 900;  len = 2\n    when r.start_with?('D')  then v = 500;  len = 1\n    when r.start_with?('CD') then v = 400;  len = 2\n    when r.start_with?('C')  then v = 100;  len = 1\n    when r.start_with?('XC') then v = 90;   len = 2\n    when r.start_with?('L')  then v = 50;   len = 1\n    when r.start_with?('XL') then v = 40;   len = 2\n    when r.start_with?('X')  then v = 10;   len = 1\n    when r.start_with?('IX') then v = 9;    len = 2\n    when r.start_with?('V')  then v = 5;    len = 1\n    when r.start_with?('IV') then v = 4;    len = 2\n    when r.start_with?('I')  then v = 1;    len = 1\n    else\n      raise ArgumentError.new(\"invalid roman numerals: \" + roman)\n    end\n    n += v\n    r.slice!(0,len)\n  end\n  n\nend\n\n[ \"MCMXC\", \"MMVIII\", \"MDCLXVI\" ].each {|r| p r => fromRoman(r)}\n", "target": "_rdecode = dict(zip('MDCLXVI', (1000, 500, 100, 50, 10, 5, 1)))\n\ndef decode( roman ):\n    result = 0\n    for r, r1 in zip(roman, roman[1:]):\n        rd, rd1 = _rdecode[r], _rdecode[r1]\n        result += -rd if rd < rd1 else rd\n    return result + _rdecode[roman[-1]]\n\nif __name__ == '__main__':\n    for r in 'MCMXC MMVIII MDCLXVI'.split():\n        print( r, decode(r) )\n"}
{"id": 100865, "name": "Roman numerals_Decode", "source": "Translate Ruby to Python: def fromRoman(roman)\n  r = roman.upcase\n  n = 0\n  until r.empty? do\n    case\n    when r.start_with?('M')  then v = 1000; len = 1\n    when r.start_with?('CM') then v = 900;  len = 2\n    when r.start_with?('D')  then v = 500;  len = 1\n    when r.start_with?('CD') then v = 400;  len = 2\n    when r.start_with?('C')  then v = 100;  len = 1\n    when r.start_with?('XC') then v = 90;   len = 2\n    when r.start_with?('L')  then v = 50;   len = 1\n    when r.start_with?('XL') then v = 40;   len = 2\n    when r.start_with?('X')  then v = 10;   len = 1\n    when r.start_with?('IX') then v = 9;    len = 2\n    when r.start_with?('V')  then v = 5;    len = 1\n    when r.start_with?('IV') then v = 4;    len = 2\n    when r.start_with?('I')  then v = 1;    len = 1\n    else\n      raise ArgumentError.new(\"invalid roman numerals: \" + roman)\n    end\n    n += v\n    r.slice!(0,len)\n  end\n  n\nend\n\n[ \"MCMXC\", \"MMVIII\", \"MDCLXVI\" ].each {|r| p r => fromRoman(r)}\n", "target": "_rdecode = dict(zip('MDCLXVI', (1000, 500, 100, 50, 10, 5, 1)))\n\ndef decode( roman ):\n    result = 0\n    for r, r1 in zip(roman, roman[1:]):\n        rd, rd1 = _rdecode[r], _rdecode[r1]\n        result += -rd if rd < rd1 else rd\n    return result + _rdecode[roman[-1]]\n\nif __name__ == '__main__':\n    for r in 'MCMXC MMVIII MDCLXVI'.split():\n        print( r, decode(r) )\n"}
{"id": 101171, "name": "Euler method", "source": "Translate Ruby to C#: def euler(y, a, b, h)\n  a.step(b,h) do |t|\n    puts \"%7.3f %7.3f\" % [t,y]\n    y += h * yield(t,y)\n  end\nend\n\n[10, 5, 2].each do |step|\n  puts \"Step = \n  euler(100,0,100,step) {|time, temp| -0.07 * (temp - 20) }\n  puts\nend\n", "target": "using System;\n\nnamespace prog\n{\n\tclass MainClass\n\t{\n\t\tconst float T0 = 100f;\n\t\tconst float TR = 20f;\n\t\tconst float k = 0.07f;\n\t\treadonly static float[] delta_t = {2.0f,5.0f,10.0f};\n\t\tconst int n = 100;\n\t\t\n\t\tpublic delegate float func(float t);\n\t\tstatic float NewtonCooling(float t)\n\t\t{\n\t\t\treturn -k * (t-TR);\t\t\t\n\t\t}\n\t\t\n\t\tpublic static void Main (string[] args)\n\t\t{\n\t\t\tfunc f = new func(NewtonCooling); \n\t\t\tfor(int i=0; i<delta_t.Length; i++)\n\t\t\t{\n\t\t\t\tConsole.WriteLine(\"delta_t = \" + delta_t[i]);\n\t\t\t\tEuler(f,T0,n,delta_t[i]);\n\t\t\t}\n\t\t}\n\t\t\t\t\n\t\tpublic static void Euler(func f, float y, int n, float h)\n\t\t{\n\t\t\tfor(float x=0; x<=n; x+=h)\n\t\t\t{\n\t\t\t\tConsole.WriteLine(\"\\t\" + x + \"\\t\" + y);\n\t\t\t\ty += h * f(y);\t\n\t\t\t}\n\t\t}\n\t}\n}\n"}
{"id": 101173, "name": "Euler method", "source": "Translate Ruby to Java: def euler(y, a, b, h)\n  a.step(b,h) do |t|\n    puts \"%7.3f %7.3f\" % [t,y]\n    y += h * yield(t,y)\n  end\nend\n\n[10, 5, 2].each do |step|\n  puts \"Step = \n  euler(100,0,100,step) {|time, temp| -0.07 * (temp - 20) }\n  puts\nend\n", "target": "public class Euler {\n  private static void euler (Callable f, double y0, int a, int b, int h) {\n    int t = a;\n    double y = y0;\n    while (t < b) {\n      System.out.println (\"\" + t + \" \" + y);\n      t += h;\n      y += h * f.compute (t, y);\n    }\n    System.out.println (\"DONE\");\n  }\n\n  public static void main (String[] args) {\n    Callable cooling = new Cooling ();\n    int[] steps = {2, 5, 10};\n    for (int stepSize : steps) {\n      System.out.println (\"Step size: \" + stepSize);\n      euler (cooling, 100.0, 0, 100, stepSize);\n    }\n  }\n}\n\n\ninterface Callable {\n  public double compute (int time, double t);\n}\n\n\nclass Cooling implements Callable {\n  public double compute (int time, double t) {\n    return -0.07 * (t - 20);\n  }\n}\n"}
{"id": 101174, "name": "Euler method", "source": "Translate Ruby to Python: def euler(y, a, b, h)\n  a.step(b,h) do |t|\n    puts \"%7.3f %7.3f\" % [t,y]\n    y += h * yield(t,y)\n  end\nend\n\n[10, 5, 2].each do |step|\n  puts \"Step = \n  euler(100,0,100,step) {|time, temp| -0.07 * (temp - 20) }\n  puts\nend\n", "target": "def euler(f,y0,a,b,h):\n\tt,y = a,y0\n\twhile t <= b:\n\t\tprint \"%6.3f %6.3f\" % (t,y)\n\t\tt += h\n\t\ty += h * f(t,y)\n\ndef newtoncooling(time, temp):\n\treturn -0.07 * (temp - 20)\n\neuler(newtoncooling,100,0,100,10)\n"}
{"id": 101624, "name": "Horner's rule for polynomial evaluation", "source": "Translate Ruby to C#: def horner(coeffs, x)\n  coeffs.reverse.inject(0) {|acc, coeff| acc * x + coeff}\nend\np horner([-19, 7, -4, 6], 3)  \n", "target": "using System;\nusing System.Linq;\n\nclass Program\n{\n    static double Horner(double[] coefficients, double variable)\n    {\n        return coefficients.Reverse().Aggregate(\n                (accumulator, coefficient) => accumulator * variable + coefficient);\n    }\n\n    static void Main()\n    {\n        Console.WriteLine(Horner(new[] { -19.0, 7.0, -4.0, 6.0 }, 3.0));\n    }\n}\n"}
{"id": 101625, "name": "Horner's rule for polynomial evaluation", "source": "Translate Ruby to C#: def horner(coeffs, x)\n  coeffs.reverse.inject(0) {|acc, coeff| acc * x + coeff}\nend\np horner([-19, 7, -4, 6], 3)  \n", "target": "using System;\nusing System.Linq;\n\nclass Program\n{\n    static double Horner(double[] coefficients, double variable)\n    {\n        return coefficients.Reverse().Aggregate(\n                (accumulator, coefficient) => accumulator * variable + coefficient);\n    }\n\n    static void Main()\n    {\n        Console.WriteLine(Horner(new[] { -19.0, 7.0, -4.0, 6.0 }, 3.0));\n    }\n}\n"}
{"id": 101628, "name": "Horner's rule for polynomial evaluation", "source": "Translate Ruby to Java: def horner(coeffs, x)\n  coeffs.reverse.inject(0) {|acc, coeff| acc * x + coeff}\nend\np horner([-19, 7, -4, 6], 3)  \n", "target": "import java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\n\npublic class Horner {\n    public static void main(String[] args){\n        List<Double> coeffs = new ArrayList<Double>();\n        coeffs.add(-19.0);\n        coeffs.add(7.0);\n        coeffs.add(-4.0);\n        coeffs.add(6.0);\n        System.out.println(polyEval(coeffs, 3));\n    }\n\n    public static double polyEval(List<Double> coefficients, double x) {\n        Collections.reverse(coefficients);\n        Double accumulator = coefficients.get(0);\n        for (int i = 1; i < coefficients.size(); i++) {\n            accumulator = (accumulator * x) + (Double) coefficients.get(i);\n        }\n        return accumulator;\n    }\n}\n"}
{"id": 101629, "name": "Horner's rule for polynomial evaluation", "source": "Translate Ruby to Java: def horner(coeffs, x)\n  coeffs.reverse.inject(0) {|acc, coeff| acc * x + coeff}\nend\np horner([-19, 7, -4, 6], 3)  \n", "target": "import java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\n\npublic class Horner {\n    public static void main(String[] args){\n        List<Double> coeffs = new ArrayList<Double>();\n        coeffs.add(-19.0);\n        coeffs.add(7.0);\n        coeffs.add(-4.0);\n        coeffs.add(6.0);\n        System.out.println(polyEval(coeffs, 3));\n    }\n\n    public static double polyEval(List<Double> coefficients, double x) {\n        Collections.reverse(coefficients);\n        Double accumulator = coefficients.get(0);\n        for (int i = 1; i < coefficients.size(); i++) {\n            accumulator = (accumulator * x) + (Double) coefficients.get(i);\n        }\n        return accumulator;\n    }\n}\n"}
{"id": 101630, "name": "Horner's rule for polynomial evaluation", "source": "Translate Ruby to Python: def horner(coeffs, x)\n  coeffs.reverse.inject(0) {|acc, coeff| acc * x + coeff}\nend\np horner([-19, 7, -4, 6], 3)  \n", "target": ">>> def horner(coeffs, x):\n\tacc = 0\n\tfor c in reversed(coeffs):\n\t\tacc = acc * x + c\n\treturn acc\n\n>>> horner( (-19, 7, -4, 6), 3)\n128\n"}
{"id": 101631, "name": "Horner's rule for polynomial evaluation", "source": "Translate Ruby to Python: def horner(coeffs, x)\n  coeffs.reverse.inject(0) {|acc, coeff| acc * x + coeff}\nend\np horner([-19, 7, -4, 6], 3)  \n", "target": ">>> def horner(coeffs, x):\n\tacc = 0\n\tfor c in reversed(coeffs):\n\t\tacc = acc * x + c\n\treturn acc\n\n>>> horner( (-19, 7, -4, 6), 3)\n128\n"}
{"id": 101959, "name": "Matrix multiplication", "source": "Translate Ruby to C#: require 'matrix'\n\nMatrix[[1, 2],\n       [3, 4]] * Matrix[[-3, -8, 3],\n                        [-2,  1, 4]]\n", "target": "public class Matrix\n{\n\tint n;\n\tint m;\n\tdouble[,] a;\n\n\tpublic Matrix(int n, int m)\n\t{\n\t\tif (n <= 0 || m <= 0)\n\t\t\tthrow new ArgumentException(\"Matrix dimensions must be positive\");\n\t\tthis.n = n;\n\t\tthis.m = m;\n\t\ta = new double[n, m];\n\t}\n\n\t\n\tpublic double this[int i, int j]\n\t{\n\t\tget { return a[i - 1, j - 1]; }\n\t\tset { a[i - 1, j - 1] = value; }\n\t}\n\n\tpublic int N { get { return n; } }\n\tpublic int M { get { return m; } }\n\n\tpublic static Matrix operator*(Matrix _a, Matrix b)\n\t{\n\t\tint n = _a.N;\n\t\tint m = b.M;\n\t\tint l = _a.M;\n\t\tif (l != b.N)\n\t\t\tthrow new ArgumentException(\"Illegal matrix dimensions for multiplication. _a.M must be equal b.N\");\n\t\tMatrix result = new Matrix(_a.N, b.M);\n\t\tfor(int i = 0; i < n; i++)\n\t\t\tfor (int j = 0; j < m; j++)\n\t\t\t{\n\t\t\t\tdouble sum = 0.0;\n\t\t\t\tfor (int k = 0; k < l; k++)\n\t\t\t\t\tsum += _a.a[i, k]*b.a[k, j];\n\t\t\t\tresult.a[i, j] = sum;\n\t\t\t}\n\t\treturn result;\n\t}\n}\n"}
{"id": 101961, "name": "Matrix multiplication", "source": "Translate Ruby to Java: require 'matrix'\n\nMatrix[[1, 2],\n       [3, 4]] * Matrix[[-3, -8, 3],\n                        [-2,  1, 4]]\n", "target": "public static double[][] mult(double a[][], double b[][]){\n   if(a.length == 0) return new double[0][0];\n   if(a[0].length != b.length) return null; \n\n   int n = a[0].length;\n   int m = a.length;\n   int p = b[0].length;\n\n   double ans[][] = new double[m][p];\n\n   for(int i = 0;i < m;i++){\n      for(int j = 0;j < p;j++){\n         for(int k = 0;k < n;k++){\n            ans[i][j] += a[i][k] * b[k][j];\n         }\n      }\n   }\n   return ans;\n}\n"}
{"id": 101962, "name": "Matrix multiplication", "source": "Translate Ruby to Python: require 'matrix'\n\nMatrix[[1, 2],\n       [3, 4]] * Matrix[[-3, -8, 3],\n                        [-2,  1, 4]]\n", "target": "a=((1,  1,  1,   1), \n     (2,  4,  8,  16),\n     (3,  9, 27,  81),\n     (4, 16, 64, 256))\n\nb=((  4  , -3  ,  4/3.,  -1/4. ), \n     (-13/3., 19/4., -7/3.,  11/24.),\n     (  3/2., -2.  ,  7/6.,  -1/4. ),\n     ( -1/6.,  1/4., -1/6.,   1/24.))\n\n\n\ndef MatrixMul( mtx_a, mtx_b):\n    tpos_b = zip( *mtx_b)\n    rtn = [[ sum( ea*eb for ea,eb in zip(a,b)) for b in tpos_b] for a in mtx_a]\n    return rtn\n\n\nv = MatrixMul( a, b )\n\nprint 'v = ('\nfor r in v:\n    print '[', \n    for val in r:\n        print '%8.2f '%val, \n    print ']'\nprint ')'\n\n\nu = MatrixMul(b,a)\n\nprint 'u = '\nfor r in u:\n    print '[', \n    for val in r:\n        print '%8.2f '%val, \n    print ']'\nprint ')'\n"}
{"id": 102154, "name": "File modification time", "source": "Translate Ruby to C#: \nmodtime = File.mtime('filename')\n\n\nFile.utime(actime, mtime, 'path')\n\n\nFile.utime(File.atime('path'), mtime, 'path')\n\n\nFile.utime(nil, nil, 'path')\n", "target": "using System;\nusing System.IO;\n\nConsole.WriteLine(File.GetLastWriteTime(\"file.txt\"));\nFile.SetLastWriteTime(\"file.txt\", DateTime.Now);\n"}
{"id": 102156, "name": "File modification time", "source": "Translate Ruby to Java: \nmodtime = File.mtime('filename')\n\n\nFile.utime(actime, mtime, 'path')\n\n\nFile.utime(File.atime('path'), mtime, 'path')\n\n\nFile.utime(nil, nil, 'path')\n", "target": "import java.io.File;\nimport java.util.Date;\npublic class FileModificationTimeTest {\n   public static void test(String type, File file) {\n       long t = file.lastModified();\n       System.out.println(\"The following \" + type + \" called \" + file.getPath() +\n            (t == 0 ? \" does not exist.\" : \" was modified at \" + new Date(t).toString() )\n       );\n       System.out.println(\"The following \" + type + \" called \" + file.getPath() + \n            (!file.setLastModified(System.currentTimeMillis()) ? \" does not exist.\" : \" was modified to current time.\" )\n       );\n       System.out.println(\"The following \" + type + \" called \" + file.getPath() + \n            (!file.setLastModified(t) ? \" does not exist.\" : \" was modified to previous time.\" )\n       );\n   }\n   public static void main(String args[]) {\n       test(\"file\", new File(\"output.txt\"));\n       test(\"directory\", new File(\"docs\"));\n   }\n}\n"}
{"id": 102157, "name": "File modification time", "source": "Translate Ruby to Python: \nmodtime = File.mtime('filename')\n\n\nFile.utime(actime, mtime, 'path')\n\n\nFile.utime(File.atime('path'), mtime, 'path')\n\n\nFile.utime(nil, nil, 'path')\n", "target": "import os\n\n\nmodtime = os.path.getmtime('filename')\n\n\nos.utime('path', (actime, mtime))\n\n\nos.utime('path', (os.path.getatime('path'), mtime))\n\n\nos.utime('path', None)\n"}
{"id": 102376, "name": "Dragon curve", "source": "Translate Ruby to C#: Point = Struct.new(:x, :y)\nLine = Struct.new(:start, :stop)\n\nShoes.app(:width => 800, :height => 600, :resizable => false) do\n\n  def split_segments(n)\n    dir = 1\n    @segments = @segments.inject([]) do |new, l|\n      a, b, c, d = l.start.x, l.start.y, l.stop.x, l.stop.y\n\n      mid_x = a + (c-a)/2.0 - (d-b)/2.0*dir\n      mid_y = b + (d-b)/2.0 + (c-a)/2.0*dir\n      mid_p = Point.new(mid_x, mid_y)\n\n      dir *= -1\n      new << Line.new(l.start, mid_p)\n      new << Line.new(mid_p, l.stop)\n    end\n  end\n\n  @segments = [Line.new(Point.new(200,200), Point.new(600,200))]\n  15.times do |n|\n    info \"calculating frame \n    split_segments(n)\n  end\n\n  stack do\n    @segments.each do |l|\n      line l.start.x, l.start.y, l.stop.x, l.stop.y\n    end\n  end\nend\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Drawing;\nusing System.Drawing.Drawing2D;\nusing System.Windows.Forms;\n\npublic class DragonCurve : Form\n{\n    private List<int> turns;\n    private double startingAngle, side;\n\n    public DragonCurve(int iter)\n    {\n        Size = new Size(800, 600);\n        StartPosition = FormStartPosition.CenterScreen;\n        DoubleBuffered = true;\n        BackColor = Color.White;\n\n        startingAngle = -iter * (Math.PI / 4);\n        side = 400 / Math.Pow(2, iter / 2.0);\n\n        turns = getSequence(iter);\n    }\n\n    private List<int> getSequence(int iter)\n    {\n        var turnSequence = new List<int>();\n        for (int i = 0; i < iter; i++)\n        {\n            var copy = new List<int>(turnSequence);\n            copy.Reverse();\n            turnSequence.Add(1);\n            foreach (int turn in copy)\n            {\n                turnSequence.Add(-turn);\n            }\n        }\n        return turnSequence;\n    }\n\n    protected override void OnPaint(PaintEventArgs e)\n    {\n        base.OnPaint(e);\n        e.Graphics.SmoothingMode = SmoothingMode.AntiAlias;\n\n        double angle = startingAngle;\n        int x1 = 230, y1 = 350;\n        int x2 = x1 + (int)(Math.Cos(angle) * side);\n        int y2 = y1 + (int)(Math.Sin(angle) * side);\n        e.Graphics.DrawLine(Pens.Black, x1, y1, x2, y2);\n        x1 = x2;\n        y1 = y2;\n        foreach (int turn in turns)\n        {\n            angle += turn * (Math.PI / 2);\n            x2 = x1 + (int)(Math.Cos(angle) * side);\n            y2 = y1 + (int)(Math.Sin(angle) * side);\n            e.Graphics.DrawLine(Pens.Black, x1, y1, x2, y2);\n            x1 = x2;\n            y1 = y2;\n        }\n    }\n\n    [STAThread]\n    static void Main()\n    {\n        Application.Run(new DragonCurve(14));\n    }\n}\n"}
{"id": 102378, "name": "Dragon curve", "source": "Translate Ruby to Java: Point = Struct.new(:x, :y)\nLine = Struct.new(:start, :stop)\n\nShoes.app(:width => 800, :height => 600, :resizable => false) do\n\n  def split_segments(n)\n    dir = 1\n    @segments = @segments.inject([]) do |new, l|\n      a, b, c, d = l.start.x, l.start.y, l.stop.x, l.stop.y\n\n      mid_x = a + (c-a)/2.0 - (d-b)/2.0*dir\n      mid_y = b + (d-b)/2.0 + (c-a)/2.0*dir\n      mid_p = Point.new(mid_x, mid_y)\n\n      dir *= -1\n      new << Line.new(l.start, mid_p)\n      new << Line.new(mid_p, l.stop)\n    end\n  end\n\n  @segments = [Line.new(Point.new(200,200), Point.new(600,200))]\n  15.times do |n|\n    info \"calculating frame \n    split_segments(n)\n  end\n\n  stack do\n    @segments.each do |l|\n      line l.start.x, l.start.y, l.stop.x, l.stop.y\n    end\n  end\nend\n", "target": "import java.awt.Color;\nimport java.awt.Graphics;\nimport java.util.*;\nimport javax.swing.JFrame;\n\npublic class DragonCurve extends JFrame {\n\n    private List<Integer> turns;\n    private double startingAngle, side;\n\n    public DragonCurve(int iter) {\n        super(\"Dragon Curve\");\n        setBounds(100, 100, 800, 600);\n        setDefaultCloseOperation(EXIT_ON_CLOSE);\n        turns = getSequence(iter);\n        startingAngle = -iter * (Math.PI / 4);\n        side = 400 / Math.pow(2, iter / 2.);\n    }\n\n    public List<Integer> getSequence(int iterations) {\n        List<Integer> turnSequence = new ArrayList<Integer>();\n        for (int i = 0; i < iterations; i++) {\n            List<Integer> copy = new ArrayList<Integer>(turnSequence);\n            Collections.reverse(copy);\n            turnSequence.add(1);\n            for (Integer turn : copy) {\n                turnSequence.add(-turn);\n            }\n        }\n        return turnSequence;\n    }\n\n    @Override\n    public void paint(Graphics g) {\n        g.setColor(Color.BLACK);\n        double angle = startingAngle;\n        int x1 = 230, y1 = 350;\n        int x2 = x1 + (int) (Math.cos(angle) * side);\n        int y2 = y1 + (int) (Math.sin(angle) * side);\n        g.drawLine(x1, y1, x2, y2);\n        x1 = x2;\n        y1 = y2;\n        for (Integer turn : turns) {\n            angle += turn * (Math.PI / 2);\n            x2 = x1 + (int) (Math.cos(angle) * side);\n            y2 = y1 + (int) (Math.sin(angle) * side);\n            g.drawLine(x1, y1, x2, y2);\n            x1 = x2;\n            y1 = y2;\n        }\n    }\n\n    public static void main(String[] args) {\n        new DragonCurve(14).setVisible(true);\n    }\n}\n"}
{"id": 102379, "name": "Dragon curve", "source": "Translate Ruby to Python: Point = Struct.new(:x, :y)\nLine = Struct.new(:start, :stop)\n\nShoes.app(:width => 800, :height => 600, :resizable => false) do\n\n  def split_segments(n)\n    dir = 1\n    @segments = @segments.inject([]) do |new, l|\n      a, b, c, d = l.start.x, l.start.y, l.stop.x, l.stop.y\n\n      mid_x = a + (c-a)/2.0 - (d-b)/2.0*dir\n      mid_y = b + (d-b)/2.0 + (c-a)/2.0*dir\n      mid_p = Point.new(mid_x, mid_y)\n\n      dir *= -1\n      new << Line.new(l.start, mid_p)\n      new << Line.new(mid_p, l.stop)\n    end\n  end\n\n  @segments = [Line.new(Point.new(200,200), Point.new(600,200))]\n  15.times do |n|\n    info \"calculating frame \n    split_segments(n)\n  end\n\n  stack do\n    @segments.each do |l|\n      line l.start.x, l.start.y, l.stop.x, l.stop.y\n    end\n  end\nend\n", "target": "l = 3\nints = 13\n\ndef setup():\n  size(700, 600)\n  background(0, 0, 255)\n  translate(150, 100)\n  stroke(255)\n  turn_left(l, ints)\n  turn_right(l, ints)\n\ndef turn_right(l, ints):\n    if ints == 0:\n        line(0, 0, 0, -l)\n        translate(0, -l)\n    else:\n        turn_left(l, ints - 1)\n        rotate(radians(90))\n        turn_right(l, ints - 1)\n  \ndef turn_left(l, ints):\n    if ints == 0:\n        line(0, 0, 0, -l)\n        translate(0, -l)\n    else:\n        turn_left(l, ints - 1)\n        rotate(radians(-90))\n        turn_right(l, ints - 1)\n"}
{"id": 102605, "name": "Input loop", "source": "Translate Ruby to C#: stream = $stdin\nstream.each do |line|\n  \nend\n", "target": "using System;\nusing System.IO;\n\nclass Program\n{\n    static void Main(string[] args)\n    {\n        \n        \n\n        using (var b = new StreamReader(\"file.txt\"))\n        {\n            string line;\n            while ((line = b.ReadLine()) != null)\n                Console.WriteLine(line);\n        }\n    }\n}\n"}
{"id": 102607, "name": "Input loop", "source": "Translate Ruby to Java: stream = $stdin\nstream.each do |line|\n  \nend\n", "target": "import java.io.InputStream;\nimport java.util.Scanner;\n\npublic class InputLoop {\n    public static void main(String args[]) {\n        \n        InputStream source = System.in;\n\n        \n\n        Scanner in = new Scanner(source);\n        while(in.hasNext()){\n            String input = in.next(); \n\n            \n            System.out.println(input);\n        }\n    }\n}\n"}
{"id": 102608, "name": "Input loop", "source": "Translate Ruby to Python: stream = $stdin\nstream.each do |line|\n  \nend\n", "target": "while(True):\n      x = input(\"What is your age? \")\n      print(x)\n"}
{"id": 102873, "name": "Mandelbrot set", "source": "Translate Ruby to C#: require 'complex'\n\ndef mandelbrot(a)\n  Array.new(50).inject(0) { |z,c| z*z + a }\nend\n\n(1.0).step(-1,-0.05) do |y|\n  (-2.0).step(0.5,0.0315) do |x|\n    print mandelbrot(Complex(x,y)).abs < 2 ? '*' : ' '\n  end\n  puts\nend\n", "target": "using System;\nusing System.Drawing;\nusing System.Drawing.Imaging;\nusing System.Threading;\nusing System.Windows.Forms;\n\n\n\n\npublic class MandelbrotSetForm : Form\n{\n    const double MaxValueExtent = 2.0;\n    Thread thread;\n\n    static double CalcMandelbrotSetColor(ComplexNumber c)\n    {\n        \n        const int MaxIterations = 1000;\n        const double MaxNorm = MaxValueExtent * MaxValueExtent;\n\n        int iteration = 0;\n        ComplexNumber z = new ComplexNumber();\n        do\n        {\n            z = z * z + c;\n            iteration++;\n        } while (z.Norm() < MaxNorm && iteration < MaxIterations);\n        if (iteration < MaxIterations)\n            return (double)iteration / MaxIterations;\n        else\n            return 0; \n    }\n\n    static void GenerateBitmap(Bitmap bitmap)\n    {\n        double scale = 2 * MaxValueExtent / Math.Min(bitmap.Width, bitmap.Height);\n        for (int i = 0; i < bitmap.Height; i++)\n        {\n            double y = (bitmap.Height / 2 - i) * scale;\n            for (int j = 0; j < bitmap.Width; j++)\n            {\n                double x = (j - bitmap.Width / 2) * scale;\n                double color = CalcMandelbrotSetColor(new ComplexNumber(x, y));\n                bitmap.SetPixel(j, i, GetColor(color));\n            }\n        }\n    }\n\n    static Color GetColor(double value)\n    {\n        const double MaxColor = 256;\n        const double ContrastValue = 0.2;\n        return Color.FromArgb(0, 0,\n            (int)(MaxColor * Math.Pow(value, ContrastValue)));\n    }\n    \n    public MandelbrotSetForm()\n    {\n        \n        this.Text = \"Mandelbrot Set Drawing\";\n        this.BackColor = System.Drawing.Color.Black;\n        this.BackgroundImageLayout = System.Windows.Forms.ImageLayout.Stretch;\n        this.MaximizeBox = false;\n        this.StartPosition = FormStartPosition.CenterScreen;\n        this.FormBorderStyle = FormBorderStyle.FixedDialog;\n        this.ClientSize = new Size(640, 640);\n        this.Load += new System.EventHandler(this.MainForm_Load);\n    }\n\n    void MainForm_Load(object sender, EventArgs e)\n    {\n        thread = new Thread(thread_Proc);\n        thread.IsBackground = true;\n        thread.Start(this.ClientSize);\n    }\n\n    void thread_Proc(object args)\n    {\n        \n        Size size = (Size)args;\n        int width = 16;\n        while (width * 2 < size.Width)\n        {\n            int height = width * size.Height / size.Width;\n            Bitmap bitmap = new Bitmap(width, height, PixelFormat.Format24bppRgb);\n            GenerateBitmap(bitmap);\n            this.BeginInvoke(new SetNewBitmapDelegate(SetNewBitmap), bitmap);\n            width *= 2;\n            Thread.Sleep(200);\n        }\n        \n        Bitmap finalBitmap = new Bitmap(size.Width, size.Height, PixelFormat.Format24bppRgb);\n        GenerateBitmap(finalBitmap);\n        this.BeginInvoke(new SetNewBitmapDelegate(SetNewBitmap), finalBitmap);\n    }\n\n    void SetNewBitmap(Bitmap image)\n    {\n        if (this.BackgroundImage != null)\n            this.BackgroundImage.Dispose();\n        this.BackgroundImage = image;\n    }\n\n    delegate void SetNewBitmapDelegate(Bitmap image);\n\n    static void Main()\n    {\n        Application.Run(new MandelbrotSetForm());\n    }\n}\n\nstruct ComplexNumber\n{\n    public double Re;\n    public double Im;\n\n    public ComplexNumber(double re, double im)\n    {\n        this.Re = re;\n        this.Im = im;\n    }\n\n    public static ComplexNumber operator +(ComplexNumber x, ComplexNumber y)\n    {\n        return new ComplexNumber(x.Re + y.Re, x.Im + y.Im);\n    }\n\n    public static ComplexNumber operator *(ComplexNumber x, ComplexNumber y)\n    {\n        return new ComplexNumber(x.Re * y.Re - x.Im * y.Im,\n            x.Re * y.Im + x.Im * y.Re);\n    }\n\n    public double Norm()\n    {\n        return Re * Re + Im * Im;\n    }\n}\n"}
{"id": 102875, "name": "Mandelbrot set", "source": "Translate Ruby to Java: require 'complex'\n\ndef mandelbrot(a)\n  Array.new(50).inject(0) { |z,c| z*z + a }\nend\n\n(1.0).step(-1,-0.05) do |y|\n  (-2.0).step(0.5,0.0315) do |x|\n    print mandelbrot(Complex(x,y)).abs < 2 ? '*' : ' '\n  end\n  puts\nend\n", "target": "import java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport javax.swing.JFrame;\n\npublic class Mandelbrot extends JFrame {\n\n    private final int MAX_ITER = 570;\n    private final double ZOOM = 150;\n    private BufferedImage I;\n    private double zx, zy, cX, cY, tmp;\n\n    public Mandelbrot() {\n        super(\"Mandelbrot Set\");\n        setBounds(100, 100, 800, 600);\n        setResizable(false);\n        setDefaultCloseOperation(EXIT_ON_CLOSE);\n        I = new BufferedImage(getWidth(), getHeight(), BufferedImage.TYPE_INT_RGB);\n        for (int y = 0; y < getHeight(); y++) {\n            for (int x = 0; x < getWidth(); x++) {\n                zx = zy = 0;\n                cX = (x - 400) / ZOOM;\n                cY = (y - 300) / ZOOM;\n                int iter = MAX_ITER;\n                while (zx * zx + zy * zy < 4 && iter > 0) {\n                    tmp = zx * zx - zy * zy + cX;\n                    zy = 2.0 * zx * zy + cY;\n                    zx = tmp;\n                    iter--;\n                }\n                I.setRGB(x, y, iter | (iter << 8));\n            }\n        }\n    }\n\n    @Override\n    public void paint(Graphics g) {\n        g.drawImage(I, 0, 0, this);\n    }\n\n    public static void main(String[] args) {\n        new Mandelbrot().setVisible(true);\n    }\n}\n"}
{"id": 102876, "name": "Mandelbrot set", "source": "Translate Ruby to Python: require 'complex'\n\ndef mandelbrot(a)\n  Array.new(50).inject(0) { |z,c| z*z + a }\nend\n\n(1.0).step(-1,-0.05) do |y|\n  (-2.0).step(0.5,0.0315) do |x|\n    print mandelbrot(Complex(x,y)).abs < 2 ? '*' : ' '\n  end\n  puts\nend\n", "target": "i = di = dj = 0\nfn1, fn2, fn3 = random(20), random(20), random(20)\nf = 10\n    \ndef setup():\n    global zmx1, zmx2, zmy1, zmy2\n    size(500, 500)\n    zmx1 = int(width / 4)\n    zmx2 = 2\n    zmy1 = int(height / 4)\n    zmy2 = 2\n\n\ndef draw():\n    global i\n\n    if i <= width:\n        i += 1\n    x = float(i + di) / zmx1 - zmx2\n    for j in range(height + 1):\n        y = zmy2 - float(j + dj) / zmy1\n        zr = zi = zr2 = zi2 = 0\n        cr, ci = x, y\n        n = 1\n        while n < 200 and (zr2 + zi2) < 4:\n            zi2 = zi * zi\n            zr2 = zr * zr\n            zi = 2 * zi * zr + ci\n            zr = zr2 - zi2 + cr\n            n += 1\n\n        re = (n * fn1) % 255\n        gr = (n * fn2) % 255\n        bl = (n * fn3) % 255\n        stroke(re, gr, bl)\n        point(i, j)\n\n\ndef mousePressed():\n    global zmx1, zmx2, zmy1, zmy2, di, dj\n    global i, j\n    background(200)\n    xt, yt = mouseX, mouseY\n    di = di + xt - width / 2.\n    dj = dj + yt - height / 2.\n    zmx1 = zmx1 * f\n    zmx2 = zmx2 * (1. / f)\n    zmy1 = zmy1 * f\n    zmy2 = zmy2 * (1. / f)\n    di, dj = di * f, dj * f\n    i = j = 0\n"}
{"id": 103150, "name": "Anagrams", "source": "Translate Ruby to C#: require \"http/client\"\n\nresponse = HTTP::Client.get(\"http://wiki.puzzlers.org/pub/wordlists/unixdict.txt\")\n\nif response.body?\n  words : Array(String) = response.body.split\n\n  anagram = {} of String => Array(String)\n\n  words.each do |word|\n    key = word.split(\"\").sort.join\n\n    if !anagram[key]?\n      anagram[key] = [word]\n    else\n      anagram[key] << word\n    end\n  end\n\n  count = anagram.values.map { |ana| ana.size }.max\n  anagram.each_value { |ana| puts ana if ana.size >= count }\nend\n", "target": "using System;\nusing System.IO;\nusing System.Linq;\nusing System.Net;\nusing System.Text.RegularExpressions;\n\nnamespace Anagram\n{\n    class Program\n    {\n        const string DICO_URL = \"http:\n\n        static void Main( string[] args )\n        {\n            WebRequest request = WebRequest.Create(DICO_URL);\n            string[] words;\n            using (StreamReader sr = new StreamReader(request.GetResponse().GetResponseStream(), true)) {\n                words = Regex.Split(sr.ReadToEnd(), @\"\\r?\\n\");\n            }\n            var groups = from string w in words\n                         group w by string.Concat(w.OrderBy(x => x)) into c\n                         group c by c.Count() into d\n                         orderby d.Key descending\n                         select d;\n            foreach (var c in groups.First()) {\n                Console.WriteLine(string.Join(\" \", c));\n            }\n        }\n    }\n}\n"}
{"id": 103152, "name": "Anagrams", "source": "Translate Ruby to Java: require \"http/client\"\n\nresponse = HTTP::Client.get(\"http://wiki.puzzlers.org/pub/wordlists/unixdict.txt\")\n\nif response.body?\n  words : Array(String) = response.body.split\n\n  anagram = {} of String => Array(String)\n\n  words.each do |word|\n    key = word.split(\"\").sort.join\n\n    if !anagram[key]?\n      anagram[key] = [word]\n    else\n      anagram[key] << word\n    end\n  end\n\n  count = anagram.values.map { |ana| ana.size }.max\n  anagram.each_value { |ana| puts ana if ana.size >= count }\nend\n", "target": "import java.net.*;\nimport java.io.*;\nimport java.util.*;\n \npublic class WordsOfEqChars {\n    public static void main(String[] args) throws IOException {\n        URL url = new URL(\"http:\n        InputStreamReader isr = new InputStreamReader(url.openStream());\n        BufferedReader reader = new BufferedReader(isr);\n\n        Map<String, Collection<String>> anagrams = new HashMap<String, Collection<String>>();\n        String word;\n        int count = 0;\n        while ((word = reader.readLine()) != null) {\n            char[] chars = word.toCharArray();\n            Arrays.sort(chars);\n            String key = new String(chars);\n            if (!anagrams.containsKey(key))\n                anagrams.put(key, new ArrayList<String>());\n            anagrams.get(key).add(word);\n            count = Math.max(count, anagrams.get(key).size());\n        }\n\n        reader.close();\n\n        for (Collection<String> ana : anagrams.values())\n            if (ana.size() >= count)\n                System.out.println(ana);\n    }   \n}\n"}
{"id": 103153, "name": "Anagrams", "source": "Translate Ruby to Python: require \"http/client\"\n\nresponse = HTTP::Client.get(\"http://wiki.puzzlers.org/pub/wordlists/unixdict.txt\")\n\nif response.body?\n  words : Array(String) = response.body.split\n\n  anagram = {} of String => Array(String)\n\n  words.each do |word|\n    key = word.split(\"\").sort.join\n\n    if !anagram[key]?\n      anagram[key] = [word]\n    else\n      anagram[key] << word\n    end\n  end\n\n  count = anagram.values.map { |ana| ana.size }.max\n  anagram.each_value { |ana| puts ana if ana.size >= count }\nend\n", "target": ">>> import urllib.request\n>>> from collections import defaultdict\n>>> words = urllib.request.urlopen('http://wiki.puzzlers.org/pub/wordlists/unixdict.txt').read().split()\n>>> anagram = defaultdict(list) \n>>> for word in words:\n\tanagram[tuple(sorted(word))].append( word )\n\n\t\n>>> count = max(len(ana) for ana in anagram.values())\n>>> for ana in anagram.values():\n\tif len(ana) >= count:\n\t\tprint ([x.decode() for x in ana])\n"}
{"id": 103445, "name": "Draw a clock", "source": "Translate Ruby to C#: Shoes.app(:width=>205, :height => 228, :title => \"A Clock\") do\n  def draw_ray(width, start, stop, ratio)\n    angle = Math::PI * 2 * ratio - Math::PI/2\n    strokewidth width\n    cos = Math::cos(angle)\n    sin = Math::sin(angle)\n    line 101+cos*start, 101+sin*start, 101+cos*stop, 101+sin*stop\n  end\n\n  def update\n    t = Time.now\n    @time.text = t.strftime(\"%H:%M:%S\")\n    h, m, s = (t.hour % 12).to_f, t.min.to_f, t.sec.to_f\n    s += t.to_f - t.to_i  \n\n    @hands.clear do\n      draw_ray(3, 0, 70, (h + m/60)/12)\n      draw_ray(2, 0, 90, (m + s/60)/60)\n      draw_ray(1, 0, 95, s/60)\n    end\n  end\n\n  \n  @time = para(:align=>\"center\", :family => \"monospace\")\n\n  \n  stack(:width=>203, :height=>203) do\n    strokewidth 1\n    fill gradient(deepskyblue, aqua)\n    oval 1, 1, 200\n    fill black\n    oval 98, 98, 6\n    \n    0.upto(59) {|m| draw_ray(1, (m % 5 == 0 ? 96 : 98), 100, m.to_f/60)}\n  end.move(0,23)\n\n  \n  @hands = stack(:width=>203, :height=>203) {}.move(0,23)\n\n  animate(5) {update}\nend\n", "target": "using System;\nusing System.Drawing;\nusing System.Drawing.Drawing2D;\nusing System.Windows.Forms;\n\npublic class Clock : Form\n{\n    static readonly float degrees06 = (float)Math.PI / 30;\n    static readonly float degrees30 = degrees06 * 5;\n    static readonly float degrees90 = degrees30 * 3;\n\n    readonly int margin = 20;\n\n    private Point p0;\n\n    public Clock()\n    {\n        Size = new Size(500, 500);\n        StartPosition = FormStartPosition.CenterScreen;\n        Resize += (sender, args) => ResetSize();\n        ResetSize();\n        var timer = new Timer() { Interval = 1000, Enabled = true };\n        timer.Tick += (sender, e) => Refresh();\n        DoubleBuffered = true;\n    }\n\n    private void ResetSize()\n    {\n        p0 = new Point(ClientRectangle.Width / 2, ClientRectangle.Height / 2);\n        Refresh();\n    }\n\n    protected override void OnPaint(PaintEventArgs e)\n    {\n        base.OnPaint(e);\n        e.Graphics.SmoothingMode = SmoothingMode.AntiAlias;\n\n        drawFace(e.Graphics);\n\n        var time = DateTime.Now;\n        int second = time.Second;\n        int minute = time.Minute;\n        int hour = time.Hour;\n\n        float angle = degrees90 - (degrees06 * second);\n        DrawHand(e.Graphics, Pens.Red, angle, 0.95);\n\n        float minsecs = (minute + second / 60.0F);\n        angle = degrees90 - (degrees06 * minsecs);\n        DrawHand(e.Graphics, Pens.Black, angle, 0.9);\n\n        float hourmins = (hour + minsecs / 60.0F);\n        angle = degrees90 - (degrees30 * hourmins);\n        DrawHand(e.Graphics, Pens.Black, angle, 0.6);\n    }\n\n    private void drawFace(Graphics g)\n    {\n        int radius = Math.Min(p0.X, p0.Y) - margin;\n        g.FillEllipse(Brushes.White, p0.X - radius, p0.Y - radius, radius * 2, radius * 2);\n\n        for (int h = 0; h < 12; h++)\n            DrawHand(g, Pens.LightGray, h * degrees30, -0.05);\n\n        for (int m = 0; m < 60; m++)\n            DrawHand(g, Pens.LightGray, m * degrees06, -0.025);\n    }\n\n    private void DrawHand(Graphics g, Pen pen, float angle, double size)\n    {\n        int radius = Math.Min(p0.X, p0.Y) - margin;\n\n        int x0 = p0.X + (size > 0 ? 0 : Convert.ToInt32(radius * (1 + size) * Math.Cos(angle)));\n        int y0 = p0.Y + (size > 0 ? 0 : Convert.ToInt32(radius * (1 + size) * Math.Sin(-angle)));\n\n        int x1 = p0.X + Convert.ToInt32(radius * (size > 0 ? size : 1) * Math.Cos(angle));\n        int y1 = p0.Y + Convert.ToInt32(radius * (size > 0 ? size : 1) * Math.Sin(-angle));\n\n        g.DrawLine(pen, x0, y0, x1, y1);\n    }\n\n    [STAThread]\n    static void Main()\n    {\n        Application.Run(new Clock());\n    }\n}\n"}
{"id": 103446, "name": "Draw a clock", "source": "Translate Ruby to C#: Shoes.app(:width=>205, :height => 228, :title => \"A Clock\") do\n  def draw_ray(width, start, stop, ratio)\n    angle = Math::PI * 2 * ratio - Math::PI/2\n    strokewidth width\n    cos = Math::cos(angle)\n    sin = Math::sin(angle)\n    line 101+cos*start, 101+sin*start, 101+cos*stop, 101+sin*stop\n  end\n\n  def update\n    t = Time.now\n    @time.text = t.strftime(\"%H:%M:%S\")\n    h, m, s = (t.hour % 12).to_f, t.min.to_f, t.sec.to_f\n    s += t.to_f - t.to_i  \n\n    @hands.clear do\n      draw_ray(3, 0, 70, (h + m/60)/12)\n      draw_ray(2, 0, 90, (m + s/60)/60)\n      draw_ray(1, 0, 95, s/60)\n    end\n  end\n\n  \n  @time = para(:align=>\"center\", :family => \"monospace\")\n\n  \n  stack(:width=>203, :height=>203) do\n    strokewidth 1\n    fill gradient(deepskyblue, aqua)\n    oval 1, 1, 200\n    fill black\n    oval 98, 98, 6\n    \n    0.upto(59) {|m| draw_ray(1, (m % 5 == 0 ? 96 : 98), 100, m.to_f/60)}\n  end.move(0,23)\n\n  \n  @hands = stack(:width=>203, :height=>203) {}.move(0,23)\n\n  animate(5) {update}\nend\n", "target": "using System;\nusing System.Drawing;\nusing System.Drawing.Drawing2D;\nusing System.Windows.Forms;\n\npublic class Clock : Form\n{\n    static readonly float degrees06 = (float)Math.PI / 30;\n    static readonly float degrees30 = degrees06 * 5;\n    static readonly float degrees90 = degrees30 * 3;\n\n    readonly int margin = 20;\n\n    private Point p0;\n\n    public Clock()\n    {\n        Size = new Size(500, 500);\n        StartPosition = FormStartPosition.CenterScreen;\n        Resize += (sender, args) => ResetSize();\n        ResetSize();\n        var timer = new Timer() { Interval = 1000, Enabled = true };\n        timer.Tick += (sender, e) => Refresh();\n        DoubleBuffered = true;\n    }\n\n    private void ResetSize()\n    {\n        p0 = new Point(ClientRectangle.Width / 2, ClientRectangle.Height / 2);\n        Refresh();\n    }\n\n    protected override void OnPaint(PaintEventArgs e)\n    {\n        base.OnPaint(e);\n        e.Graphics.SmoothingMode = SmoothingMode.AntiAlias;\n\n        drawFace(e.Graphics);\n\n        var time = DateTime.Now;\n        int second = time.Second;\n        int minute = time.Minute;\n        int hour = time.Hour;\n\n        float angle = degrees90 - (degrees06 * second);\n        DrawHand(e.Graphics, Pens.Red, angle, 0.95);\n\n        float minsecs = (minute + second / 60.0F);\n        angle = degrees90 - (degrees06 * minsecs);\n        DrawHand(e.Graphics, Pens.Black, angle, 0.9);\n\n        float hourmins = (hour + minsecs / 60.0F);\n        angle = degrees90 - (degrees30 * hourmins);\n        DrawHand(e.Graphics, Pens.Black, angle, 0.6);\n    }\n\n    private void drawFace(Graphics g)\n    {\n        int radius = Math.Min(p0.X, p0.Y) - margin;\n        g.FillEllipse(Brushes.White, p0.X - radius, p0.Y - radius, radius * 2, radius * 2);\n\n        for (int h = 0; h < 12; h++)\n            DrawHand(g, Pens.LightGray, h * degrees30, -0.05);\n\n        for (int m = 0; m < 60; m++)\n            DrawHand(g, Pens.LightGray, m * degrees06, -0.025);\n    }\n\n    private void DrawHand(Graphics g, Pen pen, float angle, double size)\n    {\n        int radius = Math.Min(p0.X, p0.Y) - margin;\n\n        int x0 = p0.X + (size > 0 ? 0 : Convert.ToInt32(radius * (1 + size) * Math.Cos(angle)));\n        int y0 = p0.Y + (size > 0 ? 0 : Convert.ToInt32(radius * (1 + size) * Math.Sin(-angle)));\n\n        int x1 = p0.X + Convert.ToInt32(radius * (size > 0 ? size : 1) * Math.Cos(angle));\n        int y1 = p0.Y + Convert.ToInt32(radius * (size > 0 ? size : 1) * Math.Sin(-angle));\n\n        g.DrawLine(pen, x0, y0, x1, y1);\n    }\n\n    [STAThread]\n    static void Main()\n    {\n        Application.Run(new Clock());\n    }\n}\n"}
{"id": 103449, "name": "Draw a clock", "source": "Translate Ruby to Java: Shoes.app(:width=>205, :height => 228, :title => \"A Clock\") do\n  def draw_ray(width, start, stop, ratio)\n    angle = Math::PI * 2 * ratio - Math::PI/2\n    strokewidth width\n    cos = Math::cos(angle)\n    sin = Math::sin(angle)\n    line 101+cos*start, 101+sin*start, 101+cos*stop, 101+sin*stop\n  end\n\n  def update\n    t = Time.now\n    @time.text = t.strftime(\"%H:%M:%S\")\n    h, m, s = (t.hour % 12).to_f, t.min.to_f, t.sec.to_f\n    s += t.to_f - t.to_i  \n\n    @hands.clear do\n      draw_ray(3, 0, 70, (h + m/60)/12)\n      draw_ray(2, 0, 90, (m + s/60)/60)\n      draw_ray(1, 0, 95, s/60)\n    end\n  end\n\n  \n  @time = para(:align=>\"center\", :family => \"monospace\")\n\n  \n  stack(:width=>203, :height=>203) do\n    strokewidth 1\n    fill gradient(deepskyblue, aqua)\n    oval 1, 1, 200\n    fill black\n    oval 98, 98, 6\n    \n    0.upto(59) {|m| draw_ray(1, (m % 5 == 0 ? 96 : 98), 100, m.to_f/60)}\n  end.move(0,23)\n\n  \n  @hands = stack(:width=>203, :height=>203) {}.move(0,23)\n\n  animate(5) {update}\nend\n", "target": "import java.awt.*;\nimport java.awt.event.*;\nimport static java.lang.Math.*;\nimport java.time.LocalTime;\nimport javax.swing.*;\n\nclass Clock extends JPanel {\n\n    final float degrees06 = (float) (PI / 30);\n    final float degrees30 = degrees06 * 5;\n    final float degrees90 = degrees30 * 3;\n\n    final int size = 590;\n    final int spacing = 40;\n    final int diameter = size - 2 * spacing;\n    final int cx = diameter / 2 + spacing;\n    final int cy = diameter / 2 + spacing;\n\n    public Clock() {\n        setPreferredSize(new Dimension(size, size));\n        setBackground(Color.white);\n\n        new Timer(1000, (ActionEvent e) -> {\n            repaint();\n        }).start();\n    }\n\n    @Override\n    public void paintComponent(Graphics gg) {\n        super.paintComponent(gg);\n        Graphics2D g = (Graphics2D) gg;\n        g.setRenderingHint(RenderingHints.KEY_ANTIALIASING,\n                RenderingHints.VALUE_ANTIALIAS_ON);\n\n        drawFace(g);\n\n        final LocalTime time  = LocalTime.now();\n        int hour = time.getHour();\n        int minute = time.getMinute();\n        int second = time.getSecond();\n\n        float angle = degrees90 - (degrees06 * second);\n        drawHand(g, angle, diameter / 2 - 30, Color.red);\n\n        float minsecs = (minute + second / 60.0F);\n        angle = degrees90 - (degrees06 * minsecs);\n        drawHand(g, angle, diameter / 3 + 10, Color.black);\n\n        float hourmins = (hour + minsecs / 60.0F);\n        angle = degrees90 - (degrees30 * hourmins);\n        drawHand(g, angle, diameter / 4 + 10, Color.black);\n    }\n\n    private void drawFace(Graphics2D g) {\n        g.setStroke(new BasicStroke(2));\n        g.setColor(Color.white);\n        g.fillOval(spacing, spacing, diameter, diameter);\n        g.setColor(Color.black);\n        g.drawOval(spacing, spacing, diameter, diameter);\n    }\n\n    private void drawHand(Graphics2D g, float angle, int radius, Color color) {\n        int x = cx + (int) (radius * cos(angle));\n        int y = cy - (int) (radius * sin(angle));\n        g.setColor(color);\n        g.drawLine(cx, cy, x, y);\n    }\n\n    public static void main(String[] args) {\n        SwingUtilities.invokeLater(() -> {\n            JFrame f = new JFrame();\n            f.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n            f.setTitle(\"Clock\");\n            f.setResizable(false);\n            f.add(new Clock(), BorderLayout.CENTER);\n            f.pack();\n            f.setLocationRelativeTo(null);\n            f.setVisible(true);\n        });\n    }\n}\n"}
{"id": 103450, "name": "Draw a clock", "source": "Translate Ruby to Python: Shoes.app(:width=>205, :height => 228, :title => \"A Clock\") do\n  def draw_ray(width, start, stop, ratio)\n    angle = Math::PI * 2 * ratio - Math::PI/2\n    strokewidth width\n    cos = Math::cos(angle)\n    sin = Math::sin(angle)\n    line 101+cos*start, 101+sin*start, 101+cos*stop, 101+sin*stop\n  end\n\n  def update\n    t = Time.now\n    @time.text = t.strftime(\"%H:%M:%S\")\n    h, m, s = (t.hour % 12).to_f, t.min.to_f, t.sec.to_f\n    s += t.to_f - t.to_i  \n\n    @hands.clear do\n      draw_ray(3, 0, 70, (h + m/60)/12)\n      draw_ray(2, 0, 90, (m + s/60)/60)\n      draw_ray(1, 0, 95, s/60)\n    end\n  end\n\n  \n  @time = para(:align=>\"center\", :family => \"monospace\")\n\n  \n  stack(:width=>203, :height=>203) do\n    strokewidth 1\n    fill gradient(deepskyblue, aqua)\n    oval 1, 1, 200\n    fill black\n    oval 98, 98, 6\n    \n    0.upto(59) {|m| draw_ray(1, (m % 5 == 0 ? 96 : 98), 100, m.to_f/60)}\n  end.move(0,23)\n\n  \n  @hands = stack(:width=>203, :height=>203) {}.move(0,23)\n\n  animate(5) {update}\nend\n", "target": "last_sec = second()\n\ndef draw():\n    global last_sec\n    if last_sec != second():\n        draw_clock()\n        last_sec = second()\n\ndef draw_clock():\n    background(192)\n    translate(width / 2, height / 2)\n    s = second() * TWO_PI / 60.0\n    m = minute() * TWO_PI / 60.0\n    h = hour() * TWO_PI / 12.0\n    rotate(s)\n    strokeWeight(1)\n    line(0, 0, 0, -width * 0.5)\n    rotate(-s + m)\n    strokeWeight(2)\n    line(0, 0, 0, -width * 0.4)\n    rotate(-m + h)\n    strokeWeight(4)\n    line(0, 0, 0, -width * 0.2)\n"}
{"id": 103451, "name": "Draw a clock", "source": "Translate Ruby to Python: Shoes.app(:width=>205, :height => 228, :title => \"A Clock\") do\n  def draw_ray(width, start, stop, ratio)\n    angle = Math::PI * 2 * ratio - Math::PI/2\n    strokewidth width\n    cos = Math::cos(angle)\n    sin = Math::sin(angle)\n    line 101+cos*start, 101+sin*start, 101+cos*stop, 101+sin*stop\n  end\n\n  def update\n    t = Time.now\n    @time.text = t.strftime(\"%H:%M:%S\")\n    h, m, s = (t.hour % 12).to_f, t.min.to_f, t.sec.to_f\n    s += t.to_f - t.to_i  \n\n    @hands.clear do\n      draw_ray(3, 0, 70, (h + m/60)/12)\n      draw_ray(2, 0, 90, (m + s/60)/60)\n      draw_ray(1, 0, 95, s/60)\n    end\n  end\n\n  \n  @time = para(:align=>\"center\", :family => \"monospace\")\n\n  \n  stack(:width=>203, :height=>203) do\n    strokewidth 1\n    fill gradient(deepskyblue, aqua)\n    oval 1, 1, 200\n    fill black\n    oval 98, 98, 6\n    \n    0.upto(59) {|m| draw_ray(1, (m % 5 == 0 ? 96 : 98), 100, m.to_f/60)}\n  end.move(0,23)\n\n  \n  @hands = stack(:width=>203, :height=>203) {}.move(0,23)\n\n  animate(5) {update}\nend\n", "target": "last_sec = second()\n\ndef draw():\n    global last_sec\n    if last_sec != second():\n        draw_clock()\n        last_sec = second()\n\ndef draw_clock():\n    background(192)\n    translate(width / 2, height / 2)\n    s = second() * TWO_PI / 60.0\n    m = minute() * TWO_PI / 60.0\n    h = hour() * TWO_PI / 12.0\n    rotate(s)\n    strokeWeight(1)\n    line(0, 0, 0, -width * 0.5)\n    rotate(-s + m)\n    strokeWeight(2)\n    line(0, 0, 0, -width * 0.4)\n    rotate(-m + h)\n    strokeWeight(4)\n    line(0, 0, 0, -width * 0.2)\n"}
{"id": 103703, "name": "Letter frequency", "source": "Translate Ruby to C#: def letter_frequency(file)\n  letters = 'a' .. 'z'\n  File.read(file) .\n       split(//) .\n       group_by {|letter| letter.downcase} .\n       select   {|key, val| letters.include? key} .\n       collect  {|key, val| [key, val.length]} \nend\n\nletter_frequency(ARGV[0]).sort_by {|key, val| -val}.each {|pair| p pair}\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.IO;\nusing System.Linq;\n\nclass Program\n{\n    static SortedDictionary<TItem, int> GetFrequencies<TItem>(IEnumerable<TItem> items)\n    {\n        var dictionary = new SortedDictionary<TItem, int>();\n        foreach (var item in items)\n        {\n            if (dictionary.ContainsKey(item))\n            {\n                dictionary[item]++;\n            }\n            else\n            {\n                dictionary[item] = 1;\n            }\n        }\n        return dictionary;\n    }\n\n    static void Main(string[] arguments)\n    {\n        var file = arguments.FirstOrDefault();\n        if (File.Exists(file))\n        {\n            var text = File.ReadAllText(file);\n            foreach (var entry in GetFrequencies(text))\n            {\n                Console.WriteLine(\"{0}: {1}\", entry.Key, entry.Value);\n            }\n        }\n    }\n}\n"}
{"id": 103705, "name": "Letter frequency", "source": "Translate Ruby to Java: def letter_frequency(file)\n  letters = 'a' .. 'z'\n  File.read(file) .\n       split(//) .\n       group_by {|letter| letter.downcase} .\n       select   {|key, val| letters.include? key} .\n       collect  {|key, val| [key, val.length]} \nend\n\nletter_frequency(ARGV[0]).sort_by {|key, val| -val}.each {|pair| p pair}\n", "target": "import java.io.BufferedReader;\nimport java.io.FileReader;\nimport java.io.IOException;\nimport java.util.Arrays;\n\npublic class LetterFreq {\n\tpublic static int[] countLetters(String filename) throws IOException{\n\t\tint[] freqs = new int[26];\n\t\tBufferedReader in = new BufferedReader(new FileReader(filename));\n\t\tString line;\n\t\twhile((line = in.readLine()) != null){\n\t\t\tline = line.toUpperCase();\n\t\t\tfor(char ch:line.toCharArray()){\n\t\t\t\tif(Character.isLetter(ch)){\n\t\t\t\t\tfreqs[ch - 'A']++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tin.close();\n\t\treturn freqs;\n\t}\n\t\n\tpublic static void main(String[] args) throws IOException{\n\t\tSystem.out.println(Arrays.toString(countLetters(\"filename.txt\")));\n\t}\n}\n"}
{"id": 103706, "name": "Letter frequency", "source": "Translate Ruby to Python: def letter_frequency(file)\n  letters = 'a' .. 'z'\n  File.read(file) .\n       split(//) .\n       group_by {|letter| letter.downcase} .\n       select   {|key, val| letters.include? key} .\n       collect  {|key, val| [key, val.length]} \nend\n\nletter_frequency(ARGV[0]).sort_by {|key, val| -val}.each {|pair| p pair}\n", "target": "import collections, sys\n\ndef filecharcount(openfile):\n    return sorted(collections.Counter(c for l in openfile for c in l).items())\n\nf = open(sys.argv[1])\nprint(filecharcount(f))\n"}
{"id": 103885, "name": "Sort a list of object identifiers", "source": "Translate Ruby to C#: %w[\n  1.3.6.1.4.1.11.2.17.19.3.4.0.10\n  1.3.6.1.4.1.11.2.17.5.2.0.79\n  1.3.6.1.4.1.11.2.17.19.3.4.0.4\n  1.3.6.1.4.1.11150.3.4.0.1\n  1.3.6.1.4.1.11.2.17.19.3.4.0.1\n  1.3.6.1.4.1.11150.3.4.0\n]\n.sort_by{|oid| oid.split(\".\").map(&:to_i)}\n.each{|oid| puts oid}\n", "target": "using System;\nusing System.Linq;\nusing System.Collections.Generic;\n\npublic class Program\n{\n    public static void Main() {\n        var oids = new [] {\n            \"1.3.6.1.4.1.11.2.17.19.3.4.0.10\",\n            \"1.3.6.1.4.1.11.2.17.5.2.0.79\",\n            \"1.3.6.1.4.1.11.2.17.19.3.4.0.4\",\n            \"1.3.6.1.4.1.11150.3.4.0.1\",\n            \"1.3.6.1.4.1.11.2.17.19.3.4.0.1\",\n            \"1.3.6.1.4.1.11150.3.4.0\"\n        };\n\n        var comparer = Comparer<string>.Create((a, b) => {\n            int c = a.Split('.').Select(int.Parse)\n\t        .Zip(b.Split('.').Select(int.Parse),\n                    (i, j) => i.CompareTo(j)).FirstOrDefault(x => x != 0);\n            return c != 0 ? c : a.Length.CompareTo(b.Length);\n        });\n\n        Array.Sort(oids, comparer);\n\n        Console.WriteLine(string.Join(Environment.NewLine, oids));\n    }\n}\n"}
{"id": 103887, "name": "Sort a list of object identifiers", "source": "Translate Ruby to Java: %w[\n  1.3.6.1.4.1.11.2.17.19.3.4.0.10\n  1.3.6.1.4.1.11.2.17.5.2.0.79\n  1.3.6.1.4.1.11.2.17.19.3.4.0.4\n  1.3.6.1.4.1.11150.3.4.0.1\n  1.3.6.1.4.1.11.2.17.19.3.4.0.1\n  1.3.6.1.4.1.11150.3.4.0\n]\n.sort_by{|oid| oid.split(\".\").map(&:to_i)}\n.each{|oid| puts oid}\n", "target": "package com.rosettacode;\n\nimport java.util.Comparator;\nimport java.util.stream.Stream;\n\npublic class OIDListSorting {\n\n    public static void main(String[] args) {\n\n        final String dot = \"\\\\.\";\n\n        final Comparator<String> oids_comparator = (o1, o2) -> {\n            final String[] o1Numbers = o1.split(dot), o2Numbers = o2.split(dot);\n            for (int i = 0; ; i++) {\n                if (i == o1Numbers.length && i == o2Numbers.length)\n                    return 0;\n                if (i == o1Numbers.length)\n                    return -1;\n                if (i == o2Numbers.length)\n                    return 1;\n                final int nextO1Number = Integer.valueOf(o1Numbers[i]), nextO2Number = Integer.valueOf(o2Numbers[i]);\n                final int result = Integer.compare(nextO1Number, nextO2Number);\n                if (result != 0)\n                    return result;\n            }\n        };\n\n        Stream.of(\"1.3.6.1.4.1.11.2.17.19.3.4.0.10\", \"1.3.6.1.4.1.11.2.17.5.2.0.79\", \"1.3.6.1.4.1.11.2.17.19.3.4.0.4\",\n                  \"1.3.6.1.4.1.11150.3.4.0.1\", \"1.3.6.1.4.1.11.2.17.19.3.4.0.1\", \"1.3.6.1.4.1.11150.3.4.0\")\n                .sorted(oids_comparator)\n                .forEach(System.out::println);\n    }\n}\n"}
{"id": 103888, "name": "Sort a list of object identifiers", "source": "Translate Ruby to Python: %w[\n  1.3.6.1.4.1.11.2.17.19.3.4.0.10\n  1.3.6.1.4.1.11.2.17.5.2.0.79\n  1.3.6.1.4.1.11.2.17.19.3.4.0.4\n  1.3.6.1.4.1.11150.3.4.0.1\n  1.3.6.1.4.1.11.2.17.19.3.4.0.1\n  1.3.6.1.4.1.11150.3.4.0\n]\n.sort_by{|oid| oid.split(\".\").map(&:to_i)}\n.each{|oid| puts oid}\n", "target": "data = [\n    '1.3.6.1.4.1.11.2.17.19.3.4.0.10',\n    '1.3.6.1.4.1.11.2.17.5.2.0.79',\n    '1.3.6.1.4.1.11.2.17.19.3.4.0.4',\n    '1.3.6.1.4.1.11150.3.4.0.1',\n    '1.3.6.1.4.1.11.2.17.19.3.4.0.1',\n    '1.3.6.1.4.1.11150.3.4.0'\n]\n\nfor s in sorted(data, key=lambda x: list(map(int, x.split('.')))):\n    print(s)\n"}
{"id": 104102, "name": "Hello world_Graphical", "source": "Translate Ruby to C#: require 'gtk2'\n\nwindow = Gtk::Window.new\nwindow.title = 'Goodbye, World'\nwindow.signal_connect(:delete-event) { Gtk.main_quit }\nwindow.show_all\n\nGtk.main\n", "target": "using System;\nusing System.Windows.Forms;\n\nclass Program {\n    static void Main(string[] args) {\n        Application.EnableVisualStyles(); \n        MessageBox.Show(\"Goodbye, World!\");\n    }\n}\n"}
{"id": 104104, "name": "Hello world_Graphical", "source": "Translate Ruby to Java: require 'gtk2'\n\nwindow = Gtk::Window.new\nwindow.title = 'Goodbye, World'\nwindow.signal_connect(:delete-event) { Gtk.main_quit }\nwindow.show_all\n\nGtk.main\n", "target": "import javax.swing.*;\nimport java.awt.*;\n\npublic class OutputSwing {\n\n    public static void main(String[] args) {\n\n        SwingUtilities.invokeLater(new Runnable(){\n            public void run() {\n                JOptionPane.showMessageDialog (null, \"Goodbye, World!\"); \n                JFrame frame = new JFrame(\"Goodbye, World!\");            \n                JTextArea text = new JTextArea(\"Goodbye, World!\");       \n                JButton button = new JButton(\"Goodbye, World!\");         \n\n                frame.setLayout(new FlowLayout());\n                frame.add(button);\n                frame.add(text);\n                frame.pack();\n                frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n                frame.setVisible(true);\n            }\n        });\n    }\n}\n"}
{"id": 104105, "name": "Hello world_Graphical", "source": "Translate Ruby to Python: require 'gtk2'\n\nwindow = Gtk::Window.new\nwindow.title = 'Goodbye, World'\nwindow.signal_connect(:delete-event) { Gtk.main_quit }\nwindow.show_all\n\nGtk.main\n", "target": "import bpy\n\n\nbpy.data.objects['Cube'].select_set(True)\n\n\nbpy.ops.object.delete(True)\n  \n\nbpy.data.curves.new(type=\"FONT\", name=\"Font Curve\").body = \"Hello World\"\nfont_obj = bpy.data.objects.new(name=\"Font Object\", object_data=bpy.data.curves[\"Font Curve\"])\nbpy.context.scene.collection.objects.link(font_obj)\n        \n\nbpy.context.scene.camera.location = (2.5,0.3,10)\n\n\nbpy.context.scene.camera.rotation_euler = (0,0,0)\n\n\narea = next(area for area in bpy.context.screen.areas if area.type == 'VIEW_3D')\narea.spaces[0].region_3d.view_perspective = 'CAMERA'\n"}
{"id": 104387, "name": "Search a list", "source": "Translate Ruby to C#: haystack = %w(Zig Zag Wally Ronald Bush Krusty Charlie Bush Bozo)\n\n%w(Bush Washington).each do |needle|\n  if (i = haystack.index(needle))\n    puts \"\n  else\n    raise \"\n  end\nend\n", "target": "using System;\nusing System.Collections.Generic;\n\nclass Program {\n    static void Main(string[] args) {\n        List<string> haystack = new List<string>() { \"Zig\", \"Zag\", \"Wally\", \"Ronald\", \"Bush\", \"Krusty\", \"Charlie\", \"Bush\", \"Bozo\" };\n\n        foreach (string needle in new string[] { \"Washington\", \"Bush\" }) {\n            int index = haystack.IndexOf(needle);\n            \n            if (index < 0) Console.WriteLine(\"{0} is not in haystack\",needle);                \n            else Console.WriteLine(\"{0} {1}\",index,needle);\n        }\n    }\n}\n"}
{"id": 104389, "name": "Search a list", "source": "Translate Ruby to Java: haystack = %w(Zig Zag Wally Ronald Bush Krusty Charlie Bush Bozo)\n\n%w(Bush Washington).each do |needle|\n  if (i = haystack.index(needle))\n    puts \"\n  else\n    raise \"\n  end\nend\n", "target": "import java.util.List;\nimport java.util.Arrays;\n\nList<String> haystack = Arrays.asList(\"Zig\",\"Zag\",\"Wally\",\"Ronald\",\"Bush\",\"Krusty\",\"Charlie\",\"Bush\",\"Bozo\");\n\nfor (String needle : new String[]{\"Washington\",\"Bush\"}) {\n    int index = haystack.indexOf(needle);\n    if (index < 0)\n        System.out.println(needle + \" is not in haystack\");\n    else\n        System.out.println(index + \" \" + needle);\n}\n"}
{"id": 104390, "name": "Search a list", "source": "Translate Ruby to Python: haystack = %w(Zig Zag Wally Ronald Bush Krusty Charlie Bush Bozo)\n\n%w(Bush Washington).each do |needle|\n  if (i = haystack.index(needle))\n    puts \"\n  else\n    raise \"\n  end\nend\n", "target": "haystack=[\"Zig\",\"Zag\",\"Wally\",\"Ronald\",\"Bush\",\"Krusty\",\"Charlie\",\"Bush\",\"Bozo\"]\n\nfor needle in (\"Washington\",\"Bush\"):\n  try:\n    print haystack.index(needle), needle\n  except ValueError, value_error:\n    print needle,\"is not in haystack\"\n"}
{"id": 104569, "name": "Element-wise operations", "source": "Translate Ruby to C#: require 'matrix'\n\nclass Matrix\n  def element_wise( operator, other )\n    Matrix.build(row_size, column_size) do |row, col|\n      self[row, col].send(operator, other[row, col])\n    end\n  end\nend\n\nm1, m2 = Matrix[[3,1,4],[1,5,9]], Matrix[[2,7,1],[8,2,2]]\nputs \"m1: \n\n[:+, :-, :*, :/, :fdiv, :**, :%].each do |op|\n  puts \"m1\u00a0%-4s m2  =  %s\" % [op, m1.element_wise(op, m2)]\nend\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\npublic static class ElementWiseOperations\n{\n    private static readonly Dictionary<string, Func<double, double, double>> operations =\n        new Dictionary<string, Func<double, double, double>> {\n            { \"add\", (a, b) => a + b },\n            { \"sub\", (a, b) => a - b },\n            { \"mul\", (a, b) => a * b },\n            { \"div\", (a, b) => a / b },\n            { \"pow\", (a, b) => Math.Pow(a, b) }\n        };\n\n    private static readonly Func<double, double, double> nothing = (a, b) => a;\n\n    public static double[,] DoOperation(this double[,] m, string name, double[,] other) =>\n        DoOperation(m, operations.TryGetValue(name, out var operation) ? operation : nothing, other);\n\n    public static double[,] DoOperation(this double[,] m, Func<double, double, double> operation, double[,] other) {\n        if (m == null || other == null) throw new ArgumentNullException();\n        int rows = m.GetLength(0), columns = m.GetLength(1);\n        if (rows != other.GetLength(0) || columns != other.GetLength(1)) {\n            throw new ArgumentException(\"Matrices have different dimensions.\");\n        }\n\n        double[,] result = new double[rows, columns];\n        for (int r = 0; r < rows; r++) {\n            for (int c = 0; c < columns; c++) {\n                result[r, c] = operation(m[r, c], other[r, c]);\n            }\n        }\n        return result;\n    }\n\n    public static double[,] DoOperation(this double[,] m, string name, double number) =>\n        DoOperation(m, operations.TryGetValue(name, out var operation) ? operation : nothing, number);\n\n    public static double[,] DoOperation(this double[,] m, Func<double, double, double> operation, double number) {\n        if (m == null) throw new ArgumentNullException();\n        int rows = m.GetLength(0), columns = m.GetLength(1);\n        double[,] result = new double[rows, columns];\n        for (int r = 0; r < rows; r++) {\n            for (int c = 0; c < columns; c++) {\n                result[r, c] = operation(m[r, c], number);\n            }\n        }\n        return result;\n    }\n\n    public static void Print(this double[,] m) {\n        if (m == null) throw new ArgumentNullException();\n        int rows = m.GetLength(0), columns = m.GetLength(1);\n        for (int r = 0; r < rows; r++) {\n            Console.WriteLine(\"[ \" + string.Join(\", \", Enumerable.Range(0, columns).Select(c => m[r, c])) + \" ]\");\n        }\n    }\n\n}\n\npublic class Program\n{\n    public static void Main() {\n        double[,] matrix = {\n            { 1, 2, 3, 4 },\n            { 5, 6, 7, 8 },\n            { 9, 10, 11, 12 }\n        };\n\n        double[,] tens = {\n            { 10, 10, 10, 10 },\n            { 20, 20, 20, 20 },\n            { 30, 30, 30, 30 }\n        };\n\n        matrix.Print();\n        WriteLine();\n\n        (matrix = matrix.DoOperation(\"add\", tens)).Print();\n        WriteLine();\n\n        matrix.DoOperation((a, b) => b - a, 100).Print();\n    }\n}\n"}
{"id": 104571, "name": "Element-wise operations", "source": "Translate Ruby to Java: require 'matrix'\n\nclass Matrix\n  def element_wise( operator, other )\n    Matrix.build(row_size, column_size) do |row, col|\n      self[row, col].send(operator, other[row, col])\n    end\n  end\nend\n\nm1, m2 = Matrix[[3,1,4],[1,5,9]], Matrix[[2,7,1],[8,2,2]]\nputs \"m1: \n\n[:+, :-, :*, :/, :fdiv, :**, :%].each do |op|\n  puts \"m1\u00a0%-4s m2  =  %s\" % [op, m1.element_wise(op, m2)]\nend\n", "target": "import java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.function.BiFunction;\nimport java.util.stream.Stream;\n\n@SuppressWarnings(\"serial\")\npublic class ElementWiseOp {\n\tstatic final Map<String, BiFunction<Double, Double, Double>> OPERATIONS = new HashMap<String, BiFunction<Double, Double, Double>>() {\n\t\t{\n\t\t\tput(\"add\", (a, b) -> a + b);\n\t\t\tput(\"sub\", (a, b) -> a - b);\n\t\t\tput(\"mul\", (a, b) -> a * b);\n\t\t\tput(\"div\", (a, b) -> a / b);\n\t\t\tput(\"pow\", (a, b) -> Math.pow(a, b));\n\t\t\tput(\"mod\", (a, b) -> a % b);\n\t\t}\n\t};\n\tpublic static Double[][] scalarOp(String op, Double[][] matr, Double scalar) {\n\t\tBiFunction<Double, Double, Double> operation = OPERATIONS.getOrDefault(op, (a, b) -> a);\n\t\tDouble[][] result = new Double[matr.length][matr[0].length];\n\t\tfor (int i = 0; i < matr.length; i++) {\n\t\t\tfor (int j = 0; j < matr[i].length; j++) {\n\t\t\t\tresult[i][j] = operation.apply(matr[i][j], scalar);\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n\tpublic static Double[][] matrOp(String op, Double[][] matr, Double[][] scalar) {\n\t\tBiFunction<Double, Double, Double> operation = OPERATIONS.getOrDefault(op, (a, b) -> a);\n\t\tDouble[][] result = new Double[matr.length][Stream.of(matr).mapToInt(a -> a.length).max().getAsInt()];\n\t\tfor (int i = 0; i < matr.length; i++) {\n\t\t\tfor (int j = 0; j < matr[i].length; j++) {\n\t\t\t\tresult[i][j] = operation.apply(matr[i][j], scalar[i % scalar.length][j\n\t\t\t\t\t\t% scalar[i % scalar.length].length]);\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n\tpublic static void printMatrix(Double[][] matr) {\n\t\tStream.of(matr).map(Arrays::toString).forEach(System.out::println);\n\t}\n\tpublic static void main(String[] args) {\n\t\tprintMatrix(scalarOp(\"mul\", new Double[][] {\n\t\t\t\t{ 1.0, 2.0, 3.0 }, \n\t\t\t\t{ 4.0, 5.0, 6.0 }, \n\t\t\t\t{ 7.0, 8.0, 9.0 }\n\t\t}, 3.0));\n\n\t\tprintMatrix(matrOp(\"div\", new Double[][] {\n\t\t\t\t{ 1.0, 2.0, 3.0 }, \n\t\t\t\t{ 4.0, 5.0, 6.0 }, \n\t\t\t\t{ 7.0, 8.0, 9.0 }\n\t\t}, new Double[][] {\n\t\t\t\t{ 1.0, 2.0}, \n\t\t\t\t{ 3.0, 4.0} \n\t\t}));\n\t}\n}\n"}
{"id": 104572, "name": "Element-wise operations", "source": "Translate Ruby to Python: require 'matrix'\n\nclass Matrix\n  def element_wise( operator, other )\n    Matrix.build(row_size, column_size) do |row, col|\n      self[row, col].send(operator, other[row, col])\n    end\n  end\nend\n\nm1, m2 = Matrix[[3,1,4],[1,5,9]], Matrix[[2,7,1],[8,2,2]]\nputs \"m1: \n\n[:+, :-, :*, :/, :fdiv, :**, :%].each do |op|\n  puts \"m1\u00a0%-4s m2  =  %s\" % [op, m1.element_wise(op, m2)]\nend\n", "target": ">>> import random\n>>> from operator import add, sub, mul, floordiv\n>>> from pprint import pprint as pp\n>>> \n>>> def ewise(matrix1, matrix2, op):\n\treturn [[op(e1,e2) for e1,e2 in zip(row1, row2)] for row1,row2 in zip(matrix1, matrix2)]\n\n>>> m,n = 3,4 \t\n>>> a0 = [[random.randint(1,9) for y in range(n)] for x in range(m)]\n>>> a1 = [[random.randint(1,9) for y in range(n)] for x in range(m)]\n>>> pp(a0); pp(a1)\n[[7, 8, 7, 4], [4, 9, 4, 1], [2, 3, 6, 4]]\n[[4, 5, 1, 6], [6, 8, 3, 4], [2, 2, 6, 3]]\n>>> pp(ewise(a0, a1, add))\n[[11, 13, 8, 10], [10, 17, 7, 5], [4, 5, 12, 7]]\n>>> pp(ewise(a0, a1, sub))\n[[3, 3, 6, -2], [-2, 1, 1, -3], [0, 1, 0, 1]]\n>>> pp(ewise(a0, a1, mul))\n[[28, 40, 7, 24], [24, 72, 12, 4], [4, 6, 36, 12]]\n>>> pp(ewise(a0, a1, floordiv))\n[[1, 1, 7, 0], [0, 1, 1, 0], [1, 1, 1, 1]]\n>>> pp(ewise(a0, a1, pow))\n[[2401, 32768, 7, 4096], [4096, 43046721, 64, 1], [4, 9, 46656, 64]]\n>>> pp(ewise(a0, a1, lambda x, y:2*x - y))\n[[10, 11, 13, 2], [2, 10, 5, -2], [2, 4, 6, 5]]\n>>> \n>>> def s_ewise(scalar1, matrix1, op):\n\treturn [[op(scalar1, e1) for e1 in row1] for row1 in matrix1]\n\n>>> scalar = 10\n>>> a0\n[[7, 8, 7, 4], [4, 9, 4, 1], [2, 3, 6, 4]]\n>>> for op in ( add, sub, mul, floordiv, pow, lambda x, y:2*x - y ):\n\tprint(\"%10s\u00a0:\" % op.__name__, s_ewise(scalar, a0, op))\n\n\t\n       add : [[17, 18, 17, 14], [14, 19, 14, 11], [12, 13, 16, 14]]\n       sub : [[3, 2, 3, 6], [6, 1, 6, 9], [8, 7, 4, 6]]\n       mul : [[70, 80, 70, 40], [40, 90, 40, 10], [20, 30, 60, 40]]\n  floordiv : [[1, 1, 1, 2], [2, 1, 2, 10], [5, 3, 1, 2]]\n       pow : [[10000000, 100000000, 10000000, 10000], [10000, 1000000000, 10000, 10], [100, 1000, 1000000, 10000]]\n  <lambda> : [[13, 12, 13, 16], [16, 11, 16, 19], [18, 17, 14, 16]]\n>>>\n"}
{"id": 104660, "name": "Terminal control_Cursor positioning", "source": "Translate Ruby to C#: require 'curses'\n\nCurses.init_screen\nbegin\n  Curses.setpos(6, 3)  \n  Curses.addstr(\"Hello\")\n\n  Curses.getch  \nensure\n  Curses.close_screen\nend\n", "target": "static void Main(string[] args)\n{\n    Console.SetCursorPosition(3, 6);\n    Console.Write(\"Hello\");\n}\n"}
{"id": 104661, "name": "Terminal control_Cursor positioning", "source": "Translate Ruby to Python: require 'curses'\n\nCurses.init_screen\nbegin\n  Curses.setpos(6, 3)  \n  Curses.addstr(\"Hello\")\n\n  Curses.getch  \nensure\n  Curses.close_screen\nend\n", "target": "print(\"\\033[6;3HHello\")\n"}
{"id": 104823, "name": "Break OO privacy", "source": "Translate Ruby to C#: class Example\n  def initialize\n     @private_data = \"nothing\" \n  end\n  private\n  def hidden_method\n     \"secret\"\n  end\nend\nexample = Example.new\np example.private_methods(false) \n\np example.send(:hidden_method) \np example.instance_variables \np example.instance_variable_get :@private_data \np example.instance_variable_set :@private_data, 42 \np example.instance_variable_get :@private_data \n", "target": "using System;\nusing System.Reflection;\n\npublic class MyClass\n{\n    private int answer = 42;\n}\n\npublic class Program\n{\n    public static void Main()\n    {\n        var myInstance = new MyClass();\n        var fieldInfo = typeof(MyClass).GetField(\"answer\", BindingFlags.NonPublic | BindingFlags.Instance);\n        var answer = fieldInfo.GetValue(myInstance);\n        Console.WriteLine(answer);\n    }\n}\n"}
{"id": 104824, "name": "Break OO privacy", "source": "Translate Ruby to C#: class Example\n  def initialize\n     @private_data = \"nothing\" \n  end\n  private\n  def hidden_method\n     \"secret\"\n  end\nend\nexample = Example.new\np example.private_methods(false) \n\np example.send(:hidden_method) \np example.instance_variables \np example.instance_variable_get :@private_data \np example.instance_variable_set :@private_data, 42 \np example.instance_variable_get :@private_data \n", "target": "using System;\nusing System.Reflection;\n\npublic class MyClass\n{\n    private int answer = 42;\n}\n\npublic class Program\n{\n    public static void Main()\n    {\n        var myInstance = new MyClass();\n        var fieldInfo = typeof(MyClass).GetField(\"answer\", BindingFlags.NonPublic | BindingFlags.Instance);\n        var answer = fieldInfo.GetValue(myInstance);\n        Console.WriteLine(answer);\n    }\n}\n"}
{"id": 104827, "name": "Break OO privacy", "source": "Translate Ruby to Java: class Example\n  def initialize\n     @private_data = \"nothing\" \n  end\n  private\n  def hidden_method\n     \"secret\"\n  end\nend\nexample = Example.new\np example.private_methods(false) \n\np example.send(:hidden_method) \np example.instance_variables \np example.instance_variable_get :@private_data \np example.instance_variable_set :@private_data, 42 \np example.instance_variable_get :@private_data \n", "target": "module BreakOO\n    {\n    \n    class Exposed\n        {\n        public    String pub = \"public\";\n        protected String pro = \"protected\";\n        private   String pri = \"private\";\n\n        @Override\n        String toString()\n            {\n            return $\"pub={pub.quoted()}, pro={pro.quoted()}, pri={pri.quoted()}\";\n            }\n        }\n\n    void run()\n        {\n        @Inject Console console;\n\n        Exposed expo = new Exposed();\n        console.print($\"before: {expo}\");\n\n        \n        expo.pub = $\"this was {expo.pub}\";\n     \n     \n\n        \n        assert (protected Exposed) expoPro := &expo.revealAs((protected Exposed));\n        expoPro.pro = $\"this was {expoPro.pro}\";\n     \n\n        \n        assert (private Exposed) expoPri := &expo.revealAs((private Exposed));\n        expoPri.pri = $\"this was {expoPri.pri}\";\n\n        \n        \n        assert (struct Exposed) expoStr := &expo.revealAs((struct Exposed));\n        expoStr.pub = $\"{expoStr.pub}!!!\";\n        expoStr.pro = $\"{expoStr.pro}!!!\";\n        expoStr.pri = $\"{expoStr.pri}!!!\";\n\n        console.print($\"after: {expo}\");\n        }\n    }\n"}
{"id": 104828, "name": "Break OO privacy", "source": "Translate Ruby to Java: class Example\n  def initialize\n     @private_data = \"nothing\" \n  end\n  private\n  def hidden_method\n     \"secret\"\n  end\nend\nexample = Example.new\np example.private_methods(false) \n\np example.send(:hidden_method) \np example.instance_variables \np example.instance_variable_get :@private_data \np example.instance_variable_set :@private_data, 42 \np example.instance_variable_get :@private_data \n", "target": "module BreakOO\n    {\n    \n    class Exposed\n        {\n        public    String pub = \"public\";\n        protected String pro = \"protected\";\n        private   String pri = \"private\";\n\n        @Override\n        String toString()\n            {\n            return $\"pub={pub.quoted()}, pro={pro.quoted()}, pri={pri.quoted()}\";\n            }\n        }\n\n    void run()\n        {\n        @Inject Console console;\n\n        Exposed expo = new Exposed();\n        console.print($\"before: {expo}\");\n\n        \n        expo.pub = $\"this was {expo.pub}\";\n     \n     \n\n        \n        assert (protected Exposed) expoPro := &expo.revealAs((protected Exposed));\n        expoPro.pro = $\"this was {expoPro.pro}\";\n     \n\n        \n        assert (private Exposed) expoPri := &expo.revealAs((private Exposed));\n        expoPri.pri = $\"this was {expoPri.pri}\";\n\n        \n        \n        assert (struct Exposed) expoStr := &expo.revealAs((struct Exposed));\n        expoStr.pub = $\"{expoStr.pub}!!!\";\n        expoStr.pro = $\"{expoStr.pro}!!!\";\n        expoStr.pri = $\"{expoStr.pri}!!!\";\n\n        console.print($\"after: {expo}\");\n        }\n    }\n"}
{"id": 104829, "name": "Break OO privacy", "source": "Translate Ruby to Python: class Example\n  def initialize\n     @private_data = \"nothing\" \n  end\n  private\n  def hidden_method\n     \"secret\"\n  end\nend\nexample = Example.new\np example.private_methods(false) \n\np example.send(:hidden_method) \np example.instance_variables \np example.instance_variable_get :@private_data \np example.instance_variable_set :@private_data, 42 \np example.instance_variable_get :@private_data \n", "target": ">>> class MyClassName:\n\t__private = 123\n\tnon_private = __private * 2\n\n\t\n>>> mine = MyClassName()\n>>> mine.non_private\n246\n>>> mine.__private\nTraceback (most recent call last):\n  File \"<pyshell\n    mine.__private\nAttributeError: 'MyClassName' object has no attribute '__private'\n>>> mine._MyClassName__private\n123\n>>>\n"}
{"id": 104830, "name": "Break OO privacy", "source": "Translate Ruby to Python: class Example\n  def initialize\n     @private_data = \"nothing\" \n  end\n  private\n  def hidden_method\n     \"secret\"\n  end\nend\nexample = Example.new\np example.private_methods(false) \n\np example.send(:hidden_method) \np example.instance_variables \np example.instance_variable_get :@private_data \np example.instance_variable_set :@private_data, 42 \np example.instance_variable_get :@private_data \n", "target": ">>> class MyClassName:\n\t__private = 123\n\tnon_private = __private * 2\n\n\t\n>>> mine = MyClassName()\n>>> mine.non_private\n246\n>>> mine.__private\nTraceback (most recent call last):\n  File \"<pyshell\n    mine.__private\nAttributeError: 'MyClassName' object has no attribute '__private'\n>>> mine._MyClassName__private\n123\n>>>\n"}
{"id": 105075, "name": "Amicable pairs", "source": "Translate Ruby to C#: h = {}\n(1..20_000).each{|n| h[n] = n.proper_divisors.sum }\nh.select{|k,v| h[v] == k && k < v}.each do |key,val|  \n  puts \"\nend\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\nnamespace RosettaCode.AmicablePairs\n{\n    internal static class Program {\n        private const int Limit = 20000;        \n\n        private static void Main()\n        {\n            foreach (var pair in GetPairs(Limit))\n            {\n                Console.WriteLine(\"{0} {1}\", pair.Item1, pair.Item2);\n            }\n        }\n\n        private static IEnumerable<Tuple<int, int>> GetPairs(int max)\n        {\n            List<int> divsums =\n                Enumerable.Range(0, max + 1).Select(i => ProperDivisors(i).Sum()).ToList();\n            for(int i=1; i<divsums.Count; i++) {\n                int sum = divsums[i];\n                if(i < sum && sum <= divsums.Count && divsums[sum] == i) {\n                    yield return new Tuple<int, int>(i, sum);\n                }\n            }\n        }\n\n        private static IEnumerable<int> ProperDivisors(int number)\n        {\n            return\n                Enumerable.Range(1, number / 2)\n                    .Where(divisor => number % divisor == 0);\n        }\n    }\n}\n"}
{"id": 105077, "name": "Amicable pairs", "source": "Translate Ruby to Java: h = {}\n(1..20_000).each{|n| h[n] = n.proper_divisors.sum }\nh.select{|k,v| h[v] == k && k < v}.each do |key,val|  \n  puts \"\nend\n", "target": "import java.util.Map;\nimport java.util.function.Function;\nimport java.util.stream.Collectors;\nimport java.util.stream.LongStream;\n\npublic class AmicablePairs {\n\n    public static void main(String[] args) {\n        int limit = 20_000;\n\n        Map<Long, Long> map = LongStream.rangeClosed(1, limit)\n                .parallel()\n                .boxed()\n                .collect(Collectors.toMap(Function.identity(), AmicablePairs::properDivsSum));\n\n        LongStream.rangeClosed(1, limit)\n                .forEach(n -> {\n                    long m = map.get(n);\n                    if (m > n && m <= limit && map.get(m) == n)\n                        System.out.printf(\"%s %s %n\", n, m);\n                });\n    }\n\n    public static Long properDivsSum(long n) {\n        return LongStream.rangeClosed(1, (n + 1) / 2).filter(i -> n % i == 0).sum();\n    }\n}\n"}
{"id": 105078, "name": "Amicable pairs", "source": "Translate Ruby to Python: h = {}\n(1..20_000).each{|n| h[n] = n.proper_divisors.sum }\nh.select{|k,v| h[v] == k && k < v}.each do |key,val|  \n  puts \"\nend\n", "target": "from proper_divisors import proper_divs\n\ndef amicable(rangemax=20000):\n    n2divsum = {n: sum(proper_divs(n)) for n in range(1, rangemax + 1)}\n    for num, divsum in n2divsum.items():\n        if num < divsum and divsum <= rangemax and n2divsum[divsum] == num:\n            yield num, divsum\n\nif __name__ == '__main__':\n    for num, divsum in amicable():\n        print('Amicable pair: %i and %i With proper divisors:\\n    %r\\n    %r'\n              % (num, divsum, sorted(proper_divs(num)), sorted(proper_divs(divsum))))\n"}
{"id": 105293, "name": "Animation", "source": "Translate Ruby to C#: require 'tk'\n$str = TkVariable.new(\"Hello World! \")\n$dir = :right\n \ndef animate\n  $str.value = shift_char($str.value, $dir)\n  $root.after(125) {animate}\nend\n\ndef shift_char(str, dir)\n  case dir\n  when :right then str[-1,1] + str[0..-2]\n  when :left  then str[1..-1] + str[0,1]\n  end\nend\n \n$root = TkRoot.new(\"title\" => \"Basic Animation\")\n \nTkLabel.new($root) do\n  textvariable $str\n  font \"Courier 14\"\n  pack {side 'top'}\n  bind(\"ButtonPress-1\") {$dir = {:right=>:left,:left=>:right}[$dir]}\nend\n \nanimate\nTk.mainloop\n", "target": "using System;\nusing System.Drawing;\nusing System.Windows.Forms;\n\nnamespace BasicAnimation\n{\n  class BasicAnimationForm : Form\n  {\n    bool isReverseDirection;\n    Label textLabel;\n    Timer timer;\n\n    internal BasicAnimationForm()\n    {\n      this.Size = new Size(150, 75);\n      this.Text = \"Basic Animation\";\n\n      textLabel = new Label();\n      textLabel.Text = \"Hello World! \";\n      textLabel.Location = new Point(3,3);\n      textLabel.AutoSize = true;\n      textLabel.Click += new EventHandler(textLabel_OnClick);\n      this.Controls.Add(textLabel);\n\n      timer = new Timer();\n      timer.Interval = 500;\n      timer.Tick += new EventHandler(timer_OnTick);\n      timer.Enabled = true;\n\n      isReverseDirection = false;\n    }\n\n    private void timer_OnTick(object sender, EventArgs e)\n    {\n      string oldText = textLabel.Text, newText;\n      if(isReverseDirection)\n        newText = oldText.Substring(1, oldText.Length - 1) + oldText.Substring(0, 1);\n      else\n        newText = oldText.Substring(oldText.Length - 1, 1) + oldText.Substring(0, oldText.Length - 1);\n      textLabel.Text = newText;\n    }\n\n    private void textLabel_OnClick(object sender, EventArgs e)\n    {\n      isReverseDirection = !isReverseDirection;\n    }\n  }\n\n   class Program\n   {\n      static void Main()\n      {\n\tApplication.Run(new BasicAnimationForm());\n      }\n   }\n}\n"}
{"id": 105295, "name": "Animation", "source": "Translate Ruby to Java: require 'tk'\n$str = TkVariable.new(\"Hello World! \")\n$dir = :right\n \ndef animate\n  $str.value = shift_char($str.value, $dir)\n  $root.after(125) {animate}\nend\n\ndef shift_char(str, dir)\n  case dir\n  when :right then str[-1,1] + str[0..-2]\n  when :left  then str[1..-1] + str[0,1]\n  end\nend\n \n$root = TkRoot.new(\"title\" => \"Basic Animation\")\n \nTkLabel.new($root) do\n  textvariable $str\n  font \"Courier 14\"\n  pack {side 'top'}\n  bind(\"ButtonPress-1\") {$dir = {:right=>:left,:left=>:right}[$dir]}\nend\n \nanimate\nTk.mainloop\n", "target": "import java.awt.event.MouseAdapter;\nimport java.awt.event.MouseEvent;\nimport java.awt.event.WindowAdapter;\nimport java.awt.event.WindowEvent;\nimport java.util.Timer;\nimport java.util.TimerTask;\nimport javax.swing.JFrame;\nimport javax.swing.JLabel;\nimport javax.swing.WindowConstants;\n\npublic class Rotate {\n\n    private static class State {\n        private final String text = \"Hello World! \";\n        private int startIndex = 0;\n        private boolean rotateRight = true;\n    }\n\n    public static void main(String[] args) {\n        State state = new State();\n\n        JLabel label = new JLabel(state.text);\n        label.addMouseListener(new MouseAdapter() {\n            @Override\n            public void mouseClicked(MouseEvent event) {\n                state.rotateRight = !state.rotateRight;\n            }\n        });\n\n        TimerTask task = new TimerTask() {\n            public void run() {\n                int delta = state.rotateRight ? 1 : -1;\n                state.startIndex = (state.startIndex + state.text.length() + delta) % state.text.length();\n                label.setText(rotate(state.text, state.startIndex));\n            }\n        };\n        Timer timer = new Timer(false);\n        timer.schedule(task, 0, 500);\n\n        JFrame rot = new JFrame();\n        rot.setDefaultCloseOperation(WindowConstants.DISPOSE_ON_CLOSE);\n        rot.add(label);\n        rot.pack();\n        rot.setLocationRelativeTo(null);\n        rot.addWindowListener(new WindowAdapter() {\n            @Override\n            public void windowClosed(WindowEvent e) {\n                timer.cancel();\n            }\n        });\n        rot.setVisible(true);\n    }\n\n    private static String rotate(String text, int startIdx) {\n        char[] rotated = new char[text.length()];\n        for (int i = 0; i < text.length(); i++) {\n            rotated[i] = text.charAt((i + startIdx) % text.length());\n        }\n        return String.valueOf(rotated);\n    }\n}\n"}
{"id": 105296, "name": "Animation", "source": "Translate Ruby to Python: require 'tk'\n$str = TkVariable.new(\"Hello World! \")\n$dir = :right\n \ndef animate\n  $str.value = shift_char($str.value, $dir)\n  $root.after(125) {animate}\nend\n\ndef shift_char(str, dir)\n  case dir\n  when :right then str[-1,1] + str[0..-2]\n  when :left  then str[1..-1] + str[0,1]\n  end\nend\n \n$root = TkRoot.new(\"title\" => \"Basic Animation\")\n \nTkLabel.new($root) do\n  textvariable $str\n  font \"Courier 14\"\n  pack {side 'top'}\n  bind(\"ButtonPress-1\") {$dir = {:right=>:left,:left=>:right}[$dir]}\nend\n \nanimate\nTk.mainloop\n", "target": "txt = \"Hello, world! \"\nleft = True\n\ndef draw():\n    global txt\n    background(128)\n    text(txt, 10, height / 2)\n    if frameCount % 10 == 0:\n        if (left):\n            txt = rotate(txt, 1)\n        else:\n            txt = rotate(txt, -1)\n        println(txt)\n\ndef mouseReleased():\n    global left\n    left = not left\n\ndef rotate(text, startIdx):\n    rotated = text[startIdx:] + text[:startIdx]\n    return rotated\n"}
{"id": 105429, "name": "Knapsack problem_Unbounded", "source": "Translate Ruby to C#: KnapsackItem = Struct.new(:volume, :weight, :value)\npanacea = KnapsackItem.new(0.025, 0.3, 3000)\nichor   = KnapsackItem.new(0.015, 0.2, 1800)\ngold    = KnapsackItem.new(0.002, 2.0, 2500)\nmaximum = KnapsackItem.new(0.25,  25,  0)\n\nmax_items = {}\nfor item in [panacea, ichor, gold]\n  max_items[item] = [(maximum.volume/item.volume).to_i, (maximum.weight/item.weight).to_i].min\nend\n\nmaxval = 0\nsolutions = []\n\n0.upto(max_items[ichor]) do |i|\n  0.upto(max_items[panacea]) do |p|\n    0.upto(max_items[gold]) do |g|\n      break if i*ichor.weight + p*panacea.weight + g*gold.weight > maximum.weight\n      break if i*ichor.volume + p*panacea.volume + g*gold.volume > maximum.volume\n      val = i*ichor.value + p*panacea.value + g*gold.value\n      if val > maxval\n        maxval = val\n        solutions = [[i, p, g]]\n      elsif val == maxval\n        solutions << [i, p, g]\n      end\n    end\n  end\nend\n\nputs \"The maximal solution has value \nsolutions.each do |i, p, g|\n  printf \"  ichor=%2d, panacea=%2d, gold=%2d -- weight:%.1f, volume=%.3f\\n\",\n    i, p, g,\n    i*ichor.weight + p*panacea.weight + g*gold.weight,\n    i*ichor.volume + p*panacea.volume + g*gold.volume \nend\n", "target": "\nusing System;\nclass Program\n{\n    static void Main()\n    {\n        uint[] r = items1();\n        Console.WriteLine(r[0] + \" v  \" + r[1] + \" a  \" + r[2] + \" b\");  \n        var sw = System.Diagnostics.Stopwatch.StartNew();\n        for (int i = 1000; i > 0; i--) items1();\n        Console.Write(sw.Elapsed); Console.Read();\n    }\n\n    static uint[] items0()  \n    {\n        uint v, v0 = 0, a, b, c, a0 = 0, b0 = 0, c0 = 0;\n        for (a = 0; a <= 10; a++)\n            for (b = 0; a * 5 + b * 3 <= 50; b++)\n                for (c = 0; a * 25 + b * 15 + c * 2 <= 250 && a * 3 + b * 2 + c * 20 <= 250; c++)\n                    if (v0 < (v = a * 30 + b * 18 + c * 25))\n                    {\n                        v0 = v; a0 = a; b0 = b; c0 = c;\n                        \n                    }\n        return new uint[] { a0, b0, c0 };\n    }\n\n    static uint[] items1()  \n    {\n        uint v, v0 = 0, a, b, c, a0 = 0, b0 = 0, c0 = 0, c1 = 0;\n        for (a = 0; a <= 10; a++)\n            for (b = 0; a * 5 + b * 3 <= 50; b++)\n            {\n                c = (250 - a * 25 - b * 15) / 2;\n                if ((c1 = (250 - a * 3 - b * 2) / 20) < c) c = c1;\n                if (v0 < (v = a * 30 + b * 18 + c * 25))\n                { v0 = v; a0 = a; b0 = b; c0 = c; }\n            }\n        return new uint[] { a0, b0, c0 };\n    }\n}\n"}
{"id": 105430, "name": "Knapsack problem_Unbounded", "source": "Translate Ruby to Java: KnapsackItem = Struct.new(:volume, :weight, :value)\npanacea = KnapsackItem.new(0.025, 0.3, 3000)\nichor   = KnapsackItem.new(0.015, 0.2, 1800)\ngold    = KnapsackItem.new(0.002, 2.0, 2500)\nmaximum = KnapsackItem.new(0.25,  25,  0)\n\nmax_items = {}\nfor item in [panacea, ichor, gold]\n  max_items[item] = [(maximum.volume/item.volume).to_i, (maximum.weight/item.weight).to_i].min\nend\n\nmaxval = 0\nsolutions = []\n\n0.upto(max_items[ichor]) do |i|\n  0.upto(max_items[panacea]) do |p|\n    0.upto(max_items[gold]) do |g|\n      break if i*ichor.weight + p*panacea.weight + g*gold.weight > maximum.weight\n      break if i*ichor.volume + p*panacea.volume + g*gold.volume > maximum.volume\n      val = i*ichor.value + p*panacea.value + g*gold.value\n      if val > maxval\n        maxval = val\n        solutions = [[i, p, g]]\n      elsif val == maxval\n        solutions << [i, p, g]\n      end\n    end\n  end\nend\n\nputs \"The maximal solution has value \nsolutions.each do |i, p, g|\n  printf \"  ichor=%2d, panacea=%2d, gold=%2d -- weight:%.1f, volume=%.3f\\n\",\n    i, p, g,\n    i*ichor.weight + p*panacea.weight + g*gold.weight,\n    i*ichor.volume + p*panacea.volume + g*gold.volume \nend\n", "target": "package hu.pj.alg;\n\nimport hu.pj.obj.Item;\nimport java.text.*;\n\npublic class UnboundedKnapsack {\n\n    protected Item []  items = {\n                               new Item(\"panacea\", 3000,  0.3, 0.025),\n                               new Item(\"ichor\"  , 1800,  0.2, 0.015),\n                               new Item(\"gold\"   , 2500,  2.0, 0.002)\n                               };\n    protected final int    n = items.length; \n    protected Item      sack = new Item(\"sack\"   ,    0, 25.0, 0.250);\n    protected Item      best = new Item(\"best\"   ,    0,  0.0, 0.000);\n    protected int  []  maxIt = new int [n];  \n    protected int  []    iIt = new int [n];  \n    protected int  [] bestAm = new int [n];  \n\n    public UnboundedKnapsack() {\n        \n        for (int i = 0; i < n; i++) {\n            maxIt [i] = Math.min(\n                           (int)(sack.getWeight() / items[i].getWeight()),\n                           (int)(sack.getVolume() / items[i].getVolume())\n                        );\n        } \n\n        \n        calcWithRecursion(0);\n\n        \n        NumberFormat nf = NumberFormat.getInstance();\n        System.out.println(\"Maximum value achievable is: \" + best.getValue());\n        System.out.print(\"This is achieved by carrying (one solution): \");\n        for (int i = 0; i < n; i++) {\n            System.out.print(bestAm[i] + \" \" + items[i].getName() + \", \");\n        }\n        System.out.println();\n        System.out.println(\"The weight to carry is: \" + nf.format(best.getWeight()) +\n                           \"   and the volume used is: \" + nf.format(best.getVolume())\n                          );\n\n    }\n\n    \n    \n    public void calcWithRecursion(int item) {\n        for (int i = 0; i <= maxIt[item]; i++) {\n            iIt[item] = i;\n            if (item < n-1) {\n                calcWithRecursion(item+1);\n            } else {\n                int    currVal = 0;   \n                double currWei = 0.0; \n                double currVol = 0.0; \n                for (int j = 0; j < n; j++) {\n                    currVal += iIt[j] * items[j].getValue();\n                    currWei += iIt[j] * items[j].getWeight();\n                    currVol += iIt[j] * items[j].getVolume();\n                }\n\n                if (currVal > best.getValue()\n                    &&\n                    currWei <= sack.getWeight()\n                    &&\n                    currVol <= sack.getVolume()\n                )\n                {\n                    best.setValue (currVal);\n                    best.setWeight(currWei);\n                    best.setVolume(currVol);\n                    for (int j = 0; j < n; j++) bestAm[j] = iIt[j];\n                } \n            } \n        } \n    } \n\n    \n    public static void main(String[] args) {\n        new UnboundedKnapsack();\n    } \n\n} \n"}
{"id": 105585, "name": "Variables", "source": "Translate Ruby to C#: $a_global_var = 5\nclass Demo\n  @@a_class_var = 6\n  A_CONSTANT = 8\n  def initialize\n    @an_instance_var = 7\n  end\n  def incr(a_local_var)\n    @an_instance_var += a_local_var\n  end\nend\n", "target": "int j;\n"}
{"id": 105587, "name": "Variables", "source": "Translate Ruby to Java: $a_global_var = 5\nclass Demo\n  @@a_class_var = 6\n  A_CONSTANT = 8\n  def initialize\n    @an_instance_var = 7\n  end\n  def incr(a_local_var)\n    @an_instance_var += a_local_var\n  end\nend\n", "target": "int a;\ndouble b;\nAClassNameHere c;\n"}
{"id": 105588, "name": "Variables", "source": "Translate Ruby to Python: $a_global_var = 5\nclass Demo\n  @@a_class_var = 6\n  A_CONSTANT = 8\n  def initialize\n    @an_instance_var = 7\n  end\n  def incr(a_local_var)\n    @an_instance_var += a_local_var\n  end\nend\n", "target": "\nexample1 = 3\nexample2 = 3.0\nexample3 = True\nexample4 = \"hello\"\n\n\nexample1 = \"goodbye\"\n"}
{"id": 105798, "name": "Sort three variables", "source": "Translate Ruby to C#: x =  'lions, tigers, and'\ny =  'bears, oh my!'\nz =  '(from the \"Wizard of OZ\")'\nx, y, z = [x, y, z].sort\nputs x, y, z\n\nx, y, z = 7.7444e4, -12, 18/2r \nx, y, z = [x, y, z].sort\nputs x, y, z\n", "target": "using System;\npublic class Program\n{\n    public static void Main()\n    {\n        (int x, int y, int z) = (77444, -12, 0);\n\n        \n        if (x > y) (x, y) = (y, x);\n        if (x > z) (x, z) = (z, x);\n        if (y > z) (y, z) = (z, y);\n        Console.WriteLine((x, y, z));\n\n        var (a, b, c) = (\n            \"lions, tigers, and\",\n            \"bears, oh my!\",\n            \"(from the 'Wizard of OZ')\");\n        \n        \n        Sort(ref a, ref b, ref c);\n        Console.WriteLine((a, b, c));\n    }\n    \n    public static void Sort<T>(ref T a, ref T b, ref T c)\n        where T : IComparable<T>\n    {\n        if (a.CompareTo(b) > 0) (a, b) = (b, a);\n        if (a.CompareTo(c) > 0) (a, c) = (c, a);\n        if (b.CompareTo(c) > 0) (b, c) = (c, b);\n    }\n}\n"}
{"id": 105800, "name": "Sort three variables", "source": "Translate Ruby to Java: x =  'lions, tigers, and'\ny =  'bears, oh my!'\nz =  '(from the \"Wizard of OZ\")'\nx, y, z = [x, y, z].sort\nputs x, y, z\n\nx, y, z = 7.7444e4, -12, 18/2r \nx, y, z = [x, y, z].sort\nputs x, y, z\n", "target": "import java.util.Comparator;\nimport java.util.stream.Stream;\n\nclass Box {\n    public int weightKg;\n\n    Box(final int weightKg) {\n        this.weightKg = weightKg;\n    }\n}\n\npublic class Sort3Vars {\n    public static void main(String... args) {\n        int iA = 21;\n        int iB = 11;\n        int iC = 82;\n        int[] sortedInt = Stream.of(iA, iB, iC).sorted().mapToInt(Integer::intValue).toArray();\n        iA = sortedInt[0];\n        iB = sortedInt[1];\n        iC = sortedInt[2];\n        System.out.printf(\"Sorted values: %d %d %d%n\", iA, iB, iC);\n\n        String sA = \"s21\";\n        String sB = \"s11\";\n        String sC = \"s82\";\n        Object[] sortedStr = Stream.of(sA, sB, sC).sorted().toArray();\n        sA = (String) sortedStr[0];\n        sB = (String) sortedStr[1];\n        sC = (String) sortedStr[2];\n        System.out.printf(\"Sorted values: %s %s %s%n\", sA, sB, sC);\n\n        Box bA = new Box(200);\n        Box bB = new Box(12);\n        Box bC = new Box(143);\n        \n        Object[] sortedBox = Stream.of(bA, bB, bC).sorted(Comparator.comparingInt(a -> a.weightKg)).toArray();\n        bA = (Box) sortedBox[0];\n        bB = (Box) sortedBox[1];\n        bC = (Box) sortedBox[2];\n        System.out.printf(\"Sorted Boxes: %dKg %dKg %dKg%n\", bA.weightKg, bB.weightKg, bC.weightKg);\n    }\n}\n"}
{"id": 105801, "name": "Sort three variables", "source": "Translate Ruby to Python: x =  'lions, tigers, and'\ny =  'bears, oh my!'\nz =  '(from the \"Wizard of OZ\")'\nx, y, z = [x, y, z].sort\nputs x, y, z\n\nx, y, z = 7.7444e4, -12, 18/2r \nx, y, z = [x, y, z].sort\nputs x, y, z\n", "target": "\na= raw_input(\"Enter values one by one ..\\n1.\").strip()\nb=raw_input(\"2.\").strip()\nc=raw_input(\"3.\").strip()\nif a>b :\n   a,b = b,a \nif a>c:\n   a,c = c,a \nif b>c:\n   b,c = c,b \nprint(str(a)+\" \"+str(b)+\" \"+str(c))\n"}
{"id": 105955, "name": "Sorting algorithms_Radix sort", "source": "Translate Ruby to C#: class Array\n  def radix_sort(base=10)\n    ary = dup\n    rounds = (Math.log(ary.minmax.map(&:abs).max)/Math.log(base)).floor + 1\n    rounds.times do |i|\n      buckets = Array.new(2*base){[]}\n      base_i = base**i\n      ary.each do |n|\n        digit = (n/base_i) % base\n        digit += base if 0<=n\n        buckets[digit] << n\n      end\n      ary = buckets.flatten\n      p [i, ary] if $DEBUG\n    end\n    ary\n  end\n  def radix_sort!(base=10)\n    replace radix_sort(base)\n  end\nend\n\np [1, 3, 8, 9, 0, 0, 8, 7, 1, 6].radix_sort\np [170, 45, 75, 90, 2, 24, 802, 66].radix_sort\np [170, 45, 75, 90, 2, 24, -802, -66].radix_sort\np [100000, -10000, 400, 23, 10000].radix_sort\n", "target": "using System;\n\nnamespace RadixSort\n{\n    class Program\n    {\n        static void Sort(int[] old)\n        {\n            int i, j;\n            int[] tmp = new int[old.Length];\n            for (int shift = 31; shift > -1; --shift)\n            {\n                j = 0;\n                for (i = 0; i < old.Length; ++i)\n                {\n                    bool move = (old[i] << shift) >= 0;\n                    if (shift == 0 ? !move : move)  \n                        old[i-j] = old[i];\n                    else                            \n                        tmp[j++] = old[i];\n                }\n                Array.Copy(tmp, 0, old, old.Length-j, j);\n            }\n        }\n        static void Main(string[] args)\n        {\n            int[] old = new int[] { 2, 5, 1, -3, 4 };\n            Console.WriteLine(string.Join(\", \", old));\n            Sort(old);\n            Console.WriteLine(string.Join(\", \", old));\n            Console.Read();\n        }\n    }\n}\n"}
{"id": 105957, "name": "Sorting algorithms_Radix sort", "source": "Translate Ruby to Java: class Array\n  def radix_sort(base=10)\n    ary = dup\n    rounds = (Math.log(ary.minmax.map(&:abs).max)/Math.log(base)).floor + 1\n    rounds.times do |i|\n      buckets = Array.new(2*base){[]}\n      base_i = base**i\n      ary.each do |n|\n        digit = (n/base_i) % base\n        digit += base if 0<=n\n        buckets[digit] << n\n      end\n      ary = buckets.flatten\n      p [i, ary] if $DEBUG\n    end\n    ary\n  end\n  def radix_sort!(base=10)\n    replace radix_sort(base)\n  end\nend\n\np [1, 3, 8, 9, 0, 0, 8, 7, 1, 6].radix_sort\np [170, 45, 75, 90, 2, 24, 802, 66].radix_sort\np [170, 45, 75, 90, 2, 24, -802, -66].radix_sort\np [100000, -10000, 400, 23, 10000].radix_sort\n", "target": "public static int[] sort(int[] old) {\n    \n    for (int shift = Integer.SIZE - 1; shift > -1; shift--) {\n        \n        int[] tmp = new int[old.length];\n        \n        int j = 0;\n\n        \n        for (int i = 0; i < old.length; i++) {\n            \n            boolean move = old[i] << shift >= 0;\n\n            \n            if (shift == 0 ? !move : move) {\n                tmp[j] = old[i];\n                j++;\n            } else {\n                \n                old[i - j] = old[i];\n            }\n        }\n\n        \n        for (int i = j; i < tmp.length; i++) {\n            tmp[i] = old[i - j];\n        }\n\n        \n        old = tmp;\n    }\n\n    return old;\n}\n"}
{"id": 105958, "name": "Sorting algorithms_Radix sort", "source": "Translate Ruby to Python: class Array\n  def radix_sort(base=10)\n    ary = dup\n    rounds = (Math.log(ary.minmax.map(&:abs).max)/Math.log(base)).floor + 1\n    rounds.times do |i|\n      buckets = Array.new(2*base){[]}\n      base_i = base**i\n      ary.each do |n|\n        digit = (n/base_i) % base\n        digit += base if 0<=n\n        buckets[digit] << n\n      end\n      ary = buckets.flatten\n      p [i, ary] if $DEBUG\n    end\n    ary\n  end\n  def radix_sort!(base=10)\n    replace radix_sort(base)\n  end\nend\n\np [1, 3, 8, 9, 0, 0, 8, 7, 1, 6].radix_sort\np [170, 45, 75, 90, 2, 24, 802, 66].radix_sort\np [170, 45, 75, 90, 2, 24, -802, -66].radix_sort\np [100000, -10000, 400, 23, 10000].radix_sort\n", "target": "\nfrom math import log\n \ndef getDigit(num, base, digit_num):\n    \n    return (num // base ** digit_num) % base  \n \ndef makeBlanks(size):\n    \n    return [ [] for i in range(size) ]  \n \ndef split(a_list, base, digit_num):\n    buckets = makeBlanks(base)\n    for num in a_list:\n        \n        buckets[getDigit(num, base, digit_num)].append(num)  \n    return buckets\n \n\ndef merge(a_list):\n    new_list = []\n    for sublist in a_list:\n       new_list.extend(sublist)\n    return new_list\n \ndef maxAbs(a_list):\n    \n    return max(abs(num) for num in a_list)\n\ndef split_by_sign(a_list):\n    \n    \n    buckets = [[], []]\n    for num in a_list:\n        if num < 0:\n            buckets[0].append(num)\n        else:\n            buckets[1].append(num)\n    return buckets\n \ndef radixSort(a_list, base):\n    \n    passes = int(round(log(maxAbs(a_list), base)) + 1) \n    new_list = list(a_list)\n    for digit_num in range(passes):\n        new_list = merge(split(new_list, base, digit_num))\n    return merge(split_by_sign(new_list))\n"}
{"id": 106165, "name": "Walk a directory_Non-recursively", "source": "Translate Ruby to C#: \nDir.glob('*') { |file| puts file }\n\n\nDir.glob( File.join('/foo/bar', '*') ) { |file| puts file }\n\n\ndef file_match(pattern=/\\.txt/, path='.')\n  Dir[File.join(path,'*')].each do |file|\n    puts file if file =~ pattern\n  end\nend\n", "target": "using System;\nusing System.IO;\n\nnamespace DirectoryWalk\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            string[] filePaths = Directory.GetFiles(@\"c:\\MyDir\", \"a*\");\n            foreach (string filename in filePaths)\n                Console.WriteLine(filename);            \n        }\n    }\n}\n"}
{"id": 106167, "name": "Walk a directory_Non-recursively", "source": "Translate Ruby to Java: \nDir.glob('*') { |file| puts file }\n\n\nDir.glob( File.join('/foo/bar', '*') ) { |file| puts file }\n\n\ndef file_match(pattern=/\\.txt/, path='.')\n  Dir[File.join(path,'*')].each do |file|\n    puts file if file =~ pattern\n  end\nend\n", "target": "File dir = new File(\"/foo/bar\");\n\nString[] contents = dir.list();\nfor (String file : contents)\n    if (file.endsWith(\".mp3\"))\n        System.out.println(file);\n"}
{"id": 106168, "name": "Walk a directory_Non-recursively", "source": "Translate Ruby to Python: \nDir.glob('*') { |file| puts file }\n\n\nDir.glob( File.join('/foo/bar', '*') ) { |file| puts file }\n\n\ndef file_match(pattern=/\\.txt/, path='.')\n  Dir[File.join(path,'*')].each do |file|\n    puts file if file =~ pattern\n  end\nend\n", "target": "import glob\nfor filename in glob.glob('/foo/bar/*.mp3'):\n    print(filename)\n"}
{"id": 106313, "name": "Miller\u2013Rabin primality test", "source": "Translate Ruby to C#: require \"big\"\n\nmodule Primes\n  module MillerRabin\n\n    def prime?(k = 15)             \n      neg_one_mod = d = self - 1\n      s = 0\n      while d.even?; d >>= 1; s += 1 end  \n      k.times do\n        b = 2 + rand(self - 4)     \n        y = powmod(b, d, self)     \n        next if y == 1 || y == neg_one_mod\n        (s - 1).times do\n          y = (y * y) % self       \n          return false if y == 1\n          break if y == neg_one_mod\n        end\n        return false if y != neg_one_mod\n      end\n      true                         \n    end\n\n    \n    private def powmod(b, e, m)\n      r, b = 1, b.to_big_i\n      while e > 0\n        r = (b * r) % m if e.odd?\n        b = (b * b) % m\n        e >>= 1\n      end\n      r\n    end\n  end\nend\n\nstruct Int; include Primes::MillerRabin end\n\nputs 341521.prime?(20) \nputs 341531.prime?     \n", "target": "public static class RabinMiller\n{\n    public static bool IsPrime(int n, int k)\n    {\n        if ((n < 2) || (n % 2 == 0)) return (n == 2);\n\n        int s = n - 1;\n        while (s % 2 == 0)  s >>= 1;\n\n        Random r = new Random();\n        for (int i = 0; i < k; i++)\n        {\n            int a = r.Next(n - 1) + 1;\n            int temp = s;\n            long mod = 1;\n            for (int j = 0; j < temp; ++j)  mod = (mod * a) % n;\n            while (temp != n - 1 && mod != 1 && mod != n - 1)\n            {\n                mod = (mod * mod) % n;\n                temp *= 2;\n            }\n\n            if (mod != n - 1 && temp % 2 == 0) return false;\n        }\n        return true;\n    }\n}\n"}
{"id": 106314, "name": "Miller\u2013Rabin primality test", "source": "Translate Ruby to Java: require \"big\"\n\nmodule Primes\n  module MillerRabin\n\n    def prime?(k = 15)             \n      neg_one_mod = d = self - 1\n      s = 0\n      while d.even?; d >>= 1; s += 1 end  \n      k.times do\n        b = 2 + rand(self - 4)     \n        y = powmod(b, d, self)     \n        next if y == 1 || y == neg_one_mod\n        (s - 1).times do\n          y = (y * y) % self       \n          return false if y == 1\n          break if y == neg_one_mod\n        end\n        return false if y != neg_one_mod\n      end\n      true                         \n    end\n\n    \n    private def powmod(b, e, m)\n      r, b = 1, b.to_big_i\n      while e > 0\n        r = (b * r) % m if e.odd?\n        b = (b * b) % m\n        e >>= 1\n      end\n      r\n    end\n  end\nend\n\nstruct Int; include Primes::MillerRabin end\n\nputs 341521.prime?(20) \nputs 341531.prime?     \n", "target": "import java.math.BigInteger;\n\npublic class MillerRabinPrimalityTest {\n  public static void main(String[] args) {\n    BigInteger n = new BigInteger(args[0]);\n    int certainty = Integer.parseInt(args[1]);\n    System.out.println(n.toString() + \" is \" + (n.isProbablePrime(certainty) ? \"probably prime\" : \"composite\"));\n  }\n}\n"}
{"id": 106315, "name": "Miller\u2013Rabin primality test", "source": "Translate Ruby to Python: require \"big\"\n\nmodule Primes\n  module MillerRabin\n\n    def prime?(k = 15)             \n      neg_one_mod = d = self - 1\n      s = 0\n      while d.even?; d >>= 1; s += 1 end  \n      k.times do\n        b = 2 + rand(self - 4)     \n        y = powmod(b, d, self)     \n        next if y == 1 || y == neg_one_mod\n        (s - 1).times do\n          y = (y * y) % self       \n          return false if y == 1\n          break if y == neg_one_mod\n        end\n        return false if y != neg_one_mod\n      end\n      true                         \n    end\n\n    \n    private def powmod(b, e, m)\n      r, b = 1, b.to_big_i\n      while e > 0\n        r = (b * r) % m if e.odd?\n        b = (b * b) % m\n        e >>= 1\n      end\n      r\n    end\n  end\nend\n\nstruct Int; include Primes::MillerRabin end\n\nputs 341521.prime?(20) \nputs 341531.prime?     \n", "target": "import random\n\ndef is_Prime(n):\n    \n    if n!=int(n):\n        return False\n    n=int(n)\n    \n    if n==0 or n==1 or n==4 or n==6 or n==8 or n==9:\n        return False\n        \n    if n==2 or n==3 or n==5 or n==7:\n        return True\n    s = 0\n    d = n-1\n    while d%2==0:\n        d>>=1\n        s+=1\n    assert(2**s * d == n-1)\n  \n    def trial_composite(a):\n        if pow(a, d, n) == 1:\n            return False\n        for i in range(s):\n            if pow(a, 2**i * d, n) == n-1:\n                return False\n        return True  \n \n    for i in range(8):\n        a = random.randrange(2, n)\n        if trial_composite(a):\n            return False\n \n    return True\n"}
{"id": 106476, "name": "Bulls and cows_Player", "source": "Translate Ruby to C#: size = 4\nscores = [] of Tuple(Int32, Int32)\nguesses = [] of Array(Char)\nputs \"Playing Bulls & Cows with \npossible_guesses = ('1'..'9').to_a.permutations(size).shuffle\n\nloop do\n  guesses << (current_guess = possible_guesses.pop)\n  print \"Guess \n  bulls, cows = gets.not_nil!.split(',').map(&.to_i)\n  scores << (score = {bulls, cows})\n\n  \n  break (puts \"Yeah!\") if score == {size, 0}\n\n  \n  possible_guesses.select! do |guess|\n    bulls = guess.zip(current_guess).count { |g, cg| g == cg }\n    cows = size - (guess - current_guess).size - bulls\n    {bulls, cows} == score\n  end\n\n  \n  if possible_guesses.empty?\n    puts \"Error in scoring?\"\n    guesses.zip(scores).each { |g, (b, c)| puts \"\n    break\n  end\nend\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\nnamespace BullsAndCows\n{\n    class Program\n    {\n        const int ANSWER_SIZE = 4;\n\n        static IEnumerable<string> Permutations(int size)\n        {\n            if (size > 0)\n            {\n                foreach (string s in Permutations(size - 1))\n                    foreach (char n in \"123456789\")\n                        if (!s.Contains(n))\n                            yield return s + n;\n            }\n            else\n                yield return \"\";\n        }\n\n        static IEnumerable<T> Shuffle<T>(IEnumerable<T> source)\n        {\n            Random random = new Random();\n            List<T> list = source.ToList();\n            while (list.Count > 0)\n            {\n                int ix = random.Next(list.Count);\n                yield return list[ix];\n                list.RemoveAt(ix);\n            }\n        }\n\n        static bool ReadBullsCows(out int bulls, out int cows)\n        {\n            string[] input = Console.ReadLine().Split(',').ToArray();\n            bulls = cows = 0;\n            if (input.Length < 2)\n                return false;\n            else\n                return int.TryParse(input[0], out bulls)\n                    && int.TryParse(input[1], out cows);\n        }\n\n        static void Main(string[] args)\n        {\n            Console.WriteLine(\"Bulls and Cows\");\n            Console.WriteLine(\"==============\");\n            Console.WriteLine();\n            List<string> answers = Shuffle(Permutations(ANSWER_SIZE)).ToList();\n            while (answers.Count > 1)\n            {\n                string guess = answers[0];\n                Console.Write(\"My guess is {0}. How many bulls, cows? \", guess);\n                int bulls, cows;\n                if (!ReadBullsCows(out bulls, out cows))\n                    Console.WriteLine(\"Sorry, I didn't understand that. Please try again.\");\n                else\n                    for (int ans = answers.Count - 1; ans >= 0; ans--)\n                    {\n                        int tb = 0, tc = 0;\n                        for (int ix = 0; ix < ANSWER_SIZE; ix++)\n                            if (answers[ans][ix] == guess[ix])\n                                tb++;\n                            else if (answers[ans].Contains(guess[ix]))\n                                tc++;\n                        if ((tb != bulls) || (tc != cows))\n                            answers.RemoveAt(ans);\n                    }\n            }\n            if (answers.Count == 1)\n                Console.WriteLine(\"Hooray! The answer is {0}!\", answers[0]);\n            else\n                Console.WriteLine(\"No possible answer fits the scores you gave.\");\n        }\n    }\n}\n"}
{"id": 106478, "name": "Bulls and cows_Player", "source": "Translate Ruby to Java: size = 4\nscores = [] of Tuple(Int32, Int32)\nguesses = [] of Array(Char)\nputs \"Playing Bulls & Cows with \npossible_guesses = ('1'..'9').to_a.permutations(size).shuffle\n\nloop do\n  guesses << (current_guess = possible_guesses.pop)\n  print \"Guess \n  bulls, cows = gets.not_nil!.split(',').map(&.to_i)\n  scores << (score = {bulls, cows})\n\n  \n  break (puts \"Yeah!\") if score == {size, 0}\n\n  \n  possible_guesses.select! do |guess|\n    bulls = guess.zip(current_guess).count { |g, cg| g == cg }\n    cows = size - (guess - current_guess).size - bulls\n    {bulls, cows} == score\n  end\n\n  \n  if possible_guesses.empty?\n    puts \"Error in scoring?\"\n    guesses.zip(scores).each { |g, (b, c)| puts \"\n    break\n  end\nend\n", "target": "public class BullsAndCowsPlayerGame {\n\n    private static int count;\n    private static Console io = System.console();\n\n    private final GameNumber secret;\n    private List<AutoGuessNumber> pool = new ArrayList<>();\n\n    public BullsAndCowsPlayerGame(GameNumber secret) {\n        this.secret = secret;\n        fillPool();\n    }\n\n    private void fillPool() {\n        for (int i = 123; i < 9877; i++) {\n            int[] arr = AutoGuessNumber.parseDigits(i, 4);\n\n            if (GameNumber.isGuess(arr)) {\n                pool.add(new AutoGuessNumber(i, 4));\n            }\n        }\n    }\n\n    public void play() {\n        io.printf(\"Bulls and Cows%n\");\n        io.printf(\"==============%n\");\n        io.printf(\"Secret number is %s%n\", secret);\n\n        do {\n            AutoGuessNumber guess = guessNumber();\n            io.printf(\"Guess #%d is %s from %d%n\", count, guess, pool.size());\n\n            GuessResult result = secret.match(guess);\n            if (result != null) {\n                printScore(io, result);\n\n                if (result.isWin()) {\n                    io.printf(\"The answer is %s%n\", guess);\n                    break;\n                }\n\n                clearPool(guess, result);\n            } else {\n                io.printf(\"No more variants%n\");\n                System.exit(0);\n            }\n        } while (true);\n    }\n\n    private AutoGuessNumber guessNumber() {\n        Random random = new Random();\n        if (pool.size() > 0) {\n            int number = random.nextInt(pool.size());\n            count++;\n            return pool.get(number);\n        }\n        return null;\n    }\n\n    private static void printScore(Console io, GuessResult result) {\n        io.printf(\"%1$d  %2$d%n\", result.getBulls(), result.getCows());\n    }\n\n    private void clearPool(AutoGuessNumber guess, GuessResult guessResult) {\n        pool.remove(guess);\n\n        for (int i = 0; i < pool.size(); i++) {\n            AutoGuessNumber g = pool.get(i);\n            GuessResult gr = guess.match(g);\n\n            if (!guessResult.equals(gr)) {\n                pool.remove(g);\n            }\n        }\n    }\n\n    public static void main(String[] args) {\n        new BullsAndCowsPlayerGame(new GameNumber()).play();\n    }\n}\n"}
{"id": 106479, "name": "Bulls and cows_Player", "source": "Translate Ruby to Python: size = 4\nscores = [] of Tuple(Int32, Int32)\nguesses = [] of Array(Char)\nputs \"Playing Bulls & Cows with \npossible_guesses = ('1'..'9').to_a.permutations(size).shuffle\n\nloop do\n  guesses << (current_guess = possible_guesses.pop)\n  print \"Guess \n  bulls, cows = gets.not_nil!.split(',').map(&.to_i)\n  scores << (score = {bulls, cows})\n\n  \n  break (puts \"Yeah!\") if score == {size, 0}\n\n  \n  possible_guesses.select! do |guess|\n    bulls = guess.zip(current_guess).count { |g, cg| g == cg }\n    cows = size - (guess - current_guess).size - bulls\n    {bulls, cows} == score\n  end\n\n  \n  if possible_guesses.empty?\n    puts \"Error in scoring?\"\n    guesses.zip(scores).each { |g, (b, c)| puts \"\n    break\n  end\nend\n", "target": "from itertools import permutations\nfrom random import shuffle\n\ntry:\n    raw_input\nexcept:\n    raw_input = input\ntry:\n    from itertools import izip\nexcept:\n    izip = zip\n    \ndigits = '123456789'\nsize = 4\n\ndef parse_score(score):\n    score = score.strip().split(',')\n    return tuple(int(s.strip()) for s in score)\n\ndef scorecalc(guess, chosen):\n    bulls = cows = 0\n    for g,c in izip(guess, chosen):\n        if g == c:\n            bulls += 1\n        elif g in chosen:\n            cows += 1\n    return bulls, cows\n\nchoices = list(permutations(digits, size))\nshuffle(choices)\nanswers = []\nscores  = []\n\nprint (\"Playing Bulls & Cows with %i unique digits\\n\" % size)\n       \nwhile True:\n    ans = choices[0]\n    answers.append(ans)\n    \n    score = raw_input(\"Guess %2i is %*s. Answer (Bulls, cows)? \"\n                      % (len(answers), size, ''.join(ans)))\n    score = parse_score(score)\n    scores.append(score)\n    \n    found =  score == (size, 0)\n    if found:\n        print (\"Ye-haw!\")\n        break\n    choices = [c for c in choices if scorecalc(c, ans) == score]\n    if not choices:\n        print (\"Bad scoring? nothing fits those scores you gave:\")\n        print ('  ' +\n               '\\n  '.join(\"%s -> %s\" % (''.join(an),sc)\n                           for an,sc in izip(answers, scores)))\n        break\n"}
{"id": 106820, "name": "Last Friday of each month", "source": "Translate Ruby to C#: require 'date'\n\ndef last_friday(year, month)\n  \n  d = Date.new(year, month, -1)\n  d -= (d.wday - 5) % 7  \nend\n\nyear = Integer(ARGV.shift)\n(1..12).each {|month| puts last_friday(year, month)}\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Globalization;\nusing System.Linq;\n\nnamespace RosettaCode.LastFridaysOfYear\n{\n    internal static class Program\n    {\n        private static IEnumerable<DateTime> LastFridaysOfYear(int year)\n        {\n            for (var month = 1; month <= 12; month++)\n            {\n                var date = new DateTime(year, month, 1).AddMonths(1).AddDays(-1);\n                while (date.DayOfWeek != DayOfWeek.Friday)\n                {\n                    date = date.AddDays(-1);\n                }\n                yield return date;\n            }\n        }\n\n        private static void Main(string[] arguments)\n        {\n            int year;\n            var argument = arguments.FirstOrDefault();\n            if (string.IsNullOrEmpty(argument) || !int.TryParse(argument, out year))\n            {\n                year = DateTime.Today.Year;\n            }\n\n            foreach (var date in LastFridaysOfYear(year))\n            {\n                Console.WriteLine(date.ToString(\"d\", CultureInfo.InvariantCulture));\n            }\n        }\n    }\n}\n"}
{"id": 106821, "name": "Last Friday of each month", "source": "Translate Ruby to C#: require 'date'\n\ndef last_friday(year, month)\n  \n  d = Date.new(year, month, -1)\n  d -= (d.wday - 5) % 7  \nend\n\nyear = Integer(ARGV.shift)\n(1..12).each {|month| puts last_friday(year, month)}\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Globalization;\nusing System.Linq;\n\nnamespace RosettaCode.LastFridaysOfYear\n{\n    internal static class Program\n    {\n        private static IEnumerable<DateTime> LastFridaysOfYear(int year)\n        {\n            for (var month = 1; month <= 12; month++)\n            {\n                var date = new DateTime(year, month, 1).AddMonths(1).AddDays(-1);\n                while (date.DayOfWeek != DayOfWeek.Friday)\n                {\n                    date = date.AddDays(-1);\n                }\n                yield return date;\n            }\n        }\n\n        private static void Main(string[] arguments)\n        {\n            int year;\n            var argument = arguments.FirstOrDefault();\n            if (string.IsNullOrEmpty(argument) || !int.TryParse(argument, out year))\n            {\n                year = DateTime.Today.Year;\n            }\n\n            foreach (var date in LastFridaysOfYear(year))\n            {\n                Console.WriteLine(date.ToString(\"d\", CultureInfo.InvariantCulture));\n            }\n        }\n    }\n}\n"}
{"id": 106824, "name": "Last Friday of each month", "source": "Translate Ruby to Java: require 'date'\n\ndef last_friday(year, month)\n  \n  d = Date.new(year, month, -1)\n  d -= (d.wday - 5) % 7  \nend\n\nyear = Integer(ARGV.shift)\n(1..12).each {|month| puts last_friday(year, month)}\n", "target": "import java.text.*;\nimport java.util.*;\n\npublic class LastFridays {\n\n    public static void main(String[] args) throws Exception {\n        int year = Integer.parseInt(args[0]);\n        GregorianCalendar c = new GregorianCalendar(year, 0, 1);\n\n        for (String mon : new DateFormatSymbols(Locale.US).getShortMonths()) {\n            if (!mon.isEmpty()) {\n                int totalDaysOfMonth = c.getActualMaximum(Calendar.DAY_OF_MONTH);\n                c.set(Calendar.DAY_OF_MONTH, totalDaysOfMonth);\n\n                int daysToRollBack = (c.get(Calendar.DAY_OF_WEEK) + 1) % 7;\n\n                int day = totalDaysOfMonth - daysToRollBack;\n                c.set(Calendar.DAY_OF_MONTH, day);\n\n                System.out.printf(\"%d %s %d\\n\", year, mon, day);\n\n                c.set(year, c.get(Calendar.MONTH) + 1, 1);\n            }\n        }\n    }\n}\n"}
{"id": 106825, "name": "Last Friday of each month", "source": "Translate Ruby to Java: require 'date'\n\ndef last_friday(year, month)\n  \n  d = Date.new(year, month, -1)\n  d -= (d.wday - 5) % 7  \nend\n\nyear = Integer(ARGV.shift)\n(1..12).each {|month| puts last_friday(year, month)}\n", "target": "import java.text.*;\nimport java.util.*;\n\npublic class LastFridays {\n\n    public static void main(String[] args) throws Exception {\n        int year = Integer.parseInt(args[0]);\n        GregorianCalendar c = new GregorianCalendar(year, 0, 1);\n\n        for (String mon : new DateFormatSymbols(Locale.US).getShortMonths()) {\n            if (!mon.isEmpty()) {\n                int totalDaysOfMonth = c.getActualMaximum(Calendar.DAY_OF_MONTH);\n                c.set(Calendar.DAY_OF_MONTH, totalDaysOfMonth);\n\n                int daysToRollBack = (c.get(Calendar.DAY_OF_WEEK) + 1) % 7;\n\n                int day = totalDaysOfMonth - daysToRollBack;\n                c.set(Calendar.DAY_OF_MONTH, day);\n\n                System.out.printf(\"%d %s %d\\n\", year, mon, day);\n\n                c.set(year, c.get(Calendar.MONTH) + 1, 1);\n            }\n        }\n    }\n}\n"}
{"id": 106826, "name": "Last Friday of each month", "source": "Translate Ruby to Python: require 'date'\n\ndef last_friday(year, month)\n  \n  d = Date.new(year, month, -1)\n  d -= (d.wday - 5) % 7  \nend\n\nyear = Integer(ARGV.shift)\n(1..12).each {|month| puts last_friday(year, month)}\n", "target": "import calendar\n\ndef last_fridays(year):\n    for month in range(1, 13):\n        last_friday = max(week[calendar.FRIDAY]\n            for week in calendar.monthcalendar(year, month))\n        print('{:4d}-{:02d}-{:02d}'.format(year, month, last_friday))\n"}
{"id": 106827, "name": "Last Friday of each month", "source": "Translate Ruby to Python: require 'date'\n\ndef last_friday(year, month)\n  \n  d = Date.new(year, month, -1)\n  d -= (d.wday - 5) % 7  \nend\n\nyear = Integer(ARGV.shift)\n(1..12).each {|month| puts last_friday(year, month)}\n", "target": "import calendar\n\ndef last_fridays(year):\n    for month in range(1, 13):\n        last_friday = max(week[calendar.FRIDAY]\n            for week in calendar.monthcalendar(year, month))\n        print('{:4d}-{:02d}-{:02d}'.format(year, month, last_friday))\n"}
{"id": 107152, "name": "Date format", "source": "Translate Ruby to C#: puts Time.now\nputs Time.now.strftime('%Y-%m-%d')\nputs Time.now.strftime('%F')            \nputs Time.now.strftime('%A, %B %d, %Y')\n", "target": "using System;\n\nnamespace RosettaCode.DateFormat\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            DateTime today = DateTime.Now.Date;\n            Console.WriteLine(today.ToString(\"yyyy-MM-dd\"));\n            Console.WriteLine(today.ToString(\"dddd, MMMMM d, yyyy\"));\n        }\n    }\n}\n"}
{"id": 107154, "name": "Date format", "source": "Translate Ruby to Java: puts Time.now\nputs Time.now.strftime('%Y-%m-%d')\nputs Time.now.strftime('%F')            \nputs Time.now.strftime('%A, %B %d, %Y')\n", "target": "Datetime dtNow = datetime.now();\nString strDt1 = dtNow.format('yyyy-MM-dd');\nString strDt2 = dtNow.format('EEEE, MMMM dd, yyyy');\nsystem.debug(strDt1); \nsystem.debug(strDt2); \n"}
{"id": 107155, "name": "Date format", "source": "Translate Ruby to Python: puts Time.now\nputs Time.now.strftime('%Y-%m-%d')\nputs Time.now.strftime('%F')            \nputs Time.now.strftime('%A, %B %d, %Y')\n", "target": "import datetime\ntoday = datetime.date.today()\n\ntoday.isoformat()\n\ntoday.strftime(\"%A, %B %d, %Y\")\n\n\n\"The date is {0:%A, %B %d, %Y}\".format(d)\n\n\"The date is {date:%A, %B %d, %Y}\".format(date=d)\n\nf\"The date is {d:%A, %B %d, %Y}\"\n"}
{"id": 107410, "name": "XML_Input", "source": "Translate Ruby to C#: require 'rexml/document'\ninclude REXML\n\ndoc = Document.new(File.new(\"sample.xml\"))\n\n\n\n\ndoc.each_recursive do |node|\n  puts node.attributes[\"Name\"] if node.name == \"Student\"\nend\n\n\ndoc.each_element(\"*/Student\") {|node| puts node.attributes[\"Name\"]}\n", "target": "class Program\n{\n    static void Main(string[] args)\n    {   \n        XDocument xmlDoc = XDocument.Load(\"XMLFile1.xml\");\n        var query = from p in xmlDoc.Descendants(\"Student\")\n                    select p.Attribute(\"Name\");\n\n        foreach (var item in query)\n        {\n            Console.WriteLine(item.Value);\n        }\n        Console.ReadLine();\n    }  \n}\n"}
{"id": 107412, "name": "XML_Input", "source": "Translate Ruby to Java: require 'rexml/document'\ninclude REXML\n\ndoc = Document.new(File.new(\"sample.xml\"))\n\n\n\n\ndoc.each_recursive do |node|\n  puts node.attributes[\"Name\"] if node.name == \"Student\"\nend\n\n\ndoc.each_element(\"*/Student\") {|node| puts node.attributes[\"Name\"]}\n", "target": "import java.io.IOException;\nimport java.io.StringReader;\nimport org.xml.sax.Attributes;\nimport org.xml.sax.InputSource;\nimport org.xml.sax.SAXException;\nimport org.xml.sax.XMLReader;\nimport org.xml.sax.helpers.DefaultHandler;\nimport org.xml.sax.helpers.XMLReaderFactory;\n\npublic class StudentHandler extends DefaultHandler {\n  public static void main(String[] args)throws Exception{\n    String xml = \"<Students>\\n\"+\n    \"<Student Name=\\\"April\\\" Gender=\\\"F\\\" DateOfBirth=\\\"1989-01-02\\\" />\\n\"+\n    \"<Student Name=\\\"Bob\\\" Gender=\\\"M\\\"  DateOfBirth=\\\"1990-03-04\\\" />\\n\"+\n    \"<Student Name=\\\"Chad\\\" Gender=\\\"M\\\"  DateOfBirth=\\\"1991-05-06\\\" />\\n\"+\n    \"<Student Name=\\\"Dave\\\" Gender=\\\"M\\\"  DateOfBirth=\\\"1992-07-08\\\">\\n\"+\n    \"  <Pet Type=\\\"dog\\\" Name=\\\"Rover\\\" />\\n\"+\n    \"</Student>\\n\"+\n    \"<Student DateOfBirth=\\\"1993-09-10\\\" Gender=\\\"F\\\" Name=\\\"&#x00C9;mily\\\" />\\n\"+\n    \"</Students>\";\n    StudentHandler handler = new StudentHandler();\n    handler.parse(new InputSource(new StringReader(xml)));\n  }\n\n  public void parse(InputSource src) throws SAXException, IOException {\n\t\tXMLReader parser = XMLReaderFactory.createXMLReader();\n    parser.setContentHandler(this);\n    parser.parse(src);\n  }\n\n  @Override\n  public void characters(char[] ch, int start, int length) throws SAXException {\n    \n    \n    super.characters(ch, start, length);\n  }\n\n  @Override\n  public void endElement(String uri, String localName, String qName) throws SAXException {\n    \n    \n    super.endElement(uri, localName, qName);\n  }\n\n  @Override\n  public void startElement(String uri, String localName, String qName, Attributes attributes) throws SAXException {\n    if(qName.equals(\"Student\")){\n      System.out.println(attributes.getValue(\"Name\"));\n    }\n  }\n}\n"}
{"id": 107413, "name": "XML_Input", "source": "Translate Ruby to Python: require 'rexml/document'\ninclude REXML\n\ndoc = Document.new(File.new(\"sample.xml\"))\n\n\n\n\ndoc.each_recursive do |node|\n  puts node.attributes[\"Name\"] if node.name == \"Student\"\nend\n\n\ndoc.each_element(\"*/Student\") {|node| puts node.attributes[\"Name\"]}\n", "target": "import xml.dom.minidom\n\ndoc = \n\ndoc = xml.dom.minidom.parseString(doc)\n\nfor i in doc.getElementsByTagName(\"Student\"):\n    print i.getAttribute(\"Name\")\n"}
{"id": 107707, "name": "Exponentiation order", "source": "Translate Ruby to C#: ar = [\"5**3**2\", \"(5**3)**2\", \"5**(3**2)\", \"[5,3,2].inject(:**)\"]\nar.each{|exp| puts \"\n", "target": "using System;\n\nnamespace exponents\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            \n            Console.WriteLine(Math.Pow(Math.Pow(5, 3), 2));\n            Console.WriteLine(Math.Pow(5, Math.Pow(3, 2)));\n            Console.Read();\n        }\n\n    }\n}\n"}
{"id": 107708, "name": "Exponentiation order", "source": "Translate Ruby to C#: ar = [\"5**3**2\", \"(5**3)**2\", \"5**(3**2)\", \"[5,3,2].inject(:**)\"]\nar.each{|exp| puts \"\n", "target": "using System;\n\nnamespace exponents\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            \n            Console.WriteLine(Math.Pow(Math.Pow(5, 3), 2));\n            Console.WriteLine(Math.Pow(5, Math.Pow(3, 2)));\n            Console.Read();\n        }\n\n    }\n}\n"}
{"id": 107711, "name": "Exponentiation order", "source": "Translate Ruby to Python: ar = [\"5**3**2\", \"(5**3)**2\", \"5**(3**2)\", \"[5,3,2].inject(:**)\"]\nar.each{|exp| puts \"\n", "target": ">>> 5**3**2\n1953125\n>>> (5**3)**2\n15625\n>>> 5**(3**2)\n1953125\n>>> \n>>> try: from functools import reduce \nexcept: pass\n\n>>> reduce(pow, (5, 3, 2))\n15625\n>>>\n"}
{"id": 107712, "name": "Exponentiation order", "source": "Translate Ruby to Python: ar = [\"5**3**2\", \"(5**3)**2\", \"5**(3**2)\", \"[5,3,2].inject(:**)\"]\nar.each{|exp| puts \"\n", "target": ">>> 5**3**2\n1953125\n>>> (5**3)**2\n15625\n>>> 5**(3**2)\n1953125\n>>> \n>>> try: from functools import reduce \nexcept: pass\n\n>>> reduce(pow, (5, 3, 2))\n15625\n>>>\n"}
{"id": 107983, "name": "Loops_For with a specified step", "source": "Translate Ruby to C#: 2.step(8,2) {|n| print \"\nputs \"who do we appreciate?\"\n", "target": "using System;\n \nclass Program {\n    static void Main(string[] args) {    \n        for (int i = 2; i <= 8; i+= 2) {        \n            Console.Write(\"{0}, \", i);\n        }\n\n        Console.WriteLine(\"who do we appreciate?\");\n    }\n}\n"}
{"id": 107985, "name": "Loops_For with a specified step", "source": "Translate Ruby to Java: 2.step(8,2) {|n| print \"\nputs \"who do we appreciate?\"\n", "target": "for(int i = 2; i <= 8;i += 2){\n   System.out.print(i + \", \");\n}\nSystem.out.println(\"who do we appreciate?\");\n"}
{"id": 107986, "name": "Loops_For with a specified step", "source": "Translate Ruby to Python: 2.step(8,2) {|n| print \"\nputs \"who do we appreciate?\"\n", "target": "for i in xrange(2, 9, 2):\n    print \"%d,\" % i,\nprint \"who do we appreciate?\"\n"}
{"id": 108234, "name": "Queue_Usage", "source": "Translate Ruby to C#: q = Queue.new\nq.push \"Hello\"  \nq.push \"world\"\np q.pop         \np q.empty?      \n", "target": "using System;\nusing System.Collections.Generic;\n\nnamespace RosettaCode\n{\n    class Program\n    {\n        static void Main()\n        {\n            \n            Queue<int> queue  = new Queue<int>();\n            queue.Enqueue(1);\n            queue.Enqueue(3);\n            queue.Enqueue(5);\n\n            \n            Console.WriteLine(queue.Dequeue()); \n            Console.WriteLine(queue.Dequeue()); \n            Console.WriteLine(queue.Dequeue()); \n\n            \n            bool empty = queue.Count == 0;\n            Console.WriteLine(empty); \n\n            \n            \n            try\n            {\n                queue.Dequeue();\n            }\n            catch (InvalidOperationException exception)\n            {\n                Console.WriteLine(exception.Message); \n            }\n        }\n    }\n}\n"}
{"id": 108236, "name": "Queue_Usage", "source": "Translate Ruby to Java: q = Queue.new\nq.push \"Hello\"  \nq.push \"world\"\np q.pop         \np q.empty?      \n", "target": "import java.util.LinkedList;\nimport java.util.Queue;\n...\nQueue<Integer> queue = new LinkedList<Integer>();\nSystem.out.println(queue.isEmpty());      \n\nqueue.add(1);\nqueue.add(2);\nqueue.add(3);\nSystem.out.println(queue);                \nSystem.out.println(queue.remove());       \nSystem.out.println(queue);                \nSystem.out.println(queue.isEmpty());      \n"}
{"id": 108237, "name": "Queue_Usage", "source": "Translate Ruby to Python: q = Queue.new\nq.push \"Hello\"  \nq.push \"world\"\np q.pop         \np q.empty?      \n", "target": "let my_queue = Queue()\n\nmy_queue.push!('foo')\nmy_queue.push!('bar')\nmy_queue.push!('baz')\n\nprint my_queue.pop!() \nprint my_queue.pop!() \nprint my_queue.pop!() \n"}
{"id": 108571, "name": "Generator_Exponential", "source": "Translate Ruby to C#: \n\ndef powers(m)\n  return enum_for(__method__, m) unless block_given?\n  0.step{|n| yield n**m}\nend\n\ndef squares_without_cubes\n  return enum_for(__method__) unless block_given?\n  \n  cubes = powers(3)\n  c = cubes.next\n  powers(2) do |s|\n    c = cubes.next while c < s\n    yield s unless c == s\n  end\nend\n\np squares_without_cubes.take(30).drop(20)\n\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\nstatic class Program {\n    static void Main() {\n        Func<int, IEnumerable<int>> ms = m => Infinite().Select(i => (int)Math.Pow(i, m));\n        var squares = ms(2);\n        var cubes = ms(3);\n        var filtered = squares.Where(square => cubes.First(cube => cube >= square) != square);\n        var final = filtered.Skip(20).Take(10);\n        foreach (var i in final) Console.WriteLine(i);\n    }\n\n    static IEnumerable<int> Infinite() {\n        var i = 0;\n        while (true) yield return i++;\n    }\n}\n"}
{"id": 108572, "name": "Generator_Exponential", "source": "Translate Ruby to C#: \n\ndef powers(m)\n  return enum_for(__method__, m) unless block_given?\n  0.step{|n| yield n**m}\nend\n\ndef squares_without_cubes\n  return enum_for(__method__) unless block_given?\n  \n  cubes = powers(3)\n  c = cubes.next\n  powers(2) do |s|\n    c = cubes.next while c < s\n    yield s unless c == s\n  end\nend\n\np squares_without_cubes.take(30).drop(20)\n\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\nstatic class Program {\n    static void Main() {\n        Func<int, IEnumerable<int>> ms = m => Infinite().Select(i => (int)Math.Pow(i, m));\n        var squares = ms(2);\n        var cubes = ms(3);\n        var filtered = squares.Where(square => cubes.First(cube => cube >= square) != square);\n        var final = filtered.Skip(20).Take(10);\n        foreach (var i in final) Console.WriteLine(i);\n    }\n\n    static IEnumerable<int> Infinite() {\n        var i = 0;\n        while (true) yield return i++;\n    }\n}\n"}
{"id": 108575, "name": "Generator_Exponential", "source": "Translate Ruby to Java: \n\ndef powers(m)\n  return enum_for(__method__, m) unless block_given?\n  0.step{|n| yield n**m}\nend\n\ndef squares_without_cubes\n  return enum_for(__method__) unless block_given?\n  \n  cubes = powers(3)\n  c = cubes.next\n  powers(2) do |s|\n    c = cubes.next while c < s\n    yield s unless c == s\n  end\nend\n\np squares_without_cubes.take(30).drop(20)\n\n", "target": "import java.util.function.LongSupplier;\nimport static java.util.stream.LongStream.generate;\n\npublic class GeneratorExponential implements LongSupplier {\n    private LongSupplier source, filter;\n    private long s, f;\n\n    public GeneratorExponential(LongSupplier source, LongSupplier filter) {\n        this.source = source;\n        this.filter = filter;\n        f = filter.getAsLong();\n    }\n\n    @Override\n    public long getAsLong() {\n        s = source.getAsLong();\n\n        while (s == f) {\n            s = source.getAsLong();\n            f = filter.getAsLong();\n        }\n\n        while (s > f) {\n            f = filter.getAsLong();\n        }\n\n        return s;\n    }\n\n    public static void main(String[] args) {\n        generate(new GeneratorExponential(new SquaresGen(), new CubesGen()))\n                .skip(20).limit(10)\n                .forEach(n -> System.out.printf(\"%d \", n));\n    }\n}\n\nclass SquaresGen implements LongSupplier {\n    private long n;\n\n    @Override\n    public long getAsLong() {\n        return n * n++;\n    }\n}\n\nclass CubesGen implements LongSupplier {\n    private long n;\n\n    @Override\n    public long getAsLong() {\n        return n * n * n++;\n    }\n}\n"}
{"id": 108576, "name": "Generator_Exponential", "source": "Translate Ruby to Java: \n\ndef powers(m)\n  return enum_for(__method__, m) unless block_given?\n  0.step{|n| yield n**m}\nend\n\ndef squares_without_cubes\n  return enum_for(__method__) unless block_given?\n  \n  cubes = powers(3)\n  c = cubes.next\n  powers(2) do |s|\n    c = cubes.next while c < s\n    yield s unless c == s\n  end\nend\n\np squares_without_cubes.take(30).drop(20)\n\n", "target": "import java.util.function.LongSupplier;\nimport static java.util.stream.LongStream.generate;\n\npublic class GeneratorExponential implements LongSupplier {\n    private LongSupplier source, filter;\n    private long s, f;\n\n    public GeneratorExponential(LongSupplier source, LongSupplier filter) {\n        this.source = source;\n        this.filter = filter;\n        f = filter.getAsLong();\n    }\n\n    @Override\n    public long getAsLong() {\n        s = source.getAsLong();\n\n        while (s == f) {\n            s = source.getAsLong();\n            f = filter.getAsLong();\n        }\n\n        while (s > f) {\n            f = filter.getAsLong();\n        }\n\n        return s;\n    }\n\n    public static void main(String[] args) {\n        generate(new GeneratorExponential(new SquaresGen(), new CubesGen()))\n                .skip(20).limit(10)\n                .forEach(n -> System.out.printf(\"%d \", n));\n    }\n}\n\nclass SquaresGen implements LongSupplier {\n    private long n;\n\n    @Override\n    public long getAsLong() {\n        return n * n++;\n    }\n}\n\nclass CubesGen implements LongSupplier {\n    private long n;\n\n    @Override\n    public long getAsLong() {\n        return n * n * n++;\n    }\n}\n"}
{"id": 108577, "name": "Generator_Exponential", "source": "Translate Ruby to Python: \n\ndef powers(m)\n  return enum_for(__method__, m) unless block_given?\n  0.step{|n| yield n**m}\nend\n\ndef squares_without_cubes\n  return enum_for(__method__) unless block_given?\n  \n  cubes = powers(3)\n  c = cubes.next\n  powers(2) do |s|\n    c = cubes.next while c < s\n    yield s unless c == s\n  end\nend\n\np squares_without_cubes.take(30).drop(20)\n\n", "target": "from itertools import islice, count\n\ndef powers(m):\n    for n in count():\n        yield n ** m\n    \ndef filtered(s1, s2):\n    v, f = next(s1), next(s2)\n    while True:\n        if v > f:\n            f = next(s2)\n            continue\n        elif v < f:\n            yield v\n        v = next(s1)\n\nsquares, cubes = powers(2), powers(3)\nf = filtered(squares, cubes)\nprint(list(islice(f, 20, 30)))\n"}
{"id": 108578, "name": "Generator_Exponential", "source": "Translate Ruby to Python: \n\ndef powers(m)\n  return enum_for(__method__, m) unless block_given?\n  0.step{|n| yield n**m}\nend\n\ndef squares_without_cubes\n  return enum_for(__method__) unless block_given?\n  \n  cubes = powers(3)\n  c = cubes.next\n  powers(2) do |s|\n    c = cubes.next while c < s\n    yield s unless c == s\n  end\nend\n\np squares_without_cubes.take(30).drop(20)\n\n", "target": "from itertools import islice, count\n\ndef powers(m):\n    for n in count():\n        yield n ** m\n    \ndef filtered(s1, s2):\n    v, f = next(s1), next(s2)\n    while True:\n        if v > f:\n            f = next(s2)\n            continue\n        elif v < f:\n            yield v\n        v = next(s1)\n\nsquares, cubes = powers(2), powers(3)\nf = filtered(squares, cubes)\nprint(list(islice(f, 20, 30)))\n"}
{"id": 108893, "name": "Loops_Break", "source": "Translate Ruby to C#: loop do\n  a = rand(20)\n  print a\n  if a == 10\n    puts\n    break\n  end\n  b = rand(20)\n  puts \"\\t\nend\n", "target": "class Program\n{\n    static void Main(string[] args)\n    {\n        Random random = new Random();\n        while (true)\n        {\n            int a = random.Next(20);\n            Console.WriteLine(a);\n            if (a == 10)\n                break;\n            int b = random.Next(20)\n            Console.WriteLine(b);\n        }\n           \n        Console.ReadLine();\n    }       \n}\n"}
{"id": 108895, "name": "Loops_Break", "source": "Translate Ruby to Java: loop do\n  a = rand(20)\n  print a\n  if a == 10\n    puts\n    break\n  end\n  b = rand(20)\n  puts \"\\t\nend\n", "target": "import java.util.Random;\n\nRandom rand = new Random();\nwhile(true){\n    int a = rand.nextInt(20);\n    System.out.println(a);\n    if(a == 10) break;\n    int b = rand.nextInt(20);\n    System.out.println(b);\n}\n"}
{"id": 108896, "name": "Loops_Break", "source": "Translate Ruby to Python: loop do\n  a = rand(20)\n  print a\n  if a == 10\n    puts\n    break\n  end\n  b = rand(20)\n  puts \"\\t\nend\n", "target": "from random import randrange\n\nwhile True:\n    a = randrange(20)\n    print(a)\n    if a == 10:\n        break\n    b = randrange(20)\n    print(b)\n"}
{"id": 109140, "name": "Non-decimal radices_Convert", "source": "Translate Ruby to C#: class String\n  def convert_base(from, to)\n    Integer(self, from).to_s(to)  \n    \n  end\nend\n\n\np \"12345\".convert_base(10, 23) \np \"107h\".convert_base(23, 7) \np \"50664\".convert_base(7, 10) \np \"1038334289300125869792154778345043071467300\".convert_base(10, 36) \np \"ff\".convert_base(15, 10) \n", "target": "public static class BaseConverter {\n\n    \n    \n    \n    \n    \n    \n    public static long stringToLong(string s, int b) {\n\n        if ( b < 2 || b > 36 )\n            throw new ArgumentException(\"Base must be between 2 and 36\", \"b\");\n\n        checked {\n\n            int slen = s.Length;\n            long result = 0;\n            bool isNegative = false;\n\n            for ( int i = 0; i < slen; i++ ) {\n\n                char c = s[i];\n                int num;\n\n                if ( c == '-' ) {\n                    \n                    if ( i != 0 )\n                        throw new ArgumentException(\"A negative sign is allowed only as the first character of the string.\", \"s\");\n\n                    isNegative = true;\n                    continue;\n                }\n\n                if ( c > 0x2F && c < 0x3A )\n                    \n                    num = c - 0x30;\n                else if ( c > 0x40 && c < 0x5B )\n                    \n                    \n                    num = c - 0x37;  \n                else if ( c > 0x60 && c < 0x7B )\n                    \n                    \n                    num = c - 0x57;  \n                else\n                    throw new ArgumentException(\"The string contains an invalid character '\" + c + \"'\", \"s\");\n\n                \n\n                if ( num >= b )\n                    throw new ArgumentException(\"The string contains a character '\" + c + \"' which is not allowed in base \" + b, \"s\");\n\n                \n\n                result *= b;\n                result += num;\n\n            }\n\n            if ( isNegative )\n                result = -result;\n\n            return result;\n\n        }\n\n    }\n\n    \n    \n    \n    \n    \n    \n    public static string longToString(long n, int b) {\n        \n        \n        \n        \n        if ( b < 2 || b > 36 )\n            throw new ArgumentException(\"Base must be between 2 and 36\", \"b\");\n\n        \n\n        if ( b == 10 )\n            return n.ToString();\n\n        checked {\n            long longBase = b;\n            \n            StringBuilder sb = new StringBuilder();\n            \n            if ( n < 0 ) {\n                \n                n = -n;\n                sb.Append('-');\n            }\n            \n            long div = 1;\n            while ( n / div >= b )\n                \n                \n                div *= b;\n            \n            while ( true ) {\n                byte digit = (byte) (n / div);\n            \n                if ( digit < 10 )\n                    \n                    sb.Append((char) (digit + 0x30));\n                else\n                    \n                    sb.Append((char) (digit + 0x57));  \n            \n                if ( div == 1 )\n                    \n                    break;\n            \n                n %= div;\n                div /= b;\n            }\n            \n            return sb.ToString();\n        }\n\n    }\n\n}\n"}
{"id": 109142, "name": "Non-decimal radices_Convert", "source": "Translate Ruby to Java: class String\n  def convert_base(from, to)\n    Integer(self, from).to_s(to)  \n    \n  end\nend\n\n\np \"12345\".convert_base(10, 23) \np \"107h\".convert_base(23, 7) \np \"50664\".convert_base(7, 10) \np \"1038334289300125869792154778345043071467300\".convert_base(10, 36) \np \"ff\".convert_base(15, 10) \n", "target": "public static long backToTen(String num, int oldBase){\n   return Long.parseLong(num, oldBase); \n}\n\npublic static String tenToBase(long num, int newBase){\n   return Long.toString(num, newBase);\n}\n"}
{"id": 109143, "name": "Non-decimal radices_Convert", "source": "Translate Ruby to Python: class String\n  def convert_base(from, to)\n    Integer(self, from).to_s(to)  \n    \n  end\nend\n\n\np \"12345\".convert_base(10, 23) \np \"107h\".convert_base(23, 7) \np \"50664\".convert_base(7, 10) \np \"1038334289300125869792154778345043071467300\".convert_base(10, 36) \np \"ff\".convert_base(15, 10) \n", "target": "i = int('1a',16)  \n"}
{"id": 109328, "name": "Inverted index", "source": "Translate Ruby to C#: if File.exist? \"index.dat\"\n  @data = Marshal.load open(\"index.dat\")\nelse\n  @data = {}\nend\n\n\n\nclass String\n  def index_sanitize\n    self.split.collect do |token|\n      token.downcase.gsub(/\\W/, '')\n    end\n  end\nend\n\n\nARGV.each do |filename|\n  open filename do |file|\n    file.read.index_sanitize.each do |word|\n      @data[word] ||= []\n      @data[word] << filename unless @data[word].include? filename\n    end\n  end\nend\n\nopen(\"index.dat\", \"w\") do |index|\n  index.write Marshal.dump(@data)\nend\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.IO;\nusing System.Linq;\n\nclass InvertedIndex\n{\n    static Dictionary<TItem, IEnumerable<TKey>> Invert<TKey, TItem>(Dictionary<TKey, IEnumerable<TItem>> dictionary)\n    {\n        return dictionary\n            .SelectMany(keyValuePair => keyValuePair.Value.Select(item => new KeyValuePair<TItem, TKey>(item, keyValuePair.Key)))\n            .GroupBy(keyValuePair => keyValuePair.Key)\n            .ToDictionary(group => group.Key, group => group.Select(keyValuePair => keyValuePair.Value));\n    }\n\n    static void Main()\n    {\n        Console.Write(\"files: \");\n        var files = Console.ReadLine();\n        Console.Write(\"find: \");\n        var find = Console.ReadLine();\n        var dictionary = files.Split().ToDictionary(file => file, file => File.ReadAllText(file).Split().AsEnumerable());\n        Console.WriteLine(\"{0} found in: {1}\", find, string.Join(\" \", Invert(dictionary)[find]));\n    }\n}\n"}
{"id": 109330, "name": "Inverted index", "source": "Translate Ruby to Java: if File.exist? \"index.dat\"\n  @data = Marshal.load open(\"index.dat\")\nelse\n  @data = {}\nend\n\n\n\nclass String\n  def index_sanitize\n    self.split.collect do |token|\n      token.downcase.gsub(/\\W/, '')\n    end\n  end\nend\n\n\nARGV.each do |filename|\n  open filename do |file|\n    file.read.index_sanitize.each do |word|\n      @data[word] ||= []\n      @data[word] << filename unless @data[word].include? filename\n    end\n  end\nend\n\nopen(\"index.dat\", \"w\") do |index|\n  index.write Marshal.dump(@data)\nend\n", "target": "package org.rosettacode;\n\nimport java.io.BufferedReader;\nimport java.io.File;\nimport java.io.FileReader;\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\n\npublic class InvertedIndex {\n\n    List<String> stopwords = Arrays.asList(\"a\", \"able\", \"about\",\n            \"across\", \"after\", \"all\", \"almost\", \"also\", \"am\", \"among\", \"an\",\n            \"and\", \"any\", \"are\", \"as\", \"at\", \"be\", \"because\", \"been\", \"but\",\n            \"by\", \"can\", \"cannot\", \"could\", \"dear\", \"did\", \"do\", \"does\",\n            \"either\", \"else\", \"ever\", \"every\", \"for\", \"from\", \"get\", \"got\",\n            \"had\", \"has\", \"have\", \"he\", \"her\", \"hers\", \"him\", \"his\", \"how\",\n            \"however\", \"i\", \"if\", \"in\", \"into\", \"is\", \"it\", \"its\", \"just\",\n            \"least\", \"let\", \"like\", \"likely\", \"may\", \"me\", \"might\", \"most\",\n            \"must\", \"my\", \"neither\", \"no\", \"nor\", \"not\", \"of\", \"off\", \"often\",\n            \"on\", \"only\", \"or\", \"other\", \"our\", \"own\", \"rather\", \"said\", \"say\",\n            \"says\", \"she\", \"should\", \"since\", \"so\", \"some\", \"than\", \"that\",\n            \"the\", \"their\", \"them\", \"then\", \"there\", \"these\", \"they\", \"this\",\n            \"tis\", \"to\", \"too\", \"twas\", \"us\", \"wants\", \"was\", \"we\", \"were\",\n            \"what\", \"when\", \"where\", \"which\", \"while\", \"who\", \"whom\", \"why\",\n            \"will\", \"with\", \"would\", \"yet\", \"you\", \"your\");\n\n    Map<String, List<Tuple>> index = new HashMap<String, List<Tuple>>();\n    List<String> files = new ArrayList<String>();\n\n    public void indexFile(File file) throws IOException {\n        int fileno = files.indexOf(file.getPath());\n        if (fileno == -1) {\n            files.add(file.getPath());\n            fileno = files.size() - 1;\n        }\n\n        int pos = 0;\n        BufferedReader reader = new BufferedReader(new FileReader(file));\n        for (String line = reader.readLine(); line != null; line = reader\n                .readLine()) {\n            for (String _word : line.split(\"\\\\W+\")) {\n                String word = _word.toLowerCase();\n                pos++;\n                if (stopwords.contains(word))\n                    continue;\n                List<Tuple> idx = index.get(word);\n                if (idx == null) {\n                    idx = new LinkedList<Tuple>();\n                    index.put(word, idx);\n                }\n                idx.add(new Tuple(fileno, pos));\n            }\n        }\n        System.out.println(\"indexed \" + file.getPath() + \" \" + pos + \" words\");\n    }\n\n    public void search(List<String> words) {\n        for (String _word : words) {\n            Set<String> answer = new HashSet<String>();\n            String word = _word.toLowerCase();\n            List<Tuple> idx = index.get(word);\n            if (idx != null) {\n                for (Tuple t : idx) {\n                    answer.add(files.get(t.fileno));\n                }\n            }\n            System.out.print(word);\n            for (String f : answer) {\n                System.out.print(\" \" + f);\n            }\n            System.out.println(\"\");\n        }\n    }\n\n    public static void main(String[] args) {\n        try {\n            InvertedIndex idx = new InvertedIndex();\n            for (int i = 1; i < args.length; i++) {\n                idx.indexFile(new File(args[i]));\n            }\n            idx.search(Arrays.asList(args[0].split(\",\")));\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n    private class Tuple {\n        private int fileno;\n        private int position;\n\n        public Tuple(int fileno, int position) {\n            this.fileno = fileno;\n            this.position = position;\n        }\n    }\n}\n"}
{"id": 109331, "name": "Inverted index", "source": "Translate Ruby to Python: if File.exist? \"index.dat\"\n  @data = Marshal.load open(\"index.dat\")\nelse\n  @data = {}\nend\n\n\n\nclass String\n  def index_sanitize\n    self.split.collect do |token|\n      token.downcase.gsub(/\\W/, '')\n    end\n  end\nend\n\n\nARGV.each do |filename|\n  open filename do |file|\n    file.read.index_sanitize.each do |word|\n      @data[word] ||= []\n      @data[word] << filename unless @data[word].include? filename\n    end\n  end\nend\n\nopen(\"index.dat\", \"w\") do |index|\n  index.write Marshal.dump(@data)\nend\n", "target": "\n\nfrom pprint import pprint as pp\nfrom glob import glob\ntry: reduce\nexcept: from functools import reduce\ntry:    raw_input\nexcept: raw_input = input\n\n\ndef parsetexts(fileglob='InvertedIndex/T*.txt'):\n    texts, words = {}, set()\n    for txtfile in glob(fileglob):\n        with open(txtfile, 'r') as f:\n            txt = f.read().split()\n            words |= set(txt)\n            texts[txtfile.split('\\\\')[-1]] = txt\n    return texts, words\n\ndef termsearch(terms): \n    return reduce(set.intersection,\n                  (invindex[term] for term in terms),\n                  set(texts.keys()))\n\ntexts, words = parsetexts()\nprint('\\nTexts')\npp(texts)\nprint('\\nWords')\npp(sorted(words))\n\ninvindex = {word:set(txt\n                        for txt, wrds in texts.items() if word in wrds)\n            for word in words}\nprint('\\nInverted Index')\npp({k:sorted(v) for k,v in invindex.items()})\n\nterms = [\"what\", \"is\", \"it\"]\nprint('\\nTerm Search for: ' + repr(terms))\npp(sorted(termsearch(terms)))\n"}
{"id": 109572, "name": "Factors of an integer", "source": "Translate Ruby to C#: struct Int\n  def factors() (1..self).select { |n| (self % n).zero? } end\nend\n", "target": "static void Main (string[] args) {\n    do {\n        Console.WriteLine (\"Number:\");\n        Int64 p = 0;\n        do {\n            try {\n                p = Convert.ToInt64 (Console.ReadLine ());\n                break;\n            } catch (Exception) { }\n\n        } while (true);\n\n        Console.WriteLine (\"For 1 through \" + ((int) Math.Sqrt (p)).ToString () + \"\");\n        for (int x = 1; x <= (int) Math.Sqrt (p); x++) {\n            if (p % x == 0)\n                Console.WriteLine (\"Found: \" + x.ToString () + \". \" + p.ToString () + \" / \" + x.ToString () + \" = \" + (p / x).ToString ());\n        }\n\n        Console.WriteLine (\"Done.\");\n    } while (true);\n}\n"}
{"id": 109574, "name": "Factors of an integer", "source": "Translate Ruby to Java: struct Int\n  def factors() (1..self).select { |n| (self % n).zero? } end\nend\n", "target": "public static TreeSet<Long> factors(long n)\n{\n TreeSet<Long> factors = new TreeSet<Long>();\n factors.add(n);\n factors.add(1L);\n for(long test = n - 1; test >= Math.sqrt(n); test--)\n  if(n % test == 0)\n  {\n   factors.add(test);\n   factors.add(n / test);\n  }\n return factors;\n}\n"}
{"id": 109575, "name": "Factors of an integer", "source": "Translate Ruby to Python: struct Int\n  def factors() (1..self).select { |n| (self % n).zero? } end\nend\n", "target": ">>> def factors(n):\n      return [i for i in range(1, n + 1) if not n%i]\n"}
{"id": 109839, "name": "Regular expressions", "source": "Translate Ruby to C#: str = \"I am a string\"\np \"Ends with 'string'\" if str =~ /string$/\np \"Does not start with 'You'\" unless str =~ /^You/\n", "target": "using System;\nusing System.Text.RegularExpressions;\n\nclass Program {\n    static void Main(string[] args) {\n        string str = \"I am a string\";\n\n        if (new Regex(\"string$\").IsMatch(str)) {\n            Console.WriteLine(\"Ends with string.\");\n        }\n\n        str = new Regex(\" a \").Replace(str, \" another \");\n        Console.WriteLine(str);\n    }\n}\n"}
{"id": 109841, "name": "Regular expressions", "source": "Translate Ruby to Java: str = \"I am a string\"\np \"Ends with 'string'\" if str =~ /string$/\np \"Does not start with 'You'\" unless str =~ /^You/\n", "target": "String str = \"I am a string\";\nif (str.matches(\".*string\")) { \n  System.out.println(\"ends with 'string'\");\n}\n"}
{"id": 109842, "name": "Regular expressions", "source": "Translate Ruby to Python: str = \"I am a string\"\np \"Ends with 'string'\" if str =~ /string$/\np \"Does not start with 'You'\" unless str =~ /^You/\n", "target": "import re\n\nstring = \"This is a string\"\n\nif re.search('string$', string):\n    print(\"Ends with string.\")\n\nstring = re.sub(\" a \", \" another \", string)\nprint(string)\n"}
{"id": 110299, "name": "Anagrams_Deranged anagrams", "source": "Translate Ruby to C#: def deranged?(a, b)\n  a.chars.zip(b.chars).all? {|char_a, char_b| char_a != char_b}\nend\n\ndef find_derangements(list)\n  list.combination(2) {|a,b| return a,b  if deranged?(a,b)}\n  nil\nend\n\nrequire 'open-uri'\nanagram = open('http://www.puzzlers.org/pub/wordlists/unixdict.txt') do |f|\n  f.read.split.group_by {|s| s.each_char.sort}\nend\n\nanagram = anagram.select{|k,list| list.size>1}.sort_by{|k,list| -k.size}\n\nanagram.each do |k,list|\n  if derangements = find_derangements(list)\n    puts \"Longest derangement anagram: \n    break\n  end\nend\n", "target": "public static void Main()\n{\n    var lookupTable = File.ReadLines(\"unixdict.txt\").ToLookup(line => AnagramKey(line));\n    var query = from a in lookupTable\n        orderby a.Key.Length descending\n        let deranged = FindDeranged(a)\n        where deranged != null\n        select deranged[0] + \" \" + deranged[1];\n    Console.WriteLine(query.FirstOrDefault());\n}\n\t\nstatic string AnagramKey(string word) => new string(word.OrderBy(c => c).ToArray());\n\t\nstatic string[] FindDeranged(IEnumerable<string> anagrams) => (\n    from first in anagrams\n    from second in anagrams\n    where !second.Equals(first)\n        && Enumerable.Range(0, first.Length).All(i => first[i] != second[i])\n    select new [] { first, second })\n    .FirstOrDefault();\n"}
{"id": 110300, "name": "Anagrams_Deranged anagrams", "source": "Translate Ruby to C#: def deranged?(a, b)\n  a.chars.zip(b.chars).all? {|char_a, char_b| char_a != char_b}\nend\n\ndef find_derangements(list)\n  list.combination(2) {|a,b| return a,b  if deranged?(a,b)}\n  nil\nend\n\nrequire 'open-uri'\nanagram = open('http://www.puzzlers.org/pub/wordlists/unixdict.txt') do |f|\n  f.read.split.group_by {|s| s.each_char.sort}\nend\n\nanagram = anagram.select{|k,list| list.size>1}.sort_by{|k,list| -k.size}\n\nanagram.each do |k,list|\n  if derangements = find_derangements(list)\n    puts \"Longest derangement anagram: \n    break\n  end\nend\n", "target": "public static void Main()\n{\n    var lookupTable = File.ReadLines(\"unixdict.txt\").ToLookup(line => AnagramKey(line));\n    var query = from a in lookupTable\n        orderby a.Key.Length descending\n        let deranged = FindDeranged(a)\n        where deranged != null\n        select deranged[0] + \" \" + deranged[1];\n    Console.WriteLine(query.FirstOrDefault());\n}\n\t\nstatic string AnagramKey(string word) => new string(word.OrderBy(c => c).ToArray());\n\t\nstatic string[] FindDeranged(IEnumerable<string> anagrams) => (\n    from first in anagrams\n    from second in anagrams\n    where !second.Equals(first)\n        && Enumerable.Range(0, first.Length).All(i => first[i] != second[i])\n    select new [] { first, second })\n    .FirstOrDefault();\n"}
{"id": 110303, "name": "Anagrams_Deranged anagrams", "source": "Translate Ruby to Java: def deranged?(a, b)\n  a.chars.zip(b.chars).all? {|char_a, char_b| char_a != char_b}\nend\n\ndef find_derangements(list)\n  list.combination(2) {|a,b| return a,b  if deranged?(a,b)}\n  nil\nend\n\nrequire 'open-uri'\nanagram = open('http://www.puzzlers.org/pub/wordlists/unixdict.txt') do |f|\n  f.read.split.group_by {|s| s.each_char.sort}\nend\n\nanagram = anagram.select{|k,list| list.size>1}.sort_by{|k,list| -k.size}\n\nanagram.each do |k,list|\n  if derangements = find_derangements(list)\n    puts \"Longest derangement anagram: \n    break\n  end\nend\n", "target": "import java.io.File;\nimport java.io.IOException;\nimport java.nio.file.Files;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\n \npublic class DerangedAnagrams {\n \n    public static void main(String[] args) throws IOException {\n        List<String> words = Files.readAllLines(new File(\"unixdict.txt\").toPath());\n        printLongestDerangedAnagram(words);\n    }\n \n    private static void printLongestDerangedAnagram(List<String> words) {\n        words.sort(Comparator.comparingInt(String::length).reversed().thenComparing(String::toString));\n\n        Map<String, ArrayList<String>> map = new HashMap<>();\n        for (String word : words) {\n            char[] chars = word.toCharArray();\n            Arrays.sort(chars);\n            String key = String.valueOf(chars);\n\n            List<String> anagrams = map.computeIfAbsent(key, k -> new ArrayList<>());\n            for (String anagram : anagrams) {\n                if (isDeranged(word, anagram)) {\n                    System.out.printf(\"%s %s%n\", anagram, word);\n                    return;\n                }\n            }\n            anagrams.add(word);\n        }\n        System.out.println(\"no result\");\n    }\n\n    private static boolean isDeranged(String word1, String word2) {\n        for (int i = 0; i < word1.length(); i++) {\n            if (word1.charAt(i) == word2.charAt(i)) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\n"}
{"id": 110304, "name": "Anagrams_Deranged anagrams", "source": "Translate Ruby to Python: def deranged?(a, b)\n  a.chars.zip(b.chars).all? {|char_a, char_b| char_a != char_b}\nend\n\ndef find_derangements(list)\n  list.combination(2) {|a,b| return a,b  if deranged?(a,b)}\n  nil\nend\n\nrequire 'open-uri'\nanagram = open('http://www.puzzlers.org/pub/wordlists/unixdict.txt') do |f|\n  f.read.split.group_by {|s| s.each_char.sort}\nend\n\nanagram = anagram.select{|k,list| list.size>1}.sort_by{|k,list| -k.size}\n\nanagram.each do |k,list|\n  if derangements = find_derangements(list)\n    puts \"Longest derangement anagram: \n    break\n  end\nend\n", "target": "import urllib.request\nfrom collections import defaultdict\nfrom itertools import combinations\n\ndef getwords(url='http://www.puzzlers.org/pub/wordlists/unixdict.txt'):\n    return list(set(urllib.request.urlopen(url).read().decode().split()))\n\ndef find_anagrams(words):\n    anagram = defaultdict(list) \n    for word in words:\n        anagram[tuple(sorted(word))].append( word )\n    return dict((key, words) for key, words in anagram.items()\n                if len(words) > 1)\n\ndef is_deranged(words):\n    'returns pairs of words that have no character in the same position'\n    return [ (word1, word2)\n             for word1,word2 in combinations(words, 2)\n             if all(ch1 != ch2 for ch1, ch2 in zip(word1, word2)) ]\n\ndef largest_deranged_ana(anagrams):\n    ordered_anagrams = sorted(anagrams.items(),\n                              key=lambda x:(-len(x[0]), x[0]))\n    for _, words in ordered_anagrams:\n        deranged_pairs = is_deranged(words)\n        if deranged_pairs:\n            return deranged_pairs\n    return []\n\nif __name__ == '__main__':\n    words = getwords('http://www.puzzlers.org/pub/wordlists/unixdict.txt')\n    print(\"Word count:\", len(words))\n\n    anagrams = find_anagrams(words)\n    print(\"Anagram count:\", len(anagrams),\"\\n\")\n\n    print(\"Longest anagrams with no characters in the same position:\")\n    print('  ' + '\\n  '.join(', '.join(pairs)\n                             for pairs in largest_deranged_ana(anagrams)))\n"}
{"id": 110305, "name": "Anagrams_Deranged anagrams", "source": "Translate Ruby to Python: def deranged?(a, b)\n  a.chars.zip(b.chars).all? {|char_a, char_b| char_a != char_b}\nend\n\ndef find_derangements(list)\n  list.combination(2) {|a,b| return a,b  if deranged?(a,b)}\n  nil\nend\n\nrequire 'open-uri'\nanagram = open('http://www.puzzlers.org/pub/wordlists/unixdict.txt') do |f|\n  f.read.split.group_by {|s| s.each_char.sort}\nend\n\nanagram = anagram.select{|k,list| list.size>1}.sort_by{|k,list| -k.size}\n\nanagram.each do |k,list|\n  if derangements = find_derangements(list)\n    puts \"Longest derangement anagram: \n    break\n  end\nend\n", "target": "import urllib.request\nfrom collections import defaultdict\nfrom itertools import combinations\n\ndef getwords(url='http://www.puzzlers.org/pub/wordlists/unixdict.txt'):\n    return list(set(urllib.request.urlopen(url).read().decode().split()))\n\ndef find_anagrams(words):\n    anagram = defaultdict(list) \n    for word in words:\n        anagram[tuple(sorted(word))].append( word )\n    return dict((key, words) for key, words in anagram.items()\n                if len(words) > 1)\n\ndef is_deranged(words):\n    'returns pairs of words that have no character in the same position'\n    return [ (word1, word2)\n             for word1,word2 in combinations(words, 2)\n             if all(ch1 != ch2 for ch1, ch2 in zip(word1, word2)) ]\n\ndef largest_deranged_ana(anagrams):\n    ordered_anagrams = sorted(anagrams.items(),\n                              key=lambda x:(-len(x[0]), x[0]))\n    for _, words in ordered_anagrams:\n        deranged_pairs = is_deranged(words)\n        if deranged_pairs:\n            return deranged_pairs\n    return []\n\nif __name__ == '__main__':\n    words = getwords('http://www.puzzlers.org/pub/wordlists/unixdict.txt')\n    print(\"Word count:\", len(words))\n\n    anagrams = find_anagrams(words)\n    print(\"Anagram count:\", len(anagrams),\"\\n\")\n\n    print(\"Longest anagrams with no characters in the same position:\")\n    print('  ' + '\\n  '.join(', '.join(pairs)\n                             for pairs in largest_deranged_ana(anagrams)))\n"}
{"id": 110724, "name": "Gapful numbers", "source": "Translate Ruby to C#: struct Int\n  def gapful?\n    a = self.to_s.chars.map(&.to_i)\n    self % (a.first*10 + a.last) == 0\n  end\nend\n\nspecs = {100 => 30, 1_000_000 => 15, 1_000_000_000 => 10, 7123 => 25}\n\nspecs.each do |start, count|\n  puts \"first \n  puts (start..).each.select(&.gapful?).first(count).to_a, \"\\n\"\nend\n", "target": "using System;\n\nnamespace GapfulNumbers\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            Console.WriteLine(\"The first 30 gapful numbers are: \");\n            \n            FindGap(100, 30);\n\n            Console.WriteLine(\"The first 15 gapful numbers > 1,000,000 are: \");\n            FindGap(1000000, 15);\n\n            Console.WriteLine(\"The first 10 gapful numbers > 1,000,000,000 are: \");\n            FindGap(1000000000, 10);\n\n            Console.Read();\n        }\n\n        public static int firstNum(int n)\n        {\n            \n            while (n >= 10)\n            {\n                n /= 10;\n            }\n            return (n);\n        }\n\n        public static int lastNum(int n)\n        {\n            \n            return (n % 10);\n        }\n\n        static void FindGap(int n, int gaps)\n        {\n            int count = 0;\n            while (count < gaps)\n            {\n\n                \n                string concat = firstNum(n).ToString() + lastNum(n).ToString();\n                \n                int i = Convert.ToInt32(concat);\n\n                \n                if (n % i == 0)\n                {\n                    Console.Write(n + \" \");\n                    count++;\n                    n++;\n                }\n                else\n                {\n                    n++;\n                    continue;\n                }\n            }\n        }\n    }\n}\n"}
{"id": 110725, "name": "Gapful numbers", "source": "Translate Ruby to C#: struct Int\n  def gapful?\n    a = self.to_s.chars.map(&.to_i)\n    self % (a.first*10 + a.last) == 0\n  end\nend\n\nspecs = {100 => 30, 1_000_000 => 15, 1_000_000_000 => 10, 7123 => 25}\n\nspecs.each do |start, count|\n  puts \"first \n  puts (start..).each.select(&.gapful?).first(count).to_a, \"\\n\"\nend\n", "target": "using System;\n\nnamespace GapfulNumbers\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            Console.WriteLine(\"The first 30 gapful numbers are: \");\n            \n            FindGap(100, 30);\n\n            Console.WriteLine(\"The first 15 gapful numbers > 1,000,000 are: \");\n            FindGap(1000000, 15);\n\n            Console.WriteLine(\"The first 10 gapful numbers > 1,000,000,000 are: \");\n            FindGap(1000000000, 10);\n\n            Console.Read();\n        }\n\n        public static int firstNum(int n)\n        {\n            \n            while (n >= 10)\n            {\n                n /= 10;\n            }\n            return (n);\n        }\n\n        public static int lastNum(int n)\n        {\n            \n            return (n % 10);\n        }\n\n        static void FindGap(int n, int gaps)\n        {\n            int count = 0;\n            while (count < gaps)\n            {\n\n                \n                string concat = firstNum(n).ToString() + lastNum(n).ToString();\n                \n                int i = Convert.ToInt32(concat);\n\n                \n                if (n % i == 0)\n                {\n                    Console.Write(n + \" \");\n                    count++;\n                    n++;\n                }\n                else\n                {\n                    n++;\n                    continue;\n                }\n            }\n        }\n    }\n}\n"}
{"id": 110728, "name": "Gapful numbers", "source": "Translate Ruby to Java: struct Int\n  def gapful?\n    a = self.to_s.chars.map(&.to_i)\n    self % (a.first*10 + a.last) == 0\n  end\nend\n\nspecs = {100 => 30, 1_000_000 => 15, 1_000_000_000 => 10, 7123 => 25}\n\nspecs.each do |start, count|\n  puts \"first \n  puts (start..).each.select(&.gapful?).first(count).to_a, \"\\n\"\nend\n", "target": "import java.util.List;\n\npublic class GapfulNumbers {\n    private static String commatize(long n) {\n        StringBuilder sb = new StringBuilder(Long.toString(n));\n        int le = sb.length();\n        for (int i = le - 3; i >= 1; i -= 3) {\n            sb.insert(i, ',');\n        }\n        return sb.toString();\n    }\n\n    public static void main(String[] args) {\n        List<Long> starts = List.of((long) 1e2, (long) 1e6, (long) 1e7, (long) 1e9, (long) 7123);\n        List<Integer> counts = List.of(30, 15, 15, 10, 25);\n        for (int i = 0; i < starts.size(); ++i) {\n            int count = 0;\n            Long j = starts.get(i);\n            long pow = 100;\n            while (j >= pow * 10) {\n                pow *= 10;\n            }\n            System.out.printf(\"First %d gapful numbers starting at %s:\\n\", counts.get(i), commatize(starts.get(i)));\n            while (count < counts.get(i)) {\n                long fl = (j / pow) * 10 + (j % 10);\n                if (j % fl == 0) {\n                    System.out.printf(\"%d \", j);\n                    count++;\n                }\n                j++;\n                if (j >= 10 * pow) {\n                    pow *= 10;\n                }\n            }\n            System.out.println('\\n');\n        }\n    }\n}\n"}
{"id": 110729, "name": "Gapful numbers", "source": "Translate Ruby to Java: struct Int\n  def gapful?\n    a = self.to_s.chars.map(&.to_i)\n    self % (a.first*10 + a.last) == 0\n  end\nend\n\nspecs = {100 => 30, 1_000_000 => 15, 1_000_000_000 => 10, 7123 => 25}\n\nspecs.each do |start, count|\n  puts \"first \n  puts (start..).each.select(&.gapful?).first(count).to_a, \"\\n\"\nend\n", "target": "import java.util.List;\n\npublic class GapfulNumbers {\n    private static String commatize(long n) {\n        StringBuilder sb = new StringBuilder(Long.toString(n));\n        int le = sb.length();\n        for (int i = le - 3; i >= 1; i -= 3) {\n            sb.insert(i, ',');\n        }\n        return sb.toString();\n    }\n\n    public static void main(String[] args) {\n        List<Long> starts = List.of((long) 1e2, (long) 1e6, (long) 1e7, (long) 1e9, (long) 7123);\n        List<Integer> counts = List.of(30, 15, 15, 10, 25);\n        for (int i = 0; i < starts.size(); ++i) {\n            int count = 0;\n            Long j = starts.get(i);\n            long pow = 100;\n            while (j >= pow * 10) {\n                pow *= 10;\n            }\n            System.out.printf(\"First %d gapful numbers starting at %s:\\n\", counts.get(i), commatize(starts.get(i)));\n            while (count < counts.get(i)) {\n                long fl = (j / pow) * 10 + (j % 10);\n                if (j % fl == 0) {\n                    System.out.printf(\"%d \", j);\n                    count++;\n                }\n                j++;\n                if (j >= 10 * pow) {\n                    pow *= 10;\n                }\n            }\n            System.out.println('\\n');\n        }\n    }\n}\n"}
{"id": 110730, "name": "Gapful numbers", "source": "Translate Ruby to Python: struct Int\n  def gapful?\n    a = self.to_s.chars.map(&.to_i)\n    self % (a.first*10 + a.last) == 0\n  end\nend\n\nspecs = {100 => 30, 1_000_000 => 15, 1_000_000_000 => 10, 7123 => 25}\n\nspecs.each do |start, count|\n  puts \"first \n  puts (start..).each.select(&.gapful?).first(count).to_a, \"\\n\"\nend\n", "target": "from itertools import islice, count\nfor start, n in [(100, 30), (1_000_000, 15), (1_000_000_000, 10)]:\n    print(f\"\\nFirst {n} gapful numbers from {start:_}\")\n    print(list(islice(( x for x in count(start) \n                        if (x % (int(str(x)[0]) * 10 + (x % 10)) == 0) )\n                      , n)))\n"}
{"id": 110731, "name": "Gapful numbers", "source": "Translate Ruby to Python: struct Int\n  def gapful?\n    a = self.to_s.chars.map(&.to_i)\n    self % (a.first*10 + a.last) == 0\n  end\nend\n\nspecs = {100 => 30, 1_000_000 => 15, 1_000_000_000 => 10, 7123 => 25}\n\nspecs.each do |start, count|\n  puts \"first \n  puts (start..).each.select(&.gapful?).first(count).to_a, \"\\n\"\nend\n", "target": "from itertools import islice, count\nfor start, n in [(100, 30), (1_000_000, 15), (1_000_000_000, 10)]:\n    print(f\"\\nFirst {n} gapful numbers from {start:_}\")\n    print(list(islice(( x for x in count(start) \n                        if (x % (int(str(x)[0]) * 10 + (x % 10)) == 0) )\n                      , n)))\n"}
{"id": 110909, "name": "Make directory path", "source": "Translate Ruby to Java: require 'fileutils'\nFileUtils.mkdir_p(\"path/to/dir\")\n", "target": "import java.io.File;\n\npublic interface Test {\n\n    public static void main(String[] args) {\n        try {\n            File f = new File(\"C:/parent/test\");\n            if (f.mkdirs())\n                System.out.println(\"path successfully created\");\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}\n"}
{"id": 110910, "name": "Make directory path", "source": "Translate Ruby to Python: require 'fileutils'\nFileUtils.mkdir_p(\"path/to/dir\")\n", "target": "from errno import EEXIST\nfrom os import mkdir, curdir\nfrom os.path import split, exists\n\ndef mkdirp(path, mode=0777):\n    head, tail = split(path)\n    if not tail:\n        head, tail = split(head)\n    if head and tail and not exists(head):\n        try:\n            mkdirp(head, mode)\n        except OSError as e:\n            \n            if e.errno != EEXIST:\n                raise\n        if tail == curdir:  \n            return\n    try:\n        mkdir(path, mode)\n    except OSError as e:\n        \n        if e.errno != EEXIST:\n            raise\n"}
{"id": 111149, "name": "Take notes on the command line", "source": "Translate Ruby to C#: notes = 'NOTES.TXT'\nif ARGV.empty?\n  File.copy_stream(notes, $stdout) rescue nil\nelse\n  File.open(notes, 'a') {|file| file.puts \"%s\\n\\t%s\" % [Time.now, ARGV.join(' ')]}\nend\n", "target": "using System;\nusing System.IO;\nusing System.Text;\n\nnamespace RosettaCode\n{\n  internal class Program\n  {\n    private const string FileName = \"NOTES.TXT\";\n\n    private static void Main(string[] args)\n    {\n      if (args.Length==0)\n      {\n        string txt = File.ReadAllText(FileName);\n        Console.WriteLine(txt);\n      }\n      else\n      {\n        var sb = new StringBuilder();\n        sb.Append(DateTime.Now).Append(\"\\n\\t\");\n        foreach (string s in args)\n          sb.Append(s).Append(\" \");\n        sb.Append(\"\\n\");\n\n        if (File.Exists(FileName))\n          File.AppendAllText(FileName, sb.ToString());\n        else\n          File.WriteAllText(FileName, sb.ToString());\n      }\n    }\n  }\n}\n"}
{"id": 111151, "name": "Take notes on the command line", "source": "Translate Ruby to Java: notes = 'NOTES.TXT'\nif ARGV.empty?\n  File.copy_stream(notes, $stdout) rescue nil\nelse\n  File.open(notes, 'a') {|file| file.puts \"%s\\n\\t%s\" % [Time.now, ARGV.join(' ')]}\nend\n", "target": "import java.io.*;\nimport java.nio.channels.*;\nimport java.util.Date;\n\npublic class TakeNotes {\n    public static void main(String[] args) throws IOException {\n        if (args.length > 0) {\n            PrintStream ps = new PrintStream(new FileOutputStream(\"notes.txt\", true));\n            ps.println(new Date());\n            ps.print(\"\\t\" + args[0]);\n            for (int i = 1; i < args.length; i++)\n                ps.print(\" \" + args[i]);\n            ps.println();\n            ps.close();\n        } else {\n            FileChannel fc = new FileInputStream(\"notes.txt\").getChannel();\n            fc.transferTo(0, fc.size(), Channels.newChannel(System.out));\n            fc.close();\n        }\n    }\n}\n"}
{"id": 111152, "name": "Take notes on the command line", "source": "Translate Ruby to Python: notes = 'NOTES.TXT'\nif ARGV.empty?\n  File.copy_stream(notes, $stdout) rescue nil\nelse\n  File.open(notes, 'a') {|file| file.puts \"%s\\n\\t%s\" % [Time.now, ARGV.join(' ')]}\nend\n", "target": "import sys, datetime, shutil\n\nif len(sys.argv) == 1:\n    try:\n        with open(\"notes.txt\", \"r\") as f:\n            shutil.copyfileobj(f, sys.stdout)\n    except IOError:\n        pass\nelse:\n    with open(\"notes.txt\", \"a\") as f:\n        f.write(datetime.datetime.now().isoformat() + \"\\n\")\n        f.write(\"\\t%s\\n\" % ' '.join(sys.argv[1:]))\n"}
{"id": 111463, "name": "Base64 encode data", "source": "Translate Ruby to C#: require \"http/client\"\nrequire \"base64\"\n\nresponse = HTTP::Client.get \"https://rosettacode.org/favicon.ico\"\nif response.success?\n    Base64.encode(response.body, STDOUT)\nend\n", "target": "namespace RosettaCode.Base64EncodeData\n{\n    using System;\n    using System.Net;\n\n    internal static class Program\n    {\n        private static void Main()\n        {\n            const string path = \"http:\n\n            byte[] input;\n            using (var client = new WebClient())\n            {\n                input = client.DownloadData(path);\n            }\n\n            var output = Convert.ToBase64String(input);\n            Console.WriteLine(output);\n        }\n    }\n}\n"}
{"id": 111464, "name": "Base64 encode data", "source": "Translate Ruby to C#: require \"http/client\"\nrequire \"base64\"\n\nresponse = HTTP::Client.get \"https://rosettacode.org/favicon.ico\"\nif response.success?\n    Base64.encode(response.body, STDOUT)\nend\n", "target": "namespace RosettaCode.Base64EncodeData\n{\n    using System;\n    using System.Net;\n\n    internal static class Program\n    {\n        private static void Main()\n        {\n            const string path = \"http:\n\n            byte[] input;\n            using (var client = new WebClient())\n            {\n                input = client.DownloadData(path);\n            }\n\n            var output = Convert.ToBase64String(input);\n            Console.WriteLine(output);\n        }\n    }\n}\n"}
{"id": 111466, "name": "Base64 encode data", "source": "Translate Ruby to Java: require \"http/client\"\nrequire \"base64\"\n\nresponse = HTTP::Client.get \"https://rosettacode.org/favicon.ico\"\nif response.success?\n    Base64.encode(response.body, STDOUT)\nend\n", "target": "import java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.net.URL;\nimport java.net.URLConnection;\nimport java.util.Arrays;\n\npublic class Base64 {\n\n    private static final char[] alpha = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\".toCharArray();\n\n    static String base64(InputStream is) throws IOException {\n        StringBuilder sb = new StringBuilder();\n        int blocks = 0;\n\n        while (true) {\n            int c0 = is.read();\n            if (c0 == -1)\n                break;\n            int c1 = is.read();\n            int c2 = is.read();\n\n            int block = ((c0 & 0xFF) << 16) | ((Math.max(c1, 0) & 0xFF) << 8) | (Math.max(c2, 0) & 0xFF);\n\n            sb.append(alpha[block >> 18 & 63]);\n            sb.append(alpha[block >> 12 & 63]);\n            sb.append(c1 == -1 ? '=' : alpha[block >> 6 & 63]);\n            sb.append(c2 == -1 ? '=' : alpha[block & 63]);\n\n            if (++blocks == 19) {\n                blocks = 0;\n                sb.append('\\n');\n            }\n        }\n\n        if (blocks > 0)\n            sb.append('\\n');\n\n        return sb.toString();\n    }\n\n    private static void assertBase64(String expected, byte[] bytes) throws IOException {\n        String actual = base64(new ByteArrayInputStream(bytes));\n        if (!actual.equals(expected)) {\n            throw new IllegalStateException(String.format(\"Expected %s for %s, but got %s.\",\n                    expected, Arrays.toString(bytes), actual));\n        }\n    }\n\n    private static void testBase64() throws IOException {\n        assertBase64(\"\", new byte[]{});\n        assertBase64(\"AA==\\n\", new byte[]{0});\n        assertBase64(\"AAA=\\n\", new byte[]{0, 0});\n        assertBase64(\"AAAA\\n\", new byte[]{0, 0, 0});\n        assertBase64(\"AAAAAA==\\n\", new byte[]{0, 0, 0, 0});\n        assertBase64(\"/w==\\n\", new byte[]{-1});\n        assertBase64(\"\n        assertBase64(\"\n        assertBase64(\"\n    }\n\n    public static void main(String[] args) throws IOException {\n        testBase64();\n\n        URLConnection conn = new URL(\"http:\n        conn.addRequestProperty(\"User-Agent\", \"Mozilla\"); \n        try (InputStream is = conn.getInputStream()) {\n            System.out.println(base64(is));\n        }\n    }\n}\n"}
{"id": 111467, "name": "Base64 encode data", "source": "Translate Ruby to Java: require \"http/client\"\nrequire \"base64\"\n\nresponse = HTTP::Client.get \"https://rosettacode.org/favicon.ico\"\nif response.success?\n    Base64.encode(response.body, STDOUT)\nend\n", "target": "import java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.net.URL;\nimport java.net.URLConnection;\nimport java.util.Arrays;\n\npublic class Base64 {\n\n    private static final char[] alpha = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\".toCharArray();\n\n    static String base64(InputStream is) throws IOException {\n        StringBuilder sb = new StringBuilder();\n        int blocks = 0;\n\n        while (true) {\n            int c0 = is.read();\n            if (c0 == -1)\n                break;\n            int c1 = is.read();\n            int c2 = is.read();\n\n            int block = ((c0 & 0xFF) << 16) | ((Math.max(c1, 0) & 0xFF) << 8) | (Math.max(c2, 0) & 0xFF);\n\n            sb.append(alpha[block >> 18 & 63]);\n            sb.append(alpha[block >> 12 & 63]);\n            sb.append(c1 == -1 ? '=' : alpha[block >> 6 & 63]);\n            sb.append(c2 == -1 ? '=' : alpha[block & 63]);\n\n            if (++blocks == 19) {\n                blocks = 0;\n                sb.append('\\n');\n            }\n        }\n\n        if (blocks > 0)\n            sb.append('\\n');\n\n        return sb.toString();\n    }\n\n    private static void assertBase64(String expected, byte[] bytes) throws IOException {\n        String actual = base64(new ByteArrayInputStream(bytes));\n        if (!actual.equals(expected)) {\n            throw new IllegalStateException(String.format(\"Expected %s for %s, but got %s.\",\n                    expected, Arrays.toString(bytes), actual));\n        }\n    }\n\n    private static void testBase64() throws IOException {\n        assertBase64(\"\", new byte[]{});\n        assertBase64(\"AA==\\n\", new byte[]{0});\n        assertBase64(\"AAA=\\n\", new byte[]{0, 0});\n        assertBase64(\"AAAA\\n\", new byte[]{0, 0, 0});\n        assertBase64(\"AAAAAA==\\n\", new byte[]{0, 0, 0, 0});\n        assertBase64(\"/w==\\n\", new byte[]{-1});\n        assertBase64(\"\n        assertBase64(\"\n        assertBase64(\"\n    }\n\n    public static void main(String[] args) throws IOException {\n        testBase64();\n\n        URLConnection conn = new URL(\"http:\n        conn.addRequestProperty(\"User-Agent\", \"Mozilla\"); \n        try (InputStream is = conn.getInputStream()) {\n            System.out.println(base64(is));\n        }\n    }\n}\n"}
{"id": 111468, "name": "Base64 encode data", "source": "Translate Ruby to Python: require \"http/client\"\nrequire \"base64\"\n\nresponse = HTTP::Client.get \"https://rosettacode.org/favicon.ico\"\nif response.success?\n    Base64.encode(response.body, STDOUT)\nend\n", "target": "import urllib\nimport base64\n\ndata = urllib.urlopen('http://rosettacode.org/favicon.ico').read()\nprint base64.b64encode(data)\n"}
{"id": 111469, "name": "Base64 encode data", "source": "Translate Ruby to Python: require \"http/client\"\nrequire \"base64\"\n\nresponse = HTTP::Client.get \"https://rosettacode.org/favicon.ico\"\nif response.success?\n    Base64.encode(response.body, STDOUT)\nend\n", "target": "import urllib\nimport base64\n\ndata = urllib.urlopen('http://rosettacode.org/favicon.ico').read()\nprint base64.b64encode(data)\n"}
{"id": 111733, "name": "Sort using a custom comparator", "source": "Translate Ruby to C#: words = %w(Here are some sample strings to be sorted)\np words.sort_by {|word| [-word.size, word.downcase]}\n", "target": "using System;\nusing System.Collections.Generic;\n\nnamespace RosettaCode {\n    class SortCustomComparator {\n        \n        public void CustomSort() {\n            String[] items = { \"Here\", \"are\", \"some\", \"sample\", \"strings\", \"to\", \"be\", \"sorted\" };\n            List<String> list = new List<string>(items);\n\n            DisplayList(\"Unsorted\", list);\n            \n            list.Sort(CustomCompare);\n            DisplayList(\"Descending Length\", list);\n\n            list.Sort();\n            DisplayList(\"Ascending order\", list);\n        }\n\n        \n        public int CustomCompare(String x, String y) {\n            int result = -x.Length.CompareTo(y.Length);\n            if (result == 0) {\n                result = x.ToLower().CompareTo(y.ToLower());\n            }\n\n            return result;\n        }\n\n        \n        public void DisplayList(String header, List<String> theList) {\n            Console.WriteLine(header);\n            Console.WriteLine(\"\".PadLeft(header.Length, '*'));\n            foreach (String str in theList) {\n                Console.WriteLine(str);\n            }\n            Console.WriteLine();\n        }\n    }\n}\n"}
{"id": 111735, "name": "Sort using a custom comparator", "source": "Translate Ruby to Java: words = %w(Here are some sample strings to be sorted)\np words.sort_by {|word| [-word.size, word.downcase]}\n", "target": "import java.util.Comparator;\nimport java.util.Arrays;\n\npublic class Test {\n  public static void main(String[] args) {\n    String[] strings = {\"Here\", \"are\", \"some\", \"sample\", \"strings\", \"to\", \"be\", \"sorted\"};\n\n    Arrays.sort(strings, new Comparator<String>() {\n      public int compare(String s1, String s2) {\n        int c = s2.length() - s1.length();\n        if (c == 0)\n          c = s1.compareToIgnoreCase(s2);\n        return c;\n      }\n    });\n\n    for (String s: strings)\n      System.out.print(s + \" \");\n  }\n}\n"}
{"id": 111736, "name": "Sort using a custom comparator", "source": "Translate Ruby to Python: words = %w(Here are some sample strings to be sorted)\np words.sort_by {|word| [-word.size, word.downcase]}\n", "target": "strings = \"here are Some sample strings to be sorted\".split()\n\ndef mykey(x):\n    return -len(x), x.upper()\n\nprint sorted(strings, key=mykey)\n"}
{"id": 112007, "name": "Feigenbaum constant calculation", "source": "Translate Ruby to C#: def main\n    maxIt = 13\n    maxItJ = 10\n    a1 = 1.0\n    a2 = 0.0\n    d1 = 3.2\n    puts \" i       d\"\n    for i in 2 .. maxIt\n        a = a1 + (a1 - a2) / d1\n        for j in 1 .. maxItJ\n            x = 0.0\n            y = 0.0\n            for k in 1 .. 1 << i\n                y = 1.0 - 2.0 * y * x\n                x = a - x * x\n            end\n            a = a - x / y\n        end\n        d = (a1 - a2) / (a - a1)\n        print \"%2d   \u00a0%.8f\\n\" % [i, d]\n        d1 = d\n        a2 = a1\n        a1 = a\n    end\nend\n\nmain()\n", "target": "using System;\n\nnamespace FeigenbaumConstant {\n    class Program {\n        static void Main(string[] args) {\n            var maxIt = 13;\n            var maxItJ = 10;\n            var a1 = 1.0;\n            var a2 = 0.0;\n            var d1 = 3.2;\n            Console.WriteLine(\" i       d\");\n            for (int i = 2; i <= maxIt; i++) {\n                var a = a1 + (a1 - a2) / d1;\n                for (int j = 1; j <= maxItJ; j++) {\n                    var x = 0.0;\n                    var y = 0.0;\n                    for (int k = 1; k <= 1<<i; k++) {\n                        y = 1.0 - 2.0 * y * x;\n                        x = a - x * x;\n                    }\n                    a -= x / y;\n                }\n                var d = (a1 - a2) / (a - a1);\n                Console.WriteLine(\"{0,2:d}    {1:f8}\", i, d);\n                d1 = d;\n                a2 = a1;\n                a1 = a;\n            }\n        }\n    }\n}\n"}
{"id": 112008, "name": "Feigenbaum constant calculation", "source": "Translate Ruby to C#: def main\n    maxIt = 13\n    maxItJ = 10\n    a1 = 1.0\n    a2 = 0.0\n    d1 = 3.2\n    puts \" i       d\"\n    for i in 2 .. maxIt\n        a = a1 + (a1 - a2) / d1\n        for j in 1 .. maxItJ\n            x = 0.0\n            y = 0.0\n            for k in 1 .. 1 << i\n                y = 1.0 - 2.0 * y * x\n                x = a - x * x\n            end\n            a = a - x / y\n        end\n        d = (a1 - a2) / (a - a1)\n        print \"%2d   \u00a0%.8f\\n\" % [i, d]\n        d1 = d\n        a2 = a1\n        a1 = a\n    end\nend\n\nmain()\n", "target": "using System;\n\nnamespace FeigenbaumConstant {\n    class Program {\n        static void Main(string[] args) {\n            var maxIt = 13;\n            var maxItJ = 10;\n            var a1 = 1.0;\n            var a2 = 0.0;\n            var d1 = 3.2;\n            Console.WriteLine(\" i       d\");\n            for (int i = 2; i <= maxIt; i++) {\n                var a = a1 + (a1 - a2) / d1;\n                for (int j = 1; j <= maxItJ; j++) {\n                    var x = 0.0;\n                    var y = 0.0;\n                    for (int k = 1; k <= 1<<i; k++) {\n                        y = 1.0 - 2.0 * y * x;\n                        x = a - x * x;\n                    }\n                    a -= x / y;\n                }\n                var d = (a1 - a2) / (a - a1);\n                Console.WriteLine(\"{0,2:d}    {1:f8}\", i, d);\n                d1 = d;\n                a2 = a1;\n                a1 = a;\n            }\n        }\n    }\n}\n"}
{"id": 112011, "name": "Feigenbaum constant calculation", "source": "Translate Ruby to Java: def main\n    maxIt = 13\n    maxItJ = 10\n    a1 = 1.0\n    a2 = 0.0\n    d1 = 3.2\n    puts \" i       d\"\n    for i in 2 .. maxIt\n        a = a1 + (a1 - a2) / d1\n        for j in 1 .. maxItJ\n            x = 0.0\n            y = 0.0\n            for k in 1 .. 1 << i\n                y = 1.0 - 2.0 * y * x\n                x = a - x * x\n            end\n            a = a - x / y\n        end\n        d = (a1 - a2) / (a - a1)\n        print \"%2d   \u00a0%.8f\\n\" % [i, d]\n        d1 = d\n        a2 = a1\n        a1 = a\n    end\nend\n\nmain()\n", "target": "public class Feigenbaum {\n    public static void main(String[] args) {\n        int max_it = 13;\n        int max_it_j = 10;\n        double a1 = 1.0;\n        double a2 = 0.0;\n        double d1 = 3.2;\n        double a;\n\n        System.out.println(\" i       d\");\n        for (int i = 2; i <= max_it; i++) {\n            a = a1 + (a1 - a2) / d1;\n            for (int j = 0; j < max_it_j; j++) {\n                double x = 0.0;\n                double y = 0.0;\n                for (int k = 0; k < 1 << i; k++) {\n                    y = 1.0 - 2.0 * y * x;\n                    x = a - x * x;\n                }\n                a -= x / y;\n            }\n            double d = (a1 - a2) / (a - a1);\n            System.out.printf(\"%2d   \u00a0%.8f\\n\", i, d);\n            d1 = d;\n            a2 = a1;\n            a1 = a;\n        }\n    }\n}\n"}
{"id": 112012, "name": "Feigenbaum constant calculation", "source": "Translate Ruby to Java: def main\n    maxIt = 13\n    maxItJ = 10\n    a1 = 1.0\n    a2 = 0.0\n    d1 = 3.2\n    puts \" i       d\"\n    for i in 2 .. maxIt\n        a = a1 + (a1 - a2) / d1\n        for j in 1 .. maxItJ\n            x = 0.0\n            y = 0.0\n            for k in 1 .. 1 << i\n                y = 1.0 - 2.0 * y * x\n                x = a - x * x\n            end\n            a = a - x / y\n        end\n        d = (a1 - a2) / (a - a1)\n        print \"%2d   \u00a0%.8f\\n\" % [i, d]\n        d1 = d\n        a2 = a1\n        a1 = a\n    end\nend\n\nmain()\n", "target": "public class Feigenbaum {\n    public static void main(String[] args) {\n        int max_it = 13;\n        int max_it_j = 10;\n        double a1 = 1.0;\n        double a2 = 0.0;\n        double d1 = 3.2;\n        double a;\n\n        System.out.println(\" i       d\");\n        for (int i = 2; i <= max_it; i++) {\n            a = a1 + (a1 - a2) / d1;\n            for (int j = 0; j < max_it_j; j++) {\n                double x = 0.0;\n                double y = 0.0;\n                for (int k = 0; k < 1 << i; k++) {\n                    y = 1.0 - 2.0 * y * x;\n                    x = a - x * x;\n                }\n                a -= x / y;\n            }\n            double d = (a1 - a2) / (a - a1);\n            System.out.printf(\"%2d   \u00a0%.8f\\n\", i, d);\n            d1 = d;\n            a2 = a1;\n            a1 = a;\n        }\n    }\n}\n"}
{"id": 112013, "name": "Feigenbaum constant calculation", "source": "Translate Ruby to Python: def main\n    maxIt = 13\n    maxItJ = 10\n    a1 = 1.0\n    a2 = 0.0\n    d1 = 3.2\n    puts \" i       d\"\n    for i in 2 .. maxIt\n        a = a1 + (a1 - a2) / d1\n        for j in 1 .. maxItJ\n            x = 0.0\n            y = 0.0\n            for k in 1 .. 1 << i\n                y = 1.0 - 2.0 * y * x\n                x = a - x * x\n            end\n            a = a - x / y\n        end\n        d = (a1 - a2) / (a - a1)\n        print \"%2d   \u00a0%.8f\\n\" % [i, d]\n        d1 = d\n        a2 = a1\n        a1 = a\n    end\nend\n\nmain()\n", "target": "max_it = 13\nmax_it_j = 10\na1 = 1.0\na2 = 0.0\nd1 = 3.2\na = 0.0\n\nprint \" i       d\"\nfor i in range(2, max_it + 1):\n    a = a1 + (a1 - a2) / d1\n    for j in range(1, max_it_j + 1):\n        x = 0.0\n        y = 0.0\n        for k in range(1, (1 << i) + 1):\n            y = 1.0 - 2.0 * y * x\n            x = a - x * x\n        a = a - x / y\n    d = (a1 - a2) / (a - a1)\n    print(\"{0:2d}    {1:.8f}\".format(i, d))\n    d1 = d\n    a2 = a1\n    a1 = a\n"}
{"id": 112014, "name": "Feigenbaum constant calculation", "source": "Translate Ruby to Python: def main\n    maxIt = 13\n    maxItJ = 10\n    a1 = 1.0\n    a2 = 0.0\n    d1 = 3.2\n    puts \" i       d\"\n    for i in 2 .. maxIt\n        a = a1 + (a1 - a2) / d1\n        for j in 1 .. maxItJ\n            x = 0.0\n            y = 0.0\n            for k in 1 .. 1 << i\n                y = 1.0 - 2.0 * y * x\n                x = a - x * x\n            end\n            a = a - x / y\n        end\n        d = (a1 - a2) / (a - a1)\n        print \"%2d   \u00a0%.8f\\n\" % [i, d]\n        d1 = d\n        a2 = a1\n        a1 = a\n    end\nend\n\nmain()\n", "target": "max_it = 13\nmax_it_j = 10\na1 = 1.0\na2 = 0.0\nd1 = 3.2\na = 0.0\n\nprint \" i       d\"\nfor i in range(2, max_it + 1):\n    a = a1 + (a1 - a2) / d1\n    for j in range(1, max_it_j + 1):\n        x = 0.0\n        y = 0.0\n        for k in range(1, (1 << i) + 1):\n            y = 1.0 - 2.0 * y * x\n            x = a - x * x\n        a = a - x / y\n    d = (a1 - a2) / (a - a1)\n    print(\"{0:2d}    {1:.8f}\".format(i, d))\n    d1 = d\n    a2 = a1\n    a1 = a\n"}
{"id": 112147, "name": "Memory allocation", "source": "Translate Ruby to C#: class Thingamajig\n  def initialize\n    fail 'not yet implemented'\n  end\nend\nt = Thingamajig.allocate\n", "target": "using System;\nusing System.Runtime.InteropServices;\n\npublic unsafe class Program\n{\n    public static unsafe void HeapMemory()\n    {\n        const int HEAP_ZERO_MEMORY = 0x00000008;\n        const int size = 1000;\n        int ph = GetProcessHeap();\n        void* pointer = HeapAlloc(ph, HEAP_ZERO_MEMORY, size);\n        if (pointer == null)\n            throw new OutOfMemoryException();\n        Console.WriteLine(HeapSize(ph, 0, pointer));\n        HeapFree(ph, 0, pointer);\n    }\n\n    public static unsafe void StackMemory()\n    {\n        byte* buffer = stackalloc byte[1000];\n        \n    }\n    public static void Main(string[] args)\n    {\n        HeapMemory();\n        StackMemory();\n    }\n    [DllImport(\"kernel32\")]\n    static extern void* HeapAlloc(int hHeap, int flags, int size);\n    [DllImport(\"kernel32\")]\n    static extern bool HeapFree(int hHeap, int flags, void* block);\n    [DllImport(\"kernel32\")]\n    static extern int GetProcessHeap();\n    [DllImport(\"kernel32\")]\n    static extern int HeapSize(int hHeap, int flags, void* block);\n\n}\n"}
{"id": 112149, "name": "Memory allocation", "source": "Translate Ruby to Java: class Thingamajig\n  def initialize\n    fail 'not yet implemented'\n  end\nend\nt = Thingamajig.allocate\n", "target": "\n\nObject foo = new Object(); \nint[] fooArray = new int[size]; \nint x = 0; \n"}
{"id": 112150, "name": "Memory allocation", "source": "Translate Ruby to Python: class Thingamajig\n  def initialize\n    fail 'not yet implemented'\n  end\nend\nt = Thingamajig.allocate\n", "target": ">>> from array import array\n>>> argslist = [('l', []), ('c', 'hello world'), ('u', u'hello \\u2641'),\n\t('l', [1, 2, 3, 4, 5]), ('d', [1.0, 2.0, 3.14])]\n>>> for typecode, initializer in argslist:\n\ta = array(typecode, initializer)\n\tprint a\n\tdel a\n\n\t\narray('l')\narray('c', 'hello world')\narray('u', u'hello \\u2641')\narray('l', [1, 2, 3, 4, 5])\narray('d', [1.0, 2.0, 3.1400000000000001])\n>>>\n"}
{"id": 112427, "name": "Stair-climbing puzzle", "source": "Translate Ruby to C#: def step_up\n  start_position = $position\n  step until ($position == start_position + 1)\nend\n\n\n\n\ndef step\n  if rand < 0.5\n    $position -= 1\n    p \"fall (\n    return false\n  else\n    $position += 1\n    p \"rise (\n    return true\n  end\nend\n\n$position = 0\nstep_up\n", "target": "void step_up() {\n    while (!step()) step_up();\n}\n"}
{"id": 112428, "name": "Stair-climbing puzzle", "source": "Translate Ruby to C#: def step_up\n  start_position = $position\n  step until ($position == start_position + 1)\nend\n\n\n\n\ndef step\n  if rand < 0.5\n    $position -= 1\n    p \"fall (\n    return false\n  else\n    $position += 1\n    p \"rise (\n    return true\n  end\nend\n\n$position = 0\nstep_up\n", "target": "void step_up() {\n    while (!step()) step_up();\n}\n"}
{"id": 112431, "name": "Stair-climbing puzzle", "source": "Translate Ruby to Java: def step_up\n  start_position = $position\n  step until ($position == start_position + 1)\nend\n\n\n\n\ndef step\n  if rand < 0.5\n    $position -= 1\n    p \"fall (\n    return false\n  else\n    $position += 1\n    p \"rise (\n    return true\n  end\nend\n\n$position = 0\nstep_up\n", "target": "public void stepUp() {\n  while (!step()) stepUp();\n}\n"}
{"id": 112432, "name": "Stair-climbing puzzle", "source": "Translate Ruby to Java: def step_up\n  start_position = $position\n  step until ($position == start_position + 1)\nend\n\n\n\n\ndef step\n  if rand < 0.5\n    $position -= 1\n    p \"fall (\n    return false\n  else\n    $position += 1\n    p \"rise (\n    return true\n  end\nend\n\n$position = 0\nstep_up\n", "target": "public void stepUp() {\n  while (!step()) stepUp();\n}\n"}
{"id": 112433, "name": "Stair-climbing puzzle", "source": "Translate Ruby to Python: def step_up\n  start_position = $position\n  step until ($position == start_position + 1)\nend\n\n\n\n\ndef step\n  if rand < 0.5\n    $position -= 1\n    p \"fall (\n    return false\n  else\n    $position += 1\n    p \"rise (\n    return true\n  end\nend\n\n$position = 0\nstep_up\n", "target": "def step_up1():\n  \n  deficit = 1\n  while deficit > 0:\n    if step():\n      deficit -= 1\n    else:\n      deficit += 1\n"}
{"id": 112434, "name": "Stair-climbing puzzle", "source": "Translate Ruby to Python: def step_up\n  start_position = $position\n  step until ($position == start_position + 1)\nend\n\n\n\n\ndef step\n  if rand < 0.5\n    $position -= 1\n    p \"fall (\n    return false\n  else\n    $position += 1\n    p \"rise (\n    return true\n  end\nend\n\n$position = 0\nstep_up\n", "target": "def step_up1():\n  \n  deficit = 1\n  while deficit > 0:\n    if step():\n      deficit -= 1\n    else:\n      deficit += 1\n"}
{"id": 112610, "name": "Hostname", "source": "Translate Ruby to Java: require 'socket'\nhost = Socket.gethostname\n", "target": "import java.net.*;\nclass DiscoverHostName {\n public static void main(final String[] args) {\n  try {\n   System.out.println(InetAddress.getLocalHost().getHostName());\n  } catch (UnknownHostException e) { \n  }\n }\n}\n"}
{"id": 112849, "name": "Guess the number", "source": "Translate Ruby to C#: n = rand(1..10)\nputs \"Guess the number: 1..10\"\nuntil gets.to_s.to_i == n; puts \"Wrong! Guess again: \" end\nputs \"Well guessed!\"\n", "target": "using System;\n\nclass GuessTheNumberGame\n{\n    static void Main()\n    {\n        int randomNumber = new Random().Next(1, 11);\n        \n        Console.WriteLine(\"I'm thinking of a number between 1 and 10. Can you guess it?\");\n        while(true)\n        {\n            Console.Write(\"Guess: \");\n            if (int.Parse(Console.ReadLine()) == randomNumber)\n                break;\n            Console.WriteLine(\"That's not it. Guess again.\");\n        }\n        Console.WriteLine(\"Congrats!! You guessed right!\");\n    }\n};\n"}
{"id": 112851, "name": "Guess the number", "source": "Translate Ruby to Java: n = rand(1..10)\nputs \"Guess the number: 1..10\"\nuntil gets.to_s.to_i == n; puts \"Wrong! Guess again: \" end\nputs \"Well guessed!\"\n", "target": "public class Guessing {\n    public static void main(String[] args) throws NumberFormatException{\n        int n = (int)(Math.random() * 10 + 1);\n        System.out.print(\"Guess the number between 1 and 10: \");\n        while(Integer.parseInt(System.console().readLine()) != n){\n            System.out.print(\"Wrong! Guess again: \");\n        }\n        System.out.println(\"Well guessed!\");\n    }\n}\n"}
{"id": 112852, "name": "Guess the number", "source": "Translate Ruby to Python: n = rand(1..10)\nputs \"Guess the number: 1..10\"\nuntil gets.to_s.to_i == n; puts \"Wrong! Guess again: \" end\nputs \"Well guessed!\"\n", "target": "import random\nt,g=random.randint(1,10),0\ng=int(input(\"Guess a number that's between 1 and 10: \"))\nwhile t!=g:g=int(input(\"Guess again! \"))\nprint(\"That's right!\")\n"}
{"id": 112989, "name": "Bitmap_Read a PPM file", "source": "Translate Ruby to C#: class Pixmap\n  \n  def self.open(filename)\n    bitmap = nil\n    File.open(filename, 'r') do |f|\n      header = [f.gets.chomp, f.gets.chomp, f.gets.chomp]\n      width, height = header[1].split.map {|n| n.to_i }\n      if header[0] != 'P6' or header[2] != '255' or width < 1 or height < 1\n        raise StandardError, \"file '\n      end\n      f.binmode\n      bitmap = self.new(width, height)\n      height.times do |y|\n        width.times do |x|\n          \n          red, green, blue = f.read(3).unpack('C3')\n          bitmap[x,y] = RGBColour.new(red, green, blue)\n        end\n      end\n    end\n    bitmap\n  end\nend\n\n\ncolour_bitmap = Pixmap.new(20, 30)\ncolour_bitmap.fill(RGBColour::BLUE)\ncolour_bitmap.height.times {|y| [9,10,11].each {|x| colour_bitmap[x,y]=RGBColour::GREEN}}\ncolour_bitmap.width.times  {|x| [14,15,16].each {|y| colour_bitmap[x,y]=RGBColour::GREEN}}\ncolour_bitmap.save('testcross.ppm')\n\n\nPixmap.open('testcross.ppm').to_grayscale!.save('testgray.ppm')\n", "target": "using System.IO;\nclass PPMReader\n{\n    public static Bitmap ReadBitmapFromPPM(string file)\n    {\n        var reader = new BinaryReader(new FileStream(file, FileMode.Open));\n        if (reader.ReadChar() != 'P' || reader.ReadChar() != '6')\n            return null;\n        reader.ReadChar(); \n        string widths = \"\", heights = \"\";\n        char temp;\n        while ((temp = reader.ReadChar()) != ' ')\n            widths += temp;\n        while ((temp = reader.ReadChar()) >= '0' && temp <= '9')\n            heights += temp;\n        if (reader.ReadChar() != '2' || reader.ReadChar() != '5' || reader.ReadChar() != '5')\n            return null;\n        reader.ReadChar(); \n        int width = int.Parse(widths),\n            height = int.Parse(heights);\n        Bitmap bitmap = new Bitmap(width, height);\n        \n        for (int y = 0; y < height; y++)\n            for (int x = 0; x < width; x++)\n                bitmap.SetPixel(x, y, new Bitmap.Color()\n                {\n                    Red = reader.ReadByte(),\n                    Green = reader.ReadByte(),\n                    Blue = reader.ReadByte()\n                });\n        return bitmap;\n    }\n}\n"}
{"id": 112990, "name": "Bitmap_Read a PPM file", "source": "Translate Ruby to Python: class Pixmap\n  \n  def self.open(filename)\n    bitmap = nil\n    File.open(filename, 'r') do |f|\n      header = [f.gets.chomp, f.gets.chomp, f.gets.chomp]\n      width, height = header[1].split.map {|n| n.to_i }\n      if header[0] != 'P6' or header[2] != '255' or width < 1 or height < 1\n        raise StandardError, \"file '\n      end\n      f.binmode\n      bitmap = self.new(width, height)\n      height.times do |y|\n        width.times do |x|\n          \n          red, green, blue = f.read(3).unpack('C3')\n          bitmap[x,y] = RGBColour.new(red, green, blue)\n        end\n      end\n    end\n    bitmap\n  end\nend\n\n\ncolour_bitmap = Pixmap.new(20, 30)\ncolour_bitmap.fill(RGBColour::BLUE)\ncolour_bitmap.height.times {|y| [9,10,11].each {|x| colour_bitmap[x,y]=RGBColour::GREEN}}\ncolour_bitmap.width.times  {|x| [14,15,16].each {|y| colour_bitmap[x,y]=RGBColour::GREEN}}\ncolour_bitmap.save('testcross.ppm')\n\n\nPixmap.open('testcross.ppm').to_grayscale!.save('testgray.ppm')\n", "target": "\n\n\nimport io\n\nppmtxt = \n\n\ndef tokenize(f):\n    for line in f:\n        if line[0] != '\n            for t in line.split():\n                yield t\n\ndef ppmp3tobitmap(f):\n    t = tokenize(f)\n    nexttoken = lambda : next(t)\n    assert 'P3' == nexttoken(), 'Wrong filetype'\n    width, height, maxval = (int(nexttoken()) for i in range(3))\n    bitmap = Bitmap(width, height, Colour(0, 0, 0))\n    for h in range(height-1, -1, -1):\n        for w in range(0, width):\n            bitmap.set(w, h, Colour( *(int(nexttoken()) for i in range(3))))\n\n    return bitmap\n    \nprint('Original Colour PPM file')\nprint(ppmtxt)\nppmfile = io.StringIO(ppmtxt)\nbitmap = ppmp3tobitmap(ppmfile)\nprint('Grey PPM:')\nbitmap.togreyscale()\nppmfileout = io.StringIO('')\nbitmap.writeppmp3(ppmfileout)\nprint(ppmfileout.getvalue())\n\n\n\n"}
{"id": 113179, "name": "Set", "source": "Translate Ruby to C#: >> require 'set'\n=> true\n>> s1, s2 = Set[1, 2, 3, 4], [3, 4, 5, 6].to_set \n=> [\n>> s1 | s2 \n=> \n>> s1 & s2 \n=> \n>> s1 - s2 \n=> \n>> s1.proper_subset?(s1) \n=> false\n>> Set[3, 1].proper_subset?(s1) \n=> true\n>> s1.subset?(s1) \n=> true\n>> Set[3, 1].subset?(s1) \n=> true\n>> Set[3, 2, 4, 1] == s1 \n=> true\n>> s1 == s2 \n=> false\n>> s1.include?(2) \n=> true\n>> Set[1, 2, 3, 4, 5].proper_superset?(s1) \n=> true\n>> Set[1, 2, 3, 4].proper_superset?(s1) \n=> false\n>> Set[1, 2, 3, 4].superset?(s1) \n=> true\n>> s1 ^ s2 \n=> \n>> s1.size \n=> 4\n>> s1 << 99 \n=> \n>> s1.delete(99) \n=> \n>> s1.merge(s2) \n=> \n>> s1.subtract(s2) \n=> \n>>\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\nclass Program\n{\n    static void PrintCollection(IEnumerable<int> x)\n    {\n        Console.WriteLine(string.Join(\" \", x));\n    }\n    static void Main(string[] args)\n    {\n        Console.OutputEncoding = Encoding.UTF8;\n        Console.WriteLine(\"Set creation\");\n        var A = new HashSet<int> { 4, 12, 14, 17, 18, 19, 20 };\n        var B = new HashSet<int> { 2, 5, 8, 11, 12, 13, 17, 18, 20 };\n\n        PrintCollection(A);\n        PrintCollection(B);\n\n        Console.WriteLine(\"Test m \u2208 S -- \\\"m is an element in set S\\\"\");\n        Console.WriteLine(\"14 is an element in set A: {0}\", A.Contains(14));\n        Console.WriteLine(\"15 is an element in set A: {0}\", A.Contains(15));\n\n        Console.WriteLine(\"A \u222a B -- union; a set of all elements either in set A or in set B.\");\n        var aUb = A.Union(B);\n        PrintCollection(aUb);\n\n        Console.WriteLine(\"A \u2216 B -- difference; a set of all elements in set A, except those in set B.\");\n        var aDb = A.Except(B);\n        PrintCollection(aDb);\n\n        Console.WriteLine(\"A \u2286 B -- subset; true if every element in set A is also in set B.\");\n        Console.WriteLine(A.IsSubsetOf(B));\n        var C = new HashSet<int> { 14, 17, 18 };\n        Console.WriteLine(C.IsSubsetOf(A));\n\n        Console.WriteLine(\"A = B -- equality; true if every element of set A is in set B and vice versa.\");\n        Console.WriteLine(A.SetEquals(B));\n        var D = new HashSet<int> { 4, 12, 14, 17, 18, 19, 20 };\n        Console.WriteLine(A.SetEquals(D));\n\n        Console.WriteLine(\"If A \u2286 B, but A \u2260 B, then A is called a true or proper subset of B, written A \u2282 B or A \u228a B\");\n        Console.WriteLine(A.IsProperSubsetOf(B));\n        Console.WriteLine(C.IsProperSubsetOf(A));\n\n        Console.WriteLine(\"Modify a mutable set.  (Add 10 to A; remove 12 from B).\");\n        A.Add(10);\n        B.Remove(12);\n        PrintCollection(A);\n        PrintCollection(B);\n\n        Console.ReadKey();\n    }\n}\n"}
{"id": 113181, "name": "Set", "source": "Translate Ruby to Java: >> require 'set'\n=> true\n>> s1, s2 = Set[1, 2, 3, 4], [3, 4, 5, 6].to_set \n=> [\n>> s1 | s2 \n=> \n>> s1 & s2 \n=> \n>> s1 - s2 \n=> \n>> s1.proper_subset?(s1) \n=> false\n>> Set[3, 1].proper_subset?(s1) \n=> true\n>> s1.subset?(s1) \n=> true\n>> Set[3, 1].subset?(s1) \n=> true\n>> Set[3, 2, 4, 1] == s1 \n=> true\n>> s1 == s2 \n=> false\n>> s1.include?(2) \n=> true\n>> Set[1, 2, 3, 4, 5].proper_superset?(s1) \n=> true\n>> Set[1, 2, 3, 4].proper_superset?(s1) \n=> false\n>> Set[1, 2, 3, 4].superset?(s1) \n=> true\n>> s1 ^ s2 \n=> \n>> s1.size \n=> 4\n>> s1 << 99 \n=> \n>> s1.delete(99) \n=> \n>> s1.merge(s2) \n=> \n>> s1.subtract(s2) \n=> \n>>\n", "target": "import java.util.Arrays;\nimport java.util.Collections;\nimport java.util.Set;\nimport java.util.TreeSet;\n\npublic class Sets {\n    public static void main(String[] args){\n        Set<Integer> a = new TreeSet<>();\n        \n        \n        \n        \n        \n        Set<Integer> b = new TreeSet<>();\n        Set<Integer> c = new TreeSet<>();\n        Set<Integer> d = new TreeSet<>();\n        \n        a.addAll(Arrays.asList(1, 2, 3, 4, 5));\n        b.addAll(Arrays.asList(2, 3, 4, 5, 6, 8));\n        c.addAll(Arrays.asList(2, 3, 4));\n        d.addAll(Arrays.asList(2, 3, 4));\n        System.out.println(\"a: \" + a);\n        System.out.println(\"b: \" + b);\n        System.out.println(\"c: \" + c);\n        System.out.println(\"d: \" + d);\n        \n        System.out.println(\"2 in a: \" + a.contains(2));\n        System.out.println(\"6 in a: \" + a.contains(6));\n        \n        Set<Integer> ab = new TreeSet<>();\n        ab.addAll(a);\n        ab.addAll(b);\n        System.out.println(\"a union b: \" + ab);\n        \n        Set<Integer> a_b = new TreeSet<>();\n        a_b.addAll(a);\n        a_b.removeAll(b);\n        System.out.println(\"a - b: \" + a_b);\n        \n        System.out.println(\"c subset of a: \" + a.containsAll(c));\n        \n        \n        System.out.println(\"c = d: \" + c.equals(d));\n        System.out.println(\"d = c: \" + d.equals(c));\n        \n        Set<Integer> aib = new TreeSet<>();\n        aib.addAll(a);\n        aib.retainAll(b);\n        System.out.println(\"a intersect b: \" + aib);\n        \n        System.out.println(\"add 7 to a: \" + a.add(7));\n        System.out.println(\"add 2 to a again: \" + a.add(2));\n        \n        \n        Set<Integer> empty = Collections.EMPTY_SET; \n        \n        empty.isEmpty(); \n        empty.size();\n        Collections.disjoint(a, b); \n        Collections.unmodifiableSet(a); \n    }\n}\n"}
{"id": 113182, "name": "Set", "source": "Translate Ruby to Python: >> require 'set'\n=> true\n>> s1, s2 = Set[1, 2, 3, 4], [3, 4, 5, 6].to_set \n=> [\n>> s1 | s2 \n=> \n>> s1 & s2 \n=> \n>> s1 - s2 \n=> \n>> s1.proper_subset?(s1) \n=> false\n>> Set[3, 1].proper_subset?(s1) \n=> true\n>> s1.subset?(s1) \n=> true\n>> Set[3, 1].subset?(s1) \n=> true\n>> Set[3, 2, 4, 1] == s1 \n=> true\n>> s1 == s2 \n=> false\n>> s1.include?(2) \n=> true\n>> Set[1, 2, 3, 4, 5].proper_superset?(s1) \n=> true\n>> Set[1, 2, 3, 4].proper_superset?(s1) \n=> false\n>> Set[1, 2, 3, 4].superset?(s1) \n=> true\n>> s1 ^ s2 \n=> \n>> s1.size \n=> 4\n>> s1 << 99 \n=> \n>> s1.delete(99) \n=> \n>> s1.merge(s2) \n=> \n>> s1.subtract(s2) \n=> \n>>\n", "target": ">>> s1, s2 = {1, 2, 3, 4}, {3, 4, 5, 6}\n>>> s1 | s2 \n{1, 2, 3, 4, 5, 6}\n>>> s1 & s2 \n{3, 4}\n>>> s1 - s2 \n{1, 2}\n>>> s1 < s1 \nFalse\n>>> {3, 1} < s1 \nTrue\n>>> s1 <= s1 \nTrue\n>>> {3, 1} <= s1 \nTrue\n>>> {3, 2, 4, 1} == s1 \nTrue\n>>> s1 == s2 \nFalse\n>>> 2 in s1 \nTrue\n>>> 10 not in s1 \nTrue\n>>> {1, 2, 3, 4, 5} > s1 \nTrue\n>>> {1, 2, 3, 4} > s1 \nFalse\n>>> {1, 2, 3, 4} >= s1 \nTrue\n>>> s1 ^ s2 \n{1, 2, 5, 6}\n>>> len(s1) \n4\n>>> s1.add(99) \n>>> s1\n{99, 1, 2, 3, 4}\n>>> s1.discard(99) \n>>> s1\n{1, 2, 3, 4}\n>>> s1 |= s2 \n>>> s1\n{1, 2, 3, 4, 5, 6}\n>>> s1 -= s2 \n>>> s1\n{1, 2}\n>>> s1 ^= s2 \n>>> s1\n{1, 2, 3, 4, 5, 6}\n>>>\n"}
{"id": 113503, "name": "Parsing_RPN calculator algorithm", "source": "Translate Ruby to C#: rpn = RPNExpression(\"3 4 2 * 1 5 - 2 3 ^ ^ / +\")\nvalue = rpn.eval\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Globalization;\nusing System.Threading;\n\nnamespace RPNEvaluator\n{\n    class RPNEvaluator\n    {\n        static void Main(string[] args)\n        {\n            Thread.CurrentThread.CurrentCulture = CultureInfo.InvariantCulture;\n\n            string rpn = \"3 4 2 * 1 5 - 2 3 ^ ^ / +\";\n            Console.WriteLine(\"{0}\\n\", rpn);\n\n            decimal result = CalculateRPN(rpn);\n            Console.WriteLine(\"\\nResult is {0}\", result);\n        }\n\n        static decimal CalculateRPN(string rpn)\n        {\n            string[] rpnTokens = rpn.Split(' ');\n            Stack<decimal> stack = new Stack<decimal>();\n            decimal number = decimal.Zero;\n\n            foreach (string token in rpnTokens)\n            {\n                if (decimal.TryParse(token, out number))\n                {\n                    stack.Push(number);\n                }\n                else\n                {\n                    switch (token)\n                    {\n                        case \"^\":\n                        case \"pow\":\n                            {\n                                number = stack.Pop();\n                                stack.Push((decimal)Math.Pow((double)stack.Pop(), (double)number));\n                                break;\n                            }\n                        case \"ln\":\n                            {\n                                stack.Push((decimal)Math.Log((double)stack.Pop(), Math.E));\n                                break;\n                            }\n                        case \"sqrt\":\n                            {\n                                stack.Push((decimal)Math.Sqrt((double)stack.Pop()));\n                                break;\n                            }\n                        case \"*\":\n                            {\n                                stack.Push(stack.Pop() * stack.Pop());\n                                break;\n                            }\n                        case \"/\":\n                            {\n                                number = stack.Pop();\n                                stack.Push(stack.Pop() / number);\n                                break;\n                            }\n                        case \"+\":\n                            {\n                                stack.Push(stack.Pop() + stack.Pop());\n                                break;\n                            }\n                        case \"-\":\n                            {\n                                number = stack.Pop();\n                                stack.Push(stack.Pop() - number);\n                                break;\n                            }\n                        default:\n                            Console.WriteLine(\"Error in CalculateRPN(string) Method!\");\n                            break;\n                    }\n                }\n                PrintState(stack);\n            }\n\n            return stack.Pop();\n        }\n\n        static void PrintState(Stack<decimal> stack)\n        {\n            decimal[] arr = stack.ToArray();\n\n            for (int i = arr.Length - 1; i >= 0; i--)\n            {\n                Console.Write(\"{0,-8:F3}\", arr[i]);\n            }\n            \n            Console.WriteLine();\n        }\n    }\n}\n"}
{"id": 113504, "name": "Parsing_RPN calculator algorithm", "source": "Translate Ruby to C#: rpn = RPNExpression(\"3 4 2 * 1 5 - 2 3 ^ ^ / +\")\nvalue = rpn.eval\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Globalization;\nusing System.Threading;\n\nnamespace RPNEvaluator\n{\n    class RPNEvaluator\n    {\n        static void Main(string[] args)\n        {\n            Thread.CurrentThread.CurrentCulture = CultureInfo.InvariantCulture;\n\n            string rpn = \"3 4 2 * 1 5 - 2 3 ^ ^ / +\";\n            Console.WriteLine(\"{0}\\n\", rpn);\n\n            decimal result = CalculateRPN(rpn);\n            Console.WriteLine(\"\\nResult is {0}\", result);\n        }\n\n        static decimal CalculateRPN(string rpn)\n        {\n            string[] rpnTokens = rpn.Split(' ');\n            Stack<decimal> stack = new Stack<decimal>();\n            decimal number = decimal.Zero;\n\n            foreach (string token in rpnTokens)\n            {\n                if (decimal.TryParse(token, out number))\n                {\n                    stack.Push(number);\n                }\n                else\n                {\n                    switch (token)\n                    {\n                        case \"^\":\n                        case \"pow\":\n                            {\n                                number = stack.Pop();\n                                stack.Push((decimal)Math.Pow((double)stack.Pop(), (double)number));\n                                break;\n                            }\n                        case \"ln\":\n                            {\n                                stack.Push((decimal)Math.Log((double)stack.Pop(), Math.E));\n                                break;\n                            }\n                        case \"sqrt\":\n                            {\n                                stack.Push((decimal)Math.Sqrt((double)stack.Pop()));\n                                break;\n                            }\n                        case \"*\":\n                            {\n                                stack.Push(stack.Pop() * stack.Pop());\n                                break;\n                            }\n                        case \"/\":\n                            {\n                                number = stack.Pop();\n                                stack.Push(stack.Pop() / number);\n                                break;\n                            }\n                        case \"+\":\n                            {\n                                stack.Push(stack.Pop() + stack.Pop());\n                                break;\n                            }\n                        case \"-\":\n                            {\n                                number = stack.Pop();\n                                stack.Push(stack.Pop() - number);\n                                break;\n                            }\n                        default:\n                            Console.WriteLine(\"Error in CalculateRPN(string) Method!\");\n                            break;\n                    }\n                }\n                PrintState(stack);\n            }\n\n            return stack.Pop();\n        }\n\n        static void PrintState(Stack<decimal> stack)\n        {\n            decimal[] arr = stack.ToArray();\n\n            for (int i = arr.Length - 1; i >= 0; i--)\n            {\n                Console.Write(\"{0,-8:F3}\", arr[i]);\n            }\n            \n            Console.WriteLine();\n        }\n    }\n}\n"}
{"id": 113507, "name": "Parsing_RPN calculator algorithm", "source": "Translate Ruby to Java: rpn = RPNExpression(\"3 4 2 * 1 5 - 2 3 ^ ^ / +\")\nvalue = rpn.eval\n", "target": "grammar rpnC ;\n\n\n\n\n\n@members {\nStack<Double> s = new Stack<Double>();\n}\nrpn\t:\t(WS* (num|op) (WS | WS* NEWLINE {System.out.println(s.pop());}))*;\nnum\t:\t'-'? Digit+ ('.' Digit+)? {s.push(Double.parseDouble($num.text));};\nDigit\t:\t'0'..'9';\nop\t:\t'-' {double x = s.pop(); s.push(s.pop() - x);}\n\t|\t'/' {double x = s.pop(); s.push(s.pop() / x);}\n\t|\t'*' {s.push(s.pop() * s.pop());}\n\t|\t'^' {double x = s.pop(); s.push(Math.pow(s.pop(), x));}\n\t|\t'+' {s.push(s.pop() + s.pop());};\nWS\t:\t(' ' | '\\t'){skip()};\nNEWLINE\t:\t'\\r'? '\\n';\n"}
{"id": 113508, "name": "Parsing_RPN calculator algorithm", "source": "Translate Ruby to Java: rpn = RPNExpression(\"3 4 2 * 1 5 - 2 3 ^ ^ / +\")\nvalue = rpn.eval\n", "target": "grammar rpnC ;\n\n\n\n\n\n@members {\nStack<Double> s = new Stack<Double>();\n}\nrpn\t:\t(WS* (num|op) (WS | WS* NEWLINE {System.out.println(s.pop());}))*;\nnum\t:\t'-'? Digit+ ('.' Digit+)? {s.push(Double.parseDouble($num.text));};\nDigit\t:\t'0'..'9';\nop\t:\t'-' {double x = s.pop(); s.push(s.pop() - x);}\n\t|\t'/' {double x = s.pop(); s.push(s.pop() / x);}\n\t|\t'*' {s.push(s.pop() * s.pop());}\n\t|\t'^' {double x = s.pop(); s.push(Math.pow(s.pop(), x));}\n\t|\t'+' {s.push(s.pop() + s.pop());};\nWS\t:\t(' ' | '\\t'){skip()};\nNEWLINE\t:\t'\\r'? '\\n';\n"}
{"id": 113509, "name": "Parsing_RPN calculator algorithm", "source": "Translate Ruby to Python: rpn = RPNExpression(\"3 4 2 * 1 5 - 2 3 ^ ^ / +\")\nvalue = rpn.eval\n", "target": "def op_pow(stack):\n    b = stack.pop(); a = stack.pop()\n    stack.append( a ** b )\ndef op_mul(stack):\n    b = stack.pop(); a = stack.pop()\n    stack.append( a * b )\ndef op_div(stack):\n    b = stack.pop(); a = stack.pop()\n    stack.append( a / b )\ndef op_add(stack):\n    b = stack.pop(); a = stack.pop()\n    stack.append( a + b )\ndef op_sub(stack):\n    b = stack.pop(); a = stack.pop()\n    stack.append( a - b )\ndef op_num(stack, num):\n    stack.append( num )\n    \nops = {\n '^': op_pow,\n '*': op_mul,\n '/': op_div,\n '+': op_add,\n '-': op_sub,\n }\n\ndef get_input(inp = None):\n    'Inputs an expression and returns list of tokens'\n    \n    if inp is None:\n        inp = input('expression: ')\n    tokens = inp.strip().split()\n    return tokens\n\ndef rpn_calc(tokens):\n    stack = []\n    table = ['TOKEN,ACTION,STACK'.split(',')]\n    for token in tokens:\n        if token in ops:\n            action = 'Apply op to top of stack'\n            ops[token](stack)\n            table.append( (token, action, ' '.join(str(s) for s in stack)) )\n        else:\n            action = 'Push num onto top of stack'\n            op_num(stack, eval(token))\n            table.append( (token, action, ' '.join(str(s) for s in stack)) )\n    return table\n\nif __name__ == '__main__':\n    rpn = '3 4 2 * 1 5 - 2 3 ^ ^ / +'\n    print( 'For RPN expression: %r\\n' % rpn )\n    rp = rpn_calc(get_input(rpn))\n    maxcolwidths = [max(len(y) for y in x) for x in zip(*rp)]\n    row = rp[0]\n    print( ' '.join('{cell:^{width}}'.format(width=width, cell=cell) for (width, cell) in zip(maxcolwidths, row)))\n    for row in rp[1:]:\n        print( ' '.join('{cell:<{width}}'.format(width=width, cell=cell) for (width, cell) in zip(maxcolwidths, row)))\n\n    print('\\n The final output value is: %r' % rp[-1][2])\n"}
{"id": 113510, "name": "Parsing_RPN calculator algorithm", "source": "Translate Ruby to Python: rpn = RPNExpression(\"3 4 2 * 1 5 - 2 3 ^ ^ / +\")\nvalue = rpn.eval\n", "target": "def op_pow(stack):\n    b = stack.pop(); a = stack.pop()\n    stack.append( a ** b )\ndef op_mul(stack):\n    b = stack.pop(); a = stack.pop()\n    stack.append( a * b )\ndef op_div(stack):\n    b = stack.pop(); a = stack.pop()\n    stack.append( a / b )\ndef op_add(stack):\n    b = stack.pop(); a = stack.pop()\n    stack.append( a + b )\ndef op_sub(stack):\n    b = stack.pop(); a = stack.pop()\n    stack.append( a - b )\ndef op_num(stack, num):\n    stack.append( num )\n    \nops = {\n '^': op_pow,\n '*': op_mul,\n '/': op_div,\n '+': op_add,\n '-': op_sub,\n }\n\ndef get_input(inp = None):\n    'Inputs an expression and returns list of tokens'\n    \n    if inp is None:\n        inp = input('expression: ')\n    tokens = inp.strip().split()\n    return tokens\n\ndef rpn_calc(tokens):\n    stack = []\n    table = ['TOKEN,ACTION,STACK'.split(',')]\n    for token in tokens:\n        if token in ops:\n            action = 'Apply op to top of stack'\n            ops[token](stack)\n            table.append( (token, action, ' '.join(str(s) for s in stack)) )\n        else:\n            action = 'Push num onto top of stack'\n            op_num(stack, eval(token))\n            table.append( (token, action, ' '.join(str(s) for s in stack)) )\n    return table\n\nif __name__ == '__main__':\n    rpn = '3 4 2 * 1 5 - 2 3 ^ ^ / +'\n    print( 'For RPN expression: %r\\n' % rpn )\n    rp = rpn_calc(get_input(rpn))\n    maxcolwidths = [max(len(y) for y in x) for x in zip(*rp)]\n    row = rp[0]\n    print( ' '.join('{cell:^{width}}'.format(width=width, cell=cell) for (width, cell) in zip(maxcolwidths, row)))\n    for row in rp[1:]:\n        print( ' '.join('{cell:<{width}}'.format(width=width, cell=cell) for (width, cell) in zip(maxcolwidths, row)))\n\n    print('\\n The final output value is: %r' % rp[-1][2])\n"}
{"id": 113828, "name": "Run-length encoding", "source": "Translate Ruby to C#: \ndef run_encode(string)\n  string\n    .chars\n    .chunk{|i| i}\n    .map {|kind, array| [kind, array.length]}\nend\n\n\ndef run_decode(char_counts)\n  char_counts\n    .map{|char, count| char * count}\n    .join\nend\n", "target": "using System.Collections.Generic;\nusing System.Linq;\nusing static System.Console;\nusing static System.Linq.Enumerable;\n\nnamespace RunLengthEncoding\n{\n    static class Program\n    {\n          public static string Encode(string input) => input.Length ==0 ? \"\" : input.Skip(1)\n            .Aggregate((t:input[0].ToString(),o:Empty<string>()),\n               (a,c)=>a.t[0]==c ? (a.t+c,a.o) : (c.ToString(),a.o.Append(a.t)),\n               a=>a.o.Append(a.t).Select(p => (key: p.Length, chr: p[0])))\n            .Select(p=> $\"{p.key}{p.chr}\")\n            .StringConcat();\n\n        public static string Decode(string input) => input\n            .Aggregate((t: \"\", o: Empty<string>()), (a, c) => !char.IsDigit(c) ? (\"\", a.o.Append(a.t+c)) : (a.t + c,a.o)).o \n            .Select(p => new string(p.Last(), int.Parse(string.Concat(p.Where(char.IsDigit)))))\n            .StringConcat();\n\n        private static string StringConcat(this IEnumerable<string> seq) => string.Concat(seq);\n        \n        public static void Main(string[] args)\n        {\n            const string  raw = \"WWWWWWWWWWWWBWWWWWWWWWWWWBBBWWWWWWWWWWWWWWWWWWWWWWWWBWWWWWWWWWWWWWW\";\n            const string encoded = \"12W1B12W3B24W1B14W\";\n\n            WriteLine($\"raw = {raw}\");\n            WriteLine($\"encoded = {encoded}\");\n            WriteLine($\"Encode(raw) = encoded = {Encode(raw)}\");\n            WriteLine($\"Decode(encode) = {Decode(encoded)}\");\n            WriteLine($\"Decode(Encode(raw)) = {Decode(Encode(raw)) == raw}\");\n            ReadLine();\n        }\n    }\n}\n"}
{"id": 113830, "name": "Run-length encoding", "source": "Translate Ruby to Java: \ndef run_encode(string)\n  string\n    .chars\n    .chunk{|i| i}\n    .map {|kind, array| [kind, array.length]}\nend\n\n\ndef run_decode(char_counts)\n  char_counts\n    .map{|char, count| char * count}\n    .join\nend\n", "target": "import java.util.regex.Matcher;\nimport java.util.regex.Pattern;\npublic class RunLengthEncoding {\n\n    public static String encode(String source) {\n        StringBuffer dest = new StringBuffer();\n        for (int i = 0; i < source.length(); i++) {\n            int runLength = 1;\n            while (i+1 < source.length() && source.charAt(i) == source.charAt(i+1)) {\n                runLength++;\n                i++;\n            }\n            dest.append(runLength);\n            dest.append(source.charAt(i));\n        }\n        return dest.toString();\n    }\n\n    public static String decode(String source) {\n        StringBuffer dest = new StringBuffer();\n        Pattern pattern = Pattern.compile(\"[0-9]+|[a-zA-Z]\");\n        Matcher matcher = pattern.matcher(source);\n        while (matcher.find()) {\n            int number = Integer.parseInt(matcher.group());\n            matcher.find();\n            while (number-- != 0) {\n                dest.append(matcher.group());\n            }\n        }\n        return dest.toString();\n    }\n\n    public static void main(String[] args) {\n        String example = \"WWWWWWWWWWWWBWWWWWWWWWWWWBBBWWWWWWWWWWWWWWWWWWWWWWWWBWWWWWWWWWWWWWW\";\n        System.out.println(encode(example));\n        System.out.println(decode(\"1W1B1W1B1W1B1W1B1W1B1W1B1W1B\"));\n    }\n}\n"}
{"id": 113831, "name": "Run-length encoding", "source": "Translate Ruby to Python: \ndef run_encode(string)\n  string\n    .chars\n    .chunk{|i| i}\n    .map {|kind, array| [kind, array.length]}\nend\n\n\ndef run_decode(char_counts)\n  char_counts\n    .map{|char, count| char * count}\n    .join\nend\n", "target": "def encode(input_string):\n    count = 1\n    prev = None\n    lst = []\n    for character in input_string:\n        if character != prev:\n            if prev:\n                entry = (prev, count)\n                lst.append(entry)\n            count = 1\n            prev = character\n        else:\n            count += 1\n    else:\n        try:\n            entry = (character, count)\n            lst.append(entry)\n            return (lst, 0)\n        except Exception as e:\n            print(\"Exception encountered {e}\".format(e=e)) \n            return (e, 1)\n \ndef decode(lst):\n    q = []\n    for character, count in lst:\n        q.append(character * count)\n    return ''.join(q)\n \n\nvalue = encode(\"aaaaahhhhhhmmmmmmmuiiiiiiiaaaaaa\")\nif value[1] == 0:\n    print(\"Encoded value is {}\".format(value[0]))\n    decode(value[0])\n"}
{"id": 114101, "name": "Anonymous recursion", "source": "Translate Ruby to C#: def fib(n)\n  raise RangeError, \"fib of negative\" if n < 0\n  (fib2 = proc { |m| m < 2 ? m : fib2[m - 1] + fib2[m - 2] })[n]\nend\n", "target": "static int Fib(int n)\n{\n    if (n < 0) throw new ArgumentException(\"Must be non negativ\", \"n\");\n \n    Func<int, int> fib = null; \n    fib = p => p > 1 ? fib(p - 2) + fib(p - 1) : p;\n    return fib(n);\n}\n"}
{"id": 114103, "name": "Anonymous recursion", "source": "Translate Ruby to Java: def fib(n)\n  raise RangeError, \"fib of negative\" if n < 0\n  (fib2 = proc { |m| m < 2 ? m : fib2[m - 1] + fib2[m - 2] })[n]\nend\n", "target": "public static long fib(int n) {\n    if (n < 0)\n        throw new IllegalArgumentException(\"n can not be a negative number\");\n\n    return new Object() {\n        private long fibInner(int n) {\n            return (n < 2) ? n : (fibInner(n - 1) + fibInner(n - 2));\n        }\n    }.fibInner(n);\n}\n"}
{"id": 114104, "name": "Anonymous recursion", "source": "Translate Ruby to Python: def fib(n)\n  raise RangeError, \"fib of negative\" if n < 0\n  (fib2 = proc { |m| m < 2 ? m : fib2[m - 1] + fib2[m - 2] })[n]\nend\n", "target": ">>> Y = lambda f: (lambda x: x(x))(lambda y: f(lambda *args: y(y)(*args)))\n>>> fib = lambda f: lambda n: None if n < 0 else (0 if n == 0 else (1 if n == 1 else f(n-1) + f(n-2)))\n>>> [ Y(fib)(i) for i in range(-2, 10) ]\n[None, None, 0, 1, 1, 2, 3, 5, 8, 13, 21, 34]\n"}
{"id": 114599, "name": "A+B", "source": "Translate Ruby to C#: puts gets.not_nil!.split.map(&.to_i).sum\n", "target": "using System;\nusing System.Linq;\n\nclass Program\n{\n    static void Main()\n    {\n        Console.WriteLine(Console.ReadLine().Split().Select(int.Parse).Sum());\n    }\n}\n"}
{"id": 114600, "name": "A+B", "source": "Translate Ruby to C#: puts gets.not_nil!.split.map(&.to_i).sum\n", "target": "using System;\nusing System.Linq;\n\nclass Program\n{\n    static void Main()\n    {\n        Console.WriteLine(Console.ReadLine().Split().Select(int.Parse).Sum());\n    }\n}\n"}
{"id": 114603, "name": "A+B", "source": "Translate Ruby to Java: puts gets.not_nil!.split.map(&.to_i).sum\n", "target": "import java.util.Scanner;\n\npublic class Sum2 {\n    public static void main(String[] args) {\n        Scanner in = new Scanner(System.in); \n        System.out.println(in.nextInt() + in.nextInt()); \n    }\n}\n"}
{"id": 114604, "name": "A+B", "source": "Translate Ruby to Java: puts gets.not_nil!.split.map(&.to_i).sum\n", "target": "import java.util.Scanner;\n\npublic class Sum2 {\n    public static void main(String[] args) {\n        Scanner in = new Scanner(System.in); \n        System.out.println(in.nextInt() + in.nextInt()); \n    }\n}\n"}
{"id": 114605, "name": "A+B", "source": "Translate Ruby to Python: puts gets.not_nil!.split.map(&.to_i).sum\n", "target": "try: raw_input\nexcept: raw_input = input\n\nprint(sum(map(int, raw_input().split())))\n"}
{"id": 114606, "name": "A+B", "source": "Translate Ruby to Python: puts gets.not_nil!.split.map(&.to_i).sum\n", "target": "try: raw_input\nexcept: raw_input = input\n\nprint(sum(map(int, raw_input().split())))\n"}
{"id": 114959, "name": "Leap year", "source": "Translate Ruby to C#: p Time.leap_year?(2020)\np Time.leap_year?(2021)\np Time.leap_year?(2022)\n", "target": "using System;\n\nclass Program\n{\n    static void Main()\n    {\n        foreach (var year in new[] { 1900, 1994, 1996, DateTime.Now.Year })\n        {\n            Console.WriteLine(\"{0} is {1}a leap year.\",\n                              year,\n                              DateTime.IsLeapYear(year) ? string.Empty : \"not \");\n        }\n    }\n}\n"}
{"id": 114961, "name": "Leap year", "source": "Translate Ruby to Java: p Time.leap_year?(2020)\np Time.leap_year?(2021)\np Time.leap_year?(2022)\n", "target": "import java.util.GregorianCalendar;\nimport java.text.MessageFormat;\n\npublic class Leapyear{\n        public static void main(String[] argv){\n                int[] yrs = {1800,1900,1994,1998,1999,2000,2001,2004,2100};\n                GregorianCalendar cal = new GregorianCalendar();\n                for(int year : yrs){\n                        System.err.println(MessageFormat.format(\"The year {0,number,#} is leaper: {1} / {2}.\",\n                                                                 year, cal.isLeapYear(year), isLeapYear(year)));\n                }\n\n        }\n        public static boolean isLeapYear(int year){\n                return (year % 100 == 0) ? (year % 400 == 0) : (year % 4 == 0);\n        }\n}\n"}
{"id": 114962, "name": "Leap year", "source": "Translate Ruby to Python: p Time.leap_year?(2020)\np Time.leap_year?(2021)\np Time.leap_year?(2022)\n", "target": "import calendar\ncalendar.isleap(year)\n"}
{"id": 115222, "name": "Program name", "source": "Translate Ruby to C#: \n\nputs \"Path: \nputs \"Name: \n", "target": "using System;\nnamespace ProgramName\n{\n\tclass Program\n\t{\n\t\tstatic void Main(string[] args)\n\t\t{\n\t\t\tConsole.Write(Environment.CommandLine);\n\t\t}\n\t}\n}\n"}
{"id": 115224, "name": "Program name", "source": "Translate Ruby to Java: \n\nputs \"Path: \nputs \"Name: \n", "target": "public class ScriptName {\n\tpublic static void main(String[] args) {\n\t\tString program = System.getProperty(\"sun.java.command\").split(\" \")[0];\n\t\tSystem.out.println(\"Program: \" + program);\n\t}\n}\n"}
{"id": 115225, "name": "Program name", "source": "Translate Ruby to Python: \n\nputs \"Path: \nputs \"Name: \n", "target": "\n\nimport sys\n\ndef main():\n    program = sys.argv[0]\n    print(\"Program: %s\" % program)\n\nif __name__ == \"__main__\":\n    main()\n"}
{"id": 115362, "name": "Terminal control_Ringing the terminal bell", "source": "Translate Ruby to C#: print \"\\a\"\n", "target": "\nSystem.Console.Write(\"\\a\"); \nSystem.Threading.Thread.Sleep(1000); \nSystem.Console.Beep(); \nSystem.Threading.Thread.Sleep(1000);\n\n\nSystem.Console.Beep(440, 2000); \n"}
{"id": 115363, "name": "Terminal control_Ringing the terminal bell", "source": "Translate Ruby to Java: print \"\\a\"\n", "target": "public class Bell{\n    public static void main(String[] args){\n        java.awt.Toolkit.getDefaultToolkit().beep();\n\n        \n\n        System.out.println((char)7);\n    }\n}\n"}
{"id": 115479, "name": "Doubly-linked list_Element insertion", "source": "Translate Ruby to C#: class DListNode\n  def insert_after(search_value, new_value)\n    if search_value == value\n      new_node = self.class.new(new_value, nil, nil)\n      next_node = self.succ\n      self.succ = new_node\n      new_node.prev = self\n      new_node.succ = next_node\n      next_node.prev = new_node\n    elsif self.succ.nil?\n      raise StandardError, \"value \n    else\n      self.succ.insert_after(search_value, new_value)\n    end\n  end\nend\n\nhead = DListNode.from_array([:a, :b])\nhead.insert_after(:a, :c)\n", "target": "static void InsertAfter(Link prev, int i)\n{\n    if (prev.next != null)\n    {\n        prev.next.prev = new Link() { item = i, prev = prev, next = prev.next };\n        prev.next = prev.next.prev;\n    }\n    else\n        prev.next = new Link() { item = i, prev = prev };\n}\n"}
{"id": 115481, "name": "Doubly-linked list_Element insertion", "source": "Translate Ruby to Java: class DListNode\n  def insert_after(search_value, new_value)\n    if search_value == value\n      new_node = self.class.new(new_value, nil, nil)\n      next_node = self.succ\n      self.succ = new_node\n      new_node.prev = self\n      new_node.succ = next_node\n      next_node.prev = new_node\n    elsif self.succ.nil?\n      raise StandardError, \"value \n    else\n      self.succ.insert_after(search_value, new_value)\n    end\n  end\nend\n\nhead = DListNode.from_array([:a, :b])\nhead.insert_after(:a, :c)\n", "target": "import java.util.LinkedList;\n\n@SuppressWarnings(\"serial\")\npublic class DoublyLinkedListInsertion<T> extends LinkedList<T> {\n   \n    public static void main(String[] args) {\n        DoublyLinkedListInsertion<String> list = new DoublyLinkedListInsertion<String>();\n        list.addFirst(\"Add First 1\");\n        list.addFirst(\"Add First 2\");\n        list.addFirst(\"Add First 3\");\n        list.addFirst(\"Add First 4\");\n        list.addFirst(\"Add First 5\");\n        traverseList(list);\n        \n        list.addAfter(\"Add First 3\", \"Add New\");\n        traverseList(list);\n    }\n    \n    \n    public void addAfter(T after, T element) {\n        int index = indexOf(after);\n        if ( index >= 0 ) {\n            add(index + 1, element);\n        }\n        else {\n            addLast(element);\n        }\n    }\n    \n    private static void traverseList(LinkedList<String> list) {\n        System.out.println(\"Traverse List:\");\n        for ( int i = 0 ; i < list.size() ; i++ ) {\n            System.out.printf(\"Element number %d - Element value = '%s'%n\", i, list.get(i));\n        }\n        System.out.println();\n    }\n    \n}\n"}
{"id": 115482, "name": "Doubly-linked list_Element insertion", "source": "Translate Ruby to Python: class DListNode\n  def insert_after(search_value, new_value)\n    if search_value == value\n      new_node = self.class.new(new_value, nil, nil)\n      next_node = self.succ\n      self.succ = new_node\n      new_node.prev = self\n      new_node.succ = next_node\n      next_node.prev = new_node\n    elsif self.succ.nil?\n      raise StandardError, \"value \n    else\n      self.succ.insert_after(search_value, new_value)\n    end\n  end\nend\n\nhead = DListNode.from_array([:a, :b])\nhead.insert_after(:a, :c)\n", "target": "def insert(anchor, new):\n    new.next = anchor.next\n    new.prev = anchor\n    anchor.next.prev = new\n    anchor.next = new\n"}
{"id": 115917, "name": "N-queens problem", "source": "Translate Ruby to C#: \"\"\"\n\n\nPorted to **Julia** from examples in several languages from\nhere: https://hbfs.wordpress.com/2009/11/10/is-python-slow\n\"\"\"\nmodule EightQueensPuzzle\n\nexport Board, solve!\n\nmutable struct Board\n    cols::Int\n    nodes::Int\n    diag45::Int\n    diag135::Int\n    solutions::Int\n\n    Board() = new(0, 0, 0, 0, 0)\nend\n\n\"Marks occupancy.\"\nfunction mark!(b::Board, k::Int, j::Int)\n    b.cols    \u22bb= (1 << j)\n    b.diag135 \u22bb= (1 << (j+k))\n    b.diag45  \u22bb= (1 << (32+j-k))\nend\n\n\"Tests if a square is menaced.\"\nfunction test(b::Board, k::Int, j::Int)\n    b.cols    & (1 << j)        +\n    b.diag135 & (1 << (j+k))    +\n    b.diag45  & (1 << (32+j-k)) == 0\nend\n\n\"Backtracking solver.\"\nfunction solve!(b::Board, niv::Int, dx::Int)\n    if niv > 0\n        for i in 0:dx-1\n            if test(b, niv, i) == true\n                mark!(b, niv, i)\n                solve!(b, niv-1, dx)\n                mark!(b, niv, i)\n            end\n        end\n    else\n        for i in 0:dx-1\n            if test(b, 0, i) == true\n                b.solutions += 1\n            end\n        end\n    end\n    b.nodes += 1\n    b.solutions\nend\n\nend \n\nusing  .EightQueensPuzzle\n\nfor n = 1:17\n    b = Board()\n    @show n\n    print(\"elapsed:\")\n    solutions = @time solve!(b, n-1, n)\n    @show solutions\n    println()\nend\n", "target": "using System.Collections.Generic;\nusing static System.Linq.Enumerable;\nusing static System.Console;\nusing static System.Math;\n\nnamespace N_Queens\n{\n    static class Program\n    {\n        static void Main(string[] args)\n        {\n            var n = 8;\n            var cols = Range(0, n);\n            var combs = cols.Combinations(2).Select(pairs=> pairs.ToArray());\n            var solved = from v in cols.Permutations().Select(p => p.ToArray())\n                         where combs.All(c => Abs(v[c[0]] - v[c[1]]) != Abs(c[0] - c[1]))\n                         select v;\n            \n            WriteLine($\"{n}-queens has {solved.Count()} solutions\");\n            WriteLine(\"Position is row, value is column:-\");\n            var first = string.Join(\" \", solved.First());\n            WriteLine($\"First Solution: {first}\");\n            Read();\n        }\n\n        \n        public static IEnumerable<IEnumerable<T>> Permutations<T>(this IEnumerable<T> values)\n        {\n            if (values.Count() == 1)\n                return values.ToSingleton();\n\n            return values.SelectMany(v => Permutations(values.Except(v.ToSingleton())), (v, p) => p.Prepend(v));\n        }\n\n        public static IEnumerable<IEnumerable<T>> Combinations<T>(this IEnumerable<T> seq) =>\n            seq.Aggregate(Empty<T>().ToSingleton(), (a, b) => a.Concat(a.Select(x => x.Append(b))));\n\n        public static IEnumerable<IEnumerable<T>> Combinations<T>(this IEnumerable<T> seq, int numItems) =>\n            seq.Combinations().Where(s => s.Count() == numItems);\n\n        public static IEnumerable<T> ToSingleton<T>(this T item) { yield return item; }\n    }\n}\n"}
{"id": 115918, "name": "N-queens problem", "source": "Translate Ruby to C#: \"\"\"\n\n\nPorted to **Julia** from examples in several languages from\nhere: https://hbfs.wordpress.com/2009/11/10/is-python-slow\n\"\"\"\nmodule EightQueensPuzzle\n\nexport Board, solve!\n\nmutable struct Board\n    cols::Int\n    nodes::Int\n    diag45::Int\n    diag135::Int\n    solutions::Int\n\n    Board() = new(0, 0, 0, 0, 0)\nend\n\n\"Marks occupancy.\"\nfunction mark!(b::Board, k::Int, j::Int)\n    b.cols    \u22bb= (1 << j)\n    b.diag135 \u22bb= (1 << (j+k))\n    b.diag45  \u22bb= (1 << (32+j-k))\nend\n\n\"Tests if a square is menaced.\"\nfunction test(b::Board, k::Int, j::Int)\n    b.cols    & (1 << j)        +\n    b.diag135 & (1 << (j+k))    +\n    b.diag45  & (1 << (32+j-k)) == 0\nend\n\n\"Backtracking solver.\"\nfunction solve!(b::Board, niv::Int, dx::Int)\n    if niv > 0\n        for i in 0:dx-1\n            if test(b, niv, i) == true\n                mark!(b, niv, i)\n                solve!(b, niv-1, dx)\n                mark!(b, niv, i)\n            end\n        end\n    else\n        for i in 0:dx-1\n            if test(b, 0, i) == true\n                b.solutions += 1\n            end\n        end\n    end\n    b.nodes += 1\n    b.solutions\nend\n\nend \n\nusing  .EightQueensPuzzle\n\nfor n = 1:17\n    b = Board()\n    @show n\n    print(\"elapsed:\")\n    solutions = @time solve!(b, n-1, n)\n    @show solutions\n    println()\nend\n", "target": "using System.Collections.Generic;\nusing static System.Linq.Enumerable;\nusing static System.Console;\nusing static System.Math;\n\nnamespace N_Queens\n{\n    static class Program\n    {\n        static void Main(string[] args)\n        {\n            var n = 8;\n            var cols = Range(0, n);\n            var combs = cols.Combinations(2).Select(pairs=> pairs.ToArray());\n            var solved = from v in cols.Permutations().Select(p => p.ToArray())\n                         where combs.All(c => Abs(v[c[0]] - v[c[1]]) != Abs(c[0] - c[1]))\n                         select v;\n            \n            WriteLine($\"{n}-queens has {solved.Count()} solutions\");\n            WriteLine(\"Position is row, value is column:-\");\n            var first = string.Join(\" \", solved.First());\n            WriteLine($\"First Solution: {first}\");\n            Read();\n        }\n\n        \n        public static IEnumerable<IEnumerable<T>> Permutations<T>(this IEnumerable<T> values)\n        {\n            if (values.Count() == 1)\n                return values.ToSingleton();\n\n            return values.SelectMany(v => Permutations(values.Except(v.ToSingleton())), (v, p) => p.Prepend(v));\n        }\n\n        public static IEnumerable<IEnumerable<T>> Combinations<T>(this IEnumerable<T> seq) =>\n            seq.Aggregate(Empty<T>().ToSingleton(), (a, b) => a.Concat(a.Select(x => x.Append(b))));\n\n        public static IEnumerable<IEnumerable<T>> Combinations<T>(this IEnumerable<T> seq, int numItems) =>\n            seq.Combinations().Where(s => s.Count() == numItems);\n\n        public static IEnumerable<T> ToSingleton<T>(this T item) { yield return item; }\n    }\n}\n"}
{"id": 115921, "name": "N-queens problem", "source": "Translate Ruby to Java: \"\"\"\n\n\nPorted to **Julia** from examples in several languages from\nhere: https://hbfs.wordpress.com/2009/11/10/is-python-slow\n\"\"\"\nmodule EightQueensPuzzle\n\nexport Board, solve!\n\nmutable struct Board\n    cols::Int\n    nodes::Int\n    diag45::Int\n    diag135::Int\n    solutions::Int\n\n    Board() = new(0, 0, 0, 0, 0)\nend\n\n\"Marks occupancy.\"\nfunction mark!(b::Board, k::Int, j::Int)\n    b.cols    \u22bb= (1 << j)\n    b.diag135 \u22bb= (1 << (j+k))\n    b.diag45  \u22bb= (1 << (32+j-k))\nend\n\n\"Tests if a square is menaced.\"\nfunction test(b::Board, k::Int, j::Int)\n    b.cols    & (1 << j)        +\n    b.diag135 & (1 << (j+k))    +\n    b.diag45  & (1 << (32+j-k)) == 0\nend\n\n\"Backtracking solver.\"\nfunction solve!(b::Board, niv::Int, dx::Int)\n    if niv > 0\n        for i in 0:dx-1\n            if test(b, niv, i) == true\n                mark!(b, niv, i)\n                solve!(b, niv-1, dx)\n                mark!(b, niv, i)\n            end\n        end\n    else\n        for i in 0:dx-1\n            if test(b, 0, i) == true\n                b.solutions += 1\n            end\n        end\n    end\n    b.nodes += 1\n    b.solutions\nend\n\nend \n\nusing  .EightQueensPuzzle\n\nfor n = 1:17\n    b = Board()\n    @show n\n    print(\"elapsed:\")\n    solutions = @time solve!(b, n-1, n)\n    @show solutions\n    println()\nend\n", "target": "public class NQueens {\n\n  private static int[] b = new int[8];\n  private static int s = 0;\n\n  static boolean unsafe(int y) {\n    int x = b[y];\n    for (int i = 1; i <= y; i++) {\n      int t = b[y - i];\n      if (t == x ||\n          t == x - i ||\n          t == x + i) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  public static void putboard() {\n    System.out.println(\"\\n\\nSolution \" + (++s));\n    for (int y = 0; y < 8; y++) {\n      for (int x = 0; x < 8; x++) {\n        System.out.print((b[y] == x) ? \"|Q\" : \"|_\");\n      }\n      System.out.println(\"|\");\n    }\n  }\n\n  public static void main(String[] args) {\n    int y = 0;\n    b[0] = -1;\n    while (y >= 0) {\n      do {\n        b[y]++;\n      } while ((b[y] < 8) && unsafe(y));\n      if (b[y] < 8) {\n        if (y < 7) {\n          b[++y] = -1;\n        } else {\n          putboard();\n        }\n      } else {\n        y--;\n      }\n    }\n  }\n}\n"}
{"id": 115922, "name": "N-queens problem", "source": "Translate Ruby to Java: \"\"\"\n\n\nPorted to **Julia** from examples in several languages from\nhere: https://hbfs.wordpress.com/2009/11/10/is-python-slow\n\"\"\"\nmodule EightQueensPuzzle\n\nexport Board, solve!\n\nmutable struct Board\n    cols::Int\n    nodes::Int\n    diag45::Int\n    diag135::Int\n    solutions::Int\n\n    Board() = new(0, 0, 0, 0, 0)\nend\n\n\"Marks occupancy.\"\nfunction mark!(b::Board, k::Int, j::Int)\n    b.cols    \u22bb= (1 << j)\n    b.diag135 \u22bb= (1 << (j+k))\n    b.diag45  \u22bb= (1 << (32+j-k))\nend\n\n\"Tests if a square is menaced.\"\nfunction test(b::Board, k::Int, j::Int)\n    b.cols    & (1 << j)        +\n    b.diag135 & (1 << (j+k))    +\n    b.diag45  & (1 << (32+j-k)) == 0\nend\n\n\"Backtracking solver.\"\nfunction solve!(b::Board, niv::Int, dx::Int)\n    if niv > 0\n        for i in 0:dx-1\n            if test(b, niv, i) == true\n                mark!(b, niv, i)\n                solve!(b, niv-1, dx)\n                mark!(b, niv, i)\n            end\n        end\n    else\n        for i in 0:dx-1\n            if test(b, 0, i) == true\n                b.solutions += 1\n            end\n        end\n    end\n    b.nodes += 1\n    b.solutions\nend\n\nend \n\nusing  .EightQueensPuzzle\n\nfor n = 1:17\n    b = Board()\n    @show n\n    print(\"elapsed:\")\n    solutions = @time solve!(b, n-1, n)\n    @show solutions\n    println()\nend\n", "target": "public class NQueens {\n\n  private static int[] b = new int[8];\n  private static int s = 0;\n\n  static boolean unsafe(int y) {\n    int x = b[y];\n    for (int i = 1; i <= y; i++) {\n      int t = b[y - i];\n      if (t == x ||\n          t == x - i ||\n          t == x + i) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  public static void putboard() {\n    System.out.println(\"\\n\\nSolution \" + (++s));\n    for (int y = 0; y < 8; y++) {\n      for (int x = 0; x < 8; x++) {\n        System.out.print((b[y] == x) ? \"|Q\" : \"|_\");\n      }\n      System.out.println(\"|\");\n    }\n  }\n\n  public static void main(String[] args) {\n    int y = 0;\n    b[0] = -1;\n    while (y >= 0) {\n      do {\n        b[y]++;\n      } while ((b[y] < 8) && unsafe(y));\n      if (b[y] < 8) {\n        if (y < 7) {\n          b[++y] = -1;\n        } else {\n          putboard();\n        }\n      } else {\n        y--;\n      }\n    }\n  }\n}\n"}
{"id": 115923, "name": "N-queens problem", "source": "Translate Ruby to Python: \"\"\"\n\n\nPorted to **Julia** from examples in several languages from\nhere: https://hbfs.wordpress.com/2009/11/10/is-python-slow\n\"\"\"\nmodule EightQueensPuzzle\n\nexport Board, solve!\n\nmutable struct Board\n    cols::Int\n    nodes::Int\n    diag45::Int\n    diag135::Int\n    solutions::Int\n\n    Board() = new(0, 0, 0, 0, 0)\nend\n\n\"Marks occupancy.\"\nfunction mark!(b::Board, k::Int, j::Int)\n    b.cols    \u22bb= (1 << j)\n    b.diag135 \u22bb= (1 << (j+k))\n    b.diag45  \u22bb= (1 << (32+j-k))\nend\n\n\"Tests if a square is menaced.\"\nfunction test(b::Board, k::Int, j::Int)\n    b.cols    & (1 << j)        +\n    b.diag135 & (1 << (j+k))    +\n    b.diag45  & (1 << (32+j-k)) == 0\nend\n\n\"Backtracking solver.\"\nfunction solve!(b::Board, niv::Int, dx::Int)\n    if niv > 0\n        for i in 0:dx-1\n            if test(b, niv, i) == true\n                mark!(b, niv, i)\n                solve!(b, niv-1, dx)\n                mark!(b, niv, i)\n            end\n        end\n    else\n        for i in 0:dx-1\n            if test(b, 0, i) == true\n                b.solutions += 1\n            end\n        end\n    end\n    b.nodes += 1\n    b.solutions\nend\n\nend \n\nusing  .EightQueensPuzzle\n\nfor n = 1:17\n    b = Board()\n    @show n\n    print(\"elapsed:\")\n    solutions = @time solve!(b, n-1, n)\n    @show solutions\n    println()\nend\n", "target": "from itertools import permutations, product\n\nn = 8\ncols = range(n)\ni = 0  \n\nsolutions = [vec for vec in permutations(cols)\n             if n == len(set(vec[i] + i for i in cols))\n                  == len(set(vec[i] - i for i in cols))]\n\ndef setup():\n    size(400, 400)\n    textAlign(CENTER, CENTER)\n    textFont(createFont(\"DejaVu Sans\", 44))\n\ndef draw():\n    background(0)\n    w = width / n\n    for x, y in product(range(n), range(n)):\n        fill(255 * ((x + y) % 2))\n        square(x * w, y * w, w)\n        if solutions[i][y] == x:\n            fill(255 - 255 * ((x + y) % 2))\n            text(u'\u2655', w / 2 + x * w, w / 3 + y * w)\n\ndef keyPressed():  \n    global i\n    i = (i + 1) % len(solutions)\n"}
{"id": 115924, "name": "N-queens problem", "source": "Translate Ruby to Python: \"\"\"\n\n\nPorted to **Julia** from examples in several languages from\nhere: https://hbfs.wordpress.com/2009/11/10/is-python-slow\n\"\"\"\nmodule EightQueensPuzzle\n\nexport Board, solve!\n\nmutable struct Board\n    cols::Int\n    nodes::Int\n    diag45::Int\n    diag135::Int\n    solutions::Int\n\n    Board() = new(0, 0, 0, 0, 0)\nend\n\n\"Marks occupancy.\"\nfunction mark!(b::Board, k::Int, j::Int)\n    b.cols    \u22bb= (1 << j)\n    b.diag135 \u22bb= (1 << (j+k))\n    b.diag45  \u22bb= (1 << (32+j-k))\nend\n\n\"Tests if a square is menaced.\"\nfunction test(b::Board, k::Int, j::Int)\n    b.cols    & (1 << j)        +\n    b.diag135 & (1 << (j+k))    +\n    b.diag45  & (1 << (32+j-k)) == 0\nend\n\n\"Backtracking solver.\"\nfunction solve!(b::Board, niv::Int, dx::Int)\n    if niv > 0\n        for i in 0:dx-1\n            if test(b, niv, i) == true\n                mark!(b, niv, i)\n                solve!(b, niv-1, dx)\n                mark!(b, niv, i)\n            end\n        end\n    else\n        for i in 0:dx-1\n            if test(b, 0, i) == true\n                b.solutions += 1\n            end\n        end\n    end\n    b.nodes += 1\n    b.solutions\nend\n\nend \n\nusing  .EightQueensPuzzle\n\nfor n = 1:17\n    b = Board()\n    @show n\n    print(\"elapsed:\")\n    solutions = @time solve!(b, n-1, n)\n    @show solutions\n    println()\nend\n", "target": "from itertools import permutations, product\n\nn = 8\ncols = range(n)\ni = 0  \n\nsolutions = [vec for vec in permutations(cols)\n             if n == len(set(vec[i] + i for i in cols))\n                  == len(set(vec[i] - i for i in cols))]\n\ndef setup():\n    size(400, 400)\n    textAlign(CENTER, CENTER)\n    textFont(createFont(\"DejaVu Sans\", 44))\n\ndef draw():\n    background(0)\n    w = width / n\n    for x, y in product(range(n), range(n)):\n        fill(255 * ((x + y) % 2))\n        square(x * w, y * w, w)\n        if solutions[i][y] == x:\n            fill(255 - 255 * ((x + y) % 2))\n            text(u'\u2655', w / 2 + x * w, w / 3 + y * w)\n\ndef keyPressed():  \n    global i\n    i = (i + 1) % len(solutions)\n"}
{"id": 116294, "name": "Four bit adder", "source": "Translate Ruby to C#: \ndef four_bit_adder(a, b)\n  a_bits = binary_string_to_bits(a,4)\n  b_bits = binary_string_to_bits(b,4)\n  \n  s0, c0 = full_adder(a_bits[0], b_bits[0],  0)\n  s1, c1 = full_adder(a_bits[1], b_bits[1], c0)\n  s2, c2 = full_adder(a_bits[2], b_bits[2], c1)\n  s3, c3 = full_adder(a_bits[3], b_bits[3], c2)\n  \n  [bits_to_binary_string([s0, s1, s2, s3]), c3.to_s]\nend\n\n\ndef full_adder(a, b, c0)\n  s, c = half_adder(c0, a)\n  s, c1 = half_adder(s, b)\n  [s, _or(c,c1)]\nend\n\n\ndef half_adder(a, b)\n  [xor(a, b), _and(a,b)]\nend\n\ndef xor(a, b)\n  _or(_and(a, _not(b)), _and(_not(a), b))\nend\n\n\ndef _and(a, b)  a & b  end\ndef _or(a, b)   a | b  end\ndef _not(a)    ~a & 1  end\n\ndef int_to_binary_string(n, length)\n  \"%0\nend\n\ndef binary_string_to_bits(s, length)\n  (\"%\nend\n\ndef bits_to_binary_string(bits)\n  bits.map(&:to_s).reverse.join\nend\n\nputs \" A    B      A      B   C    S  sum\" \n0.upto(15) do |a|\n  0.upto(15) do |b|\n    bin_a = int_to_binary_string(a, 4)\n    bin_b = int_to_binary_string(b, 4)\n    sum, carry = four_bit_adder(bin_a, bin_b)\n    puts \"%2d + %2d = %s + %s = %s %s = %2d\" %\n         [a, b, bin_a, bin_b, carry, sum, (carry + sum).to_i(2)]\n  end\nend\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\nnamespace RosettaCodeTasks.FourBitAdder\n{\n\tpublic struct BitAdderOutput\n\t{\n\t\tpublic bool S { get; set; }\n\t\tpublic bool C { get; set; }\n\t\tpublic override string ToString ( )\n\t\t{\n\t\t\treturn \"S\" + ( S ? \"1\" : \"0\" ) + \"C\" + ( C ? \"1\" : \"0\" );\n\t\t}\n\t}\n\tpublic struct Nibble\n\t{\n\t\tpublic bool _1 { get; set; }\n\t\tpublic bool _2 { get; set; }\n\t\tpublic bool _3 { get; set; }\n\t\tpublic bool _4 { get; set; }\n\t\tpublic override string ToString ( )\n\t\t{\n\t\t\treturn ( _4 ? \"1\" : \"0\" )\n\t\t\t\t+ ( _3 ? \"1\" : \"0\" )\n\t\t\t\t+ ( _2 ? \"1\" : \"0\" )\n\t\t\t\t+ ( _1 ? \"1\" : \"0\" );\n\t\t}\n\t}\n\tpublic struct FourBitAdderOutput\n\t{\n\t\tpublic Nibble N { get; set; }\n\t\tpublic bool C { get; set; }\n\t\tpublic override string ToString ( )\n\t\t{\n\t\t\treturn N.ToString ( ) + \"c\" + ( C ? \"1\" : \"0\" );\n\t\t}\n\t}\n\n\tpublic static class LogicGates\n\t{\n\t\t\n\t\tpublic static bool Not ( bool A ) { return !A; }\n\t\tpublic static bool And ( bool A, bool B ) { return A && B; }\n\t\tpublic static bool Or ( bool A, bool B ) { return A || B; }\n\n\t\t\n\t\tpublic static bool Xor ( bool A, bool B ) {\treturn Or ( And ( A, Not ( B ) ), ( And ( Not ( A ), B ) ) ); }\n\t}\n\n\tpublic static class ConstructiveBlocks\n\t{\n\t\tpublic static BitAdderOutput HalfAdder ( bool A, bool B )\n\t\t{\n\t\t\treturn new BitAdderOutput ( ) { S = LogicGates.Xor ( A, B ), C = LogicGates.And ( A, B ) };\n\t\t}\n\n\t\tpublic static BitAdderOutput FullAdder ( bool A, bool B, bool CI )\n\t\t{\n\t\t\tBitAdderOutput HA1 = HalfAdder ( CI, A );\n\t\t\tBitAdderOutput HA2 = HalfAdder ( HA1.S, B );\n\n\t\t\treturn new BitAdderOutput ( ) { S = HA2.S, C = LogicGates.Or ( HA1.C, HA2.C ) };\n\t\t}\n\n\t\tpublic static FourBitAdderOutput FourBitAdder ( Nibble A, Nibble B, bool CI )\n\t\t{\n\n\t\t\tBitAdderOutput FA1 = FullAdder ( A._1, B._1, CI );\n\t\t\tBitAdderOutput FA2 = FullAdder ( A._2, B._2, FA1.C );\n\t\t\tBitAdderOutput FA3 = FullAdder ( A._3, B._3, FA2.C );\n\t\t\tBitAdderOutput FA4 = FullAdder ( A._4, B._4, FA3.C );\n\n\t\t\treturn new FourBitAdderOutput ( ) { N = new Nibble ( ) { _1 = FA1.S, _2 = FA2.S, _3 = FA3.S, _4 = FA4.S }, C = FA4.C };\n\t\t}\n\n\t\tpublic static void Test ( )\n\t\t{\n\t\t\tConsole.WriteLine ( \"Four Bit Adder\" );\n\n\t\t\tfor ( int i = 0; i < 256; i++ )\n\t\t\t{\n\t\t\t\tNibble A = new Nibble ( ) { _1 = false, _2 = false, _3 = false, _4 = false };\n\t\t\t\tNibble B = new Nibble ( ) { _1 = false, _2 = false, _3 = false, _4 = false };\n\t\t\t\tif ( (i & 1) == 1)\n\t\t\t\t{\n\t\t\t\t\tA._1 = true;\n\t\t\t\t}\n\t\t\t\tif ( ( i & 2 ) == 2 )\n\t\t\t\t{\n\t\t\t\t\tA._2 = true;\n\t\t\t\t}\n\t\t\t\tif ( ( i & 4 ) == 4 )\n\t\t\t\t{\n\t\t\t\t\tA._3 = true;\n\t\t\t\t}\n\t\t\t\tif ( ( i & 8 ) == 8 )\n\t\t\t\t{\n\t\t\t\t\tA._4 = true;\n\t\t\t\t}\n\t\t\t\tif ( ( i & 16 ) == 16 )\n\t\t\t\t{\n\t\t\t\t\tB._1 = true;\n\t\t\t\t}\n\t\t\t\tif ( ( i & 32 ) == 32)\n\t\t\t\t{\n\t\t\t\t\tB._2 = true;\n\t\t\t\t}\n\t\t\t\tif ( ( i & 64 ) == 64 )\n\t\t\t\t{\n\t\t\t\t\tB._3 = true;\n\t\t\t\t}\n\t\t\t\tif ( ( i & 128 ) == 128 )\n\t\t\t\t{\n\t\t\t\t\tB._4 = true;\n\t\t\t\t}\n\n\t\t\t\tConsole.WriteLine ( \"{0} + {1} = {2}\", A.ToString ( ), B.ToString ( ), FourBitAdder( A, B, false ).ToString ( ) );\n\n\t\t\t}\n\n\t\t\tConsole.WriteLine ( );\n\t\t}\n\n\t}\n}\n"}
{"id": 116295, "name": "Four bit adder", "source": "Translate Ruby to C#: \ndef four_bit_adder(a, b)\n  a_bits = binary_string_to_bits(a,4)\n  b_bits = binary_string_to_bits(b,4)\n  \n  s0, c0 = full_adder(a_bits[0], b_bits[0],  0)\n  s1, c1 = full_adder(a_bits[1], b_bits[1], c0)\n  s2, c2 = full_adder(a_bits[2], b_bits[2], c1)\n  s3, c3 = full_adder(a_bits[3], b_bits[3], c2)\n  \n  [bits_to_binary_string([s0, s1, s2, s3]), c3.to_s]\nend\n\n\ndef full_adder(a, b, c0)\n  s, c = half_adder(c0, a)\n  s, c1 = half_adder(s, b)\n  [s, _or(c,c1)]\nend\n\n\ndef half_adder(a, b)\n  [xor(a, b), _and(a,b)]\nend\n\ndef xor(a, b)\n  _or(_and(a, _not(b)), _and(_not(a), b))\nend\n\n\ndef _and(a, b)  a & b  end\ndef _or(a, b)   a | b  end\ndef _not(a)    ~a & 1  end\n\ndef int_to_binary_string(n, length)\n  \"%0\nend\n\ndef binary_string_to_bits(s, length)\n  (\"%\nend\n\ndef bits_to_binary_string(bits)\n  bits.map(&:to_s).reverse.join\nend\n\nputs \" A    B      A      B   C    S  sum\" \n0.upto(15) do |a|\n  0.upto(15) do |b|\n    bin_a = int_to_binary_string(a, 4)\n    bin_b = int_to_binary_string(b, 4)\n    sum, carry = four_bit_adder(bin_a, bin_b)\n    puts \"%2d + %2d = %s + %s = %s %s = %2d\" %\n         [a, b, bin_a, bin_b, carry, sum, (carry + sum).to_i(2)]\n  end\nend\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\nnamespace RosettaCodeTasks.FourBitAdder\n{\n\tpublic struct BitAdderOutput\n\t{\n\t\tpublic bool S { get; set; }\n\t\tpublic bool C { get; set; }\n\t\tpublic override string ToString ( )\n\t\t{\n\t\t\treturn \"S\" + ( S ? \"1\" : \"0\" ) + \"C\" + ( C ? \"1\" : \"0\" );\n\t\t}\n\t}\n\tpublic struct Nibble\n\t{\n\t\tpublic bool _1 { get; set; }\n\t\tpublic bool _2 { get; set; }\n\t\tpublic bool _3 { get; set; }\n\t\tpublic bool _4 { get; set; }\n\t\tpublic override string ToString ( )\n\t\t{\n\t\t\treturn ( _4 ? \"1\" : \"0\" )\n\t\t\t\t+ ( _3 ? \"1\" : \"0\" )\n\t\t\t\t+ ( _2 ? \"1\" : \"0\" )\n\t\t\t\t+ ( _1 ? \"1\" : \"0\" );\n\t\t}\n\t}\n\tpublic struct FourBitAdderOutput\n\t{\n\t\tpublic Nibble N { get; set; }\n\t\tpublic bool C { get; set; }\n\t\tpublic override string ToString ( )\n\t\t{\n\t\t\treturn N.ToString ( ) + \"c\" + ( C ? \"1\" : \"0\" );\n\t\t}\n\t}\n\n\tpublic static class LogicGates\n\t{\n\t\t\n\t\tpublic static bool Not ( bool A ) { return !A; }\n\t\tpublic static bool And ( bool A, bool B ) { return A && B; }\n\t\tpublic static bool Or ( bool A, bool B ) { return A || B; }\n\n\t\t\n\t\tpublic static bool Xor ( bool A, bool B ) {\treturn Or ( And ( A, Not ( B ) ), ( And ( Not ( A ), B ) ) ); }\n\t}\n\n\tpublic static class ConstructiveBlocks\n\t{\n\t\tpublic static BitAdderOutput HalfAdder ( bool A, bool B )\n\t\t{\n\t\t\treturn new BitAdderOutput ( ) { S = LogicGates.Xor ( A, B ), C = LogicGates.And ( A, B ) };\n\t\t}\n\n\t\tpublic static BitAdderOutput FullAdder ( bool A, bool B, bool CI )\n\t\t{\n\t\t\tBitAdderOutput HA1 = HalfAdder ( CI, A );\n\t\t\tBitAdderOutput HA2 = HalfAdder ( HA1.S, B );\n\n\t\t\treturn new BitAdderOutput ( ) { S = HA2.S, C = LogicGates.Or ( HA1.C, HA2.C ) };\n\t\t}\n\n\t\tpublic static FourBitAdderOutput FourBitAdder ( Nibble A, Nibble B, bool CI )\n\t\t{\n\n\t\t\tBitAdderOutput FA1 = FullAdder ( A._1, B._1, CI );\n\t\t\tBitAdderOutput FA2 = FullAdder ( A._2, B._2, FA1.C );\n\t\t\tBitAdderOutput FA3 = FullAdder ( A._3, B._3, FA2.C );\n\t\t\tBitAdderOutput FA4 = FullAdder ( A._4, B._4, FA3.C );\n\n\t\t\treturn new FourBitAdderOutput ( ) { N = new Nibble ( ) { _1 = FA1.S, _2 = FA2.S, _3 = FA3.S, _4 = FA4.S }, C = FA4.C };\n\t\t}\n\n\t\tpublic static void Test ( )\n\t\t{\n\t\t\tConsole.WriteLine ( \"Four Bit Adder\" );\n\n\t\t\tfor ( int i = 0; i < 256; i++ )\n\t\t\t{\n\t\t\t\tNibble A = new Nibble ( ) { _1 = false, _2 = false, _3 = false, _4 = false };\n\t\t\t\tNibble B = new Nibble ( ) { _1 = false, _2 = false, _3 = false, _4 = false };\n\t\t\t\tif ( (i & 1) == 1)\n\t\t\t\t{\n\t\t\t\t\tA._1 = true;\n\t\t\t\t}\n\t\t\t\tif ( ( i & 2 ) == 2 )\n\t\t\t\t{\n\t\t\t\t\tA._2 = true;\n\t\t\t\t}\n\t\t\t\tif ( ( i & 4 ) == 4 )\n\t\t\t\t{\n\t\t\t\t\tA._3 = true;\n\t\t\t\t}\n\t\t\t\tif ( ( i & 8 ) == 8 )\n\t\t\t\t{\n\t\t\t\t\tA._4 = true;\n\t\t\t\t}\n\t\t\t\tif ( ( i & 16 ) == 16 )\n\t\t\t\t{\n\t\t\t\t\tB._1 = true;\n\t\t\t\t}\n\t\t\t\tif ( ( i & 32 ) == 32)\n\t\t\t\t{\n\t\t\t\t\tB._2 = true;\n\t\t\t\t}\n\t\t\t\tif ( ( i & 64 ) == 64 )\n\t\t\t\t{\n\t\t\t\t\tB._3 = true;\n\t\t\t\t}\n\t\t\t\tif ( ( i & 128 ) == 128 )\n\t\t\t\t{\n\t\t\t\t\tB._4 = true;\n\t\t\t\t}\n\n\t\t\t\tConsole.WriteLine ( \"{0} + {1} = {2}\", A.ToString ( ), B.ToString ( ), FourBitAdder( A, B, false ).ToString ( ) );\n\n\t\t\t}\n\n\t\t\tConsole.WriteLine ( );\n\t\t}\n\n\t}\n}\n"}
{"id": 116296, "name": "Four bit adder", "source": "Translate Ruby to Java: \ndef four_bit_adder(a, b)\n  a_bits = binary_string_to_bits(a,4)\n  b_bits = binary_string_to_bits(b,4)\n  \n  s0, c0 = full_adder(a_bits[0], b_bits[0],  0)\n  s1, c1 = full_adder(a_bits[1], b_bits[1], c0)\n  s2, c2 = full_adder(a_bits[2], b_bits[2], c1)\n  s3, c3 = full_adder(a_bits[3], b_bits[3], c2)\n  \n  [bits_to_binary_string([s0, s1, s2, s3]), c3.to_s]\nend\n\n\ndef full_adder(a, b, c0)\n  s, c = half_adder(c0, a)\n  s, c1 = half_adder(s, b)\n  [s, _or(c,c1)]\nend\n\n\ndef half_adder(a, b)\n  [xor(a, b), _and(a,b)]\nend\n\ndef xor(a, b)\n  _or(_and(a, _not(b)), _and(_not(a), b))\nend\n\n\ndef _and(a, b)  a & b  end\ndef _or(a, b)   a | b  end\ndef _not(a)    ~a & 1  end\n\ndef int_to_binary_string(n, length)\n  \"%0\nend\n\ndef binary_string_to_bits(s, length)\n  (\"%\nend\n\ndef bits_to_binary_string(bits)\n  bits.map(&:to_s).reverse.join\nend\n\nputs \" A    B      A      B   C    S  sum\" \n0.upto(15) do |a|\n  0.upto(15) do |b|\n    bin_a = int_to_binary_string(a, 4)\n    bin_b = int_to_binary_string(b, 4)\n    sum, carry = four_bit_adder(bin_a, bin_b)\n    puts \"%2d + %2d = %s + %s = %s %s = %2d\" %\n         [a, b, bin_a, bin_b, carry, sum, (carry + sum).to_i(2)]\n  end\nend\n", "target": "public class GateLogic\n{\n  \n  public interface OneInputGate\n  {  boolean eval(boolean input);  }\n  \n  public interface TwoInputGate\n  {  boolean eval(boolean input1, boolean input2);  }\n  \n  public interface MultiGate\n  {  boolean[] eval(boolean... inputs);  }\n  \n  \n  public static OneInputGate NOT = new OneInputGate() {\n    public boolean eval(boolean input)\n    {  return !input;  }\n  };\n  \n  \n  public static TwoInputGate AND = new TwoInputGate() {\n    public boolean eval(boolean input1, boolean input2)\n    {  return input1 && input2;  }\n  };\n  \n  \n  public static TwoInputGate OR = new TwoInputGate() {\n    public boolean eval(boolean input1, boolean input2)\n    {  return input1 || input2;  }\n  };\n  \n  \n  public static TwoInputGate XOR = new TwoInputGate() {\n    public boolean eval(boolean input1, boolean input2)\n    {\n      return OR.eval(\n               AND.eval(input1, NOT.eval(input2)),\n               AND.eval(NOT.eval(input1), input2)\n             );\n    }\n  };\n  \n  \n  public static MultiGate HALF_ADDER = new MultiGate() {\n    public boolean[] eval(boolean... inputs)\n    {\n      if (inputs.length != 2)\n        throw new IllegalArgumentException();\n      return new boolean[] {\n        XOR.eval(inputs[0], inputs[1]),  \n        AND.eval(inputs[0], inputs[1])   \n      };\n    }\n  };\n  \n  \n  public static MultiGate FULL_ADDER = new MultiGate() {\n    public boolean[] eval(boolean... inputs)\n    {\n      if (inputs.length != 3)\n        throw new IllegalArgumentException();\n      \n      \n      boolean[] haOutputs1 = HALF_ADDER.eval(inputs[0], inputs[1]);\n      boolean[] haOutputs2 = HALF_ADDER.eval(haOutputs1[0], inputs[2]);\n      return new boolean[] {\n        haOutputs2[0],                         \n        OR.eval(haOutputs1[1], haOutputs2[1])  \n      };\n    }\n  };\n  \n  public static MultiGate buildAdder(final int numBits)\n  {\n    return new MultiGate() {\n      public boolean[] eval(boolean... inputs)\n      {\n        \n        if (inputs.length != (numBits << 1))\n          throw new IllegalArgumentException();\n        boolean[] outputs = new boolean[numBits + 1];\n        boolean[] faInputs = new boolean[3];\n        boolean[] faOutputs = null;\n        for (int i = 0; i < numBits; i++)\n        {\n          faInputs[0] = (faOutputs == null) ? false : faOutputs[1];  \n          faInputs[1] = inputs[i];                                   \n          faInputs[2] = inputs[numBits + i];                         \n          faOutputs = FULL_ADDER.eval(faInputs);\n          outputs[i] = faOutputs[0];                                 \n        }\n        if (faOutputs != null)\n          outputs[numBits] = faOutputs[1];                           \n        return outputs;\n      }\n    };\n  }\n  \n  public static void main(String[] args)\n  {\n    int numBits = Integer.parseInt(args[0]);\n    int firstNum = Integer.parseInt(args[1]);\n    int secondNum = Integer.parseInt(args[2]);\n    int maxNum = 1 << numBits;\n    if ((firstNum < 0) || (firstNum >= maxNum))\n    {\n      System.out.println(\"First number is out of range\");\n      return;\n    }\n    if ((secondNum < 0) || (secondNum >= maxNum))\n    {\n      System.out.println(\"Second number is out of range\");\n      return;\n    }\n    \n    MultiGate multiBitAdder = buildAdder(numBits);\n    \n    boolean[] inputs = new boolean[numBits << 1];\n    String firstNumDisplay = \"\";\n    String secondNumDisplay = \"\";\n    for (int i = 0; i < numBits; i++)\n    {\n      boolean firstBit = ((firstNum >>> i) & 1) == 1;\n      boolean secondBit = ((secondNum >>> i) & 1) == 1;\n      inputs[i] = firstBit;\n      inputs[numBits + i] = secondBit;\n      firstNumDisplay = (firstBit ? \"1\" : \"0\") + firstNumDisplay;\n      secondNumDisplay = (secondBit ? \"1\" : \"0\") + secondNumDisplay;\n    }\n    \n    boolean[] outputs = multiBitAdder.eval(inputs);\n    int outputNum = 0;\n    String outputNumDisplay = \"\";\n    String outputCarryDisplay = null;\n    for (int i = numBits; i >= 0; i--)\n    {\n      outputNum = (outputNum << 1) | (outputs[i] ? 1 : 0);\n      if (i == numBits)\n        outputCarryDisplay = outputs[i] ? \"1\" : \"0\";\n      else\n        outputNumDisplay += (outputs[i] ? \"1\" : \"0\");\n    }\n    System.out.println(\"numBits=\" + numBits);\n    System.out.println(\"A=\" + firstNumDisplay + \" (\" + firstNum + \"), B=\" + secondNumDisplay + \" (\" + secondNum + \"), S=\" + outputCarryDisplay + \" \" + outputNumDisplay + \" (\" + outputNum + \")\");\n    return;\n  }\n  \n}\n"}
{"id": 116297, "name": "Four bit adder", "source": "Translate Ruby to Java: \ndef four_bit_adder(a, b)\n  a_bits = binary_string_to_bits(a,4)\n  b_bits = binary_string_to_bits(b,4)\n  \n  s0, c0 = full_adder(a_bits[0], b_bits[0],  0)\n  s1, c1 = full_adder(a_bits[1], b_bits[1], c0)\n  s2, c2 = full_adder(a_bits[2], b_bits[2], c1)\n  s3, c3 = full_adder(a_bits[3], b_bits[3], c2)\n  \n  [bits_to_binary_string([s0, s1, s2, s3]), c3.to_s]\nend\n\n\ndef full_adder(a, b, c0)\n  s, c = half_adder(c0, a)\n  s, c1 = half_adder(s, b)\n  [s, _or(c,c1)]\nend\n\n\ndef half_adder(a, b)\n  [xor(a, b), _and(a,b)]\nend\n\ndef xor(a, b)\n  _or(_and(a, _not(b)), _and(_not(a), b))\nend\n\n\ndef _and(a, b)  a & b  end\ndef _or(a, b)   a | b  end\ndef _not(a)    ~a & 1  end\n\ndef int_to_binary_string(n, length)\n  \"%0\nend\n\ndef binary_string_to_bits(s, length)\n  (\"%\nend\n\ndef bits_to_binary_string(bits)\n  bits.map(&:to_s).reverse.join\nend\n\nputs \" A    B      A      B   C    S  sum\" \n0.upto(15) do |a|\n  0.upto(15) do |b|\n    bin_a = int_to_binary_string(a, 4)\n    bin_b = int_to_binary_string(b, 4)\n    sum, carry = four_bit_adder(bin_a, bin_b)\n    puts \"%2d + %2d = %s + %s = %s %s = %2d\" %\n         [a, b, bin_a, bin_b, carry, sum, (carry + sum).to_i(2)]\n  end\nend\n", "target": "public class GateLogic\n{\n  \n  public interface OneInputGate\n  {  boolean eval(boolean input);  }\n  \n  public interface TwoInputGate\n  {  boolean eval(boolean input1, boolean input2);  }\n  \n  public interface MultiGate\n  {  boolean[] eval(boolean... inputs);  }\n  \n  \n  public static OneInputGate NOT = new OneInputGate() {\n    public boolean eval(boolean input)\n    {  return !input;  }\n  };\n  \n  \n  public static TwoInputGate AND = new TwoInputGate() {\n    public boolean eval(boolean input1, boolean input2)\n    {  return input1 && input2;  }\n  };\n  \n  \n  public static TwoInputGate OR = new TwoInputGate() {\n    public boolean eval(boolean input1, boolean input2)\n    {  return input1 || input2;  }\n  };\n  \n  \n  public static TwoInputGate XOR = new TwoInputGate() {\n    public boolean eval(boolean input1, boolean input2)\n    {\n      return OR.eval(\n               AND.eval(input1, NOT.eval(input2)),\n               AND.eval(NOT.eval(input1), input2)\n             );\n    }\n  };\n  \n  \n  public static MultiGate HALF_ADDER = new MultiGate() {\n    public boolean[] eval(boolean... inputs)\n    {\n      if (inputs.length != 2)\n        throw new IllegalArgumentException();\n      return new boolean[] {\n        XOR.eval(inputs[0], inputs[1]),  \n        AND.eval(inputs[0], inputs[1])   \n      };\n    }\n  };\n  \n  \n  public static MultiGate FULL_ADDER = new MultiGate() {\n    public boolean[] eval(boolean... inputs)\n    {\n      if (inputs.length != 3)\n        throw new IllegalArgumentException();\n      \n      \n      boolean[] haOutputs1 = HALF_ADDER.eval(inputs[0], inputs[1]);\n      boolean[] haOutputs2 = HALF_ADDER.eval(haOutputs1[0], inputs[2]);\n      return new boolean[] {\n        haOutputs2[0],                         \n        OR.eval(haOutputs1[1], haOutputs2[1])  \n      };\n    }\n  };\n  \n  public static MultiGate buildAdder(final int numBits)\n  {\n    return new MultiGate() {\n      public boolean[] eval(boolean... inputs)\n      {\n        \n        if (inputs.length != (numBits << 1))\n          throw new IllegalArgumentException();\n        boolean[] outputs = new boolean[numBits + 1];\n        boolean[] faInputs = new boolean[3];\n        boolean[] faOutputs = null;\n        for (int i = 0; i < numBits; i++)\n        {\n          faInputs[0] = (faOutputs == null) ? false : faOutputs[1];  \n          faInputs[1] = inputs[i];                                   \n          faInputs[2] = inputs[numBits + i];                         \n          faOutputs = FULL_ADDER.eval(faInputs);\n          outputs[i] = faOutputs[0];                                 \n        }\n        if (faOutputs != null)\n          outputs[numBits] = faOutputs[1];                           \n        return outputs;\n      }\n    };\n  }\n  \n  public static void main(String[] args)\n  {\n    int numBits = Integer.parseInt(args[0]);\n    int firstNum = Integer.parseInt(args[1]);\n    int secondNum = Integer.parseInt(args[2]);\n    int maxNum = 1 << numBits;\n    if ((firstNum < 0) || (firstNum >= maxNum))\n    {\n      System.out.println(\"First number is out of range\");\n      return;\n    }\n    if ((secondNum < 0) || (secondNum >= maxNum))\n    {\n      System.out.println(\"Second number is out of range\");\n      return;\n    }\n    \n    MultiGate multiBitAdder = buildAdder(numBits);\n    \n    boolean[] inputs = new boolean[numBits << 1];\n    String firstNumDisplay = \"\";\n    String secondNumDisplay = \"\";\n    for (int i = 0; i < numBits; i++)\n    {\n      boolean firstBit = ((firstNum >>> i) & 1) == 1;\n      boolean secondBit = ((secondNum >>> i) & 1) == 1;\n      inputs[i] = firstBit;\n      inputs[numBits + i] = secondBit;\n      firstNumDisplay = (firstBit ? \"1\" : \"0\") + firstNumDisplay;\n      secondNumDisplay = (secondBit ? \"1\" : \"0\") + secondNumDisplay;\n    }\n    \n    boolean[] outputs = multiBitAdder.eval(inputs);\n    int outputNum = 0;\n    String outputNumDisplay = \"\";\n    String outputCarryDisplay = null;\n    for (int i = numBits; i >= 0; i--)\n    {\n      outputNum = (outputNum << 1) | (outputs[i] ? 1 : 0);\n      if (i == numBits)\n        outputCarryDisplay = outputs[i] ? \"1\" : \"0\";\n      else\n        outputNumDisplay += (outputs[i] ? \"1\" : \"0\");\n    }\n    System.out.println(\"numBits=\" + numBits);\n    System.out.println(\"A=\" + firstNumDisplay + \" (\" + firstNum + \"), B=\" + secondNumDisplay + \" (\" + secondNum + \"), S=\" + outputCarryDisplay + \" \" + outputNumDisplay + \" (\" + outputNum + \")\");\n    return;\n  }\n  \n}\n"}
{"id": 116298, "name": "Four bit adder", "source": "Translate Ruby to Python: \ndef four_bit_adder(a, b)\n  a_bits = binary_string_to_bits(a,4)\n  b_bits = binary_string_to_bits(b,4)\n  \n  s0, c0 = full_adder(a_bits[0], b_bits[0],  0)\n  s1, c1 = full_adder(a_bits[1], b_bits[1], c0)\n  s2, c2 = full_adder(a_bits[2], b_bits[2], c1)\n  s3, c3 = full_adder(a_bits[3], b_bits[3], c2)\n  \n  [bits_to_binary_string([s0, s1, s2, s3]), c3.to_s]\nend\n\n\ndef full_adder(a, b, c0)\n  s, c = half_adder(c0, a)\n  s, c1 = half_adder(s, b)\n  [s, _or(c,c1)]\nend\n\n\ndef half_adder(a, b)\n  [xor(a, b), _and(a,b)]\nend\n\ndef xor(a, b)\n  _or(_and(a, _not(b)), _and(_not(a), b))\nend\n\n\ndef _and(a, b)  a & b  end\ndef _or(a, b)   a | b  end\ndef _not(a)    ~a & 1  end\n\ndef int_to_binary_string(n, length)\n  \"%0\nend\n\ndef binary_string_to_bits(s, length)\n  (\"%\nend\n\ndef bits_to_binary_string(bits)\n  bits.map(&:to_s).reverse.join\nend\n\nputs \" A    B      A      B   C    S  sum\" \n0.upto(15) do |a|\n  0.upto(15) do |b|\n    bin_a = int_to_binary_string(a, 4)\n    bin_b = int_to_binary_string(b, 4)\n    sum, carry = four_bit_adder(bin_a, bin_b)\n    puts \"%2d + %2d = %s + %s = %s %s = %2d\" %\n         [a, b, bin_a, bin_b, carry, sum, (carry + sum).to_i(2)]\n  end\nend\n", "target": "\n\nfrom myhdl import *\n\n\n\n@block\ndef NOTgate( a,  q ):   \n   \n   @always_comb   \n   def NOTgateLogic():\n      q.next = not a\n\n   return NOTgateLogic   \n\n\n@block\ndef ANDgate( a, b,  q ):\n   \n   @always_comb \n   def ANDgateLogic():\n      q.next = a and b\n\n   return ANDgateLogic\n\n\n@block\ndef ORgate( a, b,  q ):\n      \n   @always_comb  \n   def ORgateLogic():\n      q.next = a or b\n\n   return ORgateLogic\n\n\n\n\n@block\ndef XORgate( a, b,  q ):\n      \n   \n   nota, notb, annotb, bnnota = [Signal(bool(0)) for i in range(4)]\n   \n   inv0 = NOTgate( a,  nota )\n   inv1 = NOTgate( b,  notb )\n   and2a = ANDgate( a, notb,  annotb )\n   and2b = ANDgate( b, nota,  bnnota )\n   or2a = ORgate( annotb, bnnota,  q )\n\n   return inv0, inv1, and2a, and2b, or2a\n\n\n@block\ndef HalfAdder( in_a, in_b,  summ, carry ):\n    \n   and2a =  ANDgate(in_a, in_b,  carry)\n   xor2a =  XORgate(in_a, in_b,  summ)\n\n   return and2a, xor2a\n\n\n@block\ndef FullAdder( fa_c0, fa_a, fa_b,  fa_s, fa_c1 ):\n   \n\n   ha1_s, ha1_c1, ha2_c1 = [Signal(bool(0)) for i in range(3)]\n\n   HalfAdder01 = HalfAdder( fa_c0, fa_a,  ha1_s, ha1_c1 )\n   HalfAdder02 = HalfAdder( ha1_s, fa_b,  fa_s,  ha2_c1 )\n   or2a = ORgate(ha1_c1, ha2_c1,  fa_c1)\n\n   return HalfAdder01, HalfAdder02, or2a\n\n\n@block\ndef Adder4b( ina, inb,  cOut, sum4):\n    \n\n   cl = [Signal(bool()) for i in range(0,4)]  \n   sl = [Signal(bool()) for i in range(4)]  \n\n   HalfAdder0 = HalfAdder(        ina(0), inb(0),  sl[0], cl[1] )\n   FullAdder1 = FullAdder( cl[1], ina(1), inb(1),  sl[1], cl[2] ) \n   FullAdder2 = FullAdder( cl[2], ina(2), inb(2),  sl[2], cl[3] ) \n   FullAdder3 = FullAdder( cl[3], ina(3), inb(3),  sl[3], cOut ) \n\n   sc = ConcatSignal(*reversed(sl))  \n\n   @always_comb\n   def list2intbv():\n      sum4.next = sc  \n\n   return HalfAdder0, FullAdder1, FullAdder2, FullAdder3, list2intbv\n\n\n\nt_co, t_s, t_a, t_b, dbug =  [Signal(bool(0)) for i in range(5)]\nina4, inb4, sum4 =  [Signal(intbv(0)[4:])  for i in range(3)]\n\nfrom random import randrange \n\n@block\ndef Test_Adder4b():\n   \n   dut = Adder4b( ina4, inb4,  t_co, sum4 )\n\n   @instance\n   def check():\n      print( \"\\n      b   a   |  c1    s   \\n     -------------------\" )\n      for i in range(15):\n         ina4.next, inb4.next = randrange(2**4), randrange(2**4)\n         yield delay(5)\n         print( \"     %2d  %2d   |  %2d   %2d     \" \\\n                % (ina4,inb4, t_co,sum4) )\n         assert t_co * 16 + sum4 == ina4 + inb4  \n      print()\n\n   return dut, check\n\n\n\n\ndef main():\n   simInst = Test_Adder4b()\n   simInst.name = \"mySimInst\"\n   simInst.config_sim(trace=True)  \n   simInst.run_sim(duration=None)\n\n   inst = Adder4b( ina4, inb4,  t_co, sum4 )  \n   inst.convert(hdl='VHDL')  \n   inst.convert(hdl='Verilog')  \n\n    \nif __name__ == '__main__':\n   main()\n"}
{"id": 116299, "name": "Four bit adder", "source": "Translate Ruby to Python: \ndef four_bit_adder(a, b)\n  a_bits = binary_string_to_bits(a,4)\n  b_bits = binary_string_to_bits(b,4)\n  \n  s0, c0 = full_adder(a_bits[0], b_bits[0],  0)\n  s1, c1 = full_adder(a_bits[1], b_bits[1], c0)\n  s2, c2 = full_adder(a_bits[2], b_bits[2], c1)\n  s3, c3 = full_adder(a_bits[3], b_bits[3], c2)\n  \n  [bits_to_binary_string([s0, s1, s2, s3]), c3.to_s]\nend\n\n\ndef full_adder(a, b, c0)\n  s, c = half_adder(c0, a)\n  s, c1 = half_adder(s, b)\n  [s, _or(c,c1)]\nend\n\n\ndef half_adder(a, b)\n  [xor(a, b), _and(a,b)]\nend\n\ndef xor(a, b)\n  _or(_and(a, _not(b)), _and(_not(a), b))\nend\n\n\ndef _and(a, b)  a & b  end\ndef _or(a, b)   a | b  end\ndef _not(a)    ~a & 1  end\n\ndef int_to_binary_string(n, length)\n  \"%0\nend\n\ndef binary_string_to_bits(s, length)\n  (\"%\nend\n\ndef bits_to_binary_string(bits)\n  bits.map(&:to_s).reverse.join\nend\n\nputs \" A    B      A      B   C    S  sum\" \n0.upto(15) do |a|\n  0.upto(15) do |b|\n    bin_a = int_to_binary_string(a, 4)\n    bin_b = int_to_binary_string(b, 4)\n    sum, carry = four_bit_adder(bin_a, bin_b)\n    puts \"%2d + %2d = %s + %s = %s %s = %2d\" %\n         [a, b, bin_a, bin_b, carry, sum, (carry + sum).to_i(2)]\n  end\nend\n", "target": "\n\nfrom myhdl import *\n\n\n\n@block\ndef NOTgate( a,  q ):   \n   \n   @always_comb   \n   def NOTgateLogic():\n      q.next = not a\n\n   return NOTgateLogic   \n\n\n@block\ndef ANDgate( a, b,  q ):\n   \n   @always_comb \n   def ANDgateLogic():\n      q.next = a and b\n\n   return ANDgateLogic\n\n\n@block\ndef ORgate( a, b,  q ):\n      \n   @always_comb  \n   def ORgateLogic():\n      q.next = a or b\n\n   return ORgateLogic\n\n\n\n\n@block\ndef XORgate( a, b,  q ):\n      \n   \n   nota, notb, annotb, bnnota = [Signal(bool(0)) for i in range(4)]\n   \n   inv0 = NOTgate( a,  nota )\n   inv1 = NOTgate( b,  notb )\n   and2a = ANDgate( a, notb,  annotb )\n   and2b = ANDgate( b, nota,  bnnota )\n   or2a = ORgate( annotb, bnnota,  q )\n\n   return inv0, inv1, and2a, and2b, or2a\n\n\n@block\ndef HalfAdder( in_a, in_b,  summ, carry ):\n    \n   and2a =  ANDgate(in_a, in_b,  carry)\n   xor2a =  XORgate(in_a, in_b,  summ)\n\n   return and2a, xor2a\n\n\n@block\ndef FullAdder( fa_c0, fa_a, fa_b,  fa_s, fa_c1 ):\n   \n\n   ha1_s, ha1_c1, ha2_c1 = [Signal(bool(0)) for i in range(3)]\n\n   HalfAdder01 = HalfAdder( fa_c0, fa_a,  ha1_s, ha1_c1 )\n   HalfAdder02 = HalfAdder( ha1_s, fa_b,  fa_s,  ha2_c1 )\n   or2a = ORgate(ha1_c1, ha2_c1,  fa_c1)\n\n   return HalfAdder01, HalfAdder02, or2a\n\n\n@block\ndef Adder4b( ina, inb,  cOut, sum4):\n    \n\n   cl = [Signal(bool()) for i in range(0,4)]  \n   sl = [Signal(bool()) for i in range(4)]  \n\n   HalfAdder0 = HalfAdder(        ina(0), inb(0),  sl[0], cl[1] )\n   FullAdder1 = FullAdder( cl[1], ina(1), inb(1),  sl[1], cl[2] ) \n   FullAdder2 = FullAdder( cl[2], ina(2), inb(2),  sl[2], cl[3] ) \n   FullAdder3 = FullAdder( cl[3], ina(3), inb(3),  sl[3], cOut ) \n\n   sc = ConcatSignal(*reversed(sl))  \n\n   @always_comb\n   def list2intbv():\n      sum4.next = sc  \n\n   return HalfAdder0, FullAdder1, FullAdder2, FullAdder3, list2intbv\n\n\n\nt_co, t_s, t_a, t_b, dbug =  [Signal(bool(0)) for i in range(5)]\nina4, inb4, sum4 =  [Signal(intbv(0)[4:])  for i in range(3)]\n\nfrom random import randrange \n\n@block\ndef Test_Adder4b():\n   \n   dut = Adder4b( ina4, inb4,  t_co, sum4 )\n\n   @instance\n   def check():\n      print( \"\\n      b   a   |  c1    s   \\n     -------------------\" )\n      for i in range(15):\n         ina4.next, inb4.next = randrange(2**4), randrange(2**4)\n         yield delay(5)\n         print( \"     %2d  %2d   |  %2d   %2d     \" \\\n                % (ina4,inb4, t_co,sum4) )\n         assert t_co * 16 + sum4 == ina4 + inb4  \n      print()\n\n   return dut, check\n\n\n\n\ndef main():\n   simInst = Test_Adder4b()\n   simInst.name = \"mySimInst\"\n   simInst.config_sim(trace=True)  \n   simInst.run_sim(duration=None)\n\n   inst = Adder4b( ina4, inb4,  t_co, sum4 )  \n   inst.convert(hdl='VHDL')  \n   inst.convert(hdl='Verilog')  \n\n    \nif __name__ == '__main__':\n   main()\n"}
{"id": 116649, "name": "Longest common subsequence", "source": "Translate Ruby to C#: \ndef lcs(xstr, ystr)\n  return \"\" if xstr.empty? || ystr.empty?\n  \n  x, xs, y, ys = xstr[0..0], xstr[1..-1], ystr[0..0], ystr[1..-1]\n  if x == y\n    x + lcs(xs, ys)\n  else\n    [lcs(xstr, ys), lcs(xs, ystr)].max_by {|x| x.size}\n  end\nend\n", "target": "using System;\n\nnamespace LCS\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            string word1 = \"thisisatest\";\n            string word2 = \"testing123testing\";\n            \n            Console.WriteLine(lcsBack(word1, word2));\n            Console.ReadKey();\n        }\n\n        public static string lcsBack(string a, string b)\n        {\n            string aSub = a.Substring(0, (a.Length - 1 < 0) ? 0 : a.Length - 1);\n            string bSub = b.Substring(0, (b.Length - 1 < 0) ? 0 : b.Length - 1);\n            \n            if (a.Length == 0 || b.Length == 0)            \n                return \"\";\n            else if (a[a.Length - 1] == b[b.Length - 1])\n                return lcsBack(aSub, bSub) + a[a.Length - 1];\n            else\n            {\n                string x = lcsBack(a, bSub);\n                string y = lcsBack(aSub, b);\n                return (x.Length > y.Length) ? x : y;\n            }\n        }\n    }\n}\n"}
{"id": 116650, "name": "Longest common subsequence", "source": "Translate Ruby to C#: \ndef lcs(xstr, ystr)\n  return \"\" if xstr.empty? || ystr.empty?\n  \n  x, xs, y, ys = xstr[0..0], xstr[1..-1], ystr[0..0], ystr[1..-1]\n  if x == y\n    x + lcs(xs, ys)\n  else\n    [lcs(xstr, ys), lcs(xs, ystr)].max_by {|x| x.size}\n  end\nend\n", "target": "using System;\n\nnamespace LCS\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            string word1 = \"thisisatest\";\n            string word2 = \"testing123testing\";\n            \n            Console.WriteLine(lcsBack(word1, word2));\n            Console.ReadKey();\n        }\n\n        public static string lcsBack(string a, string b)\n        {\n            string aSub = a.Substring(0, (a.Length - 1 < 0) ? 0 : a.Length - 1);\n            string bSub = b.Substring(0, (b.Length - 1 < 0) ? 0 : b.Length - 1);\n            \n            if (a.Length == 0 || b.Length == 0)            \n                return \"\";\n            else if (a[a.Length - 1] == b[b.Length - 1])\n                return lcsBack(aSub, bSub) + a[a.Length - 1];\n            else\n            {\n                string x = lcsBack(a, bSub);\n                string y = lcsBack(aSub, b);\n                return (x.Length > y.Length) ? x : y;\n            }\n        }\n    }\n}\n"}
{"id": 116653, "name": "Longest common subsequence", "source": "Translate Ruby to Java: \ndef lcs(xstr, ystr)\n  return \"\" if xstr.empty? || ystr.empty?\n  \n  x, xs, y, ys = xstr[0..0], xstr[1..-1], ystr[0..0], ystr[1..-1]\n  if x == y\n    x + lcs(xs, ys)\n  else\n    [lcs(xstr, ys), lcs(xs, ystr)].max_by {|x| x.size}\n  end\nend\n", "target": "public static String lcs(String a, String b){\n    int aLen = a.length();\n    int bLen = b.length();\n    if(aLen == 0 || bLen == 0){\n        return \"\";\n    }else if(a.charAt(aLen-1) == b.charAt(bLen-1)){\n        return lcs(a.substring(0,aLen-1),b.substring(0,bLen-1))\n            + a.charAt(aLen-1);\n    }else{\n        String x = lcs(a, b.substring(0,bLen-1));\n        String y = lcs(a.substring(0,aLen-1), b);\n        return (x.length() > y.length()) ? x : y;\n    }\n}\n"}
{"id": 116654, "name": "Longest common subsequence", "source": "Translate Ruby to Java: \ndef lcs(xstr, ystr)\n  return \"\" if xstr.empty? || ystr.empty?\n  \n  x, xs, y, ys = xstr[0..0], xstr[1..-1], ystr[0..0], ystr[1..-1]\n  if x == y\n    x + lcs(xs, ys)\n  else\n    [lcs(xstr, ys), lcs(xs, ystr)].max_by {|x| x.size}\n  end\nend\n", "target": "public static String lcs(String a, String b){\n    int aLen = a.length();\n    int bLen = b.length();\n    if(aLen == 0 || bLen == 0){\n        return \"\";\n    }else if(a.charAt(aLen-1) == b.charAt(bLen-1)){\n        return lcs(a.substring(0,aLen-1),b.substring(0,bLen-1))\n            + a.charAt(aLen-1);\n    }else{\n        String x = lcs(a, b.substring(0,bLen-1));\n        String y = lcs(a.substring(0,aLen-1), b);\n        return (x.length() > y.length()) ? x : y;\n    }\n}\n"}
{"id": 116655, "name": "Longest common subsequence", "source": "Translate Ruby to Python: \ndef lcs(xstr, ystr)\n  return \"\" if xstr.empty? || ystr.empty?\n  \n  x, xs, y, ys = xstr[0..0], xstr[1..-1], ystr[0..0], ystr[1..-1]\n  if x == y\n    x + lcs(xs, ys)\n  else\n    [lcs(xstr, ys), lcs(xs, ystr)].max_by {|x| x.size}\n  end\nend\n", "target": "def lcs(xstr, ystr):\n    \n    if not xstr or not ystr:\n        return \"\"\n    x, xs, y, ys = xstr[0], xstr[1:], ystr[0], ystr[1:]\n    if x == y:\n        return str(lcs(xs, ys)) + x\n    else:\n        return max(lcs(xstr, ys), lcs(xs, ystr), key=len)\n"}
{"id": 116656, "name": "Longest common subsequence", "source": "Translate Ruby to Python: \ndef lcs(xstr, ystr)\n  return \"\" if xstr.empty? || ystr.empty?\n  \n  x, xs, y, ys = xstr[0..0], xstr[1..-1], ystr[0..0], ystr[1..-1]\n  if x == y\n    x + lcs(xs, ys)\n  else\n    [lcs(xstr, ys), lcs(xs, ystr)].max_by {|x| x.size}\n  end\nend\n", "target": "def lcs(xstr, ystr):\n    \n    if not xstr or not ystr:\n        return \"\"\n    x, xs, y, ys = xstr[0], xstr[1:], ystr[0], ystr[1:]\n    if x == y:\n        return str(lcs(xs, ys)) + x\n    else:\n        return max(lcs(xstr, ys), lcs(xs, ystr), key=len)\n"}
{"id": 117114, "name": "ABC problem", "source": "Translate Ruby to C#: words = %w(A BaRK BOoK tREaT COmMOn SqUAD CoNfuSE) << \"\"\n\nwords.each do |word|\n  blocks = \"BO XK DQ CP NA GT RE TG QD FS JW HU VI AN OB ER FS LY PC ZM\"\n  res = word.each_char.all?{|c| blocks.sub!(/\\w?\n  puts \"\nend\n", "target": "using System;\nusing System.IO;\n\nusing System.Text.RegularExpressions;\nusing System.Collections.Generic;\n\nvoid Main()\n{\n   string blocks = \"BO XK DQ CP NA GT RE TG QD FS JW HU VI AN OB ER FS LY PC ZM\";\n   List<string> words = new List<string>() {\n      \"A\", \"BARK\", \"BOOK\", \"TREAT\", \"COMMON\", \"SQUAD\", \"CONFUSE\"\n   };\n\n   foreach(var word in words)\n   {\n      Console.WriteLine(\"{0}: {1}\", word, CheckWord(blocks, word));\n   }\n}\n\nbool CheckWord(string blocks, string word)\n{\n   for(int i = 0; i < word.Length; ++i)\n   {\n      int length = blocks.Length;\n      Regex rgx = new Regex(\"([a-z]\"+word[i]+\"|\"+word[i]+\"[a-z])\", RegexOptions.IgnoreCase);\n      blocks = rgx.Replace(blocks, \"\", 1);\n      if(blocks.Length == length) return false;\n   }\n   return true;\n}\n"}
{"id": 117115, "name": "ABC problem", "source": "Translate Ruby to C#: words = %w(A BaRK BOoK tREaT COmMOn SqUAD CoNfuSE) << \"\"\n\nwords.each do |word|\n  blocks = \"BO XK DQ CP NA GT RE TG QD FS JW HU VI AN OB ER FS LY PC ZM\"\n  res = word.each_char.all?{|c| blocks.sub!(/\\w?\n  puts \"\nend\n", "target": "using System;\nusing System.IO;\n\nusing System.Text.RegularExpressions;\nusing System.Collections.Generic;\n\nvoid Main()\n{\n   string blocks = \"BO XK DQ CP NA GT RE TG QD FS JW HU VI AN OB ER FS LY PC ZM\";\n   List<string> words = new List<string>() {\n      \"A\", \"BARK\", \"BOOK\", \"TREAT\", \"COMMON\", \"SQUAD\", \"CONFUSE\"\n   };\n\n   foreach(var word in words)\n   {\n      Console.WriteLine(\"{0}: {1}\", word, CheckWord(blocks, word));\n   }\n}\n\nbool CheckWord(string blocks, string word)\n{\n   for(int i = 0; i < word.Length; ++i)\n   {\n      int length = blocks.Length;\n      Regex rgx = new Regex(\"([a-z]\"+word[i]+\"|\"+word[i]+\"[a-z])\", RegexOptions.IgnoreCase);\n      blocks = rgx.Replace(blocks, \"\", 1);\n      if(blocks.Length == length) return false;\n   }\n   return true;\n}\n"}
{"id": 117118, "name": "ABC problem", "source": "Translate Ruby to Java: words = %w(A BaRK BOoK tREaT COmMOn SqUAD CoNfuSE) << \"\"\n\nwords.each do |word|\n  blocks = \"BO XK DQ CP NA GT RE TG QD FS JW HU VI AN OB ER FS LY PC ZM\"\n  res = word.each_char.all?{|c| blocks.sub!(/\\w?\n  puts \"\nend\n", "target": "static Boolean canMakeWord(List<String> src_blocks, String word) {\n    if (String.isEmpty(word)) {\n        return true;\n    }\n\n    List<String> blocks = new List<String>();\n    for (String block : src_blocks) {\n        blocks.add(block.toUpperCase());\n    }\n    \n    for (Integer i = 0; i < word.length(); i++) {\n        Integer blockIndex = -1;\n        String c = word.mid(i, 1).toUpperCase();\n        \n        for (Integer j = 0; j < blocks.size(); j++) {\n            if (blocks.get(j).contains(c)) {\n                blockIndex = j;\n                break;\n            }\n        }\n        \n        if (blockIndex == -1) {\n            return false;\n        } else {\n            blocks.remove(blockIndex);\n        }\n    }\n        \n    return true;\n}\n\nList<String> blocks = new List<String>{\n    'BO', 'XK', 'DQ', 'CP', 'NA',\n    'GT', 'RE', 'TG', 'QD', 'FS', \n    'JW', 'HU', 'VI', 'AN', 'OB', \n    'ER', 'FS', 'LY', 'PC', 'ZM'\n};\nSystem.debug('\"\": ' + canMakeWord(blocks, ''));\nSystem.debug('\"A\": ' + canMakeWord(blocks, 'A'));\nSystem.debug('\"BARK\": ' + canMakeWord(blocks, 'BARK'));\nSystem.debug('\"book\": ' + canMakeWord(blocks, 'book'));\nSystem.debug('\"treat\": ' + canMakeWord(blocks, 'treat'));\nSystem.debug('\"COMMON\": ' + canMakeWord(blocks, 'COMMON'));\nSystem.debug('\"SQuAd\": ' + canMakeWord(blocks, 'SQuAd'));\nSystem.debug('\"CONFUSE\": ' + canMakeWord(blocks, 'CONFUSE'));\n"}
{"id": 117119, "name": "ABC problem", "source": "Translate Ruby to Java: words = %w(A BaRK BOoK tREaT COmMOn SqUAD CoNfuSE) << \"\"\n\nwords.each do |word|\n  blocks = \"BO XK DQ CP NA GT RE TG QD FS JW HU VI AN OB ER FS LY PC ZM\"\n  res = word.each_char.all?{|c| blocks.sub!(/\\w?\n  puts \"\nend\n", "target": "static Boolean canMakeWord(List<String> src_blocks, String word) {\n    if (String.isEmpty(word)) {\n        return true;\n    }\n\n    List<String> blocks = new List<String>();\n    for (String block : src_blocks) {\n        blocks.add(block.toUpperCase());\n    }\n    \n    for (Integer i = 0; i < word.length(); i++) {\n        Integer blockIndex = -1;\n        String c = word.mid(i, 1).toUpperCase();\n        \n        for (Integer j = 0; j < blocks.size(); j++) {\n            if (blocks.get(j).contains(c)) {\n                blockIndex = j;\n                break;\n            }\n        }\n        \n        if (blockIndex == -1) {\n            return false;\n        } else {\n            blocks.remove(blockIndex);\n        }\n    }\n        \n    return true;\n}\n\nList<String> blocks = new List<String>{\n    'BO', 'XK', 'DQ', 'CP', 'NA',\n    'GT', 'RE', 'TG', 'QD', 'FS', \n    'JW', 'HU', 'VI', 'AN', 'OB', \n    'ER', 'FS', 'LY', 'PC', 'ZM'\n};\nSystem.debug('\"\": ' + canMakeWord(blocks, ''));\nSystem.debug('\"A\": ' + canMakeWord(blocks, 'A'));\nSystem.debug('\"BARK\": ' + canMakeWord(blocks, 'BARK'));\nSystem.debug('\"book\": ' + canMakeWord(blocks, 'book'));\nSystem.debug('\"treat\": ' + canMakeWord(blocks, 'treat'));\nSystem.debug('\"COMMON\": ' + canMakeWord(blocks, 'COMMON'));\nSystem.debug('\"SQuAd\": ' + canMakeWord(blocks, 'SQuAd'));\nSystem.debug('\"CONFUSE\": ' + canMakeWord(blocks, 'CONFUSE'));\n"}
{"id": 117120, "name": "ABC problem", "source": "Translate Ruby to Python: words = %w(A BaRK BOoK tREaT COmMOn SqUAD CoNfuSE) << \"\"\n\nwords.each do |word|\n  blocks = \"BO XK DQ CP NA GT RE TG QD FS JW HU VI AN OB ER FS LY PC ZM\"\n  res = word.each_char.all?{|c| blocks.sub!(/\\w?\n  puts \"\nend\n", "target": "    >>> can_make_word(\"A\")\n    True\n    >>> can_make_word(\"BARK\")\n    True\n    >>> can_make_word(\"BOOK\")\n    False\n    >>> can_make_word(\"TREAT\")\n    True\n    >>> can_make_word(\"COMMON\")\n    False\n    >>> can_make_word(\"SQUAD\")\n    True\n    >>> can_make_word(\"CONFUSE\")\n    True\n"}
{"id": 117121, "name": "ABC problem", "source": "Translate Ruby to Python: words = %w(A BaRK BOoK tREaT COmMOn SqUAD CoNfuSE) << \"\"\n\nwords.each do |word|\n  blocks = \"BO XK DQ CP NA GT RE TG QD FS JW HU VI AN OB ER FS LY PC ZM\"\n  res = word.each_char.all?{|c| blocks.sub!(/\\w?\n  puts \"\nend\n", "target": "    >>> can_make_word(\"A\")\n    True\n    >>> can_make_word(\"BARK\")\n    True\n    >>> can_make_word(\"BOOK\")\n    False\n    >>> can_make_word(\"TREAT\")\n    True\n    >>> can_make_word(\"COMMON\")\n    False\n    >>> can_make_word(\"SQUAD\")\n    True\n    >>> can_make_word(\"CONFUSE\")\n    True\n"}
{"id": 117447, "name": "Diversity prediction theorem", "source": "Translate Ruby to C#: def mean(a) = a.sum(0.0) / a.size\ndef mean_square_diff(a, predictions) = mean(predictions.map { |x| square(x - a)**2 })\n \ndef diversity_theorem(truth, predictions)\n    average = mean(predictions)\n    puts \"truth: \n         \"average-error: \n         \"crowd-error: \n         \"diversity: \nend\n \ndiversity_theorem(49.0, [48.0, 47.0, 51.0])\ndiversity_theorem(49.0, [48.0, 47.0, 51.0, 42.0])\n", "target": "using System;\nusing System.Linq;\nusing System.Collections.Generic;\n\npublic class MainClass {\n    static double Square(double x) => x * x;\n\n    static double AverageSquareDiff(double a, IEnumerable<double> predictions)\n        => predictions.Select(x => Square(x - a)).Average();\n\n    static void DiversityTheorem(double truth, IEnumerable<double> predictions)\n    {\n        var average = predictions.Average();\n        Console.WriteLine($@\"average-error: {AverageSquareDiff(truth, predictions)}\ncrowd-error: {Square(truth - average)}\ndiversity: {AverageSquareDiff(average, predictions)}\");\n    }\n\t\n    public static void Main() {\n\tDiversityTheorem(49, new []{48d,47,51});\n    \tDiversityTheorem(49, new []{48d,47,51,42});\n    }\n}\n"}
{"id": 117448, "name": "Diversity prediction theorem", "source": "Translate Ruby to C#: def mean(a) = a.sum(0.0) / a.size\ndef mean_square_diff(a, predictions) = mean(predictions.map { |x| square(x - a)**2 })\n \ndef diversity_theorem(truth, predictions)\n    average = mean(predictions)\n    puts \"truth: \n         \"average-error: \n         \"crowd-error: \n         \"diversity: \nend\n \ndiversity_theorem(49.0, [48.0, 47.0, 51.0])\ndiversity_theorem(49.0, [48.0, 47.0, 51.0, 42.0])\n", "target": "using System;\nusing System.Linq;\nusing System.Collections.Generic;\n\npublic class MainClass {\n    static double Square(double x) => x * x;\n\n    static double AverageSquareDiff(double a, IEnumerable<double> predictions)\n        => predictions.Select(x => Square(x - a)).Average();\n\n    static void DiversityTheorem(double truth, IEnumerable<double> predictions)\n    {\n        var average = predictions.Average();\n        Console.WriteLine($@\"average-error: {AverageSquareDiff(truth, predictions)}\ncrowd-error: {Square(truth - average)}\ndiversity: {AverageSquareDiff(average, predictions)}\");\n    }\n\t\n    public static void Main() {\n\tDiversityTheorem(49, new []{48d,47,51});\n    \tDiversityTheorem(49, new []{48d,47,51,42});\n    }\n}\n"}
{"id": 117451, "name": "Diversity prediction theorem", "source": "Translate Ruby to Java: def mean(a) = a.sum(0.0) / a.size\ndef mean_square_diff(a, predictions) = mean(predictions.map { |x| square(x - a)**2 })\n \ndef diversity_theorem(truth, predictions)\n    average = mean(predictions)\n    puts \"truth: \n         \"average-error: \n         \"crowd-error: \n         \"diversity: \nend\n \ndiversity_theorem(49.0, [48.0, 47.0, 51.0])\ndiversity_theorem(49.0, [48.0, 47.0, 51.0, 42.0])\n", "target": "import java.util.Arrays;\n\npublic class DiversityPredictionTheorem {\n    private static double square(double d) {\n        return d * d;\n    }\n\n    private static double averageSquareDiff(double d, double[] predictions) {\n        return Arrays.stream(predictions)\n            .map(it -> square(it - d))\n            .average()\n            .orElseThrow();\n    }\n\n    private static String diversityTheorem(double truth, double[] predictions) {\n        double average = Arrays.stream(predictions)\n            .average()\n            .orElseThrow();\n        return String.format(\"average-error\u00a0: %6.3f%n\", averageSquareDiff(truth, predictions))\n            + String.format(\"crowd-error  \u00a0: %6.3f%n\", square(truth - average))\n            + String.format(\"diversity    \u00a0: %6.3f%n\", averageSquareDiff(average, predictions));\n    }\n\n    public static void main(String[] args) {\n        System.out.println(diversityTheorem(49.0, new double[]{48.0, 47.0, 51.0}));\n        System.out.println(diversityTheorem(49.0, new double[]{48.0, 47.0, 51.0, 42.0}));\n    }\n}\n"}
{"id": 117452, "name": "Diversity prediction theorem", "source": "Translate Ruby to Java: def mean(a) = a.sum(0.0) / a.size\ndef mean_square_diff(a, predictions) = mean(predictions.map { |x| square(x - a)**2 })\n \ndef diversity_theorem(truth, predictions)\n    average = mean(predictions)\n    puts \"truth: \n         \"average-error: \n         \"crowd-error: \n         \"diversity: \nend\n \ndiversity_theorem(49.0, [48.0, 47.0, 51.0])\ndiversity_theorem(49.0, [48.0, 47.0, 51.0, 42.0])\n", "target": "import java.util.Arrays;\n\npublic class DiversityPredictionTheorem {\n    private static double square(double d) {\n        return d * d;\n    }\n\n    private static double averageSquareDiff(double d, double[] predictions) {\n        return Arrays.stream(predictions)\n            .map(it -> square(it - d))\n            .average()\n            .orElseThrow();\n    }\n\n    private static String diversityTheorem(double truth, double[] predictions) {\n        double average = Arrays.stream(predictions)\n            .average()\n            .orElseThrow();\n        return String.format(\"average-error\u00a0: %6.3f%n\", averageSquareDiff(truth, predictions))\n            + String.format(\"crowd-error  \u00a0: %6.3f%n\", square(truth - average))\n            + String.format(\"diversity    \u00a0: %6.3f%n\", averageSquareDiff(average, predictions));\n    }\n\n    public static void main(String[] args) {\n        System.out.println(diversityTheorem(49.0, new double[]{48.0, 47.0, 51.0}));\n        System.out.println(diversityTheorem(49.0, new double[]{48.0, 47.0, 51.0, 42.0}));\n    }\n}\n"}
{"id": 117453, "name": "Diversity prediction theorem", "source": "Translate Ruby to Python: def mean(a) = a.sum(0.0) / a.size\ndef mean_square_diff(a, predictions) = mean(predictions.map { |x| square(x - a)**2 })\n \ndef diversity_theorem(truth, predictions)\n    average = mean(predictions)\n    puts \"truth: \n         \"average-error: \n         \"crowd-error: \n         \"diversity: \nend\n \ndiversity_theorem(49.0, [48.0, 47.0, 51.0])\ndiversity_theorem(49.0, [48.0, 47.0, 51.0, 42.0])\n", "target": "\n\nfrom itertools import chain\nfrom functools import reduce\n\n\n\n\ndef diversityValues(x):\n    \n    def go(ps):\n        mp = mean(ps)\n        return {\n            'mean-error': meanErrorSquared(x)(ps),\n            'crowd-error': pow(x - mp, 2),\n            'diversity': meanErrorSquared(mp)(ps)\n        }\n    return go\n\n\n\ndef meanErrorSquared(x):\n    \n    def go(ps):\n        return mean([\n            pow(p - x, 2) for p in ps\n        ])\n    return go\n\n\n\n\ndef main():\n    \n\n    print(unlines(map(\n        showDiversityValues(49),\n        [\n            [48, 47, 51],\n            [48, 47, 51, 42],\n            [50, '?', 50, {}, 50],  \n            []                      \n        ]\n    )))\n    print(unlines(map(\n        showDiversityValues('49'),  \n        [\n            [50, 50, 50],\n            [40, 35, 40],\n        ]\n    )))\n\n\n\n\n\ndef showDiversityValues(x):\n    \n    def go(ps):\n        def showDict(dct):\n            w = 4 + max(map(len, dct.keys()))\n\n            def showKV(a, kv):\n                k, v = kv\n                return a + k.rjust(w, ' ') + (\n                    '\u00a0: ' + showPrecision(3)(v) + '\\n'\n                )\n            return 'Predictions: ' + showList(ps) + ' ->\\n' + (\n                reduce(showKV, dct.items(), '')\n            )\n\n        def showProblem(e):\n            return (\n                unlines(map(indented(1), e)) if (\n                    isinstance(e, list)\n                ) else indented(1)(repr(e))\n            ) + '\\n'\n\n        return 'Observation:  ' + repr(x) + '\\n' + (\n            either(showProblem)(showDict)(\n                bindLR(numLR(x))(\n                    lambda n: bindLR(numsLR(ps))(\n                        compose(Right, diversityValues(n))\n                    )\n                )\n            )\n        )\n    return go\n\n\n\n\n\ndef Left(x):\n    \n    return {'type': 'Either', 'Right': None, 'Left': x}\n\n\n\ndef Right(x):\n    \n    return {'type': 'Either', 'Left': None, 'Right': x}\n\n\n\ndef bindLR(m):\n    \n    def go(mf):\n        return (\n            mf(m.get('Right')) if None is m.get('Left') else m\n        )\n    return go\n\n\n\ndef compose(*fs):\n    \n    def go(f, g):\n        def fg(x):\n            return f(g(x))\n        return fg\n    return reduce(go, fs, identity)\n\n\n\ndef concatMap(f):\n    \n    def go(xs):\n        return chain.from_iterable(map(f, xs))\n    return go\n\n\n\ndef either(fl):\n    \n    return lambda fr: lambda e: fl(e['Left']) if (\n        None is e['Right']\n    ) else fr(e['Right'])\n\n\n\ndef identity(x):\n    \n    return x\n\n\n\ndef indented(n):\n    \n    return lambda s: (4 * ' ' * n) + s\n\n\ndef mean(xs):\n    \n    return sum(xs) / float(len(xs))\n\n\n\ndef numLR(x):\n    \n    return Right(x) if (\n        isinstance(x, (float, int))\n    ) else Left(\n        'Expected number, saw: ' + (\n            str(type(x)) + ' ' + repr(x)\n        )\n    )\n\n\n\ndef numsLR(xs):\n    \n    def go(ns):\n        ls, rs = partitionEithers(map(numLR, ns))\n        return Left(ls) if ls else Right(rs)\n    return bindLR(\n        Right(xs) if (\n            bool(xs) and isinstance(xs, list)\n        ) else Left(\n            'Expected a non-empty list, saw: ' + (\n                str(type(xs)) + ' ' + repr(xs)\n            )\n        )\n    )(go)\n\n\n\ndef partitionEithers(lrs):\n    \n    def go(a, x):\n        ls, rs = a\n        r = x.get('Right')\n        return (ls + [x.get('Left')], rs) if None is r else (\n            ls, rs + [r]\n        )\n    return reduce(go, lrs, ([], []))\n\n\n\ndef showList(xs):\n    \n    return '[' + ','.join(str(x) for x in xs) + ']'\n\n\n\ndef showPrecision(n):\n    \n    def go(x):\n        return str(round(x, n))\n    return go\n\n\n\ndef unlines(xs):\n    \n    return '\\n'.join(xs)\n\n\n\nif __name__ == '__main__':\n    main()\n"}
{"id": 117454, "name": "Diversity prediction theorem", "source": "Translate Ruby to Python: def mean(a) = a.sum(0.0) / a.size\ndef mean_square_diff(a, predictions) = mean(predictions.map { |x| square(x - a)**2 })\n \ndef diversity_theorem(truth, predictions)\n    average = mean(predictions)\n    puts \"truth: \n         \"average-error: \n         \"crowd-error: \n         \"diversity: \nend\n \ndiversity_theorem(49.0, [48.0, 47.0, 51.0])\ndiversity_theorem(49.0, [48.0, 47.0, 51.0, 42.0])\n", "target": "\n\nfrom itertools import chain\nfrom functools import reduce\n\n\n\n\ndef diversityValues(x):\n    \n    def go(ps):\n        mp = mean(ps)\n        return {\n            'mean-error': meanErrorSquared(x)(ps),\n            'crowd-error': pow(x - mp, 2),\n            'diversity': meanErrorSquared(mp)(ps)\n        }\n    return go\n\n\n\ndef meanErrorSquared(x):\n    \n    def go(ps):\n        return mean([\n            pow(p - x, 2) for p in ps\n        ])\n    return go\n\n\n\n\ndef main():\n    \n\n    print(unlines(map(\n        showDiversityValues(49),\n        [\n            [48, 47, 51],\n            [48, 47, 51, 42],\n            [50, '?', 50, {}, 50],  \n            []                      \n        ]\n    )))\n    print(unlines(map(\n        showDiversityValues('49'),  \n        [\n            [50, 50, 50],\n            [40, 35, 40],\n        ]\n    )))\n\n\n\n\n\ndef showDiversityValues(x):\n    \n    def go(ps):\n        def showDict(dct):\n            w = 4 + max(map(len, dct.keys()))\n\n            def showKV(a, kv):\n                k, v = kv\n                return a + k.rjust(w, ' ') + (\n                    '\u00a0: ' + showPrecision(3)(v) + '\\n'\n                )\n            return 'Predictions: ' + showList(ps) + ' ->\\n' + (\n                reduce(showKV, dct.items(), '')\n            )\n\n        def showProblem(e):\n            return (\n                unlines(map(indented(1), e)) if (\n                    isinstance(e, list)\n                ) else indented(1)(repr(e))\n            ) + '\\n'\n\n        return 'Observation:  ' + repr(x) + '\\n' + (\n            either(showProblem)(showDict)(\n                bindLR(numLR(x))(\n                    lambda n: bindLR(numsLR(ps))(\n                        compose(Right, diversityValues(n))\n                    )\n                )\n            )\n        )\n    return go\n\n\n\n\n\ndef Left(x):\n    \n    return {'type': 'Either', 'Right': None, 'Left': x}\n\n\n\ndef Right(x):\n    \n    return {'type': 'Either', 'Left': None, 'Right': x}\n\n\n\ndef bindLR(m):\n    \n    def go(mf):\n        return (\n            mf(m.get('Right')) if None is m.get('Left') else m\n        )\n    return go\n\n\n\ndef compose(*fs):\n    \n    def go(f, g):\n        def fg(x):\n            return f(g(x))\n        return fg\n    return reduce(go, fs, identity)\n\n\n\ndef concatMap(f):\n    \n    def go(xs):\n        return chain.from_iterable(map(f, xs))\n    return go\n\n\n\ndef either(fl):\n    \n    return lambda fr: lambda e: fl(e['Left']) if (\n        None is e['Right']\n    ) else fr(e['Right'])\n\n\n\ndef identity(x):\n    \n    return x\n\n\n\ndef indented(n):\n    \n    return lambda s: (4 * ' ' * n) + s\n\n\ndef mean(xs):\n    \n    return sum(xs) / float(len(xs))\n\n\n\ndef numLR(x):\n    \n    return Right(x) if (\n        isinstance(x, (float, int))\n    ) else Left(\n        'Expected number, saw: ' + (\n            str(type(x)) + ' ' + repr(x)\n        )\n    )\n\n\n\ndef numsLR(xs):\n    \n    def go(ns):\n        ls, rs = partitionEithers(map(numLR, ns))\n        return Left(ls) if ls else Right(rs)\n    return bindLR(\n        Right(xs) if (\n            bool(xs) and isinstance(xs, list)\n        ) else Left(\n            'Expected a non-empty list, saw: ' + (\n                str(type(xs)) + ' ' + repr(xs)\n            )\n        )\n    )(go)\n\n\n\ndef partitionEithers(lrs):\n    \n    def go(a, x):\n        ls, rs = a\n        r = x.get('Right')\n        return (ls + [x.get('Left')], rs) if None is r else (\n            ls, rs + [r]\n        )\n    return reduce(go, lrs, ([], []))\n\n\n\ndef showList(xs):\n    \n    return '[' + ','.join(str(x) for x in xs) + ']'\n\n\n\ndef showPrecision(n):\n    \n    def go(x):\n        return str(round(x, n))\n    return go\n\n\n\ndef unlines(xs):\n    \n    return '\\n'.join(xs)\n\n\n\nif __name__ == '__main__':\n    main()\n"}
{"id": 117851, "name": "Sum digits of an integer", "source": "Translate Ruby to C#: class String\n  def sum_digits(base : Int) : Int32\n  \tself.chars.reduce(0) { |acc, c|\n  \t\tvalue = c.to_i(base)\n  \t\tacc += value\n  \t}\n  end\nend\n\nputs(\"1\".sum_digits 10)\nputs(\"1234\".sum_digits 10)\nputs(\"fe\".sum_digits 16)\nputs(\"f0e\".sum_digits 16)\n", "target": "namespace RosettaCode.SumDigitsOfAnInteger\n{\n    using System;\n    using System.Collections.Generic;\n    using System.Linq;\n\n    internal static class Program\n    {\n        \n        \n        \n        \n        \n        \n        \n        \n        \n        private static IEnumerable<int> Digits(this int number, int @base = 10)\n        {\n            while (number != 0)\n            {\n                int digit;\n                number = Math.DivRem(number, @base, out digit);\n                yield return digit;\n            }\n        }\n\n        \n        \n        \n        \n        \n        \n        private static int SumOfDigits(this int number, int @base = 10)\n        {\n            return number.Digits(@base).Sum();\n        }\n\n        \n        \n        \n        private static void Main()\n        {\n            foreach (var example in\n                new[]\n                {\n                    new {Number = 1, Base = 10},\n                    new {Number = 12345, Base = 10},\n                    new {Number = 123045, Base = 10},\n                    new {Number = 0xfe, Base = 0x10},\n                    new {Number = 0xf0e, Base = 0x10}\n                })\n            {\n                Console.WriteLine(example.Number.SumOfDigits(example.Base));\n            }\n        }\n    }\n}\n"}
{"id": 117852, "name": "Sum digits of an integer", "source": "Translate Ruby to C#: class String\n  def sum_digits(base : Int) : Int32\n  \tself.chars.reduce(0) { |acc, c|\n  \t\tvalue = c.to_i(base)\n  \t\tacc += value\n  \t}\n  end\nend\n\nputs(\"1\".sum_digits 10)\nputs(\"1234\".sum_digits 10)\nputs(\"fe\".sum_digits 16)\nputs(\"f0e\".sum_digits 16)\n", "target": "namespace RosettaCode.SumDigitsOfAnInteger\n{\n    using System;\n    using System.Collections.Generic;\n    using System.Linq;\n\n    internal static class Program\n    {\n        \n        \n        \n        \n        \n        \n        \n        \n        \n        private static IEnumerable<int> Digits(this int number, int @base = 10)\n        {\n            while (number != 0)\n            {\n                int digit;\n                number = Math.DivRem(number, @base, out digit);\n                yield return digit;\n            }\n        }\n\n        \n        \n        \n        \n        \n        \n        private static int SumOfDigits(this int number, int @base = 10)\n        {\n            return number.Digits(@base).Sum();\n        }\n\n        \n        \n        \n        private static void Main()\n        {\n            foreach (var example in\n                new[]\n                {\n                    new {Number = 1, Base = 10},\n                    new {Number = 12345, Base = 10},\n                    new {Number = 123045, Base = 10},\n                    new {Number = 0xfe, Base = 0x10},\n                    new {Number = 0xf0e, Base = 0x10}\n                })\n            {\n                Console.WriteLine(example.Number.SumOfDigits(example.Base));\n            }\n        }\n    }\n}\n"}
{"id": 117855, "name": "Sum digits of an integer", "source": "Translate Ruby to Java: class String\n  def sum_digits(base : Int) : Int32\n  \tself.chars.reduce(0) { |acc, c|\n  \t\tvalue = c.to_i(base)\n  \t\tacc += value\n  \t}\n  end\nend\n\nputs(\"1\".sum_digits 10)\nputs(\"1234\".sum_digits 10)\nputs(\"fe\".sum_digits 16)\nputs(\"f0e\".sum_digits 16)\n", "target": "import java.math.BigInteger;\npublic class SumDigits {\n    public static int sumDigits(long num) {\n\treturn sumDigits(num, 10);\n    }\n    public static int sumDigits(long num, int base) {\n\tString s = Long.toString(num, base);\n\tint result = 0;\n\tfor (int i = 0; i < s.length(); i++)\n\t    result += Character.digit(s.charAt(i), base);\n\treturn result;\n    }\n    public static int sumDigits(BigInteger num) {\n\treturn sumDigits(num, 10);\n    }\n    public static int sumDigits(BigInteger num, int base) {\n\tString s = num.toString(base);\n\tint result = 0;\n\tfor (int i = 0; i < s.length(); i++)\n\t    result += Character.digit(s.charAt(i), base);\n\treturn result;\n    }\n\n    public static void main(String[] args) {\n\tSystem.out.println(sumDigits(1));\n\tSystem.out.println(sumDigits(12345));\n\tSystem.out.println(sumDigits(123045));\n\tSystem.out.println(sumDigits(0xfe, 16));\n\tSystem.out.println(sumDigits(0xf0e, 16));\n\tSystem.out.println(sumDigits(new BigInteger(\"12345678901234567890\")));\n    }\n}\n"}
{"id": 117856, "name": "Sum digits of an integer", "source": "Translate Ruby to Python: class String\n  def sum_digits(base : Int) : Int32\n  \tself.chars.reduce(0) { |acc, c|\n  \t\tvalue = c.to_i(base)\n  \t\tacc += value\n  \t}\n  end\nend\n\nputs(\"1\".sum_digits 10)\nputs(\"1234\".sum_digits 10)\nputs(\"fe\".sum_digits 16)\nputs(\"f0e\".sum_digits 16)\n", "target": "\n\n\n\n\n\u0ba8\u0bbf\u0bb0\u0bb2\u0bcd\u0baa\u0bbe\u0b95\u0bae\u0bcd \u0b8e\u0ba3\u0bcd_\u0b95\u0bc2\u0b9f\u0bcd\u0b9f\u0bb2\u0bcd( \u0b8e\u0ba3\u0bcd )\n  \u0ba4\u0bca\u0b95\u0bc8 = 0\n  @( \u0b8e\u0ba3\u0bcd > 0 ) \u0bb5\u0bb0\u0bc8\n     d = \u0b8e\u0ba3\u0bcd%10;\n     \u0baa\u0ba4\u0bbf\u0baa\u0bcd\u0baa\u0bbf \"digit = \",d\n     \u0b8e\u0ba3\u0bcd = (\u0b8e\u0ba3\u0bcd-d)/10;\n     \u0ba4\u0bca\u0b95\u0bc8  = \u0ba4\u0bca\u0b95\u0bc8  + d\n  \u0bae\u0bc1\u0b9f\u0bbf\n  \u0baa\u0bbf\u0ba9\u0bcd\u0b95\u0bca\u0b9f\u0bc1 \u0ba4\u0bca\u0b95\u0bc8 \n\u0bae\u0bc1\u0b9f\u0bbf\n\n\n\u0baa\u0ba4\u0bbf\u0baa\u0bcd\u0baa\u0bbf \u0b8e\u0ba3\u0bcd_\u0b95\u0bc2\u0b9f\u0bcd\u0b9f\u0bb2\u0bcd( 1289)\n\u0baa\u0ba4\u0bbf\u0baa\u0bcd\u0baa\u0bbf \u0b8e\u0ba3\u0bcd_\u0b95\u0bc2\u0b9f\u0bcd\u0b9f\u0bb2\u0bcd( 123456789)\n"}
{"id": 117857, "name": "Sum digits of an integer", "source": "Translate Ruby to Python: class String\n  def sum_digits(base : Int) : Int32\n  \tself.chars.reduce(0) { |acc, c|\n  \t\tvalue = c.to_i(base)\n  \t\tacc += value\n  \t}\n  end\nend\n\nputs(\"1\".sum_digits 10)\nputs(\"1234\".sum_digits 10)\nputs(\"fe\".sum_digits 16)\nputs(\"f0e\".sum_digits 16)\n", "target": "\n\n\n\n\n\u0ba8\u0bbf\u0bb0\u0bb2\u0bcd\u0baa\u0bbe\u0b95\u0bae\u0bcd \u0b8e\u0ba3\u0bcd_\u0b95\u0bc2\u0b9f\u0bcd\u0b9f\u0bb2\u0bcd( \u0b8e\u0ba3\u0bcd )\n  \u0ba4\u0bca\u0b95\u0bc8 = 0\n  @( \u0b8e\u0ba3\u0bcd > 0 ) \u0bb5\u0bb0\u0bc8\n     d = \u0b8e\u0ba3\u0bcd%10;\n     \u0baa\u0ba4\u0bbf\u0baa\u0bcd\u0baa\u0bbf \"digit = \",d\n     \u0b8e\u0ba3\u0bcd = (\u0b8e\u0ba3\u0bcd-d)/10;\n     \u0ba4\u0bca\u0b95\u0bc8  = \u0ba4\u0bca\u0b95\u0bc8  + d\n  \u0bae\u0bc1\u0b9f\u0bbf\n  \u0baa\u0bbf\u0ba9\u0bcd\u0b95\u0bca\u0b9f\u0bc1 \u0ba4\u0bca\u0b95\u0bc8 \n\u0bae\u0bc1\u0b9f\u0bbf\n\n\n\u0baa\u0ba4\u0bbf\u0baa\u0bcd\u0baa\u0bbf \u0b8e\u0ba3\u0bcd_\u0b95\u0bc2\u0b9f\u0bcd\u0b9f\u0bb2\u0bcd( 1289)\n\u0baa\u0ba4\u0bbf\u0baa\u0bcd\u0baa\u0bbf \u0b8e\u0ba3\u0bcd_\u0b95\u0bc2\u0b9f\u0bcd\u0b9f\u0bb2\u0bcd( 123456789)\n"}
{"id": 118200, "name": "Apply a callback to an array", "source": "Translate Ruby to C#: values = [1, 2, 3]\n\nnew_values = values.map do |number|\n  number * 2\nend\n\nputs new_values  \n", "target": "int[] intArray = { 1, 2, 3, 4, 5 };\n\nint[] squares1 = intArray.Select(x => x * x).ToArray();\n\n\nint[] squares2 = (from x in intArray\n                  select x * x).ToArray();\n\n\nforeach (var i in intArray)\n    Console.WriteLine(i * i);\n"}
{"id": 118202, "name": "Apply a callback to an array", "source": "Translate Ruby to Java: values = [1, 2, 3]\n\nnew_values = values.map do |number|\n  number * 2\nend\n\nputs new_values  \n", "target": "public class ArrayCallback7 {\n\n    interface IntConsumer {\n        void run(int x);\n    }\n\n    interface IntToInt {\n        int run(int x);\n    }\n\n    static void forEach(int[] arr, IntConsumer consumer) {\n        for (int i : arr) {\n            consumer.run(i);\n        }\n    }\n\n    static void update(int[] arr, IntToInt mapper) {\n        for (int i = 0; i < arr.length; i++) {\n            arr[i] = mapper.run(arr[i]);\n        }\n    }\n\n    public static void main(String[] args) {\n        int[] numbers = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};\n\n        forEach(numbers, new IntConsumer() {\n            public void run(int x) {\n                System.out.println(x);\n            }\n        });\n\n        update(numbers, new IntToInt() {\n            @Override\n            public int run(int x) {\n                return x * x;\n            }\n        });\n\n        forEach(numbers, new IntConsumer() {\n            public void run(int x) {\n                System.out.println(x);\n            }\n        });\n    }\n}\n"}
{"id": 118203, "name": "Apply a callback to an array", "source": "Translate Ruby to Python: values = [1, 2, 3]\n\nnew_values = values.map do |number|\n  number * 2\nend\n\nputs new_values  \n", "target": "def square(n):\n    return n * n\n  \nnumbers = [1, 3, 5, 7]\n\nsquares1 = [square(n) for n in numbers]     \n\nsquares2a = map(square, numbers)            \n\nsquares2b = map(lambda x: x*x, numbers)     \n\nsquares3 = [n * n for n in numbers]         \n                                            \n\nisquares1 = (n * n for n in numbers)        \n\nimport itertools\nisquares2 = itertools.imap(square, numbers) \n"}
{"id": 118483, "name": "Sum of squares", "source": "Translate Ruby to C#: def sum_squares(a)\n    a.map{|e| e*e}.sum()\nend\n\nputs sum_squares([1, 2, 3])\n\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\nclass Program\n{\n    static int SumOfSquares(IEnumerable<int> list)\n    {\n        return list.Sum(x => x * x);\n    }\n    static void Main(string[] args)\n    {\n        Console.WriteLine(SumOfSquares(new int[] { 4, 8, 15, 16, 23, 42 })); \n        Console.WriteLine(SumOfSquares(new int[] { 1, 2, 3, 4, 5 })); \n        Console.WriteLine(SumOfSquares(new int[] { })); \n    }\n}\n"}
{"id": 118485, "name": "Sum of squares", "source": "Translate Ruby to Java: def sum_squares(a)\n    a.map{|e| e*e}.sum()\nend\n\nputs sum_squares([1, 2, 3])\n\n", "target": "public class SumSquares\n{\n public static void main(final String[] args)\n {\n  double sum = 0;\n  int[] nums = {1,2,3,4,5};\n  for (int i : nums)\n   sum += i * i;\n  System.out.println(\"The sum of the squares is: \" + sum);\n }\n}\n"}
{"id": 118486, "name": "Sum of squares", "source": "Translate Ruby to Python: def sum_squares(a)\n    a.map{|e| e*e}.sum()\nend\n\nputs sum_squares([1, 2, 3])\n\n", "target": "sum([1, 2, 3, 4]\u00b2)\n"}
{"id": 118928, "name": "Convert seconds to compound duration", "source": "Translate Ruby to C#: MINUTE = 60\nHOUR   = MINUTE*60\nDAY    = HOUR*24\nWEEK   = DAY*7\n\ndef sec_to_str(sec)\n  w, rem = sec.divmod(WEEK)\n  d, rem = rem.divmod(DAY)\n  h, rem = rem.divmod(HOUR)\n  m, s   = rem.divmod(MINUTE)\n  units  = [\"\n  units.reject{|str| str.start_with?(\"0\")}.join(\", \")\nend\n\n[7259, 86400, 6000000].each{|t| puts \"\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\nnamespace ConvertSecondsToCompoundDuration\n{\n  class Program\n  {\n    static void Main( string[] args )\n    {\n      foreach ( string arg in args )\n      {\n        int duration ;\n        bool isValid = int.TryParse( arg , out duration ) ;\n\n        if ( !isValid     ) { Console.Error.WriteLine( \"ERROR: Not an integer: {0}\"           , arg ) ; }\n        if ( duration < 0 ) { Console.Error.WriteLine( \"ERROR: duration must be non-negative\" , arg ) ; }\n        \n        Console.WriteLine();\n        Console.WriteLine( \"{0:#,##0} seconds ==> {1}\" , duration , FormatAsDuration(duration) ) ;\n        \n      }\n    }\n    \n    private static string FormatAsDuration( int duration )\n    {\n      if ( duration < 0 ) throw new ArgumentOutOfRangeException(\"duration\") ;\n      return string.Join( \", \" , GetDurationParts(duration)  ) ;\n    }\n    \n    private static IEnumerable<string> GetDurationParts( int duration )\n    {\n      var parts = new[]\n      {\n        new { Name=\"wk\" , Length = 7*24*60*60*1 , } ,\n        new { Name=\"d\"  , Length =   24*60*60*1 , } ,\n        new { Name=\"h\"  , Length =      60*60*1 , } ,\n        new { Name=\"m\"  , Length =         60*1 , } ,\n        new { Name=\"s\"  , Length =            1 , } ,\n      } ;\n      \n      foreach ( var part in parts )\n      {\n        int n = Math.DivRem( duration , part.Length , out duration ) ;\n        if ( n > 0 ) yield return string.Format( \"{0} {1}\" , n , part.Name ) ;\n      }\n      \n    }\n    \n  }\n  \n}\n"}
{"id": 118929, "name": "Convert seconds to compound duration", "source": "Translate Ruby to C#: MINUTE = 60\nHOUR   = MINUTE*60\nDAY    = HOUR*24\nWEEK   = DAY*7\n\ndef sec_to_str(sec)\n  w, rem = sec.divmod(WEEK)\n  d, rem = rem.divmod(DAY)\n  h, rem = rem.divmod(HOUR)\n  m, s   = rem.divmod(MINUTE)\n  units  = [\"\n  units.reject{|str| str.start_with?(\"0\")}.join(\", \")\nend\n\n[7259, 86400, 6000000].each{|t| puts \"\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\nnamespace ConvertSecondsToCompoundDuration\n{\n  class Program\n  {\n    static void Main( string[] args )\n    {\n      foreach ( string arg in args )\n      {\n        int duration ;\n        bool isValid = int.TryParse( arg , out duration ) ;\n\n        if ( !isValid     ) { Console.Error.WriteLine( \"ERROR: Not an integer: {0}\"           , arg ) ; }\n        if ( duration < 0 ) { Console.Error.WriteLine( \"ERROR: duration must be non-negative\" , arg ) ; }\n        \n        Console.WriteLine();\n        Console.WriteLine( \"{0:#,##0} seconds ==> {1}\" , duration , FormatAsDuration(duration) ) ;\n        \n      }\n    }\n    \n    private static string FormatAsDuration( int duration )\n    {\n      if ( duration < 0 ) throw new ArgumentOutOfRangeException(\"duration\") ;\n      return string.Join( \", \" , GetDurationParts(duration)  ) ;\n    }\n    \n    private static IEnumerable<string> GetDurationParts( int duration )\n    {\n      var parts = new[]\n      {\n        new { Name=\"wk\" , Length = 7*24*60*60*1 , } ,\n        new { Name=\"d\"  , Length =   24*60*60*1 , } ,\n        new { Name=\"h\"  , Length =      60*60*1 , } ,\n        new { Name=\"m\"  , Length =         60*1 , } ,\n        new { Name=\"s\"  , Length =            1 , } ,\n      } ;\n      \n      foreach ( var part in parts )\n      {\n        int n = Math.DivRem( duration , part.Length , out duration ) ;\n        if ( n > 0 ) yield return string.Format( \"{0} {1}\" , n , part.Name ) ;\n      }\n      \n    }\n    \n  }\n  \n}\n"}
{"id": 118932, "name": "Convert seconds to compound duration", "source": "Translate Ruby to Java: MINUTE = 60\nHOUR   = MINUTE*60\nDAY    = HOUR*24\nWEEK   = DAY*7\n\ndef sec_to_str(sec)\n  w, rem = sec.divmod(WEEK)\n  d, rem = rem.divmod(DAY)\n  h, rem = rem.divmod(HOUR)\n  m, s   = rem.divmod(MINUTE)\n  units  = [\"\n  units.reject{|str| str.start_with?(\"0\")}.join(\", \")\nend\n\n[7259, 86400, 6000000].each{|t| puts \"\n", "target": "public class CompoundDuration {\n\n    public static void main(String[] args) {\n        compound(7259);\n        compound(86400);\n        compound(6000_000);\n    }\n\n    private static void compound(long seconds) {\n        StringBuilder sb = new StringBuilder();\n\n        seconds = addUnit(sb, seconds, 604800, \" wk, \");\n        seconds = addUnit(sb, seconds, 86400, \" d, \");\n        seconds = addUnit(sb, seconds, 3600, \" hr, \");\n        seconds = addUnit(sb, seconds, 60, \" min, \");\n        addUnit(sb, seconds, 1, \" sec, \");\n\n        sb.setLength(sb.length() > 2 ? sb.length() - 2 : 0);\n\n        System.out.println(sb);\n    }\n\n    private static long addUnit(StringBuilder sb, long sec, long unit, String s) {\n        long n;\n        if ((n = sec / unit) > 0) {\n            sb.append(n).append(s);\n            sec %= (n * unit);\n        }\n        return sec;\n    }\n}\n"}
{"id": 118933, "name": "Convert seconds to compound duration", "source": "Translate Ruby to Java: MINUTE = 60\nHOUR   = MINUTE*60\nDAY    = HOUR*24\nWEEK   = DAY*7\n\ndef sec_to_str(sec)\n  w, rem = sec.divmod(WEEK)\n  d, rem = rem.divmod(DAY)\n  h, rem = rem.divmod(HOUR)\n  m, s   = rem.divmod(MINUTE)\n  units  = [\"\n  units.reject{|str| str.start_with?(\"0\")}.join(\", \")\nend\n\n[7259, 86400, 6000000].each{|t| puts \"\n", "target": "public class CompoundDuration {\n\n    public static void main(String[] args) {\n        compound(7259);\n        compound(86400);\n        compound(6000_000);\n    }\n\n    private static void compound(long seconds) {\n        StringBuilder sb = new StringBuilder();\n\n        seconds = addUnit(sb, seconds, 604800, \" wk, \");\n        seconds = addUnit(sb, seconds, 86400, \" d, \");\n        seconds = addUnit(sb, seconds, 3600, \" hr, \");\n        seconds = addUnit(sb, seconds, 60, \" min, \");\n        addUnit(sb, seconds, 1, \" sec, \");\n\n        sb.setLength(sb.length() > 2 ? sb.length() - 2 : 0);\n\n        System.out.println(sb);\n    }\n\n    private static long addUnit(StringBuilder sb, long sec, long unit, String s) {\n        long n;\n        if ((n = sec / unit) > 0) {\n            sb.append(n).append(s);\n            sec %= (n * unit);\n        }\n        return sec;\n    }\n}\n"}
{"id": 118934, "name": "Convert seconds to compound duration", "source": "Translate Ruby to Python: MINUTE = 60\nHOUR   = MINUTE*60\nDAY    = HOUR*24\nWEEK   = DAY*7\n\ndef sec_to_str(sec)\n  w, rem = sec.divmod(WEEK)\n  d, rem = rem.divmod(DAY)\n  h, rem = rem.divmod(HOUR)\n  m, s   = rem.divmod(MINUTE)\n  units  = [\"\n  units.reject{|str| str.start_with?(\"0\")}.join(\", \")\nend\n\n[7259, 86400, 6000000].each{|t| puts \"\n", "target": ">>> def duration(seconds):\n\tt= []\n\tfor dm in (60, 60, 24, 7):\n\t\tseconds, m = divmod(seconds, dm)\n\t\tt.append(m)\n\tt.append(seconds)\n\treturn ', '.join('%d %s' % (num, unit)\n\t\t\t for num, unit in zip(t[::-1], 'wk d hr min sec'.split())\n\t\t\t if num)\n\n>>> for seconds in [7259, 86400, 6000000]:\n\tprint(\"%7d sec = %s\" % (seconds, duration(seconds)))\n\n\t\n   7259 sec = 2 hr, 59 sec\n  86400 sec = 1 d\n6000000 sec = 9 wk, 6 d, 10 hr, 40 min\n>>>\n"}
{"id": 118935, "name": "Convert seconds to compound duration", "source": "Translate Ruby to Python: MINUTE = 60\nHOUR   = MINUTE*60\nDAY    = HOUR*24\nWEEK   = DAY*7\n\ndef sec_to_str(sec)\n  w, rem = sec.divmod(WEEK)\n  d, rem = rem.divmod(DAY)\n  h, rem = rem.divmod(HOUR)\n  m, s   = rem.divmod(MINUTE)\n  units  = [\"\n  units.reject{|str| str.start_with?(\"0\")}.join(\", \")\nend\n\n[7259, 86400, 6000000].each{|t| puts \"\n", "target": ">>> def duration(seconds):\n\tt= []\n\tfor dm in (60, 60, 24, 7):\n\t\tseconds, m = divmod(seconds, dm)\n\t\tt.append(m)\n\tt.append(seconds)\n\treturn ', '.join('%d %s' % (num, unit)\n\t\t\t for num, unit in zip(t[::-1], 'wk d hr min sec'.split())\n\t\t\t if num)\n\n>>> for seconds in [7259, 86400, 6000000]:\n\tprint(\"%7d sec = %s\" % (seconds, duration(seconds)))\n\n\t\n   7259 sec = 2 hr, 59 sec\n  86400 sec = 1 d\n6000000 sec = 9 wk, 6 d, 10 hr, 40 min\n>>>\n"}
{"id": 119161, "name": "Execute a system command", "source": "Translate Ruby to C#: string = `ls`\n\nstring = %x{ls}\n\n\nsystem \"ls\"\n\n\nprint `ls`\n\n\nexec \"ls\"\n\n\n\nio = IO.popen('ls')\n\nio.each {|line| puts line}\n", "target": "using System.Diagnostics;\n\nnamespace Execute\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            Process.Start(\"cmd.exe\", \"/c dir\");\n        }\n    }\n}\n"}
{"id": 119163, "name": "Execute a system command", "source": "Translate Ruby to Java: string = `ls`\n\nstring = %x{ls}\n\n\nsystem \"ls\"\n\n\nprint `ls`\n\n\nexec \"ls\"\n\n\n\nio = IO.popen('ls')\n\nio.each {|line| puts line}\n", "target": "import java.util.Scanner;\nimport java.io.*;\n\npublic class Program {\n    public static void main(String[] args) {    \t\n    \ttry {\n    \t\tProcess p = Runtime.getRuntime().exec(\"cmd /C dir\");\n    \t\tScanner sc = new Scanner(p.getInputStream());    \t\t\n    \t\twhile (sc.hasNext()) System.out.println(sc.nextLine());\n    \t}\n    \tcatch (IOException e) {\n    \t\tSystem.out.println(e.getMessage());\n    \t}\n    }\n}\n"}
{"id": 119164, "name": "Execute a system command", "source": "Translate Ruby to Python: string = `ls`\n\nstring = %x{ls}\n\n\nsystem \"ls\"\n\n\nprint `ls`\n\n\nexec \"ls\"\n\n\n\nio = IO.popen('ls')\n\nio.each {|line| puts line}\n", "target": "import os\nexit_code = os.system('ls')       \noutput    = os.popen('ls').read() \n"}
{"id": 119423, "name": "Loops_Do-while", "source": "Translate Ruby to C#: val = 0\nbegin\n   val += 1\n   puts val\nend while val % 6 != 0\n", "target": "int a = 0;\n\ndo\n{\n    a += 1;\n    Console.WriteLine(a);\n} while (a % 6 != 0);\n"}
{"id": 119425, "name": "Loops_Do-while", "source": "Translate Ruby to Java: val = 0\nbegin\n   val += 1\n   puts val\nend while val % 6 != 0\n", "target": "int val = 0;\ndo{\n   val++;\n   System.out.println(val);\n}while(val % 6 != 0);\n"}
{"id": 119426, "name": "Loops_Do-while", "source": "Translate Ruby to Python: val = 0\nbegin\n   val += 1\n   puts val\nend while val % 6 != 0\n", "target": "val = 0\nwhile True:\n   val +=1\n   print val\n   if val % 6 == 0: break\n"}
{"id": 119762, "name": "Cheryl's birthday", "source": "Translate Ruby to C#: dates = [\n    [\"May\", 15],\n    [\"May\", 16],\n    [\"May\", 19],\n    [\"June\", 17],\n    [\"June\", 18],\n    [\"July\", 14],\n    [\"July\", 16],\n    [\"August\", 14],\n    [\"August\", 15],\n    [\"August\", 17],\n]\n\nprint dates.length, \" remaining\\n\"\n\n\nuniqueMonths = dates.group_by { |m,d| d }\n                    .select { |k,v| v.size == 1 }\n                    .map { |k,v| v.flatten }\n                    .map { |m,d| m }\ndates.delete_if { |m,d| uniqueMonths.include? m }\nprint dates.length, \" remaining\\n\"\n\n\ndates = dates   .group_by { |m,d| d }\n                .select { |k,v| v.size == 1 }\n                .map { |k,v| v.flatten }\nprint dates.length, \" remaining\\n\"\n\n\ndates = dates   .group_by { |m,d| m }\n                .select { |k,v| v.size == 1 }\n                .map { |k,v| v }\n                .flatten\nprint dates\n", "target": "public static class CherylsBirthday\n{\n    public static void Main() {\n        var dates = new HashSet<(string month, int day)> {\n            (\"May\", 15),\n            (\"May\", 16),\n            (\"May\", 19),\n            (\"June\", 17),\n            (\"June\", 18),\n            (\"July\", 14),\n            (\"July\", 16),\n            (\"August\", 14),\n            (\"August\", 15),\n            (\"August\", 17)\n        };\n\n        Console.WriteLine(dates.Count + \" remaining.\");\n        \n        var monthsWithUniqueDays = dates.GroupBy(d => d.day).Where(g => g.Count() == 1).Select(g => g.First().month).ToHashSet();\n        dates.RemoveWhere(d => monthsWithUniqueDays.Contains(d.month));\n        Console.WriteLine(dates.Count + \" remaining.\");\n        \n        dates.IntersectWith(dates.GroupBy(d => d.day).Where(g => g.Count() == 1).Select(g => g.First()));\n        Console.WriteLine(dates.Count + \" remaining.\");\n        \n        dates.IntersectWith(dates.GroupBy(d => d.month).Where(g => g.Count() == 1).Select(g => g.First()));\n        Console.WriteLine(dates.Single());\n    }\n    \n}\n"}
{"id": 119763, "name": "Cheryl's birthday", "source": "Translate Ruby to C#: dates = [\n    [\"May\", 15],\n    [\"May\", 16],\n    [\"May\", 19],\n    [\"June\", 17],\n    [\"June\", 18],\n    [\"July\", 14],\n    [\"July\", 16],\n    [\"August\", 14],\n    [\"August\", 15],\n    [\"August\", 17],\n]\n\nprint dates.length, \" remaining\\n\"\n\n\nuniqueMonths = dates.group_by { |m,d| d }\n                    .select { |k,v| v.size == 1 }\n                    .map { |k,v| v.flatten }\n                    .map { |m,d| m }\ndates.delete_if { |m,d| uniqueMonths.include? m }\nprint dates.length, \" remaining\\n\"\n\n\ndates = dates   .group_by { |m,d| d }\n                .select { |k,v| v.size == 1 }\n                .map { |k,v| v.flatten }\nprint dates.length, \" remaining\\n\"\n\n\ndates = dates   .group_by { |m,d| m }\n                .select { |k,v| v.size == 1 }\n                .map { |k,v| v }\n                .flatten\nprint dates\n", "target": "public static class CherylsBirthday\n{\n    public static void Main() {\n        var dates = new HashSet<(string month, int day)> {\n            (\"May\", 15),\n            (\"May\", 16),\n            (\"May\", 19),\n            (\"June\", 17),\n            (\"June\", 18),\n            (\"July\", 14),\n            (\"July\", 16),\n            (\"August\", 14),\n            (\"August\", 15),\n            (\"August\", 17)\n        };\n\n        Console.WriteLine(dates.Count + \" remaining.\");\n        \n        var monthsWithUniqueDays = dates.GroupBy(d => d.day).Where(g => g.Count() == 1).Select(g => g.First().month).ToHashSet();\n        dates.RemoveWhere(d => monthsWithUniqueDays.Contains(d.month));\n        Console.WriteLine(dates.Count + \" remaining.\");\n        \n        dates.IntersectWith(dates.GroupBy(d => d.day).Where(g => g.Count() == 1).Select(g => g.First()));\n        Console.WriteLine(dates.Count + \" remaining.\");\n        \n        dates.IntersectWith(dates.GroupBy(d => d.month).Where(g => g.Count() == 1).Select(g => g.First()));\n        Console.WriteLine(dates.Single());\n    }\n    \n}\n"}
{"id": 119766, "name": "Cheryl's birthday", "source": "Translate Ruby to Java: dates = [\n    [\"May\", 15],\n    [\"May\", 16],\n    [\"May\", 19],\n    [\"June\", 17],\n    [\"June\", 18],\n    [\"July\", 14],\n    [\"July\", 16],\n    [\"August\", 14],\n    [\"August\", 15],\n    [\"August\", 17],\n]\n\nprint dates.length, \" remaining\\n\"\n\n\nuniqueMonths = dates.group_by { |m,d| d }\n                    .select { |k,v| v.size == 1 }\n                    .map { |k,v| v.flatten }\n                    .map { |m,d| m }\ndates.delete_if { |m,d| uniqueMonths.include? m }\nprint dates.length, \" remaining\\n\"\n\n\ndates = dates   .group_by { |m,d| d }\n                .select { |k,v| v.size == 1 }\n                .map { |k,v| v.flatten }\nprint dates.length, \" remaining\\n\"\n\n\ndates = dates   .group_by { |m,d| m }\n                .select { |k,v| v.size == 1 }\n                .map { |k,v| v }\n                .flatten\nprint dates\n", "target": "import java.time.Month;\nimport java.util.Collection;\nimport java.util.List;\nimport java.util.Set;\nimport java.util.stream.Collectors;\n\npublic class Main {\n    private static class Birthday {\n        private Month month;\n        private int day;\n\n        public Birthday(Month month, int day) {\n            this.month = month;\n            this.day = day;\n        }\n\n        public Month getMonth() {\n            return month;\n        }\n\n        public int getDay() {\n            return day;\n        }\n\n        @Override\n        public String toString() {\n            return month + \" \" + day;\n        }\n    }\n\n    public static void main(String[] args) {\n        List<Birthday> choices = List.of(\n            new Birthday(Month.MAY, 15),\n            new Birthday(Month.MAY, 16),\n            new Birthday(Month.MAY, 19),\n            new Birthday(Month.JUNE, 17),\n            new Birthday(Month.JUNE, 18),\n            new Birthday(Month.JULY, 14),\n            new Birthday(Month.JULY, 16),\n            new Birthday(Month.AUGUST, 14),\n            new Birthday(Month.AUGUST, 15),\n            new Birthday(Month.AUGUST, 17)\n        );\n        System.out.printf(\"There are %d candidates remaining.\\n\", choices.size());\n\n        \n        Set<Month> uniqueMonths = choices.stream()\n            .collect(Collectors.groupingBy(Birthday::getDay))\n            .values()\n            .stream()\n            .filter(g -> g.size() == 1)\n            .flatMap(Collection::stream)\n            .map(Birthday::getMonth)\n            .collect(Collectors.toSet());\n        List<Birthday> f1List = choices.stream()\n            .filter(birthday -> !uniqueMonths.contains(birthday.month))\n            .collect(Collectors.toList());\n        System.out.printf(\"There are %d candidates remaining.\\n\", f1List.size());\n\n        \n        List<Birthday> f2List = f1List.stream()\n            .collect(Collectors.groupingBy(Birthday::getDay))\n            .values()\n            .stream()\n            .filter(g -> g.size() == 1)\n            .flatMap(Collection::stream)\n            .collect(Collectors.toList());\n        System.out.printf(\"There are %d candidates remaining.\\n\", f2List.size());\n\n        \n        List<Birthday> f3List = f2List.stream()\n            .collect(Collectors.groupingBy(Birthday::getMonth))\n            .values()\n            .stream()\n            .filter(g -> g.size() == 1)\n            .flatMap(Collection::stream)\n            .collect(Collectors.toList());\n        System.out.printf(\"There are %d candidates remaining.\\n\", f3List.size());\n\n        if (f3List.size() == 1) {\n            System.out.printf(\"Cheryl's birthday is %s\\n\", f3List.get(0));\n        } else {\n            System.out.println(\"No unique choice found\");\n        }\n    }\n}\n"}
{"id": 119767, "name": "Cheryl's birthday", "source": "Translate Ruby to Java: dates = [\n    [\"May\", 15],\n    [\"May\", 16],\n    [\"May\", 19],\n    [\"June\", 17],\n    [\"June\", 18],\n    [\"July\", 14],\n    [\"July\", 16],\n    [\"August\", 14],\n    [\"August\", 15],\n    [\"August\", 17],\n]\n\nprint dates.length, \" remaining\\n\"\n\n\nuniqueMonths = dates.group_by { |m,d| d }\n                    .select { |k,v| v.size == 1 }\n                    .map { |k,v| v.flatten }\n                    .map { |m,d| m }\ndates.delete_if { |m,d| uniqueMonths.include? m }\nprint dates.length, \" remaining\\n\"\n\n\ndates = dates   .group_by { |m,d| d }\n                .select { |k,v| v.size == 1 }\n                .map { |k,v| v.flatten }\nprint dates.length, \" remaining\\n\"\n\n\ndates = dates   .group_by { |m,d| m }\n                .select { |k,v| v.size == 1 }\n                .map { |k,v| v }\n                .flatten\nprint dates\n", "target": "import java.time.Month;\nimport java.util.Collection;\nimport java.util.List;\nimport java.util.Set;\nimport java.util.stream.Collectors;\n\npublic class Main {\n    private static class Birthday {\n        private Month month;\n        private int day;\n\n        public Birthday(Month month, int day) {\n            this.month = month;\n            this.day = day;\n        }\n\n        public Month getMonth() {\n            return month;\n        }\n\n        public int getDay() {\n            return day;\n        }\n\n        @Override\n        public String toString() {\n            return month + \" \" + day;\n        }\n    }\n\n    public static void main(String[] args) {\n        List<Birthday> choices = List.of(\n            new Birthday(Month.MAY, 15),\n            new Birthday(Month.MAY, 16),\n            new Birthday(Month.MAY, 19),\n            new Birthday(Month.JUNE, 17),\n            new Birthday(Month.JUNE, 18),\n            new Birthday(Month.JULY, 14),\n            new Birthday(Month.JULY, 16),\n            new Birthday(Month.AUGUST, 14),\n            new Birthday(Month.AUGUST, 15),\n            new Birthday(Month.AUGUST, 17)\n        );\n        System.out.printf(\"There are %d candidates remaining.\\n\", choices.size());\n\n        \n        Set<Month> uniqueMonths = choices.stream()\n            .collect(Collectors.groupingBy(Birthday::getDay))\n            .values()\n            .stream()\n            .filter(g -> g.size() == 1)\n            .flatMap(Collection::stream)\n            .map(Birthday::getMonth)\n            .collect(Collectors.toSet());\n        List<Birthday> f1List = choices.stream()\n            .filter(birthday -> !uniqueMonths.contains(birthday.month))\n            .collect(Collectors.toList());\n        System.out.printf(\"There are %d candidates remaining.\\n\", f1List.size());\n\n        \n        List<Birthday> f2List = f1List.stream()\n            .collect(Collectors.groupingBy(Birthday::getDay))\n            .values()\n            .stream()\n            .filter(g -> g.size() == 1)\n            .flatMap(Collection::stream)\n            .collect(Collectors.toList());\n        System.out.printf(\"There are %d candidates remaining.\\n\", f2List.size());\n\n        \n        List<Birthday> f3List = f2List.stream()\n            .collect(Collectors.groupingBy(Birthday::getMonth))\n            .values()\n            .stream()\n            .filter(g -> g.size() == 1)\n            .flatMap(Collection::stream)\n            .collect(Collectors.toList());\n        System.out.printf(\"There are %d candidates remaining.\\n\", f3List.size());\n\n        if (f3List.size() == 1) {\n            System.out.printf(\"Cheryl's birthday is %s\\n\", f3List.get(0));\n        } else {\n            System.out.println(\"No unique choice found\");\n        }\n    }\n}\n"}
{"id": 119768, "name": "Cheryl's birthday", "source": "Translate Ruby to Python: dates = [\n    [\"May\", 15],\n    [\"May\", 16],\n    [\"May\", 19],\n    [\"June\", 17],\n    [\"June\", 18],\n    [\"July\", 14],\n    [\"July\", 16],\n    [\"August\", 14],\n    [\"August\", 15],\n    [\"August\", 17],\n]\n\nprint dates.length, \" remaining\\n\"\n\n\nuniqueMonths = dates.group_by { |m,d| d }\n                    .select { |k,v| v.size == 1 }\n                    .map { |k,v| v.flatten }\n                    .map { |m,d| m }\ndates.delete_if { |m,d| uniqueMonths.include? m }\nprint dates.length, \" remaining\\n\"\n\n\ndates = dates   .group_by { |m,d| d }\n                .select { |k,v| v.size == 1 }\n                .map { |k,v| v.flatten }\nprint dates.length, \" remaining\\n\"\n\n\ndates = dates   .group_by { |m,d| m }\n                .select { |k,v| v.size == 1 }\n                .map { |k,v| v }\n                .flatten\nprint dates\n", "target": "\n\nfrom itertools import groupby\nfrom re import split\n\n\n\ndef main():\n    \n\n    month, day = 0, 1\n    print(\n        \n        \n        uniquePairing(month)(\n            \n            \n            uniquePairing(day)(\n                \n                \n                monthsWithUniqueDays(False)([\n                    \n                    tuple(x.split()) for x in\n                    split(\n                        ', ',\n                        'May 15, May 16, May 19, ' +\n                        'June 17, June 18, ' +\n                        'July 14, July 16, ' +\n                        'Aug 14, Aug 15, Aug 17'\n                    )\n                ])\n            )\n        )\n    )\n\n\n\n\n\ndef monthsWithUniqueDays(blnInclude):\n    \n    def go(xs):\n        month, day = 0, 1\n        months = [fst(x) for x in uniquePairing(day)(xs)]\n        return [\n            md for md in xs\n            if blnInclude or not (md[month] in months)\n        ]\n    return go\n\n\n\ndef uniquePairing(i):\n    \n    def go(xs):\n        def inner(md):\n            dct = md[i]\n            uniques = [\n                k for k in dct.keys()\n                if 1 == len(dct[k])\n            ]\n            return [tpl for tpl in xs if tpl[i] in uniques]\n        return inner\n    return ap(bindPairs)(go)\n\n\n\n\n\ndef bindPairs(xs):\n    \n    return lambda f: f(\n        (\n            dictFromPairs(xs),\n            dictFromPairs(\n                [(b, a) for (a, b) in xs]\n            )\n        )\n    )\n\n\n\ndef dictFromPairs(xs):\n    \n    return {\n        k: [snd(x) for x in m] for k, m in groupby(\n            sorted(xs, key=fst), key=fst\n        )\n    }\n\n\n\n\n\ndef ap(f):\n    \n    def go(g):\n        def fxgx(x):\n            return f(x)(\n                g(x)\n            )\n        return fxgx\n    return go\n\n\n\ndef fst(tpl):\n    \n    return tpl[0]\n\n\n\ndef snd(tpl):\n    \n    return tpl[1]\n\n\nif __name__ == '__main__':\n    main()\n"}
{"id": 119769, "name": "Cheryl's birthday", "source": "Translate Ruby to Python: dates = [\n    [\"May\", 15],\n    [\"May\", 16],\n    [\"May\", 19],\n    [\"June\", 17],\n    [\"June\", 18],\n    [\"July\", 14],\n    [\"July\", 16],\n    [\"August\", 14],\n    [\"August\", 15],\n    [\"August\", 17],\n]\n\nprint dates.length, \" remaining\\n\"\n\n\nuniqueMonths = dates.group_by { |m,d| d }\n                    .select { |k,v| v.size == 1 }\n                    .map { |k,v| v.flatten }\n                    .map { |m,d| m }\ndates.delete_if { |m,d| uniqueMonths.include? m }\nprint dates.length, \" remaining\\n\"\n\n\ndates = dates   .group_by { |m,d| d }\n                .select { |k,v| v.size == 1 }\n                .map { |k,v| v.flatten }\nprint dates.length, \" remaining\\n\"\n\n\ndates = dates   .group_by { |m,d| m }\n                .select { |k,v| v.size == 1 }\n                .map { |k,v| v }\n                .flatten\nprint dates\n", "target": "\n\nfrom itertools import groupby\nfrom re import split\n\n\n\ndef main():\n    \n\n    month, day = 0, 1\n    print(\n        \n        \n        uniquePairing(month)(\n            \n            \n            uniquePairing(day)(\n                \n                \n                monthsWithUniqueDays(False)([\n                    \n                    tuple(x.split()) for x in\n                    split(\n                        ', ',\n                        'May 15, May 16, May 19, ' +\n                        'June 17, June 18, ' +\n                        'July 14, July 16, ' +\n                        'Aug 14, Aug 15, Aug 17'\n                    )\n                ])\n            )\n        )\n    )\n\n\n\n\n\ndef monthsWithUniqueDays(blnInclude):\n    \n    def go(xs):\n        month, day = 0, 1\n        months = [fst(x) for x in uniquePairing(day)(xs)]\n        return [\n            md for md in xs\n            if blnInclude or not (md[month] in months)\n        ]\n    return go\n\n\n\ndef uniquePairing(i):\n    \n    def go(xs):\n        def inner(md):\n            dct = md[i]\n            uniques = [\n                k for k in dct.keys()\n                if 1 == len(dct[k])\n            ]\n            return [tpl for tpl in xs if tpl[i] in uniques]\n        return inner\n    return ap(bindPairs)(go)\n\n\n\n\n\ndef bindPairs(xs):\n    \n    return lambda f: f(\n        (\n            dictFromPairs(xs),\n            dictFromPairs(\n                [(b, a) for (a, b) in xs]\n            )\n        )\n    )\n\n\n\ndef dictFromPairs(xs):\n    \n    return {\n        k: [snd(x) for x in m] for k, m in groupby(\n            sorted(xs, key=fst), key=fst\n        )\n    }\n\n\n\n\n\ndef ap(f):\n    \n    def go(g):\n        def fxgx(x):\n            return f(x)(\n                g(x)\n            )\n        return fxgx\n    return go\n\n\n\ndef fst(tpl):\n    \n    return tpl[0]\n\n\n\ndef snd(tpl):\n    \n    return tpl[1]\n\n\nif __name__ == '__main__':\n    main()\n"}
{"id": 119977, "name": "Text processing_2", "source": "Translate Ruby to C#: require 'set'\n\ndef munge2(readings, debug=false)\n   datePat = /^\\d{4}-\\d{2}-\\d{2}/\n   valuPat = /^[-+]?\\d+\\.\\d+/\n   statPat = /^-?\\d+/\n   totalLines = 0\n   dupdate, badform, badlen, badreading = Set[], Set[], Set[], 0\n   datestamps = Set[[]]\n   for line in readings\n      totalLines += 1\n      fields = line.split(/\\t/)\n      date = fields.shift\n      pairs = fields.enum_slice(2).to_a\n \n      lineFormatOk = date =~ datePat &&\n        pairs.all? { |x,y| x =~ valuPat && y =~ statPat }\n      if !lineFormatOk\n         puts 'Bad formatting ' + line if debug\n         badform << date\n      end\n         \n      if pairs.length != 24 ||\n           pairs.any? { |x,y| y.to_i < 1 }\n         puts 'Missing values ' + line if debug\n      end\n      if pairs.length != 24\n         badlen << date\n      end\n      if pairs.any? { |x,y| y.to_i < 1 }\n         badreading += 1\n      end\n \n      if datestamps.include?(date)\n         puts 'Duplicate datestamp ' + line if debug\n         dupdate << date\n      end\n\n      datestamps << date\n   end\n\n   puts 'Duplicate dates:', dupdate.sort.map { |x| '  ' + x }\n   puts 'Bad format:', badform.sort.map { |x| '  ' + x }\n   puts 'Bad number of fields:', badlen.sort.map { |x| '  ' + x }\n   puts 'Records with good readings: %i = %5.2f%%' % [\n      totalLines-badreading, (totalLines-badreading)/totalLines.to_f*100 ]\n   puts\n   puts 'Total records:  %d' % totalLines\nend\n\nopen('readings.txt','r') do |readings|\n   munge2(readings)\nend\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Text.RegularExpressions;\nusing System.IO;\n\nnamespace TextProc2\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            Regex multiWhite = new Regex(@\"\\s+\");\n            Regex dateEx = new Regex(@\"^\\d{4}-\\d{2}-\\d{2}$\");\n            Regex valEx = new Regex(@\"^\\d+\\.{1}\\d{3}$\");\n            Regex flagEx = new Regex(@\"^[1-9]{1}$\");\n            \n            int missformcount = 0, totalcount = 0;\n            Dictionary<int, string> dates = new Dictionary<int, string>();\n\n            using (StreamReader sr = new StreamReader(\"readings.txt\"))\n            {\n                string line = sr.ReadLine();\n                while (line != null)\n                {\n                    line = multiWhite.Replace(line, @\" \");                    \n                    string[] splitLine = line.Split(' ');\n                    if (splitLine.Length != 49)\n                        missformcount++;\n                    if (!dateEx.IsMatch(splitLine[0]))                        \n                        missformcount++;                    \n                    else\n                        dates.Add(totalcount + 1, dateEx.Match(splitLine[0]).ToString());\n                    int err = 0;                    \n                    for (int i = 1; i < splitLine.Length; i++)\n                    {\n                        if (i%2 != 0)\n                        {\n                            if (!valEx.IsMatch(splitLine[i]))                          \n                                err++;\n                        }\n                        else\n                        {\n                            if (!flagEx.IsMatch(splitLine[i]))\n                                err++;                                                        \n                        }                        \n                    }\n                    if (err != 0) missformcount++;\n                    line = sr.ReadLine();\n                    totalcount++;                    \n                }\n            }\n\n            int goodEntries = totalcount - missformcount;\n            Dictionary<string,List<int>> dateReverse = new Dictionary<string,List<int>>();\n\n            foreach (KeyValuePair<int, string> kvp in dates)\n            {\n                if (!dateReverse.ContainsKey(kvp.Value))\n                    dateReverse[kvp.Value] = new List<int>();\n                dateReverse[kvp.Value].Add(kvp.Key);\n            }\n\n            Console.WriteLine(goodEntries + \" valid Records out of \" + totalcount);\n\n            foreach (KeyValuePair<string, List<int>> kvp in dateReverse)\n            {\n                if (kvp.Value.Count > 1)\n                    Console.WriteLine(\"{0} is duplicated at Lines\u00a0: {1}\", kvp.Key, string.Join(\",\", kvp.Value));                    \n            }\n        }\n    }\n}\n"}
{"id": 119979, "name": "Text processing_2", "source": "Translate Ruby to Python: require 'set'\n\ndef munge2(readings, debug=false)\n   datePat = /^\\d{4}-\\d{2}-\\d{2}/\n   valuPat = /^[-+]?\\d+\\.\\d+/\n   statPat = /^-?\\d+/\n   totalLines = 0\n   dupdate, badform, badlen, badreading = Set[], Set[], Set[], 0\n   datestamps = Set[[]]\n   for line in readings\n      totalLines += 1\n      fields = line.split(/\\t/)\n      date = fields.shift\n      pairs = fields.enum_slice(2).to_a\n \n      lineFormatOk = date =~ datePat &&\n        pairs.all? { |x,y| x =~ valuPat && y =~ statPat }\n      if !lineFormatOk\n         puts 'Bad formatting ' + line if debug\n         badform << date\n      end\n         \n      if pairs.length != 24 ||\n           pairs.any? { |x,y| y.to_i < 1 }\n         puts 'Missing values ' + line if debug\n      end\n      if pairs.length != 24\n         badlen << date\n      end\n      if pairs.any? { |x,y| y.to_i < 1 }\n         badreading += 1\n      end\n \n      if datestamps.include?(date)\n         puts 'Duplicate datestamp ' + line if debug\n         dupdate << date\n      end\n\n      datestamps << date\n   end\n\n   puts 'Duplicate dates:', dupdate.sort.map { |x| '  ' + x }\n   puts 'Bad format:', badform.sort.map { |x| '  ' + x }\n   puts 'Bad number of fields:', badlen.sort.map { |x| '  ' + x }\n   puts 'Records with good readings: %i = %5.2f%%' % [\n      totalLines-badreading, (totalLines-badreading)/totalLines.to_f*100 ]\n   puts\n   puts 'Total records:  %d' % totalLines\nend\n\nopen('readings.txt','r') do |readings|\n   munge2(readings)\nend\n", "target": "import re\nimport zipfile\nimport StringIO\n\ndef munge2(readings):\n\n   datePat = re.compile(r'\\d{4}-\\d{2}-\\d{2}')\n   valuPat = re.compile(r'[-+]?\\d+\\.\\d+')\n   statPat = re.compile(r'-?\\d+')\n   allOk, totalLines = 0, 0\n   datestamps = set([])\n   for line in readings:\n      totalLines += 1\n      fields = line.split('\\t')\n      date = fields[0]\n      pairs = [(fields[i],fields[i+1]) for i in range(1,len(fields),2)]\n\n      lineFormatOk = datePat.match(date) and \\\n         all( valuPat.match(p[0]) for p in pairs ) and \\\n         all( statPat.match(p[1]) for p in pairs )\n      if not lineFormatOk:\n         print 'Bad formatting', line\n         continue\n\t\t\n      if len(pairs)!=24 or any( int(p[1]) < 1 for p in pairs ):\n         print 'Missing values', line\n         continue\n\n      if date in datestamps:\n         print 'Duplicate datestamp', line\n         continue\n      datestamps.add(date)\n      allOk += 1\n\n   print 'Lines with all readings: ', allOk\n   print 'Total records: ', totalLines\n\n\n\nreadings = open('readings.txt','r')\nmunge2(readings)\n"}
{"id": 120415, "name": "Floyd's triangle", "source": "Translate Ruby to C#: def floyd(rows)\n  max = (rows * (rows + 1)) / 2\n  widths = ((max - rows + 1)..max).map {|n| n.to_s.length + 1}\n  n = 0\n  rows.times do |r|\n    puts (0..r).map {|i| n += 1; \"%\n  end\nend\n\nfloyd(5)\nfloyd(14)\n", "target": "using System;\nusing System.Text;\n\npublic class FloydsTriangle\n{\n    internal static void Main(string[] args)\n    {\n        int count;\n        if (args.Length >= 1 && int.TryParse(args[0], out count) && count > 0)\n        {\n            Console.WriteLine(MakeTriangle(count));\n        }\n        else\n        {\n            Console.WriteLine(MakeTriangle(5));\n            Console.WriteLine();\n            Console.WriteLine(MakeTriangle(14));\n        }\n    }\n\n    public static string MakeTriangle(int rows)\n    {\n        int maxValue = (rows * (rows + 1)) / 2;\n        int digit = 0;\n        StringBuilder output = new StringBuilder();\n\n        for (int row = 1; row <= rows; row++)\n        {\n            for (int column = 0; column < row; column++)\n            {\n                int colMaxDigit = (maxValue - rows) + column + 1;\n                if (column > 0)\n                {\n                    output.Append(' ');\n                }\n\n                digit++;\n                output.Append(digit.ToString().PadLeft(colMaxDigit.ToString().Length));\n            }\n\n            output.AppendLine();\n        }\n\n        return output.ToString();\n    }\n}\n"}
{"id": 120416, "name": "Floyd's triangle", "source": "Translate Ruby to C#: def floyd(rows)\n  max = (rows * (rows + 1)) / 2\n  widths = ((max - rows + 1)..max).map {|n| n.to_s.length + 1}\n  n = 0\n  rows.times do |r|\n    puts (0..r).map {|i| n += 1; \"%\n  end\nend\n\nfloyd(5)\nfloyd(14)\n", "target": "using System;\nusing System.Text;\n\npublic class FloydsTriangle\n{\n    internal static void Main(string[] args)\n    {\n        int count;\n        if (args.Length >= 1 && int.TryParse(args[0], out count) && count > 0)\n        {\n            Console.WriteLine(MakeTriangle(count));\n        }\n        else\n        {\n            Console.WriteLine(MakeTriangle(5));\n            Console.WriteLine();\n            Console.WriteLine(MakeTriangle(14));\n        }\n    }\n\n    public static string MakeTriangle(int rows)\n    {\n        int maxValue = (rows * (rows + 1)) / 2;\n        int digit = 0;\n        StringBuilder output = new StringBuilder();\n\n        for (int row = 1; row <= rows; row++)\n        {\n            for (int column = 0; column < row; column++)\n            {\n                int colMaxDigit = (maxValue - rows) + column + 1;\n                if (column > 0)\n                {\n                    output.Append(' ');\n                }\n\n                digit++;\n                output.Append(digit.ToString().PadLeft(colMaxDigit.ToString().Length));\n            }\n\n            output.AppendLine();\n        }\n\n        return output.ToString();\n    }\n}\n"}
{"id": 120419, "name": "Floyd's triangle", "source": "Translate Ruby to Java: def floyd(rows)\n  max = (rows * (rows + 1)) / 2\n  widths = ((max - rows + 1)..max).map {|n| n.to_s.length + 1}\n  n = 0\n  rows.times do |r|\n    puts (0..r).map {|i| n += 1; \"%\n  end\nend\n\nfloyd(5)\nfloyd(14)\n", "target": "public class Floyd {\n\tpublic static void main(String[] args){\n\t\tprintTriangle(5);\n\t\tprintTriangle(14);\n\t}\n\t\n\tprivate static void printTriangle(int n){\n\t\tSystem.out.println(n + \" rows:\");\n\t\tfor(int rowNum = 1, printMe = 1, numsPrinted = 0;\n\t\t\t\trowNum <= n; printMe++){\n\t\t\tint cols = (int)Math.ceil(Math.log10(n*(n-1)/2 + numsPrinted + 2));\n\t\t\tSystem.out.printf(\"%\"+cols+\"d \", printMe);\n\t\t\tif(++numsPrinted == rowNum){\n\t\t\t\tSystem.out.println();\n\t\t\t\trowNum++;\n\t\t\t\tnumsPrinted = 0;\n\t\t\t}\n\t\t}\n\t}\n}\n"}
{"id": 120420, "name": "Floyd's triangle", "source": "Translate Ruby to Java: def floyd(rows)\n  max = (rows * (rows + 1)) / 2\n  widths = ((max - rows + 1)..max).map {|n| n.to_s.length + 1}\n  n = 0\n  rows.times do |r|\n    puts (0..r).map {|i| n += 1; \"%\n  end\nend\n\nfloyd(5)\nfloyd(14)\n", "target": "public class Floyd {\n\tpublic static void main(String[] args){\n\t\tprintTriangle(5);\n\t\tprintTriangle(14);\n\t}\n\t\n\tprivate static void printTriangle(int n){\n\t\tSystem.out.println(n + \" rows:\");\n\t\tfor(int rowNum = 1, printMe = 1, numsPrinted = 0;\n\t\t\t\trowNum <= n; printMe++){\n\t\t\tint cols = (int)Math.ceil(Math.log10(n*(n-1)/2 + numsPrinted + 2));\n\t\t\tSystem.out.printf(\"%\"+cols+\"d \", printMe);\n\t\t\tif(++numsPrinted == rowNum){\n\t\t\t\tSystem.out.println();\n\t\t\t\trowNum++;\n\t\t\t\tnumsPrinted = 0;\n\t\t\t}\n\t\t}\n\t}\n}\n"}
{"id": 120421, "name": "Floyd's triangle", "source": "Translate Ruby to Python: def floyd(rows)\n  max = (rows * (rows + 1)) / 2\n  widths = ((max - rows + 1)..max).map {|n| n.to_s.length + 1}\n  n = 0\n  rows.times do |r|\n    puts (0..r).map {|i| n += 1; \"%\n  end\nend\n\nfloyd(5)\nfloyd(14)\n", "target": ">>> def floyd(rowcount=5):\n\trows = [[1]]\n\twhile len(rows) < rowcount:\n\t\tn = rows[-1][-1] + 1\n\t\trows.append(list(range(n, n + len(rows[-1]) + 1)))\n\treturn rows\n\n>>> floyd()\n[[1], [2, 3], [4, 5, 6], [7, 8, 9, 10], [11, 12, 13, 14, 15]]\n>>> def pfloyd(rows=[[1], [2, 3], [4, 5, 6], [7, 8, 9, 10]]):\n\tcolspace = [len(str(n)) for n in rows[-1]]\n\tfor row in rows:\n\t\tprint( ' '.join('%*i' % space_n for space_n in zip(colspace, row)))\n\n\t\t\n>>> pfloyd()\n1\n2 3\n4 5 6\n7 8 9 10\n>>> pfloyd(floyd(5))\n 1\n 2  3\n 4  5  6\n 7  8  9 10\n11 12 13 14 15\n>>> pfloyd(floyd(14))\n 1\n 2  3\n 4  5  6\n 7  8  9 10\n11 12 13 14 15\n16 17 18 19 20 21\n22 23 24 25 26 27 28\n29 30 31 32 33 34 35 36\n37 38 39 40 41 42 43 44  45\n46 47 48 49 50 51 52 53  54  55\n56 57 58 59 60 61 62 63  64  65  66\n67 68 69 70 71 72 73 74  75  76  77  78\n79 80 81 82 83 84 85 86  87  88  89  90  91\n92 93 94 95 96 97 98 99 100 101 102 103 104 105\n>>>\n"}
{"id": 120422, "name": "Floyd's triangle", "source": "Translate Ruby to Python: def floyd(rows)\n  max = (rows * (rows + 1)) / 2\n  widths = ((max - rows + 1)..max).map {|n| n.to_s.length + 1}\n  n = 0\n  rows.times do |r|\n    puts (0..r).map {|i| n += 1; \"%\n  end\nend\n\nfloyd(5)\nfloyd(14)\n", "target": ">>> def floyd(rowcount=5):\n\trows = [[1]]\n\twhile len(rows) < rowcount:\n\t\tn = rows[-1][-1] + 1\n\t\trows.append(list(range(n, n + len(rows[-1]) + 1)))\n\treturn rows\n\n>>> floyd()\n[[1], [2, 3], [4, 5, 6], [7, 8, 9, 10], [11, 12, 13, 14, 15]]\n>>> def pfloyd(rows=[[1], [2, 3], [4, 5, 6], [7, 8, 9, 10]]):\n\tcolspace = [len(str(n)) for n in rows[-1]]\n\tfor row in rows:\n\t\tprint( ' '.join('%*i' % space_n for space_n in zip(colspace, row)))\n\n\t\t\n>>> pfloyd()\n1\n2 3\n4 5 6\n7 8 9 10\n>>> pfloyd(floyd(5))\n 1\n 2  3\n 4  5  6\n 7  8  9 10\n11 12 13 14 15\n>>> pfloyd(floyd(14))\n 1\n 2  3\n 4  5  6\n 7  8  9 10\n11 12 13 14 15\n16 17 18 19 20 21\n22 23 24 25 26 27 28\n29 30 31 32 33 34 35 36\n37 38 39 40 41 42 43 44  45\n46 47 48 49 50 51 52 53  54  55\n56 57 58 59 60 61 62 63  64  65  66\n67 68 69 70 71 72 73 74  75  76  77  78\n79 80 81 82 83 84 85 86  87  88  89  90  91\n92 93 94 95 96 97 98 99 100 101 102 103 104 105\n>>>\n"}
{"id": 120886, "name": "100 prisoners", "source": "Translate Ruby to C#: prisoners = [*1..100]\nN = 10_000\ngenerate_rooms = ->{ [nil]+[*1..100].shuffle }\n \nres = N.times.count do\n  rooms = generate_rooms[]\n  prisoners.all? {|pr| rooms[1,100].sample(50).include?(pr)}\nend\nputs \"Random strategy\u00a0: %11.4f\u00a0%%\" % (res.fdiv(N) * 100)\n\nres = N.times.count do\n  rooms = generate_rooms[]\n  prisoners.all? do |pr|\n    cur_room = pr\n    50.times.any? do\n      found = (rooms[cur_room] == pr)\n      cur_room = rooms[cur_room]\n      found\n    end\n  end\nend\nputs \"Optimal strategy: %11.4f\u00a0%%\" % (res.fdiv(N) * 100)\n", "target": "using System;\nusing System.Linq;\n\nnamespace Prisoners {\n    class Program {\n        static bool PlayOptimal() {\n            var secrets = Enumerable.Range(0, 100).OrderBy(a => Guid.NewGuid()).ToList();\n\n            for (int p = 0; p < 100; p++) {\n                bool success = false;\n\n                var choice = p;\n                for (int i = 0; i < 50; i++) {\n                    if (secrets[choice] == p) {\n                        success = true;\n                        break;\n                    }\n                    choice = secrets[choice];\n                }\n\n                if (!success) {\n                    return false;\n                }\n            }\n\n            return true;\n        }\n\n        static bool PlayRandom() {\n            var secrets = Enumerable.Range(0, 100).OrderBy(a => Guid.NewGuid()).ToList();\n\n            for (int p = 0; p < 100; p++) {\n                var choices = Enumerable.Range(0, 100).OrderBy(a => Guid.NewGuid()).ToList();\n\n                bool success = false;\n                for (int i = 0; i < 50; i++) {\n                    if (choices[i] == p) {\n                        success = true;\n                        break;\n                    }\n                }\n\n                if (!success) {\n                    return false;\n                }\n            }\n\n            return true;\n        }\n\n        static double Exec(uint n, Func<bool> play) {\n            uint success = 0;\n            for (uint i = 0; i < n; i++) {\n                if (play()) {\n                    success++;\n                }\n            }\n            return 100.0 * success / n;\n        }\n\n        static void Main() {\n            const uint N = 1_000_000;\n            Console.WriteLine(\"# of executions: {0}\", N);\n            Console.WriteLine(\"Optimal play success rate: {0:0.00000000000}%\", Exec(N, PlayOptimal));\n            Console.WriteLine(\" Random play success rate: {0:0.00000000000}%\", Exec(N, PlayRandom));\n        }\n    }\n}\n"}
{"id": 120887, "name": "100 prisoners", "source": "Translate Ruby to C#: prisoners = [*1..100]\nN = 10_000\ngenerate_rooms = ->{ [nil]+[*1..100].shuffle }\n \nres = N.times.count do\n  rooms = generate_rooms[]\n  prisoners.all? {|pr| rooms[1,100].sample(50).include?(pr)}\nend\nputs \"Random strategy\u00a0: %11.4f\u00a0%%\" % (res.fdiv(N) * 100)\n\nres = N.times.count do\n  rooms = generate_rooms[]\n  prisoners.all? do |pr|\n    cur_room = pr\n    50.times.any? do\n      found = (rooms[cur_room] == pr)\n      cur_room = rooms[cur_room]\n      found\n    end\n  end\nend\nputs \"Optimal strategy: %11.4f\u00a0%%\" % (res.fdiv(N) * 100)\n", "target": "using System;\nusing System.Linq;\n\nnamespace Prisoners {\n    class Program {\n        static bool PlayOptimal() {\n            var secrets = Enumerable.Range(0, 100).OrderBy(a => Guid.NewGuid()).ToList();\n\n            for (int p = 0; p < 100; p++) {\n                bool success = false;\n\n                var choice = p;\n                for (int i = 0; i < 50; i++) {\n                    if (secrets[choice] == p) {\n                        success = true;\n                        break;\n                    }\n                    choice = secrets[choice];\n                }\n\n                if (!success) {\n                    return false;\n                }\n            }\n\n            return true;\n        }\n\n        static bool PlayRandom() {\n            var secrets = Enumerable.Range(0, 100).OrderBy(a => Guid.NewGuid()).ToList();\n\n            for (int p = 0; p < 100; p++) {\n                var choices = Enumerable.Range(0, 100).OrderBy(a => Guid.NewGuid()).ToList();\n\n                bool success = false;\n                for (int i = 0; i < 50; i++) {\n                    if (choices[i] == p) {\n                        success = true;\n                        break;\n                    }\n                }\n\n                if (!success) {\n                    return false;\n                }\n            }\n\n            return true;\n        }\n\n        static double Exec(uint n, Func<bool> play) {\n            uint success = 0;\n            for (uint i = 0; i < n; i++) {\n                if (play()) {\n                    success++;\n                }\n            }\n            return 100.0 * success / n;\n        }\n\n        static void Main() {\n            const uint N = 1_000_000;\n            Console.WriteLine(\"# of executions: {0}\", N);\n            Console.WriteLine(\"Optimal play success rate: {0:0.00000000000}%\", Exec(N, PlayOptimal));\n            Console.WriteLine(\" Random play success rate: {0:0.00000000000}%\", Exec(N, PlayRandom));\n        }\n    }\n}\n"}
{"id": 120890, "name": "100 prisoners", "source": "Translate Ruby to Java: prisoners = [*1..100]\nN = 10_000\ngenerate_rooms = ->{ [nil]+[*1..100].shuffle }\n \nres = N.times.count do\n  rooms = generate_rooms[]\n  prisoners.all? {|pr| rooms[1,100].sample(50).include?(pr)}\nend\nputs \"Random strategy\u00a0: %11.4f\u00a0%%\" % (res.fdiv(N) * 100)\n\nres = N.times.count do\n  rooms = generate_rooms[]\n  prisoners.all? do |pr|\n    cur_room = pr\n    50.times.any? do\n      found = (rooms[cur_room] == pr)\n      cur_room = rooms[cur_room]\n      found\n    end\n  end\nend\nputs \"Optimal strategy: %11.4f\u00a0%%\" % (res.fdiv(N) * 100)\n", "target": "import java.util.Collections;\nimport java.util.List;\nimport java.util.Objects;\nimport java.util.function.Function;\nimport java.util.function.Supplier;\nimport java.util.stream.Collectors;\nimport java.util.stream.IntStream;\n\npublic class Main {\n    private static boolean playOptimal(int n) {\n        List<Integer> secretList = IntStream.range(0, n).boxed().collect(Collectors.toList());\n        Collections.shuffle(secretList);\n\n        prisoner:\n        for (int i = 0; i < secretList.size(); ++i) {\n            int prev = i;\n            for (int j = 0; j < secretList.size() / 2; ++j) {\n                if (secretList.get(prev) == i) {\n                    continue prisoner;\n                }\n                prev = secretList.get(prev);\n            }\n            return false;\n        }\n        return true;\n    }\n\n    private static boolean playRandom(int n) {\n        List<Integer> secretList = IntStream.range(0, n).boxed().collect(Collectors.toList());\n        Collections.shuffle(secretList);\n\n        prisoner:\n        for (Integer i : secretList) {\n            List<Integer> trialList = IntStream.range(0, n).boxed().collect(Collectors.toList());\n            Collections.shuffle(trialList);\n\n            for (int j = 0; j < trialList.size() / 2; ++j) {\n                if (Objects.equals(trialList.get(j), i)) {\n                    continue prisoner;\n                }\n            }\n\n            return false;\n        }\n        return true;\n    }\n\n    private static double exec(int n, int p, Function<Integer, Boolean> play) {\n        int succ = 0;\n        for (int i = 0; i < n; ++i) {\n            if (play.apply(p)) {\n                succ++;\n            }\n        }\n        return (succ * 100.0) / n;\n    }\n\n    public static void main(String[] args) {\n        final int n = 100_000;\n        final int p = 100;\n        System.out.printf(\"# of executions: %d\\n\", n);\n        System.out.printf(\"Optimal play success rate: %f%%\\n\", exec(n, p, Main::playOptimal));\n        System.out.printf(\"Random play success rate: %f%%\\n\", exec(n, p, Main::playRandom));\n    }\n}\n"}
{"id": 120891, "name": "100 prisoners", "source": "Translate Ruby to Java: prisoners = [*1..100]\nN = 10_000\ngenerate_rooms = ->{ [nil]+[*1..100].shuffle }\n \nres = N.times.count do\n  rooms = generate_rooms[]\n  prisoners.all? {|pr| rooms[1,100].sample(50).include?(pr)}\nend\nputs \"Random strategy\u00a0: %11.4f\u00a0%%\" % (res.fdiv(N) * 100)\n\nres = N.times.count do\n  rooms = generate_rooms[]\n  prisoners.all? do |pr|\n    cur_room = pr\n    50.times.any? do\n      found = (rooms[cur_room] == pr)\n      cur_room = rooms[cur_room]\n      found\n    end\n  end\nend\nputs \"Optimal strategy: %11.4f\u00a0%%\" % (res.fdiv(N) * 100)\n", "target": "import java.util.Collections;\nimport java.util.List;\nimport java.util.Objects;\nimport java.util.function.Function;\nimport java.util.function.Supplier;\nimport java.util.stream.Collectors;\nimport java.util.stream.IntStream;\n\npublic class Main {\n    private static boolean playOptimal(int n) {\n        List<Integer> secretList = IntStream.range(0, n).boxed().collect(Collectors.toList());\n        Collections.shuffle(secretList);\n\n        prisoner:\n        for (int i = 0; i < secretList.size(); ++i) {\n            int prev = i;\n            for (int j = 0; j < secretList.size() / 2; ++j) {\n                if (secretList.get(prev) == i) {\n                    continue prisoner;\n                }\n                prev = secretList.get(prev);\n            }\n            return false;\n        }\n        return true;\n    }\n\n    private static boolean playRandom(int n) {\n        List<Integer> secretList = IntStream.range(0, n).boxed().collect(Collectors.toList());\n        Collections.shuffle(secretList);\n\n        prisoner:\n        for (Integer i : secretList) {\n            List<Integer> trialList = IntStream.range(0, n).boxed().collect(Collectors.toList());\n            Collections.shuffle(trialList);\n\n            for (int j = 0; j < trialList.size() / 2; ++j) {\n                if (Objects.equals(trialList.get(j), i)) {\n                    continue prisoner;\n                }\n            }\n\n            return false;\n        }\n        return true;\n    }\n\n    private static double exec(int n, int p, Function<Integer, Boolean> play) {\n        int succ = 0;\n        for (int i = 0; i < n; ++i) {\n            if (play.apply(p)) {\n                succ++;\n            }\n        }\n        return (succ * 100.0) / n;\n    }\n\n    public static void main(String[] args) {\n        final int n = 100_000;\n        final int p = 100;\n        System.out.printf(\"# of executions: %d\\n\", n);\n        System.out.printf(\"Optimal play success rate: %f%%\\n\", exec(n, p, Main::playOptimal));\n        System.out.printf(\"Random play success rate: %f%%\\n\", exec(n, p, Main::playRandom));\n    }\n}\n"}
{"id": 120892, "name": "100 prisoners", "source": "Translate Ruby to Python: prisoners = [*1..100]\nN = 10_000\ngenerate_rooms = ->{ [nil]+[*1..100].shuffle }\n \nres = N.times.count do\n  rooms = generate_rooms[]\n  prisoners.all? {|pr| rooms[1,100].sample(50).include?(pr)}\nend\nputs \"Random strategy\u00a0: %11.4f\u00a0%%\" % (res.fdiv(N) * 100)\n\nres = N.times.count do\n  rooms = generate_rooms[]\n  prisoners.all? do |pr|\n    cur_room = pr\n    50.times.any? do\n      found = (rooms[cur_room] == pr)\n      cur_room = rooms[cur_room]\n      found\n    end\n  end\nend\nputs \"Optimal strategy: %11.4f\u00a0%%\" % (res.fdiv(N) * 100)\n", "target": "import random\n\ndef play_random(n):\n    \n    pardoned = 0\n    in_drawer = list(range(100))\n    sampler = list(range(100))\n    for _round in range(n):\n        random.shuffle(in_drawer)\n        found = False\n        for prisoner in range(100):\n            found = False\n            for reveal in random.sample(sampler, 50):\n                card = in_drawer[reveal]\n                if card == prisoner:\n                    found = True\n                    break\n            if not found:\n                break\n        if found:\n            pardoned += 1\n    return pardoned / n * 100   \n\ndef play_optimal(n):\n    \n    pardoned = 0\n    in_drawer = list(range(100))\n    for _round in range(n):\n        random.shuffle(in_drawer)\n        for prisoner in range(100):\n            reveal = prisoner\n            found = False\n            for go in range(50):\n                card = in_drawer[reveal]\n                if card == prisoner:\n                    found = True\n                    break\n                reveal = card\n            if not found:\n                break\n        if found:\n            pardoned += 1\n    return pardoned / n * 100   \n\nif __name__ == '__main__':\n    n = 100_000\n    print(\" Simulation count:\", n)\n    print(f\" Random play wins: {play_random(n):4.1f}% of simulations\")\n    print(f\"Optimal play wins: {play_optimal(n):4.1f}% of simulations\")\n"}
{"id": 120893, "name": "100 prisoners", "source": "Translate Ruby to Python: prisoners = [*1..100]\nN = 10_000\ngenerate_rooms = ->{ [nil]+[*1..100].shuffle }\n \nres = N.times.count do\n  rooms = generate_rooms[]\n  prisoners.all? {|pr| rooms[1,100].sample(50).include?(pr)}\nend\nputs \"Random strategy\u00a0: %11.4f\u00a0%%\" % (res.fdiv(N) * 100)\n\nres = N.times.count do\n  rooms = generate_rooms[]\n  prisoners.all? do |pr|\n    cur_room = pr\n    50.times.any? do\n      found = (rooms[cur_room] == pr)\n      cur_room = rooms[cur_room]\n      found\n    end\n  end\nend\nputs \"Optimal strategy: %11.4f\u00a0%%\" % (res.fdiv(N) * 100)\n", "target": "import random\n\ndef play_random(n):\n    \n    pardoned = 0\n    in_drawer = list(range(100))\n    sampler = list(range(100))\n    for _round in range(n):\n        random.shuffle(in_drawer)\n        found = False\n        for prisoner in range(100):\n            found = False\n            for reveal in random.sample(sampler, 50):\n                card = in_drawer[reveal]\n                if card == prisoner:\n                    found = True\n                    break\n            if not found:\n                break\n        if found:\n            pardoned += 1\n    return pardoned / n * 100   \n\ndef play_optimal(n):\n    \n    pardoned = 0\n    in_drawer = list(range(100))\n    for _round in range(n):\n        random.shuffle(in_drawer)\n        for prisoner in range(100):\n            reveal = prisoner\n            found = False\n            for go in range(50):\n                card = in_drawer[reveal]\n                if card == prisoner:\n                    found = True\n                    break\n                reveal = card\n            if not found:\n                break\n        if found:\n            pardoned += 1\n    return pardoned / n * 100   \n\nif __name__ == '__main__':\n    n = 100_000\n    print(\" Simulation count:\", n)\n    print(f\" Random play wins: {play_random(n):4.1f}% of simulations\")\n    print(f\"Optimal play wins: {play_optimal(n):4.1f}% of simulations\")\n"}
{"id": 121302, "name": "Word wrap", "source": "Translate Ruby to C#: class String\n  def wrap(width)\n    txt = gsub(\"\\n\", \" \")\n    para = []\n    i = 0\n    while i < length \n      j = i + width\n      j -= 1 while j != txt.length && j > i + 1 && !(txt[j] =~ /\\s/)\n      para << txt[i ... j]\n      i = j + 1\n    end\n    para\n  end\nend\n\ntext = <<END\nIn olden times when wishing still helped one, there lived a king\nwhose daughters were all beautiful, but the youngest was so beautiful\nthat the sun itself, which has seen so much, was astonished whenever\nit shone in her face.  Close by the king's castle lay a great dark\nforest, and under an old lime-tree in the forest was a well, and when\nthe day was very warm, the king's child went out into the forest and\nsat down by the side of the cool fountain, and when she was bored she\ntook a golden ball, and threw it up on high and caught it, and this\nball was her favorite plaything.\nEND\n\n[72,80].each do |w|\n  puts \".\" * w\n  puts text.wrap(w)\nend\n", "target": "namespace RosettaCode.WordWrap\n{\n    using System;\n    using System.Collections.Generic;\n\n    internal static class Program\n    {\n        private const string LoremIpsum = @\"\nLorem ipsum dolor sit amet, consectetur adipiscing elit. Maecenas varius sapien\nvel purus hendrerit vehicula. Integer hendrerit viverra turpis, ac sagittis arcu\npharetra id. Sed dapibus enim non dui posuere sit amet rhoncus tellus\nconsectetur. Proin blandit lacus vitae nibh tincidunt cursus. Cum sociis natoque\npenatibus et magnis dis parturient montes, nascetur ridiculus mus. Nam tincidunt\npurus at tortor tincidunt et aliquam dui gravida. Nulla consectetur sem vel\nfelis vulputate et imperdiet orci pharetra. Nam vel tortor nisi. Sed eget porta\ntortor. Aliquam suscipit lacus vel odio faucibus tempor. Sed ipsum est,\ncondimentum eget eleifend ac, ultricies non dui. Integer tempus, nunc sed\nvenenatis feugiat, augue orci pellentesque risus, nec pretium lacus enim eu\nnibh.\";\n\n        private static void Main()\n        {\n            foreach (var lineWidth in new[] { 72, 80 })\n            {\n                Console.WriteLine(new string('-', lineWidth));\n                Console.WriteLine(Wrap(LoremIpsum, lineWidth));\n            }\n        }\n\n        private static string Wrap(string text, int lineWidth)\n        {\n            return string.Join(string.Empty,\n                               Wrap(\n                                   text.Split(new char[0],\n                                              StringSplitOptions\n                                                  .RemoveEmptyEntries),\n                                   lineWidth));\n        }\n\n        private static IEnumerable<string> Wrap(IEnumerable<string> words,\n                                                int lineWidth)\n        {\n            var currentWidth = 0;\n            foreach (var word in words)\n            {\n                if (currentWidth != 0)\n                {\n                    if (currentWidth + word.Length < lineWidth)\n                    {\n                        currentWidth++;\n                        yield return \" \";\n                    }\n                    else\n                    {\n                        currentWidth = 0;\n                        yield return Environment.NewLine;\n                    }\n                }\n                currentWidth += word.Length;\n                yield return word;\n            }\n        }\n    }\n}\n"}
{"id": 121303, "name": "Word wrap", "source": "Translate Ruby to C#: class String\n  def wrap(width)\n    txt = gsub(\"\\n\", \" \")\n    para = []\n    i = 0\n    while i < length \n      j = i + width\n      j -= 1 while j != txt.length && j > i + 1 && !(txt[j] =~ /\\s/)\n      para << txt[i ... j]\n      i = j + 1\n    end\n    para\n  end\nend\n\ntext = <<END\nIn olden times when wishing still helped one, there lived a king\nwhose daughters were all beautiful, but the youngest was so beautiful\nthat the sun itself, which has seen so much, was astonished whenever\nit shone in her face.  Close by the king's castle lay a great dark\nforest, and under an old lime-tree in the forest was a well, and when\nthe day was very warm, the king's child went out into the forest and\nsat down by the side of the cool fountain, and when she was bored she\ntook a golden ball, and threw it up on high and caught it, and this\nball was her favorite plaything.\nEND\n\n[72,80].each do |w|\n  puts \".\" * w\n  puts text.wrap(w)\nend\n", "target": "namespace RosettaCode.WordWrap\n{\n    using System;\n    using System.Collections.Generic;\n\n    internal static class Program\n    {\n        private const string LoremIpsum = @\"\nLorem ipsum dolor sit amet, consectetur adipiscing elit. Maecenas varius sapien\nvel purus hendrerit vehicula. Integer hendrerit viverra turpis, ac sagittis arcu\npharetra id. Sed dapibus enim non dui posuere sit amet rhoncus tellus\nconsectetur. Proin blandit lacus vitae nibh tincidunt cursus. Cum sociis natoque\npenatibus et magnis dis parturient montes, nascetur ridiculus mus. Nam tincidunt\npurus at tortor tincidunt et aliquam dui gravida. Nulla consectetur sem vel\nfelis vulputate et imperdiet orci pharetra. Nam vel tortor nisi. Sed eget porta\ntortor. Aliquam suscipit lacus vel odio faucibus tempor. Sed ipsum est,\ncondimentum eget eleifend ac, ultricies non dui. Integer tempus, nunc sed\nvenenatis feugiat, augue orci pellentesque risus, nec pretium lacus enim eu\nnibh.\";\n\n        private static void Main()\n        {\n            foreach (var lineWidth in new[] { 72, 80 })\n            {\n                Console.WriteLine(new string('-', lineWidth));\n                Console.WriteLine(Wrap(LoremIpsum, lineWidth));\n            }\n        }\n\n        private static string Wrap(string text, int lineWidth)\n        {\n            return string.Join(string.Empty,\n                               Wrap(\n                                   text.Split(new char[0],\n                                              StringSplitOptions\n                                                  .RemoveEmptyEntries),\n                                   lineWidth));\n        }\n\n        private static IEnumerable<string> Wrap(IEnumerable<string> words,\n                                                int lineWidth)\n        {\n            var currentWidth = 0;\n            foreach (var word in words)\n            {\n                if (currentWidth != 0)\n                {\n                    if (currentWidth + word.Length < lineWidth)\n                    {\n                        currentWidth++;\n                        yield return \" \";\n                    }\n                    else\n                    {\n                        currentWidth = 0;\n                        yield return Environment.NewLine;\n                    }\n                }\n                currentWidth += word.Length;\n                yield return word;\n            }\n        }\n    }\n}\n"}
{"id": 121306, "name": "Word wrap", "source": "Translate Ruby to Java: class String\n  def wrap(width)\n    txt = gsub(\"\\n\", \" \")\n    para = []\n    i = 0\n    while i < length \n      j = i + width\n      j -= 1 while j != txt.length && j > i + 1 && !(txt[j] =~ /\\s/)\n      para << txt[i ... j]\n      i = j + 1\n    end\n    para\n  end\nend\n\ntext = <<END\nIn olden times when wishing still helped one, there lived a king\nwhose daughters were all beautiful, but the youngest was so beautiful\nthat the sun itself, which has seen so much, was astonished whenever\nit shone in her face.  Close by the king's castle lay a great dark\nforest, and under an old lime-tree in the forest was a well, and when\nthe day was very warm, the king's child went out into the forest and\nsat down by the side of the cool fountain, and when she was bored she\ntook a golden ball, and threw it up on high and caught it, and this\nball was her favorite plaything.\nEND\n\n[72,80].each do |w|\n  puts \".\" * w\n  puts text.wrap(w)\nend\n", "target": "package rosettacode;\n\nimport java.util.StringTokenizer;\n\npublic class WordWrap \n{\n    int defaultLineWidth=80;\n    int defaultSpaceWidth=1;\n    void minNumLinesWrap(String text)\n    {\n        minNumLinesWrap(text,defaultLineWidth);\n    }\n    void minNumLinesWrap(String text,int LineWidth)\n    {\n        StringTokenizer st=new StringTokenizer(text);\n        int SpaceLeft=LineWidth;\n        int SpaceWidth=defaultSpaceWidth;\n        while(st.hasMoreTokens())\n        {\n            String word=st.nextToken();\n            if((word.length()+SpaceWidth)>SpaceLeft)\n            {\n                System.out.print(\"\\n\"+word+\" \");\n                SpaceLeft=LineWidth-word.length();\n            }\n            else\n            {\n                System.out.print(word+\" \");\n                SpaceLeft-=(word.length()+SpaceWidth);\n            }\n        }\n    }\n    public static void main(String[] args)\n    {\n        WordWrap now=new WordWrap();\n        String wodehouse=\"Old Mr MacFarland (_said Henry_) started the place fifteen years ago. He was a widower with one son and what you might call half a daughter. That's to say, he had adopted her. Katie was her name, and she was the child of a dead friend of his. The son's name was Andy. A little freckled nipper he was when I first knew him--one of those silent kids that don't say much and have as much obstinacy in them as if they were mules. Many's the time, in them days, I've clumped him on the head and told him to do something; and he didn't run yelling to his pa, same as most kids would have done, but just said nothing and went on not doing whatever it was I had told him to do. That was the sort of disposition Andy had, and it grew on him. Why, when he came back from Oxford College the time the old man sent for him--what I'm going to tell you about soon--he had a jaw on him like the ram of a battleship. Katie was the kid for my money. I liked Katie. We all liked Katie.\";\n        System.out.println(\"DEFAULT:\");\n        now.minNumLinesWrap(wodehouse);\n        System.out.println(\"\\n\\nLINEWIDTH=120\");\n        now.minNumLinesWrap(wodehouse,120);\n    }\n\n}\n"}
{"id": 121307, "name": "Word wrap", "source": "Translate Ruby to Java: class String\n  def wrap(width)\n    txt = gsub(\"\\n\", \" \")\n    para = []\n    i = 0\n    while i < length \n      j = i + width\n      j -= 1 while j != txt.length && j > i + 1 && !(txt[j] =~ /\\s/)\n      para << txt[i ... j]\n      i = j + 1\n    end\n    para\n  end\nend\n\ntext = <<END\nIn olden times when wishing still helped one, there lived a king\nwhose daughters were all beautiful, but the youngest was so beautiful\nthat the sun itself, which has seen so much, was astonished whenever\nit shone in her face.  Close by the king's castle lay a great dark\nforest, and under an old lime-tree in the forest was a well, and when\nthe day was very warm, the king's child went out into the forest and\nsat down by the side of the cool fountain, and when she was bored she\ntook a golden ball, and threw it up on high and caught it, and this\nball was her favorite plaything.\nEND\n\n[72,80].each do |w|\n  puts \".\" * w\n  puts text.wrap(w)\nend\n", "target": "package rosettacode;\n\nimport java.util.StringTokenizer;\n\npublic class WordWrap \n{\n    int defaultLineWidth=80;\n    int defaultSpaceWidth=1;\n    void minNumLinesWrap(String text)\n    {\n        minNumLinesWrap(text,defaultLineWidth);\n    }\n    void minNumLinesWrap(String text,int LineWidth)\n    {\n        StringTokenizer st=new StringTokenizer(text);\n        int SpaceLeft=LineWidth;\n        int SpaceWidth=defaultSpaceWidth;\n        while(st.hasMoreTokens())\n        {\n            String word=st.nextToken();\n            if((word.length()+SpaceWidth)>SpaceLeft)\n            {\n                System.out.print(\"\\n\"+word+\" \");\n                SpaceLeft=LineWidth-word.length();\n            }\n            else\n            {\n                System.out.print(word+\" \");\n                SpaceLeft-=(word.length()+SpaceWidth);\n            }\n        }\n    }\n    public static void main(String[] args)\n    {\n        WordWrap now=new WordWrap();\n        String wodehouse=\"Old Mr MacFarland (_said Henry_) started the place fifteen years ago. He was a widower with one son and what you might call half a daughter. That's to say, he had adopted her. Katie was her name, and she was the child of a dead friend of his. The son's name was Andy. A little freckled nipper he was when I first knew him--one of those silent kids that don't say much and have as much obstinacy in them as if they were mules. Many's the time, in them days, I've clumped him on the head and told him to do something; and he didn't run yelling to his pa, same as most kids would have done, but just said nothing and went on not doing whatever it was I had told him to do. That was the sort of disposition Andy had, and it grew on him. Why, when he came back from Oxford College the time the old man sent for him--what I'm going to tell you about soon--he had a jaw on him like the ram of a battleship. Katie was the kid for my money. I liked Katie. We all liked Katie.\";\n        System.out.println(\"DEFAULT:\");\n        now.minNumLinesWrap(wodehouse);\n        System.out.println(\"\\n\\nLINEWIDTH=120\");\n        now.minNumLinesWrap(wodehouse,120);\n    }\n\n}\n"}
{"id": 121308, "name": "Word wrap", "source": "Translate Ruby to Python: class String\n  def wrap(width)\n    txt = gsub(\"\\n\", \" \")\n    para = []\n    i = 0\n    while i < length \n      j = i + width\n      j -= 1 while j != txt.length && j > i + 1 && !(txt[j] =~ /\\s/)\n      para << txt[i ... j]\n      i = j + 1\n    end\n    para\n  end\nend\n\ntext = <<END\nIn olden times when wishing still helped one, there lived a king\nwhose daughters were all beautiful, but the youngest was so beautiful\nthat the sun itself, which has seen so much, was astonished whenever\nit shone in her face.  Close by the king's castle lay a great dark\nforest, and under an old lime-tree in the forest was a well, and when\nthe day was very warm, the king's child went out into the forest and\nsat down by the side of the cool fountain, and when she was bored she\ntook a golden ball, and threw it up on high and caught it, and this\nball was her favorite plaything.\nEND\n\n[72,80].each do |w|\n  puts \".\" * w\n  puts text.wrap(w)\nend\n", "target": ">>> import textwrap\n>>> help(textwrap.fill)\nHelp on function fill in module textwrap:\n\nfill(text, width=70, **kwargs)\n    Fill a single paragraph of text, returning a new string.\n    \n    Reformat the single paragraph in 'text' to fit in lines of no more\n    than 'width' columns, and return a new string containing the entire\n    wrapped paragraph.  As with wrap(), tabs are expanded and other\n    whitespace characters converted to space.  See TextWrapper class for\n    available keyword args to customize wrapping behaviour.\n\n>>> txt = \n>>> print(textwrap.fill(txt, width=75))\nReformat the single paragraph in 'text' to fit in lines of no more than\n'width' columns, and return a new string containing the entire wrapped\nparagraph.  As with wrap(), tabs are expanded and other whitespace\ncharacters converted to space.  See TextWrapper class for available keyword\nargs to customize wrapping behaviour.\n>>> print(textwrap.fill(txt, width=45))\nReformat the single paragraph in 'text' to\nfit in lines of no more than 'width' columns,\nand return a new string containing the entire\nwrapped paragraph.  As with wrap(), tabs are\nexpanded and other whitespace characters\nconverted to space.  See TextWrapper class\nfor available keyword args to customize\nwrapping behaviour.\n>>> print(textwrap.fill(txt, width=85))\nReformat the single paragraph in 'text' to fit in lines of no more than 'width'\ncolumns, and return a new string containing the entire wrapped paragraph.  As with\nwrap(), tabs are expanded and other whitespace characters converted to space.  See\nTextWrapper class for available keyword args to customize wrapping behaviour.\n>>>\n"}
{"id": 121309, "name": "Word wrap", "source": "Translate Ruby to Python: class String\n  def wrap(width)\n    txt = gsub(\"\\n\", \" \")\n    para = []\n    i = 0\n    while i < length \n      j = i + width\n      j -= 1 while j != txt.length && j > i + 1 && !(txt[j] =~ /\\s/)\n      para << txt[i ... j]\n      i = j + 1\n    end\n    para\n  end\nend\n\ntext = <<END\nIn olden times when wishing still helped one, there lived a king\nwhose daughters were all beautiful, but the youngest was so beautiful\nthat the sun itself, which has seen so much, was astonished whenever\nit shone in her face.  Close by the king's castle lay a great dark\nforest, and under an old lime-tree in the forest was a well, and when\nthe day was very warm, the king's child went out into the forest and\nsat down by the side of the cool fountain, and when she was bored she\ntook a golden ball, and threw it up on high and caught it, and this\nball was her favorite plaything.\nEND\n\n[72,80].each do |w|\n  puts \".\" * w\n  puts text.wrap(w)\nend\n", "target": ">>> import textwrap\n>>> help(textwrap.fill)\nHelp on function fill in module textwrap:\n\nfill(text, width=70, **kwargs)\n    Fill a single paragraph of text, returning a new string.\n    \n    Reformat the single paragraph in 'text' to fit in lines of no more\n    than 'width' columns, and return a new string containing the entire\n    wrapped paragraph.  As with wrap(), tabs are expanded and other\n    whitespace characters converted to space.  See TextWrapper class for\n    available keyword args to customize wrapping behaviour.\n\n>>> txt = \n>>> print(textwrap.fill(txt, width=75))\nReformat the single paragraph in 'text' to fit in lines of no more than\n'width' columns, and return a new string containing the entire wrapped\nparagraph.  As with wrap(), tabs are expanded and other whitespace\ncharacters converted to space.  See TextWrapper class for available keyword\nargs to customize wrapping behaviour.\n>>> print(textwrap.fill(txt, width=45))\nReformat the single paragraph in 'text' to\nfit in lines of no more than 'width' columns,\nand return a new string containing the entire\nwrapped paragraph.  As with wrap(), tabs are\nexpanded and other whitespace characters\nconverted to space.  See TextWrapper class\nfor available keyword args to customize\nwrapping behaviour.\n>>> print(textwrap.fill(txt, width=85))\nReformat the single paragraph in 'text' to fit in lines of no more than 'width'\ncolumns, and return a new string containing the entire wrapped paragraph.  As with\nwrap(), tabs are expanded and other whitespace characters converted to space.  See\nTextWrapper class for available keyword args to customize wrapping behaviour.\n>>>\n"}
{"id": 121806, "name": "Harshad or Niven series", "source": "Translate Ruby to C#: harshad = 1.step.select { |n| n % n.to_s.chars.sum(&.to_i) == 0 }\n \nputs \"The first 20 harshard numbers are: \\n\nputs \"The first harshard number > 1000 is \n", "target": "using System;\nusing System.Collections.Generic;\n\nnamespace Harshad\n{\n    class Program\n    {\n        public static bool IsHarshad(int n)\n        {\n            char[] inputChars = n.ToString().ToCharArray();\n            IList<byte> digits = new List<byte>();\n\n            foreach (char digit in inputChars)\n            {\n                digits.Add((byte)Char.GetNumericValue(digit));\n            }\n\n            if (n < 1)\n            {\n                return false;\n            }\n\n            int sum = 0;\n\n            foreach (byte digit in digits)\n            {\n                sum += digit;\n            }\n\n            return n % sum == 0;\n        }\n\n        static void Main(string[] args)\n        {\n            int i = 1;\n            int count = 0;\n\n            while (true)\n            {\n                if (IsHarshad(i))\n                {\n                    count++;\n\n                    if (count <= 20)\n                    {\n                        Console.Write(string.Format(\"{0} \", i));\n                    }\n                    else if (i > 1000)\n                    {\n                        Console.Write(string.Format(\"{0} \", i));\n                        break;\n                    }\n                }\n\n                i++;\n            }\n\n            Console.ReadKey();\n        }\n    }\n}\n"}
{"id": 121807, "name": "Harshad or Niven series", "source": "Translate Ruby to C#: harshad = 1.step.select { |n| n % n.to_s.chars.sum(&.to_i) == 0 }\n \nputs \"The first 20 harshard numbers are: \\n\nputs \"The first harshard number > 1000 is \n", "target": "using System;\nusing System.Collections.Generic;\n\nnamespace Harshad\n{\n    class Program\n    {\n        public static bool IsHarshad(int n)\n        {\n            char[] inputChars = n.ToString().ToCharArray();\n            IList<byte> digits = new List<byte>();\n\n            foreach (char digit in inputChars)\n            {\n                digits.Add((byte)Char.GetNumericValue(digit));\n            }\n\n            if (n < 1)\n            {\n                return false;\n            }\n\n            int sum = 0;\n\n            foreach (byte digit in digits)\n            {\n                sum += digit;\n            }\n\n            return n % sum == 0;\n        }\n\n        static void Main(string[] args)\n        {\n            int i = 1;\n            int count = 0;\n\n            while (true)\n            {\n                if (IsHarshad(i))\n                {\n                    count++;\n\n                    if (count <= 20)\n                    {\n                        Console.Write(string.Format(\"{0} \", i));\n                    }\n                    else if (i > 1000)\n                    {\n                        Console.Write(string.Format(\"{0} \", i));\n                        break;\n                    }\n                }\n\n                i++;\n            }\n\n            Console.ReadKey();\n        }\n    }\n}\n"}
{"id": 121810, "name": "Harshad or Niven series", "source": "Translate Ruby to Java: harshad = 1.step.select { |n| n % n.to_s.chars.sum(&.to_i) == 0 }\n \nputs \"The first 20 harshard numbers are: \\n\nputs \"The first harshard number > 1000 is \n", "target": "public class Harshad{\n    private static long sumDigits(long n){\n        long sum = 0;\n        for(char digit:Long.toString(n).toCharArray()){\n            sum += Character.digit(digit, 10);\n        }\n        return sum;\n    }\n    public static void main(String[] args){\n        for(int count = 0, i = 1; count < 20;i++){\n            if(i % sumDigits(i) == 0){\n                System.out.println(i);\n                count++;\n            }\n        }\n        System.out.println();\n        for(int i = 1001; ; i++){\n            if(i % sumDigits(i) == 0){\n                System.out.println(i);\n                break;\n            }\n        }\n    }\n}\n"}
{"id": 121811, "name": "Harshad or Niven series", "source": "Translate Ruby to Java: harshad = 1.step.select { |n| n % n.to_s.chars.sum(&.to_i) == 0 }\n \nputs \"The first 20 harshard numbers are: \\n\nputs \"The first harshard number > 1000 is \n", "target": "public class Harshad{\n    private static long sumDigits(long n){\n        long sum = 0;\n        for(char digit:Long.toString(n).toCharArray()){\n            sum += Character.digit(digit, 10);\n        }\n        return sum;\n    }\n    public static void main(String[] args){\n        for(int count = 0, i = 1; count < 20;i++){\n            if(i % sumDigits(i) == 0){\n                System.out.println(i);\n                count++;\n            }\n        }\n        System.out.println();\n        for(int i = 1001; ; i++){\n            if(i % sumDigits(i) == 0){\n                System.out.println(i);\n                break;\n            }\n        }\n    }\n}\n"}
{"id": 121812, "name": "Harshad or Niven series", "source": "Translate Ruby to Python: harshad = 1.step.select { |n| n % n.to_s.chars.sum(&.to_i) == 0 }\n \nputs \"The first 20 harshard numbers are: \\n\nputs \"The first harshard number > 1000 is \n", "target": ">>> import itertools\n>>> def harshad():\n\tfor n in itertools.count(1):\n\t\tif n % sum(int(ch) for ch in str(n)) == 0:\n\t\t\tyield n\n\n\t\t\n>>> list(itertools.islice(harshad(), 0, 20))\n[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 12, 18, 20, 21, 24, 27, 30, 36, 40, 42]\n>>> for n in harshad():\n\tif n > 1000:\n\t\tprint(n)\n\t\tbreak\n\n\t\n1002\n>>>\n"}
{"id": 121813, "name": "Harshad or Niven series", "source": "Translate Ruby to Python: harshad = 1.step.select { |n| n % n.to_s.chars.sum(&.to_i) == 0 }\n \nputs \"The first 20 harshard numbers are: \\n\nputs \"The first harshard number > 1000 is \n", "target": ">>> import itertools\n>>> def harshad():\n\tfor n in itertools.count(1):\n\t\tif n % sum(int(ch) for ch in str(n)) == 0:\n\t\t\tyield n\n\n\t\t\n>>> list(itertools.islice(harshad(), 0, 20))\n[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 12, 18, 20, 21, 24, 27, 30, 36, 40, 42]\n>>> for n in harshad():\n\tif n > 1000:\n\t\tprint(n)\n\t\tbreak\n\n\t\n1002\n>>>\n"}
{"id": 122018, "name": "Arithmetic_Rational", "source": "Translate Ruby to C#: for candidate in 2 .. 2**19\n  sum = Rational(1, candidate)\n  for factor in 2 .. Integer.sqrt(candidate)\n    if candidate % factor == 0\n      sum += Rational(1, factor) + Rational(1, candidate / factor)\n    end\n  end\n  if sum.denominator == 1\n    puts \"Sum of recipr. factors of %d = %d exactly %s\" %\n           [candidate, sum.to_i, sum == 1 ? \"perfect!\" : \"\"]\n  end\nend\n", "target": "using System;\n\nstruct Fraction : IEquatable<Fraction>, IComparable<Fraction>\n{\n    public readonly long Num;\n    public readonly long Denom;\n\n    public Fraction(long num, long denom)\n    {\n        if (num == 0)\n        {\n            denom = 1;\n        }\n        else if (denom == 0)\n        {\n            throw new ArgumentException(\"Denominator may not be zero\", \"denom\");\n        }\n        else if (denom < 0)\n        {\n            num = -num;\n            denom = -denom;\n        }\n\n        long d = GCD(num, denom);\n        this.Num = num / d;\n        this.Denom = denom / d;\n    }\n\n    private static long GCD(long x, long y)\n    {\n        return y == 0 ? x : GCD(y, x % y);\n    }\n\n    private static long LCM(long x, long y)\n    {\n        return x / GCD(x, y) * y;\n    }\n\n    public Fraction Abs()\n    {\n        return new Fraction(Math.Abs(Num), Denom);\n    }\n\n    public Fraction Reciprocal()\n    {\n        return new Fraction(Denom, Num);\n    }\n\n    #region Conversion Operators\n\n    public static implicit operator Fraction(long i)\n    {\n        return new Fraction(i, 1);\n    }\n\n    public static explicit operator double(Fraction f)\n    {\n        return f.Num == 0 ? 0 : (double)f.Num / f.Denom;\n    }\n\n    #endregion\n\n    #region Arithmetic Operators\n\n    public static Fraction operator -(Fraction f)\n    {\n        return new Fraction(-f.Num, f.Denom);\n    }\n\n    public static Fraction operator +(Fraction a, Fraction b)\n    {\n        long m = LCM(a.Denom, b.Denom);\n        long na = a.Num * m / a.Denom;\n        long nb = b.Num * m / b.Denom;\n        return new Fraction(na + nb, m);\n    }\n\n    public static Fraction operator -(Fraction a, Fraction b)\n    {\n        return a + (-b);\n    }\n\n    public static Fraction operator *(Fraction a, Fraction b)\n    {\n        return new Fraction(a.Num * b.Num, a.Denom * b.Denom);\n    }\n\n    public static Fraction operator /(Fraction a, Fraction b)\n    {\n        return a * b.Reciprocal();\n    }\n\n    public static Fraction operator %(Fraction a, Fraction b)\n    {\n        long l = a.Num * b.Denom, r = a.Denom * b.Num;\n        long n = l / r;\n        return new Fraction(l - n * r, a.Denom * b.Denom);\n    }\n\n    #endregion\n\n    #region Comparison Operators\n\n    public static bool operator ==(Fraction a, Fraction b)\n    {\n        return a.Num == b.Num && a.Denom == b.Denom;\n    }\n\n    public static bool operator !=(Fraction a, Fraction b)\n    {\n        return a.Num != b.Num || a.Denom != b.Denom;\n    }\n\n    public static bool operator <(Fraction a, Fraction b)\n    {\n        return (a.Num * b.Denom) < (a.Denom * b.Num);\n    }\n\n    public static bool operator >(Fraction a, Fraction b)\n    {\n        return (a.Num * b.Denom) > (a.Denom * b.Num);\n    }\n\n    public static bool operator <=(Fraction a, Fraction b)\n    {\n        return !(a > b);\n    }\n\n    public static bool operator >=(Fraction a, Fraction b)\n    {\n        return !(a < b);\n    }\n\n    #endregion\n\n    #region Object Members\n\n    public override bool Equals(object obj)\n    {\n        if (obj is Fraction)\n            return ((Fraction)obj) == this;\n        else\n            return false;\n    }\n\n    public override int GetHashCode()\n    {\n        return Num.GetHashCode() ^ Denom.GetHashCode();\n    }\n\n    public override string ToString()\n    {\n        return Num.ToString() + \"/\" + Denom.ToString();\n    }\n\n    #endregion\n\n    #region IEquatable<Fraction> Members\n\n    public bool Equals(Fraction other)\n    {\n        return other == this;\n    }\n\n    #endregion\n\n    #region IComparable<Fraction> Members\n\n    public int CompareTo(Fraction other)\n    {\n        return (this.Num * other.Denom).CompareTo(this.Denom * other.Num);\n    }\n\n    #endregion\n}\n"}
{"id": 122020, "name": "Arithmetic_Rational", "source": "Translate Ruby to Java: for candidate in 2 .. 2**19\n  sum = Rational(1, candidate)\n  for factor in 2 .. Integer.sqrt(candidate)\n    if candidate % factor == 0\n      sum += Rational(1, factor) + Rational(1, candidate / factor)\n    end\n  end\n  if sum.denominator == 1\n    puts \"Sum of recipr. factors of %d = %d exactly %s\" %\n           [candidate, sum.to_i, sum == 1 ? \"perfect!\" : \"\"]\n  end\nend\n", "target": "public class BigRationalFindPerfectNumbers {\n    public static void main(String[] args) {\n        int MAX_NUM = 1 << 19;\n        System.out.println(\"Searching for perfect numbers in the range [1, \" + (MAX_NUM - 1) + \"]\");\n\n        BigRational TWO = BigRational.valueOf(2);\n        for (int i = 1; i < MAX_NUM; i++) {\n            BigRational reciprocalSum = BigRational.ONE;\n            if (i > 1)\n                reciprocalSum = reciprocalSum.add(BigRational.valueOf(i).reciprocal());\n            int maxDivisor = (int) Math.sqrt(i);\n            if (maxDivisor >= i)\n                maxDivisor--;\n\n            for (int divisor = 2; divisor <= maxDivisor; divisor++) {\n                if (i % divisor == 0) {\n                    reciprocalSum = reciprocalSum.add(BigRational.valueOf(divisor).reciprocal());\n                    int dividend = i / divisor;\n                    if (divisor != dividend)\n                        reciprocalSum = reciprocalSum.add(BigRational.valueOf(dividend).reciprocal());\n                }\n            }\n            if (reciprocalSum.equals(TWO))\n                System.out.println(String.valueOf(i) + \" is a perfect number\");\n        }\n    }\n}\n"}
{"id": 122021, "name": "Arithmetic_Rational", "source": "Translate Ruby to Python: for candidate in 2 .. 2**19\n  sum = Rational(1, candidate)\n  for factor in 2 .. Integer.sqrt(candidate)\n    if candidate % factor == 0\n      sum += Rational(1, factor) + Rational(1, candidate / factor)\n    end\n  end\n  if sum.denominator == 1\n    puts \"Sum of recipr. factors of %d = %d exactly %s\" %\n           [candidate, sum.to_i, sum == 1 ? \"perfect!\" : \"\"]\n  end\nend\n", "target": "from fractions import Fraction\n\nfor candidate in range(2, 2**19):\n  sum = Fraction(1, candidate)\n  for factor in range(2, int(candidate**0.5)+1):\n    if candidate % factor == 0:\n      sum += Fraction(1, factor) + Fraction(1, candidate // factor)\n  if sum.denominator == 1:\n    print(\"Sum of recipr. factors of %d = %d exactly %s\" %\n           (candidate, int(sum), \"perfect!\" if sum == 1 else \"\"))\n"}
{"id": 122431, "name": "Even or odd", "source": "Translate Ruby to C#: print \"evens: \"\np -5.upto(5).select(&:even?)\nprint \"odds: \"\np -5.upto(5).select(&:odd?)\n", "target": "namespace RosettaCode\n{\n    using System;\n\n    public static class EvenOrOdd\n    {\n        public static bool IsEvenBitwise(this int number)\n        {\n            return (number & 1) == 0;\n        }\n\n        public static bool IsOddBitwise(this int number)\n        {\n            return (number & 1) != 0;\n        }\n\n        public static bool IsEvenRemainder(this int number)\n        {\n            int remainder;\n            Math.DivRem(number, 2, out remainder);\n            return remainder == 0;\n        }\n\n        public static bool IsOddRemainder(this int number)\n        {\n            int remainder;\n            Math.DivRem(number, 2, out remainder);\n            return remainder != 0;\n        }\n\n        public static bool IsEvenModulo(this int number)\n        {\n            return (number % 2) == 0;\n        }\n\n        public static bool IsOddModulo(this int number)\n        {\n            return (number % 2) != 0;\n        }\n    }\n    public class Program\n    {\n        public static void Main()\n        {\n            int num = 26;               \n            if (num.IsEvenBitwise())    \n            {\n                Console.Write(\"Even\");\n            }\n            else\n            {\n                Console.Write(\"Odd\");\n            }\n            \n            if (num.IsOddBitwise())    \n            {\n                Console.Write(\"Odd\");\n            }\n            else\n            {\n                Console.Write(\"Even\");\n            }\n            \n        }\n    }\n}\n"}
{"id": 122432, "name": "Even or odd", "source": "Translate Ruby to C#: print \"evens: \"\np -5.upto(5).select(&:even?)\nprint \"odds: \"\np -5.upto(5).select(&:odd?)\n", "target": "namespace RosettaCode\n{\n    using System;\n\n    public static class EvenOrOdd\n    {\n        public static bool IsEvenBitwise(this int number)\n        {\n            return (number & 1) == 0;\n        }\n\n        public static bool IsOddBitwise(this int number)\n        {\n            return (number & 1) != 0;\n        }\n\n        public static bool IsEvenRemainder(this int number)\n        {\n            int remainder;\n            Math.DivRem(number, 2, out remainder);\n            return remainder == 0;\n        }\n\n        public static bool IsOddRemainder(this int number)\n        {\n            int remainder;\n            Math.DivRem(number, 2, out remainder);\n            return remainder != 0;\n        }\n\n        public static bool IsEvenModulo(this int number)\n        {\n            return (number % 2) == 0;\n        }\n\n        public static bool IsOddModulo(this int number)\n        {\n            return (number % 2) != 0;\n        }\n    }\n    public class Program\n    {\n        public static void Main()\n        {\n            int num = 26;               \n            if (num.IsEvenBitwise())    \n            {\n                Console.Write(\"Even\");\n            }\n            else\n            {\n                Console.Write(\"Odd\");\n            }\n            \n            if (num.IsOddBitwise())    \n            {\n                Console.Write(\"Odd\");\n            }\n            else\n            {\n                Console.Write(\"Even\");\n            }\n            \n        }\n    }\n}\n"}
{"id": 122435, "name": "Even or odd", "source": "Translate Ruby to Java: print \"evens: \"\np -5.upto(5).select(&:even?)\nprint \"odds: \"\np -5.upto(5).select(&:odd?)\n", "target": "public static boolean isEven(int i){\n    return (i & 1) == 0;\n}\n"}
{"id": 122436, "name": "Even or odd", "source": "Translate Ruby to Java: print \"evens: \"\np -5.upto(5).select(&:even?)\nprint \"odds: \"\np -5.upto(5).select(&:odd?)\n", "target": "public static boolean isEven(int i){\n    return (i & 1) == 0;\n}\n"}
{"id": 122437, "name": "Even or odd", "source": "Translate Ruby to Python: print \"evens: \"\np -5.upto(5).select(&:even?)\nprint \"odds: \"\np -5.upto(5).select(&:odd?)\n", "target": ">>> def is_odd(i): return bool(i & 1)\n\n>>> def is_even(i): return not is_odd(i)\n\n>>> [(j, is_odd(j)) for j in range(10)]\n[(0, False), (1, True), (2, False), (3, True), (4, False), (5, True), (6, False), (7, True), (8, False), (9, True)]\n>>> [(j, is_even(j)) for j in range(10)]\n[(0, True), (1, False), (2, True), (3, False), (4, True), (5, False), (6, True), (7, False), (8, True), (9, False)]\n>>>\n"}
{"id": 122438, "name": "Even or odd", "source": "Translate Ruby to Python: print \"evens: \"\np -5.upto(5).select(&:even?)\nprint \"odds: \"\np -5.upto(5).select(&:odd?)\n", "target": ">>> def is_odd(i): return bool(i & 1)\n\n>>> def is_even(i): return not is_odd(i)\n\n>>> [(j, is_odd(j)) for j in range(10)]\n[(0, False), (1, True), (2, False), (3, True), (4, False), (5, True), (6, False), (7, True), (8, False), (9, True)]\n>>> [(j, is_even(j)) for j in range(10)]\n[(0, True), (1, False), (2, True), (3, False), (4, True), (5, False), (6, True), (7, False), (8, True), (9, False)]\n>>>\n"}
{"id": 122728, "name": "Quickselect algorithm", "source": "Translate Ruby to C#: def quickselect(a, k)\n  arr = a.dup \n  loop do\n    pivot = arr.delete_at(rand(arr.size))\n    left, right = arr.partition { |x| x < pivot }\n    if k == left.size\n      return pivot\n    elsif k < left.size\n      arr = left\n    else\n      k = k - left.size - 1\n      arr = right\n    end\n  end\nend\n \nv = [9, 8, 7, 6, 5, 0, 1, 2, 3, 4]\np v.each_index.map { |i| quickselect(v, i) }.to_a\n", "target": "\n\n\n\n\n\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\n\nnamespace QuickSelect\n{\n    internal static class Program\n    {\n        #region Static Members\n\n        private static void Main()\n        {\n            var inputArray = new[] {9, 8, 7, 6, 5, 0, 1, 2, 3, 4};\n            \n            Console.WriteLine( \"Loop quick select 10 times.\" );\n            for( var i = 0 ; i < 10 ; i++ )\n            {\n                Console.Write( inputArray.NthSmallestElement( i ) );\n                if( i < 9 )\n                    Console.Write( \", \" );\n            }\n            Console.WriteLine();\n\n            \n            \n            Console.WriteLine( \"Just sort 10 elements.\" );\n            Console.WriteLine( string.Join( \", \", inputArray.TakeSmallest( 10 ).OrderBy( v => v ).Select( v => v.ToString() ).ToArray() ) );\n            \n            Console.WriteLine( \"Get 4 smallest and sort them.\" );\n            Console.WriteLine( string.Join( \", \", inputArray.TakeSmallest( 4 ).OrderBy( v => v ).Select( v => v.ToString() ).ToArray() ) );\n            Console.WriteLine( \"< Press any key >\" );\n            Console.ReadKey();\n        }\n\n        #endregion\n    }\n\n    internal static class ArrayExtension\n    {\n        #region Static Members\n\n        \n        \n        \n        \n        \n        \n        \n        public static IEnumerable<T> TakeSmallest<T>( this T[] array, int count ) where T : IComparable<T>\n        {\n            if( count < 0 )\n                throw new ArgumentOutOfRangeException( \"count\", \"Count is smaller than 0.\" );\n            if( count == 0 )\n                return new T[0];\n            if( array.Length <= count )\n                return array;\n\n            return QuickSelectSmallest( array, count - 1 ).Take( count );\n        }\n\n        \n        \n        \n        \n        \n        \n        \n        public static T NthSmallestElement<T>( this T[] array, int n ) where T : IComparable<T>\n        {\n            if( n < 0 || n > array.Length - 1 )\n                throw new ArgumentOutOfRangeException( \"n\", n, string.Format( \"n should be between 0 and {0} it was {1}.\", array.Length - 1, n ) );\n            if( array.Length == 0 )\n                throw new ArgumentException( \"Array is empty.\", \"array\" );\n            if( array.Length == 1 )\n                return array[ 0 ];\n\n            return QuickSelectSmallest( array, n )[ n ];\n        }\n\n        \n        \n        \n        \n        \n        \n        \n        private static T[] QuickSelectSmallest<T>( T[] input, int n ) where T : IComparable<T>\n        {\n            \n            \n            var partiallySortedArray = (T[]) input.Clone();\n           \n            \n            var startIndex = 0;\n            var endIndex = input.Length - 1;\n            \n            \n            \n            var pivotIndex = n;\n\n            \n            var r = new Random();\n            while( endIndex > startIndex )\n            {\n                pivotIndex = QuickSelectPartition( partiallySortedArray, startIndex, endIndex, pivotIndex );\n                if( pivotIndex == n )\n                    \n                    break;\n                if( pivotIndex > n )\n                    \n                    endIndex = pivotIndex - 1;\n                else                    \n                    \n                    startIndex = pivotIndex + 1;\n\n                \n                \n                pivotIndex = r.Next( startIndex,  endIndex );\n            }\n            return partiallySortedArray;\n        }\n\n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        private static int QuickSelectPartition<T>( this T[] array, int startIndex, int endIndex, int pivotIndex ) where T : IComparable<T>\n        {\n            var pivotValue = array[ pivotIndex ];\n            \n            array.Swap( pivotIndex, endIndex );\n            for( var i = startIndex ; i < endIndex ; i++ )\n            {\n                if( array[ i ].CompareTo( pivotValue ) > 0 )\n                    continue;\n\n                \n                array.Swap( i, startIndex );\n                \n                startIndex++;\n            }\n            \n            array.Swap( endIndex, startIndex );\n            return startIndex;\n        }\n\n        private static void Swap<T>( this T[] array, int index1, int index2 )\n        {\n            if( index1 == index2 )\n                return;\n\n            var temp = array[ index1 ];\n            array[ index1 ] = array[ index2 ];\n            array[ index2 ] = temp;\n        }\n\n        #endregion\n    }\n}\n"}
{"id": 122730, "name": "Quickselect algorithm", "source": "Translate Ruby to Java: def quickselect(a, k)\n  arr = a.dup \n  loop do\n    pivot = arr.delete_at(rand(arr.size))\n    left, right = arr.partition { |x| x < pivot }\n    if k == left.size\n      return pivot\n    elsif k < left.size\n      arr = left\n    else\n      k = k - left.size - 1\n      arr = right\n    end\n  end\nend\n \nv = [9, 8, 7, 6, 5, 0, 1, 2, 3, 4]\np v.each_index.map { |i| quickselect(v, i) }.to_a\n", "target": "import java.util.Random;\n\npublic class QuickSelect {\n\n\tprivate static <E extends Comparable<? super E>> int partition(E[] arr, int left, int right, int pivot) {\n\t\tE pivotVal = arr[pivot];\n\t\tswap(arr, pivot, right);\n\t\tint storeIndex = left;\n\t\tfor (int i = left; i < right; i++) {\n\t\t\tif (arr[i].compareTo(pivotVal) < 0) {\n\t\t\t\tswap(arr, i, storeIndex);\n\t\t\t\tstoreIndex++;\n\t\t\t}\n\t\t}\n\t\tswap(arr, right, storeIndex);\n\t\treturn storeIndex;\n\t}\n\t\n\tprivate static <E extends Comparable<? super E>> E select(E[] arr, int n) {\n\t\tint left = 0;\n\t\tint right = arr.length - 1;\n\t\tRandom rand = new Random();\n\t\twhile (right >= left) {\n\t\t\tint pivotIndex = partition(arr, left, right, rand.nextInt(right - left + 1) + left);\n\t\t\tif (pivotIndex == n) {\n\t\t\t\treturn arr[pivotIndex];\n\t\t\t} else if (pivotIndex < n) {\n\t\t\t\tleft = pivotIndex + 1;\n\t\t\t} else {\n\t\t\t\tright = pivotIndex - 1;\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\t\n\tprivate static void swap(Object[] arr, int i1, int i2) {\n\t\tif (i1 != i2) {\n\t\t\tObject temp = arr[i1];\n\t\t\tarr[i1] = arr[i2];\n\t\t\tarr[i2] = temp;\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tfor (int i = 0; i < 10; i++) {\n\t\t\tInteger[] input = {9, 8, 7, 6, 5, 0, 1, 2, 3, 4};\n\t\t\tSystem.out.print(select(input, i));\n\t\t\tif (i < 9) System.out.print(\", \");\n\t\t}\n\t\tSystem.out.println();\n\t}\n\n}\n"}
{"id": 122731, "name": "Quickselect algorithm", "source": "Translate Ruby to Python: def quickselect(a, k)\n  arr = a.dup \n  loop do\n    pivot = arr.delete_at(rand(arr.size))\n    left, right = arr.partition { |x| x < pivot }\n    if k == left.size\n      return pivot\n    elsif k < left.size\n      arr = left\n    else\n      k = k - left.size - 1\n      arr = right\n    end\n  end\nend\n \nv = [9, 8, 7, 6, 5, 0, 1, 2, 3, 4]\np v.each_index.map { |i| quickselect(v, i) }.to_a\n", "target": "import random\n\ndef partition(vector, left, right, pivotIndex):\n    pivotValue = vector[pivotIndex]\n    vector[pivotIndex], vector[right] = vector[right], vector[pivotIndex]  \n    storeIndex = left\n    for i in range(left, right):\n        if vector[i] < pivotValue:\n            vector[storeIndex], vector[i] = vector[i], vector[storeIndex]\n            storeIndex += 1\n    vector[right], vector[storeIndex] = vector[storeIndex], vector[right]  \n    return storeIndex\n\ndef _select(vector, left, right, k):\n    \"Returns the k-th smallest, (k >= 0), element of vector within vector[left:right+1] inclusive.\"\n    while True:\n        pivotIndex = random.randint(left, right)     \n        pivotNewIndex = partition(vector, left, right, pivotIndex)\n        pivotDist = pivotNewIndex - left\n        if pivotDist == k:\n            return vector[pivotNewIndex]\n        elif k < pivotDist:\n            right = pivotNewIndex - 1\n        else:\n            k -= pivotDist + 1\n            left = pivotNewIndex + 1\n\ndef select(vector, k, left=None, right=None):\n    \n    if left is None:\n        left = 0\n    lv1 = len(vector) - 1\n    if right is None:\n        right = lv1\n    assert vector and k >= 0, \"Either null vector or k < 0 \"\n    assert 0 <= left <= lv1, \"left is out of range\"\n    assert left <= right <= lv1, \"right is out of range\"\n    return _select(vector, left, right, k)\n\nif __name__ == '__main__':\n    v = [9, 8, 7, 6, 5, 0, 1, 2, 3, 4]\n    print([select(v, i) for i in range(10)])\n"}
{"id": 123112, "name": "Kaprekar numbers", "source": "Translate Ruby to C#: def kaprekar(n, base = 10)\n  return [1, 1, 1, \"\"] if n == 1 \n  return if n*(n-1) % (base-1) != 0     \n  sqr = (n ** 2).to_s(base)\n  (1...sqr.length).each do |i|\n    a = sqr[0 ... i]\n    b = sqr[i .. -1]\n    break if b.delete(\"0\").empty?\n    sum = a.to_i(base) + b.to_i(base)\n    return n.to_s(base), sqr, a, b if sum == n\n  end\n  nil\nend\n\ncount = 0\n1.upto(10_000 - 1) do |i| \n  if result = kaprekar(i)\n    puts \"%4d  %8d  %s + %s\" % result\n    count += 1\n  end\nend\n\n10_000.upto(1_000_000 - 1) {|i| count += 1 if kaprekar(i)}\nputs \"\n\nputs \"\\nbase17 kaprekar numbers under (base10)1,000,000\"\nbase = 17\n1.upto(1_000_000) do |decimal|\n  if result = kaprekar(decimal, base)\n    puts \"%7s  %5s  %9s  %s + %s\" % [decimal, *result]\n  end\nend\n", "target": "using System;\nusing System.Collections.Generic;\n\npublic class KaprekarNumbers {\n\n    \n    \n    \n    public static void Main() {\n        int count = 0;\n\n        foreach ( ulong i in _kaprekarGenerator(999999) ) {\n            Console.WriteLine(i);\n            count++;\n        }\n\n        Console.WriteLine(\"There are {0} Kaprekar numbers less than 1000000.\", count);\n    }\n\n    \n    \n    \n    \n    \n    private static IEnumerable<ulong> _kaprekarGenerator(ulong max) {\n\n        ulong next = 1;\n\n        \n        yield return next;\n\n        for ( next = 2; next <= max; next++ ) {\n\n            ulong square = next * next;\n\n            for ( ulong check = 10; check <= 10000000000000000000; check *= 10 ) {\n                \n                \n\n                \n                if ( square <= check )\n                    break;\n\n                \n                \n                \n                \n                \n\n                ulong r = square % check;\n                ulong q = (square - r) / check;\n\n                if ( r != 0 && q + r == next ) {\n                    yield return next;\n                    break;\n                }\n            }\n\n        }\n\n    }\n\n}\n"}
{"id": 123113, "name": "Kaprekar numbers", "source": "Translate Ruby to C#: def kaprekar(n, base = 10)\n  return [1, 1, 1, \"\"] if n == 1 \n  return if n*(n-1) % (base-1) != 0     \n  sqr = (n ** 2).to_s(base)\n  (1...sqr.length).each do |i|\n    a = sqr[0 ... i]\n    b = sqr[i .. -1]\n    break if b.delete(\"0\").empty?\n    sum = a.to_i(base) + b.to_i(base)\n    return n.to_s(base), sqr, a, b if sum == n\n  end\n  nil\nend\n\ncount = 0\n1.upto(10_000 - 1) do |i| \n  if result = kaprekar(i)\n    puts \"%4d  %8d  %s + %s\" % result\n    count += 1\n  end\nend\n\n10_000.upto(1_000_000 - 1) {|i| count += 1 if kaprekar(i)}\nputs \"\n\nputs \"\\nbase17 kaprekar numbers under (base10)1,000,000\"\nbase = 17\n1.upto(1_000_000) do |decimal|\n  if result = kaprekar(decimal, base)\n    puts \"%7s  %5s  %9s  %s + %s\" % [decimal, *result]\n  end\nend\n", "target": "using System;\nusing System.Collections.Generic;\n\npublic class KaprekarNumbers {\n\n    \n    \n    \n    public static void Main() {\n        int count = 0;\n\n        foreach ( ulong i in _kaprekarGenerator(999999) ) {\n            Console.WriteLine(i);\n            count++;\n        }\n\n        Console.WriteLine(\"There are {0} Kaprekar numbers less than 1000000.\", count);\n    }\n\n    \n    \n    \n    \n    \n    private static IEnumerable<ulong> _kaprekarGenerator(ulong max) {\n\n        ulong next = 1;\n\n        \n        yield return next;\n\n        for ( next = 2; next <= max; next++ ) {\n\n            ulong square = next * next;\n\n            for ( ulong check = 10; check <= 10000000000000000000; check *= 10 ) {\n                \n                \n\n                \n                if ( square <= check )\n                    break;\n\n                \n                \n                \n                \n                \n\n                ulong r = square % check;\n                ulong q = (square - r) / check;\n\n                if ( r != 0 && q + r == next ) {\n                    yield return next;\n                    break;\n                }\n            }\n\n        }\n\n    }\n\n}\n"}
{"id": 123116, "name": "Kaprekar numbers", "source": "Translate Ruby to Java: def kaprekar(n, base = 10)\n  return [1, 1, 1, \"\"] if n == 1 \n  return if n*(n-1) % (base-1) != 0     \n  sqr = (n ** 2).to_s(base)\n  (1...sqr.length).each do |i|\n    a = sqr[0 ... i]\n    b = sqr[i .. -1]\n    break if b.delete(\"0\").empty?\n    sum = a.to_i(base) + b.to_i(base)\n    return n.to_s(base), sqr, a, b if sum == n\n  end\n  nil\nend\n\ncount = 0\n1.upto(10_000 - 1) do |i| \n  if result = kaprekar(i)\n    puts \"%4d  %8d  %s + %s\" % result\n    count += 1\n  end\nend\n\n10_000.upto(1_000_000 - 1) {|i| count += 1 if kaprekar(i)}\nputs \"\n\nputs \"\\nbase17 kaprekar numbers under (base10)1,000,000\"\nbase = 17\n1.upto(1_000_000) do |decimal|\n  if result = kaprekar(decimal, base)\n    puts \"%7s  %5s  %9s  %s + %s\" % [decimal, *result]\n  end\nend\n", "target": "public class Kaprekar {\n    private static String[] splitAt(String str, int idx){\n        String[] ans = new String[2];\n        ans[0] = str.substring(0, idx);\n        if(ans[0].equals(\"\")) ans[0] = \"0\"; \n        ans[1] = str.substring(idx);\n        return ans;\n    }\n        \n    public static void main(String[] args){\n        int count = 0;\n        int base = (args.length > 0) ? Integer.parseInt(args[0]) : 10;\n        for(long i = 1; i <= 1000000; i++){\n            String sqrStr = Long.toString(i * i, base);\n            for(int j = 0; j < sqrStr.length() / 2 + 1; j++){\n                String[] parts = splitAt(sqrStr, j);\n                long firstNum = Long.parseLong(parts[0], base);\n                long secNum = Long.parseLong(parts[1], base);\n                \n                if(secNum == 0) break;\n                if(firstNum + secNum == i){\n                    System.out.println(i + \"\\t\" + Long.toString(i, base) +\n                            \"\\t\" + sqrStr + \"\\t\" + parts[0] + \" + \" + parts[1]);\n                    count++;\n                    break;\n                }\n            }\n        }\n        System.out.println(count + \" Kaprekar numbers < 1000000 (base 10) in base \"+base);\n    }\n}\n"}
{"id": 123117, "name": "Kaprekar numbers", "source": "Translate Ruby to Java: def kaprekar(n, base = 10)\n  return [1, 1, 1, \"\"] if n == 1 \n  return if n*(n-1) % (base-1) != 0     \n  sqr = (n ** 2).to_s(base)\n  (1...sqr.length).each do |i|\n    a = sqr[0 ... i]\n    b = sqr[i .. -1]\n    break if b.delete(\"0\").empty?\n    sum = a.to_i(base) + b.to_i(base)\n    return n.to_s(base), sqr, a, b if sum == n\n  end\n  nil\nend\n\ncount = 0\n1.upto(10_000 - 1) do |i| \n  if result = kaprekar(i)\n    puts \"%4d  %8d  %s + %s\" % result\n    count += 1\n  end\nend\n\n10_000.upto(1_000_000 - 1) {|i| count += 1 if kaprekar(i)}\nputs \"\n\nputs \"\\nbase17 kaprekar numbers under (base10)1,000,000\"\nbase = 17\n1.upto(1_000_000) do |decimal|\n  if result = kaprekar(decimal, base)\n    puts \"%7s  %5s  %9s  %s + %s\" % [decimal, *result]\n  end\nend\n", "target": "public class Kaprekar {\n    private static String[] splitAt(String str, int idx){\n        String[] ans = new String[2];\n        ans[0] = str.substring(0, idx);\n        if(ans[0].equals(\"\")) ans[0] = \"0\"; \n        ans[1] = str.substring(idx);\n        return ans;\n    }\n        \n    public static void main(String[] args){\n        int count = 0;\n        int base = (args.length > 0) ? Integer.parseInt(args[0]) : 10;\n        for(long i = 1; i <= 1000000; i++){\n            String sqrStr = Long.toString(i * i, base);\n            for(int j = 0; j < sqrStr.length() / 2 + 1; j++){\n                String[] parts = splitAt(sqrStr, j);\n                long firstNum = Long.parseLong(parts[0], base);\n                long secNum = Long.parseLong(parts[1], base);\n                \n                if(secNum == 0) break;\n                if(firstNum + secNum == i){\n                    System.out.println(i + \"\\t\" + Long.toString(i, base) +\n                            \"\\t\" + sqrStr + \"\\t\" + parts[0] + \" + \" + parts[1]);\n                    count++;\n                    break;\n                }\n            }\n        }\n        System.out.println(count + \" Kaprekar numbers < 1000000 (base 10) in base \"+base);\n    }\n}\n"}
{"id": 123118, "name": "Kaprekar numbers", "source": "Translate Ruby to Python: def kaprekar(n, base = 10)\n  return [1, 1, 1, \"\"] if n == 1 \n  return if n*(n-1) % (base-1) != 0     \n  sqr = (n ** 2).to_s(base)\n  (1...sqr.length).each do |i|\n    a = sqr[0 ... i]\n    b = sqr[i .. -1]\n    break if b.delete(\"0\").empty?\n    sum = a.to_i(base) + b.to_i(base)\n    return n.to_s(base), sqr, a, b if sum == n\n  end\n  nil\nend\n\ncount = 0\n1.upto(10_000 - 1) do |i| \n  if result = kaprekar(i)\n    puts \"%4d  %8d  %s + %s\" % result\n    count += 1\n  end\nend\n\n10_000.upto(1_000_000 - 1) {|i| count += 1 if kaprekar(i)}\nputs \"\n\nputs \"\\nbase17 kaprekar numbers under (base10)1,000,000\"\nbase = 17\n1.upto(1_000_000) do |decimal|\n  if result = kaprekar(decimal, base)\n    puts \"%7s  %5s  %9s  %s + %s\" % [decimal, *result]\n  end\nend\n", "target": ">>> def k(n):\n\tn2 = str(n**2)\n\tfor i in range(len(n2)):\n\t\ta, b = int(n2[:i] or 0), int(n2[i:])\n\t\tif b and a + b == n:\n\t\t\treturn n\n\t\t\t\n\n\t\t\n>>> [x for x in range(1,10000) if k(x)]\n[1, 9, 45, 55, 99, 297, 703, 999, 2223, 2728, 4879, 4950, 5050, 5292, 7272, 7777, 9999]\n>>> len([x for x in range(1,1000000) if k(x)])\n54\n>>>\n"}
{"id": 123119, "name": "Kaprekar numbers", "source": "Translate Ruby to Python: def kaprekar(n, base = 10)\n  return [1, 1, 1, \"\"] if n == 1 \n  return if n*(n-1) % (base-1) != 0     \n  sqr = (n ** 2).to_s(base)\n  (1...sqr.length).each do |i|\n    a = sqr[0 ... i]\n    b = sqr[i .. -1]\n    break if b.delete(\"0\").empty?\n    sum = a.to_i(base) + b.to_i(base)\n    return n.to_s(base), sqr, a, b if sum == n\n  end\n  nil\nend\n\ncount = 0\n1.upto(10_000 - 1) do |i| \n  if result = kaprekar(i)\n    puts \"%4d  %8d  %s + %s\" % result\n    count += 1\n  end\nend\n\n10_000.upto(1_000_000 - 1) {|i| count += 1 if kaprekar(i)}\nputs \"\n\nputs \"\\nbase17 kaprekar numbers under (base10)1,000,000\"\nbase = 17\n1.upto(1_000_000) do |decimal|\n  if result = kaprekar(decimal, base)\n    puts \"%7s  %5s  %9s  %s + %s\" % [decimal, *result]\n  end\nend\n", "target": ">>> def k(n):\n\tn2 = str(n**2)\n\tfor i in range(len(n2)):\n\t\ta, b = int(n2[:i] or 0), int(n2[i:])\n\t\tif b and a + b == n:\n\t\t\treturn n\n\t\t\t\n\n\t\t\n>>> [x for x in range(1,10000) if k(x)]\n[1, 9, 45, 55, 99, 297, 703, 999, 2223, 2728, 4879, 4950, 5050, 5292, 7272, 7777, 9999]\n>>> len([x for x in range(1,1000000) if k(x)])\n54\n>>>\n"}
{"id": 123354, "name": "Infinity", "source": "Translate Ruby to C#: a = 1.0/0       \na.finite?       \na.infinite?     \n\na = -1/0.0      \na.infinite?     \n\na = Float::MAX  \na.finite?       \na.infinite?     \n", "target": "using System;\n\nclass Program\n{\n    static double PositiveInfinity()\n    {\n        return double.PositiveInfinity;\n    }\n\n    static void Main()\n    {\n        Console.WriteLine(PositiveInfinity());\n    }\n}\n"}
{"id": 123356, "name": "Infinity", "source": "Translate Ruby to Java: a = 1.0/0       \na.finite?       \na.infinite?     \n\na = -1/0.0      \na.infinite?     \n\na = Float::MAX  \na.finite?       \na.infinite?     \n", "target": "double infinity = Double.POSITIVE_INFINITY; \nDouble.isInfinite(infinity); \n"}
{"id": 123357, "name": "Infinity", "source": "Translate Ruby to Python: a = 1.0/0       \na.finite?       \na.infinite?     \n\na = -1/0.0      \na.infinite?     \n\na = Float::MAX  \na.finite?       \na.infinite?     \n", "target": ">>> float('infinity')\ninf\n"}
{"id": 123578, "name": "Sort an integer array", "source": "Translate Ruby to C#: a = [5, 4, 3, 2, 1]\nputs a.sort\n\n\nputs a\n\n\na.sort!\nputs a\n\n", "target": "using System;\nusing System.Collections.Generic;\n\npublic class Program {\n    static void Main() {\n        int[] unsorted = { 6, 2, 7, 8, 3, 1, 10, 5, 4, 9 };\n        Array.Sort(unsorted);\n    }\n}\n"}
{"id": 123580, "name": "Sort an integer array", "source": "Translate Ruby to Java: a = [5, 4, 3, 2, 1]\nputs a.sort\n\n\nputs a\n\n\na.sort!\nputs a\n\n", "target": "import java.util.Arrays;\n\npublic class Example {\n    public static void main(String[] args)\n    {\n        int[] nums = {2,4,3,1,2};\n        Arrays.sort(nums);\n    }\n}\n"}
{"id": 123581, "name": "Sort an integer array", "source": "Translate Ruby to Python: a = [5, 4, 3, 2, 1]\nputs a.sort\n\n\nputs a\n\n\na.sort!\nputs a\n\n", "target": "nums = [2,4,3,1,2]\nnums.sort()\n"}
{"id": 123891, "name": "Base64 decode data", "source": "Translate Ruby to C#: require \"base64\"\n\nencoded_string = \"VG8gZXJyIGlzIGh1bWFuLCBidXQgdG8gcmVhbGx5IGZvdWwgdGhpbmdzIHVwIHlvdSBuZWVkIGEgY29tcHV0ZXIuCiAgICAtLSBQYXVsIFIuIEVocmxpY2g=\"\n\ndecoded_string = Base64.decode_string(encoded_string)\nputs decoded_string\n", "target": "using System;\nusing System.Text;\n\nnamespace Base64DecodeData {\n    class Program {\n        static void Main(string[] args) {\n            var data = \"VG8gZXJyIGlzIGh1bWFuLCBidXQgdG8gcmVhbGx5IGZvdWwgdGhpbmdzIHVwIHlvdSBuZWVkIGEgY29tcHV0ZXIuCiAgICAtLSBQYXVsIFIuIEVocmxpY2g=\";\n            Console.WriteLine(data);\n            Console.WriteLine();\n\n            var decoded = Encoding.ASCII.GetString(Convert.FromBase64String(data));\n            Console.WriteLine(decoded);\n        }\n    }\n}\n"}
{"id": 123892, "name": "Base64 decode data", "source": "Translate Ruby to C#: require \"base64\"\n\nencoded_string = \"VG8gZXJyIGlzIGh1bWFuLCBidXQgdG8gcmVhbGx5IGZvdWwgdGhpbmdzIHVwIHlvdSBuZWVkIGEgY29tcHV0ZXIuCiAgICAtLSBQYXVsIFIuIEVocmxpY2g=\"\n\ndecoded_string = Base64.decode_string(encoded_string)\nputs decoded_string\n", "target": "using System;\nusing System.Text;\n\nnamespace Base64DecodeData {\n    class Program {\n        static void Main(string[] args) {\n            var data = \"VG8gZXJyIGlzIGh1bWFuLCBidXQgdG8gcmVhbGx5IGZvdWwgdGhpbmdzIHVwIHlvdSBuZWVkIGEgY29tcHV0ZXIuCiAgICAtLSBQYXVsIFIuIEVocmxpY2g=\";\n            Console.WriteLine(data);\n            Console.WriteLine();\n\n            var decoded = Encoding.ASCII.GetString(Convert.FromBase64String(data));\n            Console.WriteLine(decoded);\n        }\n    }\n}\n"}
{"id": 123895, "name": "Base64 decode data", "source": "Translate Ruby to Java: require \"base64\"\n\nencoded_string = \"VG8gZXJyIGlzIGh1bWFuLCBidXQgdG8gcmVhbGx5IGZvdWwgdGhpbmdzIHVwIHlvdSBuZWVkIGEgY29tcHV0ZXIuCiAgICAtLSBQYXVsIFIuIEVocmxpY2g=\"\n\ndecoded_string = Base64.decode_string(encoded_string)\nputs decoded_string\n", "target": "\nmodule Base64\n    {\n    @Inject Console console;\n    void run()\n        {\n        String orig  = \\|VG8gZXJyIGlzIGh1bWFuLCBidXQgdG8gcmVhbGx5IGZvdWwgdGhpbmdzIHVwIH\\\n                        |lvdSBuZWVkIGEgY29tcHV0ZXIuCiAgICAtLSBQYXVsIFIuIEVocmxpY2g=\n                       ;\n        Byte[] bytes = decode(orig);\n        String text  = encode(bytes, pad=True);\n        assert text == orig;\n        console.print($\"base64={text}, bytes={bytes}\");\n        }\n\n    static Byte[] read(Iterator<Char> stream)\n        {\n        Int    charLen    = 0;\n        charLen := stream.knownSize();\n        Byte[] byteBuf    = new Byte[](charLen * 6 / 8);\n        Byte   prevBits   = 0;\n        Int    prevCount  = 0;\n        while (Char ch := stream.next())\n            {\n            if (Byte newBits := isBase64(ch, assertTrash=True))\n                {\n                if (prevCount == 0)\n                    {\n                    prevBits  = newBits;\n                    prevCount = 6;\n                    }\n                else\n                    {\n                    byteBuf.add((prevBits << 8-prevCount) | (newBits >> prevCount-2));\n                    prevBits   = newBits;\n                    prevCount -= 2;\n                    }\n                }\n            }\n\n        return byteBuf.freeze(True);\n        }\n\n    static void write(Byte[] value, Appender<Char> stream, Boolean pad=False, Int? lineLength=Null)\n        {\n        lineLength ?:= Int.maxvalue;\n\n        Int    lineOffset = 0;\n        Int    totalChars = 0;\n        Byte   prevByte   = 0;\n        Int    prevCount  = 0;          \n        Int    byteOffset = 0;\n        Int    byteLength = value.size;\n        while (True)\n            {\n            \n            Byte sixBits;\n            if (byteOffset >= byteLength)\n                {\n                if (prevCount == 0)\n                    {\n                    break;\n                    }\n                sixBits   = prevByte << 6 - prevCount;\n                prevCount = 0;\n                }\n            else if (prevCount == 6)\n                {\n                sixBits   = prevByte << 6 - prevCount;\n                prevCount = 0;\n                }\n            else\n                {\n                Byte nextByte = value[byteOffset++];\n                sixBits    = (prevByte << 6 - prevCount) | (nextByte >> 2 + prevCount);\n                prevByte   = nextByte;\n                prevCount += 2;\n                }\n\n            if (lineOffset >= lineLength)\n                {\n                stream.add('\\r').add('\\n');\n                totalChars += lineOffset;\n                lineOffset  = 0;\n                }\n\n            stream.add(base64(sixBits & 0b111111));\n            ++lineOffset;\n            }\n\n        if (pad)\n            {\n            totalChars += lineOffset;\n            for (Int i = 0, Int padCount = 4 - (totalChars & 0b11) & 0b11; i < padCount; ++i)\n                {\n                if (lineOffset >= lineLength)\n                    {\n                    stream.add('\\r').add('\\n');\n                    lineOffset  = 0;\n                    }\n\n                stream.add('=');\n                ++lineOffset;\n                }\n            }\n        }\n\n    static String encode(Byte[] value, Boolean pad=False, Int? lineLength=Null)\n        {\n        \n        Int byteLen = value.size;\n        Int charLen = (byteLen * 8 + 5) / 6;\n        if (pad)\n            {\n            charLen += 4 - (charLen & 0b11) & 0b11;\n            }\n        if (lineLength != Null)\n            {\n            charLen += ((charLen + lineLength - 1) / lineLength - 1).maxOf(0) * 2;\n            }\n\n        StringBuffer charBuf = new StringBuffer(charLen);\n        write(value, charBuf, pad, lineLength);\n        return charBuf.toString();\n        }\n\n    static Byte[] decode(String text)\n        {\n        Int    charLen    = text.size;\n        Byte[] byteBuf    = new Byte[](charLen * 6 / 8);\n        Byte   prevBits   = 0;\n        Int    prevCount  = 0;\n        for (Int offset = 0; offset < charLen; ++offset)\n            {\n            if (Byte newBits := isBase64(text[offset], assertTrash=True))\n                {\n                if (prevCount == 0)\n                    {\n                    prevBits  = newBits;\n                    prevCount = 6;\n                    }\n                else\n                    {\n                    byteBuf.add((prevBits << 8-prevCount) | (newBits >> prevCount-2));\n                    prevBits   = newBits;\n                    prevCount -= 2;\n                    }\n                }\n            }\n\n        return byteBuf.freeze(True);\n        }\n\n    \n    static Byte valOf(Char ch)\n        {\n        return switch (ch)\n            {\n            case 'A'..'Z': (ch - 'A').toUInt8();\n            case 'a'..'z': (ch - 'a').toUInt8() + 26;\n            case '0'..'9': (ch - '0').toUInt8() + 52;\n            case '+': 62;\n            case '/': 63;\n\n            case '=':        assert as $\"Unexpected padding character in Base64: {ch.quoted()}\";\n            case '\\r', '\\n': assert as $\"Unexpected newline character in Base64: {ch.quoted()}\";\n            default:         assert as $\"Invalid Base64 character: {ch.quoted()}\";\n            };\n        }\n\n    \n    static conditional Byte isBase64(Char ch, Boolean assertTrash=False)\n        {\n        return switch (ch)\n            {\n            case 'A'..'Z': (True, (ch - 'A').toUInt8());\n            case 'a'..'z': (True, (ch - 'a').toUInt8() + 26);\n            case '0'..'9': (True, (ch - '0').toUInt8() + 52);\n            case '+': (True, 62);\n            case '/': (True, 63);\n\n            case '=':           \n            case '\\r', '\\n':    \n                False;\n\n            default: assertTrash ? assert as $\"Invalid Base64 character: {ch.quoted()}\" : False;\n            };\n        }\n\n    \n    static Char base64(Byte byte)\n        {\n        return switch (byte)\n            {\n            case  0 ..< 26: 'A'+byte;\n            case 26 ..< 52: 'a'+(byte-26);\n            case 52 ..< 62: '0'+(byte-52);\n            case 62: '+';\n            case 63: '/';\n            default: assert:bounds as $\"byte={byte}\";\n            };\n        }\n    }\n"}
{"id": 123896, "name": "Base64 decode data", "source": "Translate Ruby to Java: require \"base64\"\n\nencoded_string = \"VG8gZXJyIGlzIGh1bWFuLCBidXQgdG8gcmVhbGx5IGZvdWwgdGhpbmdzIHVwIHlvdSBuZWVkIGEgY29tcHV0ZXIuCiAgICAtLSBQYXVsIFIuIEVocmxpY2g=\"\n\ndecoded_string = Base64.decode_string(encoded_string)\nputs decoded_string\n", "target": "\nmodule Base64\n    {\n    @Inject Console console;\n    void run()\n        {\n        String orig  = \\|VG8gZXJyIGlzIGh1bWFuLCBidXQgdG8gcmVhbGx5IGZvdWwgdGhpbmdzIHVwIH\\\n                        |lvdSBuZWVkIGEgY29tcHV0ZXIuCiAgICAtLSBQYXVsIFIuIEVocmxpY2g=\n                       ;\n        Byte[] bytes = decode(orig);\n        String text  = encode(bytes, pad=True);\n        assert text == orig;\n        console.print($\"base64={text}, bytes={bytes}\");\n        }\n\n    static Byte[] read(Iterator<Char> stream)\n        {\n        Int    charLen    = 0;\n        charLen := stream.knownSize();\n        Byte[] byteBuf    = new Byte[](charLen * 6 / 8);\n        Byte   prevBits   = 0;\n        Int    prevCount  = 0;\n        while (Char ch := stream.next())\n            {\n            if (Byte newBits := isBase64(ch, assertTrash=True))\n                {\n                if (prevCount == 0)\n                    {\n                    prevBits  = newBits;\n                    prevCount = 6;\n                    }\n                else\n                    {\n                    byteBuf.add((prevBits << 8-prevCount) | (newBits >> prevCount-2));\n                    prevBits   = newBits;\n                    prevCount -= 2;\n                    }\n                }\n            }\n\n        return byteBuf.freeze(True);\n        }\n\n    static void write(Byte[] value, Appender<Char> stream, Boolean pad=False, Int? lineLength=Null)\n        {\n        lineLength ?:= Int.maxvalue;\n\n        Int    lineOffset = 0;\n        Int    totalChars = 0;\n        Byte   prevByte   = 0;\n        Int    prevCount  = 0;          \n        Int    byteOffset = 0;\n        Int    byteLength = value.size;\n        while (True)\n            {\n            \n            Byte sixBits;\n            if (byteOffset >= byteLength)\n                {\n                if (prevCount == 0)\n                    {\n                    break;\n                    }\n                sixBits   = prevByte << 6 - prevCount;\n                prevCount = 0;\n                }\n            else if (prevCount == 6)\n                {\n                sixBits   = prevByte << 6 - prevCount;\n                prevCount = 0;\n                }\n            else\n                {\n                Byte nextByte = value[byteOffset++];\n                sixBits    = (prevByte << 6 - prevCount) | (nextByte >> 2 + prevCount);\n                prevByte   = nextByte;\n                prevCount += 2;\n                }\n\n            if (lineOffset >= lineLength)\n                {\n                stream.add('\\r').add('\\n');\n                totalChars += lineOffset;\n                lineOffset  = 0;\n                }\n\n            stream.add(base64(sixBits & 0b111111));\n            ++lineOffset;\n            }\n\n        if (pad)\n            {\n            totalChars += lineOffset;\n            for (Int i = 0, Int padCount = 4 - (totalChars & 0b11) & 0b11; i < padCount; ++i)\n                {\n                if (lineOffset >= lineLength)\n                    {\n                    stream.add('\\r').add('\\n');\n                    lineOffset  = 0;\n                    }\n\n                stream.add('=');\n                ++lineOffset;\n                }\n            }\n        }\n\n    static String encode(Byte[] value, Boolean pad=False, Int? lineLength=Null)\n        {\n        \n        Int byteLen = value.size;\n        Int charLen = (byteLen * 8 + 5) / 6;\n        if (pad)\n            {\n            charLen += 4 - (charLen & 0b11) & 0b11;\n            }\n        if (lineLength != Null)\n            {\n            charLen += ((charLen + lineLength - 1) / lineLength - 1).maxOf(0) * 2;\n            }\n\n        StringBuffer charBuf = new StringBuffer(charLen);\n        write(value, charBuf, pad, lineLength);\n        return charBuf.toString();\n        }\n\n    static Byte[] decode(String text)\n        {\n        Int    charLen    = text.size;\n        Byte[] byteBuf    = new Byte[](charLen * 6 / 8);\n        Byte   prevBits   = 0;\n        Int    prevCount  = 0;\n        for (Int offset = 0; offset < charLen; ++offset)\n            {\n            if (Byte newBits := isBase64(text[offset], assertTrash=True))\n                {\n                if (prevCount == 0)\n                    {\n                    prevBits  = newBits;\n                    prevCount = 6;\n                    }\n                else\n                    {\n                    byteBuf.add((prevBits << 8-prevCount) | (newBits >> prevCount-2));\n                    prevBits   = newBits;\n                    prevCount -= 2;\n                    }\n                }\n            }\n\n        return byteBuf.freeze(True);\n        }\n\n    \n    static Byte valOf(Char ch)\n        {\n        return switch (ch)\n            {\n            case 'A'..'Z': (ch - 'A').toUInt8();\n            case 'a'..'z': (ch - 'a').toUInt8() + 26;\n            case '0'..'9': (ch - '0').toUInt8() + 52;\n            case '+': 62;\n            case '/': 63;\n\n            case '=':        assert as $\"Unexpected padding character in Base64: {ch.quoted()}\";\n            case '\\r', '\\n': assert as $\"Unexpected newline character in Base64: {ch.quoted()}\";\n            default:         assert as $\"Invalid Base64 character: {ch.quoted()}\";\n            };\n        }\n\n    \n    static conditional Byte isBase64(Char ch, Boolean assertTrash=False)\n        {\n        return switch (ch)\n            {\n            case 'A'..'Z': (True, (ch - 'A').toUInt8());\n            case 'a'..'z': (True, (ch - 'a').toUInt8() + 26);\n            case '0'..'9': (True, (ch - '0').toUInt8() + 52);\n            case '+': (True, 62);\n            case '/': (True, 63);\n\n            case '=':           \n            case '\\r', '\\n':    \n                False;\n\n            default: assertTrash ? assert as $\"Invalid Base64 character: {ch.quoted()}\" : False;\n            };\n        }\n\n    \n    static Char base64(Byte byte)\n        {\n        return switch (byte)\n            {\n            case  0 ..< 26: 'A'+byte;\n            case 26 ..< 52: 'a'+(byte-26);\n            case 52 ..< 62: '0'+(byte-52);\n            case 62: '+';\n            case 63: '/';\n            default: assert:bounds as $\"byte={byte}\";\n            };\n        }\n    }\n"}
{"id": 123897, "name": "Base64 decode data", "source": "Translate Ruby to Python: require \"base64\"\n\nencoded_string = \"VG8gZXJyIGlzIGh1bWFuLCBidXQgdG8gcmVhbGx5IGZvdWwgdGhpbmdzIHVwIHlvdSBuZWVkIGEgY29tcHV0ZXIuCiAgICAtLSBQYXVsIFIuIEVocmxpY2g=\"\n\ndecoded_string = Base64.decode_string(encoded_string)\nputs decoded_string\n", "target": "import base64\ndata = 'VG8gZXJyIGlzIGh1bWFuLCBidXQgdG8gcmVhbGx5IGZvdWwgdGhpbmdzIHVwIHlvdSBuZWVkIGEgY29tcHV0ZXIuCiAgICAtLSBQYXVsIFIuIEVocmxpY2g='\nprint(base64.b64decode(data).decode('utf-8'))\n"}
{"id": 123898, "name": "Base64 decode data", "source": "Translate Ruby to Python: require \"base64\"\n\nencoded_string = \"VG8gZXJyIGlzIGh1bWFuLCBidXQgdG8gcmVhbGx5IGZvdWwgdGhpbmdzIHVwIHlvdSBuZWVkIGEgY29tcHV0ZXIuCiAgICAtLSBQYXVsIFIuIEVocmxpY2g=\"\n\ndecoded_string = Base64.decode_string(encoded_string)\nputs decoded_string\n", "target": "import base64\ndata = 'VG8gZXJyIGlzIGh1bWFuLCBidXQgdG8gcmVhbGx5IGZvdWwgdGhpbmdzIHVwIHlvdSBuZWVkIGEgY29tcHV0ZXIuCiAgICAtLSBQYXVsIFIuIEVocmxpY2g='\nprint(base64.b64decode(data).decode('utf-8'))\n"}
{"id": 124095, "name": "Substitution cipher", "source": "Translate Ruby to C#: Alphabet = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\"\nKey      = \"VsciBjedgrzyHalvXZKtUPumGfIwJxqOCFRApnDhQWobLkESYMTN\"\n\ndef encrypt(str) = str.tr(Alphabet, Key)\ndef decrypt(str) = str.tr(Key, Alphabet)\n  \nstr = 'All is lost, he thought. Everything is ruined. It\u2019s ten past three.'\np encrypted =   encrypt(str) \np decrypt(encrypted)\n", "target": "using System;\nusing System.IO;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Threading.Tasks;\n\nnamespace SubstitutionCipherProject\n{\n    class SubstitutionCipher\n    {\n        static void Main(string[] args)\n        {\n            doEncDec(\"e:\\\\source.txt\", \"enc.txt\", true);\n            doEncDec(\"enc.txt\", \"dec.txt\", false);\n            Console.WriteLine(\"Done\");\n            Console.ReadKey();\n        }\n        static void doEncDec(String source, String target, bool IsEncrypt)\n        {\n            ITransform trans;\n\n            if (IsEncrypt)\n                trans = new Encrypt();\n            else\n                trans = new Decrypt();\n\n            FileInfo sfi = new FileInfo(source);\n            FileStream sstream = sfi.OpenRead();\n            StreamReader sr = new StreamReader(sstream);\n\n            FileInfo tfi = new FileInfo(target);\n            FileStream tstream = tfi.OpenWrite();\n            TransformWriter tw = new TransformWriter(tstream, trans);\n            StreamWriter sw = new StreamWriter(tw);\n\n            String line;\n            while ((line = sr.ReadLine()) != null)\n                sw.WriteLine(line);\n            sw.Close();\n        }\n    }\n    public interface ITransform\n    {\n        byte transform(byte ch);\n    }\n    public class Encrypt : ITransform\n    {\n        const String str = \"xyfagchbimpourvnqsdewtkjzl\";\n        byte ITransform.transform(byte ch)\n        {\n            if (char.IsLower((char)ch))\n                ch = (byte)str[ch - (byte)'a'];\n            return ch;\n        }\n    }\n    class Decrypt : ITransform\n    {\n        const String str = \"xyfagchbimpourvnqsdewtkjzl\";\n        byte ITransform.transform(byte ch)\n        {\n            if (char.IsLower((char)ch))\n                ch = (byte)(str.IndexOf((char)ch) + 'a');\n            return ch;\n        }\n    }\n    class TransformWriter : Stream, IDisposable\n    {\n        private Stream outs;\n        private ITransform trans;\n\n        public TransformWriter(Stream s, ITransform t)\n        {\n            this.outs = s;\n            this.trans = t;\n        }\n\n        public override bool CanRead\n        {\n            get { return false; }\n        }\n\n        public override bool CanSeek\n        {\n            get { return false; }\n        }\n\n        public override bool CanWrite\n        {\n            get { return true; }\n        }\n        public override void Flush()\n        {\n            outs.Flush();\n        }\n\n        public override long Length\n        {\n            get { return outs.Length; }\n        }\n        public override long Position\n        {\n            get\n            {\n                return outs.Position;\n            }\n            set\n            {\n                outs.Position = value;\n            }\n        }\n        public override long Seek(long offset, SeekOrigin origin)\n        {\n            return outs.Seek(offset, origin);\n        }\n\n        public override void SetLength(long value)\n        {\n            outs.SetLength(value);\n        }\n\n        public override void Write(byte[] buf, int off, int len)\n        {\n            for (int i = off; i < off + len; i++)\n                buf[i] = trans.transform(buf[i]);\n            outs.Write(buf, off, len);\n        }\n\n        void IDisposable.Dispose()\n        {\n            outs.Dispose();\n        }\n\n        public override void Close()\n        {\n            outs.Close();\n        }\n\n        public override int Read(byte[] cbuf, int off, int count)\n        {\n            return outs.Read(cbuf, off, count);\n        }\n    }\n}\n"}
{"id": 124097, "name": "Substitution cipher", "source": "Translate Ruby to Java: Alphabet = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\"\nKey      = \"VsciBjedgrzyHalvXZKtUPumGfIwJxqOCFRApnDhQWobLkESYMTN\"\n\ndef encrypt(str) = str.tr(Alphabet, Key)\ndef decrypt(str) = str.tr(Key, Alphabet)\n  \nstr = 'All is lost, he thought. Everything is ruined. It\u2019s ten past three.'\np encrypted =   encrypt(str) \np decrypt(encrypted)\n", "target": "public class SubstitutionCipher {\n\n    final static String key = \"]kYV}(!7P$n5_0i R:?jOWtF/=-pe'AD&@r6%ZXs\\\"v*N\"\n            + \"[#wSl9zq2^+g;LoB`aGh{3.HIu4fbK)mU8|dMET><,Qc\\\\C1yxJ\";\n\n    static String text = \"Here we have to do is there will be a input/source \"\n            + \"file in which we are going to Encrypt the file by replacing every \"\n            + \"upper/lower case alphabets of the source file with another \"\n            + \"predetermined upper/lower case alphabets or symbols and save \"\n            + \"it into another output/encrypted file and then again convert \"\n            + \"that output/encrypted file into original/decrypted file. This \"\n            + \"type of Encryption/Decryption scheme is often called a \"\n            + \"Substitution Cipher.\";\n\n    public static void main(String[] args) {\n        String enc = encode(text);\n        System.out.println(\"Encoded: \" + enc);\n        System.out.println(\"\\nDecoded: \" + decode(enc));\n    }\n\n    static String encode(String s) {\n        StringBuilder sb = new StringBuilder(s.length());\n\n        for (char c : s.toCharArray())\n            sb.append(key.charAt((int) c - 32));\n\n        return sb.toString();\n    }\n\n    static String decode(String s) {\n        StringBuilder sb = new StringBuilder(s.length());\n\n        for (char c : s.toCharArray())\n            sb.append((char) (key.indexOf((int) c) + 32));\n\n        return sb.toString();\n    }\n}\n"}
{"id": 124098, "name": "Substitution cipher", "source": "Translate Ruby to Python: Alphabet = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\"\nKey      = \"VsciBjedgrzyHalvXZKtUPumGfIwJxqOCFRApnDhQWobLkESYMTN\"\n\ndef encrypt(str) = str.tr(Alphabet, Key)\ndef decrypt(str) = str.tr(Key, Alphabet)\n  \nstr = 'All is lost, he thought. Everything is ruined. It\u2019s ten past three.'\np encrypted =   encrypt(str) \np decrypt(encrypted)\n", "target": "from string import printable\nimport random\n\nEXAMPLE_KEY = ''.join(sorted(printable, key=lambda _:random.random()))\n\ndef encode(plaintext, key):\n    return ''.join(key[printable.index(char)] for char in plaintext)\n\ndef decode(plaintext, key):\n    return ''.join(printable[key.index(char)] for char in plaintext)\n\noriginal = \"A simple example.\"\nencoded = encode(original, EXAMPLE_KEY)\ndecoded = decode(encoded, EXAMPLE_KEY)\nprint(.format(\n    original, EXAMPLE_KEY, encoded, decoded))\n"}
{"id": 124441, "name": "Cartesian product of two or more lists", "source": "Translate Ruby to C#: p [1, 2].product([3, 4]) \np [3, 4].product([1, 2])\np [1, 2].product([])\np [].product([1, 2]) \np [1776, 1789].product([7, 12], [4, 14, 23], [0, 1])\np [1, 2, 3].product([30], [500, 100]) \np [1, 2, 3].product([], [500, 100])\n", "target": "using System;\npublic class Program\n{\n    public static void Main()\n    {\n        int[] empty = new int[0];\n        int[] list1 = { 1, 2 };\n        int[] list2 = { 3, 4 };\n        int[] list3 = { 1776, 1789 };\n        int[] list4 = { 7, 12 };\n        int[] list5 = { 4, 14, 23 };\n        int[] list6 = { 0, 1 };\n        int[] list7 = { 1, 2, 3 };\n        int[] list8 = { 30 };\n        int[] list9 = { 500, 100 };\n        \n        foreach (var sequenceList in new [] {\n            new [] { list1, list2 },\n            new [] { list2, list1 },\n            new [] { list1, empty },\n            new [] { empty, list1 },\n            new [] { list3, list4, list5, list6 },\n            new [] { list7, list8, list9 },\n            new [] { list7, empty, list9 }\n        }) {\n            var cart = sequenceList.CartesianProduct()\n                .Select(tuple => $\"({string.Join(\", \", tuple)})\");\n            Console.WriteLine($\"{{{string.Join(\", \", cart)}}}\");\n        }\n    }\n}\n\npublic static class Extensions\n{\n    public static IEnumerable<IEnumerable<T>> CartesianProduct<T>(this IEnumerable<IEnumerable<T>> sequences) {\n        IEnumerable<IEnumerable<T>> emptyProduct = new[] { Enumerable.Empty<T>() };\n        return sequences.Aggregate(\n            emptyProduct,\n            (accumulator, sequence) =>\n            from acc in accumulator\n            from item in sequence\n            select acc.Concat(new [] { item }));\n    }\n}\n"}
{"id": 124442, "name": "Cartesian product of two or more lists", "source": "Translate Ruby to C#: p [1, 2].product([3, 4]) \np [3, 4].product([1, 2])\np [1, 2].product([])\np [].product([1, 2]) \np [1776, 1789].product([7, 12], [4, 14, 23], [0, 1])\np [1, 2, 3].product([30], [500, 100]) \np [1, 2, 3].product([], [500, 100])\n", "target": "using System;\npublic class Program\n{\n    public static void Main()\n    {\n        int[] empty = new int[0];\n        int[] list1 = { 1, 2 };\n        int[] list2 = { 3, 4 };\n        int[] list3 = { 1776, 1789 };\n        int[] list4 = { 7, 12 };\n        int[] list5 = { 4, 14, 23 };\n        int[] list6 = { 0, 1 };\n        int[] list7 = { 1, 2, 3 };\n        int[] list8 = { 30 };\n        int[] list9 = { 500, 100 };\n        \n        foreach (var sequenceList in new [] {\n            new [] { list1, list2 },\n            new [] { list2, list1 },\n            new [] { list1, empty },\n            new [] { empty, list1 },\n            new [] { list3, list4, list5, list6 },\n            new [] { list7, list8, list9 },\n            new [] { list7, empty, list9 }\n        }) {\n            var cart = sequenceList.CartesianProduct()\n                .Select(tuple => $\"({string.Join(\", \", tuple)})\");\n            Console.WriteLine($\"{{{string.Join(\", \", cart)}}}\");\n        }\n    }\n}\n\npublic static class Extensions\n{\n    public static IEnumerable<IEnumerable<T>> CartesianProduct<T>(this IEnumerable<IEnumerable<T>> sequences) {\n        IEnumerable<IEnumerable<T>> emptyProduct = new[] { Enumerable.Empty<T>() };\n        return sequences.Aggregate(\n            emptyProduct,\n            (accumulator, sequence) =>\n            from acc in accumulator\n            from item in sequence\n            select acc.Concat(new [] { item }));\n    }\n}\n"}
{"id": 124445, "name": "Cartesian product of two or more lists", "source": "Translate Ruby to Java: p [1, 2].product([3, 4]) \np [3, 4].product([1, 2])\np [1, 2].product([])\np [].product([1, 2]) \np [1776, 1789].product([7, 12], [4, 14, 23], [0, 1])\np [1, 2, 3].product([30], [500, 100]) \np [1, 2, 3].product([], [500, 100])\n", "target": "import static java.util.Arrays.asList;\nimport static java.util.Collections.emptyList;\nimport static java.util.Optional.of;\nimport static java.util.stream.Collectors.toList;\n\nimport java.util.List;\n\npublic class CartesianProduct {\n\n    public List<?> product(List<?>... a) {\n        if (a.length >= 2) {\n            List<?> product = a[0];\n            for (int i = 1; i < a.length; i++) {\n                product = product(product, a[i]);\n            }\n            return product;\n        }\n\n        return emptyList();\n    }\n\n    private <A, B> List<?> product(List<A> a, List<B> b) {\n        return of(a.stream()\n                .map(e1 -> of(b.stream().map(e2 -> asList(e1, e2)).collect(toList())).orElse(emptyList()))\n                .flatMap(List::stream)\n                .collect(toList())).orElse(emptyList());\n    }\n}\n"}
{"id": 124446, "name": "Cartesian product of two or more lists", "source": "Translate Ruby to Java: p [1, 2].product([3, 4]) \np [3, 4].product([1, 2])\np [1, 2].product([])\np [].product([1, 2]) \np [1776, 1789].product([7, 12], [4, 14, 23], [0, 1])\np [1, 2, 3].product([30], [500, 100]) \np [1, 2, 3].product([], [500, 100])\n", "target": "import static java.util.Arrays.asList;\nimport static java.util.Collections.emptyList;\nimport static java.util.Optional.of;\nimport static java.util.stream.Collectors.toList;\n\nimport java.util.List;\n\npublic class CartesianProduct {\n\n    public List<?> product(List<?>... a) {\n        if (a.length >= 2) {\n            List<?> product = a[0];\n            for (int i = 1; i < a.length; i++) {\n                product = product(product, a[i]);\n            }\n            return product;\n        }\n\n        return emptyList();\n    }\n\n    private <A, B> List<?> product(List<A> a, List<B> b) {\n        return of(a.stream()\n                .map(e1 -> of(b.stream().map(e2 -> asList(e1, e2)).collect(toList())).orElse(emptyList()))\n                .flatMap(List::stream)\n                .collect(toList())).orElse(emptyList());\n    }\n}\n"}
{"id": 124447, "name": "Cartesian product of two or more lists", "source": "Translate Ruby to Python: p [1, 2].product([3, 4]) \np [3, 4].product([1, 2])\np [1, 2].product([])\np [].product([1, 2]) \np [1776, 1789].product([7, 12], [4, 14, 23], [0, 1])\np [1, 2, 3].product([30], [500, 100]) \np [1, 2, 3].product([], [500, 100])\n", "target": "import itertools\n\ndef cp(lsts):\n    return list(itertools.product(*lsts))\n\nif __name__ == '__main__':\n    from pprint import pprint as pp\n    \n    for lists in [[[1,2],[3,4]], [[3,4],[1,2]], [[], [1, 2]], [[1, 2], []],\n                  ((1776, 1789),  (7, 12), (4, 14, 23), (0, 1)),\n                  ((1, 2, 3), (30,), (500, 100)),\n                  ((1, 2, 3), (), (500, 100))]:\n        print(lists, '=>')\n        pp(cp(lists), indent=2)\n"}
{"id": 124448, "name": "Cartesian product of two or more lists", "source": "Translate Ruby to Python: p [1, 2].product([3, 4]) \np [3, 4].product([1, 2])\np [1, 2].product([])\np [].product([1, 2]) \np [1776, 1789].product([7, 12], [4, 14, 23], [0, 1])\np [1, 2, 3].product([30], [500, 100]) \np [1, 2, 3].product([], [500, 100])\n", "target": "import itertools\n\ndef cp(lsts):\n    return list(itertools.product(*lsts))\n\nif __name__ == '__main__':\n    from pprint import pprint as pp\n    \n    for lists in [[[1,2],[3,4]], [[3,4],[1,2]], [[], [1, 2]], [[1, 2], []],\n                  ((1776, 1789),  (7, 12), (4, 14, 23), (0, 1)),\n                  ((1, 2, 3), (30,), (500, 100)),\n                  ((1, 2, 3), (), (500, 100))]:\n        print(lists, '=>')\n        pp(cp(lists), indent=2)\n"}
{"id": 124587, "name": "Parameterized SQL statement", "source": "Translate Ruby to C#: require 'sqlite3'\n\ndb = SQLite3::Database.new(\":memory:\")\n\n\ndb.execute('create temp table players (name, score, active, jerseyNum)')\ndb.execute('insert into players values (\"name\",0,\"false\",99)')\ndb.execute('insert into players values (\"name\",0,\"false\",100)')\ndb.execute('insert into players values (\"name\",0,\"false\",101)')\n\n\n\n\ndb.execute('update players set name=?, score=?, active=? where jerseyNum=?', 'Smith, Steve', 42, true, 99)\n\n\ndb.execute('update players set name=:name, score=:score, active=:active where jerseyNum=:num',\n    :num => 100,\n    :name => 'John Doe',\n    :active => false,\n    :score => -1\n)\n\n\nstmt = db.prepare('update players set name=?4, score=?3, active=?2 where jerseyNum=?1')\nstmt.bind_param(1, 101)\nstmt.bind_param(2, true)\nstmt.bind_param(3, 3)\nstmt.bind_param(4, \"Robert'; DROP TABLE players--\")\nstmt.execute\n\n\ndb.execute2('select * from players') {|row| p row}\n", "target": "using System.Data.Sql;\nusing System.Data.SqlClient;\n\nnamespace ConsoleApplication1\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            using var tConn = new SqlConnection(\"ConnectionString\");\n\n            using var tCommand = tConn.CreateCommand();\n            tCommand.CommandText = \"UPDATE players SET name = @name, score = @score, active = @active WHERE jerseyNum = @jerseyNum\";\n\n            tCommand.Parameters.Add(new SqlParameter(\"@name\", System.Data.SqlDbType.VarChar).Value = \"Smith, Steve\");\n            tCommand.Parameters.Add(new SqlParameter(\"@score\", System.Data.SqlDbType.Int).Value = \"42\");\n            tCommand.Parameters.Add(new SqlParameter(\"@active\", System.Data.SqlDbType.Bit).Value = true);\n            tCommand.Parameters.Add(new SqlParameter(\"@jerseyNum\", System.Data.SqlDbType.Int).Value = \"99\");\n\n            tCommand.ExecuteNonQuery();\n        }\n    }\n}\n"}
{"id": 124589, "name": "Parameterized SQL statement", "source": "Translate Ruby to Java: require 'sqlite3'\n\ndb = SQLite3::Database.new(\":memory:\")\n\n\ndb.execute('create temp table players (name, score, active, jerseyNum)')\ndb.execute('insert into players values (\"name\",0,\"false\",99)')\ndb.execute('insert into players values (\"name\",0,\"false\",100)')\ndb.execute('insert into players values (\"name\",0,\"false\",101)')\n\n\n\n\ndb.execute('update players set name=?, score=?, active=? where jerseyNum=?', 'Smith, Steve', 42, true, 99)\n\n\ndb.execute('update players set name=:name, score=:score, active=:active where jerseyNum=:num',\n    :num => 100,\n    :name => 'John Doe',\n    :active => false,\n    :score => -1\n)\n\n\nstmt = db.prepare('update players set name=?4, score=?3, active=?2 where jerseyNum=?1')\nstmt.bind_param(1, 101)\nstmt.bind_param(2, true)\nstmt.bind_param(3, 3)\nstmt.bind_param(4, \"Robert'; DROP TABLE players--\")\nstmt.execute\n\n\ndb.execute2('select * from players') {|row| p row}\n", "target": "import java.sql.DriverManager;\nimport java.sql.Connection;\nimport java.sql.PreparedStatement;\n \npublic class DBDemo{\n   private String protocol; \n   private String dbName;   \n   private String username;\n   private String password;\n\n   PreparedStatement query;\n \n   public int setUpAndExecPS(){\n      try {\n         Connection conn = DriverManager.getConnection(protocol + dbName, username, password);\n\n         query = conn.prepareStatement(\n            \"UPDATE players SET name =\u00a0?, score =\u00a0?, active =\u00a0? WHERE jerseyNum =\u00a0?\");\n \n         query.setString(1, \"Smith, Steve\");\n         query.setInt(2, 42);\n         query.setBoolean(3, true);\n         query.setInt(4, 99);\n         \n         return query.executeUpdate();\n         \n         \n\n      } catch (Exception e) {\n         e.printStackTrace();\n      }\n\n      return 0;\n   }\n}\n"}
{"id": 124590, "name": "Parameterized SQL statement", "source": "Translate Ruby to Python: require 'sqlite3'\n\ndb = SQLite3::Database.new(\":memory:\")\n\n\ndb.execute('create temp table players (name, score, active, jerseyNum)')\ndb.execute('insert into players values (\"name\",0,\"false\",99)')\ndb.execute('insert into players values (\"name\",0,\"false\",100)')\ndb.execute('insert into players values (\"name\",0,\"false\",101)')\n\n\n\n\ndb.execute('update players set name=?, score=?, active=? where jerseyNum=?', 'Smith, Steve', 42, true, 99)\n\n\ndb.execute('update players set name=:name, score=:score, active=:active where jerseyNum=:num',\n    :num => 100,\n    :name => 'John Doe',\n    :active => false,\n    :score => -1\n)\n\n\nstmt = db.prepare('update players set name=?4, score=?3, active=?2 where jerseyNum=?1')\nstmt.bind_param(1, 101)\nstmt.bind_param(2, true)\nstmt.bind_param(3, 3)\nstmt.bind_param(4, \"Robert'; DROP TABLE players--\")\nstmt.execute\n\n\ndb.execute2('select * from players') {|row| p row}\n", "target": "import sqlite3\n\ndb = sqlite3.connect(':memory:')\n\n\ndb.execute('create temp table players (name, score, active, jerseyNum)')\ndb.execute('insert into players values (\"name\",0,\"false\",99)')\ndb.execute('insert into players values (\"name\",0,\"false\",100)')\n\n\n\n\ndb.execute('update players set name=?, score=?, active=? where jerseyNum=?', ('Smith, Steve', 42, True, 99))\n\n\ndb.execute('update players set name=:name, score=:score, active=:active where jerseyNum=:num',\n    {'num': 100,\n     'name': 'John Doe',\n     'active': False,\n     'score': -1}\n)\n\n\nfor row in db.execute('select * from players'):\n   print(row)\n"}
{"id": 124826, "name": "Prime decomposition", "source": "Translate Ruby to C#: irb(main):001:0> require 'prime'\n=> true\nirb(main):003:0> 2543821448263974486045199.prime_division\n=> [[701, 1], [1123, 2], [2411, 1], [1092461, 2]]\n", "target": "using System;\nusing System.Collections.Generic;\n\nnamespace PrimeDecomposition\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            GetPrimes(12);\n        }\n\n        static List<int> GetPrimes(decimal n)\n        {\n            List<int> storage = new List<int>();\n            while (n > 1)\n            {\n                int i = 1;\n                while (true)\n                {\n                    if (IsPrime(i))\n                    {                        \n                        if (((decimal)n / i) == Math.Round((decimal) n / i))\n                        {\n                            n /= i;\n                            storage.Add(i);                            \n                            break;\n                        }\n                    }\n                    i++;\n                }\n            }\n            return storage;\n        }\n\n        static bool IsPrime(int n)\n        {\n            if (n <= 1) return false;\n            for (int i = 2; i <= Math.Sqrt(n); i++)\n                if (n % i == 0) return false;\n            return true;\n        }\n    }\n}\n"}
{"id": 124828, "name": "Prime decomposition", "source": "Translate Ruby to Java: irb(main):001:0> require 'prime'\n=> true\nirb(main):003:0> 2543821448263974486045199.prime_division\n=> [[701, 1], [1123, 2], [2411, 1], [1092461, 2]]\n", "target": "public boolean prime(BigInteger i);\n"}
{"id": 124829, "name": "Prime decomposition", "source": "Translate Ruby to Python: irb(main):001:0> require 'prime'\n=> true\nirb(main):003:0> 2543821448263974486045199.prime_division\n=> [[701, 1], [1123, 2], [2411, 1], [1092461, 2]]\n", "target": "from __future__ import print_function\n\nimport sys\nfrom itertools import cycle\n\ndef is_prime(n):\n    return list(zip((True, False), decompose(n)))[-1][0]\n\nclass IsPrimeCached(dict):\n    def __missing__(self, n):\n        r = is_prime(n)\n        self[n] = r\n        return r\n\nis_prime_cached = IsPrimeCached()\n\ndef croft():\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    for p in (2, 3, 5):\n        yield p\n    roots = {}  \n    not_primeroot = tuple(x not in {1,7,11,13,17,19,23,29} for x in range(30))\n    q = 1\n    for x in cycle((6, 4, 2, 4, 2, 4, 6, 2)):\n        \n        q += x\n        \n        \n        if q in roots:\n            p = roots.pop(q)\n            x = q + p\n            while not_primeroot[x % 30] or x in roots:\n                x += p\n            roots[x] = p\n        else:\n            roots[q * q] = q + q\n            yield q\nprimes = croft\n\ndef decompose(n):\n    for p in primes():\n        if p*p > n: break\n        while n % p == 0:\n            yield p\n            n //=p\n    if n > 1:\n        yield n\n\n\nif __name__ == '__main__':\n    \n\n    import time\n\n    for m in primes():\n        p = 2 ** m - 1\n        print( \"2**{0:d}-1 = {1:d}, with factors:\".format(m, p) )\n        start = time.time()\n        for factor in decompose(p):\n            print(factor, end=' ')\n            sys.stdout.flush()\n\n        print( \"=> {0:.2f}s\".format( time.time()-start ) )\n        if m >= 59:\n            break\n"}
{"id": 125156, "name": "Happy numbers", "source": "Translate Ruby to C#: def happy?(n)\n  past = [] of Int32 | Int64\n  until n == 1\n    sum = 0; while n > 0; sum += (n % 10) ** 2; n //= 10 end\n    return false if past.includes? (n = sum)\n    past << n\n  end\n  true\nend\n\ni = count = 0\nuntil count == 8; (puts i; count += 1) if happy?(i += 1) end\nputs\n(99999999999900..99999999999999).each { |i| puts i if happy?(i) }\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\nnamespace HappyNums\n{\n    class Program\n    {\n        public static bool ishappy(int n)\n        {\n            List<int> cache = new List<int>();\n            int sum = 0;\n            while (n != 1)\n            {\n                if (cache.Contains(n))\n                {\n                    return false;\n                }\n                cache.Add(n);\n                while (n != 0)\n                {\n                    int digit = n % 10;\n                    sum += digit * digit;\n                    n /= 10;\n                }\n                n = sum;\n                sum = 0;\n            }\n           return true;            \n        }\n\n        static void Main(string[] args)\n        {\n            int num = 1;\n            List<int> happynums = new List<int>();\n\n            while (happynums.Count < 8)\n            {\n                if (ishappy(num))\n                {\n                    happynums.Add(num);\n                }\n                num++;\n            }\n            Console.WriteLine(\"First 8 happy numbers\u00a0: \" + string.Join(\",\", happynums));\n        }\n    }\n}\n"}
{"id": 125158, "name": "Happy numbers", "source": "Translate Ruby to Java: def happy?(n)\n  past = [] of Int32 | Int64\n  until n == 1\n    sum = 0; while n > 0; sum += (n % 10) ** 2; n //= 10 end\n    return false if past.includes? (n = sum)\n    past << n\n  end\n  true\nend\n\ni = count = 0\nuntil count == 8; (puts i; count += 1) if happy?(i += 1) end\nputs\n(99999999999900..99999999999999).each { |i| puts i if happy?(i) }\n", "target": "import java.util.HashSet;\npublic class Happy{\n   public static boolean happy(long number){\n       long m = 0;\n       int digit = 0;\n       HashSet<Long> cycle = new HashSet<Long>();\n       while(number != 1 && cycle.add(number)){\n           m = 0;\n           while(number > 0){\n               digit = (int)(number % 10);\n               m += digit*digit;\n               number /= 10;\n           }\n           number = m;\n       }\n       return number == 1;\n   }\n\n   public static void main(String[] args){\n       for(long num = 1,count = 0;count<8;num++){\n           if(happy(num)){\n               System.out.println(num);\n               count++;\n           }\n       }\n   }\n}\n"}
{"id": 125159, "name": "Happy numbers", "source": "Translate Ruby to Python: def happy?(n)\n  past = [] of Int32 | Int64\n  until n == 1\n    sum = 0; while n > 0; sum += (n % 10) ** 2; n //= 10 end\n    return false if past.includes? (n = sum)\n    past << n\n  end\n  true\nend\n\ni = count = 0\nuntil count == 8; (puts i; count += 1) if happy?(i += 1) end\nputs\n(99999999999900..99999999999999).each { |i| puts i if happy?(i) }\n", "target": ">>> def happy(n):\n    past = set()\t\t\t\n    while n != 1:\n        n = sum(int(i)**2 for i in str(n))\n        if n in past:\n            return False\n        past.add(n)\n    return True\n\n>>> [x for x in xrange(500) if happy(x)][:8]\n[1, 7, 10, 13, 19, 23, 28, 31]\n"}
{"id": 125408, "name": "Random numbers", "source": "Translate Ruby to C#: n, mean, sd, tau = 1000, 1, 0.5, (2 * Math::PI)\narray = Array.new(n) { mean + sd * Math.sqrt(-2 * Math.log(rand)) * Math.cos(tau * rand) }\n\nmean = array.sum / array.size\nstandev = Math.sqrt( array.sum{ |x| (x - mean) ** 2 } / array.size )\nputs \"mean = \n", "target": "private static double randomNormal()\n{\n\treturn Math.Cos(2 * Math.PI * tRand.NextDouble()) * Math.Sqrt(-2 * Math.Log(tRand.NextDouble()));\n}\n"}
{"id": 125410, "name": "Random numbers", "source": "Translate Ruby to Java: n, mean, sd, tau = 1000, 1, 0.5, (2 * Math::PI)\narray = Array.new(n) { mean + sd * Math.sqrt(-2 * Math.log(rand)) * Math.cos(tau * rand) }\n\nmean = array.sum / array.size\nstandev = Math.sqrt( array.sum{ |x| (x - mean) ** 2 } / array.size )\nputs \"mean = \n", "target": "double[] list = new double[1000];\ndouble mean = 1.0, std = 0.5;\nRandom rng = new Random();\nfor(int i = 0;i<list.length;i++) {\n  list[i] = mean + std * rng.nextGaussian();\n}\n"}
{"id": 125411, "name": "Random numbers", "source": "Translate Ruby to Python: n, mean, sd, tau = 1000, 1, 0.5, (2 * Math::PI)\narray = Array.new(n) { mean + sd * Math.sqrt(-2 * Math.log(rand)) * Math.cos(tau * rand) }\n\nmean = array.sum / array.size\nstandev = Math.sqrt( array.sum{ |x| (x - mean) ** 2 } / array.size )\nputs \"mean = \n", "target": ">>> import random\n>>> values = [random.gauss(1, .5) for i in range(1000)]\n>>>\n"}
{"id": 125634, "name": "Averages_Mean time of day", "source": "Translate Ruby to C#: def time2deg(t)\n  raise \"invalid time\" unless m = t.match(/^(\\d\\d):(\\d\\d):(\\d\\d)$/)\n  hh,mm,ss = m[1..3].map {|e| e.to_i}\n  raise \"invalid time\" unless (0..23).include? hh and\n                              (0..59).include? mm and\n                              (0..59).include? ss\n  (hh*3600 + mm*60 + ss) * 360 / 86400.0\nend\n\ndef deg2time(d)\n  sec = (d % 360) * 86400 / 360.0\n  \"%02d:%02d:%02d\" % [sec/3600, (sec%3600)/60, sec%60]\nend\n\ndef mean_time(times)\n  deg2time(mean_angle(times.map {|t| time2deg t}))\nend\n\nputs mean_time [\"23:00:17\", \"23:40:20\", \"00:12:45\", \"00:17:19\"]\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing static System.Math;\n\nnamespace RosettaCode;\n\nclass Program\n{\n    private const int SecondsPerDay = 60 * 60 * 24;\n\n    static void Main()\n    {\n        var digitimes = new List<TimeSpan>();\n\n        Console.WriteLine(\"Enter times, end with no input: \");\n        while (true) {\n            string input = Console.ReadLine();\n            if (string.IsNullOrWhiteSpace(input)) break;\n            if (TimeSpan.TryParse(input, out var digitime)) {\n                digitimes.Add(digitime);\n            } else {\n                Console.WriteLine(\"Seems this is wrong input: ignoring time\");\n            }\n        }\n        if(digitimes.Count() > 0)\n            Console.WriteLine($\"The mean time is\u00a0: {MeanTime(digitimes)}\");\n    }\n\n    public static TimeSpan MeanTime(IEnumerable<TimeSpan> ts) => FromDegrees(MeanAngle(ts.Select(ToDegrees)));\n    public static double ToDegrees(TimeSpan ts) => ts.TotalSeconds * 360d / SecondsPerDay;\n    public static TimeSpan FromDegrees(double degrees) => TimeSpan.FromSeconds((int)(degrees * SecondsPerDay / 360));\n\n    public static double MeanAngle(IEnumerable<double> angles)\n    {\n        var x = angles.Average(a => Cos(a * PI / 180));\n        var y = angles.Average(a => Sin(a * PI / 180));\n        return (Atan2(y, x) * 180 / PI + 360) % 360;\n    }\n}\n"}
{"id": 125636, "name": "Averages_Mean time of day", "source": "Translate Ruby to Python: def time2deg(t)\n  raise \"invalid time\" unless m = t.match(/^(\\d\\d):(\\d\\d):(\\d\\d)$/)\n  hh,mm,ss = m[1..3].map {|e| e.to_i}\n  raise \"invalid time\" unless (0..23).include? hh and\n                              (0..59).include? mm and\n                              (0..59).include? ss\n  (hh*3600 + mm*60 + ss) * 360 / 86400.0\nend\n\ndef deg2time(d)\n  sec = (d % 360) * 86400 / 360.0\n  \"%02d:%02d:%02d\" % [sec/3600, (sec%3600)/60, sec%60]\nend\n\ndef mean_time(times)\n  deg2time(mean_angle(times.map {|t| time2deg t}))\nend\n\nputs mean_time [\"23:00:17\", \"23:40:20\", \"00:12:45\", \"00:17:19\"]\n", "target": "from cmath import rect, phase\nfrom math import radians, degrees\n\n\ndef mean_angle(deg):\n    return degrees(phase(sum(rect(1, radians(d)) for d in deg)/len(deg)))\n\ndef mean_time(times):\n    t = (time.split(':') for time in times)\n    seconds = ((float(s) + int(m) * 60 + int(h) * 3600) \n               for h, m, s in t)\n    day = 24 * 60 * 60\n    to_angles = [s * 360. / day for s in seconds]\n    mean_as_angle = mean_angle(to_angles)\n    mean_seconds = mean_as_angle * day / 360.\n    if mean_seconds < 0:\n        mean_seconds += day\n    h, m = divmod(mean_seconds, 3600)\n    m, s = divmod(m, 60)\n    return '%02i:%02i:%02i' % (h, m, s)\n\n\nif __name__ == '__main__':\n    print( mean_time([\"23:00:17\", \"23:40:20\", \"00:12:45\", \"00:17:19\"]) )\n"}
{"id": 125926, "name": "Convert decimal number to rational", "source": "Translate Ruby to C#: > '0.9054054 0.518518 0.75'.split.each { |d| puts \"%s %s\" % [d, Rational(d)] }\n0.9054054 4527027/5000000\n0.518518 259259/500000\n0.75 3/4\n=> [\"0.9054054\", \"0.518518\", \"0.75\"]\n", "target": "using System;\nusing System.Text;\n\nnamespace RosettaDecimalToFraction\n{\n    public class Fraction\n    {\n        public Int64 Numerator;\n        public Int64 Denominator;\n        public Fraction(double f, Int64 MaximumDenominator = 4096)\n        {\n            \n            \n            Int64 a;\n            var h = new Int64[3] { 0, 1, 0 };\n            var k = new Int64[3] { 1, 0, 0 };\n            Int64 x, d, n = 1;\n            int i, neg = 0;\n\n            if (MaximumDenominator <= 1)\n            {\n                Denominator = 1;\n                Numerator = (Int64)f;\n                return;\n            }\n\n            if (f < 0) { neg = 1; f = -f; }\n\n            while (f != Math.Floor(f)) { n <<= 1; f *= 2; }\n            d = (Int64)f;\n\n            \n            for (i = 0; i < 64; i++)\n            {\n                a = (n != 0) ? d / n : 0;\n                if ((i != 0) && (a == 0)) break;\n\n                x = d; d = n; n = x % n;\n\n                x = a;\n                if (k[1] * a + k[0] >= MaximumDenominator)\n                {\n                    x = (MaximumDenominator - k[0]) / k[1];\n                    if (x * 2 >= a || k[1] >= MaximumDenominator)\n                        i = 65;\n                    else\n                        break;\n                }\n\n                h[2] = x * h[1] + h[0]; h[0] = h[1]; h[1] = h[2];\n                k[2] = x * k[1] + k[0]; k[0] = k[1]; k[1] = k[2];\n            }\n            Denominator = k[1];\n            Numerator = neg != 0 ? -h[1] : h[1];\n        }\n        public override string ToString()\n        {\n            return string.Format(\"{0} / {1}\", Numerator, Denominator);\n        }\n    }\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            Console.OutputEncoding = UTF8Encoding.UTF8;\n            foreach (double d in new double[] { 0.9054054, 0.518518, 0.75, 0.4285714, 0.833333,\n                0.90909, 3.14159265358979, 2.7182818284590451 })\n            {\n                var f = new Fraction(d, d >= 2 ? 65536 : 4096);\n                Console.WriteLine(\"{0,20} \u2192 {1}\", d, f);\n\n            }\n        }\n    }\n}\n"}
{"id": 125927, "name": "Convert decimal number to rational", "source": "Translate Ruby to C#: > '0.9054054 0.518518 0.75'.split.each { |d| puts \"%s %s\" % [d, Rational(d)] }\n0.9054054 4527027/5000000\n0.518518 259259/500000\n0.75 3/4\n=> [\"0.9054054\", \"0.518518\", \"0.75\"]\n", "target": "using System;\nusing System.Text;\n\nnamespace RosettaDecimalToFraction\n{\n    public class Fraction\n    {\n        public Int64 Numerator;\n        public Int64 Denominator;\n        public Fraction(double f, Int64 MaximumDenominator = 4096)\n        {\n            \n            \n            Int64 a;\n            var h = new Int64[3] { 0, 1, 0 };\n            var k = new Int64[3] { 1, 0, 0 };\n            Int64 x, d, n = 1;\n            int i, neg = 0;\n\n            if (MaximumDenominator <= 1)\n            {\n                Denominator = 1;\n                Numerator = (Int64)f;\n                return;\n            }\n\n            if (f < 0) { neg = 1; f = -f; }\n\n            while (f != Math.Floor(f)) { n <<= 1; f *= 2; }\n            d = (Int64)f;\n\n            \n            for (i = 0; i < 64; i++)\n            {\n                a = (n != 0) ? d / n : 0;\n                if ((i != 0) && (a == 0)) break;\n\n                x = d; d = n; n = x % n;\n\n                x = a;\n                if (k[1] * a + k[0] >= MaximumDenominator)\n                {\n                    x = (MaximumDenominator - k[0]) / k[1];\n                    if (x * 2 >= a || k[1] >= MaximumDenominator)\n                        i = 65;\n                    else\n                        break;\n                }\n\n                h[2] = x * h[1] + h[0]; h[0] = h[1]; h[1] = h[2];\n                k[2] = x * k[1] + k[0]; k[0] = k[1]; k[1] = k[2];\n            }\n            Denominator = k[1];\n            Numerator = neg != 0 ? -h[1] : h[1];\n        }\n        public override string ToString()\n        {\n            return string.Format(\"{0} / {1}\", Numerator, Denominator);\n        }\n    }\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            Console.OutputEncoding = UTF8Encoding.UTF8;\n            foreach (double d in new double[] { 0.9054054, 0.518518, 0.75, 0.4285714, 0.833333,\n                0.90909, 3.14159265358979, 2.7182818284590451 })\n            {\n                var f = new Fraction(d, d >= 2 ? 65536 : 4096);\n                Console.WriteLine(\"{0,20} \u2192 {1}\", d, f);\n\n            }\n        }\n    }\n}\n"}
{"id": 125928, "name": "Convert decimal number to rational", "source": "Translate Ruby to Java: > '0.9054054 0.518518 0.75'.split.each { |d| puts \"%s %s\" % [d, Rational(d)] }\n0.9054054 4527027/5000000\n0.518518 259259/500000\n0.75 3/4\n=> [\"0.9054054\", \"0.518518\", \"0.75\"]\n", "target": "import org.apache.commons.math3.fraction.BigFraction;\n\npublic class Test {\n\n    public static void main(String[] args) {\n        double[] n = {0.750000000, 0.518518000, 0.905405400, 0.142857143,\n            3.141592654, 2.718281828, -0.423310825, 31.415926536};\n\n        for (double d : n)\n            System.out.printf(\"%-12s\u00a0: %s%n\", d, new BigFraction(d, 0.00000002D, 10000));\n    }\n}\n"}
{"id": 125929, "name": "Convert decimal number to rational", "source": "Translate Ruby to Java: > '0.9054054 0.518518 0.75'.split.each { |d| puts \"%s %s\" % [d, Rational(d)] }\n0.9054054 4527027/5000000\n0.518518 259259/500000\n0.75 3/4\n=> [\"0.9054054\", \"0.518518\", \"0.75\"]\n", "target": "import org.apache.commons.math3.fraction.BigFraction;\n\npublic class Test {\n\n    public static void main(String[] args) {\n        double[] n = {0.750000000, 0.518518000, 0.905405400, 0.142857143,\n            3.141592654, 2.718281828, -0.423310825, 31.415926536};\n\n        for (double d : n)\n            System.out.printf(\"%-12s\u00a0: %s%n\", d, new BigFraction(d, 0.00000002D, 10000));\n    }\n}\n"}
{"id": 125930, "name": "Convert decimal number to rational", "source": "Translate Ruby to Python: > '0.9054054 0.518518 0.75'.split.each { |d| puts \"%s %s\" % [d, Rational(d)] }\n0.9054054 4527027/5000000\n0.518518 259259/500000\n0.75 3/4\n=> [\"0.9054054\", \"0.518518\", \"0.75\"]\n", "target": ">>> from fractions import Fraction\n>>> for d in (0.9054054, 0.518518, 0.75): print(d, Fraction.from_float(d).limit_denominator(100))\n\n0.9054054 67/74\n0.518518 14/27\n0.75 3/4\n>>> for d in '0.9054054 0.518518 0.75'.split(): print(d, Fraction(d))\n\n0.9054054 4527027/5000000\n0.518518 259259/500000\n0.75 3/4\n>>>\n"}
{"id": 125931, "name": "Convert decimal number to rational", "source": "Translate Ruby to Python: > '0.9054054 0.518518 0.75'.split.each { |d| puts \"%s %s\" % [d, Rational(d)] }\n0.9054054 4527027/5000000\n0.518518 259259/500000\n0.75 3/4\n=> [\"0.9054054\", \"0.518518\", \"0.75\"]\n", "target": ">>> from fractions import Fraction\n>>> for d in (0.9054054, 0.518518, 0.75): print(d, Fraction.from_float(d).limit_denominator(100))\n\n0.9054054 67/74\n0.518518 14/27\n0.75 3/4\n>>> for d in '0.9054054 0.518518 0.75'.split(): print(d, Fraction(d))\n\n0.9054054 4527027/5000000\n0.518518 259259/500000\n0.75 3/4\n>>>\n"}
{"id": 126243, "name": "Knight's tour", "source": "Translate Ruby to C#: class Board\n  Cell = Struct.new(:value, :adj) do\n    def self.end=(end_val)\n      @@end = end_val\n    end\n    \n    def try(seq_num)\n      self.value = seq_num\n      return true  if seq_num==@@end\n      a = []\n      adj.each_with_index do |cell, n|\n        a << [wdof(cell.adj)*10+n, cell]  if cell.value.zero?\n      end\n      a.sort.each {|_, cell| return true  if cell.try(seq_num+1)}\n      self.value = 0\n      false\n    end\n    \n    def wdof(adj)\n      adj.count {|cell| cell.value.zero?}\n    end\n  end\n  \n  def initialize(rows, cols)\n    @rows, @cols = rows, cols\n    unless defined? ADJACENT                      \n      eval(\"ADJACENT = [[-1,-2],[-2,-1],[-2,1],[-1,2],[1,2],[2,1],[2,-1],[1,-2]]\")\n    end\n    frame = ADJACENT.flatten.map(&:abs).max\n    @board = Array.new(rows+frame) do |i|\n      Array.new(cols+frame) do |j|\n        (i<rows and j<cols) ? Cell.new(0) : nil   \n      end\n    end\n    rows.times do |i|\n      cols.times do |j|\n        @board[i][j].adj = ADJACENT.map{|di,dj| @board[i+di][j+dj]}.compact\n      end\n    end\n    Cell.end = rows * cols\n    @format = \"\u00a0%\n  end\n  \n  def solve(sx, sy)\n    if (@rows*@cols).odd? and (sx+sy).odd?\n      puts \"No solution\"\n    else\n      puts (@board[sx][sy].try(1) ? to_s : \"No solution\")\n    end\n  end\n  \n  def to_s\n    (0...@rows).map do |x|\n      (0...@cols).map{|y| @format % @board[x][y].value}.join\n    end\n  end\nend\n\ndef knight_tour(rows=8, cols=rows, sx=rand(rows), sy=rand(cols))\n  puts \"\\nBoard (%d x %d), Start:[%d, %d]\" % [rows, cols, sx, sy]\n  Board.new(rows, cols).solve(sx, sy)\nend\n\nknight_tour(8,8,3,1)\n\nknight_tour(5,5,2,2)\n\nknight_tour(4,9,0,0)\n\nknight_tour(5,5,0,1)\n\nknight_tour(12,12,1,1)\n", "target": "using System;\nusing System.Collections.Generic;\n\nnamespace prog\n{\n\tclass MainClass\n\t{\t\n\t\tconst int N = 8;\n\t\t\n\t\treadonly static int[,] moves = { {+1,-2},{+2,-1},{+2,+1},{+1,+2},\n\t\t\t                         {-1,+2},{-2,+1},{-2,-1},{-1,-2} };\n\t\tstruct ListMoves\n\t\t{\n\t\t\tpublic int x, y;\t\t\t\n\t\t\tpublic ListMoves( int _x, int _y ) { x = _x; y = _y; }\n\t\t}\t\t\n\t\t\n\t\tpublic static void Main (string[] args)\n\t\t{\n\t\t\tint[,] board = new int[N,N];\n\t\t\tboard.Initialize();\n\t\t\t\n\t\t\tint x = 0,\t\t\t\t\t\t\n\t\t\t    y = 0;\n\t\t\t\n\t\t\tList<ListMoves> list = new List<ListMoves>(N*N);\n\t\t\tlist.Add( new ListMoves(x,y) );\n\t\t\t\t\t\t\n\t\t\tdo\n\t\t\t{\t\t\t\t\t\t\t\t\n\t\t\t\tif ( Move_Possible( board, x, y ) )\n\t\t\t\t{\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\tint move = board[x,y];\t\t\t\t\t\n\t\t\t\t\tboard[x,y]++;\n\t\t\t\t\tx += moves[move,0];\n\t\t\t\t\ty += moves[move,1];\t\t\t\n\t\t\t\t\tlist.Add( new ListMoves(x,y) );\t\t\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\t\t\t\t\t\n\t\t\t\t\tif ( board[x,y] >= 8 )\n\t\t\t\t\t{\t\t\t\t\t\t\n\t\t\t\t\t\tboard[x,y] = 0;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\tlist.RemoveAt(list.Count-1);\t\t\t\t\t\t\n\t\t\t\t\t\tif ( list.Count == 0 )\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tConsole.WriteLine( \"No solution found.\" );\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\t\t\n\t\t\t\t\t\tx = list[list.Count-1].x;\n\t\t\t\t\t\ty = list[list.Count-1].y;\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t\tboard[x,y]++;\n\t\t\t\t}\t\t\t\t\n\t\t\t}\n\t\t\twhile( list.Count < N*N );\n\t\t\t\n\t\t\tint last_x = list[0].x,\n\t\t\t    last_y = list[0].y;\n\t\t\tstring letters = \"ABCDEFGH\";\n\t\t\tfor( int i=1; i<list.Count; i++ )\n\t\t\t{\t\t\t\t\n\t\t\t\tConsole.WriteLine( string.Format(\"{0,2}:  \", i) + letters[last_x] + (last_y+1) + \" - \" + letters[list[i].x] + (list[i].y+1) );\n\t\t\t\t\n\t\t\t\tlast_x = list[i].x;\n\t\t\t\tlast_y = list[i].y;\n\t\t\t}\n\t\t}\n\t\t\n\t\tstatic bool Move_Possible( int[,] board, int cur_x, int cur_y )\n\t\t{\t\t\t\n\t\t\tif ( board[cur_x,cur_y] >= 8 ) \n\t\t\t\treturn false;\n\t\t\t\n\t\t\tint new_x = cur_x + moves[board[cur_x,cur_y],0],\n\t\t\t    new_y = cur_y + moves[board[cur_x,cur_y],1];\n\t\t\t\n\t\t\tif ( new_x >= 0 && new_x < N && new_y >= 0 && new_y < N && board[new_x,new_y] == 0 )\n\t\t\t\treturn true;\n\t\t\t\n\t\t\treturn false;\n\t\t}\n\t}\n}\n"}
{"id": 126244, "name": "Knight's tour", "source": "Translate Ruby to C#: class Board\n  Cell = Struct.new(:value, :adj) do\n    def self.end=(end_val)\n      @@end = end_val\n    end\n    \n    def try(seq_num)\n      self.value = seq_num\n      return true  if seq_num==@@end\n      a = []\n      adj.each_with_index do |cell, n|\n        a << [wdof(cell.adj)*10+n, cell]  if cell.value.zero?\n      end\n      a.sort.each {|_, cell| return true  if cell.try(seq_num+1)}\n      self.value = 0\n      false\n    end\n    \n    def wdof(adj)\n      adj.count {|cell| cell.value.zero?}\n    end\n  end\n  \n  def initialize(rows, cols)\n    @rows, @cols = rows, cols\n    unless defined? ADJACENT                      \n      eval(\"ADJACENT = [[-1,-2],[-2,-1],[-2,1],[-1,2],[1,2],[2,1],[2,-1],[1,-2]]\")\n    end\n    frame = ADJACENT.flatten.map(&:abs).max\n    @board = Array.new(rows+frame) do |i|\n      Array.new(cols+frame) do |j|\n        (i<rows and j<cols) ? Cell.new(0) : nil   \n      end\n    end\n    rows.times do |i|\n      cols.times do |j|\n        @board[i][j].adj = ADJACENT.map{|di,dj| @board[i+di][j+dj]}.compact\n      end\n    end\n    Cell.end = rows * cols\n    @format = \"\u00a0%\n  end\n  \n  def solve(sx, sy)\n    if (@rows*@cols).odd? and (sx+sy).odd?\n      puts \"No solution\"\n    else\n      puts (@board[sx][sy].try(1) ? to_s : \"No solution\")\n    end\n  end\n  \n  def to_s\n    (0...@rows).map do |x|\n      (0...@cols).map{|y| @format % @board[x][y].value}.join\n    end\n  end\nend\n\ndef knight_tour(rows=8, cols=rows, sx=rand(rows), sy=rand(cols))\n  puts \"\\nBoard (%d x %d), Start:[%d, %d]\" % [rows, cols, sx, sy]\n  Board.new(rows, cols).solve(sx, sy)\nend\n\nknight_tour(8,8,3,1)\n\nknight_tour(5,5,2,2)\n\nknight_tour(4,9,0,0)\n\nknight_tour(5,5,0,1)\n\nknight_tour(12,12,1,1)\n", "target": "using System;\nusing System.Collections.Generic;\n\nnamespace prog\n{\n\tclass MainClass\n\t{\t\n\t\tconst int N = 8;\n\t\t\n\t\treadonly static int[,] moves = { {+1,-2},{+2,-1},{+2,+1},{+1,+2},\n\t\t\t                         {-1,+2},{-2,+1},{-2,-1},{-1,-2} };\n\t\tstruct ListMoves\n\t\t{\n\t\t\tpublic int x, y;\t\t\t\n\t\t\tpublic ListMoves( int _x, int _y ) { x = _x; y = _y; }\n\t\t}\t\t\n\t\t\n\t\tpublic static void Main (string[] args)\n\t\t{\n\t\t\tint[,] board = new int[N,N];\n\t\t\tboard.Initialize();\n\t\t\t\n\t\t\tint x = 0,\t\t\t\t\t\t\n\t\t\t    y = 0;\n\t\t\t\n\t\t\tList<ListMoves> list = new List<ListMoves>(N*N);\n\t\t\tlist.Add( new ListMoves(x,y) );\n\t\t\t\t\t\t\n\t\t\tdo\n\t\t\t{\t\t\t\t\t\t\t\t\n\t\t\t\tif ( Move_Possible( board, x, y ) )\n\t\t\t\t{\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\tint move = board[x,y];\t\t\t\t\t\n\t\t\t\t\tboard[x,y]++;\n\t\t\t\t\tx += moves[move,0];\n\t\t\t\t\ty += moves[move,1];\t\t\t\n\t\t\t\t\tlist.Add( new ListMoves(x,y) );\t\t\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\t\t\t\t\t\n\t\t\t\t\tif ( board[x,y] >= 8 )\n\t\t\t\t\t{\t\t\t\t\t\t\n\t\t\t\t\t\tboard[x,y] = 0;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\tlist.RemoveAt(list.Count-1);\t\t\t\t\t\t\n\t\t\t\t\t\tif ( list.Count == 0 )\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tConsole.WriteLine( \"No solution found.\" );\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\t\t\n\t\t\t\t\t\tx = list[list.Count-1].x;\n\t\t\t\t\t\ty = list[list.Count-1].y;\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t\tboard[x,y]++;\n\t\t\t\t}\t\t\t\t\n\t\t\t}\n\t\t\twhile( list.Count < N*N );\n\t\t\t\n\t\t\tint last_x = list[0].x,\n\t\t\t    last_y = list[0].y;\n\t\t\tstring letters = \"ABCDEFGH\";\n\t\t\tfor( int i=1; i<list.Count; i++ )\n\t\t\t{\t\t\t\t\n\t\t\t\tConsole.WriteLine( string.Format(\"{0,2}:  \", i) + letters[last_x] + (last_y+1) + \" - \" + letters[list[i].x] + (list[i].y+1) );\n\t\t\t\t\n\t\t\t\tlast_x = list[i].x;\n\t\t\t\tlast_y = list[i].y;\n\t\t\t}\n\t\t}\n\t\t\n\t\tstatic bool Move_Possible( int[,] board, int cur_x, int cur_y )\n\t\t{\t\t\t\n\t\t\tif ( board[cur_x,cur_y] >= 8 ) \n\t\t\t\treturn false;\n\t\t\t\n\t\t\tint new_x = cur_x + moves[board[cur_x,cur_y],0],\n\t\t\t    new_y = cur_y + moves[board[cur_x,cur_y],1];\n\t\t\t\n\t\t\tif ( new_x >= 0 && new_x < N && new_y >= 0 && new_y < N && board[new_x,new_y] == 0 )\n\t\t\t\treturn true;\n\t\t\t\n\t\t\treturn false;\n\t\t}\n\t}\n}\n"}
{"id": 126247, "name": "Knight's tour", "source": "Translate Ruby to Java: class Board\n  Cell = Struct.new(:value, :adj) do\n    def self.end=(end_val)\n      @@end = end_val\n    end\n    \n    def try(seq_num)\n      self.value = seq_num\n      return true  if seq_num==@@end\n      a = []\n      adj.each_with_index do |cell, n|\n        a << [wdof(cell.adj)*10+n, cell]  if cell.value.zero?\n      end\n      a.sort.each {|_, cell| return true  if cell.try(seq_num+1)}\n      self.value = 0\n      false\n    end\n    \n    def wdof(adj)\n      adj.count {|cell| cell.value.zero?}\n    end\n  end\n  \n  def initialize(rows, cols)\n    @rows, @cols = rows, cols\n    unless defined? ADJACENT                      \n      eval(\"ADJACENT = [[-1,-2],[-2,-1],[-2,1],[-1,2],[1,2],[2,1],[2,-1],[1,-2]]\")\n    end\n    frame = ADJACENT.flatten.map(&:abs).max\n    @board = Array.new(rows+frame) do |i|\n      Array.new(cols+frame) do |j|\n        (i<rows and j<cols) ? Cell.new(0) : nil   \n      end\n    end\n    rows.times do |i|\n      cols.times do |j|\n        @board[i][j].adj = ADJACENT.map{|di,dj| @board[i+di][j+dj]}.compact\n      end\n    end\n    Cell.end = rows * cols\n    @format = \"\u00a0%\n  end\n  \n  def solve(sx, sy)\n    if (@rows*@cols).odd? and (sx+sy).odd?\n      puts \"No solution\"\n    else\n      puts (@board[sx][sy].try(1) ? to_s : \"No solution\")\n    end\n  end\n  \n  def to_s\n    (0...@rows).map do |x|\n      (0...@cols).map{|y| @format % @board[x][y].value}.join\n    end\n  end\nend\n\ndef knight_tour(rows=8, cols=rows, sx=rand(rows), sy=rand(cols))\n  puts \"\\nBoard (%d x %d), Start:[%d, %d]\" % [rows, cols, sx, sy]\n  Board.new(rows, cols).solve(sx, sy)\nend\n\nknight_tour(8,8,3,1)\n\nknight_tour(5,5,2,2)\n\nknight_tour(4,9,0,0)\n\nknight_tour(5,5,0,1)\n\nknight_tour(12,12,1,1)\n", "target": "import java.util.*;\n\npublic class KnightsTour {\n    private final static int base = 12;\n    private final static int[][] moves = {{1,-2},{2,-1},{2,1},{1,2},{-1,2},\n        {-2,1},{-2,-1},{-1,-2}};\n    private static int[][] grid;\n    private static int total;\n\n    public static void main(String[] args) {\n        grid = new int[base][base];\n        total = (base - 4) * (base - 4);\n\n        for (int r = 0; r < base; r++)\n            for (int c = 0; c < base; c++)\n                if (r < 2 || r > base - 3 || c < 2 || c > base - 3)\n                    grid[r][c] = -1;\n\n        int row = 2 + (int) (Math.random() * (base - 4));\n        int col = 2 + (int) (Math.random() * (base - 4));\n\n        grid[row][col] = 1;\n\n        if (solve(row, col, 2))\n            printResult();\n        else System.out.println(\"no result\");\n\n    }\n\n    private static boolean solve(int r, int c, int count) {\n        if (count > total)\n            return true;\n\n        List<int[]> nbrs = neighbors(r, c);\n\n        if (nbrs.isEmpty() && count != total)\n            return false;\n\n        Collections.sort(nbrs, new Comparator<int[]>() {\n            public int compare(int[] a, int[] b) {\n                return a[2] - b[2];\n            }\n        });\n\n        for (int[] nb : nbrs) {\n            r = nb[0];\n            c = nb[1];\n            grid[r][c] = count;\n            if (!orphanDetected(count, r, c) && solve(r, c, count + 1))\n                return true;\n            grid[r][c] = 0;\n        }\n\n        return false;\n    }\n\n    private static List<int[]> neighbors(int r, int c) {\n        List<int[]> nbrs = new ArrayList<>();\n\n        for (int[] m : moves) {\n            int x = m[0];\n            int y = m[1];\n            if (grid[r + y][c + x] == 0) {\n                int num = countNeighbors(r + y, c + x);\n                nbrs.add(new int[]{r + y, c + x, num});\n            }\n        }\n        return nbrs;\n    }\n\n    private static int countNeighbors(int r, int c) {\n        int num = 0;\n        for (int[] m : moves)\n            if (grid[r + m[1]][c + m[0]] == 0)\n                num++;\n        return num;\n    }\n\n    private static boolean orphanDetected(int cnt, int r, int c) {\n        if (cnt < total - 1) {\n            List<int[]> nbrs = neighbors(r, c);\n            for (int[] nb : nbrs)\n                if (countNeighbors(nb[0], nb[1]) == 0)\n                    return true;\n        }\n        return false;\n    }\n\n    private static void printResult() {\n        for (int[] row : grid) {\n            for (int i : row) {\n                if (i == -1) continue;\n                System.out.printf(\"%2d \", i);\n            }\n            System.out.println();\n        }\n    }\n}\n"}
{"id": 126248, "name": "Knight's tour", "source": "Translate Ruby to Java: class Board\n  Cell = Struct.new(:value, :adj) do\n    def self.end=(end_val)\n      @@end = end_val\n    end\n    \n    def try(seq_num)\n      self.value = seq_num\n      return true  if seq_num==@@end\n      a = []\n      adj.each_with_index do |cell, n|\n        a << [wdof(cell.adj)*10+n, cell]  if cell.value.zero?\n      end\n      a.sort.each {|_, cell| return true  if cell.try(seq_num+1)}\n      self.value = 0\n      false\n    end\n    \n    def wdof(adj)\n      adj.count {|cell| cell.value.zero?}\n    end\n  end\n  \n  def initialize(rows, cols)\n    @rows, @cols = rows, cols\n    unless defined? ADJACENT                      \n      eval(\"ADJACENT = [[-1,-2],[-2,-1],[-2,1],[-1,2],[1,2],[2,1],[2,-1],[1,-2]]\")\n    end\n    frame = ADJACENT.flatten.map(&:abs).max\n    @board = Array.new(rows+frame) do |i|\n      Array.new(cols+frame) do |j|\n        (i<rows and j<cols) ? Cell.new(0) : nil   \n      end\n    end\n    rows.times do |i|\n      cols.times do |j|\n        @board[i][j].adj = ADJACENT.map{|di,dj| @board[i+di][j+dj]}.compact\n      end\n    end\n    Cell.end = rows * cols\n    @format = \"\u00a0%\n  end\n  \n  def solve(sx, sy)\n    if (@rows*@cols).odd? and (sx+sy).odd?\n      puts \"No solution\"\n    else\n      puts (@board[sx][sy].try(1) ? to_s : \"No solution\")\n    end\n  end\n  \n  def to_s\n    (0...@rows).map do |x|\n      (0...@cols).map{|y| @format % @board[x][y].value}.join\n    end\n  end\nend\n\ndef knight_tour(rows=8, cols=rows, sx=rand(rows), sy=rand(cols))\n  puts \"\\nBoard (%d x %d), Start:[%d, %d]\" % [rows, cols, sx, sy]\n  Board.new(rows, cols).solve(sx, sy)\nend\n\nknight_tour(8,8,3,1)\n\nknight_tour(5,5,2,2)\n\nknight_tour(4,9,0,0)\n\nknight_tour(5,5,0,1)\n\nknight_tour(12,12,1,1)\n", "target": "import java.util.*;\n\npublic class KnightsTour {\n    private final static int base = 12;\n    private final static int[][] moves = {{1,-2},{2,-1},{2,1},{1,2},{-1,2},\n        {-2,1},{-2,-1},{-1,-2}};\n    private static int[][] grid;\n    private static int total;\n\n    public static void main(String[] args) {\n        grid = new int[base][base];\n        total = (base - 4) * (base - 4);\n\n        for (int r = 0; r < base; r++)\n            for (int c = 0; c < base; c++)\n                if (r < 2 || r > base - 3 || c < 2 || c > base - 3)\n                    grid[r][c] = -1;\n\n        int row = 2 + (int) (Math.random() * (base - 4));\n        int col = 2 + (int) (Math.random() * (base - 4));\n\n        grid[row][col] = 1;\n\n        if (solve(row, col, 2))\n            printResult();\n        else System.out.println(\"no result\");\n\n    }\n\n    private static boolean solve(int r, int c, int count) {\n        if (count > total)\n            return true;\n\n        List<int[]> nbrs = neighbors(r, c);\n\n        if (nbrs.isEmpty() && count != total)\n            return false;\n\n        Collections.sort(nbrs, new Comparator<int[]>() {\n            public int compare(int[] a, int[] b) {\n                return a[2] - b[2];\n            }\n        });\n\n        for (int[] nb : nbrs) {\n            r = nb[0];\n            c = nb[1];\n            grid[r][c] = count;\n            if (!orphanDetected(count, r, c) && solve(r, c, count + 1))\n                return true;\n            grid[r][c] = 0;\n        }\n\n        return false;\n    }\n\n    private static List<int[]> neighbors(int r, int c) {\n        List<int[]> nbrs = new ArrayList<>();\n\n        for (int[] m : moves) {\n            int x = m[0];\n            int y = m[1];\n            if (grid[r + y][c + x] == 0) {\n                int num = countNeighbors(r + y, c + x);\n                nbrs.add(new int[]{r + y, c + x, num});\n            }\n        }\n        return nbrs;\n    }\n\n    private static int countNeighbors(int r, int c) {\n        int num = 0;\n        for (int[] m : moves)\n            if (grid[r + m[1]][c + m[0]] == 0)\n                num++;\n        return num;\n    }\n\n    private static boolean orphanDetected(int cnt, int r, int c) {\n        if (cnt < total - 1) {\n            List<int[]> nbrs = neighbors(r, c);\n            for (int[] nb : nbrs)\n                if (countNeighbors(nb[0], nb[1]) == 0)\n                    return true;\n        }\n        return false;\n    }\n\n    private static void printResult() {\n        for (int[] row : grid) {\n            for (int i : row) {\n                if (i == -1) continue;\n                System.out.printf(\"%2d \", i);\n            }\n            System.out.println();\n        }\n    }\n}\n"}
{"id": 126249, "name": "Knight's tour", "source": "Translate Ruby to Python: class Board\n  Cell = Struct.new(:value, :adj) do\n    def self.end=(end_val)\n      @@end = end_val\n    end\n    \n    def try(seq_num)\n      self.value = seq_num\n      return true  if seq_num==@@end\n      a = []\n      adj.each_with_index do |cell, n|\n        a << [wdof(cell.adj)*10+n, cell]  if cell.value.zero?\n      end\n      a.sort.each {|_, cell| return true  if cell.try(seq_num+1)}\n      self.value = 0\n      false\n    end\n    \n    def wdof(adj)\n      adj.count {|cell| cell.value.zero?}\n    end\n  end\n  \n  def initialize(rows, cols)\n    @rows, @cols = rows, cols\n    unless defined? ADJACENT                      \n      eval(\"ADJACENT = [[-1,-2],[-2,-1],[-2,1],[-1,2],[1,2],[2,1],[2,-1],[1,-2]]\")\n    end\n    frame = ADJACENT.flatten.map(&:abs).max\n    @board = Array.new(rows+frame) do |i|\n      Array.new(cols+frame) do |j|\n        (i<rows and j<cols) ? Cell.new(0) : nil   \n      end\n    end\n    rows.times do |i|\n      cols.times do |j|\n        @board[i][j].adj = ADJACENT.map{|di,dj| @board[i+di][j+dj]}.compact\n      end\n    end\n    Cell.end = rows * cols\n    @format = \"\u00a0%\n  end\n  \n  def solve(sx, sy)\n    if (@rows*@cols).odd? and (sx+sy).odd?\n      puts \"No solution\"\n    else\n      puts (@board[sx][sy].try(1) ? to_s : \"No solution\")\n    end\n  end\n  \n  def to_s\n    (0...@rows).map do |x|\n      (0...@cols).map{|y| @format % @board[x][y].value}.join\n    end\n  end\nend\n\ndef knight_tour(rows=8, cols=rows, sx=rand(rows), sy=rand(cols))\n  puts \"\\nBoard (%d x %d), Start:[%d, %d]\" % [rows, cols, sx, sy]\n  Board.new(rows, cols).solve(sx, sy)\nend\n\nknight_tour(8,8,3,1)\n\nknight_tour(5,5,2,2)\n\nknight_tour(4,9,0,0)\n\nknight_tour(5,5,0,1)\n\nknight_tour(12,12,1,1)\n", "target": "import copy\n\nboardsize=6\n_kmoves = ((2,1), (1,2), (-1,2), (-2,1), (-2,-1), (-1,-2), (1,-2), (2,-1)) \n\n\ndef chess2index(chess, boardsize=boardsize):\n    'Convert Algebraic chess notation to internal index format'\n    chess = chess.strip().lower()\n    x = ord(chess[0]) - ord('a')\n    y = boardsize - int(chess[1:])\n    return (x, y)\n    \ndef boardstring(board, boardsize=boardsize):\n    r = range(boardsize)\n    lines = ''\n    for y in r:\n        lines += '\\n' + ','.join('%2i' % board[(x,y)] if board[(x,y)] else '  '\n                                 for x in r)\n    return lines\n    \ndef knightmoves(board, P, boardsize=boardsize):\n    Px, Py = P\n    kmoves = set((Px+x, Py+y) for x,y in _kmoves)\n    kmoves = set( (x,y)\n                  for x,y in kmoves\n                  if 0 <= x < boardsize\n                     and 0 <= y < boardsize\n                     and not board[(x,y)] )\n    return kmoves\n\ndef accessibility(board, P, boardsize=boardsize):\n    access = []\n    brd = copy.deepcopy(board)\n    for pos in knightmoves(board, P, boardsize=boardsize):\n        brd[pos] = -1\n        access.append( (len(knightmoves(brd, pos, boardsize=boardsize)), pos) )\n        brd[pos] = 0\n    return access\n    \ndef knights_tour(start, boardsize=boardsize, _debug=False):\n    board = {(x,y):0 for x in range(boardsize) for y in range(boardsize)}\n    move = 1\n    P = chess2index(start, boardsize)\n    board[P] = move\n    move += 1\n    if _debug:\n        print(boardstring(board, boardsize=boardsize))\n    while move <= len(board):\n        P = min(accessibility(board, P, boardsize))[1]\n        board[P] = move\n        move += 1\n        if _debug:\n            print(boardstring(board, boardsize=boardsize))\n            input('\\n%2i next: ' % move)\n    return board\n\nif __name__ == '__main__':\n    while 1:\n        boardsize = int(input('\\nboardsize: '))\n        if boardsize < 5:\n            continue\n        start = input('Start position: ')\n        board = knights_tour(start, boardsize)\n        print(boardstring(board, boardsize=boardsize))\n"}
{"id": 126250, "name": "Knight's tour", "source": "Translate Ruby to Python: class Board\n  Cell = Struct.new(:value, :adj) do\n    def self.end=(end_val)\n      @@end = end_val\n    end\n    \n    def try(seq_num)\n      self.value = seq_num\n      return true  if seq_num==@@end\n      a = []\n      adj.each_with_index do |cell, n|\n        a << [wdof(cell.adj)*10+n, cell]  if cell.value.zero?\n      end\n      a.sort.each {|_, cell| return true  if cell.try(seq_num+1)}\n      self.value = 0\n      false\n    end\n    \n    def wdof(adj)\n      adj.count {|cell| cell.value.zero?}\n    end\n  end\n  \n  def initialize(rows, cols)\n    @rows, @cols = rows, cols\n    unless defined? ADJACENT                      \n      eval(\"ADJACENT = [[-1,-2],[-2,-1],[-2,1],[-1,2],[1,2],[2,1],[2,-1],[1,-2]]\")\n    end\n    frame = ADJACENT.flatten.map(&:abs).max\n    @board = Array.new(rows+frame) do |i|\n      Array.new(cols+frame) do |j|\n        (i<rows and j<cols) ? Cell.new(0) : nil   \n      end\n    end\n    rows.times do |i|\n      cols.times do |j|\n        @board[i][j].adj = ADJACENT.map{|di,dj| @board[i+di][j+dj]}.compact\n      end\n    end\n    Cell.end = rows * cols\n    @format = \"\u00a0%\n  end\n  \n  def solve(sx, sy)\n    if (@rows*@cols).odd? and (sx+sy).odd?\n      puts \"No solution\"\n    else\n      puts (@board[sx][sy].try(1) ? to_s : \"No solution\")\n    end\n  end\n  \n  def to_s\n    (0...@rows).map do |x|\n      (0...@cols).map{|y| @format % @board[x][y].value}.join\n    end\n  end\nend\n\ndef knight_tour(rows=8, cols=rows, sx=rand(rows), sy=rand(cols))\n  puts \"\\nBoard (%d x %d), Start:[%d, %d]\" % [rows, cols, sx, sy]\n  Board.new(rows, cols).solve(sx, sy)\nend\n\nknight_tour(8,8,3,1)\n\nknight_tour(5,5,2,2)\n\nknight_tour(4,9,0,0)\n\nknight_tour(5,5,0,1)\n\nknight_tour(12,12,1,1)\n", "target": "import copy\n\nboardsize=6\n_kmoves = ((2,1), (1,2), (-1,2), (-2,1), (-2,-1), (-1,-2), (1,-2), (2,-1)) \n\n\ndef chess2index(chess, boardsize=boardsize):\n    'Convert Algebraic chess notation to internal index format'\n    chess = chess.strip().lower()\n    x = ord(chess[0]) - ord('a')\n    y = boardsize - int(chess[1:])\n    return (x, y)\n    \ndef boardstring(board, boardsize=boardsize):\n    r = range(boardsize)\n    lines = ''\n    for y in r:\n        lines += '\\n' + ','.join('%2i' % board[(x,y)] if board[(x,y)] else '  '\n                                 for x in r)\n    return lines\n    \ndef knightmoves(board, P, boardsize=boardsize):\n    Px, Py = P\n    kmoves = set((Px+x, Py+y) for x,y in _kmoves)\n    kmoves = set( (x,y)\n                  for x,y in kmoves\n                  if 0 <= x < boardsize\n                     and 0 <= y < boardsize\n                     and not board[(x,y)] )\n    return kmoves\n\ndef accessibility(board, P, boardsize=boardsize):\n    access = []\n    brd = copy.deepcopy(board)\n    for pos in knightmoves(board, P, boardsize=boardsize):\n        brd[pos] = -1\n        access.append( (len(knightmoves(brd, pos, boardsize=boardsize)), pos) )\n        brd[pos] = 0\n    return access\n    \ndef knights_tour(start, boardsize=boardsize, _debug=False):\n    board = {(x,y):0 for x in range(boardsize) for y in range(boardsize)}\n    move = 1\n    P = chess2index(start, boardsize)\n    board[P] = move\n    move += 1\n    if _debug:\n        print(boardstring(board, boardsize=boardsize))\n    while move <= len(board):\n        P = min(accessibility(board, P, boardsize))[1]\n        board[P] = move\n        move += 1\n        if _debug:\n            print(boardstring(board, boardsize=boardsize))\n            input('\\n%2i next: ' % move)\n    return board\n\nif __name__ == '__main__':\n    while 1:\n        boardsize = int(input('\\nboardsize: '))\n        if boardsize < 5:\n            continue\n        start = input('Start position: ')\n        board = knights_tour(start, boardsize)\n        print(boardstring(board, boardsize=boardsize))\n"}
{"id": 126386, "name": "GUI enabling_disabling of controls", "source": "Translate Ruby to C#: Shoes.app do\n  @number = edit_line\n  @number.change {update_controls}\n\n  @incr = button('Increment') {update_controls(@number.text.to_i + 1)}\n  @decr = button('Decrement') {update_controls(@number.text.to_i - 1)}\n\n  def update_controls(value = @number.text.to_i)\n    @number.text = value\n    @incr.state = value.to_i >= 10 ? \"disabled\" : nil\n    @decr.state = value.to_i <=  0 ? \"disabled\" : nil\n  end\n\n  update_controls 0\nend\n", "target": "using System; \nusing System.ComponentModel; \nusing System.Windows.Forms; \n\nclass RosettaInteractionForm : Form\n{    \n\n    \n    \n    class NumberModel: INotifyPropertyChanged\n    {\n        \n        public event PropertyChangedEventHandler PropertyChanged = delegate {};\n\n        int _value;\n        public int Value\n        {\n            get { return _value; }\n            set \n            { \n                _value = value;\n                \n                PropertyChanged(this, new PropertyChangedEventArgs(\"Value\"));\n            }\n        }\n    }\n\n    NumberModel model = new NumberModel{ Value = 0};\n    \n    RosettaInteractionForm()    \n    {\n        \n        var tbNumber = new MaskedTextBox\n                        { \n                            Mask=\"0000\",            \n                            ResetOnSpace = false,   \n                            Dock = DockStyle.Top    \n                        };\n        \n        tbNumber.DataBindings.Add(\"Text\", model, \"Value\");\n        var enabledIfZero = new Binding(\"Enabled\", model, \"Value\");\n        EnableControlWhen(tbNumber, value => value == 0);\n\n        var btIncrement = new Button{Text = \"Increment\", Dock = DockStyle.Bottom};\n        btIncrement.Click += delegate\n                        {\n                            model.Value++;\n                        };\n        EnableControlWhen(btIncrement, value => value < 10);\n        var btDecrement = new Button{Text = \"Decrement\", Dock = DockStyle.Bottom};\n        btDecrement.Click += delegate\n                        {\n                            model.Value--;\n                        };\n        EnableControlWhen(btDecrement, value => value > 0);\n        Controls.Add(tbNumber);\n        Controls.Add(btIncrement);\n        Controls.Add(btDecrement);\n    }\n\n    \n    void EnableControlWhen(Control ctrl, Func<int, bool> predicate)\n    {\n        \n        var enabledBinding = new Binding(\"Enabled\", model, \"Value\");\n        \n        enabledBinding.Format += (sender, args) =>\n            {\n                \n                if (args.DesiredType != typeof(bool)) return;\n                \n                args.Value = predicate((int)args.Value);\n            };\n        \n        ctrl.DataBindings.Add(enabledBinding);\n    }\n\n    static void Main()\n    {\n        Application.Run(new RosettaInteractionForm());\n    }\n}\n"}
{"id": 126388, "name": "GUI enabling_disabling of controls", "source": "Translate Ruby to Java: Shoes.app do\n  @number = edit_line\n  @number.change {update_controls}\n\n  @incr = button('Increment') {update_controls(@number.text.to_i + 1)}\n  @decr = button('Decrement') {update_controls(@number.text.to_i - 1)}\n\n  def update_controls(value = @number.text.to_i)\n    @number.text = value\n    @incr.state = value.to_i >= 10 ? \"disabled\" : nil\n    @decr.state = value.to_i <=  0 ? \"disabled\" : nil\n  end\n\n  update_controls 0\nend\n", "target": "import java.awt.GridLayout;\nimport java.awt.event.ActionEvent;\nimport java.awt.event.ActionListener;\nimport java.awt.event.KeyEvent;\nimport java.awt.event.KeyListener;\n\nimport javax.swing.JButton;\nimport javax.swing.JFrame;\nimport javax.swing.JPanel;\nimport javax.swing.JTextField;\nimport javax.swing.SwingUtilities;\n\npublic class Interact extends JFrame{\n\tfinal JTextField numberField;\n\tfinal JButton incButton, decButton;\n\t\n\tpublic Interact(){\n\t\t\n\t\tsetDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); \n\t\t\n\t\tnumberField = new JTextField();\n\t\tincButton = new JButton(\"Increment\");\n\t\tdecButton = new JButton(\"Decrement\");\n\t\t\n\t\tnumberField.setText(\"0\");\n\t\tdecButton.setEnabled(false);\n\t\t\n\t\t\n\t\tnumberField.addKeyListener(new KeyListener(){\n\t\t\t@Override\n\t\t\tpublic void keyTyped(KeyEvent e) {\n\t\t\t\t\n\t\t\t\tif(!Character.isDigit(e.getKeyChar())){\n\t\t\t\t\t\n\t\t\t\t\te.consume();\n\t\t\t\t}else if(Character.isDigit(e.getKeyChar())){\n\t\t\t\t\t\n\t\t\t\t\t\n\t\t\t\t\t\n\t\t\t\t\tSwingUtilities.invokeLater(new Runnable() {\n\t\t\t\t\t\t@Override\n\t\t\t\t\t\tpublic void run() {\n\t\t\t\t\t\t\tString text = numberField.getText();\n\t\t\t\t\t\t\tif(text.isEmpty()){\n\t\t\t\t\t\t\t\tnumberField.setText(\"0\");\n\t\t\t\t\t\t\t\tdecButton.setEnabled(false);\n\t\t\t\t\t\t\t\tincButton.setEnabled(true);\n\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(Long.valueOf(text) <= 0){\n\t\t\t\t\t\t\t\tdecButton.setEnabled(false);\n\t\t\t\t\t\t\t\tincButton.setEnabled(true);\n\t\t\t\t\t\t\t}else if(Long.valueOf(text) >= 10){\n\t\t\t\t\t\t\t\tincButton.setEnabled(false);\n\t\t\t\t\t\t\t\tdecButton.setEnabled(true);\n\t\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t\tincButton.setEnabled(true);\n\t\t\t\t\t\t\t\tdecButton.setEnabled(true);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\t\t\t@Override\n\t\t\tpublic void keyReleased(KeyEvent e){}\n\t\t\t@Override\n\t\t\tpublic void keyPressed(KeyEvent e){\n\t\t\t\t\n\t\t\t\t\n\t\t\t\tif(e.getKeyCode() == KeyEvent.VK_BACK_SPACE ||\n\t\t\t\t\t\te.getKeyCode() == KeyEvent.VK_DELETE){\n\t\t\t\t\tSwingUtilities.invokeLater(new Runnable() {\n\t\t\t\t\t\t@Override\n\t\t\t\t\t\tpublic void run() {\n\t\t\t\t\t\t\tString text = numberField.getText();\n\t\t\t\t\t\t\tif(text.isEmpty()){\n\t\t\t\t\t\t\t\tnumberField.setText(\"0\");\n\t\t\t\t\t\t\t\tdecButton.setEnabled(false);\n\t\t\t\t\t\t\t\tincButton.setEnabled(true);\n\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(Long.valueOf(text) <= 0){\n\t\t\t\t\t\t\t\tdecButton.setEnabled(false);\n\t\t\t\t\t\t\t\tincButton.setEnabled(true);\n\t\t\t\t\t\t\t}else if(Long.valueOf(text) >= 10){\n\t\t\t\t\t\t\t\tincButton.setEnabled(false);\n\t\t\t\t\t\t\t\tdecButton.setEnabled(true);\n\t\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t\tincButton.setEnabled(true);\n\t\t\t\t\t\t\t\tdecButton.setEnabled(true);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t\t\n\t\t\n\t\tincButton.addActionListener(new ActionListener(){\n\t\t\t@Override\n\t\t\tpublic void actionPerformed(ActionEvent e) {\n\t\t\t\tString text = numberField.getText();\n\t\t\t\tnumberField.setText((Long.valueOf(text) + 1) + \"\");\n\t\t\t\tif(Long.valueOf(text) + 1 >= 10){\n\t\t\t\t\tincButton.setEnabled(false);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(Long.valueOf(text) + 1 > 0){\n\t\t\t\t\tdecButton.setEnabled(true);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t\t\n\t\t\n\t\tdecButton.addActionListener(new ActionListener(){\n\t\t\t@Override\n\t\t\tpublic void actionPerformed(ActionEvent e) {\n\t\t\t\tString text = numberField.getText();\n\t\t\t\tnumberField.setText((Long.valueOf(text) - 1) + \"\");\n\t\t\t\tif(Long.valueOf(text) - 1 <= 0){\n\t\t\t\t\tdecButton.setEnabled(false);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(Long.valueOf(text) - 1 < 10){\n\t\t\t\t\tincButton.setEnabled(true);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t\t\n\t\t\n\t\tsetLayout(new GridLayout(2, 1));\n\t\t\n\t\t\n\t\tJPanel buttonPanel = new JPanel();\n\t\t\n\t\t\n\t\tbuttonPanel.setLayout(new GridLayout(1, 2));\n\t\t\n\t\tbuttonPanel.add(incButton);\n\t\tbuttonPanel.add(decButton);\n\t\t\n\t\t\n\t\tadd(numberField);\n\t\tadd(buttonPanel);\n\t\t\n\t\tpack();\n\t\t\n\t}\n\n\tpublic static void main(String[] args){\n\t\tnew Interact().setVisible(true);\n\t}\n}\n"}
{"id": 126389, "name": "GUI enabling_disabling of controls", "source": "Translate Ruby to Python: Shoes.app do\n  @number = edit_line\n  @number.change {update_controls}\n\n  @incr = button('Increment') {update_controls(@number.text.to_i + 1)}\n  @decr = button('Decrement') {update_controls(@number.text.to_i - 1)}\n\n  def update_controls(value = @number.text.to_i)\n    @number.text = value\n    @incr.state = value.to_i >= 10 ? \"disabled\" : nil\n    @decr.state = value.to_i <=  0 ? \"disabled\" : nil\n  end\n\n  update_controls 0\nend\n", "target": "\n\nimport tkinter as tk\n\nclass MyForm(tk.Frame):\n\n    def __init__(self, master=None):\n        tk.Frame.__init__(self, master)\n        self.pack(expand=True, fill=\"both\", padx=10, pady=10)\n        self.master.title(\"Controls\")\n        self.setupUI()\n\n    def setupUI(self):\n        self.value_entry = tk.Entry(self, justify=tk.CENTER)\n        self.value_entry.grid(row=0, column=0, columnspan=2,\n                              padx=5, pady=5, sticky=\"nesw\")\n        self.value_entry.insert('end', '0')\n        self.value_entry.bind(\"<KeyPress-Return>\", self.eventHandler)\n\n        self.decre_btn = tk.Button(self, text=\"Decrement\", state=tk.DISABLED)\n        self.decre_btn.grid(row=1, column=0, padx=5, pady=5)\n        self.decre_btn.bind(\"<Button-1>\", self.eventHandler)\n\n        self.incre_btn = tk.Button(self, text=\"Increment\")\n        self.incre_btn.grid(row=1, column=1, padx=5, pady=5)\n        self.incre_btn.bind(\"<Button-1>\", self.eventHandler)\n\n    def eventHandler(self, event):\n        value = int(self.value_entry.get())\n        if event.widget == self.value_entry:\n            if value > 10:\n                self.value_entry.delete(\"0\", \"end\")\n                self.value_entry.insert(\"end\", \"0\")\n            elif value == 10:\n                self.value_entry.config(state=tk.DISABLED)\n                self.incre_btn.config(state=tk.DISABLED)\n                self.decre_btn.config(state=tk.NORMAL)\n            elif value == 0:\n                self.value_entry.config(state=tk.NORMAL)\n                self.incre_btn.config(state=tk.NORMAL)\n                self.decre_btn.config(state=tk.DISABLED)\n            elif (value > 0) and (value < 10):\n                self.value_entry.config(state=tk.DISABLED)\n                self.incre_btn.config(state=tk.NORMAL)\n                self.decre_btn.config(state=tk.NORMAL)\n        else:\n            if event.widget == self.incre_btn:\n                if (value >= 0) and (value < 10):\n                    value += 1\n                    self.value_entry.config(state=tk.NORMAL)\n                    self.value_entry.delete(\"0\", \"end\")\n                    self.value_entry.insert(\"end\", str(value))\n                if value > 0:\n                    self.decre_btn.config(state=tk.NORMAL)\n                    self.value_entry.config(state=tk.DISABLED)\n                if value == 10:\n                    self.incre_btn.config(state=tk.DISABLED)\n            elif event.widget == self.decre_btn:\n                if (value > 0) and (value <= 10):\n                    value -= 1\n                    self.value_entry.config(state=tk.NORMAL)\n                    self.value_entry.delete(\"0\", \"end\")\n                    self.value_entry.insert(\"end\", str(value))\n                    self.value_entry.config(state=tk.DISABLED)\n                if (value) < 10:\n                    self.incre_btn.config(state=tk.NORMAL)\n                if (value) == 0:\n                    self.decre_btn.config(state=tk.DISABLED)\n                    self.value_entry.config(state=tk.NORMAL)\n\ndef main():\n    app = MyForm()\n    app.mainloop()\n\nif __name__ == \"__main__\":\n    main()\n"}
{"id": 126537, "name": "Singly-linked list_Element insertion", "source": "Translate Ruby to C#: class ListNode\n  def insert_after(search_value, new_value)\n    if search_value == value\n      self.succ = self.class.new(new_value, succ)\n    elsif self.succ.nil?\n      raise StandardError, \"value \n    else\n      self.succ.insert_after(search_value, new_value)\n    end\n  end\nend\n\nlist = ListNode.new(:a, ListNode.new(:b))\nlist.insert_after(:a, :c)\n", "target": "static void InsertAfter<T>(LinkedListNode<T> prev, T value)\n{\n    prev.Next = new Link() { Value = value, Next = prev.Next };\n}\n"}
{"id": 126539, "name": "Singly-linked list_Element insertion", "source": "Translate Ruby to Java: class ListNode\n  def insert_after(search_value, new_value)\n    if search_value == value\n      self.succ = self.class.new(new_value, succ)\n    elsif self.succ.nil?\n      raise StandardError, \"value \n    else\n      self.succ.insert_after(search_value, new_value)\n    end\n  end\nend\n\nlist = ListNode.new(:a, ListNode.new(:b))\nlist.insert_after(:a, :c)\n", "target": "void insertNode(Node<T> anchor_node, Node<T> new_node)\n{\n    new_node.next = anchor_node.next;\n    anchor_node.next = new_node;\n}\n"}
{"id": 126540, "name": "Singly-linked list_Element insertion", "source": "Translate Ruby to Python: class ListNode\n  def insert_after(search_value, new_value)\n    if search_value == value\n      self.succ = self.class.new(new_value, succ)\n    elsif self.succ.nil?\n      raise StandardError, \"value \n    else\n      self.succ.insert_after(search_value, new_value)\n    end\n  end\nend\n\nlist = ListNode.new(:a, ListNode.new(:b))\nlist.insert_after(:a, :c)\n", "target": "def chain_insert(lst, at, item):\n    while lst is not None:\n        if lst[0] == at:\n            lst[1] = [item, lst[1]]\n            return\n        else:\n            lst = lst[1]\n    raise ValueError(str(at) + \" not found\")\n\nchain = ['A', ['B', None]]\nchain_insert(chain, 'A', 'C')\nprint chain\n"}
{"id": 126651, "name": "Variable-length quantity", "source": "Translate Ruby to C#: [0x200000, 0x1fffff].each do |i|\n  \n  ber = [i].pack(\"w\")\n  hex = ber.unpack(\"C*\").collect {|c| \"%02x\" % c}.join(\":\")\n  printf \"%s => %s\\n\", i, hex\n\n  \n  j = ber.unpack(\"w\").first\n  i == j or fail \"BER not preserve integer\"\nend\n", "target": "namespace Vlq\n{\n  using System;\n  using System.Collections.Generic;\n  using System.Linq;\n\n  public static class VarLenQuantity\n  {\n    public static ulong ToVlq(ulong integer)\n    {\n      var array = new byte[8];\n      var buffer = ToVlqCollection(integer)\n        .SkipWhile(b => b == 0)\n        .Reverse()\n        .ToArray();\n      Array.Copy(buffer, array, buffer.Length);\n      return BitConverter.ToUInt64(array, 0);\n    }\n\n    public static ulong FromVlq(ulong integer)\n    {\n      var collection = BitConverter.GetBytes(integer).Reverse();\n      return FromVlqCollection(collection);\n    }\n\n    public static IEnumerable<byte> ToVlqCollection(ulong integer)\n    {\n      if (integer > Math.Pow(2, 56))\n        throw new OverflowException(\"Integer exceeds max value.\");\n\n      var index = 7;\n      var significantBitReached = false;\n      var mask = 0x7fUL << (index * 7);\n      while (index >= 0)\n      {\n        var buffer = (mask & integer);\n        if (buffer > 0 || significantBitReached)\n        {\n          significantBitReached = true;\n          buffer >>= index * 7;\n          if (index > 0)\n            buffer |= 0x80;\n          yield return (byte)buffer;\n        }\n        mask >>= 7;\n        index--;\n      }\n    }\n\n\n    public static ulong FromVlqCollection(IEnumerable<byte> vlq)\n    {\n      ulong integer = 0;\n      var significantBitReached = false;\n\n      using (var enumerator = vlq.GetEnumerator())\n      {\n        int index = 0;\n        while (enumerator.MoveNext())\n        {\n          var buffer = enumerator.Current;\n          if (buffer > 0 || significantBitReached)\n          {\n            significantBitReached = true;\n            integer <<= 7;\n            integer |= (buffer & 0x7fUL);\n          }\n\n          if (++index == 8 || (significantBitReached && (buffer & 0x80) != 0x80))\n            break;\n        }\n      }\n      return integer;\n    }\n\n    public static void Main()\n    {\n      var integers = new ulong[] { 0x7fUL << 7 * 7, 0x80, 0x2000, 0x3FFF, 0x4000, 0x200000, 0x1fffff };\n\n      foreach (var original in integers)\n      {\n        Console.WriteLine(\"Original: 0x{0:X}\", original);\n\n        \n        var seq = ToVlqCollection(original);\n        Console.WriteLine(\"Sequence: 0x{0}\", seq.Select(b => b.ToString(\"X2\")).Aggregate(string.Concat));\n\n        var decoded = FromVlqCollection(seq);\n        Console.WriteLine(\"Decoded: 0x{0:X}\", decoded);\n\n        \n        var encoded = ToVlq(original);\n        Console.WriteLine(\"Encoded: 0x{0:X}\", encoded);\n\n        decoded = FromVlq(encoded);\n        Console.WriteLine(\"Decoded: 0x{0:X}\", decoded);\n\n        Console.WriteLine();\n      }\n      Console.WriteLine(\"Press any key to continue...\");\n      Console.ReadKey();\n    }\n  }\n}\n"}
{"id": 126653, "name": "Variable-length quantity", "source": "Translate Ruby to Java: [0x200000, 0x1fffff].each do |i|\n  \n  ber = [i].pack(\"w\")\n  hex = ber.unpack(\"C*\").collect {|c| \"%02x\" % c}.join(\":\")\n  printf \"%s => %s\\n\", i, hex\n\n  \n  j = ber.unpack(\"w\").first\n  i == j or fail \"BER not preserve integer\"\nend\n", "target": "public class VLQCode\n{\n  public static byte[] encode(long n)\n  {\n    int numRelevantBits = 64 - Long.numberOfLeadingZeros(n);\n    int numBytes = (numRelevantBits + 6) / 7;\n    if (numBytes == 0)\n      numBytes = 1;\n    byte[] output = new byte[numBytes];\n    for (int i = numBytes - 1; i >= 0; i--)\n    {\n      int curByte = (int)(n & 0x7F);\n      if (i != (numBytes - 1))\n        curByte |= 0x80;\n      output[i] = (byte)curByte;\n      n >>>= 7;\n    }\n    return output;\n  }\n  \n  public static long decode(byte[] b)\n  {\n    long n = 0;\n    for (int i = 0; i < b.length; i++)\n    {\n      int curByte = b[i] & 0xFF;\n      n = (n << 7) | (curByte & 0x7F);\n      if ((curByte & 0x80) == 0)\n        break;\n    }\n    return n;\n  }\n  \n  public static String byteArrayToString(byte[] b)\n  {\n    StringBuilder sb = new StringBuilder();\n    for (int i = 0; i < b.length; i++)\n    {\n      if (i > 0)\n        sb.append(\", \");\n      String s = Integer.toHexString(b[i] & 0xFF);\n      if (s.length() < 2)\n        s = \"0\" + s;\n      sb.append(s);\n    }\n    return sb.toString();\n  }\n  \n  public static void main(String[] args)\n  {\n    long[] testNumbers = { 2097152, 2097151, 1, 127, 128, 589723405834L };\n    for (long n : testNumbers)\n    {\n      byte[] encoded = encode(n);\n      long decoded = decode(encoded);\n      System.out.println(\"Original input=\" + n + \", encoded = [\" + byteArrayToString(encoded) + \"], decoded=\" + decoded + \", \" + ((n == decoded) ? \"OK\" : \"FAIL\"));\n    }\n  }\n}\n"}
{"id": 126654, "name": "Variable-length quantity", "source": "Translate Ruby to Python: [0x200000, 0x1fffff].each do |i|\n  \n  ber = [i].pack(\"w\")\n  hex = ber.unpack(\"C*\").collect {|c| \"%02x\" % c}.join(\":\")\n  printf \"%s => %s\\n\", i, hex\n\n  \n  j = ber.unpack(\"w\").first\n  i == j or fail \"BER not preserve integer\"\nend\n", "target": "def tobits(n, _group=8, _sep='_', _pad=False):\n    'Express n as binary bits with separator'\n    bits = '{0:b}'.format(n)[::-1]\n    if _pad:\n        bits = '{0:0{1}b}'.format(n,\n                                  ((_group+len(bits)-1)//_group)*_group)[::-1]\n        answer = _sep.join(bits[i:i+_group]\n                                 for i in range(0, len(bits), _group))[::-1]\n        answer = '0'*(len(_sep)-1) + answer\n    else:\n        answer = _sep.join(bits[i:i+_group]\n                           for i in range(0, len(bits), _group))[::-1]\n    return answer\n\ndef tovlq(n):\n    return tobits(n, _group=7, _sep='1_', _pad=True)\n\ndef toint(vlq):\n    return int(''.join(vlq.split('_1')), 2)    \n\ndef vlqsend(vlq):\n    for i, byte in enumerate(vlq.split('_')[::-1]):\n        print('Sent byte {0:3}: {1:\n"}
{"id": 126735, "name": "Sudan function", "source": "Translate Ruby to C#: def sudan(n, x, y)\n  return x + y if n == 0\n  return x if y == 0\n\n  sudan(n - 1, sudan(n, x, y - 1), sudan(n, x, y - 1) + y)\nend\n", "target": "\n\nusing System;\n\nnamespace Sudan\n{\n  class Sudan\n  {\n  \tstatic int F(int n,int x,int y) {\n  \t\tif (n == 0) {\n    \t\treturn x + y;\n  \t\t}\n \n  \t\telse if (y == 0) {\n    \t\treturn x;\n  \t\t}\n \n  \t\treturn F(n - 1, F(n, x, y - 1), F(n, x, y - 1) + y);\n\t}\n    \n    static void Main(string[] args)\n    {\n      Console.WriteLine(\"F(1,3,3) = \" + F(1,3,3));    \n    }\n  }\n}\n"}
{"id": 126737, "name": "Sudan function", "source": "Translate Ruby to Java: def sudan(n, x, y)\n  return x + y if n == 0\n  return x if y == 0\n\n  sudan(n - 1, sudan(n, x, y - 1), sudan(n, x, y - 1) + y)\nend\n", "target": "\n\npublic class Main {\n\n  private static int F(int n,int x,int y) {\n  \tif (n == 0) {\n    \treturn x + y;\n  \t}\n \n \t else if (y == 0) {\n    \treturn x;\n  \t}\n \n  \treturn F(n - 1, F(n, x, y - 1), F(n, x, y - 1) + y);\n }\n\n  public static void main(String[] args) {\n    System.out.println(\"F(1,3,3) = \" + F(1,3,3));\n  }\n}\n"}
{"id": 126738, "name": "Sudan function", "source": "Translate Ruby to Python: def sudan(n, x, y)\n  return x + y if n == 0\n  return x if y == 0\n\n  sudan(n - 1, sudan(n, x, y - 1), sudan(n, x, y - 1) + y)\nend\n", "target": "\n\ndef F(n,x,y):\n  if n==0:\n    return x + y\n  elif y==0:\n    return x\n  else:\n    return F(n - 1, F(n, x, y - 1), F(n, x, y - 1) + y)\n    \n    \nprint(\"F(1,3,3) = \", F(1,3,3))\n"}
{"id": 126949, "name": "Classes", "source": "Translate Ruby to C#: class MyClass\n  \n  def initialize\n    @instance_var = 0\n  end\n \n  def add_1\n    @instance_var += 1\n  end\n\nend\n \nmy_class = MyClass.new \n", "target": "public class MyClass\n{\n    public MyClass()\n    {\n    }\n    public void SomeMethod()\n    {\n    }\n    private int _variable;\n    public int Variable\n    {\n        get { return _variable; }\n        set { _variable = value; }\n    }\n    public static void Main()\n    {\n        \n        MyClass instance = new MyClass();\n        \n        instance.SomeMethod();\n        \n        instance.Variable = 99;\n        \n        System.Console.WriteLine( \"Variable=\" + instance.Variable.ToString() );\n    }\n}\n"}
{"id": 126951, "name": "Classes", "source": "Translate Ruby to Java: class MyClass\n  \n  def initialize\n    @instance_var = 0\n  end\n \n  def add_1\n    @instance_var += 1\n  end\n\nend\n \nmy_class = MyClass.new \n", "target": "public class MyClass{\n\n  \n  private int variable;  \n\n  \n  public MyClass(){\n    \n  }\n\n  \n  public void someMethod(){\n   this.variable = 1;\n  }\n}\n"}
{"id": 126952, "name": "Classes", "source": "Translate Ruby to Python: class MyClass\n  \n  def initialize\n    @instance_var = 0\n  end\n \n  def add_1\n    @instance_var += 1\n  end\n\nend\n \nmy_class = MyClass.new \n", "target": "class MyClass:\n    name2 = 2 \n\n    def __init__(self):\n        \n        self.name1 = 0 \n  \n    def someMethod(self):\n        \n        self.name1 = 1\n        MyClass.name2 = 3\n  \n  \nmyclass = MyClass() \n\nclass MyOtherClass:\n    count = 0  \n    def __init__(self, name, gender=\"Male\", age=None):\n        \n        MyOtherClass.count += 1\n        self.name = name\n        self.gender = gender\n        if age is not None:\n            self.age = age\n    def __del__(self):\n        MyOtherClass.count -= 1\n\nperson1 = MyOtherClass(\"John\")\nprint person1.name, person1.gender  \nprint person1.age                   \nperson2 = MyOtherClass(\"Jane\", \"Female\", 23)\nprint person2.name, person2.gender, person2.age  \n"}
{"id": 127176, "name": "Long multiplication", "source": "Translate Ruby to C#: require \"big\"\n\na = 2.to_big_i ** 64\n\nputs \"\n", "target": "using System;\nusing static System.Console;\nusing BI = System.Numerics.BigInteger;\n\nclass Program {\n\n  static decimal mx = 1E28M, hm = 1E14M, a;\n\n  \n  struct bi { public decimal hi, lo; }\n\n  \n  static bi set4sq(decimal a) { bi r; r.hi = Math.Floor(a / hm); r.lo = a % hm; return r; }\n\n  \n  static string toStr(bi a, bool comma = false) {\n    string r = a.hi == 0 ? string.Format(\"{0:0}\", a.lo) :\n                           string.Format(\"{0:0}{1:\" + new string('0', 28) + \"}\", a.hi, a.lo);\n    if (!comma) return r;  string rc = \"\";\n    for (int i = r.Length - 3; i > 0; i -= 3) rc = \",\" + r.Substring(i, 3) + rc;\n    return r.Substring(0, ((r.Length + 2) % 3) + 1) + rc; }\n\n  \n  static decimal Pow_dec(decimal bas, uint exp) {\n    if (exp == 0) return 1M; decimal tmp = Pow_dec(bas, exp >> 1); tmp *= tmp;\n    if ((exp & 1) == 0) return tmp; return tmp * bas; }\n\n  static void Main(string[] args) {\n    for (uint p = 64; p < 95; p += 30) {        \n      bi x = set4sq(a = Pow_dec(2M, p)), y;     \n      WriteLine(\"The square of (2^{0}):                    {1,38:n0}\", p, a); BI BS = BI.Pow((BI)a, 2);\n      y.lo = x.lo * x.lo; y.hi = x.hi * x.hi;   \n      a = x.hi * x.lo * 2M;                     \n      y.hi += Math.Floor(a / hm);               \n      y.lo += (a % hm) * hm;                    \n      while (y.lo > mx) { y.lo -= mx; y.hi++; } \n      WriteLine(\" is {0,75} (which {1} match the BigInteger computation)\\n\", toStr(y, true),\n          BS.ToString() == toStr(y) ? \"does\" : \"fails to\"); } }\n\n}\n"}
{"id": 127178, "name": "Long multiplication", "source": "Translate Ruby to Java: require \"big\"\n\na = 2.to_big_i ** 64\n\nputs \"\n", "target": "public class LongMult {\n\n\tprivate static byte[] stringToDigits(String num) {\n\t\tbyte[] result = new byte[num.length()];\n\t\tfor (int i = 0; i < num.length(); i++) {\n\t\t\tchar c = num.charAt(i);\n\t\t\tif (c < '0' || c > '9') {\n\t\t\t\tthrow new IllegalArgumentException(\"Invalid digit \" + c\n\t\t\t\t\t\t+ \" found at position \" + i);\n\t\t\t}\n\t\t\tresult[num.length() - 1 - i] = (byte) (c - '0');\n\t\t}\n\t\treturn result;\n\t}\n\n\tpublic static String longMult(String num1, String num2) {\n\t\tbyte[] left = stringToDigits(num1);\n\t\tbyte[] right = stringToDigits(num2);\n\t\tbyte[] result = new byte[left.length + right.length];\n\t\tfor (int rightPos = 0; rightPos < right.length; rightPos++) {\n\t\t\tbyte rightDigit = right[rightPos];\n\t\t\tbyte temp = 0;\n\t\t\tfor (int leftPos = 0; leftPos < left.length; leftPos++) {\n\t\t\t\ttemp += result[leftPos + rightPos];\n\t\t\t\ttemp += rightDigit * left[leftPos];\n\t\t\t\tresult[leftPos + rightPos] = (byte) (temp % 10);\n\t\t\t\ttemp /= 10;\n\t\t\t}\n\t\t\tint destPos = rightPos + left.length;\n\t\t\twhile (temp != 0) {\n\t\t\t\ttemp += result[destPos] & 0xFFFFFFFFL;\n\t\t\t\tresult[destPos] = (byte) (temp % 10);\n\t\t\t\ttemp /= 10;\n\t\t\t\tdestPos++;\n\t\t\t}\n\t\t}\n\t\tStringBuilder stringResultBuilder = new StringBuilder(result.length);\n\t\tfor (int i = result.length - 1; i >= 0; i--) {\n\t\t\tbyte digit = result[i];\n\t\t\tif (digit != 0 || stringResultBuilder.length() > 0) {\n\t\t\t\tstringResultBuilder.append((char) (digit + '0'));\n\t\t\t}\n\t\t}\n\t\treturn stringResultBuilder.toString();\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tSystem.out.println(longMult(\"18446744073709551616\",\n\t\t\t\t\"18446744073709551616\"));\n\t}\n}\n"}
{"id": 127610, "name": "Detect division by zero", "source": "Translate Ruby to C#: def div_check(x, y)\n  begin\n    x / y\n  rescue ZeroDivisionError\n    true\n  else\n    false\n  end\nend\n", "target": "using System;\n\nnamespace RosettaCode {\n    class Program {\n        static void Main(string[] args) {\n            int x = 1;\n            int y = 0;\n            try {\n               int z = x / y;\n            } catch (DivideByZeroException e) {\n                Console.WriteLine(e);\n            }\n            \n        }\n    }\n}\n"}
{"id": 127611, "name": "Detect division by zero", "source": "Translate Ruby to C#: def div_check(x, y)\n  begin\n    x / y\n  rescue ZeroDivisionError\n    true\n  else\n    false\n  end\nend\n", "target": "using System;\n\nnamespace RosettaCode {\n    class Program {\n        static void Main(string[] args) {\n            int x = 1;\n            int y = 0;\n            try {\n               int z = x / y;\n            } catch (DivideByZeroException e) {\n                Console.WriteLine(e);\n            }\n            \n        }\n    }\n}\n"}
{"id": 127614, "name": "Detect division by zero", "source": "Translate Ruby to Java: def div_check(x, y)\n  begin\n    x / y\n  rescue ZeroDivisionError\n    true\n  else\n    false\n  end\nend\n", "target": "public static boolean infinity(double numer, double denom){\n\treturn Double.isInfinite(numer/denom);\n}\n"}
{"id": 127615, "name": "Detect division by zero", "source": "Translate Ruby to Java: def div_check(x, y)\n  begin\n    x / y\n  rescue ZeroDivisionError\n    true\n  else\n    false\n  end\nend\n", "target": "public static boolean infinity(double numer, double denom){\n\treturn Double.isInfinite(numer/denom);\n}\n"}
{"id": 127616, "name": "Detect division by zero", "source": "Translate Ruby to Python: def div_check(x, y)\n  begin\n    x / y\n  rescue ZeroDivisionError\n    true\n  else\n    false\n  end\nend\n", "target": "def div_check(x, y):\n  try:\n    x / y\n  except ZeroDivisionError:\n    return True\n  else:\n    return False\n"}
{"id": 127617, "name": "Detect division by zero", "source": "Translate Ruby to Python: def div_check(x, y)\n  begin\n    x / y\n  rescue ZeroDivisionError\n    true\n  else\n    false\n  end\nend\n", "target": "def div_check(x, y):\n  try:\n    x / y\n  except ZeroDivisionError:\n    return True\n  else:\n    return False\n"}
{"id": 127823, "name": "Mouse position", "source": "Translate Ruby to C#: Shoes.app(:title => \"Mouse Position\", :width => 400, :height => 400) do\n  @position = para \"Position\u00a0:\u00a0?,\u00a0?\", :size => 12, :margin => 10\n  \n  motion do |x, y|\n    @position.text = \"Position\u00a0: \n  end\nend\n", "target": "using System;\nusing System.Windows.Forms;\nstatic class Program\n{\n    [STAThread]\n    static void Main()\n    {\n        Console.WriteLine(Control.MousePosition.X);\n        Console.WriteLine(Control.MousePosition.Y);\n    }\n}\n"}
{"id": 127824, "name": "Mouse position", "source": "Translate Ruby to Java: Shoes.app(:title => \"Mouse Position\", :width => 400, :height => 400) do\n  @position = para \"Position\u00a0:\u00a0?,\u00a0?\", :size => 12, :margin => 10\n  \n  motion do |x, y|\n    @position.text = \"Position\u00a0: \n  end\nend\n", "target": "Point mouseLocation = MouseInfo.getPointerInfo().getLocation();\n"}
{"id": 127825, "name": "Mouse position", "source": "Translate Ruby to Python: Shoes.app(:title => \"Mouse Position\", :width => 400, :height => 400) do\n  @position = para \"Position\u00a0:\u00a0?,\u00a0?\", :size => 12, :margin => 10\n  \n  motion do |x, y|\n    @position.text = \"Position\u00a0: \n  end\nend\n", "target": "def setup():\n    size(640, 480)\n\ndef draw():\n    \n    ellipse(mouseX, mouseY, 5, 5) \n    println(\"x:{} y:{}\".format(mouseX, mouseY))\n"}
{"id": 127916, "name": "Terminal control_Hiding the cursor", "source": "Translate Ruby to C#: require \"curses\"\ninclude Curses\n\ninit_screen\nbegin\n  curs_set(1) \n  sleep 3\n  curs_set(0) \n  sleep 3\n  curs_set(1) \n  sleep 3\nensure\n  close_screen\nend\n", "target": "static void Main(string[] args)\n{\n    Console.Write(\"At the end of this line you will see the cursor, process will sleep for 5 seconds.\");\n    System.Threading.Thread.Sleep(5000);\n    Console.CursorVisible = false;\n    Console.WriteLine();\n    Console.Write(\"At the end of this line you will not see the cursor, process will sleep for 5 seconds.\");\n    System.Threading.Thread.Sleep(5000);\n}\n"}
{"id": 127918, "name": "Terminal control_Hiding the cursor", "source": "Translate Ruby to Python: require \"curses\"\ninclude Curses\n\ninit_screen\nbegin\n  curs_set(1) \n  sleep 3\n  curs_set(0) \n  sleep 3\n  curs_set(1) \n  sleep 3\nensure\n  close_screen\nend\n", "target": "print(\"\\x1b[?25l\") \nprint(\"\\x1b[?25h\") \n"}
{"id": 128124, "name": "Simple windowed application", "source": "Translate Ruby to C#: require 'tk'\nstr = TkVariable.new(\"no clicks yet\")\ncount = 0\nroot = TkRoot.new\nTkLabel.new(root, \"textvariable\" => str).pack\nTkButton.new(root) do\n  text \"click me\"\n  command {str.value = count += 1}\n  pack\nend\nTk.mainloop\n", "target": "using System.Windows.Forms;\n\nclass RosettaForm : Form\n{\n    RosettaForm()\n    {\n        var clickCount = 0;\n\n        var label = new Label();\n        label.Text = \"There have been no clicks yet.\";\n        label.Dock = DockStyle.Top;\n        Controls.Add(label);\n\n        var button = new Button();\n        button.Text = \"Click Me\";\n        button.Dock = DockStyle.Bottom;\n        button.Click += delegate\n                        {\n                            clickCount++;\n                            label.Text = \"Number of clicks: \" + clickCount + \".\";\n                        };\n        Controls.Add(button);\n    }\n\n    static void Main()\n    {\n        Application.Run(new RosettaForm());\n    }\n}\n"}
{"id": 128126, "name": "Simple windowed application", "source": "Translate Ruby to Java: require 'tk'\nstr = TkVariable.new(\"no clicks yet\")\ncount = 0\nroot = TkRoot.new\nTkLabel.new(root, \"textvariable\" => str).pack\nTkButton.new(root) do\n  text \"click me\"\n  command {str.value = count += 1}\n  pack\nend\nTk.mainloop\n", "target": "import java.awt.BorderLayout;\nimport java.awt.Dimension;\nimport java.awt.event.ActionEvent;\nimport java.awt.event.ActionListener;\nimport javax.swing.JButton;\nimport javax.swing.JFrame;\nimport javax.swing.JLabel;\nimport javax.swing.SwingUtilities;\npublic class Clicks extends JFrame{\n\tprivate long clicks = 0;\n\n\tpublic Clicks(){\n\t\tsuper(\"Clicks\");\n\t\tJLabel label = new JLabel(\"There have been no clicks yet\");\n\t\tJButton clicker = new JButton(\"click me\");\n\t\tclicker.addActionListener(\n\t\t\tnew ActionListener(){\n\t\t\t\t@Override\n\t\t\t\tpublic void actionPerformed(ActionEvent e) {\n\t\t\t\t\tlabel.setText(\"There have been \" + (++clicks) + \" clicks\");\n\t\t\t\t}\n\t\t\t}\n\t\t);\n\t\tsetLayout(new BorderLayout());\n\t\tadd(label,BorderLayout.CENTER);\n\t\tadd(clicker,BorderLayout.SOUTH);\n\t\tlabel.setPreferredSize(new Dimension(300,100));\n\t\tlabel.setHorizontalAlignment(JLabel.CENTER);\n\t\tpack();\n\t\tsetDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n\t\tsetVisible(true);\n\t}\n\tpublic static void main(String[] args){\n\t\tSwingUtilities.invokeLater( \n\t\t\t() -> new Clicks() \n\t\t);\n\t}\n}\n"}
{"id": 128127, "name": "Simple windowed application", "source": "Translate Ruby to Python: require 'tk'\nstr = TkVariable.new(\"no clicks yet\")\ncount = 0\nroot = TkRoot.new\nTkLabel.new(root, \"textvariable\" => str).pack\nTkButton.new(root) do\n  text \"click me\"\n  command {str.value = count += 1}\n  pack\nend\nTk.mainloop\n", "target": "from functools import partial\nimport tkinter as tk\n\ndef on_click(label: tk.Label,\n             counter: tk.IntVar) -> None:\n    counter.set(counter.get() + 1)\n    label[\"text\"] = f\"Number of clicks: {counter.get()}\"\n\ndef main():\n    window = tk.Tk()\n    window.geometry(\"200x50+100+100\")\n    label = tk.Label(master=window,\n                     text=\"There have been no clicks yet\")\n    label.pack()\n    counter = tk.IntVar()\n    update_counter = partial(on_click,\n                             label=label,\n                             counter=counter)\n    button = tk.Button(master=window,\n                       text=\"click me\",\n                       command=update_counter)\n    button.pack()\n    window.mainloop()\n\nif __name__ == '__main__':\n    main()\n"}
{"id": 128570, "name": "Roman numerals_Encode", "source": "Translate Ruby to C#: Symbols = { 1=>'I', 5=>'V', 10=>'X', 50=>'L', 100=>'C', 500=>'D', 1000=>'M' }\nSubtractors = [ [1000, 100], [500, 100], [100, 10], [50, 10], [10, 1], [5, 1], [1, 0] ]\n\ndef roman(num)\n  return Symbols[num]  if Symbols.has_key?(num)\n  Subtractors.each do |cutPoint, subtractor| \n    return roman(cutPoint) + roman(num - cutPoint)      if num >  cutPoint\n    return roman(subtractor) + roman(num + subtractor)  if num >= cutPoint - subtractor and num < cutPoint\n  end\nend\n\n[1990, 2008, 1666].each do |i|\n  puts \"%4d => %s\" % [i, roman(i)]\nend\n", "target": "using System;\nclass Program\n{\n    static uint[] nums = { 1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1 };\n    static string[] rum = { \"M\", \"CM\", \"D\", \"CD\", \"C\", \"XC\", \"L\", \"XL\", \"X\", \"IX\", \"V\", \"IV\", \"I\" };\n\n    static string ToRoman(uint number)\n    {\n        string value = \"\";\n        for (int i = 0; i < nums.Length && number != 0; i++)\n        {\n            while (number >= nums[i])\n            {\n                number -= nums[i];\n                value += rum[i];\n            }\n        }\n        return value;\n    }\n\n    static void Main()\n    {\n        for (uint number = 1; number <= 1 << 10; number *= 2)\n        {\n            Console.WriteLine(\"{0} = {1}\", number, ToRoman(number));\n        }\n    }\n}\n"}
{"id": 128571, "name": "Roman numerals_Encode", "source": "Translate Ruby to C#: Symbols = { 1=>'I', 5=>'V', 10=>'X', 50=>'L', 100=>'C', 500=>'D', 1000=>'M' }\nSubtractors = [ [1000, 100], [500, 100], [100, 10], [50, 10], [10, 1], [5, 1], [1, 0] ]\n\ndef roman(num)\n  return Symbols[num]  if Symbols.has_key?(num)\n  Subtractors.each do |cutPoint, subtractor| \n    return roman(cutPoint) + roman(num - cutPoint)      if num >  cutPoint\n    return roman(subtractor) + roman(num + subtractor)  if num >= cutPoint - subtractor and num < cutPoint\n  end\nend\n\n[1990, 2008, 1666].each do |i|\n  puts \"%4d => %s\" % [i, roman(i)]\nend\n", "target": "using System;\nclass Program\n{\n    static uint[] nums = { 1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1 };\n    static string[] rum = { \"M\", \"CM\", \"D\", \"CD\", \"C\", \"XC\", \"L\", \"XL\", \"X\", \"IX\", \"V\", \"IV\", \"I\" };\n\n    static string ToRoman(uint number)\n    {\n        string value = \"\";\n        for (int i = 0; i < nums.Length && number != 0; i++)\n        {\n            while (number >= nums[i])\n            {\n                number -= nums[i];\n                value += rum[i];\n            }\n        }\n        return value;\n    }\n\n    static void Main()\n    {\n        for (uint number = 1; number <= 1 << 10; number *= 2)\n        {\n            Console.WriteLine(\"{0} = {1}\", number, ToRoman(number));\n        }\n    }\n}\n"}
{"id": 128574, "name": "Roman numerals_Encode", "source": "Translate Ruby to Java: Symbols = { 1=>'I', 5=>'V', 10=>'X', 50=>'L', 100=>'C', 500=>'D', 1000=>'M' }\nSubtractors = [ [1000, 100], [500, 100], [100, 10], [50, 10], [10, 1], [5, 1], [1, 0] ]\n\ndef roman(num)\n  return Symbols[num]  if Symbols.has_key?(num)\n  Subtractors.each do |cutPoint, subtractor| \n    return roman(cutPoint) + roman(num - cutPoint)      if num >  cutPoint\n    return roman(subtractor) + roman(num + subtractor)  if num >= cutPoint - subtractor and num < cutPoint\n  end\nend\n\n[1990, 2008, 1666].each do |i|\n  puts \"%4d => %s\" % [i, roman(i)]\nend\n", "target": "public class RN {\n\n    enum Numeral {\n        I(1), IV(4), V(5), IX(9), X(10), XL(40), L(50), XC(90), C(100), CD(400), D(500), CM(900), M(1000);\n        int weight;\n\n        Numeral(int weight) {\n            this.weight = weight;\n        }\n    };\n\n    public static String roman(long n) {\n        \n        if( n <= 0) {\n            throw new IllegalArgumentException();\n        }\n        \n        StringBuilder buf = new StringBuilder();\n\n        final Numeral[] values = Numeral.values();\n        for (int i = values.length - 1; i >= 0; i--) {\n            while (n >= values[i].weight) {\n                buf.append(values[i]);\n                n -= values[i].weight;\n            }\n        }\n        return buf.toString();\n    }\n\n    public static void test(long n) {\n        System.out.println(n + \" = \" + roman(n));\n    }\n\n    public static void main(String[] args) {\n        test(1999);\n        test(25);\n        test(944);\n        test(0);\n    }\n\n}\n"}
{"id": 128575, "name": "Roman numerals_Encode", "source": "Translate Ruby to Java: Symbols = { 1=>'I', 5=>'V', 10=>'X', 50=>'L', 100=>'C', 500=>'D', 1000=>'M' }\nSubtractors = [ [1000, 100], [500, 100], [100, 10], [50, 10], [10, 1], [5, 1], [1, 0] ]\n\ndef roman(num)\n  return Symbols[num]  if Symbols.has_key?(num)\n  Subtractors.each do |cutPoint, subtractor| \n    return roman(cutPoint) + roman(num - cutPoint)      if num >  cutPoint\n    return roman(subtractor) + roman(num + subtractor)  if num >= cutPoint - subtractor and num < cutPoint\n  end\nend\n\n[1990, 2008, 1666].each do |i|\n  puts \"%4d => %s\" % [i, roman(i)]\nend\n", "target": "public class RN {\n\n    enum Numeral {\n        I(1), IV(4), V(5), IX(9), X(10), XL(40), L(50), XC(90), C(100), CD(400), D(500), CM(900), M(1000);\n        int weight;\n\n        Numeral(int weight) {\n            this.weight = weight;\n        }\n    };\n\n    public static String roman(long n) {\n        \n        if( n <= 0) {\n            throw new IllegalArgumentException();\n        }\n        \n        StringBuilder buf = new StringBuilder();\n\n        final Numeral[] values = Numeral.values();\n        for (int i = values.length - 1; i >= 0; i--) {\n            while (n >= values[i].weight) {\n                buf.append(values[i]);\n                n -= values[i].weight;\n            }\n        }\n        return buf.toString();\n    }\n\n    public static void test(long n) {\n        System.out.println(n + \" = \" + roman(n));\n    }\n\n    public static void main(String[] args) {\n        test(1999);\n        test(25);\n        test(944);\n        test(0);\n    }\n\n}\n"}
{"id": 128576, "name": "Roman numerals_Encode", "source": "Translate Ruby to Python: Symbols = { 1=>'I', 5=>'V', 10=>'X', 50=>'L', 100=>'C', 500=>'D', 1000=>'M' }\nSubtractors = [ [1000, 100], [500, 100], [100, 10], [50, 10], [10, 1], [5, 1], [1, 0] ]\n\ndef roman(num)\n  return Symbols[num]  if Symbols.has_key?(num)\n  Subtractors.each do |cutPoint, subtractor| \n    return roman(cutPoint) + roman(num - cutPoint)      if num >  cutPoint\n    return roman(subtractor) + roman(num + subtractor)  if num >= cutPoint - subtractor and num < cutPoint\n  end\nend\n\n[1990, 2008, 1666].each do |i|\n  puts \"%4d => %s\" % [i, roman(i)]\nend\n", "target": "import roman\nprint(roman.toRoman(2022))\n"}
{"id": 128577, "name": "Roman numerals_Encode", "source": "Translate Ruby to Python: Symbols = { 1=>'I', 5=>'V', 10=>'X', 50=>'L', 100=>'C', 500=>'D', 1000=>'M' }\nSubtractors = [ [1000, 100], [500, 100], [100, 10], [50, 10], [10, 1], [5, 1], [1, 0] ]\n\ndef roman(num)\n  return Symbols[num]  if Symbols.has_key?(num)\n  Subtractors.each do |cutPoint, subtractor| \n    return roman(cutPoint) + roman(num - cutPoint)      if num >  cutPoint\n    return roman(subtractor) + roman(num + subtractor)  if num >= cutPoint - subtractor and num < cutPoint\n  end\nend\n\n[1990, 2008, 1666].each do |i|\n  puts \"%4d => %s\" % [i, roman(i)]\nend\n", "target": "import roman\nprint(roman.toRoman(2022))\n"}
{"id": 128928, "name": "Loops_While", "source": "Translate Ruby to C#: i = 1024\nwhile i > 0 do\n   puts i\n   i /= 2\nend\n", "target": "int i = 1024;\nwhile(i > 0){\n   System.Console.WriteLine(i);\n   i /= 2;\n}\n"}
{"id": 128930, "name": "Loops_While", "source": "Translate Ruby to Java: i = 1024\nwhile i > 0 do\n   puts i\n   i /= 2\nend\n", "target": "int i = 1024;\nwhile(i > 0){\n   System.out.println(i);\n   i >>= 1; \n}\n"}
{"id": 128931, "name": "Loops_While", "source": "Translate Ruby to Python: i = 1024\nwhile i > 0 do\n   puts i\n   i /= 2\nend\n", "target": "n = 1024\nwhile n > 0:\n    print n\n    n //= 2\n"}
{"id": 129187, "name": "Probabilistic choice", "source": "Translate Ruby to C#: probabilities = {\n  \"aleph\"  => 1/5.0,\n  \"beth\"   => 1/6.0,\n  \"gimel\"  => 1/7.0,\n  \"daleth\" => 1/8.0,\n  \"he\"     => 1/9.0,\n  \"waw\"    => 1/10.0,\n  \"zayin\"  => 1/11.0,\n}\nprobabilities[\"heth\"] = 1.0 - probabilities.each_value.inject(:+)\nordered_keys = probabilities.keys\n\nsum, sums = 0.0, {}\nordered_keys.each do |key|\n  sum += probabilities[key]\n  sums[key] = sum\nend\n\nactual = Hash.new(0)\n\nsamples = 1_000_000\nsamples.times do\n  r = rand\n  for k in ordered_keys\n    if r < sums[k]\n      actual[k] += 1\n      break\n    end\n  end\nend\n\nputs  \"key     expected    actual        diff\"\nfor k in ordered_keys\n  act = Float(actual[k]) / samples\n  val = probabilities[k]\n  printf \"%-8s%.8f \u00a0%.8f  %6.3f\u00a0%%\\n\", k, val, act, 100*(act-val)/val\nend\n", "target": "using System;\n\nclass Program\n{\n    static long TRIALS = 1000000L;\n    private class Expv\n    {\n        public string name;\n        public int probcount;\n        public double expect;\n        public double mapping;\n\n        public Expv(string name, int probcount, double expect, double mapping)\n        {\n            this.name = name;\n            this.probcount = probcount;\n            this.expect = expect;\n            this.mapping = mapping;\n        }\n    }\n\n    static Expv[] items = {\n        new Expv(\"aleph\", 0, 0.0, 0.0), new Expv(\"beth\", 0, 0.0, 0.0),\n        new Expv(\"gimel\", 0, 0.0, 0.0), new Expv(\"daleth\", 0, 0.0, 0.0),\n\tnew Expv(\"he\", 0, 0.0, 0.0),    new Expv(\"waw\", 0, 0.0, 0.0),\n\tnew Expv(\"zayin\", 0, 0.0, 0.0), new Expv(\"heth\", 0, 0.0, 0.0)\n    };\n\n    static void Main(string[] args)\n    {\n        double rnum, tsum = 0.0;\n        Random random = new Random();\n\n        for (int i = 0, rnum = 5.0; i < 7; i++, rnum += 1.0)\n        {\n            items[i].expect = 1.0 / rnum;\n            tsum += items[i].expect;\n        }\n        items[7].expect = 1.0 - tsum;\n\n        items[0].mapping = 1.0 / 5.0;\n        for (int i = 1; i < 7; i++)\n            items[i].mapping = items[i - 1].mapping + 1.0 / ((double)i + 5.0);\n        items[7].mapping = 1.0;\n\n        for (int i = 0; i < TRIALS; i++)\n        {\n            rnum = random.NextDouble();\n            for (int j = 0; j < 8; j++)\n                if (rnum < items[j].mapping)\n                {\n                    items[j].probcount++;\n                    break;\n                }\n        }\n\n        Console.WriteLine(\"Trials: {0}\", TRIALS);\n        Console.Write(\"Items:          \");\n        for (int i = 0; i < 8; i++)\n            Console.Write(items[i].name.PadRight(9));\n        Console.WriteLine();\n        Console.Write(\"Target prob.:   \");\n        for (int i = 0; i < 8; i++)\n            Console.Write(\"{0:0.000000} \", items[i].expect);\n        Console.WriteLine();\n        Console.Write(\"Attained prob.: \");\n        for (int i = 0; i < 8; i++)\n            Console.Write(\"{0:0.000000} \", (double)items[i].probcount / (double)TRIALS);\n        Console.WriteLine();\n    }\n}\n"}
{"id": 129189, "name": "Probabilistic choice", "source": "Translate Ruby to Java: probabilities = {\n  \"aleph\"  => 1/5.0,\n  \"beth\"   => 1/6.0,\n  \"gimel\"  => 1/7.0,\n  \"daleth\" => 1/8.0,\n  \"he\"     => 1/9.0,\n  \"waw\"    => 1/10.0,\n  \"zayin\"  => 1/11.0,\n}\nprobabilities[\"heth\"] = 1.0 - probabilities.each_value.inject(:+)\nordered_keys = probabilities.keys\n\nsum, sums = 0.0, {}\nordered_keys.each do |key|\n  sum += probabilities[key]\n  sums[key] = sum\nend\n\nactual = Hash.new(0)\n\nsamples = 1_000_000\nsamples.times do\n  r = rand\n  for k in ordered_keys\n    if r < sums[k]\n      actual[k] += 1\n      break\n    end\n  end\nend\n\nputs  \"key     expected    actual        diff\"\nfor k in ordered_keys\n  act = Float(actual[k]) / samples\n  val = probabilities[k]\n  printf \"%-8s%.8f \u00a0%.8f  %6.3f\u00a0%%\\n\", k, val, act, 100*(act-val)/val\nend\n", "target": "public class Prob{\n\tstatic long TRIALS= 1000000;\n\n\tprivate static class Expv{\n\t\tpublic String name;\n\t\tpublic int probcount;\n\t\tpublic double expect;\n\t\tpublic double mapping;\n\n\t\tpublic Expv(String name, int probcount, double expect, double mapping){\n\t\t\tthis.name= name;\n\t\t\tthis.probcount= probcount;\n\t\t\tthis.expect= expect;\n\t\t\tthis.mapping= mapping;\n\t\t}\n\t}\n\n\tstatic Expv[] items=\n\t\t\t{new Expv(\"aleph\", 0, 0.0, 0.0), new Expv(\"beth\", 0, 0.0, 0.0),\n\t\t\t\t\tnew Expv(\"gimel\", 0, 0.0, 0.0),\n\t\t\t\t\tnew Expv(\"daleth\", 0, 0.0, 0.0),\n\t\t\t\t\tnew Expv(\"he\", 0, 0.0, 0.0), new Expv(\"waw\", 0, 0.0, 0.0),\n\t\t\t\t\tnew Expv(\"zayin\", 0, 0.0, 0.0),\n\t\t\t\t\tnew Expv(\"heth\", 0, 0.0, 0.0)};\n\n\tpublic static void main(String[] args){\n\t\tint i, j;\n\t\tdouble rnum, tsum= 0.0;\n\n\t\tfor(i= 0, rnum= 5.0;i < 7;i++, rnum+= 1.0){\n\t\t\titems[i].expect= 1.0 / rnum;\n\t\t\ttsum+= items[i].expect;\n\t\t}\n\t\titems[7].expect= 1.0 - tsum;\n\n\t\titems[0].mapping= 1.0 / 5.0;\n\t\tfor(i= 1;i < 7;i++){\n\t\t\titems[i].mapping= items[i - 1].mapping + 1.0 / ((double)i + 5.0);\n\t\t}\n\t\titems[7].mapping= 1.0;\n\n\n\t\tfor(i= 0;i < TRIALS;i++){\n\t\t\trnum= Math.random();\n\t\t\tfor(j= 0;j < 8;j++){\n\t\t\t\tif(rnum < items[j].mapping){\n\t\t\t\t\titems[j].probcount++;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tSystem.out.printf(\"Trials: %d\\n\", TRIALS);\n\t\tSystem.out.printf(\"Items:          \");\n\t\tfor(i= 0;i < 8;i++)\n\t\t\tSystem.out.printf(\"%-8s \", items[i].name);\n\t\tSystem.out.printf(\"\\nTarget prob.:   \");\n\t\tfor(i= 0;i < 8;i++)\n\t\t\tSystem.out.printf(\"%8.6f \", items[i].expect);\n\t\tSystem.out.printf(\"\\nAttained prob.: \");\n\t\tfor(i= 0;i < 8;i++)\n\t\t\tSystem.out.printf(\"%8.6f \", (double)(items[i].probcount)\n\t\t\t\t\t/ (double)TRIALS);\n\t\tSystem.out.printf(\"\\n\");\n\n\t}\n}\n"}
{"id": 129190, "name": "Probabilistic choice", "source": "Translate Ruby to Python: probabilities = {\n  \"aleph\"  => 1/5.0,\n  \"beth\"   => 1/6.0,\n  \"gimel\"  => 1/7.0,\n  \"daleth\" => 1/8.0,\n  \"he\"     => 1/9.0,\n  \"waw\"    => 1/10.0,\n  \"zayin\"  => 1/11.0,\n}\nprobabilities[\"heth\"] = 1.0 - probabilities.each_value.inject(:+)\nordered_keys = probabilities.keys\n\nsum, sums = 0.0, {}\nordered_keys.each do |key|\n  sum += probabilities[key]\n  sums[key] = sum\nend\n\nactual = Hash.new(0)\n\nsamples = 1_000_000\nsamples.times do\n  r = rand\n  for k in ordered_keys\n    if r < sums[k]\n      actual[k] += 1\n      break\n    end\n  end\nend\n\nputs  \"key     expected    actual        diff\"\nfor k in ordered_keys\n  act = Float(actual[k]) / samples\n  val = probabilities[k]\n  printf \"%-8s%.8f \u00a0%.8f  %6.3f\u00a0%%\\n\", k, val, act, 100*(act-val)/val\nend\n", "target": "import random, bisect\n\ndef probchoice(items, probs):\n  \n  \n  prob_accumulator = 0\n  accumulator = []\n  for p in probs:\n    prob_accumulator += p\n    accumulator.append(prob_accumulator)\n    \n  while True:\n    r = random.random()\n    yield items[bisect.bisect(accumulator, r)]\n\ndef probchoice2(items, probs, bincount=10000):\n  \n  \n  bins = []\n  for item,prob in zip(items, probs):\n    bins += [item]*int(bincount*prob)\n  while True:\n    yield random.choice(bins)\n      \n      \ndef tester(func=probchoice, items='good bad ugly'.split(),\n                    probs=[0.5, 0.3, 0.2],\n                    trials = 100000\n                    ):\n  def problist2string(probs):\n    \n    return \",\".join('%8.6f' % (p,) for p in probs)\n  \n  from collections import defaultdict\n   \n  counter = defaultdict(int)\n  it = func(items, probs)\n  for dummy in xrange(trials):\n    counter[it.next()] += 1\n  print \"\\n\n  print \"Trials:              \", trials\n  print \"Items:               \", ' '.join(items)\n  print \"Target probability:  \", problist2string(probs)\n  print \"Attained probability:\", problist2string(\n    counter[x]/float(trials) for x in items)\n\nif __name__ == '__main__':\n  items = 'aleph beth gimel daleth he waw zayin heth'.split()\n  probs = [1/(float(n)+5) for n in range(len(items))]\n  probs[-1] = 1-sum(probs[:-1])\n  tester(probchoice, items, probs, 1000000)\n  tester(probchoice2, items, probs, 1000000)\n"}
{"id": 129411, "name": "Towers of Hanoi", "source": "Translate Ruby to C#: def move(num_disks, start=0, target=1, using=2)\n  if num_disks == 1\n   @towers[target] << @towers[start].pop\n    puts \"Move disk from \n  else\n    move(num_disks-1, start, using, target)\n    move(1,           start, target, using)\n    move(num_disks-1, using, target, start)\n  end \nend\n\nn = 5\n@towers = [[*1..n].reverse, [], []]\nmove(n)\n", "target": "public  void move(int n, int from, int to, int via) {\n   if (n == 1) {\n     System.Console.WriteLine(\"Move disk from pole \" + from + \" to pole \" + to);\n   } else {\n     move(n - 1, from, via, to);\n     move(1, from, to, via);\n     move(n - 1, via, to, from);\n   }\n }\n"}
{"id": 129413, "name": "Towers of Hanoi", "source": "Translate Ruby to Java: def move(num_disks, start=0, target=1, using=2)\n  if num_disks == 1\n   @towers[target] << @towers[start].pop\n    puts \"Move disk from \n  else\n    move(num_disks-1, start, using, target)\n    move(1,           start, target, using)\n    move(num_disks-1, using, target, start)\n  end \nend\n\nn = 5\n@towers = [[*1..n].reverse, [], []]\nmove(n)\n", "target": "public void move(int n, int from, int to, int via) {\n  if (n == 1) {\n    System.out.println(\"Move disk from pole \" + from + \" to pole \" + to);\n  } else {\n    move(n - 1, from, via, to);\n    move(1, from, to, via);\n    move(n - 1, via, to, from);\n  }\n}\n"}
{"id": 129414, "name": "Towers of Hanoi", "source": "Translate Ruby to Python: def move(num_disks, start=0, target=1, using=2)\n  if num_disks == 1\n   @towers[target] << @towers[start].pop\n    puts \"Move disk from \n  else\n    move(num_disks-1, start, using, target)\n    move(1,           start, target, using)\n    move(num_disks-1, using, target, start)\n  end \nend\n\nn = 5\n@towers = [[*1..n].reverse, [], []]\nmove(n)\n", "target": "\n\n\n\u0ba8\u0bbf\u0bb0\u0bb2\u0bcd\u0baa\u0bbe\u0b95\u0bae\u0bcd \u0bb9\u0bcb\u0ba9\u0bbe\u0baf\u0bcd(\u0bb5\u0b9f\u0bcd\u0b9f\u0bc1\u0b95\u0bb3\u0bcd, \u0bae\u0bc1\u0ba4\u0bb2\u0bcd\u0b85\u0b9a\u0bcd\u0b9a\u0bc1, \u0b87\u0bb1\u0bc1\u0ba4\u0bbf\u0b85\u0b9a\u0bcd\u0b9a\u0bc1,\u0bb5\u0b9f\u0bcd\u0b9f\u0bc1)\n\n  @(\u0bb5\u0b9f\u0bcd\u0b9f\u0bc1\u0b95\u0bb3\u0bcd == 1 ) \u0b86\u0ba9\u0bbe\u0bb2\u0bcd\n     \u0baa\u0ba4\u0bbf\u0baa\u0bcd\u0baa\u0bbf  \u201c\u0bb5\u0b9f\u0bcd\u0b9f\u0bc1 \u201d + str(\u0bb5\u0b9f\u0bcd\u0b9f\u0bc1) + \u201c\u0b90 \\t  (\u201d + str(\u0bae\u0bc1\u0ba4\u0bb2\u0bcd\u0b85\u0b9a\u0bcd\u0b9a\u0bc1) + \u201c  \u2014> \u201d +  str(\u0b87\u0bb1\u0bc1\u0ba4\u0bbf\u0b85\u0b9a\u0bcd\u0b9a\u0bc1)+ \u201c) \u0b85\u0b9a\u0bcd\u0b9a\u0bbf\u0bb1\u0bcd\u0b95\u0bc1 \u0ba8\u0b95\u0bb0\u0bcd\u0ba4\u0bcd\u0ba4\u0bc1\u0b95.\u201d\n  \u0b87\u0bb2\u0bcd\u0bb2\u0bc8\n\n  @( [\"\u0b87\", \"\u0b85\",  \"\u0b86\"]  \u0b87\u0bb2\u0bcd \u0b85\u0b9a\u0bcd\u0b9a\u0bc1 ) \u0b92\u0bb5\u0bcd\u0bb5\u0bca\u0ba9\u0bcd\u0bb1\u0bbe\u0b95\n          @( (\u0bae\u0bc1\u0ba4\u0bb2\u0bcd\u0b85\u0b9a\u0bcd\u0b9a\u0bc1 != \u0b85\u0b9a\u0bcd\u0b9a\u0bc1)  && (\u0b87\u0bb1\u0bc1\u0ba4\u0bbf\u0b85\u0b9a\u0bcd\u0b9a\u0bc1  != \u0b85\u0b9a\u0bcd\u0b9a\u0bc1) ) \u0b86\u0ba9\u0bbe\u0bb2\u0bcd\n              \u0ba8\u0b9f\u0bc1 = \u0b85\u0b9a\u0bcd\u0b9a\u0bc1\n          \u0bae\u0bc1\u0b9f\u0bbf\n  \u0bae\u0bc1\u0b9f\u0bbf\n\n    \n    \u0bb9\u0bcb\u0ba9\u0bbe\u0baf\u0bcd(\u0bb5\u0b9f\u0bcd\u0b9f\u0bc1\u0b95\u0bb3\u0bcd-1,   \u0bae\u0bc1\u0ba4\u0bb2\u0bcd\u0b85\u0b9a\u0bcd\u0b9a\u0bc1,\u0ba8\u0b9f\u0bc1,\u0bb5\u0b9f\u0bcd\u0b9f\u0bc1\u0b95\u0bb3\u0bcd-1)\n\n    \n    \u0bb9\u0bcb\u0ba9\u0bbe\u0baf\u0bcd(1, \u0bae\u0bc1\u0ba4\u0bb2\u0bcd\u0b85\u0b9a\u0bcd\u0b9a\u0bc1, \u0b87\u0bb1\u0bc1\u0ba4\u0bbf\u0b85\u0b9a\u0bcd\u0b9a\u0bc1,\u0bb5\u0b9f\u0bcd\u0b9f\u0bc1\u0b95\u0bb3\u0bcd)\n\n    \n    \u0bb9\u0bcb\u0ba9\u0bbe\u0baf\u0bcd(\u0bb5\u0b9f\u0bcd\u0b9f\u0bc1\u0b95\u0bb3\u0bcd-1, \u0ba8\u0b9f\u0bc1, \u0b87\u0bb1\u0bc1\u0ba4\u0bbf\u0b85\u0b9a\u0bcd\u0b9a\u0bc1,\u0bb5\u0b9f\u0bcd\u0b9f\u0bc1\u0b95\u0bb3\u0bcd-1)\n  \u0bae\u0bc1\u0b9f\u0bbf\n\u0bae\u0bc1\u0b9f\u0bbf\n\n\u0bb9\u0bcb\u0ba9\u0bbe\u0baf\u0bcd(4,\u201d\u0b85\u201d,\u201d\u0b86\u201d,0)\n"}
{"id": 129605, "name": "Active object", "source": "Translate Ruby to C#: require \"math\"\nrequire \"time\"\n\n\n\n\nenum Action\n  Finished  \n  \nend\n\nclass Integrator\n  property interval : Float64\n  getter s : Float64 = 0f64\n\n  \n  getter k : Proc(Float64, Float64) = ->(t : Float64) { 0f64 }\n\n  \n  @proc_chan : Channel(Tuple(Action, Proc(Float64, Float64)|Nil))\n  @result_chan : Channel(Float64)\n\n  def initialize(@k, @proc_chan, @result_chan, @interval = 1e-4)\n    \n    start = Time.monotonic.total_seconds\n    t0, k0 = 0f64, @k.call(0f64)\n\n    loop do\n      \n      \n      sleep interval.seconds\n      \n      self.check_channel()\n      t1 = Time.monotonic.total_seconds - start\n      k1 = @k.call(t1)\n      @s += (k1 + k0) * (t1 - t0) / 2.0\n      t0, k0 = t1, k1\n    end\n  end\n\n  \n  def check_channel\n    select\n    when message = @proc_chan.receive\n      action, new_k = message\n      case action\n      when Action::Finished\n        @result_chan.send @s\n        @k = new_k unless new_k.nil?\n      end\n    else\n      nil\n    end\n  end\nend\n\n\n\nproc_chan = Channel(Tuple(Action, Proc(Float64, Float64)|Nil)).new\n\n\nresult_chan = Channel(Float64).new\n\n\n\n\n\n\nspawn name: \"state_clock\" do\n  ai = Integrator.new ->(t : Float64) { Math.sin(Math::PI * t) }, proc_chan, result_chan\nend\n\nsleep 2.seconds\nproc_chan.send({Action::Finished, ->(t : Float64) { 0f64 }})\nsleep 0.5.seconds\nputs result_chan.receive\n", "target": "using System;\nusing System.Threading.Tasks;\n\nusing static System.Diagnostics.Stopwatch;\nusing static System.Math;\nusing static System.Threading.Thread;\n\nclass ActiveObject\n{\n    static double timeScale = 1.0 / Frequency;\n\n    Func<double, double> func;\n    Task updateTask;\n    double integral;\n    double value;\n    long timestamp0, timestamp;\n\n    public ActiveObject(Func<double, double> input)\n    {\n        timestamp0 = timestamp = GetTimestamp();\n        func = input;\n        value = func(0);\n        updateTask = Integrate();\n    }\n\n    public void ChangeInput(Func<double, double> input)\n    {\n        lock (updateTask)\n        {\n            func = input;\n        }\n    }\n\n    public double Value\n    {\n        get\n        {\n            lock (updateTask)\n            {\n                return integral;\n            }\n        }\n    }\n\n    async Task Integrate()\n    {\n        while (true)\n        {\n            await Task.Yield();\n            var newTime = GetTimestamp();\n            double newValue;\n\n            lock (updateTask)\n            {\n                newValue = func((newTime - timestamp0) * timeScale);\n                integral += (newValue + value) * (newTime - timestamp) * timeScale / 2;\n            }\n\n            timestamp = newTime;\n            value = newValue;\n        }\n    }\n}\n\nclass Program\n{\n    static Func<double, double> Sine(double frequency) =>\n        t => Sin(2 * PI * frequency * t);\n\n    static void Main(string[] args)\n    {\n        var ao = new ActiveObject(Sine(0.5));\n        Sleep(TimeSpan.FromSeconds(2));\n        ao.ChangeInput(t => 0);\n        Sleep(TimeSpan.FromSeconds(0.5));\n        Console.WriteLine(ao.Value);\n    }\n}\n"}
{"id": 129607, "name": "Active object", "source": "Translate Ruby to Java: require \"math\"\nrequire \"time\"\n\n\n\n\nenum Action\n  Finished  \n  \nend\n\nclass Integrator\n  property interval : Float64\n  getter s : Float64 = 0f64\n\n  \n  getter k : Proc(Float64, Float64) = ->(t : Float64) { 0f64 }\n\n  \n  @proc_chan : Channel(Tuple(Action, Proc(Float64, Float64)|Nil))\n  @result_chan : Channel(Float64)\n\n  def initialize(@k, @proc_chan, @result_chan, @interval = 1e-4)\n    \n    start = Time.monotonic.total_seconds\n    t0, k0 = 0f64, @k.call(0f64)\n\n    loop do\n      \n      \n      sleep interval.seconds\n      \n      self.check_channel()\n      t1 = Time.monotonic.total_seconds - start\n      k1 = @k.call(t1)\n      @s += (k1 + k0) * (t1 - t0) / 2.0\n      t0, k0 = t1, k1\n    end\n  end\n\n  \n  def check_channel\n    select\n    when message = @proc_chan.receive\n      action, new_k = message\n      case action\n      when Action::Finished\n        @result_chan.send @s\n        @k = new_k unless new_k.nil?\n      end\n    else\n      nil\n    end\n  end\nend\n\n\n\nproc_chan = Channel(Tuple(Action, Proc(Float64, Float64)|Nil)).new\n\n\nresult_chan = Channel(Float64).new\n\n\n\n\n\n\nspawn name: \"state_clock\" do\n  ai = Integrator.new ->(t : Float64) { Math.sin(Math::PI * t) }, proc_chan, result_chan\nend\n\nsleep 2.seconds\nproc_chan.send({Action::Finished, ->(t : Float64) { 0f64 }})\nsleep 0.5.seconds\nputs result_chan.receive\n", "target": "\npublic class Integrator {\n\n    public interface Function {\n        double apply(double timeSinceStartInSeconds);\n    }\n\n    private final long start;\n    private volatile boolean running;\n\n    private Function func;\n    private double t0;\n    private double v0;\n    private double sum;\n\n    public Integrator(Function func) {\n        this.start = System.nanoTime();\n        setFunc(func);\n        new Thread(this::integrate).start();\n    }\n\n    public void setFunc(Function func) {\n        this.func = func;\n        v0 = func.apply(0.0);\n        t0 = 0;\n    }\n\n    public double getOutput() {\n        return sum;\n    }\n\n    public void stop() {\n        running = false;\n    }\n\n    private void integrate() {\n        running = true;\n        while (running) {\n            try {\n                Thread.sleep(1);\n                update();\n            } catch (InterruptedException e) {\n                return;\n            }\n        }\n    }\n\n    private void update() {\n        double t1 = (System.nanoTime() - start) / 1.0e9;\n        double v1 = func.apply(t1);\n        double rect = (t1 - t0) * (v0 + v1) / 2;\n        this.sum += rect;\n        t0 = t1;\n        v0 = v1;\n    }\n\n    public static void main(String[] args) throws InterruptedException {\n        Integrator integrator = new Integrator(t -> Math.sin(Math.PI * t));\n        Thread.sleep(2000);\n\n        integrator.setFunc(t -> 0.0);\n        Thread.sleep(500);\n\n        integrator.stop();\n        System.out.println(integrator.getOutput());\n    }\n}\n"}
{"id": 129608, "name": "Active object", "source": "Translate Ruby to Python: require \"math\"\nrequire \"time\"\n\n\n\n\nenum Action\n  Finished  \n  \nend\n\nclass Integrator\n  property interval : Float64\n  getter s : Float64 = 0f64\n\n  \n  getter k : Proc(Float64, Float64) = ->(t : Float64) { 0f64 }\n\n  \n  @proc_chan : Channel(Tuple(Action, Proc(Float64, Float64)|Nil))\n  @result_chan : Channel(Float64)\n\n  def initialize(@k, @proc_chan, @result_chan, @interval = 1e-4)\n    \n    start = Time.monotonic.total_seconds\n    t0, k0 = 0f64, @k.call(0f64)\n\n    loop do\n      \n      \n      sleep interval.seconds\n      \n      self.check_channel()\n      t1 = Time.monotonic.total_seconds - start\n      k1 = @k.call(t1)\n      @s += (k1 + k0) * (t1 - t0) / 2.0\n      t0, k0 = t1, k1\n    end\n  end\n\n  \n  def check_channel\n    select\n    when message = @proc_chan.receive\n      action, new_k = message\n      case action\n      when Action::Finished\n        @result_chan.send @s\n        @k = new_k unless new_k.nil?\n      end\n    else\n      nil\n    end\n  end\nend\n\n\n\nproc_chan = Channel(Tuple(Action, Proc(Float64, Float64)|Nil)).new\n\n\nresult_chan = Channel(Float64).new\n\n\n\n\n\n\nspawn name: \"state_clock\" do\n  ai = Integrator.new ->(t : Float64) { Math.sin(Math::PI * t) }, proc_chan, result_chan\nend\n\nsleep 2.seconds\nproc_chan.send({Action::Finished, ->(t : Float64) { 0f64 }})\nsleep 0.5.seconds\nputs result_chan.receive\n", "target": "from time import time, sleep\nfrom threading import Thread\n\nclass Integrator(Thread):\n    'continuously integrate a function `K`, at each `interval` seconds'\n    def __init__(self, K=lambda t:0, interval=1e-4):\n        Thread.__init__(self)\n        self.interval  = interval\n        self.K   = K\n        self.S   = 0.0\n        self.__run = True\n        self.start()\n\n    def run(self):\n        \"entry point for the thread\"\n        interval = self.interval\n        start = time()\n        t0, k0 = 0, self.K(0)\n        while self.__run:\n            sleep(interval)\n            t1 = time() - start\n            k1 = self.K(t1)\n            self.S += (k1 + k0)*(t1 - t0)/2.0\n            t0, k0 = t1, k1\n\n    def join(self):\n        self.__run = False\n        Thread.join(self)\n\nif __name__ == \"__main__\":\n    from math import sin, pi\n \n    ai = Integrator(lambda t: sin(pi*t))\n    sleep(2)\n    print(ai.S)\n    ai.K = lambda t: 0\n    sleep(0.5)\n    print(ai.S)\n"}
{"id": 129724, "name": "Twelve statements", "source": "Translate Ruby to C#: constraints = [\n  ->(st) { st.size == 12 }, \n  ->(st) { st.last(6).count(true) == 3 },\n  ->(st) { st.each_slice(2).map(&:last).count(true) == 2 },\n  ->(st) { st[4] ? (st[5] & st[6]) : true },\n  ->(st) { st[1..3].none? },\n  ->(st) { st.each_slice(2).map(&:first).count(true) == 4 },\n  ->(st) { st[1] ^ st[2] },\n  ->(st) { st[6] ? (st[4] & st[5]) : true  }, \n  ->(st) { st.first(6).count(true) == 3 },\n  ->(st) { st[10] & st[11] },\n  ->(st) { st[6..8].one? },\n  ->(st) { st[0,11].count(true) == 4 },\n]\n \nResult = Struct.new(:truths, :consistency)\n \nresults = [true, false].repeated_permutation(12).map do |truths|\n  Result.new(truths, constraints.zip(truths).map {|cn,truth| cn[truths] == truth })\nend\n\nputs \"solution:\", \n  results.find {|r| r.consistency.all? }.truths.to_s\n\nputs \"\\nnear misses: \"\nnear_misses = results.select {|r| r.consistency.count(false) == 1 }\nnear_misses.each do |r|\n  puts \"missed by statement \nend\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n    \npublic static class TwelveStatements\n{\n    public static void Main() {\n        Func<Statements, bool>[] checks = {\n            st => st[1],\n            st => st[2] == (7.To(12).Count(i => st[i]) == 3),\n            st => st[3] == (2.To(12, by: 2).Count(i => st[i]) == 2),\n            st => st[4] == st[5].Implies(st[6] && st[7]),\n            st => st[5] == (!st[2] && !st[3] && !st[4]),\n            st => st[6] == (1.To(12, by: 2).Count(i => st[i]) == 4),\n            st => st[7] == (st[2] != st[3]),\n            st => st[8] == st[7].Implies(st[5] && st[6]),\n            st => st[9] == (1.To(6).Count(i => st[i]) == 3),\n            st => st[10] == (st[11] && st[12]),\n            st => st[11] == (7.To(9).Count(i => st[i]) == 1),\n            st => st[12] == (1.To(11).Count(i => st[i]) == 4)\n        };\n        \n        for (Statements statements = new Statements(0); statements.Value < 4096; statements++) {\n            int count = 0;\n            int falseIndex = 0;\n            for (int i = 0; i < checks.Length; i++) {\n                if (checks[i](statements)) count++;\n                else falseIndex = i;\n            }\n            if (count == 0) Console.WriteLine($\"{\"All wrong:\", -13}{statements}\");\n            else if (count == 11) Console.WriteLine($\"{$\"Wrong at {falseIndex + 1}:\", -13}{statements}\");\n            else if (count == 12) Console.WriteLine($\"{\"All correct:\", -13}{statements}\");\n        }\n    }\n    \n    struct Statements\n    {    \n        public Statements(int value) : this() { Value = value; }\n        \n        public int Value { get; }\n                \n        public bool this[int index] => (Value & (1 << index - 1)) != 0;\n        \n        public static Statements operator ++(Statements statements) => new Statements(statements.Value + 1);\n        \n        public override string ToString() {\n            Statements copy = this; \n            return string.Join(\" \", from i in 1.To(12) select copy[i] ? \"T\" : \"F\");\n        }\n        \n    }\n    \n    \n    static bool Implies(this bool x, bool y) => !x || y;\n    \n    static IEnumerable<int> To(this int start, int end, int by = 1) {\n        while (start <= end) {\n            yield return start;\n            start += by;\n        }\n    }\n\n}\n"}
{"id": 129725, "name": "Twelve statements", "source": "Translate Ruby to Java: constraints = [\n  ->(st) { st.size == 12 }, \n  ->(st) { st.last(6).count(true) == 3 },\n  ->(st) { st.each_slice(2).map(&:last).count(true) == 2 },\n  ->(st) { st[4] ? (st[5] & st[6]) : true },\n  ->(st) { st[1..3].none? },\n  ->(st) { st.each_slice(2).map(&:first).count(true) == 4 },\n  ->(st) { st[1] ^ st[2] },\n  ->(st) { st[6] ? (st[4] & st[5]) : true  }, \n  ->(st) { st.first(6).count(true) == 3 },\n  ->(st) { st[10] & st[11] },\n  ->(st) { st[6..8].one? },\n  ->(st) { st[0,11].count(true) == 4 },\n]\n \nResult = Struct.new(:truths, :consistency)\n \nresults = [true, false].repeated_permutation(12).map do |truths|\n  Result.new(truths, constraints.zip(truths).map {|cn,truth| cn[truths] == truth })\nend\n\nputs \"solution:\", \n  results.find {|r| r.consistency.all? }.truths.to_s\n\nputs \"\\nnear misses: \"\nnear_misses = results.select {|r| r.consistency.count(false) == 1 }\nnear_misses.each do |r|\n  puts \"missed by statement \nend\n", "target": "public class LogicPuzzle\n{\n    boolean S[] = new boolean[13];\n    int Count = 0;\n\n    public boolean check2 ()\n    {\n        int count = 0;\n        for (int k = 7; k <= 12; k++)\n            if (S[k]) count++;\n        return S[2] == (count == 3);\n    }\n\n    public boolean check3 ()\n    {\n        int count = 0;\n        for (int k = 2; k <= 12; k += 2)\n            if (S[k]) count++;\n        return S[3] == (count == 2);\n    }\n\n    public boolean check4 ()\n    {\n        return S[4] == ( !S[5] || S[6] && S[7]);\n    }\n\n    public boolean check5 ()\n    {\n        return S[5] == ( !S[2] && !S[3] && !S[4]);\n    }\n\n    public boolean check6 ()\n    {\n        int count = 0;\n        for (int k = 1; k <= 11; k += 2)\n            if (S[k]) count++;\n        return S[6] == (count == 4);\n    }\n\n    public boolean check7 ()\n    {\n        return S[7] == ((S[2] || S[3]) && !(S[2] && S[3]));\n    }\n\n    public boolean check8 ()\n    {\n        return S[8] == ( !S[7] || S[5] && S[6]);\n    }\n\n    public boolean check9 ()\n    {\n        int count = 0;\n        for (int k = 1; k <= 6; k++)\n            if (S[k]) count++;\n        return S[9] == (count == 3);\n    }\n\n    public boolean check10 ()\n    {\n        return S[10] == (S[11] && S[12]);\n    }\n\n    public boolean check11 ()\n    {\n        int count = 0;\n        for (int k = 7; k <= 9; k++)\n            if (S[k]) count++;\n        return S[11] == (count == 1);\n    }\n\n    public boolean check12 ()\n    {\n        int count = 0;\n        for (int k = 1; k <= 11; k++)\n            if (S[k]) count++;\n        return S[12] == (count == 4);\n    }\n\n    public void check ()\n    {\n        if (check2() && check3() && check4() && check5() && check6()\n            && check7() && check8() && check9() && check10() && check11()\n            && check12())\n        {\n            for (int k = 1; k <= 12; k++)\n                if (S[k]) System.out.print(k + \" \");\n            System.out.println();\n            Count++;\n        }\n    }\n\n    public void recurseAll (int k)\n    {\n        if (k == 13)\n            check();\n        else\n        {\n            S[k] = false;\n            recurseAll(k + 1);\n            S[k] = true;\n            recurseAll(k + 1);\n        }\n    }\n\n    public static void main (String args[])\n    {\n        LogicPuzzle P = new LogicPuzzle();\n        P.S[1] = true;\n        P.recurseAll(2);\n        System.out.println();\n        System.out.println(P.Count + \" Solutions found.\");\n    }\n}\n"}
{"id": 129726, "name": "Twelve statements", "source": "Translate Ruby to Python: constraints = [\n  ->(st) { st.size == 12 }, \n  ->(st) { st.last(6).count(true) == 3 },\n  ->(st) { st.each_slice(2).map(&:last).count(true) == 2 },\n  ->(st) { st[4] ? (st[5] & st[6]) : true },\n  ->(st) { st[1..3].none? },\n  ->(st) { st.each_slice(2).map(&:first).count(true) == 4 },\n  ->(st) { st[1] ^ st[2] },\n  ->(st) { st[6] ? (st[4] & st[5]) : true  }, \n  ->(st) { st.first(6).count(true) == 3 },\n  ->(st) { st[10] & st[11] },\n  ->(st) { st[6..8].one? },\n  ->(st) { st[0,11].count(true) == 4 },\n]\n \nResult = Struct.new(:truths, :consistency)\n \nresults = [true, false].repeated_permutation(12).map do |truths|\n  Result.new(truths, constraints.zip(truths).map {|cn,truth| cn[truths] == truth })\nend\n\nputs \"solution:\", \n  results.find {|r| r.consistency.all? }.truths.to_s\n\nputs \"\\nnear misses: \"\nnear_misses = results.select {|r| r.consistency.count(false) == 1 }\nnear_misses.each do |r|\n  puts \"missed by statement \nend\n", "target": "from itertools import product\n\n\nconstraintinfo = (  \n  (lambda st: len(st) == 12                 ,(1, 'This is a numbered list of twelve statements')),\n  (lambda st: sum(st[-6:]) == 3             ,(2, 'Exactly 3 of the last 6 statements are true')),\n  (lambda st: sum(st[1::2]) == 2            ,(3, 'Exactly 2 of the even-numbered statements are true')),\n  (lambda st: (st[5]&st[6]) if st[4] else 1 ,(4, 'If statement 5 is true, then statements 6 and 7 are both true')),\n  (lambda st: sum(st[1:4]) == 0             ,(5, 'The 3 preceding statements are all false')),\n  (lambda st: sum(st[0::2]) == 4            ,(6, 'Exactly 4 of the odd-numbered statements are true')),\n  (lambda st: sum(st[1:3]) == 1             ,(7, 'Either statement 2 or 3 is true, but not both')),\n  (lambda st: (st[4]&st[5]) if st[6] else 1 ,(8, 'If statement 7 is true, then 5 and 6 are both true')),\n  (lambda st: sum(st[:6]) == 3              ,(9, 'Exactly 3 of the first 6 statements are true')),\n  (lambda st: (st[10]&st[11])               ,(10, 'The next two statements are both true')),\n  (lambda st: sum(st[6:9]) == 1             ,(11, 'Exactly 1 of statements 7, 8 and 9 are true')),\n  (lambda st: sum(st[0:11]) == 4            ,(12, 'Exactly 4 of the preceding statements are true')),\n)  \n\ndef printer(st, matches):\n    if False in matches:\n        print('Missed by one statement: %i, %s' % docs[matches.index(False)])\n    else:\n        print('Full match:')\n    print('  ' + ', '.join('%i:%s' % (i, 'T' if t else 'F') for i, t in enumerate(st, 1)))\n\nfuncs, docs = zip(*constraintinfo)\n\nfull, partial = [], []\n\nfor st in product( *([(False, True)] * 12) ):\n    truths = [bool(func(st)) for func in funcs]\n    matches = [s == t for s,t in zip(st, truths)]\n    mcount = sum(matches)\n    if mcount == 12:\n        full.append((st, matches))\n    elif mcount == 11:\n        partial.append((st, matches))\n\nfor stm in full + partial:\n    printer(*stm)\n"}
{"id": 129950, "name": "Remove duplicate elements", "source": "Translate Ruby to C#: ary = [1, 1, 2, 2, \"a\", [1, 2, 3], [1, 2, 3], \"a\"]\np ary.uniq\n", "target": "int[] nums = { 1, 1, 2, 3, 4, 4 };\nList<int> unique = new List<int>();\nforeach (int n in nums)\n    if (!unique.Contains(n))\n        unique.Add(n);\n"}
{"id": 129952, "name": "Remove duplicate elements", "source": "Translate Ruby to Java: ary = [1, 1, 2, 2, \"a\", [1, 2, 3], [1, 2, 3], \"a\"]\np ary.uniq\n", "target": "module RetainUniqueValues\n    {\n    @Inject Console console;\n    void run()\n        {\n        Int[] array = [1, 2, 3, 2, 1, 2, 3, 4, 5, 3, 2, 1];\n        array = array.distinct().toArray();\n        console.print($\"result={array}\");\n        }\n    }\n"}
{"id": 129953, "name": "Remove duplicate elements", "source": "Translate Ruby to Python: ary = [1, 1, 2, 2, \"a\", [1, 2, 3], [1, 2, 3], \"a\"]\np ary.uniq\n", "target": "items = [1, 2, 3, 'a', 'b', 'c', 2, 3, 4, 'b', 'c', 'd']\nunique = list(set(items))\n"}
{"id": 130195, "name": "Emirp primes", "source": "Translate Ruby to C#: require 'prime'\n\nemirp = Enumerator.new do |y|\n  Prime.each do |prime|\n    rev = prime.to_s.reverse.to_i\n    y << prime  if rev.prime? and rev != prime\n  end\nend\n\nputs \"First 20 emirps:\", emirp.first(20).join(\" \")\nputs \"Emirps between 7,700 and 8,000:\"\nemirp.with_index(1) do |prime,i|\n  print \"\n  if i==10000\n    puts \"\", \"10,000th emirp:\", prime\n    break\n  end\nend\n", "target": "using static System.Console;\nusing System;\nusing System.Linq;\nusing System.Collections.Generic;\n\npublic class Program\n{\n    public static void Main() {\n        const int limit = 1_000_000;\n        WriteLine(\"First 20:\");\n        WriteLine(FindEmirpPrimes(limit).Take(20).Delimit());\n        WriteLine();\n\t\t\n        WriteLine(\"Between 7700 and 8000:\");\n        WriteLine(FindEmirpPrimes(limit).SkipWhile(p => p < 7700).TakeWhile(p => p < 8000).Delimit());\n        WriteLine();\n\t\t\n        WriteLine(\"10000th:\");\n        WriteLine(FindEmirpPrimes(limit).ElementAt(9999));\n    }\n\t\n    private static IEnumerable<int> FindEmirpPrimes(int limit)\n    {\n        var primes = Primes(limit).ToHashSet();\n\t\t\n        foreach (int prime in primes) {\n            int reverse = prime.Reverse();\n            if (reverse != prime && primes.Contains(reverse)) yield return prime;\n\t}\n    }\n\t\n    private static IEnumerable<int> Primes(int bound) {\n        if (bound < 2) yield break;\n        yield return 2;\n\t\t\n        BitArray composite = new BitArray((bound - 1) / 2);\n        int limit = ((int)(Math.Sqrt(bound)) - 1) / 2;\n        for (int i = 0; i < limit; i++) {\n            if (composite[i]) continue;\n\t    int prime = 2 * i + 3;\n\t    yield return prime;\n\t\t\t\n\t    for (int j = (prime * prime - 2) / 2; j < composite.Count; j += prime)\n\t        composite[j] = true;\n        }\n\tfor (int i = limit; i < composite.Count; i++)\n\t    if (!composite[i]) yield return 2 * i + 3;\n    }\n}\n\npublic static class Extensions\n{\n    public static HashSet<T> ToHashSet<T>(this IEnumerable<T> source) => new HashSet<T>(source);\n\n    private const string defaultSeparator = \" \";\n    public static string Delimit<T>(this IEnumerable<T> source, string separator = defaultSeparator) =>\n        string.Join(separator ?? defaultSeparator, source);\n\n    public static int Reverse(this int number)\n    {\n\tif (number < 0) return -Reverse(-number);\n\tif (number < 10) return number;\n\tint reverse = 0;\n\twhile (number > 0) {\n\t    reverse = reverse * 10 + number % 10;\n\t    number /= 10;\n\t}\n\treturn reverse;\n    }\n}\n"}
{"id": 130197, "name": "Emirp primes", "source": "Translate Ruby to Java: require 'prime'\n\nemirp = Enumerator.new do |y|\n  Prime.each do |prime|\n    rev = prime.to_s.reverse.to_i\n    y << prime  if rev.prime? and rev != prime\n  end\nend\n\nputs \"First 20 emirps:\", emirp.first(20).join(\" \")\nputs \"Emirps between 7,700 and 8,000:\"\nemirp.with_index(1) do |prime,i|\n  print \"\n  if i==10000\n    puts \"\", \"10,000th emirp:\", prime\n    break\n  end\nend\n", "target": "public class Emirp{\n\t\n\t\n\tpublic static boolean isPrime(long x){\n\t\tif(x < 2) return false;\n\t\tif(x == 2) return true;\n\t\tif((x & 1) == 0) return false;\n\t\t\n\t\tfor(long i = 3; i <= Math.sqrt(x);i+=2){\n\t\t\tif(x % i == 0) return false;\n\t\t}\n\t\t\n\t\treturn true;\n\t}\n\t\n\tpublic static boolean isEmirp(long x){\n\t\tString xString = Long.toString(x);\n\t\tif(xString.length() == 1) return false;\n\t\tif(xString.matches(\"[24568].*\") || xString.matches(\".*[24568]\")) return false; \n\t\tlong xR = Long.parseLong(new StringBuilder(xString).reverse().toString());\n\t\tif(xR == x) return false;\n\t\treturn isPrime(x) && isPrime(xR);\n\t}\n\t\n\tpublic static void main(String[] args){\n\t\tint count = 0;\n\t\tlong x = 1;\n\t\t\n\t\tSystem.out.println(\"First 20 emirps:\");\n\t\twhile(count < 20){\n\t\t\tif(isEmirp(x)){\n\t\t\t\tcount++;\n\t\t\t\tSystem.out.print(x + \" \");\n\t\t\t}\n\t\t\tx++;\n\t\t}\n\t\t\n\t\tSystem.out.println(\"\\nEmirps between 7700 and 8000:\");\n\t\tfor(x = 7700; x <= 8000; x++){\n\t\t\tif(isEmirp(x)){\n\t\t\t\tSystem.out.print(x +\" \");\n\t\t\t}\n\t\t}\n\t\t\n\t\tSystem.out.println(\"\\n10,000th emirp:\");\n\t\tfor(x = 1, count = 0;count < 10000; x++){\n\t\t\tif(isEmirp(x)){\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t\t\n\t\tSystem.out.println(--x);\n\t}\n}\n"}
{"id": 130198, "name": "Emirp primes", "source": "Translate Ruby to Python: require 'prime'\n\nemirp = Enumerator.new do |y|\n  Prime.each do |prime|\n    rev = prime.to_s.reverse.to_i\n    y << prime  if rev.prime? and rev != prime\n  end\nend\n\nputs \"First 20 emirps:\", emirp.first(20).join(\" \")\nputs \"Emirps between 7,700 and 8,000:\"\nemirp.with_index(1) do |prime,i|\n  print \"\n  if i==10000\n    puts \"\", \"10,000th emirp:\", prime\n    break\n  end\nend\n", "target": "from __future__ import print_function\nfrom prime_decomposition import primes, is_prime\nfrom heapq import *\nfrom itertools import islice\n\ndef emirp():\n    largest = set()\n    emirps = []\n    heapify(emirps)\n    for pr in primes():\n        while emirps and pr > emirps[0]:\n            yield heappop(emirps)\n        if pr in largest:\n            yield pr\n        else:\n            rp = int(str(pr)[::-1])\n            if rp > pr and is_prime(rp):\n                heappush(emirps, pr)\n                largest.add(rp)\n\nprint('First 20:\\n  ', list(islice(emirp(), 20)))\nprint('Between 7700 and 8000:\\n  [', end='')\nfor pr in emirp():\n    if pr >= 8000: break\n    if pr >= 7700: print(pr, end=', ')\nprint(']')\nprint('10000th:\\n  ', list(islice(emirp(), 10000-1, 10000)))\n"}
{"id": 130443, "name": "Continued fraction_Arithmetic_Construct from rational number", "source": "Translate Ruby to C#: \n\ndef r2cf(n1,n2)\n  while n2 > 0\n    n1, (t1, n2) = n2, n1.divmod(n2)\n    yield t1\n  end\nend\n", "target": "using System;\nusing System.Collections.Generic;\n\nclass Program\n{\n    static IEnumerable<int> r2cf(int n1, int n2)\n    {\n        while (Math.Abs(n2) > 0)\n        {\n            int t1 = n1 / n2;\n            int t2 = n2;\n            n2 = n1 - t1 * n2;\n            n1 = t2;\n            yield return t1;\n        }\n    }\n\n    static void spit(IEnumerable<int> f)\n    {\n        foreach (int n in f) Console.Write(\" {0}\", n);\n        Console.WriteLine();\n    }\n\n    static void Main(string[] args)\n    {\n        spit(r2cf(1, 2));\n        spit(r2cf(3, 1));\n        spit(r2cf(23, 8));\n        spit(r2cf(13, 11));\n        spit(r2cf(22, 7));\n        spit(r2cf(-151, 77));\n        for (int scale = 10; scale <= 10000000; scale *= 10)\n        {\n            spit(r2cf((int)(Math.Sqrt(2) * scale), scale));\n        }\n        spit(r2cf(31, 10));\n        spit(r2cf(314, 100)); \n        spit(r2cf(3142, 1000));\n        spit(r2cf(31428, 10000));\n        spit(r2cf(314285, 100000));\n        spit(r2cf(3142857, 1000000));\n        spit(r2cf(31428571, 10000000));\n        spit(r2cf(314285714, 100000000));\n    }\n}\n"}
{"id": 130444, "name": "Continued fraction_Arithmetic_Construct from rational number", "source": "Translate Ruby to C#: \n\ndef r2cf(n1,n2)\n  while n2 > 0\n    n1, (t1, n2) = n2, n1.divmod(n2)\n    yield t1\n  end\nend\n", "target": "using System;\nusing System.Collections.Generic;\n\nclass Program\n{\n    static IEnumerable<int> r2cf(int n1, int n2)\n    {\n        while (Math.Abs(n2) > 0)\n        {\n            int t1 = n1 / n2;\n            int t2 = n2;\n            n2 = n1 - t1 * n2;\n            n1 = t2;\n            yield return t1;\n        }\n    }\n\n    static void spit(IEnumerable<int> f)\n    {\n        foreach (int n in f) Console.Write(\" {0}\", n);\n        Console.WriteLine();\n    }\n\n    static void Main(string[] args)\n    {\n        spit(r2cf(1, 2));\n        spit(r2cf(3, 1));\n        spit(r2cf(23, 8));\n        spit(r2cf(13, 11));\n        spit(r2cf(22, 7));\n        spit(r2cf(-151, 77));\n        for (int scale = 10; scale <= 10000000; scale *= 10)\n        {\n            spit(r2cf((int)(Math.Sqrt(2) * scale), scale));\n        }\n        spit(r2cf(31, 10));\n        spit(r2cf(314, 100)); \n        spit(r2cf(3142, 1000));\n        spit(r2cf(31428, 10000));\n        spit(r2cf(314285, 100000));\n        spit(r2cf(3142857, 1000000));\n        spit(r2cf(31428571, 10000000));\n        spit(r2cf(314285714, 100000000));\n    }\n}\n"}
{"id": 130447, "name": "Continued fraction_Arithmetic_Construct from rational number", "source": "Translate Ruby to Java: \n\ndef r2cf(n1,n2)\n  while n2 > 0\n    n1, (t1, n2) = n2, n1.divmod(n2)\n    yield t1\n  end\nend\n", "target": "import java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\n\npublic class ConstructFromRationalNumber {\n    private static class R2cf implements Iterator<Integer> {\n        private int num;\n        private int den;\n\n        R2cf(int num, int den) {\n            this.num = num;\n            this.den = den;\n        }\n\n        @Override\n        public boolean hasNext() {\n            return den != 0;\n        }\n\n        @Override\n        public Integer next() {\n            int div = num / den;\n            int rem = num % den;\n            num = den;\n            den = rem;\n            return div;\n        }\n    }\n\n    private static void iterate(R2cf generator) {\n        generator.forEachRemaining(n -> System.out.printf(\"%d \", n));\n        System.out.println();\n    }\n\n    public static void main(String[] args) {\n        List<Map.Entry<Integer, Integer>> fracs = List.of(\n                Map.entry(1, 2),\n                Map.entry(3, 1),\n                Map.entry(23, 8),\n                Map.entry(13, 11),\n                Map.entry(22, 7),\n                Map.entry(-151, 77)\n        );\n        for (Map.Entry<Integer, Integer> frac : fracs) {\n            System.out.printf(\"%4d /\u00a0%-2d = \", frac.getKey(), frac.getValue());\n            iterate(new R2cf(frac.getKey(), frac.getValue()));\n        }\n\n        System.out.println(\"\\nSqrt(2) ->\");\n        List<Map.Entry<Integer, Integer>> root2 = List.of(\n                Map.entry(    14_142,     10_000),\n                Map.entry(   141_421,    100_000),\n                Map.entry( 1_414_214,  1_000_000),\n                Map.entry(14_142_136, 10_000_000)\n        );\n        for (Map.Entry<Integer, Integer> frac : root2) {\n            System.out.printf(\"%8d /\u00a0%-8d = \", frac.getKey(), frac.getValue());\n            iterate(new R2cf(frac.getKey(), frac.getValue()));\n        }\n\n        System.out.println(\"\\nPi ->\");\n        List<Map.Entry<Integer, Integer>> pi = List.of(\n                Map.entry(         31,        10),\n                Map.entry(        314,       100),\n                Map.entry(      3_142,      1_000),\n                Map.entry(     31_428,     10_000),\n                Map.entry(    314_285,    100_000),\n                Map.entry(  3_142_857,   1_000_000),\n                Map.entry( 31_428_571,  10_000_000),\n                Map.entry(314_285_714, 100_000_000)\n        );\n        for (Map.Entry<Integer, Integer> frac : pi) {\n            System.out.printf(\"%9d /\u00a0%-9d = \", frac.getKey(), frac.getValue());\n            iterate(new R2cf(frac.getKey(), frac.getValue()));\n        }\n    }\n}\n"}
{"id": 130448, "name": "Continued fraction_Arithmetic_Construct from rational number", "source": "Translate Ruby to Java: \n\ndef r2cf(n1,n2)\n  while n2 > 0\n    n1, (t1, n2) = n2, n1.divmod(n2)\n    yield t1\n  end\nend\n", "target": "import java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\n\npublic class ConstructFromRationalNumber {\n    private static class R2cf implements Iterator<Integer> {\n        private int num;\n        private int den;\n\n        R2cf(int num, int den) {\n            this.num = num;\n            this.den = den;\n        }\n\n        @Override\n        public boolean hasNext() {\n            return den != 0;\n        }\n\n        @Override\n        public Integer next() {\n            int div = num / den;\n            int rem = num % den;\n            num = den;\n            den = rem;\n            return div;\n        }\n    }\n\n    private static void iterate(R2cf generator) {\n        generator.forEachRemaining(n -> System.out.printf(\"%d \", n));\n        System.out.println();\n    }\n\n    public static void main(String[] args) {\n        List<Map.Entry<Integer, Integer>> fracs = List.of(\n                Map.entry(1, 2),\n                Map.entry(3, 1),\n                Map.entry(23, 8),\n                Map.entry(13, 11),\n                Map.entry(22, 7),\n                Map.entry(-151, 77)\n        );\n        for (Map.Entry<Integer, Integer> frac : fracs) {\n            System.out.printf(\"%4d /\u00a0%-2d = \", frac.getKey(), frac.getValue());\n            iterate(new R2cf(frac.getKey(), frac.getValue()));\n        }\n\n        System.out.println(\"\\nSqrt(2) ->\");\n        List<Map.Entry<Integer, Integer>> root2 = List.of(\n                Map.entry(    14_142,     10_000),\n                Map.entry(   141_421,    100_000),\n                Map.entry( 1_414_214,  1_000_000),\n                Map.entry(14_142_136, 10_000_000)\n        );\n        for (Map.Entry<Integer, Integer> frac : root2) {\n            System.out.printf(\"%8d /\u00a0%-8d = \", frac.getKey(), frac.getValue());\n            iterate(new R2cf(frac.getKey(), frac.getValue()));\n        }\n\n        System.out.println(\"\\nPi ->\");\n        List<Map.Entry<Integer, Integer>> pi = List.of(\n                Map.entry(         31,        10),\n                Map.entry(        314,       100),\n                Map.entry(      3_142,      1_000),\n                Map.entry(     31_428,     10_000),\n                Map.entry(    314_285,    100_000),\n                Map.entry(  3_142_857,   1_000_000),\n                Map.entry( 31_428_571,  10_000_000),\n                Map.entry(314_285_714, 100_000_000)\n        );\n        for (Map.Entry<Integer, Integer> frac : pi) {\n            System.out.printf(\"%9d /\u00a0%-9d = \", frac.getKey(), frac.getValue());\n            iterate(new R2cf(frac.getKey(), frac.getValue()));\n        }\n    }\n}\n"}
{"id": 130449, "name": "Continued fraction_Arithmetic_Construct from rational number", "source": "Translate Ruby to Python: \n\ndef r2cf(n1,n2)\n  while n2 > 0\n    n1, (t1, n2) = n2, n1.divmod(n2)\n    yield t1\n  end\nend\n", "target": "def r2cf(n1,n2):\n  while n2:\n    n1, (t1, n2) = n2, divmod(n1, n2)\n    yield t1\n\nprint(list(r2cf(1,2)))    \nprint(list(r2cf(3,1)))    \nprint(list(r2cf(23,8)))    \nprint(list(r2cf(13,11)))    \nprint(list(r2cf(22,7)))    \nprint(list(r2cf(14142,10000)))    \nprint(list(r2cf(141421,100000)))    \nprint(list(r2cf(1414214,1000000)))    \nprint(list(r2cf(14142136,10000000)))    \n"}
{"id": 130450, "name": "Continued fraction_Arithmetic_Construct from rational number", "source": "Translate Ruby to Python: \n\ndef r2cf(n1,n2)\n  while n2 > 0\n    n1, (t1, n2) = n2, n1.divmod(n2)\n    yield t1\n  end\nend\n", "target": "def r2cf(n1,n2):\n  while n2:\n    n1, (t1, n2) = n2, divmod(n1, n2)\n    yield t1\n\nprint(list(r2cf(1,2)))    \nprint(list(r2cf(3,1)))    \nprint(list(r2cf(23,8)))    \nprint(list(r2cf(13,11)))    \nprint(list(r2cf(22,7)))    \nprint(list(r2cf(14142,10000)))    \nprint(list(r2cf(141421,100000)))    \nprint(list(r2cf(1414214,1000000)))    \nprint(list(r2cf(14142136,10000000)))    \n"}
{"id": 130879, "name": "Empty directory", "source": "Translate Ruby to C#: Dir.entries(\"testdir\").empty?\n", "target": "using System;\nusing System.IO;\n\nclass Program\n{\n    static void Main( string[] args )\n    {\n        foreach ( string dir in args )\n        {\n            Console.WriteLine( \"'{0}' {1} empty\", dir, IsDirectoryEmpty( dir ) ? \"is\" : \"is not\" );\n        }\n    }\n\n    private static bool IsDirectoryEmpty( string dir )\n    {\n        return ( Directory.GetFiles( dir ).Length == 0 &&\n            Directory.GetDirectories( dir ).Length == 0 );\n    }\n}\n"}
{"id": 130880, "name": "Empty directory", "source": "Translate Ruby to C#: Dir.entries(\"testdir\").empty?\n", "target": "using System;\nusing System.IO;\n\nclass Program\n{\n    static void Main( string[] args )\n    {\n        foreach ( string dir in args )\n        {\n            Console.WriteLine( \"'{0}' {1} empty\", dir, IsDirectoryEmpty( dir ) ? \"is\" : \"is not\" );\n        }\n    }\n\n    private static bool IsDirectoryEmpty( string dir )\n    {\n        return ( Directory.GetFiles( dir ).Length == 0 &&\n            Directory.GetDirectories( dir ).Length == 0 );\n    }\n}\n"}
{"id": 130883, "name": "Empty directory", "source": "Translate Ruby to Java: Dir.entries(\"testdir\").empty?\n", "target": "import java.nio.file.Paths;\n\npublic static boolean isEmptyDir(String dirName){\n    return Paths.get(dirName).toFile().listFiles().length == 0;\n}\n"}
{"id": 130884, "name": "Empty directory", "source": "Translate Ruby to Java: Dir.entries(\"testdir\").empty?\n", "target": "import java.nio.file.Paths;\n\npublic static boolean isEmptyDir(String dirName){\n    return Paths.get(dirName).toFile().listFiles().length == 0;\n}\n"}
{"id": 130885, "name": "Empty directory", "source": "Translate Ruby to Python: Dir.entries(\"testdir\").empty?\n", "target": "import os;\nif os.listdir(raw_input(\"directory\")):\n    print \"not empty\"\nelse:\n    print \"empty\"\n"}
{"id": 130886, "name": "Empty directory", "source": "Translate Ruby to Python: Dir.entries(\"testdir\").empty?\n", "target": "import os;\nif os.listdir(raw_input(\"directory\")):\n    print \"not empty\"\nelse:\n    print \"empty\"\n"}
{"id": 131085, "name": "Loops_Wrong ranges", "source": "Translate Ruby to C#: examples = [\n     [ -2,    2,    1],\n     [ -2,    2,    0], \n     [ -2,    2,   -1],\n     [ -2,    2,   10], \n     [  2,   -2,    1], \n     [  2,    2,    1], \n     [  2,    2,   -1], \n     [  2,    2,    0], \n     [  0,    0,    0]\n     ]\n\nexamples.each do |start, stop, step|\n  as = (start..stop).step(step)\n  puts \"\nend\n", "target": "using System;\nusing System.Collections.Generic;\n\nstatic class Program\n{\n    static void Main()\n    {\n        Example(-2, 2, 1, \"Normal\");\n        Example(-2, 2, 0, \"Zero increment\");\n        Example(-2, 2, -1, \"Increments away from stop value\");\n        Example(-2, 2, 10, \"First increment is beyond stop value\");\n        Example(2, -2, 1, \"Start more than stop: positive increment\");\n        Example(2, 2, 1, \"Start equal stop: positive increment\");\n        Example(2, 2, -1, \"Start equal stop: negative increment\");\n        Example(2, 2, 0, \"Start equal stop: zero increment\");\n        Example(0, 0, 0, \"Start equal stop equal zero: zero increment\");\n    }\n\n    static IEnumerable<int> Range(int start, int stop, int increment)\n    {\n        \n        \n\n        \n        \n\n        \n        for (int i = start; i <= stop; i += increment)\n            yield return i;\n    }\n\n    static void Example(int start, int stop, int increment, string comment)\n    {\n        \n        Console.Write((comment + \" \").PadRight(50, '-') + \" \");\n\n        const int MAX_ITER = 9;\n\n        int iteration = 0;\n        foreach (int i in Range(start, stop, increment))\n        {\n            Console.Write(\"{0,2} \", i);\n\n            if (++iteration > MAX_ITER) break;\n        }\n\n        Console.WriteLine();\n    }\n}\n"}
{"id": 131086, "name": "Loops_Wrong ranges", "source": "Translate Ruby to Java: examples = [\n     [ -2,    2,    1],\n     [ -2,    2,    0], \n     [ -2,    2,   -1],\n     [ -2,    2,   10], \n     [  2,   -2,    1], \n     [  2,    2,    1], \n     [  2,    2,   -1], \n     [  2,    2,    0], \n     [  0,    0,    0]\n     ]\n\nexamples.each do |start, stop, step|\n  as = (start..stop).step(step)\n  puts \"\nend\n", "target": "import java.util.ArrayList;\nimport java.util.List;\n\npublic class LoopsWrongRanges {\n\n    public static void main(String[] args) {\n        runTest(new LoopTest(-2, 2, 1, \"Normal\"));\n        runTest(new LoopTest(-2, 2, 0, \"Zero increment\"));\n        runTest(new LoopTest(-2, 2, -1, \"Increments away from stop value\"));\n        runTest(new LoopTest(-2, 2, 10, \"First increment is beyond stop value\"));\n        runTest(new LoopTest(2, -2, 1, \"Start more than stop: positive increment\"));\n        runTest(new LoopTest(2, 2, 1, \"Start equal stop: positive increment\"));\n        runTest(new LoopTest(2, 2, -1, \"Start equal stop: negative increment\"));\n        runTest(new LoopTest(2, 2, 0, \"Start equal stop: zero increment\"));\n        runTest(new LoopTest(0, 0, 0, \"Start equal stop equal zero: zero increment\"));\n    }\n    \n    private static void runTest(LoopTest loopTest) {\n        List<Integer> values = new ArrayList<>();\n        for (int i = loopTest.start ; i <= loopTest.stop ; i += loopTest.increment ) {\n            values.add(i);\n            if ( values.size() >= 10 ) {\n                break;\n            }\n        }\n        System.out.printf(\"%-45s %s%s%n\", loopTest.comment, values, values.size()==10 ? \" (loops forever)\" : \"\");\n    }\n    \n    private static class LoopTest {\n        int start;\n        int stop;\n        int increment;\n        String comment;\n        public LoopTest(int start, int stop, int increment, String comment) {\n            this.start = start;\n            this.stop = stop;\n            this.increment = increment;\n            this.comment = comment;\n        }\n    }\n\n}\n"}
{"id": 131087, "name": "Loops_Wrong ranges", "source": "Translate Ruby to Python: examples = [\n     [ -2,    2,    1],\n     [ -2,    2,    0], \n     [ -2,    2,   -1],\n     [ -2,    2,   10], \n     [  2,   -2,    1], \n     [  2,    2,    1], \n     [  2,    2,   -1], \n     [  2,    2,    0], \n     [  0,    0,    0]\n     ]\n\nexamples.each do |start, stop, step|\n  as = (start..stop).step(step)\n  puts \"\nend\n", "target": "import re\nfrom itertools import islice \n\n\n\n\ndata = \n\ntable = [re.split(r'\\s\\s+', line.strip()) for line in data.strip().split('\\n')]\n\nfor _start, _stop, _increment, comment in table[1:]:\n    start, stop, increment = [int(x) for x in (_start, _stop, _increment)]\n    print(f'{comment.upper()}:\\n  range({start}, {stop}, {increment})')\n    values = None\n    try: \n        values = list(islice(range(start, stop, increment), 999))\n    except ValueError as e:\n        print(' \u00a0!!ERROR!!', e)\n    if values is not None:\n        if len(values) < 22:\n            print('    =', values)\n        else:\n            print('    =', str(values[:22])[:-1], '...')\n"}
{"id": 131293, "name": "Bacon cipher", "source": "Translate Ruby to C#: CODES = {\n    'a' => \"AAAAA\", 'b' => \"AAAAB\", 'c' => \"AAABA\", 'd' => \"AAABB\", 'e' => \"AABAA\",\n    'f' => \"AABAB\", 'g' => \"AABBA\", 'h' => \"AABBB\", 'i' => \"ABAAA\", 'j' => \"ABAAB\",\n    'k' => \"ABABA\", 'l' => \"ABABB\", 'm' => \"ABBAA\", 'n' => \"ABBAB\", 'o' => \"ABBBA\",\n    'p' => \"ABBBB\", 'q' => \"BAAAA\", 'r' => \"BAAAB\", 's' => \"BAABA\", 't' => \"BAABB\",\n    'u' => \"BABAA\", 'v' => \"BABAB\", 'w' => \"BABBA\", 'x' => \"BABBB\", 'y' => \"BBAAA\",\n    'z' => \"BBAAB\", ' ' => \"BBBAA\", \n}\n\ndef encode(plainText, message)\n    pt = plainText.downcase\n    et = \"\"\n    pt.each_char { |c|\n        if 'a' <= c and c <= 'z' then\n            et.concat(CODES[c])\n        else\n            et.concat(CODES[' '])\n        end\n    }\n\n    mg = message.downcase\n    result = \"\"\n    count = 0\n    mg.each_char { |c|\n        if 'a' <= c and c <= 'z' then\n            if et[count] == 'A' then\n                result.concat(c)\n            else\n                result.concat(c.upcase)\n            end\n\n            count = count + 1\n            if count == et.length then\n                break\n            end\n        else\n            result.concat(c)\n        end\n    }\n\n    return result\nend\n\ndef decode(message)\n    et = \"\"\n    message.each_char { |c|\n        if 'a' <= c and c <= 'z' then\n            et.concat('A')\n        elsif 'A' <= c and c <= 'Z' then\n            et.concat('B')\n        end\n    }\n\n    result = \"\"\n    i = 0\n    while i < et.length do\n        quintet = et[i,5]\n        for k,v in CODES do\n            if v == quintet then\n                result.concat(k)\n                break\n            end\n        end\n\n        i = i + 5\n    end\n\n    return result\nend\n\ndef main\n    plainText = \"the quick brown fox jumps over the lazy dog\"\n    message = \"bacon's cipher is a method of steganography created by francis bacon. \" \\\n            + \"this task is to implement a program for encryption and decryption of \" \\\n            + \"plaintext using the simple alphabet of the baconian cipher or some \" \\\n            + \"other kind of representation of this alphabet (make anything signify anything). \" \\\n            + \"the baconian alphabet may optionally be extended to encode all lower \" \\\n            + \"case characters individually and/or adding a few punctuation characters \" \\\n            + \"such as the space.\"\n\n    cipherText = encode(plainText, message)\n    puts \"Cipher text -> \", cipherText\n\n    decodedText = decode(cipherText)\n    puts \"\\nHidden text ->\", decodedText\nend\n\nmain()\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Threading.Tasks;\n\nnamespace BaconCipher {\n    class Program {\n        private static Dictionary<char, string> codes = new Dictionary<char, string> {\n            {'a', \"AAAAA\" }, {'b', \"AAAAB\" }, {'c', \"AAABA\" }, {'d', \"AAABB\" }, {'e', \"AABAA\" },\n            {'f', \"AABAB\" }, {'g', \"AABBA\" }, {'h', \"AABBB\" }, {'i', \"ABAAA\" }, {'j', \"ABAAB\" },\n            {'k', \"ABABA\" }, {'l', \"ABABB\" }, {'m', \"ABBAA\" }, {'n', \"ABBAB\" }, {'o', \"ABBBA\" },\n            {'p', \"ABBBB\" }, {'q', \"BAAAA\" }, {'r', \"BAAAB\" }, {'s', \"BAABA\" }, {'t', \"BAABB\" },\n            {'u', \"BABAA\" }, {'v', \"BABAB\" }, {'w', \"BABBA\" }, {'x', \"BABBB\" }, {'y', \"BBAAA\" },\n            {'z', \"BBAAB\" }, {' ', \"BBBAA\" }, \n        };\n\n        private static string Encode(string plainText, string message) {\n            string pt = plainText.ToLower();\n            StringBuilder sb = new StringBuilder();\n            foreach (char c in pt) {\n                if ('a' <= c && c <= 'z') sb.Append(codes[c]);\n                else sb.Append(codes[' ']);\n            }\n            string et = sb.ToString();\n            string mg = message.ToLower();  \n            sb.Length = 0;\n            int count = 0;\n            foreach (char c in mg) {\n                if ('a' <= c && c <= 'z') {\n                    if (et[count] == 'A') sb.Append(c);\n                    else sb.Append((char)(c - 32)); \n                    count++;\n                    if (count == et.Length) break;\n                }\n                else sb.Append(c);\n            }\n\n            return sb.ToString();\n        }\n\n        private static string Decode(string message) {\n            StringBuilder sb = new StringBuilder();\n            foreach (char c in message) {\n                if ('a' <= c && c <= 'z') sb.Append('A');\n                else if ('A' <= c && c <= 'Z') sb.Append('B');\n            }\n            string et = sb.ToString();\n            sb.Length = 0;\n            for (int i = 0; i < et.Length; i += 5) {\n                string quintet = et.Substring(i, 5);\n                char key = codes.Where(a => a.Value == quintet).First().Key;\n                sb.Append(key);\n            }\n            return sb.ToString();\n        }\n\n        static void Main(string[] args) {\n            string plainText = \"the quick brown fox jumps over the lazy dog\";\n            string message = \"bacon's cipher is a method of steganography created by francis bacon. \" +\n                \"this task is to implement a program for encryption and decryption of \" +\n                \"plaintext using the simple alphabet of the baconian cipher or some \" +\n                \"other kind of representation of this alphabet (make anything signify anything). \" +\n                \"the baconian alphabet may optionally be extended to encode all lower \" +\n                \"case characters individually and/or adding a few punctuation characters \" +\n                \"such as the space.\";\n            string cipherText = Encode(plainText, message);\n            Console.WriteLine(\"Cipher text ->\\n{0}\", cipherText);\n            string decodedText = Decode(cipherText);\n            Console.WriteLine(\"\\nHidden text ->\\n{0}\", decodedText);\n        }\n    }\n}\n"}
{"id": 131294, "name": "Bacon cipher", "source": "Translate Ruby to C#: CODES = {\n    'a' => \"AAAAA\", 'b' => \"AAAAB\", 'c' => \"AAABA\", 'd' => \"AAABB\", 'e' => \"AABAA\",\n    'f' => \"AABAB\", 'g' => \"AABBA\", 'h' => \"AABBB\", 'i' => \"ABAAA\", 'j' => \"ABAAB\",\n    'k' => \"ABABA\", 'l' => \"ABABB\", 'm' => \"ABBAA\", 'n' => \"ABBAB\", 'o' => \"ABBBA\",\n    'p' => \"ABBBB\", 'q' => \"BAAAA\", 'r' => \"BAAAB\", 's' => \"BAABA\", 't' => \"BAABB\",\n    'u' => \"BABAA\", 'v' => \"BABAB\", 'w' => \"BABBA\", 'x' => \"BABBB\", 'y' => \"BBAAA\",\n    'z' => \"BBAAB\", ' ' => \"BBBAA\", \n}\n\ndef encode(plainText, message)\n    pt = plainText.downcase\n    et = \"\"\n    pt.each_char { |c|\n        if 'a' <= c and c <= 'z' then\n            et.concat(CODES[c])\n        else\n            et.concat(CODES[' '])\n        end\n    }\n\n    mg = message.downcase\n    result = \"\"\n    count = 0\n    mg.each_char { |c|\n        if 'a' <= c and c <= 'z' then\n            if et[count] == 'A' then\n                result.concat(c)\n            else\n                result.concat(c.upcase)\n            end\n\n            count = count + 1\n            if count == et.length then\n                break\n            end\n        else\n            result.concat(c)\n        end\n    }\n\n    return result\nend\n\ndef decode(message)\n    et = \"\"\n    message.each_char { |c|\n        if 'a' <= c and c <= 'z' then\n            et.concat('A')\n        elsif 'A' <= c and c <= 'Z' then\n            et.concat('B')\n        end\n    }\n\n    result = \"\"\n    i = 0\n    while i < et.length do\n        quintet = et[i,5]\n        for k,v in CODES do\n            if v == quintet then\n                result.concat(k)\n                break\n            end\n        end\n\n        i = i + 5\n    end\n\n    return result\nend\n\ndef main\n    plainText = \"the quick brown fox jumps over the lazy dog\"\n    message = \"bacon's cipher is a method of steganography created by francis bacon. \" \\\n            + \"this task is to implement a program for encryption and decryption of \" \\\n            + \"plaintext using the simple alphabet of the baconian cipher or some \" \\\n            + \"other kind of representation of this alphabet (make anything signify anything). \" \\\n            + \"the baconian alphabet may optionally be extended to encode all lower \" \\\n            + \"case characters individually and/or adding a few punctuation characters \" \\\n            + \"such as the space.\"\n\n    cipherText = encode(plainText, message)\n    puts \"Cipher text -> \", cipherText\n\n    decodedText = decode(cipherText)\n    puts \"\\nHidden text ->\", decodedText\nend\n\nmain()\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Threading.Tasks;\n\nnamespace BaconCipher {\n    class Program {\n        private static Dictionary<char, string> codes = new Dictionary<char, string> {\n            {'a', \"AAAAA\" }, {'b', \"AAAAB\" }, {'c', \"AAABA\" }, {'d', \"AAABB\" }, {'e', \"AABAA\" },\n            {'f', \"AABAB\" }, {'g', \"AABBA\" }, {'h', \"AABBB\" }, {'i', \"ABAAA\" }, {'j', \"ABAAB\" },\n            {'k', \"ABABA\" }, {'l', \"ABABB\" }, {'m', \"ABBAA\" }, {'n', \"ABBAB\" }, {'o', \"ABBBA\" },\n            {'p', \"ABBBB\" }, {'q', \"BAAAA\" }, {'r', \"BAAAB\" }, {'s', \"BAABA\" }, {'t', \"BAABB\" },\n            {'u', \"BABAA\" }, {'v', \"BABAB\" }, {'w', \"BABBA\" }, {'x', \"BABBB\" }, {'y', \"BBAAA\" },\n            {'z', \"BBAAB\" }, {' ', \"BBBAA\" }, \n        };\n\n        private static string Encode(string plainText, string message) {\n            string pt = plainText.ToLower();\n            StringBuilder sb = new StringBuilder();\n            foreach (char c in pt) {\n                if ('a' <= c && c <= 'z') sb.Append(codes[c]);\n                else sb.Append(codes[' ']);\n            }\n            string et = sb.ToString();\n            string mg = message.ToLower();  \n            sb.Length = 0;\n            int count = 0;\n            foreach (char c in mg) {\n                if ('a' <= c && c <= 'z') {\n                    if (et[count] == 'A') sb.Append(c);\n                    else sb.Append((char)(c - 32)); \n                    count++;\n                    if (count == et.Length) break;\n                }\n                else sb.Append(c);\n            }\n\n            return sb.ToString();\n        }\n\n        private static string Decode(string message) {\n            StringBuilder sb = new StringBuilder();\n            foreach (char c in message) {\n                if ('a' <= c && c <= 'z') sb.Append('A');\n                else if ('A' <= c && c <= 'Z') sb.Append('B');\n            }\n            string et = sb.ToString();\n            sb.Length = 0;\n            for (int i = 0; i < et.Length; i += 5) {\n                string quintet = et.Substring(i, 5);\n                char key = codes.Where(a => a.Value == quintet).First().Key;\n                sb.Append(key);\n            }\n            return sb.ToString();\n        }\n\n        static void Main(string[] args) {\n            string plainText = \"the quick brown fox jumps over the lazy dog\";\n            string message = \"bacon's cipher is a method of steganography created by francis bacon. \" +\n                \"this task is to implement a program for encryption and decryption of \" +\n                \"plaintext using the simple alphabet of the baconian cipher or some \" +\n                \"other kind of representation of this alphabet (make anything signify anything). \" +\n                \"the baconian alphabet may optionally be extended to encode all lower \" +\n                \"case characters individually and/or adding a few punctuation characters \" +\n                \"such as the space.\";\n            string cipherText = Encode(plainText, message);\n            Console.WriteLine(\"Cipher text ->\\n{0}\", cipherText);\n            string decodedText = Decode(cipherText);\n            Console.WriteLine(\"\\nHidden text ->\\n{0}\", decodedText);\n        }\n    }\n}\n"}
{"id": 131297, "name": "Bacon cipher", "source": "Translate Ruby to Java: CODES = {\n    'a' => \"AAAAA\", 'b' => \"AAAAB\", 'c' => \"AAABA\", 'd' => \"AAABB\", 'e' => \"AABAA\",\n    'f' => \"AABAB\", 'g' => \"AABBA\", 'h' => \"AABBB\", 'i' => \"ABAAA\", 'j' => \"ABAAB\",\n    'k' => \"ABABA\", 'l' => \"ABABB\", 'm' => \"ABBAA\", 'n' => \"ABBAB\", 'o' => \"ABBBA\",\n    'p' => \"ABBBB\", 'q' => \"BAAAA\", 'r' => \"BAAAB\", 's' => \"BAABA\", 't' => \"BAABB\",\n    'u' => \"BABAA\", 'v' => \"BABAB\", 'w' => \"BABBA\", 'x' => \"BABBB\", 'y' => \"BBAAA\",\n    'z' => \"BBAAB\", ' ' => \"BBBAA\", \n}\n\ndef encode(plainText, message)\n    pt = plainText.downcase\n    et = \"\"\n    pt.each_char { |c|\n        if 'a' <= c and c <= 'z' then\n            et.concat(CODES[c])\n        else\n            et.concat(CODES[' '])\n        end\n    }\n\n    mg = message.downcase\n    result = \"\"\n    count = 0\n    mg.each_char { |c|\n        if 'a' <= c and c <= 'z' then\n            if et[count] == 'A' then\n                result.concat(c)\n            else\n                result.concat(c.upcase)\n            end\n\n            count = count + 1\n            if count == et.length then\n                break\n            end\n        else\n            result.concat(c)\n        end\n    }\n\n    return result\nend\n\ndef decode(message)\n    et = \"\"\n    message.each_char { |c|\n        if 'a' <= c and c <= 'z' then\n            et.concat('A')\n        elsif 'A' <= c and c <= 'Z' then\n            et.concat('B')\n        end\n    }\n\n    result = \"\"\n    i = 0\n    while i < et.length do\n        quintet = et[i,5]\n        for k,v in CODES do\n            if v == quintet then\n                result.concat(k)\n                break\n            end\n        end\n\n        i = i + 5\n    end\n\n    return result\nend\n\ndef main\n    plainText = \"the quick brown fox jumps over the lazy dog\"\n    message = \"bacon's cipher is a method of steganography created by francis bacon. \" \\\n            + \"this task is to implement a program for encryption and decryption of \" \\\n            + \"plaintext using the simple alphabet of the baconian cipher or some \" \\\n            + \"other kind of representation of this alphabet (make anything signify anything). \" \\\n            + \"the baconian alphabet may optionally be extended to encode all lower \" \\\n            + \"case characters individually and/or adding a few punctuation characters \" \\\n            + \"such as the space.\"\n\n    cipherText = encode(plainText, message)\n    puts \"Cipher text -> \", cipherText\n\n    decodedText = decode(cipherText)\n    puts \"\\nHidden text ->\", decodedText\nend\n\nmain()\n", "target": "import java.util.HashMap;\nimport java.util.Map;\nimport java.util.Objects;\n\npublic class BaconCipher {\n    private static final Map<Character, String> codes;\n\n    static {\n        codes = new HashMap<>();\n        codes.putAll(Map.of(\n            'a', \"AAAAA\", 'b', \"AAAAB\", 'c', \"AAABA\", 'd', \"AAABB\", 'e', \"AABAA\",\n            'f', \"AABAB\", 'g', \"AABBA\", 'h', \"AABBB\", 'i', \"ABAAA\", 'j', \"ABAAB\"\n        ));\n        codes.putAll(Map.of(\n            'k', \"ABABA\", 'l', \"ABABB\", 'm', \"ABBAA\", 'n', \"ABBAB\", 'o', \"ABBBA\",\n            'p', \"ABBBB\", 'q', \"BAAAA\", 'r', \"BAAAB\", 's', \"BAABA\", 't', \"BAABB\"\n        ));\n        codes.putAll(Map.of(\n            'u', \"BABAA\", 'v', \"BABAB\", 'w', \"BABBA\", 'x', \"BABBB\", 'y', \"BBAAA\",\n            'z', \"BBAAB\", ' ', \"BBBAA\" \n        ));\n    }\n\n    private static String encode(String plainText, String message) {\n        String pt = plainText.toLowerCase();\n        StringBuilder sb = new StringBuilder();\n        for (char c : pt.toCharArray()) {\n            if ('a' <= c && c <= 'z') sb.append(codes.get(c));\n            else sb.append(codes.get(' '));\n        }\n        String et = sb.toString();\n        String mg = message.toLowerCase();  \n        sb.setLength(0);\n        int count = 0;\n        for (char c : mg.toCharArray()) {\n            if ('a' <= c && c <= 'z') {\n                if (et.charAt(count) == 'A') sb.append(c);\n                else sb.append(((char) (c - 32))); \n                count++;\n                if (count == et.length()) break;\n            } else sb.append(c);\n        }\n        return sb.toString();\n    }\n\n    private static String decode(String message) {\n        StringBuilder sb = new StringBuilder();\n        for (char c : message.toCharArray()) {\n            if ('a' <= c && c <= 'z') sb.append('A');\n            if ('A' <= c && c <= 'Z') sb.append('B');\n        }\n        String et = sb.toString();\n        sb.setLength(0);\n        for (int i = 0; i < et.length(); i += 5) {\n            String quintet = et.substring(i, i + 5);\n            Character key = codes.entrySet().stream().filter(a -> Objects.equals(a.getValue(), quintet)).findFirst().map(Map.Entry::getKey).orElse(null);\n            sb.append(key);\n        }\n        return sb.toString();\n    }\n\n    public static void main(String[] args) {\n        String plainText = \"the quick brown fox jumps over the lazy dog\";\n        String message = \"bacon's cipher is a method of steganography created by francis bacon. \" +\n            \"this task is to implement a program for encryption and decryption of \" +\n            \"plaintext using the simple alphabet of the baconian cipher or some \" +\n            \"other kind of representation of this alphabet (make anything signify anything). \" +\n            \"the baconian alphabet may optionally be extended to encode all lower \" +\n            \"case characters individually and/or adding a few punctuation characters \" +\n            \"such as the space.\";\n        String cipherText = encode(plainText, message);\n        System.out.printf(\"Cipher text ->\\n\\n%s\\n\", cipherText);\n        String decodedText = decode(cipherText);\n        System.out.printf(\"\\nHidden text ->\\n\\n%s\\n\", decodedText);\n    }\n}\n"}
{"id": 131298, "name": "Bacon cipher", "source": "Translate Ruby to Java: CODES = {\n    'a' => \"AAAAA\", 'b' => \"AAAAB\", 'c' => \"AAABA\", 'd' => \"AAABB\", 'e' => \"AABAA\",\n    'f' => \"AABAB\", 'g' => \"AABBA\", 'h' => \"AABBB\", 'i' => \"ABAAA\", 'j' => \"ABAAB\",\n    'k' => \"ABABA\", 'l' => \"ABABB\", 'm' => \"ABBAA\", 'n' => \"ABBAB\", 'o' => \"ABBBA\",\n    'p' => \"ABBBB\", 'q' => \"BAAAA\", 'r' => \"BAAAB\", 's' => \"BAABA\", 't' => \"BAABB\",\n    'u' => \"BABAA\", 'v' => \"BABAB\", 'w' => \"BABBA\", 'x' => \"BABBB\", 'y' => \"BBAAA\",\n    'z' => \"BBAAB\", ' ' => \"BBBAA\", \n}\n\ndef encode(plainText, message)\n    pt = plainText.downcase\n    et = \"\"\n    pt.each_char { |c|\n        if 'a' <= c and c <= 'z' then\n            et.concat(CODES[c])\n        else\n            et.concat(CODES[' '])\n        end\n    }\n\n    mg = message.downcase\n    result = \"\"\n    count = 0\n    mg.each_char { |c|\n        if 'a' <= c and c <= 'z' then\n            if et[count] == 'A' then\n                result.concat(c)\n            else\n                result.concat(c.upcase)\n            end\n\n            count = count + 1\n            if count == et.length then\n                break\n            end\n        else\n            result.concat(c)\n        end\n    }\n\n    return result\nend\n\ndef decode(message)\n    et = \"\"\n    message.each_char { |c|\n        if 'a' <= c and c <= 'z' then\n            et.concat('A')\n        elsif 'A' <= c and c <= 'Z' then\n            et.concat('B')\n        end\n    }\n\n    result = \"\"\n    i = 0\n    while i < et.length do\n        quintet = et[i,5]\n        for k,v in CODES do\n            if v == quintet then\n                result.concat(k)\n                break\n            end\n        end\n\n        i = i + 5\n    end\n\n    return result\nend\n\ndef main\n    plainText = \"the quick brown fox jumps over the lazy dog\"\n    message = \"bacon's cipher is a method of steganography created by francis bacon. \" \\\n            + \"this task is to implement a program for encryption and decryption of \" \\\n            + \"plaintext using the simple alphabet of the baconian cipher or some \" \\\n            + \"other kind of representation of this alphabet (make anything signify anything). \" \\\n            + \"the baconian alphabet may optionally be extended to encode all lower \" \\\n            + \"case characters individually and/or adding a few punctuation characters \" \\\n            + \"such as the space.\"\n\n    cipherText = encode(plainText, message)\n    puts \"Cipher text -> \", cipherText\n\n    decodedText = decode(cipherText)\n    puts \"\\nHidden text ->\", decodedText\nend\n\nmain()\n", "target": "import java.util.HashMap;\nimport java.util.Map;\nimport java.util.Objects;\n\npublic class BaconCipher {\n    private static final Map<Character, String> codes;\n\n    static {\n        codes = new HashMap<>();\n        codes.putAll(Map.of(\n            'a', \"AAAAA\", 'b', \"AAAAB\", 'c', \"AAABA\", 'd', \"AAABB\", 'e', \"AABAA\",\n            'f', \"AABAB\", 'g', \"AABBA\", 'h', \"AABBB\", 'i', \"ABAAA\", 'j', \"ABAAB\"\n        ));\n        codes.putAll(Map.of(\n            'k', \"ABABA\", 'l', \"ABABB\", 'm', \"ABBAA\", 'n', \"ABBAB\", 'o', \"ABBBA\",\n            'p', \"ABBBB\", 'q', \"BAAAA\", 'r', \"BAAAB\", 's', \"BAABA\", 't', \"BAABB\"\n        ));\n        codes.putAll(Map.of(\n            'u', \"BABAA\", 'v', \"BABAB\", 'w', \"BABBA\", 'x', \"BABBB\", 'y', \"BBAAA\",\n            'z', \"BBAAB\", ' ', \"BBBAA\" \n        ));\n    }\n\n    private static String encode(String plainText, String message) {\n        String pt = plainText.toLowerCase();\n        StringBuilder sb = new StringBuilder();\n        for (char c : pt.toCharArray()) {\n            if ('a' <= c && c <= 'z') sb.append(codes.get(c));\n            else sb.append(codes.get(' '));\n        }\n        String et = sb.toString();\n        String mg = message.toLowerCase();  \n        sb.setLength(0);\n        int count = 0;\n        for (char c : mg.toCharArray()) {\n            if ('a' <= c && c <= 'z') {\n                if (et.charAt(count) == 'A') sb.append(c);\n                else sb.append(((char) (c - 32))); \n                count++;\n                if (count == et.length()) break;\n            } else sb.append(c);\n        }\n        return sb.toString();\n    }\n\n    private static String decode(String message) {\n        StringBuilder sb = new StringBuilder();\n        for (char c : message.toCharArray()) {\n            if ('a' <= c && c <= 'z') sb.append('A');\n            if ('A' <= c && c <= 'Z') sb.append('B');\n        }\n        String et = sb.toString();\n        sb.setLength(0);\n        for (int i = 0; i < et.length(); i += 5) {\n            String quintet = et.substring(i, i + 5);\n            Character key = codes.entrySet().stream().filter(a -> Objects.equals(a.getValue(), quintet)).findFirst().map(Map.Entry::getKey).orElse(null);\n            sb.append(key);\n        }\n        return sb.toString();\n    }\n\n    public static void main(String[] args) {\n        String plainText = \"the quick brown fox jumps over the lazy dog\";\n        String message = \"bacon's cipher is a method of steganography created by francis bacon. \" +\n            \"this task is to implement a program for encryption and decryption of \" +\n            \"plaintext using the simple alphabet of the baconian cipher or some \" +\n            \"other kind of representation of this alphabet (make anything signify anything). \" +\n            \"the baconian alphabet may optionally be extended to encode all lower \" +\n            \"case characters individually and/or adding a few punctuation characters \" +\n            \"such as the space.\";\n        String cipherText = encode(plainText, message);\n        System.out.printf(\"Cipher text ->\\n\\n%s\\n\", cipherText);\n        String decodedText = decode(cipherText);\n        System.out.printf(\"\\nHidden text ->\\n\\n%s\\n\", decodedText);\n    }\n}\n"}
{"id": 131299, "name": "Bacon cipher", "source": "Translate Ruby to Python: CODES = {\n    'a' => \"AAAAA\", 'b' => \"AAAAB\", 'c' => \"AAABA\", 'd' => \"AAABB\", 'e' => \"AABAA\",\n    'f' => \"AABAB\", 'g' => \"AABBA\", 'h' => \"AABBB\", 'i' => \"ABAAA\", 'j' => \"ABAAB\",\n    'k' => \"ABABA\", 'l' => \"ABABB\", 'm' => \"ABBAA\", 'n' => \"ABBAB\", 'o' => \"ABBBA\",\n    'p' => \"ABBBB\", 'q' => \"BAAAA\", 'r' => \"BAAAB\", 's' => \"BAABA\", 't' => \"BAABB\",\n    'u' => \"BABAA\", 'v' => \"BABAB\", 'w' => \"BABBA\", 'x' => \"BABBB\", 'y' => \"BBAAA\",\n    'z' => \"BBAAB\", ' ' => \"BBBAA\", \n}\n\ndef encode(plainText, message)\n    pt = plainText.downcase\n    et = \"\"\n    pt.each_char { |c|\n        if 'a' <= c and c <= 'z' then\n            et.concat(CODES[c])\n        else\n            et.concat(CODES[' '])\n        end\n    }\n\n    mg = message.downcase\n    result = \"\"\n    count = 0\n    mg.each_char { |c|\n        if 'a' <= c and c <= 'z' then\n            if et[count] == 'A' then\n                result.concat(c)\n            else\n                result.concat(c.upcase)\n            end\n\n            count = count + 1\n            if count == et.length then\n                break\n            end\n        else\n            result.concat(c)\n        end\n    }\n\n    return result\nend\n\ndef decode(message)\n    et = \"\"\n    message.each_char { |c|\n        if 'a' <= c and c <= 'z' then\n            et.concat('A')\n        elsif 'A' <= c and c <= 'Z' then\n            et.concat('B')\n        end\n    }\n\n    result = \"\"\n    i = 0\n    while i < et.length do\n        quintet = et[i,5]\n        for k,v in CODES do\n            if v == quintet then\n                result.concat(k)\n                break\n            end\n        end\n\n        i = i + 5\n    end\n\n    return result\nend\n\ndef main\n    plainText = \"the quick brown fox jumps over the lazy dog\"\n    message = \"bacon's cipher is a method of steganography created by francis bacon. \" \\\n            + \"this task is to implement a program for encryption and decryption of \" \\\n            + \"plaintext using the simple alphabet of the baconian cipher or some \" \\\n            + \"other kind of representation of this alphabet (make anything signify anything). \" \\\n            + \"the baconian alphabet may optionally be extended to encode all lower \" \\\n            + \"case characters individually and/or adding a few punctuation characters \" \\\n            + \"such as the space.\"\n\n    cipherText = encode(plainText, message)\n    puts \"Cipher text -> \", cipherText\n\n    decodedText = decode(cipherText)\n    puts \"\\nHidden text ->\", decodedText\nend\n\nmain()\n", "target": "import string\n\nsometext = .lower()\n\nlc2bin = {ch: '{:05b}'.format(i) \n          for i, ch in enumerate(string.ascii_lowercase + ' .')}\nbin2lc = {val: key for key, val in lc2bin.items()}\n\nphrase = 'Rosetta code Bacon cipher example secret phrase to encode in the capitalisation of peter pan'.lower()\n\ndef to_5binary(msg):\n    return ( ch == '1' for ch in ''.join(lc2bin.get(ch, '') for ch in msg.lower()))\n\ndef encrypt(message, text):\n    bin5 = to_5binary(message)\n    textlist = list(text.lower())\n    out = []\n    for capitalise in bin5:\n        while textlist:\n            ch = textlist.pop(0)\n            if ch.isalpha():\n                if capitalise:\n                    ch = ch.upper()\n                out.append(ch)\n                break\n            else:\n                out.append(ch)\n        else:\n            raise Exception('ERROR: Ran out of characters in sometext')\n    return ''.join(out) + '...'\n\n\ndef  decrypt(bacontext):\n    binary = []\n    bin5 = []\n    out = []\n    for ch in bacontext:\n        if ch.isalpha():\n            binary.append('1' if ch.isupper() else '0')\n            if len(binary) == 5:\n                bin5 = ''.join(binary)\n                out.append(bin2lc[bin5])\n                binary = []\n    return ''.join(out)\n                \n\nprint('PLAINTEXT = \\n%s\\n' % phrase)\nencrypted = encrypt(phrase, sometext)\nprint('ENCRYPTED = \\n%s\\n' % encrypted)\ndecrypted = decrypt(encrypted)\nprint('DECRYPTED = \\n%s\\n' % decrypted)\nassert phrase == decrypted, 'Round-tripping error'\n"}
{"id": 131300, "name": "Bacon cipher", "source": "Translate Ruby to Python: CODES = {\n    'a' => \"AAAAA\", 'b' => \"AAAAB\", 'c' => \"AAABA\", 'd' => \"AAABB\", 'e' => \"AABAA\",\n    'f' => \"AABAB\", 'g' => \"AABBA\", 'h' => \"AABBB\", 'i' => \"ABAAA\", 'j' => \"ABAAB\",\n    'k' => \"ABABA\", 'l' => \"ABABB\", 'm' => \"ABBAA\", 'n' => \"ABBAB\", 'o' => \"ABBBA\",\n    'p' => \"ABBBB\", 'q' => \"BAAAA\", 'r' => \"BAAAB\", 's' => \"BAABA\", 't' => \"BAABB\",\n    'u' => \"BABAA\", 'v' => \"BABAB\", 'w' => \"BABBA\", 'x' => \"BABBB\", 'y' => \"BBAAA\",\n    'z' => \"BBAAB\", ' ' => \"BBBAA\", \n}\n\ndef encode(plainText, message)\n    pt = plainText.downcase\n    et = \"\"\n    pt.each_char { |c|\n        if 'a' <= c and c <= 'z' then\n            et.concat(CODES[c])\n        else\n            et.concat(CODES[' '])\n        end\n    }\n\n    mg = message.downcase\n    result = \"\"\n    count = 0\n    mg.each_char { |c|\n        if 'a' <= c and c <= 'z' then\n            if et[count] == 'A' then\n                result.concat(c)\n            else\n                result.concat(c.upcase)\n            end\n\n            count = count + 1\n            if count == et.length then\n                break\n            end\n        else\n            result.concat(c)\n        end\n    }\n\n    return result\nend\n\ndef decode(message)\n    et = \"\"\n    message.each_char { |c|\n        if 'a' <= c and c <= 'z' then\n            et.concat('A')\n        elsif 'A' <= c and c <= 'Z' then\n            et.concat('B')\n        end\n    }\n\n    result = \"\"\n    i = 0\n    while i < et.length do\n        quintet = et[i,5]\n        for k,v in CODES do\n            if v == quintet then\n                result.concat(k)\n                break\n            end\n        end\n\n        i = i + 5\n    end\n\n    return result\nend\n\ndef main\n    plainText = \"the quick brown fox jumps over the lazy dog\"\n    message = \"bacon's cipher is a method of steganography created by francis bacon. \" \\\n            + \"this task is to implement a program for encryption and decryption of \" \\\n            + \"plaintext using the simple alphabet of the baconian cipher or some \" \\\n            + \"other kind of representation of this alphabet (make anything signify anything). \" \\\n            + \"the baconian alphabet may optionally be extended to encode all lower \" \\\n            + \"case characters individually and/or adding a few punctuation characters \" \\\n            + \"such as the space.\"\n\n    cipherText = encode(plainText, message)\n    puts \"Cipher text -> \", cipherText\n\n    decodedText = decode(cipherText)\n    puts \"\\nHidden text ->\", decodedText\nend\n\nmain()\n", "target": "import string\n\nsometext = .lower()\n\nlc2bin = {ch: '{:05b}'.format(i) \n          for i, ch in enumerate(string.ascii_lowercase + ' .')}\nbin2lc = {val: key for key, val in lc2bin.items()}\n\nphrase = 'Rosetta code Bacon cipher example secret phrase to encode in the capitalisation of peter pan'.lower()\n\ndef to_5binary(msg):\n    return ( ch == '1' for ch in ''.join(lc2bin.get(ch, '') for ch in msg.lower()))\n\ndef encrypt(message, text):\n    bin5 = to_5binary(message)\n    textlist = list(text.lower())\n    out = []\n    for capitalise in bin5:\n        while textlist:\n            ch = textlist.pop(0)\n            if ch.isalpha():\n                if capitalise:\n                    ch = ch.upper()\n                out.append(ch)\n                break\n            else:\n                out.append(ch)\n        else:\n            raise Exception('ERROR: Ran out of characters in sometext')\n    return ''.join(out) + '...'\n\n\ndef  decrypt(bacontext):\n    binary = []\n    bin5 = []\n    out = []\n    for ch in bacontext:\n        if ch.isalpha():\n            binary.append('1' if ch.isupper() else '0')\n            if len(binary) == 5:\n                bin5 = ''.join(binary)\n                out.append(bin2lc[bin5])\n                binary = []\n    return ''.join(out)\n                \n\nprint('PLAINTEXT = \\n%s\\n' % phrase)\nencrypted = encrypt(phrase, sometext)\nprint('ENCRYPTED = \\n%s\\n' % encrypted)\ndecrypted = decrypt(encrypted)\nprint('DECRYPTED = \\n%s\\n' % decrypted)\nassert phrase == decrypted, 'Round-tripping error'\n"}
{"id": 131474, "name": "Constrained random points on a circle", "source": "Translate Ruby to C#: points = (1..100).map do\n  \n  angle = rand * 2.0 * Math::PI\n  rad   = rand * 5.0 + 10.0\n  \n  [rad * Math::cos(angle), rad * Math::sin(angle)].map(&:round)\nend\n\n(-15..15).each do |row|\n  puts (-15..15).map { |col| points.include?([row, col]) ? \"X\" : \" \" }.join\nend\n\nload 'raster_graphics.rb'\n\npixmap = Pixmap.new(321,321)\npixmap.draw_circle(Pixel.new(160,160),90,RGBColour::BLACK)\npixmap.draw_circle(Pixel.new(160,160),160,RGBColour::BLACK)\npoints.each {|(x,y)| pixmap[10*(x+16),10*(y+16)] = RGBColour::BLACK}\npngfile = __FILE__\npngfile[/\\.rb/] = \".png\"\npixmap.save_as_png(pngfile)\n", "target": "using System;\nusing System.Diagnostics;\nusing System.Drawing;\n\nnamespace RosettaConstrainedRandomCircle\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            var points = new Point[404];\n            int i = 0;\n            for (int y = -15; y <= 15; y++)\n                for (int x = -15; x <= 15 && i < 404; x++)\n                {\n                    var c = Math.Sqrt(x * x + y * y);\n                    if (10 <= c && c <= 15)\n                    {\n                        points[i++] = new Point(x, y);\n                    }\n                }\n\n            var bm = new Bitmap(600, 600);\n            var g = Graphics.FromImage(bm);\n            var brush = new SolidBrush(Color.Magenta);\n\n            var r = new System.Random();\n            for (int count = 0; count < 100; count++)\n            {\n                var p = points[r.Next(404)];\n                g.FillEllipse(brush, new Rectangle(290 + 19 * p.X, 290 + 19 * p.Y, 10, 10));\n            }\n            const string filename = \"Constrained Random Circle.png\";\n            bm.Save(filename);\n            Process.Start(filename);\n        }\n    }\n}\n"}
{"id": 131476, "name": "Constrained random points on a circle", "source": "Translate Ruby to Java: points = (1..100).map do\n  \n  angle = rand * 2.0 * Math::PI\n  rad   = rand * 5.0 + 10.0\n  \n  [rad * Math::cos(angle), rad * Math::sin(angle)].map(&:round)\nend\n\n(-15..15).each do |row|\n  puts (-15..15).map { |col| points.include?([row, col]) ? \"X\" : \" \" }.join\nend\n\nload 'raster_graphics.rb'\n\npixmap = Pixmap.new(321,321)\npixmap.draw_circle(Pixel.new(160,160),90,RGBColour::BLACK)\npixmap.draw_circle(Pixel.new(160,160),160,RGBColour::BLACK)\npoints.each {|(x,y)| pixmap[10*(x+16),10*(y+16)] = RGBColour::BLACK}\npngfile = __FILE__\npngfile[/\\.rb/] = \".png\"\npixmap.save_as_png(pngfile)\n", "target": "import java.util.Random;\n\npublic class FuzzyCircle {\n\tstatic final Random rnd = new Random();\n\tpublic static void main(String[] args){\n\t\tchar[][] field = new char[31][31];\n\t\tfor(int i = 0; i < field.length; i++){\n\t\t\tfor(int j = 0; j < field[i].length; j++){\n\t\t\t\tfield[i][j] = ' ';\n\t\t\t}\n\t\t}\n\t\tint pointsInDisc = 0;\n\t\twhile(pointsInDisc < 100){\n\t\t\tint x = rnd.nextInt(31) - 15;\n\t\t\tint y = rnd.nextInt(31) - 15;\n\t\t\tdouble dist = Math.hypot(x, y);\n\t\t\tif(dist >= 10 && dist <= 15 && field[x + 15][y + 15] == ' '){\n\t\t\t\tfield[x + 15][y + 15] = 'X';\n\t\t\t\tpointsInDisc++;\n\t\t\t}\n\t\t}\n\t\tfor(char[] row:field){\n\t\t\tfor(char space:row){\n\t\t\t\tSystem.out.print(space);\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t}\n}\n"}
{"id": 131477, "name": "Constrained random points on a circle", "source": "Translate Ruby to Python: points = (1..100).map do\n  \n  angle = rand * 2.0 * Math::PI\n  rad   = rand * 5.0 + 10.0\n  \n  [rad * Math::cos(angle), rad * Math::sin(angle)].map(&:round)\nend\n\n(-15..15).each do |row|\n  puts (-15..15).map { |col| points.include?([row, col]) ? \"X\" : \" \" }.join\nend\n\nload 'raster_graphics.rb'\n\npixmap = Pixmap.new(321,321)\npixmap.draw_circle(Pixel.new(160,160),90,RGBColour::BLACK)\npixmap.draw_circle(Pixel.new(160,160),160,RGBColour::BLACK)\npoints.each {|(x,y)| pixmap[10*(x+16),10*(y+16)] = RGBColour::BLACK}\npngfile = __FILE__\npngfile[/\\.rb/] = \".png\"\npixmap.save_as_png(pngfile)\n", "target": ">>> from collections import defaultdict\n>>> from random import choice\n>>> world = defaultdict(int)\n>>> possiblepoints = [(x,y) for x in range(-15,16)\n\t\t  for y in range(-15,16)\n\t\t  if 10 <= abs(x+y*1j) <= 15]\n>>> for i in range(100): world[choice(possiblepoints)] += 1\n\n>>> for x in range(-15,16):\n\tprint(''.join(str(min([9, world[(x,y)]])) if world[(x,y)] else ' '\n\t\t\t  for y in range(-15,16)))\n\n\t\n                               \n             1     1           \n          1 1                  \n      11 1     1  1     1      \n     111  1     1211           \n      1   2    1 1    11       \n      1  11         21         \n     1   1            11  1    \n   1  2                1 1     \n                               \n 1  2                          \n   1 1                      1  \n   1 1                         \n   2                      11   \n  1                         1  \n                         1     \n                               \n                               \n  1                          1 \n                         1     \n                         2     \n                            1  \n     1                  1 1    \n      1                2   1   \n   1   3            11  2      \n    11   1    1      1   2     \n            1   1    2         \n        1  1                   \n         1      1     1        \n          2 2   1              \n               1\n"}
{"id": 131629, "name": "Call an object method", "source": "Translate Ruby to C#: \nMyClass.some_method(some_parameter)\n\n\nfoo = MyClass\nfoo.some_method(some_parameter)\n\n\n\nmy_instance.a_method(some_parameter)\n\n\nmy_instance.a_method some_parameter\n\n\nmy_instance.another_method\n", "target": "\nMyClass.Method(someParameter);\n \n\nmyInstance.Method(someParameter);\n"}
{"id": 131631, "name": "Call an object method", "source": "Translate Ruby to Java: \nMyClass.some_method(some_parameter)\n\n\nfoo = MyClass\nfoo.some_method(some_parameter)\n\n\n\nmy_instance.a_method(some_parameter)\n\n\nmy_instance.a_method some_parameter\n\n\nmy_instance.another_method\n", "target": "\nMyClass.method(someParameter);\n\n\nmyInstance.method(someParameter);\n"}
{"id": 131632, "name": "Call an object method", "source": "Translate Ruby to Python: \nMyClass.some_method(some_parameter)\n\n\nfoo = MyClass\nfoo.some_method(some_parameter)\n\n\n\nmy_instance.a_method(some_parameter)\n\n\nmy_instance.a_method some_parameter\n\n\nmy_instance.another_method\n", "target": "class MyClass(object):\n\t@classmethod\n\tdef myClassMethod(self, x):\n\t\tpass\n\t@staticmethod\n\tdef myStaticMethod(x):\n\t\tpass\n\tdef myMethod(self, x):\n\t\treturn 42 + x\n\nmyInstance = MyClass()\n\n\nmyInstance.myMethod(someParameter)\n\nMyClass.myMethod(myInstance, someParameter)\n\n\n\nMyClass.myClassMethod(someParameter)\nMyClass.myStaticMethod(someParameter)\n\nmyInstance.myClassMethod(someParameter)\nmyInstance.myStaticMethod(someParameter)\n"}
{"id": 131809, "name": "SHA-256", "source": "Translate Ruby to C#: require \"openssl\"\nputs OpenSSL::Digest.new(\"SHA256\").update(\"Rosetta code\")\n", "target": "using System;\nusing System.Security.Cryptography;\nusing System.Text;\nusing Microsoft.VisualStudio.TestTools.UnitTesting;\n\nnamespace RosettaCode.SHA256\n{\n    [TestClass]\n    public class SHA256ManagedTest\n    {\n        [TestMethod]\n        public void TestComputeHash()\n        {\n            var buffer = Encoding.UTF8.GetBytes(\"Rosetta code\");\n            var hashAlgorithm = new SHA256Managed();\n            var hash = hashAlgorithm.ComputeHash(buffer);\n            Assert.AreEqual(\n                \"76-4F-AF-5C-61-AC-31-5F-14-97-F9-DF-A5-42-71-39-65-B7-85-E5-CC-2F-70-7D-64-68-D7-D1-12-4C-DF-CF\",\n                BitConverter.ToString(hash));\n        }\n    }\n}\n"}
{"id": 131811, "name": "SHA-256", "source": "Translate Ruby to Python: require \"openssl\"\nputs OpenSSL::Digest.new(\"SHA256\").update(\"Rosetta code\")\n", "target": ">>> import hashlib\n>>> hashlib.sha256( \"Rosetta code\".encode() ).hexdigest()\n'764faf5c61ac315f1497f9dfa542713965b785e5cc2f707d6468d7d1124cdfcf'\n>>>\n"}
{"id": 131995, "name": "Factors of a Mersenne number", "source": "Translate Ruby to C#: require \"big\"\n\ndef prime?(n)                             \n  return n | 1 == 3 if n < 5              \n  return false if n.gcd(6) != 1           \n  pc1, pc2 = -1, 1                        \n  until (pc1 += 6) > Math.sqrt(n).to_i    \n    return false if n % pc1 == 0 || n % (pc2 += 6) == 0  \n  end\n  true\nend\n\n\ndef powmod(b, e, m)\n  r, b = 1.to_big_i, b.to_big_i\n  while e > 0\n    r = (r * b) % m if e.odd?\n    b = (b * b) % m\n    e >>= 1\n  end\n  r\nend\n\ndef mersenne_factor(p)\n  mers_num = 2.to_big_i ** p - 1\n  kp2 = p2 = 2.to_big_i *  p\n  while (kp2 - 1) ** 2 < mers_num\n    q  = kp2 + 1     \n    return q if [1, 7].includes?(q % 8) && prime?(q) && (powmod(2, p, q) == 1)\n    kp2 += p2\n  end\n  true    \nend\n\ndef check_mersenne(p)\n  print \"M\n  f = mersenne_factor(p)\n  (puts \"prime\"; return) if f.is_a?(Bool)  \n  puts \"composite with factor \nend\n\n(2..53).each { |p| check_mersenne(p) if prime?(p) }\ncheck_mersenne 929\n", "target": "using System;\n\nnamespace prog\n{\n\tclass MainClass\n\t{\n\t\tpublic static void Main (string[] args)\n\t\t{\n\t\t\tint q = 929;\n\t\t\tif ( !isPrime(q) ) return;\n\t\t\tint r = q;\n\t\t\twhile( r > 0 ) \n\t\t\t\tr <<= 1;\n\t\t\tint d = 2 * q + 1;\n\t\t\tdo\n\t\t\t{\n\t\t\t\tint i = 1;\n\t\t\t\tfor( int p=r; p!=0; p<<=1 )\n\t\t\t\t{\n\t\t\t\t\ti = (i*i) % d;\n\t\t\t\t\tif (p < 0) i *= 2;\n\t\t\t\t\tif (i > d) i -= d;\n\t\t\t\t}\n\t\t\t\tif (i != 1) d += 2 * q; else break;\t\t\t\t\n\t\t\t}\n\t\t\twhile(true);\n\t\t\t\n\t\t\tConsole.WriteLine(\"2^\"+q+\"-1 = 0 (mod \"+d+\")\"); \n\t\t}\n\t\t\n\t\tstatic bool isPrime(int n)\n\t\t{\n\t\t\tif ( n % 2 == 0 ) return n == 2;\n\t\t\tif ( n % 3 == 0 ) return n == 3;\n\t\t\tint d = 5;\n\t\t\twhile( d*d <= n )\n\t\t\t{\n\t\t\t\tif ( n % d == 0 ) return false;\n\t\t\t\td += 2;\n\t\t\t\tif ( n % d == 0 ) return false;\n\t\t\t\td += 4;\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\t}\n}\n"}
{"id": 131997, "name": "Factors of a Mersenne number", "source": "Translate Ruby to Java: require \"big\"\n\ndef prime?(n)                             \n  return n | 1 == 3 if n < 5              \n  return false if n.gcd(6) != 1           \n  pc1, pc2 = -1, 1                        \n  until (pc1 += 6) > Math.sqrt(n).to_i    \n    return false if n % pc1 == 0 || n % (pc2 += 6) == 0  \n  end\n  true\nend\n\n\ndef powmod(b, e, m)\n  r, b = 1.to_big_i, b.to_big_i\n  while e > 0\n    r = (r * b) % m if e.odd?\n    b = (b * b) % m\n    e >>= 1\n  end\n  r\nend\n\ndef mersenne_factor(p)\n  mers_num = 2.to_big_i ** p - 1\n  kp2 = p2 = 2.to_big_i *  p\n  while (kp2 - 1) ** 2 < mers_num\n    q  = kp2 + 1     \n    return q if [1, 7].includes?(q % 8) && prime?(q) && (powmod(2, p, q) == 1)\n    kp2 += p2\n  end\n  true    \nend\n\ndef check_mersenne(p)\n  print \"M\n  f = mersenne_factor(p)\n  (puts \"prime\"; return) if f.is_a?(Bool)  \n  puts \"composite with factor \nend\n\n(2..53).each { |p| check_mersenne(p) if prime?(p) }\ncheck_mersenne 929\n", "target": "import java.math.BigInteger;\n\nclass MersenneFactorCheck\n{\n\n  private final static BigInteger TWO = BigInteger.valueOf(2);\n  \n  public static boolean isPrime(long n)\n  {\n    if (n == 2)\n      return true;\n    if ((n < 2) || ((n & 1) == 0))\n      return false;\n    long maxFactor = (long)Math.sqrt((double)n);\n    for (long possibleFactor = 3; possibleFactor <= maxFactor; possibleFactor += 2)\n      if ((n % possibleFactor) == 0)\n        return false;\n    return true;\n  }\n  \n  public static BigInteger findFactorMersenneNumber(int primeP)\n  {\n    if (primeP <= 0)\n      throw new IllegalArgumentException();\n    BigInteger bigP = BigInteger.valueOf(primeP);\n    BigInteger m = BigInteger.ONE.shiftLeft(primeP).subtract(BigInteger.ONE);\n    \n    BigInteger maxFactor = BigInteger.ONE.shiftLeft((primeP + 1) >>> 1);\n    BigInteger twoP = BigInteger.valueOf(primeP << 1);\n    BigInteger possibleFactor = BigInteger.ONE;\n    int possibleFactorBits12 = 0;\n    int twoPBits12 = primeP & 3;\n    \n    while ((possibleFactor = possibleFactor.add(twoP)).compareTo(maxFactor) <= 0)\n    {\n      possibleFactorBits12 = (possibleFactorBits12 + twoPBits12) & 3;\n      \n      if ((possibleFactorBits12 == 0) || (possibleFactorBits12 == 3))\n        if (TWO.modPow(bigP, possibleFactor).equals(BigInteger.ONE))\n          return possibleFactor;\n    }\n    return null;\n  }\n  \n  public static void checkMersenneNumber(int p)\n  {\n    if (!isPrime(p))\n    {\n      System.out.println(\"M\" + p + \" is not prime\");\n      return;\n    }\n    BigInteger factor = findFactorMersenneNumber(p);\n    if (factor == null)\n      System.out.println(\"M\" + p + \" is prime\");\n    else\n      System.out.println(\"M\" + p + \" is not prime, has factor \" + factor);\n    return;\n  }\n\n  public static void main(String[] args)\n  {\n    for (int p = 1; p <= 50; p++)\n      checkMersenneNumber(p);\n    checkMersenneNumber(929);\n    return;\n  }\n  \n}\n"}
{"id": 131998, "name": "Factors of a Mersenne number", "source": "Translate Ruby to Python: require \"big\"\n\ndef prime?(n)                             \n  return n | 1 == 3 if n < 5              \n  return false if n.gcd(6) != 1           \n  pc1, pc2 = -1, 1                        \n  until (pc1 += 6) > Math.sqrt(n).to_i    \n    return false if n % pc1 == 0 || n % (pc2 += 6) == 0  \n  end\n  true\nend\n\n\ndef powmod(b, e, m)\n  r, b = 1.to_big_i, b.to_big_i\n  while e > 0\n    r = (r * b) % m if e.odd?\n    b = (b * b) % m\n    e >>= 1\n  end\n  r\nend\n\ndef mersenne_factor(p)\n  mers_num = 2.to_big_i ** p - 1\n  kp2 = p2 = 2.to_big_i *  p\n  while (kp2 - 1) ** 2 < mers_num\n    q  = kp2 + 1     \n    return q if [1, 7].includes?(q % 8) && prime?(q) && (powmod(2, p, q) == 1)\n    kp2 += p2\n  end\n  true    \nend\n\ndef check_mersenne(p)\n  print \"M\n  f = mersenne_factor(p)\n  (puts \"prime\"; return) if f.is_a?(Bool)  \n  puts \"composite with factor \nend\n\n(2..53).each { |p| check_mersenne(p) if prime?(p) }\ncheck_mersenne 929\n", "target": "def is_prime(number):\n    return True \n\ndef m_factor(p):\n    max_k = 16384 / p \n    for k in xrange(max_k):\n        q = 2*p*k + 1\n        if not is_prime(q):\n            continue\n        elif q % 8 != 1 and q % 8 != 7:\n            continue\n        elif pow(2, p, q) == 1:\n            return q\n    return None\n\nif __name__ == '__main__':\n    exponent = int(raw_input(\"Enter exponent of Mersenne number: \"))\n    if not is_prime(exponent):\n        print \"Exponent is not prime: %d\" % exponent\n    else:\n        factor = m_factor(exponent)\n        if not factor:\n            print \"No factor found for M%d\" % exponent\n        else:\n            print \"M%d has a factor: %d\" % (exponent, factor)\n"}
{"id": 132434, "name": "Population count", "source": "Translate Ruby to C#: struct Int\n  def evil?\n    self >= 0 && popcount.even?\n  end\nend\n \nputs \"Powers of 3:\", (0...30).map{|n| (3u64 ** n).popcount}.join(' ') \nputs \"Evil:\"  , 0.step.select(&.evil?).first(30).join(' ')\nputs \"Odious:\", 0.step.reject(&.evil?).first(30).join(' ')\n", "target": "using System;\nusing System.Linq;\n\nnamespace PopulationCount\n{\n    class Program\n    {\n        private static int PopulationCount(long n)\n        {\n            string binaryn = Convert.ToString(n, 2);\n            return binaryn.ToCharArray().Where(t => t == '1').Count();\n        }\n\n        static void Main(string[] args)\n        {\n            Console.WriteLine(\"Population Counts:\");\n            Console.Write(\"3^n\u00a0:   \");\n\n            int count = 0;\n\n            while (count < 30)\n            {\n                double n = Math.Pow(3f, (double)count);\n                int popCount = PopulationCount((long)n);\n                Console.Write(string.Format(\"{0} \", popCount));\n                count++;\n            }\n\n            Console.WriteLine();\n            Console.Write(\"Evil:   \");\n\n            count = 0;\n            int i = 0;\n\n            while (count < 30)\n            {\n                int popCount = PopulationCount(i);\n\n                if (popCount % 2 == 0)\n                {\n                    count++;\n                    Console.Write(string.Format(\"{0} \", i));\n                }\n\n                i++;\n            }\n\n            Console.WriteLine();\n            Console.Write(\"Odious: \");\n\n            count = 0;\n            i = 0;\n\n            while (count < 30)\n            {\n                int popCount = PopulationCount(i);\n\n                if (popCount % 2 != 0)\n                {\n                    count++;\n                    Console.Write(string.Format(\"{0} \", i));\n                }\n\n                i++;\n            }\n\n            Console.ReadKey();\n        }\n    }\n}\n"}
{"id": 132435, "name": "Population count", "source": "Translate Ruby to C#: struct Int\n  def evil?\n    self >= 0 && popcount.even?\n  end\nend\n \nputs \"Powers of 3:\", (0...30).map{|n| (3u64 ** n).popcount}.join(' ') \nputs \"Evil:\"  , 0.step.select(&.evil?).first(30).join(' ')\nputs \"Odious:\", 0.step.reject(&.evil?).first(30).join(' ')\n", "target": "using System;\nusing System.Linq;\n\nnamespace PopulationCount\n{\n    class Program\n    {\n        private static int PopulationCount(long n)\n        {\n            string binaryn = Convert.ToString(n, 2);\n            return binaryn.ToCharArray().Where(t => t == '1').Count();\n        }\n\n        static void Main(string[] args)\n        {\n            Console.WriteLine(\"Population Counts:\");\n            Console.Write(\"3^n\u00a0:   \");\n\n            int count = 0;\n\n            while (count < 30)\n            {\n                double n = Math.Pow(3f, (double)count);\n                int popCount = PopulationCount((long)n);\n                Console.Write(string.Format(\"{0} \", popCount));\n                count++;\n            }\n\n            Console.WriteLine();\n            Console.Write(\"Evil:   \");\n\n            count = 0;\n            int i = 0;\n\n            while (count < 30)\n            {\n                int popCount = PopulationCount(i);\n\n                if (popCount % 2 == 0)\n                {\n                    count++;\n                    Console.Write(string.Format(\"{0} \", i));\n                }\n\n                i++;\n            }\n\n            Console.WriteLine();\n            Console.Write(\"Odious: \");\n\n            count = 0;\n            i = 0;\n\n            while (count < 30)\n            {\n                int popCount = PopulationCount(i);\n\n                if (popCount % 2 != 0)\n                {\n                    count++;\n                    Console.Write(string.Format(\"{0} \", i));\n                }\n\n                i++;\n            }\n\n            Console.ReadKey();\n        }\n    }\n}\n"}
{"id": 132438, "name": "Population count", "source": "Translate Ruby to Java: struct Int\n  def evil?\n    self >= 0 && popcount.even?\n  end\nend\n \nputs \"Powers of 3:\", (0...30).map{|n| (3u64 ** n).popcount}.join(' ') \nputs \"Evil:\"  , 0.step.select(&.evil?).first(30).join(' ')\nputs \"Odious:\", 0.step.reject(&.evil?).first(30).join(' ')\n", "target": "import java.math.BigInteger;\n\npublic class PopCount {\n    public static void main(String[] args) {\n\t{ \n\t    System.out.print(\"32-bit integer: \");\n\t    int n = 1;\n\t    for (int i = 0; i < 20; i++) {\n\t\tSystem.out.printf(\"%d \", Integer.bitCount(n));\n\t\tn *= 3;\n\t    }\n\t    System.out.println();\n\t}\n\t{ \n\t    System.out.print(\"64-bit integer: \");\n\t    long n = 1;\n\t    for (int i = 0; i < 30; i++) {\n\t\tSystem.out.printf(\"%d \", Long.bitCount(n));\n\t\tn *= 3;\n\t    }\n\t    System.out.println();\n\t}\n\t{ \n\t    System.out.print(\"big integer  \u00a0: \");\n\t    BigInteger n = BigInteger.ONE;\n\t    BigInteger three = BigInteger.valueOf(3);\n\t    for (int i = 0; i < 30; i++) {\n\t\tSystem.out.printf(\"%d \", n.bitCount());\n\t\tn = n.multiply(three);\n\t    }\n\t    System.out.println();\n\t}\n\n\tint[] od = new int[30];\n\tint ne = 0, no = 0;\n\tSystem.out.print(\"evil  \u00a0: \");\n\tfor (int n = 0; ne+no < 60; n++) {\n\t    if ((Integer.bitCount(n) & 1) == 0) {\n\t\tif (ne < 30) {\n\t\t    System.out.printf(\"%d \", n);\n\t\t    ne++;\n\t\t}\n\t    } else {\n\t\tif (no < 30) {\n\t\t    od[no++] = n;\n\t\t}\n\t    }\n\t}\n\tSystem.out.println();\n\tSystem.out.print(\"odious\u00a0: \");\n\tfor (int n : od) {\n\t    System.out.printf(\"%d \", n);\n\t}\n\tSystem.out.println();\n    }\n}\n"}
{"id": 132439, "name": "Population count", "source": "Translate Ruby to Java: struct Int\n  def evil?\n    self >= 0 && popcount.even?\n  end\nend\n \nputs \"Powers of 3:\", (0...30).map{|n| (3u64 ** n).popcount}.join(' ') \nputs \"Evil:\"  , 0.step.select(&.evil?).first(30).join(' ')\nputs \"Odious:\", 0.step.reject(&.evil?).first(30).join(' ')\n", "target": "import java.math.BigInteger;\n\npublic class PopCount {\n    public static void main(String[] args) {\n\t{ \n\t    System.out.print(\"32-bit integer: \");\n\t    int n = 1;\n\t    for (int i = 0; i < 20; i++) {\n\t\tSystem.out.printf(\"%d \", Integer.bitCount(n));\n\t\tn *= 3;\n\t    }\n\t    System.out.println();\n\t}\n\t{ \n\t    System.out.print(\"64-bit integer: \");\n\t    long n = 1;\n\t    for (int i = 0; i < 30; i++) {\n\t\tSystem.out.printf(\"%d \", Long.bitCount(n));\n\t\tn *= 3;\n\t    }\n\t    System.out.println();\n\t}\n\t{ \n\t    System.out.print(\"big integer  \u00a0: \");\n\t    BigInteger n = BigInteger.ONE;\n\t    BigInteger three = BigInteger.valueOf(3);\n\t    for (int i = 0; i < 30; i++) {\n\t\tSystem.out.printf(\"%d \", n.bitCount());\n\t\tn = n.multiply(three);\n\t    }\n\t    System.out.println();\n\t}\n\n\tint[] od = new int[30];\n\tint ne = 0, no = 0;\n\tSystem.out.print(\"evil  \u00a0: \");\n\tfor (int n = 0; ne+no < 60; n++) {\n\t    if ((Integer.bitCount(n) & 1) == 0) {\n\t\tif (ne < 30) {\n\t\t    System.out.printf(\"%d \", n);\n\t\t    ne++;\n\t\t}\n\t    } else {\n\t\tif (no < 30) {\n\t\t    od[no++] = n;\n\t\t}\n\t    }\n\t}\n\tSystem.out.println();\n\tSystem.out.print(\"odious\u00a0: \");\n\tfor (int n : od) {\n\t    System.out.printf(\"%d \", n);\n\t}\n\tSystem.out.println();\n    }\n}\n"}
{"id": 132440, "name": "Population count", "source": "Translate Ruby to Python: struct Int\n  def evil?\n    self >= 0 && popcount.even?\n  end\nend\n \nputs \"Powers of 3:\", (0...30).map{|n| (3u64 ** n).popcount}.join(' ') \nputs \"Evil:\"  , 0.step.select(&.evil?).first(30).join(' ')\nputs \"Odious:\", 0.step.reject(&.evil?).first(30).join(' ')\n", "target": ">>> def popcount(n): return bin(n).count(\"1\")\n... \n>>> [popcount(3**i) for i in range(30)]\n[1, 2, 2, 4, 3, 6, 6, 5, 6, 8, 9, 13, 10, 11, 14, 15, 11, 14, 14, 17, 17, 20, 19, 22, 16, 18, 24, 30, 25, 25]\n>>> evil, odious, i = [], [], 0\n>>> while len(evil) < 30 or len(odious) < 30:\n...     p = popcount(i)\n...     if p % 2: odious.append(i)\n...     else: evil.append(i)\n...     i += 1\n... \n>>> evil[:30]\n[0, 3, 5, 6, 9, 10, 12, 15, 17, 18, 20, 23, 24, 27, 29, 30, 33, 34, 36, 39, 40, 43, 45, 46, 48, 51, 53, 54, 57, 58]\n>>> odious[:30]\n[1, 2, 4, 7, 8, 11, 13, 14, 16, 19, 21, 22, 25, 26, 28, 31, 32, 35, 37, 38, 41, 42, 44, 47, 49, 50, 52, 55, 56, 59]\n>>>\n"}
{"id": 132441, "name": "Population count", "source": "Translate Ruby to Python: struct Int\n  def evil?\n    self >= 0 && popcount.even?\n  end\nend\n \nputs \"Powers of 3:\", (0...30).map{|n| (3u64 ** n).popcount}.join(' ') \nputs \"Evil:\"  , 0.step.select(&.evil?).first(30).join(' ')\nputs \"Odious:\", 0.step.reject(&.evil?).first(30).join(' ')\n", "target": ">>> def popcount(n): return bin(n).count(\"1\")\n... \n>>> [popcount(3**i) for i in range(30)]\n[1, 2, 2, 4, 3, 6, 6, 5, 6, 8, 9, 13, 10, 11, 14, 15, 11, 14, 14, 17, 17, 20, 19, 22, 16, 18, 24, 30, 25, 25]\n>>> evil, odious, i = [], [], 0\n>>> while len(evil) < 30 or len(odious) < 30:\n...     p = popcount(i)\n...     if p % 2: odious.append(i)\n...     else: evil.append(i)\n...     i += 1\n... \n>>> evil[:30]\n[0, 3, 5, 6, 9, 10, 12, 15, 17, 18, 20, 23, 24, 27, 29, 30, 33, 34, 36, 39, 40, 43, 45, 46, 48, 51, 53, 54, 57, 58]\n>>> odious[:30]\n[1, 2, 4, 7, 8, 11, 13, 14, 16, 19, 21, 22, 25, 26, 28, 31, 32, 35, 37, 38, 41, 42, 44, 47, 49, 50, 52, 55, 56, 59]\n>>>\n"}
{"id": 132692, "name": "Statistics_Basic", "source": "Translate Ruby to C#: def generate_statistics(n)\n  sum = sum2 = 0.0\n  hist = Array.new(10, 0)\n  n.times do\n    r = rand\n    sum += r\n    sum2 += r**2\n    hist[(10*r).to_i] += 1\n  end\n  mean = sum / n\n  stddev = Math::sqrt((sum2 / n) - mean**2)\n  \n  puts \"size: \n  puts \"mean:   \n  puts \"stddev: \n  hist.each_with_index {|x,i| puts \"%.1f:%s\" % [0.1*i, \"=\" * (70*x/hist.max)]}\n  puts\nend\n\n[100, 1000, 10000].each {|n| generate_statistics n}\n", "target": "using System;\nusing MathNet.Numerics.Statistics;\n\nclass Program\n{\n    static void Run(int sampleSize)\n    {\n        double[] X = new double[sampleSize];\n        var r = new Random();\n        for (int i = 0; i < sampleSize; i++)\n            X[i] = r.NextDouble();\n\n        const int numBuckets = 10;\n        var histogram = new Histogram(X, numBuckets);\n        Console.WriteLine(\"Sample size: {0:N0}\", sampleSize);\n        for (int i = 0; i < numBuckets; i++)\n        {\n            string bar = new String('#', (int)(histogram[i].Count * 360 / sampleSize));\n            Console.WriteLine(\" {0:0.00}\u00a0: {1}\", histogram[i].LowerBound, bar);\n        }\n        var statistics = new DescriptiveStatistics(X);\n        Console.WriteLine(\"  Mean: \" + statistics.Mean);\n        Console.WriteLine(\"StdDev: \" + statistics.StandardDeviation);\n        Console.WriteLine();\n    }\n    static void Main(string[] args)\n    {\n        Run(100);\n        Run(1000);\n        Run(10000);\n    }\n}\n"}
{"id": 132694, "name": "Statistics_Basic", "source": "Translate Ruby to Java: def generate_statistics(n)\n  sum = sum2 = 0.0\n  hist = Array.new(10, 0)\n  n.times do\n    r = rand\n    sum += r\n    sum2 += r**2\n    hist[(10*r).to_i] += 1\n  end\n  mean = sum / n\n  stddev = Math::sqrt((sum2 / n) - mean**2)\n  \n  puts \"size: \n  puts \"mean:   \n  puts \"stddev: \n  hist.each_with_index {|x,i| puts \"%.1f:%s\" % [0.1*i, \"=\" * (70*x/hist.max)]}\n  puts\nend\n\n[100, 1000, 10000].each {|n| generate_statistics n}\n", "target": "import static java.lang.Math.pow;\nimport static java.util.Arrays.stream;\nimport static java.util.stream.Collectors.joining;\nimport static java.util.stream.IntStream.range;\n\npublic class Test {\n    static double[] meanStdDev(double[] numbers) {\n        if (numbers.length == 0)\n            return new double[]{0.0, 0.0};\n\n        double sx = 0.0, sxx = 0.0;\n        long n = 0;\n        for (double x : numbers) {\n            sx += x;\n            sxx += pow(x, 2);\n            n++;\n        }\n        return new double[]{sx / n, pow((n * sxx - pow(sx, 2)), 0.5) / n};\n    }\n\n    static String replicate(int n, String s) {\n        return range(0, n + 1).mapToObj(i -> s).collect(joining());\n    }\n\n    static void showHistogram01(double[] numbers) {\n        final int maxWidth = 50;\n        long[] bins = new long[10];\n\n        for (double x : numbers)\n            bins[(int) (x * bins.length)]++;\n\n        double maxFreq = stream(bins).max().getAsLong();\n\n        for (int i = 0; i < bins.length; i++)\n            System.out.printf(\" %3.1f: %s%n\", i / (double) bins.length,\n                    replicate((int) (bins[i] / maxFreq * maxWidth), \"*\"));\n        System.out.println();\n    }\n\n    public static void main(String[] a) {\n        Locale.setDefault(Locale.US);\n        for (int p = 1; p < 7; p++) {\n            double[] n = range(0, (int) pow(10, p))\n                    .mapToDouble(i -> Math.random()).toArray();\n\n            System.out.println((int)pow(10, p) + \" numbers:\");\n            double[] res = meanStdDev(n);\n            System.out.printf(\" Mean: %8.6f, SD: %8.6f%n\", res[0], res[1]);\n            showHistogram01(n);\n        }\n    }\n}\n"}
{"id": 132695, "name": "Statistics_Basic", "source": "Translate Ruby to Python: def generate_statistics(n)\n  sum = sum2 = 0.0\n  hist = Array.new(10, 0)\n  n.times do\n    r = rand\n    sum += r\n    sum2 += r**2\n    hist[(10*r).to_i] += 1\n  end\n  mean = sum / n\n  stddev = Math::sqrt((sum2 / n) - mean**2)\n  \n  puts \"size: \n  puts \"mean:   \n  puts \"stddev: \n  hist.each_with_index {|x,i| puts \"%.1f:%s\" % [0.1*i, \"=\" * (70*x/hist.max)]}\n  puts\nend\n\n[100, 1000, 10000].each {|n| generate_statistics n}\n", "target": "def sd1(numbers):\n    if numbers:\n        mean = sum(numbers) / len(numbers)\n        sd = (sum((n - mean)**2 for n in numbers) / len(numbers))**0.5\n        return sd, mean\n    else:\n        return 0, 0\n\ndef sd2(numbers):\n    if numbers:\n        sx = sxx = n = 0\n        for x in numbers:\n            sx += x\n            sxx += x*x\n            n += 1\n        sd = (n * sxx - sx*sx)**0.5 / n\n        return sd, sx / n\n    else:\n        return 0, 0\n\ndef histogram(numbers):\n    h = [0] * 10\n    maxwidth = 50 \n    for n in numbers:\n        h[int(n*10)] += 1\n    mx = max(h)\n    print()\n    for n, i in enumerate(h):\n        print('%3.1f: %s' % (n / 10, '+' * int(i / mx * maxwidth)))\n    print()\n\nif __name__ == '__main__':\n    import random\n    for i in range(1, 6):\n        n = [random.random() for j in range(10**i)]\n        print(\"\\n\n        print('  Naive  method: sd: %8.6f, mean: %8.6f' % sd1(n))\n        print('  Second method: sd: %8.6f, mean: %8.6f' % sd2(n))\n        histogram(n)\n"}
{"id": 132907, "name": "Langton's ant", "source": "Translate Ruby to C#: class Ant\n  \n  class OutOfBoundsException < StandardError; end\n  \n  class Plane\n    def initialize(x, y)\n      @size_x, @size_y = x, y\n      @cells = Array.new(y) {Array.new(x, :white)}\n    end\n    \n    def white?(px, py)\n      @cells[py][px] == :white\n    end\n    \n    def toggle_colour(px, py)\n      @cells[py][px] = (white?(px, py) ? :black : :white)\n    end\n    \n    def check_bounds(px, py)\n      unless (0 <= px and px < @size_x) and (0 <= py and py < @size_y)\n        raise OutOfBoundsException, \"(\n      end\n    end\n    \n    def to_s\n      @cells.collect {|row|\n        row.collect {|cell| cell == :white ? \".\" : \"\n      }.join\n    end\n  end\n  \n  dir_move = [[:north, [0,-1]], [:east, [1,0]], [:south, [0,1]], [:west, [-1,0]]]\n  Move = Hash[dir_move]\n  directions = dir_move.map{|dir, move| dir}       \n  Right = Hash[ directions.zip(directions.rotate).to_a ]\n  Left  = Right.invert\n  \n  def initialize(size_x, size_y, pos_x=size_x/2, pos_y=size_y/2)\n    @plane = Plane.new(size_x, size_y)\n    @pos_x, @pos_y = pos_x, pos_y\n    @direction = :south\n    @plane.check_bounds(@pos_x, @pos_y)\n  end\n  \n  def run\n    moves = 0\n    loop do\n      begin\n        moves += 1\n        move\n      rescue OutOfBoundsException\n        break\n      end\n    end\n    moves\n  end\n  \n  def move\n    @plane.toggle_colour(@pos_x, @pos_y)\n    advance\n    if @plane.white?(@pos_x, @pos_y)\n      @direction = Right[@direction]\n    else\n      @direction = Left[@direction]\n    end\n  end\n  \n  def advance\n    dx, dy = Move[@direction]\n    @pos_x += dx\n    @pos_y += dy\n    @plane.check_bounds(@pos_x, @pos_y)\n  end\n  \n  def position\n    \"(\n  end\n  \n  def to_s\n    @plane.to_s\n  end\nend\n\n\n\n\nant = Ant.new(100, 100)\nmoves = ant.run\nputs \"out of bounds after \nputs ant\n", "target": "using System;\n\nnamespace LangtonAnt\n{\n    public struct Point\n    {\n        public int X;\n        public int Y;\n\n        public Point(int x, int y)\n        {\n            X = x;\n            Y = y;\n        }\n    }\n\n    enum Direction\n    {\n        North, East, West, South\n    }\n\n    public class Langton\n    {\n        public readonly bool [,] IsBlack;\n        private Point _origin;\n        private Point _antPosition = new Point(0, 0);\n        public bool OutOfBounds { get; set;}\n\n        \n        private Direction _antDirection = Direction.East;\n\n        private readonly Direction[] _leftTurn = new[] { Direction.West, Direction.North, Direction.South, Direction.East };\n        private readonly Direction[] _rightTurn = new[] { Direction.East, Direction.South, Direction.North, Direction.West };\n        private readonly int[] _xInc = new[] { 0, 1,-1, 0};\n        private readonly int[] _yInc = new[] {-1, 0, 0, 1};\n\n        public Langton(int width, int height, Point origin)\n        {\n            _origin = origin;\n            IsBlack = new bool[width, height];\n            OutOfBounds = false;\n        }\n\n        public Langton(int width, int height) : this(width, height, new Point(width / 2, height / 2)) {}\n\n        private void MoveAnt()\n        {\n            _antPosition.X += _xInc[(int)_antDirection];\n            _antPosition.Y += _yInc[(int)_antDirection];\n        }\n\n        public Point Step()\n        {\n            if (OutOfBounds)\n            {\n                throw new InvalidOperationException(\"Trying to step after ant is out of bounds\");\n            }\n            Point ptCur = new Point(_antPosition.X + _origin.X, _antPosition.Y + _origin.Y);\n            bool leftTurn = IsBlack[ptCur.X, ptCur.Y];\n            int iDirection = (int) _antDirection;\n            _antDirection = leftTurn ? _leftTurn[iDirection] : _rightTurn[iDirection];\n            IsBlack[ptCur.X, ptCur.Y] = !IsBlack[ptCur.X, ptCur.Y];\n            MoveAnt();\n            ptCur = new Point(_antPosition.X + _origin.X, _antPosition.Y + _origin.Y);\n            OutOfBounds = \n                ptCur.X < 0 ||\n                ptCur.X >= IsBlack.GetUpperBound(0) ||\n                ptCur.Y < 0 ||\n                ptCur.Y >= IsBlack.GetUpperBound(1);\n            return _antPosition;\n        }\n    }\n    class Program\n    {\n        static void Main()\n        {\n            Langton ant = new Langton(100, 100);\n\n            while (!ant.OutOfBounds) ant.Step();\n\n            for (int iRow = 0; iRow < 100; iRow++)\n            {\n                for (int iCol = 0; iCol < 100; iCol++)\n                {\n                    Console.Write(ant.IsBlack[iCol, iRow] ? \"#\" : \" \");\n                }\n                Console.WriteLine();\n            }\n\n            Console.ReadKey();\n        }\n    }\n}\n"}
{"id": 132909, "name": "Langton's ant", "source": "Translate Ruby to Java: class Ant\n  \n  class OutOfBoundsException < StandardError; end\n  \n  class Plane\n    def initialize(x, y)\n      @size_x, @size_y = x, y\n      @cells = Array.new(y) {Array.new(x, :white)}\n    end\n    \n    def white?(px, py)\n      @cells[py][px] == :white\n    end\n    \n    def toggle_colour(px, py)\n      @cells[py][px] = (white?(px, py) ? :black : :white)\n    end\n    \n    def check_bounds(px, py)\n      unless (0 <= px and px < @size_x) and (0 <= py and py < @size_y)\n        raise OutOfBoundsException, \"(\n      end\n    end\n    \n    def to_s\n      @cells.collect {|row|\n        row.collect {|cell| cell == :white ? \".\" : \"\n      }.join\n    end\n  end\n  \n  dir_move = [[:north, [0,-1]], [:east, [1,0]], [:south, [0,1]], [:west, [-1,0]]]\n  Move = Hash[dir_move]\n  directions = dir_move.map{|dir, move| dir}       \n  Right = Hash[ directions.zip(directions.rotate).to_a ]\n  Left  = Right.invert\n  \n  def initialize(size_x, size_y, pos_x=size_x/2, pos_y=size_y/2)\n    @plane = Plane.new(size_x, size_y)\n    @pos_x, @pos_y = pos_x, pos_y\n    @direction = :south\n    @plane.check_bounds(@pos_x, @pos_y)\n  end\n  \n  def run\n    moves = 0\n    loop do\n      begin\n        moves += 1\n        move\n      rescue OutOfBoundsException\n        break\n      end\n    end\n    moves\n  end\n  \n  def move\n    @plane.toggle_colour(@pos_x, @pos_y)\n    advance\n    if @plane.white?(@pos_x, @pos_y)\n      @direction = Right[@direction]\n    else\n      @direction = Left[@direction]\n    end\n  end\n  \n  def advance\n    dx, dy = Move[@direction]\n    @pos_x += dx\n    @pos_y += dy\n    @plane.check_bounds(@pos_x, @pos_y)\n  end\n  \n  def position\n    \"(\n  end\n  \n  def to_s\n    @plane.to_s\n  end\nend\n\n\n\n\nant = Ant.new(100, 100)\nmoves = ant.run\nputs \"out of bounds after \nputs ant\n", "target": "import java.awt.Color;\nimport java.awt.Graphics;\n\nimport javax.swing.JFrame;\nimport javax.swing.JPanel;\n\npublic class Langton extends JFrame{\n\tprivate JPanel planePanel;\n\tprivate static final int ZOOM = 4;\n\t\n\tpublic Langton(final boolean[][] plane){\n\t\tplanePanel = new JPanel(){\n\t\t\t@Override\n\t\t\tpublic void paint(Graphics g) {\n\t\t\t\tfor(int y = 0; y < plane.length;y++){\n\t\t\t\t\tfor(int x = 0; x < plane[0].length;x++){\n\t\t\t\t\t\tg.setColor(plane[y][x] ? Color.BLACK : Color.WHITE);\n\t\t\t\t\t\tg.fillRect(x * ZOOM, y * ZOOM, ZOOM, ZOOM);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tg.setColor(Color.GREEN);\n\t\t\t\tg.fillRect(plane[0].length / 2 * ZOOM,\n\t\t\t\t           plane.length / 2 * ZOOM, ZOOM/2, ZOOM/2);\n\t\t\t}\n\t\t};\n\t\tplanePanel.setSize(plane[0].length - 1, plane.length - 1);\n\t\tadd(planePanel);\n\t\tsetSize(ZOOM * plane[0].length, ZOOM * plane.length + 30);\n\t\tsetDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n\t\tsetVisible(true);\n\t}\n\t\n\tpublic static void main(String[] args){\n\t\tnew Langton(runAnt(100, 100));\n\t}\n\n\tprivate static boolean[][] runAnt(int height, int width){\n\t\tboolean[][] plane = new boolean[height][width];\n\t\tint antX = width/2, antY = height/2;\n\t\tint xChange = 0, yChange = -1; \n\t\twhile(antX < width && antY < height && antX >= 0 && antY >= 0){\n\t\t\tif(plane[antY][antX]){\n\t\t\t\t\n\t\t\t\tif(xChange == 0){ \n\t\t\t\t\txChange = yChange;\n\t\t\t\t\tyChange = 0;\n\t\t\t\t}else{ \n\t\t\t\t\tyChange = -xChange;\n\t\t\t\t\txChange = 0;\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\t\n\t\t\t\tif(xChange == 0){ \n\t\t\t\t\txChange = -yChange;\n\t\t\t\t\tyChange = 0;\n\t\t\t\t}else{ \n\t\t\t\t\tyChange = xChange;\n\t\t\t\t\txChange = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\tplane[antY][antX] = !plane[antY][antX];\n\t\t\tantX += xChange;\n\t\t\tantY += yChange;\n\t\t}\n\t\treturn plane;\n\t}\n}\n"}
{"id": 132910, "name": "Langton's ant", "source": "Translate Ruby to Python: class Ant\n  \n  class OutOfBoundsException < StandardError; end\n  \n  class Plane\n    def initialize(x, y)\n      @size_x, @size_y = x, y\n      @cells = Array.new(y) {Array.new(x, :white)}\n    end\n    \n    def white?(px, py)\n      @cells[py][px] == :white\n    end\n    \n    def toggle_colour(px, py)\n      @cells[py][px] = (white?(px, py) ? :black : :white)\n    end\n    \n    def check_bounds(px, py)\n      unless (0 <= px and px < @size_x) and (0 <= py and py < @size_y)\n        raise OutOfBoundsException, \"(\n      end\n    end\n    \n    def to_s\n      @cells.collect {|row|\n        row.collect {|cell| cell == :white ? \".\" : \"\n      }.join\n    end\n  end\n  \n  dir_move = [[:north, [0,-1]], [:east, [1,0]], [:south, [0,1]], [:west, [-1,0]]]\n  Move = Hash[dir_move]\n  directions = dir_move.map{|dir, move| dir}       \n  Right = Hash[ directions.zip(directions.rotate).to_a ]\n  Left  = Right.invert\n  \n  def initialize(size_x, size_y, pos_x=size_x/2, pos_y=size_y/2)\n    @plane = Plane.new(size_x, size_y)\n    @pos_x, @pos_y = pos_x, pos_y\n    @direction = :south\n    @plane.check_bounds(@pos_x, @pos_y)\n  end\n  \n  def run\n    moves = 0\n    loop do\n      begin\n        moves += 1\n        move\n      rescue OutOfBoundsException\n        break\n      end\n    end\n    moves\n  end\n  \n  def move\n    @plane.toggle_colour(@pos_x, @pos_y)\n    advance\n    if @plane.white?(@pos_x, @pos_y)\n      @direction = Right[@direction]\n    else\n      @direction = Left[@direction]\n    end\n  end\n  \n  def advance\n    dx, dy = Move[@direction]\n    @pos_x += dx\n    @pos_y += dy\n    @plane.check_bounds(@pos_x, @pos_y)\n  end\n  \n  def position\n    \"(\n  end\n  \n  def to_s\n    @plane.to_s\n  end\nend\n\n\n\n\nant = Ant.new(100, 100)\nmoves = ant.run\nputs \"out of bounds after \nputs ant\n", "target": "\n\n\n\n\n\nSTEP = 100\ncount = 0\n\ndef setup():\n    global x, y, direction\n\n    \n    \n    size(100, 100, P2D)\n\n    background(255)\n    x = width / 2\n    y = height / 2\n    direction = 0\n\ndef draw():\n    global count\n    for i in range(STEP):\n        count += 1\n        pix = get(x, y) != -1 \n        setBool(x, y, pix)\n\n        turn(pix)\n        move()\n\n        if (x < 0 or y < 0 or x >= width or y >= height):\n            println(\"finished\")\n            noLoop()\n            break\n\n    if count % 1000 == 0:\n        println(\"iteration {}\".format(count))\n\ndef move():\n    global x, y\n    if direction == 0:\n        y -= 1\n    elif direction == 1:\n        x -= 1\n    elif direction == 2:\n        y += 1\n    elif direction == 3:\n        x += 1\n\ndef turn(rightleft):\n    global direction\n    direction += 1 if rightleft else -1\n    if direction == -1:\n        direction = 3\n    if direction == 4:\n        direction = 0\n\ndef setBool(x, y, white):\n    set(x, y, -1 if white else 0)\n"}
{"id": 133085, "name": "Bernoulli numbers", "source": "Translate Ruby to C#: require \"big\"\n\nclass Bernoulli\n  include Iterator(Tuple(Int32, BigRational))\n\n  def initialize\n    @a = [] of BigRational\n    @m = 0\n  end\n\n  def next\n    @a << BigRational.new(1, @m+1)\n    @m.downto(1) { |j| @a[j-1] = j*(@a[j-1] - @a[j]) }\n    v = @m.odd? && @m != 1 ? BigRational.new(0, 1) : @a.first\n    return {@m, v}\n  ensure\n    @m += 1\n  end\nend\n\nb = Bernoulli.new\nbn = b.first(61).to_a\n\nmax_width = bn.map { |_, v| v.numerator.to_s.size }.max\nbn.reject { |i, v| v.zero? }.each do |i, v|\n  puts \"B(%2i) =\u00a0%*i/%i\" % [i, max_width, v.numerator, v.denominator]\nend\n", "target": "using Mpir.NET;\nusing System;\n\nnamespace Bernoulli\n{\n    class Program\n    {\n        private static void bernoulli(mpq_t rop, uint n)\n        {\n            mpq_t[] a = new mpq_t[n + 1];\n\n            for (uint i = 0; i < n + 1; i++)\n            {\n                a[i] = new mpq_t();\n            }\n\n            for (uint m = 0; m <= n; ++m)\n            {\n                mpir.mpq_set_ui(a[m], 1, m + 1);\n\n                for (uint j = m; j > 0; --j)\n                {\n                    mpir.mpq_sub(a[j - 1], a[j], a[j - 1]);\n                    mpir.mpq_set_ui(rop, j, 1);\n                    mpir.mpq_mul(a[j - 1], a[j - 1], rop);\n                }\n\n                mpir.mpq_set(rop, a[0]);\n            }\n        }\n\n        static void Main(string[] args)\n        {\n            mpq_t rop = new mpq_t();\n            mpz_t n = new mpz_t();\n            mpz_t d = new mpz_t();\n\n            for (uint  i = 0; i <= 60; ++i) \n            {\n                bernoulli(rop, i);\n\n                if (mpir.mpq_cmp_ui(rop, 0, 1) != 0) \n                {\n                    mpir.mpq_get_num(n, rop);\n                    mpir.mpq_get_den(d, rop);\n                    Console.WriteLine(string.Format(\"B({0, 2}) = {1, 44} / {2}\", i, n, d));\n                }\n            }\n\n            Console.ReadKey();\n        }\n    }\n}\n"}
{"id": 133087, "name": "Bernoulli numbers", "source": "Translate Ruby to Java: require \"big\"\n\nclass Bernoulli\n  include Iterator(Tuple(Int32, BigRational))\n\n  def initialize\n    @a = [] of BigRational\n    @m = 0\n  end\n\n  def next\n    @a << BigRational.new(1, @m+1)\n    @m.downto(1) { |j| @a[j-1] = j*(@a[j-1] - @a[j]) }\n    v = @m.odd? && @m != 1 ? BigRational.new(0, 1) : @a.first\n    return {@m, v}\n  ensure\n    @m += 1\n  end\nend\n\nb = Bernoulli.new\nbn = b.first(61).to_a\n\nmax_width = bn.map { |_, v| v.numerator.to_s.size }.max\nbn.reject { |i, v| v.zero? }.each do |i, v|\n  puts \"B(%2i) =\u00a0%*i/%i\" % [i, max_width, v.numerator, v.denominator]\nend\n", "target": "import org.apache.commons.math3.fraction.BigFraction;\n\npublic class BernoulliNumbers {\n\n    public static void main(String[] args) {\n        for (int n = 0; n <= 60; n++) {\n            BigFraction b = bernouilli(n);\n            if (!b.equals(BigFraction.ZERO))\n                System.out.printf(\"B(%-2d) =\u00a0%-1s%n\", n , b);\n        }\n    }\n\n    static BigFraction bernouilli(int n) {\n        BigFraction[] A = new BigFraction[n + 1];\n        for (int m = 0; m <= n; m++) {\n            A[m] = new BigFraction(1, (m + 1));\n            for (int j = m; j >= 1; j--)\n                A[j - 1] = (A[j - 1].subtract(A[j])).multiply(new BigFraction(j));\n        }\n        return A[0];\n    }\n}\n"}
{"id": 133088, "name": "Bernoulli numbers", "source": "Translate Ruby to Python: require \"big\"\n\nclass Bernoulli\n  include Iterator(Tuple(Int32, BigRational))\n\n  def initialize\n    @a = [] of BigRational\n    @m = 0\n  end\n\n  def next\n    @a << BigRational.new(1, @m+1)\n    @m.downto(1) { |j| @a[j-1] = j*(@a[j-1] - @a[j]) }\n    v = @m.odd? && @m != 1 ? BigRational.new(0, 1) : @a.first\n    return {@m, v}\n  ensure\n    @m += 1\n  end\nend\n\nb = Bernoulli.new\nbn = b.first(61).to_a\n\nmax_width = bn.map { |_, v| v.numerator.to_s.size }.max\nbn.reject { |i, v| v.zero? }.each do |i, v|\n  puts \"B(%2i) =\u00a0%*i/%i\" % [i, max_width, v.numerator, v.denominator]\nend\n", "target": "from fractions import Fraction as Fr\n\ndef bernoulli(n):\n    A = [0] * (n+1)\n    for m in range(n+1):\n        A[m] = Fr(1, m+1)\n        for j in range(m, 0, -1):\n          A[j-1] = j*(A[j-1] - A[j])\n    return A[0] \n\nbn = [(i, bernoulli(i)) for i in range(61)]\nbn = [(i, b) for i,b in bn if b]\nwidth = max(len(str(b.numerator)) for i,b in bn)\nfor i,b in bn:\n    print('B(%2i) = %*i/%i' % (i, width, b.numerator, b.denominator))\n"}
{"id": 133524, "name": "Pangram checker", "source": "Translate Ruby to C#: def pangram?(sentence)\n  ('a'..'z').all? {|c| sentence.downcase.includes?(c) }\nend\n\np pangram?(\"not a pangram\")\np pangram?(\"The quick brown fox jumps over the lazy dog.\")\n", "target": "using System;\nusing System.Linq;\n\nstatic class Program\n{\n    static bool IsPangram(this string text, string alphabet = \"abcdefghijklmnopqrstuvwxyz\")\n    {\n        return alphabet.All(text.ToLower().Contains);\n    }\n\n    static void Main(string[] arguments)\n    {\n        Console.WriteLine(arguments.Any() && arguments.First().IsPangram());\n    }\n}\n"}
{"id": 133525, "name": "Pangram checker", "source": "Translate Ruby to C#: def pangram?(sentence)\n  ('a'..'z').all? {|c| sentence.downcase.includes?(c) }\nend\n\np pangram?(\"not a pangram\")\np pangram?(\"The quick brown fox jumps over the lazy dog.\")\n", "target": "using System;\nusing System.Linq;\n\nstatic class Program\n{\n    static bool IsPangram(this string text, string alphabet = \"abcdefghijklmnopqrstuvwxyz\")\n    {\n        return alphabet.All(text.ToLower().Contains);\n    }\n\n    static void Main(string[] arguments)\n    {\n        Console.WriteLine(arguments.Any() && arguments.First().IsPangram());\n    }\n}\n"}
{"id": 133528, "name": "Pangram checker", "source": "Translate Ruby to Java: def pangram?(sentence)\n  ('a'..'z').all? {|c| sentence.downcase.includes?(c) }\nend\n\np pangram?(\"not a pangram\")\np pangram?(\"The quick brown fox jumps over the lazy dog.\")\n", "target": "public class Pangram {\n    public static boolean isPangram(String test){\n        for (char a = 'A'; a <= 'Z'; a++)\n            if ((test.indexOf(a) < 0) && (test.indexOf((char)(a + 32)) < 0))\n                return false;\n        return true;\n    }\n\n    public static void main(String[] args){\n        System.out.println(isPangram(\"the quick brown fox jumps over the lazy dog\"));\n        System.out.println(isPangram(\"the quick brown fox jumped over the lazy dog\"));\n        System.out.println(isPangram(\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"));\n        System.out.println(isPangram(\"ABCDEFGHIJKLMNOPQSTUVWXYZ\"));\n        System.out.println(isPangram(\"ABCDEFGHIJKL.NOPQRSTUVWXYZ\"));\n        System.out.println(isPangram(\"ABC.D.E.FGHI*J/KL-M+NO*PQ R\\nSTUVWXYZ\"));\n        System.out.println(isPangram(\"\"));\n    }\n}\n"}
{"id": 133529, "name": "Pangram checker", "source": "Translate Ruby to Python: def pangram?(sentence)\n  ('a'..'z').all? {|c| sentence.downcase.includes?(c) }\nend\n\np pangram?(\"not a pangram\")\np pangram?(\"The quick brown fox jumps over the lazy dog.\")\n", "target": "import string, sys\nif sys.version_info[0] < 3:\n    input = raw_input\n\ndef ispangram(sentence, alphabet=string.ascii_lowercase):\n    alphaset = set(alphabet)\n    return alphaset <= set(sentence.lower())\n\nprint ( ispangram(input('Sentence: ')) )\n"}
{"id": 133530, "name": "Pangram checker", "source": "Translate Ruby to Python: def pangram?(sentence)\n  ('a'..'z').all? {|c| sentence.downcase.includes?(c) }\nend\n\np pangram?(\"not a pangram\")\np pangram?(\"The quick brown fox jumps over the lazy dog.\")\n", "target": "import string, sys\nif sys.version_info[0] < 3:\n    input = raw_input\n\ndef ispangram(sentence, alphabet=string.ascii_lowercase):\n    alphaset = set(alphabet)\n    return alphaset <= set(sentence.lower())\n\nprint ( ispangram(input('Sentence: ')) )\n"}
{"id": 133846, "name": "Find common directory path", "source": "Translate Ruby to C#: require 'abbrev'\n\ndirs = %w( /home/user1/tmp/coverage/test /home/user1/tmp/covert/operator /home/user1/tmp/coven/members )\n\ncommon_prefix = dirs.abbrev.keys.min_by {|key| key.length}.chop  \ncommon_directory = common_prefix.sub(%r{/[^/]*$}, '')            \n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\nnamespace RosettaCodeTasks\n{\n\n\tclass Program\n\t{\n\t\tstatic void Main ( string[ ] args )\n\t\t{\n\t\t\tFindCommonDirectoryPath.Test ( );\n\t\t}\n\n\t}\n\n\tclass FindCommonDirectoryPath\n\t{\n\t\tpublic static void Test ( )\n\t\t{\n\t\t\tConsole.WriteLine ( \"Find Common Directory Path\" );\n\t\t\tConsole.WriteLine ( );\n\t\t\tList<string> PathSet1 = new List<string> ( );\n\t\t\tPathSet1.Add ( \"/home/user1/tmp/coverage/test\" );\n\t\t\tPathSet1.Add ( \"/home/user1/tmp/covert/operator\" );\n\t\t\tPathSet1.Add ( \"/home/user1/tmp/coven/members\" );\n\t\t\tConsole.WriteLine(\"Path Set 1 (All Absolute Paths):\");\n\t\t\tforeach ( string path in PathSet1 )\n\t\t\t{\n\t\t\t\tConsole.WriteLine ( path );\n\t\t\t}\n\t\t\tConsole.WriteLine ( \"Path Set 1 Common Path: {0}\", FindCommonPath ( \"/\", PathSet1 ) );\n\t\t}\n\t\tpublic static string FindCommonPath ( string Separator, List<string> Paths )\n\t\t{\n\t\t\tstring CommonPath = String.Empty;\n\t\t\tList<string> SeparatedPath = Paths\n\t\t\t\t.First ( str => str.Length == Paths.Max ( st2 => st2.Length ) )\n\t\t\t\t.Split ( new string[ ] { Separator }, StringSplitOptions.RemoveEmptyEntries )\n\t\t\t\t.ToList ( );\n\n\t\t\tforeach ( string PathSegment in SeparatedPath.AsEnumerable ( ) )\n\t\t\t{\n\t\t\t\tif ( CommonPath.Length == 0 && Paths.All ( str => str.StartsWith ( PathSegment ) ) )\n\t\t\t\t{\n\t\t\t\t\tCommonPath = PathSegment;\n\t\t\t\t}\n\t\t\t\telse if ( Paths.All ( str => str.StartsWith ( CommonPath + Separator + PathSegment ) ) )\n\t\t\t\t{\n\t\t\t\t\tCommonPath += Separator + PathSegment;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\treturn CommonPath;\n\t\t}\n\t}\n}\n"}
{"id": 133848, "name": "Find common directory path", "source": "Translate Ruby to Java: require 'abbrev'\n\ndirs = %w( /home/user1/tmp/coverage/test /home/user1/tmp/covert/operator /home/user1/tmp/coven/members )\n\ncommon_prefix = dirs.abbrev.keys.min_by {|key| key.length}.chop  \ncommon_directory = common_prefix.sub(%r{/[^/]*$}, '')            \n", "target": "public class CommonPath {\n\tpublic static String commonPath(String... paths){\n\t\tString commonPath = \"\";\n\t\tString[][] folders = new String[paths.length][];\n\t\tfor(int i = 0; i < paths.length; i++){\n\t\t\tfolders[i] = paths[i].split(\"/\"); \n\t\t}\n\t\tfor(int j = 0; j < folders[0].length; j++){\n\t\t\tString thisFolder = folders[0][j]; \n\t\t\tboolean allMatched = true; \n\t\t\tfor(int i = 1; i < folders.length && allMatched; i++){ \n\t\t\t\tif(folders[i].length < j){ \n\t\t\t\t\tallMatched = false; \n\t\t\t\t\tbreak; \n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tallMatched &= folders[i][j].equals(thisFolder); \n\t\t\t}\n\t\t\tif(allMatched){ \n\t\t\t\tcommonPath += thisFolder + \"/\"; \n\t\t\t}else{\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn commonPath;\n\t}\n\t\n\tpublic static void main(String[] args){\n\t\tString[] paths = { \"/home/user1/tmp/coverage/test\",\n\t\t\t\t \"/home/user1/tmp/covert/operator\",\n\t\t\t\t \"/home/user1/tmp/coven/members\"};\n\t\tSystem.out.println(commonPath(paths));\n\t\t\n\t\tString[] paths2 = { \"/hame/user1/tmp/coverage/test\",\n\t\t\t\t \"/home/user1/tmp/covert/operator\",\n\t\t\t\t \"/home/user1/tmp/coven/members\"};\n\t\tSystem.out.println(commonPath(paths2));\n\t}\n}\n"}
{"id": 133849, "name": "Find common directory path", "source": "Translate Ruby to Python: require 'abbrev'\n\ndirs = %w( /home/user1/tmp/coverage/test /home/user1/tmp/covert/operator /home/user1/tmp/coven/members )\n\ncommon_prefix = dirs.abbrev.keys.min_by {|key| key.length}.chop  \ncommon_directory = common_prefix.sub(%r{/[^/]*$}, '')            \n", "target": ">>> import os\n>>> os.path.commonpath(['/home/user1/tmp/coverage/test', \n                        '/home/user1/tmp/covert/operator', '/home/user1/tmp/coven/members'])\n'/home/user1/tmp'\n"}
{"id": 134003, "name": "Delegates", "source": "Translate Ruby to C#: class Delegator\n   attr_accessor :delegate\n   def operation\n      if @delegate.respond_to?(:thing)\n         @delegate.thing\n      else\n         'default implementation'\n      end\n   end\nend\n\nclass Delegate\n   def thing\n      'delegate implementation'\n   end\nend\n\nif __FILE__ == $PROGRAM_NAME\n\n   \n   a = Delegator.new\n   puts a.operation \n\n   \n   a.delegate = 'A delegate may be any object'\n   puts a.operation \n\n   \n   a.delegate = Delegate.new\n   puts a.operation \nend\n", "target": "using System;\n\ninterface IOperable\n{\n    string Operate();\n}\n\nclass Inoperable\n{\n}\n\nclass Operable : IOperable\n{\n    public string Operate()\n    {\n        return \"Delegate implementation.\";\n    }\n}\n\nclass Delegator : IOperable\n{\n    object Delegate;\n\n    public string Operate()\n    {\n        var operable = Delegate as IOperable;\n        return operable != null ? operable.Operate() : \"Default implementation.\";\n    }\n\n    static void Main()\n    {\n        var delegator = new Delegator();\n        foreach (var @delegate in new object[] { null, new Inoperable(), new Operable() })\n        {\n            delegator.Delegate = @delegate;\n            Console.WriteLine(delegator.Operate());\n        }\n    }\n}\n"}
{"id": 134005, "name": "Delegates", "source": "Translate Ruby to Java: class Delegator\n   attr_accessor :delegate\n   def operation\n      if @delegate.respond_to?(:thing)\n         @delegate.thing\n      else\n         'default implementation'\n      end\n   end\nend\n\nclass Delegate\n   def thing\n      'delegate implementation'\n   end\nend\n\nif __FILE__ == $PROGRAM_NAME\n\n   \n   a = Delegator.new\n   puts a.operation \n\n   \n   a.delegate = 'A delegate may be any object'\n   puts a.operation \n\n   \n   a.delegate = Delegate.new\n   puts a.operation \nend\n", "target": "interface Thingable {\n    String thing();\n}\n\nclass Delegator {\n    public Thingable delegate;\n\n    public String operation() {\n        if (delegate == null)\n            return \"default implementation\";\n        else\n            return delegate.thing();\n    }\n}\n\nclass Delegate implements Thingable {\n    public String thing() {\n        return \"delegate implementation\";\n    }\n}\n\n\n\npublic class DelegateExample {\n    public static void main(String[] args) {\n        \n        Delegator a = new Delegator();\n        assert a.operation().equals(\"default implementation\");\n\n        \n        Delegate d = new Delegate();\n        a.delegate = d;\n        assert a.operation().equals(\"delegate implementation\");\n\n        \n        a.delegate = new Thingable() {\n                public String thing() {\n                    return \"anonymous delegate implementation\";\n                }\n            };\n        assert a.operation().equals(\"anonymous delegate implementation\");\n    }\n}\n"}
{"id": 134006, "name": "Delegates", "source": "Translate Ruby to Python: class Delegator\n   attr_accessor :delegate\n   def operation\n      if @delegate.respond_to?(:thing)\n         @delegate.thing\n      else\n         'default implementation'\n      end\n   end\nend\n\nclass Delegate\n   def thing\n      'delegate implementation'\n   end\nend\n\nif __FILE__ == $PROGRAM_NAME\n\n   \n   a = Delegator.new\n   puts a.operation \n\n   \n   a.delegate = 'A delegate may be any object'\n   puts a.operation \n\n   \n   a.delegate = Delegate.new\n   puts a.operation \nend\n", "target": "class Delegator:\n   def __init__(self):\n      self.delegate = None\n   def operation(self):\n       if hasattr(self.delegate, 'thing') and callable(self.delegate.thing):\n          return self.delegate.thing()\n       return 'default implementation'\n\nclass Delegate:\n   def thing(self):\n      return 'delegate implementation'\n\nif __name__ == '__main__':\n\n   \n   a = Delegator()\n   assert a.operation() == 'default implementation'\n\n   \n   a.delegate = 'A delegate may be any object'\n   assert a.operation() == 'default implementation'\n\n   \n   a.delegate = Delegate()\n   assert a.operation() == 'delegate implementation'\n"}
{"id": 134500, "name": "Empty string", "source": "Translate Ruby to C#: s = \"\"\ns = String.new\ns = \"any string\"; s.clear\n", "target": "using System;\n\nnamespace EmptyString\n{\n  class Program\n  {\n    public static void Main()\n    {\n      String s = scope .();\n      if (s.IsEmpty)\n      {\n        Console.Writeln(\"string empty\");\n      }\n      if (!s.IsEmpty)\n      {\n        Console.Writeln(\"string not empty\");\n      }\n    }\n  }\n}\n"}
{"id": 134501, "name": "Empty string", "source": "Translate Ruby to C#: s = \"\"\ns = String.new\ns = \"any string\"; s.clear\n", "target": "using System;\n\nnamespace EmptyString\n{\n  class Program\n  {\n    public static void Main()\n    {\n      String s = scope .();\n      if (s.IsEmpty)\n      {\n        Console.Writeln(\"string empty\");\n      }\n      if (!s.IsEmpty)\n      {\n        Console.Writeln(\"string not empty\");\n      }\n    }\n  }\n}\n"}
{"id": 134504, "name": "Empty string", "source": "Translate Ruby to Java: s = \"\"\ns = String.new\ns = \"any string\"; s.clear\n", "target": "String s = \"\";\nif(s != null && s.isEmpty()){\n   System.out.println(\"s is empty\");\n}else{\n   System.out.println(\"s is not empty\");\n}\n"}
{"id": 134505, "name": "Empty string", "source": "Translate Ruby to Python: s = \"\"\ns = String.new\ns = \"any string\"; s.clear\n", "target": "s = ''\n\ns = str()\n\nif not s or s == '':\n   print(\"String is empty\")\n\nif len(s) == 0:\n    print(\"String is empty\")\nelse:\n    print(\"String not empty\")\n\n\n\n\n\n\ndef emptystring(s):\n   if isinstance(s, (''.__class__ , u''.__class__) ):\n      if len(s) == 0: \n         return True\n      else \n         return False\n\n   elif s is None:\n        return True\n"}
{"id": 134506, "name": "Empty string", "source": "Translate Ruby to Python: s = \"\"\ns = String.new\ns = \"any string\"; s.clear\n", "target": "s = ''\n\ns = str()\n\nif not s or s == '':\n   print(\"String is empty\")\n\nif len(s) == 0:\n    print(\"String is empty\")\nelse:\n    print(\"String not empty\")\n\n\n\n\n\n\ndef emptystring(s):\n   if isinstance(s, (''.__class__ , u''.__class__) ):\n      if len(s) == 0: \n         return True\n      else \n         return False\n\n   elif s is None:\n        return True\n"}
{"id": 134991, "name": "Equilibrium index", "source": "Translate Ruby to C#: def eq_indices(list)\n  list.each_index.select do |i|\n    list[0...i].sum == list[i+1..-1].sum\n  end\nend\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\nclass Program\n{\n    static IEnumerable<int> EquilibriumIndices(IEnumerable<int> sequence)\n    {\n        var left = 0;\n        var right = sequence.Sum();\n        var index = 0;\n        foreach (var element in sequence)\n        {\n            right -= element;\n            if (left == right)\n            {\n                yield return index;\n            }\n            left += element;\n            index++;\n        }\n    }\n\n    static void Main()\n    {\n        foreach (var index in EquilibriumIndices(new[] { -7, 1, 5, 2, -4, 3, 0 }))\n        {\n            Console.WriteLine(index);\n        }\n    }\n}\n"}
{"id": 134992, "name": "Equilibrium index", "source": "Translate Ruby to C#: def eq_indices(list)\n  list.each_index.select do |i|\n    list[0...i].sum == list[i+1..-1].sum\n  end\nend\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\nclass Program\n{\n    static IEnumerable<int> EquilibriumIndices(IEnumerable<int> sequence)\n    {\n        var left = 0;\n        var right = sequence.Sum();\n        var index = 0;\n        foreach (var element in sequence)\n        {\n            right -= element;\n            if (left == right)\n            {\n                yield return index;\n            }\n            left += element;\n            index++;\n        }\n    }\n\n    static void Main()\n    {\n        foreach (var index in EquilibriumIndices(new[] { -7, 1, 5, 2, -4, 3, 0 }))\n        {\n            Console.WriteLine(index);\n        }\n    }\n}\n"}
{"id": 134995, "name": "Equilibrium index", "source": "Translate Ruby to Java: def eq_indices(list)\n  list.each_index.select do |i|\n    list[0...i].sum == list[i+1..-1].sum\n  end\nend\n", "target": "public class Equlibrium {\n\tpublic static void main(String[] args) {\n\t\tint[] sequence = {-7, 1, 5, 2, -4, 3, 0};\n\t\tequlibrium_indices(sequence);\n\t}\n\n\tpublic static void equlibrium_indices(int[] sequence){\n\t\t\n\t\tint totalSum = 0;\n\t\tfor (int n : sequence) {\n\t\t\ttotalSum += n;\n\t\t}\n\t\t\n\t\tint runningSum = 0;\n\t\tfor (int i = 0; i < sequence.length; i++) {\n\t\t\tint n = sequence[i];\n\t\t\tif (totalSum - runningSum - n == runningSum) {\n\t\t\t\tSystem.out.println(i);\n\t\t\t}\n\t\t\trunningSum += n;\n\t\t}\n\t}\n}\n"}
{"id": 134996, "name": "Equilibrium index", "source": "Translate Ruby to Java: def eq_indices(list)\n  list.each_index.select do |i|\n    list[0...i].sum == list[i+1..-1].sum\n  end\nend\n", "target": "public class Equlibrium {\n\tpublic static void main(String[] args) {\n\t\tint[] sequence = {-7, 1, 5, 2, -4, 3, 0};\n\t\tequlibrium_indices(sequence);\n\t}\n\n\tpublic static void equlibrium_indices(int[] sequence){\n\t\t\n\t\tint totalSum = 0;\n\t\tfor (int n : sequence) {\n\t\t\ttotalSum += n;\n\t\t}\n\t\t\n\t\tint runningSum = 0;\n\t\tfor (int i = 0; i < sequence.length; i++) {\n\t\t\tint n = sequence[i];\n\t\t\tif (totalSum - runningSum - n == runningSum) {\n\t\t\t\tSystem.out.println(i);\n\t\t\t}\n\t\t\trunningSum += n;\n\t\t}\n\t}\n}\n"}
{"id": 134997, "name": "Equilibrium index", "source": "Translate Ruby to Python: def eq_indices(list)\n  list.each_index.select do |i|\n    list[0...i].sum == list[i+1..-1].sum\n  end\nend\n", "target": "def eqindex2Pass(data):\n    \"Two pass\"\n    suml, sumr, ddelayed = 0, sum(data), 0\n    for i, d in enumerate(data):\n        suml += ddelayed\n        sumr -= d\n        ddelayed = d\n        if suml == sumr:\n            yield i\n"}
{"id": 134998, "name": "Equilibrium index", "source": "Translate Ruby to Python: def eq_indices(list)\n  list.each_index.select do |i|\n    list[0...i].sum == list[i+1..-1].sum\n  end\nend\n", "target": "def eqindex2Pass(data):\n    \"Two pass\"\n    suml, sumr, ddelayed = 0, sum(data), 0\n    for i, d in enumerate(data):\n        suml += ddelayed\n        sumr -= d\n        ddelayed = d\n        if suml == sumr:\n            yield i\n"}
{"id": 135322, "name": "Matrix transposition", "source": "Translate Ruby to C#: m=[[1,  1,  1,   1],\n   [2,  4,  8,  16],\n   [3,  9, 27,  81],\n   [4, 16, 64, 256],\n   [5, 25,125, 625]]\nputs m.transpose\n", "target": "using System;\nusing System.Text;\n\nnamespace prog\n{\n\tclass MainClass\n\t{\t\t\t\t\t\t\n\t\tpublic static void Main (string[] args)\n\t\t{\n\t\t\tdouble[,] m = { {1,2,3},{4,5,6},{7,8,9} };\n\t\t\t\n\t\t\tdouble[,] t = Transpose( m );\t\n\t\t\t\n\t\t\tfor( int i=0; i<t.GetLength(0); i++ )\n\t\t\t{\n\t\t\t\tfor( int j=0; j<t.GetLength(1); j++ )\t\t\n\t\t\t\t\tConsole.Write( t[i,j] + \"  \" );\n\t\t\t\tConsole.WriteLine(\"\");\n\t\t\t}\n\t\t}\n\t\t\n\t\tpublic static double[,] Transpose( double[,] m )\n\t\t{\n\t\t\tdouble[,] t = new double[m.GetLength(1),m.GetLength(0)];\n\t\t\tfor( int i=0; i<m.GetLength(0); i++ )\n\t\t\t\tfor( int j=0; j<m.GetLength(1); j++ )\n\t\t\t\t\tt[j,i] = m[i,j];\t\t\t\n\t\t\t\n\t\t\treturn t;\n\t\t}\n\t}\n}\n"}
{"id": 135324, "name": "Matrix transposition", "source": "Translate Ruby to Java: m=[[1,  1,  1,   1],\n   [2,  4,  8,  16],\n   [3,  9, 27,  81],\n   [4, 16, 64, 256],\n   [5, 25,125, 625]]\nputs m.transpose\n", "target": "import java.util.Arrays;\npublic class Transpose{\n       public static void main(String[] args){\n               double[][] m = {{1, 1, 1, 1},\n                               {2, 4, 8, 16},\n                               {3, 9, 27, 81},\n                               {4, 16, 64, 256},\n                               {5, 25, 125, 625}};\n               double[][] ans = new double[m[0].length][m.length];\n               for(int rows = 0; rows < m.length; rows++){\n                       for(int cols = 0; cols < m[0].length; cols++){\n                               ans[cols][rows] = m[rows][cols];\n                       }\n               }\n               for(double[] i:ans){\n                       System.out.println(Arrays.toString(i));\n               }\n       }\n}\n"}
{"id": 135325, "name": "Matrix transposition", "source": "Translate Ruby to Python: m=[[1,  1,  1,   1],\n   [2,  4,  8,  16],\n   [3,  9, 27,  81],\n   [4, 16, 64, 256],\n   [5, 25,125, 625]]\nputs m.transpose\n", "target": "m=((1,  1,  1,   1),\n   (2,  4,  8,  16),\n   (3,  9, 27,  81),\n   (4, 16, 64, 256),\n   (5, 25,125, 625))\nprint(zip(*m))\n\n\n"}
{"id": 135481, "name": "Atomic updates", "source": "Translate Ruby to C#: require 'thread'\n\n\n\n\nclass BucketStore\n\n  \n  \n  def initialize nbuckets\n    \n    @buckets = (0...nbuckets).map { rand(1024) }\n\n    \n    @mutex = Mutex.new\n  end\n\n  \n  def buckets\n    @mutex.synchronize { Array.new(@buckets) }\n  end\n\n  \n  \n  def transfer destination, source, amount\n    \n    return nil if destination == source\n\n    @mutex.synchronize do\n      \n      amount = [amount, @buckets[source]].min\n\n      @buckets[source] -= amount\n      @buckets[destination] += amount\n    end\n    nil\n  end\nend\n\n\nbucket_store = BucketStore.new 8\n\n\nTOTAL = bucket_store.buckets.inject { |a, b| a += b }\n\n\nThread.new do\n  loop do\n    \n    buckets = bucket_store.buckets\n    first = rand buckets.length\n    second = rand buckets.length\n\n    \n    first, second = second, first if buckets[first] > buckets[second]\n\n    \n    bucket_store.transfer first, second, (buckets[second] - buckets[first]) / 2\n  end\nend\n\n\nThread.new do\n  loop do\n    \n    buckets = bucket_store.buckets\n    first = rand buckets.length\n    second = rand buckets.length\n\n    \n    bucket_store.transfer first, second, rand(buckets[second])\n  end\nend\n\n\nloop do\n  sleep 1\n\n  buckets = bucket_store.buckets\n\n  \n  \n  \n  n = buckets.inject { |a, b| a += b }\n\n  \n  printf \"%s, total %d\\n\", (buckets.map { |v| sprintf \"%4d\", v }.join \" \"), n\n\n  if n != TOTAL\n    \n    $stderr.puts \"ERROR: Total changed from \n    exit 1\n  end\nend\n", "target": "using System; \nusing System.Threading; \npublic class ThreadSafeBuckets\n{\n    \n    \n    Random rand = new Random();\n    int[] Buckets;\n    object[] locks; \n    public int BucketCount { get; private set; }\n    public ThreadSafeBuckets(int bucketcount)\n    {\n        \n        BucketCount = bucketcount;\n        Buckets = new int[bucketcount];\n        locks = new object[bucketcount];\n        int startingtotal = 0;\n        for (int i = 0; i < BucketCount; i++)\n        {\n            locks[i] = new object();\n            Buckets[i] = rand.Next(30);\n            startingtotal += Buckets[i];\n        }\n        \n        Console.WriteLine(\"Starting total: \" + startingtotal);\n    }\n    public int GetBucketValue(int i)\n    {\n        return Buckets[i];\n    }\n    public void Transfer(int i, int j, int amount)\n    {\n        \n        if (i > BucketCount || j > BucketCount || i < 0 || j < 0 ||\n            i == j || amount < 0)\n            return;\n\n        \n        lock (locks[Math.Min(i, j)])\n            lock (locks[Math.Max(i, j)])\n            {\n                \n                amount = Math.Min(amount, Buckets[i]);\n\n                \n                Buckets[i] -= amount;\n                Buckets[j] += amount;\n            }\n    }\n\n    public void PrintBuckets()\n    {\n        int counter = 0;\n        \n        for (int i = 0; i < BucketCount; i++)\n        {\n            Monitor.Enter(locks[i]);\n            Console.Write(Buckets[i] + \" \");\n            counter += Buckets[i];\n        }\n        \n        Console.Write(\"= \" + counter);\n        Console.WriteLine();\n\n        foreach (var l in locks)\n            Monitor.Exit(l);\n    }\n}\n\nclass Program\n{\n    static ThreadSafeBuckets TSBs;\n\n    public static void Main(){\n        \n        TSBs = new ThreadSafeBuckets(10);\n        TSBs.PrintBuckets();\n        \n        new Thread(new ThreadStart(EqualizerThread)).Start();\n        Thread.Sleep(1);\n        \n        new Thread(new ThreadStart(RandomizerThread)).Start();\n        \n        PrinterThread();\n    }\n    \n    static void EqualizerThread()\n    {\n        Random rand = new Random();\n        while (true)\n        {\n            \n            int b1 = rand.Next(TSBs.BucketCount);\n            int b2 = rand.Next(TSBs.BucketCount);\n            \n            int diff = TSBs.GetBucketValue(b1) - TSBs.GetBucketValue(b2);\n            \n            if (diff < 0)\n                TSBs.Transfer(b2, b1, -diff / 2);\n            else\n                TSBs.Transfer(b1, b2, diff/2);\n        }\n    }\n    \n    static void RandomizerThread()\n    {\n        Random rand = new Random();\n        while (true)\n        {\n            int b1 = rand.Next(TSBs.BucketCount);\n            int b2 = rand.Next(TSBs.BucketCount);\n            int diff = rand.Next(TSBs.GetBucketValue(b1));\n            TSBs.Transfer(b1, b2, diff);\n        }\n    }\n    \n    static void PrinterThread()\n    {\n        while (true)\n        {\n            Thread.Sleep(50); \n            TSBs.PrintBuckets();\n        }\n    }\n}\n"}
{"id": 135483, "name": "Atomic updates", "source": "Translate Ruby to Java: require 'thread'\n\n\n\n\nclass BucketStore\n\n  \n  \n  def initialize nbuckets\n    \n    @buckets = (0...nbuckets).map { rand(1024) }\n\n    \n    @mutex = Mutex.new\n  end\n\n  \n  def buckets\n    @mutex.synchronize { Array.new(@buckets) }\n  end\n\n  \n  \n  def transfer destination, source, amount\n    \n    return nil if destination == source\n\n    @mutex.synchronize do\n      \n      amount = [amount, @buckets[source]].min\n\n      @buckets[source] -= amount\n      @buckets[destination] += amount\n    end\n    nil\n  end\nend\n\n\nbucket_store = BucketStore.new 8\n\n\nTOTAL = bucket_store.buckets.inject { |a, b| a += b }\n\n\nThread.new do\n  loop do\n    \n    buckets = bucket_store.buckets\n    first = rand buckets.length\n    second = rand buckets.length\n\n    \n    first, second = second, first if buckets[first] > buckets[second]\n\n    \n    bucket_store.transfer first, second, (buckets[second] - buckets[first]) / 2\n  end\nend\n\n\nThread.new do\n  loop do\n    \n    buckets = bucket_store.buckets\n    first = rand buckets.length\n    second = rand buckets.length\n\n    \n    bucket_store.transfer first, second, rand(buckets[second])\n  end\nend\n\n\nloop do\n  sleep 1\n\n  buckets = bucket_store.buckets\n\n  \n  \n  \n  n = buckets.inject { |a, b| a += b }\n\n  \n  printf \"%s, total %d\\n\", (buckets.map { |v| sprintf \"%4d\", v }.join \" \"), n\n\n  if n != TOTAL\n    \n    $stderr.puts \"ERROR: Total changed from \n    exit 1\n  end\nend\n", "target": "import java.util.Arrays;\nimport java.util.concurrent.ThreadLocalRandom;\n\npublic class AtomicUpdates {\n\n    private static final int NUM_BUCKETS = 10;\n\n    public static class Buckets {\n        private final int[] data;\n\n        public Buckets(int[] data) {\n            this.data = data.clone();\n        }\n\n        public int getBucket(int index) {\n            synchronized (data) {\n                return data[index];\n            }\n        }\n\n        public int transfer(int srcIndex, int dstIndex, int amount) {\n            if (amount < 0)\n                throw new IllegalArgumentException(\"negative amount: \" + amount);\n            if (amount == 0)\n                return 0;\n\n            synchronized (data) {\n                if (data[srcIndex] - amount < 0)\n                    amount = data[srcIndex];\n                if (data[dstIndex] + amount < 0)\n                    amount = Integer.MAX_VALUE - data[dstIndex];\n                if (amount < 0)\n                    throw new IllegalStateException();\n                data[srcIndex] -= amount;\n                data[dstIndex] += amount;\n                return amount;\n            }\n        }\n\n        public int[] getBuckets() {\n            synchronized (data) {\n                return data.clone();\n            }\n        }\n    }\n\n    private static long getTotal(int[] values) {\n        long total = 0;\n        for (int value : values) {\n            total += value;\n        }\n        return total;\n    }\n\n    public static void main(String[] args) {\n        ThreadLocalRandom rnd = ThreadLocalRandom.current();\n\n        int[] values = new int[NUM_BUCKETS];\n        for (int i = 0; i < values.length; i++)\n            values[i] = rnd.nextInt() & Integer.MAX_VALUE;\n        System.out.println(\"Initial Array: \" + getTotal(values) + \" \" + Arrays.toString(values));\n\n        Buckets buckets = new Buckets(values);\n        new Thread(() -> equalize(buckets), \"equalizer\").start();\n        new Thread(() -> transferRandomAmount(buckets), \"transferrer\").start();\n        new Thread(() -> print(buckets), \"printer\").start();\n    }\n\n    private static void transferRandomAmount(Buckets buckets) {\n        ThreadLocalRandom rnd = ThreadLocalRandom.current();\n        while (true) {\n            int srcIndex = rnd.nextInt(NUM_BUCKETS);\n            int dstIndex = rnd.nextInt(NUM_BUCKETS);\n            int amount = rnd.nextInt() & Integer.MAX_VALUE;\n            buckets.transfer(srcIndex, dstIndex, amount);\n        }\n    }\n\n    private static void equalize(Buckets buckets) {\n        ThreadLocalRandom rnd = ThreadLocalRandom.current();\n        while (true) {\n            int srcIndex = rnd.nextInt(NUM_BUCKETS);\n            int dstIndex = rnd.nextInt(NUM_BUCKETS);\n            int amount = (buckets.getBucket(srcIndex) - buckets.getBucket(dstIndex)) / 2;\n            if (amount >= 0)\n                buckets.transfer(srcIndex, dstIndex, amount);\n        }\n    }\n\n    private static void print(Buckets buckets) {\n        while (true) {\n            long nextPrintTime = System.currentTimeMillis() + 3000;\n            long now;\n            while ((now = System.currentTimeMillis()) < nextPrintTime) {\n                try {\n                    Thread.sleep(nextPrintTime - now);\n                } catch (InterruptedException e) {\n                    return;\n                }\n            }\n\n            int[] bucketValues = buckets.getBuckets();\n            System.out.println(\"Current values: \" + getTotal(bucketValues) + \" \" + Arrays.toString(bucketValues));\n        }\n    }\n}\n"}
{"id": 135484, "name": "Atomic updates", "source": "Translate Ruby to Python: require 'thread'\n\n\n\n\nclass BucketStore\n\n  \n  \n  def initialize nbuckets\n    \n    @buckets = (0...nbuckets).map { rand(1024) }\n\n    \n    @mutex = Mutex.new\n  end\n\n  \n  def buckets\n    @mutex.synchronize { Array.new(@buckets) }\n  end\n\n  \n  \n  def transfer destination, source, amount\n    \n    return nil if destination == source\n\n    @mutex.synchronize do\n      \n      amount = [amount, @buckets[source]].min\n\n      @buckets[source] -= amount\n      @buckets[destination] += amount\n    end\n    nil\n  end\nend\n\n\nbucket_store = BucketStore.new 8\n\n\nTOTAL = bucket_store.buckets.inject { |a, b| a += b }\n\n\nThread.new do\n  loop do\n    \n    buckets = bucket_store.buckets\n    first = rand buckets.length\n    second = rand buckets.length\n\n    \n    first, second = second, first if buckets[first] > buckets[second]\n\n    \n    bucket_store.transfer first, second, (buckets[second] - buckets[first]) / 2\n  end\nend\n\n\nThread.new do\n  loop do\n    \n    buckets = bucket_store.buckets\n    first = rand buckets.length\n    second = rand buckets.length\n\n    \n    bucket_store.transfer first, second, rand(buckets[second])\n  end\nend\n\n\nloop do\n  sleep 1\n\n  buckets = bucket_store.buckets\n\n  \n  \n  \n  n = buckets.inject { |a, b| a += b }\n\n  \n  printf \"%s, total %d\\n\", (buckets.map { |v| sprintf \"%4d\", v }.join \" \"), n\n\n  if n != TOTAL\n    \n    $stderr.puts \"ERROR: Total changed from \n    exit 1\n  end\nend\n", "target": "from __future__ import with_statement \nimport threading\nimport random\nimport time\n\nterminate = threading.Event()\n\nclass Buckets:\n    def __init__(self, nbuckets):\n        self.nbuckets = nbuckets\n        self.values = [random.randrange(10) for i in range(nbuckets)]\n        self.lock = threading.Lock()\n\n    def __getitem__(self, i):\n        return self.values[i]\n\n    def transfer(self, src, dst, amount):\n        with self.lock:\n            amount = min(amount, self.values[src])\n            self.values[src] -= amount\n            self.values[dst] += amount\n\n    def snapshot(self):\n        \n        with self.lock:\n            return self.values[:]\n\ndef randomize(buckets):\n    nbuckets = buckets.nbuckets\n    while not terminate.isSet():\n        src = random.randrange(nbuckets)\n        dst = random.randrange(nbuckets)\n        if dst!=src:\n            amount = random.randrange(20)\n            buckets.transfer(src, dst, amount)\n\ndef equalize(buckets):\n    nbuckets = buckets.nbuckets\n    while not terminate.isSet():\n        src = random.randrange(nbuckets)\n        dst = random.randrange(nbuckets)\n        if dst!=src:\n            amount = (buckets[src] - buckets[dst]) // 2\n            if amount>=0: buckets.transfer(src, dst, amount)\n            else: buckets.transfer(dst, src, -amount)\n\ndef print_state(buckets):\n    snapshot = buckets.snapshot()\n    for value in snapshot:\n        print '%2d' % value,\n    print '=', sum(snapshot)\n\n\nbuckets = Buckets(15)\n\n\nt1 = threading.Thread(target=randomize, args=[buckets])\nt1.start()\n\n\nt2 = threading.Thread(target=equalize, args=[buckets])\nt2.start()\n\n\ntry:\n    while True:\n        print_state(buckets)\n        time.sleep(1)\nexcept KeyboardInterrupt: \n    terminate.set()\n\n\nt1.join()\nt2.join()\n"}
{"id": 135637, "name": "Subtractive generator", "source": "Translate Ruby to C#: \n\nclass SubRandom\n  \n  attr_reader :seed\n\n  \n  \n  def initialize(seed = Kernel.rand(1_000_000_000))\n    (0..999_999_999).include? seed or\n      raise ArgumentError, \"seed not in 0..999_999_999\"\n\n    \n    ary = [seed, 1]\n    53.times { ary << ary[-2] - ary[-1] }\n    @state = []\n    34.step(1870, 34) {|i| @state << ary[i % 55] }\n\n    220.times { rand }  \n\n    @seed = seed        \n  end\n\n  \n  def initialize_copy(orig)\n    @state = @state.dup\n  end\n\n  \n  def rand\n    @state << (@state[-55] - @state[-24]) % 1_000_000_000\n    @state.shift\n  end\nend\n\nrng = SubRandom.new(292929)\np (1..3).map { rng.rand }\n", "target": "public class SubtractiveGenerator {\n    public static int MAX = 1000000000;\n    private int[] state;\n    private int pos;\n\n    private int mod(int n) {\n        return ((n % MAX) + MAX) % MAX;\n    }\n\n    public SubtractiveGenerator(int seed) {\n        state = new int[55];\n\n        int[] temp = new int[55];\n        temp[0] = mod(seed);\n        temp[1] = 1;\n        for(int i = 2; i < 55; ++i)\n            temp[i] = mod(temp[i - 2] - temp[i - 1]);\n\n        for(int i = 0; i < 55; ++i)\n            state[i] = temp[(34 * (i + 1)) % 55];\n\n        pos = 54;\n        for(int i = 55; i < 220; ++i)\n            next();\n    }\n\n    public int next() {\n        int temp = mod(state[(pos + 1) % 55] - state[(pos + 32) % 55]);\n        pos = (pos + 1) % 55;\n        state[pos] = temp;\n        return temp;\n    }\n\n    static void Main(string[] args) {\n        SubtractiveGenerator gen = new SubtractiveGenerator(292929);\n        for(int i = 220; i < 230; ++i)\n            Console.WriteLine(i.ToString() + \": \" + gen.next().ToString());\n    }\n}\n"}
{"id": 135639, "name": "Subtractive generator", "source": "Translate Ruby to Java: \n\nclass SubRandom\n  \n  attr_reader :seed\n\n  \n  \n  def initialize(seed = Kernel.rand(1_000_000_000))\n    (0..999_999_999).include? seed or\n      raise ArgumentError, \"seed not in 0..999_999_999\"\n\n    \n    ary = [seed, 1]\n    53.times { ary << ary[-2] - ary[-1] }\n    @state = []\n    34.step(1870, 34) {|i| @state << ary[i % 55] }\n\n    220.times { rand }  \n\n    @seed = seed        \n  end\n\n  \n  def initialize_copy(orig)\n    @state = @state.dup\n  end\n\n  \n  def rand\n    @state << (@state[-55] - @state[-24]) % 1_000_000_000\n    @state.shift\n  end\nend\n\nrng = SubRandom.new(292929)\np (1..3).map { rng.rand }\n", "target": "import java.util.function.IntSupplier;\nimport static java.util.stream.IntStream.generate;\n\npublic class SubtractiveGenerator implements IntSupplier {\n    static final int MOD = 1_000_000_000;\n    private int[] state = new int[55];\n    private int si, sj;\n\n    public SubtractiveGenerator(int p1) {\n        subrandSeed(p1);\n    }\n\n    void subrandSeed(int p1) {\n        int p2 = 1;\n\n        state[0] = p1 % MOD;\n        for (int i = 1, j = 21; i < 55; i++, j += 21) {\n            if (j >= 55)\n                j -= 55;\n            state[j] = p2;\n            if ((p2 = p1 - p2) < 0)\n                p2 += MOD;\n            p1 = state[j];\n        }\n\n        si = 0;\n        sj = 24;\n        for (int i = 0; i < 165; i++)\n            getAsInt();\n    }\n\n    @Override\n    public int getAsInt() {\n        if (si == sj)\n            subrandSeed(0);\n\n        if (si-- == 0)\n            si = 54;\n        if (sj-- == 0)\n            sj = 54;\n\n        int x = state[si] - state[sj];\n        if (x < 0)\n            x += MOD;\n\n        return state[si] = x;\n    }\n\n    public static void main(String[] args) {\n        generate(new SubtractiveGenerator(292_929)).limit(10)\n                .forEach(System.out::println);\n    }\n}\n"}
{"id": 135640, "name": "Subtractive generator", "source": "Translate Ruby to Python: \n\nclass SubRandom\n  \n  attr_reader :seed\n\n  \n  \n  def initialize(seed = Kernel.rand(1_000_000_000))\n    (0..999_999_999).include? seed or\n      raise ArgumentError, \"seed not in 0..999_999_999\"\n\n    \n    ary = [seed, 1]\n    53.times { ary << ary[-2] - ary[-1] }\n    @state = []\n    34.step(1870, 34) {|i| @state << ary[i % 55] }\n\n    220.times { rand }  \n\n    @seed = seed        \n  end\n\n  \n  def initialize_copy(orig)\n    @state = @state.dup\n  end\n\n  \n  def rand\n    @state << (@state[-55] - @state[-24]) % 1_000_000_000\n    @state.shift\n  end\nend\n\nrng = SubRandom.new(292929)\np (1..3).map { rng.rand }\n", "target": "import collections\ns= collections.deque(maxlen=55)\n\nseed = 292929\n\n\n\n\ns.append(seed)\ns.append(1)\n\n\n\nfor n in xrange(2, 55):\n    s.append((s[n-2] - s[n-1]) % 10**9)\n\n\n\n\nr = collections.deque(maxlen=55)\nfor n in xrange(55):\n    i = (34 * (n+1)) % 55\n    r.append(s[i])\n\n\n\n\n\n\ndef getnextr():\n    \n    r.append((r[0]-r[31])%10**9)\n    return r[54]\n\n\nfor n in xrange(219 - 54):\n    getnextr()\n\n\n\nfor i in xrange(5):\n    print \"result = \", getnextr()\n"}
{"id": 135772, "name": "Bitcoin_address validation", "source": "Translate Ruby to C#: \n\n\n\nrequire 'digest/sha2'\ndef convert g\n  i,e = '',[]\n  (0...g.length/2).each{|n| e[n] = g[n+=n]+g[n+1]; i+='H2'}\n  e.pack(i)\nend\nN = [0,1,2,3,4,5,6,7,8,nil,nil,nil,nil,nil,nil,nil,9,10,11,12,13,14,15,16,nil,17,18,19,20,21,nil,22,23,24,25,26,27,28,29,30,31,32,nil,nil,nil,nil,nil,nil,33,34,35,36,37,38,39,40,41,42,43,nil,44,45,46,47,48,49,50,51,52,53,54,55,56,57]\nA = '1AGNa15ZQXAZUgFiqJ2i7Z2DPU2J6hW62x'\ng = A.bytes.inject(0){|g,n| g*58+N[n-49]}.to_s(16) \nn = g.slice!(0..-9)\n(n.length...42).each{n.insert(0,'0')}\nputs \"I think the checksum should be \n", "target": "using System;\nusing System.Linq;\nusing System.Security.Cryptography;\nusing NUnit.Framework;\n\nnamespace BitcoinValidator\n{\n    public class ValidateTest\n    {\n        [TestCase]\n        public void ValidateBitcoinAddressTest()\n        {\n            Assert.IsTrue(ValidateBitcoinAddress(\"1AGNa15ZQXAZUgFiqJ2i7Z2DPU2J6hW62i\")); \n            Assert.IsTrue(ValidateBitcoinAddress(\"1Q1pE5vPGEEMqRcVRMbtBK842Y6Pzo6nK9\")); \n            Assert.Throws<Exception>(() => ValidateBitcoinAddress(\"1AGNa15ZQXAZUgFiqJ2i7Z2DPU2J6hW62X\")); \n            Assert.Throws<Exception>(() => ValidateBitcoinAddress(\"1ANNa15ZQXAZUgFiqJ2i7Z2DPU2J6hW62i\")); \n            Assert.Throws<Exception>(() => ValidateBitcoinAddress(\"1A Na15ZQXAZUgFiqJ2i7Z2DPU2J6hW62i\")); \n            Assert.Throws<Exception>(() => ValidateBitcoinAddress(\"BZbvjr\")); \n        }\n\n        public static bool ValidateBitcoinAddress(string address)\n        {\n            if (address.Length < 26 || address.Length > 35) throw new Exception(\"wrong length\");\n            var decoded = DecodeBase58(address);\n            var d1 = Hash(decoded.SubArray(0, 21));\n            var d2 = Hash(d1);\n            if (!decoded.SubArray(21, 4).SequenceEqual(d2.SubArray(0, 4))) throw new Exception(\"bad digest\");\n            return true;\n        }\n\n        const string Alphabet = \"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz\";\n        const int Size = 25;\n\n        private static byte[] DecodeBase58(string input)\n        {\n            var output = new byte[Size];\n            foreach (var t in input)\n            {\n                var p = Alphabet.IndexOf(t);\n                if (p == -1) throw new Exception(\"invalid character found\");\n                var j = Size;\n                while (--j > 0)\n                {\n                    p += 58 * output[j];\n                    output[j] = (byte)(p % 256);\n                    p /= 256;\n                }\n                if (p != 0) throw new Exception(\"address too long\");\n            }\n            return output;\n        }\n\n        private static byte[] Hash(byte[] bytes)\n        {\n            var hasher = new SHA256Managed();\n            return hasher.ComputeHash(bytes);\n        }\n    }\n\n    public static class ArrayExtensions\n    {\n        public static T[] SubArray<T>(this T[] data, int index, int length)\n        {\n            var result = new T[length];\n            Array.Copy(data, index, result, 0, length);\n            return result;\n        }\n    }\n}\n"}
{"id": 135773, "name": "Bitcoin_address validation", "source": "Translate Ruby to C#: \n\n\n\nrequire 'digest/sha2'\ndef convert g\n  i,e = '',[]\n  (0...g.length/2).each{|n| e[n] = g[n+=n]+g[n+1]; i+='H2'}\n  e.pack(i)\nend\nN = [0,1,2,3,4,5,6,7,8,nil,nil,nil,nil,nil,nil,nil,9,10,11,12,13,14,15,16,nil,17,18,19,20,21,nil,22,23,24,25,26,27,28,29,30,31,32,nil,nil,nil,nil,nil,nil,33,34,35,36,37,38,39,40,41,42,43,nil,44,45,46,47,48,49,50,51,52,53,54,55,56,57]\nA = '1AGNa15ZQXAZUgFiqJ2i7Z2DPU2J6hW62x'\ng = A.bytes.inject(0){|g,n| g*58+N[n-49]}.to_s(16) \nn = g.slice!(0..-9)\n(n.length...42).each{n.insert(0,'0')}\nputs \"I think the checksum should be \n", "target": "using System;\nusing System.Linq;\nusing System.Security.Cryptography;\nusing NUnit.Framework;\n\nnamespace BitcoinValidator\n{\n    public class ValidateTest\n    {\n        [TestCase]\n        public void ValidateBitcoinAddressTest()\n        {\n            Assert.IsTrue(ValidateBitcoinAddress(\"1AGNa15ZQXAZUgFiqJ2i7Z2DPU2J6hW62i\")); \n            Assert.IsTrue(ValidateBitcoinAddress(\"1Q1pE5vPGEEMqRcVRMbtBK842Y6Pzo6nK9\")); \n            Assert.Throws<Exception>(() => ValidateBitcoinAddress(\"1AGNa15ZQXAZUgFiqJ2i7Z2DPU2J6hW62X\")); \n            Assert.Throws<Exception>(() => ValidateBitcoinAddress(\"1ANNa15ZQXAZUgFiqJ2i7Z2DPU2J6hW62i\")); \n            Assert.Throws<Exception>(() => ValidateBitcoinAddress(\"1A Na15ZQXAZUgFiqJ2i7Z2DPU2J6hW62i\")); \n            Assert.Throws<Exception>(() => ValidateBitcoinAddress(\"BZbvjr\")); \n        }\n\n        public static bool ValidateBitcoinAddress(string address)\n        {\n            if (address.Length < 26 || address.Length > 35) throw new Exception(\"wrong length\");\n            var decoded = DecodeBase58(address);\n            var d1 = Hash(decoded.SubArray(0, 21));\n            var d2 = Hash(d1);\n            if (!decoded.SubArray(21, 4).SequenceEqual(d2.SubArray(0, 4))) throw new Exception(\"bad digest\");\n            return true;\n        }\n\n        const string Alphabet = \"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz\";\n        const int Size = 25;\n\n        private static byte[] DecodeBase58(string input)\n        {\n            var output = new byte[Size];\n            foreach (var t in input)\n            {\n                var p = Alphabet.IndexOf(t);\n                if (p == -1) throw new Exception(\"invalid character found\");\n                var j = Size;\n                while (--j > 0)\n                {\n                    p += 58 * output[j];\n                    output[j] = (byte)(p % 256);\n                    p /= 256;\n                }\n                if (p != 0) throw new Exception(\"address too long\");\n            }\n            return output;\n        }\n\n        private static byte[] Hash(byte[] bytes)\n        {\n            var hasher = new SHA256Managed();\n            return hasher.ComputeHash(bytes);\n        }\n    }\n\n    public static class ArrayExtensions\n    {\n        public static T[] SubArray<T>(this T[] data, int index, int length)\n        {\n            var result = new T[length];\n            Array.Copy(data, index, result, 0, length);\n            return result;\n        }\n    }\n}\n"}
{"id": 135774, "name": "Bitcoin_address validation", "source": "Translate Ruby to Java: \n\n\n\nrequire 'digest/sha2'\ndef convert g\n  i,e = '',[]\n  (0...g.length/2).each{|n| e[n] = g[n+=n]+g[n+1]; i+='H2'}\n  e.pack(i)\nend\nN = [0,1,2,3,4,5,6,7,8,nil,nil,nil,nil,nil,nil,nil,9,10,11,12,13,14,15,16,nil,17,18,19,20,21,nil,22,23,24,25,26,27,28,29,30,31,32,nil,nil,nil,nil,nil,nil,33,34,35,36,37,38,39,40,41,42,43,nil,44,45,46,47,48,49,50,51,52,53,54,55,56,57]\nA = '1AGNa15ZQXAZUgFiqJ2i7Z2DPU2J6hW62x'\ng = A.bytes.inject(0){|g,n| g*58+N[n-49]}.to_s(16) \nn = g.slice!(0..-9)\n(n.length...42).each{n.insert(0,'0')}\nputs \"I think the checksum should be \n", "target": "import java.math.BigInteger;\nimport java.security.MessageDigest;\nimport java.security.NoSuchAlgorithmException;\nimport java.util.Arrays;\n\npublic class BitcoinAddressValidator {\n\n    private static final String ALPHABET = \"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz\";\n\n    public static boolean validateBitcoinAddress(String addr) {\n        if (addr.length() < 26 || addr.length() > 35)\n            return false;\n        byte[] decoded = decodeBase58To25Bytes(addr);\n        if (decoded == null)\n            return false;\n\n        byte[] hash1 = sha256(Arrays.copyOfRange(decoded, 0, 21));\n        byte[] hash2 = sha256(hash1);\n\n        return Arrays.equals(Arrays.copyOfRange(hash2, 0, 4), Arrays.copyOfRange(decoded, 21, 25));\n    }\n\n    private static byte[] decodeBase58To25Bytes(String input) {\n        BigInteger num = BigInteger.ZERO;\n        for (char t : input.toCharArray()) {\n            int p = ALPHABET.indexOf(t);\n            if (p == -1)\n                return null;\n            num = num.multiply(BigInteger.valueOf(58)).add(BigInteger.valueOf(p));\n        }\n\n        byte[] result = new byte[25];\n        byte[] numBytes = num.toByteArray();\n        System.arraycopy(numBytes, 0, result, result.length - numBytes.length, numBytes.length);\n        return result;\n    }\n\n    private static byte[] sha256(byte[] data) {\n        try {\n            MessageDigest md = MessageDigest.getInstance(\"SHA-256\");\n            md.update(data);\n            return md.digest();\n        } catch (NoSuchAlgorithmException e) {\n            throw new IllegalStateException(e);\n        }\n    }\n\n    public static void main(String[] args) {\n        assertBitcoin(\"1AGNa15ZQXAZUgFiqJ2i7Z2DPU2J6hW62i\", true);\n        assertBitcoin(\"1AGNa15ZQXAZUgFiqJ2i7Z2DPU2J6hW62j\", false);\n        assertBitcoin(\"1Q1pE5vPGEEMqRcVRMbtBK842Y6Pzo6nK9\", true);\n        assertBitcoin(\"1AGNa15ZQXAZUgFiqJ2i7Z2DPU2J6hW62X\", false);\n        assertBitcoin(\"1ANNa15ZQXAZUgFiqJ2i7Z2DPU2J6hW62i\", false);\n        assertBitcoin(\"1A Na15ZQXAZUgFiqJ2i7Z2DPU2J6hW62i\", false);\n        assertBitcoin(\"BZbvjr\", false);\n        assertBitcoin(\"i55j\", false);\n        assertBitcoin(\"1AGNa15ZQXAZUgFiqJ2i7Z2DPU2J6hW62!\", false);\n        assertBitcoin(\"1AGNa15ZQXAZUgFiqJ2i7Z2DPU2J6hW62iz\", false);\n        assertBitcoin(\"1AGNa15ZQXAZUgFiqJ2i7Z2DPU2J6hW62izz\", false);\n        assertBitcoin(\"1Q1pE5vPGEEMqRcVRMbtBK842Y6Pzo6nJ9\", false);\n        assertBitcoin(\"1AGNa15ZQXAZUgFiqJ2i7Z2DPU2J6hW62I\", false);\n    }\n\n    private static void assertBitcoin(String address, boolean expected) {\n        boolean actual = validateBitcoinAddress(address);\n        if (actual != expected)\n            throw new AssertionError(String.format(\"Expected %s for %s, but got %s.\", expected, address, actual));\n    }\n}\n"}
{"id": 135775, "name": "Bitcoin_address validation", "source": "Translate Ruby to Java: \n\n\n\nrequire 'digest/sha2'\ndef convert g\n  i,e = '',[]\n  (0...g.length/2).each{|n| e[n] = g[n+=n]+g[n+1]; i+='H2'}\n  e.pack(i)\nend\nN = [0,1,2,3,4,5,6,7,8,nil,nil,nil,nil,nil,nil,nil,9,10,11,12,13,14,15,16,nil,17,18,19,20,21,nil,22,23,24,25,26,27,28,29,30,31,32,nil,nil,nil,nil,nil,nil,33,34,35,36,37,38,39,40,41,42,43,nil,44,45,46,47,48,49,50,51,52,53,54,55,56,57]\nA = '1AGNa15ZQXAZUgFiqJ2i7Z2DPU2J6hW62x'\ng = A.bytes.inject(0){|g,n| g*58+N[n-49]}.to_s(16) \nn = g.slice!(0..-9)\n(n.length...42).each{n.insert(0,'0')}\nputs \"I think the checksum should be \n", "target": "import java.math.BigInteger;\nimport java.security.MessageDigest;\nimport java.security.NoSuchAlgorithmException;\nimport java.util.Arrays;\n\npublic class BitcoinAddressValidator {\n\n    private static final String ALPHABET = \"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz\";\n\n    public static boolean validateBitcoinAddress(String addr) {\n        if (addr.length() < 26 || addr.length() > 35)\n            return false;\n        byte[] decoded = decodeBase58To25Bytes(addr);\n        if (decoded == null)\n            return false;\n\n        byte[] hash1 = sha256(Arrays.copyOfRange(decoded, 0, 21));\n        byte[] hash2 = sha256(hash1);\n\n        return Arrays.equals(Arrays.copyOfRange(hash2, 0, 4), Arrays.copyOfRange(decoded, 21, 25));\n    }\n\n    private static byte[] decodeBase58To25Bytes(String input) {\n        BigInteger num = BigInteger.ZERO;\n        for (char t : input.toCharArray()) {\n            int p = ALPHABET.indexOf(t);\n            if (p == -1)\n                return null;\n            num = num.multiply(BigInteger.valueOf(58)).add(BigInteger.valueOf(p));\n        }\n\n        byte[] result = new byte[25];\n        byte[] numBytes = num.toByteArray();\n        System.arraycopy(numBytes, 0, result, result.length - numBytes.length, numBytes.length);\n        return result;\n    }\n\n    private static byte[] sha256(byte[] data) {\n        try {\n            MessageDigest md = MessageDigest.getInstance(\"SHA-256\");\n            md.update(data);\n            return md.digest();\n        } catch (NoSuchAlgorithmException e) {\n            throw new IllegalStateException(e);\n        }\n    }\n\n    public static void main(String[] args) {\n        assertBitcoin(\"1AGNa15ZQXAZUgFiqJ2i7Z2DPU2J6hW62i\", true);\n        assertBitcoin(\"1AGNa15ZQXAZUgFiqJ2i7Z2DPU2J6hW62j\", false);\n        assertBitcoin(\"1Q1pE5vPGEEMqRcVRMbtBK842Y6Pzo6nK9\", true);\n        assertBitcoin(\"1AGNa15ZQXAZUgFiqJ2i7Z2DPU2J6hW62X\", false);\n        assertBitcoin(\"1ANNa15ZQXAZUgFiqJ2i7Z2DPU2J6hW62i\", false);\n        assertBitcoin(\"1A Na15ZQXAZUgFiqJ2i7Z2DPU2J6hW62i\", false);\n        assertBitcoin(\"BZbvjr\", false);\n        assertBitcoin(\"i55j\", false);\n        assertBitcoin(\"1AGNa15ZQXAZUgFiqJ2i7Z2DPU2J6hW62!\", false);\n        assertBitcoin(\"1AGNa15ZQXAZUgFiqJ2i7Z2DPU2J6hW62iz\", false);\n        assertBitcoin(\"1AGNa15ZQXAZUgFiqJ2i7Z2DPU2J6hW62izz\", false);\n        assertBitcoin(\"1Q1pE5vPGEEMqRcVRMbtBK842Y6Pzo6nJ9\", false);\n        assertBitcoin(\"1AGNa15ZQXAZUgFiqJ2i7Z2DPU2J6hW62I\", false);\n    }\n\n    private static void assertBitcoin(String address, boolean expected) {\n        boolean actual = validateBitcoinAddress(address);\n        if (actual != expected)\n            throw new AssertionError(String.format(\"Expected %s for %s, but got %s.\", expected, address, actual));\n    }\n}\n"}
{"id": 135776, "name": "Bitcoin_address validation", "source": "Translate Ruby to Python: \n\n\n\nrequire 'digest/sha2'\ndef convert g\n  i,e = '',[]\n  (0...g.length/2).each{|n| e[n] = g[n+=n]+g[n+1]; i+='H2'}\n  e.pack(i)\nend\nN = [0,1,2,3,4,5,6,7,8,nil,nil,nil,nil,nil,nil,nil,9,10,11,12,13,14,15,16,nil,17,18,19,20,21,nil,22,23,24,25,26,27,28,29,30,31,32,nil,nil,nil,nil,nil,nil,33,34,35,36,37,38,39,40,41,42,43,nil,44,45,46,47,48,49,50,51,52,53,54,55,56,57]\nA = '1AGNa15ZQXAZUgFiqJ2i7Z2DPU2J6hW62x'\ng = A.bytes.inject(0){|g,n| g*58+N[n-49]}.to_s(16) \nn = g.slice!(0..-9)\n(n.length...42).each{n.insert(0,'0')}\nputs \"I think the checksum should be \n", "target": "from hashlib import sha256\n\ndigits58 = '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz'\n\ndef decode_base58(bc, length):\n    n = 0\n    for char in bc:\n        n = n * 58 + digits58.index(char)\n    return n.to_bytes(length, 'big')\ndef check_bc(bc):\n    try:\n        bcbytes = decode_base58(bc, 25)\n        return bcbytes[-4:] == sha256(sha256(bcbytes[:-4]).digest()).digest()[:4]\n    except Exception:\n        return False\n\nprint(check_bc('1AGNa15ZQXAZUgFiqJ3i7Z2DPU2J6hW62i'))\nprint(check_bc(\"17NdbrSGoUotzeGCcMMCqnFkEvLymoou9j\"))\n"}
{"id": 135777, "name": "Bitcoin_address validation", "source": "Translate Ruby to Python: \n\n\n\nrequire 'digest/sha2'\ndef convert g\n  i,e = '',[]\n  (0...g.length/2).each{|n| e[n] = g[n+=n]+g[n+1]; i+='H2'}\n  e.pack(i)\nend\nN = [0,1,2,3,4,5,6,7,8,nil,nil,nil,nil,nil,nil,nil,9,10,11,12,13,14,15,16,nil,17,18,19,20,21,nil,22,23,24,25,26,27,28,29,30,31,32,nil,nil,nil,nil,nil,nil,33,34,35,36,37,38,39,40,41,42,43,nil,44,45,46,47,48,49,50,51,52,53,54,55,56,57]\nA = '1AGNa15ZQXAZUgFiqJ2i7Z2DPU2J6hW62x'\ng = A.bytes.inject(0){|g,n| g*58+N[n-49]}.to_s(16) \nn = g.slice!(0..-9)\n(n.length...42).each{n.insert(0,'0')}\nputs \"I think the checksum should be \n", "target": "from hashlib import sha256\n\ndigits58 = '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz'\n\ndef decode_base58(bc, length):\n    n = 0\n    for char in bc:\n        n = n * 58 + digits58.index(char)\n    return n.to_bytes(length, 'big')\ndef check_bc(bc):\n    try:\n        bcbytes = decode_base58(bc, 25)\n        return bcbytes[-4:] == sha256(sha256(bcbytes[:-4]).digest()).digest()[:4]\n    except Exception:\n        return False\n\nprint(check_bc('1AGNa15ZQXAZUgFiqJ3i7Z2DPU2J6hW62i'))\nprint(check_bc(\"17NdbrSGoUotzeGCcMMCqnFkEvLymoou9j\"))\n"}
{"id": 136022, "name": "Pernicious numbers", "source": "Translate Ruby to C#: require \"prime\"\n\nclass Integer\n \n  def popcount\n    to_s(2).count(\"1\")   \n  end\n \n  def pernicious?\n    popcount.prime?\n  end\n\nend\n\np 1.step.lazy.select(&:pernicious?).take(25).to_a\np ( 888888877..888888888).select(&:pernicious?)\n", "target": "using System;\nusing System.Linq;\n\nnamespace PerniciousNumbers\n{\n    class Program\n    {\n        public static int PopulationCount(long n)\n        {\n            int cnt = 0;\n            do\n            {\n                if ((n & 1) != 0) \n                {\n                    cnt++;\n                }\n            } while ((n >>= 1) > 0);\n\n            return cnt;\n        }\n\n         public static bool isPrime(int x)\n        {\n            if (x <= 2 || (x & 1) == 0)\n            {\n                return x == 2;\n            }\n\n            var limit = Math.Sqrt(x);\n            for (int i = 3; i <= limit; i += 2)\n            {\n                if (x % i == 0)\n                {\n                    return false;\n                }\n            }\n\n            return true;\n        }\n\n        private static IEnumerable<int> Pernicious(int start, int count, int take)\n        {\n            return Enumerable.Range(start, count).Where(n => isPrime(PopulationCount(n))).Take(take);\n        }\n\n        static void Main(string[] args)\n        {\n            foreach (var n in Pernicious(0, int.MaxValue, 25))\n            {\n                Console.Write(\"{0} \", n);\n            }\n\n            Console.WriteLine();\n\n            foreach (var n in Pernicious(888888877, 11, 11))\n            {\n                Console.Write(\"{0} \", n);\n            }\n\n            Console.ReadKey();\n        }\n    }\n}\n"}
{"id": 136024, "name": "Pernicious numbers", "source": "Translate Ruby to Python: require \"prime\"\n\nclass Integer\n \n  def popcount\n    to_s(2).count(\"1\")   \n  end\n \n  def pernicious?\n    popcount.prime?\n  end\n\nend\n\np 1.step.lazy.select(&:pernicious?).take(25).to_a\np ( 888888877..888888888).select(&:pernicious?)\n", "target": ">>> def popcount(n): return bin(n).count(\"1\")\n\n>>> primes = {2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61}\n>>> p, i = [], 0\n>>> while len(p) < 25:\n        if popcount(i) in primes: p.append(i)\n        i += 1\n\n        \n>>> p\n[3, 5, 6, 7, 9, 10, 11, 12, 13, 14, 17, 18, 19, 20, 21, 22, 24, 25, 26, 28, 31, 33, 34, 35, 36]\n>>> p, i = [], 888888877\n>>> while i <= 888888888:\n        if popcount(i) in primes: p.append(i)\n        i += 1\n\n        \n>>> p\n[888888877, 888888878, 888888880, 888888883, 888888885, 888888886]\n>>>\n"}
{"id": 136245, "name": "IBAN", "source": "Translate Ruby to C#: def valid_iban? iban\n  len = {\n    AL: 28, AD: 24, AT: 20, AZ: 28, BE: 16, BH: 22, BA: 20, BR: 29,\n    BG: 22, CR: 21, HR: 21, CY: 28, CZ: 24, DK: 18, DO: 28, EE: 20,\n    FO: 18, FI: 18, FR: 27, GE: 22, DE: 22, GI: 23, GR: 27, GL: 18,\n    GT: 28, HU: 28, IS: 26, IE: 22, IL: 23, IT: 27, KZ: 20, KW: 30,\n    LV: 21, LB: 28, LI: 21, LT: 20, LU: 20, MK: 19, MT: 31, MR: 27,\n    MU: 30, MC: 27, MD: 24, ME: 22, NL: 18, NO: 15, PK: 24, PS: 29,\n    PL: 28, PT: 25, RO: 24, SM: 27, SA: 24, RS: 22, SK: 24, SI: 19,\n    ES: 24, SE: 24, CH: 21, TN: 24, TR: 26, AE: 23, GB: 22, VG: 24\n  }\n\n  \n  iban.delete! \" \\t\"\n  return false unless iban =~ /^[\\dA-Z]+$/\n\n  \n  cc = iban[0, 2].to_sym\n  return false unless iban.size == len[cc]\n\n  \n  iban = iban[4..-1] + iban[0, 4]\n  iban.gsub!(/./) { |c| c.to_i(36) }\n\n  iban.to_i % 97 == 1\nend\n\np valid_iban? \"GB82 WEST 1234 5698 7654 32\" \np valid_iban? \"GB82 TEST 1234 5698 7654 32\" \n", "target": "    public class IbanValidator : IValidateTypes\n    {\n        public ValidationResult Validate(string value)\n        {\n            \n            if (string.IsNullOrEmpty(value))\n                return ValidationResult.ValueMissing;\n\n            if (value.Length < 2)\n                return ValidationResult.ValueTooSmall;\n\n            var countryCode = value.Substring(0, 2).ToUpper();\n\n            int lengthForCountryCode;\n\n            var countryCodeKnown = Lengths.TryGetValue(countryCode, out lengthForCountryCode);\n            if (!countryCodeKnown)\n            {\n                return ValidationResult.CountryCodeNotKnown;\n            }\n\n            \n            if (value.Length < lengthForCountryCode)\n                return ValidationResult.ValueTooSmall;\n\n            if (value.Length > lengthForCountryCode)\n                return ValidationResult.ValueTooBig;\n\n            value = value.ToUpper();\n            var newIban = value.Substring(4) + value.Substring(0, 4);\n\n            newIban = Regex.Replace(newIban, @\"\\D\", match => (match.Value[0] - 55).ToString());\n\n            var remainder = BigInteger.Parse(newIban) % 97;\n\n            if (remainder != 1)\n                return ValidationResult.ValueFailsModule97Check;\n\n            return ValidationResult.IsValid;\n        }\n\n        public enum ValidationResult\n        {\n            IsValid,\n            ValueMissing,\n            ValueTooSmall,\n            ValueTooBig,\n            ValueFailsModule97Check,\n            CountryCodeNotKnown\n        }\n\n        private static readonly IDictionary<string, int> Lengths = new Dictionary<string, int>\n        {\n            {\"AL\", 28},\n            {\"AD\", 24},\n            {\"AT\", 20},\n            {\"AZ\", 28},\n            {\"BE\", 16},\n            {\"BH\", 22},\n            {\"BA\", 20},\n            {\"BR\", 29},\n            {\"BG\", 22},\n            {\"CR\", 21},\n            {\"HR\", 21},\n            {\"CY\", 28},\n            {\"CZ\", 24},\n            {\"DK\", 18},\n            {\"DO\", 28},\n            {\"EE\", 20},\n            {\"FO\", 18},\n            {\"FI\", 18},\n            {\"FR\", 27},\n            {\"GE\", 22},\n            {\"DE\", 22},\n            {\"GI\", 23},\n            {\"GR\", 27},\n            {\"GL\", 18},\n            {\"GT\", 28},\n            {\"HU\", 28},\n            {\"IS\", 26},\n            {\"IE\", 22},\n            {\"IL\", 23},\n            {\"IT\", 27},\n            {\"KZ\", 20},\n            {\"KW\", 30},\n            {\"LV\", 21},\n            {\"LB\", 28},\n            {\"LI\", 21},\n            {\"LT\", 20},\n            {\"LU\", 20},\n            {\"MK\", 19},\n            {\"MT\", 31},\n            {\"MR\", 27},\n            {\"MU\", 30},\n            {\"MC\", 27},\n            {\"MD\", 24},\n            {\"ME\", 22},\n            {\"NL\", 18},\n            {\"NO\", 15},\n            {\"PK\", 24},\n            {\"PS\", 29},\n            {\"PL\", 28},\n            {\"PT\", 25},\n            {\"RO\", 24},\n            {\"SM\", 27},\n            {\"SA\", 24},\n            {\"RS\", 22},\n            {\"SK\", 24},\n            {\"SI\", 19},\n            {\"ES\", 24},\n            {\"SE\", 24},\n            {\"CH\", 21},\n            {\"TN\", 24},\n            {\"TR\", 26},\n            {\"AE\", 23},\n            {\"GB\", 22},\n            {\"VG\", 24}\n        };\n    }\n"}
{"id": 136247, "name": "IBAN", "source": "Translate Ruby to Java: def valid_iban? iban\n  len = {\n    AL: 28, AD: 24, AT: 20, AZ: 28, BE: 16, BH: 22, BA: 20, BR: 29,\n    BG: 22, CR: 21, HR: 21, CY: 28, CZ: 24, DK: 18, DO: 28, EE: 20,\n    FO: 18, FI: 18, FR: 27, GE: 22, DE: 22, GI: 23, GR: 27, GL: 18,\n    GT: 28, HU: 28, IS: 26, IE: 22, IL: 23, IT: 27, KZ: 20, KW: 30,\n    LV: 21, LB: 28, LI: 21, LT: 20, LU: 20, MK: 19, MT: 31, MR: 27,\n    MU: 30, MC: 27, MD: 24, ME: 22, NL: 18, NO: 15, PK: 24, PS: 29,\n    PL: 28, PT: 25, RO: 24, SM: 27, SA: 24, RS: 22, SK: 24, SI: 19,\n    ES: 24, SE: 24, CH: 21, TN: 24, TR: 26, AE: 23, GB: 22, VG: 24\n  }\n\n  \n  iban.delete! \" \\t\"\n  return false unless iban =~ /^[\\dA-Z]+$/\n\n  \n  cc = iban[0, 2].to_sym\n  return false unless iban.size == len[cc]\n\n  \n  iban = iban[4..-1] + iban[0, 4]\n  iban.gsub!(/./) { |c| c.to_i(36) }\n\n  iban.to_i % 97 == 1\nend\n\np valid_iban? \"GB82 WEST 1234 5698 7654 32\" \np valid_iban? \"GB82 TEST 1234 5698 7654 32\" \n", "target": "import java.math.BigInteger;\nimport java.util.*;\n\npublic class IBAN {\n    private static final String DEFSTRS = \"\"\n            + \"AL28 AD24 AT20 AZ28 BE16 BH22 BA20 BR29 BG22 \"\n            + \"HR21 CY28 CZ24 DK18 DO28 EE20 FO18 FI18 FR27 GE22 DE22 GI23 \"\n            + \"GL18 GT28 HU28 IS26 IE22 IL23 IT27 KZ20 KW30 LV21 LB28 LI21 \"\n            + \"LT20 LU20 MK19 MT31 MR27 MU30 MC27 MD24 ME22 NL18 NO15 PK24 \"\n            + \"PS29 PL28 PT25 RO24 SM27 SA24 RS22 SK24 SI19 ES24 SE24 CH21 \"\n            + \"TN24 TR26 AE23 GB22 VG24 GR27 CR21\";\n    private static final Map<String, Integer> DEFINITIONS = new HashMap<>();\n\n    static {\n        for (String definition : DEFSTRS.split(\" \"))\n            DEFINITIONS.put(definition.substring(0, 2), Integer.parseInt(definition.substring(2)));\n    }\n\n    public static void main(String[] args) {\n        String[] ibans = {\n                \"GB82 WEST 1234 5698 7654 32\",\n                \"GB82 TEST 1234 5698 7654 32\",\n                \"GB81 WEST 1234 5698 7654 32\",\n                \"SA03 8000 0000 6080 1016 7519\",\n                \"CH93 0076 2011 6238 5295 7\",\n                \"XX00 0000\",\n                \"\",\n                \"DE\",\n                \"DE13 \u00e4\u00f6\u00fc_ 1234 1234 1234 12\"};\n        for (String iban : ibans)\n            System.out.printf(\"%s is %s.%n\", iban, validateIBAN(iban) ? \"valid\" : \"not valid\");\n    }\n\n    static boolean validateIBAN(String iban) {\n        iban = iban.replaceAll(\"\\\\s\", \"\").toUpperCase(Locale.ROOT);\n\n        int len = iban.length();\n        if (len < 4 || !iban.matches(\"[0-9A-Z]+\") || DEFINITIONS.getOrDefault(iban.substring(0, 2), 0) != len)\n            return false;\n\n        iban = iban.substring(4) + iban.substring(0, 4);\n\n        StringBuilder sb = new StringBuilder();\n        for (int i = 0; i < len; i++)\n            sb.append(Character.digit(iban.charAt(i), 36));\n\n        BigInteger bigInt = new BigInteger(sb.toString());\n\n        return bigInt.mod(BigInteger.valueOf(97)).intValue() == 1;\n    }\n}\n"}
{"id": 136248, "name": "IBAN", "source": "Translate Ruby to Python: def valid_iban? iban\n  len = {\n    AL: 28, AD: 24, AT: 20, AZ: 28, BE: 16, BH: 22, BA: 20, BR: 29,\n    BG: 22, CR: 21, HR: 21, CY: 28, CZ: 24, DK: 18, DO: 28, EE: 20,\n    FO: 18, FI: 18, FR: 27, GE: 22, DE: 22, GI: 23, GR: 27, GL: 18,\n    GT: 28, HU: 28, IS: 26, IE: 22, IL: 23, IT: 27, KZ: 20, KW: 30,\n    LV: 21, LB: 28, LI: 21, LT: 20, LU: 20, MK: 19, MT: 31, MR: 27,\n    MU: 30, MC: 27, MD: 24, ME: 22, NL: 18, NO: 15, PK: 24, PS: 29,\n    PL: 28, PT: 25, RO: 24, SM: 27, SA: 24, RS: 22, SK: 24, SI: 19,\n    ES: 24, SE: 24, CH: 21, TN: 24, TR: 26, AE: 23, GB: 22, VG: 24\n  }\n\n  \n  iban.delete! \" \\t\"\n  return false unless iban =~ /^[\\dA-Z]+$/\n\n  \n  cc = iban[0, 2].to_sym\n  return false unless iban.size == len[cc]\n\n  \n  iban = iban[4..-1] + iban[0, 4]\n  iban.gsub!(/./) { |c| c.to_i(36) }\n\n  iban.to_i % 97 == 1\nend\n\np valid_iban? \"GB82 WEST 1234 5698 7654 32\" \np valid_iban? \"GB82 TEST 1234 5698 7654 32\" \n", "target": "import re\n\n_country2length = dict(\n    AL=28, AD=24, AT=20, AZ=28, BE=16, BH=22, BA=20, BR=29,\n    BG=22, CR=21, HR=21, CY=28, CZ=24, DK=18, DO=28, EE=20,\n    FO=18, FI=18, FR=27, GE=22, DE=22, GI=23, GR=27, GL=18,\n    GT=28, HU=28, IS=26, IE=22, IL=23, IT=27, KZ=20, KW=30,\n    LV=21, LB=28, LI=21, LT=20, LU=20, MK=19, MT=31, MR=27,\n    MU=30, MC=27, MD=24, ME=22, NL=18, NO=15, PK=24, PS=29,\n    PL=28, PT=25, RO=24, SM=27, SA=24, RS=22, SK=24, SI=19,\n    ES=24, SE=24, CH=21, TN=24, TR=26, AE=23, GB=22, VG=24 )\n\ndef valid_iban(iban):\n    \n    iban = iban.replace(' ','').replace('\\t','')\n    if not re.match(r'^[\\dA-Z]+$', iban): \n        return False\n    \n    if len(iban) != _country2length[iban[:2]]:\n        return False\n    \n    iban = iban[4:] + iban[:4]\n    digits = int(''.join(str(int(ch, 36)) for ch in iban)) \n    return digits % 97 == 1\n\nif __name__ == '__main__':\n    for account in [\"GB82 WEST 1234 5698 7654 32\", \"GB82 TEST 1234 5698 7654 32\"]:\n        print('%s validation is: %s' % (account, valid_iban(account)))\n"}
{"id": 136430, "name": "Grayscale image", "source": "Translate Ruby to C#: class RGBColour\n  def to_grayscale\n    luminosity = (0.2126*@red + 0.7152*@green + 0.0722*@blue).to_i\n    self.class.new(luminosity, luminosity, luminosity)\n  end\nend\n\nclass Pixmap\n  def to_grayscale\n    gray = self.class.new(@width, @height)\n    @width.times do |x|\n      @height.times do |y|\n        gray[x,y] = self[x,y].to_grayscale\n      end\n    end\n    gray\n  end\nend\n", "target": "Bitmap tImage = new Bitmap(\"spectrum.bmp\");\n\nfor (int x = 0; x < tImage.Width; x++)\n{\n\tfor (int y = 0; y < tImage.Height; y++)\n\t{\n\t\tColor tCol = tImage.GetPixel(x, y);\n\n\t\t\n\t\tdouble L = 0.2126 * tCol.R + 0.7152 * tCol.G + 0.0722 * tCol.B;\n\t\ttImage.SetPixel(x, y, Color.FromArgb(Convert.ToInt32(L), Convert.ToInt32(L), Convert.ToInt32(L)));\n\t}\n}\n\n\ntImage.Save(\"spectrum2.bmp\");\n"}
{"id": 136431, "name": "Grayscale image", "source": "Translate Ruby to Java: class RGBColour\n  def to_grayscale\n    luminosity = (0.2126*@red + 0.7152*@green + 0.0722*@blue).to_i\n    self.class.new(luminosity, luminosity, luminosity)\n  end\nend\n\nclass Pixmap\n  def to_grayscale\n    gray = self.class.new(@width, @height)\n    @width.times do |x|\n      @height.times do |y|\n        gray[x,y] = self[x,y].to_grayscale\n      end\n    end\n    gray\n  end\nend\n", "target": "void convertToGrayscale(final BufferedImage image){\n    for(int i=0; i<image.getWidth(); i++){\n        for(int j=0; j<image.getHeight(); j++){\n            int color = image.getRGB(i,j);\n\n            int alpha = (color >> 24) & 255;\n            int red = (color >> 16) & 255;\n            int green = (color >> 8) & 255;\n            int blue = (color) & 255;\n\n            final int lum = (int)(0.2126 * red + 0.7152 * green + 0.0722 * blue);\n\n            alpha = (alpha << 24);\n            red = (lum << 16);\n            green = (lum << 8);\n            blue = lum;\n\n            color = alpha + red + green + blue;\n\n            image.setRGB(i,j,color);\n        }\n    }\n}\n"}
{"id": 136432, "name": "Grayscale image", "source": "Translate Ruby to Python: class RGBColour\n  def to_grayscale\n    luminosity = (0.2126*@red + 0.7152*@green + 0.0722*@blue).to_i\n    self.class.new(luminosity, luminosity, luminosity)\n  end\nend\n\nclass Pixmap\n  def to_grayscale\n    gray = self.class.new(@width, @height)\n    @width.times do |x|\n      @height.times do |y|\n        gray[x,y] = self[x,y].to_grayscale\n      end\n    end\n    gray\n  end\nend\n", "target": "\nimport io\nppmfileout = io.StringIO('')\n\ndef togreyscale(self):\n    for h in range(self.height):\n        for w in range(self.width):\n            r, g, b = self.get(w, h)\n            l = int(0.2126 * r + 0.7152 * g + 0.0722 * b)\n            self.set(w, h, Colour(l, l, l))\n\nBitmap.togreyscale = togreyscale    \n\n\n\nbitmap = Bitmap(4, 4, white)\nbitmap.fillrect(1, 0, 1, 2, Colour(127, 0, 63))\nbitmap.set(3, 3, Colour(0, 127, 31))\nprint('Colour:')\n\nbitmap.writeppmp3(ppmfileout)\nprint(ppmfileout.getvalue())\nprint('Grey:')\nbitmap.togreyscale()\nppmfileout = io.StringIO('')\nbitmap.writeppmp3(ppmfileout)\nprint(ppmfileout.getvalue())\n\n\n\n"}
{"id": 136645, "name": "Literals_String", "source": "Translate Ruby to C#: 'single quotes with \\'embedded quote\\' and \\\\backslash'\n%q(not interpolating with (nested) parentheses\nand newline)\n", "target": "string path = @\"C:\\Windows\\System32\";\nstring multiline = @\"Line 1.\nLine 2.\nLine 3.\";\n"}
{"id": 136647, "name": "Literals_String", "source": "Translate Ruby to Java: 'single quotes with \\'embedded quote\\' and \\\\backslash'\n%q(not interpolating with (nested) parentheses\nand newline)\n", "target": "  char a = 'a';  \n  String b = \"abc\";  \n  char doubleQuote = '\"';  \n  char singleQuote = '\\'';  \n  String singleQuotes = \"''\";  \n  String doubleQuotes = \"\\\"\\\"\";  \n"}
{"id": 136648, "name": "Literals_String", "source": "Translate Ruby to Python: 'single quotes with \\'embedded quote\\' and \\\\backslash'\n%q(not interpolating with (nested) parentheses\nand newline)\n", "target": "'c' == \"c\" \n'text' == \"text\"\n' \" '\n\" ' \"\n'\\x20' == ' '\nu'unicode string'\nu'\\u05d0' \n"}
{"id": 136945, "name": "Extend your language", "source": "Translate Ruby to C#: \nclass HopelesslyEgocentric\n  def method_missing(what, *args) self end\nend\n\ndef if2(cond1, cond2)\n  if cond1 and cond2\n    yield\n    HopelesslyEgocentric.new\n  elsif cond1\n    Class.new(HopelesslyEgocentric) do\n      def else1; yield; HopelesslyEgocentric.new end\n    end.new\n  elsif cond2\n    Class.new(HopelesslyEgocentric) do\n      def else2; yield; HopelesslyEgocentric.new end\n    end.new\n  else\n    Class.new(HopelesslyEgocentric) do\n      def neither; yield end\n    end.new\n  end\nend\n", "target": "using System;\nusing System.Reflection;\n\nnamespace Extend_your_language\n{\n\t\n\n\tclass Program\n\t{\n\t\t\n\t\tpublic static void Main(string[] args)\n\t\t{\n\t\t\tConsole.WriteLine();\n\t\t\tConsole.WriteLine(\"Hello World!\");\n\t\t\tConsole.WriteLine();\n\t\t\t\n\t\t\tint x = 0;\n\t\t\tint y = 0;\n\t\t\t\n\t\t\tfor(x=0;x<2;x++)\n\t\t\t{\n\t\t\t\tfor(y=0;y<2;y++)\n\t\t\t\t{\n\t\t\t\t\t\n\t\t\t\t\tCONDITIONS( (x==0) , (y==0) ).\n\t\t\t\t\t\tIF2  (\"METHOD1\").\n\t\t\t\t\t\tELSE1(\"METHOD2\").\n\t\t\t\t\t\tELSE2(\"METHOD3\").\n\t\t\t\t\t\tELSE (\"METHOD4\");\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tConsole.WriteLine();\n\t\t\tConsole.Write(\"Press any key to continue . . . \");\n\t\t\tConsole.ReadKey(true);\n\t\t}\n\t\t\n\t\t\n\t\t\n\t\t\n\t\tpublic static void METHOD1()\n\t\t{\n\t\t\tConsole.WriteLine(\"METHOD 1 executed - both are true\");\n\t\t}\n\t\t\n\t\tpublic static void METHOD2()\n\t\t{\n\t\t\tConsole.WriteLine(\"METHOD 2 executed - first is true\");\n\t\t}\n\t\t\n\t\tpublic static void METHOD3()\n\t\t{\n\t\t\tConsole.WriteLine(\"METHOD 3 executed - second is true\");\n\t\t}\n\t\t\n\t\tpublic static void METHOD4()\n\t\t{\n\t\t\tConsole.WriteLine(\"METHOD 4 executed - both are false\");\n\t\t}\n\t\t\n\t\t\n\t\tstatic int CONDITIONS(bool condition1, bool condition2)\n\t\t{\n\t\t\tint c = 0;\n\t\t\tif(condition1 && condition2)\n\t\t\t\tc = 0;\n\t\t\telse if(condition1)\n\t\t\t\tc = 1;\n\t\t\telse if(condition2)\n\t\t\t\tc = 2;\n\t\t\telse\n\t\t\t\tc = 3;\n\t\t\t\n\t\t\treturn c;\n\t\t}\n\t}\n\t\n\t\n\tpublic static class ExtensionMethods\n\t{\n\n\t\tpublic static int IF2(this int value, string method)\n\t\t{\n\t\t\tif(value == 0)\n\t\t\t{\n\t\t\t\tMethodInfo m = typeof(Program).GetMethod(method);\n\t\t\t\tm.Invoke(null,null);\n\t\t\t}\n\t\t\t\n\t\t\treturn value;\n\t\t}\n\t\t\n\t\tpublic static int ELSE1(this int value, string method)\n\t\t{\n\t\t\tif(value == 1)\n\t\t\t{\n\t\t\t\tMethodInfo m = typeof(Program).GetMethod(method);\n\t\t\t\tm.Invoke(null,null);\n\t\t\t}\n\t\t\t\n\t\t\treturn value;\n\t\t}\n\t\t\n\t\tpublic static int ELSE2(this int value, string method)\n\t\t{\n\t\t\tif(value == 2)\n\t\t\t{\n\t\t\t\tMethodInfo m = typeof(Program).GetMethod(method);\n\t\t\t\tm.Invoke(null,null);\n\t\t\t}\n\t\t\t\n\t\t\treturn value;\n\t\t}\n\t\t\n\t\tpublic static void ELSE(this int value, string method)\n\t\t{\n\t\t\tif(value == 3)\n\t\t\t{\n\t\t\t\tMethodInfo m = typeof(Program).GetMethod(method);\n\t\t\t\tm.Invoke(null,null);\n\t\t\t}\n\t\t}\n\t\t\n\t}\n}\n"}
{"id": 136946, "name": "Extend your language", "source": "Translate Ruby to C#: \nclass HopelesslyEgocentric\n  def method_missing(what, *args) self end\nend\n\ndef if2(cond1, cond2)\n  if cond1 and cond2\n    yield\n    HopelesslyEgocentric.new\n  elsif cond1\n    Class.new(HopelesslyEgocentric) do\n      def else1; yield; HopelesslyEgocentric.new end\n    end.new\n  elsif cond2\n    Class.new(HopelesslyEgocentric) do\n      def else2; yield; HopelesslyEgocentric.new end\n    end.new\n  else\n    Class.new(HopelesslyEgocentric) do\n      def neither; yield end\n    end.new\n  end\nend\n", "target": "using System;\nusing System.Reflection;\n\nnamespace Extend_your_language\n{\n\t\n\n\tclass Program\n\t{\n\t\t\n\t\tpublic static void Main(string[] args)\n\t\t{\n\t\t\tConsole.WriteLine();\n\t\t\tConsole.WriteLine(\"Hello World!\");\n\t\t\tConsole.WriteLine();\n\t\t\t\n\t\t\tint x = 0;\n\t\t\tint y = 0;\n\t\t\t\n\t\t\tfor(x=0;x<2;x++)\n\t\t\t{\n\t\t\t\tfor(y=0;y<2;y++)\n\t\t\t\t{\n\t\t\t\t\t\n\t\t\t\t\tCONDITIONS( (x==0) , (y==0) ).\n\t\t\t\t\t\tIF2  (\"METHOD1\").\n\t\t\t\t\t\tELSE1(\"METHOD2\").\n\t\t\t\t\t\tELSE2(\"METHOD3\").\n\t\t\t\t\t\tELSE (\"METHOD4\");\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tConsole.WriteLine();\n\t\t\tConsole.Write(\"Press any key to continue . . . \");\n\t\t\tConsole.ReadKey(true);\n\t\t}\n\t\t\n\t\t\n\t\t\n\t\t\n\t\tpublic static void METHOD1()\n\t\t{\n\t\t\tConsole.WriteLine(\"METHOD 1 executed - both are true\");\n\t\t}\n\t\t\n\t\tpublic static void METHOD2()\n\t\t{\n\t\t\tConsole.WriteLine(\"METHOD 2 executed - first is true\");\n\t\t}\n\t\t\n\t\tpublic static void METHOD3()\n\t\t{\n\t\t\tConsole.WriteLine(\"METHOD 3 executed - second is true\");\n\t\t}\n\t\t\n\t\tpublic static void METHOD4()\n\t\t{\n\t\t\tConsole.WriteLine(\"METHOD 4 executed - both are false\");\n\t\t}\n\t\t\n\t\t\n\t\tstatic int CONDITIONS(bool condition1, bool condition2)\n\t\t{\n\t\t\tint c = 0;\n\t\t\tif(condition1 && condition2)\n\t\t\t\tc = 0;\n\t\t\telse if(condition1)\n\t\t\t\tc = 1;\n\t\t\telse if(condition2)\n\t\t\t\tc = 2;\n\t\t\telse\n\t\t\t\tc = 3;\n\t\t\t\n\t\t\treturn c;\n\t\t}\n\t}\n\t\n\t\n\tpublic static class ExtensionMethods\n\t{\n\n\t\tpublic static int IF2(this int value, string method)\n\t\t{\n\t\t\tif(value == 0)\n\t\t\t{\n\t\t\t\tMethodInfo m = typeof(Program).GetMethod(method);\n\t\t\t\tm.Invoke(null,null);\n\t\t\t}\n\t\t\t\n\t\t\treturn value;\n\t\t}\n\t\t\n\t\tpublic static int ELSE1(this int value, string method)\n\t\t{\n\t\t\tif(value == 1)\n\t\t\t{\n\t\t\t\tMethodInfo m = typeof(Program).GetMethod(method);\n\t\t\t\tm.Invoke(null,null);\n\t\t\t}\n\t\t\t\n\t\t\treturn value;\n\t\t}\n\t\t\n\t\tpublic static int ELSE2(this int value, string method)\n\t\t{\n\t\t\tif(value == 2)\n\t\t\t{\n\t\t\t\tMethodInfo m = typeof(Program).GetMethod(method);\n\t\t\t\tm.Invoke(null,null);\n\t\t\t}\n\t\t\t\n\t\t\treturn value;\n\t\t}\n\t\t\n\t\tpublic static void ELSE(this int value, string method)\n\t\t{\n\t\t\tif(value == 3)\n\t\t\t{\n\t\t\t\tMethodInfo m = typeof(Program).GetMethod(method);\n\t\t\t\tm.Invoke(null,null);\n\t\t\t}\n\t\t}\n\t\t\n\t}\n}\n"}
{"id": 136947, "name": "Extend your language", "source": "Translate Ruby to Java: \nclass HopelesslyEgocentric\n  def method_missing(what, *args) self end\nend\n\ndef if2(cond1, cond2)\n  if cond1 and cond2\n    yield\n    HopelesslyEgocentric.new\n  elsif cond1\n    Class.new(HopelesslyEgocentric) do\n      def else1; yield; HopelesslyEgocentric.new end\n    end.new\n  elsif cond2\n    Class.new(HopelesslyEgocentric) do\n      def else2; yield; HopelesslyEgocentric.new end\n    end.new\n  else\n    Class.new(HopelesslyEgocentric) do\n      def neither; yield end\n    end.new\n  end\nend\n", "target": "public class If2 {\n\n    public static void if2(boolean firstCondition, boolean secondCondition,\n                           Runnable bothTrue, Runnable firstTrue, Runnable secondTrue, Runnable noneTrue) {\n        if (firstCondition)\n            if (secondCondition)\n                bothTrue.run();\n            else firstTrue.run();\n        else if (secondCondition)\n            secondTrue.run();\n        else noneTrue.run();\n    }\n}\n"}
{"id": 136948, "name": "Extend your language", "source": "Translate Ruby to Java: \nclass HopelesslyEgocentric\n  def method_missing(what, *args) self end\nend\n\ndef if2(cond1, cond2)\n  if cond1 and cond2\n    yield\n    HopelesslyEgocentric.new\n  elsif cond1\n    Class.new(HopelesslyEgocentric) do\n      def else1; yield; HopelesslyEgocentric.new end\n    end.new\n  elsif cond2\n    Class.new(HopelesslyEgocentric) do\n      def else2; yield; HopelesslyEgocentric.new end\n    end.new\n  else\n    Class.new(HopelesslyEgocentric) do\n      def neither; yield end\n    end.new\n  end\nend\n", "target": "public class If2 {\n\n    public static void if2(boolean firstCondition, boolean secondCondition,\n                           Runnable bothTrue, Runnable firstTrue, Runnable secondTrue, Runnable noneTrue) {\n        if (firstCondition)\n            if (secondCondition)\n                bothTrue.run();\n            else firstTrue.run();\n        else if (secondCondition)\n            secondTrue.run();\n        else noneTrue.run();\n    }\n}\n"}
{"id": 136949, "name": "Extend your language", "source": "Translate Ruby to Python: \nclass HopelesslyEgocentric\n  def method_missing(what, *args) self end\nend\n\ndef if2(cond1, cond2)\n  if cond1 and cond2\n    yield\n    HopelesslyEgocentric.new\n  elsif cond1\n    Class.new(HopelesslyEgocentric) do\n      def else1; yield; HopelesslyEgocentric.new end\n    end.new\n  elsif cond2\n    Class.new(HopelesslyEgocentric) do\n      def else2; yield; HopelesslyEgocentric.new end\n    end.new\n  else\n    Class.new(HopelesslyEgocentric) do\n      def neither; yield end\n    end.new\n  end\nend\n", "target": "a, b = 1, 0\n\nif (c1 := a == 1) and (c2 := b == 3):\n  print('a = 1 and b = 3')\nelif c1:\n  print('a = 1 and b <> 3')\nelif c2:\n  print('a <> 1 and b = 3')\nelse:\n  print('a <> 1 and b <> 3')\n"}
{"id": 136950, "name": "Extend your language", "source": "Translate Ruby to Python: \nclass HopelesslyEgocentric\n  def method_missing(what, *args) self end\nend\n\ndef if2(cond1, cond2)\n  if cond1 and cond2\n    yield\n    HopelesslyEgocentric.new\n  elsif cond1\n    Class.new(HopelesslyEgocentric) do\n      def else1; yield; HopelesslyEgocentric.new end\n    end.new\n  elsif cond2\n    Class.new(HopelesslyEgocentric) do\n      def else2; yield; HopelesslyEgocentric.new end\n    end.new\n  else\n    Class.new(HopelesslyEgocentric) do\n      def neither; yield end\n    end.new\n  end\nend\n", "target": "a, b = 1, 0\n\nif (c1 := a == 1) and (c2 := b == 3):\n  print('a = 1 and b = 3')\nelif c1:\n  print('a = 1 and b <> 3')\nelif c2:\n  print('a <> 1 and b = 3')\nelse:\n  print('a <> 1 and b <> 3')\n"}
{"id": 137098, "name": "Compare length of two strings", "source": "Translate Ruby to C#: a, b = \"Given two strings\", \"of different length\"\n[a,b].sort_by{|s| - s.size }.each{|s| puts s + \" (size: \n\nlist = [\"abcd\",\"123456789\",\"abcdef\",\"1234567\"]\nputs list.sort_by{|s|- s.size}\n", "target": "using System;\nusing System.Collections.Generic;\n\nnamespace example\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            var strings = new string[] { \"abcd\", \"123456789\", \"abcdef\", \"1234567\" };\n            compareAndReportStringsLength(strings);\n        }\n\n        private static void compareAndReportStringsLength(string[] strings)\n        {\n            if (strings.Length > 0)\n            {\n                char Q = '\"';\n                string hasLength = \" has length \";\n                string predicateMax = \" and is the longest string\";\n                string predicateMin = \" and is the shortest string\";\n                string predicateAve = \" and is neither the longest nor the shortest string\";\n                string predicate;\n\n                (int, int)[] li = new (int, int)[strings.Length];\n                for (int i = 0; i < strings.Length; i++)\n                    li[i] = (strings[i].Length, i);\n                Array.Sort(li, ((int, int) a, (int, int) b) => b.Item1 - a.Item1);\n                int maxLength = li[0].Item1;\n                int minLength = li[strings.Length - 1].Item1;\n\n                for (int i = 0; i < strings.Length; i++)\n                {\n                    int length = li[i].Item1;\n                    string str = strings[li[i].Item2];\n                    if (length == maxLength)\n                        predicate = predicateMax;\n                    else if (length == minLength)\n                        predicate = predicateMin;\n                    else\n                        predicate = predicateAve;\n                    Console.WriteLine(Q + str + Q + hasLength + length + predicate);\n                }\n            }\n        }\n\n    }\n}\n"}
{"id": 137100, "name": "Compare length of two strings", "source": "Translate Ruby to Java: a, b = \"Given two strings\", \"of different length\"\n[a,b].sort_by{|s| - s.size }.each{|s| puts s + \" (size: \n\nlist = [\"abcd\",\"123456789\",\"abcdef\",\"1234567\"]\nputs list.sort_by{|s|- s.size}\n", "target": "package stringlensort;\n\nimport java.io.PrintStream;\nimport java.util.Arrays;\nimport java.util.Comparator;\n\npublic class ReportStringLengths {\n\n    public static void main(String[] args) {\n        String[] list = {\"abcd\", \"123456789\", \"abcdef\", \"1234567\"};\n        String[] strings = args.length > 0 ? args : list;\n\n        compareAndReportStringsLength(strings);\n    }\n\n        \n    public static void compareAndReportStringsLength(String[] strings) {\n        compareAndReportStringsLength(strings, System.out);\n    }\n\n    \n    public static void compareAndReportStringsLength(String[] strings, PrintStream stream) {\n        if (strings.length > 0) {\n            strings = strings.clone();\n            final String QUOTE = \"\\\"\";\n            Arrays.sort(strings, Comparator.comparing(String::length));\n            int min = strings[0].length();\n            int max = strings[strings.length - 1].length();\n            for (int i = strings.length - 1; i >= 0; i--) {\n                int length = strings[i].length();\n                String predicate;\n                if (length == max) {\n                    predicate = \"is the longest string\";\n                } else if (length == min) {\n                    predicate = \"is the shortest string\";\n                } else {\n                    predicate = \"is neither the longest nor the shortest string\";\n                }\n                \n                stream.println(QUOTE + strings[i] + QUOTE + \" has length \" + length\n                        + \" and \" + predicate);\n            }\n        }\n    }\n}\n"}
{"id": 137101, "name": "Compare length of two strings", "source": "Translate Ruby to Python: a, b = \"Given two strings\", \"of different length\"\n[a,b].sort_by{|s| - s.size }.each{|s| puts s + \" (size: \n\nlist = [\"abcd\",\"123456789\",\"abcdef\",\"1234567\"]\nputs list.sort_by{|s|- s.size}\n", "target": "A = 'I am string'\nB = 'I am string too'\n\nif len(A) > len(B):\n    print('\"' + A + '\"', 'has length', len(A), 'and is the longest of the two strings')\n    print('\"' + B + '\"', 'has length', len(B), 'and is the shortest of the two strings')\nelif len(A) < len(B):\n    print('\"' + B + '\"', 'has length', len(B), 'and is the longest of the two strings')\n    print('\"' + A + '\"', 'has length', len(A), 'and is the shortest of the two strings')\nelse:\n    print('\"' + A + '\"', 'has length', len(A), 'and it is as long as the second string')\n    print('\"' + B + '\"', 'has length', len(B), 'and it is as long as the second string')\n"}
{"id": 137335, "name": "Zig-zag matrix", "source": "Translate Ruby to C#: def zigzag(n)\n  (seq=(0...n).to_a).product(seq)\n    .sort_by {|x,y| [x+y, (x+y).even? ? y : -y]}\n    .map_with_index{|v, i| {v, i}}.sort.map(&.last).each_slice(n).to_a\nend\n \ndef print_matrix(m)\n  format = \"%\n  m.each {|row| puts format % row}\nend\n \nprint_matrix zigzag(5)\n", "target": "public static int[,] ZigZag(int n)\n{\n    int[,] result = new int[n, n];\n    int i = 0, j = 0;\n    int d = -1; \n    int start = 0, end = n * n - 1;\n    do\n    {\n        result[i, j] = start++;\n        result[n - i - 1, n - j - 1] = end--;\n\n        i += d; j -= d;\n        if (i < 0)\n        {\n            i++; d = -d; \n        }\n        else if (j < 0)\n        {\n            j++; d = -d; \n        }\n    } while (start < end);\n    if (start == end)\n        result[i, j] = start;\n    return result;\n}\n"}
{"id": 137337, "name": "Zig-zag matrix", "source": "Translate Ruby to Java: def zigzag(n)\n  (seq=(0...n).to_a).product(seq)\n    .sort_by {|x,y| [x+y, (x+y).even? ? y : -y]}\n    .map_with_index{|v, i| {v, i}}.sort.map(&.last).each_slice(n).to_a\nend\n \ndef print_matrix(m)\n  format = \"%\n  m.each {|row| puts format % row}\nend\n \nprint_matrix zigzag(5)\n", "target": "public static int[][] Zig_Zag(final int size)\n{\n int[][] data = new int[size][size];\n int i = 1;\n int j = 1;\n for (int element = 0; element < size * size; element++)\n {\n  data[i - 1][j - 1] = element;\n  if ((i + j) % 2 == 0)\n  {\n   \n   if (j < size)\n    j++;\n   else\n    i+= 2;\n   if (i > 1)\n    i--;\n  }\n  else\n  {\n   \n   if (i < size)\n    i++;\n   else\n    j+= 2;\n   if (j > 1)\n    j--;\n  }\n }\n return data;\n}\n"}
{"id": 137338, "name": "Zig-zag matrix", "source": "Translate Ruby to Python: def zigzag(n)\n  (seq=(0...n).to_a).product(seq)\n    .sort_by {|x,y| [x+y, (x+y).even? ? y : -y]}\n    .map_with_index{|v, i| {v, i}}.sort.map(&.last).each_slice(n).to_a\nend\n \ndef print_matrix(m)\n  format = \"%\n  m.each {|row| puts format % row}\nend\n \nprint_matrix zigzag(5)\n", "target": "def zigzag(n):\n    \n    def compare(xy):\n        x, y = xy\n        return (x + y, -y if (x + y) % 2 else y)\n    xs = range(n)\n    return {index: n for n, index in enumerate(sorted(\n        ((x, y) for x in xs for y in xs),\n        key=compare\n    ))}\n\n\ndef printzz(myarray):\n    \n    n = int(len(myarray) ** 0.5 + 0.5)\n    xs = range(n)\n    print('\\n'.join(\n        [''.join(\"%3i\" % myarray[(x, y)] for x in xs) for y in xs]\n    ))\n\n\nprintzz(zigzag(6))\n"}
{"id": 137443, "name": "Add a variable to a class instance at runtime", "source": "Translate Ruby to C#: class Empty\nend\n\ne = Empty.new\nclass << e\n  attr_accessor :foo\nend\ne.foo = 1\nputs e.foo  \n\nf = Empty.new\nf.foo = 1   \n", "target": "\n\n\n\n\n\n\n\nusing System;\nusing System.Dynamic;\n\nnamespace DynamicClassVariable\n{\n    internal static class Program\n    {\n        #region Static Members\n\n        private static void Main()\n        {\n            \n            \n            dynamic sampleObj = new ExpandoObject();\n            \n            sampleObj.bar = 1;\n            Console.WriteLine( \"sampleObj.bar = {0}\", sampleObj.bar );\n\n            \n            \n            \n            \n            Console.WriteLine( \"< Press any key >\" );\n            Console.ReadKey();\n        }\n\n        #endregion\n    }\n}\n"}
{"id": 137444, "name": "Add a variable to a class instance at runtime", "source": "Translate Ruby to Python: class Empty\nend\n\ne = Empty.new\nclass << e\n  attr_accessor :foo\nend\ne.foo = 1\nputs e.foo  \n\nf = Empty.new\nf.foo = 1   \n", "target": "class empty(object):\n    pass\ne = empty()\n"}
{"id": 137825, "name": "JSON", "source": "Translate Ruby to C#: require \"json_mapping\"\n\nclass Foo\n  JSON.mapping(\n    num: Int64,\n    array: Array(String),\n  )\nend\n\ndef json\n  foo = Foo.from_json(%({\"num\": 1, \"array\": [\"a\", \"b\"]}))\n  puts(\"\n  puts(foo.to_json)\nend\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Web.Script.Serialization;\n\nclass Program\n{\n    static void Main()\n    {\n        var people = new Dictionary<string, object> {{\"1\", \"John\"}, {\"2\", \"Susan\"}};\n        var serializer = new JavaScriptSerializer();\n        \n        var json = serializer.Serialize(people);\n        Console.WriteLine(json);\n\n        var deserialized = serializer.Deserialize<Dictionary<string, object>>(json);\n        Console.WriteLine(deserialized[\"2\"]);\n\n        var jsonObject = serializer.DeserializeObject(@\"{ \"\"foo\"\": 1, \"\"bar\"\": [10, \"\"apples\"\"] }\");\n        var data = jsonObject as Dictionary<string, object>;\n        var array = data[\"bar\"] as object[];\n        Console.WriteLine(array[1]);\n    }\n}\n"}
{"id": 137826, "name": "JSON", "source": "Translate Ruby to C#: require \"json_mapping\"\n\nclass Foo\n  JSON.mapping(\n    num: Int64,\n    array: Array(String),\n  )\nend\n\ndef json\n  foo = Foo.from_json(%({\"num\": 1, \"array\": [\"a\", \"b\"]}))\n  puts(\"\n  puts(foo.to_json)\nend\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Web.Script.Serialization;\n\nclass Program\n{\n    static void Main()\n    {\n        var people = new Dictionary<string, object> {{\"1\", \"John\"}, {\"2\", \"Susan\"}};\n        var serializer = new JavaScriptSerializer();\n        \n        var json = serializer.Serialize(people);\n        Console.WriteLine(json);\n\n        var deserialized = serializer.Deserialize<Dictionary<string, object>>(json);\n        Console.WriteLine(deserialized[\"2\"]);\n\n        var jsonObject = serializer.DeserializeObject(@\"{ \"\"foo\"\": 1, \"\"bar\"\": [10, \"\"apples\"\"] }\");\n        var data = jsonObject as Dictionary<string, object>;\n        var array = data[\"bar\"] as object[];\n        Console.WriteLine(array[1]);\n    }\n}\n"}
{"id": 137829, "name": "JSON", "source": "Translate Ruby to Java: require \"json_mapping\"\n\nclass Foo\n  JSON.mapping(\n    num: Int64,\n    array: Array(String),\n  )\nend\n\ndef json\n  foo = Foo.from_json(%({\"num\": 1, \"array\": [\"a\", \"b\"]}))\n  puts(\"\n  puts(foo.to_json)\nend\n", "target": "\n\n\n\ngrammar JSON ;\n@members {\nString Indent = \"\";\n}\nNumber\t:\t(('0')|('-'? ('1'..'9') ('0'..'9')*)) ('.' ('0'..'9')+)? (('e'|'E') ('+'|'-')? ('0'..'9')+)?;\nWS\t:\t(' ' | '\\t' | '\\r' |'\\n') {skip();};\nTz\t:\t' ' .. '!' | '#' .. '[' | ']' .. '~';\nControl\t:\t'\\\\' ('\"'|'\\\\'|'/'|'b'|'f'|'n'|'r'|'t'|UCode);\nUCode\t:\t'u' ('0'..'9'|'a'..'f'|'A'..'F') ('0'..'9'|'a'..'f'|'A'..'F') ('0'..'9'|'a'..'f'|'A'..'F') ('0'..'9'|'a'..'f'|'A'..'F');\nKeyword\t:\t'true' | 'false' | 'null';\nString\t:\t'\"' (Control? Tz)* '\"';\nobject\t:       '{' {System.out.println(Indent + \"{Object}\"); Indent += \"    \";} (pair (',' pair*)*)? '}' {Indent = Indent.substring(4);};\npair\t:\te = String {System.out.println(Indent + \"{Property}\\t\" + $e.text);} ':' value;\nvalue\t:\tNumber             {System.out.println(Indent + \"{Number}  \\t\" + $Number.text);}\n\t|\tobject\n\t|\tString             {System.out.println(Indent + \"{String}  \\t\" + $String.text);}\n\t|\tKeyword            {System.out.println(Indent + \"{Keyword} \\t\" + $Keyword.text);}\n\t|\tarray;\narray\t:\t'[' {System.out.println(Indent + \"Array\"); Indent += \"    \";} (value (',' value)*)? ']' {Indent = Indent.substring(4);};\n"}
{"id": 137830, "name": "JSON", "source": "Translate Ruby to Java: require \"json_mapping\"\n\nclass Foo\n  JSON.mapping(\n    num: Int64,\n    array: Array(String),\n  )\nend\n\ndef json\n  foo = Foo.from_json(%({\"num\": 1, \"array\": [\"a\", \"b\"]}))\n  puts(\"\n  puts(foo.to_json)\nend\n", "target": "\n\n\n\ngrammar JSON ;\n@members {\nString Indent = \"\";\n}\nNumber\t:\t(('0')|('-'? ('1'..'9') ('0'..'9')*)) ('.' ('0'..'9')+)? (('e'|'E') ('+'|'-')? ('0'..'9')+)?;\nWS\t:\t(' ' | '\\t' | '\\r' |'\\n') {skip();};\nTz\t:\t' ' .. '!' | '#' .. '[' | ']' .. '~';\nControl\t:\t'\\\\' ('\"'|'\\\\'|'/'|'b'|'f'|'n'|'r'|'t'|UCode);\nUCode\t:\t'u' ('0'..'9'|'a'..'f'|'A'..'F') ('0'..'9'|'a'..'f'|'A'..'F') ('0'..'9'|'a'..'f'|'A'..'F') ('0'..'9'|'a'..'f'|'A'..'F');\nKeyword\t:\t'true' | 'false' | 'null';\nString\t:\t'\"' (Control? Tz)* '\"';\nobject\t:       '{' {System.out.println(Indent + \"{Object}\"); Indent += \"    \";} (pair (',' pair*)*)? '}' {Indent = Indent.substring(4);};\npair\t:\te = String {System.out.println(Indent + \"{Property}\\t\" + $e.text);} ':' value;\nvalue\t:\tNumber             {System.out.println(Indent + \"{Number}  \\t\" + $Number.text);}\n\t|\tobject\n\t|\tString             {System.out.println(Indent + \"{String}  \\t\" + $String.text);}\n\t|\tKeyword            {System.out.println(Indent + \"{Keyword} \\t\" + $Keyword.text);}\n\t|\tarray;\narray\t:\t'[' {System.out.println(Indent + \"Array\"); Indent += \"    \";} (value (',' value)*)? ']' {Indent = Indent.substring(4);};\n"}
{"id": 137831, "name": "JSON", "source": "Translate Ruby to Python: require \"json_mapping\"\n\nclass Foo\n  JSON.mapping(\n    num: Int64,\n    array: Array(String),\n  )\nend\n\ndef json\n  foo = Foo.from_json(%({\"num\": 1, \"array\": [\"a\", \"b\"]}))\n  puts(\"\n  puts(foo.to_json)\nend\n", "target": ">>> import json\n>>> data = json.loads('{ \"foo\": 1, \"bar\": [10, \"apples\"] }')\n>>> sample = { \"blue\": [1,2], \"ocean\": \"water\" }\n>>> json_string = json.dumps(sample)\n>>> json_string\n'{\"blue\": [1, 2], \"ocean\": \"water\"}'\n>>> sample\n{'blue': [1, 2], 'ocean': 'water'}\n>>> data\n{'foo': 1, 'bar': [10, 'apples']}\n"}
{"id": 137832, "name": "JSON", "source": "Translate Ruby to Python: require \"json_mapping\"\n\nclass Foo\n  JSON.mapping(\n    num: Int64,\n    array: Array(String),\n  )\nend\n\ndef json\n  foo = Foo.from_json(%({\"num\": 1, \"array\": [\"a\", \"b\"]}))\n  puts(\"\n  puts(foo.to_json)\nend\n", "target": ">>> import json\n>>> data = json.loads('{ \"foo\": 1, \"bar\": [10, \"apples\"] }')\n>>> sample = { \"blue\": [1,2], \"ocean\": \"water\" }\n>>> json_string = json.dumps(sample)\n>>> json_string\n'{\"blue\": [1, 2], \"ocean\": \"water\"}'\n>>> sample\n{'blue': [1, 2], 'ocean': 'water'}\n>>> data\n{'foo': 1, 'bar': [10, 'apples']}\n"}
{"id": 138159, "name": "Check that file exists", "source": "Translate Ruby to C#: def check_file(filename : String)\n  if File.directory?(filename)\n    puts \"\n  elsif File.exists?(filename)\n    puts \"\n  else\n    puts \"\n  end\nend\n\ncheck_file(\"input.txt\")\ncheck_file(\"docs\")\ncheck_file(\"/input.txt\")\ncheck_file(\"/docs\")\n", "target": "using System.IO;\n\nConsole.WriteLine(File.Exists(\"input.txt\"));\nConsole.WriteLine(File.Exists(\"/input.txt\"));\nConsole.WriteLine(Directory.Exists(\"docs\"));\nConsole.WriteLine(Directory.Exists(\"/docs\"));\n"}
{"id": 138161, "name": "Check that file exists", "source": "Translate Ruby to Java: def check_file(filename : String)\n  if File.directory?(filename)\n    puts \"\n  elsif File.exists?(filename)\n    puts \"\n  else\n    puts \"\n  end\nend\n\ncheck_file(\"input.txt\")\ncheck_file(\"docs\")\ncheck_file(\"/input.txt\")\ncheck_file(\"/docs\")\n", "target": "import java.io.File;\npublic class FileExistsTest {\n   public static boolean isFileExists(String filename) {\n       boolean exists = new File(filename).exists();\n       return exists;\n   }\n   public static void test(String type, String filename) {\n       System.out.println(\"The following \" + type + \" called \" + filename + \n           (isFileExists(filename) ? \" exists.\" : \" not exists.\")\n       );\n   }\n   public static void main(String args[]) {\n        test(\"file\", \"input.txt\");\n        test(\"file\", File.separator + \"input.txt\");\n        test(\"directory\", \"docs\");\n        test(\"directory\", File.separator + \"docs\" + File.separator);\n   }\n}\n"}
{"id": 138162, "name": "Check that file exists", "source": "Translate Ruby to Python: def check_file(filename : String)\n  if File.directory?(filename)\n    puts \"\n  elsif File.exists?(filename)\n    puts \"\n  else\n    puts \"\n  end\nend\n\ncheck_file(\"input.txt\")\ncheck_file(\"docs\")\ncheck_file(\"/input.txt\")\ncheck_file(\"/docs\")\n", "target": "import os\n\nos.path.isfile(\"input.txt\")\nos.path.isfile(\"/input.txt\")\nos.path.isdir(\"docs\")\nos.path.isdir(\"/docs\")\n"}
{"id": 138611, "name": "Evolutionary algorithm", "source": "Translate Ruby to C#: @target = \"METHINKS IT IS LIKE A WEASEL\"\nCharset = [\" \", *\"A\"..\"Z\"]\nCOPIES = 100\n\ndef random_char; Charset.sample end\n\ndef fitness(candidate)\n  sum = 0\n  candidate.chars.zip(@target.chars) {|x,y| sum += (x[0].ord - y[0].ord).abs}\n  100.0 * Math.exp(Float(sum) / -10.0)\nend\n\ndef mutation_rate(candidate)\n  1.0 - Math.exp( -(100.0 - fitness(candidate)) / 400.0)\nend\n\ndef mutate(parent, rate)\n  parent.each_char.collect {|ch| rand <= rate ? random_char : ch}.join\nend\n\ndef log(iteration, rate, parent)\n  puts \"%4d\u00a0%.2f %5.1f %s\" % [iteration, rate, fitness(parent), parent]\nend\n\niteration = 0\nparent = Array.new(@target.length) {random_char}.join\nprev = \"\"\n\nwhile parent != @target\n  iteration += 1\n  rate = mutation_rate(parent)\n  if prev != parent\n    log(iteration, rate, parent)\n    prev = parent\n  end\n  copies = [parent] + Array.new(COPIES) {mutate(parent, rate)}\n  parent = copies.max_by {|c| fitness(c)}\nend\nlog(iteration, rate, parent)\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\nstatic class Program {\n    static Random Rng = new Random((int)DateTime.Now.Ticks);\n\n    static char NextCharacter(this Random self) {\n        const string AllowedChars = \" ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n        return AllowedChars[self.Next() % AllowedChars.Length];\n    }\n\n    static string NextString(this Random self, int length) {\n        return String.Join(\"\", Enumerable.Repeat(' ', length)\n            .Select(c => Rng.NextCharacter()));\n    }\n\n    static int Fitness(string target, string current) {\n        return target.Zip(current, (a, b) => a == b ? 1 : 0).Sum();\n    }\n\n    static string Mutate(string current, double rate) {\n        return String.Join(\"\", from c in current\n               select Rng.NextDouble() <= rate ? Rng.NextCharacter() : c);\n    }\n\n    static void Main(string[] args) {\n        const string target = \"METHINKS IT IS LIKE A WEASEL\";\n        const int C = 100;\n        const double P = 0.05;\n\n        \n        string parent = Rng.NextString(target.Length);\n\n        Console.WriteLine(\"START:       {0,20} fitness: {1}\", \n            parent, Fitness(target, parent));\n        int i = 0;\n\n        while (parent != target) {\n            \n            var candidates = Enumerable.Range(0, C + 1)\n                .Select(n => n > 0 ? Mutate(parent, P) : parent);\n\n            \n            parent = candidates.OrderByDescending(c => Fitness(target, c)).First();\n\n            ++i;\n            Console.WriteLine(\"     #{0,6} {1,20} fitness: {2}\", \n                i, parent, Fitness(target, parent));\n        }\n\n        Console.WriteLine(\"END: #{0,6} {1,20}\", i, parent);\n    }\n}\n"}
{"id": 138612, "name": "Evolutionary algorithm", "source": "Translate Ruby to C#: @target = \"METHINKS IT IS LIKE A WEASEL\"\nCharset = [\" \", *\"A\"..\"Z\"]\nCOPIES = 100\n\ndef random_char; Charset.sample end\n\ndef fitness(candidate)\n  sum = 0\n  candidate.chars.zip(@target.chars) {|x,y| sum += (x[0].ord - y[0].ord).abs}\n  100.0 * Math.exp(Float(sum) / -10.0)\nend\n\ndef mutation_rate(candidate)\n  1.0 - Math.exp( -(100.0 - fitness(candidate)) / 400.0)\nend\n\ndef mutate(parent, rate)\n  parent.each_char.collect {|ch| rand <= rate ? random_char : ch}.join\nend\n\ndef log(iteration, rate, parent)\n  puts \"%4d\u00a0%.2f %5.1f %s\" % [iteration, rate, fitness(parent), parent]\nend\n\niteration = 0\nparent = Array.new(@target.length) {random_char}.join\nprev = \"\"\n\nwhile parent != @target\n  iteration += 1\n  rate = mutation_rate(parent)\n  if prev != parent\n    log(iteration, rate, parent)\n    prev = parent\n  end\n  copies = [parent] + Array.new(COPIES) {mutate(parent, rate)}\n  parent = copies.max_by {|c| fitness(c)}\nend\nlog(iteration, rate, parent)\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\nstatic class Program {\n    static Random Rng = new Random((int)DateTime.Now.Ticks);\n\n    static char NextCharacter(this Random self) {\n        const string AllowedChars = \" ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n        return AllowedChars[self.Next() % AllowedChars.Length];\n    }\n\n    static string NextString(this Random self, int length) {\n        return String.Join(\"\", Enumerable.Repeat(' ', length)\n            .Select(c => Rng.NextCharacter()));\n    }\n\n    static int Fitness(string target, string current) {\n        return target.Zip(current, (a, b) => a == b ? 1 : 0).Sum();\n    }\n\n    static string Mutate(string current, double rate) {\n        return String.Join(\"\", from c in current\n               select Rng.NextDouble() <= rate ? Rng.NextCharacter() : c);\n    }\n\n    static void Main(string[] args) {\n        const string target = \"METHINKS IT IS LIKE A WEASEL\";\n        const int C = 100;\n        const double P = 0.05;\n\n        \n        string parent = Rng.NextString(target.Length);\n\n        Console.WriteLine(\"START:       {0,20} fitness: {1}\", \n            parent, Fitness(target, parent));\n        int i = 0;\n\n        while (parent != target) {\n            \n            var candidates = Enumerable.Range(0, C + 1)\n                .Select(n => n > 0 ? Mutate(parent, P) : parent);\n\n            \n            parent = candidates.OrderByDescending(c => Fitness(target, c)).First();\n\n            ++i;\n            Console.WriteLine(\"     #{0,6} {1,20} fitness: {2}\", \n                i, parent, Fitness(target, parent));\n        }\n\n        Console.WriteLine(\"END: #{0,6} {1,20}\", i, parent);\n    }\n}\n"}
{"id": 138615, "name": "Evolutionary algorithm", "source": "Translate Ruby to Java: @target = \"METHINKS IT IS LIKE A WEASEL\"\nCharset = [\" \", *\"A\"..\"Z\"]\nCOPIES = 100\n\ndef random_char; Charset.sample end\n\ndef fitness(candidate)\n  sum = 0\n  candidate.chars.zip(@target.chars) {|x,y| sum += (x[0].ord - y[0].ord).abs}\n  100.0 * Math.exp(Float(sum) / -10.0)\nend\n\ndef mutation_rate(candidate)\n  1.0 - Math.exp( -(100.0 - fitness(candidate)) / 400.0)\nend\n\ndef mutate(parent, rate)\n  parent.each_char.collect {|ch| rand <= rate ? random_char : ch}.join\nend\n\ndef log(iteration, rate, parent)\n  puts \"%4d\u00a0%.2f %5.1f %s\" % [iteration, rate, fitness(parent), parent]\nend\n\niteration = 0\nparent = Array.new(@target.length) {random_char}.join\nprev = \"\"\n\nwhile parent != @target\n  iteration += 1\n  rate = mutation_rate(parent)\n  if prev != parent\n    log(iteration, rate, parent)\n    prev = parent\n  end\n  copies = [parent] + Array.new(COPIES) {mutate(parent, rate)}\n  parent = copies.max_by {|c| fitness(c)}\nend\nlog(iteration, rate, parent)\n", "target": "import java.util.Random;\n\npublic class EvoAlgo {\n  static final String target = \"METHINKS IT IS LIKE A WEASEL\";\n  static final char[] possibilities = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ \".toCharArray();\n  static int C = 100; \n  static double minMutateRate = 0.09;\n  static int perfectFitness = target.length();\n  private static String parent;\n  static Random rand = new Random();\n\n  private static int fitness(String trial){\n    int retVal = 0;\n    for(int i = 0;i < trial.length(); i++){\n      if (trial.charAt(i) == target.charAt(i)) retVal++;\n    }\n    return retVal;\n  }\n\n  private static double newMutateRate(){\n    return (((double)perfectFitness - fitness(parent)) / perfectFitness * (1 - minMutateRate));\n  }\n\n  private static String mutate(String parent, double rate){\n    String retVal = \"\";\n    for(int i = 0;i < parent.length(); i++){\n      retVal += (rand.nextDouble() <= rate) ?\n        possibilities[rand.nextInt(possibilities.length)]:\n        parent.charAt(i);\n    }\n    return retVal;\n  }\n  \n  public static void main(String[] args){\n    parent = mutate(target, 1);\n    int iter = 0;\n    while(!target.equals(parent)){\n      double rate = newMutateRate();\n      iter++;\n      if(iter % 100 == 0){\n        System.out.println(iter +\": \"+parent+ \", fitness: \"+fitness(parent)+\", rate: \"+rate);\n      }\n      String bestSpawn = null;\n      int bestFit = 0;\n      for(int i = 0; i < C; i++){\n        String spawn = mutate(parent, rate);\n        int fitness = fitness(spawn);\n        if(fitness > bestFit){\n          bestSpawn = spawn;\n          bestFit = fitness;\n        }\n      }\n      parent = bestFit > fitness(parent) ? bestSpawn : parent;\n    }\n    System.out.println(parent+\", \"+iter);\n  }\n\n}\n"}
{"id": 138616, "name": "Evolutionary algorithm", "source": "Translate Ruby to Java: @target = \"METHINKS IT IS LIKE A WEASEL\"\nCharset = [\" \", *\"A\"..\"Z\"]\nCOPIES = 100\n\ndef random_char; Charset.sample end\n\ndef fitness(candidate)\n  sum = 0\n  candidate.chars.zip(@target.chars) {|x,y| sum += (x[0].ord - y[0].ord).abs}\n  100.0 * Math.exp(Float(sum) / -10.0)\nend\n\ndef mutation_rate(candidate)\n  1.0 - Math.exp( -(100.0 - fitness(candidate)) / 400.0)\nend\n\ndef mutate(parent, rate)\n  parent.each_char.collect {|ch| rand <= rate ? random_char : ch}.join\nend\n\ndef log(iteration, rate, parent)\n  puts \"%4d\u00a0%.2f %5.1f %s\" % [iteration, rate, fitness(parent), parent]\nend\n\niteration = 0\nparent = Array.new(@target.length) {random_char}.join\nprev = \"\"\n\nwhile parent != @target\n  iteration += 1\n  rate = mutation_rate(parent)\n  if prev != parent\n    log(iteration, rate, parent)\n    prev = parent\n  end\n  copies = [parent] + Array.new(COPIES) {mutate(parent, rate)}\n  parent = copies.max_by {|c| fitness(c)}\nend\nlog(iteration, rate, parent)\n", "target": "import java.util.Random;\n\npublic class EvoAlgo {\n  static final String target = \"METHINKS IT IS LIKE A WEASEL\";\n  static final char[] possibilities = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ \".toCharArray();\n  static int C = 100; \n  static double minMutateRate = 0.09;\n  static int perfectFitness = target.length();\n  private static String parent;\n  static Random rand = new Random();\n\n  private static int fitness(String trial){\n    int retVal = 0;\n    for(int i = 0;i < trial.length(); i++){\n      if (trial.charAt(i) == target.charAt(i)) retVal++;\n    }\n    return retVal;\n  }\n\n  private static double newMutateRate(){\n    return (((double)perfectFitness - fitness(parent)) / perfectFitness * (1 - minMutateRate));\n  }\n\n  private static String mutate(String parent, double rate){\n    String retVal = \"\";\n    for(int i = 0;i < parent.length(); i++){\n      retVal += (rand.nextDouble() <= rate) ?\n        possibilities[rand.nextInt(possibilities.length)]:\n        parent.charAt(i);\n    }\n    return retVal;\n  }\n  \n  public static void main(String[] args){\n    parent = mutate(target, 1);\n    int iter = 0;\n    while(!target.equals(parent)){\n      double rate = newMutateRate();\n      iter++;\n      if(iter % 100 == 0){\n        System.out.println(iter +\": \"+parent+ \", fitness: \"+fitness(parent)+\", rate: \"+rate);\n      }\n      String bestSpawn = null;\n      int bestFit = 0;\n      for(int i = 0; i < C; i++){\n        String spawn = mutate(parent, rate);\n        int fitness = fitness(spawn);\n        if(fitness > bestFit){\n          bestSpawn = spawn;\n          bestFit = fitness;\n        }\n      }\n      parent = bestFit > fitness(parent) ? bestSpawn : parent;\n    }\n    System.out.println(parent+\", \"+iter);\n  }\n\n}\n"}
{"id": 138617, "name": "Evolutionary algorithm", "source": "Translate Ruby to Python: @target = \"METHINKS IT IS LIKE A WEASEL\"\nCharset = [\" \", *\"A\"..\"Z\"]\nCOPIES = 100\n\ndef random_char; Charset.sample end\n\ndef fitness(candidate)\n  sum = 0\n  candidate.chars.zip(@target.chars) {|x,y| sum += (x[0].ord - y[0].ord).abs}\n  100.0 * Math.exp(Float(sum) / -10.0)\nend\n\ndef mutation_rate(candidate)\n  1.0 - Math.exp( -(100.0 - fitness(candidate)) / 400.0)\nend\n\ndef mutate(parent, rate)\n  parent.each_char.collect {|ch| rand <= rate ? random_char : ch}.join\nend\n\ndef log(iteration, rate, parent)\n  puts \"%4d\u00a0%.2f %5.1f %s\" % [iteration, rate, fitness(parent), parent]\nend\n\niteration = 0\nparent = Array.new(@target.length) {random_char}.join\nprev = \"\"\n\nwhile parent != @target\n  iteration += 1\n  rate = mutation_rate(parent)\n  if prev != parent\n    log(iteration, rate, parent)\n    prev = parent\n  end\n  copies = [parent] + Array.new(COPIES) {mutate(parent, rate)}\n  parent = copies.max_by {|c| fitness(c)}\nend\nlog(iteration, rate, parent)\n", "target": "from string import letters\nfrom random import choice, random\n \ntarget  = list(\"METHINKS IT IS LIKE A WEASEL\")\ncharset = letters + ' '\nparent  = [choice(charset) for _ in range(len(target))]\nminmutaterate  = .09\nC = range(100)\n \nperfectfitness = float(len(target))\n    \ndef fitness(trial):\n    'Sum of matching chars by position'\n    return sum(t==h for t,h in zip(trial, target))\n \ndef mutaterate():\n    'Less mutation the closer the fit of the parent'\n    return 1-((perfectfitness - fitness(parent)) / perfectfitness * (1 - minmutaterate))\n \ndef mutate(parent, rate):\n    return [(ch if random() <= rate else choice(charset)) for ch in parent]\n \ndef que():\n    '(from the favourite saying of Manuel in Fawlty Towers)'\n    print (\"\n           (iterations, fitness(parent)*100./perfectfitness, ''.join(parent)))\n\ndef mate(a, b):\n    place = 0\n    if choice(xrange(10)) < 7:\n        place = choice(xrange(len(target)))\n    else:\n        return a, b\n    \n    return a, b, a[:place] + b[place:], b[:place] + a[place:]\n\niterations = 0\ncenter = len(C)/2\nwhile parent != target:\n    rate = mutaterate()\n    iterations += 1\n    if iterations % 100 == 0: que()\n    copies = [ mutate(parent, rate) for _ in C ]  + [parent]\n    parent1 = max(copies[:center], key=fitness)\n    parent2 = max(copies[center:], key=fitness)\n    parent = max(mate(parent1, parent2), key=fitness)\nque()\n"}
{"id": 138618, "name": "Evolutionary algorithm", "source": "Translate Ruby to Python: @target = \"METHINKS IT IS LIKE A WEASEL\"\nCharset = [\" \", *\"A\"..\"Z\"]\nCOPIES = 100\n\ndef random_char; Charset.sample end\n\ndef fitness(candidate)\n  sum = 0\n  candidate.chars.zip(@target.chars) {|x,y| sum += (x[0].ord - y[0].ord).abs}\n  100.0 * Math.exp(Float(sum) / -10.0)\nend\n\ndef mutation_rate(candidate)\n  1.0 - Math.exp( -(100.0 - fitness(candidate)) / 400.0)\nend\n\ndef mutate(parent, rate)\n  parent.each_char.collect {|ch| rand <= rate ? random_char : ch}.join\nend\n\ndef log(iteration, rate, parent)\n  puts \"%4d\u00a0%.2f %5.1f %s\" % [iteration, rate, fitness(parent), parent]\nend\n\niteration = 0\nparent = Array.new(@target.length) {random_char}.join\nprev = \"\"\n\nwhile parent != @target\n  iteration += 1\n  rate = mutation_rate(parent)\n  if prev != parent\n    log(iteration, rate, parent)\n    prev = parent\n  end\n  copies = [parent] + Array.new(COPIES) {mutate(parent, rate)}\n  parent = copies.max_by {|c| fitness(c)}\nend\nlog(iteration, rate, parent)\n", "target": "from string import letters\nfrom random import choice, random\n \ntarget  = list(\"METHINKS IT IS LIKE A WEASEL\")\ncharset = letters + ' '\nparent  = [choice(charset) for _ in range(len(target))]\nminmutaterate  = .09\nC = range(100)\n \nperfectfitness = float(len(target))\n    \ndef fitness(trial):\n    'Sum of matching chars by position'\n    return sum(t==h for t,h in zip(trial, target))\n \ndef mutaterate():\n    'Less mutation the closer the fit of the parent'\n    return 1-((perfectfitness - fitness(parent)) / perfectfitness * (1 - minmutaterate))\n \ndef mutate(parent, rate):\n    return [(ch if random() <= rate else choice(charset)) for ch in parent]\n \ndef que():\n    '(from the favourite saying of Manuel in Fawlty Towers)'\n    print (\"\n           (iterations, fitness(parent)*100./perfectfitness, ''.join(parent)))\n\ndef mate(a, b):\n    place = 0\n    if choice(xrange(10)) < 7:\n        place = choice(xrange(len(target)))\n    else:\n        return a, b\n    \n    return a, b, a[:place] + b[place:], b[:place] + a[place:]\n\niterations = 0\ncenter = len(C)/2\nwhile parent != target:\n    rate = mutaterate()\n    iterations += 1\n    if iterations % 100 == 0: que()\n    copies = [ mutate(parent, rate) for _ in C ]  + [parent]\n    parent1 = max(copies[:center], key=fitness)\n    parent2 = max(copies[center:], key=fitness)\n    parent = max(mate(parent1, parent2), key=fitness)\nque()\n"}
{"id": 138880, "name": "Maze generation", "source": "Translate Ruby to C#: class Maze\n  DIRECTIONS = [ [1, 0], [-1, 0], [0, 1], [0, -1] ]\n  \n  def initialize(width, height)\n    @width   = width\n    @height  = height\n    @start_x = rand(width)\n    @start_y = 0\n    @end_x   = rand(width)\n    @end_y   = height - 1\n    \n    \n    \n    \n    \n    @vertical_walls   = Array.new(width) { Array.new(height, true) }\n    @horizontal_walls = Array.new(width) { Array.new(height, true) }\n    \n    @path             = Array.new(width) { Array.new(height) }\n    \n    \n    @horizontal_walls[@end_x][@end_y] = false\n    \n    \n    generate\n  end\n  \n  \n  def print\n    \n    puts @width.times.inject(\"+\") {|str, x| str << (x == @start_x ? \"   +\" : \"---+\")}\n    \n    \n    @height.times do |y|\n      line = @width.times.inject(\"|\") do |str, x|\n        str << (@path[x][y] ? \" * \" : \"   \") << (@vertical_walls[x][y] ? \"|\" : \" \")\n      end\n      puts line\n      \n      puts @width.times.inject(\"+\") {|str, x| str << (@horizontal_walls[x][y] ? \"---+\" : \"   +\")}\n    end\n  end\n  \n  private\n  \n  \n  def reset_visiting_state\n    @visited = Array.new(@width) { Array.new(@height) }\n  end\n  \n  \n  def move_valid?(x, y)\n    (0...@width).cover?(x) && (0...@height).cover?(y) && !@visited[x][y]\n  end\n  \n  \n  def generate\n    reset_visiting_state\n    generate_visit_cell(@start_x, @start_y)\n  end\n  \n  \n  def generate_visit_cell(x, y)\n    \n    @visited[x][y] = true\n    \n    \n    \n    coordinates = DIRECTIONS.shuffle.map { |dx, dy| [x + dx, y + dy] }\n    \n    for new_x, new_y in coordinates\n      next unless move_valid?(new_x, new_y)\n      \n      \n      \n      connect_cells(x, y, new_x, new_y)\n      generate_visit_cell(new_x, new_y)\n    end\n  end\n  \n  \n  def connect_cells(x1, y1, x2, y2)\n    if x1 == x2\n      \n      @horizontal_walls[x1][ [y1, y2].min ] = false\n    else\n      \n      @vertical_walls[ [x1, x2].min ][y1] = false\n    end\n  end\nend\n\n\nmaze = Maze.new 20, 10\nmaze.print\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\nusing System.Linq;\nusing System.Text;\nusing System.Drawing;\n\nnamespace MazeGeneration\n{\n    public static class Extensions\n    {\n        public static IEnumerable<T> Shuffle<T>(this IEnumerable<T> source, Random rng)\n        {\n            var e = source.ToArray();\n            for (var i = e.Length - 1; i >= 0; i--)\n            {\n                var swapIndex = rng.Next(i + 1);\n                yield return e[swapIndex];\n                e[swapIndex] = e[i];\n            }\n        }\n\n        public static CellState OppositeWall(this CellState orig)\n        {\n            return (CellState)(((int) orig >> 2) | ((int) orig << 2)) & CellState.Initial;\n        }\n\n        public static bool HasFlag(this CellState cs,CellState flag)\n        {\n            return ((int)cs & (int)flag) != 0;\n        }\n    }\n\n    [Flags]\n    public enum CellState\n    {\n        Top = 1,\n        Right = 2,\n        Bottom = 4,\n        Left = 8,\n        Visited = 128,\n        Initial = Top | Right | Bottom | Left,\n    }\n\n    public struct RemoveWallAction\n    {\n        public Point Neighbour;\n        public CellState Wall;\n    }\n\n    public class Maze\n    {\n        private readonly CellState[,] _cells;\n        private readonly int _width;\n        private readonly int _height;\n        private readonly Random _rng;\n\n        public Maze(int width, int height)\n        {\n            _width = width;\n            _height = height;\n            _cells = new CellState[width, height];\n            for(var x=0; x<width; x++)\n                for(var y=0; y<height; y++)\n                    _cells[x, y] = CellState.Initial;\n            _rng = new Random();\n            VisitCell(_rng.Next(width), _rng.Next(height));\n        }\n\n        public CellState this[int x, int y]\n        {\n            get { return _cells[x,y]; }\n            set { _cells[x,y] = value; }\n        }\n\n        public IEnumerable<RemoveWallAction> GetNeighbours(Point p)\n        {\n            if (p.X > 0) yield return new RemoveWallAction {Neighbour = new Point(p.X - 1, p.Y), Wall = CellState.Left};\n            if (p.Y > 0) yield return new RemoveWallAction {Neighbour = new Point(p.X, p.Y - 1), Wall = CellState.Top};\n            if (p.X < _width-1) yield return new RemoveWallAction {Neighbour = new Point(p.X + 1, p.Y), Wall = CellState.Right};\n            if (p.Y < _height-1) yield return new RemoveWallAction {Neighbour = new Point(p.X, p.Y + 1), Wall = CellState.Bottom};\n        }\n\n        public void VisitCell(int x, int y)\n        {\n            this[x,y] |= CellState.Visited;\n            foreach (var p in GetNeighbours(new Point(x, y)).Shuffle(_rng).Where(z => !(this[z.Neighbour.X, z.Neighbour.Y].HasFlag(CellState.Visited))))\n            {\n                this[x, y] -= p.Wall;\n                this[p.Neighbour.X, p.Neighbour.Y] -= p.Wall.OppositeWall();\n                VisitCell(p.Neighbour.X, p.Neighbour.Y);\n            }\n        }\n\n        public void Display()\n        {\n            var firstLine = string.Empty;\n            for (var y = 0; y < _height; y++)\n            {\n                var sbTop = new StringBuilder();\n                var sbMid = new StringBuilder();\n                for (var x = 0; x < _width; x++)\n                {\n                    sbTop.Append(this[x, y].HasFlag(CellState.Top) ? \"+---\" : \"+   \");\n                    sbMid.Append(this[x, y].HasFlag(CellState.Left) ? \"|   \" : \"    \");\n                }\n                if (firstLine == string.Empty)\n                    firstLine = \"   \" + sbTop.ToString();\n                Debug.WriteLine(\"   \" + sbTop + \"+\");\n                Debug.WriteLine(\"   \" + sbMid + \"|\");\n            }\n            Debug.WriteLine(firstLine);\n        }\n    }\n\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            var maze = new Maze(20, 20);\n            maze.Display();\n        }\n    }\n}\n"}
{"id": 138882, "name": "Maze generation", "source": "Translate Ruby to Java: class Maze\n  DIRECTIONS = [ [1, 0], [-1, 0], [0, 1], [0, -1] ]\n  \n  def initialize(width, height)\n    @width   = width\n    @height  = height\n    @start_x = rand(width)\n    @start_y = 0\n    @end_x   = rand(width)\n    @end_y   = height - 1\n    \n    \n    \n    \n    \n    @vertical_walls   = Array.new(width) { Array.new(height, true) }\n    @horizontal_walls = Array.new(width) { Array.new(height, true) }\n    \n    @path             = Array.new(width) { Array.new(height) }\n    \n    \n    @horizontal_walls[@end_x][@end_y] = false\n    \n    \n    generate\n  end\n  \n  \n  def print\n    \n    puts @width.times.inject(\"+\") {|str, x| str << (x == @start_x ? \"   +\" : \"---+\")}\n    \n    \n    @height.times do |y|\n      line = @width.times.inject(\"|\") do |str, x|\n        str << (@path[x][y] ? \" * \" : \"   \") << (@vertical_walls[x][y] ? \"|\" : \" \")\n      end\n      puts line\n      \n      puts @width.times.inject(\"+\") {|str, x| str << (@horizontal_walls[x][y] ? \"---+\" : \"   +\")}\n    end\n  end\n  \n  private\n  \n  \n  def reset_visiting_state\n    @visited = Array.new(@width) { Array.new(@height) }\n  end\n  \n  \n  def move_valid?(x, y)\n    (0...@width).cover?(x) && (0...@height).cover?(y) && !@visited[x][y]\n  end\n  \n  \n  def generate\n    reset_visiting_state\n    generate_visit_cell(@start_x, @start_y)\n  end\n  \n  \n  def generate_visit_cell(x, y)\n    \n    @visited[x][y] = true\n    \n    \n    \n    coordinates = DIRECTIONS.shuffle.map { |dx, dy| [x + dx, y + dy] }\n    \n    for new_x, new_y in coordinates\n      next unless move_valid?(new_x, new_y)\n      \n      \n      \n      connect_cells(x, y, new_x, new_y)\n      generate_visit_cell(new_x, new_y)\n    end\n  end\n  \n  \n  def connect_cells(x1, y1, x2, y2)\n    if x1 == x2\n      \n      @horizontal_walls[x1][ [y1, y2].min ] = false\n    else\n      \n      @vertical_walls[ [x1, x2].min ][y1] = false\n    end\n  end\nend\n\n\nmaze = Maze.new 20, 10\nmaze.print\n", "target": "package org.rosettacode;\n\nimport java.util.Collections;\nimport java.util.Arrays;\n\n\npublic class MazeGenerator {\n\tprivate final int x;\n\tprivate final int y;\n\tprivate final int[][] maze;\n\n\tpublic MazeGenerator(int x, int y) {\n\t\tthis.x = x;\n\t\tthis.y = y;\n\t\tmaze = new int[this.x][this.y];\n\t\tgenerateMaze(0, 0);\n\t}\n\n\tpublic void display() {\n\t\tfor (int i = 0; i < y; i++) {\n\t\t\t\n\t\t\tfor (int j = 0; j < x; j++) {\n\t\t\t\tSystem.out.print((maze[j][i] & 1) == 0 ? \"+---\" : \"+   \");\n\t\t\t}\n\t\t\tSystem.out.println(\"+\");\n\t\t\t\n\t\t\tfor (int j = 0; j < x; j++) {\n\t\t\t\tSystem.out.print((maze[j][i] & 8) == 0 ? \"|   \" : \"    \");\n\t\t\t}\n\t\t\tSystem.out.println(\"|\");\n\t\t}\n\t\t\n\t\tfor (int j = 0; j < x; j++) {\n\t\t\tSystem.out.print(\"+---\");\n\t\t}\n\t\tSystem.out.println(\"+\");\n\t}\n\n\tprivate void generateMaze(int cx, int cy) {\n\t\tDIR[] dirs = DIR.values();\n\t\tCollections.shuffle(Arrays.asList(dirs));\n\t\tfor (DIR dir : dirs) {\n\t\t\tint nx = cx + dir.dx;\n\t\t\tint ny = cy + dir.dy;\n\t\t\tif (between(nx, x) && between(ny, y)\n\t\t\t\t\t&& (maze[nx][ny] == 0)) {\n\t\t\t\tmaze[cx][cy] |= dir.bit;\n\t\t\t\tmaze[nx][ny] |= dir.opposite.bit;\n\t\t\t\tgenerateMaze(nx, ny);\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate static boolean between(int v, int upper) {\n\t\treturn (v >= 0) && (v < upper);\n\t}\n\n\tprivate enum DIR {\n\t\tN(1, 0, -1), S(2, 0, 1), E(4, 1, 0), W(8, -1, 0);\n\t\tprivate final int bit;\n\t\tprivate final int dx;\n\t\tprivate final int dy;\n\t\tprivate DIR opposite;\n\n\t\t\n\t\tstatic {\n\t\t\tN.opposite = S;\n\t\t\tS.opposite = N;\n\t\t\tE.opposite = W;\n\t\t\tW.opposite = E;\n\t\t}\n\n\t\tprivate DIR(int bit, int dx, int dy) {\n\t\t\tthis.bit = bit;\n\t\t\tthis.dx = dx;\n\t\t\tthis.dy = dy;\n\t\t}\n\t};\n\n\tpublic static void main(String[] args) {\n\t\tint x = args.length >= 1 ? (Integer.parseInt(args[0])) : 8;\n\t\tint y = args.length == 2 ? (Integer.parseInt(args[1])) : 8;\n\t\tMazeGenerator maze = new MazeGenerator(x, y);\n\t\tmaze.display();\n\t}\n\n}\n"}
{"id": 138883, "name": "Maze generation", "source": "Translate Ruby to Python: class Maze\n  DIRECTIONS = [ [1, 0], [-1, 0], [0, 1], [0, -1] ]\n  \n  def initialize(width, height)\n    @width   = width\n    @height  = height\n    @start_x = rand(width)\n    @start_y = 0\n    @end_x   = rand(width)\n    @end_y   = height - 1\n    \n    \n    \n    \n    \n    @vertical_walls   = Array.new(width) { Array.new(height, true) }\n    @horizontal_walls = Array.new(width) { Array.new(height, true) }\n    \n    @path             = Array.new(width) { Array.new(height) }\n    \n    \n    @horizontal_walls[@end_x][@end_y] = false\n    \n    \n    generate\n  end\n  \n  \n  def print\n    \n    puts @width.times.inject(\"+\") {|str, x| str << (x == @start_x ? \"   +\" : \"---+\")}\n    \n    \n    @height.times do |y|\n      line = @width.times.inject(\"|\") do |str, x|\n        str << (@path[x][y] ? \" * \" : \"   \") << (@vertical_walls[x][y] ? \"|\" : \" \")\n      end\n      puts line\n      \n      puts @width.times.inject(\"+\") {|str, x| str << (@horizontal_walls[x][y] ? \"---+\" : \"   +\")}\n    end\n  end\n  \n  private\n  \n  \n  def reset_visiting_state\n    @visited = Array.new(@width) { Array.new(@height) }\n  end\n  \n  \n  def move_valid?(x, y)\n    (0...@width).cover?(x) && (0...@height).cover?(y) && !@visited[x][y]\n  end\n  \n  \n  def generate\n    reset_visiting_state\n    generate_visit_cell(@start_x, @start_y)\n  end\n  \n  \n  def generate_visit_cell(x, y)\n    \n    @visited[x][y] = true\n    \n    \n    \n    coordinates = DIRECTIONS.shuffle.map { |dx, dy| [x + dx, y + dy] }\n    \n    for new_x, new_y in coordinates\n      next unless move_valid?(new_x, new_y)\n      \n      \n      \n      connect_cells(x, y, new_x, new_y)\n      generate_visit_cell(new_x, new_y)\n    end\n  end\n  \n  \n  def connect_cells(x1, y1, x2, y2)\n    if x1 == x2\n      \n      @horizontal_walls[x1][ [y1, y2].min ] = false\n    else\n      \n      @vertical_walls[ [x1, x2].min ][y1] = false\n    end\n  end\nend\n\n\nmaze = Maze.new 20, 10\nmaze.print\n", "target": "g_size = 10\nbackground_color = color(80, 80, 220)\nrunner = color(255, 50, 50)\nvisited_color = color(220, 240, 240)\ndone_color = color(100, 160, 250)\n\ndef setup():\n    global cell, done, visit, run_cell, c_size\n    size(600, 600)\n    frameRate(20)\n    smooth(4)\n    strokeCap(ROUND)\n    c_size = max(width / g_size, height / g_size)\n    cell = [[None] * g_size for _ in range(g_size)]\n    \n    for i in range(g_size):\n        for j in range(g_size):\n            cell[i][j] = Cell(i, j)\n\n    for i in range(g_size):\n        for j in range(g_size):\n            cell[i][j].add_neighbor()\n\n    run_cell = cell[0][0]\n    visit, done = [], []\n    visit.append(run_cell)\n\n\ndef draw():\n    global run_cell\n    \n    background(background_color)\n    \n    for i in range(g_size):\n        for j in range(g_size):\n            cell[i][j].draw_cell()\n            cell[i][j].draw_wall()\n\n    if len(visit) < g_size * g_size:\n        if run_cell.check_sides():\n            chosen = run_cell.pick_neighbor()\n            done.append(run_cell)\n            run_cell.stacked = True\n            if chosen.i - run_cell.i == 1:\n                run_cell.wall[1] = False\n                chosen.wall[3] = False\n            elif chosen.i - run_cell.i == -1:\n                run_cell.wall[3] = False\n                chosen.wall[1] = False\n            elif chosen.j - run_cell.j == 1:\n                run_cell.wall[2] = False\n                chosen.wall[0] = False\n            else:\n                run_cell.wall[0] = False\n                chosen.wall[2] = False\n            run_cell.current = False\n            run_cell = chosen\n            run_cell.current = True\n            run_cell.visited = True\n        elif done:\n            run_cell.current = False\n            run_cell = done.pop()\n            run_cell.stacked = False\n            run_cell.current = True\n\n\nclass Cell:\n\n    def __init__(self, i, j):\n        self.i = i\n        self.j = j\n        self.wall = [True, True, True, True]\n        self.visited = False\n        self.stacked = False\n        self.current = False\n\n    def pick_neighbor(self):\n        from random import choice\n        unvisited = [nb for nb in self.neighbor\n                          if nb.visited == False]\n        return choice(unvisited)\n\n    def add_neighbor(self):\n        i, j = self.i, self.j\n        neighbor = []\n        if i > 0:\n            neighbor.append(cell[i - 1][j])\n        if i < g_size - 1:\n            neighbor.append(cell[i + 1][j])\n        if j > 0:\n            neighbor.append(cell[i][j - 1])\n        if j < g_size - 1:\n            neighbor.append(cell[i][j + 1])\n        self.neighbor = neighbor\n\n    def check_sides(self):\n        for nb in self.neighbor:\n            if not nb.visited:\n                return True\n        return False\n\n    def draw_cell(self):\n        s = c_size\n        noStroke()\n        noFill()\n        if self.current:\n            fill(runner)\n        elif self.stacked:\n            fill(done_color)\n        elif self.visited:\n            fill(visited_color)\n        rect(self.j * s, self.i * s, s, s)\n\n    def draw_wall(self):\n        i, j = self.i, self.j\n        wall = self.wall\n        stroke(0)\n        strokeWeight(5)\n        if wall[0]: line(j * c_size, i * c_size, j * c_size, (i + 1) * c_size)\n        if wall[1]: line(j * c_size, (i + 1) * c_size, (j + 1) * c_size, (i + 1) * c_size)\n        if wall[2]: line((j + 1) * c_size, (i + 1) * c_size, (j + 1) * c_size, i * c_size)\n        if wall[3]: line((j + 1) * c_size, i * c_size, j * c_size, i * c_size)\n"}
{"id": 139145, "name": "Ordered words", "source": "Translate Ruby to C#: require 'open-uri'\nordered_words = open('http://www.puzzlers.org/pub/wordlists/unixdict.txt', 'r').select do |word| \n  word.strip!\n  word.chars.sort.join == word\nend\n\ngrouped = ordered_words.group_by &:size\nputs grouped[grouped.keys.max]\n", "target": "using System;\nusing System.Linq;\nusing System.Net;\n\nstatic class Program\n{\n    static void Main(string[] args)\n    {\n        WebClient client = new WebClient();\n        string text = client.DownloadString(\"http:\n        string[] words = text.Split(new char[] { '\\r', '\\n' }, StringSplitOptions.RemoveEmptyEntries);\n\n        var query = from w in words\n                    where IsOrderedWord(w)\n                    group w by w.Length into ows\n                    orderby ows.Key descending\n                    select ows;\n\n        Console.WriteLine(string.Join(\", \", query.First().ToArray()));\n    }\n\n    private static bool IsOrderedWord(string w)\n    {\n        for (int i = 1; i < w.Length; i++)\n            if (w[i] < w[i - 1])\n                return false;\n\n        return true;\n    }\n}\n"}
{"id": 139147, "name": "Ordered words", "source": "Translate Ruby to Java: require 'open-uri'\nordered_words = open('http://www.puzzlers.org/pub/wordlists/unixdict.txt', 'r').select do |word| \n  word.strip!\n  word.chars.sort.join == word\nend\n\ngrouped = ordered_words.group_by &:size\nputs grouped[grouped.keys.max]\n", "target": "import java.io.BufferedReader;\nimport java.io.FileReader;\nimport java.io.IOException;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.LinkedList;\nimport java.util.List;\n\npublic class Ordered {\n\n\tprivate static boolean isOrderedWord(String word){\n\t\tchar[] sortedWord = word.toCharArray();\n\t\tArrays.sort(sortedWord);\n\t\treturn word.equals(new String(sortedWord));\n\t}\n\t\n\tpublic static void main(String[] args) throws IOException{\n\t\tList<String> orderedWords = new LinkedList<String>();\n\t\tBufferedReader in = new BufferedReader(new FileReader(args[0]));\n\t\twhile(in.ready()){\n\t\t\tString word = in.readLine();\n\t\t\tif(isOrderedWord(word)) orderedWords.add(word);\n\t\t}\n\t\tin.close();\n\t\t\n\t\tCollections.<String>sort(orderedWords, new Comparator<String>() {\n\t\t\t@Override\n\t\t\tpublic int compare(String o1, String o2) {\n\t\t\t\treturn new Integer(o2.length()).compareTo(o1.length());\n\t\t\t}\n\t\t});\n\t\t\n\t\tint maxLen = orderedWords.get(0).length();\n\t\tfor(String word: orderedWords){\n\t\t\tif(word.length() == maxLen){\n\t\t\t\tSystem.out.println(word);\n\t\t\t}else{\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}\n"}
{"id": 139148, "name": "Ordered words", "source": "Translate Ruby to Python: require 'open-uri'\nordered_words = open('http://www.puzzlers.org/pub/wordlists/unixdict.txt', 'r').select do |word| \n  word.strip!\n  word.chars.sort.join == word\nend\n\ngrouped = ordered_words.group_by &:size\nputs grouped[grouped.keys.max]\n", "target": "import urllib.request\n\nurl = 'http://www.puzzlers.org/pub/wordlists/unixdict.txt'\nwords = urllib.request.urlopen(url).read().decode(\"utf-8\").split()\nordered = [word for word in words if word==''.join(sorted(word))]\nmaxlen = len(max(ordered, key=len))\nmaxorderedwords = [word for word in ordered if len(word) == maxlen]\nprint(' '.join(maxorderedwords))\n"}
{"id": 139385, "name": "Arrays", "source": "Translate Ruby to C#: \na = ['foo']\n\n\n\n\na << 1         \na.push(3,4,5)  \n\n\na[0] = 2       \n\n\na[0,3] = 'bar'    \na[1..-1] = 'baz'  \na[0] = nil        \na[0,1] = nil      \n\n\nputs a[0]\n", "target": " int[] numbers = new int[10];\n"}
{"id": 139387, "name": "Arrays", "source": "Translate Ruby to Java: \na = ['foo']\n\n\n\n\na << 1         \na.push(3,4,5)  \n\n\na[0] = 2       \n\n\na[0,3] = 'bar'    \na[1..-1] = 'baz'  \na[0] = nil        \na[0,1] = nil      \n\n\nputs a[0]\n", "target": "Int[] literalArray = [1,2,3];\nInt[] fixedLengthArray = new Int[10];\nInt[] variableArray = new Int[];\n\nassert literalArray.size == 3; \nInt n = literalArray[2];       \nfixedLengthArray[4] = 12345;   \n\nfixedLengthArray += 6789;  \nvariableArray    += 6789;  \n"}
{"id": 139388, "name": "Arrays", "source": "Translate Ruby to Python: \na = ['foo']\n\n\n\n\na << 1         \na.push(3,4,5)  \n\n\na[0] = 2       \n\n\na[0,3] = 'bar'    \na[1..-1] = 'baz'  \na[0] = nil        \na[0,1] = nil      \n\n\nputs a[0]\n", "target": "array = []\n\narray.append(1)\narray.append(3)\n\narray[0] = 2\n\nprint(array[0])\n"}
{"id": 139588, "name": "Partial function application", "source": "Translate Ruby to C#: fs = proc { |f, s| s.map &f }\nf1 = proc { |n| n * 2 }\nf2 = proc { |n| n ** 2 }\nfsf1 = fs.curry[f1]\nfsf2 = fs.curry[f2]\n\n[0..3, (2..8).step(2)].each do |e|\n  p fsf1[e]\n  p fsf2[e]\nend\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\nclass PartialFunctionApplication\n{\n    static Func<T1, TResult> PartiallyApply<T1, T2, TResult>(Func<T1, T2, TResult> function, T2 argument2)\n    {\n        return argument1 => function(argument1, argument2);\n    }\n\n    static void Main()\n    {\n        var fs = (Func<IEnumerable<int>, Func<int, int>, IEnumerable<int>>)Enumerable.Select;\n        var f1 = (Func<int, int>)(n => n * 2);\n        var f2 = (Func<int, int>)(n => n * n);\n        var fsf1 = PartiallyApply(fs, f1);\n        var fsf2 = PartiallyApply(fs, f2);\n\n        var s = new[] { 0, 1, 2, 3 };\n        Console.WriteLine(string.Join(\", \", fsf1(s)));\n        Console.WriteLine(string.Join(\", \", fsf2(s)));\n\n        s = new[] { 2, 4, 6, 8 };\n        Console.WriteLine(string.Join(\", \", fsf1(s)));\n        Console.WriteLine(string.Join(\", \", fsf2(s)));\n    }\n}\n"}
{"id": 139590, "name": "Partial function application", "source": "Translate Ruby to Java: fs = proc { |f, s| s.map &f }\nf1 = proc { |n| n * 2 }\nf2 = proc { |n| n ** 2 }\nfsf1 = fs.curry[f1]\nfsf2 = fs.curry[f2]\n\n[0..3, (2..8).step(2)].each do |e|\n  p fsf1[e]\n  p fsf2[e]\nend\n", "target": "import java.util.Arrays;\n\npublic class PartialApplication {\n\tinterface IntegerFunction {\n\t\tint call(int arg);\n\t}\n\n\t\n\tstatic int[] fs(IntegerFunction f, int[] s) {\n\t\tint[] r = new int[s.length];\n\t\tfor (int i = 0; i < s.length; i++)\n\t\t\tr[i] = f.call(s[i]);\n\t\treturn r;\t\t\n\t}\n\n\tinterface SequenceFunction {\n\t\tint[] call(int[] arg);\n\t}\n\n\t\n\t\n\tstatic SequenceFunction fs(final IntegerFunction f) {\n\t\treturn new SequenceFunction() {\n\t\t\tpublic int[] call(int[] s) {\n\t\t\t\t\n\t\t\t\treturn fs(f, s);\n\t\t\t}\n\t\t};\n\t}\n\n\tstatic IntegerFunction f1 = new IntegerFunction() {\n\t\tpublic int call(int i) {\n\t\t\treturn i * 2;\n\t\t}\n\t};\n\n\tstatic IntegerFunction f2 = new IntegerFunction() {\n\t\tpublic int call(int i) {\n\t\t\treturn i * i;\n\t\t}\n\t};\n\n\tstatic SequenceFunction fsf1 = fs(f1); \n\n\tstatic SequenceFunction fsf2 = fs(f2);\n\n\tpublic static void main(String[] args) {\n\t\tint[][] sequences = {\n\t\t\t{ 0, 1, 2, 3 },\n\t\t\t{ 2, 4, 6, 8 },\n\t\t};\n\n\t\tfor (int[] array : sequences) {\n\t\t\tSystem.out.printf(\n\t\t\t    \"array: %s\\n\" +\n\t\t\t    \"  fsf1(array): %s\\n\" +\n\t\t\t    \"  fsf2(array): %s\\n\",\n\t\t\t    Arrays.toString(array),\n\t\t\t    Arrays.toString(fsf1.call(array)),\n\t\t\t    Arrays.toString(fsf2.call(array)));\n\t\t}\n\t}\n}\n"}
{"id": 139591, "name": "Partial function application", "source": "Translate Ruby to Python: fs = proc { |f, s| s.map &f }\nf1 = proc { |n| n * 2 }\nf2 = proc { |n| n ** 2 }\nfsf1 = fs.curry[f1]\nfsf2 = fs.curry[f2]\n\n[0..3, (2..8).step(2)].each do |e|\n  p fsf1[e]\n  p fsf2[e]\nend\n", "target": "from functools import partial\n\ndef fs(f, s): return [f(value) for value in s]\n\ndef f1(value): return value * 2\n\ndef f2(value): return value ** 2\n\nfsf1 = partial(fs, f1)\nfsf2 = partial(fs, f2)\n\ns = [0, 1, 2, 3]\nassert fs(f1, s) == fsf1(s) \nassert fs(f2, s) == fsf2(s) \n\ns = [2, 4, 6, 8]\nassert fs(f1, s) == fsf1(s) \nassert fs(f2, s) == fsf2(s) \n"}
{"id": 139832, "name": "Associative array_Merging", "source": "Translate Ruby to C#: base = {\"name\" => \"Rocket Skates\", \"price\" => 12.75, \"color\" => \"yellow\"}\nupdate = {\"price\" => 15.25, \"color\" => \"red\", \"year\" => 1974}\n\nresult = base.merge(update)\np result\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\npublic class Program\n{\n    public static void Main() {\n        var baseData = new Dictionary<string, object> {\n            [\"name\"] = \"Rocket Skates\",\n            [\"price\"] = 12.75,\n            [\"color\"] = \"yellow\"\n        };\n        var updateData = new Dictionary<string, object> {\n            [\"price\"] = 15.25,\n            [\"color\"] = \"red\",\n            [\"year\"] = 1974\n        };\n        var mergedData = new Dictionary<string, object>();\n        foreach (var entry in baseData.Concat(updateData)) {\n            mergedData[entry.Key] = entry.Value;\n        }\n        foreach (var entry in mergedData) {\n            Console.WriteLine(entry);\n        }\n   }\n}\n"}
{"id": 139833, "name": "Associative array_Merging", "source": "Translate Ruby to C#: base = {\"name\" => \"Rocket Skates\", \"price\" => 12.75, \"color\" => \"yellow\"}\nupdate = {\"price\" => 15.25, \"color\" => \"red\", \"year\" => 1974}\n\nresult = base.merge(update)\np result\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\npublic class Program\n{\n    public static void Main() {\n        var baseData = new Dictionary<string, object> {\n            [\"name\"] = \"Rocket Skates\",\n            [\"price\"] = 12.75,\n            [\"color\"] = \"yellow\"\n        };\n        var updateData = new Dictionary<string, object> {\n            [\"price\"] = 15.25,\n            [\"color\"] = \"red\",\n            [\"year\"] = 1974\n        };\n        var mergedData = new Dictionary<string, object>();\n        foreach (var entry in baseData.Concat(updateData)) {\n            mergedData[entry.Key] = entry.Value;\n        }\n        foreach (var entry in mergedData) {\n            Console.WriteLine(entry);\n        }\n   }\n}\n"}
{"id": 139836, "name": "Associative array_Merging", "source": "Translate Ruby to Java: base = {\"name\" => \"Rocket Skates\", \"price\" => 12.75, \"color\" => \"yellow\"}\nupdate = {\"price\" => 15.25, \"color\" => \"red\", \"year\" => 1974}\n\nresult = base.merge(update)\np result\n", "target": "import java.util.*;\n\nclass MergeMaps {\n    public static void main(String[] args) {\n        Map<String, Object> base = new HashMap<>();\n        base.put(\"name\", \"Rocket Skates\");\n        base.put(\"price\", 12.75);\n        base.put(\"color\", \"yellow\");\n        Map<String, Object> update = new HashMap<>();\n        update.put(\"price\", 15.25);\n        update.put(\"color\", \"red\");\n        update.put(\"year\", 1974);\n\n        Map<String, Object> result = new HashMap<>(base);\n        result.putAll(update);\n\n        System.out.println(result);\n    }\n}\n"}
{"id": 139837, "name": "Associative array_Merging", "source": "Translate Ruby to Java: base = {\"name\" => \"Rocket Skates\", \"price\" => 12.75, \"color\" => \"yellow\"}\nupdate = {\"price\" => 15.25, \"color\" => \"red\", \"year\" => 1974}\n\nresult = base.merge(update)\np result\n", "target": "import java.util.*;\n\nclass MergeMaps {\n    public static void main(String[] args) {\n        Map<String, Object> base = new HashMap<>();\n        base.put(\"name\", \"Rocket Skates\");\n        base.put(\"price\", 12.75);\n        base.put(\"color\", \"yellow\");\n        Map<String, Object> update = new HashMap<>();\n        update.put(\"price\", 15.25);\n        update.put(\"color\", \"red\");\n        update.put(\"year\", 1974);\n\n        Map<String, Object> result = new HashMap<>(base);\n        result.putAll(update);\n\n        System.out.println(result);\n    }\n}\n"}
{"id": 139838, "name": "Associative array_Merging", "source": "Translate Ruby to Python: base = {\"name\" => \"Rocket Skates\", \"price\" => 12.75, \"color\" => \"yellow\"}\nupdate = {\"price\" => 15.25, \"color\" => \"red\", \"year\" => 1974}\n\nresult = base.merge(update)\np result\n", "target": "base = {\"name\":\"Rocket Skates\", \"price\":12.75, \"color\":\"yellow\"}\nupdate = {\"price\":15.25, \"color\":\"red\", \"year\":1974}\n\nresult = {**base, **update}\n\nprint(result)\n"}
{"id": 139839, "name": "Associative array_Merging", "source": "Translate Ruby to Python: base = {\"name\" => \"Rocket Skates\", \"price\" => 12.75, \"color\" => \"yellow\"}\nupdate = {\"price\" => 15.25, \"color\" => \"red\", \"year\" => 1974}\n\nresult = base.merge(update)\np result\n", "target": "base = {\"name\":\"Rocket Skates\", \"price\":12.75, \"color\":\"yellow\"}\nupdate = {\"price\":15.25, \"color\":\"red\", \"year\":1974}\n\nresult = {**base, **update}\n\nprint(result)\n"}
{"id": 140117, "name": "Associative array_Iteration", "source": "Translate Ruby to C#: dict = { 'def' => 1, 'abc' => 2 }\n\nfor( keyvalue in dict ) io.writeln( keyvalue );\nfor( key in dict.keys(); value in dict.values() ) io.writeln( key, value )\ndict.iterate { [key, value]\n    io.writeln( key, value )\n}\n", "target": "using System;\nusing System.Collections.Generic;\n\nnamespace AssocArrays\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n\n            Dictionary<string,int> assocArray = new Dictionary<string,int>();\n\n            assocArray[\"Hello\"] = 1;\n            assocArray.Add(\"World\", 2);\n            assocArray[\"!\"] = 3;\n\n            foreach (KeyValuePair<string, int> kvp in assocArray)\n            {\n                Console.WriteLine(kvp.Key + \"\u00a0: \" + kvp.Value);\n            }\n\n            foreach (string key in assocArray.Keys)\n            {\n                Console.WriteLine(key);\n            }\n\n            foreach (int val in assocArray.Values)\n            {\n                Console.WriteLine(val.ToString());\n            }\n        }\n    }\n}\n"}
{"id": 140119, "name": "Associative array_Iteration", "source": "Translate Ruby to Java: dict = { 'def' => 1, 'abc' => 2 }\n\nfor( keyvalue in dict ) io.writeln( keyvalue );\nfor( key in dict.keys(); value in dict.values() ) io.writeln( key, value )\ndict.iterate { [key, value]\n    io.writeln( key, value )\n}\n", "target": "Map<String, Integer> map = new HashMap<String, Integer>();\nmap.put(\"hello\", 1);\nmap.put(\"world\", 2);\nmap.put(\"!\", 3);\n\n\nfor (Map.Entry<String, Integer> e : map.entrySet()) {\n    String key = e.getKey();\n    Integer value = e.getValue();\n    System.out.println(\"key = \" + key + \", value = \" + value);\n}\n\n\nfor (String key : map.keySet()) {\n    System.out.println(\"key = \" + key);\n}\n\n\nfor (Integer value : map.values()) {\n    System.out.println(\"value = \" + value);\n}\n"}
{"id": 140120, "name": "Associative array_Iteration", "source": "Translate Ruby to Python: dict = { 'def' => 1, 'abc' => 2 }\n\nfor( keyvalue in dict ) io.writeln( keyvalue );\nfor( key in dict.keys(); value in dict.values() ) io.writeln( key, value )\ndict.iterate { [key, value]\n    io.writeln( key, value )\n}\n", "target": "myDict = { \"hello\": 13,\n\t   \"world\": 31,\n\t   \"!\"    : 71 }\n\n\nfor key, value in myDict.items():\n    print (\"key = %s, value = %s\" % (key, value))\n\n\nfor key in myDict:\n    print (\"key = %s\" % key)\n\nfor key in myDict.keys():\n    print (\"key = %s\" % key)\n\n\nfor value in myDict.values():\n    print (\"value = %s\" % value)\n"}
{"id": 140267, "name": "GUI_Maximum window dimensions", "source": "Translate Ruby to C#: require('Tk')\n\nfunc max_window_size() -> (Number, Number) {\n    %s'MainWindow'.new.maxsize;\n}\n\nvar (width, height) = max_window_size();\nsay (width, 'x', height);\n", "target": "using System;\nusing System.Drawing;\nusing System.Windows.Forms;\n\nstatic class Program\n{\n    static void Main()\n    {\n        Rectangle bounds = Screen.PrimaryScreen.Bounds;\n        Console.WriteLine($\"Primary screen bounds:  {bounds.Width}x{bounds.Height}\");\n\n        Rectangle workingArea = Screen.PrimaryScreen.WorkingArea;\n        Console.WriteLine($\"Primary screen working area:  {workingArea.Width}x{workingArea.Height}\");\n    }\n}\n"}
{"id": 140268, "name": "GUI_Maximum window dimensions", "source": "Translate Ruby to Java: require('Tk')\n\nfunc max_window_size() -> (Number, Number) {\n    %s'MainWindow'.new.maxsize;\n}\n\nvar (width, height) = max_window_size();\nsay (width, 'x', height);\n", "target": "import java.awt.*;\nimport javax.swing.JFrame;\n\npublic class Test extends JFrame {\n\n    public static void main(String[] args) {\n        new Test();\n    }\n\n    Test() {\n        Toolkit toolkit = Toolkit.getDefaultToolkit();\n\n        Dimension screenSize = toolkit.getScreenSize();\n        System.out.println(\"Physical screen size: \" + screenSize);\n\n        Insets insets = toolkit.getScreenInsets(getGraphicsConfiguration());\n        System.out.println(\"Insets: \" + insets);\n\n        screenSize.width -= (insets.left + insets.right);\n        screenSize.height -= (insets.top + insets.bottom);\n        System.out.println(\"Max available: \" + screenSize);\n    }\n}\n"}
{"id": 140269, "name": "GUI_Maximum window dimensions", "source": "Translate Ruby to Python: require('Tk')\n\nfunc max_window_size() -> (Number, Number) {\n    %s'MainWindow'.new.maxsize;\n}\n\nvar (width, height) = max_window_size();\nsay (width, 'x', height);\n", "target": "\n\nimport tkinter as tk \n\nroot = tk.Tk() \nroot.state('zoomed') \nroot.update_idletasks() \ntk.Label(root, text=(str(root.winfo_width())+ \" x \" +str(root.winfo_height())),\n         font=(\"Helvetica\", 25)).pack() \nroot.mainloop()\n"}
{"id": 140457, "name": "Knapsack problem_0-1", "source": "Translate Ruby to C#: require \"bit_array\"\n\nstruct BitArray\n  def clone\n    BitArray.new(size).tap { |new| new.to_slice.copy_from (to_slice) }\n  end\nend\n\nrecord Item, name : String, weight : Int32, value : Int32\n\nrecord Selection, mask : BitArray, cur_index : Int32, total_value : Int32\n\nclass Knapsack\n  @threshold_value = 0\n  @threshold_choice : Selection?\n  getter checked_nodes = 0\n\n  def knapsack_step(taken, items, remaining_weight)\n    if taken.total_value > @threshold_value\n      @threshold_value = taken.total_value\n      @threshold_choice = taken\n    end\n    candidate_index = items.index(taken.cur_index) { |item| item.weight <= remaining_weight }\n    return nil unless candidate_index\n    @checked_nodes += 1\n    candidate = items[candidate_index]\n    \n    \n    return nil if taken.total_value + 1.0 * candidate.value / candidate.weight * remaining_weight < @threshold_value\n    \n    mask = taken.mask.clone\n    mask[candidate_index] = true\n    knapsack_step Selection.new(mask, candidate_index + 1, taken.total_value + candidate.value), items, remaining_weight - candidate.weight\n    mask = taken.mask.clone\n    mask[candidate_index] = false\n    knapsack_step Selection.new(mask, candidate_index + 1, taken.total_value), items, remaining_weight\n  end\n\n  def select(items, max_weight)\n    @checked_variants = 0\n    \n    list = items.sort_by { |item| -1.0 * item.value / item.weight }\n    \n    w = max_weight\n    heur_list = list.take_while { |item| w -= item.weight; w > 0 }\n    nothing = Selection.new(BitArray.new(items.size), 0, 0)\n    @threshold_value = heur_list.sum(&.value) - 1\n    @threshold_choice = nothing\n    knapsack_step(nothing, list, max_weight)\n    selected = @threshold_choice.not_nil!\n    result = [] of Item\n    selected.mask.each_with_index { |v, i| result << list[i] if v }\n    result\n  end\nend\n\npossible = [\n  Item.new(\"map\", 9, 150),\n  Item.new(\"compass\", 13, 35),\n  Item.new(\"water\", 153, 200),\n  Item.new(\"sandwich\", 50, 160),\n  Item.new(\"glucose\", 15, 60),\n  Item.new(\"tin\", 68, 45),\n  Item.new(\"banana\", 27, 60),\n  Item.new(\"apple\", 39, 40),\n  Item.new(\"cheese\", 23, 30),\n  Item.new(\"beer\", 52, 10),\n  Item.new(\"suntan cream\", 11, 70),\n  Item.new(\"camera\", 32, 30),\n  Item.new(\"T-shirt\", 24, 15),\n  Item.new(\"trousers\", 48, 10),\n  Item.new(\"umbrella\", 73, 40),\n  Item.new(\"waterproof trousers\", 42, 70),\n  Item.new(\"waterproof overclothes\", 43, 75),\n  Item.new(\"note-case\", 22, 80),\n  Item.new(\"sunglasses\", 7, 20),\n  Item.new(\"towel\", 18, 12),\n  Item.new(\"socks\", 4, 50),\n  Item.new(\"book\", 30, 10),\n]\n\nsolver = Knapsack.new\nused = solver.select(possible, 400)\nputs \"optimal choice: \nputs \"total weight \nputs \"checked nodes: \n", "target": "using System;\nusing System.Collections.Generic;\n\nnamespace Tests_With_Framework_4\n{\n\nclass Bag : IEnumerable<Bag.Item>\n        {\n            List<Item> items;\n            const int MaxWeightAllowed = 400;\n\n            public Bag()\n            {\n                items = new List<Item>();\n            }\n\n            void AddItem(Item i)\n            {\n                if ((TotalWeight + i.Weight) <= MaxWeightAllowed)\n                    items.Add(i);\n            }\n\n            public void Calculate(List<Item> items)\n            {\n                foreach (Item i in Sorte(items))\n                {\n                    AddItem(i);\n                }\n            }\n\n            List<Item> Sorte(List<Item> inputItems)\n            {\n                List<Item> choosenItems = new List<Item>();\n                for (int i = 0; i < inputItems.Count; i++)\n                {\n                    int j = -1;\n                    if (i == 0)\n                    {\n                        choosenItems.Add(inputItems[i]);\n                    }\n                    if (i > 0)\n                    {\n                        if (!RecursiveF(inputItems, choosenItems, i, choosenItems.Count - 1, false, ref j))\n                        {\n                            choosenItems.Add(inputItems[i]);\n                        }\n                    }\n                }\n                return choosenItems;\n            }\n\n            bool RecursiveF(List<Item> knapsackItems, List<Item> choosenItems, int i, int lastBound, bool dec, ref int indxToAdd)\n            {\n                if (!(lastBound < 0))\n                {\n                    if ( knapsackItems[i].ResultWV < choosenItems[lastBound].ResultWV )\n                    {\n                        indxToAdd = lastBound;\n                    }\n                    return RecursiveF(knapsackItems, choosenItems, i, lastBound - 1, true, ref indxToAdd);\n                }\n                if (indxToAdd > -1)\n                {\n                    choosenItems.Insert(indxToAdd, knapsackItems[i]);\n                    return true;\n                }\n                return false;\n            }\n\n            #region IEnumerable<Item> Members\n            IEnumerator<Item> IEnumerable<Item>.GetEnumerator()\n            {\n                foreach (Item i in items)\n                    yield return i;\n            }\n            #endregion\n\n            #region IEnumerable Members\n            System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()\n            {\n                return items.GetEnumerator();\n            }\n            #endregion\n\n            public int TotalWeight\n            {\n                get\n                {\n                    var sum = 0;\n                    foreach (Item i in this)\n                    {\n                        sum += i.Weight;\n                    }\n                    return sum;\n                }\n            }\n\n            public class Item\n            {\n                public string Name { get; set; } public int Weight { get; set; } public int Value { get; set; } public int ResultWV { get { return  Weight-Value; } }\n                public override string ToString()\n                {\n                    return \"Name\u00a0: \" + Name + \"        Wieght\u00a0: \" + Weight + \"       Value\u00a0: \" + Value + \"     ResultWV\u00a0: \" + ResultWV;\n                }\n            }\n        }\n\n    class Program\n    {\n        static void Main(string[] args)\n        {List<Bag.Item> knapsackItems = new List<Bag.Item>();\n            knapsackItems.Add(new Bag.Item() { Name = \"Map\", Weight = 9, Value = 150 });\n            knapsackItems.Add(new Bag.Item() { Name = \"Water\", Weight = 153, Value = 200 });\n            knapsackItems.Add(new Bag.Item() { Name = \"Compass\", Weight = 13, Value = 35 });\n            knapsackItems.Add(new Bag.Item() { Name = \"Sandwitch\", Weight = 50, Value = 160 });\n            knapsackItems.Add(new Bag.Item() { Name = \"Glucose\", Weight = 15, Value = 60 });\n            knapsackItems.Add(new Bag.Item() { Name = \"Tin\", Weight = 68, Value = 45 });\n            knapsackItems.Add(new Bag.Item() { Name = \"Banana\", Weight = 27, Value = 60 });\n            knapsackItems.Add(new Bag.Item() { Name = \"Apple\", Weight = 39, Value = 40 });\n            knapsackItems.Add(new Bag.Item() { Name = \"Cheese\", Weight = 23, Value = 30 });\n            knapsackItems.Add(new Bag.Item() { Name = \"Beer\", Weight = 52, Value = 10 });\n            knapsackItems.Add(new Bag.Item() { Name = \"Suntan Cream\", Weight = 11, Value = 70 });\n            knapsackItems.Add(new Bag.Item() { Name = \"Camera\", Weight = 32, Value = 30 });\n            knapsackItems.Add(new Bag.Item() { Name = \"T-shirt\", Weight = 24, Value = 15 });\n            knapsackItems.Add(new Bag.Item() { Name = \"Trousers\", Weight = 48, Value = 10 });\n            knapsackItems.Add(new Bag.Item() { Name = \"Umbrella\", Weight = 73, Value = 40 });\n            knapsackItems.Add(new Bag.Item() { Name = \"WaterProof Trousers\", Weight = 42, Value = 70 });\n            knapsackItems.Add(new Bag.Item() { Name = \"Note-Case\", Weight = 22, Value = 80 });\n            knapsackItems.Add(new Bag.Item() { Name = \"Sunglasses\", Weight = 7, Value = 20 });\n            knapsackItems.Add(new Bag.Item() { Name = \"Towel\", Weight = 18, Value = 12 });\n            knapsackItems.Add(new Bag.Item() { Name = \"Socks\", Weight = 4, Value = 50 });\n            knapsackItems.Add(new Bag.Item() { Name = \"Book\", Weight = 30, Value = 10 });\n            knapsackItems.Add(new Bag.Item() { Name = \"waterproof overclothes \", Weight = 43, Value = 75 });\n\n            Bag b = new Bag();\n            b.Calculate(knapsackItems);\n            b.All(x => { Console.WriteLine(x); return true; });\n            Console.WriteLine(b.Sum(x => x.Weight));\n            Console.ReadKey();\n        }\n    }\n}\n"}
{"id": 140459, "name": "Knapsack problem_0-1", "source": "Translate Ruby to Java: require \"bit_array\"\n\nstruct BitArray\n  def clone\n    BitArray.new(size).tap { |new| new.to_slice.copy_from (to_slice) }\n  end\nend\n\nrecord Item, name : String, weight : Int32, value : Int32\n\nrecord Selection, mask : BitArray, cur_index : Int32, total_value : Int32\n\nclass Knapsack\n  @threshold_value = 0\n  @threshold_choice : Selection?\n  getter checked_nodes = 0\n\n  def knapsack_step(taken, items, remaining_weight)\n    if taken.total_value > @threshold_value\n      @threshold_value = taken.total_value\n      @threshold_choice = taken\n    end\n    candidate_index = items.index(taken.cur_index) { |item| item.weight <= remaining_weight }\n    return nil unless candidate_index\n    @checked_nodes += 1\n    candidate = items[candidate_index]\n    \n    \n    return nil if taken.total_value + 1.0 * candidate.value / candidate.weight * remaining_weight < @threshold_value\n    \n    mask = taken.mask.clone\n    mask[candidate_index] = true\n    knapsack_step Selection.new(mask, candidate_index + 1, taken.total_value + candidate.value), items, remaining_weight - candidate.weight\n    mask = taken.mask.clone\n    mask[candidate_index] = false\n    knapsack_step Selection.new(mask, candidate_index + 1, taken.total_value), items, remaining_weight\n  end\n\n  def select(items, max_weight)\n    @checked_variants = 0\n    \n    list = items.sort_by { |item| -1.0 * item.value / item.weight }\n    \n    w = max_weight\n    heur_list = list.take_while { |item| w -= item.weight; w > 0 }\n    nothing = Selection.new(BitArray.new(items.size), 0, 0)\n    @threshold_value = heur_list.sum(&.value) - 1\n    @threshold_choice = nothing\n    knapsack_step(nothing, list, max_weight)\n    selected = @threshold_choice.not_nil!\n    result = [] of Item\n    selected.mask.each_with_index { |v, i| result << list[i] if v }\n    result\n  end\nend\n\npossible = [\n  Item.new(\"map\", 9, 150),\n  Item.new(\"compass\", 13, 35),\n  Item.new(\"water\", 153, 200),\n  Item.new(\"sandwich\", 50, 160),\n  Item.new(\"glucose\", 15, 60),\n  Item.new(\"tin\", 68, 45),\n  Item.new(\"banana\", 27, 60),\n  Item.new(\"apple\", 39, 40),\n  Item.new(\"cheese\", 23, 30),\n  Item.new(\"beer\", 52, 10),\n  Item.new(\"suntan cream\", 11, 70),\n  Item.new(\"camera\", 32, 30),\n  Item.new(\"T-shirt\", 24, 15),\n  Item.new(\"trousers\", 48, 10),\n  Item.new(\"umbrella\", 73, 40),\n  Item.new(\"waterproof trousers\", 42, 70),\n  Item.new(\"waterproof overclothes\", 43, 75),\n  Item.new(\"note-case\", 22, 80),\n  Item.new(\"sunglasses\", 7, 20),\n  Item.new(\"towel\", 18, 12),\n  Item.new(\"socks\", 4, 50),\n  Item.new(\"book\", 30, 10),\n]\n\nsolver = Knapsack.new\nused = solver.select(possible, 400)\nputs \"optimal choice: \nputs \"total weight \nputs \"checked nodes: \n", "target": "package hu.pj.alg.test;\n\nimport hu.pj.alg.ZeroOneKnapsack;\nimport hu.pj.obj.Item;\nimport java.util.*;\nimport java.text.*;\n\npublic class ZeroOneKnapsackForTourists {\n\n    public ZeroOneKnapsackForTourists() {\n        ZeroOneKnapsack zok = new ZeroOneKnapsack(400); \n\n        \n        zok.add(\"map\", 9, 150);\n        zok.add(\"compass\", 13, 35);\n        zok.add(\"water\", 153, 200);\n        zok.add(\"sandwich\", 50, 160);\n        zok.add(\"glucose\", 15, 60);\n        zok.add(\"tin\", 68, 45);\n        zok.add(\"banana\", 27, 60);\n        zok.add(\"apple\", 39, 40);\n        zok.add(\"cheese\", 23, 30);\n        zok.add(\"beer\", 52, 10);\n        zok.add(\"suntan cream\", 11, 70);\n        zok.add(\"camera\", 32, 30);\n        zok.add(\"t-shirt\", 24, 15);\n        zok.add(\"trousers\", 48, 10);\n        zok.add(\"umbrella\", 73, 40);\n        zok.add(\"waterproof trousers\", 42, 70);\n        zok.add(\"waterproof overclothes\", 43, 75);\n        zok.add(\"note-case\", 22, 80);\n        zok.add(\"sunglasses\", 7, 20);\n        zok.add(\"towel\", 18, 12);\n        zok.add(\"socks\", 4, 50);\n        zok.add(\"book\", 30, 10);\n\n        \n        List<Item> itemList = zok.calcSolution();\n\n        \n        if (zok.isCalculated()) {\n            NumberFormat nf  = NumberFormat.getInstance();\n\n            System.out.println(\n                \"Maximal weight           = \" +\n                nf.format(zok.getMaxWeight() / 100.0) + \" kg\"\n            );\n            System.out.println(\n                \"Total weight of solution = \" +\n                nf.format(zok.getSolutionWeight() / 100.0) + \" kg\"\n            );\n            System.out.println(\n                \"Total value              = \" +\n                zok.getProfit()\n            );\n            System.out.println();\n            System.out.println(\n                \"You can carry the following materials \" +\n                \"in the knapsack:\"\n            );\n            for (Item item : itemList) {\n                if (item.getInKnapsack() == 1) {\n                    System.out.format(\n                        \"%1$-23s %2$-3s %3$-5s %4$-15s \\n\",\n                        item.getName(),\n                        item.getWeight(), \"dag  \",\n                        \"(value = \" + item.getValue() + \")\"\n                    );\n                }\n            }\n        } else {\n            System.out.println(\n                \"The problem is not solved. \" +\n                \"Maybe you gave wrong data.\"\n            );\n        }\n\n    }\n\n    public static void main(String[] args) {\n        new ZeroOneKnapsackForTourists();\n    }\n\n} \n"}
{"id": 140460, "name": "Knapsack problem_0-1", "source": "Translate Ruby to Python: require \"bit_array\"\n\nstruct BitArray\n  def clone\n    BitArray.new(size).tap { |new| new.to_slice.copy_from (to_slice) }\n  end\nend\n\nrecord Item, name : String, weight : Int32, value : Int32\n\nrecord Selection, mask : BitArray, cur_index : Int32, total_value : Int32\n\nclass Knapsack\n  @threshold_value = 0\n  @threshold_choice : Selection?\n  getter checked_nodes = 0\n\n  def knapsack_step(taken, items, remaining_weight)\n    if taken.total_value > @threshold_value\n      @threshold_value = taken.total_value\n      @threshold_choice = taken\n    end\n    candidate_index = items.index(taken.cur_index) { |item| item.weight <= remaining_weight }\n    return nil unless candidate_index\n    @checked_nodes += 1\n    candidate = items[candidate_index]\n    \n    \n    return nil if taken.total_value + 1.0 * candidate.value / candidate.weight * remaining_weight < @threshold_value\n    \n    mask = taken.mask.clone\n    mask[candidate_index] = true\n    knapsack_step Selection.new(mask, candidate_index + 1, taken.total_value + candidate.value), items, remaining_weight - candidate.weight\n    mask = taken.mask.clone\n    mask[candidate_index] = false\n    knapsack_step Selection.new(mask, candidate_index + 1, taken.total_value), items, remaining_weight\n  end\n\n  def select(items, max_weight)\n    @checked_variants = 0\n    \n    list = items.sort_by { |item| -1.0 * item.value / item.weight }\n    \n    w = max_weight\n    heur_list = list.take_while { |item| w -= item.weight; w > 0 }\n    nothing = Selection.new(BitArray.new(items.size), 0, 0)\n    @threshold_value = heur_list.sum(&.value) - 1\n    @threshold_choice = nothing\n    knapsack_step(nothing, list, max_weight)\n    selected = @threshold_choice.not_nil!\n    result = [] of Item\n    selected.mask.each_with_index { |v, i| result << list[i] if v }\n    result\n  end\nend\n\npossible = [\n  Item.new(\"map\", 9, 150),\n  Item.new(\"compass\", 13, 35),\n  Item.new(\"water\", 153, 200),\n  Item.new(\"sandwich\", 50, 160),\n  Item.new(\"glucose\", 15, 60),\n  Item.new(\"tin\", 68, 45),\n  Item.new(\"banana\", 27, 60),\n  Item.new(\"apple\", 39, 40),\n  Item.new(\"cheese\", 23, 30),\n  Item.new(\"beer\", 52, 10),\n  Item.new(\"suntan cream\", 11, 70),\n  Item.new(\"camera\", 32, 30),\n  Item.new(\"T-shirt\", 24, 15),\n  Item.new(\"trousers\", 48, 10),\n  Item.new(\"umbrella\", 73, 40),\n  Item.new(\"waterproof trousers\", 42, 70),\n  Item.new(\"waterproof overclothes\", 43, 75),\n  Item.new(\"note-case\", 22, 80),\n  Item.new(\"sunglasses\", 7, 20),\n  Item.new(\"towel\", 18, 12),\n  Item.new(\"socks\", 4, 50),\n  Item.new(\"book\", 30, 10),\n]\n\nsolver = Knapsack.new\nused = solver.select(possible, 400)\nputs \"optimal choice: \nputs \"total weight \nputs \"checked nodes: \n", "target": "from itertools import combinations\n\ndef anycomb(items):\n    ' return combinations of any length from the items '\n    return ( comb\n             for r in range(1, len(items)+1)\n             for comb in combinations(items, r)\n             )\n\ndef totalvalue(comb):\n    ' Totalise a particular combination of items'\n    totwt = totval = 0\n    for item, wt, val in comb:\n        totwt  += wt\n        totval += val\n    return (totval, -totwt) if totwt <= 400 else (0, 0)\n\nitems = (\n    (\"map\", 9, 150), (\"compass\", 13, 35), (\"water\", 153, 200), (\"sandwich\", 50, 160),\n    (\"glucose\", 15, 60), (\"tin\", 68, 45), (\"banana\", 27, 60), (\"apple\", 39, 40),\n    (\"cheese\", 23, 30), (\"beer\", 52, 10), (\"suntan cream\", 11, 70), (\"camera\", 32, 30),\n    (\"t-shirt\", 24, 15), (\"trousers\", 48, 10), (\"umbrella\", 73, 40),\n    (\"waterproof trousers\", 42, 70), (\"waterproof overclothes\", 43, 75),\n    (\"note-case\", 22, 80), (\"sunglasses\", 7, 20), (\"towel\", 18, 12),\n    (\"socks\", 4, 50), (\"book\", 30, 10),\n    )\nbagged = max( anycomb(items), key=totalvalue) \nprint(\"Bagged the following items\\n  \" +\n      '\\n  '.join(sorted(item for item,_,_ in bagged)))\nval, wt = totalvalue(bagged)\nprint(\"for a total value of %i and a total weight of %i\" % (val, -wt))\n"}
{"id": 140920, "name": "Hofstadter-Conway $10,000 sequence", "source": "Translate Ruby to C#: class HofstadterConway10000\n  def initialize\n    @sequence = [nil, 1, 1]\n  end\n  \n  def [](n)\n    raise ArgumentError, \"n must be >= 1\" if n < 1\n    a = @sequence\n    a.length.upto(n) {|i| a[i] = a[a[i-1]] + a[i-a[i-1]] }\n    a[n]\n  end\nend\n\nhc = HofstadterConway10000.new\n\nmallows = nil\n(1...20).each do |i|\n  j = i + 1\n  max_n, max_v = -1, -1\n  (2**i .. 2**j).each do |n|\n    v = hc[n].to_f / n\n    max_n, max_v = n, v if v > max_v\n    \n    mallows = n if v >= 0.55\n  end\n  puts \"maximum between 2^%2d and 2^%2d occurs at%7d:\u00a0%.8f\" % [i, j, max_n, max_v]\nend\n\nputs \"the mallows number is \n", "target": "using System;\nusing System.Linq;\n\nnamespace HofstadterConway\n{\n    class Program\n    {\n        static int[] GenHofstadterConway(int max)\n        {\n            int[] result = new int[max];\n            result[0]=result[1]=1;\n            for (int ix = 2; ix < max; ix++)\n                result[ix] = result[result[ix - 1] - 1] + result[ix - result[ix - 1]];\n            return result;\n        }\n\n        static void Main(string[] args)\n        {\n            double[] adiv = new double[1 << 20];\n            {\n                int[] a = GenHofstadterConway(1 << 20);\n                for (int i = 0; i < 1 << 20; i++)\n                    adiv[i] = a[i] / (double)(i + 1);\n            }\n            for (int p = 2; p <= 20; p++)\n            {\n                var max = Enumerable.Range(\n                     (1 << (p - 1)) - 1,\n                     (1 << p) - (1 << (p - 1))\n                     )\n                     .Select(ix => new { I = ix + 1, A = adiv[ix] })\n                     .OrderByDescending(x => x.A)\n                     .First();\n                Console.WriteLine(\"Maximum from 2^{0} to 2^{1} is {2} at {3}\",\n                    p - 1, p, max.A, max.I);\n            }\n            Console.WriteLine(\"The winning number is {0}.\",\n                Enumerable.Range(0, 1 << 20)\n                    .Last(i => (adiv[i] > 0.55)) + 1\n                );\n        }\n    }\n}\n"}
{"id": 140921, "name": "Hofstadter-Conway $10,000 sequence", "source": "Translate Ruby to C#: class HofstadterConway10000\n  def initialize\n    @sequence = [nil, 1, 1]\n  end\n  \n  def [](n)\n    raise ArgumentError, \"n must be >= 1\" if n < 1\n    a = @sequence\n    a.length.upto(n) {|i| a[i] = a[a[i-1]] + a[i-a[i-1]] }\n    a[n]\n  end\nend\n\nhc = HofstadterConway10000.new\n\nmallows = nil\n(1...20).each do |i|\n  j = i + 1\n  max_n, max_v = -1, -1\n  (2**i .. 2**j).each do |n|\n    v = hc[n].to_f / n\n    max_n, max_v = n, v if v > max_v\n    \n    mallows = n if v >= 0.55\n  end\n  puts \"maximum between 2^%2d and 2^%2d occurs at%7d:\u00a0%.8f\" % [i, j, max_n, max_v]\nend\n\nputs \"the mallows number is \n", "target": "using System;\nusing System.Linq;\n\nnamespace HofstadterConway\n{\n    class Program\n    {\n        static int[] GenHofstadterConway(int max)\n        {\n            int[] result = new int[max];\n            result[0]=result[1]=1;\n            for (int ix = 2; ix < max; ix++)\n                result[ix] = result[result[ix - 1] - 1] + result[ix - result[ix - 1]];\n            return result;\n        }\n\n        static void Main(string[] args)\n        {\n            double[] adiv = new double[1 << 20];\n            {\n                int[] a = GenHofstadterConway(1 << 20);\n                for (int i = 0; i < 1 << 20; i++)\n                    adiv[i] = a[i] / (double)(i + 1);\n            }\n            for (int p = 2; p <= 20; p++)\n            {\n                var max = Enumerable.Range(\n                     (1 << (p - 1)) - 1,\n                     (1 << p) - (1 << (p - 1))\n                     )\n                     .Select(ix => new { I = ix + 1, A = adiv[ix] })\n                     .OrderByDescending(x => x.A)\n                     .First();\n                Console.WriteLine(\"Maximum from 2^{0} to 2^{1} is {2} at {3}\",\n                    p - 1, p, max.A, max.I);\n            }\n            Console.WriteLine(\"The winning number is {0}.\",\n                Enumerable.Range(0, 1 << 20)\n                    .Last(i => (adiv[i] > 0.55)) + 1\n                );\n        }\n    }\n}\n"}
{"id": 140924, "name": "Hofstadter-Conway $10,000 sequence", "source": "Translate Ruby to Java: class HofstadterConway10000\n  def initialize\n    @sequence = [nil, 1, 1]\n  end\n  \n  def [](n)\n    raise ArgumentError, \"n must be >= 1\" if n < 1\n    a = @sequence\n    a.length.upto(n) {|i| a[i] = a[a[i-1]] + a[i-a[i-1]] }\n    a[n]\n  end\nend\n\nhc = HofstadterConway10000.new\n\nmallows = nil\n(1...20).each do |i|\n  j = i + 1\n  max_n, max_v = -1, -1\n  (2**i .. 2**j).each do |n|\n    v = hc[n].to_f / n\n    max_n, max_v = n, v if v > max_v\n    \n    mallows = n if v >= 0.55\n  end\n  puts \"maximum between 2^%2d and 2^%2d occurs at%7d:\u00a0%.8f\" % [i, j, max_n, max_v]\nend\n\nputs \"the mallows number is \n", "target": "\n\npublic class HofstadterConwaySequence {\n\n    private static int MAX = (int) Math.pow(2, 20) + 1;\n    private static int[] HCS = new int[MAX];\n    static {\n        HCS[1] = 1;\n        HCS[2] = 1;\n        for ( int n = 3 ; n < MAX ; n++ ) {\n            int nm1 = HCS[n - 1];\n            HCS[n] = HCS[nm1] + HCS[n - nm1];\n        }\n    }\n    \n    public static void main(String[] args) {\n        int mNum = 0;\n        for ( int m = 1 ; m < 20 ; m++ ) {\n            int min = (int) Math.pow(2, m);\n            int max = min * 2;\n            double maxRatio = 0.0;\n            int nVal = 0;\n            for ( int n = min ; n <= max ; n ++ ) {\n                double ratio = (double) HCS[n] / n;\n                if ( ratio > maxRatio ) {\n                    maxRatio = Math.max(ratio,  maxRatio);\n                    nVal = n;\n                }\n                if ( ratio >= 0.55 ) {\n                    mNum = n;\n                }\n            }\n            System.out.printf(\"Max ratio between 2^%d and 2^%d is %f at n =\u00a0%,d%n\", m, m+1, maxRatio, nVal);\n        }\n        System.out.printf(\"Mallow's number is %d.%n\", mNum);\n    }\n\n}\n"}
{"id": 140925, "name": "Hofstadter-Conway $10,000 sequence", "source": "Translate Ruby to Java: class HofstadterConway10000\n  def initialize\n    @sequence = [nil, 1, 1]\n  end\n  \n  def [](n)\n    raise ArgumentError, \"n must be >= 1\" if n < 1\n    a = @sequence\n    a.length.upto(n) {|i| a[i] = a[a[i-1]] + a[i-a[i-1]] }\n    a[n]\n  end\nend\n\nhc = HofstadterConway10000.new\n\nmallows = nil\n(1...20).each do |i|\n  j = i + 1\n  max_n, max_v = -1, -1\n  (2**i .. 2**j).each do |n|\n    v = hc[n].to_f / n\n    max_n, max_v = n, v if v > max_v\n    \n    mallows = n if v >= 0.55\n  end\n  puts \"maximum between 2^%2d and 2^%2d occurs at%7d:\u00a0%.8f\" % [i, j, max_n, max_v]\nend\n\nputs \"the mallows number is \n", "target": "\n\npublic class HofstadterConwaySequence {\n\n    private static int MAX = (int) Math.pow(2, 20) + 1;\n    private static int[] HCS = new int[MAX];\n    static {\n        HCS[1] = 1;\n        HCS[2] = 1;\n        for ( int n = 3 ; n < MAX ; n++ ) {\n            int nm1 = HCS[n - 1];\n            HCS[n] = HCS[nm1] + HCS[n - nm1];\n        }\n    }\n    \n    public static void main(String[] args) {\n        int mNum = 0;\n        for ( int m = 1 ; m < 20 ; m++ ) {\n            int min = (int) Math.pow(2, m);\n            int max = min * 2;\n            double maxRatio = 0.0;\n            int nVal = 0;\n            for ( int n = min ; n <= max ; n ++ ) {\n                double ratio = (double) HCS[n] / n;\n                if ( ratio > maxRatio ) {\n                    maxRatio = Math.max(ratio,  maxRatio);\n                    nVal = n;\n                }\n                if ( ratio >= 0.55 ) {\n                    mNum = n;\n                }\n            }\n            System.out.printf(\"Max ratio between 2^%d and 2^%d is %f at n =\u00a0%,d%n\", m, m+1, maxRatio, nVal);\n        }\n        System.out.printf(\"Mallow's number is %d.%n\", mNum);\n    }\n\n}\n"}
{"id": 140926, "name": "Hofstadter-Conway $10,000 sequence", "source": "Translate Ruby to Python: class HofstadterConway10000\n  def initialize\n    @sequence = [nil, 1, 1]\n  end\n  \n  def [](n)\n    raise ArgumentError, \"n must be >= 1\" if n < 1\n    a = @sequence\n    a.length.upto(n) {|i| a[i] = a[a[i-1]] + a[i-a[i-1]] }\n    a[n]\n  end\nend\n\nhc = HofstadterConway10000.new\n\nmallows = nil\n(1...20).each do |i|\n  j = i + 1\n  max_n, max_v = -1, -1\n  (2**i .. 2**j).each do |n|\n    v = hc[n].to_f / n\n    max_n, max_v = n, v if v > max_v\n    \n    mallows = n if v >= 0.55\n  end\n  puts \"maximum between 2^%2d and 2^%2d occurs at%7d:\u00a0%.8f\" % [i, j, max_n, max_v]\nend\n\nputs \"the mallows number is \n", "target": "from __future__ import division\n\ndef maxandmallows(nmaxpower2):\n    nmax = 2**nmaxpower2\n    mx = (0.5, 2)\n    mxpow2 = []\n    mallows = None\n\n    \n    \n    hc = [None, 1, 1]\n\n    for n in range(2, nmax + 1):\n        ratio = hc[n] / n\n        if ratio > mx[0]:\n            mx = (ratio, n)\n        if ratio >= 0.55:\n            mallows = n\n        if ratio == 0.5:\n            print(\"In the region %7i < n <= %7i: max a(n)/n = %6.4f at  n = %i\" %\n\t\t  (n//2, n, mx[0], mx[1]))\n            mxpow2.append(mx[0])\n            mx = (ratio, n)\n        hc.append(hc[hc[n]] + hc[-hc[n]])\n\n    return hc, mallows if mxpow2 and mxpow2[-1] < 0.55 and n > 4 else None\n\nif __name__ == '__main__':\n    hc, mallows = maxandmallows(20)\n    if mallows:\n        print(\"\\nYou too might have won $1000 with the mallows number of %i\" % mallows)\n"}
{"id": 140927, "name": "Hofstadter-Conway $10,000 sequence", "source": "Translate Ruby to Python: class HofstadterConway10000\n  def initialize\n    @sequence = [nil, 1, 1]\n  end\n  \n  def [](n)\n    raise ArgumentError, \"n must be >= 1\" if n < 1\n    a = @sequence\n    a.length.upto(n) {|i| a[i] = a[a[i-1]] + a[i-a[i-1]] }\n    a[n]\n  end\nend\n\nhc = HofstadterConway10000.new\n\nmallows = nil\n(1...20).each do |i|\n  j = i + 1\n  max_n, max_v = -1, -1\n  (2**i .. 2**j).each do |n|\n    v = hc[n].to_f / n\n    max_n, max_v = n, v if v > max_v\n    \n    mallows = n if v >= 0.55\n  end\n  puts \"maximum between 2^%2d and 2^%2d occurs at%7d:\u00a0%.8f\" % [i, j, max_n, max_v]\nend\n\nputs \"the mallows number is \n", "target": "from __future__ import division\n\ndef maxandmallows(nmaxpower2):\n    nmax = 2**nmaxpower2\n    mx = (0.5, 2)\n    mxpow2 = []\n    mallows = None\n\n    \n    \n    hc = [None, 1, 1]\n\n    for n in range(2, nmax + 1):\n        ratio = hc[n] / n\n        if ratio > mx[0]:\n            mx = (ratio, n)\n        if ratio >= 0.55:\n            mallows = n\n        if ratio == 0.5:\n            print(\"In the region %7i < n <= %7i: max a(n)/n = %6.4f at  n = %i\" %\n\t\t  (n//2, n, mx[0], mx[1]))\n            mxpow2.append(mx[0])\n            mx = (ratio, n)\n        hc.append(hc[hc[n]] + hc[-hc[n]])\n\n    return hc, mallows if mxpow2 and mxpow2[-1] < 0.55 and n > 4 else None\n\nif __name__ == '__main__':\n    hc, mallows = maxandmallows(20)\n    if mallows:\n        print(\"\\nYou too might have won $1000 with the mallows number of %i\" % mallows)\n"}
{"id": 141144, "name": "Bitmap", "source": "Translate Ruby to C#: class RGBColor\n  getter red, green, blue\n\n  def initialize(@red = 0_u8, @green = 0_u8, @blue = 0_u8)\n  end\n \n  RED   = new(red: 255_u8)\n  GREEN = new(green: 255_u8)\n  BLUE  = new(blue: 255_u8)\n  BLACK = new\n  WHITE = new(255_u8, 255_u8, 255_u8)\nend\n\nclass Pixmap\n  getter width, height\n  @data : Array(Array(RGBColor))\n\n  def initialize(@width : Int32, @height : Int32)\n    @data = Array.new(@width) { Array.new(@height, RGBColor::WHITE) }\n  end\n\n  def fill(color)\n    @data.each &.fill(color)\n  end\n\n  def [](x, y)\n    @data[x][y]\n  end\n\n  def []=(x, y, color)\n    @data[x][y] = color\n  end\nend\n\nbmap = Pixmap.new(5, 5)\npp bmap\n", "target": "public class Bitmap\n{\n    public struct Color\n    {\n        public byte Red { get; set; }\n        public byte Blue { get; set; }\n        public byte Green { get; set; }\n    }\n    Color[,] _imagemap;\n    public int Width { get { return _imagemap.GetLength(0); } }\n    public int Height { get { return _imagemap.GetLength(1); } }\n    public Bitmap(int width, int height)\n    {\n        _imagemap = new Color[width, height];\n    }\n    public void Fill(Color color)\n    {\n        for (int y = 0; y < Height; y++)\n            for (int x = 0; x < Width; x++)\n            {\n                _imagemap[x, y] = color;\n            }\n    }\n    public Color GetPixel(int x, int y)\n    {\n        return _imagemap[x, y];\n    }\n    public void SetPixel(int x, int y, Color color)\n    {\n        _imagemap[x, y] = color;\n    }\n}\n"}
{"id": 141350, "name": "Tokenize a string with escaping", "source": "Translate Ruby to C#: def tokenize(string, sep, esc)\n  sep = Regexp.escape(sep)\n  esc = Regexp.escape(esc)\n  string.scan(/\\G (?:^ | \n    m.gsub(/\n  end\nend\n\np tokenize('one^|uno||three^^^^|four^^^|^cuatro|', '|', '^')\n", "target": "using System;\nusing System.Text;\nusing System.Collections.Generic;\n\npublic class TokenizeAStringWithEscaping\n{\n    public static void Main() {\n        string testcase = \"one^|uno||three^^^^|four^^^|^cuatro|\";\n        foreach (var token in testcase.Tokenize(separator: '|', escape: '^')) {\n            Console.WriteLine(\": \" + token); \n        }\n    }\n}\n\npublic static class Extensions\n{\n    public static IEnumerable<string> Tokenize(this string input, char separator, char escape) {\n        if (input == null) yield break;\n        var buffer = new StringBuilder();\n        bool escaping = false;\n        foreach (char c in input) {\n            if (escaping) {\n                buffer.Append(c);\n                escaping = false;\n            } else if (c == escape) {\n                escaping = true;\n            } else if (c == separator) {\n                yield return buffer.Flush();\n            } else {\n                buffer.Append(c);\n            }\n        }\n        if (buffer.Length > 0 || input[input.Length-1] == separator) yield return buffer.Flush();\n    }\n    \n    public static string Flush(this StringBuilder stringBuilder) {\n        string result = stringBuilder.ToString();\n        stringBuilder.Clear();\n        return result;\n    }\n}\n"}
{"id": 141352, "name": "Tokenize a string with escaping", "source": "Translate Ruby to Java: def tokenize(string, sep, esc)\n  sep = Regexp.escape(sep)\n  esc = Regexp.escape(esc)\n  string.scan(/\\G (?:^ | \n    m.gsub(/\n  end\nend\n\np tokenize('one^|uno||three^^^^|four^^^|^cuatro|', '|', '^')\n", "target": "import java.util.*;\n\npublic class TokenizeStringWithEscaping {\n\n    public static void main(String[] args) {\n        String sample = \"one^|uno||three^^^^|four^^^|^cuatro|\";\n        char separator = '|';\n        char escape = '^';\n\n        System.out.println(sample);\n        try {\n            System.out.println(tokenizeString(sample, separator, escape));\n        } catch (Exception e) {\n            System.out.println(e);\n        }\n    }\n\n    public static List<String> tokenizeString(String s, char sep, char escape)\n            throws Exception {\n        List<String> tokens = new ArrayList<>();\n        StringBuilder sb = new StringBuilder();\n\n        boolean inEscape = false;\n        for (char c : s.toCharArray()) {\n            if (inEscape) {\n                inEscape = false;\n            } else if (c == escape) {\n                inEscape = true;\n                continue;\n            } else if (c == sep) {\n                tokens.add(sb.toString());\n                sb.setLength(0);\n                continue;\n            }\n            sb.append(c);\n        }\n        if (inEscape)\n            throw new Exception(\"Invalid terminal escape\");\n\n        tokens.add(sb.toString());\n\n        return tokens;\n    }\n}\n"}
{"id": 141353, "name": "Tokenize a string with escaping", "source": "Translate Ruby to Python: def tokenize(string, sep, esc)\n  sep = Regexp.escape(sep)\n  esc = Regexp.escape(esc)\n  string.scan(/\\G (?:^ | \n    m.gsub(/\n  end\nend\n\np tokenize('one^|uno||three^^^^|four^^^|^cuatro|', '|', '^')\n", "target": "def token_with_escape(a, escape = '^', separator = '|'):\n    \n    result = []\n    token = ''\n    state = 0\n    for c in a:\n        if state == 0:\n            if c == escape:\n                state = 1\n            elif c == separator:\n                result.append(token)\n                token = ''\n            else:\n                token += c\n        elif state == 1:\n            token += c\n            state = 0\n    result.append(token)\n    return result\n"}
{"id": 141707, "name": "Damm algorithm", "source": "Translate Ruby to C#: TABLE = [\n    [0,3,1,7,5,9,8,6,4,2], [7,0,9,2,1,5,4,8,6,3],\n    [4,2,0,6,8,7,1,3,5,9], [1,7,5,0,9,8,3,4,2,6],\n    [6,1,2,3,0,4,5,9,7,8], [3,6,7,4,2,0,9,5,8,1],\n    [5,8,6,9,7,2,0,1,3,4], [8,9,4,5,3,6,2,0,1,7],\n    [9,4,3,8,6,1,7,2,0,5], [2,5,8,1,4,3,6,7,9,0]\n]\n\ndef damm_valid?(n) = n.digits.reverse.inject(0){|idx, a| TABLE[idx][a] } == 0\n\n[5724, 5727, 112946].each{|n| puts \"\n", "target": "using System;\n\nnamespace DammAlgorithm {\n    class Program {\n        static int[,] table = {\n            {0, 3, 1, 7, 5, 9, 8, 6, 4, 2},\n            {7, 0, 9, 2, 1, 5, 4, 8, 6, 3},\n            {4, 2, 0, 6, 8, 7, 1, 3, 5, 9},\n            {1, 7, 5, 0, 9, 8, 3, 4, 2, 6},\n            {6, 1, 2, 3, 0, 4, 5, 9, 7, 8},\n            {3, 6, 7, 4, 2, 0, 9, 5, 8, 1},\n            {5, 8, 6, 9, 7, 2, 0, 1, 3, 4},\n            {8, 9, 4, 5, 3, 6, 2, 0, 1, 7},\n            {9, 4, 3, 8, 6, 1, 7, 2, 0, 5},\n            {2, 5, 8, 1, 4, 3, 6, 7, 9, 0},\n        };\n\n        static bool Damm(string s) {\n            int interim = 0;\n            foreach (char c in s) {\n                interim = table[interim, c - '0'];\n            }\n            return interim == 0;\n        }\n\n        static void Main(string[] args) {\n            int[] numbers = { 5724, 5727, 112946, 112949 };\n            foreach (int number in numbers) {\n                bool isValid = Damm(number.ToString());\n                if (isValid) {\n                    Console.WriteLine(\"{0,6} is valid\", number);\n                }\n                else {\n                    Console.WriteLine(\"{0,6} is invalid\", number);\n                }\n            }\n        }\n    }\n}\n"}
{"id": 141708, "name": "Damm algorithm", "source": "Translate Ruby to C#: TABLE = [\n    [0,3,1,7,5,9,8,6,4,2], [7,0,9,2,1,5,4,8,6,3],\n    [4,2,0,6,8,7,1,3,5,9], [1,7,5,0,9,8,3,4,2,6],\n    [6,1,2,3,0,4,5,9,7,8], [3,6,7,4,2,0,9,5,8,1],\n    [5,8,6,9,7,2,0,1,3,4], [8,9,4,5,3,6,2,0,1,7],\n    [9,4,3,8,6,1,7,2,0,5], [2,5,8,1,4,3,6,7,9,0]\n]\n\ndef damm_valid?(n) = n.digits.reverse.inject(0){|idx, a| TABLE[idx][a] } == 0\n\n[5724, 5727, 112946].each{|n| puts \"\n", "target": "using System;\n\nnamespace DammAlgorithm {\n    class Program {\n        static int[,] table = {\n            {0, 3, 1, 7, 5, 9, 8, 6, 4, 2},\n            {7, 0, 9, 2, 1, 5, 4, 8, 6, 3},\n            {4, 2, 0, 6, 8, 7, 1, 3, 5, 9},\n            {1, 7, 5, 0, 9, 8, 3, 4, 2, 6},\n            {6, 1, 2, 3, 0, 4, 5, 9, 7, 8},\n            {3, 6, 7, 4, 2, 0, 9, 5, 8, 1},\n            {5, 8, 6, 9, 7, 2, 0, 1, 3, 4},\n            {8, 9, 4, 5, 3, 6, 2, 0, 1, 7},\n            {9, 4, 3, 8, 6, 1, 7, 2, 0, 5},\n            {2, 5, 8, 1, 4, 3, 6, 7, 9, 0},\n        };\n\n        static bool Damm(string s) {\n            int interim = 0;\n            foreach (char c in s) {\n                interim = table[interim, c - '0'];\n            }\n            return interim == 0;\n        }\n\n        static void Main(string[] args) {\n            int[] numbers = { 5724, 5727, 112946, 112949 };\n            foreach (int number in numbers) {\n                bool isValid = Damm(number.ToString());\n                if (isValid) {\n                    Console.WriteLine(\"{0,6} is valid\", number);\n                }\n                else {\n                    Console.WriteLine(\"{0,6} is invalid\", number);\n                }\n            }\n        }\n    }\n}\n"}
{"id": 141711, "name": "Damm algorithm", "source": "Translate Ruby to Java: TABLE = [\n    [0,3,1,7,5,9,8,6,4,2], [7,0,9,2,1,5,4,8,6,3],\n    [4,2,0,6,8,7,1,3,5,9], [1,7,5,0,9,8,3,4,2,6],\n    [6,1,2,3,0,4,5,9,7,8], [3,6,7,4,2,0,9,5,8,1],\n    [5,8,6,9,7,2,0,1,3,4], [8,9,4,5,3,6,2,0,1,7],\n    [9,4,3,8,6,1,7,2,0,5], [2,5,8,1,4,3,6,7,9,0]\n]\n\ndef damm_valid?(n) = n.digits.reverse.inject(0){|idx, a| TABLE[idx][a] } == 0\n\n[5724, 5727, 112946].each{|n| puts \"\n", "target": "public class DammAlgorithm {\n    private static final int[][] table = {\n        {0, 3, 1, 7, 5, 9, 8, 6, 4, 2},\n        {7, 0, 9, 2, 1, 5, 4, 8, 6, 3},\n        {4, 2, 0, 6, 8, 7, 1, 3, 5, 9},\n        {1, 7, 5, 0, 9, 8, 3, 4, 2, 6},\n        {6, 1, 2, 3, 0, 4, 5, 9, 7, 8},\n        {3, 6, 7, 4, 2, 0, 9, 5, 8, 1},\n        {5, 8, 6, 9, 7, 2, 0, 1, 3, 4},\n        {8, 9, 4, 5, 3, 6, 2, 0, 1, 7},\n        {9, 4, 3, 8, 6, 1, 7, 2, 0, 5},\n        {2, 5, 8, 1, 4, 3, 6, 7, 9, 0},\n    };\n\n    private static boolean damm(String s) {\n        int interim = 0;\n        for (char c : s.toCharArray()) interim = table[interim][c - '0'];\n        return interim == 0;\n    }\n\n    public static void main(String[] args) {\n        int[] numbers = {5724, 5727, 112946, 112949};\n        for (Integer number : numbers) {\n            boolean isValid = damm(number.toString());\n            if (isValid) {\n                System.out.printf(\"%6d is valid\\n\", number);\n            } else {\n                System.out.printf(\"%6d is invalid\\n\", number);\n            }\n        }\n    }\n}\n"}
{"id": 141712, "name": "Damm algorithm", "source": "Translate Ruby to Java: TABLE = [\n    [0,3,1,7,5,9,8,6,4,2], [7,0,9,2,1,5,4,8,6,3],\n    [4,2,0,6,8,7,1,3,5,9], [1,7,5,0,9,8,3,4,2,6],\n    [6,1,2,3,0,4,5,9,7,8], [3,6,7,4,2,0,9,5,8,1],\n    [5,8,6,9,7,2,0,1,3,4], [8,9,4,5,3,6,2,0,1,7],\n    [9,4,3,8,6,1,7,2,0,5], [2,5,8,1,4,3,6,7,9,0]\n]\n\ndef damm_valid?(n) = n.digits.reverse.inject(0){|idx, a| TABLE[idx][a] } == 0\n\n[5724, 5727, 112946].each{|n| puts \"\n", "target": "public class DammAlgorithm {\n    private static final int[][] table = {\n        {0, 3, 1, 7, 5, 9, 8, 6, 4, 2},\n        {7, 0, 9, 2, 1, 5, 4, 8, 6, 3},\n        {4, 2, 0, 6, 8, 7, 1, 3, 5, 9},\n        {1, 7, 5, 0, 9, 8, 3, 4, 2, 6},\n        {6, 1, 2, 3, 0, 4, 5, 9, 7, 8},\n        {3, 6, 7, 4, 2, 0, 9, 5, 8, 1},\n        {5, 8, 6, 9, 7, 2, 0, 1, 3, 4},\n        {8, 9, 4, 5, 3, 6, 2, 0, 1, 7},\n        {9, 4, 3, 8, 6, 1, 7, 2, 0, 5},\n        {2, 5, 8, 1, 4, 3, 6, 7, 9, 0},\n    };\n\n    private static boolean damm(String s) {\n        int interim = 0;\n        for (char c : s.toCharArray()) interim = table[interim][c - '0'];\n        return interim == 0;\n    }\n\n    public static void main(String[] args) {\n        int[] numbers = {5724, 5727, 112946, 112949};\n        for (Integer number : numbers) {\n            boolean isValid = damm(number.toString());\n            if (isValid) {\n                System.out.printf(\"%6d is valid\\n\", number);\n            } else {\n                System.out.printf(\"%6d is invalid\\n\", number);\n            }\n        }\n    }\n}\n"}
{"id": 141713, "name": "Damm algorithm", "source": "Translate Ruby to Python: TABLE = [\n    [0,3,1,7,5,9,8,6,4,2], [7,0,9,2,1,5,4,8,6,3],\n    [4,2,0,6,8,7,1,3,5,9], [1,7,5,0,9,8,3,4,2,6],\n    [6,1,2,3,0,4,5,9,7,8], [3,6,7,4,2,0,9,5,8,1],\n    [5,8,6,9,7,2,0,1,3,4], [8,9,4,5,3,6,2,0,1,7],\n    [9,4,3,8,6,1,7,2,0,5], [2,5,8,1,4,3,6,7,9,0]\n]\n\ndef damm_valid?(n) = n.digits.reverse.inject(0){|idx, a| TABLE[idx][a] } == 0\n\n[5724, 5727, 112946].each{|n| puts \"\n", "target": "def damm(num: int) -> bool:\n    row = 0\n    for digit in str(num):\n        row = _matrix[row][int(digit)] \n    return row == 0\n\n_matrix = (\n    (0, 3, 1, 7, 5, 9, 8, 6, 4, 2),\n    (7, 0, 9, 2, 1, 5, 4, 8, 6, 3),\n    (4, 2, 0, 6, 8, 7, 1, 3, 5, 9),\n    (1, 7, 5, 0, 9, 8, 3, 4, 2, 6),\n    (6, 1, 2, 3, 0, 4, 5, 9, 7, 8),\n    (3, 6, 7, 4, 2, 0, 9, 5, 8, 1),\n    (5, 8, 6, 9, 7, 2, 0, 1, 3, 4),\n    (8, 9, 4, 5, 3, 6, 2, 0, 1, 7),\n    (9, 4, 3, 8, 6, 1, 7, 2, 0, 5),\n    (2, 5, 8, 1, 4, 3, 6, 7, 9, 0)\n)\n\nif __name__ == '__main__':\n    for test in [5724, 5727, 112946]:\n        print(f'{test}\\t Validates as: {damm(test)}')\n"}
{"id": 141714, "name": "Damm algorithm", "source": "Translate Ruby to Python: TABLE = [\n    [0,3,1,7,5,9,8,6,4,2], [7,0,9,2,1,5,4,8,6,3],\n    [4,2,0,6,8,7,1,3,5,9], [1,7,5,0,9,8,3,4,2,6],\n    [6,1,2,3,0,4,5,9,7,8], [3,6,7,4,2,0,9,5,8,1],\n    [5,8,6,9,7,2,0,1,3,4], [8,9,4,5,3,6,2,0,1,7],\n    [9,4,3,8,6,1,7,2,0,5], [2,5,8,1,4,3,6,7,9,0]\n]\n\ndef damm_valid?(n) = n.digits.reverse.inject(0){|idx, a| TABLE[idx][a] } == 0\n\n[5724, 5727, 112946].each{|n| puts \"\n", "target": "def damm(num: int) -> bool:\n    row = 0\n    for digit in str(num):\n        row = _matrix[row][int(digit)] \n    return row == 0\n\n_matrix = (\n    (0, 3, 1, 7, 5, 9, 8, 6, 4, 2),\n    (7, 0, 9, 2, 1, 5, 4, 8, 6, 3),\n    (4, 2, 0, 6, 8, 7, 1, 3, 5, 9),\n    (1, 7, 5, 0, 9, 8, 3, 4, 2, 6),\n    (6, 1, 2, 3, 0, 4, 5, 9, 7, 8),\n    (3, 6, 7, 4, 2, 0, 9, 5, 8, 1),\n    (5, 8, 6, 9, 7, 2, 0, 1, 3, 4),\n    (8, 9, 4, 5, 3, 6, 2, 0, 1, 7),\n    (9, 4, 3, 8, 6, 1, 7, 2, 0, 5),\n    (2, 5, 8, 1, 4, 3, 6, 7, 9, 0)\n)\n\nif __name__ == '__main__':\n    for test in [5724, 5727, 112946]:\n        print(f'{test}\\t Validates as: {damm(test)}')\n"}
{"id": 141996, "name": "Apply a digital filter (direct form II transposed)", "source": "Translate Ruby to C#: def filter(a,b,signal)\n    result = Array.new(signal.length(), 0.0)\n    for i in 0..signal.length()-1 do\n        tmp = 0.0\n        for j in 0 .. b.length()-1 do\n            if i - j < 0 then next end\n            tmp += b[j] * signal[i - j]\n        end\n        for j in 1 .. a.length()-1 do\n            if i - j < 0 then next end\n            tmp -= a[j] * result[i - j]\n        end\n        tmp /= a[0]\n        result[i] = tmp\n    end\n    return result\nend\n\ndef main\n    a = [1.00000000, -2.77555756e-16, 3.33333333e-01, -1.85037171e-17]\n    b = [0.16666667, 0.5, 0.5, 0.16666667]\n    signal = [\n        -0.917843918645,  0.141984778794, 1.20536903482,   0.190286794412,\n        -0.662370894973, -1.00700480494, -0.404707073677,  0.800482325044,\n         0.743500089861,  1.01090520172,  0.741527555207,  0.277841675195,\n         0.400833448236, -0.2085993586,  -0.172842103641, -0.134316096293,\n         0.0259303398477, 0.490105989562, 0.549391221511,  0.9047198589\n    ]\n\n    result = filter(a,b,signal)\n    for i in 0 .. result.length() - 1 do\n        print \"%11.8f\" % [result[i]]\n        if (i + 1) % 5 == 0 then\n            print \"\\n\"\n        else\n            print \", \"\n        end\n    end\nend\n\nmain()\n", "target": "using System;\n\nnamespace ApplyDigitalFilter {\n    class Program {\n        private static double[] Filter(double[] a, double[] b, double[] signal) {\n            double[] result = new double[signal.Length];\n            for (int i = 0; i < signal.Length; ++i) {\n                double tmp = 0.0;\n                for (int j = 0; j < b.Length; ++j) {\n                    if (i - j < 0) continue;\n                    tmp += b[j] * signal[i - j];\n                }\n                for (int j = 1; j < a.Length; ++j) {\n                    if (i - j < 0) continue;\n                    tmp -= a[j] * result[i - j];\n                }\n                tmp /= a[0];\n                result[i] = tmp;\n            }\n            return result;\n        }\n\n        static void Main(string[] args) {\n            double[] a = new double[] { 1.00000000, -2.77555756e-16, 3.33333333e-01, -1.85037171e-17 };\n            double[] b = new double[] { 0.16666667, 0.5, 0.5, 0.16666667 };\n\n            double[] signal = new double[] {\n                -0.917843918645, 0.141984778794, 1.20536903482, 0.190286794412,\n                -0.662370894973, -1.00700480494, -0.404707073677, 0.800482325044,\n                0.743500089861, 1.01090520172, 0.741527555207, 0.277841675195,\n                0.400833448236, -0.2085993586, -0.172842103641, -0.134316096293,\n                0.0259303398477, 0.490105989562, 0.549391221511, 0.9047198589\n            };\n\n            double[] result = Filter(a, b, signal);\n            for (int i = 0; i < result.Length; ++i) {\n                Console.Write(\"{0,11:F8}\", result[i]);\n                Console.Write((i + 1) % 5 != 0 ? \", \" : \"\\n\");\n            }\n        }\n    }\n}\n"}
{"id": 141997, "name": "Apply a digital filter (direct form II transposed)", "source": "Translate Ruby to C#: def filter(a,b,signal)\n    result = Array.new(signal.length(), 0.0)\n    for i in 0..signal.length()-1 do\n        tmp = 0.0\n        for j in 0 .. b.length()-1 do\n            if i - j < 0 then next end\n            tmp += b[j] * signal[i - j]\n        end\n        for j in 1 .. a.length()-1 do\n            if i - j < 0 then next end\n            tmp -= a[j] * result[i - j]\n        end\n        tmp /= a[0]\n        result[i] = tmp\n    end\n    return result\nend\n\ndef main\n    a = [1.00000000, -2.77555756e-16, 3.33333333e-01, -1.85037171e-17]\n    b = [0.16666667, 0.5, 0.5, 0.16666667]\n    signal = [\n        -0.917843918645,  0.141984778794, 1.20536903482,   0.190286794412,\n        -0.662370894973, -1.00700480494, -0.404707073677,  0.800482325044,\n         0.743500089861,  1.01090520172,  0.741527555207,  0.277841675195,\n         0.400833448236, -0.2085993586,  -0.172842103641, -0.134316096293,\n         0.0259303398477, 0.490105989562, 0.549391221511,  0.9047198589\n    ]\n\n    result = filter(a,b,signal)\n    for i in 0 .. result.length() - 1 do\n        print \"%11.8f\" % [result[i]]\n        if (i + 1) % 5 == 0 then\n            print \"\\n\"\n        else\n            print \", \"\n        end\n    end\nend\n\nmain()\n", "target": "using System;\n\nnamespace ApplyDigitalFilter {\n    class Program {\n        private static double[] Filter(double[] a, double[] b, double[] signal) {\n            double[] result = new double[signal.Length];\n            for (int i = 0; i < signal.Length; ++i) {\n                double tmp = 0.0;\n                for (int j = 0; j < b.Length; ++j) {\n                    if (i - j < 0) continue;\n                    tmp += b[j] * signal[i - j];\n                }\n                for (int j = 1; j < a.Length; ++j) {\n                    if (i - j < 0) continue;\n                    tmp -= a[j] * result[i - j];\n                }\n                tmp /= a[0];\n                result[i] = tmp;\n            }\n            return result;\n        }\n\n        static void Main(string[] args) {\n            double[] a = new double[] { 1.00000000, -2.77555756e-16, 3.33333333e-01, -1.85037171e-17 };\n            double[] b = new double[] { 0.16666667, 0.5, 0.5, 0.16666667 };\n\n            double[] signal = new double[] {\n                -0.917843918645, 0.141984778794, 1.20536903482, 0.190286794412,\n                -0.662370894973, -1.00700480494, -0.404707073677, 0.800482325044,\n                0.743500089861, 1.01090520172, 0.741527555207, 0.277841675195,\n                0.400833448236, -0.2085993586, -0.172842103641, -0.134316096293,\n                0.0259303398477, 0.490105989562, 0.549391221511, 0.9047198589\n            };\n\n            double[] result = Filter(a, b, signal);\n            for (int i = 0; i < result.Length; ++i) {\n                Console.Write(\"{0,11:F8}\", result[i]);\n                Console.Write((i + 1) % 5 != 0 ? \", \" : \"\\n\");\n            }\n        }\n    }\n}\n"}
{"id": 142000, "name": "Apply a digital filter (direct form II transposed)", "source": "Translate Ruby to Java: def filter(a,b,signal)\n    result = Array.new(signal.length(), 0.0)\n    for i in 0..signal.length()-1 do\n        tmp = 0.0\n        for j in 0 .. b.length()-1 do\n            if i - j < 0 then next end\n            tmp += b[j] * signal[i - j]\n        end\n        for j in 1 .. a.length()-1 do\n            if i - j < 0 then next end\n            tmp -= a[j] * result[i - j]\n        end\n        tmp /= a[0]\n        result[i] = tmp\n    end\n    return result\nend\n\ndef main\n    a = [1.00000000, -2.77555756e-16, 3.33333333e-01, -1.85037171e-17]\n    b = [0.16666667, 0.5, 0.5, 0.16666667]\n    signal = [\n        -0.917843918645,  0.141984778794, 1.20536903482,   0.190286794412,\n        -0.662370894973, -1.00700480494, -0.404707073677,  0.800482325044,\n         0.743500089861,  1.01090520172,  0.741527555207,  0.277841675195,\n         0.400833448236, -0.2085993586,  -0.172842103641, -0.134316096293,\n         0.0259303398477, 0.490105989562, 0.549391221511,  0.9047198589\n    ]\n\n    result = filter(a,b,signal)\n    for i in 0 .. result.length() - 1 do\n        print \"%11.8f\" % [result[i]]\n        if (i + 1) % 5 == 0 then\n            print \"\\n\"\n        else\n            print \", \"\n        end\n    end\nend\n\nmain()\n", "target": "public class DigitalFilter {\n    private static double[] filter(double[] a, double[] b, double[] signal) {\n        double[] result = new double[signal.length];\n        for (int i = 0; i < signal.length; ++i) {\n            double tmp = 0.0;\n            for (int j = 0; j < b.length; ++j) {\n                if (i - j < 0) continue;\n                tmp += b[j] * signal[i - j];\n            }\n            for (int j = 1; j < a.length; ++j) {\n                if (i - j < 0) continue;\n                tmp -= a[j] * result[i - j];\n            }\n            tmp /= a[0];\n            result[i] = tmp;\n        }\n        return result;\n    }\n\n    public static void main(String[] args) {\n        double[] a = new double[]{1.00000000, -2.77555756e-16, 3.33333333e-01, -1.85037171e-17};\n        double[] b = new double[]{0.16666667, 0.5, 0.5, 0.16666667};\n\n        double[] signal = new double[]{\n            -0.917843918645, 0.141984778794, 1.20536903482, 0.190286794412,\n            -0.662370894973, -1.00700480494, -0.404707073677, 0.800482325044,\n            0.743500089861, 1.01090520172, 0.741527555207, 0.277841675195,\n            0.400833448236, -0.2085993586, -0.172842103641, -0.134316096293,\n            0.0259303398477, 0.490105989562, 0.549391221511, 0.9047198589\n        };\n\n        double[] result = filter(a, b, signal);\n        for (int i = 0; i < result.length; ++i) {\n            System.out.printf(\"% .8f\", result[i]);\n            System.out.print((i + 1) % 5 != 0 ? \", \" : \"\\n\");\n        }\n    }\n}\n"}
{"id": 142001, "name": "Apply a digital filter (direct form II transposed)", "source": "Translate Ruby to Java: def filter(a,b,signal)\n    result = Array.new(signal.length(), 0.0)\n    for i in 0..signal.length()-1 do\n        tmp = 0.0\n        for j in 0 .. b.length()-1 do\n            if i - j < 0 then next end\n            tmp += b[j] * signal[i - j]\n        end\n        for j in 1 .. a.length()-1 do\n            if i - j < 0 then next end\n            tmp -= a[j] * result[i - j]\n        end\n        tmp /= a[0]\n        result[i] = tmp\n    end\n    return result\nend\n\ndef main\n    a = [1.00000000, -2.77555756e-16, 3.33333333e-01, -1.85037171e-17]\n    b = [0.16666667, 0.5, 0.5, 0.16666667]\n    signal = [\n        -0.917843918645,  0.141984778794, 1.20536903482,   0.190286794412,\n        -0.662370894973, -1.00700480494, -0.404707073677,  0.800482325044,\n         0.743500089861,  1.01090520172,  0.741527555207,  0.277841675195,\n         0.400833448236, -0.2085993586,  -0.172842103641, -0.134316096293,\n         0.0259303398477, 0.490105989562, 0.549391221511,  0.9047198589\n    ]\n\n    result = filter(a,b,signal)\n    for i in 0 .. result.length() - 1 do\n        print \"%11.8f\" % [result[i]]\n        if (i + 1) % 5 == 0 then\n            print \"\\n\"\n        else\n            print \", \"\n        end\n    end\nend\n\nmain()\n", "target": "public class DigitalFilter {\n    private static double[] filter(double[] a, double[] b, double[] signal) {\n        double[] result = new double[signal.length];\n        for (int i = 0; i < signal.length; ++i) {\n            double tmp = 0.0;\n            for (int j = 0; j < b.length; ++j) {\n                if (i - j < 0) continue;\n                tmp += b[j] * signal[i - j];\n            }\n            for (int j = 1; j < a.length; ++j) {\n                if (i - j < 0) continue;\n                tmp -= a[j] * result[i - j];\n            }\n            tmp /= a[0];\n            result[i] = tmp;\n        }\n        return result;\n    }\n\n    public static void main(String[] args) {\n        double[] a = new double[]{1.00000000, -2.77555756e-16, 3.33333333e-01, -1.85037171e-17};\n        double[] b = new double[]{0.16666667, 0.5, 0.5, 0.16666667};\n\n        double[] signal = new double[]{\n            -0.917843918645, 0.141984778794, 1.20536903482, 0.190286794412,\n            -0.662370894973, -1.00700480494, -0.404707073677, 0.800482325044,\n            0.743500089861, 1.01090520172, 0.741527555207, 0.277841675195,\n            0.400833448236, -0.2085993586, -0.172842103641, -0.134316096293,\n            0.0259303398477, 0.490105989562, 0.549391221511, 0.9047198589\n        };\n\n        double[] result = filter(a, b, signal);\n        for (int i = 0; i < result.length; ++i) {\n            System.out.printf(\"% .8f\", result[i]);\n            System.out.print((i + 1) % 5 != 0 ? \", \" : \"\\n\");\n        }\n    }\n}\n"}
{"id": 142002, "name": "Apply a digital filter (direct form II transposed)", "source": "Translate Ruby to Python: def filter(a,b,signal)\n    result = Array.new(signal.length(), 0.0)\n    for i in 0..signal.length()-1 do\n        tmp = 0.0\n        for j in 0 .. b.length()-1 do\n            if i - j < 0 then next end\n            tmp += b[j] * signal[i - j]\n        end\n        for j in 1 .. a.length()-1 do\n            if i - j < 0 then next end\n            tmp -= a[j] * result[i - j]\n        end\n        tmp /= a[0]\n        result[i] = tmp\n    end\n    return result\nend\n\ndef main\n    a = [1.00000000, -2.77555756e-16, 3.33333333e-01, -1.85037171e-17]\n    b = [0.16666667, 0.5, 0.5, 0.16666667]\n    signal = [\n        -0.917843918645,  0.141984778794, 1.20536903482,   0.190286794412,\n        -0.662370894973, -1.00700480494, -0.404707073677,  0.800482325044,\n         0.743500089861,  1.01090520172,  0.741527555207,  0.277841675195,\n         0.400833448236, -0.2085993586,  -0.172842103641, -0.134316096293,\n         0.0259303398477, 0.490105989562, 0.549391221511,  0.9047198589\n    ]\n\n    result = filter(a,b,signal)\n    for i in 0 .. result.length() - 1 do\n        print \"%11.8f\" % [result[i]]\n        if (i + 1) % 5 == 0 then\n            print \"\\n\"\n        else\n            print \", \"\n        end\n    end\nend\n\nmain()\n", "target": "\nfrom __future__ import print_function\nfrom scipy import signal\nimport matplotlib.pyplot as plt\n\nif __name__==\"__main__\":\n\tsig = [-0.917843918645,0.141984778794,1.20536903482,0.190286794412,-0.662370894973,-1.00700480494,\n\t\t-0.404707073677,0.800482325044,0.743500089861,1.01090520172,0.741527555207,\n\t\t0.277841675195,0.400833448236,-0.2085993586,-0.172842103641,-0.134316096293,\n\t\t0.0259303398477,0.490105989562,0.549391221511,0.9047198589]\n\n\t\n\t\n\ta = [1.00000000, -2.77555756e-16, 3.33333333e-01, -1.85037171e-17]\n\tb = [0.16666667, 0.5, 0.5, 0.16666667]\n\n\t\n\tfilt = signal.lfilter(b, a, sig)\n\tprint (filt)\n\n\tplt.plot(sig, 'b')\n\tplt.plot(filt, 'r--')\n\tplt.show()\n"}
{"id": 142003, "name": "Apply a digital filter (direct form II transposed)", "source": "Translate Ruby to Python: def filter(a,b,signal)\n    result = Array.new(signal.length(), 0.0)\n    for i in 0..signal.length()-1 do\n        tmp = 0.0\n        for j in 0 .. b.length()-1 do\n            if i - j < 0 then next end\n            tmp += b[j] * signal[i - j]\n        end\n        for j in 1 .. a.length()-1 do\n            if i - j < 0 then next end\n            tmp -= a[j] * result[i - j]\n        end\n        tmp /= a[0]\n        result[i] = tmp\n    end\n    return result\nend\n\ndef main\n    a = [1.00000000, -2.77555756e-16, 3.33333333e-01, -1.85037171e-17]\n    b = [0.16666667, 0.5, 0.5, 0.16666667]\n    signal = [\n        -0.917843918645,  0.141984778794, 1.20536903482,   0.190286794412,\n        -0.662370894973, -1.00700480494, -0.404707073677,  0.800482325044,\n         0.743500089861,  1.01090520172,  0.741527555207,  0.277841675195,\n         0.400833448236, -0.2085993586,  -0.172842103641, -0.134316096293,\n         0.0259303398477, 0.490105989562, 0.549391221511,  0.9047198589\n    ]\n\n    result = filter(a,b,signal)\n    for i in 0 .. result.length() - 1 do\n        print \"%11.8f\" % [result[i]]\n        if (i + 1) % 5 == 0 then\n            print \"\\n\"\n        else\n            print \", \"\n        end\n    end\nend\n\nmain()\n", "target": "\nfrom __future__ import print_function\nfrom scipy import signal\nimport matplotlib.pyplot as plt\n\nif __name__==\"__main__\":\n\tsig = [-0.917843918645,0.141984778794,1.20536903482,0.190286794412,-0.662370894973,-1.00700480494,\n\t\t-0.404707073677,0.800482325044,0.743500089861,1.01090520172,0.741527555207,\n\t\t0.277841675195,0.400833448236,-0.2085993586,-0.172842103641,-0.134316096293,\n\t\t0.0259303398477,0.490105989562,0.549391221511,0.9047198589]\n\n\t\n\t\n\ta = [1.00000000, -2.77555756e-16, 3.33333333e-01, -1.85037171e-17]\n\tb = [0.16666667, 0.5, 0.5, 0.16666667]\n\n\t\n\tfilt = signal.lfilter(b, a, sig)\n\tprint (filt)\n\n\tplt.plot(sig, 'b')\n\tplt.plot(filt, 'r--')\n\tplt.show()\n"}
{"id": 142143, "name": "Honeycombs", "source": "Translate Ruby to C#: Shoes.app(title: \"Honeycombs\", height: 700, width: 700) do\n  C = Math::cos(Math::PI/3)\n  S = Math::sin(Math::PI/3)\n  Radius = 60.0\n  letters = [\n    %w[L A R N D 1 2], \n    %w[G U I Y T 3 4], \n    %w[P C F E B 5 6], \n    %w[V S O M K 7 8],\n    %w[Q X J Z H 9 0],\n  ]\n  \n  def highlight(hexagon)\n    hexagon.style(fill: magenta)\n  end\n  \n  def unhighlight(hexagon)\n    hexagon.style(fill: yellow)\n  end\n  \n  def choose(hexagon)\n    hexagon.choose\n    highlight hexagon\n    chosen = @hexagons.find_all {|h| h.chosen?}.map {|h| h.letter}\n    if chosen.size == @hexagons.size\n      @chosen.text = 'Every hexagon has been chosen.'\n    else\n      @chosen.text = \"Chosen: \n                     \"Last Chosen: \n    end\n  end\n  \n  width = 20 + (Radius*(7*letters[0].size - 3)/4.0).ceil\n  height = 60 + (Radius*(1 + 2*S*letters.size)).ceil\n  @hexagons = []\n  letter_to_hex = {}\n  \n  \n  stack(height: height, width: width) do\n    @chosen = para(\"Chosen:\\nLast chosen:\")\n    \n    \n    letters.each_index do |row|\n      letters[0].each_index do |column|\n        x = 60 + column * Radius * 0.75 + (1-S) * Radius\n        y = 80 + row * S * Radius + (column.odd? ? S * Radius * 0.5 : 0)\n        h = shape(x-Radius, y-S*Radius) do\n          strokewidth 3\n          move_to(x-C*Radius, y-S*Radius)\n          line_to(x+C*Radius, y-S*Radius)\n          line_to(x+Radius,   y)\n          line_to(x+C*Radius, y+S*Radius)\n          line_to(x-C*Radius, y+S*Radius)\n          line_to(x-Radius,   y)\n          line_to(x-C*Radius, y-S*Radius)\n        end\n        \n        \n        class << h\n          attr_accessor :x, :y, :state, :letter\n          def chosen?\n            not @state.nil?\n          end\n          def choose\n            @state = :chosen\n          end\n          def contains?(px, py)\n            if @x-Radius < px and px <= @x-C*Radius\n              ratio = (px - @x + Radius)/(Radius*(1-C))\n              @y - ratio*S*Radius < py and py <= @y + ratio*S*Radius\n            elsif @x-C*Radius < px and px <= @x+C*Radius\n              @y - S*Radius < py and py < @y + S*Radius\n            elsif @x+C*Radius < px and px <= @x+Radius\n              ratio = (@x + Radius - px)/(Radius*(1-C))\n              @y - ratio*S*Radius < py and py <= @y + ratio*S*Radius\n            else\n              false\n            end\n          end\n          def inspect\n            %q(<%s,\"%s\",%s,%d@%d>) % [self.class, letter, chosen?, x, y]\n          end\n        end\n        \n        h.x = x + x - Radius\n        h.y = y + y - S*Radius\n        h.letter = letters[row][column]\n        unhighlight h\n        \n        @hexagons << h\n        letter_to_hex[h.letter.downcase] = h\n        letter_to_hex[h.letter.upcase] = h\n        \n        \n        para(h.letter).style(size:56, stroke:red) \\\n                      .move(h.x - C*Radius, h.y - S*Radius)\n      end\n    end\n    \n    \n    hex_over = nil\n    motion do |x, y|\n      hex = @hexagons.find {|h| h.contains?(x,y)}\n      unless hex.nil? or hex.chosen?\n        highlight hex \n      end\n      unless hex_over == hex or hex_over.nil? or hex_over.chosen?\n        unhighlight hex_over \n      end\n      hex_over = hex\n    end\n    \n    \n    click do |button, x, y|\n      info(\"button \n      hexagon = @hexagons.find {|h| h.contains?(x,y)}\n      if hexagon\n        info(\"clicked hexagon \n        choose hexagon\n      end\n    end\n    \n    \n    keypress do |key| \n      if key == \"\\x11\"  \n        exit\n      elsif key == \"?\"\n        info @hexagons.collect {|h| h.inspect}.join(\"\\n\")\n      elsif letter_to_hex.has_key?(key)\n        info(\"pressed key \n        choose letter_to_hex[key]\n      end\n    end\n  end\nend\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Windows;\nusing System.Windows.Controls;\nusing System.Windows.Input;\nusing System.Windows.Media;\nusing System.Windows.Shapes;\n\n\n\n\n\n\n\nnamespace Honeycombs\n{\n    public partial class MainWindow\n    {\n        private const int RowCount = 4;\n        private const int ColCount = 5;\n        private const int LabelSize = 20;\n        private readonly char[] _permutedChars;\n\n        public MainWindow()\n        {\n            if (RowCount * ColCount > 26)\n#pragma warning disable 162\n            {\n                throw new ArgumentException(\"Too many cells\");\n            }\n#pragma warning restore 162\n            _permutedChars = GetPermutedChars(RowCount * ColCount);\n\n            \n            InitializeComponent();\n        }\n\n        private static char[] GetPermutedChars(int characterCount)\n        {\n            const string allChars = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n            var rnd = new Random();\n            var chars = new char[allChars.Length];\n\n            for (int i = 0; i < allChars.Length; i++)\n            {\n                chars[i] = allChars[i];\n            }\n\n            for (int i = 0; i < characterCount; i++)\n            {\n                int swapIndex = rnd.Next() % (allChars.Length - i);\n                char tmp = chars[swapIndex + i];\n                chars[swapIndex + i] = chars[i];\n                chars[i] = tmp;\n            }\n            return chars;\n        }\n\n        private void SetHexProperties(UIElementCollection hexes, double cellSize)\n        {\n            int charIndex = 0;\n            List<Polygon> hexList = hexes.Cast<Polygon>().ToList();\n\n            foreach (Polygon element in hexList)\n            {\n                SetHexProperties(element, _permutedChars[charIndex++], cellSize);\n            }\n        }\n\n        private void SetHexProperties(Polygon hex, char charToSet, double cellSize)\n        {\n            var tag = (Tuple<int, int, double, double>) hex.Tag;\n            double cellX = tag.Item3;\n            double cellY = tag.Item4;\n\n            \n            \n\n            var centeringGrid = new Grid();\n            centeringGrid.Width = centeringGrid.Height = 2 * cellSize;\n            centeringGrid.SetValue(Canvas.LeftProperty, cellX - cellSize);\n            centeringGrid.SetValue(Canvas.TopProperty, cellY - cellSize);\n            centeringGrid.IsHitTestVisible = false;\n            HoneycombCanvas.Children.Add(centeringGrid);\n\n            var label = new TextBlock\n                {\n                    Text = new string(charToSet, 1),\n                    FontFamily = new FontFamily(\"Segoe\"),\n                    FontSize = LabelSize\n                };\n            label.HorizontalAlignment = HorizontalAlignment.Center;\n            label.VerticalAlignment = VerticalAlignment.Center;\n            label.IsHitTestVisible = false;\n            centeringGrid.Children.Add(label);\n\n            \n            hex.Tag = charToSet;\n            hex.Fill = new SolidColorBrush(Colors.Yellow);\n            hex.Stroke = new SolidColorBrush(Colors.Black);\n            hex.StrokeThickness = cellSize / 10;\n\n            \n            hex.MouseDown += hex_MouseDown;\n        }\n\n        private void hex_MouseDown(object sender, MouseButtonEventArgs e)\n        {\n            var hex = sender as Shape;\n            if (hex == null)\n            {\n                throw new InvalidCastException(\"Non-shape in Honeycomb\");\n            }\n\n            \n            var ch = (char) hex.Tag;\n\n            \n            Letters.Text = Letters.Text + ch;\n\n            \n            hex.Fill = new SolidColorBrush(Colors.Magenta);\n\n            \n            hex.MouseDown -= hex_MouseDown;\n        }\n\n        private static void GetCombSize(double actualHeight, double actualWidth, int columns, int rows,\n                                        out double cellSize, out double combHeight, out double combWidth)\n        {\n            double columnFactor = (3 * columns + 1) / 2.0;\n            double rowFactor = (Math.Sqrt(3) * (2 * rows + 1)) / 2.0;\n            double cellFromWidth = actualWidth / columnFactor;\n            double cellFromHeight = actualHeight / rowFactor;\n            cellSize = Math.Min(cellFromWidth, cellFromHeight);\n            combWidth = cellSize * columnFactor;\n            combHeight = cellSize * rowFactor;\n        }\n\n        private static void AddCells(Canvas canvas, double cellSize, int columns, int rows)\n        {\n            double rowHeight = cellSize * Math.Sqrt(3) / 2;\n\n            for (int row = 0; row < rows; row++)\n            {\n                AddRow(rowHeight, canvas, cellSize, columns, row);\n                rowHeight += cellSize * Math.Sqrt(3);\n            }\n        }\n\n        private static void AddRow(double rowHeight, Canvas canvas, double cellSize, int columnCount, int row)\n        {\n            double cellX = cellSize;\n            double cellHeight = cellSize * Math.Sqrt(3);\n\n            for (int col = 0; col < columnCount; col++)\n            {\n                double cellY = rowHeight + ((col & 1) == 1 ? cellHeight / 2 : 0);\n                Polygon hex = GetCenteredHex(cellSize, cellX, cellY, cellHeight);\n                hex.Tag = Tuple.Create(col, row, cellX, cellY);\n                canvas.Children.Add(hex);\n                cellX += 3 * cellSize / 2;\n            }\n        }\n\n        private static Polygon GetCenteredHex(double cellSize, double cellX, double cellY, double cellHeight)\n        {\n            var hex = new Polygon();\n            hex.Points.Add(new Point(cellX - cellSize, cellY));\n            hex.Points.Add(new Point(cellX - cellSize / 2, cellY + cellHeight / 2));\n            hex.Points.Add(new Point(cellX + cellSize / 2, cellY + cellHeight / 2));\n            hex.Points.Add(new Point(cellX + cellSize, cellY));\n            hex.Points.Add(new Point(cellX + cellSize / 2, cellY - cellHeight / 2));\n            hex.Points.Add(new Point(cellX - cellSize / 2, cellY - cellHeight / 2));\n            return hex;\n        }\n\n        private void Window_Loaded(object sender, RoutedEventArgs e)\n        {\n            double combHeight, combWidth, cellSize;\n\n            \n            GetCombSize(Main.ActualHeight, Main.ActualWidth, ColCount, RowCount, out cellSize, out combHeight,\n                        out combWidth);\n\n            \n            HoneycombCanvas.Width = combWidth;\n            HoneycombCanvas.Height = combHeight;\n\n            \n            AddCells(HoneycombCanvas, cellSize, ColCount, RowCount);\n\n            \n            SetHexProperties(HoneycombCanvas.Children, cellSize);\n        }\n    }\n}\n"}
{"id": 142144, "name": "Honeycombs", "source": "Translate Ruby to C#: Shoes.app(title: \"Honeycombs\", height: 700, width: 700) do\n  C = Math::cos(Math::PI/3)\n  S = Math::sin(Math::PI/3)\n  Radius = 60.0\n  letters = [\n    %w[L A R N D 1 2], \n    %w[G U I Y T 3 4], \n    %w[P C F E B 5 6], \n    %w[V S O M K 7 8],\n    %w[Q X J Z H 9 0],\n  ]\n  \n  def highlight(hexagon)\n    hexagon.style(fill: magenta)\n  end\n  \n  def unhighlight(hexagon)\n    hexagon.style(fill: yellow)\n  end\n  \n  def choose(hexagon)\n    hexagon.choose\n    highlight hexagon\n    chosen = @hexagons.find_all {|h| h.chosen?}.map {|h| h.letter}\n    if chosen.size == @hexagons.size\n      @chosen.text = 'Every hexagon has been chosen.'\n    else\n      @chosen.text = \"Chosen: \n                     \"Last Chosen: \n    end\n  end\n  \n  width = 20 + (Radius*(7*letters[0].size - 3)/4.0).ceil\n  height = 60 + (Radius*(1 + 2*S*letters.size)).ceil\n  @hexagons = []\n  letter_to_hex = {}\n  \n  \n  stack(height: height, width: width) do\n    @chosen = para(\"Chosen:\\nLast chosen:\")\n    \n    \n    letters.each_index do |row|\n      letters[0].each_index do |column|\n        x = 60 + column * Radius * 0.75 + (1-S) * Radius\n        y = 80 + row * S * Radius + (column.odd? ? S * Radius * 0.5 : 0)\n        h = shape(x-Radius, y-S*Radius) do\n          strokewidth 3\n          move_to(x-C*Radius, y-S*Radius)\n          line_to(x+C*Radius, y-S*Radius)\n          line_to(x+Radius,   y)\n          line_to(x+C*Radius, y+S*Radius)\n          line_to(x-C*Radius, y+S*Radius)\n          line_to(x-Radius,   y)\n          line_to(x-C*Radius, y-S*Radius)\n        end\n        \n        \n        class << h\n          attr_accessor :x, :y, :state, :letter\n          def chosen?\n            not @state.nil?\n          end\n          def choose\n            @state = :chosen\n          end\n          def contains?(px, py)\n            if @x-Radius < px and px <= @x-C*Radius\n              ratio = (px - @x + Radius)/(Radius*(1-C))\n              @y - ratio*S*Radius < py and py <= @y + ratio*S*Radius\n            elsif @x-C*Radius < px and px <= @x+C*Radius\n              @y - S*Radius < py and py < @y + S*Radius\n            elsif @x+C*Radius < px and px <= @x+Radius\n              ratio = (@x + Radius - px)/(Radius*(1-C))\n              @y - ratio*S*Radius < py and py <= @y + ratio*S*Radius\n            else\n              false\n            end\n          end\n          def inspect\n            %q(<%s,\"%s\",%s,%d@%d>) % [self.class, letter, chosen?, x, y]\n          end\n        end\n        \n        h.x = x + x - Radius\n        h.y = y + y - S*Radius\n        h.letter = letters[row][column]\n        unhighlight h\n        \n        @hexagons << h\n        letter_to_hex[h.letter.downcase] = h\n        letter_to_hex[h.letter.upcase] = h\n        \n        \n        para(h.letter).style(size:56, stroke:red) \\\n                      .move(h.x - C*Radius, h.y - S*Radius)\n      end\n    end\n    \n    \n    hex_over = nil\n    motion do |x, y|\n      hex = @hexagons.find {|h| h.contains?(x,y)}\n      unless hex.nil? or hex.chosen?\n        highlight hex \n      end\n      unless hex_over == hex or hex_over.nil? or hex_over.chosen?\n        unhighlight hex_over \n      end\n      hex_over = hex\n    end\n    \n    \n    click do |button, x, y|\n      info(\"button \n      hexagon = @hexagons.find {|h| h.contains?(x,y)}\n      if hexagon\n        info(\"clicked hexagon \n        choose hexagon\n      end\n    end\n    \n    \n    keypress do |key| \n      if key == \"\\x11\"  \n        exit\n      elsif key == \"?\"\n        info @hexagons.collect {|h| h.inspect}.join(\"\\n\")\n      elsif letter_to_hex.has_key?(key)\n        info(\"pressed key \n        choose letter_to_hex[key]\n      end\n    end\n  end\nend\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Windows;\nusing System.Windows.Controls;\nusing System.Windows.Input;\nusing System.Windows.Media;\nusing System.Windows.Shapes;\n\n\n\n\n\n\n\nnamespace Honeycombs\n{\n    public partial class MainWindow\n    {\n        private const int RowCount = 4;\n        private const int ColCount = 5;\n        private const int LabelSize = 20;\n        private readonly char[] _permutedChars;\n\n        public MainWindow()\n        {\n            if (RowCount * ColCount > 26)\n#pragma warning disable 162\n            {\n                throw new ArgumentException(\"Too many cells\");\n            }\n#pragma warning restore 162\n            _permutedChars = GetPermutedChars(RowCount * ColCount);\n\n            \n            InitializeComponent();\n        }\n\n        private static char[] GetPermutedChars(int characterCount)\n        {\n            const string allChars = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n            var rnd = new Random();\n            var chars = new char[allChars.Length];\n\n            for (int i = 0; i < allChars.Length; i++)\n            {\n                chars[i] = allChars[i];\n            }\n\n            for (int i = 0; i < characterCount; i++)\n            {\n                int swapIndex = rnd.Next() % (allChars.Length - i);\n                char tmp = chars[swapIndex + i];\n                chars[swapIndex + i] = chars[i];\n                chars[i] = tmp;\n            }\n            return chars;\n        }\n\n        private void SetHexProperties(UIElementCollection hexes, double cellSize)\n        {\n            int charIndex = 0;\n            List<Polygon> hexList = hexes.Cast<Polygon>().ToList();\n\n            foreach (Polygon element in hexList)\n            {\n                SetHexProperties(element, _permutedChars[charIndex++], cellSize);\n            }\n        }\n\n        private void SetHexProperties(Polygon hex, char charToSet, double cellSize)\n        {\n            var tag = (Tuple<int, int, double, double>) hex.Tag;\n            double cellX = tag.Item3;\n            double cellY = tag.Item4;\n\n            \n            \n\n            var centeringGrid = new Grid();\n            centeringGrid.Width = centeringGrid.Height = 2 * cellSize;\n            centeringGrid.SetValue(Canvas.LeftProperty, cellX - cellSize);\n            centeringGrid.SetValue(Canvas.TopProperty, cellY - cellSize);\n            centeringGrid.IsHitTestVisible = false;\n            HoneycombCanvas.Children.Add(centeringGrid);\n\n            var label = new TextBlock\n                {\n                    Text = new string(charToSet, 1),\n                    FontFamily = new FontFamily(\"Segoe\"),\n                    FontSize = LabelSize\n                };\n            label.HorizontalAlignment = HorizontalAlignment.Center;\n            label.VerticalAlignment = VerticalAlignment.Center;\n            label.IsHitTestVisible = false;\n            centeringGrid.Children.Add(label);\n\n            \n            hex.Tag = charToSet;\n            hex.Fill = new SolidColorBrush(Colors.Yellow);\n            hex.Stroke = new SolidColorBrush(Colors.Black);\n            hex.StrokeThickness = cellSize / 10;\n\n            \n            hex.MouseDown += hex_MouseDown;\n        }\n\n        private void hex_MouseDown(object sender, MouseButtonEventArgs e)\n        {\n            var hex = sender as Shape;\n            if (hex == null)\n            {\n                throw new InvalidCastException(\"Non-shape in Honeycomb\");\n            }\n\n            \n            var ch = (char) hex.Tag;\n\n            \n            Letters.Text = Letters.Text + ch;\n\n            \n            hex.Fill = new SolidColorBrush(Colors.Magenta);\n\n            \n            hex.MouseDown -= hex_MouseDown;\n        }\n\n        private static void GetCombSize(double actualHeight, double actualWidth, int columns, int rows,\n                                        out double cellSize, out double combHeight, out double combWidth)\n        {\n            double columnFactor = (3 * columns + 1) / 2.0;\n            double rowFactor = (Math.Sqrt(3) * (2 * rows + 1)) / 2.0;\n            double cellFromWidth = actualWidth / columnFactor;\n            double cellFromHeight = actualHeight / rowFactor;\n            cellSize = Math.Min(cellFromWidth, cellFromHeight);\n            combWidth = cellSize * columnFactor;\n            combHeight = cellSize * rowFactor;\n        }\n\n        private static void AddCells(Canvas canvas, double cellSize, int columns, int rows)\n        {\n            double rowHeight = cellSize * Math.Sqrt(3) / 2;\n\n            for (int row = 0; row < rows; row++)\n            {\n                AddRow(rowHeight, canvas, cellSize, columns, row);\n                rowHeight += cellSize * Math.Sqrt(3);\n            }\n        }\n\n        private static void AddRow(double rowHeight, Canvas canvas, double cellSize, int columnCount, int row)\n        {\n            double cellX = cellSize;\n            double cellHeight = cellSize * Math.Sqrt(3);\n\n            for (int col = 0; col < columnCount; col++)\n            {\n                double cellY = rowHeight + ((col & 1) == 1 ? cellHeight / 2 : 0);\n                Polygon hex = GetCenteredHex(cellSize, cellX, cellY, cellHeight);\n                hex.Tag = Tuple.Create(col, row, cellX, cellY);\n                canvas.Children.Add(hex);\n                cellX += 3 * cellSize / 2;\n            }\n        }\n\n        private static Polygon GetCenteredHex(double cellSize, double cellX, double cellY, double cellHeight)\n        {\n            var hex = new Polygon();\n            hex.Points.Add(new Point(cellX - cellSize, cellY));\n            hex.Points.Add(new Point(cellX - cellSize / 2, cellY + cellHeight / 2));\n            hex.Points.Add(new Point(cellX + cellSize / 2, cellY + cellHeight / 2));\n            hex.Points.Add(new Point(cellX + cellSize, cellY));\n            hex.Points.Add(new Point(cellX + cellSize / 2, cellY - cellHeight / 2));\n            hex.Points.Add(new Point(cellX - cellSize / 2, cellY - cellHeight / 2));\n            return hex;\n        }\n\n        private void Window_Loaded(object sender, RoutedEventArgs e)\n        {\n            double combHeight, combWidth, cellSize;\n\n            \n            GetCombSize(Main.ActualHeight, Main.ActualWidth, ColCount, RowCount, out cellSize, out combHeight,\n                        out combWidth);\n\n            \n            HoneycombCanvas.Width = combWidth;\n            HoneycombCanvas.Height = combHeight;\n\n            \n            AddCells(HoneycombCanvas, cellSize, ColCount, RowCount);\n\n            \n            SetHexProperties(HoneycombCanvas.Children, cellSize);\n        }\n    }\n}\n"}
{"id": 142147, "name": "Honeycombs", "source": "Translate Ruby to Java: Shoes.app(title: \"Honeycombs\", height: 700, width: 700) do\n  C = Math::cos(Math::PI/3)\n  S = Math::sin(Math::PI/3)\n  Radius = 60.0\n  letters = [\n    %w[L A R N D 1 2], \n    %w[G U I Y T 3 4], \n    %w[P C F E B 5 6], \n    %w[V S O M K 7 8],\n    %w[Q X J Z H 9 0],\n  ]\n  \n  def highlight(hexagon)\n    hexagon.style(fill: magenta)\n  end\n  \n  def unhighlight(hexagon)\n    hexagon.style(fill: yellow)\n  end\n  \n  def choose(hexagon)\n    hexagon.choose\n    highlight hexagon\n    chosen = @hexagons.find_all {|h| h.chosen?}.map {|h| h.letter}\n    if chosen.size == @hexagons.size\n      @chosen.text = 'Every hexagon has been chosen.'\n    else\n      @chosen.text = \"Chosen: \n                     \"Last Chosen: \n    end\n  end\n  \n  width = 20 + (Radius*(7*letters[0].size - 3)/4.0).ceil\n  height = 60 + (Radius*(1 + 2*S*letters.size)).ceil\n  @hexagons = []\n  letter_to_hex = {}\n  \n  \n  stack(height: height, width: width) do\n    @chosen = para(\"Chosen:\\nLast chosen:\")\n    \n    \n    letters.each_index do |row|\n      letters[0].each_index do |column|\n        x = 60 + column * Radius * 0.75 + (1-S) * Radius\n        y = 80 + row * S * Radius + (column.odd? ? S * Radius * 0.5 : 0)\n        h = shape(x-Radius, y-S*Radius) do\n          strokewidth 3\n          move_to(x-C*Radius, y-S*Radius)\n          line_to(x+C*Radius, y-S*Radius)\n          line_to(x+Radius,   y)\n          line_to(x+C*Radius, y+S*Radius)\n          line_to(x-C*Radius, y+S*Radius)\n          line_to(x-Radius,   y)\n          line_to(x-C*Radius, y-S*Radius)\n        end\n        \n        \n        class << h\n          attr_accessor :x, :y, :state, :letter\n          def chosen?\n            not @state.nil?\n          end\n          def choose\n            @state = :chosen\n          end\n          def contains?(px, py)\n            if @x-Radius < px and px <= @x-C*Radius\n              ratio = (px - @x + Radius)/(Radius*(1-C))\n              @y - ratio*S*Radius < py and py <= @y + ratio*S*Radius\n            elsif @x-C*Radius < px and px <= @x+C*Radius\n              @y - S*Radius < py and py < @y + S*Radius\n            elsif @x+C*Radius < px and px <= @x+Radius\n              ratio = (@x + Radius - px)/(Radius*(1-C))\n              @y - ratio*S*Radius < py and py <= @y + ratio*S*Radius\n            else\n              false\n            end\n          end\n          def inspect\n            %q(<%s,\"%s\",%s,%d@%d>) % [self.class, letter, chosen?, x, y]\n          end\n        end\n        \n        h.x = x + x - Radius\n        h.y = y + y - S*Radius\n        h.letter = letters[row][column]\n        unhighlight h\n        \n        @hexagons << h\n        letter_to_hex[h.letter.downcase] = h\n        letter_to_hex[h.letter.upcase] = h\n        \n        \n        para(h.letter).style(size:56, stroke:red) \\\n                      .move(h.x - C*Radius, h.y - S*Radius)\n      end\n    end\n    \n    \n    hex_over = nil\n    motion do |x, y|\n      hex = @hexagons.find {|h| h.contains?(x,y)}\n      unless hex.nil? or hex.chosen?\n        highlight hex \n      end\n      unless hex_over == hex or hex_over.nil? or hex_over.chosen?\n        unhighlight hex_over \n      end\n      hex_over = hex\n    end\n    \n    \n    click do |button, x, y|\n      info(\"button \n      hexagon = @hexagons.find {|h| h.contains?(x,y)}\n      if hexagon\n        info(\"clicked hexagon \n        choose hexagon\n      end\n    end\n    \n    \n    keypress do |key| \n      if key == \"\\x11\"  \n        exit\n      elsif key == \"?\"\n        info @hexagons.collect {|h| h.inspect}.join(\"\\n\")\n      elsif letter_to_hex.has_key?(key)\n        info(\"pressed key \n        choose letter_to_hex[key]\n      end\n    end\n  end\nend\n", "target": "import java.awt.*;\nimport java.awt.event.*;\nimport javax.swing.*;\n\npublic class Honeycombs extends JFrame {\n\n    public static void main(String[] args) {\n        SwingUtilities.invokeLater(() -> {\n            JFrame f = new Honeycombs();\n            f.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n            f.setVisible(true);\n        });\n    }\n\n    public Honeycombs() {\n        add(new HoneycombsPanel(), BorderLayout.CENTER);\n        setTitle(\"Honeycombs\");\n        setResizable(false);\n        pack();\n        setLocationRelativeTo(null);\n    }\n}\n\nclass HoneycombsPanel extends JPanel {\n\n    Hexagon[] comb;\n\n    public HoneycombsPanel() {\n        setPreferredSize(new Dimension(600, 500));\n        setBackground(Color.white);\n        setFocusable(true);\n\n        addMouseListener(new MouseAdapter() {\n            @Override\n            public void mousePressed(MouseEvent e) {\n                for (Hexagon hex : comb)\n                    if (hex.contains(e.getX(), e.getY())) {\n                        hex.setSelected();\n                        break;\n                    }\n                repaint();\n            }\n        });\n\n        addKeyListener(new KeyAdapter() {\n            @Override\n            public void keyPressed(KeyEvent e) {\n                for (Hexagon hex : comb)\n                    if (hex.letter == Character.toUpperCase(e.getKeyChar())) {\n                        hex.setSelected();\n                        break;\n                    }\n                repaint();\n            }\n        });\n\n        char[] letters = \"LRDGITPFBVOKANUYCESM\".toCharArray();\n        comb = new Hexagon[20];\n\n        int x1 = 150, y1 = 100, x2 = 225, y2 = 143, w = 150, h = 87;\n        for (int i = 0; i < comb.length; i++) {\n            int x, y;\n            if (i < 12) {\n                x = x1 + (i % 3) * w;\n                y = y1 + (i / 3) * h;\n            } else {\n                x = x2 + (i % 2) * w;\n                y = y2 + ((i - 12) / 2) * h;\n            }\n            comb[i] = new Hexagon(x, y, w / 3, letters[i]);\n        }\n\n        requestFocus();\n    }\n\n    @Override\n    public void paintComponent(Graphics gg) {\n        super.paintComponent(gg);\n        Graphics2D g = (Graphics2D) gg;\n        g.setRenderingHint(RenderingHints.KEY_ANTIALIASING,\n                RenderingHints.VALUE_ANTIALIAS_ON);\n\n        g.setFont(new Font(\"SansSerif\", Font.BOLD, 30));\n        g.setStroke(new BasicStroke(3));\n\n        for (Hexagon hex : comb)\n            hex.draw(g);\n    }\n}\n\nclass Hexagon extends Polygon {\n    final Color baseColor = Color.yellow;\n    final Color selectedColor = Color.magenta;\n    final char letter;\n\n    private boolean hasBeenSelected;\n\n    Hexagon(int x, int y, int halfWidth, char c) {\n        letter = c;\n        for (int i = 0; i < 6; i++)\n            addPoint((int) (x + halfWidth * Math.cos(i * Math.PI / 3)),\n                     (int) (y + halfWidth * Math.sin(i * Math.PI / 3)));\n        getBounds();\n    }\n\n    void setSelected() {\n        hasBeenSelected = true;\n    }\n\n    void draw(Graphics2D g) {\n        g.setColor(hasBeenSelected ? selectedColor : baseColor);\n        g.fillPolygon(this);\n\n        g.setColor(Color.black);\n        g.drawPolygon(this);\n\n        g.setColor(hasBeenSelected ? Color.black : Color.red);\n        drawCenteredString(g, String.valueOf(letter));\n    }\n\n    void drawCenteredString(Graphics2D g, String s) {\n        FontMetrics fm = g.getFontMetrics();\n        int asc = fm.getAscent();\n        int dec = fm.getDescent();\n\n        int x = bounds.x + (bounds.width - fm.stringWidth(s)) / 2;\n        int y = bounds.y + (asc + (bounds.height - (asc + dec)) / 2);\n\n        g.drawString(s, x, y);\n    }\n}\n"}
{"id": 142148, "name": "Honeycombs", "source": "Translate Ruby to Java: Shoes.app(title: \"Honeycombs\", height: 700, width: 700) do\n  C = Math::cos(Math::PI/3)\n  S = Math::sin(Math::PI/3)\n  Radius = 60.0\n  letters = [\n    %w[L A R N D 1 2], \n    %w[G U I Y T 3 4], \n    %w[P C F E B 5 6], \n    %w[V S O M K 7 8],\n    %w[Q X J Z H 9 0],\n  ]\n  \n  def highlight(hexagon)\n    hexagon.style(fill: magenta)\n  end\n  \n  def unhighlight(hexagon)\n    hexagon.style(fill: yellow)\n  end\n  \n  def choose(hexagon)\n    hexagon.choose\n    highlight hexagon\n    chosen = @hexagons.find_all {|h| h.chosen?}.map {|h| h.letter}\n    if chosen.size == @hexagons.size\n      @chosen.text = 'Every hexagon has been chosen.'\n    else\n      @chosen.text = \"Chosen: \n                     \"Last Chosen: \n    end\n  end\n  \n  width = 20 + (Radius*(7*letters[0].size - 3)/4.0).ceil\n  height = 60 + (Radius*(1 + 2*S*letters.size)).ceil\n  @hexagons = []\n  letter_to_hex = {}\n  \n  \n  stack(height: height, width: width) do\n    @chosen = para(\"Chosen:\\nLast chosen:\")\n    \n    \n    letters.each_index do |row|\n      letters[0].each_index do |column|\n        x = 60 + column * Radius * 0.75 + (1-S) * Radius\n        y = 80 + row * S * Radius + (column.odd? ? S * Radius * 0.5 : 0)\n        h = shape(x-Radius, y-S*Radius) do\n          strokewidth 3\n          move_to(x-C*Radius, y-S*Radius)\n          line_to(x+C*Radius, y-S*Radius)\n          line_to(x+Radius,   y)\n          line_to(x+C*Radius, y+S*Radius)\n          line_to(x-C*Radius, y+S*Radius)\n          line_to(x-Radius,   y)\n          line_to(x-C*Radius, y-S*Radius)\n        end\n        \n        \n        class << h\n          attr_accessor :x, :y, :state, :letter\n          def chosen?\n            not @state.nil?\n          end\n          def choose\n            @state = :chosen\n          end\n          def contains?(px, py)\n            if @x-Radius < px and px <= @x-C*Radius\n              ratio = (px - @x + Radius)/(Radius*(1-C))\n              @y - ratio*S*Radius < py and py <= @y + ratio*S*Radius\n            elsif @x-C*Radius < px and px <= @x+C*Radius\n              @y - S*Radius < py and py < @y + S*Radius\n            elsif @x+C*Radius < px and px <= @x+Radius\n              ratio = (@x + Radius - px)/(Radius*(1-C))\n              @y - ratio*S*Radius < py and py <= @y + ratio*S*Radius\n            else\n              false\n            end\n          end\n          def inspect\n            %q(<%s,\"%s\",%s,%d@%d>) % [self.class, letter, chosen?, x, y]\n          end\n        end\n        \n        h.x = x + x - Radius\n        h.y = y + y - S*Radius\n        h.letter = letters[row][column]\n        unhighlight h\n        \n        @hexagons << h\n        letter_to_hex[h.letter.downcase] = h\n        letter_to_hex[h.letter.upcase] = h\n        \n        \n        para(h.letter).style(size:56, stroke:red) \\\n                      .move(h.x - C*Radius, h.y - S*Radius)\n      end\n    end\n    \n    \n    hex_over = nil\n    motion do |x, y|\n      hex = @hexagons.find {|h| h.contains?(x,y)}\n      unless hex.nil? or hex.chosen?\n        highlight hex \n      end\n      unless hex_over == hex or hex_over.nil? or hex_over.chosen?\n        unhighlight hex_over \n      end\n      hex_over = hex\n    end\n    \n    \n    click do |button, x, y|\n      info(\"button \n      hexagon = @hexagons.find {|h| h.contains?(x,y)}\n      if hexagon\n        info(\"clicked hexagon \n        choose hexagon\n      end\n    end\n    \n    \n    keypress do |key| \n      if key == \"\\x11\"  \n        exit\n      elsif key == \"?\"\n        info @hexagons.collect {|h| h.inspect}.join(\"\\n\")\n      elsif letter_to_hex.has_key?(key)\n        info(\"pressed key \n        choose letter_to_hex[key]\n      end\n    end\n  end\nend\n", "target": "import java.awt.*;\nimport java.awt.event.*;\nimport javax.swing.*;\n\npublic class Honeycombs extends JFrame {\n\n    public static void main(String[] args) {\n        SwingUtilities.invokeLater(() -> {\n            JFrame f = new Honeycombs();\n            f.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n            f.setVisible(true);\n        });\n    }\n\n    public Honeycombs() {\n        add(new HoneycombsPanel(), BorderLayout.CENTER);\n        setTitle(\"Honeycombs\");\n        setResizable(false);\n        pack();\n        setLocationRelativeTo(null);\n    }\n}\n\nclass HoneycombsPanel extends JPanel {\n\n    Hexagon[] comb;\n\n    public HoneycombsPanel() {\n        setPreferredSize(new Dimension(600, 500));\n        setBackground(Color.white);\n        setFocusable(true);\n\n        addMouseListener(new MouseAdapter() {\n            @Override\n            public void mousePressed(MouseEvent e) {\n                for (Hexagon hex : comb)\n                    if (hex.contains(e.getX(), e.getY())) {\n                        hex.setSelected();\n                        break;\n                    }\n                repaint();\n            }\n        });\n\n        addKeyListener(new KeyAdapter() {\n            @Override\n            public void keyPressed(KeyEvent e) {\n                for (Hexagon hex : comb)\n                    if (hex.letter == Character.toUpperCase(e.getKeyChar())) {\n                        hex.setSelected();\n                        break;\n                    }\n                repaint();\n            }\n        });\n\n        char[] letters = \"LRDGITPFBVOKANUYCESM\".toCharArray();\n        comb = new Hexagon[20];\n\n        int x1 = 150, y1 = 100, x2 = 225, y2 = 143, w = 150, h = 87;\n        for (int i = 0; i < comb.length; i++) {\n            int x, y;\n            if (i < 12) {\n                x = x1 + (i % 3) * w;\n                y = y1 + (i / 3) * h;\n            } else {\n                x = x2 + (i % 2) * w;\n                y = y2 + ((i - 12) / 2) * h;\n            }\n            comb[i] = new Hexagon(x, y, w / 3, letters[i]);\n        }\n\n        requestFocus();\n    }\n\n    @Override\n    public void paintComponent(Graphics gg) {\n        super.paintComponent(gg);\n        Graphics2D g = (Graphics2D) gg;\n        g.setRenderingHint(RenderingHints.KEY_ANTIALIASING,\n                RenderingHints.VALUE_ANTIALIAS_ON);\n\n        g.setFont(new Font(\"SansSerif\", Font.BOLD, 30));\n        g.setStroke(new BasicStroke(3));\n\n        for (Hexagon hex : comb)\n            hex.draw(g);\n    }\n}\n\nclass Hexagon extends Polygon {\n    final Color baseColor = Color.yellow;\n    final Color selectedColor = Color.magenta;\n    final char letter;\n\n    private boolean hasBeenSelected;\n\n    Hexagon(int x, int y, int halfWidth, char c) {\n        letter = c;\n        for (int i = 0; i < 6; i++)\n            addPoint((int) (x + halfWidth * Math.cos(i * Math.PI / 3)),\n                     (int) (y + halfWidth * Math.sin(i * Math.PI / 3)));\n        getBounds();\n    }\n\n    void setSelected() {\n        hasBeenSelected = true;\n    }\n\n    void draw(Graphics2D g) {\n        g.setColor(hasBeenSelected ? selectedColor : baseColor);\n        g.fillPolygon(this);\n\n        g.setColor(Color.black);\n        g.drawPolygon(this);\n\n        g.setColor(hasBeenSelected ? Color.black : Color.red);\n        drawCenteredString(g, String.valueOf(letter));\n    }\n\n    void drawCenteredString(Graphics2D g, String s) {\n        FontMetrics fm = g.getFontMetrics();\n        int asc = fm.getAscent();\n        int dec = fm.getDescent();\n\n        int x = bounds.x + (bounds.width - fm.stringWidth(s)) / 2;\n        int y = bounds.y + (asc + (bounds.height - (asc + dec)) / 2);\n\n        g.drawString(s, x, y);\n    }\n}\n"}
{"id": 142334, "name": "String prepend", "source": "Translate Ruby to C#: str = \"llo world\"\nstr.prepend(\"He\")\np str \n", "target": "using System;\n\nnamespace PrependString\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            string str = \"World\";\n            str = \"Hello \" + str;\n            Console.WriteLine(str);\n            Console.ReadKey();\n        }\n    }\n}\n"}
{"id": 142336, "name": "String prepend", "source": "Translate Ruby to Java: str = \"llo world\"\nstr.prepend(\"He\")\np str \n", "target": "\npublic class Prepend {\n    public static void main(String[] args) {\n        StringBuilder sb = new StringBuilder(\"world\");\n        sb.insert(0, \"Hello, \");\n        System.out.println(sb);\n    }\n}\n"}
{"id": 142337, "name": "String prepend", "source": "Translate Ruby to Python: str = \"llo world\"\nstr.prepend(\"He\")\np str \n", "target": "\n\n\ns = \"12345678\"\ns = \"0\" + s  \nprint(s)\n"}
{"id": 142570, "name": "Currency", "source": "Translate Ruby to C#: require 'bigdecimal/util'\n\nbefore_tax = 4000000000000000 * 5.50.to_d + 2 * 2.86.to_d\ntax        = (before_tax * 0.0765.to_d).round(2)\ntotal      = before_tax + tax\n\nputs \"Before tax: $\nTax: $\nTotal: $\n", "target": "using System;\nusing System.Collections.Generic;\n\nnamespace Currency\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            MenuItem hamburger = new MenuItem() { Name = \"Hamburger\", Price = 5.5M };\n            MenuItem milkshake = new MenuItem() { Name = \"Milkshake\", Price = 2.86M };\n\n            IList<CartItem> cart = new List<CartItem>();\n            cart.Add(new CartItem() { item = hamburger, quantity = 4000000000000000 });\n            cart.Add(new CartItem() { item = milkshake, quantity = 2 });\n\n            decimal total = CalculateTotal(cart);\n\n            Console.WriteLine(string.Format(\"Total before tax: {0:C}\", total));\n\n            \n            decimal tax = total * 0.0765M;\n\n            Console.WriteLine(string.Format(\"Tax: {0:C}\", tax));\n\n            total += tax;\n\n            Console.WriteLine(string.Format(\"Total with tax: {0:C}\", total));\n        }\n\n        private static decimal CalculateTotal(IList<CartItem> cart)\n        {\n            decimal total = 0M;\n\n            foreach (CartItem item in cart)\n            {\n                total += item.quantity * item.item.Price;\n            }\n\n            return total;\n        }\n\n        private struct MenuItem\n        {\n            public string Name { get; set; }\n            public decimal Price { get; set; }\n        }\n\n        private struct CartItem\n        {\n            public MenuItem item { get; set; }\n            public decimal quantity { get; set; }\n        }\n    }\n}\n"}
{"id": 142571, "name": "Currency", "source": "Translate Ruby to C#: require 'bigdecimal/util'\n\nbefore_tax = 4000000000000000 * 5.50.to_d + 2 * 2.86.to_d\ntax        = (before_tax * 0.0765.to_d).round(2)\ntotal      = before_tax + tax\n\nputs \"Before tax: $\nTax: $\nTotal: $\n", "target": "using System;\nusing System.Collections.Generic;\n\nnamespace Currency\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            MenuItem hamburger = new MenuItem() { Name = \"Hamburger\", Price = 5.5M };\n            MenuItem milkshake = new MenuItem() { Name = \"Milkshake\", Price = 2.86M };\n\n            IList<CartItem> cart = new List<CartItem>();\n            cart.Add(new CartItem() { item = hamburger, quantity = 4000000000000000 });\n            cart.Add(new CartItem() { item = milkshake, quantity = 2 });\n\n            decimal total = CalculateTotal(cart);\n\n            Console.WriteLine(string.Format(\"Total before tax: {0:C}\", total));\n\n            \n            decimal tax = total * 0.0765M;\n\n            Console.WriteLine(string.Format(\"Tax: {0:C}\", tax));\n\n            total += tax;\n\n            Console.WriteLine(string.Format(\"Total with tax: {0:C}\", total));\n        }\n\n        private static decimal CalculateTotal(IList<CartItem> cart)\n        {\n            decimal total = 0M;\n\n            foreach (CartItem item in cart)\n            {\n                total += item.quantity * item.item.Price;\n            }\n\n            return total;\n        }\n\n        private struct MenuItem\n        {\n            public string Name { get; set; }\n            public decimal Price { get; set; }\n        }\n\n        private struct CartItem\n        {\n            public MenuItem item { get; set; }\n            public decimal quantity { get; set; }\n        }\n    }\n}\n"}
{"id": 142572, "name": "Currency", "source": "Translate Ruby to Java: require 'bigdecimal/util'\n\nbefore_tax = 4000000000000000 * 5.50.to_d + 2 * 2.86.to_d\ntax        = (before_tax * 0.0765.to_d).round(2)\ntotal      = before_tax + tax\n\nputs \"Before tax: $\nTax: $\nTotal: $\n", "target": "import java.math.*;\nimport java.util.*;\n\npublic class Currency {\n    final static String taxrate = \"7.65\";\n\n    enum MenuItem {\n\n        Hamburger(\"5.50\"), Milkshake(\"2.86\");\n\n        private MenuItem(String p) {\n            price = new BigDecimal(p);\n        }\n\n        public final BigDecimal price;\n    }\n\n    public static void main(String[] args) {\n        Locale.setDefault(Locale.ENGLISH);\n\n        MathContext mc = MathContext.DECIMAL128;\n\n        Map<MenuItem, BigDecimal> order = new HashMap<>();\n        order.put(MenuItem.Hamburger, new BigDecimal(\"4000000000000000\"));\n        order.put(MenuItem.Milkshake, new BigDecimal(\"2\"));\n\n        BigDecimal subtotal = BigDecimal.ZERO;\n        for (MenuItem it : order.keySet())\n            subtotal = subtotal.add(it.price.multiply(order.get(it), mc));\n\n        BigDecimal tax = new BigDecimal(taxrate, mc);\n        tax = tax.divide(new BigDecimal(\"100\"), mc);\n        tax = subtotal.multiply(tax, mc);\n\n        System.out.printf(\"Subtotal: %20.2f%n\", subtotal);\n        System.out.printf(\"     Tax: %20.2f%n\", tax);\n        System.out.printf(\"   Total: %20.2f%n\", subtotal.add(tax));\n    }\n}\n"}
{"id": 142573, "name": "Currency", "source": "Translate Ruby to Java: require 'bigdecimal/util'\n\nbefore_tax = 4000000000000000 * 5.50.to_d + 2 * 2.86.to_d\ntax        = (before_tax * 0.0765.to_d).round(2)\ntotal      = before_tax + tax\n\nputs \"Before tax: $\nTax: $\nTotal: $\n", "target": "import java.math.*;\nimport java.util.*;\n\npublic class Currency {\n    final static String taxrate = \"7.65\";\n\n    enum MenuItem {\n\n        Hamburger(\"5.50\"), Milkshake(\"2.86\");\n\n        private MenuItem(String p) {\n            price = new BigDecimal(p);\n        }\n\n        public final BigDecimal price;\n    }\n\n    public static void main(String[] args) {\n        Locale.setDefault(Locale.ENGLISH);\n\n        MathContext mc = MathContext.DECIMAL128;\n\n        Map<MenuItem, BigDecimal> order = new HashMap<>();\n        order.put(MenuItem.Hamburger, new BigDecimal(\"4000000000000000\"));\n        order.put(MenuItem.Milkshake, new BigDecimal(\"2\"));\n\n        BigDecimal subtotal = BigDecimal.ZERO;\n        for (MenuItem it : order.keySet())\n            subtotal = subtotal.add(it.price.multiply(order.get(it), mc));\n\n        BigDecimal tax = new BigDecimal(taxrate, mc);\n        tax = tax.divide(new BigDecimal(\"100\"), mc);\n        tax = subtotal.multiply(tax, mc);\n\n        System.out.printf(\"Subtotal: %20.2f%n\", subtotal);\n        System.out.printf(\"     Tax: %20.2f%n\", tax);\n        System.out.printf(\"   Total: %20.2f%n\", subtotal.add(tax));\n    }\n}\n"}
{"id": 142574, "name": "Currency", "source": "Translate Ruby to Python: require 'bigdecimal/util'\n\nbefore_tax = 4000000000000000 * 5.50.to_d + 2 * 2.86.to_d\ntax        = (before_tax * 0.0765.to_d).round(2)\ntotal      = before_tax + tax\n\nputs \"Before tax: $\nTax: $\nTotal: $\n", "target": "from decimal import Decimal as D\nfrom collections import namedtuple\n\nItem = namedtuple('Item', 'price, quant')\n\nitems = dict( hamburger=Item(D('5.50'), D('4000000000000000')),\n              milkshake=Item(D('2.86'), D('2')) )\ntax_rate = D('0.0765')\n\nfmt = \"%-10s %8s %18s %22s\"\nprint(fmt % tuple('Item Price Quantity Extension'.upper().split()))\n\ntotal_before_tax = 0\nfor item, (price, quant) in sorted(items.items()):\n    ext = price * quant\n    print(fmt % (item, price, quant, ext))\n    total_before_tax += ext\nprint(fmt % ('', '', '', '--------------------'))\nprint(fmt % ('', '', 'subtotal', total_before_tax))\n\ntax = (tax_rate * total_before_tax).quantize(D('0.00'))\nprint(fmt % ('', '', 'Tax', tax))\n\ntotal = total_before_tax + tax\nprint(fmt % ('', '', '', '--------------------'))\nprint(fmt % ('', '', 'Total', total))\n"}
{"id": 142575, "name": "Currency", "source": "Translate Ruby to Python: require 'bigdecimal/util'\n\nbefore_tax = 4000000000000000 * 5.50.to_d + 2 * 2.86.to_d\ntax        = (before_tax * 0.0765.to_d).round(2)\ntotal      = before_tax + tax\n\nputs \"Before tax: $\nTax: $\nTotal: $\n", "target": "from decimal import Decimal as D\nfrom collections import namedtuple\n\nItem = namedtuple('Item', 'price, quant')\n\nitems = dict( hamburger=Item(D('5.50'), D('4000000000000000')),\n              milkshake=Item(D('2.86'), D('2')) )\ntax_rate = D('0.0765')\n\nfmt = \"%-10s %8s %18s %22s\"\nprint(fmt % tuple('Item Price Quantity Extension'.upper().split()))\n\ntotal_before_tax = 0\nfor item, (price, quant) in sorted(items.items()):\n    ext = price * quant\n    print(fmt % (item, price, quant, ext))\n    total_before_tax += ext\nprint(fmt % ('', '', '', '--------------------'))\nprint(fmt % ('', '', 'subtotal', total_before_tax))\n\ntax = (tax_rate * total_before_tax).quantize(D('0.00'))\nprint(fmt % ('', '', 'Tax', tax))\n\ntotal = total_before_tax + tax\nprint(fmt % ('', '', '', '--------------------'))\nprint(fmt % ('', '', 'Total', total))\n"}
{"id": 142882, "name": "Fast Fourier transform", "source": "Translate Ruby to C#: require \"complex\"\n\ndef fft(x : Array(Int32 | Float64)) \n  return [x[0].to_c] if x.size <= 1\n  even = fft(Array.new(x.size // 2) { |k| x[2 * k] })\n  odd  = fft(Array.new(x.size // 2) { |k| x[2 * k + 1] })\n  c = Array.new(x.size // 2) { |k| Math.exp((-2 * Math::PI * k / x.size).i) }\n  codd = Array.new(x.size // 2) { |k| c[k] * odd[k] }\n  return Array.new(x.size // 2) { |k| even[k] + codd[k] } + Array.new(x.size // 2) { |k| even[k] - codd[k] }\nend\n \nfft([1,1,1,1,0,0,0,0]).each{ |c| puts c }\n", "target": "using System;\nusing System.Numerics;\nusing System.Linq;\nusing System.Diagnostics;\n\n\npublic class Program {\n\n    \n    public static int BitReverse(int n, int bits) {\n       int reversedN = n;\n       int count = bits - 1;\n\n       n >>= 1;\n       while (n > 0) {\n            reversedN = (reversedN << 1) | (n & 1);\n            count--;\n            n >>= 1;\n        }\n\n        return ((reversedN << count) & ((1 << bits) - 1));\n    }\n\n    \n    public static void FFT(Complex[] buffer) {\n#if false\n        int bits = (int)Math.Log(buffer.Length, 2);\n        for (int j = 1; j < buffer.Length / 2; j++) {\n\n            int swapPos = BitReverse(j, bits);\n            var temp = buffer[j];\n            buffer[j] = buffer[swapPos];\n            buffer[swapPos] = temp;\n        }\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n#else\n            for (int j = 1; j < buffer.Length; j++)\n            {\n                int swapPos = BitReverse(j, bits);\n                if (swapPos <= j)\n                {\n                    continue;\n                }\n                var temp = buffer[j];\n                buffer[j] = buffer[swapPos];\n                buffer[swapPos] = temp;\n            }\n\n\n\n\n#endif\n\n        for (int N = 2; N <= buffer.Length; N <<= 1) {\n            for (int i = 0; i < buffer.Length; i += N) {\n                for (int k = 0; k < N / 2; k++) {\n\n                    int evenIndex = i + k;\n                    int oddIndex = i + k + (N / 2);\n                    var even = buffer[evenIndex];\n                    var odd = buffer[oddIndex];\n\n                    double term = -2 * Math.PI * k / (double)N;\n                    Complex exp = new Complex(Math.Cos(term), Math.Sin(term)) * odd;\n\n                    buffer[evenIndex] = even + exp;\n                    buffer[oddIndex] = even - exp;\n\n                }\n            }\n        }\n    }\n\n    public static void Main(string[] args) {\n        Complex[] input = {1.0, 1.0, 1.0, 1.0, 0.0, 0.0, 0.0, 0.0};       \n        \n        FFT(input);       \n                  \n        Console.WriteLine(\"Results:\");\n        foreach (Complex c in input) {\n            Console.WriteLine(c);   \n        }   \n    }\n}\n"}
{"id": 142883, "name": "Fast Fourier transform", "source": "Translate Ruby to C#: require \"complex\"\n\ndef fft(x : Array(Int32 | Float64)) \n  return [x[0].to_c] if x.size <= 1\n  even = fft(Array.new(x.size // 2) { |k| x[2 * k] })\n  odd  = fft(Array.new(x.size // 2) { |k| x[2 * k + 1] })\n  c = Array.new(x.size // 2) { |k| Math.exp((-2 * Math::PI * k / x.size).i) }\n  codd = Array.new(x.size // 2) { |k| c[k] * odd[k] }\n  return Array.new(x.size // 2) { |k| even[k] + codd[k] } + Array.new(x.size // 2) { |k| even[k] - codd[k] }\nend\n \nfft([1,1,1,1,0,0,0,0]).each{ |c| puts c }\n", "target": "using System;\nusing System.Numerics;\nusing System.Linq;\nusing System.Diagnostics;\n\n\npublic class Program {\n\n    \n    public static int BitReverse(int n, int bits) {\n       int reversedN = n;\n       int count = bits - 1;\n\n       n >>= 1;\n       while (n > 0) {\n            reversedN = (reversedN << 1) | (n & 1);\n            count--;\n            n >>= 1;\n        }\n\n        return ((reversedN << count) & ((1 << bits) - 1));\n    }\n\n    \n    public static void FFT(Complex[] buffer) {\n#if false\n        int bits = (int)Math.Log(buffer.Length, 2);\n        for (int j = 1; j < buffer.Length / 2; j++) {\n\n            int swapPos = BitReverse(j, bits);\n            var temp = buffer[j];\n            buffer[j] = buffer[swapPos];\n            buffer[swapPos] = temp;\n        }\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n#else\n            for (int j = 1; j < buffer.Length; j++)\n            {\n                int swapPos = BitReverse(j, bits);\n                if (swapPos <= j)\n                {\n                    continue;\n                }\n                var temp = buffer[j];\n                buffer[j] = buffer[swapPos];\n                buffer[swapPos] = temp;\n            }\n\n\n\n\n#endif\n\n        for (int N = 2; N <= buffer.Length; N <<= 1) {\n            for (int i = 0; i < buffer.Length; i += N) {\n                for (int k = 0; k < N / 2; k++) {\n\n                    int evenIndex = i + k;\n                    int oddIndex = i + k + (N / 2);\n                    var even = buffer[evenIndex];\n                    var odd = buffer[oddIndex];\n\n                    double term = -2 * Math.PI * k / (double)N;\n                    Complex exp = new Complex(Math.Cos(term), Math.Sin(term)) * odd;\n\n                    buffer[evenIndex] = even + exp;\n                    buffer[oddIndex] = even - exp;\n\n                }\n            }\n        }\n    }\n\n    public static void Main(string[] args) {\n        Complex[] input = {1.0, 1.0, 1.0, 1.0, 0.0, 0.0, 0.0, 0.0};       \n        \n        FFT(input);       \n                  \n        Console.WriteLine(\"Results:\");\n        foreach (Complex c in input) {\n            Console.WriteLine(c);   \n        }   \n    }\n}\n"}
{"id": 142886, "name": "Fast Fourier transform", "source": "Translate Ruby to Java: require \"complex\"\n\ndef fft(x : Array(Int32 | Float64)) \n  return [x[0].to_c] if x.size <= 1\n  even = fft(Array.new(x.size // 2) { |k| x[2 * k] })\n  odd  = fft(Array.new(x.size // 2) { |k| x[2 * k + 1] })\n  c = Array.new(x.size // 2) { |k| Math.exp((-2 * Math::PI * k / x.size).i) }\n  codd = Array.new(x.size // 2) { |k| c[k] * odd[k] }\n  return Array.new(x.size // 2) { |k| even[k] + codd[k] } + Array.new(x.size // 2) { |k| even[k] - codd[k] }\nend\n \nfft([1,1,1,1,0,0,0,0]).each{ |c| puts c }\n", "target": "import static java.lang.Math.*;\n\npublic class FastFourierTransform {\n\n    public static int bitReverse(int n, int bits) {\n        int reversedN = n;\n        int count = bits - 1;\n\n        n >>= 1;\n        while (n > 0) {\n            reversedN = (reversedN << 1) | (n & 1);\n            count--;\n            n >>= 1;\n        }\n\n        return ((reversedN << count) & ((1 << bits) - 1));\n    }\n\n    static void fft(Complex[] buffer) {\n\n        int bits = (int) (log(buffer.length) / log(2));\n        for (int j = 1; j < buffer.length / 2; j++) {\n\n            int swapPos = bitReverse(j, bits);\n            Complex temp = buffer[j];\n            buffer[j] = buffer[swapPos];\n            buffer[swapPos] = temp;\n        }\n\n        for (int N = 2; N <= buffer.length; N <<= 1) {\n            for (int i = 0; i < buffer.length; i += N) {\n                for (int k = 0; k < N / 2; k++) {\n\n                    int evenIndex = i + k;\n                    int oddIndex = i + k + (N / 2);\n                    Complex even = buffer[evenIndex];\n                    Complex odd = buffer[oddIndex];\n\n                    double term = (-2 * PI * k) / (double) N;\n                    Complex exp = (new Complex(cos(term), sin(term)).mult(odd));\n\n                    buffer[evenIndex] = even.add(exp);\n                    buffer[oddIndex] = even.sub(exp);\n                }\n            }\n        }\n    }\n\n    public static void main(String[] args) {\n        double[] input = {1.0, 1.0, 1.0, 1.0, 0.0, 0.0, 0.0, 0.0};\n\n        Complex[] cinput = new Complex[input.length];\n        for (int i = 0; i < input.length; i++)\n            cinput[i] = new Complex(input[i], 0.0);\n\n        fft(cinput);\n\n        System.out.println(\"Results:\");\n        for (Complex c : cinput) {\n            System.out.println(c);\n        }\n    }\n}\n\nclass Complex {\n    public final double re;\n    public final double im;\n\n    public Complex() {\n        this(0, 0);\n    }\n\n    public Complex(double r, double i) {\n        re = r;\n        im = i;\n    }\n\n    public Complex add(Complex b) {\n        return new Complex(this.re + b.re, this.im + b.im);\n    }\n\n    public Complex sub(Complex b) {\n        return new Complex(this.re - b.re, this.im - b.im);\n    }\n\n    public Complex mult(Complex b) {\n        return new Complex(this.re * b.re - this.im * b.im,\n                this.re * b.im + this.im * b.re);\n    }\n\n    @Override\n    public String toString() {\n        return String.format(\"(%f,%f)\", re, im);\n    }\n}\n"}
{"id": 142887, "name": "Fast Fourier transform", "source": "Translate Ruby to Java: require \"complex\"\n\ndef fft(x : Array(Int32 | Float64)) \n  return [x[0].to_c] if x.size <= 1\n  even = fft(Array.new(x.size // 2) { |k| x[2 * k] })\n  odd  = fft(Array.new(x.size // 2) { |k| x[2 * k + 1] })\n  c = Array.new(x.size // 2) { |k| Math.exp((-2 * Math::PI * k / x.size).i) }\n  codd = Array.new(x.size // 2) { |k| c[k] * odd[k] }\n  return Array.new(x.size // 2) { |k| even[k] + codd[k] } + Array.new(x.size // 2) { |k| even[k] - codd[k] }\nend\n \nfft([1,1,1,1,0,0,0,0]).each{ |c| puts c }\n", "target": "import static java.lang.Math.*;\n\npublic class FastFourierTransform {\n\n    public static int bitReverse(int n, int bits) {\n        int reversedN = n;\n        int count = bits - 1;\n\n        n >>= 1;\n        while (n > 0) {\n            reversedN = (reversedN << 1) | (n & 1);\n            count--;\n            n >>= 1;\n        }\n\n        return ((reversedN << count) & ((1 << bits) - 1));\n    }\n\n    static void fft(Complex[] buffer) {\n\n        int bits = (int) (log(buffer.length) / log(2));\n        for (int j = 1; j < buffer.length / 2; j++) {\n\n            int swapPos = bitReverse(j, bits);\n            Complex temp = buffer[j];\n            buffer[j] = buffer[swapPos];\n            buffer[swapPos] = temp;\n        }\n\n        for (int N = 2; N <= buffer.length; N <<= 1) {\n            for (int i = 0; i < buffer.length; i += N) {\n                for (int k = 0; k < N / 2; k++) {\n\n                    int evenIndex = i + k;\n                    int oddIndex = i + k + (N / 2);\n                    Complex even = buffer[evenIndex];\n                    Complex odd = buffer[oddIndex];\n\n                    double term = (-2 * PI * k) / (double) N;\n                    Complex exp = (new Complex(cos(term), sin(term)).mult(odd));\n\n                    buffer[evenIndex] = even.add(exp);\n                    buffer[oddIndex] = even.sub(exp);\n                }\n            }\n        }\n    }\n\n    public static void main(String[] args) {\n        double[] input = {1.0, 1.0, 1.0, 1.0, 0.0, 0.0, 0.0, 0.0};\n\n        Complex[] cinput = new Complex[input.length];\n        for (int i = 0; i < input.length; i++)\n            cinput[i] = new Complex(input[i], 0.0);\n\n        fft(cinput);\n\n        System.out.println(\"Results:\");\n        for (Complex c : cinput) {\n            System.out.println(c);\n        }\n    }\n}\n\nclass Complex {\n    public final double re;\n    public final double im;\n\n    public Complex() {\n        this(0, 0);\n    }\n\n    public Complex(double r, double i) {\n        re = r;\n        im = i;\n    }\n\n    public Complex add(Complex b) {\n        return new Complex(this.re + b.re, this.im + b.im);\n    }\n\n    public Complex sub(Complex b) {\n        return new Complex(this.re - b.re, this.im - b.im);\n    }\n\n    public Complex mult(Complex b) {\n        return new Complex(this.re * b.re - this.im * b.im,\n                this.re * b.im + this.im * b.re);\n    }\n\n    @Override\n    public String toString() {\n        return String.format(\"(%f,%f)\", re, im);\n    }\n}\n"}
{"id": 142888, "name": "Fast Fourier transform", "source": "Translate Ruby to Python: require \"complex\"\n\ndef fft(x : Array(Int32 | Float64)) \n  return [x[0].to_c] if x.size <= 1\n  even = fft(Array.new(x.size // 2) { |k| x[2 * k] })\n  odd  = fft(Array.new(x.size // 2) { |k| x[2 * k + 1] })\n  c = Array.new(x.size // 2) { |k| Math.exp((-2 * Math::PI * k / x.size).i) }\n  codd = Array.new(x.size // 2) { |k| c[k] * odd[k] }\n  return Array.new(x.size // 2) { |k| even[k] + codd[k] } + Array.new(x.size // 2) { |k| even[k] - codd[k] }\nend\n \nfft([1,1,1,1,0,0,0,0]).each{ |c| puts c }\n", "target": "from cmath import exp, pi\n\ndef fft(x):\n    N = len(x)\n    if N <= 1: return x\n    even = fft(x[0::2])\n    odd =  fft(x[1::2])\n    T= [exp(-2j*pi*k/N)*odd[k] for k in range(N//2)]\n    return [even[k] + T[k] for k in range(N//2)] + \\\n           [even[k] - T[k] for k in range(N//2)]\n\nprint( ' '.join(\"%5.3f\" % abs(f) \n                for f in fft([1.0, 1.0, 1.0, 1.0, 0.0, 0.0, 0.0, 0.0])) )\n"}
{"id": 142889, "name": "Fast Fourier transform", "source": "Translate Ruby to Python: require \"complex\"\n\ndef fft(x : Array(Int32 | Float64)) \n  return [x[0].to_c] if x.size <= 1\n  even = fft(Array.new(x.size // 2) { |k| x[2 * k] })\n  odd  = fft(Array.new(x.size // 2) { |k| x[2 * k + 1] })\n  c = Array.new(x.size // 2) { |k| Math.exp((-2 * Math::PI * k / x.size).i) }\n  codd = Array.new(x.size // 2) { |k| c[k] * odd[k] }\n  return Array.new(x.size // 2) { |k| even[k] + codd[k] } + Array.new(x.size // 2) { |k| even[k] - codd[k] }\nend\n \nfft([1,1,1,1,0,0,0,0]).each{ |c| puts c }\n", "target": "from cmath import exp, pi\n\ndef fft(x):\n    N = len(x)\n    if N <= 1: return x\n    even = fft(x[0::2])\n    odd =  fft(x[1::2])\n    T= [exp(-2j*pi*k/N)*odd[k] for k in range(N//2)]\n    return [even[k] + T[k] for k in range(N//2)] + \\\n           [even[k] - T[k] for k in range(N//2)]\n\nprint( ' '.join(\"%5.3f\" % abs(f) \n                for f in fft([1.0, 1.0, 1.0, 1.0, 0.0, 0.0, 0.0, 0.0])) )\n"}
{"id": 143192, "name": "Increment a numerical string", "source": "Translate Ruby to C#: '1234'.succ \n'99'.succ \n", "target": "string s = \"12345\";\ns = (int.Parse(s) + 1).ToString();\n\n\n\n\n\n\nusing System.Numerics;\nstring bis = \"123456789012345678999999999\";\nbis = (BigInteger.Parse(bis) + 1).ToString();\n\n\n"}
{"id": 143194, "name": "Increment a numerical string", "source": "Translate Ruby to Java: '1234'.succ \n'99'.succ \n", "target": "String s = \"12345\";\nIntLiteral lit1 = new IntLiteral(s);\nIntLiteral lit2 = 6789;\n++lit1; \n++lit2; \n"}
{"id": 143347, "name": "Humble numbers", "source": "Translate Ruby to C#: def humble?(i)\n  return true if (i < 2)\n  return humble?(i // 2) if (i % 2 == 0)\n  return humble?(i // 3) if (i % 3 == 0)\n  return humble?(i // 5) if (i % 5 == 0)\n  return humble?(i // 7) if (i % 7 == 0)\n  false\nend\n\ncount, num = 0, 0_i64\ndigits = 10                        \nlimit  = 10_i64 ** digits          \nhumble = Array.new(digits + 1, 0)\n\nwhile (num += 1) < limit\n  if humble?(num)\n    humble[num.to_s.size] += 1\n    print num, \" \" if count < 50\n    count += 1\n  end\nend\n\nprint \"\\n\\nOf the first \n(1..digits).each { |num|  printf(\"%5d have %2d digits\\n\", humble[num], num) }\n", "target": "using System;\nusing System.Collections.Generic;\n\nnamespace HumbleNumbers {\n    class Program {\n        static bool IsHumble(int i) {\n            if (i <= 1) return true;\n            if (i % 2 == 0) return IsHumble(i / 2);\n            if (i % 3 == 0) return IsHumble(i / 3);\n            if (i % 5 == 0) return IsHumble(i / 5);\n            if (i % 7 == 0) return IsHumble(i / 7);\n            return false;\n        }\n\n        static void Main() {\n            var limit = short.MaxValue;\n            Dictionary<int, int> humble = new Dictionary<int, int>();\n            var count = 0;\n            var num = 1;\n\n            while (count < limit) {\n                if (IsHumble(num)) {\n                    var str = num.ToString();\n                    var len = str.Length;\n                    if (humble.ContainsKey(len)) {\n                        humble[len]++;\n                    } else {\n                        humble[len] = 1;\n                    }\n                    if (count < 50) Console.Write(\"{0} \", num);\n                    count++;\n                }\n                num++;\n            }\n            Console.WriteLine(\"\\n\");\n\n            Console.WriteLine(\"Of the first {0} humble numbers:\", count);\n            num = 1;\n            while (num < humble.Count - 1) {\n                if (humble.ContainsKey(num)) {\n                    var c = humble[num];\n                    Console.WriteLine(\"{0,5} have {1,2} digits\", c, num);\n                    num++;\n                } else {\n                    break;\n                }\n            }\n        }\n    }\n}\n"}
{"id": 143349, "name": "Humble numbers", "source": "Translate Ruby to Java: def humble?(i)\n  return true if (i < 2)\n  return humble?(i // 2) if (i % 2 == 0)\n  return humble?(i // 3) if (i % 3 == 0)\n  return humble?(i // 5) if (i % 5 == 0)\n  return humble?(i // 7) if (i % 7 == 0)\n  false\nend\n\ncount, num = 0, 0_i64\ndigits = 10                        \nlimit  = 10_i64 ** digits          \nhumble = Array.new(digits + 1, 0)\n\nwhile (num += 1) < limit\n  if humble?(num)\n    humble[num.to_s.size] += 1\n    print num, \" \" if count < 50\n    count += 1\n  end\nend\n\nprint \"\\n\\nOf the first \n(1..digits).each { |num|  printf(\"%5d have %2d digits\\n\", humble[num], num) }\n", "target": "import java.math.BigInteger;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\n\npublic class HumbleNumbers {\n\n    public static void main(String[] args) {\n        System.out.println(\"First 50 humble numbers:\");\n        System.out.println(Arrays.toString(humble(50)));\n        Map<Integer,Integer> lengthCountMap = new HashMap<>();\n        BigInteger[] seq = humble(1_000_000);\n        for ( int i = 0 ; i < seq.length ; i++ ) {\n            BigInteger humbleNumber = seq[i];\n            int len = humbleNumber.toString().length();\n            lengthCountMap.merge(len, 1, (v1, v2) -> v1 + v2);\n        }\n        List<Integer> sorted = new ArrayList<>(lengthCountMap.keySet());\n        Collections.sort(sorted);\n        System.out.printf(\"Length  Count%n\");\n        for ( Integer len : sorted ) {\n            System.out.printf(\"    %2s  %5s%n\", len, lengthCountMap.get(len));\n        }\n    }\n    \n    private static BigInteger[] humble(int n) {\n        BigInteger two = BigInteger.valueOf(2);\n        BigInteger twoTest = two;\n        BigInteger three = BigInteger.valueOf(3);\n        BigInteger threeTest = three;\n        BigInteger five = BigInteger.valueOf(5);\n        BigInteger fiveTest = five;\n        BigInteger seven = BigInteger.valueOf(7);\n        BigInteger sevenTest = seven;\n        BigInteger[] results = new BigInteger[n];\n        results[0] = BigInteger.ONE;\n        int twoIndex = 0, threeIndex = 0, fiveIndex = 0, sevenIndex = 0;\n        for ( int index = 1 ; index < n ; index++ ) {\n            results[index] = twoTest.min(threeTest).min(fiveTest).min(sevenTest);\n            if ( results[index].compareTo(twoTest) == 0 ) {\n                twoIndex++;\n                twoTest = two.multiply(results[twoIndex]);\n            }\n            if (results[index].compareTo(threeTest) == 0 ) {\n                threeIndex++;\n                threeTest = three.multiply(results[threeIndex]);\n            }\n            if (results[index].compareTo(fiveTest) == 0 ) {\n                fiveIndex++;\n                fiveTest = five.multiply(results[fiveIndex]);\n            }\n            if (results[index].compareTo(sevenTest) == 0 ) {\n                sevenIndex++;\n                sevenTest = seven.multiply(results[sevenIndex]);\n            }\n        }\n        return results;\n    }\n\n}\n"}
{"id": 143350, "name": "Humble numbers", "source": "Translate Ruby to Python: def humble?(i)\n  return true if (i < 2)\n  return humble?(i // 2) if (i % 2 == 0)\n  return humble?(i // 3) if (i % 3 == 0)\n  return humble?(i // 5) if (i % 5 == 0)\n  return humble?(i // 7) if (i % 7 == 0)\n  false\nend\n\ncount, num = 0, 0_i64\ndigits = 10                        \nlimit  = 10_i64 ** digits          \nhumble = Array.new(digits + 1, 0)\n\nwhile (num += 1) < limit\n  if humble?(num)\n    humble[num.to_s.size] += 1\n    print num, \" \" if count < 50\n    count += 1\n  end\nend\n\nprint \"\\n\\nOf the first \n(1..digits).each { |num|  printf(\"%5d have %2d digits\\n\", humble[num], num) }\n", "target": "\n\nfrom itertools import groupby, islice\nfrom functools import reduce\n\n\n\ndef humbles():\n    \n    hs = set([1])\n    while True:\n        nxt = min(hs)\n        yield nxt\n        hs.remove(nxt)\n        hs.update(nxt * x for x in [2, 3, 5, 7])\n\n\n\n\ndef main():\n    \n\n    print('First 50 Humble numbers:\\n')\n    for row in chunksOf(10)(\n            take(50)(humbles())\n    ):\n        print(' '.join(map(\n            lambda x: str(x).rjust(3),\n            row\n        )))\n\n    print('\\nCounts of Humble numbers with n digits:\\n')\n    for tpl in take(10)(\n            (k, len(list(g))) for k, g in\n            groupby(len(str(x)) for x in humbles())\n    ):\n        print(tpl)\n\n\n\n\n\ndef chunksOf(n):\n    \n    return lambda xs: reduce(\n        lambda a, i: a + [xs[i:n + i]],\n        range(0, len(xs), n), []\n    ) if 0 < n else []\n\n\n\n\ndef take(n):\n    \n    return lambda xs: (\n        list(islice(xs, n))\n    )\n\n\n\nif __name__ == '__main__':\n    main()\n"}
{"id": 143528, "name": "Gamma function", "source": "Translate Ruby to C#: \ndef a\n   [ 1.00000_00000_00000_00000,  0.57721_56649_01532_86061, -0.65587_80715_20253_88108,\n    -0.04200_26350_34095_23553,  0.16653_86113_82291_48950, -0.04219_77345_55544_33675,\n    -0.00962_19715_27876_97356,  0.00721_89432_46663_09954, -0.00116_51675_91859_06511,\n    -0.00021_52416_74114_95097,  0.00012_80502_82388_11619, -0.00002_01348_54780_78824,\n    -0.00000_12504_93482_14267,  0.00000_11330_27231_98170, -0.00000_02056_33841_69776,\n     0.00000_00061_16095_10448,  0.00000_00050_02007_64447, -0.00000_00011_81274_57049,\n     0.00000_00001_04342_67117,  0.00000_00000_07782_26344, -0.00000_00000_03696_80562,\n     0.00000_00000_00510_03703, -0.00000_00000_00020_58326, -0.00000_00000_00005_34812,\n     0.00000_00000_00001_22678, -0.00000_00000_00000_11813,  0.00000_00000_00000_00119,\n     0.00000_00000_00000_00141, -0.00000_00000_00000_00023,  0.00000_00000_00000_00002 ]\nend\n\ndef taylor_gamma(x)\n  y = x.to_f - 1\n  1.0 / a.reverse.reduce(0) { |sum, an| sum * y + an }\nend\n\n\ndef p\n  [ 0.99999_99999_99809_93, 676.52036_81218_851, -1259.13921_67224_028, \n    771.32342_87776_5313, -176.61502_91621_4059,  12.50734_32786_86905, \n    -0.13857_10952_65720_12, 9.98436_95780_19571_6e-6, 1.50563_27351_49311_6e-7 ]\nend\n\ndef lanczos_gamma(z)\n  \n  z = z.to_f\n  if z < 0.5\n    Math::PI / (Math.sin(Math::PI * z) * lanczos_gamma(1 - z))\n  else\n    z -= 1\n    x = p[0]\n    (1..p.size - 1).each { |i| x += p[i] / (z + i) }\n    t = z + p.size - 1.5\n    Math.sqrt(2 * Math::PI) * t**(z + 0.5) * Math.exp(-t) * x\n  end\nend\n\nputs \"                Taylor Series         Lanczos Method        Builtin Function\"\n(1..27).each { |i| n = i/3.0; puts \"gamma(%.2f) =\u00a0%.14e \u00a0%.14e \u00a0%.14e\" % [n, taylor_gamma(n), lanczos_gamma(n), Math.gamma(n)] }\n", "target": "using System;\nusing System.Numerics;\n\nstatic int g = 7;\nstatic double[] p = {0.99999999999980993, 676.5203681218851, -1259.1392167224028,\n\t     771.32342877765313, -176.61502916214059, 12.507343278686905,\n\t     -0.13857109526572012, 9.9843695780195716e-6, 1.5056327351493116e-7};\n\t\t \nComplex Gamma(Complex z)\n{\n    \n    if (z.Real < 0.5)\n\t{\n        return Math.PI / (Complex.Sin( Math.PI * z) * Gamma(1 - z));\n\t}\n    else\n\t{\n        z -= 1;\n        Complex x = p[0];\n        for (var i = 1; i < g + 2; i++)\n\t\t{\n            x += p[i]/(z+i);\n\t\t}\n        Complex t = z + g + 0.5;\n        return Complex.Sqrt(2 * Math.PI) * (Complex.Pow(t, z + 0.5)) * Complex.Exp(-t) * x;\n\t}\n}\n"}
{"id": 143530, "name": "Gamma function", "source": "Translate Ruby to Java: \ndef a\n   [ 1.00000_00000_00000_00000,  0.57721_56649_01532_86061, -0.65587_80715_20253_88108,\n    -0.04200_26350_34095_23553,  0.16653_86113_82291_48950, -0.04219_77345_55544_33675,\n    -0.00962_19715_27876_97356,  0.00721_89432_46663_09954, -0.00116_51675_91859_06511,\n    -0.00021_52416_74114_95097,  0.00012_80502_82388_11619, -0.00002_01348_54780_78824,\n    -0.00000_12504_93482_14267,  0.00000_11330_27231_98170, -0.00000_02056_33841_69776,\n     0.00000_00061_16095_10448,  0.00000_00050_02007_64447, -0.00000_00011_81274_57049,\n     0.00000_00001_04342_67117,  0.00000_00000_07782_26344, -0.00000_00000_03696_80562,\n     0.00000_00000_00510_03703, -0.00000_00000_00020_58326, -0.00000_00000_00005_34812,\n     0.00000_00000_00001_22678, -0.00000_00000_00000_11813,  0.00000_00000_00000_00119,\n     0.00000_00000_00000_00141, -0.00000_00000_00000_00023,  0.00000_00000_00000_00002 ]\nend\n\ndef taylor_gamma(x)\n  y = x.to_f - 1\n  1.0 / a.reverse.reduce(0) { |sum, an| sum * y + an }\nend\n\n\ndef p\n  [ 0.99999_99999_99809_93, 676.52036_81218_851, -1259.13921_67224_028, \n    771.32342_87776_5313, -176.61502_91621_4059,  12.50734_32786_86905, \n    -0.13857_10952_65720_12, 9.98436_95780_19571_6e-6, 1.50563_27351_49311_6e-7 ]\nend\n\ndef lanczos_gamma(z)\n  \n  z = z.to_f\n  if z < 0.5\n    Math::PI / (Math.sin(Math::PI * z) * lanczos_gamma(1 - z))\n  else\n    z -= 1\n    x = p[0]\n    (1..p.size - 1).each { |i| x += p[i] / (z + i) }\n    t = z + p.size - 1.5\n    Math.sqrt(2 * Math::PI) * t**(z + 0.5) * Math.exp(-t) * x\n  end\nend\n\nputs \"                Taylor Series         Lanczos Method        Builtin Function\"\n(1..27).each { |i| n = i/3.0; puts \"gamma(%.2f) =\u00a0%.14e \u00a0%.14e \u00a0%.14e\" % [n, taylor_gamma(n), lanczos_gamma(n), Math.gamma(n)] }\n", "target": "public class GammaFunction {\n\n\tpublic double st_gamma(double x){\n\t\treturn Math.sqrt(2*Math.PI/x)*Math.pow((x/Math.E), x);\n\t}\n\t\n\tpublic double la_gamma(double x){\n\t\tdouble[] p = {0.99999999999980993, 676.5203681218851, -1259.1392167224028,\n\t\t\t     \t  771.32342877765313, -176.61502916214059, 12.507343278686905,\n\t\t\t     \t  -0.13857109526572012, 9.9843695780195716e-6, 1.5056327351493116e-7};\n\t\tint g = 7;\n\t\tif(x < 0.5) return Math.PI / (Math.sin(Math.PI * x)*la_gamma(1-x));\n\n\t\tx -= 1;\n\t\tdouble a = p[0];\n\t\tdouble t = x+g+0.5;\n\t\tfor(int i = 1; i < p.length; i++){\n\t\t\ta += p[i]/(x+i);\n\t\t}\n\t\t\n\t\treturn Math.sqrt(2*Math.PI)*Math.pow(t, x+0.5)*Math.exp(-t)*a;\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tGammaFunction test = new GammaFunction();\n\t\tSystem.out.println(\"Gamma \\t\\tStirling \\t\\tLanczos\");\n\t\tfor(double i = 1; i <= 20; i += 1){\n\t\t\tSystem.out.println(\"\" + i/10.0 + \"\\t\\t\" + test.st_gamma(i/10.0) + \"\\t\" + test.la_gamma(i/10.0));\n\t\t}\n\t}\n}\n"}
{"id": 143531, "name": "Gamma function", "source": "Translate Ruby to Python: \ndef a\n   [ 1.00000_00000_00000_00000,  0.57721_56649_01532_86061, -0.65587_80715_20253_88108,\n    -0.04200_26350_34095_23553,  0.16653_86113_82291_48950, -0.04219_77345_55544_33675,\n    -0.00962_19715_27876_97356,  0.00721_89432_46663_09954, -0.00116_51675_91859_06511,\n    -0.00021_52416_74114_95097,  0.00012_80502_82388_11619, -0.00002_01348_54780_78824,\n    -0.00000_12504_93482_14267,  0.00000_11330_27231_98170, -0.00000_02056_33841_69776,\n     0.00000_00061_16095_10448,  0.00000_00050_02007_64447, -0.00000_00011_81274_57049,\n     0.00000_00001_04342_67117,  0.00000_00000_07782_26344, -0.00000_00000_03696_80562,\n     0.00000_00000_00510_03703, -0.00000_00000_00020_58326, -0.00000_00000_00005_34812,\n     0.00000_00000_00001_22678, -0.00000_00000_00000_11813,  0.00000_00000_00000_00119,\n     0.00000_00000_00000_00141, -0.00000_00000_00000_00023,  0.00000_00000_00000_00002 ]\nend\n\ndef taylor_gamma(x)\n  y = x.to_f - 1\n  1.0 / a.reverse.reduce(0) { |sum, an| sum * y + an }\nend\n\n\ndef p\n  [ 0.99999_99999_99809_93, 676.52036_81218_851, -1259.13921_67224_028, \n    771.32342_87776_5313, -176.61502_91621_4059,  12.50734_32786_86905, \n    -0.13857_10952_65720_12, 9.98436_95780_19571_6e-6, 1.50563_27351_49311_6e-7 ]\nend\n\ndef lanczos_gamma(z)\n  \n  z = z.to_f\n  if z < 0.5\n    Math::PI / (Math.sin(Math::PI * z) * lanczos_gamma(1 - z))\n  else\n    z -= 1\n    x = p[0]\n    (1..p.size - 1).each { |i| x += p[i] / (z + i) }\n    t = z + p.size - 1.5\n    Math.sqrt(2 * Math::PI) * t**(z + 0.5) * Math.exp(-t) * x\n  end\nend\n\nputs \"                Taylor Series         Lanczos Method        Builtin Function\"\n(1..27).each { |i| n = i/3.0; puts \"gamma(%.2f) =\u00a0%.14e \u00a0%.14e \u00a0%.14e\" % [n, taylor_gamma(n), lanczos_gamma(n), Math.gamma(n)] }\n", "target": "_a =    ( 1.00000000000000000000, 0.57721566490153286061, -0.65587807152025388108,\n         -0.04200263503409523553, 0.16653861138229148950, -0.04219773455554433675,\n         -0.00962197152787697356, 0.00721894324666309954, -0.00116516759185906511,\n         -0.00021524167411495097, 0.00012805028238811619, -0.00002013485478078824,\n         -0.00000125049348214267, 0.00000113302723198170, -0.00000020563384169776,\n          0.00000000611609510448, 0.00000000500200764447, -0.00000000118127457049,\n          0.00000000010434267117, 0.00000000000778226344, -0.00000000000369680562,\n          0.00000000000051003703, -0.00000000000002058326, -0.00000000000000534812,\n          0.00000000000000122678, -0.00000000000000011813, 0.00000000000000000119,\n          0.00000000000000000141, -0.00000000000000000023, 0.00000000000000000002\n       )\ndef gamma (x): \n   y  = float(x) - 1.0;\n   sm = _a[-1];\n   for an in _a[-2::-1]:\n      sm = sm * y + an;\n   return 1.0 / sm;\n \n\nif __name__ == '__main__':\n    for i in range(1,11):\n        print \"  %20.14e\" % gamma(i/3.0)\n"}
{"id": 143664, "name": "Polynomial long division", "source": "Translate Ruby to C#: def polynomial_long_division(numerator, denominator)\n  dd = degree(denominator)\n  raise ArgumentError, \"denominator is zero\" if dd < 0\n  if dd == 0\n    return [multiply(numerator, 1.0/denominator[0]), [0]*numerator.length]\n  end\n  \n  q = [0] * numerator.length\n  \n  while (dn = degree(numerator)) >= dd\n    d = shift_right(denominator, dn - dd)\n    q[dn-dd] = numerator[dn] / d[degree(d)]\n    d = multiply(d, q[dn-dd])\n    numerator = subtract(numerator, d)\n  end\n  \n  [q, numerator]\nend\n\ndef degree(ary)\n  idx = ary.rindex(&:nonzero?)\n  idx ? idx : -1\nend\n\ndef shift_right(ary, n)\n  [0]*n + ary[0, ary.length - n]\nend\n\ndef subtract(a1, a2)\n  a1.zip(a2).collect {|v1,v2| v1 - v2}\nend\n\ndef multiply(ary, num)\n  ary.collect {|x| x * num}\nend\n\nf = [-42, 0, -12, 1]\ng = [-3, 1, 0, 0]\nq, r = polynomial_long_division(f, g)\nputs \"\n\n\ng = [-3, 1, 1, 0]\nq, r = polynomial_long_division(f, g)\nputs \"\n\n", "target": "using System;\n\nnamespace PolynomialLongDivision {\n    class Solution {\n        public Solution(double[] q, double[] r) {\n            Quotient = q;\n            Remainder = r;\n        }\n\n        public double[] Quotient { get; }\n        public double[] Remainder { get; }\n    }\n\n    class Program {\n        static int PolyDegree(double[] p) {\n            for (int i = p.Length - 1; i >= 0; --i) {\n                if (p[i] != 0.0) return i;\n            }\n            return int.MinValue;\n        }\n\n        static double[] PolyShiftRight(double[] p, int places) {\n            if (places <= 0) return p;\n            int pd = PolyDegree(p);\n            if (pd + places >= p.Length) {\n                throw new ArgumentOutOfRangeException(\"The number of places to be shifted is too large\");\n            }\n            double[] d = new double[p.Length];\n            p.CopyTo(d, 0);\n            for (int i = pd; i >= 0; --i) {\n                d[i + places] = d[i];\n                d[i] = 0.0;\n            }\n            return d;\n        }\n\n        static void PolyMultiply(double[] p, double m) {\n            for (int i = 0; i < p.Length; ++i) {\n                p[i] *= m;\n            }\n        }\n\n        static void PolySubtract(double[] p, double[] s) {\n            for (int i = 0; i < p.Length; ++i) {\n                p[i] -= s[i];\n            }\n        }\n\n        static Solution PolyLongDiv(double[] n, double[] d) {\n            if (n.Length != d.Length) {\n                throw new ArgumentException(\"Numerator and denominator vectors must have the same size\");\n            }\n            int nd = PolyDegree(n);\n            int dd = PolyDegree(d);\n            if (dd < 0) {\n                throw new ArgumentException(\"Divisor must have at least one one-zero coefficient\");\n            }\n            if (nd < dd) {\n                throw new ArgumentException(\"The degree of the divisor cannot exceed that of the numerator\");\n            }\n            double[] n2 = new double[n.Length];\n            n.CopyTo(n2, 0);\n            double[] q = new double[n.Length];\n            while (nd >= dd) {\n                double[] d2 = PolyShiftRight(d, nd - dd);\n                q[nd - dd] = n2[nd] / d2[nd];\n                PolyMultiply(d2, q[nd - dd]);\n                PolySubtract(n2, d2);\n                nd = PolyDegree(n2);\n            }\n            return new Solution(q, n2);\n        }\n\n        static void PolyShow(double[] p) {\n            int pd = PolyDegree(p);\n            for (int i = pd; i >= 0; --i) {\n                double coeff = p[i];\n                if (coeff == 0.0) continue;\n                if (coeff == 1.0) {\n                    if (i < pd) {\n                        Console.Write(\" + \");\n                    }\n                } else if (coeff == -1.0) {\n                    if (i < pd) {\n                        Console.Write(\" - \");\n                    } else {\n                        Console.Write(\"-\");\n                    }\n                } else if (coeff < 0.0) {\n                    if (i < pd) {\n                        Console.Write(\" - {0:F1}\", -coeff);\n                    } else {\n                        Console.Write(\"{0:F1}\", coeff);\n                    }\n                } else {\n                    if (i < pd) {\n                        Console.Write(\" + {0:F1}\", coeff);\n                    } else {\n                        Console.Write(\"{0:F1}\", coeff);\n                    }\n                }\n                if (i > 1) Console.Write(\"x^{0}\", i);\n                else if (i == 1) Console.Write(\"x\");\n            }\n            Console.WriteLine();\n        }\n\n        static void Main(string[] args) {\n            double[] n = { -42.0, 0.0, -12.0, 1.0 };\n            double[] d = { -3.0, 1.0, 0.0, 0.0 };\n            Console.Write(\"Numerator  \u00a0: \");\n            PolyShow(n);\n            Console.Write(\"Denominator\u00a0: \");\n            PolyShow(d);\n            Console.WriteLine(\"-------------------------------------\");\n            Solution sol = PolyLongDiv(n, d);\n            Console.Write(\"Quotient   \u00a0: \");\n            PolyShow(sol.Quotient);\n            Console.Write(\"Remainder  \u00a0: \");\n            PolyShow(sol.Remainder);\n        }\n    }\n}\n"}
{"id": 143666, "name": "Polynomial long division", "source": "Translate Ruby to Python: def polynomial_long_division(numerator, denominator)\n  dd = degree(denominator)\n  raise ArgumentError, \"denominator is zero\" if dd < 0\n  if dd == 0\n    return [multiply(numerator, 1.0/denominator[0]), [0]*numerator.length]\n  end\n  \n  q = [0] * numerator.length\n  \n  while (dn = degree(numerator)) >= dd\n    d = shift_right(denominator, dn - dd)\n    q[dn-dd] = numerator[dn] / d[degree(d)]\n    d = multiply(d, q[dn-dd])\n    numerator = subtract(numerator, d)\n  end\n  \n  [q, numerator]\nend\n\ndef degree(ary)\n  idx = ary.rindex(&:nonzero?)\n  idx ? idx : -1\nend\n\ndef shift_right(ary, n)\n  [0]*n + ary[0, ary.length - n]\nend\n\ndef subtract(a1, a2)\n  a1.zip(a2).collect {|v1,v2| v1 - v2}\nend\n\ndef multiply(ary, num)\n  ary.collect {|x| x * num}\nend\n\nf = [-42, 0, -12, 1]\ng = [-3, 1, 0, 0]\nq, r = polynomial_long_division(f, g)\nputs \"\n\n\ng = [-3, 1, 1, 0]\nq, r = polynomial_long_division(f, g)\nputs \"\n\n", "target": "\n\nfrom itertools import izip\n\ndef degree(poly):\n    while poly and poly[-1] == 0:\n        poly.pop()   \n    return len(poly)-1\n\ndef poly_div(N, D):\n    dD = degree(D)\n    dN = degree(N)\n    if dD < 0: raise ZeroDivisionError\n    if dN >= dD:\n        q = [0] * dN\n        while dN >= dD:\n            d = [0]*(dN - dD) + D\n            mult = q[dN - dD] = N[-1] / float(d[-1])\n            d = [coeff*mult for coeff in d]\n            N = [coeffN - coeffd for coeffN, coeffd in izip(N, d)]\n            dN = degree(N)\n        r = N\n    else:\n        q = [0]\n        r = N\n    return q, r\n\nif __name__ == '__main__':\n    print \"POLYNOMIAL LONG DIVISION\"\n    N = [-42, 0, -12, 1]\n    D = [-3, 1, 0, 0]\n    print \"  %s / %s =\" % (N,D),\n    print \" %s remainder %s\" % poly_div(N, D)\n"}
{"id": 143891, "name": "Visualize a tree", "source": "Translate Ruby to C#: root = BinaryTreeNode.from_array [1, [2, [4, 7], [5]], [3, [6, [8], [9]]]]\n", "target": "using System;\n\npublic static class VisualizeTree\n{\n    public static void Main() {\n        \"A\".t(\n            \"B0\".t(\n                \"C1\",\n                \"C2\".t(\n                    \"D\".t(\"E1\", \"E2\", \"E3\")),\n                \"C3\".t(\n                    \"F1\",\n                    \"F2\",\n                    \"F3\".t(\"G\"),\n                    \"F4\".t(\"H1\", \"H2\"))),\n            \"B1\".t(\n                \"K1\",\n                \"K2\".t(\n                    \"L1\".t(\"M\"),\n                    \"L2\",\n                    \"L3\"),\n                \"K3\")\n        ).Print();\n    }\n\n    private static Tree t(this string value, params Tree[] children) => new Tree(value, children);\n\n    private static void Print(this Tree tree) => tree.Print(true, \"\");\n\n    private static void Print(this Tree tree, bool last, string prefix) {\n        (string current, string next) = last\n            ? (prefix + \"\u2514\u2500\" + tree.Value, prefix + \"  \")\n            : (prefix + \"\u251c\u2500\" + tree.Value, prefix + \"| \");\n        Console.WriteLine(current[2..]);\n        for (int c = 0; c < tree.Children.Length; c++) {\n            tree.Children[c].Print(c == tree.Children.Length - 1, next);\n        }\n    }\n\n    class Tree\n    {\n        public Tree(string value, params Tree[] children) => (Value, Children) = (value, children);\n        public static implicit operator Tree(string value) => new Tree(value);\n        public string Value { get; }\n        public Tree[] Children { get; }\n    }\n    \n}\n"}
{"id": 143892, "name": "Visualize a tree", "source": "Translate Ruby to C#: root = BinaryTreeNode.from_array [1, [2, [4, 7], [5]], [3, [6, [8], [9]]]]\n", "target": "using System;\n\npublic static class VisualizeTree\n{\n    public static void Main() {\n        \"A\".t(\n            \"B0\".t(\n                \"C1\",\n                \"C2\".t(\n                    \"D\".t(\"E1\", \"E2\", \"E3\")),\n                \"C3\".t(\n                    \"F1\",\n                    \"F2\",\n                    \"F3\".t(\"G\"),\n                    \"F4\".t(\"H1\", \"H2\"))),\n            \"B1\".t(\n                \"K1\",\n                \"K2\".t(\n                    \"L1\".t(\"M\"),\n                    \"L2\",\n                    \"L3\"),\n                \"K3\")\n        ).Print();\n    }\n\n    private static Tree t(this string value, params Tree[] children) => new Tree(value, children);\n\n    private static void Print(this Tree tree) => tree.Print(true, \"\");\n\n    private static void Print(this Tree tree, bool last, string prefix) {\n        (string current, string next) = last\n            ? (prefix + \"\u2514\u2500\" + tree.Value, prefix + \"  \")\n            : (prefix + \"\u251c\u2500\" + tree.Value, prefix + \"| \");\n        Console.WriteLine(current[2..]);\n        for (int c = 0; c < tree.Children.Length; c++) {\n            tree.Children[c].Print(c == tree.Children.Length - 1, next);\n        }\n    }\n\n    class Tree\n    {\n        public Tree(string value, params Tree[] children) => (Value, Children) = (value, children);\n        public static implicit operator Tree(string value) => new Tree(value);\n        public string Value { get; }\n        public Tree[] Children { get; }\n    }\n    \n}\n"}
{"id": 143895, "name": "Visualize a tree", "source": "Translate Ruby to Java: root = BinaryTreeNode.from_array [1, [2, [4, 7], [5]], [3, [6, [8], [9]]]]\n", "target": "public class VisualizeTree {\n    public static void main(String[] args) {\n        BinarySearchTree tree = new BinarySearchTree();\n\n        tree.insert(100);\n        for (int i = 0; i < 20; i++)\n            tree.insert((int) (Math.random() * 200));\n        tree.display();\n    }\n}\n\nclass BinarySearchTree {\n    private Node root;\n\n    private class Node {\n        private int key;\n        private Node left, right;\n\n        Node(int k) {\n            key = k;\n        }\n    }\n\n    public boolean insert(int key) {\n        if (root == null)\n            root = new Node(key);\n        else {\n            Node n = root;\n            Node parent;\n            while (true) {\n                if (n.key == key)\n                    return false;\n\n                parent = n;\n\n                boolean goLeft = key < n.key;\n                n = goLeft ? n.left : n.right;\n\n                if (n == null) {\n                    if (goLeft) {\n                        parent.left = new Node(key);\n                    } else {\n                        parent.right = new Node(key);\n                    }\n                    break;\n                }\n            }\n        }\n        return true;\n    }\n\n    public void display() {\n        final int height = 5, width = 64;\n\n        int len = width * height * 2 + 2;\n        StringBuilder sb = new StringBuilder(len);\n        for (int i = 1; i <= len; i++)\n            sb.append(i < len - 2 && i % width == 0 ? \"\\n\" : ' ');\n\n        displayR(sb, width / 2, 1, width / 4, width, root, \" \");\n        System.out.println(sb);\n    }\n\n    private void displayR(StringBuilder sb, int c, int r, int d, int w, Node n,\n            String edge) {\n        if (n != null) {\n            displayR(sb, c - d, r + 2, d / 2, w, n.left, \" /\");\n\n            String s = String.valueOf(n.key);\n            int idx1 = r * w + c - (s.length() + 1) / 2;\n            int idx2 = idx1 + s.length();\n            int idx3 = idx1 - w;\n            if (idx2 < sb.length())\n                sb.replace(idx1, idx2, s).replace(idx3, idx3 + 2, edge);\n\n            displayR(sb, c + d, r + 2, d / 2, w, n.right, \"\\\\ \");\n        }\n    }\n}\n"}
{"id": 143896, "name": "Visualize a tree", "source": "Translate Ruby to Java: root = BinaryTreeNode.from_array [1, [2, [4, 7], [5]], [3, [6, [8], [9]]]]\n", "target": "public class VisualizeTree {\n    public static void main(String[] args) {\n        BinarySearchTree tree = new BinarySearchTree();\n\n        tree.insert(100);\n        for (int i = 0; i < 20; i++)\n            tree.insert((int) (Math.random() * 200));\n        tree.display();\n    }\n}\n\nclass BinarySearchTree {\n    private Node root;\n\n    private class Node {\n        private int key;\n        private Node left, right;\n\n        Node(int k) {\n            key = k;\n        }\n    }\n\n    public boolean insert(int key) {\n        if (root == null)\n            root = new Node(key);\n        else {\n            Node n = root;\n            Node parent;\n            while (true) {\n                if (n.key == key)\n                    return false;\n\n                parent = n;\n\n                boolean goLeft = key < n.key;\n                n = goLeft ? n.left : n.right;\n\n                if (n == null) {\n                    if (goLeft) {\n                        parent.left = new Node(key);\n                    } else {\n                        parent.right = new Node(key);\n                    }\n                    break;\n                }\n            }\n        }\n        return true;\n    }\n\n    public void display() {\n        final int height = 5, width = 64;\n\n        int len = width * height * 2 + 2;\n        StringBuilder sb = new StringBuilder(len);\n        for (int i = 1; i <= len; i++)\n            sb.append(i < len - 2 && i % width == 0 ? \"\\n\" : ' ');\n\n        displayR(sb, width / 2, 1, width / 4, width, root, \" \");\n        System.out.println(sb);\n    }\n\n    private void displayR(StringBuilder sb, int c, int r, int d, int w, Node n,\n            String edge) {\n        if (n != null) {\n            displayR(sb, c - d, r + 2, d / 2, w, n.left, \" /\");\n\n            String s = String.valueOf(n.key);\n            int idx1 = r * w + c - (s.length() + 1) / 2;\n            int idx2 = idx1 + s.length();\n            int idx3 = idx1 - w;\n            if (idx2 < sb.length())\n                sb.replace(idx1, idx2, s).replace(idx3, idx3 + 2, edge);\n\n            displayR(sb, c + d, r + 2, d / 2, w, n.right, \"\\\\ \");\n        }\n    }\n}\n"}
{"id": 143897, "name": "Visualize a tree", "source": "Translate Ruby to Python: root = BinaryTreeNode.from_array [1, [2, [4, 7], [5]], [3, [6, [8], [9]]]]\n", "target": "Python 3.2.3 (default, May  3 2012, 15:54:42) \n[GCC 4.6.3] on linux2\nType \"copyright\", \"credits\" or \"license()\" for more information.\n>>> help('pprint.pprint')\nHelp on function pprint in pprint:\n\npprint.pprint = pprint(object, stream=None, indent=1, width=80, depth=None)\n    Pretty-print a Python object to a stream [default is sys.stdout].\n\n>>> from pprint import pprint\n>>> for tree in [ (1, 2, 3, 4, 5, 6, 7, 8),\n\t          (1, (( 2, 3 ), (4, (5, ((6, 7), 8))))),\n\t          ((((1, 2), 3), 4), 5, 6, 7, 8) ]:\n\tprint(\"\\nTree %r can be pprint'd as:\" % (tree, ))\n\tpprint(tree, indent=1, width=1)\n\n\t\n\nTree (1, 2, 3, 4, 5, 6, 7, 8) can be pprint'd as:\n(1,\n 2,\n 3,\n 4,\n 5,\n 6,\n 7,\n 8)\n\nTree (1, ((2, 3), (4, (5, ((6, 7), 8))))) can be pprint'd as:\n(1,\n ((2,\n   3),\n  (4,\n   (5,\n    ((6,\n      7),\n     8)))))\n\nTree ((((1, 2), 3), 4), 5, 6, 7, 8) can be pprint'd as:\n((((1,\n    2),\n   3),\n  4),\n 5,\n 6,\n 7,\n 8)\n>>>\n"}
{"id": 143898, "name": "Visualize a tree", "source": "Translate Ruby to Python: root = BinaryTreeNode.from_array [1, [2, [4, 7], [5]], [3, [6, [8], [9]]]]\n", "target": "Python 3.2.3 (default, May  3 2012, 15:54:42) \n[GCC 4.6.3] on linux2\nType \"copyright\", \"credits\" or \"license()\" for more information.\n>>> help('pprint.pprint')\nHelp on function pprint in pprint:\n\npprint.pprint = pprint(object, stream=None, indent=1, width=80, depth=None)\n    Pretty-print a Python object to a stream [default is sys.stdout].\n\n>>> from pprint import pprint\n>>> for tree in [ (1, 2, 3, 4, 5, 6, 7, 8),\n\t          (1, (( 2, 3 ), (4, (5, ((6, 7), 8))))),\n\t          ((((1, 2), 3), 4), 5, 6, 7, 8) ]:\n\tprint(\"\\nTree %r can be pprint'd as:\" % (tree, ))\n\tpprint(tree, indent=1, width=1)\n\n\t\n\nTree (1, 2, 3, 4, 5, 6, 7, 8) can be pprint'd as:\n(1,\n 2,\n 3,\n 4,\n 5,\n 6,\n 7,\n 8)\n\nTree (1, ((2, 3), (4, (5, ((6, 7), 8))))) can be pprint'd as:\n(1,\n ((2,\n   3),\n  (4,\n   (5,\n    ((6,\n      7),\n     8)))))\n\nTree ((((1, 2), 3), 4), 5, 6, 7, 8) can be pprint'd as:\n((((1,\n    2),\n   3),\n  4),\n 5,\n 6,\n 7,\n 8)\n>>>\n"}
{"id": 144177, "name": "Chaocipher", "source": "Translate Ruby to C#: txt    = \"WELLDONEISBETTERTHANWELLSAID\"\n@left  = \"HXUCZVAMDSLKPEFJRIGTWOBNYQ\".chars\n@right = \"PTLNBQDEOYSFAVZKGJRIHWXUMC\".chars\n\ndef encrypt(char)\n  coded_char = @left[@right.index(char)]\n\n  @left.rotate!(@left.index(coded_char))\n  part = @left.slice!(1,13).rotate\n  @left.insert(1, *part)\n\n  @right.rotate!(@right.index(char)+1)\n  part = @right.slice!(2,12).rotate\n  @right.insert(2, *part)\n  \n  @left[0]\nend\n\nputs txt.each_char.map{|c| encrypt(c) }.join\n", "target": "using System;\n\nnamespace Chaocipher {\n    enum Mode {\n        ENCRYPT,\n        DECRYPT,\n    }\n\n    class Program {\n        const string L_ALPHABET = \"HXUCZVAMDSLKPEFJRIGTWOBNYQ\";\n        const string R_ALPHABET = \"PTLNBQDEOYSFAVZKGJRIHWXUMC\";\n\n        static string Exec(string text, Mode mode, bool showSteps = false) {\n            char[] left = L_ALPHABET.ToCharArray();\n            char[] right = R_ALPHABET.ToCharArray();\n            char[] eText = new char[text.Length];\n            char[] temp = new char[26];\n\n            for (int i = 0; i < text.Length; ++i) {\n                if (showSteps) Console.WriteLine(\"{0} {1}\", string.Join(\"\", left), string.Join(\"\", right));\n                int index = 0;\n                if (mode == Mode.ENCRYPT) {\n                    index = Array.IndexOf(right, text[i]);\n                    eText[i] = left[index];\n                } else {\n                    index = Array.IndexOf(left, text[i]);\n                    eText[i] = right[index];\n                }\n                if (i == text.Length - 1) break;\n\n                \n\n                for (int j = index; j < 26; ++j) temp[j - index] = left[j];\n                for (int j = 0; j < index; ++j) temp[26 - index + j] = left[j];\n                var store = temp[1];\n                for (int j = 2; j < 14; ++j) temp[j - 1] = temp[j];\n                temp[13] = store;\n                temp.CopyTo(left, 0);\n\n                \n\n                for (int j = index; j < 26; ++j) temp[j - index] = right[j];\n                for (int j = 0; j < index; ++j) temp[26 - index + j] = right[j];\n                store = temp[0];\n                for (int j = 1; j < 26; ++j) temp[j - 1] = temp[j];\n                temp[25] = store;\n                store = temp[2];\n                for (int j = 3; j < 14; ++j) temp[j - 1] = temp[j];\n                temp[13] = store;\n                temp.CopyTo(right, 0);\n            }\n\n            return new string(eText);\n        }\n\n        static void Main(string[] args) {\n            var plainText = \"WELLDONEISBETTERTHANWELLSAID\";\n            Console.WriteLine(\"The original plaintext is\u00a0: {0}\", plainText);\n            Console.WriteLine(\"\\nThe left and right alphabets after each permutation during encryption are\u00a0:\\n\");\n            var cipherText = Exec(plainText, Mode.ENCRYPT, true);\n            Console.WriteLine(\"\\nThe ciphertext is\u00a0: {0}\", cipherText);\n            var plainText2 = Exec(cipherText, Mode.DECRYPT);\n            Console.WriteLine(\"\\nThe recovered plaintext is\u00a0: {0}\", plainText2);\n        }\n    }\n}\n"}
{"id": 144178, "name": "Chaocipher", "source": "Translate Ruby to C#: txt    = \"WELLDONEISBETTERTHANWELLSAID\"\n@left  = \"HXUCZVAMDSLKPEFJRIGTWOBNYQ\".chars\n@right = \"PTLNBQDEOYSFAVZKGJRIHWXUMC\".chars\n\ndef encrypt(char)\n  coded_char = @left[@right.index(char)]\n\n  @left.rotate!(@left.index(coded_char))\n  part = @left.slice!(1,13).rotate\n  @left.insert(1, *part)\n\n  @right.rotate!(@right.index(char)+1)\n  part = @right.slice!(2,12).rotate\n  @right.insert(2, *part)\n  \n  @left[0]\nend\n\nputs txt.each_char.map{|c| encrypt(c) }.join\n", "target": "using System;\n\nnamespace Chaocipher {\n    enum Mode {\n        ENCRYPT,\n        DECRYPT,\n    }\n\n    class Program {\n        const string L_ALPHABET = \"HXUCZVAMDSLKPEFJRIGTWOBNYQ\";\n        const string R_ALPHABET = \"PTLNBQDEOYSFAVZKGJRIHWXUMC\";\n\n        static string Exec(string text, Mode mode, bool showSteps = false) {\n            char[] left = L_ALPHABET.ToCharArray();\n            char[] right = R_ALPHABET.ToCharArray();\n            char[] eText = new char[text.Length];\n            char[] temp = new char[26];\n\n            for (int i = 0; i < text.Length; ++i) {\n                if (showSteps) Console.WriteLine(\"{0} {1}\", string.Join(\"\", left), string.Join(\"\", right));\n                int index = 0;\n                if (mode == Mode.ENCRYPT) {\n                    index = Array.IndexOf(right, text[i]);\n                    eText[i] = left[index];\n                } else {\n                    index = Array.IndexOf(left, text[i]);\n                    eText[i] = right[index];\n                }\n                if (i == text.Length - 1) break;\n\n                \n\n                for (int j = index; j < 26; ++j) temp[j - index] = left[j];\n                for (int j = 0; j < index; ++j) temp[26 - index + j] = left[j];\n                var store = temp[1];\n                for (int j = 2; j < 14; ++j) temp[j - 1] = temp[j];\n                temp[13] = store;\n                temp.CopyTo(left, 0);\n\n                \n\n                for (int j = index; j < 26; ++j) temp[j - index] = right[j];\n                for (int j = 0; j < index; ++j) temp[26 - index + j] = right[j];\n                store = temp[0];\n                for (int j = 1; j < 26; ++j) temp[j - 1] = temp[j];\n                temp[25] = store;\n                store = temp[2];\n                for (int j = 3; j < 14; ++j) temp[j - 1] = temp[j];\n                temp[13] = store;\n                temp.CopyTo(right, 0);\n            }\n\n            return new string(eText);\n        }\n\n        static void Main(string[] args) {\n            var plainText = \"WELLDONEISBETTERTHANWELLSAID\";\n            Console.WriteLine(\"The original plaintext is\u00a0: {0}\", plainText);\n            Console.WriteLine(\"\\nThe left and right alphabets after each permutation during encryption are\u00a0:\\n\");\n            var cipherText = Exec(plainText, Mode.ENCRYPT, true);\n            Console.WriteLine(\"\\nThe ciphertext is\u00a0: {0}\", cipherText);\n            var plainText2 = Exec(cipherText, Mode.DECRYPT);\n            Console.WriteLine(\"\\nThe recovered plaintext is\u00a0: {0}\", plainText2);\n        }\n    }\n}\n"}
{"id": 144181, "name": "Chaocipher", "source": "Translate Ruby to Java: txt    = \"WELLDONEISBETTERTHANWELLSAID\"\n@left  = \"HXUCZVAMDSLKPEFJRIGTWOBNYQ\".chars\n@right = \"PTLNBQDEOYSFAVZKGJRIHWXUMC\".chars\n\ndef encrypt(char)\n  coded_char = @left[@right.index(char)]\n\n  @left.rotate!(@left.index(coded_char))\n  part = @left.slice!(1,13).rotate\n  @left.insert(1, *part)\n\n  @right.rotate!(@right.index(char)+1)\n  part = @right.slice!(2,12).rotate\n  @right.insert(2, *part)\n  \n  @left[0]\nend\n\nputs txt.each_char.map{|c| encrypt(c) }.join\n", "target": "import java.util.Arrays;\n\npublic class Chaocipher {\n    private enum Mode {\n        ENCRYPT,\n        DECRYPT\n    }\n\n    private static final String L_ALPHABET = \"HXUCZVAMDSLKPEFJRIGTWOBNYQ\";\n    private static final String R_ALPHABET = \"PTLNBQDEOYSFAVZKGJRIHWXUMC\";\n\n    private static int indexOf(char[] a, char c) {\n        for (int i = 0; i < a.length; ++i) {\n            if (a[i] == c) {\n                return i;\n            }\n        }\n        return -1;\n    }\n\n    private static String exec(String text, Mode mode) {\n        return exec(text, mode, false);\n    }\n\n    private static String exec(String text, Mode mode, Boolean showSteps) {\n        char[] left = L_ALPHABET.toCharArray();\n        char[] right = R_ALPHABET.toCharArray();\n        char[] eText = new char[text.length()];\n        char[] temp = new char[26];\n\n        for (int i = 0; i < text.length(); ++i) {\n            if (showSteps) {\n                System.out.printf(\"%s  %s\\n\", new String(left), new String(right));\n            }\n            int index;\n            if (mode == Mode.ENCRYPT) {\n                index = indexOf(right, text.charAt(i));\n                eText[i] = left[index];\n            } else {\n                index = indexOf(left, text.charAt(i));\n                eText[i] = right[index];\n            }\n            if (i == text.length() - 1) {\n                break;\n            }\n\n            \n\n            if (26 - index >= 0) System.arraycopy(left, index, temp, 0, 26 - index);\n            System.arraycopy(left, 0, temp, 26 - index, index);\n            char store = temp[1];\n            System.arraycopy(temp, 2, temp, 1, 12);\n            temp[13] = store;\n            left = Arrays.copyOf(temp, temp.length);\n\n            \n\n            if (26 - index >= 0) System.arraycopy(right, index, temp, 0, 26 - index);\n            System.arraycopy(right, 0, temp, 26 - index, index);\n            store = temp[0];\n            System.arraycopy(temp, 1, temp, 0, 25);\n            temp[25] = store;\n            store = temp[2];\n            System.arraycopy(temp, 3, temp, 2, 11);\n            temp[13] = store;\n            right = Arrays.copyOf(temp, temp.length);\n        }\n\n        return new String(eText);\n    }\n\n    public static void main(String[] args) {\n        String plainText = \"WELLDONEISBETTERTHANWELLSAID\";\n        System.out.printf(\"The original plaintext is\u00a0: %s\\n\", plainText);\n        System.out.println(\"\\nThe left and right alphabets after each permutation during encryption are:\");\n        String cipherText = exec(plainText, Mode.ENCRYPT, true);\n        System.out.printf(\"\\nThe cipher text is\u00a0: %s\\n\", cipherText);\n        String plainText2 = exec(cipherText, Mode.DECRYPT);\n        System.out.printf(\"\\nThe recovered plaintext is\u00a0: %s\\n\", plainText2);\n    }\n}\n"}
{"id": 144182, "name": "Chaocipher", "source": "Translate Ruby to Java: txt    = \"WELLDONEISBETTERTHANWELLSAID\"\n@left  = \"HXUCZVAMDSLKPEFJRIGTWOBNYQ\".chars\n@right = \"PTLNBQDEOYSFAVZKGJRIHWXUMC\".chars\n\ndef encrypt(char)\n  coded_char = @left[@right.index(char)]\n\n  @left.rotate!(@left.index(coded_char))\n  part = @left.slice!(1,13).rotate\n  @left.insert(1, *part)\n\n  @right.rotate!(@right.index(char)+1)\n  part = @right.slice!(2,12).rotate\n  @right.insert(2, *part)\n  \n  @left[0]\nend\n\nputs txt.each_char.map{|c| encrypt(c) }.join\n", "target": "import java.util.Arrays;\n\npublic class Chaocipher {\n    private enum Mode {\n        ENCRYPT,\n        DECRYPT\n    }\n\n    private static final String L_ALPHABET = \"HXUCZVAMDSLKPEFJRIGTWOBNYQ\";\n    private static final String R_ALPHABET = \"PTLNBQDEOYSFAVZKGJRIHWXUMC\";\n\n    private static int indexOf(char[] a, char c) {\n        for (int i = 0; i < a.length; ++i) {\n            if (a[i] == c) {\n                return i;\n            }\n        }\n        return -1;\n    }\n\n    private static String exec(String text, Mode mode) {\n        return exec(text, mode, false);\n    }\n\n    private static String exec(String text, Mode mode, Boolean showSteps) {\n        char[] left = L_ALPHABET.toCharArray();\n        char[] right = R_ALPHABET.toCharArray();\n        char[] eText = new char[text.length()];\n        char[] temp = new char[26];\n\n        for (int i = 0; i < text.length(); ++i) {\n            if (showSteps) {\n                System.out.printf(\"%s  %s\\n\", new String(left), new String(right));\n            }\n            int index;\n            if (mode == Mode.ENCRYPT) {\n                index = indexOf(right, text.charAt(i));\n                eText[i] = left[index];\n            } else {\n                index = indexOf(left, text.charAt(i));\n                eText[i] = right[index];\n            }\n            if (i == text.length() - 1) {\n                break;\n            }\n\n            \n\n            if (26 - index >= 0) System.arraycopy(left, index, temp, 0, 26 - index);\n            System.arraycopy(left, 0, temp, 26 - index, index);\n            char store = temp[1];\n            System.arraycopy(temp, 2, temp, 1, 12);\n            temp[13] = store;\n            left = Arrays.copyOf(temp, temp.length);\n\n            \n\n            if (26 - index >= 0) System.arraycopy(right, index, temp, 0, 26 - index);\n            System.arraycopy(right, 0, temp, 26 - index, index);\n            store = temp[0];\n            System.arraycopy(temp, 1, temp, 0, 25);\n            temp[25] = store;\n            store = temp[2];\n            System.arraycopy(temp, 3, temp, 2, 11);\n            temp[13] = store;\n            right = Arrays.copyOf(temp, temp.length);\n        }\n\n        return new String(eText);\n    }\n\n    public static void main(String[] args) {\n        String plainText = \"WELLDONEISBETTERTHANWELLSAID\";\n        System.out.printf(\"The original plaintext is\u00a0: %s\\n\", plainText);\n        System.out.println(\"\\nThe left and right alphabets after each permutation during encryption are:\");\n        String cipherText = exec(plainText, Mode.ENCRYPT, true);\n        System.out.printf(\"\\nThe cipher text is\u00a0: %s\\n\", cipherText);\n        String plainText2 = exec(cipherText, Mode.DECRYPT);\n        System.out.printf(\"\\nThe recovered plaintext is\u00a0: %s\\n\", plainText2);\n    }\n}\n"}
{"id": 144183, "name": "Chaocipher", "source": "Translate Ruby to Python: txt    = \"WELLDONEISBETTERTHANWELLSAID\"\n@left  = \"HXUCZVAMDSLKPEFJRIGTWOBNYQ\".chars\n@right = \"PTLNBQDEOYSFAVZKGJRIHWXUMC\".chars\n\ndef encrypt(char)\n  coded_char = @left[@right.index(char)]\n\n  @left.rotate!(@left.index(coded_char))\n  part = @left.slice!(1,13).rotate\n  @left.insert(1, *part)\n\n  @right.rotate!(@right.index(char)+1)\n  part = @right.slice!(2,12).rotate\n  @right.insert(2, *part)\n  \n  @left[0]\nend\n\nputs txt.each_char.map{|c| encrypt(c) }.join\n", "target": "\n\n\n\ndef main():\n    \n    lalpha = \"HXUCZVAMDSLKPEFJRIGTWOBNYQ\"\n    ralpha = \"PTLNBQDEOYSFAVZKGJRIHWXUMC\"\n    msg = \"WELLDONEISBETTERTHANWELLSAID\"\n\n    print(\"L:\", lalpha)\n    print(\"R:\", ralpha)\n    print(\"I:\", msg)\n    print(\"O:\", do_chao(msg, lalpha, ralpha, 1, 0), \"\\n\")\n    \n    do_chao(msg, lalpha, ralpha, 1, 1)\n\ndef do_chao(msg, lalpha, ralpha, en=1, show=0):\n    msg = correct_case(msg)\n    out = \"\"    \n    if show:\n        print(\"=\"*54)        \n        print(10*\" \" + \"left:\" + 21*\" \" + \"right: \")\n        print(\"=\"*54)        \n        print(lalpha, ralpha, \"\\n\")\n    for L in msg:\n        if en:\n            lalpha, ralpha = rotate_wheels(lalpha, ralpha, L)\n            out += lalpha[0]\n        else:\n            ralpha, lalpha = rotate_wheels(ralpha, lalpha, L)\n            out += ralpha[0]\n        lalpha, ralpha = scramble_wheels(lalpha, ralpha)\n        if show:\n            print(lalpha, ralpha)            \n    return out\n    \ndef makealpha(key=\"\"):\n    alpha = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n    z = set()\n    key = [x.upper() for x in (key + alpha[::-1])\n           if not (x.upper() in z or z.add(x.upper()))]\n    return \"\".join(key)\n\ndef correct_case(string):\n    return \"\".join([s.upper() for s in string if s.isalpha()])\n\ndef permu(alp, num):\n    alp = alp[:num], alp[num:]\n    return \"\".join(alp[::-1])\n\ndef rotate_wheels(lalph, ralph, key):\n    newin = ralph.index(key)\n    return permu(lalph, newin), permu(ralph, newin)    \n\ndef scramble_wheels(lalph, ralph):\n    \n    \n    lalph = list(lalph)\n    lalph = \"\".join([*lalph[0],\n                    *lalph[2:14],\n                    lalph[1],\n                    *lalph[14:]])\n    \n    \n    \n    \n    ralph = list(ralph)\n    ralph = \"\".join([*ralph[1:3],\n                     *ralph[4:15],\n                     ralph[3],\n                     *ralph[15:],\n                     ralph[0]])\n    return lalph, ralph\n\nmain()\n"}
{"id": 144184, "name": "Chaocipher", "source": "Translate Ruby to Python: txt    = \"WELLDONEISBETTERTHANWELLSAID\"\n@left  = \"HXUCZVAMDSLKPEFJRIGTWOBNYQ\".chars\n@right = \"PTLNBQDEOYSFAVZKGJRIHWXUMC\".chars\n\ndef encrypt(char)\n  coded_char = @left[@right.index(char)]\n\n  @left.rotate!(@left.index(coded_char))\n  part = @left.slice!(1,13).rotate\n  @left.insert(1, *part)\n\n  @right.rotate!(@right.index(char)+1)\n  part = @right.slice!(2,12).rotate\n  @right.insert(2, *part)\n  \n  @left[0]\nend\n\nputs txt.each_char.map{|c| encrypt(c) }.join\n", "target": "\n\n\n\ndef main():\n    \n    lalpha = \"HXUCZVAMDSLKPEFJRIGTWOBNYQ\"\n    ralpha = \"PTLNBQDEOYSFAVZKGJRIHWXUMC\"\n    msg = \"WELLDONEISBETTERTHANWELLSAID\"\n\n    print(\"L:\", lalpha)\n    print(\"R:\", ralpha)\n    print(\"I:\", msg)\n    print(\"O:\", do_chao(msg, lalpha, ralpha, 1, 0), \"\\n\")\n    \n    do_chao(msg, lalpha, ralpha, 1, 1)\n\ndef do_chao(msg, lalpha, ralpha, en=1, show=0):\n    msg = correct_case(msg)\n    out = \"\"    \n    if show:\n        print(\"=\"*54)        \n        print(10*\" \" + \"left:\" + 21*\" \" + \"right: \")\n        print(\"=\"*54)        \n        print(lalpha, ralpha, \"\\n\")\n    for L in msg:\n        if en:\n            lalpha, ralpha = rotate_wheels(lalpha, ralpha, L)\n            out += lalpha[0]\n        else:\n            ralpha, lalpha = rotate_wheels(ralpha, lalpha, L)\n            out += ralpha[0]\n        lalpha, ralpha = scramble_wheels(lalpha, ralpha)\n        if show:\n            print(lalpha, ralpha)            \n    return out\n    \ndef makealpha(key=\"\"):\n    alpha = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n    z = set()\n    key = [x.upper() for x in (key + alpha[::-1])\n           if not (x.upper() in z or z.add(x.upper()))]\n    return \"\".join(key)\n\ndef correct_case(string):\n    return \"\".join([s.upper() for s in string if s.isalpha()])\n\ndef permu(alp, num):\n    alp = alp[:num], alp[num:]\n    return \"\".join(alp[::-1])\n\ndef rotate_wheels(lalph, ralph, key):\n    newin = ralph.index(key)\n    return permu(lalph, newin), permu(ralph, newin)    \n\ndef scramble_wheels(lalph, ralph):\n    \n    \n    lalph = list(lalph)\n    lalph = \"\".join([*lalph[0],\n                    *lalph[2:14],\n                    lalph[1],\n                    *lalph[14:]])\n    \n    \n    \n    \n    ralph = list(ralph)\n    ralph = \"\".join([*ralph[1:3],\n                     *ralph[4:15],\n                     ralph[3],\n                     *ralph[15:],\n                     ralph[0]])\n    return lalph, ralph\n\nmain()\n"}
{"id": 144304, "name": "Terminal control_Clear the screen", "source": "Translate Ruby to Java: system 'clear'\n", "target": "public class Clear\n{\n    public static void main (String[] args)\n    {\n        System.out.print(\"\\033[2J\");\n    }\n}\n"}
{"id": 144508, "name": "Arbitrary-precision integers (included)", "source": "Translate Ruby to C#: y = ( 5**4**3**2 ).to_s\nputs \"5**4**3**2 = \n", "target": "using System;\nusing System.Diagnostics;\nusing System.Linq;\nusing System.Numerics;\n\nstatic class Program {\n    static void Main() {\n        BigInteger n = BigInteger.Pow(5, (int)BigInteger.Pow(4, (int)BigInteger.Pow(3, 2)));\n        string result = n.ToString();\n\n        Debug.Assert(result.Length == 183231);\n        Debug.Assert(result.StartsWith(\"62060698786608744707\"));\n        Debug.Assert(result.EndsWith(\"92256259918212890625\"));\n\n        Console.WriteLine(\"n = 5^4^3^2\");\n        Console.WriteLine(\"n = {0}...{1}\", \n            result.Substring(0, 20),\n            result.Substring(result.Length - 20, 20)\n            );\n\n        Console.WriteLine(\"n digits = {0}\", result.Length);\n    }\n}\n"}
{"id": 144510, "name": "Arbitrary-precision integers (included)", "source": "Translate Ruby to Java: y = ( 5**4**3**2 ).to_s\nputs \"5**4**3**2 = \n", "target": "import java.math.BigInteger;\n\nclass IntegerPower {\n    public static void main(String[] args) {\n        BigInteger power = BigInteger.valueOf(5).pow(BigInteger.valueOf(4).pow(BigInteger.valueOf(3).pow(2).intValueExact()).intValueExact());\n        String str = power.toString();\n        int len = str.length();\n        System.out.printf(\"5**4**3**2 = %s...%s and has %d digits%n\",\n                str.substring(0, 20), str.substring(len - 20), len);\n    }\n}\n"}
{"id": 144511, "name": "Arbitrary-precision integers (included)", "source": "Translate Ruby to Python: y = ( 5**4**3**2 ).to_s\nputs \"5**4**3**2 = \n", "target": ">>> y = str( 5**4**3**2 )\n>>> print (\"5**4**3**2 = %s...%s and has %i digits\" % (y[:20], y[-20:], len(y)))\n5**4**3**2 = 62060698786608744707...92256259918212890625 and has 183231 digits\n"}
{"id": 144659, "name": "Hilbert curve", "source": "Translate Ruby to C#: \n\nload_library :grammar\nattr_reader :hilbert\ndef settings\n  size 600, 600\nend\n\ndef setup\n  sketch_title '2D Hilbert'\n  @hilbert = Hilbert.new\n  hilbert.create_grammar 5\n  no_loop\nend\n\ndef draw\n  background 0\n  hilbert.render\nend\n\nTurtle = Struct.new(:x, :y, :theta)\n\n\nclass Hilbert\n  include Processing::Proxy\n\n  attr_reader :grammar, :axiom, :draw_length, :production, :turtle\n  DELTA = 90.radians\n  def initialize\n    @axiom = 'FL'\n    @grammar = Grammar.new(\n      axiom,\n      'L' => '+RF-LFL-FR+',\n      'R' => '-LF+RFR+FL-'\n    )\n    @draw_length = 200\n    stroke 0, 255, 0\n    stroke_weight 2\n    @turtle = Turtle.new(width / 9, height / 9, 0)\n  end\n\n  def render\n    production.scan(/./) do |element|\n      case element\n      when 'F' \n        draw_line(turtle)\n      when '+'\n        turtle.theta += DELTA\n      when '-'\n        turtle.theta -= DELTA\n      when 'L'\n      when 'R'\n      else puts 'Grammar not recognized'\n      end\n    end\n  end\n\n  def draw_line(turtle)\n    x_temp = turtle.x\n    y_temp = turtle.y\n    turtle.x += draw_length * Math.cos(turtle.theta)\n    turtle.y += draw_length * Math.sin(turtle.theta)\n    line(x_temp, y_temp, turtle.x, turtle.y)\n  end\n\n  \n  \n  \n  \n\n  def create_grammar(gen)\n    @draw_length *= 0.6**gen\n    @production = @grammar.generate gen\n  end\nend\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\nusing System.Text;\n\nnamespace HilbertCurve {\n    class Program {\n        static void Swap<T>(ref T a, ref T b) {\n            var c = a;\n            a = b;\n            b = c;\n        }\n\n        struct Point {\n            public int x, y;\n\n            public Point(int x, int y) {\n                this.x = x;\n                this.y = y;\n            }\n\n            \n            public void Rot(int n, bool rx, bool ry) {\n                if (!ry) {\n                    if (rx) {\n                        x = (n - 1) - x;\n                        y = (n - 1) - y;\n                    }\n                    Swap(ref x, ref y);\n                }\n            }\n\n            public override string ToString() {\n                return string.Format(\"({0}, {1})\", x, y);\n            }\n        }\n\n        static Point FromD(int n, int d) {\n            var p = new Point(0, 0);\n            int t = d;\n\n            for (int s = 1; s < n; s <<= 1) {\n                var rx = (t & 2) != 0;\n                var ry = ((t ^ (rx ? 1 : 0)) & 1) != 0;\n                p.Rot(s, rx, ry);\n                p.x += rx ? s : 0;\n                p.y += ry ? s : 0;\n                t >>= 2;\n            }\n\n            return p;\n        }\n\n        static List<Point> GetPointsForCurve(int n) {\n            var points = new List<Point>();\n            int d = 0;\n            while (d < n * n) {\n                points.Add(FromD(n, d));\n                d += 1;\n            }\n            return points;\n        }\n\n        static List<string> DrawCurve(List<Point> points, int n) {\n            var canvas = new char[n, n * 3 - 2];\n            for (int i = 0; i < canvas.GetLength(0); i++) {\n                for (int j = 0; j < canvas.GetLength(1); j++) {\n                    canvas[i, j] = ' ';\n                }\n            }\n\n            for (int i = 1; i < points.Count; i++) {\n                var lastPoint = points[i - 1];\n                var curPoint = points[i];\n                var deltaX = curPoint.x - lastPoint.x;\n                var deltaY = curPoint.y - lastPoint.y;\n                if (deltaX == 0) {\n                    Debug.Assert(deltaY != 0, \"Duplicate point\");\n                    \n                    int row = Math.Max(curPoint.y, lastPoint.y);\n                    int col = curPoint.x * 3;\n                    canvas[row, col] = '|';\n                } else {\n                    Debug.Assert(deltaY == 0, \"Duplicate point\");\n                    \n                    var row = curPoint.y;\n                    var col = Math.Min(curPoint.x, lastPoint.x) * 3 + 1;\n                    canvas[row, col] = '_';\n                    canvas[row, col + 1] = '_';\n                }\n            }\n\n            var lines = new List<string>();\n            for (int i = 0; i < canvas.GetLength(0); i++) {\n                var sb = new StringBuilder();\n                for (int j = 0; j < canvas.GetLength(1); j++) {\n                    sb.Append(canvas[i, j]);\n                }\n                lines.Add(sb.ToString());\n            }\n            return lines;\n        }\n\n        static void Main() {\n            for (int order = 1; order <= 5; order++) {\n                var n = 1 << order;\n                var points = GetPointsForCurve(n);\n                Console.WriteLine(\"Hilbert curve, order={0}\", order);\n                var lines = DrawCurve(points, n);\n                foreach (var line in lines) {\n                    Console.WriteLine(line);\n                }\n                Console.WriteLine();\n            }\n        }\n    }\n}\n"}
{"id": 144661, "name": "Hilbert curve", "source": "Translate Ruby to Java: \n\nload_library :grammar\nattr_reader :hilbert\ndef settings\n  size 600, 600\nend\n\ndef setup\n  sketch_title '2D Hilbert'\n  @hilbert = Hilbert.new\n  hilbert.create_grammar 5\n  no_loop\nend\n\ndef draw\n  background 0\n  hilbert.render\nend\n\nTurtle = Struct.new(:x, :y, :theta)\n\n\nclass Hilbert\n  include Processing::Proxy\n\n  attr_reader :grammar, :axiom, :draw_length, :production, :turtle\n  DELTA = 90.radians\n  def initialize\n    @axiom = 'FL'\n    @grammar = Grammar.new(\n      axiom,\n      'L' => '+RF-LFL-FR+',\n      'R' => '-LF+RFR+FL-'\n    )\n    @draw_length = 200\n    stroke 0, 255, 0\n    stroke_weight 2\n    @turtle = Turtle.new(width / 9, height / 9, 0)\n  end\n\n  def render\n    production.scan(/./) do |element|\n      case element\n      when 'F' \n        draw_line(turtle)\n      when '+'\n        turtle.theta += DELTA\n      when '-'\n        turtle.theta -= DELTA\n      when 'L'\n      when 'R'\n      else puts 'Grammar not recognized'\n      end\n    end\n  end\n\n  def draw_line(turtle)\n    x_temp = turtle.x\n    y_temp = turtle.y\n    turtle.x += draw_length * Math.cos(turtle.theta)\n    turtle.y += draw_length * Math.sin(turtle.theta)\n    line(x_temp, y_temp, turtle.x, turtle.y)\n  end\n\n  \n  \n  \n  \n\n  def create_grammar(gen)\n    @draw_length *= 0.6**gen\n    @production = @grammar.generate gen\n  end\nend\n", "target": "\n\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\n\npublic class HilbertCurve {\n    public static class Point {\n        public int x;\n        public int y;\n        \n        public Point(int x, int y) {\n            this.x = x;\n            this.y = y;\n        }\n        \n        public String toString() {\n            return \"(\" + x + \", \" + y + \")\";\n        }\n        \n        \n        public void rot(int n, boolean rx, boolean ry) {\n            if (!ry) {\n                if (rx) {\n                    x = (n - 1) - x;\n                    y = (n - 1) - y;\n                }\n        \n                \n                int t  = x;\n                x = y;\n                y = t;\n            }\n            \n            return;\n        }\n        \n        public int calcD(int n) {\n            boolean rx, ry;\n            int d = 0;\n            for (int s = n >>> 1; s > 0; s >>>= 1) {\n                rx = ((x & s) != 0);\n                ry = ((y & s) != 0);\n                d += s * s * ((rx ? 3 : 0) ^ (ry ? 1 : 0));\n                rot(s, rx, ry);\n            }\n            \n            return d;\n        }\n        \n    }\n\n    public static Point fromD(int n, int d) {\n        Point p = new Point(0, 0);\n        boolean rx, ry;\n        int t = d;\n        for (int s = 1; s < n; s <<= 1) {\n            rx = ((t & 2) != 0);\n            ry = (((t ^ (rx ? 1 : 0)) & 1) != 0);\n            p.rot(s, rx, ry);\n            p.x += (rx ? s : 0);\n            p.y += (ry ? s : 0);\n            t >>>= 2;\n        }\n        return p;\n    }\n    \n    public static List<Point> getPointsForCurve(int n) {\n        List<Point> points = new ArrayList<Point>();\n        for (int d = 0; d < (n * n); d++) {\n            Point p = fromD(n, d);\n            points.add(p);\n        }\n        \n        return points;\n    }\n    \n    public static List<String> drawCurve(List<Point> points, int n) {\n        char[][] canvas = new char[n][n * 3 - 2];\n        for (char[] line : canvas) {\n            Arrays.fill(line, ' ');\n        }\n        for (int i = 1; i < points.size(); i++) {\n             Point lastPoint = points.get(i - 1);\n            Point curPoint = points.get(i);\n            int deltaX = curPoint.x - lastPoint.x;\n            int deltaY = curPoint.y - lastPoint.y;\n            if (deltaX == 0) {\n                if (deltaY == 0) {\n                    \n                    throw new IllegalStateException(\"Duplicate point, deltaX=\" + deltaX + \", deltaY=\" + deltaY);\n                }\n                \n                int row = Math.max(curPoint.y, lastPoint.y);\n                int col = curPoint.x * 3;\n                canvas[row][col] = '|';\n            }\n            else {\n                if (deltaY != 0) {\n                    \n                    throw new IllegalStateException(\"Diagonal line, deltaX=\" + deltaX + \", deltaY=\" + deltaY);\n                }\n                \n                int row = curPoint.y;\n                int col = Math.min(curPoint.x, lastPoint.x) * 3 + 1;\n                canvas[row][col] = '_';\n                canvas[row][col + 1] = '_';\n            }\n            \n        }\n        List<String> lines = new ArrayList<String>();\n        for (char[] row : canvas) {\n            String line = new String(row);\n            lines.add(line);\n        }\n        \n        return lines;\n    }\n    \n    public static void main(String... args) {\n        for (int order = 1; order <= 5; order++) {\n            int n = (1 << order);\n            List<Point> points = getPointsForCurve(n);\n            System.out.println(\"Hilbert curve, order=\" + order);\n            List<String> lines = drawCurve(points, n);\n            for (String line : lines) {\n                System.out.println(line);\n            }\n            System.out.println();\n        }\n        return;\n    }\n}\n"}
{"id": 144662, "name": "Hilbert curve", "source": "Translate Ruby to Python: \n\nload_library :grammar\nattr_reader :hilbert\ndef settings\n  size 600, 600\nend\n\ndef setup\n  sketch_title '2D Hilbert'\n  @hilbert = Hilbert.new\n  hilbert.create_grammar 5\n  no_loop\nend\n\ndef draw\n  background 0\n  hilbert.render\nend\n\nTurtle = Struct.new(:x, :y, :theta)\n\n\nclass Hilbert\n  include Processing::Proxy\n\n  attr_reader :grammar, :axiom, :draw_length, :production, :turtle\n  DELTA = 90.radians\n  def initialize\n    @axiom = 'FL'\n    @grammar = Grammar.new(\n      axiom,\n      'L' => '+RF-LFL-FR+',\n      'R' => '-LF+RFR+FL-'\n    )\n    @draw_length = 200\n    stroke 0, 255, 0\n    stroke_weight 2\n    @turtle = Turtle.new(width / 9, height / 9, 0)\n  end\n\n  def render\n    production.scan(/./) do |element|\n      case element\n      when 'F' \n        draw_line(turtle)\n      when '+'\n        turtle.theta += DELTA\n      when '-'\n        turtle.theta -= DELTA\n      when 'L'\n      when 'R'\n      else puts 'Grammar not recognized'\n      end\n    end\n  end\n\n  def draw_line(turtle)\n    x_temp = turtle.x\n    y_temp = turtle.y\n    turtle.x += draw_length * Math.cos(turtle.theta)\n    turtle.y += draw_length * Math.sin(turtle.theta)\n    line(x_temp, y_temp, turtle.x, turtle.y)\n  end\n\n  \n  \n  \n  \n\n  def create_grammar(gen)\n    @draw_length *= 0.6**gen\n    @production = @grammar.generate gen\n  end\nend\n", "target": "iterations = 7\nstroke_len = 600\nangle_deg = 90\naxiom = 'L'\nsentence = axiom\nrules = {\n    'L': '+RF-LFL-FR+',\n    'R': '-LF+RFR+FL-',\n}\n\ndef setup():\n    size(700, 700)\n    global xo, yo\n    xo, yo = 50, height - 50\n    strokeWeight(1)\n    noFill()\n    generate(iterations)\n\ndef draw():\n    background(0)\n    translate(xo, yo)\n    plot(radians(angle_deg))\n\ndef generate(n):\n    global stroke_len, sentence\n    for _ in range(n):\n        stroke_len *= 0.5\n        next_sentence = ''\n        for c in sentence:\n            next_sentence += rules.get(c, c)\n        sentence = next_sentence\n\ndef plot(angle):\n    for c in sentence:\n        if c == 'F':\n            stroke(255)\n            line(0, 0, 0, -stroke_len)\n            translate(0, -stroke_len)\n        elif c == '+':\n            rotate(angle)\n        elif c == '-':\n            rotate(-angle)\n\ndef keyPressed():\n    global angle_deg, xo, yo, stroke_len\n    if key == '-':\n        angle_deg -= 5\n        print(angle_deg)\n    if str(key) in \"=+\":\n        angle_deg += 5\n        print(angle_deg)\n    if key == 'a':\n        stroke_len *= 2\n    if key == 'z':\n        stroke_len /= 2\n    if keyCode == LEFT:\n        xo -= 50\n    if keyCode == RIGHT:\n        xo += 50\n    if keyCode == UP:\n        yo -= 50\n    if keyCode == DOWN:\n        yo += 50\n"}
{"id": 145002, "name": "Show ASCII table", "source": "Translate Ruby to C#: chars = (32..127).map do |ord|\n  k = case ord\n    when 32  then \"\u2420\"\n    when 127 then \"\u2421\"\n    else ord.chr \n  end\n  \"\nend\n \nchars.each_slice(chars.size/6).to_a.transpose.each{|s| puts s.join(\"  \")}\n", "target": "using static System.Console;\nusing static System.Linq.Enumerable;\n\npublic class Program\n{\n    static void Main()\n    {\n        for (int start = 32; start + 16 * 5 < 128; start++) {\n            WriteLine(string.Concat(Range(0, 6).Select(i => $\"{start+16*i, 3}\u00a0: {Text(start+16*i), -6}\")));\n        }\n\n        string Text(int index) => index == 32 ? \"Sp\" : index == 127 ? \"Del\" : (char)index + \"\";\n    }\n}\n"}
{"id": 145003, "name": "Show ASCII table", "source": "Translate Ruby to C#: chars = (32..127).map do |ord|\n  k = case ord\n    when 32  then \"\u2420\"\n    when 127 then \"\u2421\"\n    else ord.chr \n  end\n  \"\nend\n \nchars.each_slice(chars.size/6).to_a.transpose.each{|s| puts s.join(\"  \")}\n", "target": "using static System.Console;\nusing static System.Linq.Enumerable;\n\npublic class Program\n{\n    static void Main()\n    {\n        for (int start = 32; start + 16 * 5 < 128; start++) {\n            WriteLine(string.Concat(Range(0, 6).Select(i => $\"{start+16*i, 3}\u00a0: {Text(start+16*i), -6}\")));\n        }\n\n        string Text(int index) => index == 32 ? \"Sp\" : index == 127 ? \"Del\" : (char)index + \"\";\n    }\n}\n"}
{"id": 145006, "name": "Show ASCII table", "source": "Translate Ruby to Java: chars = (32..127).map do |ord|\n  k = case ord\n    when 32  then \"\u2420\"\n    when 127 then \"\u2421\"\n    else ord.chr \n  end\n  \"\nend\n \nchars.each_slice(chars.size/6).to_a.transpose.each{|s| puts s.join(\"  \")}\n", "target": "module test\n    {\n    @Inject Console console;\n    void run()\n        {\n        for (Int offset : 0..<16)\n            {\n            for (Int ascii = 32+offset; ascii < 128; ascii += 16)\n                {\n                console.print($|{ascii.toString().rightJustify(3)}/\\\n                               |{ascii.toByte().toByteArray()}: \\\n                               |{new Char(ascii).quoted().leftJustify(5)}\n                              , suppressNewline=True);\n                }\n            console.print();\n            }\n        }\n    }\n"}
{"id": 145007, "name": "Show ASCII table", "source": "Translate Ruby to Java: chars = (32..127).map do |ord|\n  k = case ord\n    when 32  then \"\u2420\"\n    when 127 then \"\u2421\"\n    else ord.chr \n  end\n  \"\nend\n \nchars.each_slice(chars.size/6).to_a.transpose.each{|s| puts s.join(\"  \")}\n", "target": "module test\n    {\n    @Inject Console console;\n    void run()\n        {\n        for (Int offset : 0..<16)\n            {\n            for (Int ascii = 32+offset; ascii < 128; ascii += 16)\n                {\n                console.print($|{ascii.toString().rightJustify(3)}/\\\n                               |{ascii.toByte().toByteArray()}: \\\n                               |{new Char(ascii).quoted().leftJustify(5)}\n                              , suppressNewline=True);\n                }\n            console.print();\n            }\n        }\n    }\n"}
{"id": 145008, "name": "Show ASCII table", "source": "Translate Ruby to Python: chars = (32..127).map do |ord|\n  k = case ord\n    when 32  then \"\u2420\"\n    when 127 then \"\u2421\"\n    else ord.chr \n  end\n  \"\nend\n \nchars.each_slice(chars.size/6).to_a.transpose.each{|s| puts s.join(\"  \")}\n", "target": "for i in range(16):\n    for j in range(32+i, 127+1, 16):\n        if j == 32:\n            k = 'Spc'\n        elif j == 127:\n            k = 'Del'\n        else:\n            k = chr(j)\n        print(\"%3d\u00a0: %-3s\" % (j,k), end=\"\")\n    print()\n"}
{"id": 145009, "name": "Show ASCII table", "source": "Translate Ruby to Python: chars = (32..127).map do |ord|\n  k = case ord\n    when 32  then \"\u2420\"\n    when 127 then \"\u2421\"\n    else ord.chr \n  end\n  \"\nend\n \nchars.each_slice(chars.size/6).to_a.transpose.each{|s| puts s.join(\"  \")}\n", "target": "for i in range(16):\n    for j in range(32+i, 127+1, 16):\n        if j == 32:\n            k = 'Spc'\n        elif j == 127:\n            k = 'Del'\n        else:\n            k = chr(j)\n        print(\"%3d\u00a0: %-3s\" % (j,k), end=\"\")\n    print()\n"}
{"id": 145321, "name": "Sorting algorithms_Gnome sort", "source": "Translate Ruby to C#: class Array\n  def gnomesort!\n    i, j = 1, 2\n    while i < length\n      if self[i-1] <= self[i]\n        i, j = j, j+1\n      else\n        self[i-1], self[i] = self[i], self[i-1]\n        i -= 1\n        if i == 0\n          i, j = j, j+1\n        end\n      end\n    end\n    self\n  end\nend\nary = [7,6,5,9,8,4,3,1,2,0]\nary.gnomesort!\n\n", "target": "        public static void gnomeSort(int[] anArray)\n        {\n            int first = 1;\n            int second = 2;\n\n            while (first < anArray.Length)\n            {\n                if (anArray[first - 1] <= anArray[first])\n                {\n                    first = second;\n                    second++;\n                }\n                else\n                {\n                    int tmp = anArray[first - 1];\n                    anArray[first - 1] = anArray[first];\n                    anArray[first] = tmp;\n                    first -= 1;\n                    if (first == 0)\n                    {\n                        first = 1;\n                        second = 2;\n                    }\n                }\n                \n            }\n        }\n"}
{"id": 145323, "name": "Sorting algorithms_Gnome sort", "source": "Translate Ruby to Java: class Array\n  def gnomesort!\n    i, j = 1, 2\n    while i < length\n      if self[i-1] <= self[i]\n        i, j = j, j+1\n      else\n        self[i-1], self[i] = self[i], self[i-1]\n        i -= 1\n        if i == 0\n          i, j = j, j+1\n        end\n      end\n    end\n    self\n  end\nend\nary = [7,6,5,9,8,4,3,1,2,0]\nary.gnomesort!\n\n", "target": "public static void gnomeSort(int[] a)\n{\n  int i=1;\n  int j=2;\n \n  while(i < a.length) {\n    if ( a[i-1] <= a[i] ) {\n      i = j; j++;\n    } else {\n      int tmp = a[i-1];\n      a[i-1] = a[i];\n      a[i--] = tmp;\n      i = (i==0) ? j++ : i;\n    }\n  }\n}\n"}
{"id": 145324, "name": "Sorting algorithms_Gnome sort", "source": "Translate Ruby to Python: class Array\n  def gnomesort!\n    i, j = 1, 2\n    while i < length\n      if self[i-1] <= self[i]\n        i, j = j, j+1\n      else\n        self[i-1], self[i] = self[i], self[i-1]\n        i -= 1\n        if i == 0\n          i, j = j, j+1\n        end\n      end\n    end\n    self\n  end\nend\nary = [7,6,5,9,8,4,3,1,2,0]\nary.gnomesort!\n\n", "target": ">>> def gnomesort(a):\n\ti,j,size = 1,2,len(a)\n\twhile i < size:\n\t\tif a[i-1] <= a[i]:\n\t\t\ti,j = j, j+1\n\t\telse:\n\t\t\ta[i-1],a[i] = a[i],a[i-1]\n\t\t\ti -= 1\n\t\t\tif i == 0:\n\t\t\t\ti,j = j, j+1\n\treturn a\n\n>>> gnomesort([3,4,2,5,1,6])\n[1, 2, 3, 4, 5, 6]\n>>>\n"}
{"id": 145667, "name": "9 billion names of God the integer", "source": "Translate Ruby to C#: def g(n, g)\n  return 1 unless 1 < g && g < n-1\n  (2..g).reduce(1){ |res, q| res + (q > n-g ? 0 : g(n-g, q)) }\nend\n \n(1..25).each { |n| puts (1..n).map { |g| \"%4s\" % g(n, g) }.join }\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Numerics;\n\nnamespace NamesOfGod\n{\n    public class RowSummer\n    {\n        const int N = 100000;\n        public BigInteger[] p;\n\n        private void calc(int n)\n            \n        {\n            p[n] = 0;\n\n            for (int k = 1; k <= n; k++)\n            {\n                int d = n - k * (3 * k - 1) / 2;\n                if (d < 0) break;\n\n                if ((k & 1) != 0) p[n] += p[d];\n                else p[n] -= p[d];\n\n                d -= k;\n                if (d < 0) break;\n\n                if ((k & 1) != 0) p[n] += p[d];\n                else p[n] -= p[d];\n            }\n\n        }\n        public void PrintSums()\n            \n        {\n            p = new BigInteger[N + 1];\n            var idx = new int[] { 23, 123, 1234, 12345, 20000, 30000, 40000, 50000, N, 0 };\n            int at = 0;\n\n            p[0] = 1;\n\n            for (int i = 1; idx[at] > 0; i++)\n            {\n                calc(i);\n                if (i != idx[at]) continue;\n                Console.WriteLine(i + \":\\t\" + p[i]);\n                at++;\n            }\n        }\n    }\n\n    public class RowPrinter\n        \n    {\n        List<List<int>> cache;\n        public RowPrinter()\n        {\n            cache = new List<List<int>> { new List<int> { 1 } };\n        }\n        public List<int> cumu(int n)\n        {\n            for (int l = cache.Count; l < n + 1; l++)\n            {\n                var r = new List<int> { 0 };\n                for (int x = 1; x < l + 1; x++)\n                    r.Add(r.Last() + cache[l - x][Math.Min(x, l - x)]);\n                cache.Add(r);\n            }\n            return cache[n];\n        }\n        public List<int> row(int n)\n        {\n            var r = cumu(n);\n            return (from i in Enumerable.Range(0, n) select r[i + 1] - r[i]).ToList();\n        }\n        public void PrintRows()\n        {\n            var rows = Enumerable.Range(1, 25).Select(x => string.Join(\" \", row(x))).ToList();\n            var widest = rows.Last().Length;\n            foreach (var r in rows)\n                Console.WriteLine(new String(' ', (widest - r.Length) / 2) + r);\n        }\n    }\n\n    class Program\n    {\n        static void Main(string[] args) \n        {\n            var rpr = new RowPrinter();\n            rpr.PrintRows();\n            var ros = new RowSummer();\n            ros.PrintSums();\n            Console.ReadLine();\n        }\n    }\n}\n"}
{"id": 145668, "name": "9 billion names of God the integer", "source": "Translate Ruby to C#: def g(n, g)\n  return 1 unless 1 < g && g < n-1\n  (2..g).reduce(1){ |res, q| res + (q > n-g ? 0 : g(n-g, q)) }\nend\n \n(1..25).each { |n| puts (1..n).map { |g| \"%4s\" % g(n, g) }.join }\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Numerics;\n\nnamespace NamesOfGod\n{\n    public class RowSummer\n    {\n        const int N = 100000;\n        public BigInteger[] p;\n\n        private void calc(int n)\n            \n        {\n            p[n] = 0;\n\n            for (int k = 1; k <= n; k++)\n            {\n                int d = n - k * (3 * k - 1) / 2;\n                if (d < 0) break;\n\n                if ((k & 1) != 0) p[n] += p[d];\n                else p[n] -= p[d];\n\n                d -= k;\n                if (d < 0) break;\n\n                if ((k & 1) != 0) p[n] += p[d];\n                else p[n] -= p[d];\n            }\n\n        }\n        public void PrintSums()\n            \n        {\n            p = new BigInteger[N + 1];\n            var idx = new int[] { 23, 123, 1234, 12345, 20000, 30000, 40000, 50000, N, 0 };\n            int at = 0;\n\n            p[0] = 1;\n\n            for (int i = 1; idx[at] > 0; i++)\n            {\n                calc(i);\n                if (i != idx[at]) continue;\n                Console.WriteLine(i + \":\\t\" + p[i]);\n                at++;\n            }\n        }\n    }\n\n    public class RowPrinter\n        \n    {\n        List<List<int>> cache;\n        public RowPrinter()\n        {\n            cache = new List<List<int>> { new List<int> { 1 } };\n        }\n        public List<int> cumu(int n)\n        {\n            for (int l = cache.Count; l < n + 1; l++)\n            {\n                var r = new List<int> { 0 };\n                for (int x = 1; x < l + 1; x++)\n                    r.Add(r.Last() + cache[l - x][Math.Min(x, l - x)]);\n                cache.Add(r);\n            }\n            return cache[n];\n        }\n        public List<int> row(int n)\n        {\n            var r = cumu(n);\n            return (from i in Enumerable.Range(0, n) select r[i + 1] - r[i]).ToList();\n        }\n        public void PrintRows()\n        {\n            var rows = Enumerable.Range(1, 25).Select(x => string.Join(\" \", row(x))).ToList();\n            var widest = rows.Last().Length;\n            foreach (var r in rows)\n                Console.WriteLine(new String(' ', (widest - r.Length) / 2) + r);\n        }\n    }\n\n    class Program\n    {\n        static void Main(string[] args) \n        {\n            var rpr = new RowPrinter();\n            rpr.PrintRows();\n            var ros = new RowSummer();\n            ros.PrintSums();\n            Console.ReadLine();\n        }\n    }\n}\n"}
{"id": 145671, "name": "9 billion names of God the integer", "source": "Translate Ruby to Java: def g(n, g)\n  return 1 unless 1 < g && g < n-1\n  (2..g).reduce(1){ |res, q| res + (q > n-g ? 0 : g(n-g, q)) }\nend\n \n(1..25).each { |n| puts (1..n).map { |g| \"%4s\" % g(n, g) }.join }\n", "target": "import java.math.BigInteger;\nimport java.util.*;\nimport static java.util.Arrays.asList;\nimport static java.util.stream.Collectors.toList;\nimport static java.util.stream.IntStream.range;\nimport static java.lang.Math.min;\n\npublic class Test {\n\n    static List<BigInteger> cumu(int n) {\n        List<List<BigInteger>> cache = new ArrayList<>();\n        cache.add(asList(BigInteger.ONE));\n\n        for (int L = cache.size(); L < n + 1; L++) {\n            List<BigInteger> r = new ArrayList<>();\n            r.add(BigInteger.ZERO);\n            for (int x = 1; x < L + 1; x++)\n                r.add(r.get(r.size() - 1).add(cache.get(L - x).get(min(x, L - x))));\n            cache.add(r);\n        }\n        return cache.get(n);\n    }\n\n    static List<BigInteger> row(int n) {\n        List<BigInteger> r = cumu(n);\n        return range(0, n).mapToObj(i -> r.get(i + 1).subtract(r.get(i)))\n                .collect(toList());\n    }\n\n    public static void main(String[] args) {\n        System.out.println(\"Rows:\");\n        for (int x = 1; x < 11; x++)\n            System.out.printf(\"%2d: %s%n\", x, row(x));\n\n        System.out.println(\"\\nSums:\");\n        for (int x : new int[]{23, 123, 1234}) {\n            List<BigInteger> c = cumu(x);\n            System.out.printf(\"%s %s%n\", x, c.get(c.size() - 1));\n        }\n    }\n}\n"}
{"id": 145672, "name": "9 billion names of God the integer", "source": "Translate Ruby to Java: def g(n, g)\n  return 1 unless 1 < g && g < n-1\n  (2..g).reduce(1){ |res, q| res + (q > n-g ? 0 : g(n-g, q)) }\nend\n \n(1..25).each { |n| puts (1..n).map { |g| \"%4s\" % g(n, g) }.join }\n", "target": "import java.math.BigInteger;\nimport java.util.*;\nimport static java.util.Arrays.asList;\nimport static java.util.stream.Collectors.toList;\nimport static java.util.stream.IntStream.range;\nimport static java.lang.Math.min;\n\npublic class Test {\n\n    static List<BigInteger> cumu(int n) {\n        List<List<BigInteger>> cache = new ArrayList<>();\n        cache.add(asList(BigInteger.ONE));\n\n        for (int L = cache.size(); L < n + 1; L++) {\n            List<BigInteger> r = new ArrayList<>();\n            r.add(BigInteger.ZERO);\n            for (int x = 1; x < L + 1; x++)\n                r.add(r.get(r.size() - 1).add(cache.get(L - x).get(min(x, L - x))));\n            cache.add(r);\n        }\n        return cache.get(n);\n    }\n\n    static List<BigInteger> row(int n) {\n        List<BigInteger> r = cumu(n);\n        return range(0, n).mapToObj(i -> r.get(i + 1).subtract(r.get(i)))\n                .collect(toList());\n    }\n\n    public static void main(String[] args) {\n        System.out.println(\"Rows:\");\n        for (int x = 1; x < 11; x++)\n            System.out.printf(\"%2d: %s%n\", x, row(x));\n\n        System.out.println(\"\\nSums:\");\n        for (int x : new int[]{23, 123, 1234}) {\n            List<BigInteger> c = cumu(x);\n            System.out.printf(\"%s %s%n\", x, c.get(c.size() - 1));\n        }\n    }\n}\n"}
{"id": 145673, "name": "9 billion names of God the integer", "source": "Translate Ruby to Python: def g(n, g)\n  return 1 unless 1 < g && g < n-1\n  (2..g).reduce(1){ |res, q| res + (q > n-g ? 0 : g(n-g, q)) }\nend\n \n(1..25).each { |n| puts (1..n).map { |g| \"%4s\" % g(n, g) }.join }\n", "target": "cache = [[1]]\ndef cumu(n):\n    for l in range(len(cache), n+1):\n        r = [0]\n        for x in range(1, l+1):\n            r.append(r[-1] + cache[l-x][min(x, l-x)])\n        cache.append(r)\n    return cache[n]\n\ndef row(n):\n    r = cumu(n)\n    return [r[i+1] - r[i] for i in range(n)]\n\nprint \"rows:\"\nfor x in range(1, 11): print \"%2d:\"%x, row(x)\n\n\nprint \"\\nsums:\"\nfor x in [23, 123, 1234, 12345]: print x, cumu(x)[-1]\n"}
{"id": 145674, "name": "9 billion names of God the integer", "source": "Translate Ruby to Python: def g(n, g)\n  return 1 unless 1 < g && g < n-1\n  (2..g).reduce(1){ |res, q| res + (q > n-g ? 0 : g(n-g, q)) }\nend\n \n(1..25).each { |n| puts (1..n).map { |g| \"%4s\" % g(n, g) }.join }\n", "target": "cache = [[1]]\ndef cumu(n):\n    for l in range(len(cache), n+1):\n        r = [0]\n        for x in range(1, l+1):\n            r.append(r[-1] + cache[l-x][min(x, l-x)])\n        cache.append(r)\n    return cache[n]\n\ndef row(n):\n    r = cumu(n)\n    return [r[i+1] - r[i] for i in range(n)]\n\nprint \"rows:\"\nfor x in range(1, 11): print \"%2d:\"%x, row(x)\n\n\nprint \"\\nsums:\"\nfor x in [23, 123, 1234, 12345]: print x, cumu(x)[-1]\n"}
{"id": 146169, "name": "Balanced brackets", "source": "Translate Ruby to C#: def generate(n : Int) \n  (['[',']'] * n).shuffle.join \nend\n\ndef is_balanced(str : String)\n  count = 0\n  str.each_char do |ch|\n    case ch\n    when '['\n      count += 1\n    when ']'\n      count -= 1\n      if count < 0\n        return false\n      end\n    else\n      return false\n    end\n  end\n  count == 0\nend\n\n10.times do |i|\n  str = generate(i)\n  puts \"\nend\n", "target": "using System;\nusing System.Linq;\n\nclass Program\n{\n    static bool IsBalanced(string text, char open = '[', char close = ']')\n    {\n        var level = 0;\n        foreach (var character in text)\n        {\n            if (character == close)\n            {\n                if (level == 0)\n                {\n                    return false;\n                }\n                level--;\n            }\n            if (character == open)\n            {\n                level++;\n            }\n        }\n        return level == 0;\n    }\n\n    static string RandomBrackets(int count, char open = '[', char close = ']')\n    {\n        var random = new Random();\n        return string.Join(string.Empty,\n                (new string(open, count) + new string(close, count)).OrderBy(c => random.Next()));\n    }\n\n    static void Main()\n    {\n        for (var count = 0; count < 9; count++)\n        {\n            var text = RandomBrackets(count);\n            Console.WriteLine(\"\\\"{0}\\\" is {1}balanced.\", text, IsBalanced(text) ? string.Empty : \"not \");\n        }\n    }\n}\n"}
{"id": 146170, "name": "Balanced brackets", "source": "Translate Ruby to C#: def generate(n : Int) \n  (['[',']'] * n).shuffle.join \nend\n\ndef is_balanced(str : String)\n  count = 0\n  str.each_char do |ch|\n    case ch\n    when '['\n      count += 1\n    when ']'\n      count -= 1\n      if count < 0\n        return false\n      end\n    else\n      return false\n    end\n  end\n  count == 0\nend\n\n10.times do |i|\n  str = generate(i)\n  puts \"\nend\n", "target": "using System;\nusing System.Linq;\n\nclass Program\n{\n    static bool IsBalanced(string text, char open = '[', char close = ']')\n    {\n        var level = 0;\n        foreach (var character in text)\n        {\n            if (character == close)\n            {\n                if (level == 0)\n                {\n                    return false;\n                }\n                level--;\n            }\n            if (character == open)\n            {\n                level++;\n            }\n        }\n        return level == 0;\n    }\n\n    static string RandomBrackets(int count, char open = '[', char close = ']')\n    {\n        var random = new Random();\n        return string.Join(string.Empty,\n                (new string(open, count) + new string(close, count)).OrderBy(c => random.Next()));\n    }\n\n    static void Main()\n    {\n        for (var count = 0; count < 9; count++)\n        {\n            var text = RandomBrackets(count);\n            Console.WriteLine(\"\\\"{0}\\\" is {1}balanced.\", text, IsBalanced(text) ? string.Empty : \"not \");\n        }\n    }\n}\n"}
{"id": 146173, "name": "Balanced brackets", "source": "Translate Ruby to Java: def generate(n : Int) \n  (['[',']'] * n).shuffle.join \nend\n\ndef is_balanced(str : String)\n  count = 0\n  str.each_char do |ch|\n    case ch\n    when '['\n      count += 1\n    when ']'\n      count -= 1\n      if count < 0\n        return false\n      end\n    else\n      return false\n    end\n  end\n  count == 0\nend\n\n10.times do |i|\n  str = generate(i)\n  puts \"\nend\n", "target": "module BalancedBrackets\n    {\n    Boolean balanced(String text)\n        {\n        Int depth = 0;\n        for (Char ch : text)\n            {\n            switch (ch, depth)\n                {\n                case ('[', _):\n                    ++depth;\n                    break;\n                case (']', 0):\n                    return False;\n                case (']', _):\n                    --depth;\n                    break;\n                }\n            }\n        return depth==0;\n        }\n\n    @Inject Console console;\n    void run()\n        {\n        String[] tests =\n            [\n            \"[]\",\n            \"[][]\",\n            \"[]][[]\",\n            \"[[[]][]]\",\n            \"][[[[]][]]\",\n            \"[[[]][[]][]]\",\n            \"]][[]][[[[][]]\",\n            \"[[]]]][]][[][[[]\",\n            ];\n        Int longest = tests.map(s -> s.size).reduce(0, (max, len) -> max.maxOf(len));\n        for (String test : tests)\n            {\n            console.print($\"{test}{' ' * (longest-test.size)} {balanced(test)\u00a0? \"OK\"\u00a0: \"NOT OK\"}\");\n            }\n        }\n    }\n"}
{"id": 146174, "name": "Balanced brackets", "source": "Translate Ruby to Java: def generate(n : Int) \n  (['[',']'] * n).shuffle.join \nend\n\ndef is_balanced(str : String)\n  count = 0\n  str.each_char do |ch|\n    case ch\n    when '['\n      count += 1\n    when ']'\n      count -= 1\n      if count < 0\n        return false\n      end\n    else\n      return false\n    end\n  end\n  count == 0\nend\n\n10.times do |i|\n  str = generate(i)\n  puts \"\nend\n", "target": "module BalancedBrackets\n    {\n    Boolean balanced(String text)\n        {\n        Int depth = 0;\n        for (Char ch : text)\n            {\n            switch (ch, depth)\n                {\n                case ('[', _):\n                    ++depth;\n                    break;\n                case (']', 0):\n                    return False;\n                case (']', _):\n                    --depth;\n                    break;\n                }\n            }\n        return depth==0;\n        }\n\n    @Inject Console console;\n    void run()\n        {\n        String[] tests =\n            [\n            \"[]\",\n            \"[][]\",\n            \"[]][[]\",\n            \"[[[]][]]\",\n            \"][[[[]][]]\",\n            \"[[[]][[]][]]\",\n            \"]][[]][[[[][]]\",\n            \"[[]]]][]][[][[[]\",\n            ];\n        Int longest = tests.map(s -> s.size).reduce(0, (max, len) -> max.maxOf(len));\n        for (String test : tests)\n            {\n            console.print($\"{test}{' ' * (longest-test.size)} {balanced(test)\u00a0? \"OK\"\u00a0: \"NOT OK\"}\");\n            }\n        }\n    }\n"}
{"id": 146175, "name": "Balanced brackets", "source": "Translate Ruby to Python: def generate(n : Int) \n  (['[',']'] * n).shuffle.join \nend\n\ndef is_balanced(str : String)\n  count = 0\n  str.each_char do |ch|\n    case ch\n    when '['\n      count += 1\n    when ']'\n      count -= 1\n      if count < 0\n        return false\n      end\n    else\n      return false\n    end\n  end\n  count == 0\nend\n\n10.times do |i|\n  str = generate(i)\n  puts \"\nend\n", "target": ">>> def gen(N):\n...     txt = ['[', ']'] * N\n...     random.shuffle( txt )\n...     return ''.join(txt)\n... \n>>> def balanced(txt):\n...     braced = 0\n...     for ch in txt:\n...         if ch == '[': braced += 1\n...         if ch == ']':\n...             braced -= 1\n...             if braced < 0: return False\n...     return braced == 0\n... \n>>> for txt in (gen(N) for N in range(10)):\n...     print (\"%-22r is%s balanced\" % (txt, '' if balanced(txt) else ' not'))\n... \n''                     is balanced\n'[]'                   is balanced\n'[][]'                 is balanced\n'][[[]]'               is not balanced\n'[]][[][]'             is not balanced\n'[][[][]]]['           is not balanced\n'][]][][[]][['         is not balanced\n'[[]]]]][]][[[['       is not balanced\n'[[[[]][]]][[][]]'     is balanced\n'][[][[]]][]]][[[[]'   is not balanced\n"}
{"id": 146176, "name": "Balanced brackets", "source": "Translate Ruby to Python: def generate(n : Int) \n  (['[',']'] * n).shuffle.join \nend\n\ndef is_balanced(str : String)\n  count = 0\n  str.each_char do |ch|\n    case ch\n    when '['\n      count += 1\n    when ']'\n      count -= 1\n      if count < 0\n        return false\n      end\n    else\n      return false\n    end\n  end\n  count == 0\nend\n\n10.times do |i|\n  str = generate(i)\n  puts \"\nend\n", "target": ">>> def gen(N):\n...     txt = ['[', ']'] * N\n...     random.shuffle( txt )\n...     return ''.join(txt)\n... \n>>> def balanced(txt):\n...     braced = 0\n...     for ch in txt:\n...         if ch == '[': braced += 1\n...         if ch == ']':\n...             braced -= 1\n...             if braced < 0: return False\n...     return braced == 0\n... \n>>> for txt in (gen(N) for N in range(10)):\n...     print (\"%-22r is%s balanced\" % (txt, '' if balanced(txt) else ' not'))\n... \n''                     is balanced\n'[]'                   is balanced\n'[][]'                 is balanced\n'][[[]]'               is not balanced\n'[]][[][]'             is not balanced\n'[][[][]]]['           is not balanced\n'][]][][[]][['         is not balanced\n'[[]]]]][]][[[['       is not balanced\n'[[[[]][]]][[][]]'     is balanced\n'][[][[]]][]]][[[[]'   is not balanced\n"}
{"id": 146476, "name": "Numerical integration", "source": "Translate Ruby to C#: def leftrect(f, left, right)\n  f.call(left)\nend\n \ndef midrect(f, left, right)\n  f.call((left+right)/2.0)\nend\n \ndef rightrect(f, left, right)\n  f.call(right)\nend\n \ndef trapezium(f, left, right)\n  (f.call(left) + f.call(right)) / 2.0\nend\n \ndef simpson(f, left, right)\n  (f.call(left) + 4*f.call((left+right)/2.0) + f.call(right)) / 6.0\nend\n \ndef integrate(f, a, b, steps, method)\n  delta = 1.0 * (b - a) / steps\n  total = 0.0\n  steps.times do |i|\n    left = a + i*delta\n    right = left + delta\n    total += delta * send(method, f, left, right)\n  end\n  total\nend\n \ndef square(x)\n  x**2\nend\n \ndef def_int(f, a, b)\n  l = case f.to_s\n      when /sin>/\n        lambda {|x| -Math.cos(x)}\n      when /square>/\n        lambda {|x| (x**3)/3.0}\n      end\n  l.call(b) - l.call(a)\nend\n \na = 0\nb = Math::PI\nsteps = 10\n \nfor func in [method(:square), Math.method(:sin)]\n  puts \"integral of \n  actual = def_int(func, a, b)\n  for method in [:leftrect, :midrect, :rightrect, :trapezium, :simpson]\n    int = integrate(func, a, b, steps, method)\n    diff = (int - actual) * 100.0 / actual\n    printf \"  \u00a0%-10s  %s\\t(%.1f%%)\\n\", method, int, diff\n  end\nend\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\npublic class Interval\n{\n    public Interval(double leftEndpoint, double size)\n    {\n        LeftEndpoint = leftEndpoint;\n        RightEndpoint = leftEndpoint + size;\n    }\n\n    public double LeftEndpoint\n    {\n        get;\n        set;\n    }\n\n    public double RightEndpoint\n    {\n        get;\n        set;\n    }\n\n    public double Size\n    {\n        get\n        {\n            return RightEndpoint - LeftEndpoint;\n        }\n    }\n\n    public double Center\n    {\n        get\n        {\n            return (LeftEndpoint + RightEndpoint) / 2;\n        }\n    }\n\n    public IEnumerable<Interval> Subdivide(int subintervalCount)\n    {\n        double subintervalSize = Size / subintervalCount;\n        return Enumerable.Range(0, subintervalCount).Select(index => new Interval(LeftEndpoint + index * subintervalSize, subintervalSize));\n    }\n}\n\npublic class DefiniteIntegral\n{\n    public DefiniteIntegral(Func<double, double> integrand, Interval domain)\n    {\n        Integrand = integrand;\n        Domain = domain;\n    }\n\n    public Func<double, double> Integrand\n    {\n        get;\n        set;\n    }\n\n    public Interval Domain\n    {\n        get;\n        set;\n    }\n\n    public double SampleIntegrand(ApproximationMethod approximationMethod, Interval subdomain)\n    {\n        switch (approximationMethod)\n        {\n            case ApproximationMethod.RectangleLeft:\n                return Integrand(subdomain.LeftEndpoint);\n            case ApproximationMethod.RectangleMidpoint:\n                return Integrand(subdomain.Center);\n            case ApproximationMethod.RectangleRight:\n                return Integrand(subdomain.RightEndpoint);\n            case ApproximationMethod.Trapezium:\n                return (Integrand(subdomain.LeftEndpoint) + Integrand(subdomain.RightEndpoint)) / 2;\n            case ApproximationMethod.Simpson:\n                return (Integrand(subdomain.LeftEndpoint) + 4 * Integrand(subdomain.Center) + Integrand(subdomain.RightEndpoint)) / 6;\n            default:\n                throw new NotImplementedException();\n        }\n    }\n\n    public double Approximate(ApproximationMethod approximationMethod, int subdomainCount)\n    {\n        return Domain.Size * Domain.Subdivide(subdomainCount).Sum(subdomain => SampleIntegrand(approximationMethod, subdomain)) / subdomainCount;\n    }\n\n    public enum ApproximationMethod\n    {\n        RectangleLeft,\n        RectangleMidpoint,\n        RectangleRight,\n        Trapezium,\n        Simpson\n    }\n}\n\npublic class Program\n{\n    private static void TestApproximationMethods(DefiniteIntegral integral, int subdomainCount)\n    {\n        foreach (DefiniteIntegral.ApproximationMethod approximationMethod in Enum.GetValues(typeof(DefiniteIntegral.ApproximationMethod)))\n        {\n            Console.WriteLine(integral.Approximate(approximationMethod, subdomainCount));\n        }\n    }\n\n    public static void Main()\n    {\n        TestApproximationMethods(new DefiniteIntegral(x => x * x * x, new Interval(0, 1)), 10000);\n        TestApproximationMethods(new DefiniteIntegral(x => 1 / x, new Interval(1, 99)), 1000);\n        TestApproximationMethods(new DefiniteIntegral(x => x, new Interval(0, 5000)), 500000);\n        TestApproximationMethods(new DefiniteIntegral(x => x, new Interval(0, 6000)), 6000000);\n    }\n}\n"}
{"id": 146478, "name": "Numerical integration", "source": "Translate Ruby to Java: def leftrect(f, left, right)\n  f.call(left)\nend\n \ndef midrect(f, left, right)\n  f.call((left+right)/2.0)\nend\n \ndef rightrect(f, left, right)\n  f.call(right)\nend\n \ndef trapezium(f, left, right)\n  (f.call(left) + f.call(right)) / 2.0\nend\n \ndef simpson(f, left, right)\n  (f.call(left) + 4*f.call((left+right)/2.0) + f.call(right)) / 6.0\nend\n \ndef integrate(f, a, b, steps, method)\n  delta = 1.0 * (b - a) / steps\n  total = 0.0\n  steps.times do |i|\n    left = a + i*delta\n    right = left + delta\n    total += delta * send(method, f, left, right)\n  end\n  total\nend\n \ndef square(x)\n  x**2\nend\n \ndef def_int(f, a, b)\n  l = case f.to_s\n      when /sin>/\n        lambda {|x| -Math.cos(x)}\n      when /square>/\n        lambda {|x| (x**3)/3.0}\n      end\n  l.call(b) - l.call(a)\nend\n \na = 0\nb = Math::PI\nsteps = 10\n \nfor func in [method(:square), Math.method(:sin)]\n  puts \"integral of \n  actual = def_int(func, a, b)\n  for method in [:leftrect, :midrect, :rightrect, :trapezium, :simpson]\n    int = integrate(func, a, b, steps, method)\n    diff = (int - actual) * 100.0 / actual\n    printf \"  \u00a0%-10s  %s\\t(%.1f%%)\\n\", method, int, diff\n  end\nend\n", "target": "class NumericalIntegration\n{\n\n  interface FPFunction\n  {\n    double eval(double n);\n  }\n  \n  public static double rectangularLeft(double a, double b, int n, FPFunction f)\n  {\n    return rectangular(a, b, n, f, 0);\n  }\n  \n  public static double rectangularMidpoint(double a, double b, int n, FPFunction f)\n  {\n    return rectangular(a, b, n, f, 1);\n  }\n  \n  public static double rectangularRight(double a, double b, int n, FPFunction f)\n  {\n    return rectangular(a, b, n, f, 2);\n  }\n  \n  public static double trapezium(double a, double b, int n, FPFunction f)\n  {\n    double range = checkParamsGetRange(a, b, n);\n    double nFloat = (double)n;\n    double sum = 0.0;\n    for (int i = 1; i < n; i++)\n    {\n      double x = a + range * (double)i / nFloat;\n      sum += f.eval(x);\n    }\n    sum += (f.eval(a) + f.eval(b)) / 2.0;\n    return sum * range / nFloat;\n  }\n  \n  public static double simpsons(double a, double b, int n, FPFunction f)\n  {\n    double range = checkParamsGetRange(a, b, n);\n    double nFloat = (double)n;\n    double sum1 = f.eval(a + range / (nFloat * 2.0));\n    double sum2 = 0.0;\n    for (int i = 1; i < n; i++)\n    {\n      double x1 = a + range * ((double)i + 0.5) / nFloat;\n      sum1 += f.eval(x1);\n      double x2 = a + range * (double)i / nFloat;\n      sum2 += f.eval(x2);\n    }\n    return (f.eval(a) + f.eval(b) + sum1 * 4.0 + sum2 * 2.0) * range / (nFloat * 6.0);\n  }\n  \n  private static double rectangular(double a, double b, int n, FPFunction f, int mode)\n  {\n    double range = checkParamsGetRange(a, b, n);\n    double modeOffset = (double)mode / 2.0;\n    double nFloat = (double)n;\n    double sum = 0.0;\n    for (int i = 0; i < n; i++)\n    {\n      double x = a + range * ((double)i + modeOffset) / nFloat;\n      sum += f.eval(x);\n    }\n    return sum * range / nFloat;\n  }\n  \n  private static double checkParamsGetRange(double a, double b, int n)\n  {\n    if (n <= 0)\n      throw new IllegalArgumentException(\"Invalid value of n\");\n    double range = b - a;\n    if (range <= 0)\n      throw new IllegalArgumentException(\"Invalid range\");\n    return range;\n  }\n  \n  \n  private static void testFunction(String fname, double a, double b, int n, FPFunction f)\n  {\n    System.out.println(\"Testing function \\\"\" + fname + \"\\\", a=\" + a + \", b=\" + b + \", n=\" + n);\n    System.out.println(\"rectangularLeft: \" + rectangularLeft(a, b, n, f));\n    System.out.println(\"rectangularMidpoint: \" + rectangularMidpoint(a, b, n, f));\n    System.out.println(\"rectangularRight: \" + rectangularRight(a, b, n, f));\n    System.out.println(\"trapezium: \" + trapezium(a, b, n, f));\n    System.out.println(\"simpsons: \" + simpsons(a, b, n, f));\n    System.out.println();\n    return;\n  }\n  \n  public static void main(String[] args)\n  {\n    testFunction(\"x^3\", 0.0, 1.0, 100, new FPFunction() {\n        public double eval(double n) {\n          return n * n * n;\n        }\n      }\n    );\n    \n    testFunction(\"1/x\", 1.0, 100.0, 1000, new FPFunction() {\n        public double eval(double n) {\n          return 1.0 / n;\n        }\n      }\n    );\n    \n    testFunction(\"x\", 0.0, 5000.0, 5000000, new FPFunction() {\n        public double eval(double n) {\n          return n;\n        }\n      }\n    );\n    \n    testFunction(\"x\", 0.0, 6000.0, 6000000, new FPFunction() {\n        public double eval(double n) {\n          return n;\n        }\n      }\n    );\n    \n    return;\n  }\n}\n"}
{"id": 146479, "name": "Numerical integration", "source": "Translate Ruby to Python: def leftrect(f, left, right)\n  f.call(left)\nend\n \ndef midrect(f, left, right)\n  f.call((left+right)/2.0)\nend\n \ndef rightrect(f, left, right)\n  f.call(right)\nend\n \ndef trapezium(f, left, right)\n  (f.call(left) + f.call(right)) / 2.0\nend\n \ndef simpson(f, left, right)\n  (f.call(left) + 4*f.call((left+right)/2.0) + f.call(right)) / 6.0\nend\n \ndef integrate(f, a, b, steps, method)\n  delta = 1.0 * (b - a) / steps\n  total = 0.0\n  steps.times do |i|\n    left = a + i*delta\n    right = left + delta\n    total += delta * send(method, f, left, right)\n  end\n  total\nend\n \ndef square(x)\n  x**2\nend\n \ndef def_int(f, a, b)\n  l = case f.to_s\n      when /sin>/\n        lambda {|x| -Math.cos(x)}\n      when /square>/\n        lambda {|x| (x**3)/3.0}\n      end\n  l.call(b) - l.call(a)\nend\n \na = 0\nb = Math::PI\nsteps = 10\n \nfor func in [method(:square), Math.method(:sin)]\n  puts \"integral of \n  actual = def_int(func, a, b)\n  for method in [:leftrect, :midrect, :rightrect, :trapezium, :simpson]\n    int = integrate(func, a, b, steps, method)\n    diff = (int - actual) * 100.0 / actual\n    printf \"  \u00a0%-10s  %s\\t(%.1f%%)\\n\", method, int, diff\n  end\nend\n", "target": "from fractions import Fraction\n\ndef left_rect(f,x,h):\n  return f(x)\n \ndef mid_rect(f,x,h):\n  return f(x + h/2)\n \ndef right_rect(f,x,h):\n  return f(x+h)\n \ndef trapezium(f,x,h):\n  return (f(x) + f(x+h))/2.0\n \ndef simpson(f,x,h):\n  return (f(x) + 4*f(x + h/2) + f(x+h))/6.0\n \ndef cube(x):\n  return x*x*x\n \ndef reciprocal(x):\n  return 1/x\n \ndef identity(x):\n  return x\n \ndef integrate( f, a, b, steps, meth):\n   h = (b-a)/steps\n   ival = h * sum(meth(f, a+i*h, h) for i in range(steps))\n   return ival  \n\n\nfor a, b, steps, func in ((0., 1., 100, cube), (1., 100., 1000, reciprocal)):\n    for rule in (left_rect, mid_rect, right_rect, trapezium, simpson):\n        print('%s integrated using %s\\n  from %r to %r (%i steps) = %r' %\n              (func.__name__, rule.__name__, a, b, steps,\n               integrate( func, a, b, steps, rule)))\n    a, b = Fraction.from_float(a), Fraction.from_float(b)\n    for rule in (left_rect, mid_rect, right_rect, trapezium, simpson):\n        print('%s integrated using %s\\n  from %r to %r (%i steps and fractions) = %r' %\n              (func.__name__, rule.__name__, a, b, steps,\n               float(integrate( func, a, b, steps, rule))))\n\n\nfor a, b, steps, func in ((0., 5000., 5000000, identity),\n                          (0., 6000., 6000000, identity)):\n    for rule in (left_rect, mid_rect, right_rect, trapezium, simpson):\n        print('%s integrated using %s\\n  from %r to %r (%i steps) = %r' %\n              (func.__name__, rule.__name__, a, b, steps,\n               integrate( func, a, b, steps, rule)))\n    a, b = Fraction.from_float(a), Fraction.from_float(b)\n    for rule in (left_rect, mid_rect, right_rect, trapezium, simpson):\n        print('%s integrated using %s\\n  from %r to %r (%i steps and fractions) = %r' %\n              (func.__name__, rule.__name__, a, b, steps,\n               float(integrate( func, a, b, steps, rule))))\n"}
{"id": 146733, "name": "Universal Turing machine", "source": "Translate Ruby to C#: class Turing\n    class Tape\n        def initialize(symbols, blank, starting_tape)\n            @symbols = symbols\n            @blank = blank\n            @tape = starting_tape\n            @index = 0\n        end\n        def read\n            retval = @tape[@index]\n            unless retval\n                retval = @tape[@index] = @blank\n            end\n            raise \"invalid symbol '\n            return retval\n        end\n        def write(symbol)\n            @tape[@index] = symbol\n        end\n        def right\n            @index += 1\n        end\n        def left\n            if @index == 0\n              @tape.unshift @blank\n            else\n              @index -= 1\n            end\n        end\n        def stay\n            \n        end\n        def get_tape\n            return @tape\n        end\n    end\n\n    def initialize(symbols, blank,\n                   initial_state, halt_states, running_states,\n                   rules, starting_tape = [])\n        @tape = Tape.new(symbols, blank, starting_tape)\n        @initial_state = initial_state\n        @halt_states = halt_states\n        @running_states = running_states\n        @rules = rules\n        @halted = false\n    end\n    def run\n        raise \"machine already halted\" if @halted\n        state = @initial_state\n        while (true)\n            break if @halt_states.member? state\n            raise \"unknown state '\n            symbol = @tape.read\n            outsym, action, state = @rules[state][symbol]\n            @tape.write outsym\n            @tape.send action\n        end\n        @halted = true\n        return @tape.get_tape\n    end\nend\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\nusing System.Linq;\nusing System.Text;\nusing System.Threading;\nusing System.Threading.Tasks;\n\npublic class TuringMachine\n{\n    public static async Task Main() {\n        var fiveStateBusyBeaver = new TuringMachine(\"A\", '0', \"H\").WithTransitions(\n            (\"A\", '0', '1', Right, \"B\"),\n            (\"A\", '1', '1', Left,  \"C\"),\n            (\"B\", '0', '1', Right, \"C\"),\n            (\"B\", '1', '1', Right, \"B\"),\n            (\"C\", '0', '1', Right, \"D\"),\n            (\"C\", '1', '0', Left,  \"E\"),\n            (\"D\", '0', '1', Left,  \"A\"),\n            (\"D\", '1', '1', Left,  \"D\"),\n            (\"E\", '0', '1', Stay,  \"H\"),\n            (\"E\", '1', '0', Left,  \"A\")\n        );\n        var busyBeaverTask = fiveStateBusyBeaver.TimeAsync();\n\n        var incrementer = new TuringMachine(\"q0\", 'B', \"qf\").WithTransitions(\n            (\"q0\", '1', '1', Right, \"q0\"),\n            (\"q0\", 'B', '1', Stay,  \"qf\")\n        )\n        .WithInput(\"111\");\n        foreach (var _ in incrementer.Run()) PrintLine(incrementer);\n        PrintResults(incrementer);\n\n        var threeStateBusyBeaver = new TuringMachine(\"a\", '0', \"halt\").WithTransitions(\n            (\"a\", '0', '1', Right, \"b\"),\n            (\"a\", '1', '1', Left,  \"c\"),\n            (\"b\", '0', '1', Left,  \"a\"),\n            (\"b\", '1', '1', Right, \"b\"),\n            (\"c\", '0', '1', Left,  \"b\"),\n            (\"c\", '1', '1', Stay,  \"halt\")\n        );\n        foreach (var _ in threeStateBusyBeaver.Run()) PrintLine(threeStateBusyBeaver);\n        PrintResults(threeStateBusyBeaver);\n\n        var sorter = new TuringMachine(\"A\", '*', \"X\").WithTransitions(\n            (\"A\", 'a', 'a', Right, \"A\"),\n            (\"A\", 'b', 'B', Right, \"B\"),\n            (\"A\", '*', '*', Left,  \"E\"),\n            (\"B\", 'a', 'a', Right, \"B\"),\n            (\"B\", 'b', 'b', Right, \"B\"),\n            (\"B\", '*', '*', Left,  \"C\"),\n            (\"C\", 'a', 'b', Left,  \"D\"),\n            (\"C\", 'b', 'b', Left,  \"C\"),\n            (\"C\", 'B', 'b', Left,  \"E\"),\n            (\"D\", 'a', 'a', Left,  \"D\"),\n            (\"D\", 'b', 'b', Left,  \"D\"),\n            (\"D\", 'B', 'a', Right, \"A\"),\n            (\"E\", 'a', 'a', Left,  \"E\"),\n            (\"E\", '*', '*', Right, \"X\")\n        )\n        .WithInput(\"babbababaa\");\n        sorter.Run().Last();\n        Console.WriteLine(\"Sorted: \" + sorter.TapeString);\n        PrintResults(sorter);\n\n        sorter.Reset().WithInput(\"bbbababaaabba\");\n        sorter.Run().Last();\n        Console.WriteLine(\"Sorted: \" + sorter.TapeString);\n        PrintResults(sorter);\n\n        Console.WriteLine(await busyBeaverTask);\n        PrintResults(fiveStateBusyBeaver);\n\n        void PrintLine(TuringMachine tm) => Console.WriteLine(tm.TapeString + \"\\tState \" + tm.State);\n\n        void PrintResults(TuringMachine tm) {\n            Console.WriteLine($\"End state: {tm.State} = {(tm.Success\u00a0? \"Success\"\u00a0: \"Failure\")}\");\n            Console.WriteLine(tm.Steps + \" steps\");\n            Console.WriteLine(\"tape length: \" + tm.TapeLength);\n            Console.WriteLine();\n        }\n    }\n\n    public const int Left = -1, Stay = 0, Right = 1;\n    private readonly Tape tape;\n    private readonly string initialState;\n    private readonly HashSet<string> terminatingStates;\n    private Dictionary<(string state, char read), (char write, int move, string toState)> transitions;\n\n    public TuringMachine(string initialState, char blankSymbol, params string[] terminatingStates) {\n        State = this.initialState = initialState;\n        tape = new Tape(blankSymbol);\n        this.terminatingStates = terminatingStates.ToHashSet();\n    }\n\n    public TuringMachine WithTransitions(\n        params (string state, char read, char write, int move, string toState)[] transitions)\n    {\n        this.transitions = transitions.ToDictionary(k => (k.state, k.read), k => (k.write, k.move, k.toState));\n        return this;\n    }\n\n    public TuringMachine Reset() {\n        State = initialState;\n        Steps = 0;\n        tape.Reset();\n        return this;\n    }\n\n    public TuringMachine WithInput(string input) {\n        tape.Input(input);\n        return this;\n    }\n\n    public int Steps { get; private set; }\n    public string State { get; private set; }\n    public bool Success => terminatingStates.Contains(State);\n    public int TapeLength => tape.Length;\n    public string TapeString => tape.ToString();\n\n    public IEnumerable<string> Run() {\n        yield return State;\n        while (Step()) yield return State;\n    }\n\n    public async Task<TimeSpan> TimeAsync(CancellationToken cancel = default) {\n        var chrono = Stopwatch.StartNew();\n        await RunAsync(cancel);\n        chrono.Stop();\n        return chrono.Elapsed;\n    }\n\n    public Task RunAsync(CancellationToken cancel = default)\n        => Task.Run(() => {\n            while (Step()) cancel.ThrowIfCancellationRequested();\n        });\n\n    private bool Step() {\n        if (!transitions.TryGetValue((State, tape.Current), out var action)) return false;\n        tape.Current = action.write;\n        tape.Move(action.move);\n        State = action.toState;\n        Steps++;\n        return true;\n    }\n\n\n    private class Tape\n    {\n        private List<char> forwardTape = new List<char>(), backwardTape = new List<char>();\n        private int head = 0;\n        private char blank;\n\n        public Tape(char blankSymbol) => forwardTape.Add(blank = blankSymbol);\n\n        public void Reset() {\n            backwardTape.Clear();\n            forwardTape.Clear();\n            head = 0;\n            forwardTape.Add(blank);\n        }\n\n        public void Input(string input) {\n            Reset();\n            forwardTape.Clear();\n            forwardTape.AddRange(input);\n        }\n\n        public void Move(int direction) {\n            head += direction;\n            if (head >= 0 && forwardTape.Count <= head) forwardTape.Add(blank);\n            if (head < 0 && backwardTape.Count <= ~head) backwardTape.Add(blank);\n        }\n\n        public char Current {\n            get => head < 0 ? backwardTape[~head] : forwardTape[head];\n            set {\n                if (head < 0) backwardTape[~head] = value;\n                else forwardTape[head] = value;\n            }\n        }\n\n        public int Length => backwardTape.Count + forwardTape.Count;\n\n        public override string ToString() {\n            int h = (head < 0 ? ~head : backwardTape.Count + head) * 2 + 1;\n            var builder = new StringBuilder(\" \", Length * 2 + 1);\n            if (backwardTape.Count > 0) {\n                builder.Append(string.Join(\" \", backwardTape)).Append(\" \");\n                if (head < 0) (builder[h + 1], builder[h - 1]) = ('(', ')');\n                for (int l = 0, r = builder.Length - 1; l < r; l++, r--) (builder[l], builder[r]) = (builder[r], builder[l]);\n            }\n            builder.Append(string.Join(\" \", forwardTape)).Append(\" \");\n            if (head >= 0) (builder[h - 1], builder[h + 1]) = ('(', ')');\n            return builder.ToString();\n        }\n\n    }\n\n}\n"}
{"id": 146734, "name": "Universal Turing machine", "source": "Translate Ruby to C#: class Turing\n    class Tape\n        def initialize(symbols, blank, starting_tape)\n            @symbols = symbols\n            @blank = blank\n            @tape = starting_tape\n            @index = 0\n        end\n        def read\n            retval = @tape[@index]\n            unless retval\n                retval = @tape[@index] = @blank\n            end\n            raise \"invalid symbol '\n            return retval\n        end\n        def write(symbol)\n            @tape[@index] = symbol\n        end\n        def right\n            @index += 1\n        end\n        def left\n            if @index == 0\n              @tape.unshift @blank\n            else\n              @index -= 1\n            end\n        end\n        def stay\n            \n        end\n        def get_tape\n            return @tape\n        end\n    end\n\n    def initialize(symbols, blank,\n                   initial_state, halt_states, running_states,\n                   rules, starting_tape = [])\n        @tape = Tape.new(symbols, blank, starting_tape)\n        @initial_state = initial_state\n        @halt_states = halt_states\n        @running_states = running_states\n        @rules = rules\n        @halted = false\n    end\n    def run\n        raise \"machine already halted\" if @halted\n        state = @initial_state\n        while (true)\n            break if @halt_states.member? state\n            raise \"unknown state '\n            symbol = @tape.read\n            outsym, action, state = @rules[state][symbol]\n            @tape.write outsym\n            @tape.send action\n        end\n        @halted = true\n        return @tape.get_tape\n    end\nend\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\nusing System.Linq;\nusing System.Text;\nusing System.Threading;\nusing System.Threading.Tasks;\n\npublic class TuringMachine\n{\n    public static async Task Main() {\n        var fiveStateBusyBeaver = new TuringMachine(\"A\", '0', \"H\").WithTransitions(\n            (\"A\", '0', '1', Right, \"B\"),\n            (\"A\", '1', '1', Left,  \"C\"),\n            (\"B\", '0', '1', Right, \"C\"),\n            (\"B\", '1', '1', Right, \"B\"),\n            (\"C\", '0', '1', Right, \"D\"),\n            (\"C\", '1', '0', Left,  \"E\"),\n            (\"D\", '0', '1', Left,  \"A\"),\n            (\"D\", '1', '1', Left,  \"D\"),\n            (\"E\", '0', '1', Stay,  \"H\"),\n            (\"E\", '1', '0', Left,  \"A\")\n        );\n        var busyBeaverTask = fiveStateBusyBeaver.TimeAsync();\n\n        var incrementer = new TuringMachine(\"q0\", 'B', \"qf\").WithTransitions(\n            (\"q0\", '1', '1', Right, \"q0\"),\n            (\"q0\", 'B', '1', Stay,  \"qf\")\n        )\n        .WithInput(\"111\");\n        foreach (var _ in incrementer.Run()) PrintLine(incrementer);\n        PrintResults(incrementer);\n\n        var threeStateBusyBeaver = new TuringMachine(\"a\", '0', \"halt\").WithTransitions(\n            (\"a\", '0', '1', Right, \"b\"),\n            (\"a\", '1', '1', Left,  \"c\"),\n            (\"b\", '0', '1', Left,  \"a\"),\n            (\"b\", '1', '1', Right, \"b\"),\n            (\"c\", '0', '1', Left,  \"b\"),\n            (\"c\", '1', '1', Stay,  \"halt\")\n        );\n        foreach (var _ in threeStateBusyBeaver.Run()) PrintLine(threeStateBusyBeaver);\n        PrintResults(threeStateBusyBeaver);\n\n        var sorter = new TuringMachine(\"A\", '*', \"X\").WithTransitions(\n            (\"A\", 'a', 'a', Right, \"A\"),\n            (\"A\", 'b', 'B', Right, \"B\"),\n            (\"A\", '*', '*', Left,  \"E\"),\n            (\"B\", 'a', 'a', Right, \"B\"),\n            (\"B\", 'b', 'b', Right, \"B\"),\n            (\"B\", '*', '*', Left,  \"C\"),\n            (\"C\", 'a', 'b', Left,  \"D\"),\n            (\"C\", 'b', 'b', Left,  \"C\"),\n            (\"C\", 'B', 'b', Left,  \"E\"),\n            (\"D\", 'a', 'a', Left,  \"D\"),\n            (\"D\", 'b', 'b', Left,  \"D\"),\n            (\"D\", 'B', 'a', Right, \"A\"),\n            (\"E\", 'a', 'a', Left,  \"E\"),\n            (\"E\", '*', '*', Right, \"X\")\n        )\n        .WithInput(\"babbababaa\");\n        sorter.Run().Last();\n        Console.WriteLine(\"Sorted: \" + sorter.TapeString);\n        PrintResults(sorter);\n\n        sorter.Reset().WithInput(\"bbbababaaabba\");\n        sorter.Run().Last();\n        Console.WriteLine(\"Sorted: \" + sorter.TapeString);\n        PrintResults(sorter);\n\n        Console.WriteLine(await busyBeaverTask);\n        PrintResults(fiveStateBusyBeaver);\n\n        void PrintLine(TuringMachine tm) => Console.WriteLine(tm.TapeString + \"\\tState \" + tm.State);\n\n        void PrintResults(TuringMachine tm) {\n            Console.WriteLine($\"End state: {tm.State} = {(tm.Success\u00a0? \"Success\"\u00a0: \"Failure\")}\");\n            Console.WriteLine(tm.Steps + \" steps\");\n            Console.WriteLine(\"tape length: \" + tm.TapeLength);\n            Console.WriteLine();\n        }\n    }\n\n    public const int Left = -1, Stay = 0, Right = 1;\n    private readonly Tape tape;\n    private readonly string initialState;\n    private readonly HashSet<string> terminatingStates;\n    private Dictionary<(string state, char read), (char write, int move, string toState)> transitions;\n\n    public TuringMachine(string initialState, char blankSymbol, params string[] terminatingStates) {\n        State = this.initialState = initialState;\n        tape = new Tape(blankSymbol);\n        this.terminatingStates = terminatingStates.ToHashSet();\n    }\n\n    public TuringMachine WithTransitions(\n        params (string state, char read, char write, int move, string toState)[] transitions)\n    {\n        this.transitions = transitions.ToDictionary(k => (k.state, k.read), k => (k.write, k.move, k.toState));\n        return this;\n    }\n\n    public TuringMachine Reset() {\n        State = initialState;\n        Steps = 0;\n        tape.Reset();\n        return this;\n    }\n\n    public TuringMachine WithInput(string input) {\n        tape.Input(input);\n        return this;\n    }\n\n    public int Steps { get; private set; }\n    public string State { get; private set; }\n    public bool Success => terminatingStates.Contains(State);\n    public int TapeLength => tape.Length;\n    public string TapeString => tape.ToString();\n\n    public IEnumerable<string> Run() {\n        yield return State;\n        while (Step()) yield return State;\n    }\n\n    public async Task<TimeSpan> TimeAsync(CancellationToken cancel = default) {\n        var chrono = Stopwatch.StartNew();\n        await RunAsync(cancel);\n        chrono.Stop();\n        return chrono.Elapsed;\n    }\n\n    public Task RunAsync(CancellationToken cancel = default)\n        => Task.Run(() => {\n            while (Step()) cancel.ThrowIfCancellationRequested();\n        });\n\n    private bool Step() {\n        if (!transitions.TryGetValue((State, tape.Current), out var action)) return false;\n        tape.Current = action.write;\n        tape.Move(action.move);\n        State = action.toState;\n        Steps++;\n        return true;\n    }\n\n\n    private class Tape\n    {\n        private List<char> forwardTape = new List<char>(), backwardTape = new List<char>();\n        private int head = 0;\n        private char blank;\n\n        public Tape(char blankSymbol) => forwardTape.Add(blank = blankSymbol);\n\n        public void Reset() {\n            backwardTape.Clear();\n            forwardTape.Clear();\n            head = 0;\n            forwardTape.Add(blank);\n        }\n\n        public void Input(string input) {\n            Reset();\n            forwardTape.Clear();\n            forwardTape.AddRange(input);\n        }\n\n        public void Move(int direction) {\n            head += direction;\n            if (head >= 0 && forwardTape.Count <= head) forwardTape.Add(blank);\n            if (head < 0 && backwardTape.Count <= ~head) backwardTape.Add(blank);\n        }\n\n        public char Current {\n            get => head < 0 ? backwardTape[~head] : forwardTape[head];\n            set {\n                if (head < 0) backwardTape[~head] = value;\n                else forwardTape[head] = value;\n            }\n        }\n\n        public int Length => backwardTape.Count + forwardTape.Count;\n\n        public override string ToString() {\n            int h = (head < 0 ? ~head : backwardTape.Count + head) * 2 + 1;\n            var builder = new StringBuilder(\" \", Length * 2 + 1);\n            if (backwardTape.Count > 0) {\n                builder.Append(string.Join(\" \", backwardTape)).Append(\" \");\n                if (head < 0) (builder[h + 1], builder[h - 1]) = ('(', ')');\n                for (int l = 0, r = builder.Length - 1; l < r; l++, r--) (builder[l], builder[r]) = (builder[r], builder[l]);\n            }\n            builder.Append(string.Join(\" \", forwardTape)).Append(\" \");\n            if (head >= 0) (builder[h - 1], builder[h + 1]) = ('(', ')');\n            return builder.ToString();\n        }\n\n    }\n\n}\n"}
{"id": 146737, "name": "Universal Turing machine", "source": "Translate Ruby to Java: class Turing\n    class Tape\n        def initialize(symbols, blank, starting_tape)\n            @symbols = symbols\n            @blank = blank\n            @tape = starting_tape\n            @index = 0\n        end\n        def read\n            retval = @tape[@index]\n            unless retval\n                retval = @tape[@index] = @blank\n            end\n            raise \"invalid symbol '\n            return retval\n        end\n        def write(symbol)\n            @tape[@index] = symbol\n        end\n        def right\n            @index += 1\n        end\n        def left\n            if @index == 0\n              @tape.unshift @blank\n            else\n              @index -= 1\n            end\n        end\n        def stay\n            \n        end\n        def get_tape\n            return @tape\n        end\n    end\n\n    def initialize(symbols, blank,\n                   initial_state, halt_states, running_states,\n                   rules, starting_tape = [])\n        @tape = Tape.new(symbols, blank, starting_tape)\n        @initial_state = initial_state\n        @halt_states = halt_states\n        @running_states = running_states\n        @rules = rules\n        @halted = false\n    end\n    def run\n        raise \"machine already halted\" if @halted\n        state = @initial_state\n        while (true)\n            break if @halt_states.member? state\n            raise \"unknown state '\n            symbol = @tape.read\n            outsym, action, state = @rules[state][symbol]\n            @tape.write outsym\n            @tape.send action\n        end\n        @halted = true\n        return @tape.get_tape\n    end\nend\n", "target": "import java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.LinkedList;\nimport java.util.ListIterator;\nimport java.util.List;\nimport java.util.Set;\nimport java.util.Map;\n\npublic class UTM {\n    private List<String> tape;\n    private String blankSymbol;\n    private ListIterator<String> head;\n    private Map<StateTapeSymbolPair, Transition> transitions = new HashMap<StateTapeSymbolPair, Transition>();\n    private Set<String> terminalStates;\n    private String initialState;\n    \n    public UTM(Set<Transition> transitions, Set<String> terminalStates, String initialState, String blankSymbol) {\n        this.blankSymbol = blankSymbol;\n        for (Transition t : transitions) {\n            this.transitions.put(t.from, t);\n        }\n        this.terminalStates = terminalStates;\n        this.initialState = initialState;\n    }\n    \n    public static class StateTapeSymbolPair {\n        private String state;\n        private String tapeSymbol;\n\n        public StateTapeSymbolPair(String state, String tapeSymbol) {\n            this.state = state;\n            this.tapeSymbol = tapeSymbol;\n        }\n\n        \n        @Override\n        public int hashCode() {\n            final int prime = 31;\n            int result = 1;\n            result = prime * result\n                    + ((state == null) ? 0 : state.hashCode());\n            result = prime\n                    * result\n                    + ((tapeSymbol == null) ? 0 : tapeSymbol\n                            .hashCode());\n            return result;\n        }\n\n        \n        @Override\n        public boolean equals(Object obj) {\n            if (this == obj)\n                return true;\n            if (obj == null)\n                return false;\n            if (getClass() != obj.getClass())\n                return false;\n            StateTapeSymbolPair other = (StateTapeSymbolPair) obj;\n            if (state == null) {\n                if (other.state != null)\n                    return false;\n            } else if (!state.equals(other.state))\n                return false;\n            if (tapeSymbol == null) {\n                if (other.tapeSymbol != null)\n                    return false;\n            } else if (!tapeSymbol.equals(other.tapeSymbol))\n                return false;\n            return true;\n        }\n\n        @Override\n        public String toString() {\n            return \"(\" + state + \",\" + tapeSymbol + \")\";\n        }\n    }\n    \n    public static class Transition {\n        private StateTapeSymbolPair from;\n        private StateTapeSymbolPair to;\n        private int direction; \n\n        public Transition(StateTapeSymbolPair from, StateTapeSymbolPair to, int direction) {\n             this.from = from;\n            this.to = to;\n            this.direction = direction;\n        }\n\n        @Override\n        public String toString() {\n            return from + \"=>\" + to + \"/\" + direction;\n        }\n    }\n    \n    public void initializeTape(List<String> input) { \n        tape = input;\n    }\n    \n    public void initializeTape(String input) { \n        tape = new LinkedList<String>();\n        for (int i = 0; i < input.length(); i++) {\n            tape.add(input.charAt(i) + \"\");\n        }\n    }\n    \n    public List<String> runTM() { \n        if (tape.size() == 0) {\n            tape.add(blankSymbol);\n        }\n        \n        head = tape.listIterator();\n        head.next();\n        head.previous();\n        \n        StateTapeSymbolPair tsp = new StateTapeSymbolPair(initialState, tape.get(0));\n        \n        while (transitions.containsKey(tsp)) { \n            System.out.println(this + \" --- \" + transitions.get(tsp));\n            Transition trans = transitions.get(tsp);\n            head.set(trans.to.tapeSymbol); \n            tsp.state = trans.to.state; \n            if (trans.direction == -1) { \n                if (!head.hasPrevious()) {\n                    head.add(blankSymbol); \n                }\n                tsp.tapeSymbol = head.previous(); \n            } else if (trans.direction == 1) { \n                head.next();\n                if (!head.hasNext()) {\n                    head.add(blankSymbol); \n                    head.previous();\n                }\n                tsp.tapeSymbol = head.next(); \n                head.previous();\n            } else {\n                tsp.tapeSymbol = trans.to.tapeSymbol;\n            }\n        }\n        \n        System.out.println(this + \" --- \" + tsp);\n        \n        if (terminalStates.contains(tsp.state)) {\n            return tape;\n        } else {\n            return null;\n        }\n    }\n\n    @Override\n    public String toString() {\n        try {\n        \tint headPos = head.previousIndex();\n            String s = \"[ \";\n            \n            for (int i = 0; i <= headPos; i++) {\n                s += tape.get(i) + \" \";\n            }\n\n            s += \"[H] \";\n            \n            for (int i = headPos + 1; i < tape.size(); i++) {\n                s += tape.get(i) + \" \";\n            }\n\n            return s + \"]\";\n        } catch (Exception e) {\n            return \"\";\n        }\n    }\n    \n    public static void main(String[] args) {\n        \n        String init = \"q0\";\n        String blank = \"b\";\n        \n        Set<String> term = new HashSet<String>();\n        term.add(\"qf\");\n        \n        Set<Transition> trans = new HashSet<Transition>();\n        \n        trans.add(new Transition(new StateTapeSymbolPair(\"q0\", \"1\"), new StateTapeSymbolPair(\"q0\", \"1\"), 1));\n        trans.add(new Transition(new StateTapeSymbolPair(\"q0\", \"b\"), new StateTapeSymbolPair(\"qf\", \"1\"), 0));\n        \n        UTM machine = new UTM(trans, term, init, blank);\n        machine.initializeTape(\"111\");\n        System.out.println(\"Output (si): \" + machine.runTM() + \"\\n\");\n        \n        \n        init = \"a\";\n        \n        term.clear();\n        term.add(\"halt\");\n        \n        blank = \"0\";\n        \n        trans.clear();\n\n        \n        trans.add(new Transition(new StateTapeSymbolPair(\"a\", \"0\"), new StateTapeSymbolPair(\"b\", \"1\"), 1));\n        trans.add(new Transition(new StateTapeSymbolPair(\"a\", \"1\"), new StateTapeSymbolPair(\"c\", \"1\"), -1));\n        trans.add(new Transition(new StateTapeSymbolPair(\"b\", \"0\"), new StateTapeSymbolPair(\"a\", \"1\"), -1));\n        trans.add(new Transition(new StateTapeSymbolPair(\"b\", \"1\"), new StateTapeSymbolPair(\"b\", \"1\"), 1));\n        trans.add(new Transition(new StateTapeSymbolPair(\"c\", \"0\"), new StateTapeSymbolPair(\"b\", \"1\"), -1));\n        trans.add(new Transition(new StateTapeSymbolPair(\"c\", \"1\"), new StateTapeSymbolPair(\"halt\", \"1\"), 0));\n        \n        machine = new UTM(trans, term, init, blank);\n        machine.initializeTape(\"\");\n        System.out.println(\"Output (bb): \" + machine.runTM());\n\n        \n        init = \"s0\";\n        blank = \"*\";\n        \n        term = new HashSet<String>();\n        term.add(\"see\");\n        \n        trans = new HashSet<Transition>();\n        \n        trans.add(new Transition(new StateTapeSymbolPair(\"s0\", \"a\"), new StateTapeSymbolPair(\"s0\", \"a\"), 1));\n        trans.add(new Transition(new StateTapeSymbolPair(\"s0\", \"b\"), new StateTapeSymbolPair(\"s1\", \"B\"), 1));\n        trans.add(new Transition(new StateTapeSymbolPair(\"s0\", \"*\"), new StateTapeSymbolPair(\"se\", \"*\"), -1));\n        trans.add(new Transition(new StateTapeSymbolPair(\"s1\", \"a\"), new StateTapeSymbolPair(\"s1\", \"a\"), 1));\n        trans.add(new Transition(new StateTapeSymbolPair(\"s1\", \"b\"), new StateTapeSymbolPair(\"s1\", \"b\"), 1));\n        trans.add(new Transition(new StateTapeSymbolPair(\"s1\", \"*\"), new StateTapeSymbolPair(\"s2\", \"*\"), -1));\n        trans.add(new Transition(new StateTapeSymbolPair(\"s2\", \"a\"), new StateTapeSymbolPair(\"s3\", \"b\"), -1));\n        trans.add(new Transition(new StateTapeSymbolPair(\"s2\", \"b\"), new StateTapeSymbolPair(\"s2\", \"b\"), -1));\n        trans.add(new Transition(new StateTapeSymbolPair(\"s2\", \"B\"), new StateTapeSymbolPair(\"se\", \"b\"), -1));\n        trans.add(new Transition(new StateTapeSymbolPair(\"s3\", \"a\"), new StateTapeSymbolPair(\"s3\", \"a\"), -1));\n        trans.add(new Transition(new StateTapeSymbolPair(\"s3\", \"b\"), new StateTapeSymbolPair(\"s3\", \"b\"), -1));\n        trans.add(new Transition(new StateTapeSymbolPair(\"s3\", \"B\"), new StateTapeSymbolPair(\"s0\", \"a\"), 1));\n        trans.add(new Transition(new StateTapeSymbolPair(\"se\", \"a\"), new StateTapeSymbolPair(\"se\", \"a\"), -1));\n        trans.add(new Transition(new StateTapeSymbolPair(\"se\", \"*\"), new StateTapeSymbolPair(\"see\", \"*\"), 1));\n\n        machine = new UTM(trans, term, init, blank);\n        machine.initializeTape(\"babbababaa\");\n        System.out.println(\"Output (sort): \" + machine.runTM() + \"\\n\");\n    }\n}\n"}
{"id": 146738, "name": "Universal Turing machine", "source": "Translate Ruby to Java: class Turing\n    class Tape\n        def initialize(symbols, blank, starting_tape)\n            @symbols = symbols\n            @blank = blank\n            @tape = starting_tape\n            @index = 0\n        end\n        def read\n            retval = @tape[@index]\n            unless retval\n                retval = @tape[@index] = @blank\n            end\n            raise \"invalid symbol '\n            return retval\n        end\n        def write(symbol)\n            @tape[@index] = symbol\n        end\n        def right\n            @index += 1\n        end\n        def left\n            if @index == 0\n              @tape.unshift @blank\n            else\n              @index -= 1\n            end\n        end\n        def stay\n            \n        end\n        def get_tape\n            return @tape\n        end\n    end\n\n    def initialize(symbols, blank,\n                   initial_state, halt_states, running_states,\n                   rules, starting_tape = [])\n        @tape = Tape.new(symbols, blank, starting_tape)\n        @initial_state = initial_state\n        @halt_states = halt_states\n        @running_states = running_states\n        @rules = rules\n        @halted = false\n    end\n    def run\n        raise \"machine already halted\" if @halted\n        state = @initial_state\n        while (true)\n            break if @halt_states.member? state\n            raise \"unknown state '\n            symbol = @tape.read\n            outsym, action, state = @rules[state][symbol]\n            @tape.write outsym\n            @tape.send action\n        end\n        @halted = true\n        return @tape.get_tape\n    end\nend\n", "target": "import java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.LinkedList;\nimport java.util.ListIterator;\nimport java.util.List;\nimport java.util.Set;\nimport java.util.Map;\n\npublic class UTM {\n    private List<String> tape;\n    private String blankSymbol;\n    private ListIterator<String> head;\n    private Map<StateTapeSymbolPair, Transition> transitions = new HashMap<StateTapeSymbolPair, Transition>();\n    private Set<String> terminalStates;\n    private String initialState;\n    \n    public UTM(Set<Transition> transitions, Set<String> terminalStates, String initialState, String blankSymbol) {\n        this.blankSymbol = blankSymbol;\n        for (Transition t : transitions) {\n            this.transitions.put(t.from, t);\n        }\n        this.terminalStates = terminalStates;\n        this.initialState = initialState;\n    }\n    \n    public static class StateTapeSymbolPair {\n        private String state;\n        private String tapeSymbol;\n\n        public StateTapeSymbolPair(String state, String tapeSymbol) {\n            this.state = state;\n            this.tapeSymbol = tapeSymbol;\n        }\n\n        \n        @Override\n        public int hashCode() {\n            final int prime = 31;\n            int result = 1;\n            result = prime * result\n                    + ((state == null) ? 0 : state.hashCode());\n            result = prime\n                    * result\n                    + ((tapeSymbol == null) ? 0 : tapeSymbol\n                            .hashCode());\n            return result;\n        }\n\n        \n        @Override\n        public boolean equals(Object obj) {\n            if (this == obj)\n                return true;\n            if (obj == null)\n                return false;\n            if (getClass() != obj.getClass())\n                return false;\n            StateTapeSymbolPair other = (StateTapeSymbolPair) obj;\n            if (state == null) {\n                if (other.state != null)\n                    return false;\n            } else if (!state.equals(other.state))\n                return false;\n            if (tapeSymbol == null) {\n                if (other.tapeSymbol != null)\n                    return false;\n            } else if (!tapeSymbol.equals(other.tapeSymbol))\n                return false;\n            return true;\n        }\n\n        @Override\n        public String toString() {\n            return \"(\" + state + \",\" + tapeSymbol + \")\";\n        }\n    }\n    \n    public static class Transition {\n        private StateTapeSymbolPair from;\n        private StateTapeSymbolPair to;\n        private int direction; \n\n        public Transition(StateTapeSymbolPair from, StateTapeSymbolPair to, int direction) {\n             this.from = from;\n            this.to = to;\n            this.direction = direction;\n        }\n\n        @Override\n        public String toString() {\n            return from + \"=>\" + to + \"/\" + direction;\n        }\n    }\n    \n    public void initializeTape(List<String> input) { \n        tape = input;\n    }\n    \n    public void initializeTape(String input) { \n        tape = new LinkedList<String>();\n        for (int i = 0; i < input.length(); i++) {\n            tape.add(input.charAt(i) + \"\");\n        }\n    }\n    \n    public List<String> runTM() { \n        if (tape.size() == 0) {\n            tape.add(blankSymbol);\n        }\n        \n        head = tape.listIterator();\n        head.next();\n        head.previous();\n        \n        StateTapeSymbolPair tsp = new StateTapeSymbolPair(initialState, tape.get(0));\n        \n        while (transitions.containsKey(tsp)) { \n            System.out.println(this + \" --- \" + transitions.get(tsp));\n            Transition trans = transitions.get(tsp);\n            head.set(trans.to.tapeSymbol); \n            tsp.state = trans.to.state; \n            if (trans.direction == -1) { \n                if (!head.hasPrevious()) {\n                    head.add(blankSymbol); \n                }\n                tsp.tapeSymbol = head.previous(); \n            } else if (trans.direction == 1) { \n                head.next();\n                if (!head.hasNext()) {\n                    head.add(blankSymbol); \n                    head.previous();\n                }\n                tsp.tapeSymbol = head.next(); \n                head.previous();\n            } else {\n                tsp.tapeSymbol = trans.to.tapeSymbol;\n            }\n        }\n        \n        System.out.println(this + \" --- \" + tsp);\n        \n        if (terminalStates.contains(tsp.state)) {\n            return tape;\n        } else {\n            return null;\n        }\n    }\n\n    @Override\n    public String toString() {\n        try {\n        \tint headPos = head.previousIndex();\n            String s = \"[ \";\n            \n            for (int i = 0; i <= headPos; i++) {\n                s += tape.get(i) + \" \";\n            }\n\n            s += \"[H] \";\n            \n            for (int i = headPos + 1; i < tape.size(); i++) {\n                s += tape.get(i) + \" \";\n            }\n\n            return s + \"]\";\n        } catch (Exception e) {\n            return \"\";\n        }\n    }\n    \n    public static void main(String[] args) {\n        \n        String init = \"q0\";\n        String blank = \"b\";\n        \n        Set<String> term = new HashSet<String>();\n        term.add(\"qf\");\n        \n        Set<Transition> trans = new HashSet<Transition>();\n        \n        trans.add(new Transition(new StateTapeSymbolPair(\"q0\", \"1\"), new StateTapeSymbolPair(\"q0\", \"1\"), 1));\n        trans.add(new Transition(new StateTapeSymbolPair(\"q0\", \"b\"), new StateTapeSymbolPair(\"qf\", \"1\"), 0));\n        \n        UTM machine = new UTM(trans, term, init, blank);\n        machine.initializeTape(\"111\");\n        System.out.println(\"Output (si): \" + machine.runTM() + \"\\n\");\n        \n        \n        init = \"a\";\n        \n        term.clear();\n        term.add(\"halt\");\n        \n        blank = \"0\";\n        \n        trans.clear();\n\n        \n        trans.add(new Transition(new StateTapeSymbolPair(\"a\", \"0\"), new StateTapeSymbolPair(\"b\", \"1\"), 1));\n        trans.add(new Transition(new StateTapeSymbolPair(\"a\", \"1\"), new StateTapeSymbolPair(\"c\", \"1\"), -1));\n        trans.add(new Transition(new StateTapeSymbolPair(\"b\", \"0\"), new StateTapeSymbolPair(\"a\", \"1\"), -1));\n        trans.add(new Transition(new StateTapeSymbolPair(\"b\", \"1\"), new StateTapeSymbolPair(\"b\", \"1\"), 1));\n        trans.add(new Transition(new StateTapeSymbolPair(\"c\", \"0\"), new StateTapeSymbolPair(\"b\", \"1\"), -1));\n        trans.add(new Transition(new StateTapeSymbolPair(\"c\", \"1\"), new StateTapeSymbolPair(\"halt\", \"1\"), 0));\n        \n        machine = new UTM(trans, term, init, blank);\n        machine.initializeTape(\"\");\n        System.out.println(\"Output (bb): \" + machine.runTM());\n\n        \n        init = \"s0\";\n        blank = \"*\";\n        \n        term = new HashSet<String>();\n        term.add(\"see\");\n        \n        trans = new HashSet<Transition>();\n        \n        trans.add(new Transition(new StateTapeSymbolPair(\"s0\", \"a\"), new StateTapeSymbolPair(\"s0\", \"a\"), 1));\n        trans.add(new Transition(new StateTapeSymbolPair(\"s0\", \"b\"), new StateTapeSymbolPair(\"s1\", \"B\"), 1));\n        trans.add(new Transition(new StateTapeSymbolPair(\"s0\", \"*\"), new StateTapeSymbolPair(\"se\", \"*\"), -1));\n        trans.add(new Transition(new StateTapeSymbolPair(\"s1\", \"a\"), new StateTapeSymbolPair(\"s1\", \"a\"), 1));\n        trans.add(new Transition(new StateTapeSymbolPair(\"s1\", \"b\"), new StateTapeSymbolPair(\"s1\", \"b\"), 1));\n        trans.add(new Transition(new StateTapeSymbolPair(\"s1\", \"*\"), new StateTapeSymbolPair(\"s2\", \"*\"), -1));\n        trans.add(new Transition(new StateTapeSymbolPair(\"s2\", \"a\"), new StateTapeSymbolPair(\"s3\", \"b\"), -1));\n        trans.add(new Transition(new StateTapeSymbolPair(\"s2\", \"b\"), new StateTapeSymbolPair(\"s2\", \"b\"), -1));\n        trans.add(new Transition(new StateTapeSymbolPair(\"s2\", \"B\"), new StateTapeSymbolPair(\"se\", \"b\"), -1));\n        trans.add(new Transition(new StateTapeSymbolPair(\"s3\", \"a\"), new StateTapeSymbolPair(\"s3\", \"a\"), -1));\n        trans.add(new Transition(new StateTapeSymbolPair(\"s3\", \"b\"), new StateTapeSymbolPair(\"s3\", \"b\"), -1));\n        trans.add(new Transition(new StateTapeSymbolPair(\"s3\", \"B\"), new StateTapeSymbolPair(\"s0\", \"a\"), 1));\n        trans.add(new Transition(new StateTapeSymbolPair(\"se\", \"a\"), new StateTapeSymbolPair(\"se\", \"a\"), -1));\n        trans.add(new Transition(new StateTapeSymbolPair(\"se\", \"*\"), new StateTapeSymbolPair(\"see\", \"*\"), 1));\n\n        machine = new UTM(trans, term, init, blank);\n        machine.initializeTape(\"babbababaa\");\n        System.out.println(\"Output (sort): \" + machine.runTM() + \"\\n\");\n    }\n}\n"}
{"id": 146739, "name": "Universal Turing machine", "source": "Translate Ruby to Python: class Turing\n    class Tape\n        def initialize(symbols, blank, starting_tape)\n            @symbols = symbols\n            @blank = blank\n            @tape = starting_tape\n            @index = 0\n        end\n        def read\n            retval = @tape[@index]\n            unless retval\n                retval = @tape[@index] = @blank\n            end\n            raise \"invalid symbol '\n            return retval\n        end\n        def write(symbol)\n            @tape[@index] = symbol\n        end\n        def right\n            @index += 1\n        end\n        def left\n            if @index == 0\n              @tape.unshift @blank\n            else\n              @index -= 1\n            end\n        end\n        def stay\n            \n        end\n        def get_tape\n            return @tape\n        end\n    end\n\n    def initialize(symbols, blank,\n                   initial_state, halt_states, running_states,\n                   rules, starting_tape = [])\n        @tape = Tape.new(symbols, blank, starting_tape)\n        @initial_state = initial_state\n        @halt_states = halt_states\n        @running_states = running_states\n        @rules = rules\n        @halted = false\n    end\n    def run\n        raise \"machine already halted\" if @halted\n        state = @initial_state\n        while (true)\n            break if @halt_states.member? state\n            raise \"unknown state '\n            symbol = @tape.read\n            outsym, action, state = @rules[state][symbol]\n            @tape.write outsym\n            @tape.send action\n        end\n        @halted = true\n        return @tape.get_tape\n    end\nend\n", "target": "from __future__ import print_function\n\ndef run_utm(\n        state = None,\n        blank = None,\n        rules = [],\n        tape = [],\n        halt = None,\n        pos = 0):\n    st = state\n    if not tape: tape = [blank]\n    if pos < 0: pos += len(tape)\n    if pos >= len(tape) or pos < 0: raise Error( \"bad init position\")\n    rules = dict(((s0, v0), (v1, dr, s1)) for (s0, v0, v1, dr, s1) in rules)\n\n    while True:\n        print(st, '\\t', end=\" \")\n        for i, v in enumerate(tape):\n            if i == pos: print(\"[%s]\" % (v,), end=\" \")\n            else: print(v, end=\" \")\n        print()\n\n        if st == halt: break\n        if (st, tape[pos]) not in rules: break\n\n        (v1, dr, s1) = rules[(st, tape[pos])]\n        tape[pos] = v1\n        if dr == 'left':\n            if pos > 0: pos -= 1\n            else: tape.insert(0, blank)\n        if dr == 'right':\n            pos += 1\n            if pos >= len(tape): tape.append(blank) \n        st = s1\n    \n\n\n            \nprint(\"incr machine\\n\")\nrun_utm(\n    halt = 'qf',\n\tstate = 'q0',\n\ttape = list(\"111\"),\n\tblank = 'B',\n\trules = map(tuple, \n               [\"q0 1 1 right q0\".split(),\n\t\t        \"q0 B 1 stay  qf\".split()]\n        )\n    )\n\nprint(\"\\nbusy beaver\\n\")\nrun_utm(\n    halt = 'halt',\n\tstate = 'a',\n\tblank = '0',\n\trules = map(tuple,\n        [\"a 0 1 right b\".split(),\n         \"a 1 1 left  c\".split(),\n         \"b 0 1 left  a\".split(),\n         \"b 1 1 right b\".split(),\n         \"c 0 1 left  b\".split(),\n         \"c 1 1 stay  halt\".split()]\n        )\n    )\n\nprint(\"\\nsorting test\\n\")\nrun_utm(halt = 'STOP',\n\tstate = 'A',\n\tblank = '0',\n\ttape = \"2 2 2 1 2 2 1 2 1 2 1 2 1 2\".split(),\n\trules = map(tuple,\n       [\"A 1 1 right A\".split(),\n\t\t\"A 2 3 right B\".split(),\n\t\t\"A 0 0 left  E\".split(),\n\t\t\"B 1 1 right B\".split(),\n\t\t\"B 2 2 right B\".split(),\n\t\t\"B 0 0 left  C\".split(),\n\t\t\"C 1 2 left  D\".split(),\n\t\t\"C 2 2 left  C\".split(),\n\t\t\"C 3 2 left  E\".split(),\n\t\t\"D 1 1 left  D\".split(),\n\t\t\"D 2 2 left  D\".split(),\n\t\t\"D 3 1 right A\".split(),\n\t\t\"E 1 1 left  E\".split(),\n\t\t\"E 0 0 right STOP\".split()]\n        )\n    )\n"}
{"id": 146740, "name": "Universal Turing machine", "source": "Translate Ruby to Python: class Turing\n    class Tape\n        def initialize(symbols, blank, starting_tape)\n            @symbols = symbols\n            @blank = blank\n            @tape = starting_tape\n            @index = 0\n        end\n        def read\n            retval = @tape[@index]\n            unless retval\n                retval = @tape[@index] = @blank\n            end\n            raise \"invalid symbol '\n            return retval\n        end\n        def write(symbol)\n            @tape[@index] = symbol\n        end\n        def right\n            @index += 1\n        end\n        def left\n            if @index == 0\n              @tape.unshift @blank\n            else\n              @index -= 1\n            end\n        end\n        def stay\n            \n        end\n        def get_tape\n            return @tape\n        end\n    end\n\n    def initialize(symbols, blank,\n                   initial_state, halt_states, running_states,\n                   rules, starting_tape = [])\n        @tape = Tape.new(symbols, blank, starting_tape)\n        @initial_state = initial_state\n        @halt_states = halt_states\n        @running_states = running_states\n        @rules = rules\n        @halted = false\n    end\n    def run\n        raise \"machine already halted\" if @halted\n        state = @initial_state\n        while (true)\n            break if @halt_states.member? state\n            raise \"unknown state '\n            symbol = @tape.read\n            outsym, action, state = @rules[state][symbol]\n            @tape.write outsym\n            @tape.send action\n        end\n        @halted = true\n        return @tape.get_tape\n    end\nend\n", "target": "from __future__ import print_function\n\ndef run_utm(\n        state = None,\n        blank = None,\n        rules = [],\n        tape = [],\n        halt = None,\n        pos = 0):\n    st = state\n    if not tape: tape = [blank]\n    if pos < 0: pos += len(tape)\n    if pos >= len(tape) or pos < 0: raise Error( \"bad init position\")\n    rules = dict(((s0, v0), (v1, dr, s1)) for (s0, v0, v1, dr, s1) in rules)\n\n    while True:\n        print(st, '\\t', end=\" \")\n        for i, v in enumerate(tape):\n            if i == pos: print(\"[%s]\" % (v,), end=\" \")\n            else: print(v, end=\" \")\n        print()\n\n        if st == halt: break\n        if (st, tape[pos]) not in rules: break\n\n        (v1, dr, s1) = rules[(st, tape[pos])]\n        tape[pos] = v1\n        if dr == 'left':\n            if pos > 0: pos -= 1\n            else: tape.insert(0, blank)\n        if dr == 'right':\n            pos += 1\n            if pos >= len(tape): tape.append(blank) \n        st = s1\n    \n\n\n            \nprint(\"incr machine\\n\")\nrun_utm(\n    halt = 'qf',\n\tstate = 'q0',\n\ttape = list(\"111\"),\n\tblank = 'B',\n\trules = map(tuple, \n               [\"q0 1 1 right q0\".split(),\n\t\t        \"q0 B 1 stay  qf\".split()]\n        )\n    )\n\nprint(\"\\nbusy beaver\\n\")\nrun_utm(\n    halt = 'halt',\n\tstate = 'a',\n\tblank = '0',\n\trules = map(tuple,\n        [\"a 0 1 right b\".split(),\n         \"a 1 1 left  c\".split(),\n         \"b 0 1 left  a\".split(),\n         \"b 1 1 right b\".split(),\n         \"c 0 1 left  b\".split(),\n         \"c 1 1 stay  halt\".split()]\n        )\n    )\n\nprint(\"\\nsorting test\\n\")\nrun_utm(halt = 'STOP',\n\tstate = 'A',\n\tblank = '0',\n\ttape = \"2 2 2 1 2 2 1 2 1 2 1 2 1 2\".split(),\n\trules = map(tuple,\n       [\"A 1 1 right A\".split(),\n\t\t\"A 2 3 right B\".split(),\n\t\t\"A 0 0 left  E\".split(),\n\t\t\"B 1 1 right B\".split(),\n\t\t\"B 2 2 right B\".split(),\n\t\t\"B 0 0 left  C\".split(),\n\t\t\"C 1 2 left  D\".split(),\n\t\t\"C 2 2 left  C\".split(),\n\t\t\"C 3 2 left  E\".split(),\n\t\t\"D 1 1 left  D\".split(),\n\t\t\"D 2 2 left  D\".split(),\n\t\t\"D 3 1 right A\".split(),\n\t\t\"E 1 1 left  E\".split(),\n\t\t\"E 0 0 right STOP\".split()]\n        )\n    )\n"}
{"id": 146967, "name": "Number names", "source": "Translate Ruby to C#: SMALL = %w(zero one two three four five six seven eight nine ten\n           eleven twelve thirteen fourteen fifteen sixteen seventeen\n           eighteen nineteen)\n\nTENS = %w(wrong wrong twenty thirty forty fifty sixty seventy\n          eighty ninety)\n\nBIG = [nil, \"thousand\"] +\n      %w( m b tr quadr quint sext sept oct non dec).map{ |p| \"\n\ndef wordify number\n  case\n  when number < 0\n    \"negative \n    \n  when number < 20\n    SMALL[number]\n    \n  when number < 100\n    div, mod = number.divmod(10)\n    TENS[div] + (mod==0 ? \"\" : \"-\n    \n  when number < 1000\n    div, mod = number.divmod(100)\n    \"\n    \n  else\n    \n    chunks = []\n    div = number\n    while div != 0\n      div, mod = div.divmod(1000)\n      chunks << mod                 \n    end\n    \n    raise ArgumentError, \"Integer value too large.\" if chunks.size > BIG.size\n    \n    chunks.map{ |c| wordify c }.\n           zip(BIG).    \n           find_all { |c| c[0] != 'zero' }.\n           map{ |c| c.join ' '}.    \n           reverse.\n           join(', ').              \n           strip\n  end\nend\n\ndata = [-1123, 0, 1, 20, 123, 200, 220, 1245, 2000, 2200, 2220, 467889,\n        23_000_467, 23_234_467, 2_235_654_234, 12_123_234_543_543_456,\n        987_654_321_098_765_432_109_876_543_210_987_654,\n        123890812938219038290489327894327894723897432]\n\ndata.each do |n|\n  print \"\n  begin\n    puts \"'\n  rescue => e\n    puts \"Error: \n  end\nend\n", "target": "using System;\n\nclass NumberNamer {\n    static readonly string[] incrementsOfOne =\n            { \"zero\",    \"one\",     \"two\",       \"three\",    \"four\",\n              \"five\",    \"six\",     \"seven\",     \"eight\",    \"nine\",\n              \"ten\",     \"eleven\",  \"twelve\",    \"thirteen\", \"fourteen\",\n              \"fifteen\", \"sixteen\", \"seventeen\", \"eighteen\", \"nineteen\" };\n\n    static readonly string[] incrementsOfTen =\n            { \"\",      \"\",      \"twenty\",  \"thirty\", \"fourty\",\n              \"fifty\", \"sixty\", \"seventy\", \"eighty\", \"ninety\" };\n\n    const string millionName = \"million\",\n                 thousandName = \"thousand\",\n                 hundredName = \"hundred\",\n                 andName = \"and\";\n\n\n    public static string GetName( int i ) {\n        string output = \"\";\n        if( i >= 1000000 ) {\n            output += ParseTriplet( i / 1000000 ) + \" \" + millionName;\n            i %= 1000000;\n            if( i == 0 ) return output;\n        }\n\n        if( i >= 1000 ) {\n            if( output.Length > 0 ) {\n                output += \", \";\n            }\n            output += ParseTriplet( i / 1000 ) + \" \" + thousandName;\n            i %= 1000;\n            if( i == 0 ) return output;\n        }\n\n        if( output.Length > 0 ) {\n            output += \", \";\n        }\n        output += ParseTriplet( i );\n        return output;\n    }\n\n\n    static string ParseTriplet( int i ) {\n        string output = \"\";\n        if( i >= 100 ) {\n            output += incrementsOfOne[i / 100] + \" \" + hundredName;\n            i %= 100;\n            if( i == 0 ) return output;\n        }\n\n        if( output.Length > 0 ) {\n            output += \" \" + andName + \" \";\n        }\n        if( i >= 20 ) {\n            output += incrementsOfTen[i / 10];\n            i %= 10;\n            if( i == 0 ) return output;\n        }\n\n        if( output.Length > 0 ) {\n            output += \" \";\n        }\n        output += incrementsOfOne[i];\n        return output;\n    }\n}\n\n\nclass Program { \n    static void Main( string[] args ) {\n        Console.WriteLine( NumberNamer.GetName( 1 ) );\n        Console.WriteLine( NumberNamer.GetName( 234 ) );\n        Console.WriteLine( NumberNamer.GetName( 31337 ) );\n        Console.WriteLine( NumberNamer.GetName( 987654321 ) );\n    }\n}\n"}
{"id": 146969, "name": "Number names", "source": "Translate Ruby to Java: SMALL = %w(zero one two three four five six seven eight nine ten\n           eleven twelve thirteen fourteen fifteen sixteen seventeen\n           eighteen nineteen)\n\nTENS = %w(wrong wrong twenty thirty forty fifty sixty seventy\n          eighty ninety)\n\nBIG = [nil, \"thousand\"] +\n      %w( m b tr quadr quint sext sept oct non dec).map{ |p| \"\n\ndef wordify number\n  case\n  when number < 0\n    \"negative \n    \n  when number < 20\n    SMALL[number]\n    \n  when number < 100\n    div, mod = number.divmod(10)\n    TENS[div] + (mod==0 ? \"\" : \"-\n    \n  when number < 1000\n    div, mod = number.divmod(100)\n    \"\n    \n  else\n    \n    chunks = []\n    div = number\n    while div != 0\n      div, mod = div.divmod(1000)\n      chunks << mod                 \n    end\n    \n    raise ArgumentError, \"Integer value too large.\" if chunks.size > BIG.size\n    \n    chunks.map{ |c| wordify c }.\n           zip(BIG).    \n           find_all { |c| c[0] != 'zero' }.\n           map{ |c| c.join ' '}.    \n           reverse.\n           join(', ').              \n           strip\n  end\nend\n\ndata = [-1123, 0, 1, 20, 123, 200, 220, 1245, 2000, 2200, 2220, 467889,\n        23_000_467, 23_234_467, 2_235_654_234, 12_123_234_543_543_456,\n        987_654_321_098_765_432_109_876_543_210_987_654,\n        123890812938219038290489327894327894723897432]\n\ndata.each do |n|\n  print \"\n  begin\n    puts \"'\n  rescue => e\n    puts \"Error: \n  end\nend\n", "target": "module NumberNames\n    {\n    void run()\n        {\n        @Inject Console console;\n\n        Int[] tests = [0, 1, -1, 11, -17, 42, 99, 100, 101, -111, 1000, 1234, 10000, 100000,\n                       123456789000, 0x123456789ABCDEF];\n        for (Int test : tests)\n            {\n            console.print($\"{test} = {toEnglish(test)}\");\n            }\n        }\n\n    static String[] digits = [\"zero\", \"one\", \"two\", \"three\", \"four\",\n                              \"five\", \"six\", \"seven\", \"eight\", \"nine\"];\n    static String[] teens  = [\"ten\", \"eleven\", \"twelve\", \"thirteen\", \"fourteen\",\n                              \"fifteen\", \"sixteen\", \"seventeen\", \"eighteen\", \"nineteen\"];\n    static String[] tens   = [\"zero\", \"ten\", \"twenty\", \"thirty\", \"forty\",\n                              \"fifty\", \"sixty\", \"seventy\", \"eighty\", \"ninety\"];\n    static String[] ten3rd = [\"?\", \"thousand\", \"million\", \"billion\", \"trillion\",\n                              \"quadrillion\", \"quintillion\"];\n\n    static String toEnglish(Int n)\n        {\n        StringBuffer buf = new StringBuffer();\n        if (n < 0)\n            {\n            \"negative \".appendTo(buf);\n            n = -n;\n            }\n\n        format3digits(n, buf);\n        return buf.toString();\n        }\n\n    static void format3digits(Int n, StringBuffer buf, Int nested=0)\n        {\n        (Int left, Int right) = n /% 1000;\n        if (left != 0)\n            {\n            format3digits(left, buf, nested+1);\n            }\n\n        if (right != 0 || (left == 0 && nested==0))\n            {\n            if (right >= 100)\n                {\n                (left, right) = (right /% 100);\n                digits[left].appendTo(buf);\n                \" hundred \".appendTo(buf);\n                if (right != 0)\n                    {\n                    format2digits(right, buf);\n                    }\n                }\n            else\n                {\n                format2digits(right, buf);\n                }\n\n            if (nested > 0)\n                {\n                ten3rd[nested].appendTo(buf).add(' ');\n                }\n            }\n        }\n\n    static void format2digits(Int n, StringBuffer buf)\n        {\n        switch (n)\n            {\n            case 0..9:\n                digits[n].appendTo(buf).add(' ');\n                break;\n\n            case 10..19:\n                teens[n-10].appendTo(buf).add(' ');\n                break;\n\n            default:\n                (Int left, Int right) = n /% 10;\n                tens[left].appendTo(buf);\n                if (right == 0)\n                    {\n                    buf.add(' ');\n                    }\n                else\n                    {\n                    buf.add('-');\n                    digits[right].appendTo(buf).add(' ');\n                    }\n                break;\n            }\n        }\n    }\n"}
{"id": 146970, "name": "Number names", "source": "Translate Ruby to Python: SMALL = %w(zero one two three four five six seven eight nine ten\n           eleven twelve thirteen fourteen fifteen sixteen seventeen\n           eighteen nineteen)\n\nTENS = %w(wrong wrong twenty thirty forty fifty sixty seventy\n          eighty ninety)\n\nBIG = [nil, \"thousand\"] +\n      %w( m b tr quadr quint sext sept oct non dec).map{ |p| \"\n\ndef wordify number\n  case\n  when number < 0\n    \"negative \n    \n  when number < 20\n    SMALL[number]\n    \n  when number < 100\n    div, mod = number.divmod(10)\n    TENS[div] + (mod==0 ? \"\" : \"-\n    \n  when number < 1000\n    div, mod = number.divmod(100)\n    \"\n    \n  else\n    \n    chunks = []\n    div = number\n    while div != 0\n      div, mod = div.divmod(1000)\n      chunks << mod                 \n    end\n    \n    raise ArgumentError, \"Integer value too large.\" if chunks.size > BIG.size\n    \n    chunks.map{ |c| wordify c }.\n           zip(BIG).    \n           find_all { |c| c[0] != 'zero' }.\n           map{ |c| c.join ' '}.    \n           reverse.\n           join(', ').              \n           strip\n  end\nend\n\ndata = [-1123, 0, 1, 20, 123, 200, 220, 1245, 2000, 2200, 2220, 467889,\n        23_000_467, 23_234_467, 2_235_654_234, 12_123_234_543_543_456,\n        987_654_321_098_765_432_109_876_543_210_987_654,\n        123890812938219038290489327894327894723897432]\n\ndata.each do |n|\n  print \"\n  begin\n    puts \"'\n  rescue => e\n    puts \"Error: \n  end\nend\n", "target": "TENS = [None, None, \"twenty\", \"thirty\", \"forty\",\n        \"fifty\", \"sixty\", \"seventy\", \"eighty\", \"ninety\"]\nSMALL = [\"zero\", \"one\", \"two\", \"three\", \"four\", \"five\",\n         \"six\", \"seven\", \"eight\", \"nine\", \"ten\", \"eleven\",\n         \"twelve\", \"thirteen\", \"fourteen\", \"fifteen\",\n         \"sixteen\", \"seventeen\", \"eighteen\", \"nineteen\"]\nHUGE = [None, None] + [h + \"illion\" \n                       for h in (\"m\", \"b\", \"tr\", \"quadr\", \"quint\", \"sext\", \n                                  \"sept\", \"oct\", \"non\", \"dec\")]\n\ndef nonzero(c, n, connect=''):\n    return \"\" if n == 0 else connect + c + spell_integer(n)\n\ndef last_and(num):\n    if ',' in num:\n        pre, last = num.rsplit(',', 1)\n        if ' and ' not in last:\n            last = ' and' + last\n        num = ''.join([pre, ',', last])\n    return num\n    \ndef big(e, n):\n    if e == 0:\n        return spell_integer(n)\n    elif e == 1:\n        return spell_integer(n) + \" thousand\"\n    else:\n        return spell_integer(n) + \" \" + HUGE[e]\n\ndef base1000_rev(n):\n    \n    \n    while n != 0:\n        n, r = divmod(n, 1000)\n        yield r\n \ndef spell_integer(n):\n    if n < 0:\n        return \"minus \" + spell_integer(-n)\n    elif n < 20:\n        return SMALL[n]\n    elif n < 100:\n        a, b = divmod(n, 10)\n        return TENS[a] + nonzero(\"-\", b)\n    elif n < 1000:\n        a, b = divmod(n, 100)\n        return SMALL[a] + \" hundred\" + nonzero(\" \", b, ' and')\n    else:\n        num = \", \".join([big(e, x) for e, x in\n                         enumerate(base1000_rev(n)) if x][::-1])\n        return last_and(num)\n\nif __name__ == '__main__':\n    \n    for n in (0, -3, 5, -7, 11, -13, 17, -19, 23, -29):\n        print('%+4i -> %s' % (n, spell_integer(n)))\n    print('')  \n    \n    n = 201021002001\n    while n:\n        print('%-12i -> %s' % (n, spell_integer(n)))\n        n //= -10\n    print('%-12i -> %s' % (n, spell_integer(n)))\n    print('')\n"}
{"id": 147182, "name": "Text processing_Max licenses in use", "source": "Translate Ruby to C#: out = 0\nmax_out = -1\nmax_times = []\n \nFile.foreach('mlijobs.txt') do |line|\n  out += line.include?(\"OUT\") ? 1 : -1\n  if out > max_out\n    max_out = out\n    max_times = []\n  end\n  max_times << line.split[3]  if out == max_out\nend\n \nputs \"Maximum simultaneous license use is \nmax_times.each {|time| puts \"  \n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.IO;\n\nnamespace TextProc3\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {            \n            string line;\n            int count = 0, maxcount = 0;\n            List<string> times = new List<string>();\n            System.IO.StreamReader file = new StreamReader(\"mlijobs.txt\");\n            while ((line = file.ReadLine()) != null)\n            {\n                string[] lineelements = line.Split(' ');                \n                switch (lineelements[1])\n                {\n                    case \"IN\":\n                        count--;\n                        break;\n                    case \"OUT\":\n                        count++;\n                        if (count > maxcount)\n                        {\n                            maxcount = count;\n                            times.Clear();\n                            times.Add(lineelements[3]);\n                        }else if(count == maxcount){\n                            times.Add(lineelements[3]);\n                        }\n                        break;\n                }                \n            }\n            file.Close();\n            Console.WriteLine(maxcount);\n            foreach (string time in times)\n            {\n                Console.WriteLine(time);\n            }\n        }\n    }\n}\n"}
{"id": 147184, "name": "Text processing_Max licenses in use", "source": "Translate Ruby to Java: out = 0\nmax_out = -1\nmax_times = []\n \nFile.foreach('mlijobs.txt') do |line|\n  out += line.include?(\"OUT\") ? 1 : -1\n  if out > max_out\n    max_out = out\n    max_times = []\n  end\n  max_times << line.split[3]  if out == max_out\nend\n \nputs \"Maximum simultaneous license use is \nmax_times.each {|time| puts \"  \n", "target": "import java.io.BufferedReader;\nimport java.io.FileNotFoundException;\nimport java.io.FileReader;\nimport java.io.IOException;\nimport java.util.LinkedList;\n\npublic class License {\n  public static void main(String[] args) throws FileNotFoundException, IOException{\n    BufferedReader in = new BufferedReader(new FileReader(args[0]));\n    int max = Integer.MIN_VALUE;\n    LinkedList<String> dates = new LinkedList<String>();\n    String line;\n    int count = 0;\n    while((line = in.readLine()) != null){\n      if(line.startsWith(\"License OUT \")) count++;\n      if(line.startsWith(\"License IN \")) count--;\n      if(count > max){\n        max = count;\n        String date = line.split(\" \")[3];\n        dates.clear();\n        dates.add(date);\n      }else if(count == max){\n        String date = line.split(\" \")[3];\n        dates.add(date);\n      }\n    }\n    System.out.println(\"Max licenses out: \"+max);\n    System.out.println(\"At time(s): \"+dates);\n  }\n}\n"}
{"id": 147185, "name": "Text processing_Max licenses in use", "source": "Translate Ruby to Python: out = 0\nmax_out = -1\nmax_times = []\n \nFile.foreach('mlijobs.txt') do |line|\n  out += line.include?(\"OUT\") ? 1 : -1\n  if out > max_out\n    max_out = out\n    max_times = []\n  end\n  max_times << line.split[3]  if out == max_out\nend\n \nputs \"Maximum simultaneous license use is \nmax_times.each {|time| puts \"  \n", "target": "out, max_out, max_times = 0, -1, []\nfor job in open('mlijobs.txt'):\n    out += 1 if \"OUT\" in job else -1\n    if out > max_out:\n        max_out, max_times = out, []\n    if out == max_out:\n        max_times.append(job.split()[3])\n        \nprint(\"Maximum simultaneous license use is %i at the following times:\" % max_out)\nprint('  ' + '\\n  '.join(max_times))\n"}
{"id": 147367, "name": "Roots of a function", "source": "Translate Ruby to C#: def sign(x)\n  x <=> 0\nend\n\ndef find_roots(f, range, step=0.001)\n  sign = sign(f[range.begin])\n  range.step(step) do |x|\n    value = f[x]\n    if value == 0\n      puts \"Root found at \n    elsif sign(value) == -sign\n      puts \"Root found between \n    end\n    sign = sign(value)\n  end\nend\n\nf = lambda { |x| x**3 - 3*x**2 + 2*x }\nfind_roots(f, -1..3)\n", "target": "using System;\n\nclass Program\n{\n    public static void Main(string[] args)\n    {\n        Func<double, double> f = x => { return x * x * x - 3 * x * x + 2 * x; };\n\n        double step = 0.001; \n        double start = -1;\n        double stop = 3;\n        double value = f(start);\n        int sign = (value > 0) ? 1 : 0;\n \n        \n        if (value == 0)\n            Console.WriteLine(\"Root found at {0}\", start);\n\n        for (var x = start + step; x <= stop; x += step)\n        {\n            value = f(x);\n \n            if (((value > 0) ? 1 : 0) != sign)\n                \n                Console.WriteLine(\"Root found near {0}\", x);\n            else if (value == 0)\n                \n                Console.WriteLine(\"Root found at {0}\", x);\n \n            \n            sign = (value > 0) ? 1 : 0;\n        }\n    }\n}\n"}
{"id": 147369, "name": "Roots of a function", "source": "Translate Ruby to Java: def sign(x)\n  x <=> 0\nend\n\ndef find_roots(f, range, step=0.001)\n  sign = sign(f[range.begin])\n  range.step(step) do |x|\n    value = f[x]\n    if value == 0\n      puts \"Root found at \n    elsif sign(value) == -sign\n      puts \"Root found between \n    end\n    sign = sign(value)\n  end\nend\n\nf = lambda { |x| x**3 - 3*x**2 + 2*x }\nfind_roots(f, -1..3)\n", "target": "public class Roots {\n    public interface Function {\n\tpublic double f(double x);\n    }\n\n    private static int sign(double x) {\n\treturn (x < 0.0) ? -1 : (x > 0.0) ? 1 : 0;\n    }\n\n    public static void printRoots(Function f, double lowerBound,\n\t\t\t\t  double upperBound, double step) {\n\tdouble x = lowerBound, ox = x;\n\tdouble y = f.f(x), oy = y;\n\tint s = sign(y), os = s;\n\n\tfor (; x <= upperBound ; x += step) {\n\t    s = sign(y = f.f(x));\n\t    if (s == 0) {\n\t\tSystem.out.println(x);\n\t    } else if (s != os) {\n\t\tdouble dx = x - ox;\n\t\tdouble dy = y - oy;\n\t\tdouble cx = x - dx * (y / dy);\n\t\tSystem.out.println(\"~\" + cx);\n\t    }\n\t    ox = x; oy = y; os = s;\n\t}\n    }\n\n    public static void main(String[] args) {\n\tFunction poly = new Function () {\n\t    public double f(double x) {\n\t\treturn x*x*x - 3*x*x + 2*x;\n\t    }\n\t};\n\tprintRoots(poly, -1.0, 4, 0.002);\n    }\n}\n"}
{"id": 147370, "name": "Roots of a function", "source": "Translate Ruby to Python: def sign(x)\n  x <=> 0\nend\n\ndef find_roots(f, range, step=0.001)\n  sign = sign(f[range.begin])\n  range.step(step) do |x|\n    value = f[x]\n    if value == 0\n      puts \"Root found at \n    elsif sign(value) == -sign\n      puts \"Root found between \n    end\n    sign = sign(value)\n  end\nend\n\nf = lambda { |x| x**3 - 3*x**2 + 2*x }\nfind_roots(f, -1..3)\n", "target": "f = lambda x: x * x * x - 3 * x * x + 2 * x\n\nstep = 0.001 \nstart = -1\nstop = 3\n\nsign = f(start) > 0\n\nx = start\nwhile x <= stop:\n    value = f(x)\n\n    if value == 0:\n        \n        print \"Root found at\", x\n    elif (value > 0) != sign:\n        \n        print \"Root found near\", x\n\n    \n    sign = value > 0\n\n    x += step\n"}
{"id": 147527, "name": "Sequence of primes by trial division", "source": "Translate Ruby to C#: require \"big\"\n\ndef primep5?(n)                          \n  \n  n = n.to_big_i\n  return [2, 3, 5].includes?(n) if n < 7 \n  return false if n.gcd(30) != 1         \n  p = typeof(n).new(7)                   \n  until p*p > n\n    return false if                      \n      n % (p)    == 0 || n % (p+4)  == 0 || n % (p+6)  == 0 || n % (p+10) == 0 ||\n      n % (p+12) == 0 || n % (p+16) == 0 || n % (p+22) == 0 || n % (p+24) == 0\n      p += 30  \n  end\n  true\nend\n\n\nn = 1_000_000_001; n.step(to: n+200, by: 2) { |p| puts p if primep5?(p) }\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\npublic class Program\n{\n    static void Main() {\n        Console.WriteLine(string.Join(\" \", Primes(100)));\n    }\n\n    static IEnumerable<int> Primes(int limit) => Enumerable.Range(2, limit-1).Where(IsPrime);\n    static bool IsPrime(int n) => Enumerable.Range(2, (int)Math.Sqrt(n)-1).All(i => n % i != 0);\n}\n"}
{"id": 147529, "name": "Sequence of primes by trial division", "source": "Translate Ruby to Java: require \"big\"\n\ndef primep5?(n)                          \n  \n  n = n.to_big_i\n  return [2, 3, 5].includes?(n) if n < 7 \n  return false if n.gcd(30) != 1         \n  p = typeof(n).new(7)                   \n  until p*p > n\n    return false if                      \n      n % (p)    == 0 || n % (p+4)  == 0 || n % (p+6)  == 0 || n % (p+10) == 0 ||\n      n % (p+12) == 0 || n % (p+16) == 0 || n % (p+22) == 0 || n % (p+24) == 0\n      p += 30  \n  end\n  true\nend\n\n\nn = 1_000_000_001; n.step(to: n+200, by: 2) { |p| puts p if primep5?(p) }\n", "target": "import java.util.stream.IntStream;\n\npublic class Test {\n\n    static IntStream getPrimes(int start, int end) {\n        return IntStream.rangeClosed(start, end).filter(n -> isPrime(n));\n    }\n\n    public static boolean isPrime(long x) {\n        if (x < 3 || x % 2 == 0)\n            return x == 2;\n\n        long max = (long) Math.sqrt(x);\n        for (long n = 3; n <= max; n += 2) {\n            if (x % n == 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    public static void main(String[] args) {\n        getPrimes(0, 100).forEach(p -> System.out.printf(\"%d, \", p));\n    }\n}\n"}
{"id": 147530, "name": "Sequence of primes by trial division", "source": "Translate Ruby to Python: require \"big\"\n\ndef primep5?(n)                          \n  \n  n = n.to_big_i\n  return [2, 3, 5].includes?(n) if n < 7 \n  return false if n.gcd(30) != 1         \n  p = typeof(n).new(7)                   \n  until p*p > n\n    return false if                      \n      n % (p)    == 0 || n % (p+4)  == 0 || n % (p+6)  == 0 || n % (p+10) == 0 ||\n      n % (p+12) == 0 || n % (p+16) == 0 || n % (p+22) == 0 || n % (p+24) == 0\n      p += 30  \n  end\n  true\nend\n\n\nn = 1_000_000_001; n.step(to: n+200, by: 2) { |p| puts p if primep5?(p) }\n", "target": "def prime(a):\n    return not (a < 2 or any(a % x == 0 for x in xrange(2, int(a**0.5) + 1)))\n\ndef primes_below(n):\n    return [i for i in range(n) if prime(i)]\n"}
{"id": 147744, "name": "Linear congruential generator", "source": "Translate Ruby to C#: module LCG\n  module Common\n    \n    attr_reader :seed\n\n    \n    def initialize(seed)\n      @seed = @r = seed\n    end\n  end\n\n  \n  \n  class Berkeley\n    include Common\n    def rand\n      @r = (1103515245 * @r + 12345) & 0x7fff_ffff\n    end\n  end\n\n  \n  \n  class Microsoft\n    include Common\n    def rand\n      @r = (214013 * @r + 2531011) & 0x7fff_ffff\n      @r >> 16\n    end\n  end\nend\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing static System.Console;\n\nnamespace LinearCongruentialGenerator\n{\n    static class LinearCongruentialGenerator\n    {\n        static int _seed = (int)DateTime.Now.Ticks; \n        static int _bsdCurrent = _seed;\n        static int _msvcrtCurrent = _seed;\n\n        static int Next(int seed, int a, int b) => (a * seed + b) & int.MaxValue;\n\n        static int BsdRand() => _bsdCurrent = Next(_bsdCurrent, 1103515245, 12345); \n\n        static int MscvrtRand() => _msvcrtCurrent = Next (_msvcrtCurrent << 16,214013,2531011) >> 16;\n\n        static void PrintRandom(int count, bool isBsd)\n        {\n            var name = isBsd ? \"BSD\" : \"MS\";\n            WriteLine($\"{name} next {count} Random\");\n            var gen = isBsd ? (Func<int>)(BsdRand) : MscvrtRand;\n            foreach (var r in Enumerable.Repeat(gen, count))\n                WriteLine(r.Invoke());\n        }\n\n        static void Main(string[] args)\n        {\n            PrintRandom(10, true);\n            PrintRandom(10, false);\n            Read();\n        }\n    }\n}\n"}
{"id": 147746, "name": "Linear congruential generator", "source": "Translate Ruby to Java: module LCG\n  module Common\n    \n    attr_reader :seed\n\n    \n    def initialize(seed)\n      @seed = @r = seed\n    end\n  end\n\n  \n  \n  class Berkeley\n    include Common\n    def rand\n      @r = (1103515245 * @r + 12345) & 0x7fff_ffff\n    end\n  end\n\n  \n  \n  class Microsoft\n    include Common\n    def rand\n      @r = (214013 * @r + 2531011) & 0x7fff_ffff\n      @r >> 16\n    end\n  end\nend\n", "target": "import java.util.stream.IntStream;\nimport static java.util.stream.IntStream.iterate;\n\npublic class LinearCongruentialGenerator {\n    final static int mask = (1 << 31) - 1;\n\n    public static void main(String[] args) {\n        System.out.println(\"BSD:\");\n        randBSD(0).limit(10).forEach(System.out::println);\n\n        System.out.println(\"\\nMS:\");\n        randMS(0).limit(10).forEach(System.out::println);\n    }\n\n    static IntStream randBSD(int seed) {\n        return iterate(seed, s -> (s * 1_103_515_245 + 12_345) & mask).skip(1);\n    }\n\n    static IntStream randMS(int seed) {\n        return iterate(seed, s -> (s * 214_013 + 2_531_011) & mask).skip(1)\n                .map(i -> i >> 16);\n    }\n}\n"}
{"id": 147747, "name": "Linear congruential generator", "source": "Translate Ruby to Python: module LCG\n  module Common\n    \n    attr_reader :seed\n\n    \n    def initialize(seed)\n      @seed = @r = seed\n    end\n  end\n\n  \n  \n  class Berkeley\n    include Common\n    def rand\n      @r = (1103515245 * @r + 12345) & 0x7fff_ffff\n    end\n  end\n\n  \n  \n  class Microsoft\n    include Common\n    def rand\n      @r = (214013 * @r + 2531011) & 0x7fff_ffff\n      @r >> 16\n    end\n  end\nend\n", "target": "def bsd_rand(seed):\n   def rand():\n      rand.seed = (1103515245*rand.seed + 12345) & 0x7fffffff\n      return rand.seed\n   rand.seed = seed\n   return rand\n\ndef msvcrt_rand(seed):\n   def rand():\n      rand.seed = (214013*rand.seed + 2531011) & 0x7fffffff\n      return rand.seed >> 16\n   rand.seed = seed\n   return rand\n"}
{"id": 148011, "name": "Sorting algorithms_Selection sort", "source": "Translate Ruby to C#: \n\ndef sequential_sort(array)\n  sorted = []\n\n  while array.any?\n    index_of_smallest_element = find_smallest_index(array) \n    sorted << array.delete_at(index_of_smallest_element)\n  end\n\n  sorted\nend\n\ndef find_smallest_index(array)\n  smallest_element = array[0]\n  smallest_index = 0\n\n  array.each_with_index do |ele, idx|\n    if ele < smallest_element\n      smallest_element = ele\n      smallest_index = idx\n    end\n  end\n\n  smallest_index\nend\n\nputs \"sequential_sort([9, 6, 8, 7, 5]): \n\n\n\n\n\n\ndef sequential_sort_with_swapping(array)\n  array.each_with_index do |element, index|\n    smallest_unsorted_element_so_far = element\n    smallest_unsorted_index_so_far = index\n\n    (index+1...array.length).each do |index_value|\n      if array[index_value] < smallest_unsorted_element_so_far\n        smallest_unsorted_element_so_far = array[index_value]\n        smallest_unsorted_index_so_far = index_value\n      end\n    end\n\n    \n    array[index], array[smallest_unsorted_index_so_far] = array[smallest_unsorted_index_so_far], array[index]\n  end\n\n  array\nend\n\nputs \"sequential_sort_with_swapping([7,6,5,9,8,4,3,1,2,0]): \n\n", "target": "class SelectionSort<T> where T : IComparable {\n    public T[] Sort(T[] list) {\n        int k;\n        T temp;\n\n        for (int i = 0; i < list.Length; i++) {\n            k = i;\n            for (int j=i + 1; j < list.Length; j++) {\n                if (list[j].CompareTo(list[k]) < 0) {\n                    k = j;\n                }\n            }\n            temp = list[i];\n            list[i] = list[k];\n            list[k] = temp;\n        }\n\n        return list;\n    }\n}\n"}
{"id": 148013, "name": "Sorting algorithms_Selection sort", "source": "Translate Ruby to Java: \n\ndef sequential_sort(array)\n  sorted = []\n\n  while array.any?\n    index_of_smallest_element = find_smallest_index(array) \n    sorted << array.delete_at(index_of_smallest_element)\n  end\n\n  sorted\nend\n\ndef find_smallest_index(array)\n  smallest_element = array[0]\n  smallest_index = 0\n\n  array.each_with_index do |ele, idx|\n    if ele < smallest_element\n      smallest_element = ele\n      smallest_index = idx\n    end\n  end\n\n  smallest_index\nend\n\nputs \"sequential_sort([9, 6, 8, 7, 5]): \n\n\n\n\n\n\ndef sequential_sort_with_swapping(array)\n  array.each_with_index do |element, index|\n    smallest_unsorted_element_so_far = element\n    smallest_unsorted_index_so_far = index\n\n    (index+1...array.length).each do |index_value|\n      if array[index_value] < smallest_unsorted_element_so_far\n        smallest_unsorted_element_so_far = array[index_value]\n        smallest_unsorted_index_so_far = index_value\n      end\n    end\n\n    \n    array[index], array[smallest_unsorted_index_so_far] = array[smallest_unsorted_index_so_far], array[index]\n  end\n\n  array\nend\n\nputs \"sequential_sort_with_swapping([7,6,5,9,8,4,3,1,2,0]): \n\n", "target": "public static void sort(int[] nums){\n\tfor(int currentPlace = 0;currentPlace<nums.length-1;currentPlace++){\n\t\tint smallest = Integer.MAX_VALUE;\n\t\tint smallestAt = currentPlace+1;\n\t\tfor(int check = currentPlace; check<nums.length;check++){\n\t\t\tif(nums[check]<smallest){\n\t\t\t\tsmallestAt = check;\n\t\t\t\tsmallest = nums[check];\n\t\t\t}\n\t\t}\n\t\tint temp = nums[currentPlace];\n\t\tnums[currentPlace] = nums[smallestAt];\n\t\tnums[smallestAt] = temp;\n\t}\n}\n"}
{"id": 148014, "name": "Sorting algorithms_Selection sort", "source": "Translate Ruby to Python: \n\ndef sequential_sort(array)\n  sorted = []\n\n  while array.any?\n    index_of_smallest_element = find_smallest_index(array) \n    sorted << array.delete_at(index_of_smallest_element)\n  end\n\n  sorted\nend\n\ndef find_smallest_index(array)\n  smallest_element = array[0]\n  smallest_index = 0\n\n  array.each_with_index do |ele, idx|\n    if ele < smallest_element\n      smallest_element = ele\n      smallest_index = idx\n    end\n  end\n\n  smallest_index\nend\n\nputs \"sequential_sort([9, 6, 8, 7, 5]): \n\n\n\n\n\n\ndef sequential_sort_with_swapping(array)\n  array.each_with_index do |element, index|\n    smallest_unsorted_element_so_far = element\n    smallest_unsorted_index_so_far = index\n\n    (index+1...array.length).each do |index_value|\n      if array[index_value] < smallest_unsorted_element_so_far\n        smallest_unsorted_element_so_far = array[index_value]\n        smallest_unsorted_index_so_far = index_value\n      end\n    end\n\n    \n    array[index], array[smallest_unsorted_index_so_far] = array[smallest_unsorted_index_so_far], array[index]\n  end\n\n  array\nend\n\nputs \"sequential_sort_with_swapping([7,6,5,9,8,4,3,1,2,0]): \n\n", "target": "def selection_sort(lst):\n    for i, e in enumerate(lst):\n        mn = min(range(i,len(lst)), key=lst.__getitem__)\n        lst[i], lst[mn] = lst[mn], e\n    return lst\n"}
{"id": 148268, "name": "Sorting algorithms_Comb sort", "source": "Translate Ruby to C#: class Array\n  def combsort!\n    gap = size\n    swaps = true\n    while gap > 1 or swaps\n      gap = [1, (gap / 1.25).to_i].max\n      swaps = false\n      0.upto(size - gap - 1) do |i|\n        if self[i] > self[i+gap]\n          self[i], self[i+gap] = self[i+gap], self[i]\n          swaps = true\n        end\n      end\n    end\n    self\n  end\nend\n\np [23, 76, 99, 58, 97, 57, 35, 89, 51, 38, 95, 92, 24, 46, 31, 24, 14, 12, 57, 78].combsort!\n", "target": "using System;\n\nnamespace CombSort\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            int[] unsorted = new int[] { 3, 5, 1, 9, 7, 6, 8, 2, 4 };\n            Console.WriteLine(string.Join(\",\", combSort(unsorted)));\n        }\n        public static int[] combSort(int[] input)\n        {\n            double gap = input.Length;\n            bool swaps = true;\n            while (gap > 1 || swaps)\n            {\n                gap /= 1.247330950103979;\n                if (gap < 1) { gap = 1; }\n                int i = 0;\n                swaps = false;\n                while (i + gap < input.Length)\n                {\n                    int igap = i + (int)gap;\n                    if (input[i] > input[igap])\n                    {\n                        int swap = input[i];\n                        input[i] = input[igap];\n                        input[igap] = swap;\n                        swaps = true;\n                    }\n                    i++;\n                }\n            }\n            return input;\n        }\n    }\n}\n"}
{"id": 148270, "name": "Sorting algorithms_Comb sort", "source": "Translate Ruby to Python: class Array\n  def combsort!\n    gap = size\n    swaps = true\n    while gap > 1 or swaps\n      gap = [1, (gap / 1.25).to_i].max\n      swaps = false\n      0.upto(size - gap - 1) do |i|\n        if self[i] > self[i+gap]\n          self[i], self[i+gap] = self[i+gap], self[i]\n          swaps = true\n        end\n      end\n    end\n    self\n  end\nend\n\np [23, 76, 99, 58, 97, 57, 35, 89, 51, 38, 95, 92, 24, 46, 31, 24, 14, 12, 57, 78].combsort!\n", "target": ">>> def combsort(input):\n    gap = len(input)\n    swaps = True\n    while gap > 1 or swaps:\n        gap = max(1, int(gap / 1.25))  \n        swaps = False\n        for i in range(len(input) - gap):\n            j = i+gap\n            if input[i] > input[j]:\n                input[i], input[j] = input[j], input[i]\n                swaps = True\n\n                \n>>> y = [88, 18, 31, 44, 4, 0, 8, 81, 14, 78, 20, 76, 84, 33, 73, 75, 82, 5, 62, 70]\n>>> combsort(y)\n>>> assert y == sorted(y)\n>>> y\n[0, 4, 5, 8, 14, 18, 20, 31, 33, 44, 62, 70, 73, 75, 76, 78, 81, 82, 84, 88]\n>>>\n"}
{"id": 148477, "name": "Horizontal sundial calculations", "source": "Translate Ruby to C#: include Math\nDtoR = PI/180\n\nprint 'Enter latitude: '\nlat = Float( gets )\nprint 'Enter longitude: '\nlng = Float( gets )\nprint 'Enter legal meridian: '\nref = Float( gets )\nputs\n\nslat = sin( lat * DtoR )\n\nputs \"    sine of latitude: \u00a0%.3f\"% slat\nputs \"    diff longitude:   \u00a0%.3f\"% (lng-ref)\nputs\nputs 'Hour, sun hour angle, dial hour line angle from 6am to 6pm'\n-6.upto(6) do |h|\n  hra = 15 * h\n  hra -= lng - ref\n  hla =  atan( slat * tan( hra * DtoR ))/ DtoR \n  puts \"HR =%3d; HRA =%7.3f; HLA =%7.3f\" % [h, hra, hla]\nend\n", "target": "using System;\n\nnamespace RosettaCode\n{\n  internal sealed class Program\n  {\n    private static void Main()\n    {\n      Func<double> getDouble = () => Convert.ToDouble(Console.ReadLine());\n      double h = 0, lat, lng, lme, slat, hra, hla;\n\n      Console.Write(\"Enter latitude       => \");\n      lat = getDouble();\n      Console.Write(\"Enter longitude      => \");\n      lng = getDouble();\n      Console.Write(\"Enter legal meridian => \");\n      lme = getDouble();\n\n      slat = Math.Sin(lat*2*Math.PI/360);\n      Console.WriteLine(\"\\n    sine of latitude:   {0:0.000}\", slat);\n      Console.WriteLine(\"    diff longitude:     {0:0.000}\\n\", lng-lme);\n      Console.WriteLine(\"Hour, sun hour angle, dial hour line angle from 6am to 6pm\");\n      for (h = -6; h<6; h++)\n      {\n        hra = 15*h;\n        hra -= lng-lme;\n        hla = Math.Atan(slat*Math.Tan(hra*2*Math.PI/360))*360/(2*Math.PI);\n        Console.WriteLine(\"HR= {0,7:0.000}; HRA {1,7:0.000}; HLA= {2,7:0.000}\", h, hra, hla);\n      }\n    }\n  }\n}\n"}
{"id": 148479, "name": "Horizontal sundial calculations", "source": "Translate Ruby to Java: include Math\nDtoR = PI/180\n\nprint 'Enter latitude: '\nlat = Float( gets )\nprint 'Enter longitude: '\nlng = Float( gets )\nprint 'Enter legal meridian: '\nref = Float( gets )\nputs\n\nslat = sin( lat * DtoR )\n\nputs \"    sine of latitude: \u00a0%.3f\"% slat\nputs \"    diff longitude:   \u00a0%.3f\"% (lng-ref)\nputs\nputs 'Hour, sun hour angle, dial hour line angle from 6am to 6pm'\n-6.upto(6) do |h|\n  hra = 15 * h\n  hra -= lng - ref\n  hla =  atan( slat * tan( hra * DtoR ))/ DtoR \n  puts \"HR =%3d; HRA =%7.3f; HLA =%7.3f\" % [h, hra, hla]\nend\n", "target": "import java.util.Scanner;\n\npublic class Sundial {\n    public static void main(String[] args) {\n        double lat, slat, lng, ref;\n        Scanner sc = new Scanner(System.in);\n\n        System.out.print(\"Enter latitude: \");\n        lat = sc.nextDouble();\n        System.out.print(\"Enter longitude: \");\n        lng = sc.nextDouble();\n        System.out.print(\"Enter legal meridian: \");\n        ref = sc.nextDouble();\n        System.out.println();\n\n        slat = Math.sin(Math.toRadians(lat));\n        System.out.printf(\"sine of latitude:\u00a0%.3f\\n\", slat);\n        System.out.printf(\"diff longitude:\u00a0%.3f\\n\\n\", lng - ref);\n\n        System.out.printf(\"Hour, sun hour angle, dial hour line angle from 6am to 6pm\\n\");\n\n        for (int h = -6; h <= 6; h++) {\n            double hla, hra, hraRad;\n            hra = 15.0 * h;\n            hra = hra - lng + ref;\n            hraRad = Math.toRadians(hra);\n            hla = Math.toDegrees(Math.atan2(Math.sin(hraRad)*Math.sin(Math.toRadians(lat)), Math.cos(hraRad)));\n            System.out.printf(\"HR= %3d;  \\t  HRA=%7.3f;  \\t  HLA= %7.3f\\n\",\n                    h, hra, hla);\n        }\n    }\n}\n"}
{"id": 148480, "name": "Horizontal sundial calculations", "source": "Translate Ruby to Python: include Math\nDtoR = PI/180\n\nprint 'Enter latitude: '\nlat = Float( gets )\nprint 'Enter longitude: '\nlng = Float( gets )\nprint 'Enter legal meridian: '\nref = Float( gets )\nputs\n\nslat = sin( lat * DtoR )\n\nputs \"    sine of latitude: \u00a0%.3f\"% slat\nputs \"    diff longitude:   \u00a0%.3f\"% (lng-ref)\nputs\nputs 'Hour, sun hour angle, dial hour line angle from 6am to 6pm'\n-6.upto(6) do |h|\n  hra = 15 * h\n  hra -= lng - ref\n  hla =  atan( slat * tan( hra * DtoR ))/ DtoR \n  puts \"HR =%3d; HRA =%7.3f; HLA =%7.3f\" % [h, hra, hla]\nend\n", "target": "from __future__ import print_function\nimport math\ntry: raw_input\nexcept: raw_input = input\n\nlat = float(raw_input(\"Enter latitude       => \"))\nlng = float(raw_input(\"Enter longitude      => \"))\nref = float(raw_input(\"Enter legal meridian => \"))\nprint()\n\nslat = math.sin(math.radians(lat))\nprint(\"    sine of latitude:   %.3f\" % slat)\nprint(\"    diff longitude:     %.3f\" % (lng-ref))\nprint()\nprint(\"Hour, sun hour angle, dial hour line angle from 6am to 6pm\")\n\nfor h in range(-6, 7):\n  hra = 15 * h\n  hra -= lng - ref\n  hla = math.degrees(math.atan(slat * math.tan(math.radians(hra))))\n  print(\"HR=%3d; HRA=%7.3f; HLA=%7.3f\" % (h, hra, hla))\n"}
{"id": 148795, "name": "Attractive numbers", "source": "Translate Ruby to C#: require \"prime\"\n \np (1..120).select{|n| n.prime_division.sum(&:last).prime? }\n", "target": "using System;\n\nnamespace AttractiveNumbers {\n    class Program {\n        const int MAX = 120;\n\n        static bool IsPrime(int n) {\n            if (n < 2) return false;\n            if (n % 2 == 0) return n == 2;\n            if (n % 3 == 0) return n == 3;\n            int d = 5;\n            while (d * d <= n) {\n                if (n % d == 0) return false;\n                d += 2;\n                if (n % d == 0) return false;\n                d += 4;\n            }\n            return true;\n        }\n\n        static int PrimeFactorCount(int n) {\n            if (n == 1) return 0;\n            if (IsPrime(n)) return 1;\n            int count = 0;\n            int f = 2;\n            while (true) {\n                if (n % f == 0) {\n                    count++;\n                    n /= f;\n                    if (n == 1) return count;\n                    if (IsPrime(n)) f = n;\n                } else if (f >= 3) {\n                    f += 2;\n                } else {\n                    f = 3;\n                }\n            }\n        }\n\n        static void Main(string[] args) {\n            Console.WriteLine(\"The attractive numbers up to and including {0} are:\", MAX);\n            int i = 1;\n            int count = 0;\n            while (i <= MAX) {\n                int n = PrimeFactorCount(i);\n                if (IsPrime(n)) {\n                    Console.Write(\"{0,4}\", i);\n                    if (++count % 20 == 0) Console.WriteLine();\n                }\n                ++i;\n            }\n            Console.WriteLine();\n        }\n    }\n}\n"}
{"id": 148796, "name": "Attractive numbers", "source": "Translate Ruby to C#: require \"prime\"\n \np (1..120).select{|n| n.prime_division.sum(&:last).prime? }\n", "target": "using System;\n\nnamespace AttractiveNumbers {\n    class Program {\n        const int MAX = 120;\n\n        static bool IsPrime(int n) {\n            if (n < 2) return false;\n            if (n % 2 == 0) return n == 2;\n            if (n % 3 == 0) return n == 3;\n            int d = 5;\n            while (d * d <= n) {\n                if (n % d == 0) return false;\n                d += 2;\n                if (n % d == 0) return false;\n                d += 4;\n            }\n            return true;\n        }\n\n        static int PrimeFactorCount(int n) {\n            if (n == 1) return 0;\n            if (IsPrime(n)) return 1;\n            int count = 0;\n            int f = 2;\n            while (true) {\n                if (n % f == 0) {\n                    count++;\n                    n /= f;\n                    if (n == 1) return count;\n                    if (IsPrime(n)) f = n;\n                } else if (f >= 3) {\n                    f += 2;\n                } else {\n                    f = 3;\n                }\n            }\n        }\n\n        static void Main(string[] args) {\n            Console.WriteLine(\"The attractive numbers up to and including {0} are:\", MAX);\n            int i = 1;\n            int count = 0;\n            while (i <= MAX) {\n                int n = PrimeFactorCount(i);\n                if (IsPrime(n)) {\n                    Console.Write(\"{0,4}\", i);\n                    if (++count % 20 == 0) Console.WriteLine();\n                }\n                ++i;\n            }\n            Console.WriteLine();\n        }\n    }\n}\n"}
{"id": 148799, "name": "Attractive numbers", "source": "Translate Ruby to Java: require \"prime\"\n \np (1..120).select{|n| n.prime_division.sum(&:last).prime? }\n", "target": "public class Attractive {\n\n    static boolean is_prime(int n) {\n        if (n < 2) return false;\n        if (n % 2 == 0) return n == 2;\n        if (n % 3 == 0) return n == 3;\n        int d = 5;\n        while (d *d <= n) {\n            if (n % d == 0) return false;\n            d += 2;\n            if (n % d == 0) return false;\n            d += 4;\n        }\n        return true;\n    }\n\n    static int count_prime_factors(int n) {\n        if (n == 1) return 0;\n        if (is_prime(n)) return 1;\n        int count = 0, f = 2;\n        while (true) {\n            if (n % f == 0) {\n                count++;\n                n /= f;\n                if (n == 1) return count;\n                if (is_prime(n)) f = n;\n            }\n            else if (f >= 3) f += 2;\n            else f = 3;\n        }\n    }\n\n    public static void main(String[] args) {\n        final int max = 120;\n        System.out.printf(\"The attractive numbers up to and including %d are:\\n\", max);\n        for (int i = 1, count = 0; i <= max; ++i) {\n            int n = count_prime_factors(i);\n            if (is_prime(n)) {\n                System.out.printf(\"%4d\", i);\n                if (++count % 20 == 0) System.out.println();\n            }\n        }\n        System.out.println();\n    }\n}\n"}
{"id": 148800, "name": "Attractive numbers", "source": "Translate Ruby to Java: require \"prime\"\n \np (1..120).select{|n| n.prime_division.sum(&:last).prime? }\n", "target": "public class Attractive {\n\n    static boolean is_prime(int n) {\n        if (n < 2) return false;\n        if (n % 2 == 0) return n == 2;\n        if (n % 3 == 0) return n == 3;\n        int d = 5;\n        while (d *d <= n) {\n            if (n % d == 0) return false;\n            d += 2;\n            if (n % d == 0) return false;\n            d += 4;\n        }\n        return true;\n    }\n\n    static int count_prime_factors(int n) {\n        if (n == 1) return 0;\n        if (is_prime(n)) return 1;\n        int count = 0, f = 2;\n        while (true) {\n            if (n % f == 0) {\n                count++;\n                n /= f;\n                if (n == 1) return count;\n                if (is_prime(n)) f = n;\n            }\n            else if (f >= 3) f += 2;\n            else f = 3;\n        }\n    }\n\n    public static void main(String[] args) {\n        final int max = 120;\n        System.out.printf(\"The attractive numbers up to and including %d are:\\n\", max);\n        for (int i = 1, count = 0; i <= max; ++i) {\n            int n = count_prime_factors(i);\n            if (is_prime(n)) {\n                System.out.printf(\"%4d\", i);\n                if (++count % 20 == 0) System.out.println();\n            }\n        }\n        System.out.println();\n    }\n}\n"}
{"id": 148801, "name": "Attractive numbers", "source": "Translate Ruby to Python: require \"prime\"\n \np (1..120).select{|n| n.prime_division.sum(&:last).prime? }\n", "target": "from sympy import sieve \n\ndef get_pfct(n): \n\ti = 2; factors = []\n\twhile i * i <= n:\n\t\tif n % i:\n\t\t\ti += 1\n\t\telse:\n\t\t\tn //= i\n\t\t\tfactors.append(i)\n\tif n > 1:\n\t\tfactors.append(n)\n\treturn len(factors) \n\nsieve.extend(110) \nprimes=sieve._list\n\npool=[]\n\nfor each in xrange(0,121):\n\tpool.append(get_pfct(each))\n\nfor i,each in enumerate(pool):\n\tif each in primes:\n\t\tprint i,\n"}
{"id": 148802, "name": "Attractive numbers", "source": "Translate Ruby to Python: require \"prime\"\n \np (1..120).select{|n| n.prime_division.sum(&:last).prime? }\n", "target": "from sympy import sieve \n\ndef get_pfct(n): \n\ti = 2; factors = []\n\twhile i * i <= n:\n\t\tif n % i:\n\t\t\ti += 1\n\t\telse:\n\t\t\tn //= i\n\t\t\tfactors.append(i)\n\tif n > 1:\n\t\tfactors.append(n)\n\treturn len(factors) \n\nsieve.extend(110) \nprimes=sieve._list\n\npool=[]\n\nfor each in xrange(0,121):\n\tpool.append(get_pfct(each))\n\nfor i,each in enumerate(pool):\n\tif each in primes:\n\t\tprint i,\n"}
{"id": 149040, "name": "Convex hull", "source": "Translate Ruby to C#: class Point\n    include Comparable\n    attr :x, :y\n\n    def initialize(x, y)\n        @x = x\n        @y = y\n    end\n\n    def <=>(other)\n        x <=> other.x\n    end\n\n    def to_s\n        \"(%d, %d)\" % [@x, @y]\n    end\n\n    def to_str\n        to_s()\n    end\nend\n\ndef ccw(a, b, c)\n    ((b.x - a.x) * (c.y - a.y)) > ((b.y - a.y) * (c.x - a.x))\nend\n\ndef convexHull(p)\n    if p.length == 0 then\n        return []\n    end\n\n    p = p.sort\n    h = []\n\n    \n    p.each { |pt|\n        while h.length >= 2 and not ccw(h[-2], h[-1], pt)\n            h.pop()\n        end\n        h << pt\n    }\n\n    \n    t = h.length + 1\n    p.reverse.each { |pt|\n        while h.length >= t and not ccw(h[-2], h[-1], pt)\n            h.pop()\n        end\n        h << pt\n    }\n\n    h.pop()\n    h\nend\n\ndef main\n    points = [\n        Point.new(16,  3), Point.new(12, 17), Point.new( 0,  6), Point.new(-4, -6), Point.new(16,  6),\n        Point.new(16, -7), Point.new(16, -3), Point.new(17, -4), Point.new( 5, 19), Point.new(19, -8),\n        Point.new( 3, 16), Point.new(12, 13), Point.new( 3, -4), Point.new(17,  5), Point.new(-3, 15),\n        Point.new(-3, -9), Point.new( 0, 11), Point.new(-9, -3), Point.new(-4, -2), Point.new(12, 10)\n    ]\n    hull = convexHull(points)\n    print \"Convex Hull: [\", hull.join(\", \"), \"]\\n\"\nend\n\nmain()\n", "target": "using System;\nusing System.Collections.Generic;\n\nnamespace ConvexHull {\n    class Point : IComparable<Point> {\n        private int x, y;\n\n        public Point(int x, int y) {\n            this.x = x;\n            this.y = y;\n        }\n\n        public int X { get => x; set => x = value; }\n        public int Y { get => y; set => y = value; }\n\n        public int CompareTo(Point other) {\n            return x.CompareTo(other.x);\n        }\n\n        public override string ToString() {\n            return string.Format(\"({0}, {1})\", x, y);\n        }\n    }\n\n    class Program {\n        private static List<Point> ConvexHull(List<Point> p) {\n            if (p.Count == 0) return new List<Point>();\n            p.Sort();\n            List<Point> h = new List<Point>();\n\n            \n            foreach (var pt in p) {\n                while (h.Count >= 2 && !Ccw(h[h.Count - 2], h[h.Count - 1], pt)) {\n                    h.RemoveAt(h.Count - 1);\n                }\n                h.Add(pt);\n            }\n\n            \n            int t = h.Count + 1;\n            for (int i = p.Count - 1; i >= 0; i--) {\n                Point pt = p[i];\n                while (h.Count >= t && !Ccw(h[h.Count - 2], h[h.Count - 1], pt)) {\n                    h.RemoveAt(h.Count - 1);\n                }\n                h.Add(pt);\n            }\n\n            h.RemoveAt(h.Count - 1);\n            return h;\n        }\n\n        private static bool Ccw(Point a, Point b, Point c) {\n            return ((b.X - a.X) * (c.Y - a.Y)) > ((b.Y - a.Y) * (c.X - a.X));\n        }\n\n        static void Main(string[] args) {\n            List<Point> points = new List<Point>() {\n                new Point(16, 3),\n                new Point(12, 17),\n                new Point(0, 6),\n                new Point(-4, -6),\n                new Point(16, 6),\n\n                new Point(16, -7),\n                new Point(16, -3),\n                new Point(17, -4),\n                new Point(5, 19),\n                new Point(19, -8),\n\n                new Point(3, 16),\n                new Point(12, 13),\n                new Point(3, -4),\n                new Point(17, 5),\n                new Point(-3, 15),\n\n                new Point(-3, -9),\n                new Point(0, 11),\n                new Point(-9, -3),\n                new Point(-4, -2),\n                new Point(12, 10)\n            };\n\n            List<Point> hull = ConvexHull(points);\n            Console.Write(\"Convex Hull: [\");\n            for (int i = 0; i < hull.Count; i++) {\n                if (i > 0) {\n                    Console.Write(\", \");\n                }\n                Point pt = hull[i];\n                Console.Write(pt);\n            }\n            Console.WriteLine(\"]\");\n        }\n    }\n}\n"}
{"id": 149042, "name": "Convex hull", "source": "Translate Ruby to Java: class Point\n    include Comparable\n    attr :x, :y\n\n    def initialize(x, y)\n        @x = x\n        @y = y\n    end\n\n    def <=>(other)\n        x <=> other.x\n    end\n\n    def to_s\n        \"(%d, %d)\" % [@x, @y]\n    end\n\n    def to_str\n        to_s()\n    end\nend\n\ndef ccw(a, b, c)\n    ((b.x - a.x) * (c.y - a.y)) > ((b.y - a.y) * (c.x - a.x))\nend\n\ndef convexHull(p)\n    if p.length == 0 then\n        return []\n    end\n\n    p = p.sort\n    h = []\n\n    \n    p.each { |pt|\n        while h.length >= 2 and not ccw(h[-2], h[-1], pt)\n            h.pop()\n        end\n        h << pt\n    }\n\n    \n    t = h.length + 1\n    p.reverse.each { |pt|\n        while h.length >= t and not ccw(h[-2], h[-1], pt)\n            h.pop()\n        end\n        h << pt\n    }\n\n    h.pop()\n    h\nend\n\ndef main\n    points = [\n        Point.new(16,  3), Point.new(12, 17), Point.new( 0,  6), Point.new(-4, -6), Point.new(16,  6),\n        Point.new(16, -7), Point.new(16, -3), Point.new(17, -4), Point.new( 5, 19), Point.new(19, -8),\n        Point.new( 3, 16), Point.new(12, 13), Point.new( 3, -4), Point.new(17,  5), Point.new(-3, 15),\n        Point.new(-3, -9), Point.new( 0, 11), Point.new(-9, -3), Point.new(-4, -2), Point.new(12, 10)\n    ]\n    hull = convexHull(points)\n    print \"Convex Hull: [\", hull.join(\", \"), \"]\\n\"\nend\n\nmain()\n", "target": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.stream.Collectors;\n\nimport static java.util.Collections.emptyList;\n\npublic class ConvexHull {\n    private static class Point implements Comparable<Point> {\n        private int x, y;\n\n        public Point(int x, int y) {\n            this.x = x;\n            this.y = y;\n        }\n\n        @Override\n        public int compareTo(Point o) {\n            return Integer.compare(x, o.x);\n        }\n\n        @Override\n        public String toString() {\n            return String.format(\"(%d, %d)\", x, y);\n        }\n    }\n\n    private static List<Point> convexHull(List<Point> p) {\n        if (p.isEmpty()) return emptyList();\n        p.sort(Point::compareTo);\n        List<Point> h = new ArrayList<>();\n\n        \n        for (Point pt : p) {\n            while (h.size() >= 2 && !ccw(h.get(h.size() - 2), h.get(h.size() - 1), pt)) {\n                h.remove(h.size() - 1);\n            }\n            h.add(pt);\n        }\n\n        \n        int t = h.size() + 1;\n        for (int i = p.size() - 1; i >= 0; i--) {\n            Point pt = p.get(i);\n            while (h.size() >= t && !ccw(h.get(h.size() - 2), h.get(h.size() - 1), pt)) {\n                h.remove(h.size() - 1);\n            }\n            h.add(pt);\n        }\n\n        h.remove(h.size() - 1);\n        return h;\n    }\n\n    \n    private static boolean ccw(Point a, Point b, Point c) {\n        return ((b.x - a.x) * (c.y - a.y)) > ((b.y - a.y) * (c.x - a.x));\n    }\n\n    public static void main(String[] args) {\n        List<Point> points = Arrays.asList(new Point(16, 3),\n                                           new Point(12, 17),\n                                           new Point(0, 6),\n                                           new Point(-4, -6),\n                                           new Point(16, 6),\n\n                                           new Point(16, -7),\n                                           new Point(16, -3),\n                                           new Point(17, -4),\n                                           new Point(5, 19),\n                                           new Point(19, -8),\n\n                                           new Point(3, 16),\n                                           new Point(12, 13),\n                                           new Point(3, -4),\n                                           new Point(17, 5),\n                                           new Point(-3, 15),\n\n                                           new Point(-3, -9),\n                                           new Point(0, 11),\n                                           new Point(-9, -3),\n                                           new Point(-4, -2),\n                                           new Point(12, 10));\n\n        List<Point> hull = convexHull(points);\n        System.out.printf(\"Convex Hull: %s\\n\", hull);\n    }\n}\n"}
{"id": 149043, "name": "Convex hull", "source": "Translate Ruby to Python: class Point\n    include Comparable\n    attr :x, :y\n\n    def initialize(x, y)\n        @x = x\n        @y = y\n    end\n\n    def <=>(other)\n        x <=> other.x\n    end\n\n    def to_s\n        \"(%d, %d)\" % [@x, @y]\n    end\n\n    def to_str\n        to_s()\n    end\nend\n\ndef ccw(a, b, c)\n    ((b.x - a.x) * (c.y - a.y)) > ((b.y - a.y) * (c.x - a.x))\nend\n\ndef convexHull(p)\n    if p.length == 0 then\n        return []\n    end\n\n    p = p.sort\n    h = []\n\n    \n    p.each { |pt|\n        while h.length >= 2 and not ccw(h[-2], h[-1], pt)\n            h.pop()\n        end\n        h << pt\n    }\n\n    \n    t = h.length + 1\n    p.reverse.each { |pt|\n        while h.length >= t and not ccw(h[-2], h[-1], pt)\n            h.pop()\n        end\n        h << pt\n    }\n\n    h.pop()\n    h\nend\n\ndef main\n    points = [\n        Point.new(16,  3), Point.new(12, 17), Point.new( 0,  6), Point.new(-4, -6), Point.new(16,  6),\n        Point.new(16, -7), Point.new(16, -3), Point.new(17, -4), Point.new( 5, 19), Point.new(19, -8),\n        Point.new( 3, 16), Point.new(12, 13), Point.new( 3, -4), Point.new(17,  5), Point.new(-3, 15),\n        Point.new(-3, -9), Point.new( 0, 11), Point.new(-9, -3), Point.new(-4, -2), Point.new(12, 10)\n    ]\n    hull = convexHull(points)\n    print \"Convex Hull: [\", hull.join(\", \"), \"]\\n\"\nend\n\nmain()\n", "target": "from __future__ import print_function\nfrom shapely.geometry import MultiPoint\n\nif __name__==\"__main__\":\n\tpts = MultiPoint([(16,3), (12,17), (0,6), (-4,-6), (16,6), (16,-7), (16,-3), (17,-4), (5,19), (19,-8), (3,16), (12,13), (3,-4), (17,5), (-3,15), (-3,-9), (0,11), (-9,-3), (-4,-2), (12,10)])\n\tprint (pts.convex_hull)\n"}
{"id": 149285, "name": "Trigonometric functions", "source": "Translate Ruby to C#: radians = Math::PI / 4\ndegrees = 45.0\n\ndef deg2rad(d)\n  d * Math::PI / 180\nend\n\ndef rad2deg(r)\n  r * 180 / Math::PI\nend\n\n\nputs \"\n\nputs \"\n\nputs \"\n\narcsin = Math.asin(Math.sin(radians))\nputs \"\n\narccos = Math.acos(Math.cos(radians))\nputs \"\n\narctan = Math.atan(Math.tan(radians))\nputs \"\n", "target": "using System;\n\nnamespace RosettaCode {\n    class Program {\n        static void Main(string[] args) {\n            Console.WriteLine(\"=== radians ===\");\n            Console.WriteLine(\"sin (pi/3) = {0}\", Math.Sin(Math.PI / 3));\n            Console.WriteLine(\"cos (pi/3) = {0}\", Math.Cos(Math.PI / 3));\n            Console.WriteLine(\"tan (pi/3) = {0}\", Math.Tan(Math.PI / 3));\n            Console.WriteLine(\"arcsin (1/2) = {0}\", Math.Asin(0.5));\n            Console.WriteLine(\"arccos (1/2) = {0}\", Math.Acos(0.5));\n            Console.WriteLine(\"arctan (1/2) = {0}\", Math.Atan(0.5));\n            Console.WriteLine(\"\");\n            Console.WriteLine(\"=== degrees ===\");\n            Console.WriteLine(\"sin (60) = {0}\", Math.Sin(60 * Math.PI / 180));\n            Console.WriteLine(\"cos (60) = {0}\", Math.Cos(60 * Math.PI / 180));\n            Console.WriteLine(\"tan (60) = {0}\", Math.Tan(60 * Math.PI / 180));\n            Console.WriteLine(\"arcsin (1/2) = {0}\", Math.Asin(0.5) * 180/ Math.PI);\n            Console.WriteLine(\"arccos (1/2) = {0}\", Math.Acos(0.5) * 180 / Math.PI);\n            Console.WriteLine(\"arctan (1/2) = {0}\", Math.Atan(0.5) * 180 / Math.PI);\n\n            Console.ReadLine();\n        }\n    }\n}\n"}
{"id": 149287, "name": "Trigonometric functions", "source": "Translate Ruby to Java: radians = Math::PI / 4\ndegrees = 45.0\n\ndef deg2rad(d)\n  d * Math::PI / 180\nend\n\ndef rad2deg(r)\n  r * 180 / Math::PI\nend\n\n\nputs \"\n\nputs \"\n\nputs \"\n\narcsin = Math.asin(Math.sin(radians))\nputs \"\n\narccos = Math.acos(Math.cos(radians))\nputs \"\n\narctan = Math.atan(Math.tan(radians))\nputs \"\n", "target": "public class Trig {\n        public static void main(String[] args) {\n                \n                double radians = Math.PI / 4;\n                double degrees = 45.0;\n                \n                System.out.println(Math.sin(radians) + \" \" + Math.sin(Math.toRadians(degrees)));\n                \n                System.out.println(Math.cos(radians) + \" \" + Math.cos(Math.toRadians(degrees)));\n                \n                System.out.println(Math.tan(radians) + \" \" + Math.tan(Math.toRadians(degrees)));\n                \n                double arcsin = Math.asin(Math.sin(radians));\n                System.out.println(arcsin + \" \" + Math.toDegrees(arcsin));\n                \n                double arccos = Math.acos(Math.cos(radians));\n                System.out.println(arccos + \" \" + Math.toDegrees(arccos));\n                \n                double arctan = Math.atan(Math.tan(radians));\n                System.out.println(arctan + \" \" + Math.toDegrees(arctan));\n        }\n}\n"}
{"id": 149288, "name": "Trigonometric functions", "source": "Translate Ruby to Python: radians = Math::PI / 4\ndegrees = 45.0\n\ndef deg2rad(d)\n  d * Math::PI / 180\nend\n\ndef rad2deg(r)\n  r * 180 / Math::PI\nend\n\n\nputs \"\n\nputs \"\n\nputs \"\n\narcsin = Math.asin(Math.sin(radians))\nputs \"\n\narccos = Math.acos(Math.cos(radians))\nputs \"\n\narctan = Math.atan(Math.tan(radians))\nputs \"\n", "target": "Python 3.2.2 (default, Sep  4 2011, 09:51:08) [MSC v.1500 32 bit (Intel)] on win32\nType \"copyright\", \"credits\" or \"license()\" for more information.\n>>> from math import degrees, radians, sin, cos, tan, asin, acos, atan, pi\n>>> rad, deg = pi/4, 45.0\n>>> print(\"Sine:\", sin(rad), sin(radians(deg)))\nSine: 0.7071067811865475 0.7071067811865475\n>>> print(\"Cosine:\", cos(rad), cos(radians(deg)))\nCosine: 0.7071067811865476 0.7071067811865476\n>>> print(\"Tangent:\", tan(rad), tan(radians(deg)))\nTangent: 0.9999999999999999 0.9999999999999999\n>>> arcsine = asin(sin(rad))\n>>> print(\"Arcsine:\", arcsine, degrees(arcsine))\nArcsine: 0.7853981633974482 44.99999999999999\n>>> arccosine = acos(cos(rad))\n>>> print(\"Arccosine:\", arccosine, degrees(arccosine))\nArccosine: 0.7853981633974483 45.0\n>>> arctangent = atan(tan(rad))\n>>> print(\"Arctangent:\", arctangent, degrees(arctangent))\nArctangent: 0.7853981633974483 45.0\n>>>\n"}
{"id": 149555, "name": "Loops_For", "source": "Translate Ruby to C#: for i in 1..5\n  for j in 1..i\n    print \"*\"\n  end\n  puts\nend\n", "target": "using System;\n\nclass Program {\n    static void Main(string[] args)\n    {\n        for (int i = 0; i < 5; i++)\n        {\n            for (int j = 0; j <= i; j++)\n            {\n                Console.Write(\"*\");\n            }\n            Console.WriteLine();\n        }\n    }\n}\n"}
{"id": 149557, "name": "Loops_For", "source": "Translate Ruby to Java: for i in 1..5\n  for j in 1..i\n    print \"*\"\n  end\n  puts\nend\n", "target": "for (Integer i = 0; i < 5; i++) {\n    String line = '';\n\n    for (Integer j = 0; j < i; j++) {\n        line += '*';\n    }\n\n    System.debug(line);\n}\n\nList<String> lines = new List<String> {\n    '*',\n    '**',\n    '***',\n    '****',\n    '*****'\n};\n\nfor (String line : lines) {\n    System.debug(line);\n}\n"}
{"id": 149558, "name": "Loops_For", "source": "Translate Ruby to Python: for i in 1..5\n  for j in 1..i\n    print \"*\"\n  end\n  puts\nend\n", "target": "for i in 1..5:\n  for j in 1..i:\n    stdout.write(\"*\")\n  echo(\"\")\n"}
{"id": 149801, "name": "Loops_Downward for", "source": "Translate Ruby to C#: 10.downto(0) do |i|\n   puts i\nend\n", "target": "for (int i = 10; i >= 0; i--)\n{\n   Console.WriteLine(i);\n}\n"}
{"id": 149803, "name": "Loops_Downward for", "source": "Translate Ruby to Java: 10.downto(0) do |i|\n   puts i\nend\n", "target": "for (int i = 10; i >= 0; i--) {\n    System.out.println(i);\n}\n"}
{"id": 150041, "name": "Entropy", "source": "Translate Ruby to C#: \ndef sum(array : Array(Float64))\n  res = 0\n  array.each do |n|\n    res += n\n  end\n  res\nend\n\n\ndef histogram(source : String)\n  hist = {} of Char => Int32\n  l = 0\n  source.each_char do |e|\n    if !hist.has_key? e\n      hist[e] = 0\n    end\n    hist[e] += 1\n  end\n  return Tuple.new(source.size, hist)\nend\n\n\ndef entropy(hist : Hash(Char, Int32), l : Int32)\n  elist = [] of Float64\n  hist.each do |el|\n    v = el[1]\n    c = v / l\n    elist << (-c * Math.log(c, 2))\n  end\n  return sum elist\nend\n\nsource = \"1223334444\"\nhist_res = histogram source\nl = hist_res[0]\nh = hist_res[1]\nputs \".[Results].\"\nputs \"Length: \" + l.to_s\nputs \"Entropy: \" + (entropy h, l).to_s\n", "target": "using System;\nusing System.Collections.Generic;\nnamespace Entropy\n{\n\tclass Program\n\t{\n\t\tpublic static double logtwo(double num)\n\t\t{\n\t\t\treturn Math.Log(num)/Math.Log(2);\n\t\t}\n\t\tpublic static void Main(string[] args)\n\t\t{\n\t\tlabel1:\n\t\t\tstring input = Console.ReadLine();\n\t\t\tdouble infoC=0;\n\t\t\tDictionary<char,double> table = new Dictionary<char, double>();\n\n\t\t\t\n\t\t\tforeach (char c in input)\n\t\t\t{\n\t\t\t\tif (table.ContainsKey(c))\n\t\t\t\t\ttable[c]++;\n\t\t\t\t    else\n\t\t\t\t    \ttable.Add(c,1);\n\t\n\t\t\t}\n\t\t\tdouble freq;\n\t\t\tforeach (KeyValuePair<char,double> letter in table)\n\t\t\t{\n\t\t\t\tfreq=letter.Value/input.Length;\n\t\t\t\tinfoC+=freq*logtwo(freq);\n\t\t\t}\n\t\t\tinfoC*=-1;\n\t\t\tConsole.WriteLine(\"The Entropy of {0} is {1}\",input,infoC);\n\t\t\tgoto label1;\n\t\t\n\t\t}\n\t}\n}\n"}
{"id": 150043, "name": "Entropy", "source": "Translate Ruby to Python: \ndef sum(array : Array(Float64))\n  res = 0\n  array.each do |n|\n    res += n\n  end\n  res\nend\n\n\ndef histogram(source : String)\n  hist = {} of Char => Int32\n  l = 0\n  source.each_char do |e|\n    if !hist.has_key? e\n      hist[e] = 0\n    end\n    hist[e] += 1\n  end\n  return Tuple.new(source.size, hist)\nend\n\n\ndef entropy(hist : Hash(Char, Int32), l : Int32)\n  elist = [] of Float64\n  hist.each do |el|\n    v = el[1]\n    c = v / l\n    elist << (-c * Math.log(c, 2))\n  end\n  return sum elist\nend\n\nsource = \"1223334444\"\nhist_res = histogram source\nl = hist_res[0]\nh = hist_res[1]\nputs \".[Results].\"\nputs \"Length: \" + l.to_s\nputs \"Entropy: \" + (entropy h, l).to_s\n", "target": "from __future__ import division\nimport math\n\ndef hist(source):\n    hist = {}; l = 0;\n    for e in source:\n        l += 1\n        if e not in hist:\n            hist[e] = 0\n        hist[e] += 1\n    return (l,hist)\n\ndef entropy(hist,l):\n    elist = []\n    for v in hist.values():\n        c = v / l\n        elist.append(-c * math.log(c ,2))\n    return sum(elist)\n\ndef printHist(h):\n    flip = lambda (k,v) : (v,k)\n    h = sorted(h.iteritems(), key = flip)\n    print 'Sym\\thi\\tfi\\tInf'\n    for (k,v) in h:\n        print '%s\\t%f\\t%f\\t%f'%(k,v,v/l,-math.log(v/l, 2))\n    \n    \n\nsource = \"1223334444\"\n(l,h) = hist(source);\nprint '.[Results].'\nprint 'Length',l\nprint 'Entropy:', entropy(h, l)\nprintHist(h)\n"}
{"id": 150255, "name": "Host introspection", "source": "Translate Ruby to C#: \n\nword_size = 42.size * 8\nputs \"Word size: \n\n\n\nbytes = [1].pack('S').unpack('C*')\nbyte_order = (bytes[0] == 0 ? 'big' : 'little') + ' endian'\nputs \"Byte order: \n", "target": "static void Main()\n{\n  Console.WriteLine(\"Word size = {0} bytes,\",sizeof(int));\n\n  if (BitConverter.IsLittleEndian)\n    Console.WriteLine(\"Little-endian.\");\n  else\n    Console.WriteLine(\"Big-endian.\");\n}\n"}
{"id": 150257, "name": "Host introspection", "source": "Translate Ruby to Java: \n\nword_size = 42.size * 8\nputs \"Word size: \n\n\n\nbytes = [1].pack('S').unpack('C*')\nbyte_order = (bytes[0] == 0 ? 'big' : 'little') + ' endian'\nputs \"Byte order: \n", "target": "import java.nio.ByteOrder;\n\npublic class ShowByteOrder {\n    public static void main(String[] args) {\n        \n        System.out.println(ByteOrder.nativeOrder());\n    }\n}\n"}
{"id": 150258, "name": "Host introspection", "source": "Translate Ruby to Python: \n\nword_size = 42.size * 8\nputs \"Word size: \n\n\n\nbytes = [1].pack('S').unpack('C*')\nbyte_order = (bytes[0] == 0 ? 'big' : 'little') + ' endian'\nputs \"Byte order: \n", "target": ">>> import platform, sys, socket\n>>> platform.architecture()\n('64bit', 'ELF')\n>>> platform.machine()\n'x86_64'\n>>> platform.node()\n'yourhostname'\n>>> platform.system()\n'Linux'\n>>> sys.byteorder\nlittle\n>>> socket.gethostname()\n'yourhostname'\n>>>\n"}
{"id": 150516, "name": "Currying", "source": "Translate Ruby to C#: add_things = ->(x1 : Int32, x2 : Int32, x3 : Int32) { x1 + x2 + x3 }\nadd_curried = add_things.partial(2, 3)\nadd_curried.call(4)  \n\ndef add_two_things(x1)\n  return ->(x2 : Int32) {\n    ->(x3 : Int32) { x1 + x2 + x3 }\n  }\nend\nadd13 = add_two_things(3).call(10)\nadd13.call(5)  \n", "target": "public delegate int Plus(int y); \npublic delegate Plus CurriedPlus(int x);\npublic static CurriedPlus plus = \n      delegate(int x) {return delegate(int y) {return x + y;};};\nstatic void Main()\n{\n    int sum = plus(3)(4); \n    int sum2= plus(2)(plus(3)(4)) \n}\n"}
{"id": 150517, "name": "Currying", "source": "Translate Ruby to C#: add_things = ->(x1 : Int32, x2 : Int32, x3 : Int32) { x1 + x2 + x3 }\nadd_curried = add_things.partial(2, 3)\nadd_curried.call(4)  \n\ndef add_two_things(x1)\n  return ->(x2 : Int32) {\n    ->(x3 : Int32) { x1 + x2 + x3 }\n  }\nend\nadd13 = add_two_things(3).call(10)\nadd13.call(5)  \n", "target": "public delegate int Plus(int y); \npublic delegate Plus CurriedPlus(int x);\npublic static CurriedPlus plus = \n      delegate(int x) {return delegate(int y) {return x + y;};};\nstatic void Main()\n{\n    int sum = plus(3)(4); \n    int sum2= plus(2)(plus(3)(4)) \n}\n"}
{"id": 150518, "name": "Currying", "source": "Translate Ruby to Java: add_things = ->(x1 : Int32, x2 : Int32, x3 : Int32) { x1 + x2 + x3 }\nadd_curried = add_things.partial(2, 3)\nadd_curried.call(4)  \n\ndef add_two_things(x1)\n  return ->(x2 : Int32) {\n    ->(x3 : Int32) { x1 + x2 + x3 }\n  }\nend\nadd13 = add_two_things(3).call(10)\nadd13.call(5)  \n", "target": "module CurryPower\n    {\n    @Inject Console console;\n    void run()\n        {\n        function Int(Int, Int) divide = (x,y) -> x / y;\n\n        function Int(Int) half = divide(_, 2);\n        function Int(Int) partsOf120 = divide(120, _);\n\n        console.print($|half of a dozen is {half(12)}\n                       |half of 120 is {partsOf120(2)}\n                       |a third is {partsOf120(3)}\n                       |and a quarter is {partsOf120(4)}\n                     );\n        }\n    }\n"}
{"id": 150519, "name": "Currying", "source": "Translate Ruby to Java: add_things = ->(x1 : Int32, x2 : Int32, x3 : Int32) { x1 + x2 + x3 }\nadd_curried = add_things.partial(2, 3)\nadd_curried.call(4)  \n\ndef add_two_things(x1)\n  return ->(x2 : Int32) {\n    ->(x3 : Int32) { x1 + x2 + x3 }\n  }\nend\nadd13 = add_two_things(3).call(10)\nadd13.call(5)  \n", "target": "module CurryPower\n    {\n    @Inject Console console;\n    void run()\n        {\n        function Int(Int, Int) divide = (x,y) -> x / y;\n\n        function Int(Int) half = divide(_, 2);\n        function Int(Int) partsOf120 = divide(120, _);\n\n        console.print($|half of a dozen is {half(12)}\n                       |half of 120 is {partsOf120(2)}\n                       |a third is {partsOf120(3)}\n                       |and a quarter is {partsOf120(4)}\n                     );\n        }\n    }\n"}
{"id": 150520, "name": "Currying", "source": "Translate Ruby to Python: add_things = ->(x1 : Int32, x2 : Int32, x3 : Int32) { x1 + x2 + x3 }\nadd_curried = add_things.partial(2, 3)\nadd_curried.call(4)  \n\ndef add_two_things(x1)\n  return ->(x2 : Int32) {\n    ->(x3 : Int32) { x1 + x2 + x3 }\n  }\nend\nadd13 = add_two_things(3).call(10)\nadd13.call(5)  \n", "target": " def addN(n):\n     def adder(x):\n         return x + n\n     return adder\n"}
{"id": 150521, "name": "Currying", "source": "Translate Ruby to Python: add_things = ->(x1 : Int32, x2 : Int32, x3 : Int32) { x1 + x2 + x3 }\nadd_curried = add_things.partial(2, 3)\nadd_curried.call(4)  \n\ndef add_two_things(x1)\n  return ->(x2 : Int32) {\n    ->(x3 : Int32) { x1 + x2 + x3 }\n  }\nend\nadd13 = add_two_things(3).call(10)\nadd13.call(5)  \n", "target": " def addN(n):\n     def adder(x):\n         return x + n\n     return adder\n"}
{"id": 150785, "name": "Fork", "source": "Translate Ruby to C#: pid = fork\nif pid\n \nelse\n \nend\n", "target": "using System;\nusing System.Threading;\n\nnamespace Fork {\n    class Program {\n        static void Fork() {\n            Console.WriteLine(\"Spawned Thread\");\n        }\n\n        static void Main(string[] args) {\n            Thread t = new Thread(new ThreadStart(Fork));\n            t.Start();\n\n            Console.WriteLine(\"Main Thread\");\n            t.Join();\n\n            Console.ReadLine();\n        }\n    }\n}\n"}
{"id": 150787, "name": "Fork", "source": "Translate Ruby to Java: pid = fork\nif pid\n \nelse\n \nend\n", "target": "import java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.BufferedReader;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.Map;\n\npublic class RFork {\n\n  public static void main(String[] args) {\n    ProcessBuilder pb;\n    Process pp;\n    List<String> command;\n    Map<String, String> env;\n    BufferedReader ir;\n    String currentuser;\n    String line;\n    try {\n      command = Arrays.asList(\"\");\n      pb = new ProcessBuilder(command);\n      env = pb.environment();\n      currentuser = env.get(\"USER\");\n      command = Arrays.asList(\"ps\", \"-f\", \"-U\", currentuser);\n      pb.command(command);\n      pp = pb.start();\n      ir = new BufferedReader(new InputStreamReader(pp.getInputStream()));\n      line = \"Output of running \" + command.toString() + \" is:\";\n      do {\n        System.out.println(line);\n      } while ((line = ir.readLine()) != null);\n    }\n    catch (IOException iox) {\n      iox.printStackTrace();\n    }\n\n    return;\n  }\n}\n"}
{"id": 150947, "name": "S-expressions", "source": "Translate Ruby to C#: class SExpr\n  def initialize(str)\n    @original = str\n    @data = parse_sexpr(str)\n  end\n  attr_reader :data, :original\n  \n  def to_sexpr\n    @data.to_sexpr\n  end\n  \n  private\n  \n  def parse_sexpr(str)\n    state = :token_start\n    tokens = []\n    word = \"\"\n    str.each_char do |char|\n      case state\n        \n      when :token_start\n        case char\n        when \"(\" \n          tokens << :lbr\n        when \")\" \n          tokens << :rbr\n        when /\\s/\n          \n        when  '\"'\n          state = :read_quoted_string\n          word = \"\"\n        else\n          state = :read_string_or_number\n          word = char\n        end\n        \n      when :read_quoted_string\n        case char\n        when '\"'\n          tokens << word\n          state = :token_start\n        else\n          word << char\n        end\n        \n      when :read_string_or_number\n        case char\n        when /\\s/\n          tokens << symbol_or_number(word)\n          state = :token_start\n        when ')'\n          tokens << symbol_or_number(word)\n          tokens << :rbr\n          state = :token_start\n        else\n          word << char\n        end\n      end\n    end\n    \n    sexpr_tokens_to_array(tokens)\n  end\n  \n  def symbol_or_number(word)\n    Integer(word)\n  rescue ArgumentError\n    begin \n      Float(word)\n    rescue ArgumentError\n      word.to_sym\n    end\n  end\n  \n  def sexpr_tokens_to_array(tokens, idx = 0)\n    result = []\n    while idx < tokens.length\n      case tokens[idx]\n      when :lbr\n        tmp, idx = sexpr_tokens_to_array(tokens, idx + 1)\n        result << tmp\n      when :rbr\n        return [result, idx]\n      else \n        result << tokens[idx]\n      end\n      idx += 1\n    end\n    result[0]\n  end\nend\n\nclass Object\n  def to_sexpr\n    self\n  end\nend\n\nclass String\n  def to_sexpr\n    self.match(/[\\s()]/) ? self.inspect : self\n  end\nend\n\nclass Symbol\n  alias :to_sexpr :to_s\nend\n\nclass Array\n  def to_sexpr\n    \"(%s)\" % inject([]) {|a, elem| a << elem.to_sexpr}.join(\" \")\n  end\nend\n\n\nsexpr = SExpr.new <<END\n((data \"quoted data\" 123 4.5)\n (data (!@\nEND\n \nputs \"original sexpr:\\n\nputs \"\\nruby data structure:\\n\nputs \"\\nand back to S-Expr:\\n\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Text;\n\n  public class SNode\n    {\n        private List<SNode> _items;\n        public string Name { get; set; }\n        public IReadOnlyCollection<SNode> Items { get { return _items.AsReadOnly(); } }\n        public SNode()\n        {\n            this._items = new List<SNode>();\n        }\n        public SNode(string name):this()\n        {\n            this.Name=name;\n        }\n        public void AddNode(SNode node)\n        {\n            this._items.Add(node);\n        }      \n    }\n\n    public class SNodeFull : SNode\n    {\n        private bool _isLeaf;\n        public bool IsLeaf { get => _isLeaf; }\n        public SNodeFull(bool isLeaf) : base()\n        {\n            this._isLeaf = isLeaf;\n        }\n\n        public SNodeFull(string name, bool isLeaf) : base(name)\n        {\n            this._isLeaf = isLeaf;\n        }\n\n        public SNodeFull RootNode { get; set; }\n\n        public void AddNode(SNodeFull node)\n        {\n            base.AddNode(node);\n            node.RootNode = this;\n        }\n    }\n"}
{"id": 150949, "name": "S-expressions", "source": "Translate Ruby to Java: class SExpr\n  def initialize(str)\n    @original = str\n    @data = parse_sexpr(str)\n  end\n  attr_reader :data, :original\n  \n  def to_sexpr\n    @data.to_sexpr\n  end\n  \n  private\n  \n  def parse_sexpr(str)\n    state = :token_start\n    tokens = []\n    word = \"\"\n    str.each_char do |char|\n      case state\n        \n      when :token_start\n        case char\n        when \"(\" \n          tokens << :lbr\n        when \")\" \n          tokens << :rbr\n        when /\\s/\n          \n        when  '\"'\n          state = :read_quoted_string\n          word = \"\"\n        else\n          state = :read_string_or_number\n          word = char\n        end\n        \n      when :read_quoted_string\n        case char\n        when '\"'\n          tokens << word\n          state = :token_start\n        else\n          word << char\n        end\n        \n      when :read_string_or_number\n        case char\n        when /\\s/\n          tokens << symbol_or_number(word)\n          state = :token_start\n        when ')'\n          tokens << symbol_or_number(word)\n          tokens << :rbr\n          state = :token_start\n        else\n          word << char\n        end\n      end\n    end\n    \n    sexpr_tokens_to_array(tokens)\n  end\n  \n  def symbol_or_number(word)\n    Integer(word)\n  rescue ArgumentError\n    begin \n      Float(word)\n    rescue ArgumentError\n      word.to_sym\n    end\n  end\n  \n  def sexpr_tokens_to_array(tokens, idx = 0)\n    result = []\n    while idx < tokens.length\n      case tokens[idx]\n      when :lbr\n        tmp, idx = sexpr_tokens_to_array(tokens, idx + 1)\n        result << tmp\n      when :rbr\n        return [result, idx]\n      else \n        result << tokens[idx]\n      end\n      idx += 1\n    end\n    result[0]\n  end\nend\n\nclass Object\n  def to_sexpr\n    self\n  end\nend\n\nclass String\n  def to_sexpr\n    self.match(/[\\s()]/) ? self.inspect : self\n  end\nend\n\nclass Symbol\n  alias :to_sexpr :to_s\nend\n\nclass Array\n  def to_sexpr\n    \"(%s)\" % inject([]) {|a, elem| a << elem.to_sexpr}.join(\" \")\n  end\nend\n\n\nsexpr = SExpr.new <<END\n((data \"quoted data\" 123 4.5)\n (data (!@\nEND\n \nputs \"original sexpr:\\n\nputs \"\\nruby data structure:\\n\nputs \"\\nand back to S-Expr:\\n\n", "target": "package jfkbits;\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.Reader;\nimport java.io.StreamTokenizer;\nimport java.io.StringReader;\nimport java.util.Iterator;\n\npublic class LispTokenizer implements Iterator<Token>\n{\n    \n    StreamTokenizer m_tokenizer;\n    IOException m_ioexn;\n\n    \n    public LispTokenizer(String src)\n    {\n        this(new StringReader(src));\n    }\n\n    \n    public LispTokenizer(Reader r)\n    {\n        if(r == null)\n            r = new StringReader(\"\");\n        BufferedReader buffrdr = new BufferedReader(r);\n        m_tokenizer = new StreamTokenizer(buffrdr);\n        m_tokenizer.resetSyntax(); \n\n        m_tokenizer.whitespaceChars(0, ' ');\n        m_tokenizer.wordChars(' '+1,255);\n        m_tokenizer.ordinaryChar('(');\n        m_tokenizer.ordinaryChar(')');\n        m_tokenizer.ordinaryChar('\\'');\n        m_tokenizer.commentChar(';');\n        m_tokenizer.quoteChar('\"');\n    }\n\n    public Token peekToken()\n    {\t\n        if(m_ioexn != null)\n            return null;\n        try\n        {\n            m_tokenizer.nextToken();\n        }\n        catch(IOException e)\n        {\n            m_ioexn = e;\n            return null;\n        }\n        if(m_tokenizer.ttype == StreamTokenizer.TT_EOF)\n            return null;\n        Token token = new Token(m_tokenizer);\n        m_tokenizer.pushBack();\n        return token;\n    }\n\n    public boolean hasNext()\n    {\n        if(m_ioexn != null)\n            return false;\n        try\n        {\n            m_tokenizer.nextToken();\n        }\n        catch(IOException e)\n        {\n            m_ioexn = e;\n            return false;\n        }\n        if(m_tokenizer.ttype == StreamTokenizer.TT_EOF)\n            return false;\n        m_tokenizer.pushBack();\n        return true;\n    }\n\n    \n    public IOException getIOException()\n    {\n        return m_ioexn;\n    }\n\n    public Token next()\n    {\n        try\n        {\n            m_tokenizer.nextToken();\n        }\n        catch(IOException e)\n        {\n            m_ioexn = e;\n            return null;\n        }\n\n        Token token = new Token(m_tokenizer);\n        return token;\n    }\n\n    public void remove()\n    {\n    }\n}\n"}
{"id": 150950, "name": "S-expressions", "source": "Translate Ruby to Python: class SExpr\n  def initialize(str)\n    @original = str\n    @data = parse_sexpr(str)\n  end\n  attr_reader :data, :original\n  \n  def to_sexpr\n    @data.to_sexpr\n  end\n  \n  private\n  \n  def parse_sexpr(str)\n    state = :token_start\n    tokens = []\n    word = \"\"\n    str.each_char do |char|\n      case state\n        \n      when :token_start\n        case char\n        when \"(\" \n          tokens << :lbr\n        when \")\" \n          tokens << :rbr\n        when /\\s/\n          \n        when  '\"'\n          state = :read_quoted_string\n          word = \"\"\n        else\n          state = :read_string_or_number\n          word = char\n        end\n        \n      when :read_quoted_string\n        case char\n        when '\"'\n          tokens << word\n          state = :token_start\n        else\n          word << char\n        end\n        \n      when :read_string_or_number\n        case char\n        when /\\s/\n          tokens << symbol_or_number(word)\n          state = :token_start\n        when ')'\n          tokens << symbol_or_number(word)\n          tokens << :rbr\n          state = :token_start\n        else\n          word << char\n        end\n      end\n    end\n    \n    sexpr_tokens_to_array(tokens)\n  end\n  \n  def symbol_or_number(word)\n    Integer(word)\n  rescue ArgumentError\n    begin \n      Float(word)\n    rescue ArgumentError\n      word.to_sym\n    end\n  end\n  \n  def sexpr_tokens_to_array(tokens, idx = 0)\n    result = []\n    while idx < tokens.length\n      case tokens[idx]\n      when :lbr\n        tmp, idx = sexpr_tokens_to_array(tokens, idx + 1)\n        result << tmp\n      when :rbr\n        return [result, idx]\n      else \n        result << tokens[idx]\n      end\n      idx += 1\n    end\n    result[0]\n  end\nend\n\nclass Object\n  def to_sexpr\n    self\n  end\nend\n\nclass String\n  def to_sexpr\n    self.match(/[\\s()]/) ? self.inspect : self\n  end\nend\n\nclass Symbol\n  alias :to_sexpr :to_s\nend\n\nclass Array\n  def to_sexpr\n    \"(%s)\" % inject([]) {|a, elem| a << elem.to_sexpr}.join(\" \")\n  end\nend\n\n\nsexpr = SExpr.new <<END\n((data \"quoted data\" 123 4.5)\n (data (!@\nEND\n \nputs \"original sexpr:\\n\nputs \"\\nruby data structure:\\n\nputs \"\\nand back to S-Expr:\\n\n", "target": "import re\n\ndbg = False\n\nterm_regex = r\n\ndef parse_sexp(sexp):\n    stack = []\n    out = []\n    if dbg: print(\"%-6s %-14s %-44s %-s\" % tuple(\"term value out stack\".split()))\n    for termtypes in re.finditer(term_regex, sexp):\n        term, value = [(t,v) for t,v in termtypes.groupdict().items() if v][0]\n        if dbg: print(\"%-7s %-14s %-44r %-r\" % (term, value, out, stack))\n        if   term == 'brackl':\n            stack.append(out)\n            out = []\n        elif term == 'brackr':\n            assert stack, \"Trouble with nesting of brackets\"\n            tmpout, out = out, stack.pop(-1)\n            out.append(tmpout)\n        elif term == 'num':\n            v = float(value)\n            if v.is_integer(): v = int(v)\n            out.append(v)\n        elif term == 'sq':\n            out.append(value[1:-1])\n        elif term == 's':\n            out.append(value)\n        else:\n            raise NotImplementedError(\"Error: %r\" % (term, value))\n    assert not stack, \"Trouble with nesting of brackets\"\n    return out[0]\n\ndef print_sexp(exp):\n    out = ''\n    if type(exp) == type([]):\n        out += '(' + ' '.join(print_sexp(x) for x in exp) + ')'\n    elif type(exp) == type('') and re.search(r'[\\s()]', exp):\n        out += '\"%s\"' % repr(exp)[1:-1].replace('\"', '\\\"')\n    else:\n        out += '%s' % exp\n    return out\n        \n    \nif __name__ == '__main__':\n    sexp = \n\n    print('Input S-expression: %r' % (sexp, ))\n    parsed = parse_sexp(sexp)\n    print(\"\\nParsed to Python:\", parsed)\n\n    print(\"\\nThen back to: '%s'\" % print_sexp(parsed))\n"}
{"id": 151369, "name": "Identity matrix", "source": "Translate Ruby to C#: def identity(size)\n  Array.new(size){|i| Array.new(size){|j| i==j ? 1 : 0}}\nend\n\n[4,5,6].each do |size|\n  puts size, identity(size).map {|r| r.to_s}, \"\"\nend\n", "target": "using System;\nusing System.Linq;\n\nnamespace IdentityMatrix\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            if (args.Length != 1)\n            {\n                Console.WriteLine(\"Requires exactly one argument\");\n                return;\n            }\n            int n;\n            if (!int.TryParse(args[0], out n))\n            {\n                Console.WriteLine(\"Requires integer parameter\");\n                return;\n            }\n\n            var identity =\n                Enumerable.Range(0, n).Select(i => Enumerable.Repeat(0, n).Select((z,j) => j == i ? 1 : 0).ToList()).ToList();\n            foreach (var row in identity)\n            {\n                foreach (var elem in row)\n                {\n                    Console.Write(\" \" + elem);\n                }\n                Console.WriteLine();\n            }\n            Console.ReadKey();\n        }\n    }\n}\n"}
{"id": 151370, "name": "Identity matrix", "source": "Translate Ruby to C#: def identity(size)\n  Array.new(size){|i| Array.new(size){|j| i==j ? 1 : 0}}\nend\n\n[4,5,6].each do |size|\n  puts size, identity(size).map {|r| r.to_s}, \"\"\nend\n", "target": "using System;\nusing System.Linq;\n\nnamespace IdentityMatrix\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            if (args.Length != 1)\n            {\n                Console.WriteLine(\"Requires exactly one argument\");\n                return;\n            }\n            int n;\n            if (!int.TryParse(args[0], out n))\n            {\n                Console.WriteLine(\"Requires integer parameter\");\n                return;\n            }\n\n            var identity =\n                Enumerable.Range(0, n).Select(i => Enumerable.Repeat(0, n).Select((z,j) => j == i ? 1 : 0).ToList()).ToList();\n            foreach (var row in identity)\n            {\n                foreach (var elem in row)\n                {\n                    Console.Write(\" \" + elem);\n                }\n                Console.WriteLine();\n            }\n            Console.ReadKey();\n        }\n    }\n}\n"}
{"id": 151373, "name": "Identity matrix", "source": "Translate Ruby to Java: def identity(size)\n  Array.new(size){|i| Array.new(size){|j| i==j ? 1 : 0}}\nend\n\n[4,5,6].each do |size|\n  puts size, identity(size).map {|r| r.to_s}, \"\"\nend\n", "target": "public class PrintIdentityMatrix {\n\n    public static void main(String[] args) {\n        int n = 5;\n        int[][] array = new int[n][n];\n\n        IntStream.range(0, n).forEach(i -> array[i][i] = 1);\n\n        Arrays.stream(array)\n                .map((int[] a) -> Arrays.toString(a))\n                .forEach(System.out::println);\n    }\n}\n"}
{"id": 151374, "name": "Identity matrix", "source": "Translate Ruby to Java: def identity(size)\n  Array.new(size){|i| Array.new(size){|j| i==j ? 1 : 0}}\nend\n\n[4,5,6].each do |size|\n  puts size, identity(size).map {|r| r.to_s}, \"\"\nend\n", "target": "public class PrintIdentityMatrix {\n\n    public static void main(String[] args) {\n        int n = 5;\n        int[][] array = new int[n][n];\n\n        IntStream.range(0, n).forEach(i -> array[i][i] = 1);\n\n        Arrays.stream(array)\n                .map((int[] a) -> Arrays.toString(a))\n                .forEach(System.out::println);\n    }\n}\n"}
{"id": 151375, "name": "Identity matrix", "source": "Translate Ruby to Python: def identity(size)\n  Array.new(size){|i| Array.new(size){|j| i==j ? 1 : 0}}\nend\n\n[4,5,6].each do |size|\n  puts size, identity(size).map {|r| r.to_s}, \"\"\nend\n", "target": "def identity(size):\n    matrix = [[0]*size for i in range(size)]\n    \n\n    for i in range(size):\n        matrix[i][i] = 1\n    \n    for rows in matrix:\n        for elements in rows:\n            print elements,\n        print \"\"\n"}
{"id": 151376, "name": "Identity matrix", "source": "Translate Ruby to Python: def identity(size)\n  Array.new(size){|i| Array.new(size){|j| i==j ? 1 : 0}}\nend\n\n[4,5,6].each do |size|\n  puts size, identity(size).map {|r| r.to_s}, \"\"\nend\n", "target": "def identity(size):\n    matrix = [[0]*size for i in range(size)]\n    \n\n    for i in range(size):\n        matrix[i][i] = 1\n    \n    for rows in matrix:\n        for elements in rows:\n            print elements,\n        print \"\"\n"}
{"id": 151637, "name": "Resistor mesh", "source": "Translate Ruby to C#: var (w, h) = (10, 10)\n\nvar v = h.of { w.of(0) } \nvar f = h.of { w.of(0) } \nvar d = h.of { w.of(0) } \nvar n = []               \n\nfor i in ^h {\n    for j in (1 ..^ w  ) { n[i][j] := [] << [i, j-1] }\n    for j in (0 ..^ w-1) { n[i][j] := [] << [i, j+1] }\n}\n\nfor j in ^w {\n    for i in (1 ..^ h  ) { n[i][j] := [] << [i-1, j] }\n    for i in (0 ..^ h-1) { n[i][j] := [] << [i+1, j] }\n}\n\nfunc set_boundary {\n    f[1][1] = 1; f[6][7] = -1;\n    v[1][1] = 1; v[6][7] = -1;\n}\n\nfunc calc_diff {\n    var total_diff = 0\n    for i,j in (^h ~X ^w) {\n        var w = n[i][j].map { |a| v.dig(a...) }.sum\n        d[i][j] = (w = (v[i][j] - w/n[i][j].len))\n        f[i][j] || (total_diff += w*w)\n    }\n    total_diff\n}\n\nfunc iter {\n    var diff = 1\n    while (diff > 1e-24) {\n        set_boundary()\n        diff = calc_diff()\n        for i,j in (^h ~X ^w) {\n            v[i][j] -= d[i][j]\n        }\n    }\n\n    var current = 3.of(0)\n    for i,j in (^h ~X ^w) {\n        current[ f[i][j] ] += (d[i][j] * n[i][j].len)\n    }\n    (current[1] - current[-1]) / 2\n}\n\nsay \"R = \n", "target": "using System;\nusing System.Collections.Generic;\n\nnamespace ResistorMesh {\n    class Node {\n        public Node(double v, int fixed_) {\n            V = v;\n            Fixed = fixed_;\n        }\n\n        public double V { get; set; }\n        public int Fixed { get; set; }\n    }\n\n    class Program {\n        static void SetBoundary(List<List<Node>> m) {\n            m[1][1].V = 1.0;\n            m[1][1].Fixed = 1;\n\n            m[6][7].V = -1.0;\n            m[6][7].Fixed = -1;\n        }\n\n        static double CalcuateDifference(List<List<Node>> m, List<List<Node>> d, int w, int h) {\n            double total = 0.0;\n            for (int i = 0; i < h; i++) {\n                for (int j = 0; j < w; j++) {\n                    double v = 0.0;\n                    int n = 0;\n                    if (i > 0) {\n                        v += m[i - 1][j].V;\n                        n++;\n                    }\n                    if (j > 0) {\n                        v += m[i][j - 1].V;\n                        n++;\n                    }\n                    if (i + 1 < h) {\n                        v += m[i + 1][j].V;\n                        n++;\n                    }\n                    if (j + 1 < w) {\n                        v += m[i][j + 1].V;\n                        n++;\n                    }\n                    v = m[i][j].V - v / n;\n                    d[i][j].V = v;\n                    if (m[i][j].Fixed == 0) {\n                        total += v * v;\n                    }\n                }\n            }\n            return total;\n        }\n\n        static double Iter(List<List<Node>> m, int w, int h) {\n            List<List<Node>> d = new List<List<Node>>(h);\n            for (int i = 0; i < h; i++) {\n                List<Node> t = new List<Node>(w);\n                for (int j = 0; j < w; j++) {\n                    t.Add(new Node(0.0, 0));\n                }\n                d.Add(t);\n            }\n\n            double[] curr = new double[3];\n            double diff = 1e10;\n\n            while (diff > 1e-24) {\n                SetBoundary(m);\n                diff = CalcuateDifference(m, d, w, h);\n                for (int i = 0; i < h; i++) {\n                    for (int j = 0; j < w; j++) {\n                        m[i][j].V -= d[i][j].V;\n                    }\n                }\n            }\n\n            for (int i = 0; i < h; i++) {\n                for (int j = 0; j < w; j++) {\n                    int k = 0;\n                    if (i != 0) k++;\n                    if (j != 0) k++;\n                    if (i < h - 1) k++;\n                    if (j < w - 1) k++;\n                    curr[m[i][j].Fixed + 1] += d[i][j].V * k;\n                }\n            }\n\n            return (curr[2] - curr[0]) / 2.0;\n        }\n\n        const int S = 10;\n        static void Main(string[] args) {\n            List<List<Node>> mesh = new List<List<Node>>(S);\n            for (int i = 0; i < S; i++) {\n                List<Node> t = new List<Node>(S);\n                for (int j = 0; j < S; j++) {\n                    t.Add(new Node(0.0, 0));\n                }\n                mesh.Add(t);\n            }\n\n            double r = 2.0 / Iter(mesh, S, S);\n            Console.WriteLine(\"R = {0:F15}\", r);\n        }\n    }\n}\n"}
{"id": 151638, "name": "Resistor mesh", "source": "Translate Ruby to C#: var (w, h) = (10, 10)\n\nvar v = h.of { w.of(0) } \nvar f = h.of { w.of(0) } \nvar d = h.of { w.of(0) } \nvar n = []               \n\nfor i in ^h {\n    for j in (1 ..^ w  ) { n[i][j] := [] << [i, j-1] }\n    for j in (0 ..^ w-1) { n[i][j] := [] << [i, j+1] }\n}\n\nfor j in ^w {\n    for i in (1 ..^ h  ) { n[i][j] := [] << [i-1, j] }\n    for i in (0 ..^ h-1) { n[i][j] := [] << [i+1, j] }\n}\n\nfunc set_boundary {\n    f[1][1] = 1; f[6][7] = -1;\n    v[1][1] = 1; v[6][7] = -1;\n}\n\nfunc calc_diff {\n    var total_diff = 0\n    for i,j in (^h ~X ^w) {\n        var w = n[i][j].map { |a| v.dig(a...) }.sum\n        d[i][j] = (w = (v[i][j] - w/n[i][j].len))\n        f[i][j] || (total_diff += w*w)\n    }\n    total_diff\n}\n\nfunc iter {\n    var diff = 1\n    while (diff > 1e-24) {\n        set_boundary()\n        diff = calc_diff()\n        for i,j in (^h ~X ^w) {\n            v[i][j] -= d[i][j]\n        }\n    }\n\n    var current = 3.of(0)\n    for i,j in (^h ~X ^w) {\n        current[ f[i][j] ] += (d[i][j] * n[i][j].len)\n    }\n    (current[1] - current[-1]) / 2\n}\n\nsay \"R = \n", "target": "using System;\nusing System.Collections.Generic;\n\nnamespace ResistorMesh {\n    class Node {\n        public Node(double v, int fixed_) {\n            V = v;\n            Fixed = fixed_;\n        }\n\n        public double V { get; set; }\n        public int Fixed { get; set; }\n    }\n\n    class Program {\n        static void SetBoundary(List<List<Node>> m) {\n            m[1][1].V = 1.0;\n            m[1][1].Fixed = 1;\n\n            m[6][7].V = -1.0;\n            m[6][7].Fixed = -1;\n        }\n\n        static double CalcuateDifference(List<List<Node>> m, List<List<Node>> d, int w, int h) {\n            double total = 0.0;\n            for (int i = 0; i < h; i++) {\n                for (int j = 0; j < w; j++) {\n                    double v = 0.0;\n                    int n = 0;\n                    if (i > 0) {\n                        v += m[i - 1][j].V;\n                        n++;\n                    }\n                    if (j > 0) {\n                        v += m[i][j - 1].V;\n                        n++;\n                    }\n                    if (i + 1 < h) {\n                        v += m[i + 1][j].V;\n                        n++;\n                    }\n                    if (j + 1 < w) {\n                        v += m[i][j + 1].V;\n                        n++;\n                    }\n                    v = m[i][j].V - v / n;\n                    d[i][j].V = v;\n                    if (m[i][j].Fixed == 0) {\n                        total += v * v;\n                    }\n                }\n            }\n            return total;\n        }\n\n        static double Iter(List<List<Node>> m, int w, int h) {\n            List<List<Node>> d = new List<List<Node>>(h);\n            for (int i = 0; i < h; i++) {\n                List<Node> t = new List<Node>(w);\n                for (int j = 0; j < w; j++) {\n                    t.Add(new Node(0.0, 0));\n                }\n                d.Add(t);\n            }\n\n            double[] curr = new double[3];\n            double diff = 1e10;\n\n            while (diff > 1e-24) {\n                SetBoundary(m);\n                diff = CalcuateDifference(m, d, w, h);\n                for (int i = 0; i < h; i++) {\n                    for (int j = 0; j < w; j++) {\n                        m[i][j].V -= d[i][j].V;\n                    }\n                }\n            }\n\n            for (int i = 0; i < h; i++) {\n                for (int j = 0; j < w; j++) {\n                    int k = 0;\n                    if (i != 0) k++;\n                    if (j != 0) k++;\n                    if (i < h - 1) k++;\n                    if (j < w - 1) k++;\n                    curr[m[i][j].Fixed + 1] += d[i][j].V * k;\n                }\n            }\n\n            return (curr[2] - curr[0]) / 2.0;\n        }\n\n        const int S = 10;\n        static void Main(string[] args) {\n            List<List<Node>> mesh = new List<List<Node>>(S);\n            for (int i = 0; i < S; i++) {\n                List<Node> t = new List<Node>(S);\n                for (int j = 0; j < S; j++) {\n                    t.Add(new Node(0.0, 0));\n                }\n                mesh.Add(t);\n            }\n\n            double r = 2.0 / Iter(mesh, S, S);\n            Console.WriteLine(\"R = {0:F15}\", r);\n        }\n    }\n}\n"}
{"id": 151641, "name": "Resistor mesh", "source": "Translate Ruby to Java: var (w, h) = (10, 10)\n\nvar v = h.of { w.of(0) } \nvar f = h.of { w.of(0) } \nvar d = h.of { w.of(0) } \nvar n = []               \n\nfor i in ^h {\n    for j in (1 ..^ w  ) { n[i][j] := [] << [i, j-1] }\n    for j in (0 ..^ w-1) { n[i][j] := [] << [i, j+1] }\n}\n\nfor j in ^w {\n    for i in (1 ..^ h  ) { n[i][j] := [] << [i-1, j] }\n    for i in (0 ..^ h-1) { n[i][j] := [] << [i+1, j] }\n}\n\nfunc set_boundary {\n    f[1][1] = 1; f[6][7] = -1;\n    v[1][1] = 1; v[6][7] = -1;\n}\n\nfunc calc_diff {\n    var total_diff = 0\n    for i,j in (^h ~X ^w) {\n        var w = n[i][j].map { |a| v.dig(a...) }.sum\n        d[i][j] = (w = (v[i][j] - w/n[i][j].len))\n        f[i][j] || (total_diff += w*w)\n    }\n    total_diff\n}\n\nfunc iter {\n    var diff = 1\n    while (diff > 1e-24) {\n        set_boundary()\n        diff = calc_diff()\n        for i,j in (^h ~X ^w) {\n            v[i][j] -= d[i][j]\n        }\n    }\n\n    var current = 3.of(0)\n    for i,j in (^h ~X ^w) {\n        current[ f[i][j] ] += (d[i][j] * n[i][j].len)\n    }\n    (current[1] - current[-1]) / 2\n}\n\nsay \"R = \n", "target": "import java.util.ArrayList;\nimport java.util.List;\n\npublic class ResistorMesh {\n    private static final int S = 10;\n\n    private static class Node {\n        double v;\n        int fixed;\n\n        Node(double v, int fixed) {\n            this.v = v;\n            this.fixed = fixed;\n        }\n    }\n\n    private static void setBoundary(List<List<Node>> m) {\n        m.get(1).get(1).v = 1.0;\n        m.get(1).get(1).fixed = 1;\n\n        m.get(6).get(7).v = -1.0;\n        m.get(6).get(7).fixed = -1;\n    }\n\n    private static double calcDiff(List<List<Node>> m, List<List<Node>> d, int w, int h) {\n        double total = 0.0;\n        for (int i = 0; i < h; ++i) {\n            for (int j = 0; j < w; ++j) {\n                double v = 0.0;\n                int n = 0;\n                if (i > 0) {\n                    v += m.get(i - 1).get(j).v;\n                    n++;\n                }\n                if (j > 0) {\n                    v += m.get(i).get(j - 1).v;\n                    n++;\n                }\n                if (i + 1 < h) {\n                    v += m.get(i + 1).get(j).v;\n                    n++;\n                }\n                if (j + 1 < w) {\n                    v += m.get(i).get(j + 1).v;\n                    n++;\n                }\n                v = m.get(i).get(j).v - v / n;\n                d.get(i).get(j).v = v;\n                if (m.get(i).get(j).fixed == 0) {\n                    total += v * v;\n                }\n            }\n        }\n        return total;\n    }\n\n    private static double iter(List<List<Node>> m, int w, int h) {\n        List<List<Node>> d = new ArrayList<>(h);\n        for (int i = 0; i < h; ++i) {\n            List<Node> t = new ArrayList<>(w);\n            for (int j = 0; j < w; ++j) {\n                t.add(new Node(0.0, 0));\n            }\n            d.add(t);\n        }\n\n        double[] cur = new double[3];\n        double diff = 1e10;\n\n        while (diff > 1e-24) {\n            setBoundary(m);\n            diff = calcDiff(m, d, w, h);\n            for (int i = 0; i < h; ++i) {\n                for (int j = 0; j < w; ++j) {\n                    m.get(i).get(j).v -= d.get(i).get(j).v;\n                }\n            }\n        }\n\n        for (int i = 0; i < h; ++i) {\n            for (int j = 0; j < w; ++j) {\n                int k = 0;\n                if (i != 0) k++;\n                if (j != 0) k++;\n                if (i < h - 1) k++;\n                if (j < w - 1) k++;\n                cur[m.get(i).get(j).fixed + 1] += d.get(i).get(j).v * k;\n            }\n        }\n\n        return (cur[2] - cur[0]) / 2.0;\n    }\n\n    public static void main(String[] args) {\n        List<List<Node>> mesh = new ArrayList<>(S);\n        for (int i = 0; i < S; ++i) {\n            List<Node> t = new ArrayList<>(S);\n            for (int j = 0; j < S; ++j) {\n                t.add(new Node(0.0, 0));\n            }\n            mesh.add(t);\n        }\n\n        double r = 2.0 / iter(mesh, S, S);\n        System.out.printf(\"R =\u00a0%.15f\", r);\n    }\n}\n"}
{"id": 151642, "name": "Resistor mesh", "source": "Translate Ruby to Java: var (w, h) = (10, 10)\n\nvar v = h.of { w.of(0) } \nvar f = h.of { w.of(0) } \nvar d = h.of { w.of(0) } \nvar n = []               \n\nfor i in ^h {\n    for j in (1 ..^ w  ) { n[i][j] := [] << [i, j-1] }\n    for j in (0 ..^ w-1) { n[i][j] := [] << [i, j+1] }\n}\n\nfor j in ^w {\n    for i in (1 ..^ h  ) { n[i][j] := [] << [i-1, j] }\n    for i in (0 ..^ h-1) { n[i][j] := [] << [i+1, j] }\n}\n\nfunc set_boundary {\n    f[1][1] = 1; f[6][7] = -1;\n    v[1][1] = 1; v[6][7] = -1;\n}\n\nfunc calc_diff {\n    var total_diff = 0\n    for i,j in (^h ~X ^w) {\n        var w = n[i][j].map { |a| v.dig(a...) }.sum\n        d[i][j] = (w = (v[i][j] - w/n[i][j].len))\n        f[i][j] || (total_diff += w*w)\n    }\n    total_diff\n}\n\nfunc iter {\n    var diff = 1\n    while (diff > 1e-24) {\n        set_boundary()\n        diff = calc_diff()\n        for i,j in (^h ~X ^w) {\n            v[i][j] -= d[i][j]\n        }\n    }\n\n    var current = 3.of(0)\n    for i,j in (^h ~X ^w) {\n        current[ f[i][j] ] += (d[i][j] * n[i][j].len)\n    }\n    (current[1] - current[-1]) / 2\n}\n\nsay \"R = \n", "target": "import java.util.ArrayList;\nimport java.util.List;\n\npublic class ResistorMesh {\n    private static final int S = 10;\n\n    private static class Node {\n        double v;\n        int fixed;\n\n        Node(double v, int fixed) {\n            this.v = v;\n            this.fixed = fixed;\n        }\n    }\n\n    private static void setBoundary(List<List<Node>> m) {\n        m.get(1).get(1).v = 1.0;\n        m.get(1).get(1).fixed = 1;\n\n        m.get(6).get(7).v = -1.0;\n        m.get(6).get(7).fixed = -1;\n    }\n\n    private static double calcDiff(List<List<Node>> m, List<List<Node>> d, int w, int h) {\n        double total = 0.0;\n        for (int i = 0; i < h; ++i) {\n            for (int j = 0; j < w; ++j) {\n                double v = 0.0;\n                int n = 0;\n                if (i > 0) {\n                    v += m.get(i - 1).get(j).v;\n                    n++;\n                }\n                if (j > 0) {\n                    v += m.get(i).get(j - 1).v;\n                    n++;\n                }\n                if (i + 1 < h) {\n                    v += m.get(i + 1).get(j).v;\n                    n++;\n                }\n                if (j + 1 < w) {\n                    v += m.get(i).get(j + 1).v;\n                    n++;\n                }\n                v = m.get(i).get(j).v - v / n;\n                d.get(i).get(j).v = v;\n                if (m.get(i).get(j).fixed == 0) {\n                    total += v * v;\n                }\n            }\n        }\n        return total;\n    }\n\n    private static double iter(List<List<Node>> m, int w, int h) {\n        List<List<Node>> d = new ArrayList<>(h);\n        for (int i = 0; i < h; ++i) {\n            List<Node> t = new ArrayList<>(w);\n            for (int j = 0; j < w; ++j) {\n                t.add(new Node(0.0, 0));\n            }\n            d.add(t);\n        }\n\n        double[] cur = new double[3];\n        double diff = 1e10;\n\n        while (diff > 1e-24) {\n            setBoundary(m);\n            diff = calcDiff(m, d, w, h);\n            for (int i = 0; i < h; ++i) {\n                for (int j = 0; j < w; ++j) {\n                    m.get(i).get(j).v -= d.get(i).get(j).v;\n                }\n            }\n        }\n\n        for (int i = 0; i < h; ++i) {\n            for (int j = 0; j < w; ++j) {\n                int k = 0;\n                if (i != 0) k++;\n                if (j != 0) k++;\n                if (i < h - 1) k++;\n                if (j < w - 1) k++;\n                cur[m.get(i).get(j).fixed + 1] += d.get(i).get(j).v * k;\n            }\n        }\n\n        return (cur[2] - cur[0]) / 2.0;\n    }\n\n    public static void main(String[] args) {\n        List<List<Node>> mesh = new ArrayList<>(S);\n        for (int i = 0; i < S; ++i) {\n            List<Node> t = new ArrayList<>(S);\n            for (int j = 0; j < S; ++j) {\n                t.add(new Node(0.0, 0));\n            }\n            mesh.add(t);\n        }\n\n        double r = 2.0 / iter(mesh, S, S);\n        System.out.printf(\"R =\u00a0%.15f\", r);\n    }\n}\n"}
{"id": 151643, "name": "Resistor mesh", "source": "Translate Ruby to Python: var (w, h) = (10, 10)\n\nvar v = h.of { w.of(0) } \nvar f = h.of { w.of(0) } \nvar d = h.of { w.of(0) } \nvar n = []               \n\nfor i in ^h {\n    for j in (1 ..^ w  ) { n[i][j] := [] << [i, j-1] }\n    for j in (0 ..^ w-1) { n[i][j] := [] << [i, j+1] }\n}\n\nfor j in ^w {\n    for i in (1 ..^ h  ) { n[i][j] := [] << [i-1, j] }\n    for i in (0 ..^ h-1) { n[i][j] := [] << [i+1, j] }\n}\n\nfunc set_boundary {\n    f[1][1] = 1; f[6][7] = -1;\n    v[1][1] = 1; v[6][7] = -1;\n}\n\nfunc calc_diff {\n    var total_diff = 0\n    for i,j in (^h ~X ^w) {\n        var w = n[i][j].map { |a| v.dig(a...) }.sum\n        d[i][j] = (w = (v[i][j] - w/n[i][j].len))\n        f[i][j] || (total_diff += w*w)\n    }\n    total_diff\n}\n\nfunc iter {\n    var diff = 1\n    while (diff > 1e-24) {\n        set_boundary()\n        diff = calc_diff()\n        for i,j in (^h ~X ^w) {\n            v[i][j] -= d[i][j]\n        }\n    }\n\n    var current = 3.of(0)\n    for i,j in (^h ~X ^w) {\n        current[ f[i][j] ] += (d[i][j] * n[i][j].len)\n    }\n    (current[1] - current[-1]) / 2\n}\n\nsay \"R = \n", "target": "DIFF_THRESHOLD = 1e-40\n\nclass Fixed:\n    FREE = 0\n    A = 1\n    B = 2\n\nclass Node:\n    __slots__ = [\"voltage\", \"fixed\"]\n    def __init__(self, v=0.0, f=Fixed.FREE):\n        self.voltage = v\n        self.fixed = f\n\ndef set_boundary(m):\n    m[1][1] = Node( 1.0, Fixed.A)\n    m[6][7] = Node(-1.0, Fixed.B)\n\ndef calc_difference(m, d):\n    h = len(m)\n    w = len(m[0])\n    total = 0.0\n\n    for i in xrange(h):\n        for j in xrange(w):\n            v = 0.0\n            n = 0\n            if i != 0:  v += m[i-1][j].voltage; n += 1\n            if j != 0:  v += m[i][j-1].voltage; n += 1\n            if i < h-1: v += m[i+1][j].voltage; n += 1\n            if j < w-1: v += m[i][j+1].voltage; n += 1\n            v = m[i][j].voltage - v / n\n\n            d[i][j].voltage = v\n            if m[i][j].fixed == Fixed.FREE:\n                total += v ** 2\n    return total\n\ndef iter(m):\n    h = len(m)\n    w = len(m[0])\n    difference = [[Node() for j in xrange(w)] for i in xrange(h)]\n\n    while True:\n        set_boundary(m) \n        if calc_difference(m, difference) < DIFF_THRESHOLD:\n            break\n        for i, di in enumerate(difference):\n            for j, dij in enumerate(di):\n                m[i][j].voltage -= dij.voltage\n\n    cur = [0.0] * 3\n    for i, di in enumerate(difference):\n        for j, dij in enumerate(di):\n            cur[m[i][j].fixed] += (dij.voltage *\n                (bool(i) + bool(j) + (i < h-1) + (j < w-1)))\n\n    return (cur[Fixed.A] - cur[Fixed.B]) / 2.0\n\ndef main():\n    w = h = 10\n    mesh = [[Node() for j in xrange(w)] for i in xrange(h)]\n    print \"R = %.16f\" % (2 / iter(mesh))\n\nmain()\n"}
{"id": 151644, "name": "Resistor mesh", "source": "Translate Ruby to Python: var (w, h) = (10, 10)\n\nvar v = h.of { w.of(0) } \nvar f = h.of { w.of(0) } \nvar d = h.of { w.of(0) } \nvar n = []               \n\nfor i in ^h {\n    for j in (1 ..^ w  ) { n[i][j] := [] << [i, j-1] }\n    for j in (0 ..^ w-1) { n[i][j] := [] << [i, j+1] }\n}\n\nfor j in ^w {\n    for i in (1 ..^ h  ) { n[i][j] := [] << [i-1, j] }\n    for i in (0 ..^ h-1) { n[i][j] := [] << [i+1, j] }\n}\n\nfunc set_boundary {\n    f[1][1] = 1; f[6][7] = -1;\n    v[1][1] = 1; v[6][7] = -1;\n}\n\nfunc calc_diff {\n    var total_diff = 0\n    for i,j in (^h ~X ^w) {\n        var w = n[i][j].map { |a| v.dig(a...) }.sum\n        d[i][j] = (w = (v[i][j] - w/n[i][j].len))\n        f[i][j] || (total_diff += w*w)\n    }\n    total_diff\n}\n\nfunc iter {\n    var diff = 1\n    while (diff > 1e-24) {\n        set_boundary()\n        diff = calc_diff()\n        for i,j in (^h ~X ^w) {\n            v[i][j] -= d[i][j]\n        }\n    }\n\n    var current = 3.of(0)\n    for i,j in (^h ~X ^w) {\n        current[ f[i][j] ] += (d[i][j] * n[i][j].len)\n    }\n    (current[1] - current[-1]) / 2\n}\n\nsay \"R = \n", "target": "DIFF_THRESHOLD = 1e-40\n\nclass Fixed:\n    FREE = 0\n    A = 1\n    B = 2\n\nclass Node:\n    __slots__ = [\"voltage\", \"fixed\"]\n    def __init__(self, v=0.0, f=Fixed.FREE):\n        self.voltage = v\n        self.fixed = f\n\ndef set_boundary(m):\n    m[1][1] = Node( 1.0, Fixed.A)\n    m[6][7] = Node(-1.0, Fixed.B)\n\ndef calc_difference(m, d):\n    h = len(m)\n    w = len(m[0])\n    total = 0.0\n\n    for i in xrange(h):\n        for j in xrange(w):\n            v = 0.0\n            n = 0\n            if i != 0:  v += m[i-1][j].voltage; n += 1\n            if j != 0:  v += m[i][j-1].voltage; n += 1\n            if i < h-1: v += m[i+1][j].voltage; n += 1\n            if j < w-1: v += m[i][j+1].voltage; n += 1\n            v = m[i][j].voltage - v / n\n\n            d[i][j].voltage = v\n            if m[i][j].fixed == Fixed.FREE:\n                total += v ** 2\n    return total\n\ndef iter(m):\n    h = len(m)\n    w = len(m[0])\n    difference = [[Node() for j in xrange(w)] for i in xrange(h)]\n\n    while True:\n        set_boundary(m) \n        if calc_difference(m, difference) < DIFF_THRESHOLD:\n            break\n        for i, di in enumerate(difference):\n            for j, dij in enumerate(di):\n                m[i][j].voltage -= dij.voltage\n\n    cur = [0.0] * 3\n    for i, di in enumerate(difference):\n        for j, dij in enumerate(di):\n            cur[m[i][j].fixed] += (dij.voltage *\n                (bool(i) + bool(j) + (i < h-1) + (j < w-1)))\n\n    return (cur[Fixed.A] - cur[Fixed.B]) / 2.0\n\ndef main():\n    w = h = 10\n    mesh = [[Node() for j in xrange(w)] for i in xrange(h)]\n    print \"R = %.16f\" % (2 / iter(mesh))\n\nmain()\n"}
{"id": 151814, "name": "RIPEMD-160", "source": "Translate Ruby to C#: require 'digest'\nputs Digest::RMD160.hexdigest('Rosetta Code')\n", "target": "using System;\nusing System.Security.Cryptography;\nusing System.Text;\n\nclass Program\n{\n    static void Main(string[] args)\n    {\n        string text = \"Rosetta Code\";\n        byte[] bytes = Encoding.ASCII.GetBytes(text);\n        RIPEMD160 myRIPEMD160 = RIPEMD160Managed.Create();\n        byte[] hashValue = myRIPEMD160.ComputeHash(bytes);\n        var hexdigest = BitConverter.ToString(hashValue).Replace(\"-\", \"\").ToLower();\n        Console.WriteLine(hexdigest);\n        Console.ReadLine();\n    }\n}\n"}
{"id": 151815, "name": "RIPEMD-160", "source": "Translate Ruby to C#: require 'digest'\nputs Digest::RMD160.hexdigest('Rosetta Code')\n", "target": "using System;\nusing System.Security.Cryptography;\nusing System.Text;\n\nclass Program\n{\n    static void Main(string[] args)\n    {\n        string text = \"Rosetta Code\";\n        byte[] bytes = Encoding.ASCII.GetBytes(text);\n        RIPEMD160 myRIPEMD160 = RIPEMD160Managed.Create();\n        byte[] hashValue = myRIPEMD160.ComputeHash(bytes);\n        var hexdigest = BitConverter.ToString(hashValue).Replace(\"-\", \"\").ToLower();\n        Console.WriteLine(hexdigest);\n        Console.ReadLine();\n    }\n}\n"}
{"id": 151816, "name": "RIPEMD-160", "source": "Translate Ruby to Java: require 'digest'\nputs Digest::RMD160.hexdigest('Rosetta Code')\n", "target": "import org.bouncycastle.crypto.digests.RIPEMD160Digest;\nimport org.bouncycastle.util.encoders.Hex;\n\npublic class RosettaRIPEMD160\n{\n    public static void main (String[] argv) throws Exception\n    {\n        byte[] r = \"Rosetta Code\".getBytes(\"US-ASCII\");\n        RIPEMD160Digest d = new RIPEMD160Digest();\n        d.update (r, 0, r.length);\n        byte[] o = new byte[d.getDigestSize()];\n        d.doFinal (o, 0);\n        Hex.encode (o, System.out);\n        System.out.println();\n    }\n}\n"}
{"id": 151817, "name": "RIPEMD-160", "source": "Translate Ruby to Java: require 'digest'\nputs Digest::RMD160.hexdigest('Rosetta Code')\n", "target": "import org.bouncycastle.crypto.digests.RIPEMD160Digest;\nimport org.bouncycastle.util.encoders.Hex;\n\npublic class RosettaRIPEMD160\n{\n    public static void main (String[] argv) throws Exception\n    {\n        byte[] r = \"Rosetta Code\".getBytes(\"US-ASCII\");\n        RIPEMD160Digest d = new RIPEMD160Digest();\n        d.update (r, 0, r.length);\n        byte[] o = new byte[d.getDigestSize()];\n        d.doFinal (o, 0);\n        Hex.encode (o, System.out);\n        System.out.println();\n    }\n}\n"}
{"id": 151818, "name": "RIPEMD-160", "source": "Translate Ruby to Python: require 'digest'\nputs Digest::RMD160.hexdigest('Rosetta Code')\n", "target": "Python 3.3.0 (v3.3.0:bd8afb90ebf2, Sep 29 2012, 10:57:17) [MSC v.1600 64 bit (AMD64)] on win32\nType \"copyright\", \"credits\" or \"license()\" for more information.\n>>> import hashlib\n>>> h = hashlib.new('ripemd160')\n>>> h.update(b\"Rosetta Code\")\n>>> h.hexdigest()\n'b3be159860842cebaa7174c8fff0aa9e50a5199f'\n>>>\n"}
{"id": 151819, "name": "RIPEMD-160", "source": "Translate Ruby to Python: require 'digest'\nputs Digest::RMD160.hexdigest('Rosetta Code')\n", "target": "Python 3.3.0 (v3.3.0:bd8afb90ebf2, Sep 29 2012, 10:57:17) [MSC v.1600 64 bit (AMD64)] on win32\nType \"copyright\", \"credits\" or \"license()\" for more information.\n>>> import hashlib\n>>> h = hashlib.new('ripemd160')\n>>> h.update(b\"Rosetta Code\")\n>>> h.hexdigest()\n'b3be159860842cebaa7174c8fff0aa9e50a5199f'\n>>>\n"}
{"id": 151962, "name": "OpenGL", "source": "Translate Ruby to C#: require 'rubygems'\nrequire 'gl'\nrequire 'glut'\n\ninclude Gl\ninclude Glut\n\npaint = lambda do\n  glClearColor(0.3,0.3,0.3,0.0)\n  glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT)\n\n  glShadeModel(GL_SMOOTH)\n \n  glLoadIdentity\n  glTranslatef(-15.0, -15.0, 0.0)\n \n  glBegin(GL_TRIANGLES)\n    glColor3f(1.0, 0.0, 0.0)\n    glVertex2f(0.0, 0.0)\n    glColor3f(0.0, 1.0, 0.0)\n    glVertex2f(30.0, 0.0)\n    glColor3f(0.0, 0.0, 1.0)\n    glVertex2f(0.0, 30.0)\n  glEnd\n \n  glFlush\nend\n \nreshape = lambda do |width, height|\n  glViewport(0, 0, width, height)\n  glMatrixMode(GL_PROJECTION)\n  glLoadIdentity\n  glOrtho(-30.0, 30.0, -30.0, 30.0, -30.0, 30.0)\n  glMatrixMode(GL_MODELVIEW)\nend\n \nglutInit\nglutInitWindowSize(640, 480)\nglutCreateWindow(\"Triangle\")\n\nglutDisplayFunc(paint)\nglutReshapeFunc(reshape)\n\nglutMainLoop\n", "target": "using OpenTK;\nusing OpenTK.Graphics;\nnamespace OpenGLTest\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            \n            GameWindow window = new GameWindow(640, 480, GraphicsMode.Default, \"OpenGL Example\");\n\n            GL.MatrixMode(MatrixMode.Projection);\n            GL.LoadIdentity();\n            GL.Ortho(-30.0, 30.0, -30.0, 30.0, -30.0, 30.0);\n            GL.MatrixMode(MatrixMode.Modelview);\n\n            \n            window.RenderFrame += new RenderFrameEvent(a_RenderFrame);\n            \n            window.Run();\n        }\n        static void a_RenderFrame(GameWindow sender, RenderFrameEventArgs e)\n        {\n            GL.ClearColor(0.3f, 0.3f, 0.3f, 0f);\n            GL.Clear(ClearBufferMask.ColorBufferBit | ClearBufferMask.DepthBufferBit);\n\n            GL.ShadeModel(ShadingModel.Smooth);\n\n            GL.LoadIdentity();\n            GL.Translate(-15.0f, -15.0f, 0.0f);\n\n            GL.Begin(BeginMode.Triangles);\n            GL.Color3(1.0f, 0.0f, 0.0f);\n            GL.Vertex2(0.0f, 0.0f);\n            GL.Color3(0.0f, 1.0f, 0.0f);\n            GL.Vertex2(30f, 0.0f);\n            GL.Color3(0.0f, 0.0f, 1.0f);\n            GL.Vertex2(0.0f, 30.0f);\n            GL.End();\n            \n            sender.SwapBuffers();\n        }\n    }\n}\n"}
{"id": 151963, "name": "OpenGL", "source": "Translate Ruby to Java: require 'rubygems'\nrequire 'gl'\nrequire 'glut'\n\ninclude Gl\ninclude Glut\n\npaint = lambda do\n  glClearColor(0.3,0.3,0.3,0.0)\n  glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT)\n\n  glShadeModel(GL_SMOOTH)\n \n  glLoadIdentity\n  glTranslatef(-15.0, -15.0, 0.0)\n \n  glBegin(GL_TRIANGLES)\n    glColor3f(1.0, 0.0, 0.0)\n    glVertex2f(0.0, 0.0)\n    glColor3f(0.0, 1.0, 0.0)\n    glVertex2f(30.0, 0.0)\n    glColor3f(0.0, 0.0, 1.0)\n    glVertex2f(0.0, 30.0)\n  glEnd\n \n  glFlush\nend\n \nreshape = lambda do |width, height|\n  glViewport(0, 0, width, height)\n  glMatrixMode(GL_PROJECTION)\n  glLoadIdentity\n  glOrtho(-30.0, 30.0, -30.0, 30.0, -30.0, 30.0)\n  glMatrixMode(GL_MODELVIEW)\nend\n \nglutInit\nglutInitWindowSize(640, 480)\nglutCreateWindow(\"Triangle\")\n\nglutDisplayFunc(paint)\nglutReshapeFunc(reshape)\n\nglutMainLoop\n", "target": "import org.lwjgl.LWJGLException;\nimport org.lwjgl.opengl.Display;\nimport org.lwjgl.opengl.DisplayMode;\nimport static org.lwjgl.opengl.GL11.*;\n\n\npublic class OpenGlExample {\n\n\tpublic void run() throws LWJGLException {\n\t\tDisplay.setDisplayMode(new DisplayMode(640, 480));\n\t\tDisplay.create();\n\t\t\n\t\tglMatrixMode(GL_PROJECTION);\n\t\tglLoadIdentity();\n\t\tglOrtho(-30, 30, -30, 30, -30, 30);\n\t\tglMatrixMode(GL_MODELVIEW);\n\t\t\n\t\twhile(!Display.isCloseRequested()) {\n\t\t\trender();\n\t\t\t\n\t\t\tDisplay.update();\n\t\t}\n\t\t\n\t\tDisplay.destroy();\n\t}\n\t\n\tpublic void render() {\n\t\t\n\t\tglClearColor(0.3f, 0.3f, 0.3f, 0.0f);\n\t\tglClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);\n\t\t\n\t\tglShadeModel(GL_SMOOTH);\n\t\t\n\t\tglLoadIdentity();\n\t\tglTranslatef(-15.0f, -15.0f, 0.0f);\n\t\t\n\t\tglBegin(GL_TRIANGLES);\n\t\tglColor3f(1.0f, 0.0f, 0.0f);\n\t\tglVertex2f(0.0f, 0.0f);\n\t\tglColor3f(0.0f, 1.0f, 0.0f);\n\t\tglVertex2f(30f, 0.0f);\n\t\tglColor3f(0.0f, 0.0f, 1.0f);\n\t\tglVertex2f(0.0f, 30.0f);\n\t\tglEnd();\n\t\t\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tOpenGlExample openGlExmpl = new OpenGlExample();\n\t\ttry {\n\t\t\topenGlExmpl.run();\n\t\t} catch(LWJGLException e) {\n\t\t\tSystem.err.println(e);\n\t\t}\n\t}\n\t\n}\n"}
{"id": 151964, "name": "OpenGL", "source": "Translate Ruby to Python: require 'rubygems'\nrequire 'gl'\nrequire 'glut'\n\ninclude Gl\ninclude Glut\n\npaint = lambda do\n  glClearColor(0.3,0.3,0.3,0.0)\n  glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT)\n\n  glShadeModel(GL_SMOOTH)\n \n  glLoadIdentity\n  glTranslatef(-15.0, -15.0, 0.0)\n \n  glBegin(GL_TRIANGLES)\n    glColor3f(1.0, 0.0, 0.0)\n    glVertex2f(0.0, 0.0)\n    glColor3f(0.0, 1.0, 0.0)\n    glVertex2f(30.0, 0.0)\n    glColor3f(0.0, 0.0, 1.0)\n    glVertex2f(0.0, 30.0)\n  glEnd\n \n  glFlush\nend\n \nreshape = lambda do |width, height|\n  glViewport(0, 0, width, height)\n  glMatrixMode(GL_PROJECTION)\n  glLoadIdentity\n  glOrtho(-30.0, 30.0, -30.0, 30.0, -30.0, 30.0)\n  glMatrixMode(GL_MODELVIEW)\nend\n \nglutInit\nglutInitWindowSize(640, 480)\nglutCreateWindow(\"Triangle\")\n\nglutDisplayFunc(paint)\nglutReshapeFunc(reshape)\n\nglutMainLoop\n", "target": "\n\n\nfrom OpenGL.GL import *\nfrom OpenGL.GLUT import *\n\ndef paint():\n    glClearColor(0.3,0.3,0.3,0.0)\n    glClear(GL_COLOR_BUFFER_BIT|GL_DEPTH_BUFFER_BIT)\n\n    glShadeModel(GL_SMOOTH)\n\n    glLoadIdentity()\n    glTranslatef(-15.0, -15.0, 0.0)\n\n    glBegin(GL_TRIANGLES)\n    glColor3f(1.0, 0.0, 0.0)\n    glVertex2f(0.0, 0.0)\n    glColor3f(0.0, 1.0, 0.0)\n    glVertex2f(30.0, 0.0)\n    glColor3f(0.0, 0.0, 1.0)\n    glVertex2f(0.0, 30.0)\n    glEnd()\n\n    glFlush()\n\ndef reshape(width, height):\n    glViewport(0, 0, width, height)\n    glMatrixMode(GL_PROJECTION)\n    glLoadIdentity()\n    glOrtho(-30.0, 30.0, -30.0, 30.0, -30.0, 30.0)\n    glMatrixMode(GL_MODELVIEW)\n\nif __name__ == '__main__':\n    glutInit(1, 1)\n    glutInitWindowSize(640, 480)\n    glutCreateWindow(\"Triangle\")\n\n    glutDisplayFunc(paint)\n    glutReshapeFunc(reshape)\n\n    glutMainLoop()\n"}
{"id": 152132, "name": "MD4", "source": "Translate Ruby to C#: require 'openssl'\nputs OpenSSL::Digest::MD4.hexdigest('Rosetta Code')\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nstatic class Md4\n{\n    public static string Md4Hash(this string input)\n    {\n        \n        List<byte> bytes = Encoding.ASCII.GetBytes(input).ToList();\n        uint bitCount = (uint)(bytes.Count) * 8;\n        bytes.Add(128);\n        while (bytes.Count % 64 != 56) bytes.Add(0);\n        var uints = new List<uint>();\n        for (int i = 0; i + 3 < bytes.Count; i += 4)\n            uints.Add(bytes[i] | (uint)bytes[i + 1] << 8 | (uint)bytes[i + 2] << 16 | (uint)bytes[i + 3] << 24);\n        uints.Add(bitCount);\n        uints.Add(0);\n\n        \n        uint a = 0x67452301, b = 0xefcdab89, c = 0x98badcfe, d = 0x10325476;\n        Func<uint, uint, uint> rol = (x, y) => x << (int)y | x >> 32 - (int)y;\n        for (int q = 0; q + 15 < uints.Count; q += 16)\n        {\n            var chunk = uints.GetRange(q, 16);\n            uint aa = a, bb = b, cc = c, dd = d;\n            Action<Func<uint, uint, uint, uint>, uint[]> round = (f, y) =>\n            {\n                foreach (uint i in new[] { y[0], y[1], y[2], y[3] })\n                {\n                    a = rol(a + f(b, c, d) + chunk[(int)(i + y[4])] + y[12], y[8]);\n                    d = rol(d + f(a, b, c) + chunk[(int)(i + y[5])] + y[12], y[9]);\n                    c = rol(c + f(d, a, b) + chunk[(int)(i + y[6])] + y[12], y[10]);\n                    b = rol(b + f(c, d, a) + chunk[(int)(i + y[7])] + y[12], y[11]);\n                }\n            };\n            round((x, y, z) => (x & y) | (~x & z), new uint[] { 0, 4, 8, 12, 0, 1, 2, 3, 3, 7, 11, 19, 0 });\n            round((x, y, z) => (x & y) | (x & z) | (y & z), new uint[] { 0, 1, 2, 3, 0, 4, 8, 12, 3, 5, 9, 13, 0x5a827999 });\n            round((x, y, z) => x ^ y ^ z, new uint[] { 0, 2, 1, 3, 0, 8, 4, 12, 3, 9, 11, 15, 0x6ed9eba1 });\n            a += aa; b += bb; c += cc; d += dd;\n        }\n\n        \n        byte[] outBytes = new[] { a, b, c, d }.SelectMany(BitConverter.GetBytes).ToArray();\n        return BitConverter.ToString(outBytes).Replace(\"-\", \"\").ToLower();\n    }\n    static void Main() { Console.WriteLine(\"Rosetta Code\".Md4Hash()); }\n}\n"}
{"id": 152133, "name": "MD4", "source": "Translate Ruby to C#: require 'openssl'\nputs OpenSSL::Digest::MD4.hexdigest('Rosetta Code')\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nstatic class Md4\n{\n    public static string Md4Hash(this string input)\n    {\n        \n        List<byte> bytes = Encoding.ASCII.GetBytes(input).ToList();\n        uint bitCount = (uint)(bytes.Count) * 8;\n        bytes.Add(128);\n        while (bytes.Count % 64 != 56) bytes.Add(0);\n        var uints = new List<uint>();\n        for (int i = 0; i + 3 < bytes.Count; i += 4)\n            uints.Add(bytes[i] | (uint)bytes[i + 1] << 8 | (uint)bytes[i + 2] << 16 | (uint)bytes[i + 3] << 24);\n        uints.Add(bitCount);\n        uints.Add(0);\n\n        \n        uint a = 0x67452301, b = 0xefcdab89, c = 0x98badcfe, d = 0x10325476;\n        Func<uint, uint, uint> rol = (x, y) => x << (int)y | x >> 32 - (int)y;\n        for (int q = 0; q + 15 < uints.Count; q += 16)\n        {\n            var chunk = uints.GetRange(q, 16);\n            uint aa = a, bb = b, cc = c, dd = d;\n            Action<Func<uint, uint, uint, uint>, uint[]> round = (f, y) =>\n            {\n                foreach (uint i in new[] { y[0], y[1], y[2], y[3] })\n                {\n                    a = rol(a + f(b, c, d) + chunk[(int)(i + y[4])] + y[12], y[8]);\n                    d = rol(d + f(a, b, c) + chunk[(int)(i + y[5])] + y[12], y[9]);\n                    c = rol(c + f(d, a, b) + chunk[(int)(i + y[6])] + y[12], y[10]);\n                    b = rol(b + f(c, d, a) + chunk[(int)(i + y[7])] + y[12], y[11]);\n                }\n            };\n            round((x, y, z) => (x & y) | (~x & z), new uint[] { 0, 4, 8, 12, 0, 1, 2, 3, 3, 7, 11, 19, 0 });\n            round((x, y, z) => (x & y) | (x & z) | (y & z), new uint[] { 0, 1, 2, 3, 0, 4, 8, 12, 3, 5, 9, 13, 0x5a827999 });\n            round((x, y, z) => x ^ y ^ z, new uint[] { 0, 2, 1, 3, 0, 8, 4, 12, 3, 9, 11, 15, 0x6ed9eba1 });\n            a += aa; b += bb; c += cc; d += dd;\n        }\n\n        \n        byte[] outBytes = new[] { a, b, c, d }.SelectMany(BitConverter.GetBytes).ToArray();\n        return BitConverter.ToString(outBytes).Replace(\"-\", \"\").ToLower();\n    }\n    static void Main() { Console.WriteLine(\"Rosetta Code\".Md4Hash()); }\n}\n"}
{"id": 152134, "name": "MD4", "source": "Translate Ruby to Java: require 'openssl'\nputs OpenSSL::Digest::MD4.hexdigest('Rosetta Code')\n", "target": "import org.bouncycastle.crypto.digests.MD4Digest;\nimport org.bouncycastle.util.encoders.Hex;\n\npublic class RosettaMD4\n{\n    public static void main (String[] argv) throws Exception\n    {\n        byte[] r = \"Rosetta Code\".getBytes(\"US-ASCII\");\n        MD4Digest d = new MD4Digest();\n        d.update (r, 0, r.length);\n        byte[] o = new byte[d.getDigestSize()];\n        d.doFinal (o, 0);\n        Hex.encode (o, System.out);\n        System.out.println();\n    }\n}\n"}
{"id": 152135, "name": "MD4", "source": "Translate Ruby to Python: require 'openssl'\nputs OpenSSL::Digest::MD4.hexdigest('Rosetta Code')\n", "target": "import hashlib\nprint hashlib.new(\"md4\",raw_input().encode('utf-16le')).hexdigest().upper()\n"}
{"id": 152136, "name": "MD4", "source": "Translate Ruby to Python: require 'openssl'\nputs OpenSSL::Digest::MD4.hexdigest('Rosetta Code')\n", "target": "import hashlib\nprint hashlib.new(\"md4\",raw_input().encode('utf-16le')).hexdigest().upper()\n"}
{"id": 152266, "name": "Object serialization", "source": "Translate Ruby to C#: class Being\n  def initialize(specialty=nil)\n    @specialty=specialty\n  end\n  def to_s\n    \"(object_id = \n  end\n  def to_s4Being\n    \"I am a collection of cooperative molecules with a talent for self-preservation.\"\n  end\nend\n\nclass Earthling < Being\n  def to_s4Being\n    \"I originate from a blue planet.\\n\"+\" \"*12+to_s4Earthling\n  end\nend\n\nclass Mammal < Earthling\n  def initialize(type)\n    @type=type\n  end\n  def to_s4Earthling\n    \"I am champion in taking care of my offspring and eating everything I can find, except mammals of type \n  end\nend\n\nclass Fish < Earthling\n  def initialize(iq)\n    @iq=(iq>1 ? :instrustableValue : iq)\n  end\n  def to_s4Earthling\n    \"Although I think I can think, I can't resist biting in hooks.\"\n  end\nend\n\nclass Moonling < Being\n  def to_s4Being\n    \"My name is Janneke Maan, and apparently some Earthlings will pay me a visit.\"\n  end\nend\n\ndiverseCollection=[]\ndiverseCollection << (marsian=Being.new(\"I come from Mars and like playing hide and seek.\"))\ndiverseCollection << (me=Mammal.new(:human))\ndiverseCollection << (nemo=Fish.new(0.99))\ndiverseCollection << (jannakeMaan=Moonling.new)\n\nputs \"BEGIN ORIGINAL DIVERSE COLLECTION\"\ndiverseCollection.each do |being|\n  puts \"\",being.to_s\nend\nputs \"END ORIGINAL DIVERSE COLLECTION\"\nputs \"\\n\"+\"*\"*50+\"\\n\\n\"\n\n\nFile.open('diverseCollection.bin','w') do |fo|\n  fo << Marshal.dump(diverseCollection)\nend\n\n\nsameDiverseCollection=Marshal.load(File.read('diverseCollection.bin'))\n\nputs \"BEGIN LOADED DIVERSE COLLECTION\"\nputs(\n     sameDiverseCollection.collect do |being|\n       being.to_s\n     end.join(\"\\n\\n\")\n     )\nputs \"END LOADED DIVERSE COLLECTION\"\n", "target": "using System;\nusing System.IO;\nusing System.Collections.Generic;\nusing System.Runtime.Serialization.Formatters.Binary;\n\nnamespace Object_serialization\n{\n  [Serializable] public class Being\n  {\n    public bool Alive { get; set; }\n  }\n\n  [Serializable] public class Animal: Being\n  {\n    public Animal() { }\n\n    public Animal(long id, string name, bool alive = true)\n    {\n      Id = id;\n      Name = name;\n      Alive = alive;\n    }\n\n    public long Id { get; set; }\n    public string Name { get; set; }\n\n    public void Print() { Console.WriteLine(\"{0}, id={1} is {2}\",\n      Name, Id, Alive ? \"alive\" : \"dead\"); }\n  }\n\n\n  internal class Program\n  {\n    private static void Main()\n    {\n      string path = \n        Environment.GetFolderPath(Environment.SpecialFolder.Desktop)+\"\\\\objects.dat\";\n\n      var n = new List<Animal>\n              {\n                new Animal(1, \"Fido\"),\n                new Animal(2, \"Lupo\"),\n                new Animal(7, \"Wanda\"),\n                new Animal(3, \"Kiki\", alive: false)\n              };\n\n      foreach(Animal animal in n)\n        animal.Print();\n\n      using(var stream = new FileStream(path, FileMode.Create, FileAccess.Write))\n        new BinaryFormatter().Serialize(stream, n);\n\n      n.Clear();\n      Console.WriteLine(\"---------------\");\n      List<Animal> m;\n\n      using(var stream = new FileStream(path, FileMode.Open, FileAccess.Read))\n        m = (List<Animal>) new BinaryFormatter().Deserialize(stream);\n\n      foreach(Animal animal in m)\n        animal.Print();\n    }\n  }\n}\n"}
{"id": 152268, "name": "Object serialization", "source": "Translate Ruby to Java: class Being\n  def initialize(specialty=nil)\n    @specialty=specialty\n  end\n  def to_s\n    \"(object_id = \n  end\n  def to_s4Being\n    \"I am a collection of cooperative molecules with a talent for self-preservation.\"\n  end\nend\n\nclass Earthling < Being\n  def to_s4Being\n    \"I originate from a blue planet.\\n\"+\" \"*12+to_s4Earthling\n  end\nend\n\nclass Mammal < Earthling\n  def initialize(type)\n    @type=type\n  end\n  def to_s4Earthling\n    \"I am champion in taking care of my offspring and eating everything I can find, except mammals of type \n  end\nend\n\nclass Fish < Earthling\n  def initialize(iq)\n    @iq=(iq>1 ? :instrustableValue : iq)\n  end\n  def to_s4Earthling\n    \"Although I think I can think, I can't resist biting in hooks.\"\n  end\nend\n\nclass Moonling < Being\n  def to_s4Being\n    \"My name is Janneke Maan, and apparently some Earthlings will pay me a visit.\"\n  end\nend\n\ndiverseCollection=[]\ndiverseCollection << (marsian=Being.new(\"I come from Mars and like playing hide and seek.\"))\ndiverseCollection << (me=Mammal.new(:human))\ndiverseCollection << (nemo=Fish.new(0.99))\ndiverseCollection << (jannakeMaan=Moonling.new)\n\nputs \"BEGIN ORIGINAL DIVERSE COLLECTION\"\ndiverseCollection.each do |being|\n  puts \"\",being.to_s\nend\nputs \"END ORIGINAL DIVERSE COLLECTION\"\nputs \"\\n\"+\"*\"*50+\"\\n\\n\"\n\n\nFile.open('diverseCollection.bin','w') do |fo|\n  fo << Marshal.dump(diverseCollection)\nend\n\n\nsameDiverseCollection=Marshal.load(File.read('diverseCollection.bin'))\n\nputs \"BEGIN LOADED DIVERSE COLLECTION\"\nputs(\n     sameDiverseCollection.collect do |being|\n       being.to_s\n     end.join(\"\\n\\n\")\n     )\nputs \"END LOADED DIVERSE COLLECTION\"\n", "target": "import java.io.*;\n\n\nclass Entity implements Serializable {\n    \n    \n    static final long serialVersionUID = 3504465751164822571L;\n    String name = \"Entity\";\n    public String toString() { return name; }\n}\n\nclass Person extends Entity implements Serializable {\n    static final long serialVersionUID = -9170445713373959735L;\n    Person() { name = \"Cletus\"; }\n}\n\npublic class SerializationTest {\n    public static void main(String[] args) {\n        Person instance1 = new Person();\n        System.out.println(instance1);\n\n        Entity instance2 = new Entity();\n        System.out.println(instance2);\n\n        \n        try {\n            ObjectOutput out = new ObjectOutputStream(new FileOutputStream(\"objects.dat\")); \n\n            out.writeObject(instance1); \n            out.writeObject(instance2);\n            out.close();\n            System.out.println(\"Serialized...\");\n        } catch (IOException e) {\n            System.err.println(\"Something screwed up while serializing\");\n            e.printStackTrace();\n            System.exit(1);\n        }\n\n        \n        try {\n            ObjectInput in = new ObjectInputStream(new FileInputStream(\"objects.dat\")); \n\n            Object readObject1 = in.readObject(); \n            Object readObject2 = in.readObject(); \n            in.close();\n            System.out.println(\"Deserialized...\");\n\n            System.out.println(readObject1);\n            System.out.println(readObject2);\n        } catch (IOException e) {\n            System.err.println(\"Something screwed up while deserializing\");\n            e.printStackTrace();\n            System.exit(1);\n        } catch (ClassNotFoundException e) {\n            System.err.println(\"Unknown class for deserialized object\");\n            e.printStackTrace();\n            System.exit(1);\n        }\n    }\n}\n"}
{"id": 152269, "name": "Object serialization", "source": "Translate Ruby to Python: class Being\n  def initialize(specialty=nil)\n    @specialty=specialty\n  end\n  def to_s\n    \"(object_id = \n  end\n  def to_s4Being\n    \"I am a collection of cooperative molecules with a talent for self-preservation.\"\n  end\nend\n\nclass Earthling < Being\n  def to_s4Being\n    \"I originate from a blue planet.\\n\"+\" \"*12+to_s4Earthling\n  end\nend\n\nclass Mammal < Earthling\n  def initialize(type)\n    @type=type\n  end\n  def to_s4Earthling\n    \"I am champion in taking care of my offspring and eating everything I can find, except mammals of type \n  end\nend\n\nclass Fish < Earthling\n  def initialize(iq)\n    @iq=(iq>1 ? :instrustableValue : iq)\n  end\n  def to_s4Earthling\n    \"Although I think I can think, I can't resist biting in hooks.\"\n  end\nend\n\nclass Moonling < Being\n  def to_s4Being\n    \"My name is Janneke Maan, and apparently some Earthlings will pay me a visit.\"\n  end\nend\n\ndiverseCollection=[]\ndiverseCollection << (marsian=Being.new(\"I come from Mars and like playing hide and seek.\"))\ndiverseCollection << (me=Mammal.new(:human))\ndiverseCollection << (nemo=Fish.new(0.99))\ndiverseCollection << (jannakeMaan=Moonling.new)\n\nputs \"BEGIN ORIGINAL DIVERSE COLLECTION\"\ndiverseCollection.each do |being|\n  puts \"\",being.to_s\nend\nputs \"END ORIGINAL DIVERSE COLLECTION\"\nputs \"\\n\"+\"*\"*50+\"\\n\\n\"\n\n\nFile.open('diverseCollection.bin','w') do |fo|\n  fo << Marshal.dump(diverseCollection)\nend\n\n\nsameDiverseCollection=Marshal.load(File.read('diverseCollection.bin'))\n\nputs \"BEGIN LOADED DIVERSE COLLECTION\"\nputs(\n     sameDiverseCollection.collect do |being|\n       being.to_s\n     end.join(\"\\n\\n\")\n     )\nputs \"END LOADED DIVERSE COLLECTION\"\n", "target": "\n\n\n\n\nimport pickle\n\nclass Entity:\n\tdef __init__(self):\n\t\tself.name = \"Entity\"\n\tdef printName(self):\n\t\tprint self.name\n\nclass Person(Entity): \n\tdef __init__(self): \n\t\tself.name = \"Cletus\" \n\ninstance1 = Person()\ninstance1.printName()\n\ninstance2 = Entity()\ninstance2.printName()\n\ntarget = file(\"objects.dat\", \"w\") \n\n\npickle.dump((instance1, instance2), target) \ntarget.close() \nprint \"Serialized...\"\n\n\ntarget = file(\"objects.dat\") \ni1, i2 = pickle.load(target)\nprint \"Unserialized...\"\n\ni1.printName()\ni2.printName()\n"}
{"id": 152679, "name": "Averages_Mean angle", "source": "Translate Ruby to C#: require 'complex' \n\ndef deg2rad(d)\n  d * Math::PI / 180\nend\n \ndef rad2deg(r)\n  r * 180 / Math::PI\nend\n\ndef mean_angle(deg)\n  rad2deg((deg.inject(0) {|z, d| z + Complex.polar(1, deg2rad(d))} / deg.length).arg)\nend\n\n[[350, 10], [90, 180, 270, 360], [10, 20, 30]].each {|angles|\n  puts \"The mean angle of %p is: %f degrees\" % [angles, mean_angle(angles)]\n}\n", "target": "using System;\nusing System.Linq;\nusing static System.Math;\nclass Program\n{\n    static double MeanAngle(double[] angles)\n    {\n        var x = angles.Sum(a => Cos(a * PI / 180)) / angles.Length;\n        var y = angles.Sum(a => Sin(a * PI / 180)) / angles.Length;\n        return Atan2(y, x) * 180 / PI;\n    }\n    static void Main()\n    {\n        Action<double[]> printMean = x => Console.WriteLine(\"{0:0.###}\", MeanAngle(x));\n        printMean(new double[] { 350, 10 });\n        printMean(new double[] { 90, 180, 270, 360 });\n        printMean(new double[] { 10, 20, 30 });\n    }\n}\n"}
{"id": 152680, "name": "Averages_Mean angle", "source": "Translate Ruby to C#: require 'complex' \n\ndef deg2rad(d)\n  d * Math::PI / 180\nend\n \ndef rad2deg(r)\n  r * 180 / Math::PI\nend\n\ndef mean_angle(deg)\n  rad2deg((deg.inject(0) {|z, d| z + Complex.polar(1, deg2rad(d))} / deg.length).arg)\nend\n\n[[350, 10], [90, 180, 270, 360], [10, 20, 30]].each {|angles|\n  puts \"The mean angle of %p is: %f degrees\" % [angles, mean_angle(angles)]\n}\n", "target": "using System;\nusing System.Linq;\nusing static System.Math;\nclass Program\n{\n    static double MeanAngle(double[] angles)\n    {\n        var x = angles.Sum(a => Cos(a * PI / 180)) / angles.Length;\n        var y = angles.Sum(a => Sin(a * PI / 180)) / angles.Length;\n        return Atan2(y, x) * 180 / PI;\n    }\n    static void Main()\n    {\n        Action<double[]> printMean = x => Console.WriteLine(\"{0:0.###}\", MeanAngle(x));\n        printMean(new double[] { 350, 10 });\n        printMean(new double[] { 90, 180, 270, 360 });\n        printMean(new double[] { 10, 20, 30 });\n    }\n}\n"}
{"id": 152683, "name": "Averages_Mean angle", "source": "Translate Ruby to Java: require 'complex' \n\ndef deg2rad(d)\n  d * Math::PI / 180\nend\n \ndef rad2deg(r)\n  r * 180 / Math::PI\nend\n\ndef mean_angle(deg)\n  rad2deg((deg.inject(0) {|z, d| z + Complex.polar(1, deg2rad(d))} / deg.length).arg)\nend\n\n[[350, 10], [90, 180, 270, 360], [10, 20, 30]].each {|angles|\n  puts \"The mean angle of %p is: %f degrees\" % [angles, mean_angle(angles)]\n}\n", "target": "import java.util.Arrays;\n\npublic class AverageMeanAngle {\n\n    public static void main(String[] args) {\n        printAverageAngle(350.0, 10.0);\n        printAverageAngle(90.0, 180.0, 270.0, 360.0);\n        printAverageAngle(10.0, 20.0, 30.0);\n        printAverageAngle(370.0);\n        printAverageAngle(180.0);\n    }\n\n    private static void printAverageAngle(double... sample) {\n        double meanAngle = getMeanAngle(sample);\n        System.out.printf(\"The mean angle of %s is %s%n\", Arrays.toString(sample), meanAngle);\n    }\n\n    public static double getMeanAngle(double... anglesDeg) {\n        double x = 0.0;\n        double y = 0.0;\n\n        for (double angleD : anglesDeg) {\n            double angleR = Math.toRadians(angleD);\n            x += Math.cos(angleR);\n            y += Math.sin(angleR);\n        }\n        double avgR = Math.atan2(y / anglesDeg.length, x / anglesDeg.length);\n        return Math.toDegrees(avgR);\n    }\n}\n"}
{"id": 152684, "name": "Averages_Mean angle", "source": "Translate Ruby to Java: require 'complex' \n\ndef deg2rad(d)\n  d * Math::PI / 180\nend\n \ndef rad2deg(r)\n  r * 180 / Math::PI\nend\n\ndef mean_angle(deg)\n  rad2deg((deg.inject(0) {|z, d| z + Complex.polar(1, deg2rad(d))} / deg.length).arg)\nend\n\n[[350, 10], [90, 180, 270, 360], [10, 20, 30]].each {|angles|\n  puts \"The mean angle of %p is: %f degrees\" % [angles, mean_angle(angles)]\n}\n", "target": "import java.util.Arrays;\n\npublic class AverageMeanAngle {\n\n    public static void main(String[] args) {\n        printAverageAngle(350.0, 10.0);\n        printAverageAngle(90.0, 180.0, 270.0, 360.0);\n        printAverageAngle(10.0, 20.0, 30.0);\n        printAverageAngle(370.0);\n        printAverageAngle(180.0);\n    }\n\n    private static void printAverageAngle(double... sample) {\n        double meanAngle = getMeanAngle(sample);\n        System.out.printf(\"The mean angle of %s is %s%n\", Arrays.toString(sample), meanAngle);\n    }\n\n    public static double getMeanAngle(double... anglesDeg) {\n        double x = 0.0;\n        double y = 0.0;\n\n        for (double angleD : anglesDeg) {\n            double angleR = Math.toRadians(angleD);\n            x += Math.cos(angleR);\n            y += Math.sin(angleR);\n        }\n        double avgR = Math.atan2(y / anglesDeg.length, x / anglesDeg.length);\n        return Math.toDegrees(avgR);\n    }\n}\n"}
{"id": 152685, "name": "Averages_Mean angle", "source": "Translate Ruby to Python: require 'complex' \n\ndef deg2rad(d)\n  d * Math::PI / 180\nend\n \ndef rad2deg(r)\n  r * 180 / Math::PI\nend\n\ndef mean_angle(deg)\n  rad2deg((deg.inject(0) {|z, d| z + Complex.polar(1, deg2rad(d))} / deg.length).arg)\nend\n\n[[350, 10], [90, 180, 270, 360], [10, 20, 30]].each {|angles|\n  puts \"The mean angle of %p is: %f degrees\" % [angles, mean_angle(angles)]\n}\n", "target": ">>> from cmath import rect, phase\n>>> from math import radians, degrees\n>>> def mean_angle(deg):\n...     return degrees(phase(sum(rect(1, radians(d)) for d in deg)/len(deg)))\n... \n>>> for angles in [[350, 10], [90, 180, 270, 360], [10, 20, 30]]:\n...     print('The mean angle of', angles, 'is:', round(mean_angle(angles), 12), 'degrees')\n...     \nThe mean angle of [350, 10] is: -0.0 degrees\nThe mean angle of [90, 180, 270, 360] is: -90.0 degrees\nThe mean angle of [10, 20, 30] is: 20.0 degrees\n>>>\n"}
{"id": 152686, "name": "Averages_Mean angle", "source": "Translate Ruby to Python: require 'complex' \n\ndef deg2rad(d)\n  d * Math::PI / 180\nend\n \ndef rad2deg(r)\n  r * 180 / Math::PI\nend\n\ndef mean_angle(deg)\n  rad2deg((deg.inject(0) {|z, d| z + Complex.polar(1, deg2rad(d))} / deg.length).arg)\nend\n\n[[350, 10], [90, 180, 270, 360], [10, 20, 30]].each {|angles|\n  puts \"The mean angle of %p is: %f degrees\" % [angles, mean_angle(angles)]\n}\n", "target": ">>> from cmath import rect, phase\n>>> from math import radians, degrees\n>>> def mean_angle(deg):\n...     return degrees(phase(sum(rect(1, radians(d)) for d in deg)/len(deg)))\n... \n>>> for angles in [[350, 10], [90, 180, 270, 360], [10, 20, 30]]:\n...     print('The mean angle of', angles, 'is:', round(mean_angle(angles), 12), 'degrees')\n...     \nThe mean angle of [350, 10] is: -0.0 degrees\nThe mean angle of [90, 180, 270, 360] is: -90.0 degrees\nThe mean angle of [10, 20, 30] is: 20.0 degrees\n>>>\n"}
{"id": 153245, "name": "Least common multiple", "source": "Translate Ruby to C#: irb(main):001:0> 12.lcm 18\n=> 36\n", "target": "Using System;\nclass Program\n{\n    static int gcd(int m, int n)\n    {\n        return n == 0 ? Math.Abs(m) : gcd(n, n % m);\n    }\n    static int lcm(int m, int n)\n    {\n        return Math.Abs(m * n) / gcd(m, n);\n    }\n    static void Main()\n    {\n        Console.WriteLine(\"lcm(12,18)=\" + lcm(12,18));\n    }\n}\n"}
{"id": 153246, "name": "Least common multiple", "source": "Translate Ruby to C#: irb(main):001:0> 12.lcm 18\n=> 36\n", "target": "Using System;\nclass Program\n{\n    static int gcd(int m, int n)\n    {\n        return n == 0 ? Math.Abs(m) : gcd(n, n % m);\n    }\n    static int lcm(int m, int n)\n    {\n        return Math.Abs(m * n) / gcd(m, n);\n    }\n    static void Main()\n    {\n        Console.WriteLine(\"lcm(12,18)=\" + lcm(12,18));\n    }\n}\n"}
{"id": 153249, "name": "Least common multiple", "source": "Translate Ruby to Java: irb(main):001:0> 12.lcm 18\n=> 36\n", "target": "import java.util.Scanner;\n\npublic class LCM{\n   public static void main(String[] args){\n      Scanner aScanner = new Scanner(System.in);\n   \n      \n      System.out.print(\"Enter the value of m:\");\n      int m = aScanner.nextInt();\n      System.out.print(\"Enter the value of n:\");\n      int n = aScanner.nextInt();\n      int lcm = (n == m || n == 1) ? m :(m == 1 ? n : 0);\n      \n      if (lcm == 0) {\n         int mm = m, nn = n;\n         while (mm != nn) {\n             while (mm < nn) { mm += m; }\n             while (nn < mm) { nn += n; }\n         }  \n         lcm = mm;\n      }\n      System.out.println(\"lcm(\" + m + \", \" + n + \") = \" + lcm);\n   }\n}\n"}
{"id": 153250, "name": "Least common multiple", "source": "Translate Ruby to Java: irb(main):001:0> 12.lcm 18\n=> 36\n", "target": "import java.util.Scanner;\n\npublic class LCM{\n   public static void main(String[] args){\n      Scanner aScanner = new Scanner(System.in);\n   \n      \n      System.out.print(\"Enter the value of m:\");\n      int m = aScanner.nextInt();\n      System.out.print(\"Enter the value of n:\");\n      int n = aScanner.nextInt();\n      int lcm = (n == m || n == 1) ? m :(m == 1 ? n : 0);\n      \n      if (lcm == 0) {\n         int mm = m, nn = n;\n         while (mm != nn) {\n             while (mm < nn) { mm += m; }\n             while (nn < mm) { nn += n; }\n         }  \n         lcm = mm;\n      }\n      System.out.println(\"lcm(\" + m + \", \" + n + \") = \" + lcm);\n   }\n}\n"}
{"id": 153251, "name": "Least common multiple", "source": "Translate Ruby to Python: irb(main):001:0> 12.lcm 18\n=> 36\n", "target": ">>> import fractions\n>>> def lcm(a,b): return abs(a * b) / fractions.gcd(a,b) if a and b else 0\n\n>>> lcm(12, 18)\n36\n>>> lcm(-6, 14)\n42\n>>> assert lcm(0, 2) == lcm(2, 0) == 0\n>>>\n"}
{"id": 153252, "name": "Least common multiple", "source": "Translate Ruby to Python: irb(main):001:0> 12.lcm 18\n=> 36\n", "target": ">>> import fractions\n>>> def lcm(a,b): return abs(a * b) / fractions.gcd(a,b) if a and b else 0\n\n>>> lcm(12, 18)\n36\n>>> lcm(-6, 14)\n42\n>>> assert lcm(0, 2) == lcm(2, 0) == 0\n>>>\n"}
{"id": 153474, "name": "Set puzzle", "source": "Translate Ruby to C#: COLORS   = %i(red green purple) \nSYMBOLS  = %i(oval squiggle diamond)\nNUMBERS  = %i(one two three)\nSHADINGS = %i(solid open striped)\nDECK = COLORS.product(SYMBOLS, NUMBERS, SHADINGS)\n\ndef get_all_sets(hand) \n  hand.combination(3).select do |candidate|\n    grouped_features = candidate.flatten.group_by{|f| f}\n    grouped_features.values.none?{|v| v.size == 2}\n  end\nend\n\ndef get_puzzle_and_answer(hand_size, num_sets_goal)\n  begin\n    hand = DECK.sample(hand_size)\n    sets = get_all_sets(hand)\n  end until sets.size == num_sets_goal\n  [hand, sets]\nend\n\ndef print_cards(cards)\n  puts cards.map{|card| \" \u00a0%-8s\" * 4 % card}\n  puts\nend\n\ndef set_puzzle(deal, goal=deal/2)\n  puzzle, sets = get_puzzle_and_answer(deal, goal)\n  puts \"Dealt \n  print_cards(puzzle)\n  puts \"Containing \n  sets.each{|set| print_cards(set)}\nend\n\nset_puzzle(9)\nset_puzzle(12)\n", "target": "using System;\nusing System.Collections.Generic;\nusing static System.Linq.Enumerable;\n\npublic static class SetPuzzle\n{\n    static readonly Feature[] numbers  = { (1, \"One\"), (2, \"Two\"), (3, \"Three\") };\n    static readonly Feature[] colors   = { (1, \"Red\"), (2, \"Green\"), (3, \"Purple\") };\n    static readonly Feature[] shadings = { (1, \"Open\"), (2, \"Striped\"), (3, \"Solid\") };\n    static readonly Feature[] symbols  = { (1, \"Oval\"), (2, \"Squiggle\"), (3, \"Diamond\") };\n\n    private readonly struct Feature\n    {\n        public Feature(int value, string name) => (Value, Name) = (value, name);\n        public int Value { get; }\n        public string Name { get; }\n        public static implicit operator int(Feature f) => f.Value;\n        public static implicit operator Feature((int value, string name) t) => new Feature(t.value, t.name);\n        public override string ToString() => Name;\n    }\n\n    private readonly struct Card : IEquatable<Card>\n    {\n        public Card(Feature number, Feature color, Feature shading, Feature symbol) =>\n            (Number, Color, Shading, Symbol) = (number, color, shading, symbol);\n\n        public Feature Number { get; }\n        public Feature Color { get; }\n        public Feature Shading { get; }\n        public Feature Symbol { get; }\n\n        public override string ToString() => $\"{Number} {Color} {Shading} {Symbol}(s)\";\n        public bool Equals(Card other) => Number == other.Number && Color == other.Color && Shading == other.Shading && Symbol == other.Symbol;\n    }\n\n    public static void Main() {\n        Card[] deck = (\n            from number in numbers\n            from color in colors\n            from shading in shadings\n            from symbol in symbols\n            select new Card(number, color, shading, symbol)\n        ).ToArray();\n        var random = new Random();\n\n        Deal(deck, 9, 4, random);\n        Console.WriteLine();\n        Console.WriteLine();\n        Deal(deck, 12, 6, random);\n    }\n\n    static void Deal(Card[] deck, int size, int target, Random random) {\n        List<(Card a, Card b, Card c)> sets;\n        do {\n            Shuffle(deck, random.Next);\n            sets = (\n                from i in 0.To(size - 2)\n                from j in (i + 1).To(size - 1)\n                from k in (j + 1).To(size)\n                select (deck[i], deck[j], deck[k])\n            ).Where(IsSet).ToList();\n        } while (sets.Count != target);\n        Console.WriteLine(\"The board:\");\n        foreach (Card card in deck.Take(size)) Console.WriteLine(card);\n        Console.WriteLine();\n        Console.WriteLine(\"Sets:\");\n        foreach (var s in sets) Console.WriteLine(s);\n    }\n\n    static void Shuffle<T>(T[] array, Func<int, int, int> rng) {\n        for (int i = 0; i < array.Length; i++) {\n            int r = rng(i, array.Length);\n            (array[r], array[i]) = (array[i], array[r]);\n        }\n    }\n\n    static bool IsSet((Card a, Card b, Card c) t) =>\n        AreSameOrDifferent(t.a.Number, t.b.Number, t.c.Number) &&\n        AreSameOrDifferent(t.a.Color, t.b.Color, t.c.Color) &&\n        AreSameOrDifferent(t.a.Shading, t.b.Shading, t.c.Shading) &&\n        AreSameOrDifferent(t.a.Symbol, t.b.Symbol, t.c.Symbol);\n\n    static bool AreSameOrDifferent(int a, int b, int c) => (a + b + c) % 3 == 0;\n    static IEnumerable<int> To(this int start, int end) => Range(start, end - start - 1);\n}\n"}
{"id": 153476, "name": "Set puzzle", "source": "Translate Ruby to Java: COLORS   = %i(red green purple) \nSYMBOLS  = %i(oval squiggle diamond)\nNUMBERS  = %i(one two three)\nSHADINGS = %i(solid open striped)\nDECK = COLORS.product(SYMBOLS, NUMBERS, SHADINGS)\n\ndef get_all_sets(hand) \n  hand.combination(3).select do |candidate|\n    grouped_features = candidate.flatten.group_by{|f| f}\n    grouped_features.values.none?{|v| v.size == 2}\n  end\nend\n\ndef get_puzzle_and_answer(hand_size, num_sets_goal)\n  begin\n    hand = DECK.sample(hand_size)\n    sets = get_all_sets(hand)\n  end until sets.size == num_sets_goal\n  [hand, sets]\nend\n\ndef print_cards(cards)\n  puts cards.map{|card| \" \u00a0%-8s\" * 4 % card}\n  puts\nend\n\ndef set_puzzle(deal, goal=deal/2)\n  puzzle, sets = get_puzzle_and_answer(deal, goal)\n  puts \"Dealt \n  print_cards(puzzle)\n  puts \"Containing \n  sets.each{|set| print_cards(set)}\nend\n\nset_puzzle(9)\nset_puzzle(12)\n", "target": "import java.util.*;\n\npublic class SetPuzzle {\n\n    enum Color {\n\n        GREEN(0), PURPLE(1), RED(2);\n\n        private Color(int v) {\n            val = v;\n        }\n        public final int val;\n    }\n\n    enum Number {\n\n        ONE(0), TWO(1), THREE(2);\n\n        private Number(int v) {\n            val = v;\n        }\n        public final int val;\n    }\n\n    enum Symbol {\n\n        OVAL(0), DIAMOND(1), SQUIGGLE(2);\n\n        private Symbol(int v) {\n            val = v;\n        }\n        public final int val;\n    }\n\n    enum Fill {\n\n        OPEN(0), STRIPED(1), SOLID(2);\n\n        private Fill(int v) {\n            val = v;\n        }\n        public final int val;\n    }\n\n    private static class Card implements Comparable<Card> {\n\n        Color c;\n        Number n;\n        Symbol s;\n        Fill f;\n\n        @Override\n        public String toString() {\n            return String.format(\"[Card: %s, %s, %s, %s]\", c, n, s, f);\n        }\n\n        @Override\n        public int compareTo(Card o) {\n            return (c.val - o.c.val) * 10 + (n.val - o.n.val);\n        }\n    }\n    private static Card[] deck;\n\n    public static void main(String[] args) {\n        deck = new Card[81];\n        Color[] colors = Color.values();\n        Number[] numbers = Number.values();\n        Symbol[] symbols = Symbol.values();\n        Fill[] fillmodes = Fill.values();\n        for (int i = 0; i < deck.length; i++) {\n            deck[i] = new Card();\n            deck[i].c = colors[i / 27];\n            deck[i].n = numbers[(i / 9) % 3];\n            deck[i].s = symbols[(i / 3) % 3];\n            deck[i].f = fillmodes[i % 3];\n        }\n        findSets(12);\n    }\n\n    private static void findSets(int numCards) {\n        int target = numCards / 2;\n        Card[] cards;\n        Card[][] sets = new Card[target][3];\n        int cnt;\n        do {\n            Collections.shuffle(Arrays.asList(deck));\n            cards = Arrays.copyOfRange(deck, 0, numCards);\n            cnt = 0;\n\n            outer:\n            for (int i = 0; i < cards.length - 2; i++) {\n                for (int j = i + 1; j < cards.length - 1; j++) {\n                    for (int k = j + 1; k < cards.length; k++) {\n                        if (validSet(cards[i], cards[j], cards[k])) {\n                            if (cnt < target)\n                                sets[cnt] = new Card[]{cards[i], cards[j], cards[k]};\n                            if (++cnt > target) {\n                                break outer;\n                            }\n                        }\n                    }\n                }\n            }\n        } while (cnt != target);\n\n        Arrays.sort(cards);\n\n        System.out.printf(\"GIVEN %d CARDS:\\n\\n\", numCards);\n        for (Card c : cards) {\n            System.out.println(c);\n        }\n        System.out.println();\n\n        System.out.println(\"FOUND \" + target + \" SETS:\\n\");\n        for (Card[] set : sets) {\n            for (Card c : set) {\n                System.out.println(c);\n            }\n            System.out.println();\n        }\n    }\n\n    private static boolean validSet(Card c1, Card c2, Card c3) {\n        int tot = 0;\n        tot += (c1.c.val + c2.c.val + c3.c.val) % 3;\n        tot += (c1.n.val + c2.n.val + c3.n.val) % 3;\n        tot += (c1.s.val + c2.s.val + c3.s.val) % 3;\n        tot += (c1.f.val + c2.f.val + c3.f.val) % 3;\n        return tot == 0;\n    }\n}\n"}
{"id": 153477, "name": "Set puzzle", "source": "Translate Ruby to Python: COLORS   = %i(red green purple) \nSYMBOLS  = %i(oval squiggle diamond)\nNUMBERS  = %i(one two three)\nSHADINGS = %i(solid open striped)\nDECK = COLORS.product(SYMBOLS, NUMBERS, SHADINGS)\n\ndef get_all_sets(hand) \n  hand.combination(3).select do |candidate|\n    grouped_features = candidate.flatten.group_by{|f| f}\n    grouped_features.values.none?{|v| v.size == 2}\n  end\nend\n\ndef get_puzzle_and_answer(hand_size, num_sets_goal)\n  begin\n    hand = DECK.sample(hand_size)\n    sets = get_all_sets(hand)\n  end until sets.size == num_sets_goal\n  [hand, sets]\nend\n\ndef print_cards(cards)\n  puts cards.map{|card| \" \u00a0%-8s\" * 4 % card}\n  puts\nend\n\ndef set_puzzle(deal, goal=deal/2)\n  puzzle, sets = get_puzzle_and_answer(deal, goal)\n  puts \"Dealt \n  print_cards(puzzle)\n  puts \"Containing \n  sets.each{|set| print_cards(set)}\nend\n\nset_puzzle(9)\nset_puzzle(12)\n", "target": "\n    \nfrom itertools import product, combinations\nfrom random import sample\n \n\nfeatures = [ 'green purple red'.split(),\n             'one two three'.split(),\n             'oval diamond squiggle'.split(),\n             'open striped solid'.split() ]\n             \ndeck = list(product(list(range(3)), repeat=4))\n\ndealt = 9\n \n\ndef printcard(card):\n    print(' '.join('%8s' % f[i] for f,i in zip(features, card)))\n \ndef getdeal(dealt=dealt):\n    deal = sample(deck, dealt)\n    return deal\n \ndef getsets(deal):\n    good_feature_count = set([1, 3])\n    sets = [ comb for comb in combinations(deal, 3)\n             if all( [(len(set(feature)) in good_feature_count)\n                     for feature in zip(*comb)]\n                   ) ]\n    return sets\n \ndef printit(deal, sets):\n    print('Dealt %i cards:' % len(deal))\n    for card in deal: printcard(card)\n    print('\\nFound %i sets:' % len(sets))\n    for s in sets:\n        for card in s: printcard(card)\n        print('')\n \nif __name__ == '__main__':\n    while True:\n        deal = getdeal()\n        sets = getsets(deal)\n        if len(sets) == dealt / 2:\n           break\n    printit(deal, sets)\n"}
{"id": 153699, "name": "Averages_Simple moving average", "source": "Translate Ruby to C#: def sma(n) Proc(Float64, Float64)\n\ta = Array(Float64).new\n\t->(x : Float64) {\n\t\ta.shift if a.size == n\n\t\ta.push x\n\t\ta.sum / a.size.to_f\n\t}\nend\n\nsma3, sma5 = sma(3), sma(5)\n\n\n(1.upto(5).to_a + 5.downto(1).to_a).each do |n|\n\tprintf \"%d: sma3 =\u00a0%.3f - sma5 =\u00a0%.3f\\n\", n, sma3.call(n.to_f), sma5.call(n.to_f)\nend\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\nnamespace SMA {\n    class Program {\n        static void Main(string[] args) {\n            var nums = Enumerable.Range(1, 5).Select(n => (double)n);\n            nums = nums.Concat(nums.Reverse());\n\n            var sma3 = SMA(3);\n            var sma5 = SMA(5);\n\n            foreach (var n in nums) {\n                Console.WriteLine(\"{0}    (sma3) {1,-16} (sma5) {2,-16}\", n, sma3(n), sma5(n));\n            }\n        }\n\n        static Func<double, double> SMA(int p) {\n            Queue<double> s = new Queue<double>(p);\n            return (x) => {\n                if (s.Count >= p) {\n                    s.Dequeue();\n                }\n                s.Enqueue(x);\n                return s.Average();\n            };\n        }\n    }\n}\n"}
{"id": 153701, "name": "Averages_Simple moving average", "source": "Translate Ruby to Java: def sma(n) Proc(Float64, Float64)\n\ta = Array(Float64).new\n\t->(x : Float64) {\n\t\ta.shift if a.size == n\n\t\ta.push x\n\t\ta.sum / a.size.to_f\n\t}\nend\n\nsma3, sma5 = sma(3), sma(5)\n\n\n(1.upto(5).to_a + 5.downto(1).to_a).each do |n|\n\tprintf \"%d: sma3 =\u00a0%.3f - sma5 =\u00a0%.3f\\n\", n, sma3.call(n.to_f), sma5.call(n.to_f)\nend\n", "target": "import java.util.LinkedList;\nimport java.util.Queue;\n\npublic class MovingAverage {\n    private final Queue<Double> window = new LinkedList<Double>();\n    private final int period;\n    private double sum;\n\n    public MovingAverage(int period) {\n        assert period > 0 : \"Period must be a positive integer\";\n        this.period = period;\n    }\n\n    public void newNum(double num) {\n        sum += num;\n        window.add(num);\n        if (window.size() > period) {\n            sum -= window.remove();\n        }\n    }\n\n    public double getAvg() {\n        if (window.isEmpty()) return 0.0; \n        return sum / window.size();\n    }\n\n    public static void main(String[] args) {\n        double[] testData = {1, 2, 3, 4, 5, 5, 4, 3, 2, 1};\n        int[] windowSizes = {3, 5};\n        for (int windSize : windowSizes) {\n            MovingAverage ma = new MovingAverage(windSize);\n            for (double x : testData) {\n                ma.newNum(x);\n                System.out.println(\"Next number = \" + x + \", SMA = \" + ma.getAvg());\n            }\n            System.out.println();\n        }\n    }\n}\n"}
{"id": 153702, "name": "Averages_Simple moving average", "source": "Translate Ruby to Python: def sma(n) Proc(Float64, Float64)\n\ta = Array(Float64).new\n\t->(x : Float64) {\n\t\ta.shift if a.size == n\n\t\ta.push x\n\t\ta.sum / a.size.to_f\n\t}\nend\n\nsma3, sma5 = sma(3), sma(5)\n\n\n(1.upto(5).to_a + 5.downto(1).to_a).each do |n|\n\tprintf \"%d: sma3 =\u00a0%.3f - sma5 =\u00a0%.3f\\n\", n, sma3.call(n.to_f), sma5.call(n.to_f)\nend\n", "target": "from collections import deque\n\ndef simplemovingaverage(period):\n    assert period == int(period) and period > 0, \"Period must be an integer >0\"\n    \n    summ = n = 0.0\n    values = deque([0.0] * period)     \n\n    def sma(x):\n        nonlocal summ, n\n        \n        values.append(x)\n        summ += x - values.popleft()\n        n = min(n+1, period)\n        return summ / n\n\n    return sma\n"}
{"id": 153942, "name": "Literals_Integer", "source": "Translate Ruby to C#: 727 == 0b1011010111  \n727 == 0x2d7   \n727 == 0o1327  \n727 == 01327   \n\n12345 == 12_345 \n", "target": "int a = 42;\nint b = 0x2a;\n"}
{"id": 153944, "name": "Literals_Integer", "source": "Translate Ruby to Java: 727 == 0b1011010111  \n727 == 0x2d7   \n727 == 0o1327  \n727 == 01327   \n\n12345 == 12_345 \n", "target": "public class IntegerLiterals {\n    public static void main(String[] args) {\n        System.out.println( 727 == 0x2d7 && \n                            727 == 01327   );\n    }\n}\n"}
{"id": 153945, "name": "Literals_Integer", "source": "Translate Ruby to Python: 727 == 0b1011010111  \n727 == 0x2d7   \n727 == 0o1327  \n727 == 01327   \n\n12345 == 12_345 \n", "target": ">>> \n>>> 0b1011010111 == 0o1327 == 727 == 0x2d7\nTrue\n>>>\n"}
{"id": 154150, "name": "JortSort", "source": "Translate Ruby to C#: def jort_sort(array)\n  array == array.sort\nend\n", "target": "using System;\n\nclass Program\n{\n  public static bool JortSort<T>(T[] array) where T : IComparable, IEquatable<T>\n  {\n    \n    T[] originalArray = (T[]) array.Clone();\n    Array.Sort(array);\n\n    \n    for (var i = 0; i < originalArray.Length; i++)\n    {\n      if (!Equals(originalArray[i], array[i]))\n      {\n        return false;\n      }\n    }\n\n    return true;\n  }\n}\n"}
{"id": 154152, "name": "JortSort", "source": "Translate Ruby to Java: def jort_sort(array)\n  array == array.sort\nend\n", "target": "public class JortSort {\n    public static void main(String[] args) {\n        System.out.println(jortSort(new int[]{1, 2, 3}));\n    }\n\n    static boolean jortSort(int[] arr) {\n        return true;\n    }\n}\n"}
{"id": 154153, "name": "JortSort", "source": "Translate Ruby to Python: def jort_sort(array)\n  array == array.sort\nend\n", "target": ">>> def jortsort(sequence):\n\treturn list(sequence) == sorted(sequence)\n>>> for data in [(1,2,4,3), (14,6,8), ['a', 'c'], ['s', 'u', 'x'], 'CVGH', 'PQRST']:\n\tprint(f'jortsort({repr(data)}) is {jortsort(data)}')\njortsort((1, 2, 4, 3)) is False\njortsort((14, 6, 8)) is False\njortsort(['a', 'c']) is True\njortsort(['s', 'u', 'x']) is True\njortsort('CVGH') is False\njortsort('PQRST') is True\n>>>\n"}
{"id": 154410, "name": "String concatenation", "source": "Translate Ruby to C#: s = \"hello\"\n\nputs \"\n\nputs s                     \n\nputs s + \" literal\"        \n\nputs s                     \n\n\n\ns += \" literal\"\nputs s                     \ns << \" another\" \nputs s                     \n\ns = \"hello\"\nputs s.concat(\" literal\")  \nputs s                     \nputs s.prepend(\"Alice said: \")  \nputs s                     \n", "target": "using System;\nnamespace StringConcatenation\n{\n  class Program {\n    static void Main() {\n        String s = scope (\"hello\");\n        Console.Write(s);\n        Console.WriteLine(\" literal\");\n        s.Append(\" literal\");\n        Console.WriteLine(s);\n    }\n  }\n}\n"}
{"id": 154412, "name": "String concatenation", "source": "Translate Ruby to Java: s = \"hello\"\n\nputs \"\n\nputs s                     \n\nputs s + \" literal\"        \n\nputs s                     \n\n\n\ns += \" literal\"\nputs s                     \ns << \" another\" \nputs s                     \n\ns = \"hello\"\nputs s.concat(\" literal\")  \nputs s                     \nputs s.prepend(\"Alice said: \")  \nputs s                     \n", "target": "public class Str{\n   public static void main(String[] args){\n      String s = \"hello\";\n      System.out.println(s + \" literal\");\n      String s2 = s + \" literal\";\n      System.out.println(s2);\n   }\n}\n"}
{"id": 154413, "name": "String concatenation", "source": "Translate Ruby to Python: s = \"hello\"\n\nputs \"\n\nputs s                     \n\nputs s + \" literal\"        \n\nputs s                     \n\n\n\ns += \" literal\"\nputs s                     \ns << \" another\" \nputs s                     \n\ns = \"hello\"\nputs s.concat(\" literal\")  \nputs s                     \nputs s.prepend(\"Alice said: \")  \nputs s                     \n", "target": "s1 = \"hello\"\nprint s1 + \" world\"\n\ns2 = s1 + \" world\"\nprint s2\n"}
{"id": 154580, "name": "Program termination", "source": "Translate Ruby to C#: if problem\n  exit(1)\nend\n\n\nif problem\n  abort   \nend\n", "target": "if (problem)\n{\n   Environment.Exit(1);\n}\n"}
{"id": 154582, "name": "Program termination", "source": "Translate Ruby to Java: if problem\n  exit(1)\nend\n\n\nif problem\n  abort   \nend\n", "target": "if(problem){\n   System.exit(integerErrorCode); \n   \n   \n   \n}\n"}
{"id": 154936, "name": "Thue-Morse", "source": "Translate Ruby to C#: steps = 6\n\ntmp = \"\"\ns1 = \"0\"\ns2 = \"1\"\n\nsteps.times {\n  tmp = s1\n  s1 += s2\n  s2 += tmp\n}\n\nputs s1\n", "target": "using System;\nusing System.Text;\n\nnamespace ThueMorse\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            Sequence(6);\n        }\n\n        public static void Sequence(int steps)\n        {\n            var sb1 = new StringBuilder(\"0\");\n            var sb2 = new StringBuilder(\"1\");\n            for (int i = 0; i < steps; i++)\n            {\n                var tmp = sb1.ToString();\n                sb1.Append(sb2);\n                sb2.Append(tmp);\n            }\n            Console.WriteLine(sb1);\n            Console.ReadLine();\n        }\n    }\n}\n"}
{"id": 154937, "name": "Thue-Morse", "source": "Translate Ruby to C#: steps = 6\n\ntmp = \"\"\ns1 = \"0\"\ns2 = \"1\"\n\nsteps.times {\n  tmp = s1\n  s1 += s2\n  s2 += tmp\n}\n\nputs s1\n", "target": "using System;\nusing System.Text;\n\nnamespace ThueMorse\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            Sequence(6);\n        }\n\n        public static void Sequence(int steps)\n        {\n            var sb1 = new StringBuilder(\"0\");\n            var sb2 = new StringBuilder(\"1\");\n            for (int i = 0; i < steps; i++)\n            {\n                var tmp = sb1.ToString();\n                sb1.Append(sb2);\n                sb2.Append(tmp);\n            }\n            Console.WriteLine(sb1);\n            Console.ReadLine();\n        }\n    }\n}\n"}
{"id": 154940, "name": "Thue-Morse", "source": "Translate Ruby to Java: steps = 6\n\ntmp = \"\"\ns1 = \"0\"\ns2 = \"1\"\n\nsteps.times {\n  tmp = s1\n  s1 += s2\n  s2 += tmp\n}\n\nputs s1\n", "target": "public class ThueMorse {\n\n    public static void main(String[] args) {\n        sequence(6);\n    }\n\n    public static void sequence(int steps) {\n        StringBuilder sb1 = new StringBuilder(\"0\");\n        StringBuilder sb2 = new StringBuilder(\"1\");\n        for (int i = 0; i < steps; i++) {\n            String tmp = sb1.toString();\n            sb1.append(sb2);\n            sb2.append(tmp);\n        }\n        System.out.println(sb1);\n    }\n}\n"}
{"id": 154941, "name": "Thue-Morse", "source": "Translate Ruby to Java: steps = 6\n\ntmp = \"\"\ns1 = \"0\"\ns2 = \"1\"\n\nsteps.times {\n  tmp = s1\n  s1 += s2\n  s2 += tmp\n}\n\nputs s1\n", "target": "public class ThueMorse {\n\n    public static void main(String[] args) {\n        sequence(6);\n    }\n\n    public static void sequence(int steps) {\n        StringBuilder sb1 = new StringBuilder(\"0\");\n        StringBuilder sb2 = new StringBuilder(\"1\");\n        for (int i = 0; i < steps; i++) {\n            String tmp = sb1.toString();\n            sb1.append(sb2);\n            sb2.append(tmp);\n        }\n        System.out.println(sb1);\n    }\n}\n"}
{"id": 154942, "name": "Thue-Morse", "source": "Translate Ruby to Python: steps = 6\n\ntmp = \"\"\ns1 = \"0\"\ns2 = \"1\"\n\nsteps.times {\n  tmp = s1\n  s1 += s2\n  s2 += tmp\n}\n\nputs s1\n", "target": "m='0'\nprint(m)\nfor i in range(0,6):\n     m0=m\n     m=m.replace('0','a')\n     m=m.replace('1','0')\n     m=m.replace('a','1')\n     m=m0+m\n     print(m)\n"}
{"id": 154943, "name": "Thue-Morse", "source": "Translate Ruby to Python: steps = 6\n\ntmp = \"\"\ns1 = \"0\"\ns2 = \"1\"\n\nsteps.times {\n  tmp = s1\n  s1 += s2\n  s2 += tmp\n}\n\nputs s1\n", "target": "m='0'\nprint(m)\nfor i in range(0,6):\n     m0=m\n     m=m.replace('0','a')\n     m=m.replace('1','0')\n     m=m.replace('a','1')\n     m=m0+m\n     print(m)\n"}
{"id": 155297, "name": "Repeat a string", "source": "Translate Ruby to Python: puts \"ha\" * 5\n", "target": "def setup():\n    rep = repeat(\"ha\", 5)\n    println(rep)\n\ndef repeat(s, times):\n    return s * times\n"}
{"id": 155534, "name": "Ethiopian multiplication", "source": "Translate Ruby to C#: def halve(x) = x/2\ndef double(x) = x*2\n\n\ndef ethiopian_multiply(a, b)\n  product = 0\n  while a >= 1 \n    p [a, b, a.even? ? \"STRIKE\" : \"KEEP\"] if $DEBUG\n    product += b unless a.even?\n    a = halve(a)\n    b = double(b)\n  end\n  product\nend\n\n\ndef rec_ethiopian_multiply(a, b)\n  return 0 if a < 1\n  p [a, b, a.even? ? \"STRIKE\" : \"KEEP\"] if $DEBUG\n  (a.even? ? 0 : b) + rec_ethiopian_multiply(halve(a), double(b))\nend\n\n$DEBUG = true   \na, b = 20, 5\nputs \"\n", "target": "using System;\nusing System.Linq;\n\nnamespace RosettaCode.Tasks\n{\n\tpublic static class EthiopianMultiplication_Task\n\t{\n\t\tpublic static void Test ( )\n\t\t{\n\t\t\tConsole.WriteLine ( \"Ethiopian Multiplication\" );\n\t\t\tint A = 17, B = 34;\n\t\t\tConsole.WriteLine ( \"Recursion: {0}*{1}={2}\", A, B, EM_Recursion ( A, B ) );\n\t\t\tConsole.WriteLine ( \"Linq: {0}*{1}={2}\", A, B, EM_Linq ( A, B ) );\n\t\t\tConsole.WriteLine ( \"Loop: {0}*{1}={2}\", A, B, EM_Loop ( A, B ) );\n\t\t\tConsole.WriteLine ( );\n\t\t}\n\n\t\tpublic static int Halve ( this int p_Number )\n\t\t{\n\t\t\treturn p_Number >> 1;\n\t\t}\n\t\tpublic static int Double ( this int p_Number )\n\t\t{\n\t\t\treturn p_Number << 1;\n\t\t}\n\t\tpublic static bool IsEven ( this int p_Number )\n\t\t{\n\t\t\treturn ( p_Number % 2 ) == 0;\n\t\t}\n\n\t\tpublic static int EM_Recursion ( int p_NumberA, int p_NumberB )\n\t\t{\n\t\t\t\n\t\t\treturn p_NumberA == 1 ? p_NumberB : EM_Recursion ( p_NumberA.Halve ( ), p_NumberB.Double ( ) ) + ( p_NumberA.IsEven ( ) ? 0 : p_NumberB );\n\t\t}\n\t\tpublic static int EM_Linq ( int p_NumberA, int p_NumberB )\n\t\t{\n\t\t\t\n\t\t\t\n\t\t\treturn Enumerable.Range ( 1, Convert.ToInt32 ( Math.Log ( p_NumberA, Math.E ) / Math.Log ( 2, Math.E ) ) + 1 )\n\t\t\t\t\n\t\t\t\t.Select ( ( item ) => Enumerable.Repeat ( new { Col1 = p_NumberA, Col2 = p_NumberB }, item )\n\t\t\t\t\t\n\t\t\t\t\t.Aggregate ( ( agg_pair, orig_pair ) => new { Col1 = agg_pair.Col1.Halve ( ), Col2 = agg_pair.Col2.Double ( ) } ) )\n\t\t\t\t\n\t\t\t\t.Where ( pair => !pair.Col1.IsEven ( ) )\n\t\t\t\t\n\t\t\t\t.Sum ( pair => pair.Col2 );\n\t\t}\n\t\tpublic static int EM_Loop ( int p_NumberA, int p_NumberB )\n\t\t{\n\t\t\tint RetVal = 0;\n\t\t\twhile ( p_NumberA >= 1 )\n\t\t\t{\n\t\t\t\tRetVal += p_NumberA.IsEven ( ) ? 0 : p_NumberB;\n\t\t\t\tp_NumberA = p_NumberA.Halve ( );\n\t\t\t\tp_NumberB = p_NumberB.Double ( );\n\t\t\t}\n\t\t\treturn RetVal;\n\t\t}\n\t}\n}\n"}
{"id": 155536, "name": "Ethiopian multiplication", "source": "Translate Ruby to Java: def halve(x) = x/2\ndef double(x) = x*2\n\n\ndef ethiopian_multiply(a, b)\n  product = 0\n  while a >= 1 \n    p [a, b, a.even? ? \"STRIKE\" : \"KEEP\"] if $DEBUG\n    product += b unless a.even?\n    a = halve(a)\n    b = double(b)\n  end\n  product\nend\n\n\ndef rec_ethiopian_multiply(a, b)\n  return 0 if a < 1\n  p [a, b, a.even? ? \"STRIKE\" : \"KEEP\"] if $DEBUG\n  (a.even? ? 0 : b) + rec_ethiopian_multiply(halve(a), double(b))\nend\n\n$DEBUG = true   \na, b = 20, 5\nputs \"\n", "target": "import java.util.HashMap;\nimport java.util.Map;\nimport java.util.Scanner;\npublic class Mult{\n  public static void main(String[] args){\n    Scanner sc = new Scanner(System.in);\n    int first = sc.nextInt();\n    int second = sc.nextInt();\n\n    if(first < 0){\n        first = -first;\n        second = -second;\n    }\n\n    Map<Integer, Integer> columns = new HashMap<Integer, Integer>();\n        columns.put(first, second);\n    int sum = isEven(first)? 0 : second;\n    do{\n      first = halveInt(first);\n      second = doubleInt(second);\n      columns.put(first, second);\n      if(!isEven(first)){\n          sum += second;\n      }\n    }while(first > 1);\n \n    System.out.println(sum);\n  }\n\n  public static int doubleInt(int doubleMe){\n    return doubleMe << 1; \n  }\n\n  public static int halveInt(int halveMe){\n    return halveMe >>> 1; \n  }\n\n  public static boolean isEven(int num){\n    return (num & 1) == 0;\n  }\n}\n"}
{"id": 155537, "name": "Ethiopian multiplication", "source": "Translate Ruby to Python: def halve(x) = x/2\ndef double(x) = x*2\n\n\ndef ethiopian_multiply(a, b)\n  product = 0\n  while a >= 1 \n    p [a, b, a.even? ? \"STRIKE\" : \"KEEP\"] if $DEBUG\n    product += b unless a.even?\n    a = halve(a)\n    b = double(b)\n  end\n  product\nend\n\n\ndef rec_ethiopian_multiply(a, b)\n  return 0 if a < 1\n  p [a, b, a.even? ? \"STRIKE\" : \"KEEP\"] if $DEBUG\n  (a.even? ? 0 : b) + rec_ethiopian_multiply(halve(a), double(b))\nend\n\n$DEBUG = true   \na, b = 20, 5\nputs \"\n", "target": "tutor = True\n\ndef halve(x):\n    return x // 2\n\ndef double(x):\n    return x * 2\n\ndef even(x):\n    return not x % 2\n\ndef ethiopian(multiplier, multiplicand):\n    if tutor:\n        print(\"Ethiopian multiplication of %i and %i\" %\n              (multiplier, multiplicand))\n    result = 0\n    while multiplier >= 1:\n        if even(multiplier):\n            if tutor:\n                print(\"%4i %6i STRUCK\" %\n                      (multiplier, multiplicand))\n        else:\n            if tutor:\n                print(\"%4i %6i KEPT\" %\n                      (multiplier, multiplicand))\n            result += multiplicand\n        multiplier   = halve(multiplier)\n        multiplicand = double(multiplicand)\n    if tutor:\n        print()\n    return result\n"}
{"id": 155768, "name": "Forest fire", "source": "Translate Ruby to C#: class Forest_Fire\n  Neighborhood = [-1,0,1].product([-1,0,1]) - [0,0]\n  States = {empty:\" \", tree:\"T\", fire:\"\n  \n  def initialize(xsize, ysize=xsize, p=0.5, f=0.01)\n    @xsize, @ysize, @p, @f = xsize, ysize, p, f\n    @field = Array.new(xsize+1) {|i| Array.new(ysize+1, :empty)}\n    @generation = 0\n  end\n  \n  def evolve\n    @generation += 1\n    work = @field.map{|row| row.map{|cell| cell}}\n    for i in 0...@xsize\n      for j in 0...@ysize\n        case cell=@field[i][j]\n        when :empty\n          cell = :tree  if rand < @p\n        when :tree\n          cell = :fire  if fire?(i,j)\n        else\n          cell = :empty\n        end\n        work[i][j] = cell\n      end\n    end\n    @field = work\n  end\n  \n  def fire?(i,j)\n    rand < @f or Neighborhood.any? {|di,dj| @field[i+di][j+dj] == :fire}\n  end\n  \n  def display\n    puts \"Generation\u00a0: \n    puts @xsize.times.map{|i| @ysize.times.map{|j| States[@field[i][j]]}.join}\n  end\nend\n\nforest = Forest_Fire.new(10,30)\n10.times do |i|\n  forest.evolve\n  forest.display\nend\n", "target": "using System;\nusing System.Drawing;\nusing System.Drawing.Drawing2D;\nusing System.Threading;\nusing System.Windows.Forms;\n\nnamespace ForestFire\n{\n    class Program : Form\n    {\n        private static readonly Random rand = new Random();\n        private Bitmap img;\n\n        public Program(int w, int h, int f, int p)\n        {\n            Size = new Size(w, h);\n            StartPosition = FormStartPosition.CenterScreen;\n\n            Thread t = new Thread(() => fire(f, p));\n            t.Start();\n\n            FormClosing += (object sender, FormClosingEventArgs e) => { t.Abort(); t = null; };\n        }\n\n        private void fire(int f, int p)\n        {\n            int clientWidth = ClientRectangle.Width;\n            int clientHeight = ClientRectangle.Height;\n            int cellSize = 10;\n\n            img = new Bitmap(clientWidth, clientHeight);\n            Graphics g = Graphics.FromImage(img);\n\n            CellState[,] state = InitializeForestFire(clientWidth, clientHeight);\n\n            uint generation = 0;\n\n            do\n            {\n                g.FillRectangle(Brushes.White, 0, 0, img.Width, img.Height);\n                state = StepForestFire(state, f, p);\n\n                for (int y = 0; y < clientHeight - cellSize; y += cellSize)\n                {\n                    for (int x = 0; x < clientWidth - cellSize; x += cellSize)\n                    {\n                        switch (state[y, x])\n                        {\n                            case CellState.Empty:\n                                break;\n                            case CellState.Tree:\n                                g.FillRectangle(Brushes.DarkGreen, x, y, cellSize, cellSize);\n                                break;\n                            case CellState.Burning:\n                                g.FillRectangle(Brushes.DarkRed, x, y, cellSize, cellSize);\n                                break;\n                        }\n                    }\n                }\n\n                Thread.Sleep(500);\n\n                Invoke((MethodInvoker)Refresh);\n\n            } while (generation < uint.MaxValue);\n\n            g.Dispose();\n        }\n\n        private CellState[,] InitializeForestFire(int width, int height)\n        {\n            \n            var state = new CellState[height, width];\n            state.Initialize();\n            return state;\n        }\n\n        private enum CellState : byte\n        {\n            Empty = 0,\n            Tree = 1,\n            Burning = 2\n        }\n\n        private CellState[,] StepForestFire(CellState[,] state, int f, int p)\n        {\n            \n            var newState = (CellState[,])state.Clone();\n\n            int numRows = state.GetLength(0);\n            int numCols = state.GetLength(1);\n\n            for (int r = 1; r < numRows - 1; r++)\n            {\n                for (int c = 1; c < numCols - 1; c++)\n                {\n                    \n                    switch (state[r, c])\n                    {\n                        case CellState.Empty:\n                            if (rand.Next(0, p) == 0)\n                                newState[r, c] = CellState.Tree;\n                            break;\n\n                        case CellState.Tree:\n                            if (NeighborHasState(state, r, c, CellState.Burning) || rand.Next(0, f) == 0)\n                                newState[r, c] = CellState.Burning;\n                            break;\n\n                        case CellState.Burning:\n                            newState[r, c] = CellState.Empty;\n                            break;\n                    }\n                }\n            }\n\n            return newState;\n        }\n\n        private bool NeighborHasState(CellState[,] state, int x, int y, CellState value)\n        {\n            \n            for (int r = -1; r <= 1; r++)\n            {\n                for (int c = -1; c <= 1; c++)\n                {\n                    if (r == 0 && c == 0)\n                        continue;\n\n                    if (state[x + r, y + c] == value)\n                        return true;\n                }\n            }\n\n            return false;\n        }\n\n        protected override void OnPaint(PaintEventArgs e)\n        {\n            base.OnPaint(e);\n            e.Graphics.DrawImage(img, 0, 0);\n        }\n\n        [STAThread]\n        static void Main(string[] args)\n        {\n            Application.Run(new Program(w: 500, h: 500, f: 2, p: 5));\n        }\n    }\n}\n"}
{"id": 155770, "name": "Forest fire", "source": "Translate Ruby to Java: class Forest_Fire\n  Neighborhood = [-1,0,1].product([-1,0,1]) - [0,0]\n  States = {empty:\" \", tree:\"T\", fire:\"\n  \n  def initialize(xsize, ysize=xsize, p=0.5, f=0.01)\n    @xsize, @ysize, @p, @f = xsize, ysize, p, f\n    @field = Array.new(xsize+1) {|i| Array.new(ysize+1, :empty)}\n    @generation = 0\n  end\n  \n  def evolve\n    @generation += 1\n    work = @field.map{|row| row.map{|cell| cell}}\n    for i in 0...@xsize\n      for j in 0...@ysize\n        case cell=@field[i][j]\n        when :empty\n          cell = :tree  if rand < @p\n        when :tree\n          cell = :fire  if fire?(i,j)\n        else\n          cell = :empty\n        end\n        work[i][j] = cell\n      end\n    end\n    @field = work\n  end\n  \n  def fire?(i,j)\n    rand < @f or Neighborhood.any? {|di,dj| @field[i+di][j+dj] == :fire}\n  end\n  \n  def display\n    puts \"Generation\u00a0: \n    puts @xsize.times.map{|i| @ysize.times.map{|j| States[@field[i][j]]}.join}\n  end\nend\n\nforest = Forest_Fire.new(10,30)\n10.times do |i|\n  forest.evolve\n  forest.display\nend\n", "target": "import java.util.Arrays;\nimport java.util.LinkedList;\nimport java.util.List;\n\npublic class Fire {\n\tprivate static final char BURNING = 'w'; \n\tprivate static final char TREE = 'T';\n\tprivate static final char EMPTY = '.';\n\tprivate static final double F = 0.2;\n\tprivate static final double P = 0.4;\n\tprivate static final double TREE_PROB = 0.5;\n\t\n\tprivate static List<String> process(List<String> land){\n\t\tList<String> newLand = new LinkedList<String>();\n\t\tfor(int i = 0; i < land.size(); i++){\n\t\t\tString rowAbove, thisRow = land.get(i), rowBelow;\n\t\t\tif(i == 0){\n\t\t\t\trowAbove = null;\n\t\t\t\trowBelow = land.get(i + 1);\n\t\t\t}else if(i == land.size() - 1){\n\t\t\t\trowBelow = null;\n\t\t\t\trowAbove = land.get(i - 1);\n\t\t\t}else{\n\t\t\t\trowBelow = land.get(i + 1);\n\t\t\t\trowAbove = land.get(i - 1);\n\t\t\t}\n\t\t\tnewLand.add(processRows(rowAbove, thisRow, rowBelow));\n\t\t}\n\t\treturn newLand;\n\t}\n\n\tprivate static String processRows(String rowAbove, String thisRow,\n\t\t\tString rowBelow){\n\t\tString newRow = \"\";\n\t\tfor(int i = 0; i < thisRow.length();i++){\n\t\t\tswitch(thisRow.charAt(i)){\n\t\t\tcase BURNING:\n\t\t\t\tnewRow+= EMPTY;\n\t\t\t\tbreak;\n\t\t\tcase EMPTY:\n\t\t\t\tnewRow+= Math.random() < P ? TREE : EMPTY;\n\t\t\t\tbreak;\n\t\t\tcase TREE:\n\t\t\t\tString neighbors = \"\";\n\t\t\t\tif(i == 0){\n\t\t\t\t\tneighbors+= rowAbove == null ? \"\" : rowAbove.substring(i, i + 2);\n\t\t\t\t\tneighbors+= thisRow.charAt(i + 1);\n\t\t\t\t\tneighbors+= rowBelow == null ? \"\" : rowBelow.substring(i, i + 2);\n\t\t\t\t\tif(neighbors.contains(Character.toString(BURNING))){\n\t\t\t\t\t\tnewRow+= BURNING;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}else if(i == thisRow.length() - 1){\n\t\t\t\t\tneighbors+= rowAbove == null ? \"\" : rowAbove.substring(i - 1, i + 1);\n\t\t\t\t\tneighbors+= thisRow.charAt(i - 1);\n\t\t\t\t\tneighbors+= rowBelow == null ? \"\" : rowBelow.substring(i - 1, i + 1);\n\t\t\t\t\tif(neighbors.contains(Character.toString(BURNING))){\n\t\t\t\t\t\tnewRow+= BURNING;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}else{\n\t\t\t\t\tneighbors+= rowAbove == null ? \"\" : rowAbove.substring(i - 1, i + 2);\n\t\t\t\t\tneighbors+= thisRow.charAt(i + 1);\n\t\t\t\t\tneighbors+= thisRow.charAt(i - 1);\n\t\t\t\t\tneighbors+= rowBelow == null ? \"\" : rowBelow.substring(i - 1, i + 2);\n\t\t\t\t\tif(neighbors.contains(Character.toString(BURNING))){\n\t\t\t\t\t\tnewRow+= BURNING;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tnewRow+= Math.random() < F ? BURNING : TREE;\n\t\t\t}\n\t\t}\n\t\treturn newRow;\n\t}\n\t\n\tpublic static List<String> populate(int width, int height){\n\t\tList<String> land = new LinkedList<String>();\n\t\tfor(;height > 0; height--){\n\t\t\tStringBuilder line = new StringBuilder(width);\n\t\t\tfor(int i = width; i > 0; i--){\n\t\t\t\tline.append((Math.random() < TREE_PROB) ? TREE : EMPTY);\n\t\t\t}\n\t\t\tland.add(line.toString());\n\t\t}\n\t\treturn land;\n\t}\n\t\n\t\n\tpublic static void processN(List<String> land, int n){\n\t\tfor(int i = 0;i < n; i++){\n\t\t\tland = process(land);\n\t\t}\n\t}\n\t\n\t\n\tpublic static void processNPrint(List<String> land, int n){\n\t\tfor(int i = 0;i < n; i++){\n\t\t\tland = process(land);\n\t\t\tprint(land);\n\t\t}\n\t}\n\t\n\t\n\tpublic static void print(List<String> land){\n\t\tfor(String row: land){\n\t\t\tSystem.out.println(row);\n\t\t}\n\t\tSystem.out.println();\n\t}\n\t\n\tpublic static void main(String[] args){\n\t\tList<String> land = Arrays.asList(\".TTT.T.T.TTTT.T\",\n\t\t\t\t\"T.T.T.TT..T.T..\",\n\t\t\t\t\"TT.TTTT...T.TT.\",\n\t\t\t\t\"TTT..TTTTT.T..T\",\n\t\t\t\t\".T.TTT....TT.TT\",\n\t\t\t\t\"...T..TTT.TT.T.\",\n\t\t\t\t\".TT.TT...TT..TT\",\n\t\t\t\t\".TT.T.T..T.T.T.\",\n\t\t\t\t\"..TTT.TT.T..T..\",\n\t\t\t\t\".T....T.....TTT\",\n\t\t\t\t\"T..TTT..T..T...\",\n\t\t\t\t\"TTT....TTTTTT.T\",\n\t\t\t\t\"......TwTTT...T\",\n\t\t\t\t\"..T....TTTTTTTT\",\n\t\t\t\t\".T.T.T....TT...\");\n\t\tprint(land);\n\t\tprocessNPrint(land, 10);\n\t\t\n\t\tSystem.out.println(\"Random land test:\");\n\t\t\n\t\tland = populate(10, 10);\n\t\tprint(land);\n\t\tprocessNPrint(land, 10);\n\t}\n}\n"}
{"id": 155771, "name": "Forest fire", "source": "Translate Ruby to Python: class Forest_Fire\n  Neighborhood = [-1,0,1].product([-1,0,1]) - [0,0]\n  States = {empty:\" \", tree:\"T\", fire:\"\n  \n  def initialize(xsize, ysize=xsize, p=0.5, f=0.01)\n    @xsize, @ysize, @p, @f = xsize, ysize, p, f\n    @field = Array.new(xsize+1) {|i| Array.new(ysize+1, :empty)}\n    @generation = 0\n  end\n  \n  def evolve\n    @generation += 1\n    work = @field.map{|row| row.map{|cell| cell}}\n    for i in 0...@xsize\n      for j in 0...@ysize\n        case cell=@field[i][j]\n        when :empty\n          cell = :tree  if rand < @p\n        when :tree\n          cell = :fire  if fire?(i,j)\n        else\n          cell = :empty\n        end\n        work[i][j] = cell\n      end\n    end\n    @field = work\n  end\n  \n  def fire?(i,j)\n    rand < @f or Neighborhood.any? {|di,dj| @field[i+di][j+dj] == :fire}\n  end\n  \n  def display\n    puts \"Generation\u00a0: \n    puts @xsize.times.map{|i| @ysize.times.map{|j| States[@field[i][j]]}.join}\n  end\nend\n\nforest = Forest_Fire.new(10,30)\n10.times do |i|\n  forest.evolve\n  forest.display\nend\n", "target": "\n\nL = 15\n\ninitial_trees = 0.55\np = 0.01\nf = 0.001\n\ntry:\n    raw_input\nexcept:\n    raw_input = input\n    \nimport random\n\n\ntree, burning, space = 'TB.'\nhood = ((-1,-1), (-1,0), (-1,1),\n        (0,-1),          (0, 1),\n        (1,-1),  (1,0),  (1,1))\n\ndef initialise():\n    grid = {(x,y): (tree if random.random()<= initial_trees else space)\n            for x in range(L)\n            for y in range(L) }\n    return grid\n\ndef gprint(grid):\n    txt = '\\n'.join(''.join(grid[(x,y)] for x in range(L))\n                    for y in range(L))\n    print(txt)\n\ndef quickprint(grid):\n    t = b = 0\n    ll = L * L\n    for x in range(L):\n        for y in range(L):\n            if grid[(x,y)] in (tree, burning):\n                t += 1\n                if grid[(x,y)] == burning:\n                    b += 1\n    print(('Of %6i cells, %6i are trees of which %6i are currently burning.'\n          + ' (%6.3f%%, %6.3f%%)')\n          % (ll, t, b, 100. * t / ll, 100. * b / ll))\n                \n\ndef gnew(grid):\n    newgrid = {}\n    for x in range(L):\n        for y in range(L):\n            if grid[(x,y)] == burning:\n                newgrid[(x,y)] = space\n            elif grid[(x,y)] == space:\n                newgrid[(x,y)] = tree if random.random()<= p else space\n            elif grid[(x,y)] == tree:\n                newgrid[(x,y)] = (burning\n                                   if any(grid.get((x+dx,y+dy),space) == burning\n                                            for dx,dy in hood)\n                                        or random.random()<= f \n                                   else tree)\n    return newgrid\n\nif __name__ == '__main__':\n    grid = initialise()\n    iter = 0\n    while True:\n        quickprint(grid)\n        inp = raw_input('Print/Quit/<int>/<return> %6i: ' % iter).lower().strip()\n        if inp:\n            if inp[0] == 'p':\n                gprint(grid)\n            elif inp.isdigit():\n                for i in range(int(inp)):\n                    iter +=1\n                    grid = gnew(grid)\n                    quickprint(grid)\n            elif inp[0] == 'q':\n                break\n        grid = gnew(grid)\n        iter +=1\n"}
{"id": 156117, "name": "Multisplit", "source": "Translate Ruby to C#: text = 'a!===b=!=c'\nseparators = ['==', '!=', '=']\n\ndef multisplit_simple(text, separators)\n  text.split(Regexp.union(separators))\nend\n\np multisplit_simple(text, separators) \n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\nnamespace Multisplit\n{\n    internal static class Program\n    {\n        private static void Main(string[] args)\n        {\n            foreach (var s in \"a!===b=!=c\".Multisplit(true, \"==\", \"!=\", \"=\")) \n            {\n                Console.Write(s); \n            }\n            Console.WriteLine();\n        }\n\n        private static IEnumerable<string> Multisplit(this string s, bool returnSeparators = false,\n                                                      params string[] delimiters)\n        {\n            var currentString = new StringBuilder(); \n\n            int index = 0; \n\n            while (index < s.Length) \n            {\n                \n                string foundDelimiter =\n                    (from delimiter in delimiters\n                     where s.Length >= index + delimiter.Length &&\n                           s.Substring(index, delimiter.Length) == delimiter\n                     select delimiter).FirstOrDefault();\n\n                if (foundDelimiter != null)\n                {\n                    yield return currentString.ToString(); \n                    if (returnSeparators) \n                        yield return\n                            string.Format(\"{{\\\"{0}\\\", ({1}, {2})}}\",\n                                          foundDelimiter,\n                                          index, index + foundDelimiter.Length);\n                    currentString.Clear(); \n                    index += foundDelimiter.Length; \n                }\n                else\n                {\n                    currentString.Append(s[index++]); \n                }\n            }\n\n            if (currentString.Length > 0)\n                yield return currentString.ToString(); \n        }\n    }\n}\n"}
{"id": 156118, "name": "Multisplit", "source": "Translate Ruby to C#: text = 'a!===b=!=c'\nseparators = ['==', '!=', '=']\n\ndef multisplit_simple(text, separators)\n  text.split(Regexp.union(separators))\nend\n\np multisplit_simple(text, separators) \n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\nnamespace Multisplit\n{\n    internal static class Program\n    {\n        private static void Main(string[] args)\n        {\n            foreach (var s in \"a!===b=!=c\".Multisplit(true, \"==\", \"!=\", \"=\")) \n            {\n                Console.Write(s); \n            }\n            Console.WriteLine();\n        }\n\n        private static IEnumerable<string> Multisplit(this string s, bool returnSeparators = false,\n                                                      params string[] delimiters)\n        {\n            var currentString = new StringBuilder(); \n\n            int index = 0; \n\n            while (index < s.Length) \n            {\n                \n                string foundDelimiter =\n                    (from delimiter in delimiters\n                     where s.Length >= index + delimiter.Length &&\n                           s.Substring(index, delimiter.Length) == delimiter\n                     select delimiter).FirstOrDefault();\n\n                if (foundDelimiter != null)\n                {\n                    yield return currentString.ToString(); \n                    if (returnSeparators) \n                        yield return\n                            string.Format(\"{{\\\"{0}\\\", ({1}, {2})}}\",\n                                          foundDelimiter,\n                                          index, index + foundDelimiter.Length);\n                    currentString.Clear(); \n                    index += foundDelimiter.Length; \n                }\n                else\n                {\n                    currentString.Append(s[index++]); \n                }\n            }\n\n            if (currentString.Length > 0)\n                yield return currentString.ToString(); \n        }\n    }\n}\n"}
{"id": 156121, "name": "Multisplit", "source": "Translate Ruby to Java: text = 'a!===b=!=c'\nseparators = ['==', '!=', '=']\n\ndef multisplit_simple(text, separators)\n  text.split(Regexp.union(separators))\nend\n\np multisplit_simple(text, separators) \n", "target": "import java.util.*;\n\npublic class MultiSplit {\n\n    public static void main(String[] args) {\n        System.out.println(\"Regex split:\");\n        System.out.println(Arrays.toString(\"a!===b=!=c\".split(\"==|!=|=\")));\n\n        System.out.println(\"\\nManual split:\");\n        for (String s : multiSplit(\"a!===b=!=c\", new String[]{\"==\", \"!=\", \"=\"}))\n            System.out.printf(\"\\\"%s\\\" \", s);\n    }\n\n    static List<String> multiSplit(String txt, String[] separators) {\n        List<String> result = new ArrayList<>();\n        int txtLen = txt.length(), from = 0;\n\n        for (int to = 0; to < txtLen; to++) {\n            for (String sep : separators) {\n                int sepLen = sep.length();\n                if (txt.regionMatches(to, sep, 0, sepLen)) {\n                    result.add(txt.substring(from, to));\n                    from = to + sepLen;\n                    to = from - 1; \n                    break;\n                }\n            }\n        }\n        if (from < txtLen)\n            result.add(txt.substring(from));\n        return result;\n    }\n}\n"}
{"id": 156122, "name": "Multisplit", "source": "Translate Ruby to Java: text = 'a!===b=!=c'\nseparators = ['==', '!=', '=']\n\ndef multisplit_simple(text, separators)\n  text.split(Regexp.union(separators))\nend\n\np multisplit_simple(text, separators) \n", "target": "import java.util.*;\n\npublic class MultiSplit {\n\n    public static void main(String[] args) {\n        System.out.println(\"Regex split:\");\n        System.out.println(Arrays.toString(\"a!===b=!=c\".split(\"==|!=|=\")));\n\n        System.out.println(\"\\nManual split:\");\n        for (String s : multiSplit(\"a!===b=!=c\", new String[]{\"==\", \"!=\", \"=\"}))\n            System.out.printf(\"\\\"%s\\\" \", s);\n    }\n\n    static List<String> multiSplit(String txt, String[] separators) {\n        List<String> result = new ArrayList<>();\n        int txtLen = txt.length(), from = 0;\n\n        for (int to = 0; to < txtLen; to++) {\n            for (String sep : separators) {\n                int sepLen = sep.length();\n                if (txt.regionMatches(to, sep, 0, sepLen)) {\n                    result.add(txt.substring(from, to));\n                    from = to + sepLen;\n                    to = from - 1; \n                    break;\n                }\n            }\n        }\n        if (from < txtLen)\n            result.add(txt.substring(from));\n        return result;\n    }\n}\n"}
{"id": 156123, "name": "Multisplit", "source": "Translate Ruby to Python: text = 'a!===b=!=c'\nseparators = ['==', '!=', '=']\n\ndef multisplit_simple(text, separators)\n  text.split(Regexp.union(separators))\nend\n\np multisplit_simple(text, separators) \n", "target": ">>> import re\n>>> def ms2(txt=\"a!===b=!=c\", sep=[\"==\", \"!=\", \"=\"]):\n\tif not txt or not sep:\n\t\treturn []\n\tans = m = []\n\tfor m in re.finditer('(.*?)(?:' + '|'.join('('+re.escape(s)+')' for s in sep) + ')', txt):\n\t\tans += [m.group(1), (m.lastindex-2, m.start(m.lastindex))]\n\tif m and txt[m.end(m.lastindex):]:\n\t\tans += [txt[m.end(m.lastindex):]]\n\treturn ans\n\n>>> ms2()\n['a', (1, 1), '', (0, 3), 'b', (2, 6), '', (1, 7), 'c']\n>>> ms2(txt=\"a!===b=!=c\", sep=[\"=\", \"!=\", \"==\"])\n['a', (1, 1), '', (0, 3), '', (0, 4), 'b', (0, 6), '', (1, 7), 'c']\n"}
{"id": 156124, "name": "Multisplit", "source": "Translate Ruby to Python: text = 'a!===b=!=c'\nseparators = ['==', '!=', '=']\n\ndef multisplit_simple(text, separators)\n  text.split(Regexp.union(separators))\nend\n\np multisplit_simple(text, separators) \n", "target": ">>> import re\n>>> def ms2(txt=\"a!===b=!=c\", sep=[\"==\", \"!=\", \"=\"]):\n\tif not txt or not sep:\n\t\treturn []\n\tans = m = []\n\tfor m in re.finditer('(.*?)(?:' + '|'.join('('+re.escape(s)+')' for s in sep) + ')', txt):\n\t\tans += [m.group(1), (m.lastindex-2, m.start(m.lastindex))]\n\tif m and txt[m.end(m.lastindex):]:\n\t\tans += [txt[m.end(m.lastindex):]]\n\treturn ans\n\n>>> ms2()\n['a', (1, 1), '', (0, 3), 'b', (2, 6), '', (1, 7), 'c']\n>>> ms2(txt=\"a!===b=!=c\", sep=[\"=\", \"!=\", \"==\"])\n['a', (1, 1), '', (0, 3), '', (0, 4), 'b', (0, 6), '', (1, 7), 'c']\n"}
{"id": 156349, "name": "Binary strings", "source": "Translate Ruby to C#: \nx = \"hello world\"\n \n\nx = nil\n \n\nx = \"a\\0b\"\nx.length  \n \n\nif x == \"hello\"\n  puts \"equal\"\nelse\n  puts \"not equal\"\nend\ny = 'bc'\nif x < y\n  puts \"\nend\n \n\nxx = x.dup\nx == xx       \nx.equal?(xx)  \n \n\nif x.empty?\n  puts \"is empty\"\nend\n \n\np x << \"\\07\"\n \n\np xx = x[0..-2]\nx[1,2] = \"XYZ\"\np x\n \n\np y = \"hello world\".tr(\"l\", \"L\")\n \n\na = \"hel\"\nb = \"lo w\"\nc = \"orld\"\np d = a + b + c\n", "target": "using System;\n\nclass Program\n{\n    static void Main()\n    {\n        \n        var x = \"hello world\";\n\n        \n        x = null;\n\n        \n        x = \"ab\\0\";\n        Console.WriteLine(x);\n        Console.WriteLine(x.Length); \n\n        \n        if (x == \"hello\")\n            Console.WriteLine(\"equal\");\n        else\n            Console.WriteLine(\"not equal\");\n\n        if (x.CompareTo(\"bc\") == -1)\n            Console.WriteLine(\"x is lexicographically less than 'bc'\");\n\n        \n        var c = new char[3];\n        x.CopyTo(0, c, 0, 3);\n        object objecty = new string(c);\n        var y = new string(c);\n\n        Console.WriteLine(x == y);      \n        Console.WriteLine(x.Equals(y)); \n\n        Console.WriteLine(x == objecty); \n\n        \n        var empty = \"\";\n        string nullString = null;\n        var whitespace = \"   \";\n        if (nullString == null && empty == string.Empty && \n            string.IsNullOrEmpty(nullString) && string.IsNullOrEmpty(empty) &&\n            string.IsNullOrWhiteSpace(nullString) && string.IsNullOrWhiteSpace(empty) &&\n            string.IsNullOrWhiteSpace(whitespace))\n            Console.WriteLine(\"Strings are null, empty or whitespace\");\n\n        \n        x = \"helloworld\";\n        x += (char)83;\n        Console.WriteLine(x);\n\n        \n        var slice = x.Substring(5, 5);\n        Console.WriteLine(slice);\n\n        \n        var greeting = x.Replace(\"worldS\", \"\");\n        Console.WriteLine(greeting);\n\n        \n        var join = greeting + \" \" + slice;\n        Console.WriteLine(join);\n    }\n}\n"}
{"id": 156351, "name": "Binary strings", "source": "Translate Ruby to Java: \nx = \"hello world\"\n \n\nx = nil\n \n\nx = \"a\\0b\"\nx.length  \n \n\nif x == \"hello\"\n  puts \"equal\"\nelse\n  puts \"not equal\"\nend\ny = 'bc'\nif x < y\n  puts \"\nend\n \n\nxx = x.dup\nx == xx       \nx.equal?(xx)  \n \n\nif x.empty?\n  puts \"is empty\"\nend\n \n\np x << \"\\07\"\n \n\np xx = x[0..-2]\nx[1,2] = \"XYZ\"\np x\n \n\np y = \"hello world\".tr(\"l\", \"L\")\n \n\na = \"hel\"\nb = \"lo w\"\nc = \"orld\"\np d = a + b + c\n", "target": "module BinaryStrings\n    {\n    @Inject Console console;\n    void run()\n        {\n        Byte[] mutableBytes = new Byte[];       \n        Byte[] fixedLength  = new Byte[10];     \n        Byte[] literal      = [0, 1, 7, 0xff];  \n        console.print($|String creation and assignment:\n                       |  mutableBytes={mutableBytes}\n                       |  fixedLength={fixedLength}\n                       |  literal={literal}\n                       |\n                     );\n\n        console.print($|Check if a string is empty:\n                       |  mutableBytes.empty={mutableBytes.empty}\n                       |  fixedLength.empty={fixedLength.empty}\n                       |  literal.empty={literal.empty}\n                       |\n                     );\n\n        mutableBytes += 0;                      \n        mutableBytes.add(1);                    \n        mutableBytes.addAll(#07FF);             \n        console.print($|Append a byte to a string:\n                       |  mutableBytes={mutableBytes}\n                       |\n                     );\n\n        console.print($|String comparison:\n                       |  mutableBytes==literal = {mutableBytes==literal}\n                       |  fixedLength==literal = {fixedLength==literal}\n                       |\n                     );\n\n        fixedLength = new Byte[4](i -> literal[i]);     \n        val clone = fixedLength.clone();                \n        console.print($|String cloning and copying:\n                       |  fixedLength={fixedLength}\n                       |  clone={clone}\n                       |\n                     );\n\n        console.print($|Extract a substring from a string:\n                       |  mutableBytes[1..2]={mutableBytes[1..2]}\n                       |  fixedLength[0..2]={fixedLength[0..2]}\n                       |  literal[2..3]={literal[2..3]}\n                       |\n                     );\n\n        for (Int start = 0; Int index := fixedLength.indexOf(0x01, start); start = index)\n            {\n            fixedLength[index] = 0x04;\n            }\n        console.print($|Replace every occurrence of a byte in a string with another string:\n                       |  fixedLength={fixedLength}\n                       |\n                     );\n\n        for (Int start = 0; Int index := mutableBytes.indexOf(#0107, start); start = index)\n            {\n            mutableBytes.replaceAll(index, #9876);\n            }\n        console.print($|Replace every occurrence of a string in a string with another string:\n                       |  mutableBytes={mutableBytes}\n                       |\n                     );\n\n        console.print($|Join strings:\n                       |  mutableBytes+fixedLength+literal={mutableBytes+fixedLength+literal}\n                       |\n                     );\n        }\n    }\n"}
{"id": 156352, "name": "Binary strings", "source": "Translate Ruby to Python: \nx = \"hello world\"\n \n\nx = nil\n \n\nx = \"a\\0b\"\nx.length  \n \n\nif x == \"hello\"\n  puts \"equal\"\nelse\n  puts \"not equal\"\nend\ny = 'bc'\nif x < y\n  puts \"\nend\n \n\nxx = x.dup\nx == xx       \nx.equal?(xx)  \n \n\nif x.empty?\n  puts \"is empty\"\nend\n \n\np x << \"\\07\"\n \n\np xx = x[0..-2]\nx[1,2] = \"XYZ\"\np x\n \n\np y = \"hello world\".tr(\"l\", \"L\")\n \n\na = \"hel\"\nb = \"lo w\"\nc = \"orld\"\np d = a + b + c\n", "target": "s1 = \"A 'string' literal \\n\"\ns2 = 'You may use any of \\' or \" as delimiter'\ns3 = \n"}
{"id": 156580, "name": "Number reversal game", "source": "Translate Ruby to C#: SIZE = 9\nordered = (1..SIZE).to_a\nshuffled = (1..SIZE).to_a\n\nwhile shuffled == ordered\n  shuffled.shuffle!\nend\n\nscore = 0\nuntil shuffled == ordered\n  print \"\n\n  next unless guess = gets\n  next unless num = guess.to_i?\n  next if num < 2 || num > SIZE\n  \n  shuffled[0, num] = shuffled[0, num].reverse\n  score += 1\nend\n\nputs \"\n", "target": "using System;\nusing System.Linq;\n\nclass Program\n{\n    static void Main(string[] args)\n    {\n        var r = new Random();\n\n        var tries = 1;\n        var sorted = Enumerable.Range(1, 9).ToList();\n        var values = sorted.OrderBy(x => r.Next(-1, 1)).ToList();\n\n        while (Enumerable.SequenceEqual(sorted, values)) {\n            values = sorted.OrderBy(x => r.Next(-1, 1)).ToList();\n        }\n\n        \n\n        while (!Enumerable.SequenceEqual(sorted, values))\n        {\n            Console.Write(\"# {0}: LIST: {1} - Flip how many? \", tries, String.Join(\" \", values));\n\n            values.Reverse(0, int.Parse(Console.ReadLine()));\n            tries += 1;\n        }\n\n        Console.WriteLine(\"\\nYou took {0} attempts to put the digits in order!\", tries - 1);\n        Console.ReadLine();\n    }\n}\n"}
{"id": 156582, "name": "Number reversal game", "source": "Translate Ruby to Java: SIZE = 9\nordered = (1..SIZE).to_a\nshuffled = (1..SIZE).to_a\n\nwhile shuffled == ordered\n  shuffled.shuffle!\nend\n\nscore = 0\nuntil shuffled == ordered\n  print \"\n\n  next unless guess = gets\n  next unless num = guess.to_i?\n  next if num < 2 || num > SIZE\n  \n  shuffled[0, num] = shuffled[0, num].reverse\n  score += 1\nend\n\nputs \"\n", "target": "import java.util.List;\nimport java.util.ArrayList;\nimport java.util.Scanner;\nimport java.util.Collections;\n\n\npublic class ReversalGame {\n    private List<Integer> gameList;\n\n    public ReversalGame() {\n        initialize();\n    }\n\n    public void play() throws Exception {\n        int i = 0;\n        int moveCount = 0;\n        Scanner scanner = new Scanner(System.in);\n        while (true) {\n            System.out.println(gameList);\n            System.out.println(\"Please enter a index to reverse from 2 to 9. Enter 99 to quit\");\n            i = scanner.nextInt();\n            if (i == 99) {\n                break;\n            }\n            if (i < 2 || i > 9) {\n                System.out.println(\"Invalid input\");\n            } else {\n                moveCount++;\n                reverse(i);\n                if (isSorted()) {\n                    System.out.println(\"Congratulations you solved this in \" + moveCount + \" moves!\");\n                    break;\n                }\n            }\n\n        }\n        scanner.close();\n    }\n\n    private void reverse(int position) {\n        Collections.reverse(gameList.subList(0, position));\n    }\n\n    private boolean isSorted() {\n        for (int i=0; i < gameList.size() - 1; ++i) {\n            if (gameList.get(i).compareTo(gameList.get(i + 1)) > 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    private void initialize() {\n        this.gameList = new ArrayList<Integer>(9);\n        for (int i=1; i < 10; ++i) {\n            gameList.add(i);\n        }\n        while (isSorted()) {\n            Collections.shuffle(gameList);\n        }\n    }\n\n\n    public static void main(String[] args) {\n        try {\n            ReversalGame game = new ReversalGame();\n            game.play();\n        } catch (Exception e) {\n            System.out.println(e.getMessage());\n            e.printStackTrace();\n        }\n    }\n}\n"}
{"id": 156583, "name": "Number reversal game", "source": "Translate Ruby to Python: SIZE = 9\nordered = (1..SIZE).to_a\nshuffled = (1..SIZE).to_a\n\nwhile shuffled == ordered\n  shuffled.shuffle!\nend\n\nscore = 0\nuntil shuffled == ordered\n  print \"\n\n  next unless guess = gets\n  next unless num = guess.to_i?\n  next if num < 2 || num > SIZE\n  \n  shuffled[0, num] = shuffled[0, num].reverse\n  score += 1\nend\n\nputs \"\n", "target": "print '\n\nvar data, trials = list(1..9), 0\n\nwhile data == sort data:\n    random.shuffle data\n\nwhile data != sort data:\n    trials += 1\n    flip = int input '\n    data[:flip] = reverse data[:flip]\n\nprint '\\nYou took ${trials} attempts to put digits in order!'\n"}
{"id": 156921, "name": "Van Eck sequence", "source": "Translate Ruby to C#: van_eck = Enumerator.new do |y|\n  ar = [0]\n  loop do\n    y << (term = ar.last)  \n    ar << (ar.count(term)==1 ? 0 : ar.size - 1 - ar[0..-2].rindex(term))\n  end\nend\n\nve = van_eck.take(1000)\np ve.first(10), ve.last(10)\n", "target": "using System.Linq; class Program { static void Main() {\n    int a, b, c, d, e, f, g; int[] h = new int[g = 1000];\n    for (a = 0, b = 1, c = 2; c < g; a = b, b = c++)\n        for (d = a, e = b - d, f = h[b]; e <= b; e++)\n            if (f == h[d--]) { h[c] = e; break; }\n    void sho(int i) { System.Console.WriteLine(string.Join(\" \",\n        h.Skip(i).Take(10))); } sho(0); sho(990); } }\n"}
{"id": 156922, "name": "Van Eck sequence", "source": "Translate Ruby to C#: van_eck = Enumerator.new do |y|\n  ar = [0]\n  loop do\n    y << (term = ar.last)  \n    ar << (ar.count(term)==1 ? 0 : ar.size - 1 - ar[0..-2].rindex(term))\n  end\nend\n\nve = van_eck.take(1000)\np ve.first(10), ve.last(10)\n", "target": "using System.Linq; class Program { static void Main() {\n    int a, b, c, d, e, f, g; int[] h = new int[g = 1000];\n    for (a = 0, b = 1, c = 2; c < g; a = b, b = c++)\n        for (d = a, e = b - d, f = h[b]; e <= b; e++)\n            if (f == h[d--]) { h[c] = e; break; }\n    void sho(int i) { System.Console.WriteLine(string.Join(\" \",\n        h.Skip(i).Take(10))); } sho(0); sho(990); } }\n"}
{"id": 156925, "name": "Van Eck sequence", "source": "Translate Ruby to Java: van_eck = Enumerator.new do |y|\n  ar = [0]\n  loop do\n    y << (term = ar.last)  \n    ar << (ar.count(term)==1 ? 0 : ar.size - 1 - ar[0..-2].rindex(term))\n  end\nend\n\nve = van_eck.take(1000)\np ve.first(10), ve.last(10)\n", "target": "import java.util.HashMap;\nimport java.util.Map;\n\npublic class VanEckSequence {\n\n    public static void main(String[] args) {\n        System.out.println(\"First 10 terms of Van Eck's sequence:\");\n        vanEck(1, 10);\n        System.out.println(\"\");\n        System.out.println(\"Terms 991 to 1000 of Van Eck's sequence:\");\n        vanEck(991, 1000);\n    }\n    \n    private static void vanEck(int firstIndex, int lastIndex) {\n        Map<Integer,Integer> vanEckMap = new HashMap<>();        \n        int last = 0;\n        if ( firstIndex == 1 ) {\n            System.out.printf(\"VanEck[%d] = %d%n\", 1, 0);\n        }\n        for ( int n = 2 ; n <= lastIndex ; n++ ) {\n            int vanEck = vanEckMap.containsKey(last) ? n - vanEckMap.get(last) : 0;\n            vanEckMap.put(last, n);\n            last = vanEck;\n            if ( n >= firstIndex ) {\n                System.out.printf(\"VanEck[%d] = %d%n\", n, vanEck);\n            }\n        }\n        \n    }\n\n}\n"}
{"id": 156926, "name": "Van Eck sequence", "source": "Translate Ruby to Java: van_eck = Enumerator.new do |y|\n  ar = [0]\n  loop do\n    y << (term = ar.last)  \n    ar << (ar.count(term)==1 ? 0 : ar.size - 1 - ar[0..-2].rindex(term))\n  end\nend\n\nve = van_eck.take(1000)\np ve.first(10), ve.last(10)\n", "target": "import java.util.HashMap;\nimport java.util.Map;\n\npublic class VanEckSequence {\n\n    public static void main(String[] args) {\n        System.out.println(\"First 10 terms of Van Eck's sequence:\");\n        vanEck(1, 10);\n        System.out.println(\"\");\n        System.out.println(\"Terms 991 to 1000 of Van Eck's sequence:\");\n        vanEck(991, 1000);\n    }\n    \n    private static void vanEck(int firstIndex, int lastIndex) {\n        Map<Integer,Integer> vanEckMap = new HashMap<>();        \n        int last = 0;\n        if ( firstIndex == 1 ) {\n            System.out.printf(\"VanEck[%d] = %d%n\", 1, 0);\n        }\n        for ( int n = 2 ; n <= lastIndex ; n++ ) {\n            int vanEck = vanEckMap.containsKey(last) ? n - vanEckMap.get(last) : 0;\n            vanEckMap.put(last, n);\n            last = vanEck;\n            if ( n >= firstIndex ) {\n                System.out.printf(\"VanEck[%d] = %d%n\", n, vanEck);\n            }\n        }\n        \n    }\n\n}\n"}
{"id": 156927, "name": "Van Eck sequence", "source": "Translate Ruby to Python: van_eck = Enumerator.new do |y|\n  ar = [0]\n  loop do\n    y << (term = ar.last)  \n    ar << (ar.count(term)==1 ? 0 : ar.size - 1 - ar[0..-2].rindex(term))\n  end\nend\n\nve = van_eck.take(1000)\np ve.first(10), ve.last(10)\n", "target": "def van_eck():\n    n, seen, val = 0, {}, 0\n    while True:\n        yield val\n        last = {val: n}\n        val = n - seen.get(val, n)\n        seen.update(last)\n        n += 1\n\nif __name__ == '__main__':\n    print(\"Van Eck: first 10 terms:  \", list(islice(van_eck(), 10)))\n    print(\"Van Eck: terms 991 - 1000:\", list(islice(van_eck(), 1000))[-10:])\n"}
{"id": 156928, "name": "Van Eck sequence", "source": "Translate Ruby to Python: van_eck = Enumerator.new do |y|\n  ar = [0]\n  loop do\n    y << (term = ar.last)  \n    ar << (ar.count(term)==1 ? 0 : ar.size - 1 - ar[0..-2].rindex(term))\n  end\nend\n\nve = van_eck.take(1000)\np ve.first(10), ve.last(10)\n", "target": "def van_eck():\n    n, seen, val = 0, {}, 0\n    while True:\n        yield val\n        last = {val: n}\n        val = n - seen.get(val, n)\n        seen.update(last)\n        n += 1\n\nif __name__ == '__main__':\n    print(\"Van Eck: first 10 terms:  \", list(islice(van_eck(), 10)))\n    print(\"Van Eck: terms 991 - 1000:\", list(islice(van_eck(), 1000))[-10:])\n"}
{"id": 157074, "name": "Bitmap_Midpoint circle algorithm", "source": "Translate Ruby to C#: Pixel = Struct.new(:x, :y)\n\nclass Pixmap\n  def draw_circle(pixel, radius, colour)\n    validate_pixel(pixel.x, pixel.y)\n \n    self[pixel.x, pixel.y + radius] = colour\n    self[pixel.x, pixel.y - radius] = colour\n    self[pixel.x + radius, pixel.y] = colour\n    self[pixel.x - radius, pixel.y] = colour\n \n    f = 1 - radius\n    ddF_x = 1\n    ddF_y = -2 * radius\n    x = 0\n    y = radius\n    while x < y\n      if f >= 0\n        y -= 1\n        ddF_y += 2\n        f += ddF_y\n      end\n      x += 1\n      ddF_x += 2\n      f += ddF_x\n      self[pixel.x + x, pixel.y + y] = colour\n      self[pixel.x + x, pixel.y - y] = colour\n      self[pixel.x - x, pixel.y + y] = colour\n      self[pixel.x - x, pixel.y - y] = colour\n      self[pixel.x + y, pixel.y + x] = colour\n      self[pixel.x + y, pixel.y - x] = colour\n      self[pixel.x - y, pixel.y + x] = colour\n      self[pixel.x - y, pixel.y - x] = colour\n    end\n  end\nend\n\nbitmap = Pixmap.new(30, 30)\nbitmap.draw_circle(Pixel[14,14], 12, RGBColour::BLACK)\n", "target": "        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        public static void DrawCircle(this GenericImage image, int centerX, int centerY, int radius, Color color)\n        {\n            int d = (5 - radius * 4) / 4;\n            int x = 0;\n            int y = radius;\n\n            do\n            {\n                \n                \n                if (centerX + x >= 0 && centerX + x <= image.Width - 1 && centerY + y >= 0 && centerY + y <= image.Height - 1) image[centerX + x, centerY + y] = color;\n                if (centerX + x >= 0 && centerX + x <= image.Width - 1 && centerY - y >= 0 && centerY - y <= image.Height - 1) image[centerX + x, centerY - y] = color;\n                if (centerX - x >= 0 && centerX - x <= image.Width - 1 && centerY + y >= 0 && centerY + y <= image.Height - 1) image[centerX - x, centerY + y] = color;\n                if (centerX - x >= 0 && centerX - x <= image.Width - 1 && centerY - y >= 0 && centerY - y <= image.Height - 1) image[centerX - x, centerY - y] = color;\n                if (centerX + y >= 0 && centerX + y <= image.Width - 1 && centerY + x >= 0 && centerY + x <= image.Height - 1) image[centerX + y, centerY + x] = color;\n                if (centerX + y >= 0 && centerX + y <= image.Width - 1 && centerY - x >= 0 && centerY - x <= image.Height - 1) image[centerX + y, centerY - x] = color;\n                if (centerX - y >= 0 && centerX - y <= image.Width - 1 && centerY + x >= 0 && centerY + x <= image.Height - 1) image[centerX - y, centerY + x] = color;\n                if (centerX - y >= 0 && centerX - y <= image.Width - 1 && centerY - x >= 0 && centerY - x <= image.Height - 1) image[centerX - y, centerY - x] = color;\n                if (d < 0)\n                {\n                    d += 2 * x + 1;\n                }\n                else\n                {\n                    d += 2 * (x - y) + 1;\n                    y--;\n                }\n                x++;\n            } while (x <= y);\n        }\n"}
{"id": 157075, "name": "Bitmap_Midpoint circle algorithm", "source": "Translate Ruby to Java: Pixel = Struct.new(:x, :y)\n\nclass Pixmap\n  def draw_circle(pixel, radius, colour)\n    validate_pixel(pixel.x, pixel.y)\n \n    self[pixel.x, pixel.y + radius] = colour\n    self[pixel.x, pixel.y - radius] = colour\n    self[pixel.x + radius, pixel.y] = colour\n    self[pixel.x - radius, pixel.y] = colour\n \n    f = 1 - radius\n    ddF_x = 1\n    ddF_y = -2 * radius\n    x = 0\n    y = radius\n    while x < y\n      if f >= 0\n        y -= 1\n        ddF_y += 2\n        f += ddF_y\n      end\n      x += 1\n      ddF_x += 2\n      f += ddF_x\n      self[pixel.x + x, pixel.y + y] = colour\n      self[pixel.x + x, pixel.y - y] = colour\n      self[pixel.x - x, pixel.y + y] = colour\n      self[pixel.x - x, pixel.y - y] = colour\n      self[pixel.x + y, pixel.y + x] = colour\n      self[pixel.x + y, pixel.y - x] = colour\n      self[pixel.x - y, pixel.y + x] = colour\n      self[pixel.x - y, pixel.y - x] = colour\n    end\n  end\nend\n\nbitmap = Pixmap.new(30, 30)\nbitmap.draw_circle(Pixel[14,14], 12, RGBColour::BLACK)\n", "target": "import java.awt.Color;\n\npublic class MidPointCircle {\n\tprivate BasicBitmapStorage image;\n\n\tpublic MidPointCircle(final int imageWidth, final int imageHeight) {\n\t\tthis.image = new BasicBitmapStorage(imageWidth, imageHeight);\n\t}\n\n\tprivate void drawCircle(final int centerX, final int centerY, final int radius) {\n\t\tint d = (5 - radius * 4)/4;\n\t\tint x = 0;\n\t\tint y = radius;\n\t\tColor circleColor = Color.white;\n\n\t\tdo {\n\t\t\timage.setPixel(centerX + x, centerY + y, circleColor);\n\t\t\timage.setPixel(centerX + x, centerY - y, circleColor);\n\t\t\timage.setPixel(centerX - x, centerY + y, circleColor);\n\t\t\timage.setPixel(centerX - x, centerY - y, circleColor);\n\t\t\timage.setPixel(centerX + y, centerY + x, circleColor);\n\t\t\timage.setPixel(centerX + y, centerY - x, circleColor);\n\t\t\timage.setPixel(centerX - y, centerY + x, circleColor);\n\t\t\timage.setPixel(centerX - y, centerY - x, circleColor);\n\t\t\tif (d < 0) {\n\t\t\t\td += 2 * x + 1;\n\t\t\t} else {\n\t\t\t\td += 2 * (x - y) + 1;\n\t\t\t\ty--;\n\t\t\t}\n\t\t\tx++;\n\t\t} while (x <= y);\n\n\t}\n}\n"}
{"id": 157076, "name": "Bitmap_Midpoint circle algorithm", "source": "Translate Ruby to Python: Pixel = Struct.new(:x, :y)\n\nclass Pixmap\n  def draw_circle(pixel, radius, colour)\n    validate_pixel(pixel.x, pixel.y)\n \n    self[pixel.x, pixel.y + radius] = colour\n    self[pixel.x, pixel.y - radius] = colour\n    self[pixel.x + radius, pixel.y] = colour\n    self[pixel.x - radius, pixel.y] = colour\n \n    f = 1 - radius\n    ddF_x = 1\n    ddF_y = -2 * radius\n    x = 0\n    y = radius\n    while x < y\n      if f >= 0\n        y -= 1\n        ddF_y += 2\n        f += ddF_y\n      end\n      x += 1\n      ddF_x += 2\n      f += ddF_x\n      self[pixel.x + x, pixel.y + y] = colour\n      self[pixel.x + x, pixel.y - y] = colour\n      self[pixel.x - x, pixel.y + y] = colour\n      self[pixel.x - x, pixel.y - y] = colour\n      self[pixel.x + y, pixel.y + x] = colour\n      self[pixel.x + y, pixel.y - x] = colour\n      self[pixel.x - y, pixel.y + x] = colour\n      self[pixel.x - y, pixel.y - x] = colour\n    end\n  end\nend\n\nbitmap = Pixmap.new(30, 30)\nbitmap.draw_circle(Pixel[14,14], 12, RGBColour::BLACK)\n", "target": "def circle(self, x0, y0, radius, colour=black):\n    f = 1 - radius\n    ddf_x = 1\n    ddf_y = -2 * radius\n    x = 0\n    y = radius\n    self.set(x0, y0 + radius, colour)\n    self.set(x0, y0 - radius, colour)\n    self.set(x0 + radius, y0, colour)\n    self.set(x0 - radius, y0, colour)\n\n    while x < y:\n        if f >= 0: \n            y -= 1\n            ddf_y += 2\n            f += ddf_y\n        x += 1\n        ddf_x += 2\n        f += ddf_x    \n        self.set(x0 + x, y0 + y, colour)\n        self.set(x0 - x, y0 + y, colour)\n        self.set(x0 + x, y0 - y, colour)\n        self.set(x0 - x, y0 - y, colour)\n        self.set(x0 + y, y0 + x, colour)\n        self.set(x0 - y, y0 + x, colour)\n        self.set(x0 + y, y0 - x, colour)\n        self.set(x0 - y, y0 - x, colour)\nBitmap.circle = circle\n\nbitmap = Bitmap(25,25)\nbitmap.circle(x0=12, y0=12, radius=12)\nbitmap.chardisplay()\n\n\n"}
{"id": 157277, "name": "Permutations", "source": "Translate Ruby to C#: puts [1, 2, 3].permutations\n", "target": "public static class Extension\n{\n    public static IEnumerable<IEnumerable<T>> Permutations<T>(this IEnumerable<T> values) where T : IComparable<T>\n    {\n        if (values.Count() == 1)\n            return new[] { values };\n        return values.SelectMany(v => Permutations(values.Where(x => x.CompareTo(v) != 0)), (v, p) => p.Prepend(v));\n    }\n}\n"}
{"id": 157279, "name": "Permutations", "source": "Translate Ruby to Java: puts [1, 2, 3].permutations\n", "target": "\nmodule Permutations\n    {\n    static Int[][] permut(Int items)\n        {\n        if (items <= 1)\n            {\n            \n            return items == 1 ? [[0]] : [];\n            }\n\n        \n        \n        Int[][] pattern = permut(items - 1);\n\n        \n        \n        Int[][] result = new Int[][];\n        for (Int prefix : 0 ..< items)\n            {\n            for (Int[] suffix : pattern)\n                {\n                result.add(new Int[items](i -> i == 0 ? prefix : (prefix + suffix[i-1] + 1) % items));\n                }\n            }\n        return result;\n        }\n\n    void run()\n        {\n        @Inject Console console;\n        console.print($\"permut(3) = {permut(3)}\");\n        }\n    }\n"}
{"id": 157485, "name": "Proper divisors", "source": "Translate Ruby to C#: require \"prime\"\n\nclass Integer\n  def proper_divisors\n    return [] if self == 1\n    primes = prime_division.flat_map{|prime, freq| [prime] * freq}\n    (1...primes.size).each_with_object([1]) do |n, res|\n      primes.combination(n).map{|combi| res << combi.inject(:*)}\n    end.flatten.uniq\n  end\nend\n\n(1..10).map{|n| puts \"\n\nsize, select = (1..20_000).group_by{|n| n.proper_divisors.size}.max\nselect.each do |n|\n  puts \"\nend\n", "target": "namespace RosettaCode.ProperDivisors\n{\n    using System;\n    using System.Collections.Generic;\n    using System.Linq;\n\n    internal static class Program\n    {\n        private static IEnumerable<int> ProperDivisors(int number)\n        {\n            return\n                Enumerable.Range(1, number / 2)\n                    .Where(divisor => number % divisor == 0);\n        }\n\n        private static void Main()\n        {\n            foreach (var number in Enumerable.Range(1, 10))\n            {\n                Console.WriteLine(\"{0}: {{{1}}}\", number,\n                    string.Join(\", \", ProperDivisors(number)));\n            }\n\n            var record = Enumerable.Range(1, 20000).Select(number => new\n            {\n                Number = number,\n                Count = ProperDivisors(number).Count()\n            }).OrderByDescending(currentRecord => currentRecord.Count).First();\n            Console.WriteLine(\"{0}: {1}\", record.Number, record.Count);\n        }\n    }\n}\n"}
{"id": 157487, "name": "Proper divisors", "source": "Translate Ruby to Java: require \"prime\"\n\nclass Integer\n  def proper_divisors\n    return [] if self == 1\n    primes = prime_division.flat_map{|prime, freq| [prime] * freq}\n    (1...primes.size).each_with_object([1]) do |n, res|\n      primes.combination(n).map{|combi| res << combi.inject(:*)}\n    end.flatten.uniq\n  end\nend\n\n(1..10).map{|n| puts \"\n\nsize, select = (1..20_000).group_by{|n| n.proper_divisors.size}.max\nselect.each do |n|\n  puts \"\nend\n", "target": "import java.util.Collections;\nimport java.util.LinkedList;\nimport java.util.List;\n\npublic class Proper{\n    public static List<Integer> properDivs(int n){\n        List<Integer> divs = new LinkedList<Integer>();\n        if(n == 1) return divs;\n        divs.add(1);\n        for(int x = 2; x < n; x++){\n            if(n % x == 0) divs.add(x);\n        }\n        \n        Collections.sort(divs);\n        \n        return divs;\n    }\n    \n    public static void main(String[] args){\n        for(int x = 1; x <= 10; x++){\n            System.out.println(x + \": \" + properDivs(x));\n        }\n        \n        int x = 0, count = 0;\n        for(int n = 1; n <= 20000; n++){\n            if(properDivs(n).size() > count){\n                x = n;\n                count = properDivs(n).size();\n            }\n        }\n        System.out.println(x + \": \" + count);\n    }\n}\n"}
{"id": 157488, "name": "Proper divisors", "source": "Translate Ruby to Python: require \"prime\"\n\nclass Integer\n  def proper_divisors\n    return [] if self == 1\n    primes = prime_division.flat_map{|prime, freq| [prime] * freq}\n    (1...primes.size).each_with_object([1]) do |n, res|\n      primes.combination(n).map{|combi| res << combi.inject(:*)}\n    end.flatten.uniq\n  end\nend\n\n(1..10).map{|n| puts \"\n\nsize, select = (1..20_000).group_by{|n| n.proper_divisors.size}.max\nselect.each do |n|\n  puts \"\nend\n", "target": ">>> def proper_divs2(n):\n...     return {x for x in range(1, (n + 1) // 2 + 1) if n % x == 0 and n != x}\n... \n>>> [proper_divs2(n) for n in range(1, 11)]\n[set(), {1}, {1}, {1, 2}, {1}, {1, 2, 3}, {1}, {1, 2, 4}, {1, 3}, {1, 2, 5}]\n>>> \n>>> n, length = max(((n, len(proper_divs2(n))) for n in range(1, 20001)), key=lambda pd: pd[1])\n>>> n\n15120\n>>> length\n79\n>>>\n"}
{"id": 157656, "name": "Define a primitive data type", "source": "Translate Ruby to C#: require 'test/unit'\ninclude Test::Unit::Assertions\n\nclass MyInt\n  @@min = 1\n  @@max = 10\n  \n  attr_reader :value\n  private :value\n  \n  def initialize(val)\n    begin\n      v = Integer(val)\n    rescue ArgumentError\n      raise ArgumentError, \"invalid value '\n    end\n    \n    unless v.between?(@@min, @@max)\n      raise ArgumentError, \"invalid value '\n    end\n    \n    @value = v\n  end\n  \n  def method_missing(m, *args)\n    super unless @value.respond_to?(m)\n    myint_args = args.collect do |arg|\n      arg.kind_of?(self.class) ? arg.to_int : arg\n    end\n    result = @value.send(m, *myint_args)\n    return result if m == :coerce\n    case result\n    when Integer\n      MyInt.new(result)\n    when Array\n      result.collect do |element|\n        element.kind_of?(Integer) ? MyInt.new(element) : element\n      end\n    else\n      result\n    end\n  end\n  \n  def respond_to?(method)\n    super or @value.respond_to? method\n  end\n  \n  def to_int\n    @value\n  end\n  def to_f\n    Float(@value)\n  end\n  def to_s\n    @value.to_s\n  end\n  def inspect\n    to_s\n  end\nend\n\n\nassert_raise(ArgumentError) { MyInt.new(\"foo\") }    \nassert_raise(ArgumentError) { MyInt.new(11) }       \n\na = MyInt.new(7)\nb = MyInt.new(5)\n\nc = 5 + a\nassert_kind_of(Fixnum, c)\nassert_equal(12, c)\n\nc = a + 2\nassert_kind_of(MyInt, c)\nassert_equal(9, c.to_int)\n\nc = a + 2.8\nassert_kind_of(Float, c)\nassert_equal(9.8, c)\n\nc = a - b\nassert_kind_of(MyInt, c)\nassert_equal(2, c.to_int)\n\nassert_raise(ArgumentError) { c = a + b }    \nassert_raise(ArgumentError) { c = b - a }    \n", "target": "using System;\nusing System.Globalization;\n\nstruct LimitedInt : IComparable, IComparable<LimitedInt>, IConvertible, IEquatable<LimitedInt>, IFormattable\n{\n    const int MIN_VALUE = 1;\n    const int MAX_VALUE = 10;\n\n    public static readonly LimitedInt MinValue = new LimitedInt(MIN_VALUE);\n    public static readonly LimitedInt MaxValue = new LimitedInt(MAX_VALUE);\n\n    static bool IsValidValue(int value) => value >= MIN_VALUE && value <= MAX_VALUE;\n\n    readonly int _value;\n    public int Value => this._value == 0 ? MIN_VALUE : this._value; \n\n    public LimitedInt(int value)\n    {\n        if (!IsValidValue(value))\n            throw new ArgumentOutOfRangeException(nameof(value), value, $\"Value must be between {MIN_VALUE} and {MAX_VALUE}.\");\n        this._value = value;\n    }\n\n    #region IComparable\n    public int CompareTo(object obj)\n    {\n        if (obj is LimitedInt l) return this.Value.CompareTo(l);\n        throw new ArgumentException(\"Object must be of type \" + nameof(LimitedInt), nameof(obj));\n    }\n    #endregion\n\n    #region IComparable<LimitedInt>\n    public int CompareTo(LimitedInt other) => this.Value.CompareTo(other.Value);\n    #endregion\n\n    #region IConvertible\n    public TypeCode GetTypeCode() => this.Value.GetTypeCode();\n    bool IConvertible.ToBoolean(IFormatProvider provider) => ((IConvertible)this.Value).ToBoolean(provider);\n    byte IConvertible.ToByte(IFormatProvider provider) => ((IConvertible)this.Value).ToByte(provider);\n    char IConvertible.ToChar(IFormatProvider provider) => ((IConvertible)this.Value).ToChar(provider);\n    DateTime IConvertible.ToDateTime(IFormatProvider provider) => ((IConvertible)this.Value).ToDateTime(provider);\n    decimal IConvertible.ToDecimal(IFormatProvider provider) => ((IConvertible)this.Value).ToDecimal(provider);\n    double IConvertible.ToDouble(IFormatProvider provider) => ((IConvertible)this.Value).ToDouble(provider);\n    short IConvertible.ToInt16(IFormatProvider provider) => ((IConvertible)this.Value).ToInt16(provider);\n    int IConvertible.ToInt32(IFormatProvider provider) => ((IConvertible)this.Value).ToInt32(provider);\n    long IConvertible.ToInt64(IFormatProvider provider) => ((IConvertible)this.Value).ToInt64(provider);\n    sbyte IConvertible.ToSByte(IFormatProvider provider) => ((IConvertible)this.Value).ToSByte(provider);\n    float IConvertible.ToSingle(IFormatProvider provider) => ((IConvertible)this.Value).ToSingle(provider);\n    string IConvertible.ToString(IFormatProvider provider) => this.Value.ToString(provider);\n    object IConvertible.ToType(Type conversionType, IFormatProvider provider) => ((IConvertible)this.Value).ToType(conversionType, provider);\n    ushort IConvertible.ToUInt16(IFormatProvider provider) => ((IConvertible)this.Value).ToUInt16(provider);\n    uint IConvertible.ToUInt32(IFormatProvider provider) => ((IConvertible)this.Value).ToUInt32(provider);\n    ulong IConvertible.ToUInt64(IFormatProvider provider) => ((IConvertible)this.Value).ToUInt64(provider);\n    #endregion\n\n    #region IEquatable<LimitedInt>\n    public bool Equals(LimitedInt other) => this == other;\n    #endregion\n\n    #region IFormattable\n    public string ToString(string format, IFormatProvider formatProvider) => this.Value.ToString(format, formatProvider);\n    #endregion\n\n    #region operators\n    public static bool operator ==(LimitedInt left, LimitedInt right) => left.Value == right.Value;\n    public static bool operator !=(LimitedInt left, LimitedInt right) => left.Value != right.Value;\n    public static bool operator <(LimitedInt left, LimitedInt right) => left.Value < right.Value;\n    public static bool operator >(LimitedInt left, LimitedInt right) => left.Value > right.Value;\n    public static bool operator <=(LimitedInt left, LimitedInt right) => left.Value <= right.Value;\n    public static bool operator >=(LimitedInt left, LimitedInt right) => left.Value >= right.Value;\n\n    public static LimitedInt operator ++(LimitedInt left) => (LimitedInt)(left.Value + 1);\n    public static LimitedInt operator --(LimitedInt left) => (LimitedInt)(left.Value - 1);\n\n    public static LimitedInt operator +(LimitedInt left, LimitedInt right) => (LimitedInt)(left.Value + right.Value);\n    public static LimitedInt operator -(LimitedInt left, LimitedInt right) => (LimitedInt)(left.Value - right.Value);\n    public static LimitedInt operator *(LimitedInt left, LimitedInt right) => (LimitedInt)(left.Value * right.Value);\n    public static LimitedInt operator /(LimitedInt left, LimitedInt right) => (LimitedInt)(left.Value / right.Value);\n    public static LimitedInt operator %(LimitedInt left, LimitedInt right) => (LimitedInt)(left.Value % right.Value);\n\n    public static LimitedInt operator &(LimitedInt left, LimitedInt right) => (LimitedInt)(left.Value & right.Value);\n    public static LimitedInt operator |(LimitedInt left, LimitedInt right) => (LimitedInt)(left.Value | right.Value);\n    public static LimitedInt operator ^(LimitedInt left, LimitedInt right) => (LimitedInt)(left.Value ^ right.Value);\n    public static LimitedInt operator ~(LimitedInt left) => (LimitedInt)~left.Value;\n\n    public static LimitedInt operator >>(LimitedInt left, int right) => (LimitedInt)(left.Value >> right);\n    public static LimitedInt operator <<(LimitedInt left, int right) => (LimitedInt)(left.Value << right);\n\n    public static implicit operator int(LimitedInt value) => value.Value;\n    public static explicit operator LimitedInt(int value)\n    {\n        if (!IsValidValue(value)) throw new OverflowException();\n        return new LimitedInt(value);\n    }\n    #endregion\n\n    public bool TryFormat(Span<char> destination, out int charsWritten, ReadOnlySpan<char> format = default, IFormatProvider provider = null)\n        => this.Value.TryFormat(destination, out charsWritten, format, provider);\n\n    public override int GetHashCode() => this.Value.GetHashCode();\n    public override bool Equals(object obj) => obj is LimitedInt l && this.Equals(l);\n    public override string ToString() => this.Value.ToString();\n\n    #region static methods\n    public static bool TryParse(ReadOnlySpan<char> s, out int result) => int.TryParse(s, out result);\n    public static bool TryParse(ReadOnlySpan<char> s, NumberStyles style, IFormatProvider provider, out int result) => int.TryParse(s, style, provider, out result);\n    public static int Parse(string s, IFormatProvider provider) => int.Parse(s, provider);\n    public static int Parse(string s, NumberStyles style, IFormatProvider provider) => int.Parse(s, style, provider);\n    public static bool TryParse(string s, NumberStyles style, IFormatProvider provider, ref int result) => int.TryParse(s, style, provider, out result);\n    public static int Parse(string s) => int.Parse(s);\n    public static int Parse(string s, NumberStyles style) => int.Parse(s, style);\n    public static int Parse(ReadOnlySpan<char> s, NumberStyles style = NumberStyles.Integer, IFormatProvider provider = null) => int.Parse(s, style, provider);\n    public static bool TryParse(string s, ref int result) => int.TryParse(s, out result);\n    #endregion\n}\n"}
{"id": 157658, "name": "Define a primitive data type", "source": "Translate Ruby to Java: require 'test/unit'\ninclude Test::Unit::Assertions\n\nclass MyInt\n  @@min = 1\n  @@max = 10\n  \n  attr_reader :value\n  private :value\n  \n  def initialize(val)\n    begin\n      v = Integer(val)\n    rescue ArgumentError\n      raise ArgumentError, \"invalid value '\n    end\n    \n    unless v.between?(@@min, @@max)\n      raise ArgumentError, \"invalid value '\n    end\n    \n    @value = v\n  end\n  \n  def method_missing(m, *args)\n    super unless @value.respond_to?(m)\n    myint_args = args.collect do |arg|\n      arg.kind_of?(self.class) ? arg.to_int : arg\n    end\n    result = @value.send(m, *myint_args)\n    return result if m == :coerce\n    case result\n    when Integer\n      MyInt.new(result)\n    when Array\n      result.collect do |element|\n        element.kind_of?(Integer) ? MyInt.new(element) : element\n      end\n    else\n      result\n    end\n  end\n  \n  def respond_to?(method)\n    super or @value.respond_to? method\n  end\n  \n  def to_int\n    @value\n  end\n  def to_f\n    Float(@value)\n  end\n  def to_s\n    @value.to_s\n  end\n  def inspect\n    to_s\n  end\nend\n\n\nassert_raise(ArgumentError) { MyInt.new(\"foo\") }    \nassert_raise(ArgumentError) { MyInt.new(11) }       \n\na = MyInt.new(7)\nb = MyInt.new(5)\n\nc = 5 + a\nassert_kind_of(Fixnum, c)\nassert_equal(12, c)\n\nc = a + 2\nassert_kind_of(MyInt, c)\nassert_equal(9, c.to_int)\n\nc = a + 2.8\nassert_kind_of(Float, c)\nassert_equal(9.8, c)\n\nc = a - b\nassert_kind_of(MyInt, c)\nassert_equal(2, c.to_int)\n\nassert_raise(ArgumentError) { c = a + b }    \nassert_raise(ArgumentError) { c = b - a }    \n", "target": "class BoundedIntOutOfBoundsException extends Exception\n{\n  public BoundedIntOutOfBoundsException(int v, int l, int u) {\n    super(\"value \" + v + \" is out of bounds [\" + l + \",\" + u + \"]\");\n  }\n}\n\nclass BoundedInt {\n  private int value;\n  private int lower;\n  private int upper;\n\n  public BoundedInt(int l, int u) {\n    lower = Math.min(l, u);\n    upper = Math.max(l, u);\n  }\n\n  private boolean checkBounds(int v) {\n    return (v >= this.lower) && (v <= this.upper);\n  }\n\n  public void assign(BoundedInt i) throws BoundedIntOutOfBoundsException {{\n    assign(i.value()); \n  }\n\n  public void assign(int v) throws BoundedIntOutOfBoundsException {\n    if ( checkBounds(v) ) {\n      this.value = v;\n    } else {\n      throw new BoundedIntOutOfBoundsException(v, this.lower, this.upper);\n    }\n  }\n\n  public int add(BoundedInt i) throws BoundedIntOutOfBoundsException {\n    return add(i.value());\n  }\n\n  public int add(int i) throws BoundedIntOutOfBoundsException {\n    if ( checkBounds(this.value + i) ) {\n      this.value += i;\n    }  else {\n      throw new BoundedIntOutOfBoundsException(this.value + i, this.lower, this.upper);\n    }\n    return this.value;\n  }\n\n  public int value() {\n    return this.value;\n  }\n}\n\n\npublic class Bounded {\n  public static void main(String[] args) throws BoundedIntOutOfBoundsException {\n    BoundedInt a = new BoundedInt(1, 10);\n    BoundedInt b = new BoundedInt(1, 10);\n\n    a.assign(6);\n    try {\n      b.assign(12);\n    } catch (Exception e) {\n      System.out.println(e.getMessage());\n    }\n    b.assign(9);\n    try {\n      a.add(b.value());\n    } catch (Exception e) {\n      System.out.println(e.getMessage());\n    }\n  }\n}\n"}
{"id": 157659, "name": "Define a primitive data type", "source": "Translate Ruby to Python: require 'test/unit'\ninclude Test::Unit::Assertions\n\nclass MyInt\n  @@min = 1\n  @@max = 10\n  \n  attr_reader :value\n  private :value\n  \n  def initialize(val)\n    begin\n      v = Integer(val)\n    rescue ArgumentError\n      raise ArgumentError, \"invalid value '\n    end\n    \n    unless v.between?(@@min, @@max)\n      raise ArgumentError, \"invalid value '\n    end\n    \n    @value = v\n  end\n  \n  def method_missing(m, *args)\n    super unless @value.respond_to?(m)\n    myint_args = args.collect do |arg|\n      arg.kind_of?(self.class) ? arg.to_int : arg\n    end\n    result = @value.send(m, *myint_args)\n    return result if m == :coerce\n    case result\n    when Integer\n      MyInt.new(result)\n    when Array\n      result.collect do |element|\n        element.kind_of?(Integer) ? MyInt.new(element) : element\n      end\n    else\n      result\n    end\n  end\n  \n  def respond_to?(method)\n    super or @value.respond_to? method\n  end\n  \n  def to_int\n    @value\n  end\n  def to_f\n    Float(@value)\n  end\n  def to_s\n    @value.to_s\n  end\n  def inspect\n    to_s\n  end\nend\n\n\nassert_raise(ArgumentError) { MyInt.new(\"foo\") }    \nassert_raise(ArgumentError) { MyInt.new(11) }       \n\na = MyInt.new(7)\nb = MyInt.new(5)\n\nc = 5 + a\nassert_kind_of(Fixnum, c)\nassert_equal(12, c)\n\nc = a + 2\nassert_kind_of(MyInt, c)\nassert_equal(9, c.to_int)\n\nc = a + 2.8\nassert_kind_of(Float, c)\nassert_equal(9.8, c)\n\nc = a - b\nassert_kind_of(MyInt, c)\nassert_equal(2, c.to_int)\n\nassert_raise(ArgumentError) { c = a + b }    \nassert_raise(ArgumentError) { c = b - a }    \n", "target": ">>> class num(int):\n    def __init__(self, b):\n        if 1 <= b <= 10:\n            return int.__init__(self+0)\n        else:\n            raise ValueError,\"Value %s should be >=0 and <= 10\" % b\n\n        \n>>> x = num(3)\n>>> x = num(11)\n\nTraceback (most recent call last):\n  File \"<pyshell\n    x = num(11)\n  File \"<pyshell\n    raise ValueError,\"Value %s should be >=0 and <= 10\" % b\nValueError: Value 11 should be >=0 and <= 10\n>>> x\n3\n>>> type(x)\n<class '__main__.num'>\n>>>\n"}
{"id": 157785, "name": "Palindrome dates", "source": "Translate Ruby to C#: require 'date'\n\npalindate = Enumerator.new do |yielder|\n  (\"2020\"..).each do |y|\n    m, d = y.reverse.scan(/../) \n    strings = [y, m, d]\n    yielder << strings.join(\"-\") if Date.valid_date?( *strings.map( &:to_i ) )\n  end\nend\n\nputs palindate.take(15)\n", "target": "using System;\nusing System.Linq;\nusing System.Collections.Generic;\n\npublic class Program\n{\n    static void Main()\n    {\n        foreach (var date in PalindromicDates(2021).Take(15)) WriteLine(date.ToString(\"yyyy-MM-dd\"));\n    }\n\n    public static IEnumerable<DateTime> PalindromicDates(int startYear) {\n        for (int y = startYear; ; y++) {\n            int m = Reverse(y % 100);\n            int d = Reverse(y / 100);\n            if (IsValidDate(y, m, d, out var date)) yield return date;\n        }\n\n        int Reverse(int x) => x % 10 * 10 + x / 10;\n        bool IsValidDate(int y, int m, int d, out DateTime date) => DateTime.TryParse($\"{y}-{m}-{d}\", out date);\n    }\n}\n"}
{"id": 157787, "name": "Palindrome dates", "source": "Translate Ruby to Java: require 'date'\n\npalindate = Enumerator.new do |yielder|\n  (\"2020\"..).each do |y|\n    m, d = y.reverse.scan(/../) \n    strings = [y, m, d]\n    yielder << strings.join(\"-\") if Date.valid_date?( *strings.map( &:to_i ) )\n  end\nend\n\nputs palindate.take(15)\n", "target": "import java.time.LocalDate;\nimport java.time.format.DateTimeFormatter;\n\npublic class PalindromeDates {\n\n    public static void main(String[] args) {\n        LocalDate date = LocalDate.of(2020, 2, 3);\n        DateTimeFormatter formatter = DateTimeFormatter.ofPattern(\"yyyyMMdd\");\n        DateTimeFormatter formatterDash = DateTimeFormatter.ofPattern(\"yyyy-MM-dd\");\n        System.out.printf(\"First 15 palindrome dates after 2020-02-02 are:%n\");\n        for ( int count = 0 ; count < 15 ; date = date.plusDays(1) ) {\n            String dateFormatted = date.format(formatter);\n            if ( dateFormatted.compareTo(new StringBuilder(dateFormatted).reverse().toString()) == 0 ) {\n                count++;\n                System.out.printf(\"date = %s%n\", date.format(formatterDash));\n            }\n        }\n    }\n\n}\n"}
{"id": 157788, "name": "Palindrome dates", "source": "Translate Ruby to Python: require 'date'\n\npalindate = Enumerator.new do |yielder|\n  (\"2020\"..).each do |y|\n    m, d = y.reverse.scan(/../) \n    strings = [y, m, d]\n    yielder << strings.join(\"-\") if Date.valid_date?( *strings.map( &:to_i ) )\n  end\nend\n\nputs palindate.take(15)\n", "target": "\n\nfrom datetime import datetime\nfrom itertools import chain\n\n\n\ndef palinDay(y):\n    \n    s = str(y)\n    r = s[::-1]\n    iso = '-'.join([s, r[0:2], r[2:]])\n    try:\n        datetime.strptime(iso, '%Y-%m-%d')\n        return [iso]\n    except ValueError:\n        return []\n\n\n\n\ndef main():\n    \n    palinDates = list(chain.from_iterable(\n        map(palinDay, range(2021, 10000))\n    ))\n    for x in [\n            'Count of palindromic dates [2021..9999]:',\n            len(palinDates),\n            '\\nFirst 15:',\n            '\\n'.join(palinDates[0:15]),\n            '\\nLast 15:',\n            '\\n'.join(palinDates[-15:])\n    ]:\n        print(x)\n\n\n\nif __name__ == '__main__':\n    main()\n"}
{"id": 158050, "name": "Phrase reversals", "source": "Translate Ruby to C#: str = \"rosetta code phrase reversal\"\n\nputs str.reverse                          \nputs str.split.map(&:reverse).join(\" \")   \nputs str.split.reverse.join(\" \")          \n", "target": "using System;\nusing System.Linq;\nnamespace ConsoleApplication\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            \n            \n            Func<string, string> reverse = s => new string(s.Reverse().ToArray());\n\n            string phrase = \"rosetta code phrase reversal\";\n            \n            Console.WriteLine(reverse(phrase));\n            \n            Console.WriteLine(string.Join(\" \", phrase.Split(' ').Select(word => reverse(word))));\n            \n            Console.WriteLine(string.Join(\" \", phrase.Split(' ').Reverse()));\n        }\n    }\n}\n"}
{"id": 158052, "name": "Phrase reversals", "source": "Translate Ruby to Java: str = \"rosetta code phrase reversal\"\n\nputs str.reverse                          \nputs str.split.map(&:reverse).join(\" \")   \nputs str.split.reverse.join(\" \")          \n", "target": "import java.util.Arrays;\n\npublic class PhraseRev{\n\tprivate static String reverse(String x){\n\t\treturn new StringBuilder(x).reverse().toString();\n\t}\n\t\n\tprivate static <T> T[] reverse(T[] x){\n\t\tT[] rev = Arrays.copyOf(x, x.length);\n\t\tfor(int i = x.length - 1; i >= 0; i--){\n\t\t\trev[x.length - 1 - i] = x[i];\n\t\t}\n\t\treturn rev;\n\t}\n\t\n\tprivate static String join(String[] arr, String joinStr){\n\t\tStringBuilder joined = new StringBuilder();\n\t\tfor(int i = 0; i < arr.length; i++){\n\t\t\tjoined.append(arr[i]);\n\t\t\tif(i < arr.length - 1) joined.append(joinStr);\n\t\t}\n\t\treturn joined.toString();\n\t}\n\t\n\tpublic static void main(String[] args){\n\t\tString str = \"rosetta code phrase reversal\";\n\t\t\n\t\tSystem.out.println(\"Straight-up reversed: \" + reverse(str));\n\t\tString[] words = str.split(\" \");\n\t\tfor(int i = 0; i < words.length; i++){\n\t\t\twords[i] = reverse(words[i]);\n\t\t}\n\t\tSystem.out.println(\"Reversed words: \" + join(words, \" \"));\n\t\tSystem.out.println(\"Reversed word order: \" + join(reverse(str.split(\" \")), \" \"));\n\t}\n}\n"}
{"id": 158053, "name": "Phrase reversals", "source": "Translate Ruby to Python: str = \"rosetta code phrase reversal\"\n\nputs str.reverse                          \nputs str.split.map(&:reverse).join(\" \")   \nputs str.split.reverse.join(\" \")          \n", "target": ">>> phrase = \"rosetta code phrase reversal\"\n>>> phrase[::-1]\t\t\t\t\t  \n'lasrever esarhp edoc attesor'\n>>> ' '.join(word[::-1] for word in phrase.split())\t  \n'attesor edoc esarhp lasrever'\n>>> ' '.join(phrase.split()[::-1])\t                  \n'reversal phrase code rosetta'\n>>>\n"}
{"id": 158188, "name": "Negative base numbers", "source": "Translate Ruby to C#: DIGITS = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz'\n\n\n\ndef negative_base_encode(n, b)\n  raise 'base out of range' if (b < -62) || (b > -2)\n  return '0' if n == 0\n  revdigs = []\n  while n != 0 do\n    n, r = n.divmod(b)\n    if r < 0\n      n += 1\n      r -= b\n    end\n    revdigs << r\n  end\n  return revdigs.reduce('') { |digstr, digit| DIGITS[digit] + digstr }\nend\n\n\n\ndef negative_base_decode(n, b)\n  raise 'base out of range' if (b < -62) || (b > -2)\n  value = 0\n  n.reverse.each_char.with_index do |ch, inx|\n    value += DIGITS.index(ch) * b**inx\n  end\n  return value\nend\n\n\n\n[ [10, -2], [146, -3], [15, -10], [0, -31], [-6221826, -62] ].each do |pair|\n  decimal, base = pair\n  encoded = negative_base_encode(decimal, base)\n  decoded = negative_base_decode(encoded, base)\n  puts(\"Enc: %8i base\u00a0%-3i = %5s base\u00a0%-3i  Dec: %5s base\u00a0%-3i = %8i base\u00a0%-3i\" %\n       [decimal, 10, encoded, base, encoded, base, decoded, 10])\nend\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\nnamespace NegativeBaseNumbers {\n    class Program {\n        const string DIGITS = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\";\n\n        static string EncodeNegativeBase(long n, int b) {\n            if (b < -62 || b > -1) {\n                throw new ArgumentOutOfRangeException(\"b\");\n            }\n            if (n == 0) {\n                return \"0\";\n            }\n            StringBuilder output = new StringBuilder();\n            long nn = n;\n            while (nn != 0) {\n                int rem = (int)(nn % b);\n                nn /= b;\n                if (rem < 0) {\n                    nn++;\n                    rem -= b;\n                }\n                output.Append(DIGITS[rem]);\n            }\n            return new string(output.ToString().Reverse().ToArray());\n        }\n\n        static long DecodeNegativeBase(string ns, int b) {\n            if (b < -62 || b > -1) {\n                throw new ArgumentOutOfRangeException(\"b\");\n            }\n            if (ns == \"0\") {\n                return 0;\n            }\n            long total = 0;\n            long bb = 1;\n            for (int i = ns.Length - 1; i >= 0; i--) {\n                char c = ns[i];\n                total += DIGITS.IndexOf(c) * bb;\n                bb *= b;\n            }\n            return total;\n        }\n\n        static void Main(string[] args) {\n            List<Tuple<long, int>> nbl = new List<Tuple<long, int>>() {\n                new Tuple<long, int>(10,-2),\n                new Tuple<long, int>(146,-3),\n                new Tuple<long, int>(15,-10),\n                new Tuple<long, int>(-34025238427,-62),\n            };\n            foreach (var p in nbl) {\n                string ns = EncodeNegativeBase(p.Item1, p.Item2);\n                Console.WriteLine(\"{0,12} encoded in base {1,-3} = {2}\", p.Item1, p.Item2, ns);\n                long n = DecodeNegativeBase(ns, p.Item2);\n                Console.WriteLine(\"{0,12} decoded in base {1,-3} = {2}\", ns, p.Item2, n);\n                Console.WriteLine();\n            }\n        }\n    }\n}\n"}
{"id": 158190, "name": "Negative base numbers", "source": "Translate Ruby to Java: DIGITS = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz'\n\n\n\ndef negative_base_encode(n, b)\n  raise 'base out of range' if (b < -62) || (b > -2)\n  return '0' if n == 0\n  revdigs = []\n  while n != 0 do\n    n, r = n.divmod(b)\n    if r < 0\n      n += 1\n      r -= b\n    end\n    revdigs << r\n  end\n  return revdigs.reduce('') { |digstr, digit| DIGITS[digit] + digstr }\nend\n\n\n\ndef negative_base_decode(n, b)\n  raise 'base out of range' if (b < -62) || (b > -2)\n  value = 0\n  n.reverse.each_char.with_index do |ch, inx|\n    value += DIGITS.index(ch) * b**inx\n  end\n  return value\nend\n\n\n\n[ [10, -2], [146, -3], [15, -10], [0, -31], [-6221826, -62] ].each do |pair|\n  decimal, base = pair\n  encoded = negative_base_encode(decimal, base)\n  decoded = negative_base_decode(encoded, base)\n  puts(\"Enc: %8i base\u00a0%-3i = %5s base\u00a0%-3i  Dec: %5s base\u00a0%-3i = %8i base\u00a0%-3i\" %\n       [decimal, 10, encoded, base, encoded, base, decoded, 10])\nend\n", "target": "import java.util.List;\nimport java.util.Map;\nimport java.util.Objects;\n\npublic class NegativeBaseNumbers {\n    private static final String DIGITS = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\";\n\n    private static String encodeNegBase(long n, int b) {\n        if (b < -62 || b > -1) throw new IllegalArgumentException(\"Parameter b is out of bounds\");\n        if (n == 0) return \"0\";\n        StringBuilder out = new StringBuilder();\n        long nn = n;\n        while (nn != 0) {\n            int rem = (int) (nn % b);\n            nn /= b;\n            if (rem < 0) {\n                nn++;\n                rem -= b;\n            }\n            out.append(DIGITS.charAt(rem));\n        }\n        out.reverse();\n        return out.toString();\n    }\n\n    private static long decodeNegBase(String ns, int b) {\n        if (b < -62 || b > -1) throw new IllegalArgumentException(\"Parameter b is out of bounds\");\n        if (Objects.equals(ns, \"0\")) return 0;\n        long total = 0;\n        long bb = 1;\n        for (int i = ns.length() - 1; i >= 0; i--) {\n            char c = ns.charAt(i);\n            total += DIGITS.indexOf(c) * bb;\n            bb *= b;\n        }\n        return total;\n    }\n\n    public static void main(String[] args) {\n        List<Map.Entry<Long, Integer>> nbl = List.of(\n                Map.entry(10L, -2),\n                Map.entry(146L, -3),\n                Map.entry(15L, -10),\n                Map.entry(-4393346L, -62)\n        );\n        for (Map.Entry<Long, Integer> p : nbl) {\n            String ns = encodeNegBase(p.getKey(), p.getValue());\n            System.out.printf(\"%12d encoded in base\u00a0%-3d = %s\\n\", p.getKey(), p.getValue(), ns);\n            long n = decodeNegBase(ns, p.getValue());\n            System.out.printf(\"%12s decoded in base\u00a0%-3d = %d\\n\\n\", ns, p.getValue(), n);\n        }\n    }\n}\n"}
{"id": 158191, "name": "Negative base numbers", "source": "Translate Ruby to Python: DIGITS = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz'\n\n\n\ndef negative_base_encode(n, b)\n  raise 'base out of range' if (b < -62) || (b > -2)\n  return '0' if n == 0\n  revdigs = []\n  while n != 0 do\n    n, r = n.divmod(b)\n    if r < 0\n      n += 1\n      r -= b\n    end\n    revdigs << r\n  end\n  return revdigs.reduce('') { |digstr, digit| DIGITS[digit] + digstr }\nend\n\n\n\ndef negative_base_decode(n, b)\n  raise 'base out of range' if (b < -62) || (b > -2)\n  value = 0\n  n.reverse.each_char.with_index do |ch, inx|\n    value += DIGITS.index(ch) * b**inx\n  end\n  return value\nend\n\n\n\n[ [10, -2], [146, -3], [15, -10], [0, -31], [-6221826, -62] ].each do |pair|\n  decimal, base = pair\n  encoded = negative_base_encode(decimal, base)\n  decoded = negative_base_decode(encoded, base)\n  puts(\"Enc: %8i base\u00a0%-3i = %5s base\u00a0%-3i  Dec: %5s base\u00a0%-3i = %8i base\u00a0%-3i\" %\n       [decimal, 10, encoded, base, encoded, base, decoded, 10])\nend\n", "target": "\nfrom __future__ import print_function\n\ndef EncodeNegBase(n, b): \n\tif n == 0:\n\t\treturn \"0\"\n\tout = []\n\twhile n != 0:\n\t\tn, rem = divmod(n, b)\n\t\tif rem < 0:\n\t\t\tn += 1\n\t\t\trem -= b\n\t\tout.append(rem)\n\treturn \"\".join(map(str, out[::-1]))\n\ndef DecodeNegBase(nstr, b): \n\tif nstr == \"0\":\n\t\treturn 0\n\t\n\ttotal = 0\n\tfor i, ch in enumerate(nstr[::-1]):\n\t\ttotal += int(ch) * b**i\n\treturn total\n\nif __name__==\"__main__\":\n\t\n\tprint (\"Encode 10 as negabinary (expect 11110)\")\n\tresult = EncodeNegBase(10, -2)\n\tprint (result)\n\tif DecodeNegBase(result, -2) == 10: print (\"Converted back to decimal\")\n\telse: print (\"Error converting back to decimal\")\n\n\tprint (\"Encode 146 as negaternary (expect 21102)\")\n\tresult = EncodeNegBase(146, -3)\n\tprint (result)\n\tif DecodeNegBase(result, -3) == 146: print (\"Converted back to decimal\")\n\telse: print (\"Error converting back to decimal\")\n\n\tprint (\"Encode 15 as negadecimal (expect 195)\")\n\tresult = EncodeNegBase(15, -10)\n\tprint (result)\n\tif DecodeNegBase(result, -10) == 15: print (\"Converted back to decimal\")\n\telse: print (\"Error converting back to decimal\")\n"}
{"id": 158377, "name": "Old lady swallowed a fly", "source": "Translate Ruby to C#: descriptions = {\n  :fly    => \"I don't know why S\",\n  :spider => \"That wriggled and jiggled and tickled inside her.\",\n  :bird   => \"Quite absurd T\",\n  :cat    => \"Fancy that, S\",\n  :dog    => \"What a hog, S\",\n  :goat   => \"She opened her throat T\",\n  :cow    => \"I don't know how S\",\n  :horse  => \"She's dead, of course.\",\n}\nanimals = descriptions.keys\n\nanimals.each_with_index do |animal, idx|\n  puts \"There was an old lady who swallowed a \n\n  d = descriptions[animal]\n  case d[-1]\n  when \"S\" then d[-1] = \"she swallowed a \n  when \"T\" then d[-1] = \"to swallow a \n  end\n  puts d\n  break if animal == :horse\n\n  idx.downto(1) do |i|\n    puts \"She swallowed the \n    case animals[i-1]\n    when :spider, :fly then puts descriptions[animals[i-1]]\n    end\n  end\n\n  print \"Perhaps she'll die.\\n\\n\"\nend\n", "target": "using System;\n\nnamespace OldLady\n{\n    internal class Program\n    {\n        private const string reason = \"She swallowed the {0} to catch the {1}\";\n        private static readonly string[] creatures = {\"fly\", \"spider\", \"bird\", \"cat\", \"dog\", \"goat\", \"cow\", \"horse\"};\n\n        private static readonly string[] comments =\n        {\n            \"I don't know why she swallowed that fly.\\nPerhaps she'll die\\n\",\n            \"That wiggled and jiggled and tickled inside her\",\n            \"How absurd, to swallow a bird\",\n            \"Imagine that. She swallowed a cat\",\n            \"What a hog to swallow a dog\",\n            \"She just opened her throat and swallowed that goat\",\n            \"I don't know how she swallowed that cow\",\n            \"She's dead of course\"\n        };\n\n        private static void Main()\n        {\n            int max = creatures.Length;\n            for (int i = 0; i < max; i++)\n            {\n                Console.WriteLine(\"There was an old lady who swallowed a {0}\", creatures[i]);\n                Console.WriteLine(comments[i]);\n                for (int j = i; j > 0 && i < max - 1; j--)\n                {\n                    Console.WriteLine(reason, creatures[j], creatures[j - 1]);\n                    if (j == 1)\n                    {\n                        Console.WriteLine(comments[j - 1]);\n                    }\n                }\n            }\n            Console.Read();\n        }\n    }\n}\n"}
{"id": 158379, "name": "Old lady swallowed a fly", "source": "Translate Ruby to Java: descriptions = {\n  :fly    => \"I don't know why S\",\n  :spider => \"That wriggled and jiggled and tickled inside her.\",\n  :bird   => \"Quite absurd T\",\n  :cat    => \"Fancy that, S\",\n  :dog    => \"What a hog, S\",\n  :goat   => \"She opened her throat T\",\n  :cow    => \"I don't know how S\",\n  :horse  => \"She's dead, of course.\",\n}\nanimals = descriptions.keys\n\nanimals.each_with_index do |animal, idx|\n  puts \"There was an old lady who swallowed a \n\n  d = descriptions[animal]\n  case d[-1]\n  when \"S\" then d[-1] = \"she swallowed a \n  when \"T\" then d[-1] = \"to swallow a \n  end\n  puts d\n  break if animal == :horse\n\n  idx.downto(1) do |i|\n    puts \"She swallowed the \n    case animals[i-1]\n    when :spider, :fly then puts descriptions[animals[i-1]]\n    end\n  end\n\n  print \"Perhaps she'll die.\\n\\n\"\nend\n", "target": "public class OldLadySwallowedAFly {\n\n    final static String[] data = {\n        \"_ha _c _e _p,/Quite absurd_f_p;_`cat,/Fancy that_fcat;_j`dog,/What a hog\"\n        + \"_fdog;_l`pig,/Her mouth_qso big_fpig;_d_r,/She just opened her throat_f_\"\n        + \"r;_icow,/_mhow she_ga cow;_k_o,/It_qrather wonky_f_o;_a_o_bcow,_khorse..\"\n        + \"./She's dead, of course!/\", \"_a_p_b_e \", \"/S_t \", \" to catch the \", \"fly,/Bu\"\n        + \"t _mwhy s_t fly,/Perhaps she'll die!\n        + \"t wr_nj_ntickled inside her;_aspider_b_c\", \", to_s a \", \"_sed \", \"There_qan\"\n        + \" old lady who_g\", \"_a_r_bpig,_d\", \"_acat_b_p,_\", \"_acow_b_r,_i\", \"_adog_bcat\"\n        + \",_j\", \"I don't know \", \"iggled and \", \"donkey\", \"bird\", \" was \", \"goat\", \" swal\"\n        + \"low\", \"he_gthe\"};\n\n    static boolean oldLady(String part, boolean s) {\n        for (char c : part.toCharArray()) {\n            if (s)\n                s = oldLady(data[c - '_'], false);\n            else if (c == '_')\n                s = true;\n            else\n                System.out.print(c == '/' ? '\\n' : c);\n        }\n        return s;\n    }\n\n    public static void main(String[] args) {\n        oldLady(data[0], false);\n    }\n}\n"}
{"id": 158380, "name": "Old lady swallowed a fly", "source": "Translate Ruby to Python: descriptions = {\n  :fly    => \"I don't know why S\",\n  :spider => \"That wriggled and jiggled and tickled inside her.\",\n  :bird   => \"Quite absurd T\",\n  :cat    => \"Fancy that, S\",\n  :dog    => \"What a hog, S\",\n  :goat   => \"She opened her throat T\",\n  :cow    => \"I don't know how S\",\n  :horse  => \"She's dead, of course.\",\n}\nanimals = descriptions.keys\n\nanimals.each_with_index do |animal, idx|\n  puts \"There was an old lady who swallowed a \n\n  d = descriptions[animal]\n  case d[-1]\n  when \"S\" then d[-1] = \"she swallowed a \n  when \"T\" then d[-1] = \"to swallow a \n  end\n  puts d\n  break if animal == :horse\n\n  idx.downto(1) do |i|\n    puts \"She swallowed the \n    case animals[i-1]\n    when :spider, :fly then puts descriptions[animals[i-1]]\n    end\n  end\n\n  print \"Perhaps she'll die.\\n\\n\"\nend\n", "target": "import zlib, base64\n\nb64 = b\nprint(zlib.decompress(base64.b64decode(b64)).decode(\"utf-8\", \"strict\"))\n"}
{"id": 158566, "name": "Move-to-front algorithm", "source": "Translate Ruby to C#: module MoveToFront\n  \n  ABC = (\"a\"..\"z\").to_a.freeze\n  \n  def self.encode(str)\n    ar = ABC.dup\n    str.chars.each_with_object([]) do |char, memo|\n      memo << (i = ar.index(char))\n      ar = m2f(ar,i)\n    end\n  end\n  \n  def self.decode(indices)\n    ar = ABC.dup\n    indices.each_with_object(\"\") do |i, str|\n      str << ar[i]\n      ar = m2f(ar,i)\n    end\n  end\n  \n  private\n  def self.m2f(ar,i)\n    [ar.delete_at(i)] + ar\n  end\n  \nend\n\n['broood', 'bananaaa', 'hiphophiphop'].each do |word|\n  p word == MoveToFront.decode(p MoveToFront.encode(p word))\nend\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Text;\n\nnamespace MoveToFront\n{\n    class Program\n    {\n        private static char[] symbolTable;\n        private static void setSymbolTable()\n        {\n            symbolTable = \"abcdefghijklmnopqrstuvwxyz\".ToCharArray();\n        }\n\n        private static void moveToFront(int charIndex)\n        {\n            char toFront = symbolTable[charIndex];\n            for (int j = charIndex; j > 0; j--)\n            {\n                symbolTable[j] = symbolTable[j - 1];\n            }\n            symbolTable[0] = toFront;\n        }\n\n        public static int[] Encode(string input)\n        {\n            setSymbolTable();\n            var output = new List<int>();\n            foreach (char c in input)\n            {\n                for (int i = 0; i < 26; i++)\n                {\n                    if (symbolTable[i] == c)\n                    {\n                        output.Add(i);\n                        moveToFront(i);\n                        break;\n                    }\n                }\n            }         \n            return output.ToArray();\n        }\n\n        public static string Decode(int[] input)\n        {\n            setSymbolTable();\n            var output = new StringBuilder(input.Length);\n            foreach (int n in input)\n            {\n                output.Append(symbolTable[n]);\n                moveToFront(n);\n            }\n            return output.ToString();\n        }\n\n        static void Main(string[] args)\n        {\n            string[] testInputs = new string[] { \"broood\", \"bananaaa\", \"hiphophiphop\" };\n            int[] encoding;\n            foreach (string s in testInputs) \n            {\n                Console.WriteLine($\"Encoding for '{s}':\");\n                encoding = Encode(s);\n                foreach (int i in encoding)\n                {\n                    Console.Write($\"{i} \");\n                }\n                Console.WriteLine($\"\\nDecoding for '{s}':\");\n                Console.WriteLine($\"{Decode(encoding)}\\n\");\n            }\n        }\n    }\n}\n"}
{"id": 158568, "name": "Move-to-front algorithm", "source": "Translate Ruby to Java: module MoveToFront\n  \n  ABC = (\"a\"..\"z\").to_a.freeze\n  \n  def self.encode(str)\n    ar = ABC.dup\n    str.chars.each_with_object([]) do |char, memo|\n      memo << (i = ar.index(char))\n      ar = m2f(ar,i)\n    end\n  end\n  \n  def self.decode(indices)\n    ar = ABC.dup\n    indices.each_with_object(\"\") do |i, str|\n      str << ar[i]\n      ar = m2f(ar,i)\n    end\n  end\n  \n  private\n  def self.m2f(ar,i)\n    [ar.delete_at(i)] + ar\n  end\n  \nend\n\n['broood', 'bananaaa', 'hiphophiphop'].each do |word|\n  p word == MoveToFront.decode(p MoveToFront.encode(p word))\nend\n", "target": "import java.util.LinkedList;\nimport java.util.List;\n\npublic class MTF{\n\tpublic static List<Integer> encode(String msg, String symTable){\n\t\tList<Integer> output = new LinkedList<Integer>();\n\t\tStringBuilder s = new StringBuilder(symTable);\n\t\tfor(char c : msg.toCharArray()){\n\t\t\tint idx = s.indexOf(\"\" + c);\n\t\t\toutput.add(idx);\n\t\t\ts = s.deleteCharAt(idx).insert(0, c);\n\t\t}\n\t\treturn output;\n\t}\n\t\n\tpublic static String decode(List<Integer> idxs, String symTable){\n\t\tStringBuilder output = new StringBuilder();\n\t\tStringBuilder s = new StringBuilder(symTable);\n\t\tfor(int idx : idxs){\n\t\t\tchar c = s.charAt(idx);\n\t\t\toutput = output.append(c);\n\t\t\ts = s.deleteCharAt(idx).insert(0, c);\n\t\t}\n\t\treturn output.toString();\n\t}\n\t\n\tprivate static void test(String toEncode, String symTable){\n\t\tList<Integer> encoded = encode(toEncode, symTable);\n\t\tSystem.out.println(toEncode + \": \" + encoded);\n\t\tString decoded = decode(encoded, symTable);\n\t\tSystem.out.println((toEncode.equals(decoded) ? \"\" : \"in\") + \"correctly decoded to \" + decoded);\n\t}\n\t\n\tpublic static void main(String[] args){\n\t\tString symTable = \"abcdefghijklmnopqrstuvwxyz\";\n\t\ttest(\"broood\", symTable);\n\t\ttest(\"bananaaa\", symTable);\n\t\ttest(\"hiphophiphop\", symTable);\n\t}\n}\n"}
{"id": 158569, "name": "Move-to-front algorithm", "source": "Translate Ruby to Python: module MoveToFront\n  \n  ABC = (\"a\"..\"z\").to_a.freeze\n  \n  def self.encode(str)\n    ar = ABC.dup\n    str.chars.each_with_object([]) do |char, memo|\n      memo << (i = ar.index(char))\n      ar = m2f(ar,i)\n    end\n  end\n  \n  def self.decode(indices)\n    ar = ABC.dup\n    indices.each_with_object(\"\") do |i, str|\n      str << ar[i]\n      ar = m2f(ar,i)\n    end\n  end\n  \n  private\n  def self.m2f(ar,i)\n    [ar.delete_at(i)] + ar\n  end\n  \nend\n\n['broood', 'bananaaa', 'hiphophiphop'].each do |word|\n  p word == MoveToFront.decode(p MoveToFront.encode(p word))\nend\n", "target": "from __future__ import print_function\nfrom string import ascii_lowercase\n\nSYMBOLTABLE = list(ascii_lowercase)\n\ndef move2front_encode(strng, symboltable):\n    sequence, pad = [], symboltable[::]\n    for char in strng:\n        indx = pad.index(char)\n        sequence.append(indx)\n        pad = [pad.pop(indx)] + pad\n    return sequence\n\ndef move2front_decode(sequence, symboltable):\n    chars, pad = [], symboltable[::]\n    for indx in sequence:\n        char = pad[indx]\n        chars.append(char)\n        pad = [pad.pop(indx)] + pad\n    return ''.join(chars)\n\nif __name__ == '__main__':\n    for s in ['broood', 'bananaaa', 'hiphophiphop']:\n        encode = move2front_encode(s, SYMBOLTABLE)\n        print('%14r encodes to %r' % (s, encode), end=', ')\n        decode = move2front_decode(encode, SYMBOLTABLE)\n        print('which decodes back to %r' % decode)\n        assert s == decode, 'Whoops!'\n"}
{"id": 158758, "name": "Get system command output", "source": "Translate Ruby to C#: str = `ls`   \narr = `ls`.lines\n", "target": "using System;\n\nnamespace GetSystemCommandOutput {\n    class Program {\n        static void Main(string[] args) {\n            System.Diagnostics.Process process = new System.Diagnostics.Process();\n            System.Diagnostics.ProcessStartInfo startInfo = new System.Diagnostics.ProcessStartInfo();\n            startInfo.WindowStyle = System.Diagnostics.ProcessWindowStyle.Hidden;\n            startInfo.FileName = \"cmd.exe\";\n            startInfo.Arguments = \"/c echo Hello World\";\n            startInfo.RedirectStandardOutput = true;\n            startInfo.UseShellExecute = false;\n            process.StartInfo = startInfo;\n            process.Start();\n\n            string output = process.StandardOutput.ReadToEnd();\n            Console.WriteLine(\"Output is {0}\", output);\n        }\n    }\n}\n"}
{"id": 158760, "name": "Get system command output", "source": "Translate Ruby to Java: str = `ls`   \narr = `ls`.lines\n", "target": "import java.io.*;\nimport java.util.*;\n\npublic class SystemCommand {\n\n    public static void main(String args[]) throws IOException {\n\n        String command = \"cmd /c dir\";\n        Process p = Runtime.getRuntime().exec(command);\n\n        try (Scanner sc = new Scanner(p.getInputStream())) {\n\n            System.out.printf(\"Output of the command: %s %n%n\", command);\n            while (sc.hasNext()) {\n                System.out.println(sc.nextLine());\n            }\n        }\n    }\n}\n"}
{"id": 158761, "name": "Get system command output", "source": "Translate Ruby to Python: str = `ls`   \narr = `ls`.lines\n", "target": ">>> import subprocess\n>>> returned_text = subprocess.check_output(\"dir\", shell=True, universal_newlines=True)\n>>> type(returned_text)\n<class 'str'>\n>>> print(returned_text)\n Volume in drive C is Windows\n Volume Serial Number is 44X7-73CE\n\n Directory of C:\\Python33\n\n04/07/2013  06:40    <DIR>          .\n04/07/2013  06:40    <DIR>          ..\n27/05/2013  07:10    <DIR>          DLLs\n27/05/2013  07:10    <DIR>          Doc\n27/05/2013  07:10    <DIR>          include\n27/05/2013  07:10    <DIR>          Lib\n27/05/2013  07:10    <DIR>          libs\n16/05/2013  00:15            33,326 LICENSE.txt\n15/05/2013  22:49           214,554 NEWS.txt\n16/05/2013  00:03            26,624 python.exe\n16/05/2013  00:03            27,136 pythonw.exe\n15/05/2013  22:49             6,701 README.txt\n27/05/2013  07:10    <DIR>          tcl\n27/05/2013  07:10    <DIR>          Tools\n16/05/2013  00:02            43,008 w9xpopen.exe\n               6 File(s)        351,349 bytes\n               9 Dir(s)  46,326,947,840 bytes free\n\n>>> \n"}
{"id": 158912, "name": "Integer overflow", "source": "Translate Ruby to C#: 2.1.1 :001 > a = 2**62 -1\n => 4611686018427387903 \n2.1.1 :002 > a.class\n => Fixnum \n2.1.1 :003 > (b = a + 1).class\n => Bignum \n2.1.1 :004 > (b-1).class\n => Fixnum\n", "target": "using System;\n    \npublic class IntegerOverflow\n{\n    public static void Main() {\n        unchecked {\n            Console.WriteLine(\"For 32-bit signed integers:\");\n            Console.WriteLine(-(-2147483647 - 1));\n            Console.WriteLine(2000000000 + 2000000000);\n            Console.WriteLine(-2147483647 - 2147483647);\n            Console.WriteLine(46341 * 46341);\n            Console.WriteLine((-2147483647 - 1) / -1);\n            Console.WriteLine();\n            \n            Console.WriteLine(\"For 64-bit signed integers:\");\n            Console.WriteLine(-(-9223372036854775807L - 1));\n            Console.WriteLine(5000000000000000000L + 5000000000000000000L);\n            Console.WriteLine(-9223372036854775807L - 9223372036854775807L);\n            Console.WriteLine(3037000500L * 3037000500L);\n            Console.WriteLine((-9223372036854775807L - 1) / -1);\n            Console.WriteLine();\n\n            Console.WriteLine(\"For 32-bit unsigned integers:\");\n            \n            Console.WriteLine(-4294967295U);\n            Console.WriteLine(3000000000U + 3000000000U);\n            Console.WriteLine(2147483647U - 4294967295U);\n            Console.WriteLine(65537U * 65537U);\n            Console.WriteLine();\n\n            Console.WriteLine(\"For 64-bit unsigned integers:\");\n            \n            \n            Console.WriteLine(10000000000000000000UL + 10000000000000000000UL);\n            Console.WriteLine(9223372036854775807UL - 18446744073709551615UL);\n            Console.WriteLine(4294967296UL * 4294967296UL);\n            Console.WriteLine();\n        }\n        \n        int i = 2147483647;\n        Console.WriteLine(i + 1);\n        try {\n            checked { Console.WriteLine(i + 1); }\n        } catch (OverflowException) {\n            Console.WriteLine(\"Overflow!\");\n        }\n    }\n    \n}\n"}
{"id": 158914, "name": "Integer overflow", "source": "Translate Ruby to Java: 2.1.1 :001 > a = 2**62 -1\n => 4611686018427387903 \n2.1.1 :002 > a.class\n => Fixnum \n2.1.1 :003 > (b = a + 1).class\n => Bignum \n2.1.1 :004 > (b-1).class\n => Fixnum\n", "target": "public class IntegerOverflow {\n    public static void main(String[] args) {\n        System.out.println(\"Signed 32-bit:\");\n        System.out.println(-(-2147483647 - 1));\n        System.out.println(2000000000 + 2000000000);\n        System.out.println(-2147483647 - 2147483647);\n        System.out.println(46341 * 46341);\n        System.out.println((-2147483647 - 1) / -1);\n        System.out.println(\"Signed 64-bit:\");\n        System.out.println(-(-9223372036854775807L - 1));\n        System.out.println(5000000000000000000L + 5000000000000000000L);\n        System.out.println(-9223372036854775807L - 9223372036854775807L);\n        System.out.println(3037000500L * 3037000500L);\n        System.out.println((-9223372036854775807L - 1) / -1);\n    }\n}\n"}
{"id": 158915, "name": "Integer overflow", "source": "Translate Ruby to Python: 2.1.1 :001 > a = 2**62 -1\n => 4611686018427387903 \n2.1.1 :002 > a.class\n => Fixnum \n2.1.1 :003 > (b = a + 1).class\n => Bignum \n2.1.1 :004 > (b-1).class\n => Fixnum\n", "target": "Python 2.7.5 (default, May 15 2013, 22:43:36) [MSC v.1500 32 bit (Intel)] on win32\nType \"copyright\", \"credits\" or \"license()\" for more information.\n>>> for calc in .split('\\n'):\n\tans = eval(calc)\n\tprint('Expression: %r evaluates to %s of type %s'\n\t      % (calc.strip(), ans, type(ans)))\n\n\t\nExpression: '-(-2147483647-1)' evaluates to 2147483648 of type <type 'long'>\nExpression: '2000000000 + 2000000000' evaluates to 4000000000 of type <type 'long'>\nExpression: '-2147483647 - 2147483647' evaluates to -4294967294 of type <type 'long'>\nExpression: '46341 * 46341' evaluates to 2147488281 of type <type 'long'>\nExpression: '(-2147483647-1) / -1' evaluates to 2147483648 of type <type 'long'>\n>>>\n"}
{"id": 159136, "name": "Semordnilap", "source": "Translate Ruby to C#: require \"set\"\n\nUNIXDICT = File.read(\"unixdict.txt\").lines\n\ndef word?(word : String)\n  UNIXDICT.includes?(word)\nend\n\n\nsemordnilap = UNIXDICT.select { |word| word?(word) && word?(word.reverse) }\n\n\nfinal_results = semordnilap.map { |word| [word, word.reverse].to_set }.uniq\n\n\n\nputs final_results.size, final_results.sample(5)\n", "target": "using System;\nusing System.Net;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.IO;\n\npublic class Semordnilap\n{\n    public static void Main() {\n        var results = FindSemordnilaps(\"http:\n        Console.WriteLine(results.Count);\n        var random = new Random();\n        Console.WriteLine(\"5 random results:\");\n        foreach (string s in results.OrderBy(_ => random.Next()).Distinct().Take(5)) Console.WriteLine(s + \" \" + Reversed(s));\n    }\n    \n    private static IEnumerable<string> FindSemordnilaps(string url) {\n        var found = new HashSet<string>();\n        foreach (string line in GetLines(url)) {\n            string reversed = Reversed(line);\n            \n            if (line.CompareTo(reversed) != 0) {\n                if (found.Remove(reversed)) yield return reversed;\n                else found.Add(line);\n            }\n        }\n    }\n    \n    private static IEnumerable<string> GetLines(string url) {\n        WebRequest request = WebRequest.Create(url);\n        using (var reader = new StreamReader(request.GetResponse().GetResponseStream(), true)) {\n            while (!reader.EndOfStream) {\n                yield return reader.ReadLine();\n            }\n        }\n    }\n    \n    private static string Reversed(string value) => new string(value.Reverse().ToArray());\n}\n"}
{"id": 159138, "name": "Semordnilap", "source": "Translate Ruby to Java: require \"set\"\n\nUNIXDICT = File.read(\"unixdict.txt\").lines\n\ndef word?(word : String)\n  UNIXDICT.includes?(word)\nend\n\n\nsemordnilap = UNIXDICT.select { |word| word?(word) && word?(word.reverse) }\n\n\nfinal_results = semordnilap.map { |word| [word, word.reverse].to_set }.uniq\n\n\n\nputs final_results.size, final_results.sample(5)\n", "target": "import java.nio.file.*;\nimport java.util.*;\n\npublic class Semordnilap {\n\n    public static void main(String[] args) throws Exception {\n        List<String> lst = Files.readAllLines(Paths.get(\"unixdict.txt\"));\n        Set<String> seen = new HashSet<>();\n        int count = 0;\n        for (String w : lst) {\n            w = w.toLowerCase();\n            String r = new StringBuilder(w).reverse().toString();\n            if (seen.contains(r)) {\n                if (count++ < 5)\n                    System.out.printf(\"%-10s\u00a0%-10s\\n\", w, r);\n            } else seen.add(w);\n        }\n        System.out.println(\"\\nSemordnilap pairs found: \" + count);\n    }\n}\n"}
{"id": 159139, "name": "Semordnilap", "source": "Translate Ruby to Python: require \"set\"\n\nUNIXDICT = File.read(\"unixdict.txt\").lines\n\ndef word?(word : String)\n  UNIXDICT.includes?(word)\nend\n\n\nsemordnilap = UNIXDICT.select { |word| word?(word) && word?(word.reverse) }\n\n\nfinal_results = semordnilap.map { |word| [word, word.reverse].to_set }.uniq\n\n\n\nputs final_results.size, final_results.sample(5)\n", "target": ">>> with open('unixdict.txt') as f:\n\twordset = set(f.read().strip().split())\n\n>>> revlist = (''.join(word[::-1]) for word in wordset)\n>>> pairs   = set((word, rev) for word, rev in zip(wordset, revlist) \n                  if word < rev and rev in wordset)\n>>> len(pairs)\n158\n>>> sorted(pairs, key=lambda p: (len(p[0]), p))[-5:]\n[('damon', 'nomad'), ('lager', 'regal'), ('leper', 'repel'), ('lever', 'revel'), ('kramer', 'remark')]\n>>>\n"}
{"id": 159445, "name": "Longest common substring", "source": "Translate Ruby to C#: def longest_common_substring(a,b)\n  lengths = Array.new(a.length){Array.new(b.length, 0)}\n  greatestLength = 0\n  output = \"\"\n  a.each_char.with_index do |x,i|\n    b.each_char.with_index do |y,j|\n      next if x != y\n      lengths[i][j] = (i.zero? || j.zero?) ? 1 : lengths[i-1][j-1] + 1\n      if lengths[i][j] > greatestLength\n        greatestLength = lengths[i][j]\n        output = a[i - greatestLength + 1, greatestLength]\n      end\n    end\n  end\n  output\nend\n\np longest_common_substring(\"thisisatest\", \"testing123testing\")\n", "target": "using System;\n\nnamespace LongestCommonSubstring\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            Console.WriteLine(lcs(\"thisisatest\", \"testing123testing\"));\n            Console.ReadKey(true);\n        }\n\n        public static string lcs(string a, string b)\n        {\n            var lengths = new int[a.Length, b.Length];\n            int greatestLength = 0;\n            string output = \"\";\n            for (int i = 0; i < a.Length; i++)\n            {\n                for (int j = 0; j < b.Length; j++)\n                {\n                    if (a[i] == b[j])\n                    {\n                        lengths[i, j] = i == 0 || j == 0 ? 1 : lengths[i - 1, j - 1] + 1;\n                        if (lengths[i, j] > greatestLength)\n                        {\n                            greatestLength = lengths[i, j];\n                            output = a.Substring(i - greatestLength + 1, greatestLength);\n                        }\n                    }\n                    else\n                    {\n                        lengths[i, j] = 0;\n                    }\n                }\n            }\n            return output;\n        }\n    }\n}\n"}
{"id": 159447, "name": "Longest common substring", "source": "Translate Ruby to Java: def longest_common_substring(a,b)\n  lengths = Array.new(a.length){Array.new(b.length, 0)}\n  greatestLength = 0\n  output = \"\"\n  a.each_char.with_index do |x,i|\n    b.each_char.with_index do |y,j|\n      next if x != y\n      lengths[i][j] = (i.zero? || j.zero?) ? 1 : lengths[i-1][j-1] + 1\n      if lengths[i][j] > greatestLength\n        greatestLength = lengths[i][j]\n        output = a[i - greatestLength + 1, greatestLength]\n      end\n    end\n  end\n  output\nend\n\np longest_common_substring(\"thisisatest\", \"testing123testing\")\n", "target": "public class LongestCommonSubstring {\n\n    public static void main(String[] args) {\n        System.out.println(lcs(\"testing123testing\", \"thisisatest\"));\n        System.out.println(lcs(\"test\", \"thisisatest\"));\n        System.out.println(lcs(\"testing\", \"sting\"));\n        System.out.println(lcs(\"testing\", \"thisisasting\"));\n    }\n\n    static String lcs(String a, String b) {\n        if (a.length() > b.length())\n            return lcs(b, a);\n\n        String res = \"\";\n        for (int ai = 0; ai < a.length(); ai++) {\n            for (int len = a.length() - ai; len > 0; len--) {\n\n                for (int bi = 0; bi <= b.length() - len; bi++) {\n\n                    if (a.regionMatches(ai, b, bi, len) && len > res.length()) {\n                        res = a.substring(ai, ai + len);\n                    }\n                }\n            }\n        }\n        return res;\n    }\n}\n"}
{"id": 159448, "name": "Longest common substring", "source": "Translate Ruby to Python: def longest_common_substring(a,b)\n  lengths = Array.new(a.length){Array.new(b.length, 0)}\n  greatestLength = 0\n  output = \"\"\n  a.each_char.with_index do |x,i|\n    b.each_char.with_index do |y,j|\n      next if x != y\n      lengths[i][j] = (i.zero? || j.zero?) ? 1 : lengths[i-1][j-1] + 1\n      if lengths[i][j] > greatestLength\n        greatestLength = lengths[i][j]\n        output = a[i - greatestLength + 1, greatestLength]\n      end\n    end\n  end\n  output\nend\n\np longest_common_substring(\"thisisatest\", \"testing123testing\")\n", "target": "s1 = \"thisisatest\"\ns2 = \"testing123testing\"\nlen1, len2 = len(s1), len(s2)\nir, jr = 0, -1\nfor i1 in range(len1):\n    i2 = s2.find(s1[i1])\n    while i2 >= 0:\n        j1, j2 = i1, i2\n        while j1 < len1 and j2 < len2 and s2[j2] == s1[j1]:\n            if j1-i1 >= jr-ir:\n                ir, jr = i1, j1\n            j1 += 1; j2 += 1\n        i2 = s2.find(s1[i1], i2+1)\nprint (s1[ir:jr+1])\n"}
{"id": 159625, "name": "Password generator", "source": "Translate Ruby to C#: ARRS = [(\"a\"..\"z\").to_a,\n        (\"A\"..\"Z\").to_a, \n        (\"0\"..\"9\").to_a,\n        %q(!\"\nALL  = ARRS.flatten\n\ndef generate_pwd(size, num)\n  raise ArgumentError, \"Desired size too small\" unless size >= ARRS.size\n  num.times.map do\n    arr = ARRS.map(&:sample)\n    (size - ARRS.size).times{ arr << ALL.sample}\n    arr.shuffle.join\n  end\nend\n\nputs generate_pwd(8,3)\n", "target": "using System;\nusing System.Linq;\n\nclass Program\n{\n    const string Lower = \"abcdefghijklmnopqrstuvwxyz\";\n    const string Upper = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n    const string Digits = \"0123456789\";\n    const string Symbols = \"!\\\"#$%&'()*+,-./:;<=>?@[]^_{|}~\";\n    static readonly string[] Full = {Lower, Upper, Digits, Symbols, Lower + Upper + Digits + Symbols};\n\n    const string Similar = \"Il1O05S2Z\";\n    static readonly string[] Excluded = Full.Select(x => new string(x.Except(Similar).ToArray())).ToArray();\n\n    static Random _rng = new Random();\n    static string[] _symbolSet = Full;\n\n    static void Main(string[] args)\n    {\n        int length = 12, count = 1;\n        try\n        {\n            foreach (var x in args.Select(arg => arg.Split(':')))\n            {\n                switch (x[0])\n                {\n                    case \"-l\": length = int.Parse(x[1]); break;\n                    case \"-c\": count = int.Parse(x[1]); break;\n                    case \"-s\": _rng = new Random(x[1].GetHashCode()); break;\n                    case \"-x\": _symbolSet = bool.Parse(x[1]) ? Excluded : Full; break;\n                    default: throw new FormatException(\"Could not parse arguments\");\n                }\n            }\n        }\n        catch { ShowUsage(); return; }\n        try\n        {\n            for (int i = 0; i < count; i++)\n                Console.WriteLine(GeneratePass(length));\n        }\n        catch (Exception ex) { Console.WriteLine(\"Error: \" + ex.Message); }\n    }\n\n    static void ShowUsage()\n    {\n        Console.WriteLine(\"Usage: PASSGEN [-l:length] [-c:count] [-s:seed] [-x:(true|false)]\");\n        Console.WriteLine(\"\\t-l: the length of the generated passwords\");\n        Console.WriteLine(\"\\t-c: the number of passwords to generate\");\n        Console.WriteLine(\"\\t-s: seed for the random number generator\");\n        Console.WriteLine(\"\\t-x: exclude similar characters: \" + Similar);\n        Console.WriteLine(\"Example: PASSGEN -l:10 -c:5 -s:\\\"Sample Seed\\\" -x:true\");\n    }\n\n    static string GeneratePass(int length)\n    {\n        var minLength = _symbolSet.Length - 1;\n        if(length < minLength)\n            throw new Exception(\"password length must be \" + minLength + \" or greater\");\n\n        int[] usesRemaining = Enumerable.Repeat(1, _symbolSet.Length).ToArray();\n        usesRemaining[minLength] = length - minLength;\n        var password = new char[length];\n        for (int ii = 0; ii < length; ii++)\n        {\n            int set = _rng.Next(0, _symbolSet.Length);\n            if (usesRemaining[set] > 0)\n            {\n                usesRemaining[set]--;\n                password[ii] = _symbolSet[set][_rng.Next(0, _symbolSet[set].Length)];\n            }\n            else ii--;\n        }\n        return new string(password);\n    }\n}\n"}
{"id": 159627, "name": "Password generator", "source": "Translate Ruby to Java: ARRS = [(\"a\"..\"z\").to_a,\n        (\"A\"..\"Z\").to_a, \n        (\"0\"..\"9\").to_a,\n        %q(!\"\nALL  = ARRS.flatten\n\ndef generate_pwd(size, num)\n  raise ArgumentError, \"Desired size too small\" unless size >= ARRS.size\n  num.times.map do\n    arr = ARRS.map(&:sample)\n    (size - ARRS.size).times{ arr << ALL.sample}\n    arr.shuffle.join\n  end\nend\n\nputs generate_pwd(8,3)\n", "target": "import java.util.*;\n\npublic class PasswordGenerator {\n    final static Random rand = new Random();\n\n    public static void main(String[] args) {\n        int num, len;\n\n        try {\n            if (args.length != 2)\n                throw new IllegalArgumentException();\n\n            len = Integer.parseInt(args[0]);\n            if (len < 4 || len > 16)\n                throw new IllegalArgumentException();\n\n            num = Integer.parseInt(args[1]);\n            if (num < 1 || num > 10)\n                throw new IllegalArgumentException();\n\n            for (String pw : generatePasswords(num, len))\n                System.out.println(pw);\n\n        } catch (IllegalArgumentException e) {\n            String s = \"Provide the length of the passwords (min 4, max 16) you \"\n                    + \"want to generate,\\nand how many (min 1, max 10)\";\n            System.out.println(s);\n        }\n    }\n\n    private static List<String> generatePasswords(int num, int len) {\n        final String s = \"!\\\"#$%&'()*+,-./:;<=>?@[]^_{|}~\";\n\n        List<String> result = new ArrayList<>();\n\n        for (int i = 0; i < num; i++) {\n            StringBuilder sb = new StringBuilder();\n            sb.append(s.charAt(rand.nextInt(s.length())));\n            sb.append((char) (rand.nextInt(10) + '0'));\n            sb.append((char) (rand.nextInt(26) + 'a'));\n            sb.append((char) (rand.nextInt(26) + 'A'));\n\n            for (int j = 4; j < len; j++) {\n                int r = rand.nextInt(93) + '!';\n                if (r == 92 || r == 96) {\n                    j--;\n                } else {\n                    sb.append((char) r);\n                }\n            }\n            result.add(shuffle(sb));\n        }\n        return result;\n    }\n\n    public static String shuffle(StringBuilder sb) {\n        int len = sb.length();\n        for (int i = len - 1; i > 0; i--) {\n            int r = rand.nextInt(i);\n            char tmp = sb.charAt(i);\n            sb.setCharAt(i, sb.charAt(r));\n            sb.setCharAt(r, tmp);\n        }\n        return sb.toString();\n    }\n}\n"}
{"id": 159628, "name": "Password generator", "source": "Translate Ruby to Python: ARRS = [(\"a\"..\"z\").to_a,\n        (\"A\"..\"Z\").to_a, \n        (\"0\"..\"9\").to_a,\n        %q(!\"\nALL  = ARRS.flatten\n\ndef generate_pwd(size, num)\n  raise ArgumentError, \"Desired size too small\" unless size >= ARRS.size\n  num.times.map do\n    arr = ARRS.map(&:sample)\n    (size - ARRS.size).times{ arr << ALL.sample}\n    arr.shuffle.join\n  end\nend\n\nputs generate_pwd(8,3)\n", "target": "import random\n\nlowercase = 'abcdefghijklmnopqrstuvwxyz' \nuppercase = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' \ndigits = '0123456789'                    \npunctuation = '!\"\n\nallowed = lowercase + uppercase + digits + punctuation\n\nvisually_similar = 'Il1O05S2Z'\n\n\ndef new_password(length:int, readable=True) -> str:\n    if length < 4:\n        print(\"password length={} is too short,\".format(length),\n            \"minimum length=4\")\n        return ''\n    choice = random.SystemRandom().choice\n    while True:\n        password_chars = [\n            choice(lowercase),\n            choice(uppercase),\n            choice(digits),\n            choice(punctuation)\n            ] + random.sample(allowed, length-4)\n        if (not readable or \n                all(c not in visually_similar for c in password_chars)):\n            random.SystemRandom().shuffle(password_chars)\n            return ''.join(password_chars)\n\n\ndef password_generator(length, qty=1, readable=True):\n    for i in range(qty):\n        print(new_password(length, readable))\n"}
{"id": 159841, "name": "Largest int from concatenated ints", "source": "Translate Ruby to C#: def icsort nums\n  nums.sort { |x, y| \"\nend\n\n[[54, 546, 548, 60], [1, 34, 3, 98, 9, 76, 45, 4]].each do |c|\n  p c \n  puts icsort(c).join\nend\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\nclass Program\n{\n    static void Main(string[] args)\n    {\n        var source1 = new int[] { 1, 34, 3, 98, 9, 76, 45, 4 };\n        var source2 = new int[] { 54, 546, 548, 60 };\n\n        var largest1 = LargestPossibleSequence(source1);\n        var largest2 = LargestPossibleSequence(source2);\n\n        Console.WriteLine(\"The largest possible integer from set 1 is: {0}\", largest1);\n        Console.WriteLine(\"The largest possible integer from set 2 is: {0}\", largest2);\n    }\n\n    static long LargestPossibleSequence(int[] ints)\n    {\n        return long.Parse(string.Join(\"\", ints.OrderBy(i => i, new IntConcatenationComparer()).Reverse()));\n    }\n}\n\nclass IntConcatenationComparer : IComparer<int>\n{\n    public int Compare(int x, int y)\n    {\n        var xy = int.Parse(x.ToString() + y.ToString());\n        var yx = int.Parse(y.ToString() + x.ToString());\n\n        return xy - yx;\n    }\n}\n"}
{"id": 159843, "name": "Largest int from concatenated ints", "source": "Translate Ruby to Java: def icsort nums\n  nums.sort { |x, y| \"\nend\n\n[[54, 546, 548, 60], [1, 34, 3, 98, 9, 76, 45, 4]].each do |c|\n  p c \n  puts icsort(c).join\nend\n", "target": "import java.util.*;\n\npublic class IntConcat {\n \n    private static Comparator<Integer> sorter = new Comparator<Integer>(){\n        @Override\n        public int compare(Integer o1, Integer o2){\n            String o1s = o1.toString();\n            String o2s = o2.toString();\n            \n            if(o1s.length() == o2s.length()){\n                return o2s.compareTo(o1s);\n            }\n\n            int mlen = Math.max(o1s.length(), o2s.length());\n            while(o1s.length() < mlen * 2) o1s += o1s;\n            while(o2s.length() < mlen * 2) o2s += o2s;\n            \n            return o2s.compareTo(o1s);\n        }\n    };\n    \n    public static String join(List<?> things){\n        String output = \"\";\n        for(Object obj:things){\n            output += obj;\n        }\n        return output;\n    }\n    \n    public static void main(String[] args){\n        List<Integer> ints1 = new ArrayList<Integer>(Arrays.asList(1, 34, 3, 98, 9, 76, 45, 4));\n        \n        Collections.sort(ints1, sorter);\n        System.out.println(join(ints1));\n        \n        List<Integer> ints2 = new ArrayList<Integer>(Arrays.asList(54, 546, 548, 60));\n        \n        Collections.sort(ints2, sorter);\n        System.out.println(join(ints2));\n    }\n}\n"}
{"id": 159844, "name": "Largest int from concatenated ints", "source": "Translate Ruby to Python: def icsort nums\n  nums.sort { |x, y| \"\nend\n\n[[54, 546, 548, 60], [1, 34, 3, 98, 9, 76, 45, 4]].each do |c|\n  p c \n  puts icsort(c).join\nend\n", "target": "try:\n    cmp     \n    def maxnum(x):\n        return ''.join(sorted((str(n) for n in x),\n                              cmp=lambda x,y:cmp(y+x, x+y)))\nexcept NameError:\n    \n    from functools import cmp_to_key\n    def cmp(x, y):\n        return -1 if x<y else ( 0 if x==y else 1)\n    def maxnum(x):\n        return ''.join(sorted((str(n) for n in x),\n                              key=cmp_to_key(lambda x,y:cmp(y+x, x+y))))\n\nfor numbers in [(1, 34, 3, 98, 9, 76, 45, 4), (54, 546, 548, 60)]:\n    print('Numbers: %r\\n  Largest integer: %15s' % (numbers, maxnum(numbers)))\n"}
{"id": 160044, "name": "Maximum triangle path sum", "source": "Translate Ruby to C#: triangle = \n\"                         55\n                        94 48\n                       95 30 96\n                     77 71 26 67\n                    97 13 76 38 45\n                  07 36 79 16 37 68\n                 48 07 09 18 70 26 06\n               18 72 79 46 59 79 29 90\n              20 76 87 11 32 07 07 49 18\n            27 83 58 35 71 11 25 57 29 85\n           14 64 36 96 27 11 58 56 92 18 55\n         02 90 03 60 48 49 41 46 33 36 47 23\n        92 50 48 02 36 59 42 79 72 20 82 77 42\n      56 78 38 80 39 75 02 71 66 66 01 03 55 72\n     44 25 67 84 71 67 11 61 40 57 58 89 40 56 36\n   85 32 25 85 57 48 84 35 47 62 17 01 01 99 89 52\n  06 71 28 75 94 48 37 10 23 51 06 48 53 18 74 98 15\n27 02 92 23 08 71 76 84 15 52 92 63 81 10 44 10 69 93\"\n\nar = triangle.each_line.map{|line| line.split.map(&:to_i)}\nputs ar.inject([]){|res,x|\n  maxes = [0, *res, 0].each_cons(2).map(&:max)\n  x.zip(maxes).map{|a,b| a+b}\n}.max\n\n", "target": "using System;\n\nnamespace RosetaCode\n{\n\tclass MainClass\n\t{\n\t\tpublic static void Main (string[] args)\n\t\t{\n\t\t\tint[,] list = new int[18,19];\n\t\t\tstring input = @\"55\n\t                        94 48\n\t                       95 30 96\n\t                     77 71 26 67\n\t                    97 13 76 38 45\n\t                  07 36 79 16 37 68\n\t                 48 07 09 18 70 26 06\n\t               18 72 79 46 59 79 29 90\n\t              20 76 87 11 32 07 07 49 18\n\t            27 83 58 35 71 11 25 57 29 85\n\t           14 64 36 96 27 11 58 56 92 18 55\n\t         02 90 03 60 48 49 41 46 33 36 47 23\n\t        92 50 48 02 36 59 42 79 72 20 82 77 42\n\t      56 78 38 80 39 75 02 71 66 66 01 03 55 72\n\t     44 25 67 84 71 67 11 61 40 57 58 89 40 56 36\n\t   85 32 25 85 57 48 84 35 47 62 17 01 01 99 89 52\n\t  06 71 28 75 94 48 37 10 23 51 06 48 53 18 74 98 15\n\t27 02 92 23 08 71 76 84 15 52 92 63 81 10 44 10 69 93\";\n\t\t\tvar charArray = input.Split ('\\n');\n\n\t\t\tfor (int i=0; i < charArray.Length; i++) {\n\t\t\t\tvar numArr = charArray[i].Trim().Split(' ');\n\n\t\t\t\tfor (int j = 0; j<numArr.Length; j++)\n\t\t\t\t{\n\t\t\t\t\tint number = Convert.ToInt32 (numArr[j]);\n\t\t\t\t\tlist [i, j] = number;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor (int i = 16; i >= 0; i--) {\n\t\t\t\tfor (int j = 0; j < 18; j++) {\n\t\t\t\t\tlist[i,j] = Math.Max(list[i, j] + list[i+1, j], list[i,j] + list[i+1, j+1]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tConsole.WriteLine (string.Format(\"Maximum total: {0}\", list [0, 0]));\n\t\t}\n\t}\n}\n"}
{"id": 160046, "name": "Maximum triangle path sum", "source": "Translate Ruby to Java: triangle = \n\"                         55\n                        94 48\n                       95 30 96\n                     77 71 26 67\n                    97 13 76 38 45\n                  07 36 79 16 37 68\n                 48 07 09 18 70 26 06\n               18 72 79 46 59 79 29 90\n              20 76 87 11 32 07 07 49 18\n            27 83 58 35 71 11 25 57 29 85\n           14 64 36 96 27 11 58 56 92 18 55\n         02 90 03 60 48 49 41 46 33 36 47 23\n        92 50 48 02 36 59 42 79 72 20 82 77 42\n      56 78 38 80 39 75 02 71 66 66 01 03 55 72\n     44 25 67 84 71 67 11 61 40 57 58 89 40 56 36\n   85 32 25 85 57 48 84 35 47 62 17 01 01 99 89 52\n  06 71 28 75 94 48 37 10 23 51 06 48 53 18 74 98 15\n27 02 92 23 08 71 76 84 15 52 92 63 81 10 44 10 69 93\"\n\nar = triangle.each_line.map{|line| line.split.map(&:to_i)}\nputs ar.inject([]){|res,x|\n  maxes = [0, *res, 0].each_cons(2).map(&:max)\n  x.zip(maxes).map{|a,b| a+b}\n}.max\n\n", "target": "import java.nio.file.*;\nimport static java.util.Arrays.stream;\n\npublic class MaxPathSum {\n\n    public static void main(String[] args) throws Exception {\n        int[][] data = Files.lines(Paths.get(\"triangle.txt\"))\n                .map(s -> stream(s.trim().split(\"\\\\s+\"))\n                        .mapToInt(Integer::parseInt)\n                        .toArray())\n                .toArray(int[][]::new);\n\n        for (int r = data.length - 1; r > 0; r--)\n            for (int c = 0; c < data[r].length - 1; c++)\n                data[r - 1][c] += Math.max(data[r][c], data[r][c + 1]);\n\n        System.out.println(data[0][0]);\n    }\n}\n"}
{"id": 160047, "name": "Maximum triangle path sum", "source": "Translate Ruby to Python: triangle = \n\"                         55\n                        94 48\n                       95 30 96\n                     77 71 26 67\n                    97 13 76 38 45\n                  07 36 79 16 37 68\n                 48 07 09 18 70 26 06\n               18 72 79 46 59 79 29 90\n              20 76 87 11 32 07 07 49 18\n            27 83 58 35 71 11 25 57 29 85\n           14 64 36 96 27 11 58 56 92 18 55\n         02 90 03 60 48 49 41 46 33 36 47 23\n        92 50 48 02 36 59 42 79 72 20 82 77 42\n      56 78 38 80 39 75 02 71 66 66 01 03 55 72\n     44 25 67 84 71 67 11 61 40 57 58 89 40 56 36\n   85 32 25 85 57 48 84 35 47 62 17 01 01 99 89 52\n  06 71 28 75 94 48 37 10 23 51 06 48 53 18 74 98 15\n27 02 92 23 08 71 76 84 15 52 92 63 81 10 44 10 69 93\"\n\nar = triangle.each_line.map{|line| line.split.map(&:to_i)}\nputs ar.inject([]){|res,x|\n  maxes = [0, *res, 0].each_cons(2).map(&:max)\n  x.zip(maxes).map{|a,b| a+b}\n}.max\n\n", "target": "fun maxpathsum(t): \n    let a = val t\n    for i in a.length-1..-1..1, c in linearindices a[r]:\n        a[r, c] += max(a[r+1, c], a[r=1, c+1])\n    return a[1, 1]\n\nlet test = [\n    [55],\n    [94, 48],\n    [95, 30, 96],\n    [77, 71, 26, 67],\n    [97, 13, 76, 38, 45],\n    [07, 36, 79, 16, 37, 68],\n    [48, 07, 09, 18, 70, 26, 06],\n    [18, 72, 79, 46, 59, 79, 29, 90],\n    [20, 76, 87, 11, 32, 07, 07, 49, 18],\n    [27, 83, 58, 35, 71, 11, 25, 57, 29, 85],\n    [14, 64, 36, 96, 27, 11, 58, 56, 92, 18, 55],\n    [02, 90, 03, 60, 48, 49, 41, 46, 33, 36, 47, 23],\n    [92, 50, 48, 02, 36, 59, 42, 79, 72, 20, 82, 77, 42],\n    [56, 78, 38, 80, 39, 75, 02, 71, 66, 66, 01, 03, 55, 72],\n    [44, 25, 67, 84, 71, 67, 11, 61, 40, 57, 58, 89, 40, 56, 36],\n    [85, 32, 25, 85, 57, 48, 84, 35, 47, 62, 17, 01, 01, 99, 89, 52],\n    [06, 71, 28, 75, 94, 48, 37, 10, 23, 51, 06, 48, 53, 18, 74, 98, 15],\n    [27, 02, 92, 23, 08, 71, 76, 84, 15, 52, 92, 63, 81, 10, 44, 10, 69, 93]\n]\n\n@print maxpathsum test\n"}
{"id": 160215, "name": "Unix_ls", "source": "Translate Ruby to C#: Dir.foreach(\"./\"){|n| puts n}\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.IO;\nusing System.Linq;\nusing System.Threading.Tasks;\n\nnamespace Unix_ls\n{\n    public class UnixLS\n    {\n        public static void Main(string[] args)\n        {\n            UnixLS ls = new UnixLS();\n            ls.list(args.Length.Equals(0) ? \".\" : args[0]);\n        }\n\n        private void list(string folder)\n        {\n            foreach (FileSystemInfo fileSystemInfo in new DirectoryInfo(folder).EnumerateFileSystemInfos(\"*\", SearchOption.TopDirectoryOnly))\n            {\n                Console.WriteLine(fileSystemInfo.Name);\n            }\n        }\n    }\n}\n"}
{"id": 160217, "name": "Unix_ls", "source": "Translate Ruby to Java: Dir.foreach(\"./\"){|n| puts n}\n", "target": "package rosetta;\n\nimport java.io.IOException;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\n\npublic class UnixLS {\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tFiles.list(Path.of(\"\")).sorted().forEach(System.out::println);\n\t}\n}\n"}
{"id": 160218, "name": "Unix_ls", "source": "Translate Ruby to Python: Dir.foreach(\"./\"){|n| puts n}\n", "target": ">>> import os\n>>> print('\\n'.join(sorted(os.listdir('.'))))\nDLLs\nDoc\nLICENSE.txt\nLib\nNEWS.txt\nREADME.txt\nScripts\nTools\ninclude\nlibs\npython.exe\npythonw.exe\ntcl\n>>>\n"}
{"id": 160334, "name": "Law of cosines - triples", "source": "Translate Ruby to C#: grouped =  (1..13).to_a.repeated_permutation(3).group_by do |a,b,c|\n  sumaabb, ab = a*a + b*b, a*b\n  case c*c\n    when sumaabb      then 90\n    when sumaabb - ab then 60\n    when sumaabb + ab then 120\n  end\nend\n\ngrouped.delete(nil)\nres = grouped.transform_values{|v| v.map(&:sort).uniq }\n\nres.each do |k,v|\n  puts \"For an angle of \n  puts v.inspect, \"\\n\"\nend\n", "target": "using System;\nusing System.Collections.Generic;\nusing static System.Linq.Enumerable;\n\npublic static class LawOfCosinesTriples\n{\n    public static void Main2() {\n        PrintTriples(60, 13);\n        PrintTriples(90, 13);\n        PrintTriples(120, 13);\n        PrintTriples(60, 10_000, true, false);\n    }\n\n    private static void PrintTriples(int degrees, int maxSideLength, bool notAllTheSameLength = false, bool print = true) {\n        string s = $\"{degrees} degree triangles in range 1..{maxSideLength}\";\n        if (notAllTheSameLength) s += \" where not all sides are the same\";\n        Console.WriteLine(s);\n        int count = 0;\n        var triples = FindTriples(degrees, maxSideLength);\n        if (notAllTheSameLength) triples = triples.Where(NotAllTheSameLength);\n        foreach (var triple in triples) {\n            count++;\n            if (print) Console.WriteLine(triple);\n        }\n        Console.WriteLine($\"{count} solutions\");\n    }\n\n    private static IEnumerable<(int a, int b, int c)> FindTriples(int degrees, int maxSideLength) {\n        double radians = degrees * Math.PI / 180;\n        int coefficient = (int)Math.Round(Math.Cos(radians) * -2, MidpointRounding.AwayFromZero);\n        int maxSideLengthSquared = maxSideLength * maxSideLength;\n        return\n            from a in Range(1, maxSideLength)\n            from b in Range(1, a)\n            let cc = a * a + b * b + a * b * coefficient\n            where cc <= maxSideLengthSquared\n            let c = (int)Math.Sqrt(cc)\n            where c * c == cc\n            select (a, b, c);\n    }\n\n    private static bool NotAllTheSameLength((int a, int b, int c) triple) => triple.a != triple.b || triple.a != triple.c;\n}\n"}
{"id": 160336, "name": "Law of cosines - triples", "source": "Translate Ruby to Java: grouped =  (1..13).to_a.repeated_permutation(3).group_by do |a,b,c|\n  sumaabb, ab = a*a + b*b, a*b\n  case c*c\n    when sumaabb      then 90\n    when sumaabb - ab then 60\n    when sumaabb + ab then 120\n  end\nend\n\ngrouped.delete(nil)\nres = grouped.transform_values{|v| v.map(&:sort).uniq }\n\nres.each do |k,v|\n  puts \"For an angle of \n  puts v.inspect, \"\\n\"\nend\n", "target": "public class LawOfCosines {\n\n    public static void main(String[] args) {\n        generateTriples(13);\n        generateTriples60(10000);\n    }\n    \n    private static void generateTriples(int max) {\n        for ( int coeff : new int[] {0, -1, 1} ) {\n            int count = 0;\n            System.out.printf(\"Max side length %d, formula:  a*a + b*b %s= c*c%n\", max, coeff == 0 ? \"\" : (coeff<0 ? \"-\"  : \"+\") + \" a*b \");\n            for ( int a = 1 ; a <= max ; a++ ) {\n                for ( int b = 1 ; b <= a ; b++ ) {\n                    int val = a*a + b*b + coeff*a*b;\n                    int c = (int) (Math.sqrt(val) + .5d);\n                    if ( c > max ) {\n                        break;\n                    }\n                    if ( c*c == val ) {\n                        System.out.printf(\"  (%d, %d, %d)%n\", a, b ,c);\n                        count++;\n                    }\n                }\n            }\n            System.out.printf(\"%d triangles%n\", count);\n        }        \n    }\n\n    private static void generateTriples60(int max) {\n        int count = 0;\n        System.out.printf(\"%nExtra Credit.%nMax side length %d, sides different length, formula:  a*a + b*b - a*b = c*c%n\", max);\n        for ( int a = 1 ; a <= max ; a++ ) {\n            for ( int b = 1 ; b < a ; b++ ) {\n                int val = a*a + b*b - a*b;\n                int c = (int) (Math.sqrt(val) + .5d);\n                if ( c*c == val ) {\n                    count++;\n                }\n            }\n        }\n        System.out.printf(\"%d triangles%n\", count);\n    }\n\n}\n"}
{"id": 160337, "name": "Law of cosines - triples", "source": "Translate Ruby to Python: grouped =  (1..13).to_a.repeated_permutation(3).group_by do |a,b,c|\n  sumaabb, ab = a*a + b*b, a*b\n  case c*c\n    when sumaabb      then 90\n    when sumaabb - ab then 60\n    when sumaabb + ab then 120\n  end\nend\n\ngrouped.delete(nil)\nres = grouped.transform_values{|v| v.map(&:sort).uniq }\n\nres.each do |k,v|\n  puts \"For an angle of \n  puts v.inspect, \"\\n\"\nend\n", "target": "N = 13\n\ndef method1(N=N):\n    squares = [x**2 for x in range(0, N+1)]\n    sqrset = set(squares)\n    tri90, tri60, tri120 = (set() for _ in range(3))\n    for a in range(1, N+1):\n        a2 = squares[a]\n        for b in range(1, a + 1):\n            b2 = squares[b]\n            c2 = a2 + b2\n            if c2 in sqrset:\n                tri90.add(tuple(sorted((a, b, int(c2**0.5)))))\n            ab = a * b\n            c2 -= ab\n            if c2 in sqrset:\n                tri60.add(tuple(sorted((a, b, int(c2**0.5)))))\n            c2 += 2 * ab\n            if c2 in sqrset:\n                tri120.add(tuple(sorted((a, b, int(c2**0.5)))))\n    return  sorted(tri90), sorted(tri60), sorted(tri120)\n\nif __name__ == '__main__':\n    print(f'Integer triangular triples for sides 1..{N}:')\n    for angle, triples in zip([90, 60, 120], method1(N)):\n        print(f'  {angle:3}\u00b0 has {len(triples)} solutions:\\n    {triples}')\n    _, t60, _ = method1(10_000)\n    notsame = sum(1 for a, b, c in t60 if a != b or b != c)\n    print('Extra credit:', notsame)\n"}
{"id": 160533, "name": "Top rank per group", "source": "Translate Ruby to C#: require \"csv\"\n\ndata = <<EOS\nEmployee Name,Employee ID,Salary,Department\nTyler Bennett,E10297,32000,D101\nJohn Rappl,E21437,47000,D050\nGeorge Woltman,E00127,53500,D101\nAdam Smith,E63535,18000,D202\nClaire Buckman,E39876,27800,D202\nDavid McClellan,E04242,41500,D101\nRich Holcomb,E01234,49500,D202\nNathan Adams,E41298,21900,D050\nRichard Potter,E43128,15900,D101\nDavid Motsinger,E27002,19250,D202\nTim Sampair,E03033,27000,D101\nKim Arlich,E10001,57000,D190\nTimothy Grove,E16398,29900,D190\nEOS\n\ndef show_top_salaries_per_group(data, n)\n  table = CSV.parse(data, :headers=>true, :header_converters=>:symbol)\n  groups = table.group_by{|emp| emp[:department]}.sort\n  groups.each do |dept, emps|\n    puts dept\n    \n    emps.max_by(n) {|emp| emp[:salary].to_i}.each do |e|\n      puts \"   \u00a0%-16s %6s %7d\" % [e[:employee_name], e[:employee_id], e[:salary]]\n    end\n    puts\n  end\nend\n\nshow_top_salaries_per_group(data, 3)\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\npublic class Program\n{\n    class Employee\n    {\n        public Employee(string name, string id, int salary, string department)\n        {\n            Name = name;\n            Id = id;\n            Salary = salary;\n            Department = department;\n        }\n\n        public string Name { get; private set; }\n        public string Id { get; private set; }\n        public int Salary { get; private set; }\n        public string Department { get; private set; }\n\n        public override string ToString()\n        {\n            return String.Format(\"{0, -25}\\t{1}\\t{2}\", Name, Id, Salary);\n        }\n    }\n\n    private static void Main(string[] args)\n    {\n        var employees = new List<Employee>\n                        {\n                            new Employee(\"Tyler Bennett\", \"E10297\", 32000, \"D101\"),\n                            new Employee(\"John Rappl\", \"E21437\", 47000, \"D050\"),\n                            new Employee(\"George Woltman\", \"E21437\", 53500, \"D101\"),\n                            new Employee(\"Adam Smith\", \"E21437\", 18000, \"D202\"),\n                            new Employee(\"Claire Buckman\", \"E39876\", 27800, \"D202\"),\n                            new Employee(\"David McClellan\", \"E04242\", 41500, \"D101\"),\n                            new Employee(\"Rich Holcomb\", \"E01234\", 49500, \"D202\"),\n                            new Employee(\"Nathan Adams\", \"E41298\", 21900, \"D050\"),\n                            new Employee(\"Richard Potter\", \"E43128\", 15900, \"D101\"),\n                            new Employee(\"David Motsinger\", \"E27002\", 19250, \"D202\"),\n                            new Employee(\"Tim Sampair\", \"E03033\", 27000, \"D101\"),\n                            new Employee(\"Kim Arlich\", \"E10001\", 57000, \"D190\"),\n                            new Employee(\"Timothy Grove\", \"E16398\", 29900, \"D190\")\n                        };\n\n        DisplayTopNPerDepartment(employees, 2);\n    }\n\n    static void DisplayTopNPerDepartment(IEnumerable<Employee> employees, int n)\n    {\n        var topSalariesByDepartment =\n            from employee in employees\n            group employee by employee.Department\n            into g\n            select new\n                    {\n                        Department = g.Key,\n                        TopEmployeesBySalary = g.OrderByDescending(e => e.Salary).Take(n)\n                    };\n\n        foreach (var x in topSalariesByDepartment)\n        {\n            Console.WriteLine(\"Department: \" + x.Department);\n            foreach (var employee in x.TopEmployeesBySalary)\n                Console.WriteLine(employee);\n            Console.WriteLine(\"----------------------------\");\n        }\n    }\n}\n"}
{"id": 160535, "name": "Top rank per group", "source": "Translate Ruby to Java: require \"csv\"\n\ndata = <<EOS\nEmployee Name,Employee ID,Salary,Department\nTyler Bennett,E10297,32000,D101\nJohn Rappl,E21437,47000,D050\nGeorge Woltman,E00127,53500,D101\nAdam Smith,E63535,18000,D202\nClaire Buckman,E39876,27800,D202\nDavid McClellan,E04242,41500,D101\nRich Holcomb,E01234,49500,D202\nNathan Adams,E41298,21900,D050\nRichard Potter,E43128,15900,D101\nDavid Motsinger,E27002,19250,D202\nTim Sampair,E03033,27000,D101\nKim Arlich,E10001,57000,D190\nTimothy Grove,E16398,29900,D190\nEOS\n\ndef show_top_salaries_per_group(data, n)\n  table = CSV.parse(data, :headers=>true, :header_converters=>:symbol)\n  groups = table.group_by{|emp| emp[:department]}.sort\n  groups.each do |dept, emps|\n    puts dept\n    \n    emps.max_by(n) {|emp| emp[:salary].to_i}.each do |e|\n      puts \"   \u00a0%-16s %6s %7d\" % [e[:employee_name], e[:employee_id], e[:salary]]\n    end\n    puts\n  end\nend\n\nshow_top_salaries_per_group(data, 3)\n", "target": "import java.io.File;\nimport java.util.*;\n\npublic class TopRankPerGroup {\n\n    private static class Employee {\n        final String name;\n        final String id;\n        final String department;\n        final int salary;\n\n        Employee(String[] rec) {\n            name = rec[0];\n            id = rec[1];\n            salary = Integer.parseInt(rec[2]);\n            department = rec[3];\n        }\n\n        @Override\n        public String toString() {\n            return String.format(\"%s %s %d %s\", id, name, salary, department);\n        }\n    }\n\n    public static void main(String[] args) throws Exception {\n        int N = args.length > 0 ? Integer.parseInt(args[0]) : 3;\n\n        Map<String, List<Employee>> records = new TreeMap<>();\n        try (Scanner sc = new Scanner(new File(\"data.txt\"))) {\n            while (sc.hasNextLine()) {\n                String[] rec = sc.nextLine().trim().split(\", \");\n\n                List<Employee> lst = records.get(rec[3]);\n                if (lst == null) {\n                    lst = new ArrayList<>();\n                    records.put(rec[3], lst);\n                }\n                lst.add(new Employee(rec));\n            }\n        }\n\n        records.forEach((key, val) -> {\n            System.out.printf(\"%nDepartment %s%n\", key);\n            val.stream()\n                .sorted((a, b) -> Integer.compare(b.salary, a.salary))\n                .limit(N).forEach(System.out::println);\n        });\n    }\n}\n"}
{"id": 160536, "name": "Top rank per group", "source": "Translate Ruby to Python: require \"csv\"\n\ndata = <<EOS\nEmployee Name,Employee ID,Salary,Department\nTyler Bennett,E10297,32000,D101\nJohn Rappl,E21437,47000,D050\nGeorge Woltman,E00127,53500,D101\nAdam Smith,E63535,18000,D202\nClaire Buckman,E39876,27800,D202\nDavid McClellan,E04242,41500,D101\nRich Holcomb,E01234,49500,D202\nNathan Adams,E41298,21900,D050\nRichard Potter,E43128,15900,D101\nDavid Motsinger,E27002,19250,D202\nTim Sampair,E03033,27000,D101\nKim Arlich,E10001,57000,D190\nTimothy Grove,E16398,29900,D190\nEOS\n\ndef show_top_salaries_per_group(data, n)\n  table = CSV.parse(data, :headers=>true, :header_converters=>:symbol)\n  groups = table.group_by{|emp| emp[:department]}.sort\n  groups.each do |dept, emps|\n    puts dept\n    \n    emps.max_by(n) {|emp| emp[:salary].to_i}.each do |e|\n      puts \"   \u00a0%-16s %6s %7d\" % [e[:employee_name], e[:employee_id], e[:salary]]\n    end\n    puts\n  end\nend\n\nshow_top_salaries_per_group(data, 3)\n", "target": "from collections import defaultdict\nfrom heapq import nlargest\n \ndata = [('Employee Name', 'Employee ID', 'Salary', 'Department'),\n        ('Tyler Bennett', 'E10297', 32000, 'D101'),\n        ('John Rappl', 'E21437', 47000, 'D050'),\n        ('George Woltman', 'E00127', 53500, 'D101'),\n        ('Adam Smith', 'E63535', 18000, 'D202'),\n        ('Claire Buckman', 'E39876', 27800, 'D202'),\n        ('David McClellan', 'E04242', 41500, 'D101'),\n        ('Rich Holcomb', 'E01234', 49500, 'D202'),\n        ('Nathan Adams', 'E41298', 21900, 'D050'),\n        ('Richard Potter', 'E43128', 15900, 'D101'),\n        ('David Motsinger', 'E27002', 19250, 'D202'),\n        ('Tim Sampair', 'E03033', 27000, 'D101'),\n        ('Kim Arlich', 'E10001', 57000, 'D190'),\n        ('Timothy Grove', 'E16398', 29900, 'D190')]\n \ndepartments = defaultdict(list)\nfor rec in data[1:]:\n    departments[rec[-1]].append(rec)\n \nN = 3\nformat = \" %-15s \" * len(data[0])\nfor department, recs in sorted(departments.items()):\n    print (\"Department %s\" % department)\n    print (format % data[0])\n    for rec in nlargest(N, recs, key=lambda rec: rec[-2]):\n        print (format % rec)\n    print('')\n"}
{"id": 160738, "name": "Subleq", "source": "Translate Ruby to C#: class Computer\n  def initialize program\n    @memory = program.map &:to_i\n    @instruction_pointer = 0\n  end\n\n  def step\n    return nil if @instruction_pointer < 0\n\n    a, b, c = @memory[@instruction_pointer .. @instruction_pointer + 2]\n    @instruction_pointer += 3\n\n    if a == -1\n      b = readchar\n    elsif b == -1\n      writechar @memory[a]\n    else\n      difference = @memory[b] -= @memory[a]\n      @instruction_pointer = c if difference <= 0\n    end\n\n    @instruction_pointer\n  end\n\n  def run\n    current_pointer = @instruction_pointer\n    current_pointer = step while current_pointer >= 0\n  end\n\n  private\n\n  def readchar\n    gets[0].ord\n  end\n\n  def writechar code_point\n    print code_point.chr\n  end\nend\n\nsubleq = Computer.new ARGV\n\nsubleq.run\n", "target": "using System;\n\nnamespace Subleq {\n    class Program {\n        static void Main(string[] args) {\n            int[] mem = {\n                15, 17, -1, 17, -1, -1, 16, 1, -1, 16,\n                3, -1, 15, 15, 0, 0, -1, 72, 101, 108,\n                108, 111, 44, 32, 119, 111, 114, 108, 100, 33,\n                10, 0,\n            };\n\n            int instructionPointer = 0;\n\n            do {\n                int a = mem[instructionPointer];\n                int b = mem[instructionPointer + 1];\n\n                if (a == -1) {\n                    mem[b] = Console.Read();\n                }\n                else if (b == -1) {\n                    Console.Write((char)mem[a]);\n                }\n                else {\n                    mem[b] -= mem[a];\n                    if (mem[b] < 1) {\n                        instructionPointer = mem[instructionPointer + 2];\n                        continue;\n                    }\n                }\n\n                instructionPointer += 3;\n            } while (instructionPointer >= 0);\n        }\n    }\n}\n"}
{"id": 160740, "name": "Subleq", "source": "Translate Ruby to Java: class Computer\n  def initialize program\n    @memory = program.map &:to_i\n    @instruction_pointer = 0\n  end\n\n  def step\n    return nil if @instruction_pointer < 0\n\n    a, b, c = @memory[@instruction_pointer .. @instruction_pointer + 2]\n    @instruction_pointer += 3\n\n    if a == -1\n      b = readchar\n    elsif b == -1\n      writechar @memory[a]\n    else\n      difference = @memory[b] -= @memory[a]\n      @instruction_pointer = c if difference <= 0\n    end\n\n    @instruction_pointer\n  end\n\n  def run\n    current_pointer = @instruction_pointer\n    current_pointer = step while current_pointer >= 0\n  end\n\n  private\n\n  def readchar\n    gets[0].ord\n  end\n\n  def writechar code_point\n    print code_point.chr\n  end\nend\n\nsubleq = Computer.new ARGV\n\nsubleq.run\n", "target": "import java.util.Scanner;\n\npublic class Subleq {\n\n    public static void main(String[] args) {\n        int[] mem = {15, 17, -1, 17, -1, -1, 16, 1, -1, 16, 3, -1, 15, 15, 0, 0,\n            -1, 72, 101, 108, 108, 111, 44, 32, 119, 111, 114, 108, 100, 33, 10, 0};\n\n        Scanner input = new Scanner(System.in);\n        int instructionPointer = 0;\n\n        do {\n            int a = mem[instructionPointer];\n            int b = mem[instructionPointer + 1];\n\n            if (a == -1) {\n                mem[b] = input.nextInt();\n\n            } else if (b == -1) {\n                System.out.printf(\"%c\", (char) mem[a]);\n\n            } else {\n\n                mem[b] -= mem[a];\n                if (mem[b] < 1) {\n                    instructionPointer = mem[instructionPointer + 2];\n                    continue;\n                }\n            }\n\n            instructionPointer += 3;\n\n        } while (instructionPointer >= 0);\n    }\n}\n"}
{"id": 160741, "name": "Subleq", "source": "Translate Ruby to Python: class Computer\n  def initialize program\n    @memory = program.map &:to_i\n    @instruction_pointer = 0\n  end\n\n  def step\n    return nil if @instruction_pointer < 0\n\n    a, b, c = @memory[@instruction_pointer .. @instruction_pointer + 2]\n    @instruction_pointer += 3\n\n    if a == -1\n      b = readchar\n    elsif b == -1\n      writechar @memory[a]\n    else\n      difference = @memory[b] -= @memory[a]\n      @instruction_pointer = c if difference <= 0\n    end\n\n    @instruction_pointer\n  end\n\n  def run\n    current_pointer = @instruction_pointer\n    current_pointer = step while current_pointer >= 0\n  end\n\n  private\n\n  def readchar\n    gets[0].ord\n  end\n\n  def writechar code_point\n    print code_point.chr\n  end\nend\n\nsubleq = Computer.new ARGV\n\nsubleq.run\n", "target": "import sys\n\ndef subleq(a):\n    i = 0\n    try:\n        while i >= 0:\n            if a[i] == -1:\n                a[a[i + 1]] = ord(sys.stdin.read(1))\n            elif a[i + 1] == -1:\n                print(chr(a[a[i]]), end=\"\")\n            else:\n                a[a[i + 1]] -= a[a[i]]\n                if a[a[i + 1]] <= 0:\n                    i = a[i + 2]\n                    continue\n            i += 3\n    except (ValueError, IndexError, KeyboardInterrupt):\n        print(\"abort\")\n        print(a)\n\nsubleq([15, 17, -1, 17, -1, -1, 16, 1, -1, 16, 3, -1, 15, 15,\n        0, 0, -1, 72, 101, 108, 108, 111, 44, 32, 119, 111,\n        114, 108, 100, 33, 10, 0])\n"}
{"id": 160880, "name": "Last letter-first letter", "source": "Translate Ruby to C#: class LastL_FirstL\n  def initialize(names)\n    @names = names.dup\n    @first = names.group_by {|name| name[0]}\n    @sequences = []\n  end\n  \n  def add_name(seq)\n    last_letter = seq[-1][-1]\n    potentials = @first.include?(last_letter) ? (@first[last_letter] - seq) : []\n    if potentials.empty?\n      @sequences << seq\n    else\n      potentials.each {|name| add_name(seq + [name])}\n    end\n  end\n  \n  def search\n    @names.each {|name| add_name [name]}\n    max = @sequences.max_by {|seq| seq.length}.length\n    max_seqs = @sequences.select {|seq| seq.length == max}\n    puts \"there are \n    puts \"the longest is \n    puts \"there are \n    max_seqs.last.each_with_index {|name, idx| puts \"  %2d %s\" % [idx+1, name]}\n  end\nend\n\nnames = %w{\n  audino bagon baltoy banette bidoof braviary bronzor carracosta charmeleon\n  cresselia croagunk darmanitan deino emboar emolga exeggcute gabite\n  girafarig gulpin haxorus heatmor heatran ivysaur jellicent jumpluff kangaskhan\n  kricketune landorus ledyba loudred lumineon lunatone machamp magnezone mamoswine\n  nosepass petilil pidgeotto pikachu pinsir poliwrath poochyena porygon2\n  porygonz registeel relicanth remoraid rufflet sableye scolipede scrafty seaking\n  sealeo silcoon simisear snivy snorlax spoink starly tirtouga trapinch treecko\n  tyrogue vigoroth vulpix wailord wartortle whismur wingull yamask\n}\n\nlf = LastL_FirstL.new(names)\nlf.search\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\nnamespace ConsoleApplication1\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            string pokemon_names = @\"audino bagon baltoy banette bidoof braviary bronzor carracosta charmeleon\ncresselia croagunk darmanitan deino emboar emolga exeggcute gabite\ngirafarig gulpin haxorus heatmor heatran ivysaur jellicent jumpluff kangaskhan\nkricketune landorus ledyba loudred lumineon lunatone machamp magnezone mamoswine\nnosepass petilil pidgeotto pikachu pinsir poliwrath poochyena porygon2\nporygonz registeel relicanth remoraid rufflet sableye scolipede scrafty seaking\nsealeo silcoon simisear snivy snorlax spoink starly tirtouga trapinch treecko\ntyrogue vigoroth vulpix wailord wartortle whismur wingull yamask\";\n\n            string[] pokemon = pokemon_names.Split(new char[]{' ','\\n'});\n            List<string> chain = new List<string>(pokemon.Length);\n\n            for (int i = 0; i < pokemon.Length; i++)\n            {\n                swap(ref pokemon[0], ref pokemon[i]);\n                Search( pokemon, chain, 1 );               \n                swap(ref pokemon[0], ref pokemon[i]);\n            }\n\n            foreach (string s in chain)\n                Console.WriteLine(s);\n\n            Console.ReadKey();\n        }\n\n        static void Search(string[] pokemon, List<string> longest_chain, int len )\n        {\n            if (len > longest_chain.Count)\n            {\n                longest_chain.Clear();\n                for (int i = 0; i < len; i++)\n                    longest_chain.Add(pokemon[i]);\n            }\n\n            char lastchar = pokemon[len - 1][pokemon[len-1].Length - 1];\n            for (int i = len; i < pokemon.Length; i++)\n            {\n                if (pokemon[i][0] == lastchar)\n                {\n                    swap(ref pokemon[i], ref pokemon[len]);\n                    Search(pokemon, longest_chain, len + 1);\n                    swap(ref pokemon[i], ref pokemon[len]);\n                }\n            }\n        }\n\n        static void swap(ref string s1, ref string s2)\n        {\n            string tmp = s1;\n            s1 = s2;\n            s2 = tmp;\n        }\n    }\n}\n"}
{"id": 160882, "name": "Last letter-first letter", "source": "Translate Ruby to Java: class LastL_FirstL\n  def initialize(names)\n    @names = names.dup\n    @first = names.group_by {|name| name[0]}\n    @sequences = []\n  end\n  \n  def add_name(seq)\n    last_letter = seq[-1][-1]\n    potentials = @first.include?(last_letter) ? (@first[last_letter] - seq) : []\n    if potentials.empty?\n      @sequences << seq\n    else\n      potentials.each {|name| add_name(seq + [name])}\n    end\n  end\n  \n  def search\n    @names.each {|name| add_name [name]}\n    max = @sequences.max_by {|seq| seq.length}.length\n    max_seqs = @sequences.select {|seq| seq.length == max}\n    puts \"there are \n    puts \"the longest is \n    puts \"there are \n    max_seqs.last.each_with_index {|name, idx| puts \"  %2d %s\" % [idx+1, name]}\n  end\nend\n\nnames = %w{\n  audino bagon baltoy banette bidoof braviary bronzor carracosta charmeleon\n  cresselia croagunk darmanitan deino emboar emolga exeggcute gabite\n  girafarig gulpin haxorus heatmor heatran ivysaur jellicent jumpluff kangaskhan\n  kricketune landorus ledyba loudred lumineon lunatone machamp magnezone mamoswine\n  nosepass petilil pidgeotto pikachu pinsir poliwrath poochyena porygon2\n  porygonz registeel relicanth remoraid rufflet sableye scolipede scrafty seaking\n  sealeo silcoon simisear snivy snorlax spoink starly tirtouga trapinch treecko\n  tyrogue vigoroth vulpix wailord wartortle whismur wingull yamask\n}\n\nlf = LastL_FirstL.new(names)\nlf.search\n", "target": "\nfinal class LastLetterFirstLetter {\n    static int maxPathLength = 0;\n    static int maxPathLengthCount = 0;\n    static final StringBuffer maxPathExample = new StringBuffer(500);\n\n    static final String[] names = {\"audino\", \"bagon\", \"baltoy\", \"banette\",\n        \"bidoof\", \"braviary\", \"bronzor\", \"carracosta\", \"charmeleon\",\n        \"cresselia\", \"croagunk\", \"darmanitan\", \"deino\", \"emboar\",\n        \"emolga\", \"exeggcute\", \"gabite\", \"girafarig\", \"gulpin\",\n        \"haxorus\", \"heatmor\", \"heatran\", \"ivysaur\", \"jellicent\",\n        \"jumpluff\", \"kangaskhan\", \"kricketune\", \"landorus\", \"ledyba\",\n        \"loudred\", \"lumineon\", \"lunatone\", \"machamp\", \"magnezone\",\n        \"mamoswine\", \"nosepass\", \"petilil\", \"pidgeotto\", \"pikachu\",\n        \"pinsir\", \"poliwrath\", \"poochyena\", \"porygon2\", \"porygonz\",\n        \"registeel\", \"relicanth\", \"remoraid\", \"rufflet\", \"sableye\",\n        \"scolipede\", \"scrafty\", \"seaking\", \"sealeo\", \"silcoon\",\n        \"simisear\", \"snivy\", \"snorlax\", \"spoink\", \"starly\", \"tirtouga\",\n        \"trapinch\", \"treecko\", \"tyrogue\", \"vigoroth\", \"vulpix\",\n        \"wailord\", \"wartortle\", \"whismur\", \"wingull\", \"yamask\"};\n\n    static void recursive(String[] part, int offset) {\n        if (offset > maxPathLength) {\n            maxPathLength = offset;\n            maxPathLengthCount = 1;\n        } else if (offset == maxPathLength) {\n            maxPathLengthCount++;\n            maxPathExample.setLength(0);\n            for (int i = 0; i < offset; i++) {\n                maxPathExample.append((i % 5 == 0 ? \"\\n  \" : \" \"));\n                maxPathExample.append(part[i]);\n            }\n        }\n        final char lastChar = part[offset - 1].charAt(part[offset - 1].length()-1);\n        for (int i = offset; i < part.length; i++) {\n            if (part[i].charAt(0) == lastChar) {\n                String tmp = names[offset];\n                names[offset] = names[i];\n                names[i] = tmp;\n                recursive(names, offset+1);\n                names[i] = names[offset];\n                names[offset] = tmp;\n            }\n        }\n    }\n\n    public static void main(String[] args) {\n        for (int i = 0; i < names.length; i++) {\n            String tmp = names[0];\n            names[0] = names[i];\n            names[i] = tmp;\n            recursive(names, 1);\n            names[i] = names[0];\n            names[0] = tmp;\n       }\n       System.out.println(\"maximum path length       \u00a0: \" + maxPathLength);\n       System.out.println(\"paths of that length      \u00a0: \" + maxPathLengthCount);\n       System.out.println(\"example path of that length:\" + maxPathExample);\n    }\n}\n"}
{"id": 160883, "name": "Last letter-first letter", "source": "Translate Ruby to Python: class LastL_FirstL\n  def initialize(names)\n    @names = names.dup\n    @first = names.group_by {|name| name[0]}\n    @sequences = []\n  end\n  \n  def add_name(seq)\n    last_letter = seq[-1][-1]\n    potentials = @first.include?(last_letter) ? (@first[last_letter] - seq) : []\n    if potentials.empty?\n      @sequences << seq\n    else\n      potentials.each {|name| add_name(seq + [name])}\n    end\n  end\n  \n  def search\n    @names.each {|name| add_name [name]}\n    max = @sequences.max_by {|seq| seq.length}.length\n    max_seqs = @sequences.select {|seq| seq.length == max}\n    puts \"there are \n    puts \"the longest is \n    puts \"there are \n    max_seqs.last.each_with_index {|name, idx| puts \"  %2d %s\" % [idx+1, name]}\n  end\nend\n\nnames = %w{\n  audino bagon baltoy banette bidoof braviary bronzor carracosta charmeleon\n  cresselia croagunk darmanitan deino emboar emolga exeggcute gabite\n  girafarig gulpin haxorus heatmor heatran ivysaur jellicent jumpluff kangaskhan\n  kricketune landorus ledyba loudred lumineon lunatone machamp magnezone mamoswine\n  nosepass petilil pidgeotto pikachu pinsir poliwrath poochyena porygon2\n  porygonz registeel relicanth remoraid rufflet sableye scolipede scrafty seaking\n  sealeo silcoon simisear snivy snorlax spoink starly tirtouga trapinch treecko\n  tyrogue vigoroth vulpix wailord wartortle whismur wingull yamask\n}\n\nlf = LastL_FirstL.new(names)\nlf.search\n", "target": "from collections import defaultdict\n\ndef order_words(words):\n    byfirst = defaultdict(set)\n    for word in words:\n        byfirst[word[0]].add( word )\n    \n    return byfirst\n\ndef linkfirst(byfirst, sofar):\n    \n\n    assert sofar\n    chmatch = sofar[-1][-1]\n    options = byfirst[chmatch] - set(sofar)\n    \n    if not options:\n        return sofar\n    else:\n        alternatives = ( linkfirst(byfirst, list(sofar) + [word])\n                         for word in options )\n        mx = max( alternatives, key=len )\n        \n        return mx\n\ndef llfl(words):\n\n    byfirst = order_words(words)\n    return max( (linkfirst(byfirst, [word]) for word in words), key=len )\n\nif __name__ == '__main__':\n    pokemon = \n    pokemon = pokemon.strip().lower().split()\n    pokemon = sorted(set(pokemon))    \n    l = llfl(pokemon)\n    for i in range(0, len(l), 8): print(' '.join(l[i:i+8]))\n    print(len(l))\n"}
{"id": 161117, "name": "Range extraction", "source": "Translate Ruby to C#: def range_extract(l)\n  \n  \n  sorted, range = l.sort.concat([Float::MAX]), []\n  canidate_number = sorted.first\n\n  \n  sorted.each_cons(2) do |current_number, next_number|\n    \n    if current_number.succ < next_number\n      \n      if canidate_number == current_number\n        \n        range << canidate_number.to_s\n      else\n        \n        \n        seperator = canidate_number.succ == current_number ? \",\" : \"-\"\n        range << \"%d%s%d\" % [canidate_number, seperator, current_number]\n      end\n      \n      canidate_number = next_number\n    end\n  end\n  range.join(',')\nend\n\nlst = [\n    0,  1,  2,  4,  6,  7,  8, 11, 12, 14,\n   15, 16, 17, 18, 19, 20, 21, 22, 23, 24,\n   25, 27, 28, 29, 30, 31, 32, 33, 35, 36,\n   37, 38, 39\n]\n\np rng = range_extract(lst)\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\nclass RangeExtraction\n{\n    static void Main()\n    {\n        const string testString = \"0,  1,  2,  4,  6,  7,  8, 11, 12, 14,15, 16, 17, 18, 19, 20, 21, 22, 23, 24,25, 27, 28, 29, 30, 31, 32, 33, 35, 36,37, 38, 39\";\n        var result = String.Join(\",\", RangesToStrings(GetRanges(testString)));\n        Console.Out.WriteLine(result);\n    }\n\n    public static IEnumerable<IEnumerable<int>> GetRanges(string testString)\n    {\n        var numbers = testString.Split(new[] { ',' }).Select(x => Convert.ToInt32(x));\n        var current = new List<int>();\n        foreach (var n in numbers)\n        {\n            if (current.Count == 0)\n            {\n                current.Add(n);\n            }\n            else\n            {\n                if (current.Max() + 1 == n)\n                {\n                    current.Add(n);\n                }\n                else\n                {\n                    yield return current;\n                    current = new List<int> { n };\n                }\n            }\n        }\n        yield return current;\n    }\n\n    public static IEnumerable<string> RangesToStrings(IEnumerable<IEnumerable<int>> ranges)\n    {\n        foreach (var range in ranges)\n        {\n            if (range.Count() == 1)\n            {\n                yield return range.Single().ToString();\n            }\n            else if (range.Count() == 2)\n            {\n                yield return range.Min() + \",\" + range.Max();\n            }\n            else\n            {\n                yield return range.Min() + \"-\" + range.Max();\n            }\n        }\n    }\n}\n"}
{"id": 161119, "name": "Range extraction", "source": "Translate Ruby to Java: def range_extract(l)\n  \n  \n  sorted, range = l.sort.concat([Float::MAX]), []\n  canidate_number = sorted.first\n\n  \n  sorted.each_cons(2) do |current_number, next_number|\n    \n    if current_number.succ < next_number\n      \n      if canidate_number == current_number\n        \n        range << canidate_number.to_s\n      else\n        \n        \n        seperator = canidate_number.succ == current_number ? \",\" : \"-\"\n        range << \"%d%s%d\" % [canidate_number, seperator, current_number]\n      end\n      \n      canidate_number = next_number\n    end\n  end\n  range.join(',')\nend\n\nlst = [\n    0,  1,  2,  4,  6,  7,  8, 11, 12, 14,\n   15, 16, 17, 18, 19, 20, 21, 22, 23, 24,\n   25, 27, 28, 29, 30, 31, 32, 33, 35, 36,\n   37, 38, 39\n]\n\np rng = range_extract(lst)\n", "target": "public class RangeExtraction {\n\n    public static void main(String[] args) {\n        int[] arr = {0, 1, 2, 4, 6, 7, 8, 11, 12, 14,\n            15, 16, 17, 18, 19, 20, 21, 22, 23, 24,\n            25, 27, 28, 29, 30, 31, 32, 33, 35, 36,\n            37, 38, 39};\n\n        int len = arr.length;\n        int idx = 0, idx2 = 0;\n        while (idx < len) {\n            while (++idx2 < len && arr[idx2] - arr[idx2 - 1] == 1);\n            if (idx2 - idx > 2) {\n                System.out.printf(\"%s-%s,\", arr[idx], arr[idx2 - 1]);\n                idx = idx2;\n            } else {\n                for (; idx < idx2; idx++)\n                    System.out.printf(\"%s,\", arr[idx]);\n            }\n        }\n    }\n}\n"}
{"id": 161120, "name": "Range extraction", "source": "Translate Ruby to Python: def range_extract(l)\n  \n  \n  sorted, range = l.sort.concat([Float::MAX]), []\n  canidate_number = sorted.first\n\n  \n  sorted.each_cons(2) do |current_number, next_number|\n    \n    if current_number.succ < next_number\n      \n      if canidate_number == current_number\n        \n        range << canidate_number.to_s\n      else\n        \n        \n        seperator = canidate_number.succ == current_number ? \",\" : \"-\"\n        range << \"%d%s%d\" % [canidate_number, seperator, current_number]\n      end\n      \n      canidate_number = next_number\n    end\n  end\n  range.join(',')\nend\n\nlst = [\n    0,  1,  2,  4,  6,  7,  8, 11, 12, 14,\n   15, 16, 17, 18, 19, 20, 21, 22, 23, 24,\n   25, 27, 28, 29, 30, 31, 32, 33, 35, 36,\n   37, 38, 39\n]\n\np rng = range_extract(lst)\n", "target": "def range_extract(lst):\n    'Yield 2-tuple ranges or 1-tuple single elements from list of increasing ints'\n    lenlst = len(lst)\n    i = 0\n    while i< lenlst:\n        low = lst[i]\n        while i <lenlst-1 and lst[i]+1 == lst[i+1]: i +=1\n        hi = lst[i]\n        if   hi - low >= 2:\n            yield (low, hi)\n        elif hi - low == 1:\n            yield (low,)\n            yield (hi,)\n        else:\n            yield (low,)\n        i += 1\n\ndef printr(ranges):\n    print( ','.join( (('%i-%i' % r) if len(r) == 2 else '%i' % r)\n                     for r in ranges ) )\n\nif __name__ == '__main__':\n    for lst in [[-8, -7, -6, -3, -2, -1, 0, 1, 3, 4, 5, 7,\n                 8, 9, 10, 11, 14, 15, 17, 18, 19, 20],\n                [0, 1, 2, 4, 6, 7, 8, 11, 12, 14, 15, 16, 17, 18, 19, 20, 21, 22,\n                 23, 24, 25, 27, 28, 29, 30, 31, 32, 33, 35, 36, 37, 38, 39]]:\n        \n        printr(range_extract(lst))\n"}
{"id": 161248, "name": "Copy stdin to stdout", "source": "Translate Ruby to C#: STDIN.each_line do |line|\n  puts line\nend\n", "target": "using System;\n\nclass Program\n{\n    static void Main(string[] args)\n    {\n        Console.OpenStandardInput().CopyTo(Console.OpenStandardOutput());\n    }\n}\n"}
{"id": 161250, "name": "Copy stdin to stdout", "source": "Translate Ruby to Java: STDIN.each_line do |line|\n  puts line\nend\n", "target": "import java.util.Scanner;\n\npublic class CopyStdinToStdout {\n\n    public static void main(String[] args) {\n        try (Scanner scanner = new Scanner(System.in);) {\n            String s;\n            while ( (s = scanner.nextLine()).compareTo(\"\") != 0 ) {\n                System.out.println(s);\n            }\n        }\n    }\n\n}\n"}
{"id": 161446, "name": "Zeckendorf number representation", "source": "Translate Ruby to C#: def zeckendorf(n)\n  return 0 if n.zero?\n  fib = [1, 2]\n  while fib[-1] < n; fib << fib[-2] + fib[-1] end\n  digit = \"\"\n  fib.reverse_each do |f|\n    if f <= n\n      digit, n = digit + \"1\", n - f\n    else\n      digit += \"0\"\n    end\n  end\n  digit.to_i\nend\n \n(0..20).each { |i| puts \"%3d: %8d\" % [i, zeckendorf(i)] }\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\nnamespace Zeckendorf\n{\n    class Program\n    {\n        private static uint Fibonacci(uint n)\n        {\n            if (n < 2)\n            {\n                return n;\n            }\n            else\n            {\n                return Fibonacci(n - 1) + Fibonacci(n - 2);\n            }\n        }\n\n        private static string Zeckendorf(uint num)\n        {\n            IList<uint> fibonacciNumbers = new List<uint>();\n            uint fibPosition = 2;\n\n            uint currentFibonaciNum = Fibonacci(fibPosition);\n\n            do\n            {\n                fibonacciNumbers.Add(currentFibonaciNum);\n                currentFibonaciNum = Fibonacci(++fibPosition);\n            } while (currentFibonaciNum <= num);\n\n            uint temp = num;\n            StringBuilder output = new StringBuilder();\n\n            foreach (uint item in fibonacciNumbers.Reverse())\n            {\n                if (item <= temp)\n                {\n                    output.Append(\"1\");\n                    temp -= item;\n                }\n                else\n                {\n                    output.Append(\"0\");\n                }\n            }\n\n            return output.ToString();\n        }\n\n        static void Main(string[] args)\n        {\n            for (uint i = 1; i <= 20; i++)\n            {\n                string zeckendorfRepresentation = Zeckendorf(i);\n                Console.WriteLine(string.Format(\"{0}\u00a0: {1}\", i, zeckendorfRepresentation));\n            }\n\n            Console.ReadKey();\n        }\n    }\n}\n"}
{"id": 161448, "name": "Zeckendorf number representation", "source": "Translate Ruby to Java: def zeckendorf(n)\n  return 0 if n.zero?\n  fib = [1, 2]\n  while fib[-1] < n; fib << fib[-2] + fib[-1] end\n  digit = \"\"\n  fib.reverse_each do |f|\n    if f <= n\n      digit, n = digit + \"1\", n - f\n    else\n      digit += \"0\"\n    end\n  end\n  digit.to_i\nend\n \n(0..20).each { |i| puts \"%3d: %8d\" % [i, zeckendorf(i)] }\n", "target": "import java.util.*;\n\nclass Zeckendorf\n{\n  public static String getZeckendorf(int n)\n  {\n    if (n == 0)\n      return \"0\";\n    List<Integer> fibNumbers = new ArrayList<Integer>();\n    fibNumbers.add(1);\n    int nextFib = 2;\n    while (nextFib <= n)\n    {\n      fibNumbers.add(nextFib);\n      nextFib += fibNumbers.get(fibNumbers.size() - 2);\n    }\n    StringBuilder sb = new StringBuilder();\n    for (int i = fibNumbers.size() - 1; i >= 0; i--)\n    {\n      int fibNumber = fibNumbers.get(i);\n      sb.append((fibNumber <= n) ? \"1\" : \"0\");\n      if (fibNumber <= n)\n        n -= fibNumber;\n    }\n    return sb.toString();\n  }\n  \n  public static void main(String[] args)\n  {\n    for (int i = 0; i <= 20; i++)\n      System.out.println(\"Z(\" + i + \")=\" + getZeckendorf(i));\n  }\n}\n"}
{"id": 161449, "name": "Zeckendorf number representation", "source": "Translate Ruby to Python: def zeckendorf(n)\n  return 0 if n.zero?\n  fib = [1, 2]\n  while fib[-1] < n; fib << fib[-2] + fib[-1] end\n  digit = \"\"\n  fib.reverse_each do |f|\n    if f <= n\n      digit, n = digit + \"1\", n - f\n    else\n      digit += \"0\"\n    end\n  end\n  digit.to_i\nend\n \n(0..20).each { |i| puts \"%3d: %8d\" % [i, zeckendorf(i)] }\n", "target": "def fib():\n    memo = [1, 2]\n    while True:\n        memo.append(sum(memo))\n        yield memo.pop(0)\n\ndef sequence_down_from_n(n, seq_generator):\n    seq = []\n    for s in seq_generator():\n        seq.append(s)\n        if s >= n: break\n    return seq[::-1]\n\ndef zeckendorf(n):\n    if n == 0: return [0]\n    seq = sequence_down_from_n(n, fib)\n    digits, nleft = [], n\n    for s in seq:\n        if s <= nleft:\n            digits.append(1)\n            nleft -= s\n        else:\n            digits.append(0)\n    assert nleft == 0, 'Check all of n is accounted for'\n    assert sum(x*y for x,y in zip(digits, seq)) == n, 'Assert digits are correct'\n    while digits[0] == 0:\n        \n        digits.pop(0)\n    return digits\n\nn = 20\nprint('Fibonacci digit multipliers: %r' % sequence_down_from_n(n, fib))\nfor i in range(n + 1):\n    print('%3i: %8s' % (i, ''.join(str(d) for d in zeckendorf(i))))\n"}
{"id": 161696, "name": "Reverse words in a string", "source": "Translate Ruby to C#: puts <<EOS\n---------- Ice and Fire ------------\n\nfire, in end will world the say Some\nice. in say Some\ndesire of tasted I've what From\nfire. favor who those with hold I\n\n... elided paragraph last ...\n\nFrost Robert -----------------------\nEOS\n  .each_line.map {|line| line.split.reverse.join(' ')}\n", "target": "using System;\n\npublic class ReverseWordsInString\n{\n    public static void Main(string[] args)\n    {\n        string text = @\"\n            ---------- Ice and Fire ------------\n\n            fire, in end will world the say Some\n            ice. in say Some\n            desire of tasted I've what From\n            fire. favor who those with hold I\n\n            ... elided paragraph last ...\n\n            Frost Robert -----------------------\n            \";\n\n        foreach (string line in text.Split(Environment.NewLine)) {\n            \n            string[] words = line.Split(default(char[]), StringSplitOptions.RemoveEmptyEntries);\n            Array.Reverse(words);\n            WriteLine(string.Join(\" \", words));\n        }\n    }\n}\n"}
{"id": 161698, "name": "Reverse words in a string", "source": "Translate Ruby to Java: puts <<EOS\n---------- Ice and Fire ------------\n\nfire, in end will world the say Some\nice. in say Some\ndesire of tasted I've what From\nfire. favor who those with hold I\n\n... elided paragraph last ...\n\nFrost Robert -----------------------\nEOS\n  .each_line.map {|line| line.split.reverse.join(' ')}\n", "target": "public class ReverseWords {\n\n    static final String[] lines = {\n        \" ----------- Ice and Fire ----------- \",\n        \"                                      \",\n        \" fire, in end will world the say Some \",\n        \" ice. in say Some                     \",\n        \" desire of tasted I've what From      \",\n        \" fire. favor who those with hold I    \",\n        \"                                      \",\n        \" ... elided paragraph last ...        \",\n        \" Frost Robert ----------------------- \"};\n\n    public static void main(String[] args) {\n        for (String line : lines) {\n            String[] words = line.split(\"\\\\s\");\n            for (int i = words.length - 1; i >= 0; i--)\n                System.out.printf(\"%s \", words[i]);\n            System.out.println();\n        }\n    }\n}\n"}
{"id": 161699, "name": "Reverse words in a string", "source": "Translate Ruby to Python: puts <<EOS\n---------- Ice and Fire ------------\n\nfire, in end will world the say Some\nice. in say Some\ndesire of tasted I've what From\nfire. favor who those with hold I\n\n... elided paragraph last ...\n\nFrost Robert -----------------------\nEOS\n  .each_line.map {|line| line.split.reverse.join(' ')}\n", "target": " text = \n\nfor line in text.split('\\n'): print(' '.join(line.split()[::-1]))\n"}
{"id": 161891, "name": "Iterated digits squaring", "source": "Translate Ruby to C#: \ndef iterated_square_digit(d)\n  f = Array.new(d+1){|n| (1..n).inject(1, :*)}      \n  g = -> (n) { res = n.digits.sum{|d| d*d} \n               res==89 ? 0 : res }\n  \n  \n  table = Array.new(d*81+1){|n| n.zero? ? 1 : (i=g.call(n))==89 ? 0 : i}\n  table.collect!{|n| n = table[n] while n>1; n}\n  z = 0                                             \n  [*0..9].repeated_combination(d) do |rc|           \n    next if table[rc.inject(0){|g,n| g+n*n}].zero?  \n    nn = [0] * 10                                   \n    rc.each{|n| nn[n] += 1}\n    z += nn.inject(f[d]){|gn,n| gn / f[n]}          \n  end\n  puts \"\\nd=(\n       \"\nend\n\n[8, 11, 14, 17].each do |d|\n  t0 = Time.now\n  iterated_square_digit(d)\n  puts \"  \nend\n", "target": "using System;\npublic static class IteratedDigitsSquaring\n{\n    public static void Main() {\n        Console.WriteLine(Count89s(1_000_000));\n        Console.WriteLine(Count89s(100_000_000));\n    }\n\n    public static int Count89s(int limit) {\n        if (limit < 1) return 0;\n        int[] end = new int[Math.Min(limit, 9 * 9 * 9 + 2)];\n        int result = 0;\n\n        for (int i = 1; i < end.Length; i++) {\n            for (end[i] = i; end[i] != 1 && end[i] != 89; end[i] = SquareDigitSum(end[i])) { }\n            if (end[i] == 89) result++;\n        }\n        for (int i = end.Length; i < limit; i++) {\n            if (end[SquareDigitSum(i)] == 89) result++;\n        }\n        return result;\n\n        int SquareDigitSum(int n) {\n            int sum = 0;\n            while (n > 0) {\n                int digit = n % 10;\n                sum += digit * digit;\n                n /= 10;\n            }\n            return sum;\n        }\n    }\n\n}\n"}
{"id": 161893, "name": "Iterated digits squaring", "source": "Translate Ruby to Java: \ndef iterated_square_digit(d)\n  f = Array.new(d+1){|n| (1..n).inject(1, :*)}      \n  g = -> (n) { res = n.digits.sum{|d| d*d} \n               res==89 ? 0 : res }\n  \n  \n  table = Array.new(d*81+1){|n| n.zero? ? 1 : (i=g.call(n))==89 ? 0 : i}\n  table.collect!{|n| n = table[n] while n>1; n}\n  z = 0                                             \n  [*0..9].repeated_combination(d) do |rc|           \n    next if table[rc.inject(0){|g,n| g+n*n}].zero?  \n    nn = [0] * 10                                   \n    rc.each{|n| nn[n] += 1}\n    z += nn.inject(f[d]){|gn,n| gn / f[n]}          \n  end\n  puts \"\\nd=(\n       \"\nend\n\n[8, 11, 14, 17].each do |d|\n  t0 = Time.now\n  iterated_square_digit(d)\n  puts \"  \nend\n", "target": "import java.util.stream.IntStream;\n\npublic class IteratedDigitsSquaring {\n\n    public static void main(String[] args) {\n        long r = IntStream.range(1, 100_000_000)\n                .parallel()\n                .filter(n -> calc(n) == 89)\n                .count();\n        System.out.println(r);\n    }\n\n    private static int calc(int n) {\n        while (n != 89 && n != 1) {\n            int total = 0;\n            while (n > 0) {\n                total += Math.pow(n % 10, 2);\n                n /= 10;\n            }\n            n = total;\n        }\n        return n;\n    }\n}\n"}
{"id": 161894, "name": "Iterated digits squaring", "source": "Translate Ruby to Python: \ndef iterated_square_digit(d)\n  f = Array.new(d+1){|n| (1..n).inject(1, :*)}      \n  g = -> (n) { res = n.digits.sum{|d| d*d} \n               res==89 ? 0 : res }\n  \n  \n  table = Array.new(d*81+1){|n| n.zero? ? 1 : (i=g.call(n))==89 ? 0 : i}\n  table.collect!{|n| n = table[n] while n>1; n}\n  z = 0                                             \n  [*0..9].repeated_combination(d) do |rc|           \n    next if table[rc.inject(0){|g,n| g+n*n}].zero?  \n    nn = [0] * 10                                   \n    rc.each{|n| nn[n] += 1}\n    z += nn.inject(f[d]){|gn,n| gn / f[n]}          \n  end\n  puts \"\\nd=(\n       \"\nend\n\n[8, 11, 14, 17].each do |d|\n  t0 = Time.now\n  iterated_square_digit(d)\n  puts \"  \nend\n", "target": ">>> step = lambda x: sum(int(d) ** 2 for d in str(x))\n>>> iterate = lambda x: x if x in [1, 89] else iterate(step(x))\n>>> [iterate(x) for x in xrange(1, 20)]\n[1, 89, 89, 89, 89, 89, 1, 89, 89, 1, 89, 89, 1, 89, 89, 89, 89, 89, 1]\n"}
{"id": 162108, "name": "Middle three digits", "source": "Translate Ruby to C#: def middle_three_digits(num)\n  \n  \n  num = num.abs\n  \n  \n  length = (str = num.to_s).length\n  \n  \n  raise ArgumentError, \"Number must have at least three digits\" if length < 3\n  raise ArgumentError, \"Number must have an odd number of digits\" if length.even?\n  \n  return str[length/2 - 1, 3].to_i\nend\n", "target": "using System;\n\nnamespace RosettaCode\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            string text = Math.Abs(int.Parse(Console.ReadLine())).ToString();\n            Console.WriteLine(text.Length < 2 || text.Length % 2 == 0 ? \"Error\" : text.Substring((text.Length - 3) / 2, 3));\n        }\n    }\n}\n"}
{"id": 162110, "name": "Middle three digits", "source": "Translate Ruby to Java: def middle_three_digits(num)\n  \n  \n  num = num.abs\n  \n  \n  length = (str = num.to_s).length\n  \n  \n  raise ArgumentError, \"Number must have at least three digits\" if length < 3\n  raise ArgumentError, \"Number must have an odd number of digits\" if length.even?\n  \n  return str[length/2 - 1, 3].to_i\nend\n", "target": "public class MiddleThreeDigits {\n\n    public static void main(String[] args) {\n        final long[] passing = {123, 12345, 1234567, 987654321, 10001, -10001,\n            -123, -100, 100, -12345, Long.MIN_VALUE, Long.MAX_VALUE};\n\n        final int[] failing = {1, 2, -1, -10, 2002, -2002, 0, Integer.MIN_VALUE,\n            Integer.MAX_VALUE};\n\n        for (long n : passing)\n            System.out.printf(\"middleThreeDigits(%s): %s\\n\", n, middleThreeDigits(n));\n\n        for (int n : failing)\n            System.out.printf(\"middleThreeDigits(%s): %s\\n\", n, middleThreeDigits(n));\n    }\n\n    public static <T> String middleThreeDigits(T n) {\n        String s = String.valueOf(n);\n        if (s.charAt(0) == '-')\n            s = s.substring(1);\n        int len = s.length();\n        if (len < 3 || len % 2 == 0)\n            return \"Need odd and >= 3 digits\";\n        int mid = len / 2;\n        return s.substring(mid - 1, mid + 2);\n    }\n}\n"}
{"id": 162111, "name": "Middle three digits", "source": "Translate Ruby to Python: def middle_three_digits(num)\n  \n  \n  num = num.abs\n  \n  \n  length = (str = num.to_s).length\n  \n  \n  raise ArgumentError, \"Number must have at least three digits\" if length < 3\n  raise ArgumentError, \"Number must have an odd number of digits\" if length.even?\n  \n  return str[length/2 - 1, 3].to_i\nend\n", "target": ">>> def middle_three_digits(i):\n\ts = str(abs(i))\n\tlength = len(s)\n\tassert length >= 3 and length % 2 == 1, \"Need odd and >= 3 digits\"\n\tmid = length // 2\n\treturn s[mid-1:mid+2]\n\n>>> passing = [123, 12345, 1234567, 987654321, 10001, -10001, -123, -100, 100, -12345]\n>>> failing = [1, 2, -1, -10, 2002, -2002, 0]\n>>> for x in passing + failing:\n\ttry:\n\t\tanswer = middle_three_digits(x)\n\texcept AssertionError as error:\n\t\tanswer = error\n\tprint(\"middle_three_digits(%s) returned: %r\" % (x, answer))\n\n\t\nmiddle_three_digits(123) returned: '123'\nmiddle_three_digits(12345) returned: '234'\nmiddle_three_digits(1234567) returned: '345'\nmiddle_three_digits(987654321) returned: '654'\nmiddle_three_digits(10001) returned: '000'\nmiddle_three_digits(-10001) returned: '000'\nmiddle_three_digits(-123) returned: '123'\nmiddle_three_digits(-100) returned: '100'\nmiddle_three_digits(100) returned: '100'\nmiddle_three_digits(-12345) returned: '234'\nmiddle_three_digits(1) returned: AssertionError('Need odd and >= 3 digits',)\nmiddle_three_digits(2) returned: AssertionError('Need odd and >= 3 digits',)\nmiddle_three_digits(-1) returned: AssertionError('Need odd and >= 3 digits',)\nmiddle_three_digits(-10) returned: AssertionError('Need odd and >= 3 digits',)\nmiddle_three_digits(2002) returned: AssertionError('Need odd and >= 3 digits',)\nmiddle_three_digits(-2002) returned: AssertionError('Need odd and >= 3 digits',)\nmiddle_three_digits(0) returned: AssertionError('Need odd and >= 3 digits',)\n>>>\n"}
{"id": 162365, "name": "Range expansion", "source": "Translate Ruby to C#: def range_expand(rng)\n  rng.split(',').flat_map do |part|\n    if part =~ /^(-?\\d+)-(-?\\d+)$/\n      ($1.to_i .. $2.to_i).to_a\n    else\n      Integer(part)\n    end\n  end\nend\n\np range_expand('-6,-3--1,3-5,7-11,14,15,17-20')\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text.RegularExpressions;\n\nclass Program\n{\n    static void Main(string[] args)\n    {\n        var rangeString = \"-6,-3--1,3-5,7-11,14,15,17-20\";\n        var matches = Regex.Matches(rangeString, @\"(?<f>-?\\d+)-(?<s>-?\\d+)|(-?\\d+)\");\n        var values = new List<string>();\n\n        foreach (var m in matches.OfType<Match>())\n        {\n            if (m.Groups[1].Success)\n            {\n                values.Add(m.Value);\n                continue;\n            }\n\n            var start = Convert.ToInt32(m.Groups[\"f\"].Value);\n            var end = Convert.ToInt32(m.Groups[\"s\"].Value) + 1;\n\n            values.AddRange(Enumerable.Range(start, end - start).Select(v => v.ToString()));\n        }\n\n        Console.WriteLine(string.Join(\", \", values));\n    }\n}\n"}
{"id": 162367, "name": "Range expansion", "source": "Translate Ruby to Java: def range_expand(rng)\n  rng.split(',').flat_map do |part|\n    if part =~ /^(-?\\d+)-(-?\\d+)$/\n      ($1.to_i .. $2.to_i).to_a\n    else\n      Integer(part)\n    end\n  end\nend\n\np range_expand('-6,-3--1,3-5,7-11,14,15,17-20')\n", "target": "import java.util.*;\n\nclass RangeExpander implements Iterator<Integer>, Iterable<Integer> {\n\n    private static final Pattern TOKEN_PATTERN = Pattern.compile(\"([+-]?\\\\d+)-([+-]?\\\\d+)\");\n\n    private final Iterator<String> tokensIterator;\n\n    private boolean inRange;\n    private int upperRangeEndpoint;\n    private int nextRangeValue;\n\n    public RangeExpander(String range) {\n        String[] tokens = range.split(\"\\\\s*,\\\\s*\");\n        this.tokensIterator = Arrays.asList(tokens).iterator();\n    }\n\n    @Override\n    public boolean hasNext() {\n        return hasNextRangeValue() || this.tokensIterator.hasNext();\n    }\n\n    private boolean hasNextRangeValue() {\n        return this.inRange && this.nextRangeValue <= this.upperRangeEndpoint;\n    }\n\n    @Override\n    public Integer next() {\n        if (!hasNext()) {\n            throw new NoSuchElementException();\n        }\n\n        if (hasNextRangeValue()) {\n            return this.nextRangeValue++;\n        }\n\n        String token = this.tokensIterator.next();\n\n        Matcher matcher = TOKEN_PATTERN.matcher(token);\n        if (matcher.find()) {\n            this.inRange = true;\n            this.upperRangeEndpoint = Integer.valueOf(matcher.group(2));\n            this.nextRangeValue = Integer.valueOf(matcher.group(1));\n            return this.nextRangeValue++;\n        }\n\n        this.inRange = false;\n        return Integer.valueOf(token);\n    }\n\n    @Override\n    public Iterator<Integer> iterator() {\n        return this;\n    }\n\n}\n\nclass RangeExpanderTest {\n    public static void main(String[] args) {\n        RangeExpander re = new RangeExpander(\"-6,-3--1,3-5,7-11,14,15,17-20\");\n        for (int i : re) {\n            System.out.print(i + \" \");\n        }\n    }\n}\n"}
{"id": 162368, "name": "Range expansion", "source": "Translate Ruby to Python: def range_expand(rng)\n  rng.split(',').flat_map do |part|\n    if part =~ /^(-?\\d+)-(-?\\d+)$/\n      ($1.to_i .. $2.to_i).to_a\n    else\n      Integer(part)\n    end\n  end\nend\n\np range_expand('-6,-3--1,3-5,7-11,14,15,17-20')\n", "target": "def rangeexpand(txt):\n    lst = []\n    for r in txt.split(','):\n        if '-' in r[1:]:\n            r0, r1 = r[1:].split('-', 1)\n            lst += range(int(r[0] + r0), int(r1) + 1)\n        else:\n            lst.append(int(r))\n    return lst\n\nprint(rangeexpand('-6,-3--1,3-5,7-11,14,15,17-20'))\n"}
{"id": 162510, "name": "Bitwise IO", "source": "Translate Ruby to C#: def crunch(ascii)\n  bitstring = ascii.bytes.collect {|b| \"%07b\" % b}.join\n  [bitstring].pack(\"B*\")\nend\n\ndef expand(binary)\n  bitstring = binary.unpack(\"B*\")[0]\n  bitstring.scan(/[01]{7}/).collect {|b| b.to_i(2).chr}.join\nend\n\noriginal = \"This is an ascii string that will be crunched, written, read and expanded.\"\nputs \"my ascii string is \n\nfilename = \"crunched.out\"\n\n\nFile.open(filename, \"w\") do |fh|\n  fh.binmode\n  fh.print crunch(original)\nend\n\nfilesize = File.size(filename)\nputs \"the file containing the crunched text is \n\n\nexpanded = File.open(filename, \"r\") do |fh| \n  fh.binmode\n  expand(fh.read)\nend\n\nif original == expanded\n  puts \"success\"\nelse\n  puts \"fail!\"\nend\n", "target": "using System;\nusing System.IO;\n\npublic class BitReader\n{\n    uint readData = 0;\n    int startPosition = 0;\n    int endPosition = 0;\n\n    public int InBuffer\n    {\n        get { return endPosition - startPosition; }\n    }\n\n    private Stream stream;\n\n    public Stream BaseStream\n    {\n        get { return stream; }\n    }\n\n    public BitReader(Stream stream)\n    {\n        this.stream = stream;\n    }\n\n    void EnsureData(int bitCount)\n    {\n        int readBits = bitCount - InBuffer;\n        while (readBits > 0)\n        {\n            int b = BaseStream.ReadByte();\n\n            if (b < 0) throw new InvalidOperationException(\"Unexpected end of stream\");\n\n            readData |= checked((uint)b << endPosition);\n            endPosition += 8;\n            readBits -= 8;\n        }\n    }\n\n    public bool ReadBit()\n    {\n        return Read(1) > 0;\n    }\n\n    public int Read(int bitCount)\n    {\n        EnsureData(bitCount);\n\n        int result = (int)(readData >> startPosition) & ((1 << bitCount) - 1);\n        startPosition += bitCount;\n        if (endPosition == startPosition)\n        {\n            endPosition = startPosition = 0;\n            readData = 0;\n        }\n        else if (startPosition >= 8)\n        {\n            readData >>= startPosition;\n            endPosition -= startPosition;\n            startPosition = 0;\n        }\n\n        return result;\n    }\n\n    public void Align()\n    {\n        endPosition = startPosition = 0;\n        readData = 0;\n    }\n}\n\npublic class BitWriter\n{\n    uint data = 0;\n    int dataLength = 0;\n    Stream stream;\n\n    public Stream BaseStream\n    {\n        get { return stream; }\n    }\n\n    public int BitsToAligment\n    {\n        get { return (32 - dataLength) % 8; }\n    }\n\n    public BitWriter(Stream stream)\n    {\n        this.stream = stream;\n    }\n\n    public void WriteBit(bool value)\n    {\n        Write(value ? 1 : 0, 1);\n    }\n\n    public void Write(int value, int length)\n    {\n        uint currentData = data | checked((uint)value << dataLength);\n        int currentLength = dataLength + length;\n        while (currentLength >= 8)\n        {\n            BaseStream.WriteByte((byte)currentData);\n            currentData >>= 8;\n            currentLength -= 8;\n        }\n        data = currentData;\n        dataLength = currentLength;\n    }\n\n    public void Align()\n    {\n        if (dataLength > 0)\n        {\n            BaseStream.WriteByte((byte)data);\n\n            data = 0;\n            dataLength = 0;\n        }\n    }\n}\n\nclass Program\n{\n    static void Main(string[] args)\n    {\n        MemoryStream ms = new MemoryStream();\n        BitWriter writer = new BitWriter(ms);\n        writer.WriteBit(true);\n        writer.Write(5, 3);\n        writer.Write(0x0155, 11);\n        writer.Align();\n\n        ms.Position = 0;\n        BitReader reader = new BitReader(ms);\n        Console.WriteLine(reader.ReadBit());\n        Console.WriteLine(reader.Read(3));\n        Console.WriteLine(reader.Read(11).ToString(\"x4\"));\n        reader.Align();\n    }\n}\n"}
{"id": 162511, "name": "Bitwise IO", "source": "Translate Ruby to Java: def crunch(ascii)\n  bitstring = ascii.bytes.collect {|b| \"%07b\" % b}.join\n  [bitstring].pack(\"B*\")\nend\n\ndef expand(binary)\n  bitstring = binary.unpack(\"B*\")[0]\n  bitstring.scan(/[01]{7}/).collect {|b| b.to_i(2).chr}.join\nend\n\noriginal = \"This is an ascii string that will be crunched, written, read and expanded.\"\nputs \"my ascii string is \n\nfilename = \"crunched.out\"\n\n\nFile.open(filename, \"w\") do |fh|\n  fh.binmode\n  fh.print crunch(original)\nend\n\nfilesize = File.size(filename)\nputs \"the file containing the crunched text is \n\n\nexpanded = File.open(filename, \"r\") do |fh| \n  fh.binmode\n  expand(fh.read)\nend\n\nif original == expanded\n  puts \"success\"\nelse\n  puts \"fail!\"\nend\n", "target": "module BitwiseIO\n    {\n    class BitReader\n        {\n        construct(Byte[] bytes)\n            {\n            this.bits = bytes.toBitArray();\n            }\n\n        private Bit[] bits;\n        private Int   index;\n\n        Int offset          \n            {\n            @Override\n            Int get()\n                {\n                return index;\n                }\n\n            @Override\n            void set(Int offset)\n                {\n                assert 0 <= offset < size;\n                index = offset;\n                }\n            }\n\n        Int size.get()      \n            {\n            return bits.size;\n            }\n\n        Boolean eof.get()   \n            {\n            return index >= size;\n            }\n\n        Bit readBit()\n            {\n            return eof ? assert:bounds : bits[index++];\n            }\n\n        Byte readByte()\n            {\n            assert:bounds index + 8 <= size as $\"eof (offset={index}, size={size}\";\n            Int start = index;\n            index += 8;\n            return bits[start ..< index].toByte();\n            }\n        }\n\n    class BitWriter\n        {\n        private Bit[] bits = new Bit[];\n\n        BitWriter writeBit(Bit bit)\n            {\n            bits.add(bit);\n            return this;\n            }\n\n        BitWriter writeByte(Byte byte)\n            {\n            bits.addAll(byte.toBitArray());\n            return this;\n            }\n\n        Byte[] bytes.get()\n            {\n            \n            \n            \n            bits += bits.size & 0x7 == 0 ? [] : Byte:0.toBitArray() [bits.size & 0x7 ..< 8];\n            return bits.toByteArray();\n            }\n        }\n\n    @Inject Console console;\n    void run()\n        {\n        Bit[] orig = [0,1,0,1,0,1,1,1,0,1,0,1,0];   \n\n        val out = new BitWriter();\n        orig.forEach(bit -> out.writeBit(bit));\n\n        val bytes = out.bytes;\n        console.print($\"bytes written={bytes}\");  \n\n        val in = new BitReader(bytes);\n        val test = new Bit[orig.size]((Int i) -> in.readBit());\n        assert test == orig;\n        }\n    }\n"}
{"id": 162512, "name": "Bitwise IO", "source": "Translate Ruby to Python: def crunch(ascii)\n  bitstring = ascii.bytes.collect {|b| \"%07b\" % b}.join\n  [bitstring].pack(\"B*\")\nend\n\ndef expand(binary)\n  bitstring = binary.unpack(\"B*\")[0]\n  bitstring.scan(/[01]{7}/).collect {|b| b.to_i(2).chr}.join\nend\n\noriginal = \"This is an ascii string that will be crunched, written, read and expanded.\"\nputs \"my ascii string is \n\nfilename = \"crunched.out\"\n\n\nFile.open(filename, \"w\") do |fh|\n  fh.binmode\n  fh.print crunch(original)\nend\n\nfilesize = File.size(filename)\nputs \"the file containing the crunched text is \n\n\nexpanded = File.open(filename, \"r\") do |fh| \n  fh.binmode\n  expand(fh.read)\nend\n\nif original == expanded\n  puts \"success\"\nelse\n  puts \"fail!\"\nend\n", "target": "class BitWriter(object):\n    def __init__(self, f):\n        self.accumulator = 0\n        self.bcount = 0\n        self.out = f\n\n    def __enter__(self):\n        return self\n\n    def __exit__(self, exc_type, exc_val, exc_tb):\n        self.flush()\n\n    def __del__(self):\n        try:\n            self.flush()\n        except ValueError:   \n            pass\n\n    def _writebit(self, bit):\n        if self.bcount == 8:\n            self.flush()\n        if bit > 0:\n            self.accumulator |= 1 << 7-self.bcount\n        self.bcount += 1\n\n    def writebits(self, bits, n):\n        while n > 0:\n            self._writebit(bits & 1 << n-1)\n            n -= 1\n\n    def flush(self):\n        self.out.write(bytearray([self.accumulator]))\n        self.accumulator = 0\n        self.bcount = 0\n\n\nclass BitReader(object):\n    def __init__(self, f):\n        self.input = f\n        self.accumulator = 0\n        self.bcount = 0\n        self.read = 0\n\n    def __enter__(self):\n        return self\n\n    def __exit__(self, exc_type, exc_val, exc_tb):\n        pass\n\n    def _readbit(self):\n        if not self.bcount:\n            a = self.input.read(1)\n            if a:\n                self.accumulator = ord(a)\n            self.bcount = 8\n            self.read = len(a)\n        rv = (self.accumulator & (1 << self.bcount-1)) >> self.bcount-1\n        self.bcount -= 1\n        return rv\n\n    def readbits(self, n):\n        v = 0\n        while n > 0:\n            v = (v << 1) | self._readbit()\n            n -= 1\n        return v\n\nif __name__ == '__main__':\n    import os\n    import sys\n    \n    module_name = os.path.splitext(os.path.basename(__file__))[0]\n    bitio = __import__(module_name)\n\n    with open('bitio_test.dat', 'wb') as outfile:\n        with bitio.BitWriter(outfile) as writer:\n            chars = '12345abcde'\n            for ch in chars:\n                writer.writebits(ord(ch), 7)\n\n    with open('bitio_test.dat', 'rb') as infile:\n        with bitio.BitReader(infile) as reader:\n            chars = []\n            while True:\n                x = reader.readbits(7)\n                if not reader.read:  \n                    break\n                chars.append(chr(x))\n            print(''.join(chars))\n"}
{"id": 162624, "name": "Narcissist", "source": "Translate Ruby to C#: s = \"s = %s%s%s; puts(gets.chomp == (s\u00a0%% [34.chr, s, 34.chr])\u00a0? 'accept'\u00a0: 'reject')\"; puts(gets.chomp == (s % [34.chr, s, 34.chr]) ? 'accept' : 'reject')\n", "target": "using System;\nusing System.IO;\nusing System.Text;\nusing System.Text.RegularExpressions;\nnamespace Narcisisst\n{\n\tclass Program\n\t{\n\t\tpublic static void Main(string[] args)\n\t\t{\n\t\t\tconst string path = @\"E:\\Narcisisst\";\n\t\t\tstring[] thisFile = Directory.GetFiles(path , \"Program.cs\");\n\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\t\n\t\t\t\tforeach (string readLine in File.ReadLines(thisFile[0]))\n\t\t\t\t{\n\t\t\t\t\tsb.Append(readLine);\n\t\t\t\t\tsb.Append(\"\\n\");\n\t\t\t\t}\n\t\t\t\t\n\t\t\tConsole.WriteLine(sb);\n\t\t\tstring input =String.Empty;\n\t\t\t       \tinput = Console.ReadLine();\n\t\t\t       \tConsole.WriteLine((Regex.IsMatch(sb.ToString(),input))?\"accept\":\"reject\");\n\t\t\t       \tConsole.ReadKey();\n\t\t\t }\n\t}\n}\n"}
{"id": 162625, "name": "Narcissist", "source": "Translate Ruby to Java: s = \"s = %s%s%s; puts(gets.chomp == (s\u00a0%% [34.chr, s, 34.chr])\u00a0? 'accept'\u00a0: 'reject')\"; puts(gets.chomp == (s % [34.chr, s, 34.chr]) ? 'accept' : 'reject')\n", "target": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\n\npublic class Narcissist {\n    private static final String SOURCE = \"import java.io.BufferedReader;%nimport java.io.IOException;%nimport java.io.InputStreamReader;%n%npublic class Narcissist {%n    private static final String SOURCE = %c%s%c;%n    private static final char QUOTE = 0x22;%n%n    public static void main(String[] args) throws IOException {%n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));%n        StringBuilder sb = new StringBuilder();%n%n        while (true) {%n            String line = br.readLine();%n            if (null == line) break;%n            sb.append(line).append(System.lineSeparator());%n        }%n%n        String program = String.format(SOURCE, QUOTE, SOURCE, QUOTE, QUOTE, QUOTE, QUOTE, QUOTE);%n        if (program.equals(sb.toString())) {%n            System.out.println(%caccept%c);%n        } else {%n            System.out.println(%creject%c);%n        }%n    }%n}%n\";\n    private static final char QUOTE = 0x22;\n\n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        StringBuilder sb = new StringBuilder();\n\n        while (true) {\n            String line = br.readLine();\n            if (null == line) break;\n            sb.append(line).append(System.lineSeparator());\n        }\n\n        String program = String.format(SOURCE, QUOTE, SOURCE, QUOTE, QUOTE, QUOTE, QUOTE, QUOTE);\n        if (program.equals(sb.toString())) {\n            System.out.println(\"accept\");\n        } else {\n            System.out.println(\"reject\");\n        }\n    }\n}\n"}
{"id": 162626, "name": "Narcissist", "source": "Translate Ruby to Python: s = \"s = %s%s%s; puts(gets.chomp == (s\u00a0%% [34.chr, s, 34.chr])\u00a0? 'accept'\u00a0: 'reject')\"; puts(gets.chomp == (s % [34.chr, s, 34.chr]) ? 'accept' : 'reject')\n", "target": "import sys\nwith open(sys.argv[0]) as quine:\n    code = raw_input(\"Enter source code: \")\n    if code == quine.read():\n        print(\"Accept\")\n    else:\n        print(\"Reject\")\n"}
{"id": 162799, "name": "Modular inverse", "source": "Translate Ruby to C#: def modinv(a0, m0)\n  return 1 if m0 == 1\n  a, m = a0, m0\n  x0, inv = 0, 1\n  while a > 1\n    inv -= (a // m) * x0\n    a, m = m, a % m\n    x0, inv = inv, x0\n  end\n  inv += m0 if inv < 0\n  inv\nend\n", "target": "public class Program\n{\n    static void Main()\n    {\n        System.Console.WriteLine(42.ModInverse(2017));\n    }\n}\n\npublic static class IntExtensions\n{\n    public static int ModInverse(this int a, int m)\n    {\n        if (m == 1) return 0;\n        int m0 = m;\n        (int x, int y) = (1, 0);\n\n        while (a > 1) {\n            int q = a / m;\n            (a, m) = (m, a % m);\n            (x, y) = (y, x - q * y);\n        }\n        return x < 0 ? x + m0 : x;\n    }\n}\n"}
{"id": 162801, "name": "Modular inverse", "source": "Translate Ruby to Java: def modinv(a0, m0)\n  return 1 if m0 == 1\n  a, m = a0, m0\n  x0, inv = 0, 1\n  while a > 1\n    inv -= (a // m) * x0\n    a, m = m, a % m\n    x0, inv = inv, x0\n  end\n  inv += m0 if inv < 0\n  inv\nend\n", "target": "System.out.println(BigInteger.valueOf(42).modInverse(BigInteger.valueOf(2017)));\n"}
{"id": 162802, "name": "Modular inverse", "source": "Translate Ruby to Python: def modinv(a0, m0)\n  return 1 if m0 == 1\n  a, m = a0, m0\n  x0, inv = 0, 1\n  while a > 1\n    inv -= (a // m) * x0\n    a, m = m, a % m\n    x0, inv = inv, x0\n  end\n  inv += m0 if inv < 0\n  inv\nend\n", "target": ">>> def extended_gcd(aa, bb):\n    lastremainder, remainder = abs(aa), abs(bb)\n    x, lastx, y, lasty = 0, 1, 1, 0\n    while remainder:\n        lastremainder, (quotient, remainder) = remainder, divmod(lastremainder, remainder)\n        x, lastx = lastx - quotient*x, x\n        y, lasty = lasty - quotient*y, y\n    return lastremainder, lastx * (-1 if aa < 0 else 1), lasty * (-1 if bb < 0 else 1)\n\n>>> def modinv(a, m):\n\tg, x, y = extended_gcd(a, m)\n\tif g != 1:\n\t\traise ValueError\n\treturn x % m\n\n>>> modinv(42, 2017)\n1969\n>>>\n"}
{"id": 163117, "name": "UTF-8 encode and decode", "source": "Translate Ruby to C#: character_arr = [\"A\",\"\u00f6\",\"\u0416\",\"\u20ac\",\"\ud834\udd1e\"]\nfor c in character_arr do\n    puts \"Character: \" + c.encode(\"utf-8\")\n    puts \"Code-Point: \n    puts \"Code-Units: \" + c.each_byte.map { |n| '%02X ' % (n & 0xFF) }.join\n    puts \"\"\nend\n", "target": "using System;\nusing System.Text;\n\nnamespace Rosetta\n{\n    class Program\n    {\n        static byte[] MyEncoder(int codepoint) => Encoding.UTF8.GetBytes(char.ConvertFromUtf32(codepoint));\n        static string MyDecoder(byte[] utf8bytes) => Encoding.UTF8.GetString(utf8bytes);\n        static void Main(string[] args)\n        {\n            Console.OutputEncoding = Encoding.UTF8;  \n            foreach (int unicodePoint in new int[] {  0x0041, 0x00F6, 0x0416, 0x20AC, 0x1D11E})\n            {\n                byte[] asUtf8bytes = MyEncoder(unicodePoint);\n                string theCharacter = MyDecoder(asUtf8bytes);\n                Console.WriteLine(\"{0,8} {1,5}     {2,-15}\", unicodePoint.ToString(\"X4\"), theCharacter, BitConverter.ToString(asUtf8bytes));\n            }\n        }\n    }\n}\n\n"}
{"id": 163118, "name": "UTF-8 encode and decode", "source": "Translate Ruby to Java: character_arr = [\"A\",\"\u00f6\",\"\u0416\",\"\u20ac\",\"\ud834\udd1e\"]\nfor c in character_arr do\n    puts \"Character: \" + c.encode(\"utf-8\")\n    puts \"Code-Point: \n    puts \"Code-Units: \" + c.each_byte.map { |n| '%02X ' % (n & 0xFF) }.join\n    puts \"\"\nend\n", "target": "import java.nio.charset.StandardCharsets;\nimport java.util.Formatter;\n\npublic class UTF8EncodeDecode {\n\n    public static byte[] utf8encode(int codepoint) {\n        return new String(new int[]{codepoint}, 0, 1).getBytes(StandardCharsets.UTF_8);\n    }\n\n    public static int utf8decode(byte[] bytes) {\n        return new String(bytes, StandardCharsets.UTF_8).codePointAt(0);\n    }\n\n    public static void main(String[] args) {\n        System.out.printf(\"%-7s\u00a0%-43s %7s\\t%s\\t%7s%n\",\n                \"Char\", \"Name\", \"Unicode\", \"UTF-8 encoded\", \"Decoded\");\n\n        for (int codepoint : new int[]{0x0041, 0x00F6, 0x0416, 0x20AC, 0x1D11E}) {\n            byte[] encoded = utf8encode(codepoint);\n            Formatter formatter = new Formatter();\n            for (byte b : encoded) {\n                formatter.format(\"%02X \", b);\n            }\n            String encodedHex = formatter.toString();\n            int decoded = utf8decode(encoded);\n            System.out.printf(\"%-7c\u00a0%-43s U+%04X\\t%-12s\\tU+%04X%n\",\n                    codepoint, Character.getName(codepoint), codepoint, encodedHex, decoded);\n        }\n    }\n}\n"}
{"id": 163119, "name": "UTF-8 encode and decode", "source": "Translate Ruby to Python: character_arr = [\"A\",\"\u00f6\",\"\u0416\",\"\u20ac\",\"\ud834\udd1e\"]\nfor c in character_arr do\n    puts \"Character: \" + c.encode(\"utf-8\")\n    puts \"Code-Point: \n    puts \"Code-Units: \" + c.each_byte.map { |n| '%02X ' % (n & 0xFF) }.join\n    puts \"\"\nend\n", "target": "\nfrom unicodedata import name\n\n\ndef unicode_code(ch):\n    return 'U+{:04x}'.format(ord(ch))\n\n\ndef utf8hex(ch):\n    return \" \".join([hex(c)[2:] for c in ch.encode('utf8')]).upper()\n\n\nif __name__ == \"__main__\":\n    print('{:<11} {:<36} {:<15} {:<15}'.format('Character', 'Name', 'Unicode', 'UTF-8 encoding (hex)'))\n    chars = ['A', '\u00f6', '\u0416', '\u20ac', '\ud834\udd1e']\n    for char in chars:\n        print('{:<11} {:<36} {:<15} {:<15}'.format(char, name(char), unicode_code(char), utf8hex(char)))\n"}
{"id": 163250, "name": "Parsing_RPN to infix conversion", "source": "Translate Ruby to C#: rpn = RPNExpression.new(\"3 4 2 * 1 5 - 2 3 ^ ^ / +\")\ninfix = rpn.to_infix\nruby = rpn.to_ruby\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text.RegularExpressions;\n\nnamespace PostfixToInfix\n{\n    class Program\n    {\n        class Operator\n        {\n            public Operator(char t, int p, bool i = false)\n            {\n                Token = t;\n                Precedence = p;\n                IsRightAssociative = i;\n            }\n\n            public char Token { get; private set; }\n            public int Precedence { get; private set; }\n            public bool IsRightAssociative { get; private set; }\n        }\n\n        static IReadOnlyDictionary<char, Operator> operators = new Dictionary<char, Operator>\n        {\n            { '+', new Operator('+', 2) },\n            { '-', new Operator('-', 2) },\n            { '/', new Operator('/', 3) },\n            { '*', new Operator('*', 3) },\n            { '^', new Operator('^', 4, true) }\n        };\n\n        class Expression\n        {\n            public String ex;\n            public Operator op;\n\n            public Expression(String e)\n            {\n                ex = e;\n            }\n\n            public Expression(String e1, String e2, Operator o)\n            {\n                ex = String.Format(\"{0} {1} {2}\", e1, o.Token, e2);\n                op = o;\n            }\n        }\n\n        static String PostfixToInfix(String postfix)\n        {\n            var stack = new Stack<Expression>();\n\n            foreach (var token in Regex.Split(postfix, @\"\\s+\"))\n            {\n                char c = token[0];\n\n                var op = operators.FirstOrDefault(kv => kv.Key == c).Value;\n                if (op != null && token.Length == 1)\n                {\n                    Expression rhs = stack.Pop();\n                    Expression lhs = stack.Pop();\n\n                    int opPrec = op.Precedence;\n\n                    int lhsPrec = lhs.op != null ? lhs.op.Precedence : int.MaxValue;\n                    int rhsPrec = rhs.op != null ? rhs.op.Precedence : int.MaxValue;\n\n                    if ((lhsPrec < opPrec || (lhsPrec == opPrec && c == '^')))\n                        lhs.ex = '(' + lhs.ex + ')';\n\n                    if ((rhsPrec < opPrec || (rhsPrec == opPrec && c != '^')))\n                        rhs.ex = '(' + rhs.ex + ')';\n\n                    stack.Push(new Expression(lhs.ex, rhs.ex, op));\n                }\n                else\n                {\n                    stack.Push(new Expression(token));\n                }\n\n                \n                Console.WriteLine(\"{0} -> [{1}]\", token,\n                    string.Join(\", \", stack.Reverse().Select(e => e.ex)));\n            }\n            return stack.Peek().ex;\n        }\n\n        static void Main(string[] args)\n        {\n            string[] inputs = { \"3 4 2 * 1 5 - 2 3 ^ ^ / +\", \"1 2 + 3 4 + ^ 5 6 + ^\" };\n            foreach (var e in inputs)\n            {\n                Console.WriteLine(\"Postfix\u00a0: {0}\", e);\n                Console.WriteLine(\"Infix\u00a0: {0}\", PostfixToInfix(e));\n                Console.WriteLine(); ;\n            }\n            Console.ReadLine();\n        }\n    }\n}\n"}
{"id": 163252, "name": "Parsing_RPN to infix conversion", "source": "Translate Ruby to Java: rpn = RPNExpression.new(\"3 4 2 * 1 5 - 2 3 ^ ^ / +\")\ninfix = rpn.to_infix\nruby = rpn.to_ruby\n", "target": "import java.util.Stack;\n\npublic class PostfixToInfix {\n\n    public static void main(String[] args) {\n        for (String e : new String[]{\"3 4 2 * 1 5 - 2 3 ^ ^ / +\",\n            \"1 2 + 3 4 + ^ 5 6 + ^\"}) {\n            System.out.printf(\"Postfix\u00a0: %s%n\", e);\n            System.out.printf(\"Infix\u00a0: %s%n\", postfixToInfix(e));\n            System.out.println();\n        }\n    }\n\n    static String postfixToInfix(final String postfix) {\n\n        class Expression {\n            final static String ops = \"-+/*^\";\n\n            String op, ex;\n            int prec = 3;\n\n            Expression(String e) {\n                ex = e;\n            }\n\n            Expression(String e1, String e2, String o) {\n                ex = String.format(\"%s %s %s\", e1, o, e2);\n                op = o;\n                prec = ops.indexOf(o) / 2;\n            }\n\n            @Override\n            public String toString() {\n                return ex;\n            }\n        }\n\n        Stack<Expression> expr = new Stack<>();\n\n        for (String token : postfix.split(\"\\\\s+\")) {\n            char c = token.charAt(0);\n            int idx = Expression.ops.indexOf(c);\n            if (idx != -1 && token.length() == 1) {\n\n                Expression r = expr.pop();\n                Expression l = expr.pop();\n\n                int opPrec = idx / 2;\n\n                if (l.prec < opPrec || (l.prec == opPrec && c == '^'))\n                    l.ex = '(' + l.ex + ')';\n\n                if (r.prec < opPrec || (r.prec == opPrec && c != '^'))\n                    r.ex = '(' + r.ex + ')';\n\n                expr.push(new Expression(l.ex, r.ex, token));\n            } else {\n                expr.push(new Expression(token));\n            }\n            System.out.printf(\"%s -> %s%n\", token, expr);\n        }\n        return expr.peek().ex;\n    }\n}\n"}
{"id": 163253, "name": "Parsing_RPN to infix conversion", "source": "Translate Ruby to Python: rpn = RPNExpression.new(\"3 4 2 * 1 5 - 2 3 ^ ^ / +\")\ninfix = rpn.to_infix\nruby = rpn.to_ruby\n", "target": " \n\n\nprec_dict =  {'^':4, '*':3, '/':3, '+':2, '-':2}\nassoc_dict = {'^':1, '*':0, '/':0, '+':0, '-':0}\n \nclass Node:\n    def __init__(self,x,op,y=None):\n        self.precedence = prec_dict[op]\n        self.assocright = assoc_dict[op]\n        self.op = op\n        self.x,self.y = x,y\n \n    def __str__(self):\n        \n        \n        if self.y == None:\n            return '%s(%s)'%(self.op,str(self.x))\n \n        \n        str_y = str(self.y)\n        if  self.y < self or \\\n            (self.y == self and self.assocright) or \\\n            (str_y[0] is '-' and self.assocright):\n \n            str_y = '(%s)'%str_y\n        \n        str_x = str(self.x)\n        str_op = self.op\n        if self.op is '+' and not isinstance(self.x, Node) and str_x[0] is '-':\n            str_x = str_x[1:]\n            str_op = '-'\n        elif self.op is '-' and not isinstance(self.x, Node) and str_x[0] is '-':\n            str_x = str_x[1:]\n            str_op = '+'\n        elif self.x < self or \\\n             (self.x == self and not self.assocright and \\\n              getattr(self.x, 'op', 1) != getattr(self, 'op', 2)):\n \n            str_x = '(%s)'%str_x\n        return ' '.join([str_y, str_op, str_x])\n \n    def __repr__(self):\n        \n        return 'Node(%s,%s,%s)'%(repr(self.x), repr(self.op), repr(self.y))\n \n    def __lt__(self, other):\n        if isinstance(other, Node):\n            return self.precedence < other.precedence\n        return self.precedence < prec_dict.get(other,9)\n \n    def __gt__(self, other):\n        if isinstance(other, Node):\n            return self.precedence > other.precedence\n        return self.precedence > prec_dict.get(other,9)\n\n    def __eq__(self, other):\n        if isinstance(other, Node):\n            return self.precedence == other.precedence\n        return self.precedence > prec_dict.get(other,9)\n \n \n \ndef rpn_to_infix(s, VERBOSE=False):\n    \n    if VERBOSE : print('TOKEN  STACK')\n \n    stack=[]\n    for token in s.replace('^','^').split():\n        if token in prec_dict:\n            stack.append(Node(stack.pop(),token,stack.pop()))\n        else:\n            stack.append(token)\n \n        \n        if VERBOSE : print(token+' '*(7-len(token))+repr(stack)) \n \n    return str(stack[0])\n  \nstrTest = \"3 4 2 * 1 5 - 2 3 ^ ^ / +\"\nstrResult = rpn_to_infix(strTest, VERBOSE=False)\nprint (\"Input: \",strTest)\nprint (\"Output:\",strResult)\n\nprint()\n\nstrTest = \"1 2 + 3 4 + ^ 5 6 + ^\"\nstrResult = rpn_to_infix(strTest, VERBOSE=False)\nprint (\"Input: \",strTest)\nprint (\"Output:\",strResult)\n"}
{"id": 163383, "name": "Display a linear combination", "source": "Translate Ruby to C#: def linearCombo(c)\n    sb = \"\"\n    c.each_with_index { |n, i|\n        if n == 0 then\n            next\n        end\n        if n < 0 then\n            if sb.length == 0 then\n                op = \"-\"\n            else\n                op = \" - \"\n            end\n        elsif n > 0 then\n            if sb.length > 0 then\n                op = \" + \"\n            else\n                op = \"\"\n            end\n        else\n            op = \"\"\n        end\n        av = n.abs()\n        if av != 1 then\n            coeff = \"%d*\" % [av]\n        else\n            coeff = \"\"\n        end\n        sb = sb + \"%s%se(%d)\" % [op, coeff, i + 1]\n    }\n    if sb.length == 0 then\n        return \"0\"\n    end\n    return sb\nend\n\ndef main\n    combos = [\n        [1, 2, 3],\n        [0, 1, 2, 3],\n        [1, 0, 3, 4],\n        [1, 2, 0],\n        [0, 0, 0],\n        [0],\n        [1, 1, 1],\n        [-1, -1, -1],\n        [-1, -2, 0, -3],\n        [-1],\n    ]\n\n    for c in combos do\n        print \"%-15s  ->  %s\\n\" % [c, linearCombo(c)]\n    end\nend\n\nmain()\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Text;\n\nnamespace DisplayLinearCombination {\n    class Program {\n        static string LinearCombo(List<int> c) {\n            StringBuilder sb = new StringBuilder();\n            for (int i = 0; i < c.Count; i++) {\n                int n = c[i];\n                if (n < 0) {\n                    if (sb.Length == 0) {\n                        sb.Append('-');\n                    } else {\n                        sb.Append(\" - \");\n                    }\n                } else if (n > 0) {\n                    if (sb.Length != 0) {\n                        sb.Append(\" + \");\n                    }\n                } else {\n                    continue;\n                }\n\n                int av = Math.Abs(n);\n                if (av != 1) {\n                    sb.AppendFormat(\"{0}*\", av);\n                }\n                sb.AppendFormat(\"e({0})\", i + 1);\n            }\n            if (sb.Length == 0) {\n                sb.Append('0');\n            }\n            return sb.ToString();\n        }\n\n        static void Main(string[] args) {\n            List<List<int>> combos = new List<List<int>>{\n                new List<int> { 1, 2, 3},\n                new List<int> { 0, 1, 2, 3},\n                new List<int> { 1, 0, 3, 4},\n                new List<int> { 1, 2, 0},\n                new List<int> { 0, 0, 0},\n                new List<int> { 0},\n                new List<int> { 1, 1, 1},\n                new List<int> { -1, -1, -1},\n                new List<int> { -1, -2, 0, -3},\n                new List<int> { -1},\n            };\n\n            foreach (List<int> c in combos) {\n                var arr = \"[\" + string.Join(\", \", c) + \"]\";\n                Console.WriteLine(\"{0,15} -> {1}\", arr, LinearCombo(c));\n            }\n        }\n    }\n}\n"}
{"id": 163385, "name": "Display a linear combination", "source": "Translate Ruby to Java: def linearCombo(c)\n    sb = \"\"\n    c.each_with_index { |n, i|\n        if n == 0 then\n            next\n        end\n        if n < 0 then\n            if sb.length == 0 then\n                op = \"-\"\n            else\n                op = \" - \"\n            end\n        elsif n > 0 then\n            if sb.length > 0 then\n                op = \" + \"\n            else\n                op = \"\"\n            end\n        else\n            op = \"\"\n        end\n        av = n.abs()\n        if av != 1 then\n            coeff = \"%d*\" % [av]\n        else\n            coeff = \"\"\n        end\n        sb = sb + \"%s%se(%d)\" % [op, coeff, i + 1]\n    }\n    if sb.length == 0 then\n        return \"0\"\n    end\n    return sb\nend\n\ndef main\n    combos = [\n        [1, 2, 3],\n        [0, 1, 2, 3],\n        [1, 0, 3, 4],\n        [1, 2, 0],\n        [0, 0, 0],\n        [0],\n        [1, 1, 1],\n        [-1, -1, -1],\n        [-1, -2, 0, -3],\n        [-1],\n    ]\n\n    for c in combos do\n        print \"%-15s  ->  %s\\n\" % [c, linearCombo(c)]\n    end\nend\n\nmain()\n", "target": "import java.util.Arrays;\n\npublic class LinearCombination {\n    private static String linearCombo(int[] c) {\n        StringBuilder sb = new StringBuilder();\n        for (int i = 0; i < c.length; ++i) {\n            if (c[i] == 0) continue;\n            String op;\n            if (c[i] < 0 && sb.length() == 0) {\n                op = \"-\";\n            } else if (c[i] < 0) {\n                op = \" - \";\n            } else if (c[i] > 0 && sb.length() == 0) {\n                op = \"\";\n            } else {\n                op = \" + \";\n            }\n            int av = Math.abs(c[i]);\n            String coeff = av == 1 ? \"\" : \"\" + av + \"*\";\n            sb.append(op).append(coeff).append(\"e(\").append(i + 1).append(')');\n        }\n        if (sb.length() == 0) {\n            return \"0\";\n        }\n        return sb.toString();\n    }\n\n    public static void main(String[] args) {\n        int[][] combos = new int[][]{\n            new int[]{1, 2, 3},\n            new int[]{0, 1, 2, 3},\n            new int[]{1, 0, 3, 4},\n            new int[]{1, 2, 0},\n            new int[]{0, 0, 0},\n            new int[]{0},\n            new int[]{1, 1, 1},\n            new int[]{-1, -1, -1},\n            new int[]{-1, -2, 0, -3},\n            new int[]{-1},\n        };\n        for (int[] c : combos) {\n            System.out.printf(\"%-15s  ->  %s\\n\", Arrays.toString(c), linearCombo(c));\n        }\n    }\n}\n"}
{"id": 163386, "name": "Display a linear combination", "source": "Translate Ruby to Python: def linearCombo(c)\n    sb = \"\"\n    c.each_with_index { |n, i|\n        if n == 0 then\n            next\n        end\n        if n < 0 then\n            if sb.length == 0 then\n                op = \"-\"\n            else\n                op = \" - \"\n            end\n        elsif n > 0 then\n            if sb.length > 0 then\n                op = \" + \"\n            else\n                op = \"\"\n            end\n        else\n            op = \"\"\n        end\n        av = n.abs()\n        if av != 1 then\n            coeff = \"%d*\" % [av]\n        else\n            coeff = \"\"\n        end\n        sb = sb + \"%s%se(%d)\" % [op, coeff, i + 1]\n    }\n    if sb.length == 0 then\n        return \"0\"\n    end\n    return sb\nend\n\ndef main\n    combos = [\n        [1, 2, 3],\n        [0, 1, 2, 3],\n        [1, 0, 3, 4],\n        [1, 2, 0],\n        [0, 0, 0],\n        [0],\n        [1, 1, 1],\n        [-1, -1, -1],\n        [-1, -2, 0, -3],\n        [-1],\n    ]\n\n    for c in combos do\n        print \"%-15s  ->  %s\\n\" % [c, linearCombo(c)]\n    end\nend\n\nmain()\n", "target": "def linear(x):\n    return ' + '.join(['{}e({})'.format('-' if v == -1 else '' if v == 1 else str(v) + '*', i + 1)\n        for i, v in enumerate(x) if v] or ['0']).replace(' + -', ' - ')\n\nlist(map(lambda x: print(linear(x)), [[1, 2, 3], [0, 1, 2, 3], [1, 0, 3, 4], [1, 2, 0],\n        [0, 0, 0], [0], [1, 1, 1], [-1, -1, -1], [-1, -2, 0, 3], [-1]]))\n"}
{"id": 163563, "name": "Stern-Brocot sequence", "source": "Translate Ruby to C#: def sb\n  return enum_for :sb unless block_given?\n  a=[1,1]\n  0.step do |i|\n    yield a[i]\n    a << a[i]+a[i+1] << a[i+1]\n  end\nend\n\nputs \"First 15: \n\n[*1..10,100].each do |n| \n  puts \"\nend\n\nif sb.take(1000).each_cons(2).all? { |a,b| a.gcd(b) == 1 }\n  puts \"All GCD's are 1\"\nelse\n  puts \"Whoops, not all GCD's are 1!\"\nend\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\nstatic class Program {\n    static List<int> l = new List<int>() { 1, 1 };\n\n    static int gcd(int a, int b) {\n        return a > 0 ? a < b ? gcd(b % a, a) : gcd(a % b, b) : b; }\n\n    static void Main(string[] args) {\n        int max = 1000; int take = 15; int i = 1;\n        int[] selection = new[] { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 100 };\n        do { l.AddRange(new List<int>() { l[i] + l[i - 1], l[i] }); i += 1; }\n        while (l.Count < max || l[l.Count - 2] != selection.Last());\n        Console.Write(\"The first {0} items In the Stern-Brocot sequence: \", take);\n        Console.WriteLine(\"{0}\\n\", string.Join(\", \", l.Take(take)));\n        Console.WriteLine(\"The locations of where the selected numbers (1-to-10, & 100) first appear:\");\n        foreach (int ii in selection) {\n            int j = l.FindIndex(x => x == ii) + 1; Console.WriteLine(\"{0,3}: {1:n0}\", ii, j); }\n        Console.WriteLine(); bool good = true;\n        for (i = 1; i <= max; i++) { if (gcd(l[i], l[i - 1]) != 1) { good = false; break; } }\n        Console.WriteLine(\"The greatest common divisor of all the two consecutive items of the\" + \n                          \" series up to the {0}th item is {1}always one.\", max, good ? \"\" : \"not \");\n    }\n}\n"}
{"id": 163565, "name": "Stern-Brocot sequence", "source": "Translate Ruby to Java: def sb\n  return enum_for :sb unless block_given?\n  a=[1,1]\n  0.step do |i|\n    yield a[i]\n    a << a[i]+a[i+1] << a[i+1]\n  end\nend\n\nputs \"First 15: \n\n[*1..10,100].each do |n| \n  puts \"\nend\n\nif sb.take(1000).each_cons(2).all? { |a,b| a.gcd(b) == 1 }\n  puts \"All GCD's are 1\"\nelse\n  puts \"Whoops, not all GCD's are 1!\"\nend\n", "target": "import java.math.BigInteger;\nimport java.util.LinkedList;\n\npublic class SternBrocot {\n\tstatic LinkedList<Integer> sequence = new LinkedList<Integer>(){{\n\t\tadd(1); add(1);\n\t}};\n\t\n\tprivate static void genSeq(int n){\n\t\tfor(int conIdx = 1; sequence.size() < n; conIdx++){\n\t\t\tint consider = sequence.get(conIdx);\n\t\t\tint pre = sequence.get(conIdx - 1);\n\t\t\tsequence.add(consider + pre);\n\t\t\tsequence.add(consider);\n\t\t}\n\t\t\n\t}\n\t\n\tpublic static void main(String[] args){\n\t\tgenSeq(1200);\n\t\tSystem.out.println(\"The first 15 elements are: \" + sequence.subList(0, 15));\n\t\tfor(int i = 1; i <= 10; i++){\n\t\t\tSystem.out.println(\"First occurrence of \" + i + \" is at \" + (sequence.indexOf(i) + 1));\n\t\t}\n\t\t\n\t\tSystem.out.println(\"First occurrence of 100 is at \" + (sequence.indexOf(100) + 1));\n\t\t\n\t\tboolean failure = false;\n\t\tfor(int i = 0; i < 999; i++){\n\t\t\tfailure |= !BigInteger.valueOf(sequence.get(i)).gcd(BigInteger.valueOf(sequence.get(i + 1))).equals(BigInteger.ONE);\n\t\t}\n\t\tSystem.out.println(\"All GCDs are\" + (failure ? \" not\" : \"\") + \" 1\");\n\t}\n}\n"}
{"id": 163566, "name": "Stern-Brocot sequence", "source": "Translate Ruby to Python: def sb\n  return enum_for :sb unless block_given?\n  a=[1,1]\n  0.step do |i|\n    yield a[i]\n    a << a[i]+a[i+1] << a[i+1]\n  end\nend\n\nputs \"First 15: \n\n[*1..10,100].each do |n| \n  puts \"\nend\n\nif sb.take(1000).each_cons(2).all? { |a,b| a.gcd(b) == 1 }\n  puts \"All GCD's are 1\"\nelse\n  puts \"Whoops, not all GCD's are 1!\"\nend\n", "target": "def stern_brocot(predicate=lambda series: len(series) < 20):\n    \n\n    sb, i = [1, 1], 0\n    while predicate(sb):\n        sb += [sum(sb[i:i + 2]), sb[i + 1]]\n        i += 1\n    return sb\n\n\nif __name__ == '__main__':\n    from fractions import gcd\n\n    n_first = 15\n    print('The first %i values:\\n  ' % n_first,\n          stern_brocot(lambda series: len(series) < n_first)[:n_first])\n    print()\n    n_max = 10\n    for n_occur in list(range(1, n_max + 1)) + [100]:\n        print('1-based index of the first occurrence of %3i in the series:' % n_occur,\n              stern_brocot(lambda series: n_occur not in series).index(n_occur) + 1)\n              \n              \n\n    print()\n    n_gcd = 1000\n    s = stern_brocot(lambda series: len(series) < n_gcd)[:n_gcd]\n    assert all(gcd(prev, this) == 1\n               for prev, this in zip(s, s[1:])), 'A fraction from adjacent terms is reducible'\n"}
{"id": 163794, "name": "Temperature conversion", "source": "Translate Ruby to C#: module TempConvert\n\n  FROM_TEMP_SCALE_TO_K = \n  {'kelvin'     => lambda{|t| t},\n   'celsius'    => lambda{|t| t + 273.15},\n   'fahrenheit' => lambda{|t| (t + 459.67) * 5/9.0},\n   'rankine'    => lambda{|t| t * 5/9.0},\n   'delisle'    => lambda{|t| 373.15 - t * 2/3.0},\n   'newton'     => lambda{|t| t * 100/33.0 + 273.15},\n   'reaumur'    => lambda{|t| t * 5/4.0 + 273.15},\n   'roemer'     => lambda{|t| (t - 7.5) * 40/21.0 + 273.15}}\n\n  TO_TEMP_SCALE_FROM_K = \n  {'kelvin'     => lambda{|t| t},\n   'celsius'    => lambda{|t| t - 273.15},\n   'fahrenheit' => lambda{|t| t * 9/5.0 - 459.67},\n   'rankine'    => lambda{|t| t * 9/5.0},\n   'delisle'    => lambda{|t| (373.15 - t) * 3/2.0},\n   'newton'     => lambda{|t| (t - 273.15) * 33/100.0},\n   'reaumur'    => lambda{|t| (t - 273.15) * 4/5.0},\n   'roemer'     => lambda{|t| (t - 273.15) * 21/40.0 + 7.5}}\n  \n  SUPPORTED_SCALES = FROM_TEMP_SCALE_TO_K.keys.join('|')\n\n  def self.method_missing(meth, *args, &block)\n    if valid_temperature_conversion?(meth) then\n      convert_temperature(meth, *args)\n    else\n      super\n    end\n  end\n\n  def self.respond_to_missing?(meth, include_private = false)\n    valid_temperature_conversion?(meth) || super\n  end\n \n  def self.valid_temperature_conversion?(meth)\n    !!(meth.to_s =~ /(\n  end\n  \n  def self.convert_temperature(meth, temp)\n    from_scale, to_scale = meth.to_s.split(\"_to_\")\n    return temp.to_f if from_scale == to_scale \n    TO_TEMP_SCALE_FROM_K[to_scale].call(FROM_TEMP_SCALE_TO_K[from_scale].call(temp)).round(2)\n  end\n \nend\n", "target": "using System;\n\nnamespace TemperatureConversion\n{\n    class Program\n    {\n        static Func<double, double> ConvertKelvinToFahrenheit = x => (x * 1.8) - 459.67;\n        static Func<double, double> ConvertKelvinToRankine = x => x * 1.8;\n        static Func<double, double> ConvertKelvinToCelsius = x => x = 273.13;\n\n        static void Main(string[] args)\n        {\n            Console.Write(\"Enter a Kelvin Temperature: \");\n            string inputVal = Console.ReadLine();\n            double kelvinTemp = 0f;\n\n            if (double.TryParse(inputVal, out kelvinTemp))\n            {\n                Console.WriteLine(string.Format(\"Kelvin: {0}\", kelvinTemp));\n                Console.WriteLine(string.Format(\"Fahrenheit: {0}\", ConvertKelvinToFahrenheit(kelvinTemp)));\n                Console.WriteLine(string.Format(\"Rankine: {0}\", ConvertKelvinToRankine(kelvinTemp)));\n                Console.WriteLine(string.Format(\"Celsius: {0}\", ConvertKelvinToCelsius(kelvinTemp)));\n                Console.ReadKey();\n            }\n            else\n            {\n                Console.WriteLine(\"Invalid input value: \" + inputVal);\n            }\n        }\n    }\n}\n"}
{"id": 163796, "name": "Temperature conversion", "source": "Translate Ruby to Java: module TempConvert\n\n  FROM_TEMP_SCALE_TO_K = \n  {'kelvin'     => lambda{|t| t},\n   'celsius'    => lambda{|t| t + 273.15},\n   'fahrenheit' => lambda{|t| (t + 459.67) * 5/9.0},\n   'rankine'    => lambda{|t| t * 5/9.0},\n   'delisle'    => lambda{|t| 373.15 - t * 2/3.0},\n   'newton'     => lambda{|t| t * 100/33.0 + 273.15},\n   'reaumur'    => lambda{|t| t * 5/4.0 + 273.15},\n   'roemer'     => lambda{|t| (t - 7.5) * 40/21.0 + 273.15}}\n\n  TO_TEMP_SCALE_FROM_K = \n  {'kelvin'     => lambda{|t| t},\n   'celsius'    => lambda{|t| t - 273.15},\n   'fahrenheit' => lambda{|t| t * 9/5.0 - 459.67},\n   'rankine'    => lambda{|t| t * 9/5.0},\n   'delisle'    => lambda{|t| (373.15 - t) * 3/2.0},\n   'newton'     => lambda{|t| (t - 273.15) * 33/100.0},\n   'reaumur'    => lambda{|t| (t - 273.15) * 4/5.0},\n   'roemer'     => lambda{|t| (t - 273.15) * 21/40.0 + 7.5}}\n  \n  SUPPORTED_SCALES = FROM_TEMP_SCALE_TO_K.keys.join('|')\n\n  def self.method_missing(meth, *args, &block)\n    if valid_temperature_conversion?(meth) then\n      convert_temperature(meth, *args)\n    else\n      super\n    end\n  end\n\n  def self.respond_to_missing?(meth, include_private = false)\n    valid_temperature_conversion?(meth) || super\n  end\n \n  def self.valid_temperature_conversion?(meth)\n    !!(meth.to_s =~ /(\n  end\n  \n  def self.convert_temperature(meth, temp)\n    from_scale, to_scale = meth.to_s.split(\"_to_\")\n    return temp.to_f if from_scale == to_scale \n    TO_TEMP_SCALE_FROM_K[to_scale].call(FROM_TEMP_SCALE_TO_K[from_scale].call(temp)).round(2)\n  end\n \nend\n", "target": "public class TemperatureConversion {\n    public static void main(String args[]) {\n        if (args.length == 1) {\n            try {\n                double kelvin = Double.parseDouble(args[0]);\n                if (kelvin >= 0) {\n                    System.out.printf(\"K  %2.2f\\n\", kelvin);\n                    System.out.printf(\"C  %2.2f\\n\", kelvinToCelsius(kelvin));\n                    System.out.printf(\"F  %2.2f\\n\", kelvinToFahrenheit(kelvin));\n                    System.out.printf(\"R  %2.2f\\n\", kelvinToRankine(kelvin));\n                } else {\n                    System.out.printf(\"%2.2f K is below absolute zero\", kelvin);\n                }\n            } catch (NumberFormatException e) {\n                System.out.println(e);\n            }\n        }\n    }\n\n    public static double kelvinToCelsius(double k) {\n        return k - 273.15;\n    }\n\n    public static double kelvinToFahrenheit(double k) {\n        return k * 1.8 - 459.67;\n    }\n\n    public static double kelvinToRankine(double k) {\n        return k * 1.8;\n    }\n}\n"}
{"id": 163797, "name": "Temperature conversion", "source": "Translate Ruby to Python: module TempConvert\n\n  FROM_TEMP_SCALE_TO_K = \n  {'kelvin'     => lambda{|t| t},\n   'celsius'    => lambda{|t| t + 273.15},\n   'fahrenheit' => lambda{|t| (t + 459.67) * 5/9.0},\n   'rankine'    => lambda{|t| t * 5/9.0},\n   'delisle'    => lambda{|t| 373.15 - t * 2/3.0},\n   'newton'     => lambda{|t| t * 100/33.0 + 273.15},\n   'reaumur'    => lambda{|t| t * 5/4.0 + 273.15},\n   'roemer'     => lambda{|t| (t - 7.5) * 40/21.0 + 273.15}}\n\n  TO_TEMP_SCALE_FROM_K = \n  {'kelvin'     => lambda{|t| t},\n   'celsius'    => lambda{|t| t - 273.15},\n   'fahrenheit' => lambda{|t| t * 9/5.0 - 459.67},\n   'rankine'    => lambda{|t| t * 9/5.0},\n   'delisle'    => lambda{|t| (373.15 - t) * 3/2.0},\n   'newton'     => lambda{|t| (t - 273.15) * 33/100.0},\n   'reaumur'    => lambda{|t| (t - 273.15) * 4/5.0},\n   'roemer'     => lambda{|t| (t - 273.15) * 21/40.0 + 7.5}}\n  \n  SUPPORTED_SCALES = FROM_TEMP_SCALE_TO_K.keys.join('|')\n\n  def self.method_missing(meth, *args, &block)\n    if valid_temperature_conversion?(meth) then\n      convert_temperature(meth, *args)\n    else\n      super\n    end\n  end\n\n  def self.respond_to_missing?(meth, include_private = false)\n    valid_temperature_conversion?(meth) || super\n  end\n \n  def self.valid_temperature_conversion?(meth)\n    !!(meth.to_s =~ /(\n  end\n  \n  def self.convert_temperature(meth, temp)\n    from_scale, to_scale = meth.to_s.split(\"_to_\")\n    return temp.to_f if from_scale == to_scale \n    TO_TEMP_SCALE_FROM_K[to_scale].call(FROM_TEMP_SCALE_TO_K[from_scale].call(temp)).round(2)\n  end\n \nend\n", "target": ">>> while True:\n    k = float(input('K\u00a0? '))\n    print(\"%g Kelvin = %g Celsius = %g Fahrenheit = %g Rankine degrees.\"\n          % (k, k - 273.15, k * 1.8 - 459.67, k * 1.8))\n\n    \nK ? 21.0\n21 Kelvin = -252.15 Celsius = -421.87 Fahrenheit = 37.8 Rankine degrees.\nK ? 222.2\n222.2 Kelvin = -50.95 Celsius = -59.71 Fahrenheit = 399.96 Rankine degrees.\nK ?\n"}
{"id": 164003, "name": "Pig the dice game", "source": "Translate Ruby to C#: class PigGame\n  Player = Struct.new(:name, :safescore, :score) do\n    def bust!() self.score = safescore end\n    def stay!() self.safescore = score end\n    def to_s() \"\n  end\n  \n  def initialize(names, maxscore=100, die_sides=6)\n    rotation = names.map {|name| Player.new(name,0,0) }\n    \n    rotation.cycle do |player|\n      loop do\n        if wants_to_roll?(player)\n          puts \"Rolled: \n          if bust?(roll)\n            puts \"Busted!\",''\n            player.bust!\n            break\n          else\n            player.score += roll\n            if player.score >= maxscore\n              puts player.name + \" wins!\"\n              return\n            end\n          end\n        else\n          player.stay!\n          puts \"Staying with \n          break\n        end\n      end\n    end\n  end\n  \n  def roll_dice(die_sides) rand(1..die_sides) end\n  def bust?(roll) roll==1 end\n  def wants_to_roll?(player)\n    print \"\n    ['Y','y',''].include?(gets.chomp)\n  end\nend\n\nPigGame.new( %w|Samuel Elizabeth| )\n", "target": "using System;\nusing System.IO;\n\nnamespace Pig {\n\n\tclass Roll {\n\t\tpublic int TotalScore{get;set;}\n\t\tpublic int RollScore{get;set;}\n\t\tpublic bool Continue{get;set;}\n\t}\n\n\tclass Player {\n\t\tpublic String Name{get;set;}\n\t\tpublic int Score {get;set;}\n\t\tRandom rand;\n\n\t\tpublic Player() {\n\t\t\tScore = 0;\n\t\t\trand = new Random();\n\t\t}\n\n\t\tpublic Roll Roll(int LastScore){\n\t\t\tRoll roll = new Roll();\n\t\t\troll.RollScore = rand.Next(6) + 1;\n\n\t\t\tif(roll.RollScore == 1){\n\t\t\t\troll.TotalScore = 0;\n\t\t\t\troll.Continue = false;\n\t\t\t\treturn roll;\n\t\t\t}\n\n\t\t\troll.TotalScore = LastScore + roll.RollScore;\n\t\t\troll.Continue = true;\n\t\t\treturn roll;\n\t\t}\n\n\t\tpublic void FinalizeTurn(Roll roll){\n\t\t\tScore = Score + roll.TotalScore;\n\t\t}\n\t}\n\n\tpublic class Game {\t\t\n\t\tpublic static void Main(String[] argv){\n\t\t\tString input = null;\n\t\t\tPlayer[] players = new Player[2];\n\n\t\t\t\n\t\t\twhile(true){\t\t\t\t\t\t\t\t\n\t\t\t\tConsole.Write(\"Greetings! Would you like to play a game (y/n)?\");\n\t\t\t\twhile(input == null){\n\t\t\t\t\tinput = Console.ReadLine();\n\t\t\t\t\tif(input.ToLowerInvariant() == \"y\"){\n\t\t\t\t\t\tplayers[0] = new Player();\n\t\t\t\t\t\tplayers[1] = new Player();\n\t\t\t\t\t\tConsole.Write(\"Player One, what's your name?\");\n\t\t\t\t\t\tinput = Console.ReadLine();\n\t\t\t\t\t\tplayers[0].Name = input;\n\t\t\t\t\t\tConsole.Write(\"Player Two, what's your name?\");\n\t\t\t\t\t\tinput = Console.ReadLine();\n\t\t\t\t\t\tplayers[1].Name = input;\n\t\t\t\t\t\tConsole.WriteLine(players[0].Name + \" and \" + players[1].Name + \", prepare to do battle!\");\n\t\t\t\t\t} else if (input.ToLowerInvariant() == \"n\"){\n\t\t\t\t\t\tgoto Goodbye; \n\t\t\t\t\t} else {\n\t\t\t\t\t\tinput = null;\n\t\t\t\t\t\tConsole.Write(\"I'm sorry, I don't understand. Play a game (y/n)?\");\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t\n\t\t\t\tint currentPlayer = 0;\n\t\t\t\tRoll roll = null;\n\t\t\t\tbool runTurn = true;\n\t\t\t\twhile(runTurn){\n\t\t\t\t\tPlayer p = players[currentPlayer];\n\t\t\t\t\troll = p.Roll( (roll !=null) ? roll.TotalScore : 0 );\n\t\t\t\t\tif(roll.Continue){\n\t\t\t\t\t\tif(roll.TotalScore + p.Score > 99){\n\t\t\t\t\t\t\tConsole.WriteLine(\"Congratulations, \" + p.Name + \"! You rolled a \" + roll.RollScore + \" for a final score of \" + (roll.TotalScore + p.Score) + \"!\");\n\t\t\t\t\t\t\trunTurn = false;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tConsole.Write(p.Name + \": Roll \" + roll.RollScore + \"/Turn \" + roll.TotalScore + \"/Total \" + (roll.TotalScore + p.Score) + \". Roll again (y/n)?\");\n\t\t\t\t\t\t\tinput = Console.ReadLine();\n\t\t\t\t\t\t\tif(input.ToLowerInvariant() == \"y\"){\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t} else if (input.ToLowerInvariant() == \"n\"){\n\t\t\t\t\t\t\t\tp.FinalizeTurn(roll);\n\t\t\t\t\t\t\t\tcurrentPlayer = Math.Abs(currentPlayer - 1);\t\t\t\n\t\t\t\t\t\t\t\tConsole.WriteLine();\n\t\t\t\t\t\t\tConsole.WriteLine(players[0].Name + \": \" + players[0].Score + \"    \" + players[1].Name + \": \" + players[1].Score);\t\t\t\t\t\n\t\t\t\t\t\t\t\tConsole.WriteLine(players[currentPlayer].Name + \", your turn begins.\");\n\t\t\t\t\t\t\t\troll = null;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tinput = null;\n\t\t\t\t\t\t\t\tConsole.Write(\"I'm sorry, I don't understand. Play a game (y/n)?\");\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tConsole.WriteLine(p.Name + @\", you rolled a 1 and lost your points for this turn.\nYour current score:\t\" + p.Score);\n\t\t\t\t\t\tConsole.WriteLine();\n\t\t\t\t\t\tConsole.WriteLine(players[0].Name + \": \" + players[0].Score + \"    \" + players[1].Name + \": \" + players[1].Score);\n\t\t\t\t\t\tcurrentPlayer = Math.Abs(currentPlayer - 1);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\n\t\t\t\tinput = null;\n\t\t\t}\n\t\t\tGoodbye:\n\t\t\tConsole.WriteLine(\"Thanks for playing, and remember: the house ALWAYS wins!\");\n\t\t\tSystem.Environment.Exit(0);\n\t\t}\n\t}\n}\n"}
{"id": 164005, "name": "Pig the dice game", "source": "Translate Ruby to Java: class PigGame\n  Player = Struct.new(:name, :safescore, :score) do\n    def bust!() self.score = safescore end\n    def stay!() self.safescore = score end\n    def to_s() \"\n  end\n  \n  def initialize(names, maxscore=100, die_sides=6)\n    rotation = names.map {|name| Player.new(name,0,0) }\n    \n    rotation.cycle do |player|\n      loop do\n        if wants_to_roll?(player)\n          puts \"Rolled: \n          if bust?(roll)\n            puts \"Busted!\",''\n            player.bust!\n            break\n          else\n            player.score += roll\n            if player.score >= maxscore\n              puts player.name + \" wins!\"\n              return\n            end\n          end\n        else\n          player.stay!\n          puts \"Staying with \n          break\n        end\n      end\n    end\n  end\n  \n  def roll_dice(die_sides) rand(1..die_sides) end\n  def bust?(roll) roll==1 end\n  def wants_to_roll?(player)\n    print \"\n    ['Y','y',''].include?(gets.chomp)\n  end\nend\n\nPigGame.new( %w|Samuel Elizabeth| )\n", "target": "import java.util.*;\n\npublic class PigDice {\n\n    public static void main(String[] args) {\n        final int maxScore = 100;\n        final int playerCount = 2;\n        final String[] yesses = {\"y\", \"Y\", \"\"};\n\n        int[] safeScore = new int[2];\n        int player = 0, score = 0;\n\n        Scanner sc = new Scanner(System.in);\n        Random rnd = new Random();\n\n        while (true) {\n            System.out.printf(\" Player %d: (%d, %d) Rolling? (y/n) \", player,\n                    safeScore[player], score);\n            if (safeScore[player] + score < maxScore\n                    && Arrays.asList(yesses).contains(sc.nextLine())) {\n                final int rolled = rnd.nextInt(6) + 1;\n                System.out.printf(\" Rolled %d\\n\", rolled);\n                if (rolled == 1) {\n                    System.out.printf(\" Bust! You lose %d but keep %d\\n\\n\",\n                            score, safeScore[player]);\n                } else {\n                    score += rolled;\n                    continue;\n                }\n            } else {\n                safeScore[player] += score;\n                if (safeScore[player] >= maxScore)\n                    break;\n                System.out.printf(\" Sticking with %d\\n\\n\", safeScore[player]);\n            }\n            score = 0;\n            player = (player + 1) % playerCount;\n        }\n        System.out.printf(\"\\n\\nPlayer %d wins with a score of %d\",\n                player, safeScore[player]);\n    }\n}\n"}
{"id": 164006, "name": "Pig the dice game", "source": "Translate Ruby to Python: class PigGame\n  Player = Struct.new(:name, :safescore, :score) do\n    def bust!() self.score = safescore end\n    def stay!() self.safescore = score end\n    def to_s() \"\n  end\n  \n  def initialize(names, maxscore=100, die_sides=6)\n    rotation = names.map {|name| Player.new(name,0,0) }\n    \n    rotation.cycle do |player|\n      loop do\n        if wants_to_roll?(player)\n          puts \"Rolled: \n          if bust?(roll)\n            puts \"Busted!\",''\n            player.bust!\n            break\n          else\n            player.score += roll\n            if player.score >= maxscore\n              puts player.name + \" wins!\"\n              return\n            end\n          end\n        else\n          player.stay!\n          puts \"Staying with \n          break\n        end\n      end\n    end\n  end\n  \n  def roll_dice(die_sides) rand(1..die_sides) end\n  def bust?(roll) roll==1 end\n  def wants_to_roll?(player)\n    print \"\n    ['Y','y',''].include?(gets.chomp)\n  end\nend\n\nPigGame.new( %w|Samuel Elizabeth| )\n", "target": "\n\n\n\nfrom random import randint\n\nplayercount = 2\nmaxscore = 100\nsafescore = [0] * playercount\nplayer = 0\nscore=0\n\nwhile max(safescore) < maxscore:\n    rolling = input(\"Player %i: (%i, %i) Rolling? (Y) \"\n                    % (player, safescore[player], score)).strip().lower() in {'yes', 'y', ''}\n    if rolling:\n        rolled = randint(1, 6)\n        print('  Rolled %i' % rolled)\n        if rolled == 1:\n            print('  Bust! you lose %i but still keep your previous %i'\n                  % (score, safescore[player]))\n            score, player = 0, (player + 1) % playercount\n        else:\n            score += rolled\n    else:\n        safescore[player] += score\n        if safescore[player] >= maxscore:\n            break\n        print('  Sticking with %i' % safescore[player])\n        score, player = 0, (player + 1) % playercount\n        \nprint('\\nPlayer %i wins with a score of %i' %(player, safescore[player]))\n"}
{"id": 164245, "name": "Square but not cube", "source": "Translate Ruby to C#: \n\nclass PowIt\n\t:next\n\t\n\tdef initialize\n\t\t@next = 1;\n\tend\nend\n\nclass SquareIt < PowIt\n\tdef next\n\t\tresult = @next ** 2\n\t\t@next += 1\n\t\treturn result\n\tend\nend\n\nclass CubeIt < PowIt\n\tdef next\n\t\tresult = @next ** 3\n\t\t@next += 1\n\t\treturn result\n\tend\nend\n\nsquares = []\nhexponents = []\n\nsquit = SquareIt.new\ncuit = CubeIt.new\n\ns = squit.next\nc = cuit.next\n\nwhile (squares.length < 30 || hexponents.length < 3)\n\tif s < c\n\t\tsquares.push(s) if squares.length < 30\n\t\ts = squit.next\n\telsif s == c\n\t\thexponents.push(s) if hexponents.length < 3\n\t\ts = squit.next\n\t\tc = cuit.next\n\telse\n\t\tc = cuit.next\n\tend\nend\n\nputs \"Squares:\"\nputs squares.join(\" \")\n\nputs \"Square-and-cubes:\"\nputs hexponents.join(\" \")\n", "target": "using System;\nusing System.Collections.Generic;\nusing static System.Console;\nusing static System.Linq.Enumerable;\n\npublic static class SquareButNotCube\n{\n    public static void Main() {\n        var squares = from i in Integers() select i * i;\n        var cubes = from i in Integers() select i * i * i;\n\n        foreach (var x in Merge().Take(33)) {\n            WriteLine(x.isCube ? x.n + \" (also cube)\" : x.n + \"\");\n        }\n        \n        IEnumerable<int> Integers() {\n            for (int i = 1; ;i++) yield return i;\n        }\n\n        IEnumerable<(int n, bool isCube)> Merge() {\n            using (var s = squares.GetEnumerator())\n            using (var c = cubes.GetEnumerator()) {\n                s.MoveNext();\n                c.MoveNext();\n                while (true) {\n                    if (s.Current < c.Current) {\n                        yield return (s.Current, false);\n                        s.MoveNext();\n                    } else if (s.Current == c.Current) {\n                        yield return (s.Current, true);\n                        s.MoveNext();\n                        c.MoveNext();\n                    } else {\n                        c.MoveNext();\n                    }\n                }\n            }\n        }\n\n    }\n}\n"}
{"id": 164247, "name": "Square but not cube", "source": "Translate Ruby to Java: \n\nclass PowIt\n\t:next\n\t\n\tdef initialize\n\t\t@next = 1;\n\tend\nend\n\nclass SquareIt < PowIt\n\tdef next\n\t\tresult = @next ** 2\n\t\t@next += 1\n\t\treturn result\n\tend\nend\n\nclass CubeIt < PowIt\n\tdef next\n\t\tresult = @next ** 3\n\t\t@next += 1\n\t\treturn result\n\tend\nend\n\nsquares = []\nhexponents = []\n\nsquit = SquareIt.new\ncuit = CubeIt.new\n\ns = squit.next\nc = cuit.next\n\nwhile (squares.length < 30 || hexponents.length < 3)\n\tif s < c\n\t\tsquares.push(s) if squares.length < 30\n\t\ts = squit.next\n\telsif s == c\n\t\thexponents.push(s) if hexponents.length < 3\n\t\ts = squit.next\n\t\tc = cuit.next\n\telse\n\t\tc = cuit.next\n\tend\nend\n\nputs \"Squares:\"\nputs squares.join(\" \")\n\nputs \"Square-and-cubes:\"\nputs hexponents.join(\" \")\n", "target": "public class SquaresCubes {\n    public static boolean isPerfectCube(long n) {\n        long c = (long)Math.cbrt((double)n);\n        return ((c * c * c) == n);\n    }\n    \n    public static void main(String... args) {\n        long n = 1;\n        int squareOnlyCount = 0;\n        int squareCubeCount = 0;\n        while ((squareOnlyCount < 30) || (squareCubeCount < 3)) {\n            long sq = n * n;\n            if (isPerfectCube(sq)) {\n                squareCubeCount++;\n                System.out.println(\"Square and cube: \" + sq);\n            }\n            else {\n                squareOnlyCount++;\n                System.out.println(\"Square: \" + sq);\n            }\n            n++;\n        }\n    }\n}\n"}
{"id": 164248, "name": "Square but not cube", "source": "Translate Ruby to Python: \n\nclass PowIt\n\t:next\n\t\n\tdef initialize\n\t\t@next = 1;\n\tend\nend\n\nclass SquareIt < PowIt\n\tdef next\n\t\tresult = @next ** 2\n\t\t@next += 1\n\t\treturn result\n\tend\nend\n\nclass CubeIt < PowIt\n\tdef next\n\t\tresult = @next ** 3\n\t\t@next += 1\n\t\treturn result\n\tend\nend\n\nsquares = []\nhexponents = []\n\nsquit = SquareIt.new\ncuit = CubeIt.new\n\ns = squit.next\nc = cuit.next\n\nwhile (squares.length < 30 || hexponents.length < 3)\n\tif s < c\n\t\tsquares.push(s) if squares.length < 30\n\t\ts = squit.next\n\telsif s == c\n\t\thexponents.push(s) if hexponents.length < 3\n\t\ts = squit.next\n\t\tc = cuit.next\n\telse\n\t\tc = cuit.next\n\tend\nend\n\nputs \"Squares:\"\nputs squares.join(\" \")\n\nputs \"Square-and-cubes:\"\nputs hexponents.join(\" \")\n", "target": "\ndef nonCubeSquares(n):\n    upto = enumFromTo(1)\n    ns = upto(n)\n    setCubes = set(x ** 3 for x in ns)\n    ms = upto(n + len(set(x * x for x in ns).intersection(\n        setCubes\n    )))\n    return list(tuple([x * x, x in setCubes]) for x in ms)\n\n\n\ndef squareListing(xs):\n    justifyIdx = justifyRight(len(str(1 + len(xs))))(' ')\n    justifySqr = justifyRight(1 + len(str(xs[-1][0])))(' ')\n    return list(\n        '(' + str(1 + idx) + '^2 = ' + str(n) +\n        ' = ' + str(round(n ** (1 / 3))) + '^3)' if bln else (\n            justifyIdx(1 + idx) + ' ->' +\n            justifySqr(n)\n        )\n        for idx, (n, bln) in enumerate(xs)\n    )\n\n\ndef main():\n    print(\n        unlines(\n            squareListing(\n                nonCubeSquares(30)\n            )\n        )\n    )\n\n\n\n\n\ndef enumFromTo(m):\n    return lambda n: list(range(m, 1 + n))\n\n\n\ndef justifyRight(n):\n    return lambda cFiller: lambda a: (\n        ((n * cFiller) + str(a))[-n:]\n    )\n\n\n\ndef unlines(xs):\n    return '\\n'.join(xs)\n\n\nmain()\n"}
{"id": 164432, "name": "Egyptian division", "source": "Translate Ruby to C#: def egyptian_divmod(dividend, divisor)\n  table = [[1, divisor]]\n  table << table.last.map{|e| e*2} while table.last.first * 2 <= dividend\n  answer, accumulator = 0, 0\n  table.reverse_each do |pow, double|\n    if accumulator + double <= dividend\n      accumulator += double\n      answer += pow\n    end\n  end\n  [answer, dividend - accumulator] \nend\n\nputs \"Quotient = %s Remainder = %s\" % egyptian_divmod(580, 34)\n", "target": "using System;\nusing System.Collections;\n\nnamespace Egyptian_division\n{\n\tclass Program\n\t{\n\t\tpublic static void Main(string[] args)\n\t\t{\n\t\t\tConsole.Clear();\n\t\t\tConsole.WriteLine();\n\t\t\tConsole.WriteLine(\" Egyptian division \");\n\t\t\tConsole.WriteLine();\n\t\t\tConsole.Write(\" Enter value of dividend\u00a0: \");\n\t\t\tint dividend = int.Parse(Console.ReadLine());\n\t\t\t     \n\t\t\tConsole.Write(\" Enter value of divisor\u00a0: \");\n\t\t\tint divisor = int.Parse(Console.ReadLine());\n\t\t\t                         \n\t\t\tDivide(dividend, divisor);\n\t\t\t\n\t\t\tConsole.WriteLine();\n\t\t\tConsole.Write(\"Press any key to continue . . . \");\n\t\t\tConsole.ReadKey(true);\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t}\n\t\t\n\t\tstatic void Divide(int dividend, int divisor)\n\t\t{\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t\tint result   = 0;\n\t\t\tint reminder = 0;\n\t\t\t\n\t\t\tint powers_of_two = 0;\n\t\t\tint doublings \t  = 0;\n\t\t\t\n\t\t\tint answer \t= 0;\n\t\t\tint accumulator = 0;\n\t\t\t\n\t\t\tint two = 2;\n\t\t\tint pow = 0;\n\t\t\tint row = 0;\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t\tArrayList table_powers_of_two = new ArrayList();\n\t\t\tArrayList table_doublings     = new ArrayList();\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t\tConsole.WriteLine(\"                           \");\n\t\t\tConsole.WriteLine(\" powers_of_2     doublings \");\n\t\t\tConsole.WriteLine(\"                           \");\n\t\t\t\n\t\t\t\n\t\t\tpowers_of_two = 1;\n\t\t\tdoublings = divisor;\n\t\t\twhile( doublings <= dividend )\n\t\t\t{\n\t\t\t\t\n\t\t\t\ttable_powers_of_two.Add( powers_of_two );\n\t\t\t\ttable_doublings.Add( doublings );\n\t\t\t\t\n\t\t\t\t\n\t\t\t\tConsole.WriteLine(\"{0,8}{1,16}\",powers_of_two, doublings);\n\t\t\t\t\n\t\t\t\t\n\t\t\t\tpow++;\n\t\t\t\t\n\t\t\t\tpowers_of_two = (int)Math.Pow( two, pow );\n\t\t\t\tdoublings = powers_of_two * divisor;\n\t\t\t}\n\t\t\tConsole.WriteLine(\"                           \");\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t\trow = pow - 1;\n\t\t\tConsole.WriteLine(\"                                                 \");\n\t\t\tConsole.WriteLine(\" powers_of_2     doublings   answer   accumulator\");\n\t\t\tConsole.WriteLine(\"                                                 \");\n\t\t\tConsole.SetCursorPosition(Console.CursorLeft, Console.CursorTop + row);\n\t\t\t\n\t\t\tpow--;\n\t\t\twhile( pow >= 0 && accumulator < dividend )\n\t\t\t{\n\t\t\t\t\n\t\t\t\tdoublings = int.Parse(table_doublings[pow].ToString());\n\t\t\t\tpowers_of_two = int.Parse(table_powers_of_two[pow].ToString());\n\t\t\t\t\n\t\t\t\tif(accumulator + int.Parse(table_doublings[pow].ToString()) <= dividend )\n\t\t\t\t{\n\t\t\t\t\t\n\t\t\t\t\taccumulator += doublings;\n\t\t\t\t\tanswer += powers_of_two;\n\t\t\t\t\t\n\t\t\t\t\t\n\t\t\t\t\tConsole.ForegroundColor = ConsoleColor.Green;\n\t\t\t\t\tConsole.Write(\"{0,8}{1,16}\",powers_of_two, doublings);\n\t\t\t\t\tConsole.ForegroundColor = ConsoleColor.Green;\n\t\t\t\t\tConsole.WriteLine(\"{0,10}{1,12}\", answer, accumulator);\n\t\t\t\t\tConsole.SetCursorPosition(Console.CursorLeft, Console.CursorTop - 2);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t\n\t\t\t\t\tConsole.ForegroundColor = ConsoleColor.DarkGray;\n\t\t\t\t\tConsole.Write(\"{0,8}{1,16}\",powers_of_two, doublings);\n\t\t\t\t\tConsole.ForegroundColor = ConsoleColor.Gray;\n\t\t\t\t\tConsole.WriteLine(\"{0,10}{1,12}\", answer, accumulator);\n\t\t\t\t\tConsole.SetCursorPosition(Console.CursorLeft, Console.CursorTop - 2);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t\n\t\t\t\tpow--;\n\t\t\t}\n\t\t\t\n\t\t\tConsole.WriteLine();\n\t\t\tConsole.SetCursorPosition(Console.CursorLeft, Console.CursorTop + row + 2);\n\t\t\tConsole.ResetColor();\n\t\t\t\n\t\t\t\n\t\t\tresult = answer;\n\t\t\tif( accumulator < dividend )\n\t\t\t{\n\t\t\t\treminder = dividend - accumulator;\n\t\t\t\t\n\t\t\t\tConsole.WriteLine(\" So \" + dividend +\n\t\t\t\t                  \" divided by \" + divisor +\n\t\t\t\t                  \" using the Egyptian method is \\n \" + result +\n\t\t\t\t                  \" remainder (\" + dividend + \" - \" + accumulator +\n\t\t\t\t                  \") or \" + reminder);\n\t\t\t\tConsole.WriteLine();\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\treminder = 0;\n\t\t\t\t\n\t\t\t\tConsole.WriteLine(\" So \" + dividend +\n\t\t\t\t                  \" divided by \" + divisor +\n\t\t\t\t                  \" using the Egyptian method is \\n \" + result +\n\t\t\t\t                  \" remainder \" + reminder);\n\t\t\t\tConsole.WriteLine();\n\t\t\t}\n\t\t}\n\t}\n}\n"}
{"id": 164434, "name": "Egyptian division", "source": "Translate Ruby to Java: def egyptian_divmod(dividend, divisor)\n  table = [[1, divisor]]\n  table << table.last.map{|e| e*2} while table.last.first * 2 <= dividend\n  answer, accumulator = 0, 0\n  table.reverse_each do |pow, double|\n    if accumulator + double <= dividend\n      accumulator += double\n      answer += pow\n    end\n  end\n  [answer, dividend - accumulator] \nend\n\nputs \"Quotient = %s Remainder = %s\" % egyptian_divmod(580, 34)\n", "target": "import java.util.ArrayList;\nimport java.util.List;\n\npublic class EgyptianDivision {\n\n    \n    public static void main(String[] args) {\n\n        divide(580, 34);\n\n    }\n\n    \n    public static void divide(int dividend, int divisor) {\n\n        List<Integer> powersOf2 = new ArrayList<>();\n        List<Integer> doublings = new ArrayList<>();\n\n        \n        int line = 0;\n        while ((Math.pow(2, line) * divisor) <= dividend) { \n            int powerOf2 = (int) Math.pow(2, line);\n            powersOf2.add(powerOf2);\n            doublings.add(powerOf2 * divisor);\n            line++;\n        }\n\n        int answer = 0;\n        int accumulator = 0;\n\n        \n        for (int i = powersOf2.size() - 1; i >= 0; i--) {\n            if (accumulator + doublings.get(i) <= dividend) {\n                accumulator += doublings.get(i);\n                answer += powersOf2.get(i);\n            }\n        }\n\n        System.out.println(String.format(\"%d, remainder %d\", answer, dividend - accumulator));\n    }\n}\n"}
{"id": 164435, "name": "Egyptian division", "source": "Translate Ruby to Python: def egyptian_divmod(dividend, divisor)\n  table = [[1, divisor]]\n  table << table.last.map{|e| e*2} while table.last.first * 2 <= dividend\n  answer, accumulator = 0, 0\n  table.reverse_each do |pow, double|\n    if accumulator + double <= dividend\n      accumulator += double\n      answer += pow\n    end\n  end\n  [answer, dividend - accumulator] \nend\n\nputs \"Quotient = %s Remainder = %s\" % egyptian_divmod(580, 34)\n", "target": "from itertools import product\n\ndef egyptian_divmod(dividend, divisor):\n    assert divisor != 0\n    pwrs, dbls = [1], [divisor]\n    while dbls[-1] <= dividend:\n        pwrs.append(pwrs[-1] * 2)\n        dbls.append(pwrs[-1] * divisor)\n    ans, accum = 0, 0\n    for pwr, dbl in zip(pwrs[-2::-1], dbls[-2::-1]):\n        if accum + dbl <= dividend:\n            accum += dbl\n            ans += pwr\n    return ans, abs(accum - dividend)\n\nif __name__ == \"__main__\":\n    \n    for i, j in product(range(13), range(1, 13)):\n            assert egyptian_divmod(i, j) == divmod(i, j)\n    \n    i, j = 580, 34\n    print(f'{i} divided by {j} using the Egyption method is %i remainder %i'\n          % egyptian_divmod(i, j))\n"}
{"id": 164654, "name": "One of n lines in a file", "source": "Translate Ruby to C#: \n\n\ndef random_line(io)\n  choice = io.gets; count = 1\n  while line = io.gets\n    rand(count += 1).zero? and choice = line\n  end\n  choice\nend\n\ndef one_of_n(n)\n  \n  \n  (mock_io = Object.new).instance_eval do\n    @count = 0\n    @last = n\n    def self.gets\n      (@count < @last) ? (@count += 1) : nil\n    end\n  end\n  random_line(mock_io)\nend\n\nchosen = Hash.new(0)\n1_000_000.times { chosen[one_of_n(10)] += 1 }\nchosen.keys.sort.each do |key|\n  puts \"\nend\n", "target": "    class Program\n    {\n        private static Random rnd = new Random();\n        public static int one_of_n(int n)\n        {\n            int currentChoice = 1;\n            for (int i = 2; i <= n; i++)\n            {\n                double outerLimit = 1D / (double)i;\n                if (rnd.NextDouble() < outerLimit)\n                    currentChoice = i;\n            }\n            return currentChoice;\n        }\n\n        static void Main(string[] args)\n        {\n            Dictionary<int, int> results = new Dictionary<int, int>();\n            for (int i = 1; i < 11; i++)\n                results.Add(i, 0);\n\n            for (int i = 0; i < 1000000; i++)\n            {\n                int result = one_of_n(10);\n                results[result] = results[result] + 1;\n            }\n\n            for (int i = 1; i < 11; i++)\n                Console.WriteLine(\"{0}\\t{1}\", i, results[i]);\n            Console.ReadLine();\n        }\n    }\n"}
{"id": 164656, "name": "One of n lines in a file", "source": "Translate Ruby to Java: \n\n\ndef random_line(io)\n  choice = io.gets; count = 1\n  while line = io.gets\n    rand(count += 1).zero? and choice = line\n  end\n  choice\nend\n\ndef one_of_n(n)\n  \n  \n  (mock_io = Object.new).instance_eval do\n    @count = 0\n    @last = n\n    def self.gets\n      (@count < @last) ? (@count += 1) : nil\n    end\n  end\n  random_line(mock_io)\nend\n\nchosen = Hash.new(0)\n1_000_000.times { chosen[one_of_n(10)] += 1 }\nchosen.keys.sort.each do |key|\n  puts \"\nend\n", "target": "import java.util.Arrays;\nimport java.util.Random;\n\npublic class OneOfNLines {\n\n\tstatic Random rand;\n\t\n\tpublic static int oneOfN(int n) {\n\t\tint choice = 0;\n\t\t\n\t\tfor(int i = 1; i < n; i++) {\n\t\t\tif(rand.nextInt(i+1) == 0)\n\t\t\t\tchoice = i;\n\t\t}\n\t\t\n\t\treturn choice;\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tint n = 10;\n\t\tint trials = 1000000;\n\t\tint[] bins = new int[n];\n\t\trand = new Random();\n\t\t\n\t\tfor(int i = 0; i < trials; i++)\n\t\t\tbins[oneOfN(n)]++;\n\t\t\n\t\t\n\t\tSystem.out.println(Arrays.toString(bins));\n\t}\n}\n"}
{"id": 164657, "name": "One of n lines in a file", "source": "Translate Ruby to Python: \n\n\ndef random_line(io)\n  choice = io.gets; count = 1\n  while line = io.gets\n    rand(count += 1).zero? and choice = line\n  end\n  choice\nend\n\ndef one_of_n(n)\n  \n  \n  (mock_io = Object.new).instance_eval do\n    @count = 0\n    @last = n\n    def self.gets\n      (@count < @last) ? (@count += 1) : nil\n    end\n  end\n  random_line(mock_io)\nend\n\nchosen = Hash.new(0)\n1_000_000.times { chosen[one_of_n(10)] += 1 }\nchosen.keys.sort.each do |key|\n  puts \"\nend\n", "target": "from random import randrange\ntry:\n    range = xrange\nexcept: pass\n\ndef one_of_n(lines): \n    choice = None\n    for i, line in enumerate(lines):\n        if randrange(i+1) == 0:\n            choice = line\n    return choice\n            \ndef one_of_n_test(n=10, trials=1000000):\n    bins = [0] * n\n    if n:\n        for i in range(trials):\n            bins[one_of_n(range(n))] += 1\n    return bins\n\nprint(one_of_n_test())\n"}
{"id": 164815, "name": "Set consolidation", "source": "Translate Ruby to C#: require 'set'\n\ntests = [[[:A,:B], [:C,:D]],\n         [[:A,:B], [:B,:D]],\n         [[:A,:B], [:C,:D], [:D,:B]],\n         [[:H,:I,:K], [:A,:B], [:C,:D], [:D,:B], [:F,:G,:H]]]\ntests.map!{|sets| sets.map(&:to_set)}\n\ntests.each do |sets|\n  until sets.combination(2).none?{|a,b| a.merge(b) && sets.delete(b) if a.intersect?(b)}\n  end\n  p sets\nend\n", "target": "using System;\nusing System.Linq;\nusing System.Collections.Generic;\n\npublic class SetConsolidation\n{\n    public static void Main()\n    {\n        var setCollection1 = new[] {new[] {\"A\", \"B\"}, new[] {\"C\", \"D\"}};\n        var setCollection2 = new[] {new[] {\"A\", \"B\"}, new[] {\"B\", \"D\"}};\n        var setCollection3 = new[] {new[] {\"A\", \"B\"}, new[] {\"C\", \"D\"}, new[] {\"B\", \"D\"}};\n        var setCollection4 = new[] {new[] {\"H\", \"I\", \"K\"}, new[] {\"A\", \"B\"}, new[] {\"C\", \"D\"},\n            new[] {\"D\", \"B\"}, new[] {\"F\", \"G\", \"H\"}};\n        var input = new[] {setCollection1, setCollection2, setCollection3, setCollection4};\n        \n        foreach (var sets in input) {\n            Console.WriteLine(\"Start sets:\");\n            Console.WriteLine(string.Join(\", \", sets.Select(s => \"{\" + string.Join(\", \", s) + \"}\")));\n            Console.WriteLine(\"Sets consolidated using Nodes:\");\n            Console.WriteLine(string.Join(\", \", ConsolidateSets1(sets).Select(s => \"{\" + string.Join(\", \", s) + \"}\")));\n            Console.WriteLine(\"Sets consolidated using Set operations:\");\n            Console.WriteLine(string.Join(\", \", ConsolidateSets2(sets).Select(s => \"{\" + string.Join(\", \", s) + \"}\")));\n            Console.WriteLine();\n        }\n    }\n    \n    \n    \n    \n    \n    private static IEnumerable<IEnumerable<T>> ConsolidateSets1<T>(IEnumerable<IEnumerable<T>> sets,\n        IEqualityComparer<T> comparer = null)\n    {\n        if (comparer == null) comparer = EqualityComparer<T>.Default;\n        var elements = new Dictionary<T, Node<T>>();\n        foreach (var set in sets) {\n            Node<T> top = null;\n            foreach (T value in set) {\n                Node<T> element;\n                if (elements.TryGetValue(value, out element)) {\n                    if (top != null) {\n                        var newTop = element.FindTop();\n                        top.Parent = newTop;\n                        element.Parent = newTop;\n                        top = newTop;\n                    } else {\n                        top = element.FindTop();\n                    }\n                } else {\n                    elements.Add(value, element = new Node<T>(value));\n                    if (top == null) top = element;\n                    else element.Parent = top;\n                }\n            }\n        }\n        foreach (var g in elements.Values.GroupBy(element => element.FindTop().Value))\n            yield return g.Select(e => e.Value);\n    }\n    \n    private class Node<T>\n    {\n        public Node(T value, Node<T> parent = null) {\n            Value = value;\n            Parent = parent ?? this;\n        }\n        \n        public T Value { get; }\n        public Node<T> Parent { get; set; }\n        \n        public Node<T> FindTop() {\n            var top = this;\n            while (top != top.Parent) top = top.Parent;\n            \n            var element = this;\n            while (element.Parent != top) {\n                var parent = element.Parent;\n                element.Parent = top;\n                element = parent;\n            }\n            return top;\n        }\n    }\n    \n    \n    \n    \n    \n    private static IEnumerable<IEnumerable<T>> ConsolidateSets2<T>(IEnumerable<IEnumerable<T>> sets,\n        IEqualityComparer<T> comparer = null)\n    {\n        if (comparer == null) comparer = EqualityComparer<T>.Default;\n        var currentSets = sets.Select(s => new HashSet<T>(s)).ToList();\n        int previousSize;\n        do {\n            previousSize = currentSets.Count;\n            for (int i = 0; i < currentSets.Count - 1; i++) {\n                for (int j = currentSets.Count - 1; j > i; j--) {\n                    if (currentSets[i].Overlaps(currentSets[j])) {\n                        currentSets[i].UnionWith(currentSets[j]);\n                        currentSets.RemoveAt(j);\n                    }\n                }\n            }\n        } while (previousSize > currentSets.Count);\n        foreach (var set in currentSets) yield return set.Select(value => value);\n    }\n}\n"}
{"id": 164817, "name": "Set consolidation", "source": "Translate Ruby to Java: require 'set'\n\ntests = [[[:A,:B], [:C,:D]],\n         [[:A,:B], [:B,:D]],\n         [[:A,:B], [:C,:D], [:D,:B]],\n         [[:H,:I,:K], [:A,:B], [:C,:D], [:D,:B], [:F,:G,:H]]]\ntests.map!{|sets| sets.map(&:to_set)}\n\ntests.each do |sets|\n  until sets.combination(2).none?{|a,b| a.merge(b) && sets.delete(b) if a.intersect?(b)}\n  end\n  p sets\nend\n", "target": "import java.util.*;\n\npublic class SetConsolidation {\n\n    public static void main(String[] args) {\n        List<Set<Character>> h1 = hashSetList(\"AB\", \"CD\");\n        System.out.println(consolidate(h1));\n\n        List<Set<Character>> h2 = hashSetList(\"AB\", \"BD\");\n        System.out.println(consolidateR(h2));\n\n        List<Set<Character>> h3 = hashSetList(\"AB\", \"CD\", \"DB\");\n        System.out.println(consolidate(h3));\n\n        List<Set<Character>> h4 = hashSetList(\"HIK\", \"AB\", \"CD\", \"DB\", \"FGH\");\n        System.out.println(consolidateR(h4));\n    }\n\n    \n    private static <E> List<Set<E>>\n                consolidate(Collection<? extends Set<E>> sets) {\n\tList<Set<E>> r = new ArrayList<>();\n\tfor (Set<E> s : sets) {\n\t    List<Set<E>> new_r = new ArrayList<>();\n\t    new_r.add(s);\n\t    for (Set<E> x : r) {\n\t\tif (!Collections.disjoint(s, x)) {\n\t\t    s.addAll(x);\n\t\t} else {\n\t\t    new_r.add(x);\n\t\t}\n\t    }\n\t    r = new_r;\n\t}\n\treturn r;\n    }\n\n    \n    private static <E> List<Set<E>> consolidateR(List<Set<E>> sets) {\n        if (sets.size() < 2)\n            return sets;\n        List<Set<E>> r = new ArrayList<>();\n        r.add(sets.get(0));\n        for (Set<E> x : consolidateR(sets.subList(1, sets.size()))) {\n            if (!Collections.disjoint(r.get(0), x)) {\n                r.get(0).addAll(x);\n            } else {\n                r.add(x);\n            }\n        }\n        return r;\n    }\n\n    private static List<Set<Character>> hashSetList(String... set) {\n        List<Set<Character>> r = new ArrayList<>();\n        for (int i = 0; i < set.length; i++) {\n            r.add(new HashSet<Character>());\n            for (int j = 0; j < set[i].length(); j++)\n                r.get(i).add(set[i].charAt(j));\n        }\n        return r;\n    }\n}\n"}
{"id": 164818, "name": "Set consolidation", "source": "Translate Ruby to Python: require 'set'\n\ntests = [[[:A,:B], [:C,:D]],\n         [[:A,:B], [:B,:D]],\n         [[:A,:B], [:C,:D], [:D,:B]],\n         [[:H,:I,:K], [:A,:B], [:C,:D], [:D,:B], [:F,:G,:H]]]\ntests.map!{|sets| sets.map(&:to_set)}\n\ntests.each do |sets|\n  until sets.combination(2).none?{|a,b| a.merge(b) && sets.delete(b) if a.intersect?(b)}\n  end\n  p sets\nend\n", "target": "def consolidate(sets):\n    setlist = [s for s in sets if s]\n    for i, s1 in enumerate(setlist):\n        if s1:\n            for s2 in setlist[i+1:]:\n                intersection = s1.intersection(s2)\n                if intersection:\n                    s2.update(s1)\n                    s1.clear()\n                    s1 = s2\n    return [s for s in setlist if s]\n"}
{"id": 165003, "name": "Repeat", "source": "Translate Ruby to C#: 4.times{ puts \"Example\" }  \n\ndef repeat(proc,num)\n  num.times{ proc.call }\nend\n\nrepeat(->{ puts \"Example\" }, 4)\n", "target": "using System;\n\nnamespace Repeat {\n    class Program {\n        static void Repeat(int count, Action<int> fn) {\n            if (null == fn) {\n                throw new ArgumentNullException(\"fn\");\n            }\n            for (int i = 0; i < count; i++) {\n                fn.Invoke(i + 1);\n            }\n        }\n\n        static void Main(string[] args) {\n            Repeat(3, x => Console.WriteLine(\"Example {0}\", x));\n        }\n    }\n}\n"}
{"id": 165005, "name": "Repeat", "source": "Translate Ruby to Java: 4.times{ puts \"Example\" }  \n\ndef repeat(proc,num)\n  num.times{ proc.call }\nend\n\nrepeat(->{ puts \"Example\" }, 4)\n", "target": "import java.util.function.Consumer;\nimport java.util.stream.IntStream;\n\npublic class Repeat {\n\n    public static void main(String[] args) {\n        repeat(3, (x) -> System.out.println(\"Example \" + x));\n    }\n\n    static void repeat (int n, Consumer<Integer> fun) {\n        IntStream.range(0, n).forEach(i -> fun.accept(i + 1));\n    }\n}\n"}
{"id": 165006, "name": "Repeat", "source": "Translate Ruby to Python: 4.times{ puts \"Example\" }  \n\ndef repeat(proc,num)\n  num.times{ proc.call }\nend\n\nrepeat(->{ puts \"Example\" }, 4)\n", "target": "\ndef repeat(f,n):\n  for i in range(n):\n    f();\n\ndef procedure():\n  print(\"Example\");\n\nrepeat(procedure,3); \n"}
{"id": 165103, "name": "Stream merge", "source": "Translate Ruby to C#: def stream_merge(*files)\n  fio = files.map{|fname| open(fname)}\n  merge(fio.map{|io| [io, io.gets]})\nend\n\ndef merge(fdata)\n  until fdata.empty?\n    io, min = fdata.min_by{|_,data| data}\n    puts min\n    if (next_data = io.gets).nil?\n      io.close\n      fdata.delete([io, min])\n    else\n      i = fdata.index{|x,_| x == io}\n      fdata[i] = [io, next_data]\n    end\n  end\nend\n\nfiles = %w(temp1.dat temp2.dat temp3.dat)\nfiles.each do |fname|\n  data = IO.read(fname).gsub(\"\\n\", \" \")\n  puts \"\nend\nstream_merge(*files)\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\nnamespace RosettaCode\n{\n    static class StreamMerge\n    {\n        static IEnumerable<T> Merge2<T>(IEnumerable<T> source1, IEnumerable<T> source2) where T : IComparable\n        {\n            var q1 = new Queue<T>(source1);\n            var q2 = new Queue<T>(source2);\n            while (q1.Any() && q2.Any())\n            {\n                var c = q1.Peek().CompareTo(q2.Peek());\n                if (c <= 0) yield return q1.Dequeue(); else yield return q2.Dequeue();\n            }\n            while (q1.Any()) yield return q1.Dequeue();\n            while (q2.Any()) yield return q2.Dequeue();\n        }\n\n        static IEnumerable<T> MergeN<T>(params IEnumerable<T>[] sources) where T : IComparable\n        {\n            var queues = sources.Select(e => new Queue<T>(e)).Where(q => q.Any()).ToList();\n            var headComparer = Comparer<Queue<T>>.Create((x, y) => x.Peek().CompareTo(y.Peek()));\n            queues.Sort(headComparer);\n            \n            while (queues.Any())\n            {\n                var q = queues.First();\n                queues.RemoveAt(0);\n                yield return q.Dequeue();\n                if (q.Any())\n                {\n                    var index = queues.BinarySearch(q, headComparer);\n                    queues.Insert(index < 0 ? ~index : index, q);\n                }\n            }\n        }\n\n        static void Main()\n        {\n            var a = new[] { 1, 4, 7, 10 };\n            var b = new[] { 2, 5, 8, 11 };\n            var c = new[] { 3, 6, 9, 12 };\n\n            foreach (var i in Merge2(a, b)) Console.Write($\"{i} \");\n            Console.WriteLine();\n\n            foreach (var i in MergeN(a, b, c)) Console.Write($\"{i} \");\n            Console.WriteLine();\n        }\n    }\n}\n"}
{"id": 165105, "name": "Stream merge", "source": "Translate Ruby to Java: def stream_merge(*files)\n  fio = files.map{|fname| open(fname)}\n  merge(fio.map{|io| [io, io.gets]})\nend\n\ndef merge(fdata)\n  until fdata.empty?\n    io, min = fdata.min_by{|_,data| data}\n    puts min\n    if (next_data = io.gets).nil?\n      io.close\n      fdata.delete([io, min])\n    else\n      i = fdata.index{|x,_| x == io}\n      fdata[i] = [io, next_data]\n    end\n  end\nend\n\nfiles = %w(temp1.dat temp2.dat temp3.dat)\nfiles.each do |fname|\n  data = IO.read(fname).gsub(\"\\n\", \" \")\n  puts \"\nend\nstream_merge(*files)\n", "target": "import java.util.Iterator;\nimport java.util.List;\nimport java.util.Objects;\n\npublic class StreamMerge {\n    private static <T extends Comparable<T>> void merge2(Iterator<T> i1, Iterator<T> i2) {\n        T a = null, b = null;\n\n        while (i1.hasNext() || i2.hasNext()) {\n            if (null == a && i1.hasNext()) {\n                a = i1.next();\n            }\n            if (null == b && i2.hasNext()) {\n                b = i2.next();\n            }\n\n            if (null != a) {\n                if (null != b) {\n                    if (a.compareTo(b) < 0) {\n                        System.out.print(a);\n                        a = null;\n                    } else {\n                        System.out.print(b);\n                        b = null;\n                    }\n                } else {\n                    System.out.print(a);\n                    a = null;\n                }\n            } else if (null != b) {\n                System.out.print(b);\n                b = null;\n            }\n        }\n\n        if (null != a) {\n            System.out.print(a);\n        }\n        if (null != b) {\n            System.out.print(b);\n        }\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    @SafeVarargs\n    private static <T extends Comparable<T>> void mergeN(Iterator<T>... iter) {\n        Objects.requireNonNull(iter);\n        if (iter.length == 0) {\n            throw new IllegalArgumentException(\"Must have at least one iterator\");\n        }\n\n        Object[] pa = new Object[iter.length];\n        boolean done;\n\n        do {\n            done = true;\n\n            for (int i = 0; i < iter.length; i++) {\n                Iterator<T> t = iter[i];\n                if (null == pa[i] && t.hasNext()) {\n                    pa[i] = t.next();\n                }\n            }\n\n            T min = null;\n            int idx = -1;\n            for (int i = 0; i < pa.length; ++i) {\n                T t = (T) pa[i];\n                if (null != t) {\n                    if (null == min) {\n                        min = t;\n                        idx = i;\n                        done = false;\n                    } else if (t.compareTo(min) < 0) {\n                        min = t;\n                        idx = i;\n                        done = false;\n                    }\n                }\n            }\n            if (idx != -1) {\n                System.out.print(min);\n                pa[idx] = null;\n            }\n        } while (!done);\n    }\n\n    public static void main(String[] args) {\n        List<Integer> l1 = List.of(1, 4, 7, 10);\n        List<Integer> l2 = List.of(2, 5, 8, 11);\n        List<Integer> l3 = List.of(3, 6, 9, 12);\n\n        merge2(l1.iterator(), l2.iterator());\n        System.out.println();\n\n        mergeN(l1.iterator(), l2.iterator(), l3.iterator());\n        System.out.println();\n        System.out.flush();\n    }\n}\n"}
{"id": 165106, "name": "Stream merge", "source": "Translate Ruby to Python: def stream_merge(*files)\n  fio = files.map{|fname| open(fname)}\n  merge(fio.map{|io| [io, io.gets]})\nend\n\ndef merge(fdata)\n  until fdata.empty?\n    io, min = fdata.min_by{|_,data| data}\n    puts min\n    if (next_data = io.gets).nil?\n      io.close\n      fdata.delete([io, min])\n    else\n      i = fdata.index{|x,_| x == io}\n      fdata[i] = [io, next_data]\n    end\n  end\nend\n\nfiles = %w(temp1.dat temp2.dat temp3.dat)\nfiles.each do |fname|\n  data = IO.read(fname).gsub(\"\\n\", \" \")\n  puts \"\nend\nstream_merge(*files)\n", "target": "import heapq\nimport sys\n\nsources = sys.argv[1:]\nfor item in heapq.merge(open(source) for source in sources):\n    print(item)\n"}
{"id": 165309, "name": "The Twelve Days of Christmas", "source": "Translate Ruby to C#: days = \"first second third fourth fifth sixth seventh eighth ninth tenth eleventh twelfth\".split \" \"\ngifts = \"A partridge in a pear tree\nTwo turtle doves and\nThree french hens\nFour calling birds\nFive golden rings\nSix geese a-laying\nSeven swans a-swimming\nEight maids a-milking\nNine ladies dancing\nTen lords a-leaping\nEleven pipers piping\nTwelve drummers drumming\".split \"\\n\"\n\ndays.each_with_index do |day, i|\n    puts \"On the \n    gifts[0, i + 1].reverse.each &->puts(String)\n    puts\nend\n", "target": "using System;\n\npublic class TwelveDaysOfChristmas {\n\n    public static void Main() {\n\n        string[] days = new string[12] {\n            \"first\", \"second\", \"third\", \"fourth\", \"fifth\", \"sixth\", \"seventh\", \"eighth\", \"ninth\",\n            \"tenth\", \"eleventh\", \"twelfth\",\n        };\n\n        string[] gifts = new string[12] {\n            \"A partridge in a pear tree\",\n            \"Two turtle doves\",\n            \"Three french hens\",\n            \"Four calling birds\",\n            \"Five golden rings\",\n            \"Six geese a-laying\",\n            \"Seven swans a-swimming\",\n            \"Eight maids a-milking\",\n            \"Nine ladies dancing\",\n            \"Ten lords a-leaping\",\n            \"Eleven pipers piping\",\n            \"Twelve drummers drumming\"\n        };\n\n        for ( int i = 0; i < 12; i++ ) {\n\n            Console.WriteLine(\"On the \" + days[i] + \" day of Christmas, my true love gave to me\");\n\n            int j = i + 1;\n            while ( j-- > 0 )\n                Console.WriteLine(gifts[j]);\n\n            Console.WriteLine();\n\n            if ( i == 0 )\n                gifts[0] = \"And a partridge in a pear tree\";\n        }\n\n    }\n\n}\n"}
{"id": 165311, "name": "The Twelve Days of Christmas", "source": "Translate Ruby to Java: days = \"first second third fourth fifth sixth seventh eighth ninth tenth eleventh twelfth\".split \" \"\ngifts = \"A partridge in a pear tree\nTwo turtle doves and\nThree french hens\nFour calling birds\nFive golden rings\nSix geese a-laying\nSeven swans a-swimming\nEight maids a-milking\nNine ladies dancing\nTen lords a-leaping\nEleven pipers piping\nTwelve drummers drumming\".split \"\\n\"\n\ndays.each_with_index do |day, i|\n    puts \"On the \n    gifts[0, i + 1].reverse.each &->puts(String)\n    puts\nend\n", "target": "public class TwelveDaysOfChristmas {\n\n    final static String[] gifts = {\n        \"A partridge in a pear tree.\", \"Two turtle doves and\",\n        \"Three french hens\", \"Four calling birds\",\n        \"Five golden rings\", \"Six geese a-laying\",\n        \"Seven swans a-swimming\", \"Eight maids a-milking\",\n        \"Nine ladies dancing\", \"Ten lords a-leaping\",\n        \"Eleven pipers piping\", \"Twelve drummers drumming\",\n        \"And a partridge in a pear tree.\", \"Two turtle doves\"\n    };\n\n    final static String[] days = {\n        \"first\", \"second\", \"third\", \"fourth\", \"fifth\", \"sixth\", \"seventh\",\n        \"eighth\", \"ninth\", \"tenth\", \"eleventh\", \"Twelfth\"\n    };\n\n    public static void main(String[] args) {\n        for (int i = 0; i < days.length; i++) {\n            System.out.printf(\"%nOn the %s day of Christmas%n\", days[i]);\n            System.out.println(\"My true love gave to me:\");\n            for (int j = i; j >= 0; j--)\n                System.out.println(gifts[i == 11 && j < 2 ? j + 12 : j]);\n        }\n    }\n}\n"}
{"id": 165312, "name": "The Twelve Days of Christmas", "source": "Translate Ruby to Python: days = \"first second third fourth fifth sixth seventh eighth ninth tenth eleventh twelfth\".split \" \"\ngifts = \"A partridge in a pear tree\nTwo turtle doves and\nThree french hens\nFour calling birds\nFive golden rings\nSix geese a-laying\nSeven swans a-swimming\nEight maids a-milking\nNine ladies dancing\nTen lords a-leaping\nEleven pipers piping\nTwelve drummers drumming\".split \"\\n\"\n\ndays.each_with_index do |day, i|\n    puts \"On the \n    gifts[0, i + 1].reverse.each &->puts(String)\n    puts\nend\n", "target": "gifts = .split('\\n')\n\ndays = .split()\n\nfor n, day in enumerate(days, 1):\n    g = gifts[:n][::-1]\n    print(('\\nOn the %s day of Christmas\\nMy true love gave to me:\\n' % day) +\n          '\\n'.join(g[:-1]) +\n          (' and\\n' + g[-1] if n > 1 else g[-1].capitalize()))\n"}
{"id": 165447, "name": "Same fringe", "source": "Translate Ruby to C#: var trees = [\n    \n    [ 'd', [ 'c', [ 'a', 'b', ], ], ],\n    [ [ 'd', 'c' ], [ 'a', 'b' ] ],\n    [ [ [ 'd', 'c', ], 'a', ], 'b', ],\n    \n    [ [ [ [ [ [ 'a' ], 'b' ], 'c', ], 'd', ], 'e', ], 'f' ],\n]\n\u00a0\nfunc get_tree_iterator(*rtrees) {\n    var tree\n    func {\n        tree = rtrees.pop\n        while (defined(tree) && tree.kind_of(Array)) {\n            rtrees.append(tree[1])\n            tree = tree[0]\n        }\n        return tree\n    }\n}\n\u00a0\nfunc cmp_fringe(a, b) {\n    var ti1 = get_tree_iterator(a)\n    var ti2 = get_tree_iterator(b)\n    loop {\n        var (L, R) = (ti1(), ti2())\n         defined(L) &&  defined(R) && (L == R) && next\n       \u00a0!defined(L) &&\u00a0!defined(R) && return \"Same\"\n        return \"Different\"\n    }\n}\n\u00a0\nfor idx in ^(trees.end) {\n    say (\"tree[\n           cmp_fringe(trees[idx], trees[idx+1]))\n}\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\nnamespace Same_Fringe\n{\n\tclass Program\n\t{\n\t\tstatic void Main()\n\t\t{\n\t\t\tvar rnd = new Random(110456);\n\t\t\tvar randList = Enumerable.Range(0, 20).Select(i => rnd.Next(1000)).ToList();\n\t\t\tvar bt1 = new BinTree<int>(randList);\n\t\t\t\n\t\t\tShuffle(randList, 428);\n\t\t\tvar bt2 = new BinTree<int>(randList);\n\t\t\tConsole.WriteLine(bt1.CompareTo(bt2) ? \"True compare worked\" : \"True compare failed\");\n\t\t\t\n\t\t\tbt1.Insert(0);\n\t\t\tConsole.WriteLine(bt1.CompareTo(bt2) ? \"False compare failed\" : \"False compare worked\");\n\t\t}\n\n\t\tstatic void Shuffle<T>(List<T> values, int seed)\n\t\t{\n\t\t\tvar rnd = new Random(seed);\n\n\t\t\tfor (var i = 0; i < values.Count - 2; i++)\n\t\t\t{\n\t\t\t\tvar iSwap = rnd.Next(values.Count - i) + i;\n\t\t\t\tvar tmp = values[iSwap];\n\t\t\t\tvalues[iSwap] = values[i];\n\t\t\t\tvalues[i] = tmp;\n\t\t\t}\n\t\t}\n\t}\n\n\t\n\tclass BinTree<T> where T:IComparable\n\t{\n\t\tprivate BinTree<T> _left;\n\t\tprivate BinTree<T> _right;\n\t\tprivate T _value;\n\n\t\tprivate BinTree<T> Left\n\t\t{\n\t\t\tget { return _left; }\n\t\t}\n\n\t\tprivate BinTree<T> Right\n\t\t{\n\t\t\tget { return _right; }\n\t\t}\n\n\t\t\n\t\t\n\t\tprivate T Value\n\t\t{\n\t\t\tget { return _value; }\n\t\t}\n\n\t\tpublic bool IsLeaf { get { return Left == null; } }\n\n\t\tprivate BinTree(BinTree<T> left, BinTree<T> right, T value)\n\t\t{\n\t\t\t_left = left;\n\t\t\t_right = right;\n\t\t\t_value = value;\n\t\t}\n\n\t\tpublic BinTree(T value) : this(null, null, value) { }\n\n\t\tpublic BinTree(IEnumerable<T> values)\n\t\t{\n\t\t\t\n\t\t\t_value = values.First();\n\t\t\tforeach (var value in values.Skip(1))\n\t\t\t{\n\t\t\t\tInsert(value);\n\t\t\t}\n\t\t\t\n\t\t}\n\n\t\tpublic void Insert(T value)\n\t\t{\n\t\t\tif (IsLeaf)\n\t\t\t{\n\t\t\t\tif (value.CompareTo(Value) < 0)\n\t\t\t\t{\n\t\t\t\t\t_left = new BinTree<T>(value);\n\t\t\t\t\t_right = new BinTree<T>(Value);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t_left = new BinTree<T>(Value);\n\t\t\t\t\t_right = new BinTree<T>(value);\n\t\t\t\t\t_value = value;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif (value.CompareTo(Value) < 0)\n\t\t\t\t{\n\t\t\t\t\tLeft.Insert(value);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tRight.Insert(value);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tpublic IEnumerable<T> GetLeaves()\n\t\t{\n\t\t\tif (IsLeaf)\n\t\t\t{\n\t\t\t\tyield return Value;\n\t\t\t\tyield break;\n\t\t\t}\n\t\t\tforeach (var val in Left.GetLeaves())\n\t\t\t{\n\t\t\t\tyield return val;\n\t\t\t}\n\t\t\tforeach (var val in Right.GetLeaves())\n\t\t\t{\n\t\t\t\tyield return val;\n\t\t\t}\n\t\t}\n\n\t\tinternal bool CompareTo(BinTree<T> other)\n\t\t{\n\t\t\treturn other.GetLeaves().Zip(GetLeaves(), (t1, t2) => t1.CompareTo(t2) == 0).All(f => f);\n\t\t}\n\t}\n}\n"}
{"id": 165449, "name": "Same fringe", "source": "Translate Ruby to Java: var trees = [\n    \n    [ 'd', [ 'c', [ 'a', 'b', ], ], ],\n    [ [ 'd', 'c' ], [ 'a', 'b' ] ],\n    [ [ [ 'd', 'c', ], 'a', ], 'b', ],\n    \n    [ [ [ [ [ [ 'a' ], 'b' ], 'c', ], 'd', ], 'e', ], 'f' ],\n]\n\u00a0\nfunc get_tree_iterator(*rtrees) {\n    var tree\n    func {\n        tree = rtrees.pop\n        while (defined(tree) && tree.kind_of(Array)) {\n            rtrees.append(tree[1])\n            tree = tree[0]\n        }\n        return tree\n    }\n}\n\u00a0\nfunc cmp_fringe(a, b) {\n    var ti1 = get_tree_iterator(a)\n    var ti2 = get_tree_iterator(b)\n    loop {\n        var (L, R) = (ti1(), ti2())\n         defined(L) &&  defined(R) && (L == R) && next\n       \u00a0!defined(L) &&\u00a0!defined(R) && return \"Same\"\n        return \"Different\"\n    }\n}\n\u00a0\nfor idx in ^(trees.end) {\n    say (\"tree[\n           cmp_fringe(trees[idx], trees[idx+1]))\n}\n", "target": "import java.util.*;\n\nclass SameFringe\n{\n  public interface Node<T extends Comparable<? super T>>\n  {\n    Node<T> getLeft();\n    Node<T> getRight();\n    boolean isLeaf();\n    T getData();\n  }\n  \n  public static class SimpleNode<T extends Comparable<? super T>> implements Node<T>\n  {\n    private final T data;\n    public SimpleNode<T> left;\n    public SimpleNode<T> right;\n    \n    public SimpleNode(T data)\n    {  this(data, null, null);  }\n    \n    public SimpleNode(T data, SimpleNode<T> left, SimpleNode<T> right)\n    {\n      this.data = data;\n      this.left = left;\n      this.right = right;\n    }\n    \n    public Node<T> getLeft()\n    {  return left;  }\n    \n    public Node<T> getRight()\n    {  return right;  }\n    \n    public boolean isLeaf()\n    {  return ((left == null) && (right == null));  }\n    \n    public T getData()\n    {  return data;  }\n    \n    public SimpleNode<T> addToTree(T data)\n    {\n      int cmp = data.compareTo(this.data);\n      if (cmp == 0)\n        throw new IllegalArgumentException(\"Same data!\");\n      if (cmp < 0)\n      {\n        if (left == null)\n          return (left = new SimpleNode<T>(data));\n        return left.addToTree(data);\n      }\n      if (right == null)\n        return (right = new SimpleNode<T>(data));\n      return right.addToTree(data);\n    }\n  }\n  \n  public static <T extends Comparable<? super T>> boolean areLeavesSame(Node<T> node1, Node<T> node2)\n  {\n    Stack<Node<T>> stack1 = new Stack<Node<T>>();\n    Stack<Node<T>> stack2 = new Stack<Node<T>>();\n    stack1.push(node1);\n    stack2.push(node2);\n    \n    while (((node1 = advanceToLeaf(stack1)) != null) & ((node2 = advanceToLeaf(stack2)) != null))\n      if (!node1.getData().equals(node2.getData()))\n        return false;\n    \n    return (node1 == null) && (node2 == null);\n  }\n  \n  private static <T extends Comparable<? super T>> Node<T> advanceToLeaf(Stack<Node<T>> stack)\n  {\n    while (!stack.isEmpty())\n    {\n      Node<T> node = stack.pop();\n      if (node.isLeaf())\n        return node;\n      Node<T> rightNode = node.getRight();\n      if (rightNode != null)\n        stack.push(rightNode);\n      Node<T> leftNode = node.getLeft();\n      if (leftNode != null)\n        stack.push(leftNode);\n    }\n    return null;\n  }\n  \n  public static void main(String[] args)\n  {\n    SimpleNode<Integer> headNode1 = new SimpleNode<Integer>(35, new SimpleNode<Integer>(25, new SimpleNode<Integer>(15, new SimpleNode<Integer>(10), new SimpleNode<Integer>(20)), new SimpleNode<Integer>(30)), new SimpleNode<Integer>(45, new SimpleNode<Integer>(40), new SimpleNode<Integer>(50)));\n    SimpleNode<Integer> headNode2 = new SimpleNode<Integer>(24, new SimpleNode<Integer>(14, new SimpleNode<Integer>(10), new SimpleNode<Integer>(16, null, new SimpleNode<Integer>(20))), new SimpleNode<Integer>(34, new SimpleNode<Integer>(30), new SimpleNode<Integer>(42, new SimpleNode<Integer>(40), new SimpleNode<Integer>(56, new SimpleNode<Integer>(50), null))));\n    SimpleNode<Integer> headNode3 = new SimpleNode<Integer>(24, new SimpleNode<Integer>(14, new SimpleNode<Integer>(10), new SimpleNode<Integer>(16, null, new SimpleNode<Integer>(20))), new SimpleNode<Integer>(34, new SimpleNode<Integer>(30), new SimpleNode<Integer>(42, new SimpleNode<Integer>(40), new SimpleNode<Integer>(50, null, new SimpleNode<Integer>(56)))));\n    System.out.print(\"Leaves for set 1: \");\n    simpleWalk(headNode1);\n    System.out.println();\n    System.out.print(\"Leaves for set 2: \");\n    simpleWalk(headNode2);\n    System.out.println();\n    System.out.print(\"Leaves for set 3: \");\n    simpleWalk(headNode3);\n    System.out.println();\n    System.out.println(\"areLeavesSame(1, 2)? \" + areLeavesSame(headNode1, headNode2));\n    System.out.println(\"areLeavesSame(2, 3)? \" + areLeavesSame(headNode2, headNode3));\n  }\n  \n  public static void simpleWalk(Node<Integer> node)\n  {\n    if (node.isLeaf())\n      System.out.print(node.getData() + \" \");\n    else\n    {\n      Node<Integer> left = node.getLeft();\n      if (left != null)\n        simpleWalk(left);\n      Node<Integer> right = node.getRight();\n      if (right != null)\n        simpleWalk(right);\n    }\n  }\n}\n"}
{"id": 165450, "name": "Same fringe", "source": "Translate Ruby to Python: var trees = [\n    \n    [ 'd', [ 'c', [ 'a', 'b', ], ], ],\n    [ [ 'd', 'c' ], [ 'a', 'b' ] ],\n    [ [ [ 'd', 'c', ], 'a', ], 'b', ],\n    \n    [ [ [ [ [ [ 'a' ], 'b' ], 'c', ], 'd', ], 'e', ], 'f' ],\n]\n\u00a0\nfunc get_tree_iterator(*rtrees) {\n    var tree\n    func {\n        tree = rtrees.pop\n        while (defined(tree) && tree.kind_of(Array)) {\n            rtrees.append(tree[1])\n            tree = tree[0]\n        }\n        return tree\n    }\n}\n\u00a0\nfunc cmp_fringe(a, b) {\n    var ti1 = get_tree_iterator(a)\n    var ti2 = get_tree_iterator(b)\n    loop {\n        var (L, R) = (ti1(), ti2())\n         defined(L) &&  defined(R) && (L == R) && next\n       \u00a0!defined(L) &&\u00a0!defined(R) && return \"Same\"\n        return \"Different\"\n    }\n}\n\u00a0\nfor idx in ^(trees.end) {\n    say (\"tree[\n           cmp_fringe(trees[idx], trees[idx+1]))\n}\n", "target": "try:\n    from itertools import zip_longest as izip_longest \nexcept:\n    from itertools import izip_longest                \n\ndef fringe(tree):\n    \n    for node1 in tree:\n        if isinstance(node1, tuple):\n            for node2 in fringe(node1):\n                yield node2\n        else:\n            yield node1\n\ndef same_fringe(tree1, tree2):\n    return all(node1 == node2 for node1, node2 in\n               izip_longest(fringe(tree1), fringe(tree2)))\n\nif __name__ == '__main__':\n    a = 1, 2, 3, 4, 5, 6, 7, 8\n    b = 1, (( 2, 3 ), (4, (5, ((6, 7), 8))))\n    c = (((1, 2), 3), 4), 5, 6, 7, 8\n\n    x = 1, 2, 3, 4, 5, 6, 7, 8, 9\n    y = 0, 2, 3, 4, 5, 6, 7, 8\n    z = 1, 2, (4, 3), 5, 6, 7, 8\n\n    assert same_fringe(a, a)\n    assert same_fringe(a, b)\n    assert same_fringe(a, c)\n\n    assert not same_fringe(a, x)\n    assert not same_fringe(a, y)\n    assert not same_fringe(a, z)\n"}
